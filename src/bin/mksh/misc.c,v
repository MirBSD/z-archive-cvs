head	1.296;
access;
symbols
	mksh-R57:1.293
	mksh-R56c:1.291
	mksh-R56b:1.279
	mksh-R56:1.279
	mksh-R55:1.255
	mksh-R54:1.249
	mksh-R53a:1.245
	mksh-R53:1.245
	mksh-R52c:1.242
	mksh-R52b:1.240
	mksh-R52:1.240
	mksh-R51:1.238
	mksh-R50f:1.219.2.3
	mksh-R50e:1.219.2.2
	mksh-R50stable:1.219.0.2
	mksh-R50d:1.219
	mksh-R50c:1.219
	mksh-R50b:1.219
	mksh-R50:1.219
	mksh-R49:1.219
	mksh-R48b:1.214
	mksh-R48:1.214
	mksh-R47:1.213
	mksh-R46:1.211
	mksh-R45:1.209
	mksh-R44:1.207
	mksh-R43:1.205
	mksh-R42b:1.205
	mksh-R41c:1.201.2.3
	mksh-R41b:1.201.2.3
	mksh-R42:1.205
	mksh-R41:1.201
	mksh-R41stable:1.201.0.2
	mksh-wheezy:1.194.0.2
	tg-multikey-bind:1.193.0.2
	mksh-R40f:1.167.2.5
	mksh-R40e:1.167.2.4
	mksh-R40d:1.167.2.3
	mksh-R40c:1.167.2.1
	mksh-R40b:1.167
	mksh-R40stable:1.167.0.2
	mksh-R40:1.167
	mksh-R39c:1.138
	mksh-R39b:1.138
	tg-wcswidth-behaviour:1.131.0.2
	tg-nameref:1.118.0.2
	mksh-R39:1.114
	tg-mksh-printf-builtin:1.111.0.2
	mksh-R38c:1.110
	mksh-R38b:1.108
	mksh-R38:1.107
	mksh-R37c:1.103
	mksh-R37b:1.102
	mksh-R37:1.99
	mksh-R36b:1.93.2.1
	tg-aalloc-experimental_BASE:1.91
	tg-aalloc-experimental:1.91.0.2
	mksh-R36:1.86
	mksh-R35b:1.85
	mksh-R35:1.79
	mksh-R33d:1.72
	mksh-R33c:1.71
	mksh-R33b:1.69
	MIRBSD_10:1.68.0.2
	MIRBSD_10_BASE:1.68
	mksh-R33:1.68
	mksh-R32:1.67
	mksh-R31d:1.66
	mksh-R31c:1.66
	mksh-R31b:1.66
	mksh-R31:1.65
	mksh-R30:1.64
	mksh-R29g:1.52.2.2
	mksh-R29f:1.52.2.1
	mksh-R29e:1.52.2.1
	mksh-R29stable:1.52.0.2
	mksh-R29d:1.52
	mksh-R29c:1.52
	mksh-R29b:1.52
	mksh-R29:1.52
	mksh-R28:1.16
	tg-mksh-plan9ape_BASE:1.16
	tg-mksh-plan9ape:1.13.0.2
	mksh-R27e:1.11
	MIRBSD_9_BASE:1.11
	mksh-R27d:1.11
	mksh-R27:1.11
	mksh-R26c:1.10
	mksh-R26b:1.10
	MIRBSD_8:1.10.0.2
	MIRBSD_8_BASE:1.10
	mksh-R26:1.10
	mksh-R25:1.8
	mksh-R24c:1.7
	mksh-R24b:1.7
	mksh-R24:1.7
	mksh-R23:1.4
	mksh-R22:1.4
	mksh-R21:1.3;
locks; strict;
comment	@ * @;


1.296
date	2019.12.11.23.58.19;	author tg;	state Exp;
branches;
next	1.295;
commitid	1005DF182AD50645981;

1.295
date	2019.12.11.21.47.27;	author tg;	state Exp;
branches;
next	1.294;
commitid	1005DF163FC1B2BE44D;

1.294
date	2019.12.11.20.11.13;	author tg;	state Exp;
branches;
next	1.293;
commitid	1005DF14D4D1BAFC22E;

1.293
date	2018.08.10.02.53.35;	author tg;	state Exp;
branches;
next	1.292;
commitid	1005B6CFE0B5BDFE404;

1.292
date	2018.03.17.22.46.09;	author tg;	state Exp;
branches;
next	1.291;
commitid	1005AAD9AB546CBB14D;

1.291
date	2018.01.14.00.03.03;	author tg;	state Exp;
branches;
next	1.290;
commitid	1005A5A9E3D208A81CB;

1.290
date	2018.01.13.23.58.32;	author tg;	state Exp;
branches;
next	1.289;
commitid	1005A5A9D40184FC2AC;

1.289
date	2018.01.13.23.55.12;	author tg;	state Exp;
branches;
next	1.288;
commitid	1005A5A9C627E45C2B1;

1.288
date	2017.10.15.20.21.51;	author tg;	state Exp;
branches;
next	1.287;
commitid	10059E3C33F0AB3D2C5;

1.287
date	2017.10.14.20.11.30;	author tg;	state Exp;
branches;
next	1.286;
commitid	10059E26F7E043E5515;

1.286
date	2017.10.12.15.17.03;	author tg;	state Exp;
branches;
next	1.285;
commitid	10059DF878300BC6807;

1.285
date	2017.10.11.23.48.36;	author tg;	state Exp;
branches;
next	1.284;
commitid	10059DEADB56A033CC5;

1.284
date	2017.10.11.23.23.02;	author tg;	state Exp;
branches;
next	1.283;
commitid	10059DEA793272A5286;

1.283
date	2017.10.11.21.49.06;	author tg;	state Exp;
branches;
next	1.282;
commitid	10059DE91E92ABC4B24;

1.282
date	2017.10.11.20.46.14;	author tg;	state Exp;
branches;
next	1.281;
commitid	10059DE83287E3B2814;

1.281
date	2017.10.11.19.06.44;	author tg;	state Exp;
branches;
next	1.280;
commitid	10059DE6BD421D60423;

1.280
date	2017.10.10.21.30.43;	author tg;	state Exp;
branches;
next	1.279;
commitid	10059DD3B89156C2B99;

1.279
date	2017.08.07.21.39.25;	author tg;	state Exp;
branches;
next	1.278;
commitid	1005988DE2644315248;

1.278
date	2017.08.07.20.49.41;	author tg;	state Exp;
branches;
next	1.277;
commitid	1005988D271333D0EFB;

1.277
date	2017.05.05.22.53.30;	author tg;	state Exp;
branches;
next	1.276;
commitid	100590D026845CD3DFF;

1.276
date	2017.05.05.19.43.52;	author tg;	state Exp;
branches;
next	1.275;
commitid	100590CD60A12E221FB;

1.275
date	2017.05.03.17.48.08;	author tg;	state Exp;
branches;
next	1.274;
commitid	100590A17CE405AEE2E;

1.274
date	2017.05.01.19.44.29;	author tg;	state Exp;
branches;
next	1.273;
commitid	100590790345DC952B2;

1.273
date	2017.05.01.15.59.45;	author tg;	state Exp;
branches;
next	1.272;
commitid	10059075B7C780B45D4;

1.272
date	2017.04.29.22.04.29;	author tg;	state Exp;
branches;
next	1.271;
commitid	10059050DFF02CF9B3E;

1.271
date	2017.04.29.21.49.07;	author tg;	state Exp;
branches;
next	1.270;
commitid	10059050A1F555381AA;

1.270
date	2017.04.28.21.43.30;	author tg;	state Exp;
branches;
next	1.269;
commitid	1005903B79C5D16A9CC;

1.269
date	2017.04.28.11.13.48;	author tg;	state Exp;
branches;
next	1.268;
commitid	100590323E86CD0E167;

1.268
date	2017.04.28.03.46.49;	author tg;	state Exp;
branches;
next	1.267;
commitid	1005902BB2B4D4574E0;

1.267
date	2017.04.28.03.28.18;	author tg;	state Exp;
branches;
next	1.266;
commitid	1005902B6DC3ECE3910;

1.266
date	2017.04.28.02.24.57;	author tg;	state Exp;
branches;
next	1.265;
commitid	1005902A8007F54B819;

1.265
date	2017.04.28.00.49.33;	author tg;	state Exp;
branches;
next	1.264;
commitid	100590291AF6848CD3A;

1.264
date	2017.04.28.00.38.31;	author tg;	state Exp;
branches;
next	1.263;
commitid	10059028F0E0808B3E9;

1.263
date	2017.04.27.23.34.20;	author tg;	state Exp;
branches;
next	1.262;
commitid	100590280135F493720;

1.262
date	2017.04.27.23.12.47;	author tg;	state Exp;
branches;
next	1.261;
commitid	10059027AFC0DEF48C9;

1.261
date	2017.04.27.20.22.26;	author tg;	state Exp;
branches;
next	1.260;
commitid	1005902531266D3FCB6;

1.260
date	2017.04.27.19.33.52;	author tg;	state Exp;
branches;
next	1.259;
commitid	100590247A92C66CAF9;

1.259
date	2017.04.27.19.16.08;	author tg;	state Exp;
branches;
next	1.258;
commitid	1005902438A577EF826;

1.258
date	2017.04.21.20.06.05;	author tg;	state Exp;
branches;
next	1.257;
commitid	10058FA66392543430F;

1.257
date	2017.04.21.19.50.08;	author tg;	state Exp;
branches;
next	1.256;
commitid	10058FA61D94E9BD833;

1.256
date	2017.04.20.16.34.39;	author tg;	state Exp;
branches;
next	1.255;
commitid	10058F8E33929DD5F44;

1.255
date	2017.04.12.16.46.22;	author tg;	state Exp;
branches;
next	1.254;
commitid	10058EE59ED44DAA3D5;

1.254
date	2017.04.02.13.08.06;	author tg;	state Exp;
branches;
next	1.253;
commitid	10058E0F79F196EC7B8;

1.253
date	2017.03.26.00.10.24;	author tg;	state Exp;
branches;
next	1.252;
commitid	10058D706207E0A1FF4;

1.252
date	2017.03.11.23.56.17;	author tg;	state Exp;
branches;
next	1.251;
commitid	10058C48EB05CCA29F2;

1.251
date	2017.02.18.02.33.13;	author tg;	state Exp;
branches;
next	1.250;
commitid	10058A7B271530B4CED;

1.250
date	2016.11.12.03.54.48;	author tg;	state Exp;
branches;
next	1.249;
commitid	100582692904AD1579B;

1.249
date	2016.11.11.23.31.35;	author tg;	state Exp;
branches;
next	1.248;
commitid	100582654B972655F84;

1.248
date	2016.11.11.21.13.25;	author tg;	state Exp;
branches;
next	1.247;
commitid	1005826347D6811313F;

1.247
date	2016.11.11.20.22.52;	author tg;	state Exp;
branches;
next	1.246;
commitid	100582628A62C64D865;

1.246
date	2016.11.11.20.14.18;	author tg;	state Exp;
branches;
next	1.245;
commitid	100582626A23DD889A9;

1.245
date	2016.08.01.18.42.42;	author tg;	state Exp;
branches;
next	1.244;
commitid	100579F982F7FDB005E;

1.244
date	2016.07.25.20.36.28;	author tg;	state Exp;
branches;
next	1.243;
commitid	1005796785B4D2EFC61;

1.243
date	2016.07.25.00.04.45;	author tg;	state Exp;
branches;
next	1.242;
commitid	1005795579F14A3FE5C;

1.242
date	2016.03.04.14.26.13;	author tg;	state Exp;
branches;
next	1.241;
commitid	10056D99B037D4D691D;

1.241
date	2016.01.21.18.24.43;	author tg;	state Exp;
branches;
next	1.240;
commitid	10056A12268001BF859;

1.240
date	2015.10.09.16.11.17;	author tg;	state Exp;
branches;
next	1.239;
commitid	1005617E72E4A2BA371;

1.239
date	2015.09.05.19.19.07;	author tg;	state Exp;
branches;
next	1.238;
commitid	10055EB402C54C3076B;

1.238
date	2015.07.10.19.36.36;	author tg;	state Exp;
branches;
next	1.237;
commitid	10055A01EBD784EE31A;

1.237
date	2015.07.09.20.52.41;	author tg;	state Exp;
branches;
next	1.236;
commitid	100559EDF161DEE9DD2;

1.236
date	2015.07.05.14.58.33;	author tg;	state Exp;
branches;
next	1.235;
commitid	100559946194B5E57C2;

1.235
date	2015.07.05.14.47.41;	author tg;	state Exp;
branches;
next	1.234;
commitid	1005599439A66F5F3A8;

1.234
date	2015.07.05.14.43.07;	author tg;	state Exp;
branches;
next	1.233;
commitid	100559942841CED5205;

1.233
date	2015.07.05.14.33.21;	author tg;	state Exp;
branches;
next	1.232;
commitid	1005599402D246984F3;

1.232
date	2015.05.01.23.16.30;	author tg;	state Exp;
branches;
next	1.231;
commitid	100554409082C43CC56;

1.231
date	2015.04.29.20.21.35;	author tg;	state Exp;
branches;
next	1.230;
commitid	10055413D670885EEE5;

1.230
date	2015.04.29.20.16.48;	author tg;	state Exp;
branches;
next	1.229;
commitid	10055413C49781058E3;

1.229
date	2015.04.29.20.07.34;	author tg;	state Exp;
branches;
next	1.228;
commitid	100554139453DB97755;

1.228
date	2015.04.29.18.38.52;	author tg;	state Exp;
branches;
next	1.227;
commitid	100554125524190E2D8;

1.227
date	2015.04.29.18.32.44;	author tg;	state Exp;
branches;
next	1.226;
commitid	100554123E246E02963;

1.226
date	2015.03.20.21.46.40;	author tg;	state Exp;
branches;
next	1.225;
commitid	100550C95382C9C0F05;

1.225
date	2015.03.01.15.23.04;	author tg;	state Exp;
branches;
next	1.224;
commitid	10054F32EE078DD628C;

1.224
date	2015.01.25.15.23.41;	author tg;	state Exp;
branches;
next	1.223;
commitid	10054C50A720861330B;

1.223
date	2015.01.02.13.21.28;	author tg;	state Exp;
branches;
next	1.222;
commitid	10054A69B5C737AE4A2;

1.222
date	2015.01.02.08.18.44;	author tg;	state Exp;
branches;
next	1.221;
commitid	10054A654645ECD6C28;

1.221
date	2014.11.25.21.13.29;	author tg;	state Exp;
branches;
next	1.220;
commitid	1005474F00E09321C83;

1.220
date	2014.11.25.20.00.39;	author tg;	state Exp;
branches;
next	1.219;
commitid	1005474DFFB1DC897E5;

1.219
date	2014.01.05.21.57.27;	author tg;	state Exp;
branches
	1.219.2.1;
next	1.218;
commitid	10052C9D445413B34DF;

1.218
date	2013.11.30.17.33.50;	author tg;	state Exp;
branches;
next	1.217;
commitid	100529A2193602D314C;

1.217
date	2013.11.17.22.22.53;	author tg;	state Exp;
branches;
next	1.216;
commitid	100528941C810C8A893;

1.216
date	2013.10.09.11.59.29;	author tg;	state Exp;
branches;
next	1.215;
commitid	10052554535524C4C97;

1.215
date	2013.08.23.14.07.36;	author tg;	state Exp;
branches;
next	1.214;
commitid	10052176CB912FE954B;

1.214
date	2013.08.11.14.57.09;	author tg;	state Exp;
branches;
next	1.213;
commitid	1005207A65963070688;

1.213
date	2013.07.21.18.47.20;	author tg;	state Exp;
branches;
next	1.212;
commitid	10051EC2CBD68BDF6A5;

1.212
date	2013.06.03.22.28.05;	author tg;	state Exp;
branches;
next	1.211;
commitid	10051AD188C1F05BE20;

1.211
date	2013.05.02.20.21.44;	author tg;	state Exp;
branches;
next	1.210;
commitid	1005182CAE814B1B129;

1.210
date	2013.04.27.19.09.13;	author tg;	state Exp;
branches;
next	1.209;
commitid	100517C22710F79B7DA;

1.209
date	2013.04.26.19.10.58;	author tg;	state Exp;
branches;
next	1.208;
commitid	100517AD14E22C17EA0;

1.208
date	2013.04.01.02.37.51;	author tg;	state Exp;
branches;
next	1.207;
commitid	1005158F2D44922CF13;

1.207
date	2013.02.24.14.22.43;	author tg;	state Exp;
branches;
next	1.206;
commitid	100512A22416D5A6B55;

1.206
date	2013.02.24.14.10.04;	author tg;	state Exp;
branches;
next	1.205;
commitid	100512A1F4D5F4A3F6F;

1.205
date	2012.12.17.23.18.08;	author tg;	state Exp;
branches;
next	1.204;
commitid	10050CFA81334F40D7F;

1.204
date	2012.12.05.19.38.22;	author tg;	state Exp;
branches;
next	1.203;
commitid	10050BFA2C0046FB3B9;

1.203
date	2012.12.04.01.18.31;	author tg;	state Exp;
branches;
next	1.202;
commitid	10050BD4F7642624FD1;

1.202
date	2012.12.04.01.12.11;	author tg;	state Exp;
branches;
next	1.201;
commitid	10050BD4E043FF1DB7C;

1.201
date	2012.11.30.17.34.46;	author tg;	state Exp;
branches
	1.201.2.1;
next	1.200;
commitid	10050B8EE4E54495B0F;

1.200
date	2012.10.22.20.52.47;	author tg;	state Exp;
branches;
next	1.199;
commitid	1005085B2164C54559E;

1.199
date	2012.10.03.17.24.21;	author tg;	state Exp;
branches;
next	1.198;
commitid	100506C74D35719B33B;

1.198
date	2012.10.03.15.13.33;	author tg;	state Exp;
branches;
next	1.197;
commitid	100506C56316A8B5F1D;

1.197
date	2012.07.30.21.37.13;	author tg;	state Exp;
branches;
next	1.196;
commitid	1005016FE9B27F9F4DC;

1.196
date	2012.07.20.21.18.45;	author tg;	state Exp;
branches;
next	1.195;
commitid	1005009CAF806EB6B69;

1.195
date	2012.07.01.15.54.56;	author tg;	state Exp;
branches;
next	1.194;
commitid	1004FF072DE3F1A3116;

1.194
date	2012.06.26.19.22.19;	author tg;	state Exp;
branches;
next	1.193;
commitid	1004FEA0BF87993D98F;

1.193
date	2012.05.05.17.37.43;	author tg;	state Exp;
branches;
next	1.192;
commitid	1004FA5657C4457F07B;

1.192
date	2012.05.05.15.10.39;	author tg;	state Exp;
branches;
next	1.191;
commitid	1004FA542E658930BDA;

1.191
date	2012.05.04.22.05.02;	author tg;	state Exp;
branches;
next	1.190;
commitid	1004FA452A16C9E34E1;

1.190
date	2012.05.04.21.57.38;	author tg;	state Exp;
branches;
next	1.189;
commitid	1004FA450E704CFDFF0;

1.189
date	2012.05.04.20.49.06;	author tg;	state Exp;
branches;
next	1.188;
commitid	1004FA4409A67B135DE;

1.188
date	2012.05.04.20.08.25;	author tg;	state Exp;
branches;
next	1.187;
commitid	1004FA4373D2C11CAC3;

1.187
date	2012.04.06.12.59.27;	author tg;	state Exp;
branches;
next	1.186;
commitid	1004F7EE8B85815EBA4;

1.186
date	2012.04.01.16.55.16;	author tg;	state Exp;
branches;
next	1.185;
commitid	1004F78886806E0931E;

1.185
date	2012.03.26.20.04.05;	author tg;	state Exp;
branches;
next	1.184;
commitid	1004F70CBB9583CA90E;

1.184
date	2012.03.23.21.58.22;	author tg;	state Exp;
branches;
next	1.183;
commitid	1004F6CF1C82CE9B908;

1.183
date	2012.03.23.20.07.11;	author tg;	state Exp;
branches;
next	1.182;
commitid	1004F6CD8052D2FFA5E;

1.182
date	2012.01.04.22.38.33;	author tg;	state Exp;
branches;
next	1.181;
commitid	1004F04D50079B983FD;

1.181
date	2012.01.04.19.09.35;	author tg;	state Exp;
branches;
next	1.180;
commitid	1004F04A401028F581D;

1.180
date	2011.12.29.22.54.20;	author tg;	state Exp;
branches;
next	1.179;
commitid	1004EFCEFA861A142CF;

1.179
date	2011.12.03.00.03.25;	author tg;	state Exp;
branches;
next	1.178;
commitid	1004ED9676422AE42AD;

1.178
date	2011.12.03.00.01.27;	author tg;	state Exp;
branches;
next	1.177;
commitid	1004ED966E04423C3DF;

1.177
date	2011.10.26.20.46.15;	author tg;	state Exp;
branches;
next	1.176;
commitid	1004EA871AC0D94FE1C;

1.176
date	2011.10.25.22.36.37;	author tg;	state Exp;
branches;
next	1.175;
commitid	1004EA73A0B4E5C1903;

1.175
date	2011.10.25.22.25.06;	author tg;	state Exp;
branches;
next	1.174;
commitid	1004EA7375829799438;

1.174
date	2011.10.24.19.40.58;	author tg;	state Exp;
branches;
next	1.173;
commitid	1004EA5BF612F516747;

1.173
date	2011.10.24.19.40.46;	author tg;	state Exp;
branches;
next	1.172;
commitid	1004EA5BF552B8478DC;

1.172
date	2011.09.07.15.24.18;	author tg;	state Exp;
branches;
next	1.171;
commitid	1004E678C6929FE60A6;

1.171
date	2011.08.27.18.06.49;	author tg;	state Exp;
branches;
next	1.170;
commitid	1004E5932432420AA61;

1.170
date	2011.08.27.17.30.07;	author tg;	state Exp;
branches;
next	1.169;
commitid	1004E5929AF6944B2F7;

1.169
date	2011.07.06.22.21.57;	author tg;	state Exp;
branches;
next	1.168;
commitid	1004E14E010182825E7;

1.168
date	2011.06.12.15.37.08;	author tg;	state Exp;
branches;
next	1.167;
commitid	1004DF4DD33162FB258;

1.167
date	2011.06.12.14.45.34;	author tg;	state Exp;
branches
	1.167.2.1;
next	1.166;
commitid	1004DF4D1244225E067;

1.166
date	2011.05.29.02.18.53;	author tg;	state Exp;
branches;
next	1.165;
commitid	1004DE1AD11046BEFFC;

1.165
date	2011.05.04.23.16.02;	author tg;	state Exp;
branches;
next	1.164;
commitid	1004DC1DE466716BC29;

1.164
date	2011.03.28.21.31.01;	author tg;	state Exp;
branches;
next	1.163;
commitid	1004D90FE1962742D4E;

1.163
date	2011.03.26.21.46.03;	author tg;	state Exp;
branches;
next	1.162;
commitid	1004D8E5E8E09438DF7;

1.162
date	2011.03.26.21.09.09;	author tg;	state Exp;
branches;
next	1.161;
commitid	1004D8E55EE760E733C;

1.161
date	2011.03.26.19.43.48;	author tg;	state Exp;
branches;
next	1.160;
commitid	1004D8E4204410B09C9;

1.160
date	2011.03.26.19.29.41;	author tg;	state Exp;
branches;
next	1.159;
commitid	1004D8E3E9F05D8FC79;

1.159
date	2011.03.26.15.37.19;	author tg;	state Exp;
branches;
next	1.158;
commitid	1004D8E082927B5293B;

1.158
date	2011.03.24.19.05.48;	author tg;	state Exp;
branches;
next	1.157;
commitid	1004D8B961A2724DA38;

1.157
date	2011.03.17.22.09.22;	author tg;	state Exp;
branches;
next	1.156;
commitid	1004D8286A619CA67D7;

1.156
date	2011.03.17.22.00.45;	author tg;	state Exp;
branches;
next	1.155;
commitid	1004D8284A021AB02D0;

1.155
date	2011.03.17.21.59.28;	author tg;	state Exp;
branches;
next	1.154;
commitid	1004D8284560EEE6F6C;

1.154
date	2011.03.13.01.20.21;	author tg;	state Exp;
branches;
next	1.153;
commitid	1004D7C1BE368F5B459;

1.153
date	2011.03.07.20.30.39;	author tg;	state Exp;
branches;
next	1.152;
commitid	1004D75404D6F4BA14C;

1.152
date	2011.03.05.21.43.17;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004D72AE603B079174;

1.151
date	2011.02.11.01.18.19;	author tg;	state Exp;
branches;
next	1.150;
commitid	1004D548C4E66D17A12;

1.150
date	2011.01.21.21.04.45;	author tg;	state Exp;
branches;
next	1.149;
commitid	1004D39F4C639F3DCA7;

1.149
date	2011.01.09.21.57.27;	author tg;	state Exp;
branches;
next	1.148;
commitid	1004D2A2F086B2268F4;

1.148
date	2010.09.19.19.28.22;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004C96645E6EA59306;

1.147
date	2010.09.14.21.26.15;	author tg;	state Exp;
branches;
next	1.146;
commitid	1004C8FE654576B0E25;

1.146
date	2010.09.14.21.15.10;	author tg;	state Exp;
branches;
next	1.145;
commitid	1004C8FE5D57435CE69;

1.145
date	2010.08.28.20.22.21;	author tg;	state Exp;
branches;
next	1.144;
commitid	1004C796FE40C544CCE;

1.144
date	2010.08.28.18.50.55;	author tg;	state Exp;
branches;
next	1.143;
commitid	1004C795A82072326AF;

1.143
date	2010.08.28.16.47.09;	author tg;	state Exp;
branches;
next	1.142;
commitid	1004C793DA0390DF065;

1.142
date	2010.08.28.15.48.19;	author tg;	state Exp;
branches;
next	1.141;
commitid	1004C792FD945CE393C;

1.141
date	2010.07.17.22.09.36;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004C42295452E71B6E;

1.140
date	2010.07.13.13.07.56;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004C3C65071B4AEB31;

1.139
date	2010.07.04.17.33.55;	author tg;	state Exp;
branches;
next	1.138;
commitid	1004C30C5ED28DF693B;

1.138
date	2010.01.29.09.34.29;	author tg;	state Exp;
branches;
next	1.137;
commitid	1004B62ABB7333ED94C;

1.137
date	2010.01.28.15.18.49;	author tg;	state Exp;
branches;
next	1.136;
commitid	1004B61A9B525E85DF5;

1.136
date	2010.01.25.14.07.39;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004B5DA5BE4FE11A27;

1.135
date	2010.01.01.18.02.00;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004B3E388722B20246;

1.134
date	2009.12.05.17.43.48;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004B1A9BCF3E49BC5B;

1.133
date	2009.11.28.14.28.02;	author tg;	state Exp;
branches;
next	1.132;
commitid	1004B11334F4604E973;

1.132
date	2009.11.28.14.21.45;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004B1131E93EDF1403;

1.131
date	2009.11.23.12.48.19;	author tg;	state Exp;
branches
	1.131.2.1;
next	1.130;
commitid	1004B0A8493141CC535;

1.130
date	2009.11.21.22.30.36;	author tg;	state Exp;
branches;
next	1.129;
commitid	1004B0869F632AFA7FC;

1.129
date	2009.11.09.23.35.10;	author tg;	state Exp;
branches;
next	1.128;
commitid	1004AF8A72F40172587;

1.128
date	2009.10.30.14.37.43;	author tg;	state Exp;
branches;
next	1.127;
commitid	1004AEAFA4D5BAFA082;

1.127
date	2009.10.30.00.57.38;	author tg;	state Exp;
branches;
next	1.126;
commitid	1004AEA39BD3F10ECFA;

1.126
date	2009.10.27.17.00.02;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004AE726F77A03CF56;

1.125
date	2009.10.02.18.08.35;	author tg;	state Exp;
branches;
next	1.124;
commitid	1004AC641341D9D9D02;

1.124
date	2009.09.24.17.15.32;	author tg;	state Exp;
branches;
next	1.123;
commitid	1004ABBA8D95908292B;

1.123
date	2009.09.20.16.40.56;	author tg;	state Exp;
branches;
next	1.122;
commitid	1004AB65AF3542D0922;

1.122
date	2009.09.19.22.32.23;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004AB55BFD3DADFED4;

1.121
date	2009.09.19.21.54.45;	author tg;	state Exp;
branches;
next	1.120;
commitid	1004AB552F7546C611E;

1.120
date	2009.09.19.19.08.47;	author tg;	state Exp;
branches;
next	1.119;
commitid	1004AB52C3C201A31B8;

1.119
date	2009.09.19.15.16.03;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004AB4F5B430F7AA5A;

1.118
date	2009.08.30.13.30.07;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004A9A7EDF06F600FC;

1.117
date	2009.08.28.21.07.26;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004A984722589F219C;

1.116
date	2009.08.28.21.04.16;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004A9846665E529BFC;

1.115
date	2009.08.08.13.08.52;	author tg;	state Exp;
branches;
next	1.114;
commitid	1004A7D785D73D49CFA;

1.114
date	2009.08.01.20.31.47;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004A74A6485E8B4D07;

1.113
date	2009.08.01.20.29.24;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004A74A5AD143467F6;

1.112
date	2009.07.25.21.31.26;	author tg;	state Exp;
branches;
next	1.111;
commitid	1004A6B79B87CB15A8B;

1.111
date	2009.06.11.12.42.20;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004A30FBB114E3FED9;

1.110
date	2009.06.10.18.12.48;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004A2FF7913BD44883;

1.109
date	2009.06.08.20.06.48;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004A2D6F3A31FB4CBC;

1.108
date	2009.05.31.15.10.07;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004A229DBA2308E628;

1.107
date	2009.05.27.09.58.23;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004A1D0E9B4EF3C493;

1.106
date	2009.05.16.18.40.07;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004A0F087409E93A5D;

1.105
date	2009.05.16.16.59.38;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004A0EF0664EF4168D;

1.104
date	2009.04.22.16.46.11;	author tg;	state Exp;
branches;
next	1.103;
commitid	10049EF49D65A3D449D;

1.103
date	2009.04.07.19.51.47;	author tg;	state Exp;
branches;
next	1.102;
commitid	10049DBAEE94DD17BA7;

1.102
date	2009.04.05.12.35.32;	author tg;	state Exp;
branches;
next	1.101;
commitid	10049D8A5A72FBB1A39;

1.101
date	2009.04.03.10.54.58;	author tg;	state Exp;
branches;
next	1.100;
commitid	10049D5EB1A03E284E0;

1.100
date	2009.04.03.09.39.06;	author tg;	state Exp;
branches;
next	1.99;
commitid	10049D5D94A2E5145F0;

1.99
date	2009.03.22.18.09.16;	author tg;	state Exp;
branches;
next	1.98;
commitid	10049C67ED920BB5FB5;

1.98
date	2009.03.22.17.31.17;	author tg;	state Exp;
branches;
next	1.97;
commitid	10049C675F404D09353;

1.97
date	2009.03.14.18.12.53;	author tg;	state Exp;
branches;
next	1.96;
commitid	10049BBF38A0ADEDD54;

1.96
date	2009.02.22.18.53.03;	author tg;	state Exp;
branches;
next	1.95;
commitid	10049A19F23486008A0;

1.95
date	2009.02.22.18.02.31;	author tg;	state Exp;
branches;
next	1.94;
commitid	10049A192E10DAA38C8;

1.94
date	2008.12.17.19.37.08;	author tg;	state Exp;
branches;
next	1.93;
commitid	100494954ED0D36117B;

1.93
date	2008.12.13.17.02.16;	author tg;	state Exp;
branches
	1.93.2.1;
next	1.92;
commitid	1004943EAA830C0300B;

1.92
date	2008.12.04.18.11.06;	author tg;	state Exp;
branches;
next	1.91;
commitid	10049381D2D4EEC022C;

1.91
date	2008.11.12.00.54.50;	author tg;	state Exp;
branches
	1.91.2.1;
next	1.90;
commitid	100491A295841A6D8EB;

1.90
date	2008.11.11.23.50.30;	author tg;	state Exp;
branches;
next	1.89;
commitid	100491A1A3D7C6B56F1;

1.89
date	2008.10.28.14.51.06;	author tg;	state Exp;
branches;
next	1.88;
commitid	100490726E022860659;

1.88
date	2008.10.28.14.32.42;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004907226D3DEFCCD1;

1.87
date	2008.10.26.21.51.26;	author ahoka;	state Exp;
branches;
next	1.86;
commitid	1004904E5B13CEB9815;

1.86
date	2008.10.13.23.06.03;	author tg;	state Exp;
branches;
next	1.85;
commitid	10048F3D44866CCA1C2;

1.85
date	2008.07.18.11.33.12;	author tg;	state Exp;
branches;
next	1.84;
commitid	10048807F804EE06E7A;

1.84
date	2008.07.12.18.24.58;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004878F6B80D9920E5;

1.83
date	2008.07.12.17.56.37;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004878F0635F3A0604;

1.82
date	2008.07.12.17.47.21;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004878EE2A1B7B5C06;

1.81
date	2008.07.12.17.23.00;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004878E8826534BFE6;

1.80
date	2008.07.12.16.26.58;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004878DB4501F6BD98;

1.79
date	2008.05.17.18.47.00;	author tg;	state Exp;
branches;
next	1.78;
commitid	100482F280E7B53AA4C;

1.78
date	2008.05.04.02.02.32;	author tg;	state Exp;
branches;
next	1.77;
commitid	100481D19480574E21F;

1.77
date	2008.04.22.19.00.01;	author tg;	state Exp;
branches;
next	1.76;
commitid	100480E35A1492EB653;

1.76
date	2008.04.22.18.57.26;	author tg;	state Exp;
branches;
next	1.75;
commitid	100480E35217010E6B4;

1.75
date	2008.04.19.22.15.03;	author tg;	state Exp;
branches;
next	1.74;
commitid	100480A6CC85EC0197B;

1.74
date	2008.04.19.17.21.54;	author tg;	state Exp;
branches;
next	1.73;
commitid	100480A2A2B32040FD7;

1.73
date	2008.04.16.21.56.02;	author tg;	state Exp;
branches;
next	1.72;
commitid	100480675E12E8ACD98;

1.72
date	2008.04.11.19.55.23;	author tg;	state Exp;
branches;
next	1.71;
commitid	10047FFC1677D373ADF;

1.71
date	2008.04.01.21.50.58;	author tg;	state Exp;
branches;
next	1.70;
commitid	10047F2AE2966CBAC7A;

1.70
date	2008.04.01.20.40.22;	author tg;	state Exp;
branches;
next	1.69;
commitid	10047F29D740D1FD5B8;

1.69
date	2008.03.23.22.09.58;	author tg;	state Exp;
branches;
next	1.68;
commitid	10047E6D4C4222CC17E;

1.68
date	2008.02.27.01.00.09;	author tg;	state Exp;
branches
	1.68.2.1;
next	1.67;
commitid	10047C4B5C65A58F987;

1.67
date	2007.10.25.15.19.16;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004720B40258F7886E;

1.66
date	2007.09.09.18.06.41;	author tg;	state Exp;
branches;
next	1.65;
commitid	10046E436442CDF8871;

1.65
date	2007.08.12.13.42.21;	author tg;	state Exp;
branches;
next	1.64;
commitid	10046BF0E4F7055959B;

1.64
date	2007.07.26.13.23.51;	author tg;	state Exp;
branches;
next	1.63;
commitid	10046A8A03C41A44494;

1.63
date	2007.07.22.14.01.49;	author tg;	state Exp;
branches;
next	1.62;
commitid	10046A36344350ACD7B;

1.62
date	2007.07.22.13.38.26;	author tg;	state Exp;
branches;
next	1.61;
commitid	10046A35DE715FF102D;

1.61
date	2007.07.22.13.34.51;	author tg;	state Exp;
branches;
next	1.60;
commitid	10046A35CEC35BB7B5F;

1.60
date	2007.07.01.22.17.29;	author tg;	state Exp;
branches;
next	1.59;
commitid	100468827DE7134CF74;

1.59
date	2007.07.01.16.49.17;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004687DB08710A5AB8;

1.58
date	2007.06.15.21.55.19;	author tg;	state Exp;
branches;
next	1.57;
commitid	10046730AA46E14A9D1;

1.57
date	2007.06.06.23.28.16;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004667430836D68E66;

1.56
date	2007.06.06.21.36.29;	author tg;	state Exp;
branches;
next	1.55;
commitid	100466728AC5CB298E8;

1.55
date	2007.06.05.19.48.47;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004665BE264E72FCFA;

1.54
date	2007.05.13.18.33.29;	author tg;	state Exp;
branches;
next	1.53;
commitid	100464759DE15635029;

1.53
date	2007.05.13.17.51.23;	author tg;	state Exp;
branches;
next	1.52;
commitid	10046474FB1292DF336;

1.52
date	2007.03.04.03.04.26;	author tg;	state Exp;
branches
	1.52.2.1;
next	1.51;
commitid	10045EA374B3374AB35;

1.51
date	2007.03.04.00.13.16;	author tg;	state Exp;
branches;
next	1.50;
commitid	10045EA0F2F6674C8B9;

1.50
date	2007.01.26.18.27.34;	author tg;	state Exp;
branches;
next	1.49;
commitid	10045BA47F3716BA1F6;

1.49
date	2007.01.18.20.54.30;	author tg;	state Exp;
branches;
next	1.48;
commitid	10045AFDE8E5FA1161E;

1.48
date	2007.01.18.20.48.23;	author tg;	state Exp;
branches;
next	1.47;
commitid	10045AFDD21386526AD;

1.47
date	2007.01.18.15.50.32;	author tg;	state Exp;
branches;
next	1.46;
commitid	10045AF974442B3F2AC;

1.46
date	2007.01.18.01.01.25;	author tg;	state Exp;
branches;
next	1.45;
commitid	10045AEC6F576A0E2AE;

1.45
date	2007.01.17.23.27.47;	author tg;	state Exp;
branches;
next	1.44;
commitid	10045AEB1062E76AA2B;

1.44
date	2006.11.19.20.43.13;	author tg;	state Exp;
branches
	1.44.2.1;
next	1.43;
commitid	1004560C1B06C73EF4A;

1.43
date	2006.11.16.13.35.07;	author tg;	state Exp;
branches;
next	1.42;
commitid	100455C692216B2C856;

1.42
date	2006.11.12.14.58.15;	author tg;	state Exp;
branches;
next	1.41;
commitid	100455735A7145E26AA;

1.41
date	2006.11.12.13.35.29;	author tg;	state Exp;
branches;
next	1.40;
commitid	100455722FF1E6F1B08;

1.40
date	2006.11.12.12.56.10;	author tg;	state Exp;
branches;
next	1.39;
commitid	100455719F125BF13F8;

1.39
date	2006.11.10.19.11.57;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004554CF043237BEF4;

1.38
date	2006.11.10.07.52.03;	author tg;	state Exp;
branches;
next	1.37;
commitid	10045542F8269E05F56;

1.37
date	2006.11.10.07.18.57;	author tg;	state Exp;
branches;
next	1.36;
commitid	100455427B90A1F6E32;

1.36
date	2006.11.10.06.53.27;	author tg;	state Exp;
branches;
next	1.35;
commitid	100455421CB6900D8A1;

1.35
date	2006.11.10.06.27.09;	author tg;	state Exp;
branches;
next	1.34;
commitid	10045541B9967DE13F7;

1.34
date	2006.11.10.05.21.38;	author tg;	state Exp;
branches;
next	1.33;
commitid	10045540C7858962592;

1.33
date	2006.11.10.04.07.59;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004553FB0076C258F6;

1.32
date	2006.11.10.04.03.59;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004553F9E36E96466A;

1.31
date	2006.11.10.03.54.38;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004553F80D24B48A9F;

1.30
date	2006.11.10.03.45.57;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004553F5FF71731A58;

1.29
date	2006.11.10.03.23.50;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004553F0C348A7A034;

1.28
date	2006.11.10.02.10.45;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004553DFAF581C692B;

1.27
date	2006.11.10.02.05.06;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004553DE4F563F80A0;

1.26
date	2006.11.10.01.52.23;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004553DB3445FC4B16;

1.25
date	2006.11.10.01.44.39;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004553D9465642DE5C;

1.24
date	2006.11.10.01.19.17;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004553D39E1A79289C;

1.23
date	2006.11.10.01.13.52;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004553D1A316532A65;

1.22
date	2006.11.09.23.55.51;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004553BFD0613CC553;

1.21
date	2006.11.09.23.39.16;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004553BC2C6319F8C2;

1.20
date	2006.11.09.20.53.41;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004553955D62299BF9;

1.19
date	2006.11.09.14.19.31;	author tg;	state Exp;
branches;
next	1.18;
commitid	100455339025D8787C5;

1.18
date	2006.11.05.17.01.46;	author tg;	state Exp;
branches;
next	1.17;
commitid	100454E18FF508FB3FE;

1.17
date	2006.11.05.12.11.14;	author tg;	state Exp;
branches;
next	1.16;
commitid	100454DD4E712F5401D;

1.16
date	2006.08.24.20.32.53;	author tg;	state Exp;
branches;
next	1.15;
commitid	10044EE0CE2267A59CF;

1.15
date	2006.08.22.22.49.36;	author tg;	state Exp;
branches;
next	1.14;
commitid	10044EB89CB27D175DB;

1.14
date	2006.08.22.22.16.04;	author tg;	state Exp;
branches;
next	1.13;
commitid	10044EB821E410451C2;

1.13
date	2006.08.09.20.44.15;	author tg;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	10044DA49163318158B;

1.12
date	2006.08.01.13.43.28;	author tg;	state Exp;
branches;
next	1.11;
commitid	10044CF5A93693A5C0A;

1.11
date	2006.05.10.18.54.11;	author tg;	state Exp;
branches;
next	1.10;
commitid	100446236E6726083C8;

1.10
date	2005.11.24.19.39.10;	author tg;	state Exp;
branches;
next	1.9;
commitid	3463438616e1366f;

1.9
date	2005.11.22.18.40.43;	author tg;	state Exp;
branches;
next	1.8;
commitid	108a438366254326;

1.8
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	76cc435e8d34d8ce;

1.7
date	2005.07.07.23.27.52;	author tg;	state Exp;
branches;
next	1.6;
commitid	419f42cdba670de9;

1.6
date	2005.07.04.12.34.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	4a8342c92cd61cc3;

1.5
date	2005.07.04.12.27.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	3ec342c92b3a8874;

1.4
date	2005.05.25.13.46.01;	author tg;	state Exp;
branches;
next	1.3;
commitid	503942948197230c;

1.3
date	2005.05.23.15.54.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	78044291fcc1aba2;

1.2
date	2005.05.23.15.18.16;	author tg;	state Exp;
branches;
next	1.1;
commitid	3dc04291f43ca526;

1.1
date	2005.05.23.03.06.08;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.219.2.1
date	2015.01.25.15.35.48;	author tg;	state Exp;
branches;
next	1.219.2.2;
commitid	10054C50D442D861FBF;

1.219.2.2
date	2015.03.01.15.43.02;	author tg;	state Exp;
branches;
next	1.219.2.3;
commitid	10054F33364551D895A;

1.219.2.3
date	2015.03.20.22.21.04;	author tg;	state Exp;
branches;
next	;
commitid	100550C9D521FCB4274;

1.201.2.1
date	2012.12.04.01.26.28;	author tg;	state Exp;
branches;
next	1.201.2.2;
commitid	10050BD5149729CD584;

1.201.2.2
date	2012.12.05.19.58.32;	author tg;	state Exp;
branches;
next	1.201.2.3;
commitid	10050BFA7766B61F30F;

1.201.2.3
date	2013.02.10.17.11.26;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.167.2.1
date	2011.10.25.22.50.35;	author tg;	state Exp;
branches;
next	1.167.2.2;
commitid	1004EA73D456165B188;

1.167.2.2
date	2011.11.26.18.23.22;	author tg;	state Exp;
branches;
next	1.167.2.3;
commitid	1004ED12E8854A4E765;

1.167.2.3
date	2011.12.04.19.59.47;	author tg;	state Exp;
branches;
next	1.167.2.4;
commitid	1004EDBD1266A61D50A;

1.167.2.4
date	2012.03.24.21.22.38;	author tg;	state Exp;
branches;
next	1.167.2.5;
commitid	1004F6E3A967ACCD93A;

1.167.2.5
date	2012.04.06.14.40.22;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.131.2.1
date	2009.11.28.14.27.53;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.93.2.1
date	2008.12.13.17.43.26;	author tg;	state Exp;
branches;
next	;
commitid	1004943F430159F0440;

1.91.2.1
date	2008.11.22.13.20.34;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.68.2.1
date	2008.04.22.13.29.30;	author tg;	state Exp;
branches;
next	1.68.2.2;
commitid	100480DE80F32BAA72D;

1.68.2.2
date	2008.05.19.18.41.27;	author tg;	state Exp;
branches;
next	1.68.2.3;
commitid	1004831C9A63DA06745;

1.68.2.3
date	2008.07.18.13.29.46;	author tg;	state Exp;
branches;
next	1.68.2.4;
commitid	10048809AD278B142AC;

1.68.2.4
date	2008.12.14.00.07.45;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.52.2.1
date	2007.05.13.19.29.38;	author tg;	state Exp;
branches;
next	1.52.2.2;
commitid	1004647668D4636830B;

1.52.2.2
date	2007.07.05.11.49.21;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.44.2.1
date	2007.03.03.21.37.57;	author tg;	state Exp;
branches;
next	1.44.2.2;
commitid	10045E9EAC27ABA6ADF;

1.44.2.2
date	2007.03.03.22.38.24;	author tg;	state Exp;
branches;
next	1.44.2.3;
commitid	10045E9F8F5395F55BB;

1.44.2.3
date	2007.03.03.23.38.38;	author tg;	state Exp;
branches;
next	;
commitid	10045EA07113BF2F32A;

1.13.2.1
date	2006.08.24.19.23.03;	author tg;	state Exp;
branches;
next	1.13.2.2;
commitid	10044EDFCAA1027810A;

1.13.2.2
date	2006.08.24.20.52.13;	author tg;	state Exp;
branches;
next	1.13.2.3;
commitid	10044EE117A130AF943;

1.13.2.3
date	2006.08.28.01.49.19;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.296
log
@further memory optimisation
@
text
@/*	$OpenBSD: misc.c,v 1.41 2015/09/10 22:48:58 nicm Exp $	*/
/*	$OpenBSD: path.c,v 1.13 2015/09/05 09:47:08 jsg Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2015
 *	Daniel Richard G. <skunk@@iSKUNK.ORG>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"
#if !HAVE_GETRUSAGE
#include <sys/times.h>
#endif
#if HAVE_GRP_H
#include <grp.h>
#endif

__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.295 2019/12/11 21:47:27 tg Exp $");

#define KSH_CHVT_FLAG
#ifdef MKSH_SMALL
#undef KSH_CHVT_FLAG
#endif
#ifdef TIOCSCTTY
#define KSH_CHVT_CODE
#define KSH_CHVT_FLAG
#endif

/* type bits for unsigned char */
unsigned char chtypes[UCHAR_MAX + 1];

static const unsigned char *pat_scan(const unsigned char *,
    const unsigned char *, bool) MKSH_A_PURE;
static int do_gmatch(const unsigned char *, const unsigned char *,
    const unsigned char *, const unsigned char *,
    const unsigned char *) MKSH_A_PURE;
static const unsigned char *gmatch_cclass(const unsigned char *, unsigned char)
    MKSH_A_PURE;
#ifdef KSH_CHVT_CODE
static void chvt(const Getopt *);
#endif

/*XXX this should go away */
static int make_path(const char *, const char *, char **, XString *, int *);

#ifdef SETUID_CAN_FAIL_WITH_EAGAIN
/* we don't need to check for other codes, EPERM won't happen */
#define DO_SETUID(func, argvec) do {					\
	if ((func argvec) && errno == EAGAIN)				\
		errorf("%s failed with EAGAIN, probably due to a"	\
		    " too low process limit; aborting", #func);		\
} while (/* CONSTCOND */ 0)
#else
#define DO_SETUID(func, argvec) func argvec
#endif


/* called from XcheckN() to grow buffer */
char *
Xcheck_grow(XString *xsp, const char *xp, size_t more)
{
	const char *old_beg = xsp->beg;

	if (more < xsp->len)
		more = xsp->len;
	/* (xsp->len + X_EXTRA) never overflows */
	checkoktoadd(more, xsp->len + X_EXTRA);
	xsp->beg = aresize(xsp->beg, (xsp->len += more) + X_EXTRA, xsp->areap);
	xsp->end = xsp->beg + xsp->len;
	return (xsp->beg + (xp - old_beg));
}


#define SHFLAGS_DEFNS
#define FN(sname,cname,flags,ochar)		\
	static const struct {			\
		/* character flag (if any) */	\
		char c;				\
		/* OF_* */			\
		unsigned char optflags;		\
		/* long name of option */	\
		char name[sizeof(sname)];	\
	} shoptione_ ## cname = {		\
		ochar, flags, sname		\
	};
#include "sh_flags.gen"

#define OFC(i) (options[i][-2])
#define OFF(i) (((const unsigned char *)options[i])[-1])
#define OFN(i) (options[i])

const char * const options[] = {
#define SHFLAGS_ITEMS
#include "sh_flags.gen"
};

/*
 * translate -o option into F* constant (also used for test -o option)
 */
size_t
option(const char *n)
{
	size_t i = 0;

	if (ctype(n[0], C_MINUS | C_PLUS) && n[1] && !n[2])
		while (i < NELEM(options)) {
			if (OFC(i) == n[1])
				return (i);
			++i;
		}
	else
		while (i < NELEM(options)) {
			if (!strcmp(OFN(i), n))
				return (i);
			++i;
		}

	return ((size_t)-1);
}

struct options_info {
	int opt_width;
	int opts[NELEM(options)];
};

static void options_fmt_entry(char *, size_t, unsigned int, const void *);
static void printoptions(bool);

/* format a single select menu item */
static void
options_fmt_entry(char *buf, size_t buflen, unsigned int i, const void *arg)
{
	const struct options_info *oi = (const struct options_info *)arg;

	shf_snprintf(buf, buflen, "%-*s %s",
	    oi->opt_width, OFN(oi->opts[i]),
	    Flag(oi->opts[i]) ? "on" : "off");
}

static void
printoptions(bool verbose)
{
	size_t i = 0;

	if (verbose) {
		size_t n = 0, len, octs = 0;
		struct options_info oi;
		struct columnise_opts co;

		/* verbose version */
		shf_puts("Current option settings\n", shl_stdout);

		oi.opt_width = 0;
		while (i < NELEM(options)) {
			if ((len = strlen(OFN(i)))) {
				oi.opts[n++] = i;
				if (len > octs)
					octs = len;
				len = utf_mbswidth(OFN(i));
				if ((int)len > oi.opt_width)
					oi.opt_width = (int)len;
			}
			++i;
		}
		co.shf = shl_stdout;
		co.linesep = '\n';
		co.prefcol = co.do_last = true;
		print_columns(&co, n, options_fmt_entry, &oi,
		    octs + 4, oi.opt_width + 4);
	} else {
		/* short version like AT&T ksh93 */
		shf_puts(Tset, shl_stdout);
		while (i < NELEM(options)) {
			if (Flag(i) && OFN(i)[0])
				shprintf(" -o %s", OFN(i));
			++i;
		}
		shf_putc('\n', shl_stdout);
	}
}

char *
getoptions(void)
{
	size_t i = 0;
	char c, m[(int)FNFLAGS + 1];
	char *cp = m;

	while (i < NELEM(options)) {
		if ((c = OFC(i)) && Flag(i))
			*cp++ = c;
		++i;
	}
	strndupx(cp, m, cp - m, ATEMP);
	return (cp);
}

/* change a Flag(*) value; takes care of special actions */
void
change_flag(enum sh_flag f, int what, bool newset)
{
	unsigned char oldval = Flag(f);
	unsigned char newval = (newset ? 1 : 0);

	if (f == FXTRACE) {
		change_xtrace(newval, true);
		return;
	} else if (f == FPRIVILEGED) {
		if (!oldval)
			/* no getting back dropped privs */
			return;
		else if (!newval) {
			/* turning off -p */
			kshegid = kshgid;
			ksheuid = kshuid;
		} else if (oldval != 3)
			/* nor going full sugid */
			goto change_flag;

		/* +++ set group IDs +++ */
#if HAVE_SETRESUGID
		DO_SETUID(setresgid, (kshegid, kshegid, kshgid));
#else /* !HAVE_SETRESUGID */
		/* setgid, setegid don't EAGAIN on Linux */
		setgid(kshegid);
#ifndef MKSH__NO_SETEUGID
		setegid(kshegid);
#endif /* !MKSH__NO_SETEUGID */
#endif /* !HAVE_SETRESUGID */

		/* +++ wipe groups vector +++ */
#if HAVE_SETGROUPS
		/* setgroups doesn't EAGAIN on Linux */
		setgroups(0, NULL);
#endif /* HAVE_SETGROUPS */

		/* +++ set user IDs +++ */
#if HAVE_SETRESUGID
		DO_SETUID(setresuid, (ksheuid, ksheuid, kshuid));
#else /* !HAVE_SETRESUGID */
		/* seteuid doesn't EAGAIN on Linux */
		DO_SETUID(setuid, (ksheuid));
#ifndef MKSH__NO_SETEUGID
		seteuid(ksheuid);
#endif /* !MKSH__NO_SETEUGID */
#endif /* !HAVE_SETRESUGID */

		/* +++ privs changed +++ */
	} else if ((f == FPOSIX || f == FSH) && newval) {
		/* Turning on -o posix? */
		if (f == FPOSIX)
			/* C locale required for compliance */
			UTFMODE = 0;
		/* Turning on -o posix or -o sh? */
		Flag(FBRACEEXPAND) = 0;
#ifndef MKSH_NO_CMDLINE_EDITING
	} else if ((f == FEMACS ||
#if !MKSH_S_NOVI
	    f == FVI ||
#endif
	    f == FGMACS) && newval) {
#if !MKSH_S_NOVI
		Flag(FVI) = 0;
#endif
		Flag(FEMACS) = Flag(FGMACS) = 0;
#endif
	}

 change_flag:
	Flag(f) = newval;

	if (f == FTALKING) {
		/* Changing interactive flag? */
		if ((what == OF_CMDLINE || what == OF_SET) && procpid == kshpid)
			Flag(FTALKING_I) = newval;
#ifndef MKSH_UNEMPLOYED
	} else if (f == FMONITOR) {
		if (what != OF_CMDLINE && newval != oldval)
			j_change();
#endif
	}
}

void
change_xtrace(unsigned char newval, bool dosnapshot)
{
	static bool in_xtrace;

	if (in_xtrace)
		return;

	if (!dosnapshot && newval == Flag(FXTRACE))
		return;

	if (Flag(FXTRACE) == 2) {
		shf_putc('\n', shl_xtrace);
		Flag(FXTRACE) = 1;
		shf_flush(shl_xtrace);
	}

	if (!dosnapshot && Flag(FXTRACE) == 1)
		switch (newval) {
		case 1:
			return;
		case 2:
			goto changed_xtrace;
		}

	shf_flush(shl_xtrace);
	if (shl_xtrace->fd != 2)
		close(shl_xtrace->fd);
	if (!newval || (shl_xtrace->fd = savefd(2)) == -1)
		shl_xtrace->fd = 2;

 changed_xtrace:
	if ((Flag(FXTRACE) = newval) == 2) {
		in_xtrace = true;
		Flag(FXTRACE) = 0;
		shf_puts(substitute(str_val(global("PS4")), 0), shl_xtrace);
		Flag(FXTRACE) = 2;
		in_xtrace = false;
	}
}

/*
 * Parse command line and set command arguments. Returns the index of
 * non-option arguments, -1 if there is an error.
 */
int
parse_args(const char **argv,
    /* OF_FIRSTTIME, OF_CMDLINE, or OF_SET */
    int what,
    bool *setargsp)
{
	static const char cmd_opts[] =
#define SHFLAGS_NOT_SET
#define SHFLAGS_OPTCS
#include "sh_flags.gen"
#undef SHFLAGS_NOT_SET
	    ;
	static const char set_opts[] =
#define SHFLAGS_NOT_CMD
#define SHFLAGS_OPTCS
#include "sh_flags.gen"
#undef SHFLAGS_NOT_CMD
	    ;
	bool set;
	const char *opts;
	const char *array = NULL;
	Getopt go;
	size_t i;
	int optc, arrayset = 0;
	bool sortargs = false;
	bool fcompatseen = false;

	if (what == OF_CMDLINE) {
		const char *p = argv[0], *q;
		/*
		 * Set FLOGIN before parsing options so user can clear
		 * flag using +l.
		 */
		if (*p != '-')
			for (q = p; *q; )
				if (mksh_cdirsep(*q++))
					p = q;
		Flag(FLOGIN) = (*p == '-');
		opts = cmd_opts;
	} else if (what == OF_FIRSTTIME) {
		opts = cmd_opts;
	} else
		opts = set_opts;
	ksh_getopt_reset(&go, GF_ERROR|GF_PLUSOPT);
	while ((optc = ksh_getopt(argv, &go, opts)) != -1) {
		set = tobool(!(go.info & GI_PLUS));
		switch (optc) {
		case 'A':
			if (what == OF_FIRSTTIME)
				break;
			arrayset = set ? 1 : -1;
			array = go.optarg;
			break;

		case 'o':
			if (what == OF_FIRSTTIME)
				break;
			if (go.optarg == NULL) {
				/*
				 * lone -o: print options
				 *
				 * Note that on the command line, -o requires
				 * an option (ie, can't get here if what is
				 * OF_CMDLINE).
				 */
				printoptions(set);
				break;
			}
			i = option(go.optarg);
			if ((i == FPOSIX || i == FSH) && set && !fcompatseen) {
				/*
				 * If running 'set -o posix' or
				 * 'set -o sh', turn off the other;
				 * if running 'set -o posix -o sh'
				 * allow both to be set though.
				 */
				Flag(FPOSIX) = 0;
				Flag(FSH) = 0;
				fcompatseen = true;
			}
			if ((i != (size_t)-1) && (set ? 1U : 0U) == Flag(i))
				/*
				 * Don't check the context if the flag
				 * isn't changing - makes "set -o interactive"
				 * work if you're already interactive. Needed
				 * if the output of "set +o" is to be used.
				 */
				;
			else if ((i != (size_t)-1) && (OFF(i) & what))
				change_flag((enum sh_flag)i, what, set);
			else {
				bi_errorf(Tf_sD_s, go.optarg,
				    Tunknown_option);
				return (-1);
			}
			break;

#ifdef KSH_CHVT_FLAG
		case 'T':
			if (what != OF_FIRSTTIME)
				break;
#ifndef KSH_CHVT_CODE
			errorf("no TIOCSCTTY ioctl");
#else
			change_flag(FTALKING, OF_CMDLINE, true);
			chvt(&go);
			break;
#endif
#endif

		case '?':
			return (-1);

		default:
			if (what == OF_FIRSTTIME)
				break;
			/* -s: sort positional params (AT&T ksh stupidity) */
			if (what == OF_SET && optc == 's') {
				sortargs = true;
				break;
			}
			for (i = 0; i < NELEM(options); i++)
				if (optc == OFC(i) &&
				    (what & OFF(i))) {
					change_flag((enum sh_flag)i, what, set);
					break;
				}
			if (i == NELEM(options))
				internal_errorf("parse_args: '%c'", optc);
		}
	}
	if (!(go.info & GI_MINUSMINUS) && argv[go.optind] &&
	    ctype(argv[go.optind][0], C_MINUS | C_PLUS) &&
	    argv[go.optind][1] == '\0') {
		/* lone - clears -v and -x flags */
		if (argv[go.optind][0] == '-') {
			Flag(FVERBOSE) = 0;
			change_xtrace(0, false);
		}
		/* set skips lone - or + option */
		go.optind++;
	}
	if (setargsp)
		/* -- means set $#/$* even if there are no arguments */
		*setargsp = !arrayset && ((go.info & GI_MINUSMINUS) ||
		    argv[go.optind]);

	if (arrayset) {
		const char *ccp = NULL;

		if (array && *array)
			ccp = skip_varname(array, false);
		if (!ccp || !(!ccp[0] || (ccp[0] == '+' && !ccp[1]))) {
			bi_errorf(Tf_sD_s, array, Tnot_ident);
			return (-1);
		}
	}
	if (sortargs) {
		for (i = go.optind; argv[i]; i++)
			;
		qsort(&argv[go.optind], i - go.optind, sizeof(void *),
		    ascpstrcmp);
	}
	if (arrayset)
		go.optind += set_array(array, tobool(arrayset > 0),
		    argv + go.optind);

	return (go.optind);
}

/* parse a decimal number: returns 0 if string isn't a number, 1 otherwise */
int
getn(const char *s, int *ai)
{
	char c;
	mksh_ari_u num;
	bool neg = false;

	num.u = 0;

	do {
		c = *s++;
	} while (ctype(c, C_SPACE));

	switch (c) {
	case '-':
		neg = true;
		/* FALLTHROUGH */
	case '+':
		c = *s++;
		break;
	}

	do {
		if (!ctype(c, C_DIGIT))
			/* not numeric */
			return (0);
		if (num.u > 214748364U)
			/* overflow on multiplication */
			return (0);
		num.u = num.u * 10U + (unsigned int)ksh_numdig(c);
		/* now: num.u <= 2147483649U */
	} while ((c = *s++));

	if (num.u > (neg ? 2147483648U : 2147483647U))
		/* overflow for signed 32-bit int */
		return (0);

	if (neg)
		num.u = -num.u;
	*ai = num.i;
	return (1);
}

/**
 * pattern simplifications:
 * - @@(x) -> x (not @@(x|y) though)
 * - ** -> *
 */
static void *
simplify_gmatch_pattern(const unsigned char *sp)
{
	uint8_t c;
	unsigned char *cp, *dp;
	const unsigned char *ps, *se;

	cp = alloc(strlen((const void *)sp) + 1, ATEMP);
	goto simplify_gmatch_pat1a;

	/* foo@@(b@@(a)r)b@@(a|a)z -> foobarb@@(a|a)z */
 simplify_gmatch_pat1:
	sp = cp;
 simplify_gmatch_pat1a:
	dp = cp;
	se = strnul(sp);
	while ((c = *sp++)) {
		if (!ISMAGIC(c)) {
			*dp++ = c;
			continue;
		}
		switch ((c = *sp++)) {
		case 0x80|'@@':
		/* simile for @@ */
		case 0x80|' ':
			/* check whether it has only one clause */
			ps = pat_scan(sp, se, true);
			if (!ps || ps[-1] != /*(*/ ')')
				/* nope */
				break;
			/* copy inner clause until matching close */
			ps -= 2;
			while ((const unsigned char *)sp < ps)
				*dp++ = *sp++;
			/* skip MAGIC and closing parenthesis */
			sp += 2;
			/* copy the rest of the pattern */
			memmove(dp, sp, strlen((const void *)sp) + 1);
			/* redo from start */
			goto simplify_gmatch_pat1;
		}
		*dp++ = MAGIC;
		*dp++ = c;
	}
	*dp = '\0';

	/* collapse adjacent asterisk wildcards */
	sp = dp = cp;
	while ((c = *sp++)) {
		if (!ISMAGIC(c)) {
			*dp++ = c;
			continue;
		}
		switch ((c = *sp++)) {
		case '*':
			while (ISMAGIC(sp[0]) && sp[1] == c)
				sp += 2;
			break;
		}
		*dp++ = MAGIC;
		*dp++ = c;
	}
	*dp = '\0';

	/* return the result, allocated from ATEMP */
	return (cp);
}

/* -------- gmatch.c -------- */

/*
 * int gmatch(string, pattern)
 * char *string, *pattern;
 *
 * Match a pattern as in sh(1).
 * pattern character are prefixed with MAGIC by expand.
 */
int
gmatchx(const char *s, const char *p, bool isfile)
{
	const char *se, *pe;
	char *pnew;
	int rv;

	if (s == NULL || p == NULL)
		return (0);

	pe = strnul(p);
	/*
	 * isfile is false iff no syntax check has been done on
	 * the pattern. If check fails, just do a strcmp().
	 */
	if (!isfile && !has_globbing(p)) {
		size_t len = pe - p + 1;
		char tbuf[64];
		char *t = len <= sizeof(tbuf) ? tbuf : alloc(len, ATEMP);
		debunk(t, p, len);
		return (!strcmp(t, s));
	}
	se = strnul(s);

	/*
	 * since the do_gmatch() engine sucks so much, we must do some
	 * pattern simplifications
	 */
	pnew = simplify_gmatch_pattern((const unsigned char *)p);
	pe = strnul(pnew);

	rv = do_gmatch((const unsigned char *)s, (const unsigned char *)se,
	    (const unsigned char *)pnew, (const unsigned char *)pe,
	    (const unsigned char *)s);
	afree(pnew, ATEMP);
	return (rv);
}

/**
 * Returns if p is a syntacticly correct globbing pattern, false
 * if it contains no pattern characters or if there is a syntax error.
 * Syntax errors are:
 *	- [ with no closing ]
 *	- imbalanced $(...) expression
 *	- [...] and *(...) not nested (eg, @@(a[b|)c], *(a[b|c]d))
 */
/*XXX
 * - if no magic,
 *	if dest given, copy to dst
 *	return ?
 * - if magic && (no globbing || syntax error)
 *	debunk to dst
 *	return ?
 * - return ?
 */
bool
has_globbing(const char *pat)
{
	unsigned char c, subc;
	bool saw_glob = false;
	unsigned int nest = 0;
	const unsigned char *p = (const unsigned char *)pat;
	const unsigned char *s;

	while ((c = *p++)) {
		/* regular character? ok. */
		if (!ISMAGIC(c))
			continue;
		/* MAGIC + NUL? abort. */
		if (!(c = *p++))
			return (false);
		/* some specials */
		if (ord(c) == ORD('*') || ord(c) == ORD('?')) {
			/* easy glob, accept */
			saw_glob = true;
		} else if (ord(c) == ORD('[')) {
			/* bracket expression; eat negation and initial ] */
			if (ISMAGIC(p[0]) && ord(p[1]) == ORD('!'))
				p += 2;
			if (ISMAGIC(p[0]) && ord(p[1]) == ORD(']'))
				p += 2;
			/* check next string part */
			s = p;
			while ((c = *s++)) {
				/* regular chars are ok */
				if (!ISMAGIC(c))
					continue;
				/* MAGIC + NUL cannot happen */
				if (!(c = *s++))
					return (false);
				/* terminating bracket? */
				if (ord(c) == ORD(']')) {
					/* accept and continue */
					p = s;
					saw_glob = true;
					break;
				}
				/* sub-bracket expressions */
				if (ord(c) == ORD('[') && (
				    /* collating element? */
				    ord(*s) == ORD('.') ||
				    /* equivalence class? */
				    ord(*s) == ORD('=') ||
				    /* character class? */
				    ord(*s) == ORD(':'))) {
					/* must stop with exactly the same c */
					subc = *s++;
					/* arbitrarily many chars in betwixt */
					while ((c = *s++))
						/* but only this sequence... */
						if (c == subc && ISMAGIC(*s) &&
						    ord(s[1]) == ORD(']')) {
							/* accept, terminate */
							s += 2;
							break;
						}
					/* EOS without: reject bracket expr */
					if (!c)
						break;
					/* continue; */
				}
				/* anything else just goes on */
			}
		} else if ((c & 0x80) && ctype(c & 0x7F, C_PATMO | C_SPC)) {
			/* opening pattern */
			saw_glob = true;
			++nest;
		} else if (ord(c) == ORD(/*(*/ ')')) {
			/* closing pattern */
			if (nest)
				--nest;
		}
	}
	return (saw_glob && !nest);
}

/* Function must return either 0 or 1 (assumed by code for 0x80|'!') */
static int
do_gmatch(const unsigned char *s, const unsigned char *se,
    const unsigned char *p, const unsigned char *pe,
    const unsigned char *smin)
{
	unsigned char sc, pc, sl = 0;
	const unsigned char *prest, *psub, *pnext;
	const unsigned char *srest;

	if (s == NULL || p == NULL)
		return (0);
	if (s > smin && s <= se)
		sl = s[-1];
	while (p < pe) {
		pc = *p++;
		sc = s < se ? *s : '\0';
		s++;
		if (!ISMAGIC(pc)) {
			if (sc != pc)
				return (0);
			sl = sc;
			continue;
		}
		switch (ord(*p++)) {
		case ORD('['):
			/* BSD cclass extension? */
			if (ISMAGIC(p[0]) && ord(p[1]) == ORD('[') &&
			    ord(p[2]) == ORD(':') &&
			    ctype((pc = p[3]), C_ANGLE) &&
			    ord(p[4]) == ORD(':') &&
			    ISMAGIC(p[5]) && ord(p[6]) == ORD(']') &&
			    ISMAGIC(p[7]) && ord(p[8]) == ORD(']')) {
				/* zero-length match */
				--s;
				p += 9;
				/* word begin? */
				if (ord(pc) == ORD('<') &&
				    !ctype(sl, C_ALNUX) &&
				    ctype(sc, C_ALNUX))
					break;
				/* word end? */
				if (ord(pc) == ORD('>') &&
				    ctype(sl, C_ALNUX) &&
				    !ctype(sc, C_ALNUX))
					break;
				/* neither */
				return (0);
			}
			if (sc == 0 || (p = gmatch_cclass(p, sc)) == NULL)
				return (0);
			break;

		case ORD('?'):
			if (sc == 0)
				return (0);
			if (UTFMODE) {
				--s;
				s += utf_ptradj((const void *)s);
			}
			break;

		case ORD('*'):
			if (p == pe)
				return (1);
			s--;
			do {
				if (do_gmatch(s, se, p, pe, smin))
					return (1);
			} while (s++ < se);
			return (0);

		/**
		 * [+*?@@!](pattern|pattern|..)
		 * This is also needed for ${..%..}, etc.
		 */

		/* matches one or more times */
		case ORD('+') | 0x80:
		/* matches zero or more times */
		case ORD('*') | 0x80:
			if (!(prest = pat_scan(p, pe, false)))
				return (0);
			s--;
			/* take care of zero matches */
			if (ord(p[-1]) == (0x80 | ORD('*')) &&
			    do_gmatch(s, se, prest, pe, smin))
				return (1);
			for (psub = p; ; psub = pnext) {
				pnext = pat_scan(psub, pe, true);
				for (srest = s; srest <= se; srest++) {
					if (do_gmatch(s, srest, psub, pnext - 2, smin) &&
					    (do_gmatch(srest, se, prest, pe, smin) ||
					    (s != srest &&
					    do_gmatch(srest, se, p - 2, pe, smin))))
						return (1);
				}
				if (pnext == prest)
					break;
			}
			return (0);

		/* matches zero or once */
		case ORD('?') | 0x80:
		/* matches one of the patterns */
		case ORD('@@') | 0x80:
		/* simile for @@ */
		case ORD(' ') | 0x80:
			if (!(prest = pat_scan(p, pe, false)))
				return (0);
			s--;
			/* Take care of zero matches */
			if (ord(p[-1]) == (0x80 | ORD('?')) &&
			    do_gmatch(s, se, prest, pe, smin))
				return (1);
			for (psub = p; ; psub = pnext) {
				pnext = pat_scan(psub, pe, true);
				srest = prest == pe ? se : s;
				for (; srest <= se; srest++) {
					if (do_gmatch(s, srest, psub, pnext - 2, smin) &&
					    do_gmatch(srest, se, prest, pe, smin))
						return (1);
				}
				if (pnext == prest)
					break;
			}
			return (0);

		/* matches none of the patterns */
		case ORD('!') | 0x80:
			if (!(prest = pat_scan(p, pe, false)))
				return (0);
			s--;
			for (srest = s; srest <= se; srest++) {
				int matched = 0;

				for (psub = p; ; psub = pnext) {
					pnext = pat_scan(psub, pe, true);
					if (do_gmatch(s, srest, psub,
					    pnext - 2, smin)) {
						matched = 1;
						break;
					}
					if (pnext == prest)
						break;
				}
				if (!matched &&
				    do_gmatch(srest, se, prest, pe, smin))
					return (1);
			}
			return (0);

		default:
			if (sc != p[-1])
				return (0);
			break;
		}
		sl = sc;
	}
	return (s == se);
}

/*XXX this is a prime example for bsearch or a const hashtable */
static const struct cclass {
	const char *name;
	uint32_t value;
} cclasses[] = {
	/* POSIX */
	{ "alnum",	C_ALNUM	},
	{ "alpha",	C_ALPHA	},
	{ "blank",	C_BLANK	},
	{ "cntrl",	C_CNTRL	},
	{ "digit",	C_DIGIT	},
	{ "graph",	C_GRAPH	},
	{ "lower",	C_LOWER	},
	{ "print",	C_PRINT	},
	{ "punct",	C_PUNCT	},
	{ "space",	C_SPACE	},
	{ "upper",	C_UPPER	},
	{ "xdigit",	C_SEDEC	},
	/* BSD */
	/* "<" and ">" are handled inline */
	/* GNU bash */
	{ "ascii",	C_ASCII	},
	{ "word",	C_ALNUX	},
	/* mksh */
	{ "sh_alias",	C_ALIAS	},
	{ "sh_edq",	C_EDQ	},
	{ "sh_ifs",	C_IFS	},
	{ "sh_ifsws",	C_IFSWS	},
	{ "sh_nl",	C_NL	},
	{ "sh_quote",	C_QUOTE	},
	/* sentinel */
	{ NULL,		0	}
};

static const unsigned char *
gmatch_cclass(const unsigned char *pat, unsigned char sc)
{
	unsigned char c, subc, lc;
	const unsigned char *p = pat, *s;
	bool found = false;
	bool negated = false;
	char *subp;

	/* check for negation */
	if (ISMAGIC(p[0]) && ord(p[1]) == ORD('!')) {
		p += 2;
		negated = true;
	}
	/* make initial ] non-MAGIC */
	if (ISMAGIC(p[0]) && ord(p[1]) == ORD(']'))
		++p;
	/* iterate over bracket expression, debunk()ing on the fly */
	while ((c = *p++)) {
 nextc:
		/* non-regular character? */
		if (ISMAGIC(c)) {
			/* MAGIC + NUL cannot happen */
			if (!(c = *p++))
				break;
			/* terminating bracket? */
			if (ord(c) == ORD(']')) {
				/* accept and return */
				return (found != negated ? p : NULL);
			}
			/* sub-bracket expressions */
			if (ord(c) == ORD('[') && (
			    /* collating element? */
			    ord(*p) == ORD('.') ||
			    /* equivalence class? */
			    ord(*p) == ORD('=') ||
			    /* character class? */
			    ord(*p) == ORD(':'))) {
				/* must stop with exactly the same c */
				subc = *p++;
				/* save away start of substring */
				s = p;
				/* arbitrarily many chars in betwixt */
				while ((c = *p++))
					/* but only this sequence... */
					if (c == subc && ISMAGIC(*p) &&
					    ord(p[1]) == ORD(']')) {
						/* accept, terminate */
						p += 2;
						break;
					}
				/* EOS without: reject bracket expr */
				if (!c)
					break;
				/* debunk substring */
				strndupx(subp, s, p - s - 3, ATEMP);
				debunk(subp, subp, p - s - 3 + 1);
 cclass_common:
				/* whither subexpression */
				if (ord(subc) == ORD(':')) {
					const struct cclass *cls = cclasses;

					/* search for name in cclass list */
					while (cls->name)
						if (!strcmp(subp, cls->name)) {
							/* found, match? */
							if (ctype(sc,
							    cls->value))
								found = true;
							/* break either way */
							break;
						} else
							++cls;
					/* that's all here */
					afree(subp, ATEMP);
					continue;
				}
				/* collating element or equivalence class */
				/* Note: latter are treated as former */
				if (ctype(subp[0], C_ASCII) && !subp[1])
					/* [.a.] where a is one ASCII char */
					c = subp[0];
				else
					/* force no match */
					c = 0;
				/* no longer needed */
				afree(subp, ATEMP);
			} else if (!ISMAGIC(c) && (c & 0x80)) {
				/* 0x80|' ' is plain (...) */
				if ((c &= 0x7F) != ' ') {
					/* check single match NOW */
					if (sc == c)
						found = true;
					/* next character is (...) */
				}
				c = '(' /*)*/;
			}
		}
		/* range expression? */
		if (!(ISMAGIC(p[0]) && ord(p[1]) == ORD('-') &&
		    /* not terminating bracket? */
		    (!ISMAGIC(p[2]) || ord(p[3]) != ORD(']')))) {
			/* no, check single match */
			if (sc == c)
				/* note: sc is never NUL */
				found = true;
			/* do the next "first" character */
			continue;
		}
		/* save lower range bound */
		lc = c;
		/* skip over the range operator */
		p += 2;
		/* do the same shit as above... almost */
		subc = 0;
		if (!(c = *p++))
			break;
		/* non-regular character? */
		if (ISMAGIC(c)) {
			/* MAGIC + NUL cannot happen */
			if (!(c = *p++))
				break;
			/* sub-bracket expressions */
			if (ord(c) == ORD('[') && (
			    /* collating element? */
			    ord(*p) == ORD('.') ||
			    /* equivalence class? */
			    ord(*p) == ORD('=') ||
			    /* character class? */
			    ord(*p) == ORD(':'))) {
				/* must stop with exactly the same c */
				subc = *p++;
				/* save away start of substring */
				s = p;
				/* arbitrarily many chars in betwixt */
				while ((c = *p++))
					/* but only this sequence... */
					if (c == subc && ISMAGIC(*p) &&
					    ord(p[1]) == ORD(']')) {
						/* accept, terminate */
						p += 2;
						break;
					}
				/* EOS without: reject bracket expr */
				if (!c)
					break;
				/* debunk substring */
				strndupx(subp, s, p - s - 3, ATEMP);
				debunk(subp, subp, p - s - 3 + 1);
				/* whither subexpression */
				if (ord(subc) == ORD(':')) {
					/* oops, not a range */

					/* match single previous char */
					if (lc && (sc == lc))
						found = true;
					/* match hyphen-minus */
					if (ord(sc) == ORD('-'))
						found = true;
					/* handle cclass common part */
					goto cclass_common;
				}
				/* collating element or equivalence class */
				/* Note: latter are treated as former */
				if (ctype(subp[0], C_ASCII) && !subp[1])
					/* [.a.] where a is one ASCII char */
					c = subp[0];
				else
					/* force no match */
					c = 0;
				/* no longer needed */
				afree(subp, ATEMP);
				/* other meaning below */
				subc = 0;
			} else if (c == (0x80 | ' ')) {
				/* 0x80|' ' is plain (...) */
				c = '(' /*)*/;
			} else if (!ISMAGIC(c) && (c & 0x80)) {
				c &= 0x7F;
				subc = '(' /*)*/;
			}
		}
		/* now do the actual range match check */
		if (lc != 0 /* && c != 0 */ &&
		    asciibetical(lc) <= asciibetical(sc) &&
		    asciibetical(sc) <= asciibetical(c))
			found = true;
		/* forced next character? */
		if (subc) {
			c = subc;
			goto nextc;
		}
		/* otherwise, just go on with the pattern string */
	}
	/* if we broke here, the bracket expression was invalid */
	if (ord(sc) == ORD('['))
		/* initial opening bracket as literal match */
		return (pat);
	/* or rather no match */
	return (NULL);
}

/* Look for next ) or | (if match_sep) in *(foo|bar) pattern */
static const unsigned char *
pat_scan(const unsigned char *p, const unsigned char *pe, bool match_sep)
{
	int nest = 0;

	for (; p < pe; p++) {
		if (!ISMAGIC(*p))
			continue;
		if ((*++p == /*(*/ ')' && nest-- == 0) ||
		    (*p == '|' && match_sep && nest == 0))
			return (p + 1);
		if ((*p & 0x80) && ctype(*p & 0x7F, C_PATMO | C_SPC))
			nest++;
	}
	return (NULL);
}

int
ascstrcmp(const void *s1, const void *s2)
{
	const uint8_t *cp1 = s1, *cp2 = s2;

	while (*cp1 == *cp2) {
		if (*cp1++ == '\0')
			return (0);
		++cp2;
	}
	return ((int)asciibetical(*cp1) - (int)asciibetical(*cp2));
}

int
ascpstrcmp(const void *pstr1, const void *pstr2)
{
	return (ascstrcmp(*(const char * const *)pstr1,
	    *(const char * const *)pstr2));
}

/* Initialise a Getopt structure */
void
ksh_getopt_reset(Getopt *go, int flags)
{
	go->optind = 1;
	go->optarg = NULL;
	go->p = 0;
	go->flags = flags;
	go->info = 0;
	go->buf[1] = '\0';
}


/**
 * getopt() used for shell built-in commands, the getopts command, and
 * command line options.
 * A leading ':' in options means don't print errors, instead return '?'
 * or ':' and set go->optarg to the offending option character.
 * If GF_ERROR is set (and option doesn't start with :), errors result in
 * a call to bi_errorf().
 *
 * Non-standard features:
 *	- ';' is like ':' in options, except the argument is optional
 *	  (if it isn't present, optarg is set to 0).
 *	  Used for 'set -o'.
 *	- ',' is like ':' in options, except the argument always immediately
 *	  follows the option character (optarg is set to the null string if
 *	  the option is missing).
 *	  Used for 'read -u2', 'print -u2' and fc -40.
 *	- '#' is like ':' in options, expect that the argument is optional
 *	  and must start with a digit. If the argument doesn't start with a
 *	  digit, it is assumed to be missing and normal option processing
 *	  continues (optarg is set to 0 if the option is missing).
 *	  Used for 'typeset -LZ4'.
 *	- accepts +c as well as -c IF the GF_PLUSOPT flag is present. If an
 *	  option starting with + is accepted, the GI_PLUS flag will be set
 *	  in go->info.
 */
int
ksh_getopt(const char **argv, Getopt *go, const char *optionsp)
{
	char c;
	const char *o;

	if (go->p == 0 || (c = argv[go->optind - 1][go->p]) == '\0') {
		const char *arg = argv[go->optind], flag = arg ? *arg : '\0';

		go->p = 1;
		if (flag == '-' && ksh_isdash(arg + 1)) {
			go->optind++;
			go->p = 0;
			go->info |= GI_MINUSMINUS;
			return (-1);
		}
		if (arg == NULL ||
		    ((flag != '-' ) &&
		    /* neither a - nor a + (if + allowed) */
		    (!(go->flags & GF_PLUSOPT) || flag != '+')) ||
		    (c = arg[1]) == '\0') {
			go->p = 0;
			return (-1);
		}
		go->optind++;
		go->info &= ~(GI_MINUS|GI_PLUS);
		go->info |= flag == '-' ? GI_MINUS : GI_PLUS;
	}
	go->p++;
	if (ctype(c, C_QUEST | C_COLON | C_HASH) || c == ';' || c == ',' ||
	    !(o = cstrchr(optionsp, c))) {
		if (optionsp[0] == ':') {
			go->buf[0] = c;
			go->optarg = go->buf;
		} else {
			warningf(true, Tf_optfoo,
			    (go->flags & GF_NONAME) ? "" : argv[0],
			    (go->flags & GF_NONAME) ? "" : Tcolsp,
			    c, Tunknown_option);
			if (go->flags & GF_ERROR)
				bi_errorfz();
		}
		return ('?');
	}
	/**
	 * : means argument must be present, may be part of option argument
	 *   or the next argument
	 * ; same as : but argument may be missing
	 * , means argument is part of option argument, and may be null.
	 */
	if (*++o == ':' || *o == ';') {
		if (argv[go->optind - 1][go->p])
			go->optarg = argv[go->optind - 1] + go->p;
		else if (argv[go->optind])
			go->optarg = argv[go->optind++];
		else if (*o == ';')
			go->optarg = NULL;
		else {
			if (optionsp[0] == ':') {
				go->buf[0] = c;
				go->optarg = go->buf;
				return (':');
			}
			warningf(true, Tf_optfoo,
			    (go->flags & GF_NONAME) ? "" : argv[0],
			    (go->flags & GF_NONAME) ? "" : Tcolsp,
			    c, Treq_arg);
			if (go->flags & GF_ERROR)
				bi_errorfz();
			return ('?');
		}
		go->p = 0;
	} else if (*o == ',') {
		/* argument is attached to option character, even if null */
		go->optarg = argv[go->optind - 1] + go->p;
		go->p = 0;
	} else if (*o == '#') {
		/*
		 * argument is optional and may be attached or unattached
		 * but must start with a digit. optarg is set to 0 if the
		 * argument is missing.
		 */
		if (argv[go->optind - 1][go->p]) {
			if (ctype(argv[go->optind - 1][go->p], C_DIGIT)) {
				go->optarg = argv[go->optind - 1] + go->p;
				go->p = 0;
			} else
				go->optarg = NULL;
		} else {
			if (argv[go->optind] &&
			    ctype(argv[go->optind][0], C_DIGIT)) {
				go->optarg = argv[go->optind++];
				go->p = 0;
			} else
				go->optarg = NULL;
		}
	}
	return (c);
}

/*
 * print variable/alias value using necessary quotes
 * (POSIX says they should be suitable for re-entry...)
 * No trailing newline is printed.
 */
void
print_value_quoted(struct shf *shf, const char *s)
{
	unsigned char c;
	const unsigned char *p = (const unsigned char *)s;
	bool inquote = true;

	/* first, special-case empty strings (for re-entrancy) */
	if (!*s) {
		shf_putc('\'', shf);
		shf_putc('\'', shf);
		return;
	}

	/* non-empty; check whether any quotes are needed */
	while (rtt2asc(c = *p++) >= 32)
		if (ctype(c, C_QUOTE | C_SPC))
			inquote = false;

	p = (const unsigned char *)s;
	if (c == 0) {
		if (inquote) {
			/* nope, use the shortcut */
			shf_puts(s, shf);
			return;
		}

		/* otherwise, quote nicely via state machine */
		while ((c = *p++) != 0) {
			if (c == '\'') {
				/*
				 * multiple single quotes or any of them
				 * at the beginning of a string look nicer
				 * this way than when simply substituting
				 */
				if (inquote) {
					shf_putc('\'', shf);
					inquote = false;
				}
				shf_putc('\\', shf);
			} else if (!inquote) {
				shf_putc('\'', shf);
				inquote = true;
			}
			shf_putc(c, shf);
		}
	} else {
		unsigned int wc;
		size_t n;

		/* use $'...' quote format */
		shf_putc('$', shf);
		shf_putc('\'', shf);
		while ((c = *p) != 0) {
#ifndef MKSH_EBCDIC
			if (c >= 0xC2) {
				n = utf_mbtowc(&wc, (const char *)p);
				if (n != (size_t)-1) {
					p += n;
					shf_fprintf(shf, "\\u%04X", wc);
					continue;
				}
			}
#endif
			++p;
			switch (c) {
			/* see unbksl() in this file for comments */
			case KSH_BEL:
				c = 'a';
				if (0)
					/* FALLTHROUGH */
			case '\b':
				  c = 'b';
				if (0)
					/* FALLTHROUGH */
			case '\f':
				  c = 'f';
				if (0)
					/* FALLTHROUGH */
			case '\n':
				  c = 'n';
				if (0)
					/* FALLTHROUGH */
			case '\r':
				  c = 'r';
				if (0)
					/* FALLTHROUGH */
			case '\t':
				  c = 't';
				if (0)
					/* FALLTHROUGH */
			case KSH_VTAB:
				  c = 'v';
				if (0)
					/* FALLTHROUGH */
			case KSH_ESC:
				/* take E not e because \e is \ in *roff */
				  c = 'E';
				/* FALLTHROUGH */
			case '\\':
				shf_putc('\\', shf);

				if (0)
					/* FALLTHROUGH */
			default:
#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
				  if (ksh_isctrl(c))
#else
				  if (!ctype(c, C_PRINT))
#endif
				    {
					/* FALLTHROUGH */
			case '\'':
					shf_fprintf(shf, "\\%03o", c);
					break;
				}

				shf_putc(c, shf);
				break;
			}
		}
		inquote = true;
	}
	if (inquote)
		shf_putc('\'', shf);
}

/*
 * Print things in columns and rows - func() is called to format
 * the i-th element
 */
void
print_columns(struct columnise_opts *opts, unsigned int n,
    void (*func)(char *, size_t, unsigned int, const void *),
    const void *arg, size_t max_oct, size_t max_colz)
{
	unsigned int i, r = 0, c, rows, cols, nspace, max_col;
	char *str;

	if (!n)
		return;

	if (max_colz > 2147483646) {
#ifndef MKSH_SMALL
		internal_warningf("print_columns called with %s=%zu >= INT_MAX",
		    "max_col", max_colz);
#endif
		return;
	}
	max_col = (unsigned int)max_colz;

	if (max_oct > 2147483646) {
#ifndef MKSH_SMALL
		internal_warningf("print_columns called with %s=%zu >= INT_MAX",
		    "max_oct", max_oct);
#endif
		return;
	}
	++max_oct;
	str = alloc(max_oct, ATEMP);

	/*
	 * We use (max_col + 2) to consider the separator space.
	 * Note that no spaces are printed after the last column
	 * to avoid problems with terminals that have auto-wrap,
	 * but we need to also take this into account in x_cols.
	 */
	cols = (x_cols + 1) / (max_col + 2);

	/* if we can only print one column anyway, skip the goo */
	if (cols < 2) {
		goto prcols_easy;
		while (r < n) {
			shf_putc(opts->linesep, opts->shf);
 prcols_easy:
			(*func)(str, max_oct, r++, arg);
			shf_puts(str, opts->shf);
		}
		goto out;
	}

	rows = (n + cols - 1) / cols;
	if (opts->prefcol && cols > rows) {
		cols = rows;
		rows = (n + cols - 1) / cols;
	}

	nspace = (x_cols - max_col * cols) / cols;
	if (nspace < 2)
		nspace = 2;
	max_col = -max_col;
	goto prcols_hard;
	while (r < rows) {
		shf_putchar(opts->linesep, opts->shf);
 prcols_hard:
		for (c = 0; c < cols; c++) {
			if ((i = c * rows + r) >= n)
				break;
			(*func)(str, max_oct, i, arg);
			if (i + rows >= n)
				shf_puts(str, opts->shf);
			else
				shf_fprintf(opts->shf, "%*s%*s",
				    (int)max_col, str, (int)nspace, null);
		}
		++r;
	}
 out:
	if (opts->do_last)
		shf_putchar(opts->linesep, opts->shf);
	afree(str, ATEMP);
}

/* strip all NUL bytes from buf; output is NUL-terminated if stripped */
void
strip_nuls(char *buf, size_t len)
{
	char *cp, *dp, *ep;

	if (!len || !(dp = memchr(buf, '\0', len)))
		return;

	ep = buf + len;
	cp = dp;

 cp_has_nul_byte:
	while (cp++ < ep && *cp == '\0')
		;	/* nothing */
	while (cp < ep && *cp != '\0')
		*dp++ = *cp++;
	if (cp < ep)
		goto cp_has_nul_byte;

	*dp = '\0';
}

/*
 * Like read(2), but if read fails due to non-blocking flag,
 * resets flag and restarts read.
 */
ssize_t
blocking_read(int fd, char *buf, size_t nbytes)
{
	ssize_t ret;
	bool tried_reset = false;

	while ((ret = read(fd, buf, nbytes)) < 0) {
		if (!tried_reset && errno == EAGAIN) {
			if (reset_nonblock(fd) > 0) {
				tried_reset = true;
				continue;
			}
			errno = EAGAIN;
		}
		break;
	}
	return (ret);
}

/*
 * Reset the non-blocking flag on the specified file descriptor.
 * Returns -1 if there was an error, 0 if non-blocking wasn't set,
 * 1 if it was.
 */
int
reset_nonblock(int fd)
{
	int flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) < 0)
		return (-1);
	if (!(flags & O_NONBLOCK))
		return (0);
	flags &= ~O_NONBLOCK;
	if (fcntl(fd, F_SETFL, flags) < 0)
		return (-1);
	return (1);
}

/* getcwd(3) equivalent, allocates from ATEMP but doesn't resize */
char *
ksh_get_wd(void)
{
#ifdef MKSH__NO_PATH_MAX
	char *rv, *cp;

	if ((cp = get_current_dir_name())) {
		strdupx(rv, cp, ATEMP);
		free_gnu_gcdn(cp);
	} else
		rv = NULL;
#else
	char *rv;

	if (!getcwd((rv = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)) {
		afree(rv, ATEMP);
		rv = NULL;
	}
#endif

	return (rv);
}

#ifndef ELOOP
#define ELOOP		E2BIG
#endif

char *
do_realpath(const char *upath)
{
	char *xp, *ip, *tp, *ipath, *ldest = NULL;
	XString xs;
	size_t pos, len;
	int llen;
	struct stat sb;
#ifdef MKSH__NO_PATH_MAX
	size_t ldestlen = 0;
#define pathlen sb.st_size
#define pathcnd (ldestlen < (pathlen + 1))
#else
#define pathlen PATH_MAX
#define pathcnd (!ldest)
#endif
	/* max. recursion depth */
	int symlinks = 32;

	if (mksh_abspath(upath)) {
		/* upath is an absolute pathname */
		strdupx(ipath, upath, ATEMP);
#ifdef MKSH_DOSPATH
	} else if (mksh_drvltr(upath)) {
		/* upath is a drive-relative pathname */
		if (getdrvwd(&ldest, ord(*upath)))
			return (NULL);
		/* A:foo -> A:/cwd/foo; A: -> A:/cwd */
		strpathx(ipath, ldest, upath + 2, 0);
#endif
	} else {
		/* upath is a relative pathname, prepend cwd */
		if ((tp = ksh_get_wd()) == NULL || !mksh_abspath(tp))
			return (NULL);
		strpathx(ipath, tp, upath, 1);
		afree(tp, ATEMP);
	}

	/* ipath and upath are in memory at the same time -> unchecked */
	Xinit(xs, xp, strlen(ip = ipath) + 1, ATEMP);

	/* now jump into the deep of the loop */
	goto beginning_of_a_pathname;

	while (*ip) {
		/* skip slashes in input */
		while (mksh_cdirsep(*ip))
			++ip;
		if (!*ip)
			break;

		/* get next pathname component from input */
		tp = ip;
		while (*ip && !mksh_cdirsep(*ip))
			++ip;
		len = ip - tp;

		/* check input for "." and ".." */
		if (tp[0] == '.') {
			if (len == 1)
				/* just continue with the next one */
				continue;
			else if (len == 2 && tp[1] == '.') {
				/* strip off last pathname component */
				/*XXX consider a rooted pathname */
				while (xp > Xstring(xs, xp))
					if (mksh_cdirsep(*--xp))
						break;
				/* then continue with the next one */
				continue;
			}
		}

		/* store output position away, then append slash to output */
		pos = Xsavepos(xs, xp);
		/* 1 for the '/' and len + 1 for tp and the NUL from below */
		XcheckN(xs, xp, 1 + len + 1);
		Xput(xs, xp, '/');

		/* append next pathname component to output */
		memcpy(xp, tp, len);
		xp += len;
		*xp = '\0';

		/* lstat the current output, see if it's a symlink */
		if (mksh_lstat(Xstring(xs, xp), &sb)) {
			/* lstat failed */
			if (errno == ENOENT) {
				/* because the pathname does not exist */
				while (mksh_cdirsep(*ip))
					/* skip any trailing slashes */
					++ip;
				/* no more components left? */
				if (!*ip)
					/* we can still return successfully */
					break;
				/* more components left? fall through */
			}
			/* not ENOENT or not at the end of ipath */
			goto notfound;
		}

		/* check if we encountered a symlink? */
		if (S_ISLNK(sb.st_mode)) {
#ifndef MKSH__NO_SYMLINK
			/* reached maximum recursion depth? */
			if (!symlinks--) {
				/* yep, prevent infinite loops */
				errno = ELOOP;
				goto notfound;
			}

			/* get symlink(7) target */
			if (pathcnd) {
#ifdef MKSH__NO_PATH_MAX
				if (notoktoadd(pathlen, 1)) {
					errno = ENAMETOOLONG;
					goto notfound;
				}
#endif
				ldest = aresize(ldest, pathlen + 1, ATEMP);
			}
			llen = readlink(Xstring(xs, xp), ldest, pathlen);
			if (llen < 0)
				/* oops... */
				goto notfound;
			ldest[llen] = '\0';

			/*
			 * restart if symlink target is an absolute path,
			 * otherwise continue with currently resolved prefix
			 */
#ifdef MKSH_DOSPATH
 assemble_symlink:
#endif
			/* append rest of current input path to link target */
			strpathx(tp, ldest, ip, 0);
			afree(ipath, ATEMP);
			ip = ipath = tp;
			if (!mksh_abspath(ipath)) {
#ifdef MKSH_DOSPATH
				/* symlink target might be drive-relative */
				if (mksh_drvltr(ipath)) {
					if (getdrvwd(&ldest, ord(*ipath)))
						goto notfound;
					ip += 2;
					goto assemble_symlink;
				}
#endif
				/* symlink target is a relative path */
				xp = Xrestpos(xs, xp, pos);
			} else
#endif
			  {
				/* symlink target is an absolute path */
				xp = Xstring(xs, xp);
 beginning_of_a_pathname:
				/* assert: mksh_abspath(ip == ipath) */
				/* assert: xp == xs.beg => start of path */

				/* exactly two leading slashes? (SUSv4 3.266) */
				if (ip[1] == ip[0] && !mksh_cdirsep(ip[2])) {
					/* keep them, e.g. for UNC pathnames */
					Xput(xs, xp, '/');
				}
#ifdef MKSH_DOSPATH
				/* drive letter? */
				if (mksh_drvltr(ip)) {
					/* keep it */
					Xput(xs, xp, *ip++);
					Xput(xs, xp, *ip++);
				}
#endif
			}
		}
		/* otherwise (no symlink) merely go on */
	}

	/*
	 * either found the target and successfully resolved it,
	 * or found its parent directory and may create it
	 */
	if (Xlength(xs, xp) == 0)
		/*
		 * if the resolved pathname is "", make it "/",
		 * otherwise do not add a trailing slash
		 */
		Xput(xs, xp, '/');
	Xput(xs, xp, '\0');

	/*
	 * if source path had a trailing slash, check if target path
	 * is not a non-directory existing file
	 */
	if (ip > ipath && mksh_cdirsep(ip[-1])) {
		if (stat(Xstring(xs, xp), &sb)) {
			if (errno != ENOENT)
				goto notfound;
		} else if (!S_ISDIR(sb.st_mode)) {
			errno = ENOTDIR;
			goto notfound;
		}
		/* target now either does not exist or is a directory */
	}

	/* return target path */
	afree(ldest, ATEMP);
	afree(ipath, ATEMP);
	return (Xclose(xs, xp));

 notfound:
	/* save; freeing memory might trash it */
	llen = errno;
	afree(ldest, ATEMP);
	afree(ipath, ATEMP);
	Xfree(xs, xp);
	errno = llen;
	return (NULL);

#undef pathlen
#undef pathcnd
}

/**
 *	Makes a filename into result using the following algorithm.
 *	- make result NULL
 *	- if file starts with '/', append file to result & set cdpathp to NULL
 *	- if file starts with ./ or ../ append cwd and file to result
 *	  and set cdpathp to NULL
 *	- if the first element of cdpathp doesnt start with a '/' xx or '.' xx
 *	  then cwd is appended to result.
 *	- the first element of cdpathp is appended to result
 *	- file is appended to result
 *	- cdpathp is set to the start of the next element in cdpathp (or NULL
 *	  if there are no more elements.
 *	The return value indicates whether a non-null element from cdpathp
 *	was appended to result.
 */
static int
make_path(const char *cwd, const char *file,
    /* pointer to colon-separated list */
    char **cdpathp,
    XString *xsp,
    int *phys_pathp)
{
	int rval = 0;
	bool use_cdpath = true;
	char *plist;
	size_t len, plen = 0;
	char *xp = Xstring(*xsp, xp);

	if (!file)
		file = null;

	if (mksh_abspath(file)) {
		*phys_pathp = 0;
		use_cdpath = false;
	} else {
		if (file[0] == '.') {
			char c = file[1];

			if (c == '.')
				c = file[2];
			if (mksh_cdirsep(c) || c == '\0')
				use_cdpath = false;
		}

		plist = *cdpathp;
		if (!plist)
			use_cdpath = false;
		else if (use_cdpath) {
			char *pend = plist;

			while (*pend && *pend != MKSH_PATHSEPC)
				++pend;
			plen = pend - plist;
			*cdpathp = *pend ? pend + 1 : NULL;
		}

		if ((!use_cdpath || !plen || !mksh_abspath(plist)) &&
		    (cwd && *cwd)) {
			len = strlen(cwd);
			XcheckN(*xsp, xp, len);
			memcpy(xp, cwd, len);
			xp += len;
			if (!mksh_cdirsep(cwd[len - 1]))
				Xput(*xsp, xp, '/');
		}
		*phys_pathp = Xlength(*xsp, xp);
		if (use_cdpath && plen) {
			XcheckN(*xsp, xp, plen);
			memcpy(xp, plist, plen);
			xp += plen;
			if (!mksh_cdirsep(plist[plen - 1]))
				Xput(*xsp, xp, '/');
			rval = 1;
		}
	}

	len = strlen(file) + 1;
	XcheckN(*xsp, xp, len);
	memcpy(xp, file, len);

	if (!use_cdpath)
		*cdpathp = NULL;

	return (rval);
}

/*-
 * Simplify pathnames containing "." and ".." entries.
 *
 * simplify_path(this)			= that
 * /a/b/c/./../d/..			/a/b
 * //./C/foo/bar/../baz			//C/foo/baz
 * /foo/				/foo
 * /foo/../../bar			/bar
 * /foo/./blah/..			/foo
 * .					.
 * ..					..
 * ./foo				foo
 * foo/../../../bar			../../bar
 * C:/foo/../..				C:/
 * C:.					C:
 * C:..					C:..
 * C:foo/../../blah			C:../blah
 *
 * XXX consider a rooted pathname: we cannot really 'cd ..' for
 * pathnames like: '/', 'c:/', '//foo', '//foo/', '/@@unixroot/'
 * (no effect), 'c:', 'c:.' (effect is retaining the '../') but
 * we need to honour this throughout the shell
 */
void
simplify_path(char *p)
{
	char *dp, *ip, *sp, *tp;
	size_t len;
	bool needslash;
#ifdef MKSH_DOSPATH
	bool needdot = true;

	/* keep drive letter */
	if (mksh_drvltr(p)) {
		p += 2;
		needdot = false;
	}
#else
#define needdot true
#endif

	switch (*p) {
	case 0:
		return;
	case '/':
#ifdef MKSH_DOSPATH
	case '\\':
#endif
		/* exactly two leading slashes? (SUSv4 3.266) */
		if (p[1] == p[0] && !mksh_cdirsep(p[2]))
			/* keep them, e.g. for UNC pathnames */
			++p;
		needslash = true;
		break;
	default:
		needslash = false;
	}
	dp = ip = sp = p;

	while (*ip) {
		/* skip slashes in input */
		while (mksh_cdirsep(*ip))
			++ip;
		if (!*ip)
			break;

		/* get next pathname component from input */
		tp = ip;
		while (*ip && !mksh_cdirsep(*ip))
			++ip;
		len = ip - tp;

		/* check input for "." and ".." */
		if (tp[0] == '.') {
			if (len == 1)
				/* just continue with the next one */
				continue;
			else if (len == 2 && tp[1] == '.') {
				/* parent level, but how? (see above) */
				if (mksh_abspath(p))
					/* absolute path, only one way */
					goto strip_last_component;
				else if (dp > sp) {
					/* relative path, with subpaths */
					needslash = false;
 strip_last_component:
					/* strip off last pathname component */
					while (dp > sp)
						if (mksh_cdirsep(*--dp))
							break;
				} else {
					/* relative path, at its beginning */
					if (needslash)
						/* or already dotdot-slash'd */
						*dp++ = '/';
					/* keep dotdot-slash if not absolute */
					*dp++ = '.';
					*dp++ = '.';
					needslash = true;
					sp = dp;
				}
				/* then continue with the next one */
				continue;
			}
		}

		if (needslash)
			*dp++ = '/';

		/* append next pathname component to output */
		memmove(dp, tp, len);
		dp += len;

		/* append slash if we continue */
		needslash = true;
		/* try next component */
	}
	if (dp == p) {
		/* empty path -> dot (or slash, when absolute) */
		if (needslash)
			*dp++ = '/';
		else if (needdot)
			*dp++ = '.';
	}
	*dp = '\0';
#undef needdot
}

void
set_current_wd(const char *nwd)
{
	char *allocd = NULL;

	if (nwd == NULL) {
		allocd = ksh_get_wd();
		nwd = allocd ? allocd : null;
	}

	afree(current_wd, APERM);
	strdupx(current_wd, nwd, APERM);

	afree(allocd, ATEMP);
}

int
c_cd(const char **wp)
{
	int optc, rv, phys_path;
	bool physical = tobool(Flag(FPHYSICAL));
	/* was a node from cdpath added in? */
	int cdnode;
	/* show where we went?, error for $PWD */
	bool printpath = false, eflag = false;
	struct tbl *pwd_s, *oldpwd_s;
	XString xs;
	char *dir, *allocd = NULL, *tryp, *pwd, *cdpath;

	while ((optc = ksh_getopt(wp, &builtin_opt, "eLP")) != -1)
		switch (optc) {
		case 'e':
			eflag = true;
			break;
		case 'L':
			physical = false;
			break;
		case 'P':
			physical = true;
			break;
		case '?':
			return (2);
		}
	wp += builtin_opt.optind;

	if (Flag(FRESTRICTED)) {
		bi_errorf(Tcant_cd);
		return (2);
	}

	pwd_s = global(TPWD);
	oldpwd_s = global(TOLDPWD);

	if (!wp[0]) {
		/* No arguments - go home */
		if ((dir = str_val(global("HOME"))) == null) {
			bi_errorf("no home directory (HOME not set)");
			return (2);
		}
	} else if (!wp[1]) {
		/* One argument: - or dir */
		strdupx(allocd, wp[0], ATEMP);
		if (ksh_isdash((dir = allocd))) {
			afree(allocd, ATEMP);
			allocd = NULL;
			dir = str_val(oldpwd_s);
			if (dir == null) {
				bi_errorf(Tno_OLDPWD);
				return (2);
			}
			printpath = true;
		}
	} else if (!wp[2]) {
		/* Two arguments - substitute arg1 in PWD for arg2 */
		size_t ilen, olen, nlen, elen;
		char *cp;

		if (!current_wd[0]) {
			bi_errorf("can't determine current directory");
			return (2);
		}
		/*
		 * substitute arg1 for arg2 in current path.
		 * if the first substitution fails because the cd fails
		 * we could try to find another substitution. For now
		 * we don't
		 */
		if ((cp = strstr(current_wd, wp[0])) == NULL) {
			bi_errorf(Tbadsubst);
			return (2);
		}
		/*-
		 * ilen = part of current_wd before wp[0]
		 * elen = part of current_wd after wp[0]
		 * because current_wd and wp[1] need to be in memory at the
		 * same time beforehand the addition can stay unchecked
		 */
		ilen = cp - current_wd;
		olen = strlen(wp[0]);
		nlen = strlen(wp[1]);
		elen = strlen(current_wd + ilen + olen) + 1;
		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
		memcpy(dir, current_wd, ilen);
		memcpy(dir + ilen, wp[1], nlen);
		memcpy(dir + ilen + nlen, current_wd + ilen + olen, elen);
		printpath = true;
	} else {
		bi_errorf(Ttoo_many_args);
		return (2);
	}

#ifdef MKSH_DOSPATH
	tryp = NULL;
	if (mksh_drvltr(dir) && !mksh_cdirsep(dir[2]) &&
	    !getdrvwd(&tryp, ord(*dir))) {
		strpathx(dir, tryp, dir + 2, 0);
		afree(tryp, ATEMP);
		afree(allocd, ATEMP);
		allocd = dir;
	}
#endif

#ifdef MKSH__NO_PATH_MAX
	/* only a first guess; make_path will enlarge xs if necessary */
	XinitN(xs, 1024, ATEMP);
#else
	XinitN(xs, PATH_MAX, ATEMP);
#endif

	cdpath = str_val(global("CDPATH"));
	do {
		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
		if (physical)
			rv = chdir(tryp = Xstring(xs, xp) + phys_path);
		else {
			simplify_path(Xstring(xs, xp));
			rv = chdir(tryp = Xstring(xs, xp));
		}
	} while (rv < 0 && cdpath != NULL);

	if (rv < 0) {
		if (cdnode)
			bi_errorf(Tf_sD_s, dir, "bad directory");
		else
			bi_errorf(Tf_sD_s, tryp, cstrerror(errno));
		afree(allocd, ATEMP);
		Xfree(xs, xp);
		return (2);
	}

	rv = 0;

	/* allocd (above) => dir, which is no longer used */
	afree(allocd, ATEMP);
	allocd = NULL;

	/* Clear out tracked aliases with relative paths */
	flushcom(false);

	/*
	 * Set OLDPWD (note: unsetting OLDPWD does not disable this
	 * setting in AT&T ksh)
	 */
	if (current_wd[0])
		/* Ignore failure (happens if readonly or integer) */
		setstr(oldpwd_s, current_wd, KSH_RETURN_ERROR);

	if (!mksh_abspath(Xstring(xs, xp))) {
		pwd = NULL;
	} else if (!physical) {
		goto norealpath_PWD;
	} else if ((pwd = allocd = do_realpath(Xstring(xs, xp))) == NULL) {
		if (eflag)
			rv = 1;
 norealpath_PWD:
		pwd = Xstring(xs, xp);
	}

	/* Set PWD */
	if (pwd) {
		char *ptmp = pwd;

		set_current_wd(ptmp);
		/* Ignore failure (happens if readonly or integer) */
		setstr(pwd_s, ptmp, KSH_RETURN_ERROR);
	} else {
		set_current_wd(null);
		pwd = Xstring(xs, xp);
		/* XXX unset $PWD? */
		if (eflag)
			rv = 1;
	}
	if (printpath || cdnode)
		shprintf(Tf_sN, pwd);

	afree(allocd, ATEMP);
	Xfree(xs, xp);
	return (rv);
}


#ifdef KSH_CHVT_CODE
extern void chvt_reinit(void);

static void
chvt(const Getopt *go)
{
	const char *dv = go->optarg;
	char *cp = NULL;
	int fd;

	switch (*dv) {
	case '-':
		dv = "/dev/null";
		break;
	case '!':
		++dv;
		/* FALLTHROUGH */
	default: {
		struct stat sb;

		if (stat(dv, &sb)) {
			cp = shf_smprintf("/dev/ttyC%s", dv);
			dv = cp;
			if (stat(dv, &sb)) {
				memmove(cp + 1, cp, /* /dev/tty */ 8);
				dv = cp + 1;
				if (stat(dv, &sb)) {
					errorf(Tf_sD_sD_s, "chvt",
					    "can't find tty", go->optarg);
				}
			}
		}
		if (!(sb.st_mode & S_IFCHR))
			errorf(Tf_sD_sD_s, "chvt", "not a char device", dv);
#ifndef MKSH_DISABLE_REVOKE_WARNING
#if HAVE_REVOKE
		if (revoke(dv))
#endif
			warningf(false, Tf_sD_s_s, "chvt",
			    "new shell is potentially insecure, can't revoke",
			    dv);
#endif
	    }
	}
	if ((fd = binopen2(dv, O_RDWR)) < 0) {
		sleep(1);
		if ((fd = binopen2(dv, O_RDWR)) < 0) {
			errorf(Tf_sD_s_s, "chvt", Tcant_open, dv);
		}
	}
	if (go->optarg[0] != '!') {
		switch (fork()) {
		case -1:
			errorf(Tf_sD_s_s, "chvt", "fork", "failed");
		case 0:
			break;
		default:
			exit(0);
		}
	}
	if (setsid() == -1)
		errorf(Tf_sD_s_s, "chvt", "setsid", "failed");
	if (go->optarg[0] != '-') {
		if (ioctl(fd, TIOCSCTTY, NULL) == -1)
			errorf(Tf_sD_s_s, "chvt", "TIOCSCTTY", "failed");
		if (tcflush(fd, TCIOFLUSH))
			errorf(Tf_sD_s_s, "chvt", "TCIOFLUSH", "failed");
	}
	ksh_dup2(fd, 0, false);
	ksh_dup2(fd, 1, false);
	ksh_dup2(fd, 2, false);
	if (fd > 2)
		close(fd);
	rndset((unsigned long)chvt_rndsetup(go, sizeof(Getopt)));
	chvt_reinit();
}
#endif

#ifdef DEBUG
char *
strchr(char *p, int ch)
{
	for (;; ++p) {
		if (*p == ch)
			return (p);
		if (!*p)
			return (NULL);
	}
	/* NOTREACHED */
}

char *
strstr(char *b, const char *l)
{
	char first, c;
	size_t n;

	if ((first = *l++) == '\0')
		return (b);
	n = strlen(l);
 strstr_look:
	while ((c = *b++) != first)
		if (c == '\0')
			return (NULL);
	if (strncmp(b, l, n))
		goto strstr_look;
	return (b - 1);
}
#endif

#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
char *
strndup_i(const char *src, size_t len, Area *ap)
{
	char *dst = NULL;

	if (src != NULL) {
		dst = alloc(len + 1, ap);
		memcpy(dst, src, len);
		dst[len] = '\0';
	}
	return (dst);
}

char *
strdup_i(const char *src, Area *ap)
{
	return (src == NULL ? NULL : strndup_i(src, strlen(src), ap));
}
#endif

#if !HAVE_GETRUSAGE
#define INVTCK(r,t)	do {						\
	r.tv_usec = ((t) % (1000000 / CLK_TCK)) * (1000000 / CLK_TCK);	\
	r.tv_sec = (t) / CLK_TCK;					\
} while (/* CONSTCOND */ 0)

int
getrusage(int what, struct rusage *ru)
{
	struct tms tms;
	clock_t u, s;

	if (/* ru == NULL || */ times(&tms) == (clock_t)-1)
		return (-1);

	switch (what) {
	case RUSAGE_SELF:
		u = tms.tms_utime;
		s = tms.tms_stime;
		break;
	case RUSAGE_CHILDREN:
		u = tms.tms_cutime;
		s = tms.tms_cstime;
		break;
	default:
		errno = EINVAL;
		return (-1);
	}
	INVTCK(ru->ru_utime, u);
	INVTCK(ru->ru_stime, s);
	return (0);
}
#endif

/*
 * process the string available via fg (get a char)
 * and fp (put back a char) for backslash escapes,
 * assuming the first call to *fg gets the char di-
 * rectly after the backslash; return the character
 * (0..0xFF), UCS (wc + 0x100), or -1 if no known
 * escape sequence was found
 */
int
unbksl(bool cstyle, int (*fg)(void), void (*fp)(int))
{
	int wc, i, c, fc, n;

	fc = (*fg)();
	switch (fc) {
	case 'a':
		wc = KSH_BEL;
		break;
	case 'b':
		wc = '\b';
		break;
	case 'c':
		if (!cstyle)
			goto unknown_escape;
		c = (*fg)();
		wc = ksh_toctrl(c);
		break;
	case 'E':
	case 'e':
		wc = KSH_ESC;
		break;
	case 'f':
		wc = '\f';
		break;
	case 'n':
		wc = '\n';
		break;
	case 'r':
		wc = '\r';
		break;
	case 't':
		wc = '\t';
		break;
	case 'v':
		wc = KSH_VTAB;
		break;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
		if (!cstyle)
			goto unknown_escape;
		/* FALLTHROUGH */
	case '0':
		if (cstyle)
			(*fp)(fc);
		/*
		 * look for an octal number with up to three
		 * digits, not counting the leading zero;
		 * convert it to a raw octet
		 */
		wc = 0;
		i = 3;
		while (i--)
			if (ctype((c = (*fg)()), C_OCTAL))
				wc = (wc << 3) + ksh_numdig(c);
			else {
				(*fp)(c);
				break;
			}
		break;
	case 'U':
		i = 8;
		if (/* CONSTCOND */ 0)
			/* FALLTHROUGH */
	case 'u':
		  i = 4;
		if (/* CONSTCOND */ 0)
			/* FALLTHROUGH */
	case 'x':
		  i = cstyle ? -1 : 2;
		/**
		 * x:	look for a hexadecimal number with up to
		 *	two (C style: arbitrary) digits; convert
		 *	to raw octet (C style: UCS if >0xFF)
		 * u/U:	look for a hexadecimal number with up to
		 *	four (U: eight) digits; convert to UCS
		 */
		wc = 0;
		n = 0;
		while (n < i || i == -1) {
			wc <<= 4;
			if (!ctype((c = (*fg)()), C_SEDEC)) {
				wc >>= 4;
				(*fp)(c);
				break;
			}
			if (ctype(c, C_DIGIT))
				wc += ksh_numdig(c);
			else if (ctype(c, C_UPPER))
				wc += ksh_numuc(c) + 10;
			else
				wc += ksh_numlc(c) + 10;
			++n;
		}
		if (!n)
			goto unknown_escape;
		if ((cstyle && wc > 0xFF) || fc != 'x')
			/* UCS marker */
			wc += 0x100;
		break;
	case '\'':
		if (!cstyle)
			goto unknown_escape;
		wc = '\'';
		break;
	case '\\':
		wc = '\\';
		break;
	default:
 unknown_escape:
		(*fp)(fc);
		return (-1);
	}

	return (wc);
}
@


1.295
log
@empty out auxilliary groups vector when playing with privilegues
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.294 2019/12/11 20:11:13 tg Exp $");
d1692 1
a1692 2
		ipath = shf_smprintf(Tf_sss, ldest,
		    upath[2] ? "/" : "", upath + 2);
d1698 1
a1698 1
		ipath = shf_smprintf(Tf_sss, tp, "/", upath);
d1800 1
a1800 1
			tp = shf_smprintf(Tf_sss, ldest, *ip ? "/" : "", ip);
d2216 1
a2216 2
		dir = shf_smprintf(Tf_sss, tryp,
		    dir[2] ? "/" : "", dir + 2);
@


1.294
log
@implement run-time setting of privileged option to realise setugid fully

to avoid needing an extra tool in cases like Debian #946599

set +p drops privs fully and irrevocably of course
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.292 2018/03/17 22:46:09 tg Exp $");
d248 1
a248 1
		/* +++ set groups vector +++ */
d251 1
a251 1
		setgroups(1, &kshegid);
@


1.293
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d6 1
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d219 1
a219 1
	unsigned char oldval;
d225 11
a235 24
	}
	oldval = Flag(f);
	Flag(f) = newval = (newset ? 1 : 0);
#ifndef MKSH_UNEMPLOYED
	if (f == FMONITOR) {
		if (what != OF_CMDLINE && newval != oldval)
			j_change();
	} else
#endif
#ifndef MKSH_NO_CMDLINE_EDITING
	  if ((
#if !MKSH_S_NOVI
	    f == FVI ||
#endif
	    f == FEMACS || f == FGMACS) && newval) {
#if !MKSH_S_NOVI
		Flag(FVI) =
#endif
		    Flag(FEMACS) = Flag(FGMACS) = 0;
		Flag(f) = newval;
	} else
#endif
	  if (f == FPRIVILEGED && oldval && !newval) {
		/* Turning off -p? */
d237 1
a237 3
		/*XXX this can probably be optimised */
		kshegid = kshgid = getgid();
		ksheuid = kshuid = getuid();
d239 10
a248 1
		DO_SETUID(setresgid, (kshegid, kshegid, kshegid));
d252 5
a256 2
#endif
		DO_SETUID(setresuid, (ksheuid, ksheuid, ksheuid));
d258 1
a258 5
		/* setgid, setegid, seteuid don't EAGAIN on Linux */
		setgid(kshegid);
#ifndef MKSH__NO_SETEUGID
		setegid(kshegid);
#endif
d262 1
a262 1
#endif
d264 2
a266 2
		/* Turning on -o posix or -o sh? */
		Flag(FBRACEEXPAND) = 0;
d268 1
a268 1
		if (f == FPOSIX) {
d271 19
a289 2
		}
	} else if (f == FTALKING) {
d293 5
@


1.292
log
@quote empty strings for re-entry into shell

From: Martijn Dekker <martijn@@inlv.org>
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.291 2018/01/14 00:03:03 tg Exp $");
d2459 1
a2459 1
 * (0..0xFF), Unicode (wc + 0x100), or -1 if no known
d2541 1
a2541 1
		 *	to raw octet (C style: Unicode if >0xFF)
d2543 1
a2543 1
		 *	four (U: eight) digits; convert to Unicode
d2565 1
a2565 1
			/* Unicode marker */
@


1.291
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.285 2017/10/11 23:48:36 tg Exp $");
d1349 8
a1356 1
	/* first, check whether any quotes are needed */
@


1.290
log
@DOSPATH fix
@
text
@d788 1
a788 1
		case CORD('['):
d816 1
a816 1
		case CORD('?'):
d825 1
a825 1
		case CORD('*'):
d841 1
a841 1
		case CORD('+') | 0x80:
d843 1
a843 1
		case CORD('*') | 0x80:
d866 1
a866 1
		case CORD('?') | 0x80:
d868 1
a868 1
		case CORD('@@') | 0x80:
d870 1
a870 1
		case CORD(' ') | 0x80:
d892 1
a892 1
		case CORD('!') | 0x80:
@


1.289
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d1667 1
a1667 1
		if (getdrvwd(&ldest, ORD(*upath)))
d1786 1
a1786 1
					if (getdrvwd(&ldest, ORD(*ipath)))
d2194 1
a2194 1
	    !getdrvwd(&tryp, ORD(*dir))) {
@


1.288
log
@apply another quickfix by komh

really, getdrvwd should be passed an Xstring (probably with Xinit0 in
the callers), especially as one caller already didn’t update ldestlen
properly… (but not tonight as I’ve really got no head for that left)
@
text
@d699 1
a699 1
		if (ord(c) == ord('*') || ord(c) == ord('?')) {
d702 1
a702 1
		} else if (ord(c) == ord('[')) {
d704 1
a704 1
			if (ISMAGIC(p[0]) && ord(p[1]) == ord('!'))
d706 1
a706 1
			if (ISMAGIC(p[0]) && ord(p[1]) == ord(']'))
d718 1
a718 1
				if (ord(c) == ord(']')) {
d725 1
a725 1
				if (ord(c) == ord('[') && (
d727 1
a727 1
				    ord(*s) == ord('.') ||
d729 1
a729 1
				    ord(*s) == ord('=') ||
d731 1
a731 1
				    ord(*s) == ord(':'))) {
d738 1
a738 1
						    ord(s[1]) == ord(']')) {
d754 1
a754 1
		} else if (ord(c) == ord(/*(*/ ')')) {
d788 1
a788 1
		case ord('['):
d790 2
a791 2
			if (ISMAGIC(p[0]) && ord(p[1]) == ord('[') &&
			    ord(p[2]) == ord(':') &&
d793 3
a795 3
			    ord(p[4]) == ord(':') &&
			    ISMAGIC(p[5]) && ord(p[6]) == ord(']') &&
			    ISMAGIC(p[7]) && ord(p[8]) == ord(']')) {
d800 1
a800 1
				if (ord(pc) == ord('<') &&
d805 1
a805 1
				if (ord(pc) == ord('>') &&
d816 1
a816 1
		case ord('?'):
d825 1
a825 1
		case ord('*'):
d841 1
a841 1
		case 0x80|ord('+'):
d843 1
a843 1
		case 0x80|ord('*'):
d848 1
a848 1
			if (ord(p[-1]) == (0x80 | ord('*')) &&
d866 1
a866 1
		case 0x80|ord('?'):
d868 1
a868 1
		case 0x80|ord('@@'):
d870 1
a870 1
		case 0x80|ord(' '):
d875 1
a875 1
			if (ord(p[-1]) == (0x80 | ord('?')) &&
d892 1
a892 1
		case 0x80|ord('!'):
d969 1
a969 1
	if (ISMAGIC(p[0]) && ord(p[1]) == ord('!')) {
d974 1
a974 1
	if (ISMAGIC(p[0]) && ord(p[1]) == ord(']'))
d985 1
a985 1
			if (ord(c) == ord(']')) {
d990 1
a990 1
			if (ord(c) == ord('[') && (
d992 1
a992 1
			    ord(*p) == ord('.') ||
d994 1
a994 1
			    ord(*p) == ord('=') ||
d996 1
a996 1
			    ord(*p) == ord(':'))) {
d1005 1
a1005 1
					    ord(p[1]) == ord(']')) {
d1018 1
a1018 1
				if (ord(subc) == ord(':')) {
d1058 1
a1058 1
		if (!(ISMAGIC(p[0]) && ord(p[1]) == ord('-') &&
d1060 1
a1060 1
		    (!ISMAGIC(p[2]) || ord(p[3]) != ord(']')))) {
d1082 1
a1082 1
			if (ord(c) == ord('[') && (
d1084 1
a1084 1
			    ord(*p) == ord('.') ||
d1086 1
a1086 1
			    ord(*p) == ord('=') ||
d1088 1
a1088 1
			    ord(*p) == ord(':'))) {
d1097 1
a1097 1
					    ord(p[1]) == ord(']')) {
d1109 1
a1109 1
				if (ord(subc) == ord(':')) {
d1116 1
a1116 1
					if (ord(sc) == ord('-'))
d1154 1
a1154 1
	if (ord(sc) == ord('['))
d1667 1
a1667 1
		if (getdrvwd(&ldest, ord(*upath)))
d1786 1
a1786 1
					if (getdrvwd(&ldest, ord(*ipath)))
d2194 1
a2194 1
	    !getdrvwd(&tryp, ord(*dir))) {
@


1.287
log
@fix “cd e:foo” on DOSPATH systems (I think)
@
text
@d2192 1
@


1.286
log
@apply fixes from code review by @@komh
@
text
@d2191 11
@


1.285
log
@note on rooted pathnames, concept found in original pdksh which had
various forms of path attributes (not just absolute or not), though
we shouldn’t just copy theirs either
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.284 2017/10/11 23:23:02 tg Exp $");
d1667 1
a1667 1
		if (!getdrvwd(&ldest, ord(*upath)))
d1786 1
a1786 1
					if (!getdrvwd(&ldest, ord(*ipath)))
@


1.284
log
@handle drive-qualified nōn-absolute pathnames in do_realpath(), untested

the idea here is that:

- /foo/bar and a:/foo/bar are absolute
- foo/bar is relative
- a:foo/bar needs to be handled specially,
  mostly per making it into an absolute (“a:/” + getcwd(a:) + “foo/bar”)
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.283 2017/10/11 21:49:06 tg Exp $");
d1707 1
d1969 5
d2030 1
a2030 1
				/* parent level, but how? */
@


1.283
log
@further OS/2 fixes for simplify_path()
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.277 2017/05/05 22:53:30 tg Exp $");
d1664 9
d1774 3
d1781 10
a1790 1
			if (!mksh_abspath(ldest)) {
d1799 1
a1799 1
				/* assert: mksh_cdirsep((ip == ipath)[0]) */
a1812 8
					/*
					 * XXX if (!mksh_cdirsep(*ip)): we
					 * XXX must get the cwd on that drive
					 * XXX and prepend it here as this is
					 * XXX a drive-qualified relative path
					 * XXX which we are supposed to convert
					 * XXX to an absolute (with drive) one
					 */
@


1.282
log
@keep drive letter when simplifying path (untested)
@
text
@d1951 4
a1954 2
 * C:/../foo				C:/foo
 * C:../foo				C:../foo
d1962 2
a1964 1
#ifdef MKSH_DOSPATH
d1966 1
a1966 1
	if (mksh_drvltr(p))
d1968 4
d2050 7
a2056 3
	if (dp == p)
		/* empty path -> dot */
		*dp++ = needslash ? '/' : '.';
d2058 1
@


1.281
log
@turns out the slash was already added (later), 10x komh
@
text
@d1788 1
a1788 1
				if (ctype(ip[0], C_ALPHA) && ip[1] == ':') {
d1951 2
d1961 6
@


1.280
log
@fix part of realpath for drive-qualified DOS paths:

if a path or symlink target is drive-qualified, keep the drive letter
(this part from komh) and, if present, a leading (back)slash (from me)

missing: if a drive qualification is *not* followed by a (back)slash,
we must retrieve the per-drive cwd for the target drive and insert it
just like we insert the cwd for (normal/Unix) relative paths; maybe
consider redoing absolute/relative path logic, DOS paths are tristate

komh’s commit: fix realpath failure on OS/2

On OS/2, an absolute path is 'x:/path/to/file'. Because it has not
a leading slash, '/' is prepended, that is, '/x:/path/to/file'. As a
result, it fails to find a requested file.
@
text
@a1791 3
					/* as well as a leading (back)slash */
					if (mksh_cdirsep(*ip))
						Xput(xs, xp, *ip++);
d1793 2
a1794 1
					 * XXX else: get the cwd on that drive
@


1.279
log
@release
@
text
@d1786 18
@


1.278
log
@turn off UTF-8 mode upon entering POSIX mode, for J�rg
@
text
@d275 1
a275 1
		if (f == POSIX) {
@


1.277
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.266 2017/04/28 02:24:57 tg Exp $");
d274 5
@


1.276
log
@some more small EBCDIC fixes
@
text
@d749 1
a749 1
		} else if (ord(c) == ord(/*(*/')')) {
d782 2
a783 2
		switch (*p++) {
		case '[':
d811 1
a811 1
		case '?':
d820 1
a820 1
		case '*':
d836 1
a836 1
		case 0x80|'+':
d838 1
a838 1
		case 0x80|'*':
d843 1
a843 1
			if (p[-1] == (0x80 | '*') &&
d861 1
a861 1
		case 0x80|'?':
d863 1
a863 1
		case 0x80|'@@':
d865 1
a865 1
		case 0x80|' ':
d870 1
a870 1
			if (p[-1] == (0x80 | '?') &&
d887 1
a887 1
		case 0x80|'!':
d1049 1
a1049 1
				c = '('/*)*/;
d1130 1
a1130 1
				c = '('/*)*/;
d1133 1
a1133 1
				subc = '('/*)*/;
@


1.275
log
@first cut at the new matching code, IT WORKS!!! in the FIRST try!

missing:
- tons of new testcases
- EBCDIC support with ASCII ordering for POSIX ranges
@
text
@d1137 3
a1139 1
		if (lc != 0 && /* c != 0 && */ lc <= sc && sc <= c)
@


1.274
log
@commit my WIP for the Beltane Snapshot of the Mainframe Korn Shell, not going to make finishing it tonight ☹
@
text
@a954 2
gmatch_cclass(const unsigned char *p, unsigned char sub)
#if 0
d957 1
a957 1
	unsigned char c, subc;
d961 1
d973 1
d996 76
a1071 11
}
#endif
{
	unsigned char c, d;
	bool notp, found = false;
	const unsigned char *orig_p = p;

	if ((notp = tobool(ISMAGIC(*p) && *++p == '!')))
		p++;
	do {
		c = *p++;
d1073 59
a1131 3
			c = *p++;
			if ((c & 0x80) && !ISMAGIC(c)) {
				/* extended pattern matching: *+?@@! */
d1133 1
a1133 4
				/* XXX the ( char isn't handled as part of [] */
				if (c == ' ')
					/* simile for @@: plain (..) */
					c = '(' /*)*/;
d1136 2
a1137 19
		if (c == '\0')
			/* No closing ] - act as if the opening [ was quoted */
			return (sub == '[' ? orig_p : NULL);
		if (ISMAGIC(p[0]) && p[1] == '-' &&
		    (!ISMAGIC(p[2]) || p[3] != ']')) {
			/* MAGIC- */
			p += 2;
			d = *p++;
			if (ISMAGIC(d)) {
				d = *p++;
				if ((d & 0x80) && !ISMAGIC(d))
					d &= 0x7f;
			}
			/* POSIX says this is an invalid expression */
			if (c > d)
				return (NULL);
		} else
			d = c;
		if (c == sub || (c <= sub && sub <= d))
d1139 13
a1151 3
	} while (!(ISMAGIC(p[0]) && p[1] == ']'));

	return ((found != notp) ? p+2 : NULL);
@


1.273
log
@add BSDish [[:<:]] and [[:>:]] matching (angle brackets must be escaped)
@
text
@d920 34
d956 42
@


1.272
log
@use strnul(); optimise
@
text
@d52 2
a53 1
    const unsigned char *, const unsigned char *) MKSH_A_PURE;
d654 2
a655 1
	    (const unsigned char *)pnew, (const unsigned char *)pe);
d694 1
a694 1
		if (c == '*' || c == '?') {
d697 1
a697 1
		} else if (c == '[') {
d699 1
a699 1
			if (ISMAGIC(p[0]) && p[1] == '!')
d701 1
a701 1
			if (ISMAGIC(p[0]) && p[1] == ']')
d713 1
a713 1
				if (c == ']') {
d719 8
a726 3
				/* collating, equivalence or character class */
				if (c == '[' && (
				    *s == '.' || *s == '=' || *s == ':')) {
d733 1
a733 1
						    s[1] == ']') {
d749 1
a749 1
		} else if (c == /*(*/')') {
d761 2
a762 1
    const unsigned char *p, const unsigned char *pe)
d764 1
a764 1
	unsigned char sc, pc;
d770 2
d779 1
d784 23
d825 1
a825 1
				if (do_gmatch(s, se, p, pe))
d844 1
a844 1
			    do_gmatch(s, se, prest, pe))
d849 4
a852 4
					if (do_gmatch(s, srest, psub, pnext - 2) &&
					    (do_gmatch(srest, se, prest, pe) ||
					    (s != srest && do_gmatch(srest,
					    se, p - 2, pe))))
d871 1
a871 1
			    do_gmatch(s, se, prest, pe))
d877 2
a878 2
					if (do_gmatch(s, srest, psub, pnext - 2) &&
					    do_gmatch(srest, se, prest, pe))
d897 1
a897 1
					    pnext - 2)) {
d905 1
a905 1
				    do_gmatch(srest, se, prest, pe))
d915 1
@


1.271
log
@reimplement has_globbing() with proper bracket expression parsing,
and take ahead parsing collating symbols, equivalence classes and
character classes already (heck my first draft of this already did
better than GNU bash, ksh93 I still don’t grok its code at all)
@
text
@d559 1
a559 1
	se = sp + strlen((const void *)sp);
d631 1
a631 2
	se = s + strlen(s);
	pe = p + strlen(p);
d643 1
d650 1
a650 1
	pe = pnew + strlen(pnew);
@


1.270
log
@optimise <0x20/>0x7E into !C_PRINT
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.269 2017/04/28 11:13:48 tg Exp $");
d637 1
a637 1
	if (!isfile && !has_globbing(p, pe)) {
d664 1
a664 1
 *	- [...] and *(...) not nested (eg, [a$(b|]c), *(a[b|c]d))
d675 2
a676 2
int
has_globbing(const char *xp, const char *xpe)
d678 1
a678 4
	const unsigned char *p = (const unsigned char *) xp;
	const unsigned char *pe = (const unsigned char *) xpe;
	int c;
	int nest = 0, bnest = 0;
d680 7
a686 5
	/* inside [...] */
	bool in_bracket = false;

	for (; p < pe; p++) {
		if (!ISMAGIC(*p))
d688 6
a693 1
		if ((c = *++p) == '*' || c == '?')
d695 42
a736 16
		else if (c == '[') {
			if (!in_bracket) {
				saw_glob = true;
				in_bracket = true;
				if (ISMAGIC(p[1]) && p[2] == '!')
					p += 2;
				if (ISMAGIC(p[1]) && p[2] == ']')
					p += 2;
			}
			/*XXX Do we need to check ranges here? POSIX Q */
		} else if (c == ']') {
			if (in_bracket) {
				if (bnest)
					/* [a*(b]) */
					return (0);
				in_bracket = false;
d739 1
d741 5
a745 15
			if (in_bracket)
				bnest++;
			else
				nest++;
		} else if (c == '|') {
			if (in_bracket && !bnest)
				/* *(a[foo|bar]) */
				return (0);
		} else if (c == /*(*/ ')') {
			if (in_bracket) {
				if (!bnest--)
					/* *(a[b)c] */
					return (0);
			} else if (nest)
				nest--;
a746 1
		/* else must be MAGIC followed by MAGIC or one of: ]{},!- */
d748 1
a748 1
	return (saw_glob && !in_bracket && !nest);
d797 1
a797 1
		 * [*+?@@!](pattern|pattern|..)
@


1.269
log
@add -DMKSH_FAUX_EBCDIC to test the codepaths better

waking up to: Lanfear - Just Another Broken Shell
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.266 2017/04/28 02:24:57 tg Exp $");
d1194 1
a1194 1
				  if (c < 32 || c > 0x7E)
@


1.268
log
@rename asc() to asciibetical() to make clear it’s for POSIX ordering only
and switch remaining consumers, except the allowed one, to rtt2asc()
@
text
@d1191 1
a1191 1
#ifdef MKSH_EBCDIC
@


1.267
log
@control character madness, but more compiler-friendly
@
text
@d940 1
a940 1
	return ((int)asc(*cp1) - (int)asc(*cp2));
d1101 1
a1101 1
	while (asc(c = *p++) >= 32)
@


1.266
log
@apply most of the remaining parts of the EBCDIC patch, sans the CTRL() changes
@
text
@d35 1
a35 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.262 2017/04/27 23:12:47 tg Exp $");
d1101 1
a1101 1
	while ((c = *p++) >= 32)
d1140 1
d1149 1
d1192 1
a1192 1
				  if (c < 64 || c == 0xFF)
d2156 1
a2156 1
		wc = CTRL(c);
@


1.265
log
@BEL was, and Vi mode is, not EBCDIC-safe
@
text
@d8 2
d1175 1
a1175 1
			case 11:
d1179 1
a1179 1
			case '\033':
d1189 6
a1194 1
				  if (c < 32 || c > 0x7E) {
d2158 1
a2158 1
		wc = 033;
d2173 1
a2173 2
		/* assume ASCII here as well */
		wc = 11;
@


1.264
log
@commit the optimisation result from the new fast character classes
@
text
@d1149 1
a1149 1
			case 7:
d2138 1
a2138 7
		/*
		 * according to the comments in pdksh, \007 seems
		 * to be more portable than \a (due to HP-UX cc,
		 * Ultrix cc, old pcc, etc.) so we avoid the escape
		 * sequence altogether in mksh and assume ASCII
		 */
		wc = 7;
@


1.263
log
@fix return value to signed
@
text
@d119 1
a119 1
	if ((n[0] == '-' || n[0] == '+') && n[1] && !n[2])
d455 1
a455 1
	    (argv[go.optind][0] == '-' || argv[go.optind][0] == '+') &&
d706 1
a706 1
		} else if ((c & 0x80) && ctype(c & 0x7F, C_PATMO)) {
d922 1
a922 1
		if ((*p & 0x80) && ctype(*p & 0x7F, C_PATMO))
d1015 1
a1015 1
	if (c == '?' || c == ':' || c == ';' || c == ',' || c == '#' ||
@


1.262
log
@fixup the remaining issues and last optimisations
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.251 2017/02/18 02:33:13 tg Exp $");
d938 1
a938 1
	return (asc(*cp1) - asc(*cp2));
@


1.261
log
@batch of optimisations
@
text
@d706 1
a706 1
		} else if ((c & 0x80) && vstrchr("*+?@@! ", c & 0x7f)) {
d922 1
a922 1
		if ((*p & 0x80) && vstrchr("*+?@@! ", *p & 0x7f))
@


1.260
log
@eliminate legacy macros
@
text
@d1075 2
a1076 1
			if (argv[go->optind] && ctype(argv[go->optind][0], C_DIGIT)) {
d1100 1
a1100 1
		if (ctype(c, C_QUOTE))
d2196 1
a2196 1
			if (ctype((c = (*fg)()), C_DIGIT) && asc(c) <= asc('7'))
d2224 1
a2224 7
			if (ctype((c = (*fg)()), C_DIGIT))
				wc += ksh_numdig(c);
			else if (asc(c) >= asc('A') && asc(c) <= asc('F'))
				wc += ksh_numuc(c) + 10;
			else if (asc(c) >= asc('a') && asc(c) <= asc('f'))
				wc += ksh_numlc(c) + 10;
			else {
d2229 6
@


1.259
log
@convert to the new fast character classes
@
text
@d505 1
a505 1
	} while (ksh_isspace(c));
d517 1
a517 1
		if (!ksh_isdigit(c))
d1069 1
a1069 1
			if (ksh_isdigit(argv[go->optind - 1][go->p])) {
d1075 1
a1075 1
			if (argv[go->optind] && ksh_isdigit(argv[go->optind][0])) {
d2195 1
a2195 1
			if (ksh_isdigit((c = (*fg)())) && asc(c) <= asc('7'))
d2223 1
a2223 1
			if (ksh_isdigit((c = (*fg)())))
@


1.258
log
@now actually do comparisons for sorting ASCIIbetically
@
text
@a70 31
/*
 * Fast character classes
 */
void
setctypes(const char *s, int t)
{
	if (t & C_IFS) {
		unsigned int i = 0;

		while (++i <= UCHAR_MAX)
			chtypes[i] &= ~C_IFS;
		/* include '\0' in C_IFS */
		chtypes[0] |= C_IFS;
	}
	while (*s != 0)
		chtypes[(unsigned char)*s++] |= t;
}

void
initctypes(void)
{
	setctypes(letters_uc, C_ALPHX);
	setctypes(letters_lc, C_ALPHX);
	chtypes['_'] |= C_ALPHX;
	setctypes("0123456789", C_DIGIT);
	setctypes(TC_LEX1, C_LEX1);
	setctypes("*@@#!$-?", C_VAR1);
	setctypes(TC_IFSWS, C_IFSWS);
	setctypes("=-+?", C_SUBOP1);
	setctypes("\t\n \"#$&'()*;<=>?[\\]`|", C_QUOTE);
}
@


1.257
log
@make ord() result unsigned int; add asc() which is:

• not designed to be emitted, only used in comparisons with
  other asc() results
• on EBCDIC platforms, the mapping of an EBCDIC octet to their
  corresponding ASCII or Unicode/UCS-4 codepoint or, if there
  is no mapping, a distinct value above all valid Unicode codepoints
• on nōn-EBCDIC platforms, just the identity mapping of the input
  octet into their ord() value

Intended use are ASCII-ish character ops, including ranges (“A-Z”),
mapping from those to the corresponding digit offset, and sorting
of things in an ASCIIbetical way
@
text
@d515 1
a515 1
		    xstrcmp);
d664 1
a664 1
	 * the pattern. If check fails, just to a strcmp().
d960 1
a960 1
xstrcmp(const void *p1, const void *p2)
d962 15
a976 1
	return (strcmp(*(const char * const *)p1, *(const char * const *)p2));
@


1.256
log
@fix comment
@
text
@d2212 1
a2212 1
			if ((c = (*fg)()) >= ord('0') && c <= ord('7'))
d2240 1
a2240 1
			if ((c = (*fg)()) >= ord('0') && c <= ord('9'))
d2242 1
a2242 1
			else if (c >= ord('A') && c <= ord('F'))
d2244 1
a2244 1
			else if (c >= ord('a') && c <= ord('f'))
@


1.255
log
@(very few) fixes and a couple of workarounds for Coverity
@
text
@d755 1
a755 4
		/*
		 * else must be a MAGIC-MAGIC, or MAGIC-!,
		 * MAGIC--, MAGIC-], MAGIC-{, MAGIC-, MAGIC-}
		 */
@


1.254
log
@split path-specific ('C:\FOO' instead of '/foo') stuff into MKSH_DOSPATH:
• backslashes as directory separators
• semicolon as $PATH separator
• drive letters are absolute paths
@
text
@d504 1
a504 1
		if (*array)
@


1.253
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d1708 1
a1708 1
#ifdef __OS2__
@


1.252
log
@unbreak $'\xz' to expand to 'xz'
@
text
@d92 3
a94 3
	setctypes(letters_uc, C_ALPHA);
	setctypes(letters_lc, C_ALPHA);
	chtypes['_'] |= C_ALPHA;
a95 1
	/* \0 added automatically */
@


1.251
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.242 2016/03/04 14:26:13 tg Exp $");
d2153 1
a2153 1
	int wc, i, c, fc;
d2241 2
a2242 1
		while (i--) {
d2255 1
d2257 2
@


1.250
log
@fix embarassing pasto and OS/2 UNC logic; thanks komh!
@
text
@d6 1
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
a42 4
#ifdef MKSH_LEGACY_MODE
#undef KSH_CHVT_CODE
#undef KSH_CHVT_FLAG
#endif
@


1.249
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d1544 1
a1544 1
				/* assert: (ip == ipath)[0] == '/' */
d1548 1
a1548 2
				/* @@komh do NOT use mksh_cdirsep() here */
				if (ip[1] == '/' && ip[2] != '/') {
d1713 3
d1717 1
a1717 2
		/* @@komh no mksh_cdirsep() here! */
		if (p[1] == '/' && p[2] != '/')
a1719 4
#ifdef __OS2__
		/* FALLTHROUGH */
	case '\\':
#endif
@


1.248
log
@make print -c honour line separator
@
text
@d394 1
a394 1
				if (*q++ == '/')
d1446 1
a1446 1
		while (*ip == '/')
d1453 1
a1453 1
		while (*ip && *ip != '/')
d1465 1
a1465 1
					if (*--xp == '/')
d1488 1
a1488 1
				while (*ip == '/')
d1548 1
d1574 1
a1574 1
	if (ip > ipath && ip[-1] == '/') {
d1643 1
a1643 1
			if (c == '/' || c == '\0')
d1665 1
a1665 1
			if (cwd[len - 1] != '/')
d1673 1
a1673 1
			if (plist[plen - 1] != '/')
d1715 1
d1719 4
d1732 1
a1732 1
		while (*ip == '/')
d1739 1
a1739 1
		while (*ip && *ip != '/')
d1759 1
a1759 1
						if (*--dp == '/')
@


1.247
log
@restructure so that the trailing separator is output separately from
the inner line separators
@
text
@d216 2
a217 1
		co.prefcol = true;
d1274 1
a1274 1
			shf_putc('\n', opts->shf);
d1294 1
a1294 1
		shf_putchar('\n', opts->shf);
d1309 2
a1310 1
	shf_putchar('\n', opts->shf);
@


1.246
log
@put print_columns options into a helper struct, eases passing things around
@
text
@d1236 1
a1236 1
	unsigned int i, r, c, rows, cols, nspace, max_col;
d1271 5
a1275 2
		for (i = 0; i < n; ++i) {
			(*func)(str, max_oct, i, arg);
a1276 1
			shf_putc('\n', opts->shf);
d1291 4
a1294 1
	for (r = 0; r < rows; r++) {
d1305 1
a1305 1
		shf_putchar('\n', opts->shf);
d1308 1
@


1.245
log
@clean up chtypes use
@
text
@d198 1
d215 4
a218 2
		print_columns(shl_stdout, n, options_fmt_entry, &oi,
		    octs + 4, oi.opt_width + 4, true);
d1232 1
a1232 1
print_columns(struct shf *shf, unsigned int n,
d1234 1
a1234 1
    const void *arg, size_t max_oct, size_t max_colz, bool prefcol)
d1273 2
a1274 2
			shf_puts(str, shf);
			shf_putc('\n', shf);
d1280 1
a1280 1
	if (prefcol && cols > rows) {
d1295 1
a1295 1
				shf_puts(str, shf);
d1297 1
a1297 1
				shf_fprintf(shf, "%*s%*s",
d1300 1
a1300 1
		shf_putchar('\n', shf);
@


1.244
log
@add a testcase as documentation (why POSIX isn’t everything); fix comments
@
text
@d81 2
a82 1
	unsigned int i;
d84 1
a84 2
	if (t & C_IFS) {
		for (i = 0; i < UCHAR_MAX + 1; i++)
d86 1
a86 1
		/* include \0 in C_IFS */
@


1.243
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d357 1
a357 1
    /* OF_CMDLINE or OF_SET */
@


1.242
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.231 2015/04/29 20:21:35 tg Exp $");
d446 2
a447 1
				bi_errorf("%s: %s", go.optarg, "bad option");
d508 1
a508 1
			bi_errorf("%s: %s", array, "is not an identifier");
d1042 1
a1042 1
			warningf(true, "%s%s-%c: %s",
d1044 2
a1045 2
			    (go->flags & GF_NONAME) ? "" : ": ", c,
			    "unknown option");
d1070 1
a1070 1
			warningf(true, "%s%s-%c: %s",
d1072 2
a1073 2
			    (go->flags & GF_NONAME) ? "" : ": ", c,
			    "requires an argument");
d1423 1
a1423 1
		ipath = shf_smprintf("%s%s%s", tp, "/", upath);
d1521 1
a1521 1
			tp = shf_smprintf("%s%s%s", ldest, *ip ? "/" : "", ip);
d1823 1
a1823 1
		bi_errorf("restricted shell - can't cd");
d1827 2
a1828 2
	pwd_s = global("PWD");
	oldpwd_s = global("OLDPWD");
d1844 1
a1844 1
				bi_errorf("no OLDPWD");
d1884 1
a1884 1
		bi_errorf("too many arguments");
d1908 1
a1908 1
			bi_errorf("%s: %s", dir, "bad directory");
d1910 1
a1910 1
			bi_errorf("%s: %s", tryp, cstrerror(errno));
d1959 1
a1959 1
		shprintf("%s\n", pwd);
d1994 1
a1994 1
					errorf("%s: %s: %s", "chvt",
d2000 1
a2000 1
			errorf("%s: %s: %s", "chvt", "not a char device", dv);
d2005 1
a2005 1
			warningf(false, "%s: %s %s", "chvt",
d2014 1
a2014 1
			errorf("%s: %s %s", "chvt", "can't open", dv);
d2020 1
a2020 1
			errorf("%s: %s %s", "chvt", "fork", "failed");
d2028 1
a2028 1
		errorf("%s: %s %s", "chvt", "setsid", "failed");
d2031 1
a2031 1
			errorf("%s: %s %s", "chvt", "TIOCSCTTY", "failed");
d2033 1
a2033 1
			errorf("%s: %s %s", "chvt", "TCIOFLUSH", "failed");
@


1.241
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d1294 1
a1294 1
				    max_col, str, nspace, null);
@


1.240
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d6 1
a6 1
 *		 2011, 2012, 2013, 2014, 2015
d1864 1
a1864 1
			bi_errorf("bad substitution");
@


1.239
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2015/03/18 15:12:36 tedu Exp $	*/
d7 1
a7 1
 *	mirabilos <tg@@mirbsd.org>
@


1.238
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d2 1
a2 1
/*	$OpenBSD: path.c,v 1.12 2005/03/30 17:16:37 deraadt Exp $	*/
d7 1
a7 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d1573 1
a1573 2
	if (ldest != NULL)
		afree(ldest, ATEMP);
d1580 1
a1580 2
	if (ldest != NULL)
		afree(ldest, ATEMP);
@


1.237
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d1415 1
a1415 1
	if (upath[0] == '/') {
d1420 1
a1420 1
		if ((tp = ksh_get_wd()) == NULL || tp[0] != '/')
d1523 1
a1523 1
			if (ldest[0] != '/') {
d1623 1
a1623 1
	if (file[0] == '/') {
d1640 1
a1640 1
			char *pend;
d1642 2
a1643 2
			for (pend = plist; *pend && *pend != ':'; pend++)
				;
d1648 1
a1648 1
		if ((!use_cdpath || !plen || plist[0] != '/') &&
d1734 1
a1734 1
				if (*p == '/')
d1934 1
a1934 1
	if (Xstring(xs, xp)[0] != '/') {
@


1.236
log
@ensure at least two spaces of cell-to-cell horizontal padding in print_columns;
audit all callers of print_columns to always pass the exact maximum sizes
@
text
@d2012 1
a2012 1
	if ((fd = open(dv, O_RDWR | O_BINARY)) < 0) {
d2014 1
a2014 1
		if ((fd = open(dv, O_RDWR | O_BINARY)) < 0) {
@


1.235
log
@omit trailing whitespace for print_columns
@
text
@d1258 4
a1261 3
	 * We use (max_col + 1) to consider the space separator.
	 * Note that no space is printed after the last column
	 * to avoid problems with terminals that have auto-wrap.
d1263 1
a1263 1
	cols = x_cols / (max_col + 1);
d1282 2
a1284 2
	if (nspace <= 0)
		nspace = 1;
@


1.234
log
@simplify print_columns func argument: no need to return the first arg any more
@
text
@d1286 8
a1293 7
			i = c * rows + r;
			if (i < n) {
				(*func)(str, max_oct, i, arg);
				shf_fprintf(shf, "%*s", max_col, str);
				if (i + rows < n)
					shf_fprintf(shf, "%*s", nspace, null);
			}
@


1.233
log
@in print_columns, skip space padding for all last cells, not just
those in the last column, for jagged arrays
@
text
@d176 1
a176 1
static char *options_fmt_entry(char *, size_t, unsigned int, const void *);
d180 1
a180 1
static char *
a187 1
	return (buf);
d1229 1
a1229 1
    char *(*func)(char *, size_t, unsigned int, const void *),
d1266 5
a1270 3
		for (i = 0; i < n; ++i)
			shf_fprintf(shf, "%s\n",
			    (*func)(str, max_oct, i, arg));
d1288 2
a1289 2
				shf_fprintf(shf, "%*s", max_col,
				    (*func)(str, max_oct, i, arg));
@


1.232
log
@sometimes, I feel pretty stupid

separate the backslash+newline things out of the *.opt files,
logically not 100% clean, but better as it is not generated
content anyway (keeping the one-liners in there for now, even
though more consistent would be shifting them out as well)
@
text
@d1289 1
a1289 1
				if (c + 1 < cols)
@


1.231
log
@…
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.221 2014/11/25 21:13:29 tg Exp $");
d125 11
@


1.230
log
@make it compile
@
text
@d96 2
a97 2
	setctypes(digits_uc, C_ALPHA);
	setctypes(digits_lc, C_ALPHA);
@


1.229
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@a95 2
	int c;

@


1.228
log
@EBCDIC helpers and OS/390 signals
@
text
@d98 2
a99 4
	for (c = 'a'; c <= 'z'; c++)
		chtypes[c] |= C_ALPHA;
	for (c = 'A'; c <= 'Z'; c++)
		chtypes[c] |= C_ALPHA;
d546 1
a546 1
		num.u = num.u * 10U + (unsigned int)(c - '0');
d2195 2
a2196 2
			if ((c = (*fg)()) >= '0' && c <= '7')
				wc = (wc << 3) + (c - '0');
d2205 1
a2205 1
		/* FALLTHROUGH */
d2207 1
a2207 1
		i = 4;
d2209 1
a2209 1
		/* FALLTHROUGH */
d2211 1
a2211 1
		i = cstyle ? -1 : 2;
d2222 6
a2227 6
			if ((c = (*fg)()) >= '0' && c <= '9')
				wc += c - '0';
			else if (c >= 'A' && c <= 'F')
				wc += c - 'A' + 10;
			else if (c >= 'a' && c <= 'f')
				wc += c - 'a' + 10;
@


1.227
log
@use already-existing ksh_isdash helper macro
@
text
@d55 1
a55 1
static const unsigned char *cclass(const unsigned char *, unsigned char)
d779 1
a779 1
			if (sc == 0 || (p = cclass(p, sc)) == NULL)
d892 1
a892 1
cclass(const unsigned char *p, unsigned char sub)
@


1.226
log
@oksh rcsid-only sync, plus bonus rewrite of strip_nuls
(uses size_t ipv int for buffer size now, and no extra
calls to memchr/memmove, input is typically small)
@
text
@d1010 1
a1010 1
		if (flag == '-' && arg[1] == '-' && arg[2] == '\0') {
@


1.225
log
@keep “set -x” disabled during PS4 expansion, to avoid infinite looping
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2015/01/16 06:39:32 deraadt Exp $	*/
d1292 1
a1292 1
/* Strip any nul bytes from buf - returns new length (nbytes - # of nuls) */
d1294 1
a1294 1
strip_nuls(char *buf, int nbytes)
d1296 1
a1296 1
	char *dst;
d1298 15
a1312 20
	/*
	 * nbytes check because some systems (older FreeBSDs) have a
	 * buggy memchr()
	 */
	if (nbytes && (dst = memchr(buf, '\0', nbytes))) {
		char *end = buf + nbytes;
		char *p, *q;

		for (p = dst; p < end; p = q) {
			/* skip a block of nulls */
			while (++p < end && *p == '\0')
				;
			/* find end of non-null block */
			if (!(q = memchr(p, '\0', end - p)))
				q = end;
			memmove(dst, p, q - p);
			dst += q - p;
		}
		*dst = '\0';
	}
@


1.224
log
@rcsid sync from obsd; misc sync; small improvements
• mksh testsuite no longer uses printf, again
• use MAXPATHLEN from <sys/param.h> as PATH_MAX fallback
@
text
@d307 5
d336 3
a338 1
	if ((Flag(FXTRACE) = newval) == 2)
d340 3
@


1.223
log
@bump version and, also, year… I hate this… 2014 is gonna follow us for a while…
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.38 2013/11/28 10:33:37 sobrado Exp $	*/
@


1.222
log
@apparently, we’re supposed to setuid() before seteuid()
cf. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=772597
also, groups before users, methinks…
@
text
@d6 1
a6 1
 *		 2011, 2012, 2013, 2014
@


1.221
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.220 2014/11/25 20:00:39 tg Exp $");
d284 2
a285 1
		/* seteuid, setegid, setgid don't EAGAIN on Linux */
d287 1
a287 1
		seteuid(ksheuid);
d291 1
a291 1
		setegid(kshegid);
a292 1
		setgid(kshegid);
@


1.220
log
@stop using ptrdiff_t
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.219 2014/01/05 21:57:27 tg Exp $");
a487 1
		mkssert(array != NULL);
@


1.219
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.218 2013/11/30 17:33:50 tg Exp $");
d1387 1
a1387 2
	ptrdiff_t pos;
	size_t len;
@


1.219.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2015/01/16 06:39:32 deraadt Exp $	*/
d6 1
a6 1
 *		 2011, 2012, 2013, 2014, 2015
d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.219 2014/01/05 21:57:27 tg Exp $");
d284 1
a284 2
		/* setgid, setegid, seteuid don't EAGAIN on Linux */
		setgid(kshegid);
d286 1
a286 1
		setegid(kshegid);
d290 1
a290 1
		seteuid(ksheuid);
d292 1
d488 1
d1387 2
a1388 1
	size_t pos, len;
@


1.219.2.2
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.219.2.1 2015/01/25 15:35:48 tg Exp $");
a306 5
	static bool in_xtrace;

	if (in_xtrace)
		return;

d331 1
a331 3
	if ((Flag(FXTRACE) = newval) == 2) {
		in_xtrace = true;
		Flag(FXTRACE) = 0;
a332 3
		Flag(FXTRACE) = 2;
		in_xtrace = false;
	}
@


1.219.2.3
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2015/03/18 15:12:36 tedu Exp $	*/
d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.219.2.2 2015/03/01 15:43:02 tg Exp $");
d1292 1
a1292 1
/* strip all NUL bytes from buf; output is NUL-terminated if stripped */
d1294 1
a1294 1
strip_nuls(char *buf, size_t len)
d1296 1
a1296 1
	char *cp, *dp, *ep;
d1298 20
a1317 15
	if (!len || !(dp = memchr(buf, '\0', len)))
		return;

	ep = buf + len;
	cp = dp;

 cp_has_nul_byte:
	while (cp++ < ep && *cp == '\0')
		;	/* nothing */
	while (cp < ep && *cp != '\0')
		*dp++ = *cp++;
	if (cp < ep)
		goto cp_has_nul_byte;

	*dp = '\0';
@


1.218
log
@RCSID-only oksh sync (their whitespace changes don’t apply to us)
note that emacs.c partial peereboom rewrite is *not* merged, and kept that way
@
text
@d6 1
a6 1
 *		 2011, 2012, 2013
d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.217 2013/11/17 22:22:53 tg Exp $");
d52 1
a52 1
    const unsigned char *, bool);
d54 3
a56 2
    const unsigned char *, const unsigned char *);
static const unsigned char *cclass(const unsigned char *, unsigned char);
a1955 1
extern uint32_t chvt_rndsetup(const void *, size_t);
@


1.217
log
@static option creating for cmdline and set, too
(in preparation of doing something real with set ±p)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.37 2009/04/19 20:34:05 sthen Exp $	*/
d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.215 2013/08/23 14:07:36 tg Exp $");
@


1.216
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d128 1
a128 1
#include "sh_flags.h"
d136 1
a136 1
#include "sh_flags.h"
d344 12
a355 2
	static char cmd_opts[NELEM(options) + 5]; /* o:T:\0 */
	static char set_opts[NELEM(options) + 6]; /* A:o;s\0 */
d357 1
a357 1
	char *opts;
a364 30
	/* First call? Build option strings... */
	if (cmd_opts[0] == '\0') {
		char ch, *p = cmd_opts, *q = set_opts;

		/* see cmd_opts[] declaration */
		*p++ = 'o';
		*p++ = ':';
#ifdef KSH_CHVT_FLAG
		*p++ = 'T';
		*p++ = ':';
#endif
		/* see set_opts[] declaration */
		*q++ = 'A';
		*q++ = ':';
		*q++ = 'o';
		*q++ = ';';
		*q++ = 's';

		for (i = 0; i < NELEM(options); i++) {
			if ((ch = OFC(i))) {
				if (OFF(i) & OF_CMDLINE)
					*p++ = ch;
				if (OFF(i) & OF_SET)
					*q++ = ch;
			}
		}
		*p = '\0';
		*q = '\0';
	}

@


1.215
log
@SECURITY: Unbreak “set +p”, broken by OpenBSD ksh change.

TODO: I am seriously considering following Chet and changing
the way this works, by explicitly dropping privs unless the
shell is run with -p. Every other shell does it like mksh,
except Heirloom sh, which on the other hand doesn’t know any
explicit set -p or set +p (though it doesn’t know set +foo
for any foo either).

┌──┤ QUESTION: Do we need the ability to do this:
│ tg@@blau:~ $ ./suidmksh -p -c 'whoami; set +p; whoami'
│ root
│ tg

If not, I’m seriously considering to drop set ±p as well,
only parse -p on the command line, with +p being the default,
and dropping FPRIVILEGED.

Thanks to RT for noticing and jilles for initial follow-up
discussion, as well as Chet Ramey for doing the sane/secure
thing instead of following Debian.
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.214 2013/08/11 14:57:09 tg Exp $");
d2019 1
a2019 1
	if ((fd = open(dv, O_RDWR)) < 0) {
d2021 1
a2021 1
		if ((fd = open(dv, O_RDWR)) < 0) {
@


1.214
log
@improve density of .rodata (with net win on .text size(1)) via better struct packing
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.213 2013/07/21 18:47:20 tg Exp $");
d274 1
d282 1
a282 1
#else
a283 1
		ksheuid = kshuid = getuid();
d292 1
a292 1
#endif
@


1.213
log
@Fix most “set -x” problems (LP#1179287)

• “set -x” manually (cmdline too) snapshots fd#2 now
• “set -o inherit-xtrace” introduced; default still enabled
• reverted iodup printing to pre-R45 behaviour
• made Flag(FXTRACE) a proper state machine
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.212 2013/06/03 22:28:05 tg Exp $");
d126 1
d130 5
a134 1
const struct shoption options[] = {
d145 1
a145 1
	size_t i;
d147 3
a149 3
	if ((n[0] == '-' || n[0] == '+') && n[1] && !n[2]) {
		for (i = 0; i < NELEM(options); i++)
			if (options[i].c == n[1])
d151 8
a158 3
	} else for (i = 0; i < NELEM(options); i++)
		if (options[i].name && strcmp(options[i].name, n) == 0)
			return (i);
d178 1
a178 1
	    oi->opt_width, options[oi->opts[i]].name,
d197 1
a197 1
			if (options[i].name) {
a198 1
				len = strlen(options[i].name);
d201 1
a201 1
				len = utf_mbswidth(options[i].name);
d212 3
a214 4
		while (i < (int)NELEM(options)) {
			if (Flag(i) && options[i].name)
				shprintf("%s %s %s", null, "-o",
				    options[i].name);
d224 2
a225 2
	size_t i;
	char m[(int)FNFLAGS + 1];
d228 5
a232 3
	for (i = 0; i < NELEM(options); i++)
		if (options[i].c && Flag(i))
			*cp++ = options[i].c;
d357 1
a357 1
		char *p = cmd_opts, *q = set_opts;
d374 5
a378 5
			if (options[i].c) {
				if (options[i].flags & OF_CMDLINE)
					*p++ = options[i].c;
				if (options[i].flags & OF_SET)
					*q++ = options[i].c;
d446 1
a446 1
			else if ((i != (size_t)-1) && (options[i].flags & what))
d479 2
a480 2
				if (optc == options[i].c &&
				    (what & options[i].flags)) {
@


1.212
log
@support n̲o̲t̲ fork(2)ing for -T (by prepending the tty with ‘!’); especially useful on Linux since our own setsid(2) is more annoying; gets rid of the need for oneit_lite and similar hacks; WARNING: also removes chown/chmod on the tty!
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.210 2013/04/27 19:09:13 tg Exp $");
d232 1
a232 1
	unsigned char newval;
d234 4
d293 31
d482 4
a485 2
		if (argv[go.optind][0] == '-')
			Flag(FVERBOSE) = Flag(FXTRACE) = 0;
@


1.211
log
@• Allow setting both -o posix and -o sh (although only in the same
  command; setting one still unsets the other at first)
• Change subst_exstat to be conformant unless -o sh is set and -o posix isn’t
• In lksh, make subst_exstat (newly) conformant if -o posix
• New MKSH_BINSHPOSIX to accompany MKSH_BINSHREDUCED
• Sync lksh manpage precisely
@
text
@d57 1
a57 1
static void chvt(const char *);
d417 1
a417 1
			chvt(go.optarg);
d1928 1
d1932 1
a1932 1
chvt(const char *fn)
d1934 2
a1935 2
	char dv[20];
	struct stat sb;
d1938 13
a1950 7
	if (*fn == '-') {
		memcpy(dv, "-/dev/null", sizeof("-/dev/null"));
		fn = dv + 1;
	} else {
		if (stat(fn, &sb)) {
			memcpy(dv, "/dev/ttyC", 9);
			strlcpy(dv + 9, fn, sizeof(dv) - 9);
d1952 6
a1957 4
				strlcpy(dv + 8, fn, sizeof(dv) - 8);
				if (stat(dv, &sb))
					errorf("%s: %s %s", "chvt",
					    "can't find tty", fn);
a1958 1
			fn = dv;
d1961 2
a1962 5
			errorf("%s %s %s", "chvt: not a char", "device", fn);
		if ((sb.st_uid != 0) && chown(fn, 0, 0))
			warningf(false, "%s: %s %s", "chvt", "can't chown root", fn);
		if (((sb.st_mode & 07777) != 0600) && chmod(fn, (mode_t)0600))
			warningf(false, "%s: %s %s", "chvt", "can't chmod 0600", fn);
d1964 1
a1964 1
		if (revoke(fn))
d1968 3
a1970 1
			    fn);
d1972 1
a1972 1
	if ((fd = open(fn, O_RDWR)) < 0) {
d1974 3
a1976 2
		if ((fd = open(fn, O_RDWR)) < 0)
			errorf("%s: %s %s", "chvt", "can't open", fn);
d1978 9
a1986 7
	switch (fork()) {
	case -1:
		errorf("%s: %s %s", "chvt", "fork", "failed");
	case 0:
		break;
	default:
		exit(0);
d1990 1
a1990 1
	if (fn != dv + 1) {
d2001 1
a2001 8
	{
		register uint32_t h;

		NZATInit(h);
		NZATUpdateMem(h, &rndsetupstate, sizeof(rndsetupstate));
		NZAATFinish(h);
		rndset((unsigned long)h);
	}
@


1.210
log
@x_cols is a signed long in lksh; unbreak "set -o" and other print_columns using code
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.209 2013/04/26 19:10:58 tg Exp $");
d280 4
a283 5
		Flag(FPOSIX) = Flag(FSH) = Flag(FBRACEEXPAND) = 0;
		Flag(f) = newval;
	}
	/* Changing interactive flag? */
	if (f == FTALKING) {
d308 1
d382 11
@


1.209
log
@fix remaining signed int nonsense I am aware of
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.208 2013/04/01 02:37:51 tg Exp $");
d1224 1
a1225 1
	nspace = (x_cols + max_col * cols) / cols;
@


1.208
log
@one can’t cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(I’m gonna have to revise lots more code…)
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.207 2013/02/24 14:22:43 tg Exp $");
d475 1
a475 1
	unsigned int i = 0;
d478 2
d497 1
a497 1
		if (i > 214748364U)
d500 2
a501 2
		i = i * 10U + (unsigned int)(c - '0');
		/* now: i <= 2147483649U */
d504 1
a504 1
	if (i > (neg ? 2147483648U : 2147483647U))
d508 3
a510 1
	*ai = neg ? -(int)i : (int)i;
@


1.207
log
@optimise prefer_cols print_columns display
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.205 2012/12/17 23:18:08 tg Exp $");
d1982 1
a1982 1
		rndset((long)h);
@


1.206
log
@why’s there a space before the newline?
@
text
@d6 1
a6 1
 *		 2011, 2012
d1216 2
a1217 3
		i = rows;
		rows = cols > n ? n : cols;
		cols = i;
@


1.205
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.204 2012/12/05 19:38:22 tg Exp $");
d1209 1
a1209 1
			shf_fprintf(shf, "%s \n",
@


1.204
log
@fix libFirm/cparser -Wsign-compare
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.203 2012/12/04 01:18:31 tg Exp $");
d1856 1
a1856 1
			bi_errorf("%s: %s", tryp, strerror(errno));
@


1.203
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.201 2012/11/30 17:34:46 tg Exp $");
d55 1
a55 1
static const unsigned char *cclass(const unsigned char *, int);
d229 1
a229 1
change_flag(enum sh_flag f, int what, unsigned int newval)
d232 1
d235 1
a235 2
	/* needed for tristates */
	Flag(f) = newval ? 1 : 0;
d252 1
a252 1
		Flag(f) = (unsigned char)newval;
d281 1
a281 1
		Flag(f) = (unsigned char)newval;
d286 1
a286 1
			Flag(FTALKING_I) = (unsigned char)newval;
d302 2
a303 1
	char set, *opts;
d358 1
a358 1
		set = (go.info & GI_PLUS) ? 0 : 1;
d382 1
a382 1
			if ((i != (size_t)-1) && set == Flag(i))
d405 1
a405 1
			change_flag(FTALKING, OF_CMDLINE, 1);
d710 1
a710 1
	int sc, pc;
d840 1
a840 1
cclass(const unsigned char *p, int sub)
d842 2
a843 1
	int c, d, notp, found = 0;
d846 1
a846 1
	if ((notp = (ISMAGIC(*p) && *++p == '!')))
d880 1
a880 1
			found = 1;
@


1.202
log
@Rewrite the getn function (again) to fix any remaining issues.
@
text
@d448 1
@


1.201
log
@open distinguishes between >=0 and ==-1 but <-1 is undef, make it error
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.200 2012/10/22 20:52:47 tg Exp $");
d472 2
a473 2
	int c;
	unsigned int i, j, k;
a474 1
	int rv = 0;
d479 3
a481 1
	if (c == '-') {
d483 2
d486 3
a488 4
	} else if (c == '+')
		c = *s++;
	k = neg ? 2147483648U : 2147483647U;
	j = i = 0;
d491 7
a497 4
			goto getn_out;
		if ((j = i * 10 + c - '0') > k)
			goto getn_out;
		i = j;
a498 1
	rv = 1;
d500 6
a505 3
 getn_out:
	*ai = i == 2147483648U ? (int)i : neg ? -(int)i : (int)i;
	return (rv);
@


1.201.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.201 2012/11/30 17:34:46 tg Exp $");
a447 1
		mkssert(array != NULL);
d472 2
a473 2
	char c;
	unsigned int i = 0;
d475 1
d480 1
a480 3

	switch (c) {
	case '-':
a481 2
		/* FALLTHROUGH */
	case '+':
d483 4
a486 3
		break;
	}

d489 4
a492 7
			/* not numeric */
			return (0);
		if (i > 214748364U)
			/* overflow on multiplication */
			return (0);
		i = i * 10U + (unsigned int)(c - '0');
		/* now: i <= 2147483649U */
d494 1
d496 3
a498 6
	if (i > (neg ? 2147483648U : 2147483647U))
		/* overflow for signed 32-bit int */
		return (0);

	*ai = neg ? -(int)i : (int)i;
	return (1);
@


1.201.2.2
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.201.2.1 2012/12/04 01:26:28 tg Exp $");
d55 1
a55 1
static const unsigned char *cclass(const unsigned char *, unsigned char);
d229 1
a229 1
change_flag(enum sh_flag f, int what, bool newset)
a231 1
	unsigned char newval;
d234 2
a235 1
	Flag(f) = newval = (newset ? 1 : 0);
d252 1
a252 1
		Flag(f) = newval;
d281 1
a281 1
		Flag(f) = newval;
d286 1
a286 1
			Flag(FTALKING_I) = newval;
d302 1
a302 2
	bool set;
	char *opts;
d357 1
a357 1
		set = tobool(!(go.info & GI_PLUS));
d381 1
a381 1
			if ((i != (size_t)-1) && (set ? 1U : 0U) == Flag(i))
d404 1
a404 1
			change_flag(FTALKING, OF_CMDLINE, true);
d709 1
a709 1
	unsigned char sc, pc;
d839 1
a839 1
cclass(const unsigned char *p, unsigned char sub)
d841 1
a841 2
	unsigned char c, d;
	bool notp, found = false;
d844 1
a844 1
	if ((notp = tobool(ISMAGIC(*p) && *++p == '!')))
d878 1
a878 1
			found = true;
@


1.201.2.3
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.201.2.2 2012/12/05 19:58:32 tg Exp $");
d449 1
@


1.200
log
@maybe this makes gcc not bitch… again… anal-retentive arsecompiler…
found in opensuse buildservice logs for centos 5
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.199 2012/10/03 17:24:21 tg Exp $");
d1941 1
a1941 1
	if ((fd = open(fn, O_RDWR)) == -1) {
d1943 1
a1943 1
		if ((fd = open(fn, O_RDWR)) == -1)
@


1.199
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.198 2012/10/03 15:13:33 tg Exp $");
d497 1
a497 1
	*ai = i == 2147483648U ? -2147483648 : neg ? -(int)i : (int)i;
@


1.198
log
@repair choiceless select builtin
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.197 2012/07/30 21:37:13 tg Exp $");
d472 2
a473 1
	int i, c, rv = 0;
d475 1
d485 2
a486 1
	*ai = i = 0;
d490 1
a490 3
		i *= 10;
		if (i < *ai)
			/* overflow */
d492 1
a492 2
		i += c - '0';
		*ai = i;
d497 1
a497 2
	if (neg)
		*ai = -*ai;
@


1.197
log
@implement ksh93 feature ${ foo;}
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.196 2012/07/20 21:18:45 tg Exp $");
d158 1
a158 1
static char *options_fmt_entry(char *, size_t, int, const void *);
d163 1
a163 1
options_fmt_entry(char *buf, size_t buflen, int i, const void *arg)
d179 1
a179 1
		ssize_t n = 0, len, octs = 0;
d193 2
a194 2
				if (len > oi.opt_width)
					oi.opt_width = len;
d1161 2
a1162 2
print_columns(struct shf *shf, int n,
    char *(*func)(char *, size_t, int, const void *),
d1165 1
a1165 1
	int i, r, c, rows, cols, nspace, max_col;
d1168 4
a1171 1
	if (n <= 0) {
d1173 2
a1174 1
		internal_warningf("print_columns called with n=%d <= 0", n);
d1178 1
d1180 1
a1180 1
	if (max_colz > 2147483647) {
d1182 2
a1183 2
		internal_warningf("print_columns called with max_col=%zu > INT_MAX",
		    max_colz);
a1186 2
	max_col = (int)max_colz;

@


1.196
log
@make 'typeset -p' (and soon ${foo@@$}) output strings safe for re-entry
into AT&T ksh93 (that we still must use octal, in this day and age,
because dgk’s \x is broken… tss…)

not round-trip, as ksh93 doesn’t encode hi-bit7 or \v, but safe
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.195 2012/07/01 15:54:56 tg Exp $");
d104 1
a104 1
	setctypes(" \t\n|&;<>()", C_LEX1);
d106 1
a106 1
	setctypes(" \t\n", C_IFSWS);
@


1.195
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/ – add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.194 2012/06/26 19:22:19 tg Exp $");
d1142 1
a1142 1
					shf_fprintf(shf, "\\x%02X", c);
@


1.194
log
@disable mksh feature -T in lksh
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.193 2012/05/05 17:37:43 tg Exp $");
d2009 1
a2009 1
#ifdef MKSH_SMALL
@


1.193
log
@sprinkle CONSERVATIVE_FDS for many older OSes; DISABLE_TTY_WARNING for BeOS and Coherent (probably more to come); NO_CMDLINE_EDITING to Plan 9; put Hurd NO_PATH_MAX into MKSH__ private namespace
@
text
@d33 14
a46 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.192 2012/05/05 15:10:39 tg Exp $");
d56 1
a56 1
#ifdef TIOCSCTTY
d316 1
a316 1
#if !defined(MKSH_SMALL) || defined(TIOCSCTTY)
d397 1
a397 1
#if !defined(MKSH_SMALL) || defined(TIOCSCTTY)
d401 1
a401 1
#ifndef TIOCSCTTY
d1901 1
a1901 1
#ifdef TIOCSCTTY
@


1.192
log
@my own over-optimisation prevents me from making the MKSH__NO_SYMLINK
case as nice as it could be, since part of the “if (0) {” case is jumped
into for the first run of the loop… thanks RT
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.191 2012/05/04 22:05:02 tg Exp $");
d1291 1
a1291 1
#ifdef NO_PATH_MAX
d1324 1
a1324 1
#ifdef NO_PATH_MAX
d1421 1
a1421 1
#ifdef NO_PATH_MAX
d1809 1
a1809 1
#ifdef NO_PATH_MAX
@


1.191
log
@more symlink(7) nonexistence support code
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.189 2012/05/04 20:49:06 tg Exp $");
a1408 1
#ifndef MKSH__NO_SYMLINK
d1411 1
d1446 3
a1448 1
			} else {
a1461 1
#endif
@


1.190
log
@generalise the skipping sete{u,g}id() case for Coherent, not just BeOS
@
text
@d1392 1
a1392 1
		if (lstat(Xstring(xs, xp), &sb)) {
d1409 1
d1460 1
@


1.189
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.188 2012/05/04 20:08:25 tg Exp $");
d257 1
a257 2
#ifndef __BEOS__
		/* BeOS doesn't have different UIDs */
d261 1
a261 2
#ifndef __BEOS__
		/* BeOS doesn't have different GIDs */
@


1.188
log
@move bi_getn from misc.c to funcs.c and make it static

even antique gcc versions will usually inline it now
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.187 2012/04/06 12:59:27 tg Exp $");
d229 1
d240 3
a242 1
	} else if (f == FPRIVILEGED && oldval && !newval) {
@


1.187
log
@drop the need for strcasestr: just uppercase a copy and compare with uppercased
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.186 2012/04/01 16:55:16 tg Exp $");
a487 11
/* getn() that prints error */
int
bi_getn(const char *as, int *ai)
{
	int rv;

	if (!(rv = getn(as, ai)))
		bi_errorf("%s: %s", as, "bad number");
	return (rv);
}

@


1.186
log
@BeOS has no tty nor uid/gid other than 0, a̲n̲d̲ a broken /bin/sh
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.185 2012/03/26 20:04:05 tg Exp $");
a2002 20
#if !HAVE_STRCASESTR
const char *
stristr(const char *b, const char *l)
{
	char first, c;
	size_t n;

	if ((first = *l++), ((first = ksh_tolower(first)) == '\0'))
		return (b);
	n = strlen(l);
 stristr_look:
	while ((c = *b++), ((c = ksh_tolower(c)) != first))
		if (c == '\0')
			return (NULL);
	if (strncasecmp(b, l, n))
		goto stristr_look;
	return (b - 1);
}
#endif

@


1.185
log
@winstonw made me discover there is no ELOOP in Plan 9:
http://plan9.bell-labs.com/sources/plan9/sys/include/ape/errno.h
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.184 2012/03/23 21:58:22 tg Exp $");
d253 5
a257 1
		seteuid(ksheuid = kshuid = getuid());
d259 2
d262 1
@


1.184
log
@always keep x_cols and x_lins valid; check once at start including tty init
if we find any, but not later; do not check on every read

⇒ allows changing COLUMNS and LINES (independent of each other, or both)
  for script shells by passing them in an environment setting, even if
  we get a tty; interactive shells still check before each line is read…

reported by the PLD guys, thanks
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.183 2012/03/23 20:07:11 tg Exp $");
d1314 4
@


1.183
log
@drop use of the NOT macro, [^foo] ≠ [!foo] anyway, and we’re not gonna change that
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.182 2012/01/04 22:38:33 tg Exp $");
a1176 4
	/* ensure x_cols is valid first */
	if (x_cols < MIN_COLS)
		change_winsz();

@


1.182
log
@I hate having to do those year bumps…
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.181 2012/01/04 19:09:35 tg Exp $");
d648 1
a648 1
				if (ISMAGIC(p[1]) && p[2] == NOT)
d827 1
a827 1
	if ((notp = (ISMAGIC(*p) && *++p == NOT)))
@


1.181
log
@fix regression escaping single-char strings
@
text
@d5 2
a6 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.180 2011/12/29 22:54:20 tg Exp $");
@


1.180
log
@give dumptree an dumpioact helper
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.179 2011/12/03 00:03:25 tg Exp $");
d1040 2
a1041 4
	while ((c = *p++) != 0)
		if (c < 32)
			break;
		else if (ctype(*p, C_QUOTE))
@


1.179
log
@-Wpointer-sign
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.178 2011/12/03 00:01:27 tg Exp $");
d1033 1
a1033 1
print_value_quoted(const char *s)
d1050 1
a1050 1
			shf_puts(s, shl_stdout);
d1063 1
a1063 1
					shf_putc('\'', shl_stdout);
d1066 1
a1066 1
				shf_putc('\\', shl_stdout);
d1068 1
a1068 1
				shf_putc('\'', shl_stdout);
d1071 1
a1071 1
			shf_putc(c, shl_stdout);
d1078 2
a1079 2
		shf_putc('$', shl_stdout);
		shf_putc('\'', shl_stdout);
d1085 1
a1085 1
					shf_fprintf(shl_stdout, "\\u%04X", wc);
d1125 1
a1125 1
				shf_putc('\\', shl_stdout);
d1133 1
a1133 1
					shf_fprintf(shl_stdout, "\\x%02X", c);
d1137 1
a1137 1
				shf_putc(c, shl_stdout);
d1144 1
a1144 1
		shf_putc('\'', shl_stdout);
@


1.178
log
@move compile-time assertions out of misc.c(#ifdef DEBUG) into Build.sh
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.177 2011/10/26 20:46:15 tg Exp $");
d1082 1
a1082 1
				n = utf_mbtowc(&wc, p);
@


1.177
log
@forgotten in cid 1004EA5BF612F516747 to take '\n' presence as $'…' quoting reason
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.176 2011/10/25 22:36:37 tg Exp $");
a1965 13
#define assert_eq(name, a, b) char name[a == b ? 1 : -1]
#define assert_ge(name, a, b) char name[a >= b ? 1 : -1]
assert_ge(intsize_is_okay, sizeof(int), 4);
assert_eq(intsizes_are_okay, sizeof(int), sizeof(unsigned int));
assert_ge(longsize_is_okay, sizeof(long), sizeof(int));
assert_eq(arisize_is_okay, sizeof(mksh_ari_t), 4);
assert_eq(uarisize_is_okay, sizeof(mksh_uari_t), 4);
assert_eq(sizesizes_are_okay, sizeof(size_t), sizeof(ssize_t));
assert_eq(ptrsizes_are_okay, sizeof(ptrdiff_t), sizeof(void *));
assert_eq(ptrsize_is_sizet, sizeof(ptrdiff_t), sizeof(size_t));
/* formatting routines assume this */
assert_ge(ptr_fits_in_long, sizeof(long), sizeof(size_t));

@


1.176
log
@rename more identifiers with trailing underscores
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.175 2011/10/25 22:25:06 tg Exp $");
d1041 1
a1041 1
		if (c < 32 && c != '\n')
@


1.175
log
@also Xcheck_grow_ may not end with an underscore
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.174 2011/10/24 19:40:58 tg Exp $");
d2032 1
a2032 1
strndup_(const char *src, size_t len, Area *ap)
d2045 1
a2045 1
strdup_(const char *src, Area *ap)
d2047 1
a2047 1
	return (src == NULL ? NULL : strndup_(src, strlen(src), ap));
@


1.174
log
@also emit newline as backslash-n to align with GNU bash (and to keep everything on one line)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.172 2011/09/07 15:24:18 tg Exp $");
d99 1
a99 1
Xcheck_grow_(XString *xsp, const char *xp, size_t more)
@


1.173
log
@when printing for-reentry parameter values, use dgk’s $'…' for non-ASCII characters
@
text
@d1104 4
d1126 3
a1128 5
				/* FALLTHROUGH */
			case '\n':
 dgk_regchar:
				shf_putc(c, shl_stdout);
				break;
d1130 2
a1131 3
				if (c >= 32 && c <= 0x7E)
					goto dgk_regchar;
				/* FALLTHROUGH */
d1133 5
a1137 1
				shf_fprintf(shl_stdout, "\\x%02X", c);
@


1.172
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.171 2011/08/27 18:06:49 tg Exp $");
d1035 3
a1037 2
	const char *p;
	bool inquote = false;
d1040 2
a1041 2
	for (p = s; *p; p++)
		if (ctype(*p, C_QUOTE))
d1043 10
a1052 5
	if (!*p) {
		/* nope, use the shortcut */
		shf_puts(s, shl_stdout);
		return;
	}
d1054 14
a1067 8
	/* quote via state machine */
	for (p = s; *p; p++) {
		if (*p == '\'') {
			/*
			 * multiple '''s or any ' at beginning of string
			 * look nicer this way than when simply substituting
			 */
			if (inquote) {
d1069 65
a1133 1
				inquote = false;
a1134 4
			shf_putc('\\', shl_stdout);
		} else if (!inquote) {
			shf_putc('\'', shl_stdout);
			inquote = true;
d1136 1
a1136 1
		shf_putc(*p, shl_stdout);
@


1.171
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.170 2011/08/27 17:30:07 tg Exp $");
d188 1
a188 1
		shf_puts(T_set, shl_stdout);
d1077 1
a1077 1
    const void *arg, size_t max_oct, size_t max_col_, bool prefcol)
d1089 1
a1089 1
	if (max_col_ > 2147483647) {
d1091 2
a1092 1
		internal_warningf("print_columns called with max_col=%zu > INT_MAX", max_col_);
d1096 1
a1096 1
	max_col = (int)max_col_;
@


1.170
log
@jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.169 2011/07/06 22:21:57 tg Exp $");
d144 1
a144 1
static char *options_fmt_entry(char *, int, int, const void *);
d149 1
a149 1
options_fmt_entry(char *buf, int buflen, int i, const void *arg)
d162 1
a162 1
	int i = 0;
d165 1
a165 1
		int n = 0, len, octs = 0;
d172 1
a172 1
		while (i < (int)NELEM(options)) {
d202 1
a202 1
	unsigned int i;
d1076 2
a1077 2
    char *(*func)(char *, int, int, const void *),
    const void *arg, int max_oct, int max_col, bool prefcol)
d1079 1
a1079 1
	int i, r, c, rows, cols, nspace;
d1089 8
d1460 1
a1460 1
	int len, plen = 0;
d1888 12
a1899 6
char intsize_is_okay[sizeof(int) >= 4 ? 1 : -1];
char intsizes_are_okay[sizeof(int) == sizeof(unsigned int) ? 1 : -1];
char longsize_is_okay[sizeof(long) >= sizeof(int) ? 1 : -1];
char longsizes_are_okay[sizeof(long) == sizeof(unsigned long) ? 1 : -1];
char arisize_is_okay[sizeof(mksh_ari_t) == 4 ? 1 : -1];
char uarisize_is_okay[sizeof(mksh_uari_t) == 4 ? 1 : -1];
@


1.169
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.168 2011/06/12 15:37:08 tg Exp $");
a1917 1
#ifndef MKSH_ASSUME_UTF8
a1936 1
#endif
@


1.168
log
@drop long-deprecated 'set ±o arc4random'
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.167 2011/06/12 14:45:34 tg Exp $");
d1870 3
a1872 3
		oaat1_init_impl(h);
		oaat1_addmem_impl(h, &rndsetupstate, sizeof(rndsetupstate));
		oaat1_fini_impl(h);
@


1.167
log
@ACK found a missing "static", gcc on Minix found a missing cast; add more type size checks
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.166 2011/05/29 02:18:53 tg Exp $");
a358 8
#ifndef MKSH_NO_DEPRECATED_WARNING
			if ((enum sh_flag)i == FARC4RANDOM) {
				warningf(true, "Do not use set ±o arc4random,"
				    " it will be removed in the next version"
				    " of mksh!");
				return (0);
			}
#endif
@


1.167.2.1
log
@MFC from HEAD and adjust version

Build.sh:
- better handling of eval and CPPFLAGS in build system
- partial OPENSTEP support
- fix typo

check.t:
- mark utf8opt-2a as need-pass: no (1.481)

dot.mkshrc:
- do not close stderr (1.65)
- use only printable characters (1.65)

edit.c:
- upper bound Emacs mode command repeat by input line length

funcs.c, sh.h:
- optimise an if away, and possibly even the function bodies…

misc.c:
- jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr

mksh.1, sh.h. var.c:
- fix spelling

mksh.1:
- document "export -"

sh.h:
- undef optarg, optind in case the OE predefines them (1.493)

shf.c:
- handle %zu (size_t), %zd (ssize_t), etc. (1.43)

syn.c:
- avoid (not-)function-local externs (1.68)

multiple:
- do not use macros or identifiers ending with an underscore
- more {,s}size_t, type, lint, other cleanups (edit.c 1.220; eval.c 1.107;
  exec.c 1.95; expr.c 1.48; funcs.c 1.196; histrap.c 1.110; jobs.c 1.81;
  lalloc.c 1.18; lex.c 1.155; main.c 1.198; misc.c 1.171; sh.h 1.493;
  shf.c 1.43; tree.c 1.50; var.c 1.131)
- wrap access(2) (edit.c 1.221; exec.c 1.96; expr.c 1.49; funcs.c 1.197;
  histrap.c 1.111; sh.h 1.494)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.167 2011/06/12 14:45:34 tg Exp $");
d99 1
a99 1
Xcheck_grow(XString *xsp, const char *xp, size_t more)
d144 1
a144 1
static char *options_fmt_entry(char *, size_t, int, const void *);
d149 1
a149 1
options_fmt_entry(char *buf, size_t buflen, int i, const void *arg)
d162 1
a162 1
	size_t i = 0;
d165 1
a165 1
		ssize_t n = 0, len, octs = 0;
d172 1
a172 1
		while (i < NELEM(options)) {
d188 1
a188 1
		shf_puts(Tset, shl_stdout);
d202 1
a202 1
	size_t i;
d1084 2
a1085 2
    char *(*func)(char *, size_t, int, const void *),
    const void *arg, size_t max_oct, size_t max_colz, bool prefcol)
d1087 1
a1087 1
	int i, r, c, rows, cols, nspace, max_col;
a1096 9
	if (max_colz > 2147483647) {
#ifndef MKSH_SMALL
		internal_warningf("print_columns called with max_col=%zu > INT_MAX",
		    max_colz);
#endif
		return;
	}
	max_col = (int)max_colz;

d1460 1
a1460 1
	size_t len, plen = 0;
d1888 6
a1893 12
#define assert_eq(name, a, b) char name[a == b ? 1 : -1]
#define assert_ge(name, a, b) char name[a >= b ? 1 : -1]
assert_ge(intsize_is_okay, sizeof(int), 4);
assert_eq(intsizes_are_okay, sizeof(int), sizeof(unsigned int));
assert_ge(longsize_is_okay, sizeof(long), sizeof(int));
assert_eq(arisize_is_okay, sizeof(mksh_ari_t), 4);
assert_eq(uarisize_is_okay, sizeof(mksh_uari_t), 4);
assert_eq(sizesizes_are_okay, sizeof(size_t), sizeof(ssize_t));
assert_eq(ptrsizes_are_okay, sizeof(ptrdiff_t), sizeof(void *));
assert_eq(ptrsize_is_sizet, sizeof(ptrdiff_t), sizeof(size_t));
/* formatting routines assume this */
assert_ge(ptr_fits_in_long, sizeof(long), sizeof(size_t));
d1926 1
d1946 1
d1950 1
a1950 1
strndup_i(const char *src, size_t len, Area *ap)
d1963 1
a1963 1
strdup_i(const char *src, Area *ap)
d1965 1
a1965 1
	return (src == NULL ? NULL : strndup_i(src, strlen(src), ap));
@


1.167.2.2
log
@• MFC this week’s bag of misc fixes
• mark “set ±o arc4random” MKSH_DISABLE_DEPRECATED (for e.g. Android)
@
text
@d359 1
a359 1
#if !defined(MKSH_NO_DEPRECATED_WARNING) && !defined(MKSH_DISABLE_DEPRECATED)
@


1.167.2.3
log
@MFC recent changes to R40-stable, validate it, fix a pedantic warning
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.167.2.2 2011/11/26 18:23:22 tg Exp $");
d1897 13
@


1.167.2.4
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d5 1
a5 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.184 2012/03/23 21:58:22 tg Exp $");
d655 1
a655 1
				if (ISMAGIC(p[1]) && p[2] == '!')
d834 1
a834 1
	if ((notp = (ISMAGIC(*p) && *++p == '!')))
d1109 4
@


1.167.2.5
log
@MFC fixes from HEAD
@
text
@d33 1
a33 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.187 2012/04/06 12:59:27 tg Exp $");
d253 1
a253 5
		ksheuid = kshuid = getuid();
#ifndef __BEOS__
		/* BeOS doesn't have different UIDs */
		seteuid(ksheuid);
#endif
a254 2
#ifndef __BEOS__
		/* BeOS doesn't have different GIDs */
a255 1
#endif
a1246 4
#ifndef ELOOP
#define ELOOP		E2BIG
#endif

d1925 20
@


1.166
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.165 2011/05/04 23:16:02 tg Exp $");
d875 1
a875 1
const unsigned char *
d1888 3
@


1.165
log
@+= support for variables and arrays
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.164 2011/03/28 21:31:01 tg Exp $");
d1644 2
a1645 2
	/* print where we cd'd? */
	bool printpath = false;
d1650 1
a1650 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
d1652 3
d1662 1
a1662 1
			return (1);
d1668 1
a1668 1
		return (1);
d1678 1
a1678 1
			return (1);
d1689 1
a1689 1
				return (1);
d1700 1
a1700 1
			return (1);
d1710 1
a1710 1
			return (1);
d1729 1
a1729 1
		return (1);
d1756 2
a1757 1
		return (1);
d1760 2
d1779 6
a1784 1
	} else if (!physical || !(pwd = allocd = do_realpath(Xstring(xs, xp))))
d1786 1
d1799 2
d1806 2
a1807 1
	return (0);
@


1.164
log
@we got a decision on pathnames with exactly two leading slashes
thanks, Eric and David!
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.163 2011/03/26 21:46:03 tg Exp $");
d284 2
a285 1
	int optc, sortargs = 0, arrayset = 0;
d404 1
a404 1
				sortargs = 1;
d431 9
a439 3
	if (arrayset && (!*array || *skip_varname(array, false))) {
		bi_errorf("%s: %s", array, "is not an identifier");
		return (-1);
@


1.163
log
@• bring back test -H ifdef S_ISCDF (for HP-UX)
• whitespace, etc.
• bump version for tonight, I’m not gonna hack on c_cd,
  all this pathname stuff is mind-boggling…
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.162 2011/03/26 21:09:09 tg Exp $");
d1371 1
a1371 1
				/* exactly two leading slashes? */
d1373 1
a1373 1
					/* SUSv4 3.266 Pathname */
d1519 1
a1519 1
 * //./C/foo/bar/../baz			//./C/foo/bar/../baz
d1541 2
a1542 2
			/* implementation defined, we CANNOT simplify this */
			return;
@


1.162
log
@• rewrite simplify_path() to keep more in line with do_realpath()
• add regression test to ensure that //foo pathnames are never simplified
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.161 2011/03/26 19:43:48 tg Exp $");
d203 1
a203 1
	char m[(int) FNFLAGS + 1];
@


1.161
log
@simplify code to use existing $PWD
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.160 2011/03/26 19:29:41 tg Exp $");
d1514 1
a1514 1
/*
d1516 11
a1526 2
 * ie, simplify_path("/a/b/c/./../d/..") returns "/a/b"
 * but simplify_path("//./C/foo/bar/../baz") stays as it is
d1529 1
a1529 1
simplify_path(char *pathl)
d1531 3
a1533 3
	char *cur, *t;
	bool isrooted;
	char *very_start = pathl, *start;
d1535 2
a1536 1
	if (!*pathl)
d1538 11
d1550 6
a1555 6
	if ((isrooted = pathl[0] == '/'))
		very_start++;
	/* exactly two leading slashes? (SUSv4 3.266) */
	if (isrooted && pathl[1] == '/' && pathl[2] != '/')
		/* implementation defined, we CANNOT simplify this */
		return;
d1557 5
a1561 10
	/*-
	 * Before			After
	 * /foo/			/foo
	 * /foo/../../bar		/bar
	 * /foo/./blah/..		/foo
	 * .				.
	 * ..				..
	 * ./foo			foo
	 * foo/../../../bar		../../bar
	 */
d1563 4
a1566 16
	for (cur = t = start = very_start; ; ) {
		/* treat multiple '/'s as one '/' */
		while (*t == '/')
			t++;

		if (*t == '\0') {
			if (cur == pathl)
				/* convert empty path to dot */
				*cur++ = '.';
			*cur = '\0';
			break;
		}

		if (t[0] == '.') {
			if (!t[1] || t[1] == '/') {
				t += 1;
d1568 25
a1592 11
			} else if (t[1] == '.' && (!t[2] || t[2] == '/')) {
				if (!isrooted && cur == start) {
					if (cur != very_start)
						*cur++ = '/';
					*cur++ = '.';
					*cur++ = '.';
					start = cur;
				} else if (cur != start)
					while (--cur > start && *cur != '/')
						;
				t += 2;
d1597 2
a1598 2
		if (cur != very_start)
			*cur++ = '/';
d1600 12
a1611 4
		/* find/copy next component of pathname */
		while (*t && *t != '/')
			*cur++ = *t++;
	}
@


1.160
log
@simplify_path: we CANNOT simplify pathnames beginning with //
since they’re implementation-defined and *not absolute*!
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.159 2011/03/26 15:37:19 tg Exp $");
d1589 1
a1589 1
set_current_wd(char *nwd)
@


1.159
log
@temporary patch for Cygwin against cd breaking UNC pathnames
from Chris “ironhead” Sutcliffe
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.158 2011/03/24 19:05:48 tg Exp $");
d1517 1
d1533 2
a1534 1
		very_start++;
@


1.158
log
@• move funcs.c:do_realpath() to misc.c and make it global
  ⇒ consider merging simplify_path()
• move funcs.c:c_cd() to misc.c
• make misc.c:make_path() static, c_cd() is its only user
  ⇒ mark as obsolete
• tweak misc.c:set_current_wd() to drop ksh_get_wd() argument

should be no code change, but the entire path stuff is a mess…
so expect actual implementation changes or even rewrites shortly
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.157 2011/03/17 22:09:22 tg Exp $");
d1371 1
d1373 1
a1373 1
					/* keep UNC names, per POSIX */
d1530 3
@


1.157
log
@fix cast; bump version
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.156 2011/03/17 22:00:45 tg Exp $");
d46 3
d1210 23
a1233 1
/* Like getcwd(), except bsize is ignored if buf is 0 (PATH_MAX is used) */
d1235 1
a1235 1
ksh_get_wd(size_t *dlen)
d1237 16
a1252 2
	char *ret, *b;
	size_t len = 1;
d1254 85
d1340 4
a1343 11
	if ((b = get_current_dir_name())) {
		len = strlen(b) + 1;
		strndupx(ret, b, len - 1, ATEMP);
		free_gnu_gcdn(b);
	} else
		ret = NULL;
#else
	if ((ret = getcwd((b = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)))
		ret = aresize(b, len = (strlen(b) + 1), ATEMP);
	else
		afree(b, ATEMP);
d1345 46
d1392 33
a1424 3
	if (dlen)
		*dlen = len;
	return (ret);
d1442 1
a1442 1
int
d1444 1
a1444 1
    /* & of : separated list */
d1582 15
d1598 2
a1599 2
void
set_current_wd(char *pathl)
d1601 9
a1609 2
	size_t len = 1;
	char *p = pathl;
d1611 140
a1750 5
	if (p == NULL) {
		if ((p = ksh_get_wd(&len)) == NULL)
			p = null;
	} else
		len = strlen(p) + 1;
d1752 2
a1753 7
	if (len > current_wd_size) {
		afree(current_wd, APERM);
		current_wd = alloc(current_wd_size = len, APERM);
	}
	memcpy(current_wd, p, len);
	if (p != pathl && p != null)
		afree(p, ATEMP);
d1756 1
@


1.156
log
@• write a pattern optimiser and call it before invoking do_gmatch(),
  to catch several very slow cases (especially “*@@(*foo)” busy-loops
  – spotted by Jb_boin as usual these days ☺) by converting all @@(…)
  with one case to drop the enclosing MAGIC(…), and in a second pass
  collapsing adjacent asterisk (‘*’) wildcards
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.155 2011/03/17 21:59:28 tg Exp $");
d501 1
a501 1
	cp = alloc(strlen((void *)sp) + 1, ATEMP);
d531 1
a531 1
			memmove(dp, sp, strlen((void *)sp) + 1);
@


1.155
log
@• make misc.c(gmatch.c):pat_scan() static and fix int → bool
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.154 2011/03/13 01:20:21 tg Exp $");
d489 73
a570 1

d575 2
d594 12
a605 2
	return (do_gmatch((const unsigned char *) s, (const unsigned char *) se,
	    (const unsigned char *) p, (const unsigned char *) pe));
@


1.154
log
@lint is your friend
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.153 2011/03/07 20:30:39 tg Exp $");
d37 2
d654 1
a654 1
			if (!(prest = pat_scan(p, pe, 0)))
d662 1
a662 1
				pnext = pat_scan(psub, pe, 1);
d681 1
a681 1
			if (!(prest = pat_scan(p, pe, 0)))
d689 1
a689 1
				pnext = pat_scan(psub, pe, 1);
d703 1
a703 1
			if (!(prest = pat_scan(p, pe, 0)))
d710 1
a710 1
					pnext = pat_scan(psub, pe, 1);
d782 1
a782 1
pat_scan(const unsigned char *p, const unsigned char *pe, int match_sep)
@


1.153
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.152 2011/03/05 21:43:17 tg Exp $");
d1597 1
a1597 1
		if (0)
d1601 1
a1601 1
		if (0)
@


1.152
log
@introduce macros for malloc, realloc, free to hide them from mksh

no code may henceforth use memory (de-)allocation functions directly
use these macros, porters can change them for abstraction
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.151 2011/02/11 01:18:19 tg Exp $");
d436 1
a436 1
		go.optind += set_array(array, arrayset > 0 ? true : false,
@


1.151
log
@• more comment and int→bool cleanup, add and improve some comments
• in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesn’t suffice
• add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
• for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
• when called as builtin, echo behaves POSIXish
• add domainname as alias for true on MirBSD only, to be able to link it
• sync mksh Makefiles with Build.sh output
• adjust manpage wrt release plans
• link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
• drop linked utilities and, except for echo and kill, their manpages
• adjust instbin and link a few more there as well
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.150 2011/01/21 21:04:45 tg Exp $");
d1133 1
a1133 1
		free(b);
@


1.150
log
@• implement KSHEGID, KSHGID, KSHUID variables by suggestion of Richard K.
  (KSHEUID aka USER_ID already exists)
• simplify, speed up LCG and $RANDOM handling again
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.149 2011/01/09 21:57:27 tg Exp $");
d34 2
a35 1
unsigned char chtypes[UCHAR_MAX + 1];	/* type bits for unsigned char */
d66 2
a67 1
		chtypes[0] |= C_IFS; /* include \0 in C_IFS */
d84 2
a85 1
	setctypes(" \t\n|&;<>()", C_LEX1); /* \0 added automatically */
d215 2
a216 1
	Flag(f) = newval ? 1 : 0;	/* needed for tristates */
d263 2
a264 1
/* Parse command line & set command arguments. Returns the index of
d269 2
a270 1
    int what,			/* OF_CMDLINE or OF_SET */
d313 2
a314 1
		/* Set FLOGIN before parsing options so user can clear
d342 2
a343 1
				/* lone -o: print options
d362 2
a363 1
				/* Don't check the context if the flag
d507 2
a508 1
	/* isfile is false iff no syntax check has been done on
d522 2
a523 1
/* Returns if p is a syntacticly correct globbing pattern, false
d531 8
a538 8
- if no magic,
	if dest given, copy to dst
	return ?
- if magic && (no globbing || syntax error)
	debunk to dst
	return ?
- return ?
*/
d546 3
a548 2
	int saw_glob = 0;
	int in_bracket = 0; /* inside [...] */
d554 1
a554 1
			saw_glob = 1;
d557 2
a558 2
				saw_glob = 1;
				in_bracket = 1;
d564 1
a564 1
			/* XXX Do we need to check ranges here? POSIX Q */
d567 2
a568 1
				if (bnest)		/* [a*(b]) */
d570 1
a570 1
				in_bracket = 0;
d573 1
a573 1
			saw_glob = 1;
d579 2
a580 1
			if (in_bracket && !bnest)	/* *(a[foo|bar]) */
d584 2
a585 1
				if (!bnest--)		/* *(a[b)c] */
d647 5
a651 2
		case 0x80|'+': /* matches one or more times */
		case 0x80|'*': /* matches zero or more times */
d673 6
a678 3
		case 0x80|'?': /* matches zero or once */
		case 0x80|'@@': /* matches one of the patterns */
		case 0x80|' ': /* simile for @@ */
d699 2
a700 1
		case 0x80|'!': /* matches none of the patterns */
d758 2
a759 1
			p += 2; /* MAGIC- */
d815 2
a816 1
/* getopt() used for shell built-in commands, the getopts command, and
d857 2
a858 1
		    ((flag != '-' ) && /* neither a - nor a + (if + allowed) */
d884 2
a885 1
	/* : means argument must be present, may be part of option argument
d917 2
a918 1
		/* argument is optional and may be attached or unattached
d939 2
a940 1
/* print variable/alias value using necessary quotes
d1056 3
a1058 2
	/* nbytes check because some systems (older FreeBSDs) have a buggy
	 * memchr()
d1148 1
a1148 1
/*
d1165 2
a1166 1
    char **cdpathp,		/* & of : separated list */
d1251 2
a1252 1
	/* Before			After
d1605 1
a1605 1
		/*
@


1.149
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Lëtzebuerg ☺

This was the third try. Where to put this was not palpable… same for =(…)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.148 2010/09/19 19:28:22 tg Exp $");
a35 5
#if !HAVE_SETRESUGID
uid_t kshuid;
gid_t kshgid, kshegid;
#endif

d231 3
a234 2
		gid_t kshegid = getgid();

d245 1
a245 1
		setegid(kshegid = kshgid = getgid());
a1303 3
	/* for entropy */
	kshstate_f.h = evilhash(fn);

d1358 8
@


1.148
log
@while here, change SETUID_CAN_FAIL_WITH_EAGAIN to abort immediately
by suggestion of Chris Palmer again
@
text
@d5 1
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.147 2010/09/14 21:26:15 tg Exp $");
d924 1
a924 1
	int inquote = 0;
d926 1
a926 1
	/* Test if any quotes are needed */
d931 1
d935 2
d939 5
a943 1
			if (inquote)
d945 2
a947 1
			inquote = 0;
d950 1
a950 1
			inquote = 1;
@


1.147
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.146 2010/09/14 21:15:10 tg Exp $");
d51 3
a53 11
	bool messaged = false;						\
									\
	while (/* CONSTCOND */ 1)					\
		if (!(func argvec) || errno != EAGAIN)			\
			break;						\
		else if (!messaged) {					\
			warningf(true, "%s failed with EAGAIN,"		\
			    " probably due to a too low process"	\
			    " limit; retrying infinitely", #func);	\
			messaged = true;				\
		}							\
@


1.146
log
@add size optimisation hacks by me from Android except ifdef’d
(note, I’d prefer everyone to keep IDSTRINGs around though)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.145 2010/08/28 20:22:21 tg Exp $");
d48 19
d104 1
a104 1
Xcheck_grow_(XString *xsp, const char *xp, unsigned int more)
d108 5
a112 2
	xsp->len += more > xsp->len ? more : xsp->len;
	xsp->beg = aresize(xsp->beg, xsp->len + 8, xsp->areap);
d247 1
a247 1
		setresgid(kshegid, kshegid, kshegid);
d249 1
d252 1
a252 1
		setresuid(ksheuid, ksheuid, ksheuid);
d254 1
d256 1
a256 1
		setuid(ksheuid);
@


1.145
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.144 2010/08/28 18:50:55 tg Exp $");
d333 1
d340 1
@


1.144
log
@improve string pooling: saves 316 bytes in .text
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.143 2010/08/28 16:47:09 tg Exp $");
d170 1
a170 1
		/* short version á la AT&T ksh93 */
d836 1
a836 1
			warningf(true, "%s%s-%c: unknown option",
d838 2
a839 1
			    (go->flags & GF_NONAME) ? "" : ": ", c);
d863 1
a863 1
			warningf(true, "%s%s-'%c' %s",
d1303 1
a1303 1
			warningf(false, "%s: %s %s", "chvt", "cannot chown root", fn);
d1305 1
a1305 1
			warningf(false, "%s: %s %s", "chvt", "cannot chmod 0600", fn);
d1309 3
a1311 2
			warningf(false, "%s: cannot revoke %s, new shell is"
			    " potentially insecure", "chvt", fn);
d1316 1
a1316 1
			errorf("%s: %s %s", "chvt", "cannot open", fn);
@


1.143
log
@fix blocking_read prototype
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.142 2010/08/28 15:48:19 tg Exp $");
d171 1
a171 1
		shf_puts("set", shl_stdout);
d174 2
a175 1
				shprintf(" -o %s", options[i].name);
d349 1
a349 1
				bi_errorf("%s: bad option", go.optarg);
d403 1
a403 1
		bi_errorf("%s: is not an identifier", array);
d460 1
a460 1
		bi_errorf("%s: bad number", as);
d862 1
a862 1
			warningf(true, "%s%s-'%c' requires argument",
d864 2
a865 1
			    (go->flags & GF_NONAME) ? "" : ": ", c);
d1294 2
a1295 1
					errorf("chvt: can't find tty %s", fn);
d1300 1
a1300 1
			errorf("chvt: not a char device: %s", fn);
d1302 1
a1302 1
			warningf(false, "chvt: cannot chown root %s", fn);
d1304 1
a1304 1
			warningf(false, "chvt: cannot chmod 0600 %s", fn);
d1308 2
a1309 2
			warningf(false, "chvt: cannot revoke %s, new shell is"
			    " potentially insecure", fn);
d1314 1
a1314 1
			errorf("chvt: cannot open %s", fn);
d1318 1
a1318 1
		errorf("chvt: %s failed", "fork");
d1325 1
a1325 1
		errorf("chvt: %s failed", "setsid");
d1328 1
a1328 1
			errorf("chvt: %s failed", "TIOCSCTTY");
d1330 1
a1330 1
			errorf("chvt: %s failed", "TCIOFLUSH");
@


1.142
log
@whitespace
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.141 2010/07/17 22:09:36 tg Exp $");
d1024 3
a1026 2
/* Like read(2), but if read fails due to non-blocking flag, resets flag
 * and restarts read.
d1028 2
a1029 2
int
blocking_read(int fd, char *buf, int nbytes)
d1031 2
a1032 2
	int ret;
	int tried_reset = 0;
d1037 1
a1037 1
				tried_reset = 1;
d1047 2
a1048 1
/* Reset the non-blocking flag on the specified file descriptor.
@


1.141
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.140 2010/07/13 13:07:56 tg Exp $");
d708 2
a709 1
				c &= 0x7f;/* extended pattern matching: *+?@@! */
d711 2
a712 1
				if (c == ' ') /* simile for @@: plain (..) */
@


1.140
log
@compatibility: stick “set ±o arc4random” around for a bit longer,
until R40 is definitively out (so there MAY still be an R39d)

this commit can easily be reverted in its entirety later, when
Build.sh’s compatibility for “-combine” &c. is removed too
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.139 2010/07/04 17:33:55 tg Exp $");
d698 1
a698 1
	int c, d, not, found = 0;
d701 1
a701 1
	if ((not = (ISMAGIC(*p) && *++p == NOT)))
d735 1
a735 1
	return ((found != not) ? p+2 : NULL);
@


1.139
log
@to speed up mksh, get rid of arc4random(3) uses and use the LCG always;
depend on ASLR for seeding
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.138 2010/01/29 09:34:29 tg Exp $");
d332 6
@


1.138
log
@remove some more of this ugliness
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.137 2010/01/28 15:18:49 tg Exp $");
d1269 3
@


1.137
log
@To solve the incompatibility issues between mksh-current, old mksh versions
and vendor pdksh versions, re-introduce FPOSIX alongside FSH. The semantics
are now:
‣ set -o posix ⇒
  • disable brace expansion and FSH when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
‣ set -o sh ⇒
  • set automatically #ifdef MKSH_BINSHREDUCED
  • disable brace expansion and FPOSIX when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
  • trigger MKSH_MIDNIGHTBSD01ASH_COMPAT mode if compiled in
  • make “set -- $(getopt ab:c "$@@")” construct work

Note that the set/getopt one used to behave POSIXly only with FSH or
FPOSIX (depending on the mksh version) set and Bourne-ish with it not
set, so this changes default mksh behaviour to POSIX!
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.136 2010/01/25 14:07:39 tg Exp $");
d554 4
a557 2
		/* else must be a MAGIC-MAGIC, or MAGIC-!, MAGIC--, MAGIC-]
			 MAGIC-{, MAGIC-,, MAGIC-} */
@


1.136
log
@fix © year
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.135 2010/01/01 18:02:00 tg Exp $");
d235 3
a237 2
	} else if (f == FSH && newval) {
		Flag(FBRACEEXPAND) = 0;
@


1.135
log
@make [[ -o ‣-U ]] = [[ -o ‣+U ]] = [[ -o ‣utf8-mode ]]
where ‘‣’ is either nothing, ‘!’ or ‘?’ as usual.
@
text
@d5 1
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.134 2009/12/05 17:43:48 tg Exp $");
@


1.134
log
@llvm/clang scan-build is now content…
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.133 2009/11/28 14:28:02 tg Exp $");
d111 5
a115 1
	for (i = 0; i < NELEM(options); i++)
@


1.133
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.131 2009/11/23 12:48:19 tg Exp $");
d247 1
a247 1
    int *setargsp)
@


1.132
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d157 1
a157 1
				len = utf_mbswidth(options[i].name, true);
@


1.131
log
@fix a warning from MirDebian mksh_39.9.20091122-0wtf1:
../../mksh/misc.c:586: warning: pointer targets in passing argument 1 of 'utf_ptradj' differ in signedness
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.130 2009/11/21 22:30:36 tg Exp $");
d157 1
a157 1
				len = utf_mbswidth(options[i].name);
@


1.131.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.132 2009/11/28 14:21:45 tg Exp $");
d157 1
a157 1
				len = utf_mbswidth(options[i].name, true);
@


1.130
log
@improve globbing:
• a=blöd; print ${a%???} → now printf 'b' not 'bl' in UTF-8 mode
• a=hä; print ${a%?} still broken
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.129 2009/11/09 23:35:10 tg Exp $");
d586 1
a586 1
				s += utf_ptradj(s);
@


1.129
log
@make print_columns() aware that octets≠characters≠columns
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.128 2009/10/30 14:37:43 tg Exp $");
d584 4
@


1.128
log
@• fix 「mksh -lT1」 (it was broken due to getpgrp() et al. being
  moved to early)
• allow ‘-T’ for MKSH_SMALL too, the installer needs it

sync clog
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.127 2009/10/30 00:57:38 tg Exp $");
d123 2
a124 2
static char *options_fmt_entry(const void *arg, int, char *, int);
static void printoptions(int);
d128 1
a128 1
options_fmt_entry(const void *arg, int i, char *buf, int buflen)
d139 1
a139 1
printoptions(int verbose)
d141 1
a141 1
	unsigned int i;
d144 1
a145 1
		int n, len;
d150 2
a151 1
		for (i = n = oi.opt_width = 0; i < NELEM(options); i++)
d153 1
d155 3
a157 1
				oi.opts[n++] = i;
d161 2
d164 1
a164 1
		    oi.opt_width + 5, 1);
d166 1
a166 1
		/* short version ala ksh93 */
d168 1
a168 1
		for (i = 0; i < NELEM(options); i++)
d171 2
d910 3
a912 2
/* Print things in columns and rows - func() is called to format the ith
 * element
d916 2
a917 2
    char *(*func) (const void *, int, char *, int),
    const void *arg, int max_width, int prefcol)
a918 1
	char *str = alloc(max_width + 1, ATEMP);
d920 11
d936 4
a939 3
	/* max_width + 1 for the space. Note that no space
	 * is printed after the last column to avoid problems
	 * with terminals that have auto-wrap.
d941 2
a942 1
	cols = x_cols / (max_width + 1);
d947 1
a947 1
			    (*func)(arg, i, str, max_width + 1));
d950 1
d952 4
a955 7
	if (prefcol && n && cols > rows) {
		int tmp = rows;

		rows = cols;
		cols = tmp;
		if (rows > n)
			rows = n;
d958 2
a959 1
	nspace = (x_cols - max_width * cols) / cols;
d966 2
a967 3
				shf_fprintf(shf, "%-*s",
				    max_width,
				    (*func)(arg, i, str, max_width + 1));
@


1.127
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d32 1
a32 7
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.126 2009/10/27 17:00:02 tg Exp $");

#undef USE_CHVT
/* XXX conditions correct? */
#if defined(TIOCSCTTY) && !defined(MKSH_SMALL)
#define USE_CHVT
#endif
d44 1
a44 1
#ifdef USE_CHVT
d256 1
a256 1
#ifndef MKSH_SMALL
d334 1
a334 1
#ifndef MKSH_SMALL
d338 1
a338 1
#ifndef USE_CHVT
d1229 3
a1231 1
#ifdef USE_CHVT
d1291 1
@


1.126
log
@do not use PATH_MAX on GNU/Hurd (even if it *was* defined), but use
some glibc-only functions that don’t require its use instead

tested on gnubber, where (admittedly) sysconf(_PC_PATH_MAX) == 1024…
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.125 2009/10/02 18:08:35 tg Exp $");
d86 1
a86 1
	setctypes(" \n\t\"#$&'()*;<>?[]\\`|", C_QUOTE);
@


1.125
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.124 2009/09/24 17:15:32 tg Exp $");
d1041 8
d1053 1
@


1.124
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.123 2009/09/20 16:40:56 tg Exp $");
d229 1
a229 1
	} else if (f == FPOSIX && newval) {
@


1.123
log
@more of this:

• shell flags are now handled in one single place (sh_flags.h)
• sync comments (between enum and array) and manpage with reality
• FMONITOR is now no longer needed for Hartz IV shells
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.122 2009/09/19 22:32:23 tg Exp $");
d204 1
a204 1
#ifndef MKSH_NOVI
d208 1
a208 1
#ifndef MKSH_NOVI
@


1.122
log
@\x only auto-converts to unicode for $'…' and printf if >0xFF
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.121 2009/09/19 21:54:45 tg Exp $");
d101 3
d105 2
a106 54
	/* Special cases (see parse_args()): -A, -o, -s.
	 * Options are sorted by their longnames - the order of these
	 * entries MUST match the order of sh_flag F* enumerations in sh.h.
	 */
	{ "allexport",		'a',	OF_ANY },
#if HAVE_ARC4RANDOM
	{ "arc4random",		0,	OF_ANY },
#endif
	{ "braceexpand",	0,	OF_ANY },	/* non-standard */
#if HAVE_NICE
	{ "bgnice",		0,	OF_ANY },
#endif
	{ NULL,			'c',	OF_CMDLINE },
	{ "emacs",		0,	OF_ANY },
	{ "errexit",		'e',	OF_ANY },
	{ "gmacs",		0,	OF_ANY },
	{ "ignoreeof",		0,	OF_ANY },
	{ "interactive",	'i',	OF_CMDLINE },
	{ "keyword",		'k',	OF_ANY },
	{ "login",		'l',	OF_CMDLINE },
	{ "markdirs",		'X',	OF_ANY },
#ifndef MKSH_UNEMPLOYED
	{ "monitor",		'm',	OF_ANY },
#else
	{ NULL,			'm',	0 },		/* needed */
#endif
	{ "noclobber",		'C',	OF_ANY },
	{ "noexec",		'n',	OF_ANY },
	{ "noglob",		'f',	OF_ANY },
	{ "nohup",		0,	OF_ANY },
	{ "nolog",		0,	OF_ANY },	/* no effect */
#ifndef MKSH_UNEMPLOYED
	{ "notify",		'b',	OF_ANY },
#endif
	{ "nounset",		'u',	OF_ANY },
	{ "physical",		0,	OF_ANY },	/* non-standard */
	{ "posix",		0,	OF_ANY },	/* non-standard */
	{ "privileged",		'p',	OF_ANY },
	{ "restricted",		'r',	OF_CMDLINE },
	{ "stdin",		's',	OF_CMDLINE },	/* pseudo non-st.. */
	{ "trackall",		'h',	OF_ANY },
	{ "utf8-mode",		'U',	OF_ANY },	/* non-standard */
	{ "verbose",		'v',	OF_ANY },
#ifndef MKSH_NOVI
	{ "vi",			0,	OF_ANY },
	{ "viraw",		0,	OF_ANY },	/* no effect */
	{ "vi-tabcomplete",	0,	OF_ANY },	/* non-standard */
	{ "vi-esccomplete",	0,	OF_ANY },	/* non-standard */
#endif
	{ "xtrace",		'x',	OF_ANY },
	/* Anonymous flags: used internally by shell only
	 * (not visible to user)
	 */
	{ NULL,			0,	OF_INTERNAL }, /* FTALKING_I */
@


1.121
log
@$'…' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.120 2009/09/19 19:08:47 tg Exp $");
d1545 1
a1545 1
		 *	to raw octet (C style: Unicode)
d1564 1
a1564 1
		if (cstyle || fc != 'x')
@


1.120
log
@align with C standard (optional C style); document differences to C style
for print builtin (align with ksh93 ipv GNU bash)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.119 2009/09/19 15:16:03 tg Exp $");
d1452 6
a1457 5
 * process the string at *sp for backslash escapes,
 * assuming (*sp)[-1] was the backslash; return the
 * character ([0;0xFF]), Unicode (wc+0x100), or -1
 * if none found; *sp afterwards points to the first
 * unprocessed character (unchanged if rv=-1)
d1460 1
a1460 1
unbksl(const char **sp, bool cstyle)
d1462 1
a1462 2
	int wc, i;
	const char *cp = (*sp);
d1464 2
a1465 1
	switch (*cp++) {
d1478 10
a1510 2
	case '8':
	case '9':
d1512 1
a1512 1
			return (-1);
d1516 1
a1516 1
			--cp;
d1524 7
a1530 2
		while (i-- && *cp >= '0' && *cp <= '7')
			wc = (wc << 3) + (*cp++ - '0');
d1552 6
a1557 6
			if (*cp >= '0' && *cp <= '9')
				wc += *cp++ - '0';
			else if (*cp >= 'A' && *cp <= 'F')
				wc += *cp++ - 'A' + 10;
			else if (*cp >= 'a' && *cp <= 'f')
				wc += *cp++ - 'a' + 10;
d1560 1
d1564 1
a1564 1
		if (cstyle || **sp != 'x')
d1568 5
d1577 2
a1581 1
	(*sp) = cp;
@


1.119
log
@new function unbksl doing "backslash expansion" independent of c_print();
also make a separate subsection about it in the manpage
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.118 2009/08/30 13:30:07 tg Exp $");
d1459 1
a1459 1
unbksl(const char **sp)
d1493 12
d1506 2
d1527 1
a1527 1
		i = 2;
d1529 5
a1533 4
		 * x: look for a hexadecimal number with up to
		 *    two digits; convert to raw octet
		 * u: look for a hexadecimal number with up to
		 *    four (U: eight) digits; convert to Unicode
d1549 1
a1549 1
		if (**sp != 'x')
@


1.118
log
@replace pdksh’s get_phys_path() and do_phys_path() with my new
do_realpath() function – looking fine, review welcome though
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.117 2009/08/28 21:07:26 tg Exp $");
d1450 98
@


1.117
log
@optimise
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.115 2009/08/08 13:08:52 tg Exp $");
a52 1
static char *do_phys_path(XString *, char *, const char *);
a1274 74
char *
get_phys_path(const char *pathl)
{
	XString xs;
	char *xp;

	Xinit(xs, xp, strlen(pathl) + 1, ATEMP);

	xp = do_phys_path(&xs, xp, pathl);

	if (!xp)
		return (NULL);

	if (Xlength(xs, xp) == 0)
		Xput(xs, xp, '/');
	Xput(xs, xp, '\0');

	return (Xclose(xs, xp));
}

static char *
do_phys_path(XString *xsp, char *xp, const char *pathl)
{
	const char *p, *q;
	int len, llen, savepos;
	char *lbuf;

	lbuf = alloc(PATH_MAX, ATEMP);
	Xcheck(*xsp, xp);
	for (p = pathl; p; p = q) {
		while (*p == '/')
			p++;
		if (!*p)
			break;
		len = (q = cstrchr(p, '/')) ? q - p : (int)strlen(p);
		if (len == 1 && p[0] == '.')
			continue;
		if (len == 2 && p[0] == '.' && p[1] == '.') {
			while (xp > Xstring(*xsp, xp)) {
				xp--;
				if (*xp == '/')
					break;
			}
			continue;
		}

		savepos = Xsavepos(*xsp, xp);
		Xput(*xsp, xp, '/');
		XcheckN(*xsp, xp, len + 1);
		memcpy(xp, p, len);
		xp += len;
		*xp = '\0';

		llen = readlink(Xstring(*xsp, xp), lbuf, PATH_MAX - 1);
		if (llen < 0) {
			if (errno == EINVAL)
				/* not a symbolic link */
				continue;
			xp = NULL;
			goto out;
		}
		lbuf[llen] = '\0';

		/* If absolute path, start from scratch.. */
		xp = lbuf[0] == '/' ? Xstring(*xsp, xp) :
		    Xrestpos(*xsp, xp, savepos);
		if ((xp = do_phys_path(xsp, xp, lbuf)) == NULL)
			break;
	}
 out:
	afree(lbuf, ATEMP);
	return (xp);
}

@


1.116
log
@more int→bool
@
text
@d448 3
a450 5
	if (arrayset) {
		set_array(array, arrayset > 0 ? true : false, argv + go.optind);
		for (; argv[go.optind]; go.optind++)
			;
	}
@


1.115
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.114 2009/08/01 20:31:47 tg Exp $");
d449 1
a449 1
		set_array(array, arrayset, argv + go.optind);
@


1.114
log
@use sizeof
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.113 2009/08/01 20:29:24 tg Exp $");
d241 1
a241 3
change_flag(enum sh_flag f,
    int what,		/* flag to change */
    char newval)	/* what is changing the flag (command line vs set) */
d243 1
a243 1
	char oldval;
d262 1
a262 1
		Flag(f) = newval;
d285 1
a285 1
			Flag(FTALKING_I) = newval;
d792 1
a792 1
	return (strcmp(*(char * const *)p1, *(char * const *)p2));
d1378 1
a1378 1
		if (((sb.st_mode & 07777) != 0600) && chmod(fn, 0600))
@


1.113
log
@if duplicating strings, it’s idiotic to use strlcpy(3) when we know
the sizes (checked)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.112 2009/07/25 21:31:26 tg Exp $");
d1368 1
a1368 1
			strlcpy(dv + 9, fn, 20 - 9);
d1370 1
a1370 1
				strlcpy(dv + 8, fn, 20 - 8);
@


1.112
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.111 2009/06/11 12:42:20 tg Exp $");
d1482 3
a1484 2
		dst = alloc(++len, ap);
		strlcpy(dst, src, len);
@


1.111
log
@capitalise AT&T®
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.110 2009/06/10 18:12:48 tg Exp $");
d35 1
a1417 1

@


1.110
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.109 2009/06/08 20:06:48 tg Exp $");
d410 1
a410 1
			/* -s: sort positional params (at&t ksh stupidity) */
@


1.109
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.108 2009/05/31 15:10:07 tg Exp $");
d106 1
a106 1
	{ "allexport",	'a',		OF_ANY },
d108 1
a108 1
	{ "arc4random",	  0,		OF_ANY },
d110 1
a110 1
	{ "braceexpand",  0,		OF_ANY }, /* non-standard */
d112 1
a112 1
	{ "bgnice",	  0,		OF_ANY },
d114 9
a122 9
	{ NULL,		'c',	    OF_CMDLINE },
	{ "emacs",	  0,		OF_ANY },
	{ "errexit",	'e',		OF_ANY },
	{ "gmacs",	  0,		OF_ANY },
	{ "ignoreeof",	  0,		OF_ANY },
	{ "interactive",'i',	    OF_CMDLINE },
	{ "keyword",	'k',		OF_ANY },
	{ "login",	'l',	    OF_CMDLINE },
	{ "markdirs",	'X',		OF_ANY },
d124 1
a124 1
	{ "monitor",	'm',		OF_ANY },
d126 1
a126 1
	{ NULL,		'm',		0      }, /* needed */
d128 5
a132 5
	{ "noclobber",	'C',		OF_ANY },
	{ "noexec",	'n',		OF_ANY },
	{ "noglob",	'f',		OF_ANY },
	{ "nohup",	  0,		OF_ANY },
	{ "nolog",	  0,		OF_ANY }, /* no effect */
d134 1
a134 1
	{ "notify",	'b',		OF_ANY },
d136 9
a144 9
	{ "nounset",	'u',		OF_ANY },
	{ "physical",	  0,		OF_ANY }, /* non-standard */
	{ "posix",	  0,		OF_ANY }, /* non-standard */
	{ "privileged",	'p',		OF_ANY },
	{ "restricted",	'r',	    OF_CMDLINE },
	{ "stdin",	's',	    OF_CMDLINE }, /* pseudo non-standard */
	{ "trackall",	'h',		OF_ANY },
	{ "utf8-mode",	'U',		OF_ANY }, /* non-standard */
	{ "verbose",	'v',		OF_ANY },
d146 4
a149 4
	{ "vi",		  0,		OF_ANY },
	{ "viraw",	  0,		OF_ANY }, /* no effect */
	{ "vi-tabcomplete",  0,		OF_ANY }, /* non-standard */
	{ "vi-esccomplete",  0,		OF_ANY }, /* non-standard */
d151 1
a151 1
	{ "xtrace",	'x',		OF_ANY },
d155 1
a155 1
	{ NULL,		 0,	   OF_INTERNAL }, /* FTALKING_I */
d290 1
a290 1
/* parse command line & set command arguments.  returns the index of
d306 1
a306 1
	/* First call?  Build option strings... */
d379 1
a379 1
				 * work if you're already interactive.  Needed
d524 1
a524 1
	 * the pattern.  If check fails, just to a strcmp().
d647 4
a650 4
		  /*
		   * [*+?@@!](pattern|pattern|..)
		   * This is also needed for ${..%..}, etc.
		   */
d825 1
a825 1
 *	  and must start with a digit.  If the argument doesn't start with a
d829 1
a829 1
 *	- accepts +c as well as -c IF the GF_PLUSOPT flag is present.  If an
d907 1
a907 1
		 * but must start with a digit.  optarg is set to 0 if the
d976 1
a976 1
	/* max_width + 1 for the space.  Note that no space
d1207 7
a1213 7
	 *  /foo/			/foo
	 *  /foo/../../bar		/bar
	 *  /foo/./blah/..		/foo
	 *  .				.
	 *  ..				..
	 *  ./foo			foo
	 *  foo/../../../bar		../../bar
@


1.108
log
@fix bug exhibited by t0000-basic.sh introduced in R38 shortly before the
release: sometimes, a “cd -P” would cause memory corruption because lalloc
internal data was overwritten due to accidentally losing a “continue;”
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.107 2009/05/27 09:58:23 tg Exp $");
d98 1
a98 1
	return xsp->beg + (xp - old_beg);
d190 1
a190 1
	return buf;
d405 1
a405 1
			return -1;
d441 1
a441 1
		return -1;
d446 1
a446 1
		qsort(&argv[go.optind], i - go.optind, sizeof (void *),
d455 1
a455 1
	return go.optind;
d519 1
a519 1
		return 0;
d531 1
a531 1
		return !strcmp(t, s);
d533 2
a534 2
	return do_gmatch((const unsigned char *) s, (const unsigned char *) se,
	    (const unsigned char *) p, (const unsigned char *) pe);
d581 1
a581 1
					return 0;
d592 1
a592 1
				return 0;
d596 1
a596 1
					return 0;
d603 1
a603 1
	return saw_glob && !in_bracket && !nest;
d616 1
a616 1
		return 0;
d623 1
a623 1
				return 0;
d629 1
a629 1
				return 0;
d634 1
a634 1
				return 0;
d639 1
a639 1
				return 1;
d643 1
a643 1
					return 1;
d645 1
a645 1
			return 0;
d654 1
a654 1
				return 0;
d659 1
a659 1
				return 1;
d667 1
a667 1
						return 1;
d672 1
a672 1
			return 0;
d678 1
a678 1
				return 0;
d683 1
a683 1
				return 1;
d690 1
a690 1
						return 1;
d695 1
a695 1
			return 0;
d699 1
a699 1
				return 0;
d716 1
a716 1
					return 1;
d718 1
a718 1
			return 0;
d722 1
a722 1
				return 0;
d726 1
a726 1
	return s == se;
d750 1
a750 1
			return sub == '[' ? orig_p : NULL;
d762 1
a762 1
				return NULL;
d769 1
a769 1
	return (found != not) ? p+2 : NULL;
d847 1
a847 1
			return -1;
d854 1
a854 1
			return -1;
d873 1
a873 1
		return '?';
d891 1
a891 1
				return ':';
d898 1
a898 1
			return '?';
d924 1
a924 1
	return c;
d1064 1
a1064 1
	return ret;
d1077 1
a1077 1
		return -1;
d1079 1
a1079 1
		return 0;
d1082 2
a1083 2
		return -1;
	return 1;
d1101 1
a1101 1
	return ret;
d1186 1
a1186 1
	return rval;
d1290 1
a1290 1
		return NULL;
d1296 1
a1296 1
	return Xclose(xs, xp);
d1362 1
a1362 1
		memcpy(dv, "-/dev/null", sizeof ("-/dev/null"));
d1418 3
a1420 3
char longsizes_are_okay[sizeof (long) == sizeof (unsigned long) ? 1 : -1];
char arisize_is_okay[sizeof (mksh_ari_t) == 4 ? 1 : -1];
char uarisize_is_okay[sizeof (mksh_uari_t) == 4 ? 1 : -1];
@


1.107
log
@• Build.sh, strlcpy.c: gcc-current conversion &c. warnings cleanup
• histrap.c, lex.c, misc.c: get average stack frame size to <= 768 bytes
• check.t, sh.h: bump version
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.106 2009/05/16 18:40:07 tg Exp $");
d1334 5
a1338 5
			/* EINVAL means it wasn't a symlink... */
			if (errno != EINVAL) {
				xp = NULL;
				goto out;
			}
@


1.106
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.105 2009/05/16 16:59:38 tg Exp $");
d1303 2
a1304 3
	int len, llen;
	int savepos;
	char lbuf[PATH_MAX];
d1306 1
d1332 1
a1332 1
		llen = readlink(Xstring(*xsp, xp), lbuf, sizeof(lbuf) - 1);
d1335 4
a1338 3
			if (errno != EINVAL)
				return NULL;
			continue;
d1345 2
a1346 2
		if (!(xp = do_phys_path(xsp, xp, lbuf)))
			return NULL;
d1348 3
a1350 1
	return xp;
@


1.105
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.104 2009/04/22 16:46:11 tg Exp $");
a520 6
#if 0
	/* debugging output */
	fprintf(stderr, "gmatchx:\n\tstring =`%s`\n\tpattern=`%s`\n", s, p);
	fflush(stderr);
#endif

@


1.104
log
@sync rcsid with openbsd; we did it in misc.c,v 1.95 already
what they kludged in now
@
text
@d4 20
d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.103 2009/04/07 19:51:47 tg Exp $");
@


1.103
log
@tabs, bools
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.36 2009/03/03 20:01:01 millert Exp $	*/
d12 1
a12 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.102 2009/04/05 12:35:32 tg Exp $");
@


1.102
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d12 1
a12 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.101 2009/04/03 10:54:58 tg Exp $");
d1111 5
a1115 6
	int	rval = 0;
	int	use_cdpath = 1;
	char	*plist;
	int	len;
	int	plen = 0;
	char	*xp = Xstring(*xsp, xp);
d1122 1
a1122 1
		use_cdpath = 0;
d1130 1
a1130 1
				use_cdpath = 0;
d1135 1
a1135 1
			use_cdpath = 0;
d1145 1
a1145 1
		if ((use_cdpath == 0 || !plen || plist[0] != '/') &&
d1182 3
a1184 5
	char	*cur;
	char	*t;
	int	isrooted;
	char	*very_start = pathl;
	char	*start;
@


1.101
log
@fix compilation
@
text
@d12 1
a12 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.100 2009/04/03 09:39:06 tg Exp $");
d103 1
d105 3
d113 1
d115 1
d228 1
d232 3
a234 1
	} else if ((
@


1.100
log
@(experimental) implement getrusage via times if not found
@
text
@d12 1
a12 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.99 2009/03/22 18:09:16 tg Exp $");
d1500 2
a1501 2
	INVTCK(r->ru_utime, u);
	INVTCK(r->ru_stime, s);
@


1.99
log
@merge manpage and sync RCS IDs
not merged: POSuX character class nonsense
@
text
@d5 3
d12 1
a12 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.98 2009/03/22 17:31:17 tg Exp $");
d1471 34
@


1.98
log
@sync with oksh (nop)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.35 2009/01/17 22:06:44 millert Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.97 2009/03/14 18:12:53 tg Exp $");
@


1.97
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2008/07/12 12:33:42 miod Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.96 2009/02/22 18:53:03 tg Exp $");
@


1.96
log
@gmatchx debug (if 0'd)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.95 2009/02/22 18:02:31 tg Exp $");
d1393 2
@


1.95
log
@when outputting in a row x column formatted way, but the available space
on the screen is not enough for two columns, just output the text line by
line, instead of trying to format it; gets rid of superfluous empty lines
if we did not even have space for one column on the screen (x_cols)

noticed by Gábor Gergely in irc, thanks!
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.94 2008/12/17 19:37:08 tg Exp $");
d488 7
@


1.94
log
@ensure sizes of long and unsigned long are the same #ifdef DEBUG
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.93 2008/12/13 17:02:16 tg Exp $");
d939 4
d948 7
a954 2
	if (!cols)
		cols = 1;
d981 1
@


1.93
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.92 2008/12/04 18:11:06 tg Exp $");
d1374 3
@


1.93.2.1
log
@during mksh-R36-stable, we should not introduce incompatibilities,
so revert "-o utf8-mode / -U" to "-o utf8-hack / -U" for R36b
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.93 2008/12/13 17:02:16 tg Exp $");
d114 1
a114 1
	{ "utf8-hack",	'U',		OF_ANY }, /* non-standard */
@


1.92
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.91 2008/11/12 00:54:50 tg Exp $");
d73 1
a73 1
	xsp->beg = aresize(xsp->beg, 1, xsp->len + 8, xsp->areap);
d496 1
a496 1
		char *t = len <= sizeof(tbuf) ? tbuf : alloc(1, len, ATEMP);
d936 1
a936 1
	char *str = alloc(1, max_width + 1, ATEMP);
d1051 2
a1052 2
	if ((ret = getcwd((b = alloc(1, PATH_MAX + 1, ATEMP)), PATH_MAX)))
		ret = aresize(b, 1, len = (strlen(b) + 1), ATEMP);
d1232 1
a1232 1
		current_wd = alloc(1, current_wd_size = len, APERM);
d1429 1
a1429 1
strndup_(const char *src, size_t len, PArea ap)
d1434 1
a1434 1
		dst = alloc(1, ++len, ap);
d1441 1
a1441 1
strdup_(const char *src, PArea ap)
@


1.91
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.90 2008/11/11 23:50:30 tg Exp $");
d114 1
a114 1
	{ "utf8-hack",	'U',		OF_ANY }, /* non-standard */
@


1.91.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.91 2008/11/12 00:54:50 tg Exp $");
d73 1
a73 2
	/* XXX why + 8 ? */
	xsp->beg = grealloc(xsp->beg, 1, xsp->len + 8, xsp->gp_XS);
a494 1
		int res;
d496 1
a496 1
		char *t = len <= sizeof(tbuf) ? tbuf : galloc(1, len, ATEMP);
d498 1
a498 4
		res = !strcmp(t, s);
		if (t != tbuf)
			gfree(t, ATEMP);
		return (res);
d936 1
a936 1
	char *str = galloc(1, max_width + 1, ATEMP);
d972 1
a972 1
	gfree(str, ATEMP);
d1051 2
a1052 2
	if ((ret = getcwd((b = galloc(1, PATH_MAX + 1, ATEMP)), PATH_MAX)))
		ret = grealloc(b, 1, len = (strlen(b) + 1), ATEMP);
d1054 1
a1054 1
		gfree(b, ATEMP);
d1231 2
a1232 2
		gfree(current_wd, APERM);
		current_wd = galloc(1, current_wd_size = len, APERM);
d1236 1
a1236 1
		gfree(p, ATEMP);
d1429 1
a1429 1
strndup_(const char *src, size_t len, PGroup ap)
d1434 2
a1435 3
		dst = galloc(1, len + 1, ap);
		memcpy(dst, src, len);
		dst[len] = '\0';
d1441 1
a1441 1
strdup_(const char *src, PGroup ap)
@


1.90
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.89 2008/10/28 14:51:06 tg Exp $");
d73 1
a73 1
	xsp->beg = aresize(xsp->beg, xsp->len + 8, xsp->areap);
d496 1
a496 2
		char *t = len <= sizeof(tbuf) ? tbuf :
		    (char *)alloc(len, ATEMP);
d936 1
a936 1
	char *str = (char *)alloc(max_width + 1, ATEMP);
d1051 2
a1052 2
	if ((ret = getcwd((b = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)))
		ret = aresize(b, len = (strlen(b) + 1), ATEMP);
d1230 4
a1233 2
	if (len > current_wd_size)
		current_wd = aresize(current_wd, current_wd_size = len, APERM);
d1434 1
a1434 1
		dst = alloc(++len, ap);
@


1.89
log
@save 1640 .text bytes in MKSH_SMALL case by not inlining strdupx, strndupx
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.88 2008/10/28 14:32:42 tg Exp $");
d1428 1
a1428 1
strndup_(const char *src, size_t len, Area *ap)
d1440 1
a1440 1
strdup_(const char *src, Area *ap)
@


1.88
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.87 2008/10/26 21:51:26 ahoka Exp $");
d1425 20
@


1.87
log
@Add check for the nice(3) system call.
It may be not implemented on some plaforms, though it's usually present.

Required to compile on Haiku as of 2008 October.
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.86 2008/10/13 23:06:03 tg Exp $");
a65 28
#if defined(MKSH_SMALL) || !HAVE_EXPSTMT
char *
str_nsave(const char *s, int n, Area *ap)
{
	char *rv = NULL;

	if ((n >= 0) && (s != NULL))
		strlcpy(rv = alloc(n + 1, ap), s, n + 1);
	return (rv);
}

char *
str_save(const char *s, Area *ap)
{
#ifdef MKSH_SMALL
	return (s ? str_nsave(s, strlen(s), ap) : NULL);
#else
	char *rv = NULL;

	if (s != NULL) {
		size_t sz = strlen(s) + 1;
		strlcpy(rv = alloc(sz, ap), s, sz);
	}
	return (rv);
#endif
}
#endif

d205 2
a206 1
	return (str_nsave_(m, cp - m, ATEMP));
a1424 9

#if !HAVE_EXPSTMT
bool
ksh_isspace_(unsigned int ksh_isspace_c)
{
	return ((ksh_isspace_c >= 0x09 && ksh_isspace_c <= 0x0D) ||
	    (ksh_isspace_c == 0x20));
}
#endif
@


1.86
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.85 2008/07/18 11:33:12 tg Exp $");
d116 1
d118 1
@


1.85
log
@fixes for constant conditionals, from gcc-4.2 fat binary building
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.84 2008/07/12 18:24:58 tg Exp $");
d776 1
a776 1
			return ++p;
d780 1
a780 1
	return NULL;
d1140 1
a1140 1
			*cdpathp = *pend ? ++pend : NULL;
@


1.84
log
@we're up to 133214 for MKSH_SMALL, as I missed a NULL pointer check
in the MKSH_SMALL case… so the speed, code size, and number of insns
is the same as before for that, except that the NULL pointer check is
moved to possibly save a function call, and that the function call may
be inlined or jumped
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.83 2008/07/12 17:56:37 tg Exp $");
d231 1
a231 1
	return (str_nsave(m, cp - m, ATEMP));
@


1.83
log
@for MKSH_SMALL, reduce code size, even at cost of performance
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.82 2008/07/12 17:47:21 tg Exp $");
d81 1
a81 1
	return (str_nsave(s, strlen(s), ap));
@


1.82
log
@600 bytes more for the small version aren't worth it; it looks
as if there are not many NULL pointers to be optimised away
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.81 2008/07/12 17:23:00 tg Exp $");
d68 1
a68 1
str_save(const char *s, Area *ap)
d72 2
a73 4
	if (s != NULL) {
		size_t sz = strlen(s) + 1;
		strlcpy(rv = alloc(sz, ap), s, sz);
	}
d78 1
a78 1
str_nsave(const char *s, int n, Area *ap)
d80 3
d85 4
a88 2
	if ((n >= 0) && (s != NULL))
		strlcpy(rv = alloc(n + 1, ap), s, n + 1);
d90 1
@


1.81
log
@further optimisation attempts in the str_save() and str_nsave() area
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.80 2008/07/12 16:26:58 tg Exp $");
d66 1
a66 1
#ifdef MKSH_SMALL
d68 1
a68 1
str_save_s(const char *s, Area *ap)
d70 1
a70 2
	char *rv;
	size_t sz;
d72 4
a75 2
	sz = strlen(s) + 1;
	strlcpy(rv = alloc(sz, ap), s, sz);
d80 1
a80 1
str_nsave_s(const char *s, int n, Area *ap)
d84 1
a84 1
	if (n >= 0)
a87 9
#elif !HAVE_EXPSTMT
char *
str_nsave_ns(const char *s, unsigned int sz, Area *ap)
{
	char *rv;

	strlcpy(rv = alloc(sz, ap), s, sz);
	return (rv);
}
@


1.80
log
@• sync RCSID with oksh, Miod fixed a bug which fell out during my size
  optimisation whack earlier in mksh
• optimise a little more for the (s == NULL) case while here
  (more to follow…)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.79 2008/05/17 18:47:00 tg Exp $");
d66 1
a66 4
/* Allocate a string of size n+1 and copy upto n characters from the possibly
 * NUL terminated string s into it.  Always returns a NUL terminated string
 * (unless n < 0).
 */
d68 1
a68 1
str_nsave(const char *s, int n, Area *ap)
d70 2
a71 1
	char *ns = NULL;
d73 3
a75 3
	if (n >= 0 && s)
		strlcpy(ns = alloc(n + 1, ap), s, n + 1);
	return (ns);
a77 1
#ifdef MKSH_SMALL
d79 11
a89 1
str_save(const char *s, Area *ap)
d91 4
a94 1
	return (s ? str_nsave(s, strlen(s), ap) : NULL);
@


1.79
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2007/08/02 11:05:54 fgsch Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.78 2008/05/04 02:02:32 tg Exp $");
d84 1
a84 1
	return (str_nsave(s, s ? strlen(s) : 0, ap));
@


1.78
log
@shrink code size for a corner case
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.77 2008/04/22 19:00:01 tg Exp $");
d516 1
a516 1
		    (char *) alloc(len, ATEMP);
d956 1
a956 1
	char *str = (char *) alloc(max_width + 1, ATEMP);
@


1.77
log
@remove the now-unused addition to the ksh_getopt() code
which oksh used for their ulimit change, as I’m not going
to hack on it for now… maybe editing the optstring as it
is parsed (in the first loop), but… naah, not now
@
text
@d9 1
a9 1
__RCSID("$MirOS$");
d1423 1
d1443 1
@


1.76
log
@sh.h can provide its rcsid itself, no need for that ugly hack
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.33 2008/03/21 12:51:19 millert Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.75 2008/04/19 22:15:03 tg Exp $");
d812 4
a815 4
 *	  and must start with a digit or be the string "unlimited".  If the
 *	  argument doesn't match, it is assumed to be missing and normal option
 *	  processing continues (optarg is set to 0 if the option is missing).
 *	  Used for 'typeset -LZ4' and 'ulimit -adunlimited'.
d898 1
a898 2
			if (ksh_isdigit(argv[go->optind - 1][go->p]) ||
			    !strcmp(&argv[go->optind - 1][go->p], "unlimited")) {
d904 1
a904 3
			if (argv[go->optind] &&
			    (ksh_isdigit(argv[go->optind][0]) ||
			    !strcmp(argv[go->optind], "unlimited"))) {
@


1.75
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d9 1
a9 2
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.74 2008/04/19 17:21:54 tg Exp $\t"
	MKSH_SH_H_ID);
@


1.74
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.73 2008/04/16 21:56:02 tg Exp $\t"
d38 1
a38 1
	unsigned i;
d91 1
a91 1
Xcheck_grow_(XString *xsp, const char *xp, unsigned more)
d188 1
a188 1
	unsigned i;
d219 1
a219 1
	unsigned i;
d1449 1
a1449 1
ksh_isspace_(unsigned ksh_isspace_c)
@


1.73
log
@_careful_ (feature) sync with oksh:

   (3 weeks, 5 days ago) by millert
Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.72 2008/04/11 19:55:23 tg Exp $\t"
d961 1
a961 4
	int i;
	int r, c;
	int rows, cols;
	int nspace;
@


1.72
log
@SECURITY fix: when spawning mksh on a new terminal (tty, not /dev/null),
flush all of its I/O first – someone could have written on it beforehand
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2007/08/02 11:05:54 fgsch Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.71 2008/04/01 21:50:58 tg Exp $\t"
d813 4
a816 4
 *	  and must start with a digit.  If the argument doesn't start with a
 *	  digit, it is assumed to be missing and normal option processing
 *	  continues (optarg is set to 0 if the option is missing).
 *	  Used for 'typeset -LZ4'.
d899 2
a900 1
			if (ksh_isdigit(argv[go->optind - 1][go->p])) {
d906 3
a908 1
			if (argv[go->optind] && ksh_isdigit(argv[go->optind][0])) {
@


1.71
log
@more
• int → bool
• shprintf("foo") → shf_puts("foo", shl_stdout)
• shprintf("%s", foo) → shf_puts(foo, shl_stdout)
• shf_puts("x", foo) → shf_putc('x', foo)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.70 2008/04/01 20:40:22 tg Exp $\t"
d1373 1
a1373 1
		errorf("fork failed");
d1380 7
a1386 3
		errorf("chvt: setsid failed");
	if ((fn != dv + 1) && ioctl(fd, TIOCSCTTY, NULL) == -1)
		errorf("chvt: TIOCSCTTY failed");
@


1.70
log
@• unify ksh_dup2() usage, use bool where appropriate
• apply diff from mirbsdksh-1.11:
  #ifdef DUP2_BROKEN
  /* Ultrix systems like to preserve the close-on-exec flag */
  ‣ XXX we do #ifdef __ultrix here (imake-style) instead of mirtoconfing it
    (but does anyone know of any other OS with the same problem? plus we’d
    see it as we now know the symptoms)
• remove ultrix Build.hs warn=' but might work…' in the hope it DOES
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.69 2008/03/23 22:09:58 tg Exp $\t"
d195 1
a195 1
		shprintf("Current option settings\n");
d208 1
a208 1
		shprintf("set");
d930 1
a930 1
		shprintf("%s", s);
@


1.69
log
@support dæmonisation in mksh, for example
|	csh -cf '/command/svscanboot &'
and
|	/usr/mpkg/bin/pgrphack /usr/mpkg/bin/svscanboot &
can now be replaced with
|	/bin/mksh -T- /usr/mpkg/bin/svscanboot
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.68 2008/02/27 01:00:09 tg Exp $\t"
d1383 3
a1385 3
	dup2(fd, 0);
	dup2(fd, 1);
	dup2(fd, 2);
@


1.68
log
@I _think_ this implements ${foo/bar/baz} logic (bar is a glob pattern)
todo tomorrow:
• test case (compare with e.g. GNU bash)
• manpage
• version bump

sqchar is a bit ugly, but \/ must be preserved, as we don’t get wdencoded
strings later on in the process (eval.c CSUBST) and I didn’t want to have
an implementation like ${foo: 2: 3} this time
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.67 2007/10/25 15:19:16 tg Exp $\t"
d1340 20
a1359 16
	if (stat(fn, &sb)) {
		memcpy(dv, "/dev/ttyC", 9);
		strlcpy(dv + 9, fn, 20 - 9);
		if (stat(dv, &sb)) {
			strlcpy(dv + 8, fn, 20 - 8);
			if (stat(dv, &sb))
				errorf("chvt: can't find tty %s", fn);
		}
		fn = dv;
	}
	if (!(sb.st_mode & S_IFCHR))
		errorf("chvt: not a char device: %s", fn);
	if ((sb.st_uid != 0) && chown(fn, 0, 0))
		warningf(false, "chvt: cannot chown root %s", fn);
	if (((sb.st_mode & 07777) != 0600) && chmod(fn, 0600))
		warningf(false, "chvt: cannot chmod 0600 %s", fn);
d1361 1
a1361 1
	if (revoke(fn))
d1363 3
a1365 3
		warningf(false, "chvt: cannot revoke %s, new shell is"
		    " potentially insecure", fn);

d1381 1
a1381 1
	if (ioctl(fd, TIOCSCTTY, NULL) == -1)
@


1.68.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.72 2008/04/11 19:55:23 tg Exp $\t"
d195 1
a195 1
		shf_puts("Current option settings\n", shl_stdout);
d208 1
a208 1
		shf_puts("set", shl_stdout);
d930 1
a930 1
		shf_puts(s, shl_stdout);
d1340 16
a1355 20
	if (*fn == '-') {
		memcpy(dv, "-/dev/null", sizeof ("-/dev/null"));
		fn = dv + 1;
	} else {
		if (stat(fn, &sb)) {
			memcpy(dv, "/dev/ttyC", 9);
			strlcpy(dv + 9, fn, 20 - 9);
			if (stat(dv, &sb)) {
				strlcpy(dv + 8, fn, 20 - 8);
				if (stat(dv, &sb))
					errorf("chvt: can't find tty %s", fn);
			}
			fn = dv;
		}
		if (!(sb.st_mode & S_IFCHR))
			errorf("chvt: not a char device: %s", fn);
		if ((sb.st_uid != 0) && chown(fn, 0, 0))
			warningf(false, "chvt: cannot chown root %s", fn);
		if (((sb.st_mode & 07777) != 0600) && chmod(fn, 0600))
			warningf(false, "chvt: cannot chmod 0600 %s", fn);
d1357 1
a1357 1
		if (revoke(fn))
d1359 3
a1361 3
			warningf(false, "chvt: cannot revoke %s, new shell is"
			    " potentially insecure", fn);
	}
d1369 1
a1369 1
		errorf("chvt: %s failed", "fork");
d1376 6
a1381 10
		errorf("chvt: %s failed", "setsid");
	if (fn != dv + 1) {
		if (ioctl(fd, TIOCSCTTY, NULL) == -1)
			errorf("chvt: %s failed", "TIOCSCTTY");
		if (tcflush(fd, TCIOFLUSH))
			errorf("chvt: %s failed", "TCIOFLUSH");
	}
	ksh_dup2(fd, 0, false);
	ksh_dup2(fd, 1, false);
	ksh_dup2(fd, 2, false);
@


1.68.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d9 2
a10 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.79 2008/05/17 18:47:00 tg Exp $");
d38 1
a38 1
	unsigned int i;
d91 1
a91 1
Xcheck_grow_(XString *xsp, const char *xp, unsigned int more)
d188 1
a188 1
	unsigned int i;
d219 1
a219 1
	unsigned int i;
d517 1
a517 1
		    (char *)alloc(len, ATEMP);
d957 5
a961 2
	char *str = (char *)alloc(max_width + 1, ATEMP);
	int i, r, c, rows, cols, nspace;
a1426 1
#ifndef MKSH_ASSUME_UTF8
a1445 1
#endif
d1449 1
a1449 1
ksh_isspace_(unsigned int ksh_isspace_c)
@


1.68.2.3
log
@MFC: mksh R35b
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2008/07/12 12:33:42 miod Exp $	*/
d9 1
a9 1
__RCSID("$MirOS$");
d66 4
a69 1
#if defined(MKSH_SMALL) || !HAVE_EXPSTMT
d73 1
a73 1
	char *rv = NULL;
d75 3
a77 3
	if ((n >= 0) && (s != NULL))
		strlcpy(rv = alloc(n + 1, ap), s, n + 1);
	return (rv);
d80 1
d84 1
a84 11
#ifdef MKSH_SMALL
	return (s ? str_nsave(s, strlen(s), ap) : NULL);
#else
	char *rv = NULL;

	if (s != NULL) {
		size_t sz = strlen(s) + 1;
		strlcpy(rv = alloc(sz, ap), s, sz);
	}
	return (rv);
#endif
d225 1
a225 1
	return (str_nsave_(m, cp - m, ATEMP));
@


1.68.2.4
log
@MFC: mksh R36b
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.93.2.1 2008/12/13 17:43:26 tg Exp $");
d66 28
a115 1
#if HAVE_NICE
a116 1
#endif
d231 1
a231 2
	strndupx(cp, m, cp - m, ATEMP);
	return (cp);
d521 2
a522 1
		char *t = len <= sizeof(tbuf) ? tbuf : alloc(len, ATEMP);
d776 1
a776 1
			return (p + 1);
d780 1
a780 1
	return (NULL);
d962 1
a962 1
	char *str = alloc(max_width + 1, ATEMP);
d1140 1
a1140 1
			*cdpathp = *pend ? pend + 1 : NULL;
d1256 2
a1257 4
	if (len > current_wd_size) {
		afree(current_wd, APERM);
		current_wd = alloc(current_wd_size = len, APERM);
	}
d1451 3
a1453 15
#ifdef MKSH_SMALL
char *
strndup_(const char *src, size_t len, Area *ap)
{
	char *dst = NULL;

	if (src != NULL) {
		dst = alloc(++len, ap);
		strlcpy(dst, src, len);
	}
	return (dst);
}

char *
strdup_(const char *src, Area *ap)
d1455 2
a1456 1
	return (src == NULL ? NULL : strndup_(src, strlen(src), ap));
@


1.67
log
@optimise (struct padding, function→macro, etc.)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.66 2007/09/09 18:06:41 tg Exp $\t"
d41 1
a41 1
		for (i = 0; i < UCHAR_MAX+1; i++)
d46 1
a46 1
		chtypes[(unsigned char) *s++] |= t;
d502 1
a502 1
gmatchx(const char *s, const char *p, int isfile)
@


1.66
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.65 2007/08/12 13:42:21 tg Exp $\t"
d484 1
a484 1
	int rv = getn(as, ai);
d486 1
a486 1
	if (!rv)
d488 1
a488 1
	return rv;
@


1.65
log
@add “set -o arc4random”, RTFM for details
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.30 2006/03/12 00:26:58 deraadt Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.64 2007/07/26 13:23:51 tg Exp $\t"
@


1.64
log
@• test on HURD (gnubber)
• fix unreachable code (break stmt) cought by suncc on yofuh's E420
• bump vsn to today
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.63 2007/07/22 14:01:49 tg Exp $\t"
d107 3
d238 1
a238 1
	Flag(f) = newval;
@


1.63
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.62 2007/07/22 13:38:26 tg Exp $\t"
d385 1
a386 1
			break;
@


1.62
log
@some null/NUL
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.61 2007/07/22 13:34:51 tg Exp $\t"
d856 1
a856 1
				bi_errorf("");
d882 1
a882 1
				bi_errorf("");
@


1.61
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.60 2007/07/01 22:17:29 tg Exp $\t"
d68 1
a68 1
 * null terminated string s into it.  Always returns a null terminated string
@


1.60
log
@silence a gcc-4.2 warning and, in doing so, save quite a few operations:
• a NUL termination
• a strlen()
• a pointer comparision
• eventually a function call
replaced by
• a pointer subtraction
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.59 2007/07/01 16:49:17 tg Exp $\t"
d209 1
a209 1
		shprintf(newline);
d856 1
a856 1
				bi_errorf(null);
d882 1
a882 1
				bi_errorf(null);
@


1.59
log
@some <getopt.h> from vendors define a “struct option”, so use a
different name for ours
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.58 2007/06/15 21:55:19 tg Exp $\t"
d223 1
a223 2
	*cp = 0;
	return str_save(m, ATEMP);
@


1.58
log
@• check.t: add some FPOSIX regression tests (1 still fails)
• all: remove vi editing mode #if defined(MKSH_SMALL) || defined(MKSH_NOVI)
  saves 12608 byts on i386
• check.t: add $0 quoting
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.57 2007/06/06 23:28:16 tg Exp $\t"
d101 1
a101 1
const struct option options[] = {
@


1.57
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.56 2007/06/06 21:36:29 tg Exp $\t"
d134 1
d139 1
d240 9
a248 2
	} else if ((f == FVI || f == FEMACS || f == FGMACS) && newval) {
		Flag(FVI) = Flag(FEMACS) = Flag(FGMACS) = 0;
@


1.56
log
@first part of the Intel C Compiler (Linux) shaddap
| tglaser@@hephaistos:~ $ /usr/local/intel/cc/9.1.042/bin/icc -V
| Intel(R) C Compiler for 32-bit applications, Version 9.1    Build 20060706Z Package ID: l_cc_c_9.1.042
this one is muuuuch too verbose IMHO, _and_ it #defines __GNUC__ (eek)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.55 2007/06/05 19:48:47 tg Exp $\t"
d229 1
a229 1
    int newval)		/* what is changing the flag (command line vs set) */
d231 1
a231 1
	int oldval;
d277 1
a277 1
	char *opts;
d281 1
a281 1
	int optc, set, sortargs = 0, arrayset = 0;
d395 1
a395 2
					change_flag((enum sh_flag) i, what,
					    set);
@


1.55
log
@fix for the SUNpro 8 on yofuh's E420:
cc: Sun C 5.8 Patch 121015-04 2007/01/10
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.54 2007/05/13 18:33:29 tg Exp $\t"
d1431 1
a1431 1
ksh_isspace_(unsigned char ksh_isspace_c)
@


1.54
log
@Possible fix for Coverity CID#7:
convert options() prototype to unsigned (size_t, in fact), and make an
explicitly casted (size_t)-1 the error return code, modelled after what
is often used in Unix libraries
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.53 2007/05/13 17:51:23 tg Exp $\t"
d1428 9
@


1.53
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.52 2007/03/04 03:04:26 tg Exp $\t"
d148 1
a148 1
int
d151 1
a151 1
	unsigned i;
d155 1
a155 1
			return i;
d157 1
a157 1
	return -1;
d280 1
a281 1
	unsigned i;
d353 1
a353 1
			if (i != (unsigned)-1 && set == Flag(i))
d360 2
a361 2
			else if (i != (unsigned)-1 && (options[i].flags & what))
				change_flag((enum sh_flag) i, what, set);
d364 1
a364 1
				return -1;
@


1.52
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d9 1
a9 1
__RCSID("$MirOS$\t"
d399 2
a400 4
			if (i == NELEM(options)) {
				internal_errorf(1, "parse_args: '%c'", optc);
				return -1; /* not reached */
			}
@


1.52.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.52 2007/03/04 03:04:26 tg Exp $\t"
d148 1
a148 1
size_t
d151 1
a151 1
	size_t i;
d155 1
a155 1
			return (i);
d157 1
a157 1
	return ((size_t)-1);
a279 1
	size_t i;
d281 1
d353 1
a353 1
			if ((i != (size_t)-1) && set == Flag(i))
d360 2
a361 2
			else if ((i != (size_t)-1) && (options[i].flags & what))
				change_flag((enum sh_flag)i, what, set);
d364 1
a364 1
				return (-1);
d399 4
a402 2
			if (i == NELEM(options))
				internal_errorf("parse_args: '%c'", optc);
@


1.52.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.52.2.1 2007/05/13 19:29:38 tg Exp $\t"
d221 2
a222 1
	return (str_nsave(m, cp - m, ATEMP));
@


1.51
log
@merge the const branch +- a few
@
text
@d314 1
a314 1
		char *p;
d318 5
a322 2
		Flag(FLOGIN) = (argv[0][0] == '-' ||
		    ((p = strrchr(argv[0], '/')) && *++p == '-'));
d564 1
a564 1
		} else if ((c & 0x80) && strchr("*+?@@! ", c & 0x7f)) {
d764 1
a764 1
		if ((*p & 0x80) && strchr("*+?@@! ", *p & 0x7f))
d817 1
a817 1
	char *o;
d842 1
a842 1
	    !(o = strchr(optionsp, c))) {
d927 3
a929 1
			shprintf("'\\'" + 1 - inquote);
d931 3
a933 6
		} else {
			if (!inquote) {
				shprintf("'");
				inquote = 1;
			}
			shf_putc(*p, shl_stdout);
d935 1
d938 1
a938 1
		shprintf("'");
d1287 1
a1287 1
		len = (q = strchr(p, '/')) ? q - p : (int)strlen(p);
d1378 52
@


1.50
log
@if mksh_small don't even support -T instead of ignoring it
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.49 2007/01/18 20:54:30 tg Exp $\t"
d91 1
a91 1
Xcheck_grow_(XString *xsp, char *xp, unsigned more)
d93 1
a93 1
	char *old_beg = xsp->beg;
d271 1
a271 1
parse_args(char **argv,
d278 1
a278 1
	char *array = NULL;
d811 1
a811 1
ksh_getopt(char **argv, Getopt *go, const char *optionsp)
d817 1
a817 1
		char *arg = argv[go->optind], flag = arg ? *arg : '\0';
@


1.49
log
@* parse_T is a shitty function name for chvt()
* chvt() argument can be const
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.48 2007/01/18 20:48:23 tg Exp $\t"
d290 1
d293 1
d365 1
a366 1
#ifndef MKSH_SMALL
d375 1
a376 1
			break;
@


1.48
log
@not having revoke() or not being able to revoke() [Debian 4.0] is insecure
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.47 2007/01/18 15:50:32 tg Exp $\t"
d28 1
a28 1
static void parse_T(char *);
d371 1
a371 1
			parse_T(go.optarg);
d1321 1
a1321 1
parse_T(char *fn)
d1331 1
a1331 1
			memmove(dv + 8, dv + 9, 20 - 9);
@


1.47
log
@header overhaul: replace all #ifdef __OS__ with mirtoconf checks
(except the persistent history one)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.46 2007/01/18 01:01:25 tg Exp $\t"
a1344 1
		warningf(false, "chvt: cannot revoke %s", fn);
d1346 2
@


1.46
log
@typo (reverse logic error)
@
text
@d5 1
a5 1
#if HAVE_SETGROUPS
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.45 2007/01/17 23:27:47 tg Exp $\t"
@


1.45
log
@scan for revoke()
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.44 2006/11/19 20:43:13 tg Exp $\t"
d1343 1
a1343 1
#if !HAVE_REVOKE
@


1.44
log
@remove the "set -o sh" option (dummy anyway),
"set +o emacs-usemeta" and "set -o vi-show8" which are always on now,
since we have proper internationalisation (i.e. utf-8) support, and
assume the user either has a 'C' locale and can't enter 8-bit chars,
his terminal is 8bit-transparent, or he has a 'UTF-8' locale.
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.43 2006/11/16 13:35:07 tg Exp $\t"
d1343 1
a1343 1
#if !defined(__sun__) && !defined(__gnu_linux__) && !defined(__INTERIX)
@


1.44.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
#if HAVE_GRP_H
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.50 2007/01/26 18:27:34 tg Exp $\t"
d28 1
a28 1
static void chvt(const char *);
a289 1
#ifndef MKSH_SMALL
a291 1
#endif
d363 1
a364 1
		case 'T':
d371 2
a372 1
			chvt(go.optarg);
a374 1
#endif
d1321 1
a1321 1
chvt(const char *fn)
d1331 1
a1331 1
			strlcpy(dv + 8, fn, 20 - 8);
d1343 1
a1343 1
#if HAVE_REVOKE
d1345 1
a1346 2
		warningf(false, "chvt: cannot revoke %s, new shell is"
		    " potentially insecure", fn);
@


1.44.2.2
log
@begin constification
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.44.2.1 2007/03/03 21:37:57 tg Exp $\t"
d271 1
a271 1
parse_args(const char **argv,
d278 1
a278 1
	const char *array = NULL;
d811 1
a811 1
ksh_getopt(const char **argv, Getopt *go, const char *optionsp)
d817 1
a817 1
		const char *arg = argv[go->optind], flag = arg ? *arg : '\0';
@


1.44.2.3
log
@more constification
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.44.2.2 2007/03/03 22:38:24 tg Exp $\t"
d91 1
a91 1
Xcheck_grow_(XString *xsp, const char *xp, unsigned more)
d93 1
a93 1
	const char *old_beg = xsp->beg;
@


1.43
log
@support systems without setresugid
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.42 2006/11/12 14:58:15 tg Exp $\t"
a110 1
	{ "emacs-usemeta",  0,		OF_ANY }, /* non-standard */
a129 1
	{ "sh",		  0,		OF_ANY }, /* non-standard */
a135 1
	{ "vi-show8",	  0,		OF_ANY }, /* non-standard */
a232 4
	/* limited pdksh compatibility (FSH stays always off) */
	if (f == FSH)
		return;

@


1.42
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.41 2006/11/12 13:35:29 tg Exp $\t"
d19 5
d259 4
a262 1
#error setresid/setresgid required at the moment
@


1.41
log
@* fix CR-LF accident
* fix gcc4 warnings in autoconf tests
* Debian needs <grp.h> for setgroups, which seems fairly POSIX

Testsuite succeeds on Debian testing/unstable (i386)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.40 2006/11/12 12:56:10 tg Exp $\t"
d163 2
a164 2
static char *options_fmt_entry(void *arg, int i, char *buf, int buflen);
static void printoptions(int verbose);
d168 1
a168 1
options_fmt_entry(void *arg, int i, char *buf, int buflen)
d170 1
a170 1
	struct options_info *oi = (struct options_info *) arg;
d767 1
a767 1
	return (strcmp(*(const char **)p1, *(const char **)p2));
d939 3
a941 2
print_columns(struct shf *shf, int n, char *(*func) (void *, int, char *, int),
    void *arg, int max_width, int prefcol)
@


1.40
log
@scan for setresuid/setresgid and setgroups
no alternative implementation yet
@
text
@d5 3
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.39 2006/11/10 19:11:57 tg Exp $\t"
@


1.39
log
@not being able to get current working directory shan't yield SIGSEGV, oops
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.38 2006/11/10 07:52:03 tg Exp $\t"
d242 1
d246 1
d248 1
d250 3
@


1.38
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.37 2006/11/10 07:18:57 tg Exp $\t"
d1049 1
a1049 1
	size_t len = 0;
@


1.37
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.36 2006/11/10 06:53:27 tg Exp $\t"
d876 1
a876 1
			if (digit(argv[go->optind - 1][go->p])) {
d882 1
a882 1
			if (argv[go->optind] && digit(argv[go->optind][0])) {
@


1.36
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.35 2006/11/10 06:27:09 tg Exp $\t"
d432 1
a432 1
	} while (isspace(c));
@


1.35
log
@use setresuid(2) and friends instead, saves 88t 4d 1i
XXX revisit this if we encounter systems without at least
XXX one of setresuid, setresgid, setgroups - only tested on BSD
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.34 2006/11/10 05:21:38 tg Exp $\t"
d440 1
a440 1
		if (!isdigit(c))
@


1.34
log
@oops
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.33 2006/11/10 04:07:59 tg Exp $\t"
d242 5
a246 4
		seteuid(ksheuid = kshuid = getuid());
		setuid(ksheuid);
		setegid(kshegid = kshgid = getgid());
		setgid(kshegid);
@


1.33
log
@get rid of the 'mksh -T' functionality (chvt) if MKSH_SMALL
848 text 12 data 3 imports
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.32 2006/11/10 04:03:59 tg Exp $\t"
d453 1
a453 1
	return (1);
@


1.32
log
@thanks to the nice property of my reimplementation of getn to also
return a value in case of an error (0 or the partial result, which
is the full result in case of trailing junk even), using it to rid
atoi() is possible, saving 9t 4d 1i
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.31 2006/11/10 03:54:38 tg Exp $\t"
d9 5
d19 1
a19 1
#ifdef TIOCSCTTY
d353 1
d356 1
a356 1
#ifndef TIOCSCTTY
d362 1
d1307 1
a1307 1
#ifdef TIOCSCTTY
@


1.31
log
@exit not _exit, 50 text 4 data 1 import
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.30 2006/11/10 03:45:57 tg Exp $\t"
d419 1
a419 1
	int i, c;
d430 1
a430 1
	i = 0;
a431 1
		*ai = i;
d433 1
a433 1
			return (0);
d437 1
a437 1
			return (0);
d439 1
d441 1
d443 3
a445 1
	*ai = neg ? -i : i;
@


1.30
log
@correct a few protos and comments
saves 4 .text bytes and my nerves
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.23 2006/11/10 01:13:52 tg Exp $\t"
d1337 1
a1337 1
		_exit(0);
@


1.29
log
@use qsort(3) instead of rolling our own
saves 284 in .text, no added import since we already use qsort(3) once
@
text
@d750 1
a750 1
/* Initialize a Getopt structure */
d965 1
a965 1
int
a987 1
		return dst - buf;
a988 1
	return nbytes;
a1001 1
			int oerrno = errno;
d1006 1
a1006 1
			errno = oerrno;
d1035 1
a1035 1
ksh_get_wd(char *buf, int bsize)
d1037 2
a1038 11
	char *b;
	char *ret;

	/* Note: we could just use plain getcwd(), but then we'd had to
	 * inject possibly allocated space into the ATEMP area. */
	/* Assume getcwd() available */
	if (!buf) {
		bsize = PATH_MAX;
		b = alloc(PATH_MAX + 1, ATEMP);
	} else
		b = buf;
d1040 4
a1043 8
	ret = getcwd(b, bsize);

	if (!buf) {
		if (ret)
			ret = aresize(b, strlen(b) + 1, ATEMP);
		else
			afree(b, ATEMP);
	}
d1045 2
d1210 1
a1210 1
	int len;
d1213 5
a1217 4
	if (!p && !(p = ksh_get_wd(NULL, 0)))
		p = null;

	len = strlen(p) + 1;
@


1.28
log
@use errorf not bi_errorf if we want to abort
saves 16 .text ;)
@
text
@d403 1
a403 1
		qsortp((void **) &argv[go.optind], (size_t) (i - go.optind),
d603 1
a603 2
		   *
		   * Not ifdef'd KSH as this is needed for ${..%..}, etc.
a743 92

/* -------- qsort.c -------- */

/*
 * quick sort of array of generic pointers to objects.
 */
static void qsort1(void **base, void **lim, int (*f)(void *, void *));

void
qsortp(void **base,			/* base address */
    size_t n,				/* elements */
    int (*f) (void *, void *))		/* compare function */
{
	qsort1(base, base + n, f);
}

#define	swap2(a, b)	{\
	void *t; t = *(a); *(a) = *(b); *(b) = t;\
}
#define	swap3(a, b, c)	{\
	void *t; t = *(a); *(a) = *(c); *(c) = *(b); *(b) = t;\
}

static void
qsort1(void **base, void **lim, int (*f) (void *, void *))
{
	void **i, **j;
	void **lptr, **hptr;
	size_t n;
	int c;

 top:
	n = (lim - base) / 2;
	if (n == 0)
		return;
	hptr = lptr = base+n;
	i = base;
	j = lim - 1;

	for (;;) {
		if (i < lptr) {
			if ((c = (*f)(*i, *lptr)) == 0) {
				lptr --;
				swap2(i, lptr);
				continue;
			}
			if (c < 0) {
				i += 1;
				continue;
			}
		}

 begin:
		if (j > hptr) {
			if ((c = (*f)(*hptr, *j)) == 0) {
				hptr ++;
				swap2(hptr, j);
				goto begin;
			}
			if (c > 0) {
				if (i == lptr) {
					hptr ++;
					swap3(i, hptr, j);
					i = lptr += 1;
					goto begin;
				}
				swap2(i, j);
				j -= 1;
				i += 1;
				continue;
			}
			j -= 1;
			goto begin;
		}

		if (i == lptr) {
			if (lptr-base >= lim-hptr) {
				qsort1(hptr+1, lim, f);
				lim = lptr;
			} else {
				qsort1(base, lptr, f);
				base = hptr+1;
			}
			goto top;
		}

		lptr -= 1;
		swap3(j, lptr, i);
		j = hptr -= 1;
	}
}

d745 1
a745 1
xstrcmp(void *p1, void *p2)
d747 1
a747 1
	return (strcmp((char *)p1, (char *)p2));
@


1.27
log
@rewrite getn() which is some kind of atoi with return code
costs 1 .text, saves 4 .data, 1 libc import
@
text
@d351 1
a351 2
			bi_errorf("no TIOCSCTTY ioctl");
			return -1;
d1417 1
a1417 1
				bi_errorf("chvt: can't find tty %s", fn);
d1422 1
a1422 1
		bi_errorf("chvt: not a char device: %s", fn);
d1435 1
a1435 1
			bi_errorf("chvt: cannot open %s", fn);
d1439 1
a1439 1
		bi_errorf("fork failed");
d1446 1
a1446 1
		bi_errorf("chvt: setsid failed");
d1448 1
a1448 1
		bi_errorf("chvt: TIOCSCTTY failed");
@


1.26
log
@overhaul parse_args - don't use strlcpy and strlen when overkill
also fixes off-by-one

saves 48 .text
@
text
@d418 1
a418 1
getn(const char *as, int *ai)
d420 2
a421 2
	char *p;
	long n;
d423 19
a441 1
	n = strtol(as, &p, 10);
d443 2
a444 5
	if (!*as || *p || INT_MIN >= n || n >= INT_MAX)
		return 0;

	*ai = (int)n;
	return 1;
@


1.25
log
@* change EXECSHELL to /bin/sh (we can override it via environment anyway,
  and this is a sensible choice instead of ourselves)
* move this stuff from sh.h into exec.c where it belongs
* simplify set -o stuff

saves 8 bytes
@
text
@d260 1
a260 1
	static char set_opts[NELEM(options) + 5]; /* Ao;s\0 */
d269 1
a269 1
		char *p, *q;
d272 4
a275 2
		strlcpy(cmd_opts, "o:T:", sizeof cmd_opts);
		p = cmd_opts + strlen(cmd_opts);
d277 6
a282 2
		strlcpy(set_opts, "A:o;s", sizeof set_opts);
		q = set_opts + strlen(set_opts);
@


1.24
log
@if !MKSH_SMALL, str_save() can be a macro
@
text
@d152 1
a152 4
	struct {
		const char *name;
		int	flag;
	} opts[NELEM(options)];
d165 2
a166 2
	    oi->opt_width, oi->opts[i].name,
	    Flag(oi->opts[i].flag) ? "on" : "off");
d185 1
a185 2
				oi.opts[n].name = options[i].name;
				oi.opts[n++].flag = i;
@


1.23
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.22 2006/11/09 23:55:51 tg Exp $\t"
d68 1
d74 1
@


1.22
log
@get rid of ulton() - a joke
saves 32 bss, but adds 84 text oO
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.21 2006/11/09 23:39:16 tg Exp $\t"
d14 3
a16 1
static int parse_T(char *);
d346 4
a349 2
			if (parse_T(go.optarg))
				return -1;
d351 2
d1385 3
a1387 5
#if !defined(TIOCSCTTY)
#define NO_CHVT "no TIOCSCTTY ioctl"
#else
static const char *
chvt(char *f)
d1389 2
d1393 16
a1408 4
	if (chown(f, 0, 0))
		return "chown";
	if (chmod(f, 0600))
		return "chmod";
d1410 2
a1411 2
	if (revoke(f))
		return "revoke";
d1414 1
a1414 1
	if ((fd = open(f, O_RDWR)) == -1) {
d1416 2
a1417 2
		if ((fd = open(f, O_RDWR)) == -1)
			return "open";
d1421 1
a1421 1
		return "fork";
d1428 1
a1428 1
		return "setsid";
d1430 1
a1430 1
		return "ioctl";
a1435 2

	return NULL;
a1437 34

static int
parse_T(char *fn __attribute__((unused)))
{
#ifdef NO_CHVT
	warningf(0, "chvt: %s", NO_CHVT);
	return -1;
#else
	const char *rv;
	char dv[20];
	struct stat sb;

	strlcpy(dv, fn, 20);
	if (stat(dv, &sb)) {
		snprintf(dv, 20, "/dev/ttyC%s", fn);
		if (stat(dv, &sb)) {
			snprintf(dv, 20, "/dev/tty%s", fn);
			if (stat(dv, &sb)) {
				warningf(0, "chvt: can't find tty %s", fn);
				return -1;
			}
		}
	}
	if (!(sb.st_mode & S_IFCHR)) {
		warningf(0, "chvt: not a char device: %s", fn);
		return -1;
	}
	if ((rv = chvt(dv)) != NULL) {
		warningf(0, "chvt: failed to %s: %s", rv, strerror(errno));
		return -1;
	}
	return 0;
#endif
}
@


1.21
log
@shrink chtypes array down to 8 bit
saves 72 text and a lot bss
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.20 2006/11/09 20:53:41 tg Exp $\t"
a51 17
/* convert unsigned long to base N string */

char *
ulton(long unsigned int n, int base)
{
	char *p;
	static char buf[20];

	p = &buf[sizeof (buf)];
	*--p = '\0';
	do {
		*--p = "0123456789ABCDEF"[n%base];
		n /= base;
	} while (n != 0);
	return p;
}

@


1.20
log
@using a function instead of a macro saves 896 bytes of .text
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.19 2006/11/09 14:19:31 tg Exp $\t"
d9 1
a9 1
short chtypes[UCHAR_MAX+1];	/* type bits for unsigned char */
a48 1
	setctypes("#%", C_SUBOP2);
@


1.19
log
@optimise and, ahem… plug…
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.18 2006/11/05 17:01:46 tg Exp $\t"
d84 6
@


1.18
log
@make this R29(beta), mksh -U turn on (or setlocale), and document.
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.17 2006/11/05 12:11:14 tg Exp $\t"
d59 1
a59 1
	static char buf [20];
d61 1
a61 1
	p = &buf[sizeof(buf)];
a69 14
char *
str_save(const char *s, Area *ap)
{
	size_t len;
	char *p;

	if (!s)
		return NULL;
	len = strlen(s)+1;
	p = alloc(len, ap);
	strlcpy(p, s, len+1);
	return (p);
}

d77 1
a77 1
	char *ns;
d79 3
a81 5
	if (n < 0)
		return 0;
	ns = alloc(n + 1, ap);
	ns[0] = '\0';
	return strncat(ns, s, n);
@


1.17
log
@add new "set -o utf8-hack", currently no effect
set automatically on startup if we have locale functions (on MirOS)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.16 2006/08/24 20:32:53 tg Exp $\t"
d145 1
a145 1
	{ "utf8-hack",	  0,		OF_ANY }, /* non-standard */
@


1.16
log
@merge non-Plan9-specific stuff from the branch, add KNF, etc.
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.15 2006/08/22 22:49:36 tg Exp $\t"
d145 1
@


1.15
log
@* remove redundancy
* integrate compat.h, version.h into sh.h (dependency trick didn't work anyway)
* mention #ksh in mksh(1) since the founder (twkm) said it's on topic too
  (don't remove mention of #mksh despite it's usually empty because of control)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.14 2006/08/22 22:16:04 tg Exp $\t"
d1132 1
a1132 1
/* Like getcwd(), except bsize is ignored if buf is 0 (MAXPATHLEN is used) */
d1143 2
a1144 2
		bsize = MAXPATHLEN;
		b = alloc(MAXPATHLEN + 1, ATEMP);
@


1.14
log
@* version.h doesn't need an RCS ID
* compat.h does, add it to misc.c, always include it, move if NEED_COMPAT
* major whitespace cleanup in sh.h
@
text
@d6 2
a7 2
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.13 2006/08/09 20:44:15 tg Exp $"
	"\t" MKSH_SH_H_ID "\t" MKSH_COMPAT_H_ID);
a14 1

@


1.13
log
@re-implement "set -o posix" which doesn't do much ;)
but turns off 'braceexpand' when turned on as side effect,
just like oksh/pdksh.
document "set -o sh" too.
@
text
@d6 2
a7 2
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.12 2006/08/01 13:43:28 tg Exp $"
	"\t" MKSH_SH_H_ID);
d16 1
a16 1
static char	*do_phys_path(XString *, char *, const char *);
@


1.13.2.1
log
@use PATH_MAX not MAXPATHLEN
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.13 2006/08/09 20:44:15 tg Exp $"
d1133 1
a1133 1
/* Like getcwd(), except bsize is ignored if buf is 0 (PATH_MAX is used) */
d1144 2
a1145 2
		bsize = PATH_MAX;
		b = alloc(PATH_MAX + 1, ATEMP);
@


1.13.2.2
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d6 2
a7 2
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.16 2006/08/24 20:32:53 tg Exp $\t"
	MKSH_SH_H_ID);
d15 2
a16 1
static char *do_phys_path(XString *, char *, const char *);
@


1.13.2.3
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.12
log
@style(9)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.11 2006/05/10 18:54:11 tg Exp $"
d251 2
a252 2
	/* disabled functionality */
	if ((f == FPOSIX) || (f == FSH))
d260 3
a262 6
	} else if (f == FVI || f == FEMACS || f == FGMACS) {
		if (newval) {
			Flag(FVI) = 0;
			Flag(FEMACS) = Flag(FGMACS) = 0;
			Flag(f) = newval;
		}
d269 2
@


1.11
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.10 2005/11/24 19:39:10 tg Exp $"
d781 1
a781 1
  top:
d802 1
a802 1
	  begin:
@


1.10
log
@use \t not \n for separating RCS IDs
ident(1) finds both similarily, and as doesn't bitch
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.28 2005/03/30 17:16:37 deraadt Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.9 2005/11/22 18:40:43 tg Exp $"
d331 1
a331 1
	while ((optc = ksh_getopt(argv, &go, opts)) != EOF) {
d899 1
a899 1
			return EOF;
d906 1
a906 1
			return EOF;
@


1.9
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d6 2
a7 2
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.8 2005/10/25 19:53:28 tg Exp $"
	"\n" MKSH_SH_H_ID);
@


1.8
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.7 2005/07/07 23:27:52 tg Exp $ */
d6 2
a7 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.7 2005/07/07 23:27:52 tg Exp $");
@


1.7
log
@* move <sys/param.h> include to sh.h
* fix compilation and invocation of test suite with whitespace in
  the pathnames for real, this time
* clean up (especially whitespace)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.6 2005/07/04 12:34:23 tg Exp $ */
a5 2
#include <sys/ioctl.h>
#include <sys/stat.h>
d7 1
a7 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.6 2005/07/04 12:34:23 tg Exp $");
@


1.6
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.5 2005/07/04 12:27:27 tg Exp $ */
a6 1
#include <sys/param.h>	/* for MAXPATHLEN */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.5 2005/07/04 12:27:27 tg Exp $");
@


1.5
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.4 2005/05/25 13:46:01 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.4 2005/05/25 13:46:01 tg Exp $");
d255 1
a255 1
	if (f == FPOSIX)
@


1.4
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.3 2005/05/23 15:54:31 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.3 2005/05/23 15:54:31 tg Exp $");
d254 4
a274 2
	} else if (f == FPOSIX && newval) {
		Flag(FBRACEEXPAND) = 0;
d409 1
a409 1
		if (argv[go.optind][0] == '-' && !Flag(FPOSIX))
@


1.3
log
@now passes on Solaris (-Wall -W -Wno-char-subscripts) too
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.2 2005/05/23 15:18:16 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.2 2005/05/23 15:18:16 tg Exp $");
d267 1
a267 1
		seteuid(ksheuid = getuid());
d269 2
a270 2
		setegid(getgid());
		setgid(getgid());
@


1.2
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/misc.c,v 1.1 2005/05/23 03:06:08 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.1 2005/05/23 03:06:08 tg Exp $");
d1454 1
a1454 1
parse_T(char *fn)
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/misc.c,v 1.16 2005/05/23 02:20:36 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: mksh/misc.c,v 1.16 2005/05/23 02:20:36 tg Exp $");
d474 1
a474 1
gmatch(const char *s, const char *p, int isfile)
@

