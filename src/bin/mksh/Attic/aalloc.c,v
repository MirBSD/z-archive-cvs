head	1.32;
access;
symbols
	tg-aalloc-experimental:1.31.0.2;
locks; strict;
comment	@ * @;


1.32
date	2008.11.19.21.05.48;	author tg;	state dead;
branches;
next	1.31;
commitid	10049247FBD4DDB3E80;

1.31
date	2008.11.15.11.42.18;	author tg;	state Exp;
branches
	1.31.2.1;
next	1.30;
commitid	100491EB5952D30F89E;

1.30
date	2008.11.15.09.05.29;	author tg;	state Exp;
branches;
next	1.29;
commitid	100491E90F07B2ED887;

1.29
date	2008.11.15.08.52.00;	author tg;	state Exp;
branches;
next	1.28;
commitid	100491E8DC449203AF3;

1.28
date	2008.11.15.07.59.46;	author tg;	state Exp;
branches;
next	1.27;
commitid	100491E818025B27E8F;

1.27
date	2008.11.15.07.51.53;	author tg;	state Exp;
branches;
next	1.26;
commitid	100491E7E093930854B;

1.26
date	2008.11.15.07.35.23;	author tg;	state Exp;
branches;
next	1.25;
commitid	100491E7BBB79B0FECE;

1.25
date	2008.11.12.23.34.02;	author tg;	state Exp;
branches;
next	1.24;
commitid	100491B67F35E2F7B75;

1.24
date	2008.11.12.19.23.09;	author tg;	state Exp;
branches;
next	1.23;
commitid	100491B2D277B164E64;

1.23
date	2008.11.12.07.36.19;	author tg;	state Exp;
branches;
next	1.22;
commitid	100491A872A75670F3C;

1.22
date	2008.11.12.07.02.47;	author tg;	state Exp;
branches;
next	1.21;
commitid	100491A7FAA3BCF44EF;

1.21
date	2008.11.12.06.58.49;	author tg;	state Exp;
branches;
next	1.20;
commitid	100491A7EB8097259A5;

1.20
date	2008.11.12.06.44.04;	author tg;	state Exp;
branches;
next	1.19;
commitid	100491A7B4814238F4B;

1.19
date	2008.11.12.06.42.22;	author tg;	state Exp;
branches;
next	1.18;
commitid	100491A7AE044D9FC5C;

1.18
date	2008.11.12.06.38.08;	author tg;	state Exp;
branches;
next	1.17;
commitid	100491A79DC13A999DE;

1.17
date	2008.11.12.06.35.27;	author tg;	state Exp;
branches;
next	1.16;
commitid	100491A793F1CA8D9CA;

1.16
date	2008.11.12.06.14.26;	author tg;	state Exp;
branches;
next	1.15;
commitid	100491A745579203CD3;

1.15
date	2008.11.12.06.12.56;	author tg;	state Exp;
branches;
next	1.14;
commitid	100491A73FB5A6E852B;

1.14
date	2008.11.12.06.10.51;	author tg;	state Exp;
branches;
next	1.13;
commitid	100491A737D29B0017B;

1.13
date	2008.11.12.06.05.54;	author tg;	state Exp;
branches;
next	1.12;
commitid	100491A725118C3FBFF;

1.12
date	2008.11.12.05.55.43;	author tg;	state Exp;
branches;
next	1.11;
commitid	100491A6FE568462E77;

1.11
date	2008.11.12.05.46.45;	author tg;	state Exp;
branches;
next	1.10;
commitid	100491A6DD3650E4ED8;

1.10
date	2008.11.12.05.46.14;	author tg;	state Exp;
branches;
next	1.9;
commitid	100491A6DB958D99A4A;

1.9
date	2008.11.12.05.45.28;	author tg;	state Exp;
branches;
next	1.8;
commitid	100491A6D7F0B8B65EE;

1.8
date	2008.11.12.05.40.23;	author tg;	state Exp;
branches;
next	1.7;
commitid	100491A6C576BF02B34;

1.7
date	2008.11.12.05.34.20;	author tg;	state Exp;
branches;
next	1.6;
commitid	100491A6AEE31C1F060;

1.6
date	2008.11.12.05.32.34;	author tg;	state Exp;
branches;
next	1.5;
commitid	100491A6A823AD9E853;

1.5
date	2008.11.12.05.27.01;	author tg;	state Exp;
branches;
next	1.4;
commitid	100491A69341C5DCE55;

1.4
date	2008.11.12.05.11.05;	author tg;	state Exp;
branches;
next	1.3;
commitid	100491A657A0ABA9F49;

1.3
date	2008.11.12.05.05.17;	author tg;	state Exp;
branches;
next	1.2;
commitid	100491A641828D83F69;

1.2
date	2008.11.12.04.59.42;	author tg;	state Exp;
branches;
next	1.1;
commitid	100491A62CC18906809;

1.1
date	2008.11.12.04.55.17;	author tg;	state Exp;
branches;
next	;
commitid	100491A618E0C3BD225;

1.31.2.1
date	2008.11.22.13.20.25;	author tg;	state dead;
branches;
next	;
commitid	100492806F80A7B2451;


desc
@@


1.32
log
@b0rken for now…
@
text
@#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.31 2008/11/15 11:42:18 tg Exp $");

/* mksh integration of aalloc */

#if defined(AALLOC_STATS) && !defined(AALLOC_WARN)
#define AALLOC_WARN		aalloc_warn
static void aalloc_warn(const char *, ...)
    __attribute__((format (printf, 1, 2)));
static void
aalloc_warn(const char *fmt, ...)
{
	va_list va;
	FILE *of;

	va_start(va, fmt);
	if ((of = fopen("/tmp/aalloc.out", "ab+"))) {
		fprintf(of, "%08X %5d: ", (unsigned int)time(NULL),
		    (int)getpid());
		vfprintf(of, fmt, va);
		putc('\n', of);
		fclose(of);
	} else
		internal_verrorf(fmt, va);
}
#endif

#ifndef AALLOC_ABORT
#define AALLOC_ABORT		internal_errorf
#endif

#ifndef AALLOC_WARN
#define AALLOC_WARN		internal_warningf
#endif

#ifndef AALLOC_THREAD_ENTER
#define AALLOC_THREAD_ENTER(ap)	/* nothing */
#define AALLOC_THREAD_LEAVE(ap)	/* nothing */
#endif

#ifndef AALLOC_LEAK_SILENT
#define AALLOC_LEAK_SILENT	/* the code does not yet clean up at exit */
#endif

#ifndef AALLOC_RANDOM
#if HAVE_ARC4RANDOM
#define AALLOC_RANDOM()		arc4random()
#else
#define AALLOC_RANDOM()		(rand() * RAND_MAX + rand())
#endif
#endif

#undef AALLOC_SMALL
#ifdef MKSH_SMALL
#define AALLOC_SMALL		/* skip sanity checks */
#endif

#if defined(DEBUG) && !defined(AALLOC_DEBUG)
#define AALLOC_DEBUG		/* add extra sanity checks */
#endif

/* generic area-based allocator built for mmap malloc or omalloc */

#if defined(AALLOC_SMALL)
#undef AALLOC_DEBUG
#undef AALLOC_STATS
#undef AALLOC_TRACK
#ifndef AALLOC_NO_COOKIES
#define AALLOC_NO_COOKIES
#endif
#elif defined(AALLOC_STATS) && !defined(AALLOC_TRACK)
#define AALLOC_TRACK
#endif

#define PVALIGN			(sizeof (void *))
#define PVMASK			(sizeof (void *) - 1)
#define isunaligned(p)		(((ptrdiff_t)(p) & PVMASK) != 0)

#ifndef AALLOC_INITSZ
#define AALLOC_INITSZ		(64 * PVALIGN)	/* at least 4 pointers */
#endif

typedef /* unsigned */ ptrdiff_t TCookie;
typedef union {
	/* unsigned */ ptrdiff_t xv;
} TCooked;

typedef union {
	ptrdiff_t nv;
	char *cp;
} TPtr;

#ifdef AALLOC_NO_COOKIES
#define ldcook(p, cv, c)	((p).nv = (cv).xv, (p).nv)
#define stcook(cv, p, c)	((cv).xv = (p).nv, (p).nv)
#define stcookp(cv, p, c)	(xp.cp = (char *)(p), (cv).xv = xp.nv, xp.nv)
#define stcooki(cv, i, c)	((cv).xv = (xp.nv = (i)), xp.nv)
#define iscook(c)		true
#else
#define ldcook(p, cv, c)	((p).nv = (cv).xv ^ (c), (p).nv)
#define stcook(cv, p, c)	((cv).xv = (p).nv ^ (c), (p).nv)
#define stcookp(cv, p, c)	(xp.cp = (char *)(p), (cv).xv = xp.nv ^ (c), xp.nv)
#define stcooki(cv, i, c)	((cv).xv = (xp.nv = (i)) ^ (c), xp.nv)
#define iscook(c)		isunaligned(c)
#endif

/*
 * The separation between TBlock and TArea does not seem to make
 * sense at first, especially in the !AALLOC_TRACK case, but is
 * necessary to keep PArea values constant even if the storage is
 * enlarged. While we could use an extensible array to keep track
 * of the TBlock instances, kind of like we use TBlock.storage to
 * track the allocations, it would require another TBlock member
 * and a fair amount of backtracking; since omalloc can optimise
 * pointer sized allocations like a !AALLOC_TRACK TArea, we don't
 * do that then.
 */

struct TBlock {
#ifndef AALLOC_NO_COOKIES
	TCookie bcookie;
#endif
	char *endp;
	char *last;
	void *storage;
};
typedef struct TBlock *PBlock;

struct TArea {
	TCooked bp;
#ifdef AALLOC_TRACK
	TCooked prev;
#ifndef AALLOC_NO_COOKIES
	TCookie scookie;
#endif
#ifdef AALLOC_STATS
	const char *name;
	unsigned long numalloc;
	unsigned long maxalloc;
	bool isfree;
#endif
#endif
};

static TCookie fcookie;

#ifdef AALLOC_TRACK
static PArea track;
static void track_check(void);
#endif

#ifdef AALLOC_MPROTECT
#undef AALLOC_INITSZ
#define AALLOC_INITSZ		pagesz
static long pagesz;
#define AALLOC_ALLOW(bp)	mprotect((bp), (bp)->endp - (char *)(bp), \
				    PROT_READ | PROT_WRITE)
#define AALLOC_DENY(bp)		mprotect((bp), (bp)->endp - (char *)(bp), \
				    PROT_NONE)
#define AALLOC_PEEK(bp)		mprotect((bp), sizeof (struct TArea), \
				    PROT_READ | PROT_WRITE)
#else
#define AALLOC_ALLOW(bp)	/* nothing */
#define AALLOC_DENY(bp)		/* nothing */
#define AALLOC_PEEK(bp)		/* nothing */
#endif

/*
 * Some nice properties: allocations are always PVALIGNed, which
 * includes the pointers seen by our user, the forward and back
 * pointers, the AALLOC_TRACK prev pointer, etc.
 */

#define safe_malloc(dest, len) do {					\
	(dest) = malloc((len));						\
	safe_xalloc_common((dest), (len));				\
} while (/* CONSTCOND */ 0)
#define safe_realloc(dest, len) do {					\
	(dest) = realloc((dest), (len));				\
	safe_xalloc_common((dest), (len));				\
} while (/* CONSTCOND */ 0)
#define safe_xalloc_common(dest, len) do {				\
	if ((dest) == NULL)						\
		AALLOC_ABORT("unable to allocate %lu bytes: %s",	\
		    (unsigned long)(len), strerror(errno));		\
	if (isunaligned(dest))						\
		AALLOC_ABORT("unaligned malloc result: %p", (dest));	\
} while (/* CONSTCOND */ 0)

#define MUL_NO_OVERFLOW (1UL << (sizeof (size_t) * 8 / 2))
#define safe_muladd(nmemb, size, extra) do {				\
	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&	\
	    nmemb > 0 && SIZE_MAX / nmemb < size)			\
		AALLOC_ABORT("attempted integer overflow: %lu * %lu",	\
		    (unsigned long)nmemb, (unsigned long)size);		\
	size *= nmemb;							\
	if (size >= SIZE_MAX - extra)					\
		AALLOC_ABORT("unable to allocate %lu bytes: %s",	\
		    (unsigned long)size, "value plus extra too big");	\
	size += extra;							\
} while (/* CONSTCOND */ 0)

static void adelete_leak(PArea, PBlock, bool, const char *);
static PBlock check_bp(PArea, const char *, TCookie);
static TCooked *check_ptr(void *, PArea, PBlock *, TPtr *, const char *,
    const char *);

PArea
#ifdef AALLOC_STATS
anewEx(size_t hint, const char *friendly_name)
#else
anew(size_t hint)
#endif
{
	PArea ap;
	PBlock bp;
	TPtr xp;

	AALLOC_THREAD_ENTER(NULL)

#ifdef AALLOC_MPROTECT
	if (!pagesz) {
		if ((pagesz = sysconf(_SC_PAGESIZE)) == -1 ||
		    (size_t)pagesz < (size_t)PVALIGN)
			AALLOC_ABORT("sysconf(_SC_PAGESIZE) failed: %ld %s",
			    pagesz, strerror(errno));
	}
#endif

#ifdef AALLOC_DEBUG
	if (PVALIGN != 2 && PVALIGN != 4 && PVALIGN != 8 && PVALIGN != 16)
		AALLOC_ABORT("PVALIGN not a power of two: %lu",
		    (unsigned long)PVALIGN);
	if (sizeof (TPtr) != sizeof (TCookie) || sizeof (TPtr) != PVALIGN ||
	    sizeof (TPtr) != sizeof (TCooked))
		AALLOC_ABORT("TPtr sizes do not match: %lu, %lu, %lu, %lu",
		    (unsigned long)sizeof (TPtr),
		    (unsigned long)sizeof (TCookie), (unsigned long)PVALIGN,
		    (unsigned long)sizeof (TCooked));
	if ((size_t)AALLOC_INITSZ < sizeof (struct TBlock))
		AALLOC_ABORT("AALLOC_INITSZ constant too small: %lu < %lu",
		    (unsigned long)AALLOC_INITSZ,
		    (unsigned long)sizeof (struct TBlock));
	if (hint != (1UL << (ffs(hint) - 1)))
		AALLOC_ABORT("anew hint %lu not a power of two or too big",
		    (unsigned long)hint);
#endif

	if (!fcookie) {
#ifdef AALLOC_NO_COOKIES
		fcookie++;
#else
		size_t v = 0;

		/* ensure unaligned cookie */
		do {
			fcookie = AALLOC_RANDOM();
			if (AALLOC_RANDOM() & 1)
				v = AALLOC_RANDOM() & 7;
		} while (!iscook(fcookie) || !v);
		/* randomise seed afterwards */
		while (v--)
			AALLOC_RANDOM();
#endif
#ifdef AALLOC_TRACK
		atexit(track_check);
#endif
	}

	safe_muladd(sizeof (void *), hint, 0);
	if (hint < sizeof (struct TBlock))
		hint = AALLOC_INITSZ;

	safe_malloc(ap, sizeof (struct TArea));
	safe_malloc(bp, hint);
	/* ensure unaligned cookie */
#ifndef AALLOC_NO_COOKIES
	do {
		bp->bcookie = AALLOC_RANDOM();
	} while (!iscook(bp->bcookie));
#endif

	/* first byte after block */
	bp->endp = (char *)bp + hint;		/* bp + size of the block */
	/* next entry (forward pointer) available for new allocation */
	bp->last = (char *)&bp->storage;	/* first entry */

	(void)stcookp(ap->bp, bp, fcookie);
#ifdef AALLOC_TRACK
	(void)stcookp(ap->prev, track, fcookie);
#ifndef AALLOC_NO_COOKIES
	(void)stcooki(ap->scookie, bp->bcookie, fcookie);
#endif
#ifdef AALLOC_STATS
	ap->name = friendly_name ? friendly_name : "(no name)";
	ap->numalloc = 0;
	ap->maxalloc = 0;
	ap->isfree = false;
#endif
	track = ap;
#endif
	AALLOC_DENY(bp);
	AALLOC_THREAD_LEAVE(NULL)
	return (ap);
}

/*
 * Validate block in Area “ap”, return unlocked block pointer.
 * If “ocookie” is not 0, make sure block cookie is equal.
 */
static PBlock
check_bp(PArea ap, const char *funcname, TCookie ocookie __unused)
{
	TPtr p;
	PBlock bp;

	(void)ldcook(p, ap->bp, fcookie);
#ifndef AALLOC_SMALL
	if (!p.nv
#ifdef AALLOC_STATS
	    || ap->isfree
#endif
	    ) {
		AALLOC_WARN("%s: area %p already freed", funcname, ap);
		return (NULL);
	}
	if (isunaligned(p.nv)) {
		AALLOC_WARN("%s: area %p block pointer destroyed: %p",
		    funcname, ap, p.cp);
		return (NULL);
	}
#endif
	bp = (PBlock)p.cp;
	AALLOC_PEEK(bp);
#ifndef AALLOC_NO_COOKIES
	if (ocookie && bp->cookie != ocookie) {
		AALLOC_WARN("%s: block %p cookie destroyed: %p, %p",
		    funcname, bp, (void *)ocookie, (void *)bp->cookie);
		return (NULL);
	}
#endif
#ifndef AALLOC_SMALL
	if (isunaligned(bp->endp) || isunaligned(bp->last)) {
		AALLOC_WARN("%s: block %p data structure destroyed: %p, %p",
		    funcname, bp, bp->endp, bp->last);
		return (NULL);
	}
	if (bp->endp < (char *)bp) {
		AALLOC_WARN("%s: block %p end pointer out of bounds: %p",
		    funcname, bp, bp->endp);
		return (NULL);
	}
	if ((bp->last < (char *)&bp->storage) || (bp->last > bp->endp)) {
		AALLOC_WARN("%s: block %p last pointer out of bounds: "
		    "%p < %p < %p", funcname, bp, &bp->storage, bp->last,
		    bp->endp);
		return (NULL);
	}
#endif
	AALLOC_ALLOW(bp);
	return (bp);
}

#ifdef AALLOC_TRACK
/*
 * At exit, dump and free any leaked allocations, blocks and areas.
 */
static void
track_check(void)
{
	PArea tp;
	PBlock bp;
	TCookie xc = 0;
	TPtr xp;

	AALLOC_THREAD_ENTER(NULL)
	tp = track;
	while (tp) {
#ifndef AALLOC_NO_COOKIES
		xc = ldcook(xp, tp->scookie, fcookie);
#endif
		(void)ldcook(xp, tp->prev, fcookie);
#ifdef AALLOC_STATS
		AALLOC_WARN("AALLOC_STATS for %s(%p): %lu allocated, %lu at "
		    "once, %sfree", tp->name, tp, tp->numalloc, tp->maxalloc,
		    tp->isfree ? "" : "not ");
		if (tp->isfree)
			goto track_check_next;
#endif
		if (isunaligned(xp.nv) || !iscook(xc)) {
			/* buffer overflow or something? */
			AALLOC_WARN("AALLOC_TRACK data structure %p destroyed:"
			    " %p, %p; exiting", tp, xp.cp, (void *)xc);
			break;
		}
		if (!(bp = check_bp(tp, "atexit:track_check", xc)))
			goto track_check_next;
		if (bp->last != (char *)&bp->storage)
#ifdef AALLOC_LEAK_SILENT
			adelete_leak(tp, bp, false, "at exit");
#else
			adelete_leak(tp, bp, true, "at exit");
		else
			AALLOC_WARN("leaking empty area %p (%p %lu)", tp,
			    bp, (unsigned long)(bp->endp - (char *)bp));
#endif
		free(bp);
 track_check_next:
		free(tp);
		tp = (PArea)xp.cp;
	}
	track = NULL;
	AALLOC_THREAD_LEAVE(NULL)
}
#endif

static void
adelete_leak(PArea ap, PBlock bp, bool always_warn, const char *when)
{
	TPtr xp;

	while (bp->last > (char *)&bp->storage) {
		bp->last -= PVALIGN;
		(void)ldcook(xp, **((TCooked **)bp->last), bp->bcookie);
#ifndef AALLOC_SMALL
		if (always_warn || xp.cp != bp->last)
			AALLOC_WARN("leaking %s pointer %p in area %p (ofs %p "
			    "len %lu) %s", xp.cp != bp->last ? "underflown" :
			    "valid", *((char **)bp->last) + PVALIGN, ap, bp,
			    (unsigned long)(bp->endp - (char *)bp), when);
#endif
		free(xp.cp);
	}
}

void
adelete(PArea *pap)
{
	PBlock bp;
#if defined(AALLOC_TRACK) && !defined(AALLOC_STATS)
	PArea tp;
	TCookie xc = 0;
	TPtr xp;
#endif

	AALLOC_THREAD_ENTER(*pap)

	/* ignore invalid areas */
	if ((bp = check_bp(*pap, "adelete", 0)) != NULL) {
		if (bp->last != (char *)&bp->storage)
			adelete_leak(*pap, bp, false, "in adelete");
		free(bp);
	}

#if defined(AALLOC_TRACK) && !defined(AALLOC_STATS)
	/* if we are the last TArea allocated */
	if (track == *pap) {
		if (isunaligned(ldcook(xp, (*pap)->prev, fcookie))) {
			AALLOC_WARN("AALLOC_TRACK data structure %p destroyed:"
			    " %p", *pap, xp.cp);
			track = NULL;
		} else
			track = (PArea)xp.cp;
		goto adelete_tracked;
	}
	/* find the TArea whose prev is *pap */
	tp = track;
	while (tp) {
#ifndef AALLOC_NO_COOKIES
		xc = ldcook(xp, tp->scookie, fcookie);
#endif
		(void)ldcook(xp, tp->prev, fcookie);
		if (isunaligned(xp.nv) || !iscook(xc)) {
			/* buffer overflow or something? */
			AALLOC_WARN("AALLOC_TRACK data structure %p destroyed:"
			    " %p, %p; ignoring", tp, xp.cp, (void *)xc);
			tp = NULL;
			break;
		}
		if (xp.cp == (char *)*pap)
			break;
		tp = (PArea)xp.cp;
	}
	if (tp)
		tp->prev.xv = (*pap)->prev.xv;	/* decouple *pap */
	else
		AALLOC_WARN("area %p not in found AALLOC_TRACK data structure",
		    *pap);
 adelete_tracked:
#endif
	AALLOC_THREAD_LEAVE(*pap)
#ifdef AALLOC_STATS
	(*pap)->isfree = true;
#else
	free(*pap);
#endif
	*pap = NULL;
}

void *
alloc(size_t nmemb, size_t size, PArea ap)
{
	PBlock bp;
	TCooked *rp;
	TPtr xp;

	/* obtain the memory region requested, retaining guards */
	safe_muladd(nmemb, size, sizeof (TPtr));
	safe_malloc(rp, size);

	AALLOC_THREAD_ENTER(ap)

	/* chain into area */
	if ((bp = check_bp(ap, "alloc", 0)) == NULL)
		AALLOC_ABORT("cannot continue");
	if (bp->last == bp->endp) {
		TCooked **pp;
		size_t bsz;

		/* make room for more forward ptrs in the block allocation */
		bsz = bp->endp - (char *)bp;
		safe_muladd(2, bsz, 0);
		safe_realloc(bp, bsz);
		bp->last = (char *)bp + (bsz / 2);
		bp->endp = (char *)bp + bsz;

		/* all backpointers have to be adjusted */
		pp = (TCooked **)&bp->storage;
		while (pp < (TCooked **)bp->last) {
			(void)stcookp(**pp, pp, bp->bcookie);
			++pp;
		}

		/* “bp” has possibly changed, enter its new value into ap */
		(void)stcookp(ap->bp, bp, fcookie);
	}
	memcpy(bp->last, &rp, PVALIGN);	/* next available forward ptr */
	/* store cooked backpointer to address of forward pointer */
	(void)stcookp(*rp, bp->last, bp->bcookie);
	bp->last += PVALIGN;		/* advance next-avail pointer */
#ifdef AALLOC_STATS
	ap->numalloc++;
	{
		unsigned long curalloc;

		curalloc = (bp->last - (char *)&bp->storage) / PVALIGN;
		if (curalloc > ap->maxalloc)
			ap->maxalloc = curalloc;
	}
#endif
	AALLOC_DENY(bp);
	AALLOC_THREAD_LEAVE(ap)

	/* return aligned storage just after the cookied backpointer */
	return ((char *)rp + PVALIGN);
}

void *
aresize(void *vp, size_t nmemb, size_t size, PArea ap)
{
	PBlock bp;
	TCooked *rp;
	TPtr xp;

	if (vp == NULL)
		return (alloc(nmemb, size, ap));

	AALLOC_THREAD_ENTER(ap)

	/* validate allocation and backpointer against forward pointer */
	if ((rp = check_ptr(vp, ap, &bp, &xp, "aresize", "")) == NULL)
		AALLOC_ABORT("cannot continue");

	/* move allocation to size and possibly new location */
	safe_muladd(nmemb, size, sizeof (TPtr));
	safe_realloc(rp, size);

	/* write new address of allocation into the block forward pointer */
	memcpy(xp.cp, &rp, PVALIGN);

	AALLOC_DENY(bp);
	AALLOC_THREAD_LEAVE(ap)

	return ((char *)rp + PVALIGN);
}

/*
 * Try to find “vp” inside Area “ap”, use “what” and “extra” for error msgs.
 *
 * If an error occurs, returns NULL with no side effects.
 * Otherwise, returns address of the allocation, *bpp contains the unlocked
 * block pointer, *xpp the uncookied backpointer.
 */
static TCooked *
check_ptr(void *vp, PArea ap, PBlock *bpp, TPtr *xpp, const char *what,
    const char *extra)
{
	TCooked *rp;

#ifndef AALLOC_SMALL
	if (isunaligned(vp)) {
		AALLOC_WARN("trying to %s rogue unaligned pointer %p from "
		    "area %p%s", what + 1, vp, ap, extra);
		return (NULL);
	}
#endif

	rp = (TCooked *)(((char *)vp) - PVALIGN);
#ifndef AALLOC_SMALL
	if (!rp->xv) {
		AALLOC_WARN("trying to %s already freed pointer %p from "
		    "area %p%s", what + 1, vp, ap, extra);
		return (NULL);
	}
#endif

	if ((*bpp = check_bp(ap, what, 0)) == NULL)
		AALLOC_ABORT("cannot continue");
#ifndef AALLOC_SMALL
	if (isunaligned(ldcook(*xpp, *rp, (*bpp)->bcookie))) {
		AALLOC_WARN("trying to %s rogue pointer %p from area %p "
		    "(block %p..%p), backpointer %p unaligned%s",
		    what + 1, vp, ap, *bpp, (*bpp)->last, xpp->cp, extra);
	} else if (xpp->cp < (char *)&(*bpp)->storage ||
	    xpp->cp >= (*bpp)->last) {
		AALLOC_WARN("trying to %s rogue pointer %p from area %p "
		    "(block %p..%p), backpointer %p out of bounds%s",
		    what + 1, vp, ap, *bpp, (*bpp)->last, xpp->cp, extra);
	} else if (*((TCooked **)xpp->cp) != rp) {
		AALLOC_WARN("trying to %s rogue pointer %p from area %p "
		    "(block %p..%p), backpointer %p, forward pointer to "
		    "%p instead%s", what + 1, vp, ap, *bpp, (*bpp)->last,
		    xpp->cp, *((TCooked **)xpp->cp), extra);
	} else
#endif
		return (rp);

#ifndef AALLOC_SMALL
	/* error case fall-through */
	AALLOC_DENY(*bpp);
	return (NULL);
#endif
}

void
afree(void *vp, PArea ap)
{
	PBlock bp;
	TCooked *rp;
	TPtr xp;

	if (vp == NULL)
		return;

	AALLOC_THREAD_ENTER(ap)

	/* validate allocation and backpointer, ignore rogues */
	if ((rp = check_ptr(vp, ap, &bp, &xp, "afree", ", ignoring")) == NULL)
		goto afree_done;

	/* note: the block allocation does not ever shrink */
	bp->last -= PVALIGN;	/* mark the last forward pointer as free */
	/* if our forward pointer was not the last one, relocate the latter */
	if (xp.cp < bp->last) {
		TCooked *tmp = *((TCooked **)bp->last);

		(void)stcook(*tmp, xp, bp->bcookie);	/* write new backptr */
		memcpy(xp.cp, bp->last, PVALIGN);	/* relocate fwd ptr */
	}
	rp->xv = 0;	/* our backpointer, just in case, for double frees */
	free(rp);

	AALLOC_DENY(bp);
 afree_done:
	AALLOC_THREAD_LEAVE(ap)
	return;
}
@


1.31
log
@rewrite the cookie logic… while this is better than previously,
we still have issues:

(gdb) r
Starting program: /usr/obj/bin/mksh/mksh -c print\ \$KSH_VERSION
mksh in free(): error: modified (chunk-) pointer

Program received signal SIGABRT, Aborted.
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.30 2008/11/15 09:05:29 tg Exp $");
@


1.31.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.31 2008/11/15 11:42:18 tg Exp $");
@


1.30
log
@typo
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.29 2008/11/15 08:52:00 tg Exp $");
d69 3
d78 1
d85 3
d90 2
a91 2
	TCookie iv;
	char *pv;
d94 14
d121 3
a123 1
	TCookie cookie;
d131 1
a131 1
	TPtr bp;
d133 4
a136 2
	TPtr prev;
	TCookie ocookie;
d146 1
a146 6
static TCookie global_cookie;
#ifdef AALLOC_NO_COOKIES
#define gcookie 0
#else
#define gcookie global_cookie
#endif
d187 1
a187 1
	if ((ptrdiff_t)(dest) & PVMASK)					\
d206 2
a207 1
static TPtr *check_ptr(void *, PArea, PBlock *, const char *, const char *);
d218 1
d235 3
a237 2
	if (sizeof (TPtr) != sizeof (TCookie) || sizeof (TPtr) != PVALIGN)
		AALLOC_ABORT("TPtr sizes do not match: %lu, %lu, %lu",
d239 2
a240 1
		    (unsigned long)sizeof (TCookie), (unsigned long)PVALIGN);
d250 5
a254 2
	if (!global_cookie) {
		size_t v;
d258 4
a261 3
			global_cookie = AALLOC_RANDOM();
			v = AALLOC_RANDOM() & 7;
		} while (!(global_cookie & PVMASK) || !v);
d265 1
d278 1
a278 3
#ifdef AALLOC_NO_COOKIES
	bp->cookie = 0;
#else
d280 2
a281 2
		bp->cookie = AALLOC_RANDOM();
	} while (!(bp->cookie & PVMASK));
d285 1
a285 1
	bp->endp = (char *)bp + AALLOC_INITSZ;	/* bp + size of the block */
d289 1
a289 2
	ap->bp.pv = (char *)bp;
	ap->bp.iv ^= gcookie;
d291 4
a294 3
	ap->prev.pv = (char *)track;
	ap->prev.iv ^= gcookie;
	ap->ocookie = bp->cookie ^ gcookie;
d313 1
a313 1
check_bp(PArea ap, const char *funcname, TCookie ocookie)
d318 3
a320 1
	if (ap->bp.pv == NULL
d328 1
a328 2
	p.iv = ap->bp.iv ^ gcookie;
	if ((ptrdiff_t)(bp = (PBlock)p.pv) & PVMASK) {
d330 1
a330 1
		    funcname, ap, p.pv);
d333 2
d336 1
d342 3
a344 1
	if (((ptrdiff_t)bp->endp & PVMASK) || ((ptrdiff_t)bp->last & PVMASK)) {
d360 1
a372 1
	TPtr lp;
d374 2
d378 6
a383 2
	while (track) {
		tp = track;
d389 1
a389 7
			goto track_next;
#endif
		tp->ocookie ^= gcookie;
		lp.iv = tp->prev.iv ^ gcookie;
		if ((lp.iv & PVMASK)
#ifndef AALLOC_NO_COOKIES
		    || !(tp->ocookie & PVMASK)
d391 1
a391 1
		    ) {
d394 1
a394 2
			    " %p, %p, %p; exiting", tp, lp.pv, tp->bp.pv,
			    (void *)tp->ocookie);
d397 2
a398 2
		if (!(bp = check_bp(tp, "atexit:track_check", tp->ocookie)))
			goto track_next;
d409 1
a409 2
 track_next:
		track = (PArea)lp.pv;
d411 1
d421 1
a421 1
	TPtr *cp;
d425 9
a433 8
		cp = *((void **)bp->last);
		cp->iv ^= bp->cookie;
		if (always_warn || cp->pv != bp->last)
		AALLOC_WARN("leaking %s pointer %p in area %p (%p %lu) %s",
		    cp->pv == bp->last ? "valid" : "underflown",
		    (char *)cp + PVALIGN, ap, bp,
		    (unsigned long)(bp->endp - (char *)bp), when);
		free(cp);
d440 2
a441 1
#ifdef AALLOC_TRACK
d443 2
a444 1
	TPtr lp;
a445 1
	PBlock bp;
d456 2
a457 1
#ifdef AALLOC_TRACK
d459 6
a464 2
		(*pap)->prev.iv ^= gcookie;
		track = (PArea)((*pap)->prev.pv);
a469 2
		lp.iv = tp->prev.iv ^ gcookie;
		if ((lp.iv & PVMASK)
d471 1
a471 1
		    || !((tp->ocookie ^ gcookie) & PVMASK)
d473 2
a474 1
		    ) {
d477 1
a477 2
			    " %p, %p, %p; exiting", tp, lp.pv, tp->bp.pv,
			    (void *)(tp->ocookie ^ gcookie));
d481 1
a481 1
		if (lp.pv == (char *)*pap)
d483 1
a483 1
		tp = (PArea)lp.pv;
d486 1
a486 1
		tp->prev.iv = (*pap)->prev.iv;	/* decouple *pap */
d493 3
d497 1
d505 2
a506 1
	TPtr *ptr;
d510 1
a510 1
	safe_malloc(ptr, size);
d518 1
a518 1
		TPtr **tp;
d529 4
a532 3
		for (tp = (TPtr **)&bp->storage; tp < (TPtr **)bp->last; ++tp) {
			(*tp)->pv = (char *)tp;
			(*tp)->iv ^= bp->cookie;
d536 1
a536 2
		ap->bp.pv = (char *)bp;
		ap->bp.iv ^= gcookie;
d538 3
a540 3
	*((void **)bp->last) = ptr;	/* next available forward ptr */
	ptr->pv = bp->last;		/* backpointer to fwdptr storage */
	ptr->iv ^= bp->cookie;		/* apply block cookie */
d556 1
a556 1
	return ((char *)ptr + PVALIGN);
d563 2
a564 1
	TPtr *ptr;
d572 1
a572 1
	if ((ptr = check_ptr(vp, ap, &bp, "aresize", "")) == NULL)
d577 1
a577 1
	safe_realloc(ptr, size);
d580 2
a581 3
	memcpy(ptr->pv, &ptr, PVALIGN);
	/* apply the cookie on the backpointer again */
	ptr->iv ^= bp->cookie;
d585 1
a585 1
	return ((char *)ptr + PVALIGN);
d592 2
a593 2
 * Otherwise, returns address of the allocation, with the cookie on the
 * backpointer unapplied; *bpp contains the unlocked block pointer.
d595 3
a597 2
static TPtr *
check_ptr(void *vp, PArea ap, PBlock *bpp, const char *what, const char *extra)
d599 1
a599 2
	PBlock bp;
	TPtr *ptr;
d601 2
a602 1
	if ((ptrdiff_t)vp & PVMASK) {
d607 1
d609 3
a611 2
	ptr = (TPtr *)((char *)vp - PVALIGN);
	if (!ptr->iv) {
d616 1
d618 1
a618 1
	if ((bp = check_bp(ap, what, 0)) == NULL)
d620 7
a626 2
	ptr->iv ^= bp->cookie;
	if (ptr->pv < (char *)&bp->storage || ptr->pv >= bp->last) {
d629 2
a630 5
		    what + 1, vp, ap, bp, bp->last, ptr->pv, extra);
		AALLOC_DENY(bp);
		return (NULL);
	}
	if (*((void **)ptr->pv) != ptr) {
d633 11
a643 7
		    "%p instead%s", what + 1, vp, ap, bp, bp->last,
		    ptr->pv, *((void **)ptr->pv), extra);
		AALLOC_DENY(bp);
		return (NULL);
	}
	*bpp = bp;
	return (ptr);
d650 2
a651 1
	TPtr *ptr;
d659 1
a659 1
	if ((ptr = check_ptr(vp, ap, &bp, "afree", ", ignoring")) == NULL)
d665 2
a666 6
	if (ptr->pv < bp->last) {
		TPtr *tmp = *((TPtr **)bp->last);

		/* tmp is the former last forward pointer */
		tmp->pv = ptr->pv;	/* its backpointer to former our … */
		tmp->iv ^= bp->cookie;	/* … forward pointer, and cookie it */
d668 2
a669 1
		memcpy(ptr->pv, bp->last, PVALIGN);	/* relocate fwd ptr */
d671 2
a672 2
	ptr->iv = 0;	/* our backpointer, just in case, for double frees */
	free(ptr);
@


1.29
log
@meet AALLOC_STATS
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.28 2008/11/15 07:59:46 tg Exp $");
d68 3
a70 3
#undef AALLOC_TRACE
#elif defined(AALLOC_STATS) && !defined(AALLOC_TRACE)
#define AALLOC_TRACE
@


1.28
log
@thread-safety in the atexit function, justin case
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.27 2008/11/15 07:51:53 tg Exp $");
d7 22
d42 1
d44 1
d54 7
a60 2
#ifdef DEBUG
#define AALLOC_DEBUG
d65 8
d112 6
d189 3
d193 1
d268 6
d291 5
a295 1
	if (ap->bp.pv == NULL) {
d345 7
d500 10
@


1.27
log
@add plugs for thread-safety, requested by Jonathan Schleifer

example:
#define AALLOC_THREAD_ENTER(ap)	@@synchronized(aalloc_guard) {
#define AALLOC_THREAD_LEAVE(ap)	}

notes:
• you must declare and define eventual guard objects yourself
• while there will not be any direct “return” calls inside the
  locked area, AALLOC_ABORT and AALLOC_WARN may be called
• AALLOC_RANDOM does not need to be thread-safe, but malloc
  and free should be; if “ap” is used for locking, all functions
  called must be thread-safe though
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.26 2008/11/15 07:35:23 tg Exp $");
d285 1
d299 1
a299 1
			return;
d317 2
@


1.26
log
@enable passing of a hint how many pointers we’ll need to anew()
if 0, the default is used
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.25 2008/11/12 23:34:02 tg Exp $");
d15 5
d151 2
d224 1
d346 2
d388 1
d403 2
d434 1
d449 2
d464 1
d526 2
d530 1
a530 1
		return;
d548 2
@


1.25
log
@make silently leaking a define for better integration into other programmes
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.24 2008/11/12 19:23:09 tg Exp $");
d141 1
a141 1
anew(void)
d167 3
d188 4
d193 1
a193 1
	safe_malloc(bp, AALLOC_INITSZ);
@


1.24
log
@it is, apparently, not portably guaranteed that realloc can deal with NULL
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.23 2008/11/12 07:36:19 tg Exp $");
d15 2
d288 1
a288 1
#ifdef MKSH_VERSION	/* allowed to leak silently */
@


1.23
log
@leave at least a working tree, with zero-penalty -DAALLOC_NO_COOKIES
XXX cookies are still broken?

cost for aalloc.c: data -= (4, 0, 4, 0); text += (1665, ?, 2115, 2217)
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.22 2008/11/12 07:02:47 tg Exp $");
d105 4
d110 5
a114 1
	if (((dest) = realloc((dest), (len))) == NULL)			\
d183 2
a184 2
	ap = NULL; safe_realloc(ap, sizeof (struct TArea));
	bp = NULL; safe_realloc(bp, AALLOC_INITSZ);
d381 1
a381 1
	ptr = NULL; safe_realloc(ptr, size);
@


1.22
log
@fix the cookie checks
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.21 2008/11/12 06:58:49 tg Exp $");
d71 1
a71 1
static TCookie gcookie;
d73 3
a75 1
static TCookie fake_cookie;
d159 1
a159 4
#ifdef AALLOC_NO_COOKIES
#define gcookie fake_cookie
#endif
	if (!gcookie) {
d164 1
a164 1
			gcookie = AALLOC_RANDOM();
d166 1
a166 1
		} while (!(gcookie & PVMASK) || !v);
a173 1
#undef gcookie
d256 2
a257 1
	PArea ap;
d261 8
a268 4
		ap = track;
		ap->ocookie ^= gcookie;
		ap->prev.iv ^= gcookie;
		if ((ap->prev.iv & PVMASK) || (ap->ocookie & PVMASK)) {
d271 2
a272 2
			    " %p, %p, %p; exiting", ap, ap->prev.pv,
			    ap->bp.pv, (void *)ap->ocookie);
d275 1
a275 1
		if (!(bp = check_bp(ap, "atexit:track_check", ap->ocookie)))
d279 1
a279 1
			adelete_leak(ap, bp, false, "at exit");
d281 1
a281 1
			adelete_leak(ap, bp, true, "at exit");
d283 1
a283 1
			AALLOC_WARN("leaking empty area %p (%p %lu)", ap,
d288 2
a289 2
		track = (PArea)ap->prev.pv;
		free(ap);
d317 1
a336 1
		TPtr lp;
d338 6
a343 1
		if ((lp.iv & PVMASK) || (tp->ocookie & PVMASK)) {
d345 2
a346 2
			    " %p, %p, %p", tp, tp->prev.pv, tp->bp.pv,
			    (void *)tp->ocookie);
@


1.21
log
@same fuckup as in commitid 100491A793F1CA8D9CA, different place
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.20 2008/11/12 06:44:04 tg Exp $");
d265 1
a265 5
		if ((ap->prev.iv & PVMASK)
#ifndef AALLOC_NO_COOKIES
		    || !(ap->ocookie & PVMASK)
#endif
		    ) {
d335 1
a335 5
		if ((lp.iv & PVMASK)
#ifndef AALLOC_NO_COOKIES
		    || !(tp->ocookie & PVMASK)
#endif
		    ) {
@


1.20
log
@more silently
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.19 2008/11/12 06:42:22 tg Exp $");
d379 1
a379 1
		TPtr *tp;
d390 3
a392 3
		for (tp = (TPtr *)&bp->storage; tp < (TPtr *)bp->last; ++tp) {
			tp->pv = (char *)tp;
			tp->iv ^= bp->cookie;
@


1.19
log
@allow mksh to leak silently
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.18 2008/11/12 06:38:08 tg Exp $");
d278 1
a278 4
		if (bp->last == (char *)&bp->storage) {
			AALLOC_WARN("leaking empty area %p (%p %lu)", ap,
			    bp, (unsigned long)(bp->endp - (char *)bp));
		} else
d283 3
@


1.18
log
@adelete is supposed to be quiet on valid pointers
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.17 2008/11/12 06:35:27 tg Exp $");
d282 3
d286 1
@


1.17
log
@fix up the fuckage in afree()
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.16 2008/11/12 06:14:26 tg Exp $");
d124 1
a124 1
static void adelete_leak(PArea, PBlock, const char *);
d282 1
a282 1
			adelete_leak(ap, bp, "at exit");
d292 1
a292 1
adelete_leak(PArea ap, PBlock bp, const char *when)
d300 1
d320 1
a320 1
			adelete_leak(*pap, bp, "in adelete");
@


1.16
log
@improve error reporting
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.15 2008/11/12 06:12:56 tg Exp $");
d495 1
a495 1
		TPtr *tmp;
d497 1
a497 1
		tmp = (TPtr *)bp->last;	/* former last forward pointer */
@


1.15
log
@mergo
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.14 2008/11/12 06:10:51 tg Exp $");
d124 1
a124 1
static void adelete_leak(PArea, PBlock);
d282 1
a282 1
			adelete_leak(ap, bp);
d292 1
a292 1
adelete_leak(PArea ap, PBlock bp)
d300 1
a300 1
		AALLOC_WARN("leaking %s pointer %p in area %p (%p %lu)",
d303 1
a303 1
		    (unsigned long)(bp->endp - (char *)bp));
d319 1
a319 1
			adelete_leak(*pap, bp);
@


1.14
log
@more careful about disabling cookies
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.13 2008/11/12 06:05:54 tg Exp $");
d317 1
a317 1
	if ((bp = check_bp(*pap, "adelete", 0)) == NULL) {
@


1.13
log
@and fix another set of CPPFLAGS for debugging
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.12 2008/11/12 05:55:43 tg Exp $");
d72 3
a74 1
static TCookie gcookie_;
d157 4
a160 1
	if (!gcookie_) {
d165 1
a165 1
			gcookie_ = AALLOC_RANDOM();
d167 1
a167 1
		} while (!(gcookie_ & PVMASK) || !v);
d175 1
d180 1
d182 5
a186 3
//	do {
//		bp->cookie = AALLOC_RANDOM();
//	} while (!(bp->cookie & PVMASK));
d265 5
a269 1
		if ((ap->prev.iv & PVMASK) || !ap->ocookie) {
d334 5
a338 1
		if ((lp.iv & PVMASK) || !tp->ocookie) {
@


1.12
log
@no %t and %z specifiers in shf_vfprintf ☹ so use %p and %l instead
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.11 2008/11/12 05:46:45 tg Exp $");
d132 9
d149 1
a149 1
	if (AALLOC_INITSZ < sizeof (struct TBlock))
a154 8
#ifdef AALLOC_MPROTECT
	if (!pagesz) {
		if ((pagesz = sysconf(_SC_PAGESIZE)) == -1 || pagesz < PVALIGN)
			AALLOC_ABORT("sysconf(_SC_PAGESIZE) failed: %ld %s",
			    pagesz, strerror(errno));
	}
#endif

@


1.11
log
@forgot to charge for the extra size in the abstraction
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.10 2008/11/12 05:46:14 tg Exp $");
d82 1
a82 1
static size_t pagesz;
d103 2
a104 2
		AALLOC_ABORT("unable to allocate %zu bytes: %s",	\
		    (len), strerror(errno));				\
d113 2
a114 2
		AALLOC_ABORT("attempted integer overflow:"		\
		    " %zu * %zu", nmemb, size);				\
d117 2
a118 2
		AALLOC_ABORT("unable to allocate %zu bytes: %s",	\
		    size, "value plus extra too big");			\
d134 2
a135 1
		AALLOC_ABORT("PVALIGN not a power of two: %zu", PVALIGN);
d137 3
a139 2
		AALLOC_ABORT("TPtr sizes do not match: %zu, %zu, %zu",
		    sizeof (TPtr), sizeof (TCookie), PVALIGN);
d141 3
a143 2
		AALLOC_ABORT("AALLOC_INITSZ constant too small: %zu < %zu",
		    (size_t)AALLOC_INITSZ, sizeof (struct TBlock));
d148 2
a149 3
		if ((pagesz = sysconf(_SC_PAGESIZE)) == (size_t)-1 ||
		    pagesz < PVALIGN)
			AALLOC_ABORT("sysconf(_SC_PAGESIZE) failed: %zd %s",
d171 1
a171 1
	bp = NULL; safe_realloc(bp, (size_t)AALLOC_INITSZ);
d211 2
a212 2
		AALLOC_WARN("%s: area %p block pointer destroyed: %08tX",
		    funcname, ap, p.iv);
d217 2
a218 2
		AALLOC_WARN("%s: block %p cookie destroyed: %08tX, %08tX",
		    funcname, bp, ocookie, bp->cookie);
d258 2
a259 2
			    " %p, %08tX, %08tX", ap, ap->prev.pv,
			    ap->bp.iv, ap->ocookie);
d265 2
a266 2
			AALLOC_WARN("leaking empty area %p (%p %tu)", ap,
			    bp, bp->endp - (char *)bp);
d286 1
a286 1
		AALLOC_WARN("leaking %s pointer %p in area %p (%p %tu)",
d288 2
a289 1
		    (char *)cp + PVALIGN, ap, bp, bp->endp - (char *)bp);
d322 2
a323 2
			    " %p, %08tX, %08tX", tp, tp->prev.pv,
			    tp->bp.iv, tp->ocookie);
d361 1
a361 1
		safe_muladd((size_t)2, bsz, 0);
@


1.10
log
@raise AALLOC_INITSZ to be less expensive
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.9 2008/11/12 05:45:28 tg Exp $");
d119 1
@


1.9
log
@if the address of bp changes, all backpointers must be adjusted as well ☹
pretty expensive
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.8 2008/11/12 05:40:23 tg Exp $");
d33 1
a33 1
#define AALLOC_INITSZ		64	/* must hold at least 4 pointers */
@


1.8
log
@temporarily disable cookies for debugging
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.7 2008/11/12 05:34:20 tg Exp $");
d352 1
d362 6
@


1.7
log
@with other combinations too
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.6 2008/11/12 05:32:34 tg Exp $");
d72 1
d151 1
a151 1
	if (!gcookie) {
d156 1
a156 1
			gcookie = AALLOC_RANDOM();
d158 1
a158 1
		} while (!(gcookie & PVMASK) || !v);
d170 4
a173 3
	do {
		bp->cookie = AALLOC_RANDOM();
	} while (!(bp->cookie & PVMASK));
@


1.6
log
@get the debugging methods to build
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.5 2008/11/12 05:27:01 tg Exp $");
d138 1
a138 1
		    AALLOC_INITSZ, sizeof (struct TBlock));
@


1.5
log
@• bp->last == bp->endp is allowed
• do the realloc properly
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.4 2008/11/12 05:11:05 tg Exp $");
d82 6
a87 7
#define AALLOC_ACCESS(bp, n, p)	mprotect((bp), (bp)->endp - (bp), (p))
#define AALLOC_ALLOW(bp)	\
	AALLOC_ACCESS((bp), (bp)->endp - (bp), PROT_READ | PROT_WRITE);
#define AALLOC_DENY(bp)		\
	AALLOC_ACCESS((bp), (bp)->endp - (bp), PROT_NONE)
#define AALLOC_PEEK(bp)		\
	AALLOC_ACCESS((bp), sizeof (struct TArea), PROT_READ | PROT_WRITE)
d181 2
a182 2
	ap->prev.pv = track;
	ap->prev.iv ^= track_cookie;
d248 2
a249 2
		ap->ocookie ^= track_cookie;
		ap->prev.iv ^= track_cookie;
d253 1
a253 1
			    " %p, %08X, %08X", ap, ap->prev.pv,
d257 1
a257 1
		if (!(bp = check_bp(ap, "atexit:track_check", tp->ocookie)))
d259 1
a259 1
		if (bp->last == &bp->storage) {
d261 1
a261 1
			    bp, bp->endp - bp);
d266 1
a266 1
		track = ap->prev.pv;
d306 1
a306 1
		track = (*pap)->prev.pv;
d314 1
a314 1
		if ((lp.iv & PVMASK) || !lp->ocookie) {
d316 1
a316 1
			    " %p, %08X, %08X", tp, tp->prev.pv,
d321 1
a321 1
		if (lp.pv == *pap)
d323 1
a323 1
		tp = lp.pv;
@


1.4
log
@__CRAZY cleanliness: pointer arithmetic
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.3 2008/11/12 05:05:17 tg Exp $");
d227 1
a227 1
	if ((bp->last < (char *)&bp->storage) || (bp->last >= bp->endp)) {
d357 2
@


1.3
log
@this one I could have seen by myself if not for the late time of the day
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.2 2008/11/12 04:59:42 tg Exp $");
d40 1
a40 1
	void *pv;
d57 2
a58 2
	void *endp;
	void *last;
d175 1
a175 1
	bp->endp = bp + AALLOC_INITSZ;		/* bp + size of the block */
d177 1
a177 1
	bp->last = &bp->storage;		/* first entry */
d179 1
a179 1
	ap->bp.pv = bp;
d206 1
a206 1
	if ((ptrdiff_t)(bp = p.pv) & PVMASK) {
d222 1
a222 1
	if (bp->endp < (void *)bp) {
d227 1
a227 1
	if ((bp->last < (void *)&bp->storage) || (bp->last >= bp->endp)) {
d278 1
a278 1
	while (bp->last > (void *)&bp->storage) {
d284 1
a284 1
		    (char *)cp + PVALIGN, ap, bp, bp->endp - (void *)bp);
d299 1
a299 1
		if (bp->last != &bp->storage)
d354 1
a354 1
		bsz = bp->endp - (void *)bp;
d359 1
a359 1
		ap->bp.pv = bp;
d427 1
a427 1
	if (ptr->pv < (void *)&bp->storage || ptr->pv >= bp->last) {
d463 1
a463 1
		TPtr *tmp = bp->last;	/* former last forward pointer */
d465 1
@


1.2
log
@fix first batch of compile warnings, enable aalloc for mirbsd
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/aalloc.c,v 1.1 2008/11/12 04:55:17 tg Exp $");
d121 1
d263 2
a264 14
			goto track_freebp;
		}
		while (bp->last > &bp->storage) {
			TPtr *cp;

			bp->last -= PVALIGN;
			cp = *((void **)bp->last);
			cp->iv ^= bp->cookie;
			AALLOC_WARN("leaking %s pointer %p in area %p (%p %tu)",
			    cp->pv == bp->last ? "valid" : "underflown",
			    (char *)cp + PVALIGN, ap, bp, bp->endp - bp);
			free(cp);
		}
 track_freebp:
d273 16
d297 6
a302 2
	if ((bp = check_bp(*pap, "adelete", 0)) == NULL)
		goto adelete_freeap;	/* ignore invalid areas */
a303 4
	if (bp->last != &bp->storage)
		adelete_leak(bp);
	free(bp);
 adelete_freeap:
@


1.1
log
@prepare for aalloc.c, which I have just written myself, as an area-based
allocator using malloc and free, with mmap malloc and omalloc in mind,
not counterfeiting its security measures such as guard pages, and having
some of our own, e.g. XOR random cookies, optional mprotect, etc.

zero cost (for we have arc4random())
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/share/misc/licence.template,v 1.26 2008/07/07 13:28:40 tg Rel $");
d105 1
a105 1
	if ((dest) & PVMASK)						\
d167 1
a167 1
	bp = NULL; safe_realloc(bp, AALLOC_INITSZ);
d205 2
a206 2
	if ((bp = p.pv) & PVMASK) {
		AALLOC_WARN("%s: area %p block pointer destroyed: %08X",
d212 1
a212 1
		AALLOC_WARN("%s: block %p cookie destroyed: %08X, %08X",
d216 1
a216 1
	if ((bp->endp & PVMASK) || (bp->last & PVMASK)) {
d221 1
a221 1
	if (bp->endp < bp) {
d226 1
a226 1
	if ((bp->last < &bp->storage) || (bp->last >= bp->endp)) {
d349 2
a350 2
		bsz = bp->endp - bp;
		safe_muladd(2, bsz, 0);
d406 1
a406 1
	if (vp & PVMASK) {
d422 1
a422 1
	if (ptr->pv < &bp->storage || ptr->pv >= bp->last) {
@

