head	1.217;
access;
symbols
	mksh-R57:1.206
	mksh-R56c:1.201
	mksh-R56b:1.199
	mksh-R56:1.199
	mksh-R55:1.196
	mksh-R54:1.186
	mksh-R53a:1.179
	mksh-R53:1.179
	mksh-R52c:1.172
	mksh-R52b:1.170
	mksh-R52:1.168
	mksh-R51:1.160
	mksh-R50f:1.137.2.4
	mksh-R50e:1.137.2.2
	mksh-R50stable:1.137.0.2
	mksh-R50d:1.133
	mksh-R50c:1.133
	mksh-R50b:1.132
	mksh-R50:1.132
	mksh-R49:1.129
	mksh-R48b:1.125
	mksh-R48:1.125
	mksh-R47:1.125
	mksh-R46:1.120
	mksh-R45:1.120
	mksh-R44:1.116
	mksh-R43:1.116
	mksh-R42b:1.115
	mksh-R41c:1.106.2.7
	mksh-R41b:1.106.2.6
	mksh-R42:1.114
	mksh-R41:1.106
	mksh-R41stable:1.106.0.2
	mksh-wheezy:1.99.0.2
	tg-multikey-bind:1.98.0.2
	mksh-R40f:1.97
	mksh-R40e:1.96
	mksh-R40d:1.96
	mksh-R40c:1.96
	mksh-R40b:1.94
	mksh-R40stable:1.97.0.2
	mksh-R40:1.92
	mksh-R39c:1.72
	mksh-R39b:1.72
	tg-wcswidth-behaviour:1.68.0.2
	tg-nameref:1.64.0.2
	mksh-R39:1.59
	tg-mksh-printf-builtin:1.59.0.2
	mksh-R38c:1.58
	mksh-R38b:1.56
	mksh-R38:1.56
	mksh-R37c:1.54
	mksh-R37b:1.53
	mksh-R37:1.53
	mksh-R36b:1.48
	tg-aalloc-experimental_BASE:1.47
	tg-aalloc-experimental:1.47.0.2
	mksh-R36:1.44
	mksh-R35b:1.44
	mksh-R35:1.44
	mksh-R33d:1.41
	mksh-R33c:1.41
	mksh-R33b:1.39
	MIRBSD_10:1.39.0.2
	MIRBSD_10_BASE:1.39
	mksh-R33:1.39
	mksh-R32:1.39
	mksh-R31d:1.38
	mksh-R31c:1.38
	mksh-R31b:1.38
	mksh-R31:1.37
	mksh-R30:1.37
	mksh-R29g:1.29.2.2
	mksh-R29f:1.29.2.1
	mksh-R29e:1.29.2.1
	mksh-R29stable:1.29.0.2
	mksh-R29d:1.29
	mksh-R29c:1.29
	mksh-R29b:1.26
	mksh-R29:1.26
	mksh-R28:1.16
	tg-mksh-plan9ape_BASE:1.16
	tg-mksh-plan9ape:1.16.0.2
	mksh-R27e:1.15
	MIRBSD_9_BASE:1.15
	mksh-R27d:1.15
	mksh-R27:1.15
	mksh-R26c:1.13
	mksh-R26b:1.12
	MIRBSD_8:1.12.0.2
	MIRBSD_8_BASE:1.12
	mksh-R26:1.12
	mksh-R25:1.10
	mksh-R24c:1.8
	mksh-R24b:1.8
	mksh-R24:1.8
	mksh-R23:1.5
	mksh-R22:1.5
	mksh-R21:1.2;
locks; strict;
comment	@ * @;


1.217
date	2019.12.30.04.18.50;	author tg;	state Exp;
branches;
next	1.216;
commitid	1005E097AAE107DC225;

1.216
date	2019.12.30.03.45.12;	author tg;	state Exp;
branches;
next	1.215;
commitid	1005E0972CA305775E7;

1.215
date	2019.12.30.01.29.52;	author tg;	state Exp;
branches;
next	1.214;
commitid	1005E09532721D23AB7;

1.214
date	2019.12.30.01.18.22;	author tg;	state Exp;
branches;
next	1.213;
commitid	1005E0950692C5D1944;

1.213
date	2019.12.30.01.15.56;	author tg;	state Exp;
branches;
next	1.212;
commitid	1005E094FE436511ED6;

1.212
date	2019.12.30.01.10.56;	author tg;	state Exp;
branches;
next	1.211;
commitid	1005E094E9A55F97D93;

1.211
date	2019.12.11.23.58.18;	author tg;	state Exp;
branches;
next	1.210;
commitid	1005DF182AD50645981;

1.210
date	2019.08.02.19.27.15;	author tg;	state Exp;
branches;
next	1.209;
commitid	1005D448E820CFAF8FF;

1.209
date	2019.08.01.23.59.49;	author tg;	state Exp;
branches;
next	1.208;
commitid	1005D437D0C19D901EA;

1.208
date	2019.08.01.22.45.56;	author tg;	state Exp;
branches;
next	1.207;
commitid	1005D436B8A74995C84;

1.207
date	2019.08.01.22.20.53;	author tg;	state Exp;
branches;
next	1.206;
commitid	1005D43659C51683F4E;

1.206
date	2019.03.01.16.17.53;	author tg;	state Exp;
branches;
next	1.205;
commitid	1005C795B3C0A386909;

1.205
date	2019.01.05.12.47.40;	author tg;	state Exp;
branches;
next	1.204;
commitid	1005C30A75304FC7434;

1.204
date	2018.12.04.21.13.47;	author tg;	state Exp;
branches;
next	1.203;
commitid	1005C06EDFD15FD4F82;

1.203
date	2018.10.30.17.10.14;	author tg;	state Exp;
branches;
next	1.202;
commitid	1005BD8907D11D25921;

1.202
date	2018.10.07.01.10.11;	author tg;	state Exp;
branches;
next	1.201;
commitid	1005BB95CA10BF418E8;

1.201
date	2017.10.11.21.09.24;	author tg;	state Exp;
branches;
next	1.200;
commitid	10059DE887042D9CAC0;

1.200
date	2017.10.11.21.04.59;	author tg;	state Exp;
branches;
next	1.199;
commitid	10059DE877774D49E5E;

1.199
date	2017.08.07.21.16.31;	author tg;	state Exp;
branches;
next	1.198;
commitid	1005988D8C64668C04F;

1.198
date	2017.04.29.22.04.28;	author tg;	state Exp;
branches;
next	1.197;
commitid	10059050DFF02CF9B3E;

1.197
date	2017.04.28.00.38.29;	author tg;	state Exp;
branches;
next	1.196;
commitid	10059028F0E0808B3E9;

1.196
date	2017.04.12.16.46.21;	author tg;	state Exp;
branches;
next	1.195;
commitid	10058EE59ED44DAA3D5;

1.195
date	2017.04.08.01.07.15;	author tg;	state Exp;
branches;
next	1.194;
commitid	10058E837C565871E52;

1.194
date	2017.04.02.15.02.40;	author tg;	state Exp;
branches;
next	1.193;
commitid	10058E1129E00F9DCEB;

1.193
date	2017.04.02.15.00.42;	author tg;	state Exp;
branches;
next	1.192;
commitid	10058E1121E64BBAB7B;

1.192
date	2017.04.02.13.08.06;	author tg;	state Exp;
branches;
next	1.191;
commitid	10058E0F79F196EC7B8;

1.191
date	2017.03.22.00.20.51;	author tg;	state Exp;
branches;
next	1.190;
commitid	10058D1C37D4ECF5C13;

1.190
date	2017.03.12.02.04.12;	author tg;	state Exp;
branches;
next	1.189;
commitid	10058C4AC2520F8C875;

1.189
date	2017.03.11.23.22.34;	author tg;	state Exp;
branches;
next	1.188;
commitid	10058C486CF5C28D59E;

1.188
date	2017.03.11.22.58.51;	author tg;	state Exp;
branches;
next	1.187;
commitid	10058C4813B00114587;

1.187
date	2016.11.12.03.54.48;	author tg;	state Exp;
branches;
next	1.186;
commitid	100582692904AD1579B;

1.186
date	2016.11.11.23.31.34;	author tg;	state Exp;
branches;
next	1.185;
commitid	100582654B972655F84;

1.185
date	2016.11.11.21.13.23;	author tg;	state Exp;
branches;
next	1.184;
commitid	1005826347D6811313F;

1.184
date	2016.11.11.20.14.17;	author tg;	state Exp;
branches;
next	1.183;
commitid	100582626A23DD889A9;

1.183
date	2016.11.11.19.59.39;	author tg;	state Exp;
branches;
next	1.182;
commitid	1005826231A4E1347A4;

1.182
date	2016.10.02.22.21.46;	author tg;	state Exp;
branches;
next	1.181;
commitid	10057F1888F65CBF445;

1.181
date	2016.09.01.12.59.09;	author tg;	state Exp;
branches;
next	1.180;
commitid	10057C8260A04757349;

1.180
date	2016.08.24.20.40.00;	author tg;	state Exp;
branches;
next	1.179;
commitid	10057BE062C465118E3;

1.179
date	2016.08.01.21.38.02;	author tg;	state Exp;
branches;
next	1.178;
commitid	100579FC12F14735847;

1.178
date	2016.07.25.00.04.41;	author tg;	state Exp;
branches;
next	1.177;
commitid	1005795579F14A3FE5C;

1.177
date	2016.07.24.23.10.02;	author tg;	state Exp;
branches;
next	1.176;
commitid	10057954AD0356E0260;

1.176
date	2016.07.24.23.07.19;	author tg;	state Exp;
branches;
next	1.175;
commitid	10057954A3B63F8859D;

1.175
date	2016.06.26.00.44.58;	author tg;	state Exp;
branches;
next	1.174;
commitid	100576F259765932F2C;

1.174
date	2016.06.26.00.09.35;	author tg;	state Exp;
branches;
next	1.173;
commitid	100576F1D4100EFF065;

1.173
date	2016.04.09.16.41.07;	author tg;	state Exp;
branches;
next	1.172;
commitid	100570930AF79FA5BEB;

1.172
date	2016.03.01.18.30.04;	author tg;	state Exp;
branches;
next	1.171;
commitid	10056D5DFC11D3566D1;

1.171
date	2016.01.21.18.24.39;	author tg;	state Exp;
branches;
next	1.170;
commitid	10056A12268001BF859;

1.170
date	2015.12.31.21.03.47;	author tg;	state Exp;
branches;
next	1.169;
commitid	100568598191D3EFE4F;

1.169
date	2015.12.31.12.58.43;	author tg;	state Exp;
branches;
next	1.168;
commitid	10056852690020D3ABD;

1.168
date	2015.10.09.21.36.55;	author tg;	state Exp;
branches;
next	1.167;
commitid	100561833456A230F8F;

1.167
date	2015.10.09.19.29.48;	author tg;	state Exp;
branches;
next	1.166;
commitid	100561815B853CF84EB;

1.166
date	2015.10.09.17.48.49;	author tg;	state Exp;
branches;
next	1.165;
commitid	1005617FE066005352E;

1.165
date	2015.10.09.16.11.14;	author tg;	state Exp;
branches;
next	1.164;
commitid	1005617E72E4A2BA371;

1.164
date	2015.10.09.15.28.20;	author tg;	state Exp;
branches;
next	1.163;
commitid	1005617DD2662BE4B02;

1.163
date	2015.09.06.19.46.59;	author tg;	state Exp;
branches;
next	1.162;
commitid	10055EC98215F2B5F9C;

1.162
date	2015.09.05.19.19.03;	author tg;	state Exp;
branches;
next	1.161;
commitid	10055EB402C54C3076B;

1.161
date	2015.09.05.17.20.18;	author tg;	state Exp;
branches;
next	1.160;
commitid	10055EB24573F1E0C48;

1.160
date	2015.07.10.19.36.35;	author tg;	state Exp;
branches;
next	1.159;
commitid	10055A01EBD784EE31A;

1.159
date	2015.07.09.20.52.38;	author tg;	state Exp;
branches;
next	1.158;
commitid	100559EDF161DEE9DD2;

1.158
date	2015.07.09.20.20.42;	author tg;	state Exp;
branches;
next	1.157;
commitid	100559ED7A80A374D9C;

1.157
date	2015.07.09.19.59.14;	author tg;	state Exp;
branches;
next	1.156;
commitid	100559ED2A65B6AF321;

1.156
date	2015.07.09.19.46.41;	author tg;	state Exp;
branches;
next	1.155;
commitid	100559ECFAC4F39D69B;

1.155
date	2015.07.06.17.48.31;	author tg;	state Exp;
branches;
next	1.154;
commitid	100559ABF230C8CC8EB;

1.154
date	2015.07.05.15.45.17;	author tg;	state Exp;
branches;
next	1.153;
commitid	100559951194B011855;

1.153
date	2015.07.05.14.43.05;	author tg;	state Exp;
branches;
next	1.152;
commitid	100559942841CED5205;

1.152
date	2015.04.29.18.32.43;	author tg;	state Exp;
branches;
next	1.151;
commitid	100554123E246E02963;

1.151
date	2015.04.19.14.40.08;	author tg;	state Exp;
branches;
next	1.150;
commitid	1005533BE52080CD0EC;

1.150
date	2015.04.19.14.23.26;	author tg;	state Exp;
branches;
next	1.149;
commitid	1005533BA6234EE262D;

1.149
date	2015.04.11.23.28.19;	author tg;	state Exp;
branches;
next	1.148;
commitid	1005529AD8D33CF99B9;

1.148
date	2015.04.11.22.03.29;	author tg;	state Exp;
branches;
next	1.147;
commitid	1005529999F77F915AE;

1.147
date	2015.03.20.23.37.54;	author tg;	state Exp;
branches;
next	1.146;
commitid	100550CAF6732AE1EA7;

1.146
date	2015.02.19.22.26.49;	author tg;	state Exp;
branches;
next	1.145;
commitid	10054E6631B44A55260;

1.145
date	2015.02.19.22.00.03;	author tg;	state Exp;
branches;
next	1.144;
commitid	10054E65CBD1E50DCD0;

1.144
date	2015.02.19.21.58.19;	author tg;	state Exp;
branches;
next	1.143;
commitid	10054E65C757D308908;

1.143
date	2015.02.06.10.56.46;	author tg;	state Exp;
branches;
next	1.142;
commitid	10054D49DF4344D0AFC;

1.142
date	2015.02.06.10.09.06;	author tg;	state Exp;
branches;
next	1.141;
commitid	10054D492CC303A2CB1;

1.141
date	2015.02.06.09.42.46;	author tg;	state Exp;
branches;
next	1.140;
commitid	10054D48CAD63D89A19;

1.140
date	2015.02.06.09.42.08;	author tg;	state Exp;
branches;
next	1.139;
commitid	10054D48C7F10831DFF;

1.139
date	2014.11.25.22.46.58;	author tg;	state Exp;
branches;
next	1.138;
commitid	100547506FA45A0AA5E;

1.138
date	2014.11.25.21.13.24;	author tg;	state Exp;
branches;
next	1.137;
commitid	1005474F00E09321C83;

1.137
date	2014.10.19.21.53.07;	author tg;	state Exp;
branches
	1.137.2.1;
next	1.136;
commitid	100544432BD7CEA2F06;

1.136
date	2014.10.12.21.58.50;	author tg;	state Exp;
branches;
next	1.135;
commitid	100543AF9780895A8EB;

1.135
date	2014.10.12.20.32.09;	author tg;	state Exp;
branches;
next	1.134;
commitid	100543AE54B1820AF46;

1.134
date	2014.10.12.19.55.00;	author tg;	state Exp;
branches;
next	1.133;
commitid	100543ADCA73754295B;

1.133
date	2014.10.03.17.32.11;	author tg;	state Exp;
branches;
next	1.132;
commitid	100542EDD596FD5FBF9;

1.132
date	2014.06.24.18.38.31;	author tg;	state Exp;
branches;
next	1.131;
commitid	10053A9C570753B33C6;

1.131
date	2014.06.10.22.17.08;	author tg;	state Exp;
branches;
next	1.130;
commitid	100539783DC1BABB2C6;

1.130
date	2014.05.27.13.22.43;	author tg;	state Exp;
branches;
next	1.129;
commitid	1005384911C31753F0C;

1.129
date	2014.01.11.16.26.27;	author tg;	state Exp;
branches;
next	1.128;
commitid	10052D170CC442C6ECB;

1.128
date	2014.01.05.21.57.25;	author tg;	state Exp;
branches;
next	1.127;
commitid	10052C9D445413B34DF;

1.127
date	2013.10.09.11.59.27;	author tg;	state Exp;
branches;
next	1.126;
commitid	10052554535524C4C97;

1.126
date	2013.09.10.16.30.49;	author tg;	state Exp;
branches;
next	1.125;
commitid	100522F49426994853D;

1.125
date	2013.07.21.20.44.44;	author tg;	state Exp;
branches;
next	1.124;
commitid	10051EC48553D9C6A05;

1.124
date	2013.07.21.18.47.18;	author tg;	state Exp;
branches;
next	1.123;
commitid	10051EC2CBD68BDF6A5;

1.123
date	2013.07.21.18.36.00;	author tg;	state Exp;
branches;
next	1.122;
commitid	10051EC29F9411252FA;

1.122
date	2013.06.03.22.28.31;	author tg;	state Exp;
branches;
next	1.121;
commitid	10051AD18A44752B56B;

1.121
date	2013.06.02.03.09.14;	author tg;	state Exp;
branches;
next	1.120;
commitid	10051AAB6AE4E828507;

1.120
date	2013.04.26.21.22.44;	author tg;	state Exp;
branches;
next	1.119;
commitid	100517AEF6C22DD1AE7;

1.119
date	2013.04.26.19.47.07;	author tg;	state Exp;
branches;
next	1.118;
commitid	100517AD9A775A68494;

1.118
date	2013.04.26.19.40.44;	author tg;	state Exp;
branches;
next	1.117;
commitid	100517AD85106670209;

1.117
date	2013.03.24.00.56.22;	author tg;	state Exp;
branches;
next	1.116;
commitid	100514E4F1D5C90862C;

1.116
date	2013.02.17.05.40.15;	author tg;	state Exp;
branches;
next	1.115;
commitid	10051206D50560C037D;

1.115
date	2013.02.15.18.50.13;	author tg;	state Exp;
branches;
next	1.114;
commitid	100511E837A3084211A;

1.114
date	2013.02.10.23.59.25;	author tg;	state Exp;
branches;
next	1.113;
commitid	100511834521EDC159D;

1.113
date	2013.01.19.19.47.10;	author tg;	state Exp;
branches;
next	1.112;
commitid	10050FAF850424A45DD;

1.112
date	2013.01.06.18.51.42;	author tg;	state Exp;
branches;
next	1.111;
commitid	10050E9C7D31AD0F470;

1.111
date	2013.01.01.20.45.02;	author tg;	state Exp;
branches;
next	1.110;
commitid	10050E34AE3215C257E;

1.110
date	2012.12.22.00.03.41;	author tg;	state Exp;
branches;
next	1.109;
commitid	10050D4F8C95001AF1D;

1.109
date	2012.12.17.23.18.03;	author tg;	state Exp;
branches;
next	1.108;
commitid	10050CFA81334F40D7F;

1.108
date	2012.12.04.01.18.27;	author tg;	state Exp;
branches;
next	1.107;
commitid	10050BD4F7642624FD1;

1.107
date	2012.11.30.20.19.11;	author tg;	state Exp;
branches;
next	1.106;
commitid	10050B914D41435E735;

1.106
date	2012.11.30.19.02.06;	author tg;	state Exp;
branches
	1.106.2.1;
next	1.105;
commitid	10050B902B82AAA0C3F;

1.105
date	2012.10.30.20.13.17;	author tg;	state Exp;
branches;
next	1.104;
commitid	100509034F50DD7C6D5;

1.104
date	2012.10.22.16.53.21;	author tg;	state Exp;
branches;
next	1.103;
commitid	10050857A0A617725BC;

1.103
date	2012.10.21.21.39.01;	author tg;	state Exp;
branches;
next	1.102;
commitid	10050846B5B2B1A2932;

1.102
date	2012.10.21.21.26.39;	author tg;	state Exp;
branches;
next	1.101;
commitid	1005084678C510CF7E4;

1.101
date	2012.10.03.17.24.18;	author tg;	state Exp;
branches;
next	1.100;
commitid	100506C74D35719B33B;

1.100
date	2012.10.03.15.13.30;	author tg;	state Exp;
branches;
next	1.99;
commitid	100506C56316A8B5F1D;

1.99
date	2012.06.24.20.05.23;	author tg;	state Exp;
branches
	1.99.2.1;
next	1.98;
commitid	1004FE772F31BB43597;

1.98
date	2012.04.14.16.07.46;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004F89A0D311D70891;

1.97
date	2012.03.31.17.29.58;	author tg;	state Exp;
branches;
next	1.96;
commitid	1004F773F2D0016E021;

1.96
date	2011.09.07.15.24.14;	author tg;	state Exp;
branches;
next	1.95;
commitid	1004E678C6929FE60A6;

1.95
date	2011.08.27.18.06.43;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004E5932432420AA61;

1.94
date	2011.07.07.21.24.52;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004E16241A43F1A588;

1.93
date	2011.07.05.20.12.17;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004E136FF75DBF04C7;

1.92
date	2011.05.29.02.18.51;	author tg;	state Exp;
branches;
next	1.91;
commitid	1004DE1AD11046BEFFC;

1.91
date	2011.05.07.00.51.11;	author tg;	state Exp;
branches;
next	1.90;
commitid	1004DC49710562ACCB2;

1.90
date	2011.04.17.15.40.35;	author tg;	state Exp;
branches;
next	1.89;
commitid	1004DAB0A0A4E6FEBD8;

1.89
date	2011.04.02.10.30.10;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004D96FAB20883B7FB;

1.88
date	2011.03.13.01.20.18;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004D7C1BE368F5B459;

1.87
date	2011.02.18.22.26.08;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004D5EF0ED2C0C9394;

1.86
date	2011.02.11.01.18.16;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004D548C4E66D17A12;

1.85
date	2011.01.30.01.35.33;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004D44C07439762D63;

1.84
date	2011.01.09.21.57.25;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004D2A2F086B2268F4;

1.83
date	2010.09.15.21.08.17;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004C9135BE7A0C39AD;

1.82
date	2010.09.14.21.26.11;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004C8FE654576B0E25;

1.81
date	2010.09.05.19.51.32;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004C83F4BE00D43672;

1.80
date	2010.08.28.20.22.17;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004C796FE40C544CCE;

1.79
date	2010.08.28.18.50.49;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004C795A82072326AF;

1.78
date	2010.08.28.17.21.43;	author tg;	state Exp;
branches;
next	1.77;
commitid	1004C7945A20EB8DDA4;

1.77
date	2010.08.28.15.48.18;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004C792FD945CE393C;

1.76
date	2010.08.28.15.39.18;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004C792DBD73FFB797;

1.75
date	2010.07.17.22.09.34;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004C42295452E71B6E;

1.74
date	2010.04.08.13.21.05;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004BBDD84556472D84;

1.73
date	2010.03.27.15.29.00;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004BAE244B09562919;

1.72
date	2009.12.12.22.27.06;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004B2418AF282F4231;

1.71
date	2009.12.05.17.43.46;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004B1A9BCF3E49BC5B;

1.70
date	2009.11.28.14.28.00;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004B11334F4604E973;

1.69
date	2009.11.28.14.21.43;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004B1131E93EDF1403;

1.68
date	2009.11.09.23.35.09;	author tg;	state Exp;
branches
	1.68.2.1;
next	1.67;
commitid	1004AF8A72F40172587;

1.67
date	2009.10.15.16.25.15;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004AD74CFB3CF8DBD8;

1.66
date	2009.10.02.18.08.32;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004AC641341D9D9D02;

1.65
date	2009.09.20.16.40.55;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004AB65AF3542D0922;

1.64
date	2009.08.28.20.30.55;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004A983E6B745731A0;

1.63
date	2009.08.28.19.57.40;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004A98365B7809CDA1;

1.62
date	2009.08.28.19.16.17;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004A982D155F910FC0;

1.61
date	2009.08.28.18.53.57;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004A9827D2091BAE42;

1.60
date	2009.08.08.13.08.49;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004A7D785D73D49CFA;

1.59
date	2009.06.11.12.42.17;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004A30FBB114E3FED9;

1.58
date	2009.06.10.18.12.45;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004A2FF7913BD44883;

1.57
date	2009.06.08.20.06.45;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004A2D6F3A31FB4CBC;

1.56
date	2009.05.16.18.40.05;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004A0F087409E93A5D;

1.55
date	2009.05.16.16.59.35;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004A0EF0664EF4168D;

1.54
date	2009.04.07.19.13.09;	author tg;	state Exp;
branches;
next	1.53;
commitid	10049DBA5DA72EF04C6;

1.53
date	2009.03.22.18.28.34;	author tg;	state Exp;
branches;
next	1.52;
commitid	10049C6834E4ED058A4;

1.52
date	2009.03.22.18.20.36;	author tg;	state Exp;
branches;
next	1.51;
commitid	10049C681890F5D1326;

1.51
date	2009.03.22.17.47.36;	author tg;	state Exp;
branches;
next	1.50;
commitid	10049C679C543D854C9;

1.50
date	2009.03.16.15.50.12;	author tg;	state Exp;
branches;
next	1.49;
commitid	10049BE751056775D85;

1.49
date	2009.03.16.15.14.23;	author tg;	state Exp;
branches;
next	1.48;
commitid	10049BE6CB22E3BA1BA;

1.48
date	2008.12.13.17.02.13;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004943EAA830C0300B;

1.47
date	2008.11.12.00.55.31;	author tg;	state Exp;
branches
	1.47.2.1;
next	1.46;
commitid	100491A299233238473;

1.46
date	2008.11.12.00.54.47;	author tg;	state Exp;
branches;
next	1.45;
commitid	100491A295841A6D8EB;

1.45
date	2008.10.28.14.32.39;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004907226D3DEFCCD1;

1.44
date	2008.05.17.18.46.58;	author tg;	state Exp;
branches;
next	1.43;
commitid	100482F280E7B53AA4C;

1.43
date	2008.04.19.22.15.02;	author tg;	state Exp;
branches;
next	1.42;
commitid	100480A6CC85EC0197B;

1.42
date	2008.04.19.17.21.53;	author tg;	state Exp;
branches;
next	1.41;
commitid	100480A2A2B32040FD7;

1.41
date	2008.04.01.22.20.18;	author tg;	state Exp;
branches;
next	1.40;
commitid	10047F2B5302C15B5C3;

1.40
date	2008.04.01.20.40.21;	author tg;	state Exp;
branches;
next	1.39;
commitid	10047F29D740D1FD5B8;

1.39
date	2007.10.25.13.27.00;	author tg;	state Exp;
branches
	1.39.2.1;
next	1.38;
commitid	100472099B90238AE38;

1.38
date	2007.09.09.18.06.40;	author tg;	state Exp;
branches;
next	1.37;
commitid	10046E436442CDF8871;

1.37
date	2007.07.24.11.22.04;	author tg;	state Exp;
branches;
next	1.36;
commitid	10046A5E0B320FF6D65;

1.36
date	2007.07.22.14.01.48;	author tg;	state Exp;
branches;
next	1.35;
commitid	10046A36344350ACD7B;

1.35
date	2007.07.22.13.38.26;	author tg;	state Exp;
branches;
next	1.34;
commitid	10046A35DE715FF102D;

1.34
date	2007.07.22.13.34.49;	author tg;	state Exp;
branches;
next	1.33;
commitid	10046A35CEC35BB7B5F;

1.33
date	2007.06.15.21.22.40;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004673031812053313;

1.32
date	2007.06.06.23.28.14;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004667430836D68E66;

1.31
date	2007.05.13.18.49.00;	author tg;	state Exp;
branches;
next	1.30;
commitid	10046475DAE4D3D3C05;

1.30
date	2007.05.13.17.51.21;	author tg;	state Exp;
branches;
next	1.29;
commitid	10046474FB1292DF336;

1.29
date	2007.04.18.00.59.20;	author tg;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	10046256D4C72A35219;

1.28
date	2007.04.17.21.26.34;	author tg;	state Exp;
branches;
next	1.27;
commitid	10046253BA07E09AABA;

1.27
date	2007.04.15.12.09.57;	author tg;	state Exp;
branches;
next	1.26;
commitid	100462215D23B394727;

1.26
date	2007.03.04.03.04.24;	author tg;	state Exp;
branches;
next	1.25;
commitid	10045EA374B3374AB35;

1.25
date	2007.03.04.00.13.15;	author tg;	state Exp;
branches;
next	1.24;
commitid	10045EA0F2F6674C8B9;

1.24
date	2007.01.17.22.51.46;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045AEA86F7FE51B97;

1.23
date	2007.01.15.00.18.47;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045AAC877551BD17C;

1.22
date	2007.01.12.10.18.20;	author tg;	state Exp;
branches
	1.22.2.1;
next	1.21;
commitid	10045A76059104E0EFB;

1.21
date	2007.01.12.01.49.27;	author tg;	state Exp;
branches;
next	1.20;
commitid	10045A6E8B92FCAC95A;

1.20
date	2006.11.12.14.58.14;	author tg;	state Exp;
branches;
next	1.19;
commitid	100455735A7145E26AA;

1.19
date	2006.11.10.06.16.24;	author tg;	state Exp;
branches;
next	1.18;
commitid	100455419107E3FB2C1;

1.18
date	2006.11.10.04.03.58;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004553F9E36E96466A;

1.17
date	2006.11.10.01.44.39;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004553D9465642DE5C;

1.16
date	2006.08.01.13.43.26;	author tg;	state Exp;
branches;
next	1.15;
commitid	10044CF5A93693A5C0A;

1.15
date	2006.05.10.18.54.10;	author tg;	state Exp;
branches;
next	1.14;
commitid	100446236E6726083C8;

1.14
date	2006.01.30.12.37.22;	author tg;	state Exp;
branches;
next	1.13;
commitid	10043DE088533ED5341;

1.13
date	2006.01.29.20.04.51;	author tg;	state Exp;
branches;
next	1.12;
commitid	10043DD1FE6328EF386;

1.12
date	2005.11.22.18.40.41;	author tg;	state Exp;
branches;
next	1.11;
commitid	108a438366254326;

1.11
date	2005.11.22.18.36.19;	author tg;	state Exp;
branches;
next	1.10;
commitid	659a438364faa8a1;

1.10
date	2005.10.25.19.53.27;	author tg;	state Exp;
branches;
next	1.9;
commitid	76cc435e8d34d8ce;

1.9
date	2005.10.08.19.30.58;	author tg;	state Exp;
branches;
next	1.8;
commitid	512643481e5274c0;

1.8
date	2005.07.07.22.00.45;	author tg;	state Exp;
branches;
next	1.7;
commitid	32a042cda60d6277;

1.7
date	2005.07.04.12.34.22;	author tg;	state Exp;
branches;
next	1.6;
commitid	4a8342c92cd61cc3;

1.6
date	2005.07.04.12.27.25;	author tg;	state Exp;
branches;
next	1.5;
commitid	3ec342c92b3a8874;

1.5
date	2005.05.25.14.07.29;	author tg;	state Exp;
branches;
next	1.4;
commitid	606a4294868d06b7;

1.4
date	2005.05.25.13.45.59;	author tg;	state Exp;
branches;
next	1.3;
commitid	503942948197230c;

1.3
date	2005.05.25.11.31.15;	author tg;	state Exp;
branches;
next	1.2;
commitid	1360429461f95498;

1.2
date	2005.05.23.15.18.16;	author tg;	state Exp;
branches;
next	1.1;
commitid	3dc04291f43ca526;

1.1
date	2005.05.23.03.06.07;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.137.2.1
date	2015.01.11.22.39.48;	author tg;	state Exp;
branches;
next	1.137.2.2;
commitid	10054B2FBC1440F88AD;

1.137.2.2
date	2015.03.01.15.42.59;	author tg;	state Exp;
branches;
next	1.137.2.3;
commitid	10054F33364551D895A;

1.137.2.3
date	2015.04.12.22.32.25;	author tg;	state Exp;
branches;
next	1.137.2.4;
commitid	100552AF26A429AA816;

1.137.2.4
date	2015.04.19.19.18.15;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.106.2.1
date	2012.12.04.01.26.22;	author tg;	state Exp;
branches;
next	1.106.2.2;
commitid	10050BD5149729CD584;

1.106.2.2
date	2012.12.22.00.03.49;	author tg;	state Exp;
branches;
next	1.106.2.3;
commitid	10050D4F8C95001AF1D;

1.106.2.3
date	2013.01.01.21.20.03;	author tg;	state Exp;
branches;
next	1.106.2.4;
commitid	10050E352F23B706399;

1.106.2.4
date	2013.01.06.18.59.13;	author tg;	state Exp;
branches;
next	1.106.2.5;
commitid	10050E9C9931FE4587F;

1.106.2.5
date	2013.02.10.17.11.19;	author tg;	state Exp;
branches;
next	1.106.2.6;
commitid	1005117D46E22B420F2;

1.106.2.6
date	2013.02.10.23.59.34;	author tg;	state Exp;
branches;
next	1.106.2.7;
commitid	100511834521EDC159D;

1.106.2.7
date	2013.02.15.18.54.41;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.99.2.1
date	2013.02.11.00.27.12;	author tg;	state Exp;
branches;
next	1.99.2.2;
commitid	10051183A6D5475BB1E;

1.99.2.2
date	2013.02.15.18.54.52;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.68.2.1
date	2009.11.28.14.27.49;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.47.2.1
date	2008.11.22.13.20.27;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.39.2.1
date	2008.04.22.13.29.24;	author tg;	state Exp;
branches;
next	1.39.2.2;
commitid	100480DE80F32BAA72D;

1.39.2.2
date	2008.05.19.18.41.21;	author tg;	state Exp;
branches;
next	1.39.2.3;
commitid	1004831C9A63DA06745;

1.39.2.3
date	2008.12.14.00.07.39;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.29.2.1
date	2007.05.13.19.29.34;	author tg;	state Exp;
branches;
next	1.29.2.2;
commitid	1004647668D4636830B;

1.29.2.2
date	2007.07.05.11.49.18;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.22.2.1
date	2007.03.03.21.37.54;	author tg;	state Exp;
branches;
next	1.22.2.2;
commitid	10045E9EAC27ABA6ADF;

1.22.2.2
date	2007.03.03.21.43.48;	author tg;	state Exp;
branches;
next	1.22.2.3;
commitid	10045E9EC2B7AC589DE;

1.22.2.3
date	2007.03.03.22.38.23;	author tg;	state Exp;
branches;
next	1.22.2.4;
commitid	10045E9F8F5395F55BB;

1.22.2.4
date	2007.03.03.22.51.18;	author tg;	state Exp;
branches;
next	1.22.2.5;
commitid	10045E9FBFC58BC83D0;

1.22.2.5
date	2007.03.03.23.38.35;	author tg;	state Exp;
branches;
next	1.22.2.6;
commitid	10045EA07113BF2F32A;

1.22.2.6
date	2007.03.03.23.45.14;	author tg;	state Exp;
branches;
next	;
commitid	10045EA08A0437BD668;


desc
@@


1.217
log
@handle POSIX-style functions like ksh-style functions and external utilities

cf. Debian #935115
@
text
@/*	$OpenBSD: exec.c,v 1.52 2015/09/10 22:48:58 nicm Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.216 2019/12/30 03:45:12 tg Exp $");

#ifndef MKSH_DEFAULT_EXECSHELL
#define MKSH_DEFAULT_EXECSHELL	MKSH_UNIXROOT "/bin/sh"
#endif

static int comexec(struct op *, struct tbl * volatile, const char **,
    int volatile, volatile int *);
static void scriptexec(struct op *, const char **) MKSH_A_NORETURN;
static int call_builtin(struct tbl *, const char **, const char *, bool);
static int iosetup(struct ioword *, struct tbl *);
static const char *do_selectargs(const char **, bool);
static Test_op dbteste_isa(Test_env *, Test_meta);
static const char *dbteste_getopnd(Test_env *, Test_op, bool);
static void dbteste_error(Test_env *, int, const char *);
/* XXX: horrible kludge to fit within the framework */
static void plain_fmt_entry(char *, size_t, unsigned int, const void *);
static void select_fmt_entry(char *, size_t, unsigned int, const void *);

/*
 * execute command tree
 */
int
execute(struct op * volatile t,
    /* if XEXEC don't fork */
    volatile int flags,
    volatile int * volatile xerrok)
{
	int i;
	volatile int rv = 0, dummy = 0;
	int pv[2];
	const char ** volatile ap = NULL;
	char ** volatile up;
	const char *s, *ccp;
	struct ioword **iowp;
	struct tbl *tp = NULL;

	if (t == NULL)
		return (0);

	/* Caller doesn't care if XERROK should propagate. */
	if (xerrok == NULL)
		xerrok = &dummy;

	if ((flags&XFORK) && !(flags&XEXEC) && t->type != TPIPE)
		/* run in sub-process */
		return (exchild(t, flags & ~XTIME, xerrok, -1));

	newenv(E_EXEC);
	if (trap)
		runtraps(0);

	/* we want to run an executable, do some variance checks */
	if (t->type == TCOM) {
		/*
		 * Clear subst_exstat before argument expansion. Used by
		 * null commands (see comexec() and c_eval()) and by c_set().
		 */
		subst_exstat = 0;

		/* for $LINENO */
		current_lineno = t->lineno;

		/* check if this is 'var=<<EOF' */
		if (
		    /* we have zero arguments, i.e. no program to run */
		    t->args[0] == NULL &&
		    /* we have exactly one variable assignment */
		    t->vars[0] != NULL && t->vars[1] == NULL &&
		    /* we have exactly one I/O redirection */
		    t->ioact != NULL && t->ioact[0] != NULL &&
		    t->ioact[1] == NULL &&
		    /* of type "here document" (or "here string") */
		    (t->ioact[0]->ioflag & IOTYPE) == IOHERE &&
		    /* the variable assignment begins with a valid varname */
		    (ccp = skip_wdvarname(t->vars[0], true)) != t->vars[0] &&
		    /* and has no right-hand side (i.e. "varname=") */
		    ccp[0] == CHAR && ((ccp[1] == '=' && ccp[2] == EOS) ||
		    /* or "varname+=" */ (ccp[1] == '+' && ccp[2] == CHAR &&
		    ccp[3] == '=' && ccp[4] == EOS))) {
			char *cp, *dp;

			if ((rv = herein(t->ioact[0], &cp) /*? 1 : 0*/))
				cp = NULL;
			strdup2x(dp, evalstr(t->vars[0], DOASNTILDE | DOSCALAR),
			    rv ? null : cp);
			typeset(dp, Flag(FEXPORT) ? EXPORT : 0, 0, 0, 0);
			/* free the expanded value */
			afree(cp, APERM);
			afree(dp, ATEMP);
			goto Break;
		}

		/*
		 * POSIX says expand command words first, then redirections,
		 * and assignments last..
		 */
		up = eval(t->args, t->u.evalflags | DOBLANK | DOGLOB | DOTILDE);
		if (flags & XTIME)
			/* Allow option parsing (bizarre, but POSIX) */
			timex_hook(t, &up);
		ap = (const char **)up;
		if (ap[0])
			tp = findcom(ap[0], FC_BI|FC_FUNC);
	}
	flags &= ~XTIME;

	if (t->ioact != NULL || t->type == TPIPE || t->type == TCOPROC) {
		e->savefd = alloc2(NUFILE, sizeof(short), ATEMP);
		/* initialise to not redirected */
		memset(e->savefd, 0, NUFILE * sizeof(short));
	}

	/* mark for replacement later (unless TPIPE) */
	vp_pipest->flag |= INT_L;

	/* do redirection, to be restored in quitenv() */
	if (t->ioact != NULL)
		for (iowp = t->ioact; *iowp != NULL; iowp++) {
			if (iosetup(*iowp, tp) < 0) {
				exstat = rv = 1;
				/*
				 * Redirection failures for special commands
				 * cause (non-interactive) shell to exit.
				 */
				if (tp && tp->type == CSHELL &&
				    (tp->flag & SPEC_BI))
					errorfz();
				/* Deal with FERREXIT, quitenv(), etc. */
				goto Break;
			}
		}

	switch (t->type) {
	case TCOM:
		rv = comexec(t, tp, (const char **)ap, flags, xerrok);
		break;

	case TPAREN:
		rv = execute(t->left, flags | XFORK, xerrok);
		break;

	case TPIPE:
		flags |= XFORK;
		flags &= ~XEXEC;
		e->savefd[0] = savefd(0);
		e->savefd[1] = savefd(1);
		while (t->type == TPIPE) {
			openpipe(pv);
			/* stdout of curr */
			ksh_dup2(pv[1], 1, false);
			/**
			 * Let exchild() close pv[0] in child
			 * (if this isn't done, commands like
			 *	(: ; cat /etc/termcap) | sleep 1
			 * will hang forever).
			 */
			exchild(t->left, flags | XPIPEO | XCCLOSE,
			    NULL, pv[0]);
			/* stdin of next */
			ksh_dup2(pv[0], 0, false);
			closepipe(pv);
			flags |= XPIPEI;
			t = t->right;
		}
		/* stdout of last */
		restfd(1, e->savefd[1]);
		/* no need to re-restore this */
		e->savefd[1] = 0;
		/* Let exchild() close 0 in parent, after fork, before wait */
		i = exchild(t, flags | XPCLOSE | XPIPEST, xerrok, 0);
		if (!(flags&XBGND) && !(flags&XXCOM))
			rv = i;
		break;

	case TLIST:
		while (t->type == TLIST) {
			execute(t->left, flags & XERROK, NULL);
			t = t->right;
		}
		rv = execute(t, flags & XERROK, xerrok);
		break;

	case TCOPROC: {
#ifndef MKSH_NOPROSPECTOFWORK
		sigset_t omask;

		/*
		 * Block sigchild as we are using things changed in the
		 * signal handler
		 */
		sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
		e->type = E_ERRH;
		if ((i = kshsetjmp(e->jbuf))) {
			sigprocmask(SIG_SETMASK, &omask, NULL);
			quitenv(NULL);
			unwind(i);
			/* NOTREACHED */
		}
#endif
		/* Already have a (live) co-process? */
		if (coproc.job && coproc.write >= 0)
			errorf("coprocess already exists");

		/* Can we re-use the existing co-process pipe? */
		coproc_cleanup(true);

		/* do this before opening pipes, in case these fail */
		e->savefd[0] = savefd(0);
		e->savefd[1] = savefd(1);

		openpipe(pv);
		if (pv[0] != 0) {
			ksh_dup2(pv[0], 0, false);
			close(pv[0]);
		}
		coproc.write = pv[1];
		coproc.job = NULL;

		if (coproc.readw >= 0)
			ksh_dup2(coproc.readw, 1, false);
		else {
			openpipe(pv);
			coproc.read = pv[0];
			ksh_dup2(pv[1], 1, false);
			/* closed before first read */
			coproc.readw = pv[1];
			coproc.njobs = 0;
			/* create new coprocess id */
			++coproc.id;
		}
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
		/* no more need for error handler */
		e->type = E_EXEC;
#endif

		/*
		 * exchild() closes coproc.* in child after fork,
		 * will also increment coproc.njobs when the
		 * job is actually created.
		 */
		flags &= ~XEXEC;
		exchild(t->left, flags | XBGND | XFORK | XCOPROC | XCCLOSE,
		    NULL, coproc.readw);
		break;
	}

	case TASYNC:
		/*
		 * XXX non-optimal, I think - "(foo &)", forks for (),
		 * forks again for async... parent should optimise
		 * this to "foo &"...
		 */
		rv = execute(t->left, (flags&~XEXEC)|XBGND|XFORK, xerrok);
		break;

	case TOR:
	case TAND:
		rv = execute(t->left, XERROK, NULL);
		if ((rv == 0) == (t->type == TAND))
			rv = execute(t->right, flags & XERROK, xerrok);
		else {
			flags |= XERROK;
			if (xerrok)
				*xerrok = 1;
		}
		break;

	case TBANG:
		rv = !execute(t->right, XERROK, xerrok);
		flags |= XERROK;
		if (xerrok)
			*xerrok = 1;
		break;

	case TDBRACKET: {
		Test_env te;

		te.flags = TEF_DBRACKET;
		te.pos.wp = t->args;
		te.isa = dbteste_isa;
		te.getopnd = dbteste_getopnd;
		te.eval = test_eval;
		te.error = dbteste_error;

		rv = test_parse(&te);
		break;
	}

	case TFOR:
	case TSELECT: {
		volatile bool is_first = true;

		ap = (t->vars == NULL) ? e->loc->argv + 1 :
		    (const char **)eval((const char **)t->vars,
		    DOBLANK | DOGLOB | DOTILDE);
		e->type = E_LOOP;
		while ((i = kshsetjmp(e->jbuf))) {
			if ((e->flags&EF_BRKCONT_PASS) ||
			    (i != LBREAK && i != LCONTIN)) {
				quitenv(NULL);
				unwind(i);
			} else if (i == LBREAK) {
				rv = 0;
				goto Break;
			}
		}
		/* in case of a continue */
		rv = 0;
		if (t->type == TFOR) {
			while (*ap != NULL) {
				setstr(global(t->str), *ap++, KSH_UNWIND_ERROR);
				rv = execute(t->left, flags & XERROK, xerrok);
			}
		} else {
 do_TSELECT:
			if ((ccp = do_selectargs(ap, is_first))) {
				is_first = false;
				setstr(global(t->str), ccp, KSH_UNWIND_ERROR);
				execute(t->left, flags & XERROK, xerrok);
				goto do_TSELECT;
			}
			rv = 1;
		}
		break;
	}

	case TWHILE:
	case TUNTIL:
		e->type = E_LOOP;
		while ((i = kshsetjmp(e->jbuf))) {
			if ((e->flags&EF_BRKCONT_PASS) ||
			    (i != LBREAK && i != LCONTIN)) {
				quitenv(NULL);
				unwind(i);
			} else if (i == LBREAK) {
				rv = 0;
				goto Break;
			}
		}
		/* in case of a continue */
		rv = 0;
		while ((execute(t->left, XERROK, NULL) == 0) ==
		    (t->type == TWHILE))
			rv = execute(t->right, flags & XERROK, xerrok);
		break;

	case TIF:
	case TELIF:
		if (t->right == NULL)
			/* should be error */
			break;
		rv = execute(execute(t->left, XERROK, NULL) == 0 ?
		    t->right->left : t->right->right, flags & XERROK, xerrok);
		break;

	case TCASE:
		i = 0;
		ccp = evalstr(t->str, DOTILDE | DOSCALAR);
		for (t = t->left; t != NULL && t->type == TPAT; t = t->right) {
			for (ap = (const char **)t->vars; *ap; ap++) {
				if (i || ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
				    gmatchx(ccp, s, false))) {
					record_match(ccp);
					rv = execute(t->left, flags & XERROK,
					    xerrok);
					i = 0;
					switch (t->u.charflag) {
					case '&':
						i = 1;
						/* FALLTHROUGH */
					case '|':
						goto TCASE_next;
					}
					goto TCASE_out;
				}
			}
			i = 0;
 TCASE_next:
			/* empty */;
		}
 TCASE_out:
		break;

	case TBRACE:
		rv = execute(t->left, flags & XERROK, xerrok);
		break;

	case TFUNCT:
		rv = define(t->str, t);
		break;

	case TTIME:
		/*
		 * Clear XEXEC so nested execute() call doesn't exit
		 * (allows "ls -l | time grep foo").
		 */
		rv = timex(t, flags & ~XEXEC, xerrok);
		break;

	case TEXEC:
		/* an eval'd TCOM */
		up = makenv();
		restoresigs();
		cleanup_proc_env();
		/* I/O redirection cleanup to be done in child process */
		if (!Flag(FPOSIX) && !Flag(FSH) && t->left->ioact != NULL)
			for (iowp = t->left->ioact; *iowp != NULL; iowp++)
				if ((*iowp)->ioflag & IODUPSELF)
					fcntl((*iowp)->unit, F_SETFD, 0);
		/* try to execute */
		{
			union mksh_ccphack cargs;

			cargs.ro = t->args;
			execve(t->str, cargs.rw, up);
			rv = errno;
		}
		if (rv == ENOEXEC)
			scriptexec(t, (const char **)up);
		else
			errorfx(126, Tf_sD_s, t->str, cstrerror(rv));
	}
 Break:
	exstat = rv & 0xFF;
	if (vp_pipest->flag & INT_L) {
		unset(vp_pipest, 1);
		vp_pipest->flag = DEFINED | ISSET | INTEGER | RDONLY |
		    ARRAY | INT_U | INT_L;
		vp_pipest->val.i = rv;
	}

	/* restores IO */
	quitenv(NULL);
	if ((flags&XEXEC))
		/* exit child */
		unwind(LEXIT);
	if (rv != 0 && !(flags & XERROK) &&
	    (xerrok == NULL || !*xerrok)) {
		trapsig(ksh_SIGERR);
		if (Flag(FERREXIT))
			unwind(LERREXT);
	}
	return (rv);
}

/*
 * execute simple command
 */

static int
comexec(struct op *t, struct tbl * volatile tp, const char **ap,
    volatile int flags, volatile int *xerrok)
{
	int i;
	volatile int rv = 0;
	const char *cp;
	const char **lastp;
	/* Must be static (XXX but why?) */
	static struct op texec;
	int type_flags;
	bool resetspec;
	int fcflags = FC_BI|FC_FUNC|FC_PATH;
	struct block *l_expand, *l_assign;
	int optc;
	const char *exec_argv0 = NULL;
	bool exec_clrenv = false;

	/* snag the last argument for $_ */
	if (Flag(FTALKING) && *(lastp = ap)) {
		/*
		 * XXX not the same as AT&T ksh, which only seems to set $_
		 * after a newline (but not in functions/dot scripts, but in
		 * interactive and script) - perhaps save last arg here and
		 * set it in shell()?.
		 */
		while (*++lastp)
			;
		/* setstr() can't fail here */
		setstr(typeset("_", LOCAL, 0, INTEGER, 0), *--lastp,
		    KSH_RETURN_ERROR);
	}

	/**
	 * Deal with the shell builtins builtin, exec and command since
	 * they can be followed by other commands. This must be done before
	 * we know if we should create a local block which must be done
	 * before we can do a path search (in case the assignments change
	 * PATH).
	 * Odd cases:
	 *	FOO=bar exec >/dev/null		FOO is kept but not exported
	 *	FOO=bar exec foobar		FOO is exported
	 *	FOO=bar command exec >/dev/null	FOO is neither kept nor exported
	 *	FOO=bar command			FOO is neither kept nor exported
	 *	PATH=... foobar			use new PATH in foobar search
	 */
	resetspec = false;
	while (tp && tp->type == CSHELL) {
		/* undo effects of command */
		fcflags = FC_BI|FC_FUNC|FC_PATH;
		if (tp->val.f == c_builtin) {
			if ((cp = *++ap) == NULL ||
			    (!strcmp(cp, "--") && (cp = *++ap) == NULL)) {
				tp = NULL;
				break;
			}
			if ((tp = findcom(cp, FC_BI)) == NULL)
				errorf(Tf_sD_sD_s, Tbuiltin, cp, Tnot_found);
			if (tp->type == CSHELL && (tp->flag & LOW_BI))
				break;
			continue;
		} else if (tp->val.f == c_exec) {
			if (ap[1] == NULL)
				break;
			ksh_getopt_reset(&builtin_opt, GF_ERROR);
			while ((optc = ksh_getopt(ap, &builtin_opt, "a:c")) != -1)
				switch (optc) {
				case 'a':
					exec_argv0 = builtin_opt.optarg;
					break;
				case 'c':
					exec_clrenv = true;
					/* ensure we can actually do this */
					resetspec = true;
					break;
				default:
					rv = 2;
					goto Leave;
				}
			ap += builtin_opt.optind;
			flags |= XEXEC;
			/* POSuX demands ksh88-like behaviour here */
			if (Flag(FPOSIX))
				fcflags = FC_PATH;
		} else if (tp->val.f == c_command) {
			bool saw_p = false;

			/*
			 * Ugly dealing with options in two places (here
			 * and in c_command(), but such is life)
			 */
			ksh_getopt_reset(&builtin_opt, 0);
			while ((optc = ksh_getopt(ap, &builtin_opt, ":p")) == 'p')
				saw_p = true;
			if (optc != -1)
				/* command -vV or something */
				break;
			/* don't look for functions */
			fcflags = FC_BI|FC_PATH;
			if (saw_p) {
				if (Flag(FRESTRICTED)) {
					warningf(true, Tf_sD_s,
					    "command -p", "restricted");
					rv = 1;
					goto Leave;
				}
				fcflags |= FC_DEFPATH;
			}
			ap += builtin_opt.optind;
			/*
			 * POSIX says special builtins lose their status
			 * if accessed using command.
			 */
			resetspec = true;
			if (!ap[0]) {
				/* ensure command with no args exits with 0 */
				subst_exstat = 0;
				break;
			}
		} else if (tp->flag & LOW_BI) {
			/* if we have any flags, do not use the builtin */
			if ((ap[1] && ap[1][0] == '-' && ap[1][1] != '\0' &&
			    /* argument, begins with -, is not - or -- */
			    (ap[1][1] != '-' || ap[1][2] != '\0')) ||
			    /* always prefer the external utility */
			    (tp->flag & LOWER_BI)) {
				struct tbl *ext_cmd;

				ext_cmd = findcom(tp->name, FC_PATH | FC_FUNC);
				if (ext_cmd && (ext_cmd->type != CTALIAS ||
				    (ext_cmd->flag & ISSET)))
					tp = ext_cmd;
			}
			break;
		} else if (tp->val.f == c_trap) {
			t->u.evalflags &= ~DOTCOMEXEC;
			break;
		} else
			break;
		tp = findcom(ap[0], fcflags & (FC_BI|FC_FUNC));
	}
	if (t->u.evalflags & DOTCOMEXEC)
		flags |= XEXEC;
	l_expand = e->loc;
	if (!resetspec && (!ap[0] || (tp && (tp->flag & KEEPASN))))
		type_flags = 0;
	else {
		/* create new variable/function block */
		newblock();
		/* all functions keep assignments */
		type_flags = LOCAL|LOCAL_COPY|EXPORT;
	}
	l_assign = e->loc;
	if (exec_clrenv)
		l_assign->flags |= BF_STOPENV;
	if (Flag(FEXPORT))
		type_flags |= EXPORT;
	if (Flag(FXTRACE))
		change_xtrace(2, false);
	for (i = 0; t->vars[i]; i++) {
		/* do NOT lookup in the new var/fn block just created */
		e->loc = l_expand;
		cp = evalstr(t->vars[i], DOASNTILDE | DOSCALAR);
		e->loc = l_assign;
		if (Flag(FXTRACE)) {
			const char *ccp;

			ccp = skip_varname(cp, true);
			if (*ccp == '+')
				++ccp;
			if (*ccp == '=')
				++ccp;
			shf_write(cp, ccp - cp, shl_xtrace);
			print_value_quoted(shl_xtrace, ccp);
			shf_putc(' ', shl_xtrace);
		}
		/* but assign in there as usual */
		typeset(cp, type_flags, 0, 0, 0);
	}

	if (Flag(FXTRACE)) {
		change_xtrace(2, false);
		if (ap[rv = 0]) {
 xtrace_ap_loop:
			print_value_quoted(shl_xtrace, ap[rv]);
			if (ap[++rv]) {
				shf_putc(' ', shl_xtrace);
				goto xtrace_ap_loop;
			}
		}
		change_xtrace(1, false);
	}

	if ((cp = *ap) == NULL) {
		rv = subst_exstat;
		goto Leave;
	} else if (!tp) {
		if (Flag(FRESTRICTED) && mksh_vdirsep(cp)) {
			warningf(true, Tf_sD_s, cp, "restricted");
			rv = 1;
			goto Leave;
		}
		tp = findcom(cp, fcflags);
	}

	switch (tp->type) {

	/* shell built-in */
	case CSHELL:
 do_call_builtin:
		if (l_expand != l_assign)
			l_assign->flags |= (tp->flag & NEXTLOC_BI);
		rv = call_builtin(tp, (const char **)ap, null, resetspec);
		break;

	/* function call */
	case CFUNC: {
		volatile uint32_t old_inuse;
		const char * volatile old_kshname;
		volatile uint8_t old_flags[FNFLAGS];

		if (!(tp->flag & ISSET)) {
			struct tbl *ftp;

			if (!tp->u.fpath) {
 fpath_error:
				rv = (tp->u2.errnov == ENOENT) ? 127 : 126;
				warningf(true, Tf_sD_s_sD_s, cp,
				    Tcant_find, Tfile_fd,
				    cstrerror(tp->u2.errnov));
				break;
			}
			errno = 0;
			if (include(tp->u.fpath, 0, NULL, false) < 0 ||
			    !(ftp = findfunc(cp, hash(cp), false)) ||
			    !(ftp->flag & ISSET)) {
				rv = errno;
				if ((ftp = findcom(cp, FC_BI)) &&
				    (ftp->type == CSHELL) &&
				    (ftp->flag & LOW_BI)) {
					tp = ftp;
					goto do_call_builtin;
				}
				if (rv) {
					tp->u2.errnov = rv;
					cp = tp->u.fpath;
					goto fpath_error;
				}
				warningf(true, Tf_sD_s_s, cp,
				    "function not defined by", tp->u.fpath);
				rv = 127;
				break;
			}
			tp = ftp;
		}

		/*
		 * ksh functions set $0 to function name, POSIX
		 * functions leave $0 unchanged.
		 */
		old_kshname = kshname;
		if (tp->flag & FKSH)
			kshname = ap[0];
		else
			ap[0] = kshname;
		e->loc->argv = ap;
		for (i = 0; *ap++ != NULL; i++)
			;
		e->loc->argc = i - 1;
		/*
		 * ksh-style functions handle getopts sanely,
		 * Bourne/POSIX functions are insane...
		 */
		if (tp->flag & FKSH) {
			e->loc->flags |= BF_DOGETOPTS;
			e->loc->getopts_state = user_opt;
			getopts_reset(1);
		}

		for (type_flags = 0; type_flags < FNFLAGS; ++type_flags)
			old_flags[type_flags] = shell_flags[type_flags];
		change_xtrace((Flag(FXTRACEREC) ? Flag(FXTRACE) : 0) |
		    ((tp->flag & TRACE) ? 1 : 0), false);
		old_inuse = tp->flag & FINUSE;
		tp->flag |= FINUSE;

		e->type = E_FUNC;
		if (!(i = kshsetjmp(e->jbuf))) {
			execute(tp->val.t, flags & XERROK, NULL);
			i = LRETURN;
		}

		kshname = old_kshname;
		change_xtrace(old_flags[(int)FXTRACE], false);
#ifndef MKSH_LEGACY_MODE
		if (tp->flag & FKSH) {
			/* Korn style functions restore Flags on return */
			old_flags[(int)FXTRACE] = Flag(FXTRACE);
			for (type_flags = 0; type_flags < FNFLAGS; ++type_flags)
				shell_flags[type_flags] = old_flags[type_flags];
		}
#endif
		tp->flag = (tp->flag & ~FINUSE) | old_inuse;

		/*
		 * Were we deleted while executing? If so, free the
		 * execution tree.
		 */
		if ((tp->flag & (FDELETE|FINUSE)) == FDELETE) {
			if (tp->flag & ALLOC) {
				tp->flag &= ~ALLOC;
				tfree(tp->val.t, tp->areap);
			}
			tp->flag = 0;
		}
		switch (i) {
		case LRETURN:
		case LERROR:
		case LERREXT:
			rv = exstat & 0xFF;
			break;
		case LINTR:
		case LEXIT:
		case LLEAVE:
		case LSHELL:
			quitenv(NULL);
			unwind(i);
			/* NOTREACHED */
		default:
			quitenv(NULL);
			internal_errorf(Tunexpected_type, Tunwind, Tfunction, i);
		}
		break;
	}

	/* executable command */
	case CEXEC:
	/* tracked alias */
	case CTALIAS:
		if (!(tp->flag&ISSET)) {
			if (tp->u2.errnov == ENOENT) {
				rv = 127;
				warningf(true, Tf_sD_s_s, cp,
				    "inaccessible or", Tnot_found);
			} else {
				rv = 126;
				warningf(true, Tf_sD_sD_s, cp, "can't execute",
				    cstrerror(tp->u2.errnov));
			}
			break;
		}

		/* set $_ to program's full path */
		/* setstr() can't fail here */
		setstr(typeset("_", LOCAL | EXPORT, 0, INTEGER, 0),
		    tp->val.s, KSH_RETURN_ERROR);

		/* to fork, we set up a TEXEC node and call execute */
		texec.type = TEXEC;
		/* for vistree/dumptree */
		texec.left = t;
		texec.str = tp->val.s;
		texec.args = ap;

		/* in this case we do not fork, of course */
		if (flags & XEXEC) {
			if (exec_argv0)
				texec.args[0] = exec_argv0;
			j_exit();
			if (!(flags & XBGND)
#ifndef MKSH_UNEMPLOYED
			    || Flag(FMONITOR)
#endif
			    ) {
				setexecsig(&sigtraps[SIGINT], SS_RESTORE_ORIG);
				setexecsig(&sigtraps[SIGQUIT], SS_RESTORE_ORIG);
			}
		}

		rv = exchild(&texec, flags, xerrok, -1);
		break;
	}
 Leave:
	if (flags & XEXEC) {
		exstat = rv & 0xFF;
		unwind(LEXIT);
	}
	return (rv);
}

static void
scriptexec(struct op *tp, const char **ap)
{
	const char *sh;
#ifndef MKSH_SMALL
	int fd;
	unsigned char buf[68];
#endif
	union mksh_ccphack args, cap;

	sh = str_val(global(TEXECSHELL));
	if (sh && *sh)
		sh = search_path(sh, path, X_OK, NULL);
	if (!sh || !*sh)
		sh = MKSH_DEFAULT_EXECSHELL;

	*tp->args-- = tp->str;

#ifndef MKSH_SMALL
	if ((fd = binopen2(tp->str, O_RDONLY | O_MAYEXEC)) >= 0) {
		unsigned char *cp;
#ifndef MKSH_EBCDIC
		unsigned short m;
#endif
		ssize_t n;

#if defined(__OS2__) && defined(MKSH_WITH_TEXTMODE)
		setmode(fd, O_TEXT);
#endif
		/* read first couple of octets from file */
		n = read(fd, buf, sizeof(buf) - 1);
		close(fd);
		/* read error or short read? */
		if (n < 5)
			goto nomagic;
		/* terminate buffer */
		buf[n] = '\0';

		/* skip UTF-8 Byte Order Mark, if present */
		cp = buf + (n = ((buf[0] == 0xEF) && (buf[1] == 0xBB) &&
		    (buf[2] == 0xBF)) ? 3 : 0);

		/* scan for newline or NUL (end of buffer) */
		while (!ctype(*cp, C_NL | C_NUL))
			++cp;
		/* if the shebang line is longer than MAXINTERP, bail out */
		if (!*cp)
			goto noshebang;
		/* replace newline by NUL */
		*cp = '\0';

		/* restore start of shebang position (buf+0 or buf+3) */
		cp = buf + n;
		/* bail out if no shebang magic found */
		if (cp[0] == '#' && cp[1] == '!')
			cp += 2;
#ifdef __OS2__
		else if (!strncmp(cp, Textproc, 7) &&
		    ctype(cp[7], C_BLANK))
			cp += 8;
#endif
		else
			goto noshebang;
		/* skip whitespace before shell name */
		while (ctype(*cp, C_BLANK))
			++cp;
		/* just whitespace on the line? */
		if (*cp == '\0')
			goto noshebang;
		/* no, we actually found an interpreter name */
		sh = (char *)cp;
		/* look for end of shell/interpreter name */
		while (!ctype(*cp, C_BLANK | C_NUL))
			++cp;
		/* any arguments? */
		if (*cp) {
			*cp++ = '\0';
			/* skip spaces before arguments */
			while (ctype(*cp, C_BLANK))
				++cp;
			/* pass it all in ONE argument (historic reasons) */
			if (*cp)
				*tp->args-- = (char *)cp;
		}
#ifdef __OS2__
		/*
		 * On OS/2, the directory structure differs from normal
		 * Unix, which can make many scripts whose shebang
		 * hardcodes the path to an interpreter fail (and there
		 * might be no /usr/bin/env); for user convenience, if
		 * the specified interpreter is not usable, do a PATH
		 * search to find it.
		 */
		if (mksh_vdirsep(sh) && !search_path(sh, path, X_OK, NULL)) {
			cp = search_path(_getname(sh), path, X_OK, NULL);
			if (cp)
				sh = cp;
		}
#endif
		goto nomagic;
 noshebang:
#ifndef MKSH_EBCDIC
		m = buf[0] << 8 | buf[1];
		if (m == 0x7F45 && buf[2] == 'L' && buf[3] == 'F')
			errorf("%s: not executable: %d-bit ELF file", tp->str,
			    32 * buf[4]);
		if ((m == /* OMAGIC */ 0407) ||
		    (m == /* NMAGIC */ 0410) ||
		    (m == /* ZMAGIC */ 0413) ||
		    (m == /* QMAGIC */ 0314) ||
		    (m == /* ECOFF_I386 */ 0x4C01) ||
		    (m == /* ECOFF_M68K */ 0x0150 || m == 0x5001) ||
		    (m == /* ECOFF_SH */   0x0500 || m == 0x0005) ||
		    (m == /* bzip */ 0x425A) || (m == /* "MZ" */ 0x4D5A) ||
		    (m == /* "NE" */ 0x4E45) || (m == /* "LX" */ 0x4C58) ||
		    (m == /* ksh93 */ 0x0B13) || (m == /* LZIP */ 0x4C5A) ||
		    (m == /* xz */ 0xFD37 && buf[2] == 'z' && buf[3] == 'X' &&
		    buf[4] == 'Z') || (m == /* 7zip */ 0x377A) ||
		    (m == /* gzip */ 0x1F8B) || (m == /* .Z */ 0x1F9D))
			errorf("%s: not executable: magic %04X", tp->str, m);
#endif
#ifdef __OS2__
		cp = _getext(tp->str);
		if (cp && (!stricmp(cp, ".cmd") || !stricmp(cp, ".bat"))) {
			/* execute .cmd and .bat with OS2_SHELL, usually CMD.EXE */
			sh = str_val(global("OS2_SHELL"));
			*tp->args-- = "/c";
			/* convert slahes to backslashes */
			for (cp = tp->str; *cp; cp++) {
				if (*cp == '/')
					*cp = '\\';
			}
		}
#endif
 nomagic:
		;
	}
#endif
	args.ro = tp->args;
	*args.ro = sh;

	cap.ro = ap;
	execve(args.rw[0], args.rw, cap.rw);

	/* report both the program that was run and the bogus interpreter */
	errorf(Tf_sD_sD_s, tp->str, sh, cstrerror(errno));
}

/* actual 'builtin' built-in utility call is handled in comexec() */
int
c_builtin(const char **wp)
{
	return (call_builtin(get_builtin(*wp), wp, Tbuiltin, false));
}

struct tbl *
get_builtin(const char *s)
{
	return (s && *s ? ktsearch(&builtins, s, hash(s)) : NULL);
}

/*
 * Search function tables for a function. If create set, a table entry
 * is created if none is found.
 */
struct tbl *
findfunc(const char *name, uint32_t h, bool create)
{
	struct block *l;
	struct tbl *tp = NULL;

	for (l = e->loc; l; l = l->next) {
		tp = ktsearch(&l->funs, name, h);
		if (tp)
			break;
		if (!l->next && create) {
			tp = ktenter(&l->funs, name, h);
			tp->flag = DEFINED;
			tp->type = CFUNC;
			tp->val.t = NULL;
			break;
		}
	}
	return (tp);
}

/*
 * define function. Returns 1 if function is being undefined (t == 0) and
 * function did not exist, returns 0 otherwise.
 */
int
define(const char *name, struct op *t)
{
	uint32_t nhash;
	struct tbl *tp;
	bool was_set = false;

	nhash = hash(name);

	while (/* CONSTCOND */ 1) {
		tp = findfunc(name, nhash, true);

		if (tp->flag & ISSET)
			was_set = true;
		/*
		 * If this function is currently being executed, we zap
		 * this table entry so findfunc() won't see it
		 */
		if (tp->flag & FINUSE) {
			tp->name[0] = '\0';
			/* ensure it won't be found */
			tp->flag &= ~DEFINED;
			tp->flag |= FDELETE;
		} else
			break;
	}

	if (tp->flag & ALLOC) {
		tp->flag &= ~(ISSET|ALLOC|FKSH);
		tfree(tp->val.t, tp->areap);
	}

	if (t == NULL) {
		/* undefine */
		ktdelete(tp);
		return (was_set ? 0 : 1);
	}

	tp->val.t = tcopy(t->left, tp->areap);
	tp->flag |= (ISSET|ALLOC);
	if (t->u.ksh_func)
		tp->flag |= FKSH;

	return (0);
}

/*
 * add builtin
 */
const char *
builtin(const char *name, int (*func) (const char **))
{
	struct tbl *tp;
	uint32_t flag = DEFINED;

	/* see if any flags should be set for this builtin */
 flags_loop:
	switch (*name) {
	case '=':
		/* command does variable assignment */
		flag |= KEEPASN;
		break;
	case '*':
		/* POSIX special builtin */
		flag |= SPEC_BI;
		break;
	case '~':
		/* external utility overrides built-in utility, always */
		flag |= LOWER_BI;
		/* FALLTHROUGH */
	case '!':
		/* external utility overrides built-in utility, with flags */
		flag |= LOW_BI;
		break;
	case '-':
		/* is declaration utility if argv[1] is one (POSIX: command) */
		flag |= DECL_FWDR;
		break;
	case '^':
		/* is declaration utility (POSIX: export, readonly) */
		flag |= DECL_UTIL;
		break;
	case '#':
		/* is set or shift */
		flag |= NEXTLOC_BI;
		break;
	default:
		goto flags_seen;
	}
	++name;
	goto flags_loop;
 flags_seen:

	/* enter into the builtins hash table */
	tp = ktenter(&builtins, name, hash(name));
	tp->flag = flag;
	tp->type = CSHELL;
	tp->val.f = func;

	/* return name, for direct builtin call check in main.c */
	return (name);
}

/*
 * find command
 * either function, hashed command, or built-in (in that order)
 */
struct tbl *
findcom(const char *name, int flags)
{
	static struct tbl temp;
	uint32_t h = hash(name);
	struct tbl *tp = NULL, *tbi;
	/* insert if not found */
	unsigned char insert = Flag(FTRACKALL);
	/* for function autoloading */
	char *fpath;
	union mksh_cchack npath;

	if (mksh_vdirsep(name)) {
		insert = 0;
		/* prevent FPATH search below */
		flags &= ~FC_FUNC;
		goto Search;
	}
	tbi = (flags & FC_BI) ? ktsearch(&builtins, name, h) : NULL;
	/*
	 * POSIX says special builtins first, then functions, then
	 * regular builtins, then search path...
	 */
	if ((flags & FC_SPECBI) && tbi && (tbi->flag & SPEC_BI))
		tp = tbi;
	if (!tp && (flags & FC_FUNC)) {
		tp = findfunc(name, h, false);
		if (tp && !(tp->flag & ISSET)) {
			if ((fpath = str_val(global(TFPATH))) == null) {
				tp->u.fpath = NULL;
				tp->u2.errnov = ENOENT;
			} else
				tp->u.fpath = search_path(name, fpath, R_OK,
				    &tp->u2.errnov);
		}
	}
	if (!tp && (flags & FC_NORMBI) && tbi)
		tp = tbi;
	if (!tp && (flags & FC_PATH) && !(flags & FC_DEFPATH)) {
		tp = ktsearch(&taliases, name, h);
		if (tp && (tp->flag & ISSET) &&
		    ksh_access(tp->val.s, X_OK) != 0) {
			if (tp->flag & ALLOC) {
				tp->flag &= ~ALLOC;
				afree(tp->val.s, APERM);
			}
			tp->flag &= ~ISSET;
		}
	}

 Search:
	if ((!tp || (tp->type == CTALIAS && !(tp->flag&ISSET))) &&
	    (flags & FC_PATH)) {
		if (!tp) {
			if (insert && !(flags & FC_DEFPATH)) {
				tp = ktenter(&taliases, name, h);
				tp->type = CTALIAS;
			} else {
				tp = &temp;
				tp->type = CEXEC;
			}
			/* make ~ISSET */
			tp->flag = DEFINED;
		}
		npath.ro = search_path(name,
		    (flags & FC_DEFPATH) ? def_path : path,
		    X_OK, &tp->u2.errnov);
		if (npath.ro) {
			strdupx(tp->val.s, npath.ro, APERM);
			if (npath.ro != name)
				afree(npath.rw, ATEMP);
			tp->flag |= ISSET|ALLOC;
		} else if ((flags & FC_FUNC) &&
		    (fpath = str_val(global(TFPATH))) != null &&
		    (npath.ro = search_path(name, fpath, R_OK,
		    &tp->u2.errnov)) != NULL) {
			/*
			 * An undocumented feature of AT&T ksh is that
			 * it searches FPATH if a command is not found,
			 * even if the command hasn't been set up as an
			 * autoloaded function (ie, no typeset -uf).
			 */
			tp = &temp;
			tp->type = CFUNC;
			/* make ~ISSET */
			tp->flag = DEFINED;
			tp->u.fpath = npath.ro;
		}
	}
	return (tp);
}

/*
 * flush executable commands with relative paths
 * (just relative or all?)
 */
void
flushcom(bool all)
{
	struct tbl *tp;
	struct tstate ts;

	for (ktwalk(&ts, &taliases); (tp = ktnext(&ts)) != NULL; )
		if ((tp->flag&ISSET) && (all || !mksh_abspath(tp->val.s))) {
			if (tp->flag&ALLOC) {
				tp->flag &= ~(ALLOC|ISSET);
				afree(tp->val.s, APERM);
			}
			tp->flag &= ~ISSET;
		}
}

/* check if path is something we want to find */
int
search_access(const char *fn, int mode)
{
	struct stat sb;

	if (stat(fn, &sb) < 0)
		/* file does not exist */
		return (ENOENT);
	/* LINTED use of access */
	if (access(fn, mode) < 0) {
		/* file exists, but we can't access it */
		int eno;

		eno = errno;
		return (eno ? eno : EACCES);
	}
#ifdef __OS2__
	/* treat all files as executable on OS/2 */
	sb.st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
#endif
	if (mode == X_OK && (!S_ISREG(sb.st_mode) ||
	    !(sb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
		/* access(2) may say root can execute everything */
		return (S_ISDIR(sb.st_mode) ? EISDIR : EACCES);
	return (0);
}

#ifdef __OS2__
/* check if path is something we want to find, adding executable extensions */
#define search_access(fn, mode)	access_ex((search_access), (fn), (mode))
#else
#define search_access(fn, mode)	(search_access)((fn), (mode))
#endif

/*
 * search for command with PATH
 */
const char *
search_path(const char *name, const char *lpath,
    /* R_OK or X_OK */
    int mode,
    /* set if candidate found, but not suitable */
    int *errnop)
{
	const char *sp, *p;
	char *xp;
	XString xs;
	size_t namelen;
	int ec = 0, ev;

	if (mksh_vdirsep(name)) {
		if ((ec = search_access(name, mode)) == 0) {
 search_path_ok:
			if (errnop)
				*errnop = 0;
#ifndef __OS2__
			return (name);
#else
			return (real_exec_name(name));
#endif
		}
		goto search_path_err;
	}

	namelen = strlen(name) + 1;
	Xinit(xs, xp, 128, ATEMP);

	sp = lpath;
	while (sp != NULL) {
		xp = Xstring(xs, xp);
		if (!(p = cstrchr(sp, MKSH_PATHSEPC)))
			p = strnul(sp);
		if (p != sp) {
			XcheckN(xs, xp, p - sp);
			memcpy(xp, sp, p - sp);
			xp += p - sp;
#ifdef __OS2__
			if (xp > Xstring(xs, xp) && mksh_cdirsep(xp[-1]))
				xp--;
#endif
			*xp++ = '/';
		}
		sp = p;
		XcheckN(xs, xp, namelen);
		memcpy(xp, name, namelen);
		if ((ev = search_access(Xstring(xs, xp), mode)) == 0) {
			name = Xclose(xs, xp + namelen);
			goto search_path_ok;
		}
		/* accumulate non-ENOENT errors only */
		if (ev != ENOENT && ec == 0)
			ec = ev;
		if (*sp++ == '\0')
			sp = NULL;
	}
	Xfree(xs, xp);
 search_path_err:
	if (errnop)
		*errnop = ec ? ec : ENOENT;
	return (NULL);
}

static int
call_builtin(struct tbl *tp, const char **wp, const char *where, bool resetspec)
{
	int rv;

	if (!tp)
		internal_errorf(Tf_sD_s, where, wp[0]);
	builtin_argv0 = wp[0];
	builtin_spec = tobool(!resetspec && (tp->flag & SPEC_BI));
	shf_reopen(1, SHF_WR, shl_stdout);
	shl_stdout_ok = true;
	ksh_getopt_reset(&builtin_opt, GF_ERROR);
	rv = (*tp->val.f)(wp);
	shf_flush(shl_stdout);
	shl_stdout_ok = false;
	builtin_argv0 = NULL;
	builtin_spec = false;
	return (rv);
}

/*
 * set up redirection, saving old fds in e->savefd
 */
static int
iosetup(struct ioword *iop, struct tbl *tp)
{
	int u = -1;
	char *cp = iop->ioname;
	int iotype = iop->ioflag & IOTYPE;
	bool do_open = true, do_close = false, do_fstat = false;
	int flags = 0;
	struct ioword iotmp;
	struct stat statb;

	if (iotype != IOHERE)
		cp = evalonestr(cp, DOTILDE|(Flag(FTALKING_I) ? DOGLOB : 0));

	/* Used for tracing and error messages to print expanded cp */
	iotmp = *iop;
	iotmp.ioname = (iotype == IOHERE) ? NULL : cp;
	iotmp.ioflag |= IONAMEXP;

	if (Flag(FXTRACE)) {
		change_xtrace(2, false);
		fptreef(shl_xtrace, 0, Tft_R, &iotmp);
		change_xtrace(1, false);
	}

	switch (iotype) {
	case IOREAD:
		flags = O_RDONLY;
		break;

	case IOCAT:
		flags = O_WRONLY | O_APPEND | O_CREAT;
		break;

	case IOWRITE:
		if (Flag(FNOCLOBBER) && !(iop->ioflag & IOCLOB)) {
			/* >file under set -C */
			if (stat(cp, &statb)) {
				/* nonexistent file */
				flags = O_WRONLY | O_CREAT | O_EXCL;
			} else if (S_ISREG(statb.st_mode)) {
				/* regular file, refuse clobbering */
				goto clobber_refused;
			} else {
				/*
				 * allow redirections to things
				 * like /dev/null without error
				 */
				flags = O_WRONLY;
				/* but check again after opening */
				do_fstat = true;
			}
		} else {
			/* >|file or set +C */
			flags = O_WRONLY | O_CREAT | O_TRUNC;
		}
		break;

	case IORDWR:
		flags = O_RDWR | O_CREAT;
		break;

	case IOHERE:
		do_open = false;
		/* herein() returns -2 if error has been printed */
		u = herein(iop, NULL);
		/* cp may have wrong name */
		break;

	case IODUP: {
		const char *emsg;

		do_open = false;
		if (ksh_isdash(cp)) {
			/* prevent error return below */
			u = 1009;
			do_close = true;
		} else if ((u = check_fd(cp,
		    X_OK | ((iop->ioflag & IORDUP) ? R_OK : W_OK),
		    &emsg)) < 0) {
			char *sp;

			warningf(true, Tf_sD_s,
			    (sp = snptreef(NULL, 32, Tft_R, &iotmp)), emsg);
			afree(sp, ATEMP);
			return (-1);
		}
		if (u == (int)iop->unit) {
			/* "dup from" == "dup to" */
			iop->ioflag |= IODUPSELF;
			return (0);
		}
		break;
	    }
	}

	if (do_open) {
		if (Flag(FRESTRICTED) && (flags & O_CREAT)) {
			warningf(true, Tf_sD_s, cp, "restricted");
			return (-1);
		}
		u = binopen3(cp, flags, 0666);
		if (do_fstat && u >= 0) {
			/* prevent race conditions */
			if (fstat(u, &statb) || S_ISREG(statb.st_mode)) {
				close(u);
 clobber_refused:
				u = -1;
				errno = EEXIST;
			}
		}
	}
	if (u < 0) {
		/* herein() may already have printed message */
		if (u == -1) {
			u = errno;
			warningf(true, Tf_cant_ss_s,
#if 0
			    /* can't happen */
			    iotype == IODUP ? "dup" :
#endif
			    (iotype == IOREAD || iotype == IOHERE) ?
			    Topen : Tcreate, cp, cstrerror(u));
		}
		return (-1);
	}
	/* Do not save if it has already been redirected (i.e. "cat >x >y"). */
	if (e->savefd[iop->unit] == 0) {
		/* If these are the same, it means unit was previously closed */
		if (u == (int)iop->unit)
			e->savefd[iop->unit] = -1;
		else
			/*
			 * c_exec() assumes e->savefd[fd] set for any
			 * redirections. Ask savefd() not to close iop->unit;
			 * this allows error messages to be seen if iop->unit
			 * is 2; also means we can't lose the fd (eg, both
			 * dup2 below and dup2 in restfd() failing).
			 */
			e->savefd[iop->unit] = savefd(iop->unit);
	}

	if (do_close)
		close(iop->unit);
	else if (u != (int)iop->unit) {
		if (ksh_dup2(u, iop->unit, true) < 0) {
			int eno;
			char *sp;

			eno = errno;
			warningf(true, Tf_s_sD_s, Tredirection_dup,
			    (sp = snptreef(NULL, 32, Tft_R, &iotmp)),
			    cstrerror(eno));
			afree(sp, ATEMP);
			if (iotype != IODUP)
				close(u);
			return (-1);
		}
		if (iotype != IODUP)
			close(u);
		/*
		 * Touching any co-process fd in an empty exec
		 * causes the shell to close its copies
		 */
		else if (tp && tp->type == CSHELL && tp->val.f == c_exec) {
			if (iop->ioflag & IORDUP)
				/* possible exec <&p */
				coproc_read_close(u);
			else
				/* possible exec >&p */
				coproc_write_close(u);
		}
	}
	if (u == 2)
		/* Clear any write errors */
		shf_reopen(2, SHF_WR, shl_out);
	return (0);
}

/*
 * Process here documents by providing the content, either as
 * result (globally allocated) string or in a temp file; if
 * unquoted, the string is expanded first.
 */
static int
hereinval(struct ioword *iop, int sub, char **resbuf, struct shf *shf)
{
	const char * volatile ccp = iop->heredoc;
	struct source *s, *osource;

	osource = source;
	newenv(E_ERRH);
	if (kshsetjmp(e->jbuf)) {
		source = osource;
		quitenv(shf);
		/* special to iosetup(): don't print error */
		return (-2);
	}
	if (iop->ioflag & IOHERESTR) {
		ccp = evalstr(iop->delim, DOHERESTR | DOSCALAR | DOHEREDOC);
	} else if (sub) {
		/* do substitutions on the content of heredoc */
		s = pushs(SSTRING, ATEMP);
		s->start = s->str = ccp;
		source = s;
		if (yylex(sub) != LWORD)
			internal_errorf("herein: yylex");
		source = osource;
		ccp = evalstr(yylval.cp, DOSCALAR | DOHEREDOC);
	}

	if (resbuf == NULL)
		shf_puts(ccp, shf);
	else
		strdupx(*resbuf, ccp, APERM);

	quitenv(NULL);
	return (0);
}

int
herein(struct ioword *iop, char **resbuf)
{
	int fd = -1;
	struct shf *shf;
	struct temp *h;
	int i;

	/* lexer substitution flags */
	i = (iop->ioflag & IOEVAL) ? (ONEWORD | HEREDOC) : 0;

	/* skip all the fd setup if we just want the value */
	if (resbuf != NULL)
		return (hereinval(iop, i, resbuf, NULL));

	/*
	 * Create temp file to hold content (done before newenv
	 * so temp doesn't get removed too soon).
	 */
	h = maketemp(ATEMP, TT_HEREDOC_EXP, &e->temps);
	if (!(shf = h->shf) || (fd = binopen3(h->tffn, O_RDONLY, 0)) < 0) {
		i = errno;
		warningf(true, Tf_temp,
		    !shf ? Tcreate : Topen, h->tffn, cstrerror(i));
		if (shf)
			shf_close(shf);
		/* special to iosetup(): don't print error */
		return (-2);
	}

	if (hereinval(iop, i, NULL, shf) == -2) {
		close(fd);
		/* special to iosetup(): don't print error */
		return (-2);
	}

	if (shf_close(shf) == -1) {
		i = errno;
		close(fd);
		warningf(true, Tf_temp,
		    Twrite, h->tffn, cstrerror(i));
		/* special to iosetup(): don't print error */
		return (-2);
	}

	return (fd);
}

/*
 *	ksh special - the select command processing section
 *	print the args in column form - assuming that we can
 */
static const char *
do_selectargs(const char **ap, bool print_menu)
{
	static const char *read_args[] = {
		Tread, "-r", "REPLY", NULL
	};
	char *s;
	int i, argct;

	for (argct = 0; ap[argct]; argct++)
		;
	while (/* CONSTCOND */ 1) {
		/*-
		 * Menu is printed if
		 *	- this is the first time around the select loop
		 *	- the user enters a blank line
		 *	- the REPLY parameter is empty
		 */
		if (print_menu || !*str_val(global("REPLY")))
			pr_menu(ap);
		shellf(Tf_s, str_val(global("PS3")));
		if (call_builtin(findcom(Tread, FC_BI), read_args, Tselect,
		    false))
			return (NULL);
		if (*(s = str_val(global("REPLY"))))
			return ((getn(s, &i) && i >= 1 && i <= argct) ?
			    ap[i - 1] : null);
		print_menu = true;
	}
}

struct select_menu_info {
	const char * const *args;
	int num_width;
};

/* format a single select menu item */
static void
select_fmt_entry(char *buf, size_t buflen, unsigned int i, const void *arg)
{
	const struct select_menu_info *smi =
	    (const struct select_menu_info *)arg;

	shf_snprintf(buf, buflen, "%*u) %s",
	    smi->num_width, i + 1, smi->args[i]);
}

/*
 *	print a select style menu
 */
void
pr_menu(const char * const *ap)
{
	struct select_menu_info smi;
	const char * const *pp;
	size_t acols = 0, aocts = 0, i;
	unsigned int n;
	struct columnise_opts co;

	/*
	 * width/column calculations were done once and saved, but this
	 * means select can't be used recursively so we re-calculate
	 * each time (could save in a structure that is returned, but
	 * it's probably not worth the bother)
	 */

	/*
	 * get dimensions of the list
	 */
	for (n = 0, pp = ap; *pp; n++, pp++) {
		i = strlen(*pp);
		if (i > aocts)
			aocts = i;
		i = utf_mbswidth(*pp);
		if (i > acols)
			acols = i;
	}

	/*
	 * we will print an index of the form "%d) " in front of
	 * each entry, so get the maximum width of this
	 */
	for (i = n, smi.num_width = 1; i >= 10; i /= 10)
		smi.num_width++;

	smi.args = ap;
	co.shf = shl_out;
	co.linesep = '\n';
	co.prefcol = co.do_last = true;
	print_columns(&co, n, select_fmt_entry, (void *)&smi,
	    smi.num_width + 2 + aocts, smi.num_width + 2 + acols);
}

static void
plain_fmt_entry(char *buf, size_t buflen, unsigned int i, const void *arg)
{
	strlcpy(buf, ((const char * const *)arg)[i], buflen);
}

void
pr_list(struct columnise_opts *cop, char * const *ap)
{
	size_t acols = 0, aocts = 0, i;
	unsigned int n;
	char * const *pp;

	for (n = 0, pp = ap; *pp; n++, pp++) {
		i = strlen(*pp);
		if (i > aocts)
			aocts = i;
		i = utf_mbswidth(*pp);
		if (i > acols)
			acols = i;
	}

	print_columns(cop, n, plain_fmt_entry, (const void *)ap,
	    aocts, acols);
}

/*
 *	[[ ... ]] evaluation routines
 */

/*
 * Test if the current token is a whatever. Accepts the current token if
 * it is. Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static Test_op
dbteste_isa(Test_env *te, Test_meta meta)
{
	Test_op ret = TO_NONOP;
	bool uqword;
	const char *p;

	if (!*te->pos.wp)
		return (meta == TM_END ? TO_NONNULL : TO_NONOP);

	/* unquoted word? */
	for (p = *te->pos.wp; *p == CHAR; p += 2)
		;
	uqword = *p == EOS;

	if (meta == TM_UNOP || meta == TM_BINOP) {
		if (uqword) {
			/* longer than the longest operator */
			char buf[8];
			char *q = buf;

			p = *te->pos.wp;
			while (*p++ == CHAR &&
			    (size_t)(q - buf) < sizeof(buf) - 1)
				*q++ = *p++;
			*q = '\0';
			ret = test_isop(meta, buf);
		}
	} else if (meta == TM_END)
		ret = TO_NONOP;
	else
		ret = (uqword && !strcmp(*te->pos.wp,
		    dbtest_tokens[(int)meta])) ? TO_NONNULL : TO_NONOP;

	/* Accept the token? */
	if (ret != TO_NONOP)
		te->pos.wp++;

	return (ret);
}

static const char *
dbteste_getopnd(Test_env *te, Test_op op, bool do_eval)
{
	const char *s = *te->pos.wp;
	int flags = DOTILDE | DOSCALAR;

	if (!s)
		return (NULL);

	te->pos.wp++;

	if (!do_eval)
		return (null);

	if (op == TO_STEQL || op == TO_STNEQ)
		flags |= DOPAT;

	return (evalstr(s, flags));
}

static void
dbteste_error(Test_env *te, int offset, const char *msg)
{
	te->flags |= TEF_ERROR;
	internal_warningf("dbteste_error: %s (offset %d)", msg, offset);
}
@


1.216
log
@revamp errexit handling

we lose some trap runs but this gets us identical to GNU bash so who cares
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.210 2019/08/02 19:27:15 tg Exp $");
d627 2
a628 6
		/* ksh functions don't keep assignments, POSIX functions do. */
		if (!resetspec && tp && tp->type == CFUNC &&
		    !(tp->flag & FKSH))
			type_flags = EXPORT;
		else
			type_flags = LOCAL|LOCAL_COPY|EXPORT;
@


1.215
log
@clean up and update comment
@
text
@d465 1
a465 1
	if (rv != 0 && !(flags & XERROK) && !Flag(FEVALERR) &&
d469 1
a469 1
			unwind(LERROR);
d800 1
@


1.214
log
@scared of this change but it passes tests: g/c even more

(needs style fixing-up but Ive just found another)
@
text
@d465 1
a465 1
	if (rv != 0 && !(flags & XERROK) &&
d467 3
a469 8
		if (Flag(FEVALERR)) {
			/* inside eval */
			;
		} else {
			trapsig(ksh_SIGERR);
			if (Flag(FERREXIT))
				unwind(LERROR);
		}
@


1.213
log
@scared of this change but it passes tests: g/c some more
@
text
@d469 1
a469 1
			Flag(FEVALERR) = 0;
@


1.212
log
@introduce FEVALERR to replace (FERREXIT & 0x80)

fixes set -e appears active within eval but isnt
reported by Martijn Dekker
@
text
@a469 1
			Flag(FERREXIT) = 0;
@


1.211
log
@further memory optimisation
@
text
@d467 1
a467 1
		if (Flag(FERREXIT) & 0x80) {
d469 1
@


1.210
log
@fix regression found by, again, Martijn Dekker; tricky

GCC fails to optimise (ptr1 == ptr2) * (tp->flag & FOO), so dont do it
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.205 2019/01/05 12:47:40 tg Exp $");
d111 2
a112 2
			dp = shf_smprintf(Tf_ss, evalstr(t->vars[0],
			    DOASNTILDE | DOSCALAR), rv ? null : cp);
@


1.209
log
@fix one of the issues
@
text
@d698 1
a698 1
			l_assign->flags |= BF_RESETSPEC;
d1148 4
@


1.208
log
@failed attempt at fixing 'command set' does not set PPs

bugreport by Martijn Dekker <martijn@@inlv.org>
Message-ID: <88ba843f-0a2d-ceb7-f3fa-8a880848cb07@@inlv.org>

this fails because the new argv is allocated in the temporary
environment unsure how best fix
@
text
@d697 2
a699 4
		if (resetspec && (tp->val.f == c_shift || tp->val.f == c_set)) {
			l_expand->argc = l_assign->argc;
			l_expand->argv = l_assign->argv;
		}
@


1.207
log
@return 126 on failure to execute (e.g. E2BIG), not 1

From: Martijn Dekker <martijn@@inlv.org>
Message-ID: <87a38f95-c1a6-a4eb-0085-d85688b511a1@@inlv.org>
@
text
@d698 1
a698 1
		if (resetspec && tp->val.f == c_shift) {
@


1.206
log
@improve error message for inaccessible executables (LP#1817789)
@
text
@d449 1
a449 1
			errorf(Tf_sD_s, t->str, cstrerror(rv));
@


1.205
log
@unwind with LEXIT ipv LLEAVE in XEXEC in one more place (12 of 3)

this fixes Debian #910276 and runs EXIT traps in single-child TPIPEs
and I _hope_ it does not break anything
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.202 2018/10/07 01:10:11 tg Exp $");
d830 2
a831 1
				warningf(true, Tf_sD_s, cp, Tnot_found);
@


1.204
log
@fix ksh-style close-on-exec-for-fds-above-2 in dup-to-self scenario

bugreport by catern via IRC
@
text
@d5 2
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d872 1
a872 1
		unwind(LLEAVE);
@


1.203
log
@add O_MAYEXEC support for CLIP OS, zero cost otherwise

cf. https://lwn.net/Articles/768819/
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d432 6
d1494 1
a1494 1
		if (u == (int)iop->unit)
d1496 1
d1498 1
@


1.202
log
@spelling cleanup: programme is distinct from program; even in
British English, the latter is used for computer programs, while
the former serves for things like the TV programme, or a programme
to plant trees
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.201 2017/10/11 21:09:24 tg Exp $");
d889 1
a889 1
	if ((fd = binopen2(tp->str, O_RDONLY)) >= 0) {
@


1.201
log
@all uses of mksh_vdirsep should exclude \builtin from triggering it
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.200 2017/10/11 21:04:59 tg Exp $");
d1014 1
a1014 1
	/* report both the programme that was run and the bogus interpreter */
@


1.200
log
@update comment to unpuzzle a future me

(I just had to use git annotate and look at the two commits from komh
to figure out that the condition in the if is correct here and what
this is supposed to do)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.193 2017/04/02 15:00:42 tg Exp $");
d1175 1
a1175 5
	if (mksh_vdirsep(name)
#ifdef MKSH_DOSPATH
	    && (strcmp(name, T_builtin) != 0)
#endif
	    ) {
@


1.199
log
@fuck POSIX
@
text
@d956 6
a961 2
		 * Search shell/interpreter name without directory in PATH
		 * if specified path does not exist
@


1.198
log
@use strnul(); optimise
@
text
@d557 3
@


1.197
log
@commit the optimisation result from the new fast character classes
@
text
@d1344 1
a1344 1
			p = sp + strlen(sp);
@


1.196
log
@(very few) fixes and a couple of workarounds for Coverity
@
text
@d888 1
d890 1
d910 1
a910 1
		while (*cp && *cp != '\n')
d925 1
a925 1
		    (cp[7] == ' ' || cp[7] == '\t'))
d931 1
a931 1
		while (*cp == ' ' || *cp == '\t')
d939 1
a939 1
		while (*cp != ' ' && *cp != '\t' && *cp != '\0')
d945 1
a945 1
			while (*cp == ' ' || *cp == '\t')
d964 1
d983 1
@


1.195
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d379 2
a380 3
		rv = execute(t->left, XERROK, NULL) == 0 ?
		    execute(t->right->left, flags & XERROK, xerrok) :
		    execute(t->right->right, flags & XERROK, xerrok);
d1509 2
d1512 1
@


1.194
log
@do not use getenv() to allow users to change OS2_SHELL during the session
@
text
@d809 1
a809 1
			internal_errorf(Tf_sd, "CFUNC", i);
d1509 1
a1509 1
			warningf(true, Tf_cant,
@


1.193
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.188 2017/03/11 22:58:51 tg Exp $");
d985 1
a985 1
			sh = getenv("OS2_SHELL");
@


1.192
log
@split path-specific ('C:\FOO' instead of '/foo') stuff into MKSH_DOSPATH:
 backslashes as directory separators
 semicolon as $PATH separator
 drive letters are absolute paths
@
text
@d892 3
d950 11
d981 13
d1297 7
d1325 1
d1327 3
d1346 4
@


1.191
log
@fixup \builtin on OS/2; thanks komh for spotting this
@
text
@d1139 1
a1139 1
#ifdef __OS2__
@


1.190
log
@add a \builtin builtin, make it forward assignments, fix some bugs
related to that:
 while AT&T ksh may do it, POSIX says nothing about allowing
  declaration commands only without vars and redirections, and
  without vars especially seems against which commands they are
 fix relationship between forwarders and real declaration commands
 clean up c_builtin vs shcomexec mess

Also, re-run make repool with a fixed src/scripts/stringpool.sh,v 1.3
@
text
@d1138 5
a1142 1
	if (mksh_vdirsep(name)) {
@


1.189
log
@add \builtin utility
@
text
@d985 7
a991 2
	return (call_builtin(ktsearch(&builtins, *wp, hash(*wp)), wp,
	    Tbuiltin, false));
d1097 8
@


1.188
log
@remove odd use of KEEPASN, I believe it really unnecessary now
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.184 2016/11/11 20:14:17 tg Exp $");
d981 1
d983 1
a983 1
shcomexec(const char **wp)
d985 2
a986 4
	struct tbl *tp;

	tp = ktsearch(&builtins, *wp, hash(*wp));
	return (call_builtin(tp, wp, "shcomexec", false));
@


1.187
log
@fix embarassing pasto and OS/2 UNC logic; thanks komh!
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d1322 1
a1322 3
	builtin_spec = tobool(!resetspec &&
	    /*XXX odd use of KEEPASN */
	    ((tp->flag & SPEC_BI) || (Flag(FPOSIX) && (tp->flag & KEEPASN))));
@


1.186
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS APEX (Ronald G. Minnich, Elbing Miss, lvaro Jurado)
more from komhs OS/2 port (KO Myung-Hun)
@
text
@d1245 1
a1245 1
	sb.st_mode &= S_IXUSR | S_IXGRP | S_IXOTH;
@


1.185
log
@make print -c honour line separator
@
text
@d675 1
a675 1
		if (Flag(FRESTRICTED) && vstrchr(cp, '/')) {
d1126 1
a1126 1
	if (vstrchr(name, '/')) {
d1243 4
d1248 1
a1248 1
	    !(sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))))
d1270 1
a1270 1
	if (vstrchr(name, '/')) {
@


1.184
log
@put print_columns options into a helper struct, eases passing things around
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.171 2016/01/21 18:24:39 tg Exp $");
d1689 2
a1690 1
	co.prefcol = true;
@


1.183
log
@first implementation of print -c for columnising, currently hardcoded newlines
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.182 2016/10/02 22:21:46 tg Exp $");
d1659 1
d1688 4
a1691 3
	print_columns(shl_out, n, select_fmt_entry, (void *)&smi,
	    smi.num_width + 2 + aocts, smi.num_width + 2 + acols,
	    true);
d1701 1
a1701 1
pr_list(struct shf *shf, char * const *ap)
d1716 2
a1717 2
	print_columns(shf, n, plain_fmt_entry, (const void *)ap,
	    aocts, acols, false);
@


1.182
log
@fix error propagation in TAND/TOR constructs, noted by Martijn Dekker

still a bit unsure about the whole XERROK and *xerrok stuff, but
it seems to work
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.171 2016/01/21 18:24:39 tg Exp $");
d1699 1
a1699 1
pr_list(char * const *ap)
d1714 1
a1714 1
	print_columns(shl_out, n, plain_fmt_entry, (const void *)ap,
@


1.181
log
@fix English (thanks to Andreas Buschka); TIL:
 to start  a start
 to begin  a beginning
@
text
@d285 1
a285 1
		rv = execute(t->left, XERROK, xerrok);
@


1.180
log
@simplify manpage and code; streamline manpage formatting and Satzzeichen
@
text
@d914 1
a914 1
		/* restore begin of shebang position (buf+0 or buf+3) */
@


1.179
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtcs programmable tab completion)
to the manpage
@
text
@d342 2
a343 6
			/* TSELECT */
			for (;;) {
				if (!(ccp = do_selectargs(ap, is_first))) {
					rv = 1;
					break;
				}
d347 1
d349 1
@


1.178
log
@rework string pooling; disable our own (rely on compilers)
 if HAVE_STRING_POOLING is set to 1
 if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
 if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d393 1
@


1.177
log
@invent builtin flags instead of special-casing cat and printf for prefer-external-over-builtin stuff
@
text
@d110 1
a110 1
			dp = shf_smprintf("%s%s", evalstr(t->vars[0],
d444 1
a444 1
			errorf("%s: %s", t->str, cstrerror(rv));
d535 1
a535 1
				errorf("%s: %s: %s", Tbuiltin, cp, "not a builtin");
d576 1
a576 1
					warningf(true, "%s: %s",
d677 1
a677 1
			warningf(true, "%s: %s", cp, "restricted");
d708 2
a709 2
				warningf(true, "%s: %s %s: %s", cp,
				    "can't find", "function definition file",
d729 1
a729 1
				warningf(true, "%s: %s %s", cp,
d810 1
a810 1
			internal_errorf("%s %d", "CFUNC", i);
d822 1
a822 1
				warningf(true, "%s: %s", cp, "not found");
d825 1
a825 1
				warningf(true, "%s: %s: %s", cp, "can't execute",
d879 1
a879 1
	sh = str_val(global("EXECSHELL"));
d979 1
a979 1
	errorf("%s: %s: %s", tp->str, sh, cstrerror(errno));
d1143 1
a1143 1
			if ((fpath = str_val(global("FPATH"))) == null) {
d1188 1
a1188 1
		    (fpath = str_val(global("FPATH"))) != null &&
d1317 1
a1317 1
		internal_errorf("%s: %s", where, wp[0]);
d1357 1
a1357 1
		fptreef(shl_xtrace, 0, "%R", &iotmp);
d1418 2
a1419 2
			warningf(true, "%s: %s",
			    (sp = snptreef(NULL, 32, "%R", &iotmp)), emsg);
d1432 1
a1432 1
			warningf(true, "%s: %s", cp, "restricted");
d1450 1
a1450 1
			warningf(true, "can't %s %s: %s",
d1453 1
a1453 1
			    "open" : "create", cp, cstrerror(u));
d1481 2
a1482 3
			warningf(true, "%s %s: %s",
			    "can't finish (dup) redirection",
			    (sp = snptreef(NULL, 32, "%R", &iotmp)),
d1573 2
a1574 2
		warningf(true, "can't %s temporary file %s: %s",
		    !shf ? "create" : "open", h->tffn, cstrerror(i));
d1590 2
a1591 2
		warningf(true, "can't %s temporary file %s: %s",
		    "write", h->tffn, cstrerror(i));
d1607 1
a1607 1
		"read", "-r", "REPLY", NULL
d1623 2
a1624 2
		shellf("%s", str_val(global("PS3")));
		if (call_builtin(findcom("read", FC_BI), read_args, Tselect,
@


1.176
log
@optimise away code for a case thats almost unlikely to happen; fix pasto(?)
@
text
@d536 1
a536 5
			if (tp->type == CSHELL && (tp->val.f == c_cat
#ifdef MKSH_PRINTF_BUILTIN
			    || tp->val.f == c_printf
#endif
			    ))
d594 1
a594 1
		} else if (tp->val.f == c_cat) {
d596 1
a596 1
			if (ap[1] && ap[1][0] == '-' && ap[1][1] != '\0' &&
d598 9
a606 7
			    (ap[1][1] != '-' || ap[1][2] != '\0')) {
				struct tbl *ext_cat;

				ext_cat = findcom(Tcat, FC_PATH | FC_FUNC);
				if (ext_cat && (ext_cat->type != CTALIAS ||
				    (ext_cat->flag & ISSET)))
					tp = ext_cat;
a608 10
#ifdef MKSH_PRINTF_BUILTIN
		} else if (tp->val.f == c_printf) {
			struct tbl *ext_printf;

			ext_printf = findcom(Tprintf, FC_PATH | FC_FUNC);
			if (ext_printf && (ext_printf->type != CTALIAS ||
			    (ext_printf->flag & ISSET)))
				tp = ext_printf;
			break;
#endif
d718 4
a721 7
				if (!strcmp(cp, Tcat)) {
					tp = findcom(Tcat, FC_BI);
					goto do_call_builtin;
				}
#ifdef MKSH_PRINTF_BUILTIN
				if (!strcmp(cp, Tprintf)) {
					tp = findcom(Tprintf, FC_BI);
a723 1
#endif
d1076 20
a1095 10
	while (1) {
		if (*name == '=')
			/* command does variable assignment */
			flag |= KEEPASN;
		else if (*name == '*')
			/* POSIX special builtin */
			flag |= SPEC_BI;
		else
			break;
		name++;
d1097 3
d1101 1
d1107 1
@


1.175
log
@efficient $(<<<foo) and $(<<EOF  ) implementation, requested by izabera
@
text
@d718 1
d725 5
a729 1
			if (include(tp->u.fpath, 0, NULL, false) < 0) {
a730 1
 no_cat_in_FPATH:
a735 1
 no_printf_in_FPATH:
d740 5
a744 14
				warningf(true, "%s: %s %s %s: %s", cp,
				    "can't open", "function definition file",
				    tp->u.fpath, cstrerror(errno));
				rv = 127;
				break;
			}
			if (!(ftp = findfunc(cp, hash(cp), false)) ||
			    !(ftp->flag & ISSET)) {
				if (!strcmp(cp, Tcat))
					goto no_cat_in_FPATH;
#ifdef MKSH_PRINTF_BUILTIN
				if (!strcmp(cp, Tprintf))
					goto no_printf_in_FPATH;
#endif
@


1.174
log
@fix var=<< implementation
@
text
@a36 1
static int herein(struct ioword *, char **);
d1559 1
a1559 1
static int
@


1.173
log
@fix redefining FKSH functions as !FKSH (e.g. the smores change)
@
text
@a62 1
	char *cp;
d81 9
a90 2
		/*XXX this is broken, dont use! */
		/*XXX https://bugs.launchpad.net/mksh/+bug/1380389 */
d92 1
a92 1
		    /* we have zero arguments, i.e. no programme to run */
d106 8
a113 23
		    ccp[3] == '=' && ccp[4] == EOS)) &&
		    /* plus we can have a here document content */
		    herein(t->ioact[0], &cp) == 0 && cp && *cp) {
			char *sp = cp, *dp;
			size_t n = ccp - t->vars[0] + (ccp[1] == '+' ? 4 : 2);
			size_t z;

			/* drop redirection (will be garbage collected) */
			t->ioact = NULL;

			/* set variable to its expanded value */
			z = strlen(cp);
			if (notoktomul(z, 2) || notoktoadd(z * 2, n + 1))
				internal_errorf(Toomem, (size_t)-1);
			dp = alloc(z * 2 + n + 1, APERM);
			memcpy(dp, t->vars[0], n);
			t->vars[0] = dp;
			dp += n;
			while (*sp) {
				*dp++ = QCHAR;
				*dp++ = *sp++;
			}
			*dp = EOS;
d116 2
a120 9
		 * Clear subst_exstat before argument expansion. Used by
		 * null commands (see comexec() and c_eval()) and by c_set().
		 */
		subst_exstat = 0;

		/* for $LINENO */
		current_lineno = t->lineno;

		/*
@


1.172
log
@check not-begun heredocs at EOF earlier

izabera reported they were not caught with set -n
@
text
@d1087 1
a1087 1
		tp->flag &= ~(ISSET|ALLOC);
@


1.171
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.147 2015/03/20 23:37:54 tg Exp $");
a1583 7
	/* ksh -c 'cat <<EOF' can cause this... */
	if (iop->heredoc == NULL && !(iop->ioflag & IOHERESTR)) {
		warningf(true, Tmissinghere);
		/* special to iosetup(): don't print error */
		return (-2);
	}

@


1.170
log
@fstat(2) after open(2) for set -C case when initial stat(2) was !S_ISREG
to fix race condition as suggested by jilles
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d1562 1
a1562 1
			internal_errorf("%s: %s", "herein", "yylex");
d1586 1
a1586 1
		warningf(true, "%s missing", "here document");
@


1.169
log
@also recognise ksh93 compiled binaries and LZIP compressed files
@
text
@d1366 1
a1366 1
	bool do_open = true, do_close = false;
d1395 21
a1415 8
		flags = O_WRONLY | O_CREAT | O_TRUNC;
		/*
		 * The stat() is here to allow redirections to
		 * things like /dev/null without error.
		 */
		if (Flag(FNOCLOBBER) && !(iop->ioflag & IOCLOB) &&
		    (stat(cp, &statb) < 0 || S_ISREG(statb.st_mode)))
			flags |= O_EXCL;
d1460 9
@


1.168
log
@make source into a built-in command (keepasn, to match ksh93 and dot);
remove the stop alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d1002 1
@


1.167
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@a41 1
static int search_access(const char *, int);
a1066 8
#ifdef MKSH_LEGACY_MODE
	if (t != NULL && !tobool(t->u.ksh_func)) {
		/* drop same-name aliases for POSIX functions */
		if ((tp = ktsearch(&aliases, name, nhash)))
			ktdelete(tp);
	}
#endif

d1251 1
a1251 1
static int
@


1.166
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d1372 1
a1372 1
	char *cp = iop->name;
d1384 1
a1384 1
	iotmp.name = (iotype == IOHERE) ? NULL : cp;
@


1.165
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d1351 3
a1353 1
	builtin_spec = tobool(!resetspec && (tp->flag & SPEC_BI));
@


1.164
log
@a bit more careful, even if probably unnecessary
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.51 2015/04/18 18:28:36 deraadt Exp $	*/
@


1.163
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
d1269 1
a1269 1
	if (access(fn, mode) < 0)
d1271 5
a1275 1
		return (errno);
@


1.162
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d1521 1
a1521 1
hereinval(const char *content, int sub, char **resbuf, struct shf *shf)
d1523 1
a1523 1
	const char * volatile ccp = content;
d1534 3
a1536 1
	if (sub) {
d1565 1
a1565 1
	if (iop->heredoc == NULL) {
d1576 1
a1576 1
		return (hereinval(iop->heredoc, i, resbuf, NULL));
d1593 1
a1593 1
	if (hereinval(iop->heredoc, i, NULL, shf) == -2) {
@


1.161
log
@add missing colon to two error msgs (no effect on dedup)
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.160
log
@merge OS/2 style PATH (absolute with drive letters, ; as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d1485 1
a1485 1
			warningf(true, "%s %s %s",
@


1.159
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d29 1
a29 1
#define MKSH_DEFAULT_EXECSHELL	"/bin/sh"
d1250 1
a1250 1
		if ((tp->flag&ISSET) && (all || tp->val.s[0] != '/')) {
d1311 1
a1311 1
		if (!(p = cstrchr(sp, ':')))
@


1.158
log
@apply the new cat hack to printf, too, to prefer it over the builtin
@
text
@d928 1
a928 1
	if ((fd = open(tp->str, O_RDONLY | O_BINARY)) >= 0) {
d1448 1
a1448 1
		u = open(cp, flags | O_BINARY, 0666);
d1581 1
a1581 1
	if (!(shf = h->shf) || (fd = open(h->tffn, O_RDONLY | O_BINARY, 0)) < 0) {
@


1.157
log
@more mksh-os2 inspired hackery
@
text
@d554 5
a558 1
			if (tp->type == CSHELL && tp->val.f == c_cat)
d629 10
d748 7
d765 4
@


1.156
log
@more easy OS/2 fixes

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d976 4
a979 1
		    (m == /* "MZ" */ 0x4D5A) ||
@


1.155
log
@ revert the cat hack for realpath and rename
   I was convinced by several that more magic is never the solution
 fix a comment: function cat already had precedence
 change cat loader to look for existence, FPATH included, before
  ditching the builtin; note that in manpage
@
text
@d933 8
a940 1
		if ((cp[0] != '#') || (cp[1] != '!'))
a941 2

		cp += 2;
@


1.154
log
@implement cat thing for realpath and rename too: if flag, call external
@
text
@d554 2
d612 1
a612 14
#if !defined(MKSH_NO_EXTERNAL_CAT) || \
    !defined(MKSH_NO_EXTERNAL_REALPATH) || \
    !defined(MKSH_NO_EXTERNAL_RENAME)
		} else if (
#ifndef MKSH_NO_EXTERNAL_CAT
		    tp->val.f == c_cat ||
#endif
#ifndef MKSH_NO_EXTERNAL_REALPATH
		    tp->val.f == c_realpath ||
#endif
#ifndef MKSH_NO_EXTERNAL_RENAME
		    tp->val.f == c_rename ||
#endif
		    0) {
d616 9
a624 7
			    (ap[1][1] != '-' || ap[1][2] != '\0'))
				/* don't look for builtins or functions */
				fcflags = FC_PATH;
			else
				/* go on, use the builtin */
				break;
#endif
d704 1
d729 5
d742 2
@


1.153
log
@simplify print_columns func argument: no need to return the first arg any more
@
text
@d610 4
d615 10
a624 9
		} else if (tp->val.f == c_cat) {
			/*
			 * if we have any flags, do not use the builtin
			 * in theory, we could allow -u, but that would
			 * mean to use ksh_getopt here and possibly ad-
			 * ded complexity and more code and isn't worth
			 * additional hassle (and the builtin must call
			 * ksh_getopt already but can't come back here)
			 */
@


1.152
log
@use already-existing ksh_isdash helper macro
@
text
@d44 2
a45 2
static char *plain_fmt_entry(char *, size_t, unsigned int, const void *);
static char *select_fmt_entry(char *, size_t, unsigned int, const void *);
d1613 1
a1613 1
static char *
a1620 1
	return (buf);
d1666 1
a1666 1
static char *
a1669 1
	return (buf);
@


1.151
log
@a bit oksh-inspired getn return value checking, plus some code optimisation
@
text
@d1385 1
a1385 1
		if (*cp == '-' && !cp[1]) {
@


1.150
log
@oksh RCSID sync: we use mksh getn() instead of OS strtonum() which is just as safe (audited right now)
@
text
@d1600 3
a1602 3
		s = str_val(global("REPLY"));
		if (*s && getn(s, &i))
			return ((i >= 1 && i <= argct) ? ap[i - 1] : null);
@


1.149
log
@Implement the FKSH functions have local scope for shell options feature
for mksh but not lksh; bump to R51-alpha.

While here, tweak build scripts a bit, fixup MirBSD-specific Makefile
things, remove part of a comment thats uninteresting.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.50 2013/06/10 21:09:27 millert Exp $	*/
@


1.148
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named flag, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasnt much to be found.
@
text
@a716 1
		volatile unsigned char old_xflag;
d719 1
d771 3
a773 2
		old_xflag = Flag(FXTRACE) ? 1 : 0;
		change_xtrace((Flag(FXTRACEREC) ? old_xflag : 0) |
d785 9
a793 1
		change_xtrace(old_xflag, false);
d798 1
a798 2
		 * execution tree. TODO: Unfortunately, the table entry
		 * is never re-used until the lookup table is expanded.
@


1.147
log
@only lksh now implies unalias for a POSIX function definition (used e.g. in Debian sysvinit scripts that use a stop function)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.139 2014/11/25 22:46:58 tg Exp $");
d95 1
a95 1
		    (t->ioact[0]->flag & IOTYPE) == IOHERE &&
d1322 1
a1322 1
	int iotype = iop->flag & IOTYPE;
d1334 1
a1334 1
	iotmp.flag |= IONAMEXP;
d1357 1
a1357 1
		if (Flag(FNOCLOBBER) && !(iop->flag & IOCLOB) &&
d1382 1
a1382 1
		    X_OK | ((iop->flag & IORDUP) ? R_OK : W_OK),
d1391 1
a1391 1
		if (u == iop->unit)
d1419 1
a1419 1
		if (u == iop->unit)
d1434 1
a1434 1
	else if (u != iop->unit) {
d1456 1
a1456 1
			if (iop->flag & IORDUP)
d1525 1
a1525 1
	i = (iop->flag & IOEVAL) ? (ONEWORD | HEREDOC) : 0;
@


1.146
log
@ fixup here document expansion (regression wrt. pdksh 5.2.14)
 adjust testsuite (and write tons of new tests) after todays commits
@
text
@d1023 1
d1029 1
@


1.145
log
@basically unbreak use of $*/$@@ in here documents

a bit funny:
with NUL IFS, $* behaves like dash ('ab') and $@@ like bash/ksh93 ('a b')

with WS or NWS IFS, all shells behave alike though
@
text
@d1495 1
a1495 1
		ccp = evalstr(yylval.cp, DOSCALAR);
@


1.144
log
@fix use of $*/$@@ in scalar context in [[  ]] and case; spotted by Stphane Chazelas
@
text
@d1495 1
a1495 1
		ccp = evalstr(yylval.cp, 0);
@


1.143
log
@add getopts for exec (unbreaks exec -- /bin/ls) and steal -a and -c from ksh93
@
text
@d406 1
a406 1
		ccp = evalstr(t->str, DOTILDE);
d1738 1
d1749 1
a1749 3
		s = evalstr(s, DOTILDE | DOPAT);
	else
		s = evalstr(s, DOTILDE);
d1751 1
a1751 1
	return (s);
@


1.142
log
@stop (ab)using the OS symbolic constant EOF, always use -1; plus misc fixes
@
text
@a448 1
		s = t->args[0];
d462 1
a462 1
			errorf("%s: %s", s, cstrerror(rv));
d511 2
d558 16
a573 1
			ap++;
d652 2
d834 1
a834 1
		/* set $_ to programme's full path */
d839 11
a849 1
		if (flags&XEXEC) {
d851 1
a851 1
			if (!(flags&XBGND)
a860 6
		/* to fork we set up a TEXEC node and call execute */
		texec.type = TEXEC;
		/* for tprint */
		texec.left = t;
		texec.str = tp->val.s;
		texec.args = ap;
@


1.141
log
@int  bool
@
text
@a509 1
	bool bourne_function_call = false;
d511 1
d513 1
a513 6
	/*
	 * snag the last argument for $_ XXX not the same as AT&T ksh,
	 * which only seems to set $_ after a newline (but not in
	 * functions/dot scripts, but in interactive and script) -
	 * perhaps save last arg here and set it in shell()?.
	 */
d515 6
a559 1
			int optc;
d569 1
a569 1
			if (optc != EOF)
d630 1
a630 2
		    !(tp->flag & FKSH)) {
			bourne_function_call = true;
d632 1
a632 1
		} else
d1493 1
a1493 1
	/* ksh -c 'cat << EOF' can cause this... */
d1528 1
a1528 1
	if (shf_close(shf) == EOF) {
@


1.140
log
@remove dead code: this can no longer happen since exec.c,v 1.67
@
text
@d559 2
a560 1
			int optc, saw_p = 0;
d568 1
a568 1
				saw_p = 1;
@


1.139
log
@fix shebang/magic decoding
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.138 2014/11/25 21:13:24 tg Exp $");
a658 2
		if (bourne_function_call && !(type_flags & EXPORT))
			typeset(cp, LOCAL | LOCAL_COPY | EXPORT, 0, 0, 0);
@


1.138
log
@ Build.sh: fix NSIG detection for gcc-snapshot
 all: bump version to R50-current; add more comments; whitespace
 all: remove all mkssert(); well do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
 check.t: fix a testcase (sed could exit false, but we dont care)
 eval.c: fix tilde_ok data type (only unsigned may shl constantly)
 exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.137 2014/10/19 21:53:07 tg Exp $");
a856 3
	unsigned char *cp;
	/* 64 == MAXINTERP in MirBSD <sys/param.h> */
	char buf[64];
d858 1
d872 6
a877 4
		/* read first MAXINTERP octets from file */
		if (read(fd, buf, sizeof(buf)) <= 0)
			/* read error -> no good */
			buf[0] = '\0';
d879 5
d886 6
a891 13
		cp = (unsigned char *)buf;
		if ((cp[0] == 0xEF) && (cp[1] == 0xBB) && (cp[2] == 0xBF))
			cp += 3;
		/* save begin of shebang for later */
		fd = (char *)cp - buf;		/* either 0 or (if BOM) 3 */

		/* scan for newline (or CR) or NUL _before_ end of buffer */
		while ((size_t)((char *)cp - buf) < sizeof(buf))
			if (*cp == '\0' || *cp == '\n' || *cp == '\r') {
				*cp = '\0';
				break;
			} else
				++cp;
d893 1
a893 1
		if ((size_t)((char *)cp - buf) >= sizeof(buf))
d895 2
d899 2
a900 2
		cp = (unsigned char *)(buf + fd);
		/* bail out if read error (above) or no shebang */
d926 1
d928 2
a929 3
		cp = (unsigned char *)buf;
		if (cp[0] == 0x7F && cp[1] == 'E' && cp[2] == 'L' &&
		    cp[3] == 'F')
d931 13
a943 12
			    32 * cp[4]);
		fd = cp[0] << 8 | cp[1];
		if ((fd == /* OMAGIC */ 0407) ||
		    (fd == /* NMAGIC */ 0410) ||
		    (fd == /* ZMAGIC */ 0413) ||
		    (fd == /* QMAGIC */ 0314) ||
		    (fd == /* ECOFF_I386 */ 0x4C01) ||
		    (fd == /* ECOFF_M68K */ 0x0150 || fd == 0x5001) ||
		    (fd == /* ECOFF_SH */   0x0500 || fd == 0x0005) ||
		    (fd == /* "MZ" */ 0x4D5A) ||
		    (fd == /* gzip */ 0x1F8B))
			errorf("%s: not executable: magic %04X", tp->str, fd);
@


1.137
log
@first cut at LP#1381993 (probably incomplete) plus test coverage
also remove fbsd testsuite link, its gone during cvssvn of theirs 
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.136 2014/10/12 21:58:50 tg Exp $");
d927 3
a929 2
		if (buf[0] == 0x7F && buf[1] == 'E' && buf[2] == 'L' &&
		    buf[3] == 'F')
d931 2
a932 2
			    32 * ((uint8_t)buf[4]));
		fd = buf[0] << 8 | buf[1];
a1009 2
		/* because findfunc:create=true */
		mkssert(tp != NULL);
@


1.137.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
 pull check.t,v up to 1.672 from 1.667
 pull dot.mkshrc,v up to 1.91 from 1.89
 pull edit.c,v up to 1.277 from 1.276
 pull exec.c,v up to 1.139 from 1.137
 pull lex.c,v up to 1.195 from 1.193
 pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
 apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
 apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after whence -v with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.139 2014/11/25 22:46:58 tg Exp $");
d857 3
a860 1
	unsigned char buf[68];
d874 4
a877 6
		unsigned char *cp;
		unsigned short m;
		ssize_t n;

		/* read first couple of octets from file */
		n = read(fd, buf, sizeof(buf) - 1);
a878 5
		/* read error or short read? */
		if (n < 5)
			goto nomagic;
		/* terminate buffer */
		buf[n] = '\0';
d881 13
a893 6
		cp = buf + (n = ((buf[0] == 0xEF) && (buf[1] == 0xBB) &&
		    (buf[2] == 0xBF)) ? 3 : 0);

		/* scan for newline or NUL (end of buffer) */
		while (*cp && *cp != '\n')
			++cp;
d895 1
a895 1
		if (!*cp)
a896 2
		/* replace newline by NUL */
		*cp = '\0';
d899 2
a900 2
		cp = buf + n;
		/* bail out if no shebang magic found */
a925 1
		goto nomagic;
d927 2
a928 2
		m = buf[0] << 8 | buf[1];
		if (m == 0x7F45 && buf[2] == 'L' && buf[3] == 'F')
d930 12
a941 13
			    32 * buf[4]);
		if ((m == /* OMAGIC */ 0407) ||
		    (m == /* NMAGIC */ 0410) ||
		    (m == /* ZMAGIC */ 0413) ||
		    (m == /* QMAGIC */ 0314) ||
		    (m == /* ECOFF_I386 */ 0x4C01) ||
		    (m == /* ECOFF_M68K */ 0x0150 || m == 0x5001) ||
		    (m == /* ECOFF_SH */   0x0500 || m == 0x0005) ||
		    (m == /* "MZ" */ 0x4D5A) ||
		    (m == /* gzip */ 0x1F8B) || (m == /* .Z */ 0x1F9D))
			errorf("%s: not executable: magic %04X", tp->str, m);
 nomagic:
		;
d1009 2
@


1.137.2.2
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.137.2.1 2015/01/11 22:39:48 tg Exp $");
d406 1
a406 1
		ccp = evalstr(t->str, DOTILDE | DOSCALAR);
d449 1
d463 1
a463 1
			errorf("%s: %s", t->str, cstrerror(rv));
d510 1
a511 3
	int optc;
	const char *exec_argv0 = NULL;
	bool exec_clrenv = false;
d513 6
a518 1
	/* snag the last argument for $_ */
a519 6
		/*
		 * XXX not the same as AT&T ksh, which only seems to set $_
		 * after a newline (but not in functions/dot scripts, but in
		 * interactive and script) - perhaps save last arg here and
		 * set it in shell()?.
		 */
d556 1
a556 16
			ksh_getopt_reset(&builtin_opt, GF_ERROR);
			while ((optc = ksh_getopt(ap, &builtin_opt, "a:c")) != -1)
				switch (optc) {
				case 'a':
					exec_argv0 = builtin_opt.optarg;
					break;
				case 'c':
					exec_clrenv = true;
					/* ensure we can actually do this */
					resetspec = true;
					break;
				default:
					rv = 2;
					goto Leave;
				}
			ap += builtin_opt.optind;
d559 1
a559 1
			bool saw_p = false;
d567 2
a568 2
				saw_p = true;
			if (optc != -1)
d629 2
a630 1
		    !(tp->flag & FKSH))
d632 1
a632 1
		else
a635 2
	if (exec_clrenv)
		l_assign->flags |= BF_STOPENV;
d659 2
d818 1
a818 1
		/* set $_ to program's full path */
d823 1
a823 11
		/* to fork, we set up a TEXEC node and call execute */
		texec.type = TEXEC;
		/* for vistree/dumptree */
		texec.left = t;
		texec.str = tp->val.s;
		texec.args = ap;

		/* in this case we do not fork, of course */
		if (flags & XEXEC) {
			if (exec_argv0)
				texec.args[0] = exec_argv0;
d825 1
a825 1
			if (!(flags & XBGND)
d835 6
d1475 1
a1475 1
		ccp = evalstr(yylval.cp, DOSCALAR | DOHEREDOC);
d1495 1
a1495 1
	/* ksh -c 'cat <<EOF' can cause this... */
d1530 1
a1530 1
	if (shf_close(shf) == -1) {
a1717 1
	int flags = DOTILDE | DOSCALAR;
d1728 3
a1730 1
		flags |= DOPAT;
d1732 1
a1732 1
	return (evalstr(s, flags));
@


1.137.2.3
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.137.2.2 2015/03/01 15:42:59 tg Exp $");
d95 1
a95 1
		    (t->ioact[0]->ioflag & IOTYPE) == IOHERE &&
d789 2
a790 1
		 * execution tree.
d1320 1
a1320 1
	int iotype = iop->ioflag & IOTYPE;
d1332 1
a1332 1
	iotmp.ioflag |= IONAMEXP;
d1355 1
a1355 1
		if (Flag(FNOCLOBBER) && !(iop->ioflag & IOCLOB) &&
d1380 1
a1380 1
		    X_OK | ((iop->ioflag & IORDUP) ? R_OK : W_OK),
d1389 1
a1389 1
		if (u == (int)iop->unit)
d1417 1
a1417 1
		if (u == (int)iop->unit)
d1432 1
a1432 1
	else if (u != (int)iop->unit) {
d1454 1
a1454 1
			if (iop->ioflag & IORDUP)
d1523 1
a1523 1
	i = (iop->ioflag & IOEVAL) ? (ONEWORD | HEREDOC) : 0;
@


1.137.2.4
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.51 2015/04/18 18:28:36 deraadt Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.137.2.3 2015/04/12 22:32:25 tg Exp $");
d1589 3
a1591 3
		if (*(s = str_val(global("REPLY"))))
			return ((getn(s, &i) && i >= 1 && i <= argct) ?
			    ap[i - 1] : null);
@


1.136
log
@POSIX says command loses SPEC_BI and means it too

reported by ormaaj, who even asked on the austin ML
http://thread.gmane.org/gmane.comp.standards.posix.austin.general/9907/focus=9931
clarified by jilles; also make errorlevels match ksh93
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.134 2014/10/12 19:55:00 tg Exp $");
d643 1
a643 1
		cp = evalstr(t->vars[i], DOASNTILDE | DOASNFIELD);
@


1.135
log
@fix size calculations; prefer memleak over segfault; see LP#1380389 for more
@
text
@d35 1
a35 1
static int call_builtin(struct tbl *, const char **, const char *);
d508 1
a508 1
	bool keepasn_ok;
d540 1
a540 1
	keepasn_ok = true;
d587 1
a587 1
			keepasn_ok = false;
d622 1
a622 1
	if (keepasn_ok && (!ap[0] || (tp && (tp->flag & KEEPASN))))
d628 1
a628 1
		if (keepasn_ok && tp && tp->type == CFUNC &&
d692 2
a693 2
		rv = call_builtin(tp, (const char **)ap, null);
		if (!keepasn_ok && tp->val.f == c_shift) {
d960 1
a960 1
	return (call_builtin(tp, wp, "shcomexec"));
d1273 1
a1273 1
call_builtin(struct tbl *tp, const char **wp, const char *where)
d1280 1
a1280 1
	builtin_flag = tp->flag;
a1286 1
	builtin_flag = 0;
d1288 1
d1567 2
a1568 1
		if (call_builtin(findcom("read", FC_BI), read_args, Tselect))
@


1.134
log
@fix x+=<<
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.133 2014/10/03 17:32:11 tg Exp $");
d84 2
d112 2
a113 2
			z = strlen(cp) + 1;
			if (notoktomul(z, 2) || notoktoadd(z * 2, n))
d115 1
a115 1
			dp = alloc(z * 2 + n, ATEMP);
@


1.133
log
@overhaul IFS handling, fix bugs reported by Stephane Chazelas and mikeserv

now were at: 486 passed testsuite items, 0 failed
ifs.sh still: # tests 6856 passed 6856 failed 0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.132 2014/06/24 18:38:31 tg Exp $");
d97 3
a99 1
		    ccp[0] == CHAR && ccp[1] == '=' && ccp[2] == EOS &&
d103 2
a104 1
			size_t n = ccp - t->vars[0] + 2, z;
@


1.132
log
@Detect (potentially mismatched) ELF files; suggested by enh@@google.com
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.131 2014/06/10 22:17:08 tg Exp $");
d638 1
a638 1
		cp = evalstr(t->vars[i], DOASNTILDE);
@


1.131
log
@fix set -o pipefail w/o PIPESTATUS, and PIPESTATUS inside COMSUBs and other sequences
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.130 2014/05/27 13:22:43 tg Exp $");
d922 4
a933 1
		    (fd == 0x7F45 && buf[2] == 'L' && buf[3] == 'F') ||
@


1.130
log
@fix LP#1277691 (nameref RHS not syntax checked) and the inability to
use errorf() while nameref states were being changed (by almost completely
eliminating the global variable) and the readonly first array variable
bypass (typo/refactoro); also, whitespace, one int  bool, and add a
comment wrt. the parser rewrite talked about with igli during a fever ;)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.129 2014/01/11 16:26:27 tg Exp $");
d465 1
a465 1
		    ARRAY | INT_U;
@


1.129
log
@make the code to exec simple commands also available for mksh_small
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.128 2014/01/05 21:57:25 tg Exp $");
d655 1
a655 1
			typeset(cp, LOCAL|LOCAL_COPY|EXPORT, 0, 0, 0);
d815 1
a815 1
		setstr(typeset("_", LOCAL|EXPORT, 0, INTEGER, 0),
@


1.128
log
@ fix ${12345678901234567890} segfault (OOB access / integer overflow)
   not like oksh did, but using mkshs built-in features
 handle suggested __pure additions
 revert cid 1004F7F096867C83CF0
   always use our wcwidth code
   only use our strlcpy code if none found
 fix a couple of gcc-snapshot and clang/scan-build warnings
 mksh R49~rc1
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.127 2013/10/09 11:59:27 tg Exp $");
a606 1
#if !defined(MKSH_SMALL)
a609 1
#endif
a613 1
#if !defined(MKSH_SMALL)
a615 1
#endif
@


1.127
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.126 2013/09/10 16:30:49 tg Exp $");
d887 1
a887 1
		while ((char *)cp < (buf + sizeof(buf)))
d894 1
a894 1
		if ((char *)cp >= (buf + sizeof(buf)))
@


1.126
log
@int  bool; commit as a TODO comment a begun change attempt
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.124 2013/07/21 18:47:18 tg Exp $");
d872 1
a872 1
	if ((fd = open(tp->str, O_RDONLY)) >= 0) {
d1377 1
a1377 1
		u = open(cp, flags, 0666);
d1510 1
a1510 1
	if (!(shf = h->shf) || (fd = open(h->tffn, O_RDONLY, 0)) < 0) {
@


1.125
log
@simplify
@
text
@d1672 1
a1672 1
	int uqword;
@


1.124
log
@Fix most set -x problems (LP#1179287)

 set -x manually (cmdline too) snapshots fd#2 now
 set -o inherit-xtrace introduced; default still enabled
 reverted iodup printing to pre-R45 behaviour
 made Flag(FXTRACE) a proper state machine
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.122 2013/06/03 22:28:31 tg Exp $");
a714 1
				rv = errno;
d717 1
a717 1
				    tp->u.fpath, cstrerror(rv));
@


1.123
log
@partial merge and full RCS ID sync with oksh

merged:
 new regression tests
 check.pl (tests/th) better tmpfile handling
 exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
 ksh.1 1.147: document the above
 eval.c 1.39: Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).
   additionally make shf_open() return errno and actually show
    the error message from the system
 regression-39 test: remove the maybe marker
   but decide on correct POSIX behaviour

already been fixed in mksh:
 check.pl (tests/th) exit 1 if tests fail

not merged:
 main.c 1.52: run traps in unwind() before exiting;
  Im pretty sure this is already working as-should in mksh
 eval.c 1.38: Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status. As discussed in IRC, this is
  just plainly WRONG.
@
text
@a140 5
		if (Flag(FXTRACE)) {
			shf_puts(substitute(str_val(global("PS4")), 0),
			    shl_out);
			Flag(FXTRACE) = 2;
		}
d637 2
d652 3
a654 3
			shf_write(cp, ccp - cp, shl_out);
			print_value_quoted(shl_out, ccp);
			shf_putc(' ', shl_out);
d663 1
d666 1
a666 1
			print_value_quoted(shl_out, ap[rv]);
d668 1
a668 1
				shf_putc(' ', shl_out);
d672 1
a672 3
		shf_putc('\n', shl_out);
		Flag(FXTRACE) = 1;
		shf_flush(shl_out);
d755 3
a757 3
		old_xflag = Flag(FXTRACE);
		Flag(FXTRACE) |= tp->flag & TRACE ? 1 : 0;

d766 1
d768 1
a768 1
		Flag(FXTRACE) = old_xflag;
d770 1
d1311 5
a1315 2
	if (Flag(FXTRACE) == 2)
		fptreef(shl_out, 0, "%R", &iotmp);
@


1.122
log
@use z shf printf modifier for out-of-memory message, now that we have it
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.49 2009/01/29 23:27:26 jaredy Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.119 2013/04/26 19:47:07 tg Exp $");
d305 6
a310 4
			rv = execute(t->right, XERROK, xerrok);
		flags |= XERROK;
		if (xerrok)
			*xerrok = 1;
@


1.121
log
@fix a number of warnings and other issues:
 sig_t detection was a bit insane, it is a function-pointer type after all
 fix uninitialised variable in c_select which led to mistakenly accepting
  invalid (nn-numeric) input and acting, randomly, upon it
 keep SIGCHLD blocked in child after forking longer, for job list manip
 block SIGCHLD ifdef DEBUG_LEAKS to not run job foo during/after afreeall
 fix annoying ISO C90 vs. C99 (un)signed constant warning
@
text
@d109 1
a109 1
				internal_errorf(Toomem, (unsigned long)-1);
@


1.120
log
@Oh well this looks well, is done done, and gcc-snapshot doesnt complain:
 correct order of built-in commands; use POSIX special versus all others
  plus keeps assignments as distinction, no longer play POSIX regular vs.
  others game; sync manpage
 fix LP#1156707: map (( internally to let] which is no valid function
  name and so cant be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
 we do not need -Wno-overflow any more, either
 bump to R45
@
text
@d1564 1
a1564 2
		if (*s) {
			getn(s, &i);
a1565 1
		}
@


1.119
log
@oops pasto restored the wrong backup code

(I had one that didnt revert cid 100514E4F1D5C90862C in check.t first)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.118 2013/04/26 19:40:44 tg Exp $");
d1050 1
a1050 1
	uint32_t flag;
d1053 1
a1053 1
	for (flag = 0; ; name++) {
a1059 3
		else if (*name == '+')
			/* POSIX regular builtin */
			flag |= REG_BI;
d1062 1
d1066 1
a1066 1
	tp->flag = DEFINED | flag;
d1098 1
a1098 1
	 * POSIX regular builtins, then search path...
d1113 1
a1113 3
	if (!tp && (flags & FC_REGBI) && tbi && (tbi->flag & REG_BI))
		tp = tbi;
	if (!tp && (flags & FC_UNREGBI) && tbi)
@


1.118
log
@and, finally for today, fixup the set -x mess I made
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.117 2013/03/24 00:56:22 tg Exp $");
d664 1
a664 1
		rv = 0;
d666 5
a670 4
		print_value_quoted(shl_out, ap[rv]);
		if (ap[++rv]) {
			shf_putc(' ', shl_out);
			goto xtrace_ap_loop;
@


1.117
log
@ let mksh set -x print whole TCOM trees
 plug some memory leaks in debug (set -x) and warning paths while here
 one from Florian (friend of Natureshadow) for WTF
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.116 2013/02/17 05:40:15 tg Exp $");
d144 1
a144 2
			fptreef(shl_out, 0, "%T\n", t);
			shf_flush(shl_out);
d335 1
d645 12
d663 13
d1314 3
@


1.116
log
@backpedal with $'' and $"" interpolation

it turns out this breaks more legacy scripts than anticipated
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.115 2013/02/15 18:50:13 tg Exp $");
d141 1
a141 1
		if (Flag(FXTRACE) && ap[0]) {
d144 1
a144 3
			for (i = 0; ap[i]; i++)
				shf_fprintf(shl_out, "%s%c", ap[i],
				    ap[i + 1] ? ' ' : '\n');
a645 10

		if (Flag(FXTRACE)) {
			if (i == 0)
				shf_puts(substitute(str_val(global("PS4")), 0),
				    shl_out);
			shf_fprintf(shl_out, "%s%c", cp,
			    t->vars[i + 1] ? ' ' : '\n');
			if (!t->vars[i + 1])
				shf_flush(shl_out);
		}
a1288 5
	if (Flag(FXTRACE))
		shellf("%s%s\n",
		    substitute(str_val(global("PS4")), 0),
		    snptreef(NULL, 32, "%R", &iotmp));

d1331 2
d1334 2
a1335 1
			    snptreef(NULL, 32, "%R", &iotmp), emsg);
d1384 1
d1389 1
a1389 1
			    snptreef(NULL, 32, "%R", &iotmp),
d1391 1
@


1.115
log
@fix too strict fix for LP#1104543 (Debian #700526)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.114 2013/02/10 23:59:25 tg Exp $");
d1484 1
a1484 3
	i = (iop->flag & IOEVAL) ?
	    (ONEWORD | ((iop->flag & IOHERESTR) ? HERESTRBODY : HEREDOCBODY)) :
	    0;
@


1.114
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.113 2013/01/19 19:47:10 tg Exp $");
d751 1
a751 1
			execute(tp->val.t, 0, NULL);
@


1.113
log
@besides more code reuse, fix $'' everywhere (but keep it ignored in here document bodies that arent here strings)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.112 2013/01/06 18:51:42 tg Exp $");
d751 1
a751 2
			/* seems odd to pass XERROK here, but AT&T ksh does */
			exstat = execute(tp->val.t, flags & XERROK, xerrok) & 0xFF;
@


1.112
log
@ormaaj reported command shift not working correctly; fix
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.111 2013/01/01 20:45:02 tg Exp $");
d37 1
a37 1
static int herein(const char *, int, char **);
d99 1
a99 2
		    herein(t->ioact[0]->heredoc, t->ioact[0]->flag & IOEVAL,
		    &cp) == 0 && cp && *cp) {
d1334 1
a1334 1
		u = herein(iop->heredoc, iop->flag & IOEVAL, NULL);
d1454 1
a1454 1
		if (yylex(ONEWORD|HEREDOC) != LWORD)
d1470 1
a1470 1
herein(const char *content, int sub, char **resbuf)
d1478 1
a1478 1
	if (content == NULL) {
d1484 5
d1491 1
a1491 1
		return (hereinval(content, sub, resbuf, NULL));
d1508 1
a1508 1
	if (hereinval(content, sub, NULL, shf) == -2) {
@


1.111
log
@fix running the ERR and EXIT traps in case of set -e and/or eval (includes Debian #696823)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.110 2012/12/22 00:03:41 tg Exp $");
d509 1
a509 1
	int keepasn_ok;
d541 1
a541 1
	keepasn_ok = 1;
d588 1
a588 1
			keepasn_ok = 0;
d681 4
@


1.110
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d5 1
a5 1
 *		 2011, 2012
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.109 2012/12/17 23:18:03 tg Exp $");
d482 8
a489 3
		trapsig(ksh_SIGERR);
		if (Flag(FERREXIT))
			unwind(LERROR);
@


1.109
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.108 2012/12/04 01:18:27 tg Exp $");
d1430 1
a1430 1
	const char *ccp;
d1444 1
a1444 1
		s->start = s->str = content;
d1450 1
a1450 2
	} else
		ccp = content;
@


1.108
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.107 2012/11/30 20:19:11 tg Exp $");
d464 1
a464 1
			errorf("%s: %s", s, strerror(rv));
d691 1
a691 1
				    strerror(tp->u2.errnov));
d698 1
a698 1
				    tp->u.fpath, strerror(rv));
d792 1
a792 1
				    strerror(tp->u2.errnov));
d927 1
a927 1
	errorf("%s: %s: %s", tp->str, sh, strerror(errno));
d1366 1
a1366 1
			    "open" : "create", cp, strerror(u));
d1396 1
a1396 1
			    strerror(eno));
d1489 1
a1489 1
		    !shf ? "create" : "open", h->tffn, strerror(i));
d1506 1
a1506 1
		    "write", h->tffn, strerror(i));
@


1.107
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${precmd;} in dot.mkshrc
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106 2012/11/30 19:02:06 tg Exp $");
d35 1
a35 1
static int call_builtin(struct tbl *, const char **);
d675 1
a675 1
		rv = call_builtin(tp, (const char **)ap);
d936 1
a936 3
	if (tp == NULL)
		internal_errorf("%s: %s", "shcomexec", *wp);
	return (call_builtin(tp, wp));
d985 2
d1253 1
a1253 1
call_builtin(struct tbl *tp, const char **wp)
d1257 2
d1539 1
a1539 1
		if (call_builtin(findcom("read", FC_BI), read_args))
@


1.106
log
@use proper parenthess; int  bool; use same var (eno) for temp. errno
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.105 2012/10/30 20:13:17 tg Exp $");
d608 1
a608 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
d617 1
a617 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
@


1.106.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106 2012/11/30 19:02:06 tg Exp $");
d35 1
a35 1
static int call_builtin(struct tbl *, const char **, const char *);
d675 1
a675 1
		rv = call_builtin(tp, (const char **)ap, null);
d936 3
a938 1
	return (call_builtin(tp, wp, "shcomexec"));
a986 2
		/* because findfunc:create=true */
		mkssert(tp != NULL);
d1253 1
a1253 1
call_builtin(struct tbl *tp, const char **wp, const char *where)
a1256 2
	if (!tp)
		internal_errorf("%s: %s", where, wp[0]);
d1537 1
a1537 1
		if (call_builtin(findcom("read", FC_BI), read_args, Tselect))
@


1.106.2.2
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.1 2012/12/04 01:26:22 tg Exp $");
d1430 1
a1430 1
	const char * volatile ccp = content;
d1444 1
a1444 1
		s->start = s->str = ccp;
d1450 2
a1451 1
	}
@


1.106.2.3
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.2 2012/12/22 00:03:49 tg Exp $");
d482 3
a484 8
		if (Flag(FERREXIT) & 0x80) {
			/* inside eval */
			Flag(FERREXIT) = 0;
		} else {
			trapsig(ksh_SIGERR);
			if (Flag(FERREXIT))
				unwind(LERROR);
		}
@


1.106.2.4
log
@MFC cid 10050E9C7D31AD0F470
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.3 2013/01/01 21:20:03 tg Exp $");
a680 4
		if (!keepasn_ok && tp->val.f == c_shift) {
			l_expand->argc = l_assign->argc;
			l_expand->argv = l_assign->argv;
		}
@


1.106.2.5
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so Im keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unics)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.4 2013/01/06 18:59:13 tg Exp $");
d994 2
@


1.106.2.6
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.5 2013/02/10 17:11:19 tg Exp $");
d752 2
a753 1
			exstat = execute(tp->val.t, 0, NULL) & 0xFF;
@


1.106.2.7
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.106.2.6 2013/02/10 23:59:34 tg Exp $");
d752 1
a752 1
			exstat = execute(tp->val.t, flags & XERROK, NULL) & 0xFF;
@


1.105
log
@int  bool
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.104 2012/10/22 16:53:21 tg Exp $");
d1388 1
a1388 1
			int ev;
d1390 1
a1390 1
			ev = errno;
d1394 1
a1394 1
			    strerror(ev));
@


1.104
log
@introduce MKSH_DISABLE_EXPERIMENTAL and wrap the new feature introduced
in cid 1005084678C510CF7E4 in it
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.103 2012/10/21 21:39:01 tg Exp $");
d694 1
a694 1
			if (include(tp->u.fpath, 0, NULL, 0) < 0) {
@


1.103
log
@add some bounds, for a subsequent commit:
 all writers of exstat ensure the value is in [0; 0xFF]
 all readers of exstat AND it with 0xFF (not strictly needed thus)
 trap_exstat is safe, i.e. always either -1 or [0; 0xFF]
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.102 2012/10/21 21:26:39 tg Exp $");
d608 1
a608 1
#ifndef MKSH_SMALL
d617 1
a617 1
#ifndef MKSH_SMALL
@


1.102
log
@EXPERIMENTAL optimisation for sh -c 'foo' to equal sh -c 'exit foo' iff
several conditions are met as outlined below; for more background, refer to
http://www.FreeBSD.org/cgi/query-pr.cgi?pr=113860

We dont yet optimise % sh -c '{ echo a; sleep 10;}&'; sleep 1; ps T so
the FreeBSD sh approach cannot work for us, but scanning the sh -c argu
ment for disallowed characters and, if not, setting a flag that enables the
shell to exec the tree when parsed as TCOM *and not c_trap()* was possible.

Disallowed characters are currently C_QUOTE except space, that is:
Tab Newline " # $ & ' ( ) * ; < = > ? [ \ ] ` |

This should catch all cases of magic, variables, subshells, pipelines, etc.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.101 2012/10/03 17:24:18 tg Exp $");
d467 1
a467 1
	exstat = rv;
d744 1
a744 1
			exstat = execute(tp->val.t, flags & XERROK, xerrok);
d765 1
a765 1
			rv = exstat;
d825 1
a825 1
		exstat = rv;
@


1.101
log
@even more hacks to pass -O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver with gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)  plus make the rtchecks mandatory
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.100 2012/10/03 15:13:30 tg Exp $");
d608 5
d617 4
@


1.100
log
@repair choiceless select builtin
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.99 2012/06/24 20:05:23 tg Exp $");
d1656 4
a1659 3
			for (p = *te->pos.wp;
			    *p == CHAR && q < &buf[sizeof(buf) - 1]; p += 2)
				*q++ = p[1];
@


1.99
log
@these want to be bool, not int

but no idea how to address CID 703483, if it needs to be addressed at all
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.98 2012/04/14 16:07:46 tg Exp $");
d43 3
d1535 1
a1535 1
		print_menu = 1;
a1543 2
static char *select_fmt_entry(char *, size_t, int, const void *);

d1546 1
a1546 1
select_fmt_entry(char *buf, size_t buflen, int i, const void *arg)
d1551 1
a1551 1
	shf_snprintf(buf, buflen, "%*d) %s",
d1559 1
a1559 1
int
d1565 1
a1565 1
	int n;
a1596 2

	return (n);
a1598 3
/* XXX: horrible kludge to fit within the framework */
static char *plain_fmt_entry(char *, size_t, int, const void *);

d1600 1
a1600 1
plain_fmt_entry(char *buf, size_t buflen, int i, const void *arg)
d1606 1
a1606 1
int
d1610 1
a1610 1
	int n;
a1623 2

	return (n);
@


1.99.2.1
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.99 2012/06/24 20:05:23 tg Exp $");
d464 1
a464 1
	exstat = rv & 0xFF;
d479 3
a481 8
		if (Flag(FERREXIT) & 0x80) {
			/* inside eval */
			Flag(FERREXIT) = 0;
		} else {
			trapsig(ksh_SIGERR);
			if (Flag(FERREXIT))
				unwind(LERROR);
		}
d731 2
a732 1
			exstat = execute(tp->val.t, 0, NULL) & 0xFF;
d753 1
a753 1
			rv = exstat & 0xFF;
d813 1
a813 1
		exstat = rv & 0xFF;
@


1.99.2.2
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.99.2.1 2013/02/11 00:27:12 tg Exp $");
d736 1
a736 1
			exstat = execute(tp->val.t, flags & XERROK, NULL) & 0xFF;
@


1.98
log
@rewrite maketemp() obsoleting tempnam(3) and mkstemp(3) external deps
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.97 2012/03/31 17:29:58 tg Exp $");
d1267 2
a1268 1
	int do_open = 1, do_close = 0, flags = 0;
d1310 1
a1310 1
		do_open = 0;
d1319 1
a1319 1
		do_open = 0;
d1323 1
a1323 1
			do_close = 1;
d1335 1
a1335 1
	}
@


1.97
log
@use _setjmp/_longjmp on NeXTstep: its Intel port always restores the signal mask on siglongjmp, which we never have
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.96 2011/09/07 15:24:14 tg Exp $");
d1471 1
a1471 1
	if (!(shf = h->shf) || (fd = open(h->name, O_RDONLY, 0)) < 0) {
d1474 1
a1474 1
		    !shf ? "create" : "open", h->name, strerror(i));
d1490 2
a1491 1
		warningf(true, "%s: %s: %s", "write", h->name, strerror(i));
@


1.96
log
@ access(2) is broken in at least kFreeBSD 9.0 as modern OS, so bring
  back the wrapper code as well as refactor most other code calling it
 apparently, names cant end in _ or contain __ anywhere
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.95 2011/08/27 18:06:43 tg Exp $");
d237 1
a237 2
		i = sigsetjmp(e->jbuf, 0);
		if (i) {
d339 1
a339 4
		while (/* CONSTCOND */ 1) {
			i = sigsetjmp(e->jbuf, 0);
			if (!i)
				break;
d374 1
a374 4
		while (/* CONSTCOND */ 1) {
			i = sigsetjmp(e->jbuf, 0);
			if (!i)
				break;
d729 1
a729 2
		i = sigsetjmp(e->jbuf, 0);
		if (i == 0) {
d1419 1
a1419 1
	if (sigsetjmp(e->jbuf, 0)) {
@


1.95
log
@patch most of Jerker Bcks concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.94 2011/07/07 21:24:52 tg Exp $");
d41 1
d106 1
a106 1
				internal_errorf(T_oomem, (unsigned long)-1);
d485 1
a485 1
		trapsig(SIGERR_);
d550 1
a550 1
				errorf("%s: %s: %s", T_builtin, cp, "not a builtin");
d682 4
a685 12
				if (tp->u2.errno_) {
					warningf(true, "%s: %s %s: %s", cp,
					    "can't find",
					    "function definition file",
					    strerror(tp->u2.errno_));
					rv = 126;
				} else {
					warningf(true, "%s: %s %s", cp,
					    "can't find",
					    "function definition file");
					rv = 127;
				}
d781 4
a784 10
			/*
			 * errno_ will be set if the named command was found
			 * but could not be executed (permissions, no execute
			 * bit, directory, etc). Print out a (hopefully)
			 * useful error message and set the exit status to 126.
			 */
			if (tp->u2.errno_) {
				warningf(true, "%s: %s: %s", cp,
				    "can't execute", strerror(tp->u2.errno_));
				/* POSIX */
d786 2
a787 3
			} else {
				warningf(true, "%s: %s", cp, "not found");
				rv = 127;
d840 1
a840 1
		sh = search(sh, path, X_OK, NULL);
d1083 1
a1083 1
				tp->u2.errno_ = 0;
d1085 2
a1086 2
				tp->u.fpath = search(name, fpath, R_OK,
				    &tp->u2.errno_);
d1095 2
a1096 1
		if (tp && (tp->flag & ISSET) && access(tp->val.s, X_OK) != 0) {
d1119 3
a1121 2
		npath.ro = search(name, flags & FC_DEFPATH ? def_path : path,
		    X_OK, &tp->u2.errno_);
d1129 2
a1130 2
		    (npath.ro = search(name, fpath, R_OK,
		    &tp->u2.errno_)) != NULL) {
d1167 3
a1169 5
/* Check if path is something we want to find. Returns -1 for failure. */
int
search_access(const char *lpath, int mode,
    /* set if candidate found, but not suitable */
    int *errnop)
d1171 1
a1171 2
	int ret, err = 0;
	struct stat statb;
d1173 12
a1184 15
	if (stat(lpath, &statb) < 0)
		return (-1);
	ret = access(lpath, mode);
	if (ret < 0)
		/* File exists, but we can't access it */
		err = errno;
	else if (mode == X_OK && (!S_ISREG(statb.st_mode) ||
	    !(statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)))) {
		/* This 'cause access() says root can execute everything */
		ret = -1;
		err = S_ISDIR(statb.st_mode) ? EISDIR : EACCES;
	}
	if (err && errnop && !*errnop)
		*errnop = err;
	return (ret);
d1191 1
a1191 1
search(const char *name, const char *lpath,
d1201 1
a1202 2
	if (errnop)
		*errnop = 0;
d1204 4
a1207 1
		if (search_access(name, mode, errnop) == 0)
d1209 2
a1210 1
		return (NULL);
d1230 7
a1236 2
		if (search_access(Xstring(xs, xp), mode, errnop) == 0)
			return (Xclose(xs, xp + namelen));
d1241 3
@


1.94
log
@introduce MKSH_NO_EXTERNAL_CAT skipping the call /bin/cat if we have an
option nonsense, intended for Android, Plan 9, and other systems which
honour that cat -v is deemed harmful
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.93 2011/07/05 20:12:17 tg Exp $");
d54 1
a54 1
	const char ** volatile ap;
d1218 1
a1218 1
	int namelen;
d1553 1
a1553 1
static char *select_fmt_entry(char *, int, int, const void *);
d1557 1
a1557 1
select_fmt_entry(char *buf, int buflen, int i, const void *arg)
d1575 2
a1576 1
	int acols = 0, aocts = 0, i, n;
d1613 1
a1613 1
static char *plain_fmt_entry(char *, int, int, const void *);
d1616 1
a1616 1
plain_fmt_entry(char *buf, int buflen, int i, const void *arg)
d1625 2
a1626 1
	int acols = 0, aocts = 0, i, n;
@


1.93
log
@ bump patchlevel to todays
 while here, reformat 'struct tbl' comment-wise and placement-wise
  and drop the Tflag typedef
 while here, write regression test for the "global" built-in, which
  does what typeset is supposed to do except that it doubles as "local"
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.92 2011/05/29 02:18:51 tg Exp $");
d591 1
d609 1
@


1.92
log
@mksh R40 Release Candidate 1

Testsuite:
 add new need-pass: {yes|no} attribute, default yes
 exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
 mark utf8bom-2 as need-pass: no
Infrstructure:
 add housekeeping function for making a tty raw
 switch functions with unused results to void
 struct op: u.charflag contains last char of ;; in TPAT
 var.c:arraysearch is now a global function
Language:
 add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
 add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
 allow read -N -1 or -n -1 to slurp the entire input
 add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
 add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
 full rewrite of read builtin and its manpage section
 add regression tetss for most of the new functionality
 duplicate hexdump demo tests for use of read -a
 use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.91 2011/05/07 00:51:11 tg Exp $");
d672 1
a672 1
		volatile Tflag old_inuse;
d1036 1
a1036 1
	Tflag flag;
@


1.91
log
@ fix an inverted logic bug in the test I wrote
 only trigger deleting an alias in favour of a function for (), not
  just the opening parenthesis: stop( ) is not a function definition
  (well, actually it seems to be, but not according to POSIX, anyway)
 defer dropping the alias until the function is actually defined ()
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.90 2011/04/17 15:40:35 tg Exp $");
d408 1
d410 22
a431 8
		for (t = t->left; t != NULL && t->type == TPAT; t = t->right)
		    for (ap = (const char **)t->vars; *ap; ap++)
			if ((s = evalstr(*ap, DOTILDE|DOPAT)) &&
			    gmatchx(ccp, s, false))
				goto Found;
		break;
 Found:
		rv = execute(t->left, flags & XERROK, xerrok);
@


1.90
log
@by prodding of wbx@@ let functions inherit a global xtrace
(also since all other shells seem to do it, save posh which doesnt trace)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.89 2011/04/02 10:30:10 tg Exp $");
d965 1
d969 8
d978 1
a978 1
		tp = findfunc(name, hash(name), true);
@


1.89
log
@skip the UTF-8 BOM early, then check the magic (ELF, a.out, COFF, )
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.88 2011/03/13 01:20:18 tg Exp $");
d720 1
a720 1
		Flag(FXTRACE) = tp->flag & TRACE ? 1 : 0;
@


1.88
log
@lint is your friend
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.87 2011/02/18 22:26:08 tg Exp $");
d850 8
a858 1
		cp = (unsigned char *)buf;
d868 3
a870 4
		/* skip UTF-8 Byte Order Mark, if present */
		cp = (unsigned char *)buf;
		if ((cp[0] == 0xEF) && (cp[1] == 0xBB) && (cp[2] == 0xBF))
			cp += 3;
d874 1
@


1.87
log
@ add -u option (POSIX: unbuffered  nop) to the built-in cat
 PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
 add regression tests, documentation, etc.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.86 2011/02/11 01:18:16 tg Exp $");
d339 1
a339 1
		while (1) {
d377 1
a377 1
		while (1) {
d961 1
a961 1
	while (1) {
d1494 1
a1494 1
	while (1) {
@


1.86
log
@ more comment and intbool cleanup, add and improve some comments
 in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesnt suffice
 add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
 for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
 when called as builtin, echo behaves POSIXish
 add domainname as alias for true on MirBSD only, to be able to link it
 sync mksh Makefiles with Build.sh output
 adjust manpage wrt release plans
 link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
 drop linked utilities and, except for echo and kill, their manpages
 adjust instbin and link a few more there as well
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.85 2011/01/30 01:35:33 tg Exp $");
d156 3
d213 1
a213 1
		i = exchild(t, flags | XPCLOSE, xerrok, 0);
d455 6
d582 2
@


1.85
log
@introduce MKSH_NOPROSPECTOFWORK which is like pdkshs JOB_SIGS in reverse, like MKSH_UNEMPLOYED is pdkshs JOBS in reverse; allows mksh to work (hah! no pun intended) with klibc (and possibly, Syllable Desktop and Plan 9) for now, until they fix their bugs
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.84 2011/01/09 21:57:25 tg Exp $");
d47 2
a48 1
    volatile int flags,		/* if XEXEC don't fork */
d76 2
a77 1
	if (t->type == TCOM /* we want to run an executable... */) {
d479 2
a480 1
	static struct op texec; /* Must be static (XXX but why?) */
d487 2
a488 1
	/* snag the last argument for $_ XXX not the same as AT&T ksh,
d501 2
a502 1
	/* Deal with the shell builtins builtin, exec and command since
d535 3
a537 2
			/* Ugly dealing with options in two places (here and
			 * in c_command(), but such is life)
d543 2
a544 1
				break;	/* command -vV or something */
d557 2
a558 1
			/* POSIX says special builtins lose their status
d637 3
a639 1
	case CSHELL:			/* shell built-in */
d643 2
a644 1
	case CFUNC: {			/* function call */
d685 3
a687 2
		/* ksh functions set $0 to function name, POSIX functions leave
		 * $0 unchanged.
d698 2
a699 1
		/* ksh-style functions handle getopts sanely,
d724 4
a727 3
		/* Were we deleted while executing? If so, free the execution
		 * tree. todo: Unfortunately, the table entry is never re-used
		 * until the lookup table is expanded.
d755 4
a758 2
	case CEXEC:		/* executable command */
	case CTALIAS:		/* tracked alias */
d760 2
a761 1
			/* errno_ will be set if the named command was found
d769 2
a770 1
				rv = 126;	/* POSIX */
d797 2
a798 1
		texec.left = t;	/* for tprint */
d818 2
a819 1
	char buf[64];		/* 64 == MAXINTERP in MirBSD <sys/param.h> */
d955 3
a957 2
		/* If this function is currently being executed, we zap this
		 * table entry so findfunc() won't see it
d961 2
a962 1
			tp->flag &= ~DEFINED; /* ensure it won't be found */
d973 2
a974 1
	if (t == NULL) {		/* undefine */
d990 1
a990 1
void
d998 2
a999 1
		if (*name == '=')	/* command does variable assignment */
d1001 2
a1002 1
		else if (*name == '*')	/* POSIX special builtin */
d1004 2
a1005 1
		else if (*name == '+')	/* POSIX regular builtin */
d1015 2
d1029 4
a1032 2
	unsigned char insert = Flag(FTRACKALL);	/* insert if not found */
	char *fpath;			/* for function autoloading */
d1042 2
a1043 1
	/* POSIX says special builtins first, then functions, then
d1085 2
a1086 1
			tp->flag = DEFINED;	/* make ~ISSET */
d1099 5
a1103 4
			/* An undocumented feature of AT&T ksh is that it
			 * searches FPATH if a command is not found, even
			 * if the command hasn't been set up as an autoloaded
			 * function (ie, no typeset -uf).
d1107 2
a1108 1
			tp->flag = DEFINED; /* make ~ISSET */
d1117 1
d1120 1
a1120 1
flushcom(int all)	/* just relative or all */
d1138 2
a1139 1
    int *errnop)	/* set if candidate found, but not suitable */
d1148 2
a1149 1
		err = errno; /* File exists, but we can't access it */
d1166 4
a1169 2
    int mode,		/* R_OK or X_OK */
    int *errnop)	/* set if candidate found, but not suitable */
d1265 2
a1266 1
		/* The stat() is here to allow redirections to
d1290 2
a1291 1
			u = 1009;	 /* prevent error return below */
d1301 2
a1302 1
			return (0);		/* "dup from" == "dup to" */
d1331 2
a1332 1
			/* c_exec() assumes e->savefd[fd] set for any
d1358 2
a1359 1
		/* Touching any co-process fd in an empty exec
d1363 2
a1364 1
			if (iop->flag & IORDUP)	/* possible exec <&p */
d1366 2
a1367 1
			else			/* possible exec >&p */
d1371 2
a1372 1
	if (u == 2) /* Clear any write errors */
d1484 2
a1485 1
		/* Menu is printed if
d1624 2
a1625 1
			char buf[8];	/* longer than the longest operator */
d1627 1
@


1.84
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Ltzebuerg 

This was the third try. Where to put this was not palpable same for =()
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.83 2010/09/15 21:08:17 tg Exp $");
d117 2
a118 1
		/* Clear subst_exstat before argument expansion. Used by
d123 2
a124 1
		current_lineno = t->lineno;	/* for $LINENO */
d126 2
a127 1
		/* POSIX says expand command words first, then redirections,
d159 2
a160 1
				/* Redirection failures for special commands
d187 2
a188 1
			ksh_dup2(pv[1], 1, false); /* stdout of curr */
d197 2
a198 1
			ksh_dup2(pv[0], 0, false); /* stdin of next */
d203 4
a206 2
		restfd(1, e->savefd[1]); /* stdout of last */
		e->savefd[1] = 0; /* no need to re-restore this */
d222 1
d225 2
a226 1
		/* Block sigchild as we are using things changed in the
d238 1
d264 2
a265 1
			coproc.readw = pv[1];	 /* closed before first read */
d270 1
d272 3
a274 1
		e->type = E_EXEC; /* no more need for error handler */
d276 2
a277 1
		/* exchild() closes coproc.* in child after fork,
d288 2
a289 1
		/* XXX non-optimal, I think - "(foo &)", forks for (),
d347 2
a348 1
		rv = 0; /* in case of a continue */
d354 2
a355 1
		} else { /* TSELECT */
d385 2
a386 1
		rv = 0; /* in case of a continue */
d395 2
a396 1
			break;	/* should be error */
d423 2
a424 1
		/* Clear XEXEC so nested execute() call doesn't exit
d430 2
a431 1
	case TEXEC:		/* an eval'd TCOM */
d451 2
a452 1
	quitenv(NULL);		/* restores IO */
d454 2
a455 1
		unwind(LEXIT);	/* exit child */
@


1.83
log
@revert part of the size reduction diff (zero size change though):
shellf() implies an shf_flush()
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.82 2010/09/14 21:26:11 tg Exp $");
d31 1
a31 1
static int comexec(struct op *, struct tbl *volatile, const char **,
d36 1
a36 1
static int herein(const char *, int);
d46 1
a46 1
execute(struct op *volatile t,
d55 1
a55 1
	const char *s, *cp;
d58 1
d75 42
a116 1
	if (t->type == TCOM) {
d338 1
a338 1
				if (!(cp = do_selectargs(ap, is_first))) {
d343 1
a343 1
				setstr(global(t->str), cp, KSH_UNWIND_ERROR);
d382 1
a382 1
		cp = evalstr(t->str, DOTILDE);
d386 1
a386 1
			    gmatchx(cp, s, false))
d445 1
a445 1
comexec(struct op *t, struct tbl *volatile tp, const char **ap,
d611 1
a611 1
		const char *volatile old_kshname;
d1216 1
a1216 1
		u = herein(iop->heredoc, iop->flag & IOEVAL);
d1306 3
a1308 2
 * open here document temp file.
 * if unquoted here, expand here temp file into second temp file.
d1311 1
a1311 1
herein(const char *content, int sub)
d1313 37
a1349 3
	volatile int fd = -1;
	struct source *s, *volatile osource;
	struct shf *volatile shf;
d1356 2
a1357 1
		return (-2); /* special to iosetup(): don't print error */
d1360 7
a1366 2
	/* Create temp file to hold content (done before newenv so temp
	 * doesn't get removed too soon).
d1370 1
a1370 1
		fd = errno;
d1372 1
a1372 2
		    !shf ? "create" : "open",
		    h->name, strerror(fd));
d1375 2
a1376 1
		return (-2 /* special to iosetup(): don't print error */);
d1379 1
a1379 6
	osource = source;
	newenv(E_ERRH);
	i = sigsetjmp(e->jbuf, 0);
	if (i) {
		source = osource;
		quitenv(shf);
d1381 2
a1382 1
		return (-2); /* special to iosetup(): don't print error */
a1383 13
	if (sub) {
		/* Do substitutions on the content of heredoc */
		s = pushs(SSTRING, ATEMP);
		s->start = s->str = content;
		source = s;
		if (yylex(ONEWORD|HEREDOC) != LWORD)
			internal_errorf("%s: %s", "herein", "yylex");
		source = osource;
		shf_puts(evalstr(yylval.cp, 0), shf);
	} else
		shf_puts(content, shf);

	quitenv(NULL);
d1389 2
a1390 1
		return (-2);	/* special to iosetup(): don't print error */
@


1.82
log
@ Address concerns of Chris Palmer from the Android security team
   possible integer overflows in memory allocation, mostly
     multiplication: all are checked now
     addition: reviewed them, most were proven or guessed to be
      almost impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
     cost (MirBSD/i386 static): +76 .text
     cost (Debian sid/i386): +779 .text  -4 .data
   on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are insane)
     cost (Debian sid/i386): +192 .text (includes .rodata)
 setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
 define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.81 2010/09/05 19:51:32 tg Exp $");
d1352 1
a1352 1
		shf_puts(str_val(global("PS3")), shl_out);
@


1.81
log
@optimise error messages, option parsing, and make more builtins
recognise "--", costs us 20 .text 0 .data 0 .bss
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.80 2010/08/28 20:22:17 tg Exp $");
d104 1
a104 1
		e->savefd = alloc(NUFILE * sizeof(short), ATEMP);
@


1.80
log
@shave off another 468 bytes: were 300 bytes smaller than BEFORE the
cat builtin was added now (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.79 2010/08/28 18:50:49 tg Exp $");
d447 2
a448 1
			if ((cp = *++ap) == NULL) {
d452 1
a452 2
			tp = findcom(cp, FC_BI);
			if (tp == NULL)
@


1.79
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.78 2010/08/28 17:21:43 tg Exp $");
d91 2
a92 2
			shf_fprintf(shl_out, "%s",
				substitute(str_val(global("PS4")), 0));
d537 2
a538 2
				shf_fprintf(shl_out, "%s",
					substitute(str_val(global("PS4")), 0));
d576 3
a578 2
					warningf(true, "%s: %s: %s", cp,
					    "can't find function definition file",
d582 3
a584 2
					warningf(true, "%s: %s", cp,
					    "can't find function definition file");
d591 3
a593 3
				warningf(true,
				    "%s: can't open function definition file %s: %s",
				    cp, tp->u.fpath, strerror(rv));
d669 1
a669 1
			internal_errorf("CFUNC %d", i);
d684 1
a684 1
				    "cannot execute", strerror(tp->u2.errno_));
d1209 1
a1209 1
			warningf(true, "cannot %s %s: %s",
d1238 2
a1239 2
			warningf(true,
			    "%s %s %s", "could not finish (dup) redirection",
d1278 1
a1278 1
		warningf(true, "here document missing");
d1322 1
a1322 3
		fd = errno;
		warningf(true, "error writing %s: %s, %s", h->name,
		    strerror(i), strerror(fd));
d1352 1
a1352 1
		shellf("%s", str_val(global("PS3")));
d1433 1
a1433 1
	shf_snprintf(buf, buflen, "%s", ((const char * const *)arg)[i]);
@


1.78
log
@make cat an mksh builtin, for things like here documents
if any options are given, the external programme is invoked instead
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.77 2010/08/28 15:48:18 tg Exp $");
d453 1
a453 1
				errorf("builtin: %s: not a builtin", cp);
d475 2
a476 2
					warningf(true,
					    "command -p: restricted");
d554 1
a554 1
			warningf(true, "%s: restricted", cp);
d576 3
a578 4
					warningf(true,
					    "%s: can't find function "
					    "definition file - %s",
					    cp, strerror(tp->u2.errno_));
d581 2
a582 3
					warningf(true,
					    "%s: can't find function "
					    "definition file", cp);
d590 1
a590 1
				    "%s: can't open function definition file %s - %s",
d597 2
a598 3
				warningf(true,
				    "%s: function not defined by %s",
				    cp, tp->u.fpath);
d681 2
a682 2
				warningf(true, "%s: cannot execute - %s", cp,
				    strerror(tp->u2.errno_));
d685 1
a685 1
				warningf(true, "%s: not found", cp);
d822 1
a822 1
		internal_errorf("shcomexec: %s", *wp);
d1198 1
a1198 1
			warningf(true, "%s: restricted", cp);
d1237 1
a1237 1
			    "could not finish (dup) redirection %s: %s",
d1309 1
a1309 1
			internal_errorf("herein: yylex");
@


1.77
log
@whitespace
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.76 2010/08/28 15:39:18 tg Exp $");
d492 15
@


1.76
log
@int  bool
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.75 2010/07/17 22:09:34 tg Exp $");
d444 2
a445 1
		fcflags = FC_BI|FC_FUNC|FC_PATH;/* undo effects of command */
@


1.75
log
@ merge printf from OpenBSD
 deactivate %a and %A since our libc doesnt have it
 rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesnt support it
   saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
 fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
 fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
   a few enum warnings that relate to eglibcs {g,s}etrlimit() functions
    taking an enum instead of an int because theyre too stupid to adhere
    to POSIX interfaces they design by themselves
   all request for implicit conversion involving a "void *" on one side
 tweak the manual page somewhat more
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.74 2010/04/08 13:21:05 tg Exp $");
d1097 1
a1097 1
	shl_stdout_ok = 1;
d1101 1
a1101 1
	shl_stdout_ok = 0;
@


1.74
log
@Fix two more POSIX conformance bugs and minor documentation/comment issues
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.73 2010/03/27 15:29:00 tg Exp $");
d38 1
a38 1
static int dbteste_isa(Test_env *, Test_meta);
d1449 2
a1450 1
/* Test if the current token is a whatever. Accepts the current token if
d1454 1
a1454 1
static int
d1457 1
a1457 1
	int ret = 0;
d1462 1
a1462 1
		return (meta == TM_END);
d1480 1
a1480 1
		ret = 0;
d1482 2
a1483 2
		ret = uqword &&
		    strcmp(*te->pos.wp, dbtest_tokens[(int) meta]) == 0;
d1486 1
a1486 1
	if (ret)
@


1.73
log
@make MKSH_DEFAULT_EXECSHELL (/bin/sh) configurable, for Android
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.72 2009/12/12 22:27:06 tg Exp $");
d415 1
d495 1
d509 1
d513 2
d516 3
@


1.72
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 5
a29 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.71 2009/12/05 17:43:46 tg Exp $");
d718 1
a718 1
		sh = "/bin/sh";
@


1.71
log
@llvm/clang scan-build is now content
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.70 2009/11/28 14:28:00 tg Exp $");
d29 1
a29 2
static void scriptexec(struct op *, const char **)
    __attribute__((noreturn));
@


1.70
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd it doesnt, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.68 2009/11/09 23:35:09 tg Exp $");
d299 1
a299 1
				rv = execute(t->left, flags & XERROK, xerrok);
@


1.69
log
@switch ${%foo} to wcswidth-like behaviour  slightly problematic, and
the set +U case isnt even handled

committed to branch because Id like to get more input on this, for now
@
text
@d1383 1
a1383 1
		i = utf_mbswidth(*pp, true);
d1423 1
a1423 1
		i = utf_mbswidth(*pp, true);
@


1.68
log
@make print_columns() aware that octetscharacterscolumns
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.67 2009/10/15 16:25:15 tg Exp $");
d1383 1
a1383 1
		i = utf_mbswidth(*pp);
d1423 1
a1423 1
		i = utf_mbswidth(*pp);
@


1.68.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd it doesnt, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.69 2009/11/28 14:21:43 tg Exp $");
d1383 1
a1383 1
		i = utf_mbswidth(*pp, true);
d1423 1
a1423 1
		i = utf_mbswidth(*pp, true);
@


1.67
log
@fix exec-function-environment-1 (I hope this doesnt break anything else!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.66 2009/10/02 18:08:32 tg Exp $");
d1341 1
a1341 2
	const char *const *args;
	int arg_width;
d1345 1
a1345 1
static char *select_fmt_entry(const void *, int, char *, int);
d1349 1
a1349 1
select_fmt_entry(const void *arg, int i, char *buf, int buflen)
d1363 1
a1363 1
pr_menu(const char *const *ap)
d1366 2
a1367 2
	const char *const *pp;
	int nwidth, dwidth, i, n;
d1369 5
a1373 4
	/* Width/column calculations were done once and saved, but this
	 * means select can't be used recursively so we re-calculate each
	 * time (could save in a structure that is returned, but its probably
	 * not worth the bother).
d1379 4
a1382 1
	for (n = 0, nwidth = 0, pp = ap; *pp; n++, pp++) {
d1384 2
a1385 1
		nwidth = (i > nwidth) ? i : nwidth;
d1387 1
d1389 2
a1390 4
	 * we will print an index of the form
	 *	%d)
	 * in front of each entry
	 * get the max width of this
d1392 2
a1393 2
	for (i = n, dwidth = 1; i >= 10; i /= 10)
		dwidth++;
a1395 2
	smi.arg_width = nwidth;
	smi.num_width = dwidth;
d1397 2
a1398 1
	    dwidth + nwidth + 2, 1);
d1404 1
a1404 2

static char *plain_fmt_entry(const void *, int, char *, int);
d1407 1
a1407 1
plain_fmt_entry(const void *arg, int i, char *buf, int buflen)
d1414 1
a1414 1
pr_list(char *const *ap)
d1416 2
a1417 2
	char *const *pp;
	int nwidth, i, n;
d1419 4
a1422 1
	for (n = 0, nwidth = 0, pp = ap; *pp; n++, pp++) {
d1424 2
a1425 1
		nwidth = (i > nwidth) ? i : nwidth;
d1427 1
d1429 1
a1429 1
	    nwidth + 1, 0);
@


1.66
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.65 2009/09/20 16:40:55 tg Exp $");
d500 1
a500 1
			type_flags = 0;
@


1.65
log
@more of this:

 shell flags are now handled in one single place (sh_flags.h)
 sync comments (between enum and array) and manpage with reality
 FMONITOR is now no longer needed for Hartz IV shells
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.64 2009/08/28 20:30:55 tg Exp $");
d411 1
a411 1
	int bourne_function_call = 0;
d499 1
a499 1
			bourne_function_call = 1;
d594 1
a594 1
		 * bourne/posix functions are insane...
@


1.64
log
@much better solution: save tablep and hash value in the struct tbl entry
 also saves time during texpand :D

XXX this doesnt work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.62 2009/08/28 19:16:17 tg Exp $");
d674 5
a678 1
			if (!(flags&XBGND) || Flag(FMONITOR)) {
@


1.63
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d570 1
a570 1
			if (!(ftp = findfunc(cp, hash(cp), false, NULL)) ||
d792 1
a792 1
	tp = ktsearch(&builtins, *wp, hash(*wp), NULL);
d803 1
a803 1
findfunc(const char *name, uint32_t h, bool create, struct table_entry *pte)
d809 1
a809 1
		tp = ktsearch(&l->funs, name, h, pte);
d813 1
a813 1
			tp = ktenter(&l->funs, name, h, pte);
a830 1
	struct table_entry te;
d834 1
a834 1
		tp = findfunc(name, hash(name), true, &te);
d855 1
a855 1
		ktremove(&te);
d888 1
a888 1
	tp = ktenter(&builtins, name, hash(name), NULL);
d914 1
a914 1
	tbi = (flags & FC_BI) ? ktsearch(&builtins, name, h, NULL) : NULL;
d921 1
a921 1
		tp = findfunc(name, h, false, NULL);
d936 1
a936 1
		tp = ktsearch(&taliases, name, h, NULL);
d951 1
a951 1
				tp = ktenter(&taliases, name, h, NULL);
@


1.62
log
@another intbool
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.61 2009/08/28 18:53:57 tg Exp $");
d570 1
a570 1
			if (!(ftp = findfunc(cp, hash(cp), false)) ||
d792 1
a792 1
	tp = ktsearch(&builtins, *wp, hash(*wp));
d803 1
a803 1
findfunc(const char *name, uint32_t h, bool create)
d809 1
a809 1
		tp = ktsearch(&l->funs, name, h);
d813 1
a813 1
			tp = ktenter(&l->funs, name, h);
d831 1
d835 1
a835 1
		tp = findfunc(name, hash(name), true);
d856 1
a856 1
		ktdelete(tp);
d889 1
a889 1
	tp = ktenter(&builtins, name, hash(name));
d915 1
a915 1
	tbi = (flags & FC_BI) ? ktsearch(&builtins, name, h) : NULL;
d922 1
a922 1
		tp = findfunc(name, h, false);
d937 1
a937 1
		tp = ktsearch(&taliases, name, h);
d952 1
a952 1
				tp = ktenter(&taliases, name, h);
@


1.61
log
@ use Jenkins one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
 improve comments
 fix some types (uint32_t for hash, size_t for sizes)
 optimise ktsort()

no functional change, I think
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.60 2009/08/08 13:08:49 tg Exp $");
d803 1
a803 1
findfunc(const char *name, uint32_t h, int create)
@


1.60
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings  fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.59 2009/06/11 12:42:17 tg Exp $");
d803 1
a803 1
findfunc(const char *name, unsigned int h, int create)
d902 1
a902 1
	unsigned int h = hash(name);
@


1.59
log
@capitalise AT&T
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.58 2009/06/10 18:12:45 tg Exp $");
d540 1
a540 1
		volatile char old_xflag;
d904 1
a904 1
	int insert = Flag(FTRACKALL);	/* insert if not found */
d1404 1
a1404 1
	shf_snprintf(buf, buflen, "%s", ((char *const *)arg)[i]);
@


1.58
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.57 2009/06/08 20:06:45 tg Exp $");
d413 1
a413 1
	/* snag the last argument for $_ XXX not the same as at&t ksh,
d611 1
a611 1
			/* seems odd to pass XERROK here, but at&t ksh does */
d970 1
a970 1
			/* An undocumented feature of at&t ksh is that it
@


1.57
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthess around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.56 2009/05/16 18:40:05 tg Exp $");
d72 1
a72 1
		/* Clear subst_exstat before argument expansion.  Used by
d139 2
a140 1
			/* Let exchild() close pv[0] in child
d142 2
a143 2
			 *    (: ; cat /etc/termcap) | sleep 1
			 *  will hang forever).
d168 2
a169 3
	case TCOPROC:
	    {
		sigset_t	omask;
d224 1
a224 1
	    }
d228 1
a228 1
		 * forks again for async...  parent should optimise
d251 1
a251 2
	case TDBRACKET:
	    {
d263 1
a263 1
	    }
d266 1
a266 2
	case TSELECT:
	    {
a301 1
	    }
d303 1
d427 1
a427 1
	 * they can be followed by other commands.  This must be done before
d432 5
a436 5
	 *   FOO=bar exec >/dev/null		FOO is kept but not exported
	 *   FOO=bar exec foobar		FOO is exported
	 *   FOO=bar command exec >/dev/null	FOO is neither kept nor exported
	 *   FOO=bar command			FOO is neither kept nor exported
	 *   PATH=... foobar			use new PATH in foobar search
d539 1
a539 2
	case CFUNC:			/* function call */
	    {
d618 2
a619 2
		/* Were we deleted while executing?  If so, free the execution
		 * tree.  todo: Unfortunately, the table entry is never re-used
d646 1
a646 1
	    }
d653 1
a653 1
			 * bit, directory, etc).  Print out a (hopefully)
d799 1
a799 1
 * Search function tables for a function.  If create set, a table entry
d824 1
a824 1
 * define function.  Returns 1 if function is being undefined (t == 0) and
d1003 1
a1003 1
/* Check if path is something we want to find.  Returns -1 for failure. */
d1018 1
a1018 1
	    /* This 'cause access() says root can execute everything */
d1148 1
a1148 2
	case IODUP:
	    {
d1165 1
a1165 1
	    }
d1193 1
a1193 1
			 * redirections.  Ask savefd() not to close iop->unit;
d1295 1
a1295 1
		return (-2); /* special to iosetup(): don't print error */
d1428 2
a1429 2
/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
@


1.56
log
@ remove #if 0 and #ifdef notdef style old debugging code
 expose #ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT just in case they decide to
  require it and show it in the ksh version automatically
 sync the use of non-ASCII characters over files (unification)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.55 2009/05/16 16:59:35 tg Exp $");
d57 1
a57 1
		return 0;
d65 1
a65 1
		return exchild(t, flags & ~XTIME, xerrok, -1);
d101 1
a101 1
		e->savefd = alloc(NUFILE * sizeof (short), ATEMP);
d103 1
a103 1
		memset(e->savefd, 0, NUFILE * sizeof (short));
d394 1
a394 1
	return rv;
d696 1
a696 1
	return rv;
d721 1
a721 1
		if (read(fd, buf, sizeof (buf)) <= 0)
d727 1
a727 1
		while ((char *)cp < (buf + sizeof (buf)))
d734 1
a734 1
		if ((char *)cp >= (buf + sizeof (buf)))
d823 1
a823 1
	return tp;
d867 1
a867 1
	return 0;
d984 1
a984 1
	return tp;
d1015 1
a1015 1
		return -1;
d1027 1
a1027 1
	return ret;
d1048 1
a1048 1
		return NULL;
d1069 1
a1069 1
			return Xclose(xs, xp + namelen);
d1074 1
a1074 1
	return NULL;
d1092 1
a1092 1
	return rv;
d1164 1
a1164 1
			return -1;
d1167 1
a1167 1
			return 0;		/* "dup from" == "dup to" */
d1175 1
a1175 1
			return -1;
d1188 1
a1188 1
		return -1;
d1218 1
a1218 1
			return -1;
d1234 1
a1234 1
	return 0;
d1253 1
a1253 1
		return -2; /* special to iosetup(): don't print error */
d1267 1
a1267 1
		return -2 /* special to iosetup(): don't print error */;
d1277 1
a1277 1
		return -2; /* special to iosetup(): don't print error */
d1299 1
a1299 1
		return -2; /* special to iosetup(): don't print error */
d1302 1
a1302 1
	return fd;
d1330 1
a1330 1
			return NULL;
d1334 1
a1334 1
			return (i >= 1 && i <= argct) ? ap[i - 1] : null;
d1357 1
a1357 1
	return buf;
d1398 1
a1398 1
	return n;
d1409 1
a1409 1
	return buf;
d1425 1
a1425 1
	return n;
d1444 1
a1444 1
		return meta == TM_END;
d1471 1
a1471 1
	return ret;
d1480 1
a1480 1
		return NULL;
d1485 1
a1485 1
		return null;
d1492 1
a1492 1
	return s;
@


1.55
log
@ sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression tests results while here, which have been
  broken since cid 10049D9BE5254CE65B8
 get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.54 2009/04/07 19:13:09 tg Exp $");
d775 1
a775 1
		    (fd == /* MZ */ 0x4D5A) ||
@


1.54
log
@some int->bool, KNF, ...
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.53 2009/03/22 18:28:34 tg Exp $");
@


1.53
log
@sync; fold oksh-seterror test into errexit-*; use print not printf
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.52 2009/03/22 18:20:36 tg Exp $");
d814 1
a814 1
	int was_set = 0;
d820 1
a820 1
			was_set = 1;
d839 1
a839 1
		return was_set ? 0 : 1;
@


1.52
log
@the missing part
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.51 2009/03/22 17:47:36 tg Exp $");
d25 1
a25 1
    volatile int *xerrok)
@


1.51
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.50 2009/03/16 15:50:12 tg Exp $");
d28 1
a28 1
	volatile int rv = 0;
d39 4
@


1.50
log
@revert previous commit for now. testscript which breaks:

H4sIAAAAAAACA31TTUvDQBC951c804DtIQ0iiFhSPHiwiCDqzUpIuhO6JN2ETSS16n93Np+GFiGE
zM6bN2/fTPQOro5xENYuEVLzBz9eaF6RlWupSpyHaXqzVuvyljbbDCRV0UR7WeLiHEtT4D2GCcUy
pdNFh4pkg4wGZCV8Z6opTPOw3GI+swoq4ZIVZxqkSv0JqRAiWkBkmAJNegHIGG9vcAWcSnjM6dTo
uby8vsL7+wLllhQQKKr4SoFv/8nbXE5pQcdpk4nlwH6AE7zer17uVs/BmHVftnUdxYh0yHbV3ghY
9wh2rQlBkdMm8PmIe57Bjfs7dTW9X/OoEG6lwzwnzYKA7+8jHpsJTuFN4+IjKhKZM6dpZ0xuQ2Nz
7bGB1F74zlebmzTm/PS+OB0GZz4HLcPgz+BeDxyS9S7YU6e3qZaQk5gZgRHvQtI59Eet7QwBWFnL
O/F+ej9Fpmg0ug7OHrnqHy2+7y8x6DGEG3E0Az41RuPlYfXEEx0psrl8PAUebzf6ZklabgD8V3SS
Z7Vo6xfOuQS6gQMAAA==

mksh -o posix z failed in that it continues; mksh z correctly aborts
lets see what the obsd people have to say herefore
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.48 2007/09/05 19:02:01 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.48 2008/12/13 17:02:13 tg Exp $");
d8 1
a8 1
    int volatile);
d24 2
a25 1
    volatile int flags)		/* if XEXEC don't fork */
d40 2
a41 1
		return exchild(t, flags & ~XTIME, -1); /* run in sub-process */
d100 1
a100 1
		rv = comexec(t, tp, (const char **)ap, flags);
d104 1
a104 1
		rv = execute(t->left, flags|XFORK);
d120 2
a121 1
			exchild(t->left, flags|XPIPEO|XCCLOSE, pv[0]);
d130 1
a130 1
		i = exchild(t, flags|XPCLOSE, 0);
d137 1
a137 1
			execute(t->left, flags & XERROK);
d140 1
a140 1
		rv = execute(t, flags & XERROK);
d197 2
a198 2
		exchild(t->left, flags|XBGND|XFORK|XCOPROC|XCCLOSE,
		    coproc.readw);
d207 1
a207 1
		rv = execute(t->left, (flags&~XEXEC)|XBGND|XFORK);
d212 6
a217 5
		rv = execute(t->left, XERROK);
		if (t->right != NULL && (rv == 0) == (t->type == TAND))
			rv = execute(t->right, flags & XERROK);
		else
			flags |= XERROK;
d221 4
a224 1
		rv = !execute(t->right, XERROK);
d267 1
a267 1
				rv = execute(t->left, flags & XERROK);
d277 1
a277 1
				rv = execute(t->left, flags & XERROK);
d300 3
a302 2
		while ((execute(t->left, XERROK) == 0) == (t->type == TWHILE))
			rv = execute(t->right, flags & XERROK);
d309 3
a311 3
		rv = execute(t->left, XERROK) == 0 ?
		    execute(t->right->left, flags & XERROK) :
		    execute(t->right->right, flags & XERROK);
d323 1
a323 1
		rv = execute(t->left, flags & XERROK);
d327 1
a327 1
		rv = execute(t->left, flags & XERROK);
d338 1
a338 1
		rv = timex(t, flags & ~XEXEC);
d364 2
a365 1
	if (rv != 0 && !(flags & XERROK)) {
d379 1
a379 1
    volatile int flags)
d591 1
a591 1
			exstat = execute(tp->val.t, flags & XERROK);
d664 1
a664 1
		rv = exchild(&texec, flags, -1);
@


1.49
log
@bring back the backed-out Debian patch if FPOSIX; test programmes fixed:

H4sIAAAAAAACAz1PywrDIBA8m68YgoT20EN7TMixX1F6yGNFIWhRSw2h/95VmuDB2XmsY2oDRVyo
Si1N2uHlMzQK0b8JHaImy4RQwxIITYPiUs4xqcyeGgdfrfumtWX5dMbGSHy0WQgP1PJa49lhdpkV
ynncYSxkOjjxd/V83dmcX9sQtFGRi0zORmO5042HbwnMzlIBqa9lAmfLVBIZ7XqpKBPDnDu+WXpi
wMhnOgQXYvUD+oKHAhUBAAA=

XXX OpenBSD has something different which may DTST or even DTRT (not break
XXX our make(1) wrt <bsd.subdir.mk>), check that
@
text
@a27 2
	/* for FPOSIX only: rv being propagated or newly defined? */
	volatile bool rv_prop = false;
a102 1
		rv_prop = true;
d210 1
a210 1
		if (t->right != NULL && (rv == 0) == (t->type == TAND)) {
d212 1
a212 2
			rv_prop = true;
		} else
a256 1
		rv_prop = true;
a265 1
					rv_prop = false;
a294 1
		rv_prop = true;
a303 1
		rv_prop = true;
a315 1
		rv_prop = true;
a319 1
		rv_prop = true;
a330 1
		rv_prop = true;
d356 1
a356 1
	if (rv != 0 && (!Flag(FPOSIX) || !rv_prop) &&!(flags & XERROK)) {
@


1.48
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.47 2008/11/12 00:55:31 tg Exp $");
d28 2
d105 1
d213 1
a213 1
		if (t->right != NULL && (rv == 0) == (t->type == TAND))
d215 2
a216 1
		else
d261 1
d271 1
d301 1
d311 1
d324 1
d329 1
d341 1
d367 1
a367 1
	if (rv != 0 && !(flags & XERROK)) {
@


1.47
log
@get rid of tempting sizeofN macro
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.46 2008/11/12 00:54:47 tg Exp $");
d75 1
a75 1
		e->savefd = alloc(NUFILE, sizeof (short), ATEMP);
@


1.47.2.1
log
@before Im going to accidentally type cvs -Rq up -PAd another time,
better save the current not-so progress into the repo it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.47 2008/11/12 00:55:31 tg Exp $");
d75 1
a75 1
		e->savefd = galloc(NUFILE, sizeof (short), ATEMP);
d595 1
a595 1
				tfree(tp->val.t, tp->gp_tbl);
d821 1
a821 1
		tfree(tp->val.t, tp->gp_tbl);
d829 1
a829 1
	tp->val.t = tcopy(t->left, tp->gp_tbl);
d910 1
a910 1
				gfree(tp->val.s, APERM);
d934 1
a934 1
				gfree(npath.rw, ATEMP);
d967 1
a967 1
				gfree(tp->val.s, APERM);
@


1.46
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.45 2008/10/28 14:32:39 tg Exp $");
d77 1
a77 1
		memset(e->savefd, 0, sizeofN(short, NUFILE));
@


1.45
log
@ rewrite code to no longer use statements-as-expressions
 optimise a little
 Build.sh: remove HAVE_EXPSTMT test
 Build.sh, */Makefile: sort tests, regenerate
 mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.44 2008/05/17 18:46:58 tg Exp $");
d75 1
a75 1
		e->savefd = (short *)alloc(sizeofN(short, NUFILE), ATEMP);
@


1.44
log
@ alloc() cant fail, afree() can take NULL
   macro afreechk() is superfluous
 get rid of macro afreechv() by re-doing the dont leak that much code
 some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.43 2008/04/19 22:15:02 tg Exp $");
d932 3
a934 8
			/* XXX unsure about this, oksh does that
			if (tp == &temp)
				tp->val.s = npath.ro;
			else */ {
				tp->val.s = str_save(npath.ro, APERM);
				if (npath.ro != name)
					afree(npath.rw, ATEMP);
			}
@


1.43
log
@ more unsigned  unsigned int
 more int  bool
 more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
 make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
 optimise
 utf_wctomb: src  dst, as were writing to that char array (pasto?)
 edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
 edit.c:x_zotc3(): easier (and faster) handling of UTF-8
 implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the 1#,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80EFFF for the MirBSD encoding hack
  (print doesnt, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
 as an application example, add a hexdumper to the regression tests 
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.42 2008/04/19 17:21:53 tg Exp $");
d75 1
a75 1
		e->savefd = (short *) alloc(sizeofN(short, NUFILE), ATEMP);
@


1.42
log
@ new ksh_mbswidth
 fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
 some intbool while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.41 2008/04/01 22:20:18 tg Exp $");
d1352 1
a1352 1
		i = ksh_mbswidth(*pp);
d1391 1
a1391 1
		i = ksh_mbswidth(*pp);
@


1.41
log
@some more code folding
should decrease size
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.40 2008/04/01 20:40:21 tg Exp $");
d1340 1
a1340 2
	int nwidth, dwidth;
	int i, n;
d1352 1
a1352 1
		i = strlen(*pp);
d1367 1
a1367 1
	print_columns(shl_out, n, select_fmt_entry, (void *) &smi,
d1388 1
a1388 2
	int nwidth;
	int i, n;
d1391 1
a1391 1
		i = strlen(*pp);
d1394 2
a1395 1
	print_columns(shl_out, n, plain_fmt_entry, (const void *)ap, nwidth + 1, 0);
@


1.40
log
@ unify ksh_dup2() usage, use bool where appropriate
 apply diff from mirbsdksh-1.11:
  #ifdef DUP2_BROKEN
  /* Ultrix systems like to preserve the close-on-exec flag */
   XXX we do #ifdef __ultrix here (imake-style) instead of mirtoconfing it
    (but does anyone know of any other OS with the same problem? plus wed
    see it as we now know the symptoms)
 remove ultrix Build.hs warn=' but might work' in the hope it DOES
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.39 2007/10/25 13:27:00 tg Exp $");
d16 1
a16 1
static const char *dbteste_getopnd(Test_env *, Test_op, int);
d1448 1
a1448 1
dbteste_getopnd(Test_env *te, Test_op op, int do_eval)
@


1.39
log
@clean up
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.38 2007/09/09 18:06:40 tg Exp $");
d112 1
a112 1
			(void) ksh_dup2(pv[1], 1, false); /* stdout of curr */
d119 1
a119 1
			(void) ksh_dup2(pv[0], 0, false); /* stdin of next */
@


1.39.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.41 2008/04/01 22:20:18 tg Exp $");
d16 1
a16 1
static const char *dbteste_getopnd(Test_env *, Test_op, bool);
d112 1
a112 1
			ksh_dup2(pv[1], 1, false); /* stdout of curr */
d119 1
a119 1
			ksh_dup2(pv[0], 0, false); /* stdin of next */
d1448 1
a1448 1
dbteste_getopnd(Test_env *te, Test_op op, bool do_eval)
@


1.39.2.2
log
@MFC: pull up mksh-R34 since itll be required by MirPorts soonish
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.44 2008/05/17 18:46:58 tg Exp $");
d75 1
a75 1
		e->savefd = (short *)alloc(sizeofN(short, NUFILE), ATEMP);
d1340 2
a1341 1
	int nwidth, dwidth, i, n;
d1353 1
a1353 1
		i = utf_mbswidth(*pp);
d1368 1
a1368 1
	print_columns(shl_out, n, select_fmt_entry, (void *)&smi,
d1389 2
a1390 1
	int nwidth, i, n;
d1393 1
a1393 1
		i = utf_mbswidth(*pp);
d1396 1
a1396 2
	print_columns(shl_out, n, plain_fmt_entry, (const void *)ap,
	    nwidth + 1, 0);
@


1.39.2.3
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.48 2008/12/13 17:02:13 tg Exp $");
d75 1
a75 1
		e->savefd = alloc(NUFILE * sizeof (short), ATEMP);
d77 1
a77 1
		memset(e->savefd, 0, NUFILE * sizeof (short));
d932 8
a939 3
			strdupx(tp->val.s, npath.ro, APERM);
			if (npath.ro != name)
				afree(npath.rw, ATEMP);
@


1.38
log
@ fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
 avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
 escape ? as well (but not ] because thats wrong)
  reminded by cbiere@@netbsd via oksh
 Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
 Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@s mksh busy loop problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
 some KNF
 bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.37 2007/07/24 11:22:04 tg Exp $");
a37 8
	/* Is this the end of a pipeline?  If so, we want to evaluate the
	 * command arguments
	bool eval_done = false;
	if ((flags&XFORK) && !(flags&XEXEC) && (flags&XPCLOSE)) {
		eval_done = true;
		tp = eval_execute_args(t, &ap);
	}
	 */
@


1.37
log
@fix another errexit bug: unwind() is __dead, so the pseudo-signal was never
delivered to the process
 regression test by Clint Pachl, verified against Debian ksh93 by me
 place to fix it in the code discovered by Otto Moerbeek
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.46 2006/04/10 14:38:59 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.36 2007/07/22 14:01:48 tg Exp $");
d884 1
a884 1
	const char *npath;
d937 1
a937 1
		npath = search(name, flags & FC_DEFPATH ? def_path : path,
d939 9
a947 2
		if (npath) {
			tp->val.s = str_save(npath, APERM);
d951 1
a951 1
		    (npath = search(name, fpath, R_OK,
d961 1
a961 1
			tp->u.fpath = npath;
@


1.36
log
@ we had an unused variable leftover
 make warning-free for both gcc and xlC
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.35 2007/07/22 13:38:26 tg Exp $");
d365 1
a367 1
		trapsig(SIGERR_);
@


1.35
log
@some null/NUL
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.34 2007/07/22 13:34:49 tg Exp $");
d98 1
a98 1
					errorf("");
@


1.34
log
@ support IBM xlC on AIX
 fix all bugs it could find 
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.33 2007/06/15 21:22:40 tg Exp $");
d409 1
a409 1
	 *   FOO=bar exec > /dev/null		FOO is kept but not exported
d411 1
a411 1
	 *   FOO=bar command exec > /dev/null	FOO is neither kept nor exported
@


1.33
log
@make sure ELF, a.out, COFF, MZ/PE and gzip binaries aren't executed via sh
should save us some error messages
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.32 2007/06/06 23:28:14 tg Exp $");
d73 2
a74 2
				shf_fprintf(shl_out, "%s%s", ap[i],
				    ap[i + 1] ? space : newline);
d98 1
a98 1
					errorf(null);
d489 2
a490 2
			shf_fprintf(shl_out, "%s%s", cp,
			    t->vars[i + 1] ? space : newline);
@


1.32
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.31 2007/05/13 18:49:00 tg Exp $");
d740 13
a753 1
 noshebang:
@


1.31
log
@dead code removal
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.30 2007/05/13 17:51:21 tg Exp $");
d351 1
d353 1
a353 1
		if (errno == ENOEXEC)
d356 1
a356 1
			errorf("%s: %s", s, strerror(errno));
d518 1
a518 1
		volatile int old_xflag;
d541 1
d544 1
a544 1
				    cp, tp->u.fpath, strerror(errno));
d581 1
a581 1
		Flag(FXTRACE) = tp->flag & TRACE ? true : false;
d1142 2
a1143 1
		if (u == -1)
d1147 2
a1148 1
			    "open" : "create", cp, strerror(errno));
d1170 3
d1176 1
a1176 1
			    strerror(errno));
d1222 1
d1225 1
a1225 1
		    h->name, strerror(errno));
d1255 1
d1257 3
a1259 2
		warningf(true, "error writing %s: %s", h->name,
		    strerror(errno));
a1393 3
extern const char *const dbtest_tokens[];
extern const char db_close[];

@


1.30
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.29 2007/04/18 00:59:20 tg Exp $");
a16 1
static int dbteste_eval(Test_env *, Test_op, const char *, const char *, int);
d236 1
a236 1
		te.eval = dbteste_eval;
a1449 7
static int
dbteste_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	return test_eval(te, op, opnd1, opnd2, do_eval);
}

@


1.29
log
@ MKSH_SMALL users want to trade off size vs functionality,
  they thusly don't deserve shebang processing
 fix a comment (spelling; technical correctness)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.28 2007/04/17 21:26:34 tg Exp $");
d620 1
a620 1
			internal_errorf(1, "CFUNC %d", i);
d759 1
a759 1
		internal_errorf(1, "shcomexec: %s", *wp);
d1239 1
a1239 1
			internal_errorf(1, "herein: yylex");
d1462 1
a1462 1
	internal_errorf(0, "dbteste_error: %s (offset %d)", msg, offset);
@


1.29.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
 1004638EE466466C614
 100464368A065F40C08
 10046436B6D392D622C
 10046436DC35AC3B04F
 100464370BA2BF5141D
 10046474FB1292DF336
 100464753C139AD7515
 100464755C253EE3EA9
 100464759DE15635029
 10046475DAE4D3D3C05
 100464760593612AAF2
 100464763537E100BDF
 1004647649434DA3FE1
but not
 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.29 2007/04/18 00:59:20 tg Exp $");
d17 1
d237 1
a237 1
		te.eval = test_eval;
d620 1
a620 1
			internal_errorf("CFUNC %d", i);
d759 1
a759 1
		internal_errorf("shcomexec: %s", *wp);
d1239 1
a1239 1
			internal_errorf("herein: yylex");
d1451 7
d1462 1
a1462 1
	internal_warningf("dbteste_error: %s (offset %d)", msg, offset);
@


1.29.2.2
log
@MFC:
 some harmless optimisations
 remove the -fno-tree-vrp and -fwhole-program --combine stuff
 fix a typo
 fix check for __attribute__
 remove the multi idstring check, always use ours
 fix signal stuff
 fix types
 pick up arc4random.c
 don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
 some regression test fixes
 fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.29.2.1 2007/05/13 19:29:34 tg Exp $");
d738 1
a739 13
		fd = buf[0] << 8 | buf[1];
		if ((fd == /* OMAGIC */ 0407) ||
		    (fd == /* NMAGIC */ 0410) ||
		    (fd == /* ZMAGIC */ 0413) ||
		    (fd == /* QMAGIC */ 0314) ||
		    (fd == /* ECOFF_I386 */ 0x4C01) ||
		    (fd == /* ECOFF_M68K */ 0x0150 || fd == 0x5001) ||
		    (fd == /* ECOFF_SH */   0x0500 || fd == 0x0005) ||
		    (fd == 0x7F45 && buf[2] == 'L' && buf[3] == 'F') ||
		    (fd == /* MZ */ 0x4D5A) ||
		    (fd == /* gzip */ 0x1F8B))
			errorf("%s: not executable: magic %04X", tp->str, fd);
	}
@


1.28
log
@also accept a carriage return as end of shebang line;

helps to at least not get messages like
| sysop@@odem2k:~/mb $ ./foo.sh
| : No such file or directory
| 127|sysop@@odem2k:~/mb $ _
if you forgot to convert CR-LF into LF (of course only if the
kernel fails with ENOEXEC  an ENOENT would not help in these
cases), but of course other things will fail
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.27 2007/04/15 12:09:57 tg Exp $");
d677 1
d681 1
d692 1
d741 1
d748 1
a748 1
	/* report both the program that was run and the bogus shell */
@


1.27
log
@ (re)implement shebang execution file parsing; this makes the and which
  do not start with a "#!shell" sequence part of mksh(1) true again; this
  was probably lost in mksh R21 or so when I decided/saw that our kernel
  always parses shebang lines (code written myself, not taken from pdksh
  again or MirBSD kernel, but verified against both)
 bom+shebang execution now works, no need setting EXECSHELL in the test
 bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.26 2007/03/04 03:04:24 tg Exp $");
d696 1
a696 1
		/* scan for newline or NUL _before_ end of buffer */
d699 1
a699 1
			if (*cp == '\0' || *cp == '\n') {
@


1.26
log
@ remove strcasestr.c, use home-grown implementation, call it stricmp,
  and have it return an API-correct const char *
 enhance and stylify comments
 a little KNF and simplifications
 #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
 new cstrchr, cstrstr (take and give const char *)
 new vstrchr, vstrstr (take const or not, give boolean value)
 new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
 new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
 replace the only use of strrchr with inlined code to shrink
 minor man page fixes
 Minix 3 signames are autogenerated with gcc
 rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
 dot.mkshrc: move MKSH= down to the export line
  to not disturb the PS1 visual impression 
 dot.mkshrc: Lstripcom(): optimise
 bump version

) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better 

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d677 3
d689 49
@


1.25
log
@merge the const branch +- a few
@
text
@d503 1
a503 1
		if (Flag(FRESTRICTED) && strchr(cp, '/')) {
d817 1
a817 1
	if (strchr(name, '/') != NULL) {
d949 1
a949 1
	if (strchr(name, '/')) {
d961 1
a961 1
		if (!(p = strchr(sp, ':')))
@


1.24
log
@* support old environments without libgen.h (ancient GNU/Linux)
  and stdbool.h (ancient GNU/Linux; NetBSD 1.6.1)
* __dead must come after, not before, to accomodate gcc 2.7.2.3
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.23 2007/01/15 00:18:47 tg Exp $");
d7 3
a9 3
static int	comexec(struct op *, struct tbl *volatile, char **,
		    int volatile);
static void	scriptexec(struct op *, char **)
d11 5
a15 5
static int	call_builtin(struct tbl *, char **);
static int	iosetup(struct ioword *, struct tbl *);
static int	herein(const char *, int);
static char	*do_selectargs(char **, bool);
static int	dbteste_isa(Test_env *, Test_meta);
d17 2
a18 4
static int	dbteste_eval(Test_env *, Test_op, const char *, const char *,
		    int);
static void	dbteste_error(Test_env *, int, const char *);

d30 3
a32 2
	char ** volatile ap;
	char *s, *cp;
d65 1
a65 1
		ap = eval(t->args, t->u.evalflags | DOBLANK | DOGLOB | DOTILDE);
d68 2
a69 1
			timex_hook(t, &ap);
d107 1
a107 1
		rv = comexec(t, tp, ap, flags);
d248 3
a250 2
		ap = (t->vars != NULL) ? eval(t->vars, DOBLANK|DOGLOB|DOTILDE) :
		    e->loc->argv + 1;
d318 1
a318 1
		    for (ap = t->vars; *ap; ap++)
d344 1
a344 1
		ap = makenv();
d347 6
a352 1
		execve(t->str, t->args, ap);
d354 1
a354 1
			scriptexec(t, ap);
d377 2
a378 1
comexec(struct op *t, struct tbl *volatile tp, char **ap, volatile int flags)
d382 2
a383 2
	char *cp;
	char **lastp;
d513 1
a513 1
		rv = call_builtin(tp, ap);
d520 1
a520 1
		char *volatile old_kshname;
d565 1
a565 1
			ap[0] = (char *) kshname;
d674 1
a674 1
scriptexec(struct op *tp, char **ap)
a675 1
	static char execshell[] = "/bin/sh";
d677 1
d683 1
a683 1
		sh = execshell;
d686 2
a687 1
	*tp->args = str_save(sh, ATEMP);
d689 2
a690 1
	execve(tp->args[0], tp->args, ap);
d697 1
a697 1
shcomexec(char **wp)
d704 1
a704 1
	return call_builtin(tp, wp);
d780 1
a780 1
builtin(const char *name, int (*func) (char **))
d982 1
a982 1
call_builtin(struct tbl *tp, char **wp)
d1205 2
a1206 2
static char *
do_selectargs(char **ap, bool print_menu)
d1208 2
a1209 4
	static char read_args0[] = "read",
	    read_args1[] = "-r", read_args2[] = "REPLY",
	    *read_args[] = {
		read_args0, read_args1, read_args2, NULL
d1237 3
a1239 3
	char	*const *args;
	int	arg_width;
	int	num_width;
d1260 1
a1260 1
pr_menu(char *const *ap)
d1263 1
a1263 1
	char *const *pp;
d1341 1
a1341 1
	char *p;
d1377 1
a1377 1
	char *s = *te->pos.wp;
@


1.23
log
@ok, -rHEAD shall be unbroken
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22 2007/01/12 10:18:20 tg Exp $");
d9 2
a10 1
static __dead void scriptexec(struct op *, char **);
@


1.22
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.21 2007/01/12 01:49:27 tg Exp $");
d668 1
d675 1
a675 1
		sh = "/bin/sh";
d678 1
a678 1
	*tp->args = sh;
d1198 4
a1201 2
	static const char *const read_args[] = {
		"read", "-r", "REPLY", NULL
@


1.22.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.24 2007/01/17 22:51:46 tg Exp $");
d9 1
a9 2
static void	scriptexec(struct op *, char **)
    __attribute__((noreturn));
a667 1
	static char execshell[] = "/bin/sh";
d674 1
a674 1
		sh = execshell;
d677 1
a677 1
	*tp->args = str_save(sh, ATEMP);
d1197 2
a1198 4
	static char read_args0[] = "read",
	    read_args1[] = "-r", read_args2[] = "REPLY",
	    *read_args[] = {
		read_args0, read_args1, read_args2, NULL
@


1.22.2.2
log
@something in the merge didn't work out
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22.2.1 2007/03/03 21:37:54 tg Exp $");
d669 1
d676 1
a676 1
		sh = "/bin/sh";
d679 1
a679 1
	*tp->args = sh;
d1199 4
a1202 2
	static const char *const read_args[] = {
		"read", "-r", "REPLY", NULL
@


1.22.2.3
log
@begin constification
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22.2.2 2007/03/03 21:43:48 tg Exp $");
d7 3
a9 3
static int comexec(struct op *, struct tbl *volatile, const char **,
    int volatile);
static void scriptexec(struct op *, char **)
d11 5
a15 5
static int call_builtin(struct tbl *, const char **);
static int iosetup(struct ioword *, struct tbl *);
static int herein(const char *, int);
static char *do_selectargs(char **, bool);
static int dbteste_isa(Test_env *, Test_meta);
d17 4
a20 2
static int dbteste_eval(Test_env *, Test_op, const char *, const char *, int);
static void dbteste_error(Test_env *, int, const char *);
d33 1
a33 1
	const char *s, *cp;
d107 1
a107 1
		rv = comexec(t, tp, (const char **)ap, flags);
d346 1
a346 6
		{
			union mksh_ccphack cargs;

			cargs.ro = t->args;
			execve(t->str, cargs.rw, ap);
		}
d371 1
a371 2
comexec(struct op *t, struct tbl *volatile tp, const char **ap,
    volatile int flags)
d375 2
a376 2
	const char *cp;
	const char **lastp;
d506 1
a506 1
		rv = call_builtin(tp, (const char **)ap);
a669 1
	union mksh_ccphack args;
d678 1
a678 2
	args.ro = tp->args;
	*args.ro = sh;
d680 1
a680 1
	execve(args.rw[0], args.rw, ap);
d694 1
a694 1
	return (call_builtin(tp, (const char **)wp));
d770 1
a770 1
builtin(const char *name, int (*func) (const char **))
d972 1
a972 1
call_builtin(struct tbl *tp, const char **wp)
d1198 1
a1198 1
	static const char *read_args[] = {
@


1.22.2.4
log
@more constification
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22.2.3 2007/03/03 22:38:23 tg Exp $");
d9 1
a9 1
static void scriptexec(struct op *, const char **)
d14 1
a14 1
static const char *do_selectargs(const char **, bool);
d30 1
a30 2
	const char ** volatile ap;
	char ** volatile uap;
d64 1
a64 2
		ap = (const char **)eval(t->args,
		    t->u.evalflags | DOBLANK | DOGLOB | DOTILDE);
d246 2
a247 3
		ap = (t->vars == NULL) ? e->loc->argv + 1 :
		    (const char **)eval((const char **)t->vars,
		    DOBLANK | DOGLOB | DOTILDE);
d315 1
a315 1
		    for (ap = (const char **)t->vars; *ap; ap++)
d341 1
a341 1
		uap = makenv();
d348 1
a348 1
			execve(t->str, cargs.rw, uap);
d351 1
a351 1
			scriptexec(t, (const char **)uap);
d517 1
a517 1
		const char *volatile old_kshname;
d562 1
a562 1
			ap[0] = kshname;
d671 1
a671 1
scriptexec(struct op *tp, const char **ap)
d674 1
a674 1
	union mksh_ccphack args, cap;
d686 1
a686 2
	cap.ro = ap;
	execve(args.rw[0], args.rw, cap.rw);
d1201 2
a1202 2
static const char *
do_selectargs(const char **ap, bool print_menu)
d1233 3
a1235 3
	const char *const *args;
	int arg_width;
	int num_width;
d1256 1
a1256 1
pr_menu(const char *const *ap)
d1259 1
a1259 1
	const char *const *pp;
d1337 1
a1337 1
	const char *p;
d1373 1
a1373 1
	const char *s = *te->pos.wp;
@


1.22.2.5
log
@more constification
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22.2.4 2007/03/03 22:51:18 tg Exp $");
d65 2
a66 1
		uap = eval(t->args, t->u.evalflags | DOBLANK|DOGLOB|DOTILDE);
d69 1
a69 2
			timex_hook(t, &uap);
		ap = (const char **)uap;
@


1.22.2.6
log
@more constification
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.22.2.5 2007/03/03 23:38:35 tg Exp $");
d697 1
a697 1
shcomexec(const char **wp)
d704 1
a704 1
	return (call_builtin(tp, wp));
@


1.21
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.20 2006/11/12 14:58:14 tg Exp $");
d9 1
a9 1
static void	scriptexec(struct op *, char **) __dead;
d84 1
a84 1
		/* initialize to not redirected */
d209 1
a209 1
		 * forks again for async...  parent should optimize
a667 1
	static char execshell[] = "/bin/sh";
d674 1
a674 1
		sh = execshell;
d677 1
a677 1
	*tp->args = str_save(sh, ATEMP);
d1197 2
a1198 4
	static char read_args0[] = "read",
	    read_args1[] = "-r", read_args2[] = "REPLY",
	    *read_args[] = {
		read_args0, read_args1, read_args2, NULL
@


1.20
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.19 2006/11/10 06:16:24 tg Exp $");
d9 1
a9 1
static void scriptexec(struct op *, char **) __attribute__((noreturn));
@


1.19
log
@don't use setreuid(2) etc. stuff, like OpenBSD
only affects suid shell scripts, which are *ugh* anyway,
and I really have no idea what the old code did, when, why, etc.
262t 16d 2i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.18 2006/11/10 04:03:58 tg Exp $");
d669 1
a669 1
	char *sh;
d678 1
a678 1
	*tp->args = sh;
d805 1
a805 1
	char *npath;
d861 1
a861 1
			tp->val.s = tp == &temp ? npath : str_save(npath, APERM);
d927 1
a927 1
char *
d941 1
a941 1
			return (char *) name;
d1198 4
a1201 2
	static const char *const read_args[] = {
		"read", "-r", "REPLY", NULL
d1217 1
a1217 1
		if (call_builtin(findcom("read", FC_BI), (char **) read_args))
d1234 1
a1234 1
static char *select_fmt_entry(void *arg, int i, char *buf, int buflen);
d1238 1
a1238 1
select_fmt_entry(void *arg, int i, char *buf, int buflen)
d1240 2
a1241 1
	struct select_menu_info *smi = (struct select_menu_info *) arg;
d1292 1
a1292 1
static char *plain_fmt_entry(void *arg, int i, char *buf, int buflen);
d1295 1
a1295 1
plain_fmt_entry(void *arg, int i, char *buf, int buflen)
d1312 1
a1312 1
	print_columns(shl_out, n, plain_fmt_entry, (void *) ap, nwidth + 1, 0);
@


1.18
log
@thanks to the nice property of my reimplementation of getn to also
return a value in case of an error (0 or the partial result, which
is the full result in case of trailing junk even), using it to rid
atoi() is possible, saving 9t 4d 1i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.17 2006/11/10 01:44:39 tg Exp $");
d836 1
a836 1
		if (tp && (tp->flag & ISSET) && eaccess(tp->val.s, X_OK) != 0) {
d910 1
a910 1
	ret = eaccess(lpath, mode);
@


1.17
log
@* change EXECSHELL to /bin/sh (we can override it via environment anyway,
  and this is a sensible choice instead of ourselves)
* move this stuff from sh.h into exec.c where it belongs
* simplify set -o stuff

saves 8 bytes
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.16 2006/08/01 13:43:26 tg Exp $");
d1219 1
a1219 1
			i = atoi(s);
@


1.16
log
@style(9)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.15 2006/05/10 18:54:10 tg Exp $");
d668 1
d671 1
a671 1
	sh = str_val(global(EXECSHELL_STR));
d675 1
a675 1
		sh = strdup(EXECSHELL);
@


1.15
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.14 2006/01/30 12:37:22 tg Exp $");
d321 1
a321 1
	  Found:
d351 1
a351 1
    Break:
d657 1
a657 1
  Leave:
d844 1
a844 1
  Search:
@


1.14
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.44 2005/12/11 20:31:21 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.13 2006/01/29 20:04:51 tg Exp $");
d116 2
a117 3
		e->savefd[0] = savefd(0, 0);
		(void) ksh_dup2(e->savefd[0], 0, false); /* stdin of first */
		e->savefd[1] = savefd(1, 0);
d162 1
a162 1
			/*NOTREACHED*/
d172 2
a173 2
		e->savefd[0] = savefd(0, 0);
		e->savefd[1] = savefd(1, 0);
d609 1
a609 1
			/*NOTREACHED*/
d1093 1
a1093 1
			e->savefd[iop->unit] = savefd(iop->unit, 1);
@


1.13
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.12 2005/11/22 18:40:41 tg Exp $");
d398 1
a398 1
	 * we know if we should create a local block, which must be done
@


1.12
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.42 2005/09/11 18:02:27 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.11 2005/11/22 18:36:19 tg Exp $");
d691 1
a691 1
	tp = tsearch(&builtins, *wp, hash(*wp));
d708 1
a708 1
		tp = tsearch(&l->funs, name, h);
d712 1
a712 1
			tp = tenter(&l->funs, name, h);
d754 1
a754 1
		tdelete(tp);
d787 1
a787 1
	tp = tenter(&builtins, name, hash(name));
d813 1
a813 1
	tbi = (flags & FC_BI) ? tsearch(&builtins, name, h) : NULL;
d835 1
a835 1
		tp = tsearch(&taliases, name, h);
d850 1
a850 1
				tp = tenter(&taliases, name, h);
d890 1
a890 1
	for (twalk(&ts, &taliases); (tp = tnext(&ts)) != NULL; )
d1230 1
a1230 1
} info;
@


1.11
log
@Change interpretation of '\"' in here documents with substitution
according to SUSv3 and other modern shells (POSIX allows both).
Idea for the patch (add another lex state) from OpenBSD, but the
implementation differs slightly (and is better in quality).

Also add two testcases (/bin/sh passes both, old mksh only one),
and document the change in the manual page. Sync RCS IDs with OBSD.
@
text
@a0 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.10 2005/10/25 19:53:27 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.10 2005/10/25 19:53:27 tg Exp $");
@


1.10
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/exec.c,v 1.9 2005/10/08 19:30:58 tg Exp $ */
/*	$OpenBSD: exec.c,v 1.41 2005/03/30 17:16:37 deraadt Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.9 2005/10/08 19:30:58 tg Exp $");
d1173 1
a1173 1
		if (yylex(ONEWORD) != LWORD)
@


1.9
log
@our test(1) promises we can do string1 < string2, and
our /bin/test uses mksh... so we pee (literally) on
POSIX and don't accept < and > only for [[ ... ]] operator
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.8 2005/07/07 22:00:45 tg Exp $ */
a4 2
#include <sys/stat.h>
#include <ctype.h>
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.8 2005/07/07 22:00:45 tg Exp $");
@


1.8
log
@undo fix for Debian PR #71256 which turned to be bogus and break make(1)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.4 2005/05/25 13:45:59 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.2 2005/05/23 15:18:16 tg Exp $");
d1351 1
a1351 1
			ret = test_isop(te, meta, buf);
@


1.7
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.6 2005/07/04 12:27:25 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.6 2005/07/04 12:27:25 tg Exp $");
a32 1
	volatile int rv_prop = 0; /* rv being propogated or newly generated? */
a113 1
		rv_prop = 1;
a225 1
		rv_prop = 1;
a267 1
		rv_prop = 1;
a276 1
					rv_prop = 0;
a305 1
		rv_prop = 1;
a314 1
		rv_prop = 1;
a326 1
		rv_prop = 1;
a330 1
		rv_prop = 1;
a341 1
		rv_prop = 1;
d362 1
a362 1
		if (Flag(FERREXIT) && !rv_prop)
@


1.6
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.5 2005/05/25 14:07:29 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.5 2005/05/25 14:07:29 tg Exp $");
d401 1
a401 1
	if (!Flag(FSH) && Flag(FTALKING) && *(lastp = ap)) {
d650 4
a653 6
		if (!Flag(FSH)) {
			/* set $_ to programme's full path */
			/* setstr() can't fail here */
			setstr(typeset("_", LOCAL|EXPORT, 0, INTEGER, 0),
			    tp->val.s, KSH_RETURN_ERROR);
		}
@


1.5
log
@the new pdksh maintainer's patch is bogus
he didn't even run the testsuite

now, in not-rv_pass mode, traps are still executed
XXX look where this could break
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.4 2005/05/25 13:45:59 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.4 2005/05/25 13:45:59 tg Exp $");
a846 8
	/* todo: posix says non-special/non-regular builtins must
	 * be triggered by some user-controllable means like a
	 * special directory in PATH.  Requires modifications to
	 * the search() function.  Tracked aliases should be
	 * modified to allow tracking of builtin commands.
	 * This should be under control of the FPOSIX flag.
	 * If this is changed, also change c_whence...
	 */
@


1.4
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.3 2005/05/25 11:31:15 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.3 2005/05/25 11:31:15 tg Exp $");
d371 2
a372 2
	if (rv != 0 && !rv_prop && !(flags & XERROK)) {
		if (Flag(FERREXIT))
@


1.3
log
@new upstream patch ftp://ftp.cs.mun.ca/pub/pdksh/pdksh-5.2.14-patches.2
from maintainer via Debian PR #71256
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.2 2005/05/23 15:18:16 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.2 2005/05/23 15:18:16 tg Exp $");
d859 1
a859 1
		if (tp && (tp->flag & ISSET) && access(tp->val.s, X_OK) != 0) {
d933 1
a933 1
	ret = access(lpath, mode);
@


1.2
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/exec.c,v 1.1 2005/05/23 03:06:07 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.1 2005/05/23 03:06:07 tg Exp $");
d33 1
d115 1
d228 1
d271 1
d281 1
d311 1
d321 1
d334 1
d339 1
d351 1
d371 1
a371 1
	if (rv != 0 && !(flags & XERROK)) {
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/exec.c,v 1.8 2005/05/23 02:20:35 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: mksh/exec.c,v 1.8 2005/05/23 02:20:35 tg Exp $");
d322 1
a322 1
			    gmatch(cp, s, false))
@

