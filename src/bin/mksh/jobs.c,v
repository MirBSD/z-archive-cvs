head	1.128;
access;
symbols
	mksh-R57:1.127
	mksh-R56c:1.125
	mksh-R56b:1.124
	mksh-R56:1.124
	mksh-R55:1.121
	mksh-R54:1.121
	mksh-R53a:1.121
	mksh-R53:1.121
	mksh-R52c:1.120
	mksh-R52b:1.117
	mksh-R52:1.116
	mksh-R51:1.112
	mksh-R50f:1.105.2.2
	mksh-R50e:1.105.2.1
	mksh-R50stable:1.105.0.2
	mksh-R50d:1.105
	mksh-R50c:1.105
	mksh-R50b:1.104
	mksh-R50:1.104
	mksh-R49:1.103
	mksh-R48b:1.100
	mksh-R48:1.100
	mksh-R47:1.99
	mksh-R46:1.96
	mksh-R45:1.95
	mksh-R44:1.94
	mksh-R43:1.94
	mksh-R42b:1.94
	mksh-R41c:1.91.2.2
	mksh-R41b:1.91.2.2
	mksh-R42:1.94
	mksh-R41:1.91
	mksh-R41stable:1.91.0.2
	mksh-wheezy:1.88.0.4
	tg-multikey-bind:1.88.0.2
	mksh-R40f:1.84
	mksh-R40e:1.84
	mksh-R40d:1.81
	mksh-R40c:1.81
	mksh-R40b:1.78.2.2
	mksh-R40stable:1.84.0.4
	mksh-R40:1.78
	mksh-R39c:1.67
	mksh-R39b:1.67
	tg-wcswidth-behaviour:1.63.0.2
	tg-nameref:1.59.0.2
	mksh-R39:1.59
	tg-mksh-printf-builtin:1.57.0.2
	mksh-R38c:1.56
	mksh-R38b:1.53
	mksh-R38:1.53
	mksh-R37c:1.52
	mksh-R37b:1.51
	mksh-R37:1.46
	mksh-R36b:1.42
	tg-aalloc-experimental_BASE:1.40
	tg-aalloc-experimental:1.40.0.2
	mksh-R36:1.37
	mksh-R35b:1.36
	mksh-R35:1.36
	mksh-R33d:1.33
	mksh-R33c:1.33
	mksh-R33b:1.32
	MIRBSD_10:1.32.0.2
	MIRBSD_10_BASE:1.32
	mksh-R33:1.32
	mksh-R32:1.32
	mksh-R31d:1.28
	mksh-R31c:1.28
	mksh-R31b:1.28
	mksh-R31:1.26
	mksh-R30:1.25
	mksh-R29g:1.21.2.1
	mksh-R29f:1.21.2.1
	mksh-R29e:1.21.2.1
	mksh-R29stable:1.21.0.2
	mksh-R29d:1.21
	mksh-R29c:1.21
	mksh-R29b:1.20
	mksh-R29:1.19
	mksh-R28:1.11
	tg-mksh-plan9ape_BASE:1.11
	tg-mksh-plan9ape:1.9.0.2
	mksh-R27e:1.8
	MIRBSD_9_BASE:1.8
	mksh-R27d:1.8
	mksh-R27:1.8
	mksh-R26c:1.6
	mksh-R26b:1.6
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	mksh-R26:1.6
	mksh-R25:1.5
	mksh-R24c:1.4
	mksh-R24b:1.4
	mksh-R24:1.3
	mksh-R23:1.2
	mksh-R22:1.2
	mksh-R21:1.2;
locks; strict;
comment	@ * @;


1.128
date	2019.12.11.19.46.20;	author tg;	state Exp;
branches;
next	1.127;
commitid	1005DF1479722FAFDAC;

1.127
date	2018.07.15.16.23.10;	author tg;	state Exp;
branches;
next	1.126;
commitid	1005B4B750562480E76;

1.126
date	2018.05.08.17.37.35;	author tg;	state Exp;
branches;
next	1.125;
commitid	1005AF1E0675260363E;

1.125
date	2018.01.05.20.08.34;	author tg;	state Exp;
branches;
next	1.124;
commitid	1005A4FDB544C9CF44C;

1.124
date	2017.08.08.14.30.10;	author tg;	state Exp;
branches;
next	1.123;
commitid	1005989CAFE73C99243;

1.123
date	2017.08.08.14.29.23;	author tg;	state Exp;
branches;
next	1.122;
commitid	1005989CAD249D0472F;

1.122
date	2017.04.27.19.33.50;	author tg;	state Exp;
branches;
next	1.121;
commitid	100590247A92C66CAF9;

1.121
date	2016.07.25.00.04.44;	author tg;	state Exp;
branches;
next	1.120;
commitid	1005795579F14A3FE5C;

1.120
date	2016.03.04.14.26.13;	author tg;	state Exp;
branches;
next	1.119;
commitid	10056D99B037D4D691D;

1.119
date	2016.02.24.01.44.45;	author tg;	state Exp;
branches;
next	1.118;
commitid	10056CD0AFA12B0CBA5;

1.118
date	2016.01.21.18.24.41;	author tg;	state Exp;
branches;
next	1.117;
commitid	10056A12268001BF859;

1.117
date	2016.01.14.23.18.09;	author tg;	state Exp;
branches;
next	1.116;
commitid	10056982CC2089C928B;

1.116
date	2015.10.09.16.11.15;	author tg;	state Exp;
branches;
next	1.115;
commitid	1005617E72E4A2BA371;

1.115
date	2015.09.05.19.19.05;	author tg;	state Exp;
branches;
next	1.114;
commitid	10055EB402C54C3076B;

1.114
date	2015.09.05.17.20.19;	author tg;	state Exp;
branches;
next	1.113;
commitid	10055EB24573F1E0C48;

1.113
date	2015.08.13.21.38.19;	author tg;	state Exp;
branches;
next	1.112;
commitid	10055CD0E35383B51C9;

1.112
date	2015.04.19.14.40.09;	author tg;	state Exp;
branches;
next	1.111;
commitid	1005533BE52080CD0EC;

1.111
date	2015.04.19.14.23.26;	author tg;	state Exp;
branches;
next	1.110;
commitid	1005533BA6234EE262D;

1.110
date	2015.03.01.16.02.48;	author tg;	state Exp;
branches;
next	1.109;
commitid	10054F3383E4E01EF7A;

1.109
date	2015.03.01.15.43.09;	author tg;	state Exp;
branches;
next	1.108;
commitid	10054F33364551D895A;

1.108
date	2015.02.20.13.08.28;	author tg;	state Exp;
branches;
next	1.107;
commitid	10054E731E407F80FBA;

1.107
date	2015.02.20.12.43.22;	author tg;	state Exp;
branches;
next	1.106;
commitid	10054E72C025D6931EE;

1.106
date	2014.11.25.21.13.27;	author tg;	state Exp;
branches;
next	1.105;
commitid	1005474F00E09321C83;

1.105
date	2014.10.03.12.32.48;	author tg;	state Exp;
branches
	1.105.2.1;
next	1.104;
commitid	100542E977A1C8B92E5;

1.104
date	2014.06.10.22.17.09;	author tg;	state Exp;
branches;
next	1.103;
commitid	100539783DC1BABB2C6;

1.103
date	2013.11.30.17.41.35;	author tg;	state Exp;
branches;
next	1.102;
commitid	100529A23520014334E;

1.102
date	2013.09.10.17.33.01;	author tg;	state Exp;
branches;
next	1.101;
commitid	100522F57C13E265FDE;

1.101
date	2013.09.10.16.51.17;	author tg;	state Exp;
branches;
next	1.100;
commitid	100522F4E00173F2A67;

1.100
date	2013.07.26.20.33.23;	author tg;	state Exp;
branches;
next	1.99;
commitid	10051F2DD2B49D415C3;

1.99
date	2013.06.02.03.09.15;	author tg;	state Exp;
branches;
next	1.98;
commitid	10051AAB6AE4E828507;

1.98
date	2013.06.01.20.34.01;	author tg;	state Exp;
branches;
next	1.97;
commitid	10051AA5AD1211D71C7;

1.97
date	2013.05.31.23.59.07;	author tg;	state Exp;
branches;
next	1.96;
commitid	10051A9395A31BA9864;

1.96
date	2013.05.02.20.28.12;	author tg;	state Exp;
branches;
next	1.95;
commitid	1005182CC714DDF0A48;

1.95
date	2013.04.01.02.37.50;	author tg;	state Exp;
branches;
next	1.94;
commitid	1005158F2D44922CF13;

1.94
date	2012.12.28.02.28.36;	author tg;	state Exp;
branches;
next	1.93;
commitid	10050DD03E43C678B81;

1.93
date	2012.12.17.23.18.06;	author tg;	state Exp;
branches;
next	1.92;
commitid	10050CFA81334F40D7F;

1.92
date	2012.12.04.01.18.31;	author tg;	state Exp;
branches;
next	1.91;
commitid	10050BD4F7642624FD1;

1.91
date	2012.11.30.19.25.03;	author tg;	state Exp;
branches
	1.91.2.1;
next	1.90;
commitid	10050B907135D4B5928;

1.90
date	2012.11.30.19.20.01;	author tg;	state Exp;
branches;
next	1.89;
commitid	10050B906D807506D4B;

1.89
date	2012.11.30.19.02.07;	author tg;	state Exp;
branches;
next	1.88;
commitid	10050B902B82AAA0C3F;

1.88
date	2012.05.04.22.34.50;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004FA4598C7DB8428A;

1.87
date	2012.05.04.22.18.25;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004FA455C411397094;

1.86
date	2012.05.04.21.48.29;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004FA44EC41EDBB764;

1.85
date	2012.04.27.16.16.22;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004F9AC66A708942C6;

1.84
date	2012.02.06.17.49.52;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004F3012BD1CCF6019;

1.83
date	2012.02.06.17.42.23;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004F3010EC139BAB7F;

1.82
date	2011.12.31.00.52.22;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004EFE5CDD310861C7;

1.81
date	2011.08.27.18.06.46;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004E5932432420AA61;

1.80
date	2011.07.16.23.37.58;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004E2220ED45EF593A;

1.79
date	2011.07.16.17.41.50;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004E21CD746928BA51;

1.78
date	2011.04.22.12.21.54;	author tg;	state Exp;
branches
	1.78.2.1;
next	1.77;
commitid	1004DB172EA6A5331AE;

1.77
date	2011.03.13.01.20.20;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004D7C1BE368F5B459;

1.76
date	2011.03.06.17.08.12;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004D73BF8011CAE269;

1.75
date	2011.02.18.22.26.09;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004D5EF0ED2C0C9394;

1.74
date	2011.01.30.01.35.34;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004D44C07439762D63;

1.73
date	2011.01.21.21.04.44;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004D39F4C639F3DCA7;

1.72
date	2010.08.28.20.22.19;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004C796FE40C544CCE;

1.71
date	2010.08.28.18.50.53;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004C795A82072326AF;

1.70
date	2010.08.28.15.48.19;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004C792FD945CE393C;

1.69
date	2010.07.04.17.33.54;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004C30C5ED28DF693B;

1.68
date	2010.07.04.13.36.42;	author tg;	state Exp;
branches;
next	1.67;
commitid	1004C308E614DF59FFB;

1.67
date	2009.12.31.14.05.43;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004B3CAF8C011FFD00;

1.66
date	2009.12.12.22.27.08;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004B2418AF282F4231;

1.65
date	2009.12.12.17.45.42;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004B23D6CF08F454DD;

1.64
date	2009.12.05.22.03.39;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004B1AD8CC77F2038C;

1.63
date	2009.11.22.14.14.42;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004B094763654ADE9A;

1.62
date	2009.10.17.21.16.02;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004ADA339B53B8111A;

1.61
date	2009.09.26.03.39.59;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004ABD8CE62D55CFD8;

1.60
date	2009.09.20.16.40.55;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004AB65AF3542D0922;

1.59
date	2009.08.01.20.32.44;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004A74A6770161F3E7;

1.58
date	2009.07.25.21.31.25;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004A6B79B87CB15A8B;

1.57
date	2009.06.11.12.42.19;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004A30FBB114E3FED9;

1.56
date	2009.06.10.18.12.47;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004A2FF7913BD44883;

1.55
date	2009.06.08.20.34.40;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004A2D75D22EFFE1BD;

1.54
date	2009.06.08.20.06.47;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004A2D6F3A31FB4CBC;

1.53
date	2009.05.16.16.59.36;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004A0EF0664EF4168D;

1.52
date	2009.04.07.18.41.36;	author tg;	state Exp;
branches;
next	1.51;
commitid	10049DB9E493037411A;

1.51
date	2009.04.05.13.37.37;	author tg;	state Exp;
branches;
next	1.50;
commitid	10049D8B3D672B61FE1;

1.50
date	2009.04.05.13.07.11;	author tg;	state Exp;
branches;
next	1.49;
commitid	10049D8AD1711259F64;

1.49
date	2009.04.05.12.35.31;	author tg;	state Exp;
branches;
next	1.48;
commitid	10049D8A5A72FBB1A39;

1.48
date	2009.04.03.09.48.10;	author tg;	state Exp;
branches;
next	1.47;
commitid	10049D5DB602C9CD163;

1.47
date	2009.04.03.09.42.25;	author tg;	state Exp;
branches;
next	1.46;
commitid	10049D5DA0C4A6791E6;

1.46
date	2009.03.26.11.22.53;	author tg;	state Exp;
branches;
next	1.45;
commitid	10049CB65945BCEBC45;

1.45
date	2009.03.22.17.47.37;	author tg;	state Exp;
branches;
next	1.44;
commitid	10049C679C543D854C9;

1.44
date	2009.02.23.16.17.44;	author tg;	state Exp;
branches;
next	1.43;
commitid	10049A2CBFC1EFD3081;

1.43
date	2008.12.29.20.47.15;	author tg;	state Exp;
branches;
next	1.42;
commitid	10049593769614169C5;

1.42
date	2008.12.13.17.02.15;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004943EAA830C0300B;

1.41
date	2008.11.30.10.33.38;	author tg;	state Exp;
branches;
next	1.40;
commitid	10049326BED703E2AC2;

1.40
date	2008.11.12.00.54.49;	author tg;	state Exp;
branches
	1.40.2.1;
next	1.39;
commitid	100491A295841A6D8EB;

1.39
date	2008.11.09.20.32.18;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004917488700179B64;

1.38
date	2008.10.26.21.51.26;	author ahoka;	state Exp;
branches;
next	1.37;
commitid	1004904E5B13CEB9815;

1.37
date	2008.10.13.23.06.03;	author tg;	state Exp;
branches;
next	1.36;
commitid	10048F3D44866CCA1C2;

1.36
date	2008.05.17.19.03.25;	author tg;	state Exp;
branches;
next	1.35;
commitid	100482F2BD46FF51562;

1.35
date	2008.05.17.18.46.59;	author tg;	state Exp;
branches;
next	1.34;
commitid	100482F280E7B53AA4C;

1.34
date	2008.05.15.15.24.09;	author tg;	state Exp;
branches;
next	1.33;
commitid	100482C558039271D26;

1.33
date	2008.04.01.21.50.58;	author tg;	state Exp;
branches;
next	1.32;
commitid	10047F2AE2966CBAC7A;

1.32
date	2007.10.25.15.23.09;	author tg;	state Exp;
branches
	1.32.2.1;
next	1.31;
commitid	1004720B4ED147A8549;

1.31
date	2007.10.25.14.18.56;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004720A5D93951F8E8;

1.30
date	2007.10.25.13.51.18;	author tg;	state Exp;
branches;
next	1.29;
commitid	10047209F6430D35627;

1.29
date	2007.10.25.13.27.00;	author tg;	state Exp;
branches;
next	1.28;
commitid	100472099B90238AE38;

1.28
date	2007.09.09.19.12.10;	author tg;	state Exp;
branches;
next	1.27;
commitid	10046E445901D2B8C34;

1.27
date	2007.09.09.18.06.41;	author tg;	state Exp;
branches;
next	1.26;
commitid	10046E436442CDF8871;

1.26
date	2007.08.12.13.42.21;	author tg;	state Exp;
branches;
next	1.25;
commitid	10046BF0E4F7055959B;

1.25
date	2007.07.22.13.34.50;	author tg;	state Exp;
branches;
next	1.24;
commitid	10046A35CEC35BB7B5F;

1.24
date	2007.06.06.23.41.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	100466746376C2C11A9;

1.23
date	2007.06.06.23.28.15;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004667430836D68E66;

1.22
date	2007.05.13.17.51.22;	author tg;	state Exp;
branches;
next	1.21;
commitid	10046474FB1292DF336;

1.21
date	2007.04.19.12.07.46;	author tg;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	10046275BA351DB0959;

1.20
date	2007.03.10.18.16.27;	author tg;	state Exp;
branches;
next	1.19;
commitid	10045F2F60A6B49F58A;

1.19
date	2007.03.04.03.04.25;	author tg;	state Exp;
branches;
next	1.18;
commitid	10045EA374B3374AB35;

1.18
date	2007.01.12.10.18.21;	author tg;	state Exp;
branches;
next	1.17;
commitid	10045A76059104E0EFB;

1.17
date	2007.01.12.01.49.28;	author tg;	state Exp;
branches;
next	1.16;
commitid	10045A6E8B92FCAC95A;

1.16
date	2006.11.12.13.20.15;	author tg;	state Exp;
branches;
next	1.15;
commitid	10045571F9F338D4579;

1.15
date	2006.11.12.12.49.25;	author tg;	state Exp;
branches;
next	1.14;
commitid	10045571861610DDB49;

1.14
date	2006.11.10.07.52.03;	author tg;	state Exp;
branches;
next	1.13;
commitid	10045542F8269E05F56;

1.13
date	2006.11.10.04.03.59;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004553F9E36E96466A;

1.12
date	2006.11.09.22.08.07;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004553A6D03FB3FB12;

1.11
date	2006.08.28.01.25.33;	author tg;	state Exp;
branches;
next	1.10;
commitid	10044F245FF31EA58DA;

1.10
date	2006.08.24.20.32.53;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044EE0CE2267A59CF;

1.9
date	2006.08.01.13.43.27;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10044CF5A93693A5C0A;

1.8
date	2006.05.10.18.54.11;	author tg;	state Exp;
branches;
next	1.7;
commitid	100446236E6726083C8;

1.7
date	2006.01.30.12.37.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043DE088533ED5341;

1.6
date	2005.11.22.18.40.42;	author tg;	state Exp;
branches;
next	1.5;
commitid	108a438366254326;

1.5
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.4;
commitid	76cc435e8d34d8ce;

1.4
date	2005.08.21.12.43.55;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	2cc8430876cfbbd2;

1.3
date	2005.07.04.12.27.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	3ec342c92b3a8874;

1.2
date	2005.05.23.16.23.19;	author tg;	state Exp;
branches;
next	1.1;
commitid	1d3a429203880b55;

1.1
date	2005.05.23.03.06.08;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.105.2.1
date	2015.01.25.15.44.06;	author tg;	state Exp;
branches;
next	1.105.2.2;
commitid	10054C50F46587DFA27;

1.105.2.2
date	2015.04.19.19.18.18;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.91.2.1
date	2012.12.04.01.26.27;	author tg;	state Exp;
branches;
next	1.91.2.2;
commitid	10050BD5149729CD584;

1.91.2.2
date	2013.02.10.17.11.25;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.78.2.1
date	2011.07.16.17.41.49;	author tg;	state Exp;
branches;
next	1.78.2.2;
commitid	1004E21CD746928BA51;

1.78.2.2
date	2011.07.16.23.37.59;	author tg;	state Exp;
branches;
next	;
commitid	1004E2220ED45EF593A;

1.40.2.1
date	2008.11.22.13.20.31;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.32.2.1
date	2008.04.22.13.29.28;	author tg;	state Exp;
branches;
next	1.32.2.2;
commitid	100480DE80F32BAA72D;

1.32.2.2
date	2008.05.19.18.41.25;	author tg;	state Exp;
branches;
next	1.32.2.3;
commitid	1004831C9A63DA06745;

1.32.2.3
date	2008.12.14.00.07.43;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.21.2.1
date	2007.05.13.19.29.36;	author tg;	state Exp;
branches;
next	;
commitid	1004647668D4636830B;

1.9.2.1
date	2006.08.24.19.17.57;	author tg;	state Exp;
branches;
next	1.9.2.2;
commitid	10044EDFB754D0F30C4;

1.9.2.2
date	2006.08.24.19.52.56;	author tg;	state Exp;
branches;
next	1.9.2.3;
commitid	10044EE03AB30C6D00A;

1.9.2.3
date	2006.08.24.19.59.41;	author tg;	state Exp;
branches;
next	1.9.2.4;
commitid	10044EE054054E33D71;

1.9.2.4
date	2006.08.24.20.52.12;	author tg;	state Exp;
branches;
next	1.9.2.5;
commitid	10044EE117A130AF943;

1.9.2.5
date	2006.08.28.01.49.18;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.128
log
@hide ALLOC_ITEM in struct job explicitly as well

ubsan says it has larger alignment requirements
@
text
@/*	$OpenBSD: jobs.c,v 1.43 2015/09/10 22:48:58 nicm Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
 *		 2012, 2013, 2014, 2015, 2016, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.125 2018/01/05 20:08:34 tg Exp $");

#if HAVE_KILLPG
#define mksh_killpg		killpg
#else
/* cross fingers and hope kill is killpg-endowed */
#define mksh_killpg(p,s)	kill(-(p), (s))
#endif

/* Order important! */
#define PRUNNING	0
#define PEXITED		1
#define PSIGNALLED	2
#define PSTOPPED	3

typedef struct proc Proc;
/* to take alignment into consideration */
struct proc_dummy {
	Proc *next;
	pid_t pid;
	int state;
	int status;
	char command[128];
};
/* real structure */
struct proc {
	/* next process in pipeline (if any) */
	Proc *next;
	/* process id of this Unix process in the job */
	pid_t pid;
	/* one of the four P… above */
	int state;
	/* wait status */
	int status;
	/* process command string from vistree */
	char command[256 - (ALLOC_OVERHEAD +
	    offsetof(struct proc_dummy, command[0]))];
};

/* Notify/print flag - j_print() argument */
#define JP_SHORT	1	/* print signals processes were killed by */
#define JP_MEDIUM	2	/* print [job-num] -/+ command */
#define JP_LONG		3	/* print [job-num] -/+ pid command */
#define JP_PGRP		4	/* print pgrp */

/* put_job() flags */
#define PJ_ON_FRONT	0	/* at very front */
#define PJ_PAST_STOPPED	1	/* just past any stopped jobs */

/* Job.flags values */
#define JF_STARTED	0x001	/* set when all processes in job are started */
#define JF_WAITING	0x002	/* set if j_waitj() is waiting on job */
#define JF_W_ASYNCNOTIFY 0x004	/* set if waiting and async notification ok */
#define JF_XXCOM	0x008	/* set for $(command) jobs */
#define JF_FG		0x010	/* running in foreground (also has tty pgrp) */
#define JF_SAVEDTTY	0x020	/* j->ttystat is valid */
#define JF_CHANGED	0x040	/* process has changed state */
#define JF_KNOWN	0x080	/* $! referenced */
#define JF_ZOMBIE	0x100	/* known, unwaited process */
#define JF_REMOVE	0x200	/* flagged for removal (j_jobs()/j_noityf()) */
#define JF_USETTYMODE	0x400	/* tty mode saved if process exits normally */
#define JF_SAVEDTTYPGRP	0x800	/* j->saved_ttypgrp is valid */

typedef struct job Job;
struct job {
	ALLOC_ITEM alloc_INT;	/* internal, do not touch */
	Job *next;		/* next job in list */
	Proc *proc_list;	/* process list */
	Proc *last_proc;	/* last process in list */
	struct timeval systime;	/* system time used by job */
	struct timeval usrtime;	/* user time used by job */
	pid_t pgrp;		/* process group of job */
	pid_t ppid;		/* pid of process that forked job */
	int job;		/* job number: %n */
	int flags;		/* see JF_* */
	volatile int state;	/* job state */
	int status;		/* exit status of last process */
	int age;		/* number of jobs started */
	Coproc_id coproc_id;	/* 0 or id of coprocess output pipe */
#ifndef MKSH_UNEMPLOYED
	mksh_ttyst ttystat;	/* saved tty state for stopped jobs */
	pid_t saved_ttypgrp;	/* saved tty process group for stopped jobs */
#endif
};

/* Flags for j_waitj() */
#define JW_NONE		0x00
#define JW_INTERRUPT	0x01	/* ^C will stop the wait */
#define JW_ASYNCNOTIFY	0x02	/* asynchronous notification during wait ok */
#define JW_STOPPEDWAIT	0x04	/* wait even if job stopped */
#define JW_PIPEST	0x08	/* want PIPESTATUS */

/* Error codes for j_lookup() */
#define JL_NOSUCH	0	/* no such job */
#define JL_AMBIG	1	/* %foo or %?foo is ambiguous */
#define JL_INVALID	2	/* non-pid, non-% job id */

static const char * const lookup_msgs[] = {
	"no such job",
	"ambiguous",
	"argument must be %job or process id"
};

static Job *job_list;		/* job list */
static Job *last_job;
static Job *async_job;
static pid_t async_pid;

static int nzombie;		/* # of zombies owned by this process */
static int njobs;		/* # of jobs started */

#ifndef CHILD_MAX
#define CHILD_MAX	25
#endif

#ifndef MKSH_NOPROSPECTOFWORK
/* held_sigchld is set if sigchld occurs before a job is completely started */
static volatile sig_atomic_t held_sigchld;
#endif

#ifndef MKSH_UNEMPLOYED
static struct shf	*shl_j;
static bool		ttypgrp_ok;	/* set if can use tty pgrps */
static pid_t		restore_ttypgrp = -1;
static int const	tt_sigs[] = { SIGTSTP, SIGTTIN, SIGTTOU };
#endif

static void		j_set_async(Job *);
static void		j_startjob(Job *);
static int		j_waitj(Job *, int, const char *);
static void		j_sigchld(int);
static void		j_print(Job *, int, struct shf *);
static Job		*j_lookup(const char *, int *);
static Job		*new_job(void);
static Proc		*new_proc(void);
static void		check_job(Job *);
static void		put_job(Job *, int);
static void		remove_job(Job *, const char *);
static int		kill_job(Job *, int);

static void tty_init_talking(void);
static void tty_init_state(void);

/* initialise job control */
void
j_init(void)
{
#ifndef MKSH_NOPROSPECTOFWORK
	(void)sigemptyset(&sm_default);
	sigprocmask(SIG_SETMASK, &sm_default, NULL);

	(void)sigemptyset(&sm_sigchld);
	(void)sigaddset(&sm_sigchld, SIGCHLD);

	setsig(&sigtraps[SIGCHLD], j_sigchld,
	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
#else
	/* Make sure SIGCHLD isn't ignored - can do odd things under SYSV */
	setsig(&sigtraps[SIGCHLD], SIG_DFL, SS_RESTORE_ORIG|SS_FORCE);
#endif

#ifndef MKSH_UNEMPLOYED
	if (Flag(FMONITOR) == 127)
		Flag(FMONITOR) = Flag(FTALKING);

	/*
	 * shl_j is used to do asynchronous notification (used in
	 * an interrupt handler, so need a distinct shf)
	 */
	shl_j = shf_fdopen(2, SHF_WR, NULL);

	if (Flag(FMONITOR) || Flag(FTALKING)) {
		int i;

		/*
		 * the TF_SHELL_USES test is a kludge that lets us know if
		 * if the signals have been changed by the shell.
		 */
		for (i = NELEM(tt_sigs); --i >= 0; ) {
			sigtraps[tt_sigs[i]].flags |= TF_SHELL_USES;
			/* j_change() sets this to SS_RESTORE_DFL if FMONITOR */
			setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
		}
	}

	/* j_change() calls tty_init_talking() and tty_init_state() */
	if (Flag(FMONITOR))
		j_change();
	else
#endif
	  if (Flag(FTALKING)) {
		tty_init_talking();
		tty_init_state();
	}
}

static int
proc_errorlevel(Proc *p)
{
	switch (p->state) {
	case PEXITED:
		return ((WEXITSTATUS(p->status)) & 255);
	case PSIGNALLED:
		return (ksh_sigmask(WTERMSIG(p->status)));
	default:
		return (0);
	}
}

#if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
/* suspend the shell */
void
j_suspend(void)
{
	struct sigaction sa, osa;

	/* Restore tty and pgrp. */
	if (ttypgrp_ok) {
		if (tty_hasstate)
			mksh_tcset(tty_fd, &tty_state);
		if (restore_ttypgrp >= 0) {
			if (tcsetpgrp(tty_fd, restore_ttypgrp) < 0) {
				warningf(false, Tf_ssfaileds,
				    Tj_suspend, "tcsetpgrp", cstrerror(errno));
			} else if (setpgid(0, restore_ttypgrp) < 0) {
				warningf(false, Tf_ssfaileds,
				    Tj_suspend, "setpgid", cstrerror(errno));
			}
		}
	}

	/* Suspend the shell. */
	memset(&sa, 0, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_DFL;
	sigaction(SIGTSTP, &sa, &osa);
	kill(0, SIGTSTP);

	/* Back from suspend, reset signals, pgrp and tty. */
	sigaction(SIGTSTP, &osa, NULL);
	if (ttypgrp_ok) {
		if (restore_ttypgrp >= 0) {
			if (setpgid(0, kshpid) < 0) {
				warningf(false, Tf_ssfaileds,
				    Tj_suspend, "setpgid", cstrerror(errno));
				ttypgrp_ok = false;
			} else if (tcsetpgrp(tty_fd, kshpid) < 0) {
				warningf(false, Tf_ssfaileds,
				    Tj_suspend, "tcsetpgrp", cstrerror(errno));
				ttypgrp_ok = false;
			}
		}
		tty_init_state();
	}
}
#endif

/* job cleanup before shell exit */
void
j_exit(void)
{
	/* kill stopped, and possibly running, jobs */
	Job *j;
	bool killed = false;

	for (j = job_list; j != NULL; j = j->next) {
		if (j->ppid == procpid &&
		    (j->state == PSTOPPED ||
		    (j->state == PRUNNING &&
		    ((j->flags & JF_FG) ||
		    (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid))))) {
			killed = true;
			if (j->pgrp == 0)
				kill_job(j, SIGHUP);
			else
				mksh_killpg(j->pgrp, SIGHUP);
#ifndef MKSH_UNEMPLOYED
			if (j->state == PSTOPPED) {
				if (j->pgrp == 0)
					kill_job(j, SIGCONT);
				else
					mksh_killpg(j->pgrp, SIGCONT);
			}
#endif
		}
	}
	if (killed)
		sleep(1);
	j_notify();

#ifndef MKSH_UNEMPLOYED
	if (kshpid == procpid && restore_ttypgrp >= 0) {
		/*
		 * Need to restore the tty pgrp to what it was when the
		 * shell started up, so that the process that started us
		 * will be able to access the tty when we are done.
		 * Also need to restore our process group in case we are
		 * about to do an exec so that both our parent and the
		 * process we are to become will be able to access the tty.
		 */
		tcsetpgrp(tty_fd, restore_ttypgrp);
		setpgid(0, restore_ttypgrp);
	}
	if (Flag(FMONITOR)) {
		Flag(FMONITOR) = 0;
		j_change();
	}
#endif
}

#ifndef MKSH_UNEMPLOYED
/* turn job control on or off according to Flag(FMONITOR) */
void
j_change(void)
{
	int i;

	if (Flag(FMONITOR)) {
		bool use_tty = Flag(FTALKING);

		/* don't call mksh_tcget until we own the tty process group */
		if (use_tty)
			tty_init_talking();

		/* no controlling tty, no SIGT* */
		if ((ttypgrp_ok = (use_tty && tty_fd >= 0 && tty_devtty))) {
			setsig(&sigtraps[SIGTTIN], SIG_DFL,
			    SS_RESTORE_ORIG|SS_FORCE);
			/* wait to be given tty (POSIX.1, B.2, job control) */
			while (/* CONSTCOND */ 1) {
				pid_t ttypgrp;

				if ((ttypgrp = tcgetpgrp(tty_fd)) < 0) {
					warningf(false, Tf_ssfaileds,
					    "j_init", "tcgetpgrp",
					    cstrerror(errno));
					ttypgrp_ok = false;
					break;
				}
				if (ttypgrp == kshpgrp)
					break;
				kill(0, SIGTTIN);
			}
		}
		for (i = NELEM(tt_sigs); --i >= 0; )
			setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
			    SS_RESTORE_DFL|SS_FORCE);
		if (ttypgrp_ok && kshpgrp != kshpid) {
			if (setpgid(0, kshpid) < 0) {
				warningf(false, Tf_ssfaileds,
				    "j_init", "setpgid", cstrerror(errno));
				ttypgrp_ok = false;
			} else {
				if (tcsetpgrp(tty_fd, kshpid) < 0) {
					warningf(false, Tf_ssfaileds,
					    "j_init", "tcsetpgrp",
					    cstrerror(errno));
					ttypgrp_ok = false;
				} else
					restore_ttypgrp = kshpgrp;
				kshpgrp = kshpid;
			}
		}
#ifndef MKSH_DISABLE_TTY_WARNING
		if (use_tty && !ttypgrp_ok)
			warningf(false, Tf_sD_s, "warning",
			    "won't have full job control");
#endif
	} else {
		ttypgrp_ok = false;
		if (Flag(FTALKING))
			for (i = NELEM(tt_sigs); --i >= 0; )
				setsig(&sigtraps[tt_sigs[i]], SIG_IGN,
				    SS_RESTORE_IGN|SS_FORCE);
		else
			for (i = NELEM(tt_sigs); --i >= 0; ) {
				if (sigtraps[tt_sigs[i]].flags &
				    (TF_ORIG_IGN | TF_ORIG_DFL))
					setsig(&sigtraps[tt_sigs[i]],
					    (sigtraps[tt_sigs[i]].flags & TF_ORIG_IGN) ?
					    SIG_IGN : SIG_DFL,
					    SS_RESTORE_ORIG|SS_FORCE);
			}
	}
	tty_init_state();
}
#endif

#if HAVE_NICE
/* run nice(3) and ignore the result */
static void
ksh_nice(int ness)
{
#if defined(__USE_FORTIFY_LEVEL) && (__USE_FORTIFY_LEVEL > 0)
	int eno;

	errno = 0;
	/* this is gonna annoy users; complain to your distro, people! */
	if (nice(ness) == -1 && (eno = errno) != 0)
		warningf(false, Tf_sD_s, "bgnice", cstrerror(eno));
#else
	(void)nice(ness);
#endif
}
#endif

/* execute tree in child subprocess */
int
exchild(struct op *t, int flags,
    volatile int *xerrok,
    /* used if XPCLOSE or XCCLOSE */
    int close_fd)
{
	/* for pipelines */
	static Proc *last_proc;

	int rv = 0, forksleep, jwflags = JW_NONE;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;
#endif
	Proc *p;
	Job *j;
	pid_t cldpid;

	if (flags & XPIPEST) {
		flags &= ~XPIPEST;
		jwflags |= JW_PIPEST;
	}

	if (flags & XEXEC)
		/*
		 * Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
		 * (also done in another execute() below)
		 */
		return (execute(t, flags & (XEXEC | XERROK), xerrok));

#ifndef MKSH_NOPROSPECTOFWORK
	/* no SIGCHLDs while messing with job and process lists */
	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	p = new_proc();
	p->next = NULL;
	p->state = PRUNNING;
	p->status = 0;
	p->pid = 0;

	/* link process into jobs list */
	if (flags & XPIPEI) {
		/* continuing with a pipe */
		if (!last_job)
			internal_errorf("exchild: XPIPEI and no last_job - pid %d",
			    (int)procpid);
		j = last_job;
		if (last_proc)
			last_proc->next = p;
		last_proc = p;
	} else {
		/* fills in j->job */
		j = new_job();
		/*
		 * we don't consider XXCOMs foreground since they don't get
		 * tty process group and we don't save or restore tty modes.
		 */
		j->flags = (flags & XXCOM) ? JF_XXCOM :
		    ((flags & XBGND) ? 0 : (JF_FG|JF_USETTYMODE));
		timerclear(&j->usrtime);
		timerclear(&j->systime);
		j->state = PRUNNING;
		j->pgrp = 0;
		j->ppid = procpid;
		j->age = ++njobs;
		j->proc_list = p;
		j->coproc_id = 0;
		last_job = j;
		last_proc = p;
		put_job(j, PJ_PAST_STOPPED);
	}

	vistree(p->command, sizeof(p->command), t);

	/* create child process */
	forksleep = 1;
	while ((cldpid = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
		if (intrsig)
			/* allow user to ^C out... */
			break;
		sleep(forksleep);
		forksleep <<= 1;
	}
	/* ensure $RANDOM changes between parent and child */
	rndset((unsigned long)cldpid);
	/* fork failed? */
	if (cldpid < 0) {
		kill_job(j, SIGKILL);
		remove_job(j, "fork failed");
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
		errorf("can't fork - try again");
	}
	p->pid = cldpid ? cldpid : (procpid = getpid());

#ifndef MKSH_UNEMPLOYED
	/* job control set up */
	if (Flag(FMONITOR) && !(flags&XXCOM)) {
		bool dotty = false;

		if (j->pgrp == 0) {
			/* First process */
			j->pgrp = p->pid;
			dotty = true;
		}

		/*
		 * set pgrp in both parent and child to deal with race
		 * condition
		 */
		setpgid(p->pid, j->pgrp);
		if (ttypgrp_ok && dotty && !(flags & XBGND))
			tcsetpgrp(tty_fd, j->pgrp);
	}
#endif

	/* used to close pipe input fd */
	if (close_fd >= 0 && (((flags & XPCLOSE) && cldpid) ||
	    ((flags & XCCLOSE) && !cldpid)))
		close(close_fd);
	if (!cldpid) {
		/* child */

		/* Do this before restoring signal */
		if (flags & XCOPROC)
			coproc_cleanup(false);
		cleanup_parents_env();
#ifndef MKSH_UNEMPLOYED
		/*
		 * If FMONITOR or FTALKING is set, these signals are ignored,
		 * if neither FMONITOR nor FTALKING are set, the signals have
		 * their inherited values.
		 */
		if (Flag(FMONITOR) && !(flags & XXCOM)) {
			for (forksleep = NELEM(tt_sigs); --forksleep >= 0; )
				setsig(&sigtraps[tt_sigs[forksleep]], SIG_DFL,
				    SS_RESTORE_DFL|SS_FORCE);
		}
#endif
#if HAVE_NICE
		if (Flag(FBGNICE) && (flags & XBGND))
			ksh_nice(4);
#endif
		if ((flags & XBGND)
#ifndef MKSH_UNEMPLOYED
		    && !Flag(FMONITOR)
#endif
		    ) {
			setsig(&sigtraps[SIGINT], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
			setsig(&sigtraps[SIGQUIT], SIG_IGN,
			    SS_RESTORE_IGN|SS_FORCE);
			if ((!(flags & (XPIPEI | XCOPROC))) &&
			    ((forksleep = open("/dev/null", 0)) > 0)) {
				(void)ksh_dup2(forksleep, 0, true);
				close(forksleep);
			}
		}
		/* in case of $(jobs) command */
		remove_job(j, "child");
#ifndef MKSH_NOPROSPECTOFWORK
		/* remove_job needs SIGCHLD blocked still */
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
		nzombie = 0;
#ifndef MKSH_UNEMPLOYED
		ttypgrp_ok = false;
		Flag(FMONITOR) = 0;
#endif
		Flag(FTALKING) = 0;
		cleartraps();
		/* no return */
		execute(t, (flags & XERROK) | XEXEC, NULL);
#ifndef MKSH_SMALL
		if (t->type == TPIPE)
			unwind(LLEAVE);
		internal_warningf("%s: execute() returned", "exchild");
		fptreef(shl_out, 8, "%s: tried to execute {\n\t%T\n}\n",
		    "exchild", t);
		shf_flush(shl_out);
#endif
		unwind(LLEAVE);
		/* NOTREACHED */
	}

	/* shell (parent) stuff */
	if (!(flags & XPIPEO)) {
		/* last process in a job */
		j_startjob(j);
		if (flags & XCOPROC) {
			j->coproc_id = coproc.id;
			/* n jobs using co-process output */
			coproc.njobs++;
			/* j using co-process input */
			coproc.job = (void *)j;
		}
		if (flags & XBGND) {
			j_set_async(j);
			if (Flag(FTALKING)) {
				shf_fprintf(shl_out, "[%d]", j->job);
				for (p = j->proc_list; p; p = p->next)
					shf_fprintf(shl_out, Tf__d,
					    (int)p->pid);
				shf_putchar('\n', shl_out);
				shf_flush(shl_out);
			}
		} else
			rv = j_waitj(j, jwflags, "jw:last proc");
	}

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif

	return (rv);
}

/* start the last job: only used for $(command) jobs */
void
startlast(void)
{
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	/* no need to report error - waitlast() will do it */
	if (last_job) {
		/* ensure it isn't removed by check_job() */
		last_job->flags |= JF_WAITING;
		j_startjob(last_job);
	}
#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
}

/* wait for last job: only used for $(command) jobs */
int
waitlast(void)
{
	int rv;
	Job *j;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	j = last_job;
	if (!j || !(j->flags & JF_STARTED)) {
		if (!j)
			warningf(true, Tf_sD_s, "waitlast", "no last job");
		else
			internal_warningf(Tf_sD_s, "waitlast", Tnot_started);
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
		/* not so arbitrary, non-zero value */
		return (125);
	}

	rv = j_waitj(j, JW_NONE, "waitlast");

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif

	return (rv);
}

/* wait for child, interruptable. */
int
waitfor(const char *cp, int *sigp)
{
	int rv, ecode, flags = JW_INTERRUPT|JW_ASYNCNOTIFY;
	Job *j;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	*sigp = 0;

	if (cp == NULL) {
		/*
		 * wait for an unspecified job - always returns 0, so
		 * don't have to worry about exited/signaled jobs
		 */
		for (j = job_list; j; j = j->next)
			/* AT&T ksh will wait for stopped jobs - we don't */
			if (j->ppid == procpid && j->state == PRUNNING)
				break;
		if (!j) {
#ifndef MKSH_NOPROSPECTOFWORK
			sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
			return (-1);
		}
	} else if ((j = j_lookup(cp, &ecode))) {
		/* don't report normal job completion */
		flags &= ~JW_ASYNCNOTIFY;
		if (j->ppid != procpid) {
#ifndef MKSH_NOPROSPECTOFWORK
			sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
			return (-1);
		}
	} else {
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
		if (ecode != JL_NOSUCH)
			bi_errorf(Tf_sD_s, cp, lookup_msgs[ecode]);
		return (-1);
	}

	/* AT&T ksh will wait for stopped jobs - we don't */
	rv = j_waitj(j, flags, "jw:waitfor");

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif

	if (rv < 0)
		/* we were interrupted */
		*sigp = ksh_sigmask(-rv);

	return (rv);
}

/* kill (built-in) a job */
int
j_kill(const char *cp, int sig)
{
	Job *j;
	int rv = 0, ecode;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	if ((j = j_lookup(cp, &ecode)) == NULL) {
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
		bi_errorf(Tf_sD_s, cp, lookup_msgs[ecode]);
		return (1);
	}

	if (j->pgrp == 0) {
		/* started when !Flag(FMONITOR) */
		if (kill_job(j, sig) < 0) {
			bi_errorf(Tf_sD_s, cp, cstrerror(errno));
			rv = 1;
		}
	} else {
#ifndef MKSH_UNEMPLOYED
		if (j->state == PSTOPPED && (sig == SIGTERM || sig == SIGHUP))
			mksh_killpg(j->pgrp, SIGCONT);
#endif
		if (mksh_killpg(j->pgrp, sig) < 0) {
			bi_errorf(Tf_sD_s, cp, cstrerror(errno));
			rv = 1;
		}
	}

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif

	return (rv);
}

#ifndef MKSH_UNEMPLOYED
/* fg and bg built-ins: called only if Flag(FMONITOR) set */
int
j_resume(const char *cp, int bg)
{
	Job *j;
	Proc *p;
	int ecode, rv = 0;
	bool running;
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);

	if ((j = j_lookup(cp, &ecode)) == NULL) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf(Tf_sD_s, cp, lookup_msgs[ecode]);
		return (1);
	}

	if (j->pgrp == 0) {
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf("job not job-controlled");
		return (1);
	}

	if (bg)
		shprintf("[%d] ", j->job);

	running = false;
	for (p = j->proc_list; p != NULL; p = p->next) {
		if (p->state == PSTOPPED) {
			p->state = PRUNNING;
			p->status = 0;
			running = true;
		}
		shf_puts(p->command, shl_stdout);
		if (p->next)
			shf_puts("| ", shl_stdout);
	}
	shf_putc('\n', shl_stdout);
	shf_flush(shl_stdout);
	if (running)
		j->state = PRUNNING;

	put_job(j, PJ_PAST_STOPPED);
	if (bg)
		j_set_async(j);
	else {
		/* attach tty to job */
		if (j->state == PRUNNING) {
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
				mksh_tcset(tty_fd, &j->ttystat);
			/* See comment in j_waitj regarding saved_ttypgrp. */
			if (ttypgrp_ok &&
			    tcsetpgrp(tty_fd, (j->flags & JF_SAVEDTTYPGRP) ?
			    j->saved_ttypgrp : j->pgrp) < 0) {
				rv = errno;
				if (j->flags & JF_SAVEDTTY)
					mksh_tcset(tty_fd, &tty_state);
				sigprocmask(SIG_SETMASK, &omask, NULL);
				bi_errorf(Tf_ldfailed,
				    "fg: 1st", "tcsetpgrp", tty_fd,
				    (long)((j->flags & JF_SAVEDTTYPGRP) ?
				    j->saved_ttypgrp : j->pgrp),
				    cstrerror(rv));
				return (1);
			}
		}
		j->flags |= JF_FG;
		j->flags &= ~JF_KNOWN;
		if (j == async_job)
			async_job = NULL;
	}

	if (j->state == PRUNNING && mksh_killpg(j->pgrp, SIGCONT) < 0) {
		int eno = errno;

		if (!bg) {
			j->flags &= ~JF_FG;
			if (ttypgrp_ok && (j->flags & JF_SAVEDTTY))
				mksh_tcset(tty_fd, &tty_state);
			if (ttypgrp_ok && tcsetpgrp(tty_fd, kshpgrp) < 0)
				warningf(true, Tf_ldfailed,
				    "fg: 2nd", "tcsetpgrp", tty_fd,
				    (long)kshpgrp, cstrerror(errno));
		}
		sigprocmask(SIG_SETMASK, &omask, NULL);
		bi_errorf(Tf_s_sD_s, "can't continue job",
		    cp, cstrerror(eno));
		return (1);
	}
	if (!bg) {
		if (ttypgrp_ok) {
			j->flags &= ~(JF_SAVEDTTY | JF_SAVEDTTYPGRP);
		}
		rv = j_waitj(j, JW_NONE, "jw:resume");
	}
	sigprocmask(SIG_SETMASK, &omask, NULL);
	return (rv);
}
#endif

/* are there any running or stopped jobs ? */
int
j_stopped_running(void)
{
	Job *j;
	int which = 0;

	for (j = job_list; j != NULL; j = j->next) {
#ifndef MKSH_UNEMPLOYED
		if (j->ppid == procpid && j->state == PSTOPPED)
			which |= 1;
#endif
		if (Flag(FLOGIN) && !Flag(FNOHUP) && procpid == kshpid &&
		    j->ppid == procpid && j->state == PRUNNING)
			which |= 2;
	}
	if (which) {
		shellf("You have %s%s%s jobs\n",
		    which & 1 ? "stopped" : "",
		    which == 3 ? " and " : "",
		    which & 2 ? "running" : "");
		return (1);
	}

	return (0);
}


/* list jobs for jobs built-in */
int
j_jobs(const char *cp, int slp,
    /* 0: short, 1: long, 2: pgrp */
    int nflag)
{
	Job *j, *tmp;
	int how, zflag = 0;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	if (nflag < 0) {
		/* kludge: print zombies */
		nflag = 0;
		zflag = 1;
	}
	if (cp) {
		int ecode;

		if ((j = j_lookup(cp, &ecode)) == NULL) {
#ifndef MKSH_NOPROSPECTOFWORK
			sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
			bi_errorf(Tf_sD_s, cp, lookup_msgs[ecode]);
			return (1);
		}
	} else
		j = job_list;
	how = slp == 0 ? JP_MEDIUM : (slp == 1 ? JP_LONG : JP_PGRP);
	for (; j; j = j->next) {
		if ((!(j->flags & JF_ZOMBIE) || zflag) &&
		    (!nflag || (j->flags & JF_CHANGED))) {
			j_print(j, how, shl_stdout);
			if (j->state == PEXITED || j->state == PSIGNALLED)
				j->flags |= JF_REMOVE;
		}
		if (cp)
			break;
	}
	/* Remove jobs after printing so there won't be multiple + or - jobs */
	for (j = job_list; j; j = tmp) {
		tmp = j->next;
		if (j->flags & JF_REMOVE)
			remove_job(j, Tjobs);
	}
#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
	return (0);
}

/* list jobs for top-level notification */
void
j_notify(void)
{
	Job *j, *tmp;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif
	for (j = job_list; j; j = j->next) {
#ifndef MKSH_UNEMPLOYED
		if (Flag(FMONITOR) && (j->flags & JF_CHANGED))
			j_print(j, JP_MEDIUM, shl_out);
#endif
		/*
		 * Remove job after doing reports so there aren't
		 * multiple +/- jobs.
		 */
		if (j->state == PEXITED || j->state == PSIGNALLED)
			j->flags |= JF_REMOVE;
	}
	for (j = job_list; j; j = tmp) {
		tmp = j->next;
		if (j->flags & JF_REMOVE) {
			if (j == async_job || (j->flags & JF_KNOWN)) {
				j->flags = (j->flags & ~JF_REMOVE) | JF_ZOMBIE;
				j->job = -1;
				nzombie++;
			} else
				remove_job(j, "notify");
		}
	}
	shf_flush(shl_out);
#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
}

/* Return pid of last process in last asynchronous job */
pid_t
j_async(void)
{
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

	if (async_job)
		async_job->flags |= JF_KNOWN;

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif

	return (async_pid);
}

/*
 * Make j the last async process
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_set_async(Job *j)
{
	Job *jl, *oldest;

	if (async_job && (async_job->flags & (JF_KNOWN|JF_ZOMBIE)) == JF_ZOMBIE)
		remove_job(async_job, "async");
	if (!(j->flags & JF_STARTED)) {
		internal_warningf(Tf_sD_s, "j_async", Tjob_not_started);
		return;
	}
	async_job = j;
	async_pid = j->last_proc->pid;
	while (nzombie > CHILD_MAX) {
		oldest = NULL;
		for (jl = job_list; jl; jl = jl->next)
			if (jl != async_job && (jl->flags & JF_ZOMBIE) &&
			    (!oldest || jl->age < oldest->age))
				oldest = jl;
		if (!oldest) {
			/* XXX debugging */
			if (!(async_job->flags & JF_ZOMBIE) || nzombie != 1) {
				internal_warningf("%s: bad nzombie (%d)",
				    "j_async", nzombie);
				nzombie = 0;
			}
			break;
		}
		remove_job(oldest, "zombie");
	}
}

/*
 * Start a job: set STARTED, check for held signals and set j->last_proc
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_startjob(Job *j)
{
	Proc *p;

	j->flags |= JF_STARTED;
	for (p = j->proc_list; p->next; p = p->next)
		;
	j->last_proc = p;

#ifndef MKSH_NOPROSPECTOFWORK
	if (held_sigchld) {
		held_sigchld = 0;
		/* Don't call j_sigchld() as it may remove job... */
		kill(procpid, SIGCHLD);
	}
#endif
}

/*
 * wait for job to complete or change state
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static int
j_waitj(Job *j,
    /* see JW_* */
    int flags,
    const char *where)
{
	Proc *p;
	int rv;
#ifdef MKSH_NO_SIGSUSPEND
	sigset_t omask;
#endif

	/*
	 * No auto-notify on the job we are waiting on.
	 */
	j->flags |= JF_WAITING;
	if (flags & JW_ASYNCNOTIFY)
		j->flags |= JF_W_ASYNCNOTIFY;

#ifndef MKSH_UNEMPLOYED
	if (!Flag(FMONITOR))
#endif
		flags |= JW_STOPPEDWAIT;

	while (j->state == PRUNNING ||
	    ((flags & JW_STOPPEDWAIT) && j->state == PSTOPPED)) {
#ifndef MKSH_NOPROSPECTOFWORK
#ifdef MKSH_NO_SIGSUSPEND
		sigprocmask(SIG_SETMASK, &sm_default, &omask);
		pause();
		/* note that handlers may run here so they need to know */
		sigprocmask(SIG_SETMASK, &omask, NULL);
#else
		sigsuspend(&sm_default);
#endif
#else
		j_sigchld(SIGCHLD);
#endif
		if (fatal_trap) {
			int oldf = j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY);
			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
			runtraps(TF_FATAL);
			/* not reached... */
			j->flags |= oldf;
		}
		if ((flags & JW_INTERRUPT) && (rv = trap_pending())) {
			j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);
			return (-rv);
		}
	}
	j->flags &= ~(JF_WAITING|JF_W_ASYNCNOTIFY);

	if (j->flags & JF_FG) {
		j->flags &= ~JF_FG;
#ifndef MKSH_UNEMPLOYED
		if (Flag(FMONITOR) && ttypgrp_ok && j->pgrp) {
			/*
			 * Save the tty's current pgrp so it can be restored
			 * when the job is foregrounded. This is to
			 * deal with things like the GNU su which does
			 * a fork/exec instead of an exec (the fork means
			 * the execed shell gets a different pid from its
			 * pgrp, so naturally it sets its pgrp and gets hosed
			 * when it gets foregrounded by the parent shell which
			 * has restored the tty's pgrp to that of the su
			 * process).
			 */
			if (j->state == PSTOPPED &&
			    (j->saved_ttypgrp = tcgetpgrp(tty_fd)) >= 0)
				j->flags |= JF_SAVEDTTYPGRP;
			if (tcsetpgrp(tty_fd, kshpgrp) < 0)
				warningf(true, Tf_ldfailed,
				    "j_waitj:", "tcsetpgrp", tty_fd,
				    (long)kshpgrp, cstrerror(errno));
			if (j->state == PSTOPPED) {
				j->flags |= JF_SAVEDTTY;
				mksh_tcget(tty_fd, &j->ttystat);
			}
		}
#endif
		if (tty_hasstate) {
			/*
			 * Only restore tty settings if job was originally
			 * started in the foreground. Problems can be
			 * caused by things like 'more foobar &' which will
			 * typically get and save the shell's vi/emacs tty
			 * settings before setting up the tty for itself;
			 * when more exits, it restores the 'original'
			 * settings, and things go down hill from there...
			 */
			if (j->state == PEXITED && j->status == 0 &&
			    (j->flags & JF_USETTYMODE)) {
				mksh_tcget(tty_fd, &tty_state);
			} else {
				mksh_tcset(tty_fd, &tty_state);
				/*-
				 * Don't use tty mode if job is stopped and
				 * later restarted and exits. Consider
				 * the sequence:
				 *	vi foo (stopped)
				 *	...
				 *	stty something
				 *	...
				 *	fg (vi; ZZ)
				 * mode should be that of the stty, not what
				 * was before the vi started.
				 */
				if (j->state == PSTOPPED)
					j->flags &= ~JF_USETTYMODE;
			}
		}
#ifndef MKSH_UNEMPLOYED
		/*
		 * If it looks like user hit ^C to kill a job, pretend we got
		 * one too to break out of for loops, etc. (AT&T ksh does this
		 * even when not monitoring, but this doesn't make sense since
		 * a tty generated ^C goes to the whole process group)
		 */
		if (Flag(FMONITOR) && j->state == PSIGNALLED &&
		    WIFSIGNALED(j->last_proc->status)) {
			int termsig;

			if ((termsig = WTERMSIG(j->last_proc->status)) > 0 &&
			    termsig < ksh_NSIG &&
			    (sigtraps[termsig].flags & TF_TTY_INTR))
				trapsig(termsig);
		}
#endif
	}

	j_usrtime = j->usrtime;
	j_systime = j->systime;
	rv = j->status;

	if (!(p = j->proc_list)) {
		;	/* nothing */
	} else if (flags & JW_PIPEST) {
		uint32_t num = 0;
		struct tbl *vp;

		unset(vp_pipest, 1);
		vp = vp_pipest;
		vp->flag = DEFINED | ISSET | INTEGER | RDONLY | ARRAY | INT_U;
		goto got_array;

		while (p != NULL) {
			{
				struct tbl *vq;

				/* strlen(vp_pipest->name) == 10 */
				vq = alloc(offsetof(struct tbl, name[0]) + 11,
				    vp_pipest->areap);
				memset(vq, 0, offsetof(struct tbl, name[0]));
				memcpy(vq->name, vp_pipest->name, 11);
				vp->u.array = vq;
				vp = vq;
			}
			vp->areap = vp_pipest->areap;
			vp->ua.index = ++num;
			vp->flag = DEFINED | ISSET | INTEGER | RDONLY |
			    ARRAY | INT_U | AINDEX;
 got_array:
			vp->val.i = proc_errorlevel(p);
			if (Flag(FPIPEFAIL) && vp->val.i)
				rv = vp->val.i;
			p = p->next;
		}
	} else if (Flag(FPIPEFAIL)) {
		do {
			const int i = proc_errorlevel(p);

			if (i)
				rv = i;
		} while ((p = p->next));
	}

	if (!(flags & JW_ASYNCNOTIFY)
#ifndef MKSH_UNEMPLOYED
	    && (!Flag(FMONITOR) || j->state != PSTOPPED)
#endif
	    ) {
		j_print(j, JP_SHORT, shl_out);
		shf_flush(shl_out);
	}
	if (j->state != PSTOPPED
#ifndef MKSH_UNEMPLOYED
	    && (!Flag(FMONITOR) || !(flags & JW_ASYNCNOTIFY))
#endif
	    )
		remove_job(j, where);

	return (rv);
}

/*
 * SIGCHLD handler to reap children and update job states
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
/* ARGSUSED */
static void
j_sigchld(int sig MKSH_A_UNUSED)
{
	int saved_errno = errno;
	Job *j;
	Proc *p = NULL;
	pid_t pid;
	int status;
	struct rusage ru0, ru1;
#ifdef MKSH_NO_SIGSUSPEND
	sigset_t omask;

	/* this handler can run while SIGCHLD is not blocked, so block it now */
	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif

#ifndef MKSH_NOPROSPECTOFWORK
	/*
	 * Don't wait for any processes if a job is partially started.
	 * This is so we don't do away with the process group leader
	 * before all the processes in a pipe line are started (so the
	 * setpgid() won't fail)
	 */
	for (j = job_list; j; j = j->next)
		if (j->ppid == procpid && !(j->flags & JF_STARTED)) {
			held_sigchld = 1;
			goto j_sigchld_out;
		}
#endif

	getrusage(RUSAGE_CHILDREN, &ru0);
	do {
#ifndef MKSH_NOPROSPECTOFWORK
		pid = waitpid(-1, &status, (WNOHANG |
#if defined(WCONTINUED) && defined(WIFCONTINUED)
		    WCONTINUED |
#endif
		    WUNTRACED));
#else
		pid = wait(&status);
#endif

		/*
		 * return if this would block (0) or no children
		 * or interrupted (-1)
		 */
		if (pid <= 0)
			goto j_sigchld_out;

		getrusage(RUSAGE_CHILDREN, &ru1);

		/* find job and process structures for this pid */
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
				if (p->pid == pid)
					goto found;
 found:
		if (j == NULL) {
			/* Can occur if process has kids, then execs shell
			warningf(true, "bad process waited for (pid = %d)",
				pid);
			 */
			ru0 = ru1;
			continue;
		}

		timeradd(&j->usrtime, &ru1.ru_utime, &j->usrtime);
		timersub(&j->usrtime, &ru0.ru_utime, &j->usrtime);
		timeradd(&j->systime, &ru1.ru_stime, &j->systime);
		timersub(&j->systime, &ru0.ru_stime, &j->systime);
		ru0 = ru1;
		p->status = status;
#ifndef MKSH_UNEMPLOYED
		if (WIFSTOPPED(status))
			p->state = PSTOPPED;
		else
#if defined(WCONTINUED) && defined(WIFCONTINUED)
		  if (WIFCONTINUED(status)) {
			p->state = j->state = PRUNNING;
			/* skip check_job(), no-op in this case */
			continue;
		} else
#endif
#endif
		  if (WIFSIGNALED(status))
			p->state = PSIGNALLED;
		else
			p->state = PEXITED;

		/* check to see if entire job is done */
		check_job(j);
	}
#ifndef MKSH_NOPROSPECTOFWORK
	    while (/* CONSTCOND */ 1);
#else
	    while (/* CONSTCOND */ 0);
#endif

 j_sigchld_out:
#ifdef MKSH_NO_SIGSUSPEND
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
	errno = saved_errno;
}

/*
 * Called only when a process in j has exited/stopped (ie, called only
 * from j_sigchld()). If no processes are running, the job status
 * and state are updated, asynchronous job notification is done and,
 * if unneeded, the job is removed.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
check_job(Job *j)
{
	int jstate;
	Proc *p;

	/* XXX debugging (nasty - interrupt routine using shl_out) */
	if (!(j->flags & JF_STARTED)) {
		internal_warningf("check_job: job started (flags 0x%X)",
		    (unsigned int)j->flags);
		return;
	}

	jstate = PRUNNING;
	for (p=j->proc_list; p != NULL; p = p->next) {
		if (p->state == PRUNNING)
			/* some processes still running */
			return;
		if (p->state > jstate)
			jstate = p->state;
	}
	j->state = jstate;
	j->status = proc_errorlevel(j->last_proc);

	/*
	 * Note when co-process dies: can't be done in j_wait() nor
	 * remove_job() since neither may be called for non-interactive
	 * shells.
	 */
	if (j->state == PEXITED || j->state == PSIGNALLED) {
		/*
		 * No need to keep co-process input any more
		 * (at least, this is what ksh93d thinks)
		 */
		if (coproc.job == j) {
			coproc.job = NULL;
			/*
			 * XXX would be nice to get the closes out of here
			 * so they aren't done in the signal handler.
			 * Would mean a check in coproc_getfd() to
			 * do "if job == 0 && write >= 0, close write".
			 */
			coproc_write_close(coproc.write);
		}
		/* Do we need to keep the output? */
		if (j->coproc_id && j->coproc_id == coproc.id &&
		    --coproc.njobs == 0)
			coproc_readw_close(coproc.read);
	}

	j->flags |= JF_CHANGED;
#ifndef MKSH_UNEMPLOYED
	if (Flag(FMONITOR) && !(j->flags & JF_XXCOM)) {
		/*
		 * Only put stopped jobs at the front to avoid confusing
		 * the user (don't want finished jobs effecting %+ or %-)
		 */
		if (j->state == PSTOPPED)
			put_job(j, PJ_ON_FRONT);
		if (Flag(FNOTIFY) &&
		    (j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY)) != JF_WAITING) {
			/* Look for the real file descriptor 2 */
			{
				struct env *ep;
				int fd = 2;

				for (ep = e; ep; ep = ep->oenv)
					if (ep->savefd && ep->savefd[2])
						fd = ep->savefd[2];
				shf_reopen(fd, SHF_WR, shl_j);
			}
			/*
			 * Can't call j_notify() as it removes jobs. The job
			 * must stay in the job list as j_waitj() may be
			 * running with this job.
			 */
			j_print(j, JP_MEDIUM, shl_j);
			shf_flush(shl_j);
			if (!(j->flags & JF_WAITING) && j->state != PSTOPPED)
				remove_job(j, "notify");
		}
	}
#endif
	if (
#ifndef MKSH_UNEMPLOYED
	    !Flag(FMONITOR) &&
#endif
	    !(j->flags & (JF_WAITING|JF_FG)) &&
	    j->state != PSTOPPED) {
		if (j == async_job || (j->flags & JF_KNOWN)) {
			j->flags |= JF_ZOMBIE;
			j->job = -1;
			nzombie++;
		} else
			remove_job(j, "checkjob");
	}
}

/*
 * Print job status in either short, medium or long format.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
j_print(Job *j, int how, struct shf *shf)
{
	Proc *p;
	int state;
	int status;
#ifdef WCOREDUMP
	bool coredumped;
#endif
	char jobchar = ' ';
	char buf[64];
	const char *filler;
	int output = 0;

	if (how == JP_PGRP) {
		/*
		 * POSIX doesn't say what to do it there is no process
		 * group leader (ie, !FMONITOR). We arbitrarily return
		 * last pid (which is what $! returns).
		 */
		shf_fprintf(shf, Tf_dN, (int)(j->pgrp ? j->pgrp :
		    (j->last_proc ? j->last_proc->pid : 0)));
		return;
	}
	j->flags &= ~JF_CHANGED;
	filler = j->job > 10 ? "\n       " : "\n      ";
	if (j == job_list)
		jobchar = '+';
	else if (j == job_list->next)
		jobchar = '-';

	for (p = j->proc_list; p != NULL;) {
#ifdef WCOREDUMP
		coredumped = false;
#endif
		switch (p->state) {
		case PRUNNING:
			memcpy(buf, "Running", 8);
			break;
		case PSTOPPED: {
			int stopsig = WSTOPSIG(p->status);

			strlcpy(buf, stopsig > 0 && stopsig < ksh_NSIG ?
			    sigtraps[stopsig].mess : "Stopped", sizeof(buf));
			break;
		}
		case PEXITED: {
			int exitstatus = (WEXITSTATUS(p->status)) & 255;

			if (how == JP_SHORT)
				buf[0] = '\0';
			else if (exitstatus == 0)
				memcpy(buf, "Done", 5);
			else
				shf_snprintf(buf, sizeof(buf), "Done (%d)",
				    exitstatus);
			break;
		}
		case PSIGNALLED: {
			int termsig = WTERMSIG(p->status);
#ifdef WCOREDUMP
			if (WCOREDUMP(p->status))
				coredumped = true;
#endif
			/*
			 * kludge for not reporting 'normal termination
			 * signals' (i.e. SIGINT, SIGPIPE)
			 */
			if (how == JP_SHORT &&
#ifdef WCOREDUMP
			    !coredumped &&
#endif
			    (termsig == SIGINT || termsig == SIGPIPE)) {
				buf[0] = '\0';
			} else
				strlcpy(buf, termsig > 0 && termsig < ksh_NSIG ?
				    sigtraps[termsig].mess : "Signalled",
				    sizeof(buf));
			break;
		}
		default:
			buf[0] = '\0';
		}

		if (how != JP_SHORT) {
			if (p == j->proc_list)
				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
			else
				shf_puts(filler, shf);
		}

		if (how == JP_LONG)
			shf_fprintf(shf, "%5d ", (int)p->pid);

		if (how == JP_SHORT) {
			if (buf[0]) {
				output = 1;
#ifdef WCOREDUMP
				shf_fprintf(shf, "%s%s ",
				    buf, coredumped ? " (core dumped)" : null);
#else
				shf_puts(buf, shf);
				shf_putchar(' ', shf);
#endif
			}
		} else {
			output = 1;
			shf_fprintf(shf, "%-20s %s%s%s", buf, p->command,
			    p->next ? "|" : null,
#ifdef WCOREDUMP
			    coredumped ? " (core dumped)" :
#endif
			     null);
		}

		state = p->state;
		status = p->status;
		p = p->next;
		while (p && p->state == state && p->status == status) {
			if (how == JP_LONG)
				shf_fprintf(shf, "%s%5d %-20s %s%s", filler,
				    (int)p->pid, T1space, p->command,
				    p->next ? "|" : null);
			else if (how == JP_MEDIUM)
				shf_fprintf(shf, Tf__ss, p->command,
				    p->next ? "|" : null);
			p = p->next;
		}
	}
	if (output)
		shf_putc('\n', shf);
}

/*
 * Convert % sequence to job
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Job *
j_lookup(const char *cp, int *ecodep)
{
	Job *j, *last_match;
	Proc *p;
	size_t len;
	int job = 0;

	if (ctype(*cp, C_DIGIT) && getn(cp, &job)) {
		/* Look for last_proc->pid (what $! returns) first... */
		for (j = job_list; j != NULL; j = j->next)
			if (j->last_proc && j->last_proc->pid == job)
				return (j);
		/*
		 * ...then look for process group (this is non-POSIX,
		 * but should not break anything
		 */
		for (j = job_list; j != NULL; j = j->next)
			if (j->pgrp && j->pgrp == job)
				return (j);
		goto j_lookup_nosuch;
	}
	if (*cp != '%') {
 j_lookup_invalid:
		if (ecodep)
			*ecodep = JL_INVALID;
		return (NULL);
	}
	switch (*++cp) {
	case '\0': /* non-standard */
	case '+':
	case '%':
		if (job_list != NULL)
			return (job_list);
		break;

	case '-':
		if (job_list != NULL && job_list->next)
			return (job_list->next);
		break;

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		if (!getn(cp, &job))
			goto j_lookup_invalid;
		for (j = job_list; j != NULL; j = j->next)
			if (j->job == job)
				return (j);
		break;

	/* %?string */
	case '?':
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
			for (p = j->proc_list; p != NULL; p = p->next)
				if (strstr(p->command, cp+1) != NULL) {
					if (last_match) {
						if (ecodep)
							*ecodep = JL_AMBIG;
						return (NULL);
					}
					last_match = j;
				}
		if (last_match)
			return (last_match);
		break;

	/* %string */
	default:
		len = strlen(cp);
		last_match = NULL;
		for (j = job_list; j != NULL; j = j->next)
			if (strncmp(cp, j->proc_list->command, len) == 0) {
				if (last_match) {
					if (ecodep)
						*ecodep = JL_AMBIG;
					return (NULL);
				}
				last_match = j;
			}
		if (last_match)
			return (last_match);
		break;
	}
 j_lookup_nosuch:
	if (ecodep)
		*ecodep = JL_NOSUCH;
	return (NULL);
}

static Job	*free_jobs;
static Proc	*free_procs;

/*
 * allocate a new job and fill in the job number.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Job *
new_job(void)
{
	int i;
	Job *newj, *j;

	if (free_jobs != NULL) {
		newj = free_jobs;
		free_jobs = free_jobs->next;
	} else {
		char *cp;

		/*
		 * struct job includes ALLOC_ITEM for alignment constraints
		 * so first get the actually used memory, then assign it
		 */
		cp = alloc(sizeof(Job) - sizeof(ALLOC_ITEM), APERM);
		/* undo what alloc() did to the malloc result address */
		newj = (void *)(cp - sizeof(ALLOC_ITEM));
	}

	/* brute force method */
	i = 0;
	do {
		++i;
		j = job_list;
		while (j && j->job != i)
			j = j->next;
	} while (j);
	newj->job = i;

	return (newj);
}

/*
 * Allocate new process struct
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static Proc *
new_proc(void)
{
	Proc *p;

	if (free_procs != NULL) {
		p = free_procs;
		free_procs = free_procs->next;
	} else
		p = alloc(sizeof(Proc), APERM);

	return (p);
}

/*
 * Take job out of job_list and put old structures into free list.
 * Keeps nzombies, last_job and async_job up to date.
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
remove_job(Job *j, const char *where)
{
	Proc *p, *tmp;
	Job **prev, *curr;

	prev = &job_list;
	curr = job_list;
	while (curr && curr != j) {
		prev = &curr->next;
		curr = *prev;
	}
	if (curr != j) {
		internal_warningf("remove_job: job %s (%s)", Tnot_found, where);
		return;
	}
	*prev = curr->next;

	/* free up proc structures */
	for (p = j->proc_list; p != NULL; ) {
		tmp = p;
		p = p->next;
		tmp->next = free_procs;
		free_procs = tmp;
	}

	if ((j->flags & JF_ZOMBIE) && j->ppid == procpid)
		--nzombie;
	j->next = free_jobs;
	free_jobs = j;

	if (j == last_job)
		last_job = NULL;
	if (j == async_job)
		async_job = NULL;
}

/*
 * put j in a particular location (taking it out job_list if it is there
 * already)
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static void
put_job(Job *j, int where)
{
	Job **prev, *curr;

	/* Remove job from list (if there) */
	prev = &job_list;
	curr = job_list;
	while (curr && curr != j) {
		prev = &curr->next;
		curr = *prev;
	}
	if (curr == j)
		*prev = curr->next;

	switch (where) {
	case PJ_ON_FRONT:
		j->next = job_list;
		job_list = j;
		break;

	case PJ_PAST_STOPPED:
		prev = &job_list;
		curr = job_list;
		for (; curr && curr->state == PSTOPPED; prev = &curr->next,
		    curr = *prev)
			;
		j->next = curr;
		*prev = j;
		break;
	}
}

/*
 * nuke a job (called when unable to start full job).
 *
 * If jobs are compiled in then this routine expects sigchld to be blocked.
 */
static int
kill_job(Job *j, int sig)
{
	Proc *p;
	int rval = 0;

	for (p = j->proc_list; p != NULL; p = p->next)
		if (p->pid != 0)
			if (kill(p->pid, sig) < 0)
				rval = -1;
	return (rval);
}

static void
tty_init_talking(void)
{
	switch (tty_init_fd()) {
	case 0:
		break;
	case 1:
#ifndef MKSH_DISABLE_TTY_WARNING
		warningf(false, Tf_sD_s_sD_s,
		    "No controlling tty", Topen, T_devtty, cstrerror(errno));
#endif
		break;
	case 2:
#ifndef MKSH_DISABLE_TTY_WARNING
		warningf(false, Tf_s_sD_s, Tcant_find, Ttty_fd,
		    cstrerror(errno));
#endif
		break;
	case 3:
		warningf(false, Tf_ssfaileds, "j_ttyinit",
		    Ttty_fd_dupof, cstrerror(errno));
		break;
	case 4:
		warningf(false, Tf_sD_sD_s, "j_ttyinit",
		    "can't set close-on-exec flag", cstrerror(errno));
		break;
	}
}

static void
tty_init_state(void)
{
	if (tty_fd >= 0) {
		mksh_tcget(tty_fd, &tty_state);
		tty_hasstate = true;
	}
}
@


1.127
log
@fix an error message
@
text
@d5 1
a5 1
 *		 2012, 2013, 2014, 2015, 2016, 2018
d91 1
d1782 11
a1792 2
	} else
		newj = alloc(sizeof(Job), APERM);
d1795 7
a1801 6
	for (i = 1; ; i++) {
		for (j = job_list; j && j->job != i; j = j->next)
			;
		if (j == NULL)
			break;
	}
@


1.126
log
@fix using “-m” on the command line; spotted by G.raud <graud@@gmx.com> on ML
@
text
@d1929 1
a1929 1
		warningf(false, Tf_sD_s_s, Tcant_find, Ttty_fd,
@


1.125
log
@small cleanup for systems without core dumps, such as Jehanne
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.123 2017/08/08 14:29:23 tg Exp $");
a171 6
#ifndef MKSH_UNEMPLOYED
	bool mflagset = Flag(FMONITOR) != 127;

	Flag(FMONITOR) = 0;
#endif

d187 2
a188 2
	if (!mflagset && Flag(FTALKING))
		Flag(FMONITOR) = 1;
@


1.124
log
@fix Red Hat BZ#1479320 by making interactive shells remember async PIDs too
@
text
@d5 1
a5 1
 *		 2012, 2013, 2014, 2015, 2016
d1548 1
d1550 1
d1574 1
d1576 1
d1610 4
a1613 1
			if (how == JP_SHORT && !coredumped &&
d1639 1
d1642 4
d1651 4
a1654 1
			    coredumped ? " (core dumped)" : null);
@


1.123
log
@optimise structure size calculation to take alignment into account
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.117 2016/01/14 23:18:09 tg Exp $");
d1025 8
a1032 2
		if (j->flags & JF_REMOVE)
			remove_job(j, "notify");
@


1.122
log
@eliminate legacy macros
@
text
@d42 9
d52 5
a56 2
	Proc *next;		/* next process in pipeline (if any) */
	pid_t pid;		/* process id */
d58 2
a59 1
	int status;		/* wait status */
d61 2
a62 2
	char command[256 - (ALLOC_OVERHEAD + sizeof(Proc *) +
	    sizeof(pid_t) + 2 * sizeof(int))];
@


1.121
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d1654 1
a1654 1
	if (ksh_isdigit(*cp) && getn(cp, &job)) {
@


1.120
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d241 2
a242 2
				warningf(false, "%s: %s failed: %s",
				    "j_suspend", "tcsetpgrp", cstrerror(errno));
d244 2
a245 2
				warningf(false, "%s: %s failed: %s",
				    "j_suspend", "setpgid", cstrerror(errno));
d262 2
a263 2
				warningf(false, "%s: %s failed: %s",
				    "j_suspend", "setpgid", cstrerror(errno));
d266 2
a267 2
				warningf(false, "%s: %s failed: %s",
				    "j_suspend", "tcsetpgrp", cstrerror(errno));
d352 1
a352 1
					warningf(false, "%s: %s failed: %s",
d368 1
a368 1
				warningf(false, "%s: %s failed: %s",
d373 1
a373 1
					warningf(false, "%s: %s failed: %s",
d384 1
a384 1
			warningf(false, "%s: %s", "warning",
d418 1
a418 1
		warningf(false, "%s: %s", "bgnice", cstrerror(eno));
d628 1
a628 1
					shf_fprintf(shl_out, " %d",
d680 1
a680 1
			warningf(true, "%s: %s", "waitlast", "no last job");
d682 1
a682 1
			internal_warningf("%s: %s", "waitlast", "not started");
d742 1
a742 1
			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
d776 1
a776 1
		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
d783 1
a783 1
			bi_errorf("%s: %s", cp, cstrerror(errno));
d792 1
a792 1
			bi_errorf("%s: %s", cp, cstrerror(errno));
d819 1
a819 1
		bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
d864 1
a864 1
				bi_errorf("%s %s(%d, %ld) failed: %s",
d886 1
a886 1
				warningf(true, "%s %s(%d, %ld) failed: %s",
d891 1
a891 1
		bi_errorf("%s %s: %s", "can't continue job",
d960 1
a960 1
			bi_errorf("%s: %s", cp, lookup_msgs[ecode]);
d980 1
a980 1
			remove_job(j, "jobs");
d1054 1
a1054 1
		internal_warningf("%s: %s", "j_async", "job not started");
d1178 1
a1178 1
				warningf(true, "%s %s(%d, %ld) failed: %s",
d1541 1
a1541 1
		shf_fprintf(shf, "%d\n", (int)(j->pgrp ? j->pgrp :
d1629 1
a1629 1
				    (int)p->pid, " ", p->command,
d1632 1
a1632 1
				shf_fprintf(shf, " %s%s", p->command,
d1806 1
a1806 1
		internal_warningf("remove_job: job %s (%s)", "not found", where);
d1895 2
a1896 3
		warningf(false, "%s: %s %s: %s",
		    "No controlling tty", "open", "/dev/tty",
		    cstrerror(errno));
d1901 2
a1902 1
		warningf(false, "%s: %s", "can't find tty fd", cstrerror(errno));
d1906 2
a1907 2
		warningf(false, "%s: %s failed: %s", "j_ttyinit",
		    "dup of tty fd", cstrerror(errno));
d1910 1
a1910 1
		warningf(false, "%s: %s: %s", "j_ttyinit",
@


1.119
log
@implement mmap-using mechanism to catch buffer underruns inside mksh
(pulls stdio, is rather BSD-specific and memory-hungry and a bit slow)
@
text
@d1428 2
a1429 2
		internal_warningf("check_job: job started (flags 0x%x)",
		    j->flags);
@


1.118
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d48 2
a49 2
	char command[256 - (ALLOC_SIZE + sizeof(Proc *) + sizeof(pid_t) +
	    2 * sizeof(int))];
@


1.117
log
@incorporate more feedback from schily
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.106 2014/11/25 21:13:27 tg Exp $");
d241 2
a242 2
				warningf(false, "%s: %s %s: %s", "j_suspend",
				    "tcsetpgrp", "failed", cstrerror(errno));
d244 2
a245 2
				warningf(false, "%s: %s %s: %s", "j_suspend",
				    "setpgid", "failed", cstrerror(errno));
d262 2
a263 2
				warningf(false, "%s: %s %s: %s", "j_suspend",
				    "setpgid", "failed", cstrerror(errno));
d266 2
a267 2
				warningf(false, "%s: %s %s: %s", "j_suspend",
				    "tcsetpgrp", "failed", cstrerror(errno));
d352 2
a353 2
					warningf(false, "%s: %s %s: %s",
					    "j_init", "tcgetpgrp", "failed",
d368 2
a369 2
				warningf(false, "%s: %s %s: %s", "j_init",
				    "setpgid", "failed", cstrerror(errno));
d373 2
a374 2
					warningf(false, "%s: %s %s: %s",
					    "j_init", "tcsetpgrp", "failed",
d470 1
a470 2
			internal_errorf("%s %d",
			    "exchild: XPIPEI and no last_job - pid",
d603 1
a603 1
		internal_warningf("%s: %s", "exchild", "execute() returned");
d864 2
a865 2
				bi_errorf("%s %s(%d, %ld) %s: %s",
				    "1st", "tcsetpgrp", tty_fd,
d867 1
a867 1
				    j->saved_ttypgrp : j->pgrp), "failed",
d886 1
a886 1
				warningf(true, "%s %s(%d, %ld) %s: %s",
d888 1
a888 1
				    (long)kshpgrp, "failed", cstrerror(errno));
d1178 1
a1178 1
				warningf(true, "%s %s(%d, %ld) %s: %s",
d1180 1
a1180 1
				    (long)kshpgrp, "failed", cstrerror(errno));
d1906 2
a1907 2
		warningf(false, "%s: %s %s: %s", "j_ttyinit",
		    "dup of tty fd", "failed", cstrerror(errno));
@


1.116
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d5 1
a5 1
 *		 2012, 2013, 2014, 2015
a217 2
	int termsig;

d222 1
a222 2
		termsig = WTERMSIG(p->status);
		return ((termsig < 1 || termsig > 127) ? 255 : 128 + termsig);
d756 1
a756 1
		*sigp = 128 + -rv;
@


1.115
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.41 2015/04/18 18:28:36 deraadt Exp $	*/
d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
d89 1
a89 1
	int32_t	age;		/* number of jobs started */
d121 1
a121 1
static int32_t njobs;		/* # of jobs started */
@


1.114
log
@add missing colon to two error msgs (no effect on dedup)
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.113
log
@be more careful with signals and errorlevels; bounds-check them better;
don’t trust the OS as POSuX comes up with more-than-8-bit exit codes now;
also, one more int → bool
@
text
@d895 1
a895 1
		bi_errorf("%s %s %s", "can't continue job",
@


1.112
log
@a bit oksh-inspired getn return value checking, plus some code optimisation
@
text
@d218 2
d222 1
a222 1
		return (WEXITSTATUS(p->status));
d224 2
a225 1
		return (128 + WTERMSIG(p->status));
d1229 8
a1236 8
		{
			int status;

			status = j->last_proc->status;
			if (Flag(FMONITOR) && j->state == PSIGNALLED &&
			    WIFSIGNALED(status) &&
			    (sigtraps[WTERMSIG(status)].flags & TF_TTY_INTR))
				trapsig(WTERMSIG(status));
d1533 1
a1533 1
	int coredumped;
d1557 1
a1557 1
		coredumped = 0;
d1562 5
a1566 3
		case PSTOPPED:
			strlcpy(buf, sigtraps[WSTOPSIG(p->status)].mess,
			    sizeof(buf));
d1568 4
a1571 1
		case PEXITED:
d1574 1
a1574 1
			else if (WEXITSTATUS(p->status) == 0)
d1578 1
a1578 1
				    WEXITSTATUS(p->status));
d1580 3
a1582 1
		case PSIGNALLED:
d1585 1
a1585 1
				coredumped = 1;
d1592 1
a1592 2
			    (WTERMSIG(p->status) == SIGINT ||
			    WTERMSIG(p->status) == SIGPIPE)) {
d1595 2
a1596 1
				strlcpy(buf, sigtraps[WTERMSIG(p->status)].mess,
d1599 1
@


1.111
log
@oksh RCSID sync: we use mksh getn() instead of OS strtonum() which is just as safe (audited right now)
@
text
@d1647 1
a1647 2
	if (ksh_isdigit(*cp)) {
		getn(cp, &job);
d1659 1
a1659 3
		if (ecodep)
			*ecodep = JL_NOSUCH;
		return (NULL);
d1662 1
d1682 2
a1683 1
		getn(cp, &job);
d1723 1
@


1.110
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.40 2013/09/04 15:49:18 millert Exp $	*/
@


1.109
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d1243 1
a1243 1
		/* nothing */;
@


1.108
log
@more IRC deliberation with igli (let’s hope the “const” works), plus style advice from Kernighan’s writs
@
text
@d5 1
a5 1
 *		 2012, 2013, 2014
@


1.107
log
@optimise a bit (nuke one redundant check), from igli via IRC
@
text
@d1114 1
d1242 3
a1244 1
	if ((flags & JW_PIPEST) && (j->proc_list != NULL)) {
a1245 1
		Proc *p = j->proc_list;
d1275 3
a1277 3
	} else if (Flag(FPIPEFAIL) && (j->proc_list != NULL)) {
		Proc *p = j->proc_list;
		int i;
d1279 1
a1279 2
		do {
			if ((i = proc_errorlevel(p)))
d1281 1
a1281 1
		} while ((p = p->next) != NULL);
@


1.106
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.105 2014/10/03 12:32:48 tg Exp $");
d1277 1
a1277 1
		while (p != NULL) {
d1280 1
a1280 2
			p = p->next;
		}
@


1.105
log
@use symmetric #ifdef checks for same-feature (Debian #763842)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.104 2014/06/10 22:17:09 tg Exp $");
d1050 1
a1050 1
	Job	*jl, *oldest;
d1087 1
a1087 1
	Proc	*p;
d1424 2
a1425 2
	int	jstate;
	Proc	*p;
d1527 6
a1532 6
	Proc	*p;
	int	state;
	int	status;
	int	coredumped;
	char	jobchar = ' ';
	char	buf[64];
d1534 1
a1534 1
	int	output = 0;
d1740 2
a1741 2
	int	i;
	Job	*newj, *j;
d1769 1
a1769 1
	Proc	*p;
d1789 2
a1790 2
	Proc	*p, *tmp;
	Job	**prev, *curr;
a1791 1
	mkssert(j != NULL);
d1832 1
a1832 1
	Job	**prev, *curr;
a1833 1
	mkssert(j != NULL);
d1870 2
a1871 2
	Proc	*p;
	int	rval = 0;
@


1.105.2.1
log
@MFC most of the rest: int → bool, MAXPATHLEN, comments/whitespace
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.105 2014/10/03 12:32:48 tg Exp $");
d1050 1
a1050 1
	Job *jl, *oldest;
d1087 1
a1087 1
	Proc *p;
d1424 2
a1425 2
	int jstate;
	Proc *p;
d1527 6
a1532 6
	Proc *p;
	int state;
	int status;
	int coredumped;
	char jobchar = ' ';
	char buf[64];
d1534 1
a1534 1
	int output = 0;
d1740 2
a1741 2
	int i;
	Job *newj, *j;
d1769 1
a1769 1
	Proc *p;
d1789 2
a1790 2
	Proc *p, *tmp;
	Job **prev, *curr;
d1792 1
d1833 1
a1833 1
	Job **prev, *curr;
d1835 1
d1872 2
a1873 2
	Proc *p;
	int rval = 0;
@


1.105.2.2
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.41 2015/04/18 18:28:36 deraadt Exp $	*/
d5 1
a5 1
 *		 2012, 2013, 2014, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.105.2.1 2015/01/25 15:44:06 tg Exp $");
a1113 1
	Proc *p;
d1241 1
a1241 3
	if (!(p = j->proc_list)) {
		;	/* nothing */
	} else if (flags & JW_PIPEST) {
d1243 1
d1273 3
a1275 3
	} else if (Flag(FPIPEFAIL)) {
		do {
			int i = proc_errorlevel(p);
d1277 2
a1278 1
			if (i)
d1280 2
a1281 1
		} while ((p = p->next));
d1647 2
a1648 1
	if (ksh_isdigit(*cp) && getn(cp, &job)) {
d1660 3
a1662 1
		goto j_lookup_nosuch;
a1664 1
 j_lookup_invalid:
d1684 1
a1684 2
		if (!getn(cp, &job))
			goto j_lookup_invalid;
a1723 1
 j_lookup_nosuch:
@


1.104
log
@fix “set -o pipefail” w/o PIPESTATUS, and PIPESTATUS inside COMSUBs and other sequences
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.103 2013/11/30 17:41:35 tg Exp $");
d1342 1
a1342 1
#ifdef WCONTINUED
d1384 1
a1384 1
#ifdef WIFCONTINUED
@


1.103
log
@detect getsid(2), also spotted by RT, this on MSYS
@
text
@d5 1
a5 1
 *		 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.102 2013/09/10 17:33:01 tg Exp $");
d1273 9
@


1.102
log
@integrate latest changes from oksh: Wed Sep 4 15:49:19 2013 UTC by millert

Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.97 2013/05/31 23:59:07 tg Exp $");
d228 1
a228 1
#ifndef MKSH_UNEMPLOYED
@


1.101
log
@apply patch from Steffen Daode Nurpmeso to use WCONTINUED waitpid(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.39 2009/12/13 04:36:48 deraadt Exp $	*/
d228 48
@


1.100
log
@TGIF, drinking-beer, Sysadmin Appreciation Day commit:
• As requested by Steffen Daode Nurpmeso, enlarge the
  amount of command characters shown in job handling
@
text
@d1284 5
a1288 1
		pid = waitpid(-1, &status, (WNOHANG|WUNTRACED));
d1327 7
@


1.99
log
@fix a number of warnings and other issues:
• sig_t detection was a bit insane, it is a function-pointer type after all
• fix uninitialised variable in c_select which led to mistakenly accepting
  invalid (nōn-numeric) input and acting, randomly, upon it
• keep SIGCHLD blocked in child after forking longer, for job list manip
• block SIGCHLD ifdef DEBUG_LEAKS to not run job foo during/after afreeall
• fix annoying ISO C90 vs. C99 (un)signed constant warning
@
text
@d48 1
a48 1
	char command[64 - (ALLOC_SIZE + sizeof(Proc *) + sizeof(pid_t) +
@


1.98
log
@-Wunused-macros
@
text
@a505 3
#ifndef MKSH_NOPROSPECTOFWORK
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
d540 4
@


1.97
log
@j_sigchld may also run outside of interrupt context, so better save errno
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.96 2013/05/02 20:28:12 tg Exp $");
a52 1
#define JP_NONE		0	/* don't print anything */
d105 3
a107 4
#define JL_OK		0
#define JL_NOSUCH	1	/* no such job */
#define JL_AMBIG	2	/* %foo or %?foo is ambiguous */
#define JL_INVALID	3	/* non-pid, non-% job id */
a109 1
	null,
d112 1
a112 2
	"argument must be %job or process id",
	NULL
d906 1
a906 1
		int	ecode;
@


1.96
log
@implement set -o pipefail
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.38 2009/12/12 04:28:44 deraadt Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.95 2013/04/01 02:37:50 tg Exp $");
d1257 1
a1257 2
	/* this runs inside interrupt context, with errno saved */

d1345 1
a1345 1
	/* nothing */;
@


1.95
log
@one can’t cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(I’m gonna have to revise lots more code…)
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.94 2012/12/28 02:28:36 tg Exp $");
d1224 2
@


1.94
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.93 2012/12/17 23:18:06 tg Exp $");
d466 1
a466 1
	rndset((long)cldpid);
@


1.93
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.92 2012/12/04 01:18:31 tg Exp $");
d110 1
a110 1
static const char *const lookup_msgs[] = {
@


1.92
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.91 2012/11/30 19:25:03 tg Exp $");
d309 1
a309 1
					    strerror(errno));
d324 1
a324 1
				    "setpgid", "failed", strerror(errno));
d330 1
a330 1
					    strerror(errno));
d373 1
a373 1
		warningf(false, "%s: %s", "bgnice", strerror(eno));
d738 1
a738 1
			bi_errorf("%s: %s", cp, strerror(errno));
d747 1
a747 1
			bi_errorf("%s: %s", cp, strerror(errno));
d823 1
a823 1
				    strerror(rv));
d843 1
a843 1
				    (long)kshpgrp, "failed", strerror(errno));
d847 1
a847 1
		    cp, strerror(eno));
d1134 1
a1134 1
				    (long)kshpgrp, "failed", strerror(errno));
d1825 1
a1825 1
		    strerror(errno));
d1830 1
a1830 1
		warningf(false, "%s: %s", "can't find tty fd", strerror(errno));
d1835 1
a1835 1
		    "dup of tty fd", "failed", strerror(errno));
d1839 1
a1839 1
		    "can't set close-on-exec flag", strerror(errno));
@


1.91
log
@implement tty tracking and bump to R41 for feature completeness

• tty_fd is now never closed
• new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
• as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
• otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
• SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
• change the Uhr to match – it no longer calls stty(1) ☺
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.88 2012/05/04 22:34:50 tg Exp $");
d1725 1
d1727 5
a1731 3
	curr = *prev;
	for (; curr != NULL && curr != j; prev = &curr->next, curr = *prev)
		;
d1768 1
d1772 4
a1775 2
	for (; curr && curr != j; prev = &curr->next, curr = *prev)
		;
@


1.91.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.91 2012/11/30 19:25:03 tg Exp $");
a1724 1
	mkssert(j != NULL);
d1726 3
a1728 5
	curr = job_list;
	while (curr && curr != j) {
		prev = &curr->next;
		curr = *prev;
	}
a1764 1
	mkssert(j != NULL);
d1768 2
a1769 4
	while (curr && curr != j) {
		prev = &curr->next;
		curr = *prev;
	}
@


1.91.2.2
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.91.2.1 2012/12/04 01:26:27 tg Exp $");
d1725 1
d1768 1
@


1.90
log
@tty_close() before exec() is not necessary, it’s FD_CLOEXEC anyway

only tty_close() left are now after the early init in main, which
is new, and when not FTALKING…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.89 2012/11/30 19:02:07 tg Exp $");
d155 3
d207 1
a207 1
	/* j_change() calls tty_init() */
d212 4
a215 2
	  if (Flag(FTALKING))
		tty_init(true, true);
d294 1
a294 1
		/* Don't call tcgetattr() 'til we own the tty process group */
d296 1
a296 1
			tty_init(false, true);
a341 2
		if (tty_fd >= 0)
			mksh_tcget(tty_fd, &tty_state);
a356 2
		if (!Flag(FTALKING))
			tty_close();
d358 1
d1141 1
a1141 1
		if (tty_fd >= 0) {
d1808 38
@


1.89
log
@use proper parenthesēs; int → bool; use same var (eno) for temp. errno
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.88 2012/05/04 22:34:50 tg Exp $");
a549 1
		tty_close();
@


1.88
log
@new MKSH_DISABLE_TTY_WARNING for ports that just can’t help it

TODO: add_cppflags this automatically in the TARGET_OS switch for some
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.86 2012/05/04 21:48:29 tg Exp $");
d294 1
a294 1
		if ((ttypgrp_ok = use_tty && tty_fd >= 0 && tty_devtty)) {
d366 1
a366 1
	int e;
d370 2
a371 2
	if (nice(ness) == -1 && (e = errno) != 0)
		warningf(false, "%s: %s", "bgnice", strerror(e));
d480 1
d833 1
a833 1
		int err = errno;
d846 1
a846 1
		    cp, strerror(err));
@


1.87
log
@last parts of Coherent patchkit: O_ACCMODE and termio
@
text
@d332 1
d336 1
@


1.86
log
@fix typo; 10x RT for spotting
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.84 2012/02/06 17:49:52 tg Exp $");
d92 1
a92 1
	struct termios ttystat;	/* saved tty state for stopped jobs */
d336 1
a336 1
			tcgetattr(tty_fd, &tty_state);
d806 1
a806 1
				tcsetattr(tty_fd, TCSADRAIN, &j->ttystat);
d813 1
a813 1
					tcsetattr(tty_fd, TCSADRAIN, &tty_state);
d835 1
a835 1
				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
d1133 1
a1133 1
				tcgetattr(tty_fd, &j->ttystat);
d1149 1
a1149 1
				tcgetattr(tty_fd, &tty_state);
d1151 1
a1151 1
				tcsetattr(tty_fd, TCSADRAIN, &tty_state);
@


1.85
log
@add experimental code to use sigprocmask+pause+sigprocmask ipv sigsuspend (and harden j_sigchld handler for that) to improve working on BeOS 5.0 and Coherent UNIX, found by RT
@
text
@d1088 1
a1088 1
		sigprocmask(SIG_SETMASK, &qmask, NULL);
@


1.84
log
@let struct proc allocate 64 chars even on !ILP32 platforms
(don’t fragment memory that much)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.83 2012/02/06 17:42:23 tg Exp $");
d1065 3
d1084 6
d1091 1
d1257 6
d1274 1
a1274 1
			return;
d1291 1
a1291 1
			return;
d1334 6
@


1.83
log
@make jobs reporting deal with UTF-8 (in utf8-mode)
reported by Andrew Kudryashov, 10x
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.82 2011/12/31 00:52:22 tg Exp $");
d40 1
a40 1
typedef struct proc	Proc;
d46 3
a48 1
	char command[44];	/* process command string */
@


1.82
log
@clang3 says: Branch condition evaluates to a garbage value
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.81 2011/08/27 18:06:46 tg Exp $");
d46 1
a46 1
	char command[48];	/* process command string */
@


1.81
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.80 2011/07/16 23:37:58 tg Exp $");
d1494 2
@


1.80
log
@eek, only be a ksh_nice if we HAVE_NICE
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.79 2011/07/16 17:41:50 tg Exp $");
d1062 1
a1062 1
	int	rv;
d1180 1
a1180 1
		size_t num = 0;
d1545 4
a1548 3
	Job		*j, *last_match;
	Proc		*p;
	int		len, job = 0;
@


1.79
log
@some distributions declare nice(3) with warn-unused-result; annoy mksh users running into this so they complain to their distros
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.78 2011/04/22 12:21:54 tg Exp $");
d356 1
d372 1
@


1.78
log
@this is about the amount -Wl,--gc-sections can help me to eliminate
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.77 2011/03/13 01:20:20 tg Exp $");
d356 16
d518 1
a518 1
			(void)nice(4);
@


1.78.2.1
log
@some distributions declare nice(3) with warn-unused-result; annoy mksh users running into this so they complain to their distros
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.78 2011/04/22 12:21:54 tg Exp $");
a355 16
/* run nice(3) and ignore the result */
static void
ksh_nice(int ness)
{
#if defined(__USE_FORTIFY_LEVEL) && (__USE_FORTIFY_LEVEL > 0)
	int e;

	errno = 0;
	/* this is gonna annoy users; complain to your distro, people! */
	if (nice(ness) == -1 && (e = errno) != 0)
		warningf(false, "%s: %s", "bgnice", strerror(e));
#else
	(void)nice(ness);
#endif
}

d502 1
a502 1
			ksh_nice(4);
@


1.78.2.2
log
@eek, only be a ksh_nice if we HAVE_NICE
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.78.2.1 2011/07/16 17:41:49 tg Exp $");
a355 1
#if HAVE_NICE
a370 1
#endif
@


1.77
log
@lint is your friend
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.76 2011/03/06 17:08:12 tg Exp $");
a863 19
int
j_njobs(void)
{
	Job *j;
	int nj = 0;
#ifndef MKSH_NOPROSPECTOFWORK
	sigset_t omask;

	sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
#endif
	for (j = job_list; j; j = j->next)
		nj++;

#ifndef MKSH_NOPROSPECTOFWORK
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
	return (nj);
}

@


1.76
log
@• more fixes (some regression, some new)
• more testcases, stricter testcases
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.75 2011/02/18 22:26:09 tg Exp $");
d296 1
a296 1
			while (1) {
d1313 1
a1313 1
	    while (1);
d1315 1
a1315 1
	    while (0);
@


1.75
log
@• add -u option (POSIX: unbuffered ⇒ nop) to the built-in cat
• PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
• add regression tests, documentation, etc.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.74 2011/01/30 01:35:34 tg Exp $");
d430 1
a430 1
	snptreef(p->command, sizeof(p->command), "%T", t);
d535 1
a535 1
		fptreef(shl_out, 2, "%s: tried to execute {\n%T\n}\n",
@


1.74
log
@introduce MKSH_NOPROSPECTOFWORK which is like pdksh’s JOB_SIGS in reverse, like MKSH_UNEMPLOYED is pdksh’s JOBS in reverse; allows mksh to work (hah! no pun intended…) with klibc (and possibly, Syllable Desktop and Plan 9) for now, until they fix their bugs
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.73 2011/01/21 21:04:44 tg Exp $");
d100 1
d211 13
d366 1
a366 1
	int rv = 0, forksleep;
d374 5
d565 1
a565 1
			rv = j_waitj(j, JW_NONE, "jw:last proc");
d1180 32
d1349 1
a1349 12

	switch (j->last_proc->state) {
	case PEXITED:
		j->status = WEXITSTATUS(j->last_proc->status);
		break;
	case PSIGNALLED:
		j->status = 128 + WTERMSIG(j->last_proc->status);
		break;
	default:
		j->status = 0;
		break;
	}
@


1.73
log
@• implement KSHEGID, KSHGID, KSHUID variables by suggestion of Richard K.
  (KSHEUID aka USER_ID already exists)
• simplify, speed up LCG and $RANDOM handling again
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.72 2010/08/28 20:22:19 tg Exp $");
d127 1
d130 1
d162 1
d171 4
d215 2
a216 2
	Job	*j;
	int	killed = 0;
d224 1
a224 1
			killed = 1;
d346 2
a347 1
    /* used if XPCLOSE or XCCLOSE */ int close_fd)
d349 2
a350 1
	static Proc *last_proc;		/* for pipelines */
d353 1
d355 1
d367 1
d370 1
d416 2
a417 1
		if (intrsig)	 /* allow user to ^C out... */
d428 1
d430 1
d438 3
a440 2
		int	dotty = 0;
		if (j->pgrp == 0) {	/* First process */
d442 1
a442 1
			dotty = 1;
d445 2
a446 1
		/* set pgrp in both parent and child to deal with race
d465 1
d467 1
d470 2
a471 1
		/* If FMONITOR or FTALKING is set, these signals are ignored,
d500 2
a501 1
		remove_job(j, "child");	/* in case of $(jobs) command */
d525 2
a526 1
	if (!(flags & XPIPEO)) {	/* last process in a job */
d549 1
d551 1
d560 1
d564 1
d566 2
a567 1
	if (last_job) { /* no need to report error - waitlast() will do it */
d572 1
d574 1
d581 3
a583 2
	int	rv;
	Job	*j;
d587 1
d595 1
d597 3
a599 1
		return (125);	/* not so arbitrary, non-zero value */
d604 1
d606 1
d615 3
a617 4
	int	rv;
	Job	*j;
	int	ecode;
	int	flags = JW_INTERRUPT|JW_ASYNCNOTIFY;
d621 1
d635 1
d637 1
d644 1
d646 1
d650 1
d652 1
d661 1
d663 1
d665 2
a666 1
	if (rv < 0) /* we were interrupted */
d676 3
a678 3
	Job	*j;
	int	rv = 0;
	int	ecode;
d682 1
d685 1
d687 1
d692 2
a693 1
	if (j->pgrp == 0) {	/* started when !Flag(FMONITOR) */
d709 1
d711 1
d721 4
a724 5
	Job	*j;
	Proc	*p;
	int	ecode;
	int	running;
	int	rv = 0;
d744 1
a744 1
	running = 0;
d749 1
a749 1
			running = 1;
d775 1
a775 2
				sigprocmask(SIG_SETMASK, &omask,
				    NULL);
d822 2
a823 2
	Job	*j;
	int	which = 0;
d850 1
d854 1
d858 1
d860 1
d868 2
a869 1
    int nflag)		/* 0: short, 1: long, 2: pgrp */
d871 3
a873 3
	Job	*j, *tmp;
	int	how;
	int	zflag = 0;
d877 1
d879 2
a880 1
	if (nflag < 0) { /* kludge: print zombies */
d888 1
d890 1
d913 1
d915 1
d923 2
a924 1
	Job	*j, *tmp;
d928 1
d934 2
a935 1
		/* Remove job after doing reports so there aren't
d947 1
d949 1
d956 1
d960 1
d965 1
d967 1
d1024 1
d1030 1
d1040 2
a1041 1
    int flags,			/* see JW_* */
d1060 1
d1062 3
d1069 2
a1070 1
			j->flags |= oldf;	/* not reached... */
d1196 1
d1208 1
d1212 1
d1214 3
d1258 8
a1265 2
		check_job(j);	/* check to see if entire job is done */
	} while (1);
d1292 2
a1293 1
			return;	/* some processes still running */
d1553 2
a1554 1
	case '?':		/* %?string */
d1570 2
a1571 1
	default:		/* %string */
@


1.72
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.71 2010/08/28 18:50:53 tg Exp $");
d345 3
a347 5
	struct {
		Proc *p;
		Job *j;
		pid_t cldpid;
	} pi;
d359 5
a363 5
	pi.p = new_proc();
	pi.p->next = NULL;
	pi.p->state = PRUNNING;
	pi.p->status = 0;
	pi.p->pid = 0;
d372 1
a372 1
		pi.j = last_job;
d374 2
a375 2
			last_proc->next = pi.p;
		last_proc = pi.p;
d377 2
a378 1
		pi.j = new_job();	/* fills in pi.j->job */
d383 1
a383 1
		pi.j->flags = (flags & XXCOM) ? JF_XXCOM :
d385 11
a395 11
		timerclear(&pi.j->usrtime);
		timerclear(&pi.j->systime);
		pi.j->state = PRUNNING;
		pi.j->pgrp = 0;
		pi.j->ppid = procpid;
		pi.j->age = ++njobs;
		pi.j->proc_list = pi.p;
		pi.j->coproc_id = 0;
		last_job = pi.j;
		last_proc = pi.p;
		put_job(pi.j, PJ_PAST_STOPPED);
d398 1
a398 1
	snptreef(pi.p->command, sizeof(pi.p->command), "%T", t);
d402 1
a402 1
	while ((pi.cldpid = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
d408 6
a413 3
	if (pi.cldpid < 0) {
		kill_job(pi.j, SIGKILL);
		remove_job(pi.j, "fork failed");
d417 1
a417 7
	pi.p->pid = pi.cldpid ? pi.cldpid : (procpid = getpid());

	/*
	 * ensure next child gets a (slightly) different $RANDOM sequence
	 * from its parent process and other child processes
	 */
	change_random(&pi, sizeof(pi));
d423 2
a424 2
		if (pi.j->pgrp == 0) {	/* First process */
			pi.j->pgrp = pi.p->pid;
d431 1
a431 1
		setpgid(pi.p->pid, pi.j->pgrp);
d433 1
a433 1
			tcsetpgrp(tty_fd, pi.j->pgrp);
d438 2
a439 2
	if (close_fd >= 0 && (((flags & XPCLOSE) && pi.cldpid) ||
	    ((flags & XCCLOSE) && !pi.cldpid)))
d441 1
a441 1
	if (!pi.cldpid) {
d479 1
a479 1
		remove_job(pi.j, "child");	/* in case of $(jobs) command */
d504 1
a504 1
		j_startjob(pi.j);
d506 1
a506 1
			pi.j->coproc_id = coproc.id;
d510 1
a510 1
			coproc.job = (void *)pi.j;
d513 1
a513 1
			j_set_async(pi.j);
d515 2
a516 3
				shf_fprintf(shl_out, "[%d]", pi.j->job);
				for (pi.p = pi.j->proc_list; pi.p;
				    pi.p = pi.p->next)
d518 1
a518 1
					    (int)pi.p->pid);
d523 1
a523 1
			rv = j_waitj(pi.j, JW_NONE, "jw:last proc");
@


1.71
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.70 2010/08/28 15:48:19 tg Exp $");
d279 2
a280 2
					warningf(false, "%s: %s: %s", "j_init",
					    "tcgetpgrp() failed",
d295 2
a296 3
				warningf(false, "%s: %s: %s", "j_init",
				    "setpgid() failed",
				    strerror(errno));
d300 2
a301 2
					warningf(false, "%s: %s: %s", "j_init",
					    "tcsetpgrp() failed",
d371 2
a372 2
			internal_errorf(
			    "exchild: XPIPEI and no last_job - pid %d",
d413 1
a413 1
		errorf("cannot fork - try again");
d572 1
a572 1
	rv = j_waitj(j, JW_NONE, "jw:waitlast");
d731 4
a734 4
				bi_errorf("1st tcsetpgrp(%d, %d) failed: %s",
				    tty_fd,
				    (int)((j->flags & JF_SAVEDTTYPGRP) ?
				    j->saved_ttypgrp : j->pgrp),
d753 3
a755 3
				warningf(true,
				    "fg: 2nd tcsetpgrp(%d, %ld) failed: %s",
				    tty_fd, (long)kshpgrp, strerror(errno));
d758 1
a758 1
		bi_errorf("%s %s %s", "cannot continue job",
d1025 3
a1027 3
				warningf(true,
				    "j_waitj: tcsetpgrp(%d, %ld) failed: %s",
				    tty_fd, (long)kshpgrp, strerror(errno));
d1375 1
a1375 1
				shf_fprintf(shf, "%s", filler);
d1572 1
a1572 1
		internal_warningf("remove_job: job not found (%s)", where);
@


1.70
log
@whitespace
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.69 2010/07/04 17:33:54 tg Exp $");
d279 2
a280 2
					warningf(false,
					    "j_init: tcgetpgrp() failed: %s",
d295 2
a296 2
				warningf(false,
				    "j_init: setpgid() failed: %s",
d301 2
a302 2
					warningf(false,
					    "j_init: tcsetpgrp() failed: %s",
d311 2
a312 1
			warningf(false, "warning: won't have full job control");
d498 3
a500 2
		internal_warningf("exchild: execute() returned");
		fptreef(shl_out, 2, "exchild: tried to execute {\n%T\n}\n", t);
d566 1
a566 1
			warningf(true, "waitlast: no last job");
d568 1
a568 1
			internal_warningf("waitlast: not started");
d759 1
a759 1
		bi_errorf("cannot continue job %s: %s",
d921 1
a921 1
		internal_warningf("j_async: job not started");
d935 2
a936 2
				internal_warningf("j_async: bad nzombie (%d)",
				    nzombie);
@


1.69
log
@to speed up mksh, get rid of arc4random(3) uses and use the LCG always;
depend on ASLR for seeding
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.68 2010/07/04 13:36:42 tg Exp $");
d66 1
a66 1
#define JF_SAVEDTTY	0x020	/* j->ttystate is valid */
d90 1
a90 1
	struct termios ttystate;/* saved tty state for stopped jobs */
d379 1
a379 1
		pi.j = new_job(); /* fills in pi.j->job */
d568 1
a568 1
		return (125); /* not so arbitrary, non-zero value */
d720 1
a720 1
				tcsetattr(tty_fd, TCSADRAIN, &j->ttystate);
d996 1
a996 1
			j->flags |= oldf; /* not reached... */
d1029 1
a1029 1
				tcgetattr(tty_fd, &j->ttystate);
@


1.68
log
@simplify a bunch of things (no SIGWINCH handler, errno is saved for
an shtrap automatically) and gratitutous reformatting of comments
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.67 2009/12/31 14:05:43 tg Exp $");
d343 1
a343 1
	int i, rv = 0, forksleep;
a344 2
	Proc *p;
	Job *j;
d346 3
a348 4
#if !HAVE_ARC4RANDOM
		pid_t thepid;
#endif
		unsigned char ischild;
d361 5
a365 5
	p = new_proc();
	p->next = NULL;
	p->state = PRUNNING;
	p->status = 0;
	p->pid = 0;
d368 2
a369 1
	if (flags & XPIPEI) {	/* continuing with a pipe */
d374 1
a374 1
		j = last_job;
d376 2
a377 2
			last_proc->next = p;
		last_proc = p;
d379 1
a379 1
		j = new_job(); /* fills in j->job */
d384 1
a384 1
		j->flags = (flags & XXCOM) ? JF_XXCOM :
d386 11
a396 11
		timerclear(&j->usrtime);
		timerclear(&j->systime);
		j->state = PRUNNING;
		j->pgrp = 0;
		j->ppid = procpid;
		j->age = ++njobs;
		j->proc_list = p;
		j->coproc_id = 0;
		last_job = j;
		last_proc = p;
		put_job(j, PJ_PAST_STOPPED);
d399 1
a399 1
	snptreef(p->command, sizeof(p->command), "%T", t);
d403 1
a403 1
	while ((i = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
d409 3
a411 3
	if (i < 0) {
		kill_job(j, SIGKILL);
		remove_job(j, "fork failed");
d415 1
a415 8
#if !HAVE_ARC4RANDOM
#ifdef DEBUG
	/* reduce extra 3 bytes of entropy, for Valgrind */
	memset(&pi, 0, sizeof(pi));
#endif
	pi.thepid =
#endif
	    p->pid = (pi.ischild = i == 0) ? (procpid = getpid()) : i;
a416 1
#if !HAVE_ARC4RANDOM
a421 1
#endif
d427 2
a428 2
		if (j->pgrp == 0) {	/* First process */
			j->pgrp = p->pid;
d435 1
a435 1
		setpgid(p->pid, j->pgrp);
d437 1
a437 1
			tcsetpgrp(tty_fd, j->pgrp);
d442 2
a443 2
	if (close_fd >= 0 && (((flags & XPCLOSE) && !pi.ischild) ||
	    ((flags & XCCLOSE) && pi.ischild)))
d445 3
a447 1
	if (pi.ischild) {		/* child */
d459 2
a460 2
			for (i = NELEM(tt_sigs); --i >= 0; )
				setsig(&sigtraps[tt_sigs[i]], SIG_DFL,
d478 3
a480 3
			    ((i = open("/dev/null", 0)) > 0)) {
				(void)ksh_dup2(i, 0, true);
				close(i);
d483 1
a483 1
		remove_job(j, "child");	/* in case of $(jobs) command */
d507 1
a507 1
		j_startjob(j);
d509 5
a513 3
			j->coproc_id = coproc.id;
			coproc.njobs++; /* n jobs using co-process output */
			coproc.job = (void *) j; /* j using co-process input */
d516 1
a516 1
			j_set_async(j);
d518 3
a520 2
				shf_fprintf(shl_out, "[%d]", j->job);
				for (p = j->proc_list; p; p = p->next)
d522 1
a522 1
					    (int)p->pid);
d527 1
a527 1
			rv = j_waitj(j, JW_NONE, "jw:last proc");
@


1.67
log
@jobs.c: apply patch from deraadt@@o:
│remember to restore errno (ie. stop someone from making a mistake later)
│ok guenther
check.t, sh.h: bump vsn

I wonder though why errno must be restored even if nothing was
called after reading it… moid?
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.66 2009/12/12 22:27:08 tg Exp $");
d173 2
a174 1
	/* shl_j is used to do asynchronous notification (used in
d182 2
a183 1
		/* the TF_SHELL_USES test is a kludge that lets us know if
d238 2
a239 1
		/* Need to restore the tty pgrp to what it was when the
d355 2
a356 1
		/* Clear XFORK|XPCLOSE|XCCLOSE|XCOPROC|XPIPEO|XPIPEI|XXCOM|XBGND
d382 2
a383 1
		/* we don't consider XXCOMs foreground since they don't get
d599 2
a600 1
		/* wait for an unspecified job - always returns 0, so
d912 2
a913 1
/* Make j the last async process
d949 2
a950 1
/* Start a job: set STARTED, check for held signals and set j->last_proc
d1040 2
a1041 1
			/* Only restore tty settings if job was originally
d1054 2
a1055 1
				/* Don't use tty mode if job is stopped and
d1071 2
a1072 1
		/* If it looks like user hit ^C to kill a job, pretend we got
d1111 2
a1112 1
/* SIGCHLD handler to reap children and update job states
d1120 1
a1120 6
	int		errno_ = errno;
	Job		*j;
	Proc		*p = NULL;
	int		pid;
	int		status;
	struct rusage	ru0, ru1;
d1122 8
a1129 1
	/* Don't wait for any processes if a job is partially started.
d1137 1
a1137 1
			goto finished;
d1144 6
a1149 2
		if (pid <= 0)	/* return if would block (0) ... */
			break;	/* ... or no children or interrupted (-1) */
a1185 3

 finished:
	errno = errno_;
d1230 2
a1231 1
	/* Note when co-process dies: can't be done in j_wait() nor
d1236 2
a1237 1
		/* No need to keep co-process input any more
d1242 2
a1243 1
			/* XXX would be nice to get the closes out of here
d1259 2
a1260 1
		/* Only put stopped jobs at the front to avoid confusing
d1277 2
a1278 1
			/* Can't call j_notify() as it removes jobs. The job
d1322 2
a1323 1
		/* POSIX doesn't say what to do it there is no process
d1362 3
a1364 2
			/* kludge for not reporting 'normal termination signals'
			 * (ie, SIGINT, SIGPIPE)
d1417 2
a1418 1
/* Convert % sequence to job
d1435 4
a1438 2
		/* ...then look for process group (this is non-POSIX,
		 * but should not break anything */
d1512 2
a1513 1
/* allocate a new job and fill in the job number.
d1541 2
a1542 1
/* Allocate new process struct
d1560 2
a1561 1
/* Take job out of job_list and put old structures into free list.
d1601 2
a1602 1
/* put j in a particular location (taking it out job_list if it is there
d1638 2
a1639 1
/* nuke a job (called when unable to start full job).
@


1.66
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.65 2009/12/12 17:45:42 tg Exp $");
d1123 1
a1123 1
			return;
d1169 1
@


1.65
log
@   Revision 1.38: [7]download - view: [8]text, [9]markup, [10]annotated - [11]select for diffs
   Sat Dec 12 04:28:44 2009 UTC (13 hours, 14 minutes ago) by deraadt
   Branches: [12]MAIN
   CVS tags: [13]HEAD
   Diff to: previous 1.37: [14]preferred, [15]coloured
   Changes since revision 1.37: +2 -3 lines
a dangling do / while that was very very ugly
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.64 2009/12/05 22:03:39 tg Exp $");
d1106 1
a1106 1
j_sigchld(int sig __unused)
@


1.64
log
@another Valgrind würgaround
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.37 2009/01/29 23:27:26 jaredy Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.63 2009/11/22 14:14:42 tg Exp $");
d1167 1
a1167 2
	}
	while (1);
@


1.63
log
@25 is a better (POSIX) CHILD_MAX
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.62 2009/10/17 21:16:02 tg Exp $");
d413 4
@


1.62
log
@• overhaul handling of special variables
• use a combination of the one-at-a-time hash and an LCG for handling
  the $RANDOM special if !HAVE_ARC4RANDOM instead of rand(3)/srand(3)
  and get rid of time(3) usage to reduce import footprint
• raise entropy state (mostly in the !HAVE_ARC4RANDOM case though…)
• simplify handling of the $RANDOM_SPECIAL generally
• tweak hash() to save a temp var for non-optimising compilers
• some int → mksh_ari_t and other type fixes
• general tweaking of code and comments
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.61 2009/09/26 03:39:59 tg Exp $");
d124 1
a124 5
#ifdef _POSIX_CHILD_MAX
#define CHILD_MAX	_POSIX_CHILD_MAX
#elif defined(__KLIBC__)	/* XXX imake style */
#define CHILD_MAX	999	/* no limit :-) */
#endif
@


1.61
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.60 2009/09/20 16:40:55 tg Exp $");
d342 1
a342 1
	static Proc	*last_proc;	/* for pipelines */
d344 10
a353 7
	int		i;
	sigset_t	omask;
	Proc		*p;
	Job		*j;
	int		rv = 0;
	int		forksleep;
	int		ischild;
d416 4
a419 5
	ischild = i == 0;
	if (ischild)
		p->pid = procpid = getpid();
	else
		p->pid = i;
d422 5
a426 2
	/* ensure next child gets a (slightly) different $RANDOM sequence */
	change_random(((unsigned long)p->pid << 1) | (ischild ? 1 : 0));
d448 2
a449 2
	if (close_fd >= 0 && (((flags & XPCLOSE) && !ischild) ||
	    ((flags & XCCLOSE) && ischild)))
d451 1
a451 1
	if (ischild) {		/* child */
@


1.60
log
@more of this:

• shell flags are now handled in one single place (sh_flags.h)
• sync comments (between enum and array) and manpage with reality
• FMONITOR is now no longer needed for Hartz IV shells
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.59 2009/08/01 20:32:44 tg Exp $");
d419 2
a420 2
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
	/* Ensure next child gets a (slightly) different $RANDOM sequence */
@


1.59
log
@more use of memcpy(3) when we know destination and source sizes
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.58 2009/07/25 21:31:25 tg Exp $");
a159 1
#endif
d162 1
d467 5
a471 1
		if ((flags & XBGND) && !Flag(FMONITOR)) {
d977 1
d979 1
d1077 5
a1081 2
	if (!(flags & JW_ASYNCNOTIFY) &&
	    (!Flag(FMONITOR) || j->state != PSTOPPED)) {
d1085 5
a1089 2
	if (j->state != PSTOPPED &&
	    (!Flag(FMONITOR) || !(flags & JW_ASYNCNOTIFY)))
d1264 5
a1268 1
	if (!Flag(FMONITOR) && !(j->flags & (JF_WAITING|JF_FG)) &&
@


1.58
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.57 2009/06/11 12:42:19 tg Exp $");
d1300 1
a1300 1
			strlcpy(buf, "Running", sizeof(buf));
d1310 1
a1310 1
				strlcpy(buf, "Done", sizeof(buf));
@


1.57
log
@capitalise AT&T®
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.56 2009/06/10 18:12:47 tg Exp $");
d126 1
a126 1
#elif defined(__KLIBC__)
@


1.56
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.55 2009/06/08 20:34:40 tg Exp $");
d589 1
a589 1
			/* at&t ksh will wait for stopped jobs - we don't */
d610 1
a610 1
	/* at&t ksh will wait for stopped jobs - we don't */
d1051 1
a1051 1
		 * one too to break out of for loops, etc. (at&t ksh does this
@


1.55
log
@• Check if killpg(3) is available; if not, use kill(2) with negative
  process ID and hope it works (is POSIXly killpg-endowed)
• bump version
• sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.54 2009/06/08 20:06:47 tg Exp $");
d723 1
a723 1
				    (int) ((j->flags & JF_SAVEDTTYPGRP) ?
d998 1
a998 1
			 * when the job is foregrounded.  This is to
d1022 1
a1022 1
			 * started in the foreground.  Problems can be
d1035 1
a1035 1
				 * later restarted and exits.  Consider
d1051 1
a1051 1
		 * one too to break out of for loops, etc.  (at&t ksh does this
d1158 1
a1158 1
 * from j_sigchld()).  If no processes are running, the job status
d1241 1
a1241 1
			/* Can't call j_notify() as it removes jobs.  The job
d1282 1
a1282 1
		 * group leader (ie, !FMONITOR).  We arbitrarily return
d1290 1
a1290 1
	filler = j->job > 10 ?  "\n       " : "\n      ";
@


1.54
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 8
a32 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.53 2009/05/16 16:59:36 tg Exp $");
d223 1
a223 1
				killpg(j->pgrp, SIGHUP);
d229 1
a229 1
					killpg(j->pgrp, SIGCONT);
d646 1
a646 1
			(void)killpg(j->pgrp, SIGCONT);
d648 1
a648 1
		if (killpg(j->pgrp, sig) < 0) {
d735 1
a735 1
	if (j->state == PRUNNING && killpg(j->pgrp, SIGCONT) < 0) {
@


1.53
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.52 2009/04/07 18:41:36 tg Exp $");
d349 1
a349 1
		return execute(t, flags & (XEXEC | XERROK), xerrok);
d517 1
a517 1
	return rv;
d553 1
a553 1
		return 125; /* not so arbitrary, non-zero value */
d560 1
a560 1
	return rv;
d587 1
a587 1
			return -1;
d594 1
a594 1
			return -1;
d600 1
a600 1
		return -1;
d611 1
a611 1
	return rv;
d628 1
a628 1
		return 1;
d649 1
a649 1
	return rv;
d669 1
a669 1
		return 1;
d675 1
a675 1
		return 1;
d719 1
a719 1
				return 1;
d743 1
a743 1
		return 1;
d752 1
a752 1
	return rv;
d777 1
a777 1
		return 1;
d780 1
a780 1
	return 0;
d795 1
a795 1
	return nj;
d821 1
a821 1
			return 1;
d843 1
a843 1
	return 0;
d887 1
a887 1
	return async_pid;
d980 1
a980 1
			return -rv;
d1073 1
a1073 1
	return rv;
d1293 1
a1293 1
			strlcpy(buf, "Running", sizeof buf);
d1297 1
a1297 1
			    sizeof buf);
d1303 1
a1303 1
				strlcpy(buf, "Done", sizeof buf);
d1322 1
a1322 1
				    sizeof buf);
d1383 1
a1383 1
				return j;
d1388 1
a1388 1
				return j;
d1391 1
a1391 1
		return NULL;
d1396 1
a1396 1
		return NULL;
d1403 1
a1403 1
			return job_list;
d1408 1
a1408 1
			return job_list->next;
d1416 1
a1416 1
				return j;
d1427 1
a1427 1
						return NULL;
d1432 1
a1432 1
			return last_match;
d1443 1
a1443 1
					return NULL;
d1448 1
a1448 1
			return last_match;
d1453 1
a1453 1
	return NULL;
d1473 1
a1473 1
		newj = alloc(sizeof (Job), APERM);
d1484 1
a1484 1
	return newj;
d1500 1
a1500 1
		p = alloc(sizeof (Proc), APERM);
d1502 1
a1502 1
	return p;
d1595 1
a1595 1
	return rval;
@


1.52
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.51 2009/04/05 13:37:37 tg Exp $");
@


1.51
log
@remove extra parenthesēs; the error on WIFSIGNALED is still there:
unary - and & prios on Minix are correct, but gcc4 warns too much…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.50 2009/04/05 13:07:11 tg Exp $");
d16 1
a18 1
	pid_t pid;		/* process id */
d50 6
a59 2
	pid_t pgrp;		/* process group of job */
	pid_t ppid;		/* pid of process that forked job */
a60 4
	struct timeval systime;	/* system time used by job */
	struct timeval usrtime;	/* user time used by job */
	Proc *proc_list;	/* process list */
	Proc *last_proc;	/* last process in list */
@


1.50
log
@more extra parenthesēs (gcc4 strict warnings + broken system headers)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.49 2009/04/05 12:35:31 tg Exp $");
d1033 1
a1033 1
			    (WIFSIGNALED(status)) &&
d1113 1
a1113 1
		if ((WIFSTOPPED(status)))
d1117 1
a1117 1
		  if ((WIFSIGNALED(status)))
@


1.49
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.48 2009/04/03 09:48:10 tg Exp $");
d1113 1
a1113 1
		if (WIFSTOPPED(status))
d1117 1
a1117 1
		  if (WIFSIGNALED(status))
@


1.48
log
@extra parens around WIFSIGNALLED seem necessary on some OSes (gcc 4.1)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.47 2009/04/03 09:42:25 tg Exp $");
d62 1
d65 1
d107 1
d112 1
d129 1
a129 1
j_init(int mflagset)
d131 6
a148 1
#endif
d172 3
a174 1
	else if (Flag(FTALKING))
d197 1
d204 1
d211 1
d227 1
d230 1
d307 1
d397 1
d413 1
d425 1
d435 1
d453 1
d456 1
d617 1
d619 2
a620 1
			(void) killpg(j->pgrp, SIGCONT);
d632 1
d734 1
d744 1
d747 1
d835 1
d838 1
a965 2
		int	status;

d967 1
d992 1
d1022 1
d1028 10
a1037 5
		status = j->last_proc->status;
		if (Flag(FMONITOR) && j->state == PSIGNALLED &&
		    (WIFSIGNALED(status)) &&
		    (sigtraps[WTERMSIG(status)].flags & TF_TTY_INTR))
			trapsig(WTERMSIG(status));
d1112 1
d1115 3
a1117 1
		else if (WIFSIGNALED(status))
d1195 1
d1224 1
@


1.47
log
@experimental: prevent FMONITOR from being set on, say, Minix 3, Plan 9
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.46 2009/03/26 11:22:53 tg Exp $");
d998 1
a998 1
		    WIFSIGNALED(status) &&
@


1.46
log
@another cast to void to silence gcc1 on BSD/OS

XXX rlim_t = quad_t there is not detected
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.45 2009/03/22 17:47:37 tg Exp $");
d136 1
d139 1
@


1.45
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.44 2009/02/23 16:17:44 tg Exp $");
d131 1
a131 1
	sigaddset(&sm_sigchld, SIGCHLD);
@


1.44
log
@CHILD_MAX isn’t defined in klibc either, copy dietlibc’s definition
thanks fefe (btw, funny tempnam link time warning… never used colours…)

pending Debian #516294, #516773, #516774, mksh might work with klcc now
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.36 2007/09/06 19:57:47 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.43 2008/12/29 20:47:15 tg Exp $");
d292 3
a294 1
exchild(struct op *t, int flags, /* used if XPCLOSE or XCCLOSE */ int close_fd)
d310 1
a310 1
		return execute(t, flags & (XEXEC | XERROK));
d435 2
a436 1
		execute(t, (flags & XERROK) | XEXEC); /* no return */
@


1.43
log
@give tty_init() another argument for silent initialisation
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.42 2008/12/13 17:02:15 tg Exp $");
d95 1
d97 3
@


1.42
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.41 2008/11/30 10:33:38 tg Exp $");
d158 1
a158 1
		tty_init(true);
d220 1
a220 1
			tty_init(false);
@


1.41
log
@if MKSH_SMALL and HAVE_ARC4RANDOM, there is no need to use rand()/srand(3)
ever, since MKSH_SMALL is not required to be as close to compatibility as
normal/generic shells; we can also get rid of time(3) calls
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.40 2008/11/12 00:54:49 tg Exp $");
d1402 1
a1402 1
		newj = alloc(1, sizeof (Job), APERM);
d1429 1
a1429 1
		p = alloc(1, sizeof (Proc), APERM);
@


1.40
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.39 2008/11/09 20:32:18 tg Exp $");
d367 1
d370 1
@


1.40.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.40 2008/11/12 00:54:49 tg Exp $");
d1400 1
a1400 1
		newj = galloc(1, sizeof (Job), APERM);
d1427 1
a1427 1
		p = galloc(1, sizeof (Proc), APERM);
@


1.39
log
@build warning-free with LLVM+Clang on MirBSD itself
$ (CCC_LD=mgcc CC=ccc sh Build.sh -r && ./test.sh -v) 2>&1 | tee log
Total failed: 2 (as expected)
Total passed: 278

Just the result is huge, and we could of course build to intermediate
byte code to optimise globally…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.38 2008/10/26 21:51:26 ahoka Exp $");
d1400 1
a1400 1
		newj = (Job *)alloc(sizeof (Job), APERM);
d1427 1
a1427 1
		p = (Proc *)alloc(sizeof (Proc), APERM);
@


1.38
log
@Add check for the nice(3) system call.
It may be not implemented on some plaforms, though it's usually present.

Required to compile on Haiku as of 2008 October.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.37 2008/10/13 23:06:03 tg Exp $");
d123 1
a123 1
	sigemptyset(&sm_default);
d126 1
a126 1
	sigemptyset(&sm_sigchld);
@


1.37
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.36 2008/05/17 19:03:25 tg Exp $");
d405 1
d408 1
@


1.36
log
@optimise based upon the following assumption:
• my_pid = getpid(); setpgid(0, my_pid);
• if it hasn’t failed, the following is true: getpgrp() == my_pid

at least this is what I gather from TFM and the kernel source
waldi _thinks_ so, too
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.35 2008/05/17 18:46:59 tg Exp $");
d322 2
a323 1
		last_proc->next = p;
d406 1
a406 1
			i = nice(4);
d412 4
a415 6
			if (!(flags & (XPIPEI | XCOPROC))) {
				int fd = open("/dev/null", 0);
				if (fd != 0) {
					(void) ksh_dup2(fd, 0, true);
					close(fd);
				}
@


1.35
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.34 2008/05/15 15:24:09 tg Exp $");
a103 1
static pid_t		our_pgrp;
a223 1
			our_pgrp = kshpgrp;
d237 1
a237 1
				if (ttypgrp == our_pgrp)
d245 1
a245 1
		if (ttypgrp_ok && our_pgrp != kshpid) {
d258 2
a259 2
					restore_ttypgrp = our_pgrp;
				our_pgrp = kshpid;
d677 1
a677 1
			if (ttypgrp_ok && tcsetpgrp(tty_fd, our_pgrp) < 0) {
d679 2
a680 4
				    "fg: 2nd tcsetpgrp(%d, %d) failed: %s",
				    tty_fd, (int)our_pgrp,
				    strerror(errno));
			}
d941 1
a941 1
			if (tcsetpgrp(tty_fd, our_pgrp) < 0) {
d943 2
a944 4
				    "j_waitj: tcsetpgrp(%d, %d) failed: %s",
				    tty_fd, (int)our_pgrp,
					strerror(errno));
			}
@


1.34
log
@mksh:
* initialise the integers PPID, OPTIND, RANDOM, SECONDS, and TMOUT to base-10
* bring back PGRP as base-10 integer to the process group via getpgrp(2)
* initialise USER_ID as base-10 integer to the effective user id as retrieved
  from geteuid(2) = $(id -u)
* use $USER_ID in dot.mkshrc instead of spawning an id(1) process
  -> dot.mkshrc,v 1.34 now requires mksh R34
* convert more int to bool where appropriate
* remove dead code - getpgrp(2) cannot fail
* sync manual page to reality
* bump to mksh R34(beta) - feature freeze

XXX check if our_pgrp in jobs.c is still really needed, the setpgid call
XXX probably just makes us our own pgrp leader, and we might have to use
XXX and update kshpgrp accordingly - need feedback/help here but I think
XXX this simplification should be possible if I grok the code correctly.

etc/profile:
* adjust to $USER_ID changes in mksh (speed-up here, too)

mksh.hts:
* sync changelog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.33 2008/04/01 21:50:58 tg Exp $");
d1405 1
a1405 1
		newj = (Job *) alloc(sizeof(Job), APERM);
d1432 1
a1432 1
		p = (Proc *) alloc(sizeof(Proc), APERM);
@


1.33
log
@more
• int → bool
• shprintf("foo") → shf_puts("foo", shl_stdout)
• shprintf("%s", foo) → shf_puts(foo, shl_stdout)
• shf_puts("x", foo) → shf_putc('x', foo)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.32 2007/10/25 15:23:09 tg Exp $");
d102 1
a102 1
static int		ttypgrp_ok;	/* set if can use tty pgrps */
d224 2
a225 8
		ttypgrp_ok = use_tty && tty_fd >= 0 && tty_devtty;

		if (ttypgrp_ok && (our_pgrp = getpgrp()) < 0) {
			warningf(false, "j_init: getpgrp() failed: %s",
			    strerror(errno));
			ttypgrp_ok = 0;
		}
		if (ttypgrp_ok) {
d236 1
a236 1
					ttypgrp_ok = 0;
d252 1
a252 1
				ttypgrp_ok = 0;
d258 1
a258 1
					ttypgrp_ok = 0;
d269 1
a269 1
		ttypgrp_ok = 0;
d423 1
a423 1
		ttypgrp_ok = 0;
d682 1
a682 1
				    tty_fd, (int) our_pgrp,
d948 1
a948 1
				    tty_fd, (int) our_pgrp,
@


1.32
log
@get rid of u_char, u_int, u_long
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.31 2007/10/25 14:18:56 tg Exp $");
d638 3
a640 1
		shprintf("%s%s", p->command, p->next ? "| " : null);
@


1.32.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.33 2008/04/01 21:50:58 tg Exp $");
d638 1
a638 3
		shf_puts(p->command, shl_stdout);
		if (p->next)
			shf_puts("| ", shl_stdout);
@


1.32.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.36 2008/05/17 19:03:25 tg Exp $");
d102 1
a102 1
static bool		ttypgrp_ok;	/* set if can use tty pgrps */
d104 1
d224 8
a231 1
		if ((ttypgrp_ok = use_tty && tty_fd >= 0 && tty_devtty)) {
d242 1
a242 1
					ttypgrp_ok = false;
d245 1
a245 1
				if (ttypgrp == kshpgrp)
d253 1
a253 1
		if (ttypgrp_ok && kshpgrp != kshpid) {
d258 1
a258 1
				ttypgrp_ok = false;
d264 1
a264 1
					ttypgrp_ok = false;
d266 2
a267 2
					restore_ttypgrp = kshpgrp;
				kshpgrp = kshpid;
d275 1
a275 1
		ttypgrp_ok = false;
d429 1
a429 1
		ttypgrp_ok = false;
d685 1
a685 1
			if (ttypgrp_ok && tcsetpgrp(tty_fd, kshpgrp) < 0)
d687 4
a690 2
				    "fg: 2nd tcsetpgrp(%d, %ld) failed: %s",
				    tty_fd, (long)kshpgrp, strerror(errno));
d951 1
a951 1
			if (tcsetpgrp(tty_fd, kshpgrp) < 0)
d953 4
a956 2
				    "j_waitj: tcsetpgrp(%d, %ld) failed: %s",
				    tty_fd, (long)kshpgrp, strerror(errno));
d1411 1
a1411 1
		newj = (Job *)alloc(sizeof (Job), APERM);
d1438 1
a1438 1
		p = (Proc *)alloc(sizeof (Proc), APERM);
@


1.32.2.3
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.42 2008/12/13 17:02:15 tg Exp $");
d123 1
a123 1
	(void)sigemptyset(&sm_default);
d126 1
a126 1
	(void)sigemptyset(&sm_sigchld);
d322 1
a322 2
		if (last_proc)
			last_proc->next = p;
a365 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
a367 1
#endif
a403 1
#if HAVE_NICE
d405 1
a405 2
			(void)nice(4);
#endif
d411 6
a416 4
			if ((!(flags & (XPIPEI | XCOPROC))) &&
			    ((i = open("/dev/null", 0)) > 0)) {
				(void)ksh_dup2(i, 0, true);
				close(i);
d1399 1
a1399 1
		newj = alloc(sizeof (Job), APERM);
d1426 1
a1426 1
		p = alloc(sizeof (Proc), APERM);
@


1.31
log
@only check for 64-bit integer types if needed (arc4random support)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.30 2007/10/25 13:51:18 tg Exp $");
d375 1
a375 1
	change_random(((u_long)p->pid << 1) | (ischild ? 1 : 0));
@


1.30
log
@• fix for the pipeline-as-coprocess problem
• bump to mksh R32
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.29 2007/10/25 13:27:00 tg Exp $");
d375 1
a375 1
	change_random((p->pid << 1) | (ischild ? 1 : 0));
@


1.29
log
@clean up
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.28 2007/09/09 19:12:10 tg Exp $");
d435 3
a438 1
#ifndef MKSH_SMALL
@


1.28
log
@shut up some gcc warn_unused_result thingies from Fedora
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.27 2007/09/09 18:06:41 tg Exp $");
d296 1
a296 2
exchild(struct op *t, int flags,
    int close_fd)	/* used if XPCLOSE or XCCLOSE */
@


1.27
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.26 2007/08/12 13:42:21 tg Exp $");
d414 1
a414 1
			nice(4);
@


1.26
log
@add “set -o arc4random”, RTFM for details
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.35 2006/02/06 16:47:07 jmc Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.25 2007/07/22 13:34:50 tg Exp $");
d217 2
d220 2
a221 1
		tty_init(false);
d224 1
a224 1
		ttypgrp_ok = tty_fd >= 0 && tty_devtty;
d270 1
a270 1
		if (!ttypgrp_ok)
@


1.25
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.24 2007/06/06 23:41:24 tg Exp $");
d372 3
a442 2
	/* Ensure next child gets a (slightly) different $RANDOM sequence */
	change_random();
@


1.24
log
@more errno cleanup
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.23 2007/06/06 23:28:15 tg Exp $");
d635 1
a635 1
	shprintf(newline);
d1286 1
a1286 1
				    (int)p->pid, space, p->command,
d1295 1
a1295 1
		shf_fprintf(shf, newline);
@


1.23
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.22 2007/05/13 17:51:22 tg Exp $");
d652 1
d661 1
a661 1
				    strerror(errno));
d672 1
a672 1
		int	err = errno;
@


1.22
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.21 2007/04/19 12:07:46 tg Exp $");
d52 1
a52 1
	int state;		/* job state */
d908 2
a909 2
	while ((volatile int) j->state == PRUNNING ||
	    ((flags & JW_STOPPEDWAIT) && (volatile int) j->state == PSTOPPED)) {
@


1.21
log
@if internal error, tell what failed
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.20 2007/03/10 18:16:27 tg Exp $");
d322 1
a322 1
	if (flags&XPIPEI) {	/* continuing with a pipe */
d324 1
a324 1
			internal_errorf(1,
d326 1
a326 1
			    (int) procpid);
d430 1
a430 1
		internal_errorf(0, "exchild: execute() returned");
d499 1
a499 1
			internal_errorf(0, "waitlast: not started");
d841 1
a841 1
		internal_errorf(0, "j_async: job not started");
d855 2
a856 2
				internal_errorf(0,
				    "j_async: bad nzombie (%d)", nzombie);
d1097 1
a1097 1
		internal_errorf(0, "check_job: job started (flags 0x%x)",
d1451 1
a1451 1
		internal_errorf(0, "remove_job: job not found (%s)", where);
@


1.21.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.21 2007/04/19 12:07:46 tg Exp $");
d322 1
a322 1
	if (flags & XPIPEI) {	/* continuing with a pipe */
d324 1
a324 1
			internal_errorf(
d326 1
a326 1
			    (int)procpid);
d430 1
a430 1
		internal_warningf("exchild: execute() returned");
d499 1
a499 1
			internal_warningf("waitlast: not started");
d841 1
a841 1
		internal_warningf("j_async: job not started");
d855 2
a856 2
				internal_warningf("j_async: bad nzombie (%d)",
				    nzombie);
d1097 1
a1097 1
		internal_warningf("check_job: job started (flags 0x%x)",
d1451 1
a1451 1
		internal_warningf("remove_job: job not found (%s)", where);
@


1.20
log
@some gcc 4.1.2pre warning shutup
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.19 2007/03/04 03:04:25 tg Exp $");
d431 4
@


1.19
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.18 2007/01/12 10:18:21 tg Exp $");
a85 3
/* user and system time of last j_waitjed job */
struct timeval j_systime, j_usrtime;

@


1.18
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.17 2007/01/12 01:49:28 tg Exp $");
d15 5
a19 5
	Proc	*next;		/* next process in pipeline (if any) */
	int	state;
	int	status;		/* wait status */
	pid_t	pid;		/* process id */
	char	command[48];	/* process command string */
d49 7
a55 7
	Job	*next;		/* next job in list */
	int	job;		/* job number: %n */
	int	flags;		/* see JF_* */
	int	state;		/* job state */
	int	status;		/* exit status of last process */
	pid_t	pgrp;		/* process group of job */
	pid_t	ppid;		/* pid of process that forked job */
d59 2
a60 2
	Proc	*proc_list;	/* process list */
	Proc	*last_proc;	/* last process in list */
d63 1
a63 1
	pid_t	saved_ttypgrp;	/* saved tty process group for stopped jobs */
d78 1
a78 1
static const char	*const lookup_msgs[] = {
d86 2
a87 1
struct timeval	j_systime, j_usrtime;	/* user and system time of last j_waitjed job */
d89 4
a92 4
static Job		*job_list;	/* job list */
static Job		*last_job;
static Job		*async_job;
static pid_t		async_pid;
d94 2
a95 2
static int		nzombie;	/* # of zombies owned by this process */
static int32_t		njobs;		/* # of jobs started */
@


1.17
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.16 2006/11/12 13:20:15 tg Exp $");
d122 1
a122 1
/* initialize job control */
@


1.16
log
@more warnings, cought on interix
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.15 2006/11/12 12:49:25 tg Exp $");
d1015 1
a1015 1
j_sigchld(int sig __attribute__((unused)))
@


1.15
log
@format string warnings, courtesy of Interix 3.5
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.14 2006/11/10 07:52:03 tg Exp $");
d452 2
a453 1
					shf_fprintf(shl_out, " %d", p->pid);
@


1.14
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.13 2006/11/10 04:03:59 tg Exp $");
d1205 2
a1206 2
		shf_fprintf(shf, "%d\n", j->pgrp ? j->pgrp :
		    (j->last_proc ? j->last_proc->pid : 0));
d1261 1
a1261 1
			shf_fprintf(shf, "%5d ", p->pid);
d1281 3
a1283 2
				shf_fprintf(shf, "%s%5d %-20s %s%s", filler, p->pid,
				    space, p->command, p->next ? "|" : null);
@


1.13
log
@thanks to the nice property of my reimplementation of getn to also
return a value in case of an error (0 or the partial result, which
is the full result in case of trailing junk even), using it to rid
atoi() is possible, saving 9t 4d 1i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.12 2006/11/09 22:08:07 tg Exp $");
d1304 1
a1304 1
	if (digit(*cp)) {
@


1.12
log
@simplify getconf and confstr stuff
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.11 2006/08/28 01:25:33 tg Exp $");
d1305 1
a1305 1
		job = atoi(cp);
d1339 1
a1339 1
		job = atoi(cp);
@


1.11
log
@revert the probably-problematic part of the Plan 9-derived MI diff
(can't commit it into plan9 branch at the same time, CVS _does_
handle committing to two different branches, but not twice the
same file)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.10 2006/08/24 20:32:53 tg Exp $");
a94 1
static int		child_max;	/* CHILD_MAX */
d96 3
a125 2
	child_max = sysconf(_SC_CHILD_MAX);

d843 1
a843 1
	while (nzombie > child_max) {
@


1.10
log
@merge non-Plan9-specific stuff from the branch, add KNF, etc.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.9 2006/08/01 13:43:27 tg Exp $");
a56 1
#ifdef RUSAGE_CHILDREN
a58 1
#endif
a85 1
#ifdef RUSAGE_CHILDREN
a86 1
#endif
a338 1
#ifdef RUSAGE_CHILDREN
a340 1
#endif
a991 1
#ifdef RUSAGE_CHILDREN
a993 1
#endif
a1020 1
#ifdef RUSAGE_CHILDREN
a1021 1
#endif
a1033 1
#ifdef RUSAGE_CHILDREN
a1034 1
#endif
a1040 1
#ifdef RUSAGE_CHILDREN
a1041 1
#endif
a1053 1
#ifdef RUSAGE_CHILDREN
a1054 1
#endif
a1057 1
#ifdef RUSAGE_CHILDREN
a1062 1
#endif
@


1.9
log
@style(9)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.8 2006/05/10 18:54:11 tg Exp $");
d57 1
d60 1
d88 1
d90 1
d343 1
d346 1
d998 1
d1001 1
d1029 1
d1031 1
d1044 1
d1046 1
d1053 1
d1055 1
d1068 1
d1070 1
d1074 1
d1080 1
d1254 1
d1257 1
@


1.9.2.1
log
@more rusage stuff not in Plan 9
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.9 2006/08/01 13:43:27 tg Exp $");
a56 1
#ifdef RUSAGE_CHILDREN
a58 1
#endif
a85 1
#ifdef RUSAGE_CHILDREN
a86 1
#endif
a338 1
#ifdef RUSAGE_CHILDREN
a340 1
#endif
a991 1
#ifdef RUSAGE_CHILDREN
a993 1
#endif
a1020 1
#ifdef RUSAGE_CHILDREN
a1021 1
#endif
a1033 1
#ifdef RUSAGE_CHILDREN
a1034 1
#endif
a1040 1
#ifdef RUSAGE_CHILDREN
a1041 1
#endif
a1053 1
#ifdef RUSAGE_CHILDREN
a1054 1
#endif
a1057 1
#ifdef RUSAGE_CHILDREN
a1062 1
#endif
@


1.9.2.2
log
@stuff not in Plan 9
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.9.2.1 2006/08/24 19:17:57 tg Exp $");
a1253 1
#ifdef WCOREDUMP
a1255 1
#endif
@


1.9.2.3
log
@no nice(3) either
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.9.2.2 2006/08/24 19:52:56 tg Exp $");
a414 1
#ifndef __Plan9__
a416 1
#endif
@


1.9.2.4
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.10 2006/08/24 20:32:53 tg Exp $");
@


1.9.2.5
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@a0 13
/*
 * Plan 9 portability issues
 *
 * Added many lines of the form
 * +#ifdef RUSAGE_CHILDREN
 * This is probably causing the shell to hang after
 * executing external commands (such as 'lc', 'ls')
 * while running a simple echo/print fine.
 *
 * tg@@ has stopped development on the plan9 branch,
 * but if someone wants to continue in that area...
 */

d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.11 2006/08/28 01:25:33 tg Exp $");
@


1.8
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.7 2006/01/30 12:37:23 tg Exp $");
d1048 1
a1048 1
found:
@


1.7
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d1 1
a1 1
/*	$OpenBSD: jobs.c,v 1.34 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.6 2005/11/22 18:40:42 tg Exp $");
d1411 1
a1411 1
/* Allocate new process strut
@


1.6
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.5 2005/10/25 19:53:28 tg Exp $");
d933 1
a933 1
			 * when it gets foregrounded by the parent shell, which
@


1.5
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/jobs.c,v 1.4 2005/08/21 12:43:55 bsiegert Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.4 2005/08/21 12:43:55 bsiegert Exp $");
@


1.4
log
@Move <sys/time.h> include to the top. Unbreaks mksh compilation on Darwin,
where <sys/resource.h> contains several struct timeval references, but this
struct is only defined in <sys/time.h>.

agreed tg@@
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/jobs.c,v 1.3 2005/07/04 12:27:26 tg Exp $ */
a4 4
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/wait.h>
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.3 2005/07/04 12:27:26 tg Exp $");
@


1.3
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/jobs.c,v 1.2 2005/05/23 16:23:19 tg Exp $ */
d5 1
a7 1
#include <sys/time.h>
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.2 2005/05/23 16:23:19 tg Exp $");
@


1.2
log
@aaaand: Interix.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/jobs.c,v 1.1 2005/05/23 03:06:08 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.1 2005/05/23 03:06:08 tg Exp $");
d1313 2
a1314 3
		/* ...then look for process group (this is non-POSIX),
		 * but should not break anything (so FPOSIX isn't used).
		 */
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/jobs.c,v 1.10 2005/05/23 02:20:36 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: mksh/jobs.c,v 1.10 2005/05/23 02:20:36 tg Exp $");
d129 1
a129 1
	child_max = CHILD_MAX; /* so syscon() isn't always being called */
@

