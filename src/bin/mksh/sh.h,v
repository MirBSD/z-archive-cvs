head	1.880;
access;
symbols
	mksh-R57:1.870
	mksh-R56c:1.858
	mksh-R56b:1.841
	mksh-R56:1.840
	mksh-R55:1.808
	mksh-R54:1.791
	mksh-R53a:1.786
	mksh-R53:1.785
	mksh-R52c:1.768
	mksh-R52b:1.757
	mksh-R52:1.751
	mksh-R51:1.739
	mksh-R50f:1.701.2.7
	mksh-R50e:1.701.2.4
	mksh-R50stable:1.701.0.2
	mksh-R50d:1.697
	mksh-R50c:1.695
	mksh-R50b:1.694
	mksh-R50:1.691
	mksh-R49:1.684
	mksh-R48b:1.668
	mksh-R48:1.667
	mksh-R47:1.661
	mksh-R46:1.654
	mksh-R45:1.651
	mksh-R44:1.642
	mksh-R43:1.639
	mksh-R42b:1.635
	mksh-R41c:1.608.2.10
	mksh-R41b:1.608.2.9
	mksh-R42:1.634.2.1
	mksh-R41:1.608.2.1
	mksh-R41stable:1.608.0.2
	mksh-wheezy:1.568.0.2
	tg-multikey-bind:1.559.0.2
	mksh-R40f:1.484.2.18
	mksh-R40e:1.484.2.16
	mksh-R40d:1.484.2.11
	mksh-R40c:1.484.2.8
	mksh-R40b:1.484.2.3
	mksh-R40stable:1.484.0.2
	mksh-R40:1.476
	mksh-R39c:1.383
	mksh-R39b:1.380
	tg-wcswidth-behaviour:1.362.0.2
	tg-nameref:1.336.0.2
	mksh-R39:1.321
	tg-mksh-printf-builtin:1.313.0.2
	mksh-R38c:1.310
	mksh-R38b:1.305
	mksh-R38:1.304
	mksh-R37c:1.293
	mksh-R37b:1.288
	mksh-R37:1.286
	mksh-R36b:1.267
	tg-aalloc-experimental_BASE:1.261.2.1
	tg-aalloc-experimental:1.261.0.2
	mksh-R36:1.245
	mksh-R35b:1.229
	mksh-R35:1.224
	mksh-R33d:1.204
	mksh-R33c:1.202
	mksh-R33b:1.199
	MIRBSD_10:1.195.0.2
	MIRBSD_10_BASE:1.195
	mksh-R33:1.192
	mksh-R32:1.184
	mksh-R31d:1.177
	mksh-R31c:1.175
	mksh-R31b:1.175
	mksh-R31:1.174
	mksh-R30:1.165
	mksh-R29g:1.127.2.4
	mksh-R29f:1.127.2.3
	mksh-R29e:1.127.2.2
	mksh-R29stable:1.127.0.2
	mksh-R29d:1.127
	mksh-R29c:1.124
	mksh-R29b:1.120
	mksh-R29:1.118
	mksh-R28:1.42
	tg-mksh-plan9ape_BASE:1.42
	tg-mksh-plan9ape:1.33.0.2
	mksh-R27e:1.27
	MIRBSD_9_BASE:1.27
	mksh-R27d:1.27
	mksh-R27:1.26
	mksh-R26c:1.24
	mksh-R26b:1.23
	MIRBSD_8:1.23.0.2
	MIRBSD_8_BASE:1.23
	mksh-R26:1.23
	mksh-R25:1.21
	mksh-R24c:1.17
	mksh-R24b:1.17
	mksh-R24:1.16
	mksh-R23:1.11
	mksh-R22:1.10
	mksh-R21:1.6;
locks; strict;
comment	@ * @;


1.880
date	2020.01.09.14.39.23;	author tg;	state Exp;
branches;
next	1.879;
commitid	1005E173B1E350FEBC1;

1.879
date	2020.01.04.00.04.56;	author tg;	state Exp;
branches;
next	1.878;
commitid	1005E0FD68675B16214;

1.878
date	2019.12.30.03.58.57;	author tg;	state Exp;
branches;
next	1.877;
commitid	1005E09760D6DFD4643;

1.877
date	2019.12.30.03.45.14;	author tg;	state Exp;
branches;
next	1.876;
commitid	1005E0972CA305775E7;

1.876
date	2019.12.11.23.58.20;	author tg;	state Exp;
branches;
next	1.875;
commitid	1005DF182AD50645981;

1.875
date	2019.12.11.17.59.17;	author tg;	state Exp;
branches;
next	1.874;
commitid	1005DF12E841B917499;

1.874
date	2019.12.11.17.56.57;	author tg;	state Exp;
branches;
next	1.873;
commitid	1005DF12DE60B2B4285;

1.873
date	2019.08.02.19.27.17;	author tg;	state Exp;
branches;
next	1.872;
commitid	1005D448E820CFAF8FF;

1.872
date	2019.08.01.23.59.51;	author tg;	state Exp;
branches;
next	1.871;
commitid	1005D437D0C19D901EA;

1.871
date	2019.04.24.20.56.31;	author tg;	state Exp;
branches;
next	1.870;
commitid	1005CC0CD7B2A3E9776;

1.870
date	2019.03.01.16.18.14;	author tg;	state Exp;
branches;
next	1.869;
commitid	1005C795B5E18CB9829;

1.869
date	2019.01.05.12.47.41;	author tg;	state Exp;
branches;
next	1.868;
commitid	1005C30A75304FC7434;

1.868
date	2018.12.04.21.13.47;	author tg;	state Exp;
branches;
next	1.867;
commitid	1005C06EDFD15FD4F82;

1.867
date	2018.10.30.17.10.16;	author tg;	state Exp;
branches;
next	1.866;
commitid	1005BD8907D11D25921;

1.866
date	2018.10.20.18.45.58;	author tg;	state Exp;
branches;
next	1.865;
commitid	1005BCB77EB7119802C;

1.865
date	2018.08.10.02.53.37;	author tg;	state Exp;
branches;
next	1.864;
commitid	1005B6CFE0B5BDFE404;

1.864
date	2018.07.15.17.21.23;	author tg;	state Exp;
branches;
next	1.863;
commitid	1005B4B82617DF9E3F8;

1.863
date	2018.06.26.21.22.24;	author tg;	state Exp;
branches;
next	1.862;
commitid	1005B32AE7D3C0B22EA;

1.862
date	2018.05.08.17.37.37;	author tg;	state Exp;
branches;
next	1.861;
commitid	1005AF1E0675260363E;

1.861
date	2018.05.07.00.07.21;	author tg;	state Exp;
branches;
next	1.860;
commitid	1005AEF98C1361833B5;

1.860
date	2018.04.28.07.07.37;	author tg;	state Exp;
branches;
next	1.859;
commitid	1005AE41DB710ED1782;

1.859
date	2018.03.09.01.29.11;	author tg;	state Exp;
branches;
next	1.858;
commitid	1005AA1E36666A5C695;

1.858
date	2018.01.14.01.47.36;	author tg;	state Exp;
branches;
next	1.857;
commitid	1005A5AB6B60E91308B;

1.857
date	2018.01.14.01.44.02;	author tg;	state Exp;
branches;
next	1.856;
commitid	1005A5AB5F87C24D8D1;

1.856
date	2018.01.14.01.28.15;	author tg;	state Exp;
branches;
next	1.855;
commitid	1005A5AB24160ED8F7B;

1.855
date	2018.01.14.00.47.11;	author tg;	state Exp;
branches;
next	1.854;
commitid	1005A5AA89F68453C8D;

1.854
date	2018.01.14.00.22.29;	author tg;	state Exp;
branches;
next	1.853;
commitid	1005A5AA2D643C73A14;

1.853
date	2018.01.14.00.09.34;	author tg;	state Exp;
branches;
next	1.852;
commitid	1005A5A9FCA4F7704AE;

1.852
date	2018.01.14.00.03.03;	author tg;	state Exp;
branches;
next	1.851;
commitid	1005A5A9E3D208A81CB;

1.851
date	2018.01.13.23.55.13;	author tg;	state Exp;
branches;
next	1.850;
commitid	1005A5A9C627E45C2B1;

1.850
date	2018.01.13.21.38.09;	author tg;	state Exp;
branches;
next	1.849;
commitid	1005A5A7C0944B414C1;

1.849
date	2017.10.17.23.45.19;	author tg;	state Exp;
branches;
next	1.848;
commitid	10059E695CD2C830620;

1.848
date	2017.10.14.21.09.48;	author tg;	state Exp;
branches;
next	1.847;
commitid	10059E27D1D2A22ED17;

1.847
date	2017.10.11.23.23.03;	author tg;	state Exp;
branches;
next	1.846;
commitid	10059DEA793272A5286;

1.846
date	2017.10.11.21.52.46;	author tg;	state Exp;
branches;
next	1.845;
commitid	10059DE92A640EDACB0;

1.845
date	2017.10.11.21.09.24;	author tg;	state Exp;
branches;
next	1.844;
commitid	10059DE887042D9CAC0;

1.844
date	2017.10.11.20.55.06;	author tg;	state Exp;
branches;
next	1.843;
commitid	10059DE8531478700F9;

1.843
date	2017.10.11.20.50.46;	author tg;	state Exp;
branches;
next	1.842;
commitid	10059DE841C279F0931;

1.842
date	2017.10.11.20.29.05;	author tg;	state Exp;
branches;
next	1.841;
commitid	10059DE7F2426ED71F4;

1.841
date	2017.08.29.13.38.31;	author tg;	state Exp;
branches;
next	1.840;
commitid	10059A56E5C5EA2D5AB;

1.840
date	2017.08.08.21.11.20;	author tg;	state Exp;
branches;
next	1.839;
commitid	100598A290E2AFE53F2;

1.839
date	2017.08.07.21.56.54;	author tg;	state Exp;
branches;
next	1.838;
commitid	1005988E24067D50B93;

1.838
date	2017.08.07.21.39.26;	author tg;	state Exp;
branches;
next	1.837;
commitid	1005988DE2644315248;

1.837
date	2017.07.26.23.02.27;	author tg;	state Exp;
branches;
next	1.836;
commitid	10059791F906168237F;

1.836
date	2017.05.05.22.53.30;	author tg;	state Exp;
branches;
next	1.835;
commitid	100590D026845CD3DFF;

1.835
date	2017.05.01.19.44.16;	author tg;	state Exp;
branches;
next	1.834;
commitid	1005907902A5478AD0E;

1.834
date	2017.04.29.22.04.30;	author tg;	state Exp;
branches;
next	1.833;
commitid	10059050DFF02CF9B3E;

1.833
date	2017.04.29.21.49.07;	author tg;	state Exp;
branches;
next	1.832;
commitid	10059050A1F555381AA;

1.832
date	2017.04.29.14.20.24;	author tg;	state Exp;
branches;
next	1.831;
commitid	1005904A1366B51E1F2;

1.831
date	2017.04.28.12.02.41;	author tg;	state Exp;
branches;
next	1.830;
commitid	10059032F6F6823D78E;

1.830
date	2017.04.28.11.51.40;	author tg;	state Exp;
branches;
next	1.829;
commitid	10059032CD84B8163BC;

1.829
date	2017.04.28.11.31.51;	author tg;	state Exp;
branches;
next	1.828;
commitid	1005903282B43B4C47B;

1.828
date	2017.04.28.11.13.48;	author tg;	state Exp;
branches;
next	1.827;
commitid	100590323E86CD0E167;

1.827
date	2017.04.28.03.51.13;	author tg;	state Exp;
branches;
next	1.826;
commitid	1005902BC4656E69578;

1.826
date	2017.04.28.03.46.50;	author tg;	state Exp;
branches;
next	1.825;
commitid	1005902BB2B4D4574E0;

1.825
date	2017.04.28.03.28.18;	author tg;	state Exp;
branches;
next	1.824;
commitid	1005902B6DC3ECE3910;

1.824
date	2017.04.28.02.40.25;	author tg;	state Exp;
branches;
next	1.823;
commitid	1005902ABA9399AA66E;

1.823
date	2017.04.28.02.24.58;	author tg;	state Exp;
branches;
next	1.822;
commitid	1005902A8007F54B819;

1.822
date	2017.04.28.01.15.51;	author tg;	state Exp;
branches;
next	1.821;
commitid	1005902978D70FC7074;

1.821
date	2017.04.28.00.49.33;	author tg;	state Exp;
branches;
next	1.820;
commitid	100590291AF6848CD3A;

1.820
date	2017.04.28.00.38.32;	author tg;	state Exp;
branches;
next	1.819;
commitid	10059028F0E0808B3E9;

1.819
date	2017.04.27.23.33.20;	author tg;	state Exp;
branches;
next	1.818;
commitid	10059027FC444EF0ED1;

1.818
date	2017.04.27.23.12.48;	author tg;	state Exp;
branches;
next	1.817;
commitid	10059027AFC0DEF48C9;

1.817
date	2017.04.27.20.22.27;	author tg;	state Exp;
branches;
next	1.816;
commitid	1005902531266D3FCB6;

1.816
date	2017.04.27.19.19.05;	author tg;	state Exp;
branches;
next	1.815;
commitid	100590244350CC84112;

1.815
date	2017.04.27.19.16.09;	author tg;	state Exp;
branches;
next	1.814;
commitid	1005902438A577EF826;

1.814
date	2017.04.22.00.07.09;	author tg;	state Exp;
branches;
next	1.813;
commitid	10058FA9D043131DCC0;

1.813
date	2017.04.21.20.06.06;	author tg;	state Exp;
branches;
next	1.812;
commitid	10058FA66392543430F;

1.812
date	2017.04.21.19.50.09;	author tg;	state Exp;
branches;
next	1.811;
commitid	10058FA61D94E9BD833;

1.811
date	2017.04.20.20.50.14;	author tg;	state Exp;
branches;
next	1.810;
commitid	10058F91F0E764A8514;

1.810
date	2017.04.20.16.50.48;	author tg;	state Exp;
branches;
next	1.809;
commitid	10058F8E6FE6C65D02B;

1.809
date	2017.04.17.19.51.47;	author tg;	state Exp;
branches;
next	1.808;
commitid	10058F51CD7435931DA;

1.808
date	2017.04.12.17.38.46;	author tg;	state Exp;
branches;
next	1.807;
commitid	10058EE65E065F6F62F;

1.807
date	2017.04.08.01.07.18;	author tg;	state Exp;
branches;
next	1.806;
commitid	10058E837C565871E52;

1.806
date	2017.04.06.19.02.07;	author tg;	state Exp;
branches;
next	1.805;
commitid	10058E690B12E36D308;

1.805
date	2017.04.06.01.59.56;	author tg;	state Exp;
branches;
next	1.804;
commitid	10058E5A1067AFA1BBA;

1.804
date	2017.04.06.00.53.35;	author tg;	state Exp;
branches;
next	1.803;
commitid	10058E5919F0E16D269;

1.803
date	2017.04.06.00.41.42;	author tg;	state Exp;
branches;
next	1.802;
commitid	10058E58ECF695338FA;

1.802
date	2017.04.02.16.47.42;	author tg;	state Exp;
branches;
next	1.801;
commitid	10058E12B3D7E04D5CE;

1.801
date	2017.04.02.15.00.44;	author tg;	state Exp;
branches;
next	1.800;
commitid	10058E1121E64BBAB7B;

1.800
date	2017.04.02.14.14.08;	author tg;	state Exp;
branches;
next	1.799;
commitid	10058E106EA70D8ABF7;

1.799
date	2017.04.02.13.08.07;	author tg;	state Exp;
branches;
next	1.798;
commitid	10058E0F79F196EC7B8;

1.798
date	2017.03.26.00.10.25;	author tg;	state Exp;
branches;
next	1.797;
commitid	10058D706207E0A1FF4;

1.797
date	2017.03.22.00.20.53;	author tg;	state Exp;
branches;
next	1.796;
commitid	10058D1C37D4ECF5C13;

1.796
date	2017.03.19.22.31.29;	author tg;	state Exp;
branches;
next	1.795;
commitid	10058CF06C37397F386;

1.795
date	2017.03.17.22.45.53;	author tg;	state Exp;
branches;
next	1.794;
commitid	10058CC671F1DF58730;

1.794
date	2017.03.12.02.04.14;	author tg;	state Exp;
branches;
next	1.793;
commitid	10058C4AC2520F8C875;

1.793
date	2017.02.18.02.33.14;	author tg;	state Exp;
branches;
next	1.792;
commitid	10058A7B271530B4CED;

1.792
date	2017.02.17.22.40.13;	author tg;	state Exp;
branches;
next	1.791;
commitid	10058A77BD32DFE626F;

1.791
date	2016.11.11.23.31.38;	author tg;	state Exp;
branches;
next	1.790;
commitid	100582654B972655F84;

1.790
date	2016.11.07.16.58.48;	author tg;	state Exp;
branches;
next	1.789;
commitid	1005820B2DD17077C51;

1.789
date	2016.10.02.22.21.47;	author tg;	state Exp;
branches;
next	1.788;
commitid	10057F1888F65CBF445;

1.788
date	2016.09.01.12.59.11;	author tg;	state Exp;
branches;
next	1.787;
commitid	10057C8260A04757349;

1.787
date	2016.08.25.16.21.34;	author tg;	state Exp;
branches;
next	1.786;
commitid	10057BF1B1D101BE102;

1.786
date	2016.08.12.16.48.05;	author tg;	state Exp;
branches;
next	1.785;
commitid	10057ADFDDA517E115F;

1.785
date	2016.08.10.18.20.18;	author tg;	state Exp;
branches;
next	1.784;
commitid	10057AB70790ACA1487;

1.784
date	2016.08.04.20.51.35;	author tg;	state Exp;
branches;
next	1.783;
commitid	10057A3AAA90034EF8B;

1.783
date	2016.08.01.21.38.05;	author tg;	state Exp;
branches;
next	1.782;
commitid	100579FC12F14735847;

1.782
date	2016.08.01.20.23.15;	author tg;	state Exp;
branches;
next	1.781;
commitid	100579FAFC1354AAAE0;

1.781
date	2016.07.28.21.39.19;	author tg;	state Exp;
branches;
next	1.780;
commitid	100579A7B9C449E55CC;

1.780
date	2016.07.26.21.50.46;	author tg;	state Exp;
branches;
next	1.779;
commitid	1005797DB49584A72A4;

1.779
date	2016.07.25.21.05.24;	author tg;	state Exp;
branches;
next	1.778;
commitid	10057967F184AB0E82A;

1.778
date	2016.07.25.20.43.53;	author tg;	state Exp;
branches;
next	1.777;
commitid	10057967A0D0C01C9C9;

1.777
date	2016.07.25.00.04.46;	author tg;	state Exp;
branches;
next	1.776;
commitid	1005795579F14A3FE5C;

1.776
date	2016.07.24.23.10.04;	author tg;	state Exp;
branches;
next	1.775;
commitid	10057954AD0356E0260;

1.775
date	2016.07.12.23.07.10;	author tg;	state Exp;
branches;
next	1.774;
commitid	100578578165D391F66;

1.774
date	2016.06.26.00.44.59;	author tg;	state Exp;
branches;
next	1.773;
commitid	100576F259765932F2C;

1.773
date	2016.06.25.23.49.50;	author tg;	state Exp;
branches;
next	1.772;
commitid	100576F18B22396E4DA;

1.772
date	2016.05.17.15.36.34;	author tg;	state Exp;
branches;
next	1.771;
commitid	100573B39F5517EBA22;

1.771
date	2016.05.05.22.56.14;	author tg;	state Exp;
branches;
next	1.770;
commitid	100572BCF9760C8313C;

1.770
date	2016.04.14.15.38.38;	author tg;	state Exp;
branches;
next	1.769;
commitid	100570FB99421ECAE64;

1.769
date	2016.04.09.13.55.12;	author tg;	state Exp;
branches;
next	1.768;
commitid	100570909A43DABCFC0;

1.768
date	2016.03.04.18.28.42;	author tg;	state Exp;
branches;
next	1.767;
commitid	10056D9D3E84E42085B;

1.767
date	2016.03.04.14.26.14;	author tg;	state Exp;
branches;
next	1.766;
commitid	10056D99B037D4D691D;

1.766
date	2016.03.01.18.30.05;	author tg;	state Exp;
branches;
next	1.765;
commitid	10056D5DFC11D3566D1;

1.765
date	2016.02.26.21.53.37;	author tg;	state Exp;
branches;
next	1.764;
commitid	10056D0C89E7DCB5486;

1.764
date	2016.02.26.20.56.45;	author tg;	state Exp;
branches;
next	1.763;
commitid	10056D0BC0C02AF3EE5;

1.763
date	2016.02.26.18.48.13;	author tg;	state Exp;
branches;
next	1.762;
commitid	10056D09DEF7B46FCA2;

1.762
date	2016.02.24.02.08.39;	author tg;	state Exp;
branches;
next	1.761;
commitid	10056CD10B37F67B062;

1.761
date	2016.02.24.01.44.46;	author tg;	state Exp;
branches;
next	1.760;
commitid	10056CD0AFA12B0CBA5;

1.760
date	2016.01.21.19.58.13;	author tg;	state Exp;
branches;
next	1.759;
commitid	10056A1386A782C7EAC;

1.759
date	2016.01.21.19.38.09;	author tg;	state Exp;
branches;
next	1.758;
commitid	10056A133B56DE0B572;

1.758
date	2016.01.21.18.24.43;	author tg;	state Exp;
branches;
next	1.757;
commitid	10056A12268001BF859;

1.757
date	2016.01.20.21.34.13;	author tg;	state Exp;
branches;
next	1.756;
commitid	100569FFD594609A81E;

1.756
date	2016.01.19.23.12.14;	author tg;	state Exp;
branches;
next	1.755;
commitid	100569EC2AE617A4288;

1.755
date	2016.01.14.23.18.11;	author tg;	state Exp;
branches;
next	1.754;
commitid	10056982CC2089C928B;

1.754
date	2016.01.14.22.49.32;	author tg;	state Exp;
branches;
next	1.753;
commitid	100569825E73343E900;

1.753
date	2016.01.13.17.20.52;	author tg;	state Exp;
branches;
next	1.752;
commitid	1005696877B782808CD;

1.752
date	2015.12.31.21.03.47;	author tg;	state Exp;
branches;
next	1.751;
commitid	100568598191D3EFE4F;

1.751
date	2015.12.12.22.25.15;	author tg;	state Exp;
branches;
next	1.750;
commitid	100566C9EDD3DC6C239;

1.750
date	2015.10.24.19.45.23;	author tg;	state Exp;
branches;
next	1.749;
commitid	100562BDFBA097EA04B;

1.749
date	2015.10.09.21.36.59;	author tg;	state Exp;
branches;
next	1.748;
commitid	100561833456A230F8F;

1.748
date	2015.10.09.19.29.49;	author tg;	state Exp;
branches;
next	1.747;
commitid	100561815B853CF84EB;

1.747
date	2015.10.09.17.48.52;	author tg;	state Exp;
branches;
next	1.746;
commitid	1005617FE066005352E;

1.746
date	2015.10.09.16.11.18;	author tg;	state Exp;
branches;
next	1.745;
commitid	1005617E72E4A2BA371;

1.745
date	2015.10.05.17.59.00;	author tg;	state Exp;
branches;
next	1.744;
commitid	1005612BA62412FC278;

1.744
date	2015.09.06.19.47.00;	author tg;	state Exp;
branches;
next	1.743;
commitid	10055EC98215F2B5F9C;

1.743
date	2015.09.05.20.20.46;	author tg;	state Exp;
branches;
next	1.742;
commitid	10055EB4EA5242ECCAA;

1.742
date	2015.09.05.19.19.10;	author tg;	state Exp;
branches;
next	1.741;
commitid	10055EB402C54C3076B;

1.741
date	2015.08.13.22.06.23;	author tg;	state Exp;
branches;
next	1.740;
commitid	10055CD14E772441249;

1.740
date	2015.08.13.21.38.19;	author tg;	state Exp;
branches;
next	1.739;
commitid	10055CD0E35383B51C9;

1.739
date	2015.07.10.19.36.37;	author tg;	state Exp;
branches;
next	1.738;
commitid	10055A01EBD784EE31A;

1.738
date	2015.07.09.20.52.42;	author tg;	state Exp;
branches;
next	1.737;
commitid	100559EDF161DEE9DD2;

1.737
date	2015.07.09.20.20.45;	author tg;	state Exp;
branches;
next	1.736;
commitid	100559ED7A80A374D9C;

1.736
date	2015.07.09.19.46.43;	author tg;	state Exp;
branches;
next	1.735;
commitid	100559ECFAC4F39D69B;

1.735
date	2015.07.09.19.28.21;	author tg;	state Exp;
branches;
next	1.734;
commitid	100559ECB63048E9D39;

1.734
date	2015.07.06.17.48.37;	author tg;	state Exp;
branches;
next	1.733;
commitid	100559ABF230C8CC8EB;

1.733
date	2015.07.05.19.37.18;	author tg;	state Exp;
branches;
next	1.732;
commitid	1005599876B5247136B;

1.732
date	2015.07.05.14.43.08;	author tg;	state Exp;
branches;
next	1.731;
commitid	100559942841CED5205;

1.731
date	2015.06.28.16.23.24;	author tg;	state Exp;
branches;
next	1.730;
commitid	10055901F85432BD4FC;

1.730
date	2015.05.23.17.43.22;	author tg;	state Exp;
branches;
next	1.729;
commitid	1005560BBB87BB0247C;

1.729
date	2015.04.29.20.44.37;	author tg;	state Exp;
branches;
next	1.728;
commitid	100554142C5624212CA;

1.728
date	2015.04.29.20.07.34;	author tg;	state Exp;
branches;
next	1.727;
commitid	100554139453DB97755;

1.727
date	2015.04.29.19.11.57;	author tg;	state Exp;
branches;
next	1.726;
commitid	10055412CFF40F046F9;

1.726
date	2015.04.29.18.38.54;	author tg;	state Exp;
branches;
next	1.725;
commitid	100554125524190E2D8;

1.725
date	2015.04.19.19.18.07;	author tg;	state Exp;
branches;
next	1.724;
commitid	1005533FF4D64965277;

1.724
date	2015.04.19.18.50.37;	author tg;	state Exp;
branches;
next	1.723;
commitid	1005533F8D6407346B7;

1.723
date	2015.04.11.23.28.21;	author tg;	state Exp;
branches;
next	1.722;
commitid	1005529AD8D33CF99B9;

1.722
date	2015.04.11.22.03.31;	author tg;	state Exp;
branches;
next	1.721;
commitid	1005529999F77F915AE;

1.721
date	2015.03.20.23.37.55;	author tg;	state Exp;
branches;
next	1.720;
commitid	100550CAF6732AE1EA7;

1.720
date	2015.03.20.21.46.41;	author tg;	state Exp;
branches;
next	1.719;
commitid	100550C95382C9C0F05;

1.719
date	2015.03.14.05.23.17;	author tg;	state Exp;
branches;
next	1.718;
commitid	1005503C5CA29059CD3;

1.718
date	2015.03.14.04.37.54;	author tg;	state Exp;
branches;
next	1.717;
commitid	1005503BB3A05FBF858;

1.717
date	2015.03.08.22.54.35;	author tg;	state Exp;
branches;
next	1.716;
commitid	10054FCD1444FC13F3C;

1.716
date	2015.03.08.21.30.22;	author tg;	state Exp;
branches;
next	1.715;
commitid	10054FCBF786B35A495;

1.715
date	2015.03.07.20.46.30;	author tg;	state Exp;
branches;
next	1.714;
commitid	10054FB63890799A9FA;

1.714
date	2015.03.01.15.23.05;	author tg;	state Exp;
branches;
next	1.713;
commitid	10054F32EE078DD628C;

1.713
date	2015.02.20.07.14.30;	author tg;	state Exp;
branches;
next	1.712;
commitid	10054E6DEC961F3FFC5;

1.712
date	2015.02.19.22.26.50;	author tg;	state Exp;
branches;
next	1.711;
commitid	10054E6631B44A55260;

1.711
date	2015.02.13.12.51.33;	author tg;	state Exp;
branches;
next	1.710;
commitid	10054DDF3221517B878;

1.710
date	2015.02.06.10.56.48;	author tg;	state Exp;
branches;
next	1.709;
commitid	10054D49DF4344D0AFC;

1.709
date	2015.01.25.15.23.43;	author tg;	state Exp;
branches;
next	1.708;
commitid	10054C50A720861330B;

1.708
date	2015.01.04.21.08.10;	author tg;	state Exp;
branches;
next	1.707;
commitid	10054A9ABCF7F3049A5;

1.707
date	2015.01.02.13.21.28;	author tg;	state Exp;
branches;
next	1.706;
commitid	10054A69B5C737AE4A2;

1.706
date	2014.12.15.22.50.11;	author tg;	state Exp;
branches;
next	1.705;
commitid	100548F65AB2DD01C69;

1.705
date	2014.11.25.21.13.29;	author tg;	state Exp;
branches;
next	1.704;
commitid	1005474F00E09321C83;

1.704
date	2014.11.19.21.49.12;	author tg;	state Exp;
branches;
next	1.703;
commitid	100546D105E468BE66D;

1.703
date	2014.11.19.18.44.11;	author tg;	state Exp;
branches;
next	1.702;
commitid	100546CE4F2089B6886;

1.702
date	2014.11.14.20.21.29;	author tg;	state Exp;
branches;
next	1.701;
commitid	1005466644F12462973;

1.701
date	2014.10.19.21.53.08;	author tg;	state Exp;
branches
	1.701.2.1;
next	1.700;
commitid	100544432BD7CEA2F06;

1.700
date	2014.10.19.20.56.33;	author tg;	state Exp;
branches;
next	1.699;
commitid	1005444249972F13F37;

1.699
date	2014.10.12.21.58.53;	author tg;	state Exp;
branches;
next	1.698;
commitid	100543AF9780895A8EB;

1.698
date	2014.10.12.19.55.01;	author tg;	state Exp;
branches;
next	1.697;
commitid	100543ADCA73754295B;

1.697
date	2014.10.07.15.22.17;	author tg;	state Exp;
branches;
next	1.696;
commitid	1005434053135366996;

1.696
date	2014.10.04.11.47.18;	author tg;	state Exp;
branches;
next	1.695;
commitid	100542FDE4766613707;

1.695
date	2014.10.03.17.32.12;	author tg;	state Exp;
branches;
next	1.694;
commitid	100542EDD596FD5FBF9;

1.694
date	2014.09.03.19.22.50;	author tg;	state Exp;
branches;
next	1.693;
commitid	10054076A8136C0C0D1;

1.693
date	2014.07.28.21.45.45;	author tg;	state Exp;
branches;
next	1.692;
commitid	10053D6C428265C691A;

1.692
date	2014.07.13.11.34.29;	author tg;	state Exp;
branches;
next	1.691;
commitid	10053C26EB832BD6A2E;

1.691
date	2014.06.29.11.28.28;	author tg;	state Exp;
branches;
next	1.690;
commitid	10053AFF8604CE197F5;

1.690
date	2014.06.24.20.47.47;	author tg;	state Exp;
branches;
next	1.689;
commitid	10053A9E3FD4EC55000;

1.689
date	2014.06.24.18.51.37;	author tg;	state Exp;
branches;
next	1.688;
commitid	10053A9C8D1555162F7;

1.688
date	2014.06.10.22.17.10;	author tg;	state Exp;
branches;
next	1.687;
commitid	100539783DC1BABB2C6;

1.687
date	2014.06.09.13.25.53;	author tg;	state Exp;
branches;
next	1.686;
commitid	1005395B5803902C8E9;

1.686
date	2014.05.27.13.22.45;	author tg;	state Exp;
branches;
next	1.685;
commitid	1005384911C31753F0C;

1.685
date	2014.01.22.19.53.52;	author tg;	state Exp;
branches;
next	1.684;
commitid	10052E021E52FD0AF33;

1.684
date	2014.01.11.18.09.42;	author tg;	state Exp;
branches;
next	1.683;
commitid	10052D188DD7DFEC194;

1.683
date	2014.01.11.16.26.28;	author tg;	state Exp;
branches;
next	1.682;
commitid	10052D170CC442C6ECB;

1.682
date	2014.01.05.21.57.28;	author tg;	state Exp;
branches;
next	1.681;
commitid	10052C9D445413B34DF;

1.681
date	2014.01.05.19.14.17;	author tg;	state Exp;
branches;
next	1.680;
commitid	10052C9AF1F443DA345;

1.680
date	2013.11.30.23.20.04;	author tg;	state Exp;
branches;
next	1.679;
commitid	100529A72B0084FADD6;

1.679
date	2013.11.30.17.41.35;	author tg;	state Exp;
branches;
next	1.678;
commitid	100529A23520014334E;

1.678
date	2013.11.30.17.33.51;	author tg;	state Exp;
branches;
next	1.677;
commitid	100529A2193602D314C;

1.677
date	2013.11.30.00.20.48;	author tg;	state Exp;
branches;
next	1.676;
commitid	10052992F754802C9BE;

1.676
date	2013.11.17.22.28.51;	author tg;	state Exp;
branches;
next	1.675;
commitid	1005289433447F6CA90;

1.675
date	2013.11.17.22.23.29;	author tg;	state Exp;
branches;
next	1.674;
commitid	100528941F42B4F3BA7;

1.674
date	2013.11.17.22.22.54;	author tg;	state Exp;
branches;
next	1.673;
commitid	100528941C810C8A893;

1.673
date	2013.10.31.20.05.39;	author tg;	state Exp;
branches;
next	1.672;
commitid	1005272B7081B0E5655;

1.672
date	2013.10.09.11.59.29;	author tg;	state Exp;
branches;
next	1.671;
commitid	10052554535524C4C97;

1.671
date	2013.09.24.20.19.44;	author tg;	state Exp;
branches;
next	1.670;
commitid	1005241F37044BDFFC4;

1.670
date	2013.09.10.17.33.04;	author tg;	state Exp;
branches;
next	1.669;
commitid	100522F57C13E265FDE;

1.669
date	2013.08.23.14.07.39;	author tg;	state Exp;
branches;
next	1.668;
commitid	10052176CB912FE954B;

1.668
date	2013.08.16.10.59.03;	author tg;	state Exp;
branches;
next	1.667;
commitid	100520E05EA33BA2E83;

1.667
date	2013.08.14.20.26.19;	author tg;	state Exp;
branches;
next	1.666;
commitid	100520BE7CE316FF2FE;

1.666
date	2013.08.11.14.57.10;	author tg;	state Exp;
branches;
next	1.665;
commitid	1005207A65963070688;

1.665
date	2013.08.10.13.47.18;	author tg;	state Exp;
branches;
next	1.664;
commitid	100520644762FA2353A;

1.664
date	2013.08.10.13.44.33;	author tg;	state Exp;
branches;
next	1.663;
commitid	100520643B4127D9BCA;

1.663
date	2013.07.26.20.33.39;	author tg;	state Exp;
branches;
next	1.662;
commitid	10051F2DD36363A1B44;

1.662
date	2013.07.25.18.07.47;	author tg;	state Exp;
branches;
next	1.661;
commitid	10051F1695C46761A92;

1.661
date	2013.07.24.18.03.57;	author tg;	state Exp;
branches;
next	1.660;
commitid	10051F017226117F784;

1.660
date	2013.07.21.18.47.22;	author tg;	state Exp;
branches;
next	1.659;
commitid	10051EC2CBD68BDF6A5;

1.659
date	2013.06.03.22.28.33;	author tg;	state Exp;
branches;
next	1.658;
commitid	10051AD18A44752B56B;

1.658
date	2013.06.02.03.09.17;	author tg;	state Exp;
branches;
next	1.657;
commitid	10051AAB6AE4E828507;

1.657
date	2013.06.01.00.15.58;	author tg;	state Exp;
branches;
next	1.656;
commitid	10051A93D525FED429B;

1.656
date	2013.05.31.23.27.14;	author tg;	state Exp;
branches;
next	1.655;
commitid	10051A931CB73794C1D;

1.655
date	2013.05.08.11.16.19;	author tg;	state Exp;
branches;
next	1.654;
commitid	100518A34193FAA8C4B;

1.654
date	2013.05.02.21.59.52;	author tg;	state Exp;
branches;
next	1.653;
commitid	1005182E1E55272FF6B;

1.653
date	2013.04.27.19.16.27;	author tg;	state Exp;
branches;
next	1.652;
commitid	100517C240B5F21EA3E;

1.652
date	2013.04.27.18.12.39;	author tg;	state Exp;
branches;
next	1.651;
commitid	100517C152C6C287552;

1.651
date	2013.04.26.21.22.49;	author tg;	state Exp;
branches;
next	1.650;
commitid	100517AEF6C22DD1AE7;

1.650
date	2013.04.26.19.40.45;	author tg;	state Exp;
branches;
next	1.649;
commitid	100517AD85106670209;

1.649
date	2013.04.26.18.27.06;	author tg;	state Exp;
branches;
next	1.648;
commitid	100517AC7121FEA6081;

1.648
date	2013.04.26.17.23.15;	author tg;	state Exp;
branches;
next	1.647;
commitid	100517AB80A29723F02;

1.647
date	2013.04.01.02.37.51;	author tg;	state Exp;
branches;
next	1.646;
commitid	1005158F2D44922CF13;

1.646
date	2013.03.30.23.31.04;	author tg;	state Exp;
branches;
next	1.645;
commitid	100515775CB57F0EB86;

1.645
date	2013.03.29.17.33.56;	author tg;	state Exp;
branches;
next	1.644;
commitid	1005155D0985F77FD2A;

1.644
date	2013.03.24.15.01.50;	author tg;	state Exp;
branches;
next	1.643;
commitid	100514F15711E9EFAB7;

1.643
date	2013.03.24.00.56.25;	author tg;	state Exp;
branches;
next	1.642;
commitid	100514E4F1D5C90862C;

1.642
date	2013.03.05.15.41.41;	author tg;	state Exp;
branches;
next	1.641;
commitid	1005136124A171442C9;

1.641
date	2013.02.24.14.22.44;	author tg;	state Exp;
branches;
next	1.640;
commitid	100512A22416D5A6B55;

1.640
date	2013.02.23.20.03.31;	author tg;	state Exp;
branches;
next	1.639;
commitid	1005129208E57646522;

1.639
date	2013.02.19.18.45.22;	author tg;	state Exp;
branches;
next	1.638;
commitid	1005123C815760131DF;

1.638
date	2013.02.18.22.55.40;	author tg;	state Exp;
branches;
next	1.637;
commitid	1005122B16E6B48945B;

1.637
date	2013.02.17.05.40.17;	author tg;	state Exp;
branches;
next	1.636;
commitid	10051206D50560C037D;

1.636
date	2013.02.16.00.21.57;	author tg;	state Exp;
branches;
next	1.635;
commitid	100511ED11C146CFC01;

1.635
date	2013.02.15.18.50.14;	author tg;	state Exp;
branches;
next	1.634;
commitid	100511E837A3084211A;

1.634
date	2013.02.10.23.59.28;	author tg;	state Exp;
branches
	1.634.2.1;
next	1.633;
commitid	100511834521EDC159D;

1.633
date	2013.02.10.21.17.07;	author tg;	state Exp;
branches;
next	1.632;
commitid	10051180E6A57FFC1F3;

1.632
date	2013.02.10.17.41.06;	author tg;	state Exp;
branches;
next	1.631;
commitid	1005117DBC709D0BEB4;

1.631
date	2013.02.10.17.39.38;	author tg;	state Exp;
branches;
next	1.630;
commitid	1005117DB705AA69563;

1.630
date	2013.02.10.17.38.15;	author tg;	state Exp;
branches;
next	1.629;
commitid	1005117DB0F3E1A98CE;

1.629
date	2013.02.10.17.18.49;	author tg;	state Exp;
branches;
next	1.628;
commitid	1005117D6794EBEDD21;

1.628
date	2013.01.19.19.47.13;	author tg;	state Exp;
branches;
next	1.627;
commitid	10050FAF850424A45DD;

1.627
date	2013.01.06.18.51.43;	author tg;	state Exp;
branches;
next	1.626;
commitid	10050E9C7D31AD0F470;

1.626
date	2013.01.01.20.45.04;	author tg;	state Exp;
branches;
next	1.625;
commitid	10050E34AE3215C257E;

1.625
date	2013.01.01.03.32.43;	author tg;	state Exp;
branches;
next	1.624;
commitid	10050E258F01BA8A38D;

1.624
date	2012.12.28.04.47.50;	author tg;	state Exp;
branches;
next	1.623;
commitid	10050DD248259F0BD48;

1.623
date	2012.12.28.03.35.34;	author tg;	state Exp;
branches;
next	1.622;
commitid	10050DD139C31612F17;

1.622
date	2012.12.28.02.28.37;	author tg;	state Exp;
branches;
next	1.621;
commitid	10050DD03E43C678B81;

1.621
date	2012.12.22.22.15.21;	author tg;	state Exp;
branches;
next	1.620;
commitid	10050D6310375B6971C;

1.620
date	2012.12.22.00.03.42;	author tg;	state Exp;
branches;
next	1.619;
commitid	10050D4F8C95001AF1D;

1.619
date	2012.12.17.23.46.33;	author tg;	state Exp;
branches;
next	1.618;
commitid	10050CFAEEB2D5D31EB;

1.618
date	2012.12.17.23.18.09;	author tg;	state Exp;
branches;
next	1.617;
commitid	10050CFA81334F40D7F;

1.617
date	2012.12.17.22.14.26;	author tg;	state Exp;
branches;
next	1.616;
commitid	10050CF9958429136E1;

1.616
date	2012.12.17.21.55.06;	author tg;	state Exp;
branches;
next	1.615;
commitid	10050CF94C775867203;

1.615
date	2012.12.07.23.46.38;	author tg;	state Exp;
branches;
next	1.614;
commitid	10050C27FDC255CF0A0;

1.614
date	2012.12.05.19.38.23;	author tg;	state Exp;
branches;
next	1.613;
commitid	10050BFA2C0046FB3B9;

1.613
date	2012.12.05.18.54.09;	author tg;	state Exp;
branches;
next	1.612;
commitid	10050BF986807E3B0C1;

1.612
date	2012.12.04.01.18.32;	author tg;	state Exp;
branches;
next	1.611;
commitid	10050BD4F7642624FD1;

1.611
date	2012.12.01.01.36.28;	author tg;	state Exp;
branches;
next	1.610;
commitid	10050B95F03690E9DEE;

1.610
date	2012.11.30.20.49.18;	author tg;	state Exp;
branches;
next	1.609;
commitid	10050B91BDD34E31558;

1.609
date	2012.11.30.20.19.14;	author tg;	state Exp;
branches;
next	1.608;
commitid	10050B914D41435E735;

1.608
date	2012.11.30.19.58.48;	author tg;	state Exp;
branches
	1.608.2.1;
next	1.607;
commitid	10050B9100F36FFAD25;

1.607
date	2012.11.30.19.57.35;	author tg;	state Exp;
branches;
next	1.606;
commitid	10050B90FC753748898;

1.606
date	2012.11.30.19.51.25;	author tg;	state Exp;
branches;
next	1.605;
commitid	10050B90E3B6BD12D5D;

1.605
date	2012.11.30.19.25.06;	author tg;	state Exp;
branches;
next	1.604;
commitid	10050B907135D4B5928;

1.604
date	2012.11.26.23.14.46;	author tg;	state Exp;
branches;
next	1.603;
commitid	10050B3F7FB39D688CF;

1.603
date	2012.11.20.18.50.46;	author tg;	state Exp;
branches;
next	1.602;
commitid	10050ABD11751603401;

1.602
date	2012.11.12.19.13.46;	author tg;	state Exp;
branches;
next	1.601;
commitid	10050A14A6D512A123A;

1.601
date	2012.11.12.18.28.40;	author tg;	state Exp;
branches;
next	1.600;
commitid	10050A13FEF109064C5;

1.600
date	2012.10.30.20.49.43;	author tg;	state Exp;
branches;
next	1.599;
commitid	10050903D7D16EDB58E;

1.599
date	2012.10.30.20.13.20;	author tg;	state Exp;
branches;
next	1.598;
commitid	100509034F50DD7C6D5;

1.598
date	2012.10.30.20.07.13;	author tg;	state Exp;
branches;
next	1.597;
commitid	10050903386452ACBF1;

1.597
date	2012.10.22.20.19.16;	author tg;	state Exp;
branches;
next	1.596;
commitid	1005085AA537A17A752;

1.596
date	2012.10.22.16.53.22;	author tg;	state Exp;
branches;
next	1.595;
commitid	10050857A0A617725BC;

1.595
date	2012.10.21.21.55.05;	author tg;	state Exp;
branches;
next	1.594;
commitid	10050846F101988A117;

1.594
date	2012.10.21.21.39.05;	author tg;	state Exp;
branches;
next	1.593;
commitid	10050846B5B2B1A2932;

1.593
date	2012.10.21.21.26.41;	author tg;	state Exp;
branches;
next	1.592;
commitid	1005084678C510CF7E4;

1.592
date	2012.10.03.17.24.23;	author tg;	state Exp;
branches;
next	1.591;
commitid	100506C74D35719B33B;

1.591
date	2012.10.03.16.16.13;	author tg;	state Exp;
branches;
next	1.590;
commitid	100506C64E4724B9215;

1.590
date	2012.10.03.15.55.37;	author tg;	state Exp;
branches;
next	1.589;
commitid	100506C601212D49A2F;

1.589
date	2012.10.03.15.50.31;	author tg;	state Exp;
branches;
next	1.588;
commitid	100506C5EDD0A412A8E;

1.588
date	2012.10.03.15.13.34;	author tg;	state Exp;
branches;
next	1.587;
commitid	100506C56316A8B5F1D;

1.587
date	2012.09.21.17.20.22;	author tg;	state Exp;
branches;
next	1.586;
commitid	100505CA1BB6B435496;

1.586
date	2012.09.07.21.02.43;	author tg;	state Exp;
branches;
next	1.585;
commitid	100504A600348A7ECE5;

1.585
date	2012.09.01.23.46.41;	author tg;	state Exp;
branches;
next	1.584;
commitid	10050429E542CD63CF1;

1.584
date	2012.08.24.21.33.51;	author tg;	state Exp;
branches;
next	1.583;
commitid	1005037F34F0A0722F6;

1.583
date	2012.08.24.21.15.42;	author tg;	state Exp;
branches;
next	1.582;
commitid	1005037EEEC1CEDE454;

1.582
date	2012.08.24.20.57.46;	author tg;	state Exp;
branches;
next	1.581;
commitid	1005037EABE57131431;

1.581
date	2012.08.24.20.05.13;	author tg;	state Exp;
branches;
next	1.580;
commitid	1005037DE8E56F5392F;

1.580
date	2012.08.24.19.09.10;	author tg;	state Exp;
branches;
next	1.579;
commitid	1005037D16D4D0C81CC;

1.579
date	2012.08.24.19.02.57;	author tg;	state Exp;
branches;
next	1.578;
commitid	1005037CFF74447266D;

1.578
date	2012.08.17.18.34.24;	author tg;	state Exp;
branches;
next	1.577;
commitid	100502E8EAA4BFCF410;

1.577
date	2012.08.03.18.45.32;	author tg;	state Exp;
branches;
next	1.576;
commitid	100501C1C5E2739B581;

1.576
date	2012.07.30.21.37.15;	author tg;	state Exp;
branches;
next	1.575;
commitid	1005016FE9B27F9F4DC;

1.575
date	2012.07.30.17.04.30;	author tg;	state Exp;
branches;
next	1.574;
commitid	1005016BEB601685CAE;

1.574
date	2012.07.22.15.56.51;	author tg;	state Exp;
branches;
next	1.573;
commitid	100500C22DA33CA17CF;

1.573
date	2012.07.20.23.22.13;	author tg;	state Exp;
branches;
next	1.572;
commitid	1005009E802250C41C1;

1.572
date	2012.07.01.15.54.57;	author tg;	state Exp;
branches;
next	1.571;
commitid	1004FF072DE3F1A3116;

1.571
date	2012.07.01.15.44.31;	author tg;	state Exp;
branches;
next	1.570;
commitid	1004FF070766FF4AAF0;

1.570
date	2012.07.01.15.41.56;	author tg;	state Exp;
branches;
next	1.569;
commitid	1004FF06FCD78BB0262;

1.569
date	2012.07.01.15.38.07;	author tg;	state Exp;
branches;
next	1.568;
commitid	1004FF06EE567E89991;

1.568
date	2012.06.28.20.17.37;	author tg;	state Exp;
branches
	1.568.2.1;
next	1.567;
commitid	1004FECBBF10FC5C93C;

1.567
date	2012.06.28.20.05.11;	author tg;	state Exp;
branches;
next	1.566;
commitid	1004FECB8FB4B2757ED;

1.566
date	2012.06.28.20.02.28;	author tg;	state Exp;
branches;
next	1.565;
commitid	1004FECB86B79975962;

1.565
date	2012.06.28.20.01.00;	author tg;	state Exp;
branches;
next	1.564;
commitid	1004FECB81305B1E36F;

1.564
date	2012.06.26.19.33.33;	author tg;	state Exp;
branches;
next	1.563;
commitid	1004FEA0E9F218104F1;

1.563
date	2012.06.26.18.11.05;	author tg;	state Exp;
branches;
next	1.562;
commitid	1004FE9FB4B72E4DC0B;

1.562
date	2012.06.25.16.05.10;	author tg;	state Exp;
branches;
next	1.561;
commitid	1004FE88C477BD00898;

1.561
date	2012.06.24.20.39.26;	author tg;	state Exp;
branches;
next	1.560;
commitid	1004FE77ABD5A53682F;

1.560
date	2012.05.09.23.20.58;	author tg;	state Exp;
branches;
next	1.559;
commitid	1004FAAFBED1D226CAF;

1.559
date	2012.05.05.17.37.44;	author tg;	state Exp;
branches;
next	1.558;
commitid	1004FA5657C4457F07B;

1.558
date	2012.05.04.22.44.34;	author tg;	state Exp;
branches;
next	1.557;
commitid	1004FA45BE357DA71DC;

1.557
date	2012.05.04.22.18.27;	author tg;	state Exp;
branches;
next	1.556;
commitid	1004FA455C411397094;

1.556
date	2012.05.04.22.05.02;	author tg;	state Exp;
branches;
next	1.555;
commitid	1004FA452A16C9E34E1;

1.555
date	2012.05.04.21.47.03;	author tg;	state Exp;
branches;
next	1.554;
commitid	1004FA44E6C59CC7A07;

1.554
date	2012.05.04.21.15.34;	author tg;	state Exp;
branches;
next	1.553;
commitid	1004FA4470B7AD85C13;

1.553
date	2012.05.04.20.49.07;	author tg;	state Exp;
branches;
next	1.552;
commitid	1004FA4409A67B135DE;

1.552
date	2012.05.04.20.08.25;	author tg;	state Exp;
branches;
next	1.551;
commitid	1004FA4373D2C11CAC3;

1.551
date	2012.04.27.16.16.23;	author tg;	state Exp;
branches;
next	1.550;
commitid	1004F9AC66A708942C6;

1.550
date	2012.04.22.21.50.33;	author tg;	state Exp;
branches;
next	1.549;
commitid	1004F947C3646B6F432;

1.549
date	2012.04.14.16.07.48;	author tg;	state Exp;
branches;
next	1.548;
commitid	1004F89A0D311D70891;

1.548
date	2012.04.14.14.35.12;	author tg;	state Exp;
branches;
next	1.547;
commitid	1004F898AD566CBFC2D;

1.547
date	2012.04.14.14.07.47;	author tg;	state Exp;
branches;
next	1.546;
commitid	1004F8984C858E8C9F2;

1.546
date	2012.04.14.14.02.40;	author tg;	state Exp;
branches;
next	1.545;
commitid	1004F89836C6359BA94;

1.545
date	2012.04.07.11.19.51;	author tg;	state Exp;
branches;
next	1.544;
commitid	1004F8022E670BC1C0E;

1.544
date	2012.04.06.15.23.11;	author tg;	state Exp;
branches;
next	1.543;
commitid	1004F7F0A772094B85A;

1.543
date	2012.04.06.15.20.42;	author tg;	state Exp;
branches;
next	1.542;
commitid	1004F7F096867C83CF0;

1.542
date	2012.04.06.13.29.01;	author tg;	state Exp;
branches;
next	1.541;
commitid	1004F7EEFB200419165;

1.541
date	2012.04.06.12.59.28;	author tg;	state Exp;
branches;
next	1.540;
commitid	1004F7EE8B85815EBA4;

1.540
date	2012.04.06.11.51.43;	author tg;	state Exp;
branches;
next	1.539;
commitid	1004F7ED8E66262169C;

1.539
date	2012.03.31.17.30.00;	author tg;	state Exp;
branches;
next	1.538;
commitid	1004F773F2D0016E021;

1.538
date	2012.03.29.19.23.01;	author tg;	state Exp;
branches;
next	1.537;
commitid	1004F74B525291EF6DE;

1.537
date	2012.03.28.23.09.24;	author tg;	state Exp;
branches;
next	1.536;
commitid	1004F739A3A6E4D4666;

1.536
date	2012.03.28.11.05.16;	author tg;	state Exp;
branches;
next	1.535;
commitid	1004F72F0831E0FEDD1;

1.535
date	2012.03.27.23.13.42;	author tg;	state Exp;
branches;
next	1.534;
commitid	1004F7249BA2221FCA0;

1.534
date	2012.03.27.22.58.39;	author tg;	state Exp;
branches;
next	1.533;
commitid	1004F7246082F66D55B;

1.533
date	2012.03.27.22.49.47;	author tg;	state Exp;
branches;
next	1.532;
commitid	1004F72442237B4278D;

1.532
date	2012.03.27.22.41.17;	author tg;	state Exp;
branches;
next	1.531;
commitid	1004F72421C16F52F81;

1.531
date	2012.03.27.22.36.53;	author tg;	state Exp;
branches;
next	1.530;
commitid	1004F7240673EAD3A5A;

1.530
date	2012.03.27.21.23.52;	author tg;	state Exp;
branches;
next	1.529;
commitid	1004F722FB133BECAE5;

1.529
date	2012.03.26.21.10.44;	author tg;	state Exp;
branches;
next	1.528;
commitid	1004F70DB64299CF262;

1.528
date	2012.03.25.14.28.14;	author tg;	state Exp;
branches;
next	1.527;
commitid	1004F6F2B60460FB25D;

1.527
date	2012.03.24.21.22.25;	author tg;	state Exp;
branches;
next	1.526;
commitid	1004F6E3A967ACCD93A;

1.526
date	2012.03.23.23.25.29;	author tg;	state Exp;
branches;
next	1.525;
commitid	1004F6D064C65BE58AA;

1.525
date	2012.03.23.21.58.22;	author tg;	state Exp;
branches;
next	1.524;
commitid	1004F6CF1C82CE9B908;

1.524
date	2012.03.23.20.07.11;	author tg;	state Exp;
branches;
next	1.523;
commitid	1004F6CD8052D2FFA5E;

1.523
date	2012.03.23.19.38.12;	author tg;	state Exp;
branches;
next	1.522;
commitid	1004F6CD13A7403AC2D;

1.522
date	2012.03.03.21.30.57;	author tg;	state Exp;
branches;
next	1.521;
commitid	1004F528D8E7F3D0F12;

1.521
date	2012.02.06.17.42.23;	author tg;	state Exp;
branches;
next	1.520;
commitid	1004F3010EC139BAB7F;

1.520
date	2012.01.29.01.41.15;	author tg;	state Exp;
branches;
next	1.519;
commitid	1004F24A3CB1AC86618;

1.519
date	2012.01.04.19.09.36;	author tg;	state Exp;
branches;
next	1.518;
commitid	1004F04A401028F581D;

1.518
date	2012.01.03.01.01.44;	author tg;	state Exp;
branches;
next	1.517;
commitid	1004F02538F6727341B;

1.517
date	2012.01.03.00.58.09;	author tg;	state Exp;
branches;
next	1.516;
commitid	1004F025261140919C7;

1.516
date	2011.12.31.00.27.25;	author tg;	state Exp;
branches;
next	1.515;
commitid	1004EFE570218254BB1;

1.515
date	2011.12.30.21.00.30;	author tg;	state Exp;
branches;
next	1.514;
commitid	1004EFE26857EA11C4E;

1.514
date	2011.12.29.23.36.23;	author tg;	state Exp;
branches;
next	1.513;
commitid	1004EFCF98C06684CE3;

1.513
date	2011.12.29.22.54.21;	author tg;	state Exp;
branches;
next	1.512;
commitid	1004EFCEFA861A142CF;

1.512
date	2011.12.16.20.03.27;	author tg;	state Exp;
branches;
next	1.511;
commitid	1004EEBA4214501EA9D;

1.511
date	2011.12.10.14.12.17;	author tg;	state Exp;
branches;
next	1.510;
commitid	1004EE368AD1FE82919;

1.510
date	2011.12.10.13.34.18;	author tg;	state Exp;
branches;
next	1.509;
commitid	1004EE35FEC458C37A0;

1.509
date	2011.12.09.20.40.26;	author tg;	state Exp;
branches;
next	1.508;
commitid	1004EE272502524774F;

1.508
date	2011.12.03.00.01.28;	author tg;	state Exp;
branches;
next	1.507;
commitid	1004ED966E04423C3DF;

1.507
date	2011.12.02.22.55.49;	author tg;	state Exp;
branches;
next	1.506;
commitid	1004ED9575E20B9B002;

1.506
date	2011.11.30.21.34.15;	author tg;	state Exp;
branches;
next	1.505;
commitid	1004ED6A06C18CCDBE5;

1.505
date	2011.11.26.00.45.21;	author tg;	state Exp;
branches;
next	1.504;
commitid	1004ED036B353923A89;

1.504
date	2011.11.22.18.01.40;	author tg;	state Exp;
branches;
next	1.503;
commitid	1004ECBE39656891872;

1.503
date	2011.11.19.21.22.02;	author tg;	state Exp;
branches;
next	1.502;
commitid	1004EC81E0F6AE3EBEC;

1.502
date	2011.11.11.22.14.17;	author tg;	state Exp;
branches;
next	1.501;
commitid	1004EBD9E4D2DCCBE71;

1.501
date	2011.11.09.22.17.26;	author tg;	state Exp;
branches;
next	1.500;
commitid	1004EBAFBE75B5A370F;

1.500
date	2011.11.08.22.07.14;	author tg;	state Exp;
branches;
next	1.499;
commitid	1004EB9A7F80119200E;

1.499
date	2011.10.26.20.46.16;	author tg;	state Exp;
branches;
next	1.498;
commitid	1004EA871AC0D94FE1C;

1.498
date	2011.10.25.22.36.37;	author tg;	state Exp;
branches;
next	1.497;
commitid	1004EA73A0B4E5C1903;

1.497
date	2011.10.25.22.25.07;	author tg;	state Exp;
branches;
next	1.496;
commitid	1004EA7375829799438;

1.496
date	2011.10.24.19.41.13;	author tg;	state Exp;
branches;
next	1.495;
commitid	1004EA5BF6B41948165;

1.495
date	2011.10.07.19.51.44;	author tg;	state Exp;
branches;
next	1.494;
commitid	1004E8F58646396DFB2;

1.494
date	2011.09.07.15.24.19;	author tg;	state Exp;
branches;
next	1.493;
commitid	1004E678C6929FE60A6;

1.493
date	2011.08.27.18.06.50;	author tg;	state Exp;
branches;
next	1.492;
commitid	1004E5932432420AA61;

1.492
date	2011.08.27.17.30.07;	author tg;	state Exp;
branches;
next	1.491;
commitid	1004E5929AF6944B2F7;

1.491
date	2011.08.13.22.19.41;	author tg;	state Exp;
branches;
next	1.490;
commitid	1004E46F8814937CBB6;

1.490
date	2011.07.26.16.57.28;	author tg;	state Exp;
branches;
next	1.489;
commitid	1004E2EF1DA23EC569A;

1.489
date	2011.07.20.23.47.29;	author tg;	state Exp;
branches;
next	1.488;
commitid	1004E2769127AE0E854;

1.488
date	2011.07.18.00.35.46;	author tg;	state Exp;
branches;
next	1.487;
commitid	1004E237FF1656D5846;

1.487
date	2011.07.16.17.08.52;	author tg;	state Exp;
branches;
next	1.486;
commitid	1004E21C5B66E327FE0;

1.486
date	2011.07.16.17.08.21;	author tg;	state Exp;
branches;
next	1.485;
commitid	1004E21C5974E8E1C5E;

1.485
date	2011.07.16.17.07.34;	author tg;	state Exp;
branches;
next	1.484;
commitid	1004E21C56A65D7176B;

1.484
date	2011.07.07.20.24.52;	author tg;	state Exp;
branches
	1.484.2.1;
next	1.483;
commitid	1004E1615FC6FBD8000;

1.483
date	2011.07.06.22.22.00;	author tg;	state Exp;
branches;
next	1.482;
commitid	1004E14E010182825E7;

1.482
date	2011.07.05.20.12.19;	author tg;	state Exp;
branches;
next	1.481;
commitid	1004E136FF75DBF04C7;

1.481
date	2011.07.02.17.57.40;	author tg;	state Exp;
branches;
next	1.480;
commitid	1004E0F5C27271F5B00;

1.480
date	2011.06.30.13.48.13;	author tg;	state Exp;
branches;
next	1.479;
commitid	1004E0C7EAF5586D53A;

1.479
date	2011.06.21.21.50.25;	author tg;	state Exp;
branches;
next	1.478;
commitid	1004E011236502496A9;

1.478
date	2011.06.21.21.11.20;	author tg;	state Exp;
branches;
next	1.477;
commitid	1004E01090552E993D4;

1.477
date	2011.06.21.21.10.12;	author tg;	state Exp;
branches;
next	1.476;
commitid	1004E0108C6199AB1FE;

1.476
date	2011.06.12.14.58.45;	author tg;	state Exp;
branches;
next	1.475;
commitid	1004DF4D43A005DAB99;

1.475
date	2011.06.11.03.14.50;	author tg;	state Exp;
branches;
next	1.474;
commitid	1004DF2DDB52CEA0AB1;

1.474
date	2011.06.05.19.58.19;	author tg;	state Exp;
branches;
next	1.473;
commitid	1004DEBDFBB243C0DCF;

1.473
date	2011.06.04.16.42.31;	author tg;	state Exp;
branches;
next	1.472;
commitid	1004DEA608B78E32C69;

1.472
date	2011.06.04.16.11.19;	author tg;	state Exp;
branches;
next	1.471;
commitid	1004DEA592B5E41F86E;

1.471
date	2011.05.29.16.31.42;	author tg;	state Exp;
branches;
next	1.470;
commitid	1004DE274F9085CC4DD;

1.470
date	2011.05.29.02.18.55;	author tg;	state Exp;
branches;
next	1.469;
commitid	1004DE1AD11046BEFFC;

1.469
date	2011.05.06.15.41.25;	author tg;	state Exp;
branches;
next	1.468;
commitid	1004DC416672F61DF37;

1.468
date	2011.05.05.00.04.59;	author tg;	state Exp;
branches;
next	1.467;
commitid	1004DC1E8D640072140;

1.467
date	2011.05.02.22.52.52;	author tg;	state Exp;
branches;
next	1.466;
commitid	1004DBF35D72295ADB7;

1.466
date	2011.04.22.21.44.35;	author tg;	state Exp;
branches;
next	1.465;
commitid	1004DB1F6D813825DD9;

1.465
date	2011.04.22.12.21.55;	author tg;	state Exp;
branches;
next	1.464;
commitid	1004DB172EA6A5331AE;

1.464
date	2011.04.22.12.15.40;	author tg;	state Exp;
branches;
next	1.463;
commitid	1004DB17167553347A9;

1.463
date	2011.04.17.12.24.44;	author tg;	state Exp;
branches;
next	1.462;
commitid	1004DAADC101DEEF61A;

1.462
date	2011.04.09.21.01.03;	author tg;	state Exp;
branches;
next	1.461;
commitid	1004DA0C9186AA3EA10;

1.461
date	2011.04.09.18.47.14;	author tg;	state Exp;
branches;
next	1.460;
commitid	1004DA0A9C665117993;

1.460
date	2011.04.09.15.14.53;	author tg;	state Exp;
branches;
next	1.459;
commitid	1004DA077823393B1E0;

1.459
date	2011.04.09.14.58.53;	author tg;	state Exp;
branches;
next	1.458;
commitid	1004DA074390CE29A35;

1.458
date	2011.04.02.10.30.11;	author tg;	state Exp;
branches;
next	1.457;
commitid	1004D96FAB20883B7FB;

1.457
date	2011.03.28.08.40.42;	author tg;	state Exp;
branches;
next	1.456;
commitid	1004D90499F536528A9;

1.456
date	2011.03.27.18.50.05;	author tg;	state Exp;
branches;
next	1.455;
commitid	1004D8F86AA0EB92572;

1.455
date	2011.03.27.01.30.38;	author tg;	state Exp;
branches;
next	1.454;
commitid	1004D8E935331A46B79;

1.454
date	2011.03.26.21.46.06;	author tg;	state Exp;
branches;
next	1.453;
commitid	1004D8E5E8E09438DF7;

1.453
date	2011.03.26.19.43.49;	author tg;	state Exp;
branches;
next	1.452;
commitid	1004D8E4204410B09C9;

1.452
date	2011.03.24.19.05.49;	author tg;	state Exp;
branches;
next	1.451;
commitid	1004D8B961A2724DA38;

1.451
date	2011.03.23.18.47.07;	author tg;	state Exp;
branches;
next	1.450;
commitid	1004D8A3FE2288AD1B5;

1.450
date	2011.03.21.21.57.33;	author tg;	state Exp;
branches;
next	1.449;
commitid	1004D87C9AA1AA37C2E;

1.449
date	2011.03.17.22.09.23;	author tg;	state Exp;
branches;
next	1.448;
commitid	1004D8286A619CA67D7;

1.448
date	2011.03.17.21.59.30;	author tg;	state Exp;
branches;
next	1.447;
commitid	1004D8284560EEE6F6C;

1.447
date	2011.03.17.21.58.38;	author tg;	state Exp;
branches;
next	1.446;
commitid	1004D828425404E9610;

1.446
date	2011.03.16.20.26.36;	author tg;	state Exp;
branches;
next	1.445;
commitid	1004D811CB27C272DCB;

1.445
date	2011.03.13.16.03.53;	author tg;	state Exp;
branches;
next	1.444;
commitid	1004D7CE9C2063207F0;

1.444
date	2011.03.13.01.20.22;	author tg;	state Exp;
branches;
next	1.443;
commitid	1004D7C1BE368F5B459;

1.443
date	2011.03.12.23.04.47;	author tg;	state Exp;
branches;
next	1.442;
commitid	1004D7BFC0825FC39FC;

1.442
date	2011.03.12.21.41.14;	author tg;	state Exp;
branches;
next	1.441;
commitid	1004D7BE79D2481A518;

1.441
date	2011.03.08.18.49.50;	author tg;	state Exp;
branches;
next	1.440;
commitid	1004D767A1867ED392F;

1.440
date	2011.03.07.20.32.50;	author tg;	state Exp;
branches;
next	1.439;
commitid	1004D7540D21019BF2E;

1.439
date	2011.03.07.20.30.40;	author tg;	state Exp;
branches;
next	1.438;
commitid	1004D75404D6F4BA14C;

1.438
date	2011.03.06.17.08.13;	author tg;	state Exp;
branches;
next	1.437;
commitid	1004D73BF8011CAE269;

1.437
date	2011.03.06.01.50.11;	author tg;	state Exp;
branches;
next	1.436;
commitid	1004D72E7B5122D1766;

1.436
date	2011.03.06.01.25.33;	author tg;	state Exp;
branches;
next	1.435;
commitid	1004D72E2935F494D4B;

1.435
date	2011.03.05.21.48.09;	author tg;	state Exp;
branches;
next	1.434;
commitid	1004D72AF6C540FBB78;

1.434
date	2011.03.05.21.43.18;	author tg;	state Exp;
branches;
next	1.433;
commitid	1004D72AE603B079174;

1.433
date	2011.02.27.19.29.32;	author tg;	state Exp;
branches;
next	1.432;
commitid	1004D6AA6322ACDE0DB;

1.432
date	2011.02.18.22.26.13;	author tg;	state Exp;
branches;
next	1.431;
commitid	1004D5EF0ED2C0C9394;

1.431
date	2011.02.13.21.13.08;	author tg;	state Exp;
branches;
next	1.430;
commitid	1004D58496015725548;

1.430
date	2011.02.11.01.18.22;	author tg;	state Exp;
branches;
next	1.429;
commitid	1004D548C4E66D17A12;

1.429
date	2011.02.11.00.41.37;	author tg;	state Exp;
branches;
next	1.428;
commitid	1004D5485D4414A9BFE;

1.428
date	2011.02.09.13.08.27;	author tg;	state Exp;
branches;
next	1.427;
commitid	1004D5291DC3026B343;

1.427
date	2011.02.03.15.57.52;	author tg;	state Exp;
branches;
next	1.426;
commitid	1004D4ACE420C09213B;

1.426
date	2011.01.30.01.36.00;	author tg;	state Exp;
branches;
next	1.425;
commitid	1004D44C0920D39CB07;

1.425
date	2011.01.30.01.35.35;	author tg;	state Exp;
branches;
next	1.424;
commitid	1004D44C07439762D63;

1.424
date	2011.01.22.20.33.14;	author tg;	state Exp;
branches;
next	1.423;
commitid	1004D3B3F1E5091C6CD;

1.423
date	2011.01.21.22.25.34;	author tg;	state Exp;
branches;
next	1.422;
commitid	1004D3A07DC22BE01C9;

1.422
date	2011.01.21.21.04.47;	author tg;	state Exp;
branches;
next	1.421;
commitid	1004D39F4C639F3DCA7;

1.421
date	2011.01.09.21.57.29;	author tg;	state Exp;
branches;
next	1.420;
commitid	1004D2A2F086B2268F4;

1.420
date	2010.12.19.20.00.56;	author tg;	state Exp;
branches;
next	1.419;
commitid	1004D0E647B738BDF7F;

1.419
date	2010.11.01.17.29.05;	author tg;	state Exp;
branches;
next	1.418;
commitid	1004CCEF8F323B360DC;

1.418
date	2010.10.08.17.56.57;	author tg;	state Exp;
branches;
next	1.417;
commitid	1004CAF5B5A6D74E1C9;

1.417
date	2010.10.01.19.04.38;	author tg;	state Exp;
branches;
next	1.416;
commitid	1004CA6307E2EE8E957;

1.416
date	2010.09.19.19.28.23;	author tg;	state Exp;
branches;
next	1.415;
commitid	1004C96645E6EA59306;

1.415
date	2010.09.15.21.08.19;	author tg;	state Exp;
branches;
next	1.414;
commitid	1004C9135BE7A0C39AD;

1.414
date	2010.09.14.21.26.16;	author tg;	state Exp;
branches;
next	1.413;
commitid	1004C8FE654576B0E25;

1.413
date	2010.09.14.21.15.11;	author tg;	state Exp;
branches;
next	1.412;
commitid	1004C8FE5D57435CE69;

1.412
date	2010.09.05.19.51.35;	author tg;	state Exp;
branches;
next	1.411;
commitid	1004C83F4BE00D43672;

1.411
date	2010.08.28.20.22.22;	author tg;	state Exp;
branches;
next	1.410;
commitid	1004C796FE40C544CCE;

1.410
date	2010.08.28.18.50.55;	author tg;	state Exp;
branches;
next	1.409;
commitid	1004C795A82072326AF;

1.409
date	2010.08.28.17.21.46;	author tg;	state Exp;
branches;
next	1.408;
commitid	1004C7945A20EB8DDA4;

1.408
date	2010.08.28.16.47.10;	author tg;	state Exp;
branches;
next	1.407;
commitid	1004C793DA0390DF065;

1.407
date	2010.08.28.15.48.20;	author tg;	state Exp;
branches;
next	1.406;
commitid	1004C792FD945CE393C;

1.406
date	2010.08.28.15.39.20;	author tg;	state Exp;
branches;
next	1.405;
commitid	1004C792DBD73FFB797;

1.405
date	2010.08.24.15.19.54;	author tg;	state Exp;
branches;
next	1.404;
commitid	1004C73E31577F0CD63;

1.404
date	2010.08.24.14.42.04;	author tg;	state Exp;
branches;
next	1.403;
commitid	1004C73D9D62A68EAE7;

1.403
date	2010.08.14.21.35.13;	author tg;	state Exp;
branches;
next	1.402;
commitid	1004C670C171B08A36C;

1.402
date	2010.07.25.11.35.42;	author tg;	state Exp;
branches;
next	1.401;
commitid	1004C4C211F2951575A;

1.401
date	2010.07.24.17.08.30;	author tg;	state Exp;
branches;
next	1.400;
commitid	1004C4B1E2355F50980;

1.400
date	2010.07.21.11.31.16;	author tg;	state Exp;
branches;
next	1.399;
commitid	1004C46DA7D68DDD451;

1.399
date	2010.07.19.22.41.03;	author tg;	state Exp;
branches;
next	1.398;
commitid	1004C44D3437C9C37AE;

1.398
date	2010.07.17.22.09.38;	author tg;	state Exp;
branches;
next	1.397;
commitid	1004C42295452E71B6E;

1.397
date	2010.07.13.13.12.32;	author tg;	state Exp;
branches;
next	1.396;
commitid	1004C3C662810A34ABB;

1.396
date	2010.07.11.11.17.32;	author tg;	state Exp;
branches;
next	1.395;
commitid	1004C39A83931615597;

1.395
date	2010.07.04.17.45.16;	author tg;	state Exp;
branches;
next	1.394;
commitid	1004C30C8946816B0C1;

1.394
date	2010.07.04.17.33.57;	author tg;	state Exp;
branches;
next	1.393;
commitid	1004C30C5ED28DF693B;

1.393
date	2010.07.04.13.36.43;	author tg;	state Exp;
branches;
next	1.392;
commitid	1004C308E614DF59FFB;

1.392
date	2010.05.22.12.49.16;	author tg;	state Exp;
branches;
next	1.391;
commitid	1004BF7D29E03EBF637;

1.391
date	2010.05.16.19.04.42;	author tg;	state Exp;
branches;
next	1.390;
commitid	1004BF041CB522EEEE3;

1.390
date	2010.04.27.21.39.09;	author tg;	state Exp;
branches;
next	1.389;
commitid	1004BD75943684FFAB4;

1.389
date	2010.04.20.09.10.07;	author tg;	state Exp;
branches;
next	1.388;
commitid	1004BCD6F5E78E50C4E;

1.388
date	2010.04.09.19.16.31;	author tg;	state Exp;
branches;
next	1.387;
commitid	1004BBF7CD656308A1C;

1.387
date	2010.04.08.13.21.08;	author tg;	state Exp;
branches;
next	1.386;
commitid	1004BBDD84556472D84;

1.386
date	2010.03.27.16.53.17;	author tg;	state Exp;
branches;
next	1.385;
commitid	1004BAE380B7133518B;

1.385
date	2010.03.27.16.51.39;	author tg;	state Exp;
branches;
next	1.384;
commitid	1004BAE37A00499B2F0;

1.384
date	2010.03.14.11.58.33;	author tg;	state Exp;
branches;
next	1.383;
commitid	1004B9CCF5B34BE8F30;

1.383
date	2010.02.25.20.18.17;	author tg;	state Exp;
branches;
next	1.382;
commitid	1004B86DB1A7C6BCE8B;

1.382
date	2010.02.23.18.13.04;	author tg;	state Exp;
branches;
next	1.381;
commitid	1004B841A9A1A72C896;

1.381
date	2010.02.18.17.31.23;	author tg;	state Exp;
branches;
next	1.380;
commitid	1004B7D796C24BBD8E1;

1.380
date	2010.01.29.09.34.30;	author tg;	state Exp;
branches;
next	1.379;
commitid	1004B62ABB7333ED94C;

1.379
date	2010.01.28.20.58.34;	author tg;	state Exp;
branches;
next	1.378;
commitid	1004B61FA7F4ADB96C5;

1.378
date	2010.01.28.20.26.51;	author tg;	state Exp;
branches;
next	1.377;
commitid	1004B61F30F0039EC8B;

1.377
date	2010.01.28.15.13.25;	author tg;	state Exp;
branches;
next	1.376;
commitid	1004B61A99D4E889CC9;

1.376
date	2010.01.25.16.12.57;	author tg;	state Exp;
branches;
next	1.375;
commitid	1004B5DC2A56A6AB278;

1.375
date	2010.01.25.14.38.03;	author tg;	state Exp;
branches;
next	1.374;
commitid	1004B5DACDC357C3689;

1.374
date	2010.01.16.19.08.05;	author tg;	state Exp;
branches;
next	1.373;
commitid	1004B520E9E581ABB40;

1.373
date	2010.01.08.22.21.06;	author tg;	state Exp;
branches;
next	1.372;
commitid	1004B47AF75223D4923;

1.372
date	2010.01.01.17.44.10;	author tg;	state Exp;
branches;
next	1.371;
commitid	1004B3E342E71FBD2B2;

1.371
date	2009.12.31.14.05.44;	author tg;	state Exp;
branches;
next	1.370;
commitid	1004B3CAF8C011FFD00;

1.370
date	2009.12.12.22.27.09;	author tg;	state Exp;
branches;
next	1.369;
commitid	1004B2418AF282F4231;

1.369
date	2009.12.05.22.19.42;	author tg;	state Exp;
branches;
next	1.368;
commitid	1004B1ADC9423FC09DA;

1.368
date	2009.12.05.17.43.49;	author tg;	state Exp;
branches;
next	1.367;
commitid	1004B1A9BCF3E49BC5B;

1.367
date	2009.12.01.19.15.34;	author tg;	state Exp;
branches;
next	1.366;
commitid	1004B156B29488E0456;

1.366
date	2009.11.29.17.37.22;	author tg;	state Exp;
branches;
next	1.365;
commitid	1004B12B1665316740B;

1.365
date	2009.11.28.15.38.30;	author tg;	state Exp;
branches;
next	1.364;
commitid	1004B1144002949633C;

1.364
date	2009.11.28.14.28.02;	author tg;	state Exp;
branches;
next	1.363;
commitid	1004B11334F4604E973;

1.363
date	2009.11.28.14.21.45;	author tg;	state Exp;
branches;
next	1.362;
commitid	1004B1131E93EDF1403;

1.362
date	2009.11.22.14.25.18;	author tg;	state Exp;
branches
	1.362.2.1;
next	1.361;
commitid	1004B0949E239806ED4;

1.361
date	2009.11.21.23.23.20;	author tg;	state Exp;
branches;
next	1.360;
commitid	1004B08764D5928E063;

1.360
date	2009.11.09.23.35.11;	author tg;	state Exp;
branches;
next	1.359;
commitid	1004AF8A72F40172587;

1.359
date	2009.10.30.00.57.38;	author tg;	state Exp;
branches;
next	1.358;
commitid	1004AEA39BD3F10ECFA;

1.358
date	2009.10.27.17.00.02;	author tg;	state Exp;
branches;
next	1.357;
commitid	1004AE726F77A03CF56;

1.357
date	2009.10.18.12.30.05;	author tg;	state Exp;
branches;
next	1.356;
commitid	1004ADB0A4708185E1A;

1.356
date	2009.10.17.21.16.04;	author tg;	state Exp;
branches;
next	1.355;
commitid	1004ADA339B53B8111A;

1.355
date	2009.10.15.16.36.27;	author tg;	state Exp;
branches;
next	1.354;
commitid	1004AD74F846B061D71;

1.354
date	2009.10.10.21.17.31;	author tg;	state Exp;
branches;
next	1.353;
commitid	1004AD0F97B0E1CF3C3;

1.353
date	2009.10.04.13.19.33;	author tg;	state Exp;
branches;
next	1.352;
commitid	1004AC8A0EC1AB8E5E0;

1.352
date	2009.10.02.18.08.36;	author tg;	state Exp;
branches;
next	1.351;
commitid	1004AC641341D9D9D02;

1.351
date	2009.09.29.12.28.13;	author tg;	state Exp;
branches;
next	1.350;
commitid	1004AC1FD4F2AA51F2E;

1.350
date	2009.09.26.04.01.33;	author tg;	state Exp;
branches;
next	1.349;
commitid	1004ABD92036DD32E15;

1.349
date	2009.09.26.03.40.01;	author tg;	state Exp;
branches;
next	1.348;
commitid	1004ABD8CE62D55CFD8;

1.348
date	2009.09.24.17.15.32;	author tg;	state Exp;
branches;
next	1.347;
commitid	1004ABBA8D95908292B;

1.347
date	2009.09.23.18.04.57;	author tg;	state Exp;
branches;
next	1.346;
commitid	1004ABA62C8171BD8E4;

1.346
date	2009.09.20.17.23.52;	author tg;	state Exp;
branches;
next	1.345;
commitid	1004AB6650915B0514A;

1.345
date	2009.09.20.16.40.57;	author tg;	state Exp;
branches;
next	1.344;
commitid	1004AB65AF3542D0922;

1.344
date	2009.09.20.13.08.11;	author tg;	state Exp;
branches;
next	1.343;
commitid	1004AB6294B732533ED;

1.343
date	2009.09.19.21.54.46;	author tg;	state Exp;
branches;
next	1.342;
commitid	1004AB552F7546C611E;

1.342
date	2009.09.19.19.08.48;	author tg;	state Exp;
branches;
next	1.341;
commitid	1004AB52C3C201A31B8;

1.341
date	2009.09.19.15.16.05;	author tg;	state Exp;
branches;
next	1.340;
commitid	1004AB4F5B430F7AA5A;

1.340
date	2009.09.07.17.24.49;	author tg;	state Exp;
branches;
next	1.339;
commitid	1004AA541E5370FC6A6;

1.339
date	2009.09.06.17.55.55;	author tg;	state Exp;
branches;
next	1.338;
commitid	1004AA3F6E1614843D5;

1.338
date	2009.09.06.17.42.14;	author tg;	state Exp;
branches;
next	1.337;
commitid	1004AA3F479204C1E97;

1.337
date	2009.08.30.21.02.01;	author tg;	state Exp;
branches;
next	1.336;
commitid	1004A9AE8B12FB2C70D;

1.336
date	2009.08.30.13.30.08;	author tg;	state Exp;
branches
	1.336.2.1;
next	1.335;
commitid	1004A9A7EDF06F600FC;

1.335
date	2009.08.30.13.22.39;	author tg;	state Exp;
branches;
next	1.334;
commitid	1004A9A7CF57ABC87F3;

1.334
date	2009.08.28.22.46.21;	author tg;	state Exp;
branches;
next	1.333;
commitid	1004A985E1C5618CC94;

1.333
date	2009.08.28.22.23.34;	author tg;	state Exp;
branches;
next	1.332;
commitid	1004A9858F050FF8B13;

1.332
date	2009.08.28.21.07.27;	author tg;	state Exp;
branches;
next	1.331;
commitid	1004A984722589F219C;

1.331
date	2009.08.28.21.04.17;	author tg;	state Exp;
branches;
next	1.330;
commitid	1004A9846665E529BFC;

1.330
date	2009.08.28.21.01.26;	author tg;	state Exp;
branches;
next	1.329;
commitid	1004A9845725143AD02;

1.329
date	2009.08.28.20.38.42;	author tg;	state Exp;
branches;
next	1.328;
commitid	1004A98405B0186F15C;

1.328
date	2009.08.28.20.30.58;	author tg;	state Exp;
branches;
next	1.327;
commitid	1004A983E6B745731A0;

1.327
date	2009.08.28.19.57.42;	author tg;	state Exp;
branches;
next	1.326;
commitid	1004A98365B7809CDA1;

1.326
date	2009.08.28.19.16.16;	author tg;	state Exp;
branches;
next	1.325;
commitid	1004A982D155F910FC0;

1.325
date	2009.08.28.18.59.01;	author tg;	state Exp;
branches;
next	1.324;
commitid	1004A9828E60B2CE01C;

1.324
date	2009.08.28.18.53.59;	author tg;	state Exp;
branches;
next	1.323;
commitid	1004A9827D2091BAE42;

1.323
date	2009.08.28.18.33.05;	author tg;	state Exp;
branches;
next	1.322;
commitid	1004A9822ED4B43578E;

1.322
date	2009.08.08.13.08.52;	author tg;	state Exp;
branches;
next	1.321;
commitid	1004A7D785D73D49CFA;

1.321
date	2009.08.01.20.32.45;	author tg;	state Rel;
branches;
next	1.320;
commitid	1004A74A6770161F3E7;

1.320
date	2009.08.01.20.29.25;	author tg;	state Exp;
branches;
next	1.319;
commitid	1004A74A5AD143467F6;

1.319
date	2009.08.01.14.21.30;	author tg;	state Exp;
branches;
next	1.318;
commitid	1004A744F781627353F;

1.318
date	2009.07.30.19.11.12;	author tg;	state Exp;
branches;
next	1.317;
commitid	1004A71F04C54EFD9CF;

1.317
date	2009.07.30.18.42.31;	author tg;	state Exp;
branches;
next	1.316;
commitid	1004A71E99E7DC14CE2;

1.316
date	2009.07.25.21.31.27;	author tg;	state Exp;
branches;
next	1.315;
commitid	1004A6B79B87CB15A8B;

1.315
date	2009.07.25.20.26.33;	author tg;	state Exp;
branches;
next	1.314;
commitid	1004A6B6A5D6F28009F;

1.314
date	2009.07.25.20.18.13;	author tg;	state Exp;
branches;
next	1.313;
commitid	1004A6B688A1A8581CB;

1.313
date	2009.07.16.15.06.45;	author tg;	state Exp;
branches;
next	1.312;
commitid	1004A5F412E6BBABCED;

1.312
date	2009.07.06.15.06.25;	author tg;	state Exp;
branches;
next	1.311;
commitid	1004A5212AD490123A5;

1.311
date	2009.07.05.13.56.48;	author tg;	state Exp;
branches;
next	1.310;
commitid	1004A50B0E3697D221C;

1.310
date	2009.06.10.18.12.48;	author tg;	state Rel;
branches;
next	1.309;
commitid	1004A2FF7913BD44883;

1.309
date	2009.06.10.18.11.27;	author tg;	state Exp;
branches;
next	1.308;
commitid	1004A2FF764542B3C7D;

1.308
date	2009.06.08.20.34.40;	author tg;	state Exp;
branches;
next	1.307;
commitid	1004A2D75D22EFFE1BD;

1.307
date	2009.06.08.20.06.48;	author tg;	state Exp;
branches;
next	1.306;
commitid	1004A2D6F3A31FB4CBC;

1.306
date	2009.06.07.22.28.05;	author tg;	state Exp;
branches;
next	1.305;
commitid	1004A2C3EEE42B8D086;

1.305
date	2009.05.31.15.10.07;	author tg;	state Exp;
branches;
next	1.304;
commitid	1004A229DBA2308E628;

1.304
date	2009.05.27.19.52.38;	author tg;	state Exp;
branches;
next	1.303;
commitid	1004A1D99540BF61ECF;

1.303
date	2009.05.27.09.58.23;	author tg;	state Exp;
branches;
next	1.302;
commitid	1004A1D0E9B4EF3C493;

1.302
date	2009.05.21.14.28.35;	author tg;	state Exp;
branches;
next	1.301;
commitid	1004A156526780370CA;

1.301
date	2009.05.20.10.10.02;	author tg;	state Exp;
branches;
next	1.300;
commitid	1004A13D70259491252;

1.300
date	2009.05.16.21.00.52;	author tg;	state Exp;
branches;
next	1.299;
commitid	1004A0F296C32088698;

1.299
date	2009.05.16.19.34.07;	author tg;	state Exp;
branches;
next	1.298;
commitid	1004A0F1530750526D5;

1.298
date	2009.05.16.18.40.09;	author tg;	state Exp;
branches;
next	1.297;
commitid	1004A0F087409E93A5D;

1.297
date	2009.05.16.16.59.39;	author tg;	state Exp;
branches;
next	1.296;
commitid	1004A0EF0664EF4168D;

1.296
date	2009.05.16.15.53.02;	author tg;	state Exp;
branches;
next	1.295;
commitid	1004A0EE0AF7BF1B8E7;

1.295
date	2009.05.16.15.09.07;	author tg;	state Exp;
branches;
next	1.294;
commitid	1004A0ED7131FB6A76E;

1.294
date	2009.05.16.14.19.23;	author tg;	state Exp;
branches;
next	1.293;
commitid	1004A0ECB577CA34B34;

1.293
date	2009.04.07.19.43.28;	author tg;	state Exp;
branches;
next	1.292;
commitid	10049DBACB7766F4210;

1.292
date	2009.04.07.18.56.51;	author tg;	state Exp;
branches;
next	1.291;
commitid	10049DBA2033E87A04C;

1.291
date	2009.04.07.18.46.07;	author tg;	state Exp;
branches;
next	1.290;
commitid	10049DB9F806A153CF0;

1.290
date	2009.04.07.18.41.37;	author tg;	state Exp;
branches;
next	1.289;
commitid	10049DB9E493037411A;

1.289
date	2009.04.06.08.33.37;	author tg;	state Exp;
branches;
next	1.288;
commitid	10049D9BE5254CE65B8;

1.288
date	2009.04.05.12.35.32;	author tg;	state Exp;
branches;
next	1.287;
commitid	10049D8A5A72FBB1A39;

1.287
date	2009.04.03.09.39.07;	author tg;	state Exp;
branches;
next	1.286;
commitid	10049D5D94A2E5145F0;

1.286
date	2009.03.25.21.45.28;	author tg;	state Exp;
branches;
next	1.285;
commitid	10049CAA57F1436902F;

1.285
date	2009.03.24.08.53.45;	author tg;	state Exp;
branches;
next	1.284;
commitid	10049C89FA139EADAFE;

1.284
date	2009.03.22.18.50.43;	author tg;	state Exp;
branches;
next	1.283;
commitid	10049C68886608D7379;

1.283
date	2009.03.22.18.28.35;	author tg;	state Exp;
branches;
next	1.282;
commitid	10049C6834E4ED058A4;

1.282
date	2009.03.22.17.47.38;	author tg;	state Exp;
branches;
next	1.281;
commitid	10049C679C543D854C9;

1.281
date	2009.03.22.17.31.17;	author tg;	state Exp;
branches;
next	1.280;
commitid	10049C675F404D09353;

1.280
date	2009.03.22.16.55.38;	author tg;	state Exp;
branches;
next	1.279;
commitid	10049C66D5D5A75A28F;

1.279
date	2009.03.17.13.56.45;	author tg;	state Exp;
branches;
next	1.278;
commitid	10049BFAC131C8B19AE;

1.278
date	2009.03.16.15.50.13;	author tg;	state Exp;
branches;
next	1.277;
commitid	10049BE751056775D85;

1.277
date	2009.03.16.15.14.23;	author tg;	state Exp;
branches;
next	1.276;
commitid	10049BE6CB22E3BA1BA;

1.276
date	2009.03.15.16.13.40;	author tg;	state Exp;
branches;
next	1.275;
commitid	10049BD293E126777AC;

1.275
date	2009.03.14.18.12.54;	author tg;	state Exp;
branches;
next	1.274;
commitid	10049BBF38A0ADEDD54;

1.274
date	2009.02.22.18.02.31;	author tg;	state Exp;
branches;
next	1.273;
commitid	10049A192E10DAA38C8;

1.273
date	2009.02.20.13.25.10;	author tg;	state Exp;
branches;
next	1.272;
commitid	100499EAF33578C4C3D;

1.272
date	2008.12.29.21.34.21;	author tg;	state Exp;
branches;
next	1.271;
commitid	10049594263416D2C1C;

1.271
date	2008.12.29.21.05.15;	author tg;	state Exp;
branches;
next	1.270;
commitid	10049593B8A55E8419D;

1.270
date	2008.12.29.20.53.48;	author tg;	state Exp;
branches;
next	1.269;
commitid	100495938E67E1E57A8;

1.269
date	2008.12.29.20.47.16;	author tg;	state Exp;
branches;
next	1.268;
commitid	10049593769614169C5;

1.268
date	2008.12.17.19.39.23;	author tg;	state Exp;
branches;
next	1.267;
commitid	100494955754640680F;

1.267
date	2008.12.13.18.32.27;	author tg;	state Exp;
branches;
next	1.266;
commitid	1004943FFBF5D93ECA5;

1.266
date	2008.12.13.17.02.16;	author tg;	state Exp;
branches;
next	1.265;
commitid	1004943EAA830C0300B;

1.265
date	2008.12.04.18.11.08;	author tg;	state Exp;
branches;
next	1.264;
commitid	10049381D2D4EEC022C;

1.264
date	2008.12.02.13.20.39;	author tg;	state Exp;
branches;
next	1.263;
commitid	1004935360E5A3EA32B;

1.263
date	2008.12.02.12.39.38;	author tg;	state Exp;
branches;
next	1.262;
commitid	10049352BD82DFF462F;

1.262
date	2008.11.30.10.33.39;	author tg;	state Exp;
branches;
next	1.261;
commitid	10049326BED703E2AC2;

1.261
date	2008.11.15.08.52.01;	author tg;	state Exp;
branches
	1.261.2.1;
next	1.260;
commitid	100491E8DC449203AF3;

1.260
date	2008.11.15.08.42.36;	author tg;	state Exp;
branches;
next	1.259;
commitid	100491E8B8F448A9E71;

1.259
date	2008.11.15.08.03.24;	author tg;	state Exp;
branches;
next	1.258;
commitid	100491E82543D2BB8A4;

1.258
date	2008.11.15.07.35.24;	author tg;	state Exp;
branches;
next	1.257;
commitid	100491E7BBB79B0FECE;

1.257
date	2008.11.12.04.55.19;	author tg;	state Exp;
branches;
next	1.256;
commitid	100491A618E0C3BD225;

1.256
date	2008.11.12.00.55.32;	author tg;	state Exp;
branches;
next	1.255;
commitid	100491A299233238473;

1.255
date	2008.11.12.00.54.50;	author tg;	state Exp;
branches;
next	1.254;
commitid	100491A295841A6D8EB;

1.254
date	2008.11.12.00.27.56;	author tg;	state Exp;
branches;
next	1.253;
commitid	100491A230649FC77C0;

1.253
date	2008.11.11.23.50.30;	author tg;	state Exp;
branches;
next	1.252;
commitid	100491A1A3D7C6B56F1;

1.252
date	2008.11.10.19.33.08;	author tg;	state Exp;
branches;
next	1.251;
commitid	10049188C7F54ACF524;

1.251
date	2008.11.09.20.32.18;	author tg;	state Exp;
branches;
next	1.250;
commitid	1004917488700179B64;

1.250
date	2008.11.02.22.29.36;	author tg;	state Exp;
branches;
next	1.249;
commitid	100490E29A42BDC6B59;

1.249
date	2008.10.28.14.51.06;	author tg;	state Exp;
branches;
next	1.248;
commitid	100490726E022860659;

1.248
date	2008.10.28.14.32.42;	author tg;	state Exp;
branches;
next	1.247;
commitid	1004907226D3DEFCCD1;

1.247
date	2008.10.26.21.51.27;	author ahoka;	state Exp;
branches;
next	1.246;
commitid	1004904E5B13CEB9815;

1.246
date	2008.10.26.20.59.40;	author tg;	state Exp;
branches;
next	1.245;
commitid	1004904DA0662727312;

1.245
date	2008.10.24.21.35.43;	author tg;	state Exp;
branches;
next	1.244;
commitid	10049023FBE3B7E383F;

1.244
date	2008.10.24.19.54.23;	author tg;	state Exp;
branches;
next	1.243;
commitid	100490228041C0CEA7E;

1.243
date	2008.10.20.19.29.25;	author tg;	state Exp;
branches;
next	1.242;
commitid	10048FCDBAF5C7D98EB;

1.242
date	2008.10.19.20.15.45;	author tg;	state Exp;
branches;
next	1.241;
commitid	10048FB954E53F4A93C;

1.241
date	2008.10.15.10.25.01;	author tg;	state Exp;
branches;
next	1.240;
commitid	10048F5C4D32F55458D;

1.240
date	2008.10.13.23.06.03;	author tg;	state Exp;
branches;
next	1.239;
commitid	10048F3D44866CCA1C2;

1.239
date	2008.10.10.21.30.42;	author tg;	state Exp;
branches;
next	1.238;
commitid	10048EFC9600438B1CB;

1.238
date	2008.10.05.16.06.43;	author tg;	state Exp;
branches;
next	1.237;
commitid	10048E8E61D7FB7DA17;

1.237
date	2008.10.04.23.08.04;	author tg;	state Exp;
branches;
next	1.236;
commitid	10048E7F7686DB8B02F;

1.236
date	2008.09.30.19.25.51;	author tg;	state Exp;
branches;
next	1.235;
commitid	10048E27D493BFBB014;

1.235
date	2008.09.30.18.43.07;	author tg;	state Exp;
branches;
next	1.234;
commitid	10048E2733A0C205E40;

1.234
date	2008.09.30.17.49.26;	author tg;	state Exp;
branches;
next	1.233;
commitid	10048E266AB7BDA06AF;

1.233
date	2008.09.20.19.18.00;	author tg;	state Exp;
branches;
next	1.232;
commitid	10048D54C486245FBD7;

1.232
date	2008.09.17.19.31.30;	author tg;	state Exp;
branches;
next	1.231;
commitid	10048D15ABE2EA76C75;

1.231
date	2008.09.14.20.24.59;	author tg;	state Exp;
branches;
next	1.230;
commitid	10048CD722B0B2BCCBE;

1.230
date	2008.08.02.17.45.12;	author tg;	state Exp;
branches;
next	1.229;
commitid	10048949D196A7C1390;

1.229
date	2008.07.18.11.33.12;	author tg;	state Exp;
branches;
next	1.228;
commitid	10048807F804EE06E7A;

1.228
date	2008.07.14.12.29.06;	author tg;	state Exp;
branches;
next	1.227;
commitid	100487B467E068A55D6;

1.227
date	2008.07.12.18.09.37;	author tg;	state Exp;
branches;
next	1.226;
commitid	1004878F3774388017F;

1.226
date	2008.07.12.17.47.21;	author tg;	state Exp;
branches;
next	1.225;
commitid	1004878EE2A1B7B5C06;

1.225
date	2008.07.12.17.23.00;	author tg;	state Exp;
branches;
next	1.224;
commitid	1004878E8826534BFE6;

1.224
date	2008.07.10.21.55.08;	author tg;	state Exp;
branches;
next	1.223;
commitid	1004876854B3C9E6F3B;

1.223
date	2008.07.10.18.48.02;	author tg;	state Exp;
branches;
next	1.222;
commitid	1004876596B2B77E38C;

1.222
date	2008.07.09.21.32.44;	author tg;	state Exp;
branches;
next	1.221;
commitid	10048752E6271CABA24;

1.221
date	2008.07.06.22.41.09;	author tg;	state Exp;
branches;
next	1.220;
commitid	10048714A14702F5007;

1.220
date	2008.06.28.22.51.55;	author tg;	state Exp;
branches;
next	1.219;
commitid	1004866BFA427FDEFB9;

1.219
date	2008.06.08.17.15.30;	author tg;	state Exp;
branches;
next	1.218;
commitid	100484C13C7725BA294;

1.218
date	2008.05.17.20.10.52;	author tg;	state Exp;
branches;
next	1.217;
commitid	100482F3BDE317E5F11;

1.217
date	2008.05.17.18.47.01;	author tg;	state Exp;
branches;
next	1.216;
commitid	100482F280E7B53AA4C;

1.216
date	2008.05.17.18.27.57;	author tg;	state Exp;
branches;
next	1.215;
commitid	100482F238341D5E08C;

1.215
date	2008.05.15.15.24.11;	author tg;	state Exp;
branches;
next	1.214;
commitid	100482C558039271D26;

1.214
date	2008.05.04.01.51.31;	author tg;	state Exp;
branches;
next	1.213;
commitid	100481D16AF3E4A7EEA;

1.213
date	2008.05.02.18.55.36;	author tg;	state Exp;
branches;
next	1.212;
commitid	100481B63B51233676D;

1.212
date	2008.04.22.19.00.41;	author tg;	state Exp;
branches;
next	1.211;
commitid	100480E35EF0AEDC30B;

1.211
date	2008.04.22.18.57.25;	author tg;	state Exp;
branches;
next	1.210;
commitid	100480E35217010E6B4;

1.210
date	2008.04.20.01.41.57;	author tg;	state Exp;
branches;
next	1.209;
commitid	100480A9F777BB1DCDE;

1.209
date	2008.04.20.00.24.26;	author tg;	state Exp;
branches;
next	1.208;
commitid	100480A8D4556C8D90D;

1.208
date	2008.04.20.00.03.50;	author tg;	state Exp;
branches;
next	1.207;
commitid	100480A88364EB31FEB;

1.207
date	2008.04.19.22.15.05;	author tg;	state Exp;
branches;
next	1.206;
commitid	100480A6CC85EC0197B;

1.206
date	2008.04.19.17.21.54;	author tg;	state Exp;
branches
	1.206.2.1;
next	1.205;
commitid	100480A2A2B32040FD7;

1.205
date	2008.04.16.21.56.03;	author tg;	state Exp;
branches;
next	1.204;
commitid	100480675E12E8ACD98;

1.204
date	2008.04.11.19.55.24;	author tg;	state Exp;
branches;
next	1.203;
commitid	10047FFC1677D373ADF;

1.203
date	2008.04.06.23.27.19;	author tg;	state Exp;
branches;
next	1.202;
commitid	10047F95C5A428D2277;

1.202
date	2008.04.02.16.55.06;	author tg;	state Exp;
branches;
next	1.201;
commitid	10047F3BA6A180846DA;

1.201
date	2008.04.01.22.20.19;	author tg;	state Exp;
branches;
next	1.200;
commitid	10047F2B5302C15B5C3;

1.200
date	2008.04.01.20.40.22;	author tg;	state Exp;
branches;
next	1.199;
commitid	10047F29D740D1FD5B8;

1.199
date	2008.03.28.13.46.53;	author tg;	state Exp;
branches;
next	1.198;
commitid	10047ECF6A15422B64A;

1.198
date	2008.03.25.21.34.45;	author tg;	state Exp;
branches;
next	1.197;
commitid	10047E96EF5608C6FD5;

1.197
date	2008.03.23.22.09.59;	author tg;	state Exp;
branches;
next	1.196;
commitid	10047E6D4C4222CC17E;

1.196
date	2008.03.23.20.55.18;	author tg;	state Exp;
branches;
next	1.195;
commitid	10047E6C3B86E22471A;

1.195
date	2008.03.05.18.49.15;	author tg;	state Exp;
branches
	1.195.2.1;
next	1.194;
commitid	10047CEEB2D48891B08;

1.194
date	2008.03.05.18.21.45;	author tg;	state Exp;
branches;
next	1.193;
commitid	10047CEE3A0658866A1;

1.193
date	2008.03.05.17.06.50;	author tg;	state Exp;
branches;
next	1.192;
commitid	10047CED336427DBA32;

1.192
date	2008.03.01.21.10.26;	author tg;	state Exp;
branches;
next	1.191;
commitid	10047C9C64165F71A5A;

1.191
date	2008.03.01.02.21.38;	author tg;	state Rel;
branches;
next	1.190;
commitid	10047C8BDBC04C448EC;

1.190
date	2008.02.27.12.49.54;	author tg;	state Exp;
branches;
next	1.189;
commitid	10047C55C8411C92E34;

1.189
date	2008.02.27.11.24.12;	author tg;	state Exp;
branches;
next	1.188;
commitid	10047C5484566B4BB83;

1.188
date	2008.02.27.01.00.10;	author tg;	state Exp;
branches;
next	1.187;
commitid	10047C4B5C65A58F987;

1.187
date	2008.02.26.20.43.11;	author tg;	state Exp;
branches;
next	1.186;
commitid	10047C479E866D4A3E1;

1.186
date	2008.02.26.20.35.25;	author tg;	state Exp;
branches;
next	1.185;
commitid	10047C4781501B5CDC4;

1.185
date	2008.02.24.15.48.43;	author tg;	state Exp;
branches;
next	1.184;
commitid	10047C190EF15EAB550;

1.184
date	2007.10.25.15.34.57;	author tg;	state Exp;
branches;
next	1.183;
commitid	1004720B7B6365367B4;

1.183
date	2007.10.25.15.23.10;	author tg;	state Exp;
branches;
next	1.182;
commitid	1004720B4ED147A8549;

1.182
date	2007.10.25.15.19.16;	author tg;	state Exp;
branches;
next	1.181;
commitid	1004720B40258F7886E;

1.181
date	2007.10.25.14.26.53;	author tg;	state Exp;
branches;
next	1.180;
commitid	1004720A7B12AC914F2;

1.180
date	2007.10.25.14.18.56;	author tg;	state Exp;
branches;
next	1.179;
commitid	1004720A5D93951F8E8;

1.179
date	2007.10.25.13.51.19;	author tg;	state Exp;
branches;
next	1.178;
commitid	10047209F6430D35627;

1.178
date	2007.10.18.20.32.33;	author tg;	state Exp;
branches;
next	1.177;
commitid	1004717C2CE427DDAE7;

1.177
date	2007.10.14.13.43.41;	author tg;	state Exp;
branches;
next	1.176;
commitid	10047121D1A56A79186;

1.176
date	2007.10.09.14.50.50;	author tg;	state Exp;
branches;
next	1.175;
commitid	100470B94ED68BBDDDB;

1.175
date	2007.09.09.18.06.41;	author tg;	state Exp;
branches;
next	1.174;
commitid	10046E436442CDF8871;

1.174
date	2007.08.20.14.06.10;	author tg;	state Exp;
branches;
next	1.173;
commitid	10046C99FE84A2D6F87;

1.173
date	2007.08.19.23.12.22;	author tg;	state Exp;
branches;
next	1.172;
commitid	10046C8CE5279B1E703;

1.172
date	2007.08.19.22.06.27;	author tg;	state Exp;
branches;
next	1.171;
commitid	10046C8BEC1249CCADD;

1.171
date	2007.08.18.00.22.09;	author tg;	state Exp;
branches;
next	1.170;
commitid	10046C63BBA357F61D4;

1.170
date	2007.08.13.19.39.21;	author tg;	state Exp;
branches;
next	1.169;
commitid	10046C0B31A6F414C8F;

1.169
date	2007.08.12.13.52.03;	author tg;	state Exp;
branches;
next	1.168;
commitid	10046BF1095780EDD8B;

1.168
date	2007.08.12.13.42.23;	author tg;	state Exp;
branches;
next	1.167;
commitid	10046BF0E4F7055959B;

1.167
date	2007.08.06.12.02.39;	author tg;	state Exp;
branches;
next	1.166;
commitid	10046B70DE6767A084B;

1.166
date	2007.07.31.11.11.25;	author tg;	state Exp;
branches;
next	1.165;
commitid	10046AF18D74B1B5DF4;

1.165
date	2007.07.26.13.23.52;	author tg;	state Exp;
branches;
next	1.164;
commitid	10046A8A03C41A44494;

1.164
date	2007.07.24.21.47.14;	author tg;	state Exp;
branches;
next	1.163;
commitid	10046A673784E7347BC;

1.163
date	2007.07.24.11.22.04;	author tg;	state Exp;
branches;
next	1.162;
commitid	10046A5E0B320FF6D65;

1.162
date	2007.07.23.14.28.52;	author tg;	state Exp;
branches;
next	1.161;
commitid	10046A4BABC39976409;

1.161
date	2007.07.22.14.01.50;	author tg;	state Exp;
branches;
next	1.160;
commitid	10046A36344350ACD7B;

1.160
date	2007.07.22.13.46.15;	author tg;	state Exp;
branches;
next	1.159;
commitid	10046A35F6D6E418744;

1.159
date	2007.07.22.13.38.26;	author tg;	state Exp;
branches;
next	1.158;
commitid	10046A35DE715FF102D;

1.158
date	2007.07.22.13.34.51;	author tg;	state Exp;
branches;
next	1.157;
commitid	10046A35CEC35BB7B5F;

1.157
date	2007.07.17.13.56.49;	author tg;	state Exp;
branches;
next	1.156;
commitid	100469CCA9508D35977;

1.156
date	2007.07.06.02.22.57;	author tg;	state Exp;
branches;
next	1.155;
commitid	100468DA78E140683C0;

1.155
date	2007.07.06.01.53.36;	author tg;	state Exp;
branches;
next	1.154;
commitid	100468DA0A207B760AD;

1.154
date	2007.07.01.21.47.08;	author tg;	state Exp;
branches;
next	1.153;
commitid	100468820CD07282054;

1.153
date	2007.07.01.21.27.03;	author tg;	state Exp;
branches;
next	1.152;
commitid	10046881C10526620B9;

1.152
date	2007.07.01.16.49.18;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004687DB08710A5AB8;

1.151
date	2007.06.27.23.12.59;	author tg;	state Exp;
branches;
next	1.150;
commitid	1004682EDC82ADECDD6;

1.150
date	2007.06.22.23.34.41;	author tg;	state Exp;
branches;
next	1.149;
commitid	100467C5C9519B9C52A;

1.149
date	2007.06.21.16.04.46;	author tg;	state Exp;
branches;
next	1.148;
commitid	100467AA19E39838981;

1.148
date	2007.06.17.00.50.09;	author tg;	state Exp;
branches;
next	1.147;
commitid	100467485062D380C8D;

1.147
date	2007.06.15.21.55.20;	author tg;	state Exp;
branches;
next	1.146;
commitid	10046730AA46E14A9D1;

1.146
date	2007.06.09.22.02.04;	author tg;	state Exp;
branches;
next	1.145;
commitid	100466B23725C5F0D89;

1.145
date	2007.06.09.22.01.42;	author tg;	state Exp;
branches;
next	1.144;
commitid	100466B23524CFD40D0;

1.144
date	2007.06.09.21.59.21;	author tg;	state Exp;
branches;
next	1.143;
commitid	100466B22B6778CEDAF;

1.143
date	2007.06.06.23.28.16;	author tg;	state Exp;
branches;
next	1.142;
commitid	1004667430836D68E66;

1.142
date	2007.06.06.21.36.29;	author tg;	state Exp;
branches;
next	1.141;
commitid	100466728AC5CB298E8;

1.141
date	2007.06.05.19.48.47;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004665BE264E72FCFA;

1.140
date	2007.06.05.19.35.13;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004665BACE04B94857;

1.139
date	2007.06.04.21.33.28;	author tg;	state Exp;
branches;
next	1.138;
commitid	100466485304A0BD517;

1.138
date	2007.06.04.21.27.53;	author tg;	state Exp;
branches;
next	1.137;
commitid	10046648335104B0B82;

1.137
date	2007.05.24.23.07.19;	author tg;	state Exp;
branches;
next	1.136;
commitid	10046561A9326851C73;

1.136
date	2007.05.24.19.50.38;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004655EC9E76698127;

1.135
date	2007.05.22.19.31.01;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004653450509FD4B71;

1.134
date	2007.05.21.19.25.32;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004651F21443013C37;

1.133
date	2007.05.20.17.53.13;	author tg;	state Exp;
branches;
next	1.132;
commitid	10046508B0376038FC6;

1.132
date	2007.05.13.19.18.26;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004647649434DA3FE1;

1.131
date	2007.05.13.19.14.05;	author tg;	state Exp;
branches;
next	1.130;
commitid	100464763537E100BDF;

1.130
date	2007.05.13.18.33.29;	author tg;	state Exp;
branches;
next	1.129;
commitid	100464759DE15635029;

1.129
date	2007.05.13.17.51.23;	author tg;	state Exp;
branches;
next	1.128;
commitid	10046474FB1292DF336;

1.128
date	2007.05.10.19.08.48;	author tg;	state Exp;
branches;
next	1.127;
commitid	10046436DC35AC3B04F;

1.127
date	2007.04.24.10.42.02;	author tg;	state Exp;
branches
	1.127.2.1;
next	1.126;
commitid	100462DDE7C6EC3BD7F;

1.126
date	2007.04.23.20.37.16;	author tg;	state Exp;
branches;
next	1.125;
commitid	100462D18E37B6B8D16;

1.125
date	2007.04.23.14.04.38;	author tg;	state Exp;
branches;
next	1.124;
commitid	100462CBCFC051E209E;

1.124
date	2007.04.17.23.51.32;	author tg;	state Exp;
branches;
next	1.123;
commitid	10046255D8C44AF10A4;

1.123
date	2007.04.15.12.09.57;	author tg;	state Exp;
branches;
next	1.122;
commitid	100462215D23B394727;

1.122
date	2007.04.15.10.45.59;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004622020D73FDDAF8;

1.121
date	2007.03.14.02.41.09;	author tg;	state Exp;
branches;
next	1.120;
commitid	10045F760A869FD5E0F;

1.120
date	2007.03.10.18.16.27;	author tg;	state Exp;
branches;
next	1.119;
commitid	10045F2F60A6B49F58A;

1.119
date	2007.03.10.00.42.00;	author tg;	state Exp;
branches;
next	1.118;
commitid	10045F1FEDD0DDDFF00;

1.118
date	2007.03.04.05.14.10;	author tg;	state Exp;
branches;
next	1.117;
commitid	10045EA559E18A98F24;

1.117
date	2007.03.04.05.04.54;	author tg;	state Exp;
branches;
next	1.116;
commitid	10045EA538D5570C8FE;

1.116
date	2007.03.04.04.36.45;	author tg;	state Exp;
branches;
next	1.115;
commitid	10045EA4CCF3ED98D2A;

1.115
date	2007.03.04.03.04.27;	author tg;	state Exp;
branches;
next	1.114;
commitid	10045EA374B3374AB35;

1.114
date	2007.03.04.00.13.16;	author tg;	state Exp;
branches;
next	1.113;
commitid	10045EA0F2F6674C8B9;

1.113
date	2007.03.03.21.36.07;	author tg;	state Exp;
branches;
next	1.112;
commitid	10045E9EA54328B08FC;

1.112
date	2007.02.16.17.46.42;	author tg;	state Exp;
branches;
next	1.111;
commitid	10045D5EDDE0036A745;

1.111
date	2007.02.07.02.31.06;	author tg;	state Exp;
branches;
next	1.110;
commitid	10045C93A007420BE03;

1.110
date	2007.01.26.18.27.34;	author tg;	state Exp;
branches;
next	1.109;
commitid	10045BA47F3716BA1F6;

1.109
date	2007.01.18.16.05.05;	author tg;	state Exp;
branches;
next	1.108;
commitid	10045AF9AC06E556EEF;

1.108
date	2007.01.18.15.50.32;	author tg;	state Exp;
branches;
next	1.107;
commitid	10045AF974442B3F2AC;

1.107
date	2007.01.18.01.03.10;	author tg;	state Exp;
branches;
next	1.106;
commitid	10045AEC75E6EC0A7E3;

1.106
date	2007.01.18.00.10.16;	author tg;	state Exp;
branches;
next	1.105;
commitid	10045AEBAEC2A958426;

1.105
date	2007.01.17.23.54.39;	author tg;	state Exp;
branches;
next	1.104;
commitid	10045AEB75443B113F8;

1.104
date	2007.01.17.23.18.55;	author tg;	state Exp;
branches;
next	1.103;
commitid	10045AEAEED31DCCB57;

1.103
date	2007.01.17.23.10.14;	author tg;	state Exp;
branches;
next	1.102;
commitid	10045AEACE617745030;

1.102
date	2007.01.17.23.04.19;	author tg;	state Exp;
branches;
next	1.101;
commitid	10045AEAB814721728C;

1.101
date	2007.01.17.22.51.46;	author tg;	state Exp;
branches;
next	1.100;
commitid	10045AEA86F7FE51B97;

1.100
date	2007.01.17.21.42.23;	author tg;	state Exp;
branches;
next	1.99;
commitid	10045AE984A425BEE7A;

1.99
date	2007.01.17.01.24.29;	author tg;	state Exp;
branches;
next	1.98;
commitid	10045AD7A912A404713;

1.98
date	2007.01.15.02.48.27;	author tg;	state Exp;
branches;
next	1.97;
commitid	10045AAEB8E4EE42CAE;

1.97
date	2007.01.15.00.38.20;	author tg;	state Exp;
branches;
next	1.96;
commitid	10045AACD0F0A446E5A;

1.96
date	2007.01.12.10.18.21;	author tg;	state Exp;
branches
	1.96.2.1;
next	1.95;
commitid	10045A76059104E0EFB;

1.95
date	2007.01.12.02.02.21;	author tg;	state Exp;
branches;
next	1.94;
commitid	10045A6EC445F862407;

1.94
date	2007.01.12.01.49.28;	author tg;	state Exp;
branches;
next	1.93;
commitid	10045A6E8B92FCAC95A;

1.93
date	2007.01.12.00.25.40;	author tg;	state Exp;
branches;
next	1.92;
commitid	10045A6D3B866AF7B2F;

1.92
date	2007.01.11.00.32.31;	author tg;	state Exp;
branches;
next	1.91;
commitid	10045A5858664A950E2;

1.91
date	2007.01.06.18.48.27;	author tg;	state Exp;
branches;
next	1.90;
commitid	100459FEF0A70C6A5DA;

1.90
date	2007.01.06.17.08.14;	author tg;	state Exp;
branches;
next	1.89;
commitid	100459FD7720F90D30E;

1.89
date	2007.01.03.22.43.48;	author tg;	state Exp;
branches;
next	1.88;
commitid	100459C318675D901E0;

1.88
date	2006.12.11.16.09.49;	author tg;	state Exp;
branches;
next	1.87;
commitid	100457D82CF336F1707;

1.87
date	2006.12.06.13.46.28;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004576C9B26DDF99FB;

1.86
date	2006.11.19.20.43.14;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004560C1B06C73EF4A;

1.85
date	2006.11.19.16.43.43;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004560891159DD45F6;

1.84
date	2006.11.16.13.35.00;	author tg;	state Exp;
branches;
next	1.83;
commitid	100455C691B5B4E2676;

1.83
date	2006.11.12.14.58.15;	author tg;	state Exp;
branches;
next	1.82;
commitid	100455735A7145E26AA;

1.82
date	2006.11.12.13.15.26;	author tg;	state Exp;
branches;
next	1.81;
commitid	10045571E7C6CC49355;

1.81
date	2006.11.12.10.44.42;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004556FB165B715FFA;

1.80
date	2006.11.10.07.52.03;	author tg;	state Exp;
branches;
next	1.79;
commitid	10045542F8269E05F56;

1.79
date	2006.11.10.07.18.57;	author tg;	state Exp;
branches;
next	1.78;
commitid	100455427B90A1F6E32;

1.78
date	2006.11.10.06.53.27;	author tg;	state Exp;
branches;
next	1.77;
commitid	100455421CB6900D8A1;

1.77
date	2006.11.10.06.45.28;	author tg;	state Exp;
branches;
next	1.76;
commitid	10045541FC2382F56E4;

1.76
date	2006.11.10.06.27.09;	author tg;	state Exp;
branches;
next	1.75;
commitid	10045541B9967DE13F7;

1.75
date	2006.11.10.06.16.25;	author tg;	state Exp;
branches;
next	1.74;
commitid	100455419107E3FB2C1;

1.74
date	2006.11.10.05.23.13;	author tg;	state Exp;
branches;
next	1.73;
commitid	10045540CCB39485995;

1.73
date	2006.11.10.03.45.57;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004553F5FF71731A58;

1.72
date	2006.11.10.03.23.50;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004553F0C348A7A034;

1.71
date	2006.11.10.01.44.40;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004553D9465642DE5C;

1.70
date	2006.11.10.01.25.22;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004553D5195EC82FAA;

1.69
date	2006.11.10.01.19.17;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004553D39E1A79289C;

1.68
date	2006.11.10.01.13.52;	author tg;	state Exp;
branches;
next	1.67;
commitid	1004553D1A316532A65;

1.67
date	2006.11.09.23.55.52;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004553BFD0613CC553;

1.66
date	2006.11.09.23.39.16;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004553BC2C6319F8C2;

1.65
date	2006.11.09.22.18.10;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004553A9170C58FA40;

1.64
date	2006.11.09.22.11.08;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004553A78E6D004CA4;

1.63
date	2006.11.09.22.08.08;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004553A6D03FB3FB12;

1.62
date	2006.11.09.21.20.49;	author tg;	state Exp;
branches;
next	1.61;
commitid	10045539BBD70E1ADCD;

1.61
date	2006.11.09.21.00.13;	author tg;	state Exp;
branches;
next	1.60;
commitid	100455396D36774B042;

1.60
date	2006.11.09.20.53.42;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004553955D62299BF9;

1.59
date	2006.11.09.15.03.56;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004553437330FDC0C3;

1.58
date	2006.11.09.15.02.31;	author tg;	state Exp;
branches;
next	1.57;
commitid	100455343104AF09372;

1.57
date	2006.11.09.14.58.27;	author tg;	state Exp;
branches;
next	1.56;
commitid	100455342290BCF4F20;

1.56
date	2006.11.09.14.19.31;	author tg;	state Exp;
branches;
next	1.55;
commitid	100455339025D8787C5;

1.55
date	2006.11.09.00.39.27;	author tg;	state Exp;
branches;
next	1.54;
commitid	100455278AE1639F129;

1.54
date	2006.11.09.00.11.39;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004552723039ED92BA;

1.53
date	2006.11.08.23.50.47;	author tg;	state Exp;
branches;
next	1.52;
commitid	10045526D6A4C91763E;

1.52
date	2006.11.08.23.45.47;	author tg;	state Exp;
branches;
next	1.51;
commitid	10045526C372A4C60AB;

1.51
date	2006.11.08.23.23.41;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004552670E1A677D8A;

1.50
date	2006.11.05.17.01.47;	author tg;	state Exp;
branches;
next	1.49;
commitid	100454E18FF508FB3FE;

1.49
date	2006.11.05.15.31.37;	author tg;	state Exp;
branches;
next	1.48;
commitid	100454E03E319796BE0;

1.48
date	2006.11.05.12.11.14;	author tg;	state Exp;
branches;
next	1.47;
commitid	100454DD4E712F5401D;

1.47
date	2006.10.03.19.46.14;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004522BE1372DDCA9D;

1.46
date	2006.09.30.02.23.22;	author tg;	state Exp;
branches;
next	1.45;
commitid	100451DD52E2738424C;

1.45
date	2006.09.30.02.13.21;	author tg;	state Exp;
branches;
next	1.44;
commitid	100451DD2A867E0A573;

1.44
date	2006.09.21.22.05.46;	author tg;	state Exp;
branches;
next	1.43;
commitid	10045130CD03F43268E;

1.43
date	2006.09.21.22.03.23;	author tg;	state Exp;
branches;
next	1.42;
commitid	10045130C366B82F12F;

1.42
date	2006.08.28.01.40.54;	author tg;	state Exp;
branches;
next	1.41;
commitid	10044F2496074AF1C95;

1.41
date	2006.08.26.20.30.27;	author tg;	state Exp;
branches;
next	1.40;
commitid	10044F0AF574E06B6B7;

1.40
date	2006.08.24.20.35.40;	author tg;	state Exp;
branches;
next	1.39;
commitid	10044EE0D877DE1179E;

1.39
date	2006.08.22.22.49.37;	author tg;	state Exp;
branches;
next	1.38;
commitid	10044EB89CB27D175DB;

1.38
date	2006.08.22.22.22.07;	author tg;	state Exp;
branches;
next	1.37;
commitid	10044EB839D17F38107;

1.37
date	2006.08.22.22.21.20;	author tg;	state Exp;
branches;
next	1.36;
commitid	10044EB836E341B9D59;

1.36
date	2006.08.22.22.16.04;	author tg;	state Exp;
branches;
next	1.35;
commitid	10044EB821E410451C2;

1.35
date	2006.08.16.00.00.24;	author tg;	state Exp;
branches;
next	1.34;
commitid	10044E2602313DC1D93;

1.34
date	2006.08.15.23.54.09;	author tg;	state Exp;
branches;
next	1.33;
commitid	10044E25E9C6FDF8E57;

1.33
date	2006.08.15.23.43.30;	author tg;	state Exp;
branches
	1.33.2.1;
next	1.32;
commitid	10044E25C32521DB6A4;

1.32
date	2006.08.09.20.44.16;	author tg;	state Exp;
branches;
next	1.31;
commitid	10044DA49163318158B;

1.31
date	2006.08.02.11.33.37;	author tg;	state Exp;
branches;
next	1.30;
commitid	10044D08D5007719200;

1.30
date	2006.08.01.14.10.25;	author tg;	state Exp;
branches;
next	1.29;
commitid	10044CF60E04E385000;

1.29
date	2006.08.01.14.09.20;	author tg;	state Exp;
branches;
next	1.28;
commitid	10044CF609314C13CBE;

1.28
date	2006.08.01.12.22.26;	author tg;	state Exp;
branches;
next	1.27;
commitid	10044CF478D5EA22071;

1.27
date	2006.06.21.19.35.38;	author tg;	state Exp;
branches;
next	1.26;
commitid	10044999F9A63254C19;

1.26
date	2006.05.10.18.54.12;	author tg;	state Exp;
branches;
next	1.25;
commitid	100446236E6726083C8;

1.25
date	2006.03.19.18.06.32;	author tg;	state Exp;
branches;
next	1.24;
commitid	100441D9DAA7AB80F15;

1.24
date	2006.01.29.20.04.53;	author tg;	state Exp;
branches;
next	1.23;
commitid	10043DD1FE6328EF386;

1.23
date	2005.11.22.18.40.43;	author tg;	state Exp;
branches;
next	1.22;
commitid	108a438366254326;

1.22
date	2005.11.22.18.36.20;	author tg;	state Exp;
branches;
next	1.21;
commitid	659a438364faa8a1;

1.21
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.20;
commitid	76cc435e8d34d8ce;

1.20
date	2005.10.25.19.46.11;	author tg;	state Exp;
branches;
next	1.19;
commitid	6836435e8b86013e;

1.19
date	2005.10.21.12.41.56;	author tg;	state Exp;
branches;
next	1.18;
commitid	657d4358e1e6ede8;

1.18
date	2005.10.08.19.31.00;	author tg;	state Exp;
branches;
next	1.17;
commitid	512643481e5274c0;

1.17
date	2005.08.02.12.35.27;	author tg;	state Exp;
branches;
next	1.16;
commitid	6dd542ef687afd87;

1.16
date	2005.07.07.23.27.52;	author tg;	state Exp;
branches;
next	1.15;
commitid	419f42cdba670de9;

1.15
date	2005.07.05.22.00.20;	author tg;	state Exp;
branches;
next	1.14;
commitid	1b1c42cb0302f1c7;

1.14
date	2005.07.04.12.34.24;	author tg;	state Exp;
branches;
next	1.13;
commitid	4a8342c92cd61cc3;

1.13
date	2005.07.04.12.07.41;	author tg;	state Exp;
branches;
next	1.12;
commitid	638742c926619991;

1.12
date	2005.06.24.15.36.57;	author tg;	state Exp;
branches;
next	1.11;
commitid	e0142bc28a6abe3;

1.11
date	2005.06.08.21.51.22;	author tg;	state Exp;
branches;
next	1.10;
commitid	318442a76849872f;

1.10
date	2005.05.26.23.12.09;	author tg;	state Exp;
branches;
next	1.9;
commitid	3ad3429657d91460;

1.9
date	2005.05.26.23.01.30;	author tg;	state Exp;
branches;
next	1.8;
commitid	789f4296553dac75;

1.8
date	2005.05.25.23.31.08;	author tg;	state Exp;
branches;
next	1.7;
commitid	6fd242950a6e73e0;

1.7
date	2005.05.25.13.46.01;	author tg;	state Exp;
branches;
next	1.6;
commitid	503942948197230c;

1.6
date	2005.05.23.16.23.19;	author tg;	state Exp;
branches;
next	1.5;
commitid	1d3a429203880b55;

1.5
date	2005.05.23.15.36.55;	author tg;	state Exp;
branches;
next	1.4;
commitid	294b4291f8a10548;

1.4
date	2005.05.23.15.24.43;	author tg;	state Exp;
branches;
next	1.3;
commitid	fa04291f5c8f5c4;

1.3
date	2005.05.23.15.18.17;	author tg;	state Exp;
branches;
next	1.2;
commitid	3dc04291f43ca526;

1.2
date	2005.05.23.14.19.14;	author tg;	state Exp;
branches;
next	1.1;
commitid	5e9f4291e64f3f3e;

1.1
date	2005.05.23.03.06.09;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.701.2.1
date	2015.01.11.22.39.53;	author tg;	state Exp;
branches;
next	1.701.2.2;
commitid	10054B2FBC1440F88AD;

1.701.2.2
date	2015.01.25.15.35.51;	author tg;	state Exp;
branches;
next	1.701.2.3;
commitid	10054C50D442D861FBF;

1.701.2.3
date	2015.01.25.15.44.07;	author tg;	state Exp;
branches;
next	1.701.2.4;
commitid	10054C50F46587DFA27;

1.701.2.4
date	2015.03.01.15.43.05;	author tg;	state Exp;
branches;
next	1.701.2.5;
commitid	10054F33364551D895A;

1.701.2.5
date	2015.03.20.22.21.08;	author tg;	state Exp;
branches;
next	1.701.2.6;
commitid	100550C9D521FCB4274;

1.701.2.6
date	2015.04.12.22.32.33;	author tg;	state Exp;
branches;
next	1.701.2.7;
commitid	100552AF26A429AA816;

1.701.2.7
date	2015.04.19.19.18.21;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.634.2.1
date	2013.02.11.17.25.03;	author tg;	state Exp;
branches;
next	;
commitid	100511929846067390F;

1.608.2.1
date	2012.11.30.20.49.13;	author tg;	state Exp;
branches;
next	1.608.2.2;
commitid	10050B91BDD34E31558;

1.608.2.2
date	2012.12.04.01.26.32;	author tg;	state Exp;
branches;
next	1.608.2.3;
commitid	10050BD5149729CD584;

1.608.2.3
date	2012.12.05.19.58.33;	author tg;	state Exp;
branches;
next	1.608.2.4;
commitid	10050BFA7766B61F30F;

1.608.2.4
date	2012.12.07.23.46.29;	author tg;	state Exp;
branches;
next	1.608.2.5;
commitid	10050C27FDC255CF0A0;

1.608.2.5
date	2012.12.22.00.03.50;	author tg;	state Exp;
branches;
next	1.608.2.6;
commitid	10050D4F8C95001AF1D;

1.608.2.6
date	2013.01.01.21.20.08;	author tg;	state Exp;
branches;
next	1.608.2.7;
commitid	10050E352F23B706399;

1.608.2.7
date	2013.01.06.18.59.15;	author tg;	state Exp;
branches;
next	1.608.2.8;
commitid	10050E9C9931FE4587F;

1.608.2.8
date	2013.02.10.17.11.27;	author tg;	state Exp;
branches;
next	1.608.2.9;
commitid	1005117D46E22B420F2;

1.608.2.9
date	2013.02.10.23.59.36;	author tg;	state Exp;
branches;
next	1.608.2.10;
commitid	100511834521EDC159D;

1.608.2.10
date	2013.02.15.18.54.43;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.568.2.1
date	2012.07.20.22.51.43;	author tg;	state Exp;
branches;
next	1.568.2.2;
commitid	1005009E10A72E016E4;

1.568.2.2
date	2012.07.20.23.31.06;	author tg;	state Exp;
branches;
next	1.568.2.3;
commitid	1005009EA495F76B281;

1.568.2.3
date	2012.09.03.19.10.57;	author tg;	state Exp;
branches;
next	1.568.2.4;
commitid	100504500D439E09A42;

1.568.2.4
date	2013.02.11.00.27.19;	author tg;	state Exp;
branches;
next	1.568.2.5;
commitid	10051183A6D5475BB1E;

1.568.2.5
date	2013.02.15.18.54.54;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.484.2.1
date	2011.07.07.21.42.18;	author tg;	state Exp;
branches;
next	1.484.2.2;
commitid	1004E162810137500DE;

1.484.2.2
date	2011.07.16.13.16.44;	author tg;	state Exp;
branches;
next	1.484.2.3;
commitid	1004E218F373D0F49ED;

1.484.2.3
date	2011.07.16.16.04.16;	author tg;	state Exp;
branches;
next	1.484.2.4;
commitid	1004E21B64E3A80D0DC;

1.484.2.4
date	2011.07.26.17.17.30;	author tg;	state Exp;
branches;
next	1.484.2.5;
commitid	1004E2EF6BB28A13224;

1.484.2.5
date	2011.10.25.22.50.39;	author tg;	state Exp;
branches;
next	1.484.2.6;
commitid	1004EA73D456165B188;

1.484.2.6
date	2011.11.08.22.07.22;	author tg;	state Exp;
branches;
next	1.484.2.7;
commitid	1004EB9A7F80119200E;

1.484.2.7
date	2011.11.19.22.22.00;	author tg;	state Exp;
branches;
next	1.484.2.8;
commitid	1004EC82C02177E0E27;

1.484.2.8
date	2011.11.22.18.01.47;	author tg;	state Exp;
branches;
next	1.484.2.9;
commitid	1004ECBE39656891872;

1.484.2.9
date	2011.11.26.18.23.24;	author tg;	state Exp;
branches;
next	1.484.2.10;
commitid	1004ED12E8854A4E765;

1.484.2.10
date	2011.12.04.19.59.59;	author tg;	state Exp;
branches;
next	1.484.2.11;
commitid	1004EDBD1266A61D50A;

1.484.2.11
date	2011.12.11.18.18.28;	author tg;	state Exp;
branches;
next	1.484.2.12;
commitid	1004EE4F3FF0C99C8CA;

1.484.2.12
date	2011.12.31.02.25.33;	author tg;	state Exp;
branches;
next	1.484.2.13;
commitid	1004EFE72A268DB0925;

1.484.2.13
date	2011.12.31.02.31.44;	author tg;	state Exp;
branches;
next	1.484.2.14;
commitid	1004EFE742752FEB05E;

1.484.2.14
date	2012.02.11.15.25.33;	author tg;	state Exp;
branches;
next	1.484.2.15;
commitid	1004F36887A2CA1070B;

1.484.2.15
date	2012.03.03.21.41.45;	author tg;	state Exp;
branches;
next	1.484.2.16;
commitid	1004F529027715CBC71;

1.484.2.16
date	2012.03.24.21.22.43;	author tg;	state Exp;
branches;
next	1.484.2.17;
commitid	1004F6E3A967ACCD93A;

1.484.2.17
date	2012.04.06.14.40.23;	author tg;	state Exp;
branches;
next	1.484.2.18;
commitid	1004F7F0056695FD460;

1.484.2.18
date	2012.04.06.15.24.15;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0AB3308BB1BB;

1.362.2.1
date	2009.11.28.14.27.54;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.336.2.1
date	2009.08.30.20.56.09;	author tg;	state Exp;
branches;
next	;
commitid	1004A9AE59203C5D0BB;

1.261.2.1
date	2008.11.19.21.08.26;	author tg;	state Exp;
branches;
next	1.261.2.2;
commitid	1004924805F7FD79D3D;

1.261.2.2
date	2008.11.22.13.20.35;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.206.2.1
date	2008.04.20.01.40.44;	author tg;	state Exp;
branches;
next	;
commitid	100480A9F0728CFA8F8;

1.195.2.1
date	2008.04.22.13.29.32;	author tg;	state Exp;
branches;
next	1.195.2.2;
commitid	100480DE80F32BAA72D;

1.195.2.2
date	2008.05.19.18.41.30;	author tg;	state Exp;
branches;
next	1.195.2.3;
commitid	1004831C9A63DA06745;

1.195.2.3
date	2008.07.11.11.49.30;	author tg;	state Exp;
branches;
next	1.195.2.4;
commitid	100487748D62394D033;

1.195.2.4
date	2008.07.18.13.29.46;	author tg;	state Exp;
branches;
next	1.195.2.5;
commitid	10048809AD278B142AC;

1.195.2.5
date	2008.12.14.00.07.48;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.127.2.1
date	2007.05.13.19.29.38;	author tg;	state Exp;
branches;
next	1.127.2.2;
commitid	1004647668D4636830B;

1.127.2.2
date	2007.05.22.21.34.30;	author tg;	state Exp;
branches;
next	1.127.2.3;
commitid	100465361F206BD615D;

1.127.2.3
date	2007.05.26.22.31.21;	author tg;	state Exp;
branches;
next	1.127.2.4;
commitid	1004658B53E3CC3259F;

1.127.2.4
date	2007.07.05.11.49.22;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.96.2.1
date	2007.03.03.21.37.59;	author tg;	state Exp;
branches;
next	1.96.2.2;
commitid	10045E9EAC27ABA6ADF;

1.96.2.2
date	2007.03.03.22.38.25;	author tg;	state Exp;
branches;
next	1.96.2.3;
commitid	10045E9F8F5395F55BB;

1.96.2.3
date	2007.03.03.22.51.18;	author tg;	state Exp;
branches;
next	1.96.2.4;
commitid	10045E9FBFC58BC83D0;

1.96.2.4
date	2007.03.03.23.38.38;	author tg;	state Exp;
branches;
next	;
commitid	10045EA07113BF2F32A;

1.33.2.1
date	2006.08.15.23.49.53;	author tg;	state Exp;
branches;
next	1.33.2.2;
commitid	10044E25D6841FC583E;

1.33.2.2
date	2006.08.18.19.02.22;	author tg;	state Exp;
branches;
next	1.33.2.3;
commitid	10044E60ECD062A26B8;

1.33.2.3
date	2006.08.24.20.52.15;	author tg;	state Exp;
branches;
next	1.33.2.4;
commitid	10044EE117A130AF943;

1.33.2.4
date	2006.08.24.21.02.36;	author tg;	state Exp;
branches;
next	1.33.2.5;
commitid	10044EE13F90DF08C9B;

1.33.2.5
date	2006.08.28.01.49.20;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.880
log
@sync mips16 GCC bug workaround with jupp
@
text
@/*	$OpenBSD: sh.h,v 1.35 2015/09/10 22:48:58 nicm Exp $	*/
/*	$OpenBSD: shf.h,v 1.6 2005/12/11 18:53:51 deraadt Exp $	*/
/*	$OpenBSD: table.h,v 1.8 2012/02/19 07:52:30 otto Exp $	*/
/*	$OpenBSD: tree.h,v 1.10 2005/03/28 21:28:22 deraadt Exp $	*/
/*	$OpenBSD: expand.h,v 1.7 2015/09/01 13:12:31 tedu Exp $	*/
/*	$OpenBSD: lex.h,v 1.13 2013/03/03 19:11:34 guenther Exp $	*/
/*	$OpenBSD: proto.h,v 1.35 2013/09/04 15:49:19 millert Exp $	*/
/*	$OpenBSD: c_test.h,v 1.4 2004/12/20 11:34:26 otto Exp $	*/
/*	$OpenBSD: tty.h,v 1.5 2004/12/20 11:34:26 otto Exp $	*/

/*-
 * Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *	       2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *	       2019, 2020
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un‐
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 */

#ifdef __dietlibc__
/* XXX imake style */
#define _BSD_SOURCE	/* live, BSD, live❣ */
#endif

#if HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <sys/ioctl.h>
#if HAVE_SYS_SYSMACROS_H
#include <sys/sysmacros.h>
#endif
#if HAVE_SYS_MKDEV_H
#include <sys/mkdev.h>
#endif
#if HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif
#if HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#include <sys/stat.h>
#include <sys/wait.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#if HAVE_IO_H
#include <io.h>
#endif
#if HAVE_LIBGEN_H
#include <libgen.h>
#endif
#if HAVE_LIBUTIL_H
#include <libutil.h>
#endif
#include <limits.h>
#if HAVE_PATHS_H
#include <paths.h>
#endif
#include <pwd.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#if HAVE_STDINT_H
#include <stdint.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#if HAVE_TERMIOS_H
#include <termios.h>
#else
/* shudder… */
#include <termio.h>
#endif
#ifdef _ISC_UNIX
/* XXX imake style */
#include <sys/sioctl.h>
#endif
#if HAVE_ULIMIT_H
#include <ulimit.h>
#endif
#include <unistd.h>
#if HAVE_VALUES_H
#include <values.h>
#endif
#ifdef MIRBSD_BOOTFLOPPY
#include <wchar.h>
#endif

/* monkey-patch known-bad offsetof versions to quell a warning */
#if (defined(__KLIBC__) || defined(__dietlibc__)) && \
    ((defined(__GNUC__) && (__GNUC__ > 3)) || defined(__NWCC__))
#undef offsetof
#define offsetof(s, e)		__builtin_offsetof(s, e)
#endif

#undef __attribute__
#if HAVE_ATTRIBUTE_BOUNDED
#define MKSH_A_BOUNDED(x,y,z)	__attribute__((__bounded__(x, y, z)))
#else
#define MKSH_A_BOUNDED(x,y,z)	/* nothing */
#endif
#if HAVE_ATTRIBUTE_FORMAT
#define MKSH_A_FORMAT(x,y,z)	__attribute__((__format__(x, y, z)))
#else
#define MKSH_A_FORMAT(x,y,z)	/* nothing */
#endif
#if HAVE_ATTRIBUTE_NORETURN
#define MKSH_A_NORETURN		__attribute__((__noreturn__))
#else
#define MKSH_A_NORETURN		/* nothing */
#endif
#if HAVE_ATTRIBUTE_PURE
#define MKSH_A_PURE		__attribute__((__pure__))
#else
#define MKSH_A_PURE		/* nothing */
#endif
#if HAVE_ATTRIBUTE_UNUSED
#define MKSH_A_UNUSED		__attribute__((__unused__))
#else
#define MKSH_A_UNUSED		/* nothing */
#endif
#if HAVE_ATTRIBUTE_USED
#define MKSH_A_USED		__attribute__((__used__))
#else
#define MKSH_A_USED		/* nothing */
#endif

#if defined(MirBSD) && (MirBSD >= 0x09A1) && \
    defined(__ELF__) && defined(__GNUC__) && \
    !defined(__llvm__) && !defined(__NWCC__)
/*
 * We got usable __IDSTRING __COPYRIGHT __RCSID __SCCSID macros
 * which work for all cases; no need to redefine them using the
 * "portable" macros from below when we might have the "better"
 * gcc+ELF specific macros or other system dependent ones.
 */
#else
#undef __IDSTRING
#undef __IDSTRING_CONCAT
#undef __IDSTRING_EXPAND
#undef __COPYRIGHT
#undef __RCSID
#undef __SCCSID
#define __IDSTRING_CONCAT(l,p)		__LINTED__ ## l ## _ ## p
#define __IDSTRING_EXPAND(l,p)		__IDSTRING_CONCAT(l,p)
#ifdef MKSH_DONT_EMIT_IDSTRING
#define __IDSTRING(prefix, string)	/* nothing */
#elif defined(__ELF__) && defined(__GNUC__) && \
    !(defined(__GNUC__) && defined(__mips16) && (__GNUC__ >= 8)) && \
    !defined(__llvm__) && !defined(__NWCC__) && !defined(NO_ASM)
#define __IDSTRING(prefix, string)				\
	__asm__(".section .comment"				\
	"\n	.ascii	\"@@(\"\"#)" #prefix ": \""		\
	"\n	.asciz	\"" string "\""				\
	"\n	.previous")
#else
#define __IDSTRING(prefix, string)				\
	static const char __IDSTRING_EXPAND(__LINE__,prefix) []	\
	    MKSH_A_USED = "@@(""#)" #prefix ": " string
#endif
#define __COPYRIGHT(x)		__IDSTRING(copyright,x)
#define __RCSID(x)		__IDSTRING(rcsid,x)
#define __SCCSID(x)		__IDSTRING(sccsid,x)
#endif

#ifdef EXTERN
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.877 2019/12/30 03:45:14 tg Exp $");
#endif
#define MKSH_VERSION "R57 2019/12/29"

/* arithmetic types: C implementation */
#if !HAVE_CAN_INTTYPES
#if !HAVE_CAN_UCBINTS
typedef signed int int32_t;
typedef unsigned int uint32_t;
#else
typedef u_int32_t uint32_t;
#endif
#endif

/* arithmetic types: shell arithmetics */
#ifdef MKSH_LEGACY_MODE
/*
 * POSIX demands these to be the C environment's long type
 */
typedef long mksh_ari_t;
typedef unsigned long mksh_uari_t;
#else
/*
 * These types are exactly 32 bit wide; signed and unsigned
 * integer wraparound, even across division and modulo, for
 * any shell code using them, is guaranteed.
 */
typedef int32_t mksh_ari_t;
typedef uint32_t mksh_uari_t;
#endif

/* boolean type (no <stdbool.h> deliberately) */
typedef unsigned char mksh_bool;
#undef bool
/* false MUST equal the same 0 as written by static storage initialisation */
#undef false
#undef true
/* access macros for boolean type */
#define bool		mksh_bool
/* values must have identity mapping between mksh_bool and short */
#define false		0
#define true		1
/* make any-type into bool or short */
#define tobool(cond)	((cond) ? true : false)

/* char (octet) type: C implementation */
#if !HAVE_CAN_INT8TYPE
#if !HAVE_CAN_UCBINT8
typedef unsigned char uint8_t;
#else
typedef u_int8_t uint8_t;
#endif
#endif

/* other standard types */

#if !HAVE_RLIM_T
typedef unsigned long rlim_t;
#endif

#if !HAVE_SIG_T
#undef sig_t
typedef void (*sig_t)(int);
#endif

#ifdef MKSH_TYPEDEF_SIG_ATOMIC_T
typedef MKSH_TYPEDEF_SIG_ATOMIC_T sig_atomic_t;
#endif

#ifdef MKSH_TYPEDEF_SSIZE_T
typedef MKSH_TYPEDEF_SSIZE_T ssize_t;
#endif

#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
#define MKSH_SHF_NO_INLINE
#endif

/* do not merge these conditionals as neatcc’s preprocessor is simple */
#ifdef __neatcc__
/* parsing of comma operator <,> in expressions broken */
#define MKSH_SHF_NO_INLINE
#endif

/* un-do vendor damage */

#undef BAD		/* AIX defines that somewhere */
#undef PRINT		/* LynxOS defines that somewhere */
#undef flock		/* SCO UnixWare defines that to flock64 but ENOENT */


#ifndef MKSH_INCLUDES_ONLY

/* EBCDIC fun */

/* see the large comment in shf.c for an EBCDIC primer */

#if defined(MKSH_FOR_Z_OS) && defined(__MVS__) && defined(__IBMC__) && defined(__CHARSET_LIB)
# if !__CHARSET_LIB && !defined(MKSH_EBCDIC)
#  error "Please compile with Build.sh -E for EBCDIC!"
# endif
# if __CHARSET_LIB && defined(MKSH_EBCDIC)
#  error "Please compile without -E argument to Build.sh for ASCII!"
# endif
# if __CHARSET_LIB && !defined(_ENHANCED_ASCII_EXT)
   /* go all-out on ASCII */
#  define _ENHANCED_ASCII_EXT 0xFFFFFFFF
# endif
#endif

/* extra types */

/* getrusage does not exist on OS/2 kLIBC */
#if !HAVE_GETRUSAGE && !defined(__OS2__)
#undef rusage
#undef RUSAGE_SELF
#undef RUSAGE_CHILDREN
#define rusage mksh_rusage
#define RUSAGE_SELF		0
#define RUSAGE_CHILDREN		-1

struct rusage {
	struct timeval ru_utime;
	struct timeval ru_stime;
};
#endif

/* extra macros */

#ifndef timerclear
#define timerclear(tvp)							\
	do {								\
		(tvp)->tv_sec = (tvp)->tv_usec = 0;			\
	} while (/* CONSTCOND */ 0)
#endif
#ifndef timeradd
#define timeradd(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (/* CONSTCOND */ 0)
#endif
#ifndef timersub
#define timersub(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (/* CONSTCOND */ 0)
#endif

#ifdef MKSH__NO_PATH_MAX
#undef PATH_MAX
#else
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX	MAXPATHLEN
#else
#define PATH_MAX	1024
#endif
#endif
#endif
#ifndef SIZE_MAX
#ifdef SIZE_T_MAX
#define SIZE_MAX	SIZE_T_MAX
#else
#define SIZE_MAX	((size_t)-1)
#endif
#endif
#ifndef S_ISLNK
#define S_ISLNK(m)	((m & 0170000) == 0120000)
#endif
#ifndef S_ISSOCK
#define S_ISSOCK(m)	((m & 0170000) == 0140000)
#endif
#if !defined(S_ISCDF) && defined(S_CDF)
#define S_ISCDF(m)	(S_ISDIR(m) && ((m) & S_CDF))
#endif
#ifndef DEFFILEMODE
#define DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
#endif


/* determine ksh_NSIG: first, use the traditional definitions */
#undef ksh_NSIG
#if defined(NSIG)
#define ksh_NSIG (NSIG)
#elif defined(_NSIG)
#define ksh_NSIG (_NSIG)
#elif defined(SIGMAX)
#define ksh_NSIG (SIGMAX + 1)
#elif defined(_SIGMAX)
#define ksh_NSIG (_SIGMAX + 1)
#elif defined(NSIG_MAX)
#define ksh_NSIG (NSIG_MAX)
#elif defined(MKSH_FOR_Z_OS)
#define ksh_NSIG 40
#else
# error Please have your platform define NSIG.
#endif
/* range-check them */
#if (ksh_NSIG < 1)
# error Your NSIG value is not positive.
#undef ksh_NSIG
#endif
/* second, see if the new POSIX definition is available */
#ifdef NSIG_MAX
#if (NSIG_MAX < 2)
/* and usable */
# error Your NSIG_MAX value is too small.
#undef NSIG_MAX
#elif (ksh_NSIG > NSIG_MAX)
/* and realistic */
# error Your NSIG value is larger than your NSIG_MAX value.
#undef NSIG_MAX
#else
/* since it’s usable, prefer it */
#undef ksh_NSIG
#define ksh_NSIG (NSIG_MAX)
#endif
/* if NSIG_MAX is now still defined, use sysconf(_SC_NSIG) at runtime */
#endif
/* third, for cpp without the error directive, default */
#ifndef ksh_NSIG
#define ksh_NSIG 64
#endif

#define ksh_sigmask(sig) (((sig) < 1 || (sig) > 127) ? 255 : 128 + (sig))


/* OS-dependent additions (functions, variables, by OS) */

#ifdef MKSH_EXE_EXT
#undef MKSH_EXE_EXT
#define MKSH_EXE_EXT	".exe"
#else
#define MKSH_EXE_EXT	""
#endif

#ifdef __OS2__
#define MKSH_UNIXROOT	"/@@unixroot"
#else
#define MKSH_UNIXROOT	""
#endif

#ifdef MKSH_DOSPATH
#ifndef __GNUC__
# error GCC extensions needed later on
#endif
#define MKSH_PATHSEPS	";"
#define MKSH_PATHSEPC	';'
#else
#define MKSH_PATHSEPS	":"
#define MKSH_PATHSEPC	':'
#endif

#if !HAVE_FLOCK_DECL
extern int flock(int, int);
#endif

#if !HAVE_GETTIMEOFDAY
#define mksh_TIME(tv) do {		\
	(tv).tv_usec = 0;		\
	(tv).tv_sec = time(NULL);	\
} while (/* CONSTCOND */ 0)
#else
#define mksh_TIME(tv) gettimeofday(&(tv), NULL)
#endif

#if !HAVE_GETRUSAGE
extern int getrusage(int, struct rusage *);
#endif

#if !HAVE_MEMMOVE
/* we assume either memmove or bcopy exist, at the moment */
#define memmove(dst, src, len)	bcopy((src), (dst), (len))
#endif

#if !HAVE_REVOKE_DECL
extern int revoke(const char *);
#endif

#if defined(DEBUG) || !HAVE_STRERROR
#undef strerror
#define strerror		/* poisoned */ dontuse_strerror
#define cstrerror		/* replaced */ cstrerror
extern const char *cstrerror(int);
#else
#define cstrerror(errnum)	((const char *)strerror(errnum))
#endif

#if !HAVE_STRLCPY
size_t strlcpy(char *, const char *, size_t);
#endif

#ifdef __INTERIX
/* XXX imake style */
#define makedev mkdev
extern int __cdecl seteuid(uid_t);
extern int __cdecl setegid(gid_t);
#endif

#if defined(__COHERENT__)
#ifndef O_ACCMODE
/* this need not work everywhere, take care */
#define O_ACCMODE	(O_RDONLY | O_WRONLY | O_RDWR)
#endif
#endif

#ifndef O_BINARY
#define O_BINARY	0
#endif

#ifndef O_MAYEXEC
#define O_MAYEXEC	0
#endif

#ifdef MKSH__NO_SYMLINK
#undef S_ISLNK
#define S_ISLNK(m)	(/* CONSTCOND */ 0)
#define mksh_lstat	stat
#else
#define mksh_lstat	lstat
#endif

#if HAVE_TERMIOS_H
#define mksh_ttyst	struct termios
#define mksh_tcget(fd,st) tcgetattr((fd), (st))
#define mksh_tcset(fd,st) tcsetattr((fd), TCSADRAIN, (st))
#else
#define mksh_ttyst	struct termio
#define mksh_tcget(fd,st) ioctl((fd), TCGETA, (st))
#define mksh_tcset(fd,st) ioctl((fd), TCSETAW, (st))
#endif

#ifndef ISTRIP
#define ISTRIP		0
#endif

#ifdef MKSH_EBCDIC
#define KSH_BEL		'\a'
#define KSH_ESC		047
#define KSH_ESC_STRING	"\047"
#define KSH_VTAB	'\v'
#else
/*
 * According to the comments in pdksh, \007 seems to be more portable
 * than \a (HP-UX cc, Ultrix cc, old pcc, etc.) so we avoid the escape
 * sequence if ASCII can be assumed.
 */
#define KSH_BEL		7
#define KSH_ESC		033
#define KSH_ESC_STRING	"\033"
#define KSH_VTAB	11
#endif


/* some useful #defines */
#ifdef EXTERN
# define E_INIT(i) = i
#else
# define E_INIT(i)
# define EXTERN extern
# define EXTERN_DEFINED
#endif

/* define bit in flag */
#define BIT(i)		(1U << (i))
#define NELEM(a)	(sizeof(a) / sizeof((a)[0]))

/*
 * Make MAGIC a char that might be printed to make bugs more obvious, but
 * not a char that is used often. Also, can't use the high bit as it causes
 * portability problems (calling strchr(x, 0x80 | 'x') is error prone).
 *
 * MAGIC can be followed by MAGIC (to escape the octet itself) or one of:
 * ' !)*,-?[]{|}' 0x80|' !*+?@@' (probably… hysteric raisins abound)
 *
 * The |0x80 is likely unsafe on EBCDIC :( though the listed chars are
 * low-bit7 at least on cp1047 so YMMV
 */
#define MAGIC		KSH_BEL	/* prefix for *?[!{,} during expand */
#define ISMAGIC(c)	(ord(c) == ORD(MAGIC))

EXTERN const char *safe_prompt; /* safe prompt if PS1 substitution fails */

#ifdef MKSH_LEGACY_MODE
#define KSH_VERSIONNAME_ISLEGACY	"LEGACY"
#else
#define KSH_VERSIONNAME_ISLEGACY	"MIRBSD"
#endif
#ifdef MKSH_WITH_TEXTMODE
#define KSH_VERSIONNAME_TEXTMODE	" +TEXTMODE"
#else
#define KSH_VERSIONNAME_TEXTMODE	""
#endif
#ifdef MKSH_EBCDIC
#define KSH_VERSIONNAME_EBCDIC		" +EBCDIC"
#else
#define KSH_VERSIONNAME_EBCDIC		""
#endif
#ifndef KSH_VERSIONNAME_VENDOR_EXT
#define KSH_VERSIONNAME_VENDOR_EXT	""
#endif
EXTERN const char initvsn[] E_INIT("KSH_VERSION=@@(#)" KSH_VERSIONNAME_ISLEGACY \
    " KSH " MKSH_VERSION KSH_VERSIONNAME_EBCDIC KSH_VERSIONNAME_TEXTMODE \
    KSH_VERSIONNAME_VENDOR_EXT);
#define KSH_VERSION	(initvsn + /* "KSH_VERSION=@@(#)" */ 16)

EXTERN const char digits_uc[] E_INIT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
EXTERN const char digits_lc[] E_INIT("0123456789abcdefghijklmnopqrstuvwxyz");

/*
 * Evil hack for const correctness due to API brokenness
 */
union mksh_cchack {
	char *rw;
	const char *ro;
};
union mksh_ccphack {
	char **rw;
	const char **ro;
};

/*
 * Evil hack since casting uint to sint is implementation-defined
 */
typedef union {
	mksh_ari_t i;
	mksh_uari_t u;
} mksh_ari_u;

/* for const debugging */
#if defined(DEBUG) && defined(__GNUC__) && !defined(__ICC) && \
    !defined(__INTEL_COMPILER) && !defined(__SUNPRO_C)
char *ucstrchr(char *, int);
char *ucstrstr(char *, const char *);
#undef strchr
#define strchr ucstrchr
#define strstr ucstrstr
#define cstrchr(s,c) ({			\
	union mksh_cchack in, out;	\
					\
	in.ro = (s);			\
	out.rw = ucstrchr(in.rw, (c));	\
	(out.ro);			\
})
#define cstrstr(b,l) ({			\
	union mksh_cchack in, out;	\
					\
	in.ro = (b);			\
	out.rw = ucstrstr(in.rw, (l));	\
	(out.ro);			\
})
#define vstrchr(s,c)	(cstrchr((s), (c)) != NULL)
#define vstrstr(b,l)	(cstrstr((b), (l)) != NULL)
#else /* !DEBUG, !gcc */
#define cstrchr(s,c)	((const char *)strchr((s), (c)))
#define cstrstr(s,c)	((const char *)strstr((s), (c)))
#define vstrchr(s,c)	(strchr((s), (c)) != NULL)
#define vstrstr(b,l)	(strstr((b), (l)) != NULL)
#endif

#if defined(DEBUG) || defined(__COVERITY__)
#ifndef DEBUG_LEAKS
#define DEBUG_LEAKS
#endif
#endif

#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 571)
#error Must run Build.sh to compile this.
extern void thiswillneverbedefinedIhope(void);
int
im_sorry_dave(void)
{
	/* I’m sorry, Dave. I’m afraid I can’t do that. */
	return (thiswillneverbedefinedIhope());
}
#endif

/* use this ipv strchr(s, 0) but no side effects in s! */
#define strnul(s)	((s) + strlen((const void *)s))

#define utf_ptradjx(src, dst) do {					\
	(dst) = (src) + utf_ptradj(src);				\
} while (/* CONSTCOND */ 0)

#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
#define strdupx(d, s, ap) do {						\
	(d) = strdup_i((s), (ap));					\
} while (/* CONSTCOND */ 0)
#define strndupx(d, s, n, ap) do {					\
	(d) = strndup_i((s), (n), (ap));				\
} while (/* CONSTCOND */ 0)
#else
/* be careful to evaluate arguments only once! */
#define strdupx(d, s, ap) do {						\
	const char *strdup_src = (const void *)(s);			\
	char *strdup_dst = NULL;					\
									\
	if (strdup_src != NULL) {					\
		size_t strdup_len = strlen(strdup_src) + 1;		\
		strdup_dst = alloc(strdup_len, (ap));			\
		memcpy(strdup_dst, strdup_src, strdup_len);		\
	}								\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)
#define strndupx(d, s, n, ap) do {					\
	const char *strdup_src = (const void *)(s);			\
	char *strdup_dst = NULL;					\
									\
	if (strdup_src != NULL) {					\
		size_t strndup_len = (n);				\
		strdup_dst = alloc(strndup_len + 1, (ap));		\
		memcpy(strdup_dst, strdup_src, strndup_len);		\
		strdup_dst[strndup_len] = '\0';				\
	}								\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)
#endif
#define strdup2x(d, s1, s2) do {					\
	const char *strdup_src = (const void *)(s1);			\
	const char *strdup_app = (const void *)(s2);			\
	size_t strndup_len = strlen(strdup_src);			\
	size_t strndup_ln2 = strlen(strdup_app) + 1;			\
	char *strdup_dst = alloc(strndup_len + strndup_ln2, ATEMP);	\
									\
	memcpy(strdup_dst, strdup_src, strndup_len);			\
	memcpy(strdup_dst + strndup_len, strdup_app, strndup_ln2);	\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)
#define strpathx(d, s1, s2, cond) do {					\
	const char *strdup_src = (const void *)(s1);			\
	const char *strdup_app = (const void *)(s2);			\
	size_t strndup_len = strlen(strdup_src) + 1;			\
	size_t strndup_ln2 = ((cond) || *strdup_app) ?			\
	    strlen(strdup_app) + 1 : 0;					\
	char *strdup_dst = alloc(strndup_len + strndup_ln2, ATEMP);	\
									\
	memcpy(strdup_dst, strdup_src, strndup_len);			\
	if (strndup_ln2) {						\
		strdup_dst[strndup_len - 1] = '/';			\
		memcpy(strdup_dst + strndup_len, strdup_app,		\
		    strndup_ln2);					\
	}								\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)

#ifdef MKSH_SMALL
#ifndef MKSH_NOPWNAM
#define MKSH_NOPWNAM		/* defined */
#endif
#ifndef MKSH_S_NOVI
#define MKSH_S_NOVI		1
#endif
#endif

#ifndef MKSH_S_NOVI
#define MKSH_S_NOVI		0
#endif

#if defined(MKSH_NOPROSPECTOFWORK) && !defined(MKSH_UNEMPLOYED)
#define MKSH_UNEMPLOYED		1
#endif

#define NUFILE		32	/* Number of user-accessible files */
#define FDBASE		10	/* First file usable by Shell */

/*
 * simple grouping allocator
 */


/* 0. OS API: where to get memory from and how to free it (grouped) */

/* malloc(3)/realloc(3) -> free(3) for use by the memory allocator */
#define malloc_osi(sz)		malloc(sz)
#define realloc_osi(p,sz)	realloc((p), (sz))
#define free_osimalloc(p)	free(p)

/* malloc(3)/realloc(3) -> free(3) for use by mksh code */
#define malloc_osfunc(sz)	malloc(sz)
#define realloc_osfunc(p,sz)	realloc((p), (sz))
#define free_osfunc(p)		free(p)

#if HAVE_MKNOD
/* setmode(3) -> free(3) */
#define free_ossetmode(p)	free(p)
#endif

#ifdef MKSH__NO_PATH_MAX
/* GNU libc: get_current_dir_name(3) -> free(3) */
#define free_gnu_gcdn(p)	free(p)
#endif


/* 1. internal structure */
struct lalloc_common {
	struct lalloc_common *next;
};

#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
struct lalloc_item {
	struct lalloc_common *next;
	size_t len;
	char dummy[8192 - sizeof(struct lalloc_common *) - sizeof(size_t)];
};
#endif

/* 2. sizes */
#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
#define ALLOC_ITEM	struct lalloc_item
#define ALLOC_OVERHEAD	0
#else
#define ALLOC_ITEM	struct lalloc_common
#define ALLOC_OVERHEAD	(sizeof(ALLOC_ITEM))
#endif

/* 3. group structure */
typedef struct lalloc_common Area;


EXTERN Area aperm;		/* permanent object space */
#define APERM	&aperm
#define ATEMP	&e->area

/*
 * flags (the order of these enums MUST match the order in misc.c(options[]))
 */
enum sh_flag {
#define SHFLAGS_ENUMS
#include "sh_flags.gen"
	FNFLAGS		/* (place holder: how many flags are there) */
};

#define Flag(f)	(shell_flags[(int)(f)])
#define UTFMODE	Flag(FUNNYCODE)

/*
 * parsing & execution environment
 *
 * note that kshlongjmp MUST NOT be passed 0 as second argument!
 */
#ifdef MKSH_NO_SIGSETJMP
#define kshjmp_buf	jmp_buf
#define kshsetjmp(jbuf)	_setjmp(jbuf)
#define kshlongjmp	_longjmp
#else
#define kshjmp_buf	sigjmp_buf
#define kshsetjmp(jbuf)	sigsetjmp((jbuf), 0)
#define kshlongjmp	siglongjmp
#endif

struct sretrace_info;
struct yyrecursive_state;

EXTERN struct sretrace_info *retrace_info;
EXTERN unsigned int subshell_nesting_type;

extern struct env {
	ALLOC_ITEM alloc_INT;	/* internal, do not touch */
	Area area;		/* temporary allocation area */
	struct env *oenv;	/* link to previous environment */
	struct block *loc;	/* local variables and functions */
	short *savefd;		/* original redirected fds */
	struct temp *temps;	/* temp files */
	/* saved parser recursion state */
	struct yyrecursive_state *yyrecursive_statep;
	kshjmp_buf jbuf;	/* long jump back to env creator */
	uint8_t type;		/* environment type - see below */
	uint8_t flags;		/* EF_* */
} *e;

/* struct env.type values */
#define E_NONE	0	/* dummy environment */
#define E_PARSE	1	/* parsing command # */
#define E_FUNC	2	/* executing function # */
#define E_INCL	3	/* including a file via . # */
#define E_EXEC	4	/* executing command tree */
#define E_LOOP	5	/* executing for/while # */
#define E_ERRH	6	/* general error handler # */
#define E_GONE	7	/* hidden in child */
#define E_EVAL	8	/* running eval # */
/* # indicates env has valid jbuf (see unwind()) */

/* struct env.flag values */
#define EF_BRKCONT_PASS	BIT(1)	/* set if E_LOOP must pass break/continue on */
#define EF_FAKE_SIGDIE	BIT(2)	/* hack to get info from unwind to quitenv */
#define EF_IN_EVAL	BIT(3)	/* inside an eval */

/* Do breaks/continues stop at env type e? */
#define STOP_BRKCONT(t)	((t) == E_NONE || (t) == E_PARSE || \
			    (t) == E_FUNC || (t) == E_INCL)
/* Do returns stop at env type e? */
#define STOP_RETURN(t)	((t) == E_FUNC || (t) == E_INCL)

/* values for kshlongjmp(e->jbuf, i) */
/* note that i MUST NOT be zero */
#define LRETURN	1	/* return statement */
#define LEXIT	2	/* exit statement */
#define LERROR	3	/* errorf() called */
#define LERREXT 4	/* set -e caused */
#define LINTR	5	/* ^C noticed */
#define LBREAK	6	/* break statement */
#define LCONTIN	7	/* continue statement */
#define LSHELL	8	/* return to interactive shell() */
#define LAEXPR	9	/* error in arithmetic expression */
#define LLEAVE	10	/* untrappable exit/error */

/* sort of shell global state */
EXTERN pid_t procpid;		/* PID of executing process */
EXTERN int exstat;		/* exit status */
EXTERN int subst_exstat;	/* exit status of last $(..)/`..` */
EXTERN struct tbl *vp_pipest;	/* global PIPESTATUS array */
EXTERN short trap_exstat;	/* exit status before running a trap */
EXTERN uint8_t trap_nested;	/* running nested traps */
EXTERN uint8_t shell_flags[FNFLAGS];
EXTERN const char *kshname;	/* $0 */
EXTERN struct {
	uid_t kshuid_v;		/* real UID of shell at startup */
	uid_t ksheuid_v;	/* effective UID of shell */
	gid_t kshgid_v;		/* real GID of shell at startup */
	gid_t kshegid_v;	/* effective GID of shell */
	pid_t kshpgrp_v;	/* process group of shell */
	pid_t kshppid_v;	/* PID of parent of shell */
	pid_t kshpid_v;		/* $$, shell PID */
} rndsetupstate;

#define kshpid		rndsetupstate.kshpid_v
#define kshpgrp		rndsetupstate.kshpgrp_v
#define kshuid		rndsetupstate.kshuid_v
#define ksheuid		rndsetupstate.ksheuid_v
#define kshgid		rndsetupstate.kshgid_v
#define kshegid		rndsetupstate.kshegid_v
#define kshppid		rndsetupstate.kshppid_v


/* option processing */
#define OF_CMDLINE	0x01	/* command line */
#define OF_SET		0x02	/* set builtin */
#define OF_SPECIAL	0x04	/* a special variable changing */
#define OF_INTERNAL	0x08	/* set internally by shell */
#define OF_FIRSTTIME	0x10	/* as early as possible, once */
#define OF_ANY		(OF_CMDLINE | OF_SET | OF_SPECIAL | OF_INTERNAL)

/* null value for variable; comparison pointer for unset */
EXTERN char null[] E_INIT("");

/* string pooling: do we rely on the compiler? */
#ifndef HAVE_STRING_POOLING
/* no, we use our own, saves quite some space */
#elif HAVE_STRING_POOLING == 2
/* “on demand” */
#ifdef __GNUC__
/* only for GCC 4 or later, older ones can get by without */
#if __GNUC__ < 4
#undef HAVE_STRING_POOLING
#endif
#else
/* not GCC, default to on */
#endif
#elif HAVE_STRING_POOLING == 0
/* default to on, unless explicitly set to 0 */
#undef HAVE_STRING_POOLING
#endif

#ifndef HAVE_STRING_POOLING /* helpers for pooled strings */
EXTERN const char T4spaces[] E_INIT("    ");
#define T1space (Treal_sp2 + 5)
#define Tcolsp (Tf_sD_ + 2)
#define TC_IFSWS (TinitIFS + 4)
EXTERN const char TinitIFS[] E_INIT("IFS= \t\n");
EXTERN const char TFCEDIT_dollaru[] E_INIT("${FCEDIT:-/bin/ed} $_");
#define Tspdollaru (TFCEDIT_dollaru + 18)
EXTERN const char Tsgdot[] E_INIT("*=.");
EXTERN const char Taugo[] E_INIT("augo");
EXTERN const char Tbracket[] E_INIT("[");
#define Tdot (Tsgdot + 2)
#define Talias (Tunalias + 2)
EXTERN const char Tbadnum[] E_INIT("bad number");
#define Tbadsubst (Tfg_badsubst + 10)
EXTERN const char Tbg[] E_INIT("bg");
EXTERN const char Tbad_bsize[] E_INIT("bad shf/buf/bsize");
#define Tbsize (Tbad_bsize + 12)
EXTERN const char Tbad_sig_ss[] E_INIT("%s: bad signal '%s'");
#define Tbad_sig_s (Tbad_sig_ss + 4)
EXTERN const char Tsgbreak[] E_INIT("*=break");
#define Tbreak (Tsgbreak + 2)
EXTERN const char T__builtin[] E_INIT("-\\builtin");
#define T_builtin (T__builtin + 1)
#define Tbuiltin (T__builtin + 2)
EXTERN const char Toomem[] E_INIT("can't allocate %zu data bytes");
EXTERN const char Tcant_cd[] E_INIT("restricted shell - can't cd");
EXTERN const char Tcant_find[] E_INIT("can't find");
EXTERN const char Tcant_open[] E_INIT("can't open");
#define Tbytes (Toomem + 24)
EXTERN const char Tbcat[] E_INIT("!cat");
#define Tcat (Tbcat + 1)
#define Tcd (Tcant_cd + 25)
#define T_command (T_funny_command + 9)
#define Tcommand (T_funny_command + 10)
EXTERN const char Tsgcontinue[] E_INIT("*=continue");
#define Tcontinue (Tsgcontinue + 2)
EXTERN const char Tcreate[] E_INIT("create");
EXTERN const char TELIF_unexpected[] E_INIT("TELIF unexpected");
EXTERN const char TEXECSHELL[] E_INIT("EXECSHELL");
EXTERN const char Tdsgexport[] E_INIT("^*=export");
#define Texport (Tdsgexport + 3)
#ifdef __OS2__
EXTERN const char Textproc[] E_INIT("extproc");
#endif
EXTERN const char Tfalse[] E_INIT("false");
EXTERN const char Tfg[] E_INIT("fg");
EXTERN const char Tfg_badsubst[] E_INIT("fileglob: bad substitution");
#define Tfile (Tfile_fd + 20)
EXTERN const char Tfile_fd[] E_INIT("function definition file");
EXTERN const char TFPATH[] E_INIT("FPATH");
EXTERN const char T_function[] E_INIT(" function");
#define Tfunction (T_function + 1)
EXTERN const char T_funny_command[] E_INIT("funny $()-command");
EXTERN const char Tgetopts[] E_INIT("getopts");
#define Thistory (Tnot_in_history + 7)
EXTERN const char Tintovfl[] E_INIT("integer overflow %zu %c %zu prevented");
EXTERN const char Tinvname[] E_INIT("%s: invalid %s name");
EXTERN const char Tjobs[] E_INIT("jobs");
EXTERN const char Tjob_not_started[] E_INIT("job not started");
EXTERN const char Tmksh[] E_INIT("mksh");
#define Tname (Tinvname + 15)
EXTERN const char Tno_args[] E_INIT("missing argument");
EXTERN const char Tno_OLDPWD[] E_INIT("no OLDPWD");
EXTERN const char Tnot_ident[] E_INIT("is not an identifier");
EXTERN const char Tnot_in_history[] E_INIT("not in history");
EXTERN const char Tnot_found_s[] E_INIT("%s not found");
#define Tnot_found (Tnot_found_s + 3)
#define Tnot_started (Tjob_not_started + 4)
#define TOLDPWD (Tno_OLDPWD + 3)
#define Topen (Tcant_open + 6)
#define TPATH (TFPATH + 1)
#define Tpv (TpVv + 1)
EXTERN const char TpVv[] E_INIT("Vpv");
#define TPWD (Tno_OLDPWD + 6)
#define Tread (Tshf_read + 4)
EXTERN const char Tdsgreadonly[] E_INIT("^*=readonly");
#define Treadonly (Tdsgreadonly + 3)
EXTERN const char Tredirection_dup[] E_INIT("can't finish (dup) redirection");
#define Tredirection (Tredirection_dup + 19)
#define Treal_sp1 (Treal_sp2 + 1)
EXTERN const char Treal_sp2[] E_INIT(" real ");
EXTERN const char Treq_arg[] E_INIT("requires an argument");
EXTERN const char Tselect[] E_INIT("select");
#define Tset (Tf_parm + 18)
EXTERN const char Tsghset[] E_INIT("*=#set");
#define Tsh (Tmksh + 2)
#define TSHELL (TEXECSHELL + 4)
#define Tshell (Ttoo_many_files + 23)
EXTERN const char Tshf_read[] E_INIT("shf_read");
EXTERN const char Tshf_write[] E_INIT("shf_write");
EXTERN const char Tgsource[] E_INIT("=source");
#define Tsource (Tgsource + 1)
EXTERN const char Tj_suspend[] E_INIT("j_suspend");
#define Tsuspend (Tj_suspend + 2)
EXTERN const char Tsynerr[] E_INIT("syntax error");
EXTERN const char Ttime[] E_INIT("time");
EXTERN const char Ttoo_many_args[] E_INIT("too many arguments");
EXTERN const char Ttoo_many_files[] E_INIT("too many open files in shell");
EXTERN const char Ttrue[] E_INIT("true");
EXTERN const char Ttty_fd_dupof[] E_INIT("dup of tty fd");
#define Ttty_fd (Ttty_fd_dupof + 7)
EXTERN const char Tdgtypeset[] E_INIT("^=typeset");
#define Ttypeset (Tdgtypeset + 2)
#define Tugo (Taugo + 1)
EXTERN const char Tunalias[] E_INIT("unalias");
#define Tunexpected (TELIF_unexpected + 6)
EXTERN const char Tunexpected_type[] E_INIT("%s: unexpected %s type %d");
EXTERN const char Tunknown_option[] E_INIT("unknown option");
EXTERN const char Tunwind[] E_INIT("unwind");
#define Tuser_sp1 (Tuser_sp2 + 1)
EXTERN const char Tuser_sp2[] E_INIT(" user ");
#define Twrite (Tshf_write + 4)
EXTERN const char Tf__S[] E_INIT(" %S");
#define Tf__d (Tunexpected_type + 22)
EXTERN const char Tf__ss[] E_INIT(" %s%s");
#define Tf__sN (Tf_s_s_sN + 5)
#define Tf_T (Tf_s_T + 3)
EXTERN const char Tf_dN[] E_INIT("%d\n");
EXTERN const char Tf_s_[] E_INIT("%s ");
EXTERN const char Tf_s_T[] E_INIT("%s %T");
EXTERN const char Tf_s_s_sN[] E_INIT("%s %s %s\n");
#define Tf_s_s (Tf_sD_s_s + 4)
#define Tf_s_sD_s (Tf_cant_ss_s + 6)
EXTERN const char Tf_optfoo[] E_INIT("%s%s-%c: %s");
EXTERN const char Tf_sD_[] E_INIT("%s: ");
EXTERN const char Tf_szs[] E_INIT("%s: %zd %s");
EXTERN const char Tf_parm[] E_INIT("%s: parameter not set");
EXTERN const char Tf_coproc[] E_INIT("-p: %s");
EXTERN const char Tf_cant_s[] E_INIT("%s: can't %s");
EXTERN const char Tf_cant_ss_s[] E_INIT("can't %s %s: %s");
EXTERN const char Tf_heredoc[] E_INIT("here document '%s' unclosed");
#if HAVE_MKNOD
EXTERN const char Tf_nonnum[] E_INIT("non-numeric %s %s '%s'");
#endif
EXTERN const char Tf_S_[] E_INIT("%S ");
#define Tf_S (Tf__S + 1)
#define Tf_lu (Tf_toolarge + 17)
EXTERN const char Tf_toolarge[] E_INIT("%s %s too large: %lu");
EXTERN const char Tf_ldfailed[] E_INIT("%s %s(%d, %ld) failed: %s");
EXTERN const char Tf_sD_s_sD_s[] E_INIT("%s: %s %s: %s");
EXTERN const char Tf_toomany[] E_INIT("too many %ss");
EXTERN const char Tf_sd[] E_INIT("%s %d");
#define Tf_s (Tf_temp + 28)
EXTERN const char Tft_end[] E_INIT("%;");
EXTERN const char Tft_R[] E_INIT("%R");
#define Tf_d (Tunexpected_type + 23)
EXTERN const char Tf_sD_s_qs[] E_INIT("%s: %s '%s'");
EXTERN const char Tf_ro[] E_INIT("read-only: %s");
EXTERN const char Tf_flags[] E_INIT("%s: flags 0x%X");
EXTERN const char Tf_temp[] E_INIT("can't %s temporary file %s: %s");
EXTERN const char Tf_ssfaileds[] E_INIT("%s: %s failed: %s");
EXTERN const char Tf_sD_sD_s[] E_INIT("%s: %s: %s");
EXTERN const char Tf__c_[] E_INIT("-%c ");
EXTERN const char Tf_sD_s_s[] E_INIT("%s: %s %s");
#define Tf_sN (Tf_s_s_sN + 6)
#define Tf_sD_s (Tf_temp + 24)
EXTERN const char T_devtty[] E_INIT("/dev/tty");
#else /* helpers for string pooling */
#define T4spaces "    "
#define T1space " "
#define Tcolsp ": "
#define TC_IFSWS " \t\n"
#define TinitIFS "IFS= \t\n"
#define TFCEDIT_dollaru "${FCEDIT:-/bin/ed} $_"
#define Tspdollaru " $_"
#define Tsgdot "*=."
#define Taugo "augo"
#define Tbracket "["
#define Tdot "."
#define Talias "alias"
#define Tbadnum "bad number"
#define Tbadsubst "bad substitution"
#define Tbg "bg"
#define Tbad_bsize "bad shf/buf/bsize"
#define Tbsize "bsize"
#define Tbad_sig_ss "%s: bad signal '%s'"
#define Tbad_sig_s "bad signal '%s'"
#define Tsgbreak "*=break"
#define Tbreak "break"
#define T__builtin "-\\builtin"
#define T_builtin "\\builtin"
#define Tbuiltin "builtin"
#define Toomem "can't allocate %zu data bytes"
#define Tcant_cd "restricted shell - can't cd"
#define Tcant_find "can't find"
#define Tcant_open "can't open"
#define Tbytes "bytes"
#define Tbcat "!cat"
#define Tcat "cat"
#define Tcd "cd"
#define T_command "-command"
#define Tcommand "command"
#define Tsgcontinue "*=continue"
#define Tcontinue "continue"
#define Tcreate "create"
#define TELIF_unexpected "TELIF unexpected"
#define TEXECSHELL "EXECSHELL"
#define Tdsgexport "^*=export"
#define Texport "export"
#ifdef __OS2__
#define Textproc "extproc"
#endif
#define Tfalse "false"
#define Tfg "fg"
#define Tfg_badsubst "fileglob: bad substitution"
#define Tfile "file"
#define Tfile_fd "function definition file"
#define TFPATH "FPATH"
#define T_function " function"
#define Tfunction "function"
#define T_funny_command "funny $()-command"
#define Tgetopts "getopts"
#define Thistory "history"
#define Tintovfl "integer overflow %zu %c %zu prevented"
#define Tinvname "%s: invalid %s name"
#define Tjobs "jobs"
#define Tjob_not_started "job not started"
#define Tmksh "mksh"
#define Tname "name"
#define Tno_args "missing argument"
#define Tno_OLDPWD "no OLDPWD"
#define Tnot_ident "is not an identifier"
#define Tnot_in_history "not in history"
#define Tnot_found_s "%s not found"
#define Tnot_found "not found"
#define Tnot_started "not started"
#define TOLDPWD "OLDPWD"
#define Topen "open"
#define TPATH "PATH"
#define Tpv "pv"
#define TpVv "Vpv"
#define TPWD "PWD"
#define Tread "read"
#define Tdsgreadonly "^*=readonly"
#define Treadonly "readonly"
#define Tredirection_dup "can't finish (dup) redirection"
#define Tredirection "redirection"
#define Treal_sp1 "real "
#define Treal_sp2 " real "
#define Treq_arg "requires an argument"
#define Tselect "select"
#define Tset "set"
#define Tsghset "*=#set"
#define Tsh "sh"
#define TSHELL "SHELL"
#define Tshell "shell"
#define Tshf_read "shf_read"
#define Tshf_write "shf_write"
#define Tgsource "=source"
#define Tsource "source"
#define Tj_suspend "j_suspend"
#define Tsuspend "suspend"
#define Tsynerr "syntax error"
#define Ttime "time"
#define Ttoo_many_args "too many arguments"
#define Ttoo_many_files "too many open files in shell"
#define Ttrue "true"
#define Ttty_fd_dupof "dup of tty fd"
#define Ttty_fd "tty fd"
#define Tdgtypeset "^=typeset"
#define Ttypeset "typeset"
#define Tugo "ugo"
#define Tunalias "unalias"
#define Tunexpected "unexpected"
#define Tunexpected_type "%s: unexpected %s type %d"
#define Tunknown_option "unknown option"
#define Tunwind "unwind"
#define Tuser_sp1 "user "
#define Tuser_sp2 " user "
#define Twrite "write"
#define Tf__S " %S"
#define Tf__d " %d"
#define Tf__ss " %s%s"
#define Tf__sN " %s\n"
#define Tf_T "%T"
#define Tf_dN "%d\n"
#define Tf_s_ "%s "
#define Tf_s_T "%s %T"
#define Tf_s_s_sN "%s %s %s\n"
#define Tf_s_s "%s %s"
#define Tf_s_sD_s "%s %s: %s"
#define Tf_optfoo "%s%s-%c: %s"
#define Tf_sD_ "%s: "
#define Tf_szs "%s: %zd %s"
#define Tf_parm "%s: parameter not set"
#define Tf_coproc "-p: %s"
#define Tf_cant_s "%s: can't %s"
#define Tf_cant_ss_s "can't %s %s: %s"
#define Tf_heredoc "here document '%s' unclosed"
#if HAVE_MKNOD
#define Tf_nonnum "non-numeric %s %s '%s'"
#endif
#define Tf_S_ "%S "
#define Tf_S "%S"
#define Tf_lu "%lu"
#define Tf_toolarge "%s %s too large: %lu"
#define Tf_ldfailed "%s %s(%d, %ld) failed: %s"
#define Tf_sD_s_sD_s "%s: %s %s: %s"
#define Tf_toomany "too many %ss"
#define Tf_sd "%s %d"
#define Tf_s "%s"
#define Tft_end "%;"
#define Tft_R "%R"
#define Tf_d "%d"
#define Tf_sD_s_qs "%s: %s '%s'"
#define Tf_ro "read-only: %s"
#define Tf_flags "%s: flags 0x%X"
#define Tf_temp "can't %s temporary file %s: %s"
#define Tf_ssfaileds "%s: %s failed: %s"
#define Tf_sD_sD_s "%s: %s: %s"
#define Tf__c_ "-%c "
#define Tf_sD_s_s "%s: %s %s"
#define Tf_sN "%s\n"
#define Tf_sD_s "%s: %s"
#define T_devtty "/dev/tty"
#endif /* end of string pooling */

typedef uint8_t Temp_type;
/* expanded heredoc */
#define TT_HEREDOC_EXP	0
/* temporary file used for history editing (fc -e) */
#define TT_HIST_EDIT	1
/* temporary file used during in-situ command substitution */
#define TT_FUNSUB	2

/* temp/heredoc files. The file is removed when the struct is freed. */
struct temp {
	struct temp *next;
	struct shf *shf;
	/* pid of process parsed here-doc */
	pid_t pid;
	Temp_type type;
	/* actually longer: name (variable length) */
	char tffn[3];
};

/*
 * stdio and our IO routines
 */

#define shl_xtrace	(&shf_iob[0])	/* for set -x */
#define shl_stdout	(&shf_iob[1])
#define shl_out		(&shf_iob[2])
#ifdef DF
#define shl_dbg		(&shf_iob[3])	/* for DF() */
#endif
EXTERN bool shl_stdout_ok;

/*
 * trap handlers
 */
typedef struct trap {
	const char *name;	/* short name */
	const char *mess;	/* descriptive name */
	char *trap;		/* trap command */
	sig_t cursig;		/* current handler (valid if TF_ORIG_* set) */
	sig_t shtrap;		/* shell signal handler */
	int signal;		/* signal number */
	int flags;		/* TF_* */
	volatile sig_atomic_t set; /* trap pending */
} Trap;

/* values for Trap.flags */
#define TF_SHELL_USES	BIT(0)	/* shell uses signal, user can't change */
#define TF_USER_SET	BIT(1)	/* user has (tried to) set trap */
#define TF_ORIG_IGN	BIT(2)	/* original action was SIG_IGN */
#define TF_ORIG_DFL	BIT(3)	/* original action was SIG_DFL */
#define TF_EXEC_IGN	BIT(4)	/* restore SIG_IGN just before exec */
#define TF_EXEC_DFL	BIT(5)	/* restore SIG_DFL just before exec */
#define TF_DFL_INTR	BIT(6)	/* when received, default action is LINTR */
#define TF_TTY_INTR	BIT(7)	/* tty generated signal (see j_waitj) */
#define TF_CHANGED	BIT(8)	/* used by runtrap() to detect trap changes */
#define TF_FATAL	BIT(9)	/* causes termination if not trapped */

/* values for setsig()/setexecsig() flags argument */
#define SS_RESTORE_MASK	0x3	/* how to restore a signal before an exec() */
#define SS_RESTORE_CURR	0	/* leave current handler in place */
#define SS_RESTORE_ORIG	1	/* restore original handler */
#define SS_RESTORE_DFL	2	/* restore to SIG_DFL */
#define SS_RESTORE_IGN	3	/* restore to SIG_IGN */
#define SS_FORCE	BIT(3)	/* set signal even if original signal ignored */
#define SS_USER		BIT(4)	/* user is doing the set (ie, trap command) */
#define SS_SHTRAP	BIT(5)	/* trap for internal use (ALRM, CHLD, WINCH) */

#define ksh_SIGEXIT 0		/* for trap EXIT */
#define ksh_SIGERR  ksh_NSIG	/* for trap ERR */

EXTERN volatile sig_atomic_t trap;	/* traps pending? */
EXTERN volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
EXTERN volatile sig_atomic_t fatal_trap; /* received a fatal signal */
extern Trap sigtraps[ksh_NSIG + 1];

/* got_winch = 1 when we need to re-adjust the window size */
#ifdef SIGWINCH
EXTERN volatile sig_atomic_t got_winch E_INIT(1);
#else
#define got_winch	true
#endif

/*
 * TMOUT support
 */
/* values for ksh_tmout_state */
enum tmout_enum {
	TMOUT_EXECUTING = 0,	/* executing commands */
	TMOUT_READING,		/* waiting for input */
	TMOUT_LEAVING		/* have timed out */
};
EXTERN unsigned int ksh_tmout;
EXTERN enum tmout_enum ksh_tmout_state;

/* For "You have stopped jobs" message */
EXTERN bool really_exit;

/*
 * fast character classes
 */

/* internal types, do not reference */

/* initially empty — filled at runtime from $IFS */
#define CiIFS	BIT(0)
#define CiCNTRL	BIT(1)	/* \x01‥\x08\x0E‥\x1F\x7F	*/
#define CiUPPER	BIT(2)	/* A‥Z				*/
#define CiLOWER	BIT(3)	/* a‥z				*/
#define CiHEXLT	BIT(4)	/* A‥Fa‥f			*/
#define CiOCTAL	BIT(5)	/* 0‥7				*/
#define CiQCL	BIT(6)	/* &();|			*/
#define CiALIAS	BIT(7)	/* !,.@@				*/
#define CiQCX	BIT(8)	/* *[\\				*/
#define CiVAR1	BIT(9)	/* !*@@				*/
#define CiQCM	BIT(10)	/* /^~				*/
#define CiDIGIT	BIT(11)	/* 89				*/
#define CiQC	BIT(12)	/* "'				*/
#define CiSPX	BIT(13)	/* \x0B\x0C			*/
#define CiCURLY	BIT(14)	/* {}				*/
#define CiANGLE	BIT(15)	/* <>				*/
#define CiNUL	BIT(16)	/* \x00				*/
#define CiTAB	BIT(17)	/* \x09				*/
#define CiNL	BIT(18)	/* \x0A				*/
#define CiCR	BIT(19)	/* \x0D				*/
#define CiSP	BIT(20)	/* \x20				*/
#define CiHASH	BIT(21)	/* #				*/
#define CiSS	BIT(22)	/* $				*/
#define CiPERCT	BIT(23)	/* %				*/
#define CiPLUS	BIT(24)	/* +				*/
#define CiMINUS	BIT(25)	/* -				*/
#define CiCOLON	BIT(26)	/* :				*/
#define CiEQUAL	BIT(27)	/* =				*/
#define CiQUEST	BIT(28)	/* ?				*/
#define CiBRACK	BIT(29)	/* ]				*/
#define CiUNDER	BIT(30)	/* _				*/
#define CiGRAVE	BIT(31)	/* `				*/
/* out of space, but one for *@@ would make sense, possibly others */

/* compile-time initialised, ASCII only */
extern const uint32_t tpl_ctypes[128];
/* run-time, contains C_IFS as well, full 2⁸ octet range */
EXTERN uint32_t ksh_ctypes[256];
/* first octet of $IFS, for concatenating "$*" */
EXTERN char ifs0;

/* external types */

/* !%,-.0‥9:@@A‥Z[]_a‥z	valid characters in alias names */
#define C_ALIAS	(CiALIAS | CiBRACK | CiCOLON | CiDIGIT | CiLOWER | CiMINUS | CiOCTAL | CiPERCT | CiUNDER | CiUPPER)
/* 0‥9A‥Za‥z		alphanumerical */
#define C_ALNUM	(CiDIGIT | CiLOWER | CiOCTAL | CiUPPER)
/* 0‥9A‥Z_a‥z		alphanumerical plus underscore (“word character”) */
#define C_ALNUX	(CiDIGIT | CiLOWER | CiOCTAL | CiUNDER | CiUPPER)
/* A‥Za‥z		alphabetical (upper plus lower) */
#define C_ALPHA	(CiLOWER | CiUPPER)
/* A‥Z_a‥z		alphabetical plus underscore (identifier lead) */
#define C_ALPHX	(CiLOWER | CiUNDER | CiUPPER)
/* \x01‥\x7F		7-bit ASCII except NUL */
#define C_ASCII (CiALIAS | CiANGLE | CiBRACK | CiCNTRL | CiCOLON | CiCR | CiCURLY | CiDIGIT | CiEQUAL | CiGRAVE | CiHASH | CiLOWER | CiMINUS | CiNL | CiOCTAL | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSP | CiSPX | CiSS | CiTAB | CiUNDER | CiUPPER)
/* \x09\x20		tab and space */
#define C_BLANK	(CiSP | CiTAB)
/* \x09\x20"'		separator for completion */
#define C_CFS	(CiQC | CiSP | CiTAB)
/* \x00‥\x1F\x7F	POSIX control characters */
#define C_CNTRL	(CiCNTRL | CiCR | CiNL | CiNUL | CiSPX | CiTAB)
/* 0‥9			decimal digits */
#define C_DIGIT	(CiDIGIT | CiOCTAL)
/* &();`|			editor x_locate_word() command */
#define C_EDCMD	(CiGRAVE | CiQCL)
/* \x09\x0A\x20"&'():;<=>`|	editor non-word characters */
#define C_EDNWC	(CiANGLE | CiCOLON | CiEQUAL | CiGRAVE | CiNL | CiQC | CiQCL | CiSP | CiTAB)
/* "#$&'()*:;<=>?[\\`{|}	editor quotes for tab completion */
#define C_EDQ	(CiANGLE | CiCOLON | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiQC | CiQCL | CiQCX | CiQUEST | CiSS)
/* !‥~			POSIX graphical (alphanumerical plus punctuation) */
#define C_GRAPH	(C_PUNCT | CiDIGIT | CiLOWER | CiOCTAL | CiUPPER)
/* A‥Fa‥f		hex letter */
#define C_HEXLT	CiHEXLT
/* \x00 + $IFS		IFS whitespace, IFS non-whitespace, NUL */
#define C_IFS	(CiIFS | CiNUL)
/* \x09\x0A\x20		IFS whitespace */
#define C_IFSWS	(CiNL | CiSP | CiTAB)
/* \x09\x0A\x20&();<>|	(for the lexer) */
#define C_LEX1	(CiANGLE | CiNL | CiQCL | CiSP | CiTAB)
/* a‥z			lowercase letters */
#define C_LOWER	CiLOWER
/* not alnux or dollar	separator for motion */
#define C_MFS	(CiALIAS | CiANGLE | CiBRACK | CiCNTRL | CiCOLON | CiCR | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiMINUS | CiNL | CiNUL | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSP | CiSPX | CiTAB)
/* 0‥7			octal digit */
#define C_OCTAL	CiOCTAL
/* !*+?@@		pattern magical operator, except space */
#define C_PATMO	(CiPLUS | CiQUEST | CiVAR1)
/* \x20‥~		POSIX printable characters (graph plus space) */
#define C_PRINT	(C_GRAPH | CiSP)
/* !"#$%&'()*+,-./:;<=>?@@[\\]^_`{|}~	POSIX punctuation */
#define C_PUNCT	(CiALIAS | CiANGLE | CiBRACK | CiCOLON | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiMINUS | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSS | CiUNDER)
/* \x09\x0A"#$&'()*;<=>?[\\]`|	characters requiring quoting, minus space */
#define C_QUOTE	(CiANGLE | CiBRACK | CiEQUAL | CiGRAVE | CiHASH | CiNL | CiQC | CiQCL | CiQCX | CiQUEST | CiSS | CiTAB)
/* 0‥9A‥Fa‥f		hexadecimal digit */
#define C_SEDEC	(CiDIGIT | CiHEXLT | CiOCTAL)
/* \x09‥\x0D\x20	POSIX space class */
#define C_SPACE	(CiCR | CiNL | CiSP | CiSPX | CiTAB)
/* +-=?			substitution operations with word */
#define C_SUB1	(CiEQUAL | CiMINUS | CiPLUS | CiQUEST)
/* #%			substitution operations with pattern */
#define C_SUB2	(CiHASH | CiPERCT)
/* A‥Z			uppercase letters */
#define C_UPPER	CiUPPER
/* !#$*-?@@		substitution parameters, other than positional */
#define C_VAR1	(CiHASH | CiMINUS | CiQUEST | CiSS | CiVAR1)

/* individual chars you might like */
#define C_ANGLE	CiANGLE		/* <>	angle brackets */
#define C_COLON	CiCOLON		/* :	colon */
#define C_CR	CiCR		/* \x0D	ASCII carriage return */
#define C_DOLAR	CiSS		/* $	dollar sign */
#define C_EQUAL	CiEQUAL		/* =	equals sign */
#define C_GRAVE	CiGRAVE		/* `	accent gravis */
#define C_HASH	CiHASH		/* #	hash sign */
#define C_LF	CiNL		/* \x0A	ASCII line feed */
#define C_MINUS	CiMINUS		/* -	hyphen-minus */
#ifdef MKSH_WITH_TEXTMODE
#define C_NL	(CiNL | CiCR)	/* 	CR or LF under OS/2 TEXTMODE */
#else
#define C_NL	CiNL		/* 	LF only like under Unix */
#endif
#define C_NUL	CiNUL		/* \x00	ASCII NUL */
#define C_PLUS	CiPLUS		/* +	plus sign */
#define C_QC	CiQC		/* "'	quote characters */
#define C_QUEST	CiQUEST		/* ?	question mark */
#define C_SPC	CiSP		/* \x20	ASCII space */
#define C_TAB	CiTAB		/* \x09	ASCII horizontal tabulator */
#define C_UNDER	CiUNDER		/* _	underscore */

/* identity transform of octet */
#if defined(DEBUG) && defined(__GNUC__) && !defined(__ICC) && \
    !defined(__INTEL_COMPILER) && !defined(__SUNPRO_C)
extern unsigned int eek_ord;
#define ORD(c)	((size_t)(c) > 0xFF ? eek_ord : \
		    ((unsigned int)(unsigned char)(c)))
#define ord(c)	__builtin_choose_expr(				\
    __builtin_types_compatible_p(__typeof__(c), char) ||	\
    __builtin_types_compatible_p(__typeof__(c), unsigned char),	\
    ((unsigned int)(unsigned char)(c)), ({			\
	size_t ord_c = (c);					\
								\
	if (ord_c > (size_t)0xFFU)				\
		internal_errorf("%s:%d:ord(%zX)",		\
		    __FILE__, __LINE__, ord_c);			\
	((unsigned int)(unsigned char)(ord_c));			\
}))
#else
#define ord(c)	((unsigned int)(unsigned char)(c))
#define ORD(c)	ord(c) /* may evaluate arguments twice */
#endif
#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
EXTERN unsigned short ebcdic_map[256];
EXTERN unsigned char ebcdic_rtt_toascii[256];
EXTERN unsigned char ebcdic_rtt_fromascii[256];
extern void ebcdic_init(void);
/* one-way to-ascii-or-high conversion, for POSIX locale ordering */
#define asciibetical(c)	((unsigned int)ebcdic_map[(unsigned char)(c)])
/* two-way round-trip conversion, for general use */
#define rtt2asc(c)	ebcdic_rtt_toascii[(unsigned char)(c)]
#define asc2rtt(c)	ebcdic_rtt_fromascii[(unsigned char)(c)]
/* case-independent char comparison */
#define ksh_eq(c,u,l)	(ord(c) == ord(u) || ord(c) == ord(l))
#else
#define asciibetical(c)	ord(c)
#define rtt2asc(c)	((unsigned char)(c))
#define asc2rtt(c)	((unsigned char)(c))
#define ksh_eq(c,u,l)	((ord(c) | 0x20) == ord(l))
#endif
/* control character foo */
#ifdef MKSH_EBCDIC
#define ksh_isctrl(c)	(ord(c) < 0x40 || ord(c) == 0xFF)
#else
#define ksh_isctrl(c)	((ord(c) & 0x7F) < 0x20 || ord(c) == 0x7F)
#endif
/* new fast character classes */
#define ctype(c,t)	tobool(ksh_ctypes[ord(c)] & (t))
#define cinttype(c,t)	((c) >= 0 && (c) <= 0xFF ? \
			tobool(ksh_ctypes[(unsigned char)(c)] & (t)) : false)
/* helper functions */
#define ksh_isdash(s)	tobool(ord((s)[0]) == '-' && ord((s)[1]) == '\0')
/* invariant distance even in EBCDIC */
#define ksh_tolower(c)	(ctype(c, C_UPPER) ? (c) - 'A' + 'a' : (c))
#define ksh_toupper(c)	(ctype(c, C_LOWER) ? (c) - 'a' + 'A' : (c))
/* strictly speaking rtt2asc() here, but this works even in EBCDIC */
#define ksh_numdig(c)	(ord(c) - ORD('0'))
#define ksh_numuc(c)	(rtt2asc(c) - rtt2asc('A'))
#define ksh_numlc(c)	(rtt2asc(c) - rtt2asc('a'))
#define ksh_toctrl(c)	asc2rtt(ord(c) == ORD('?') ? 0x7F : rtt2asc(c) & 0x9F)
#define ksh_unctrl(c)	asc2rtt(rtt2asc(c) ^ 0x40U)

/* Argument parsing for built-in commands and getopts command */

/* Values for Getopt.flags */
#define GF_ERROR	BIT(0)	/* call errorf() if there is an error */
#define GF_PLUSOPT	BIT(1)	/* allow +c as an option */
#define GF_NONAME	BIT(2)	/* don't print argv[0] in errors */

/* Values for Getopt.info */
#define GI_MINUS	BIT(0)	/* an option started with -... */
#define GI_PLUS		BIT(1)	/* an option started with +... */
#define GI_MINUSMINUS	BIT(2)	/* arguments were ended with -- */

/* in case some OS defines these */
#undef optarg
#undef optind

typedef struct {
	const char *optarg;
	int optind;
	int uoptind;		/* what user sees in $OPTIND */
	int flags;		/* see GF_* */
	int info;		/* see GI_* */
	unsigned int p;		/* 0 or index into argv[optind - 1] */
	char buf[2];		/* for bad option OPTARG value */
} Getopt;

EXTERN Getopt builtin_opt;	/* for shell builtin commands */
EXTERN Getopt user_opt;		/* parsing state for getopts builtin command */

/* This for co-processes */

/* something that won't (realisticly) wrap */
typedef int Coproc_id;

struct coproc {
	void *job;	/* 0 or job of co-process using input pipe */
	int read;	/* pipe from co-process's stdout */
	int readw;	/* other side of read (saved temporarily) */
	int write;	/* pipe to co-process's stdin */
	int njobs;	/* number of live jobs using output pipe */
	Coproc_id id;	/* id of current output pipe */
};
EXTERN struct coproc coproc;

#ifndef MKSH_NOPROSPECTOFWORK
/* used in jobs.c and by coprocess stuff in exec.c and select() calls */
EXTERN sigset_t		sm_default, sm_sigchld;
#endif

/* name of called builtin function (used by error functions) */
EXTERN const char *builtin_argv0;
/* is called builtin a POSIX special builtin? (error functions only) */
EXTERN bool builtin_spec;

/* current working directory */
EXTERN char	*current_wd;

/* input line size */
#ifdef MKSH_SMALL
#define LINE		(4096 - ALLOC_OVERHEAD)
#else
#define LINE		(16384 - ALLOC_OVERHEAD)
#endif
/* columns and lines of the tty */
EXTERN mksh_ari_t x_cols E_INIT(80);
EXTERN mksh_ari_t x_lins E_INIT(24);


/* Determine the location of the system (common) profile */

#ifndef MKSH_DEFAULT_PROFILEDIR
#define MKSH_DEFAULT_PROFILEDIR	MKSH_UNIXROOT "/etc"
#endif

#define MKSH_SYSTEM_PROFILE	MKSH_DEFAULT_PROFILEDIR "/profile"
#define MKSH_SUID_PROFILE	MKSH_DEFAULT_PROFILEDIR "/suid_profile"


/* Used by v_evaluate() and setstr() to control action when error occurs */
#define KSH_UNWIND_ERROR	0	/* unwind the stack (kshlongjmp) */
#define KSH_RETURN_ERROR	1	/* return 1/0 for success/failure */

/*
 * Shell file I/O routines
 */

#define SHF_BSIZE		512

#define shf_fileno(shf)		((shf)->fd)
#define shf_setfileno(shf,nfd)	((shf)->fd = (nfd))
#define shf_getc_i(shf)		((shf)->rnleft > 0 ? \
				    (shf)->rnleft--, (int)ord(*(shf)->rp++) : \
				    shf_getchar(shf))
#define shf_putc_i(c, shf)	((shf)->wnleft == 0 ? \
				    shf_putchar((uint8_t)(c), (shf)) : \
				    ((shf)->wnleft--, *(shf)->wp++ = (c)))
#define shf_eof(shf)		((shf)->flags & SHF_EOF)
#define shf_error(shf)		((shf)->flags & SHF_ERROR)
#define shf_errno(shf)		((shf)->errnosv)
#define shf_clearerr(shf)	((shf)->flags &= ~(SHF_EOF | SHF_ERROR))

/* Flags passed to shf_*open() */
#define SHF_RD		0x0001
#define SHF_WR		0x0002
#define SHF_RDWR	(SHF_RD|SHF_WR)
#define SHF_ACCMODE	0x0003		/* mask */
#define SHF_GETFL	0x0004		/* use fcntl() to figure RD/WR flags */
#define SHF_UNBUF	0x0008		/* unbuffered I/O */
#define SHF_CLEXEC	0x0010		/* set close on exec flag */
#define SHF_MAPHI	0x0020		/* make fd > FDBASE (and close orig)
					 * (shf_open() only) */
#define SHF_DYNAMIC	0x0040		/* string: increase buffer as needed */
#define SHF_INTERRUPT	0x0080		/* EINTR in read/write causes error */
/* Flags used internally */
#define SHF_STRING	0x0100		/* a string, not a file */
#define SHF_ALLOCS	0x0200		/* shf and shf->buf were alloc()ed */
#define SHF_ALLOCB	0x0400		/* shf->buf was alloc()ed */
#define SHF_ERROR	0x0800		/* read()/write() error */
#define SHF_EOF		0x1000		/* read eof (sticky) */
#define SHF_READING	0x2000		/* currently reading: rnleft,rp valid */
#define SHF_WRITING	0x4000		/* currently writing: wnleft,wp valid */


struct shf {
	Area *areap;		/* area shf/buf were allocated in */
	unsigned char *rp;	/* read: current position in buffer */
	unsigned char *wp;	/* write: current position in buffer */
	unsigned char *buf;	/* buffer */
	ssize_t bsize;		/* actual size of buf */
	ssize_t rbsize;		/* size of buffer (1 if SHF_UNBUF) */
	ssize_t rnleft;		/* read: how much data left in buffer */
	ssize_t wbsize;		/* size of buffer (0 if SHF_UNBUF) */
	ssize_t wnleft;		/* write: how much space left in buffer */
	int flags;		/* see SHF_* */
	int fd;			/* file descriptor */
	int errnosv;		/* saved value of errno after error */
};

extern struct shf shf_iob[];

struct table {
	Area *areap;		/* area to allocate entries */
	struct tbl **tbls;	/* hashed table items */
	size_t nfree;		/* free table entries */
	uint8_t tshift;		/* table size (2^tshift) */
};

/* table item */
struct tbl {
	/* Area to allocate from */
	Area *areap;
	/* value */
	union {
		char *s;			/* string */
		mksh_ari_t i;			/* integer */
		mksh_uari_t u;			/* unsigned integer */
		int (*f)(const char **);	/* built-in command */
		struct op *t;			/* "function" tree */
	} val;
	union {
		struct tbl *array;	/* array values */
		const char *fpath;	/* temporary path to undef function */
	} u;
	union {
		int field;		/* field with for -L/-R/-Z */
		int errnov;		/* CEXEC/CTALIAS */
	} u2;
	union {
		uint32_t hval;		/* hash(name) */
		uint32_t index;		/* index for an array */
	} ua;
	/*
	 * command type (see below), base (if INTEGER),
	 * offset from val.s of value (if EXPORT)
	 */
	int type;
	/* flags (see below) */
	uint32_t flag;

	/* actually longer: name (variable length) */
	char name[4];
};

EXTERN struct tbl *vtemp;
/* set by isglobal(), global() and local() */
EXTERN bool last_lookup_was_array;

/* common flag bits */
#define ALLOC		BIT(0)	/* val.s has been allocated */
#define DEFINED		BIT(1)	/* is defined in block */
#define ISSET		BIT(2)	/* has value, vp->val.[si] */
#define EXPORT		BIT(3)	/* exported variable/function */
#define TRACE		BIT(4)	/* var: user flagged, func: execution tracing */
/* (start non-common flags at 8) */
/* flag bits used for variables */
#define SPECIAL		BIT(8)	/* PATH, IFS, SECONDS, etc */
#define INTEGER		BIT(9)	/* val.i contains integer value */
#define RDONLY		BIT(10)	/* read-only variable */
#define LOCAL		BIT(11)	/* for local typeset() */
#define ARRAY		BIT(13)	/* array */
#define LJUST		BIT(14)	/* left justify */
#define RJUST		BIT(15)	/* right justify */
#define ZEROFIL		BIT(16)	/* 0 filled if RJUSTIFY, strip 0s if LJUSTIFY */
#define LCASEV		BIT(17)	/* convert to lower case */
#define UCASEV_AL	BIT(18) /* convert to upper case / autoload function */
#define INT_U		BIT(19)	/* unsigned integer */
#define INT_L		BIT(20)	/* long integer (no-op but used as magic) */
#define IMPORT		BIT(21)	/* flag to typeset(): no arrays, must have = */
#define LOCAL_COPY	BIT(22)	/* with LOCAL - copy attrs from existing var */
#define EXPRINEVAL	BIT(23)	/* contents currently being evaluated */
#define EXPRLVALUE	BIT(24)	/* useable as lvalue (temp flag) */
#define AINDEX		BIT(25) /* array index >0 = ua.index filled in */
#define ASSOC		BIT(26) /* ARRAY ? associative : reference */
/* flag bits used for taliases/builtins/aliases/keywords/functions */
#define KEEPASN		BIT(8)	/* keep command assignments (eg, var=x cmd) */
#define FINUSE		BIT(9)	/* function being executed */
#define FDELETE		BIT(10)	/* function deleted while it was executing */
#define FKSH		BIT(11)	/* function defined with function x (vs x()) */
#define SPEC_BI		BIT(12)	/* a POSIX special builtin */
#define LOWER_BI	BIT(13)	/* (with LOW_BI) override even w/o flags */
#define LOW_BI		BIT(14)	/* external utility overrides built-in one */
#define DECL_UTIL	BIT(15)	/* is declaration utility */
#define DECL_FWDR	BIT(16) /* is declaration utility forwarder */
#define NEXTLOC_BI	BIT(17)	/* needs BF_RESETSPEC on e->loc */

/*
 * Attributes that can be set by the user (used to decide if an unset
 * param should be repoted by set/typeset). Does not include ARRAY or
 * LOCAL.
 */
#define USERATTRIB	(EXPORT|INTEGER|RDONLY|LJUST|RJUST|ZEROFIL|\
			    LCASEV|UCASEV_AL|INT_U|INT_L)

#define arrayindex(vp)	((unsigned long)((vp)->flag & AINDEX ? \
			    (vp)->ua.index : 0))

enum namerefflag {
	SRF_NOP,
	SRF_ENABLE,
	SRF_DISABLE
};

/* command types */
#define CNONE		0	/* undefined */
#define CSHELL		1	/* built-in */
#define CFUNC		2	/* function */
#define CEXEC		4	/* executable command */
#define CALIAS		5	/* alias */
#define CKEYWD		6	/* keyword */
#define CTALIAS		7	/* tracked alias */

/* Flags for findcom()/comexec() */
#define FC_SPECBI	BIT(0)	/* special builtin */
#define FC_FUNC		BIT(1)	/* function */
#define FC_NORMBI	BIT(2)	/* not special builtin */
#define FC_BI		(FC_SPECBI | FC_NORMBI)
#define FC_PATH		BIT(3)	/* do path search */
#define FC_DEFPATH	BIT(4)	/* use default path in path search */
#define FC_WHENCE	BIT(5)	/* for use by command and whence */

#define AF_ARGV_ALLOC	0x1	/* argv[] array allocated */
#define AF_ARGS_ALLOCED	0x2	/* argument strings allocated */
#define AI_ARGV(a, i)	((i) == 0 ? (a).argv[0] : (a).argv[(i) - (a).skip])
#define AI_ARGC(a)	((a).ai_argc - (a).skip)

/* Argument info. Used for $#, $* for shell, functions, includes, etc. */
struct arg_info {
	const char **argv;
	int flags;	/* AF_* */
	int ai_argc;
	int skip;	/* first arg is argv[0], second is argv[1 + skip] */
};

/*
 * activation record for function blocks
 */
struct block {
	Area area;		/* area to allocate things */
	const char **argv;
	char *error;		/* error handler */
	char *exit;		/* exit handler */
	struct block *next;	/* enclosing block */
	struct table vars;	/* local variables */
	struct table funs;	/* local functions */
	Getopt getopts_state;
	int argc;
	int flags;		/* see BF_* */
};

/* Values for struct block.flags */
#define BF_DOGETOPTS	BIT(0)	/* save/restore getopts state */
#define BF_STOPENV	BIT(1)	/* do not export further */
/* BF_RESETSPEC and NEXTLOC_BI must be numerically identical! */
#define BF_RESETSPEC	BIT(17)	/* use ->next for set and shift */

/*
 * Used by ktwalk() and ktnext() routines.
 */
struct tstate {
	struct tbl **next;
	ssize_t left;
};

EXTERN struct table taliases;	/* tracked aliases */
EXTERN struct table builtins;	/* built-in commands */
EXTERN struct table aliases;	/* aliases */
EXTERN struct table keywords;	/* keywords */
#ifndef MKSH_NOPWNAM
EXTERN struct table homedirs;	/* homedir() cache */
#endif

struct builtin {
	const char *name;
	int (*func)(const char **);
};

extern const struct builtin mkshbuiltins[];

/* values for set_prompt() */
#define PS1	0	/* command */
#define PS2	1	/* command continuation */

EXTERN char *path;		/* copy of either PATH or def_path */
EXTERN const char *def_path;	/* path to use if PATH not set */
EXTERN char *tmpdir;		/* TMPDIR value */
EXTERN const char *prompt;
EXTERN uint8_t cur_prompt;	/* PS1 or PS2 */
EXTERN int current_lineno;	/* LINENO value */

/*
 * Description of a command or an operation on commands.
 */
struct op {
	const char **args;		/* arguments to a command */
	char **vars;			/* variable assignments */
	struct ioword **ioact;		/* IO actions (eg, < > >>) */
	struct op *left, *right;	/* descendents */
	char *str;			/* word for case; identifier for for,
					 * select, and functions;
					 * path to execute for TEXEC;
					 * time hook for TCOM.
					 */
	int lineno;			/* TCOM/TFUNC: LINENO for this */
	short type;			/* operation type, see below */
	/* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
	union {
		/* TCOM: arg expansion eval() flags */
		short evalflags;
		/* TFUNC: function x (vs x()) */
		short ksh_func;
		/* TPAT: termination character */
		char charflag;
	} u;
};

/* Tree.type values */
#define TEOF		0
#define TCOM		1	/* command */
#define TPAREN		2	/* (c-list) */
#define TPIPE		3	/* a | b */
#define TLIST		4	/* a ; b */
#define TOR		5	/* || */
#define TAND		6	/* && */
#define TBANG		7	/* ! */
#define TDBRACKET	8	/* [[ .. ]] */
#define TFOR		9
#define TSELECT		10
#define TCASE		11
#define TIF		12
#define TWHILE		13
#define TUNTIL		14
#define TELIF		15
#define TPAT		16	/* pattern in case */
#define TBRACE		17	/* {c-list} */
#define TASYNC		18	/* c & */
#define TFUNCT		19	/* function name { command; } */
#define TTIME		20	/* time pipeline */
#define TEXEC		21	/* fork/exec eval'd TCOM */
#define TCOPROC		22	/* coprocess |& */

/*
 * prefix codes for words in command tree
 */
#define EOS	0	/* end of string */
#define CHAR	1	/* unquoted character */
#define QCHAR	2	/* quoted character */
#define COMSUB	3	/* $() substitution (0 terminated) */
#define EXPRSUB	4	/* $(()) substitution (0 terminated) */
#define OQUOTE	5	/* opening " or ' */
#define CQUOTE	6	/* closing " or ' */
#define OSUBST	7	/* opening ${ subst (followed by { or X) */
#define CSUBST	8	/* closing } of above (followed by } or X) */
#define OPAT	9	/* open pattern: *(, @@(, etc. */
#define SPAT	10	/* separate pattern: | */
#define CPAT	11	/* close pattern: ) */
#define ADELIM	12	/* arbitrary delimiter: ${foo:2:3} ${foo/bar/baz} */
#define FUNSUB	14	/* ${ foo;} substitution (NUL terminated) */
#define VALSUB	15	/* ${|foo;} substitution (NUL terminated) */
#define COMASUB	16	/* `…` substitution (COMSUB but expand aliases) */
#define FUNASUB	17	/* function substitution but expand aliases */

/*
 * IO redirection
 */
struct ioword {
	char *ioname;		/* filename (unused if heredoc) */
	char *delim;		/* delimiter for <<, <<- */
	char *heredoc;		/* content of heredoc */
	unsigned short ioflag;	/* action (below) */
	short unit;		/* unit (fd) affected */
};

/* ioword.flag - type of redirection */
#define IOTYPE		0xF	/* type: bits 0:3 */
#define IOREAD		0x1	/* < */
#define IOWRITE		0x2	/* > */
#define IORDWR		0x3	/* <>: todo */
#define IOHERE		0x4	/* << (here file) */
#define IOCAT		0x5	/* >> */
#define IODUP		0x6	/* <&/>& */
#define IOEVAL		BIT(4)	/* expand in << */
#define IOSKIP		BIT(5)	/* <<-, skip ^\t* */
#define IOCLOB		BIT(6)	/* >|, override -o noclobber */
#define IORDUP		BIT(7)	/* x<&y (as opposed to x>&y) */
#define IODUPSELF	BIT(8)	/* x>&x (as opposed to x>&y) */
#define IONAMEXP	BIT(9)	/* name has been expanded */
#define IOBASH		BIT(10)	/* &> etc. */
#define IOHERESTR	BIT(11)	/* <<< (here string) */
#define IONDELIM	BIT(12)	/* null delimiter (<<) */

/* execute/exchild flags */
#define XEXEC	BIT(0)		/* execute without forking */
#define XFORK	BIT(1)		/* fork before executing */
#define XBGND	BIT(2)		/* command & */
#define XPIPEI	BIT(3)		/* input is pipe */
#define XPIPEO	BIT(4)		/* output is pipe */
#define XXCOM	BIT(5)		/* `...` command */
#define XPCLOSE	BIT(6)		/* exchild: close close_fd in parent */
#define XCCLOSE	BIT(7)		/* exchild: close close_fd in child */
#define XERROK	BIT(8)		/* non-zero exit ok (for set -e) */
#define XCOPROC BIT(9)		/* starting a co-process */
#define XTIME	BIT(10)		/* timing TCOM command */
#define XPIPEST	BIT(11)		/* want PIPESTATUS */

/*
 * flags to control expansion of words (assumed by t->evalflags to fit
 * in a short)
 */
#define DOBLANK	BIT(0)		/* perform blank interpretation */
#define DOGLOB	BIT(1)		/* expand [?* */
#define DOPAT	BIT(2)		/* quote *?[ */
#define DOTILDE	BIT(3)		/* normal ~ expansion (first char) */
#define DONTRUNCOMMAND BIT(4)	/* do not run $(command) things */
#define DOASNTILDE BIT(5)	/* assignment ~ expansion (after =, :) */
#define DOBRACE BIT(6)		/* used by expand(): do brace expansion */
#define DOMAGIC BIT(7)		/* used by expand(): string contains MAGIC */
#define DOTEMP	BIT(8)		/* dito: in word part of ${..[%#=?]..} */
#define DOVACHECK BIT(9)	/* var assign check (for typeset, set, etc) */
#define DOMARKDIRS BIT(10)	/* force markdirs behaviour */
#define DOTCOMEXEC BIT(11)	/* not an eval flag, used by sh -c hack */
#define DOSCALAR BIT(12)	/* change field handling to non-list context */
#define DOHEREDOC BIT(13)	/* change scalar handling to heredoc body */
#define DOHERESTR BIT(14)	/* append a newline char */

#define X_EXTRA	20	/* this many extra bytes in X string */
#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
#define X_WASTE 15	/* allowed extra bytes to avoid shrinking, */
#else
#define X_WASTE 255	/* … must be 2ⁿ-1 */
#endif

typedef struct XString {
	/* beginning of string */
	char *beg;
	/* length of allocated area, minus safety margin */
	size_t len;
	/* end of string */
	char *end;
	/* memory area used */
	Area *areap;
} XString;

/* initialise expandable string */
#define XinitN(xs, length, area) do {				\
	(xs).len = (length);					\
	(xs).areap = (area);					\
	(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap);	\
	(xs).end = (xs).beg + (xs).len;				\
} while (/* CONSTCOND */ 0)
#define Xinit(xs, xp, length, area) do {			\
	XinitN((xs), (length), (area));				\
	(xp) = (xs).beg;					\
} while (/* CONSTCOND */ 0)

/* stuff char into string */
#define Xput(xs, xp, c)	(*xp++ = (c))

/* check if there are at least n bytes left */
#define XcheckN(xs, xp, n) do {					\
	ssize_t more = ((xp) + (n)) - (xs).end;			\
	if (more > 0)						\
		(xp) = Xcheck_grow(&(xs), (xp), (size_t)more);	\
} while (/* CONSTCOND */ 0)

/* check for overflow, expand string */
#define Xcheck(xs, xp)	XcheckN((xs), (xp), 1)

/* free string */
#define Xfree(xs, xp)	afree((xs).beg, (xs).areap)

/* close, return string */
#define Xclose(xs, xp)	aresize((xs).beg, (xp) - (xs).beg, (xs).areap)

/* beginning of string */
#define Xstring(xs, xp)	((xs).beg)

#define Xnleft(xs, xp)	((xs).end - (xp))	/* may be less than 0 */
#define Xlength(xs, xp)	((xp) - (xs).beg)
#define Xsize(xs, xp)	((xs).end - (xs).beg)
#define Xsavepos(xs, xp)	((xp) - (xs).beg)
#define Xrestpos(xs, xp, n)	((xs).beg + (n))

char *Xcheck_grow(XString *, const char *, size_t);

/*
 * expandable vector of generic pointers
 */

typedef struct {
	/* beginning of allocated area */
	void **beg;
	/* currently used number of entries */
	size_t len;
	/* allocated number of entries */
	size_t siz;
} XPtrV;

#define XPinit(x, n)	do {					\
	(x).siz = (n);						\
	(x).len = 0;						\
	(x).beg = alloc2((x).siz, sizeof(void *), ATEMP);	\
} while (/* CONSTCOND */ 0)					\

#define XPput(x, p)	do {					\
	if ((x).len == (x).siz) {				\
		(x).beg = aresize2((x).beg, (x).siz,		\
		    2 * sizeof(void *), ATEMP);			\
		(x).siz <<= 1;					\
	}							\
	(x).beg[(x).len++] = (p);				\
} while (/* CONSTCOND */ 0)

#define XPptrv(x)	((x).beg)
#define XPsize(x)	((x).len)
#define XPclose(x)	aresize2((x).beg, XPsize(x), sizeof(void *), ATEMP)
#define XPfree(x)	afree((x).beg, ATEMP)

/* for print_columns */

struct columnise_opts {
	struct shf *shf;
	char linesep;
	bool do_last;
	bool prefcol;
};

/*
 * Lexer internals
 */

typedef struct source Source;
struct source {
	/* input buffer */
	XString xs;
	/* memory area, also checked in reclaim() */
	Area *areap;
	/* stacked source */
	Source *next;
	/* input pointer */
	const char *str;
	/* start of current buffer */
	const char *start;
	/* input file name */
	const char *file;
	/* extra data */
	union {
		/* string[] */
		const char **strv;
		/* shell file */
		struct shf *shf;
		/* alias (SF_HASALIAS) */
		struct tbl *tblp;
		/* (also for SREREAD) */
		char *freeme;
	} u;
	/* flags */
	int flags;
	/* input type */
	int type;
	/* line number */
	int line;
	/* line the error occurred on (0 if not set) */
	int errline;
	/* buffer for ungetsc() (SREREAD) and alias (SALIAS) */
	char ugbuf[2];
};

/* Source.type values */
#define SEOF		0	/* input EOF */
#define SFILE		1	/* file input */
#define SSTDIN		2	/* read stdin */
#define SSTRING		3	/* string */
#define SWSTR		4	/* string without \n */
#define SWORDS		5	/* string[] */
#define SWORDSEP	6	/* string[] separator */
#define SALIAS		7	/* alias expansion */
#define SREREAD		8	/* read ahead to be re-scanned */
#define SSTRINGCMDLINE	9	/* string from "mksh -c ..." */

/* Source.flags values */
#define SF_ECHO		BIT(0)	/* echo input to shlout */
#define SF_ALIAS	BIT(1)	/* faking space at end of alias */
#define SF_ALIASEND	BIT(2)	/* faking space at end of alias */
#define SF_TTY		BIT(3)	/* type == SSTDIN & it is a tty */
#define SF_HASALIAS	BIT(4)	/* u.tblp valid (SALIAS, SEOF) */
#define SF_MAYEXEC	BIT(5)	/* special sh -c optimisation hack */

typedef union {
	int i;
	char *cp;
	char **wp;
	struct op *o;
	struct ioword *iop;
} YYSTYPE;

/* If something is added here, add it to tokentab[] in syn.c as well */
#define LWORD		256
#define LOGAND		257	/* && */
#define LOGOR		258	/* || */
#define BREAK		259	/* ;; */
#define IF		260
#define THEN		261
#define ELSE		262
#define ELIF		263
#define FI		264
#define CASE		265
#define ESAC		266
#define FOR		267
#define SELECT		268
#define WHILE		269
#define UNTIL		270
#define DO		271
#define DONE		272
#define IN		273
#define FUNCTION	274
#define TIME		275
#define REDIR		276
#define MDPAREN		277	/* (( )) */
#define BANG		278	/* ! */
#define DBRACKET	279	/* [[ .. ]] */
#define COPROC		280	/* |& */
#define BRKEV		281	/* ;| */
#define BRKFT		282	/* ;& */
#define YYERRCODE	300

/* flags to yylex */
#define CONTIN		BIT(0)	/* skip new lines to complete command */
#define ONEWORD		BIT(1)	/* single word for substitute() */
#define ALIAS		BIT(2)	/* recognise alias */
#define KEYWORD		BIT(3)	/* recognise keywords */
#define LETEXPR		BIT(4)	/* get expression inside (( )) */
#define CMDASN		BIT(5)	/* parse x[1 & 2] as one word, for typeset */
#define HEREDOC 	BIT(6)	/* parsing a here document body */
#define ESACONLY	BIT(7)	/* only accept esac keyword */
#define CMDWORD		BIT(8)	/* parsing simple command (alias related) */
#define HEREDELIM	BIT(9)	/* parsing <<,<<- delimiter */
#define LQCHAR		BIT(10)	/* source string contains QCHAR */

#define HERES		10	/* max number of << in line */

#ifdef MKSH_EBCDIC
#define CTRL_AT	(0x00U)
#define CTRL_A	(0x01U)
#define CTRL_B	(0x02U)
#define CTRL_C	(0x03U)
#define CTRL_D	(0x37U)
#define CTRL_E	(0x2DU)
#define CTRL_F	(0x2EU)
#define CTRL_G	(0x2FU)
#define CTRL_H	(0x16U)
#define CTRL_I	(0x05U)
#define CTRL_J	(0x15U)
#define CTRL_K	(0x0BU)
#define CTRL_L	(0x0CU)
#define CTRL_M	(0x0DU)
#define CTRL_N	(0x0EU)
#define CTRL_O	(0x0FU)
#define CTRL_P	(0x10U)
#define CTRL_Q	(0x11U)
#define CTRL_R	(0x12U)
#define CTRL_S	(0x13U)
#define CTRL_T	(0x3CU)
#define CTRL_U	(0x3DU)
#define CTRL_V	(0x32U)
#define CTRL_W	(0x26U)
#define CTRL_X	(0x18U)
#define CTRL_Y	(0x19U)
#define CTRL_Z	(0x3FU)
#define CTRL_BO	(0x27U)
#define CTRL_BK	(0x1CU)
#define CTRL_BC	(0x1DU)
#define CTRL_CA	(0x1EU)
#define CTRL_US	(0x1FU)
#define CTRL_QM	(0x07U)
#else
#define CTRL_AT	(0x00U)
#define CTRL_A	(0x01U)
#define CTRL_B	(0x02U)
#define CTRL_C	(0x03U)
#define CTRL_D	(0x04U)
#define CTRL_E	(0x05U)
#define CTRL_F	(0x06U)
#define CTRL_G	(0x07U)
#define CTRL_H	(0x08U)
#define CTRL_I	(0x09U)
#define CTRL_J	(0x0AU)
#define CTRL_K	(0x0BU)
#define CTRL_L	(0x0CU)
#define CTRL_M	(0x0DU)
#define CTRL_N	(0x0EU)
#define CTRL_O	(0x0FU)
#define CTRL_P	(0x10U)
#define CTRL_Q	(0x11U)
#define CTRL_R	(0x12U)
#define CTRL_S	(0x13U)
#define CTRL_T	(0x14U)
#define CTRL_U	(0x15U)
#define CTRL_V	(0x16U)
#define CTRL_W	(0x17U)
#define CTRL_X	(0x18U)
#define CTRL_Y	(0x19U)
#define CTRL_Z	(0x1AU)
#define CTRL_BO	(0x1BU)
#define CTRL_BK	(0x1CU)
#define CTRL_BC	(0x1DU)
#define CTRL_CA	(0x1EU)
#define CTRL_US	(0x1FU)
#define CTRL_QM	(0x7FU)
#endif

#define IDENT	64

EXTERN Source *source;		/* yyparse/yylex source */
EXTERN YYSTYPE yylval;		/* result from yylex */
EXTERN struct ioword *heres[HERES], **herep;
EXTERN char ident[IDENT + 1];

EXTERN char **history;		/* saved commands */
EXTERN char **histptr;		/* last history item */
EXTERN mksh_ari_t histsize;	/* history size */

/* flags to histsave */
#define HIST_FLUSH	0
#define HIST_QUEUE	1
#define HIST_APPEND	2
#define HIST_STORE	3
#define HIST_NOTE	4

/* user and system time of last j_waitjed job */
EXTERN struct timeval j_usrtime, j_systime;

#define notok2mul(max, val, c)	(((val) != 0) && ((c) != 0) && \
				    (((max) / (c)) < (val)))
#define notok2add(max, val, c)	((val) > ((max) - (c)))
#define notoktomul(val, cnst)	notok2mul(SIZE_MAX, (val), (cnst))
#define notoktoadd(val, cnst)	notok2add(SIZE_MAX, (val), (cnst))
#define checkoktoadd(val, cnst) do {					\
	if (notoktoadd((val), (cnst)))					\
		internal_errorf(Tintovfl, (size_t)(val),		\
		    '+', (size_t)(cnst));				\
} while (/* CONSTCOND */ 0)


/* lalloc.c */
void ainit(Area *);
void afreeall(Area *);
/* these cannot fail and can take NULL (not for ap) */
#define alloc(n, ap)		aresize(NULL, (n), (ap))
#define alloc2(m, n, ap)	aresize2(NULL, (m), (n), (ap))
void *aresize(void *, size_t, Area *);
void *aresize2(void *, size_t, size_t, Area *);
void afree(void *, Area *);	/* can take NULL */
#define aresizeif(z, p, n, ap)	(((p) == NULL) || ((z) < (n)) || \
				    (((z) & ~X_WASTE) > ((n) & ~X_WASTE)) ? \
				    aresize((p), (n), (ap)) : (p))
/* edit.c */
#ifndef MKSH_NO_CMDLINE_EDITING
#ifndef MKSH_SMALL
int x_bind(const char *, const char *, bool, bool);
#else
int x_bind(const char *, const char *, bool);
#endif
void x_init(void);
#ifdef DEBUG_LEAKS
void x_done(void);
#endif
int x_read(char *);
#endif
void x_mkraw(int, mksh_ttyst *, bool);
void x_initterm(const char *);
/* eval.c */
char *substitute(const char *, int);
char **eval(const char **, int);
char *evalstr(const char *cp, int);
char *evalonestr(const char *cp, int);
char *debunk(char *, const char *, size_t);
void expand(const char *, XPtrV *, int);
int glob_str(char *, XPtrV *, bool);
char *do_tilde(char *);
/* exec.c */
int execute(struct op * volatile, volatile int, volatile int * volatile);
int c_builtin(const char **);
struct tbl *get_builtin(const char *);
struct tbl *findfunc(const char *, uint32_t, bool);
int define(const char *, struct op *);
const char *builtin(const char *, int (*)(const char **));
struct tbl *findcom(const char *, int);
void flushcom(bool);
int search_access(const char *, int);
const char *search_path(const char *, const char *, int, int *);
void pr_menu(const char * const *);
void pr_list(struct columnise_opts *, char * const *);
int herein(struct ioword *, char **);
/* expr.c */
int evaluate(const char *, mksh_ari_t *, int, bool);
int v_evaluate(struct tbl *, const char *, volatile int, bool);
/* UTF-8 stuff */
size_t utf_mbtowc(unsigned int *, const char *);
size_t utf_wctomb(char *, unsigned int);
int utf_widthadj(const char *, const char **);
size_t utf_mbswidth(const char *) MKSH_A_PURE;
const char *utf_skipcols(const char *, int, int *);
size_t utf_ptradj(const char *) MKSH_A_PURE;
#ifdef MIRBSD_BOOTFLOPPY
#define utf_wcwidth(i) wcwidth((wchar_t)(i))
#else
int utf_wcwidth(unsigned int) MKSH_A_PURE;
#endif
int ksh_access(const char *, int);
struct tbl *tempvar(const char *);
/* funcs.c */
int c_hash(const char **);
int c_pwd(const char **);
int c_print(const char **);
#ifdef MKSH_PRINTF_BUILTIN
int c_printf(const char **);
#endif
int c_whence(const char **);
int c_command(const char **);
int c_typeset(const char **);
bool valid_alias_name(const char *);
int c_alias(const char **);
int c_unalias(const char **);
int c_let(const char **);
int c_jobs(const char **);
#ifndef MKSH_UNEMPLOYED
int c_fgbg(const char **);
#endif
int c_kill(const char **);
void getopts_reset(int);
int c_getopts(const char **);
#ifndef MKSH_NO_CMDLINE_EDITING
int c_bind(const char **);
#endif
int c_shift(const char **);
int c_umask(const char **);
int c_dot(const char **);
int c_wait(const char **);
int c_read(const char **);
int c_eval(const char **);
int c_trap(const char **);
int c_brkcont(const char **);
int c_exitreturn(const char **);
int c_set(const char **);
int c_unset(const char **);
int c_ulimit(const char **);
int c_times(const char **);
int timex(struct op *, int, volatile int *);
void timex_hook(struct op *, char ** volatile *);
int c_exec(const char **);
int c_test(const char **);
#if HAVE_MKNOD
int c_mknod(const char **);
#endif
int c_realpath(const char **);
int c_rename(const char **);
int c_cat(const char **);
int c_sleep(const char **);
/* histrap.c */
void init_histvec(void);
void hist_init(Source *);
#if HAVE_PERSISTENT_HISTORY
void hist_finish(void);
#endif
void histsave(int *, const char *, int, bool);
#if !defined(MKSH_SMALL) && HAVE_PERSISTENT_HISTORY
bool histsync(void);
#endif
int c_fc(const char **);
void sethistsize(mksh_ari_t);
#if HAVE_PERSISTENT_HISTORY
void sethistfile(const char *);
#endif
#if !defined(MKSH_NO_CMDLINE_EDITING) && !MKSH_S_NOVI
char **histpos(void) MKSH_A_PURE;
int histnum(int);
#endif
int findhist(int, int, const char *, bool) MKSH_A_PURE;
char **hist_get_newest(bool);
void inittraps(void);
void alarm_init(void);
Trap *gettrap(const char *, bool, bool);
void trapsig(int);
void intrcheck(void);
int fatal_trap_check(void);
int trap_pending(void);
void runtraps(int intr);
void runtrap(Trap *, bool);
void cleartraps(void);
void restoresigs(void);
void settrap(Trap *, const char *);
bool block_pipe(void);
void restore_pipe(void);
int setsig(Trap *, sig_t, int);
void setexecsig(Trap *, int);
#if HAVE_FLOCK || HAVE_LOCK_FCNTL
void mksh_lockfd(int);
void mksh_unlkfd(int);
#endif
/* jobs.c */
void j_init(void);
void j_exit(void);
#ifndef MKSH_UNEMPLOYED
void j_change(void);
#endif
int exchild(struct op *, int, volatile int *, int);
void startlast(void);
int waitlast(void);
int waitfor(const char *, int *);
int j_kill(const char *, int);
#ifndef MKSH_UNEMPLOYED
int j_resume(const char *, int);
#endif
#if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
void j_suspend(void);
#endif
int j_jobs(const char *, int, int);
void j_notify(void);
pid_t j_async(void);
int j_stopped_running(void);
/* lex.c */
int yylex(int);
void yyskiputf8bom(void);
void yyerror(const char *, ...)
    MKSH_A_NORETURN
    MKSH_A_FORMAT(__printf__, 1, 2);
Source *pushs(int, Area *);
void set_prompt(int, Source *);
int pprompt(const char *, int);
/* main.c */
int include(const char *, int, const char **, bool);
int command(const char *, int);
int shell(Source * volatile, volatile int);
/* argument MUST NOT be 0 */
void unwind(int) MKSH_A_NORETURN;
void newenv(int);
void quitenv(struct shf *);
void cleanup_parents_env(void);
void cleanup_proc_env(void);
void errorf(const char *, ...)
    MKSH_A_NORETURN
    MKSH_A_FORMAT(__printf__, 1, 2);
void errorfx(int, const char *, ...)
    MKSH_A_NORETURN
    MKSH_A_FORMAT(__printf__, 2, 3);
void warningf(bool, const char *, ...)
    MKSH_A_FORMAT(__printf__, 2, 3);
void bi_errorf(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
void maybe_errorf(int *, int, const char *, ...)
    MKSH_A_FORMAT(__printf__, 3, 4);
#define errorfz()	errorf(NULL)
#define errorfxz(rc)	errorfx((rc), NULL)
#define bi_errorfz()	bi_errorf(NULL)
void internal_errorf(const char *, ...)
    MKSH_A_NORETURN
    MKSH_A_FORMAT(__printf__, 1, 2);
void internal_warningf(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
void error_prefix(bool);
void shellf(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
void shprintf(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
int can_seek(int);
void initio(void);
void recheck_ctype(void);
int ksh_dup2(int, int, bool);
short savefd(int);
void restfd(int, int);
void openpipe(int *);
void closepipe(int *);
int check_fd(const char *, int, const char **);
void coproc_init(void);
void coproc_read_close(int);
void coproc_readw_close(int);
void coproc_write_close(int);
int coproc_getfd(int, const char **);
void coproc_cleanup(int);
struct temp *maketemp(Area *, Temp_type, struct temp **);
void ktinit(Area *, struct table *, uint8_t);
struct tbl *ktscan(struct table *, const char *, uint32_t, struct tbl ***);
/* table, name (key) to search for, hash(n) */
#define ktsearch(tp, s, h) ktscan((tp), (s), (h), NULL)
struct tbl *ktenter(struct table *, const char *, uint32_t);
#define ktdelete(p)	do { p->flag = 0; } while (/* CONSTCOND */ 0)
void ktwalk(struct tstate *, struct table *);
struct tbl *ktnext(struct tstate *);
struct tbl **ktsort(struct table *);
#ifdef DF
void DF(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
#endif
/* misc.c */
size_t option(const char *) MKSH_A_PURE;
char *getoptions(void);
void change_flag(enum sh_flag, int, bool);
void change_xtrace(unsigned char, bool);
int parse_args(const char **, int, bool *);
int getn(const char *, int *);
int gmatchx(const char *, const char *, bool);
bool has_globbing(const char *) MKSH_A_PURE;
int ascstrcmp(const void *, const void *) MKSH_A_PURE;
int ascpstrcmp(const void *, const void *) MKSH_A_PURE;
void ksh_getopt_reset(Getopt *, int);
int ksh_getopt(const char **, Getopt *, const char *);
void print_value_quoted(struct shf *, const char *);
char *quote_value(const char *);
void print_columns(struct columnise_opts *, unsigned int,
    void (*)(char *, size_t, unsigned int, const void *),
    const void *, size_t, size_t);
void strip_nuls(char *, size_t)
    MKSH_A_BOUNDED(__string__, 1, 2);
ssize_t blocking_read(int, char *, size_t)
    MKSH_A_BOUNDED(__buffer__, 2, 3);
int reset_nonblock(int);
char *ksh_get_wd(void);
char *do_realpath(const char *);
void simplify_path(char *);
void set_current_wd(const char *);
int c_cd(const char **);
#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
char *strdup_i(const char *, Area *);
char *strndup_i(const char *, size_t, Area *);
#endif
int unbksl(bool, int (*)(void), void (*)(int));
#ifdef __OS2__
/* os2.c */
void os2_init(int *, const char ***);
void setextlibpath(const char *, const char *);
int access_ex(int (*)(const char *, int), const char *, int);
int stat_ex(const char *, struct stat *);
const char *real_exec_name(const char *);
#endif
/* shf.c */
struct shf *shf_open(const char *, int, int, int);
struct shf *shf_fdopen(int, int, struct shf *);
struct shf *shf_reopen(int, int, struct shf *);
struct shf *shf_sopen(char *, ssize_t, int, struct shf *);
int shf_close(struct shf *);
int shf_fdclose(struct shf *);
char *shf_sclose(struct shf *);
int shf_flush(struct shf *);
ssize_t shf_read(char *, ssize_t, struct shf *);
char *shf_getse(char *, ssize_t, struct shf *);
int shf_getchar(struct shf *s);
int shf_ungetc(int, struct shf *);
#ifdef MKSH_SHF_NO_INLINE
int shf_getc(struct shf *);
int shf_putc(int, struct shf *);
#else
#define shf_getc shf_getc_i
#define shf_putc shf_putc_i
#endif
int shf_putchar(int, struct shf *);
ssize_t shf_puts(const char *, struct shf *);
ssize_t shf_write(const char *, ssize_t, struct shf *);
ssize_t shf_fprintf(struct shf *, const char *, ...)
    MKSH_A_FORMAT(__printf__, 2, 3);
ssize_t shf_snprintf(char *, ssize_t, const char *, ...)
    MKSH_A_FORMAT(__printf__, 3, 4)
    MKSH_A_BOUNDED(__string__, 1, 2);
char *shf_smprintf(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
ssize_t shf_vfprintf(struct shf *, const char *, va_list)
    MKSH_A_FORMAT(__printf__, 2, 0);
void set_ifs(const char *);
/* syn.c */
void initkeywords(void);
struct op *compile(Source *, bool, bool);
bool parse_usec(const char *, struct timeval *);
char *yyrecursive(int);
void yyrecursive_pop(bool);
/* tree.c */
void fptreef(struct shf *, int, const char *, ...);
char *snptreef(char *, ssize_t, const char *, ...);
struct op *tcopy(struct op *, Area *);
char *wdcopy(const char *, Area *);
const char *wdscan(const char *, int);
#define WDS_TPUTS	BIT(0)		/* tputS (dumpwdvar) mode */
char *wdstrip(const char *, int);
void tfree(struct op *, Area *);
void dumpchar(struct shf *, unsigned char);
void dumptree(struct shf *, struct op *);
void dumpwdvar(struct shf *, const char *);
void dumpioact(struct shf *shf, struct op *t);
void vistree(char *, size_t, struct op *)
    MKSH_A_BOUNDED(__string__, 1, 2);
void fpFUNCTf(struct shf *, int, bool, const char *, struct op *);
/* var.c */
void newblock(void);
void popblock(void);
void initvar(void);
struct block *varsearch(struct block *, struct tbl **, const char *, uint32_t);
struct tbl *global(const char *);
struct tbl *isglobal(const char *, bool);
struct tbl *local(const char *, bool);
char *str_val(struct tbl *);
int setstr(struct tbl *, const char *, int);
struct tbl *setint_v(struct tbl *, struct tbl *, bool);
void setint(struct tbl *, mksh_ari_t);
void setint_n(struct tbl *, mksh_ari_t, int);
struct tbl *typeset(const char *, uint32_t, uint32_t, int, int);
void unset(struct tbl *, int);
const char *skip_varname(const char *, bool) MKSH_A_PURE;
const char *skip_wdvarname(const char *, bool) MKSH_A_PURE;
int is_wdvarname(const char *, bool) MKSH_A_PURE;
int is_wdvarassign(const char *) MKSH_A_PURE;
struct tbl *arraysearch(struct tbl *, uint32_t);
char **makenv(void);
void change_winsz(void);
size_t array_ref_len(const char *) MKSH_A_PURE;
char *arrayname(const char *);
mksh_uari_t set_array(const char *, bool, const char **);
uint32_t hash(const void *) MKSH_A_PURE;
uint32_t chvt_rndsetup(const void *, size_t) MKSH_A_PURE;
mksh_ari_t rndget(void);
void rndset(unsigned long);
void rndpush(const void *);
void record_match(const char *);

enum Test_op {
	/* non-operator */
	TO_NONOP = 0,
	/* unary operators */
	TO_STNZE, TO_STZER, TO_ISSET, TO_OPTION,
	TO_FILAXST,
	TO_FILEXST,
	TO_FILREG, TO_FILBDEV, TO_FILCDEV, TO_FILSYM, TO_FILFIFO, TO_FILSOCK,
	TO_FILCDF, TO_FILID, TO_FILGID, TO_FILSETG, TO_FILSTCK, TO_FILUID,
	TO_FILRD, TO_FILGZ, TO_FILTT, TO_FILSETU, TO_FILWR, TO_FILEX,
	/* binary operators */
	TO_STEQL, TO_STNEQ, TO_STLT, TO_STGT, TO_INTEQ, TO_INTNE, TO_INTGT,
	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT,
	/* not an operator */
	TO_NONNULL	/* !TO_NONOP */
};
typedef enum Test_op Test_op;

/* Used by Test_env.isa() (order important - used to index *_tokens[] arrays) */
enum Test_meta {
	TM_OR,		/* -o or || */
	TM_AND,		/* -a or && */
	TM_NOT,		/* ! */
	TM_OPAREN,	/* ( */
	TM_CPAREN,	/* ) */
	TM_UNOP,	/* unary operator */
	TM_BINOP,	/* binary operator */
	TM_END		/* end of input */
};
typedef enum Test_meta Test_meta;

#define TEF_ERROR	BIT(0)		/* set if we've hit an error */
#define TEF_DBRACKET	BIT(1)		/* set if [[ .. ]] test */

typedef struct test_env {
	union {
		const char **wp;	/* used by ptest_* */
		XPtrV *av;		/* used by dbtestp_* */
	} pos;
	const char **wp_end;		/* used by ptest_* */
	Test_op (*isa)(struct test_env *, Test_meta);
	const char *(*getopnd) (struct test_env *, Test_op, bool);
	int (*eval)(struct test_env *, Test_op, const char *, const char *, bool);
	void (*error)(struct test_env *, int, const char *);
	int flags;			/* TEF_* */
} Test_env;

extern const char * const dbtest_tokens[];

Test_op	test_isop(Test_meta, const char *) MKSH_A_PURE;
int test_eval(Test_env *, Test_op, const char *, const char *, bool);
int test_parse(Test_env *);

/* tty_fd is not opened O_BINARY, it's thus never read/written */
EXTERN int tty_fd E_INIT(-1);	/* dup'd tty file descriptor */
EXTERN bool tty_devtty;		/* true if tty_fd is from /dev/tty */
EXTERN mksh_ttyst tty_state;	/* saved tty state */
EXTERN bool tty_hasstate;	/* true if tty_state is valid */

extern int tty_init_fd(void);	/* initialise tty_fd, tty_devtty */

#ifdef __OS2__
#define binopen2(path,flags)		__extension__({			\
	int binopen2_fd = open((path), (flags) | O_BINARY);		\
	if (binopen2_fd >= 0)						\
		setmode(binopen2_fd, O_BINARY);				\
	(binopen2_fd);							\
})
#define binopen3(path,flags,mode)	__extension__({			\
	int binopen3_fd = open((path), (flags) | O_BINARY, (mode));	\
	if (binopen3_fd >= 0)						\
		setmode(binopen3_fd, O_BINARY);				\
	(binopen3_fd);							\
})
#else
#define binopen2(path,flags)		open((path), (flags) | O_BINARY)
#define binopen3(path,flags,mode)	open((path), (flags) | O_BINARY, (mode))
#endif

#ifdef MKSH_DOSPATH
#define mksh_drvltr(s)			__extension__({			\
	const char *mksh_drvltr_s = (s);				\
	(ctype(mksh_drvltr_s[0], C_ALPHA) && mksh_drvltr_s[1] == ':');	\
})
#define mksh_abspath(s)			__extension__({			\
	const char *mksh_abspath_s = (s);				\
	(mksh_cdirsep(mksh_abspath_s[0]) ||				\
	    (mksh_drvltr(mksh_abspath_s) &&				\
	    mksh_cdirsep(mksh_abspath_s[2])));				\
})
#define mksh_cdirsep(c)			__extension__({			\
	char mksh_cdirsep_c = (c);					\
	(mksh_cdirsep_c == '/' || mksh_cdirsep_c == '\\');		\
})
#define mksh_sdirsep(s)			strpbrk((s), "/\\")
#define mksh_vdirsep(s)			__extension__({			\
	const char *mksh_vdirsep_s = (s);				\
	(((mksh_drvltr(mksh_vdirsep_s) &&				\
	    !mksh_cdirsep(mksh_vdirsep_s[2])) ? (!0) :			\
	    (mksh_sdirsep(mksh_vdirsep_s) != NULL)) &&			\
	    (strcmp(mksh_vdirsep_s, T_builtin) != 0));			\
})
int getdrvwd(char **, unsigned int);
#else
#define mksh_abspath(s)			(ord((s)[0]) == ORD('/'))
#define mksh_cdirsep(c)			(ord(c) == ORD('/'))
#define mksh_sdirsep(s)			strchr((s), '/')
#define mksh_vdirsep(s)			vstrchr((s), '/')
#endif

/* be sure not to interfere with anyone else's idea about EXTERN */
#ifdef EXTERN_DEFINED
# undef EXTERN_DEFINED
# undef EXTERN
#endif
#undef E_INIT

#endif /* !MKSH_INCLUDES_ONLY */
@


1.879
log
@sync IDSTRING code with jupp

(introduces asm for ELF, currently with everything that
pretends to be GCC except for LLVM, which might handle
it now but used not to, but others might do it as well)
@
text
@d176 1
a176 1
    !(defined(__GNUC__) && defined(__mips16)) && \
@


1.878
log
@move the “is inside eval” flag into struct env
@
text
@d14 1
a14 1
 *	       2019
d175 8
@


1.877
log
@revamp errexit handling

we lose some trap runs but this gets us identical to GNU bash so who cares…
@
text
@d186 1
a186 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.874 2019/12/11 17:56:57 tg Exp $");
d880 1
@


1.876
log
@further memory optimisation
@
text
@d188 1
a188 1
#define MKSH_VERSION "R57 2019/12/11"
d892 1
a892 1
#define LLEAVE	4	/* untrappable exit/error */
d898 1
@


1.875
log
@add beginning neatcc support, not working yet
@
text
@d188 1
a188 1
#define MKSH_VERSION "R57 2019/08/02"
d712 27
d909 1
a909 1
	uid_t kshuid_v;		/* real UID of shell */
d911 1
a911 1
	gid_t kshgid_v;		/* real GID of shell */
a1072 1
EXTERN const char Tf_sSs[] E_INIT("%s/%s");
a1095 2
#define Tf_ss (Tf_sss + 2)
EXTERN const char Tf_sss[] E_INIT("%s%s%s");
a1230 1
#define Tf_sSs "%s/%s"
a1253 2
#define Tf_ss "%s%s"
#define Tf_sss "%s%s%s"
d2033 5
d2360 3
@


1.874
log
@factor out complex ifdef into MKSH_SHF_NO_INLINE
since we may need it to make the code more portable to primitive compilers
@
text
@d186 1
a186 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.868 2018/12/04 21:13:47 tg Exp $");
d263 6
@


1.873
log
@fix regression found by, again, Martijn Dekker; tricky…

GCC fails to optimise (ptr1 == ptr2) * (tp->flag & FOO), so don’t do it
@
text
@d13 2
a14 1
 *	       2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d259 4
d2620 1
a2620 1
#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
@


1.872
log
@fix one of the issues
@
text
@d187 1
a187 1
#define MKSH_VERSION "R57 2019/08/01"
a1001 1
EXTERN const char Tsgset[] E_INIT("*=set");
d1003 1
a1162 1
#define Tsgset "*=set"
d1164 1
d1759 1
d1828 2
a1829 1
#define BF_RESETSPEC	BIT(2)	/* use ->next for set and shift */
@


1.871
log
@add two more ulimits; rlimits.opt patch and cursory descriptions are
From: Todd C. Miller <Todd.Miller@@sudo.ws>
@
text
@d187 1
a187 1
#define MKSH_VERSION "R57 2019/04/24"
d1827 1
d2515 2
@


1.870
log
@bump
@
text
@d187 1
a187 1
#define MKSH_VERSION "R57 2019/03/01"
@


1.869
log
@unwind with LEXIT ipv LLEAVE in XEXEC in one more place (1→2 of 3)

this fixes Debian #910276 and runs EXIT traps in single-child TPIPEs
and I _hope_ it does not break anything…
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2019/01/05"
d650 1
a650 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 563)
@


1.868
log
@fix ksh-style close-on-exec-for-fds-above-2 in dup-to-self scenario

bugreport by catern via IRC
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.866 2018/10/20 18:45:58 tg Exp $");
d187 1
a187 1
#define MKSH_VERSION "R56 2018/12/04"
@


1.867
log
@add O_MAYEXEC support for CLIP OS, zero cost otherwise

cf. https://lwn.net/Articles/768819/
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/10/20"
d1957 5
a1961 4
#define IONAMEXP	BIT(8)	/* name has been expanded */
#define IOBASH		BIT(9)	/* &> etc. */
#define IOHERESTR	BIT(10)	/* <<< (here string) */
#define IONDELIM	BIT(11)	/* null delimiter (<<) */
@


1.866
log
@fixup high-bit7 chars to be dumped (XXX probably want M- there)
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.864 2018/07/15 17:21:23 tg Exp $");
d494 4
@


1.865
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/07/15"
d2640 1
a2640 1
void dumpchar(struct shf *, int);
@


1.864
log
@against better judgement, allow unsetting COLUMNS:
• GNU coreutils’ test suite insists on it, even despite it can run
  successfully without doing it (WTF‽)…
• we already unspecial, explicitly commented as “hands-off” it,
  when imported from the environment
• it was already changeable (though that didn’t unspecial it on the
  command line)
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.857 2018/01/14 01:44:02 tg Exp $");
d786 1
a786 1
#define UTFMODE	Flag(FUNICODE)
@


1.863
log
@Unicode 11.0.0
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/06/26"
@


1.862
log
@fix using “-m” on the command line; spotted by G.raud <graud@@gmx.com> on ML
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/05/08"
@


1.861
log
@fix typeset -L vs. Unicode: snprintf second arg was wrong
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/05/07"
@


1.860
log
@fix allexport for arrays; add testcase that also catches exporting arrays
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/04/28"
@


1.859
log
@make ${foo#'bar'} in here document behave like ksh93
reported by Martijn Dekker <martijn@@inlv.org>
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/03/09"
@


1.858
log
@bump; add testcase provided by @@mvdan on github
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2018/01/14"
@


1.857
log
@clean up
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.856 2018/01/14 01:28:15 tg Exp $");
d187 1
a187 1
#define MKSH_VERSION "R56 2017/10/17"
@


1.856
log
@shf_getc{,har} need to return properly casted
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.848 2017/10/14 21:09:48 tg Exp $");
d1518 2
a1520 3
#define cinttype(c,t)	(intischar(c) ? \
			tobool(ksh_ctypes[(unsigned char)(c)] & (t)) : 0)
#define intischar(i)	((i) >= 0 && (i) <= 0xFF)
@


1.855
log
@after literally HOURS of debugging, I got a working-ish expression…
@
text
@d1484 1
a1484 1
		internal_errorf("%s:%d:ord(%zu)",		\
d1624 1
a1624 1
				    (shf)->rnleft--, *(shf)->rp++ : \
@


1.854
log
@plug the first couple of ctype bugs
@
text
@d1477 10
a1486 10
#define Oc(c,t)	__builtin_types_compatible_p(__typeof__(c), t)
#define ord(c)	__builtin_choose_expr(			\
    Oc((c), unsigned char) || Oc((c), char),		\
    ((unsigned int)(unsigned char)(c)), ({		\
	size_t ord_c = (c);				\
							\
	if (ord_c > 0xFF)				\
		internal_errorf("%s:%d:ord(%zu)",	\
		    __FILE__, __LINE__, ord_c);		\
	((unsigned int)(unsigned char)(c));		\
@


1.853
log
@oops, casting negative char to size_t is… not nice
@
text
@d1519 3
@


1.852
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d1477 4
a1480 1
#define ord(c)	({					\
d1487 1
a1487 1
})
@


1.851
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@a1484 1
#define CORD(c)	ORD(c)
d1487 1
a1487 2
#define ORD(c)	((void)(c), ord(c))
#define CORD(c)	ord(c)
@


1.850
log
@implement early (mediæval) locale tracking, as a compile-time option,
for SuSE; slightly inspired by the original patch submitted by
From: Dr. Werner Fink <werner@@suse.de>
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013, 2014, 2015, 2016, 2017
d559 1
a559 1
#define ISMAGIC(c)	(ord(c) == ord(MAGIC))
d807 1
a807 1
EXTERN int subshell_nesting_type;
d1472 19
a1490 1
#define ord(c)		((unsigned int)(unsigned char)(c))
d1513 1
a1513 1
#define ksh_isctrl(c)	((ord(c) & 0x7F) < 0x20 || (c) == 0x7F)
d1523 1
a1523 1
#define ksh_numdig(c)	(ord(c) - ord('0'))
d1526 1
a1526 1
#define ksh_toctrl(c)	asc2rtt(ord(c) == ord('?') ? 0x7F : rtt2asc(c) & 0x9F)
d2780 2
a2781 2
#define mksh_abspath(s)			(ord((s)[0]) == ord('/'))
#define mksh_cdirsep(c)			(ord(c) == ord('/'))
@


1.849
log
@tentatively fix Debian #878947 by putting an end to (some) nesting

‣ also makes the error message nicer:
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)'
internal error: can't allocate 8388628 data bytes
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
mksh: no closing quote
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)'
./mksh: syntax error: unmatched '('
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
./mksh: syntax error: unmatched '('

‣ alternative fix would be to keep the block and do…
-					} else {
+					} else if (source->type != SEOF) {
… but that would keep “no closing quote” for the case with newline,
and since this seems to not break… nuking unused code is always good ☻
@
text
@d646 1
a646 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 562)
d2503 1
@


1.848
log
@move getdrvwd() declaration out of OS/2-specific part:
each MKSH_DOSPATH port is required to define it (and, later, others)
@
text
@d185 1
a185 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.838 2017/08/07 21:39:26 tg Exp $");
d187 1
a187 1
#define MKSH_VERSION "R56 2017/10/14"
@


1.847
log
@handle drive-qualified nōn-absolute pathnames in do_realpath(), untested

the idea here is that:

- /foo/bar and a:/foo/bar are absolute
- foo/bar is relative
- a:foo/bar needs to be handled specially,
  mostly per making it into an absolute (“a:/” + getcwd(a:) + “foo/bar”)
@
text
@d187 1
a187 1
#define MKSH_VERSION "R56 2017/08/29"
a2568 1
int getdrvwd(char **, unsigned int);
d2759 1
@


1.846
log
@mksh_abspath() on OS/2 now requires a dir separator after the drive letter
and colon for it to recognise a pathname as absolute, as it should be

XXX make_path() unreviewed wrt this change
@
text
@d2569 1
@


1.845
log
@all uses of mksh_vdirsep should exclude “\builtin” from triggering it
@
text
@d2744 2
a2745 1
	    mksh_drvltr(mksh_abspath_s));				\
@


1.844
log
@eval.c has the only mksh_sdirsep caller and uses it on substrings,
so OS/2 drive letter checks are not correct there
@
text
@d2753 4
a2756 3
	((char *)((mksh_drvltr(mksh_vdirsep_s) &&			\
	    !mksh_cdirsep(mksh_vdirsep_s[2])) ?				\
	    (mksh_vdirsep_s + 1) : strpbrk(mksh_vdirsep_s, "/\\")));	\
@


1.843
log
@inline OS/2’s mksh_sdirsep() into its mksh_vdirsep()
because we must separate these two
@
text
@d2750 1
a2750 6
#define mksh_sdirsep(s)			__extension__({			\
	const char *mksh_sdirsep_s = (s);				\
	((char *)((mksh_drvltr(mksh_sdirsep_s) &&			\
	    !mksh_cdirsep(mksh_sdirsep_s[2])) ?				\
	    (mksh_sdirsep_s + 1) : strpbrk(mksh_sdirsep_s, "/\\")));	\
})
@


1.842
log
@introduce mksh_drvltr(s) short-hand macro
@
text
@d2756 6
a2761 1
#define mksh_vdirsep(s)			(mksh_sdirsep((s)) != NULL)
@


1.841
log
@monkey-patch offsetof for a klibc/dietlibc warning; bump to R56b (bugfixes)
@
text
@d2737 4
d2744 1
a2744 2
	    (ctype(mksh_abspath_s[0], C_ALPHA) &&			\
	    mksh_abspath_s[1] == ':'));					\
d2752 1
a2752 2
	((char *)((ctype(mksh_sdirsep_s[0], C_ALPHA) &&			\
	    mksh_sdirsep_s[1] == ':' &&					\
@


1.840
log
@bump
@
text
@d115 7
d187 1
a187 1
#define MKSH_VERSION "R56 2017/08/08"
d646 1
a646 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 561)
@


1.839
log
@fix a GCC 7 pointer target signedness warning
@
text
@d180 1
a180 1
#define MKSH_VERSION "R56 2017/08/07"
@


1.838
log
@release
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.828 2017/04/28 11:13:48 tg Exp $");
d667 1
a667 1
	const char *strdup_src = (s);					\
d678 1
a678 1
	const char *strdup_src = (s);					\
@


1.837
log
@make readonly idempotent; spotted by selk from Dragora
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/07/26"
d639 1
a639 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 551)
@


1.836
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/05/05"
@


1.835
log
@nuke unused stuff
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/05/01"
d262 2
d2176 67
a2242 67
#define CTRL_AT	0x00
#define CTRL_A	0x01
#define CTRL_B	0x02
#define CTRL_C	0x03
#define CTRL_D	0x37
#define CTRL_E	0x2D
#define CTRL_F	0x2E
#define CTRL_G	0x2F
#define CTRL_H	0x16
#define CTRL_I	0x05
#define CTRL_J	0x15
#define CTRL_K	0x0B
#define CTRL_L	0x0C
#define CTRL_M	0x0D
#define CTRL_N	0x0E
#define CTRL_O	0x0F
#define CTRL_P	0x10
#define CTRL_Q	0x11
#define CTRL_R	0x12
#define CTRL_S	0x13
#define CTRL_T	0x3C
#define CTRL_U	0x3D
#define CTRL_V	0x32
#define CTRL_W	0x26
#define CTRL_X	0x18
#define CTRL_Y	0x19
#define CTRL_Z	0x3F
#define CTRL_BO	0x27
#define CTRL_BK	0x1C
#define CTRL_BC	0x1D
#define CTRL_CA	0x1E
#define CTRL_US	0x1F
#define CTRL_QM	0x07
#else
#define CTRL_AT	0x00
#define CTRL_A	0x01
#define CTRL_B	0x02
#define CTRL_C	0x03
#define CTRL_D	0x04
#define CTRL_E	0x05
#define CTRL_F	0x06
#define CTRL_G	0x07
#define CTRL_H	0x08
#define CTRL_I	0x09
#define CTRL_J	0x0A
#define CTRL_K	0x0B
#define CTRL_L	0x0C
#define CTRL_M	0x0D
#define CTRL_N	0x0E
#define CTRL_O	0x0F
#define CTRL_P	0x10
#define CTRL_Q	0x11
#define CTRL_R	0x12
#define CTRL_S	0x13
#define CTRL_T	0x14
#define CTRL_U	0x15
#define CTRL_V	0x16
#define CTRL_W	0x17
#define CTRL_X	0x18
#define CTRL_Y	0x19
#define CTRL_Z	0x1A
#define CTRL_BO	0x1B
#define CTRL_BK	0x1C
#define CTRL_BC	0x1D
#define CTRL_CA	0x1E
#define CTRL_US	0x1F
#define CTRL_QM	0x7F
d2245 1
a2245 1
#define IDENT		64
@


1.834
log
@use strnul(); optimise
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/04/27"
a631 1
#define mkssert(e)	do { if (!(e)) exit(255); } while (/* CONSTCOND */ 0)
a634 2
#else
#define mkssert(e)	do { } while (/* CONSTCOND */ 0)
@


1.833
log
@reimplement has_globbing() with proper bracket expression parsing,
and take ahead parsing collating symbols, equivalence classes and
character classes already (heck my first draft of this already did
better than GNU bash, ksh93 I still don’t grok its code at all)
@
text
@d652 1
a652 1
#define strnul(s)	((s) + strlen(s))
@


1.832
log
@instead of disabling, make it work
@
text
@d2531 1
a2531 1
int has_globbing(const char *, const char *) MKSH_A_PURE;
@


1.831
log
@add C_ASCII (0x01 .. 0x7F: 7-bit ASCII except NUL)
@
text
@a704 5
#ifdef MKSH_EBCDIC
#undef MKSH_S_NOVI
#define MKSH_S_NOVI		1
#endif

@


1.830
log
@move three variables into common data, meaning .bss (hopefully)
@
text
@d1394 2
@


1.829
log
@keep ksh_ctypes[] array keys in EBCDIC

we set $IFS massively less often than use ctype()
@
text
@d805 2
a806 2
EXTERN struct sretrace_info *retrace_info E_INIT(NULL);
EXTERN int subshell_nesting_type E_INIT(0);
d1329 1
a1329 1
EXTERN enum tmout_enum ksh_tmout_state E_INIT(TMOUT_EXECUTING);
@


1.828
log
@add -DMKSH_FAUX_EBCDIC to test the codepaths better

waking up to: Lanfear - Just Another Broken Shell
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.826 2017/04/28 03:46:50 tg Exp $");
d1495 1
a1495 1
#define ctype(c,t)	tobool(ksh_ctypes[rtt2asc(c)] & (t))
@


1.827
log
@oops, ctypes are indexed by ASCII value even on EBCDIC systems
@
text
@d1470 1
a1470 1
#ifdef MKSH_EBCDIC
a1479 2
/* control character foo */
#define ksh_isctrl(c)	(ord(c) < 0x40 || ord(c) == 0xFF)
a1485 1
#define ksh_isctrl(c)	(((c) & 0x7F) < 0x20 || (c) == 0x7F)
d1488 6
@


1.826
log
@rename asc() to asciibetical() to make clear it’s for POSIX ordering only
and switch remaining consumers, except the allowed one, to rtt2asc()
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.818 2017/04/27 23:12:48 tg Exp $");
d1492 1
a1492 1
#define ctype(c,t)	tobool(ksh_ctypes[ord(c)] & (t))
@


1.825
log
@control character madness, but more compiler-friendly
@
text
@a1469 1
/* one-way to-ascii-or-high conversion */
d1475 3
a1477 1
#define asc(c)		((unsigned int)ebcdic_map[(unsigned char)(c)])
d1485 1
a1485 1
#define asc(c)		ord(c)
d1498 1
a1498 1
/* strictly speaking asc() here, but this works even in EBCDIC */
d1500 2
a1501 2
#define ksh_numuc(c)	(asc(c) - asc('A'))
#define ksh_numlc(c)	(asc(c) - asc('a'))
@


1.824
log
@fill two complete round-trip maps EBCDIC <-> ASCII
@
text
@d1479 2
d1487 1
d1501 2
d2175 69
a2243 4
#undef CTRL
#define	CTRL(x)		((x) == '?' ? 0x7F : (x) & 0x1F)	/* ASCII */
#define	UNCTRL(x)	((x) ^ 0x40)				/* ASCII */
#define	ISCTRL(x)	(((signed char)((uint8_t)(x) + 1)) < 33)
@


1.823
log
@apply most of the remaining parts of the EBCDIC patch, sans the CTRL() changes
@
text
@d1473 2
d1477 2
d1483 2
@


1.822
log
@commit the EBCDIC run-time table conversion code, so it can be reviewed

XXX there’s still the issue of compile-time character conversion, and
XXX that runtime m̲u̲s̲t̲ use a compatible codepage, which we cannot check,
XXX and that we need the POSIX portable character set mapped, which we
XXX decide to not check (due to the above, mostly)
@
text
@d260 15
d367 2
d509 3
d519 3
@


1.821
log
@BEL was, and Vi mode is, not EBCDIC-safe
@
text
@d1447 1
d1449 4
a1452 1
/* asc(c) must do a table lookup, non-ASCII map high */
@


1.820
log
@commit the optimisation result from the new fast character classes
@
text
@d490 11
d522 3
d526 2
a527 2
#define MAGIC		(7)	/* prefix for *?[!{,} during expand */
#define ISMAGIC(c)	((unsigned char)(c) == MAGIC)
d682 5
@


1.819
log
@allow : and [ in alias names (but forbid [[ explicitly)
to make 'enable' completely work again
@
text
@d527 5
d536 2
a537 1
    " KSH " MKSH_VERSION KSH_VERSIONNAME_TEXTMODE KSH_VERSIONNAME_VENDOR_EXT);
d1331 1
d1382 2
a1383 2
/* \x20!*+?@@		pattern magical operator */
#define C_PATMO	(CiPLUS | CiQUEST | CiSP | CiVAR1)
d1404 1
d1406 1
d1409 1
d1421 1
d2627 2
a2628 2
#define mksh_abspath(s)			((s)[0] == '/')
#define mksh_cdirsep(c)			((c) == '/')
@


1.818
log
@fixup the remaining issues and last optimisations
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.807 2017/04/08 01:07:18 tg Exp $");
d1322 1
a1322 1
#define CiCBRK	BIT(29)	/* ]				*/
d1335 2
a1336 2
/* !%,-.0‥9@@A‥Z_a‥z	valid characters in alias name */
#define C_ALIAS	(CiALIAS | CiDIGIT | CiLOWER | CiMINUS | CiOCTAL | CiPERCT | CiUNDER | CiUPPER)
d1372 1
a1372 1
#define C_MFS	(CiALIAS | CiANGLE | CiCBRK | CiCNTRL | CiCOLON | CiCR | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiMINUS | CiNL | CiNUL | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSP | CiSPX | CiTAB)
d1380 1
a1380 1
#define C_PUNCT	(CiALIAS | CiANGLE | CiCBRK | CiCOLON | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiMINUS | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSS | CiUNDER)
d1382 1
a1382 1
#define C_QUOTE	(CiANGLE | CiCBRK | CiEQUAL | CiGRAVE | CiHASH | CiNL | CiQC | CiQCL | CiQCX | CiQUEST | CiSS | CiTAB)
@


1.817
log
@batch of optimisations
@
text
@d501 1
a501 1
#define BIT(i)		(1 << (i))
d1291 1
a1291 22
#define CiCNTRL	BIT(0)	/* \x00‥\x1F\x7F	*/
#define CiUPPER	BIT(1)	/* A‥Z			*/
#define CiLOWER	BIT(2)	/* a‥z			*/
#define CiHEXLT	BIT(3)	/* A‥Fa‥f		*/
#define CiDIGIT	BIT(4)	/* 0‥9			*/
#define CiOCTAL	BIT(5)	/* 0‥7			*/
#define CiQCX	BIT(6)	/* #*=?[\\]`		*/
#define CiQCM	BIT(7)	/* +/:^{}~		*/
#define CiQCL	BIT(8)	/* &();<>|		*/
#define CiVAR1	BIT(9)	/* !#$*-?@@		*/
#define CiALIAS	BIT(10)	/* !%,-.@@		*/
#define CiSUB1	BIT(11)	/* +-=?			*/
#define CiSPX	BIT(12)	/* \x0B\x0C		*/
#define CiQC	BIT(13)	/* "'			*/
#define CiSUB2	BIT(14)	/* #%			*/
#define CiUNDER	BIT(15)	/* _			*/
#define CiNUL	BIT(16)	/* \x00			*/
#define CiTAB	BIT(17)	/* \x09			*/
#define CiNL	BIT(18)	/* \x0A			*/
#define CiSP	BIT(19)	/* \x20			*/
#define CiSS	BIT(20)	/* $			*/
#define CiCR	BIT(21)	/* \x0D			*/
d1293 32
a1324 1
#define CiIFS	BIT(30)
d1335 2
a1336 2
/* 0‥9A‥Za‥z!%,-.@@	valid characters in alias name */
#define C_ALIAS	(CiUPPER | CiLOWER | CiDIGIT | CiOCTAL | CiUNDER | CiALIAS)
d1338 3
a1340 3
#define C_ALNUM	(CiUPPER | CiLOWER | CiDIGIT | CiOCTAL)
/* 0‥9A‥Za‥z_		alphanumerical plus underscore (“word character”) */
#define C_ALNUX	(CiUPPER | CiLOWER | CiDIGIT | CiOCTAL | CiUNDER)
d1342 3
a1344 3
#define C_ALPHA	(CiUPPER | CiLOWER)
/* A‥Za‥z_		alphabetical plus underscore (identifier lead) */
#define C_ALPHX	(CiUPPER | CiLOWER | CiUNDER)
d1346 1
a1346 1
#define C_BLANK	(CiTAB | CiSP)
d1348 1
a1348 1
#define C_CFS	(CiTAB | CiSP | CiQC)
d1350 1
a1350 1
#define C_CNTRL	CiCNTRL
d1353 6
d1360 1
a1360 1
#define C_GRAPH	(CiUPPER | CiLOWER | CiDIGIT | CiOCTAL | C_PUNCT)
d1366 1
a1366 1
#define C_IFSWS	(CiTAB | CiSP | CiNL)
d1368 1
a1368 1
#define C_LEX1	(CiTAB | CiSP | CiNL | CiQCL)
d1372 1
a1372 1
#define C_MFS	(CiCNTRL | CiSP | CiQCM | CiALIAS | CiQC | CiQCL | CiQCX)
d1375 3
a1377 1
/* \x20‥\x7E		POSIX printable characters (graph plus space) */
d1380 1
a1380 1
#define C_PUNCT	(CiUNDER | CiALIAS | CiSS | CiQC | CiQCL | CiQCX)
d1382 1
a1382 1
#define C_QUOTE	(CiTAB | CiNL | CiSS | CiQC | CiQCL | CiQCX)
d1384 1
a1384 1
#define C_SEDEC	(CiDIGIT | CiOCTAL | CiHEXLT)
d1386 1
a1386 1
#define C_SPACE	(CiTAB | CiSP | CiNL | CiSPX | CiCR)
d1388 1
a1388 1
#define C_SUB1	CiSUB1
d1390 1
a1390 1
#define C_SUB2	CiSUB2
d1394 1
a1394 1
#define C_VAR1	CiVAR1
d1397 1
d1399 2
d1402 1
d1404 1
a1404 1
#define C_NL	(CiNL | CiCR)	/* CR or LF under OS/2 TEXTMODE */
d1406 1
a1406 1
#define C_NL	CiNL		/* LF only like under Unix */
d1409 1
d1417 4
a1420 1
/* identity transformation in !EBCDIC; ASCII or high in EBCDIC */
d1422 2
a1423 2
/* EBCDIC needs to compare c with both u and l */
#define ksh_eq(c,u,l)	(((c) | 0x20) == (l))
d1425 1
a1425 1
#define ctype(c, t)	tobool(ksh_ctypes[ord(c)] & (t))
@


1.816
log
@fix C_LEX1 which does STILL N̲O̲T̲ include the NUL…
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/04/20"
d1363 2
a1364 2
/* \x09\x0A\x20"#$&'()*;<=>?[\\]`|	characters requiring quoting */
#define C_QUOTE	(CiTAB | CiSP | CiNL | CiSS | CiQC | CiQCL | CiQCX)
d1403 2
a1404 2
#define ksh_tolower(c)	(ksh_isupper(c) ? (c) - 'A' + 'a' : (c))
#define ksh_toupper(c)	(ksh_islower(c) ? (c) - 'a' + 'A' : (c))
a1408 12
/* legacy functions */
#define ksh_issubop2(c)	ctype((c), C_SUB2)
#define ksh_isalias(c)	ctype((c), C_ALIAS)
#define ksh_isalpha(c)	ctype((c), C_ALPHA)
#define ksh_isalphx(c)	ctype((c), C_ALPHX)
#define ksh_isalnux(c)	ctype((c), C_ALNUX)
#define ksh_isdigit(c)	ctype((c), C_DIGIT)
#define ksh_islower(c)	ctype((c), C_LOWER)
#define ksh_isupper(c)	ctype((c), C_UPPER)
#define ksh_isspace(c)	ctype((c), C_SPACE)
#define is_cfs(c)	ctype((c), C_CFS)
#define is_mfs(c)	ctype((c), C_MFS)
d2574 1
a2574 1
	    (ksh_isalpha(mksh_abspath_s[0]) &&				\
d2583 1
a2583 1
	((char *)((ksh_isalphx(mksh_sdirsep_s[0]) &&			\
@


1.815
log
@convert to the new fast character classes
@
text
@d1351 2
a1352 2
/* \x00\x09\x0A\x20&();<>|	(for the lexer) */
#define C_LEX1	(CiTAB | CiSP | CiNL | CiQCL | CiNUL)
@


1.814
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@a535 2
#define letters_uc (digits_uc + 10)
#define letters_lc (digits_lc + 10)
d869 1
a869 2
EXTERN const char TC_LEX1[] E_INIT("|&;<>() \t\n");
#define TC_IFSWS (TC_LEX1 + 7)
a1029 1
#define TC_LEX1 "|&;<>() \t\n"
d1320 2
a1322 1
#if 0
a1390 12
#endif

/* legacy not-so-fast character classes */

#define C_ALPHX	 BIT(0)		/* A-Za-z_ */
#define C_DIGIT	 BIT(1)		/* 0-9 */
#define C_LEX1	 BIT(2)		/* \t \n\0|&;<>() */
#define C_VAR1	 BIT(3)		/* *@@#!$-? */
#define C_IFSWS	 BIT(4)		/* \t \n (IFS white space) */
#define C_SUBOP1 BIT(5)		/* "=-+?" */
#define C_QUOTE	 BIT(6)		/* \t\n "#$&'()*;<=>?[\]`| (needing quoting) */
#define C_IFS	 BIT(7)		/* $IFS */
d1392 1
a1392 3
extern unsigned char chtypes[];

#define ctype(c, t)	tobool(chtypes[(unsigned char)(c)] & (t))
d1394 1
a1394 1
/* identity transformation in !EBCDIC; Unicode map (or higher) in EBCDIC */
d1396 7
a1402 11
#define ksh_issubop2(c)	tobool(ord(c) == ord('#') || ord(c) == ord('%'))
#define ksh_isalias(c)	(ctype((c), C_ALPHX | C_DIGIT) || \
			    ord(c) == ord('!') || ord(c) == ord('%') || \
			    ord(c) == ord(',') || ord(c) == ord('.') || \
			    ord(c) == ord('@@') || ord(c) == ord('-'))
#define ksh_isalpha(c)	(ctype((c), C_ALPHX) && ord(c) != ord('_'))
#define ksh_isalphx(c)	ctype((c), C_ALPHX)
#define ksh_isalnux(c)	ctype((c), C_ALPHX | C_DIGIT)
#define ksh_isdigit(c)	ctype((c), C_DIGIT)
#define ksh_islower(c)	((asc(c) >= asc('a')) && (asc(c) <= asc('z')))
#define ksh_isupper(c)	((asc(c) >= asc('A')) && (asc(c) <= asc('Z')))
a1404 4
#define ksh_isdash(s)	(((s)[0] == '-') && ((s)[1] == '\0'))
#define ksh_isspace(c)	((((c) >= 0x09) && ((c) <= 0x0D)) || ((c) == 0x20))
/* EBCDIC needs to compare c with both */
#define ksh_eq(c,u,l)	(((c) | 0x20) == (l))
d1409 12
a1420 4
#define	is_cfs(c)	((c) == ' ' || (c) == '\t' || (c) == '"' || (c) == '\'')	/* legacy */
#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$' || ((c) & 0x80)))		/* legacy */

EXTERN char ifs0 E_INIT(' ');	/* for "$*" */
a2375 2
void setctypes(const char *, int);
void initctypes(void);
@


1.813
log
@now actually do comparisons for sorting ASCIIbetically
@
text
@d873 1
d1035 1
d1293 105
d1428 1
d1430 2
a1431 1
#define ksh_numdig(c)	(asc(c) - asc('0'))
d1434 2
d1437 1
a1437 1
EXTERN int ifs0 E_INIT(' ');	/* for "$*" */
d2467 1
@


1.812
log
@make ord() result unsigned int; add asc() which is:

• not designed to be emitted, only used in comparisons with
  other asc() results
• on EBCDIC platforms, the mapping of an EBCDIC octet to their
  corresponding ASCII or Unicode/UCS-4 codepoint or, if there
  is no mapping, a distinct value above all valid Unicode codepoints
• on nōn-EBCDIC platforms, just the identity mapping of the input
  octet into their ord() value

Intended use are ASCII-ish character ops, including ranges (“A-Z”),
mapping from those to the corresponding digit offset, and sorting
of things in an ASCIIbetical way
@
text
@d2292 2
a2293 1
int xstrcmp(const void *, const void *) MKSH_A_PURE;
@


1.811
log
@restore ‘.’ as allowed char in alias names
@
text
@d1303 9
a1311 7
#define ord(c)		((int)(unsigned char)(c))
#define ksh_issubop2(c)	tobool((c) == ord('#') || (c) == ord('%'))
#define ksh_isalias(c)	(ctype((c), C_ALPHX | C_DIGIT) || (c) == ord('!') || \
			    (c) == ord('%') || (c) == ord(',') || \
			    (c) == ord('.') || (c) == ord('@@') || \
			    (c) == ord('-'))
#define ksh_isalpha(c)	(ctype((c), C_ALPHX) && (c) != ord('_'))
d1315 2
a1316 2
#define ksh_islower(c)	(((c) >= 'a') && ((c) <= 'z'))
#define ksh_isupper(c)	(((c) >= 'A') && ((c) <= 'Z'))
d1322 3
a1324 3
#define ksh_numdig(c)	((c) - ord('0'))
#define ksh_numuc(c)	((c) - ord('A'))
#define ksh_numlc(c)	((c) - ord('a'))
@


1.810
log
@amend MAGIC comment
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/04/17"
d1307 2
a1308 1
			    (c) == ord('@@') || (c) == ord('-'))
@


1.809
log
@do not apply alias name restrictions to directories or “hash”
reported by Seb <sbb@@tuxfamily.org>
@
text
@d508 3
@


1.808
log
@add test -v, initially from Martijn Dekker
@
text
@d180 1
a180 1
#define MKSH_VERSION "R55 2017/04/12"
@


1.807
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.801 2017/04/02 15:00:44 tg Exp $");
d180 1
a180 1
#define MKSH_VERSION "R54 2017/04/07"
d596 1
a596 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 549)
d2407 1
a2407 1
	TO_STNZE, TO_STZER, TO_OPTION,
@


1.806
log
@put the hyphen-minus back into the allowed alias name characters, for
Steffen Nurpmeso <steffen@@sdaoden.eu>, except disallow it at the start
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/04/05"
d782 1
d884 2
d899 2
d952 1
d955 2
d962 1
d971 1
d973 1
d978 1
a978 1
#define Tf__d (Tf_sd + 2)
d988 1
a988 1
#define Tf_s_sD_s (Tf_cant + 6)
d994 2
a995 1
EXTERN const char Tf_cant[] E_INIT("can't %s %s: %s");
d1013 1
a1013 1
#define Tf_d (Tf_sd + 3)
d1045 2
d1060 2
d1113 1
d1116 2
d1123 1
d1132 1
d1134 1
d1155 2
a1156 1
#define Tf_cant "can't %s %s: %s"
d2217 1
a2217 1
int shell(Source * volatile, volatile bool);
@


1.805
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d1280 2
a1281 1
			  (c) == ord('%') || (c) == ord(',') || (c) == ord('@@'))
@


1.804
log
@limit alias characters to what POSIX requires
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/04/02"
d1693 2
d2081 1
d2327 1
a2327 1
struct op *compile(Source *, bool);
@


1.803
log
@streamline some error messages
@
text
@d1279 2
@


1.802
log
@string pooling, and more consistent look for error messages
@
text
@d916 1
d920 1
a920 1
EXTERN const char Tname[] E_INIT("name");
d984 1
a984 1
EXTERN const char Tf_heredoc[] E_INIT("here document '%s' unclosed\n");
d996 1
a996 1
EXTERN const char Tf_toomany[] E_INIT("too many %ss\n");
d1066 1
d1134 1
a1134 1
#define Tf_heredoc "here document '%s' unclosed\n"
d1146 1
a1146 1
#define Tf_toomany "too many %ss\n"
@


1.801
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.795 2017/03/17 22:45:53 tg Exp $");
d180 1
a180 1
#define MKSH_VERSION "R54 2017/03/25"
d876 1
d1025 1
d1478 1
a1478 1
/* set by global() and local() */
d2346 1
@


1.800
log
@introduce the -T flag to set TEXTMODE (ASCII CR+LF newline support)
@
text
@d2276 8
d2459 8
a2466 5
/*
 * I've seen mksh_sdirsep(s) and mksh_vdirsep(s) but need to think
 * more about the OS/2 port (and, possibly, toy with it) before I
 * can merge this upstream, but good job so far @@komh, thanks!
 */
@


1.799
log
@split path-specific ('C:\FOO' instead of '/foo') stuff into MKSH_DOSPATH:
• backslashes as directory separators
• semicolon as $PATH separator
• drive letters are absolute paths
@
text
@a395 1
#define MKSH_DOSPATH
d515 1
a515 1
#define KSH_VERSIONNAME	"LEGACY"
d517 1
a517 1
#define KSH_VERSIONNAME	"MIRBSD"
d519 10
a528 2
EXTERN const char initvsn[] E_INIT("KSH_VERSION=@@(#)" KSH_VERSIONNAME \
    " KSH " MKSH_VERSION);
d596 1
a596 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 541)
@


1.798
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d395 10
a406 1
#define MKSH_UNIXROOT	"/@@unixroot"
a409 1
#define MKSH_UNIXROOT	""
a2415 3
#ifndef __GNUC__
# error oops?
#endif
d2428 6
a2449 2
#define binopen2(path,flags)		open((path), (flags) | O_BINARY)
#define binopen3(path,flags,mode)	open((path), (flags) | O_BINARY, (mode))
@


1.797
log
@fixup “\builtin” on OS/2; thanks komh for spotting this
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/03/21"
d1246 1
a1246 1
#define C_ALPHA	 BIT(0)		/* a-z_A-Z */
a1253 1
#define C_SUBOP2 BIT(8)		/* "#%" (magic, see below) */
d1257 1
a1257 3
#define ctype(c, t)	tobool( ((t) == C_SUBOP2) ?			\
			    (((c) == '#' || (c) == '%') ? 1 : 0) :	\
			    (chtypes[(unsigned char)(c)] & (t)) )
d1259 5
a1263 3
#define ksh_isalphx(c)	ctype((c), C_ALPHA)
#define ksh_isalnux(c)	ctype((c), C_ALPHA | C_DIGIT)
#define ksh_isdigit(c)	(((c) >= '0') && ((c) <= '9'))
d2426 1
a2426 1
	    (ksh_isalphx(mksh_abspath_s[0]) &&				\
@


1.796
log
@add standard variable PATHSEP, for better and easier OS/2 support
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/03/19"
d868 1
d1016 1
@


1.795
log
@implement “typeset -g”, From: Martijn Dekker <martijn@@inlv.org>
also deprecate “global”; thanks!
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.754 2016/01/14 22:49:32 tg Exp $");
d180 1
a180 1
#define MKSH_VERSION "R54 2017/03/17"
@


1.794
log
@add a “\builtin” builtin, make it forward assignments, fix some bugs
related to that:
• while AT&T ksh may do it, POSIX says nothing about allowing
  declaration commands only without vars and redirections, and
  “without vars” especially seems against which commands they are
• fix relationship between forwarders and real declaration commands
• clean up c_builtin vs shcomexec mess

Also, re-run “make repool” with a fixed src/scripts/stringpool.sh,v 1.3
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/03/11"
@


1.793
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2017/02/18"
d850 2
a851 2
#define T1space (T4spaces + 3)
EXTERN const char Tcolsp[] E_INIT(": ");
d860 2
a861 2
EXTERN const char Talias[] E_INIT("alias");
EXTERN const char Tbadsubst[] E_INIT("bad substitution");
d867 2
a868 2
EXTERN const char Tgbuiltin[] E_INIT("=builtin");
#define Tbuiltin (Tgbuiltin + 1)
d877 2
a878 1
EXTERN const char Tcommand[] E_INIT("command");
d882 2
a883 2
EXTERN const char Tsgexport[] E_INIT("*=export");
#define Texport (Tsgexport + 2)
d890 1
a890 1
EXTERN const char Tfile[] E_INIT("file");
d895 1
a895 1
EXTERN const char T_funny_command[] E_INIT("funny $() command");
d897 1
a897 1
EXTERN const char Thistory[] E_INIT("history");
d913 1
a913 1
EXTERN const char Tpv[] E_INIT("pv");
d916 3
a918 3
EXTERN const char Tread[] E_INIT("read");
EXTERN const char Tsgreadonly[] E_INIT("*=readonly");
#define Treadonly (Tsgreadonly + 2)
d921 1
a921 1
EXTERN const char Treal_sp1[] E_INIT("real ");
d926 1
a926 1
#define Tset (Tsgset + 2)
d939 2
a940 2
EXTERN const char Tgtypeset[] E_INIT("=typeset");
#define Ttypeset (Tgtypeset + 1)
d945 1
a945 1
EXTERN const char Tuser_sp1[] E_INIT("user ");
d949 1
a949 1
EXTERN const char Tf__d[] E_INIT(" %d");
d951 1
a951 1
EXTERN const char Tf__sN[] E_INIT(" %s\n");
d953 1
a953 1
EXTERN const char Tf_T[] E_INIT("%T");
d958 2
a959 2
EXTERN const char Tf_s_s[] E_INIT("%s %s");
EXTERN const char Tf_s_sD_s[] E_INIT("%s %s: %s");
d972 1
a972 1
EXTERN const char Tf_lu[] E_INIT("%lu");
d975 1
a975 1
#define Tf_ss (Tf__ss + 1)
d980 1
a980 1
#define Tf_s (Tf__ss + 3)
d983 1
a983 1
#define Tf_d (Tf__d + 1)
d992 2
a993 2
#define Tf_sN (Tf__sN + 1)
#define Tf_sD_s (Tf_s_sD_s + 3)
d1014 1
a1014 1
#define Tgbuiltin "=builtin"
d1024 1
d1029 1
a1029 1
#define Tsgexport "*=export"
d1042 1
a1042 1
#define T_funny_command "funny $() command"
d1064 1
a1064 1
#define Tsgreadonly "*=readonly"
d1086 1
a1086 1
#define Tgtypeset "=typeset"
d1327 1
a1327 1
/* is called builtin SPEC_BI? (also KEEPASN, odd use though) */
d1497 2
d2018 2
a2019 1
int shcomexec(const char **);
a2085 2
/* dummy function (just need pointer value), special case in comexec() */
#define c_builtin shcomexec
a2292 1
int assign_command(const char *, bool) MKSH_A_PURE;
@


1.792
log
@in ${foo=bar}, “bar” must be scalar context; spotted by Martijn Dekker
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013, 2014, 2015, 2016
d180 1
a180 1
#define MKSH_VERSION "R54 2017/02/17"
a632 8
#ifdef MKSH_LEGACY_MODE
#ifndef MKSH_NO_CMDLINE_EDITING
#define MKSH_NO_CMDLINE_EDITING	/* defined */
#endif
#undef MKSH_S_NOVI
#define MKSH_S_NOVI		1
#endif

@


1.791
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d180 1
a180 1
#define MKSH_VERSION "R54 2016/11/11"
@


1.790
log
@fix lazy evaluation with side effects; spotted by ormaaj via IRC
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/11/07"
d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 539)
d1353 1
a1353 1
#define MKSH_DEFAULT_PROFILEDIR	"/etc"
a1750 2
typedef char *XStringP;

d1826 9
d2031 1
a2031 1
void pr_list(char * const *);
d2132 2
a2133 2
int block_pipe(void);
void restore_pipe(int);
d2247 1
a2247 1
void print_columns(struct shf *, unsigned int,
d2249 1
a2249 1
    const void *, size_t, size_t, bool);
d2430 2
a2431 1
	(mksh_abspath_s[0] == '/' || (ksh_isalphx(mksh_abspath_s[0]) &&	\
d2434 9
d2447 3
@


1.789
log
@fix error propagation in TAND/TOR constructs, noted by Martijn Dekker

still a bit unsure about the whole XERROK and *xerrok stuff, but…
it seems to work
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/10/02"
d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 531)
@


1.788
log
@fix English (thanks to Andreas Buschka); TIL:
• to start ⇒ a start
• to begin ⇒ a beginning
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/09/01"
@


1.787
log
@outstanding bumps
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/08/25"
d1741 1
a1741 1
	/* begin of string */
d1784 1
a1784 1
/* begin of string */
d1800 1
a1800 1
	/* begin of allocated area */
@


1.786
log
@fix refactoro, spotted by Natureshadow; add (working) testsuite for all operators
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/08/12"
d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 530)
@


1.785
log
@bump, required by XTaran
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/08/04"
@


1.784
log
@fixup a bad OpenBSD reaction on a bug afl showed:

set source to NULL only if the memory backing source is actually reclaimed;
fixes segfault due to NULL(+24) pointer dereference reported by Score_Under
(simplified testcase added; thanks!)
@
text
@d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 529)
@


1.783
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtc’s programmable tab completion)
to the manpage
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/08/01"
d1741 8
a1748 3
	char *end, *beg;	/* end, begin of string */
	size_t len;		/* length */
	Area *areap;		/* area to allocate/free from */
d1834 13
a1846 2
	const char *str;	/* input pointer */
	const char *start;	/* start of current buffer */
d1848 8
a1855 4
		const char **strv;	/* string [] */
		struct shf *shf;	/* shell file */
		struct tbl *tblp;	/* alias (SF_HASALIAS) */
		char *freeme;		/* also for SREREAD */
d1857 10
a1866 10
	const char *file;	/* input file name */
	int	type;		/* input type */
	int	line;		/* line number */
	int	errline;	/* line the error occurred on (0 if not set) */
	int	flags;		/* SF_* */
	Area	*areap;
	Source *next;		/* stacked source */
	XString	xs;		/* input buffer */
	char	ugbuf[2];	/* buffer for ungetsc() (SREREAD) and
				 * alias (SALIAS) */
@


1.782
log
@fix the occasional issue printing \xFF from a string
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/07/28"
d2322 1
@


1.781
log
@fix (POSIX) errorlevel of ‘.’ when sourced file has no commands; issue discovered by Natureshadow
@
text
@d1376 1
a1376 1
				    shf_putchar((c), (shf)) : \
@


1.780
log
@defer to external rename(1) too
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/07/26"
@


1.779
log
@remove fd>9 support in favour of upcoming named file descriptors; bump
@
text
@d180 1
a180 1
#define MKSH_VERSION "R53 2016/07/25"
a929 1
EXTERN const char Trename[] E_INIT("rename");
a1075 1
#define Trename "rename"
@


1.778
log
@make tmux hack workable for now (libtermcap is… ugly)

• track $TERM for the types tmux uses /^screen(-.*)?$/
• when tmux is in use (or GNU screen, really), use the, now
  hardcoded, clear-to-EOL string; otherwise, use the old behaviour
• drop unnecessary x_e_rebuildline()

carefully tested to behave no worse than R52b
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/07/24"
d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 523)
a636 3
#ifndef MKSH_CONSERVATIVE_FDS
#define MKSH_CONSERVATIVE_FDS	/* defined */
#endif
a641 3
#ifndef MKSH_CONSERVATIVE_FDS
#define MKSH_CONSERVATIVE_FDS	/* defined */
#endif
a657 2
/* these shall be smaller than 100 */
#ifdef MKSH_CONSERVATIVE_FDS
a659 4
#else
#define NUFILE		56	/* Number of user-accessible files */
#define FDBASE		24	/* First file usable by Shell */
#endif
@


1.777
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d1997 1
@


1.776
log
@invent builtin flags instead of special-casing cat and printf for prefer-external-over-builtin stuff
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/07/12"
a846 3
/* trust GCC to have string pooling; -Wformat bitches otherwise */
/*XXX TODO: make this with a .gen file plus not imake-style */

d849 40
a888 7
/* helpers for string pooling */
#if defined(__GNUC__)
#define Tsynerr		"syntax error"
#define Tintovfl	"integer overflow %zu %c %zu prevented"
#define Toomem		"can't allocate %zu data bytes"
#else
EXTERN const char Tintovfl[] E_INIT("integer overflow %zu %c %zu prevented");
d890 15
a904 1
EXTERN const char Tsynerr[] E_INIT("syntax error");
d906 38
d945 17
a961 3
EXTERN const char T_typeset[] E_INIT("=typeset");
#define Ttypeset	(T_typeset + 1)		/* "typeset" */
EXTERN const char Talias[] E_INIT("alias");
d963 87
d1051 1
a1051 1
EXTERN const char Textproc[] E_INIT("extproc");
d1053 83
a1135 16
EXTERN const char Tsgset[] E_INIT("*=set");
#define Tset		(Tsgset + 2)		/* "set" */
EXTERN const char Tsgexport[] E_INIT("*=export");
#define Texport		(Tsgexport + 2)		/* "export" */
EXTERN const char Tsgreadonly[] E_INIT("*=readonly");
#define Treadonly	(Tsgreadonly + 2)	/* "readonly" */
EXTERN const char Tgbuiltin[] E_INIT("=builtin");
#define Tbuiltin	(Tgbuiltin + 1)		/* "builtin" */
EXTERN const char T_function[] E_INIT(" function");
#define Tfunction	(T_function + 1)	/* "function" */
EXTERN const char T_funny_command[] E_INIT("funny $() command");
#define Tcommand	(T_funny_command + 10)	/* "command" */
#if defined(__GNUC__)
#define Tfg_badsubst	"fileglob: bad substitution"
#else
EXTERN const char Tfg_badsubst[] E_INIT("fileglob: bad substitution");
d1137 26
a1162 3
#define Tbadsubst	(Tfg_badsubst + 10)	/* "bad substitution" */
EXTERN const char TC_LEX1[] E_INIT("|&;<>() \t\n");
#define TC_IFSWS	(TC_LEX1 + 7)		/* space tab newline */
@


1.775
log
@experimentally use MKSH_CLRTOEOL_STRING instead of lots of spaces followed
by lots of backspaces for many clearing scenarios; requested by tmux user
slagtc on IRC
@
text
@a866 1
EXTERN const char Tcat[] E_INIT("cat");
a869 3
#ifdef MKSH_PRINTF_BUILTIN
EXTERN const char Tprintf[] E_INIT("printf");
#endif
d1242 3
@


1.774
log
@efficient $(<<<foo) and $(<<EOF … ) implementation, requested by izabera
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/06/25"
d1090 3
a1092 12
/*
 * Minimum required space to work with on a line - if the prompt leaves
 * less space than this on a line, the prompt is truncated.
 */
#define MIN_EDIT_SPACE	7
/*
 * Minimum allowed value for x_cols: 2 for prompt, 3 for " < " at end of line
 */
#define MIN_COLS	(2 + MIN_EDIT_SPACE + 3)
#define MIN_LINS	3
EXTERN mksh_ari_t x_cols E_INIT(80);	/* tty columns */
EXTERN mksh_ari_t x_lins E_INIT(24);	/* tty lines */
@


1.773
log
@increase default input line, from PLD Linux

(for as long as we still have the size static, and !MKSH_SMALL)
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/05/17"
d1755 1
@


1.772
log
@fix shf.c-internal buffer overread on printing digits,
introduced by the utf_skipcols()-related fixes, more
specifically the check for combining multibyte characters
past end of given width (bogus mixed-up semantics we have here)
by reïntroducing the NUL byte from commitid 1005474EE1E4024A4E4
@
text
@d1085 1
d1087 3
@


1.771
log
@fix utf_widthadj/utf_skipcols handling for the remaining cases I can spot
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/05/05"
@


1.770
log
@bump
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/04/14"
d1759 1
a1759 1
const char *utf_skipcols(const char *, int) MKSH_A_PURE;
@


1.769
log
@commitid 10056D5D8AF01B31531 broke fix for Debian #783978 (add testsuite)
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/04/09"
@


1.768
log
@document upcoming set +o changes; bump
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/03/04"
@


1.767
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 522)
@


1.766
log
@check not-begun heredocs at EOF earlier

izabera reported they were not caught with “set -n”
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/03/01"
a852 2
EXTERN const char Tintovfl[] E_INIT("integer overflow %zu %c %zu prevented");
EXTERN const char Toomem[] E_INIT("can't allocate %zu data bytes");
d855 2
d858 2
d2016 1
a2016 1
int assign_command(const char *, bool);
@


1.765
log
@clean up, avoid aliasing concerns in non-debug case
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/02/26"
a889 6
#if defined(__GNUC__)
#define Tmissinghere	"missing here document"
#else
EXTERN const char Tmissinghere[] E_INIT("missing here document");
#endif
#define Theredoc	(Tmissinghere + 8)	/* "here document" */
@


1.764
log
@I didn’t like the code behind command -[Vv] and whence, so I rewrote it.
Bugreport by Martijn Dekker <martijn@@inlv.org> about POSIX non-compliance
@
text
@d706 1
a708 1
#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
d711 1
a712 1
};
d715 1
d717 1
a717 3
#define ALLOC_SIZE	(sizeof(ALLOC_ITEM))
#ifndef MKSH_ALLOC_CATCH_UNDERRUNS
#define ALLOC_OVERHEAD	ALLOC_SIZE
d719 2
a720 1
#define ALLOC_OVERHEAD	0
@


1.763
log
@plug a few display problems with special parameter name expansions
reported by Stéphane Chazelas
@
text
@d1288 1
a1288 1

@


1.762
log
@share structures better, less (void *) casts when we can stay typed
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/02/23"
d1219 1
a1219 1
EXTERN struct tbl vtemp;
d1771 1
a1771 1
struct tbl *tempvar(void);
@


1.761
log
@implement mmap-using mechanism to catch buffer underruns inside mksh
(pulls stdio, is rather BSD-specific and memory-hungry and a bit slow)
@
text
@d702 2
a703 2
struct lalloc_area {
	struct lalloc_area *next;
d706 2
a707 2
struct lalloc {
	struct lalloc_area *next;
d710 1
a710 1
	char dummy[8192 - sizeof(struct lalloc_area *) - sizeof(size_t)];
d715 1
a715 1
#define ALLOC_ITEM	struct lalloc
d724 1
a724 1
typedef struct lalloc_area Area;
@


1.760
log
@so, GCC is a real bitch
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/01/21"
d702 4
d707 5
a711 1
	struct lalloc *next;
d717 5
d723 2
a724 2
/* 3. group structure (only the same for lalloc.c) */
typedef struct lalloc Area;
d1089 1
a1089 1
#define LINE		(4096 - ALLOC_SIZE)
@


1.759
log
@hotfix for newer GCC
@
text
@d834 3
a842 1
/* trust this to have string pooling; -Wformat bitches otherwise */
d871 3
d875 2
d878 1
a878 2
/* trust this to have string pooling; -Wformat bitches otherwise */
#define Tbadsubst	"bad substitution"
d880 1
a880 1
#define Tbadsubst	(Tfg_badsubst + 10)	/* "bad substitution" */
a881 1
EXTERN const char Tmissinghere[] E_INIT("missing here document");
@


1.758
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d870 4
d875 1
@


1.757
log
@fix errno in print/echo builtin; optimise (with partial rewrite)
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/01/20"
d581 1
a581 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 521)
d869 4
@


1.756
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVAR→CMDASN
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/01/19"
@


1.755
log
@incorporate more feedback from schily
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2016/01/14"
d867 2
d1637 2
a1638 2
#define VARASN		BIT(5)	/* check for var=word */
#define ARRAYVAR	BIT(6)	/* parse x[1 & 2] as one word */
a1642 1
#define HEREDOC 	BIT(11)	/* parsing a here document body */
d1993 1
a1993 1
int assign_command(const char *);
@


1.754
log
@permit 'read -A/-a arr[idx]' as long as only one element is read;
fix corruption of array indicēs with this construct (LP#1533396)
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.740 2015/08/13 21:38:19 tg Exp $");
d180 1
a180 1
#define MKSH_VERSION "R52 2016/01/13"
d382 2
@


1.753
log
@incorporate suggestions by J�rg Schilling
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013, 2014, 2015
d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.752 2015/12/31 21:03:47 tg Exp $");
d1189 2
@


1.752
log
@fstat(2) after open(2) for set -C case when initial stat(2) was !S_ISREG
to fix race condition as suggested by jilles
@
text
@d178 1
a178 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.740 2015/08/13 21:38:19 tg Exp $");
d180 1
a180 1
#define MKSH_VERSION "R52 2015/12/31"
@


1.751
log
@update for recent changes
@
text
@d180 1
a180 1
#define MKSH_VERSION "R52 2015/12/12"
@


1.750
log
@save ~1½K from the bootfloppy by reusing MirBSD libkern wcwidth(3)
but don’t bother for this for the regular /bin/mksh either
to keep the generic code path tested well
@
text
@d180 1
a180 1
#define MKSH_VERSION "R51 2015/10/24"
d579 1
a579 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 511)
a2000 2
#define WDS_KEEPQ	BIT(1)		/* keep quote characters */
#define WDS_MAGIC	BIT(2)		/* make MAGIC */
@


1.749
log
@make “source” into a built-in command (keepasn, to match ksh93 and “dot”);
remove the “stop” alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d111 3
d180 1
a180 1
#define MKSH_VERSION "R51 2015/10/09"
d1733 3
d1737 1
@


1.748
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@d177 1
a177 1
#define MKSH_VERSION "R51 2015/10/05"
a389 1
#define MKSH_PATHSEPE	"\\;"
a393 1
#define MKSH_PATHSEPE	":"
d1048 1
a1048 1
/* is called builtin SPEC_BI? */
a1072 3
#if defined(ANDROID)
#define MKSH_DEFAULT_PROFILEDIR	"/system/etc"
#else
a1074 1
#endif
d1716 1
@


1.747
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d1401 1
a1401 1
	char *name;		/* filename (unused if heredoc) */
@


1.746
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d1637 4
a1640 3
#define HEREDELIM	BIT(8)	/* parsing <<,<<- delimiter */
#define LQCHAR		BIT(9)	/* source string contains QCHAR */
#define HEREDOC 	BIT(10)	/* parsing a here document body */
@


1.745
log
@stop using issetugid(2) for ±p check as it’s probably not the right tool
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.33 2013/12/18 13:53:12 millert Exp $	*/
d1031 1
a1031 1
typedef int32_t Coproc_id;
@


1.744
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d14 1
a14 1
 *	mirabilos <tg@@mirbsd.org>
d177 1
a177 1
#define MKSH_VERSION "R51 2015/09/06"
@


1.743
log
@fix tree printing multiple heredocs in one command, bug found by izabera
@
text
@d177 1
a177 1
#define MKSH_VERSION "R51 2015/09/05"
d1457 1
@


1.742
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d177 1
a177 1
#define MKSH_VERSION "R51 2015/08/13"
@


1.741
log
@quote path separator if ; in some cases; pointed out by komh
@
text
@d5 1
a5 1
/*	$OpenBSD: expand.h,v 1.6 2005/03/30 17:16:37 deraadt Exp $	*/
d14 1
a14 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.740
log
@be more careful with signals and errorlevels; bounds-check them better;
don’t trust the OS as POSuX comes up with more-than-8-bit exit codes now;
also, one more int → bool
@
text
@d175 1
a175 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.721 2015/03/20 23:37:55 tg Exp $");
d390 1
d395 1
@


1.739
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d177 1
a177 1
#define MKSH_VERSION "R51 2015/07/10"
d340 1
a340 1
#define ksh_NSIG NSIG
d342 1
a342 1
#define ksh_NSIG _NSIG
d348 1
a348 1
#define ksh_NSIG NSIG_MAX
d370 1
a370 1
#define ksh_NSIG NSIG_MAX
@


1.738
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d177 1
a177 1
#define MKSH_VERSION "R51 2015/07/09"
d384 1
a384 1
#define MKSH_EXE_EXT ".exe"
d386 11
a396 1
#define MKSH_EXE_EXT ""
d2113 5
d2121 1
@


1.737
log
@apply the new cat hack to printf, too, to prefer it over the builtin
@
text
@d67 3
d177 1
a177 1
#define MKSH_VERSION "R51 2015/07/06"
d566 1
a566 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 510)
d2087 21
@


1.736
log
@more easy OS/2 fixes

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d836 3
@


1.735
log
@a few more mksh-os2 inspired fixes
@
text
@d256 2
a257 1
#if !HAVE_GETRUSAGE
d833 3
@


1.734
log
@• revert the cat hack for realpath and rename
  ‣ I was convinced by several that more magic is never the solution
• fix a comment: function cat already had precedence
• change cat loader to look for existence, FPATH included, before
  ditching the builtin; note that in manpage
@
text
@d378 7
@


1.733
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/07/05"
d824 1
@


1.732
log
@simplify print_columns func argument: no need to return the first arg any more
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/06/28"
d1628 7
d1761 1
a1761 1
void histsave(int *, const char *, bool, bool);
@


1.731
log
@bump; nothing to merge from oksh, and nothing more from me today
@
text
@d1897 1
a1897 1
    char *(*)(char *, size_t, unsigned int, const void *),
@


1.730
log
@The check for empty patterns and patterns matching the empty string
in commitid 1004D8283F068C41C3C was bogus; it fixed Jb_boin’s issue
but izabers’s 「var=foo; echo "${var/*/x}"」 was broken; in fact we
only want to not do the looping for // if the pattern matches much.

Also, fix a spelling mistake in the manpage and change some wording
to also work with associative arrays (in the future; no change).
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/05/23"
@


1.729
log
@overhaul the signal handling:
• support NSIG_MAX from http://austingroupbugs.net/view.php?id=741
  and make a TODO for later to use sysconf(_SC_NSIG) at runtime
• bounds-check signals (e.g. no smaller than 1, but smaller than NSIG)
• align trap errorlevel with other shells
• make trap match what’s in POSIX and fixup the manpage
• refactor some code related to signals
• hide from kill builtin both EXIT and ERR pseudo-signals
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/04/29"
@


1.728
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/04/19"
d332 7
a338 3
#ifndef NSIG
#if defined(_NSIG)
#define NSIG		_NSIG
d340 1
a340 1
#define NSIG		(SIGMAX+1)
d342 3
a344 1
#define NSIG		(_SIGMAX+1)
a346 1
#define NSIG		64
d348 4
d353 20
a372 6

/* get rid of this (and awk/printf(1) in Build.sh) later */
#if (NSIG < 1)
# error Your NSIG value is not positive.
#unset NSIG
#define NSIG		64
d904 2
a905 2
#define ksh_SIGEXIT	0	/* for trap EXIT */
#define ksh_SIGERR	NSIG	/* for trap ERR */
d910 1
a910 1
extern	Trap	sigtraps[NSIG+1];
d1771 1
a1771 1
Trap *gettrap(const char *, bool);
@


1.727
log
@inline only user of ksh_min, make it more cool; drop ksh_min, ksh_max;
move ksh_isdigit etc. to ksh_isalpha etc. definitions
@
text
@d469 2
d929 1
d935 2
a936 2
#define ksh_tolower(c)	(((c) >= 'A') && ((c) <= 'Z') ? (c) - 'A' + 'a' : (c))
#define ksh_toupper(c)	(((c) >= 'a') && ((c) <= 'z') ? (c) - 'a' + 'A' : (c))
d940 3
@


1.726
log
@EBCDIC helpers and OS/390 signals
@
text
@a300 11
#define ksh_isdigit(c)	(((c) >= '0') && ((c) <= '9'))
#define ksh_islower(c)	(((c) >= 'a') && ((c) <= 'z'))
#define ksh_isupper(c)	(((c) >= 'A') && ((c) <= 'Z'))
#define ksh_tolower(c)	(((c) >= 'A') && ((c) <= 'Z') ? (c) - 'A' + 'a' : (c))
#define ksh_toupper(c)	(((c) >= 'a') && ((c) <= 'z') ? (c) - 'a' + 'A' : (c))
#define ksh_isdash(s)	(((s)[0] == '-') && ((s)[1] == '\0'))
#define ksh_isspace(c)	((((c) >= 0x09) && ((c) <= 0x0D)) || ((c) == 0x20))
#define ksh_eq(c,u,l)	(((c) | 0x20) == (l))
#define ksh_min(x,y)	((x) < (y) ? (x) : (y))
#define ksh_max(x,y)	((x) > (y) ? (x) : (y))

d929 8
@


1.725
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d308 1
@


1.724
log
@ordinarily, lineno must be mksh_uari_t, but edit.c most of all isn’t ready,
so we mitigate a bit (in var.c mostly) and tweak another type already, and
add some checks (mksh_{,u}ari_t must fit into {,unsigned }long) and print
line numbers with %lu already
@
text
@d174 1
a174 1
#define MKSH_VERSION "R51 2015/04/11"
@


1.723
log
@Implement the “FKSH functions have local scope for shell options” feature
for mksh but not lksh; bump to R51-alpha.

While here, tweak build scripts a bit, fixup MirBSD-specific Makefile
things, remove part of a comment that’s uninteresting.
@
text
@d1267 1
a1267 1
EXTERN int cur_prompt;		/* PS1 or PS2 */
@


1.722
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/20"
d540 1
a540 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 509)
@


1.721
log
@only lksh now implies unalias for a POSIX function definition (used e.g. in Debian sysvinit scripts that use a “stop” function)
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.704 2014/11/19 21:49:12 tg Exp $");
d1344 5
a1348 5
	int	unit;		/* unit affected */
	int	flag;		/* action (below) */
	char	*name;		/* file name (unused if heredoc) */
	char	*delim;		/* delimiter for <<,<<- */
	char	*heredoc;	/* content of heredoc */
@


1.720
log
@oksh rcsid-only sync, plus bonus rewrite of strip_nuls
(uses size_t ipv int for buffer size now, and no extra
calls to memchr/memmove, input is typically small)
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/13"
@


1.719
log
@“local x=$1” is supposed to not field-split and so
@
text
@d1872 2
a1873 1
void strip_nuls(char *, int);
@


1.718
log
@remove unused CMDWORD
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/08"
d1919 1
@


1.717
log
@• protect POSIX builtins and utilities from aliases, e.g:
  ‣ : → \:
  ‣ alias → \alias
    ⇒ except in some internally used cases, where we use \builtin alias
  ‣ command . → \command .
• protect Korn Shell builtins from aliases and functions, e.g:
  ‣ typeset → \builtin typeset
    ⇒ also unravels the “local” alias used
  ‣ print → \builtin print
• protect internally-used things from aliases
  ‣ “let]” is not a valid function name
  ‣ “set” is POSIX so we don’t expect anyone to override it in a function
• use “command -v” instead of “whence -p” (“which”) in most
  places; thanks izabera from #ed on IRC for pointing out
  that “command -v” is POSIX – except, “whence -p” a̲l̲w̲a̲y̲s̲ looks
  for an executable and shows its full pathname; “command -v”
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
• make most of dot.mkshrc work in the face of such aliases
  ‣ “ulimit -c” is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesn’t use them?
• update list of builtin aliases in the manpage
@
text
@d1579 3
a1581 4
#define CMDWORD		BIT(8)	/* parsing simple command (alias related) */
#define HEREDELIM	BIT(9)	/* parsing <<,<<- delimiter */
#define LQCHAR		BIT(10)	/* source string contains QCHAR */
#define HEREDOC 	BIT(11)	/* parsing a here document body */
@


1.716
log
@remove some unused string pooling stuff
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/07"
d805 2
a806 3
EXTERN const char Tlocal_typeset[] E_INIT("local=typeset");
#define T_typeset	(Tlocal_typeset + 5)	/* "=typeset" */
#define Ttypeset	(Tlocal_typeset + 6)	/* "typeset" */
@


1.715
log
@SECURITY: make “unset HISTFILE” really work

additionally, make “HISTFILE=” the same, document the truncation and
re-reading process’ further and already-known bugs; this needs work
@
text
@a804 3
EXTERN const char Tr_fc_e_dash[] E_INIT("r=fc -e -");
#define Tfc_e_dash	(Tr_fc_e_dash + 2)	/* "fc -e -" */
#define Zfc_e_dash	7			/* strlen(Tfc_e_dash) */
a811 2
EXTERN const char Tsgunset[] E_INIT("*=unset");
#define Tunset		(Tsgunset + 2)		/* "unset" */
@


1.714
log
@keep “set -x” disabled during PS4 expansion, to avoid infinite looping
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/02"
@


1.713
log
@can't set word=IFS_QUOTE if already IFS_WORD (something there)
or IFS_QUOTE (third dquote (second OQUOTE) in """something)
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/02/20"
@


1.712
log
@• fixup here document expansion (regression wrt. pdksh 5.2.14)
• adjust testsuite (and write tons of new tests) after today’s commits
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/02/19"
@


1.711
log
@oksh sync; unsure if it applies (with us using old_source and all) but
better be safe than sorry; it at least passes our testsuite

NOTE: people who can figure out how afl can be used for mksh welcome! ;-)
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/02/13"
d1405 1
@


1.710
log
@add getopts for exec (unbreaks “exec -- /bin/ls”) and steal -a and -c from ksh93
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/02/06"
@


1.709
log
@rcsid sync from obsd; misc sync; small improvements
• mksh testsuite no longer uses printf, again
• use MAXPATHLEN from <sys/param.h> as PATH_MAX fallback
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/01/25"
d1240 1
@


1.708
log
@better
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/01/04"
d315 3
d321 1
@


1.707
log
@bump version and, also, year… I hate this… 2014 is gonna follow us for a while…
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2015/01/02"
@


1.706
log
@fix here string parsing problem found by Stéphane Chazelas
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013, 2014
d174 1
a174 1
#define MKSH_VERSION "R50 2014/12/15"
@


1.705
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2014/11/25"
@


1.704
log
@rename the “tilde” function; apparently, some system headers define it
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.703 2014/11/19 18:44:11 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/11/19"
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 504)
@


1.703
log
@fix buffer overflow found by zacts from IRC (bad length calculation)
now zsh and mksh are even… :|
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.702 2014/11/14 20:21:29 tg Exp $");
d1648 1
a1648 1
char *tilde(char *);
@


1.702
log
@mark two ($@@/$* expansion-related) testcases as expected-fail, with more to come ☹
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.700 2014/10/19 20:56:33 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/11/14"
@


1.701
log
@first cut at LP#1381993 (probably incomplete) plus test coverage
also remove fbsd testsuite link, it’s gone during cvs→svn of theirs ☹
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2014/10/19"
@


1.701.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701 2014/10/19 21:53:08 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/01/11"
@


1.701.2.2
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.1 2015/01/11 22:39:53 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/01/24"
d1648 1
a1648 1
char *do_tilde(char *);
@


1.701.2.3
log
@MFC most of the rest: int → bool, MAXPATHLEN, comments/whitespace
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013, 2014, 2015
d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.2 2015/01/25 15:35:51 tg Exp $");
a314 3
#ifdef MAXPATHLEN
#define PATH_MAX	MAXPATHLEN
#else
a317 1
#endif
@


1.701.2.4
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.3 2015/01/25 15:44:07 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/01"
d540 1
a540 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 505)
a1239 1
#define BF_STOPENV	BIT(1)	/* do not export further */
a1403 1
#define DOHEREDOC BIT(13)	/* change scalar handling to heredoc body */
@


1.701.2.5
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.4 2015/03/01 15:43:05 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/03/19"
d1585 4
a1588 3
#define HEREDELIM	BIT(8)	/* parsing <<,<<- delimiter */
#define LQCHAR		BIT(9)	/* source string contains QCHAR */
#define HEREDOC 	BIT(10)	/* parsing a here document body */
d1879 1
a1879 2
void strip_nuls(char *, size_t)
    MKSH_A_BOUNDED(__string__, 1, 2);
a1925 1
int assign_command(const char *);
@


1.701.2.6
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.5 2015/03/20 22:21:08 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/04/12"
d540 1
a540 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 506)
d1350 5
a1354 5
	char *name;		/* filename (unused if heredoc) */
	char *delim;		/* delimiter for <<, <<- */
	char *heredoc;		/* content of heredoc */
	unsigned short ioflag;	/* action (below) */
	short unit;		/* unit (fd) affected */
@


1.701.2.7
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.701.2.6 2015/04/12 22:32:33 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2015/04/19"
d1273 1
a1273 1
EXTERN uint8_t cur_prompt;	/* PS1 or PS2 */
@


1.700
log
@commit patch from LP#1381965 and two testcases, one showing this is fixed,
another showing deeper problems (probably LP#1381993 “non-list contexts” or
the IFS_WS/IFS_IWS story, perhaps *all* IFS_WS (not just ternaries) really
should be IFS_IWS instead?)
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.699 2014/10/12 21:58:53 tg Exp $");
d1399 1
a1399 1
#define DOASNFIELD BIT(12)	/* is assignment, change field handling */
@


1.699
log
@POSIX says “command” loses SPEC_BI and means it too

reported by ormaaj, who even asked on the austin ML
http://thread.gmane.org/gmane.comp.standards.posix.austin.general/9907/focus=9931
clarified by jilles; also make errorlevels match ksh93
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.697 2014/10/07 15:22:17 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/10/12"
@


1.698
log
@fix x+=<<
@
text
@d995 2
a996 2
/* flags of called builtin (SPEC_BI, etc.) */
EXTERN uint32_t builtin_flag;
@


1.697
log
@fix severe regression in field splitting (LP#1378208)
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.696 2014/10/04 11:47:18 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/10/07"
@


1.696
log
@fix null pointer deref on empty nameref assignment (no ‘=’)
found by Goodbox on IRC
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.695 2014/10/03 17:32:12 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/10/04"
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 503)
@


1.695
log
@overhaul IFS handling, fix bugs reported by Stephane Chazelas and mikeserv

now we’re at: 486 passed testsuite items, 0 failed
ifs.sh still: # tests 6856 passed 6856 failed 0
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.694 2014/09/03 19:22:50 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/10/03"
@


1.694
log
@permit $1, $!, etc. to be nameref’d again ($_ was); spotted by Jb_boin, 10x!
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.693 2014/07/28 21:45:45 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/09/03"
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 502)
d1399 1
@


1.693
log
@https://android-review.googlesource.com/102253

• permit interrupts during a write(2) loop in the cat builtin, too,
  not just in the read(2) loop – fixes inability to kill a clogged
  output cat

• kill the cat when smores finish

TODO: revisit this ⓐ in more depth, ⓑ for other functions, such as
      “hd”, and ⓒ test on AOSP as well
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.692 2014/07/13 11:34:29 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/07/28"
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 501)
@


1.692
log
@fix rare infinite loop when invalid UTF-8 is in the edit buffer
From: Ivan “Colona” Delalande <colona@@ycc.fr>
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.688 2014/06/10 22:17:10 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/07/13"
@


1.691
log
@fix access-after-free crash spotted by Enjolras via IRC, thanks!
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2014/06/29"
@


1.690
log
@bump
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2014/06/24"
@


1.689
log
@remove old/unused stuff
@
text
@d174 1
a174 1
#define MKSH_VERSION "R50 2014/06/10"
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 500)
@


1.688
log
@fix “set -o pipefail” w/o PIPESTATUS, and PIPESTATUS inside COMSUBs and other sequences
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.687 2014/06/09 13:25:53 tg Exp $");
a1399 13
/*
 * The arguments of [[ .. ]] expressions are kept in t->args[] and flags
 * indicating how the arguments have been munged are kept in t->vars[].
 * The contents of t->vars[] are stuffed strings (so they can be treated
 * like all other t->vars[]) in which the second character is the one that
 * is examined. The DB_* defines are the values for these second characters.
 */
#define DB_NORM	1	/* normal argument */
#define DB_OR	2	/* || -> -o conversion */
#define DB_AND	3	/* && -> -a conversion */
#define DB_BE	4	/* an inserted -BE */
#define DB_PAT	5	/* a pattern argument */

@


1.687
log
@fix some of the signal stuff (still didn’t get rid of awk(1) and printf(1)
calls in Build.sh, we need HOSTCC for that… which we should do, using BER
or something encoded for integers, and pregenerated hashtables as planned)

also, bump to R50 beta, due to today’s language changes
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.685 2014/01/22 19:53:52 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R50 2014/06/09"
@


1.686
log
@fix LP#1277691 (“nameref RHS not syntax checked”) and the inability to
use errorf() while nameref states were being changed (by almost completely
eliminating the global variable) and the readonly first array variable
bypass (typo/refactoro); also, whitespace, one int → bool, and add a
comment wrt. the parser rewrite talked about with igli during a fever ;)
@
text
@d174 1
a174 1
#define MKSH_VERSION "R49 2014/05/27"
d345 4
d350 6
d536 1
a536 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 499)
@


1.685
log
@this was missed
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.684 2014/01/11 18:09:42 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R49 2014/01/16"
d526 1
a526 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 491)
d1171 1
a1171 1
EXTERN enum {
d1175 1
a1175 1
} set_refflag E_INIT(SRF_NOP);
d1959 1
a1959 1
const char *skip_varname(const char *, int) MKSH_A_PURE;
@


1.684
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.683 2014/01/11 16:26:28 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R49 2014/01/11"
@


1.683
log
@make the code to exec simple commands also available for mksh_small
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.682 2014/01/05 21:57:28 tg Exp $");
d174 1
a174 1
#define MKSH_VERSION "R49 2014/01/05"
a1618 42
/* NZAAT hash based on Bob Jenkins' one-at-a-time hash */

/* From: src/kern/include/nzat.h,v 1.2 2011/07/18 00:35:40 tg Exp $ */

#define NZATInit(h) do {					\
	(h) = 0;						\
} while (/* CONSTCOND */ 0)

#define NZATUpdateByte(h,b) do {				\
	(h) += (uint8_t)(b);					\
	++(h);							\
	(h) += (h) << 10;					\
	(h) ^= (h) >> 6;					\
} while (/* CONSTCOND */ 0)

#define NZATUpdateMem(h,p,z) do {				\
	register const uint8_t *NZATUpdateMem_p;		\
	register size_t NZATUpdateMem_z = (z);			\
								\
	NZATUpdateMem_p = (const void *)(p);			\
	while (NZATUpdateMem_z--)				\
		NZATUpdateByte((h), *NZATUpdateMem_p++);	\
} while (/* CONSTCOND */ 0)

#define NZATUpdateString(h,s) do {				\
	register const char *NZATUpdateString_s;		\
	register uint8_t NZATUpdateString_c;			\
								\
	NZATUpdateString_s = (const void *)(s);			\
	while ((NZATUpdateString_c = *NZATUpdateString_s++))	\
		NZATUpdateByte((h), NZATUpdateString_c);	\
} while (/* CONSTCOND */ 0)

#define NZAATFinish(h) do {					\
	(h) += (h) << 10;					\
	(h) ^= (h) >> 6;					\
	(h) += (h) << 3;					\
	(h) ^= (h) >> 11;					\
	(h) += (h) << 15;					\
} while (/* CONSTCOND */ 0)


a1855 1
uint32_t chvt_rndsetup(const void *, size_t) MKSH_A_PURE;
d1970 1
d1973 1
@


1.682
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d172 1
a172 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.680 2013/11/30 23:20:04 tg Exp $");
a1387 1
#if !defined(MKSH_SMALL)
a1388 1
#endif
a1531 1
#if !defined(MKSH_SMALL)
a1532 1
#endif
@


1.681
log
@oksh bumped array indicēs again, INT_MAX this time, still less than mksh…
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013
d125 5
d174 1
a174 1
#define MKSH_VERSION "R48 2013/11/30"
d306 1
a306 1
#define ksh_isdash(s)	(((s) != NULL) && ((s)[0] == '-') && ((s)[1] == '\0'))
a429 8
/* remove redundancies */

#if defined(MirBSD) && (MirBSD >= 0x0AB5) && !defined(MKSH_OPTSTATIC)
#define MKSH_mirbsd_wcwidth
#define utf_wcwidth(i) wcwidth((__WCHAR_TYPE__)i)
extern int wcwidth(__WCHAR_TYPE__);
#endif

d526 1
a526 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 489)
d1434 1
a1434 1
		(xp) = Xcheck_grow(&(xs), (xp), more);		\
d1715 4
a1718 6
size_t utf_mbswidth(const char *);
const char *utf_skipcols(const char *, int);
size_t utf_ptradj(const char *);
#ifndef MKSH_mirbsd_wcwidth
int utf_wcwidth(unsigned int);
#endif
d1786 1
a1786 1
char **histpos(void);
d1789 1
a1789 1
int findhist(int, int, const char *, bool);
d1902 1
d1906 1
a1906 1
size_t option(const char *);
d1913 2
a1914 2
int has_globbing(const char *, const char *);
int xstrcmp(const void *, const void *);
d2006 4
a2009 4
const char *skip_varname(const char *, int);
const char *skip_wdvarname(const char *, bool);
int is_wdvarname(const char *, bool);
int is_wdvarassign(const char *);
d2013 1
a2013 1
size_t array_ref_len(const char *);
d2016 1
a2016 1
uint32_t hash(const void *);
d2069 1
a2069 1
Test_op	test_isop(Test_meta, const char *);
@


1.680
log
@Unicode 6.3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.32 2013/11/28 10:33:37 sobrado Exp $	*/
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.679 2013/11/30 17:41:35 tg Exp $");
@


1.679
log
@detect getsid(2), also spotted by RT, this on MSYS
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.678 2013/11/30 17:33:51 tg Exp $");
d427 1
a427 1
#if defined(MirBSD) && (MirBSD >= 0x0AB3) && !defined(MKSH_OPTSTATIC)
@


1.678
log
@RCSID-only oksh sync (their whitespace changes don’t apply to us)
note that emacs.c partial peereboom rewrite is *not* merged, and kept that way
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.677 2013/11/30 00:20:48 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/11/29"
d1829 2
@


1.677
log
@revert commit 1005289433447F6CA90 as it makes the system unbootable
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.31 2012/09/10 01:25:30 tedu Exp $	*/
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.676 2013/11/17 22:28:51 tg Exp $");
@


1.676
log
@fix initial IFSWS not ignored when expanding, noticed by Seb <sbb@@tuxfamily.org>
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.672 2013/10/09 11:59:29 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/11/17"
@


1.675
log
@apply patch by Steffen Daode Nurpmeso to drop ISTRIP termios mode
@
text
@d169 1
a169 1
#define MKSH_VERSION "R48 2013/10/08"
@


1.674
log
@static option creating for cmdline and set, too
(in preparation of doing something real with set ±p)
@
text
@d421 4
@


1.673
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d667 1
a667 1
#include "sh_flags.h"
@


1.672
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d111 1
a111 1
#define MKSH_A_BOUNDED(x,y,z)	__attribute__((__bounded__ (x, y, z)))
d116 1
a116 1
#define MKSH_A_FORMAT(x,y,z)	__attribute__((__format__ (x, y, z)))
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.671 2013/09/24 20:19:44 tg Exp $");
@


1.671
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (‘;’), oksh rcsid sync (they did
accept I was right wrt. set -e), int → bool, and code merge/cleanup
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.670 2013/09/10 17:33:04 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/09/24"
d399 4
d2071 1
@


1.670
log
@integrate latest changes from oksh: Wed Sep 4 15:49:19 2013 UTC by millert

Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.668 2013/08/16 10:59:03 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/09/10"
d1590 1
d1786 1
a1786 1
int findhist(int, int, const char *, int);
@


1.669
log
@SECURITY: Unbreak “set +p”, broken by OpenBSD ksh change.

TODO: I am seriously considering following Chet and changing
the way this works, by explicitly dropping privs unless the
shell is run with -p. Every other shell does it like mksh,
except Heirloom sh, which on the other hand doesn’t know any
explicit set -p or set +p (though it doesn’t know set +foo
for any foo either).

┌──┤ QUESTION: Do we need the ability to do this:
│ tg@@blau:~ $ ./suidmksh -p -c 'whoami; set +p; whoami'
│ root
│ tg

If not, I’m seriously considering to drop set ±p as well,
only parse -p on the command line, with +p being the default,
and dropping FPRIVILEGED.

Thanks to RT for noticing and jilles for initial follow-up
discussion, as well as Chet Ramey for doing the sane/secure
thing instead of following Debian.
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.34 2012/06/27 07:17:19 otto Exp $	*/
d169 1
a169 1
#define MKSH_VERSION "R48 2013/08/23"
d521 1
a521 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 483)
d1820 1
@


1.668
log
@Ypnose discovered a problem with multi-line prompts and SIGWINCH
related to caching some values (downside, pprompt gets back doprint option)
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.667 2013/08/14 20:26:19 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/08/16"
d521 1
a521 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 481)
@


1.667
log
@fun: when writing this code I feared an off-by-one;
Steffen Daode Nurpmeso stumbled upon it and gave very detailed
instructions on how to reproduce it (thanks!); fix that

also only call x_bs0 if xcp < xep because *xep is undefined
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.666 2013/08/11 14:57:10 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/08/14"
@


1.666
log
@improve density of .rodata (with net win on .text size(1)) via better struct packing
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.665 2013/08/10 13:47:18 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/08/11"
@


1.665
log
@improve documentation and comments
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.664 2013/08/10 13:44:33 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R48 2013/08/10"
a773 7
struct shoption {
	const char *name;	/* long name of option */
	char c;			/* character flag (if any) */
	unsigned char flags;	/* OF_* */
};
extern const struct shoption options[];

@


1.664
log
@reduce amount of .bss memory needed; initialise via AEDIT at x_init
or even first run of x_vi
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.663 2013/07/26 20:33:39 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R47 2013/08/10"
@


1.663
log
@• Completely overhaul prompt length calculation and
  prompt display routines; make Emacs and Vi share
  code, permitting reducing of duplication and code
  removal as well as more consistent behaviour; put
  some common code into shared helper functions, too
• New x_adjust() logic (Emacs mode): when determining
  what portion of a line to render use a much more
  sophisticated algorithm and try to fill up ⅔ of the
  total screen width (with line and prompt both) also
  as wished from Steffen Daode Nurpmeso
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.659 2013/06/03 22:28:33 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R47 2013/07/26"
d521 1
a521 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 471)
d994 1
a994 1
#define LINE		4096
d1686 1
a1686 1
int x_read(char *, size_t);
@


1.662
log
@Steffen Daode Nurpmeso found an actual bug:

Whenever the SIGEXIT trap was set (to anything, really)
syntax errors and interruptions were not ignored any more
in an interactive shell (where they should be, unless
set -e is used); fix that.

tbd: traps should probably only be marked as pending
and run for LLEAVE/E_NONE
@
text
@d169 1
a169 1
#define MKSH_VERSION "R47 2013/07/25"
a446 2
#define LINE		4096	/* input line size */

d993 2
d1840 1
a1840 2
void pprompt(const char *, int);
int promptlen(const char *);
@


1.661
log
@fix another clobbered-by-setjmp/longjmp warning
@
text
@d169 1
a169 1
#define MKSH_VERSION "R47 2013/07/24"
@


1.660
log
@Fix most “set -x” problems (LP#1179287)

• “set -x” manually (cmdline too) snapshots fd#2 now
• “set -o inherit-xtrace” introduced; default still enabled
• reverted iodup printing to pre-R45 behaviour
• made Flag(FXTRACE) a proper state machine
@
text
@d169 1
a169 1
#define MKSH_VERSION "R47 2013/07/21"
@


1.659
log
@use ‘z’ shf printf modifier for out-of-memory message, now that we have it
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.655 2013/05/08 11:16:19 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R46 2013/06/03"
d523 1
a523 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 469)
d841 1
a841 1
#define shl_spare	(&shf_iob[0])	/* for c_read()/c_print() */
d1909 1
@


1.658
log
@fix a number of warnings and other issues:
• sig_t detection was a bit insane, it is a function-pointer type after all
• fix uninitialised variable in c_select which led to mistakenly accepting
  invalid (nōn-numeric) input and acting, randomly, upon it
• keep SIGCHLD blocked in child after forking longer, for job list manip
• block SIGCHLD ifdef DEBUG_LEAKS to not run job foo during/after afreeall
• fix annoying ISO C90 vs. C99 (un)signed constant warning
@
text
@d169 1
a169 1
#define MKSH_VERSION "R46 2013/06/01"
d787 1
a787 1
EXTERN const char Toomem[] E_INIT("can't allocate %lu data bytes");
@


1.657
log
@pull some quoting fixes from oksh; original patch from Alexander Polakov
@
text
@d169 1
a169 1
#define MKSH_VERSION "R46 2013/05/31"
@


1.656
log
@Replace wcwidth code by mine based on Unicode 6.2.0
@
text
@d6 1
a6 1
/*	$OpenBSD: lex.h,v 1.12 2013/01/20 14:47:46 stsp Exp $	*/
@


1.655
log
@declare thiswillneverbedefinedIhope to silence some configure time warnings
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.654 2013/05/02 21:59:52 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R46 2013/05/02"
d419 1
a419 1
#if defined(MirBSD) && (MirBSD >= 0x08A8) && !defined(MKSH_OPTSTATIC)
d523 1
a523 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 461)
@


1.654
log
@implement VALSUBs
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.651 2013/04/26 21:22:49 tg Exp $");
d525 1
@


1.653
log
@sync and be even more explicit

XXX some day, write the *precise* delta of MKSH_LEGACY_MODE into lksh.1
@
text
@d169 1
a169 1
#define MKSH_VERSION "R45 2013/04/27"
d523 1
a523 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 459)
d1330 1
@


1.652
log
@start next development iteration
@
text
@d169 1
a169 1
#define MKSH_VERSION "R45 2013/04/26"
@


1.651
log
@Oh well… this looks well, is done done, and gcc-snapshot doesn’t complain:
• correct order of built-in commands; use POSIX special versus “all others”
  plus “keeps assignments” as distinction, no longer play POSIX regular vs.
  others game; sync manpage
• fix LP#1156707: map (( internally to “let]” which is no valid function
  name and so can’t be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
• we do not need -Wno-overflow any more, either
• bump to R45
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.650 2013/04/26 19:40:45 tg Exp $");
d523 1
a523 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 451)
@


1.650
log
@and, finally for today, fixup the “set -x” mess I made
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.649 2013/04/26 18:27:06 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/04/26"
d523 1
a523 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 449)
d800 2
a801 4
EXTERN const char Tpalias[] E_INIT("+alias");
#define Talias		(Tpalias + 1)		/* "alias" */
EXTERN const char Tpunalias[] E_INIT("+unalias");
#define Tunalias	(Tpunalias + 1)		/* "unalias" */
a1160 1
#define REG_BI		BIT(13)	/* a POSIX regular builtin */
d1189 5
a1193 6
#define FC_FUNC		BIT(1)	/* function builtin */
#define FC_REGBI	BIT(2)	/* regular builtin */
#define FC_UNREGBI	BIT(3)	/* un-regular builtin (!special,!regular) */
#define FC_BI		(FC_SPECBI|FC_REGBI|FC_UNREGBI)
#define FC_PATH		BIT(4)	/* do path search */
#define FC_DEFPATH	BIT(5)	/* use default path in path search */
@


1.649
log
@kill dead code
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.648 2013/04/26 17:23:15 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/03/31"
@


1.648
log
@work around a workaround in dietlibc that works around brokenness in GNU tar

/* no comment… */
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.647 2013/04/01 02:37:51 tg Exp $");
a1265 4
#define NOBLOCK	((struct op *)NULL)
#define NOWORD	((char *)NULL)
#define NOWORDS	((char **)NULL)

@


1.647
log
@one can’t cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(I’m gonna have to revise lots more code…)
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.646 2013/03/30 23:31:04 tg Exp $");
d373 1
@


1.646
log
@sync clog
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.645 2013/03/29 17:33:56 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/03/30"
d474 8
d2022 1
a2022 1
void rndset(long);
@


1.645
log
@also do not, ever, use &> bashiop in lksh
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.644 2013/03/24 15:01:50 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/03/29"
@


1.644
log
@disable parsing of &> as GNU bash iop if -o posix or -o sh, based on IRC discussion where jilles(IIRC) pointed out it breaks existing valid scripts
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.643 2013/03/24 00:56:25 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/03/24"
@


1.643
log
@• let mksh “set -x” print whole TCOM trees
• plug some memory leaks in debug (“set -x”) and warning paths while here
• one from Florian (friend of Natureshadow) for WTF
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.642 2013/03/05 15:41:41 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/03/23"
@


1.642
log
@bump
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.641 2013/02/24 14:22:44 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/02/24"
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 441)
@


1.641
log
@optimise prefer_cols print_columns display
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.640 2013/02/23 20:03:31 tg Exp $");
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 440)
@


1.640
log
@both mksh(1) and POSIX say: "$@@" should always generate multiple words
issue in pdksh reported in IRC by engla, thanks!
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.639 2013/02/19 18:45:22 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R44 2013/02/23"
@


1.639
log
@one more int → bool; mention “set -o sh” may (on raare OSes) be enabled
automatically (and it differs between targets); test MidnightBSD 0.1 ash
compat code and adjust the testsuite so it passes with it enabled
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.638 2013/02/18 22:55:40 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R43 2013/02/19"
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 431)
@


1.638
log
@put list of check_categories into Makefrag.inc generated; bump patchlevel
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.637 2013/02/17 05:40:17 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R43 2013/02/18"
@


1.637
log
@backpedal with $'…' and $"…" interpolation

it turns out this breaks more legacy scripts than anticipated
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.636 2013/02/16 00:21:57 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R43 2013/02/16"
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 430)
@


1.636
log
@… I fsck’d up and built R42b from MAIN ipv mksh-R42stable… oh well.

TODO: convert enum to something like uint8_t to save even more space
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.635 2013/02/15 18:50:14 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R42 2013/02/15"
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 429)
d1587 1
a1587 2
#define HEREDOCBODY	BIT(11)	/* parsing a here document body */
#define HERESTRBODY	BIT(12)	/* parsing a here string body */
@


1.635
log
@fix too strict fix for LP#1104543 (Debian #700526)
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.634 2013/02/10 23:59:28 tg Exp $");
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 419)
@


1.634
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.633 2013/02/10 21:17:07 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R42 2013/02/10"
@


1.634.2.1
log
@bump version
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.634 2013/02/10 23:59:28 tg Exp $");
d514 1
a514 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 421)
@


1.633
log
@when leak debugging, free everything even in builtins
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.632 2013/02/10 17:41:06 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2013/01/19"
@


1.632
log
@call it DEBUG_LEAKS so Android can always enable it
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.631 2013/02/10 17:39:38 tg Exp $");
d705 1
@


1.631
log
@actually, only needed #ifdef DEBUG
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.630 2013/02/10 17:38:15 tg Exp $");
d507 3
d1680 1
a1680 1
#ifdef DEBUG
@


1.630
log
@call afreeall(AEDIT) upon close; related to LP#1106116
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.629 2013/02/10 17:18:49 tg Exp $");
d1677 1
d1679 1
@


1.629
log
@pure RCSID sync with oksh, who also added a tabcompletion fix now, with
less code, but, even according to their own comments, not as good as ours
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.627 2013/01/06 18:51:43 tg Exp $");
d1677 1
@


1.628
log
@besides more code reuse, fix $'…' everywhere (but keep it ignored in here document bodies that aren’t here strings)
@
text
@d6 1
a6 1
/*	$OpenBSD: lex.h,v 1.11 2006/05/29 18:22:24 otto Exp $	*/
@


1.627
log
@ormaaj reported “command shift” not working correctly; fix
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.626 2013/01/01 20:45:04 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2013/01/06"
d1583 2
a1584 1
#define HEREDOC		BIT(11)	/* parsing a here document */
@


1.626
log
@fix running the ERR and EXIT traps in case of set -e and/or eval (includes Debian #696823)
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.625 2013/01/01 03:32:43 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2013/01/01"
@


1.625
log
@while thinking about mirlibₘᵢₙc I figured that sys_errlist[] entries may be NULL
@
text
@d13 1
a13 1
 *	       2011, 2012
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.624 2012/12/28 04:47:50 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2012/12/31"
@


1.624
log
@RT’s build logs show that do{}while(0) is better than functional programming
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.621 2012/12/22 22:15:21 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2012/12/27"
@


1.623
log
@RT says QNX 4 has _SIGMAX not SIGMAX or NSIG
@
text
@d506 1
a506 1
#define mkssert(e)	((e) ? (void)0 : exit(255))
d508 1
a508 1
#define mkssert(e)	((void)0)
@


1.622
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d338 2
@


1.621
log
@let printf stuff compile again after cstrerror-related change
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.620 2012/12/22 00:03:42 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2012/12/21"
a381 4
#if !HAVE_SYS_SIGLIST_DECL
extern const char *const sys_siglist[];
#endif

d2054 1
a2054 1
extern const char *const dbtest_tokens[];
@


1.620
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.619 2012/12/17 23:46:33 tg Exp $");
d371 2
a372 1
#define strerror dontuse_strerror /* poisoned */
@


1.619
log
@sync clog et al.
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.615 2012/12/07 23:46:38 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2012/12/17"
@


1.618
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.617 2012/12/17 22:14:26 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2012/12/07"
@


1.617
log
@RT also said what was missing on SunOS 4.1.1 (it also needs -DMKSH_UNEMPLOYED?)
@
text
@d97 4
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.616 2012/12/17 21:55:06 tg Exp $");
d370 5
a374 2
#if !HAVE_STRERROR
extern char *strerror(int);
@


1.616
log
@merge/genericise RT’s port to Minix-vmd
@
text
@d163 1
a163 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.615 2012/12/07 23:46:38 tg Exp $");
d357 5
d366 4
@


1.615
log
@Correct mistake when doing hashtable lookup collision resolution… oops
@
text
@d41 1
d43 6
d59 1
d61 1
a96 1
#include <time.h>
d163 1
a163 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.614 2012/12/05 19:38:23 tg Exp $");
@


1.614
log
@fix libFirm/cparser -Wsign-compare
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.612 2012/12/04 01:18:32 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2012/12/05"
@


1.613
log
@shuffle declarations around (all shared between even only two files go into sh.h even if they’re not supposed to be used elsewhere) and make some static; libFirm/cparser has -Wmissing-declarations against it
@
text
@d157 1
a157 1
#define MKSH_VERSION "R41 2012/12/03"
d1875 1
a1875 1
void change_flag(enum sh_flag, int, unsigned int);
@


1.612
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.611 2012/12/01 01:36:28 tg Exp $");
d654 2
a655 1
extern struct sretrace_info *retrace_info;
d1801 1
@


1.611
log
@remove *all* nonnull assertions and other workarounds for clang scan-build

this beast evolved in the last 2½ years, and we’ve had trouble with
some of them earlier
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.610 2012/11/30 20:49:18 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2012/11/30"
a474 1
#define mkssert(e)	((e) ? (void)0 : exit(255))
d480 5
@


1.610
log
@regenerate Makefiles
@
text
@a107 5
#if HAVE_ATTRIBUTE_NONNULL
#define MKSH_A_NONNULL(a)	__attribute__(a)
#else
#define MKSH_A_NONNULL(a)	/* nothing */
#endif
d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.604 2012/11/26 23:14:46 tg Exp $");
d1964 1
a1964 2
struct tbl *typeset(const char *, uint32_t, uint32_t, int, int)
    MKSH_A_NONNULL((__nonnull__ (1)));
@


1.609
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608 2012/11/30 19:58:48 tg Exp $");
d489 1
a489 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 409)
@


1.608
log
@… oh well, but MidnightBSD gcc picks on "" too, so just stick to NULL, it’s cheapest
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.604 2012/11/26 23:14:46 tg Exp $");
a787 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a789 1
#endif
a1300 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a1301 1
#endif
d1360 1
a1360 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
d1506 1
a1506 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
@


1.608.2.1
log
@regenerate Makefiles
@
text
@d489 1
a489 1
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 411)
@


1.608.2.2
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d108 5
d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.1 2012/11/30 20:49:13 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R41 2012/12/03"
d480 1
a485 5
#endif

#if defined(DEBUG) || defined(__COVERITY__)
#define mkssert(e)	((e) ? (void)0 : exit(255))
#else
d1973 2
a1974 1
struct tbl *typeset(const char *, uint32_t, uint32_t, int, int);
@


1.608.2.3
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.2 2012/12/04 01:26:32 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2012/12/05"
d654 1
a654 2
EXTERN struct sretrace_info *retrace_info E_INIT(NULL);
EXTERN int subshell_nesting_type E_INIT(0);
a1803 1
void yyskiputf8bom(void);
d1877 1
a1877 1
void change_flag(enum sh_flag, int, bool);
@


1.608.2.4
log
@Correct mistake when doing hashtable lookup collision resolution… oops
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.3 2012/12/05 19:58:33 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2012/12/07"
@


1.608.2.5
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.4 2012/12/07 23:46:29 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2012/12/20"
@


1.608.2.6
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d13 1
a13 1
 *	       2011, 2012, 2013
a40 1
#if HAVE_BOTH_TIME_H
a41 6
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
a51 1
#if HAVE_SYS_RESOURCE_H
a52 1
#endif
d88 1
a88 4
#ifdef _ISC_UNIX
/* XXX imake style */
#include <sys/sioctl.h>
#endif
d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.5 2012/12/22 00:03:50 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R41 2013/01/01 stable"
a325 2
#elif defined(_SIGMAX)
#define NSIG		(_SIGMAX+1)
a348 5
#if !HAVE_MEMMOVE
/* we assume either memmove or bcopy exist, at the moment */
#define memmove(dst, src, len)	bcopy((src), (dst), (len))
#endif

a352 3
/* source-level forward compatibility with mksh R42 */
#define cstrerror(errnum)	((const char *)strerror(errnum))

d483 1
a483 1
#define mkssert(e)	do { if (!(e)) exit(255); } while (/* CONSTCOND */ 0)
d485 1
a485 1
#define mkssert(e)	do { } while (/* CONSTCOND */ 0)
@


1.608.2.7
log
@MFC cid 10050E9C7D31AD0F470
@
text
@d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.6 2013/01/01 21:20:08 tg Exp $");
d169 1
a169 1
#define MKSH_VERSION "R41 2013/01/05"
@


1.608.2.8
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d97 4
d167 1
a167 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.7 2013/01/06 18:59:15 tg Exp $");
@


1.608.2.9
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d163 1
a163 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.8 2013/02/10 17:11:27 tg Exp $");
d165 1
a165 1
#define MKSH_VERSION "R41 2013/02/10"
@


1.608.2.10
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d163 1
a163 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.608.2.9 2013/02/10 23:59:36 tg Exp $");
d165 1
a165 1
#define MKSH_VERSION "R41 2013/02/15"
@


1.607
log
@so’s clang…
@
text
@d1832 3
a1834 3
#define errorfz()	errorf("")
#define errorfxz(rc)	errorfx((rc), "")
#define bi_errorfz()	bi_errorf("")
@


1.606
log
@The MidnightBSD/amd64 system compiler (Target: amd64-undermydesk-freebsd)
gcc version 4.2.1 20070719  [MidnightBSD] has stricter -Wformat checking
@
text
@d1832 3
a1834 3
#define errorfz()	errorf(null)
#define errorfxz(rc)	errorfx((rc), null)
#define bi_errorfz()	bi_errorf(null)
@


1.605
log
@implement tty tracking and bump to R41 for feature completeness

• tty_fd is now never closed
• new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
• as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
• otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
• SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
• change the Uhr to match – it no longer calls stty(1) ☺
@
text
@d1832 3
a1834 3
#define errorfz()	errorf(NULL)
#define errorfxz(rc)	errorfx((rc), NULL)
#define bi_errorfz()	bi_errorf(NULL)
@


1.604
log
@sync clog
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.603 2012/11/20 18:50:46 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/11/26"
d2046 1
d2048 1
a2048 2
extern void tty_init(bool, bool);
extern void tty_close(void);
@


1.603
log
@RT tells me Minix 2 (i386) also doesn’t have gettimeofday(2)
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.602 2012/11/12 19:13:46 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/11/20"
@


1.602
log
@add checks for ~+ and ~- (inspired by posh change) and bump date,
as I’m not likely to continue hacking tonight
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.600 2012/10/30 20:49:43 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/11/12"
d341 9
a377 6
#define mksh_TIME(tv) do {		\
	(tv).tv_usec = 0;		\
	(tv).tv_sec = time(NULL);	\
} while (/* CONSTCOND */ 0)
#else
#define mksh_TIME(tv) gettimeofday(&(tv), NULL)
@


1.601
log
@save some space for error-less error messages
inspired by a bugfix for posh for something that was not a bug in here
@
text
@d162 1
a162 1
#define MKSH_VERSION "R40 2012/10/30"
@


1.600
log
@who would’ve thought proper ^C handling be so hard?
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.597 2012/10/22 20:19:16 tg Exp $");
d1829 3
a1831 3
#define errorfz()	errorf("\1")
#define errorfxz(rc)	errorfx((rc), "\1")
#define bi_errorfz()	bi_errorf("\1")
@


1.599
log
@int → bool
@
text
@d649 1
d652 2
d1939 1
a1939 1
void yyrecursive_pop(void);
@


1.598
log
@restore yyrecursive context in quitenv (LP#1069428)
@
text
@d1807 1
a1807 1
int include(const char *, int, const char **, int);
@


1.597
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.595 2012/10/21 21:55:05 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/10/22"
d649 2
d658 2
d1936 1
@


1.596
log
@introduce MKSH_DISABLE_EXPERIMENTAL and wrap the new feature introduced
in cid 1005084678C510CF7E4 in it
@
text
@d162 1
a162 1
#define MKSH_VERSION "R40 2012/10/21"
d776 1
a776 1
/* temp file used for history editing (fc -e) */
d778 4
d1293 3
a1330 1
#define XPIPE	(XPIPEI|XPIPEO)	/* member of pipe */
d1931 1
a1931 1
char *yyrecursive(void);
@


1.595
log
@defer setting exstat for eval to 0 (the one used in case shell() is empty)
until after the stuff run in shell() has had a chance to toy with $?

bug forwarded by one of our packagers, found by one of their users
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.594 2012/10/21 21:39:05 tg Exp $");
d1348 1
a1348 1
#ifndef MKSH_SMALL
d1494 1
a1494 1
#ifndef MKSH_SMALL
@


1.594
log
@add some bounds, for a subsequent commit:
• all writers of exstat ensure the value is in [0; 0xFF]
• all readers of exstat AND it with 0xFF (not strictly needed thus)
• trap_exstat is “safe”, i.e. always either -1 or [0; 0xFF]
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.593 2012/10/21 21:26:41 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/10/03"
@


1.593
log
@EXPERIMENTAL optimisation for “sh -c 'foo'” to equal “sh -c 'exit foo'” iff
several conditions are met as outlined below; for more background, refer to
http://www.FreeBSD.org/cgi/query-pr.cgi?pr=113860

We don’t yet optimise 「% sh -c '{ echo a; sleep 10;}&'; sleep 1; ps T」 so
the FreeBSD® sh approach cannot work for us, but scanning the “sh -c” argu‐
ment for disallowed characters and, if not, setting a flag that enables the
shell to exec the tree when parsed as TCOM *and not c_trap()* was possible.

Disallowed characters are currently C_QUOTE except space, that is:
Tab Newline " # $ & ' ( ) * ; < = > ? [ \ ] ` |

This should catch all cases of magic, variables, subshells, pipelines, etc.
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.592 2012/10/03 17:24:23 tg Exp $");
d296 2
@


1.592
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.591 2012/10/03 16:16:13 tg Exp $");
d1346 3
d1492 3
@


1.591
log
@rewrite some code to avoid gcc 4.8 complaining
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.588 2012/10/03 15:13:34 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/09/07"
@


1.590
log
@reorder notoktomul to have the constant as second argument like notoktoadd
@
text
@d1562 5
a1566 3
#define notoktomul(fac1, fac2)	(((fac1) != 0) && ((fac2) != 0) && \
				    ((SIZE_MAX / (fac2)) < (fac1)))
#define notoktoadd(val, cnst)	((val) > (SIZE_MAX - (cnst)))
@


1.589
log
@rewrite XPtrV to use size_t instead of pointer arithmetic, for gcc-snapshot (20120930-1) -fstrict-overflow -Wstrict-overflow=9
@
text
@d1563 1
a1563 1
				    ((SIZE_MAX / (fac1)) < (fac2)))
@


1.588
log
@repair choiceless select builtin
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.587 2012/09/21 17:20:22 tg Exp $");
d1416 7
a1422 3
typedef struct XPtrV {
	void **cur;		/* next avail pointer */
	void **beg, **end;	/* begin, end of vector */
d1425 11
a1435 14
#define XPinit(x, n) do {					\
	void **XPinit_vp;					\
	XPinit_vp = alloc2((n), sizeof(void *), ATEMP);		\
	(x).cur = (x).beg = XPinit_vp;				\
	(x).end = XPinit_vp + (n);				\
} while (/* CONSTCOND */ 0)

#define XPput(x, p) do {					\
	if ((x).cur >= (x).end) {				\
		size_t n = XPsize(x);				\
		(x).beg = aresize2((x).beg,			\
		    n, 2 * sizeof(void *), ATEMP);		\
		(x).cur = (x).beg + n;				\
		(x).end = (x).cur + n;				\
d1437 1
a1437 1
	*(x).cur++ = (p);					\
d1441 1
a1441 1
#define XPsize(x)	((x).cur - (x).beg)
d1445 3
a1447 1
#define IDENT	64
d1548 2
d1553 1
a1553 1
EXTERN char ident[IDENT+1];
@


1.587
log
@pure RCSID sync with OpenBSD, as we introduced SIGWINCH tracking earlier

XXX we could track whether tty_fd has already been successfully opened,
XXX the ttystate initialised, and then just never close it unless it is
XXX necessary, then we can keep COLUMNS/LINES accurate in scripts, even
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.586 2012/09/07 21:02:43 tg Exp $");
d1647 2
a1648 2
int pr_menu(const char * const *);
int pr_list(char * const *);
d1857 2
a1858 2
void print_columns(struct shf *, int,
    char *(*)(char *, size_t, int, const void *),
@


1.586
log
@OpenBSD found out that "building argv for $* and $@@" manipulates l->argv
in place which affects ps(1) output on BSD; create a new array and copy
the original parts from argv[] there without touching argv passed to main
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.30 2010/01/04 18:07:11 deraadt Exp $	*/
d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.585 2012/09/01 23:46:41 tg Exp $");
@


1.585
log
@Update wcwidth data from Unicode 6.1.0
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.584 2012/08/24 21:33:51 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/09/01"
@


1.584
log
@sync clog
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.578 2012/08/17 18:34:24 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/08/24"
@


1.583
log
@related to LP#1025843 fix tab completion for tilde

this code is insane, who wrote globbing and expansion for mksh’s
predecessor must have been on very interesting drugs
@
text
@d162 1
a162 1
#define MKSH_VERSION "R40 2012/08/17"
@


1.582
log
@second attempt at getting '$FOO/b*r/baz' tab-completed right,
plus the beginning of the tilde fix… do not use, this is fucking
impossible to get right, but I’d like an archival commit
@
text
@a1345 1
#define DOKEEPQCHAR BIT(11)	/* internal use by globbing code */
@


1.581
log
@repair globbing $foo/ba*r/baz
@
text
@d1346 1
a1346 1
#define DOKEEPQUOTE BIT(11)	/* internal use by globbing code */
d1638 1
@


1.580
log
@allow overriding /etc location (LP#1039713), but don’t do it
@
text
@d1346 1
@


1.579
log
@more int → bool
@
text
@d962 1
a962 1
/* This is deliberately not configurable via CPPFLAGS */
d964 1
a964 1
#define MKSH_ETC_LOCATION	"/system/etc"
d966 2
a967 1
#define MKSH_ETC_LOCATION	"/etc"
d970 2
a971 2
#define MKSH_SYSTEM_PROFILE	MKSH_ETC_LOCATION "/profile"
#define MKSH_SUID_PROFILE	MKSH_ETC_LOCATION "/suid_profile"
@


1.578
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.577 2012/08/03 18:45:32 tg Exp $");
d1635 1
a1635 1
int glob_str(char *, XPtrV *, int);
@


1.577
log
@bump
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.576 2012/07/30 21:37:15 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/08/03"
a1285 1
#define FUNSUB	14	/* ${ foo;} substitution (NUL terminated) */
d1908 1
a1908 1
char *yyrecursive(int);
@


1.576
log
@implement ksh93 feature ${ foo;}
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.574 2012/07/22 15:56:51 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/30"
@


1.575
log
@remove unused flag
@
text
@d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/21"
d768 2
d1286 1
d1909 1
a1909 1
char *yyrecursive(void);
@


1.574
log
@note that some longjmp don’t handle 0 properly
cf. <500C1B2E.9030602@@zytor.com>
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.573 2012/07/20 23:22:13 tg Exp $");
a669 1
#define EF_FUNC_PARSE	BIT(0)	/* function being parsed */
@


1.573
log
@do implement quoting, as ${foo@@Q} though, as hommage at mirmake
dedicate this “release” to Andi
and use tomorrow’s (UTC) day for version, to cover up my debian fuckup
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.572 2012/07/01 15:54:57 tg Exp $");
d634 2
d681 1
d1782 1
@


1.572
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/ – add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568 2012/06/28 20:17:37 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/01"
@


1.571
log
@imply MKSH_CONSERVATIVE_FDS by MKSH_LEGACY_MODE, too
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.570 2012/07/01 15:41:56 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/06/28"
d501 1
a501 1
#ifdef MKSH_SMALL
d1862 1
a1862 1
#ifdef MKSH_SMALL
d1880 1
a1880 1
#ifdef MKSH_SMALL
@


1.570
log
@bugfix: make CONSERVATIVE_FDS implied by MKSH_SMALL actually work
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.569 2012/07/01 15:38:07 tg Exp $");
d539 3
@


1.569
log
@dissolve the hashtab nonsense, ¾ is good, and mirkev will also use that
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568 2012/06/28 20:17:37 tg Exp $");
a414 9
/* these shall be smaller than 100 */
#ifdef MKSH_CONSERVATIVE_FDS
#define NUFILE		32	/* Number of user-accessible files */
#define FDBASE		10	/* First file usable by Shell */
#else
#define NUFILE		56	/* Number of user-accessible files */
#define FDBASE		24	/* First file usable by Shell */
#endif

d563 9
@


1.568
log
@(mksh) tighten 32-bit requirements; (lksh) switch to long; allow any bitness
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.564 2012/06/26 19:33:33 tg Exp $");
d1819 1
a1819 6
void ktinit_real(Area *, struct table *, uint8_t);
#ifdef MKSH_SMALL
#define ktinit(ap, tp, s80, s66) ktinit_real((ap), (tp), (s80))
#else
#define ktinit(ap, tp, s80, s66) ktinit_real((ap), (tp), (s66))
#endif
@


1.568.2.1
log
@cherry-pick fixes not in this branch yet
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568 2012/06/28 20:17:37 tg Exp $");
d415 9
a547 3
#ifndef MKSH_CONSERVATIVE_FDS
#define MKSH_CONSERVATIVE_FDS	/* defined */
#endif
a571 9
/* these shall be smaller than 100 */
#ifdef MKSH_CONSERVATIVE_FDS
#define NUFILE		32	/* Number of user-accessible files */
#define FDBASE		10	/* First file usable by Shell */
#else
#define NUFILE		56	/* Number of user-accessible files */
#define FDBASE		24	/* First file usable by Shell */
#endif

@


1.568.2.2
log
@version this appropriately
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568.2.1 2012/07/20 22:51:43 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/20 Debian-2"
@


1.568.2.3
log
@MFC cid 1005037D2C82E041A1D, 1005037DE8E56F5392F, 1005037EABE57131431, 1005037EEEC1CEDE454, 1005037F34F0A0722F6:
• quell tabcompletion memory leak
• fix tab completion for tilde, related to LP#1025843
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568.2.2 2012/07/20 23:31:06 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/20 Debian-3"
a1631 1
char *tilde(char *);
@


1.568.2.4
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568.2.3 2012/09/03 19:10:57 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/20 Debian-5"
@


1.568.2.5
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.568.2.4 2013/02/11 00:27:19 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/07/20 Debian-7"
@


1.567
log
@hackish work-around the lexer to make alias definitions in mksh -c
work (Closes: #517009) and mention in the manpage why they sometimes
do not work (doing so for COMSUBs is not worth the effort)
@
text
@d162 1
a162 1
#define MKSH_VERSION "R40 2012/06/26"
d175 1
d177 9
a185 6
 * NOTE: these are currently hard-coded to exactly 32 bit, do not change
 *
 * TODO: make these configurable, or add 64-bit arithmetic, somehow
 * (on some operating environments, 64-bit types are needed for some
 * things, such as the ulimit builtin, to work proper), except mksh
 * must still be able to run on systems with no native 64-bit integers
d189 1
@


1.566
log
@make tempvar() and vtemp global
@
text
@d1465 1
@


1.565
log
@sync w/ oksh (RCSID only # no change needed)
@
text
@d1066 2
d1648 1
@


1.564
log
@mh… all I’m gonna hack on upstream today… fix -t for manpage generation and cleanup code snippets; bump vsn; sync clog
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.33 2010/05/19 17:36:08 jasper Exp $	*/
d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.563 2012/06/26 18:11:05 tg Exp $");
@


1.563
log
@bump for mksh with lksh-except-long, so we get the ball moving
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.562 2012/06/25 16:05:10 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/06/25"
@


1.562
log
@add basic LEGACY KSH mode (Build.sh -L), no changes yet
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.561 2012/06/24 20:39:26 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/06/24"
@


1.561
log
@bump after dealing with all things Benny had Coverity find
remainging CIDs not listed are either

• false positive (bug in coverity)
• intentional (possibly with lint override coverity doesn't parse)
• VLA (XXX find out how to mix C99 and ANSI VLAs)
• things flagged as possible resource leaks I have no idea about
  (no biggie though, and only in error cases I think)
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.560 2012/05/09 23:20:58 tg Exp $");
d430 8
a437 1
EXTERN const char initvsn[] E_INIT("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
d539 8
@


1.560
log
@Fix typeset issues (LP: #993847)

This was actually more evil:
• use a recursive function to display blocks in reverse order,
  so that local variable values overwrite global ones
• add array support to typeset -p (from typeset -p -)
• display 'set -A varname' line before setting values, for -p
• if -p got arguments, only display those (from the innermost scope)

Also, the usual amount of code cleanup…
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.559 2012/05/05 17:37:44 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/05/09"
@


1.559
log
@sprinkle CONSERVATIVE_FDS for many older OSes; DISABLE_TTY_WARNING for BeOS and Coherent (probably more to come); NO_CMDLINE_EDITING to Plan 9; put Hurd NO_PATH_MAX into MKSH__ private namespace
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.558 2012/05/04 22:44:34 tg Exp $");
d162 1
a162 1
#define MKSH_VERSION "R40 2012/05/04"
d733 6
d1904 1
@


1.558
log
@keep up
@
text
@d160 1
a160 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.555 2012/05/04 21:47:03 tg Exp $");
d292 1
a292 1
#ifdef NO_PATH_MAX
d574 1
a574 1
#ifdef NO_PATH_MAX
@


1.557
log
@last parts of Coherent patchkit: O_ACCMODE and termio
@
text
@d85 1
a85 1
/* shudder */
d162 1
a162 1
#define MKSH_VERSION "R40 2012/04/27"
@


1.556
log
@more symlink(7) nonexistence support code
@
text
@d82 1
d84 4
d358 4
d378 10
d1591 1
a1591 1
void x_mkraw(int, struct termios *, bool);
d1977 1
a1977 1
EXTERN struct termios tty_state;	/* saved tty state */
@


1.555
log
@provide for Coherent not having gettimeofday(2), imake style (bad, but this is not for others to use without a second thought anyway)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.554 2012/05/04 21:15:34 tg Exp $");
d361 8
@


1.554
log
@more int→bool while trying to let ^D output CR+LF (which shan’t be, oh my…)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.553 2012/05/04 20:49:07 tg Exp $");
d352 9
@


1.553
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.552 2012/05/04 20:08:25 tg Exp $");
d795 1
a795 1
EXTERN int really_exit;
d1709 1
a1709 1
int shell(Source *volatile, int volatile);
@


1.552
log
@move bi_getn from misc.c to funcs.c and make it static

even antique gcc versions will usually inline it now
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.551 2012/04/27 16:16:23 tg Exp $");
d1546 1
d1553 2
a1555 1
int x_read(char *, size_t);
d1609 1
d1611 1
d1653 1
a1653 1
#if !MKSH_S_NOVI
@


1.551
log
@add experimental code to use sigprocmask+pause+sigprocmask ipv sigsuspend (and harden j_sigchld handler for that) to improve working on BeOS 5.0 and Coherent UNIX, found by RT
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.550 2012/04/22 21:50:33 tg Exp $");
a1774 1
int bi_getn(const char *, int *);
@


1.550
log
@after discussion with ciruZ, switch mksh from NZAT to NZAAT fully
to get rid of the bias introduced by making the hash never zero

… he also pointed out a memory (heap) usage optimisation… which
may impact code size a bit though as I’d need to pass an additional
argument on hashtable function calls… or, forgo the benefit of not
having to pointer-align the key in the structure, which can be as
much as 3/7 octets per item, heap storage… OTOH the saved space is
4/8 octets per not-allocated item, possibly some code (use of an
multiply-add opcode), but the function call overhead/cost would
possibly be quite a bit… I guess I’ll have to measure…
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.549 2012/04/14 16:07:48 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/04/22"
@


1.549
log
@rewrite maketemp() obsoleting tempnam(3) and mkstemp(3) external deps
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.548 2012/04/14 14:35:12 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/04/14"
d1494 1
a1494 1
/* NZAT/NZAAT hashes based on Bob Jenkins' one-at-a-time hash */
a1526 9
/* not zero after termination */
#define NZATFinish(h) do {					\
	if ((h) == 0)						\
		++(h);						\
	else							\
		NZAATFinish(h);					\
} while (/* CONSTCOND */ 0)

/* NULs zählen an allen Teilen */
@


1.548
log
@factor out rndget() code, for adding users

XXX in the future, the entire scheme must be rethinked when we need more
XXX entropy for the hash tables; possibly a cheap add using NZAT and re-
XXX initialise the LCG only on access and when added (so keep NZAT state
XXX separate from LCG state); also, then we will need a more elaborate
XXX scheme, such as adding from environment, editor keypresses and timing
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.547 2012/04/14 14:07:47 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/04/07"
a537 5
#if !HAVE_MKSTEMP
/* tempnam(3) -> free(3) */
#define free_ostempnam(p)	free(p)
#endif

d702 6
a707 5
enum temp_type {
	TT_HEREDOC_EXP,	/* expanded heredoc */
	TT_HIST_EDIT	/* temp file used for history editing (fc -e) */
};
typedef enum temp_type Temp_type;
d712 2
a713 2
	char *name;
	int pid;	/* pid of process parsed here-doc */
d715 2
@


1.547
log
@genericise MKSH_NO_SIGSETJMP
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.546 2012/04/14 14:02:40 tg Exp $");
d1891 1
@


1.546
log
@if the OS does not provide sig_atomic_t and/or ssize_t, you can now define
MKSH_TYPEDEF_SIG_ATOMIC_T and MKSH_TYPEDEF_SSIZE_T via CPPFLAGS to the
*correct* definitions (it’s absolutely critical they be correct!)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.545 2012/04/07 11:19:51 tg Exp $");
d581 1
a581 1
#if defined(NeXT) && !defined(__GLIBC__)
@


1.545
log
@drop all deprecated code, you have been warned
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.544 2012/04/06 15:23:11 tg Exp $");
d215 8
@


1.544
log
@more speling
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.542 2012/04/06 13:29:01 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/29"
@


1.543
log
@if LDSTATIC is not empty (i.e. "-static" or " "), always add “our” sources:
• strlcpy
• utf_wcwidth
note strchr/strstr from misc.c are still #ifdef DEBUG only, as they are
not eligible: they’re for const-cleanliness debugging purposes

XXX get rid of multiple occurrences of binary search code, too…
@
text
@d344 1
a344 1
/* remove redundances */
@


1.542
log
@drop str{,n}casecmp, too
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.541 2012/04/06 12:59:28 tg Exp $");
d346 1
a346 1
#if defined(MirBSD) && (MirBSD >= 0x08A8)
@


1.541
log
@drop the need for strcasestr: just uppercase a copy and compare with uppercased
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.540 2012/04/06 11:51:43 tg Exp $");
a328 5
#ifdef __ultrix
/* XXX imake style */
int strcasecmp(const char *, const char *);
#endif

d1660 1
a1660 1
Trap *gettrap(const char *, int);
@


1.540
log
@LynxOS defines PRINT somewhere, undef it
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.539 2012/03/31 17:30:00 tg Exp $");
a333 4
#if !HAVE_STRCASESTR
const char *stristr(const char *, const char *);
#endif

a492 4
#if HAVE_STRCASESTR
#define stristr(b,l)		((const char *)strcasestr((b), (l)))
#endif

@


1.539
log
@use _setjmp/_longjmp on NeXTstep: its Intel port always restores the signal mask on siglongjmp, which we never have
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.538 2012/03/29 19:23:01 tg Exp $");
d218 1
@


1.538
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.537 2012/03/28 23:09:24 tg Exp $");
d585 10
d602 1
a602 1
	sigjmp_buf jbuf;	/* long jump back to env creator */
d628 1
a628 1
/* values for siglongjmp(e->jbuf, 0) */
d911 1
a911 1
#define KSH_UNWIND_ERROR	0	/* unwind the stack (longjmp) */
@


1.537
log
@fail in a clean way even on b0rken compilers
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.536 2012/03/28 11:05:16 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/27"
d593 2
a594 2
	short type;		/* environment type - see below */
	short flags;		/* EF_* */
d613 2
a614 2
#define STOP_BRKCONT(t)	((t) == E_NONE || (t) == E_PARSE \
			 || (t) == E_FUNC || (t) == E_INCL)
@


1.536
log
@I don’t know what those compiler authors were smoking…
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.535 2012/03/27 23:13:42 tg Exp $");
d447 6
a452 1
I’m sorry, Dave. I’m afraid I can’t do that.
@


1.535
log
@pass the version to avoid stale Makefile.inc files
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.534 2012/03/27 22:58:39 tg Exp $");
d447 1
a447 1
I'm sorry, Dave. I'm afraid I can't do that.
@


1.534
log
@g/c magic definitions for simple chars (as opposed to e.g. tokens/lexems)

some (such as NOT) were already gone; this should unconfuse; most were
unused anyway…
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.533 2012/03/27 22:49:47 tg Exp $");
d445 2
a446 1
#if !defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)
a447 1
#error Must run Build.sh to compile this.
@


1.533
log
@add a note that mksh_{,u}ari_t are, sadly, not currently configurable
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.532 2012/03/27 22:41:17 tg Exp $");
d386 1
a386 1
 * portability problems (calling strchr(x, 0x80|'x') is error prone).
a880 8
/* These to avoid bracket matching problems */
#define OPAREN	'('
#define CPAREN	')'
#define OBRACK	'['
#define CBRACK	']'
#define OBRACE	'{'
#define CBRACE	'}'

@


1.532
log
@#undef flock (LP: #912691)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.531 2012/03/27 22:36:53 tg Exp $");
d170 8
@


1.531
log
@• implement fcntl(2)-based advisory locking as an alternative iff flock(2)
  is not found, from a suggestion by RT (LP: #912691)
• try harder (in a loop) to acquire a file lock if the locking mechanism
  documents EINTR is a possibility (fcntl always, flock on Linux not .Ox)
• use -std=c99 not -std=gnu99 if it must be at all
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.530 2012/03/27 21:23:52 tg Exp $");
d207 6
a304 1
#undef BAD		/* AIX defines that somewhere */
@


1.530
log
@You have this ↓ guy a lot to thank for.
00:45 -!- variable [root@@freebsd/developer/variable] has joined #!/bin/mksh

• +b *!*root@@*, +b $a:root, +b $r:root on one more channel
• certain checks to prevent:
00:47 < variable> wjcw: sh.h:308: error: conflicting types for 'getrusage'
01:19 < variable> oh
01:19 < variable> I needed to run Build.sh
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.529 2012/03/26 21:10:44 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/26"
d1666 4
@


1.529
log
@Susv3mon says: rlim_t are unsigned
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.528 2012/03/25 14:28:14 tg Exp $");
d432 5
@


1.528
log
@fix regression w.r.t. TTY and external programmes:
• release the TTY after the initial change_winsz()
• since we release it, we can skip initialising tty_state, too
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.527 2012/03/24 21:22:25 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/25"
d199 1
a199 1
typedef long rlim_t;
@


1.527
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.526 2012/03/23 23:25:29 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/24"
@


1.526
log
@huh, I thought I had extended ${parameter@@#hash} already; make it so now,
but not yet things like ${parameter@@Fi} (1 if integer, 0 otherwise), etc.
also bump patchlevel and © years in recently changed files
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.525 2012/03/23 21:58:22 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/23"
@


1.525
log
@always keep x_cols and x_lins valid; check once at start including tty init
if we find any, but not later; do not check on every read

⇒ allows changing COLUMNS and LINES (independent of each other, or both)
  for script shells by passing them in an environment setting, even if
  we get a tty; interactive shells still check before each line is read…

reported by the PLD guys, thanks
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.524 2012/03/23 20:07:11 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/03"
@


1.524
log
@drop use of the NOT macro, [^foo] ≠ [!foo] anyway, and we’re not gonna change that
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.523 2012/03/23 19:38:12 tg Exp $");
d861 1
a861 1
EXTERN mksh_ari_t x_lins E_INIT(-1);	/* tty lines */
@


1.523
log
@efficient debug-to-file output (/tmp racy, but hey)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.522 2012/03/03 21:30:57 tg Exp $");
a376 1
#define NOT		'!'	/* might use ^ (ie, [!...] vs [^..]) */
@


1.522
log
@RCSID sync from oksh; reduce hash table #elements if !MKSH_SMALL to speed up
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.521 2012/02/06 17:42:23 tg Exp $");
d700 3
d1750 4
@


1.521
log
@make jobs reporting deal with UTF-8 (in utf8-mode)
reported by Andrew Kudryashov, 10x
@
text
@d3 1
a3 1
/*	$OpenBSD: table.h,v 1.7 2005/12/11 20:31:21 otto Exp $	*/
d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.520 2012/01/29 01:41:15 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/02/06"
d1733 6
a1738 1
void ktinit(Area *, struct table *, uint8_t);
@


1.520
log
@reduce stack usage a bit (several candidates for more, including $CC itself…)
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.519 2012/01/04 19:09:36 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/01/28"
@


1.519
log
@fix regression escaping single-char strings
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.518 2012/01/03 01:01:44 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/01/04"
@


1.518
log
@oeps…
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.517 2012/01/03 00:58:09 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/01/03"
@


1.517
log
@move linkage check (which uses sh.h INCLUDES_ONLY) to when all of its
prerequisites are actually fulfilled, i.e. evrn further down than with
the last commit doing this, and move some prerequisites of stuff that
has wandered outside the !INCLUDES_ONLY block with the compile-time
assert changes to the outside, too

fixes FTBFS on MSYS which has neither <stdint.h> nor uint32_t
reported by RT
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.516 2011/12/31 00:27:25 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2011/12/30"
@


1.516
log
@gc-sections found size optimisation chances
@
text
@d12 2
a13 1
 * Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.514 2011/12/29 23:36:23 tg Exp $");
d159 11
a169 1
/* arithmetics types */
d187 20
a224 26
#if !HAVE_RLIM_T
typedef long rlim_t;
#endif

#if !HAVE_SIG_T
#undef sig_t
typedef void (*sig_t)(int);
#endif

#if !HAVE_CAN_INTTYPES
#if !HAVE_CAN_UCBINTS
typedef signed int int32_t;
typedef unsigned int uint32_t;
#else
typedef u_int32_t uint32_t;
#endif
#endif

#if !HAVE_CAN_INT8TYPE
#if !HAVE_CAN_UCBINT8
typedef unsigned char uint8_t;
#else
typedef u_int8_t uint8_t;
#endif
#endif

@


1.515
log
@put a bit of type safety into the history code
@
text
@d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/29"
d165 1
a165 1
/* false MUST equal 0 */
a1450 2
#define HISTORYSIZE	500	/* size of saved history */

d1632 1
d1635 1
@


1.514
log
@don’t clobber the tree used for printing IOACTs in process_TIF (LP: #907224)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.513 2011/12/29 22:54:21 tg Exp $");
d1453 3
a1455 3
EXTERN char **history;	/* saved commands */
EXTERN char **histptr;	/* last history item */
EXTERN int histsize;	/* history size */
d1630 1
a1630 1
void sethistsize(int);
@


1.513
log
@give dumptree an dumpioact helper
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.512 2011/12/16 20:03:27 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/16"
@


1.512
log
@use sane spelling of read-only consistently
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.511 2011/12/10 14:12:17 tg Exp $");
d1751 1
a1751 1
void print_value_quoted(const char *);
d1821 1
@


1.511
log
@shuffle caddr_t to its only user, and use (void *) on Linux instead,
to appease Fefe’s dietlibc [-Wdeprecated-declarations]
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.510 2011/12/10 13:34:18 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/10"
@


1.510
log
@• finally, the code and manual page text to deprecate, and code to not
  handle any more, octal 010 style constants, as promised
• overhaul the manpage re. arithmetic expressions, make the guarantees
  mksh code has explicitly, precisely, clear
• to reduce burden of the compiler, getint() now operates on mksh_uari_t
  internally; it already applied the sign after operation, anyway (C99
  guarantees wraparound on unsigned types, but for signed types we need
  specific compiler support; apparently, this comes from hardware limits)
• use const and shuffle order of locals around while here
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.509 2011/12/09 20:40:26 tg Exp $");
a285 9
#if !defined(MAP_FAILED)
/* XXX imake style */
#  if defined(__linux)
#define MAP_FAILED	((void *)-1)
#  elif defined(__bsdi__) || defined(__osf__) || defined(__ultrix)
#define MAP_FAILED	((caddr_t)-1)
#  endif
#endif

@


1.509
log
@actually catch out of [1;36] bounds integer bases
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.508 2011/12/03 00:01:28 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/09"
@


1.508
log
@move compile-time assertions out of misc.c(#ifdef DEBUG) into Build.sh
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.507 2011/12/02 22:55:49 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/02"
@


1.507
log
@• improve comments
• do shave off 20 bytes from c_test() and get rid of the ugly stack
  variable and double “using” despite not parsing
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.506 2011/11/30 21:34:15 tg Exp $");
d158 18
a364 18
/* arithmetics types */
typedef int32_t mksh_ari_t;
typedef uint32_t mksh_uari_t;

/* boolean type (no <stdbool.h> deliberately) */
typedef unsigned char mksh_bool;
#undef bool
/* false MUST equal 0 */
#undef false
#undef true
/* access macros for boolean type */
#define bool		mksh_bool
/* values must have identity mapping between mksh_bool and short */
#define false		0
#define true		1
/* make any-type into bool or short */
#define tobool(cond)	((cond) ? true : false)

@


1.506
log
@rewrite funcs.c:c_test(), i.e. test(1) and [(1), to follow POSIX and XSI
in the cases where they are defined unambiguously; bug reported by
Jilles Tjoelker in <20111129232526.GC14357@@stack.nl> due to a report
by Stefano Lattarini on bug-autoconf

in the ambiguous case, I stick to traditional pdksh behaviour, which means
	test ! a = b	vs.	test a = b
and
	test ! a -o b	vs.	test a -o b
behave different from each other (in the second case, the NOT operator
binds strong; POSIX demands a reduction to 3 arguments and negating
that result in the first case), so we're at two known not-ok in the
FreeBSD® testsuite. (81 and 82 in regress.sh,v 1.3)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.505 2011/11/26 00:45:21 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/30"
@


1.505
log
@fix stateptr-underflow; really do call fastbox regression checks; bump vsn
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.504 2011/11/22 18:01:40 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/25"
@


1.504
log
@Fix regression introduced by mixing the recursive parser and support
for ;| and ;& in TCASE: ;;-less last casepart produced ";\0" in the
SREREAD string which obviously cased reparsing to fail

test from http://www.in-ulm.de/~mascheck/various/cmd-subst/
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.503 2011/11/19 21:22:02 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/21"
@


1.503
log
@bump
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.502 2011/11/11 22:14:17 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/19"
@


1.502
log
@promote x=(a b); x+=(c) to standard mksh functionality at cost of 932 MKSH_SMALL .text bytes on MirBSD/i386
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.501 2011/11/09 22:17:26 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/11"
@


1.501
log
@• select(0, …) misbehaves on Interix (by Markus Duft <mduft@@gentoo.org>)
• select(n, NULL, NULL, NULL, …) behaves the same (by Bruno Haible)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.500 2011/11/08 22:07:14 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/09"
@


1.500
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.499 2011/10/26 20:46:16 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/07"
@


1.499
log
@forgotten in cid 1004EA5BF612F516747 to take '\n' presence as $'…' quoting reason
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.498 2011/10/25 22:36:37 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/10/26"
d1843 1
a1843 1
void setint_n(struct tbl *, mksh_ari_t);
@


1.498
log
@rename more identifiers with trailing underscores
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.497 2011/10/25 22:25:07 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/10/24"
@


1.497
log
@also Xcheck_grow_ may not end with an underscore
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.496 2011/10/24 19:41:13 tg Exp $");
d445 2
a446 2
#define strdupx(d, s, ap) do { \
	(d) = strdup_((s), (ap)); \
d448 2
a449 2
#define strndupx(d, s, n, ap) do { \
	(d) = strndup_((s), (n), (ap)); \
d899 1
a899 1
#define shf_getc_(shf)		((shf)->rnleft > 0 ? \
d902 1
a902 1
#define shf_putc_(c, shf)	((shf)->wnleft == 0 ? \
d1775 2
a1776 2
char *strdup_(const char *, Area *);
char *strndup_(const char *, size_t, Area *);
d1796 2
a1797 2
#define shf_getc shf_getc_
#define shf_putc shf_putc_
@


1.496
log
@document “export -” accident found by Snader_LB
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.495 2011/10/07 19:51:44 tg Exp $");
d1300 1
a1300 1
		(xp) = Xcheck_grow_(&(xs), (xp), more);		\
d1321 1
a1321 1
char *Xcheck_grow_(XString *, const char *, size_t);
@


1.495
log
@better handling of eval and CPPFLAGS in build system
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.494 2011/09/07 15:24:19 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/10/07"
@


1.494
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.493 2011/08/27 18:06:50 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/09/07"
@


1.493
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.492 2011/08/27 17:30:07 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/08/27"
d336 1
a336 1
# define I__(i) = i
d338 1
a338 1
# define I__(i)
d386 1
a386 1
EXTERN const char initvsn[] I__("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
d389 2
a390 2
EXTERN const char digits_uc[] I__("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
EXTERN const char digits_lc[] I__("0123456789abcdefghijklmnopqrstuvwxyz");
d568 1
a568 1
	ALLOC_ITEM __alloc_i;	/* internal, do not touch */
d621 7
a627 7
	uid_t kshuid_;		/* real UID of shell */
	uid_t ksheuid_;		/* effective UID of shell */
	gid_t kshgid_;		/* real GID of shell */
	gid_t kshegid_;		/* effective GID of shell */
	pid_t kshpgrp_;		/* process group of shell */
	pid_t kshppid_;		/* PID of parent of shell */
	pid_t kshpid_;		/* $$, shell PID */
d630 7
a636 7
#define kshpid		rndsetupstate.kshpid_
#define kshpgrp		rndsetupstate.kshpgrp_
#define kshuid		rndsetupstate.kshuid_
#define ksheuid		rndsetupstate.ksheuid_
#define kshgid		rndsetupstate.kshgid_
#define kshegid		rndsetupstate.kshegid_
#define kshppid		rndsetupstate.kshppid_
d655 1
a655 1
EXTERN char null[] I__("");
d657 2
a658 2
EXTERN const char T_intovfl[] I__("integer overflow %zu %c %zu prevented");
EXTERN const char T_oomem[] I__("can't allocate %lu data bytes");
d661 1
a661 1
#define T_synerr	"syntax error"
d663 1
a663 1
EXTERN const char T_synerr[] I__("syntax error");
d665 17
a681 17
EXTERN const char T_select[] I__("select");
EXTERN const char T_r_fc_e_[] I__("r=fc -e -");
#define T_fc_e_		(T_r_fc_e_ + 2)		/* "fc -e -" */
#define Tn_fc_e_	7			/* strlen(T_fc_e_) */
EXTERN const char T_local_typeset[] I__("local=typeset");
#define T__typeset	(T_local_typeset + 5)	/* "=typeset" */
#define T_typeset	(T_local_typeset + 6)	/* "typeset" */
EXTERN const char T_palias[] I__("+alias");
#define T_alias		(T_palias + 1)		/* "alias" */
EXTERN const char T_punalias[] I__("+unalias");
#define T_unalias	(T_punalias + 1)	/* "unalias" */
EXTERN const char T_sgset[] I__("*=set");
#define T_set		(T_sgset + 2)		/* "set" */
EXTERN const char T_gbuiltin[] I__("=builtin");
#define T_builtin	(T_gbuiltin + 1)	/* "builtin" */
EXTERN const char T__function[] I__(" function");
#define T_function	(T__function + 1)	/* "function" */
d742 2
a743 2
#define SIGEXIT_	0	/* for trap EXIT */
#define SIGERR_		NSIG	/* for trap ERR */
d752 1
a752 1
EXTERN volatile sig_atomic_t got_winch I__(1);
d767 1
a767 1
EXTERN enum tmout_enum ksh_tmout_state I__(TMOUT_EXECUTING);
d793 1
a793 1
EXTERN int ifs0 I__(' ');	/* for "$*" */
d862 2
a863 2
EXTERN mksh_ari_t x_cols I__(80);	/* tty columns */
EXTERN mksh_ari_t x_lins I__(-1);	/* tty lines */
d907 1
a907 1
#define shf_errno(shf)		((shf)->errno_)
d944 1
a944 1
	int errno_;		/* saved value of errno after error */
d974 1
a974 1
		int errno_;		/* CEXEC/CTALIAS */
d1040 1
a1040 1
} set_refflag I__(SRF_NOP);
d1064 1
a1064 1
#define AI_ARGC(a)	((a).argc_ - (a).skip)
d1070 1
a1070 1
	int argc_;
d1252 3
a1254 3
#define DOBRACE_ BIT(6)		/* used by expand(): do brace expansion */
#define DOMAGIC_ BIT(7)		/* used by expand(): string contains MAGIC */
#define DOTEMP_	BIT(8)		/* ditto : in word part of ${..[%#=?]..} */
d1333 4
a1336 4
	void **vp__;						\
	vp__ = alloc2((n), sizeof(void *), ATEMP);		\
	(x).cur = (x).beg = vp__;				\
	(x).end = vp__ + (n);					\
d1474 1
a1474 1
		internal_errorf(T_intovfl, (size_t)(val),		\
d1564 1
a1564 2
const char *search(const char *, const char *, int, int *);
int search_access(const char *, int, int *);
d1580 1
d1913 1
a1913 1
EXTERN int tty_fd I__(-1);	/* dup'd tty file descriptor */
d1925 1
a1925 1
#undef I__
@


1.492
log
@jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.491 2011/08/13 22:19:41 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/26"
d657 1
a657 1
EXTERN const char T_intovfl[] I__("integer overflow %lu %c %lu prevented");
d807 4
d937 5
a942 4
	int rbsize;		/* size of buffer (1 if SHF_UNBUF) */
	int rnleft;		/* read: how much data left in buffer */
	int wbsize;		/* size of buffer (0 if SHF_UNBUF) */
	int wnleft;		/* write: how much space left in buffer */
a944 1
	int bsize;		/* actual size of buf */
d952 1
a952 1
	uint32_t nfree;		/* free table entries */
d1298 1
a1298 1
	int more = ((xp) + (n)) - (xs).end;			\
d1300 1
a1300 1
		(xp) = Xcheck_grow_(&(xs), (xp), (size_t)more);	\
d1456 3
a1458 3
EXTERN YYSTYPE	yylval;		/* result from yylex */
EXTERN struct ioword *heres [HERES], **herep;
EXTERN char	ident [IDENT+1];
d1474 2
a1475 2
		internal_errorf(T_intovfl, (unsigned long)(val),	\
		    '+', (unsigned long)(cnst));			\
d1575 1
a1575 1
int utf_mbswidth(const char *);
d1763 2
a1764 2
    char *(*)(char *, int, int, const void *),
    const void *, int, int, bool);
d1783 1
a1783 1
struct shf *shf_sopen(char *, int, int, struct shf *);
d1788 2
a1789 2
int shf_read(char *, int, struct shf *);
char *shf_getse(char *, int, struct shf *);
d1800 3
a1802 3
int shf_puts(const char *, struct shf *);
int shf_write(const char *, int, struct shf *);
int shf_fprintf(struct shf *, const char *, ...)
d1804 1
a1804 1
int shf_snprintf(char *, int, const char *, ...)
d1809 1
a1809 1
int shf_vfprintf(struct shf *, const char *, va_list)
d1818 1
a1818 1
char *snptreef(char *, int, const char *, ...);
d1854 1
a1854 1
int array_ref_len(const char *);
@


1.491
log
@dict.leo.org says this is correct
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.490 2011/07/26 16:57:28 tg Exp $");
d167 2
a168 2
#define RUSAGE_SELF	0
#define RUSAGE_CHILDREN	-1
d479 1
a479 1
#define stristr(b,l)	((const char *)strcasestr((b), (l)))
d499 1
a499 1
#define MKSH_UNEMPLOYED
@


1.490
log
@followup fix for 1004D90467358D6B13C regarding escaped substitutions
found in, out of all things, Debian/m68k, by Wouter Verhelst (Yoe)
fix hacked at DebConf 11, Бања Лука, Република Српска, Босна и Херцеговина
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.489 2011/07/20 23:47:29 tg Exp $");
d654 1
a654 1
/* null value for variable; comparision pointer for unset */
@


1.489
log
@optimise an if away, and possibly even the function bodies…
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.488 2011/07/18 00:35:46 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/20"
@


1.488
log
@now that I got Hash.cs compiled and run, I’m amazed; make NZAAT (and NZAT!) all green with a small tweak; bit distribution and χ2 look OK as well
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.487 2011/07/16 17:08:52 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/17"
a1597 1
int c_label(const char **);
@


1.487
log
@finish merging from R40-stable; set version number to yesterday though
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.486 2011/07/16 17:08:21 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/15"
d1477 1
a1477 1
/* From: src/kern/include/nzat.h,v 1.1 2011/07/06 22:18:52 tg Exp $ */
d1518 2
@


1.486
log
@‣ merge from mksh R40-stable
move /etc/{,suid_}profile to /system/etc/ for Android (but do not make
the location of /etc configurable); rewrite manpage section about
/etc/{,suid_}profile, .profile, .mkshrc
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.485 2011/07/16 17:07:34 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/07"
@


1.485
log
@‣ merge from mksh R40-stable
use common macro bodies shf_{get,put}c_ for definition
of shf_{put,get}c as functions (MKSH_SMALL) or macros, respectively
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484 2011/07/07 20:24:52 tg Exp $");
d869 1
d871 11
a881 1
#define KSH_SYSTEM_PROFILE "/etc/profile"
@


1.484
log
@take down the entire xterm (or GNU screen tab), hard, with:
mksh-R40 -c 'x=$COLUMNS; awk "BEGIN{exit(1)}"'
10x to the PLD Linux guys for spotting _and_ bisecting this!
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.483 2011/07/06 22:22:00 tg Exp $");
d880 1
a880 1
#define SHF_BSIZE	512
d882 1
a882 1
#define shf_fileno(shf)	((shf)->fd)
d884 1
a884 5
#ifdef MKSH_SMALL
int shf_getc(struct shf *);
int shf_putc(int, struct shf *);
#else
#define shf_getc(shf)		((shf)->rnleft > 0 ? \
d887 1
a887 1
#define shf_putc(c, shf)	((shf)->wnleft == 0 ? \
a889 1
#endif
d1776 7
@


1.484.2.1
log
@time to open the mksh R40-stable branch:
• bring back deprecated {build options,set ±o arc4random,OAAT1 internal hash}
• change version number in TFM
@
text
@d12 1
a12 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d17 1
a17 1
 * is granted to deal in this work without restriction, including un-
d21 1
a21 1
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
d28 1
a28 1
 * of said person's immediate fault when using the work as intended.
d33 1
a33 1
#define _BSD_SOURCE	/* live, BSD, live! */
d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484 2011/07/07 20:24:52 tg Exp $");
d1468 23
a1490 3
/* Bob Jenkins' one-at-a-time hash, with better start value */
#define oaat1_init_impl(h) do {						\
	(h) = 0x100;							\
d1492 8
a1499 9
#define oaat1_addmem_impl(h, buf, len) do {				\
	register const uint8_t *oaat1_addmem_p = (const void *)(buf);	\
	register size_t oaat1_addmem_n = (len);				\
									\
	while (oaat1_addmem_n--) {					\
		(h) += *oaat1_addmem_p++;				\
		(h) += (h) << 10;					\
		(h) ^= (h) >> 6;					\
	}								\
d1501 7
a1507 9
#define oaat1_addstr_impl(h, s) do {					\
	register const uint8_t *oaat1_addstr_p = (const void *)(s);	\
	register uint8_t oaat1_addstr_c;				\
									\
	while ((oaat1_addstr_c = *oaat1_addstr_p++)) {			\
		h += oaat1_addstr_c;					\
		(h) += (h) << 10;					\
		(h) ^= (h) >> 6;					\
	}								\
d1509 6
a1514 4
#define oaat1_fini_impl(h) do {						\
	(h) += (h) << 3;						\
	(h) ^= (h) >> 11;						\
	(h) += (h) << 15;						\
d1517 1
@


1.484.2.2
log
@use common macro bodies shf_{get,put}c_ for definition
of shf_{put,get}c as functions (MKSH_SMALL) or macros, respectively
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.1 2011/07/07 21:42:18 tg Exp $");
d870 1
a870 1
#define KSH_SYSTEM_PROFILE	"/etc/profile"
d880 1
a880 1
#define SHF_BSIZE		512
d882 1
a882 1
#define shf_fileno(shf)		((shf)->fd)
d884 5
a888 1
#define shf_getc_(shf)		((shf)->rnleft > 0 ? \
d891 1
a891 1
#define shf_putc_(c, shf)	((shf)->wnleft == 0 ? \
d894 1
a1760 7
#ifdef MKSH_SMALL
int shf_getc(struct shf *);
int shf_putc(int, struct shf *);
#else
#define shf_getc shf_getc_
#define shf_putc shf_putc_
#endif
@


1.484.2.3
log
@• move /etc/{,suid_}profile to /system/etc/ for Android (but do not make
  the location of /etc configurable)
• rewrite manpage section about /etc/{,suid_}profile, .profile, .mkshrc
• drop heredoc-weird-3 while here, it’s not deterministic by design(?)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.2 2011/07/16 13:16:44 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/16"
a868 1

d870 1
a870 11

/* This is deliberately not configurable via CPPFLAGS */
#if defined(ANDROID)
#define MKSH_ETC_LOCATION	"/system/etc"
#else
#define MKSH_ETC_LOCATION	"/etc"
#endif

#define MKSH_SYSTEM_PROFILE	MKSH_ETC_LOCATION "/profile"
#define MKSH_SUID_PROFILE	MKSH_ETC_LOCATION "/suid_profile"

@


1.484.2.4
log
@MFC cid 1004E2EF1DA23EC569A
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.3 2011/07/16 16:04:16 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/25"
@


1.484.2.5
log
@MFC from HEAD and adjust version

Build.sh:
- better handling of eval and CPPFLAGS in build system
- partial OPENSTEP support
- fix typo

check.t:
- mark utf8opt-2a as need-pass: no (1.481)

dot.mkshrc:
- do not close stderr (1.65)
- use only printable characters (1.65)

edit.c:
- upper bound Emacs mode command repeat by input line length

funcs.c, sh.h:
- optimise an if away, and possibly even the function bodies…

misc.c:
- jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr

mksh.1, sh.h. var.c:
- fix spelling

mksh.1:
- document "export -"

sh.h:
- undef optarg, optind in case the OE predefines them (1.493)

shf.c:
- handle %zu (size_t), %zd (ssize_t), etc. (1.43)

syn.c:
- avoid (not-)function-local externs (1.68)

multiple:
- do not use macros or identifiers ending with an underscore
- more {,s}size_t, type, lint, other cleanups (edit.c 1.220; eval.c 1.107;
  exec.c 1.95; expr.c 1.48; funcs.c 1.196; histrap.c 1.110; jobs.c 1.81;
  lalloc.c 1.18; lex.c 1.155; main.c 1.198; misc.c 1.171; sh.h 1.493;
  shf.c 1.43; tree.c 1.50; var.c 1.131)
- wrap access(2) (edit.c 1.221; exec.c 1.96; expr.c 1.49; funcs.c 1.197;
  histrap.c 1.111; sh.h 1.494)
@
text
@d12 1
a12 1
 * Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d17 1
a17 1
 * is granted to deal in this work without restriction, including un‐
d21 1
a21 1
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
d28 1
a28 1
 * of said person’s immediate fault when using the work as intended.
d33 1
a33 1
#define _BSD_SOURCE	/* live, BSD, live❣ */
d156 1
a156 1
#define MKSH_VERSION "R40 2011/10/25"
d167 2
a168 2
#define RUSAGE_SELF		0
#define RUSAGE_CHILDREN		-1
d336 1
a336 1
# define E_INIT(i) = i
d338 1
a338 1
# define E_INIT(i)
d386 1
a386 1
EXTERN const char initvsn[] E_INIT("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
d389 2
a390 2
EXTERN const char digits_uc[] E_INIT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
EXTERN const char digits_lc[] E_INIT("0123456789abcdefghijklmnopqrstuvwxyz");
d445 2
a446 2
#define strdupx(d, s, ap) do {						\
	(d) = strdup_i((s), (ap));					\
d448 2
a449 2
#define strndupx(d, s, n, ap) do {					\
	(d) = strndup_i((s), (n), (ap));				\
d479 1
a479 1
#define stristr(b,l)		((const char *)strcasestr((b), (l)))
d499 1
a499 1
#define MKSH_UNEMPLOYED		1
d568 1
a568 1
	ALLOC_ITEM alloc_INT;	/* internal, do not touch */
d621 7
a627 7
	uid_t kshuid_v;		/* real UID of shell */
	uid_t ksheuid_v;	/* effective UID of shell */
	gid_t kshgid_v;		/* real GID of shell */
	gid_t kshegid_v;	/* effective GID of shell */
	pid_t kshpgrp_v;	/* process group of shell */
	pid_t kshppid_v;	/* PID of parent of shell */
	pid_t kshpid_v;		/* $$, shell PID */
d630 7
a636 7
#define kshpid		rndsetupstate.kshpid_v
#define kshpgrp		rndsetupstate.kshpgrp_v
#define kshuid		rndsetupstate.kshuid_v
#define ksheuid		rndsetupstate.ksheuid_v
#define kshgid		rndsetupstate.kshgid_v
#define kshegid		rndsetupstate.kshegid_v
#define kshppid		rndsetupstate.kshppid_v
d654 2
a655 2
/* null value for variable; comparison pointer for unset */
EXTERN char null[] E_INIT("");
d657 2
a658 2
EXTERN const char Tintovfl[] E_INIT("integer overflow %zu %c %zu prevented");
EXTERN const char Toomem[] E_INIT("can't allocate %lu data bytes");
d661 1
a661 1
#define Tsynerr		"syntax error"
d663 1
a663 1
EXTERN const char Tsynerr[] E_INIT("syntax error");
d665 17
a681 17
EXTERN const char Tselect[] E_INIT("select");
EXTERN const char Tr_fc_e_dash[] E_INIT("r=fc -e -");
#define Tfc_e_dash	(Tr_fc_e_dash + 2)	/* "fc -e -" */
#define Zfc_e_dash	7			/* strlen(Tfc_e_dash) */
EXTERN const char Tlocal_typeset[] E_INIT("local=typeset");
#define T_typeset	(Tlocal_typeset + 5)	/* "=typeset" */
#define Ttypeset	(Tlocal_typeset + 6)	/* "typeset" */
EXTERN const char Tpalias[] E_INIT("+alias");
#define Talias		(Tpalias + 1)		/* "alias" */
EXTERN const char Tpunalias[] E_INIT("+unalias");
#define Tunalias	(Tpunalias + 1)		/* "unalias" */
EXTERN const char Tsgset[] E_INIT("*=set");
#define Tset		(Tsgset + 2)		/* "set" */
EXTERN const char Tgbuiltin[] E_INIT("=builtin");
#define Tbuiltin	(Tgbuiltin + 1)		/* "builtin" */
EXTERN const char T_function[] E_INIT(" function");
#define Tfunction	(T_function + 1)	/* "function" */
d742 2
a743 2
#define ksh_SIGEXIT	0	/* for trap EXIT */
#define ksh_SIGERR	NSIG	/* for trap ERR */
d752 1
a752 1
EXTERN volatile sig_atomic_t got_winch E_INIT(1);
d767 1
a767 1
EXTERN enum tmout_enum ksh_tmout_state E_INIT(TMOUT_EXECUTING);
d793 1
a793 1
EXTERN int ifs0 E_INIT(' ');	/* for "$*" */
a806 4
/* in case some OS defines these */
#undef optarg
#undef optind

d858 2
a859 2
EXTERN mksh_ari_t x_cols E_INIT(80);	/* tty columns */
EXTERN mksh_ari_t x_lins E_INIT(-1);	/* tty lines */
d895 1
a895 1
#define shf_getc_i(shf)		((shf)->rnleft > 0 ? \
d898 1
a898 1
#define shf_putc_i(c, shf)	((shf)->wnleft == 0 ? \
d903 1
a903 1
#define shf_errno(shf)		((shf)->errnosv)
a932 5
	ssize_t bsize;		/* actual size of buf */
	ssize_t rbsize;		/* size of buffer (1 if SHF_UNBUF) */
	ssize_t rnleft;		/* read: how much data left in buffer */
	ssize_t wbsize;		/* size of buffer (0 if SHF_UNBUF) */
	ssize_t wnleft;		/* write: how much space left in buffer */
d934 4
d939 2
a940 1
	int errnosv;		/* saved value of errno after error */
d948 1
a948 1
	size_t nfree;		/* free table entries */
d970 1
a970 1
		int errnov;		/* CEXEC/CTALIAS */
d1036 1
a1036 1
} set_refflag E_INIT(SRF_NOP);
d1060 1
a1060 1
#define AI_ARGC(a)	((a).ai_argc - (a).skip)
d1066 1
a1066 1
	int ai_argc;
d1248 3
a1250 3
#define DOBRACE BIT(6)		/* used by expand(): do brace expansion */
#define DOMAGIC BIT(7)		/* used by expand(): string contains MAGIC */
#define DOTEMP	BIT(8)		/* dito: in word part of ${..[%#=?]..} */
d1294 1
a1294 1
	ssize_t more = ((xp) + (n)) - (xs).end;			\
d1296 1
a1296 1
		(xp) = Xcheck_grow(&(xs), (xp), more);		\
d1317 1
a1317 1
char *Xcheck_grow(XString *, const char *, size_t);
d1329 4
a1332 4
	void **XPinit_vp;					\
	XPinit_vp = alloc2((n), sizeof(void *), ATEMP);		\
	(x).cur = (x).beg = XPinit_vp;				\
	(x).end = XPinit_vp + (n);				\
d1452 3
a1454 3
EXTERN YYSTYPE yylval;		/* result from yylex */
EXTERN struct ioword *heres[HERES], **herep;
EXTERN char ident[IDENT+1];
d1470 2
a1471 2
		internal_errorf(Tintovfl, (size_t)(val),		\
		    '+', (size_t)(cnst));				\
d1538 2
a1539 1
const char *search_path(const char *, const char *, int, int *);
d1549 1
a1549 1
size_t utf_mbswidth(const char *);
a1554 1
int ksh_access(const char *, int);
d1576 1
d1738 2
a1739 2
    char *(*)(char *, size_t, int, const void *),
    const void *, size_t, size_t, bool);
d1750 2
a1751 2
char *strdup_i(const char *, Area *);
char *strndup_i(const char *, size_t, Area *);
d1758 1
a1758 1
struct shf *shf_sopen(char *, ssize_t, int, struct shf *);
d1763 2
a1764 2
ssize_t shf_read(char *, ssize_t, struct shf *);
char *shf_getse(char *, ssize_t, struct shf *);
d1771 2
a1772 2
#define shf_getc shf_getc_i
#define shf_putc shf_putc_i
d1775 3
a1777 3
ssize_t shf_puts(const char *, struct shf *);
ssize_t shf_write(const char *, ssize_t, struct shf *);
ssize_t shf_fprintf(struct shf *, const char *, ...)
d1779 1
a1779 1
ssize_t shf_snprintf(char *, ssize_t, const char *, ...)
d1784 1
a1784 1
ssize_t shf_vfprintf(struct shf *, const char *, va_list)
d1793 1
a1793 1
char *snptreef(char *, ssize_t, const char *, ...);
d1829 1
a1829 1
size_t array_ref_len(const char *);
d1888 1
a1888 1
EXTERN int tty_fd E_INIT(-1);	/* dup'd tty file descriptor */
d1900 1
a1900 1
#undef E_INIT
@


1.484.2.6
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.5 2011/10/25 22:50:39 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/08"
d1821 1
a1821 1
void setint_n(struct tbl *, mksh_ari_t, int);
@


1.484.2.7
log
@MFC mksh-current fixes and upcoming deprecation and promotion; sync clog
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.6 2011/11/08 22:07:22 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/18"
a1477 1

a1507 1

@


1.484.2.8
log
@Fix regression introduced by mixing the recursive parser and support
for ;| and ;& in TCASE: ;;-less last casepart produced ";\0" in the
SREREAD string which obviously cased reparsing to fail

test from http://www.in-ulm.de/~mascheck/various/cmd-subst/
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.7 2011/11/19 22:22:00 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/22"
@


1.484.2.9
log
@• MFC this week’s bag of misc fixes
• mark “set ±o arc4random” MKSH_DISABLE_DEPRECATED (for e.g. Android)
@
text
@d156 1
a156 1
#define MKSH_VERSION "R40 2011/11/26"
@


1.484.2.10
log
@MFC recent changes to R40-stable, validate it, fix a pedantic warning
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.508 2011/12/03 00:01:28 tg Exp $");
d156 1
a156 19
#define MKSH_VERSION "R40 2011/12/04"

/* arithmetics types */
typedef int32_t mksh_ari_t;
typedef uint32_t mksh_uari_t;

/* boolean type (no <stdbool.h> deliberately) */
typedef unsigned char mksh_bool;
#undef bool
/* false MUST equal 0 */
#undef false
#undef true
/* access macros for boolean type */
#define bool		mksh_bool
/* values must have identity mapping between mksh_bool and short */
#define false		0
#define true		1
/* make any-type into bool or short */
#define tobool(cond)	((cond) ? true : false)
d347 18
@


1.484.2.11
log
@MFC
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.10 2011/12/04 19:59:59 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/11"
d286 9
@


1.484.2.12
log
@MFC all those nice things (not all parts, by now); sync clog
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.516 2011/12/31 00:27:25 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/30"
d165 1
a165 1
/* false MUST equal the same 0 as written by static storage initialisation */
d1451 5
a1455 3
EXTERN char **history;		/* saved commands */
EXTERN char **histptr;		/* last history item */
EXTERN mksh_ari_t histsize;	/* history size */
d1610 1
a1610 1
void sethistsize(mksh_ari_t);
a1613 1
#if !MKSH_S_NOVI
a1615 1
#endif
a1800 1
void dumpioact(struct shf *shf, struct op *t);
@


1.484.2.13
log
@oops…
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.12 2011/12/31 02:25:33 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/12/31"
@


1.484.2.14
log
@MFC pending stuff into mksh R40-stable branch
@
text
@d12 1
a12 2
 * Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *	       2011, 2012
d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.521 2012/02/06 17:42:23 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2012/02/11"
d158 1
a158 11
/* arithmetic types: C implementation */
#if !HAVE_CAN_INTTYPES
#if !HAVE_CAN_UCBINTS
typedef signed int int32_t;
typedef unsigned int uint32_t;
#else
typedef u_int32_t uint32_t;
#endif
#endif

/* arithmetic types: shell arithmetics */
a175 20
/* char (octet) type: C implementation */
#if !HAVE_CAN_INT8TYPE
#if !HAVE_CAN_UCBINT8
typedef unsigned char uint8_t;
#else
typedef u_int8_t uint8_t;
#endif
#endif

/* other standard types */

#if !HAVE_RLIM_T
typedef long rlim_t;
#endif

#if !HAVE_SIG_T
#undef sig_t
typedef void (*sig_t)(int);
#endif

d194 26
@


1.484.2.15
log
@MFC the Build.sh bugfix and the SkyOS and Minix stuff
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.14 2012/02/11 15:25:33 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/02"
@


1.484.2.16
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d3 1
a3 1
/*	$OpenBSD: table.h,v 1.8 2012/02/19 07:52:30 otto Exp $	*/
d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.526 2012/03/23 23:25:29 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/03/20"
d377 1
a699 3
#ifdef DF
#define shl_dbg		(&shf_iob[3])	/* for DF() */
#endif
d859 1
a859 1
EXTERN mksh_ari_t x_lins E_INIT(24);	/* tty lines */
a1721 4
#ifdef DF
void DF(const char *, ...)
    MKSH_A_FORMAT(__printf__, 1, 2);
#endif
@


1.484.2.17
log
@MFC fixes from HEAD
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.542 2012/04/06 13:29:01 tg Exp $");
d157 1
a157 1
#define MKSH_VERSION "R40 2012/04/06"
a169 8
/*
 * NOTE: these are currently hard-coded to exactly 32 bit, do not change
 *
 * TODO: make these configurable, or add 64-bit arithmetic, somehow
 * (on some operating environments, 64-bit types are needed for some
 * things, such as the ulimit builtin, to work proper), except mksh
 * must still be able to run on systems with no native 64-bit integers
 */
d199 1
a199 1
typedef unsigned long rlim_t;
a206 7
/* un-do vendor damage */

#undef BAD		/* AIX defines that somewhere */
#undef PRINT		/* LynxOS defines that somewhere */
#undef flock		/* SCO UnixWare defines that to flock64 but ENOENT */


d299 1
d315 9
d373 1
a373 1
 * portability problems (calling strchr(x, 0x80 | 'x') is error prone).
a431 10
#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 406)
#error Must run Build.sh to compile this.
int
im_sorry_dave(void)
{
	/* I’m sorry, Dave. I’m afraid I can’t do that. */
	return (thiswillneverbedefinedIhope());
}
#endif

d473 4
a561 10
#if defined(NeXT) && !defined(__GLIBC__)
#define kshjmp_buf	jmp_buf
#define kshsetjmp(jbuf)	_setjmp(jbuf)
#define kshlongjmp	_longjmp
#else
#define kshjmp_buf	sigjmp_buf
#define kshsetjmp(jbuf)	sigsetjmp((jbuf), 0)
#define kshlongjmp	siglongjmp
#endif

d569 3
a571 3
	kshjmp_buf jbuf;	/* long jump back to env creator */
	uint8_t type;		/* environment type - see below */
	uint8_t flags;		/* EF_* */
d590 2
a591 2
#define STOP_BRKCONT(t)	((t) == E_NONE || (t) == E_PARSE || \
			    (t) == E_FUNC || (t) == E_INCL)
d595 1
a595 1
/* values for kshlongjmp(e->jbuf, i) */
d863 8
d886 1
a886 1
#define KSH_UNWIND_ERROR	0	/* unwind the stack (kshlongjmp) */
d1627 1
a1627 1
Trap *gettrap(const char *, bool);
a1640 4
#if HAVE_FLOCK || HAVE_LOCK_FCNTL
void mksh_lockfd(int);
void mksh_unlkfd(int);
#endif
@


1.484.2.18
log
@MFC spelling fixes
@
text
@d155 1
a155 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.484.2.17 2012/04/06 14:40:23 tg Exp $");
d344 1
a344 1
/* remove redundancies */
@


1.483
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.482 2011/07/05 20:12:19 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/06"
@


1.482
log
@• bump patchlevel to today’s
• while here, reformat 'struct tbl' comment-wise and placement-wise
  and drop the Tflag typedef
• while here, write regression test for the "global" built-in, which
  does what typeset is supposed to do except that it doubles as "local"
@
text
@d12 1
a12 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d17 1
a17 1
 * is granted to deal in this work without restriction, including un-
d21 1
a21 1
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
d28 1
a28 1
 * of said person's immediate fault when using the work as intended.
d33 1
a33 1
#define _BSD_SOURCE	/* live, BSD, live! */
d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.481 2011/07/02 17:57:40 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/05"
d1468 23
a1490 3
/* Bob Jenkins' one-at-a-time hash, with better start value */
#define oaat1_init_impl(h) do {						\
	(h) = 0x100;							\
d1492 8
a1499 9
#define oaat1_addmem_impl(h, buf, len) do {				\
	register const uint8_t *oaat1_addmem_p = (const void *)(buf);	\
	register size_t oaat1_addmem_n = (len);				\
									\
	while (oaat1_addmem_n--) {					\
		(h) += *oaat1_addmem_p++;				\
		(h) += (h) << 10;					\
		(h) ^= (h) >> 6;					\
	}								\
d1501 7
a1507 9
#define oaat1_addstr_impl(h, s) do {					\
	register const uint8_t *oaat1_addstr_p = (const void *)(s);	\
	register uint8_t oaat1_addstr_c;				\
									\
	while ((oaat1_addstr_c = *oaat1_addstr_p++)) {			\
		h += oaat1_addstr_c;					\
		(h) += (h) << 10;					\
		(h) ^= (h) >> 6;					\
	}								\
d1509 6
a1514 4
#define oaat1_fini_impl(h) do {						\
	(h) += (h) << 3;						\
	(h) ^= (h) >> 11;						\
	(h) += (h) << 15;						\
d1517 1
@


1.481
log
@address "env RANDOM=1=2=3 mksh" DoS by integrifying more
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.480 2011/06/30 13:48:13 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/07/02"
a346 3
/* Table flag type - needs > 16 and < 32 bits */
typedef int32_t Tflag;

d843 1
a843 1
EXTERN Tflag builtin_flag;
d946 5
a950 2
struct tbl {			/* table item */
	Area *areap;		/* area to allocate from */
d952 6
a957 6
		char *s;		/* string */
		mksh_ari_t i;		/* integer */
		mksh_uari_t u;		/* unsigned integer */
		int (*f)(const char **); /* int function */
		struct op *t;		/* "function" tree */
	} val;			/* value */
d963 2
a964 2
		int field;	/* field with for -L/-R/-Z */
		int errno_;	/* CEXEC/CTALIAS */
a965 3
	int type;		/* command type (see below), base (if INTEGER),
				 * or offset from val.s of value (if EXPORT) */
	Tflag flag;		/* flags */
d970 10
a979 1
	char name[4];		/* name -- variable length */
d1806 1
a1806 1
struct tbl *typeset(const char *, Tflag, Tflag, int, int)
@


1.480
log
@tabcomplete ~ and ~foo like $FOO (idea by yofuh)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.479 2011/06/21 21:50:25 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/30"
d1799 1
@


1.479
log
@pretty tricky thing, IBM’s curses library does nameref foo=foo…
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.476 2011/06/12 14:58:45 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/21"
@


1.478
log
@make set_refflag an enum to get easier to understand code
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.477 2011/06/21 21:10:12 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/12"
@


1.477
log
@re-indent comments
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.476 2011/06/12 14:58:45 tg Exp $");
d1020 6
@


1.476
log
@HP-UX aCC suggested more “≠ 0” and parenthesēs
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.475 2011/06/11 03:14:50 tg Exp $");
d343 2
a345 1
#define BIT(i)		(1 << (i))	/* define bit in flag */
d377 2
a378 1
/* Make MAGIC a char that might be printed to make bugs more obvious, but
d825 3
a827 1
typedef int32_t Coproc_id; /* something that won't (realisticly) wrap */
d845 2
a846 1
EXTERN Tflag builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
d851 3
a853 2
/* Minimum required space to work with on a line - if the prompt leaves less
 * space than this on a line, the prompt is truncated.
d856 2
a857 1
/* Minimum allowed value for x_cols: 2 for prompt, 3 for " < " at end of line
d1009 4
a1012 2
/* Attributes that can be set by the user (used to decide if an unset param
 * should be repoted by set/typeset). Does not include ARRAY or LOCAL.
d1810 2
a1811 1
	TO_NONOP = 0,	/* non-operator */
@


1.475
log
@add missing shf_flush() before prompting
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.474 2011/06/05 19:58:19 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/10"
d1438 2
a1439 2
#define notoktomul(fac1, fac2)	((fac1) && (fac2) && \
				    (SIZE_MAX / (fac1) < (fac2)))
@


1.474
log
@• rework hash table interna to avoid gcc-4.1 on Debian etch bug
• also improve behaviour with _a lot_ (>2²⁸) entries
• while here, improve comments and whitespace
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.473 2011/06/04 16:42:31 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/05"
@


1.473
log
@fix segfault due to limit of hashtable entries (global variables) discovered by Jb_boin: unlimit to 2^30 minus epsilon
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.472 2011/06/04 16:11:19 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/06/04"
a937 1
	uint32_t size;		/* table size (always 2^n) */
d939 1
d1685 4
a1688 2
void ktinit(struct table *, Area *, size_t);
struct tbl *ktsearch(struct table *, const char *, uint32_t);
d1788 2
a1789 2
const char *skip_wdvarname(const char *, int);
int is_wdvarname(const char *, int);
@


1.472
log
@better parsing for x=(…) – bug noted by Frank Terbeck
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.471 2011/05/29 16:31:42 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R40 2011/05/29"
d938 2
a939 1
	short size, nfree;	/* hash size (always 2^^n), free entries */
@


1.471
log
@• AIX: display OS version better (tested on 5.3 by cnuke@@)
• IBM XL C: display version better (tested on V7.0 by cnuke@@)
• do not 'IFS=: read nr name', Cygwin 1.7 dash fails it
• disable cd-pe, glob-range-3 on Cygwin (the former cannot
  succeed because the mv fails, the latter fails from 1.7 on)
• mark heredoc-tmpfile-8 as need-pass: no
• apply __attribute__ only to a function prototype, not to
  the body (even if static), since xlC fails that
• bump version to R40 (beta)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.470 2011/05/29 02:18:55 tg Exp $");
a1415 1
#define LETARRAY	BIT(12)	/* copy expression inside =( ) */
d1417 1
a1417 1
#define HERES	10		/* max << in line */
@


1.470
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.469 2011/05/06 15:41:25 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/05/28"
@


1.469
log
@• add patch from Robert Luberda <robert@@debian.org> fixing the
  four-argument form of test (yet again…), thanks
• drop the obsolete (pre-POSIX) form “test -t” without fd
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.468 2011/05/05 00:04:59 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/05/06"
d1114 1
d1116 6
a1121 3
		/* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
		short evalflags;	/* TCOM: arg expansion eval() flags */
		short ksh_func;		/* TFUNC: function x (vs x()) */
d1399 2
d1493 1
d1789 1
@


1.468
log
@• use a flag for determining here strings, don’t parse delimiter every time
• don’t leak memory parsing possible I/O redirection tokens
• get rid of volatile by using more const (also helps codegen, methinks)
• support empty here document markers (mksh extension)
• pimp the manpage
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.467 2011/05/02 22:52:52 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/05/04"
@


1.467
log
@• fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
• merge tputS and wdstrip_internal
⇒ net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.466 2011/04/22 21:44:35 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/05/02"
d1175 15
a1189 13
#define IOTYPE	0xF	/* type: bits 0:3 */
#define IOREAD	0x1	/* < */
#define IOWRITE	0x2	/* > */
#define IORDWR	0x3	/* <>: todo */
#define IOHERE	0x4	/* << (here file) */
#define IOCAT	0x5	/* >> */
#define IODUP	0x6	/* <&/>& */
#define IOEVAL	BIT(4)	/* expand in << */
#define IOSKIP	BIT(5)	/* <<-, skip ^\t* */
#define IOCLOB	BIT(6)	/* >|, override -o noclobber */
#define IORDUP	BIT(7)	/* x<&y (as opposed to x>&y) */
#define IONAMEXP BIT(8)	/* name has been expanded */
#define IOBASH	BIT(9)	/* &> etc. */
@


1.466
log
@sync clog
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.465 2011/04/22 12:21:55 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/04/22"
d1752 4
a1755 1
char *wdstrip(const char *, bool, bool);
@


1.465
log
@this is about the amount -Wl,--gc-sections can help me to eliminate
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.464 2011/04/22 12:15:40 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/04/17"
@


1.464
log
@more static initialisers (verified using nm comparision between mksh
built with/-out "-ffunction-sections -fdata-sections -Wl,--gc-sections"
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.463 2011/04/17 12:24:44 tg Exp $");
d843 1
a843 1
/* current working directory, and size of memory allocated for same */
a844 1
EXTERN size_t	current_wd_size;
a1584 1
int findhistrel(const char *);
a1616 1
int j_njobs(void);
@


1.463
log
@always catch SIGALRM even in non-interactive shells to make sleep work
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.462 2011/04/09 21:01:03 tg Exp $");
d356 1
@


1.462
log
@avoid namespace conflicts with __attribute__(…)
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.461 2011/04/09 18:47:14 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/04/09"
@


1.461
log
@sync… various things
@
text
@d93 1
a93 1
#define MKSH_A_BOUNDED(x,y,z)	__attribute__((bounded (x, y, z)))
d98 1
a98 1
#define MKSH_A_FORMAT(x,y,z)	__attribute__((format (x, y, z)))
d108 1
a108 1
#define MKSH_A_NORETURN		__attribute__((noreturn))
d113 1
a113 1
#define MKSH_A_UNUSED		__attribute__((unused))
d118 1
a118 1
#define MKSH_A_USED		__attribute__((used))
d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.460 2011/04/09 15:14:53 tg Exp $");
d1626 1
a1626 1
    MKSH_A_FORMAT(printf, 1, 2);
d1642 1
a1642 1
    MKSH_A_FORMAT(printf, 1, 2);
d1645 1
a1645 1
    MKSH_A_FORMAT(printf, 2, 3);
d1647 1
a1647 1
    MKSH_A_FORMAT(printf, 2, 3);
d1649 1
a1649 1
    MKSH_A_FORMAT(printf, 1, 2);
d1655 1
a1655 1
    MKSH_A_FORMAT(printf, 1, 2);
d1657 1
a1657 1
    MKSH_A_FORMAT(printf, 1, 2);
d1660 1
a1660 1
    MKSH_A_FORMAT(printf, 1, 2);
d1662 1
a1662 1
    MKSH_A_FORMAT(printf, 1, 2);
d1706 1
a1706 1
    MKSH_A_BOUNDED(buffer, 2, 3);
d1735 1
a1735 1
    MKSH_A_FORMAT(printf, 2, 3);
d1737 2
a1738 2
    MKSH_A_FORMAT(printf, 3, 4)
    MKSH_A_BOUNDED(string, 1, 2);
d1740 1
a1740 1
    MKSH_A_FORMAT(printf, 1, 2);
d1742 1
a1742 1
    MKSH_A_FORMAT(printf, 2, 0);
d1760 1
a1760 1
    MKSH_A_BOUNDED(string, 1, 2);
d1773 1
a1773 1
    MKSH_A_NONNULL((nonnull (1)));
@


1.460
log
@• no longer use <stdbool.h> even if it’s available
• ensure that bool/true/false are cpp macros, overriding any pre-defined
• document the requirement that tobool(x) must map any-type 'x' into bool
• document the requirement that a bool must only be true or false, and
  that it (tobool() rather) must have an identity mapping to 'short'
• possibly fix ksh_func for/and fpFUNCTf – maybe spotted by cnuke@@
@
text
@d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.459 2011/04/09 14:58:53 tg Exp $");
d156 1
a156 1
#define MKSH_VERSION "R39 2011/04/01"
@


1.459
log
@easier debugging with HAVE_STDBOOL_H=0 for if bool is indeed built-in
@
text
@a70 3
#if HAVE_STDBOOL_H
#include <stdbool.h>
#endif
d154 1
a154 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.458 2011/04/02 10:30:11 tg Exp $");
a184 14
#if !HAVE_STDBOOL_H
/* kludge, but enough for mksh */
typedef unsigned char mksh_bool;
#define bool mksh_bool
#define false 0
#define true 1
#endif

/* choose the one that is optimised on most platforms? */
#define tobool(cond)	((cond) ? true : false)
/*#define tobool(cond)	(!!(cond))*/
/* the following only with <stdbool.h> and even then sometimes buggy */
/*#define tobool(cond)	((bool)(cond))*/

d353 13
d1114 2
a1115 1
	union { /* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
@


1.458
log
@skip the UTF-8 BOM early, then check the magic (ELF, a.out, COFF, …)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.457 2011/03/28 08:40:42 tg Exp $");
d190 2
a191 1
typedef unsigned char bool;
@


1.457
log
@add testcases, bump vsn
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.456 2011/03/27 18:50:05 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/28"
@


1.456
log
@• Implement http://austingroupbugs.net/view.php?id=367 and align things
  a bit more with POSIX and the other shells

I considered http://austingroupbugs.net/view.php?id=253 but the use
of bi_errorf() is interesting, especially as it’s often enough a
noreturn function, and funnily enough, 'cd -P /foo' returns 0 while
'chdir -P /foo' fails (so idk where to put -e)…
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.455 2011/03/27 01:30:38 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/27"
@


1.455
log
@don’t leak memory (pdksh did), and forgot a hunk
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.454 2011/03/26 21:46:06 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/26"
d1645 3
d1653 1
a1654 2
void internal_verrorf(const char *, va_list)
    MKSH_A_FORMAT(printf, 1, 0);
@


1.454
log
@• bring back test -H ifdef S_ISCDF (for HP-UX)
• whitespace, etc.
• bump version for tonight, I’m not gonna hack on c_cd,
  all this pathname stuff is mind-boggling…
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.453 2011/03/26 19:43:49 tg Exp $");
d277 3
@


1.453
log
@simplify code to use existing $PWD
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.452 2011/03/24 19:05:49 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/23"
@


1.452
log
@• move funcs.c:do_realpath() to misc.c and make it global
  ⇒ consider merging simplify_path()
• move funcs.c:c_cd() to misc.c
• make misc.c:make_path() static, c_cd() is its only user
  ⇒ mark as obsolete
• tweak misc.c:set_current_wd() to drop ksh_get_wd() argument

should be no code change, but the entire path stuff is a mess…
so expect actual implementation changes or even rewrites shortly
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.451 2011/03/23 18:47:07 tg Exp $");
d1708 1
a1708 1
void set_current_wd(char *);
@


1.451
log
@ironhead reported in IRC that some Cygwin guys (not he, he’s just the
packager) complain that mksh collapses two leading slashes; IIRC POSIX
has a clause for UNC pathnames, so stop doing that, plus add a test
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.450 2011/03/21 21:57:33 tg Exp $");
a1519 1
int c_cd(const char **);
d1705 2
a1706 2
char *ksh_get_wd(size_t *);
int make_path(const char *, const char *, char **, XString *, int *);
d1709 1
@


1.450
log
@• save/restore here document pointer during yyrecursive(), fixes crash
• add mirbsd/openbsd (omalloc rules!) specific testcase for the above
• $__progname must be used quoted, fix in comsub-torture testcase (my bad)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.449 2011/03/17 22:09:23 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/21"
@


1.449
log
@fix cast; bump version
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.448 2011/03/17 21:59:30 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/17"
@


1.448
log
@• make misc.c(gmatch.c):pat_scan() static and fix int → bool
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.447 2011/03/17 21:58:38 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/16"
@


1.447
log
@• make DEBUG:dumpchar() not static (consider rolling into shf?)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.446 2011/03/16 20:26:36 tg Exp $");
a1693 1
const unsigned char *pat_scan(const unsigned char *, const unsigned char *, int);
@


1.446
log
@• introduce a virtual TARGET_OS=Android that just sets a check category
  and switches to the TARGET_OS=Linux
• introduce android as regression test suite category
• add an android specific standard alias
• clean up redundant ‘-o sh’ arg in a few checks
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.445 2011/03/13 16:03:53 tg Exp $");
d1754 1
@


1.445
log
@• speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
• parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.444 2011/03/13 01:20:22 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/13"
@


1.444
log
@lint is your friend
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.443 2011/03/12 23:04:47 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/12"
d1356 1
a1356 2
#define SF_FIRST	BIT(4)	/* initial state (to ignore UTF-8 BOM) */
#define SF_HASALIAS	BIT(5)	/* u.tblp valid (SALIAS, SEOF) */
d1743 1
a1743 1
struct op *compile(Source *);
@


1.443
log
@• back out the EXPRSUB change
• optimise some code
• split testcase into two, one with expected-fail
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.441 2011/03/08 18:49:50 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/08"
@


1.442
log
@• make EXPRSUB not initiate an ASCIIZ string any more but a wdstring
  (token stream, lexer output / parser input), EOS terminated, let
  SASPAREN use the same lexing as SBASE (e.g. COMSUB recursively)
• make wdstrip recursive
• fix processing of COMSUB in wdstrip
⇒ pass comsub-1 test
• expose another debugging function
@
text
@d1152 1
a1152 1
#define EXPRSUB	4	/* $(()) substitution (EOS terminated wdstring) */
@


1.441
log
@• add a tree debugging dumper #ifdef DEBUG
• use shf_putc (macro), shf_putchar (function) ipv tputc
• replace shf_putchar(x,y) calls for side-effect-less x with shf_putc
• plug another bug in the tree code – '\' → "\\" (backslashes must be
  escaped inside double quotes, too)
• adjust testsuite (and, I _had_ wondered…)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.440 2011/03/07 20:32:50 tg Exp $");
d1152 1
a1152 1
#define EXPRSUB	4	/* $(()) substitution (0 terminated) */
d1756 1
@


1.440
log
@• x=$(cat <<-EOF
	EOF) # works again now, plugging a regression
• rewrite the here document parsing code to be *much* more efficient
  (and a bit more readable too!) using goto, while here (no kidding)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.439 2011/03/07 20:30:40 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/07"
d1755 1
@


1.439
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.438 2011/03/06 17:08:13 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/06"
@


1.438
log
@• more fixes (some regression, some new)
• more testcases, stricter testcases
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.437 2011/03/06 01:50:11 tg Exp $");
d190 1
a190 1
typedef int bool;
d195 6
d787 1
a787 1
#define ctype(c, t)	!!( ((t) == C_SUBOP2) ?				\
d789 1
a789 1
			    (chtypes[(unsigned char)(c)]&(t)) )
@


1.437
log
@I thought of making COMSUB pass a pointer to the struct op *t->left around
instead, but the parser for the so-called “backticks” (U+0060) still emits
plaintext COMSUB wdstrings, and the evaluation code emits plaintext if the
code is not run (‘-n’ option), so it’s not worth the effort and memory ma-
nagement issues, even though it _would_ optimise the most common case…

Bump version numbers, sync regression tests; add one testcase from the old
webpages too. Sync manpage, this now works, but keep the workaround in, as
“portability issue” with slightly changed wording.

Also, /bin/sleep must be used in one manpage example if sleep is built in.
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.436 2011/03/06 01:25:33 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/03/05"
d1742 1
a1742 1
int fptreef(struct shf *, int, const char *, ...);
d1749 3
a1751 1
int fpFUNCTf(struct shf *, int, bool, const char *, struct op *);
@


1.436
log
@the long-awaited recursive parser for COMSUB $(…) expressions

fixes RedHat BZ#496791
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.435 2011/03/05 21:48:09 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/02/18"
@


1.435
log
@split malloc_os and friends further into
• functions called by mksh’s grouping memory allocator
• functions called by mksh code itself

the latter may be changed to call the internal grouping allocator,
if a porter so desires (but if this were recommended, the code in
question would already do so, so…)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.434 2011/03/05 21:43:18 tg Exp $");
d1740 1
@


1.434
log
@introduce macros for malloc, realloc, free to hide them from mksh

no code may henceforth use memory (de-)allocation functions directly
use these macros, porters can change them for abstraction
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.433 2011/02/27 19:29:32 tg Exp $");
d503 9
a511 4
/* malloc(3)/realloc(3) -> free(3) */
#define malloc_os(sz)		malloc(sz)
#define realloc_os(p,sz)	realloc((p), (sz))
#define free_osmalloc(p)	free(p)
@


1.433
log
@fix UWIN: don’t close fd #3 (also, int→bool)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.432 2011/02/18 22:26:13 tg Exp $");
d500 24
@


1.432
log
@• add -u option (POSIX: unbuffered ⇒ nop) to the built-in cat
• PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
• add regression tests, documentation, etc.
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.431 2011/02/13 21:13:08 tg Exp $");
d1798 1
a1798 1
EXTERN int tty_devtty;		/* true if tty_fd is from /dev/tty */
@


1.431
log
@* plug a regression introduced as a pasto (think, mira!)
* add selftest-direct-builtin-call regression test, while here
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.430 2011/02/11 01:18:22 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/02/13"
d580 1
d952 1
a952 1
#define INT_L		BIT(20)	/* long integer (no-op) */
d1166 1
@


1.430
log
@• more comment and int→bool cleanup, add and improve some comments
• in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesn’t suffice
• add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
• for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
• when called as builtin, echo behaves POSIXish
• add domainname as alias for true on MirBSD only, to be able to link it
• sync mksh Makefiles with Build.sh output
• adjust manpage wrt release plans
• link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
• drop linked utilities and, except for echo and kill, their manpages
• adjust instbin and link a few more there as well
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.429 2011/02/11 00:41:37 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/02/11"
@


1.429
log
@add a sleep builtin that can deal with fractions too
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.428 2011/02/09 13:08:27 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/02/09"
d1462 1
a1462 1
void builtin(const char *, int (*)(const char **));
d1464 1
a1464 1
void flushcom(int);
@


1.428
log
@fix warning about signed vs. unsigned comparision and potential truncation error
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.427 2011/02/03 15:57:52 tg Exp $");
d629 1
d798 1
a798 1
/* Used in jobs.c and by coprocess stuff in exec.c */
d1530 1
d1708 1
@


1.427
log
@refactor code to be able to track whether we have a parameter substitution
or a “proper” glob expansion; if there’s a dollar, but not a glob, refrain
from appending a space later (LP: #710539)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.426 2011/01/30 01:36:00 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/02/03"
@


1.426
log
@SUSv4 says trap foo UNKNOWN is not a syntax error, merely exit ≠0.
Inspired by 673dab8698b0399c967216c02262eaf95361a75c.
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.425 2011/01/30 01:35:35 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/01/29"
@


1.425
log
@introduce MKSH_NOPROSPECTOFWORK which is like pdksh’s JOB_SIGS in reverse, like MKSH_UNEMPLOYED is pdksh’s JOBS in reverse; allows mksh to work (hah! no pun intended…) with klibc (and possibly, Syllable Desktop and Plan 9) for now, until they fix their bugs
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.424 2011/01/22 20:33:14 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/01/22"
@


1.424
log
@plug regression introduced with read -d by fixing the problem differently
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.423 2011/01/21 22:25:34 tg Exp $");
d492 4
d796 1
d799 1
@


1.423
log
@${foo@@x} is now special-expansion for values of x, defined for now:
‘#’ = hash of $foo
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.422 2011/01/21 21:04:47 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/01/21"
@


1.422
log
@• implement KSHEGID, KSHGID, KSHUID variables by suggestion of Richard K.
  (KSHEUID aka USER_ID already exists)
• simplify, speed up LCG and $RANDOM handling again
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.421 2011/01/09 21:57:29 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2011/01/08"
@


1.421
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Lëtzebuerg ☺

This was the third try. Where to put this was not palpable… same for =(…)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.420 2010/12/19 20:00:56 tg Exp $");
d522 1
a522 1
#define Flag(f)	(kshstate_v.shell_flags_[(int)(f)])
d572 13
a584 22
/*
 * some kind of global shell state, for change_random() mostly
 */

EXTERN struct mksh_kshstate_v {
	/* for change_random */
	struct timeval cr_tv;	/* timestamp */
	const void *cr_dp;	/* argument address */
	size_t cr_dsz;		/* argument length */
	uint32_t lcg_state_;	/* previous LCG state */
	/* global state */
	pid_t procpid_;		/* PID of executing process */
	int exstat_;		/* exit status */
	int subst_exstat_;	/* exit status of last $(..)/`..` */
	struct env env_;	/* top-level parsing & execution env. */
	short trap_exstat_;	/* exit status before running a trap */
	uint8_t trap_nested_;	/* running nested traps */
	uint8_t shell_flags_[FNFLAGS];
} kshstate_v;
EXTERN struct mksh_kshstate_f {
	const char *kshname_;	/* $0 */
	pid_t kshpid_;		/* $$, shell PID */
a585 1
	uid_t ksheuid_;		/* effective UID of shell */
d587 2
a588 12
	uint32_t h;		/* some kind of hash */
} kshstate_f;
#define kshname		kshstate_f.kshname_
#define kshpid		kshstate_f.kshpid_
#define procpid		kshstate_v.procpid_
#define kshpgrp		kshstate_f.kshpgrp_
#define ksheuid		kshstate_f.ksheuid_
#define kshppid		kshstate_f.kshppid_
#define exstat		kshstate_v.exstat_
#define subst_exstat	kshstate_v.subst_exstat_
#define trap_exstat	kshstate_v.trap_exstat_
#define trap_nested	kshstate_v.trap_nested_
d590 7
a596 2
/* evil hack: return hash(kshstate_f concat (kshstate_f'.h:=hash(arg))) */
uint32_t evilhash(const char *);
d1395 30
a1631 3
#define hash(s) oaathash_full((const uint8_t *)(s))
uint32_t oaathash_full(register const uint8_t *);
uint32_t hashmem(const void *, size_t);
a1726 1
void change_random(const void *, size_t);
d1731 2
@


1.420
log
@this is a bashism but might be from ksh93 IIRC… still dead ugly as hell!
@
text
@d12 1
a12 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.419 2010/11/01 17:29:05 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/12/19"
d633 1
d1203 1
a1203 1
#define X_EXTRA	8	/* this many extra bytes in X string */
d1401 2
d1643 1
@


1.419
log
@change behaviour of argument-less exit in traps to match SUSv4; Debian #599484 (original patch from Jonathan Nieder, thanks!) in a variant that appears to handle nested traps well
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.418 2010/10/08 17:56:57 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/11/01"
@


1.418
log
@mknod’s now demoted and only used as special-case builtin, in MirBSD only
built for the installer, to save time, as the original OpenBSD hack wanted
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.417 2010/10/01 19:04:38 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/10/01"
d587 2
d607 2
d1533 1
a1533 1
void runtrap(Trap *);
@


1.417
log
@• Build.sh: fix a compiler warning which, had it not been irrelevant in
  a mirtoconf check, would’ve been a real problem on an LP64 platform
• sh.h: work around a bad interaction between -Wformat on gcc and manual
  string pooling for T_synerr, which is used in place of a format string
  in some places
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.416 2010/09/19 19:28:23 tg Exp $");
a307 5
#if !HAVE_SETMODE
mode_t getmode(const void *, mode_t);
void *setmode(const char *);
#endif

@


1.416
log
@while here, change SETUID_CAN_FAIL_WITH_EAGAIN to abort immediately
by suggestion of Chris Palmer again
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.415 2010/09/15 21:08:19 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/09/19"
d634 4
d639 1
@


1.415
log
@revert part of the “size reduction” diff (zero size change though):
shellf() implies an shf_flush()…
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.414 2010/09/14 21:26:16 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/09/15"
@


1.414
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.413 2010/09/14 21:15:11 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/09/14"
@


1.413
log
@add size optimisation hacks by me from Android except ifdef’d
(note, I’d prefer everyone to keep IDSTRINGs around though)
@
text
@d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.412 2010/09/05 19:51:35 tg Exp $");
d159 1
a159 1
#define MKSH_VERSION "R39 2010/09/05"
d633 5
a637 4
#define T_synerr "syntax error"
EXTERN const char r_fc_e_[] I__("r=fc -e -");
#define fc_e_		(r_fc_e_ + 2)		/* "fc -e -" */
#define fc_e_n		7			/* strlen(fc_e_) */
d1227 1
a1227 1
		(xp) = Xcheck_grow_(&(xs), (xp), more);		\
d1248 1
a1248 1
char *Xcheck_grow_(XString *, const char *, unsigned int);
d1261 1
a1261 1
	vp__ = alloc((n) * sizeof(void *), ATEMP);		\
d1269 2
a1270 2
		(x).beg = aresize((x).beg,			\
		    n * 2 * sizeof(void *), ATEMP);		\
d1279 1
a1279 1
#define XPclose(x)	aresize((x).beg, XPsize(x) * sizeof(void *), ATEMP)
d1396 7
d1407 2
a1408 1
#define alloc(n, ap)	aresize(NULL, (n), (ap))
d1410 1
@


1.412
log
@optimise error messages, option parsing, and make more builtins
recognise "--", costs us 20 .text 0 .data 0 .bss
@
text
@d144 3
d150 1
d157 1
a157 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.411 2010/08/28 20:22:22 tg Exp $");
@


1.411
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.410 2010/08/28 18:50:55 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/08/28"
d1478 2
a1479 1
int c_builtin(const char **);
@


1.410
log
@improve string pooling: saves 316 bytes in .text
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.409 2010/08/28 17:21:46 tg Exp $");
d644 2
d1673 1
@


1.409
log
@make cat an mksh builtin, for things like here documents
if any options are given, the external programme is invoked instead
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.408 2010/08/28 16:47:10 tg Exp $");
d636 8
@


1.408
log
@fix blocking_read prototype
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.407 2010/08/28 15:48:20 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/08/24"
d1475 1
@


1.407
log
@whitespace
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.406 2010/08/28 15:39:20 tg Exp $");
d1614 1
a1614 1
int blocking_read(int, char *, int)
@


1.406
log
@int → bool
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.405 2010/08/24 15:19:54 tg Exp $");
d701 1
a701 1
EXTERN volatile sig_atomic_t fatal_trap;/* received a fatal signal */
d762 7
a768 7
	const char	*optarg;
	int		optind;
	int		uoptind;/* what user sees in $OPTIND */
	int		flags;	/* see GF_* */
	int		info;	/* see GI_* */
	unsigned int	p;	/* 0 or index into argv[optind - 1] */
	char		buf[2];	/* for bad option OPTARG value */
d899 1
a899 1
		int (*f)(const char **);/* int function */
d1118 5
a1122 5
	int	unit;	/* unit affected */
	int	flag;	/* action (below) */
	char	*name;	/* file name (unused if heredoc) */
	char	*delim;	/* delimiter for <<,<<- */
	char	*heredoc;/* content of heredoc */
d1721 2
a1722 2
		const char **wp;/* used by ptest_* */
		XPtrV *av;	/* used by dbtestp_* */
d1724 1
a1724 1
	const char **wp_end;	/* used by ptest_* */
d1729 1
a1729 1
	int flags;		/* TEF_* */
@


1.405
log
@it’s ugly to write a ./stdint.h file if we can instead define the
types from sh.h; sync clog
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.404 2010/08/24 14:42:04 tg Exp $");
d658 1
a658 1
EXTERN int shl_stdout_ok;
@


1.404
log
@fix realpath builtin’s handling of (source) pathnames with a trailing slash
as per POSIX (if a trailing slash is part of the symlink target it fails as
well, like GNU readlink -f does)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.403 2010/08/14 21:35:13 tg Exp $");
d191 17
@


1.403
log
@on MirBSD we can use the system wcwidth() and save ~800by on the ramdisc
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.402 2010/07/25 11:35:42 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/25"
@


1.402
log
@a tad annoying, when external programmes such as GNU screen are running,
we don’t get SIGWINCH when the window size changes during the runtime of
that, so, the signal is only usable reliably during editing in the shell
and we re-check the window size before each interactive edit line again
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.401 2010/07/24 17:08:30 tg Exp $");
d316 9
d1409 1
d1411 1
@


1.401
log
@int → bool
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.400 2010/07/21 11:31:16 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/24"
d678 1
a678 1
/* got_winch = 1 when needing to re-adjust the window size */
@


1.400
log
@Michal Hlavinka from Red Hat found another SIGSEGV
fix: when iterating over all Sources, know when to stop…
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.399 2010/07/19 22:41:03 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/21"
@


1.399
log
@*sigh* this code is interesting: assume you want to output via shf to
a string buffer whose window size is currently 32 (initial), your data
is 96 bytes, this routine used to resize the buffer to 64, append your
first 64 bytes to it (no matter if there's already something in it)
and then writes the remaining bytes to stdio fd instead of the string…
if it doesn’t SIGABRT before

discovered by wbx@@ – thanks – bug inherited from pdksh 5.2.14 (AD 1999)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.398 2010/07/17 22:09:38 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/19"
@


1.398
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.397 2010/07/13 13:12:32 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/17"
@


1.397
log
@partial oksh sync (RCSID and do add some parenthesēs to the list of
reserved words, but really only these which are only recognised at
the beginning of a line as the context says, not blindly all of them)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.396 2010/07/11 11:17:32 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/13"
d551 1
a551 1
EXTERN struct {
d564 1
a564 1
EXTERN struct {
d1669 3
a1671 1
	TO_INTGE, TO_INTLT, TO_INTLE, TO_FILEQ, TO_FILNT, TO_FILOT
d1691 1
a1691 2
typedef struct test_env Test_env;
struct test_env {
d1697 4
a1700 4
	int (*isa)(Test_env *, Test_meta);
	const char *(*getopnd) (Test_env *, Test_op, bool);
	int (*eval)(Test_env *, Test_op, const char *, const char *, bool);
	void (*error)(Test_env *, int, const char *);
d1702 1
a1702 1
};
@


1.396
log
@on obsd/mbsd, entropy is cheap enough for us to do this (codepath in
kernel checked for both) for additional seeding ($RANDOM is still from
the LCG only)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.395 2010/07/04 17:45:16 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/11"
@


1.395
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.394 2010/07/04 17:33:57 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/07/04"
@


1.394
log
@to speed up mksh, get rid of arc4random(3) uses and use the LCG always;
depend on ASLR for seeding
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.393 2010/07/04 13:36:43 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/05/22"
d668 1
a668 1
#define SS_SHTRAP	BIT(5)	/* trap for internal use (SIGCHLD, SIGALRM) */
d678 7
@


1.393
log
@simplify a bunch of things (no SIGWINCH handler, errno is saved for
an shtrap automatically) and gratitutous reformatting of comments
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.392 2010/05/22 12:49:16 tg Exp $");
a274 10
#if !HAVE_ARC4RANDOM_DECL
extern u_int32_t arc4random(void);
extern void arc4random_addrandom(unsigned char *, int)
    MKSH_A_BOUNDED(string, 1, 2);
#endif

#if !HAVE_ARC4RANDOM_PUSHB_DECL
extern uint32_t arc4random_pushb(const void *, size_t);
#endif

a353 19
EXTERN struct {
	const char *kshname_;	/* $0 */
	pid_t kshpid_;		/* $$, shell PID */
	pid_t procpid_;		/* PID of executing process */
	pid_t kshpgrp_;		/* process group of shell */
	uid_t ksheuid_;		/* effective UID of shell */
	pid_t kshppid_;		/* PID of parent of shell */
	int exstat_;		/* exit status */
	int subst_exstat_;	/* exit status of last $(..)/`..` */
} kshstate_;
#define kshname		kshstate_.kshname_
#define kshpid		kshstate_.kshpid_
#define procpid		kshstate_.procpid_
#define kshpgrp		kshstate_.kshpgrp_
#define ksheuid		kshstate_.ksheuid_
#define kshppid		kshstate_.kshppid_
#define exstat		kshstate_.exstat_
#define subst_exstat	kshstate_.subst_exstat_

d489 12
d547 38
a599 14
/*
 * flags (the order of these enums MUST match the order in misc.c(options[]))
 */
enum sh_flag {
#define SHFLAGS_ENUMS
#include "sh_flags.h"
	FNFLAGS		/* (place holder: how many flags are there) */
};

#define Flag(f)	(shell_flags[(int)(f)])
#define UTFMODE	Flag(FUNICODE)

EXTERN unsigned char shell_flags[FNFLAGS];

a1644 1
#if !HAVE_ARC4RANDOM
a1645 1
#endif
@


1.392
log
@apply diff from manuel giraud via oksh to keep track of LINENO in a trap
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.391 2010/05/16 19:04:42 tg Exp $");
d661 1
a661 1
#define SS_SHTRAP	BIT(5)	/* trap for internal use (CHLD,ALRM,WINCH) */
@


1.391
log
@disallow some more kinds to trim a vector; Debian #581867
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.32 2009/01/29 23:27:26 jaredy Exp $	*/
d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.390 2010/04/27 21:39:09 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/05/16"
d1499 1
a1499 1
int command(const char *);
@


1.390
log
@address two performance issues in do_realpath():
• avoid calling realloc twice in sequence, since the final
  size is known at the first call already
• do not lstat(2) the same path twice in the Hurd codepath
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.389 2010/04/20 09:10:07 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/04/27"
@


1.389
log
@Fourth time’s a charm… another bugfix related to the commitids
1004BBDD84556472D84, 1004BBF77B81D30DA7C and 1004BBF7CD656308A1C
to unbreak kwalletcli
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.388 2010/04/09 19:16:31 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/04/20"
@


1.388
log
@draft a testcase to understand the problem fixed by cid 1004BBF77B81D30DA7C
and make it actually work: the OpenBSD fix failed since 1004BBDD84556472D84
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.387 2010/04/08 13:21:08 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/04/09"
@


1.387
log
@Fix two more POSIX conformance bugs and minor documentation/comment issues
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.386 2010/03/27 16:53:17 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/04/08"
@


1.386
log
@fix another expand-ugly SUSv4 bug
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.385 2010/03/27 16:51:39 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/03/27"
@


1.385
log
@rework ‘m’ and ‘v’ ulimits; add more (seen at zsh)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.384 2010/03/14 11:58:33 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/03/14"
@


1.384
log
@even better on Haiku:
* let ulimits work
* add a Haiku-specific ulimit
* always use UTF-8, they have no locales but a UTF-8 terminal
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.383 2010/02/25 20:18:17 tg Exp $");
a253 4
#if !defined(RLIMIT_VMEM) && defined(RLIMIT_AS)
#define RLIMIT_VMEM	RLIMIT_AS
#endif

@


1.383
log
@(hopefully) fix the substitution thing for good
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.382 2010/02/23 18:13:04 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/02/25"
@


1.382
log
@x_bind cannot have the nonnull attribute
cought by Frank “enstein” Terbeck «ft:#grml» (efftee), 10x
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.381 2010/02/18 17:31:23 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/02/23"
@


1.381
log
@at least _parse_ the construct ${foo+(bar)} correctly
(whether the output is correct is still up for debate)
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.380 2010/01/29 09:34:30 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/02/18"
d1353 5
@


1.380
log
@remove some more of this ugliness
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.379 2010/01/28 20:58:34 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/01/29"
@


1.379
log
@• unbreak testsuite for MKSH_SMALL
• sync version and © year
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.378 2010/01/28 20:26:51 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/01/28"
d800 5
a804 3
#define shf_getc(shf) ((shf)->rnleft > 0 ? (shf)->rnleft--, *(shf)->rp++ : \
			shf_getchar(shf))
#define shf_putc(c, shf)	((shf)->wnleft == 0 ? shf_putchar((c), (shf)) : \
@


1.378
log
@Add some assertions – mkssert() – for things clang’s scan-build can’t see
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.377 2010/01/28 15:13:25 tg Exp $");
d155 1
a155 1
#define MKSH_VERSION "R39 2010/01/08"
@


1.377
log
@No, __attribute__((used)) with SUNWcc on MirBSD still won’t work…
@
text
@d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.376 2010/01/25 16:12:57 tg Exp $");
d1627 2
a1628 1
struct tbl *typeset(const char *, Tflag, Tflag, int, int);
@


1.376
log
@when using persistent history (and not MKSH_SMALL), let the shells
concurrently accessing the same $HISTFILE be more synchronised with
each other: empty lines (just pressing Return) and duplicates (that
are split and written twice by the lines loaded from $HISTFILE in
the meantime); requested by Maximilian “mxey” Gaß in #!/bin/mksh
@
text
@d126 3
a128 1
#if (defined(MirBSD) && (MirBSD >= 0x09A1))
d153 1
a153 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.375 2010/01/25 14:38:03 tg Exp $");
@


1.375
log
@remove some debugging code
@
text
@d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.374 2010/01/16 19:08:05 tg Exp $");
d1435 3
d1447 1
a1447 1
char **hist_get_newest(int);
@


1.374
log
@RCSID sync (oksh bumped their array limit again… wonder when………)
@
text
@d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.373 2010/01/08 22:21:06 tg Exp $");
a865 3
#ifdef notyet_ktremove
	struct table *tablep;	/* table we're ktenter'd in */
#endif
a1540 1
void ktremove(struct tbl *);
@


1.373
log
@While we were supposed to use Ctrl-Arrowkey for wordwise jumping,
some idiotic terminal emulators and/or people seem to use the es-
cape codes normally denoting Alt-Arrowkey instead so let's simply
bind them to the vt_hack as well... (untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: sh.h,v 1.29 2005/12/11 18:53:51 deraadt Exp $	*/
d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.372 2010/01/01 17:44:10 tg Exp $");
@


1.372
log
@• re-implement wcswidth-like behaviour for ${%foo} even in !UTFMODE
• merge the rest of branch tg-wcswidth-behaviour
• enhance test cases for wcswidth-like behaviour
• switch hash table collision resolution algorithm to Python’s as announced
• bump vsn
@
text
@d12 1
a12 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.371 2009/12/31 14:05:44 tg Exp $");
d153 1
a153 1
#define MKSH_VERSION "R39 2010/01/01"
@


1.371
log
@jobs.c: apply patch from deraadt@@o:
│remember to restore errno (ie. stop someone from making a mistake later)
│ok guenther
check.t, sh.h: bump vsn

I wonder though why errno must be restored even if nothing was
called after reading it… moid?
@
text
@d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.370 2009/12/12 22:27:09 tg Exp $");
d153 1
a153 1
#define MKSH_VERSION "R39 2009/12/31"
@


1.370
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.369 2009/12/05 22:19:42 tg Exp $");
d153 1
a153 1
#define MKSH_VERSION "R39 2009/12/12"
@


1.369
log
@strchr related fixes
@
text
@a93 1
#if HAVE_ATTRIBUTE
d95 17
d113 1
a113 1
#define __attribute__(x)	/* nothing */
d115 2
a116 4
#undef __unused
#define __unused		__attribute__((unused))
#if HAVE_ATTRIBUTE_BOUNDED
#define __bound_att__(x)	__attribute__(x)
d118 1
a118 1
#define __bound_att__(x)	/* nothing */
d121 1
a121 1
#define __attribute____used__	__attribute__((used))
d123 1
a123 1
#define __attribute____used__	/* nothing */
d144 1
a144 1
	    __attribute____used__ = "@@(""#)" #prefix ": " string
d151 1
a151 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.368 2009/12/05 17:43:49 tg Exp $");
d153 1
a153 1
#define MKSH_VERSION "R39 2009/12/05"
d280 1
a280 1
    __bound_att__((bounded (string, 1, 2)));
d1486 2
a1487 2
    __attribute__((noreturn))
    __attribute__((format (printf, 1, 2)));
d1496 1
a1496 2
void unwind(int)
    __attribute__((noreturn));
d1502 2
a1503 2
    __attribute__((noreturn))
    __attribute__((format (printf, 1, 2)));
d1505 1
a1505 1
    __attribute__((format (printf, 2, 3)));
d1507 1
a1507 1
    __attribute__((format (printf, 1, 2)));
d1511 1
a1511 1
    __attribute__((format (printf, 1, 0)));
d1513 2
a1514 2
    __attribute__((noreturn))
    __attribute__((format (printf, 1, 2)));
d1516 1
a1516 1
    __attribute__((format (printf, 1, 2)));
d1519 1
a1519 1
    __attribute__((format (printf, 1, 2)));
d1521 1
a1521 1
    __attribute__((format (printf, 1, 2)));
d1569 1
a1569 1
    __bound_att__((bounded (buffer, 2, 3)));
d1597 1
a1597 1
    __attribute__((format (printf, 2, 3)));
d1599 2
a1600 2
    __attribute__((format (printf, 3, 4)))
    __bound_att__((bounded (string, 1, 2)));
d1602 1
a1602 1
    __attribute__((format (printf, 1, 2)));
d1604 1
a1604 1
    __attribute__((format (printf, 2, 0)));
@


1.368
log
@llvm/clang scan-build is now content…
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.367 2009/12/01 19:15:34 tg Exp $");
d395 1
@


1.367
log
@* fix 'set -A foo -- [2]=a b c' contingency (tested against GNU bash4,
  which, in its latest sid incarnation, even received mksh's ability
  to produce ${!foo[*]} array keys, wow!)
* plug a memory leak while here (ATEMP only, but still)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.366 2009/11/29 17:37:22 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/12/01"
d413 1
d419 1
d1540 1
a1540 1
int parse_args(const char **, int, int *);
@


1.366
log
@this better be const, too
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.365 2009/11/28 15:38:30 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/11/28"
@


1.365
log
@fix 'mksh -U -i' and 'mksh +U -i'
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.364 2009/11/28 14:28:02 tg Exp $");
d270 1
a270 1
extern uint32_t arc4random_pushb(void *, size_t);
@


1.364
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.362 2009/11/22 14:25:18 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/11/22"
@


1.363
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d1364 1
a1364 1
int utf_mbswidth(const char *, bool);
@


1.362
log
@bump vsn
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.361 2009/11/21 23:23:20 tg Exp $");
d1364 1
a1364 1
int utf_mbswidth(const char *);
@


1.362.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.363 2009/11/28 14:21:45 tg Exp $");
d1364 1
a1364 1
int utf_mbswidth(const char *, bool);
@


1.361
log
@since we have wcwidth anyway, expose it as ${%strvar} to the user, iff
utf8-mode is enabled (otherwise it'll be a synonym for ${#strvar} aka
the number of octets in it)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.360 2009/11/09 23:35:11 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/11/21"
@


1.360
log
@make print_columns() aware that octets≠characters≠columns
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.359 2009/10/30 00:57:38 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/11/09"
@


1.359
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.358 2009/10/27 17:00:02 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/30"
d1355 2
a1356 2
int pr_menu(const char *const *);
int pr_list(char *const *);
d1549 2
a1550 2
    char *(*)(const void *, int, char *, int),
    const void *, int, int prefcol);
@


1.358
log
@do not use PATH_MAX on GNU/Hurd (even if it *was* defined), but use
some glibc-only functions that don’t require its use instead

tested on gnubber, where (admittedly) sysconf(_PC_PATH_MAX) == 1024…
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.357 2009/10/18 12:30:05 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/27"
d680 1
a680 1
#define C_QUOTE	 BIT(6)		/* \t \n"#$&'()*;<>?[]\`| (needing quoting) */
@


1.357
log
@• better IV for the oaathash-on-binary (as if we prepended a '\x01')
• better variable name for the LCG state
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.356 2009/10/17 21:16:04 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/18"
d214 3
d220 1
a350 3
#ifndef PATH_MAX
#define PATH_MAX	1024	/* pathname size */
#endif
@


1.356
log
@• overhaul handling of special variables
• use a combination of the one-at-a-time hash and an LCG for handling
  the $RANDOM special if !HAVE_ARC4RANDOM instead of rand(3)/srand(3)
  and get rid of time(3) usage to reduce import footprint
• raise entropy state (mostly in the !HAVE_ARC4RANDOM case though…)
• simplify handling of the $RANDOM_SPECIAL generally
• tweak hash() to save a temp var for non-optimising compilers
• some int → mksh_ari_t and other type fixes
• general tweaking of code and comments
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.355 2009/10/15 16:36:27 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/17"
@


1.355
log
@fix exit-eval-1 (Debian #550717), sync SUSv4 wording, improve comments
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.354 2009/10/10 21:17:31 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/15"
d351 19
a369 7
EXTERN const char *kshname;	/* $0 */
EXTERN pid_t kshpid;		/* $$, shell pid */
EXTERN pid_t procpid;		/* pid of executing process */
EXTERN pid_t kshpgrp;		/* process group of shell */
EXTERN uid_t ksheuid;		/* effective uid of shell */
EXTERN int exstat;		/* exit status */
EXTERN int subst_exstat;	/* exit status of last $(..)/`..` */
d750 2
a751 2
EXTERN int x_cols I__(80);	/* tty columns */
EXTERN int x_lins I__(-1);	/* tty lines */
d1520 2
a1521 1
uint32_t hash(const char *);
d1617 1
a1617 1
void change_random(unsigned long);
@


1.354
log
@while testing haserl-0.9.26 on MirBSD, I discovered that the echo builtin
in FSH mode did in fact, contrary to POSIX and Debian Policy 10.4 behavi-
our (I think), interpret escape sequences; fix and add testsuite for echo
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.353 2009/10/04 13:19:33 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/10"
@


1.353
log
@fix lazy evaluation of assignments in ternary ops
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.352 2009/10/02 18:08:36 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/04"
@


1.352
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.351 2009/09/29 12:28:13 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/10/02"
@


1.351
log
@SUSv4 says that there be exit 127; the old code tried but failed, so it
was an actual programmatical bug…
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.350 2009/09/26 04:01:33 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/29"
@


1.350
log
@* move the utf_* functions to a smaller file, to reduce the pain the
  CPU has to endure while gcc is crunching on edit.c
* comment on mksh not using _exactly_ OPTU-8/OPTU-16 (XXX)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.349 2009/09/26 03:40:01 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/25"
@


1.349
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.348 2009/09/24 17:15:32 tg Exp $");
a1323 7
/* UTF-8 stuff */
size_t utf_mbtowc(unsigned int *, const char *);
size_t utf_wctomb(char *, unsigned int);
int utf_widthadj(const char *, const char **);
int utf_mbswidth(const char *);
const char *utf_skipcols(const char *, int);
size_t utf_ptradj(const char *);
d1347 8
@


1.348
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.347 2009/09/23 18:04:57 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/24"
d570 5
a574 2
#define fc_e_	(r_fc_e_ + 2)		/* "fc -e -" */
#define fc_e_n	7			/* strlen(fc_e_) */
a968 15
/* var spec values */
#define V_NONE		0
#define V_COLUMNS	1
#define V_HISTFILE	2
#define V_HISTSIZE	3
#define V_IFS		4
#define V_LINENO	5
#define V_LINES		6
#define V_OPTIND	7
#define V_PATH		8
#define V_RANDOM	9
#define V_SECONDS	10
#define V_TMOUT		11
#define V_TMPDIR	12

a1591 1
mksh_ari_t intval(struct tbl *);
a1594 1
int getint(struct tbl *, mksh_ari_t *, bool);
d1602 1
a1602 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
@


1.347
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.346 2009/09/20 17:23:52 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/23"
d454 1
a454 1
#define MKSH_CONSERVATIVE_FDS
d457 1
a457 1
#define MKSH_NOPWNAM
d459 2
a460 2
#ifndef MKSH_NOVI
#define MKSH_NOVI
d464 4
@


1.346
log
@Add a hack input function for VT100-style key sequences; support
Ctrl-CurLeft and Ctrl-CurRight (not quite ANSI, but fits the scheme)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.345 2009/09/20 16:40:57 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/20"
a1331 1
int x_bind(const char *, const char *, bool, bool);
d1516 1
@


1.345
log
@more of this:

• shell flags are now handled in one single place (sh_flags.h)
• sync comments (between enum and array) and manpage with reality
• FMONITOR is now no longer needed for Hartz IV shells
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.344 2009/09/20 13:08:11 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/19"
@


1.344
log
@only one digits instance, thank you very much
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.343 2009/09/19 21:54:46 tg Exp $");
d551 2
a552 43
	FEXPORT = 0,	/* -a: export all */
#if HAVE_ARC4RANDOM
	FARC4RANDOM,	/* use 0:rand(3) 1:arc4random(3) 2:switch on write */
#endif
	FBRACEEXPAND,	/* enable {} globbing */
#if HAVE_NICE
	FBGNICE,	/* bgnice */
#endif
	FCOMMAND,	/* -c: (invocation) execute specified command */
	FEMACS,		/* emacs command editing */
	FERREXIT,	/* -e: quit on error */
	FGMACS,		/* gmacs command editing */
	FIGNOREEOF,	/* eof does not exit */
	FTALKING,	/* -i: interactive */
	FKEYWORD,	/* -k: name=value anywhere */
	FLOGIN,		/* -l: a login shell */
	FMARKDIRS,	/* mark dirs with / in file name completion */
	FMONITOR,	/* -m: job control monitoring */
	FNOCLOBBER,	/* -C: don't overwrite existing files */
	FNOEXEC,	/* -n: don't execute any commands */
	FNOGLOB,	/* -f: don't do file globbing */
	FNOHUP,		/* -H: don't kill running jobs when login shell exits */
	FNOLOG,		/* don't save functions in history (ignored) */
#ifndef MKSH_UNEMPLOYED
	FNOTIFY,	/* -b: asynchronous job completion notification */
#endif
	FNOUNSET,	/* -u: using an unset var is an error */
	FPHYSICAL,	/* -o physical: don't do logical cds/pwds */
	FPOSIX,		/* -o posix (try to be more compatible) */
	FPRIVILEGED,	/* -p: use suid_profile */
	FRESTRICTED,	/* -r: restricted shell */
	FSTDIN,		/* -s: (invocation) parse stdin */
	FTRACKALL,	/* -h: create tracked aliases for all commands */
	FUTFMODE,	/* -U: enable utf-8 processing */
	FVERBOSE,	/* -v: echo input */
#ifndef MKSH_NOVI
	FVI,		/* vi command editing */
	FVIRAW,		/* always read in raw mode (ignored) */
	FVITABCOMPLETE,	/* enable tab as file name completion char */
	FVIESCCOMPLETE,	/* enable ESC as file name completion in command mode */
#endif
	FXTRACE,	/* -x: execution trace */
	FTALKING_I,	/* (internal): initial shell was interactive */
d557 1
a557 1
#define UTFMODE	Flag(FUTFMODE)
@


1.343
log
@$'…' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.342 2009/09/19 19:08:48 tg Exp $");
d362 3
@


1.342
log
@align with C standard (optional C style); document differences to C style
for print builtin (align with ksh93 ipv GNU bash)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.341 2009/09/19 15:16:05 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/07"
d1342 4
d1594 1
a1594 1
int unbksl(const char **, bool);
@


1.341
log
@new function unbksl doing "backslash expansion" independent of c_print();
also make a separate subsection about it in the manpage
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.340 2009/09/07 17:24:49 tg Exp $");
d1590 1
a1590 1
int unbksl(const char **);
@


1.340
log
@another ksh93 feature: test -o ?foo (almost zero cost)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.339 2009/09/06 17:55:55 tg Exp $");
d1590 1
@


1.339
log
@Support Dave Korn’s alternative 「'a'」 (or 「'…'」) form for base-one
integers in addition to my 「1#a」 (or 「1#…」), which also allows for
finer end-of-character checking. Note that this is locale-dependent in
ksh93, set ±U dependent in mksh, and mksh’s OPTU-16 encoding is used.
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.338 2009/09/06 17:42:14 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/09/06"
@


1.338
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.336.2.1 2009/08/30 20:56:09 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/08/30"
@


1.337
log
@add the chdir builtin from mircvs://contrib/hosted/tg/deb/mksh/ for
better dash compatibility (mksh is now a dash superset if printf is
compiled in)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.336 2009/08/30 13:30:08 tg Exp $");
d909 1
d923 3
@


1.336
log
@replace pdksh’s get_phys_path() and do_phys_path() with my new
do_realpath() function – looking fine, review welcome though
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.335 2009/08/30 13:22:39 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/08/28"
@


1.336.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic “typeset -n v=$1” or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.336 2009/08/30 13:30:08 tg Exp $");
a908 1
#define ASSOC		BIT(26) /* ARRAY ? associative : reference */
a921 3
#define arrayindex(vp)	((unsigned long)((vp)->flag & AINDEX ? \
			    (vp)->ua.index : 0))

@


1.335
log
@add a do_realpath() implementation replacing the use of the external
libc function realpath(3) which may not be available on the target
system; compile the realpath builtin unconditionally

looks fine to me, but review is appreciated; this is (very) lightly
based upon MirBSD libc’s realpath(3) and pdksh’s get_phys_path()
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.334 2009/08/28 22:46:21 tg Exp $");
a1580 1
char *get_phys_path(const char *);
@


1.334
log
@documentation and test suite for tonight’s new features, ☾ gn8
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.333 2009/08/28 22:23:34 tg Exp $");
a1436 1
#if HAVE_REALPATH
a1437 1
#endif
@


1.333
log
@fix type (array indices should be of the unsigned arithmetic type)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.332 2009/08/28 21:07:27 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/08/08"
@


1.332
log
@optimise
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.330 2009/08/28 21:01:26 tg Exp $");
d1650 1
a1650 1
uint32_t set_array(const char *, bool, const char **);
@


1.331
log
@more int→bool
@
text
@d1650 1
a1650 1
void set_array(const char *, bool, const char **);
@


1.330
log
@… but since I liked the bonus of having the hval stored so much, merge
it with the array index; var.c says that
│ 1244         /* The table entry is always [0] */
so that we can have a special flag and a union which stores hval for
the table index, the array index otherwise (coïncidentally *hint hint*
they have the same size)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.329 2009/08/28 20:38:42 tg Exp $");
d1650 1
a1650 1
void set_array(const char *, int, const char **);
@


1.329
log
@for now, until we really use kt*() otherwise, ifdef out tablep/hval
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.326 2009/08/28 19:16:16 tg Exp $");
d877 4
a880 4
#ifdef notyet_ktremove
	uint32_t hval;		/* hash(name) */
#endif
	uint32_t index;		/* index for an array */
d908 1
@


1.328
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d867 1
d869 1
d877 1
d879 1
d1551 2
a1552 1
void ktdelete(struct tbl *);
@


1.327
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@a853 5
struct table_entry {
	struct table *tp;	/* table this entry is in */
	struct tbl **ep;	/* entry pointer (&tp->tbls[i]) */
};

d867 1
d875 1
d1376 1
a1376 1
struct tbl *findfunc(const char *, uint32_t, bool, struct table_entry *);
d1545 3
a1547 3
struct tbl *ktsearch(struct table *, const char *, uint32_t, struct table_entry *);
struct tbl *ktenter(struct table *, const char *, uint32_t, struct table_entry *);
void ktremove(struct table_entry *);
@


1.326
log
@another int→bool
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.325 2009/08/28 18:59:01 tg Exp $");
d854 5
d1379 1
a1379 1
struct tbl *findfunc(const char *, uint32_t, bool);
d1548 3
a1550 3
struct tbl *ktsearch(struct table *, const char *, uint32_t);
struct tbl *ktenter(struct table *, const char *, uint32_t);
#define ktdelete(p)	do { p->flag = 0; } while (/* CONSTCOND */ 0)
@


1.325
log
@this wants a size_t (but ssize_t is enough, since order(size_t) elements
is pretty much impossible… I estimate at most a million, but not more
than 16 million, array or keytab entries)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.324 2009/08/28 18:53:59 tg Exp $");
d1374 1
a1374 1
struct tbl *findfunc(const char *, uint32_t, int);
@


1.324
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.323 2009/08/28 18:33:05 tg Exp $");
d971 1
a971 1
	int left;
@


1.323
log
@shuffle fields of struct tbl around for better padding results
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.322 2009/08/08 13:08:52 tg Exp $");
d1374 1
a1374 1
struct tbl *findfunc(const char *, unsigned int, int);
d1541 4
a1544 4
unsigned int hash(const char *);
void ktinit(struct table *, Area *, int);
struct tbl *ktsearch(struct table *, const char *, unsigned int);
struct tbl *ktenter(struct table *, const char *, unsigned int);
@


1.322
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.321 2009/08/01 20:32:45 tg Rel $");
a854 3
	Tflag flag;		/* flags */
	int type;		/* command type (see below), base (if INTEGER),
				 * or offset from val.s of value (if EXPORT) */
d863 4
a866 1
	uint32_t index;		/* index for an array */
d871 4
a874 4
	union {
		struct tbl *array;	/* array values */
		const char *fpath;	/* temporary path to undef function */
	} u;
d895 1
a895 1
#define UCASEV_AL	BIT(18)/* convert to upper case / autoload function */
@


1.321
log
@more use of memcpy(3) when we know destination and source sizes
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.320 2009/08/01 20:29:25 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/08/01"
d597 1
a597 1
EXTERN char shell_flags[FNFLAGS];
d1554 1
a1554 1
void change_flag(enum sh_flag, int, char);
@


1.320
log
@if duplicating strings, it’s idiotic to use strlcpy(3) when we know
the sizes (checked)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.319 2009/08/01 14:21:30 tg Exp $");
d425 2
a426 2
		size_t strdup_len = strlen(strdup_src);			\
		strdup_dst = alloc(strdup_len + 1, (ap));		\
a427 1
		strdup_dst[strdup_len] = '\0';				\
d436 4
a439 4
		size_t strdup_len = (n);				\
		strdup_dst = alloc(strdup_len + 1, (ap));		\
		memcpy(strdup_dst, strdup_src, strdup_len);		\
		strdup_dst[strdup_len] = '\0';				\
@


1.319
log
@bump version and rebuild+check on MirBSD
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.318 2009/07/30 19:11:12 tg Exp $");
d425 4
a428 3
		size_t strdup_len = strlen(strdup_src) + 1;		\
		strdup_dst = alloc(strdup_len, (ap));			\
		strlcpy(strdup_dst, strdup_src, strdup_len);		\
d437 4
a440 3
		size_t strdup_len = (n) + 1;				\
		strdup_dst = alloc(strdup_len, (ap));			\
		strlcpy(strdup_dst, strdup_src, strdup_len);		\
@


1.318
log
@"official" but unsupported printf-as-builtin code, cleaner API than
in the branch; USE_PRINTF_BUILTIN=1 to enable it (Build.sh + Makefile)
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.317 2009/07/30 18:42:31 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/07/30"
@


1.317
log
@* add __COPYRIGHT
* if MirBSD is recent enough, use OS' RCSID macros
@
text
@d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.316 2009/07/25 21:31:27 tg Exp $");
d139 1
a139 1
#define MKSH_VERSION "R39 2009/07/25"
d1390 3
@


1.316
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d112 8
d123 1
d131 4
a134 2
#define __RCSID(x)	__IDSTRING(rcsid,x)
#define __SCCSID(x)	__IDSTRING(sccsid,x)
d137 1
a137 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.315 2009/07/25 20:26:33 tg Exp $");
@


1.315
log
@improve MKSH_NOPWNAM handling, whether MKSH_SMALL or not; it will cause
the entire ~fac/ expansion code to be omitted
@
text
@d32 1
d126 1
a126 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.313 2009/07/16 15:06:45 tg Exp $");
d128 1
a128 1
#define MKSH_VERSION "R39 2009/07/16"
d228 1
d276 1
d293 1
d319 1
a319 1
#ifdef MKSH_CONSERVATIVE_FDS)
d438 3
@


1.314
log
@simplify MKSH_SMALL => MKSH_CONSERVATIVE_FDS handling
@
text
@d433 5
a437 1
#if defined(MKSH_SMALL) && !defined(MKSH_NOVI)
d440 1
d959 1
a959 1
#ifndef MKSH_SMALL
@


1.313
log
@ABI bump to R39: adhere to the future POSIX standard regarding -o nounset;
add appropriate regression test (except $_ *is* unset in non-interactive
shells). See the thread at:
http://article.gmane.org/gmane.os.miros.general/8863
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.312 2009/07/06 15:06:25 tg Exp $");
d315 1
a315 1
#if defined(MKSH_SMALL) || defined(MKSH_CONSERVATIVE_FDS)
@


1.312
log
@be more robust against things like Debian #535970
reverts and rewrites the code from cid 10047C1EBA57E4F4AF0

XXX find out if this is done right
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.311 2009/07/05 13:56:48 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/07/06"
@


1.311
log
@another fix from oksh for Vi Mode word erase handling, appears to unbreak
more from cid 1004A2D72DD5A4E4B4F tried to be fixed in 1004A300A72701188E3
but I’d appreciate someone who actually uses Vi Mode to test it:

   Revision 1.26: [7]download - view: [8]text, [9]markup, [10]annotated - [11]select for diffs
   Mon Jun 29 22:50:19 2009 UTC (5 days, 14 hours ago) by martynas
   Branches: [12]MAIN
   CVS tags: [13]OPENBSD_4_6_BASE, [14]OPENBSD_4_6, [15]HEAD
   Diff to: previous 1.25: [16]preferred, [17]coloured
   Changes since revision 1.25: +10 -5 lines
make VSEARCH werase act like regular werase after the last change.
vi back-words and emacs kill-region are not completely the same.
ok merdely@@, millert@@.  "Get it in" Darrin Chandler
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.310 2009/06/10 18:12:48 tg Rel $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/07/05"
@


1.310
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.309 2009/06/10 18:11:27 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/06/10"
@


1.309
log
@Save another couple of bytes in the !ulimit case
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.308 2009/06/08 20:34:40 tg Exp $");
d670 1
a670 1
#define C_LEX1	 BIT(2)		/* \0 \t\n|&;<>() */
d674 1
a674 1
#define C_QUOTE	 BIT(6)		/*  \n\t"#$&'()*;<>?[]\`| (needing quoting) */
d888 2
a889 2
#define USERATTRIB	(EXPORT|INTEGER|RDONLY|LJUST|RJUST|ZEROFIL\
			    |LCASEV|UCASEV_AL|INT_U|INT_L)
d1218 4
a1221 4
		const char **strv; /* string [] */
		struct shf *shf;   /* shell file */
		struct tbl *tblp;  /* alias (SF_HASALIAS) */
		char *freeme;	   /* also for SREREAD */
@


1.308
log
@• Check if killpg(3) is available; if not, use kill(2) with negative
  process ID and hope it works (is POSIXly killpg-endowed)
• bump version
• sync clog
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.307 2009/06/08 20:06:48 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/06/08"
@


1.307
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.306 2009/06/07 22:28:05 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/06/07"
@


1.306
log
@new feature: -DMKSH_ASSUME_UTF8=0 assumes utf-8 is *not* set and skips
environment inspection; useful for initrd and the likes
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.305 2009/05/31 15:10:07 tg Exp $");
d304 1
a304 1
#define NELEM(a)	(sizeof (a) / sizeof ((a)[0]))
d448 1
a448 1
#define ALLOC_SIZE	(sizeof (ALLOC_ITEM))
d1190 1
a1190 1
	vp__ = alloc((n) * sizeof (void *), ATEMP);		\
d1199 1
a1199 1
		    n * 2 * sizeof (void *), ATEMP);		\
d1208 1
a1208 1
#define XPclose(x)	aresize((x).beg, XPsize(x) * sizeof (void *), ATEMP)
@


1.305
log
@fix bug exhibited by t0000-basic.sh introduced in R38 shortly before the
release: sometimes, a “cd -P” would cause memory corruption because lalloc
internal data was overwritten due to accidentally losing a “continue;”
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.304 2009/05/27 19:52:38 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/05/31"
@


1.304
log
@implement an extension that an interactive mode input line, when
starting with an ‘!’ exclamation mark at the beginning of a com-
mand (PS1 not PS2), shall have the same effect as the predefined
“r” alias, to be compatible with csh and GNU bash’s “!string” to
«Execute last used command starting with string» – documentation
and feature request provided by wbx@@ (Waldemar Brodkorb)
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.303 2009/05/27 09:58:23 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/05/27"
@


1.303
log
@• Build.sh, strlcpy.c: gcc-current conversion &c. warnings cleanup
• histrap.c, lex.c, misc.c: get average stack frame size to <= 768 bytes
• check.t, sh.h: bump version
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.302 2009/05/21 14:28:35 tg Exp $");
d579 3
@


1.302
log
@pgas mentioned ksh93 does [[ $foo ]] (ipv forced [[ -n $foo ]])
and it actually REDUCES code size to allow it as well; mention
in the manpage that it’s merely unportable (and of course exe-
cution time differs); sync clog
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.301 2009/05/20 10:10:02 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/05/21"
@


1.301
log
@commit Syllable-related improvement: simplify p_time
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.300 2009/05/16 21:00:52 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/05/19"
@


1.300
log
@laffer1 agreed they will need -DMKSH_MIDNIGHTBSD01ASH_COMPAT in the
short term, but only for /bin/sh – thus recommend to also define
-DMKSH_BINSHREDUCED and make it dependent on FPOSIX
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.297 2009/05/16 16:59:39 tg Exp $");
d127 1
a127 1
#define MKSH_VERSION "R38 2009/05/16"
@


1.299
log
@pcc cought a bad programming idiom I accidentally used
(without realising that it’s a macro expansion, that is)
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.298 2009/05/16 18:40:09 tg Exp $");
a335 6
#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
#define initvsn__add_1	" MidnightBSD-0.1-ash-compat"
#else
#define initvsn__add_1	""
#endif

d344 1
a344 2
EXTERN const char initvsn[] I__("KSH_VERSION=@@(#)MIRBSD KSH "
    MKSH_VERSION initvsn__add_1);
@


1.298
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.297 2009/05/16 16:59:39 tg Exp $");
d336 6
d351 1
a351 5
    MKSH_VERSION
#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
    "MidnightBSD-0.1-ash-compat"
#endif
    );
@


1.297
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.296 2009/05/16 15:53:02 tg Exp $");
d344 6
a349 1
EXTERN const char initvsn[] I__("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
@


1.296
log
@this began as a one-word change to the spec (manpage): that
${foo:1:2} operates on characters ipv bytes – which means:
‣ set +U: octets
‣ set -U: MirOS OPTU-8 characters

for consistency I also adapted ${#stringname} to deliver the
length in characters ipv bytes; more may follow; for example
I’d like a way to expose the string width.

you can already get the MirOS OPTU-16 of a character in the
WTF-8 (「set -U」) mode with something like
│ typeset -Uui16 -Z7 x=1#${stringname:position:1}
which will correctly use the PUA EF80‥EFFF mapping for octets.

due to this being an incompatible change, bump to R38

also change the unicode-hexdump sample regression test and
add two news for ${x:1:2} and ${#x} checks in A/W mode ☺
@
text
@d11 20
d125 1
a125 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.295 2009/05/16 15:09:07 tg Exp $");
@


1.295
log
@split utf_ptradjx into utf_ptradj function (to save space) and
self-assignment macro; remove some uses of the macro in favour
of foo += utf_ptradj(foo)
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.294 2009/05/16 14:19:23 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/05/16"
@


1.294
log
@Add search-history-up and search-history-down keybindings (both unbound
by default) to the Emacs command line editing mode; patch originally by
James Butler <sweetnavelorange@@gmail.com> but slightly modified

10x
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.293 2009/04/07 19:43:28 tg Exp $");
d373 1
a373 7
	size_t utf_ptradjx_len;						\
									\
	if (!UTFMODE ||							\
	    *(const unsigned char *)(src) < 0xC2 ||			\
	    (utf_ptradjx_len = utf_mbtowc(NULL, (src))) == (size_t)-1)	\
		utf_ptradjx_len = 1;					\
	(dst) = (src) + utf_ptradjx_len;				\
d1315 1
@


1.293
log
@"evil" workaround to the alignment issues: embed an ALLOC_ITEM into
struct env (other structures defined have no "foreign type with pos-
sible alignment constraints" members) and take care of it while dea-
ling in a struct env instance
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.292 2009/04/07 18:56:51 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/04/07"
@


1.292
log
@employ some "nice" constants and comment lalloc.c
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.290 2009/04/07 18:41:37 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/04/05"
d448 1
d450 1
a452 1
	struct env *oenv;	/* link to previous environment */
@


1.291
log
@globalise SIZE_MAX definition
@
text
@d426 3
a428 1
typedef struct lalloc {
d430 9
a438 1
} Area;
@


1.290
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.289 2009/04/06 08:33:37 tg Exp $");
d185 7
@


1.289
log
@decouple conservative file descriptor use from MKSH_SMALL, with the
new MKSH_CONSERVATIVE_FDS præprocessor flag, because Minix 3, for
example, needs it (otherwise “mksh Build.sh” fails)
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.288 2009/04/05 12:35:32 tg Exp $");
d557 1
a559 1
	char *name;
a574 1
	int signal;		/* signal number */
a577 2
	volatile sig_atomic_t set; /* trap pending */
	int flags;		/* TF_* */
d580 3
d666 1
a668 1
	const char	*optarg;
d682 1
d686 1
a687 2
	int njobs;	/* number of live jobs using output pipe */
	void *job;	/* 0 or job of co-process using input pipe */
d773 4
a777 1
	unsigned char *rp;	/* read: current position in buffer */
a779 1
	unsigned char *wp;	/* write: current position in buffer */
a781 1
	unsigned char *buf;	/* buffer */
a784 1
	Area *areap;		/* area shf/buf were allocated in */
d882 1
a883 1
	const char **argv;
d894 3
a896 2
	int argc;
	int flags;		/* see BF_* */
d900 2
a901 3
	char *error;		/* error handler */
	char *exit;		/* exit handler */
	struct block *next;	/* enclosing block */
d911 1
a912 1
	struct tbl **next;
a1180 1
	int	type;		/* input type */
d1188 2
a1191 1
	const char *file;	/* input file name */
d1194 1
a1195 1
	Source *next;		/* stacked source */
a1613 1
	int flags;		/* TEF_* */
d1623 1
@


1.288
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.287 2009/04/03 09:39:07 tg Exp $");
d288 1
a288 1
#ifdef MKSH_SMALL
@


1.287
log
@(experimental) implement getrusage via times if not found
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.286 2009/03/25 21:45:28 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/04/03"
d515 1
d517 1
d1338 1
d1340 1
d1405 1
a1405 1
void j_init(int);
d1407 1
d1409 1
d1415 1
d1417 1
@


1.286
log
@... and it did in fact require DEC ucode cc to spot this!
gcc, SUNWcc, pcc, llvm-gcc, clang, etc. all didn't say a thing!

now compiles warning-free (testsuite pass) on ULTRIX 4.5 (1986),
and OSF/1 X2.0-8 (testsuite norun: perl missing) has only the usual
bitchings about "volatile sig_atomic_t" because the latter part is
already volatile, but otherwise warning-free compile, works fine
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.285 2009/03/24 08:53:45 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/03/25"
d113 14
d233 4
@


1.285
log
@further simplify

XXX check whose platforms’ realloc(3) don’t take NULL
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.284 2009/03/22 18:50:43 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R37 2009/03/22"
d1292 1
a1292 1
int execute(struct op * volatile, volatile int, volatile int *);
@


1.284
log
@bump to R37; the ;& and ;;& are postponed indefinitively for now,
as I don't get to it and it's nontrivial
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.283 2009/03/22 18:28:35 tg Exp $");
d401 2
a402 2
typedef struct {
	void *ent;		/* entry pointer, must be first */
@


1.283
log
@sync; fold oksh-seterror test into errexit-*; use print not printf
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.282 2009/03/22 17:47:38 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/22"
@


1.282
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.281 2009/03/22 17:31:17 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/17"
@


1.281
log
@sync with oksh (nop)
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.31 2009/01/17 22:06:44 millert Exp $	*/
d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.280 2009/03/22 16:55:38 tg Exp $");
d1292 1
a1292 1
int execute(struct op * volatile, volatile int);
d1337 1
a1337 1
int timex(struct op *, int);
d1386 1
a1386 1
int exchild(struct op *, int, int);
@


1.280
log
@remove espie's double-linked-list based allocator and write a
similarily simple one from scratch, which however performs
better than espie's with AFREE_DEBUG enabled which took away
the benefit of the double-linked-list approach

all of (core) mksh is now MirOS licenced
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.30 2006/03/17 16:30:13 millert Exp $	*/
d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.279 2009/03/17 13:56:45 tg Exp $");
@


1.279
log
@another off-by-one, reported by «macaronyde:#!/bin/mksh»
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.278 2009/03/16 15:50:13 tg Exp $");
d399 1
a399 1
 * Area-based allocation built on malloc/free
d401 2
a402 2
typedef struct Area {
	struct link *freelist;	/* free list */
d1266 2
a1267 2
/* alloc.c */
Area *ainit(Area *);
d1269 2
a1270 1
void *alloc(size_t, Area *);	/* cannot fail */
@


1.278
log
@revert previous commit for now. testscript which breaks:

H4sIAAAAAAACA31TTUvDQBC951c804DtIQ0iiFhSPHiwiCDqzUpIuhO6JN2ETSS16n93Np+GFiGE
zM6bN2/fTPQOro5xENYuEVLzBz9eaF6RlWupSpyHaXqzVuvyljbbDCRV0UR7WeLiHEtT4D2GCcUy
pdNFh4pkg4wGZCV8Z6opTPOw3GI+swoq4ZIVZxqkSv0JqRAiWkBkmAJNegHIGG9vcAWcSnjM6dTo
uby8vsL7+wLllhQQKKr4SoFv/8nbXE5pQcdpk4nlwH6AE7zer17uVs/BmHVftnUdxYh0yHbV3ghY
9wh2rQlBkdMm8PmIe57Bjfs7dTW9X/OoEG6lwzwnzYKA7+8jHpsJTuFN4+IjKhKZM6dpZ0xuQ2Nz
7bGB1F74zlebmzTm/PS+OB0GZz4HLcPgz+BeDxyS9S7YU6e3qZaQk5gZgRHvQtI59Eet7QwBWFnL
O/F+ej9Fpmg0ug7OHrnqHy2+7y8x6DGEG3E0Az41RuPlYfXEEx0psrl8PAUebzf6ZklabgD8V3SS
Z7Vo6xfOuQS6gQMAAA==

「mksh -o posix z」 failed in that it continues; 「mksh z」 correctly aborts
let’s see what the obsd people have to say herefore
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.276 2009/03/15 16:13:40 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/15"
@


1.277
log
@bring back the backed-out Debian patch if FPOSIX; test programmes fixed:

H4sIAAAAAAACAz1PywrDIBA8m68YgoT20EN7TMixX1F6yGNFIWhRSw2h/95VmuDB2XmsY2oDRVyo
Si1N2uHlMzQK0b8JHaImy4RQwxIITYPiUs4xqcyeGgdfrfumtWX5dMbGSHy0WQgP1PJa49lhdpkV
ynncYSxkOjjxd/V83dmcX9sQtFGRi0zORmO5042HbwnMzlIBqa9lAmfLVBIZ7XqpKBPDnDu+WXpi
wMhnOgQXYvUD+oKHAhUBAAA=

XXX OpenBSD has something different which may DTST or even DTRT (not break
XXX our make(1) wrt <bsd.subdir.mk>), check that
@
text
@d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/16 ~test"
@


1.276
log
@sprinkle a few static and clean up the internal APIs
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.275 2009/03/14 18:12:54 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/15"
@


1.275
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.274 2009/02/22 18:02:31 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/03/14"
d1275 1
a1275 1
int x_bind(const char *, const char *, int, int);
a1280 1
int utf_wcwidth(unsigned int);
@


1.274
log
@when outputting in a row x column formatted way, but the available space
on the screen is not enough for two columns, just output the text line by
line, instead of trying to format it; gets rid of superfluous empty lines
if we did not even have space for one column on the screen (x_cols)

noticed by Gábor Gergely in irc, thanks!
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.273 2009/02/20 13:25:10 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/02/22"
d265 4
d782 2
a783 2
		long i;			/* integer */
		unsigned long u;	/* unsigned integer */
d1304 1
a1304 1
int evaluate(const char *, long *, int, bool);
d1535 1
a1535 1
long intval(struct tbl *);
d1538 2
a1539 2
void setint(struct tbl *, long);
int getint(struct tbl *, long *, bool);
@


1.273
log
@<sys/file.h> is only required for, and only contains, flock(2)
@
text
@d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.272 2008/12/29 21:34:21 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2009/02/20"
@


1.272
log
@always set COLUMNS and LINES; make use of the fact in dot.mkshrc
@
text
@a19 1
#include <sys/file.h>
d105 1
a105 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.271 2008/12/29 21:05:15 tg Exp $");
d107 1
a107 1
#define MKSH_VERSION "R36 2008/12/29"
@


1.271
log
@use a more common/generic routine for TIOCGWINSZ;
ensure x_cols and x_lins always have a sane value
after them (even if not tty_fd)
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.270 2008/12/29 20:53:48 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/12/17"
d909 12
a920 11
#define V_PATH		1
#define V_IFS		2
#define V_SECONDS	3
#define V_OPTIND	4
#define V_RANDOM	8
#define V_HISTSIZE	9
#define V_HISTFILE	10
#define V_COLUMNS	13
#define V_TMOUT		15
#define V_TMPDIR	16
#define V_LINENO	17
@


1.270
log
@new global x_lins (like x_cols), MIN_LINS (like MIN_COLS)
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.269 2008/12/29 20:47:16 tg Exp $");
d688 1
a688 1
EXTERN int x_lins I__(24);	/* tty lines */
d1546 1
@


1.269
log
@give tty_init() another argument for silent initialisation
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.268 2008/12/17 19:39:23 tg Exp $");
d686 3
a688 1
EXTERN int	x_cols I__(80);	/* tty columns */
@


1.268
log
@implement unsigned arithmetics as an mksh extension
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.267 2008/12/13 18:32:27 tg Exp $");
d1603 1
a1603 1
extern void tty_init(int);
@


1.267
log
@fix signedness issue wrecking havoc on 64 bit architectures, oops
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.266 2008/12/13 17:02:16 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/12/13"
d778 1
@


1.266
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.265 2008/12/04 18:11:08 tg Exp $");
d1092 1
a1092 1
	size_t more = ((xp) + (n)) - (xs).end;			\
@


1.265
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.264 2008/12/02 13:20:39 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/12/04"
d133 4
a136 1
#define timerclear(tvp) do { (tvp)->tv_sec = (tvp)->tv_usec = 0; } while (0)
d147 1
a147 1
	} while (0)
d158 1
a158 1
	} while (0)
d369 1
a369 1
		strdup_dst = alloc(1, strdup_len, (ap));		\
d380 1
a380 1
		strdup_dst = alloc(1, strdup_len, (ap));		\
d395 10
a404 3
typedef struct TArea *PArea;
EXTERN PArea APERM;			/* permanent object space */
#define ATEMP	e->areap
d410 1
a410 1
	PArea areap;		/* temporary allocation area */
d759 1
a759 1
	PArea areap;		/* area shf/buf were allocated in */
d765 1
a765 1
	PArea areap;		/* area to allocate entries */
d774 1
a774 1
	PArea areap;		/* area to allocate from */
d866 1
a866 1
	PArea areap;		/* area to allocate things */
d1070 1
a1070 1
	PArea areap;		/* area to allocate/free from */
d1079 1
a1079 1
	(xs).beg = alloc(1, (xs).len + X_EXTRA, (xs).areap);	\
d1081 1
a1081 1
} while (0)
d1085 1
a1085 1
} while (0)
d1092 1
a1092 1
	int more = ((xp) + (n)) - (xs).end;			\
d1095 1
a1095 1
} while (0)
d1104 2
a1105 2
#define Xclose(xs, xp)	aresize((void*)(xs).beg, 1, \
			    (size_t)((xp) - (xs).beg), (xs).areap)
d1109 5
a1113 5
#define Xnleft(xs, xp) ((xs).end - (xp))	/* may be less than 0 */
#define Xlength(xs, xp) ((xp) - (xs).beg)
#define Xsize(xs, xp) ((xs).end - (xs).beg)
#define Xsavepos(xs, xp) ((xp) - (xs).beg)
#define Xrestpos(xs, xp, n) ((xs).beg + (n))
d1128 1
a1128 1
	vp__ = alloc((n), sizeof (void *), ATEMP);		\
d1131 1
a1131 1
} while (0)
d1136 2
a1137 2
		(x).beg = aresize((void*)(x).beg,		\
		    n * 2, sizeof (void *), ATEMP);		\
d1142 1
a1142 1
} while (0)
d1146 1
a1146 4

#define XPclose(x)	aresize((void*)(x).beg, \
			    XPsize(x), sizeof (void *), ATEMP)

d1166 1
a1166 1
	PArea	areap;
d1260 5
a1264 11
#ifdef AALLOC_STATS
#define AALLOC_STRINGIFY(x) __STRING(x)
#define anew(hint)	anewEx((hint), __FILE__ ":" AALLOC_STRINGIFY(__LINE__))
PArea anewEx(size_t, const char *);	/* cannot fail */
#else
PArea anew(size_t);			/* cannot fail */
#endif
void adelete(PArea *);
void *alloc(size_t, size_t, PArea);	/* cannot fail */
void *aresize(void *, size_t, size_t, PArea);
void afree(void *, PArea);		/* can take NULL */
d1395 1
a1395 1
Source *pushs(int, PArea);
d1444 1
a1444 1
struct temp *maketemp(PArea, Temp_type, struct temp **);
d1446 1
a1446 1
void ktinit(struct table *, PArea, int);
d1449 1
a1449 1
#define ktdelete(p)	do { p->flag = 0; } while (0)
d1482 2
a1483 2
char *strdup_(const char *, PArea);
char *strndup_(const char *, size_t, PArea);
d1516 2
a1517 2
struct op *tcopy(struct op *, PArea);
char *wdcopy(const char *, PArea);
d1520 1
a1520 1
void tfree(struct op *, PArea);
@


1.264
log
@* sh.h: note that file descriptors SHALL be <100
* syn.c: fix bashiop-4 regression test; failed due to me using a
  simple string when a wdstring was expected, sorry; the new code
  assumes file descriptors take up a maximum of two characters
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.263 2008/12/02 12:39:38 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/12/02"
d344 1
a344 1
	if (!Flag(FUTFHACK) ||						\
d492 1
a492 1
	FUTFHACK,	/* -U: utf-8 hack for command line editing */
d506 1
d1268 1
a1268 1
/* UTF-8 hack stuff */
@


1.263
log
@Alias expansion has a recursion check which tries to break the cycle if
encountered. However, when reading end of input, the source type is set
to SEOF while popping, whereas the recursion check code only checks for
an SALIAS type.

Fix: add a new SF_HASALIAS flag; change u.tblp from being valid if type
is SALIAS to being valid if SF_HASALIAS is set; set SF_HASALIAS for the
created SALIAS sources; set SF_HASALIAS and u.tblp when creating SALIAS
whose next is SEOF on the SEOF source as well.

Reported by Michael Hlavinka as Redhat Bug #474115
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.262 2008/11/30 10:33:39 tg Exp $");
d263 1
@


1.262
log
@if MKSH_SMALL and HAVE_ARC4RANDOM, there is no need to use rand()/srand(3)
ever, since MKSH_SMALL is not required to be as close to compatibility as
normal/generic shells; we can also get rid of time(3) calls
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.261 2008/11/15 08:52:01 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/30"
d1150 1
a1150 1
		struct tbl *tblp;  /* alias (SALIAS) */
d1181 1
@


1.261
log
@meet AALLOC_STATS
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.260 2008/11/15 08:42:36 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/11"
d1536 1
d1538 1
@


1.261.2.1
log
@beginnings
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.261 2008/11/15 08:52:01 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/11 aalloc-experimental-branch"
@


1.261.2.2
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.261.2.1 2008/11/19 21:08:26 tg Exp $");
a247 7
/* include "galloc.h" */
#ifndef GALLOC_H
#define GALLOC_H
#include "galloc.c"
#undef GALLOC_H
#endif

d365 2
a366 2
		strdup_dst = galloc(1, strdup_len, (ap));		\
		memcpy(strdup_dst, strdup_src, strdup_len);		\
d375 3
a377 4
		size_t strdup_len = (n);				\
		strdup_dst = galloc(1, strdup_len + 1, (ap));		\
		memcpy(strdup_dst, strdup_src, strdup_len);		\
		strdup_dst[strdup_len] = '\0';				\
d391 3
a393 3
EXTERN TGroup aperm;			/* permanent object space */
#define APERM	&aperm
#define ATEMP	e->gp_env
d399 1
a399 1
	PGroup gp_env;		/* temporary allocation area */
d747 1
a747 1
	PGroup gp_shf;		/* area shf/buf were allocated in */
d753 1
a753 1
	PGroup gp_table;	/* area to allocate entries */
d762 1
a762 1
	PGroup gp_tbl;		/* area to allocate from */
d854 1
a854 1
	PGroup gp_block;	/* area to allocate things */
d1058 1
a1058 1
	PGroup gp_XS;		/* area to allocate/free from */
d1066 2
a1067 2
	(xs).gp_XS = (area);					\
	(xs).beg = galloc(1, (xs).len + X_EXTRA, (xs).gp_XS);	\
d1089 1
a1089 1
#define Xfree(xs, xp)	gfree((xs).beg, (xs).gp_XS)
d1092 2
a1093 2
#define Xclose(xs, xp)	grealloc((xs).beg, 1, Xlength((xs), (xp)), (xs).gp_XS)

d1116 1
a1116 1
	vp__ = galloc((n), sizeof (void *), ATEMP);		\
d1124 2
a1125 2
		(x).beg = grealloc((x).beg, n * 2,		\
		    sizeof (void *), ATEMP);			\
d1135 2
a1136 1
#define XPclose(x)	grealloc((x).beg, XPsize(x), sizeof (void *), ATEMP)
d1138 1
a1138 1
#define XPfree(x)	gfree((x).beg, ATEMP)
d1157 1
a1157 1
	PGroup	gp_source;
d1249 12
d1391 1
a1391 1
Source *pushs(int, PGroup);
d1440 1
a1440 1
struct temp *maketemp(PGroup, Temp_type, struct temp **);
d1442 1
a1442 1
void ktinit(struct table *, PGroup, int);
d1478 2
a1479 2
char *strdup_(const char *, PGroup);
char *strndup_(const char *, size_t, PGroup);
d1512 2
a1513 2
struct op *tcopy(struct op *, PGroup);
char *wdcopy(const char *, PGroup);
d1516 1
a1516 1
void tfree(struct op *, PGroup);
@


1.260
log
@globalise internal_verrorf()
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.259 2008/11/15 08:03:24 tg Exp $");
d1251 2
a1252 1
#define anew(hint)	anewEx((hint), __FILE__ ":" __LINE__ ":" #hint)
@


1.259
log
@introduce AALLOC_STATS, which somewhat breaks the encapsulation for need
of a friendly name
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.258 2008/11/15 07:35:24 tg Exp $");
d1413 2
@


1.258
log
@enable passing of a hint how many pointers we’ll need to anew()
if 0, the default is used
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.257 2008/11/12 04:55:19 tg Exp $");
d1250 4
d1255 1
@


1.257
log
@prepare for aalloc.c, which I have just written myself, as an area-based
allocator using malloc and free, with mmap malloc and omalloc in mind,
not counterfeiting its security measures such as guard pages, and having
some of our own, e.g. XOR random cookies, optional mprotect, etc.

zero cost (for we have arc4random())
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.256 2008/11/12 00:55:32 tg Exp $");
d1250 1
a1250 1
PArea anew(void);			/* cannot fail */
@


1.256
log
@get rid of tempting sizeofN macro
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.255 2008/11/12 00:54:50 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/10"
@


1.255
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.254 2008/11/12 00:27:56 tg Exp $");
a257 1
#define sizeofN(typ, n)	(sizeof (typ) * (n))
@


1.254
log
@isolate all knowledge of the area-based allocator from the rest of the code

cost: bss -= (0, 0, 16, 16); text += (520, 504, 516, 480)
[ gcc,pcc X full,small ]
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.253 2008/11/11 23:50:30 tg Exp $");
d366 1
a366 1
		strdup_dst = alloc(strdup_len, (ap));			\
d377 1
a377 1
		strdup_dst = alloc(strdup_len, (ap));			\
d1068 1
a1068 1
	(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap);	\
d1090 1
a1090 1
#define Xfree(xs, xp)	afree((void*)(xs).beg, (xs).areap)
d1093 1
a1093 1
#define Xclose(xs, xp)	(char*)aresize((void*)(xs).beg, \
d1117 1
a1117 1
	vp__ = (void**)alloc(sizeofN(void*, (n)), ATEMP);	\
d1124 3
a1126 3
		int n = XPsize(x);				\
		(x).beg = (void**) aresize((void*) (x).beg,	\
		    sizeofN(void *, n * 2), ATEMP);		\
d1136 2
a1137 2
#define XPclose(x)	(void**)aresize((void*)(x).beg, \
			    sizeofN(void *, XPsize(x)), ATEMP)
d1139 1
a1139 1
#define XPfree(x)	afree((void *)(x).beg, ATEMP)
d1251 1
a1251 1
PArea anew(void);		/* cannot fail */
d1253 3
a1255 3
void *alloc(size_t, PArea);	/* cannot fail */
void *aresize(void *, size_t, PArea);
void afree(void *, PArea);	/* can take NULL */
@


1.253
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.252 2008/11/10 19:33:08 tg Exp $");
a391 3
struct TArea {
	struct link *freelist;	/* free list */
};
d393 2
a394 4

extern struct TArea aperm;		/* permanent object space */
#define APERM	&aperm
#define ATEMP	&e->area
d400 1
a400 1
	struct TArea area;	/* temporary allocation area */
d855 1
a855 1
	struct TArea area;	/* area to allocate things */
d1251 2
a1252 2
PArea ainit(PArea);
void afreeall(PArea);
@


1.252
log
@work around even more format string warning stuff
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.251 2008/11/09 20:32:18 tg Exp $");
d392 1
a392 4
/*
 * Area-based allocation built on malloc/free
 */
typedef struct Area {
d394 2
a395 1
} Area;
d397 1
a397 1
EXTERN Area aperm;		/* permanent object space */
d405 1
a405 1
	Area area;		/* temporary allocation area */
d753 1
a753 1
	Area *areap;		/* area shf/buf were allocated in */
d759 1
a759 1
	Area *areap;		/* area to allocate entries */
d768 1
a768 1
	Area *areap;		/* area to allocate from */
d860 1
a860 1
	Area area;		/* area to allocate things */
d1064 1
a1064 1
	Area *areap;		/* area to allocate/free from */
d1163 1
a1163 1
	Area	*areap;
d1256 5
a1260 5
Area *ainit(Area *);
void afreeall(Area *);
void *alloc(size_t, Area *);	/* cannot fail */
void *aresize(void *, size_t, Area *);
void afree(void *, Area *);	/* can take NULL */
d1391 1
a1391 1
Source *pushs(int, Area *);
d1438 1
a1438 1
struct temp *maketemp(Area *, Temp_type, struct temp **);
d1440 1
a1440 1
void ktinit(struct table *, Area *, int);
d1476 2
a1477 2
char *strdup_(const char *, Area *);
char *strndup_(const char *, size_t, Area *);
d1510 2
a1511 2
struct op *tcopy(struct op *, Area *);
char *wdcopy(const char *, Area *);
d1514 1
a1514 1
void tfree(struct op *, Area *);
@


1.251
log
@build warning-free with LLVM+Clang on MirBSD itself
$ (CCC_LD=mgcc CC=ccc sh Build.sh -r && ./test.sh -v) 2>&1 | tee log
Total failed: 2 (as expected)
Total passed: 278

Just the result is huge, and we could of course build to intermediate
byte code to optimise globally…
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.250 2008/11/02 22:29:36 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/09"
d519 1
a519 1
EXTERN const char T_synerr[] I__("syntax error");
d1414 2
a1415 12
/*
 * circumvent compiler format string nonnull checking
 * we teach xlC to not bitch about zero-lengths, want
 * gcc to do it, and so gain double-checking benefits
 */
#if defined(__xlC__)
#define errorfz()	errorf("")
#define bi_errorfz()	bi_errorf("")
#else
#define errorfz()	errorf(null)
#define bi_errorfz()	bi_errorf(null)
#endif
@


1.250
log
@experimental support for <strings.h>
cf. http://www.opengroup.org/onlinepubs/009695399/basedefs/strings.h.html
QNX seems to bury some functions in there
@
text
@d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.249 2008/10/28 14:51:06 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/11/02"
@


1.249
log
@save 1640 .text bytes in MKSH_SMALL case by not inlining strdupx, strndupx
@
text
@d61 3
d106 1
a106 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.248 2008/10/28 14:32:42 tg Exp $");
d108 1
a108 1
#define MKSH_VERSION "R36 2008/10/28"
@


1.248
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.247 2008/10/26 21:51:27 ahoka Exp $");
d348 8
d379 1
d1484 4
@


1.247
log
@Add check for the nice(3) system call.
It may be not implemented on some plaforms, though it's usually present.

Required to compile on Haiku as of 2008 October.
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.246 2008/10/26 20:59:40 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R36 2008/10/26"
d161 1
a161 11

#if HAVE_EXPSTMT
/* this macro must not evaluate its arguments several times */
#define ksh_isspace(c)	({					\
	unsigned int ksh_isspace_c = (c);			\
	(ksh_isspace_c >= 0x09 && ksh_isspace_c <= 0x0D) ||	\
	    (ksh_isspace_c == 0x20);				\
})
#else
#define ksh_isspace(c)	ksh_isspace_((unsigned int)(c))
#endif
d338 34
a1257 1
void utf_cptradj(const char *, const char **);
a1449 17
#if defined(MKSH_SMALL) || !HAVE_EXPSTMT
#define str_save_		str_save
#define str_nsave_		str_nsave
char *str_save(const char *, Area *);
char *str_nsave(const char *, int, Area *);
#else
#define str_save_(s,ap)		str_nsave_((s), strlen(s), (ap))
#define str_nsave_(s,n,ap)	({				\
	size_t str_save_sz = (n) + 1;				\
	char *str_save_rv = alloc(str_save_sz, (ap));		\
	strlcpy(str_save_rv, (s), str_save_sz);			\
	(str_save_rv);						\
})
#define str_save(s,ap)		(!(s) ? NULL : str_save_((s), (ap)))
#define str_nsave(s,n,ap)	\
	(!(s) || (n) < 0 ? NULL : str_nsave_((s), (n), (ap)))
#endif
a1474 3
#if !HAVE_EXPSTMT
bool ksh_isspace_(unsigned int);
#endif
@


1.246
log
@• do not use __typeof__ even if we have statements-as-expressions, to
  please pcc, prompted for by Anders “ragge” Magnusson, problem spotted
  originally by Adam “replaced” Hoka
  ⇒ rewrote x_bs2() and utf_backch() into a combined x_bs3() function,
    since these are never used in any other way
• whitespace cleanup, while here
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.245 2008/10/24 21:35:43 tg Exp $");
d437 1
d439 1
@


1.245
log
@this will most certainly be mksh R36
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.244 2008/10/24 19:54:23 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R36 2008/10/24"
@


1.244
log
@• OSF/1 may not have MAP_FAILED defined either
  XXX mmap() works only on devices on some DEC OSes, not on files, so,
  XXX instead, it were best to disable it altogether
• bump date
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.243 2008/10/20 19:29:25 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/24"
@


1.243
log
@• change mksh to only then behave more POSuXish when called as /bin/sh or
  “-sh” if -DMKSH_BINSHREDUCED was passed during compilation, for example
  for Debian, but d̲e̲f̲i̲n̲i̲t̲i̲v̲e̲l̲y̲ n̲̲o̲̲t̲̲ for MirBSD™
• split up regression test to force this behaviour
• remove the gunk from our MirBSD™ startup scripts again
• mention arc4random.c changes on website, sync clog, warn packagers
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.242 2008/10/19 20:15:45 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/20"
d193 1
a193 1
#  elif defined(__bsdi__) || defined(__ultrix)
@


1.242
log
@when doing a history search (^R), restore old input line on
abortion (^G – ^C is SIGINT and doesn’t work like this, but
that’s actually good IMO)

prompted by enquiry about the Emacs editing mode by <smultron:#MidnightBSD>
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.241 2008/10/15 10:25:01 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/19"
@


1.241
log
@use less stack storage, prefer .bss storage (saves us a memset() call)
and .data instead of another initialisation; this was prompted by a bug
in scan-build (the value can never be NULL, but it doesn’t realise it),
although this doesn’t fix it, but less stack usage is always good
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.240 2008/10/13 23:06:03 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/15"
@


1.240
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.239 2008/10/10 21:30:42 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/13"
d370 1
a370 1
EXTERN struct env {
@


1.239
log
@fix prodded by cnuke@@ for AIX with IBM xlC 7.0:
fool the compiler into not doing static bounds checking when we do
one-past-the-array-boundary pointer assignments for cases where the
only accesses are like (*--pointer); bump version
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.238 2008/10/05 16:06:43 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/10"
@


1.238
log
@unbreak MKSH_SMALL after x_histp related changes
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.237 2008/10/04 23:08:04 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/05"
@


1.237
log
@implement Message-ID: <20081004171903.GA14184@@boetes.org>
in a somewhat hackish way, and it’s still quite different from zsh,
but probably closer to a desired functionality

XXX this makes state by abusing 「modified」 and 「xmp」 (“the mark”).
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.236 2008/09/30 19:25:51 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/10/04"
@


1.236
log
@ignore more dups
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.235 2008/09/30 18:43:07 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/09/30"
@


1.235
log
@add regression tests, sync manpage, bump version number
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.234 2008/09/30 17:49:26 tg Exp $");
d1309 1
a1309 1
void histsave(int, const char *, bool);
@


1.234
log
@däs isch ei buul, koa int…
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.233 2008/09/20 19:18:00 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/09/20"
@


1.233
log
@bump mksh patchlevel for today’s sorta-tested half-done changes, with more
to follow (see <Pine.BSM.4.64L.0809201417560.22066@@herc.mirbsd.org>), as I
probably am not going to hack any more tonight
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.232 2008/09/17 19:31:30 tg Exp $");
d1309 1
a1309 1
void histsave(int, const char *, int);
@


1.232
log
@• bring back automatic turn-on of FPOSIX if called as sh/-sh
  ‣ only if !MKSH_SMALL
  ‣ add appropriate regression test
• if FPOSIX is set, do not close fds > 2 on exec, Debian #499139
• add appropriate regression tests for keeping fds private or not
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.231 2008/09/14 20:24:59 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/09/17"
@


1.231
log
@• merge vi_reset() and edit_reset() into x_vi() to allow for following:
• fix vi mode (which, however, is officially orphaned) multi-line $PS1 by
  using a similar algorithm for prompt skipping as emacs mode (changing
  the meaning of prompt_trunc variable and using prompt_redraw, just even
  more efficiently than vi mode); reported by asarch via IRC
• fix multi-line prompts if last line is “too large” by using emacs mode
  algorithm of just internally appending a newline, while here ☺ this even
  saves us having to re-add the prompt_skip variable…

WARNING: this is only barely tested, as almost nobody ever uses vi mode
⇒ test yourself, there may be bugs (e.g. off-by-ones); already known is
  that the vi input line editing mode is NOT multibyte safe…
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.230 2008/08/02 17:45:12 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/09/14"
@


1.230
log
@• merge final version of the stack-free diff as committed by jaredy@@openbsd
  thanks for helping with the bug
• merge RCS IDs
• bump mksh version
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.229 2008/07/18 11:33:12 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/08/02"
@


1.229
log
@fixes for constant conditionals, from gcc-4.2 fat binary building
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.228 2008/07/14 12:29:06 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/18"
@


1.228
log
@fix attempt to free pointer to stack (function-local storage)
discovered by Elias Pipping
patch by Jared Yanovich
alloc/afree checker by Todd C. Miller
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.227 2008/07/12 18:09:37 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/14"
d1426 2
d1431 1
d1438 2
a1439 3
#define str_save(s,ap) \
	(!(s) ? NULL : str_nsave_((s), strlen(s), (ap)))
#define str_nsave(s,n,ap) \
@


1.227
log
@bump version
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.224 2008/07/10 21:55:08 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/12"
@


1.226
log
@600 bytes more for the small version aren't worth it; it looks
as if there are not many NULL pointers to be optimised away
@
text
@d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/10"
@


1.225
log
@further optimisation attempts in the str_save() and str_nsave() area
@
text
@d1425 3
a1427 5
#ifdef MKSH_SMALL
#define str_save(s,ap)		((s) ? str_save_s((s), (ap)) : NULL)
#define str_nsave(s,n,ap)	((s) ? str_nsave_s((s), (n), (ap)) : NULL)
char *str_save_s(const char *, Area *);
char *str_nsave_s(const char *, int, Area *);
d1429 5
a1433 6
#if HAVE_EXPSTMT
#define str_nsave_ns(s,sz,ap)	({				\
	unsigned int str_nsave_ns_sz = (sz);			\
	char *str_nsave_ns_rv = alloc(str_nsave_ns_sz, (ap));	\
	strlcpy(str_nsave_ns_rv, (s), str_nsave_ns_sz);		\
	(str_nsave_ns_rv);					\
d1435 4
a1438 9
#else
char *str_nsave_ns(const char *, unsigned int, Area *);
#endif
#define str_save(s,ap)		((s) \
				? str_nsave_ns((s), strlen(s) + 1, (ap)) \
				: NULL)
#define str_nsave(s,n,ap)	(((s) && ((n) >= 0)) \
				? str_nsave_ns((s), (n) + 1, (ap)) \
				: NULL)
@


1.224
log
@bump versions (since we lowered the fd limit again)
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.223 2008/07/10 18:48:02 tg Exp $");
d1426 4
a1429 1
char *str_save(const char *, Area *);
d1431 16
a1446 1
#define str_save(s,ap) (str_nsave((s), (s) ? strlen(s) : 0, (ap)))
a1447 1
char *str_nsave(const char *, int, Area *);
@


1.223
log
@limit fd usage – at least ULTRIX doesn’t cope
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.222 2008/07/09 21:32:44 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R34 2008/07/09"
@


1.222
log
@• bump NUFILE and FDBASE, allowing for more than 10 fds used by scripts
• change the code to accept more than a single digit for an fd
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.221 2008/07/06 22:41:09 tg Exp $");
d275 2
a276 2
#define NUFILE		256	/* Number of user-accessible files */
#define FDBASE		100	/* First file usable by Shell */
@


1.221
log
@check return value of unlink(2) when trying to remove an existing HISTFILE,
since mksh(1) did go into an infinite loop if that fails first

bug spotted, initial patch and help drafting a test case
From: Decklin Foster <decklin@@red-bean.com>

note there are more instances of unlink(2) and others (like chmod(2), as
spotted by flawfinder) which aren’t checked… but at least the other case
of unlink(2) use in histrap.c doesn’t cause any trouble (I think)
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.220 2008/06/28 22:51:55 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R34 2008/07/06"
d271 1
d274 4
@


1.220
log
@• add code to support GNU bash’s “&> file” I/O redirection extension,
  and make it fit into mksh’s model (also gives us a couple of things
  GNU bash doesn’t have
• add regression tests for all of these

Lukas “smultron” Upton from MidnightBSD spotted a script with /bin/sh
shebang invalidly using “&>” in some Apple backup toolkit, 10x

XXX why fds are limited to one digit?
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.219 2008/06/08 17:15:30 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R34 2008/06/28"
@


1.219
log
@• more usage fixes, inspired by sobrado
• bump mksh patchlevel
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.218 2008/05/17 20:10:52 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R34 2008/06/08"
d973 1
@


1.218
log
@I’m sorta shocked…
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.217 2008/05/17 18:47:01 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R34 2008/05/17"
@


1.217
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d11 4
d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.216 2008/05/17 18:27:57 tg Exp $");
@


1.216
log
@add new builtin “realpath” calling realpath(3) on its argument, skipping
over “--” for compatibility to Debian realpath(1) and possibly busybox’

“sounds handy” replaced@@TNF
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.215 2008/05/15 15:24:11 tg Exp $");
d1076 1
a1076 1
	vp__ = (void**) alloc(sizeofN(void*, (n)), ATEMP);	\
d1212 1
a1212 1
void *alloc(size_t, Area *);
d1214 1
a1214 10
void afree(void *, Area *);
#define afreechk(s)	do {		\
	void *afree_t = (s);		\
	if (afree_t)			\
		afree(afree_t, ATEMP);	\
} while (0)
#define afreechv(v,s)	do {		\
	if (v)				\
		afree(s, ATEMP);	\
} while (0)
@


1.215
log
@mksh:
* initialise the integers PPID, OPTIND, RANDOM, SECONDS, and TMOUT to base-10
* bring back PGRP as base-10 integer to the process group via getpgrp(2)
* initialise USER_ID as base-10 integer to the effective user id as retrieved
  from geteuid(2) = $(id -u)
* use $USER_ID in dot.mkshrc instead of spawning an id(1) process
  -> dot.mkshrc,v 1.34 now requires mksh R34
* convert more int to bool where appropriate
* remove dead code - getpgrp(2) cannot fail
* sync manual page to reality
* bump to mksh R34(beta) - feature freeze

XXX check if our_pgrp in jobs.c is still really needed, the setpgid call
XXX probably just makes us our own pgrp leader, and we might have to use
XXX and update kshpgrp accordingly - need feedback/help here but I think
XXX this simplification should be possible if I grok the code correctly.

etc/profile:
* adjust to $USER_ID changes in mksh (speed-up here, too)

mksh.hts:
* sync changelog
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.214 2008/05/04 01:51:31 tg Exp $");
d101 1
a101 1
#define MKSH_VERSION "R34 2008/05/15"
d169 3
d1298 3
@


1.214
log
@remove dead code and ifdefs, speed up configuring
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.213 2008/05/02 18:55:36 tg Exp $");
d101 1
a101 1
#define MKSH_VERSION "R33 2008/05/04"
d283 1
@


1.213
log
@thinko: multibyte characters are not always 1 column wide
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.212 2008/04/22 19:00:41 tg Exp $");
d101 1
a101 1
#define MKSH_VERSION "R33 2008/05/02"
@


1.212
log
@bump
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.211 2008/04/22 18:57:25 tg Exp $");
d101 1
a101 1
#define MKSH_VERSION "R33 2008/04/22"
d1231 1
@


1.211
log
@sh.h can provide its rcsid itself, no need for that ugly hack
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.210 2008/04/20 01:41:57 tg Exp $");
d101 1
a101 1
#define MKSH_VERSION "R33 2008/04/20"
@


1.210
log
@merge the fix for that segfault
@
text
@a10 3
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.206.2.1 2008/04/20 01:40:44 tg Exp $"
#define MKSH_VERSION "R33 2008/04/20"

d98 5
@


1.209
log
@mostly revert 100480A853206FB56FA and parse utf-8 lead bytes ourselves
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.208 2008/04/20 00:03:50 tg Exp $"
d1210 3
a1212 2
	if (s)				\
		afree(s, ATEMP);	\
@


1.208
log
@utf-8 function overhaul (size optimisation)
XXX maybe we can get more out of this?
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.207 2008/04/19 22:15:05 tg Exp $"
#define MKSH_VERSION "R33 2008/04/19"
@


1.207
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.206 2008/04/19 17:21:54 tg Exp $"
d1224 1
a1224 1
size_t utf_cptradj(const char *, const char **);
@


1.206
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.205 2008/04/16 21:56:03 tg Exp $"
#define MKSH_VERSION "R33 2008/04/16"
d159 1
a159 1
	unsigned ksh_isspace_c = (c);				\
d164 1
a164 1
#define ksh_isspace(c)	ksh_isspace_((unsigned)(c))
d1057 1
a1057 1
char *Xcheck_grow_(XString *, const char *, unsigned);
d1222 2
a1224 1
int ksh_mbswidth(const char *);
d1226 2
d1445 1
a1445 1
bool ksh_isspace_(unsigned);
@


1.206.2.1
log
@my change to edit.c:x_free_words introduced a bug because the afreechk()
macro was not side-effect safe → make it so

oops, but this was definitively not obvious
I think I know now why people tend to write macros in ALL CAPS
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.206 2008/04/19 17:21:54 tg Exp $"
d1210 2
a1211 3
	void *afree_t = (s);		\
	if (afree_t)			\
		afree(afree_t, ATEMP);	\
@


1.205
log
@_careful_ (feature) sync with oksh:

   (3 weeks, 5 days ago) by millert
Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.204 2008/04/11 19:55:24 tg Exp $"
d1222 2
@


1.204
log
@SECURITY fix: when spawning mksh on a new terminal (tty, not /dev/null),
flush all of its I/O first – someone could have written on it beforehand
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.203 2008/04/06 23:27:19 tg Exp $"
#define MKSH_VERSION "R33 2008/04/11"
@


1.203
log
@move some portability stuff required only for setmode.c into that
(XXX we somehow do need a sorta libbsd…)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.202 2008/04/02 16:55:06 tg Exp $"
#define MKSH_VERSION "R33 2008/04/01"
@


1.202
log
@• Ultrix doesn’t define MAP_FAILED either
• on Ultrix, mmap() returns a caddr_t instead of a void*, so cast
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.201 2008/04/01 22:20:19 tg Exp $"
a166 3
#ifndef S_ISTXT
#define S_ISTXT		0001000
#endif
@


1.201
log
@some more code “folding”
should decrease size
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.200 2008/04/01 20:40:22 tg Exp $"
d187 1
a187 1
#  elif defined(__bsdi__)
@


1.200
log
@• unify ksh_dup2() usage, use bool where appropriate
• apply diff from mirbsdksh-1.11:
  #ifdef DUP2_BROKEN
  /* Ultrix systems like to preserve the close-on-exec flag */
  ‣ XXX we do #ifdef __ultrix here (imake-style) instead of mirtoconfing it
    (but does anyone know of any other OS with the same problem? plus we’d
    see it as we now know the symptoms)
• remove ultrix Build.hs warn=' but might work…' in the hope it DOES
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.199 2008/03/28 13:46:53 tg Exp $"
d1545 2
a1546 2
	const char *(*getopnd) (Test_env *, Test_op, int);
	int (*eval)(Test_env *, Test_op, const char *, const char *, int);
d1553 1
a1553 1
int test_eval(Test_env *, Test_op, const char *, const char *, int);
@


1.199
log
@• fix one more of the enum arithmetics complaints
• split Xinit into XinitN and Xinit macro, the former
  not initialising the “xp” argument of the latter,
  and use this to get rid of two variables that are
  only assigned but never referenced (gcc doesn’t see
  this, but MIPSpro and IIRC SUNWcc do)
• re-indent while here
• bump patchlevel
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.198 2008/03/25 21:34:45 tg Exp $"
#define MKSH_VERSION "R33 2008/03/28"
d1387 1
a1387 1
int ksh_dup2(int, int, int);
@


1.198
log
@• Add support for Ultrix 4.5 and ucode cc (?)
  ‣ I/O redirection seems broken:
    $ (date; date >/dev/null; date) | wc -l
    1 (expected: 2)
  ‣ other than that: working fine
  ‣ -YBSD (default) and -YSYSTEM_FIVE don’t work, just -YPOSIX, somehow
• Fix $(…) to `…` for OSF/1 V2.0 /bin/sh
  ‣ this compiler is FUBAR though:
	$ cat >t.c
	main() { return (foo()); }
	$ cc t.c
	ld:
	Unresolved :
	foo
	$ echo $?
	0
	$ ls -l a.out
	-rwxr-xr-x   1 mirbsd   users      10835 Jul 21 17:12 a.out
  ‣ it seems to have ucode, but man is not installed
• new mirtoconf check: mkstemp(3)
• if !HAVE_MKSTEMP (Ultrix), use tempnam(3)
• only use printf(1) if it exists (it doesn’t on Ultrix)
• a few more signals
• add S_ISLNK if the OS doesn’t define it
• add strcasecmp(3) proto for Ultrix (it _is_ in <portability.h>, but
  only for -YBSD I think)
• fgrep(1) on Ultrix doesn’t do “-e ① -e ②”

10x DEChengst:#UnixNL for giving access
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.197 2008/03/23 22:09:59 tg Exp $"
#define MKSH_VERSION "R33 2008/03/25"
d1021 10
a1030 7
#define Xinit(xs, xp, length, area) do { \
			(xs).len = length; \
			(xs).areap = (area); \
			(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap); \
			(xs).end = (xs).beg + (xs).len; \
			xp = (xs).beg; \
		} while (0)
d1036 5
a1040 5
#define XcheckN(xs, xp, n) do { \
			int more = ((xp) + (n)) - (xs).end; \
			if (more > 0) \
				xp = Xcheck_grow_(&xs, xp, more); \
		} while (0)
d1043 1
a1043 1
#define Xcheck(xs, xp)	XcheckN(xs, xp, 1)
d1046 1
a1046 1
#define Xfree(xs, xp)	afree((void*) (xs).beg, (xs).areap)
d1049 2
a1050 2
#define Xclose(xs, xp)	(char*) aresize((void*)(xs).beg, \
					(size_t)((xp) - (xs).beg), (xs).areap)
d1071 17
a1087 17
#define XPinit(x, n) do { \
			void **vp__; \
			vp__ = (void**) alloc(sizeofN(void*, n), ATEMP); \
			(x).cur = (x).beg = vp__; \
			(x).end = vp__ + n; \
		} while (0)

#define XPput(x, p) do { \
			if ((x).cur >= (x).end) { \
				int n = XPsize(x); \
				(x).beg = (void**) aresize((void*) (x).beg, \
				    sizeofN(void*, n*2), ATEMP); \
				(x).cur = (x).beg + n; \
				(x).end = (x).cur + n; \
			} \
			*(x).cur++ = (p); \
		} while (0)
d1092 2
a1093 2
#define XPclose(x)	(void**) aresize((void*)(x).beg, \
					 sizeofN(void*, XPsize(x)), ATEMP)
d1095 1
a1095 1
#define XPfree(x)	afree((void*) (x).beg, ATEMP)
@


1.197
log
@support dæmonisation in mksh, for example
|	csh -cf '/command/svscanboot &'
and
|	/usr/mpkg/bin/pgrphack /usr/mpkg/bin/svscanboot &
can now be replaced with
|	/bin/mksh -T- /usr/mpkg/bin/svscanboot
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.195 2008/03/05 18:49:15 tg Exp $"
#define MKSH_VERSION "R33 2008/03/23"
d170 3
d227 4
@


1.196
log
@support BSD/OS 3.1 with gcc2, 10x replaced@@tnf
except MAP_FAILED not being defined, no issues
@
text
@d12 1
a12 1
#define MKSH_VERSION "R33 2008/03/05"
@


1.195
log
@• check for flock decl too (weird on OSF/1: if !POSIX and BSD)
• un-experimental Tru64
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.194 2008/03/05 18:21:45 tg Exp $"
d181 2
a182 1
#if !defined(MAP_FAILED) && defined(__linux)
d184 3
@


1.195.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.204 2008/04/11 19:55:24 tg Exp $"
#define MKSH_VERSION "R33 2008/04/11"
d167 2
a168 2
#ifndef S_ISLNK
#define S_ISLNK(m)	((m & 0170000) == 0120000)
d181 1
a181 2
#if !defined(MAP_FAILED)
#  if defined(__linux)
a182 3
#  elif defined(__bsdi__) || defined(__ultrix)
#define MAP_FAILED	((caddr_t)-1)
#  endif
a219 4
#ifdef __ultrix
int strcasecmp(const char *, const char *);
#endif

d1010 7
a1016 10
#define XinitN(xs, length, area) do {				\
	(xs).len = (length);					\
	(xs).areap = (area);					\
	(xs).beg = alloc((xs).len + X_EXTRA, (xs).areap);	\
	(xs).end = (xs).beg + (xs).len;				\
} while (0)
#define Xinit(xs, xp, length, area) do {			\
	XinitN((xs), (length), (area));				\
	(xp) = (xs).beg;					\
} while (0)
d1022 5
a1026 5
#define XcheckN(xs, xp, n) do {					\
	int more = ((xp) + (n)) - (xs).end;			\
	if (more > 0)						\
		(xp) = Xcheck_grow_(&(xs), (xp), more);		\
} while (0)
d1029 1
a1029 1
#define Xcheck(xs, xp)	XcheckN((xs), (xp), 1)
d1032 1
a1032 1
#define Xfree(xs, xp)	afree((void*)(xs).beg, (xs).areap)
d1035 2
a1036 2
#define Xclose(xs, xp)	(char*)aresize((void*)(xs).beg, \
			    (size_t)((xp) - (xs).beg), (xs).areap)
d1057 17
a1073 17
#define XPinit(x, n) do {					\
	void **vp__;						\
	vp__ = (void**) alloc(sizeofN(void*, (n)), ATEMP);	\
	(x).cur = (x).beg = vp__;				\
	(x).end = vp__ + (n);					\
} while (0)

#define XPput(x, p) do {					\
	if ((x).cur >= (x).end) {				\
		int n = XPsize(x);				\
		(x).beg = (void**) aresize((void*) (x).beg,	\
		    sizeofN(void *, n * 2), ATEMP);		\
		(x).cur = (x).beg + n;				\
		(x).end = (x).cur + n;				\
	}							\
	*(x).cur++ = (p);					\
} while (0)
d1078 2
a1079 2
#define XPclose(x)	(void**)aresize((void*)(x).beg, \
			    sizeofN(void *, XPsize(x)), ATEMP)
d1081 1
a1081 1
#define XPfree(x)	afree((void *)(x).beg, ATEMP)
d1373 1
a1373 1
int ksh_dup2(int, int, bool);
d1531 2
a1532 2
	const char *(*getopnd) (Test_env *, Test_op, bool);
	int (*eval)(Test_env *, Test_op, const char *, const char *, bool);
d1539 1
a1539 1
int test_eval(Test_env *, Test_op, const char *, const char *, bool);
@


1.195.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d11 2
a12 3
#ifdef __dietlibc__
#define _BSD_SOURCE	/* live, BSD, live! */
#endif
a100 5
#ifdef EXTERN
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.218 2008/05/17 20:10:52 tg Exp $");
#endif
#define MKSH_VERSION "R34 2008/05/17"

d159 1
a159 1
	unsigned int ksh_isspace_c = (c);			\
d164 1
a164 1
#define ksh_isspace(c)	ksh_isspace_((unsigned int)(c))
a166 3
#ifndef PATH_MAX
#define PATH_MAX	1024
#endif
a280 1
EXTERN pid_t kshpgrp;		/* process group of shell */
d1057 1
a1057 1
char *Xcheck_grow_(XString *, const char *, unsigned int);
d1070 1
a1070 1
	vp__ = (void**)alloc(sizeofN(void*, (n)), ATEMP);	\
d1206 1
a1206 1
void *alloc(size_t, Area *);	/* cannot fail */
d1208 9
a1216 1
void afree(void *, Area *);	/* can take NULL */
a1221 3
size_t utf_mbtowc(unsigned int *, const char *);
size_t utf_wctomb(char *, unsigned int);
void utf_cptradj(const char *, const char **);
a1222 3
int utf_mbswidth(const char *);
int utf_wcwidth(unsigned int);
const char *utf_skipcols(const char *, int);
a1284 3
#if HAVE_REALPATH
int c_realpath(const char **);
#endif
d1440 1
a1440 1
bool ksh_isspace_(unsigned int);
@


1.195.2.3
log
@MFC: mksh R35
@
text
@d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.224 2008/07/10 21:55:08 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/10"
a270 1
#ifdef MKSH_SMALL
a272 4
#else
#define NUFILE		56	/* Number of user-accessible files */
#define FDBASE		24	/* First file usable by Shell */
#endif
a972 1
#define IOBASH	BIT(9)	/* &> etc. */
@


1.195.2.4
log
@MFC: mksh R35b
@
text
@d103 1
a103 1
__RCSID("$MirOS$");
d105 1
a105 1
#define MKSH_VERSION "R35 2008/07/18"
d1425 1
a1425 3
#if defined(MKSH_SMALL) || !HAVE_EXPSTMT
#define str_save_		str_save
#define str_nsave_		str_nsave
a1426 1
char *str_nsave(const char *, int, Area *);
d1428 1
a1428 10
#define str_save_(s,ap)		str_nsave_((s), strlen(s), (ap))
#define str_nsave_(s,n,ap)	({				\
	size_t str_save_sz = (n) + 1;				\
	char *str_save_rv = alloc(str_save_sz, (ap));		\
	strlcpy(str_save_rv, (s), str_save_sz);			\
	(str_save_rv);						\
})
#define str_save(s,ap)		(!(s) ? NULL : str_save_((s), (ap)))
#define str_nsave(s,n,ap)	\
	(!(s) || (n) < 0 ? NULL : str_nsave_((s), (n), (ap)))
d1430 1
@


1.195.2.5
log
@MFC: mksh R36b
@
text
@a60 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d103 1
a103 1
__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.267 2008/12/13 18:32:27 tg Exp $");
d105 1
a105 1
#define MKSH_VERSION "R36 2008/12/13"
d130 1
a130 4
#define timerclear(tvp)							\
	do {								\
		(tvp)->tv_sec = (tvp)->tv_usec = 0;			\
	} while (/* CONSTCOND */ 0)
d141 1
a141 1
	} while (/* CONSTCOND */ 0)
d152 1
a152 1
	} while (/* CONSTCOND */ 0)
d161 11
a171 1
#define ksh_isspace(c)	((((c) >= 0x09) && ((c) <= 0x0D)) || ((c) == 0x20))
d193 1
a193 1
#  elif defined(__bsdi__) || defined(__osf__) || defined(__ultrix)
d265 1
a270 1
/* these shall be smaller than 100 */
a347 43
#define utf_ptradjx(src, dst) do {					\
	size_t utf_ptradjx_len;						\
									\
	if (!UTFMODE ||							\
	    *(const unsigned char *)(src) < 0xC2 ||			\
	    (utf_ptradjx_len = utf_mbtowc(NULL, (src))) == (size_t)-1)	\
		utf_ptradjx_len = 1;					\
	(dst) = (src) + utf_ptradjx_len;				\
} while (/* CONSTCOND */ 0)

#ifdef MKSH_SMALL
#define strdupx(d, s, ap) do { \
	(d) = strdup_((s), (ap)); \
} while (/* CONSTCOND */ 0)
#define strndupx(d, s, n, ap) do { \
	(d) = strndup_((s), (n), (ap)); \
} while (/* CONSTCOND */ 0)
#else
/* be careful to evaluate arguments only once! */
#define strdupx(d, s, ap) do {						\
	const char *strdup_src = (s);					\
	char *strdup_dst = NULL;					\
									\
	if (strdup_src != NULL) {					\
		size_t strdup_len = strlen(strdup_src) + 1;		\
		strdup_dst = alloc(strdup_len, (ap));			\
		strlcpy(strdup_dst, strdup_src, strdup_len);		\
	}								\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)
#define strndupx(d, s, n, ap) do {					\
	const char *strdup_src = (s);					\
	char *strdup_dst = NULL;					\
									\
	if (strdup_src != NULL) {					\
		size_t strdup_len = (n) + 1;				\
		strdup_dst = alloc(strdup_len, (ap));			\
		strlcpy(strdup_dst, strdup_src, strdup_len);		\
	}								\
	(d) = strdup_dst;						\
} while (/* CONSTCOND */ 0)
#endif

d370 1
a370 1
extern struct env {
a436 1
#if HAVE_NICE
a437 1
#endif
d461 1
a461 1
	FUTFMODE,	/* -U: enable utf-8 processing */
a474 1
#define UTFMODE	Flag(FUTFMODE)
d481 1
a481 1
#define T_synerr "syntax error"
d1039 1
a1039 1
} while (/* CONSTCOND */ 0)
d1043 1
a1043 1
} while (/* CONSTCOND */ 0)
d1053 1
a1053 1
} while (/* CONSTCOND */ 0)
d1059 1
a1059 1
#define Xfree(xs, xp)	afree((xs).beg, (xs).areap)
d1062 2
a1063 2
#define Xclose(xs, xp)	aresize((xs).beg, (xp) - (xs).beg, (xs).areap)

d1067 5
a1071 5
#define Xnleft(xs, xp)	((xs).end - (xp))	/* may be less than 0 */
#define Xlength(xs, xp)	((xp) - (xs).beg)
#define Xsize(xs, xp)	((xs).end - (xs).beg)
#define Xsavepos(xs, xp)	((xp) - (xs).beg)
#define Xrestpos(xs, xp, n)	((xs).beg + (n))
d1086 1
a1086 1
	vp__ = alloc((n) * sizeof (void *), ATEMP);		\
d1089 1
a1089 1
} while (/* CONSTCOND */ 0)
d1093 3
a1095 3
		size_t n = XPsize(x);				\
		(x).beg = aresize((x).beg,			\
		    n * 2 * sizeof (void *), ATEMP);		\
d1100 1
a1100 1
} while (/* CONSTCOND */ 0)
d1104 5
a1108 2
#define XPclose(x)	aresize((x).beg, XPsize(x) * sizeof (void *), ATEMP)
#define XPfree(x)	afree((x).beg, ATEMP)
d1120 1
a1120 1
		struct tbl *tblp;  /* alias (SF_HASALIAS) */
a1150 1
#define SF_HASALIAS	BIT(5)	/* u.tblp valid (SALIAS, SEOF) */
d1229 1
a1229 1
/* UTF-8 stuff */
d1232 1
d1309 1
a1309 1
void histsave(int *, const char *, bool, bool);
d1377 12
a1388 4
#define errorfz()	errorf("\1")
#define bi_errorfz()	bi_errorf("\1")
void internal_verrorf(const char *, va_list)
    __attribute__((format (printf, 1, 0)));
d1418 1
a1418 1
#define ktdelete(p)	do { p->flag = 0; } while (/* CONSTCOND */ 0)
d1425 17
d1467 2
a1468 3
#ifdef MKSH_SMALL
char *strdup_(const char *, Area *);
char *strndup_(const char *, size_t, Area *);
a1524 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
a1525 1
#endif
@


1.194
log
@• now this builds fine on DEChengst’s Tru64 box:
  | OSF1 rubbereendje.dechengst.nl V5.1 2650 alpha
  with the vendor compiler:
  | Compaq C V6.5-011 on HP Tru64 UNIX V5.1B (Rev. 2650)
  | Compiler Driver V6.5-003 (sys) cc Driver
• the platform’s sig_t is incompatible too (simplify check)
• no compile warnings at all
• results in:
  $ size mksh
  | text    data    bss     dec     hex
  | 327680  16384   17808   361872  58590
  $ file mksh
  | mksh:   COFF format alpha dynamically linked, demand paged executable or object module not stripped - version 3.13-14
  $ ldd mksh
  |
  |         Main  =>   mksh
  |         libc.so  =>   /usr/shlib/libc.so
  $ ls -l mksh
  | -rwxr-xr-x   1 mirbsd   users     395200 Mar  5 19:18 mksh
• minor testsuite issues:
  FAIL ./check.t:regression-13
        unexpected stderr - got too much output
        wanted nothing
        got:
                Successful
                cat: output error
  ⇒ probably harmless
• works like a charm!
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.193 2008/03/05 17:06:50 tg Exp $"
d207 4
@


1.193
log
@OSF/1 doesn’t seem to declare revoke(2) anywhere
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.192 2008/03/01 21:10:26 tg Exp $"
#define MKSH_VERSION "R33 2008/03/01"
d186 1
d188 3
@


1.192
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix ☺
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.191 2008/03/01 02:21:38 tg Rel $"
d203 4
@


1.191
log
@we don't need to be special if called as -sh any longer now
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.190 2008/02/27 12:49:54 tg Exp $"
d541 1
a541 1
#define C_SUBOP2 BIT(8)		/* "#%/" (magic, see below) */
d546 1
a546 2
			    (((c) == '#' || (c) == '%' || 		\
			      (c) == '/') ? 1 : 0) :			\
d1453 1
a1453 1
char *wdstrip(const char *);
@


1.190
log
@fix
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.189 2008/02/27 11:24:12 tg Exp $"
#define MKSH_VERSION "R33 2008/02/27"
@


1.189
log
@almost hack ${foo//bar/baz} support for real, now
still one corner case left ☹
→ 11:09⎜«Han:#UnixNL» Ik _haat_ bash
⇒ kann ich mich nur anschließen…
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.188 2008/02/27 01:00:10 tg Exp $"
d541 1
a541 1
#define C_SUBOP2 BIT(8)		/* "#%" (magic, see below) */
@


1.188
log
@I _think_ this implements ${foo/bar/baz} logic (bar is a glob pattern)
todo tomorrow:
• test case (compare with e.g. GNU bash)
• manpage
• version bump

sqchar is a bit ugly, but \/ must be preserved, as we don’t get wdencoded
strings later on in the process (eval.c CSUBST) and I didn’t want to have
an implementation like ${foo: 2: 3} this time
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.187 2008/02/26 20:43:11 tg Exp $"
#define MKSH_VERSION "R33 2008/02/26"
@


1.187
log
@implement “here strings”
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.186 2008/02/26 20:35:25 tg Exp $"
d546 2
a547 1
			    (((c) == '#' || (c) == '%') ? 1 : 0) :	\
d1398 1
a1398 1
int gmatchx(const char *, const char *, int);
@


1.186
log
@move some constants private to the lexer into its .c file
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.185 2008/02/24 15:48:43 tg Exp $"
#define MKSH_VERSION "R33 2008/02/24"
@


1.185
log
@live code from FOSDEM: add print \xDB and \u20AC, including regression test
agreed bsiegert@@
good idea and manpage diff ok'd by some netbsd person sitting next to me
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.184 2007/10/25 15:34:57 tg Exp $"
a1112 19
/*
 * states while lexing word
 */
#define SBASE		0	/* outside any lexical constructs */
#define SWORD		1	/* implicit quoting for substitute() */
#define SLETPAREN	2	/* inside (( )), implicit quoting */
#define SSQUOTE		3	/* inside '' */
#define SDQUOTE		4	/* inside "" */
#define SBRACE		5	/* inside ${} */
#define SCSPAREN	6	/* inside $() */
#define SBQUOTE		7	/* inside `` */
#define SASPAREN	8	/* inside $(( )) */
#define SHEREDELIM	9	/* parsing <<,<<- delimiter */
#define SHEREDQUOTE	10	/* parsing " in <<,<<- delimiter */
#define SPATTERN	11	/* parsing *(...|...) pattern (*+?@@!) */
#define STBRACE		12	/* parsing ${..[#%]..} */
#define SLETARRAY	13	/* inside =( ), just copy */
#define SADELIM		14	/* like SBASE, looking for delimiter */

@


1.184
log
@oops
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.183 2007/10/25 15:23:10 tg Exp $"
#define MKSH_VERSION "R32 2007/10/25"
@


1.183
log
@get rid of u_char, u_int, u_long
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.182 2007/10/25 15:19:16 tg Exp $"
d1397 1
a1397 1
#define ktdelete(p)	do { p->flag = 0 } while (0)
@


1.182
log
@optimise (struct padding, function→macro, etc.)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.181 2007/10/25 14:26:53 tg Exp $"
d1493 1
a1493 1
void change_random(u_long);
@


1.181
log
@even better: don't require 64-bit types at all
also, improve wording of Build.sh (passive terms)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.180 2007/10/25 14:18:56 tg Exp $"
a335 2
	short type;		/* environment type - see below */
	short flags;		/* EF_* */
d340 1
d342 2
a343 1
	struct temp *temps;	/* temp files */
d689 1
a690 1
	struct tbl **tbls;	/* hashed table items */
a859 5
	short type;			/* operation type, see below */
	union { /* WARNING: newtp(), tcopy() use evalflags = 0 to clear union */
		short evalflags;	/* TCOM: arg expansion eval() flags */
		short ksh_func;		/* TFUNC: function x (vs x()) */
	} u;
d870 5
d1397 1
a1397 1
void ktdelete(struct tbl *);
@


1.180
log
@only check for 64-bit integer types if needed (arc4random support)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.179 2007/10/25 13:51:19 tg Exp $"
a120 4
#if HAVE_ARC4RANDOM && !HAVE_STDINT_H && !HAVE_UINT64_T
typedef unsigned long long uint64_t;
#endif

@


1.179
log
@• fix for the pipeline-as-coprocess problem
• bump to mksh R32
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.178 2007/10/18 20:32:33 tg Exp $"
d121 4
d1497 1
a1497 1
void change_random(uint64_t);
@


1.178
log
@first step towards mksh R32 ☺
allow array indices in the uint32_t range (0‥4294967295) and map negatives
into that range; adjust manual page and regression tests; to be used RSN ☻
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.177 2007/10/14 13:43:41 tg Exp $"
#define MKSH_VERSION "R31 2007/10/18"
@


1.177
log
@clean up the CHARMASK mess
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.176 2007/10/09 14:50:50 tg Exp $"
#define MKSH_VERSION "R31 2007/10/14"
d704 1
a704 1
	int index;		/* index for an array */
@


1.176
log
@revert the return type of x_e_getc() back from u_char to int
this change broke abortion on failure to read input, was not
needed for gcc warnings and is the fault of Intel’s compiler

this should fix the other busy-loop problem occuring only on
GNU/Linux so far – 10x spaetzle@@freewrt.o for pointing me to
the problem; reproduced on my work craptop
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.175 2007/09/09 18:06:41 tg Exp $"
#define MKSH_VERSION "R31 2007/10/09"
@


1.175
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.174 2007/08/20 14:06:10 tg Exp $"
#define MKSH_VERSION "R31 2007/09/09"
@


1.174
log
@proto
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.173 2007/08/19 23:12:22 tg Exp $"
#define MKSH_VERSION "R31 2007/08/19"
@


1.173
log
@employ string pooling techniques to save off a few more bytes
(probably more than the new “rename” builtin ever required…)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.172 2007/08/19 22:06:27 tg Exp $"
d195 2
@


1.172
log
@new builtin “rename” (this name sounds better than “mksh_mv_rescue” ☻)
to just call rename(2) directly, e.g. if /bin/mv needs /lib/ld-uClibc.so.0

some assorted code cleanup
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.171 2007/08/18 00:22:09 tg Exp $"
d442 3
a444 1
EXTERN char	null[] I__("");
@


1.171
log
@feature freeze for mksh R31, to be released as part of MirOS #10
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.170 2007/08/13 19:39:21 tg Exp $"
#define MKSH_VERSION "R31 2007/08/18"
d821 1
a821 1
extern const struct builtin shbuiltins [], kshbuiltins [];
d1274 4
@


1.170
log
@Implement the “source” command, as requested by some and agreed bsiegert@@
In contrast to AT&T ksh93, its semantics are like GNU bash in that it ap-
pends the current working directory to the search path; it is implemented
as a shell alias instead of enhancing funcs.c:shbuiltins[] like in ksh93.
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.169 2007/08/12 13:52:03 tg Exp $"
#define MKSH_VERSION "R30 2007/08/13"
@


1.169
log
@Debian warning cleanup
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.168 2007/08/12 13:42:23 tg Exp $"
#define MKSH_VERSION "R30 2007/08/12"
@


1.168
log
@add “set -o arc4random”, RTFM for details
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.167 2007/08/06 12:02:39 tg Exp $"
d1420 1
a1420 1
    __attribute__((bounded (buffer, 2, 3)));
@


1.167
log
@use bounds check for function that calls read
prompted by lina output, 10x tarzeau
not a bug
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.166 2007/07/31 11:11:25 tg Exp $"
#define MKSH_VERSION "R30 2007/07/31"
d197 2
a198 2
#if !HAVE_ARC4RANDOM_PUSH_DECL
extern void arc4random_push(int);
d396 3
d437 1
a437 1
#define Flag(f)	(shell_flags[(int) (f)])
d1485 1
a1485 1
void change_random(void);
@


1.166
log
@• new way of checking for mknod & friends, due to tcc vs glibc weirdness
• bump vsn for the code restructuring
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.165 2007/07/26 13:23:52 tg Exp $"
d1416 2
a1417 1
int blocking_read(int, char *, int);
@


1.165
log
@• test on HURD (gnubber)
• fix unreachable code (break stmt) cought by suncc on yofuh's E420
• bump vsn to today
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.164 2007/07/24 21:47:14 tg Exp $"
#define MKSH_VERSION "R30 2007/07/26"
@


1.164
log
@initial support for PW32, not quite working yet (same issues as Minix 3 and Plan 9, I think)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.163 2007/07/24 11:22:04 tg Exp $"
#define MKSH_VERSION "R30 2007/07/24"
@


1.163
log
@fix another errexit bug: unwind() is __dead, so the pseudo-signal was never
delivered to the process
• regression test by Clint Pachl, verified against Debian ksh93 by me
• place to fix it in the code discovered by Otto Moerbeek
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.162 2007/07/23 14:28:52 tg Exp $"
d110 1
d123 3
@


1.162
log
@… and fix that bug.

Ｇｕｖｆ ｐｂｚｚｖｇ ｈａｘａｂｊｖａｔｙｌ ｆｃｂａｆｂｅｒｑ
ｏｌ ＮｈｅＶＦＣ ＴｏＥ， ｆｖａｐｒ ｊｒ ｈｆｒ ｚｘｆｕ，
ｎａｑ ｚｌ ｂｇｕｒｅ ｇｎｆｘｆ ｎｅｒ ｊｎｖｇｖａｔ．．．
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.161 2007/07/22 14:01:50 tg Exp $"
#define MKSH_VERSION "R30 2007/07/23"
@


1.161
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.160 2007/07/22 13:46:15 tg Exp $"
#define MKSH_VERSION "R30 2007/07/22"
@


1.160
log
@• Build.sh: always prepend well-known signal names, so that some signals
  will not come up weirdly (e.g. on AIX: SIGSAK (SIGMAX?), SIGIO (SIGAIO?),
  SIGURG (SIGIOINT?)), and add a few more while here
• check.t, sh.h: bump
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.159 2007/07/22 13:38:26 tg Exp $"
d1341 12
@


1.159
log
@some null/NUL
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.158 2007/07/22 13:34:51 tg Exp $"
#define MKSH_VERSION "R30 2007/07/17"
@


1.158
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.157 2007/07/17 13:56:49 tg Exp $"
d432 1
a432 1
EXTERN char shell_flags [FNFLAGS];
d434 2
a435 1
EXTERN char	null [] I__("");	/* null value for variable */
@


1.157
log
@• make the "if called as sh, set FPOSIX" not !SMALL-only
• bump to R30-gamma, feature freeze
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.156 2007/07/06 02:22:57 tg Exp $"
a434 2
EXTERN char	space [] I__(" ");
EXTERN char	newline [] I__("\n");
@


1.156
log
@fix the rest of it
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.155 2007/07/06 01:53:36 tg Exp $"
#define MKSH_VERSION "R29 2007/07/05"
@


1.155
log
@make this pass varexpand-substr-1 and ‘c’ of varexpand-substr-2
by actually using the lexer and parser for that
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.154 2007/07/01 21:47:08 tg Exp $"
#define MKSH_VERSION "R29 2007/07/01"
@


1.154
log
@• fix display problem
• add <libutil.h> if it exists – revoke(2) on UWIN
• add <stdlib.h> for NULL in test of mmap(2)
• regen CPPFLAGS for MirBSD native builds
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.153 2007/07/01 21:27:03 tg Exp $"
d907 1
d1120 1
@


1.153
log
@• add support for the Borland C++ Builder (on UWIN)
• add support for the Digital Mars compiler (on UWIN)
• clean up
• describe new build targets and that UWIN sucks
• bump vsn
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.152 2007/07/01 16:49:18 tg Exp $"
d39 3
@


1.152
log
@some <getopt.h> from vendors define a “struct option”, so use a
different name for ours
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.151 2007/06/27 23:12:59 tg Exp $"
#define MKSH_VERSION "R29 2007/06/27"
@


1.151
log
@this is bash compatibility week, and by suggestion of actual users,
namely Dr. Robert “Pfeffer” Arnold (in this case, in FreeWRT), make
a half-completed attempt at implementing ${foo:2:3} substring evals
(of course, negatives can't work right now and that the numbers are
in face expressions is something I only read later too – this is to
be revisited later, but it's already late)

don't depend on this behaviour yet though

if someone wants to add more regression tests, feel free to…
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.150 2007/06/22 23:34:41 tg Exp $"
d377 1
a377 1
struct option {
d382 1
a382 1
extern const struct option options[];
@


1.150
log
@implement bash-style array initialisation, as requested by many
still experimental
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.149 2007/06/21 16:04:46 tg Exp $"
#define MKSH_VERSION "R29 2007/06/22"
@


1.149
log
@rewrite some code; bug found by HP's C compiler
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.148 2007/06/17 00:50:09 tg Exp $"
#define MKSH_VERSION "R29 2007/06/21"
d1115 1
d1166 1
@


1.148
log
@make sure that “integer” and “local” are defined even in FPOSIX mode, which
is a compromise anyway; these lunox people will have to live with that, too
many existing korn shell alike scripts depend on it even if not on the full
korn shell syntax availability (note: this doesn't mean using these in some
script with #!/bin/sh is ok)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.147 2007/06/15 21:55:20 tg Exp $"
#define MKSH_VERSION "R29 2007/06/17"
@


1.147
log
@• check.t: add some FPOSIX regression tests (1 still fails)
• all: remove vi editing mode #if defined(MKSH_SMALL) || defined(MKSH_NOVI)
  saves 12608 byts on i386
• check.t: add $0 quoting
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.146 2007/06/09 22:02:04 tg Exp $"
#define MKSH_VERSION "R29 2007/06/15"
@


1.146
log
@bump
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.145 2007/06/09 22:01:42 tg Exp $"
#define MKSH_VERSION "R29 2007/06/09"
d308 4
d416 1
d421 1
@


1.145
log
@don't use __extension__, cought by sunpro on linux
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.144 2007/06/09 21:59:21 tg Exp $"
#define MKSH_VERSION "R29 2007/06/06"
@


1.144
log
@from sunpro 12 on linux: optimise use of the const-vs-unconst catcher
thanks cnuke@@ for testing
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.143 2007/06/06 23:28:16 tg Exp $"
d151 1
a151 1
#define ksh_isspace(c)	__extension__({				\
d278 1
a278 1
#define cstrchr(s,c) __extension__({	\
d285 1
a285 1
#define cstrstr(b,l) __extension__({	\
@


1.143
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.142 2007/06/06 21:36:29 tg Exp $"
d272 2
a273 1
#ifdef DEBUG
d282 1
a282 1
	out.rw = strchr(in.rw, (c));	\
d289 1
a289 1
	out.rw = strstr(in.rw, (l));	\
d294 1
a294 23
#if HAVE_STRCASESTR
#define stristr(b,l) __extension__({	\
	union mksh_cchack out;		\
					\
	out.rw = strcasestr((b), (l));	\
	(out.ro);			\
})
#endif
#else
#if HAVE_EXPSTMT
#define cstrchr(s,c) __extension__({	\
	union mksh_cchack out;		\
					\
	out.rw = strchr((s), (c));	\
	(out.ro);			\
})
#define cstrstr(b,l) __extension__({	\
	union mksh_cchack out;		\
					\
	out.rw = strstr((b), (l));	\
	(out.ro);			\
})
#else
d297 2
a298 6
#endif
#define vstrchr	strchr
#define vstrstr	strstr
#if HAVE_STRCASESTR
#define stristr	strcasestr
#endif
d304 4
@


1.142
log
@first part of the Intel C Compiler (Linux) shaddap
| tglaser@@hephaistos:~ $ /usr/local/intel/cc/9.1.042/bin/icc -V
| Intel(R) C Compiler for 32-bit applications, Version 9.1    Build 20060706Z Package ID: l_cc_c_9.1.042
this one is muuuuch too verbose IMHO, _and_ it #defines __GNUC__ (eek)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.141 2007/06/05 19:48:47 tg Exp $"
#define MKSH_VERSION "R29 2007/06/05"
d1363 1
a1363 1
int savefd(int);
d1394 1
a1394 1
void change_flag(enum sh_flag, int, int);
d1524 2
@


1.141
log
@fix for the SUNpro 8 on yofuh's E420:
cc: Sun C 5.8 Patch 121015-04 2007/01/10
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.139 2007/06/04 21:33:28 tg Exp $"
d152 1
a152 1
	unsigned char ksh_isspace_c = (c);			\
d157 1
a157 1
#define ksh_isspace(c)	ksh_isspace_((unsigned char)(c))
d1417 1
a1417 1
bool ksh_isspace_(unsigned char);
@


1.140
log
@on Linux 2.0, <sys/sysmacros.h> defines makedev(), but on Solaris, both it
and <sys/mkdev.h> do it, where the latter seems to contain the newer ones,
it undefines them before redefining too, so move its inclusion up a little
@
text
@d12 1
a12 1
#define MKSH_VERSION "R29 2007/06/04"
d149 1
d151 8
a158 5
#define ksh_isspace(c)	__extension__({					\
		unsigned char ksh_isspace_c = (c);			\
		(ksh_isspace_c >= 0x09 && ksh_isspace_c <= 0x0D) ||	\
		    (ksh_isspace_c == 0x20);				\
	})
d302 1
d315 4
d1416 3
@


1.139
log
@compile warning-free on SUNpro (regression test suite pass) for MirBSD
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.138 2007/06/04 21:27:53 tg Exp $"
d21 3
a31 3
#if HAVE_SYS_SYSMACROS_H
#include <sys/sysmacros.h>
#endif
@


1.138
log
@When compiling native MirOS BSD binaries with SUNpro 12 (don't look like a
car only slower, yes this is possible, and the resulting binary passes the
testsuite just fine), the definition of __RCSID() in <sys/cdefs.h> expands
to something with __attribute__((used)), which triggers a warning, because
__attribute__ in general is supported but the used attribute isn't. Thusly
always use our own strings and get rid of the MULTI_RCSID test (introduced
because __RCSID() on Darwin is inferiour).

Maybe we should fix <sys/cdefs.h> too? #ifdef __SUNPRO_C helps here.
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.137 2007/05/24 23:07:19 tg Exp $"
#define MKSH_VERSION "R29 2007/05/24"
@


1.137
log
@for R30, don't check for confstr() declaration any more
it was #if solaris'd in R28, and the system I have access
on does declare it now (still Solaris 8)

this can be put back if anyone complains, of course.
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.136 2007/05/24 19:50:38 tg Exp $"
a17 23
#if defined(MKSH_INCLUDES_ONLY) || !HAVE_MULTI_IDSTRING
#undef __RCSID
#endif
#if !defined(__RCSID) || !defined(__SCCSID)
#undef __IDSTRING
#undef __IDSTRING_CONCAT
#undef __IDSTRING_EXPAND
#undef __RCSID
#undef __SCCSID
#if HAVE_ATTRIBUTE_USED
#define __attribute____used__	__attribute__((used))
#else
#define __attribute____used__	/* nothing */
#endif
#define __IDSTRING_CONCAT(l,p)		__LINTED__ ## l ## _ ## p
#define __IDSTRING_EXPAND(l,p)		__IDSTRING_CONCAT(l,p)
#define __IDSTRING(prefix, string)				\
	static const char __IDSTRING_EXPAND(__LINE__,prefix) []	\
	    __attribute____used__ = "@@(""#)" #prefix ": " string
#define __RCSID(x)	__IDSTRING(rcsid,x)
#define __SCCSID(x)	__IDSTRING(sccsid,x)
#endif

d67 31
a148 13
#if HAVE_ATTRIBUTE
#undef __attribute__
#if HAVE_ATTRIBUTE_BOUNDED
#define __bound_att__		__attribute__
#else
#define __bound_att__(x)	/* nothing */
#endif
#else
#define __attribute__(x)	/* nothing */
#endif
#undef __unused
#define __unused		__attribute__((unused))

@


1.136
log
@bump vsn, we had a regression…
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.135 2007/05/22 19:31:01 tg Exp $"
a194 4
#if !HAVE_CONFSTR_DECL
size_t confstr(int, char *, size_t);
#endif

@


1.135
log
@ah, of course, bump the date
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.134 2007/05/21 19:25:32 tg Exp $"
#define MKSH_VERSION "R29 2007/05/22"
@


1.134
log
@• fix the third dramsey scrolling bug for both ^D at BOL and ^W at EOL
  (I hope)
• fix another one I found: after ^D'ing, insert at BOL, the > is displayed
  one character too late
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.133 2007/05/20 17:53:13 tg Exp $"
#define MKSH_VERSION "R29 2007/05/21"
@


1.133
log
@fix the latest appearance of the dramsey backwards movement bug, cf.
Message-ID: <e3fded850705200935h6ac2c9ebgbc7a9b10ac034a49@@mail.gmail.com>
and Message-ID: <Pine.BSM.4.64L.0705201659500.8619@@odem.66h.42h.de>
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.132 2007/05/13 19:18:26 tg Exp $"
#define MKSH_VERSION "R29 2007/05/20"
@


1.132
log
@bump version
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.131 2007/05/13 19:14:05 tg Exp $"
#define MKSH_VERSION "R29 2007/05/13"
@


1.131
log
@fix Coverity CID #8, #9

it's wrong to use strchr(s, 0) to look for the NUL byte, because in some
environments it apparently might return NULL

use new macro strnul = s+strlen(s) instead (not side-effect safe tho)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.130 2007/05/13 18:33:29 tg Exp $"
#define MKSH_VERSION "R29 2007/05/10"
@


1.130
log
@Possible fix for Coverity CID#7:
convert options() prototype to unsigned (size_t, in fact), and make an
explicitly casted (size_t)-1 the error return code, modelled after what
is often used in Unix libraries
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.129 2007/05/13 17:51:23 tg Exp $"
d326 3
@


1.129
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.128 2007/05/10 19:08:48 tg Exp $"
d1389 1
a1389 1
int option(const char *);
@


1.128
log
@fix the “dramsey horizontal scrolling bug” – time for you to find another ☺
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.127 2007/04/24 10:42:02 tg Exp $"
d1347 5
a1351 2
void internal_errorf(int, const char *, ...)
    __attribute__((format (printf, 2, 3)));
@


1.127
log
@• arc4random, arc4random_push: use our own protos to check
  XXX u_int32_t is not ISO C99, but seems to work well enough
  XXX if it fails anywhere, we'll see in the build logs
  XXX apple doesn't have the standard uint32_t and API doesn't specify it
• sys_siglist_defn: rename to sys_siglist_decl as we're really checking
  for the declaration in the headers; change wording to “check if … does
  not need to be declared” since we don't need to declare if we don't use
• scan for arc4random, arc4random_push, confstr declarations too
• sh.h: confstr declaration is no longer #ifdef __sun__; sort
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.126 2007/04/23 20:37:16 tg Exp $"
#define MKSH_VERSION "R29 2007/04/17"
@


1.127.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.127 2007/04/24 10:42:02 tg Exp $"
#define MKSH_VERSION "R29 2007/05/13"
a325 3
/* use this ipv strchr(s, 0) but no side effects in s! */
#define strnul(s)	((s) + strlen(s))

d1347 2
a1348 5
void internal_errorf(const char *, ...)
    __attribute__((noreturn))
    __attribute__((format (printf, 1, 2)));
void internal_warningf(const char *, ...)
    __attribute__((format (printf, 1, 2)));
d1386 1
a1386 1
size_t option(const char *);
@


1.127.2.2
log
@MFC all the edit.c fixes; bump vsn
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.127.2.1 2007/05/13 19:29:38 tg Exp $"
#define MKSH_VERSION "R29 2007/05/22"
@


1.127.2.3
log
@pull up fixes for regressions
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.127.2.2 2007/05/22 21:34:30 tg Exp $"
#define MKSH_VERSION "R29 2007/05/24"
@


1.127.2.4
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.127.2.3 2007/05/26 22:31:21 tg Exp $"
#define MKSH_VERSION "R29 2007/07/05"
d18 23
a89 31
#if HAVE_ATTRIBUTE
#undef __attribute__
#else
#define __attribute__(x)	/* nothing */
#endif
#undef __unused
#define __unused		__attribute__((unused))
#if HAVE_ATTRIBUTE_BOUNDED
#define __bound_att__(x)	__attribute__(x)
#else
#define __bound_att__(x)	/* nothing */
#endif
#if HAVE_ATTRIBUTE_USED
#define __attribute____used__	__attribute__((used))
#else
#define __attribute____used__	/* nothing */
#endif

#undef __IDSTRING
#undef __IDSTRING_CONCAT
#undef __IDSTRING_EXPAND
#undef __RCSID
#undef __SCCSID
#define __IDSTRING_CONCAT(l,p)		__LINTED__ ## l ## _ ## p
#define __IDSTRING_EXPAND(l,p)		__IDSTRING_CONCAT(l,p)
#define __IDSTRING(prefix, string)				\
	static const char __IDSTRING_EXPAND(__LINE__,prefix) []	\
	    __attribute____used__ = "@@(""#)" #prefix ": " string
#define __RCSID(x)	__IDSTRING(rcsid,x)
#define __SCCSID(x)	__IDSTRING(sccsid,x)

d141 13
d156 1
a156 1
		unsigned ksh_isspace_c = (c);				\
@


1.126
log
@AIX has sys_siglist[] but doesn't define it anywhere, so add a means to
scan for defns and use it here; bug reported by Kurt Telep
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.125 2007/04/23 14:04:38 tg Exp $"
d185 13
a197 1
/* OS-dependent additions */
d203 1
d207 1
d212 2
a213 2
#if defined(__sun__) && !defined(_PATH_DEFPATH) && defined(_CS_PATH)
size_t confstr(int, char *, size_t);
a221 4
#if !HAVE_SYS_SIGLIST_DEFN
extern const char *const sys_siglist[];
#endif

@


1.125
log
@part of the AIX clean-up
with help of <Gurft> on freenode (Kurt)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.124 2007/04/17 23:51:32 tg Exp $"
d18 1
a18 1
#if !HAVE_MULTI_IDSTRING
d90 2
d208 4
d1522 2
@


1.124
log
@version bump here, too (CR-LF shebang)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.123 2007/04/15 12:09:57 tg Exp $"
d181 2
@


1.123
log
@• (re)implement shebang execution file parsing; this makes the “and which
  do not start with a "#!shell" sequence” part of mksh(1) true again; this
  was probably lost in mksh R21 or so when I decided/saw that our kernel
  always parses shebang lines (code written myself, not taken from pdksh
  again or MirBSD kernel, but verified against both)
• bom+shebang execution now works, no need setting EXECSHELL in the test
• bump version
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.122 2007/04/15 10:45:59 tg Exp $"
#define MKSH_VERSION "R29 2007/04/15"
@


1.122
log
@ignore the UTF-8 Byte Order Mark at the beginning of the input (via a file
given to execute, standard input (interactive or not), via -c command line
argument, or after “eval”, but not for $(…) comsubs, at the beginning of a
subsequent line, or within a line, etc.); regression test for it

idea during my “week off” (despite the pain), bsiegert@@ thinks it's good –
and utf-8 capable tools ought to be able to do this anyway
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.121 2007/03/14 02:41:09 tg Exp $"
#define MKSH_VERSION "R29 2007/03/14"
@


1.121
log
@• use wdcopy() not str_save() to duplicate an “encoded string”, whatever
• prevent out-of-bounds memory access, cought by glibc malloc on IA-64
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.120 2007/03/10 18:16:27 tg Exp $"
d1091 1
@


1.120
log
@some gcc 4.1.2pre warning shutup
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.119 2007/03/10 00:42:00 tg Exp $"
#define MKSH_VERSION "R29 2007/03/10"
@


1.119
log
@remove unused utf_width(); bump vsn
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.118 2007/03/04 05:14:10 tg Exp $"
d376 1
a376 1
	short flags;		/* OF_* */
a1063 2
	char	ugbuf[2];	/* buffer for ungetsc() (SREREAD) and
				 * alias (SALIAS) */
d1071 2
d1172 3
@


1.118
log
@Minix 3 has no S_ISSOCK (probably not even UNIX® domain sockets)
and lacks other things (rlimit stuff), so it won't make it today
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.117 2007/03/04 05:04:54 tg Exp $"
#define MKSH_VERSION "R29 2007/03/04"
a1191 1
#define utf_width(x)	utf_widthadj(x, NULL);
@


1.117
log
@more NSIG
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.116 2007/03/04 04:36:45 tg Exp $"
d162 3
@


1.116
log
@• Minix 3 doesn't have <sys/mman.h>
• Some OSes might need <stdint.h> for int32_t (Minix 3 with GCC)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.115 2007/03/04 03:04:27 tg Exp $"
d174 4
@


1.115
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS$"
d47 1
d49 1
d74 3
@


1.114
log
@merge the const branch +- a few
@
text
@d12 1
a12 1
#define MKSH_VERSION "R29 2007/02/16"
d18 1
a18 1
#if defined(HAVE_MULTI_IDSTRING) && !HAVE_MULTI_IDSTRING
d132 1
d155 1
a155 1
#define S_ISTXT 0001000
d158 1
a158 1
#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
d162 1
a162 1
#define RLIMIT_VMEM RLIMIT_AS
d166 1
a166 1
#define MAP_FAILED ((void *)-1)
d176 1
a176 1
char *strcasestr(const char *, const char *);
d224 9
a232 9
EXTERN	const char *kshname;	/* $0 */
EXTERN	pid_t kshpid;		/* $$, shell pid */
EXTERN	pid_t procpid;		/* pid of executing process */
EXTERN	uid_t ksheuid;		/* effective uid of shell */
EXTERN	int exstat;		/* exit status */
EXTERN	int subst_exstat;	/* exit status of last $(..)/`..` */
EXTERN	const char *safe_prompt; /* safe prompt if PS1 substitution fails */
EXTERN	const char initvsn[] I__("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
#define KSH_VERSION	(initvsn + 16)
d245 7
d259 36
d411 1
a411 1
EXTERN	char shell_flags [FNFLAGS];
d413 3
a415 3
EXTERN	char	null [] I__("");	/* null value for variable */
EXTERN	char	space [] I__(" ");
EXTERN	char	newline [] I__("\n");
d479 3
a481 3
EXTERN	volatile sig_atomic_t trap;	/* traps pending? */
EXTERN	volatile sig_atomic_t intrsig;	/* pending trap interrupts command */
EXTERN	volatile sig_atomic_t fatal_trap;/* received a fatal signal */
d489 1
a489 1
	TMOUT_EXECUTING	= 0,	/* executing commands */
d578 1
a578 1
EXTERN	int	x_cols I__(80);	/* tty columns */
d668 4
a671 4
		char *s;	/* string */
		long i;		/* integer */
		int (*f)(const char **);	/* int function */
		struct op *t;	/* "function" tree */
d720 1
a720 1
			 |LCASEV|UCASEV_AL|INT_U|INT_L)
d723 7
a729 7
#define CNONE	0		/* undefined */
#define CSHELL	1		/* built-in */
#define CFUNC	2		/* function */
#define CEXEC	4		/* executable command */
#define CALIAS	5		/* alias */
#define CKEYWD	6		/* keyword */
#define CTALIAS	7		/* tracked alias */
d749 1
a749 1
	char **argv;
d781 4
a784 5

EXTERN	struct table taliases;	/* tracked aliases */
EXTERN	struct table builtins;	/* built-in commands */
EXTERN	struct table aliases;	/* aliases */
EXTERN	struct table keywords;	/* keywords */
d786 1
a786 1
EXTERN	struct table homedirs;	/* homedir() cache */
d1149 4
a1152 4
EXTERN	Source *source;		/* yyparse/yylex source */
EXTERN	YYSTYPE	yylval;		/* result from yylex */
EXTERN	struct ioword *heres [HERES], **herep;
EXTERN	char	ident [IDENT+1];
d1156 3
a1158 3
EXTERN	char **history;	/* saved commands */
EXTERN	char **histptr;	/* last history item */
EXTERN	int histsize;	/* history size */
@


1.113
log
@mirtoconf the checks if to use persistent history support
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.112 2007/02/16 17:46:42 tg Exp $"
d223 1
a223 1
EXTERN	char *kshname;		/* $0 */
d234 19
d493 1
a493 1
	char		*optarg;
d520 2
a521 2
EXTERN char	*builtin_argv0;
EXTERN Tflag	builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
d626 1
a626 1
		int (*f)(char **);	/* int function */
d715 1
a715 1
	char **argv;
d748 1
a748 1
	int (*func)(char **);
d791 1
a791 1
	char **args;			/* arguments to a command */
d959 1
a959 1
char *Xcheck_grow_(XString *, char *, unsigned);
d1004 4
a1007 4
		char **strv;	/* string [] */
		struct shf *shf; /* shell file */
		struct tbl *tblp; /* alias (SALIAS) */
		char *freeme;	/* also for SREREAD */
d1123 8
d1140 3
a1142 3
char **eval(char **, int);
char *evalstr(char *cp, int);
char *evalonestr(char *cp, int);
d1144 1
a1144 1
void expand(char *, XPtrV *, int);
d1148 1
a1148 1
int shcomexec(char **);
d1151 1
a1151 1
void builtin(const char *, int (*)(char **));
d1156 1
a1156 1
int pr_menu(char *const *);
d1162 13
a1174 13
int c_hash(char **);
int c_cd(char **);
int c_pwd(char **);
int c_print(char **);
int c_whence(char **);
int c_command(char **);
int c_typeset(char **);
int c_alias(char **);
int c_unalias(char **);
int c_let(char **);
int c_jobs(char **);
int c_fgbg(char **);
int c_kill(char **);
d1176 16
a1191 16
int c_getopts(char **);
int c_bind(char **);
int c_label(char **);
int c_shift(char **);
int c_umask(char **);
int c_dot(char **);
int c_wait(char **);
int c_read(char **);
int c_eval(char **);
int c_trap(char **);
int c_brkcont(char **);
int c_exitreturn(char **);
int c_set(char **);
int c_unset(char **);
int c_ulimit(char **);
int c_times(char **);
d1194 3
a1196 3
int c_exec(char **);
int c_builtin(char **);
int c_test(char **);
d1204 1
a1204 1
int c_fc(char **);
d1225 1
a1225 1
void settrap(Trap *, char *);
d1255 1
a1255 1
int include(const char *, int, char **, int);
d1285 1
a1285 1
int check_fd(char *, int, const char **);
d1313 1
a1313 1
int parse_args(char **, int, int *);
d1321 1
a1321 1
int ksh_getopt(char **, Getopt *, const char *);
d1392 1
a1392 1
void set_array(const char *, int, char **);
d1429 1
a1429 1
		char **wp;	/* used by ptest_* */
d1432 1
a1432 1
	char **wp_end;		/* used by ptest_* */
@


1.112
log
@* edit.c: when tabcompleting a newline to backslash+newline, this
  sequence is eaten before the command is called; cought by <TGEN>
  (Thomas E. Spanjaard) via IRC
  fix is to tabcomplete a newline to singlequote+newline+singlequote
* bump version
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.111 2007/02/07 02:31:06 tg Exp $"
a741 2
/* this is defined when we support persistent history, undefined otherwise */
#if HAVE_FLOCK_EX && !defined(MKSH_SMALL)
a742 1
#endif
d1173 1
a1173 1
#ifdef V_HISTFILE
d1179 1
a1179 1
#ifdef V_HISTFILE
@


1.111
log
@bump version
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.110 2007/01/26 18:27:34 tg Exp $"
#define MKSH_VERSION "R29 2007/02/07"
@


1.110
log
@if mksh_small don't even support -T instead of ignoring it
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.109 2007/01/18 16:05:05 tg Exp $"
#define MKSH_VERSION "R29 2007/01/26"
@


1.109
log
@autoscan for persistent history support
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.108 2007/01/18 15:50:32 tg Exp $"
#define MKSH_VERSION "R29 2007/01/18"
@


1.108
log
@header overhaul: replace all #ifdef __OS__ with mirtoconf checks
(except the persistent history one)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.107 2007/01/18 01:03:10 tg Exp $"
d743 1
a743 1
#if !defined(__sun__) && !defined(MKSH_SMALL)
@


1.107
log
@oops, this must of course be a pointer
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.106 2007/01/18 00:10:16 tg Exp $"
#define MKSH_VERSION "R29 2007/01/17"
d44 3
d61 1
a61 1
#if !defined(__sun__)
d77 1
a77 8
#include <unistd.h>

/* extra headers */

#if defined(__sun__) || defined(__INTERIX)
#include <sys/mkdev.h>
#endif
#if !defined(__OpenBSD__) && !defined(__CYGWIN__)
d80 2
a81 1
#if defined(__sun__) || defined(__gnu_linux__)
d91 4
d170 1
a170 1
#if !HAVE_SETMODE && !defined(MKSH_SMALL)
d186 1
a186 1
#define makedev(x,y)	mkdev((x),(y))
a376 4
#if !HAVE_SIG_T
typedef void (*sig_t)(int);
#endif

d742 1
@


1.106
log
@bring back sig_t as void pointer in the rare case we
don't have sighandler_t or __sighandler_t either
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.105 2007/01/17 23:54:39 tg Exp $"
d164 1
a164 1
#define MAP_FAILED -1
@


1.105
log
@scan for sig_t (and friends)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.104 2007/01/17 23:18:55 tg Exp $"
d376 4
@


1.104
log
@if we don't have rlim_t, assume it's long
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.103 2007/01/17 23:10:14 tg Exp $"
a375 4
#if defined(__sun__) || defined(__CYGWIN__)
typedef void (*sig_t)(int);
#endif

@


1.103
log
@Linux missing MAP_FAILED?
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.102 2007/01/17 23:04:19 tg Exp $"
d88 6
@


1.102
log
@<sys/sysmacros.h> contains major/minor/makedev on Linux 2.0
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.101 2007/01/17 22:51:46 tg Exp $"
d157 4
@


1.101
log
@* support old environments without libgen.h (ancient GNU/Linux)
  and stdbool.h (ancient GNU/Linux; NetBSD® 1.6.1)
* __dead must come after, not before, to accomodate gcc 2.7.2.3
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.100 2007/01/17 21:42:23 tg Exp $"
d47 3
@


1.100
log
@check if __RCSID() can be used multiple times; req'd eg. on Mac
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.99 2007/01/17 01:24:29 tg Exp $"
d51 1
d53 1
d62 1
d64 1
d85 7
a132 2
#undef __dead
#define __dead			__attribute__((noreturn))
d1212 2
a1213 1
__dead void yyerror(const char *, ...)
d1223 2
a1224 1
__dead void unwind(int);
d1229 2
a1230 1
__dead void errorf(const char *, ...)
@


1.99
log
@* Build.sh: add -fwrapv to standard CFLAGS, just to be on the safe
  side (I don't have capacities to scan 71711 files in MirOS for a
  standards-compliance whack)
* copyright: mention CVS changelogs as place of contributors' name
  and credit information, too
* check.t, sh.h: bump
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.98 2007/01/15 02:48:27 tg Exp $"
d18 3
@


1.98
log
@shrink .data a little
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.97 2007/01/15 00:38:20 tg Exp $"
#define MKSH_VERSION "R29 2007/01/14"
@


1.97
log
@bump vsn
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.96 2007/01/12 10:18:21 tg Exp $"
d204 2
a205 4
#ifndef EXTERN_DEFINED
static const char initvsn[] = "KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION;
#endif
EXTERN	const char *KSH_VERSION I__(initvsn + 16);
@


1.96
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.95 2007/01/12 02:02:21 tg Exp $"
#define MKSH_VERSION "R29 2007/01/12"
@


1.96.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.113 2007/03/03 21:36:07 tg Exp $"
#define MKSH_VERSION "R29 2007/02/16"
a17 3
#if defined(HAVE_MULTI_IDSTRING) && !HAVE_MULTI_IDSTRING
#undef __RCSID
#endif
a40 3
#if HAVE_SYS_MKDEV_H
#include <sys/mkdev.h>
#endif
a43 3
#if HAVE_SYS_SYSMACROS_H
#include <sys/sysmacros.h>
#endif
a47 1
#if HAVE_LIBGEN_H
a48 1
#endif
d50 1
a50 1
#if HAVE_PATHS_H
a56 1
#if HAVE_STDBOOL_H
a57 1
#endif
a63 3
#if HAVE_ULIMIT_H
#include <ulimit.h>
#endif
a64 3
#if HAVE_VALUES_H
#include <values.h>
#endif
d66 1
a66 1
/* extra types */
d68 2
a69 2
#if !HAVE_RLIM_T
typedef long rlim_t;
d71 2
a72 3

#if !HAVE_SIG_T
typedef void (*sig_t)(int);
d74 2
a75 6

#if !HAVE_STDBOOL_H
/* kludge, but enough for mksh */
typedef int bool;
#define false 0
#define true 1
d119 2
a141 4
#if !defined(MAP_FAILED) && defined(__linux)
#define MAP_FAILED ((void *)-1)
#endif

d144 1
a144 1
#if !HAVE_SETMODE
d160 1
a160 1
#define makedev mkdev
d204 4
a207 2
EXTERN	const char initvsn[] I__("KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION);
#define KSH_VERSION	(initvsn + 16)
d353 4
d722 1
d724 1
d1155 1
a1155 1
#if HAVE_PERSISTENT_HISTORY
d1161 1
a1161 1
#if HAVE_PERSISTENT_HISTORY
d1202 1
a1202 2
void yyerror(const char *, ...)
    __attribute__((noreturn))
d1212 1
a1212 2
void unwind(int)
    __attribute__((noreturn));
d1217 1
a1217 2
void errorf(const char *, ...)
    __attribute__((noreturn))
@


1.96.2.2
log
@begin constification
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.96.2.1 2007/03/03 21:37:59 tg Exp $"
d223 1
a223 1
EXTERN	const char *kshname;	/* $0 */
a233 19
 * Evil hack for const correctness due to API brokenness
 */
union mksh_cchack {
	char *rw;
	const char *ro;
};
union mksh_ccphack {
	char **rw;
	const char **ro;
};
#define cstrchr(s,c) __extension__({	\
	union mksh_cchack in, out;	\
					\
	in.ro = (s);			\
	out.rw = strchr(in.rw, (c));	\
	(out.ro);			\
})

/*
d474 1
a474 1
	const char	*optarg;
d501 2
a502 2
EXTERN const char *builtin_argv0;
EXTERN Tflag builtin_flag;	/* flags of called builtin (SPEC_BI, etc.) */
d607 1
a607 1
		int (*f)(const char **);	/* int function */
d696 1
a696 1
	const char **argv;
d729 1
a729 1
	int (*func)(const char **);
d772 1
a772 1
	const char **args;		/* arguments to a command */
d1113 3
a1115 3
char **eval(const char **, int);
char *evalstr(const char *cp, int);
char *evalonestr(const char *cp, int);
d1117 1
a1117 1
void expand(const char *, XPtrV *, int);
d1124 1
a1124 1
void builtin(const char *, int (*)(const char **));
d1135 13
a1147 13
int c_hash(const char **);
int c_cd(const char **);
int c_pwd(const char **);
int c_print(const char **);
int c_whence(const char **);
int c_command(const char **);
int c_typeset(const char **);
int c_alias(const char **);
int c_unalias(const char **);
int c_let(const char **);
int c_jobs(const char **);
int c_fgbg(const char **);
int c_kill(const char **);
d1149 16
a1164 16
int c_getopts(const char **);
int c_bind(const char **);
int c_label(const char **);
int c_shift(const char **);
int c_umask(const char **);
int c_dot(const char **);
int c_wait(const char **);
int c_read(const char **);
int c_eval(const char **);
int c_trap(const char **);
int c_brkcont(const char **);
int c_exitreturn(const char **);
int c_set(const char **);
int c_unset(const char **);
int c_ulimit(const char **);
int c_times(const char **);
d1167 3
a1169 3
int c_exec(const char **);
int c_builtin(const char **);
int c_test(const char **);
d1177 1
a1177 1
int c_fc(const char **);
d1286 1
a1286 1
int parse_args(const char **, int, int *);
d1294 1
a1294 1
int ksh_getopt(const char **, Getopt *, const char *);
d1365 1
a1365 1
void set_array(const char *, int, const char **);
d1402 1
a1402 1
		const char **wp;/* used by ptest_* */
d1405 1
a1405 1
	const char **wp_end;	/* used by ptest_* */
@


1.96.2.3
log
@more constification
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.96.2.2 2007/03/03 22:38:25 tg Exp $"
d1148 1
a1148 1
int pr_menu(const char *const *);
d1185 1
a1185 1
void timex_hook(struct op *, const char ** volatile *);
@


1.96.2.4
log
@more constification
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.96.2.3 2007/03/03 22:51:18 tg Exp $"
d959 1
a959 1
char *Xcheck_grow_(XString *, const char *, unsigned);
d1004 4
a1007 4
		const char **strv; /* string [] */
		struct shf *shf;   /* shell file */
		struct tbl *tblp;  /* alias (SALIAS) */
		char *freeme;	   /* also for SREREAD */
a1122 8
#define afreechk(s)	do {		\
	if (s)				\
		afree(s, ATEMP);	\
} while (0)
#define afreechv(v,s)	do {		\
	if (v)				\
		afree(s, ATEMP);	\
} while (0)
d1140 1
a1140 1
int shcomexec(const char **);
d1185 1
a1185 1
void timex_hook(struct op *, char ** volatile *);
d1217 1
a1217 1
void settrap(Trap *, const char *);
d1247 1
a1247 1
int include(const char *, int, const char **, int);
d1277 1
a1277 1
int check_fd(const char *, int, const char **);
@


1.95
log
@pasto
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.94 2007/01/12 01:49:28 tg Exp $"
d885 1
a885 1
/* initialize expandable string */
d1056 2
a1057 2
#define ALIAS		BIT(2)	/* recognize alias */
#define KEYWORD		BIT(3)	/* recognize keywords */
@


1.94
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.93 2007/01/12 00:25:40 tg Exp $"
d114 1
a114 1
#define __bound_att(x)		/* nothing */
@


1.93
log
@Clean up the signal mess, saves 172 Bytes:
* 'sigseen' in Build.sh goes away
* Signal name existence is checked in this order:
  have our own¹ -> sys_signame[] -> _sys_signame[] -> build our own²
* Signal description existence is checked in this order:
  sys_siglist[] -> _sys_siglist[] -> strsignal() -> NULL³
¹ Predefined list of items, for operating systems where we
  cannot build² them, i.e. Plan 9 and Minix 3 (e.g. no $CPP -dD)
² The usual cpp(1) stuff
³ Changed later, see below
* Make $CPP test dependent on $NEED_MKSH_SIGNAME (others can
  be added here, this is not absolute)
* Make signal name list generation² dependent on $NEED_MKSH_SIGNAME
* Fix check if the generation worked
* Guarantee that sigtraps[*].name and sigtraps[*].mess are valid
  C strings; this makes the code shorter *and* removes a few pos-
  sible nil pointer dereferences
* Embed autoconf'd usages of sys_sig* / strsignal / mksh_sigpairs
  into inittraps()
* Check for each signal 0<=i<=NSIG that
  name is not NULL or "" -> replace with ("%d", i)
  mess is not NULL or "" -> replace with ("Signal %d", i)
  name does not start (case-insensitive) with "SIG" -> name += 3
* In gettrap(), fix check if signal name starts, case-sensitive
  or case-insensitive, depending on need, with "SIG" (bug from millert@@)

Other changes:
* Build.sh: ac_test[n]() are documented
* Build.sh: ac_test[n]() can have negative prereqs as well now
* Build.sh: use <<-'EOF' consistently
* bump patchlevel to today
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.92 2007/01/11 00:32:31 tg Exp $"
a18 3
#if !defined(__GNUC__) || defined(lint)
#define __attribute__(x)		/* deleted */
#endif
d24 5
d33 1
a33 1
	    __attribute__((used)) = "@@(""#)" #prefix ": " string
d109 15
d1202 2
a1203 2
void yyerror(const char *, ...)
    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
d1212 1
a1212 1
void unwind(int) __attribute__((__noreturn__));
d1217 2
a1218 2
void errorf(const char *, ...)
    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
d1220 1
a1220 1
    __attribute__((__format__ (printf, 2, 3)));
d1222 1
a1222 1
    __attribute__((__format__ (printf, 1, 2)));
d1224 1
a1224 1
    __attribute__((__format__ (printf, 2, 3)));
d1227 1
a1227 1
    __attribute__((__format__ (printf, 1, 2)));
d1229 1
a1229 1
    __attribute__((__format__ (printf, 1, 2)));
d1303 1
a1303 1
    __attribute__((__format__ (printf, 2, 3)));
d1305 2
a1306 2
    __attribute__((__format__ (printf, 3, 4)))
    __attribute__((__bounded__ (__string__,1,2)));
d1308 1
a1308 1
    __attribute__((__format__ (printf, 1, 2)));
d1310 1
a1310 1
    __attribute__((__format__ (printf, 2, 0)));
@


1.92
log
@expand ~foo to getpwnam("foo")->dir only #if !defined(MKSH_SMALL)
this makes it possible to build a (small) mksh on glibc systems statically
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.91 2007/01/06 18:48:27 tg Exp $"
#define MKSH_VERSION "R29 2007/01/11"
@


1.91
log
@use RLIMIT_AS, after much RTFM
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.90 2007/01/06 17:08:14 tg Exp $"
#define MKSH_VERSION "R29 2007/01/06"
d686 1
d688 1
@


1.90
log
@* main.c: prevent segmentation faults on inferiour operating systems
  such as Debian GNU/Linux "etch" 4.0 with not installed locale file
  corresponding to the current environmental settings. ばかたち!
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.89 2007/01/03 22:43:48 tg Exp $"
d122 1
a122 1
#warning portability warning: RLIMIT_AS support
@


1.89
log
@* main.c: when doing the conversion from strcasecmp (wrongly used)
  to strcasestr, it was used in a wrong way (reverse logic error in
  checking its return value), turning to mis-detection of UTF-8 locale.
* sh.h, check.t: bump version
* copyright: bump year
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.88 2006/12/11 16:09:49 tg Exp $"
#define MKSH_VERSION "R29 2007/01/03"
@


1.88
log
@this is mksh, benzday edition (2006/12/07)
last code change was on 12/06
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.87 2006/12/06 13:46:28 tg Exp $"
#define MKSH_VERSION "R29 2006/12/07"
@


1.87
log
@catch up openbsd manpage changes: typos; from alf schlichting,
and revisit the RLIMIT_AS issue
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.86 2006/11/19 20:43:14 tg Exp $"
#define MKSH_VERSION "R29 2006/11/19"
@


1.86
log
@remove the "set -o sh" option (dummy anyway),
"set +o emacs-usemeta" and "set -o vi-show8" which are always on now,
since we have proper internationalisation (i.e. utf-8) support, and
assume the user either has a 'C' locale and can't enter 8-bit chars,
his terminal is 8bit-transparent, or he has a 'UTF-8' locale.
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.85 2006/11/19 16:43:43 tg Exp $"
d121 4
@


1.85
log
@make mksh compatible to the AT&T ksh spec which says, according to
twkm (from #ksh on freenode), that $RANDOM is always an unsigned
15-bit decimal integer.

(RANDOM << 15 | RANDOM) thusly yields 30 bit, which is still more
than 36^5, so we can use it on the baselife CD to speed things up
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.84 2006/11/16 13:35:00 tg Exp $"
a268 1
	FEMACSUSEMETA,	/* use 8th bit as meta */
a287 1
	FSH,		/* -o sh (dummy, for pdksh compatibility) */
a293 1
	FVISHOW8,	/* display chars with 8th bit set as is (versus M-) */
@


1.84
log
@whitespace fixes
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.83 2006/11/12 14:58:15 tg Exp $"
#define MKSH_VERSION "R29 2006/11/12"
@


1.83
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.82 2006/11/12 13:15:26 tg Exp $"
d32 2
a33 2
#define	__RCSID(x)	__IDSTRING(rcsid,x)
#define	__SCCSID(x)	__IDSTRING(sccsid,x)
d79 1
a79 1
#define	timeradd(tvp, uvp, vvp)						\
d90 1
a90 1
#define	timersub(tvp, uvp, vvp)						\
d139 1
a139 1
#define	makedev(x,y)	mkdev((x),(y))
d153 3
a155 3
#define	NELEM(a)	(sizeof (a) / sizeof ((a)[0]))
#define	sizeofN(typ, n)	(sizeof (typ) * (n))
#define	BIT(i)		(1 << (i))	/* define bit in flag */
d160 2
a161 2
#define	NUFILE		32	/* Number of user-accessible files */
#define	FDBASE		10	/* First file usable by Shell */
d167 1
a167 1
#define	MAGIC		(7)	/* prefix for *?[!{,} during expand */
d169 1
a169 1
#define	NOT		'!'	/* might use ^ (ie, [!...] vs [^..]) */
d171 1
a171 1
#define	LINE		4096	/* input line size */
d173 1
a173 1
#define	PATH_MAX	1024	/* pathname size */
d196 2
a197 2
#define	APERM	&aperm
#define	ATEMP	&e->area
d214 7
a220 7
#define	E_NONE	0	/* dummy environment */
#define	E_PARSE	1	/* parsing command # */
#define	E_FUNC	2	/* executing function # */
#define	E_INCL	3	/* including a file via . # */
#define	E_EXEC	4	/* executing command tree */
#define	E_LOOP	5	/* executing for/while # */
#define	E_ERRH	6	/* general error handler # */
d236 1
a236 1
#define	LEXIT	2	/* exit statement */
d240 2
a241 2
#define	LBREAK	6	/* break statement */
#define	LCONTIN	7	/* continue statement */
d401 9
a409 9
#define	C_ALPHA	 BIT(0)		/* a-z_A-Z */
#define	C_DIGIT	 BIT(1)		/* 0-9 */
#define	C_LEX1	 BIT(2)		/* \0 \t\n|&;<>() */
#define	C_VAR1	 BIT(3)		/* *@@#!$-? */
#define	C_IFSWS	 BIT(4)		/* \t \n (IFS white space) */
#define	C_SUBOP1 BIT(5)		/* "=-+?" */
#define	C_QUOTE	 BIT(6)		/*  \n\t"#$&'()*;<>?[]\`| (needing quoting) */
#define	C_IFS	 BIT(7)		/* $IFS */
#define	C_SUBOP2 BIT(8)		/* "#%" (magic, see below) */
d413 1
a413 1
#define	ctype(c, t)	!!( ((t) == C_SUBOP2) ?				\
d585 5
a589 5
#define	ALLOC		BIT(0)	/* val.s has been allocated */
#define	DEFINED		BIT(1)	/* is defined in block */
#define	ISSET		BIT(2)	/* has value, vp->val.[si] */
#define	EXPORT		BIT(3)	/* exported variable/function */
#define	TRACE		BIT(4)	/* var: user flagged, func: execution tracing */
d592 4
a595 4
#define	SPECIAL		BIT(8)	/* PATH, IFS, SECONDS, etc */
#define	INTEGER		BIT(9)	/* val.i contains integer value */
#define	RDONLY		BIT(10)	/* read-only variable */
#define	LOCAL		BIT(11)	/* for local typeset() */
d622 6
a627 6
#define	CNONE	0		/* undefined */
#define	CSHELL	1		/* built-in */
#define	CFUNC	2		/* function */
#define	CEXEC	4		/* executable command */
#define	CALIAS	5		/* alias */
#define	CKEYWD	6		/* keyword */
d695 6
a700 6
#define	V_NONE		0
#define	V_PATH		1
#define	V_IFS		2
#define	V_SECONDS	3
#define	V_OPTIND	4
#define	V_RANDOM	8
d721 3
a723 3
#define	NOBLOCK	((struct op *)NULL)
#define	NOWORD	((char *)NULL)
#define	NOWORDS	((char **)NULL)
d747 7
a753 7
#define	TEOF		0
#define	TCOM		1	/* command */
#define	TPAREN		2	/* (c-list) */
#define	TPIPE		3	/* a | b */
#define	TLIST		4	/* a ; b */
#define	TOR		5	/* || */
#define	TAND		6	/* && */
d756 1
a756 1
#define	TFOR		9
d758 11
a768 11
#define	TCASE		11
#define	TIF		12
#define	TWHILE		13
#define	TUNTIL		14
#define	TELIF		15
#define	TPAT		16	/* pattern in case */
#define	TBRACE		17	/* {c-list} */
#define	TASYNC		18	/* c & */
#define	TFUNCT		19	/* function name { command; } */
#define	TTIME		20	/* time pipeline */
#define	TEXEC		21	/* fork/exec eval'd TCOM */
d774 4
a777 4
#define	EOS	0	/* end of string */
#define	CHAR	1	/* unquoted character */
#define	QCHAR	2	/* quoted character */
#define	COMSUB	3	/* $() substitution (0 terminated) */
d779 4
a782 4
#define	OQUOTE	5	/* opening " or ' */
#define	CQUOTE	6	/* closing " or ' */
#define	OSUBST	7	/* opening ${ subst (followed by { or X) */
#define	CSUBST	8	/* closing } of above (followed by } or X) */
d799 10
a808 10
#define	IOTYPE	0xF	/* type: bits 0:3 */
#define	IOREAD	0x1	/* < */
#define	IOWRITE	0x2	/* > */
#define	IORDWR	0x3	/* <>: todo */
#define	IOHERE	0x4	/* << (here file) */
#define	IOCAT	0x5	/* >> */
#define	IODUP	0x6	/* <&/>& */
#define	IOEVAL	BIT(4)	/* expand in << */
#define	IOSKIP	BIT(5)	/* <<-, skip ^\t* */
#define	IOCLOB	BIT(6)	/* >|, override -o noclobber */
d813 9
a821 9
#define	XEXEC	BIT(0)		/* execute without forking */
#define	XFORK	BIT(1)		/* fork before executing */
#define	XBGND	BIT(2)		/* command & */
#define	XPIPEI	BIT(3)		/* input is pipe */
#define	XPIPEO	BIT(4)		/* output is pipe */
#define	XPIPE	(XPIPEI|XPIPEO)	/* member of pipe */
#define	XXCOM	BIT(5)		/* `...` command */
#define	XPCLOSE	BIT(6)		/* exchild: close close_fd in parent */
#define	XCCLOSE	BIT(7)		/* exchild: close close_fd in child */
d830 4
a833 4
#define	DOBLANK	BIT(0)		/* perform blank interpretation */
#define	DOGLOB	BIT(1)		/* expand [?* */
#define	DOPAT	BIT(2)		/* quote *?[ */
#define	DOTILDE	BIT(3)		/* normal ~ expansion (first char) */
d866 1
a866 1
#define	Xinit(xs, xp, length, area) do { \
d875 1
a875 1
#define	Xput(xs, xp, c)	(*xp++ = (c))
d878 1
a878 1
#define	XcheckN(xs, xp, n) do { \
d888 1
a888 1
#define	Xfree(xs, xp)	afree((void*) (xs).beg, (xs).areap)
d891 1
a891 1
#define	Xclose(xs, xp)	(char*) aresize((void*)(xs).beg, \
d894 1
a894 1
#define	Xstring(xs, xp)	((xs).beg)
d897 1
a897 1
#define	Xlength(xs, xp) ((xp) - (xs).beg)
d899 2
a900 2
#define	Xsavepos(xs, xp) ((xp) - (xs).beg)
#define	Xrestpos(xs, xp, n) ((xs).beg + (n))
d913 1
a913 1
#define	XPinit(x, n) do { \
d920 1
a920 1
#define	XPput(x, p) do { \
d931 2
a932 2
#define	XPptrv(x)	((x).beg)
#define	XPsize(x)	((x).cur - (x).beg)
d934 1
a934 1
#define	XPclose(x)	(void**) aresize((void*)(x).beg, \
d937 1
a937 1
#define	XPfree(x)	afree((void*) (x).beg, ATEMP)
d939 1
a939 1
#define	IDENT	64
d964 2
a965 2
#define	SEOF		0	/* input EOF */
#define	SFILE		1	/* file input */
d967 5
a971 5
#define	SSTRING		3	/* string */
#define	SWSTR		4	/* string without \n */
#define	SWORDS		5	/* string[] */
#define	SWORDSEP	6	/* string[] separator */
#define	SALIAS		7	/* alias expansion */
d983 9
a991 9
#define	SBASE		0	/* outside any lexical constructs */
#define	SWORD		1	/* implicit quoting for substitute() */
#define	SLETPAREN	2	/* inside (( )), implicit quoting */
#define	SSQUOTE		3	/* inside '' */
#define	SDQUOTE		4	/* inside "" */
#define	SBRACE		5	/* inside ${} */
#define	SCSPAREN	6	/* inside $() */
#define	SBQUOTE		7	/* inside `` */
#define	SASPAREN	8	/* inside $(( )) */
d1006 12
a1017 12
#define	LWORD		256
#define	LOGAND		257	/* && */
#define	LOGOR		258	/* || */
#define	BREAK		259	/* ;; */
#define	IF		260
#define	THEN		261
#define	ELSE		262
#define	ELIF		263
#define	FI		264
#define	CASE		265
#define	ESAC		266
#define	FOR		267
d1019 8
a1026 8
#define	WHILE		269
#define	UNTIL		270
#define	DO		271
#define	DONE		272
#define	IN		273
#define	FUNCTION	274
#define	TIME		275
#define	REDIR		276
d1031 1
a1031 1
#define	YYERRCODE	300
d1034 4
a1037 4
#define	CONTIN		BIT(0)	/* skip new lines to complete command */
#define	ONEWORD		BIT(1)	/* single word for substitute() */
#define	ALIAS		BIT(2)	/* recognize alias */
#define	KEYWORD		BIT(3)	/* recognize keywords */
d1044 2
a1045 2
#define	LQCHAR		BIT(10)	/* source string contains QCHAR */
#define	HEREDOC		BIT(11)	/* parsing a here document */
d1047 1
a1047 1
#define	HERES	10		/* max << in line */
@


1.82
log
@unbelievably, cygwin doesn't have strcasestr(3)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.81 2006/11/12 10:44:42 tg Exp $"
d579 1
a579 1
		char *fpath;	/* temporary path to undef function */
d1089 1
a1089 1
char *search(const char *, const char *, int, int *);
d1255 3
a1257 2
void print_columns(struct shf *, int, char *(*)(void *, int, char *, int),
    void *, int, int prefcol);
d1299 1
a1299 1
char *wdscan(const char *, int);
d1316 2
a1317 2
char *skip_varname(const char *, int);
char *skip_wdvarname(const char *, int);
@


1.81
log
@only auto-enable set -o utf8-hack (set -U) for interactive shells
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.80 2006/11/10 07:52:03 tg Exp $"
d127 3
@


1.80
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.79 2006/11/10 07:18:57 tg Exp $"
#define MKSH_VERSION "R29 2006/11/10"
@


1.79
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.78 2006/11/10 06:53:27 tg Exp $"
d404 1
a404 1
#define	C_SUBOP2 BIT(8)		/* "#%" (not realised via chtypes array) */
d406 1
a406 1
#define	C_QUOTE	 BIT(6)		/*  \n\t"#$&'()*;<>?[]\`| (needing quoting) */
d410 5
a414 6
#define	ctype(c, t)	!!(((t) == C_SUBOP2) ? \
			    (((c) == '#' || (c) == '%') ? 1 : 0) : \
			    (chtypes[(unsigned char)(c)]&(t)))
#define	letter(c)	ctype(c, C_ALPHA)
#define	digit(c)	ctype(c, C_DIGIT)
#define	letnum(c)	ctype(c, C_ALPHA|C_DIGIT)
@


1.78
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.77 2006/11/10 06:45:28 tg Exp $"
a42 1
#include <ctype.h>
d107 7
@


1.77
log
@use tolower_() and toupper_() macros (if not available, our quick 'C' ones)
76t 8d 2i
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.76 2006/11/10 06:27:09 tg Exp $"
d102 5
a106 6
#ifndef _tolower
#define _tolower(c)	(((c) >= 'A') && ((c) <= 'Z') ? (c) - 'A' + 'a' : (c))
#endif
#ifndef _toupper
#define _toupper(c)	(((c) >= 'a') && ((c) <= 'z') ? (c) - 'a' + 'A' : (c))
#endif
@


1.76
log
@use setresuid(2) and friends instead, saves 88t 4d 1i
XXX revisit this if we encounter systems without at least
XXX one of setresuid, setresgid, setgroups - only tested on BSD
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.75 2006/11/10 06:16:25 tg Exp $"
d102 7
@


1.75
log
@don't use setreuid(2) etc. stuff, like OpenBSD
only affects suid shell scripts, which are *ugh* anyway,
and I really have no idea what the old code did, when, why, etc.
262t 16d 2i
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.74 2006/11/10 05:23:13 tg Exp $"
a164 3
EXTERN	uid_t kshuid;		/* real uid of shell */
EXTERN	gid_t kshegid;		/* effective gid of shell */
EXTERN	gid_t kshgid;		/* real gid of shell */
@


1.74
log
@if MKSH_SMALL, disable persistent history code as well (like on Solaris,
where it can't work anyway), and fix that code to shrink
saves 2071t 20d 5i
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.73 2006/11/10 03:45:57 tg Exp $"
a1312 1
int eaccess(const char *, int);
@


1.73
log
@correct a few protos and comments
saves 4 .text bytes and my nerves
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.68 2006/11/10 01:13:52 tg Exp $"
d691 1
d693 1
d1124 1
d1126 1
d1130 1
d1132 1
@


1.72
log
@use qsort(3) instead of rolling our own
saves 284 in .text, no added import since we already use qsort(3) once
@
text
@d457 1
a457 1
EXTERN int	current_wd_size;
d1240 1
a1240 1
int strip_nuls(char *, int);
d1243 1
a1243 1
char *ksh_get_wd(char *, int);
@


1.71
log
@* change EXECSHELL to /bin/sh (we can override it via environment anyway,
  and this is a sensible choice instead of ourselves)
* move this stuff from sh.h into exec.c where it belongs
* simplify set -o stuff

saves 8 bytes
@
text
@d1234 1
a1234 2
void qsortp(void **, size_t, int (*)(void *, void *));
int xstrcmp(void *, void *);
@


1.70
log
@cosmetics
@
text
@a137 3
#define EXECSHELL	"/bin/mksh"
#define EXECSHELL_STR	"EXECSHELL"

@


1.69
log
@if !MKSH_SMALL, str_save() can be a macro
@
text
@d141 3
a143 3
#define	NELEM(a)	(sizeof(a) / sizeof((a)[0]))
#define	sizeofN(type, n) (sizeof(type) * (n))
#define	BIT(i)		(1<<(i))	/* define bit in flag */
@


1.68
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.67 2006/11/09 23:55:52 tg Exp $"
d1222 1
d1224 3
@


1.67
log
@get rid of ulton() - a joke
saves 32 bss, but adds 84 text oO
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.66 2006/11/09 23:39:16 tg Exp $"
#define MKSH_VERSION "R29 2006/11/09"
d1185 1
a1185 1
void warningf(int, const char *, ...)
d1191 1
a1191 1
void error_prefix(int);
d1264 9
a1272 4
int shf_fprintf(struct shf *, const char *, ...);
int shf_snprintf(char *, int, const char *, ...);
char *shf_smprintf(const char *, ...);
int shf_vfprintf(struct shf *, const char *, va_list);
@


1.66
log
@shrink chtypes array down to 8 bit
saves 72 text and a lot bss
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.65 2006/11/09 22:18:10 tg Exp $"
a1221 1
char *ulton(unsigned long, int);
@


1.65
log
@don't compile mknod(1) builtin if MKSH_SMALL
saves 1037 text, 20 data (on i386)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.64 2006/11/09 22:11:08 tg Exp $"
d398 1
a398 1
#define	C_SUBOP2 BIT(6)		/* "#%" */
d400 1
a400 1
#define	C_QUOTE	 BIT(8)		/*  \n\t"#$&'()*;<>?[]\`| (needing quoting) */
d402 1
a402 1
extern	short chtypes[];
d404 3
a406 1
#define	ctype(c, t)	!!(chtypes[(unsigned char)(c)]&(t))
@


1.64
log
@more getconf/confstr fixes
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.63 2006/11/09 22:08:08 tg Exp $"
d111 1
a111 1
#if !HAVE_SETMODE
@


1.63
log
@simplify getconf and confstr stuff
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.62 2006/11/09 21:20:49 tg Exp $"
d119 1
a119 1
#if defined(__sun__)
@


1.62
log
@make a few functions static that should be, and optimise a little
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.61 2006/11/09 21:00:13 tg Exp $"
d161 1
a161 4
#define	PATH_MAX	1024	/* pathname size (todo: PATH_MAX/pathconf()) */
#endif
#ifndef _PATH_DEFPATH
#define	_PATH_DEFPATH	"/bin:/usr/bin:/sbin:/usr/sbin"
@


1.61
log
@optional (#ifdef MKSH_SMALL) saving of 364 more bytes of .text
intended e.g. for FreeWRT
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.60 2006/11/09 20:53:42 tg Exp $"
a1063 1
void utf_ptradj(char *, char **);
@


1.60
log
@using a function instead of a macro saves 896 bytes of .text
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.59 2006/11/09 15:03:56 tg Exp $"
d495 4
d503 1
@


1.59
log
@missed these
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.58 2006/11/09 15:02:31 tg Exp $"
d1220 1
a1220 1
#define str_save(s, a)	str_nsave((s), (s) ? strlen(s) : 0, a)
@


1.58
log
@get rid of the need of strlcat() altogether (only one use was left)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.57 2006/11/09 14:58:27 tg Exp $"
a114 3
#if !HAVE_STRLCAT
size_t strlcat(char *, const char *, size_t);
#endif
@


1.57
log
@fix SIGSEGV, we are passed NULL sometimes
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.56 2006/11/09 14:19:31 tg Exp $"
#define MKSH_VERSION "R29 2006/11/08"
@


1.56
log
@optimise and, ahem… plug…
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.55 2006/11/09 00:39:27 tg Exp $"
d1223 1
a1223 1
#define str_save(s, a)	str_nsave((s), strlen(s), a)
@


1.55
log
@add the new function utf_ptradj() which does the same as utf_widthadj()
except it doesn't return a value and is much cheaper (no internal con-
version to UCS-2, just range checking on the multibytes)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.54 2006/11/09 00:11:39 tg Exp $"
d1223 1
a1223 1
char *str_save(const char *, Area *);
@


1.54
log
@* instead of including <sys/cdefs.h> (not in Solaris), we hope <sys/types.h>
  includes it for us
* autoconf-test for <sys/param.h> (not in SUSv3) existence
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.53 2006/11/08 23:50:47 tg Exp $"
d1062 1
@


1.53
log
@can use short form here
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.52 2006/11/08 23:45:47 tg Exp $"
d14 4
a17 1
#include <sys/cdefs.h>
a35 1
#include <sys/param.h>
@


1.52
log
@implement autoconf tests for langstuff; sync date
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.51 2006/11/08 23:23:41 tg Exp $"
d109 1
a109 1
#if !defined(HAVE_SETMODE) || (HAVE_SETMODE == 0)
d113 1
a113 1
#if !defined(HAVE_STRLCAT) || (HAVE_STRLCAT == 0)
d116 1
a116 1
#if !defined(HAVE_STRLCPY) || (HAVE_STRLCPY == 0)
@


1.51
log
@first attempts at more autoconf'isation
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.50 2006/11/05 17:01:47 tg Exp $"
#define MKSH_VERSION "R29 2006/11/05"
@


1.50
log
@make this R29(beta), mksh -U turn on (or setlocale), and document.
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.49 2006/11/05 15:31:37 tg Exp $"
a62 1
#ifdef NEED_COMPAT
d103 3
d109 5
a113 1
#if defined(__gnu_linux__)
d115 2
a123 6
#if defined(__gnu_linux__) || defined(__sun__) || defined(__CYGWIN__)
#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
mode_t getmode(const void *, mode_t);
void *setmode(const char *);
#endif

a128 1
#endif
@


1.49
log
@first part of utf-8 ability in mksh, already works pretty well
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.48 2006/11/05 12:11:14 tg Exp $"
#define MKSH_VERSION "R28 2006/11/05"
d286 1
a286 1
	FUTFHACK,	/* utf-8 hack for command line editing */
@


1.48
log
@add new "set -o utf8-hack", currently no effect
set automatically on startup if we have locale functions (on MirOS)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.47 2006/10/03 19:46:14 tg Exp $"
d1056 3
@


1.47
log
@use the same idstring stuff everywhere, makes sense
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.46 2006/09/30 02:23:22 tg Exp $"
#define MKSH_VERSION "R28 2006/09/30"
d286 1
@


1.46
log
@sync with src/sys/sys/cdefs.h,v 1.11
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.45 2006/09/30 02:13:21 tg Exp $"
d28 1
a28 1
	    __attribute__((used)) = "@@(""#)" string
@


1.45
log
@* avoid unaligned memory access causing SIGBUS on IA-64 (Itanic)
  (incidentally, the information xor'd now is more random)
  only affects non-arc4random targets
* bump version
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.44 2006/09/21 22:05:46 tg Exp $"
d14 1
a14 2
#include <sys/param.h>

d17 1
a17 1
#define __attribute__(x) /* deleted */
d20 4
d26 1
a26 1
#define	__IDSTRING(prefix, string)				\
d28 1
a28 2
	    __attribute__((used)) = (string)
#ifndef __RCSID
a29 2
#endif
#ifndef __SCCSID
a31 1
#endif
d33 1
@


1.44
log
@pasto: forgot these
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.43 2006/09/21 22:03:23 tg Exp $"
#define MKSH_VERSION "R28 2006/08/28"
@


1.43
log
@use the easier __RCSID() etc. stuff from current <sys/cdefs.h>
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.42 2006/08/28 01:40:54 tg Exp $"
d21 2
@


1.42
log
@bump version

our regression tests:
Total failed: 1 (as expected)
Total passed: 213

the IFS testsuite:
# tests 6856 passed 5192 failed 1664
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.41 2006/08/26 20:30:27 tg Exp $"
d16 8
d25 5
a29 1
#define	__RCSID(x)	static const char __rcsid[] __attribute__((used)) = (x)
@


1.41
log
@use an autoconf-like approach to check for arc4random(3)
after gecko2 told me his mac recently has it and I found
out that Interix has it in -lcrypt and soon -lmirmake (:
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.40 2006/08/24 20:35:40 tg Exp $"
#define MKSH_VERSION "R28 2006/08/26"
@


1.40
log
@bump version (hey, after all, I fixed the persistent history*!)
and that after submitting it to the FSF/UNESCO directory...

*) regression test for that? how?
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.39 2006/08/22 22:49:37 tg Exp $"
#define MKSH_VERSION "R28 2006/08/24"
a1344 18

#ifndef HAVE_ARC4RANDOM
#if defined(__gnu_linux__) || defined(__INTERIX) || defined(__sun__) \
    || (defined(__NetBSD__) && (__NetBSD_Version__ < 106020000)) \
    || defined(__CYGWIN__)
#define HAVE_ARC4RANDOM 0
#else
#define HAVE_ARC4RANDOM 1
#endif
#endif

#ifndef HAVE_ARC4RANDOM_PUSH
#if defined(__MirBSD__) && (MirBSD >= 0x07AD)
#define HAVE_ARC4RANDOM_PUSH 1
#else
#define HAVE_ARC4RANDOM_PUSH 0
#endif
#endif
@


1.39
log
@* remove redundancy
* integrate compat.h, version.h into sh.h (dependency trick didn't work anyway)
* mention #ksh in mksh(1) since the founder (twkm) said it's on topic too
  (don't remove mention of #mksh despite it's usually empty because of control)
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.38 2006/08/22 22:22:07 tg Exp $"
#define MKSH_VERSION "R28 2006/08/22"
@


1.38
log
@compat.h does have the status of a system header though...
@
text
@d11 2
a12 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.37 2006/08/22 22:21:20 tg Exp $"
d48 66
a113 1
#include "compat.h"
a122 1
#include "version.h"
d163 4
@


1.37
log
@save more whitespace and make it compile again (oops)
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.36 2006/08/22 22:16:04 tg Exp $"
d47 1
a56 2

#include "compat.h"
@


1.36
log
@* version.h doesn't need an RCS ID
* compat.h does, add it to misc.c, always include it, move if NEED_COMPAT
* major whitespace cleanup in sh.h
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.35 2006/08/16 00:00:24 tg Exp $"
a46 2
#include "compat.h"
#include "version.h"
d57 3
d68 1
a68 1
typedef int32_t		Tflag;
d107 1
a107 1
EXTERN	Area	aperm;		/* permanent object space */
d114 9
a122 9
EXTERN	struct env {
	short type;			/* environment type - see below */
	short flags;			/* EF_* */
	Area area;			/* temporary allocation area */
	struct block *loc;		/* local variables and functions */
	short *savefd;			/* original redirected fds */
	struct env *oenv;		/* link to previous environment */
	sigjmp_buf jbuf;		/* long jump back to env creator */
	struct temp *temps;		/* temp files */
d126 7
a132 7
#define	E_NONE	0		/* dummy environment */
#define	E_PARSE	1		/* parsing command # */
#define	E_FUNC	2		/* executing function # */
#define	E_INCL	3		/* including a file via . # */
#define	E_EXEC	4		/* executing command tree */
#define	E_LOOP	5		/* executing for/while # */
#define	E_ERRH	6		/* general error handler # */
d147 9
a155 9
#define LRETURN	1		/* return statement */
#define	LEXIT	2		/* exit statement */
#define LERROR	3		/* errorf() called */
#define LLEAVE	4		/* untrappable exit/error */
#define LINTR	5		/* ^C noticed */
#define	LBREAK	6		/* break statement */
#define	LCONTIN	7		/* continue statement */
#define LSHELL	8		/* return to interactive shell() */
#define LAEXPR	9		/* error in arithmetic expression */
d232 1
a232 1
	int pid;		/* pid of process parsed here-doc */
d600 12
a611 12
#define	V_NONE			0
#define	V_PATH			1
#define	V_IFS			2
#define	V_SECONDS		3
#define	V_OPTIND		4
#define	V_RANDOM		8
#define V_HISTSIZE		9
#define V_HISTFILE		10
#define V_COLUMNS		13
#define V_TMOUT			15
#define V_TMPDIR		16
#define V_LINENO		17
d614 2
a615 2
#define PS1	0		/* command */
#define PS2	1		/* command continuation */
d677 12
a688 12
#define	EOS	0		/* end of string */
#define	CHAR	1		/* unquoted character */
#define	QCHAR	2		/* quoted character */
#define	COMSUB	3		/* $() substitution (0 terminated) */
#define EXPRSUB	4		/* $(()) substitution (0 terminated) */
#define	OQUOTE	5		/* opening " or ' */
#define	CQUOTE	6		/* closing " or ' */
#define	OSUBST	7		/* opening ${ subst (followed by { or X) */
#define	CSUBST	8		/* closing } of above (followed by } or X) */
#define OPAT	9		/* open pattern: *(, @@(, etc. */
#define SPAT	10		/* separate pattern: | */
#define CPAT	11		/* close pattern: ) */
d702 12
a713 12
#define	IOTYPE	0xF		/* type: bits 0:3 */
#define	IOREAD	0x1		/* < */
#define	IOWRITE	0x2		/* > */
#define	IORDWR	0x3		/* <>: todo */
#define	IOHERE	0x4		/* << (here file) */
#define	IOCAT	0x5		/* >> */
#define	IODUP	0x6		/* <&/>& */
#define	IOEVAL	BIT(4)		/* expand in << */
#define	IOSKIP	BIT(5)		/* <<-, skip ^\t* */
#define	IOCLOB	BIT(6)		/* >|, override -o noclobber */
#define IORDUP	BIT(7)		/* x<&y (as opposed to x>&y) */
#define IONAMEXP BIT(8)		/* name has been expanded */
d752 5
a756 5
#define DB_NORM	1		/* normal argument */
#define DB_OR	2		/* || -> -o conversion */
#define DB_AND	3		/* && -> -a conversion */
#define DB_BE	4		/* an inserted -BE */
#define DB_PAT	5		/* a pattern argument */
d758 1
a758 1
#define X_EXTRA		8	/* this many extra bytes in X string */
@


1.35
log
@compat.h has a section 'extra headers', move inttypes.h there
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.34 2006/08/15 23:54:09 tg Exp $"
a46 1
#if defined(NEED_COMPAT)
d48 1
a48 1
#endif
d73 1
a73 1
 * not a char that is used often.  Also, can't use the high bit as it causes
d88 9
a96 9
EXTERN	char *	kshname;	/* $0 */
EXTERN	pid_t	kshpid;		/* $$, shell pid */
EXTERN	pid_t	procpid;	/* pid of executing process */
EXTERN	uid_t	ksheuid;	/* effective uid of shell */
EXTERN	uid_t	kshuid;		/* real uid of shell */
EXTERN	gid_t	kshegid;	/* effective gid of shell */
EXTERN	gid_t	kshgid;		/* real gid of shell */
EXTERN	int	exstat;		/* exit status */
EXTERN	int	subst_exstat;	/* exit status of last $(..)/`..` */
d114 6
a119 6
	short	type;			/* environment type - see below */
	short	flags;			/* EF_* */
	Area	area;			/* temporary allocation area */
	struct	block *loc;		/* local variables and functions */
	short  *savefd;			/* original redirected fds */
	struct	env *oenv;		/* link to previous environment */
d165 3
a167 3
    const char	*name;	/* long name of option */
    char	c;	/* character flag (if any) */
    short	flags;	/* OF_* */
d227 1
a227 1
/* temp/heredoc files.  The file is removed when the struct is freed. */
d229 5
a233 5
	struct temp	*next;
	struct shf	*shf;
	int		pid;		/* pid of process parsed here-doc */
	Temp_type	type;
	char		*name;
d253 1
a253 1
	int	signal;		/* signal number */
d256 1
a256 1
	char   *trap;		/* trap command */
d258 1
a258 1
	int	flags;		/* TF_* */
d359 6
a364 6
	int	read;		/* pipe from co-process's stdout */
	int	readw;		/* other side of read (saved temporarily) */
	int	write;		/* pipe to co-process's stdin */
	Coproc_id id;		/* id of current output pipe */
	int	njobs;		/* number of live jobs using output pipe */
	void    *job;           /* 0 or job of co-process using input pipe */
d460 3
a462 3
	Area   *areap;		/* area to allocate entries */
	short	size, nfree;	/* hash size (always 2^^n), free entries */
	struct	tbl **tbls;	/* hashed table items */
d466 2
a467 2
	Tflag	flag;		/* flags */
	int	type;		/* command type (see below), base (if INTEGER),
d469 1
a469 1
	Area	*areap;		/* area to allocate from */
d476 1
a476 1
	int	index;		/* index for an array */
d478 2
a479 2
	    int	field;		/* field with for -L/-R/-Z */
	    int errno_;		/* CEXEC/CTALIAS */
d483 1
a483 1
		char *fpath;		/* temporary path to undef function */
d485 1
a485 1
	char	name[4];	/* name -- variable length */
d520 1
a520 1
 * should be repoted by set/typeset).  Does not include ARRAY or LOCAL.
d549 1
a549 1
/* Argument info.  Used for $#, $* for shell, functions, includes, etc. */
d561 10
a570 11
	Area	area;		/* area to allocate things */
	/*struct arg_info argi;*/
	char	**argv;
	int	argc;
	int	flags;		/* see BF_* */
	struct	table vars;	/* local variables */
	struct	table funs;	/* local functions */
	Getopt	getopts_state;
	char *	error;		/* error handler */
	char *	exit;		/* exit handler */
	struct	block *next;	/* enclosing block */
d592 2
a593 2
	const char   *name;
	int  (*func)(char **);
d631 1
a631 1
	short	type;			/* operation type, see below */
d633 2
a634 2
		short	evalflags;	/* TCOM: arg expansion eval() flags */
		short	ksh_func;	/* TFUNC: function x (vs x()) */
d636 3
a638 3
	char  **args;			/* arguments to a command */
	char  **vars;			/* variable assignments */
	struct ioword	**ioact;	/* IO actions (eg, < > >>) */
d640 1
a640 1
	char   *str;			/* word for case; identifier for for,
d645 1
a645 1
	int	lineno;			/* TCOM/TFUNC: LINENO for this */
d749 1
a749 1
 * is examined.  The DB_* defines are the values for these second characters.
d760 3
a762 3
	char   *end, *beg;	/* end, begin of string */
	size_t	len;		/* length */
	Area	*areap;		/* area to allocate/free from */
d781 3
a783 3
		    int more = ((xp) + (n)) - (xs).end; \
		    if (more > 0) \
			xp = Xcheck_grow_(&xs, xp, more); \
d804 1
a804 1
char *	Xcheck_grow_(XString *, char *, unsigned);
d811 2
a812 2
	void  **cur;		/* next avail pointer */
	void  **beg, **end;	/* begin, end of vector */
d826 1
a826 1
						   sizeofN(void*, n*2), ATEMP); \
d900 3
a902 3
	int	i;
	char   *cp;
	char  **wp;
d958 3
a960 3
EXTERN	char  **history;	/* saved commands */
EXTERN	char  **histptr;	/* last history item */
EXTERN	int	histsize;	/* history size */
d963 5
a967 5
Area *	ainit(Area *);
void	afreeall(Area *);
void *	alloc(size_t, Area *);
void *	aresize(void *, size_t, Area *);
void	afree(void *, Area *);
d969 3
a971 3
void	x_init(void);
int	x_read(char *, size_t);
int	x_bind(const char *, const char *, int, int);
d973 7
a979 7
char *	substitute(const char *, int);
char **	eval(char **, int);
char *	evalstr(char *cp, int);
char *	evalonestr(char *cp, int);
char	*debunk(char *, const char *, size_t);
void	expand(char *, XPtrV *, int);
int	glob_str(char *, XPtrV *, int);
d981 11
a991 11
int	execute(struct op * volatile, volatile int);
int	shcomexec(char **);
struct tbl * findfunc(const char *, unsigned int, int);
int	define(const char *, struct op *);
void	builtin(const char *, int (*)(char **));
struct tbl *	findcom(const char *, int);
void	flushcom(int);
char *	search(const char *, const char *, int, int *);
int	search_access(const char *, int, int *);
int	pr_menu(char *const *);
int	pr_list(char *const *);
d993 2
a994 2
int	evaluate(const char *, long *, int, bool);
int	v_evaluate(struct tbl *, const char *, volatile int, bool);
d996 35
a1030 35
int	c_hash(char **);
int	c_cd(char **);
int	c_pwd(char **);
int	c_print(char **);
int	c_whence(char **);
int	c_command(char **);
int	c_typeset(char **);
int	c_alias(char **);
int	c_unalias(char **);
int	c_let(char **);
int	c_jobs(char **);
int	c_fgbg(char **);
int	c_kill(char **);
void	getopts_reset(int);
int	c_getopts(char **);
int	c_bind(char **);
int	c_label(char **);
int	c_shift(char **);
int	c_umask(char **);
int	c_dot(char **);
int	c_wait(char **);
int	c_read(char **);
int	c_eval(char **);
int	c_trap(char **);
int	c_brkcont(char **);
int	c_exitreturn(char **);
int	c_set(char **);
int	c_unset(char **);
int	c_ulimit(char **);
int	c_times(char **);
int	timex(struct op *, int);
void	timex_hook(struct op *, char ** volatile *);
int	c_exec(char **);
int	c_builtin(char **);
int	c_test(char **);
d1032 28
a1059 28
void	init_histvec(void);
void	hist_init(Source *);
void	hist_finish(void);
void	histsave(int, const char *, int);
int	c_fc(char **);
void	sethistsize(int);
void	sethistfile(const char *);
char **	histpos(void);
int	histnum(int);
int	findhist(int, int, const char *, int);
int	findhistrel(const char *);
char  **hist_get_newest(int);
void	inittraps(void);
void	alarm_init(void);
Trap *	gettrap(const char *, int);
void	trapsig(int);
void	intrcheck(void);
int	fatal_trap_check(void);
int	trap_pending(void);
void	runtraps(int intr);
void	runtrap(Trap *);
void	cleartraps(void);
void	restoresigs(void);
void	settrap(Trap *, char *);
int	block_pipe(void);
void	restore_pipe(int);
int	setsig(Trap *, sig_t, int);
void	setexecsig(Trap *, int);
d1061 14
a1074 14
void	j_init(int);
void	j_exit(void);
void	j_change(void);
int	exchild(struct op *, int, int);
void	startlast(void);
int	waitlast(void);
int	waitfor(const char *, int *);
int	j_kill(const char *, int);
int	j_resume(const char *, int);
int	j_jobs(const char *, int, int);
int	j_njobs(void);
void	j_notify(void);
pid_t	j_async(void);
int	j_stopped_running(void);
d1076 7
a1082 7
int	yylex(int);
void	yyerror(const char *, ...)
	    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
Source * pushs(int, Area *);
void	set_prompt(int, Source *);
void	pprompt(const char *, int);
int	promptlen(const char *);
d1084 35
a1118 35
int	include(const char *, int, char **, int);
int	command(const char *);
int	shell(Source *volatile, int volatile);
void	unwind(int) __attribute__((__noreturn__));
void	newenv(int);
void	quitenv(struct shf *);
void	cleanup_parents_env(void);
void	cleanup_proc_env(void);
void	errorf(const char *, ...)
	    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
void	warningf(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	bi_errorf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	internal_errorf(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	error_prefix(int);
void	shellf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	shprintf(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
int	can_seek(int);
void	initio(void);
int	ksh_dup2(int, int, int);
int	savefd(int);
void	restfd(int, int);
void	openpipe(int *);
void	closepipe(int *);
int	check_fd(char *, int, const char **);
void	coproc_init(void);
void	coproc_read_close(int);
void	coproc_readw_close(int);
void	coproc_write_close(int);
int	coproc_getfd(int, const char **);
void	coproc_cleanup(int);
d1120 8
a1127 8
unsigned int	hash(const char *);
void		ktinit(struct table *, Area *, int);
struct tbl *	ktsearch(struct table *, const char *, unsigned int);
struct tbl *	ktenter(struct table *, const char *, unsigned int);
void		ktdelete(struct tbl *);
void		ktwalk(struct tstate *, struct table *);
struct tbl *	ktnext(struct tstate *);
struct tbl **	ktsort(struct table *);
d1129 20
a1148 21
void	setctypes(const char *, int);
void	initctypes(void);
char *	ulton(unsigned long, int);
char *	str_save(const char *, Area *);
char *	str_nsave(const char *, int, Area *);
int	option(const char *);
char *	getoptions(void);
void	change_flag(enum sh_flag, int, int);
int	parse_args(char **, int, int *);
int	getn(const char *, int *);
int	bi_getn(const char *, int *);
int	gmatchx(const char *, const char *, int);
int	has_globbing(const char *, const char *);
const unsigned char *pat_scan(const unsigned char *, const unsigned char *,
    int);
void	qsortp(void **, size_t, int (*)(void *, void *));
int	xstrcmp(void *, void *);
void	ksh_getopt_reset(Getopt *, int);
int	ksh_getopt(char **, Getopt *, const char *);
void	print_value_quoted(const char *);
void	print_columns(struct shf *, int, char *(*)(void *, int, char *, int),
d1150 8
a1157 8
int	strip_nuls(char *, int);
int	blocking_read(int, char *, int);
int	reset_nonblock(int);
char	*ksh_get_wd(char *, int);
int	make_path(const char *, const char *, char **, XString *, int *);
void	simplify_path(char *);
char	*get_phys_path(const char *);
void	set_current_wd(char *);
d1163 15
a1177 15
int	shf_close(struct shf *);
int	shf_fdclose(struct shf *);
char *	shf_sclose(struct shf *);
int	shf_flush(struct shf *);
int	shf_read(char *, int, struct shf *);
char *	shf_getse(char *, int, struct shf *);
int	shf_getchar(struct shf *s);
int	shf_ungetc(int, struct shf *);
int	shf_putchar(int, struct shf *);
int	shf_puts(const char *, struct shf *);
int	shf_write(const char *, int, struct shf *);
int	shf_fprintf(struct shf *, const char *, ...);
int	shf_snprintf(char *, int, const char *, ...);
char *	shf_smprintf(const char *, ...);
int	shf_vfprintf(struct shf *, const char *, va_list);
d1179 2
a1180 2
void	initkeywords(void);
struct op * compile(Source *);
d1182 7
a1188 7
int	fptreef(struct shf *, int, const char *, ...);
char *	snptreef(char *, int, const char *, ...);
struct op *	tcopy(struct op *, Area *);
char *	wdcopy(const char *, Area *);
char *	wdscan(const char *, int);
char *	wdstrip(const char *);
void	tfree(struct op *, Area *);
d1190 8
a1197 8
void	newblock(void);
void	popblock(void);
void	initvar(void);
struct tbl *	global(const char *);
struct tbl *	local(const char *, bool);
char *	str_val(struct tbl *);
long	intval(struct tbl *);
int	setstr(struct tbl *, const char *, int);
d1199 14
a1212 14
void	setint(struct tbl *, long);
int	getint(struct tbl *, long *, bool);
struct tbl *	typeset(const char *, Tflag, Tflag, int, int);
void	unset(struct tbl *, int);
char  * skip_varname(const char *, int);
char	*skip_wdvarname(const char *, int);
int	is_wdvarname(const char *, int);
int	is_wdvarassign(const char *);
char **	makenv(void);
void	change_random(void);
int	array_ref_len(const char *);
char *	arrayname(const char *);
void    set_array(const char *, int, char **);
int	eaccess(const char *, int);
d1247 1
a1247 1
	int	flags;		/* TEF_* */
d1249 2
a1250 2
		char	**wp;		/* used by ptest_* */
		XPtrV	*av;		/* used by dbtestp_* */
d1252 2
a1253 2
	char **wp_end;			/* used by ptest_* */
	int	(*isa)(Test_env *, Test_meta);
d1255 2
a1256 2
	int	(*eval)(Test_env *, Test_op, const char *, const char *, int);
	void	(*error)(Test_env *, int, const char *);
d1260 2
a1261 2
int     test_eval(Test_env *, Test_op, const char *, const char *, int);
int	test_parse(Test_env *);
d1263 3
a1265 3
EXTERN int		tty_fd I__(-1);	/* dup'd tty file descriptor */
EXTERN int		tty_devtty;	/* true if tty_fd is from /dev/tty */
EXTERN struct termios	tty_state;	/* saved tty state */
d1267 2
a1268 4
extern void	tty_init(int);
extern void	tty_close(void);

#include "version.h"
d1281 1
a1281 1
#define	HAVE_ARC4RANDOM	0
d1283 1
a1283 1
#define	HAVE_ARC4RANDOM	1
@


1.34
log
@interix doesn't have <inttypes.h>, openbsd no <stdint.h>, the old chaos.
so add <inttypes.h> only for the one platform which needs it today, APE.
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.33 2006/08/15 23:43:30 tg Exp $"
a29 3
#if defined(__Plan9__)
#include <inttypes.h>
#endif
@


1.33
log
@minor cleanups from the porting work
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.32 2006/08/09 20:44:16 tg Exp $"
d30 1
d32 1
@


1.33.2.1
log
@initial attempt at porting mksh to the Plan 9 ANSI'n'POSIX Environment
struck dumb at SIGWINCH/TIOCGWINSZ, we'll have to ifdef out all of the
command line editing code as a next measure

incidentally, my qemu just crashed (not the guest OS - Plan 9 - no, it
really crashed the "outside" qemu programme, won't redraw or catch the
mouse any more), so I'll call it a day
@
text
@a12 4
#if defined(__Plan9__) && !defined(__GNUC__)
#define __attribute__(x) /* nothing */
#endif

a19 1
#if !defined(__Plan9__)
a20 1
#endif
a21 1
#if !defined(__Plan9__)
a22 1
#endif
a30 1
#if !defined(__Plan9__)
a31 1
#endif
d33 1
a33 1
#if !defined(__sun__) && !defined(__Plan9__)
a39 1
#if !defined(__Plan9__)
a40 5
#else
typedef int bool;
#define true 1
#define false 0
#endif
d247 1
a247 1
#if defined(__sun__) || defined(__CYGWIN__) || defined(__Plan9__)
d1286 1
a1286 1
    || defined(__CYGWIN__) || defined(__Plan9__)
@


1.33.2.2
log
@merge diffs between tg-mksh-plan9ape_BASE and current HEAD
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.33.2.1 2006/08/15 23:49:53 tg Exp $"
d38 1
@


1.33.2.3
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d11 1
a11 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.40 2006/08/24 20:35:40 tg Exp $"
#define MKSH_VERSION "R28 2006/08/24"
d63 2
a64 78

#ifdef NEED_COMPAT
/* extra headers */

#if defined(__sun__) || defined(__INTERIX)
#include <sys/mkdev.h>
#endif
#if defined(__Plan9__)
#include <inttypes.h>
#endif
#if !defined(__OpenBSD__) && !defined(__CYGWIN__) && !defined(__Plan9__)
#include <ulimit.h>
#endif
#if defined(__sun__) || defined(__gnu_linux__)
#include <values.h>
#endif

/* extra macros */

#ifndef timeradd
#define	timeradd(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (0)
#endif
#ifndef timersub
#define	timersub(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (0)
#endif

#ifndef S_ISTXT
#define S_ISTXT 0001000
#endif

#ifdef __Plan9__
#define S_ISLNK(x)	0
#define S_ISSOCK(x)	0
#define killpg(p,s)	kill(-(p), (s))
#endif

/* OS-dependent additions */

#if defined(__gnu_linux__) || defined(__Plan9__)
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
#endif

#if defined(__sun__)
size_t confstr(int, char *, size_t);
#endif

#if defined(__gnu_linux__) || defined(__sun__) || defined(__CYGWIN__)
#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
mode_t getmode(const void *, mode_t);
void *setmode(const char *);
#endif

#ifdef __INTERIX
#define	makedev(x,y)	mkdev((x),(y))
extern int __cdecl seteuid(uid_t);
extern int __cdecl setegid(gid_t);
#endif

#if defined(__Plan9__)
typedef unsigned char u_char;
#endif
d84 1
a84 1
typedef int32_t Tflag;
d90 1
a90 1
 * not a char that is used often. Also, can't use the high bit as it causes
d105 9
a113 9
EXTERN	char *kshname;		/* $0 */
EXTERN	pid_t kshpid;		/* $$, shell pid */
EXTERN	pid_t procpid;		/* pid of executing process */
EXTERN	uid_t ksheuid;		/* effective uid of shell */
EXTERN	uid_t kshuid;		/* real uid of shell */
EXTERN	gid_t kshegid;		/* effective gid of shell */
EXTERN	gid_t kshgid;		/* real gid of shell */
EXTERN	int exstat;		/* exit status */
EXTERN	int subst_exstat;	/* exit status of last $(..)/`..` */
a114 4
#ifndef EXTERN_DEFINED
static const char initvsn[] = "KSH_VERSION=@@(#)MIRBSD KSH " MKSH_VERSION;
#endif
EXTERN	const char *KSH_VERSION I__(initvsn + 16);
d123 1
a123 1
EXTERN Area aperm;		/* permanent object space */
d130 9
a138 9
EXTERN struct env {
	short type;		/* environment type - see below */
	short flags;		/* EF_* */
	Area area;		/* temporary allocation area */
	struct block *loc;	/* local variables and functions */
	short *savefd;		/* original redirected fds */
	struct env *oenv;	/* link to previous environment */
	sigjmp_buf jbuf;	/* long jump back to env creator */
	struct temp *temps;	/* temp files */
d142 7
a148 7
#define	E_NONE	0	/* dummy environment */
#define	E_PARSE	1	/* parsing command # */
#define	E_FUNC	2	/* executing function # */
#define	E_INCL	3	/* including a file via . # */
#define	E_EXEC	4	/* executing command tree */
#define	E_LOOP	5	/* executing for/while # */
#define	E_ERRH	6	/* general error handler # */
d163 9
a171 9
#define LRETURN	1	/* return statement */
#define	LEXIT	2	/* exit statement */
#define LERROR	3	/* errorf() called */
#define LLEAVE	4	/* untrappable exit/error */
#define LINTR	5	/* ^C noticed */
#define	LBREAK	6	/* break statement */
#define	LCONTIN	7	/* continue statement */
#define LSHELL	8	/* return to interactive shell() */
#define LAEXPR	9	/* error in arithmetic expression */
d182 3
a184 3
	const char *name;	/* long name of option */
	char c;			/* character flag (if any) */
	short flags;		/* OF_* */
d244 1
a244 1
/* temp/heredoc files. The file is removed when the struct is freed. */
d246 5
a250 5
	struct temp *next;
	struct shf *shf;
	int pid;	/* pid of process parsed here-doc */
	Temp_type type;
	char *name;
d270 1
a270 1
	int signal;		/* signal number */
d273 1
a273 1
	char *trap;		/* trap command */
d275 1
a275 1
	int flags;		/* TF_* */
d376 6
a381 6
	int read;	/* pipe from co-process's stdout */
	int readw;	/* other side of read (saved temporarily) */
	int write;	/* pipe to co-process's stdin */
	Coproc_id id;	/* id of current output pipe */
	int njobs;	/* number of live jobs using output pipe */
	void *job;	/* 0 or job of co-process using input pipe */
d477 3
a479 3
	Area *areap;		/* area to allocate entries */
	short size, nfree;	/* hash size (always 2^^n), free entries */
	struct tbl **tbls;	/* hashed table items */
d483 2
a484 2
	Tflag flag;		/* flags */
	int type;		/* command type (see below), base (if INTEGER),
d486 1
a486 1
	Area *areap;		/* area to allocate from */
d493 1
a493 1
	int index;		/* index for an array */
d495 2
a496 2
		int field;	/* field with for -L/-R/-Z */
		int errno_;	/* CEXEC/CTALIAS */
d500 1
a500 1
		char *fpath;	/* temporary path to undef function */
d502 1
a502 1
	char name[4];		/* name -- variable length */
d537 1
a537 1
 * should be repoted by set/typeset). Does not include ARRAY or LOCAL.
d566 1
a566 1
/* Argument info. Used for $#, $* for shell, functions, includes, etc. */
d578 11
a588 10
	Area area;		/* area to allocate things */
	char **argv;
	int argc;
	int flags;		/* see BF_* */
	struct table vars;	/* local variables */
	struct table funs;	/* local functions */
	Getopt getopts_state;
	char *error;		/* error handler */
	char *exit;		/* exit handler */
	struct block *next;	/* enclosing block */
d610 2
a611 2
	const char *name;
	int (*func)(char **);
d617 12
a628 12
#define	V_NONE		0
#define	V_PATH		1
#define	V_IFS		2
#define	V_SECONDS	3
#define	V_OPTIND	4
#define	V_RANDOM	8
#define V_HISTSIZE	9
#define V_HISTFILE	10
#define V_COLUMNS	13
#define V_TMOUT		15
#define V_TMPDIR	16
#define V_LINENO	17
d631 2
a632 2
#define PS1	0	/* command */
#define PS2	1	/* command continuation */
d649 1
a649 1
	short type;			/* operation type, see below */
d651 2
a652 2
		short evalflags;	/* TCOM: arg expansion eval() flags */
		short ksh_func;		/* TFUNC: function x (vs x()) */
d654 3
a656 3
	char **args;			/* arguments to a command */
	char **vars;			/* variable assignments */
	struct ioword **ioact;		/* IO actions (eg, < > >>) */
d658 1
a658 1
	char *str;			/* word for case; identifier for for,
d663 1
a663 1
	int lineno;			/* TCOM/TFUNC: LINENO for this */
d694 12
a705 12
#define	EOS	0	/* end of string */
#define	CHAR	1	/* unquoted character */
#define	QCHAR	2	/* quoted character */
#define	COMSUB	3	/* $() substitution (0 terminated) */
#define EXPRSUB	4	/* $(()) substitution (0 terminated) */
#define	OQUOTE	5	/* opening " or ' */
#define	CQUOTE	6	/* closing " or ' */
#define	OSUBST	7	/* opening ${ subst (followed by { or X) */
#define	CSUBST	8	/* closing } of above (followed by } or X) */
#define OPAT	9	/* open pattern: *(, @@(, etc. */
#define SPAT	10	/* separate pattern: | */
#define CPAT	11	/* close pattern: ) */
d719 12
a730 12
#define	IOTYPE	0xF	/* type: bits 0:3 */
#define	IOREAD	0x1	/* < */
#define	IOWRITE	0x2	/* > */
#define	IORDWR	0x3	/* <>: todo */
#define	IOHERE	0x4	/* << (here file) */
#define	IOCAT	0x5	/* >> */
#define	IODUP	0x6	/* <&/>& */
#define	IOEVAL	BIT(4)	/* expand in << */
#define	IOSKIP	BIT(5)	/* <<-, skip ^\t* */
#define	IOCLOB	BIT(6)	/* >|, override -o noclobber */
#define IORDUP	BIT(7)	/* x<&y (as opposed to x>&y) */
#define IONAMEXP BIT(8)	/* name has been expanded */
d767 1
a767 1
 * is examined. The DB_* defines are the values for these second characters.
d769 5
a773 5
#define DB_NORM	1	/* normal argument */
#define DB_OR	2	/* || -> -o conversion */
#define DB_AND	3	/* && -> -a conversion */
#define DB_BE	4	/* an inserted -BE */
#define DB_PAT	5	/* a pattern argument */
d775 1
a775 1
#define X_EXTRA	8	/* this many extra bytes in X string */
d778 3
a780 3
	char *end, *beg;	/* end, begin of string */
	size_t len;		/* length */
	Area *areap;		/* area to allocate/free from */
d799 3
a801 3
			int more = ((xp) + (n)) - (xs).end; \
			if (more > 0) \
				xp = Xcheck_grow_(&xs, xp, more); \
d822 1
a822 1
char *Xcheck_grow_(XString *, char *, unsigned);
d829 2
a830 2
	void **cur;		/* next avail pointer */
	void **beg, **end;	/* begin, end of vector */
d844 1
a844 1
				    sizeofN(void*, n*2), ATEMP); \
d918 3
a920 3
	int i;
	char *cp;
	char **wp;
d976 3
a978 3
EXTERN	char **history;	/* saved commands */
EXTERN	char **histptr;	/* last history item */
EXTERN	int histsize;	/* history size */
d981 5
a985 5
Area *ainit(Area *);
void afreeall(Area *);
void *alloc(size_t, Area *);
void *aresize(void *, size_t, Area *);
void afree(void *, Area *);
d987 3
a989 3
void x_init(void);
int x_read(char *, size_t);
int x_bind(const char *, const char *, int, int);
d991 7
a997 7
char *substitute(const char *, int);
char **eval(char **, int);
char *evalstr(char *cp, int);
char *evalonestr(char *cp, int);
char *debunk(char *, const char *, size_t);
void expand(char *, XPtrV *, int);
int glob_str(char *, XPtrV *, int);
d999 11
a1009 11
int execute(struct op * volatile, volatile int);
int shcomexec(char **);
struct tbl *findfunc(const char *, unsigned int, int);
int define(const char *, struct op *);
void builtin(const char *, int (*)(char **));
struct tbl *findcom(const char *, int);
void flushcom(int);
char *search(const char *, const char *, int, int *);
int search_access(const char *, int, int *);
int pr_menu(char *const *);
int pr_list(char *const *);
d1011 2
a1012 2
int evaluate(const char *, long *, int, bool);
int v_evaluate(struct tbl *, const char *, volatile int, bool);
d1014 35
a1048 35
int c_hash(char **);
int c_cd(char **);
int c_pwd(char **);
int c_print(char **);
int c_whence(char **);
int c_command(char **);
int c_typeset(char **);
int c_alias(char **);
int c_unalias(char **);
int c_let(char **);
int c_jobs(char **);
int c_fgbg(char **);
int c_kill(char **);
void getopts_reset(int);
int c_getopts(char **);
int c_bind(char **);
int c_label(char **);
int c_shift(char **);
int c_umask(char **);
int c_dot(char **);
int c_wait(char **);
int c_read(char **);
int c_eval(char **);
int c_trap(char **);
int c_brkcont(char **);
int c_exitreturn(char **);
int c_set(char **);
int c_unset(char **);
int c_ulimit(char **);
int c_times(char **);
int timex(struct op *, int);
void timex_hook(struct op *, char ** volatile *);
int c_exec(char **);
int c_builtin(char **);
int c_test(char **);
d1050 28
a1077 28
void init_histvec(void);
void hist_init(Source *);
void hist_finish(void);
void histsave(int, const char *, int);
int c_fc(char **);
void sethistsize(int);
void sethistfile(const char *);
char **histpos(void);
int histnum(int);
int findhist(int, int, const char *, int);
int findhistrel(const char *);
char **hist_get_newest(int);
void inittraps(void);
void alarm_init(void);
Trap *gettrap(const char *, int);
void trapsig(int);
void intrcheck(void);
int fatal_trap_check(void);
int trap_pending(void);
void runtraps(int intr);
void runtrap(Trap *);
void cleartraps(void);
void restoresigs(void);
void settrap(Trap *, char *);
int block_pipe(void);
void restore_pipe(int);
int setsig(Trap *, sig_t, int);
void setexecsig(Trap *, int);
d1079 14
a1092 14
void j_init(int);
void j_exit(void);
void j_change(void);
int exchild(struct op *, int, int);
void startlast(void);
int waitlast(void);
int waitfor(const char *, int *);
int j_kill(const char *, int);
int j_resume(const char *, int);
int j_jobs(const char *, int, int);
int j_njobs(void);
void j_notify(void);
pid_t j_async(void);
int j_stopped_running(void);
d1094 7
a1100 7
int yylex(int);
void yyerror(const char *, ...)
    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
Source *pushs(int, Area *);
void set_prompt(int, Source *);
void pprompt(const char *, int);
int promptlen(const char *);
d1102 35
a1136 35
int include(const char *, int, char **, int);
int command(const char *);
int shell(Source *volatile, int volatile);
void unwind(int) __attribute__((__noreturn__));
void newenv(int);
void quitenv(struct shf *);
void cleanup_parents_env(void);
void cleanup_proc_env(void);
void errorf(const char *, ...)
    __attribute__((__noreturn__, __format__ (printf, 1, 2)));
void warningf(int, const char *, ...)
    __attribute__((__format__ (printf, 2, 3)));
void bi_errorf(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
void internal_errorf(int, const char *, ...)
    __attribute__((__format__ (printf, 2, 3)));
void error_prefix(int);
void shellf(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
void shprintf(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
int can_seek(int);
void initio(void);
int ksh_dup2(int, int, int);
int savefd(int);
void restfd(int, int);
void openpipe(int *);
void closepipe(int *);
int check_fd(char *, int, const char **);
void coproc_init(void);
void coproc_read_close(int);
void coproc_readw_close(int);
void coproc_write_close(int);
int coproc_getfd(int, const char **);
void coproc_cleanup(int);
d1138 8
a1145 8
unsigned int hash(const char *);
void ktinit(struct table *, Area *, int);
struct tbl *ktsearch(struct table *, const char *, unsigned int);
struct tbl *ktenter(struct table *, const char *, unsigned int);
void ktdelete(struct tbl *);
void ktwalk(struct tstate *, struct table *);
struct tbl *ktnext(struct tstate *);
struct tbl **ktsort(struct table *);
d1147 21
a1167 20
void setctypes(const char *, int);
void initctypes(void);
char *ulton(unsigned long, int);
char *str_save(const char *, Area *);
char *str_nsave(const char *, int, Area *);
int option(const char *);
char *getoptions(void);
void change_flag(enum sh_flag, int, int);
int parse_args(char **, int, int *);
int getn(const char *, int *);
int bi_getn(const char *, int *);
int gmatchx(const char *, const char *, int);
int has_globbing(const char *, const char *);
const unsigned char *pat_scan(const unsigned char *, const unsigned char *, int);
void qsortp(void **, size_t, int (*)(void *, void *));
int xstrcmp(void *, void *);
void ksh_getopt_reset(Getopt *, int);
int ksh_getopt(char **, Getopt *, const char *);
void print_value_quoted(const char *);
void print_columns(struct shf *, int, char *(*)(void *, int, char *, int),
d1169 8
a1176 8
int strip_nuls(char *, int);
int blocking_read(int, char *, int);
int reset_nonblock(int);
char *ksh_get_wd(char *, int);
int make_path(const char *, const char *, char **, XString *, int *);
void simplify_path(char *);
char *get_phys_path(const char *);
void set_current_wd(char *);
d1182 15
a1196 15
int shf_close(struct shf *);
int shf_fdclose(struct shf *);
char *shf_sclose(struct shf *);
int shf_flush(struct shf *);
int shf_read(char *, int, struct shf *);
char *shf_getse(char *, int, struct shf *);
int shf_getchar(struct shf *s);
int shf_ungetc(int, struct shf *);
int shf_putchar(int, struct shf *);
int shf_puts(const char *, struct shf *);
int shf_write(const char *, int, struct shf *);
int shf_fprintf(struct shf *, const char *, ...);
int shf_snprintf(char *, int, const char *, ...);
char *shf_smprintf(const char *, ...);
int shf_vfprintf(struct shf *, const char *, va_list);
d1198 2
a1199 2
void initkeywords(void);
struct op *compile(Source *);
d1201 7
a1207 7
int fptreef(struct shf *, int, const char *, ...);
char *snptreef(char *, int, const char *, ...);
struct op *tcopy(struct op *, Area *);
char *wdcopy(const char *, Area *);
char *wdscan(const char *, int);
char *wdstrip(const char *);
void tfree(struct op *, Area *);
d1209 8
a1216 8
void newblock(void);
void popblock(void);
void initvar(void);
struct tbl *global(const char *);
struct tbl *local(const char *, bool);
char *str_val(struct tbl *);
long intval(struct tbl *);
int setstr(struct tbl *, const char *, int);
d1218 14
a1231 14
void setint(struct tbl *, long);
int getint(struct tbl *, long *, bool);
struct tbl *typeset(const char *, Tflag, Tflag, int, int);
void unset(struct tbl *, int);
char *skip_varname(const char *, int);
char *skip_wdvarname(const char *, int);
int is_wdvarname(const char *, int);
int is_wdvarassign(const char *);
char **makenv(void);
void change_random(void);
int array_ref_len(const char *);
char *arrayname(const char *);
void set_array(const char *, int, char **);
int eaccess(const char *, int);
d1266 1
a1266 1
	int flags;		/* TEF_* */
d1268 2
a1269 2
		char **wp;	/* used by ptest_* */
		XPtrV *av;	/* used by dbtestp_* */
d1271 2
a1272 2
	char **wp_end;		/* used by ptest_* */
	int (*isa)(Test_env *, Test_meta);
d1274 2
a1275 2
	int (*eval)(Test_env *, Test_op, const char *, const char *, int);
	void (*error)(Test_env *, int, const char *);
d1279 6
a1284 2
int test_eval(Test_env *, Test_op, const char *, const char *, int);
int test_parse(Test_env *);
d1286 2
a1287 3
EXTERN int tty_fd I__(-1);	/* dup'd tty file descriptor */
EXTERN int tty_devtty;		/* true if tty_fd is from /dev/tty */
EXTERN struct termios tty_state;	/* saved tty state */
d1289 1
a1289 2
extern void tty_init(int);
extern void tty_close(void);
d1302 1
a1302 1
#define HAVE_ARC4RANDOM 0
d1304 1
a1304 1
#define HAVE_ARC4RANDOM 1
@


1.33.2.4
log
@we don't use GCC out of fear of the (terminal) consequences
@
text
@d11 1
a11 1
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.33.2.3 2006/08/24 20:52:15 tg Exp $"
d14 2
a15 2
#if defined(__Plan9__)
#define __attribute__(x)	/* nothing */
@


1.33.2.5
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@d11 2
a12 2
#define MKSH_SH_H_ID "$MirOS: src/bin/mksh/sh.h,v 1.42 2006/08/28 01:40:54 tg Exp $"
#define MKSH_VERSION "R28 2006/08/28"
d1374 18
@


1.32
log
@re-implement "set -o posix" which doesn't do much ;)
but turns off 'braceexpand' when turned on as side effect,
just like oksh/pdksh.
document "set -o sh" too.
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.31 2006/08/02 11:33:37 tg Exp $"
d30 1
d69 1
a69 1
typedef int32_t Tflag;
@


1.31
log
@fix the prompt redrawal routines for multi-line prompts, prompts
with embedded newline (\n), and multi-line prompts with embedded
newlines. single-line prompts should be not affected; prompts with
embedded carriage return (\r) should be fixed by this as well.
also fix prompt_redraw comment (can't remove the variable though,
since it's required if the shell inserts a newline after the prompt
herself).
tested on cygwin and interix
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.30 2006/08/01 14:10:25 tg Exp $"
d198 1
a198 1
	FPOSIX,		/* -o posix (disabled) */
d201 1
a201 1
	FSH,		/* -o sh (disabled) */
@


1.30
log
@move promptlen from edit.c into lex.c
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.29 2006/08/01 14:09:20 tg Exp $"
d1084 1
a1084 1
int	promptlen(const char *, const char **);
@


1.29
log
@(partial) sync with openbsd (and fix after them),
gives us a better wrapping prompt and a manpage wording cleanup
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.28 2006/08/01 12:22:26 tg Exp $"
d1084 1
@


1.28
log
@move version definition into extra file
@
text
@d6 1
a6 1
/*	$OpenBSD: lex.h,v 1.10 2005/09/11 18:02:27 otto Exp $	*/
d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.27 2006/06/21 19:35:38 tg Exp $"
@


1.27
log
@new conditional: HAVE_ARC4RANDOM_PUSH
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.26 2006/05/10 18:54:12 tg Exp $"
d1272 2
@


1.26
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.25 2006/03/19 18:06:32 tg Exp $"
d1288 8
@


1.25
log
@* shuffle around _*_SOURCE definitions (sh.h -> Build.sh), per OS
* Tonnerre Lombard reports that Solaris 10 needs _BSD_SOURCE
@
text
@d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.29 2005/12/11 20:31:21 otto Exp $	*/
d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.24 2006/01/29 20:04:53 tg Exp $"
d1109 1
a1109 1
int	savefd(int, int);
@


1.24
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d11 1
a11 5
#define	MKSH_SH_H_ID	"$MirOS: src/bin/mksh/sh.h,v 1.23 2005/11/22 18:40:43 tg Exp $"

#if defined(__INTERIX) && !defined(_ALL_SOURCE)
#define _ALL_SOURCE
#endif
a14 4
#if defined(__gnu_linux__) && !defined(_POSIX_SOURCE)
#define _POSIX_SOURCE
#endif

@


1.23
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 3
a3 3
/*	$OpenBSD: sh.h,v 1.28 2005/10/04 20:35:11 otto Exp $	*/
/*	$OpenBSD: shf.h,v 1.5 2005/03/30 17:16:37 deraadt Exp $	*/
/*	$OpenBSD: table.h,v 1.6 2004/12/18 20:55:52 millert Exp $	*/
d7 1
a7 1
/*	$OpenBSD: proto.h,v 1.27 2005/10/06 06:39:36 otto Exp $	*/
d11 1
a11 1
#define	MKSH_SH_H_ID	"$MirOS$"
a229 1
EXTERN	char	slash [] I__("/");
d587 1
a587 1
 * Used by twalk() and tnext() routines.
a1049 1
int	histN(void);
a1100 1
void	aerror(Area *, const char *) __attribute__((__noreturn__));
d1130 7
a1136 7
void		tinit(struct table *, Area *, int);
struct tbl *	tsearch(struct table *, const char *, unsigned int);
struct tbl *	tenter(struct table *, const char *, unsigned int);
void		tdelete(struct tbl *);
void		twalk(struct tstate *, struct table *);
struct tbl *	tnext(struct tstate *);
struct tbl **	tsort(struct table *);
a1175 1
int	shf_finish(struct shf *);
a1176 1
int	shf_seek(struct shf *, off_t, int);
@


1.22
log
@Change interpretation of '\"' in here documents with substitution
according to SUSv3 and other modern shells (POSIX allows both).
Idea for the patch (add another lex state) from OpenBSD, but the
implementation differs slightly (and is better in quality).

Also add two testcases (/bin/sh passes both, old mksh only one),
and document the change in the manual page. Sync RCS IDs with OBSD.
@
text
@a0 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.21 2005/10/25 19:53:28 tg Exp $ */
d11 2
@


1.21
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.20 2005/10/25 19:46:11 tg Exp $ */
d7 1
a7 1
/*	$OpenBSD: lex.h,v 1.9 2004/12/18 21:04:52 millert Exp $	*/
d957 1
@


1.20
log
@Shuffle some stuff around to the compat functions and add glue
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.19 2005/10/21 12:41:56 tg Exp $ */
d26 9
d37 1
d42 1
d52 1
a53 3
#if defined(__sun__) || defined(__gnu_linux__)
#include <values.h>
#endif
@


1.19
log
@follow OpenBSD and add mknod as mksh builtin (mknod <file> p acts as mkfifo)
but write a good chunk of that code myself (better structured, better error
handling, more gotos, less function calls, int -> bool)

passes all tests on mirbsd; this will become mksh R25 once tested on other
supported OSes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.18 2005/10/08 19:31:00 tg Exp $ */
d45 3
a1280 32
#if defined(__gnu_linux__)
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
#endif

#if defined(__sun__)
size_t confstr(int, char *, size_t);
#endif

#ifndef timeradd
#define	timeradd(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (0)
#endif
#ifndef timersub
#define	timersub(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (0)
#endif

@


1.18
log
@our test(1) promises we can do string1 < string2, and
our /bin/test uses mksh... so we pee (literally) on
POSIX and don't accept < and > only for [[ ... ]] operator
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/sh.h,v 1.17 2005/08/02 12:35:27 tg Exp $ */
/*	$OpenBSD: sh.h,v 1.27 2005/03/28 21:33:04 deraadt Exp $	*/
d8 1
a8 1
/*	$OpenBSD: proto.h,v 1.26 2005/03/28 21:28:22 deraadt Exp $	*/
a455 22
struct shf *shf_open(const char *, int, int, int);
struct shf *shf_fdopen(int, int, struct shf *);
struct shf *shf_reopen(int, int, struct shf *);
struct shf *shf_sopen(char *, int, int, struct shf *);
int	    shf_close(struct shf *);
int	    shf_fdclose(struct shf *);
char	   *shf_sclose(struct shf *);
int	    shf_finish(struct shf *);
int	    shf_flush(struct shf *);
int	    shf_seek(struct shf *, off_t, int);
int	    shf_read(char *, int, struct shf *);
char	   *shf_getse(char *, int, struct shf *);
int	    shf_getchar(struct shf *s);
int	    shf_ungetc(int, struct shf *);
int	    shf_putchar(int, struct shf *);
int	    shf_puts(const char *, struct shf *);
int	    shf_write(const char *, int, struct shf *);
int	    shf_fprintf(struct shf *, const char *, ...);
int	    shf_snprintf(char *, int, const char *, ...);
char	    *shf_smprintf(const char *, ...);
int	    shf_vfprintf(struct shf *, const char *, va_list);

d965 28
a992 1
/* c_funcs.c */
a1027 27
/* edit.c */
void	x_init(void);
int	x_read(char *, size_t);
int	x_bind(const char *, const char *, int, int);
/* eval.c */
char *	substitute(const char *, int);
char **	eval(char **, int);
char *	evalstr(char *cp, int);
char *	evalonestr(char *cp, int);
char	*debunk(char *, const char *, size_t);
void	expand(char *, XPtrV *, int);
int	glob_str(char *, XPtrV *, int);
/* exec.c */
int	execute(struct op * volatile, volatile int);
int	shcomexec(char **);
struct tbl * findfunc(const char *, unsigned int, int);
int	define(const char *, struct op *);
void	builtin(const char *, int (*)(char **));
struct tbl *	findcom(const char *, int);
void	flushcom(int);
char *	search(const char *, const char *, int, int *);
int	search_access(const char *, int, int *);
int	pr_menu(char *const *);
int	pr_list(char *const *);
/* expr.c */
int	evaluate(const char *, long *, int, bool);
int	v_evaluate(struct tbl *, const char *, volatile int, bool);
d1157 22
@


1.17
log
@^V now is quote, not version, even in emacs mode. (From OpenBSD.)
Also, the "version" command got removed in its entirety.
Shaves off another global variable, even.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.16 2005/07/07 23:27:52 tg Exp $ */
d1260 1
a1260 1
Test_op	test_isop(Test_env *, Test_meta, const char *);
@


1.16
log
@* move <sys/param.h> include to sh.h
* fix compilation and invocation of test suite with whitespace in
  the pathnames for real, this time
* clean up (especially whitespace)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.15 2005/07/05 22:00:20 tg Exp $ */
a367 2
extern const char ksh_version[];

@


1.15
log
@it's said newer NetBSDen have arc4random(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.14 2005/07/04 12:34:24 tg Exp $ */
d16 1
a16 1
#include <sys/types.h>
@


1.14
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.13 2005/07/04 12:07:41 tg Exp $ */
d1314 2
a1315 1
    || defined(__NetBSD__) || defined(__CYGWIN__)
@


1.13
log
@mksh now does not look at $EDITOR and $VISUAL any more to determine
the editing mode; default is emacs (vi and gmacs off).
mksh also defaults to emacs-usemeta=OFF now.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.12 2005/06/24 15:36:57 tg Exp $ */
d193 1
a193 1
	FPOSIX,		/* -o posix: be posixly correct */
d196 1
a196 1
	FSH,		/* -o sh: favor sh behaviour */
d207 1
a207 1
	FNFLAGS /* (place holder: how many flags are there) */
a628 2
#define V_VISUAL		11
#define V_EDITOR		12
a632 1
#define	V_PGRP			18
@


1.12
log
@first step for GNU/Cygwin support
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.11 2005/06/08 21:51:22 tg Exp $ */
a1030 1
void	set_editmode(const char *);
@


1.11
log
@* major revamp of build system
* whitespace cleanup; junk comment removal
* syndicate debian/copyright file from my port (shrinks sh.h)
* bump to R23
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.10 2005/05/26 23:12:09 tg Exp $ */
d242 1
a242 1
#ifdef __sun__
d1318 1
a1318 1
    || defined(__NetBSD__)
@


1.10
log
@forgot a #endif
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.9 2005/05/26 23:01:30 tg Exp $ */
a11 27
/*-
 * Copyright (c) 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
 */

#ifndef SH_H
#define SH_H

d29 1
a29 1
#if !defined(__sun__)	/* not on Solaris */
a1323 2

#endif
@


1.9
log
@* fix logic for srand() I got reversed
* introduce HAVE_ARC4RANDOM tristate (0/1/undef) and fill it appropriately
* NetBSD(R) joins the list of OSes which don't have arc4random
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.8 2005/05/25 23:31:08 tg Exp $ */
d1350 1
@


1.8
log
@* fix emacs [ tabcompletion bug
  XXX it's probably a bug in vi mode too, it just doesn't show
* bring manual page and reality into closer sync'd state
* sort ulimits
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.7 2005/05/25 13:46:01 tg Exp $ */
d1343 8
@


1.7
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.6 2005/05/23 16:23:19 tg Exp $ */
d998 1
@


1.6
log
@aaaand: Interix.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.5 2005/05/23 15:36:55 tg Exp $ */
d115 3
d1245 1
@


1.5
log
@no persistent history (flock missing), no arc4random, etc. for Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.4 2005/05/23 15:24:43 tg Exp $ */
d39 4
@


1.4
log
@missing preprocessor defines on Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.3 2005/05/23 15:18:17 tg Exp $ */
d103 3
d1307 4
@


1.3
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.2 2005/05/23 14:19:14 tg Exp $ */
d1304 23
@


1.2
log
@* add definition of __RCSID if not yet existant (GNU/Linux)
* add declarations of strlcpy and strlcat (for GNU/Linux, again)
* always include <sys/resource.h>
* some more compile / warning fixes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/sh.h,v 1.1 2005/05/23 03:06:09 tg Exp $ */
d259 4
d1182 1
a1182 1
int	gmatch(const char *, const char *, int);
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/sh.h,v 1.20 2005/05/23 02:20:36 tg Exp $ */
d41 1
a41 1
#if defined(__gnu_linux__)
d45 4
d1295 5
@
