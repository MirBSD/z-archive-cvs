head	1.222;
access;
symbols
	mksh-R57:1.219
	mksh-R56c:1.219
	mksh-R56b:1.215
	mksh-R56:1.214
	mksh-R55:1.201
	mksh-R54:1.194
	mksh-R53a:1.192
	mksh-R53:1.192
	mksh-R52c:1.185
	mksh-R52b:1.180
	mksh-R52:1.178
	mksh-R51:1.170
	mksh-R50f:1.158.2.5
	mksh-R50e:1.158.2.4
	mksh-R50stable:1.158.0.2
	mksh-R50d:1.153
	mksh-R50c:1.152
	mksh-R50b:1.151
	mksh-R50:1.150
	mksh-R49:1.147
	mksh-R48b:1.142
	mksh-R48:1.142
	mksh-R47:1.142
	mksh-R46:1.139
	mksh-R45:1.138
	mksh-R44:1.137
	mksh-R43:1.136
	mksh-R42b:1.136
	mksh-R41c:1.129
	mksh-R41b:1.129
	mksh-R42:1.136
	mksh-R41:1.129
	mksh-R41stable:1.129.0.2
	mksh-wheezy:1.120.0.2
	tg-multikey-bind:1.118.0.2
	mksh-R40f:1.112.2.1
	mksh-R40e:1.112
	mksh-R40d:1.110
	mksh-R40c:1.109
	mksh-R40b:1.106
	mksh-R40stable:1.112.0.2
	mksh-R40:1.105
	mksh-R39c:1.83
	mksh-R39b:1.82
	tg-wcswidth-behaviour:1.74.0.2
	tg-nameref:1.68.0.2
	mksh-R39:1.64
	tg-mksh-printf-builtin:1.61.0.2
	mksh-R38c:1.59
	mksh-R38b:1.57
	mksh-R38:1.57
	mksh-R37c:1.54
	mksh-R37b:1.53
	mksh-R37:1.53
	mksh-R36b:1.51
	tg-aalloc-experimental_BASE:1.50
	tg-aalloc-experimental:1.50.0.2
	mksh-R36:1.48
	mksh-R35b:1.47
	mksh-R35:1.46
	mksh-R33d:1.45
	mksh-R33c:1.45
	mksh-R33b:1.45
	MIRBSD_10:1.45.0.2
	MIRBSD_10_BASE:1.45
	mksh-R33:1.45
	mksh-R32:1.36
	mksh-R31d:1.35
	mksh-R31c:1.35
	mksh-R31b:1.35
	mksh-R31:1.34
	mksh-R30:1.33
	mksh-R29g:1.25.2.2
	mksh-R29f:1.25.2.1
	mksh-R29e:1.25.2.1
	mksh-R29stable:1.25.0.2
	mksh-R29d:1.25
	mksh-R29c:1.25
	mksh-R29b:1.24
	mksh-R29:1.24
	mksh-R28:1.13
	tg-mksh-plan9ape_BASE:1.13
	tg-mksh-plan9ape:1.13.0.2
	mksh-R27e:1.12
	MIRBSD_9_BASE:1.12
	mksh-R27d:1.12
	mksh-R27:1.12
	mksh-R26c:1.10
	mksh-R26b:1.9
	MIRBSD_8:1.9.0.2
	MIRBSD_8_BASE:1.9
	mksh-R26:1.9
	mksh-R25:1.8
	mksh-R24c:1.7
	mksh-R24b:1.7
	mksh-R24:1.5
	mksh-R23:1.4
	mksh-R22:1.3
	mksh-R21:1.2;
locks; strict;
comment	@ * @;


1.222
date	2019.12.30.04.43.37;	author tg;	state Exp;
branches;
next	1.221;
commitid	1005E098083562BCB3C;

1.221
date	2019.12.12.00.36.53;	author tg;	state Exp;
branches;
next	1.220;
commitid	1005DF18BB027AC0ACA;

1.220
date	2019.12.11.23.58.17;	author tg;	state Exp;
branches;
next	1.219;
commitid	1005DF182AD50645981;

1.219
date	2018.01.14.01.29.47;	author tg;	state Exp;
branches;
next	1.218;
commitid	1005A5AB29D07E6066B;

1.218
date	2018.01.14.00.22.27;	author tg;	state Exp;
branches;
next	1.217;
commitid	1005A5AA2D643C73A14;

1.217
date	2018.01.14.00.03.02;	author tg;	state Exp;
branches;
next	1.216;
commitid	1005A5A9E3D208A81CB;

1.216
date	2018.01.13.23.55.09;	author tg;	state Exp;
branches;
next	1.215;
commitid	1005A5A9C627E45C2B1;

1.215
date	2017.08.28.23.27.51;	author tg;	state Exp;
branches;
next	1.214;
commitid	10059A4A70366AAC5DF;

1.214
date	2017.05.05.22.53.27;	author tg;	state Exp;
branches;
next	1.213;
commitid	100590D026845CD3DFF;

1.213
date	2017.05.05.20.36.01;	author tg;	state Exp;
branches;
next	1.212;
commitid	100590CE24264B3D492;

1.212
date	2017.05.03.15.36.12;	author tg;	state Exp;
branches;
next	1.211;
commitid	1005909F8FE711DB00F;

1.211
date	2017.05.03.15.33.16;	author tg;	state Exp;
branches;
next	1.210;
commitid	1005909F84E25A1E610;

1.210
date	2017.05.03.14.51.25;	author tg;	state Exp;
branches;
next	1.209;
commitid	1005909EE8764841F78;

1.209
date	2017.04.29.22.04.27;	author tg;	state Exp;
branches;
next	1.208;
commitid	10059050DFF02CF9B3E;

1.208
date	2017.04.29.21.49.06;	author tg;	state Exp;
branches;
next	1.207;
commitid	10059050A1F555381AA;

1.207
date	2017.04.28.00.38.29;	author tg;	state Exp;
branches;
next	1.206;
commitid	10059028F0E0808B3E9;

1.206
date	2017.04.27.23.12.46;	author tg;	state Exp;
branches;
next	1.205;
commitid	10059027AFC0DEF48C9;

1.205
date	2017.04.27.19.33.47;	author tg;	state Exp;
branches;
next	1.204;
commitid	100590247A92C66CAF9;

1.204
date	2017.04.27.19.16.07;	author tg;	state Exp;
branches;
next	1.203;
commitid	1005902438A577EF826;

1.203
date	2017.04.22.00.07.08;	author tg;	state Exp;
branches;
next	1.202;
commitid	10058FA9D043131DCC0;

1.202
date	2017.04.21.20.06.04;	author tg;	state Exp;
branches;
next	1.201;
commitid	10058FA66392543430F;

1.201
date	2017.04.06.01.59.54;	author tg;	state Exp;
branches;
next	1.200;
commitid	10058E5A1067AFA1BBA;

1.200
date	2017.04.02.15.00.41;	author tg;	state Exp;
branches;
next	1.199;
commitid	10058E1121E64BBAB7B;

1.199
date	2017.03.26.00.10.23;	author tg;	state Exp;
branches;
next	1.198;
commitid	10058D706207E0A1FF4;

1.198
date	2017.03.11.22.49.55;	author tg;	state Exp;
branches;
next	1.197;
commitid	10058C47F07715C2B99;

1.197
date	2017.02.17.22.40.12;	author tg;	state Exp;
branches;
next	1.196;
commitid	10058A77BD32DFE626F;

1.196
date	2017.02.17.21.15.55;	author tg;	state Exp;
branches;
next	1.195;
commitid	10058A768251E5394FE;

1.195
date	2017.02.17.20.52.15;	author tg;	state Exp;
branches;
next	1.194;
commitid	10058A7628E5EDD9539;

1.194
date	2016.11.11.23.31.34;	author tg;	state Exp;
branches;
next	1.193;
commitid	100582654B972655F84;

1.193
date	2016.09.01.12.59.09;	author tg;	state Exp;
branches;
next	1.192;
commitid	10057C8260A04757349;

1.192
date	2016.08.01.21.38.01;	author tg;	state Exp;
branches;
next	1.191;
commitid	100579FC12F14735847;

1.191
date	2016.07.25.00.04.41;	author tg;	state Exp;
branches;
next	1.190;
commitid	1005795579F14A3FE5C;

1.190
date	2016.07.24.23.05.52;	author tg;	state Exp;
branches;
next	1.189;
commitid	100579549C8761C6547;

1.189
date	2016.06.26.00.44.57;	author tg;	state Exp;
branches;
next	1.188;
commitid	100576F259765932F2C;

1.188
date	2016.06.25.23.54.59;	author tg;	state Exp;
branches;
next	1.187;
commitid	100576F19E14572FB35;

1.187
date	2016.05.05.22.45.57;	author tg;	state Exp;
branches;
next	1.186;
commitid	100572BCD1534586213;

1.186
date	2016.05.05.22.19.04;	author tg;	state Exp;
branches;
next	1.185;
commitid	100572BC6F120112971;

1.185
date	2016.02.26.19.05.21;	author tg;	state Exp;
branches;
next	1.184;
commitid	10056D0A1EA65CD6765;

1.184
date	2016.02.26.18.48.12;	author tg;	state Exp;
branches;
next	1.183;
commitid	10056D09DEF7B46FCA2;

1.183
date	2016.02.26.18.05.10;	author tg;	state Exp;
branches;
next	1.182;
commitid	10056D093EB5BD9B769;

1.182
date	2016.02.24.01.47.32;	author tg;	state Exp;
branches;
next	1.181;
commitid	10056CD0B7E394575BD;

1.181
date	2016.01.21.18.24.38;	author tg;	state Exp;
branches;
next	1.180;
commitid	10056A12268001BF859;

1.180
date	2016.01.19.23.12.12;	author tg;	state Exp;
branches;
next	1.179;
commitid	100569EC2AE617A4288;

1.179
date	2016.01.14.22.30.43;	author tg;	state Exp;
branches;
next	1.178;
commitid	1005698219A4D72938C;

1.178
date	2015.12.12.22.24.07;	author tg;	state Exp;
branches;
next	1.177;
commitid	100566C9E921F38B62C;

1.177
date	2015.12.12.20.38.56;	author tg;	state Exp;
branches;
next	1.176;
commitid	100566C85E67115D29A;

1.176
date	2015.12.12.18.47.22;	author tg;	state Exp;
branches;
next	1.175;
commitid	100566C6B9760BB2B12;

1.175
date	2015.12.12.17.28.10;	author tg;	state Exp;
branches;
next	1.174;
commitid	100566C59236042D5D8;

1.174
date	2015.10.09.19.29.47;	author tg;	state Exp;
branches;
next	1.173;
commitid	100561815B853CF84EB;

1.173
date	2015.10.09.17.48.48;	author tg;	state Exp;
branches;
next	1.172;
commitid	1005617FE066005352E;

1.172
date	2015.09.06.19.46.59;	author tg;	state Exp;
branches;
next	1.171;
commitid	10055EC98215F2B5F9C;

1.171
date	2015.09.05.19.19.02;	author tg;	state Exp;
branches;
next	1.170;
commitid	10055EB402C54C3076B;

1.170
date	2015.07.06.17.45.33;	author tg;	state Exp;
branches;
next	1.169;
commitid	100559ABECD5E3E334C;

1.169
date	2015.05.23.17.43.19;	author tg;	state Exp;
branches;
next	1.168;
commitid	1005560BBB87BB0247C;

1.168
date	2015.04.29.18.32.42;	author tg;	state Exp;
branches;
next	1.167;
commitid	100554123E246E02963;

1.167
date	2015.04.11.22.03.29;	author tg;	state Exp;
branches;
next	1.166;
commitid	1005529999F77F915AE;

1.166
date	2015.02.20.07.14.29;	author tg;	state Exp;
branches;
next	1.165;
commitid	10054E6DEC961F3FFC5;

1.165
date	2015.02.19.22.26.48;	author tg;	state Exp;
branches;
next	1.164;
commitid	10054E6631B44A55260;

1.164
date	2015.02.19.22.01.13;	author tg;	state Exp;
branches;
next	1.163;
commitid	10054E65D355A64BD19;

1.163
date	2015.02.06.10.09.05;	author tg;	state Exp;
branches;
next	1.162;
commitid	10054D492CC303A2CB1;

1.162
date	2015.02.06.09.33.41;	author tg;	state Exp;
branches;
next	1.161;
commitid	10054D48A657C42CECD;

1.161
date	2014.12.05.15.14.23;	author tg;	state Exp;
branches;
next	1.160;
commitid	1005481CBE7209F6ED8;

1.160
date	2014.11.25.21.13.23;	author tg;	state Exp;
branches;
next	1.159;
commitid	1005474F00E09321C83;

1.159
date	2014.11.19.21.49.12;	author tg;	state Exp;
branches;
next	1.158;
commitid	100546D105E468BE66D;

1.158
date	2014.10.19.21.53.07;	author tg;	state Exp;
branches
	1.158.2.1;
next	1.157;
commitid	100544432BD7CEA2F06;

1.157
date	2014.10.19.21.39.37;	author tg;	state Exp;
branches;
next	1.156;
commitid	10054442FAC18EC3A91;

1.156
date	2014.10.19.21.04.47;	author tg;	state Exp;
branches;
next	1.155;
commitid	1005444277E60C42255;

1.155
date	2014.10.19.20.59.43;	author tg;	state Exp;
branches;
next	1.154;
commitid	100544426521E00272E;

1.154
date	2014.10.19.20.56.32;	author tg;	state Exp;
branches;
next	1.153;
commitid	1005444249972F13F37;

1.153
date	2014.10.07.15.22.16;	author tg;	state Exp;
branches;
next	1.152;
commitid	1005434053135366996;

1.152
date	2014.10.03.17.32.11;	author tg;	state Exp;
branches;
next	1.151;
commitid	100542EDD596FD5FBF9;

1.151
date	2014.07.29.16.29.11;	author tg;	state Exp;
branches;
next	1.150;
commitid	10053D7CBC06ADB3D58;

1.150
date	2014.06.09.11.16.07;	author tg;	state Exp;
branches;
next	1.149;
commitid	1005395977B5787B7BA;

1.149
date	2014.06.09.10.41.03;	author tg;	state Exp;
branches;
next	1.148;
commitid	10053958F4C346B3377;

1.148
date	2014.05.27.13.00.30;	author tg;	state Exp;
branches;
next	1.147;
commitid	10053848C7F67D88909;

1.147
date	2014.01.11.18.09.39;	author tg;	state Exp;
branches;
next	1.146;
commitid	10052D188DD7DFEC194;

1.146
date	2014.01.05.21.57.25;	author tg;	state Exp;
branches;
next	1.145;
commitid	10052C9D445413B34DF;

1.145
date	2013.11.30.00.20.47;	author tg;	state Exp;
branches;
next	1.144;
commitid	10052992F754802C9BE;

1.144
date	2013.11.17.22.28.51;	author tg;	state Exp;
branches;
next	1.143;
commitid	1005289433447F6CA90;

1.143
date	2013.09.24.20.19.44;	author tg;	state Exp;
branches;
next	1.142;
commitid	1005241F37044BDFFC4;

1.142
date	2013.07.24.18.03.57;	author tg;	state Exp;
branches;
next	1.141;
commitid	10051F017226117F784;

1.141
date	2013.07.24.12.39.28;	author tg;	state Exp;
branches;
next	1.140;
commitid	10051EFCAFD588E97F5;

1.140
date	2013.07.21.18.36.00;	author tg;	state Exp;
branches;
next	1.139;
commitid	10051EC29F9411252FA;

1.139
date	2013.05.02.21.59.49;	author tg;	state Exp;
branches;
next	1.138;
commitid	1005182E1E55272FF6B;

1.138
date	2013.03.29.17.33.06;	author tg;	state Exp;
branches;
next	1.137;
commitid	1005155D01655460A00;

1.137
date	2013.02.23.20.03.30;	author tg;	state Exp;
branches;
next	1.136;
commitid	1005129208E57646522;

1.136
date	2013.02.10.23.43.59;	author tg;	state Exp;
branches;
next	1.135;
commitid	100511830C237D6C468;

1.135
date	2013.02.10.23.30.47;	author tg;	state Exp;
branches;
next	1.134;
commitid	10051182DAC7194E766;

1.134
date	2013.02.10.21.42.15;	author tg;	state Exp;
branches;
next	1.133;
commitid	100511814387670B07A;

1.133
date	2013.02.10.21.08.35;	author tg;	state Exp;
branches;
next	1.132;
commitid	10051180C556616C4E3;

1.132
date	2012.12.17.23.18.03;	author tg;	state Exp;
branches;
next	1.131;
commitid	10050CFA81334F40D7F;

1.131
date	2012.12.08.18.30.29;	author tg;	state Exp;
branches;
next	1.130;
commitid	10050C3875A3CBDA8F8;

1.130
date	2012.11.30.20.19.11;	author tg;	state Exp;
branches;
next	1.129;
commitid	10050B914D41435E735;

1.129
date	2012.10.22.20.19.12;	author tg;	state Exp;
branches;
next	1.128;
commitid	1005085AA537A17A752;

1.128
date	2012.08.24.21.15.42;	author tg;	state Exp;
branches;
next	1.127;
commitid	1005037EEEC1CEDE454;

1.127
date	2012.08.24.20.57.45;	author tg;	state Exp;
branches;
next	1.126;
commitid	1005037EABE57131431;

1.126
date	2012.08.24.20.05.13;	author tg;	state Exp;
branches;
next	1.125;
commitid	1005037DE8E56F5392F;

1.125
date	2012.08.24.19.02.57;	author tg;	state Exp;
branches;
next	1.124;
commitid	1005037CFF74447266D;

1.124
date	2012.08.17.18.34.20;	author tg;	state Exp;
branches;
next	1.123;
commitid	100502E8EAA4BFCF410;

1.123
date	2012.07.30.21.37.11;	author tg;	state Exp;
branches;
next	1.122;
commitid	1005016FE9B27F9F4DC;

1.122
date	2012.07.30.17.28.21;	author tg;	state Exp;
branches;
next	1.121;
commitid	1005016C44D31B536CF;

1.121
date	2012.07.20.23.22.10;	author tg;	state Exp;
branches;
next	1.120;
commitid	1005009E802250C41C1;

1.120
date	2012.06.28.20.03.20;	author tg;	state Exp;
branches
	1.120.2.1;
next	1.119;
commitid	1004FECB89C0F69075F;

1.119
date	2012.06.24.19.36.27;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004FE76C2A541A4ACC;

1.118
date	2012.05.04.22.05.00;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004FA452A16C9E34E1;

1.117
date	2012.04.22.21.50.31;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004F947C3646B6F432;

1.116
date	2012.04.06.14.07.52;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004F7EF8CF17D62DEF;

1.115
date	2012.03.29.19.22.57;	author tg;	state Exp;
branches;
next	1.114;
commitid	1004F74B525291EF6DE;

1.114
date	2012.03.27.22.58.38;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004F7246082F66D55B;

1.113
date	2012.03.23.23.25.27;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004F6D064C65BE58AA;

1.112
date	2012.03.23.20.07.10;	author tg;	state Exp;
branches
	1.112.2.1;
next	1.111;
commitid	1004F6CD8052D2FFA5E;

1.111
date	2011.12.16.20.03.12;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004EEBA41748453A5B;

1.110
date	2011.11.26.00.45.20;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004ED036B353923A89;

1.109
date	2011.10.11.19.06.07;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004E9493B640EC27D7;

1.108
date	2011.09.07.15.24.13;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004E678C6929FE60A6;

1.107
date	2011.08.27.18.06.42;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004E5932432420AA61;

1.106
date	2011.07.02.17.57.02;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004E0F5C066AEE6A67;

1.105
date	2011.06.12.14.45.33;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004DF4D1244225E067;

1.104
date	2011.05.02.22.52.51;	author tg;	state Exp;
branches;
next	1.103;
commitid	1004DBF35D72295ADB7;

1.103
date	2011.03.28.08.27.08;	author tg;	state Exp;
branches;
next	1.102;
commitid	1004D90467358D6B13C;

1.102
date	2011.03.17.21.57.50;	author tg;	state Exp;
branches;
next	1.101;
commitid	1004D8283F068C41C3C;

1.101
date	2011.03.16.20.31.33;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004D811E0B6B302451;

1.100
date	2011.03.13.16.03.50;	author tg;	state Exp;
branches;
next	1.99;
commitid	1004D7CE9C2063207F0;

1.99
date	2011.03.13.01.20.17;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004D7C1BE368F5B459;

1.98
date	2011.03.12.23.06.43;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004D7BFC863E01C4BA;

1.97
date	2011.03.12.23.04.45;	author tg;	state Exp;
branches;
next	1.96;
commitid	1004D7BFC0825FC39FC;

1.96
date	2011.03.12.21.41.13;	author tg;	state Exp;
branches;
next	1.95;
commitid	1004D7BE79D2481A518;

1.95
date	2011.03.07.20.30.36;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004D75404D6F4BA14C;

1.94
date	2011.01.21.22.25.32;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004D3A07DC22BE01C9;

1.93
date	2010.09.14.21.26.10;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004C8FE654576B0E25;

1.92
date	2010.08.28.20.22.16;	author tg;	state Exp;
branches;
next	1.91;
commitid	1004C796FE40C544CCE;

1.91
date	2010.08.28.18.50.49;	author tg;	state Exp;
branches;
next	1.90;
commitid	1004C795A82072326AF;

1.90
date	2010.07.17.22.09.33;	author tg;	state Exp;
branches;
next	1.89;
commitid	1004C42295452E71B6E;

1.89
date	2010.05.16.19.17.42;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004BF044D8775327C1;

1.88
date	2010.05.16.19.04.41;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004BF041CB522EEEE3;

1.87
date	2010.04.20.09.10.07;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004BCD6F5E78E50C4E;

1.86
date	2010.04.09.19.16.30;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004BBF7CD656308A1C;

1.85
date	2010.04.09.18.53.29;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004BBF77B81D30DA7C;

1.84
date	2010.04.08.13.21.04;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004BBDD84556472D84;

1.83
date	2010.02.25.20.18.15;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004B86DB1A7C6BCE8B;

1.82
date	2010.01.29.09.34.27;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004B62ABB7333ED94C;

1.81
date	2010.01.25.14.07.38;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004B5DA5BE4FE11A27;

1.80
date	2010.01.01.17.44.07;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004B3E342E71FBD2B2;

1.79
date	2009.12.05.22.24.35;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004B1ADDB40928C12D;

1.78
date	2009.12.05.17.43.45;	author tg;	state Exp;
branches;
next	1.77;
commitid	1004B1A9BCF3E49BC5B;

1.77
date	2009.12.05.17.02.25;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004B1A922E1893A6EE;

1.76
date	2009.11.28.14.27.59;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004B11334F4604E973;

1.75
date	2009.11.28.14.21.43;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004B1131E93EDF1403;

1.74
date	2009.11.22.13.49.04;	author tg;	state Exp;
branches
	1.74.2.1;
next	1.73;
commitid	1004B09416031CBF569;

1.73
date	2009.11.21.23.23.17;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004B08764D5928E063;

1.72
date	2009.11.21.22.32.08;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004B086A791F2A4544;

1.71
date	2009.11.21.22.29.11;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004B0869C13792921C;

1.70
date	2009.10.30.00.57.37;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004AEA39BD3F10ECFA;

1.69
date	2009.09.06.17.42.12;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004AA3F479204C1E97;

1.68
date	2009.08.28.22.39.09;	author tg;	state Exp;
branches
	1.68.2.1;
next	1.67;
commitid	1004A985C7414904DFF;

1.67
date	2009.08.28.21.35.43;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004A984DB66A4BFF43;

1.66
date	2009.08.28.20.30.55;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004A983E6B745731A0;

1.65
date	2009.08.28.19.57.40;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004A98365B7809CDA1;

1.64
date	2009.08.01.19.31.02;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004A74975D0E598F48;

1.63
date	2009.07.25.20.26.31;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004A6B6A5D6F28009F;

1.62
date	2009.07.25.20.17.47;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004A6B68756352CDEF;

1.61
date	2009.07.16.15.06.43;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004A5F412E6BBABCED;

1.60
date	2009.06.11.12.42.17;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004A30FBB114E3FED9;

1.59
date	2009.06.10.18.12.45;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004A2FF7913BD44883;

1.58
date	2009.06.08.20.06.45;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004A2D6F3A31FB4CBC;

1.57
date	2009.05.16.18.40.05;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004A0F087409E93A5D;

1.56
date	2009.05.16.16.59.34;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004A0EF0664EF4168D;

1.55
date	2009.05.16.15.53.01;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004A0EE0AF7BF1B8E7;

1.54
date	2009.04.07.18.41.35;	author tg;	state Exp;
branches;
next	1.53;
commitid	10049DB9E493037411A;

1.53
date	2009.03.22.17.47.35;	author tg;	state Exp;
branches;
next	1.52;
commitid	10049C679C543D854C9;

1.52
date	2009.03.14.18.12.51;	author tg;	state Exp;
branches;
next	1.51;
commitid	10049BBF38A0ADEDD54;

1.51
date	2008.12.13.17.02.13;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004943EAA830C0300B;

1.50
date	2008.11.12.00.54.47;	author tg;	state Exp;
branches
	1.50.2.1;
next	1.49;
commitid	100491A295841A6D8EB;

1.49
date	2008.10.28.14.32.39;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004907226D3DEFCCD1;

1.48
date	2008.10.24.20.52.22;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004902357B2AADA8A4;

1.47
date	2008.07.12.16.56.38;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004878E22B104A657A;

1.46
date	2008.05.17.18.46.58;	author tg;	state Exp;
branches;
next	1.45;
commitid	100482F280E7B53AA4C;

1.45
date	2008.03.01.22.49.37;	author tg;	state Exp;
branches
	1.45.2.1;
next	1.44;
commitid	10047C9DD8677DED4BF;

1.44
date	2008.03.01.21.24.58;	author tg;	state Exp;
branches;
next	1.43;
commitid	10047C9C9B76D05CEA1;

1.43
date	2008.03.01.21.10.25;	author tg;	state Exp;
branches;
next	1.42;
commitid	10047C9C64165F71A5A;

1.42
date	2008.03.01.17.14.17;	author tg;	state Exp;
branches;
next	1.41;
commitid	10047C98EF24733E10E;

1.41
date	2008.02.29.11.51.21;	author tg;	state Exp;
branches;
next	1.40;
commitid	10047C7F1BA6BA2358E;

1.40
date	2008.02.29.11.41.01;	author tg;	state Exp;
branches;
next	1.39;
commitid	10047C7EF5066F556FB;

1.39
date	2008.02.27.12.49.53;	author tg;	state Exp;
branches;
next	1.38;
commitid	10047C55C8411C92E34;

1.38
date	2008.02.27.11.24.11;	author tg;	state Exp;
branches;
next	1.37;
commitid	10047C5484566B4BB83;

1.37
date	2008.02.27.01.00.09;	author tg;	state Exp;
branches;
next	1.36;
commitid	10047C4B5C65A58F987;

1.36
date	2007.10.25.15.34.29;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004720B799621B739A;

1.35
date	2007.09.09.18.06.39;	author tg;	state Exp;
branches;
next	1.34;
commitid	10046E436442CDF8871;

1.34
date	2007.07.31.10.42.15;	author tg;	state Exp;
branches;
next	1.33;
commitid	10046AF121C3F451EF4;

1.33
date	2007.07.06.02.39.36;	author tg;	state Exp;
branches;
next	1.32;
commitid	100468DAB655B485375;

1.32
date	2007.07.06.02.22.56;	author tg;	state Exp;
branches;
next	1.31;
commitid	100468DA78E140683C0;

1.31
date	2007.07.06.01.53.35;	author tg;	state Exp;
branches;
next	1.30;
commitid	100468DA0A207B760AD;

1.30
date	2007.07.01.15.39.22;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004687CAA8060A5137;

1.29
date	2007.06.27.23.12.58;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004682EDC82ADECDD6;

1.28
date	2007.06.06.23.28.14;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004667430836D68E66;

1.27
date	2007.05.13.19.14.04;	author tg;	state Exp;
branches;
next	1.26;
commitid	100464763537E100BDF;

1.26
date	2007.05.13.17.51.21;	author tg;	state Exp;
branches;
next	1.25;
commitid	10046474FB1292DF336;

1.25
date	2007.03.14.02.41.08;	author tg;	state Exp;
branches
	1.25.2.1;
next	1.24;
commitid	10045F760A869FD5E0F;

1.24
date	2007.03.04.03.04.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045EA374B3374AB35;

1.23
date	2007.03.04.00.13.15;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045EA0F2F6674C8B9;

1.22
date	2007.01.17.18.01.51;	author tg;	state Exp;
branches;
next	1.21;
commitid	10045AE64A16C5EEBBE;

1.21
date	2007.01.17.17.42.22;	author tg;	state Exp;
branches;
next	1.20;
commitid	10045AE5FEF159B49BE;

1.20
date	2007.01.11.00.32.30;	author tg;	state Exp;
branches
	1.20.2.1;
next	1.19;
commitid	10045A5858664A950E2;

1.19
date	2006.11.12.14.58.14;	author tg;	state Exp;
branches;
next	1.18;
commitid	100455735A7145E26AA;

1.18
date	2006.11.10.07.52.02;	author tg;	state Exp;
branches;
next	1.17;
commitid	10045542F8269E05F56;

1.17
date	2006.11.10.06.40.05;	author tg;	state Exp;
branches;
next	1.16;
commitid	10045541ED1100460E3;

1.16
date	2006.11.10.03.23.49;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004553F0C348A7A034;

1.15
date	2006.11.10.00.09.27;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004553C325737853C1;

1.14
date	2006.11.09.23.55.51;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004553BFD0613CC553;

1.13
date	2006.08.01.13.43.26;	author tg;	state Exp;
branches;
next	1.12;
commitid	10044CF5A93693A5C0A;

1.12
date	2006.05.10.18.54.09;	author tg;	state Exp;
branches;
next	1.11;
commitid	100446236E6726083C8;

1.11
date	2006.05.08.11.07.38;	author tg;	state Exp;
branches;
next	1.10;
commitid	100445F26910BD5E11B;

1.10
date	2006.01.29.20.04.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043DD1FE6328EF386;

1.9
date	2005.11.22.18.40.41;	author tg;	state Exp;
branches;
next	1.8;
commitid	108a438366254326;

1.8
date	2005.10.25.19.53.27;	author tg;	state Exp;
branches;
next	1.7;
commitid	76cc435e8d34d8ce;

1.7
date	2005.07.12.13.30.38;	author tg;	state Exp;
branches;
next	1.6;
commitid	9d042d3c6108a63;

1.6
date	2005.07.12.13.24.00;	author tg;	state Exp;
branches;
next	1.5;
commitid	599e42d3c46ea960;

1.5
date	2005.07.04.12.27.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	3ec342c92b3a8874;

1.4
date	2005.06.08.22.34.03;	author tg;	state Exp;
branches;
next	1.3;
commitid	775142a7726c13a2;

1.3
date	2005.05.25.10.01.24;	author tg;	state Exp;
branches;
next	1.2;
commitid	25ba42944cf49660;

1.2
date	2005.05.23.15.18.15;	author tg;	state Exp;
branches;
next	1.1;
commitid	3dc04291f43ca526;

1.1
date	2005.05.23.03.06.06;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.158.2.1
date	2015.01.11.22.39.47;	author tg;	state Exp;
branches;
next	1.158.2.2;
commitid	10054B2FBC1440F88AD;

1.158.2.2
date	2015.01.25.15.35.43;	author tg;	state Exp;
branches;
next	1.158.2.3;
commitid	10054C50D442D861FBF;

1.158.2.3
date	2015.01.25.15.44.04;	author tg;	state Exp;
branches;
next	1.158.2.4;
commitid	10054C50F46587DFA27;

1.158.2.4
date	2015.03.01.15.42.58;	author tg;	state Exp;
branches;
next	1.158.2.5;
commitid	10054F33364551D895A;

1.158.2.5
date	2015.04.12.22.32.24;	author tg;	state Exp;
branches;
next	;
commitid	100552AF26A429AA816;

1.120.2.1
date	2012.09.03.19.10.56;	author tg;	state Exp;
branches;
next	;
commitid	100504500D439E09A42;

1.112.2.1
date	2012.04.06.14.40.16;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.74.2.1
date	2009.11.28.14.27.48;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.68.2.1
date	2009.08.30.20.56.05;	author tg;	state Exp;
branches;
next	;
commitid	1004A9AE59203C5D0BB;

1.50.2.1
date	2008.11.22.13.20.27;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.45.2.1
date	2008.05.19.18.41.21;	author tg;	state Exp;
branches;
next	1.45.2.2;
commitid	1004831C9A63DA06745;

1.45.2.2
date	2008.07.18.13.29.42;	author tg;	state Exp;
branches;
next	1.45.2.3;
commitid	10048809AD278B142AC;

1.45.2.3
date	2008.12.14.00.07.38;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.25.2.1
date	2007.05.13.19.29.34;	author tg;	state Exp;
branches;
next	1.25.2.2;
commitid	1004647668D4636830B;

1.25.2.2
date	2007.07.05.11.49.18;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.20.2.1
date	2007.03.03.21.37.54;	author tg;	state Exp;
branches;
next	1.20.2.2;
commitid	10045E9EAC27ABA6ADF;

1.20.2.2
date	2007.03.03.22.38.23;	author tg;	state Exp;
branches;
next	;
commitid	10045E9F8F5395F55BB;


desc
@@


1.222
log
@fix code placement issue that caused memory errors with invalid syntax

LP#1857828
@
text
@/*	$OpenBSD: eval.c,v 1.40 2013/09/14 20:09:30 millert Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.220 2019/12/11 23:58:17 tg Exp $");

/*
 * string expansion
 *
 * first pass: quoting, IFS separation, ~, ${}, $() and $(()) substitution.
 * second pass: alternation ({,}), filename expansion (*?[]).
 */

/* expansion generator state */
typedef struct {
	/* not including an "int type;" member, see expand() */
	/* string */
	const char *str;
	/* source */
	union {
		/* string[] */
		const char **strv;
		/* file */
		struct shf *shf;
	} u;
	/* variable in ${var...} */
	struct tbl *var;
	/* split "$@@" / call waitlast in $() */
	bool split;
} Expand;

#define	XBASE		0	/* scanning original */
#define	XSUB		1	/* expanding ${} string */
#define	XARGSEP		2	/* ifs0 between "$*" */
#define	XARG		3	/* expanding $*, $@@ */
#define	XCOM		4	/* expanding $() */
#define XNULLSUB	5	/* "$@@" when $# is 0 (don't generate word) */
#define XSUBMID		6	/* middle of expanding ${} */

/* States used for field splitting */
#define IFS_WORD	0	/* word has chars (or quotes except "$@@") */
#define IFS_WS		1	/* have seen IFS white-space */
#define IFS_NWS		2	/* have seen IFS non-white-space */
#define IFS_IWS		3	/* beginning of word, ignore IFS WS */
#define IFS_QUOTE	4	/* beg.w/quote, become IFS_WORD unless "$@@" */

#define STYPE_CHAR	0xFF
#define STYPE_DBL	0x100
#define STYPE_AT	0x200
#define STYPE_SINGLE	0x2FF
#define STYPE_MASK	0x300

static int varsub(Expand *, const char *, const char *, int *, int *);
static int comsub(Expand *, const char *, int);
static char *valsub(struct op *, Area *);
static char *trimsub(char *, char *, int);
static void glob(char *, XPtrV *, bool);
static void globit(XString *, char **, char *, XPtrV *, int);
static const char *maybe_expand_tilde(const char *, XString *, char **, bool);
#ifndef MKSH_NOPWNAM
static char *homedir(char *);
#endif
static void alt_expand(XPtrV *, char *, char *, char *, int);
static int utflen(const char *) MKSH_A_PURE;
static void utfincptr(const char *, mksh_ari_t *);

/* UTFMODE functions */
static int
utflen(const char *s)
{
	size_t n;

	if (UTFMODE) {
		n = 0;
		while (*s) {
			s += utf_ptradj(s);
			++n;
		}
	} else
		n = strlen(s);

	if (n > 2147483647)
		n = 2147483647;
	return ((int)n);
}

static void
utfincptr(const char *s, mksh_ari_t *lp)
{
	const char *cp = s;

	while ((*lp)--)
		cp += utf_ptradj(cp);
	*lp = cp - s;
}

/* compile and expand word */
char *
substitute(const char *cp, int f)
{
	struct source *s, *sold;

	sold = source;
	s = pushs(SWSTR, ATEMP);
	s->start = s->str = cp;
	source = s;
	if (yylex(ONEWORD) != LWORD)
		internal_errorf(Tbadsubst);
	source = sold;
	afree(s, ATEMP);
	return (evalstr(yylval.cp, f));
}

/*
 * expand arg-list
 */
char **
eval(const char **ap, int f)
{
	XPtrV w;

	if (*ap == NULL) {
		union mksh_ccphack vap;

		vap.ro = ap;
		return (vap.rw);
	}
	XPinit(w, 32);
	/* space for shell name */
	XPput(w, NULL);
	while (*ap != NULL)
		expand(*ap++, &w, f);
	XPput(w, NULL);
	return ((char **)XPclose(w) + 1);
}

/*
 * expand string
 */
char *
evalstr(const char *cp, int f)
{
	XPtrV w;
	char *dp = null;

	XPinit(w, 1);
	expand(cp, &w, f);
	if (XPsize(w))
		dp = *XPptrv(w);
	XPfree(w);
	return (dp);
}

/*
 * expand string - return only one component
 * used from iosetup to expand redirection files
 */
char *
evalonestr(const char *cp, int f)
{
	XPtrV w;
	char *rv;

	XPinit(w, 1);
	expand(cp, &w, f);
	switch (XPsize(w)) {
	case 0:
		rv = null;
		break;
	case 1:
		rv = (char *) *XPptrv(w);
		break;
	default:
		rv = evalstr(cp, f & ~DOGLOB);
		break;
	}
	XPfree(w);
	return (rv);
}

/* for nested substitution: ${var:=$var2} */
typedef struct SubType {
	struct tbl *var;	/* variable for ${var..} */
	struct SubType *prev;	/* old type */
	struct SubType *next;	/* poped type (to avoid re-allocating) */
	size_t	base;		/* start position of expanded word */
	short	stype;		/* [=+-?%#] action after expanded word */
	short	f;		/* saved value of f (DOPAT, etc) */
	uint8_t	quotep;		/* saved value of quote (for ${..[%#]..}) */
	uint8_t	quotew;		/* saved value of quote (for ${..[+-=]..}) */
} SubType;

void
expand(
    /* input word */
    const char *ccp,
    /* output words */
    XPtrV *wp,
    /* DO* flags */
    int f)
{
	int c = 0;
	/* expansion type */
	int type;
	/* quoted */
	int quote = 0;
	/* destination string and live pointer */
	XString ds;
	char *dp;
	/* source */
	const char *sp;
	/* second pass flags */
	int fdo;
	/* have word */
	int word;
	/* field splitting of parameter/command substitution */
	int doblank;
	/* expansion variables */
	Expand x = {
		NULL, { NULL }, NULL, 0
	};
	SubType st_head, *st;
	/* record number of trailing newlines in COMSUB */
	int newlines = 0;
	bool saw_eq, make_magic;
	unsigned int tilde_ok;
	size_t len;
	char *cp;

	if (ccp == NULL)
		internal_errorf("expand(NULL)");
	/* for alias, readonly, set, typeset commands */
	if ((f & DOVACHECK) && is_wdvarassign(ccp)) {
		f &= ~(DOVACHECK | DOBLANK | DOGLOB | DOTILDE);
		f |= DOASNTILDE | DOSCALAR;
	}
	if (Flag(FNOGLOB))
		f &= ~DOGLOB;
	if (Flag(FMARKDIRS))
		f |= DOMARKDIRS;
	if (Flag(FBRACEEXPAND) && (f & DOGLOB))
		f |= DOBRACE;

	/* init destination string */
	Xinit(ds, dp, 128, ATEMP);
	type = XBASE;
	sp = ccp;
	fdo = 0;
	saw_eq = false;
	/* must be 1/0 */
	tilde_ok = (f & (DOTILDE | DOASNTILDE)) ? 1 : 0;
	doblank = 0;
	make_magic = false;
	word = (f&DOBLANK) ? IFS_WS : IFS_WORD;
	/* clang doesn't know OSUBST comes before CSUBST */
	memset(&st_head, 0, sizeof(st_head));
	st = &st_head;

	while (/* CONSTCOND */ 1) {
		Xcheck(ds, dp);

		switch (type) {
		case XBASE:
			/* original prefixed string */
			c = ord(*sp++);
			switch (c) {
			case EOS:
				c = 0;
				break;
			case CHAR:
				c = ord(*sp++);
				break;
			case QCHAR:
				/* temporary quote */
				quote |= 2;
				c = ord(*sp++);
				break;
			case OQUOTE:
				if (word != IFS_WORD)
					word = IFS_QUOTE;
				tilde_ok = 0;
				quote = 1;
				continue;
			case CQUOTE:
				if (word == IFS_QUOTE)
					word = IFS_WORD;
				quote = st->quotew;
				continue;
			case COMASUB:
			case COMSUB:
			case FUNASUB:
			case FUNSUB:
			case VALSUB:
				tilde_ok = 0;
				if (f & DONTRUNCOMMAND) {
					word = IFS_WORD;
					*dp++ = '$';
					switch (c) {
					case COMASUB:
					case COMSUB:
						*dp++ = '(';
						c = ORD(')');
						break;
					case FUNASUB:
					case FUNSUB:
					case VALSUB:
						*dp++ = '{';
						*dp++ = c == VALSUB ? '|' : ' ';
						c = ORD('}');
						break;
					}
					while (*sp != '\0') {
						Xcheck(ds, dp);
						*dp++ = *sp++;
					}
					if ((unsigned int)c == ORD('}'))
						*dp++ = ';';
					*dp++ = c;
				} else {
					type = comsub(&x, sp, c);
					if (type != XBASE && (f & DOBLANK))
						doblank++;
					sp = strnul(sp) + 1;
					newlines = 0;
				}
				continue;
			case EXPRSUB:
				tilde_ok = 0;
				if (f & DONTRUNCOMMAND) {
					word = IFS_WORD;
					*dp++ = '$'; *dp++ = '('; *dp++ = '(';
					while (*sp != '\0') {
						Xcheck(ds, dp);
						*dp++ = *sp++;
					}
					*dp++ = ')'; *dp++ = ')';
				} else {
					struct tbl v;

					v.flag = DEFINED|ISSET|INTEGER;
					/* not default */
					v.type = 10;
					v.name[0] = '\0';
					v_evaluate(&v, substitute(sp, 0),
					    KSH_UNWIND_ERROR, true);
					sp = strnul(sp) + 1;
					x.str = str_val(&v);
					type = XSUB;
					if (f & DOBLANK)
						doblank++;
				}
				continue;
			case OSUBST: {
				/* ${{#}var{:}[=+-?#%]word} */
			/*-
			 * format is:
			 *	OSUBST [{x] plain-variable-part \0
			 *	    compiled-word-part CSUBST [}x]
			 * This is where all syntax checking gets done...
			 */
				/* skip the { or x (}) */
				const char *varname = ++sp;
				int stype;
				int slen = 0;

				/* skip variable */
				sp = cstrchr(sp, '\0') + 1;
				type = varsub(&x, varname, sp, &stype, &slen);
				if (type < 0) {
					char *beg, *end, *str;
 unwind_substsyn:
					/* restore sp */
					sp = varname - 2;
					beg = wdcopy(sp, ATEMP);
					end = (wdscan(cstrchr(sp, '\0') + 1,
					    CSUBST) - sp) + beg;
					/* ({) the } or x is already skipped */
					if (end < wdscan(beg, EOS))
						*end = EOS;
					str = snptreef(NULL, 64, Tf_S, beg);
					afree(beg, ATEMP);
					errorf(Tf_sD_s, str, Tbadsubst);
				}
				if (f & DOBLANK)
					doblank++;
				tilde_ok = 0;
				if (word == IFS_QUOTE && type != XNULLSUB)
					word = IFS_WORD;
				if (type == XBASE) {
					/* expand? */
					if (!st->next) {
						SubType *newst;

						newst = alloc(sizeof(SubType), ATEMP);
						newst->next = NULL;
						newst->prev = st;
						st->next = newst;
					}
					st = st->next;
					st->stype = stype;
					st->base = Xsavepos(ds, dp);
					st->f = f;
					if (x.var == vtemp) {
						st->var = tempvar(vtemp->name);
						st->var->flag &= ~INTEGER;
						/* can't fail here */
						setstr(st->var,
						    str_val(x.var),
						    KSH_RETURN_ERROR | 0x4);
					} else
						st->var = x.var;

					st->quotew = st->quotep = quote;
					/* skip qualifier(s) */
					if (stype)
						sp += slen;
					switch (stype & STYPE_SINGLE) {
					case ORD('#') | STYPE_AT:
					case ORD('Q') | STYPE_AT:
						break;
					case ORD('0'): {
						char *beg, *mid, *end, *stg;
						mksh_ari_t from = 0, num = -1, flen, finc = 0;

						beg = wdcopy(sp, ATEMP);
						mid = beg + (wdscan(sp, ADELIM) - sp);
						stg = beg + (wdscan(sp, CSUBST) - sp);
						mid[-2] = EOS;
						if (ord(mid[-1]) == ORD(/*{*/ '}')) {
							sp += mid - beg - 1;
							end = NULL;
						} else {
							end = mid +
							    (wdscan(mid, ADELIM) - mid);
							if (ord(end[-1]) != ORD(/*{*/ '}'))
								/* more than max delimiters */
								goto unwind_substsyn;
							end[-2] = EOS;
							sp += end - beg - 1;
						}
						evaluate(substitute(stg = wdstrip(beg, 0), 0),
						    &from, KSH_UNWIND_ERROR, true);
						afree(stg, ATEMP);
						if (end) {
							evaluate(substitute(stg = wdstrip(mid, 0), 0),
							    &num, KSH_UNWIND_ERROR, true);
							afree(stg, ATEMP);
						}
						afree(beg, ATEMP);
						beg = str_val(st->var);
						flen = utflen(beg);
						if (from < 0) {
							if (-from < flen)
								finc = flen + from;
						} else
							finc = from < flen ? from : flen;
						if (UTFMODE)
							utfincptr(beg, &finc);
						beg += finc;
						flen = utflen(beg);
						if (num < 0 || num > flen)
							num = flen;
						if (UTFMODE)
							utfincptr(beg, &num);
						strndupx(x.str, beg, num, ATEMP);
						goto do_CSUBST;
					    }
					case ORD('/') | STYPE_AT:
					case ORD('/'): {
						char *s, *p, *d, *sbeg;
						char *pat = NULL, *rrep;
						char fpat = 0, *tpat1, *tpat2;
						char *ws, *wpat, *wrep, tch;
						size_t rreplen;

						s = ws = wdcopy(sp, ATEMP);
						p = s + (wdscan(sp, ADELIM) - sp);
						d = s + (wdscan(sp, CSUBST) - sp);
						p[-2] = EOS;
						if (ord(p[-1]) == ORD(/*{*/ '}'))
							d = NULL;
						else
							d[-2] = EOS;
						sp += (d ? d : p) - s - 1;
						if (!(stype & STYPE_MASK) &&
						    s[0] == CHAR &&
						    ctype(s[1], C_SUB2))
							fpat = s[1];
						wpat = s + (fpat ? 2 : 0);
						if (!(wrep = d ? p : NULL)) {
							rrep = null;
							rreplen = 0;
						} else if (!(stype & STYPE_AT)) {
							rrep = evalstr(wrep,
							    DOTILDE | DOSCALAR);
							rreplen = strlen(rrep);
						} else {
							rrep = NULL;
							/* shut up GCC */
							rreplen = 0;
						}

						/* prepare string on which to work */
						strdupx(s, str_val(st->var), ATEMP);
						sbeg = s;
 again_search:
						pat = evalstr(wpat,
						    DOTILDE | DOSCALAR | DOPAT);
						/* check for special cases */
						if (!*pat && !fpat) {
							/*
							 * empty unanchored
							 * pattern => reject
							 */
							goto no_repl;
						}
						if ((stype & STYPE_MASK) &&
						    gmatchx(null, pat, false)) {
							/*
							 * pattern matches empty
							 * string => don't loop
							 */
							stype &= ~STYPE_MASK;
						}

						/* first see if we have any match at all */
						if (ord(fpat) == ORD('#')) {
							/* anchor at the beginning */
							tpat1 = shf_smprintf("%s%c*", pat, MAGIC);
							tpat2 = tpat1;
						} else if (ord(fpat) == ORD('%')) {
							/* anchor at the end */
							tpat1 = shf_smprintf("%c*%s", MAGIC, pat);
							tpat2 = pat;
						} else {
							/* float */
							tpat1 = shf_smprintf("%c*%s%c*", MAGIC, pat, MAGIC);
							tpat2 = tpat1 + 2;
						}
 again_repl:
						/*
						 * this would not be necessary if gmatchx would return
						 * the start and end values of a match found, like re*
						 */
						if (!gmatchx(sbeg, tpat1, false))
							goto end_repl;
						d = strnul(s);
						/* now anchor the beginning of the match */
						if (ord(fpat) != ORD('#'))
							while (sbeg <= d) {
								if (gmatchx(sbeg, tpat2, false))
									break;
								else
									sbeg++;
							}
						/* now anchor the end of the match */
						p = d;
						if (ord(fpat) != ORD('%'))
							while (p >= sbeg) {
								bool gotmatch;

								c = ord(*p);
								*p = '\0';
								gotmatch = tobool(gmatchx(sbeg, pat, false));
								*p = c;
								if (gotmatch)
									break;
								p--;
							}

						/* record partial string as match */
						tch = *p;
						*p = '\0';
						record_match(sbeg);
						*p = tch;
						/* get replacement string, if necessary */
						if ((stype & STYPE_AT) &&
						    rrep != null) {
							afree(rrep, ATEMP);
							/* might access match! */
							rrep = evalstr(wrep,
							    DOTILDE | DOSCALAR);
							rreplen = strlen(rrep);
						}

						/*
						 * string:
						 * |--------|---------|-------\0
						 * s  n1    sbeg  n2  p  n3   d
						 *
						 * replacement:
						 *          |------------|
						 *          rrep  rreplen
						 */

						/* move strings around and replace */
						{
							size_t n1 = sbeg - s;
							size_t n2 = p - sbeg;
							size_t n3 = d - p;
							/* move part3 to the front, OR… */
							if (rreplen < n2)
								memmove(sbeg + rreplen,
								    p, n3 + 1);
							/* … adjust size, move to back */
							if (rreplen > n2) {
								s = aresize(s,
								    n1 + rreplen + n3 + 1,
								    ATEMP);
								memmove(s + n1 + rreplen,
								    s + n1 + n2,
								    n3 + 1);
							}
							/* insert replacement */
							if (rreplen)
								memcpy(s + n1, rrep, rreplen);
							/* continue after the place */
							sbeg = s + n1 + rreplen;
						}
						if (stype & STYPE_AT) {
							afree(tpat1, ATEMP);
							afree(pat, ATEMP);
							goto again_search;
						} else if (stype & STYPE_DBL)
							goto again_repl;
 end_repl:
						afree(tpat1, ATEMP);
						x.str = s;
 no_repl:
						afree(pat, ATEMP);
						if (rrep != null)
							afree(rrep, ATEMP);
						afree(ws, ATEMP);
						goto do_CSUBST;
					    }
					case ORD('#'):
					case ORD('%'):
						/* ! DOBLANK,DOBRACE */
						f = (f & DONTRUNCOMMAND) |
						    DOPAT | DOTILDE |
						    DOTEMP | DOSCALAR;
						tilde_ok = 1;
						st->quotew = quote = 0;
						/*
						 * Prepend open pattern (so |
						 * in a trim will work as
						 * expected)
						 */
						if (!Flag(FSH)) {
							*dp++ = MAGIC;
							*dp++ = ORD(0x80 | '@@');
						}
						break;
					case ORD('='):
						/*
						 * Tilde expansion for string
						 * variables in POSIX mode is
						 * governed by Austinbug 351.
						 * In non-POSIX mode historic
						 * ksh behaviour (enable it!)
						 * us followed.
						 * Not doing tilde expansion
						 * for integer variables is a
						 * non-POSIX thing - makes
						 * sense though, since ~ is
						 * a arithmetic operator.
						 */
						if (!(x.var->flag & INTEGER))
							f |= DOASNTILDE | DOTILDE;
						f |= DOTEMP | DOSCALAR;
						/*
						 * These will be done after the
						 * value has been assigned.
						 */
						f &= ~(DOBLANK|DOGLOB|DOBRACE);
						tilde_ok = 1;
						break;
					case ORD('?'):
						if (*sp == CSUBST)
							errorf("%s: parameter null or not set",
							    st->var->name);
						f &= ~DOBLANK;
						f |= DOTEMP;
						/* FALLTHROUGH */
					default:
						/* '-' '+' '?' */
						if (quote)
							word = IFS_WORD;
						else if (dp == Xstring(ds, dp))
							word = IFS_IWS;
						/* Enable tilde expansion */
						tilde_ok = 1;
						f |= DOTILDE;
					}
				} else
					/* skip word */
					sp += wdscan(sp, CSUBST) - sp;
				continue;
			    }
			case CSUBST:
				/* only get here if expanding word */
 do_CSUBST:
				/* ({) skip the } or x */
				sp++;
				/* in case of ${unset:-} */
				tilde_ok = 0;
				*dp = '\0';
				quote = st->quotep;
				f = st->f;
				if (f & DOBLANK)
					doblank--;
				switch (st->stype & STYPE_SINGLE) {
				case ORD('#'):
				case ORD('%'):
					if (!Flag(FSH)) {
						/* Append end-pattern */
						*dp++ = MAGIC;
						*dp++ = ')';
					}
					*dp = '\0';
					dp = Xrestpos(ds, dp, st->base);
					/*
					 * Must use st->var since calling
					 * global would break things
					 * like x[i+=1].
					 */
					x.str = trimsub(str_val(st->var),
						dp, st->stype);
					if (x.str[0] != '\0') {
						word = IFS_IWS;
						type = XSUB;
					} else if (quote) {
						word = IFS_WORD;
						type = XSUB;
					} else {
						if (dp == Xstring(ds, dp))
							word = IFS_IWS;
						type = XNULLSUB;
					}
					if (f & DOBLANK)
						doblank++;
					st = st->prev;
					continue;
				case ORD('='):
					/*
					 * Restore our position and substitute
					 * the value of st->var (may not be
					 * the assigned value in the presence
					 * of integer/right-adj/etc attributes).
					 */
					dp = Xrestpos(ds, dp, st->base);
					/*
					 * Must use st->var since calling
					 * global would cause with things
					 * like x[i+=1] to be evaluated twice.
					 */
					/*
					 * Note: not exported by FEXPORT
					 * in AT&T ksh.
					 */
					/*
					 * XXX POSIX says readonly is only
					 * fatal for special builtins (setstr
					 * does readonly check).
					 */
					len = strlen(dp) + 1;
					setstr(st->var,
					    debunk(alloc(len, ATEMP),
					    dp, len), KSH_UNWIND_ERROR);
					x.str = str_val(st->var);
					type = XSUB;
					if (f & DOBLANK)
						doblank++;
					st = st->prev;
					word = quote || (!*x.str && (f & DOSCALAR)) ? IFS_WORD : IFS_IWS;
					continue;
				case ORD('?'):
					dp = Xrestpos(ds, dp, st->base);

					errorf(Tf_sD_s, st->var->name,
					    debunk(dp, dp, strlen(dp) + 1));
					break;
				case ORD('#') | STYPE_AT:
					x.str = shf_smprintf("%08X",
					    (unsigned int)hash(str_val(st->var)));
					goto common_CSUBST;
				case ORD('Q') | STYPE_AT: {
					struct shf shf;

					shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
					print_value_quoted(&shf, str_val(st->var));
					x.str = shf_sclose(&shf);
					goto common_CSUBST;
				    }
				case ORD('0'):
				case ORD('/') | STYPE_AT:
				case ORD('/'):
 common_CSUBST:
					dp = Xrestpos(ds, dp, st->base);
					type = XSUB;
					word = quote || (!*x.str && (f & DOSCALAR)) ? IFS_WORD : IFS_IWS;
					if (f & DOBLANK)
						doblank++;
					st = st->prev;
					continue;
				/* default: '-' '+' */
				}
				st = st->prev;
				type = XBASE;
				continue;

			case OPAT:
				/* open pattern: *(foo|bar) */
				/* Next char is the type of pattern */
				make_magic = true;
				c = ord(*sp++) | 0x80U;
				break;

			case SPAT:
				/* pattern separator (|) */
				make_magic = true;
				c = ORD('|');
				break;

			case CPAT:
				/* close pattern */
				make_magic = true;
				c = ORD(/*(*/ ')');
				break;
			}
			break;

		case XNULLSUB:
			/*
			 * Special case for "$@@" (and "${foo[@@]}") - no
			 * word is generated if $# is 0 (unless there is
			 * other stuff inside the quotes).
			 */
			type = XBASE;
			if (f & DOBLANK) {
				doblank--;
				if (dp == Xstring(ds, dp) && word != IFS_WORD)
					word = IFS_IWS;
			}
			continue;

		case XSUB:
		case XSUBMID:
			if ((c = ord(*x.str++)) == 0) {
				type = XBASE;
				if (f & DOBLANK)
					doblank--;
				continue;
			}
			break;

		case XARGSEP:
			type = XARG;
			quote = 1;
			/* FALLTHROUGH */
		case XARG:
			if ((c = ord(*x.str++)) == '\0') {
				/*
				 * force null words to be created so
				 * set -- "" 2 ""; echo "$@@" will do
				 * the right thing
				 */
				if (quote && x.split)
					word = IFS_WORD;
				if ((x.str = *x.u.strv++) == NULL) {
					type = XBASE;
					if (f & DOBLANK)
						doblank--;
					continue;
				}
				c = ord(ifs0);
				if ((f & DOHEREDOC)) {
					/* pseudo-field-split reliably */
					if (c == 0)
						c = ORD(' ');
					break;
				}
				if ((f & DOSCALAR)) {
					/* do not field-split */
					if (x.split) {
						c = ORD(' ');
						break;
					}
					if (c == 0)
						continue;
				}
				if (c == 0) {
					if (quote && !x.split)
						continue;
					if (!quote && word == IFS_WS)
						continue;
					/* this is so we don't terminate */
					c = ORD(' ');
					/* now force-emit a word */
					goto emit_word;
				}
				if (quote && x.split) {
					/* terminate word for "$@@" */
					type = XARGSEP;
					quote = 0;
				}
			}
			break;

		case XCOM:
			if (x.u.shf == NULL) {
				/* $(<...) failed */
				subst_exstat = 1;
				/* fake EOF */
				c = -1;
			} else if (newlines) {
				/* spit out saved NLs */
				c = ORD('\n');
				--newlines;
			} else {
				while ((c = shf_getc(x.u.shf)) == 0 ||
				    cinttype(c, C_NL)) {
#ifdef MKSH_WITH_TEXTMODE
					if (c == ORD('\r')) {
						c = shf_getc(x.u.shf);
						switch (c) {
						case ORD('\n'):
							break;
						default:
							shf_ungetc(c, x.u.shf);
							/* FALLTHROUGH */
						case -1:
							c = ORD('\r');
							break;
						}
					}
#endif
					if (c == ORD('\n'))
						/* save newlines */
						newlines++;
				}
				if (newlines && c != -1) {
					shf_ungetc(c, x.u.shf);
					c = ORD('\n');
					--newlines;
				}
			}
			if (c == -1) {
				newlines = 0;
				if (x.u.shf)
					shf_close(x.u.shf);
				if (x.split)
					subst_exstat = waitlast();
				type = XBASE;
				if (f & DOBLANK)
					doblank--;
				continue;
			}
			break;
		}

		/* check for end of word or IFS separation */
		if (c == 0 || (!quote && (f & DOBLANK) && doblank &&
		    !make_magic && ctype(c, C_IFS))) {
			/*-
			 * How words are broken up:
			 *			|	value of c
			 *	word		|	ws	nws	0
			 *	-----------------------------------
			 *	IFS_WORD		w/WS	w/NWS	w
			 *	IFS_WS			-/WS	-/NWS	-
			 *	IFS_NWS			-/NWS	w/NWS	-
			 *	IFS_IWS			-/WS	w/NWS	-
			 * (w means generate a word)
			 */
			if ((word == IFS_WORD) || (word == IFS_QUOTE) || (c &&
			    (word == IFS_IWS || word == IFS_NWS) &&
			    !ctype(c, C_IFSWS))) {
 emit_word:
				if (f & DOHERESTR)
					*dp++ = '\n';
				*dp++ = '\0';
				cp = Xclose(ds, dp);
				if (fdo & DOBRACE)
					/* also does globbing */
					alt_expand(wp, cp, cp,
					    cp + Xlength(ds, (dp - 1)),
					    fdo | (f & DOMARKDIRS));
				else if (fdo & DOGLOB)
					glob(cp, wp, tobool(f & DOMARKDIRS));
				else if ((f & DOPAT) || !(fdo & DOMAGIC))
					XPput(*wp, cp);
				else
					XPput(*wp, debunk(cp, cp,
					    strlen(cp) + 1));
				fdo = 0;
				saw_eq = false;
				/* must be 1/0 */
				tilde_ok = (f & (DOTILDE | DOASNTILDE)) ? 1 : 0;
				if (c == 0)
					return;
				Xinit(ds, dp, 128, ATEMP);
			} else if (c == 0) {
				return;
			} else if (type == XSUB && ctype(c, C_IFS) &&
			    !ctype(c, C_IFSWS) && Xlength(ds, dp) == 0) {
				*(cp = alloc(1, ATEMP)) = '\0';
				XPput(*wp, cp);
				type = XSUBMID;
			}
			if (word != IFS_NWS)
				word = ctype(c, C_IFSWS) ? IFS_WS : IFS_NWS;
		} else {
			if (type == XSUB) {
				if (word == IFS_NWS &&
				    Xlength(ds, dp) == 0) {
					*(cp = alloc(1, ATEMP)) = '\0';
					XPput(*wp, cp);
				}
				type = XSUBMID;
			}

			/* age tilde_ok info - ~ code tests second bit */
			tilde_ok <<= 1;
			/* mark any special second pass chars */
			if (!quote)
				switch (ord(c)) {
				case ORD('['):
				case ORD('!'):
				case ORD('-'):
				case ORD(']'):
					/*
					 * For character classes - doesn't hurt
					 * to have magic !,-,]s outside of
					 * [...] expressions.
					 */
					if (f & (DOPAT | DOGLOB)) {
						fdo |= DOMAGIC;
						if ((unsigned int)c == ORD('['))
							fdo |= f & DOGLOB;
						*dp++ = MAGIC;
					}
					break;
				case ORD('*'):
				case ORD('?'):
					if (f & (DOPAT | DOGLOB)) {
						fdo |= DOMAGIC | (f & DOGLOB);
						*dp++ = MAGIC;
					}
					break;
				case ORD('{'):
				case ORD('}'):
				case ORD(','):
					if ((f & DOBRACE) &&
					    (ord(c) == ORD('{' /*}*/) ||
					    (fdo & DOBRACE))) {
						fdo |= DOBRACE|DOMAGIC;
						*dp++ = MAGIC;
					}
					break;
				case ORD('='):
					/* Note first unquoted = for ~ */
					if (!(f & DOTEMP) && (!Flag(FPOSIX) ||
					    (f & DOASNTILDE)) && !saw_eq) {
						saw_eq = true;
						tilde_ok = 1;
					}
					break;
				case ORD(':'):
					/* : */
					/* Note unquoted : for ~ */
					if (!(f & DOTEMP) && (f & DOASNTILDE))
						tilde_ok = 1;
					break;
				case ORD('~'):
					/*
					 * tilde_ok is reset whenever
					 * any of ' " $( $(( ${ } are seen.
					 * Note that tilde_ok must be preserved
					 * through the sequence ${A=a=}~
					 */
					if (type == XBASE &&
					    (f & (DOTILDE | DOASNTILDE)) &&
					    (tilde_ok & 2)) {
						const char *tcp;
						char *tdp = dp;

						tcp = maybe_expand_tilde(sp,
						    &ds, &tdp,
						    tobool(f & DOASNTILDE));
						if (tcp) {
							if (dp != tdp)
								word = IFS_WORD;
							dp = tdp;
							sp = tcp;
							continue;
						}
					}
					break;
				}
			else
				/* undo temporary */
				quote &= ~2;

			if (make_magic) {
				make_magic = false;
				fdo |= DOMAGIC | (f & DOGLOB);
				*dp++ = MAGIC;
			} else if (ISMAGIC(c)) {
				fdo |= DOMAGIC;
				*dp++ = MAGIC;
			}
			/* save output char */
			*dp++ = c;
			word = IFS_WORD;
		}
	}
}

static bool
hasnonempty(const char **strv)
{
	size_t i = 0;

	while (strv[i])
		if (*strv[i++])
			return (true);
	return (false);
}

/*
 * Prepare to generate the string returned by ${} substitution.
 */
static int
varsub(Expand *xp, const char *sp, const char *word,
    int *stypep,	/* becomes qualifier type */
    int *slenp)		/* " " len (=, :=, etc.) valid iff *stypep != 0 */
{
	int c;
	int state;	/* next state: XBASE, XARG, XSUB, XNULLSUB */
	int stype;	/* substitution type */
	int slen = 0;
	const char *p;
	struct tbl *vp;
	bool zero_ok = false;

	if ((stype = ord(sp[0])) == '\0')
		/* Bad variable name */
		return (-1);

	xp->var = NULL;

	/*-
	 * ${#var}, string length (-U: characters, +U: octets) or array size
	 * ${%var}, string width (-U: screen columns, +U: octets)
	 */
	c = ord(sp[1]);
	if ((unsigned int)stype == ORD('%') && c == '\0')
		return (-1);
	if (ctype(stype, C_SUB2) && c != '\0') {
		/* Can't have any modifiers for ${#...} or ${%...} */
		if (*word != CSUBST)
			return (-1);
		sp++;
		/* Check for size of array */
		if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ORD('*') ||
		    ord(p[1]) == ORD('@@')) && ord(p[2]) == ORD(']')) {
			int n = 0;

			if ((unsigned int)stype != ORD('#'))
				return (-1);
			vp = global(arrayname(sp));
			if (vp->flag & (ISSET|ARRAY))
				zero_ok = true;
			for (; vp; vp = vp->u.array)
				if (vp->flag & ISSET)
					n++;
			c = n;
		} else if ((unsigned int)c == ORD('*') ||
		    (unsigned int)c == ORD('@@')) {
			if ((unsigned int)stype != ORD('#'))
				return (-1);
			c = e->loc->argc;
		} else {
			p = str_val(global(sp));
			zero_ok = p != null;
			if ((unsigned int)stype == ORD('#'))
				c = utflen(p);
			else {
				/* partial utf_mbswidth reimplementation */
				const char *s = p;
				unsigned int wc;
				size_t len;
				int cw;

				c = 0;
				while (*s) {
					if (!UTFMODE || (len = utf_mbtowc(&wc,
					    s)) == (size_t)-1)
						/* not UTFMODE or not UTF-8 */
						wc = rtt2asc(*s++);
					else
						/* UTFMODE and UTF-8 */
						s += len;
					/* wc == char or wchar at s++ */
					if ((cw = utf_wcwidth(wc)) == -1) {
						/* 646, 8859-1, 10646 C0/C1 */
						c = -1;
						break;
					}
					c += cw;
				}
			}
		}
		if (Flag(FNOUNSET) && c == 0 && !zero_ok)
			errorf(Tf_parm, sp);
		/* unqualified variable/string substitution */
		*stypep = 0;
		xp->str = shf_smprintf(Tf_d, c);
		return (XSUB);
	}
	if ((unsigned int)stype == ORD('!') && c != '\0' && *word == CSUBST) {
		sp++;
		if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ORD('*') ||
		    ord(p[1]) == ORD('@@')) && ord(p[2]) == ORD(']')) {
			c = ORD('!');
			stype = 0;
			goto arraynames;
		}
		xp->var = global(sp);
		xp->str = p ? shf_smprintf("%s[%lu]",
		    xp->var->name, arrayindex(xp->var)) : xp->var->name;
		*stypep = 0;
		return (XSUB);
	}

	/* Check for qualifiers in word part */
	stype = 0;
	c = word[slen + 0] == CHAR ? ord(word[slen + 1]) : 0;
	if ((unsigned int)c == ORD(':')) {
		slen += 2;
		stype = STYPE_DBL;
		c = word[slen + 0] == CHAR ? ord(word[slen + 1]) : 0;
	}
	if (!stype && (unsigned int)c == ORD('/')) {
		slen += 2;
		stype = c;
		if (word[slen] == ADELIM &&
		    ord(word[slen + 1]) == (unsigned int)c) {
			slen += 2;
			stype |= STYPE_DBL;
		}
	} else if (stype == STYPE_DBL && ((unsigned int)c == ORD(' ') ||
	    (unsigned int)c == ORD('0'))) {
		stype |= ORD('0');
	} else if (ctype(c, C_SUB1)) {
		slen += 2;
		stype |= c;
	} else if (ctype(c, C_SUB2)) {
		/* Note: ksh88 allows :%, :%%, etc */
		slen += 2;
		stype = c;
		if (word[slen + 0] == CHAR &&
		    ord(word[slen + 1]) == (unsigned int)c) {
			stype |= STYPE_DBL;
			slen += 2;
		}
	} else if ((unsigned int)c == ORD('@@')) {
		/* @@x where x is command char */
		switch (c = ord(word[slen + 2]) == CHAR ?
		    ord(word[slen + 3]) : 0) {
		case ORD('#'):
		case ORD('/'):
		case ORD('Q'):
			break;
		default:
			return (-1);
		}
		stype |= STYPE_AT | c;
		slen += 4;
	} else if (stype)
		/* : is not ok */
		return (-1);
	if (!stype && *word != CSUBST)
		return (-1);

	c = ord(sp[0]);
	if ((unsigned int)c == ORD('*') || (unsigned int)c == ORD('@@')) {
		switch (stype & STYPE_SINGLE) {
		/* can't assign to a vector */
		case ORD('='):
		/* can't trim a vector (yet) */
		case ORD('%'):
		case ORD('#'):
		case ORD('?'):
		case ORD('0'):
		case ORD('/') | STYPE_AT:
		case ORD('/'):
		case ORD('#') | STYPE_AT:
		case ORD('Q') | STYPE_AT:
			return (-1);
		}
		if (e->loc->argc == 0) {
			xp->str = null;
			xp->var = global(sp);
			state = (unsigned int)c == ORD('@@') ? XNULLSUB : XSUB;
		} else {
			xp->u.strv = (const char **)e->loc->argv + 1;
			xp->str = *xp->u.strv++;
			/* $@@ */
			xp->split = tobool((unsigned int)c == ORD('@@'));
			state = XARG;
		}
		/* POSIX 2009? */
		zero_ok = true;
	} else if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ORD('*') ||
	    ord(p[1]) == ORD('@@')) && ord(p[2]) == ORD(']')) {
		XPtrV wv;

		switch (stype & STYPE_SINGLE) {
		/* can't assign to a vector */
		case ORD('='):
		/* can't trim a vector (yet) */
		case ORD('%'):
		case ORD('#'):
		case ORD('?'):
		case ORD('0'):
		case ORD('/') | STYPE_AT:
		case ORD('/'):
		case ORD('#') | STYPE_AT:
		case ORD('Q') | STYPE_AT:
			return (-1);
		}
		c = 0;
 arraynames:
		XPinit(wv, 32);
		vp = global(arrayname(sp));
		for (; vp; vp = vp->u.array) {
			if (!(vp->flag&ISSET))
				continue;
			XPput(wv, (unsigned int)c == ORD('!') ?
			    shf_smprintf(Tf_lu, arrayindex(vp)) :
			    str_val(vp));
		}
		if (XPsize(wv) == 0) {
			xp->str = null;
			state = ord(p[1]) == ORD('@@') ? XNULLSUB : XSUB;
			XPfree(wv);
		} else {
			XPput(wv, 0);
			xp->u.strv = (const char **)XPptrv(wv);
			xp->str = *xp->u.strv++;
			/* ${foo[@@]} */
			xp->split = tobool(ord(p[1]) == ORD('@@'));
			state = XARG;
		}
	} else {
		xp->var = global(sp);
		xp->str = str_val(xp->var);
		/* can't assign things like $! or $1 */
		if ((unsigned int)(stype & STYPE_SINGLE) == ORD('=') &&
		    !*xp->str && ctype(*sp, C_VAR1 | C_DIGIT))
			return (-1);
		state = XSUB;
	}

	c = stype & STYPE_CHAR;
	/* test the compiler's code generator */
	if ((!(stype & STYPE_AT) && (ctype(c, C_SUB2) ||
	    (((stype & STYPE_DBL) ? *xp->str == '\0' : xp->str == null) &&
	    (state != XARG || (ifs0 || xp->split ?
	    (xp->u.strv[0] == NULL) : !hasnonempty(xp->u.strv))) ?
	    ctype(c, C_EQUAL | C_MINUS | C_QUEST) : (unsigned int)c == ORD('+')))) ||
	    (unsigned int)stype == (ORD('0') | STYPE_DBL) ||
	    (unsigned int)stype == (ORD('#') | STYPE_AT) ||
	    (unsigned int)stype == (ORD('Q') | STYPE_AT) ||
	    (unsigned int)(stype & STYPE_CHAR) == ORD('/'))
		/* expand word instead of variable value */
		state = XBASE;
	if (Flag(FNOUNSET) && xp->str == null && !zero_ok &&
	    (ctype(c, C_SUB2) || (state != XBASE && (unsigned int)c != ORD('+'))))
		errorf(Tf_parm, sp);
	*stypep = stype;
	*slenp = slen;
	return (state);
}

/*
 * Run the command in $(...) and read its output.
 */
static int
comsub(Expand *xp, const char *cp, int fn)
{
	Source *s, *sold;
	struct op *t;
	struct shf *shf;
	bool doalias = false;
	uint8_t old_utfmode = UTFMODE;

	switch (fn) {
	case COMASUB:
		fn = COMSUB;
		if (0)
			/* FALLTHROUGH */
	case FUNASUB:
		  fn = FUNSUB;
		doalias = true;
	}

	s = pushs(SSTRING, ATEMP);
	s->start = s->str = cp;
	sold = source;
	t = compile(s, true, doalias);
	afree(s, ATEMP);
	source = sold;

	UTFMODE = old_utfmode;

	if (t == NULL)
		return (XBASE);

	/* no waitlast() unless specifically enabled later */
	xp->split = false;

	if (t->type == TCOM &&
	    *t->args == NULL && *t->vars == NULL && t->ioact != NULL) {
		/* $(<file) */
		struct ioword *io = *t->ioact;
		char *name;

		switch (io->ioflag & IOTYPE) {
		case IOREAD:
			shf = shf_open(name = evalstr(io->ioname, DOTILDE),
				O_RDONLY, 0, SHF_MAPHI | SHF_CLEXEC);
			if (shf == NULL)
				warningf(!Flag(FTALKING), Tf_sD_s_sD_s,
				    name, Tcant_open, "$(<...) input",
				    cstrerror(errno));
			break;
		case IOHERE:
			if (!herein(io, &name)) {
				xp->str = name;
				/* as $(…) requires, trim trailing newlines */
				name = strnul(name);
				while (name > xp->str && name[-1] == '\n')
					--name;
				*name = '\0';
				return (XSUB);
			}
			shf = NULL;
			break;
		default:
			errorf(Tf_sD_s, T_funny_command,
			    snptreef(NULL, 32, Tft_R, io));
		}
	} else if (fn == FUNSUB) {
		int ofd1;
		struct temp *tf = NULL;

		/*
		 * create a temporary file, open for reading and writing,
		 * with an shf open for reading (buffered) but yet unused
		 */
		maketemp(ATEMP, TT_FUNSUB, &tf);
		if (!tf->shf) {
			errorf(Tf_temp,
			    Tcreate, tf->tffn, cstrerror(errno));
		}
		/* extract shf from temporary file, unlink and free it */
		shf = tf->shf;
		unlink(tf->tffn);
		afree(tf, ATEMP);
		/* save stdout and let it point to the tempfile */
		ofd1 = savefd(1);
		ksh_dup2(shf_fileno(shf), 1, false);
		/*
		 * run tree, with output thrown into the tempfile,
		 * in a new function block
		 */
		valsub(t, NULL);
		subst_exstat = exstat & 0xFF;
		/* rewind the tempfile and restore regular stdout */
		lseek(shf_fileno(shf), (off_t)0, SEEK_SET);
		restfd(1, ofd1);
	} else if (fn == VALSUB) {
		xp->str = valsub(t, ATEMP);
		subst_exstat = exstat & 0xFF;
		return (XSUB);
	} else {
		int ofd1, pv[2];

		openpipe(pv);
		shf = shf_fdopen(pv[0], SHF_RD, NULL);
		ofd1 = savefd(1);
		if (pv[1] != 1) {
			ksh_dup2(pv[1], 1, false);
			close(pv[1]);
		}
		execute(t, XXCOM | XPIPEO | XFORK, NULL);
		restfd(1, ofd1);
		startlast();
		/* waitlast() */
		xp->split = true;
	}

	xp->u.shf = shf;
	return (XCOM);
}

/*
 * perform #pattern and %pattern substitution in ${}
 */
static char *
trimsub(char *str, char *pat, int how)
{
	char *end = strnul(str);
	char *p, c;

	switch (how & (STYPE_CHAR | STYPE_DBL)) {
	case ORD('#'):
		/* shortest match at beginning */
		for (p = str; p <= end; p += utf_ptradj(p)) {
			c = *p; *p = '\0';
			if (gmatchx(str, pat, false)) {
				record_match(str);
				*p = c;
				return (p);
			}
			*p = c;
		}
		break;
	case ORD('#') | STYPE_DBL:
		/* longest match at beginning */
		for (p = end; p >= str; p--) {
			c = *p; *p = '\0';
			if (gmatchx(str, pat, false)) {
				record_match(str);
				*p = c;
				return (p);
			}
			*p = c;
		}
		break;
	case ORD('%'):
		/* shortest match at end */
		p = end;
		while (p >= str) {
			if (gmatchx(p, pat, false))
				goto trimsub_match;
			if (UTFMODE) {
				char *op = p;
				while ((p-- > str) && ((rtt2asc(*p) & 0xC0) == 0x80))
					;
				if ((p < str) || (p + utf_ptradj(p) != op))
					p = op - 1;
			} else
				--p;
		}
		break;
	case ORD('%') | STYPE_DBL:
		/* longest match at end */
		for (p = str; p <= end; p++)
			if (gmatchx(p, pat, false)) {
 trimsub_match:
				record_match(p);
				strndupx(end, str, p - str, ATEMP);
				return (end);
			}
		break;
	}

	/* no match, return string */
	return (str);
}

/*
 * glob
 * Name derived from V6's /etc/glob, the program that expanded filenames.
 */

/* XXX cp not const 'cause slashes are temporarily replaced with NULs... */
static void
glob(char *cp, XPtrV *wp, bool markdirs)
{
	int oldsize = XPsize(*wp);

	if (glob_str(cp, wp, markdirs) == 0)
		XPput(*wp, debunk(cp, cp, strlen(cp) + 1));
	else
		qsort(XPptrv(*wp) + oldsize, XPsize(*wp) - oldsize,
		    sizeof(void *), ascpstrcmp);
}

#define GF_NONE		0
#define GF_EXCHECK	BIT(0)		/* do existence check on file */
#define GF_GLOBBED	BIT(1)		/* some globbing has been done */
#define GF_MARKDIR	BIT(2)		/* add trailing / to directories */

/*
 * Apply file globbing to cp and store the matching files in wp. Returns
 * the number of matches found.
 */
int
glob_str(char *cp, XPtrV *wp, bool markdirs)
{
	int oldsize = XPsize(*wp);
	XString xs;
	char *xp;

	Xinit(xs, xp, 256, ATEMP);
	globit(&xs, &xp, cp, wp, markdirs ? GF_MARKDIR : GF_NONE);
	Xfree(xs, xp);

	return (XPsize(*wp) - oldsize);
}

static void
globit(XString *xs,	/* dest string */
    char **xpp,		/* ptr to dest end */
    char *sp,		/* source path */
    XPtrV *wp,		/* output list */
    int check)		/* GF_* flags */
{
	char *np;		/* next source component */
	char *xp = *xpp;
	char *se;
	char odirsep;

	/* This to allow long expansions to be interrupted */
	intrcheck();

	if (sp == NULL) {
		/* end of source path */
		/*
		 * We only need to check if the file exists if a pattern
		 * is followed by a non-pattern (eg, foo*x/bar; no check
		 * is needed for foo* since the match must exist) or if
		 * any patterns were expanded and the markdirs option is set.
		 * Symlinks make things a bit tricky...
		 */
		if ((check & GF_EXCHECK) ||
		    ((check & GF_MARKDIR) && (check & GF_GLOBBED))) {
#define stat_check()	(stat_done ? stat_done : (stat_done = \
			    stat(Xstring(*xs, xp), &statb) < 0 ? -1 : 1))
			struct stat lstatb, statb;
			/* -1: failed, 1 ok, 0 not yet done */
			int stat_done = 0;

			if (mksh_lstat(Xstring(*xs, xp), &lstatb) < 0)
				return;
			/*
			 * special case for systems which strip trailing
			 * slashes from regular files (eg, /etc/passwd/).
			 * SunOS 4.1.3 does this...
			 */
			if ((check & GF_EXCHECK) && xp > Xstring(*xs, xp) &&
			    mksh_cdirsep(xp[-1]) && !S_ISDIR(lstatb.st_mode) &&
			    (!S_ISLNK(lstatb.st_mode) ||
			    stat_check() < 0 || !S_ISDIR(statb.st_mode)))
				return;
			/*
			 * Possibly tack on a trailing / if there isn't already
			 * one and if the file is a directory or a symlink to a
			 * directory
			 */
			if (((check & GF_MARKDIR) && (check & GF_GLOBBED)) &&
			    xp > Xstring(*xs, xp) && !mksh_cdirsep(xp[-1]) &&
			    (S_ISDIR(lstatb.st_mode) ||
			    (S_ISLNK(lstatb.st_mode) && stat_check() > 0 &&
			    S_ISDIR(statb.st_mode)))) {
				*xp++ = '/';
				*xp = '\0';
			}
		}
		strndupx(np, Xstring(*xs, xp), Xlength(*xs, xp), ATEMP);
		XPput(*wp, np);
		return;
	}

	if (xp > Xstring(*xs, xp))
		*xp++ = '/';
	while (mksh_cdirsep(*sp)) {
		Xcheck(*xs, xp);
		*xp++ = *sp++;
	}
	np = mksh_sdirsep(sp);
	if (np != NULL) {
		se = np;
		/* don't assume '/', can be multiple kinds */
		odirsep = *np;
		*np++ = '\0';
	} else {
		odirsep = '\0'; /* keep gcc quiet */
		se = strnul(sp);
	}


	/*
	 * Check if sp needs globbing - done to avoid pattern checks for strings
	 * containing MAGIC characters, open [s without the matching close ],
	 * etc. (otherwise opendir() will be called which may fail because the
	 * directory isn't readable - if no globbing is needed, only execute
	 * permission should be required (as per POSIX)).
	 */
	if (!has_globbing(sp)) {
		XcheckN(*xs, xp, se - sp + 1);
		debunk(xp, sp, Xnleft(*xs, xp));
		xp = strnul(xp);
		*xpp = xp;
		globit(xs, xpp, np, wp, check);
	} else {
		DIR *dirp;
		struct dirent *d;
		char *name;
		size_t len, prefix_len;

		/* xp = *xpp;	copy_non_glob() may have re-alloc'd xs */
		*xp = '\0';
		prefix_len = Xlength(*xs, xp);
		dirp = opendir(prefix_len ? Xstring(*xs, xp) : Tdot);
		if (dirp == NULL)
			goto Nodir;
		while ((d = readdir(dirp)) != NULL) {
			name = d->d_name;
			if (name[0] == '.' &&
			    (name[1] == 0 || (name[1] == '.' && name[2] == 0)))
				/* always ignore . and .. */
				continue;
			if ((*name == '.' && *sp != '.') ||
			    !gmatchx(name, sp, true))
				continue;

			len = strlen(d->d_name) + 1;
			XcheckN(*xs, xp, len);
			memcpy(xp, name, len);
			*xpp = xp + len - 1;
			globit(xs, xpp, np, wp, (check & GF_MARKDIR) |
			    GF_GLOBBED | (np ? GF_EXCHECK : GF_NONE));
			xp = Xstring(*xs, xp) + prefix_len;
		}
		closedir(dirp);
 Nodir:
		;
	}

	if (np != NULL)
		*--np = odirsep;
}

/* remove MAGIC from string */
char *
debunk(char *dp, const char *sp, size_t dlen)
{
	char *d;
	const char *s;

	if ((s = cstrchr(sp, MAGIC))) {
		if (s - sp >= (ssize_t)dlen)
			return (dp);
		memmove(dp, sp, s - sp);
		for (d = dp + (s - sp); *s && (d - dp < (ssize_t)dlen); s++)
			if (!ISMAGIC(*s) || !(*++s & 0x80) ||
			    !ctype(*s & 0x7F, C_PATMO | C_SPC))
				*d++ = *s;
			else {
				/* extended pattern operators: *+?@@! */
				if ((*s & 0x7f) != ' ')
					*d++ = *s & 0x7f;
				if (d - dp < (ssize_t)dlen)
					*d++ = '(';
			}
		*d = '\0';
	} else if (dp != sp)
		strlcpy(dp, sp, dlen);
	return (dp);
}

/*
 * Check if p is an unquoted name, possibly followed by a / or :. If so
 * puts the expanded version in *dcp,dp and returns a pointer in p just
 * past the name, otherwise returns 0.
 */
static const char *
maybe_expand_tilde(const char *p, XString *dsp, char **dpp, bool isassign)
{
	XString ts;
	char *dp = *dpp;
	char *tp;
	const char *r;

	Xinit(ts, tp, 16, ATEMP);
	/* : only for DOASNTILDE form */
	while (p[0] == CHAR && /* not cdirsep */ p[1] != '/' &&
	    (!isassign || p[1] != ':')) {
		Xcheck(ts, tp);
		*tp++ = p[1];
		p += 2;
	}
	*tp = '\0';
	r = (p[0] == EOS || p[0] == CHAR || p[0] == CSUBST) ?
	    do_tilde(Xstring(ts, tp)) : NULL;
	Xfree(ts, tp);
	if (r) {
		while (*r) {
			Xcheck(*dsp, dp);
			if (ISMAGIC(*r))
				*dp++ = MAGIC;
			*dp++ = *r++;
		}
		*dpp = dp;
		r = p;
	}
	return (r);
}

/*
 * tilde expansion
 *
 * based on a version by Arnold Robbins
 */
char *
do_tilde(char *cp)
{
	char *dp = null;
#ifndef MKSH_NOPWNAM
	bool do_simplify = true;
#endif

	if (cp[0] == '\0')
		dp = str_val(global("HOME"));
	else if (cp[0] == '+' && cp[1] == '\0')
		dp = str_val(global(TPWD));
	else if (ksh_isdash(cp))
		dp = str_val(global(TOLDPWD));
#ifndef MKSH_NOPWNAM
	else {
		dp = homedir(cp);
		do_simplify = false;
	}
#endif

	/* if parameters aren't set, don't expand ~ */
	if (dp == NULL || dp == null)
		return (NULL);

	/* simplify parameters as if cwd upon entry */
#ifndef MKSH_NOPWNAM
	if (do_simplify)
#endif
	  {
		strdupx(dp, dp, ATEMP);
		simplify_path(dp);
	}
	return (dp);
}

#ifndef MKSH_NOPWNAM
/*
 * map userid to user's home directory.
 * note that 4.3's getpw adds more than 6K to the shell,
 * and the YP version probably adds much more.
 * we might consider our own version of getpwnam() to keep the size down.
 */
static char *
homedir(char *name)
{
	struct tbl *ap;

	ap = ktenter(&homedirs, name, hash(name));
	if (!(ap->flag & ISSET)) {
		struct passwd *pw;

		pw = getpwnam(name);
		if (pw == NULL)
			return (NULL);
		strdupx(ap->val.s, pw->pw_dir, APERM);
		ap->flag |= DEFINED|ISSET|ALLOC;
	}
	return (ap->val.s);
}
#endif

static void
alt_expand(XPtrV *wp, char *start, char *exp_start, char *end, int fdo)
{
	unsigned int count = 0;
	char *brace_start, *brace_end, *comma = NULL;
	char *field_start;
	char *p = exp_start;

	/* search for open brace */
	while ((p = strchr(p, MAGIC)) && ord(p[1]) != ORD('{' /*}*/))
		p += 2;
	brace_start = p;

	/* find matching close brace, if any */
	if (p) {
		comma = NULL;
		count = 1;
		p += 2;
		while (*p && count) {
			if (ISMAGIC(*p++)) {
				if (ord(*p) == ORD('{' /*}*/))
					++count;
				else if (ord(*p) == ORD(/*{*/ '}'))
					--count;
				else if (*p == ',' && count == 1)
					comma = p;
				++p;
			}
		}
	}
	/* no valid expansions... */
	if (!p || count != 0) {
		/*
		 * Note that given a{{b,c} we do not expand anything (this is
		 * what AT&T ksh does. This may be changed to do the {b,c}
		 * expansion. }
		 */
		if (fdo & DOGLOB)
			glob(start, wp, tobool(fdo & DOMARKDIRS));
		else
			XPput(*wp, debunk(start, start, end - start));
		return;
	}
	brace_end = p;
	if (!comma) {
		alt_expand(wp, start, brace_end, end, fdo);
		return;
	}

	/* expand expression */
	field_start = brace_start + 2;
	count = 1;
	for (p = brace_start + 2; p != brace_end; p++) {
		if (ISMAGIC(*p)) {
			if (ord(*++p) == ORD('{' /*}*/))
				++count;
			else if ((ord(*p) == ORD(/*{*/ '}') && --count == 0) ||
			    (*p == ',' && count == 1)) {
				char *news;
				int l1, l2, l3;

				/*
				 * addition safe since these operate on
				 * one string (separate substrings)
				 */
				l1 = brace_start - start;
				l2 = (p - 1) - field_start;
				l3 = end - brace_end;
				news = alloc(l1 + l2 + l3 + 1, ATEMP);
				memcpy(news, start, l1);
				memcpy(news + l1, field_start, l2);
				memcpy(news + l1 + l2, brace_end, l3);
				news[l1 + l2 + l3] = '\0';
				alt_expand(wp, news, news + l1,
				    news + l1 + l2 + l3, fdo);
				field_start = p + 1;
			}
		}
	}
	return;
}

/* helper function due to setjmp/longjmp woes */
static char *
valsub(struct op *t, Area *ap)
{
	char * volatile cp = NULL;
	struct tbl * volatile vp = NULL;

	newenv(E_FUNC);
	newblock();
	if (ap)
		vp = local("REPLY", false);
	if (!kshsetjmp(e->jbuf))
		execute(t, XXCOM | XERROK, NULL);
	if (vp)
		strdupx(cp, str_val(vp), ap);
	quitenv(NULL);

	return (cp);
}
@


1.221
log
@fix the realloc dance in substitution expansion as well
@
text
@d441 1
a441 2
						x.str = shf_smprintf("%08X",
						    (unsigned int)hash(str_val(st->var)));
a442 8
					case ORD('Q') | STYPE_AT: {
						struct shf shf;

						shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
						print_value_quoted(&shf, str_val(st->var));
						x.str = shf_sclose(&shf);
						break;
					    }
d805 12
d820 1
a820 2
				case ORD('#') | STYPE_AT:
				case ORD('Q') | STYPE_AT:
@


1.220
log
@further memory optimisation
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.217 2018/01/14 00:03:02 tg Exp $");
d501 2
a502 2
						char *s, *p, *d, *sbeg, *end;
						char *pat = NULL, *rrep = null;
d505 1
d521 11
a531 5
						wrep = d ? p : NULL;
						if (!(stype & STYPE_AT)) {
							rrep = wrep ? evalstr(wrep,
							    DOTILDE | DOSCALAR) :
							    null;
d578 1
a578 1
						end = strnul(s);
d581 1
a581 1
							while (sbeg <= end) {
d588 1
a588 1
						p = end;
d601 1
d607 8
a614 7
						/* go on */
						if (stype & STYPE_AT) {
							if (rrep != null)
								afree(rrep, ATEMP);
							rrep = wrep ? evalstr(wrep,
							    DOTILDE | DOSCALAR) :
							    null;
d616 12
d630 20
a649 10
							size_t n2 = strlen(rrep);
							size_t n3 = strlen(p);
							/*XXX do this without alloc+free */
							d = alloc(n1 + n2 + n3 + 1, ATEMP);
							memcpy(d, s, n1);
							memcpy(d + n1, rrep, n2);
							/* this can become tricky */
							memcpy(d + n1 + n2, p, n3);
							d[n1 + n2 + n3] = '\0';
							sbeg = d + n1 + n2;
a650 2
						afree(s, ATEMP);
						s = d;
@


1.219
log
@write ord’ed into c
@
text
@d5 2
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d504 1
a504 1
						char *ws, *wpat, *wrep;
d594 6
a599 3
						strndupx(end, sbeg, p - sbeg, ATEMP);
						record_match(end);
						afree(end, ATEMP);
d607 13
a619 4
						strndupx(end, s, sbeg - s, ATEMP);
						d = shf_smprintf(Tf_sss, end, rrep, p);
						afree(end, ATEMP);
						sbeg = d + (sbeg - s) + strlen(rrep);
@


1.218
log
@plug the first couple of ctype bugs
@
text
@d585 1
a585 1
								c = *p;
d794 1
a794 1
				c = *sp++ | 0x80;
d800 1
a800 1
				c = '|';
d806 1
a806 1
				c = /*(*/ ')';
d827 1
a827 1
			if ((c = *x.str++) == 0) {
d840 1
a840 1
			if ((c = *x.str++) == '\0') {
d858 1
a858 1
						c = ' ';
d864 1
a864 1
						c = ' ';
d876 1
a876 1
					c = ' ';
d896 1
a896 1
				c = '\n';
d902 1
a902 1
					if (c == '\r') {
d905 1
a905 1
						case '\n':
d911 1
a911 1
							c = '\r';
d916 1
a916 1
					if (c == '\n')
d922 1
a922 1
					c = '\n';
@


1.217
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.214 2017/05/05 22:53:27 tg Exp $");
d900 1
a900 1
				    ctype(c, C_NL)) {
@


1.216
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d439 1
a439 1
					case CORD('#') | STYPE_AT:
d443 1
a443 1
					case CORD('Q') | STYPE_AT: {
d451 1
a451 1
					case CORD('0'): {
d498 2
a499 2
					case CORD('/') | STYPE_AT:
					case CORD('/'): {
d625 2
a626 2
					case CORD('#'):
					case CORD('%'):
d643 1
a643 1
					case CORD('='):
d667 1
a667 1
					case CORD('?'):
d702 2
a703 2
				case CORD('#'):
				case CORD('%'):
d733 1
a733 1
				case CORD('='):
d766 1
a766 1
				case CORD('?'):
d772 5
a776 5
				case CORD('0'):
				case CORD('/') | STYPE_AT:
				case CORD('/'):
				case CORD('#') | STYPE_AT:
				case CORD('Q') | STYPE_AT:
d1006 4
a1009 4
				case CORD('['):
				case CORD('!'):
				case CORD('-'):
				case CORD(']'):
d1022 2
a1023 2
				case CORD('*'):
				case CORD('?'):
d1029 3
a1031 3
				case CORD('{'):
				case CORD('}'):
				case CORD(','):
d1039 1
a1039 1
				case CORD('='):
d1047 1
a1047 1
				case CORD(':'):
d1053 1
a1053 1
				case CORD('~'):
d1250 3
a1252 3
		case CORD('#'):
		case CORD('/'):
		case CORD('Q'):
d1269 1
a1269 1
		case CORD('='):
d1271 8
a1278 8
		case CORD('%'):
		case CORD('#'):
		case CORD('?'):
		case CORD('0'):
		case CORD('/') | STYPE_AT:
		case CORD('/'):
		case CORD('#') | STYPE_AT:
		case CORD('Q') | STYPE_AT:
d1300 1
a1300 1
		case CORD('='):
d1302 8
a1309 8
		case CORD('%'):
		case CORD('#'):
		case CORD('?'):
		case CORD('0'):
		case CORD('/') | STYPE_AT:
		case CORD('/'):
		case CORD('#') | STYPE_AT:
		case CORD('Q') | STYPE_AT:
d1498 1
a1498 1
	case CORD('#'):
d1510 1
a1510 1
	case CORD('#') | STYPE_DBL:
d1522 1
a1522 1
	case CORD('%'):
d1538 1
a1538 1
	case CORD('%') | STYPE_DBL:
@


1.215
log
@quell a Fink compiler warning; not entirely correct but no harm done either
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d323 1
a323 1
						c = ord(')');
d330 1
a330 1
						c = ord('}');
d337 1
a337 1
					if (c == ord('}'))
d439 1
a439 1
					case ord('#') | STYPE_AT:
d443 1
a443 1
					case ord('Q') | STYPE_AT: {
d451 1
a451 1
					case ord('0'): {
d459 1
a459 1
						if (ord(mid[-1]) == ord(/*{*/ '}')) {
d465 1
a465 1
							if (ord(end[-1]) != ord(/*{*/ '}'))
d498 2
a499 2
					case ord('/') | STYPE_AT:
					case ord('/'): {
d509 1
a509 1
						if (ord(p[-1]) == ord(/*{*/ '}'))
d550 1
a550 1
						if (ord(fpat) == ord('#')) {
d554 1
a554 1
						} else if (ord(fpat) == ord('%')) {
d572 1
a572 1
						if (ord(fpat) != ord('#'))
d581 1
a581 1
						if (ord(fpat) != ord('%'))
d625 2
a626 2
					case ord('#'):
					case ord('%'):
d640 1
a640 1
							*dp++ = ord(0x80 | '@@');
d643 1
a643 1
					case ord('='):
d667 1
a667 1
					case ord('?'):
d702 2
a703 2
				case ord('#'):
				case ord('%'):
d733 1
a733 1
				case ord('='):
d766 1
a766 1
				case ord('?'):
d772 5
a776 5
				case ord('0'):
				case ord('/') | STYPE_AT:
				case ord('/'):
				case ord('#') | STYPE_AT:
				case ord('Q') | STYPE_AT:
d1006 4
a1009 4
				case ord('['):
				case ord('!'):
				case ord('-'):
				case ord(']'):
d1017 1
a1017 1
						if (c == ord('['))
d1022 2
a1023 2
				case ord('*'):
				case ord('?'):
d1029 3
a1031 3
				case ord('{'):
				case ord('}'):
				case ord(','):
d1033 1
a1033 1
					    (ord(c) == ord('{' /*}*/) ||
d1039 1
a1039 1
				case ord('='):
d1047 1
a1047 1
				case ord(':'):
d1053 1
a1053 1
				case ord('~'):
d1136 1
a1136 1
	if (stype == ord('%') && c == '\0')
d1144 2
a1145 2
		if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ord('*') ||
		    ord(p[1]) == ord('@@')) && ord(p[2]) == ord(']')) {
d1148 1
a1148 1
			if (stype != ord('#'))
d1157 3
a1159 2
		} else if (c == ord('*') || c == ord('@@')) {
			if (stype != ord('#'))
d1165 1
a1165 1
			if (stype == ord('#'))
d1200 1
a1200 1
	if (stype == ord('!') && c != '\0' && *word == CSUBST) {
d1202 3
a1204 3
		if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ord('*') ||
		    ord(p[1]) == ord('@@')) && ord(p[2]) == ord(']')) {
			c = ord('!');
d1218 1
a1218 1
	if (c == ord(':')) {
d1223 1
a1223 1
	if (!stype && c == ord('/')) {
d1231 3
a1233 2
	} else if (stype == STYPE_DBL && (c == ord(' ') || c == ord('0'))) {
		stype |= ord('0');
d1246 1
a1246 1
	} else if (c == ord('@@')) {
d1250 3
a1252 3
		case ord('#'):
		case ord('/'):
		case ord('Q'):
d1266 1
a1266 1
	if (c == ord('*') || c == ord('@@')) {
d1269 1
a1269 1
		case ord('='):
d1271 8
a1278 8
		case ord('%'):
		case ord('#'):
		case ord('?'):
		case ord('0'):
		case ord('/') | STYPE_AT:
		case ord('/'):
		case ord('#') | STYPE_AT:
		case ord('Q') | STYPE_AT:
d1284 1
a1284 1
			state = c == ord('@@') ? XNULLSUB : XSUB;
d1289 1
a1289 1
			xp->split = tobool(c == ord('@@'));
d1294 2
a1295 2
	} else if ((p = cstrchr(sp, '[')) && (ord(p[1]) == ord('*') ||
	    ord(p[1]) == ord('@@')) && ord(p[2]) == ord(']')) {
d1300 1
a1300 1
		case ord('='):
d1302 8
a1309 8
		case ord('%'):
		case ord('#'):
		case ord('?'):
		case ord('0'):
		case ord('/') | STYPE_AT:
		case ord('/'):
		case ord('#') | STYPE_AT:
		case ord('Q') | STYPE_AT:
d1319 2
a1320 2
			XPput(wv, c == ord('!') ? shf_smprintf(Tf_lu,
			    arrayindex(vp)) :
d1325 1
a1325 1
			state = ord(p[1]) == ord('@@') ? XNULLSUB : XSUB;
d1332 1
a1332 1
			xp->split = tobool(ord(p[1]) == ord('@@'));
d1339 2
a1340 2
		if ((stype & STYPE_SINGLE) == ord('=') && !*xp->str &&
		    ctype(*sp, C_VAR1 | C_DIGIT))
d1351 5
a1355 3
	    ctype(c, C_EQUAL | C_MINUS | C_QUEST) : c == ord('+')))) ||
	    stype == (ord('0') | STYPE_DBL) || stype == (ord('#') | STYPE_AT) ||
	    stype == (ord('Q') | STYPE_AT) || (stype & STYPE_CHAR) == ord('/'))
d1359 1
a1359 1
	    (ctype(c, C_SUB2) || (state != XBASE && c != ord('+'))))
d1498 1
a1498 1
	case ord('#'):
d1510 1
a1510 1
	case ord('#') | STYPE_DBL:
d1522 1
a1522 1
	case ord('%'):
d1538 1
a1538 1
	case ord('%') | STYPE_DBL:
d1870 1
a1870 1
	while ((p = strchr(p, MAGIC)) && ord(p[1]) != ord('{' /*}*/))
d1881 1
a1881 1
				if (ord(*p) == ord('{' /*}*/))
d1883 1
a1883 1
				else if (ord(*p) == ord(/*{*/ '}'))
d1915 1
a1915 1
			if (ord(*++p) == ord('{' /*}*/))
d1917 1
a1917 1
			else if ((ord(*p) == ord(/*{*/ '}') && --count == 0) ||
@


1.214
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.211 2017/05/03 15:33:16 tg Exp $");
d640 1
a640 1
							*dp++ = 0x80 | '@@';
@


1.213
log
@switch EBCDIC to “nega-UTF8”
@
text
@d286 1
a286 1
			c = *sp++;
d292 1
a292 1
				c = *sp++;
d297 1
a297 1
				c = *sp++;
d323 1
a323 1
						c = ')';
d330 1
a330 1
						c = '}';
d337 1
a337 1
					if (c == '}')
d459 1
a459 1
						if (ord(mid[-1]) == ord(/*{*/'}')) {
d465 1
a465 1
							if (ord(end[-1]) != ord(/*{*/'}'))
d509 1
a509 1
						if (ord(p[-1]) == ord(/*{*/'}'))
d1005 5
a1009 5
				switch (c) {
				case '[':
				case '!':
				case '-':
				case ']':
d1017 1
a1017 1
						if (c == '[')
d1022 2
a1023 2
				case '*':
				case '?':
d1029 5
a1033 4
				case '{':
				case '}':
				case ',':
					if ((f & DOBRACE) && (c == '{' /*}*/ ||
d1039 1
a1039 1
				case '=':
d1047 1
a1047 1
				case ':':
d1053 1
a1053 1
				case '~':
d1866 1
a1866 1
	while ((p = strchr(p, MAGIC)) && p[1] != '{' /*}*/)
d1877 1
a1877 1
				if (*p == '{' /*}*/)
d1879 1
a1879 1
				else if (*p == /*{*/ '}')
d1911 1
a1911 1
			if (*++p == '{' /*}*/)
d1913 1
a1913 1
			else if ((*p == /*{*/ '}' && --count == 0) ||
@


1.212
log
@move the constants to an EBCDIC-friendly range
@
text
@d1177 1
a1177 1
						wc = (unsigned char)(*s++);
d1525 1
a1525 1
				while ((p-- > str) && ((*p & 0xC0) == 0x80))
@


1.211
log
@move magic constants into definitions
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.196 2017/02/17 21:15:55 tg Exp $");
d68 5
a72 5
#define STYPE_CHAR	0x7F
#define STYPE_DBL	0x80
#define STYPE_AT	0x100
#define STYPE_SINGLE	0x17F
#define STYPE_MASK	0x180
@


1.210
log
@sprinkle a few ord() and add an indicator of why some code fails on EBCDIC
@
text
@d68 6
d438 2
a439 2
					switch (stype & 0x17F) {
					case 0x100 | '#':
d443 1
a443 1
					case 0x100 | 'Q': {
d451 1
a451 1
					case '0': {
d459 1
a459 1
						if (mid[-1] == /*{*/'}') {
d465 1
a465 1
							if (end[-1] != /*{*/ '}')
d498 2
a499 2
					case 0x100 | '/':
					case '/': {
d509 1
a509 1
						if (p[-1] == /*{*/'}')
d514 1
a514 1
						if (!(stype & 0x180) &&
d520 1
a520 1
						if (!(stype & 0x100)) {
d540 1
a540 1
						if ((stype & 0x180) &&
d546 1
a546 1
							stype &= ~0x180;
d550 1
a550 1
						if (fpat == '#') {
d554 1
a554 1
						} else if (fpat == '%') {
d572 1
a572 1
						if (fpat != '#')
d581 1
a581 1
						if (fpat != '%')
d596 1
a596 1
						if (stype & 0x100) {
d609 1
a609 1
						if (stype & 0x100) {
d613 1
a613 1
						} else if (stype & 0x80)
d625 2
a626 2
					case '#':
					case '%':
d643 1
a643 1
					case '=':
d667 1
a667 1
					case '?':
d701 3
a703 3
				switch (st->stype & 0x17F) {
				case '#':
				case '%':
d733 1
a733 1
				case '=':
d766 1
a766 1
				case '?':
d772 5
a776 5
				case '0':
				case 0x100 | '/':
				case '/':
				case 0x100 | '#':
				case 0x100 | 'Q':
d1218 1
a1218 1
		stype = 0x80;
d1227 1
a1227 1
			stype |= 0x80;
d1229 2
a1230 2
	} else if (stype == 0x80 && (c == ord(' ') || c == ord('0'))) {
		stype |= ord('0');	/*XXX EBCDIC */
d1240 1
a1240 1
			stype |= 0x80;
d1254 1
a1254 1
		stype |= 0x100 | c;
d1264 1
a1264 1
		switch (stype & 0x17F) {
d1272 1
a1272 1
		case 0x100 | ord('/'):
d1274 2
a1275 2
		case 0x100 | ord('#'):
		case 0x100 | ord('Q'):
d1295 1
a1295 1
		switch (stype & 0x17F) {
d1303 1
a1303 1
		case 0x100 | ord('/'):
d1305 2
a1306 2
		case 0x100 | ord('#'):
		case 0x100 | ord('Q'):
d1336 1
a1336 1
		if ((stype & 0x17F) == ord('=') && !*xp->str &&
d1342 1
a1342 1
	c = stype & 0x7F;
d1344 2
a1345 2
	if (((stype < 0x100) && (ctype(c, C_SUB2) ||
	    (((stype & 0x80) ? *xp->str == '\0' : xp->str == null) &&
d1349 2
a1350 2
	    stype == (0x80 | ord('0')) || stype == (0x100 | ord('#')) ||
	    stype == (0x100 | ord('Q')) || (stype & 0x7F) == ord('/'))
d1492 2
a1493 2
	switch (how & 0xFF) {
	case '#':
d1505 1
a1505 1
	case '#'|0x80:
d1517 1
a1517 1
	case '%':
d1533 1
a1533 1
	case '%'|0x80:
@


1.209
log
@use strnul(); optimise
@
text
@d1118 1
a1118 1
	if ((stype = sp[0]) == '\0')
d1128 2
a1129 2
	c = sp[1];
	if (stype == '%' && c == '\0')
d1137 2
a1138 2
		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
		    p[2] == ']') {
d1141 1
a1141 1
			if (stype != '#')
d1150 2
a1151 2
		} else if (c == '*' || c == '@@') {
			if (stype != '#')
d1157 1
a1157 1
			if (stype == '#')
d1192 1
a1192 1
	if (stype == '!' && c != '\0' && *word == CSUBST) {
d1194 3
a1196 3
		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
		    p[2] == ']') {
			c = '!';
d1209 2
a1210 2
	c = word[slen + 0] == CHAR ? word[slen + 1] : 0;
	if (c == ':') {
d1213 1
a1213 1
		c = word[slen + 0] == CHAR ? word[slen + 1] : 0;
d1215 1
a1215 1
	if (!stype && c == '/') {
d1218 2
a1219 1
		if (word[slen] == ADELIM && word[slen + 1] == c) {
d1223 2
a1224 2
	} else if (stype == 0x80 && (c == ' ' || c == '0')) {
		stype |= '0';
d1232 2
a1233 1
		if (word[slen + 0] == CHAR && c == word[slen + 1]) {
d1237 1
a1237 1
	} else if (c == '@@') {
d1239 5
a1243 4
		switch (c = word[slen + 2] == CHAR ? word[slen + 3] : 0) {
		case '#':
		case '/':
		case 'Q':
d1256 2
a1257 2
	c = sp[0];
	if (c == '*' || c == '@@') {
d1260 1
a1260 1
		case '=':
d1262 8
a1269 8
		case '%':
		case '#':
		case '?':
		case '0':
		case 0x100 | '/':
		case '/':
		case 0x100 | '#':
		case 0x100 | 'Q':
d1275 1
a1275 1
			state = c == '@@' ? XNULLSUB : XSUB;
d1280 1
a1280 1
			xp->split = tobool(c == '@@');
d1285 2
a1286 2
	} else if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
	    p[2] == ']') {
d1291 1
a1291 1
		case '=':
d1293 8
a1300 8
		case '%':
		case '#':
		case '?':
		case '0':
		case 0x100 | '/':
		case '/':
		case 0x100 | '#':
		case 0x100 | 'Q':
d1310 1
a1310 1
			XPput(wv, c == '!' ? shf_smprintf(Tf_lu,
d1316 1
a1316 1
			state = p[1] == '@@' ? XNULLSUB : XSUB;
d1323 1
a1323 1
			xp->split = tobool(p[1] == '@@');
d1330 1
a1330 1
		if ((stype & 0x17F) == '=' && !*xp->str &&
d1342 3
a1344 3
	    ctype(c, C_EQUAL | C_MINUS | C_QUEST) : c == '+'))) ||
	    stype == (0x80 | '0') || stype == (0x100 | '#') ||
	    stype == (0x100 | 'Q') || (stype & 0x7F) == '/')
d1348 1
a1348 1
	    (ctype(c, C_SUB2) || (state != XBASE && c != '+')))
@


1.208
log
@reimplement has_globbing() with proper bracket expression parsing,
and take ahead parsing collating symbols, equivalence classes and
character classes already (heck my first draft of this already did
better than GNU bash, ksh93 I still don’t grok its code at all)
@
text
@d1408 1
a1408 1
				name += strlen(name);
d1658 1
a1658 1
		se = sp + strlen(sp);
d1672 1
a1672 1
		xp += strlen(xp);
d1701 2
a1702 3
			globit(xs, xpp, np, wp,
				(check & GF_MARKDIR) | GF_GLOBBED
				| (np ? GF_EXCHECK : GF_NONE));
@


1.207
log
@commit the optimisation result from the new fast character classes
@
text
@d1669 1
a1669 1
	if (!has_globbing(sp, se)) {
@


1.206
log
@fixup the remaining issues and last optimisations
@
text
@d510 1
a510 1
						    (s[1] == '#' || s[1] == '%'))
d894 1
a894 4
#ifdef MKSH_WITH_TEXTMODE
				       c == '\r' ||
#endif
				       c == '\n') {
d1131 1
a1131 1
	if ((stype == '#' || stype == '%') && c != '\0') {
d1339 1
a1339 1
	    c == '=' || c == '-' || c == '?' : c == '+'))) ||
d1728 1
a1728 1
			    !ctype(*s & 0x7F, C_PATMO))
@


1.205
log
@eliminate legacy macros
@
text
@d1731 1
a1731 1
			    !vstrchr("*+?@@! ", *s & 0x7f))
@


1.204
log
@convert to the new fast character classes
@
text
@d1230 1
a1230 1
	} else if (ksh_issubop2(c)) {
d1338 1
a1338 1
	if (((stype < 0x100) && (ksh_issubop2(c) ||
d1348 1
a1348 1
	    (ksh_issubop2(c) || (state != XBASE && c != '+')))
@


1.203
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.202 2017/04/21 20:06:04 tg Exp $");
d1227 1
a1227 1
	} else if (ctype(c, C_SUBOP1)) {
@


1.202
log
@now actually do comparisons for sorting ASCIIbetically
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.196 2017/02/17 21:15:55 tg Exp $");
d848 1
a848 1
				c = ifs0;
@


1.201
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d1558 1
a1558 1
		    sizeof(void *), xstrcmp);
@


1.200
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d304 1
d306 1
d313 14
a326 3
					*dp++ = c == COMSUB ? '(' : '{';
					if (c != COMSUB)
						*dp++ = c == FUNSUB ? ' ' : '|';
d331 1
a331 1
					if (c != COMSUB) {
d333 1
a333 3
						*dp++ = '}';
					} else
						*dp++ = ')';
d1359 1
a1359 1
comsub(Expand *xp, const char *cp, int fn MKSH_A_UNUSED)
d1364 1
d1367 10
d1380 1
a1380 1
	t = compile(s, true);
@


1.199
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d882 20
a901 1
				while ((c = shf_getc(x.u.shf)) == 0 || c == '\n')
d905 1
@


1.198
log
@fixup tilde expansion comments; revert a few bogus dirsep changes

cf. <Pine.BSM.4.64L.1703112129500.29506@@herc.mirbsd.org>
@
text
@d1199 1
a1199 1
	} else if (ctype(c, C_SUBOP2)) {
d1307 1
a1307 1
	if (((stype < 0x100) && (ctype(c, C_SUBOP2) ||
d1317 1
a1317 1
	    (ctype(c, C_SUBOP2) || (state != XBASE && c != '+')))
@


1.197
log
@in ${foo=bar}, “bar” must be scalar context; spotted by Martijn Dekker
@
text
@d628 6
a633 7
						 * Enabling tilde expansion
						 * after :s here is
						 * non-standard ksh, but is
						 * consistent with rules for
						 * other assignments. Not
						 * sure what POSIX thinks of
						 * this.
d1719 1
a1719 1
	while (p[0] == CHAR && !mksh_cdirsep(p[1]) &&
@


1.196
log
@oops…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.179 2016/01/14 22:30:43 tg Exp $");
d643 1
a643 1
						f |= DOTEMP;
@


1.195
log
@make ${var@@x} with unknown x fail; spotted by izabera, thanks
@
text
@a1219 4
		if (word[slen] == CHAR) {
			stype |= word[slen + 1];
			slen += 2;
		}
@


1.194
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d1210 10
a1219 2
		slen += 2;
		stype |= 0x100;
@


1.193
log
@fix English (thanks to Andreas Buschka); TIL:
• to start ⇒ a start
• to begin ⇒ a beginning
@
text
@d1579 1
a1579 1
			    xp[-1] == '/' && !S_ISDIR(lstatb.st_mode) &&
d1589 1
a1589 1
			    xp > Xstring(*xs, xp) && xp[-1] != '/' &&
d1604 1
a1604 1
	while (*sp == '/') {
d1608 1
a1608 1
	np = strchr(sp, '/');
d1716 2
a1717 2
	while (p[0] == CHAR && p[1] != '/' && (!isassign || p[1] != ':'))
	{
@


1.192
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtc’s programmable tab completion)
to the manpage
@
text
@d65 1
a65 1
#define IFS_IWS		3	/* begin of word, ignore IFS WS */
d201 1
a201 1
	size_t	base;		/* begin position of expanded word */
@


1.191
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d189 1
a189 1
		rv = evalstr(cp, f&~DOGLOB);
d481 1
d484 1
a484 1
						char *pat, *rrep;
d486 1
d488 1
a488 1
						s = wdcopy(sp, ATEMP);
d497 1
a497 1
						if (!(stype & 0x80) &&
d501 13
a513 1
						pat = evalstr(s + (fpat ? 2 : 0),
a514 4
						rrep = d ? evalstr(p,
						    DOTILDE | DOSCALAR) : null;
						afree(s, ATEMP);

d523 1
a523 1
						if ((stype & 0x80) &&
d529 1
a529 1
							stype &= ~0x80;
a531 4
						/* prepare string on which to work */
						strdupx(s, str_val(st->var), ATEMP);
						sbeg = s;

d576 10
d592 5
a596 1
						if (stype & 0x80)
d605 1
d757 1
d1232 1
d1263 1
d1304 1
a1304 1
	if (((stype < 0x100) && (ctype(c, C_SUBOP2) || c == '/' ||
d1310 1
a1310 1
	    stype == (0x100 | 'Q'))
d1447 1
d1459 1
d1487 1
@


1.190
log
@fix issues with home directory replacement, from Torsten Sillke:
• if $PWD = ${HOME}foo, no longer show as ~foo in PS1
• simplify ~, ~+, and ~- exactly as $PWD is upon shell entry
  (fixes HOME=/home/./foo but PWD=/home/foo)
@
text
@d384 1
a384 1
					str = snptreef(NULL, 64, "%S", beg);
d386 1
a386 1
					errorf("%s: %s", str, Tbadsubst);
d571 1
a571 1
						d = shf_smprintf("%s%s%s", end, rrep, p);
d732 1
a732 1
					errorf("%s: %s", st->var->name,
d1137 1
a1137 1
			errorf("%s: parameter not set", sp);
d1140 1
a1140 1
		xp->str = shf_smprintf("%d", c);
d1252 1
a1252 1
			XPput(wv, c == '!' ? shf_smprintf("%lu",
d1291 1
a1291 1
		errorf("%s: parameter not set", sp);
d1334 2
a1335 2
				warningf(!Flag(FTALKING), "%s: %s %s: %s",
				    name, "can't open", "$(<...) input",
d1351 2
a1352 2
			errorf("%s: %s", T_funny_command,
			    snptreef(NULL, 32, "%R", io));
d1364 2
a1365 2
			errorf("can't %s temporary file %s: %s",
			    "create", tf->tffn, cstrerror(errno));
d1615 1
a1615 1
		dirp = opendir(prefix_len ? Xstring(*xs, xp) : ".");
d1728 1
a1728 1
		dp = str_val(global("PWD"));
d1730 1
a1730 1
		dp = str_val(global("OLDPWD"));
@


1.189
log
@efficient $(<<<foo) and $(<<EOF … ) implementation, requested by izabera
@
text
@a1716 1

d1721 3
d1732 1
a1732 1
	else
d1734 2
d1737 14
a1750 2
	/* If HOME, PWD or OLDPWD are not set, don't expand ~ */
	return (dp == null ? NULL : dp);
@


1.188
log
@fix most of the ambiguous ${[prefix] var [op [word]]} corner cases

prodded by izabera and carstenh; resolution is:
• you can’t trim a vector in mksh, still (consider ${@@:-1})
• future POSIX will require non-empty “word” for most “op”s
• dissolve in order of standard → extension
• dissolve to prefer “op” over “prefix” where still necessary, mostly
@
text
@d1329 22
a1350 1
		if ((io->ioflag & IOTYPE) != IOREAD)
d1353 1
a1353 5
		shf = shf_open(name = evalstr(io->ioname, DOTILDE), O_RDONLY,
			0, SHF_MAPHI | SHF_CLEXEC);
		if (shf == NULL)
			warningf(!Flag(FTALKING), "%s: %s %s: %s", name,
			    "can't open", "$(<...) input", cstrerror(errno));
@


1.187
log
@give C_VAR1 precedence over display variable name; izabera pointed out,
rightfully, that, in POSIX shell, ${!#} is defined, and ${!#123} should work
@
text
@d1064 1
a1064 1
	int slen;
d1143 14
d1160 1
a1160 1
	c = word[slen = 0] == CHAR ? word[1] : 0;
a1198 2
	*stypep = stype;
	*slenp = slen;
d1245 2
a1247 2
		if ((c = sp[0]) == '!')
			++sp;
d1269 4
a1272 2
		/* Can't assign things like $! or $1 */
		if ((stype & 0x17F) == '=' &&
a1274 13
		if (*sp == '!' && sp[1] && !ctype(sp[1], C_VAR1)) {
			++sp;
			xp->var = global(sp);
			if (vstrchr(sp, '['))
				xp->str = shf_smprintf("%s[%lu]",
				    xp->var->name,
				    arrayindex(xp->var));
			else
				xp->str = xp->var->name;
		} else {
			xp->var = global(sp);
			xp->str = str_val(xp->var);
		}
d1292 2
@


1.186
log
@collapse uselessly nested if
@
text
@d1261 1
a1261 1
		if (*sp == '!' && sp[1]) {
@


1.185
log
@fix trimming with ? on $* and $@@; missed by Todd Miller in r2.2 in ncvs
where it was fixed for ${foo[@@]} and ${foo[*]}
@
text
@d1216 40
d1257 13
a1269 40
		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
		    p[2] == ']') {
			XPtrV wv;

			switch (stype & 0x17F) {
			/* can't assign to a vector */
			case '=':
			/* can't trim a vector (yet) */
			case '%':
			case '#':
			case '?':
			case '0':
			case '/':
			case 0x100 | '#':
			case 0x100 | 'Q':
				return (-1);
			}
			XPinit(wv, 32);
			if ((c = sp[0]) == '!')
				++sp;
			vp = global(arrayname(sp));
			for (; vp; vp = vp->u.array) {
				if (!(vp->flag&ISSET))
					continue;
				XPput(wv, c == '!' ? shf_smprintf("%lu",
				    arrayindex(vp)) :
				    str_val(vp));
			}
			if (XPsize(wv) == 0) {
				xp->str = null;
				state = p[1] == '@@' ? XNULLSUB : XSUB;
				XPfree(wv);
			} else {
				XPput(wv, 0);
				xp->u.strv = (const char **)XPptrv(wv);
				xp->str = *xp->u.strv++;
				/* ${foo[@@]} */
				xp->split = tobool(p[1] == '@@');
				state = XARG;
			}
d1271 2
a1272 18
			/* Can't assign things like $! or $1 */
			if ((stype & 0x17F) == '=' &&
			    ctype(*sp, C_VAR1 | C_DIGIT))
				return (-1);
			if (*sp == '!' && sp[1]) {
				++sp;
				xp->var = global(sp);
				if (vstrchr(sp, '['))
					xp->str = shf_smprintf("%s[%lu]",
					    xp->var->name,
					    arrayindex(xp->var));
				else
					xp->str = xp->var->name;
			} else {
				xp->var = global(sp);
				xp->str = str_val(xp->var);
			}
			state = XSUB;
d1274 1
@


1.184
log
@plug a few display problems with special parameter name expansions
reported by Stéphane Chazelas
@
text
@d1196 1
@


1.183
log
@fix substitution error message
@
text
@d407 2
a408 2
					if (x.var == &vtemp) {
						st->var = tempvar();
@


1.182
log
@ADELIM can be ‘}’ too, not just ‘/’, in code that checks for / vs. //
caught by new code after segfault report by bef0rd on IRC (thanks!)
@
text
@d378 3
a380 2
					end = (beg = wdcopy(sp, ATEMP)) +
					    (wdscan(sp, CSUBST) - sp);
@


1.181
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d1154 1
a1154 1
		if (word[slen] == ADELIM) {
@


1.180
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVAR→CMDASN
@
text
@d123 1
a123 1
		internal_errorf("bad substitution");
d385 1
a385 1
					errorf("%s: %s", str, "bad substitution");
d1136 1
a1136 1
			errorf("%s: %s", sp, "parameter not set");
d1290 1
a1290 1
		errorf("%s: %s", sp, "parameter not set");
@


1.179
log
@correctly handle nested ADELIM parsing: ADELIM doubles as CSUBST (LP#1453827)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.166 2015/02/20 07:14:29 tg Exp $");
d1327 1
a1327 1
			errorf("%s: %s", "funny $() command",
@


1.178
log
@further bring ${x/y/z} closer to GNU bash behaviour, we now only miss
recursive extglobs
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
a439 2
						if (mid >= stg)
							goto unwind_substsyn;
d447 2
a448 3
							if (end >= stg ||
							    /* more than max delimiters */
							    end[-1] != /*{*/ '}')
a487 2
						if (p >= d)
							goto unwind_substsyn;
@


1.177
log
@fix ${*:+x} constructs; bug reported by carstenh via IRC
@
text
@d486 1
a486 1
						char *tpat0, *tpat1, *tpat2;
d499 8
a506 2
						pat = evalstr(s, DOTILDE | DOPAT);
						rrep = d ? evalstr(p, DOTILDE) : null;
d510 5
a514 7
						switch (*pat) {
						case '#':
						case '%':
							tpat0 = pat + 1;
							break;
						case '\0':
							/* empty pattern, reject */
a515 2
						default:
							tpat0 = pat;
d517 2
a518 1
						if (gmatchx(null, tpat0, false)) {
d531 1
a531 2
						tpat0 = pat;
						if (*pat == '#') {
d533 1
a533 1
							tpat1 = shf_smprintf("%s%c*", ++tpat0, MAGIC);
d535 1
a535 1
						} else if (*pat == '%') {
d537 2
a538 2
							tpat1 = shf_smprintf("%c*%s", MAGIC, ++tpat0);
							tpat2 = tpat0;
d553 1
a553 1
						if (*pat != '#')
d562 1
a562 1
						if (*pat != '%')
d568 1
a568 1
								gotmatch = tobool(gmatchx(sbeg, tpat0, false));
@


1.176
log
@use evalstr instead of wdstrip+substitute and drop home-grown backslash removal
@
text
@d1044 11
d1283 3
a1285 1
	    (((stype & 0x80) ? *xp->str == '\0' : xp->str == null) ?
@


1.175
log
@fix a few expansion substitutions to do tilde expansion
issue spotted by izabera and confirmed by Geoff Clare
@
text
@d499 2
a500 10
						tpat0 = wdstrip(s,
						    WDS_KEEPQ | WDS_MAGIC);
						pat = substitute(tpat0, DOTILDE);
						if (d) {
							d = wdstrip(p, WDS_KEEPQ);
							rrep = substitute(d,
							    DOTILDE);
							afree(d, ATEMP);
						} else
							rrep = null;
a501 13
						s = d = pat;
						while (*s)
							if (*s != '\\' ||
							    s[1] == '%' ||
							    s[1] == '#' ||
							    s[1] == '\0' ||
				/* XXX really? */	    s[1] == '\\' ||
							    s[1] == '/')
								*d++ = *s++;
							else
								s++;
						*d = '\0';
						afree(tpat0, ATEMP);
@


1.174
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@d501 1
a501 1
						pat = substitute(tpat0, 0);
d504 2
a505 1
							rrep = substitute(d, 0);
d612 1
a612 1
						/* ! DOBLANK,DOBRACE,DOTILDE */
d614 3
a616 1
						    DOPAT | DOTEMP | DOSCALAR;
@


1.173
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d1337 2
a1338 2
		shf = shf_open(name = evalstr(io->name, DOTILDE), O_RDONLY, 0,
			SHF_MAPHI|SHF_CLEXEC);
@


1.172
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
d651 3
d749 2
a750 2
				case '?': {
					char *s = Xrestpos(ds, dp, st->base);
d753 2
a754 4
					    dp == s ?
					    "parameter null or not set" :
					    (debunk(s, s, strlen(s) + 1), s));
				    }
d1005 2
a1006 3
					if (!(f & DOTEMP) && !saw_eq &&
					    (Flag(FBRACEEXPAND) ||
					    (f & DOASNTILDE))) {
d1290 1
a1290 1
	    (((stype&0x80) ? *xp->str=='\0' : xp->str==null) ? /* undef? */
@


1.171
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d922 2
@


1.170
log
@do the IFS_QUOTE dance right; this finally fixes ""$@@
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.169
log
@The check for empty patterns and patterns matching the empty string
in commitid 1004D8283F068C41C3C was bogus; it fixed Jb_boin’s issue
but izabers’s 「var=foo; echo "${var/*/x}"」 was broken; in fact we
only want to not do the looping for // if the pattern matches much.

Also, fix a spelling mistake in the manpage and change some wording
to also work with associative arrays (in the future; no change).
@
text
@d294 1
a294 8
				switch (word) {
				case IFS_QUOTE:
					/* """something */
					word = IFS_WORD;
					break;
				case IFS_WORD:
					break;
				default:
a295 2
					break;
				}
d300 2
@


1.168
log
@use already-existing ksh_isdash helper macro
@
text
@a530 1
						d = str_val(st->var);
a532 5
							/* anchor at begin */
							tpat0 = pat + 1;
							tpat1 = rrep;
							tpat2 = d;
							break;
a533 1
							/* anchor at end */
a534 2
							tpat1 = d;
							tpat2 = rrep;
d537 1
a537 1
							/* empty pattern */
a540 2
							/* silence gcc */
							tpat1 = tpat2 = NULL;
d544 2
a545 2
							 * pattern matches
							 * the empty string
d547 1
a547 6
							if (tpat0 == pat)
								goto no_repl;
							/* but is anchored */
							s = shf_smprintf("%s%s",
							    tpat1, tpat2);
							goto do_repl;
d551 1
a551 1
						strdupx(s, d, ATEMP);
a608 1
 do_repl:
@


1.167
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d1737 1
a1737 1
	else if (cp[0] == '-' && cp[1] == '\0')
@


1.166
log
@can't set word=IFS_QUOTE if already IFS_WORD (something there)
or IFS_QUOTE (third dquote (second OQUOTE) in """something)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.162 2015/02/06 09:33:41 tg Exp $");
d1356 1
a1356 1
		if ((io->flag & IOTYPE) != IOREAD)
@


1.165
log
@• fixup here document expansion (regression wrt. pdksh 5.2.14)
• adjust testsuite (and write tons of new tests) after today’s commits
@
text
@d294 11
a304 1
				word = IFS_QUOTE;
@


1.164
log
@unbreak other cases where $@@ shares double quotes with something else
@
text
@d850 6
d862 1
a862 1
					if (c == 0) {
a863 1
					}
@


1.163
log
@stop (ab)using the OS symbolic constant EOF, always use -1; plus misc fixes
@
text
@d62 1
a62 1
#define IFS_WORD	0	/* word has chars (or quotes) */
d66 1
d294 1
a294 1
				word = IFS_WORD;
d387 2
d715 8
a722 2
					} else
						type = quote ? XSUB : XNULLSUB;
d815 1
a815 1
				if (dp == Xstring(ds, dp))
d927 1
a927 1
			if ((word == IFS_WORD) || (c &&
@


1.162
log
@rewrite the code a bit to avoid GCC -Wstrict-overflow triggering in one case…
most of it is utterly useless though as the line indicated is usually the
closing curly brace of a function, often not even the reported one…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.161 2014/12/05 15:14:23 tg Exp $");
d874 1
a874 1
				c = EOF;
d884 1
a884 1
				if (newlines && c != EOF) {
d890 1
a890 1
			if (c == EOF) {
@


1.161
log
@int → bool
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.160 2014/11/25 21:13:23 tg Exp $");
d1752 1
a1752 1
	int count = 0;
d1755 1
a1755 1
	char *p;
d1758 2
a1759 2
	for (p = exp_start; (p = strchr(p, MAGIC)) && p[1] != '{' /*}*/; p += 2)
		;
d1766 5
a1770 4
		for (p += 2; *p && count; p++) {
			if (ISMAGIC(*p)) {
				if (*++p == '{' /*}*/)
					count++;
d1775 1
d1804 1
a1804 1
				count++;
@


1.160
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.159 2014/11/19 21:49:12 tg Exp $");
d73 1
a73 1
static const char *maybe_expand_tilde(const char *, XString *, char **, int);
d1030 1
a1030 1
						    f & DOASNTILDE);
d1666 1
a1666 1
maybe_expand_tilde(const char *p, XString *dsp, char **dpp, int isassign)
@


1.159
log
@rename the “tilde” function; apparently, some system headers define it
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158 2014/10/19 21:53:07 tg Exp $");
d240 1
a240 1
	int tilde_ok;
a518 1
						mkssert(d != NULL);
@


1.158
log
@first cut at LP#1381993 (probably incomplete) plus test coverage
also remove fbsd testsuite link, it’s gone during cvs→svn of theirs ☹
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.156 2014/10/19 21:04:47 tg Exp $");
d1684 1
a1684 1
	    tilde(Xstring(ts, tp)) : NULL;
d1706 1
a1706 1
tilde(char *cp)
@


1.158.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158 2014/10/19 21:53:07 tg Exp $");
d240 1
a240 1
	unsigned int tilde_ok;
@


1.158.2.2
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158.2.1 2015/01/11 22:39:47 tg Exp $");
d519 1
d1684 1
a1684 1
	    do_tilde(Xstring(ts, tp)) : NULL;
d1706 1
a1706 1
do_tilde(char *cp)
@


1.158.2.3
log
@MFC most of the rest: int → bool, MAXPATHLEN, comments/whitespace
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158.2.2 2015/01/25 15:35:43 tg Exp $");
d73 1
a73 1
static const char *maybe_expand_tilde(const char *, XString *, char **, bool);
d1030 1
a1030 1
						    tobool(f & DOASNTILDE));
d1666 1
a1666 1
maybe_expand_tilde(const char *p, XString *dsp, char **dpp, bool isassign)
@


1.158.2.4
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158.2.3 2015/01/25 15:44:04 tg Exp $");
d62 1
a62 1
#define IFS_WORD	0	/* word has chars (or quotes except "$@@") */
a65 1
#define IFS_QUOTE	4	/* beg.w/quote, become IFS_WORD unless "$@@" */
d293 1
a293 11
				switch (word) {
				case IFS_QUOTE:
					/* """something */
					word = IFS_WORD;
					break;
				case IFS_WORD:
					break;
				default:
					word = IFS_QUOTE;
					break;
				}
a385 2
				if (word == IFS_QUOTE && type != XNULLSUB)
					word = IFS_WORD;
d712 2
a713 8
					} else if (quote) {
						word = IFS_WORD;
						type = XSUB;
					} else {
						if (dp == Xstring(ds, dp))
							word = IFS_IWS;
						type = XNULLSUB;
					}
d806 1
a806 1
				if (dp == Xstring(ds, dp) && word != IFS_WORD)
a840 6
				if ((f & DOHEREDOC)) {
					/* pseudo-field-split reliably */
					if (c == 0)
						c = ' ';
					break;
				}
d847 1
a847 1
					if (c == 0)
d849 1
d874 1
a874 1
				c = -1;
d884 1
a884 1
				if (newlines && c != -1) {
d890 1
a890 1
			if (c == -1) {
d918 1
a918 1
			if ((word == IFS_WORD) || (word == IFS_QUOTE) || (c &&
d1752 1
a1752 1
	unsigned int count = 0;
d1755 1
a1755 1
	char *p = exp_start;
d1758 2
a1759 2
	while ((p = strchr(p, MAGIC)) && p[1] != '{' /*}*/)
		p += 2;
d1766 4
a1769 5
		p += 2;
		while (*p && count) {
			if (ISMAGIC(*p++)) {
				if (*p == '{' /*}*/)
					++count;
a1773 1
				++p;
d1802 1
a1802 1
				++count;
@


1.158.2.5
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.158.2.4 2015/03/01 15:42:58 tg Exp $");
d1356 1
a1356 1
		if ((io->ioflag & IOTYPE) != IOREAD)
@


1.157
log
@better fix
@
text
@d249 1
a249 1
		f |= DOASNTILDE | DOASNFIELD;
d625 1
a625 1
						    DOPAT | DOTEMP;
d750 1
a750 1
					word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_IWS;
d766 1
a766 1
					word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_IWS;
d842 2
a843 2
				if ((f & DOASNFIELD)) {
					/* assignment, do not field-split */
@


1.156
log
@IFS_IWS, but doesn’t really change much…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.155 2014/10/19 20:59:43 tg Exp $");
d667 5
a671 1
						word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_IWS;
d771 1
@


1.155
log
@erm yes, committed the wrong patch…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.154 2014/10/19 20:56:32 tg Exp $");
d707 1
a707 1
						word = IFS_WS;
d746 1
a746 1
					word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_WS;
d762 1
a762 1
					word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_WS;
d803 1
a803 1
					word = IFS_WS;
@


1.154
log
@commit patch from LP#1381965 and two testcases, one showing this is fixed,
another showing deeper problems (probably LP#1381993 “non-list contexts” or
the IFS_WS/IFS_IWS story, perhaps *all* IFS_WS (not just ternaries) really
should be IFS_IWS instead?)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.153 2014/10/07 15:22:16 tg Exp $");
d667 1
a667 1
						word = quote || (!*x.str && (f & DOASNFIELD)) ? IFS_WORD : IFS_WS;
@


1.153
log
@fix severe regression in field splitting (LP#1378208)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.152 2014/10/03 17:32:11 tg Exp $");
d634 1
a634 1
							*dp++ = '@@' | 0x80;
d667 1
a667 1
						word = quote ? IFS_WORD : IFS_IWS;
@


1.152
log
@overhaul IFS handling, fix bugs reported by Stephane Chazelas and mikeserv

now we’re at: 486 passed testsuite items, 0 failed
ifs.sh still: # tests 6856 passed 6856 failed 0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.151 2014/07/29 16:29:11 tg Exp $");
d65 1
d667 1
a667 1
						word = IFS_WORD;
d911 1
a912 2
			 * Note that IFS_NWS/0 generates a word (AT&T ksh
			 * doesn't do this, but POSIX does).
d914 3
a916 2
			if (word == IFS_WORD ||
			    (word == IFS_NWS && c && !ctype(c, C_IFSWS))) {
@


1.151
log
@make the comments match the actual code; bad jaredy@@obsd for failing us so
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.150 2014/06/09 11:16:07 tg Exp $");
d247 2
a248 2
		f &= ~(DOVACHECK|DOBLANK|DOGLOB|DOTILDE);
		f |= DOASNTILDE;
d264 1
a264 1
	tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0;
d425 1
a425 1
					}
d475 1
a475 1
					}
d619 1
a619 1
					}
d652 1
a652 1
							f |= DOASNTILDE|DOTILDE;
d666 1
d675 1
a675 1
			}
d745 1
d754 1
a754 1
				}
d761 1
a800 7
				/*
				 * XXX not really correct:
				 *	x=; "$x$@@"
				 * should generate a null argument and
				 *	set A; "${@@:+}"
				 * shouldn't.
				 */
d824 1
a824 1
				 * set -- '' 2 ''; foo "$@@" will do
d836 10
d849 2
d933 2
a934 1
				tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0;
d1018 1
a1018 1
					    (f & (DOTILDE|DOASNTILDE)) &&
@


1.150
log
@LANGUAGE CHANGE: $((…)) results are now IFS-split, as per POSIX 201x
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.148 2014/05/27 13:00:30 tg Exp $");
d900 2
a901 2
			 *	IFS_WS			-/WS	w/NWS	-
			 *	IFS_NWS			-/NWS	w/NWS	w
d907 1
a907 1
			    (!ctype(c, C_IFSWS) && c && word == IFS_NWS)) {
@


1.149
log
@next attempt at fixing IFS-subst-2
@
text
@a326 1
				word = IFS_WORD;
d329 1
d346 4
a349 5
					cp = str_val(&v);
					while (*cp) {
						Xcheck(ds, dp);
						*dp++ = *cp++;
					}
d685 1
a685 1
				if (f&DOBLANK)
d709 1
a709 1
					if (f&DOBLANK)
d741 1
a741 1
					if (f&DOBLANK)
d759 1
a759 1
					if (f&DOBLANK)
d796 1
a796 1
			if (f&DOBLANK) {
d814 1
a814 1
				if (f&DOBLANK)
d835 1
a835 1
					if (f&DOBLANK)
d884 1
a884 1
				if (f&DOBLANK)
@


1.148
log
@fix ${!foo} for when foo is unset
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.147 2014/01/11 18:09:39 tg Exp $");
d705 2
a706 1
					if (quote || x.str[0] != '\0')
d708 2
a709 2
					else
						type = XNULLSUB;
d800 5
a804 3
				 * not really correct: x=; "$x$@@" should
				 * generate a null argument and
				 * set A; "${@@:+}" shouldn't.
@


1.147
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.146 2014/01/05 21:57:25 tg Exp $");
d1255 5
a1259 7
				if (vstrchr(sp, '[')) {
					if (xp->var->flag & ISSET)
						xp->str = shf_smprintf("%lu",
						    arrayindex(xp->var));
					else
						xp->str = null;
				} else if (xp->var->flag & ISSET)
a1260 3
				else
					/* ksh93 compat */
					xp->str = "0";
@


1.146
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.145 2013/11/30 00:20:47 tg Exp $");
d415 1
a415 17
					case 0x100 | '#': {
						char *beg, *end;
						mksh_ari_t seed;
						register uint32_t h;

						beg = wdcopy(sp, ATEMP);
						end = beg + (wdscan(sp, CSUBST) - sp);
						end[-2] = EOS;
						end = wdstrip(beg, 0);
						afree(beg, ATEMP);
						evaluate(substitute(end, 0),
						    &seed, KSH_UNWIND_ERROR, true);
						/* hash with seed, for now */
						h = seed;
						NZATUpdateString(h,
						    str_val(st->var));
						NZAATFinish(h);
d417 1
a417 1
						    (unsigned int)h);
a418 1
					}
@


1.145
log
@revert commit 1005289433447F6CA90 as it makes the system unbootable
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.144 2013/11/17 22:28:51 tg Exp $");
d77 1
a77 1
static int utflen(const char *);
@


1.144
log
@fix initial IFSWS not ignored when expanding, noticed by Seb <sbb@@tuxfamily.org>
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.142 2013/07/24 18:03:57 tg Exp $");
a721 1
					word = quote ? IFS_WORD : IFS_WS;
@


1.143
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (‘;’), oksh rcsid sync (they did
accept I was right wrt. set -e), int → bool, and code merge/cleanup
@
text
@d722 2
a723 1
					if (x.str[0] != '\0' || st->quotep)
@


1.142
log
@fix another clobbered-by-setjmp/longjmp warning
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.39 2013/07/01 17:25:27 jca Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.140 2013/07/21 18:36:00 tg Exp $");
@


1.141
log
@Fix apparent programming mistake (newblock doesn’t imply newenv)
that caused “echo ${|true;}$(true)” to segfault; problem reported
by pshevtsov and wbx@@ in IRC (thanks!); fix sponsored by tarent
@
text
@d1839 1
a1839 1
	char *cp = NULL;
@


1.140
log
@partial merge and full RCS ID sync with oksh

merged:
• new regression tests
• check.pl (tests/th) better tmpfile handling
• exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
• ksh.1 1.147: document the above
• eval.c 1.39: “Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).”
  ‣ additionally make shf_open() return errno and actually show
    the error message from the system
• regression-39 test: remove the “maybe” marker
  ‣ but decide on correct POSIX behaviour

already been fixed in mksh:
• check.pl (tests/th) exit 1 if tests fail

not merged:
• main.c 1.52: run traps in unwind() before exiting;
  I’m pretty sure this is already working as-should in mksh
• eval.c 1.38: “Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status.” As discussed in IRC, this is
  just plainly WRONG.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.139 2013/05/02 21:59:49 tg Exp $");
a67 1
static void funsub(struct op *);
d1370 1
a1370 1
		funsub(t);
a1835 10
static void
funsub(struct op *t)
{
	newblock();
	e->type = E_FUNC;
	if (!kshsetjmp(e->jbuf))
		execute(t, XXCOM | XERROK, NULL);
	popblock();
}

d1839 2
a1840 2
	char *cp;
	struct tbl *vp;
d1842 1
d1844 2
a1845 2
	vp = local("REPLY", false);
	e->type = E_FUNC;
d1848 4
a1851 2
	strdupx(cp, str_val(vp), ap);
	popblock();
@


1.139
log
@implement VALSUBs
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.37 2011/10/11 14:32:43 otto Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.137 2013/02/23 20:03:30 tg Exp $");
d873 6
a878 1
			if (newlines) {
d895 2
a896 1
				shf_close(x.u.shf);
d1345 2
a1346 1
			errorf("%s: %s %s", name, "can't open", "$() input");
@


1.138
log
@now that funsub() is a separate function, and we don’t have the clobber
issue from longjmp any more, and that I thought to rewind the fd, finally
implement ${ …;} on deleted-after-open tempfiles without the need to reopen
@
text
@d69 1
d302 1
d307 3
a309 5
					if (c == FUNSUB) {
						*dp++ = '{';
						*dp++ = ' ';
					} else
						*dp++ = '(';
d314 1
a314 1
					if (c == FUNSUB) {
d321 1
a321 1
					if (type == XCOM && (f&DOBLANK))
d1369 4
d1839 16
@


1.137
log
@both mksh(1) and POSIX say: "$@@" should always generate multiple words
issue in pdksh reported in IRC by engla, thanks!
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.136 2013/02/10 23:43:59 tg Exp $");
d1344 4
a1347 1
		/* create a temporary file, open for writing */
d1353 5
a1357 1
		/* save stdout and make the temporary file it */
d1359 1
a1359 1
		ksh_dup2(shf_fileno(tf->shf), 1, false);
d1366 2
a1367 2
		/* close the tempfile and restore regular stdout */
		shf_close(tf->shf);
a1368 4
		/* now open, unlink and free the tempfile for reading */
		shf = shf_open(tf->tffn, O_RDONLY, 0, SHF_MAPHI | SHF_CLEXEC);
		unlink(tf->tffn);
		afree(tf, ATEMP);
@


1.136
log
@get rid of unneeded variables ⇒ error handling (that wasn’t there
previously) ⇒ code ⇒ simplify!
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.134 2013/02/10 21:42:15 tg Exp $");
d36 5
a40 3
typedef struct Expand {
	/* int type; */			/* see expand() */
	const char *str;		/* string */
d42 9
a50 5
		const char **strv;	/* string[] */
		struct shf *shf;	/* file */
	} u;				/* source */
	struct tbl *var;		/* variable in ${var..} */
	bool split;			/* split "$@@" / call waitlast $() */
d207 7
a213 3
expand(const char *cp,	/* input word */
    XPtrV *wp,		/* output words */
    int f)		/* DO* flags */
d216 16
a231 7
	int type;		/* expansion type */
	int quote = 0;		/* quoted */
	XString ds;		/* destination string */
	char *dp;		/* destination */
	const char *sp;		/* source */
	int fdo, word;		/* second pass flags; have word */
	int doblank;		/* field splitting of parameter/command subst */
a232 1
		/* expansion variables */
d236 1
a236 1
	/* For trailing newlines in COMSUB */
d241 1
d243 1
a243 1
	if (cp == NULL)
d246 1
a246 1
	if ((f & DOVACHECK) && is_wdvarassign(cp)) {
d260 1
a260 1
	sp = cp;
a338 1
					char *p;
d347 2
a348 1
					for (p = str_val(&v); *p; ) {
d350 1
a350 1
						*dp++ = *p++;
d416 1
a416 2
					case 0x100 | '#':
					    {
d437 1
a437 2
					case 0x100 | 'Q':
					    {
d859 1
d861 2
d874 1
a874 1
				/* Spit out saved NLs */
d880 1
a880 1
						/* Save newlines */
d918 1
a918 2
				char *p;

d920 1
a920 1
				p = Xclose(ds, dp);
d923 2
a924 2
					alt_expand(wp, p, p,
					    p + Xlength(ds, (dp - 1)),
d927 1
a927 1
					glob(p, wp, tobool(f & DOMARKDIRS));
d929 1
a929 1
					XPput(*wp, p);
d931 2
a932 1
					XPput(*wp, debunk(p, p, strlen(p) + 1));
d943 2
a944 4
				char *p;

				*(p = alloc(1, ATEMP)) = '\0';
				XPput(*wp, p);
d953 2
a954 4
					char *p;

					*(p = alloc(1, ATEMP)) = '\0';
					XPput(*wp, p);
d1021 2
a1022 2
						const char *p;
						char *dp_x;
d1024 2
a1025 3
						dp_x = dp;
						p = maybe_expand_tilde(sp,
						    &ds, &dp_x,
d1027 2
a1028 2
						if (p) {
							if (dp != dp_x)
d1030 2
a1031 2
							dp = dp_x;
							sp = p;
d1194 4
a1197 2
		case '=':	/* can't assign to a vector */
		case '%':	/* can't trim a vector (yet) */
d1224 4
a1227 2
			case '=':	/* can't assign to a vector */
			case '%':	/* can't trim a vector (yet) */
d1517 2
a1518 3
#define stat_check()	(stat_done ? stat_done : \
			    (stat_done = stat(Xstring(*xs, xp), &statb) < 0 \
				? -1 : 1))
d1520 2
a1521 1
			int stat_done = 0;	 /* -1: failed, 1 ok */
@


1.135
log
@provide a layer of locality to FUNSUBs; get rid of a fork for each PS1 thus
@
text
@d62 1
a62 1
static int funsub(struct op *, struct shf *, int);
d1322 1
a1322 1
		int ofd1, i;
d1336 1
a1336 1
		 * in new function block; close tempfile and end redir
d1338 1
a1338 1
		i = funsub(t, tf->shf, ofd1);
d1340 3
d1804 2
a1805 2
int
funsub(struct op *t, struct shf *shf, int ofd1)
a1806 2
	volatile int i;

d1809 1
a1809 1
	if (!(i = kshsetjmp(e->jbuf))) {
a1810 12
		i = LRETURN;
	}
	/* close the tempfile and restore regular stdout */
	shf_close(shf);
	restfd(1, ofd1);
	/* function block error handling */
	if (i != LRETURN /* && i != LERROR */) {
		quitenv(NULL);
		unwind(i);
		internal_errorf("%s %d", "FUNSUB<", i);
		/* NOTREACHED */
	}
a1811 1
	return (i);
@


1.134
log
@as a more general solution to fd leak detection, just do CLOEXEC manually
(this also allows us to see “real” leaks)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.132 2012/12/17 23:18:03 tg Exp $");
d62 1
d1322 1
a1322 1
		int ofd1;
d1334 6
a1339 5
		/* run tree, with output thrown into the tempfile */
		execute(t, XXCOM | XERROK, NULL);
		/* close the tempfile and restore regular stdout */
		shf_close(tf->shf);
		restfd(1, ofd1);
d1799 26
@


1.133
log
@do not leak file descriptors on builtins

(this is for valgrind; we use close-on-exec on them in the normal case)
@
text
@d1343 1
a1343 6
#ifdef DEBUG_LEAKS
#define ofd1 e->savefd[1]
#else
		int ofd1;
#endif
		int pv[2];
a1346 8
#ifdef DEBUG_LEAKS
		if (!e->savefd) {
			e->savefd = alloc2(NUFILE, sizeof(short), ATEMP);
			memset(e->savefd, 0, NUFILE * sizeof(short));
		}
		/* hack to get it closed in child */
		e->savefd[pv[0]] = pv[0];
#endif
@


1.132
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d5 1
a5 1
 *		 2011, 2012
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.131 2012/12/08 18:30:29 tg Exp $");
d1343 6
a1348 1
		int ofd1, pv[2];
d1352 8
@


1.131
log
@add a few assertions for LLVM+Clang 3.2 scan-build; no !DEBUG changes
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.130 2012/11/30 20:19:11 tg Exp $");
d1328 1
a1328 1
			    "create", tf->tffn, strerror(errno));
@


1.130
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.129 2012/10/22 20:19:12 tg Exp $");
d519 1
@


1.129
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.128 2012/08/24 21:15:42 tg Exp $");
a279 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a280 1
#endif
a284 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a288 1
#endif
a293 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a297 1
#endif
a1318 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a1340 1
#endif
@


1.128
log
@related to LP#1025843 fix tab completion for tilde

this code is insane, who wrote globbing and expansion for mksh’s
predecessor must have been on very interesting drugs
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.124 2012/08/17 18:34:20 tg Exp $");
d61 1
a61 1
static int comsub(Expand *, const char *);
d280 3
d287 7
a293 1
					*dp++ = '(';
d298 7
a304 1
					*dp++ = ')';
d306 1
a306 1
					type = comsub(&x, sp);
d1290 1
a1290 1
comsub(Expand *xp, const char *cp)
d1325 24
@


1.127
log
@second attempt at getting '$FOO/b*r/baz' tab-completed right,
plus the beginning of the tilde fix… do not use, this is fucking
impossible to get right, but I’d like an archival commit
@
text
@d1011 1
a1011 1
			else {
a1013 3
				if (f & DOKEEPQCHAR)
					*dp++ = QCHAR;
			}
@


1.126
log
@repair globbing $foo/ba*r/baz
@
text
@a65 1
static char *tilde(char *);
d1014 2
a1015 2
				if (f & DOKEEPQUOTE)
					*dp++ = '\\';
d1644 1
a1644 1
static char *
@


1.125
log
@more int → bool
@
text
@d1012 1
a1012 1
			else
d1015 3
@


1.124
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.123 2012/07/30 21:37:11 tg Exp $");
d63 1
a63 1
static void glob(char *, XPtrV *, int);
d898 1
a898 1
					glob(p, wp, f & DOMARKDIRS);
d1402 1
a1402 1
glob(char *cp, XPtrV *wp, int markdirs)
d1423 1
a1423 1
glob_str(char *cp, XPtrV *wp, int markdirs)
d1723 1
a1723 1
			glob(start, wp, fdo & DOMARKDIRS);
@


1.123
log
@implement ksh93 feature ${ foo;}
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.121 2012/07/20 23:22:10 tg Exp $");
d61 1
a61 1
static int comsub(Expand *, const char *, int);
a280 1
			case FUNSUB:
d285 1
a285 5
					if (c == FUNSUB) {
						*dp++ = '{';
						*dp++ = ' ';
					} else
						*dp++ = '(';
d290 1
a290 5
					if (c == FUNSUB) {
						*dp++ = ';';
						*dp++ = '}';
					} else
						*dp++ = ')';
d292 1
a292 1
					type = comsub(&x, sp, c);
d1276 1
a1276 1
comsub(Expand *xp, const char *cp, int fn)
d1321 1
a1321 2
		execute(t, XXCOM | XPIPEO |
		    (fn == FUNSUB ? XERROK : XFORK), NULL);
d1323 3
a1325 5
		if (fn != FUNSUB) {
			startlast();
			/* waitlast() */
			xp->split = true;
		}
@


1.122
log
@more int → bool
@
text
@d61 1
a61 1
static int comsub(Expand *, const char *);
d281 1
d285 6
a290 1
					*dp++ = '$'; *dp++ = '(';
d295 5
a299 1
					*dp++ = ')';
d301 1
a301 1
					type = comsub(&x, sp);
d624 2
a625 2
						f = DOPAT | (f&DONTRUNCOMMAND) |
						    DOTEMP;
d1285 1
a1285 1
comsub(Expand *xp, const char *cp)
d1299 2
d1304 4
a1307 1
	if (t != NULL && t->type == TCOM &&
a1319 2
		/* no waitlast() */
		xp->split = false;
d1322 1
d1330 2
a1331 1
		execute(t, XFORK|XXCOM|XPIPEO, NULL);
d1333 5
a1337 3
		startlast();
		/* waitlast() */
		xp->split = true;
a1339 1
	UTFMODE = old_utfmode;
a1346 1

@


1.121
log
@do implement quoting, as ${foo@@Q} though, as hommage at mirmake
dedicate this “release” to Andi
and use tomorrow’s (UTC) day for version, to cover up my debian fuckup
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.120 2012/06/28 20:03:20 tg Exp $");
d44 1
a44 1
	short split;			/* split "$@@" / call waitlast $() */
d220 2
a221 2
	int saw_eq, tilde_ok;
	int make_magic;
d243 1
a243 1
	saw_eq = 0;
d247 1
a247 1
	make_magic = 0;
d761 1
a761 1
				make_magic = 1;
d767 1
a767 1
				make_magic = 1;
d773 1
a773 1
				make_magic = 1;
d903 1
a903 1
				saw_eq = 0;
d974 1
a974 1
						saw_eq = 1;
d1016 1
a1016 1
				make_magic = 0;
d1184 2
a1185 1
			xp->split = c == '@@'; /* $@@ */
d1225 2
a1226 1
				xp->split = p[1] == '@@'; /* ${foo[@@]} */
d1306 1
a1306 1
		xp->split = 0;
d1320 1
a1320 1
		xp->split = 1;
@


1.120
log
@fix trimming with positional parameters (Closes: #48453)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.119 2012/06/24 19:36:27 tg Exp $");
d409 9
d746 1
d1174 1
d1202 1
d1259 2
a1260 1
	    stype == (0x80 | '0') || stype == (0x100 | '#'))
@


1.120.2.1
log
@MFC cid 1005037D2C82E041A1D, 1005037DE8E56F5392F, 1005037EABE57131431, 1005037EEEC1CEDE454, 1005037F34F0A0722F6:
• quell tabcompletion memory leak
• fix tab completion for tilde, related to LP#1025843
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.120 2012/06/28 20:03:20 tg Exp $");
d66 1
d1624 1
a1624 1
char *
@


1.119
log
@Coverity 703479: add missing /* FALLTHROUGH */
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.118 2012/05/04 22:05:00 tg Exp $");
d372 10
a381 1
					st->var = x.var;
@


1.118
log
@more symlink(7) nonexistence support code
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.117 2012/04/22 21:50:31 tg Exp $");
d792 1
@


1.117
log
@after discussion with ciruZ, switch mksh from NZAT to NZAAT fully
to get rid of the bias introduced by making the hash never zero

… he also pointed out a memory (heap) usage optimisation… which
may impact code size a bit though as I’d need to pass an additional
argument on hashtable function calls… or, forgo the benefit of not
having to pointer-align the key in the structure, which can be as
much as 3/7 octets per item, heap storage… OTOH the saved space is
4/8 octets per not-allocated item, possibly some code (use of an
multiply-add opcode), but the function call overhead/cost would
possibly be quite a bit… I guess I’ll have to measure…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.116 2012/04/06 14:07:52 tg Exp $");
d1440 1
a1440 1
			if (lstat(Xstring(*xs, xp), &lstatb) < 0)
@


1.116
log
@fix indentation mishap
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.114 2012/03/27 22:58:38 tg Exp $");
d395 1
a395 1
						NZATFinish(h);
@


1.115
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d397 1
a397 1
						     (unsigned int)h);
@


1.114
log
@g/c magic definitions for simple chars (as opposed to e.g. tokens/lexems)

some (such as NOT) were already gone; this should unconfuse; most were
unused anyway…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.113 2012/03/23 23:25:27 tg Exp $");
d396 2
a397 1
						x.str = shf_smprintf("%08X", h);
@


1.113
log
@huh, I thought I had extended ${parameter@@#hash} already; make it so now,
but not yet things like ${parameter@@Fi} (1 if integer, 0 otherwise), etc.
also bump patchlevel and © years in recently changed files
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.112 2012/03/23 20:07:10 tg Exp $");
d939 2
a940 1
				case OBRACE:
d942 1
a942 2
				case CBRACE:
					if ((f & DOBRACE) && (c == OBRACE ||
d1667 1
a1667 1
	for (p = exp_start; (p = strchr(p, MAGIC)) && p[1] != OBRACE; p += 2)
d1677 1
a1677 1
				if (*++p == OBRACE)
d1679 1
a1679 1
				else if (*p == CBRACE)
d1710 1
a1710 1
			if (*++p == OBRACE)
d1712 1
a1712 1
			else if ((*p == CBRACE && --count == 0) ||
@


1.112
log
@drop use of the NOT macro, [^foo] ≠ [!foo] anyway, and we’re not gonna change that
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.111 2011/12/16 20:03:12 tg Exp $");
d379 18
a396 2
						x.str = shf_smprintf("%08X",
						    (unsigned int)hash(str_val(st->var)));
d398 1
@


1.112.2.1
log
@MFC fixes from HEAD
@
text
@d4 1
a4 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.116 2012/04/06 14:07:52 tg Exp $");
d921 1
a921 2
				case '{':
				case '}':
d923 2
a924 1
					if ((f & DOBRACE) && (c == '{' /*}*/ ||
d1649 1
a1649 1
	for (p = exp_start; (p = strchr(p, MAGIC)) && p[1] != '{' /*}*/; p += 2)
d1659 1
a1659 1
				if (*++p == '{' /*}*/)
d1661 1
a1661 1
				else if (*p == /*{*/ '}')
d1692 1
a1692 1
			if (*++p == '{' /*}*/)
d1694 1
a1694 1
			else if ((*p == /*{*/ '}' && --count == 0) ||
@


1.111
log
@fix ifs.sh; anonymous submission (mkt?), 10x
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.110 2011/11/26 00:45:20 tg Exp $");
d899 1
a899 1
				case NOT:
@


1.110
log
@fix stateptr-underflow; really do call fastbox regression checks; bump vsn
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.109 2011/10/11 19:06:07 tg Exp $");
d866 12
a877 2
				if (c != 0)
					Xinit(ds, dp, 128, ATEMP);
a878 2
			if (c == 0)
				return;
@


1.109
log
@oh lookie, oksh fixed something we did in 2007… ⇒ pointless rcsid-in-comment sync
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.108 2011/09/07 15:24:13 tg Exp $");
d192 1
a193 1
	short	base;		/* begin position of expanded word */
@


1.108
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.36 2011/03/15 08:39:54 okan Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.107 2011/08/27 18:06:42 tg Exp $");
@


1.107
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.106 2011/07/02 17:57:02 tg Exp $");
d235 1
a235 1
		f |= DOBRACE_;
d576 1
a576 1
						/* ! DOBLANK,DOBRACE_,DOTILDE */
d578 1
a578 1
						    DOTEMP_;
d607 1
a607 1
						f |= DOTEMP_;
d612 1
a612 1
						f &= ~(DOBLANK|DOGLOB|DOBRACE_);
d617 1
a617 1
						f |= DOTEMP_;
d852 1
a852 1
				if (fdo & DOBRACE_)
d859 1
a859 1
				else if ((f & DOPAT) || !(fdo & DOMAGIC_))
d900 1
a900 1
						fdo |= DOMAGIC_;
d909 1
a909 1
						fdo |= DOMAGIC_ | (f & DOGLOB);
d916 3
a918 3
					if ((f & DOBRACE_) && (c == OBRACE ||
					    (fdo & DOBRACE_))) {
						fdo |= DOBRACE_|DOMAGIC_;
d924 1
a924 1
					if (!(f & DOTEMP_) && !saw_eq &&
d934 1
a934 1
					if (!(f & DOTEMP_) && (f & DOASNTILDE))
d970 1
a970 1
				fdo |= DOMAGIC_ | (f & DOGLOB);
d973 1
a973 1
				fdo |= DOMAGIC_;
@


1.106
log
@fix vstrchr like use of cstrchr
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.105 2011/06/12 14:45:33 tg Exp $");
d70 1
a70 1
static size_t utflen(const char *);
d74 1
a74 1
static size_t
d87 4
a90 1
	return (n);
d587 1
a587 2
							*dp++ = (char)('@@' |
							    0x80);
d724 1
a724 1
				c = *sp++ + 0x80;
d1479 1
a1479 2
		int len;
		int prefix_len;
@


1.105
log
@ACK found a missing "static", gcc on Minix found a missing cast; add more type size checks
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.104 2011/05/02 22:52:51 tg Exp $");
d1184 1
a1184 1
				if (cstrchr(sp, '[')) {
@


1.104
log
@• fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
• merge tputS and wdstrip_internal
⇒ net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.103 2011/03/28 08:27:08 tg Exp $");
d376 1
a376 1
						    hash(str_val(st->var)));
@


1.103
log
@another Debian workaround for /bin/sh: don’t pattern in trims
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.102 2011/03/17 21:57:50 tg Exp $");
d401 1
a401 1
						evaluate(substitute(stg = wdstrip(beg, false, false), 0),
d405 1
a405 1
							evaluate(substitute(stg = wdstrip(mid, false, false), 0),
d444 2
a445 1
						tpat0 = wdstrip(s, true, true);
d448 1
a448 1
							d = wdstrip(p, true, false);
@


1.102
log
@• fix check for empty pattern in ${foo/bar/baz} expansion: the
  character anchoring the pattern (‘#’ or ‘%’) must be skipped
  if one was used; fixes “BLA="#test"; echo "${BLA//#/}"” busy
  looping (due to null pattern) found by Jb_boin
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.101 2011/03/16 20:31:33 tg Exp $");
d581 5
a585 2
						*dp++ = MAGIC;
						*dp++ = (char)('@@' | 0x80);
d641 6
a646 2
					/* Append end-pattern */
					*dp++ = MAGIC; *dp++ = ')'; *dp = '\0';
@


1.101
log
@RCSID sync with openbsd, one we had already, one Okan Demirmen stole
from mksh (but attributed, so it’s okay, considering the amount of
patch is not large enough to warrant copyright stuff)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.100 2011/03/13 16:03:50 tg Exp $");
d467 17
a483 2
						/* reject empty pattern */
						if (!*pat || gmatchx("", pat, false))
d485 17
d504 1
a504 1
						strdupx(s, str_val(st->var), ATEMP);
d562 1
@


1.100
log
@• speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
• parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.35 2010/03/24 08:27:26 fgsch Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.99 2011/03/13 01:20:17 tg Exp $");
@


1.99
log
@lint is your friend
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.98 2011/03/12 23:06:43 tg Exp $");
d1185 1
d1190 1
a1190 1
	t = compile(s);
d1228 1
@


1.98
log
@now fix that segfault and other bug from yesternight
do it like ksh93 though, not like bash and zsh
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.97 2011/03/12 23:04:45 tg Exp $");
d249 1
a249 1
	while (1) {
@


1.97
log
@• back out the EXPRSUB change
• optimise some code
• split testcase into two, one with expected-fail
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.95 2011/03/07 20:30:36 tg Exp $");
d394 3
a396 1
							if (end >= stg)
@


1.96
log
@• make EXPRSUB not initiate an ASCIIZ string any more but a wdstring
  (token stream, lexer output / parser input), EOS terminated, let
  SASPAREN use the same lexing as SBASE (e.g. COMSUB recursively)
• make wdstrip recursive
• fix processing of COMSUB in wdstrip
⇒ pass comsub-1 test
• expose another debugging function
@
text
@d294 1
a294 5
			case EXPRSUB: {
				char *xp;

				xp = wdstrip(sp, true, false);
				sp = wdscan(sp, EOS);
a297 1
					c = strlen(xp);
d299 4
a302 3
					XcheckN(ds, dp, c + 2);
					memcpy(dp, xp, c);
					dp += c;
d312 1
a312 1
					v_evaluate(&v, substitute(xp, 0),
d314 1
a319 1
				afree(xp, ATEMP);
a320 1
			}
@


1.95
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.94 2011/01/21 22:25:32 tg Exp $");
d294 5
a298 1
			case EXPRSUB:
d302 1
d304 3
a306 4
					while (*sp != '\0') {
						Xcheck(ds, dp);
						*dp++ = *sp++;
					}
d316 1
a316 1
					v_evaluate(&v, substitute(sp, 0),
a317 1
					sp = strnul(sp) + 1;
d323 1
d325 1
@


1.94
log
@${foo@@x} is now special-expansion for values of x, defined for now:
‘#’ = hash of $foo
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.93 2010/09/14 21:26:10 tg Exp $");
d510 3
a512 2
								c = *p; *p = '\0';
								gotmatch = gmatchx(sbeg, tpat0, false);
@


1.93
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.92 2010/08/28 20:22:16 tg Exp $");
d132 2
a133 1
	XPput(w, NULL);		/* space for shell name */
d209 2
a210 1
	Expand x = {		/* expansion variables */
d214 2
a215 1
	int newlines = 0; /* For trailing newlines in COMSUB */
d234 2
a235 1
	Xinit(ds, dp, 128, ATEMP);	/* init dest. string */
d240 2
a241 1
	tilde_ok = (f & (DOTILDE|DOASNTILDE)) ? 1 : 0; /* must be 1/0 */
d253 2
a254 1
		case XBASE:	/* original prefixed string */
d264 2
a265 1
				quote |= 2; /* temporary quote */
d309 2
a310 1
					v.type = 10; /* not default */
d321 4
a324 2
			case OSUBST: {	/* ${{#}var{:}[=+-?#%]word} */
			/* format is:
d329 2
a330 1
				const char *varname = ++sp; /* skip the { or x (}) */
d334 2
a335 1
				sp = cstrchr(sp, '\0') + 1; /* skip variable */
a338 1

d340 2
a341 1
					sp = varname - 2; /* restore sp */
d354 2
a355 1
				if (type == XBASE) {	/* expand? */
d373 5
a377 1
					switch (stype & 0x7f) {
d489 2
a490 1
						/* this would not be necessary if gmatchx would return
d540 2
a541 1
						/* Prepend open pattern (so |
d549 2
a550 1
						/* Enabling tilde expansion
d566 2
a567 1
						/* These will be done after the
d587 2
a588 1
			case CSUBST: /* only get here if expanding word */
d590 4
a593 2
				sp++; /* ({) skip the } or x */
				tilde_ok = 0;	/* in case of ${unset:-} */
d599 1
a599 1
				switch (st->stype&0x7f) {
d605 2
a606 1
					/* Must use st->var since calling
d621 2
a622 1
					/* Restore our position and substitute
d628 2
a629 1
					/* Must use st->var since calling
d633 2
a634 1
					/* Note: not exported by FEXPORT
d637 2
a638 1
					/* XXX POSIX says readonly is only
d662 1
d674 2
a675 1
			case OPAT: /* open pattern: *(foo|bar) */
d681 2
a682 1
			case SPAT: /* pattern separator (|) */
d687 2
a688 1
			case CPAT: /* close pattern */
d696 2
a697 1
			/* Special case for "$@@" (and "${foo[@@]}") - no
d704 2
a705 1
				/* not really correct: x=; "$x$@@" should
d729 2
a730 1
				/* force null words to be created so
d757 2
a758 1
			if (newlines) {		/* Spit out saved NLs */
d788 2
a789 1
			/* How words are broken up:
d848 2
a849 1
					/* For character classes - doesn't hurt
d885 2
a886 1
				case ':': /* : */
d892 2
a893 1
					/* tilde_ok is reset whenever
d919 2
a920 1
				quote &= ~2; /* undo temporary */
d930 2
a931 1
			*dp++ = c; /* save output char */
d953 2
a954 1
	if ((stype = sp[0]) == '\0')	/* Bad variable name */
d1022 2
a1023 1
		*stypep = 0; /* unqualified variable/string substitution */
d1048 2
a1049 1
	} else if (ctype(c, C_SUBOP2)) { /* Note: ksh88 allows :%, :%%, etc */
d1056 10
a1065 1
	} else if (stype)	/* : is not ok */
d1074 1
a1074 1
		switch (stype & 0x7f) {
d1080 1
d1093 2
a1094 1
		zero_ok = true;	/* POSIX 2009? */
d1100 1
a1100 1
			switch (stype & 0x7f) {
d1107 1
d1134 1
a1134 1
			if ((stype & 0x7f) == '=' &&
d1149 2
a1150 1
					xp->str = "0";	/* ksh93 compat */
d1159 1
a1159 1
	c = stype&0x7f;
d1161 1
a1161 1
	if (ctype(c, C_SUBOP2) || stype == (0x80 | '0') || c == '/' ||
d1163 4
a1166 2
	    c == '=' || c == '-' || c == '?' : c == '+'))
		state = XBASE;	/* expand word instead of variable value */
d1193 1
a1193 1
	if (t != NULL && t->type == TCOM && /* $(<file) */
d1195 1
d1206 2
a1207 1
		xp->split = 0;	/* no waitlast() */
d1220 2
a1221 1
		xp->split = 1;	/* waitlast() */
d1239 2
a1240 1
	case '#':		/* shortest at beginning */
d1250 2
a1251 1
	case '#'|0x80:		/* longest match at beginning */
d1261 2
a1262 1
	case '%':		/* shortest match at end */
d1277 2
a1278 1
	case '%'|0x80:		/* longest match at end */
d1288 2
a1289 1
	return (str);		/* no match, return string */
d1315 2
a1316 1
/* Apply file globbing to cp and store the matching files in wp. Returns
d1348 4
a1351 2
	if (sp == NULL) {	/* end of source path */
		/* We only need to check if the file exists if a pattern
d1367 2
a1368 1
			/* special case for systems which strip trailing
d1377 2
a1378 1
			/* Possibly tack on a trailing / if there isn't already
d1405 2
a1406 1
		odirsep = *np;	/* don't assume '/', can be multiple kinds */
d1414 2
a1415 1
	/* Check if sp needs globbing - done to avoid pattern checks for strings
d1444 2
a1445 1
				continue; /* always ignore . and .. */
d1496 2
a1497 1
/* Check if p is an unquoted name, possibly followed by a / or :. If so
d1615 2
a1616 1
		/* Note that given a{{b,c} we do not expand anything (this is
@


1.92
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.91 2010/08/28 18:50:49 tg Exp $");
d1565 4
@


1.91
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.90 2010/07/17 22:09:33 tg Exp $");
d111 1
a111 1
		internal_errorf("substitute");
d1137 1
a1137 1
		if ((io->flag&IOTYPE) != IOREAD)
d1143 1
a1143 1
			errorf("%s: %s", name, "cannot open $() input");
@


1.90
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.89 2010/05/16 19:17:42 tg Exp $");
d337 1
a337 1
					errorf("%s: bad substitution", str);
d977 1
a977 1
			errorf("%s: parameter not set", sp);
d1108 1
a1108 1
		errorf("%s: parameter not set", sp);
d1138 1
a1138 1
			errorf("funny $() command: %s",
d1143 1
a1143 1
			errorf("%s: cannot open $() input", name);
@


1.89
log
@related to 1004BF041CB522EEEE3 ${foo[*]} is a vector too; add testcases
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.88 2010/05/16 19:04:41 tg Exp $");
d1562 1
a1562 1
				char *new;
d1568 7
a1574 7
				new = alloc(l1 + l2 + l3 + 1, ATEMP);
				memcpy(new, start, l1);
				memcpy(new + l1, field_start, l2);
				memcpy(new + l1 + l2, brace_end, l3);
				new[l1 + l2 + l3] = '\0';
				alt_expand(wp, new, new + l1,
				    new + l1 + l2 + l3, fdo);
@


1.88
log
@disallow some more kinds to trim a vector; Debian #581867
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.87 2010/04/20 09:10:07 tg Exp $");
d1048 2
@


1.87
log
@Fourth time’s a charm… another bugfix related to the commitids
1004BBDD84556472D84, 1004BBF77B81D30DA7C and 1004BBF7CD656308A1C
to unbreak kwalletcli
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.86 2010/04/09 19:16:30 tg Exp $");
d1023 2
@


1.86
log
@draft a testcase to understand the problem fixed by cid 1004BBF77B81D30DA7C
and make it actually work: the OpenBSD fix failed since 1004BBDD84556472D84
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.85 2010/04/09 18:53:29 tg Exp $");
d571 1
a571 1
				quote = st->quotew;
@


1.85
log
@apply oksh bugfix for my bugfix they applied in oksh… ugh…
from halex@@o: modified to handle the case when the expr is quoted

no difference in check.t or ifs.sh though…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.84 2010/04/08 13:21:04 tg Exp $");
d191 2
a192 1
	short	quote;		/* saved value of quote (for ${..[%#]..}) */
d267 1
a267 1
				quote = st->quote;	/* XXX correct? */
d356 1
a356 1
					st->quote = quote;
d521 1
a521 1
						st->quote = quote = 0;
d571 1
a571 1
				quote = st->quote;
d587 1
a587 1
					if (x.str[0] != '\0' || st->quote)
@


1.84
log
@Fix two more POSIX conformance bugs and minor documentation/comment issues
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.34 2009/01/29 23:27:26 jaredy Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.83 2010/02/25 20:18:15 tg Exp $");
d586 4
a589 1
					type = strlen(x.str) ? XSUB : XNULLSUB;
@


1.83
log
@(hopefully) fix the substitution thing for good
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.82 2010/01/29 09:34:27 tg Exp $");
d520 1
a520 1
						quote = 0;
@


1.82
log
@remove some more of this ugliness
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.81 2010/01/25 14:07:38 tg Exp $");
d266 1
a266 1
				quote = 0;
@


1.81
log
@fix © year
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.80 2010/01/01 17:44:07 tg Exp $");
d554 1
a554 1
						/* FALLTHRU */
@


1.80
log
@• re-implement wcswidth-like behaviour for ${%foo} even in !UTFMODE
• merge the rest of branch tg-wcswidth-behaviour
• enhance test cases for wcswidth-like behaviour
• switch hash table collision resolution algorithm to Python’s as announced
• bump vsn
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.79 2009/12/05 22:24:35 tg Exp $");
@


1.79
log
@memmove not memcpy, src/dst overlap
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.78 2009/12/05 17:43:45 tg Exp $");
d944 27
a970 1
			c = stype == '#' ? (int)utflen(p) : utf_mbswidth(p);
d975 1
a975 1
		xp->str = shf_smprintf("%u", (unsigned int)c);
@


1.78
log
@llvm/clang scan-build is now content…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.76 2009/11/28 14:27:59 tg Exp $");
d1367 1
a1367 1
		memcpy(dp, sp, s - sp);
@


1.77
log
@clangs static analyser says these are dead stores
@
text
@d239 2
a240 1
	st_head.next = NULL;
@


1.76
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.74 2009/11/22 13:49:04 tg Exp $");
a362 4
						/* ! DOBLANK,DOBRACE_,DOTILDE */
						f = DOPAT | (f&DONTRUNCOMMAND) |
						    DOTEMP_;
						quote = 0;
a411 5
						/* ! DOBLANK,DOBRACE_,DOTILDE */
						f = DOPAT | (f&DONTRUNCOMMAND) |
						    DOTEMP_;
						quote = 0;

@


1.75
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d952 1
a952 2
			c = stype == '#' ? (int)utflen(p) :
			    utf_mbswidth(p, false);
d957 1
a957 1
		xp->str = shf_smprintf("%d", c);
@


1.74
log
@prevent buffer underrun reads, ok bsiegert@@
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.73 2009/11/21 23:23:17 tg Exp $");
d952 2
a953 1
			c = stype == '#' ? (int)utflen(p) : utf_mbswidth(p);
d958 1
a958 1
		xp->str = shf_smprintf("%u", (unsigned int)c);
@


1.74.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.75 2009/11/28 14:21:43 tg Exp $");
d952 1
a952 2
			c = stype == '#' ? (int)utflen(p) :
			    utf_mbswidth(p, false);
d957 1
a957 1
		xp->str = shf_smprintf("%d", c);
@


1.73
log
@since we have wcwidth anyway, expose it as ${%strvar} to the user, iff
utf8-mode is enabled (otherwise it'll be a synonym for ${#strvar} aka
the number of octets in it)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.72 2009/11/21 22:32:08 tg Exp $");
d1176 1
a1176 1
				while ((*--p & 0xC0) == 0x80)
@


1.72
log
@fix that as well
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.70 2009/10/30 00:57:37 tg Exp $");
d914 1
a914 1
	if (sp[0] == '\0')	/* Bad variable name */
d919 9
a927 3
	/* ${#var}, string length or array size */
	if (sp[0] == '#' && (c = sp[1]) != '\0') {
		/* Can't have any modifiers for ${#...} */
d936 2
d945 3
a947 1
		} else if (c == '*' || c == '@@')
d949 1
a949 1
		else {
d952 1
a952 1
			c = utflen(p);
d957 1
a957 1
		xp->str = shf_smprintf("%lu", (unsigned long)c);
@


1.71
log
@bugfix: ${x#?} should expand to nothing not '' if x was unset
@
text
@d1140 1
a1140 1
		for (p = str; p <= end; p++) {
d1160 16
a1175 1
		for (p = end; p >= str; p--)
a1181 5
	case '%'|0x80:		/* longest match at end */
		for (p = str; p <= end; p++)
			if (gmatchx(p, pat, false))
				goto trimsub_match;
		break;
@


1.70
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.69 2009/09/06 17:42:12 tg Exp $");
d594 1
a594 1
					type = XSUB;
@


1.69
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.68.2.1 2009/08/30 20:56:05 tg Exp $");
d1182 1
a1182 1
/* XXX cp not const 'cause slashes are temporarily replaced with nulls... */
@


1.68
log
@the capability to get array indicēs (keys), Korn shell style
bash4 doesn’t have it at all, despite knowing associative arrays
zsh does it………… differently and weird

this is for indexed arrays, as mksh doesn’t have associative arrays
but it should help ☺
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.67 2009/08/28 21:35:43 tg Exp $");
d1024 1
a1024 2
				    vp->flag & AINDEX ?
				    (unsigned long)vp->ua.index : 0) :
a1038 2
			if (*sp == '!' && sp[1])
				return (-1);
d1043 17
a1059 2
			xp->var = global(sp);
			xp->str = str_val(xp->var);
@


1.68.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic “typeset -n v=$1” or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.68 2009/08/28 22:39:09 tg Exp $");
d1024 2
a1025 1
				    arrayindex(vp)) :
d1040 2
d1046 2
a1047 17
			if (*sp == '!' && sp[1]) {
				++sp;
				xp->var = global(sp);
				if (cstrchr(sp, '[')) {
					if (xp->var->flag & ISSET)
						xp->str = shf_smprintf("%lu",
						    arrayindex(xp->var));
					else
						xp->str = null;
				} else if (xp->var->flag & ISSET)
					xp->str = xp->var->name;
				else
					xp->str = "0";	/* ksh93 compat */
			} else {
				xp->var = global(sp);
				xp->str = str_val(xp->var);
			}
@


1.67
log
@spotted a missing substitute() call inside evaluate() call
incl. regression test
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.66 2009/08/28 20:30:55 tg Exp $");
d998 1
a998 1
			xp->u.strv = (const char **) e->loc->argv + 1;
d1017 2
d1023 4
a1026 1
				XPput(wv, str_val(vp));
d1034 1
a1034 1
				xp->u.strv = (const char **) XPptrv(wv);
d1040 2
@


1.66
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.64 2009/08/01 19:31:02 tg Exp $");
d388 1
a388 1
							evaluate(stg = wdstrip(mid, false, false),
@


1.65
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d1428 1
a1428 1
	ap = ktenter(&homedirs, name, hash(name), NULL);
@


1.64
log
@utfincptr is a no-op in !UTFMODE, yet I had the “if (UTFMODE)” not only
commented out for mksh R38* but also used // denoting a temporary, de-
bugging-only, code exclusion which never should have been in the wild

Caught by ucode cc on DEC ULTRIX (where else?), thanks DEChengst ☻☺
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.63 2009/07/25 20:26:31 tg Exp $");
d1428 1
a1428 1
	ap = ktenter(&homedirs, name, hash(name));
@


1.63
log
@improve MKSH_NOPWNAM handling, whether MKSH_SMALL or not; it will cause
the entire ~fac/ expansion code to be omitted
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.62 2009/07/25 20:17:47 tg Exp $");
d400 1
a400 1
//						if (UTFMODE)
d406 1
a406 1
//						if (UTFMODE)
@


1.62
log
@avoid a redefinition warning if MKSH_SMALL and MKSH_NOPWNAM both given
@
text
@d25 1
a25 5
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.61 2009/07/16 15:06:43 tg Exp $");

#if defined(MKSH_SMALL) && !defined(MKSH_NOPWNAM)
#define MKSH_NOPWNAM
#endif
@


1.61
log
@ABI bump to R39: adhere to the future POSIX standard regarding -o nounset;
add appropriate regression test (except $_ *is* unset in non-interactive
shells). See the thread at:
http://article.gmane.org/gmane.os.miros.general/8863
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.60 2009/06/11 12:42:17 tg Exp $");
d27 1
a27 1
#ifdef MKSH_SMALL
@


1.60
log
@capitalise AT&T®
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.59 2009/06/10 18:12:45 tg Exp $");
d916 1
a924 2
		int zero_ok = 0;

d936 1
a936 1
				zero_ok = 1;
d1007 1
d1055 1
a1055 1
	if (Flag(FNOUNSET) && xp->str == null &&
@


1.59
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.58 2009/06/08 20:06:45 tg Exp $");
d615 1
a615 1
					 * in at&t ksh.
d767 1
a767 1
			 * Note that IFS_NWS/0 generates a word (at&t ksh
d1477 1
a1477 1
		 * what at&t ksh does. This may be changed to do the {b,c}
@


1.58
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.57 2009/05/16 18:40:05 tg Exp $");
d40 2
a41 2
	/* int type; */		/* see expand() */
	const char *str;	/* string */
d43 5
a47 5
		const char **strv;/* string[] */
		struct shf *shf;  /* file */
	} u;			/* source */
	struct tbl *var;	/* variable in ${var..} */
	short split;		/* split "$@@" / call waitlast $() */
d315 6
a320 7
			case OSUBST: /* ${{#}var{:}[=+-?#%]word} */
			  /* format is:
			   *   OSUBST [{x] plain-variable-part \0
			   *     compiled-word-part CSUBST [}x]
			   * This is where all syntax checking gets done...
			   */
			    {
d545 1
a545 1
						 * other assignments.  Not
d576 1
a576 1
			    }
d631 1
a631 2
				case '?':
				    {
d638 1
a638 1
				    }
d734 3
a736 2
				    if (c == '\n')
					    newlines++;	/* Save newlines */
d760 2
a761 2
			 *		   |       value of c
			 *	  word	   |	ws	nws	0
d763 4
a766 4
			 *	IFS_WORD	w/WS	w/NWS	w
			 *	IFS_WS		-/WS	w/NWS	-
			 *	IFS_NWS		-/NWS	w/NWS	w
			 *   (w means generate a word)
d1185 1
a1185 1
/* Apply file globbing to cp and store the matching files in wp.  Returns
d1297 1
a1297 1
		/* xp = *xpp;	   copy_non_glob() may have re-alloc'd xs */
d1358 1
a1358 1
/* Check if p is an unquoted name, possibly followed by a / or :.  If so
d1477 1
a1477 1
		 * what at&t ksh does.  This may be changed to do the {b,c}
@


1.57
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.56 2009/05/16 16:59:34 tg Exp $");
d118 1
a118 1
	return evalstr(yylval.cp, f);
d140 1
a140 1
	return (char **) XPclose(w) + 1;
d349 1
a349 1
						newst = alloc(sizeof (SubType), ATEMP);
d919 1
a919 1
		return -1;
d929 1
a929 1
			return -1;
d954 1
a954 1
		return XSUB;
d985 1
a985 1
		return -1;
d987 1
a987 1
		return -1;
d997 1
a997 1
			return -1;
d1019 1
a1019 1
				return -1;
d1043 1
a1043 1
				return -1;
d1059 1
a1059 1
	return state;
d1080 1
a1080 1
		return XBASE;
d1111 1
a1111 1
	return XCOM;
d1130 1
a1130 1
				return p;
d1140 1
a1140 1
				return p;
d1160 1
a1160 1
	return str;		/* no match, return string */
d1178 1
a1178 1
		    sizeof (void *), xstrcmp);
d1200 1
a1200 1
	return XPsize(*wp) - oldsize;
d1340 1
a1340 1
			return dp;
d1356 1
a1356 1
	return dp;
d1393 1
a1393 1
	return r;
d1439 1
a1439 1
			return NULL;
d1443 1
a1443 1
	return ap->val.s;
@


1.56
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.55 2009/05/16 15:53:01 tg Exp $");
a428 10
#if 0
						fprintf(stderr,
						    "D: s=%p 〈%s〉\n"
						    "   p=%p 〈%s〉\n"
						    "   d=%p 〈%s〉\n",
						    s, wdstrip(s, true, false),
						    p, wdstrip(p, true, false),
						    d, wdstrip(d, true, false));
						fflush(stderr);
#endif
a457 6
#if 0
						fprintf(stderr,
						    "D: 〔%s｜%s〕→〔%s〕\n",
						    tpat0, pat, rrep);
						fflush(stderr);
#endif
a483 6
#if 0
						fprintf(stderr,
						    "D: 「%s」 ← 〔%s｜%s〕\n",
						    s, tpat0, rrep);
						fflush(stderr);
#endif
@


1.55
log
@this began as a one-word change to the spec (manpage): that
${foo:1:2} operates on characters ipv bytes – which means:
‣ set +U: octets
‣ set -U: MirOS OPTU-8 characters

for consistency I also adapted ${#stringname} to deliver the
length in characters ipv bytes; more may follow; for example
I’d like a way to expose the string width.

you can already get the MirOS OPTU-16 of a character in the
WTF-8 (「set -U」) mode with something like
│ typeset -Uui16 -Z7 x=1#${stringname:position:1}
which will correctly use the PUA EF80‥EFFF mapping for octets.

due to this being an incompatible change, bump to R38

also change the unicode-hexdump sample regression test and
add two news for ${x:1:2} and ${#x} checks in A/W mode ☺
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.54 2009/04/07 18:41:35 tg Exp $");
@


1.54
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.53 2009/03/22 17:47:35 tg Exp $");
d54 29
d346 1
a346 1
						mksh_ari_t from = 0, num = -1, flen;
d379 1
a379 1
						flen = strlen(beg);
d382 1
a382 1
								beg += flen + from;
d384 5
a388 2
							beg += from < flen ? from : flen;
						flen = strlen(beg);
d391 2
d950 1
a950 1
			c = strlen(p);
@


1.53
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.52 2009/03/14 18:12:51 tg Exp $");
d140 3
a146 3
	struct tbl *var;	/* variable for ${var..} */
	struct SubType *prev;	/* old type */
	struct SubType *next;	/* poped type (to avoid re-allocating) */
@


1.52
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.33 2007/08/02 11:05:54 fgsch Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.51 2008/12/13 17:02:13 tg Exp $");
d1072 1
a1072 1
		execute(t, XFORK|XXCOM|XPIPEO);
@


1.51
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.50 2008/11/12 00:54:47 tg Exp $");
d317 1
a317 1
						long from = 0, num = -1, flen;
@


1.50
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.49 2008/10/28 14:32:39 tg Exp $");
d300 1
a300 2
						newst = alloc(1,
						    sizeof (SubType), ATEMP);
d592 1
a592 1
					    debunk(alloc(1, len, ATEMP),
d772 1
a772 1
					*(p = alloc(1, 1, ATEMP)) = '\0';
d1476 1
a1476 1
				new = alloc(1, l1 + l2 + l3 + 1, ATEMP);
@


1.50.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.50 2008/11/12 00:54:47 tg Exp $");
d68 1
a68 1
	gfree(s, ATEMP);
d290 1
a290 1
					gfree(beg, ATEMP);
d300 2
a301 1
						newst = galloc(1, sizeof (SubType), ATEMP);
d343 1
a343 1
						gfree(stg, ATEMP);
d347 1
a347 1
							gfree(stg, ATEMP);
d349 1
a349 1
						gfree(beg, ATEMP);
d399 1
a399 1
							gfree(d, ATEMP);
d402 1
a402 1
						gfree(s, ATEMP);
d421 1
a421 1
						gfree(tpat0, ATEMP);
d482 1
a482 1
						gfree(end, ATEMP);
d484 1
a484 1
						gfree(s, ATEMP);
d489 1
a489 1
						gfree(tpat1, ATEMP);
d492 1
a492 1
						gfree(pat, ATEMP);
d494 1
a494 1
							gfree(rrep, ATEMP);
d593 1
a593 1
					    debunk(galloc(1, len, ATEMP),
d773 1
a773 1
					*(p = galloc(1, 1, ATEMP)) = '\0';
d1045 1
a1045 1
	gfree(s, ATEMP);
d1477 1
a1477 1
				new = galloc(1, l1 + l2 + l3 + 1, ATEMP);
@


1.49
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.48 2008/10/24 20:52:22 tg Exp $");
d300 1
a300 1
						newst = (SubType *)alloc(
d593 1
a593 1
					    debunk((char *)alloc(len, ATEMP),
d773 1
a773 1
					*(p = alloc(1, ATEMP)) = '\0';
d1477 1
a1477 1
				new = (char *)alloc(l1 + l2 + l3 + 1, ATEMP);
@


1.48
log
@optimisation: s is never NULL or bigger than sbeg
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.47 2008/07/12 16:56:38 tg Exp $");
d360 1
a360 1
						x.str = str_nsave(beg, num, ATEMP);
d428 2
a429 2
						tpat0 = str_val(st->var);
						sbeg = s = str_save(tpat0, ATEMP);
d480 1
a480 1
						end = str_nsave_(s, sbeg - s, ATEMP);
d1115 6
a1120 4
		for (p = end; p >= str; p--) {
			if (gmatchx(p, pat, false))
				return str_nsave(str, p - str, ATEMP);
		}
d1123 1
a1123 1
		for (p = str; p <= end; p++) {
d1125 1
a1125 2
				return str_nsave(str, p - str, ATEMP);
		}
d1226 2
a1227 1
		XPput(*wp, str_nsave(Xstring(*xs, xp), Xlength(*xs, xp), ATEMP));
d1409 1
a1409 1
		ap->val.s = str_save(pw->pw_dir, APERM);
@


1.47
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.46 2008/05/17 18:46:58 tg Exp $");
d480 1
a480 1
						end = str_nsave(s, sbeg - s, ATEMP);
@


1.46
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.45 2008/03/01 22:49:37 tg Exp $");
d428 2
a429 1
						sbeg = s = str_save(str_val(st->var), ATEMP);
d773 1
a773 4
					if ((p = str_nsave(null, 0, ATEMP))
					    == NULL)
						internal_errorf("unable "
						    "to allocate memory");
@


1.45
log
@a better way to check for empty patterns
(not quite how bash handles it - they do a count limit)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.44 2008/03/01 21:24:58 tg Exp $");
d300 2
a301 2
						newst = (SubType *) alloc(
						    sizeof(SubType), ATEMP);
d592 1
a592 1
					    debunk((char *) alloc(len, ATEMP),
d1477 1
a1477 1
				new = (char *) alloc(l1 + l2 + l3 + 1, ATEMP);
@


1.45.2.1
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.46 2008/05/17 18:46:58 tg Exp $");
d300 2
a301 2
						newst = (SubType *)alloc(
						    sizeof (SubType), ATEMP);
d592 1
a592 1
					    debunk((char *)alloc(len, ATEMP),
d1477 1
a1477 1
				new = (char *)alloc(l1 + l2 + l3 + 1, ATEMP);
@


1.45.2.2
log
@MFC: mksh R35b
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d428 1
a428 2
						tpat0 = str_val(st->var);
						sbeg = s = str_save(tpat0, ATEMP);
d772 4
a775 1
					*(p = alloc(1, ATEMP)) = '\0';
@


1.45.2.3
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.51 2008/12/13 17:02:13 tg Exp $");
d300 2
a301 1
						newst = alloc(sizeof (SubType), ATEMP);
d360 1
a360 1
						strndupx(x.str, beg, num, ATEMP);
d428 2
a429 2
						strdupx(s, str_val(st->var), ATEMP);
						sbeg = s;
d480 1
a480 1
						strndupx(end, s, sbeg - s, ATEMP);
d593 1
a593 1
					    debunk(alloc(len, ATEMP),
d1115 4
a1118 6
		for (p = end; p >= str; p--)
			if (gmatchx(p, pat, false)) {
 trimsub_match:
				strndupx(end, str, p - str, ATEMP);
				return (end);
			}
d1121 1
a1121 1
		for (p = str; p <= end; p++)
d1123 2
a1124 1
				goto trimsub_match;
d1225 1
a1225 2
		strndupx(np, Xstring(*xs, xp), Xlength(*xs, xp), ATEMP);
		XPput(*wp, np);
d1407 1
a1407 1
		strdupx(ap->val.s, pw->pw_dir, APERM);
d1475 1
a1475 1
				new = alloc(l1 + l2 + l3 + 1, ATEMP);
@


1.44
log
@finally, all bugs fixed, adjust dot.mkshrc to use the subst code
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.43 2008/03/01 21:10:25 tg Exp $");
d424 1
a424 1
						if (!*pat)
@


1.43
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.36 2007/10/25 15:34:29 tg Exp $");
d396 6
a401 1
						rrep = d ? wdstrip(p, true, false) : null;
@


1.42
log
@fix one of the bugs in this code… still the one I’m looking for left
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.41 2008/02/29 11:51:21 tg Exp $");
a168 1
	int sqmode = 0;		/* keep backslashes before [\\/%#] */
d341 1
a341 1
						evaluate(substitute(stg = wdstrip(beg), 0),
d345 1
a345 1
							evaluate(stg = wdstrip(mid),
d363 128
a503 7
					case '/':
						/* ! DOBLANK,DOBRACE_,DOTILDE */
						f = DOPAT | (f&DONTRUNCOMMAND) |
						    DOTEMP_;
						quote = 0;
						sqmode = 2;
						break;
a546 1
				sqmode = 0;
d554 1
a554 4
					*dp++ = MAGIC; *dp++ = ')';
					/* FALLTHROUGH */
				case '/':
					*dp = '\0';
d605 1
a719 13
		if (sqmode) {
			/* keep backslash before backslash or C_SUBOP2 char */
			if ((c == '\\') ||
			    (quote && c == '/') ||
			    (quote && sqmode == 2 && ctype(c, C_SUBOP2)))
				*dp++ = '\\';
			if (sqmode == 2 && (quote || c != '/'))
				/* beginning of string, ign. leading chars */
				sqmode = 1;
			else if (!quote && c == '/')
				sqmode = 0;
		}

d931 8
a938 1
	if (stype == 0x80 && (c == ' ' || c == '0')) {
a961 1
		case '/':
a983 1
			case '/':
d1018 1
a1018 1
	if (ctype(c, C_SUBOP2) || stype == (0x80 | '0') ||
a1122 93
	case '/':		/* replace once - SLOW! */
	case '/'|0x80:		/* replace all - SLOWER! */
	    {
		char *rpat, *rrep, *tpat1, *tpat2, *tpat0, *sbeg, *s, *d;

		/* separate search pattern and replacement string */
		s = d = rpat = str_save(pat, ATEMP);
		rrep = null;
 		while ((c = *s++))
			if (c == '\\') {
				if (s[0] == '\\' && s[1] != '/')
					++s;
				if (!(*d++ = *s++))
					break;
			} else if (c == '/') {
				rrep = s;
				break;
			} else
				*d++ = c;
		*d++ = '\0';
		/* do not accept empty pattern */
		if (!*rpat) {
			afree(rpat, ATEMP);
			return (str);
		}

		/* prepare string on which to work */
		sbeg = s = str;

		/* first see if we have any match at all */
		tpat0 = rpat;
		d = pat;
		if (*d == '\\')
			++d;
		if (*d == '#') {
			/* anchor at the beginning */
			tpat1 = shf_smprintf("%s%c*", ++tpat0, MAGIC);
			tpat2 = tpat1;
		} else if (*d == '%') {
			/* anchor at the end */
			tpat1 = shf_smprintf("%c*%s", MAGIC, ++tpat0);
			tpat2 = tpat0;
		} else {
			/* float */
			tpat1 = shf_smprintf("%c*%s%c*", MAGIC, rpat, MAGIC);
			tpat2 = tpat1 + 2;
		}
#if 0
		fprintf(stderr, "D: 「%s」 → 〔%s｜%s〕\n", pat, tpat0, rrep);
		fflush(stderr);
#endif
 again_repl:
		/* this would not be necessary if gmatchx would return
		 * the start and end values of a match found, like re*
		 */
		if (!gmatchx(sbeg, tpat1, false))
			goto end_repl;
		/* now anchor the beginning of the match */
		if (*pat != '#')
			while (sbeg <= end) {
				if (gmatchx(sbeg, tpat2, false))
					break;
				else
					sbeg++;
			}
		/* now anchor the end of the match */
		p = end;
		if (*pat != '%')
			while (p >= sbeg) {
				bool gotmatch;

				c = *p; *p = '\0';
				gotmatch = gmatchx(sbeg, tpat0, false);
				*p = c;
				if (gotmatch)
					break;
				p--;
			}
		end = str_nsave(s, sbeg - s, ATEMP);
		d = shf_smprintf("%s%s%s", end, rrep, p);
		afree(end, ATEMP);
		sbeg = d + (sbeg - s) + strlen(rrep);
		if (s != str)
			afree(s, ATEMP);
		s = d;
		end = strnul(s);
		if ((how & 0xFF) != '/')
			goto again_repl;
 end_repl:
		afree(rpat, ATEMP);
		afree(tpat1, ATEMP);
		return (s);
	    }
@


1.41
log
@Sun C 5.9 SunOS_sparc Patch 124867-01 2007/07/12: statement not reached
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.40 2008/02/29 11:41:01 tg Exp $");
a1028 1
				*d++ = '\0';
d1033 1
d1061 4
@


1.40
log
@gcc sparc-sun-solaris2.8/3.4.3 warns about uninitialised usee of p
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.39 2008/02/27 12:49:53 tg Exp $");
a1101 1
		break;
@


1.39
log
@fix
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.38 2008/02/27 11:24:11 tg Exp $");
a1017 1
		bool gotmatch = false;
d1021 1
d1030 1
a1030 2
				p = s;
				gotmatch = true;
a1033 1
		rrep = gotmatch ? p : null;
d1079 2
@


1.38
log
@almost hack ${foo//bar/baz} support for real, now
still one corner case left ☹
→ 11:09⎜«Han:#UnixNL» Ik _haat_ bash
⇒ kann ich mich nur anschließen…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.37 2008/02/27 01:00:09 tg Exp $");
d169 1
a169 1
	int sqchar = 0;		/* char to keep bksl before (${…/…\/…/…}) */
d382 1
a382 1
						sqchar = 0x100 | '/';
d427 1
a427 1
				sqchar = 0;
d603 5
a607 3
		if (sqchar) {
			/* keep backslash before backslash or sqchar */
			if (quote || c == '\\')
d609 5
a613 5
			if (sqchar & 0x100 && (quote || (sqchar & 0xFF) != c)) {
				/* beginning of string, ign. leading sqchars */
				sqchar &= 0xFF;
			} else if ((sqchar & 0xFF) == c && !quote)
				sqchar = 0;
d1024 2
d1047 4
a1050 3
		if (*rpat == '\\' && (rpat[1] == '#' || rpat[1] == '%'))
			tpat0++;
		if (*tpat0 == '#') {
d1052 1
a1052 2
			tpat0++;
			tpat1 = shf_smprintf("%s%c*", tpat0, MAGIC);
d1054 1
a1054 1
		} else if (*tpat0 == '%') {
d1056 1
a1056 2
			tpat0++;
			tpat1 = shf_smprintf("%c*%s", MAGIC, tpat0);
@


1.37
log
@I _think_ this implements ${foo/bar/baz} logic (bar is a glob pattern)
todo tomorrow:
• test case (compare with e.g. GNU bash)
• manpage
• version bump

sqchar is a bit ugly, but \/ must be preserved, as we don’t get wdencoded
strings later on in the process (eval.c CSUBST) and I didn’t want to have
an implementation like ${foo: 2: 3} this time
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.36 2007/10/25 15:34:29 tg Exp $");
d382 1
a382 1
						sqchar = '/';
d603 10
a612 2
		if (quote && sqchar == c)
			*dp++ = '\\';
d1015 1
a1015 1
		char *rpat, *rrep, *tpat1, *tpat2, *sbeg, *s, *d;
a1017 1
		sbeg = s = str;
d1019 8
a1026 9
		p = d = rpat = str_save(pat, ATEMP);
 		while (*p)
			if (*p == '\\') {
				p++;
				if (*p)
					p++;
			} else if (*p == '/') {
				*p++ = '\0';
				d = p;
d1030 10
a1039 2
				p++;
		rrep = gotmatch ? d : null;
d1042 18
a1059 4
		tpat1 = shf_smprintf("%c%c%c*%s%c*%c)", MAGIC, '@@' | 0x80,
		    MAGIC, rpat, MAGIC, MAGIC);
		tpat2 = shf_smprintf("%c%c%s%c*%c)", MAGIC, '@@' | 0x80,
		    rpat, MAGIC, MAGIC);
d1064 1
a1064 1
		if (!gmatchx(s, tpat1, false))
d1067 7
a1073 5
		while (sbeg <= end)
			if (gmatchx(sbeg, tpat2, false))
				break;
			else
				sbeg++;
d1075 10
a1084 7
		for (p = end; p >= sbeg; p--) {
			c = *p; *p = '\0';
			gotmatch = gmatchx(sbeg, rpat, false);
			*p = c;
			if (gotmatch)
				break;
		}
a1097 1
		afree(tpat2, ATEMP);
@


1.36
log
@optimise more :)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.35 2007/09/09 18:06:39 tg Exp $");
d169 1
d377 7
d427 1
d435 4
a438 1
					*dp++ = MAGIC; *dp++ = ')'; *dp = '\0';
d603 3
d841 1
d864 1
d971 1
a971 1
	switch (how&0xff) {	/* UCHAR_MAX maybe? */
d982 1
a982 1
	case '#'|0x80:	/* longest match at beginning */
d998 1
a998 1
	case '%'|0x80:	/* longest match at end */
d1004 65
@


1.35
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.34 2007/07/31 10:42:15 tg Exp $");
d1246 1
a1246 3
	if (dp == null)
		dp = NULL;
	return dp;
@


1.34
log
@some steps towards building with tcc
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.30 2006/04/10 14:38:59 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.33 2007/07/06 02:39:36 tg Exp $");
d906 1
@


1.33
log
@I'm an idiot and this looks better and is more KISS (I suppose)

too bad I don't just wrap it in braces
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.32 2007/07/06 02:22:56 tg Exp $");
d101 1
a101 1
	char *dp;
d105 2
a106 1
	dp = (XPsize(w) == 0) ? null : (char*) *XPptrv(w);
@


1.32
log
@fix the rest of it
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.30 2007/07/01 15:39:22 tg Exp $");
d801 1
a801 1
	if (stype == 0x80 && !c && word[slen] && word[slen] != CHAR) {
@


1.31
log
@make this pass varexpand-substr-1 and ‘c’ of varexpand-substr-2
by actually using the lexer and parser for that
@
text
@d281 1
d325 3
d335 2
d340 2
a341 2
						evaluate(stg = wdstrip(beg), &from,
						    KSH_UNWIND_ERROR, true);
d801 1
a801 2
	if (stype == 0x80 && (ksh_isdigit(c) || c == '('/*)*/ ||
	    (!c && word[slen] && word[slen] != CHAR))) {
@


1.30
log
@fix struct packing – Microsoft® C warned about 2x2 bytes of padding here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.29 2007/06/27 23:12:58 tg Exp $");
d314 42
a355 3
					case '0':
						/* XXX begin arithmetic eval. */
						break;
d407 1
d470 6
a475 32
				    {
					char i, *s = Xrestpos(ds, dp, st->base);
					int from = 0, num = 0;
					/* bool fromend = false; */

					/* XXX use evaluate() from expr.c
					   XXX or directly parse as 2 exprs */
					/* if (*s == '-') {
						fromend = true;
						++s;
					} */
					while ((i = *s++) && i != ':')
						from = from * 10 + i - '0';
					if (i == ':') while ((i = *s++))
						num = num * 10 + i - '0';
					else
						num = -1;
					/* if (fromend) {
						int flen = strlen(x.str);

						if (from < flen)
							x.str += flen - from;
					} else */
						x.str += from;
					from = strlen(x.str);
					if (num < 0 || num > from)
						num = from;
					dp = Xstring(ds, dp);
					XcheckN(ds, dp, num);
					memcpy(dp, x.str, num);
					dp += num;
				    }
d795 2
a796 4
	if (stype == 0x80 && (ksh_isdigit(c) || c == ':')) {
		const char *tp = word + slen + 2;
		bool had_colon = false;

a797 14
		/* syntax check: minus, digits, one colon, digits */
		/* if (*tp == CHAR && tp[1] == '-')
			tp += 2; */
		while (*tp != EOS && *tp != CSUBST) {
			if (*tp != CHAR)
				return (-1);
			if (!ksh_isdigit(tp[1])) {
				if (!had_colon && tp[1] == ':')
					had_colon = true;
				else
					return (-1);
			}
			tp += 2;
		}
@


1.29
log
@this is bash compatibility week, and by suggestion of actual users,
namely Dr. Robert “Pfeffer” Arnold (in this case, in FreeWRT), make
a half-completed attempt at implementing ${foo:2:3} substring evals
(of course, negatives can't work right now and that the numbers are
in face expressions is something I only read later too – this is to
be revisited later, but it's already late)

don't depend on this behaviour yet though

if someone wants to add more regression tests, feel free to…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.28 2007/06/06 23:28:14 tg Exp $");
d142 1
a143 1
	short	quote;		/* saved value of quote (for ${..[%#]..}) */
@


1.28
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.27 2007/05/13 19:14:04 tg Exp $");
d314 3
d429 33
d781 20
a800 1
	if (ctype(c, C_SUBOP1)) {
d878 1
a878 1
	if (ctype(c, C_SUBOP2) ||
@


1.27
log
@fix Coverity CID #8, #9

it's wrong to use strchr(s, 0) to look for the NUL byte, because in some
environments it apparently might return NULL

use new macro strnul = s+strlen(s) instead (not side-effect safe tho)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.26 2007/05/13 17:51:21 tg Exp $");
a714 1
			int max = 0;
d720 1
a720 2
				if (vp->flag & ISSET) {
					max = vp->index + 1;
d722 1
a722 2
				}
			c = n; /* ksh88/ksh93 go for number, not max index */
@


1.26
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.25 2007/03/14 02:41:08 tg Exp $");
d235 1
a235 1
					sp = cstrchr(sp, 0) + 1;
d258 1
a258 1
					sp = cstrchr(sp, 0) + 1;
d894 1
a894 1
	char *end = strchr(str, 0);
@


1.25
log
@• use wdcopy() not str_save() to duplicate an “encoded string”, whatever
• prevent out-of-bounds memory access, cought by glibc malloc on IA-64
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.24 2007/03/04 03:04:24 tg Exp $");
d66 1
a66 1
		internal_errorf(1, "substitute");
d171 1
a171 1
		internal_errorf(1, "expand(NULL)");
d583 1
a583 1
						internal_errorf(1, "unable "
@


1.25.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.25 2007/03/14 02:41:08 tg Exp $");
d66 1
a66 1
		internal_errorf("substitute");
d171 1
a171 1
		internal_errorf("expand(NULL)");
d235 1
a235 1
					sp = strnul(sp) + 1;
d258 1
a258 1
					sp = strnul(sp) + 1;
d583 1
a583 1
						internal_errorf("unable "
d894 1
a894 1
	char *end = strnul(str);
@


1.25.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.25.2.1 2007/05/13 19:29:34 tg Exp $");
d142 1
a143 1
	struct tbl *var;	/* variable for ${var..} */
d715 1
d721 2
a722 1
				if (vp->flag & ISSET)
d724 2
a725 1
			c = n;
@


1.24
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d282 1
a282 1
					end = (beg = str_save(sp, ATEMP)) +
d285 2
a286 1
					*end = EOS;
@


1.23
log
@merge the const branch +- a few
@
text
@d20 1
a20 1
	/* int  type; */	/* see expand() */
d24 1
a24 1
		struct shf *shf;/* file */
d27 1
a27 1
	short	split;		/* split "$@@" / call waitlast $() */
d235 1
a235 1
					sp = strchr(sp, 0) + 1;
d258 1
a258 1
					sp = strchr(sp, 0) + 1;
d276 1
a276 1
				sp = strchr(sp, '\0') + 1; /* skip variable */
d1105 2
a1106 1
	char *d, *s;
d1108 1
a1108 1
	if ((s = strchr(sp, MAGIC))) {
d1114 1
a1114 1
			    !strchr("*+?@@! ", *s & 0x7f))
@


1.22
log
@oops unbreak -DMKSH_NOPWNAM
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.21 2007/01/17 17:42:22 tg Exp $");
d43 2
a44 2
static int varsub(Expand *, char *, char *, int *, int *);
static int comsub(Expand *, char *);
d48 1
a48 1
static char *maybe_expand_tilde(char *, XString *, char **, int);
d76 1
a76 1
eval(char **ap, int f)
d80 6
a85 2
	if (*ap == NULL)
		return ap;
d98 1
a98 1
evalstr(char *cp, int f)
d101 1
d105 1
a105 1
	cp = (XPsize(w) == 0) ? null : (char*) *XPptrv(w);
d107 1
a107 1
	return cp;
d115 1
a115 1
evalonestr(char *cp, int f)
d118 1
d124 1
a124 1
		cp = null;
d127 1
a127 1
		cp = (char*) *XPptrv(w);
d130 1
a130 1
		cp = evalstr(cp, f&~DOGLOB);
d134 1
a134 1
	return cp;
d149 1
a149 1
expand(char *cp,	/* input word */
d157 2
a158 1
	char *dp, *sp;		/* dest., source */
d272 1
a272 1
				char *varname = ++sp; /* skip the { or x (}) */
d279 1
a279 2
					char endc;
					char *str, *end;
d282 2
a283 1
					end = sp + (wdscan(sp, CSUBST) - sp);
a284 1
					endc = *end;
d286 2
a287 2
					str = snptreef(NULL, 64, "%S", sp);
					*end = endc;
d290 1
a290 1
				if (f&DOBLANK)
d648 2
a649 1
						char *p, *dp_x;
d686 1
a686 1
varsub(Expand *xp, char *sp, char *word,
d694 1
a694 1
	char *p;
d711 2
a712 1
		if ((p=strchr(sp,'[')) && (p[1]=='*'||p[1]=='@@') && p[2]==']') {
d783 2
a784 1
		if ((p=strchr(sp,'[')) && (p[1]=='*'||p[1]=='@@') && p[2]==']') {
d839 1
a839 1
comsub(Expand *xp, char *cp)
d1132 2
a1133 2
static char *
maybe_expand_tilde(char *p, XString *dsp, char **dpp, int isassign)
d1137 2
a1138 1
	char *tp, *r;
@


1.21
log
@* add #ifdef MKSH_NOPWNAM to prevent pulling in getpwnam()
* document possible "functionality omission defines" in Build.sh
* sort and sectionise mirtoconf checks; add big comments
@
text
@d5 5
a9 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.20 2007/01/11 00:32:30 tg Exp $");
d50 1
a50 1
#ifndef MKSH_SMALL
a51 2
#else
#define homedir(x) null
d1164 1
a1164 1
	char *dp;
d1172 1
d1175 1
d1182 1
a1182 1
#if !defined(MKSH_SMALL) && !defined(MKSH_NOPWNAM)
@


1.20
log
@expand ~foo to getpwnam("foo")->dir only #if !defined(MKSH_SMALL)
this makes it possible to build a (small) mksh on glibc systems statically
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.19 2006/11/12 14:58:14 tg Exp $");
d1178 1
a1178 1
#ifndef MKSH_SMALL
a1184 1

@


1.20.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 5
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.22 2007/01/17 18:01:51 tg Exp $");

#ifdef MKSH_SMALL
#define MKSH_NOPWNAM
#endif
d46 1
a46 1
#ifndef MKSH_NOPWNAM
d48 2
d1162 1
a1162 1
	char *dp = null;
a1169 1
#ifndef MKSH_NOPWNAM
a1171 1
#endif
d1178 1
a1178 1
#ifndef MKSH_NOPWNAM
d1185 1
@


1.20.2.2
log
@begin constification
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.20.2.1 2007/03/03 21:37:54 tg Exp $");
d43 2
a44 2
static int varsub(Expand *, const char *, const char *, int *, int *);
static int comsub(Expand *, const char *);
d48 1
a48 1
static const char *maybe_expand_tilde(const char *, XString *, char **, int);
d76 1
a76 1
eval(const char **ap, int f)
d80 2
a81 6
	if (*ap == NULL) {
		union mksh_ccphack vap;

		vap.ro = ap;
		return (vap.rw);
	}
d94 1
a94 1
evalstr(const char *cp, int f)
a96 1
	char *dp;
d100 1
a100 1
	dp = (XPsize(w) == 0) ? null : (char*) *XPptrv(w);
d102 1
a102 1
	return (dp);
d110 1
a110 1
evalonestr(const char *cp, int f)
a112 1
	char *rv;
d118 1
a118 1
		rv = null;
d121 1
a121 1
		rv = (char *) *XPptrv(w);
d124 1
a124 1
		rv = evalstr(cp, f&~DOGLOB);
d128 1
a128 1
	return (rv);
d143 1
a143 1
expand(const char *cp,	/* input word */
d151 1
a151 2
	char *dp;		/* destination */
	const char *sp;		/* source */
d265 1
a265 1
				const char *varname = ++sp; /* skip the { or x (}) */
d272 2
a273 1
					char *beg, *end, *str;
d276 1
a276 2
					end = (beg = str_save(sp, ATEMP)) +
					    (wdscan(sp, CSUBST) - sp);
d278 1
d280 2
a281 2
					str = snptreef(NULL, 64, "%S", beg);
					afree(beg, ATEMP);
d284 1
a284 1
				if (f & DOBLANK)
d642 1
a642 2
						const char *p;
						char *dp_x;
d679 1
a679 1
varsub(Expand *xp, const char *sp, const char *word,
d687 1
a687 1
	const char *p;
d704 1
a704 2
		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
		    p[2] == ']') {
d775 1
a775 2
		if ((p = cstrchr(sp, '[')) && (p[1] == '*' || p[1] == '@@') &&
		    p[2] == ']') {
d830 1
a830 1
comsub(Expand *xp, const char *cp)
d1123 2
a1124 2
static const char *
maybe_expand_tilde(const char *p, XString *dsp, char **dpp, int isassign)
d1128 1
a1128 2
	char *tp;
	const char *r;
@


1.19
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.18 2006/11/10 07:52:02 tg Exp $");
d46 1
d48 3
d1178 1
d1203 1
@


1.18
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.17 2006/11/10 06:40:05 tg Exp $");
d270 1
a270 1
					end = (char *) wdscan(sp, CSUBST);
d348 1
a348 1
					sp = (char *) wdscan(sp, CSUBST);
@


1.17
log
@kill two others, saves 55t 8d 2i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.16 2006/11/10 03:23:49 tg Exp $");
d800 1
a800 1
			    (ctype(*sp, C_VAR1) || digit(*sp)))
@


1.16
log
@use qsort(3) instead of rolling our own
saves 284 in .text, no added import since we already use qsort(3) once
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.15 2006/11/10 00:09:27 tg Exp $");
d568 2
a569 1
					if ((p = strdup("")) == NULL)
@


1.15
log
@save 176 text (92 text 32 bss relative to before last commit)
by making correct use of shf_* functions
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.14 2006/11/09 23:55:51 tg Exp $");
d932 2
a933 2
		qsortp(XPptrv(*wp) + oldsize, (size_t)(XPsize(*wp) - oldsize),
			xstrcmp);
@


1.14
log
@get rid of ulton() - a joke
saves 32 bss, but adds 84 text oO
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.13 2006/08/01 13:43:26 tg Exp $");
d720 1
a720 6
		{
			char tmpbuf[11];

			shf_snprintf(tmpbuf, 11, "%lu", (unsigned long)c);
			xp->str = str_save(tmpbuf, ATEMP);
		}
@


1.13
log
@style(9)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.12 2006/05/10 18:54:09 tg Exp $");
d720 6
a725 1
		xp->str = str_save(ulton((unsigned long)c, 10), ATEMP);
@


1.12
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.11 2006/05/08 11:07:38 tg Exp $");
d1077 2
a1078 1
	  Nodir:;
@


1.11
log
@un-tabulate function declaration (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.10 2006/01/29 20:04:50 tg Exp $");
d855 1
a855 1
		ofd1 = savefd(1, 0);	/* fd 1 may be closed... */
@


1.10
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.9 2005/11/22 18:40:41 tg Exp $");
d39 9
a47 9
static	int	varsub(Expand *, char *, char *, int *, int *);
static	int	comsub(Expand *, char *);
static	char   *trimsub(char *, char *, int);
static	void	glob(char *, XPtrV *, int);
static	void	globit(XString *, char **, char *, XPtrV *, int);
static char	*maybe_expand_tilde(char *, XString *, char **, int);
static	char   *tilde(char *);
static	char   *homedir(char *);
static void	alt_expand(XPtrV *, char *, char *, char *, int);
@


1.9
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: eval.c,v 1.27 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.8 2005/10/25 19:53:27 tg Exp $");
d1184 1
a1184 1
	ap = tenter(&homedirs, name, hash(name));
@


1.8
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.7 2005/07/12 13:30:38 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.7 2005/07/12 13:30:38 tg Exp $");
@


1.7
log
@please ISO C99
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.5 2005/07/04 12:27:25 tg Exp $ */
a4 3
#include <sys/stat.h>
#include <dirent.h>
#include <pwd.h>
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.5 2005/07/04 12:27:25 tg Exp $");
@


1.6
log
@gcc 4.0 with -O2 -Wall thinks it finds these uninitialised variables,
so quieten gcc

found by Bastian "waldi" Blank
@
text
@d152 3
a154 1
	Expand x = {};		/* expansion variables */
@


1.5
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.4 2005/06/08 22:34:03 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.4 2005/06/08 22:34:03 tg Exp $");
d152 1
a152 1
	Expand x;		/* expansion variables */
d263 1
a263 1
				int slen;
@


1.4
log
@some lint cleanup
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.3 2005/05/25 10:01:24 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.3 2005/05/25 10:01:24 tg Exp $");
d616 3
a618 2
					if (!(f & DOTEMP_) && (!Flag(FPOSIX)
					    || (f & DOASNTILDE)) && !saw_eq) {
@


1.3
log
@Disable tilde expansion after = (Debian PR #187839),
but only in POSIX mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.2 2005/05/23 15:18:15 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.2 2005/05/23 15:18:15 tg Exp $");
d342 1
a342 1
						/* fall through */
@


1.2
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/eval.c,v 1.1 2005/05/23 03:06:06 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.1 2005/05/23 03:06:06 tg Exp $");
d616 2
a617 1
					if (!(f & DOTEMP_) && !saw_eq) {
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/eval.c,v 1.9 2005/05/23 02:20:35 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: mksh/eval.c,v 1.9 2005/05/23 02:20:35 tg Exp $");
d884 1
a884 1
			if (gmatch(str, pat, false)) {
d894 1
a894 1
			if (gmatch(str, pat, false)) {
d903 1
a903 1
			if (gmatch(p, pat, false))
d909 1
a909 1
			if (gmatch(p, pat, false))
d1064 1
a1064 1
			    !gmatch(name, sp, true))
@

