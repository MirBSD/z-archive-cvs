head	1.97;
access;
symbols
	mksh-R57:1.97
	mksh-R56c:1.95
	mksh-R56b:1.93
	mksh-R56:1.93
	mksh-R55:1.89
	mksh-R54:1.86
	mksh-R53a:1.86
	mksh-R53:1.86
	mksh-R52c:1.83
	mksh-R52b:1.80
	mksh-R52:1.79
	mksh-R51:1.73
	mksh-R50f:1.72.2.1
	mksh-R50e:1.72
	mksh-R50stable:1.72.0.2
	mksh-R50d:1.72
	mksh-R50c:1.72
	mksh-R50b:1.72
	mksh-R50:1.72
	mksh-R49:1.72
	mksh-R48b:1.71
	mksh-R48:1.71
	mksh-R47:1.70
	mksh-R46:1.69
	mksh-R45:1.68
	mksh-R44:1.67
	mksh-R43:1.67
	mksh-R42b:1.67
	mksh-R41c:1.65.2.1
	mksh-R41b:1.65.2.1
	mksh-R42:1.67
	mksh-R41:1.65
	mksh-R41stable:1.65.0.2
	mksh-wheezy:1.61.0.2
	tg-multikey-bind:1.59.0.2
	mksh-R40f:1.52.4.3
	mksh-R40e:1.52.4.3
	mksh-R40d:1.52
	mksh-R40c:1.52
	mksh-R40b:1.49
	mksh-R40stable:1.52.0.4
	mksh-R40:1.49
	mksh-R39c:1.30
	mksh-R39b:1.29
	tg-wcswidth-behaviour:1.28.0.6
	tg-nameref:1.28.0.4
	mksh-R39:1.28
	tg-mksh-printf-builtin:1.28.0.2
	mksh-R38c:1.28
	mksh-R38b:1.26
	mksh-R38:1.26
	mksh-R37c:1.25
	mksh-R37b:1.24
	mksh-R37:1.24
	mksh-R36b:1.24
	tg-aalloc-experimental_BASE:1.23
	tg-aalloc-experimental:1.23.0.2
	mksh-R36:1.20
	mksh-R35b:1.18
	mksh-R35:1.18
	mksh-R33d:1.15
	mksh-R33c:1.15
	mksh-R33b:1.15
	MIRBSD_10:1.15.0.2
	MIRBSD_10_BASE:1.15
	mksh-R33:1.15
	mksh-R32:1.12
	mksh-R31d:1.11
	mksh-R31c:1.11
	mksh-R31b:1.11
	mksh-R31:1.11
	mksh-R30:1.11
	mksh-R29g:1.9.2.1
	mksh-R29f:1.9.2.1
	mksh-R29e:1.9.2.1
	mksh-R29stable:1.9.0.2
	mksh-R29d:1.9
	mksh-R29c:1.9
	mksh-R29b:1.9
	mksh-R29:1.9
	mksh-R28:1.4
	tg-mksh-plan9ape_BASE:1.4
	tg-mksh-plan9ape:1.4.0.2
	mksh-R27e:1.4
	MIRBSD_9_BASE:1.4
	mksh-R27d:1.4
	mksh-R27:1.4
	mksh-R26c:1.3
	mksh-R26b:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	mksh-R26:1.3
	mksh-R25:1.2
	mksh-R24c:1.2
	mksh-R24b:1.2
	mksh-R24:1.2
	mksh-R23:1.2
	mksh-R22:1.1
	mksh-R21:1.1;
locks; strict;
comment	@ * @;


1.97
date	2018.10.20.18.46.00;	author tg;	state Exp;
branches;
next	1.96;
commitid	1005BCB77EB7119802C;

1.96
date	2018.08.10.02.53.39;	author tg;	state Exp;
branches;
next	1.95;
commitid	1005B6CFE0B5BDFE404;

1.95
date	2018.01.14.00.03.05;	author tg;	state Exp;
branches;
next	1.94;
commitid	1005A5A9E3D208A81CB;

1.94
date	2018.01.13.23.55.14;	author tg;	state Exp;
branches;
next	1.93;
commitid	1005A5A9C627E45C2B1;

1.93
date	2017.05.05.22.53.32;	author tg;	state Exp;
branches;
next	1.92;
commitid	100590D026845CD3DFF;

1.92
date	2017.05.05.20.36.03;	author tg;	state Exp;
branches;
next	1.91;
commitid	100590CE24264B3D492;

1.91
date	2017.04.28.03.28.19;	author tg;	state Exp;
branches;
next	1.90;
commitid	1005902B6DC3ECE3910;

1.90
date	2017.04.28.00.38.33;	author tg;	state Exp;
branches;
next	1.89;
commitid	10059028F0E0808B3E9;

1.89
date	2017.04.12.16.46.23;	author tg;	state Exp;
branches;
next	1.88;
commitid	10058EE59ED44DAA3D5;

1.88
date	2017.04.11.12.34.04;	author tg;	state Exp;
branches;
next	1.87;
commitid	10058ECCD3F0D749F4C;

1.87
date	2017.04.06.01.59.58;	author tg;	state Exp;
branches;
next	1.86;
commitid	10058E5A1067AFA1BBA;

1.86
date	2016.07.25.00.04.48;	author tg;	state Exp;
branches;
next	1.85;
commitid	1005795579F14A3FE5C;

1.85
date	2016.06.26.00.09.35;	author tg;	state Exp;
branches;
next	1.84;
commitid	100576F1D4100EFF065;

1.84
date	2016.06.26.00.07.31;	author tg;	state Exp;
branches;
next	1.83;
commitid	100576F1CD52EC29A00;

1.83
date	2016.03.04.14.26.16;	author tg;	state Exp;
branches;
next	1.82;
commitid	10056D99B037D4D691D;

1.82
date	2016.02.26.17.58.30;	author tg;	state Exp;
branches;
next	1.81;
commitid	10056D0925F736B5B88;

1.81
date	2016.01.21.18.24.45;	author tg;	state Exp;
branches;
next	1.80;
commitid	10056A12268001BF859;

1.80
date	2016.01.14.22.30.43;	author tg;	state Exp;
branches;
next	1.79;
commitid	1005698219A4D72938C;

1.79
date	2015.12.12.19.08.58;	author tg;	state Exp;
branches;
next	1.78;
commitid	100566C70DA3AC32585;

1.78
date	2015.10.09.19.29.50;	author tg;	state Exp;
branches;
next	1.77;
commitid	100561815B853CF84EB;

1.77
date	2015.09.06.19.47.01;	author tg;	state Exp;
branches;
next	1.76;
commitid	10055EC98215F2B5F9C;

1.76
date	2015.09.05.20.20.48;	author tg;	state Exp;
branches;
next	1.75;
commitid	10055EB4EA5242ECCAA;

1.75
date	2015.09.05.19.19.11;	author tg;	state Exp;
branches;
next	1.74;
commitid	10055EB402C54C3076B;

1.74
date	2015.08.13.20.54.03;	author tg;	state Exp;
branches;
next	1.73;
commitid	10055CD03EA5D08D912;

1.73
date	2015.04.11.22.03.32;	author tg;	state Exp;
branches;
next	1.72;
commitid	1005529999F77F915AE;

1.72
date	2013.09.24.20.19.45;	author tg;	state Exp;
branches
	1.72.2.1;
next	1.71;
commitid	1005241F37044BDFFC4;

1.71
date	2013.07.26.20.33.24;	author tg;	state Exp;
branches;
next	1.70;
commitid	10051F2DD2B49D415C3;

1.70
date	2013.07.21.18.39.21;	author tg;	state Exp;
branches;
next	1.69;
commitid	10051EC2AF13B369021;

1.69
date	2013.05.02.21.59.54;	author tg;	state Exp;
branches;
next	1.68;
commitid	1005182E1E55272FF6B;

1.68
date	2013.03.24.00.56.27;	author tg;	state Exp;
branches;
next	1.67;
commitid	100514E4F1D5C90862C;

1.67
date	2012.12.04.01.10.35;	author tg;	state Exp;
branches;
next	1.66;
commitid	10050BD4DA30C3ED2E7;

1.66
date	2012.11.30.20.19.16;	author tg;	state Exp;
branches;
next	1.65;
commitid	10050B914D41435E735;

1.65
date	2012.10.22.20.19.18;	author tg;	state Exp;
branches
	1.65.2.1;
next	1.64;
commitid	1005085AA537A17A752;

1.64
date	2012.08.17.18.34.25;	author tg;	state Exp;
branches;
next	1.63;
commitid	100502E8EAA4BFCF410;

1.63
date	2012.07.30.21.37.17;	author tg;	state Exp;
branches;
next	1.62;
commitid	1005016FE9B27F9F4DC;

1.62
date	2012.07.30.19.58.05;	author tg;	state Exp;
branches;
next	1.61;
commitid	1005016E7627EF7B61F;

1.61
date	2012.06.28.20.17.39;	author tg;	state Exp;
branches
	1.61.2.1;
next	1.60;
commitid	1004FECBBF10FC5C93C;

1.60
date	2012.06.28.20.01.01;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004FECB81305B1E36F;

1.59
date	2012.05.04.18.45.03;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004FA423C77CA2CF39;

1.58
date	2012.04.07.11.19.30;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004F8022DA317E896F;

1.57
date	2012.03.23.20.07.13;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004F6CD8052D2FFA5E;

1.56
date	2012.02.06.17.42.24;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004F3010EC139BAB7F;

1.55
date	2011.12.31.00.27.27;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004EFE570218254BB1;

1.54
date	2011.12.29.23.36.25;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004EFCF98C06684CE3;

1.53
date	2011.12.29.22.54.22;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004EFCEFA861A142CF;

1.52
date	2011.10.25.22.36.39;	author tg;	state Exp;
branches
	1.52.4.1;
next	1.51;
commitid	1004EA73A0B4E5C1903;

1.51
date	2011.09.07.15.24.21;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004E678C6929FE60A6;

1.50
date	2011.08.27.18.06.51;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004E5932432420AA61;

1.49
date	2011.05.29.02.18.57;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004DE1AD11046BEFFC;

1.48
date	2011.05.07.00.24.35;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004DC49155257CCEE0;

1.47
date	2011.05.05.00.05.01;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004DC1E8D640072140;

1.46
date	2011.05.04.22.38.27;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004DC1D57B51FE2773;

1.45
date	2011.05.02.22.52.54;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004DBF35D72295ADB7;

1.44
date	2011.04.22.12.15.42;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004DB17167553347A9;

1.43
date	2011.04.09.15.14.55;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004DA077823393B1E0;

1.42
date	2011.04.09.15.05.44;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004DA075CC45538EFC;

1.41
date	2011.03.17.21.58.40;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004D828425404E9610;

1.40
date	2011.03.13.01.20.24;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004D7C1BE368F5B459;

1.39
date	2011.03.12.23.04.48;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004D7BFC0825FC39FC;

1.38
date	2011.03.12.21.41.15;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004D7BE79D2481A518;

1.37
date	2011.03.08.18.49.51;	author tg;	state Exp;
branches;
next	1.36;
commitid	1004D767A1867ED392F;

1.36
date	2011.03.06.17.08.14;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004D73BF8011CAE269;

1.35
date	2011.03.06.02.28.59;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004D72F18229073F98;

1.34
date	2011.03.06.02.14.09;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004D72EDE52B611B92;

1.33
date	2011.03.06.00.52.02;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004D72DAC96A27B620;

1.32
date	2010.09.14.21.26.19;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004C8FE654576B0E25;

1.31
date	2010.08.28.20.22.24;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004C796FE40C544CCE;

1.30
date	2010.02.25.20.18.19;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004B86DB1A7C6BCE8B;

1.29
date	2010.01.29.09.34.31;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004B62ABB7333ED94C;

1.28
date	2009.06.10.18.12.50;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004A2FF7913BD44883;

1.27
date	2009.06.08.20.06.49;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004A2D6F3A31FB4CBC;

1.26
date	2009.05.16.16.59.41;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004A0EF0664EF4168D;

1.25
date	2009.04.07.19.13.11;	author tg;	state Exp;
branches;
next	1.24;
commitid	10049DBA5DA72EF04C6;

1.24
date	2008.12.13.17.02.17;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004943EAA830C0300B;

1.23
date	2008.11.12.00.54.51;	author tg;	state Exp;
branches
	1.23.2.1;
next	1.22;
commitid	100491A295841A6D8EB;

1.22
date	2008.11.11.23.50.31;	author tg;	state Exp;
branches;
next	1.21;
commitid	100491A1A3D7C6B56F1;

1.21
date	2008.10.28.14.32.43;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004907226D3DEFCCD1;

1.20
date	2008.10.13.23.06.04;	author tg;	state Exp;
branches;
next	1.19;
commitid	10048F3D44866CCA1C2;

1.19
date	2008.09.14.20.29.13;	author tg;	state Exp;
branches;
next	1.18;
commitid	10048CD741E74FB91E4;

1.18
date	2008.07.09.21.32.45;	author tg;	state Exp;
branches;
next	1.17;
commitid	10048752E6271CABA24;

1.17
date	2008.05.17.18.47.02;	author tg;	state Exp;
branches;
next	1.16;
commitid	100482F280E7B53AA4C;

1.16
date	2008.04.19.22.15.06;	author tg;	state Exp;
branches;
next	1.15;
commitid	100480A6CC85EC0197B;

1.15
date	2008.03.01.21.10.26;	author tg;	state Exp;
branches
	1.15.2.1;
next	1.14;
commitid	10047C9C64165F71A5A;

1.14
date	2008.02.26.21.08.33;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047C47FDA7C07C90D;

1.13
date	2008.02.26.20.43.11;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047C479E866D4A3E1;

1.12
date	2007.10.25.15.19.16;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004720B40258F7886E;

1.11
date	2007.07.06.01.53.36;	author tg;	state Exp;
branches;
next	1.10;
commitid	100468DA0A207B760AD;

1.10
date	2007.05.13.17.51.24;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046474FB1292DF336;

1.9
date	2007.03.04.03.04.28;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10045EA374B3374AB35;

1.8
date	2007.03.04.00.13.17;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045EA0F2F6674C8B9;

1.7
date	2006.11.12.14.58.16;	author tg;	state Exp;
branches
	1.7.2.1;
next	1.6;
commitid	100455735A7145E26AA;

1.6
date	2006.11.10.00.09.27;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004553C325737853C1;

1.5
date	2006.11.09.23.55.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004553BFD0613CC553;

1.4
date	2006.05.10.18.54.13;	author tg;	state Exp;
branches;
next	1.3;
commitid	100446236E6726083C8;

1.3
date	2005.11.22.18.40.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	108a438366254326;

1.2
date	2005.06.08.22.34.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	775142a7726c13a2;

1.1
date	2005.05.23.03.06.10;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.72.2.1
date	2015.04.12.22.32.35;	author tg;	state Exp;
branches;
next	;
commitid	100552AF26A429AA816;

1.65.2.1
date	2012.12.04.01.26.35;	author tg;	state Exp;
branches;
next	;
commitid	10050BD5149729CD584;

1.61.2.1
date	2012.09.03.19.11.15;	author tg;	state Exp;
branches;
next	;
commitid	100504500E6588900BA;

1.52.4.1
date	2011.12.31.02.25.35;	author tg;	state Exp;
branches;
next	1.52.4.2;
commitid	1004EFE72A268DB0925;

1.52.4.2
date	2012.02.11.15.25.36;	author tg;	state Exp;
branches;
next	1.52.4.3;
commitid	1004F36887A2CA1070B;

1.52.4.3
date	2012.03.24.21.22.45;	author tg;	state Exp;
branches;
next	;
commitid	1004F6E3A967ACCD93A;

1.23.2.1
date	2008.11.22.13.20.37;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.15.2.1
date	2008.05.19.18.41.32;	author tg;	state Exp;
branches;
next	1.15.2.2;
commitid	1004831C9A63DA06745;

1.15.2.2
date	2008.07.11.11.49.32;	author tg;	state Exp;
branches;
next	1.15.2.3;
commitid	100487748D62394D033;

1.15.2.3
date	2008.12.14.00.07.51;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.9.2.1
date	2007.05.13.19.29.40;	author tg;	state Exp;
branches;
next	;
commitid	1004647668D4636830B;

1.7.2.1
date	2007.03.03.23.59.39;	author tg;	state Exp;
branches;
next	;
commitid	10045EA0C01765C8871;


desc
@@


1.97
log
@fixup high-bit7 chars to be dumped (XXX probably want M- there)
@
text
@/*	$OpenBSD: tree.c,v 1.21 2015/09/01 13:12:31 tedu Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2015, 2016, 2017
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.95 2018/01/14 00:03:05 tg Exp $");

#define INDENT	8

static void ptree(struct op *, int, struct shf *);
static void pioact(struct shf *, struct ioword *);
static const char *wdvarput(struct shf *, const char *, int, int);
static void vfptreef(struct shf *, int, const char *, va_list);
static struct ioword **iocopy(struct ioword **, Area *);
static void iofree(struct ioword **, Area *);

/* "foo& ; bar" and "foo |& ; bar" are invalid */
static bool prevent_semicolon;

static const char Telif_pT[] = "elif %T";

/*
 * print a command tree
 */
static void
ptree(struct op *t, int indent, struct shf *shf)
{
	const char **w;
	struct ioword **ioact;
	struct op *t1;
	int i;
	const char *ccp;

 Chain:
	if (t == NULL)
		return;
	switch (t->type) {
	case TCOM:
		prevent_semicolon = false;
		/* special-case 'var=<<EOF' (cf. exec.c:execute) */
		if (t->args &&
		    /* we have zero arguments, i.e. no program to run */
		    t->args[0] == NULL &&
		    /* we have exactly one variable assignment */
		    t->vars[0] != NULL && t->vars[1] == NULL &&
		    /* we have exactly one I/O redirection */
		    t->ioact != NULL && t->ioact[0] != NULL &&
		    t->ioact[1] == NULL &&
		    /* of type "here document" (or "here string") */
		    (t->ioact[0]->ioflag & IOTYPE) == IOHERE &&
		    /* the variable assignment begins with a valid varname */
		    (ccp = skip_wdvarname(t->vars[0], true)) != t->vars[0] &&
		    /* and has no right-hand side (i.e. "varname=") */
		    ccp[0] == CHAR && ((ccp[1] == '=' && ccp[2] == EOS) ||
		    /* or "varname+=" */ (ccp[1] == '+' && ccp[2] == CHAR &&
		    ccp[3] == '=' && ccp[4] == EOS))) {
			fptreef(shf, indent, Tf_S, t->vars[0]);
			break;
		}

		if (t->vars) {
			w = (const char **)t->vars;
			while (*w)
				fptreef(shf, indent, Tf_S_, *w++);
		} else
			shf_puts("#no-vars# ", shf);
		if (t->args) {
			w = t->args;
			if (*w && **w == CHAR) {
				char *cp = wdstrip(*w++, WDS_TPUTS);

				if (valid_alias_name(cp))
					shf_putc('\\', shf);
				shf_puts(cp, shf);
				shf_putc(' ', shf);
				afree(cp, ATEMP);
			}
			while (*w)
				fptreef(shf, indent, Tf_S_, *w++);
		} else
			shf_puts("#no-args# ", shf);
		break;
	case TEXEC:
		t = t->left;
		goto Chain;
	case TPAREN:
		fptreef(shf, indent + 2, "( %T) ", t->left);
		break;
	case TPIPE:
		fptreef(shf, indent, "%T| ", t->left);
		t = t->right;
		goto Chain;
	case TLIST:
		fptreef(shf, indent, "%T%;", t->left);
		t = t->right;
		goto Chain;
	case TOR:
	case TAND:
		fptreef(shf, indent, "%T%s %T",
		    t->left, (t->type == TOR) ? "||" : "&&", t->right);
		break;
	case TBANG:
		shf_puts("! ", shf);
		prevent_semicolon = false;
		t = t->right;
		goto Chain;
	case TDBRACKET:
		w = t->args;
		shf_puts("[[", shf);
		while (*w)
			fptreef(shf, indent, Tf__S, *w++);
		shf_puts(" ]] ", shf);
		break;
	case TSELECT:
	case TFOR:
		fptreef(shf, indent, "%s %s ",
		    (t->type == TFOR) ? "for" : Tselect, t->str);
		if (t->vars != NULL) {
			shf_puts("in ", shf);
			w = (const char **)t->vars;
			while (*w)
				fptreef(shf, indent, Tf_S_, *w++);
			fptreef(shf, indent, Tft_end);
		}
		fptreef(shf, indent + INDENT, "do%N%T", t->left);
		fptreef(shf, indent, "%;done ");
		break;
	case TCASE:
		fptreef(shf, indent, "case %S in", t->str);
		for (t1 = t->left; t1 != NULL; t1 = t1->right) {
			fptreef(shf, indent, "%N(");
			w = (const char **)t1->vars;
			while (*w) {
				fptreef(shf, indent, "%S%c", *w,
				    (w[1] != NULL) ? '|' : ')');
				++w;
			}
			fptreef(shf, indent + INDENT, "%N%T%N;%c", t1->left,
			    t1->u.charflag);
		}
		fptreef(shf, indent, "%Nesac ");
		break;
	case TELIF:
		internal_errorf(TELIF_unexpected);
		/* FALLTHROUGH */
	case TIF:
		i = 2;
		t1 = t;
		goto process_TIF;
		do {
			t1 = t1->right;
			i = 0;
			fptreef(shf, indent, Tft_end);
 process_TIF:
			/* 5 == strlen("elif ") */
			fptreef(shf, indent + 5 - i, Telif_pT + i, t1->left);
			t1 = t1->right;
			if (t1->left != NULL) {
				fptreef(shf, indent, Tft_end);
				fptreef(shf, indent + INDENT, "%s%N%T",
				    "then", t1->left);
			}
		} while (t1->right && t1->right->type == TELIF);
		if (t1->right != NULL) {
			fptreef(shf, indent, Tft_end);
			fptreef(shf, indent + INDENT, "%s%N%T",
			    "else", t1->right);
		}
		fptreef(shf, indent, "%;fi ");
		break;
	case TWHILE:
	case TUNTIL:
		/* 6 == strlen("while "/"until ") */
		fptreef(shf, indent + 6, Tf_s_T,
		    (t->type == TWHILE) ? "while" : "until",
		    t->left);
		fptreef(shf, indent, Tft_end);
		fptreef(shf, indent + INDENT, "do%N%T", t->right);
		fptreef(shf, indent, "%;done ");
		break;
	case TBRACE:
		fptreef(shf, indent + INDENT, "{%N%T", t->left);
		fptreef(shf, indent, "%;} ");
		break;
	case TCOPROC:
		fptreef(shf, indent, "%T|& ", t->left);
		prevent_semicolon = true;
		break;
	case TASYNC:
		fptreef(shf, indent, "%T& ", t->left);
		prevent_semicolon = true;
		break;
	case TFUNCT:
		fpFUNCTf(shf, indent, tobool(t->u.ksh_func), t->str, t->left);
		break;
	case TTIME:
		fptreef(shf, indent, Tf_s_T, Ttime, t->left);
		break;
	default:
		shf_puts("<botch>", shf);
		prevent_semicolon = false;
		break;
	}
	if ((ioact = t->ioact) != NULL) {
		bool need_nl = false;

		while (*ioact != NULL)
			pioact(shf, *ioact++);
		/* Print here documents after everything else... */
		ioact = t->ioact;
		while (*ioact != NULL) {
			struct ioword *iop = *ioact++;

			/* heredoc is NULL when tracing (set -x) */
			if ((iop->ioflag & (IOTYPE | IOHERESTR)) == IOHERE &&
			    iop->heredoc) {
				shf_putc('\n', shf);
				shf_puts(iop->heredoc, shf);
				fptreef(shf, indent, Tf_s,
				    evalstr(iop->delim, 0));
				need_nl = true;
			}
		}
		/*
		 * Last delimiter must be followed by a newline (this
		 * often leads to an extra blank line, but it's not
		 * worth worrying about)
		 */
		if (need_nl) {
			shf_putc('\n', shf);
			prevent_semicolon = true;
		}
	}
}

static void
pioact(struct shf *shf, struct ioword *iop)
{
	unsigned short flag = iop->ioflag;
	unsigned short type = flag & IOTYPE;
	short expected;

	expected = (type == IOREAD || type == IORDWR || type == IOHERE) ? 0 :
	    (type == IOCAT || type == IOWRITE) ? 1 :
	    (type == IODUP && (iop->unit == !(flag & IORDUP))) ? iop->unit :
	    iop->unit + 1;
	if (iop->unit != expected)
		shf_fprintf(shf, Tf_d, (int)iop->unit);

	switch (type) {
	case IOREAD:
		shf_putc('<', shf);
		break;
	case IOHERE:
		shf_puts("<<", shf);
		if (flag & IOSKIP)
			shf_putc('-', shf);
		else if (flag & IOHERESTR)
			shf_putc('<', shf);
		break;
	case IOCAT:
		shf_puts(">>", shf);
		break;
	case IOWRITE:
		shf_putc('>', shf);
		if (flag & IOCLOB)
			shf_putc('|', shf);
		break;
	case IORDWR:
		shf_puts("<>", shf);
		break;
	case IODUP:
		shf_puts(flag & IORDUP ? "<&" : ">&", shf);
		break;
	}
	/* name/delim are NULL when printing syntax errors */
	if (type == IOHERE) {
		if (iop->delim && !(iop->ioflag & IONDELIM))
			wdvarput(shf, iop->delim, 0, WDS_TPUTS);
	} else if (iop->ioname) {
		if (flag & IONAMEXP)
			print_value_quoted(shf, iop->ioname);
		else
			wdvarput(shf, iop->ioname, 0, WDS_TPUTS);
	}
	shf_putc(' ', shf);
	prevent_semicolon = false;
}

/* variant of fputs for ptreef and wdstrip */
static const char *
wdvarput(struct shf *shf, const char *wp, int quotelevel, int opmode)
{
	int c;
	const char *cs;

	/*-
	 * problems:
	 *	`...` -> $(...)
	 *	'foo' -> "foo"
	 *	x${foo:-"hi"} -> x${foo:-hi} unless WDS_TPUTS
	 *	x${foo:-'hi'} -> x${foo:-hi}
	 * could change encoding to:
	 *	OQUOTE ["'] ... CQUOTE ["']
	 *	COMSUB [(`] ...\0	(handle $ ` \ and maybe " in `...` case)
	 */
	while (/* CONSTCOND */ 1)
		switch (*wp++) {
		case EOS:
			return (--wp);
		case ADELIM:
			if (ord(*wp) == ORD(/*{*/ '}')) {
				++wp;
				goto wdvarput_csubst;
			}
			/* FALLTHROUGH */
		case CHAR:
			c = ord(*wp++);
			shf_putc(c, shf);
			break;
		case QCHAR:
			c = ord(*wp++);
			if (opmode & WDS_TPUTS)
				switch (c) {
				case ORD('\n'):
					if (quotelevel == 0) {
						c = ORD('\'');
						shf_putc(c, shf);
						shf_putc(ORD('\n'), shf);
					}
					break;
				default:
					if (quotelevel == 0)
						/* FALLTHROUGH */
				case ORD('"'):
				case ORD('`'):
				case ORD('$'):
				case ORD('\\'):
					  shf_putc(ORD('\\'), shf);
					break;
				}
			shf_putc(c, shf);
			break;
		case COMASUB:
		case COMSUB:
			shf_puts("$(", shf);
			cs = ")";
			if (ord(*wp) == ORD('(' /*)*/))
				shf_putc(' ', shf);
 pSUB:
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
			shf_puts(cs, shf);
			break;
		case FUNASUB:
		case FUNSUB:
			c = ORD(' ');
			if (0)
				/* FALLTHROUGH */
		case VALSUB:
			  c = ORD('|');
			shf_putc('$', shf);
			shf_putc('{', shf);
			shf_putc(c, shf);
			cs = ";}";
			goto pSUB;
		case EXPRSUB:
			shf_puts("$((", shf);
			cs = "))";
			goto pSUB;
		case OQUOTE:
			if (opmode & WDS_TPUTS) {
				quotelevel++;
				shf_putc('"', shf);
			}
			break;
		case CQUOTE:
			if (opmode & WDS_TPUTS) {
				if (quotelevel)
					quotelevel--;
				shf_putc('"', shf);
			}
			break;
		case OSUBST:
			shf_putc('$', shf);
			if (ord(*wp++) == ORD('{'))
				shf_putc('{', shf);
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
			wp = wdvarput(shf, wp, 0, opmode);
			break;
		case CSUBST:
			if (ord(*wp++) == ORD('}')) {
 wdvarput_csubst:
				shf_putc('}', shf);
			}
			return (wp);
		case OPAT:
			shf_putchar(*wp++, shf);
			shf_putc('(', shf);
			break;
		case SPAT:
			c = ORD('|');
			if (0)
				/* FALLTHROUGH */
		case CPAT:
			  c = ORD(/*(*/ ')');
			shf_putc(c, shf);
			break;
		}
}

/*
 * this is the _only_ way to reliably handle
 * variable args with an ANSI compiler
 */
/* VARARGS */
void
fptreef(struct shf *shf, int indent, const char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	vfptreef(shf, indent, fmt, va);
	va_end(va);
}

/* VARARGS */
char *
snptreef(char *s, ssize_t n, const char *fmt, ...)
{
	va_list va;
	struct shf shf;

	shf_sopen(s, n, SHF_WR | (s ? 0 : SHF_DYNAMIC), &shf);

	va_start(va, fmt);
	vfptreef(&shf, 0, fmt, va);
	va_end(va);

	/* shf_sclose NUL terminates */
	return (shf_sclose(&shf));
}

static void
vfptreef(struct shf *shf, int indent, const char *fmt, va_list va)
{
	int c;

	while ((c = ord(*fmt++))) {
		if (c == '%') {
			switch ((c = ord(*fmt++))) {
			case ORD('c'):
				/* character (octet, probably) */
				shf_putchar(va_arg(va, int), shf);
				break;
			case ORD('s'):
				/* string */
				shf_puts(va_arg(va, char *), shf);
				break;
			case ORD('S'):
				/* word */
				wdvarput(shf, va_arg(va, char *), 0, WDS_TPUTS);
				break;
			case ORD('d'):
				/* signed decimal */
				shf_fprintf(shf, Tf_d, va_arg(va, int));
				break;
			case ORD('u'):
				/* unsigned decimal */
				shf_fprintf(shf, "%u", va_arg(va, unsigned int));
				break;
			case ORD('T'):
				/* format tree */
				ptree(va_arg(va, struct op *), indent, shf);
				goto dont_trash_prevent_semicolon;
			case ORD(';'):
				/* newline or ; */
			case ORD('N'):
				/* newline or space */
				if (shf->flags & SHF_STRING) {
					if ((unsigned int)c == ORD(';') &&
					    !prevent_semicolon)
						shf_putc(';', shf);
					shf_putc(' ', shf);
				} else {
					int i;

					shf_putc('\n', shf);
					i = indent;
					while (i >= 8) {
						shf_putc('\t', shf);
						i -= 8;
					}
					while (i--)
						shf_putc(' ', shf);
				}
				break;
			case ORD('R'):
				/* I/O redirection */
				pioact(shf, va_arg(va, struct ioword *));
				break;
			default:
				shf_putc(c, shf);
				break;
			}
		} else
			shf_putc(c, shf);
		prevent_semicolon = false;
 dont_trash_prevent_semicolon:
		;
	}
}

/*
 * copy tree (for function definition)
 */
struct op *
tcopy(struct op *t, Area *ap)
{
	struct op *r;
	const char **tw;
	char **rw;

	if (t == NULL)
		return (NULL);

	r = alloc(sizeof(struct op), ap);

	r->type = t->type;
	r->u.evalflags = t->u.evalflags;

	if (t->type == TCASE)
		r->str = wdcopy(t->str, ap);
	else
		strdupx(r->str, t->str, ap);

	if (t->vars == NULL)
		r->vars = NULL;
	else {
		tw = (const char **)t->vars;
		while (*tw)
			++tw;
		rw = r->vars = alloc2(tw - (const char **)t->vars + 1,
		    sizeof(*tw), ap);
		tw = (const char **)t->vars;
		while (*tw)
			*rw++ = wdcopy(*tw++, ap);
		*rw = NULL;
	}

	if (t->args == NULL)
		r->args = NULL;
	else {
		tw = t->args;
		while (*tw)
			++tw;
		r->args = (const char **)(rw = alloc2(tw - t->args + 1,
		    sizeof(*tw), ap));
		tw = t->args;
		while (*tw)
			*rw++ = wdcopy(*tw++, ap);
		*rw = NULL;
	}

	r->ioact = (t->ioact == NULL) ? NULL : iocopy(t->ioact, ap);

	r->left = tcopy(t->left, ap);
	r->right = tcopy(t->right, ap);
	r->lineno = t->lineno;

	return (r);
}

char *
wdcopy(const char *wp, Area *ap)
{
	size_t len;

	len = wdscan(wp, EOS) - wp;
	return (memcpy(alloc(len, ap), wp, len));
}

/* return the position of prefix c in wp plus 1 */
const char *
wdscan(const char *wp, int c)
{
	int nest = 0;

	while (/* CONSTCOND */ 1)
		switch (*wp++) {
		case EOS:
			return (wp);
		case ADELIM:
			if (c == ADELIM && nest == 0)
				return (wp + 1);
			if (ord(*wp) == ORD(/*{*/ '}'))
				goto wdscan_csubst;
			/* FALLTHROUGH */
		case CHAR:
		case QCHAR:
			wp++;
			break;
		case COMASUB:
		case COMSUB:
		case FUNASUB:
		case FUNSUB:
		case VALSUB:
		case EXPRSUB:
			while (*wp++ != 0)
				;
			break;
		case OQUOTE:
		case CQUOTE:
			break;
		case OSUBST:
			nest++;
			while (*wp++ != '\0')
				;
			break;
		case CSUBST:
 wdscan_csubst:
			wp++;
			if (c == CSUBST && nest == 0)
				return (wp);
			nest--;
			break;
		case OPAT:
			nest++;
			wp++;
			break;
		case SPAT:
		case CPAT:
			if (c == wp[-1] && nest == 0)
				return (wp);
			if (wp[-1] == CPAT)
				nest--;
			break;
		default:
			internal_warningf(
			    "wdscan: unknown char 0x%X (carrying on)",
			    (unsigned char)wp[-1]);
		}
}

/*
 * return a copy of wp without any of the mark up characters and with
 * quote characters (" ' \) stripped. (string is allocated from ATEMP)
 */
char *
wdstrip(const char *wp, int opmode)
{
	struct shf shf;

	shf_sopen(NULL, 32, SHF_WR | SHF_DYNAMIC, &shf);
	wdvarput(&shf, wp, 0, opmode);
	/* shf_sclose NUL terminates */
	return (shf_sclose(&shf));
}

static struct ioword **
iocopy(struct ioword **iow, Area *ap)
{
	struct ioword **ior;
	int i;

	ior = iow;
	while (*ior)
		++ior;
	ior = alloc2(ior - iow + 1, sizeof(struct ioword *), ap);

	for (i = 0; iow[i] != NULL; i++) {
		struct ioword *p, *q;

		p = iow[i];
		q = alloc(sizeof(struct ioword), ap);
		ior[i] = q;
		*q = *p;
		if (p->ioname != NULL)
			q->ioname = wdcopy(p->ioname, ap);
		if (p->delim != NULL)
			q->delim = wdcopy(p->delim, ap);
		if (p->heredoc != NULL)
			strdupx(q->heredoc, p->heredoc, ap);
	}
	ior[i] = NULL;

	return (ior);
}

/*
 * free tree (for function definition)
 */
void
tfree(struct op *t, Area *ap)
{
	char **w;

	if (t == NULL)
		return;

	afree(t->str, ap);

	if (t->vars != NULL) {
		for (w = t->vars; *w != NULL; w++)
			afree(*w, ap);
		afree(t->vars, ap);
	}

	if (t->args != NULL) {
		/*XXX we assume the caller is right */
		union mksh_ccphack cw;

		cw.ro = t->args;
		for (w = cw.rw; *w != NULL; w++)
			afree(*w, ap);
		afree(t->args, ap);
	}

	if (t->ioact != NULL)
		iofree(t->ioact, ap);

	tfree(t->left, ap);
	tfree(t->right, ap);

	afree(t, ap);
}

static void
iofree(struct ioword **iow, Area *ap)
{
	struct ioword **iop;
	struct ioword *p;

	iop = iow;
	while ((p = *iop++) != NULL) {
		afree(p->ioname, ap);
		afree(p->delim, ap);
		afree(p->heredoc, ap);
		afree(p, ap);
	}
	afree(iow, ap);
}

void
fpFUNCTf(struct shf *shf, int i, bool isksh, const char *k, struct op *v)
{
	if (isksh)
		fptreef(shf, i, "%s %s %T", Tfunction, k, v);
	else if (ktsearch(&keywords, k, hash(k)))
		fptreef(shf, i, "%s %s() %T", Tfunction, k, v);
	else
		fptreef(shf, i, "%s() %T", k, v);
}


/* for jobs.c */
void
vistree(char *dst, size_t sz, struct op *t)
{
	unsigned int c;
	char *cp, *buf;
	size_t n;

	buf = alloc(sz + 16, ATEMP);
	snptreef(buf, sz + 16, Tf_T, t);
	cp = buf;
 vist_loop:
	if (UTFMODE && (n = utf_mbtowc(&c, cp)) != (size_t)-1) {
		if (c == 0 || n >= sz)
			/* NUL or not enough free space */
			goto vist_out;
		/* copy multibyte char */
		sz -= n;
		while (n--)
			*dst++ = *cp++;
		goto vist_loop;
	}
	if (--sz == 0 || (c = ord(*cp++)) == 0)
		/* NUL or not enough free space */
		goto vist_out;
	if (ksh_isctrl(c)) {
		/* C0 or C1 control character or DEL */
		if (--sz == 0)
			/* not enough free space for two chars */
			goto vist_out;
		*dst++ = '^';
		c = ksh_unctrl(c);
	} else if (UTFMODE && rtt2asc(c) > 0x7F) {
		/* better not try to display broken multibyte chars */
		/* also go easy on the UCS: no U+FFFD here */
		c = ORD('?');
	}
	*dst++ = c;
	goto vist_loop;

 vist_out:
	*dst = '\0';
	afree(buf, ATEMP);
}

#ifdef DEBUG
void
dumpchar(struct shf *shf, unsigned char c)
{
	if (ksh_isctrl(c)) {
		/* C0 or C1 control character or DEL */
		shf_putc('^', shf);
		c = ksh_unctrl(c);
	}
	shf_putc(c, shf);
}

/* see: wdvarput */
static const char *
dumpwdvar_i(struct shf *shf, const char *wp, int quotelevel)
{
	int c;

	while (/* CONSTCOND */ 1) {
		switch(*wp++) {
		case EOS:
			shf_puts("EOS", shf);
			return (--wp);
		case ADELIM:
			if (ord(*wp) == ORD(/*{*/ '}')) {
				shf_puts(/*{*/ "]ADELIM(})", shf);
				return (wp + 1);
			}
			shf_puts("ADELIM=", shf);
			if (0)
				/* FALLTHROUGH */
		case CHAR:
			  shf_puts("CHAR=", shf);
			dumpchar(shf, *wp++);
			break;
		case QCHAR:
			shf_puts("QCHAR<", shf);
			c = ord(*wp++);
			if (quotelevel == 0 || c == ORD('"') ||
			    c == ORD('\\') || ctype(c, C_DOLAR | C_GRAVE))
				shf_putc('\\', shf);
			dumpchar(shf, c);
			goto closeandout;
		case COMASUB:
			shf_puts("COMASUB<", shf);
			goto dumpsub;
		case COMSUB:
			shf_puts("COMSUB<", shf);
 dumpsub:
			while ((c = *wp++) != 0)
				dumpchar(shf, c);
 closeandout:
			shf_putc('>', shf);
			break;
		case FUNASUB:
			shf_puts("FUNASUB<", shf);
			goto dumpsub;
		case FUNSUB:
			shf_puts("FUNSUB<", shf);
			goto dumpsub;
		case VALSUB:
			shf_puts("VALSUB<", shf);
			goto dumpsub;
		case EXPRSUB:
			shf_puts("EXPRSUB<", shf);
			goto dumpsub;
		case OQUOTE:
			shf_fprintf(shf, "OQUOTE{%d" /*}*/, ++quotelevel);
			break;
		case CQUOTE:
			shf_fprintf(shf, /*{*/ "%d}CQUOTE", quotelevel);
			if (quotelevel)
				quotelevel--;
			else
				shf_puts("(err)", shf);
			break;
		case OSUBST:
			shf_puts("OSUBST(", shf);
			dumpchar(shf, *wp++);
			shf_puts(")[", shf);
			while ((c = *wp++) != 0)
				dumpchar(shf, c);
			shf_putc('|', shf);
			wp = dumpwdvar_i(shf, wp, 0);
			break;
		case CSUBST:
			shf_puts("]CSUBST(", shf);
			dumpchar(shf, *wp++);
			shf_putc(')', shf);
			return (wp);
		case OPAT:
			shf_puts("OPAT=", shf);
			dumpchar(shf, *wp++);
			break;
		case SPAT:
			shf_puts("SPAT", shf);
			break;
		case CPAT:
			shf_puts("CPAT", shf);
			break;
		default:
			shf_fprintf(shf, "INVAL<%u>", (uint8_t)wp[-1]);
			break;
		}
		shf_putc(' ', shf);
	}
}
void
dumpwdvar(struct shf *shf, const char *wp)
{
	dumpwdvar_i(shf, wp, 0);
}

void
dumpioact(struct shf *shf, struct op *t)
{
	struct ioword **ioact, *iop;

	if ((ioact = t->ioact) == NULL)
		return;

	shf_puts("{IOACT", shf);
	while ((iop = *ioact++) != NULL) {
		unsigned short type = iop->ioflag & IOTYPE;
#define DT(x) case x: shf_puts(#x, shf); break;
#define DB(x) if (iop->ioflag & x) shf_puts("|" #x, shf);

		shf_putc(';', shf);
		switch (type) {
		DT(IOREAD)
		DT(IOWRITE)
		DT(IORDWR)
		DT(IOHERE)
		DT(IOCAT)
		DT(IODUP)
		default:
			shf_fprintf(shf, "unk%d", type);
		}
		DB(IOEVAL)
		DB(IOSKIP)
		DB(IOCLOB)
		DB(IORDUP)
		DB(IONAMEXP)
		DB(IOBASH)
		DB(IOHERESTR)
		DB(IONDELIM)
		shf_fprintf(shf, ",unit=%d", (int)iop->unit);
		if (iop->delim && !(iop->ioflag & IONDELIM)) {
			shf_puts(",delim<", shf);
			dumpwdvar(shf, iop->delim);
			shf_putc('>', shf);
		}
		if (iop->ioname) {
			if (iop->ioflag & IONAMEXP) {
				shf_puts(",name=", shf);
				print_value_quoted(shf, iop->ioname);
			} else {
				shf_puts(",name<", shf);
				dumpwdvar(shf, iop->ioname);
				shf_putc('>', shf);
			}
		}
		if (iop->heredoc) {
			shf_puts(",heredoc=", shf);
			print_value_quoted(shf, iop->heredoc);
		}
#undef DT
#undef DB
	}
	shf_putc('}', shf);
}

void
dumptree(struct shf *shf, struct op *t)
{
	int i, j;
	const char **w, *name;
	struct op *t1;
	static int nesting;

	for (i = 0; i < nesting; ++i)
		shf_putc('\t', shf);
	++nesting;
	shf_puts("{tree:" /*}*/, shf);
	if (t == NULL) {
		name = "(null)";
		goto out;
	}
	dumpioact(shf, t);
	switch (t->type) {
#define OPEN(x) case x: name = #x; shf_puts(" {" #x ":", shf); /*}*/

	OPEN(TCOM)
		if (t->vars) {
			i = 0;
			w = (const char **)t->vars;
			while (*w) {
				shf_putc('\n', shf);
				for (j = 0; j < nesting; ++j)
					shf_putc('\t', shf);
				shf_fprintf(shf, " var%d<", i++);
				dumpwdvar(shf, *w++);
				shf_putc('>', shf);
			}
		} else
			shf_puts(" #no-vars#", shf);
		if (t->args) {
			i = 0;
			w = t->args;
			while (*w) {
				shf_putc('\n', shf);
				for (j = 0; j < nesting; ++j)
					shf_putc('\t', shf);
				shf_fprintf(shf, " arg%d<", i++);
				dumpwdvar(shf, *w++);
				shf_putc('>', shf);
			}
		} else
			shf_puts(" #no-args#", shf);
		break;
	OPEN(TEXEC)
 dumpleftandout:
		t = t->left;
 dumpandout:
		shf_putc('\n', shf);
		dumptree(shf, t);
		break;
	OPEN(TPAREN)
		goto dumpleftandout;
	OPEN(TPIPE)
 dumpleftmidrightandout:
		shf_putc('\n', shf);
		dumptree(shf, t->left);
/* middumprightandout: (unused) */
		shf_fprintf(shf, "/%s:", name);
 dumprightandout:
		t = t->right;
		goto dumpandout;
	OPEN(TLIST)
		goto dumpleftmidrightandout;
	OPEN(TOR)
		goto dumpleftmidrightandout;
	OPEN(TAND)
		goto dumpleftmidrightandout;
	OPEN(TBANG)
		goto dumprightandout;
	OPEN(TDBRACKET)
		i = 0;
		w = t->args;
		while (*w) {
			shf_putc('\n', shf);
			for (j = 0; j < nesting; ++j)
				shf_putc('\t', shf);
			shf_fprintf(shf, " arg%d<", i++);
			dumpwdvar(shf, *w++);
			shf_putc('>', shf);
		}
		break;
	OPEN(TFOR)
 dumpfor:
		shf_fprintf(shf, " str<%s>", t->str);
		if (t->vars != NULL) {
			i = 0;
			w = (const char **)t->vars;
			while (*w) {
				shf_putc('\n', shf);
				for (j = 0; j < nesting; ++j)
					shf_putc('\t', shf);
				shf_fprintf(shf, " var%d<", i++);
				dumpwdvar(shf, *w++);
				shf_putc('>', shf);
			}
		}
		goto dumpleftandout;
	OPEN(TSELECT)
		goto dumpfor;
	OPEN(TCASE)
		shf_fprintf(shf, " str<%s>", t->str);
		i = 0;
		for (t1 = t->left; t1 != NULL; t1 = t1->right) {
			shf_putc('\n', shf);
			for (j = 0; j < nesting; ++j)
				shf_putc('\t', shf);
			shf_fprintf(shf, " sub%d[(", i);
			w = (const char **)t1->vars;
			while (*w) {
				dumpwdvar(shf, *w);
				if (w[1] != NULL)
					shf_putc('|', shf);
				++w;
			}
			shf_putc(')', shf);
			dumpioact(shf, t);
			shf_putc('\n', shf);
			dumptree(shf, t1->left);
			shf_fprintf(shf, " ;%c/%d]", t1->u.charflag, i++);
		}
		break;
	OPEN(TWHILE)
		goto dumpleftmidrightandout;
	OPEN(TUNTIL)
		goto dumpleftmidrightandout;
	OPEN(TBRACE)
		goto dumpleftandout;
	OPEN(TCOPROC)
		goto dumpleftandout;
	OPEN(TASYNC)
		goto dumpleftandout;
	OPEN(TFUNCT)
		shf_fprintf(shf, " str<%s> ksh<%s>", t->str,
		    t->u.ksh_func ? Ttrue : Tfalse);
		goto dumpleftandout;
	OPEN(TTIME)
		goto dumpleftandout;
	OPEN(TIF)
 dumpif:
		shf_putc('\n', shf);
		dumptree(shf, t->left);
		t = t->right;
		dumpioact(shf, t);
		if (t->left != NULL) {
			shf_puts(" /TTHEN:\n", shf);
			dumptree(shf, t->left);
		}
		if (t->right && t->right->type == TELIF) {
			shf_puts(" /TELIF:", shf);
			t = t->right;
			dumpioact(shf, t);
			goto dumpif;
		}
		if (t->right != NULL) {
			shf_puts(" /TELSE:\n", shf);
			dumptree(shf, t->right);
		}
		break;
	OPEN(TEOF)
 dumpunexpected:
		shf_puts(Tunexpected, shf);
		break;
	OPEN(TELIF)
		goto dumpunexpected;
	OPEN(TPAT)
		goto dumpunexpected;
	default:
		name = "TINVALID";
		shf_fprintf(shf, "{T<%d>:" /*}*/, t->type);
		goto dumpunexpected;

#undef OPEN
	}
 out:
	shf_fprintf(shf, /*{*/ " /%s}\n", name);
	--nesting;
}
#endif
@


1.96
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d824 1
a824 1
dumpchar(struct shf *shf, int c)
@


1.95
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.87 2017/04/06 01:59:58 tg Exp $");
d811 1
a811 1
		/* also go easy on the Unicode: no U+FFFD here */
@


1.94
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d345 1
a345 1
				case CORD('\n'):
d355 4
a358 4
				case CORD('"'):
				case CORD('`'):
				case CORD('$'):
				case CORD('\\'):
d473 1
a473 1
			case CORD('c'):
d477 1
a477 1
			case CORD('s'):
d481 1
a481 1
			case CORD('S'):
d485 1
a485 1
			case CORD('d'):
d489 1
a489 1
			case CORD('u'):
d493 1
a493 1
			case CORD('T'):
d497 1
a497 1
			case CORD(';'):
d499 1
a499 1
			case CORD('N'):
d519 1
a519 1
			case CORD('R'):
@


1.93
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d332 1
a332 1
			if (ord(*wp) == ord(/*{*/ '}')) {
d345 1
a345 1
				case ord('\n'):
d347 1
a347 1
						c = ord('\'');
d349 1
a349 1
						shf_putc(ord('\n'), shf);
d355 5
a359 5
				case ord('"'):
				case ord('`'):
				case ord('$'):
				case ord('\\'):
					  shf_putc(ord('\\'), shf);
d368 1
a368 1
			if (ord(*wp) == ord('(' /*)*/))
d377 1
a377 1
			c = ord(' ');
d381 1
a381 1
			  c = ord('|');
d406 1
a406 1
			if (ord(*wp++) == ord('{'))
d413 1
a413 1
			if (ord(*wp++) == ord('}')) {
d423 1
a423 1
			c = ord('|');
d427 1
a427 1
			  c = ord(/*(*/ ')');
d473 1
a473 1
			case ord('c'):
d477 1
a477 1
			case ord('s'):
d481 1
a481 1
			case ord('S'):
d485 1
a485 1
			case ord('d'):
d489 1
a489 1
			case ord('u'):
d493 1
a493 1
			case ord('T'):
d497 1
a497 1
			case ord(';'):
d499 1
a499 1
			case ord('N'):
d502 2
a503 1
					if (c == ord(';') && !prevent_semicolon)
d519 1
a519 1
			case ord('R'):
d617 1
a617 1
			if (ord(*wp) == ord(/*{*/ '}'))
d812 1
a812 1
		c = ord('?');
d846 1
a846 1
			if (ord(*wp) == ord(/*{*/ '}')) {
d860 2
a861 2
			if (quotelevel == 0 || c == ord('"') ||
			    c == ord('\\') || ctype(c, C_DOLAR | C_GRAVE))
@


1.92
log
@switch EBCDIC to “nega-UTF8”
@
text
@d332 1
a332 1
			if (*wp == /*{*/'}') {
d338 1
a338 1
			c = *wp++;
d342 1
a342 1
			c = *wp++;
d345 1
a345 1
				case '\n':
d347 1
a347 1
						c = '\'';
d349 1
a349 1
						shf_putc('\n', shf);
d355 5
a359 5
				case '"':
				case '`':
				case '$':
				case '\\':
					  shf_putc('\\', shf);
d368 1
a368 1
			if (*wp == '(' /*)*/)
d377 1
a377 1
			c = ' ';
d381 1
a381 1
			  c = '|';
d406 1
a406 1
			if (*wp++ == '{')
d413 1
a413 1
			if (*wp++ == '}') {
d423 1
a423 1
			c = '|';
d427 1
a427 1
			  c = /*(*/ ')';
d470 1
a470 1
	while ((c = *fmt++)) {
d472 2
a473 2
			switch ((c = *fmt++)) {
			case 'c':
d477 1
a477 1
			case 's':
d481 1
a481 1
			case 'S':
d485 1
a485 1
			case 'd':
d489 1
a489 1
			case 'u':
d493 1
a493 1
			case 'T':
d497 1
a497 1
			case ';':
d499 1
a499 1
			case 'N':
d502 1
a502 1
					if (c == ';' && !prevent_semicolon)
d518 1
a518 1
			case 'R':
d616 1
a616 1
			if (*wp == /*{*/'}')
d798 1
a798 1
	if (--sz == 0 || (c = (unsigned char)(*cp++)) == 0)
d811 1
a811 1
		c = '?';
d845 1
a845 1
			if (*wp == /*{*/'}') {
d858 3
a860 3
			c = *wp++;
			if (quotelevel == 0 || c == '"' || c == '\\' ||
			    ctype(c, C_DOLAR | C_GRAVE))
@


1.91
log
@control character madness, but more compiler-friendly
@
text
@d808 1
a808 1
	} else if (UTFMODE && c > 0x7F) {
@


1.90
log
@commit the optimisation result from the new fast character classes
@
text
@d801 1
a801 1
	if (ISCTRL(c & 0x7F)) {
d806 2
a807 2
		*dst++ = (c & 0x80) ? '$' : '^';
		c = UNCTRL(c & 0x7F);
d825 1
a825 1
	if (ISCTRL(c & 0x7F)) {
d827 2
a828 2
		shf_putc((c & 0x80) ? '$' : '^', shf);
		c = UNCTRL(c & 0x7F);
@


1.89
log
@(very few) fixes and a couple of workarounds for Coverity
@
text
@d859 2
a860 2
			if (quotelevel == 0 ||
			    (c == '"' || c == '`' || c == '$' || c == '\\'))
@


1.88
log
@disambiguate $((…)) vs. $((…)…) in “typeset -f” output
@
text
@d61 1
a61 1
		if (
@


1.87
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.80 2016/01/14 22:30:43 tg Exp $");
d368 2
@


1.86
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2015, 2016
d89 9
d364 1
d373 1
d423 1
d425 1
a425 1
				c = /*(*/ ')';
d621 1
d623 1
d849 1
d851 1
a851 1
				shf_puts("CHAR=", shf);
d862 3
d873 3
@


1.85
log
@fix var=<< implementation
@
text
@d77 1
a77 1
			fptreef(shf, indent, "%S", t->vars[0]);
d84 1
a84 1
				fptreef(shf, indent, "%S ", *w++);
d90 1
a90 1
				fptreef(shf, indent, "%S ", *w++);
d122 1
a122 1
			fptreef(shf, indent, " %S", *w++);
d133 2
a134 2
				fptreef(shf, indent, "%S ", *w++);
			fptreef(shf, indent, "%;");
a153 1
#ifdef DEBUG
d155 1
a155 1
		internal_errorf("TELIF in tree.c:ptree() unexpected");
a156 1
#endif
d164 1
a164 1
			fptreef(shf, indent, "%;");
d170 1
a170 1
				fptreef(shf, indent, "%;");
d176 1
a176 1
			fptreef(shf, indent, "%;");
d185 1
a185 1
		fptreef(shf, indent + 6, "%s %T",
d188 1
a188 1
		fptreef(shf, indent, "%;");
d208 1
a208 1
		fptreef(shf, indent, "%s %T", "time", t->left);
d230 1
a230 1
				fptreef(shf, indent, "%s",
d259 1
a259 1
		shf_fprintf(shf, "%d", (int)iop->unit);
d473 1
a473 1
				shf_fprintf(shf, "%d", va_arg(va, int));
d769 1
a769 1
	snptreef(buf, sz + 16, "%T", t);
d1108 1
a1108 1
		    t->u.ksh_func ? "true" : "false");
d1135 1
a1135 1
		shf_puts("unexpected", shf);
@


1.84
log
@emit QCHAR '\n' reentrancy-safe
@
text
@d52 1
d60 1
a60 4
		/*
		 * special-case 'var=<<EOF' (rough; see
		 * exec.c:execute() for full code)
		 */
d62 1
a62 1
		    /* we have zero arguments, i.e. no programme to run */
d70 7
a76 1
		    (t->ioact[0]->ioflag & IOTYPE) == IOHERE) {
@


1.83
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d325 1
d330 1
a330 3
		case QCHAR: {
			bool doq;

d332 19
a350 9
			doq = (c == '"' || c == '`' || c == '$' || c == '\\');
			if (opmode & WDS_TPUTS) {
				if (quotelevel == 0)
					doq = true;
			} else {
				doq = false;
			}
			if (doq)
				shf_putc('\\', shf);
a352 1
		}
@


1.82
log
@legibility
@
text
@d634 2
a635 2
			    "wdscan: unknown char 0x%x (carrying on)",
			    wp[-1]);
@


1.81
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d820 1
a820 1
				shf_puts("]ADELIM(})", shf);
d855 1
a855 1
			shf_fprintf(shf, "OQUOTE{%d", ++quotelevel);
d858 1
a858 1
			shf_fprintf(shf, "%d}CQUOTE", quotelevel);
@


1.80
log
@correctly handle nested ADELIM parsing: ADELIM doubles as CSUBST (LP#1453827)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.72 2013/09/24 20:19:45 tg Exp $");
d1098 1
a1098 1
		    t->u.ksh_func ? "yes" : "no");
@


1.79
log
@now WDS_KEEPQ and WDS_MAGIC are both no longer needed
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2015
d321 4
d390 2
a391 1
			if (*wp++ == '}')
d393 1
d590 1
a590 1
			if (c == ADELIM)
d592 2
d615 1
d819 4
@


1.78
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@d311 1
a311 1
	 *	x${foo:-'hi'} -> x${foo:-hi} unless WDS_KEEPQ
a322 4
			if ((opmode & WDS_MAGIC) &&
			    (ISMAGIC(c) || c == '[' || c == '!' ||
			    c == '-' || c == ']' || c == '*' || c == '?'))
				shf_putc(MAGIC, shf);
d334 1
a334 2
				if (!(opmode & WDS_KEEPQ))
					doq = false;
d390 2
a391 7
			if (opmode & WDS_MAGIC) {
				shf_putc(MAGIC, shf);
				shf_putchar(*wp++ | 0x80, shf);
			} else {
				shf_putchar(*wp++, shf);
				shf_putc('(', shf);
			}
a397 2
			if (opmode & WDS_MAGIC)
				shf_putc(MAGIC, shf);
@


1.77
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
d289 1
a289 1
	} else if (iop->name) {
d291 1
a291 1
			print_value_quoted(shf, iop->name);
d293 1
a293 1
			wdvarput(shf, iop->name, 0, WDS_TPUTS);
d675 2
a676 2
		if (p->name != NULL)
			q->name = wdcopy(p->name, ap);
d733 1
a733 1
		afree(p->name, ap);
d939 1
a939 1
		if (iop->name) {
d942 1
a942 1
				print_value_quoted(shf, iop->name);
d945 1
a945 1
				dumpwdvar(shf, iop->name);
@


1.76
log
@fix tree printing multiple heredocs in one command, bug found by izabera
@
text
@a228 1
				    iop->ioflag & IONDELIM ? "<<" :
d267 2
d287 1
a287 1
		if (iop->delim)
a288 1
		/*XXX see IONDELIM hack */
d934 1
a934 1
		if (iop->delim) {
@


1.75
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d288 1
a288 2
		if (flag & IOHERESTR)
			shf_putc(' ', shf);
a293 1
		shf_putc(' ', shf);
d295 1
@


1.74
log
@make 'typeset -f' output reentrant in the face of functions whose
names are keywords and a GNU bash extension (gah!); reported by izabera
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.20 2012/06/27 07:17:19 otto Exp $	*/
d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d699 1
a699 2
	if (t->str != NULL)
		afree(t->str, ap);
d734 3
a736 6
		if (p->name != NULL)
			afree(p->name, ap);
		if (p->delim != NULL)
			afree(p->delim, ap);
		if (p->heredoc != NULL)
			afree(p->heredoc, ap);
@


1.73
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d751 2
@


1.72
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (‘;’), oksh rcsid sync (they did
accept I was right wrt. set -e), int → bool, and code merge/cleanup
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.71 2013/07/26 20:33:24 tg Exp $");
d72 1
a72 1
		    (t->ioact[0]->flag & IOTYPE) == IOHERE) {
d224 1
a224 1
			if ((iop->flag & (IOTYPE | IOHERESTR)) == IOHERE &&
d229 1
a229 1
				    iop->flag & IONDELIM ? "<<" :
d249 3
a251 3
	int flag = iop->flag;
	int type = flag & IOTYPE;
	int expected;
d258 1
a258 1
		shf_fprintf(shf, "%d", iop->unit);
d288 1
a288 1
		if (iop->flag & IOHERESTR)
d291 1
a291 1
		if (iop->flag & IONAMEXP)
d913 1
a913 1
		int type = iop->flag & IOTYPE;
d915 1
a915 1
#define DB(x) if (iop->flag & x) shf_puts("|" #x, shf);
d936 1
a936 1
		shf_fprintf(shf, ",unit=%d", iop->unit);
d943 1
a943 1
			if (iop->flag & IONAMEXP) {
@


1.72.2.1
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.72 2013/09/24 20:19:45 tg Exp $");
d72 1
a72 1
		    (t->ioact[0]->ioflag & IOTYPE) == IOHERE) {
d224 1
a224 1
			if ((iop->ioflag & (IOTYPE | IOHERESTR)) == IOHERE &&
d229 1
a229 1
				    iop->ioflag & IONDELIM ? "<<" :
d249 3
a251 3
	unsigned short flag = iop->ioflag;
	unsigned short type = flag & IOTYPE;
	short expected;
d258 1
a258 1
		shf_fprintf(shf, "%d", (int)iop->unit);
d288 1
a288 1
		if (flag & IOHERESTR)
d291 1
a291 1
		if (flag & IONAMEXP)
d913 1
a913 1
		unsigned short type = iop->ioflag & IOTYPE;
d915 1
a915 1
#define DB(x) if (iop->ioflag & x) shf_puts("|" #x, shf);
d936 1
a936 1
		shf_fprintf(shf, ",unit=%d", (int)iop->unit);
d943 1
a943 1
			if (iop->ioflag & IONAMEXP) {
@


1.71
log
@TGIF, drinking-beer, Sysadmin Appreciation Day commit:
• As requested by Steffen Daode Nurpmeso, enlarge the
  amount of command characters shown in job handling
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.69 2013/05/02 21:59:54 tg Exp $");
d781 1
a781 1
	if ((c & 0x60) == 0 || (c & 0x7F) == 0x7F) {
d787 1
a787 1
		c = (c & 0x7F) ^ 0x40;
d790 1
d805 1
a805 1
	if (((c & 0x60) == 0) || ((c & 0x7F) == 0x7F)) {
d808 1
a808 1
		c = (c & 0x7F) ^ 0x40;
@


1.70
log
@simplify
@
text
@d764 2
a765 2
	buf = alloc(sz + 8, ATEMP);
	snptreef(buf, sz + 8, "%T", t);
@


1.69
log
@implement VALSUBs
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.67 2012/12/04 01:10:35 tg Exp $");
d262 1
a262 1
		shf_puts("<", shf);
d265 3
a267 1
		shf_puts(flag & IOSKIP ? "<<-" : "<<", shf);
d273 3
a275 1
		shf_puts(flag & IOCLOB ? ">|" : ">", shf);
@


1.68
log
@• let mksh “set -x” print whole TCOM trees
• plug some memory leaks in debug (“set -x”) and warning paths while here
• one from Florian (friend of Natureshadow) for WTF
@
text
@d5 1
a5 1
 *		 2011, 2012
d352 8
a359 1
			shf_puts("${ ", shf);
d602 1
d845 3
@


1.67
log
@Keep LLVM+Clang from nagging about “"foo" + 1 ≠ "foo1"” warning.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.66 2012/11/30 20:19:16 tg Exp $");
d31 1
a31 1
static void pioact(struct shf *, int, struct ioword *);
d217 1
a217 1
			pioact(shf, indent, *ioact++);
d247 1
a247 1
pioact(struct shf *shf, int indent, struct ioword *iop)
d286 7
a292 3
	} else if (iop->name)
		fptreef(shf, indent, (iop->flag & IONAMEXP) ? "%s " : "%S ",
		    iop->name);
d492 1
a492 1
				pioact(shf, indent, va_arg(va, struct ioword *));
@


1.66
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.65 2012/10/22 20:19:18 tg Exp $");
d40 2
d165 1
a165 1
			fptreef(shf, indent + 5 - i, "elif %T" + i, t1->left);
d182 1
a182 1
		/* 6 == strlen("while"/"until") */
@


1.65
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.64 2012/08/17 18:34:25 tg Exp $");
a344 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a348 1
#endif
a587 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a588 1
#endif
a827 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a830 1
#endif
@


1.65.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.65 2012/10/22 20:19:18 tg Exp $");
a39 2
static const char Telif_pT[] = "elif %T";

d163 1
a163 1
			fptreef(shf, indent + 5 - i, Telif_pT + i, t1->left);
d180 1
a180 1
		/* 6 == strlen("while "/"until ") */
@


1.64
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.63 2012/07/30 21:37:17 tg Exp $");
d345 6
d590 3
d832 5
@


1.63
log
@implement ksh93 feature ${ foo;}
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.61 2012/06/28 20:17:39 tg Exp $");
a344 4
		case FUNSUB:
			shf_puts("${ ", shf);
			cs = ";}";
			goto pSUB;
a583 1
		case FUNSUB:
a822 3
		case FUNSUB:
			shf_puts("FUNSUB<", shf);
			goto dumpsub;
@


1.62
log
@fix reentry of here documents (LP#1030581)
@
text
@d295 1
d339 2
d343 1
a343 1
			shf_putc(')', shf);
d345 4
d351 2
a352 4
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
			shf_puts("))", shf);
			break;
d588 1
d828 3
@


1.61
log
@(mksh) tighten 32-bit requirements; (lksh) switch to long; allow any bitness
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.59 2012/05/04 18:45:03 tg Exp $");
d56 19
a86 1
		prevent_semicolon = false;
d237 1
a237 1
		if (need_nl)
d239 2
d281 2
a282 2
			fptreef(shf, indent, "%S ", iop->delim);
		else
@


1.61.2.1
log
@MFC cid 1005016E7627EF7B61F: fix reentry of here documents (LP#1030581)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.61 2012/06/28 20:17:39 tg Exp $");
a55 19
		prevent_semicolon = false;
		/*
		 * special-case 'var=<<EOF' (rough; see
		 * exec.c:execute() for full code)
		 */
		if (
		    /* we have zero arguments, i.e. no programme to run */
		    t->args[0] == NULL &&
		    /* we have exactly one variable assignment */
		    t->vars[0] != NULL && t->vars[1] == NULL &&
		    /* we have exactly one I/O redirection */
		    t->ioact != NULL && t->ioact[0] != NULL &&
		    t->ioact[1] == NULL &&
		    /* of type "here document" (or "here string") */
		    (t->ioact[0]->flag & IOTYPE) == IOHERE) {
			fptreef(shf, indent, "%S", t->vars[0]);
			break;
		}

d68 1
d219 1
a219 1
		if (need_nl) {
a220 2
			prevent_semicolon = true;
		}
d261 2
a262 2
			wdvarput(shf, iop->delim, 0, WDS_TPUTS);
		if (iop->flag & IOHERESTR)
@


1.60
log
@sync w/ oksh (RCSID only # no change needed)
@
text
@@


1.59
log
@avoid C99 constructs even in debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.19 2008/08/11 21:50:35 jaredy Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.58 2012/04/07 11:19:30 tg Exp $");
@


1.58
log
@move unexpected TELIF warning into #ifdef DEBUG as it never triggered
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.57 2012/03/23 20:07:13 tg Exp $");
d914 1
a914 1
	int i;
d937 1
a937 1
				for (int j = 0; j < nesting; ++j)
d950 1
a950 1
				for (int j = 0; j < nesting; ++j)
d990 1
a990 1
			for (int j = 0; j < nesting; ++j)
d1005 1
a1005 1
				for (int j = 0; j < nesting; ++j)
d1020 1
a1020 1
			for (int j = 0; j < nesting; ++j)
@


1.57
log
@drop use of the NOT macro, [^foo] ≠ [!foo] anyway, and we’re not gonna change that
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.56 2012/02/06 17:42:24 tg Exp $");
d130 1
a130 1
#ifndef MKSH_NO_DEPRECATED_WARNING
@


1.56
log
@make jobs reporting deal with UTF-8 (in utf8-mode)
reported by Andrew Kudryashov, 10x
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.55 2011/12/31 00:27:27 tg Exp $");
d294 1
a294 1
			    (ISMAGIC(c) || c == '[' || c == NOT ||
@


1.55
log
@gc-sections found size optimisation chances
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.53 2011/12/29 22:54:22 tg Exp $");
d716 1
a716 1
	int c;
d718 1
d720 2
a721 2
	buf = alloc(sz, ATEMP);
	snptreef(buf, sz, "%T", t);
d723 24
a746 11
	while ((c = *cp++)) {
		if (((c & 0x60) == 0) || ((c & 0x7F) == 0x7F)) {
			/* C0 or C1 control character or DEL */
			if (!--sz)
				break;
			*dst++ = (c & 0x80) ? '$' : '^';
			c = (c & 0x7F) ^ 0x40;
		}
		if (!--sz)
			break;
		*dst++ = c;
d748 4
@


1.54
log
@don’t clobber the tree used for printing IOACTs in process_TIF (LP: #907224)
@
text
@d898 1
a898 1
	static int nesting = 0;
@


1.53
log
@give dumptree an dumpioact helper
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.52 2011/10/25 22:36:39 tg Exp $");
d136 1
d139 1
a139 1
			t = t->right;
d144 3
a146 3
			fptreef(shf, indent + 5 - i, "elif %T" + i, t->left);
			t = t->right;
			if (t->left != NULL) {
d149 1
a149 1
				    "then", t->left);
d151 2
a152 2
		} while (t->right && t->right->type == TELIF);
		if (t->right != NULL) {
d155 1
a155 1
			    "else", t->right);
@


1.52
log
@rename more identifiers with trailing underscores
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.51 2011/09/07 15:24:21 tg Exp $");
d833 59
d907 1
d1011 1
d1038 1
d1046 1
@


1.52.4.1
log
@MFC all those nice things (not all parts, by now); sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.55 2011/12/31 00:27:27 tg Exp $");
a135 1
		t1 = t;
d138 1
a138 1
			t1 = t1->right;
d143 3
a145 3
			fptreef(shf, indent + 5 - i, "elif %T" + i, t1->left);
			t1 = t1->right;
			if (t1->left != NULL) {
d148 1
a148 1
				    "then", t1->left);
d150 2
a151 2
		} while (t1->right && t1->right->type == TELIF);
		if (t1->right != NULL) {
d154 1
a154 1
			    "else", t1->right);
@


1.52.4.2
log
@MFC pending stuff into mksh R40-stable branch
@
text
@d4 1
a4 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.56 2012/02/06 17:42:24 tg Exp $");
d715 1
a715 1
	unsigned int c;
a716 1
	size_t n;
d718 2
a719 2
	buf = alloc(sz + 8, ATEMP);
	snptreef(buf, sz + 8, "%T", t);
d721 11
a731 10
 vist_loop:
	if (UTFMODE && (n = utf_mbtowc(&c, cp)) != (size_t)-1) {
		if (c == 0 || n >= sz)
			/* NUL or not enough free space */
			goto vist_out;
		/* copy multibyte char */
		sz -= n;
		while (n--)
			*dst++ = *cp++;
		goto vist_loop;
a732 18
	if (--sz == 0 || (c = (unsigned char)(*cp++)) == 0)
		/* NUL or not enough free space */
		goto vist_out;
	if ((c & 0x60) == 0 || (c & 0x7F) == 0x7F) {
		/* C0 or C1 control character or DEL */
		if (--sz == 0)
			/* not enough free space for two chars */
			goto vist_out;
		*dst++ = (c & 0x80) ? '$' : '^';
		c = (c & 0x7F) ^ 0x40;
	} else if (UTFMODE && c > 0x7F) {
		/* better not try to display broken multibyte chars */
		c = '?';
	}
	*dst++ = c;
	goto vist_loop;

 vist_out:
@


1.52.4.3
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.57 2012/03/23 20:07:13 tg Exp $");
d294 1
a294 1
			    (ISMAGIC(c) || c == '[' || c == '!' ||
d858 1
a858 1
	static int nesting;
@


1.51
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.50 2011/08/27 18:06:51 tg Exp $");
d750 1
a750 1
dumpwdvar_(struct shf *shf, const char *wp, int quotelevel)
d802 1
a802 1
			wp = dumpwdvar_(shf, wp, 0);
d829 1
a829 1
	dumpwdvar_(shf, wp, 0);
@


1.50
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.49 2011/05/29 02:18:57 tg Exp $");
d103 1
a103 1
		    (t->type == TFOR) ? "for" : T_select, t->str);
d704 1
a704 1
		fptreef(shf, i, "%s %s %T", T_function, k, v);
@


1.49
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.48 2011/05/07 00:24:35 tg Exp $");
d389 1
a389 1
snptreef(char *s, int n, const char *fmt, ...)
@


1.48
log
@fix problem #1 and a comment
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.47 2011/05/05 00:05:01 tg Exp $");
d103 1
a103 1
		    (t->type == TFOR) ? "for" : "select", t->str);
d124 2
a125 1
			fptreef(shf, indent + INDENT, "%N%T%N;;", t1->left);
d953 1
a953 1
			shf_fprintf(shf, " /%d]", i++);
@


1.47
log
@• use a flag for determining here strings, don’t parse delimiter every time
• don’t leak memory parsing possible I/O redirection tokens
• get rid of volatile by using more const (also helps codegen, methinks)
• support empty here document markers (mksh extension)
• pimp the manpage
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.46 2011/05/04 22:38:27 tg Exp $");
d200 1
a200 1
			/* heredoc is 0 when tracing (set -x) */
@


1.46
log
@return EOS on EOS just to be on the safe side
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.45 2011/05/02 22:52:54 tg Exp $");
d201 2
a202 3
			if ((iop->flag & IOTYPE) == IOHERE && iop->heredoc &&
			    /* iop->delim[1] == '<' means here string */
			    (!iop->delim || iop->delim[1] != '<')) {
d206 1
@


1.45
log
@• fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
• merge tputS and wdstrip_internal
⇒ net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.44 2011/04/22 12:15:42 tg Exp $");
d286 1
a286 1
			return (wp);
d757 1
a757 1
			return (wp);
@


1.44
log
@more static initialisers (verified using nm comparision between mksh
built with/-out "-ffunction-sections -fdata-sections -Wl,--gc-sections"
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.43 2011/04/09 15:14:55 tg Exp $");
d31 1
a31 1
static void tputS(const char *, struct shf *);
a34 1
static void wdstrip_internal(struct shf *, const char *, bool, bool);
d267 3
a269 3
/* variant of fputs for ptreef */
static void
tputS(const char *wp, struct shf *shf)
d271 1
a271 1
	int c, quotelevel = 0;
d277 2
d286 1
a286 1
			return;
d289 6
a294 1
			shf_putchar(*wp++, shf);
d296 3
a298 1
		case QCHAR:
d300 9
a308 2
			if (!quotelevel ||
			    (c == '"' || c == '`' || c == '$' || c == '\\'))
d312 1
d326 4
a329 2
			quotelevel++;
			shf_putc('"', shf);
d332 5
a336 3
			if (quotelevel)
				quotelevel--;
			shf_putc('"', shf);
d344 1
d349 1
a349 1
			break;
d351 7
a357 2
			shf_putchar(*wp++, shf);
			shf_putc('(', shf);
d360 2
a361 2
			shf_putc('|', shf);
			break;
d363 4
a366 1
			shf_putc(')', shf);
d421 1
a421 1
				tputS(va_arg(va, char *), shf);
d601 1
a601 1
wdstrip(const char *wp, bool keepq, bool make_magic)
d606 1
a606 1
	wdstrip_internal(&shf, wp, keepq, make_magic);
a610 78
static void
wdstrip_internal(struct shf *shf, const char *wp, bool keepq, bool make_magic)
{
	int c;

	/*-
	 * problems:
	 *	`...` -> $(...)
	 *	x${foo:-"hi"} -> x${foo:-hi}
	 *	x${foo:-'hi'} -> x${foo:-hi} unless keepq
	 */
	while (/* CONSTCOND */ 1)
		switch (*wp++) {
		case EOS:
			return;
		case ADELIM:
		case CHAR:
			c = *wp++;
			if (make_magic && (ISMAGIC(c) || c == '[' || c == NOT ||
			    c == '-' || c == ']' || c == '*' || c == '?'))
				shf_putc(MAGIC, shf);
			shf_putc(c, shf);
			break;
		case QCHAR:
			c = *wp++;
			if (keepq && (c == '"' || c == '`' || c == '$' || c == '\\'))
				shf_putc('\\', shf);
			shf_putc(c, shf);
			break;
		case COMSUB:
			shf_puts("$(", shf);
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
			shf_putc(')', shf);
			break;
		case EXPRSUB:
			shf_puts("$((", shf);
			while (*wp != 0)
				shf_putchar(*wp++, shf);
			shf_puts("))", shf);
			break;
		case OQUOTE:
			break;
		case CQUOTE:
			break;
		case OSUBST:
			shf_putc('$', shf);
			if (*wp++ == '{')
			    shf_putc('{', shf);
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
			break;
		case CSUBST:
			if (*wp++ == '}')
				shf_putc('}', shf);
			break;
		case OPAT:
			if (make_magic) {
				shf_putc(MAGIC, shf);
				shf_putchar(*wp++ | 0x80, shf);
			} else {
				shf_putchar(*wp++, shf);
				shf_putc('(', shf);
			}
			break;
		case SPAT:
			if (make_magic)
				shf_putc(MAGIC, shf);
			shf_putc('|', shf);
			break;
		case CPAT:
			if (make_magic)
				shf_putc(MAGIC, shf);
			shf_putc(')', shf);
			break;
		}
}

d747 3
a749 3
/* see: tputS */
void
dumpwdvar(struct shf *shf, const char *wp)
d751 1
a751 1
	int c, quotelevel = 0;
d757 1
a757 1
			return;
d760 3
a762 1
 dumpchar:
a764 3
		case CHAR:
			shf_puts("CHAR=", shf);
			goto dumpchar;
d768 1
a768 1
			if (!quotelevel ||
d800 2
d807 1
a807 1
			break;
d825 5
@


1.43
log
@• no longer use <stdbool.h> even if it’s available
• ensure that bool/true/false are cpp macros, overriding any pre-defined
• document the requirement that tobool(x) must map any-type 'x' into bool
• document the requirement that a bool must only be true or false, and
  that it (tobool() rather) must have an identity mapping to 'short'
• possibly fix ksh_func for/and fpFUNCTf – maybe spotted by cnuke@@
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.42 2011/04/09 15:05:44 tg Exp $");
d38 1
a38 1
static bool prevent_semicolon = false;
@


1.42
log
@no // style comments in my source code!
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.41 2011/03/17 21:58:40 tg Exp $");
d181 1
a181 1
		fpFUNCTf(shf, indent, t->u.ksh_func, t->str, t->left);
@


1.41
log
@• make DEBUG:dumpchar() not static (consider rolling into shf?)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.40 2011/03/13 01:20:24 tg Exp $");
d934 1
a934 1
// middumprightandout:
@


1.40
log
@lint is your friend
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.39 2011/03/12 23:04:48 tg Exp $");
d785 1
a785 1
static void
@


1.39
log
@• back out the EXPRSUB change
• optimise some code
• split testcase into two, one with expected-fail
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.37 2011/03/08 18:49:51 tg Exp $");
d282 1
a282 1
	while (1)
d518 1
a518 1
	while (1)
d593 1
a593 1
	while (1)
d802 1
a802 1
	while (1) {
@


1.38
log
@• make EXPRSUB not initiate an ASCIIZ string any more but a wdstring
  (token stream, lexer output / parser input), EOS terminated, let
  SASPAREN use the same lexing as SBASE (e.g. COMSUB recursively)
• make wdstrip recursive
• fix processing of COMSUB in wdstrip
⇒ pass comsub-1 test
• expose another debugging function
@
text
@d305 2
a306 2
			tputS(wp, shf);
			wp = wdscan(wp, EOS);
d530 1
a531 3
			wp = wdscan(wp, EOS);
			break;
		case COMSUB:
d619 2
a620 2
			wdstrip_internal(shf, wp, keepq, make_magic);
			wp = wdscan(wp, EOS);
d825 1
d832 2
a833 5
			shf_puts("EXPRSUB[", shf);
			dumpwdvar(shf, wp);
			wp = wdscan(wp, EOS);
			shf_puts("]EXPRSUB", shf);
			break;
@


1.37
log
@• add a tree debugging dumper #ifdef DEBUG
• use shf_putc (macro), shf_putchar (function) ipv tputc
• replace shf_putchar(x,y) calls for side-effect-less x with shf_putc
• plug another bug in the tree code – '\' → "\\" (backslashes must be
  escaped inside double quotes, too)
• adjust testsuite (and, I _had_ wondered…)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.36 2011/03/06 17:08:14 tg Exp $");
d35 1
d305 2
a306 2
			while ((c = *wp++) != 0)
				shf_putc(c, shf);
d530 3
a533 1
		case EXPRSUB:
a576 1
	int c;
d579 9
d598 1
a598 2
			/* shf_sclose NUL terminates */
			return (shf_sclose(&shf));
d604 2
a605 2
				shf_putc(MAGIC, &shf);
			shf_putc(c, &shf);
d610 2
a611 2
				shf_putc('\\', &shf);
			shf_putc(c, &shf);
d614 4
a617 4
			shf_puts("$(", &shf);
			while (*wp != 0)
				shf_putchar(*wp++, &shf);
			shf_putc(')', &shf);
d620 4
a623 4
			shf_puts("$((", &shf);
			while (*wp != 0)
				shf_putchar(*wp++, &shf);
			shf_puts("))", &shf);
d630 1
a630 1
			shf_putc('$', &shf);
d632 1
a632 1
			    shf_putc('{', &shf);
d634 1
a634 1
				shf_putc(c, &shf);
d638 1
a638 1
				shf_putc('}', &shf);
d642 2
a643 2
				shf_putc(MAGIC, &shf);
				shf_putchar(*wp++ | 0x80, &shf);
d645 2
a646 2
				shf_putchar(*wp++, &shf);
				shf_putc('(', &shf);
d651 2
a652 2
				shf_putc(MAGIC, &shf);
			shf_putc('|', &shf);
d656 2
a657 2
				shf_putc(MAGIC, &shf);
			shf_putc(')', &shf);
d799 1
a799 1
static void
a826 1
 dumpsub:
d833 5
a837 2
			shf_puts("EXPRSUB<", shf);
			goto dumpsub;
@


1.36
log
@• more fixes (some regression, some new)
• more testcases, stricter testcases
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.35 2011/03/06 02:28:59 tg Exp $");
a28 1
#define tputc(c, shf) shf_putchar(c, shf);
d204 1
a204 1
				tputc('\n', shf);
d217 1
a217 1
			tputc('\n', shf);
d260 1
a260 1
			tputc(' ', shf);
d287 1
a287 1
			tputc(*wp++, shf);
d291 4
a294 3
			if (!quotelevel || (c == '"' || c == '`' || c == '$'))
				tputc('\\', shf);
			tputc(c, shf);
d298 3
a300 4
			while (*wp != 0)
				tputc(*wp++, shf);
			tputc(')', shf);
			wp++;
d304 2
a305 2
			while (*wp != 0)
				tputc(*wp++, shf);
a306 1
			wp++;
d310 1
a310 1
			tputc('"', shf);
d315 1
a315 1
			tputc('"', shf);
d318 1
a318 1
			tputc('$', shf);
d320 1
a320 1
				tputc('{', shf);
d322 1
a322 1
				tputc(c, shf);
d326 1
a326 1
				tputc('}', shf);
d329 2
a330 2
			tputc(*wp++, shf);
			tputc('(', shf);
d333 1
a333 1
			tputc('|', shf);
d336 1
a336 1
			tputc(')', shf);
d383 1
a383 1
				tputc(va_arg(va, int), shf);
d411 2
a412 2
						tputc(';', shf);
					tputc(' ', shf);
d416 1
a416 1
					tputc('\n', shf);
d419 1
a419 1
						tputc('\t', shf);
d423 1
a423 1
						tputc(' ', shf);
d431 1
a431 1
				tputc(c, shf);
d435 1
a435 1
			tputc(c, shf);
d594 2
a595 2
				shf_putchar(MAGIC, &shf);
			shf_putchar(c, &shf);
d600 2
a601 2
				shf_putchar('\\', &shf);
			shf_putchar(c, &shf);
d607 1
a607 1
			shf_putchar(')', &shf);
d620 1
a620 1
			shf_putchar('$', &shf);
d622 1
a622 1
			    shf_putchar('{', &shf);
d624 1
a624 1
				shf_putchar(c, &shf);
d628 1
a628 1
				shf_putchar('}', &shf);
d632 1
a632 1
				shf_putchar(MAGIC, &shf);
d636 1
a636 1
				shf_putchar('(', &shf);
d641 2
a642 2
				shf_putchar(MAGIC, &shf);
			shf_putchar('|', &shf);
d646 2
a647 2
				shf_putchar(MAGIC, &shf);
			shf_putchar(')', &shf);
d775 270
@


1.35
log
@another _two_, gosh!
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.34 2011/03/06 02:14:09 tg Exp $");
d27 1
a27 1
#define INDENT	4
d32 1
a32 2
static void tputC(int, struct shf *);
static void tputS(char *, struct shf *);
d37 3
d49 1
d56 3
a58 2
		if (t->vars)
			for (w = (const char **)t->vars; *w != NULL; )
d60 1
a60 1
		else
d62 3
a64 2
		if (t->args)
			for (w = t->args; *w != NULL; )
d66 1
a66 1
		else
d68 1
d87 1
a87 1
		    t->left, (t->type==TOR) ? "||" : "&&", t->right);
d91 1
d94 2
a95 3
	case TDBRACKET: {
		int i;

d97 2
a98 2
		for (i = 0; t->args[i]; i++)
			fptreef(shf, indent, " %S", t->args[i]);
a100 1
	}
a101 2
		fptreef(shf, indent, "select %s ", t->str);
		/* FALLTHROUGH */
d103 2
a104 2
		if (t->type == TFOR)
			fptreef(shf, indent, "for %s ", t->str);
d107 2
a108 1
			for (w = (const char **)t->vars; *w; )
d119 2
a120 1
			for (w = (const char **)t1->vars; *w != NULL; w++)
d123 2
d129 5
d135 9
a143 4
	case TELIF:
		/* 3 == strlen("if ") */
		fptreef(shf, indent + 3, "if %T", t->left);
		for (;;) {
d147 2
a148 2
				fptreef(shf, indent + INDENT, "then%N%T",
				    t->left);
d150 1
a150 7
			if (t->right == NULL || t->right->type != TELIF)
				break;
			t = t->right;
			fptreef(shf, indent, "%;");
			/* 5 == strlen("elif ") */
			fptreef(shf, indent + 5, "elif %T", t->left);
		}
d153 2
a154 1
			fptreef(shf, indent + INDENT, "else%N%T", t->right);
d162 1
a162 1
		    (t->type==TWHILE) ? "while" : "until",
d164 2
a165 2
		fptreef(shf, indent, "%;do ");
		fptreef(shf, indent + INDENT, "%T", t->right);
d174 1
d178 1
d188 1
d192 1
a192 1
		int	need_nl = 0;
d197 2
a198 1
		for (ioact = t->ioact; *ioact != NULL; ) {
d209 1
a209 1
				need_nl = 1;
d212 4
a215 3
		/* Last delimiter must be followed by a newline (this often
		 * leads to an extra blank line, but its not worth worrying
		 * about)
d238 1
a238 1
		shf_puts("< ", shf);
d244 1
a244 1
		shf_puts(">> ", shf);
d247 1
a247 1
		shf_puts(flag & IOCLOB ? ">| " : "> ", shf);
d250 1
a250 1
		shf_puts("<> ", shf);
d256 1
a256 1
	/* name/delim are 0 when printing syntax errors */
d259 1
a259 3
			fptreef(shf, indent, "%s%S ",
			    /* here string */ iop->delim[1] == '<' ? "" : " ",
			    iop->delim);
d265 1
d268 1
a268 4

/*
 * variants of fputc, fputs for ptreef and snptreef
 */
d270 1
a270 14
tputC(int c, struct shf *shf)
{
	if ((c&0x60) == 0) {		/* C0|C1 */
		tputc((c&0x80) ? '$' : '^', shf);
		tputc(((c&0x7F)|0x40), shf);
	} else if ((c&0x7F) == 0x7F) {	/* DEL */
		tputc((c&0x80) ? '$' : '^', shf);
		tputc('?', shf);
	} else
		tputc(c, shf);
}

static void
tputS(char *wp, struct shf *shf)
d274 2
a275 1
	/* problems:
d288 1
a288 1
			tputC(*wp++, shf);
d294 1
a294 1
			tputC(c, shf);
d299 1
a299 1
				tputC(*wp++, shf);
d306 1
a306 1
				tputC(*wp++, shf);
d324 1
a324 1
				tputC(c, shf);
d348 1
a348 1
int
a353 1

a355 1
	return (0);
d371 2
a372 1
	return (shf_sclose(&shf)); /* null terminates */
d384 1
d388 1
d391 2
a392 1
			case 'S':	/* word */
d395 2
a396 1
			case 'd':	/* decimal */
d399 2
a400 1
			case 'u':	/* decimal */
d403 2
a404 1
			case 'T':	/* format tree */
d406 5
a410 3
				break;
			case ';':	/* newline or ; */
			case 'N':	/* newline or space */
d412 1
a412 1
					if (c == ';')
d419 2
a420 1
					for (i = indent; i >= 8; i -= 8)
d422 3
a424 1
					for (; i > 0; --i)
d429 1
d438 3
d470 3
a472 2
		for (tw = (const char **)t->vars; *tw++ != NULL; )
			;
d475 2
a476 1
		for (tw = (const char **)t->vars; *tw != NULL; )
d484 3
a486 2
		for (tw = t->args; *tw++ != NULL; )
			;
d489 2
a490 1
		for (tw = t->args; *tw != NULL; )
d507 3
a509 1
	size_t len = wdscan(wp, EOS) - wp;
d568 3
a570 3
/* return a copy of wp without any of the mark up characters and
 * with quote characters (" ' \) stripped.
 * (string is allocated from ATEMP)
d580 2
a581 1
	/* problems:
d589 2
a590 1
			return (shf_sclose(&shf)); /* null terminates */
d660 3
a662 2
	for (ior = iow; *ior++ != NULL; )
		;
d705 1
d707 1
a707 1
		/* XXX we assume the caller is right */
d729 2
a730 1
	for (iop = iow; (p = *iop++) != NULL; ) {
d742 1
a742 1
int
d746 1
a746 1
		return (fptreef(shf, i, "%s %s %T", T_function, k, v));
d748 28
a775 1
		return (fptreef(shf, i, "%s() %T", k, v));
@


1.34
log
@plug _another_ %; versus %N output formatting bug

(apparently, nobody noticed them because everyone outputted to files,
not to strings, and this logic differs for those)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.33 2011/03/06 00:52:02 tg Exp $");
d142 1
a142 1
			fptreef(shf, indent + INDENT, "else%;%T", t->right);
d152 2
a153 2
		fptreef(shf, indent, "%;do");
		fptreef(shf, indent + INDENT, "%;%T", t->right);
@


1.33
log
@dump TCASE as "case $foo in (1) blah ;; esac" not "… (1); blah …"
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.32 2010/09/14 21:26:19 tg Exp $");
d157 1
a157 1
		fptreef(shf, indent + INDENT, "{%;%T", t->left);
@


1.32
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.31 2010/08/28 20:22:24 tg Exp $");
d118 1
a118 1
			fptreef(shf, indent + INDENT, "%;%T%N;;", t1->left);
@


1.31
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.30 2010/02/25 20:18:19 tg Exp $");
d457 1
a457 1
		rw = r->vars = alloc((tw - (const char **)t->vars + 1) *
d469 1
a469 1
		r->args = (const char **)(rw = alloc((tw - t->args + 1) *
d639 1
a639 1
	ior = alloc((ior - iow + 1) * sizeof(struct ioword *), ap);
@


1.30
log
@(hopefully) fix the substitution thing for good
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.29 2010/01/29 09:34:31 tg Exp $");
d167 1
a167 3
		fptreef(shf, indent,
		    t->u.ksh_func ? "function %s %T" : "%s() %T",
		    t->str, t->left);
d170 1
a170 1
		fptreef(shf, indent, "time %T", t->left);
d715 9
@


1.29
log
@remove some more of this ugliness
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.28 2009/06/10 18:12:50 tg Exp $");
d274 1
a274 2
	int c;
	bool quoted = false;
d293 1
a293 1
			if (!quoted || (c == '"' || c == '`' || c == '$'))
d312 1
a312 1
			quoted = true;
d316 2
a317 1
			quoted = false;
@


1.28
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.27 2009/06/08 20:06:49 tg Exp $");
d98 1
a98 1
		/* FALLTHRU */
@


1.27
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.26 2009/05/16 16:59:41 tg Exp $");
d87 1
a87 2
	case TDBRACKET:
	  {
d95 1
a95 1
	  }
@


1.26
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.25 2009/04/07 19:13:11 tg Exp $");
d443 1
a443 1
		return NULL;
d445 1
a445 1
	r = alloc(sizeof (struct op), ap);
d461 1
a461 1
		    sizeof (*tw), ap);
d473 1
a473 1
		    sizeof (*tw), ap));
d485 1
a485 1
	return r;
d492 1
a492 1
	return memcpy(alloc(len, ap), wp, len);
d570 1
a570 1
			return shf_sclose(&shf); /* null terminates */
d642 1
a642 1
	ior = alloc((ior - iow + 1) * sizeof (struct ioword *), ap);
d648 1
a648 1
		q = alloc(sizeof (struct ioword), ap);
d660 1
a660 1
	return ior;
@


1.25
log
@some int->bool, KNF, ...
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.24 2008/12/13 17:02:17 tg Exp $");
@


1.24
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.23 2008/11/12 00:54:51 tg Exp $");
d9 1
a9 1
#define tputc(c, shf)	shf_putchar(c, shf);
d255 2
a256 1
	int c, quoted=0;
d294 1
a294 1
			quoted = 1;
d298 1
a298 1
			quoted = 0;
@


1.23
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.22 2008/11/11 23:50:31 tg Exp $");
d15 2
a16 2
static struct ioword **iocopy(struct ioword **, PArea);
static void iofree(struct ioword **, PArea);
d415 1
a415 1
tcopy(struct op *t, PArea ap)
d424 1
a424 1
	r = alloc(1, sizeof (struct op), ap);
d439 1
a439 1
		rw = r->vars = alloc((tw - (const char **)t->vars + 1),
d451 1
a451 1
		r->args = (const char **)(rw = alloc((tw - t->args + 1),
d468 1
a468 1
wdcopy(const char *wp, PArea ap)
d471 1
a471 1
	return memcpy(alloc(1, len, ap), wp, len);
d614 1
a614 1
iocopy(struct ioword **iow, PArea ap)
d621 1
a621 1
	ior = alloc((ior - iow + 1), sizeof (struct ioword *), ap);
d627 1
a627 1
		q = alloc(1, sizeof (struct ioword), ap);
d646 1
a646 1
tfree(struct op *t, PArea ap)
d681 1
a681 1
iofree(struct ioword **iow, PArea ap)
@


1.23.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.23 2008/11/12 00:54:51 tg Exp $");
d15 2
a16 2
static struct ioword **iocopy(struct ioword **, PGroup);
static void iofree(struct ioword **, PGroup);
d415 1
a415 1
tcopy(struct op *t, PGroup ap)
d424 1
a424 1
	r = galloc(1, sizeof (struct op), ap);
d439 1
a439 1
		rw = r->vars = galloc((tw - (const char **)t->vars + 1),
d451 1
a451 1
		r->args = (const char **)(rw = galloc((tw - t->args + 1),
d468 1
a468 1
wdcopy(const char *wp, PGroup ap)
d471 1
a471 1
	return memcpy(galloc(1, len, ap), wp, len);
d614 1
a614 1
iocopy(struct ioword **iow, PGroup ap)
d621 1
a621 1
	ior = galloc((ior - iow + 1), sizeof (struct ioword *), ap);
d627 1
a627 1
		q = galloc(1, sizeof (struct ioword), ap);
d646 1
a646 1
tfree(struct op *t, PGroup ap)
d654 1
a654 1
		gfree(t->str, ap);
d658 2
a659 2
			gfree(*w, ap);
		gfree(t->vars, ap);
d667 2
a668 2
			gfree(*w, ap);
		gfree(t->args, ap);
d677 1
a677 1
	gfree(t, ap);
d681 1
a681 1
iofree(struct ioword **iow, PGroup ap)
d688 1
a688 1
			gfree(p->name, ap);
d690 1
a690 1
			gfree(p->delim, ap);
d692 2
a693 2
			gfree(p->heredoc, ap);
		gfree(p, ap);
d695 1
a695 1
	gfree(iow, ap);
@


1.22
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.21 2008/10/28 14:32:43 tg Exp $");
d424 1
a424 1
	r = (struct op *)alloc(sizeof (struct op), ap);
d439 2
a440 2
		rw = r->vars = (char **)alloc((tw -
		    (const char **)t->vars + 1) * sizeof (*tw), ap);
d451 2
a452 2
		r->args = (const char **)(rw = (char **)alloc((tw -
		    t->args + 1) * sizeof (*tw), ap));
d471 1
a471 1
	return memcpy(alloc(len, ap), wp, len);
d621 1
a621 1
	ior = (struct ioword **)alloc((ior - iow + 1) * sizeof (*ior), ap);
d627 1
a627 1
		q = (struct ioword *)alloc(sizeof (*p), ap);
d654 1
a654 1
		afree((void*)t->str, ap);
d658 2
a659 2
			afree((void*)*w, ap);
		afree((void*)t->vars, ap);
d667 2
a668 2
			afree((void*)*w, ap);
		afree((void*)t->args, ap);
d677 1
a677 1
	afree((void*)t, ap);
d688 1
a688 1
			afree((void*)p->name, ap);
d690 1
a690 1
			afree((void*)p->delim, ap);
d692 2
a693 2
			afree((void*)p->heredoc, ap);
		afree((void*)p, ap);
@


1.21
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.20 2008/10/13 23:06:04 tg Exp $");
d15 2
a16 2
static struct ioword **iocopy(struct ioword **, Area *);
static void iofree(struct ioword **, Area *);
d415 1
a415 1
tcopy(struct op *t, Area *ap)
d468 1
a468 1
wdcopy(const char *wp, Area *ap)
d614 1
a614 1
iocopy(struct ioword **iow, Area *ap)
d646 1
a646 1
tfree(struct op *t, Area *ap)
d681 1
a681 1
iofree(struct ioword **iow, Area *ap)
@


1.20
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.19 2008/09/14 20:29:13 tg Exp $");
d429 4
a432 1
	r->str = t->type == TCASE ? wdcopy(t->str, ap) : str_save(t->str, ap);
d635 1
a635 1
			q->heredoc = str_save(p->heredoc, ap);
@


1.19
log
@pull in another fix from oksh:

plug a memleak when freeing io redirection in commands.
the leaked memory is actually reclaimed when the command
finishes but may grow until that happens, e.g. during
command execution.

ok phessler@@.
testing sobrado@@ jmc@@ oga@@.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.18 2008/07/09 21:32:45 tg Exp $");
d265 1
a265 1
		switch ((c = *wp++)) {
d544 1
a544 1
		switch ((c = *wp++)) {
@


1.18
log
@• bump NUFILE and FDBASE, allowing for more than 10 fds used by scripts
• change the code to accept more than a single digit for an fd
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.18 2006/04/10 14:38:59 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.17 2008/05/17 18:47:02 tg Exp $");
d692 1
@


1.17
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.16 2008/04/19 22:15:06 tg Exp $");
d200 1
a200 1
		tputc('0' + iop->unit, shf);
@


1.16
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.15 2008/03/01 21:10:26 tg Exp $");
d424 1
a424 1
	r = (struct op *) alloc(sizeof(struct op), ap);
d436 2
a437 2
		rw = r->vars = (char **)
		    alloc((tw - (const char **)t->vars + 1) * sizeof(*tw), ap);
d448 2
a449 2
		r->args = (const char **)(rw = (char **)
			alloc((tw - t->args + 1) * sizeof(*tw), ap));
d618 1
a618 1
	ior = (struct ioword **) alloc((ior - iow + 1) * sizeof(*ior), ap);
d624 1
a624 1
		q = (struct ioword *) alloc(sizeof(*p), ap);
@


1.15
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.14 2008/02/26 21:08:33 tg Exp $");
d378 1
a378 1
				shf_fprintf(shf, "%u", va_arg(va, unsigned));
@


1.15.2.1
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.17 2008/05/17 18:47:02 tg Exp $");
d378 1
a378 1
				shf_fprintf(shf, "%u", va_arg(va, unsigned int));
d424 1
a424 1
	r = (struct op *)alloc(sizeof (struct op), ap);
d436 2
a437 2
		rw = r->vars = (char **)alloc((tw -
		    (const char **)t->vars + 1) * sizeof (*tw), ap);
d448 2
a449 2
		r->args = (const char **)(rw = (char **)alloc((tw -
		    t->args + 1) * sizeof (*tw), ap));
d618 1
a618 1
	ior = (struct ioword **)alloc((ior - iow + 1) * sizeof (*ior), ap);
d624 1
a624 1
		q = (struct ioword *)alloc(sizeof (*p), ap);
@


1.15.2.2
log
@MFC: mksh R35
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.18 2008/07/09 21:32:45 tg Exp $");
d200 1
a200 1
		shf_fprintf(shf, "%d", iop->unit);
@


1.15.2.3
log
@MFC: mksh R36b
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.19 2008/08/11 21:50:35 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.24 2008/12/13 17:02:17 tg Exp $");
d265 1
a265 1
		switch (*wp++) {
d424 1
a424 1
	r = alloc(sizeof (struct op), ap);
d429 1
a429 4
	if (t->type == TCASE)
		r->str = wdcopy(t->str, ap);
	else
		strdupx(r->str, t->str, ap);
d436 2
a437 2
		rw = r->vars = alloc((tw - (const char **)t->vars + 1) *
		    sizeof (*tw), ap);
d448 2
a449 2
		r->args = (const char **)(rw = alloc((tw - t->args + 1) *
		    sizeof (*tw), ap));
d544 1
a544 1
		switch (*wp++) {
d618 1
a618 1
	ior = alloc((ior - iow + 1) * sizeof (struct ioword *), ap);
d624 1
a624 1
		q = alloc(sizeof (struct ioword), ap);
d632 1
a632 1
			strdupx(q->heredoc, p->heredoc, ap);
d651 1
a651 1
		afree(t->str, ap);
d655 2
a656 2
			afree(*w, ap);
		afree(t->vars, ap);
d664 2
a665 2
			afree(*w, ap);
		afree(t->args, ap);
d674 1
a674 1
	afree(t, ap);
d685 1
a685 1
			afree(p->name, ap);
d687 1
a687 1
			afree(p->delim, ap);
d689 2
a690 2
			afree(p->heredoc, ap);
		afree(p, ap);
a691 1
	afree(iow, ap);
@


1.14
log
@clean up, optimise, comment code
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.13 2008/02/26 20:43:11 tg Exp $");
d531 1
a531 1
wdstrip(const char *wp)
d541 1
a541 1
	 *	x${foo:-'hi'} -> x${foo:-hi}
d549 6
d556 4
a559 1
			shf_putchar(*wp++, &shf);
d589 7
a595 2
			shf_putchar(*wp++, &shf);
			shf_putchar('(', &shf);
d598 2
d603 2
@


1.13
log
@implement “here strings”
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.12 2007/10/25 15:19:16 tg Exp $");
d37 1
a37 1
			fptreef(shf, indent, "#no-vars# ");
d42 1
a42 1
			fptreef(shf, indent, "#no-args# ");
d64 1
a64 1
		fptreef(shf, indent, "! ");
d71 1
a71 1
		fptreef(shf, indent, "[[");
d74 1
a74 1
		fptreef(shf, indent, " ]] ");
d84 1
a84 1
			fptreef(shf, indent, "in ");
d156 1
a156 1
		fptreef(shf, indent, "<botch>");
d170 1
d204 1
a204 1
		fptreef(shf, indent, "< ");
d207 1
a207 4
		if (flag&IOSKIP)
			fptreef(shf, indent, "<<-");
		else
			fptreef(shf, indent, "<<");
d210 1
a210 1
		fptreef(shf, indent, ">> ");
d213 1
a213 4
		if (flag&IOCLOB)
			fptreef(shf, indent, ">| ");
		else
			fptreef(shf, indent, "> ");
d216 1
a216 1
		fptreef(shf, indent, "<> ");
d219 1
a219 4
		if (flag & IORDUP)
			fptreef(shf, indent, "<&");
		else
			fptreef(shf, indent, ">&");
d224 5
a228 1
		if ((flag & IOSKIP) || (iop->delim[1] != '<'))
a229 2
		if (iop->delim)
			fptreef(shf, indent, "%S ", iop->delim);
d279 1
a279 2
			tputc('$', shf);
			tputc('(', shf);
d286 1
a286 3
			tputc('$', shf);
			tputc('(', shf);
			tputc('(', shf);
d289 1
a289 2
			tputc(')', shf);
			tputc(')', shf);
d553 1
a553 2
			shf_putchar('$', &shf);
			shf_putchar('(', &shf);
d559 1
a559 3
			shf_putchar('$', &shf);
			shf_putchar('(', &shf);
			shf_putchar('(', &shf);
d562 1
a562 2
			shf_putchar(')', &shf);
			shf_putchar(')', &shf);
@


1.12
log
@optimise (struct padding, function→macro, etc.)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.11 2007/07/06 01:53:36 tg Exp $");
d169 2
a170 1
			if ((iop->flag & IOTYPE) == IOHERE && iop->heredoc) {
d207 1
a207 1
			fptreef(shf, indent, "<<- ");
d209 1
a209 1
			fptreef(shf, indent, "<< ");
d232 2
@


1.11
log
@make this pass varexpand-substr-1 and ‘c’ of varexpand-substr-2
by actually using the lexer and parser for that
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.10 2007/05/13 17:51:24 tg Exp $");
d339 1
a339 1
  va_list	va;
d341 1
a341 1
  va_start(va, fmt);
d343 3
a345 3
  vfptreef(shf, indent, fmt, va);
  va_end(va);
  return 0;
d352 2
a353 2
  va_list va;
  struct shf shf;
d355 1
a355 1
  shf_sopen(s, n, SHF_WR | (s ? 0 : SHF_DYNAMIC), &shf);
d357 3
a359 3
  va_start(va, fmt);
  vfptreef(&shf, 0, fmt, va);
  va_end(va);
d361 1
a361 1
  return shf_sclose(&shf); /* null terminates */
@


1.10
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.9 2007/03/04 03:04:28 tg Exp $");
d271 1
d488 4
d554 1
@


1.9
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.8 2007/03/04 00:13:17 tg Exp $");
d522 1
a522 1
			internal_errorf(0,
@


1.9.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.9 2007/03/04 03:04:28 tg Exp $");
d522 1
a522 1
			internal_warningf(
@


1.8
log
@merge the const branch +- a few
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d10 5
a14 5
static void	ptree(struct op *, int, struct shf *);
static void	pioact(struct shf *, int, struct ioword *);
static void	tputC(int, struct shf *);
static void	tputS(char *, struct shf *);
static void	vfptreef(struct shf *, int, const char *, va_list);
d16 1
a16 1
static void     iofree(struct ioword **, Area *);
@


1.7
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.6 2006/11/10 00:09:27 tg Exp $");
a20 1

d24 1
a24 1
	char **w;
d34 1
a34 1
			for (w = t->vars; *w != NULL; )
d85 1
a85 1
			for (w = t->vars; *w; )
d96 1
a96 1
			for (w = t1->vars; *w != NULL; w++)
a241 1

a419 1

d424 2
a425 1
	char **tw, **rw;
d440 1
a440 1
		for (tw = t->vars; *tw++ != NULL; )
d443 2
a444 2
			alloc((tw - t->vars + 1) * sizeof(*tw), ap);
		for (tw = t->vars; *tw != NULL; )
d454 2
a455 2
		rw = r->args = (char **)
			alloc((tw - t->args + 1) * sizeof(*tw), ap);
d597 1
a597 1
static	struct ioword **
a628 1

d647 4
a650 1
		for (w = t->args; *w != NULL; w++)
d664 1
a664 1
static	void
@


1.7.2.1
log
@finish constification for now, passes regression tests but untested
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.7 2006/11/12 14:58:16 tg Exp $");
d25 1
a25 1
	const char **w;
d35 1
a35 1
			for (w = (const char **)t->vars; *w != NULL; )
d86 1
a86 1
			for (w = (const char **)t->vars; *w; )
d97 1
a97 1
			for (w = (const char **)t1->vars; *w != NULL; w++)
d422 1
d427 1
a427 2
	const char **tw;
	char **rw;
d442 1
a442 1
		for (tw = (const char **)t->vars; *tw++ != NULL; )
d445 2
a446 2
		    alloc((tw - (const char **)t->vars + 1) * sizeof(*tw), ap);
		for (tw = (const char **)t->vars; *tw != NULL; )
d456 2
a457 2
		r->args = (const char **)(rw = (char **)
			alloc((tw - t->args + 1) * sizeof(*tw), ap));
d650 1
a650 4
		union mksh_ccphack cw;
		/* XXX we assume the caller is right */
		cw.ro = t->args;
		for (w = cw.rw; *w != NULL; w++)
@


1.6
log
@save 176 text (92 text 32 bss relative to before last commit)
by making correct use of shf_* functions
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.5 2006/11/09 23:55:52 tg Exp $");
d480 1
a480 1
char *
d488 1
a488 1
			return (char *) wp;
d509 1
a509 1
				return (char *) wp;
d519 1
a519 1
				return (char *) wp;
@


1.5
log
@get rid of ulton() - a joke
saves 32 bss, but adds 84 text oO
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.4 2006/05/10 18:54:13 tg Exp $");
a371 3
			long n;
			char *p;

d377 1
a377 3
				p = va_arg(va, char *);
				while (*p)
					tputc(*p++, shf);
d380 7
a386 2
				p = va_arg(va, char *);
				tputS(p, shf);
a387 10
			case 'd': case 'u': { /* decimal */
				char tmpbuf[12];

				n = (c == 'd') ? (long)va_arg(va, int) :
				    (long)va_arg(va, unsigned int);
				shf_snprintf((p = tmpbuf), 12,
				    (c == 'd') ? "%ld" : "%lu", n);
				while (*p)
					tputc(*p++, shf);
				} break;
@


1.4
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.3 2005/11/22 18:40:44 tg Exp $");
a373 1
			int neg;
d388 3
a390 1
			case 'd': case 'u': /* decimal */
d393 2
a394 4
				neg = c=='d' && n<0;
				p = ulton((neg) ? -n : n, 10);
				if (neg)
					*--p = '-';
d397 1
a397 1
				break;
@


1.3
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.17 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.2 2005/06/08 22:34:03 tg Exp $");
@


1.2
log
@some lint cleanup
@
text
@a0 1
/**	$MirOS: src/bin/mksh/tree.c,v 1.1 2005/05/23 03:06:10 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.1 2005/05/23 03:06:10 tg Exp $");
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/tree.c,v 1.5 2005/05/23 02:20:36 tg Exp $ */
d6 1
a6 1
__RCSID("$MirOS: mksh/tree.c,v 1.5 2005/05/23 02:20:36 tg Exp $");
d81 1
a81 1
		/* fall through */
@

