head	1.169;
access;
symbols
	mksh-R57:1.167
	mksh-R56c:1.166
	mksh-R56b:1.166
	mksh-R56:1.166
	mksh-R55:1.160
	mksh-R54:1.159
	mksh-R53a:1.158
	mksh-R53:1.158
	mksh-R52c:1.156
	mksh-R52b:1.152
	mksh-R52:1.151
	mksh-R51:1.149
	mksh-R50f:1.134.2.5
	mksh-R50e:1.134.2.3
	mksh-R50stable:1.134.0.2
	mksh-R50d:1.134
	mksh-R50c:1.134
	mksh-R50b:1.134
	mksh-R50:1.134
	mksh-R49:1.133
	mksh-R48b:1.131
	mksh-R48:1.131
	mksh-R47:1.131
	mksh-R46:1.131
	mksh-R45:1.131
	mksh-R44:1.131
	mksh-R43:1.131
	mksh-R42b:1.131
	mksh-R41c:1.128.2.2
	mksh-R41b:1.128.2.2
	mksh-R42:1.131
	mksh-R41:1.128
	mksh-R41stable:1.128.0.2
	mksh-wheezy:1.126.0.2
	tg-multikey-bind:1.125.0.2
	mksh-R40f:1.122
	mksh-R40e:1.117
	mksh-R40d:1.113
	mksh-R40c:1.111
	mksh-R40b:1.109
	mksh-R40stable:1.122.0.2
	mksh-R40:1.109
	mksh-R39c:1.92
	mksh-R39b:1.92
	tg-wcswidth-behaviour:1.89.0.2
	tg-nameref:1.88.0.2
	mksh-R39:1.87
	tg-mksh-printf-builtin:1.86.0.2
	mksh-R38c:1.84
	mksh-R38b:1.82
	mksh-R38:1.82
	mksh-R37c:1.79
	mksh-R37b:1.77
	mksh-R37:1.77
	mksh-R36b:1.76
	tg-aalloc-experimental_BASE:1.75
	tg-aalloc-experimental:1.75.0.2
	mksh-R36:1.72
	mksh-R35b:1.67
	mksh-R35:1.65
	mksh-R33d:1.60
	mksh-R33c:1.60
	mksh-R33b:1.59
	MIRBSD_10:1.58.0.2
	MIRBSD_10_BASE:1.58
	mksh-R33:1.57
	mksh-R32:1.57
	mksh-R31d:1.56
	mksh-R31c:1.56
	mksh-R31b:1.56
	mksh-R31:1.55
	mksh-R30:1.53
	mksh-R29g:1.45.2.2
	mksh-R29f:1.45.2.1
	mksh-R29e:1.45.2.1
	mksh-R29stable:1.45.0.2
	mksh-R29d:1.45
	mksh-R29c:1.45
	mksh-R29b:1.45
	mksh-R29:1.45
	mksh-R28:1.25
	tg-mksh-plan9ape_BASE:1.25
	tg-mksh-plan9ape:1.23.0.2
	mksh-R27e:1.15
	MIRBSD_9_BASE:1.15
	mksh-R27d:1.15
	mksh-R27:1.15
	mksh-R26c:1.14
	mksh-R26b:1.13
	MIRBSD_8:1.13.0.2
	MIRBSD_8_BASE:1.13
	mksh-R26:1.13
	mksh-R25:1.12
	mksh-R24c:1.11
	mksh-R24b:1.11
	mksh-R24:1.10
	mksh-R23:1.8
	mksh-R22:1.8
	mksh-R21:1.8;
locks; strict;
comment	@ * @;


1.169
date	2019.09.16.21.10.33;	author tg;	state Exp;
branches;
next	1.168;
commitid	1005D7FFA5F48A3E957;

1.168
date	2019.09.10.19.52.52;	author tg;	state Exp;
branches;
next	1.167;
commitid	1005D77FF244A8936BA;

1.167
date	2018.04.28.17.16.54;	author tg;	state Exp;
branches;
next	1.166;
commitid	1005AE4AC960C059B83;

1.166
date	2017.08.07.23.25.09;	author tg;	state Exp;
branches;
next	1.165;
commitid	1005988F6E8125F87CA;

1.165
date	2017.08.07.23.15.47;	author tg;	state Exp;
branches;
next	1.164;
commitid	1005988F4B24E5A4472;

1.164
date	2017.08.07.20.43.00;	author tg;	state Exp;
branches;
next	1.163;
commitid	1005988D0DB27F10F32;

1.163
date	2017.08.07.20.40.57;	author tg;	state Exp;
branches;
next	1.162;
commitid	1005988D0430B222211;

1.162
date	2017.04.29.22.04.28;	author tg;	state Exp;
branches;
next	1.161;
commitid	10059050DFF02CF9B3E;

1.161
date	2017.04.27.19.33.49;	author tg;	state Exp;
branches;
next	1.160;
commitid	100590247A92C66CAF9;

1.160
date	2017.04.08.01.07.16;	author tg;	state Exp;
branches;
next	1.159;
commitid	10058E837C565871E52;

1.159
date	2016.11.11.18.44.32;	author tg;	state Exp;
branches;
next	1.158;
commitid	1005826119C559470A3;

1.158
date	2016.08.04.20.31.00;	author tg;	state Exp;
branches;
next	1.157;
commitid	10057A3A5F96CCF061E;

1.157
date	2016.07.25.00.04.43;	author tg;	state Exp;
branches;
next	1.156;
commitid	1005795579F14A3FE5C;

1.156
date	2016.03.04.14.26.13;	author tg;	state Exp;
branches;
next	1.155;
commitid	10056D99B037D4D691D;

1.155
date	2016.03.01.18.29.48;	author tg;	state Exp;
branches;
next	1.154;
commitid	10056D5DFB5316A8209;

1.154
date	2016.02.24.01.45.59;	author tg;	state Exp;
branches;
next	1.153;
commitid	10056CD0B461C588CEB;

1.153
date	2016.01.21.18.24.40;	author tg;	state Exp;
branches;
next	1.152;
commitid	10056A12268001BF859;

1.152
date	2016.01.14.23.18.08;	author tg;	state Exp;
branches;
next	1.151;
commitid	10056982CC2089C928B;

1.151
date	2015.11.29.17.05.01;	author tg;	state Exp;
branches;
next	1.150;
commitid	100565B305567B17D70;

1.150
date	2015.09.05.19.19.05;	author tg;	state Exp;
branches;
next	1.149;
commitid	10055EB402C54C3076B;

1.149
date	2015.07.09.20.52.40;	author tg;	state Exp;
branches;
next	1.148;
commitid	100559EDF161DEE9DD2;

1.148
date	2015.07.05.19.53.45;	author tg;	state Exp;
branches;
next	1.147;
commitid	10055998B5B2E027FD0;

1.147
date	2015.07.05.19.37.15;	author tg;	state Exp;
branches;
next	1.146;
commitid	1005599876B5247136B;

1.146
date	2015.07.05.17.04.26;	author tg;	state Exp;
branches;
next	1.145;
commitid	1005599636613028AB4;

1.145
date	2015.07.05.16.48.28;	author tg;	state Exp;
branches;
next	1.144;
commitid	10055995FD3347F2D22;

1.144
date	2015.07.05.16.47.28;	author tg;	state Exp;
branches;
next	1.143;
commitid	10055995F8E525A617A;

1.143
date	2015.04.29.20.44.35;	author tg;	state Exp;
branches;
next	1.142;
commitid	100554142C5624212CA;

1.142
date	2015.04.29.19.11.57;	author tg;	state Exp;
branches;
next	1.141;
commitid	10055412CFF40F046F9;

1.141
date	2015.04.19.18.50.36;	author tg;	state Exp;
branches;
next	1.140;
commitid	1005533F8D6407346B7;

1.140
date	2015.03.07.20.46.28;	author tg;	state Exp;
branches;
next	1.139;
commitid	10054FB63890799A9FA;

1.139
date	2015.02.06.10.09.06;	author tg;	state Exp;
branches;
next	1.138;
commitid	10054D492CC303A2CB1;

1.138
date	2015.01.22.16.54.29;	author tg;	state Exp;
branches;
next	1.137;
commitid	10054C12B5A2C0CB8B1;

1.137
date	2014.11.26.19.32.12;	author tg;	state Exp;
branches;
next	1.136;
commitid	10054762AC33B0CB0D0;

1.136
date	2014.11.25.21.13.26;	author tg;	state Exp;
branches;
next	1.135;
commitid	1005474F00E09321C83;

1.135
date	2014.11.25.20.00.38;	author tg;	state Exp;
branches;
next	1.134;
commitid	1005474DFFB1DC897E5;

1.134
date	2014.06.09.13.25.53;	author tg;	state Exp;
branches
	1.134.2.1;
next	1.133;
commitid	1005395B5803902C8E9;

1.133
date	2013.10.09.11.59.28;	author tg;	state Exp;
branches;
next	1.132;
commitid	10052554535524C4C97;

1.132
date	2013.09.24.20.19.44;	author tg;	state Exp;
branches;
next	1.131;
commitid	1005241F37044BDFFC4;

1.131
date	2012.12.28.02.28.35;	author tg;	state Exp;
branches;
next	1.130;
commitid	10050DD03E43C678B81;

1.130
date	2012.12.17.23.18.05;	author tg;	state Exp;
branches;
next	1.129;
commitid	10050CFA81334F40D7F;

1.129
date	2012.12.04.01.18.30;	author tg;	state Exp;
branches;
next	1.128;
commitid	10050BD4F7642624FD1;

1.128
date	2012.11.30.19.02.07;	author tg;	state Exp;
branches
	1.128.2.1;
next	1.127;
commitid	10050B902B82AAA0C3F;

1.127
date	2012.10.21.21.39.03;	author tg;	state Exp;
branches;
next	1.126;
commitid	10050846B5B2B1A2932;

1.126
date	2012.06.24.19.47.11;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004FE76EC944834D3A;

1.125
date	2012.05.05.18.04.20;	author tg;	state Exp;
branches;
next	1.124;
commitid	1004FA56BB53893D984;

1.124
date	2012.05.04.20.49.04;	author tg;	state Exp;
branches;
next	1.123;
commitid	1004FA4409A67B135DE;

1.123
date	2012.04.14.16.07.47;	author tg;	state Exp;
branches;
next	1.122;
commitid	1004F89A0D311D70891;

1.122
date	2012.04.06.13.29.00;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004F7EEFB200419165;

1.121
date	2012.04.01.03.23.08;	author tg;	state Exp;
branches;
next	1.120;
commitid	1004F77CA33651830F2;

1.120
date	2012.03.29.19.22.59;	author tg;	state Exp;
branches;
next	1.119;
commitid	1004F74B525291EF6DE;

1.119
date	2012.03.28.23.07.47;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004F7399D63266C4EB;

1.118
date	2012.03.27.22.36.52;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004F7240673EAD3A5A;

1.117
date	2011.12.31.00.47.45;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004EFE5BC941F48BCB;

1.116
date	2011.12.31.00.23.42;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004EFE549A2E453076;

1.115
date	2011.12.30.21.00.30;	author tg;	state Exp;
branches;
next	1.114;
commitid	1004EFE26857EA11C4E;

1.114
date	2011.12.30.20.35.29;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004EFE20A808151094;

1.113
date	2011.12.10.14.12.16;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004EE368AD1FE82919;

1.112
date	2011.11.26.18.19.00;	author tg;	state Exp;
branches;
next	1.111;
commitid	1004ED12DAB1F1169A1;

1.111
date	2011.09.07.15.24.16;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004E678C6929FE60A6;

1.110
date	2011.08.27.18.06.45;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004E5932432420AA61;

1.109
date	2011.04.22.12.21.53;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004DB172EA6A5331AE;

1.108
date	2011.03.07.20.30.38;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004D75404D6F4BA14C;

1.107
date	2011.02.09.19.32.15;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004D52EBD672606783;

1.106
date	2011.02.09.15.08.01;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004D52ADE5734E8E19;

1.105
date	2011.02.09.13.08.25;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004D5291DC3026B343;

1.104
date	2011.01.30.02.18.20;	author tg;	state Exp;
branches;
next	1.103;
commitid	1004D44CA581AA49FF9;

1.103
date	2010.11.01.17.29.03;	author tg;	state Exp;
branches;
next	1.102;
commitid	1004CCEF8F323B360DC;

1.102
date	2010.09.14.21.26.13;	author tg;	state Exp;
branches;
next	1.101;
commitid	1004C8FE654576B0E25;

1.101
date	2010.08.28.20.22.18;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004C796FE40C544CCE;

1.100
date	2010.08.28.18.50.52;	author tg;	state Exp;
branches;
next	1.99;
commitid	1004C795A82072326AF;

1.99
date	2010.08.28.15.48.18;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004C792FD945CE393C;

1.98
date	2010.07.24.17.08.29;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004C4B1E2355F50980;

1.97
date	2010.07.17.22.09.35;	author tg;	state Exp;
branches;
next	1.96;
commitid	1004C42295452E71B6E;

1.96
date	2010.07.04.17.45.14;	author tg;	state Exp;
branches;
next	1.95;
commitid	1004C30C8946816B0C1;

1.95
date	2010.07.04.13.36.42;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004C308E614DF59FFB;

1.94
date	2010.05.22.12.49.14;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004BF7D29E03EBF637;

1.93
date	2010.05.13.18.44.09;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004BEC488A683B9F85;

1.92
date	2010.01.29.09.34.28;	author tg;	state Exp;
branches;
next	1.91;
commitid	1004B62ABB7333ED94C;

1.91
date	2010.01.25.16.12.55;	author tg;	state Exp;
branches;
next	1.90;
commitid	1004B5DC2A56A6AB278;

1.90
date	2009.12.12.22.27.08;	author tg;	state Exp;
branches;
next	1.89;
commitid	1004B2418AF282F4231;

1.89
date	2009.10.02.18.08.33;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004AC641341D9D9D02;

1.88
date	2009.08.08.13.08.51;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004A7D785D73D49CFA;

1.87
date	2009.08.01.14.07.42;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004A744C2726F1DEF8;

1.86
date	2009.07.05.13.51.09;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004A50AFB14536CE06;

1.85
date	2009.06.11.12.42.18;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004A30FBB114E3FED9;

1.84
date	2009.06.10.18.12.46;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004A2FF7913BD44883;

1.83
date	2009.06.08.20.06.46;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004A2D6F3A31FB4CBC;

1.82
date	2009.05.27.09.58.22;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004A1D0E9B4EF3C493;

1.81
date	2009.05.16.18.40.06;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004A0F087409E93A5D;

1.80
date	2009.05.16.16.59.36;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004A0EF0664EF4168D;

1.79
date	2009.04.07.21.23.28;	author tg;	state Exp;
branches;
next	1.78;
commitid	10049DBC4671D9A8284;

1.78
date	2009.04.07.18.41.35;	author tg;	state Exp;
branches;
next	1.77;
commitid	10049DB9E493037411A;

1.77
date	2009.02.20.13.25.09;	author tg;	state Exp;
branches;
next	1.76;
commitid	100499EAF33578C4C3D;

1.76
date	2008.12.13.17.02.14;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004943EAA830C0300B;

1.75
date	2008.11.12.00.54.48;	author tg;	state Exp;
branches
	1.75.2.1;
next	1.74;
commitid	100491A295841A6D8EB;

1.74
date	2008.11.09.20.32.17;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004917488700179B64;

1.73
date	2008.10.28.14.32.41;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004907226D3DEFCCD1;

1.72
date	2008.10.14.19.48.27;	author tg;	state Exp;
branches;
next	1.71;
commitid	10048F4F79C16395EAF;

1.71
date	2008.10.13.23.06.02;	author tg;	state Exp;
branches;
next	1.70;
commitid	10048F3D44866CCA1C2;

1.70
date	2008.09.30.19.36.16;	author tg;	state Exp;
branches;
next	1.69;
commitid	10048E27FA3426E07E4;

1.69
date	2008.09.30.19.25.51;	author tg;	state Exp;
branches;
next	1.68;
commitid	10048E27D493BFBB014;

1.68
date	2008.09.30.17.49.26;	author tg;	state Exp;
branches;
next	1.67;
commitid	10048E266AB7BDA06AF;

1.67
date	2008.07.12.17.16.03;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004878E6E41930F79F;

1.66
date	2008.07.12.16.56.39;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004878E22B104A657A;

1.65
date	2008.07.06.22.41.08;	author tg;	state Exp;
branches;
next	1.64;
commitid	10048714A14702F5007;

1.64
date	2008.06.08.17.16.25;	author tg;	state Exp;
branches;
next	1.63;
commitid	100484C13FC58F3291E;

1.63
date	2008.06.08.17.14.31;	author tg;	state Exp;
branches;
next	1.62;
commitid	100484C136B0D4ED395;

1.62
date	2008.05.17.18.46.59;	author tg;	state Exp;
branches;
next	1.61;
commitid	100482F280E7B53AA4C;

1.61
date	2008.04.19.17.21.53;	author tg;	state Exp;
branches;
next	1.60;
commitid	100480A2A2B32040FD7;

1.60
date	2008.04.02.16.55.06;	author tg;	state Exp;
branches;
next	1.59;
commitid	10047F3BA6A180846DA;

1.59
date	2008.03.27.17.59.28;	author tg;	state Exp;
branches;
next	1.58;
commitid	10047EBE08B0311C6DE;

1.58
date	2008.03.05.16.54.21;	author tg;	state Exp;
branches
	1.58.2.1;
next	1.57;
commitid	10047CED0457F02B189;

1.57
date	2007.10.25.15.34.30;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004720B799621B739A;

1.56
date	2007.09.09.19.12.09;	author tg;	state Exp;
branches;
next	1.55;
commitid	10046E445901D2B8C34;

1.55
date	2007.08.20.14.12.29;	author tg;	state Exp;
branches;
next	1.54;
commitid	10046C9A16358B2135D;

1.54
date	2007.07.31.10.42.15;	author tg;	state Exp;
branches;
next	1.53;
commitid	10046AF121C3F451EF4;

1.53
date	2007.07.22.14.01.49;	author tg;	state Exp;
branches;
next	1.52;
commitid	10046A36344350ACD7B;

1.52
date	2007.07.22.13.34.50;	author tg;	state Exp;
branches;
next	1.51;
commitid	10046A35CEC35BB7B5F;

1.51
date	2007.07.01.21.10.28;	author tg;	state Exp;
branches;
next	1.50;
commitid	100468818584C6286F7;

1.50
date	2007.07.01.17.13.52;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004687E0E72B001417;

1.49
date	2007.06.06.23.28.15;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004667430836D68E66;

1.48
date	2007.06.05.21.47.48;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004665D9D956A3B2CA;

1.47
date	2007.06.04.21.33.28;	author tg;	state Exp;
branches;
next	1.46;
commitid	100466485304A0BD517;

1.46
date	2007.05.13.17.51.22;	author tg;	state Exp;
branches;
next	1.45;
commitid	10046474FB1292DF336;

1.45
date	2007.03.04.03.04.25;	author tg;	state Exp;
branches
	1.45.2.1;
next	1.44;
commitid	10045EA374B3374AB35;

1.44
date	2007.03.04.00.13.16;	author tg;	state Exp;
branches;
next	1.43;
commitid	10045EA0F2F6674C8B9;

1.43
date	2007.03.03.21.36.07;	author tg;	state Exp;
branches;
next	1.42;
commitid	10045E9EA54328B08FC;

1.42
date	2007.02.27.15.03.28;	author tg;	state Exp;
branches;
next	1.41;
commitid	10045E4484867042835;

1.41
date	2007.01.17.23.47.15;	author tg;	state Exp;
branches;
next	1.40;
commitid	10045AEB50A4F8328BF;

1.40
date	2007.01.15.02.48.27;	author tg;	state Exp;
branches;
next	1.39;
commitid	10045AAEB8E4EE42CAE;

1.39
date	2007.01.12.02.06.34;	author tg;	state Exp;
branches
	1.39.2.1;
next	1.38;
commitid	10045A6ED2005BADF84;

1.38
date	2007.01.12.01.49.28;	author tg;	state Exp;
branches;
next	1.37;
commitid	10045A6E8B92FCAC95A;

1.37
date	2007.01.12.01.30.35;	author tg;	state Exp;
branches;
next	1.36;
commitid	10045A6E4CF567C674F;

1.36
date	2007.01.12.00.37.09;	author tg;	state Exp;
branches;
next	1.35;
commitid	10045A6D81A16F5155C;

1.35
date	2007.01.12.00.25.40;	author tg;	state Exp;
branches;
next	1.34;
commitid	10045A6D3B866AF7B2F;

1.34
date	2006.11.12.12.49.25;	author tg;	state Exp;
branches;
next	1.33;
commitid	10045571861610DDB49;

1.33
date	2006.11.10.07.52.02;	author tg;	state Exp;
branches;
next	1.32;
commitid	10045542F8269E05F56;

1.32
date	2006.11.10.06.40.05;	author tg;	state Exp;
branches;
next	1.31;
commitid	10045541ED1100460E3;

1.31
date	2006.11.10.05.23.12;	author tg;	state Exp;
branches;
next	1.30;
commitid	10045540CCB39485995;

1.30
date	2006.11.10.04.22.13;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004553FE7A5FEC3897;

1.29
date	2006.11.10.04.03.59;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004553F9E36E96466A;

1.28
date	2006.11.10.03.50.05;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004553F6ED641C945B;

1.27
date	2006.11.10.01.13.51;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004553D1A316532A65;

1.26
date	2006.11.09.14.19.31;	author tg;	state Exp;
branches;
next	1.25;
commitid	100455339025D8787C5;

1.25
date	2006.08.24.18.57.30;	author tg;	state Exp;
branches
	1.25.2.1;
next	1.24;
commitid	10044EDF699300963E6;

1.24
date	2006.08.15.23.56.32;	author tg;	state Exp;
branches;
next	1.23;
commitid	10044E25F4130D9136B;

1.23
date	2006.08.15.23.45.53;	author tg;	state Exp;
branches
	1.23.2.1;
next	1.22;
commitid	10044E25CC425BA6786;

1.22
date	2006.08.15.23.43.30;	author tg;	state Exp;
branches;
next	1.21;
commitid	10044E25C32521DB6A4;

1.21
date	2006.08.12.20.32.33;	author tg;	state Exp;
branches;
next	1.20;
commitid	10044DE3AF56D8B154A;

1.20
date	2006.08.12.19.51.09;	author tg;	state Exp;
branches;
next	1.19;
commitid	10044DE31360656EAD5;

1.19
date	2006.08.01.14.09.19;	author tg;	state Exp;
branches;
next	1.18;
commitid	10044CF609314C13CBE;

1.18
date	2006.08.01.13.43.27;	author tg;	state Exp;
branches;
next	1.17;
commitid	10044CF5A93693A5C0A;

1.17
date	2006.08.01.13.19.42;	author tg;	state Exp;
branches;
next	1.16;
commitid	10044CF54EC6D3F0F01;

1.16
date	2006.08.01.12.57.07;	author tg;	state Exp;
branches;
next	1.15;
commitid	10044CF4F9F33070288;

1.15
date	2006.05.10.18.54.10;	author tg;	state Exp;
branches;
next	1.14;
commitid	100446236E6726083C8;

1.14
date	2006.01.29.20.04.51;	author tg;	state Exp;
branches;
next	1.13;
commitid	10043DD1FE6328EF386;

1.13
date	2005.11.22.18.40.42;	author tg;	state Exp;
branches;
next	1.12;
commitid	108a438366254326;

1.12
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.11;
commitid	76cc435e8d34d8ce;

1.11
date	2005.08.02.12.26.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	65a042ef667885b9;

1.10
date	2005.07.07.23.27.52;	author tg;	state Exp;
branches;
next	1.9;
commitid	419f42cdba670de9;

1.9
date	2005.06.24.15.36.57;	author tg;	state Exp;
branches;
next	1.8;
commitid	e0142bc28a6abe3;

1.8
date	2005.05.23.16.23.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	1d3a429203880b55;

1.7
date	2005.05.23.15.54.31;	author tg;	state Exp;
branches;
next	1.6;
commitid	78044291fcc1aba2;

1.6
date	2005.05.23.15.36.55;	author tg;	state Exp;
branches;
next	1.5;
commitid	294b4291f8a10548;

1.5
date	2005.05.23.15.09.22;	author tg;	state Exp;
branches;
next	1.4;
commitid	607b4291f2260c3d;

1.4
date	2005.05.23.14.19.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	5e9f4291e64f3f3e;

1.3
date	2005.05.23.12.06.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	771b4291c7583f41;

1.2
date	2005.05.23.12.01.09;	author tg;	state Exp;
branches;
next	1.1;
commitid	14d64291c5d9a061;

1.1
date	2005.05.23.03.06.07;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.134.2.1
date	2015.01.25.15.35.46;	author tg;	state Exp;
branches;
next	1.134.2.2;
commitid	10054C50D442D861FBF;

1.134.2.2
date	2015.01.25.15.44.05;	author tg;	state Exp;
branches;
next	1.134.2.3;
commitid	10054C50F46587DFA27;

1.134.2.3
date	2015.03.01.15.43.00;	author tg;	state Exp;
branches;
next	1.134.2.4;
commitid	10054F33364551D895A;

1.134.2.4
date	2015.03.20.22.21.02;	author tg;	state Exp;
branches;
next	1.134.2.5;
commitid	100550C9D521FCB4274;

1.134.2.5
date	2015.04.19.19.18.18;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.128.2.1
date	2012.12.04.01.26.25;	author tg;	state Exp;
branches;
next	1.128.2.2;
commitid	10050BD5149729CD584;

1.128.2.2
date	2013.02.10.17.11.23;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.75.2.1
date	2008.11.22.13.20.31;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.58.2.1
date	2008.04.22.13.29.27;	author tg;	state Exp;
branches;
next	1.58.2.2;
commitid	100480DE80F32BAA72D;

1.58.2.2
date	2008.05.19.18.41.24;	author tg;	state Exp;
branches;
next	1.58.2.3;
commitid	1004831C9A63DA06745;

1.58.2.3
date	2008.07.11.11.49.26;	author tg;	state Exp;
branches;
next	1.58.2.4;
commitid	100487748D62394D033;

1.58.2.4
date	2008.07.18.13.29.44;	author tg;	state Exp;
branches;
next	1.58.2.5;
commitid	10048809AD278B142AC;

1.58.2.5
date	2008.12.14.00.07.42;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.45.2.1
date	2007.05.13.19.29.36;	author tg;	state Exp;
branches;
next	1.45.2.2;
commitid	1004647668D4636830B;

1.45.2.2
date	2007.07.05.11.49.20;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.39.2.1
date	2007.03.03.21.37.56;	author tg;	state Exp;
branches;
next	1.39.2.2;
commitid	10045E9EAC27ABA6ADF;

1.39.2.2
date	2007.03.03.22.38.24;	author tg;	state Exp;
branches;
next	1.39.2.3;
commitid	10045E9F8F5395F55BB;

1.39.2.3
date	2007.03.03.23.38.37;	author tg;	state Exp;
branches;
next	;
commitid	10045EA07113BF2F32A;

1.25.2.1
date	2006.10.02.23.06.39;	author tg;	state Exp;
branches;
next	;
commitid	10045219B6408CB0B57;

1.23.2.1
date	2006.08.15.23.49.52;	author tg;	state Exp;
branches;
next	1.23.2.2;
commitid	10044E25D6841FC583E;

1.23.2.2
date	2006.08.18.19.02.22;	author tg;	state Exp;
branches;
next	1.23.2.3;
commitid	10044E60ECD062A26B8;

1.23.2.3
date	2006.08.24.18.53.00;	author tg;	state Exp;
branches;
next	1.23.2.4;
commitid	10044EDF59C21107285;

1.23.2.4
date	2006.08.24.18.56.20;	author tg;	state Exp;
branches;
next	1.23.2.5;
commitid	10044EDF66B48DEB72C;

1.23.2.5
date	2006.08.24.20.52.12;	author tg;	state Exp;
branches;
next	1.23.2.6;
commitid	10044EE117A130AF943;

1.23.2.6
date	2006.08.28.01.49.18;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.169
log
@oops; from Denys Nykula
@
text
@/*	$OpenBSD: history.c,v 1.41 2015/09/01 13:12:31 tedu Exp $	*/
/*	$OpenBSD: trap.c,v 1.23 2010/05/19 17:36:08 jasper Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2014, 2015, 2016, 2017, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"
#if HAVE_SYS_FILE_H
#include <sys/file.h>
#endif

__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.167 2018/04/28 17:16:54 tg Exp $");

Trap sigtraps[ksh_NSIG + 1];
static struct sigaction Sigact_ign;

#if HAVE_PERSISTENT_HISTORY
static int histload(Source *, unsigned char *, size_t);
static int writehistline(int, int, const char *);
static void writehistfile(int, const char *);
#endif

static int hist_execute(char *, Area *);
static char **hist_get(const char *, bool, bool);
static char **hist_get_oldest(void);

static bool hstarted;		/* set after hist_init() called */
static Source *hist_source;

#if HAVE_PERSISTENT_HISTORY
/*XXX imake style */
#if defined(__linux)
#define caddr_cast(x)	((void *)(x))
#else
#define caddr_cast(x)	((caddr_t)(x))
#endif

/* several OEs do not have these constants */
#ifndef MAP_FAILED
#define MAP_FAILED	caddr_cast(-1)
#endif

/* some OEs need the default mapping type specified */
#ifndef MAP_FILE
#define MAP_FILE	0
#endif

/* current history file: name, fd, size */
static char *hname;
static int histfd = -1;
static off_t histfsize;
#endif

/* HISTSIZE default: size of saved history, persistent or standard */
#ifdef MKSH_SMALL
#define MKSH_DEFHISTSIZE	255
#else
#define MKSH_DEFHISTSIZE	2047
#endif
/* maximum considered size of persistent history file */
#define MKSH_MAXHISTFSIZE	((off_t)1048576 * 96)

/* hidden option */
#define HIST_DISCARD		5

int
c_fc(const char **wp)
{
	struct shf *shf;
	struct temp *tf;
	bool gflag = false, lflag = false, nflag = false, rflag = false,
	    sflag = false;
	int optc;
	const char *p, *first = NULL, *last = NULL;
	char **hfirst, **hlast, **hp, *editor = NULL;

	if (!Flag(FTALKING_I)) {
		bi_errorf("history %ss not available", Tfunction);
		return (1);
	}

	while ((optc = ksh_getopt(wp, &builtin_opt,
	    "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != -1)
		switch (optc) {

		case 'e':
			p = builtin_opt.optarg;
			if (ksh_isdash(p))
				sflag = true;
			else {
				size_t len = strlen(p);

				/* almost certainly not overflowing */
				editor = alloc(len + 4, ATEMP);
				memcpy(editor, p, len);
				memcpy(editor + len, Tspdollaru, 4);
			}
			break;

		/* non-AT&T ksh */
		case 'g':
			gflag = true;
			break;

		case 'l':
			lflag = true;
			break;

		case 'n':
			nflag = true;
			break;

		case 'r':
			rflag = true;
			break;

		/* POSIX version of -e - */
		case 's':
			sflag = true;
			break;

		/* kludge city - accept -num as -- -num (kind of) */
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			p = shf_smprintf("-%c%s",
					optc, builtin_opt.optarg);
			if (!first)
				first = p;
			else if (!last)
				last = p;
			else {
				bi_errorf(Ttoo_many_args);
				return (1);
			}
			break;

		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	/* Substitute and execute command */
	if (sflag) {
		char *pat = NULL, *rep = NULL, *line;

		if (editor || lflag || nflag || rflag) {
			bi_errorf("can't use -e, -l, -n, -r with -s (-e -)");
			return (1);
		}

		/* Check for pattern replacement argument */
		if (*wp && **wp && (p = cstrchr(*wp + 1, '='))) {
			strdupx(pat, *wp, ATEMP);
			rep = pat + (p - *wp);
			*rep++ = '\0';
			wp++;
		}
		/* Check for search prefix */
		if (!first && (first = *wp))
			wp++;
		if (last || *wp) {
			bi_errorf(Ttoo_many_args);
			return (1);
		}

		hp = first ? hist_get(first, false, false) :
		    hist_get_newest(false);
		if (!hp)
			return (1);
		/* hist_replace */
		if (!pat)
			strdupx(line, *hp, ATEMP);
		else {
			char *s, *s1;
			size_t len, pat_len, rep_len;
			XString xs;
			char *xp;
			bool any_subst = false;

			pat_len = strlen(pat);
			rep_len = strlen(rep);
			Xinit(xs, xp, 128, ATEMP);
			for (s = *hp; (s1 = strstr(s, pat)) &&
			    (!any_subst || gflag); s = s1 + pat_len) {
				any_subst = true;
				len = s1 - s;
				XcheckN(xs, xp, len + rep_len);
				/*; first part */
				memcpy(xp, s, len);
				xp += len;
				/* replacement */
				memcpy(xp, rep, rep_len);
				xp += rep_len;
			}
			if (!any_subst) {
				bi_errorf(Tbadsubst);
				return (1);
			}
			len = strlen(s) + 1;
			XcheckN(xs, xp, len);
			memcpy(xp, s, len);
			xp += len;
			line = Xclose(xs, xp);
		}
		return (hist_execute(line, ATEMP));
	}

	if (editor && (lflag || nflag)) {
		bi_errorf("can't use -l, -n with -e");
		return (1);
	}

	if (!first && (first = *wp))
		wp++;
	if (!last && (last = *wp))
		wp++;
	if (*wp) {
		bi_errorf(Ttoo_many_args);
		return (1);
	}
	if (!first) {
		hfirst = lflag ? hist_get("-16", true, true) :
		    hist_get_newest(false);
		if (!hfirst)
			return (1);
		/* can't fail if hfirst didn't fail */
		hlast = hist_get_newest(false);
	} else {
		/*
		 * POSIX says not an error if first/last out of bounds
		 * when range is specified; AT&T ksh and pdksh allow out
		 * of bounds for -l as well.
		 */
		hfirst = hist_get(first, tobool(lflag || last), lflag);
		if (!hfirst)
			return (1);
		hlast = last ? hist_get(last, true, lflag) :
		    (lflag ? hist_get_newest(false) : hfirst);
		if (!hlast)
			return (1);
	}
	if (hfirst > hlast) {
		char **temp;

		temp = hfirst; hfirst = hlast; hlast = temp;
		/* POSIX */
		rflag = !rflag;
	}

	/* List history */
	if (lflag) {
		char *s, *t;

		for (hp = rflag ? hlast : hfirst;
		    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1) {
			if (!nflag)
				shf_fprintf(shl_stdout, Tf_lu,
				    (unsigned long)hist_source->line -
				    (unsigned long)(histptr - hp));
			shf_putc('\t', shl_stdout);
			/* print multi-line commands correctly */
			s = *hp;
			while ((t = strchr(s, '\n'))) {
				*t = '\0';
				shf_fprintf(shl_stdout, "%s\n\t", s);
				*t++ = '\n';
				s = t;
			}
			shf_fprintf(shl_stdout, Tf_sN, s);
		}
		shf_flush(shl_stdout);
		return (0);
	}

	/* Run editor on selected lines, then run resulting commands */

	tf = maketemp(ATEMP, TT_HIST_EDIT, &e->temps);
	if (!(shf = tf->shf)) {
		bi_errorf(Tf_temp, Tcreate, tf->tffn, cstrerror(errno));
		return (1);
	}
	for (hp = rflag ? hlast : hfirst;
	    hp >= hfirst && hp <= hlast; hp += rflag ? -1 : 1)
		shf_fprintf(shf, Tf_sN, *hp);
	if (shf_close(shf) == -1) {
		bi_errorf(Tf_temp, Twrite, tf->tffn, cstrerror(errno));
		return (1);
	}

	/* Ignore setstr errors here (arbitrary) */
	setstr(local("_", false), tf->tffn, KSH_RETURN_ERROR);

	if ((optc = command(editor ? editor : TFCEDIT_dollaru, 0)))
		return (optc);

	{
		struct stat statb;
		XString xs;
		char *xp;
		ssize_t n;

		if (!(shf = shf_open(tf->tffn, O_RDONLY, 0, 0))) {
			bi_errorf(Tf_temp, Topen, tf->tffn, cstrerror(errno));
			return (1);
		}

		if (stat(tf->tffn, &statb) < 0)
			n = 128;
		else if ((off_t)statb.st_size > MKSH_MAXHISTFSIZE) {
			bi_errorf(Tf_toolarge, Thistory,
			    Tfile, (unsigned long)statb.st_size);
			goto errout;
		} else
			n = (size_t)statb.st_size + 1;
		Xinit(xs, xp, n, hist_source->areap);
		while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
			xp += n;
			if (Xnleft(xs, xp) <= 0)
				XcheckN(xs, xp, Xlength(xs, xp));
		}
		if (n < 0) {
			bi_errorf(Tf_temp, Tread, tf->tffn,
			    cstrerror(shf_errno(shf)));
 errout:
			shf_close(shf);
			return (1);
		}
		shf_close(shf);
		*xp = '\0';
		strip_nuls(Xstring(xs, xp), Xlength(xs, xp));
		return (hist_execute(Xstring(xs, xp), hist_source->areap));
	}
}

/* save cmd in history, execute cmd (cmd gets afree’d) */
static int
hist_execute(char *cmd, Area *areap)
{
	static int last_line = -1;

	/* Back up over last histsave */
	if (histptr >= history && last_line != hist_source->line) {
		hist_source->line--;
		afree(*histptr, APERM);
		histptr--;
		last_line = hist_source->line;
	}

	histsave(&hist_source->line, cmd, HIST_STORE, true);
	/* now *histptr == cmd without all trailing newlines */
	afree(cmd, areap);
	cmd = *histptr;
	/* pdksh says POSIX doesn’t say this is done, testsuite needs it */
	shellf(Tf_sN, cmd);

	/*-
	 * Commands are executed here instead of pushing them onto the
	 * input 'cause POSIX says the redirection and variable assignments
	 * in
	 *	X=y fc -e - 42 2> /dev/null
	 * are to effect the repeated commands environment.
	 */
	return (command(cmd, 0));
}

/*
 * get pointer to history given pattern
 * pattern is a number or string
 */
static char **
hist_get(const char *str, bool approx, bool allow_cur)
{
	char **hp = NULL;
	int n;

	if (getn(str, &n)) {
		hp = histptr + (n < 0 ? n : (n - hist_source->line));
		if ((size_t)hp < (size_t)history) {
			if (approx)
				hp = hist_get_oldest();
			else {
				bi_errorf(Tf_sD_s, str, Tnot_in_history);
				hp = NULL;
			}
		} else if ((size_t)hp > (size_t)histptr) {
			if (approx)
				hp = hist_get_newest(allow_cur);
			else {
				bi_errorf(Tf_sD_s, str, Tnot_in_history);
				hp = NULL;
			}
		} else if (!allow_cur && hp == histptr) {
			bi_errorf(Tf_sD_s, str, "invalid range");
			hp = NULL;
		}
	} else {
		bool anchored = *str == '?' ? (++str, false) : true;

		/* the -1 is to avoid the current fc command */
		if ((n = findhist(histptr - history - 1, 0, str, anchored)) < 0)
			bi_errorf(Tf_sD_s, str, Tnot_in_history);
		else
			hp = &history[n];
	}
	return (hp);
}

/* Return a pointer to the newest command in the history */
char **
hist_get_newest(bool allow_cur)
{
	if (histptr < history || (!allow_cur && histptr == history)) {
		bi_errorf("no history (yet)");
		return (NULL);
	}
	return (allow_cur ? histptr : histptr - 1);
}

/* Return a pointer to the oldest command in the history */
static char **
hist_get_oldest(void)
{
	if (histptr <= history) {
		bi_errorf("no history (yet)");
		return (NULL);
	}
	return (history);
}

#if !defined(MKSH_NO_CMDLINE_EDITING) && !MKSH_S_NOVI
/* current position in history[] */
static char **current;

/*
 * Return the current position.
 */
char **
histpos(void)
{
	return (current);
}

int
histnum(int n)
{
	int last = histptr - history;

	if (n < 0 || n >= last) {
		current = histptr;
		return (last);
	} else {
		current = &history[n];
		return (n);
	}
}
#endif

/*
 * This will become unnecessary if hist_get is modified to allow
 * searching from positions other than the end, and in either
 * direction.
 */
int
findhist(int start, int fwd, const char *str, bool anchored)
{
	char **hp;
	int maxhist = histptr - history;
	int incr = fwd ? 1 : -1;
	size_t len = strlen(str);

	if (start < 0 || start >= maxhist)
		start = maxhist;

	hp = &history[start];
	for (; hp >= history && hp <= histptr; hp += incr)
		if ((anchored && strncmp(*hp, str, len) == 0) ||
		    (!anchored && strstr(*hp, str)))
			return (hp - history);

	return (-1);
}

/*
 * set history; this means reallocating the dataspace
 */
void
sethistsize(mksh_ari_t n)
{
	if (n > 65535)
		n = 65535;
	if (n > 0 && n != histsize) {
		int cursize = histptr - history;

		/* save most recent history */
		if (n < cursize) {
			memmove(history, histptr - n + 1, n * sizeof(char *));
			cursize = n - 1;
		}

		history = aresize2(history, n, sizeof(char *), APERM);

		histsize = n;
		histptr = history + cursize;
	}
}

#if HAVE_PERSISTENT_HISTORY
/*
 * set history file; this can mean reloading/resetting/starting
 * history file maintenance
 */
void
sethistfile(const char *name)
{
	/* if not started then nothing to do */
	if (hstarted == false)
		return;

	/* if the name is the same as the name we have */
	if (hname && name && !strcmp(hname, name))
		return;

	/*
	 * it's a new name - possibly
	 */
	if (histfd != -1) {
		/* yes the file is open */
		(void)close(histfd);
		histfd = -1;
		histfsize = 0;
		afree(hname, APERM);
		hname = NULL;
		/* let's reset the history */
		histsave(NULL, NULL, HIST_DISCARD, true);
		histptr = history - 1;
		hist_source->line = 0;
	}

	if (name)
		hist_init(hist_source);
}
#endif

/*
 * initialise the history vector
 */
void
init_histvec(void)
{
	if (history == (char **)NULL) {
		histsize = MKSH_DEFHISTSIZE;
		history = alloc2(histsize, sizeof(char *), APERM);
		histptr = history - 1;
	}
}


/*
 * It turns out that there is a lot of ghastly hackery here
 */

#if !defined(MKSH_SMALL) && HAVE_PERSISTENT_HISTORY
/* do not save command in history but possibly sync */
bool
histsync(void)
{
	bool changed = false;

	/* called by histsave(), may not HIST_DISCARD, caller should flush */

	if (histfd != -1) {
		int lno = hist_source->line;

		hist_source->line++;
		writehistfile(0, NULL);
		hist_source->line--;

		if (lno != hist_source->line)
			changed = true;
	}

	return (changed);
}
#endif

/*
 * save command in history
 */
void
histsave(int *lnp, const char *cmd, int svmode, bool ignoredups)
{
	static char *enqueued = NULL;
	char **hp, *c;
	const char *ccp;

	if (svmode == HIST_DISCARD) {
		afree(enqueued, APERM);
		enqueued = NULL;
		return;
	}

	if (svmode == HIST_APPEND) {
		if (!enqueued)
			svmode = HIST_STORE;
	} else if (enqueued) {
		c = enqueued;
		enqueued = NULL;
		--*lnp;
		histsave(lnp, c, HIST_STORE, true);
		afree(c, APERM);
	}

	if (svmode == HIST_FLUSH)
		return;

	ccp = strnul(cmd);
	while (ccp > cmd && ccp[-1] == '\n')
		--ccp;
	strndupx(c, cmd, ccp - cmd, APERM);

	if (svmode != HIST_APPEND) {
		if (ignoredups &&
		    histptr >= history &&
		    !strcmp(c, *histptr)
#if !defined(MKSH_SMALL) && HAVE_PERSISTENT_HISTORY
		    && !histsync()
#endif
		    ) {
			afree(c, APERM);
			return;
		}
		++*lnp;
	}

#if HAVE_PERSISTENT_HISTORY
	if (svmode == HIST_STORE && histfd != -1)
		writehistfile(*lnp, c);
#endif

	if (svmode == HIST_QUEUE || svmode == HIST_APPEND) {
		size_t nenq, ncmd;

		if (!enqueued) {
			if (*c)
				enqueued = c;
			else
				afree(c, APERM);
			return;
		}

		nenq = strlen(enqueued);
		ncmd = strlen(c);
		enqueued = aresize(enqueued, nenq + 1 + ncmd + 1, APERM);
		enqueued[nenq] = '\n';
		memcpy(enqueued + nenq + 1, c, ncmd + 1);
		afree(c, APERM);
		return;
	}

	hp = histptr;

	if (++hp >= history + histsize) {
		/* remove oldest command */
		afree(*history, APERM);
		for (hp = history; hp < history + histsize - 1; hp++)
			hp[0] = hp[1];
	}
	*hp = c;
	histptr = hp;
}

/*
 * Write history data to a file nominated by HISTFILE;
 * if HISTFILE is unset then history still happens, but
 * the data is not written to a file. All copies of ksh
 * looking at the file will maintain the same history.
 * This is ksh behaviour.
 *
 * This stuff uses mmap()
 *
 * This stuff is so totally broken it must eventually be
 * redesigned, without mmap, better checks, support for
 * larger files, etc. and handle partially corrupted files
 */

/*-
 * Open a history file
 * Format is:
 * Bytes 1, 2:
 *	HMAGIC - just to check that we are dealing with the correct object
 * Then follows a number of stored commands
 * Each command is
 *	<command byte><command number(4 octets, big endian)><bytes><NUL>
 */
#define HMAGIC1		0xAB
#define HMAGIC2		0xCD
#define COMMAND		0xFF

#if HAVE_PERSISTENT_HISTORY
static const unsigned char sprinkle[2] = { HMAGIC1, HMAGIC2 };

static int
hist_persist_back(int srcfd)
{
	off_t tot, mis;
	ssize_t n, w;
	char *buf, *cp;
	int rv = 0;
#define MKSH_HS_BUFSIZ 4096

	if ((tot = lseek(srcfd, (off_t)0, SEEK_END)) < 0 ||
	    lseek(srcfd, (off_t)0, SEEK_SET) < 0 ||
	    lseek(histfd, (off_t)0, SEEK_SET) < 0)
		return (1);

	if ((buf = malloc_osfunc(MKSH_HS_BUFSIZ)) == NULL)
		return (1);

	mis = tot;
	while (mis > 0) {
		if ((n = blocking_read(srcfd, (cp = buf),
		    MKSH_HS_BUFSIZ)) == -1) {
			if (errno == EINTR) {
				intrcheck();
				continue;
			}
			goto copy_error;
		}
		mis -= n;
		while (n) {
			if (intrsig)
				goto has_intrsig;
			if ((w = write(histfd, cp, n)) != -1) {
				n -= w;
				cp += w;
				continue;
			}
			if (errno == EINTR) {
 has_intrsig:
				intrcheck();
				continue;
			}
			goto copy_error;
		}
	}
	if (ftruncate(histfd, tot)) {
 copy_error:
		rv = 1;
	}
	free_osfunc(buf);
	return (rv);
}

static void
hist_persist_init(void)
{
	unsigned char *base;
	int lines, fd;
	enum { hist_init_first, hist_init_retry, hist_use_it } hs;

	if (((hname = str_val(global("HISTFILE"))) == NULL) || !*hname) {
		hname = NULL;
		return;
	}
	strdupx(hname, hname, APERM);
	hs = hist_init_first;

 retry:
	/* we have a file and are interactive */
	if ((fd = binopen3(hname, O_RDWR | O_CREAT | O_APPEND, 0600)) < 0)
		return;
	if ((histfd = savefd(fd)) < 0)
		return;
	if (histfd != fd)
		close(fd);

	mksh_lockfd(histfd);

	histfsize = lseek(histfd, (off_t)0, SEEK_END);
	if (histfsize > MKSH_MAXHISTFSIZE) {
		/* we ignore too large files but still append to them */
		goto hist_init_tail;
	} else if (histfsize > 2) {
		/* we have some data, check its validity */
		base = (void *)mmap(NULL, (size_t)histfsize, PROT_READ,
		    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
		if (base == (unsigned char *)MAP_FAILED)
			goto hist_init_fail;
		if (base[0] != HMAGIC1 || base[1] != HMAGIC2) {
			munmap(caddr_cast(base), (size_t)histfsize);
			goto hist_init_fail;
		}
		/* load _all_ data */
		lines = histload(hist_source, base + 2, (size_t)histfsize - 2);
		munmap(caddr_cast(base), (size_t)histfsize);
		/* check if the file needs to be truncated */
		if (lines > histsize && histptr >= history) {
			/* you're fucked up with the current code, trust me */
			char *nhname, **hp;
			struct stat sb;

			/* create temporary file */
			nhname = shf_smprintf("%s.%d", hname, (int)procpid);
			if ((fd = binopen3(nhname, O_RDWR | O_CREAT | O_TRUNC |
			    O_EXCL, 0600)) < 0) {
				/* just don't truncate then, meh. */
				hs = hist_use_it;
				goto hist_trunc_dont;
			}
			if (fstat(histfd, &sb) >= 0 &&
			    chown(nhname, sb.st_uid, sb.st_gid)) {
				/* abort the truncation then, meh. */
				goto hist_trunc_abort;
			}
			/* we definitively want some magic in that file */
			if (write(fd, sprinkle, 2) != 2)
				goto hist_trunc_abort;
			/* and of course the entries */
			hp = history;
			while (hp < histptr) {
				if (!writehistline(fd,
				    hist_source->line - (histptr - hp), *hp))
					goto hist_trunc_abort;
				++hp;
			}
			/* now transfer back */
			if (!hist_persist_back(fd)) {
				/* success! */
				hs = hist_use_it;
			}
 hist_trunc_abort:
			/* remove temporary file */
			close(fd);
			fd = -1;
			unlink(nhname);
			/* use whatever is in the file now */
 hist_trunc_dont:
			afree(nhname, ATEMP);
			if (hs == hist_use_it)
				goto hist_trunc_done;
			goto hist_init_fail;
		}
	} else if (histfsize != 0) {
		/* negative or too small... */
 hist_init_fail:
		/* ... or mmap failed or illegal */
		hist_finish();
		/* nuke the bogus file then retry, at most once */
		if (!unlink(hname) && hs != hist_init_retry) {
			hs = hist_init_retry;
			goto retry;
		}
		if (hs != hist_init_retry)
			bi_errorf(Tf_cant_ss_s,
			    "unlink HISTFILE", hname, cstrerror(errno));
		histfsize = 0;
		return;
	} else {
		/* size 0, add magic to the history file */
		if (write(histfd, sprinkle, 2) != 2) {
			hist_finish();
			return;
		}
	}
 hist_trunc_done:
	if ((histfsize = lseek(histfd, (off_t)0, SEEK_END)) < 0)
		goto hist_init_fail;
 hist_init_tail:
	mksh_unlkfd(histfd);
}
#endif

void
hist_init(Source *s)
{
	histsave(NULL, NULL, HIST_DISCARD, true);

	if (Flag(FTALKING) == 0)
		return;

	hstarted = true;
	hist_source = s;

#if HAVE_PERSISTENT_HISTORY
	hist_persist_init();
#endif
}

#if HAVE_PERSISTENT_HISTORY
/*
 * load the history structure from the stored data
 */
static int
histload(Source *s, unsigned char *base, size_t bytes)
{
	int lno = 0, lines = 0;
	unsigned char *cp;

 histload_loop:
	/* !bytes check as some systems (older FreeBSDs) have buggy memchr */
	if (!bytes || (cp = memchr(base, COMMAND, bytes)) == NULL)
		return (lines);
	/* advance base pointer past COMMAND byte */
	bytes -= ++cp - base;
	base = cp;
	/* if there is no full string left, don't bother with the rest */
	if (bytes < 5 || (cp = memchr(base + 4, '\0', bytes - 4)) == NULL)
		return (lines);
	/* load the stored line number */
	lno = ((base[0] & 0xFF) << 24) | ((base[1] & 0xFF) << 16) |
	    ((base[2] & 0xFF) << 8) | (base[3] & 0xFF);
	/* store away the found line (@@base[4]) */
	++lines;
	if (histptr >= history && lno - 1 != s->line) {
		/* a replacement? */
		char **hp;

		if (lno >= s->line - (histptr - history) && lno <= s->line) {
			hp = &histptr[lno - s->line];
			afree(*hp, APERM);
			strdupx(*hp, (char *)(base + 4), APERM);
		}
	} else {
		s->line = lno--;
		histsave(&lno, (char *)(base + 4), HIST_NOTE, false);
	}
	/* advance base pointer past NUL */
	bytes -= ++cp - base;
	base = cp;
	/* repeat until no more */
	goto histload_loop;
}

/*
 * write a command to the end of the history file
 *
 * This *MAY* seem easy but it's also necessary to check
 * that the history file has not changed in size.
 * If it has - then some other shell has written to it and
 * we should (re)read those commands to update our history
 */
static void
writehistfile(int lno, const char *cmd)
{
	off_t sizenow;
	size_t bytes;
	unsigned char *base, *news;

	mksh_lockfd(histfd);
	if ((sizenow = lseek(histfd, (off_t)0, SEEK_END)) < 0)
		goto bad;
	else if (sizenow < histfsize) {
		/* the file has shrunk; trust it just appending the new data */
		/* well, for now, anyway… since mksh strdups all into memory */
		/* we can use a nicer approach some time later… */
		;
	} else if (
		/* ignore changes when the file is too large */
		sizenow <= MKSH_MAXHISTFSIZE
	    &&
		/* the size has changed, we need to do read updates */
		sizenow > histfsize
	    ) {
		/* both sizenow and histfsize are <= MKSH_MAXHISTFSIZE */
		bytes = (size_t)(sizenow - histfsize);
		base = (void *)mmap(NULL, (size_t)sizenow, PROT_READ,
		    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
		if (base == (unsigned char *)MAP_FAILED)
			goto bad;
		news = base + (size_t)histfsize;
		if (*news == COMMAND) {
			hist_source->line--;
			histload(hist_source, news, bytes);
			hist_source->line++;
			lno = hist_source->line;
		} else
			bytes = 0;
		munmap(caddr_cast(base), (size_t)sizenow);
		if (!bytes)
			goto bad;
	}
	if (cmd && !writehistline(histfd, lno, cmd)) {
 bad:
		hist_finish();
		return;
	}
	if ((histfsize = lseek(histfd, (off_t)0, SEEK_END)) < 0)
		goto bad;
	mksh_unlkfd(histfd);
}

static int
writehistline(int fd, int lno, const char *cmd)
{
	ssize_t n;
	unsigned char hdr[5];

	hdr[0] = COMMAND;
	hdr[1] = (lno >> 24) & 0xFF;
	hdr[2] = (lno >> 16) & 0xFF;
	hdr[3] = (lno >> 8) & 0xFF;
	hdr[4] = lno & 0xFF;
	n = strlen(cmd) + 1;
	return (write(fd, hdr, 5) == 5 && write(fd, cmd, n) == n);
}

void
hist_finish(void)
{
	if (histfd >= 0) {
		mksh_unlkfd(histfd);
		(void)close(histfd);
	}
	histfd = -1;
}
#endif


#if !HAVE_SYS_SIGNAME
static const struct mksh_sigpair {
	const char * const name;
	int nr;
} mksh_sigpairs[] = {
#include "signames.inc"
	{ NULL, 0 }
};
#endif

#if HAVE_SYS_SIGLIST
#if !HAVE_SYS_SIGLIST_DECL
extern const char * const sys_siglist[];
#endif
#endif

void
inittraps(void)
{
	int i;
	const char *cs;
#if !HAVE_SYS_SIGNAME
	const struct mksh_sigpair *pair;
#endif

	trap_exstat = -1;

	/* populate sigtraps based on sys_signame and sys_siglist */
	for (i = 1; i < ksh_NSIG; i++) {
		sigtraps[i].signal = i;
#if HAVE_SYS_SIGNAME
		cs = sys_signame[i];
#else
		pair = mksh_sigpairs;
		while ((pair->nr != i) && (pair->name != NULL))
			++pair;
		cs = pair->name;
#endif
		if ((cs == NULL) ||
		    (cs[0] == '\0'))
			sigtraps[i].name = null;
		else {
			char *s;

			/* this is not optimal, what about SIGSIG1? */
			if (ksh_eq(cs[0], 'S', 's') &&
			    ksh_eq(cs[1], 'I', 'i') &&
			    ksh_eq(cs[2], 'G', 'g') &&
			    cs[3] != '\0') {
				/* skip leading "SIG" */
				cs += 3;
			}
			strdupx(s, cs, APERM);
			sigtraps[i].name = s;
			while ((*s = ksh_toupper(*s)))
				++s;
			/* check for reserved names */
			if (!strcmp(sigtraps[i].name, "EXIT") ||
			    !strcmp(sigtraps[i].name, "ERR")) {
#ifndef MKSH_SMALL
				internal_warningf(Tinvname, sigtraps[i].name,
				    "signal");
#endif
				sigtraps[i].name = null;
			}
		}
		if (sigtraps[i].name == null)
			sigtraps[i].name = shf_smprintf(Tf_d, i);
#if HAVE_SYS_SIGLIST
		sigtraps[i].mess = sys_siglist[i];
#elif HAVE_STRSIGNAL
		sigtraps[i].mess = strsignal(i);
#else
		sigtraps[i].mess = NULL;
#endif
		if ((sigtraps[i].mess == NULL) ||
		    (sigtraps[i].mess[0] == '\0'))
			sigtraps[i].mess = shf_smprintf(Tf_sd,
			    "Signal", i);
	}
	sigtraps[ksh_SIGEXIT].signal = ksh_SIGEXIT;
	sigtraps[ksh_SIGEXIT].name = "EXIT";
	sigtraps[ksh_SIGEXIT].mess = "Exit trap";
	sigtraps[ksh_SIGERR].signal = ksh_SIGERR;
	sigtraps[ksh_SIGERR].name = "ERR";
	sigtraps[ksh_SIGERR].mess = "Error handler";

	(void)sigemptyset(&Sigact_ign.sa_mask);
	Sigact_ign.sa_flags = 0; /* interruptible */
	Sigact_ign.sa_handler = SIG_IGN;

	sigtraps[SIGINT].flags |= TF_DFL_INTR | TF_TTY_INTR;
	sigtraps[SIGQUIT].flags |= TF_DFL_INTR | TF_TTY_INTR;
	/* SIGTERM is not fatal for interactive */
	sigtraps[SIGTERM].flags |= TF_DFL_INTR;
	sigtraps[SIGHUP].flags |= TF_FATAL;
	sigtraps[SIGCHLD].flags |= TF_SHELL_USES;

	/* these are always caught so we can clean up any temporary files. */
	setsig(&sigtraps[SIGINT], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGQUIT], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGTERM], trapsig, SS_RESTORE_ORIG);
	setsig(&sigtraps[SIGHUP], trapsig, SS_RESTORE_ORIG);
}

static void alarm_catcher(int sig);

void
alarm_init(void)
{
	sigtraps[SIGALRM].flags |= TF_SHELL_USES;
	setsig(&sigtraps[SIGALRM], alarm_catcher,
		SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
}

/* ARGSUSED */
static void
alarm_catcher(int sig MKSH_A_UNUSED)
{
	/* this runs inside interrupt context, with errno saved */

	if (ksh_tmout_state == TMOUT_READING) {
		int left = alarm(0);

		if (left == 0) {
			ksh_tmout_state = TMOUT_LEAVING;
			intrsig = 1;
		} else
			alarm(left);
	}
}

Trap *
gettrap(const char *cs, bool igncase, bool allsigs)
{
	int i;
	Trap *p;
	char *as;

	/* signal number (1..ksh_NSIG) or 0? */

	if (ctype(*cs, C_DIGIT))
		return ((getn(cs, &i) && 0 <= i && i < ksh_NSIG) ?
		    (&sigtraps[i]) : NULL);

	/* do a lookup by name then */

	/* this breaks SIGSIG1, but we do that above anyway */
	if (ksh_eq(cs[0], 'S', 's') &&
	    ksh_eq(cs[1], 'I', 'i') &&
	    ksh_eq(cs[2], 'G', 'g') &&
	    cs[3] != '\0') {
		/* skip leading "SIG" */
		cs += 3;
	}
	if (igncase) {
		char *s;

		strdupx(as, cs, ATEMP);
		cs = s = as;
		while ((*s = ksh_toupper(*s)))
			++s;
	} else
		as = NULL;

	/* this is idiotic, we really want a hashtable here */

	p = sigtraps;
	i = ksh_NSIG + 1;
	do {
		if (!strcmp(p->name, cs))
			goto found;
		++p;
	} while (--i);
	goto notfound;

 found:
	if (!allsigs) {
		if (p->signal == ksh_SIGEXIT || p->signal == ksh_SIGERR) {
 notfound:
			p = NULL;
		}
	}
	afree(as, ATEMP);
	return (p);
}

/*
 * trap signal handler
 */
void
trapsig(int i)
{
	Trap *p = &sigtraps[i];
	int eno = errno;

	trap = p->set = 1;
	if (p->flags & TF_DFL_INTR)
		intrsig = 1;
	if ((p->flags & TF_FATAL) && !p->trap) {
		fatal_trap = 1;
		intrsig = 1;
	}
	if (p->shtrap)
		(*p->shtrap)(i);
	errno = eno;
}

/*
 * called when we want to allow the user to ^C out of something - won't
 * work if user has trapped SIGINT.
 */
void
intrcheck(void)
{
	if (intrsig)
		runtraps(TF_DFL_INTR|TF_FATAL);
}

/*
 * called after EINTR to check if a signal with normally causes process
 * termination has been received.
 */
int
fatal_trap_check(void)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG + 1;

	/* todo: should check if signal is fatal, not the TF_DFL_INTR flag */
	do {
		if (p->set && (p->flags & (TF_DFL_INTR|TF_FATAL)))
			/* return value is used as an exit code */
			return (ksh_sigmask(p->signal));
		++p;
	} while (--i);
	return (0);
}

/*
 * Returns the signal number of any pending traps: ie, a signal which has
 * occurred for which a trap has been set or for which the TF_DFL_INTR flag
 * is set.
 */
int
trap_pending(void)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG + 1;

	do {
		if (p->set && ((p->trap && p->trap[0]) ||
		    ((p->flags & (TF_DFL_INTR|TF_FATAL)) && !p->trap)))
			return (p->signal);
		++p;
	} while (--i);
	return (0);
}

/*
 * run any pending traps. If intr is set, only run traps that
 * can interrupt commands.
 */
void
runtraps(int flag)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG + 1;

	if (ksh_tmout_state == TMOUT_LEAVING) {
		ksh_tmout_state = TMOUT_EXECUTING;
		warningf(false, "timed out waiting for input");
		unwind(LEXIT);
	} else
		/*
		 * XXX: this means the alarm will have no effect if a trap
		 * is caught after the alarm() was started...not good.
		 */
		ksh_tmout_state = TMOUT_EXECUTING;
	if (!flag)
		trap = 0;
	if (flag & TF_DFL_INTR)
		intrsig = 0;
	if (flag & TF_FATAL)
		fatal_trap = 0;
	++trap_nested;
	do {
		if (p->set && (!flag ||
		    ((p->flags & flag) && p->trap == NULL)))
			runtrap(p, false);
		++p;
	} while (--i);
	if (!--trap_nested)
		runtrap(NULL, true);
}

void
runtrap(Trap *p, bool is_last)
{
	int old_changed = 0, i;
	char *trapstr;

	if (p == NULL)
		/* just clean up, see runtraps() above */
		goto donetrap;
	i = p->signal;
	trapstr = p->trap;
	p->set = 0;
	if (trapstr == NULL) {
		/* SIG_DFL */
		if (p->flags & (TF_FATAL | TF_DFL_INTR)) {
			exstat = (int)(128U + (unsigned)i);
			if ((unsigned)exstat > 255U)
				exstat = 255;
		}
		/* e.g. SIGHUP */
		if (p->flags & TF_FATAL)
			unwind(LLEAVE);
		/* e.g. SIGINT, SIGQUIT, SIGTERM, etc. */
		if (p->flags & TF_DFL_INTR)
			unwind(LINTR);
		goto donetrap;
	}
	if (trapstr[0] == '\0')
		/* SIG_IGN */
		goto donetrap;
	if (i == ksh_SIGEXIT || i == ksh_SIGERR) {
		/* avoid recursion on these */
		old_changed = p->flags & TF_CHANGED;
		p->flags &= ~TF_CHANGED;
		p->trap = NULL;
	}
	if (trap_exstat == -1)
		trap_exstat = exstat & 0xFF;
	/*
	 * Note: trapstr is fully parsed before anything is executed, thus
	 * no problem with afree(p->trap) in settrap() while still in use.
	 */
	command(trapstr, current_lineno);
	if (i == ksh_SIGEXIT || i == ksh_SIGERR) {
		if (p->flags & TF_CHANGED)
			/* don't clear TF_CHANGED */
			afree(trapstr, APERM);
		else
			p->trap = trapstr;
		p->flags |= old_changed;
	}

 donetrap:
	/* we're the last trap of a sequence executed */
	if (is_last && trap_exstat != -1) {
		exstat = trap_exstat;
		trap_exstat = -1;
	}
}

/* clear pending traps and reset user's trap handlers; used after fork(2) */
void
cleartraps(void)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG + 1;

	trap = 0;
	intrsig = 0;
	fatal_trap = 0;

	do {
		p->set = 0;
		if ((p->flags & TF_USER_SET) && (p->trap && p->trap[0]))
			settrap(p, NULL);
		++p;
	} while (--i);
}

/* restore signals just before an exec(2) */
void
restoresigs(void)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG + 1;

	do {
		if (p->flags & (TF_EXEC_IGN|TF_EXEC_DFL))
			setsig(p, (p->flags & TF_EXEC_IGN) ? SIG_IGN : SIG_DFL,
			    SS_RESTORE_CURR|SS_FORCE);
		++p;
	} while (--i);
}

void
settrap(Trap *p, const char *s)
{
	sig_t f;

	afree(p->trap, APERM);
	/* handles s == NULL */
	strdupx(p->trap, s, APERM);
	p->flags |= TF_CHANGED;
	f = !s ? SIG_DFL : s[0] ? trapsig : SIG_IGN;

	p->flags |= TF_USER_SET;
	if ((p->flags & (TF_DFL_INTR|TF_FATAL)) && f == SIG_DFL)
		f = trapsig;
	else if (p->flags & TF_SHELL_USES) {
		if (!(p->flags & TF_ORIG_IGN) || Flag(FTALKING)) {
			/* do what user wants at exec time */
			p->flags &= ~(TF_EXEC_IGN|TF_EXEC_DFL);
			if (f == SIG_IGN)
				p->flags |= TF_EXEC_IGN;
			else
				p->flags |= TF_EXEC_DFL;
		}

		/*
		 * assumes handler already set to what shell wants it
		 * (normally trapsig, but could be j_sigchld() or SIG_IGN)
		 */
		return;
	}

	/* todo: should we let user know signal is ignored? how? */
	setsig(p, f, SS_RESTORE_CURR|SS_USER);
}

/*
 * called by c_print() when writing to a co-process to ensure
 * SIGPIPE won't kill shell (unless user catches it and exits)
 */
bool
block_pipe(void)
{
	bool restore_dfl = false;
	Trap *p = &sigtraps[SIGPIPE];

	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
		setsig(p, SIG_IGN, SS_RESTORE_CURR);
		if (p->flags & TF_ORIG_DFL)
			restore_dfl = true;
	} else if (p->cursig == SIG_DFL) {
		setsig(p, SIG_IGN, SS_RESTORE_CURR);
		/* restore to SIG_DFL */
		restore_dfl = true;
	}
	return (restore_dfl);
}

/* called by c_print() to undo whatever block_pipe() did */
void
restore_pipe(void)
{
	setsig(&sigtraps[SIGPIPE], SIG_DFL, SS_RESTORE_CURR);
}

/*
 * Set action for a signal. Action may not be set if original
 * action was SIG_IGN, depending on the value of flags and FTALKING.
 */
int
setsig(Trap *p, sig_t f, int flags)
{
	struct sigaction sigact;

	if (p->signal == ksh_SIGEXIT || p->signal == ksh_SIGERR)
		return (1);

	memset(&sigact, 0, sizeof(sigact));

	/*
	 * First time setting this signal? If so, get and note the current
	 * setting.
	 */
	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
		sigaction(p->signal, &Sigact_ign, &sigact);
		p->flags |= sigact.sa_handler == SIG_IGN ?
		    TF_ORIG_IGN : TF_ORIG_DFL;
		p->cursig = SIG_IGN;
	}

	/*-
	 * Generally, an ignored signal stays ignored, except if
	 *	- the user of an interactive shell wants to change it
	 *	- the shell wants for force a change
	 */
	if ((p->flags & TF_ORIG_IGN) && !(flags & SS_FORCE) &&
	    (!(flags & SS_USER) || !Flag(FTALKING)))
		return (0);

	setexecsig(p, flags & SS_RESTORE_MASK);

	/*
	 * This is here 'cause there should be a way of clearing
	 * shtraps, but don't know if this is a sane way of doing
	 * it. At the moment, all users of shtrap are lifetime
	 * users (SIGALRM, SIGCHLD, SIGWINCH).
	 */
	if (!(flags & SS_USER))
		p->shtrap = (sig_t)NULL;
	if (flags & SS_SHTRAP) {
		p->shtrap = f;
		f = trapsig;
	}

	if (p->cursig != f) {
		p->cursig = f;
		(void)sigemptyset(&sigact.sa_mask);
		/* interruptible */
		sigact.sa_flags = 0;
		sigact.sa_handler = f;
		sigaction(p->signal, &sigact, NULL);
	}

	return (1);
}

/* control what signal is set to before an exec() */
void
setexecsig(Trap *p, int restore)
{
	/* XXX debugging */
	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL)))
		internal_errorf("setexecsig: unset signal %d(%s)",
		    p->signal, p->name);

	/* restore original value for exec'd kids */
	p->flags &= ~(TF_EXEC_IGN|TF_EXEC_DFL);
	switch (restore & SS_RESTORE_MASK) {
	case SS_RESTORE_CURR:
		/* leave things as they currently are */
		break;
	case SS_RESTORE_ORIG:
		p->flags |= p->flags & TF_ORIG_IGN ? TF_EXEC_IGN : TF_EXEC_DFL;
		break;
	case SS_RESTORE_DFL:
		p->flags |= TF_EXEC_DFL;
		break;
	case SS_RESTORE_IGN:
		p->flags |= TF_EXEC_IGN;
		break;
	}
}

#if HAVE_PERSISTENT_HISTORY || defined(DF)
/*
 * File descriptor locking and unlocking functions.
 * Could use some error handling, but hey, this is only
 * advisory locking anyway, will often not work over NFS,
 * and you are SOL if this fails...
 */

void
mksh_lockfd(int fd)
{
#if defined(__OpenBSD__)
	/* flock is not interrupted by signals */
	(void)flock(fd, LOCK_EX);
#elif HAVE_FLOCK
	int rv;

	/* e.g. on Linux */
	do {
		rv = flock(fd, LOCK_EX);
	} while (rv == 1 && errno == EINTR);
#elif HAVE_LOCK_FCNTL
	int rv;
	struct flock lks;

	memset(&lks, 0, sizeof(lks));
	lks.l_type = F_WRLCK;
	do {
		rv = fcntl(fd, F_SETLKW, &lks);
	} while (rv == 1 && errno == EINTR);
#endif
}

/* designed to not define mksh_unlkfd if none triggered */
#if HAVE_FLOCK
void
mksh_unlkfd(int fd)
{
	(void)flock(fd, LOCK_UN);
}
#elif HAVE_LOCK_FCNTL
void
mksh_unlkfd(int fd)
{
	struct flock lks;

	memset(&lks, 0, sizeof(lks));
	lks.l_type = F_UNLCK;
	(void)fcntl(fd, F_SETLKW, &lks);
}
#endif
#endif
@


1.168
log
@limit HISTSIZE to 65535 as long-announced
@
text
@d505 1
a505 1
sethistsize(mksh_uari_t n)
@


1.167
log
@Coverity Scan pointed out that lseek can return -1
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014, 2015, 2016, 2017, 2018
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.163 2017/08/07 20:40:57 tg Exp $");
d505 1
a505 1
sethistsize(mksh_ari_t n)
d507 2
@


1.166
log
@Coverity 1416282
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014, 2015, 2016, 2017
d882 2
a883 1
	histfsize = lseek(histfd, (off_t)0, SEEK_END);
d966 3
a968 2
	sizenow = lseek(histfd, (off_t)0, SEEK_END);
	if (sizenow < histfsize) {
d1003 2
a1004 1
	histfsize = lseek(histfd, (off_t)0, SEEK_END);
@


1.165
log
@Coverity 1416285
@
text
@d727 5
a734 4
	tot = lseek(srcfd, (off_t)0, SEEK_END);
	lseek(srcfd, (off_t)0, SEEK_SET);
	lseek(histfd, (off_t)0, SEEK_SET);

@


1.164
log
@part 2: don’t stop using the history if the file has been truncated
@
text
@d787 2
a788 2

	histfd = savefd(fd);
@


1.163
log
@plug part of the history problems until we can do better:
do not change the underlying file when truncating; rather,
copy everything back from the tmpfile to histfd while the
latter is locked
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.159 2016/11/11 18:44:32 tg Exp $");
d966 5
a970 4
		/* the file has shrunk; give up */
		goto bad;
	}
	if (
@


1.162
log
@use strnul(); optimise
@
text
@a716 1
#endif
d718 2
a719 2
void
hist_init(Source *s)
d721 5
a725 5
#if HAVE_PERSISTENT_HISTORY
	unsigned char *base;
	int lines, fd;
	enum { hist_init_first, hist_init_retry, hist_init_restore } hs;
#endif
d727 2
a728 1
	histsave(NULL, NULL, HIST_DISCARD, true);
d730 38
a767 2
	if (Flag(FTALKING) == 0)
		return;
d769 6
a774 2
	hstarted = true;
	hist_source = s;
a775 1
#if HAVE_PERSISTENT_HISTORY
d795 1
a795 1
	if (histfsize > MKSH_MAXHISTFSIZE || hs == hist_init_restore) {
a796 1
		/* we also don't need to re-read after truncation */
d822 1
d837 1
a837 1
				    s->line - (histptr - hp), *hp))
d841 7
a847 1
			/* now unlock, close both, rename, rinse, repeat */
d850 2
a851 11
			hist_finish();
			if (rename(nhname, hname) < 0) {
 hist_trunc_abort:
				if (fd != -1)
					close(fd);
				unlink(nhname);
				if (fd != -1)
					goto hist_trunc_dont;
				/* darn! restore histfd and pray */
			}
			hs = hist_init_restore;
d854 3
a856 2
			if (hs == hist_init_restore)
				goto retry;
d880 1
d884 16
@


1.161
log
@eliminate legacy macros
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014, 2015, 2016
d632 1
a632 1
	ccp = cmd + strlen(cmd);
@


1.160
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d1117 1
a1117 1
	if (ksh_isdigit(*cs))
@


1.159
log
@pack local bools into a struct, for tighter stack packing
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.152 2016/01/14 23:18:08 tg Exp $");
d832 1
a832 1
			bi_errorf(Tf_cant,
d1036 2
a1037 2
				internal_warningf("ignoring invalid signal name %s",
				    sigtraps[i].name);
@


1.158
log
@make command() not trash the global source variable

removes local save/restore around it in two of three callers;
the third one is in runtrap() which… probably *cough* ought
to have danced the same…
@
text
@d1402 2
a1403 2
 * Called by c_print() when writing to a co-process to ensure SIGPIPE won't
 * kill shell (unless user catches it and exits)
d1405 1
a1405 1
int
d1408 1
a1408 1
	int restore_dfl = 0;
d1414 1
a1414 1
			restore_dfl = 1;
d1418 1
a1418 1
		restore_dfl = 1;
d1423 1
a1423 1
/* Called by c_print() to undo whatever block_pipe() did */
d1425 1
a1425 1
restore_pipe(int restore_dfl)
d1427 1
a1427 2
	if (restore_dfl)
		setsig(&sigtraps[SIGPIPE], SIG_DFL, SS_RESTORE_CURR);
@


1.157
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d311 2
a312 10
	/* XXX: source should not get trashed by this.. */
	{
		Source *sold = source;
		int ret;

		ret = command(editor ? editor : TFCEDIT_dollaru, 0);
		source = sold;
		if (ret)
			return (ret);
	}
a357 2
	Source *sold;
	int ret;
d381 1
a381 5
	/* XXX: source should not get trashed by this.. */
	sold = source;
	ret = command(cmd, 0);
	source = sold;
	return (ret);
@


1.156
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@a71 6
static const char Tnot_in_history[] = "not in history";
#define Thistory (Tnot_in_history + 7)

static const char TFCEDIT_dollaru[] = "${FCEDIT:-/bin/ed} $_";
#define Tspdollaru (TFCEDIT_dollaru + 18)

d150 1
a150 1
				bi_errorf("too many arguments");
d180 1
a180 1
			bi_errorf("too many arguments");
d236 1
a236 1
		bi_errorf("too many arguments");
d275 1
a275 1
				shf_fprintf(shl_stdout, "%lu",
d287 1
a287 1
			shf_fprintf(shl_stdout, "%s\n", s);
d297 1
a297 2
		bi_errorf("can't %s temporary file %s: %s",
		    "create", tf->tffn, cstrerror(errno));
d302 1
a302 1
		shf_fprintf(shf, "%s\n", *hp);
d304 1
a304 2
		bi_errorf("can't %s temporary file %s: %s",
		    "write", tf->tffn, cstrerror(errno));
d329 1
a329 2
			bi_errorf("can't %s temporary file %s: %s",
			    "open", tf->tffn, cstrerror(errno));
d336 2
a337 2
			bi_errorf("%s %s too large: %lu", Thistory,
			    "file", (unsigned long)statb.st_size);
d348 2
a349 2
			bi_errorf("can't %s temporary file %s: %s",
			    "read", tf->tffn, cstrerror(shf_errno(shf)));
d382 1
a382 1
	shellf("%s\n", cmd);
d414 1
a414 1
				bi_errorf("%s: %s", str, Tnot_in_history);
d421 1
a421 1
				bi_errorf("%s: %s", str, Tnot_in_history);
d425 1
a425 1
			bi_errorf("%s: %s", str, "invalid range");
d433 1
a433 1
			bi_errorf("%s: %s", str, Tnot_in_history);
d846 1
a846 1
			bi_errorf("can't %s %s: %s",
d1057 1
a1057 1
			sigtraps[i].name = shf_smprintf("%d", i);
d1067 1
a1067 1
			sigtraps[i].mess = shf_smprintf("%s %d",
@


1.155
log
@explicitly block SIGEXIT and SIGERR in case some idiot defines it
@
text
@d1020 3
d1026 1
a1026 1
	/* Populate sigtraps based on sys_signame and sys_siglist. */
d1032 1
a1032 1
		const struct mksh_sigpair *pair = mksh_sigpairs;
@


1.154
log
@plug a buffer underflow read we executed with *every* testsuite run and
*every* interactive shell session (history didn’t contain anything when
we tested for ignoredups)… first caught by the new code… d’uuuuuuuuuuh!
@
text
@d1036 1
a1036 1
			sigtraps[i].name = shf_smprintf("%d", i);
d1052 9
d1062 2
@


1.153
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d661 3
a663 1
		if (ignoredups && !strcmp(c, *histptr)
@


1.152
log
@incorporate more feedback from schily
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.138 2015/01/22 16:54:29 tg Exp $");
d220 1
a220 1
				bi_errorf("bad substitution");
@


1.151
log
@janitorial work
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014, 2015
d1216 1
a1216 1
			return (128 + p->signal);
@


1.150
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d7 1
a7 1
 *	mirabilos <tg@@mirbsd.org>
@


1.149
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.40 2014/11/20 15:22:39 tedu Exp $	*/
d7 1
a7 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d901 1
a901 2
			if (*hp)
				afree(*hp, APERM);
d1378 1
a1378 2
	if (p->trap)
		afree(p->trap, APERM);
@


1.148
log
@make certain actions flush the history buffer
@
text
@d767 1
a767 2
	if ((fd = open(hname, O_RDWR | O_CREAT | O_APPEND | O_BINARY,
	    0600)) < 0)
d802 2
a803 2
			if ((fd = open(nhname, O_RDWR | O_CREAT | O_TRUNC |
			    O_EXCL | O_BINARY, 0600)) < 0) {
@


1.147
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d87 3
d573 1
d608 2
d635 6
d749 2
@


1.146
log
@now removes *all* trailing newlines (by reusing histsave result, saves code),
plus plugs an ancient memory leak (hist_execute afree’s its arg now);
also partial revert of commitid 78014291f06497b3 as COMPLEX_HISTORY handles
multi-line commands correctly now (r1.4, 2005-05-23)
@
text
@d383 1
a383 1
	histsave(&hist_source->line, cmd, true, true);
d623 1
a623 1
histsave(int *lnp, const char *cmd, bool dowrite MKSH_A_UNUSED, bool ignoredups)
d625 2
a626 2
	char **hp;
	char *c;
d629 14
d648 2
a649 1
	if (ignoredups && !strcmp(c, *histptr)
d651 1
a651 1
	    && !histsync()
d653 5
a657 3
	    ) {
		afree(c, APERM);
		return;
a658 1
	++*lnp;
d661 1
a661 1
	if (dowrite && histfd != -1)
d665 20
d894 1
a894 1
		histsave(&lno, (char *)(base + 4), false, false);
@


1.145
log
@greatly simplify hist_execute (useless to cut a string in twain, then
restore the very same string), except now, the one trailing newline
is not removed (except in histsave)
@
text
@d41 1
a41 1
static int hist_execute(char *);
d226 1
a226 1
		return (hist_execute(line));
d363 1
a363 1
		return (hist_execute(Xstring(xs, xp)));
d367 1
a367 1
/* Save cmd in history, execute cmd (cmd gets trashed) */
d369 1
a369 1
hist_execute(char *cmd)
d384 5
@


1.144
log
@when storing commands with embedded newlines, don’t take those as end of string
(inspired fix from Debian #783978; bug in original pdksh COMPLEX_HISTORY code)
@
text
@a373 1
	char *p, *q;
d383 1
a383 16
	for (p = cmd; p; p = q) {
		if ((q = strchr(p, '\n'))) {
			/* kill the newline */
			*q++ = '\0';
			if (!*q)
				/* ignore trailing newline */
				q = NULL;
		}
		histsave(&hist_source->line, p, true, true);

		/* POSIX doesn't say this is done... */
		shellf("%s\n", p);
		if (q)
			/* restore \n (trailing \n not restored) */
			q[-1] = '\n';
	}
@


1.143
log
@overhaul the signal handling:
• support NSIG_MAX from http://austingroupbugs.net/view.php?id=741
  and make a TODO for later to use sysconf(_SC_NSIG) at runtime
• bounds-check signals (e.g. no smaller than 1, but smaller than NSIG)
• align trap errorlevel with other shells
• make trap match what’s in POSIX and fixup the manpage
• refactor some code related to signals
• hide from kill builtin both EXIT and ERR pseudo-signals
@
text
@d637 2
a638 1
	char *c, *cp;
d640 4
a643 3
	strdupx(c, cmd, APERM);
	if ((cp = strchr(c, '\n')) != NULL)
		*cp = '\0';
@


1.142
log
@inline only user of ksh_min, make it more cool; drop ksh_min, ksh_max;
move ksh_isdigit etc. to ksh_isalpha etc. definitions
@
text
@d32 1
a32 1
Trap sigtraps[NSIG + 1];
d983 1
a983 2
	/*XXX this is idiotic, use a multi-key/value hashtable! */
	for (i = 0; i <= NSIG; i++) {
a984 4
		if (i == ksh_SIGERR) {
			sigtraps[i].name = "ERR";
			sigtraps[i].mess = "Error handler";
		} else {
d986 1
a986 1
			cs = sys_signame[i];
d988 10
a997 10
			const struct mksh_sigpair *pair = mksh_sigpairs;
			while ((pair->nr != i) && (pair->name != NULL))
				++pair;
			cs = pair->name;
#endif
			if ((cs == NULL) ||
			    (cs[0] == '\0'))
				sigtraps[i].name = shf_smprintf("%d", i);
			else {
				char *s;
d999 7
a1005 12
				/* this is not optimal, what about SIGSIG1? */
				if ((cs[0] & 0xDF) == 'S' &&
				    (cs[1] & 0xDF) == 'I' &&
				    (cs[2] & 0xDF) == 'G' &&
				    cs[3] != '\0') {
					/* skip leading "SIG" */
					cs += 3;
				}
				strdupx(s, cs, APERM);
				sigtraps[i].name = s;
				while ((*s = ksh_toupper(*s)))
					++s;
d1007 5
d1013 1
a1013 1
			sigtraps[i].mess = sys_siglist[i];
d1015 1
a1015 1
			sigtraps[i].mess = strsignal(i);
d1017 1
a1017 1
			sigtraps[i].mess = NULL;
d1019 4
a1022 5
			if ((sigtraps[i].mess == NULL) ||
			    (sigtraps[i].mess[0] == '\0'))
				sigtraps[i].mess = shf_smprintf("%s %d",
				    "Signal", i);
		}
d1024 1
a1024 1
	/* our name for signal 0 */
d1026 4
d1077 1
a1077 1
gettrap(const char *cs, bool igncase)
d1083 4
a1086 2
	if (ksh_isdigit(*cs)) {
		return ((getn(cs, &i) && 0 <= i && i < NSIG) ?
d1088 2
a1089 1
	}
d1092 3
a1094 3
	if ((cs[0] & 0xDF) == 'S' &&
	    (cs[1] & 0xDF) == 'I' &&
	    (cs[2] & 0xDF) == 'G' &&
d1109 2
d1112 2
a1113 1
	for (i = 0; i <= NSIG; i++) {
d1117 9
a1126 2
	p = NULL;
 found:
d1170 2
a1171 2
	int i;
	Trap *p;
d1174 1
a1174 1
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
d1178 2
d1191 2
a1192 2
	int i;
	Trap *p;
d1194 1
a1194 1
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
d1198 2
d1210 2
a1211 2
	int i;
	Trap *p;
d1230 1
a1230 1
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
d1234 2
d1304 2
a1305 2
	int i;
	Trap *p;
d1310 2
a1311 1
	for (i = NSIG+1, p = sigtraps; --i >= 0; p++) {
d1315 2
a1316 1
	}
d1323 2
a1324 2
	int i;
	Trap *p;
d1326 1
a1326 1
	for (i = NSIG+1, p = sigtraps; --i >= 0; p++)
d1330 2
@


1.141
log
@ordinarily, lineno must be mksh_uari_t, but edit.c most of all isn’t ready,
so we mitigate a bit (in var.c mostly) and tweak another type already, and
add some checks (mksh_{,u}ari_t must fit into {,unsigned }long) and print
line numbers with %lu already
@
text
@d1237 7
a1243 3
		if (p->flags & TF_FATAL) {
			/* eg, SIGHUP */
			exstat = (int)ksh_min(128U + (unsigned)i, 255U);
d1245 2
a1246 4
		}
		if (p->flags & TF_DFL_INTR) {
			/* eg, SIGINT, SIGQUIT, SIGTERM, etc. */
			exstat = (int)ksh_min(128U + (unsigned)i, 255U);
a1247 1
		}
@


1.140
log
@SECURITY: make “unset HISTFILE” really work

additionally, make “HISTFILE=” the same, document the truncation and
re-reading process’ further and already-known bugs; this needs work
@
text
@d278 3
a280 2
				shf_fprintf(shl_stdout, "%d",
				    hist_source->line - (int)(histptr - hp));
@


1.139
log
@stop (ab)using the OS symbolic constant EOF, always use -1; plus misc fixes
@
text
@d566 1
a566 1
	if (hname && strcmp(hname, name) == 0)
d584 2
a585 1
	hist_init(hist_source);
d716 2
a717 1
	if ((hname = str_val(global("HISTFILE"))) == NULL)
d719 1
@


1.138
log
@fixup mergo from cid 10054762AC33B0CB0D0
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.136 2014/11/25 21:13:26 tg Exp $");
d306 1
a306 1
	if (shf_close(shf) == EOF) {
@


1.137
log
@oksh RCSID sync (nop because we are portable and thus still require <sys/file.h>)
@
text
@a0 1
/*	$OpenBSD: history.c,v 1.39 2010/05/19 17:36:08 jasper Exp $	*/
d2 1
@


1.136
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d2 1
a2 1
/*	$OpenBSD: trap.c,v 1.23 2010/05/19 17:36:08 jasper Exp $	*/
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.135 2014/11/25 20:00:38 tg Exp $");
@


1.135
log
@stop using ptrdiff_t
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134 2014/06/09 13:25:53 tg Exp $");
a636 1
	mkssert(cmd != NULL);
@


1.134
log
@fix some of the signal stuff (still didn’t get rid of awk(1) and printf(1)
calls in Build.sh, we need HOSTCC for that… which we should do, using BER
or something encoded for integers, and pregenerated hashtables as planned)

also, bump to R50 beta, due to today’s language changes
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.133 2013/10/09 11:59:28 tg Exp $");
d426 1
a426 1
		if ((ptrdiff_t)hp < (ptrdiff_t)history) {
d433 1
a433 1
		} else if ((ptrdiff_t)hp > (ptrdiff_t)histptr) {
@


1.134.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134 2014/06/09 13:25:53 tg Exp $");
d426 1
a426 1
		if ((size_t)hp < (size_t)history) {
d433 1
a433 1
		} else if ((size_t)hp > (size_t)histptr) {
d637 1
@


1.134.2.2
log
@MFC most of the rest: int → bool, MAXPATHLEN, comments/whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.40 2014/11/20 15:22:39 tedu Exp $	*/
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134.2.1 2015/01/25 15:35:46 tg Exp $");
@


1.134.2.3
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d6 1
a6 1
 *		 2011, 2012, 2014, 2015
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134.2.2 2015/01/25 15:44:05 tg Exp $");
d306 1
a306 1
	if (shf_close(shf) == -1) {
@


1.134.2.4
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134.2.3 2015/03/01 15:43:00 tg Exp $");
d566 1
a566 1
	if (hname && name && !strcmp(hname, name))
d584 1
a584 2
	if (name)
		hist_init(hist_source);
d715 1
a715 2
	if (((hname = str_val(global("HISTFILE"))) == NULL) || !*hname) {
		hname = NULL;
a716 1
	}
@


1.134.2.5
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.134.2.4 2015/03/20 22:21:02 tg Exp $");
d278 2
a279 3
				shf_fprintf(shl_stdout, "%lu",
				    (unsigned long)hist_source->line -
				    (unsigned long)(histptr - hp));
@


1.133
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d6 1
a6 1
 *		 2011, 2012
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.132 2013/09/24 20:19:44 tg Exp $");
d980 1
@


1.132
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (‘;’), oksh rcsid sync (they did
accept I was right wrt. set -e), int → bool, and code merge/cleanup
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.131 2012/12/28 02:28:35 tg Exp $");
d723 2
a724 1
	if ((fd = open(hname, O_RDWR | O_CREAT | O_APPEND, 0600)) < 0)
d760 1
a760 1
			    O_EXCL, 0600)) < 0) {
@


1.131
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.130 2012/12/17 23:18:05 tg Exp $");
d445 1
a445 1
		int anchored = *str == '?' ? (++str, 0) : 1;
d512 1
a512 1
findhist(int start, int fwd, const char *str, int anchored)
@


1.130
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.129 2012/12/04 01:18:30 tg Exp $");
d956 1
a956 1
	const char *const name;
d964 6
@


1.129
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.128 2012/11/30 19:02:07 tg Exp $");
d300 1
a300 1
		    "create", tf->tffn, strerror(errno));
d308 1
a308 1
		    "write", tf->tffn, strerror(errno));
d334 1
a334 1
			    "open", tf->tffn, strerror(errno));
d354 1
a354 1
			    "read", tf->tffn, strerror(shf_errno(shf)));
d810 1
a810 1
			    "unlink HISTFILE", hname, strerror(errno));
@


1.128
log
@use proper parenthesēs; int → bool; use same var (eno) for temp. errno
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.127 2012/10/21 21:39:03 tg Exp $");
d637 1
@


1.128.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.128 2012/11/30 19:02:07 tg Exp $");
a636 1
	mkssert(cmd != NULL);
@


1.128.2.2
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d637 1
@


1.127
log
@add some bounds, for a subsequent commit:
• all writers of exstat ensure the value is in [0; 0xFF]
• all readers of exstat AND it with 0xFF (not strictly needed thus)
• trap_exstat is “safe”, i.e. always either -1 or [0; 0xFF]
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.126 2012/06/24 19:47:11 tg Exp $");
d1115 1
a1115 1
	int errno_sv = errno;
d1126 1
a1126 1
	errno = errno_sv;
@


1.126
log
@Coverity 703490: better zero out sigact
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.125 2012/05/05 18:04:20 tg Exp $");
d1227 1
a1227 1
			exstat = 128 + i;
d1232 1
a1232 1
			exstat = 128 + i;
d1247 1
a1247 1
		trap_exstat = exstat;
@


1.125
log
@Valgrind says: close(-1) is not nice
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.124 2012/05/04 20:49:04 tg Exp $");
d1378 2
@


1.124
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.123 2012/04/14 16:07:47 tg Exp $");
d944 4
a947 2
	mksh_unlkfd(histfd);
	(void)close(histfd);
@


1.123
log
@rewrite maketemp() obsoleting tempnam(3) and mkstemp(3) external deps
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.122 2012/04/06 13:29:00 tg Exp $");
d478 1
a478 1
#if !MKSH_S_NOVI
@


1.122
log
@drop str{,n}casecmp, too
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.121 2012/04/01 03:23:08 tg Exp $");
d300 1
a300 1
		    "create", tf->name, strerror(errno));
d308 1
a308 1
		    "write", tf->name, strerror(errno));
d313 1
a313 1
	setstr(local("_", false), tf->name, KSH_RETURN_ERROR);
d332 1
a332 1
		if (!(shf = shf_open(tf->name, O_RDONLY, 0, 0))) {
d334 1
a334 1
			    "open", tf->name, strerror(errno));
d338 1
a338 1
		if (stat(tf->name, &statb) < 0)
d354 1
a354 1
			    "read", tf->name, strerror(shf_errno(shf)));
@


1.121
log
@hide persistent history stuff if not enabled
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.120 2012/03/29 19:22:59 tg Exp $");
d990 6
a995 1
				if (!strncasecmp(cs, "SIG", 3))
d997 1
d1065 1
a1065 1
gettrap(const char *name, int igncase)
d1067 1
a1067 1
	int n = NSIG + 1;
d1069 1
a1069 2
	const char *n2;
	int (*cmpfunc)(const char *, const char *) = strcmp;
d1071 22
a1092 6
	if (ksh_isdigit(*name)) {
		if (getn(name, &n) && 0 <= n && n < NSIG)
			return (&sigtraps[n]);
		else
			return (NULL);
	}
d1094 10
a1103 7
	n2 = strncasecmp(name, "SIG", 3) ? NULL : name + 3;
	if (igncase)
		cmpfunc = strcasecmp;
	for (p = sigtraps; --n >= 0; p++)
		if (!cmpfunc(p->name, name) || (n2 && !cmpfunc(p->name, n2)))
			return (p);
	return (NULL);
@


1.120
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.119 2012/03/28 23:07:47 tg Exp $");
d695 1
d697 1
@


1.119
log
@make this fail betterly
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.118 2012/03/27 22:36:52 tg Exp $");
d345 1
a345 1
			n = statb.st_size + 1;
@


1.118
log
@• implement fcntl(2)-based advisory locking as an alternative iff flock(2)
  is not found, from a suggestion by RT (LP: #912691)
• try harder (in a loop) to acquire a file lock if the locking mechanism
  documents EINTR is a possibility (fcntl always, flock on Linux not .Ox)
• use -std=c99 not -std=gnu99 if it must be at all
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.117 2011/12/31 00:47:45 tg Exp $");
a1453 2
#else
#error oops
d1457 2
a1461 1
#if HAVE_FLOCK
d1463 1
d1465 3
d1473 1
a1474 1
}
@


1.117
log
@LLVM+clang scan-build found a dead store and I found an unneeded assert
@
text
@d5 2
a6 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.113 2011/12/10 14:12:16 tg Exp $");
d727 1
a727 1
	(void)flock(histfd, LOCK_EX);
d819 1
a819 1
	(void)flock(histfd, LOCK_UN);
d884 1
a884 1
	(void)flock(histfd, LOCK_EX);
d921 1
a921 1
	(void)flock(histfd, LOCK_UN);
d942 1
a942 1
	(void)flock(histfd, LOCK_UN);
d1423 50
@


1.116
log
@plug the most atrocious offenders in the persistent history code
to address LP: #906914 (if your history file is corrupt or you
reach the end of HISTLINES, you’re still SOL)

quadruple the standard value for HISTSIZE to help users avoid it;
it’s much better to set it yourself if using persistent history
though; half it on MKSH_SMALL though which defaults to not use it
anyway

also fix handling of larger files a bit and limit the size until
which the files are considered (currently to 96 MiB) until such
time as mmap will no longer be employed to deal in them when the
offending code has been replaced by a rewrite…
@
text
@a768 1
			lines = s->line - (histptr - hp);
@


1.115
log
@put a bit of type safety into the history code
@
text
@d35 3
a37 7
static int hist_count_lines(unsigned char *, int);
static int hist_shrink(unsigned char *, int);
static unsigned char *hist_skip_back(unsigned char *,int *,int);
static void histload(Source *, unsigned char *, size_t);
static void histinsert(Source *, int, const char *);
static void writehistfile(int, char *);
static int sprinkle(int);
a40 1
static int hist_replace(char **, const char *, const char *, bool);
a42 1
static void histbackup(void);
d44 1
a44 2
static char **current;		/* current position in history[] */
static int hstarted;		/* set after hist_init() called */
d68 1
a68 1
static size_t hsize;
d74 12
a90 2
	const char *p;
	char *editor = NULL;
d94 2
a95 2
	const char *first = NULL, *last = NULL;
	char **hfirst, **hlast, **hp;
d116 1
a116 1
				memcpy(editor + len, " $_", 4);
d164 1
a164 1
		char *pat = NULL, *rep = NULL;
d190 36
a225 1
		return (hist_replace(hp, pat, rep, gflag));
d319 1
a319 1
		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_", 0);
d329 1
a329 1
		int n;
d339 1
a339 1
		else if (statb.st_size > (1024 * 1048576)) {
d369 1
d374 7
a380 1
	histbackup();
a412 42
static int
hist_replace(char **hp, const char *pat, const char *rep, bool globr)
{
	char *line;

	if (!pat)
		strdupx(line, *hp, ATEMP);
	else {
		char *s, *s1;
		size_t pat_len = strlen(pat);
		size_t rep_len = strlen(rep);
		size_t len;
		XString xs;
		char *xp;
		bool any_subst = false;

		Xinit(xs, xp, 128, ATEMP);
		for (s = *hp; (s1 = strstr(s, pat)) && (!any_subst || globr);
		    s = s1 + pat_len) {
			any_subst = true;
			len = s1 - s;
			XcheckN(xs, xp, len + rep_len);
			/*; first part */
			memcpy(xp, s, len);
			xp += len;
			/* replacement */
			memcpy(xp, rep, rep_len);
			xp += rep_len;
		}
		if (!any_subst) {
			bi_errorf("bad substitution");
			return (1);
		}
		len = strlen(s) + 1;
		XcheckN(xs, xp, len);
		memcpy(xp, s, len);
		xp += len;
		line = Xclose(xs, xp);
	}
	return (hist_execute(line));
}

d477 3
a479 15
/*
 * Back up over last histsave
 */
static void
histbackup(void)
{
	static int last_line = -1;

	if (histptr >= history && last_line != hist_source->line) {
		hist_source->line--;
		afree(*histptr, APERM);
		histptr--;
		last_line = hist_source->line;
	}
}
d503 1
d541 2
a542 2
			memmove(history, histptr - n, n * sizeof(char *));
			cursize = n;
d561 1
a561 1
	if (hstarted == 0)
d575 1
a575 1
		hsize = 0;
d594 1
a594 1
		histsize = HISTORYSIZE;
d675 4
d688 1
a688 1
 *	<command byte><command number(4 bytes)><bytes><NUL>
d690 5
a694 3
#define HMAGIC1		0xab
#define HMAGIC2		0xcd
#define COMMAND		0xff
d701 2
a702 2
	int lines, fd, rv = 0;
	off_t hfsize;
d708 1
a708 2
	hstarted = 1;

d715 1
d719 1
a719 1
	if ((fd = open(hname, O_RDWR|O_CREAT|O_APPEND, 0600)) < 0)
d728 51
a778 8
	hfsize = lseek(histfd, (off_t)0, SEEK_END);
	hsize = 1024 * 1048576;
	if (hfsize < (off_t)hsize)
		hsize = (size_t)hfsize;

	if (hsize == 0) {
		/* add magic */
		if (sprinkle(histfd)) {
d780 14
a793 1
			return;
d795 8
a802 16
	} else if (hsize > 0) {
		/*
		 * we have some data
		 */
		base = (void *)mmap(NULL, hsize, PROT_READ,
		    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
		/*
		 * check on its validity
		 */
		if (base == (unsigned char *)MAP_FAILED ||
		    *base != HMAGIC1 || base[1] != HMAGIC2) {
			if (base != (unsigned char *)MAP_FAILED)
				munmap(caddr_cast(base), hsize);
			hist_finish();
			if (unlink(hname) /* fails */)
				goto hiniterr;
d805 10
a814 18
		if (hsize > 2) {
			lines = hist_count_lines(base+2, hsize-2);
			if (lines > histsize) {
				/* we need to make the file smaller */
				if (hist_shrink(base, hsize))
					rv = unlink(hname);
				munmap(caddr_cast(base), hsize);
				hist_finish();
				if (rv) {
 hiniterr:
					bi_errorf("can't %s %s: %s",
					    "unlink HISTFILE", hname,
					    strerror(errno));
					hsize = 0;
					return;
				}
				goto retry;
			}
a815 2
		histload(hist_source, base+2, hsize-2);
		munmap(caddr_cast(base), hsize);
d817 2
a818 4
	hfsize = lseek(histfd, (off_t)0, SEEK_END);
	hsize = 1024 * 1048576;
	if (hfsize < (off_t)hsize)
		hsize = hfsize;
a823 40
typedef enum state {
	/* expecting a header */
	shdr,
	/* looking for a NUL byte to end the line */
	sline,
	/* bytes 1 to 4 of a line number */
	sn1, sn2, sn3, sn4
} State;

static int
hist_count_lines(unsigned char *base, int bytes)
{
	State state = shdr;
	int lines = 0;

	while (bytes--) {
		switch (state) {
		case shdr:
			if (*base == COMMAND)
				state = sn1;
			break;
		case sn1:
			state = sn2; break;
		case sn2:
			state = sn3; break;
		case sn3:
			state = sn4; break;
		case sn4:
			state = sline; break;
		case sline:
			if (*base == '\0') {
				lines++;
				state = shdr;
			}
		}
		base++;
	}
	return (lines);
}

d825 1
a825 1
 * Shrink the history file to HISTSIZE lines
d828 1
a828 1
hist_shrink(unsigned char *oldbase, int oldbytes)
d830 2
a831 11
	int fd, rv = 0;
	char *nfile = NULL;
	struct	stat statb;
	unsigned char *nbase = oldbase;
	int nbytes = oldbytes;

	nbase = hist_skip_back(nbase, &nbytes, histsize);
	if (nbase == NULL)
		return (1);
	if (nbase == oldbase)
		return (0);
d833 24
a856 24
	/*
	 * create temp file
	 */
	nfile = shf_smprintf("%s.%d", hname, (int)procpid);
	if ((fd = open(nfile, O_CREAT | O_TRUNC | O_WRONLY, 0600)) < 0)
		goto errout;
	if (fstat(histfd, &statb) >= 0 &&
	    chown(nfile, statb.st_uid, statb.st_gid))
		goto errout;

	if (sprinkle(fd) || write(fd, nbase, nbytes) != nbytes)
		goto errout;
	close(fd);
	fd = -1;

	/*
	 * rename
	 */
	if (rename(nfile, hname) < 0) {
 errout:
		if (fd >= 0) {
			close(fd);
			if (nfile)
				unlink(nfile);
d858 3
a860 97
		rv = 1;
	}
	afree(nfile, ATEMP);
	return (rv);
}

/*
 * find a pointer to the data 'no' back from the end of the file;
 * return the pointer and the number of bytes left
 */
static unsigned char *
hist_skip_back(unsigned char *base, int *bytes, int no)
{
	int lines = 0;
	unsigned char *ep;

	for (ep = base + *bytes; --ep > base; ) {
		/*
		 * this doesn't really work: the 4 byte line number that
		 * is encoded after the COMMAND byte can itself contain
		 * the COMMAND byte...
		 */
		for (; ep > base && *ep != COMMAND; ep--)
			;
		if (ep == base)
			break;
		if (++lines == no) {
			*bytes = *bytes - ((char *)ep - (char *)base);
			return (ep);
		}
	}
	return (NULL);
}

/*
 * load the history structure from the stored data
 */
static void
histload(Source *s, unsigned char *base, size_t bytes)
{
	State state;
	int lno = 0;
	unsigned char *line = NULL;

	for (state = shdr; bytes-- > 0; base++) {
		switch (state) {
		case shdr:
			if (*base == COMMAND)
				state = sn1;
			break;
		case sn1:
			lno = (((*base) & 0xFF) << 24);
			state = sn2;
			break;
		case sn2:
			lno |= (((*base) & 0xFF) << 16);
			state = sn3;
			break;
		case sn3:
			lno |= (((*base) & 0xFF) << 8);
			state = sn4;
			break;
		case sn4:
			lno |= (*base) & 0xFF;
			line = base + 1;
			state = sline;
			break;
		case sline:
			if (*base == '\0') {
				/* worry about line numbers */
				if (histptr >= history && lno-1 != s->line) {
					/* a replacement? */
					histinsert(s, lno, (char *)line);
				} else {
					s->line = lno--;
					histsave(&lno, (char *)line, false,
					    false);
				}
				state = shdr;
			}
		}
	}
}

/*
 * Insert a line into the history at a specified number
 */
static void
histinsert(Source *s, int lno, const char *line)
{
	char **hp;

	if (lno >= s->line - (histptr - history) && lno <= s->line) {
		hp = &histptr[lno - s->line];
		if (*hp)
			afree(*hp, APERM);
		strdupx(*hp, line, APERM);
d862 5
d878 1
a878 1
writehistfile(int lno, char *cmd)
d881 2
a882 2
	ssize_t bytes;
	unsigned char *base, *news, hdr[5];
d886 19
a904 16
	if ((sizenow <= (1024 * 1048576)) && ((size_t)sizenow != hsize)) {
		/*
		 * Things have changed
		 */
		if ((size_t)sizenow > hsize) {
			/* someone has added some lines */
			bytes = (size_t)sizenow - hsize;
			base = (void *)mmap(NULL, (size_t)sizenow, PROT_READ,
			    MAP_FILE | MAP_PRIVATE, histfd, (off_t)0);
			if (base == (unsigned char *)MAP_FAILED)
				goto bad;
			news = base + hsize;
			if (*news != COMMAND) {
				munmap(caddr_cast(base), (size_t)sizenow);
				goto bad;
			}
d909 4
a912 6
			munmap(caddr_cast(base), (size_t)sizenow);
			hsize = (size_t)sizenow;
		} else {
			/* it has shrunk */
			/* but to what? */
			/* we'll give up for now */
a913 1
		}
d915 4
a918 17
	if (cmd) {
		/*
		 * we can write our bit now
		 */
		hdr[0] = COMMAND;
		hdr[1] = (lno >> 24) & 0xFF;
		hdr[2] = (lno >> 16) & 0xFF;
		hdr[3] = (lno >> 8) & 0xFF;
		hdr[4] = lno & 0xFF;
		bytes = strlen(cmd) + 1;
		if ((write(histfd, hdr, 5) != 5) ||
		    (write(histfd, cmd, bytes) != bytes))
			goto bad;
		sizenow = lseek(histfd, (off_t)0, SEEK_END);
		hsize = 1024 * 1048576;
		if (sizenow < (off_t)hsize)
			hsize = (size_t)sizenow;
d920 1
d922 15
a936 3
	return;
 bad:
	hist_finish();
d946 1
a947 11
/*
 * add magic to the history file
 */
static int
sprinkle(int fd)
{
	static const unsigned char mag[] = { HMAGIC1, HMAGIC2 };

	return (write(fd, mag, 2) != 2);
}
#endif
@


1.114
log
@• release flock after the lseek
• -1 not 0 is the safe “none” value for fds
@
text
@d38 1
a38 1
static void histload(Source *, unsigned char *, int);
d542 1
a542 1
sethistsize(int n)
d911 1
a911 1
histload(Source *s, unsigned char *base, int bytes)
@


1.113
log
@shuffle caddr_t to its only user, and use (void *) on Linux instead,
to appease Fefe’s dietlibc [-Wdeprecated-declarations]
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.112 2011/11/26 18:19:00 tg Exp $");
d74 1
a74 1
static int histfd;
d579 1
a579 1
	if (histfd) {
d582 1
a582 1
		histfd = 0;
d620 1
a620 1
	if (histfd) {
d659 1
a659 1
	if (histfd && dowrite)
a780 1
	(void)flock(histfd, LOCK_UN);
d785 1
d1048 1
a1048 1
	histfd = 0;
@


1.112
log
@update and reformat some comments in the history code
@
text
@d29 1
a29 9
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.111 2011/09/07 15:24:16 tg Exp $");

/*-
 * MirOS: This is the default mapping type, and need not be specified.
 * IRIX doesn't have this constant.
 */
#ifndef MAP_FILE
#define MAP_FILE	0
#endif
d55 17
d753 1
a753 1
				munmap((caddr_t)base, hsize);
d765 1
a765 1
				munmap((caddr_t)base, hsize);
d779 1
a779 1
		munmap((caddr_t)base, hsize);
d1003 1
a1003 1
				munmap((caddr_t)base, (size_t)sizenow);
d1010 1
a1010 1
			munmap((caddr_t)base, (size_t)sizenow);
@


1.111
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.110 2011/08/27 18:06:45 tg Exp $");
d530 1
a530 2
 *	set history
 *	this means reallocating the dataspace
d553 2
a554 3
 *	set history file
 *	This can mean reloading/resetting/starting history file
 *	maintenance
d568 1
a568 1
	 * its a new name - possibly
d587 1
a587 1
 *	initialise the history vector
d601 1
a601 5
 *	Routines added by Peter Collinson BSDI(Europe)/Hillside Systems to
 *	a) permit HISTSIZE to control number of lines of history stored
 *	b) maintain a physical history file
 *
 *	It turns out that there is a lot of ghastly hackery here
d667 5
a671 5
 *	Write history data to a file nominated by HISTFILE
 *	if HISTFILE is unset then history still happens, but
 *	the data is not written to a file
 *	All copies of ksh looking at the file will maintain the
 *	same history. This is ksh behaviour.
d673 1
a673 2
 *	This stuff uses mmap()
 *	if your system ain't got it - then you'll have to undef HISTORYFILE
d677 7
a683 8
 *	Open a history file
 *	Format is:
 *	Bytes 1, 2:
 *		HMAGIC - just to check that we are dealing with
 *		the correct object
 *	Then follows a number of stored commands
 *	Each command is
 *	<command byte><command number(4 bytes)><bytes><null>
d782 6
a787 4
	shdr,		/* expecting a header */
	sline,		/* looking for a null byte to end the line */
	sn1,		/* bytes 1 to 4 of a line no */
	sn2, sn3, sn4
d822 1
a822 1
 *	Shrink the history file to histsize lines
d840 1
a840 1
	 *	create temp file
d855 1
a855 1
	 *	rename
d871 2
a872 2
 *	find a pointer to the data 'no' back from the end of the file
 *	return the pointer and the number of bytes left
d884 1
a884 1
		 * the COMMAND byte....
d899 1
a899 1
 *	load the history structure from the stored data
d915 1
a915 1
			lno = (((*base)&0xff)<<24);
d919 1
a919 1
			lno |= (((*base)&0xff)<<16);
d923 1
a923 1
			lno |= (((*base)&0xff)<<8);
d927 2
a928 2
			lno |= (*base)&0xff;
			line = base+1;
d935 1
a935 1
					/* a replacement ? */
d949 1
a949 1
 *	Insert a line into the history at a specified number
d965 6
a970 5
 *	write a command to the end of the history file
 *	This *MAY* seem easy but it's also necessary to check
 *	that the history file has not changed in size.
 *	If it has - then some other shell has written to it
 *	and we should read those commands to update our history
d983 1
a983 1
		 *	Things have changed
d1012 1
a1012 1
		 *	we can write our bit now
d1015 4
a1018 4
		hdr[1] = (lno>>24)&0xff;
		hdr[2] = (lno>>16)&0xff;
		hdr[3] = (lno>>8)&0xff;
		hdr[4] = lno&0xff;
d1043 1
a1043 1
 *	add magic to the history file
@


1.110
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.109 2011/04/22 12:21:53 tg Exp $");
d69 2
a70 2
static const char T_not_in_history[] = "not in history";
#define T_history (T_not_in_history + 7)
d86 1
a86 1
		bi_errorf("history %ss not available", T_function);
d293 1
a293 1
			bi_errorf("%s %s too large: %lu", T_history,
d417 1
a417 1
				bi_errorf("%s: %s", str, T_not_in_history);
d424 1
a424 1
				bi_errorf("%s: %s", str, T_not_in_history);
d436 1
a436 1
			bi_errorf("%s: %s", str, T_not_in_history);
d1080 1
a1080 1
		if (i == SIGERR_) {
d1119 1
a1119 1
	sigtraps[SIGEXIT_].name = "EXIT";
d1197 1
a1197 1
	int errno_ = errno;
d1208 1
a1208 1
	errno = errno_;
d1322 1
a1322 1
	if (i == SIGEXIT_ || i == SIGERR_) {
d1335 1
a1335 1
	if (i == SIGEXIT_ || i == SIGERR_) {
d1457 1
a1457 1
	if (p->signal == SIGEXIT_ || p->signal == SIGERR_)
@


1.109
log
@this is about the amount -Wl,--gc-sections can help me to eliminate
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.108 2011/03/07 20:30:38 tg Exp $");
d66 1
a66 1
static int hsize;
d368 3
a370 3
		int pat_len = strlen(pat);
		int rep_len = strlen(rep);
		int len;
d512 4
a515 4
	char	**hp;
	int	maxhist = histptr - history;
	int	incr = fwd ? 1 : -1;
	int	len = strlen(str);
d703 1
d729 4
a732 1
	hsize = lseek(histfd, (off_t)0, SEEK_END);
d781 4
a784 1
	hsize = lseek(histfd, (off_t)0, SEEK_END);
d980 3
a982 5
	int	sizenow;
	unsigned char	*base;
	unsigned char	*news;
	int	bytes;
	unsigned char	hdr[5];
d986 1
a986 1
	if (sizenow != hsize) {
d990 1
a990 1
		if (sizenow > hsize) {
d992 2
a993 2
			bytes = sizenow - hsize;
			base = (void *)mmap(NULL, sizenow, PROT_READ,
d999 1
a999 1
				munmap((caddr_t)base, sizenow);
d1006 2
a1007 2
			munmap((caddr_t)base, sizenow);
			hsize = sizenow;
d1028 4
a1031 1
		hsize = lseek(histfd, (off_t)0, SEEK_END);
@


1.108
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.107 2011/02/09 19:32:15 tg Exp $");
a528 20
int
findhistrel(const char *str)
{
	int	maxhist = histptr - history;
	int	start = maxhist - 1;
	int	rec;

	getn(str, &rec);
	if (rec == 0)
		return (-1);
	if (rec > 0) {
		if (rec > maxhist)
			return (-1);
		return (rec - 1);
	}
	if (rec > maxhist)
		return (-1);
	return (start + rec + 1);
}

@


1.107
log
@forgot
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.106 2011/02/09 15:08:01 tg Exp $");
d207 1
a207 1
		hfirst = hist_get(first, (lflag || last) ? true : false, lflag);
@


1.106
log
@Limit history file size to 1 GiB for sanity (especially considering struct stat.sb_size is sometimes unsigned, sometimes signed, and sometimes larger than long, ugh…)
@
text
@d5 1
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.105 2011/02/09 13:08:25 tg Exp $");
@


1.105
log
@fix warning about signed vs. unsigned comparision and potential truncation error
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.104 2011/01/30 02:18:20 tg Exp $");
d63 2
a64 1
static char *hname;		/* current name of history file */
d69 3
d93 1
d107 3
a109 1
		case 'g': /* non-AT&T ksh */
d112 1
d116 1
d120 1
d124 3
a126 1
		case 's':	/* POSIX version of -e - */
d129 1
d144 1
d202 4
a205 3
		/* POSIX says not an error if first/last out of bounds
		 * when range is specified; AT&T ksh and pdksh allow out of
		 * bounds for -l as well.
d219 2
a220 1
		rflag = !rflag; /* POSIX */
d292 5
a296 14
		else {
			unsigned long st_sizeUL;

			/* we pretty much assume ulong >= size_t */
			st_sizeUL = (unsigned long)statb.st_size;
			if (
			    /* too big, truncated by the cast */
			    statb.st_size != (long)st_sizeUL ||
			    /* a few additional bytes do not fit */
			    notoktoadd(st_sizeUL, 1 + X_EXTRA)) {
				bi_errorf(T_intovfl, st_sizeUL, '+',
				    1UL + X_EXTRA);
				goto errout;
			}
a297 1
		}
d330 4
a333 2
			*q++ = '\0'; /* kill the newline */
			if (!*q) /* ignore trailing newline */
d345 1
a345 1
	/*
d381 2
a382 1
			memcpy(xp, s, len);		/* first part */
d384 2
a385 1
			memcpy(xp, rep, rep_len);	/* replacement */
d417 1
a417 1
				bi_errorf("%s: %s", str, "not in history");
d424 1
a424 1
				bi_errorf("%s: %s", str, "not in history");
d436 1
a436 1
			bi_errorf("%s: %s", str, "not in history");
d465 3
a467 3
/******************************/
/* Back up over last histsave */
/******************************/
d682 2
a683 1
	if (++hp >= history + histsize) { /* remove oldest command */
d703 1
a703 1
/*
d1130 2
a1131 1
	sigtraps[SIGEXIT_].name = "EXIT";	/* our name for signal 0 */
d1139 2
a1140 1
	sigtraps[SIGTERM].flags |= TF_DFL_INTR; /* not fatal for interactive */
d1334 2
a1335 1
	if (i == SIGEXIT_ || i == SIGERR_) {	/* avoid recursion on these */
d1401 2
a1402 1
	strdupx(p->trap, s, APERM); /* handles s == 0 */
d1446 2
a1447 1
		restore_dfl = 1; /* restore to SIG_DFL */
d1510 2
a1511 1
		sigact.sa_flags = 0 /* interruptible */;
d1531 2
a1532 1
	case SS_RESTORE_CURR: /* leave things as they currently are */
@


1.104
log
@Scan for existence of <sys/file.h> which is not ubiquitous; allows
klibc-mksh (despite no hope to get a signal of a job) persistent history
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.103 2010/11/01 17:29:03 tg Exp $");
d277 10
a286 3
			if (notoktoadd(statb.st_size, 1 + X_EXTRA)) {
				bi_errorf(T_intovfl,
				    (unsigned long)statb.st_size, '+',
@


1.103
log
@change behaviour of argument-less exit in traps to match SUSv4; Debian #599484 (original patch from Jonathan Nieder, thanks!) in a variant that appears to handle nested traps well
@
text
@d25 1
a25 1
#if HAVE_PERSISTENT_HISTORY
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.102 2010/09/14 21:26:13 tg Exp $");
@


1.102
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.101 2010/08/28 20:22:18 tg Exp $");
d1069 2
d1276 1
d1280 3
a1282 1
			runtrap(p);
d1286 1
a1286 1
runtrap(Trap *p)
d1288 2
a1289 4
	int	i = p->signal;
	char	*trapstr = p->trap;
	int	oexstat;
	int	old_changed = 0;
d1291 5
d1297 2
a1298 1
	if (trapstr == NULL) { /* SIG_DFL */
d1309 1
a1309 1
		return;
d1311 3
a1313 2
	if (trapstr[0] == '\0') /* SIG_IGN */
		return;
d1319 2
a1320 1
	oexstat = exstat;
a1325 1
	exstat = oexstat;
d1334 7
@


1.101
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.100 2010/08/28 18:50:52 tg Exp $");
d95 2
d274 11
a284 1
		n = stat(tf->name, &statb) < 0 ? 128 : statb.st_size + 1;
d294 1
d548 1
a548 1
		history = aresize(history, n * sizeof(char *), APERM);
d599 1
a599 1
		history = alloc(histsize * sizeof(char *), APERM);
@


1.100
log
@improve string pooling: saves 316 bytes in .text
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.99 2010/08/28 15:48:18 tg Exp $");
d82 1
a82 1
		bi_errorf("history functions not available");
d310 4
a313 2
		shellf("%s\n", p); /* POSIX doesn't say this is done... */
		if (q)		/* restore \n (trailing \n not restored) */
d359 1
a359 1
			bi_errorf("substitution failed");
d753 3
a755 2
					bi_errorf("cannot unlink HISTFILE %s"
					    " - %s", hname, strerror(errno));
d1093 2
a1094 1
				sigtraps[i].mess = shf_smprintf("Signal %d", i);
@


1.99
log
@whitespace
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.98 2010/07/24 17:08:29 tg Exp $");
d233 2
a234 2
		bi_errorf("cannot create temp file %s - %s",
		    tf->name, strerror(errno));
d241 2
a242 1
		bi_errorf("error writing temporary file - %s", strerror(errno));
d267 2
a268 1
			bi_errorf("cannot open temp file %s", tf->name);
d280 2
a281 2
			bi_errorf("error reading temp file %s - %s",
			    tf->name, strerror(shf_errno(shf)));
d385 1
a385 1
				bi_errorf("%s: not in history", str);
d392 1
a392 1
				bi_errorf("%s: not in history", str);
d396 1
a396 1
			bi_errorf("%s: invalid range", str);
d404 1
a404 1
			bi_errorf("%s: not in history", str);
@


1.98
log
@int → bool
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.97 2010/07/17 22:09:35 tg Exp $");
d1099 1
a1099 1
	sigtraps[SIGTERM].flags |= TF_DFL_INTR;/* not fatal for interactive */
@


1.97
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.96 2010/07/04 17:45:14 tg Exp $");
d53 1
a53 1
static int hist_replace(char **, const char *, const char *, int);
d75 2
a76 1
	int gflag = 0, lflag = 0, nflag = 0, sflag = 0, rflag = 0;
d92 1
a92 1
				sflag++;
d101 1
a101 1
			gflag++;
d104 1
a104 1
			lflag++;
d107 1
a107 1
			nflag++;
d110 1
a110 1
			rflag++;
d113 1
a113 1
			sflag++;
d190 1
a190 2
		hfirst = hist_get(first, (lflag || last) ? true : false,
		    lflag ? true : false);
d193 1
a193 1
		hlast = last ? hist_get(last, true, lflag ? true : false) :
d328 1
a328 1
hist_replace(char **hp, const char *pat, const char *rep, int globr)
d341 1
a341 1
		int any_subst = 0;
d346 1
a346 1
			any_subst = 1;
@


1.96
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.95 2010/07/04 13:36:42 tg Exp $");
d959 1
a959 1
	unsigned char	*new;
d976 2
a977 2
			new = base + hsize;
			if (*new != COMMAND) {
d982 1
a982 1
			histload(hist_source, new, bytes);
@


1.95
log
@simplify a bunch of things (no SIGWINCH handler, errno is saved for
an shtrap automatically) and gratitutous reformatting of comments
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.94 2010/05/22 12:49:14 tg Exp $");
d1436 4
a1439 3
	 * This is here 'cause there should be a way of clearing shtraps,
	 * but don't know if this is a sane way of doing it. At the moment,
	 * all users of shtrap are lifetime users (SIGCHLD, SIGALRM).
@


1.94
log
@apply diff from manuel giraud via oksh to keep track of LINENO in a trap
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.93 2010/05/13 18:44:09 tg Exp $");
d313 2
a314 1
	/* Commands are executed here instead of pushing them onto the
d864 4
a867 3
		/* this doesn't really work: the 4 byte line number that is
		 * encoded after the COMMAND byte can itself contain the
		 * COMMAND byte....
d1124 1
a1124 1
	int errno_ = errno;
a1134 1
	errno = errno_;
d1182 2
a1183 1
/* called when we want to allow the user to ^C out of something - won't
d1193 2
a1194 1
/* called after EINTR to check if a signal with normally causes process
d1211 2
a1212 1
/* Returns the signal number of any pending traps: ie, a signal which has
d1244 2
a1245 1
		/* XXX: this means the alarm will have no effect if a trap
d1291 2
a1292 1
	/* Note: trapstr is fully parsed before anything is executed, thus
d1361 2
a1362 1
		/* assumes handler already set to what shell wants it
d1372 2
a1373 1
/* Called by c_print() when writing to a co-process to ensure SIGPIPE won't
d1401 2
a1402 1
/* Set action for a signal. Action may not be set if original
d1413 2
a1414 1
	/* First time setting this signal? If so, get and note the current
d1424 2
a1425 1
	/* Generally, an ignored signal stays ignored, except if
d1435 4
a1438 3
	/* This is here 'cause there should be a way of clearing shtraps, but
	 * don't know if this is a sane way of doing it. At the moment,
	 * all users of shtrap are lifetime users (SIGCHLD, SIGALRM, SIGWINCH).
@


1.93
log
@sync with oksh (comments and docs only)
@
text
@d1 2
a2 2
/*	$OpenBSD: history.c,v 1.38 2010/05/01 21:09:23 guenther Exp $	*/
/*	$OpenBSD: trap.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.92 2010/01/29 09:34:28 tg Exp $");
d253 1
a253 1
		ret = command(editor ? editor : "${FCEDIT:-/bin/ed} $_");
d321 1
a321 1
	ret = command(cmd);
d1289 1
a1289 1
	command(trapstr);
@


1.92
log
@remove some more of this ugliness
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.37 2009/07/02 16:29:15 martynas Exp $	*/
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.91 2010/01/25 16:12:55 tg Exp $");
d419 1
a419 1
/* Return a pointer to the newest command in the history */
@


1.91
log
@when using persistent history (and not MKSH_SMALL), let the shells
concurrently accessing the same $HISTFILE be more synchronised with
each other: empty lines (just pressing Return) and duplicates (that
are split and written twice by the lines loaded from $HISTFILE in
the meantime); requested by Maximilian “mxey” Gaß in #!/bin/mksh
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.90 2009/12/12 22:27:08 tg Exp $");
d793 4
a796 2
			if (*base == '\0')
				lines++, state = shdr;
@


1.90
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d5 1
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.89 2009/10/02 18:08:33 tg Exp $");
d54 1
a54 1
static char **hist_get(const char *, int, int);
d371 1
a371 1
hist_get(const char *str, int approx, int allow_cur)
d410 1
a410 1
hist_get_newest(int allow_cur)
d595 21
d630 5
a634 1
	if (ignoredups && !strcmp(c, *histptr)) {
d990 15
a1004 13
	/*
	 *	we can write our bit now
	 */
	hdr[0] = COMMAND;
	hdr[1] = (lno>>24)&0xff;
	hdr[2] = (lno>>16)&0xff;
	hdr[3] = (lno>>8)&0xff;
	hdr[4] = lno&0xff;
	bytes = strlen(cmd) + 1;
	if ((write(histfd, hdr, 5) != 5) ||
	    (write(histfd, cmd, bytes) != bytes))
		goto bad;
	hsize = lseek(histfd, (off_t)0, SEEK_END);
@


1.89
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.88 2009/08/08 13:08:51 tg Exp $");
d600 1
a600 1
histsave(int *lnp, const char *cmd, bool dowrite __unused, bool ignoredups)
d1091 1
a1091 1
alarm_catcher(int sig __unused)
@


1.88
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.87 2009/08/01 14:07:42 tg Exp $");
d111 1
a111 1
		case 's':	/* posix version of -e - */
d314 1
a314 1
	 * input 'cause posix says the redirection and variable assignments
@


1.87
log
@fix another warning from
gcc version 4.5.0 20090718 (experimental) [trunk revision 149777] (Debian 20090718-1)
caused by over-optimisation
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.86 2009/07/05 13:51:09 tg Exp $");
d559 1
a559 1
		(void) close(histfd);
d685 1
a685 1
	(void) flock(histfd, LOCK_EX);
d687 1
a687 1
	hsize = lseek(histfd, 0L, SEEK_END);
d700 1
a700 1
		    MAP_FILE | MAP_PRIVATE, histfd, 0);
d734 2
a735 2
	(void) flock(histfd, LOCK_UN);
	hsize = lseek(histfd, 0L, SEEK_END);
d934 2
a935 2
	(void) flock(histfd, LOCK_EX);
	sizenow = lseek(histfd, 0L, SEEK_END);
d944 1
a944 1
			    MAP_FILE | MAP_PRIVATE, histfd, 0);
d977 2
a978 2
	hsize = lseek(histfd, 0L, SEEK_END);
	(void) flock(histfd, LOCK_UN);
d987 2
a988 2
	(void) flock(histfd, LOCK_UN);
	(void) close(histfd);
@


1.86
log
@pure RCSID sync with oksh; Decklin Foster was faster than Stefan Pettersson
*and* reported it (mksh R33d on Debian) to the right people :þ
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.85 2009/06/11 12:42:18 tg Exp $");
d661 1
a661 2
	int lines;
	int fd;
a713 2
			int rv = 0;

@


1.85
log
@capitalise AT&T®
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.36 2008/05/20 00:30:30 fgsch Exp $	*/
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.84 2009/06/10 18:12:46 tg Exp $");
@


1.84
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.83 2009/06/08 20:06:46 tg Exp $");
d99 1
a99 1
		case 'g': /* non-at&t ksh */
d186 1
a186 1
		 * when range is specified; at&t ksh and pdksh allow out of
@


1.83
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.82 2009/05/27 09:58:22 tg Exp $");
d114 1
a114 1
		  /* kludge city - accept -num as -- -num (kind of) */
d645 3
a647 2
 *	Bytes 1, 2: HMAGIC - just to check that we are dealing with
 *		    the correct object
d1200 1
a1200 1
 * run any pending traps.  If intr is set, only run traps that
d1367 1
a1367 1
/* Set action for a signal.  Action may not be set if original
d1378 1
a1378 1
	/* First time setting this signal?  If so, get and note the current
d1399 1
a1399 1
	 * don't know if this is a sane way of doing it.  At the moment,
@


1.82
log
@• Build.sh, strlcpy.c: gcc-current conversion &c. warnings cleanup
• histrap.c, lex.c, misc.c: get average stack frame size to <= 768 bytes
• check.t, sh.h: bump version
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.81 2009/05/16 18:40:06 tg Exp $");
d82 1
a82 1
		return 1;
d125 1
a125 1
				return 1;
d129 1
a129 1
			return 1;
d139 1
a139 1
			return 1;
d154 1
a154 1
			return 1;
d160 2
a161 2
			return 1;
		return hist_replace(hp, pat, rep, gflag);
d166 1
a166 1
		return 1;
d175 1
a175 1
		return 1;
d181 1
a181 1
			return 1;
d192 1
a192 1
			return 1;
d196 1
a196 1
			return 1;
d226 1
a226 1
		return 0;
d235 1
a235 1
		return 1;
d242 1
a242 1
		return 1;
d256 1
a256 1
			return ret;
d267 1
a267 1
			return 1;
d281 1
a281 1
			return 1;
d286 1
a286 1
		return hist_execute(Xstring(xs, xp));
d323 1
a323 1
	return ret;
d355 1
a355 1
			return 1;
d363 1
a363 1
	return hist_execute(line);
d405 1
a405 1
	return hp;
d414 1
a414 1
		return NULL;
d425 1
a425 1
		return NULL;
d427 1
a427 1
	return history;
d452 1
a452 1
	return current;
d462 1
a462 1
		return last;
d465 1
a465 1
		return n;
d489 1
a489 1
			return hp - history;
d491 1
a491 1
	return -1;
d503 1
a503 1
		return -1;
d506 2
a507 2
			return -1;
		return rec - 1;
d510 2
a511 2
		return -1;
	return start + rec + 1;
d530 1
a530 1
		history = aresize(history, n * sizeof (char *), APERM);
d581 1
a581 1
		history = alloc(histsize * sizeof (char *), APERM);
d775 1
a775 1
	return lines;
d792 1
a792 1
		return 1;
d794 1
a794 1
		return 0;
d848 1
a848 1
			return ep;
d851 1
a851 1
	return NULL;
d1002 1
a1002 1
	return(write(fd, mag, 2) != 2);
d1177 2
a1178 2
			return 128 + p->signal;
	return 0;
d1194 2
a1195 2
			return p->signal;
	return 0;
d1355 1
a1355 1
	return restore_dfl;
d1375 1
a1375 1
		return 1;
d1393 1
a1393 1
		return 0;
d1416 1
a1416 1
	return 1;
@


1.81
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.80 2009/05/16 16:59:36 tg Exp $");
d784 2
a785 2
	int fd;
	char	nfile[PATH_MAX];
d799 1
a799 1
	shf_snprintf(nfile, sizeof(nfile), "%s.%d", hname, (int)procpid);
d801 1
a801 1
		return 1;
d806 2
a807 6
	if (sprinkle(fd) || write(fd, nbase, nbytes) != nbytes) {
 errout:
		close(fd);
		unlink(nfile);
		return 1;
	}
d809 1
d814 11
a824 3
	if (rename(nfile, hname) < 0)
		return 1;
	return 0;
@


1.80
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.79 2009/04/07 21:23:28 tg Exp $");
d33 1
a33 1
 * IRIX doesn’t have this constant.
@


1.79
log
@fix an oversight
@
text
@d4 20
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.78 2009/04/07 18:41:35 tg Exp $");
@


1.78
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.77 2009/02/20 13:25:09 tg Exp $");
d987 1
a987 1
	{ 0, NULL }
@


1.77
log
@<sys/file.h> is only required for, and only contains, flock(2)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.76 2008/12/13 17:02:14 tg Exp $");
d983 1
a984 1
	const char *const name;
@


1.76
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 3
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.75 2008/11/12 00:54:48 tg Exp $");
@


1.75
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.74 2008/11/09 20:32:17 tg Exp $");
d71 1
a71 1
				editor = alloc(1, len + 4, ATEMP);
d507 1
a507 1
		history = aresize(history, n, sizeof (char *), APERM);
d558 1
a558 1
		history = alloc(histsize, sizeof (char *), APERM);
@


1.75.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.75 2008/11/12 00:54:48 tg Exp $");
d71 1
a71 1
				editor = galloc(1, len + 4, ATEMP);
d248 1
a248 1
		Xinit(xs, xp, n, hist_source->gp_source);
d417 1
a417 1
		gfree(*histptr, APERM);
d507 1
a507 1
		history = grealloc(history, n, sizeof (char *), APERM);
d539 1
a539 1
		gfree(hname, APERM);
d558 1
a558 1
		history = galloc(histsize, sizeof (char *), APERM);
d587 1
a587 1
		gfree(c, APERM);
d600 1
a600 1
		gfree(*history, APERM);
d887 1
a887 1
			gfree(*hp, APERM);
d1232 1
a1232 1
	 * no problem with gfree(p->trap) in settrap() while still in use.
d1239 1
a1239 1
			gfree(trapstr, APERM);
d1282 1
a1282 1
		gfree(p->trap, APERM);
@


1.74
log
@build warning-free with LLVM+Clang on MirBSD itself
$ (CCC_LD=mgcc CC=ccc sh Build.sh -r && ./test.sh -v) 2>&1 | tee log
Total failed: 2 (as expected)
Total passed: 278

Just the result is huge, and we could of course build to intermediate
byte code to optimise globally…
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.73 2008/10/28 14:32:41 tg Exp $");
d71 1
a71 1
				editor = alloc(len + 4, ATEMP);
d417 1
a417 1
		afree((void*)*histptr, APERM);
d507 1
a507 1
		history = (char **)aresize(history, n*sizeof(char *), APERM);
d558 1
a558 1
		history = (char **)alloc(histsize * sizeof (char *), APERM);
d600 1
a600 1
		afree((void*)*history, APERM);
d887 1
a887 1
			afree((void*)*hp, APERM);
@


1.73
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.72 2008/10/14 19:48:27 tg Exp $");
d1036 1
a1036 1
	sigemptyset(&Sigact_ign.sa_mask);
d1382 1
a1382 1
		sigemptyset(&sigact.sa_mask);
@


1.72
log
@fix a warning
From: Elias Pipping <elias@@pipping.org>
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.71 2008/10/13 23:06:02 tg Exp $");
d121 1
a121 1
			pat = str_save(*wp, ATEMP);
d309 1
a309 1
		line = str_save(*hp, ATEMP);
d582 1
a582 1
	c = str_save(cmd, APERM);
d651 1
a651 1
	hname = str_save(hname, APERM);
d888 1
a888 1
		*hp = str_save(line, APERM);
d1017 2
a1018 1
				sigtraps[i].name = s = str_save(cs, APERM);
d1283 1
a1283 1
	p->trap = str_save(s, APERM); /* handles s == 0 */
@


1.71
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.70 2008/09/30 19:36:16 tg Exp $");
d867 2
a868 1
					histsave(&lno, line, false, false);
@


1.70
log
@• check.t: change history-e-minus-5 regression test to avoid false failure
  caused by ignoredups history control
• histrap.c: enable ignoredups after fc -s editing too
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.69 2008/09/30 19:25:51 tg Exp $");
d286 1
a286 1
		if ((p = q)) /* restore \n (trailing \n not restored) */
@


1.69
log
@ignore more dups
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.68 2008/09/30 17:49:26 tg Exp $");
d283 1
a283 2
		/* setting ignoredups to true breaks history-e-minus-5 */
		histsave(&hist_source->line, p, true, false);
@


1.68
log
@däs isch ei buul, koa int…
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.67 2008/07/12 17:16:03 tg Exp $");
d283 2
a284 1
		histsave(++(hist_source->line), p, true);
d578 1
a578 1
histsave(int lno __unused, const char *cmd, bool dowrite __unused)
d587 6
d595 1
a595 1
		writehistfile(lno, c);
d834 2
a835 2
	int	lno = 0;
	unsigned char	*line = NULL;
d867 2
a868 2
					s->line = lno;
					histsave(lno, (char *)line, false);
@


1.67
log
@even simpler *and* const clean
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.66 2008/07/12 16:56:39 tg Exp $");
d283 1
a283 1
		histsave(++(hist_source->line), p, 1);
d577 1
a577 1
histsave(int lno __unused, const char *cmd, int dowrite __unused)
d861 1
a861 1
					histsave(lno, (char *)line, 0);
@


1.66
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.65 2008/07/06 22:41:08 tg Exp $");
d1008 3
a1010 2
				s = !strncasecmp(cs, "SIG", 3) ? cs + 3 : cs;
				sigtraps[i].name = s = str_save(s, APERM);
@


1.65
log
@check return value of unlink(2) when trying to remove an existing HISTFILE,
since mksh(1) did go into an infinite loop if that fails first

bug spotted, initial patch and help drafting a test case
From: Decklin Foster <decklin@@red-bean.com>

note there are more instances of unlink(2) and others (like chmod(2), as
spotted by flawfinder) which aren’t checked… but at least the other case
of unlink(2) use in histrap.c doesn’t cause any trouble (I think)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.64 2008/06/08 17:16:25 tg Exp $");
d24 1
a24 1
static void histinsert(Source *, int, unsigned char *);
d71 2
a72 1
				editor = str_nsave(p, len + 4, ATEMP);
d643 1
a643 2
	hname = str_val(global("HISTFILE"));
	if (hname == NULL)
d858 1
a858 1
					histinsert(s, lno, line);
d873 1
a873 1
histinsert(Source *s, int lno, unsigned char *line)
d877 2
a878 2
	if (lno >= s->line-(histptr-history) && lno <= s->line) {
		hp = &histptr[lno-s->line];
d881 1
a881 1
		*hp = str_save((char *)line, APERM);
d1008 2
a1009 3
				sigtraps[i].name = s = str_save(
				    !strncasecmp(cs, "SIG", 3) ? cs + 3 : cs,
				    APERM);
@


1.64
log
@fix the RCS IDs
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.63 2008/06/08 17:14:31 tg Exp $");
d680 2
a681 1
			unlink(hname);
d685 2
d691 1
a691 1
					unlink(hname);
d694 7
@


1.63
log
@cast two pointer arithmetics to ptrdiff_t

commit inspired by fgsch:
> Log message:
> cast pointer arithmetic to unsigned so we can behave correctly on
> underflows. fixes fc -l 1 in my box where line is 1667511151.
> krw@@ ok.

  to signed rather. oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.35 2006/05/29 18:22:24 otto Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.62 2008/05/17 18:46:59 tg Exp $");
@


1.62
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.61 2008/04/19 17:21:53 tg Exp $");
d354 1
a354 1
		if (hp < history) {
d361 1
a361 1
		} else if (hp > histptr) {
@


1.61
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.60 2008/04/02 16:55:06 tg Exp $");
d557 1
a557 1
		history = (char **)alloc(histsize*sizeof (char *), APERM);
@


1.60
log
@• Ultrix doesn’t define MAP_FAILED either
• on Ultrix, mmap() returns a caddr_t instead of a void*, so cast
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.59 2008/03/27 17:59:28 tg Exp $");
d192 7
a198 3
			for (s = *hp; (t = strchr(s, '\n')); s = t)
				shf_fprintf(shl_stdout, "%.*s\t",
				    (int)(++t - s), s);
@


1.59
log
@ignore failure to define MAP_FILE
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.58 2008/03/05 16:54:21 tg Exp $");
d666 2
a667 2
		base = mmap(NULL, hsize, PROT_READ, MAP_FILE | MAP_PRIVATE,
		    histfd, 0);
d896 1
a896 1
			base = mmap(NULL, sizenow, PROT_READ,
@


1.58
log
@shut up gcc-lib/alpha-dec-osf4.0d/2.8.1
@
text
@d6 9
a14 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.57 2007/10/25 15:34:30 tg Exp $");
@


1.58.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d6 1
a6 9
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.60 2008/04/02 16:55:06 tg Exp $");

/*-
 * MirOS: This is the default mapping type, and need not be specified.
 * IRIX doesn’t have this constant.
 */
#ifndef MAP_FILE
#define MAP_FILE	0
#endif
d658 2
a659 2
		base = (void *)mmap(NULL, hsize, PROT_READ,
		    MAP_FILE | MAP_PRIVATE, histfd, 0);
d888 1
a888 1
			base = (void *)mmap(NULL, sizenow, PROT_READ,
@


1.58.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.62 2008/05/17 18:46:59 tg Exp $");
d192 3
a194 7
			s = *hp;
			while ((t = strchr(s, '\n'))) {
				*t = '\0';
				shf_fprintf(shl_stdout, "%s\n\t", s);
				*t++ = '\n';
				s = t;
			}
d553 1
a553 1
		history = (char **)alloc(histsize * sizeof (char *), APERM);
@


1.58.2.3
log
@MFC: mksh R35
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.36 2008/05/20 00:30:30 fgsch Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.65 2008/07/06 22:41:08 tg Exp $");
d354 1
a354 1
		if ((ptrdiff_t)hp < (ptrdiff_t)history) {
d361 1
a361 1
		} else if ((ptrdiff_t)hp > (ptrdiff_t)histptr) {
d680 1
a680 2
			if (unlink(hname) /* fails */)
				goto hiniterr;
a683 2
			int rv = 0;

d688 1
a688 1
					rv = unlink(hname);
a690 7
				if (rv) {
 hiniterr:
					bi_errorf("cannot unlink HISTFILE %s"
					    " - %s", hname, strerror(errno));
					hsize = 0;
					return;
				}
@


1.58.2.4
log
@MFC: mksh R35b
@
text
@d6 1
a6 1
__RCSID("$MirOS$");
d24 1
a24 1
static void histinsert(Source *, int, const char *);
d71 1
a71 2
				editor = alloc(len + 4, ATEMP);
				memcpy(editor, p, len);
d642 2
a643 1
	if ((hname = str_val(global("HISTFILE"))) == NULL)
d858 1
a858 1
					histinsert(s, lno, (char *)line);
d873 1
a873 1
histinsert(Source *s, int lno, const char *line)
d877 2
a878 2
	if (lno >= s->line - (histptr - history) && lno <= s->line) {
		hp = &histptr[lno - s->line];
d881 1
a881 1
		*hp = str_save(line, APERM);
d1008 3
a1010 3
				if (!strncasecmp(cs, "SIG", 3))
					cs += 3;
				sigtraps[i].name = s = str_save(cs, APERM);
@


1.58.2.5
log
@MFC: mksh R36b
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.76 2008/12/13 17:02:14 tg Exp $");
d121 1
a121 1
			strdupx(pat, *wp, ATEMP);
d283 1
a283 1
		histsave(&hist_source->line, p, true, true);
d286 1
a286 1
		if (q)		/* restore \n (trailing \n not restored) */
d309 1
a309 1
		strdupx(line, *hp, ATEMP);
d417 1
a417 1
		afree(*histptr, APERM);
d507 1
a507 1
		history = aresize(history, n * sizeof (char *), APERM);
d558 1
a558 1
		history = alloc(histsize * sizeof (char *), APERM);
d577 1
a577 1
histsave(int *lnp, const char *cmd, bool dowrite __unused, bool ignoredups)
d582 1
a582 1
	strdupx(c, cmd, APERM);
a585 6
	if (ignoredups && !strcmp(c, *histptr)) {
		afree(c, APERM);
		return;
	}
	++*lnp;

d588 1
a588 1
		writehistfile(*lnp, c);
d594 1
a594 1
		afree(*history, APERM);
d645 1
a645 1
	strdupx(hname, hname, APERM);
d827 2
a828 2
	int lno = 0;
	unsigned char *line = NULL;
d860 2
a861 3
					s->line = lno--;
					histsave(&lno, (char *)line, false,
					    false);
d880 2
a881 2
			afree(*hp, APERM);
		strdupx(*hp, line, APERM);
d1010 1
a1010 2
				strdupx(s, cs, APERM);
				sigtraps[i].name = s;
d1028 1
a1028 1
	(void)sigemptyset(&Sigact_ign.sa_mask);
d1275 1
a1275 1
	strdupx(p->trap, s, APERM); /* handles s == 0 */
d1374 1
a1374 1
		(void)sigemptyset(&sigact.sa_mask);
@


1.57
log
@optimise more :)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.56 2007/09/09 19:12:09 tg Exp $");
d617 3
a619 3
	unsigned char	*base;
	int	lines;
	int	fd;
d663 3
a665 2
		if (base == MAP_FAILED || *base != HMAGIC1 || base[1] != HMAGIC2) {
			if (base != MAP_FAILED)
d890 1
a890 1
			if (base == MAP_FAILED)
@


1.56
log
@shut up some gcc warn_unused_result thingies from Fedora
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.55 2007/08/20 14:12:29 tg Exp $");
d380 1
a380 3
	if (allow_cur)
		return histptr;
	return histptr - 1;
d422 1
a422 1
	int	last = histptr - history;
@


1.55
log
@shut up tcc
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.54 2007/07/31 10:42:15 tg Exp $");
d752 3
a754 2
	if (fstat(histfd, &statb) >= 0)
		chown(nfile, statb.st_uid, statb.st_gid);
d756 2
a757 6
	if (sprinkle(fd)) {
		close(fd);
		unlink(nfile);
		return 1;
	}
	if (write(fd, nbase, nbytes) != nbytes) {
d919 4
a922 2
	(void) write(histfd, hdr, 5);
	(void) write(histfd, cmd, strlen(cmd)+1);
@


1.54
log
@some steps towards building with tcc
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.53 2007/07/22 14:01:49 tg Exp $");
d1059 1
a1059 1
	int (*cmpfunc)(const char *, const char *);
d1069 2
a1070 1
	cmpfunc = igncase ? strcasecmp : strcmp;
@


1.53
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.52 2007/07/22 13:34:50 tg Exp $");
d1058 2
d1064 8
a1071 4
	} else for (p = sigtraps; --n >= 0; p++)
		if (!(igncase ? strcasecmp : strcmp)(p->name, name) ||
		   (!strncasecmp(name, "SIG", 3) &&
		    !(igncase ? strcasecmp : strcmp)(p->name, name + 3)))
@


1.52
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.51 2007/07/01 21:10:28 tg Exp $");
a175 1
		const char *nfmt = nflag ? "\t" : "%d\t";
@


1.51
log
@Borland C++ found these
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.50 2007/07/01 17:13:52 tg Exp $");
d180 4
a183 2
			shf_fprintf(shl_stdout, nfmt,
			    hist_source->line - (int) (histptr - hp));
@


1.50
log
@fix mmap args and retval (cosmetic)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.49 2007/06/06 23:28:15 tg Exp $");
d41 1
a41 1
	struct temp *tf = NULL;
d363 1
a363 2
		n = findhist(histptr - history - 1, 0, str, anchored);
		if (n < 0) {
d365 1
a365 2
			hp = NULL;
		} else
@


1.49
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.48 2007/06/05 21:47:48 tg Exp $");
d661 2
a662 2
		base = (unsigned char *)mmap(0, hsize, PROT_READ,
		    MAP_FILE|MAP_PRIVATE, histfd, 0);
d893 2
a894 2
			base = (unsigned char *)mmap(0, sizenow,
			    PROT_READ, MAP_FILE|MAP_PRIVATE, histfd, 0);
@


1.48
log
@with this, we don't need the special list of pre-known signal names
any more either, and can make use of code sharing between detection
of sys_siglist and sys_signame (and the underscored variants); nuke
the now-useless signames.c file too (merge struct into histrap.c)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.47 2007/06/04 21:33:28 tg Exp $");
d9 1
a9 1
static struct sigaction Sigact_ign, Sigact_trap;
a1011 2
	Sigact_trap = Sigact_ign;
	Sigact_trap.sa_handler = trapsig;
@


1.47
log
@compile warning-free on SUNpro (regression test suite pass) for MirBSD
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.46 2007/05/13 17:51:22 tg Exp $");
d952 8
a959 5
#if HAVE_SYS_SIGNAME
#elif HAVE__SYS_SIGNAME
#define sys_signame	_sys_signame
#else
#include "signames.c"
d975 1
a975 1
#if HAVE_SYS_SIGNAME || HAVE__SYS_SIGNAME
@


1.46
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.45 2007/03/04 03:04:25 tg Exp $");
d1339 1
a1339 1
		p->shtrap = NULL;
@


1.45
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.44 2007/03/04 00:13:16 tg Exp $");
d1362 1
a1362 1
		internal_errorf(1, "setexecsig: unset signal %d(%s)",
@


1.45.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.45 2007/03/04 03:04:25 tg Exp $");
d1362 1
a1362 1
		internal_errorf("setexecsig: unset signal %d(%s)",
@


1.45.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.45.2.1 2007/05/13 19:29:36 tg Exp $");
d9 1
a9 1
static struct sigaction Sigact_ign;
d41 1
a41 1
	struct temp *tf;
d363 2
a364 1
		if ((n = findhist(histptr - history - 1, 0, str, anchored)) < 0)
d366 2
a367 1
		else
d661 2
a662 2
		base = mmap(NULL, hsize, PROT_READ, MAP_FILE | MAP_PRIVATE,
		    histfd, 0);
d893 2
a894 2
			base = mmap(NULL, sizenow, PROT_READ,
			    MAP_FILE | MAP_PRIVATE, histfd, 0);
d1009 2
@


1.44
log
@merge the const branch +- a few
@
text
@d6 1
a6 1
__RCSID("$MirOS$");
d21 9
a29 9
static int	hist_execute(char *);
static int	hist_replace(char **, const char *, const char *, int);
static char   **hist_get(const char *, int, int);
static char   **hist_get_oldest(void);
static void	histbackup(void);

static char   **current;	/* current position in history[] */
static int	hstarted;	/* set after hist_init() called */
static Source	*hist_source;
d32 3
a34 3
static char    *hname;		/* current name of history file */
static int	histfd;
static int	hsize;
d59 1
a59 1
			if (strcmp(p, "-") == 0)
@


1.43
log
@mirtoconf the checks if to use persistent history support
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.42 2007/02/27 15:03:28 tg Exp $");
d38 1
a38 1
c_fc(char **wp)
d42 2
a43 1
	char *p, *editor = NULL;
d46 1
a46 1
	char *first = NULL, *last = NULL;
d111 1
a111 1
		if (*wp && **wp && (p = strchr(*wp + 1, '='))) {
d113 2
a114 3
			p = pat + (p - *wp);
			*p++ = '\0';
			rep = p;
d1242 1
a1242 1
settrap(Trap *p, char *s)
@


1.42
log
@typo, prevents compilation under Interix (has _sys_signame[] array)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.41 2007/01/17 23:47:15 tg Exp $");
d11 1
a11 1
#ifdef V_HISTFILE
d31 1
a31 1
#ifdef V_HISTFILE
d504 1
a504 1
#ifdef V_HISTFILE
d576 1
a576 1
#ifdef V_HISTFILE
d619 1
a619 1
#ifdef V_HISTFILE
d632 1
a632 1
#ifdef V_HISTFILE
d692 1
a692 1
#ifdef V_HISTFILE
@


1.41
log
@* Build.sh, histrap.c: prevent testing of strsignal() if we have sys_siglist[]
* mksh.1: .Nm is never used with "" as argument, fixes GNU groff 1.15
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.40 2007/01/15 02:48:27 tg Exp $");
d972 1
a972 1
#if HAVE_SYS_SIGNAME || HAVE_SYS_SIGNAME
@


1.40
log
@shrink .data a little
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.39 2007/01/12 02:06:34 tg Exp $");
a993 2
#elif HAVE__SYS_SIGLIST
			sigtraps[i].mess = _sys_siglist[i];
@


1.39
log
@* histrap.c: picky /a1/sw/pkgs/gcc-3.4.3/bin/../lib/gcc/sparc-sun-solaris2.8/3.4.3/
* main.c: thinko
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.38 2007/01/12 01:49:28 tg Exp $");
d946 1
a946 1
	static unsigned char mag[] = { HMAGIC1, HMAGIC2 };
@


1.39.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.43 2007/03/03 21:36:07 tg Exp $");
d11 1
a11 1
#if HAVE_PERSISTENT_HISTORY
d31 1
a31 1
#if HAVE_PERSISTENT_HISTORY
d504 1
a504 1
#if HAVE_PERSISTENT_HISTORY
d576 1
a576 1
#if HAVE_PERSISTENT_HISTORY
d619 1
a619 1
#if HAVE_PERSISTENT_HISTORY
d632 1
a632 1
#if HAVE_PERSISTENT_HISTORY
d692 1
a692 1
#if HAVE_PERSISTENT_HISTORY
d946 1
a946 1
	static const unsigned char mag[] = { HMAGIC1, HMAGIC2 };
d972 1
a972 1
#if HAVE_SYS_SIGNAME || HAVE__SYS_SIGNAME
d994 2
@


1.39.2.2
log
@begin constification
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.39.2.1 2007/03/03 21:37:56 tg Exp $");
d38 1
a38 1
c_fc(const char **wp)
@


1.39.2.3
log
@more constification
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.39.2.2 2007/03/03 22:38:24 tg Exp $");
d42 1
a42 2
	const char *p;
	char *editor = NULL;
d45 1
a45 1
	const char *first = NULL, *last = NULL;
d110 1
a110 1
		if (*wp && **wp && (p = cstrchr(*wp + 1, '='))) {
d112 3
a114 2
			rep = pat + (p - *wp);
			*rep++ = '\0';
d1242 1
a1242 1
settrap(Trap *p, const char *s)
@


1.38
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.37 2007/01/12 01:30:35 tg Exp $");
d989 1
a989 1
				while (*s = ksh_toupper(*s))
@


1.37
log
@constify
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.36 2007/01/12 00:37:09 tg Exp $");
d567 1
a567 2
histsave(int lno __attribute__((unused)), const char *cmd,
    int dowrite __attribute__((unused)))
d1039 1
a1039 1
alarm_catcher(int sig __attribute__((unused)))
@


1.36
log
@* inittraps: convert signal _names_ to uppercase, we're matching
  case-sensitively in the 'trap' builtin, and Mac OSX has them
  in lowercase at sys_signame[]…
* gettraps: optimise
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.35 2007/01/12 00:25:40 tg Exp $");
d964 1
a964 1
	char *s;
d974 1
a974 1
			s = sys_signame[i];
d979 1
a979 1
			s = pair->name;
d981 2
a982 2
			if ((s == NULL) ||
			    (s[0] == '\0'))
d985 2
d988 1
a988 1
				    !strncasecmp(s, "SIG", 3) ? s + 3 : s,
@


1.35
log
@Clean up the signal mess, saves 172 Bytes:
* 'sigseen' in Build.sh goes away
* Signal name existence is checked in this order:
  have our own¹ -> sys_signame[] -> _sys_signame[] -> build our own²
* Signal description existence is checked in this order:
  sys_siglist[] -> _sys_siglist[] -> strsignal() -> NULL³
¹ Predefined list of items, for operating systems where we
  cannot build² them, i.e. Plan 9 and Minix 3 (e.g. no $CPP -dD)
² The usual cpp(1) stuff
³ Changed later, see below
* Make $CPP test dependent on $NEED_MKSH_SIGNAME (others can
  be added here, this is not absolute)
* Make signal name list generation² dependent on $NEED_MKSH_SIGNAME
* Fix check if the generation worked
* Guarantee that sigtraps[*].name and sigtraps[*].mess are valid
  C strings; this makes the code shorter *and* removes a few pos-
  sible nil pointer dereferences
* Embed autoconf'd usages of sys_sig* / strsignal / mksh_sigpairs
  into inittraps()
* Check for each signal 0<=i<=NSIG that
  name is not NULL or "" -> replace with ("%d", i)
  mess is not NULL or "" -> replace with ("Signal %d", i)
  name does not start (case-insensitive) with "SIG" -> name += 3
* In gettrap(), fix check if signal name starts, case-sensitive
  or case-insensitive, depending on need, with "SIG" (bug from millert@@)

Other changes:
* Build.sh: ac_test[n]() are documented
* Build.sh: ac_test[n]() can have negative prereqs as well now
* Build.sh: use <<-'EOF' consistently
* bump patchlevel to today
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.34 2006/11/12 12:49:25 tg Exp $");
d963 2
a964 1
	int	i;
d974 1
a974 1
			sigtraps[i].name = sys_signame[i];
d979 1
a979 1
			sigtraps[i].name = pair->name;
d981 10
a999 3
			if ((sigtraps[i].name == NULL) ||
			    (sigtraps[i].name[0] == '\0'))
				sigtraps[i].name = shf_smprintf("%d", i);
a1002 2
			if (!strncasecmp(sigtraps[i].name, "SIG", 3))
				sigtraps[i].name += 3;
d1057 1
a1057 1
	int i;
a1060 2
		int n;

d1062 2
a1063 4
			return &sigtraps[n];
		return NULL;
	}
	for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
d1068 1
a1068 1
	return NULL;
@


1.34
log
@format string warnings, courtesy of Interix 3.5
@
text
@d6 1
a6 16
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.33 2006/11/10 07:52:02 tg Exp $");

#ifndef mksh_siglist
#if defined(BSD) || defined(__APPLE__)
#define	mksh_signame(x)	sys_signame[(x)]
#define	mksh_siglist(x)	sys_siglist[(x)]
#elif defined(__INTERIX)
#define	mksh_signame(x)	_sys_signame[(x)]
#define	mksh_siglist(x) _sys_siglist[(x)]
#elif defined(__gnu_linux__) || defined(__sun__) || defined(__CYGWIN__)
#define	NEED_MKSH_SIGNAME	/* sync the list above with Build.sh */
#define	mksh_siglist(x)	strsignal(x)
#else
# error "Define sys_sig{name,list} for this platform!"
#endif
#endif /* ndef mksh_siglist */
d953 5
a957 19
#ifdef NEED_MKSH_SIGNAME
static const char *
mksh_signame(int s)
{
	int i = 0;
	static const struct _mksh_sigpair {
		int nr;
		const char *name;
	} mksh_sigpair[] = {
#include "signames.inc"
		{ 0, NULL }
	};

 mksh_sigscan:
	if ((mksh_sigpair[i].nr == s) || !mksh_sigpair[i].name)
		return (mksh_sigpair[i].name);
	++i;
	goto mksh_sigscan;
}
d972 25
a996 2
			sigtraps[i].name = mksh_signame(i);
			sigtraps[i].mess = mksh_siglist(i);
d1062 4
a1065 16
		if (p->name) {
			if (igncase) {
				if (p->name && (!strcasecmp(p->name, name) ||
				    (strlen(name) > 3 && 
				    (p->name[0] == 's' || p->name[0] == 'S') &&
				    (p->name[1] == 'i' || p->name[1] == 'I') &&
				    (p->name[2] == 'g' || p->name[2] == 'G') &&
				    !strcasecmp(p->name, name + 3))))
					return p;
			} else {
				if (p->name && (!strcmp(p->name, name) ||
				    (strlen(name) > 3 && !strncmp("SIG",
				    p->name, 3) && !strcmp(p->name, name + 3))))
					return p;
			}
		}
@


1.33
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.32 2006/11/10 06:40:05 tg Exp $");
d766 1
a766 1
	(void) shf_snprintf(nfile, sizeof(nfile), "%s.%d", hname, procpid);
@


1.32
log
@kill two others, saves 55t 8d 2i
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.31 2006/11/10 05:23:12 tg Exp $");
d1060 1
a1060 1
	if (digit(*name)) {
@


1.31
log
@if MKSH_SMALL, disable persistent history code as well (like on Solaris,
where it can't work anyway), and fix that code to shrink
saves 2071t 20d 5i
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.30 2006/11/10 04:22:13 tg Exp $");
d1071 4
a1074 2
				    (strlen(name) > 3 && !strncasecmp("SIG",
				    p->name, 3) &&
@


1.30
log
@more cleanup; incidentally, replacing libc function with syscall maybe speedup
9t 4d 1i
@
text
@d6 1
a6 5
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.29 2006/11/10 04:03:59 tg Exp $");

#if !defined(__sun__)
#define DO_HISTORY
#endif
d26 1
a26 1
#ifdef DO_HISTORY
a42 1
static char    *hname;		/* current name of history file */
d46 2
d50 1
d519 1
d553 1
d592 1
a592 1
#ifdef DO_HISTORY
d635 1
a635 1
#ifdef DO_HISTORY
d648 1
a648 1
#ifdef DO_HISTORY
a704 3
#else
	hname = NULL;
	histfd = 0;
d708 1
a715 1
#ifdef DO_HISTORY
a946 1
#endif
a950 1
#ifdef DO_HISTORY
a952 1
#endif
a955 1
#ifdef DO_HISTORY
@


1.29
log
@thanks to the nice property of my reimplementation of getn to also
return a value in case of an error (0 or the partial result, which
is the full result in case of trailing junk even), using it to rid
atoi() is possible, saving 9t 4d 1i
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.28 2006/11/10 03:50:05 tg Exp $");
d250 1
a250 2
		n = fstat(shf_fileno(shf), &statb) < 0 ? 128 :
		    statb.st_size + 1;
@


1.28
log
@use chown not fchown, and move the ownership check to earlier
saves 45 text, 4 data and security peoples' nerves
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.27 2006/11/10 01:13:51 tg Exp $");
d484 1
a484 1
	int	rec = atoi(str);
d486 1
@


1.27
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.26 2006/11/09 14:19:31 tg Exp $");
d772 2
a784 5
	/*
	 *	worry about who owns this file
	 */
	if (fstat(histfd, &statb) >= 0)
		fchown(fd, statb.st_uid, statb.st_gid);
@


1.26
log
@optimise and, ahem… plug…
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.25 2006/08/24 18:57:30 tg Exp $");
d201 2
a202 1
				shf_fprintf(shl_stdout, "%.*s\t", ++t - s, s);
@


1.25
log
@merge commitid 10044EDF66B48DEB72C from plan9 branch:
fix thinko / reverse logic error rendering persistent history unusable
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.24 2006/08/15 23:56:32 tg Exp $");
d78 3
a80 3
				size_t len = strlen(p) + 4;
				editor = str_nsave(p, len, ATEMP);
				strlcat(editor, " $_", len);
@


1.25.2.1
log
@since the (#ifdef __ACK__) ACK toolkit doesn't have cc -E -dD,
and minix3 doesn't have strsignal, add 'kill -l' output from a
pdksh/minix3 pre-packaged binary here (subject to change)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.25 2006/08/24 18:57:30 tg Exp $");
a21 30
#elif defined(__minix)
#define	mksh_signame(x)	_mksh_signal[(x),0]
#define	mksh_siglist(x) _mksh_signal[(x),1]
static const char *_mksh_signal[25,2] = {
	{ NULL,		NULL },
	{ "HUP",	"Hangup" },
	{ "INT",	"Interrupt" },
	{ "QUIT",	"Quit" },
	{ "ILL",	"Illegal instruction" },
	{ "TRAP",	"Trace trap" },
	{ "ABRT",	"Abort" },
	{ "BUS",	"Bus error" },
	{ "FPE",	"Floating point exception" },
	{ "KILL",	"Killed" },
	{ "USR1",	"User defined signal 1" },
	{ "SEGV",	"Memory fault" },
	{ "USR2",	"User defined signal 2" },
	{ "PIPE",	"Broken pipe" },
	{ "ALRM",	"Alarm clock" },
	{ "TERM",	"Terminated" },
	{ "EMT",	"EMT trap" },
	{ "CHLD",	"Child exited" },
	{ "CONT",	"Continued" },
	{ "STOP",	"Stopped (signal)" },
	{ "TSTP",	"Stopped" },
	{ "WINCH",	"Window size change" },
	{ "TTIN",	"Stopped (tty input)" },
	{ "TTOU",	"Stopped (tty output)" },
	{ "ERR",	"Error handler" }
};
@


1.24
log
@shuffle code around for better structure
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.23 2006/08/15 23:45:53 tg Exp $");
d8 2
a9 2
#if defined(__sun__)
#define NO_HISTORY
d30 1
a30 1
#ifdef NO_HISTORY
d591 1
a591 1
#ifdef NO_HISTORY
d634 1
a634 1
#ifdef NO_HISTORY
d647 1
a647 1
#ifdef NO_HISTORY
d717 1
a717 1
#ifdef NO_HISTORY
d957 1
a957 1
#ifdef NO_HISTORY
d964 1
a964 1
#ifdef NO_HISTORY
@


1.23
log
@be more semantical
@
text
@d6 1
a6 4
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.21 2006/08/12 20:32:33 tg Exp $");

static int	histfd;
static int	hsize;
d12 18
d51 2
a52 18
#ifndef mksh_siglist
#if defined(BSD) || defined(__APPLE__)
#define	mksh_signame(x)	sys_signame[(x)]
#define	mksh_siglist(x)	sys_siglist[(x)]
#elif defined(__INTERIX)
#define	mksh_signame(x)	_sys_signame[(x)]
#define	mksh_siglist(x) _sys_siglist[(x)]
#elif defined(__gnu_linux__) || defined(__sun__) || defined(__CYGWIN__)
#define	NEED_MKSH_SIGNAME	/* sync the list above with Build.sh */
#define	mksh_siglist(x)	strsignal(x)
#else
# error "Define sys_sig{name,list} for this platform!"
#endif
#endif /* ndef mksh_siglist */

Trap sigtraps[NSIG + 1];

static struct sigaction Sigact_ign, Sigact_trap;
@


1.23.2.1
log
@initial attempt at porting mksh to the Plan 9 ANSI'n'POSIX Environment
struck dumb at SIGWINCH/TIOCGWINSZ, we'll have to ifdef out all of the
command line editing code as a next measure

incidentally, my qemu just crashed (not the guest OS - Plan 9 - no, it
really crashed the "outside" qemu programme, won't redraw or catch the
mouse any more), so I'll call it a day
@
text
@d11 1
a11 1
#if defined(__sun__) || defined(__Plan9__)
a45 10
#elif defined(__Plan9__)
#define mksh_signame(x) _mksh_signame[(x)+1]
#define mksh_siglist(x) _mksh_signame[(x)+1]
const char _mksh_signame[] = {
	"HUP", "INT", "QUIT", "ILL",
	"ABRT", "FPE", "KILL", "SEGV",
	"PIPE", "ALRM", "TERM", "USR1",
	"USR2", "BUS", "CHLD", "CONT",
	"STOP", "TSTP", "TTIN", "TTOU"
};
@


1.23.2.2
log
@merge diffs between tg-mksh-plan9ape_BASE and current HEAD
@
text
@d6 4
a9 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.24 2006/08/15 23:56:32 tg Exp $");
d15 21
d62 1
a64 24
#ifdef NO_HISTORY
static int hist_count_lines(unsigned char *, int);
static int hist_shrink(unsigned char *, int);
static unsigned char *hist_skip_back(unsigned char *,int *,int);
static void histload(Source *, unsigned char *, int);
static void histinsert(Source *, int, unsigned char *);
static void writehistfile(int, char *);
static int sprinkle(int);
#endif

static int	hist_execute(char *);
static int	hist_replace(char **, const char *, const char *, int);
static char   **hist_get(const char *, int, int);
static char   **hist_get_oldest(void);
static void	histbackup(void);

static char   **current;	/* current position in history[] */
static char    *hname;		/* current name of history file */
static int	hstarted;	/* set after hist_init() called */
static Source	*hist_source;

static int	histfd;
static int	hsize;

@


1.23.2.3
log
@oops, evil thinko
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.23.2.2 2006/08/18 19:02:22 tg Exp $");
d25 1
a25 1
const char *_mksh_signame[] = {
@


1.23.2.4
log
@even more thinko
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.23.2.3 2006/08/24 18:53:00 tg Exp $");
d8 2
a9 2
#if !defined(__sun__) && !defined(__Plan9__)
#define DO_HISTORY
d40 1
a40 1
#ifdef DO_HISTORY
d601 1
a601 1
#ifdef DO_HISTORY
d644 1
a644 1
#ifdef DO_HISTORY
d657 1
a657 1
#ifdef DO_HISTORY
d727 1
a727 1
#ifdef DO_HISTORY
d967 1
a967 1
#ifdef DO_HISTORY
d974 1
a974 1
#ifdef DO_HISTORY
@


1.23.2.5
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.25 2006/08/24 18:57:30 tg Exp $");
@


1.23.2.6
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.22
log
@minor cleanups from the porting work
@
text
@d11 5
a15 1
#ifndef __sun__
d592 1
a592 1
#ifndef __sun__
d635 1
a635 1
#ifndef __sun__
d648 1
a648 1
#if !defined(__sun__)
d718 1
a718 1
#ifndef __sun__
d958 1
a958 1
#ifndef __sun__
d965 1
a965 1
#ifndef __sun__
@


1.21
log
@optimise with a goto
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.20 2006/08/12 19:51:09 tg Exp $");
d644 1
a644 4
#ifdef __sun__
	hname = NULL;
	histfd = 0;
#else
d701 3
@


1.20
log
@a probably-Solaris-/bin/sh-workable improved algorithm
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.19 2006/08/01 14:09:19 tg Exp $");
d987 5
a991 6
	while (mksh_sigpair[i].name != NULL) {
		if (mksh_sigpair[i].nr == s)
			return (mksh_sigpair[i].name);
		++i;
	}
	return (NULL);
@


1.19
log
@(partial) sync with openbsd (and fix after them),
gives us a better wrapping prompt and a manpage wording cleanup
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.18 2006/08/01 13:43:27 tg Exp $");
d40 1
a40 1
#define	NEED_MKSH_SIGNAME
@


1.18
log
@style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.34 2006/03/17 16:30:13 millert Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.17 2006/08/01 13:19:42 tg Exp $");
d860 1
a860 2
				}
				else {
@


1.17
log
@make it possible for the user to specify mksh_siglist and mksh_signame
in CPPFLAGS, thus overriding the system default
(think standard OS with different libc)
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.16 2006/08/01 12:57:07 tg Exp $");
d672 1
a672 2
	}
	else if (hsize > 0) {
@


1.16
log
@* use strsignal(3) not strerror(3), oops
* on GNU, that needs -D_GNU_SOURCE
* a little style(9) KNF while here
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.15 2006/05/10 18:54:10 tg Exp $");
d32 1
d45 1
@


1.15
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.14 2006/01/29 20:04:51 tg Exp $");
d40 1
a40 1
#define	mksh_siglist(x)	strerror(x)
d651 1
a651 1
  retry:
d946 1
a946 1
bad:
d989 1
a989 1
			return mksh_sigpair[i].name;
d992 1
a992 1
	return NULL;
@


1.14
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.32 2005/12/11 18:53:51 deraadt Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.13 2005/11/22 18:40:42 tg Exp $");
d66 1
a66 1
	    "e:glnrs0,1,2,3,4,5,6,7,8,9,")) != EOF)
d656 3
a658 1
	histfd = savefd(fd, 0);
@


1.13
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.31 2005/07/31 16:12:52 espie Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.12 2005/10/25 19:53:28 tg Exp $");
a27 1
static int	curpos;		/* current index in history[] */
a434 6
histN(void)
{
	return curpos;
}

int
a440 1
		curpos = last;
a443 1
		curpos = n;
@


1.12
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.11 2005/08/02 12:26:17 tg Exp $ */
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.11 2005/08/02 12:26:17 tg Exp $");
@


1.11
log
@say goodbye to creat().
From: Marc Espie <espie@@cvs.openbsd.org>
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.10 2005/07/07 23:27:52 tg Exp $ */
a5 3
#include <sys/file.h>
#include <sys/mman.h>
#include <sys/stat.h>
d7 1
a7 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.10 2005/07/07 23:27:52 tg Exp $");
@


1.10
log
@* move <sys/param.h> include to sh.h
* fix compilation and invocation of test suite with whitespace in
  the pathnames for real, this time
* clean up (especially whitespace)
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/histrap.c,v 1.9 2005/06/24 15:36:57 tg Exp $ */
/*	$OpenBSD: history.c,v 1.30 2005/03/30 17:16:37 deraadt Exp $	*/
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.9 2005/06/24 15:36:57 tg Exp $");
d776 1
a776 1
	if ((fd = creat(nfile, 0600)) < 0)
@


1.9
log
@first step for GNU/Cygwin support
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.8 2005/05/23 16:23:18 tg Exp $ */
a5 1
#include <sys/param.h>	/* for BSD */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.8 2005/05/23 16:23:18 tg Exp $");
@


1.8
log
@aaaand: Interix.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.7 2005/05/23 15:54:31 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.7 2005/05/23 15:54:31 tg Exp $");
d44 1
a44 1
#elif defined(__gnu_linux__) || defined(__sun__)
@


1.7
log
@now passes on Solaris (-Wall -W -Wno-char-subscripts) too
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.6 2005/05/23 15:36:55 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.6 2005/05/23 15:36:55 tg Exp $");
d42 2
a43 3
#define	mksh_signame(x)	__sys_signame[(x)]
#define	mksh_siglist(x)	__sys_siglist[(x)]
#define	NSIG		__sys_nsig
@


1.6
log
@no persistent history (flock missing), no arc4random, etc. for Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.5 2005/05/23 15:09:22 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.5 2005/05/23 15:09:22 tg Exp $");
a15 1
static void histinsert(Source *, int, unsigned char *);
d21 1
d591 2
a592 1
histsave(int lno, const char *cmd, int dowrite)
a881 1
#endif
a898 1
#ifndef __sun__
@


1.5
log
@now passes on GNU/Linux with __CRAZY=1 -std=gnu99 (broken system headers ;)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.4 2005/05/23 14:19:14 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.4 2005/05/23 14:19:14 tg Exp $");
d16 2
a21 1
static void histinsert(Source *, int, unsigned char *);
d24 1
d600 1
d603 1
d643 1
d647 1
d656 4
d715 1
d725 1
a804 1

d881 1
d899 1
d963 1
d968 1
d971 1
d975 1
d986 1
@


1.4
log
@* add definition of __RCSID if not yet existant (GNU/Linux)
* add declarations of strlcpy and strlcat (for GNU/Linux, again)
* always include <sys/resource.h>
* some more compile / warning fixes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.3 2005/05/23 12:06:39 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.3 2005/05/23 12:06:39 tg Exp $");
d971 1
a971 1
static const char * const
@


1.3
log
@some spacing; move array into function
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.2 2005/05/23 12:01:09 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.2 2005/05/23 12:01:09 tg Exp $");
d978 1
a978 1
	} const mksh_sigpair[] = {
@


1.2
log
@support getting sys_siglist[], sys_signame[] and NSIG retrieval
for portable mksh on various operating systems
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/histrap.c,v 1.1 2005/05/23 03:06:07 tg Exp $ */
d11 1
a11 1
__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.1 2005/05/23 03:06:07 tg Exp $");
a970 9

struct _mksh_sigpair {
	int nr;
	const char *name;
} mksh_sigpair[] = {
#include "signames.inc"
    { 0, NULL }
};

d975 7
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/trap.c,v 1.4 2005/05/23 02:20:36 tg Exp $ */
d6 1
d11 1
a11 1
__RCSID("$MirOS: mksh/history.c,v 1.7 2005/05/23 02:20:36 tg Exp $");
d36 14
d970 24
d1006 2
a1007 2
			sigtraps[i].name = sys_signame[i];
			sigtraps[i].mess = sys_siglist[i];
@

