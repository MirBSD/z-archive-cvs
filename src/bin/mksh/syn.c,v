head	1.127;
access;
symbols
	mksh-R57:1.127
	mksh-R56c:1.127
	mksh-R56b:1.124
	mksh-R56:1.124
	mksh-R55:1.120
	mksh-R54:1.115
	mksh-R53a:1.114
	mksh-R53:1.114
	mksh-R52c:1.111
	mksh-R52b:1.109
	mksh-R52:1.107
	mksh-R51:1.101
	mksh-R50f:1.94.2.3
	mksh-R50e:1.94.2.1
	mksh-R50stable:1.94.0.2
	mksh-R50d:1.94
	mksh-R50c:1.94
	mksh-R50b:1.94
	mksh-R50:1.94
	mksh-R49:1.94
	mksh-R48b:1.92
	mksh-R48:1.92
	mksh-R47:1.92
	mksh-R46:1.91
	mksh-R45:1.90
	mksh-R44:1.88
	mksh-R43:1.88
	mksh-R42b:1.88
	mksh-R41c:1.84.2.1
	mksh-R41b:1.84.2.1
	mksh-R42:1.88
	mksh-R41:1.84
	mksh-R41stable:1.84.0.2
	mksh-wheezy:1.76.0.2
	tg-multikey-bind:1.74.0.2
	mksh-R40f:1.73
	mksh-R40e:1.73
	mksh-R40d:1.71
	mksh-R40c:1.71
	mksh-R40b:1.67
	mksh-R40stable:1.73.0.2
	mksh-R40:1.67
	mksh-R39c:1.48
	mksh-R39b:1.48
	tg-wcswidth-behaviour:1.47.0.2
	tg-nameref:1.41.0.2
	mksh-R39:1.38
	tg-mksh-printf-builtin:1.38.0.2
	mksh-R38c:1.37
	mksh-R38b:1.35
	mksh-R38:1.35
	mksh-R37c:1.34
	mksh-R37b:1.32
	mksh-R37:1.32
	mksh-R36b:1.32
	tg-aalloc-experimental_BASE:1.30
	tg-aalloc-experimental:1.30.0.2
	mksh-R36:1.27
	mksh-R35b:1.25
	mksh-R35:1.22
	mksh-R33d:1.20
	mksh-R33c:1.20
	mksh-R33b:1.19
	MIRBSD_10:1.19.0.2
	MIRBSD_10_BASE:1.19
	mksh-R33:1.19
	mksh-R32:1.18
	mksh-R31d:1.17
	mksh-R31c:1.17
	mksh-R31b:1.17
	mksh-R31:1.17
	mksh-R30:1.16
	mksh-R29g:1.12.2.2
	mksh-R29f:1.12.2.1
	mksh-R29e:1.12.2.1
	mksh-R29stable:1.12.0.2
	mksh-R29d:1.12
	mksh-R29c:1.12
	mksh-R29b:1.12
	mksh-R29:1.12
	mksh-R28:1.8
	tg-mksh-plan9ape_BASE:1.8
	tg-mksh-plan9ape:1.8.0.2
	mksh-R27e:1.7
	MIRBSD_9_BASE:1.7
	mksh-R27d:1.7
	mksh-R27:1.7
	mksh-R26c:1.5
	mksh-R26b:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	mksh-R26:1.4
	mksh-R25:1.3
	mksh-R24c:1.2
	mksh-R24b:1.2
	mksh-R24:1.2
	mksh-R23:1.1
	mksh-R22:1.1
	mksh-R21:1.1;
locks; strict;
comment	@ * @;


1.127
date	2018.01.14.00.22.30;	author tg;	state Exp;
branches;
next	1.126;
commitid	1005A5AA2D643C73A14;

1.126
date	2018.01.14.00.03.04;	author tg;	state Exp;
branches;
next	1.125;
commitid	1005A5A9E3D208A81CB;

1.125
date	2018.01.13.23.55.14;	author tg;	state Exp;
branches;
next	1.124;
commitid	1005A5A9C627E45C2B1;

1.124
date	2017.05.05.22.53.31;	author tg;	state Exp;
branches;
next	1.123;
commitid	100590D026845CD3DFF;

1.123
date	2017.04.28.00.38.33;	author tg;	state Exp;
branches;
next	1.122;
commitid	10059028F0E0808B3E9;

1.122
date	2017.04.27.20.22.28;	author tg;	state Exp;
branches;
next	1.121;
commitid	1005902531266D3FCB6;

1.121
date	2017.04.27.19.33.53;	author tg;	state Exp;
branches;
next	1.120;
commitid	100590247A92C66CAF9;

1.120
date	2017.04.06.01.59.57;	author tg;	state Exp;
branches;
next	1.119;
commitid	10058E5A1067AFA1BBA;

1.119
date	2017.04.06.00.41.42;	author tg;	state Exp;
branches;
next	1.118;
commitid	10058E58ECF695338FA;

1.118
date	2017.03.19.20.59.29;	author tg;	state Exp;
branches;
next	1.117;
commitid	10058CEF1322163CCA4;

1.117
date	2017.03.12.02.04.15;	author tg;	state Exp;
branches;
next	1.116;
commitid	10058C4AC2520F8C875;

1.116
date	2017.03.11.22.49.56;	author tg;	state Exp;
branches;
next	1.115;
commitid	10058C47F07715C2B99;

1.115
date	2016.09.01.12.59.12;	author tg;	state Exp;
branches;
next	1.114;
commitid	10057C8260A04757349;

1.114
date	2016.08.04.20.32.14;	author tg;	state Exp;
branches;
next	1.113;
commitid	10057A3A66701A72552;

1.113
date	2016.07.25.21.05.25;	author tg;	state Exp;
branches;
next	1.112;
commitid	10057967F184AB0E82A;

1.112
date	2016.07.25.00.04.48;	author tg;	state Exp;
branches;
next	1.111;
commitid	1005795579F14A3FE5C;

1.111
date	2016.02.26.21.24.58;	author tg;	state Exp;
branches;
next	1.110;
commitid	10056D0C2A16763ECD7;

1.110
date	2016.01.21.18.24.44;	author tg;	state Exp;
branches;
next	1.109;
commitid	10056A12268001BF859;

1.109
date	2016.01.19.23.12.15;	author tg;	state Exp;
branches;
next	1.108;
commitid	100569EC2AE617A4288;

1.108
date	2016.01.14.19.52.20;	author tg;	state Exp;
branches;
next	1.107;
commitid	1005697FC706232D2F1;

1.107
date	2015.12.12.21.03.53;	author tg;	state Exp;
branches;
next	1.106;
commitid	100566C8BC50878E812;

1.106
date	2015.10.09.19.29.50;	author tg;	state Exp;
branches;
next	1.105;
commitid	100561815B853CF84EB;

1.105
date	2015.10.09.17.48.53;	author tg;	state Exp;
branches;
next	1.104;
commitid	1005617FE066005352E;

1.104
date	2015.09.06.19.47.01;	author tg;	state Exp;
branches;
next	1.103;
commitid	10055EC98215F2B5F9C;

1.103
date	2015.09.05.19.19.11;	author tg;	state Exp;
branches;
next	1.102;
commitid	10055EB402C54C3076B;

1.102
date	2015.09.05.17.17.47;	author tg;	state Exp;
branches;
next	1.101;
commitid	10055EB23C9011C6C59;

1.101
date	2015.04.29.20.07.35;	author tg;	state Exp;
branches;
next	1.100;
commitid	100554139453DB97755;

1.100
date	2015.04.11.22.03.32;	author tg;	state Exp;
branches;
next	1.99;
commitid	1005529999F77F915AE;

1.99
date	2015.03.14.05.23.18;	author tg;	state Exp;
branches;
next	1.98;
commitid	1005503C5CA29059CD3;

1.98
date	2015.03.14.04.38.13;	author tg;	state Exp;
branches;
next	1.97;
commitid	1005503BB4D5A8855E8;

1.97
date	2015.03.14.04.37.55;	author tg;	state Exp;
branches;
next	1.96;
commitid	1005503BB3A05FBF858;

1.96
date	2015.03.08.22.54.36;	author tg;	state Exp;
branches;
next	1.95;
commitid	10054FCD1444FC13F3C;

1.95
date	2014.12.15.22.08.55;	author tg;	state Exp;
branches;
next	1.94;
commitid	100548F5BF4700DF4E3;

1.94
date	2014.01.05.21.57.29;	author tg;	state Exp;
branches
	1.94.2.1;
next	1.93;
commitid	10052C9D445413B34DF;

1.93
date	2013.09.10.16.30.50;	author tg;	state Exp;
branches;
next	1.92;
commitid	100522F49426994853D;

1.92
date	2013.06.03.22.28.17;	author tg;	state Exp;
branches;
next	1.91;
commitid	10051AD189A0C2AE54A;

1.91
date	2013.05.02.21.59.53;	author tg;	state Exp;
branches;
next	1.90;
commitid	1005182E1E55272FF6B;

1.90
date	2013.04.26.21.22.50;	author tg;	state Exp;
branches;
next	1.89;
commitid	100517AEF6C22DD1AE7;

1.89
date	2013.04.26.18.27.07;	author tg;	state Exp;
branches;
next	1.88;
commitid	100517AC7121FEA6081;

1.88
date	2012.12.28.02.28.39;	author tg;	state Exp;
branches;
next	1.87;
commitid	10050DD03E43C678B81;

1.87
date	2012.12.05.19.38.25;	author tg;	state Exp;
branches;
next	1.86;
commitid	10050BFA2C0046FB3B9;

1.86
date	2012.12.05.18.54.10;	author tg;	state Exp;
branches;
next	1.85;
commitid	10050BF986807E3B0C1;

1.85
date	2012.11.30.20.19.15;	author tg;	state Exp;
branches;
next	1.84;
commitid	10050B914D41435E735;

1.84
date	2012.10.30.20.49.44;	author tg;	state Exp;
branches
	1.84.2.1;
next	1.83;
commitid	10050903D7D16EDB58E;

1.83
date	2012.10.30.20.07.15;	author tg;	state Exp;
branches;
next	1.82;
commitid	10050903386452ACBF1;

1.82
date	2012.10.22.20.19.18;	author tg;	state Exp;
branches;
next	1.81;
commitid	1005085AA537A17A752;

1.81
date	2012.10.03.15.50.32;	author tg;	state Exp;
branches;
next	1.80;
commitid	100506C5EDD0A412A8E;

1.80
date	2012.08.17.18.34.25;	author tg;	state Exp;
branches;
next	1.79;
commitid	100502E8EAA4BFCF410;

1.79
date	2012.07.30.21.37.16;	author tg;	state Exp;
branches;
next	1.78;
commitid	1005016FE9B27F9F4DC;

1.78
date	2012.07.30.17.04.31;	author tg;	state Exp;
branches;
next	1.77;
commitid	1005016BEB601685CAE;

1.77
date	2012.07.01.15.38.08;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004FF06EE567E89991;

1.76
date	2012.06.28.20.04.02;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004FECB8BA4BE1EF25;

1.75
date	2012.05.09.23.21.00;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004FAAFBED1D226CAF;

1.74
date	2012.03.03.21.30.58;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004F528D8E7F3D0F12;

1.73
date	2012.01.03.15.32.08;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004F031F1C71A635C2;

1.72
date	2011.12.29.22.03.15;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004EFCE3A84AB854A0;

1.71
date	2011.11.22.18.01.41;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004ECBE39656891872;

1.70
date	2011.11.11.22.14.19;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004EBD9E4D2DCCBE71;

1.69
date	2011.09.07.15.24.21;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004E678C6929FE60A6;

1.68
date	2011.08.27.18.06.51;	author tg;	state Exp;
branches;
next	1.67;
commitid	1004E5932432420AA61;

1.67
date	2011.06.05.19.58.20;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004DEBDFBB243C0DCF;

1.66
date	2011.06.04.16.11.20;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004DEA592B5E41F86E;

1.65
date	2011.05.29.02.18.57;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004DE1AD11046BEFFC;

1.64
date	2011.05.07.00.51.12;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004DC49710562ACCB2;

1.63
date	2011.05.05.00.05.01;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004DC1E8D640072140;

1.62
date	2011.05.02.22.52.53;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004DBF35D72295ADB7;

1.61
date	2011.04.22.12.15.42;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004DB17167553347A9;

1.60
date	2011.04.09.15.14.54;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004DA077823393B1E0;

1.59
date	2011.03.26.15.32.37;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004D8E071E7181147C;

1.58
date	2011.03.21.21.57.35;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004D87C9AA1AA37C2E;

1.57
date	2011.03.13.16.03.54;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004D7CE9C2063207F0;

1.56
date	2011.03.13.01.20.24;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004D7C1BE368F5B459;

1.55
date	2011.03.12.20.20.17;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004D7BD58B625DCEEE;

1.54
date	2011.03.06.01.25.35;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004D72E2935F494D4B;

1.53
date	2011.02.11.00.41.38;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004D5485D4414A9BFE;

1.52
date	2010.09.14.21.26.18;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004C8FE654576B0E25;

1.51
date	2010.08.28.20.22.23;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004C796FE40C544CCE;

1.50
date	2010.08.28.18.50.58;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004C795A82072326AF;

1.49
date	2010.07.17.22.09.39;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004C42295452E71B6E;

1.48
date	2009.12.12.22.27.10;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004B2418AF282F4231;

1.47
date	2009.10.30.00.57.39;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004AEA39BD3F10ECFA;

1.46
date	2009.10.04.12.45.23;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004AC898E1751BB935;

1.45
date	2009.10.02.18.08.37;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004AC641341D9D9D02;

1.44
date	2009.09.26.03.40.02;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004ABD8CE62D55CFD8;

1.43
date	2009.09.23.18.04.58;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004ABA62C8171BD8E4;

1.42
date	2009.09.19.18.36.59;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004AB524D471D78F40;

1.41
date	2009.08.28.20.30.59;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004A983E6B745731A0;

1.40
date	2009.08.28.19.57.43;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004A98365B7809CDA1;

1.39
date	2009.08.28.18.54.00;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004A9827D2091BAE42;

1.38
date	2009.06.11.12.42.20;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004A30FBB114E3FED9;

1.37
date	2009.06.10.18.12.50;	author tg;	state Exp;
branches;
next	1.36;
commitid	1004A2FF7913BD44883;

1.36
date	2009.06.08.20.06.49;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004A2D6F3A31FB4CBC;

1.35
date	2009.05.16.16.59.41;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004A0EF0664EF4168D;

1.34
date	2009.04.07.19.13.11;	author tg;	state Exp;
branches;
next	1.33;
commitid	10049DBA5DA72EF04C6;

1.33
date	2009.04.07.19.06.43;	author tg;	state Exp;
branches;
next	1.32;
commitid	10049DBA45A68068BCD;

1.32
date	2008.12.13.17.02.17;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004943EAA830C0300B;

1.31
date	2008.12.02.13.20.40;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004935360E5A3EA32B;

1.30
date	2008.11.12.00.54.51;	author tg;	state Exp;
branches
	1.30.2.1;
next	1.29;
commitid	100491A295841A6D8EB;

1.29
date	2008.11.09.19.48.02;	author tg;	state Exp;
branches;
next	1.28;
commitid	10049173E7700D5CD13;

1.28
date	2008.10.28.14.32.43;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004907226D3DEFCCD1;

1.27
date	2008.10.10.21.30.43;	author tg;	state Exp;
branches;
next	1.26;
commitid	10048EFC9600438B1CB;

1.26
date	2008.08.02.17.45.12;	author tg;	state Exp;
branches;
next	1.25;
commitid	10048949D196A7C1390;

1.25
date	2008.07.18.11.33.13;	author tg;	state Exp;
branches;
next	1.24;
commitid	10048807F804EE06E7A;

1.24
date	2008.07.14.12.29.06;	author tg;	state Exp;
branches;
next	1.23;
commitid	100487B467E068A55D6;

1.23
date	2008.07.12.16.56.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004878E22B104A657A;

1.22
date	2008.06.28.22.51.56;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004866BFA427FDEFB9;

1.21
date	2008.05.17.18.47.02;	author tg;	state Exp;
branches;
next	1.20;
commitid	100482F280E7B53AA4C;

1.20
date	2008.04.01.22.20.20;	author tg;	state Exp;
branches;
next	1.19;
commitid	10047F2B5302C15B5C3;

1.19
date	2008.03.01.21.10.26;	author tg;	state Exp;
branches
	1.19.2.1;
next	1.18;
commitid	10047C9C64165F71A5A;

1.18
date	2007.10.25.15.34.30;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004720B799621B739A;

1.17
date	2007.08.19.23.12.23;	author tg;	state Exp;
branches;
next	1.16;
commitid	10046C8CE5279B1E703;

1.16
date	2007.07.01.21.10.29;	author tg;	state Exp;
branches;
next	1.15;
commitid	100468818584C6286F7;

1.15
date	2007.06.22.23.34.42;	author tg;	state Exp;
branches;
next	1.14;
commitid	100467C5C9519B9C52A;

1.14
date	2007.06.06.23.28.17;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004667430836D68E66;

1.13
date	2007.05.13.19.00.30;	author tg;	state Exp;
branches;
next	1.12;
commitid	100464760593612AAF2;

1.12
date	2007.03.04.03.04.28;	author tg;	state Exp;
branches
	1.12.2.1;
next	1.11;
commitid	10045EA374B3374AB35;

1.11
date	2007.03.04.00.13.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045EA0F2F6674C8B9;

1.10
date	2007.01.17.22.51.47;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045AEA86F7FE51B97;

1.9
date	2007.01.12.01.49.29;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10045A6E8B92FCAC95A;

1.8
date	2006.08.01.13.43.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044CF5A93693A5C0A;

1.7
date	2006.05.10.18.54.13;	author tg;	state Exp;
branches;
next	1.6;
commitid	100446236E6726083C8;

1.6
date	2006.01.30.12.37.24;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043DE088533ED5341;

1.5
date	2006.01.29.20.04.53;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043DD1FE6328EF386;

1.4
date	2005.11.22.18.40.44;	author tg;	state Exp;
branches;
next	1.3;
commitid	108a438366254326;

1.3
date	2005.10.08.19.31.00;	author tg;	state Exp;
branches;
next	1.2;
commitid	512643481e5274c0;

1.2
date	2005.07.04.12.27.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	3ec342c92b3a8874;

1.1
date	2005.05.23.03.06.10;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.94.2.1
date	2015.01.25.15.35.54;	author tg;	state Exp;
branches;
next	1.94.2.2;
commitid	10054C50D442D861FBF;

1.94.2.2
date	2015.03.20.22.21.10;	author tg;	state Exp;
branches;
next	1.94.2.3;
commitid	100550C9D521FCB4274;

1.94.2.3
date	2015.04.12.22.32.35;	author tg;	state Exp;
branches;
next	;
commitid	100552AF26A429AA816;

1.84.2.1
date	2012.12.05.19.58.36;	author tg;	state Exp;
branches;
next	;
commitid	10050BFA7766B61F30F;

1.30.2.1
date	2008.11.22.13.20.36;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.19.2.1
date	2008.04.22.13.29.34;	author tg;	state Exp;
branches;
next	1.19.2.2;
commitid	100480DE80F32BAA72D;

1.19.2.2
date	2008.05.19.18.41.32;	author tg;	state Exp;
branches;
next	1.19.2.3;
commitid	1004831C9A63DA06745;

1.19.2.3
date	2008.07.11.11.49.32;	author tg;	state Exp;
branches;
next	1.19.2.4;
commitid	100487748D62394D033;

1.19.2.4
date	2008.07.18.13.29.48;	author tg;	state Exp;
branches;
next	1.19.2.5;
commitid	10048809AD278B142AC;

1.19.2.5
date	2008.12.14.00.07.50;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.12.2.1
date	2007.05.13.19.29.40;	author tg;	state Exp;
branches;
next	1.12.2.2;
commitid	1004647668D4636830B;

1.12.2.2
date	2007.07.05.11.49.23;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.9.2.1
date	2007.03.03.21.38.00;	author tg;	state Exp;
branches;
next	1.9.2.2;
commitid	10045E9EAC27ABA6ADF;

1.9.2.2
date	2007.03.03.23.59.39;	author tg;	state Exp;
branches;
next	;
commitid	10045EA0C01765C8871;


desc
@@


1.127
log
@plug the first couple of ctype bugs
@
text
@/*	$OpenBSD: syn.c,v 1.30 2015/09/01 13:12:31 tedu Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017,
 *		 2018
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.126 2018/01/14 00:03:04 tg Exp $");

struct nesting_state {
	int start_token;	/* token than began nesting (eg, FOR) */
	int start_line;		/* line nesting began on */
};

struct yyrecursive_state {
	struct ioword *old_heres[HERES];
	struct yyrecursive_state *next;
	struct ioword **old_herep;
	int old_symbol;
	unsigned int old_nesting_type;
	bool old_reject;
};

static void yyparse(bool);
static struct op *pipeline(int, int);
static struct op *andor(int);
static struct op *c_list(int, bool);
static struct ioword *synio(int);
static struct op *nested(int, int, int, int);
static struct op *get_command(int, int);
static struct op *dogroup(int);
static struct op *thenpart(int);
static struct op *elsepart(int);
static struct op *caselist(int);
static struct op *casepart(int, int);
static struct op *function_body(char *, int, bool);
static char **wordlist(int);
static struct op *block(int, struct op *, struct op *);
static struct op *newtp(int);
static void syntaxerr(const char *) MKSH_A_NORETURN;
static void nesting_push(struct nesting_state *, int);
static void nesting_pop(struct nesting_state *);
static int inalias(struct source *) MKSH_A_PURE;
static Test_op dbtestp_isa(Test_env *, Test_meta);
static const char *dbtestp_getopnd(Test_env *, Test_op, bool);
static int dbtestp_eval(Test_env *, Test_op, const char *,
    const char *, bool);
static void dbtestp_error(Test_env *, int, const char *) MKSH_A_NORETURN;

static struct op *outtree;		/* yyparse output */
static struct nesting_state nesting;	/* \n changed to ; */

static bool reject;			/* token(cf) gets symbol again */
static int symbol;			/* yylex value */

#define REJECT		(reject = true)
#define ACCEPT		(reject = false)
#define token(cf)	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
#define tpeek(cf)	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
#define musthave(c,cf)	do { 					\
	if ((unsigned int)token(cf) != (unsigned int)(c))	\
		syntaxerr(NULL);				\
} while (/* CONSTCOND */ 0)

static const char Tcbrace[] = "}";
static const char Tesac[] = "esac";

static void
yyparse(bool doalias)
{
	int c;

	ACCEPT;

	outtree = c_list(doalias ? ALIAS : 0, source->type == SSTRING);
	c = tpeek(0);
	if (c == 0 && !outtree)
		outtree = newtp(TEOF);
	else if (!cinttype(c, C_LF | C_NUL))
		syntaxerr(NULL);
}

static struct op *
pipeline(int cf, int sALIAS)
{
	struct op *t, *p, *tl = NULL;

	t = get_command(cf, sALIAS);
	if (t != NULL) {
		while (token(0) == '|') {
			if ((p = get_command(CONTIN, sALIAS)) == NULL)
				syntaxerr(NULL);
			if (tl == NULL)
				t = tl = block(TPIPE, t, p);
			else
				tl = tl->right = block(TPIPE, tl->right, p);
		}
		REJECT;
	}
	return (t);
}

static struct op *
andor(int sALIAS)
{
	struct op *t, *p;
	int c;

	t = pipeline(0, sALIAS);
	if (t != NULL) {
		while ((c = token(0)) == LOGAND || c == LOGOR) {
			if ((p = pipeline(CONTIN, sALIAS)) == NULL)
				syntaxerr(NULL);
			t = block(c == LOGAND? TAND: TOR, t, p);
		}
		REJECT;
	}
	return (t);
}

static struct op *
c_list(int sALIAS, bool multi)
{
	struct op *t = NULL, *p, *tl = NULL;
	int c;
	bool have_sep;

	while (/* CONSTCOND */ 1) {
		p = andor(sALIAS);
		/*
		 * Token has always been read/rejected at this point, so
		 * we don't worry about what flags to pass token()
		 */
		c = token(0);
		have_sep = true;
		if (c == '\n' && (multi || inalias(source))) {
			if (!p)
				/* ignore blank lines */
				continue;
		} else if (!p)
			break;
		else if (c == '&' || c == COPROC)
			p = block(c == '&' ? TASYNC : TCOPROC, p, NULL);
		else if (c != ';')
			have_sep = false;
		if (!t)
			t = p;
		else if (!tl)
			t = tl = block(TLIST, t, p);
		else
			tl = tl->right = block(TLIST, tl->right, p);
		if (!have_sep)
			break;
	}
	REJECT;
	return (t);
}

static const char IONDELIM_delim[] = { CHAR, '<', CHAR, '<', EOS };

static struct ioword *
synio(int cf)
{
	struct ioword *iop;
	static struct ioword *nextiop;
	bool ishere;

	if (nextiop != NULL) {
		iop = nextiop;
		nextiop = NULL;
		return (iop);
	}

	if (tpeek(cf) != REDIR)
		return (NULL);
	ACCEPT;
	iop = yylval.iop;
	ishere = (iop->ioflag & IOTYPE) == IOHERE;
	if (iop->ioflag & IOHERESTR) {
		musthave(LWORD, 0);
	} else if (ishere && tpeek(HEREDELIM) == '\n') {
		ACCEPT;
		yylval.cp = wdcopy(IONDELIM_delim, ATEMP);
		iop->ioflag |= IOEVAL | IONDELIM;
	} else
		musthave(LWORD, ishere ? HEREDELIM : 0);
	if (ishere) {
		iop->delim = yylval.cp;
		if (*ident != 0 && !(iop->ioflag & IOHERESTR)) {
			/* unquoted */
			iop->ioflag |= IOEVAL;
		}
		if (herep > &heres[HERES - 1])
			yyerror(Tf_toomany, "<<");
		*herep++ = iop;
	} else
		iop->ioname = yylval.cp;

	if (iop->ioflag & IOBASH) {
		char *cp;

		nextiop = alloc(sizeof(*iop), ATEMP);
		nextiop->ioname = cp = alloc(3, ATEMP);
		*cp++ = CHAR;
		*cp++ = digits_lc[iop->unit % 10];
		*cp = EOS;

		iop->ioflag &= ~IOBASH;
		nextiop->unit = 2;
		nextiop->ioflag = IODUP;
		nextiop->delim = NULL;
		nextiop->heredoc = NULL;
	}
	return (iop);
}

static struct op *
nested(int type, int smark, int emark, int sALIAS)
{
	struct op *t;
	struct nesting_state old_nesting;

	nesting_push(&old_nesting, smark);
	t = c_list(sALIAS, true);
	musthave(emark, KEYWORD|sALIAS);
	nesting_pop(&old_nesting);
	return (block(type, t, NULL));
}

static const char builtin_cmd[] = {
	QCHAR, '\\', CHAR, 'b', CHAR, 'u', CHAR, 'i',
	CHAR, 'l', CHAR, 't', CHAR, 'i', CHAR, 'n', EOS
};
static const char let_cmd[] = {
	CHAR, 'l', CHAR, 'e', CHAR, 't', EOS
};
static const char setA_cmd0[] = {
	CHAR, 's', CHAR, 'e', CHAR, 't', EOS
};
static const char setA_cmd1[] = {
	CHAR, '-', CHAR, 'A', EOS
};
static const char setA_cmd2[] = {
	CHAR, '-', CHAR, '-', EOS
};

static struct op *
get_command(int cf, int sALIAS)
{
	struct op *t;
	int c, iopn = 0, syniocf, lno;
	struct ioword *iop, **iops;
	XPtrV args, vars;
	struct nesting_state old_nesting;

	/* NUFILE is small enough to leave this addition unchecked */
	iops = alloc2((NUFILE + 1), sizeof(struct ioword *), ATEMP);
	XPinit(args, 16);
	XPinit(vars, 16);

	syniocf = KEYWORD|sALIAS;
	switch (c = token(cf|KEYWORD|sALIAS|CMDASN)) {
	default:
		REJECT;
		afree(iops, ATEMP);
		XPfree(args);
		XPfree(vars);
		/* empty line */
		return (NULL);

	case LWORD:
	case REDIR:
		REJECT;
		syniocf &= ~(KEYWORD|sALIAS);
		t = newtp(TCOM);
		t->lineno = source->line;
		goto get_command_start;
		while (/* CONSTCOND */ 1) {
			bool check_decl_utility;

			if (XPsize(args) == 0) {
 get_command_start:
				check_decl_utility = true;
				cf = sALIAS | CMDASN;
			} else if (t->u.evalflags)
				cf = CMDWORD | CMDASN;
			else
				cf = CMDWORD;
			switch (tpeek(cf)) {
			case REDIR:
				while ((iop = synio(cf)) != NULL) {
					if (iopn >= NUFILE)
						yyerror(Tf_toomany,
						    Tredirection);
					iops[iopn++] = iop;
				}
				break;

			case LWORD:
				ACCEPT;
				if (check_decl_utility) {
					struct tbl *tt = get_builtin(ident);
					uint32_t flag;

					flag = tt ? tt->flag : 0;
					if (flag & DECL_UTIL)
						t->u.evalflags = DOVACHECK;
					if (!(flag & DECL_FWDR))
						check_decl_utility = false;
				}
				if ((XPsize(args) == 0 || Flag(FKEYWORD)) &&
				    is_wdvarassign(yylval.cp))
					XPput(vars, yylval.cp);
				else
					XPput(args, yylval.cp);
				break;

			case ORD('(' /*)*/):
				if (XPsize(args) == 0 && XPsize(vars) == 1 &&
				    is_wdvarassign(yylval.cp)) {
					char *tcp;

					/* wdarrassign: foo=(bar) */
					ACCEPT;

					/* manipulate the vars string */
					tcp = XPptrv(vars)[(vars.len = 0)];
					/* 'varname=' -> 'varname' */
					tcp[wdscan(tcp, EOS) - tcp - 3] = EOS;

					/* construct new args strings */
					XPput(args, wdcopy(builtin_cmd, ATEMP));
					XPput(args, wdcopy(setA_cmd0, ATEMP));
					XPput(args, wdcopy(setA_cmd1, ATEMP));
					XPput(args, tcp);
					XPput(args, wdcopy(setA_cmd2, ATEMP));

					/* slurp in words till closing paren */
					while (token(CONTIN) == LWORD)
						XPput(args, yylval.cp);
					if (symbol != /*(*/ ')')
						syntaxerr(NULL);
				} else {
					/*
					 * Check for "> foo (echo hi)"
					 * which AT&T ksh allows (not
					 * POSIX, but not disallowed)
					 */
					afree(t, ATEMP);
					if (XPsize(args) == 0 &&
					    XPsize(vars) == 0) {
						ACCEPT;
						goto Subshell;
					}

					/* must be a function */
					if (iopn != 0 || XPsize(args) != 1 ||
					    XPsize(vars) != 0)
						syntaxerr(NULL);
					ACCEPT;
					musthave(/*(*/ ')', 0);
					t = function_body(XPptrv(args)[0],
					    sALIAS, false);
				}
				goto Leave;

			default:
				goto Leave;
			}
		}
 Leave:
		break;

	case ORD('(' /*)*/): {
		unsigned int subshell_nesting_type_saved;
 Subshell:
		subshell_nesting_type_saved = subshell_nesting_type;
		subshell_nesting_type = ORD(')');
		t = nested(TPAREN, ORD('('), ORD(')'), sALIAS);
		subshell_nesting_type = subshell_nesting_type_saved;
		break;
	    }

	case ORD('{' /*}*/):
		t = nested(TBRACE, ORD('{'), ORD('}'), sALIAS);
		break;

	case MDPAREN:
		/* leave KEYWORD in syniocf (allow if (( 1 )) then ...) */
		lno = source->line;
		ACCEPT;
		switch (token(LETEXPR)) {
		case LWORD:
			break;
		case ORD('(' /*)*/):
			c = ORD('(');
			goto Subshell;
		default:
			syntaxerr(NULL);
		}
		t = newtp(TCOM);
		t->lineno = lno;
		XPput(args, wdcopy(builtin_cmd, ATEMP));
		XPput(args, wdcopy(let_cmd, ATEMP));
		XPput(args, yylval.cp);
		break;

	case DBRACKET: /* [[ .. ]] */
		/* leave KEYWORD in syniocf (allow if [[ -n 1 ]] then ...) */
		t = newtp(TDBRACKET);
		ACCEPT;
		{
			Test_env te;

			te.flags = TEF_DBRACKET;
			te.pos.av = &args;
			te.isa = dbtestp_isa;
			te.getopnd = dbtestp_getopnd;
			te.eval = dbtestp_eval;
			te.error = dbtestp_error;

			test_parse(&te);
		}
		break;

	case FOR:
	case SELECT:
		t = newtp((c == FOR) ? TFOR : TSELECT);
		musthave(LWORD, CMDASN);
		if (!is_wdvarname(yylval.cp, true))
			yyerror("%s: bad identifier",
			    c == FOR ? "for" : Tselect);
		strdupx(t->str, ident, ATEMP);
		nesting_push(&old_nesting, c);
		t->vars = wordlist(sALIAS);
		t->left = dogroup(sALIAS);
		nesting_pop(&old_nesting);
		break;

	case WHILE:
	case UNTIL:
		nesting_push(&old_nesting, c);
		t = newtp((c == WHILE) ? TWHILE : TUNTIL);
		t->left = c_list(sALIAS, true);
		t->right = dogroup(sALIAS);
		nesting_pop(&old_nesting);
		break;

	case CASE:
		t = newtp(TCASE);
		musthave(LWORD, 0);
		t->str = yylval.cp;
		nesting_push(&old_nesting, c);
		t->left = caselist(sALIAS);
		nesting_pop(&old_nesting);
		break;

	case IF:
		nesting_push(&old_nesting, c);
		t = newtp(TIF);
		t->left = c_list(sALIAS, true);
		t->right = thenpart(sALIAS);
		musthave(FI, KEYWORD|sALIAS);
		nesting_pop(&old_nesting);
		break;

	case BANG:
		syniocf &= ~(KEYWORD|sALIAS);
		t = pipeline(0, sALIAS);
		if (t == NULL)
			syntaxerr(NULL);
		t = block(TBANG, NULL, t);
		break;

	case TIME:
		syniocf &= ~(KEYWORD|sALIAS);
		t = pipeline(0, sALIAS);
		if (t && t->type == TCOM) {
			t->str = alloc(2, ATEMP);
			/* TF_* flags */
			t->str[0] = '\0';
			t->str[1] = '\0';
		}
		t = block(TTIME, t, NULL);
		break;

	case FUNCTION:
		musthave(LWORD, 0);
		t = function_body(yylval.cp, sALIAS, true);
		break;
	}

	while ((iop = synio(syniocf)) != NULL) {
		if (iopn >= NUFILE)
			yyerror(Tf_toomany, Tredirection);
		iops[iopn++] = iop;
	}

	if (iopn == 0) {
		afree(iops, ATEMP);
		t->ioact = NULL;
	} else {
		iops[iopn++] = NULL;
		iops = aresize2(iops, iopn, sizeof(struct ioword *), ATEMP);
		t->ioact = iops;
	}

	if (t->type == TCOM || t->type == TDBRACKET) {
		XPput(args, NULL);
		t->args = (const char **)XPclose(args);
		XPput(vars, NULL);
		t->vars = (char **)XPclose(vars);
	} else {
		XPfree(args);
		XPfree(vars);
	}

	if (c == MDPAREN) {
		t = block(TBRACE, t, NULL);
		t->ioact = t->left->ioact;
		t->left->ioact = NULL;
	}

	return (t);
}

static struct op *
dogroup(int sALIAS)
{
	int c;
	struct op *list;

	c = token(CONTIN|KEYWORD|sALIAS);
	/*
	 * A {...} can be used instead of do...done for for/select loops
	 * but not for while/until loops - we don't need to check if it
	 * is a while loop because it would have been parsed as part of
	 * the conditional command list...
	 */
	if (c == DO)
		c = DONE;
	else if ((unsigned int)c == ORD('{'))
		c = ORD('}');
	else
		syntaxerr(NULL);
	list = c_list(sALIAS, true);
	musthave(c, KEYWORD|sALIAS);
	return (list);
}

static struct op *
thenpart(int sALIAS)
{
	struct op *t;

	musthave(THEN, KEYWORD|sALIAS);
	t = newtp(0);
	t->left = c_list(sALIAS, true);
	if (t->left == NULL)
		syntaxerr(NULL);
	t->right = elsepart(sALIAS);
	return (t);
}

static struct op *
elsepart(int sALIAS)
{
	struct op *t;

	switch (token(KEYWORD|sALIAS|CMDASN)) {
	case ELSE:
		if ((t = c_list(sALIAS, true)) == NULL)
			syntaxerr(NULL);
		return (t);

	case ELIF:
		t = newtp(TELIF);
		t->left = c_list(sALIAS, true);
		t->right = thenpart(sALIAS);
		return (t);

	default:
		REJECT;
	}
	return (NULL);
}

static struct op *
caselist(int sALIAS)
{
	struct op *t, *tl;
	int c;

	c = token(CONTIN|KEYWORD|sALIAS);
	/* A {...} can be used instead of in...esac for case statements */
	if (c == IN)
		c = ESAC;
	else if ((unsigned int)c == ORD('{'))
		c = ORD('}');
	else
		syntaxerr(NULL);
	t = tl = NULL;
	/* no ALIAS here */
	while ((tpeek(CONTIN|KEYWORD|ESACONLY)) != c) {
		struct op *tc = casepart(c, sALIAS);
		if (tl == NULL)
			t = tl = tc, tl->right = NULL;
		else
			tl->right = tc, tl = tc;
	}
	musthave(c, KEYWORD|sALIAS);
	return (t);
}

static struct op *
casepart(int endtok, int sALIAS)
{
	struct op *t;
	XPtrV ptns;

	XPinit(ptns, 16);
	t = newtp(TPAT);
	/* no ALIAS here */
	if ((unsigned int)token(CONTIN | KEYWORD) != ORD('('))
		REJECT;
	do {
		switch (token(0)) {
		case LWORD:
			break;
		case ORD('}'):
		case ESAC:
			if (symbol != endtok) {
				strdupx(yylval.cp, (unsigned int)symbol ==
				    ORD('}') ? Tcbrace : Tesac, ATEMP);
				break;
			}
			/* FALLTHROUGH */
		default:
			syntaxerr(NULL);
		}
		XPput(ptns, yylval.cp);
	} while (token(0) == '|');
	REJECT;
	XPput(ptns, NULL);
	t->vars = (char **)XPclose(ptns);
	musthave(ORD(')'), 0);

	t->left = c_list(sALIAS, true);

	/* initialise to default for ;; or omitted */
	t->u.charflag = ORD(';');
	/* SUSv4 requires the ;; except in the last casepart */
	if ((tpeek(CONTIN|KEYWORD|sALIAS)) != endtok)
		switch (symbol) {
		default:
			syntaxerr(NULL);
		case BRKEV:
			t->u.charflag = ORD('|');
			if (0)
				/* FALLTHROUGH */
		case BRKFT:
			  t->u.charflag = ORD('&');
			/* FALLTHROUGH */
		case BREAK:
			/* initialised above, but we need to eat the token */
			ACCEPT;
		}
	return (t);
}

static struct op *
function_body(char *name, int sALIAS,
    /* function foo { ... } vs foo() { .. } */
    bool ksh_func)
{
	char *sname, *p;
	struct op *t;

	sname = wdstrip(name, 0);
	/*-
	 * Check for valid characters in name. POSIX and AT&T ksh93 say
	 * only allow [a-zA-Z_0-9] but this allows more as old pdkshs
	 * have allowed more; the following were never allowed:
	 *	NUL TAB NL SP " $ & ' ( ) ; < = > \ ` |
	 * C_QUOTE|C_SPC covers all but adds # * ? [ ]
	 */
	for (p = sname; *p; p++)
		if (ctype(*p, C_QUOTE | C_SPC))
			yyerror(Tinvname, sname, Tfunction);

	/*
	 * Note that POSIX allows only compound statements after foo(),
	 * sh and AT&T ksh allow any command, go with the later since it
	 * shouldn't break anything. However, for function foo, AT&T ksh
	 * only accepts an open-brace.
	 */
	if (ksh_func) {
		if ((unsigned int)tpeek(CONTIN|KEYWORD|sALIAS) == ORD('(' /*)*/)) {
			/* function foo () { //}*/
			ACCEPT;
			musthave(ORD(/*(*/ ')'), 0);
			/* degrade to POSIX function */
			ksh_func = false;
		}
		musthave(ORD('{' /*}*/), CONTIN|KEYWORD|sALIAS);
		REJECT;
	}

	t = newtp(TFUNCT);
	t->str = sname;
	t->u.ksh_func = tobool(ksh_func);
	t->lineno = source->line;

	if ((t->left = get_command(CONTIN, sALIAS)) == NULL) {
		char *tv;
		/*
		 * Probably something like foo() followed by EOF or ';'.
		 * This is accepted by sh and ksh88.
		 * To make "typeset -f foo" work reliably (so its output can
		 * be used as input), we pretend there is a colon here.
		 */
		t->left = newtp(TCOM);
		/* (2 * sizeof(char *)) is small enough */
		t->left->args = alloc(2 * sizeof(char *), ATEMP);
		t->left->args[0] = tv = alloc(3, ATEMP);
		tv[0] = QCHAR;
		tv[1] = ':';
		tv[2] = EOS;
		t->left->args[1] = NULL;
		t->left->vars = alloc(sizeof(char *), ATEMP);
		t->left->vars[0] = NULL;
		t->left->lineno = 1;
	}

	return (t);
}

static char **
wordlist(int sALIAS)
{
	int c;
	XPtrV args;

	XPinit(args, 16);
	/* POSIX does not do alias expansion here... */
	if ((c = token(CONTIN|KEYWORD|sALIAS)) != IN) {
		if (c != ';')
			/* non-POSIX, but AT&T ksh accepts a ; here */
			REJECT;
		return (NULL);
	}
	while ((c = token(0)) == LWORD)
		XPput(args, yylval.cp);
	if (c != '\n' && c != ';')
		syntaxerr(NULL);
	XPput(args, NULL);
	return ((char **)XPclose(args));
}

/*
 * supporting functions
 */

static struct op *
block(int type, struct op *t1, struct op *t2)
{
	struct op *t;

	t = newtp(type);
	t->left = t1;
	t->right = t2;
	return (t);
}

static const struct tokeninfo {
	const char *name;
	short val;
	short reserved;
} tokentab[] = {
	/* Reserved words */
	{ "if",		IF,	true },
	{ "then",	THEN,	true },
	{ "else",	ELSE,	true },
	{ "elif",	ELIF,	true },
	{ "fi",		FI,	true },
	{ "case",	CASE,	true },
	{ Tesac,	ESAC,	true },
	{ "for",	FOR,	true },
	{ Tselect,	SELECT,	true },
	{ "while",	WHILE,	true },
	{ "until",	UNTIL,	true },
	{ "do",		DO,	true },
	{ "done",	DONE,	true },
	{ "in",		IN,	true },
	{ Tfunction,	FUNCTION, true },
	{ Ttime,	TIME,	true },
	{ "{",		ORD('{'), true },
	{ Tcbrace,	ORD('}'), true },
	{ "!",		BANG,	true },
	{ "[[",		DBRACKET, true },
	/* Lexical tokens (0[EOF], LWORD and REDIR handled specially) */
	{ "&&",		LOGAND,	false },
	{ "||",		LOGOR,	false },
	{ ";;",		BREAK,	false },
	{ ";|",		BRKEV,	false },
	{ ";&",		BRKFT,	false },
	{ "((",		MDPAREN, false },
	{ "|&",		COPROC,	false },
	/* and some special cases... */
	{ "newline",	ORD('\n'), false },
	{ NULL,		0,	false }
};

void
initkeywords(void)
{
	struct tokeninfo const *tt;
	struct tbl *p;

	ktinit(APERM, &keywords,
	    /* currently 28 keywords: 75% of 64 = 2^6 */
	    6);
	for (tt = tokentab; tt->name; tt++) {
		if (tt->reserved) {
			p = ktenter(&keywords, tt->name, hash(tt->name));
			p->flag |= DEFINED|ISSET;
			p->type = CKEYWD;
			p->val.i = tt->val;
		}
	}
}

static void
syntaxerr(const char *what)
{
	/* 23<<- is the longest redirection, I think */
	char redir[8];
	const char *s;
	struct tokeninfo const *tt;
	int c;

	if (!what)
		what = Tunexpected;
	REJECT;
	c = token(0);
 Again:
	switch (c) {
	case 0:
		if (nesting.start_token) {
			c = nesting.start_token;
			source->errline = nesting.start_line;
			what = "unmatched";
			goto Again;
		}
		/* don't quote the EOF */
		yyerror("%s: unexpected EOF", Tsynerr);
		/* NOTREACHED */

	case LWORD:
		s = snptreef(NULL, 32, Tf_S, yylval.cp);
		break;

	case REDIR:
		s = snptreef(redir, sizeof(redir), Tft_R, yylval.iop);
		break;

	default:
		for (tt = tokentab; tt->name; tt++)
			if (tt->val == c)
			    break;
		if (tt->name)
			s = tt->name;
		else {
			if (c > 0 && c < 256) {
				redir[0] = c;
				redir[1] = '\0';
			} else
				shf_snprintf(redir, sizeof(redir),
					"?%d", c);
			s = redir;
		}
	}
	yyerror(Tf_sD_s_qs, Tsynerr, what, s);
}

static void
nesting_push(struct nesting_state *save, int tok)
{
	*save = nesting;
	nesting.start_token = tok;
	nesting.start_line = source->line;
}

static void
nesting_pop(struct nesting_state *saved)
{
	nesting = *saved;
}

static struct op *
newtp(int type)
{
	struct op *t;

	t = alloc(sizeof(struct op), ATEMP);
	t->type = type;
	t->u.evalflags = 0;
	t->args = NULL;
	t->vars = NULL;
	t->ioact = NULL;
	t->left = t->right = NULL;
	t->str = NULL;
	return (t);
}

struct op *
compile(Source *s, bool skiputf8bom, bool doalias)
{
	nesting.start_token = 0;
	nesting.start_line = 0;
	herep = heres;
	source = s;
	if (skiputf8bom)
		yyskiputf8bom();
	yyparse(doalias);
	return (outtree);
}

/* Check if we are in the middle of reading an alias */
static int
inalias(struct source *s)
{
	while (s && s->type == SALIAS) {
		if (!(s->flags & SF_ALIASEND))
			return (1);
		s = s->next;
	}
	return (0);
}


/*
 * Order important - indexed by Test_meta values
 * Note that ||, &&, ( and ) can't appear in as unquoted strings
 * in normal shell input, so these can be interpreted unambiguously
 * in the evaluation pass.
 */
static const char dbtest_or[] = { CHAR, '|', CHAR, '|', EOS };
static const char dbtest_and[] = { CHAR, '&', CHAR, '&', EOS };
static const char dbtest_not[] = { CHAR, '!', EOS };
static const char dbtest_oparen[] = { CHAR, '(', EOS };
static const char dbtest_cparen[] = { CHAR, ')', EOS };
const char * const dbtest_tokens[] = {
	dbtest_or, dbtest_and, dbtest_not,
	dbtest_oparen, dbtest_cparen
};
static const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
static const char db_lthan[] = { CHAR, '<', EOS };
static const char db_gthan[] = { CHAR, '>', EOS };

/*
 * Test if the current token is a whatever. Accepts the current token if
 * it is. Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static Test_op
dbtestp_isa(Test_env *te, Test_meta meta)
{
	int c = tpeek(CMDASN | (meta == TM_BINOP ? 0 : CONTIN));
	bool uqword;
	char *save = NULL;
	Test_op ret = TO_NONOP;

	/* unquoted word? */
	uqword = c == LWORD && *ident;

	if (meta == TM_OR)
		ret = c == LOGOR ? TO_NONNULL : TO_NONOP;
	else if (meta == TM_AND)
		ret = c == LOGAND ? TO_NONNULL : TO_NONOP;
	else if (meta == TM_NOT)
		ret = (uqword && !strcmp(yylval.cp,
		    dbtest_tokens[(int)TM_NOT])) ? TO_NONNULL : TO_NONOP;
	else if (meta == TM_OPAREN)
		ret = (unsigned int)c == ORD('(') /*)*/ ? TO_NONNULL : TO_NONOP;
	else if (meta == TM_CPAREN)
		ret = (unsigned int)c == /*(*/ ORD(')') ? TO_NONNULL : TO_NONOP;
	else if (meta == TM_UNOP || meta == TM_BINOP) {
		if (meta == TM_BINOP && c == REDIR &&
		    (yylval.iop->ioflag == IOREAD ||
		    yylval.iop->ioflag == IOWRITE)) {
			ret = TO_NONNULL;
			save = wdcopy(yylval.iop->ioflag == IOREAD ?
			    db_lthan : db_gthan, ATEMP);
		} else if (uqword && (ret = test_isop(meta, ident)))
			save = yylval.cp;
	} else
		/* meta == TM_END */
		ret = (uqword && !strcmp(yylval.cp,
		    db_close)) ? TO_NONNULL : TO_NONOP;
	if (ret != TO_NONOP) {
		ACCEPT;
		if ((unsigned int)meta < NELEM(dbtest_tokens))
			save = wdcopy(dbtest_tokens[(int)meta], ATEMP);
		if (save)
			XPput(*te->pos.av, save);
	}
	return (ret);
}

static const char *
dbtestp_getopnd(Test_env *te, Test_op op MKSH_A_UNUSED,
    bool do_eval MKSH_A_UNUSED)
{
	int c = tpeek(CMDASN);

	if (c != LWORD)
		return (NULL);

	ACCEPT;
	XPput(*te->pos.av, yylval.cp);

	return (null);
}

static int
dbtestp_eval(Test_env *te MKSH_A_UNUSED, Test_op op MKSH_A_UNUSED,
    const char *opnd1 MKSH_A_UNUSED, const char *opnd2 MKSH_A_UNUSED,
    bool do_eval MKSH_A_UNUSED)
{
	return (1);
}

static void
dbtestp_error(Test_env *te, int offset, const char *msg)
{
	te->flags |= TEF_ERROR;

	if (offset < 0) {
		REJECT;
		/* Kludgy to say the least... */
		symbol = LWORD;
		yylval.cp = *(XPptrv(*te->pos.av) + XPsize(*te->pos.av) +
		    offset);
	}
	syntaxerr(msg);
}

#if HAVE_SELECT

#ifndef EOVERFLOW
#ifdef ERANGE
#define EOVERFLOW	ERANGE
#else
#define EOVERFLOW	EINVAL
#endif
#endif

bool
parse_usec(const char *s, struct timeval *tv)
{
	struct timeval tt;
	int i;

	tv->tv_sec = 0;
	/* parse integral part */
	while (ctype(*s, C_DIGIT)) {
		tt.tv_sec = tv->tv_sec * 10 + ksh_numdig(*s++);
		/*XXX this overflow check maybe UB */
		if (tt.tv_sec / 10 != tv->tv_sec) {
			errno = EOVERFLOW;
			return (true);
		}
		tv->tv_sec = tt.tv_sec;
	}

	tv->tv_usec = 0;
	if (!*s)
		/* no decimal fraction */
		return (false);
	else if (*s++ != '.') {
		/* junk after integral part */
		errno = EINVAL;
		return (true);
	}

	/* parse decimal fraction */
	i = 100000;
	while (ctype(*s, C_DIGIT)) {
		tv->tv_usec += i * ksh_numdig(*s++);
		if (i == 1)
			break;
		i /= 10;
	}
	/* check for junk after fractional part */
	while (ctype(*s, C_DIGIT))
		++s;
	if (*s) {
		errno = EINVAL;
		return (true);
	}

	/* end of input string reached, no errors */
	return (false);
}
#endif

/*
 * Helper function called from within lex.c:yylex() to parse
 * a COMSUB recursively using the main shell parser and lexer
 */
char *
yyrecursive(int subtype)
{
	struct op *t;
	char *cp;
	struct yyrecursive_state *ys;
	unsigned int stok, etok;

	if (subtype != COMSUB) {
		stok = ORD('{');
		etok = ORD('}');
	} else {
		stok = ORD('(');
		etok = ORD(')');
	}

	ys = alloc(sizeof(struct yyrecursive_state), ATEMP);

	/* tell the lexer to accept a closing parenthesis as EOD */
	ys->old_nesting_type = subshell_nesting_type;
	subshell_nesting_type = etok;

	/* push reject state, parse recursively, pop reject state */
	ys->old_reject = reject;
	ys->old_symbol = symbol;
	ACCEPT;
	memcpy(ys->old_heres, heres, sizeof(heres));
	ys->old_herep = herep;
	herep = heres;
	ys->next = e->yyrecursive_statep;
	e->yyrecursive_statep = ys;
	/* we use TPAREN as a helper container here */
	t = nested(TPAREN, stok, etok, ALIAS);
	yyrecursive_pop(false);

	/* t->left because nested(TPAREN, ...) hides our goodies there */
	cp = snptreef(NULL, 0, Tf_T, t->left);
	tfree(t, ATEMP);

	return (cp);
}

void
yyrecursive_pop(bool popall)
{
	struct yyrecursive_state *ys;

 popnext:
	if (!(ys = e->yyrecursive_statep))
		return;
	e->yyrecursive_statep = ys->next;

	memcpy(heres, ys->old_heres, sizeof(heres));
	herep = ys->old_herep;
	reject = ys->old_reject;
	symbol = ys->old_symbol;

	subshell_nesting_type = ys->old_nesting_type;

	afree(ys, ATEMP);
	if (popall)
		goto popnext;
}
@


1.126
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.121 2017/04/27 19:33:53 tg Exp $");
d98 1
a98 1
	else if (!ctype(c, C_LF | C_NUL))
@


1.125
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d337 1
a337 1
			case CORD('(' /*)*/):
d393 1
a393 1
	case CORD('(' /*)*/): {
d403 1
a403 1
	case CORD('{' /*}*/):
d414 1
a414 1
		case CORD('(' /*)*/):
d649 1
a649 1
		case CORD('}'):
d816 2
a817 2
	{ "{",		CORD('{'), true },
	{ Tcbrace,	CORD('}'), true },
d829 1
a829 1
	{ "newline",	CORD('\n'), false },
@


1.124
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d5 2
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d39 1
a39 1
	int old_nesting_type;
d79 4
a82 1
#define musthave(c,cf)	do { if (token(cf) != (c)) syntaxerr(NULL); } while (/* CONSTCOND */ 0)
d337 1
a337 1
			case ord('(' /*)*/):
d393 2
a394 2
	case ord('(' /*)*/): {
		int subshell_nesting_type_saved;
d397 2
a398 2
		subshell_nesting_type = ord(')');
		t = nested(TPAREN, ord('('), ord(')'), sALIAS);
d403 2
a404 2
	case ord('{' /*}*/):
		t = nested(TBRACE, ord('{'), ord('}'), sALIAS);
d414 2
a415 2
		case ord('(' /*)*/):
			c = ord('(');
d561 2
a562 2
	else if (c == ord('{'))
		c = ord('}');
d617 2
a618 2
	else if (c == ord('{'))
		c = ord('}');
d643 1
a643 1
	if (token(CONTIN | KEYWORD) != ord('('))
d649 1
a649 1
		case ord('}'):
d652 2
a653 3
				strdupx(yylval.cp,
				    symbol == ord('}') ? Tcbrace : Tesac,
				    ATEMP);
d665 1
a665 1
	musthave(ord(')'), 0);
d670 1
a670 1
	t->u.charflag = ord(';');
d677 1
a677 1
			t->u.charflag = ord('|');
d681 1
a681 1
			  t->u.charflag = ord('&');
d717 1
a717 1
		if (tpeek(CONTIN|KEYWORD|sALIAS) == ord('(' /*)*/)) {
d720 1
a720 1
			musthave(ord(/*(*/ ')'), 0);
d724 1
a724 1
		musthave(ord('{' /*}*/), CONTIN|KEYWORD|sALIAS);
d816 2
a817 2
	{ "{",		ord('{'), true },
	{ Tcbrace,	ord('}'), true },
d829 1
a829 1
	{ "newline",	ord('\n'), false },
d1004 1
a1004 1
		ret = c == ord('(') /*)*/ ? TO_NONNULL : TO_NONOP;
d1006 1
a1006 1
		ret = c == /*(*/ ord(')') ? TO_NONNULL : TO_NONOP;
d1137 1
a1137 1
	int stok, etok;
d1140 2
a1141 2
		stok = ord('{');
		etok = ord('}');
d1143 2
a1144 2
		stok = ord('(');
		etok = ord(')');
@


1.123
log
@commit the optimisation result from the new fast character classes
@
text
@d333 1
a333 1
			case '(' /*)*/:
d376 1
a376 1
					musthave(/*(*/')', 0);
d389 1
a389 1
	case '(': /*)*/ {
d393 2
a394 2
		subshell_nesting_type = ')';
		t = nested(TPAREN, '(', ')', sALIAS);
d399 2
a400 2
	case '{': /*}*/
		t = nested(TBRACE, '{', '}', sALIAS);
d410 2
a411 2
		case '(': /*)*/
			c = '(';
d557 2
a558 2
	else if (c == '{')
		c = '}';
d613 2
a614 2
	else if (c == '{')
		c = '}';
d639 1
a639 1
	if (token(CONTIN | KEYWORD) != '(')
d645 1
a645 1
		case '}':
d649 2
a650 1
				    symbol == '}' ? Tcbrace : Tesac, ATEMP);
d662 1
a662 1
	musthave(')', 0);
d667 1
a667 1
	t->u.charflag = ';';
d674 1
a674 1
			t->u.charflag = '|';
d678 1
a678 1
			t->u.charflag = '&';
d714 1
a714 1
		if (tpeek(CONTIN|KEYWORD|sALIAS) == '(' /*)*/) {
d717 1
a717 1
			musthave(')', 0);
d721 1
a721 1
		musthave('{' /*}*/, CONTIN|KEYWORD|sALIAS);
d813 2
a814 2
	{ "{",		'{',	true },
	{ Tcbrace,	'}',	true },
d826 1
a826 1
	{ "newline",	'\n',	false },
d1001 1
a1001 1
		ret = c == '(' /*)*/ ? TO_NONNULL : TO_NONOP;
d1003 1
a1003 1
		ret = c == /*(*/ ')' ? TO_NONNULL : TO_NONOP;
d1137 2
a1138 2
		stok = '{';
		etok = '}';
d1140 2
a1141 2
		stok = '(';
		etok = ')';
@


1.122
log
@batch of optimisations
@
text
@d94 1
a94 1
	else if (c != '\n' && c != 0)
@


1.121
log
@eliminate legacy macros
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.116 2017/03/11 22:49:56 tg Exp $");
d700 1
a700 1
	 * C_QUOTE covers all but adds # * ? [ ]
d703 1
a703 1
		if (ctype(*p, C_QUOTE))
@


1.120
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d1082 1
a1082 1
	while (ksh_isdigit(*s)) {
d1104 1
a1104 1
	while (ksh_isdigit(*s)) {
d1111 1
a1111 1
	while (ksh_isdigit(*s))
@


1.119
log
@streamline some error messages
@
text
@a37 1
	int old_salias;
d42 4
a45 4
static void yyparse(void);
static struct op *pipeline(int);
static struct op *andor(void);
static struct op *c_list(bool);
d47 9
a55 9
static struct op *nested(int, int, int);
static struct op *get_command(int);
static struct op *dogroup(void);
static struct op *thenpart(void);
static struct op *elsepart(void);
static struct op *caselist(void);
static struct op *casepart(int);
static struct op *function_body(char *, bool);
static char **wordlist(void);
a72 1
static int sALIAS = ALIAS;		/* 0 in yyrecursive */
d84 1
a84 1
yyparse(void)
d90 1
a90 1
	outtree = c_list(source->type == SSTRING);
d99 1
a99 1
pipeline(int cf)
d103 1
a103 1
	t = get_command(cf);
d106 1
a106 1
			if ((p = get_command(CONTIN)) == NULL)
d119 1
a119 1
andor(void)
d124 1
a124 1
	t = pipeline(0);
d127 1
a127 1
			if ((p = pipeline(CONTIN)) == NULL)
d137 1
a137 1
c_list(bool multi)
d144 1
a144 1
		p = andor();
d233 1
a233 1
nested(int type, int smark, int emark)
d239 1
a239 1
	t = c_list(true);
d263 1
a263 1
get_command(int cf)
d377 2
a378 1
					t = function_body(XPptrv(args)[0], false);
d394 1
a394 1
		t = nested(TPAREN, '(', ')');
d400 1
a400 1
		t = nested(TBRACE, '{', '}');
d450 2
a451 2
		t->vars = wordlist();
		t->left = dogroup();
d459 2
a460 2
		t->left = c_list(true);
		t->right = dogroup();
d469 1
a469 1
		t->left = caselist();
d476 2
a477 2
		t->left = c_list(true);
		t->right = thenpart();
d484 1
a484 1
		t = pipeline(0);
d492 1
a492 1
		t = pipeline(0);
d504 1
a504 1
		t = function_body(yylval.cp, true);
d543 1
a543 1
dogroup(void)
d561 1
a561 1
	list = c_list(true);
d567 1
a567 1
thenpart(void)
d573 1
a573 1
	t->left = c_list(true);
d576 1
a576 1
	t->right = elsepart();
d581 1
a581 1
elsepart(void)
d587 1
a587 1
		if ((t = c_list(true)) == NULL)
d593 2
a594 2
		t->left = c_list(true);
		t->right = thenpart();
d604 1
a604 1
caselist(void)
d620 1
a620 1
		struct op *tc = casepart(c);
d631 1
a631 1
casepart(int endtok)
d663 1
a663 1
	t->left = c_list(true);
d687 1
a687 1
function_body(char *name,
d729 1
a729 1
	if ((t->left = get_command(CONTIN)) == NULL) {
d754 1
a754 1
wordlist(void)
d932 1
a932 1
compile(Source *s, bool skiputf8bom)
d940 1
a940 1
	yyparse();
d1128 1
a1128 1
yyrecursive(int subtype MKSH_A_UNUSED)
a1155 2
	ys->old_salias = sALIAS;
	sALIAS = 0;
d1159 1
a1159 1
	t = nested(TPAREN, stok, etok);
a1178 1
	sALIAS = ys->old_salias;
@


1.118
log
@use \\builtin ipv \let] and \set internally
@
text
@d447 1
a447 1
			yyerror("%s: bad identifier\n",
d705 1
a705 1
			yyerror("%s: invalid function name\n", sname);
d872 1
a872 1
		yyerror("%s: unexpected EOF\n", Tsynerr);
d899 1
a899 1
	yyerror("%s: '%s' %s\n", Tsynerr, s, what);
@


1.117
log
@add a “\builtin” builtin, make it forward assignments, fix some bugs
related to that:
• while AT&T ksh may do it, POSIX says nothing about allowing
  declaration commands only without vars and redirections, and
  “without vars” especially seems against which commands they are
• fix relationship between forwarders and real declaration commands
• clean up c_builtin vs shcomexec mess

Also, re-run “make repool” with a fixed src/scripts/stringpool.sh,v 1.3
@
text
@d247 4
d252 1
a252 1
	QCHAR, 'l', CHAR, 'e', CHAR, 't', CHAR, ']', EOS
d255 1
a255 1
	QCHAR, 's', CHAR, 'e', CHAR, 't', EOS
d349 1
d419 1
@


1.116
log
@fixup tilde expansion comments; revert a few bogus dirsep changes

cf. <Pine.BSM.4.64L.1703112129500.29506@@herc.mirbsd.org>
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.108 2016/01/14 19:52:20 tg Exp $");
d292 1
a292 1
			bool check_assign_cmd;
d296 1
a296 1
				check_assign_cmd = true;
d314 6
a319 7
				/*
				 * the iopn == 0 and XPsize(vars) == 0 are
				 * dubious but AT&T ksh acts this way
				 */
				if (iopn == 0 && XPsize(vars) == 0 &&
				    check_assign_cmd) {
					if (assign_command(ident, false))
d321 2
a322 2
					else if (strcmp(ident, Tcommand) != 0)
						check_assign_cmd = false;
a938 13
/* lexical analysis for declaration utilities */
int
assign_command(const char *s, bool docommand)
{
	if (!*s)
		return (0);
	return ((strcmp(s, Talias) == 0) ||
	    (strcmp(s, Texport) == 0) ||
	    (strcmp(s, Treadonly) == 0) ||
	    (docommand && (strcmp(s, Tcommand) == 0)) ||
	    (strcmp(s, Ttypeset) == 0));
}

@


1.115
log
@fix English (thanks to Andreas Buschka); TIL:
• to start ⇒ a start
• to begin ⇒ a beginning
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d940 1
a940 11
/*-
 * This kludge exists to take care of sh/AT&T ksh oddity in which
 * the arguments of alias/export/readonly/typeset have no field
 * splitting, file globbing, or (normal) tilde expansion done.
 * AT&T ksh seems to do something similar to this since
 *	$ touch a=a; typeset a=[ab]; echo "$a"
 *	a=[ab]
 *	$ x=typeset; $x a=[ab]; echo "$a"
 *	a=a
 *	$
 */
@


1.114
log
@assorted code cleanup, while here anyway
@
text
@d290 1
a290 1
		goto get_command_begin;
d295 1
a295 1
 get_command_begin:
@


1.113
log
@remove fd>9 support in favour of upcoming named file descriptors; bump
@
text
@d967 1
a967 1
	for (; s && s->type == SALIAS; s = s->next)
d970 2
@


1.112
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@a219 1
#ifdef MKSH_CONSERVATIVE_FDS
a220 8
#else
		nextiop->ioname = cp = alloc(5, ATEMP);

		if (iop->unit > 9) {
			*cp++ = CHAR;
			*cp++ = digits_lc[iop->unit / 10];
		}
#endif
@


1.111
log
@yyrecursive needs its own and empty heres[]
fixes http://thread.gmane.org/gmane.comp.shells.dash/1241/focus=1245
@
text
@d211 1
a211 1
			yyerror("too many %ss\n", "<<");
d315 2
a316 2
						yyerror("too many %ss\n",
						    "redirection");
d515 1
a515 1
			yyerror("too many %ss\n", "redirection");
d816 1
a816 1
	{ "time",	TIME,	true },
d863 1
a863 1
		what = "unexpected";
d880 1
a880 1
		s = snptreef(NULL, 32, "%S", yylval.cp);
d884 1
a884 1
		s = snptreef(redir, sizeof(redir), "%R", yylval.iop);
d1191 1
a1191 1
	cp = snptreef(NULL, 0, "%T", t->left);
@


1.110
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d34 1
d1179 1
d1181 1
d1208 1
@


1.109
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVAR→CMDASN
@
text
@d450 2
a451 2
			yyerror("%s: %s\n", c == FOR ? "for" : Tselect,
			    "bad identifier");
d708 1
a708 1
			yyerror("%s: %s\n", sname, "invalid function name");
d875 1
a875 1
		yyerror("%s: %s %s\n", Tsynerr, "unexpected", "EOF");
@


1.108
log
@parse “$( (( … ) … ) … )” correctly (LP#1532621)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.99 2015/03/14 05:23:18 tg Exp $");
a274 1
	char *tcp;
d283 1
a283 1
	switch (c = token(cf|KEYWORD|sALIAS|VARASN)) {
d298 1
d300 10
a309 2
			cf = (t->u.evalflags ? ARRAYVAR : 0) |
			    (XPsize(args) == 0 ? sALIAS|VARASN : CMDWORD);
d327 6
a332 3
				    XPsize(args) == 0 &&
				    assign_command(ident))
					t->u.evalflags = DOVACHECK;
d343 2
d448 1
a448 1
		musthave(LWORD, ARRAYVAR);
d589 1
a589 1
	switch (token(KEYWORD|sALIAS|VARASN)) {
d960 1
a960 1
assign_command(const char *s)
d967 1
d1009 1
a1009 1
	int c = tpeek(ARRAYVAR | (meta == TM_BINOP ? 0 : CONTIN));
d1055 1
a1055 1
	int c = tpeek(ARRAYVAR);
@


1.107
log
@make (( … )) into a compound command, as ormaaj says was originally intended
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d403 1
@


1.106
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@d523 6
@


1.105
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d213 1
a213 1
		iop->name = yylval.cp;
d219 4
a222 1
		nextiop->name = cp = alloc(5, ATEMP);
d228 1
@


1.104
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
d297 1
a297 1
			    (XPsize(args) == 0 ? sALIAS|VARASN : 0);
@


1.103
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d175 2
a193 2
	if (iop->ioflag & IONDELIM)
		goto gotnulldelim;
d195 8
a202 1
	musthave(LWORD, ishere ? HEREDELIM : 0);
d205 1
a205 1
		if (*ident != 0) {
a206 1
 gotnulldelim:
@


1.102
log
@we have longer fds now, plus add 1 for a space just to be sure
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.29 2013/06/03 18:40:05 jca Exp $	*/
d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.101
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d825 2
a826 2
	/* 2<<- is the longest redirection, I think */
	char redir[6];
@


1.100
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d217 1
a217 1
			*cp++ = '0' + (iop->unit / 10);
d220 1
a220 1
		*cp++ = '0' + (iop->unit % 10);
d1077 2
a1078 1
		tt.tv_sec = tv->tv_sec * 10 + (*s++ - '0');
d1099 1
a1099 1
		tv->tv_usec += i * (*s++ - '0');
@


1.99
log
@“local x=$1” is supposed to not field-split and so
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.93 2013/09/10 16:30:50 tg Exp $");
d192 1
a192 1
	if (iop->flag & IONDELIM)
d194 1
a194 1
	ishere = (iop->flag & IOTYPE) == IOHERE;
d201 1
a201 1
			iop->flag |= IOEVAL;
d209 1
a209 1
	if (iop->flag & IOBASH) {
d223 1
a223 1
		iop->flag &= ~IOBASH;
d225 1
a225 1
		nextiop->flag = IODUP;
d999 2
a1000 1
		    (yylval.iop->flag == IOREAD || yylval.iop->flag == IOWRITE)) {
d1002 1
a1002 1
			save = wdcopy(yylval.iop->flag == IOREAD ?
@


1.98
log
@another needed quote
@
text
@a60 1
static int assign_command(const char *);
d929 1
a929 1
static int
@


1.97
log
@remove unused CMDWORD
@
text
@d716 1
a716 1
		tv[0] = CHAR;
@


1.96
log
@• protect POSIX builtins and utilities from aliases, e.g:
  ‣ : → \:
  ‣ alias → \alias
    ⇒ except in some internally used cases, where we use \builtin alias
  ‣ command . → \command .
• protect Korn Shell builtins from aliases and functions, e.g:
  ‣ typeset → \builtin typeset
    ⇒ also unravels the “local” alias used
  ‣ print → \builtin print
• protect internally-used things from aliases
  ‣ “let]” is not a valid function name
  ‣ “set” is POSIX so we don’t expect anyone to override it in a function
• use “command -v” instead of “whence -p” (“which”) in most
  places; thanks izabera from #ed on IRC for pointing out
  that “command -v” is POSIX – except, “whence -p” a̲l̲w̲a̲y̲s̲ looks
  for an executable and shows its full pathname; “command -v”
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
• make most of dot.mkshrc work in the face of such aliases
  ‣ “ulimit -c” is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesn’t use them?
• update list of builtin aliases in the manpage
@
text
@d292 1
a292 1
			    (XPsize(args) == 0 ? sALIAS|VARASN : CMDWORD);
@


1.95
log
@「if + comment(!) + label(!!) + one statement」 ← shouldn’t that get braces, style(9)?
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d247 1
a247 1
	CHAR, 'l', CHAR, 'e', CHAR, 't', CHAR, ']', EOS
d250 1
a250 1
	CHAR, 's', CHAR, 'e', CHAR, 't', EOS
@


1.94
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d199 1
a199 1
		if (*ident != 0)
d203 1
@


1.94.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.94 2014/01/05 21:57:29 tg Exp $");
d199 1
a199 1
		if (*ident != 0) {
a202 1
		}
@


1.94.2.2
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.94.2.1 2015/01/25 15:35:54 tg Exp $");
d61 1
d292 1
a292 1
			    (XPsize(args) == 0 ? sALIAS|VARASN : 0);
d930 1
a930 1
int
@


1.94.2.3
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.94.2.2 2015/03/20 22:21:10 tg Exp $");
d192 1
a192 1
	if (iop->ioflag & IONDELIM)
d194 1
a194 1
	ishere = (iop->ioflag & IOTYPE) == IOHERE;
d201 1
a201 1
			iop->ioflag |= IOEVAL;
d209 1
a209 1
	if (iop->ioflag & IOBASH) {
d223 1
a223 1
		iop->ioflag &= ~IOBASH;
d225 1
a225 1
		nextiop->ioflag = IODUP;
d999 1
a999 2
		    (yylval.iop->ioflag == IOREAD ||
		    yylval.iop->ioflag == IOWRITE)) {
d1001 1
a1001 1
			save = wdcopy(yylval.iop->ioflag == IOREAD ?
@


1.93
log
@int → bool; commit as a TODO comment a begun change attempt
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.89 2013/04/26 18:27:07 tg Exp $");
d62 1
a62 1
static int inalias(struct source *);
@


1.92
log
@from oksh: “for var in; do” shouldn’t be interpreted as “for var; do” (POSIX)
@
text
@d979 1
a979 1
	int uqword;
@


1.91
log
@implement VALSUBs
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.28 2008/07/23 16:34:38 jaredy Exp $	*/
d745 2
a746 7
	if (XPsize(args) == 0) {
		XPfree(args);
		return (NULL);
	} else {
		XPput(args, NULL);
		return ((char **)XPclose(args));
	}
@


1.90
log
@Oh well… this looks well, is done done, and gcc-snapshot doesn’t complain:
• correct order of built-in commands; use POSIX special versus “all others”
  plus “keeps assignments” as distinction, no longer play POSIX regular vs.
  others game; sync manpage
• fix LP#1156707: map (( internally to “let]” which is no valid function
  name and so can’t be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
• we do not need -Wno-overflow any more, either
• bump to R45
@
text
@d1132 1
a1132 1
	if (subtype == FUNSUB) {
@


1.89
log
@kill dead code
@
text
@d5 1
a5 1
 *		 2011, 2012
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.88 2012/12/28 02:28:39 tg Exp $");
d246 1
a246 1
	CHAR, 'l', CHAR, 'e', CHAR, 't', EOS
@


1.88
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.87 2012/12/05 19:38:25 tg Exp $");
d56 1
a56 1
static struct op *block(int, struct op *, struct op *, char **);
d111 1
a111 1
				t = tl = block(TPIPE, t, p, NOWORDS);
d113 1
a113 1
				tl = tl->right = block(TPIPE, tl->right, p, NOWORDS);
d131 1
a131 1
			t = block(c == LOGAND? TAND: TOR, t, p, NOWORDS);
d160 1
a160 2
			p = block(c == '&' ? TASYNC : TCOPROC,
			    p, NOBLOCK, NOWORDS);
d166 1
a166 1
			t = tl = block(TLIST, t, p, NOWORDS);
d168 1
a168 1
			tl = tl->right = block(TLIST, tl->right, p, NOWORDS);
d242 1
a242 1
	return (block(type, t, NOBLOCK, NOWORDS));
d467 1
a467 1
		t = block(TBANG, NOBLOCK, t, NOWORDS);
d479 1
a479 1
		t = block(TTIME, t, NOBLOCK, NOWORDS);
d507 1
a507 1
		t->vars = (char **) XPclose(vars);
d634 1
a634 1
	t->vars = (char **) XPclose(ptns);
d759 1
a759 1
block(int type, struct op *t1, struct op *t2, char **wp)
a765 1
	t->vars = wp;
@


1.87
log
@fix libFirm/cparser -Wsign-compare
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.85 2012/11/30 20:19:15 tg Exp $");
d969 1
a969 1
const char *const dbtest_tokens[] = {
@


1.86
log
@shuffle declarations around (all shared between even only two files go into sh.h even if they’re not supposed to be used elsewhere) and make some static; libFirm/cparser has -Wmissing-declarations against it
@
text
@d1018 1
a1018 1
		if (meta < NELEM(dbtest_tokens))
@


1.85
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d26 1
a26 4
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.84 2012/10/30 20:49:44 tg Exp $");

extern int subshell_nesting_type;
extern void yyskiputf8bom(void);
d771 1
a771 1
const struct tokeninfo {
d973 3
a975 3
const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
const char db_lthan[] = { CHAR, '<', EOS };
const char db_gthan[] = { CHAR, '>', EOS };
@


1.84
log
@who would’ve thought proper ^C handling be so hard?
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.82 2012/10/22 20:19:18 tg Exp $");
a1136 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
d1140 1
a1140 3
	} else
#endif
	  {
@


1.84.2.1
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d26 4
a29 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.84 2012/10/30 20:49:44 tg Exp $");
d774 1
a774 1
static const struct tokeninfo {
d976 3
a978 3
static const char db_close[] = { CHAR, ']', CHAR, ']', EOS };
static const char db_lthan[] = { CHAR, '<', EOS };
static const char db_gthan[] = { CHAR, '>', EOS };
d1021 1
a1021 1
		if ((unsigned int)meta < NELEM(dbtest_tokens))
@


1.83
log
@restore yyrecursive context in quitenv (LP#1069428)
@
text
@d1165 1
a1165 1
	yyrecursive_pop();
d1175 1
a1175 1
yyrecursive_pop(void)
d1177 1
a1177 1
	struct yyrecursive_state *ys = e->yyrecursive_statep;
d1179 3
d1192 2
@


1.82
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.81 2012/10/03 15:50:32 tg Exp $");
d36 9
d1134 1
a1134 3
	bool old_reject;
	int old_symbol, old_salias, old_nesting_type;
	struct ioword **old_herep;
d1148 2
d1151 1
a1151 1
	old_nesting_type = subshell_nesting_type;
d1155 2
a1156 2
	old_reject = reject;
	old_symbol = symbol;
d1158 2
a1159 2
	old_herep = herep;
	old_salias = sALIAS;
d1161 2
d1165 1
a1165 4
	sALIAS = old_salias;
	herep = old_herep;
	reject = old_reject;
	symbol = old_symbol;
a1170 1
	subshell_nesting_type = old_nesting_type;
d1173 17
@


1.81
log
@rewrite XPtrV to use size_t instead of pointer arithmetic, for gcc-snapshot (20120930-1) -fstrict-overflow -Wstrict-overflow=9
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.80 2012/08/17 18:34:25 tg Exp $");
d28 1
a30 2
extern uint8_t subshell_nesting_level;

d366 2
a367 1
	case '(': /*)*/
d369 2
a370 1
		++subshell_nesting_level;
d372 1
a372 1
		--subshell_nesting_level;
d374 1
d1121 1
a1121 1
yyrecursive(void)
d1126 1
a1126 1
	int old_symbol, old_salias;
d1128 12
d1142 2
a1143 1
	++subshell_nesting_level;
d1153 1
a1153 1
	t = nested(TPAREN, '(', ')');
d1163 1
a1163 1
	--subshell_nesting_level;
@


1.80
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.79 2012/07/30 21:37:16 tg Exp $");
d322 1
a322 1
					tcp = *(--vars.cur);
@


1.79
log
@implement ksh93 feature ${ foo;}
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.77 2012/07/01 15:38:08 tg Exp $");
a27 1
extern int subshell_nesting_type;
d30 2
d367 1
a367 2
	case '(': /*)*/ {
		int subshell_nesting_type_saved;
d369 1
a369 2
		subshell_nesting_type_saved = subshell_nesting_type;
		subshell_nesting_type = ')';
d371 1
a371 1
		subshell_nesting_type = subshell_nesting_type_saved;
a372 1
	    }
d1119 1
a1119 1
yyrecursive(int subtype)
d1124 1
a1124 1
	int old_symbol, old_salias, old_nesting_type;
a1125 12
	int stok, etok;

	switch (subtype) {
	case FUNSUB:
		stok = '{';
		etok = '}';
		break;
	case COMSUB:
	default:
		stok = '(';
		etok = ')';
	}
d1128 1
a1128 2
	old_nesting_type = subshell_nesting_type;
	subshell_nesting_type = etok;
d1138 1
a1138 1
	t = nested(TPAREN, stok, etok);
d1148 1
a1148 1
	subshell_nesting_type = old_nesting_type;
@


1.78
log
@remove unused flag
@
text
@d28 1
a28 1
extern short subshell_nesting_level;
d366 2
a367 1
	case '(':
d369 2
a370 1
		++subshell_nesting_level;
d372 1
a372 1
		--subshell_nesting_level;
d374 1
d1121 1
a1121 1
yyrecursive(void)
d1126 1
a1126 1
	int old_symbol, old_salias;
d1128 12
d1142 2
a1143 1
	++subshell_nesting_level;
d1153 1
a1153 1
	t = nested(TPAREN, '(', ')');
d1163 1
a1163 1
	--subshell_nesting_level;
@


1.77
log
@dissolve the hashtab nonsense, ¾ is good, and mirkev will also use that
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.76 2012/06/28 20:04:02 tg Exp $");
a658 1
	bool old_func_parse;
d680 1
a680 1
			/* function foo () { */
a694 2
	old_func_parse = e->flags & EF_FUNC_PARSE;
	e->flags |= EF_FUNC_PARSE;
a714 2
	if (!old_func_parse)
		e->flags &= ~EF_FUNC_PARSE;
@


1.76
log
@ensure that case end tokens are not mixed up (Closes: #220272)

XXX token/tpeek/musthave should rescan the last input lexems
XXX if the new cf passed doesn't match the last cf passed
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.75 2012/05/09 23:21:00 tg Exp $");
d813 2
a814 2
	    /* currently 28 keywords */
	    /* 80% of 64 = 2^6 */ 6, /* 66% of 64 = 2^6 */ 6);
@


1.75
log
@Fix typeset issues (LP: #993847)

This was actually more evil:
• use a recursive function to display blocks in reverse order,
  so that local variable values overwrite global ones
• add array support to typeset -p (from typeset -p -)
• display 'set -A varname' line before setting values, for -p
• if -p got arguments, only display those (from the innermost scope)

Also, the usual amount of code cleanup…
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.74 2012/03/03 21:30:58 tg Exp $");
d76 3
d608 14
a621 1
		musthave(LWORD, 0);
d779 1
a779 1
	{ "esac",	ESAC,	true },
d790 1
a790 1
	{ "}",		'}',	true },
@


1.74
log
@RCSID sync from oksh; reduce hash table #elements if !MKSH_SMALL to speed up
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.73 2012/01/03 15:32:08 tg Exp $");
d55 1
a55 1
static int assign_command(char *);
d917 1
a917 1
assign_command(char *s)
d922 2
a923 2
	    (strcmp(s, "export") == 0) ||
	    (strcmp(s, "readonly") == 0) ||
@


1.73
log
@fix regression in jaredy’s security patch introduced in R35b
(cid 100487B467E068A55D6 and 10048949D196A7C1390) discovered
by Jb_boin: time with a not-TCOM subtree would now trash its
string argument (which is the loop variable for TFOR); amend
regression testsuite
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.72 2011/12/29 22:03:15 tg Exp $");
d797 2
a798 2
	    /* currently 28 keywords -> 80% of 64 (2^6) */
	    6);
@


1.72
log
@ensure aliases in COMSUB are not expanded twice
spotted by Jilles Tjoelker again, thanks
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.71 2011/11/22 18:01:41 tg Exp $");
d462 1
a462 1
		if (t) {
@


1.71
log
@Fix regression introduced by mixing the recursive parser and support
for ;| and ;& in TCASE: ;;-less last casepart produced ";\0" in the
SREREAD string which obviously cased reparsing to fail

test from http://www.in-ulm.de/~mascheck/various/cmd-subst/
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.70 2011/11/11 22:14:19 tg Exp $");
d67 1
d231 1
a231 1
	musthave(emark, KEYWORD|ALIAS);
d264 2
a265 2
	syniocf = KEYWORD|ALIAS;
	switch (c = token(cf|KEYWORD|ALIAS|VARASN)) {
d277 1
a277 1
		syniocf &= ~(KEYWORD|ALIAS);
d282 1
a282 1
			    (XPsize(args) == 0 ? ALIAS|VARASN : CMDWORD);
d446 1
a446 1
		musthave(FI, KEYWORD|ALIAS);
d451 1
a451 1
		syniocf &= ~(KEYWORD|ALIAS);
d459 1
a459 1
		syniocf &= ~(KEYWORD|ALIAS);
d510 1
a510 1
	c = token(CONTIN|KEYWORD|ALIAS);
d524 1
a524 1
	musthave(c, KEYWORD|ALIAS);
d533 1
a533 1
	musthave(THEN, KEYWORD|ALIAS);
d547 1
a547 1
	switch (token(KEYWORD|ALIAS|VARASN)) {
d571 1
a571 1
	c = token(CONTIN|KEYWORD|ALIAS);
d588 1
a588 1
	musthave(c, KEYWORD|ALIAS);
d617 1
a617 1
	if ((tpeek(CONTIN|KEYWORD|ALIAS)) != endtok)
d663 1
a663 1
		if (tpeek(CONTIN|KEYWORD|ALIAS) == '(' /*)*/) {
d670 1
a670 1
		musthave('{' /*}*/, CONTIN|KEYWORD|ALIAS);
d715 1
a715 1
	if ((c = token(CONTIN|KEYWORD|ALIAS)) != IN) {
d1111 1
a1111 1
	int old_symbol;
d1122 2
d1126 1
@


1.70
log
@promote x=(a b); x+=(c) to standard mksh functionality at cost of 932 MKSH_SMALL .text bytes on MirBSD/i386
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.69 2011/09/07 15:24:21 tg Exp $");
d612 4
a615 1
	/* Note: POSIX requires the ;; */
a619 1
		case BREAK:
d621 3
d625 4
a628 3
			t->u.charflag =
			    (symbol == BRKEV) ? '|' :
			    (symbol == BRKFT) ? '&' : ';';
@


1.69
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.68 2011/08/27 18:06:51 tg Exp $");
d235 13
d252 1
a252 1
	int c, iopn = 0, syniocf;
d255 1
d309 39
a347 12
			case '(':
#ifndef MKSH_SMALL
				if ((XPsize(args) == 0 || Flag(FKEYWORD)) &&
				    XPsize(vars) == 1 && is_wdvarassign(yylval.cp))
					goto is_wdarrassign;
#endif
				/*
				 * Check for "> foo (echo hi)" which AT&T ksh
				 * allows (not POSIX, but not disallowed)
				 */
				afree(t, ATEMP);
				if (XPsize(args) == 0 && XPsize(vars) == 0) {
d349 2
a350 1
					goto Subshell;
a351 43

				/* must be a function */
				if (iopn != 0 || XPsize(args) != 1 ||
				    XPsize(vars) != 0)
					syntaxerr(NULL);
				ACCEPT;
				musthave(/*(*/')', 0);
				t = function_body(XPptrv(args)[0], false);
				goto Leave;
#ifndef MKSH_SMALL
 is_wdarrassign:
			{
				static const char set_cmd0[] = {
					CHAR, 's', CHAR, 'e',
					CHAR, 't', EOS
				};
				static const char set_cmd1[] = {
					CHAR, '-', CHAR, 'A', EOS
				};
				static const char set_cmd2[] = {
					CHAR, '-', CHAR, '-', EOS
				};
				char *tcp;

				ACCEPT;

				/* manipulate the vars string */
				tcp = *(--vars.cur);
				/* 'varname=' -> 'varname' */
				tcp[wdscan(tcp, EOS) - tcp - 3] = EOS;

				/* construct new args strings */
				XPput(args, wdcopy(set_cmd0, ATEMP));
				XPput(args, wdcopy(set_cmd1, ATEMP));
				XPput(args, tcp);
				XPput(args, wdcopy(set_cmd2, ATEMP));

				/* slurp in words till closing paren */
				while (token(CONTIN) == LWORD)
					XPput(args, yylval.cp);
				if (symbol != /*(*/ ')')
					syntaxerr(NULL);

a352 2
			}
#endif
d372 1
a372 7
	case MDPAREN: {
		int lno;
		static const char let_cmd[] = {
			CHAR, 'l', CHAR, 'e',
			CHAR, 't', EOS
		};

a388 1
	}
@


1.68
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.67 2011/06/05 19:58:20 tg Exp $");
d423 1
a423 1
			yyerror("%s: %s\n", c == FOR ? "for" : T_select,
d767 1
a767 1
	{ T_select,	SELECT,	true },
d773 1
a773 1
	{ T_function,	FUNCTION, true },
d834 1
a834 1
		yyerror("%s: %s %s\n", T_synerr, "unexpected", "EOF");
d861 1
a861 1
	yyerror("%s: '%s' %s\n", T_synerr, s, what);
d923 1
a923 1
	return ((strcmp(s, T_alias) == 0) ||
d926 1
a926 1
	    (strcmp(s, T_typeset) == 0));
@


1.67
log
@• rework hash table interna to avoid gcc-4.1 on Debian etch bug
• also improve behaviour with _a lot_ (>2²⁸) entries
• while here, improve comments and whitespace
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.66 2011/06/04 16:11:20 tg Exp $");
d28 1
a896 2
	extern void yyskiputf8bom(void);

@


1.66
log
@better parsing for x=(…) – bug noted by Frank Terbeck
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.65 2011/05/29 02:18:57 tg Exp $");
d797 3
a799 3
	ktinit(&keywords, APERM,
	    /* must be 80% of 2^n (currently 28 keywords) */
	    64);
@


1.65
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.64 2011/05/07 00:51:12 tg Exp $");
d295 5
d309 1
a309 5
#ifndef MKSH_SMALL
				if ((XPsize(args) == 0 || Flag(FKEYWORD)) &&
				    XPsize(vars) == 1 && is_wdvarassign(yylval.cp))
					goto is_wdarrassign;
#endif
d322 2
a323 2
					CHAR, 'e', CHAR, 'v',
					CHAR, 'a', CHAR, 'l', EOS
a325 2
					CHAR, 's', CHAR, 'e',
					CHAR, 't', CHAR, ' ',
d332 6
a337 7
				XPfree(vars);
				XPinit(vars, 16);
				/*
				 * we know (or rather hope) that yylval.cp
				 * contains a string "varname="
				 */
				tcp = wdcopy(yylval.cp, ATEMP);
d339 2
a340 4
				/* now make an array assignment command */
				t = newtp(TCOM);
				t->lineno = source->line;
				ACCEPT;
d345 8
a352 3
				musthave(LWORD,LETARRAY);
				XPput(args, yylval.cp);
				break;
@


1.64
log
@• fix an inverted logic bug in the test I wrote
• only trigger deleting an alias in favour of a function for “()”, not
  just the opening parenthesis: “stop( )” is not a function definition
  (well, actually it seems to be, but… not according to POSIX, anyway)
• defer dropping the alias until the function is actually defined (õÕ)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.63 2011/05/05 00:05:01 tg Exp $");
d622 11
a632 1
		musthave(BREAK, CONTIN|KEYWORD|ALIAS);
d781 2
d797 2
a798 2
	    /* must be 80% of 2^n (currently 20 keywords) */
	    32);
@


1.63
log
@• use a flag for determining here strings, don’t parse delimiter every time
• don’t leak memory parsing possible I/O redirection tokens
• get rid of volatile by using more const (also helps codegen, methinks)
• support empty here document markers (mksh extension)
• pimp the manpage
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.62 2011/05/02 22:52:53 tg Exp $");
a654 2
			struct tbl *tp;

a659 2
			if ((tp = ktsearch(&aliases, sname, hash(sname))))
				ktdelete(tp);
@


1.62
log
@• fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
• merge tputS and wdstrip_internal
⇒ net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.61 2011/04/22 12:15:42 tg Exp $");
d182 3
a184 1
	ishere = (iop->flag&IOTYPE) == IOHERE;
d190 1
@


1.61
log
@more static initialisers (verified using nm comparision between mksh
built with/-out "-ffunction-sections -fdata-sections -Wl,--gc-sections"
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.60 2011/04/09 15:14:54 tg Exp $");
d632 1
a632 1
	sname = wdstrip(name, false, false);
@


1.60
log
@• no longer use <stdbool.h> even if it’s available
• ensure that bool/true/false are cpp macros, overriding any pre-defined
• document the requirement that tobool(x) must map any-type 'x' into bool
• document the requirement that a bool must only be true or false, and
  that it (tobool() rather) must have an identity mapping to 'short'
• possibly fix ksh_func for/and fpFUNCTf – maybe spotted by cnuke@@
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.59 2011/03/26 15:32:37 tg Exp $");
d169 1
a169 1
	static struct ioword *nextiop = NULL;
@


1.59
log
@new (some possible) testcases from Austin ML, and one fix
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.58 2011/03/21 21:57:35 tg Exp $");
d668 1
a668 1
	t->u.ksh_func = ksh_func;
@


1.58
log
@• save/restore here document pointer during yyrecursive(), fixes crash
• add mirbsd/openbsd (omalloc rules!) specific testcase for the above
• $__progname must be used quoted, fix in comsub-torture testcase (my bad)
@
text
@d25 3
a27 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.57 2011/03/13 16:03:54 tg Exp $");
d361 1
d363 1
a1104 1
	extern short comsub_nesting_level;
d1107 1
a1107 1
	++comsub_nesting_level;
d1124 1
a1124 1
	--comsub_nesting_level;
@


1.57
log
@• speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
• parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.56 2011/03/13 01:20:24 tg Exp $");
d1100 1
d1110 1
d1113 1
@


1.56
log
@lint is your friend
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.55 2011/03/12 20:20:17 tg Exp $");
d878 1
a878 1
compile(Source *s)
d880 2
d886 2
@


1.55
log
@even more test cases for comsub (2 breaking, but one of them fixed already)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.54 2011/03/06 01:25:35 tg Exp $");
d69 1
a69 1
#define musthave(c,cf)	do { if (token(cf) != (c)) syntaxerr(NULL); } while (0)
d131 1
a131 1
	while (1) {
d259 1
a259 1
		while (1) {
@


1.54
log
@the long-awaited recursive parser for COMSUB $(…) expressions

fixes RedHat BZ#496791
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.53 2011/02/11 00:41:38 tg Exp $");
d1096 4
d1114 1
@


1.53
log
@add a sleep builtin that can deal with fractions too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.52 2010/09/14 21:26:18 tg Exp $");
d35 1
a35 1
static struct op *c_list(int);
d62 2
a63 2
static int reject;		/* token(cf) gets symbol again */
static int symbol;		/* yylex value */
d65 2
a66 2
#define REJECT		(reject = 1)
#define ACCEPT		(reject = 0)
d125 1
a125 1
c_list(int multi)
d128 2
a129 1
	int c, have_sep;
d133 2
a134 1
		/* Token has always been read/rejected at this point, so
d138 1
a138 1
		have_sep = 1;
d140 2
a141 1
			if (!p) /* ignore blank lines */
d149 1
a149 1
			have_sep = 0;
d184 2
a185 1
		if (*ident != 0) /* unquoted */
d250 2
a251 1
		return (NULL); /* empty line */
d274 2
a275 1
				/* the iopn == 0 and XPsize(vars) == 0 are
d290 2
a291 1
				/* Check for "> foo (echo hi)" which AT&T ksh
d304 1
a304 1
				/* Must be a function */
d309 1
a309 2
				/*(*/
				musthave(')', 0);
d373 1
a373 1
		/* Leave KEYWORD in syniocf (allow if (( 1 )) then ...) */
d379 1
a379 1
		case '(':	/* ) */
d392 1
a392 1
		/* Leave KEYWORD in syniocf (allow if [[ -n 1 ]] then ...) */
d463 2
a464 1
			t->str[0] = '\0';	/* TF_* flags */
d511 2
a512 1
	/* A {...} can be used instead of do...done for for/select loops
d580 2
a581 1
	while ((tpeek(CONTIN|KEYWORD|ESACONLY)) != c) { /* no ALIAS here */
d621 2
a622 1
    bool ksh_func)		/* function foo { ... } vs foo() { .. } */
d629 4
a632 3
	/* Check for valid characters in name. POSIX and AT&T ksh93 say only
	 * allow [a-zA-Z_0-9] but this allows more as old pdkshs have
	 * allowed more (the following were never allowed:
d640 5
a644 4
	/* Note that POSIX allows only compound statements after foo(), sh and
	 * AT&T ksh allow any command, go with the later since it shouldn't
	 * break anything. However, for function foo, AT&T ksh only accepts
	 * an open-brace.
d647 1
a647 1
		if (tpeek(CONTIN|KEYWORD|ALIAS) == '(' /* ) */) {
d658 1
a658 1
		musthave('{', CONTIN|KEYWORD|ALIAS); /* } */
d704 2
a705 1
		if (c != ';') /* non-POSIX, but AT&T ksh accepts a ; here */
d782 2
a783 1
	    /* must be 80% of 2^n (currently 20 keywords) */ 32);
d797 2
a798 1
	char redir[6];	/* 2<<- is the longest redirection, I think */
d888 2
a889 1
/* This kludge exists to take care of sh/AT&T ksh oddity in which
d921 2
a922 1
/* Order important - indexed by Test_meta values
d975 2
a976 1
	} else /* meta == TM_END */
d1084 28
@


1.52
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.51 2010/08/28 20:22:23 tg Exp $");
d408 1
a408 1
			yyerror("%s: %s\n", c == FOR ? "for" : "select",
d739 1
a739 1
	{ "select",	SELECT,	true },
d1008 58
@


1.51
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.50 2010/08/28 18:50:58 tg Exp $");
d234 2
a235 1
	iops = alloc((NUFILE + 1) * sizeof(struct ioword *), ATEMP);
d480 1
a480 1
		iops = aresize(iops, iopn * sizeof(struct ioword *), ATEMP);
d660 1
a660 1
		 * Probably something like foo() followed by eof or ;.
d666 1
@


1.50
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.49 2010/07/17 22:09:39 tg Exp $");
d743 1
a743 1
	{ "function",	FUNCTION, true },
d800 1
a800 1
		yyerror("%s: %s\n", T_synerr, "unexpected EOF");
@


1.49
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.48 2009/12/12 22:27:10 tg Exp $");
d184 1
a184 1
			yyerror("too many <<s\n");
d260 2
a261 1
						yyerror("too many redirections\n");
d407 2
a408 2
			yyerror("%s: bad identifier\n",
			    c == FOR ? "for" : "select");
d470 1
a470 1
			yyerror("too many redirections\n");
d626 1
a626 1
			yyerror("%s: invalid function name\n", sname);
d800 1
a800 1
		yyerror("%s: unexpected EOF\n", T_synerr);
d886 1
a886 1
	return ((strcmp(s, "alias") == 0) ||
@


1.48
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.47 2009/10/30 00:57:39 tg Exp $");
d53 1
a53 1
static int dbtestp_isa(Test_env *, Test_meta);
d920 2
a921 1
/* Test if the current token is a whatever. Accepts the current token if
d925 1
a925 1
static int
d931 1
a931 1
	int ret = 0;
d937 1
a937 1
		ret = c == LOGOR;
d939 1
a939 1
		ret = c == LOGAND;
d941 2
a942 1
		ret = uqword && strcmp(yylval.cp, dbtest_tokens[(int) TM_NOT]) == 0;
d944 1
a944 1
		ret = c == '(' /*)*/;
d946 1
a946 1
		ret = c == /*(*/ ')';
d950 1
a950 1
			ret = 1;
d956 3
a958 2
		ret = uqword && strcmp(yylval.cp, db_close) == 0;
	if (ret) {
@


1.47
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.46 2009/10/04 12:45:23 tg Exp $");
d48 1
a48 2
static void syntaxerr(const char *)
    __attribute__((noreturn));
d57 1
a57 2
static void dbtestp_error(Test_env *, int, const char *)
    __attribute__((noreturn));
d966 2
a967 1
dbtestp_getopnd(Test_env *te, Test_op op __unused, bool do_eval __unused)
d981 3
a983 3
dbtestp_eval(Test_env *te __unused, Test_op op __unused,
    const char *opnd1 __unused, const char *opnd2 __unused,
    bool do_eval __unused)
@


1.46
log
@fix long-standing parenthesēs problem: ((foo) || bar) is now parsed corr.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.45 2009/10/02 18:08:37 tg Exp $");
d622 2
a623 2
	 *	nul space nl tab $ ' " \ ` ( ) & | ; = < >
	 * C_QUOTE covers all but = and adds # [ ] ? *)
d626 1
a626 1
		if (ctype(*p, C_QUOTE) || *p == '=')
@


1.45
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.44 2009/09/26 03:40:02 tg Exp $");
d351 1
a352 1
	case '(':
d361 1
d366 1
d368 10
d379 1
a379 2
		t->lineno = source->line;
		ACCEPT;
a380 1
		musthave(LWORD,LETEXPR);
@


1.44
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.43 2009/09/23 18:04:58 tg Exp $");
d594 1
a594 1
	/* Note: Posix requires the ;; */
d609 1
a609 1
	/* Check for valid characters in name. posix and ksh93 say only
d679 1
a679 1
	/* Posix does not do alias expansion here... */
@


1.43
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.42 2009/09/19 18:36:59 tg Exp $");
d880 1
a880 1
	    (strcmp(s, "typeset") == 0));
@


1.42
log
@allow “function stop () {” (bashism, an evil one)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.41 2009/08/28 20:30:59 tg Exp $");
d292 1
d296 1
d306 1
d342 1
@


1.41
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.39 2009/08/28 18:54:00 tg Exp $");
d44 1
a44 1
static struct op *function_body(char *, int);
d598 1
a598 1
    int ksh_func)		/* function foo { ... } vs foo() { .. } */
a614 5
	t = newtp(TFUNCT);
	t->str = sname;
	t->u.ksh_func = ksh_func;
	t->lineno = source->line;

d621 11
d636 5
@


1.40
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d746 1
a746 1
			p = ktenter(&keywords, tt->name, hash(tt->name), NULL);
@


1.39
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.38 2009/06/11 12:42:20 tg Exp $");
d746 1
a746 1
			p = ktenter(&keywords, tt->name, hash(tt->name));
@


1.38
log
@capitalise AT&T®
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.37 2009/06/10 18:12:50 tg Exp $");
d699 1
a699 1
const	struct tokeninfo {
d701 2
a702 2
	short	val;
	short	reserved;
d742 2
a743 1
	ktinit(&keywords, APERM, 32); /* must be 2^n (currently 20 keywords) */
@


1.37
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.36 2009/06/08 20:06:49 tg Exp $");
d270 1
a270 1
				 * dubious but at&t ksh acts this way
d284 1
a284 1
				/* Check for "> foo (echo hi)" which at&t ksh
d621 2
a622 2
	 * at&t ksh allow any command, go with the later since it shouldn't
	 * break anything. However, for function foo, at&t ksh only accepts
d666 1
a666 1
		if (c != ';') /* non-POSIX, but at&t ksh accepts a ; here */
d846 1
a846 1
/* This kludge exists to take care of sh/at&t ksh oddity in which
d849 1
a849 1
 * at&t ksh seems to do something similar to this since
@


1.36
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.35 2009/05/16 16:59:41 tg Exp $");
d146 1
a146 1
				  p, NOBLOCK, NOWORDS);
d305 1
a305 1
			  {
d338 1
a338 1
			  }
d356 1
a356 2
	case MDPAREN:
	  {
d369 1
a369 1
	  }
d605 1
a605 1
	/* Check for valid characters in name.  posix and ksh93 say only
d609 1
a609 1
	 *  C_QUOTE covers all but = and adds # [ ] ? *)
d622 1
a622 1
	 * break anything.  However, for function foo, at&t ksh only accepts
d896 2
a897 2
/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
@


1.35
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.34 2009/04/07 19:13:11 tg Exp $");
d159 1
a159 1
	return t;
d194 1
a194 1
		nextiop = alloc(sizeof (*iop), ATEMP);
d236 1
a236 1
	iops = alloc((NUFILE + 1) * sizeof (struct ioword *), ATEMP);
d247 1
a247 1
		return NULL; /* empty line */
d467 1
a467 1
		iops = aresize(iops, iopn * sizeof (struct ioword *), ATEMP);
d481 1
a481 1
	return t;
d504 1
a504 1
	return list;
d541 1
a541 1
	return NULL;
d642 1
a642 1
		t->left->args = alloc(2 * sizeof (char *), ATEMP);
d648 1
a648 1
		t->left->vars = alloc(sizeof (char *), ATEMP);
d655 1
a655 1
	return t;
d669 1
a669 1
		return NULL;
d677 1
a677 1
		return NULL;
d680 1
a680 1
		return (char **) XPclose(args);
d825 1
a825 1
	t = alloc(sizeof (struct op), ATEMP);
d844 1
a844 1
	return outtree;
d861 2
a862 2
		return 0;
	return (strcmp(s, "alias") == 0) ||
d865 1
a865 1
	    (strcmp(s, "typeset") == 0);
d874 2
a875 2
			return 1;
	return 0;
d939 1
a939 1
	return ret;
d948 1
a948 1
		return NULL;
d953 1
a953 1
	return null;
d961 1
a961 1
	return 1;
@


1.34
log
@some int->bool, KNF, ...
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.33 2009/04/07 19:06:43 tg Exp $");
@


1.33
log
@tabs vs spaces
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.32 2008/12/13 17:02:17 tg Exp $");
d110 1
a110 2
	int c;
	int have_sep;
d147 1
a147 1
	int ishere;
d583 1
a583 1
	int old_func_parse;
@


1.32
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.31 2008/12/02 13:20:40 tg Exp $");
d47 4
a50 4
#define	REJECT		(reject = 1)
#define	ACCEPT		(reject = 0)
#define	token(cf)	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
#define	tpeek(cf)	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
@


1.31
log
@* sh.h: note that file descriptors SHALL be <100
* syn.c: fix bashiop-4 regression test; failed due to me using a
  simple string when a wdstring was expected, sorry; the new code
  assumes file descriptors take up a maximum of two characters
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.30 2008/11/12 00:54:51 tg Exp $");
d175 2
a176 2
		nextiop = alloc(1, sizeof (*iop), ATEMP);
		nextiop->name = cp = alloc(5, 1, ATEMP);
d217 1
a217 1
	iops = alloc(NUFILE + 1, sizeof (struct ioword *), ATEMP);
d424 1
a424 1
			t->str = alloc(1, 2, ATEMP);
d448 1
a448 1
		iops = aresize(iops, iopn, sizeof (struct ioword *), ATEMP);
d623 2
a624 2
		t->left->args = alloc(2, sizeof (char *), ATEMP);
		t->left->args[0] = tv = alloc(3, sizeof (char), ATEMP);
d629 1
a629 1
		t->left->vars = alloc(1, sizeof (char *), ATEMP);
d806 1
a806 1
	t = alloc(1, sizeof (struct op), ATEMP);
@


1.30
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.29 2008/11/09 19:48:02 tg Exp $");
d173 2
d176 9
a188 1
		nextiop->name = shf_smprintf("%d", iop->unit);
@


1.30.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.30 2008/11/12 00:54:51 tg Exp $");
d173 1
a173 1
		nextiop = galloc(1, sizeof (struct ioword), ATEMP);
d207 1
a207 1
	iops = galloc(NUFILE + 1, sizeof (struct ioword *), ATEMP);
d215 1
a215 1
		gfree(iops, ATEMP);
d258 1
a258 1
				gfree(t, ATEMP);
d414 1
a414 1
			t->str = galloc(1, 2, ATEMP);
d434 1
a434 1
		gfree(iops, ATEMP);
d438 1
a438 1
		iops = grealloc(iops, iopn, sizeof (struct ioword *), ATEMP);
d613 2
a614 2
		t->left->args = galloc(2, sizeof (char *), ATEMP);
		t->left->args[0] = tv = galloc(3, sizeof (char), ATEMP);
d619 1
a619 1
		t->left->vars = galloc(1, sizeof (char *), ATEMP);
d796 1
a796 1
	t = galloc(1, sizeof (struct op), ATEMP);
@


1.29
log
@remove dead nested assignment, result from first llvm+clang scan-build
run native on mirbsd
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.28 2008/10/28 14:32:43 tg Exp $");
d173 1
a173 1
		nextiop = (struct ioword *)alloc(sizeof (*iop), ATEMP);
d207 1
a207 2
	iops = (struct ioword **)alloc(sizeofN(struct ioword *, NUFILE+1),
	    ATEMP);
d215 1
a215 1
		afree((void*) iops, ATEMP);
d414 1
a414 1
			t->str = alloc(2, ATEMP);
d434 1
a434 1
		afree((void*)iops, ATEMP);
d438 1
a438 2
		iops = (struct ioword **) aresize((void*) iops,
		    sizeofN(struct ioword *, iopn), ATEMP);
d613 2
a614 3
		t->left->args = (const char **)alloc(sizeof (char *) * 2,
		    ATEMP);
		t->left->args[0] = tv = alloc(sizeof (char) * 3, ATEMP);
d619 1
a619 1
		t->left->vars = (char **)alloc(sizeof (char *), ATEMP);
d796 1
a796 1
	t = (struct op *)alloc(sizeof (*t), ATEMP);
@


1.28
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.27 2008/10/10 21:30:43 tg Exp $");
a546 1
	int c;
d551 2
a552 2
	c = token(CONTIN|KEYWORD); /* no ALIAS here */
	if (c != '(')
d557 1
a557 1
	} while ((c = token(0)) == '|');
@


1.27
log
@fix prodded by cnuke@@ for AIX with IBM xlC 7.0:
fool the compiler into not doing static bounds checking when we do
one-past-the-array-boundary pointer assignments for cases where the
only accesses are like (*--pointer); bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.26 2008/08/02 17:45:12 tg Exp $");
d369 1
a369 1
		t->str = str_save_(ident, ATEMP);
@


1.26
log
@• merge final version of the stack-free diff as committed by jaredy@@openbsd
  thanks for helping with the bug
• merge RCS IDs
• bump mksh version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.25 2008/07/18 11:33:13 tg Exp $");
d166 1
a166 1
		if (herep >= &heres[HERES])
@


1.25
log
@fixes for constant conditionals, from gcc-4.2 fat binary building
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.27 2006/04/10 14:38:59 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.24 2008/07/14 12:29:06 tg Exp $");
d416 1
a416 1
			t->str[0] = 0;	/* TF_* flags */
@


1.24
log
@fix attempt to free pointer to stack (function-local storage)
discovered by Elias Pipping
patch by Jared Yanovich
alloc/afree checker by Todd C. Miller
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.23 2008/07/12 16:56:40 tg Exp $");
d369 1
a369 1
		t->str = str_save(ident, ATEMP);
@


1.23
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.22 2008/06/28 22:51:56 tg Exp $");
d414 5
@


1.22
log
@• add code to support GNU bash’s “&> file” I/O redirection extension,
  and make it fit into mksh’s model (also gives us a couple of things
  GNU bash doesn’t have
• add regression tests for all of these

Lukas “smultron” Upton from MidnightBSD spotted a script with /bin/sh
shebang invalidly using “&>” in some Apple backup toolkit, 10x

XXX why fds are limited to one digit?
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.21 2008/05/17 18:47:02 tg Exp $");
d369 1
a369 1
		t->str = str_nsave(ident, strlen(ident), ATEMP);
@


1.21
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.20 2008/04/01 22:20:20 tg Exp $");
d147 1
d150 6
d157 1
a157 1
		return NULL;
d171 12
a182 1
	return iop;
d232 5
a236 3
				if (iopn >= NUFILE)
					yyerror("too many redirections\n");
				iops[iopn++] = synio(cf);
@


1.20
log
@some more code “folding”
should decrease size
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.19 2008/03/01 21:10:26 tg Exp $");
d189 1
a189 1
	iops = (struct ioword **) alloc(sizeofN(struct ioword *, NUFILE+1),
d591 3
a593 2
		t->left->args = (const char **)alloc(sizeof(char *) * 2, ATEMP);
		t->left->args[0] = tv = alloc(sizeof(char) * 3, ATEMP);
d598 1
a598 1
		t->left->vars = (char **)alloc(sizeof(char *), ATEMP);
d775 1
a775 1
	t = (struct op *)alloc(sizeof(*t), ATEMP);
@


1.19
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.18 2007/10/25 15:34:30 tg Exp $");
d35 1
a35 1
static const char *dbtestp_getopnd(Test_env *, Test_op, int);
d37 1
a37 1
    const char *, int);
d892 1
a892 1
dbtestp_getopnd(Test_env *te, Test_op op __unused, int do_eval __unused)
d908 1
a908 1
    int do_eval __unused)
@


1.19.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.20 2008/04/01 22:20:20 tg Exp $");
d35 1
a35 1
static const char *dbtestp_getopnd(Test_env *, Test_op, bool);
d37 1
a37 1
    const char *, bool);
d892 1
a892 1
dbtestp_getopnd(Test_env *te, Test_op op __unused, bool do_eval __unused)
d908 1
a908 1
    bool do_eval __unused)
@


1.19.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.21 2008/05/17 18:47:02 tg Exp $");
d189 1
a189 1
	iops = (struct ioword **)alloc(sizeofN(struct ioword *, NUFILE+1),
d591 2
a592 3
		t->left->args = (const char **)alloc(sizeof (char *) * 2,
		    ATEMP);
		t->left->args[0] = tv = alloc(sizeof (char) * 3, ATEMP);
d597 1
a597 1
		t->left->vars = (char **)alloc(sizeof (char *), ATEMP);
d774 1
a774 1
	t = (struct op *)alloc(sizeof (*t), ATEMP);
@


1.19.2.3
log
@MFC: mksh R35
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.22 2008/06/28 22:51:56 tg Exp $");
a146 1
	static struct ioword *nextiop = NULL;
a148 6
	if (nextiop != NULL) {
		iop = nextiop;
		nextiop = NULL;
		return (iop);
	}

d150 1
a150 1
		return (NULL);
d164 1
a164 12

	if (iop->flag & IOBASH) {
		nextiop = (struct ioword *)alloc(sizeof (*iop), ATEMP);

		iop->flag &= ~IOBASH;
		nextiop->unit = 2;
		nextiop->flag = IODUP;
		nextiop->name = shf_smprintf("%d", iop->unit);
		nextiop->delim = NULL;
		nextiop->heredoc = NULL;
	}
	return (iop);
d214 3
a216 5
				while ((iop = synio(cf)) != NULL) {
					if (iopn >= NUFILE)
						yyerror("too many redirections\n");
					iops[iopn++] = iop;
				}
@


1.19.2.4
log
@MFC: mksh R35b
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d369 1
a369 1
		t->str = str_save_(ident, ATEMP);
a413 5
		if (t) {
			t->str = alloc(2, ATEMP);
			t->str[0] = 0;	/* TF_* flags */
			t->str[1] = '\0';
		}
@


1.19.2.5
log
@MFC: mksh R36b
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.28 2008/07/23 16:34:38 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.32 2008/12/13 17:02:17 tg Exp $");
d166 1
a166 1
		if (herep > &heres[HERES - 1])
d173 1
a173 12
		char *cp;

		nextiop = alloc(sizeof (*iop), ATEMP);
		nextiop->name = cp = alloc(5, ATEMP);

		if (iop->unit > 9) {
			*cp++ = CHAR;
			*cp++ = '0' + (iop->unit / 10);
		}
		*cp++ = CHAR;
		*cp++ = '0' + (iop->unit % 10);
		*cp = EOS;
d178 1
d207 2
a208 1
	iops = alloc((NUFILE + 1) * sizeof (struct ioword *), ATEMP);
d216 1
a216 1
		afree(iops, ATEMP);
d369 1
a369 1
		strdupx(t->str, ident, ATEMP);
d416 1
a416 1
			t->str[0] = '\0';	/* TF_* flags */
d435 1
a435 1
		afree(iops, ATEMP);
d439 2
a440 1
		iops = aresize(iops, iopn * sizeof (struct ioword *), ATEMP);
d547 1
d552 2
a553 2
	/* no ALIAS here */
	if (token(CONTIN | KEYWORD) != '(')
d558 1
a558 1
	} while (token(0) == '|');
d616 3
a618 2
		t->left->args = alloc(2 * sizeof (char *), ATEMP);
		t->left->args[0] = tv = alloc(3, ATEMP);
d623 1
a623 1
		t->left->vars = alloc(sizeof (char *), ATEMP);
d800 1
a800 1
	t = alloc(sizeof (struct op), ATEMP);
@


1.18
log
@optimise more :)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.17 2007/08/19 23:12:23 tg Exp $");
d554 1
a554 1
	sname = wdstrip(name);
@


1.17
log
@employ string pooling techniques to save off a few more bytes
(probably more than the new “rename” builtin ever required…)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.16 2007/07/01 21:10:29 tg Exp $");
a16 1
static void musthave(int, int);
d51 1
a166 7
static void
musthave(int c, int cf)
{
	if ((token(cf)) != c)
		syntaxerr(NULL);
}

@


1.16
log
@Borland C++ found these
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.15 2007/06/22 23:34:42 tg Exp $");
d732 1
a732 1
		yyerror("syntax error: unexpected EOF\n");
d759 1
a759 1
	yyerror("syntax error: '%s' %s\n", s, what);
@


1.15
log
@implement bash-style array initialisation, as requested by many
still experimental
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.14 2007/06/06 23:28:17 tg Exp $");
d861 1
a861 1
	int uqword = 0;
@


1.14
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.13 2007/05/13 19:00:30 tg Exp $");
d251 3
d263 35
@


1.13
log
@Fix for Coverity CID#10: out-of-bounds array access
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.12 2007/03/04 03:04:28 tg Exp $");
d318 1
a318 1
		t->str = str_save(ident, ATEMP);
@


1.12
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.11 2007/03/04 00:13:17 tg Exp $");
d852 3
a854 3
		if (meta != TM_END) {
			if (!save)
				save = wdcopy(dbtest_tokens[(int) meta], ATEMP);
a855 1
		}
@


1.12.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.12 2007/03/04 03:04:28 tg Exp $");
d852 3
a854 3
		if (meta < NELEM(dbtest_tokens))
			save = wdcopy(dbtest_tokens[(int)meta], ATEMP);
		if (save)
d856 1
@


1.12.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.12.2.1 2007/05/13 19:29:40 tg Exp $");
d318 1
a318 1
		t->str = str_nsave(ident, strlen(ident), ATEMP);
d823 1
a823 1
	int uqword;
@


1.11
log
@merge the const branch +- a few
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d8 2
a9 2
	int	start_token;	/* token than began nesting (eg, FOR) */
	int	start_line;	/* line nesting began on */
@


1.10
log
@* support old environments without libgen.h (ancient GNU/Linux)
  and stdbool.h (ancient GNU/Linux; NetBSD® 1.6.1)
* __dead must come after, not before, to accomodate gcc 2.7.2.3
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.9 2007/01/12 01:49:29 tg Exp $");
d379 1
a379 1
		afree((void*) iops, ATEMP);
d390 1
a390 1
		t->args = (char **) XPclose(args);
d552 1
d560 5
a564 5
		t->left->args = (char **) alloc(sizeof(char *) * 2, ATEMP);
		t->left->args[0] = alloc(sizeof(char) * 3, ATEMP);
		t->left->args[0][0] = CHAR;
		t->left->args[0][1] = ':';
		t->left->args[0][2] = EOS;
d566 1
a566 1
		t->left->vars = (char **) alloc(sizeof(char *), ATEMP);
d743 1
a743 1
	t = (struct op *) alloc(sizeof(*t), ATEMP);
d746 2
a747 1
	t->args = t->vars = NULL;
@


1.9
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.8 2006/08/01 13:43:28 tg Exp $");
d29 2
a30 1
static __dead void syntaxerr(const char *);
d39 2
a40 1
static __dead void dbtestp_error(Test_env *, int, const char *);
@


1.9.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.10 2007/01/17 22:51:47 tg Exp $");
d29 1
a29 2
static void syntaxerr(const char *)
    __attribute__((noreturn));
d38 1
a38 2
static void dbtestp_error(Test_env *, int, const char *)
    __attribute__((noreturn));
@


1.9.2.2
log
@finish constification for now, passes regression tests but untested
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.9.2.1 2007/03/03 21:38:00 tg Exp $");
d390 1
a390 1
		t->args = (const char **) XPclose(args);
a551 1
		char *tv;
d559 5
a563 5
		t->left->args = (const char **)alloc(sizeof(char *) * 2, ATEMP);
		t->left->args[0] = tv = alloc(sizeof(char) * 3, ATEMP);
		tv[0] = CHAR;
		tv[1] = ':';
		tv[2] = EOS;
d742 1
a742 1
	t = (struct op *)alloc(sizeof(*t), ATEMP);
d745 1
a745 2
	t->args = NULL;
	t->vars = NULL;
@


1.8
log
@style(9)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.7 2006/05/10 18:54:13 tg Exp $");
d12 1
a12 1
static void	yyparse(void);
d17 1
a17 1
static void	musthave(int, int);
d26 1
a26 1
static char **	wordlist(void);
d29 6
a34 6
static void	syntaxerr(const char *) __attribute__((__noreturn__));
static void	nesting_push(struct nesting_state *, int);
static void	nesting_pop(struct nesting_state *);
static int	assign_command(char *);
static int	inalias(struct source *);
static int	dbtestp_isa(Test_env *, Test_meta);
d36 1
a36 1
static int	dbtestp_eval(Test_env *, Test_op, const char *,
d38 1
a38 4
static void dbtestp_error(Test_env *, int, const char *)
    __attribute__((noreturn));

static	struct	op	*outtree; /* yyparse output */
d40 1
d43 2
a44 2
static	int	reject;		/* token(cf) gets symbol again */
static	int	symbol;		/* yylex value */
d46 4
a49 6
#define	REJECT	(reject = 1)
#define	ACCEPT	(reject = 0)
#define	token(cf) \
	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
#define	tpeek(cf) \
	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
d858 1
a858 2
dbtestp_getopnd(Test_env *te, Test_op op __attribute__((unused)),
    int do_eval __attribute__((unused)))
d872 3
a874 5
dbtestp_eval(Test_env *te __attribute__((unused)),
    Test_op op __attribute__((unused)),
    const char *opnd1 __attribute__((unused)),
    const char *opnd2 __attribute__((unused)),
    int do_eval __attribute__((unused)))
@


1.7
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.6 2006/01/30 12:37:24 tg Exp $");
d267 1
a267 1
	  Leave:
d270 1
a270 1
	  Subshell:
d685 1
a685 1
    Again:
@


1.6
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.23 2005/12/11 20:31:21 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.5 2006/01/29 20:04:53 tg Exp $");
d696 1
a696 1
		/*NOTREACHED*/
a777 2
	char c = *s;

d780 4
a783 4
	return (c == 'a' && strcmp(s, "alias") == 0) ||
	    (c == 'e' && strcmp(s, "export") == 0) ||
	    (c == 'r' && strcmp(s, "readonly") == 0) ||
	    (c == 't' && strcmp(s, "typeset") == 0);
@


1.5
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.4 2005/11/22 18:40:44 tg Exp $");
d245 1
a245 1
				/* Check for "> foo (echo hi)", which at&t ksh
@


1.4
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: syn.c,v 1.22 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.3 2005/10/08 19:31:00 tg Exp $");
d662 1
a662 1
	tinit(&keywords, APERM, 32); /* must be 2^n (currently 20 keywords) */
d665 1
a665 1
			p = tenter(&keywords, tt->name, hash(tt->name));
@


1.3
log
@our test(1) promises we can do string1 < string2, and
our /bin/test uses mksh... so we pee (literally) on
POSIX and don't accept < and > only for [[ ... ]] operator
@
text
@a0 1
/**	$MirOS: src/bin/mksh/syn.c,v 1.2 2005/07/04 12:27:28 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.2 2005/07/04 12:27:28 tg Exp $");
@


1.2
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/syn.c,v 1.1 2005/05/23 03:06:10 tg Exp $ */
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.1 2005/05/23 03:06:10 tg Exp $");
d849 1
a849 1
		} else if (uqword && (ret = test_isop(te, meta, ident)))
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/syn.c,v 1.8 2005/05/23 02:20:36 tg Exp $ */
d6 1
a6 1
__RCSID("$MirOS: mksh/syn.c,v 1.8 2005/05/23 02:20:36 tg Exp $");
d781 1
a781 1
	if (Flag(FPOSIX) || !*s)
@

