head	1.124;
access;
symbols
	mksh-R57:1.121
	mksh-R56c:1.121
	mksh-R56b:1.121
	mksh-R56:1.121
	mksh-R55:1.114
	mksh-R54:1.108
	mksh-R53a:1.108
	mksh-R53:1.108
	mksh-R52c:1.104
	mksh-R52b:1.104
	mksh-R52:1.103
	mksh-R51:1.100
	mksh-R50f:1.89.2.3
	mksh-R50e:1.89.2.1
	mksh-R50stable:1.89.0.2
	mksh-R50d:1.89
	mksh-R50c:1.89
	mksh-R50b:1.89
	mksh-R50:1.88
	mksh-R49:1.88
	mksh-R48b:1.84
	mksh-R48:1.84
	mksh-R47:1.82
	mksh-R46:1.82
	mksh-R45:1.79
	mksh-R44:1.77
	mksh-R43:1.77
	mksh-R42b:1.76
	mksh-R41c:1.72
	mksh-R41b:1.72
	mksh-R42:1.76
	mksh-R41:1.72
	mksh-R41stable:1.72.0.2
	mksh-wheezy:1.69.0.6
	tg-multikey-bind:1.69.0.2
	mksh-R40f:1.69
	mksh-R40e:1.69
	mksh-R40d:1.68
	mksh-R40c:1.65
	mksh-R40b:1.63
	mksh-R40stable:1.69.0.4
	mksh-R40:1.60
	mksh-R39c:1.54
	mksh-R39b:1.53
	tg-wcswidth-behaviour:1.51.0.2
	tg-nameref:1.49.0.2
	mksh-R39:1.45
	tg-mksh-printf-builtin:1.45.0.2
	mksh-R38c:1.43
	mksh-R38b:1.43
	mksh-R38:1.42
	mksh-R37c:1.41
	mksh-R37b:1.41
	mksh-R37:1.40
	mksh-R36b:1.39
	mksh-R36:1.37
	mksh-R35b:1.37
	mksh-R35:1.37
	mksh-R33d:1.31
	mksh-R33c:1.30
	mksh-R33b:1.30
	MIRBSD_10:1.30.0.2
	MIRBSD_10_BASE:1.30
	mksh-R33:1.28
	mksh-R32:1.24
	mksh-R31d:1.23
	mksh-R31c:1.19
	mksh-R31b:1.19
	mksh-R31:1.19
	mksh-R30:1.18
	mksh-R29g:1.17
	mksh-R29f:1.15
	mksh-R29e:1.14
	mksh-R29stable:1.14.0.2
	mksh-R29d:1.12
	mksh-R29c:1.12
	mksh-R29b:1.8
	mksh-R29:1.8
	mksh-R28:1.3
	tg-mksh-plan9ape_BASE:1.3
	tg-mksh-plan9ape:1.2.0.2;
locks; strict;
comment	@# @;


1.124
date	2019.09.25.22.50.11;	author tg;	state Exp;
branches;
next	1.123;
commitid	1005D8BEF206C7DCA5F;

1.123
date	2019.08.03.20.25.37;	author tg;	state Exp;
branches;
next	1.122;
commitid	1005D45ED80534CEB9D;

1.122
date	2019.08.03.20.19.33;	author tg;	state Exp;
branches;
next	1.121;
commitid	1005D45EC5231708970;

1.121
date	2017.08.08.21.10.21;	author tg;	state Exp;
branches;
next	1.120;
commitid	100598A288543F52A67;

1.120
date	2017.08.08.20.52.11;	author tg;	state Exp;
branches;
next	1.119;
commitid	100598A248125C7B3E0;

1.119
date	2017.08.08.20.50.34;	author tg;	state Exp;
branches;
next	1.118;
commitid	100598A24322B923A46;

1.118
date	2017.08.08.20.42.16;	author tg;	state Exp;
branches;
next	1.117;
commitid	100598A223A03DD1043;

1.117
date	2017.08.08.20.40.25;	author tg;	state Exp;
branches;
next	1.116;
commitid	100598A21CF483F0CE4;

1.116
date	2017.08.08.20.38.08;	author tg;	state Exp;
branches;
next	1.115;
commitid	100598A213D40A419D8;

1.115
date	2017.08.08.20.22.16;	author tg;	state Exp;
branches;
next	1.114;
commitid	100598A1D8C5276D7AE;

1.114
date	2017.03.19.22.31.26;	author tg;	state Exp;
branches;
next	1.113;
commitid	10058CF06C37397F386;

1.113
date	2017.03.19.21.08.25;	author tg;	state Exp;
branches;
next	1.112;
commitid	10058CEF343747BFA96;

1.112
date	2017.03.19.20.59.25;	author tg;	state Exp;
branches;
next	1.111;
commitid	10058CEF1322163CCA4;

1.111
date	2017.03.19.20.36.07;	author tg;	state Exp;
branches;
next	1.110;
commitid	10058CEEBC01764DE9F;

1.110
date	2017.02.18.02.37.57;	author tg;	state Exp;
branches;
next	1.109;
commitid	10058A7B3974FD1FF6B;

1.109
date	2017.02.18.02.33.11;	author tg;	state Exp;
branches;
next	1.108;
commitid	10058A7B271530B4CED;

1.108
date	2016.07.26.22.03.41;	author tg;	state Exp;
branches;
next	1.107;
commitid	1005797DE4D3669D6DD;

1.107
date	2016.07.25.20.41.23;	author tg;	state Exp;
branches;
next	1.106;
commitid	1005796798377E704E1;

1.106
date	2016.07.24.23.05.51;	author tg;	state Exp;
branches;
next	1.105;
commitid	100579549C8761C6547;

1.105
date	2016.04.09.16.33.23;	author tg;	state Exp;
branches;
next	1.104;
commitid	10057092EED65C454B9;

1.104
date	2015.12.31.21.00.12;	author tg;	state Exp;
branches;
next	1.103;
commitid	1005685975F58C0A82A;

1.103
date	2015.12.12.18.47.40;	author tg;	state Exp;
branches;
next	1.102;
commitid	100566C6BDF4E01DAA1;

1.102
date	2015.10.09.21.36.54;	author tg;	state Exp;
branches;
next	1.101;
commitid	100561833456A230F8F;

1.101
date	2015.07.18.23.03.24;	author tg;	state Exp;
branches;
next	1.100;
commitid	10055AADB4B4CB0CC50;

1.100
date	2015.07.10.19.36.33;	author tg;	state Exp;
branches;
next	1.99;
commitid	10055A01EBD784EE31A;

1.99
date	2015.07.05.19.02.16;	author tg;	state Exp;
branches;
next	1.98;
commitid	10055997F3E3CFFC30D;

1.98
date	2015.06.27.20.44.01;	author tg;	state Exp;
branches;
next	1.97;
commitid	100558F0B1A5F5D36F4;

1.97
date	2015.04.29.20.56.18;	author tg;	state Exp;
branches;
next	1.96;
commitid	1005541458860861272;

1.96
date	2015.04.11.19.01.59;	author tg;	state Exp;
branches;
next	1.95;
commitid	10055296FA47BACAEE8;

1.95
date	2015.04.11.18.08.56;	author tg;	state Exp;
branches;
next	1.94;
commitid	1005529621266CFBE99;

1.94
date	2015.03.14.05.23.14;	author tg;	state Exp;
branches;
next	1.93;
commitid	1005503C5CA29059CD3;

1.93
date	2015.03.08.23.50.00;	author tg;	state Exp;
branches;
next	1.92;
commitid	10054FCE029526C35A5;

1.92
date	2015.03.08.22.54.33;	author tg;	state Exp;
branches;
next	1.91;
commitid	10054FCD1444FC13F3C;

1.91
date	2015.01.11.00.23.06;	author tg;	state Exp;
branches;
next	1.90;
commitid	10054B1C263136FD7D2;

1.90
date	2015.01.06.20.54.53;	author tg;	state Exp;
branches;
next	1.89;
commitid	10054AC4B920847DDCC;

1.89
date	2014.07.28.21.45.44;	author tg;	state Exp;
branches
	1.89.2.1;
next	1.88;
commitid	10053D6C428265C691A;

1.88
date	2014.01.11.18.09.39;	author tg;	state Exp;
branches;
next	1.87;
commitid	10052D188DD7DFEC194;

1.87
date	2014.01.05.22.17.57;	author tg;	state Exp;
branches;
next	1.86;
commitid	10052C9DA18792117FE;

1.86
date	2014.01.02.22.51.01;	author tg;	state Exp;
branches;
next	1.85;
commitid	10052C5ED114C2BC527;

1.85
date	2013.08.22.13.46.46;	author tg;	state Exp;
branches;
next	1.84;
commitid	1005216163D137C7F7B;

1.84
date	2013.08.10.13.43.50;	author tg;	state Exp;
branches;
next	1.83;
commitid	100520643AE565345EB;

1.83
date	2013.07.25.14.02.02;	author tg;	state Exp;
branches;
next	1.82;
commitid	10051F12FE7184EE85D;

1.82
date	2013.05.02.21.59.48;	author tg;	state Exp;
branches;
next	1.81;
commitid	1005182E1E55272FF6B;

1.81
date	2013.05.02.21.46.29;	author tg;	state Exp;
branches;
next	1.80;
commitid	1005182DEC5602A93C0;

1.80
date	2013.04.27.18.19.44;	author tg;	state Exp;
branches;
next	1.79;
commitid	100517C16D15DD801CB;

1.79
date	2013.04.05.15.39.52;	author tg;	state Exp;
branches;
next	1.78;
commitid	100515EEFE12B128AFC;

1.78
date	2013.03.24.15.01.35;	author tg;	state Exp;
branches;
next	1.77;
commitid	100514F15672AC17B45;

1.77
date	2013.02.17.15.58.26;	author tg;	state Exp;
branches;
next	1.76;
commitid	1005120FE31433E1EEF;

1.76
date	2013.02.10.23.30.47;	author tg;	state Exp;
branches;
next	1.75;
commitid	10051182DAC7194E766;

1.75
date	2013.02.10.19.04.00;	author tg;	state Exp;
branches;
next	1.74;
commitid	1005117EF1D3942ADA8;

1.74
date	2013.01.21.15.06.24;	author tg;	state Exp;
branches;
next	1.73;
commitid	10050FD598456B412C2;

1.73
date	2012.11.30.20.19.10;	author tg;	state Exp;
branches;
next	1.72;
commitid	10050B914D41435E735;

1.72
date	2012.10.30.21.04.56;	author tg;	state Exp;
branches;
next	1.71;
commitid	1005090411125943871;

1.71
date	2012.08.17.18.34.20;	author tg;	state Exp;
branches;
next	1.70;
commitid	100502E8EAA4BFCF410;

1.70
date	2012.07.30.21.37.10;	author tg;	state Exp;
branches;
next	1.69;
commitid	1005016FE9B27F9F4DC;

1.69
date	2011.12.31.01.07.19;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004EFE605E4187686D;

1.68
date	2011.11.25.23.58.04;	author tg;	state Exp;
branches;
next	1.67;
commitid	1004ED02B9A2BD8727E;

1.67
date	2011.11.25.23.54.06;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004ED02A98536625BD;

1.66
date	2011.11.25.23.43.59;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004ED0283834F541B2;

1.65
date	2011.08.27.18.06.40;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004E5932432420AA61;

1.64
date	2011.07.18.00.35.45;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004E237FF1656D5846;

1.63
date	2011.07.06.22.21.56;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004E14E010182825E7;

1.62
date	2011.07.05.20.19.17;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004E1371A20E4D9A36;

1.61
date	2011.07.03.23.26.47;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004E10FACB14E140DE;

1.60
date	2011.05.29.02.18.49;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004DE1AD11046BEFFC;

1.59
date	2011.02.09.19.32.35;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004D52EBEB51A34FDE;

1.58
date	2011.02.02.22.48.15;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004D49DF45132FB4C9;

1.57
date	2010.11.26.21.08.54;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004CF021B158129152;

1.56
date	2010.07.11.13.54.37;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004C39CD2D3A32A01C;

1.55
date	2010.07.04.17.35.16;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004C30C668477089A5;

1.54
date	2010.02.25.20.48.10;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004B86E214711DD972;

1.53
date	2010.01.25.14.29.34;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004B5DAAE04C4182B3;

1.52
date	2009.12.12.22.27.14;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004B2418D91FC74F3D;

1.51
date	2009.11.03.17.58.44;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004AF06F353A97CB93;

1.50
date	2009.11.02.18.47.02;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004AEF29334F89DFA8;

1.49
date	2009.08.27.16.52.12;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004A96B9CD5362B588;

1.48
date	2009.08.27.16.40.08;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004A96B6C04A262C1B;

1.47
date	2009.08.27.16.29.21;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004A96B4395A34326C;

1.46
date	2009.08.27.16.03.52;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004A96AE7078339544;

1.45
date	2009.06.22.17.38.39;	author tg;	state Rel;
branches;
next	1.44;
commitid	1004A3FC0F26C661DC0;

1.44
date	2009.06.22.17.27.22;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004A3FBF0C1D9AD40F;

1.43
date	2009.05.31.17.17.33;	author tg;	state Rel;
branches;
next	1.42;
commitid	1004A22BBBB4559302F;

1.42
date	2009.05.16.16.59.33;	author tg;	state Rel;
branches;
next	1.41;
commitid	1004A0EF0664EF4168D;

1.41
date	2009.04.05.12.42.34;	author tg;	state Rel;
branches;
next	1.40;
commitid	10049D8A75131B713FD;

1.40
date	2008.12.29.21.34.19;	author tg;	state Rel;
branches;
next	1.39;
commitid	10049594263416D2C1C;

1.39
date	2008.12.13.17.09.45;	author tg;	state Rel;
branches;
next	1.38;
commitid	1004943EC66171C53D6;

1.38
date	2008.11.07.20.07.10;	author tg;	state Stab;
branches;
next	1.37;
commitid	10049149FF52ECF4D89;

1.37
date	2008.05.17.18.27.55;	author tg;	state Exp;
branches;
next	1.36;
commitid	100482F238341D5E08C;

1.36
date	2008.05.16.22.22.11;	author tg;	state Exp;
branches;
next	1.35;
commitid	100482E08FA02EE0A39;

1.35
date	2008.05.16.22.19.11;	author tg;	state Exp;
branches;
next	1.34;
commitid	100482E08614BA02E0B;

1.34
date	2008.05.15.15.24.09;	author tg;	state Exp;
branches;
next	1.33;
commitid	100482C558039271D26;

1.33
date	2008.04.22.13.48.15;	author tg;	state Rel;
branches;
next	1.32;
commitid	100480DEC3245D8280A;

1.32
date	2008.04.19.22.03.19;	author tg;	state Stab;
branches;
next	1.31;
commitid	100480A6C2D2168D617;

1.31
date	2008.04.11.20.14.02;	author tg;	state Rel;
branches;
next	1.30;
commitid	10047FFC675649362F0;

1.30
date	2008.03.03.20.22.37;	author tg;	state Stab;
branches
	1.30.2.1;
next	1.29;
commitid	10047CC5DFF4CF20F63;

1.29
date	2008.03.03.18.44.32;	author tg;	state Stab;
branches;
next	1.28;
commitid	10047CC47265340F959;

1.28
date	2008.03.01.21.24.58;	author tg;	state Rel;
branches;
next	1.27;
commitid	10047C9C9B76D05CEA1;

1.27
date	2008.03.01.16.35.30;	author tg;	state Exp;
branches;
next	1.26;
commitid	10047C985D16FC62D5B;

1.26
date	2008.02.29.16.38.41;	author tg;	state Stab;
branches;
next	1.25;
commitid	10047C8350F6BECB74A;

1.25
date	2008.02.29.11.48.32;	author tg;	state Exp;
branches;
next	1.24;
commitid	10047C7F11E25C9D944;

1.24
date	2007.10.25.14.54.00;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004720AE1D08C3933F;

1.23
date	2007.10.02.01.03.12;	author tg;	state Stab;
branches;
next	1.22;
commitid	100470198DF52617F70;

1.22
date	2007.09.25.22.36.36;	author tg;	state Stab;
branches;
next	1.21;
commitid	10046F98D423ED15913;

1.21
date	2007.09.25.15.48.45;	author tg;	state Stab;
branches;
next	1.20;
commitid	10046F92DD86D093288;

1.20
date	2007.09.24.20.30.04;	author tg;	state Exp;
branches;
next	1.19;
commitid	10046F81E1517454074;

1.19
date	2007.09.03.09.25.05;	author tg;	state Rel;
branches;
next	1.18;
commitid	10046DBD2FA09A5877F;

1.18
date	2007.07.26.13.37.21;	author tg;	state Rel;
branches;
next	1.17;
commitid	10046A8A39C7DAFF91C;

1.17
date	2007.06.20.13.38.18;	author tg;	state Exp;
branches;
next	1.16;
commitid	10046792DCD02B9583A;

1.16
date	2007.06.15.22.00.00;	author tg;	state Rel;
branches;
next	1.15;
commitid	10046730BC105D2123A;

1.15
date	2007.05.25.13.51.42;	author tg;	state Rel;
branches;
next	1.14;
commitid	1004656EA04527B6E5B;

1.14
date	2007.05.19.16.35.02;	author tg;	state Rel;
branches;
next	1.13;
commitid	100464F271F360538E3;

1.13
date	2007.05.19.16.33.10;	author tg;	state Exp;
branches;
next	1.12;
commitid	100464F26B07606E535;

1.12
date	2007.04.17.20.07.09;	author tg;	state Rel;
branches;
next	1.11;
commitid	100462528E62B0BF33B;

1.11
date	2007.04.17.20.04.08;	author tg;	state Exp;
branches;
next	1.10;
commitid	100462527BF45B87F5C;

1.10
date	2007.04.17.20.00.37;	author tg;	state Exp;
branches;
next	1.9;
commitid	100462527702D260A9A;

1.9
date	2007.04.16.18.54.37;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004623C5744FDC6F8B;

1.8
date	2007.03.04.06.20.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045EA654C48AFD64A;

1.7
date	2007.03.04.03.04.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045EA374B3374AB35;

1.6
date	2007.02.17.06.34.46;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045D6A20C36032D06;

1.5
date	2007.02.17.06.04.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D69AE435FA84D2;

1.4
date	2007.01.04.23.40.50;	author tg;	state Exp;
branches
	1.4.2.1;
next	1.3;
commitid	100459D905F4483C438;

1.3
date	2006.08.28.01.34.47;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044F248451527CD89;

1.2
date	2006.08.14.20.32.44;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10044E0DDB73A5BD9FD;

1.1
date	2006.07.23.18.44.22;	author tg;	state Exp;
branches;
next	;
commitid	10044C3C31D4538E6DA;

1.89.2.1
date	2015.01.11.22.39.44;	author tg;	state Exp;
branches;
next	1.89.2.2;
commitid	10054B2FBC1440F88AD;

1.89.2.2
date	2015.03.20.22.20.58;	author tg;	state Exp;
branches;
next	1.89.2.3;
commitid	100550C9D521FCB4274;

1.89.2.3
date	2015.04.12.22.32.22;	author tg;	state Exp;
branches;
next	;
commitid	100552AF26A429AA816;

1.30.2.1
date	2008.04.22.13.29.23;	author tg;	state Exp;
branches;
next	1.30.2.2;
commitid	100480DE80F32BAA72D;

1.30.2.2
date	2008.05.19.18.41.18;	author tg;	state Exp;
branches;
next	1.30.2.3;
commitid	1004831C9A63DA06745;

1.30.2.3
date	2008.12.14.00.07.36;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.4.2.1
date	2007.03.03.21.37.52;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;

1.2.2.1
date	2006.08.28.01.49.15;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.124
log
@offer more C.UTF-8 (cf. Debian #609306) choice; drop LTO-specific paragraph
@
text
@# $Id$
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.123 2019/08/03 20:25:37 tg Exp $
#-
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010,
#		2011, 2012, 2013, 2014, 2015, 2016, 2017, 2019
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# ${ENV:-~/.mkshrc}: mksh initialisation file for interactive shells

# catch non-mksh, non-lksh, trying to run this file
case ${KSH_VERSION:-} in
*LEGACY\ KSH*|*MIRBSD\ KSH*) ;;
*) \return 0 ;;
esac

# give MidnightBSD's laffer1 a bit of csh feeling
function setenv {
	if (( $# )); then
		\\builtin eval '\\builtin export "$1"="${2:-}"'
	else
		\\builtin typeset -x
	fi
}

# pager (not control character safe)
smores() (
	\\builtin set +m
	\\builtin cat "$@@" |&
	\\builtin trap "rv=\$?; \\\\builtin kill $! >/dev/null 2>&1; \\\\builtin exit \$rv" EXIT
	while IFS= \\builtin read -pr line; do
		llen=${%line}
		(( llen == -1 )) && llen=${#line}
		(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
		if (( (curlin += llen) >= LINES )); then
			\\builtin print -nr -- $'\e[7m--more--\e[0m'
			\\builtin read -u1 || \\builtin exit $?
			[[ $REPLY = [Qq]* ]] && \\builtin exit 0
			curlin=$llen
		fi
		\\builtin print -r -- "$line"
	done
)

# customise your favourite editor here; the first one found is used
for EDITOR in "${EDITOR:-}" jupp jstar mcedit ed vi; do
	EDITOR=$(\\builtin whence -p "$EDITOR") || EDITOR=
	[[ -n $EDITOR && -x $EDITOR ]] && break
	EDITOR=
done

\\builtin alias ls=ls l='ls -F' la='l -a' ll='l -l' lo='l -alo'
\: "${EDITOR:=/bin/ed}${TERM:=vt100}${USER:=$(\\builtin ulimit -c 0; id -un \
    2>/dev/null)}${HOSTNAME:=$(\\builtin ulimit -c 0; hostname 2>/dev/null)}"
[[ $HOSTNAME = ?(?(ip6-)localhost?(6)) ]] && HOSTNAME=nil; \\builtin unalias ls
\\builtin export EDITOR HOSTNAME TERM USER="${USER:-?}"

# minimal support for lksh users
if [[ $KSH_VERSION = *LEGACY\ KSH* ]]; then
	PS1='$USER@@${HOSTNAME%%.*}:$PWD>'
	\\builtin return 0
fi

# mksh-specific from here
\: "${MKSH:=$(\\builtin whence -p mksh)}${MKSH:=/bin/mksh}"
\\builtin export MKSH

# prompts
PS4='[$EPOCHREALTIME] '; PS1='#'; (( USER_ID )) && PS1='$'; PS1=$'\001\r''${|
	\\builtin typeset e=$?

	(( e )) && REPLY+="$e|"
	REPLY+=${USER}@@${HOSTNAME%%.*}:

	\\builtin typeset d=${PWD:-?}/ p=~; [[ $p = ?(*/) ]] || d=${d/#$p\//\~/}
	d=${d%/}; \\builtin typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
	(( m > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && d=${d:(-n)} || p=
	REPLY+=$p$d

	\\builtin return $e
} '"$PS1 "

# utilities
\\builtin alias doch='sudo mksh -c "$(\\builtin fc -ln -1)"'
\\builtin command -v rot13 >/dev/null || \\builtin alias rot13='tr \
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ \
    nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
if \\builtin command -v hd >/dev/null; then
	\:
elif \\builtin command -v hexdump >/dev/null; then
	function hd {
		hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
		    -e '"  |" "%_p"' -e '"|\n"' "$@@"
	}
else
	function hd {
		\\builtin cat "$@@" | hd_mksh "$@@"
	}
fi

# NUL-safe and EBCDIC-safe hexdump (from stdin)
function hd_mksh {
	\\builtin typeset -Uui16 -Z11 pos=0
	\\builtin typeset -Uui16 -Z5 hv=2147483647
	\\builtin typeset dasc dn line i
	\\builtin set +U

	while \\builtin read -arn 512 line; do
		\\builtin typeset -i1 'line[*]'
		i=0
		while (( i < ${#line[*]} )); do
			dn=
			(( (hv = line[i++]) != 0 )) && dn=${line[i-1]#1#}
			if (( (pos & 15) == 0 )); then
				(( pos )) && \
				    \\builtin print -r -- "$dasc|"
				\\builtin print -nr "${pos#16#}  "
				dasc=' |'
			fi
			\\builtin print -nr "${hv#16#} "
			if [[ $dn = [[:print:]] ]]; then
				dasc+=$dn
			else
				dasc+=.
			fi
			(( (pos++ & 15) == 7 )) && \
			    \\builtin print -nr -- '- '
		done
	done
	while (( pos & 15 )); do
		\\builtin print -nr '   '
		(( (pos++ & 15) == 7 )) && \
		    \\builtin print -nr -- '- '
	done
	(( hv == 2147483647 )) || \\builtin print -r -- "$dasc|"
}

# Berkeley C shell compatible dirs, popd, and pushd functions
# Z shell compatible chpwd() hook, used to update DIRSTACK[0]
DIRSTACKBASE=$(\\builtin realpath ~/. 2>/dev/null || \
    \\builtin print -nr -- "${HOME:-/}")
\\builtin set -A DIRSTACK
function chpwd {
	DIRSTACK[0]=$(\\builtin realpath . 2>/dev/null || \
	    \\builtin print -nr -- "$PWD")
	[[ $DIRSTACKBASE = ?(*/) ]] || \
	    DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/\~}
	\:
}
\chpwd .
cd() {
	\\builtin cd "$@@" || \\builtin return $?
	\chpwd "$@@"
}
function cd_csh {
	\\builtin typeset d t=${1/#\~/$DIRSTACKBASE}

	if ! d=$(\\builtin cd "$t" 2>&1); then
		\\builtin print -ru2 "${1}: ${d##*cd: $t: }."
		\\builtin return 1
	fi
	\cd "$t"
}
function dirs {
	\\builtin typeset d dwidth
	\\builtin typeset -i fl=0 fv=0 fn=0 cpos=0

	while \\builtin getopts ":lvn" d; do
		case $d {
		(l)	fl=1 ;;
		(v)	fv=1 ;;
		(n)	fn=1 ;;
		(*)	\\builtin print -ru2 'Usage: dirs [-lvn].'
			\\builtin return 1 ;;
		}
	done
	\\builtin shift $((OPTIND - 1))
	if (( $# > 0 )); then
		\\builtin print -ru2 'Usage: dirs [-lvn].'
		\\builtin return 1
	fi
	if (( fv )); then
		fv=0
		while (( fv < ${#DIRSTACK[*]} )); do
			d=${DIRSTACK[fv]}
			(( fl )) && d=${d/#\~/$DIRSTACKBASE}
			\\builtin print -r -- "$fv	$d"
			(( ++fv ))
		done
	else
		fv=0
		while (( fv < ${#DIRSTACK[*]} )); do
			d=${DIRSTACK[fv]}
			(( fl )) && d=${d/#\~/$DIRSTACKBASE}
			(( dwidth = (${%d} > 0 ? ${%d} : ${#d}) ))
			if (( fn && (cpos += dwidth + 1) >= 79 && \
			    dwidth < 80 )); then
				\\builtin print
				(( cpos = dwidth + 1 ))
			fi
			\\builtin print -nr -- "$d "
			(( ++fv ))
		done
		\\builtin print
	fi
	\\builtin return 0
}
function popd {
	\\builtin typeset d fa
	\\builtin typeset -i n=1

	while \\builtin getopts ":0123456789lvn" d; do
		case $d {
		(l|v|n)	fa+=" -$d" ;;
		(+*)	n=2
			\\builtin break ;;
		(*)	\\builtin print -ru2 'Usage: popd [-lvn] [+<n>].'
			\\builtin return 1 ;;
		}
	done
	\\builtin shift $((OPTIND - n))
	n=0
	if (( $# > 1 )); then
		\\builtin print -ru2 popd: Too many arguments.
		\\builtin return 1
	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
			\\builtin print -ru2 popd: Directory stack not that deep.
			\\builtin return 1
		fi
	elif [[ -n $1 ]]; then
		\\builtin print -ru2 popd: Bad directory.
		\\builtin return 1
	fi
	if (( ${#DIRSTACK[*]} < 2 )); then
		\\builtin print -ru2 popd: Directory stack empty.
		\\builtin return 1
	fi
	\\builtin unset DIRSTACK[n]
	\\builtin set -A DIRSTACK -- "${DIRSTACK[@@]}"
	\cd_csh "${DIRSTACK[0]}" || \\builtin return 1
	\dirs $fa
}
function pushd {
	\\builtin typeset d fa
	\\builtin typeset -i n=1

	while \\builtin getopts ":0123456789lvn" d; do
		case $d {
		(l|v|n)	fa+=" -$d" ;;
		(+*)	n=2
			\\builtin break ;;
		(*)	\\builtin print -ru2 'Usage: pushd [-lvn] [<dir>|+<n>].'
			\\builtin return 1 ;;
		}
	done
	\\builtin shift $((OPTIND - n))
	if (( $# == 0 )); then
		if (( ${#DIRSTACK[*]} < 2 )); then
			\\builtin print -ru2 pushd: No other directory.
			\\builtin return 1
		fi
		d=${DIRSTACK[1]}
		DIRSTACK[1]=${DIRSTACK[0]}
		\cd_csh "$d" || \\builtin return 1
	elif (( $# > 1 )); then
		\\builtin print -ru2 pushd: Too many arguments.
		\\builtin return 1
	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
			\\builtin print -ru2 pushd: Directory stack not that deep.
			\\builtin return 1
		fi
		while (( n-- )); do
			d=${DIRSTACK[0]}
			\\builtin unset DIRSTACK[0]
			\\builtin set -A DIRSTACK -- "${DIRSTACK[@@]}" "$d"
		done
		\cd_csh "${DIRSTACK[0]}" || \\builtin return 1
	else
		\\builtin set -A DIRSTACK -- placeholder "${DIRSTACK[@@]}"
		\cd_csh "$1" || \\builtin return 1
	fi
	\dirs $fa
}

# base64 encoder and decoder, RFC compliant, NUL safe, not EBCDIC safe
function Lb64decode {
	\\builtin set +U
	\\builtin typeset c s="$*" t
	[[ -n $s ]] || { s=$(\\builtin cat; \\builtin print x); s=${s%x}; }
	\\builtin typeset -i i=0 j=0 n=${#s} p=0 v x
	\\builtin typeset -i16 o

	while (( i < n )); do
		c=${s:(i++):1}
		case $c {
		(=)	\\builtin break ;;
		([A-Z])	(( v = 1#$c - 65 )) ;;
		([a-z])	(( v = 1#$c - 71 )) ;;
		([0-9])	(( v = 1#$c + 4 )) ;;
		(+)	v=62 ;;
		(/)	v=63 ;;
		(*)	\\builtin continue ;;
		}
		(( x = (x << 6) | v ))
		case $((p++)) {
		(0)	\\builtin continue ;;
		(1)	(( o = (x >> 4) & 255 )) ;;
		(2)	(( o = (x >> 2) & 255 )) ;;
		(3)	(( o = x & 255 ))
			p=0
			;;
		}
		t+=\\x${o#16#}
		(( ++j & 4095 )) && \\builtin continue
		\\builtin print -n $t
		t=
	done
	\\builtin print -n $t
}
function Lb64encode {
	\\builtin set +U
	\\builtin typeset c s t table
	\\builtin set -A table -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
	    a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
	if (( $# )); then
		\\builtin read -raN-1 s <<<"$*"
		\\builtin unset s[${#s[*]}-1]
	else
		\\builtin read -raN-1 s
	fi
	\\builtin typeset -i i=0 n=${#s[*]} v

	while (( i < n )); do
		(( v = s[i++] << 16 ))
		(( v |= s[i++] << 8 ))
		(( v |= s[i++] ))
		t+=${table[v >> 18]}${table[v >> 12 & 63]}
		c=${table[v >> 6 & 63]}
		if (( i <= n )); then
			t+=$c${table[v & 63]}
		elif (( i == n + 1 )); then
			t+=$c=
		else
			t+===
		fi
		if (( ${#t} == 76 || i >= n )); then
			\\builtin print -r $t
			t=
		fi
	done
}

# Better Avalanche for the Jenkins Hash
\\builtin typeset -Z11 -Uui16 Lbafh_v
function Lbafh_init {
	Lbafh_v=0
}
function Lbafh_add {
	\\builtin set +U
	\\builtin typeset s
	if (( $# )); then
		\\builtin read -raN-1 s <<<"$*"
		\\builtin unset s[${#s[*]}-1]
	else
		\\builtin read -raN-1 s
	fi
	\\builtin typeset -i i=0 n=${#s[*]}

	while (( i < n )); do
		((# Lbafh_v = (Lbafh_v + s[i++] + 1) * 1025 ))
		((# Lbafh_v ^= Lbafh_v >> 6 ))
	done
}
function Lbafh_finish {
	\\builtin typeset -Ui t

	((# t = (((Lbafh_v >> 7) & 0x01010101) * 0x1B) ^ \
	    ((Lbafh_v << 1) & 0xFEFEFEFE) ))
	((# Lbafh_v = t ^ (t ^> 8) ^ (Lbafh_v ^> 8) ^ \
	    (Lbafh_v ^> 16) ^ (Lbafh_v ^> 24) ))
	\:
}

# strip comments (and leading/trailing whitespace if IFS is set) from
# any file(s) given as argument, or stdin if none, and spew to stdout
function Lstripcom {
	\\builtin set -o noglob
	\\builtin cat "$@@" | while \\builtin read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && \\builtin print -r -- $_line
	done
}

# toggle built-in aliases and utilities, and aliases and functions from mkshrc
function enable {
	\\builtin typeset doprnt=0 mode=1 x y z rv=0
	\\builtin typeset b_alias i_alias i_func nalias=0 nfunc=0 i_all
	\\builtin set -A b_alias
	\\builtin set -A i_alias
	\\builtin set -A i_func

	# accumulate mksh built-in aliases, in ASCIIbetical order
	i_alias[nalias]=autoload; b_alias[nalias++]='\\builtin typeset -fu'
	i_alias[nalias]=functions; b_alias[nalias++]='\\builtin typeset -f'
	i_alias[nalias]=hash; b_alias[nalias++]='\\builtin alias -t'
	i_alias[nalias]=history; b_alias[nalias++]='\\builtin fc -l'
	i_alias[nalias]=integer; b_alias[nalias++]='\\builtin typeset -i'
	i_alias[nalias]=local; b_alias[nalias++]='\\builtin typeset'
	i_alias[nalias]=login; b_alias[nalias++]='\\builtin exec login'
	i_alias[nalias]=nameref; b_alias[nalias++]='\\builtin typeset -n'
	i_alias[nalias]=nohup; b_alias[nalias++]='nohup '
	i_alias[nalias]=r; b_alias[nalias++]='\\builtin fc -e -'
	i_alias[nalias]=type; b_alias[nalias++]='\\builtin whence -v'

	# accumulate mksh built-in utilities, in definition order, even ifndef
	i_func[nfunc++]=.
	i_func[nfunc++]=:
	i_func[nfunc++]='['
	i_func[nfunc++]=alias
	i_func[nfunc++]=break
	# \\builtin cannot, by design, be overridden
	i_func[nfunc++]=builtin
	i_func[nfunc++]=cat
	i_func[nfunc++]=cd
	i_func[nfunc++]=chdir
	i_func[nfunc++]=command
	i_func[nfunc++]=continue
	i_func[nfunc++]=echo
	i_func[nfunc++]=eval
	i_func[nfunc++]=exec
	i_func[nfunc++]=exit
	i_func[nfunc++]=export
	i_func[nfunc++]=false
	i_func[nfunc++]=fc
	i_func[nfunc++]=getopts
	i_func[nfunc++]=global
	i_func[nfunc++]=jobs
	i_func[nfunc++]=kill
	i_func[nfunc++]=let
	i_func[nfunc++]=print
	i_func[nfunc++]=pwd
	i_func[nfunc++]=read
	i_func[nfunc++]=readonly
	i_func[nfunc++]=realpath
	i_func[nfunc++]=rename
	i_func[nfunc++]=return
	i_func[nfunc++]=set
	i_func[nfunc++]=shift
	i_func[nfunc++]=source
	i_func[nfunc++]=suspend
	i_func[nfunc++]=test
	i_func[nfunc++]=times
	i_func[nfunc++]=trap
	i_func[nfunc++]=true
	i_func[nfunc++]=typeset
	i_func[nfunc++]=ulimit
	i_func[nfunc++]=umask
	i_func[nfunc++]=unalias
	i_func[nfunc++]=unset
	i_func[nfunc++]=wait
	i_func[nfunc++]=whence
	i_func[nfunc++]=bg
	i_func[nfunc++]=fg
	i_func[nfunc++]=bind
	i_func[nfunc++]=mknod
	i_func[nfunc++]=printf
	i_func[nfunc++]=sleep
	i_func[nfunc++]=domainname
	i_func[nfunc++]=extproc

	# accumulate aliases from dot.mkshrc, in definition order
	i_alias[nalias]=l; b_alias[nalias++]='ls -F'
	i_alias[nalias]=la; b_alias[nalias++]='l -a'
	i_alias[nalias]=ll; b_alias[nalias++]='l -l'
	i_alias[nalias]=lo; b_alias[nalias++]='l -alo'
	i_alias[nalias]=doch; b_alias[nalias++]='sudo mksh -c "$(\\builtin fc -ln -1)"'
	i_alias[nalias]=rot13; b_alias[nalias++]='tr abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
	i_alias[nalias]=cls; b_alias[nalias++]='\\builtin print -n \\ec'

	# accumulate functions from dot.mkshrc, in definition order
	i_func[nfunc++]=setenv
	i_func[nfunc++]=smores
	i_func[nfunc++]=hd
	i_func[nfunc++]=hd_mksh
	i_func[nfunc++]=chpwd
	i_func[nfunc++]=cd
	i_func[nfunc++]=cd_csh
	i_func[nfunc++]=dirs
	i_func[nfunc++]=popd
	i_func[nfunc++]=pushd
	i_func[nfunc++]=Lb64decode
	i_func[nfunc++]=Lb64encode
	i_func[nfunc++]=Lbafh_init
	i_func[nfunc++]=Lbafh_add
	i_func[nfunc++]=Lbafh_finish
	i_func[nfunc++]=Lstripcom
	i_func[nfunc++]=enable

	# collect all identifiers, sorted ASCIIbetically
	\\builtin set -sA i_all -- "${i_alias[@@]}" "${i_func[@@]}"

	# handle options, we don't do dynamic loading
	while \\builtin getopts "adf:nps" x; do
		case $x {
		(a)
			mode=-1
			;;
		(d)
			# deliberately causing an error, like bash-static
			;|
		(f)
			\\builtin print -ru2 enable: dynamic loading not available
			\\builtin return 2
			;;
		(n)
			mode=0
			;;
		(p)
			doprnt=1
			;;
		(s)
			\\builtin set -sA i_all -- . : break continue eval \
			    exec exit export readonly return set shift times \
			    trap unset
			;;
		(*)
			\\builtin print -ru2 enable: usage: \
			    "enable [-adnps] [-f filename] [name ...]"
			return 2
			;;
		}
	done
	\\builtin shift $((OPTIND - 1))

	# display builtins enabled/disabled/all/special?
	if (( doprnt || ($# == 0) )); then
		for x in "${i_all[@@]}"; do
			y=$(\\builtin alias "$x") || y=
			[[ $y = "$x='\\\\builtin whence -p $x >/dev/null || (\\\\builtin print -r mksh: $x: not found; \\\\builtin exit 127) && \$(\\\\builtin whence -p $x)'" ]]; z=$?
			case $mode:$z {
			(-1:0|0:0)
				\\builtin print -r -- "enable -n $x"
				;;
			(-1:1|1:1)
				\\builtin print -r -- "enable $x"
				;;
			}
		done
		\\builtin return 0
	fi

	for x in "$@@"; do
		z=0
		for y in "${i_alias[@@]}" "${i_func[@@]}"; do
			[[ $x = "$y" ]] || \\builtin continue
			z=1
			\\builtin break
		done
		if (( !z )); then
			\\builtin print -ru2 enable: "$x": not a shell builtin
			rv=1
			\\builtin continue
		fi
		if (( !mode )); then
			# disable this
			\\builtin alias "$x=\\\\builtin whence -p $x >/dev/null || (\\\\builtin print -r mksh: $x: not found; \\\\builtin exit 127) && \$(\\\\builtin whence -p $x)"
		else
			# find out if this is an alias or not, first
			z=0
			y=-1
			while (( ++y < nalias )); do
				[[ $x = "${i_alias[y]}" ]] || \\builtin continue
				z=1
				\\builtin break
			done
			if (( z )); then
				# re-enable the original alias body
				\\builtin alias "$x=${b_alias[y]}"
			else
				# re-enable the original utility/function
				\\builtin unalias "$x"
			fi
		fi
	done
	\\builtin return $rv
}

\: place customisations below this line

# some defaults/samples — you are supposed to adjust these to your
# liking; by default we add ~/.etc/bin and ~/bin (whichever exist)
# to $PATH, set $SHELL to mksh, set some defaults for man and less
# and show a few more possible things for users to begin moving in

for p in ~/.etc/bin ~/bin; do
	[[ -d $p/. ]] || \\builtin continue
	[[ $PATHSEP$PATH$PATHSEP = *"$PATHSEP$p$PATHSEP"* ]] || \
	    PATH=$p$PATHSEP$PATH
done

\\builtin export SHELL=$MKSH MANWIDTH=80 LESSHISTFILE=-
\\builtin alias cls='\\builtin print -n \\ec'

#\\builtin unset LC_ADDRESS LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
#    LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
#    LC_TELEPHONE LC_TIME LANGUAGE LANG LC_ALL
#p=en_GB.UTF-8
#\\builtin export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
#\\builtin export LANG=C.UTF-8 LC_CTYPE=C.UTF-8
#\\builtin export LC_ALL=C.UTF-8
#\\builtin set -U
#[[ ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} = *[Uu][Tt][Ff]?(-)8* ]] || \\builtin set +U

\\builtin unset p

\: place customisations above this line
@


1.123
log
@update commented-out locale example from Debian packaging recent changes
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.122 2019/08/03 20:19:33 tg Exp $
d625 1
@


1.122
log
@simplify HOSTNAME/USER generation

I don’t know what I had intus in r1.109 but it wasn’t good…
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.119 2017/08/08 20:50:34 tg Exp $
d606 1
a606 1
# some defaults follow — you are supposed to adjust these to your
d620 3
a622 2
#\\builtin unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
#    LC_NAME LC_NUMERIC LC_TELEPHONE LC_TIME
d625 1
d627 1
@


1.121
log
@oh wait, actually…

• besides the previously-set $EDITOR take [jupp jstar mcedit ed vi]
  as sorted list, first one found wins
• set -eu safe, and in the lksh part
@
text
@d5 1
a5 1
#		2011, 2012, 2013, 2014, 2015, 2016, 2017
d67 2
a68 3
\: "${HOSTNAME:=$(\\builtin ulimit -c 0; \\builtin print -r -- $(hostname \
    2>/dev/null))}${EDITOR:=/bin/ed}${TERM:=vt100}${USER:=$(\\builtin ulimit \
    -c 0; id -un 2>/dev/null)}${USER:=?}"
d70 1
a70 1
\\builtin export EDITOR HOSTNAME TERM USER
@


1.120
log
@promote jupp to default editor if installed, in the customisation section
@
text
@d59 7
a626 1
p=$(\\builtin whence -p jupp) && EDITOR=$p
@


1.119
log
@comment
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.111 2017/03/19 20:36:07 tg Exp $
d620 1
@


1.118
log
@let hd_mksh take from stdin, great simplification
@
text
@d76 1
d90 2
d109 1
d600 5
@


1.117
log
@make EBCDIC-safe
@
text
@d102 1
a102 1
		hd_mksh "$@@"
d112 18
a129 25
	\\builtin cat "$@@" | {
		while \\builtin read -arn 512 line; do
			\\builtin typeset -i1 'line[*]'
			i=0
			while (( i < ${#line[*]} )); do
				dn=
				(( (hv = line[i++]) != 0 )) && dn=${line[i-1]#1#}
				if (( (pos & 15) == 0 )); then
					(( pos )) && \
					    \\builtin print -r -- "$dasc|"
					\\builtin print -nr "${pos#16#}  "
					dasc=' |'
				fi
				\\builtin print -nr "${hv#16#} "
				if [[ $dn = [[:print:]] ]]; then
					dasc+=$dn
				else
					dasc+=.
				fi
				(( (pos++ & 15) == 7 )) && \
				    \\builtin print -nr -- '- '
			done
		done
		while (( pos & 15 )); do
			\\builtin print -nr '   '
d133 7
a139 2
		(( hv == 2147483647 )) || \\builtin print -r -- "$dasc|"
	}
@


1.116
log
@perform in chunks, don’t read the entire file into memory ahead
@
text
@d109 1
a109 1
	\\builtin typeset dasc line i
d117 2
a118 1
				hv=${line[i++]}
d126 3
a128 2
				#XXX EBCDIC, but we need [[:print:]] to fix this
				if (( (hv < 32) || (hv > 126) )); then
a129 2
				else
					dasc+=${line[i-1]#1#}
@


1.115
log
@always expone mksh’s hexdumper
@
text
@d112 22
a133 20
	\\builtin cat "$@@" | if \\builtin read -arN -1 line; then
		\\builtin typeset -i1 'line[*]'
		i=0
		while (( i < ${#line[*]} )); do
			hv=${line[i++]}
			if (( (pos & 15) == 0 )); then
				(( pos )) && \
				    \\builtin print -r -- "$dasc|"
				\\builtin print -nr "${pos#16#}  "
				dasc=' |'
			fi
			\\builtin print -nr "${hv#16#} "
			#XXX EBCDIC, but we need [[:print:]] to fix this
			if (( (hv < 32) || (hv > 126) )); then
				dasc+=.
			else
				dasc+=${line[i-1]#1#}
			fi
			(( (pos++ & 15) == 7 )) && \
			    \\builtin print -nr -- '- '
d141 1
a141 1
	fi
@


1.114
log
@add standard variable PATHSEP, for better and easier OS/2 support
@
text
@d102 1
a102 33
		\\builtin typeset -Uui16 -Z11 pos=0
		\\builtin typeset -Uui16 -Z5 hv=2147483647
		\\builtin typeset dasc line i
		\\builtin set +U

		\\builtin cat "$@@" | if \\builtin read -arN -1 line; then
			\\builtin typeset -i1 'line[*]'
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (pos & 15) == 0 )); then
					(( pos )) && \
					    \\builtin print -r -- "$dasc|"
					\\builtin print -nr "${pos#16#}  "
					dasc=' |'
				fi
				\\builtin print -nr "${hv#16#} "
				#XXX EBCDIC, but we need [[:print:]] to fix this
				if (( (hv < 32) || (hv > 126) )); then
					dasc+=.
				else
					dasc+=${line[i-1]#1#}
				fi
				(( (pos++ & 15) == 7 )) && \
				    \\builtin print -nr -- '- '
			done
			while (( pos & 15 )); do
				\\builtin print -nr '   '
				(( (pos++ & 15) == 7 )) && \
				    \\builtin print -nr -- '- '
			done
			(( hv == 2147483647 )) || \\builtin print -r -- "$dasc|"
		fi
d106 36
d490 1
@


1.113
log
@fix padding in Lb64encode

undefined array elements read as "" or (arithmetically) 0
so this is ok and works as the lines below expect it
@
text
@d591 1
a591 1
[[ $PATH = *\;?:\\* ]] || for p in ~/.etc/bin ~/bin; do
d593 2
a594 1
	[[ :$PATH: = *:$p:* ]] || PATH=$p:$PATH
@


1.112
log
@use \\builtin ipv \let] and \set internally
@
text
@d333 1
a333 1
	\\builtin typeset -i i=0 n=${#s[*]} j v
d337 2
a338 4
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j << 8 ))
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j ))
@


1.111
log
@use the new “\builtin” builtin for quoting, everywhere
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.106 2016/07/24 23:05:51 tg Exp $
d142 1
a142 1
set -A DIRSTACK
a443 1
	i_func[nfunc++]='let]' #XXX going
@


1.110
log
@exclude PATH manipulation if we guess at OS/2
@
text
@d28 1
a28 1
*) return 0 ;;
d34 1
a34 1
		\eval '\export "$1"="${2:-}"'
d36 1
a36 1
		\typeset -x
d42 4
a45 4
	\set +m
	\cat "$@@" |&
	\trap "rv=\$?; 'kill' $! >/dev/null 2>&1; 'exit' \$rv" EXIT
	while IFS= \read -pr line; do
d50 3
a52 3
			\builtin print -n -- '\e[7m--more--\e[0m'
			\read -u1 || \exit $?
			[[ $REPLY = [Qq]* ]] && \exit 0
d55 1
a55 1
		\builtin print -r -- "$line"
d59 6
a64 5
\: "${EDITOR:=/bin/ed}${TERM:=vt100}${HOSTNAME:=$(\ulimit -c 0; \echo \
    $(hostname 2>/dev/null))}${USER:=$(\ulimit -c 0; id -un 2>/dev/null)}"
[[ $HOSTNAME = ?(?(ip6-)localhost?(6)) ]] && HOSTNAME=nil; \: "${USER:=?}"
\alias ls=ls l='ls -F' la='l -a' ll='l -l' lo='l -alo'; \unalias ls
\export EDITOR HOSTNAME TERM USER
d69 1
a69 1
	return 0
d73 2
a74 1
\: "${MKSH:=$(\builtin whence -p mksh)}"; \: "${MKSH:=/bin/mksh}"; \export MKSH
d77 1
a77 1
	\typeset e=$?
d82 2
a83 2
	\typeset d=${PWD:-?}/ p=~; [[ $p = ?(*/) ]] || d=${d/#$p\//\~/}
	d=${d%/}; \typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
d87 1
a87 1
	\return $e
d89 2
a90 2
\alias doch='sudo mksh -c "$(\builtin fc -ln -1)"'
\command -v rot13 >/dev/null || \alias rot13='tr \
d93 3
a95 1
if \command -v hd >/dev/null; then \:; elif \command -v hexdump >/dev/null; then
d102 4
a105 4
		\typeset -Uui16 -Z11 pos=0
		\typeset -Uui16 -Z5 hv=2147483647
		\typeset dasc line i
		\set +U
d107 2
a108 2
		\cat "$@@" | if \read -arN -1 line; then
			\typeset -i1 'line[*]'
d114 2
a115 2
					    \builtin print -r -- "$dasc|"
					\builtin print -n "${pos#16#}  "
d118 1
a118 1
				\builtin print -n "${hv#16#} "
d126 1
a126 1
				    \builtin print -n -- '- '
d129 1
a129 1
				\builtin print -n '   '
d131 1
a131 1
				    \builtin print -n -- '- '
d133 1
a133 1
			(( hv == 2147483647 )) || \builtin print -r -- "$dasc|"
d140 2
a141 2
DIRSTACKBASE=$(\builtin realpath ~/. 2>/dev/null || \
    \builtin print -nr -- "${HOME:-/}")
d144 2
a145 2
	DIRSTACK[0]=$(\builtin realpath . 2>/dev/null || \
	    \builtin print -r -- "$PWD")
d152 1
a152 1
	\builtin cd "$@@" || \return $?
d156 1
a156 1
	\typeset d t=${1/#\~/$DIRSTACKBASE}
d158 3
a160 3
	if ! d=$(\builtin cd "$t" 2>&1); then
		\builtin print -u2 "${1}: ${d##*cd: $t: }."
		\return 1
d165 2
a166 2
	\typeset d dwidth
	\typeset -i fl=0 fv=0 fn=0 cpos=0
d168 1
a168 1
	while \getopts ":lvn" d; do
d173 2
a174 2
		(*)	\builtin print -u2 'Usage: dirs [-lvn].'
			\return 1 ;;
d177 1
a177 1
	\shift $((OPTIND - 1))
d179 2
a180 2
		\builtin print -u2 'Usage: dirs [-lvn].'
		\return 1
d187 2
a188 2
			\builtin print -r -- "$fv	$d"
			\builtin let fv++
d198 1
a198 1
				\builtin print
d201 2
a202 2
			\builtin print -nr -- "$d "
			\builtin let fv++
d204 1
a204 1
		\builtin print
d206 1
a206 1
	\return 0
d209 2
a210 2
	\typeset d fa
	\typeset -i n=1
d212 1
a212 1
	while \getopts ":0123456789lvn" d; do
d216 3
a218 3
			\break ;;
		(*)	\builtin print -u2 'Usage: popd [-lvn] [+<n>].'
			\return 1 ;;
d221 1
a221 1
	\shift $((OPTIND - n))
d224 2
a225 2
		\builtin print -u2 popd: Too many arguments.
		\return 1
d228 2
a229 2
			\builtin print -u2 popd: Directory stack not that deep.
			\return 1
d232 2
a233 2
		\builtin print -u2 popd: Bad directory.
		\return 1
d236 2
a237 2
		\builtin print -u2 popd: Directory stack empty.
		\return 1
d239 3
a241 3
	\unset DIRSTACK[n]
	\set -A DIRSTACK -- "${DIRSTACK[@@]}"
	\cd_csh "${DIRSTACK[0]}" || \return 1
d245 2
a246 2
	\typeset d fa
	\typeset -i n=1
d248 1
a248 1
	while \getopts ":0123456789lvn" d; do
d252 3
a254 3
			\break ;;
		(*)	\builtin print -u2 'Usage: pushd [-lvn] [<dir>|+<n>].'
			\return 1 ;;
d257 1
a257 1
	\shift $((OPTIND - n))
d260 2
a261 2
			\builtin print -u2 pushd: No other directory.
			\return 1
d265 1
a265 1
		\cd_csh "$d" || \return 1
d267 2
a268 2
		\builtin print -u2 pushd: Too many arguments.
		\return 1
d271 2
a272 2
			\builtin print -u2 pushd: Directory stack not that deep.
			\return 1
d276 2
a277 2
			\unset DIRSTACK[0]
			\set -A DIRSTACK -- "${DIRSTACK[@@]}" "$d"
d279 1
a279 1
		\cd_csh "${DIRSTACK[0]}" || \return 1
d281 2
a282 2
		\set -A DIRSTACK -- placeholder "${DIRSTACK[@@]}"
		\cd_csh "$1" || \return 1
d289 5
a293 5
	\set +U
	\typeset c s="$*" t
	[[ -n $s ]] || { s=$(\cat; \builtin print x); s=${s%x}; }
	\typeset -i i=0 j=0 n=${#s} p=0 v x
	\typeset -i16 o
d298 1
a298 1
		(=)	\break ;;
d304 1
a304 1
		(*)	\continue ;;
d308 1
a308 1
		(0)	\continue ;;
d316 2
a317 2
		(( ++j & 4095 )) && \continue
		\builtin print -n $t
d320 1
a320 1
	\builtin print -n $t
a321 3

\set -A Lb64encode_tbl -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
    a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
d323 4
a326 2
	\set +U
	\typeset c s t
d328 2
a329 2
		\read -raN-1 s <<<"$*"
		\unset s[${#s[*]}-1]
d331 1
a331 1
		\read -raN-1 s
d333 1
a333 1
	\typeset -i i=0 n=${#s[*]} j v
d341 2
a342 2
		t+=${Lb64encode_tbl[v >> 18]}${Lb64encode_tbl[v >> 12 & 63]}
		c=${Lb64encode_tbl[v >> 6 & 63]}
d344 1
a344 1
			t+=$c${Lb64encode_tbl[v & 63]}
d351 1
a351 1
			\builtin print $t
d358 1
a358 1
\typeset -Z11 -Uui16 Lbafh_v
d363 2
a364 2
	\set +U
	\typeset s
d366 2
a367 2
		\read -raN-1 s <<<"$*"
		\unset s[${#s[*]}-1]
d369 1
a369 1
		\read -raN-1 s
d371 1
a371 1
	\typeset -i i=0 n=${#s[*]}
d379 1
a379 1
	\typeset -Ui t
d391 2
a392 2
	\set -o noglob
	\cat "$@@" | while \read _line; do
d394 1
a394 1
		[[ -n $_line ]] && \builtin print -r -- $_line
d400 5
a404 5
	\typeset doprnt=0 mode=1 x y z rv=0
	\typeset b_alias i_alias i_func nalias=0 nfunc=0 i_all
	\set -A b_alias
	\set -A i_alias
	\set -A i_func
d407 8
a414 8
	i_alias[nalias]=autoload; b_alias[nalias++]='\typeset -fu'
	i_alias[nalias]=functions; b_alias[nalias++]='\typeset -f'
	i_alias[nalias]=hash; b_alias[nalias++]='\builtin alias -t'
	i_alias[nalias]=history; b_alias[nalias++]='\builtin fc -l'
	i_alias[nalias]=integer; b_alias[nalias++]='\typeset -i'
	i_alias[nalias]=local; b_alias[nalias++]='\typeset'
	i_alias[nalias]=login; b_alias[nalias++]='\exec login'
	i_alias[nalias]=nameref; b_alias[nalias++]='\typeset -n'
d416 2
a417 2
	i_alias[nalias]=r; b_alias[nalias++]='\builtin fc -e -'
	i_alias[nalias]=type; b_alias[nalias++]='\builtin whence -v'
d425 1
d444 1
a444 1
	i_func[nfunc++]='let]'
d481 1
a481 1
	i_alias[nalias]=doch; b_alias[nalias++]='sudo mksh -c "$(\builtin fc -ln -1)"'
d483 1
a483 1
	i_alias[nalias]=cls; b_alias[nalias++]='\builtin print -n \\ec'
d486 2
a494 1
	i_func[nfunc++]=smores
a500 1
	i_func[nfunc++]=setenv
d504 1
a504 1
	\set -sA i_all -- "${i_alias[@@]}" "${i_func[@@]}"
d507 1
a507 1
	while \getopts "adf:nps" x; do
d516 2
a517 2
			\builtin print -u2 enable: dynamic loading not available
			\return 2
d526 3
a528 2
			\set -sA i_all -- . : break continue eval exec exit \
			    export readonly return set shift times trap unset
d531 1
a531 1
			\builtin print -u2 enable: usage: \
d537 1
a537 1
	\shift $((OPTIND - 1))
d542 2
a543 2
			y=$(\alias "$x") || y=
			[[ $y = "$x='\\builtin whence -p $x >/dev/null || (\\builtin print mksh: $x: not found; exit 127) && \$(\\builtin whence -p $x)'" ]]; z=$?
d546 1
a546 1
				\print -r -- "enable -n $x"
d549 1
a549 1
				\print -r -- "enable $x"
d553 1
a553 1
		\return 0
d559 1
a559 1
			[[ $x = "$y" ]] || \continue
d561 1
a561 1
			\break
d564 1
a564 1
			\builtin print -ru2 enable: "$x": not a shell builtin
d566 1
a566 1
			\continue
d570 1
a570 1
			\alias "$x=\\builtin whence -p $x >/dev/null || (\\builtin print mksh: $x: not found; exit 127) && \$(\\builtin whence -p $x)"
d576 1
a576 1
				[[ $x = "${i_alias[y]}" ]] || \continue
d578 1
a578 1
				\break
d582 1
a582 1
				\alias "$x=${b_alias[y]}"
d585 1
a585 1
				\unalias "$x"
d589 1
a589 1
	\return $rv
d595 1
a595 1
	[[ -d $p/. ]] || \continue
d599 2
a600 2
\export SHELL=$MKSH MANWIDTH=80 LESSHISTFILE=-
\alias cls='\builtin print -n \\ec'
d602 1
a602 1
#\unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
d605 2
a606 2
#\export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
#\set -U
d608 1
a608 1
\unset p
@


1.109
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d589 1
a589 1
for p in ~/.etc/bin ~/bin; do
a590 1
	#XXX OS/2
@


1.108
log
@missed a function (due to it being POSIX, not Korn, probably)
@
text
@d5 1
a5 1
#		2011, 2012, 2013, 2014, 2015, 2016
d25 1
a25 1
# catch non-mksh (including lksh) trying to run this file
d27 1
a27 1
*MIRBSD\ KSH*) ;;
d31 44
a74 7
PS1='#'; (( USER_ID )) && PS1='$'; \: "${TERM:=vt100}${HOSTNAME:=$(\ulimit -c \
    0; hostname 2>/dev/null)}${EDITOR:=/bin/ed}${USER:=$(\ulimit -c 0; id -un \
    2>/dev/null || \echo \?)}${MKSH:=$(\builtin whence -p mksh)}"
HOSTNAME=${HOSTNAME%%*([	 ]).*}; HOSTNAME=${HOSTNAME##*([	 ])}
[[ $HOSTNAME = ?(ip6-)localhost?(6) ]] && HOSTNAME=
\: "${HOSTNAME:=nil}${MKSH:=/bin/mksh}"; \export EDITOR HOSTNAME MKSH TERM USER
PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
a86 6
\alias ls=ls
\unalias ls
\alias l='ls -F'
\alias la='l -a'
\alias ll='l -l'
\alias lo='l -alo'
a282 19
# pager (not control character safe)
smores() (
	\set +m
	\cat "$@@" |&
	\trap "rv=\$?; 'kill' $! >/dev/null 2>&1; 'exit' \$rv" EXIT
	while IFS= \read -pr line; do
		llen=${%line}
		(( llen == -1 )) && llen=${#line}
		(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
		if (( (curlin += llen) >= LINES )); then
			\builtin print -n -- '\e[7m--more--\e[0m'
			\read -u1 || \exit $?
			[[ $REPLY = [Qq]* ]] && \exit 0
			curlin=$llen
		fi
		\builtin print -r -- "$line"
	done
)

a394 9
# give MidnightBSD's laffer1 a bit of csh feeling
function setenv {
	if (( $# )); then
		\eval '\export "$1"="${2:-}"'
	else
		\typeset -x
	fi
}

@


1.107
log
@use ^< and ^> for ROL and ROR in R53, schedule >>> as SAR for R54

cf. http://david.tribble.com/text/c0xrot.htm
@
text
@d481 1
@


1.106
log
@fix issues with home directory replacement, from Torsten Sillke:
• if $PWD = ${HOME}foo, no longer show as ~foo in PS1
• simplify ~, ~+, and ~- exactly as $PWD is upon shell entry
  (fixes HOME=/home/./foo but PWD=/home/foo)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.90 2015/01/06 20:54:53 tg Exp $
d368 2
a369 2
	((# Lbafh_v = t ^ (t >>> 8) ^ (Lbafh_v >>> 8) ^ \
	    (Lbafh_v >>> 16) ^ (Lbafh_v >>> 24) ))
@


1.105
log
@simplify
@
text
@d43 2
a44 2
	\typeset d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/\~}
	\typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
@


1.104
log
@set -U after LANG/LC_*, for future compatibility, cf. commitid 10056858F3B37548534
@
text
@d5 1
a5 1
#		2011, 2012, 2013, 2014, 2015
d253 17
a269 19
function smores {
	(
		\set +m
		\cat "$@@" |&
		\trap "rv=\$?; 'kill' $! >/dev/null 2>&1; 'exit' \$rv" EXIT
		while IFS= \read -pr line; do
			llen=${%line}
			(( llen == -1 )) && llen=${#line}
			(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
			if (( (curlin += llen) >= LINES )); then
				\builtin print -n -- '\e[7m--more--\e[0m'
				\read -u1 || \exit $?
				[[ $REPLY = [Qq]* ]] && \exit 0
				curlin=$llen
			fi
			\builtin print -r -- "$line"
		done
	)
}
@


1.103
log
@we must quote a tilde in substitutions now
@
text
@d599 1
a600 1
#\export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
@


1.102
log
@make “source” into a built-in command (keepasn, to match ksh93 and “dot”);
remove the “stop” alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d43 1
a43 1
	\typeset d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
d112 1
a112 1
	    DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/~}
d121 1
a121 1
	\typeset d t=${1/#~/$DIRSTACKBASE}
d151 1
a151 1
			(( fl )) && d=${d/#~/$DIRSTACKBASE}
d159 1
a159 1
			(( fl )) && d=${d/#~/$DIRSTACKBASE}
@


1.101
log
@make setenv set -u safe and fix behaviour for no args
@
text
@d6 1
a6 1
#	mirabilos <tg@@mirbsd.org>
a412 3
	#XXX OS/2
	i_alias[nalias]=source; b_alias[nalias++]='PATH=$PATH:. \command .'
	i_alias[nalias]=stop; b_alias[nalias++]='\kill -STOP'
d449 1
d469 1
@


1.100
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d6 1
a6 1
#	Thorsten Glaser <tg@@mirbsd.org>
d387 5
a391 1
	\eval "'export' \"$1\""'="$2"'
@


1.99
log
@optimise by making use of commitid 1005529AD8D33CF99B9
@
text
@d409 1
d586 1
@


1.98
log
@cd does weird things wrt. error messages; slightly better, from carstenh via IRC
@
text
@d70 1
d72 1
a72 1
		\cat "$@@" | { \set +U; if \read -arN -1 line; then
d99 1
a99 1
		fi; }
a274 1
	[[ -o utf8-mode ]]; \typeset u=$? c s="$*" t
d276 1
a306 1
	(( u )) || \set -U
a311 1
	[[ -o utf8-mode ]]; \typeset u=$? c s t
d313 1
a341 1
	(( u )) || \set -U
a349 1
	[[ -o utf8-mode ]]; \typeset u=$? s
d351 1
a363 2

	(( u )) || \set -U
d378 2
a379 1
	\cat "$@@" | { \set -o noglob; while \read _line; do
d382 1
a382 1
	done; }
@


1.97
log
@EBCDIC review
@
text
@d115 1
a115 1
function cd {
@


1.96
log
@• the \: "${foo:=bar}${bar:=baz}" construct needs no spaces
• more set -u police
• 80c and tweaks while here
@
text
@d83 1
d262 1
a262 1
				\builtin print -n -- '\033[7m--more--\033[0m'
d272 1
a272 1
# base64 encoder and decoder, RFC compliant, NUL safe
d476 1
a476 1
	i_alias[nalias]=cls; b_alias[nalias++]='\builtin print -n \\033c'
d591 1
a591 1
\alias cls='\builtin print -n \\033c'
@


1.95
log
@some robustness improvements for dot.mkshrc:
• do not use \return for return before we know we are mksh
  (plus fix a wrong-word mistake)
• quote the argument(s) to \: (“colon”) for SECURITY
• default $MKSH to /bin/mksh (not normally reached)
• while here: check $USER only once, not for each PS1 (speed)

this addresses and mostly closes LP#1441853 – prt.mkshrc (in
OBS home:mirabile/mksh and DEB wtf-mksh they are identical)
is already good; Android mkshrc needs only some small robustness
fixes (mostly colon-related; enh says TMPDIR is good); I tested
this with “mksh -eu” and “mksh -eul” on Debian and ecce and with
read-only “/” and nothing else mounted on ecce, and it WFM
@
text
@d26 1
a26 1
case $KSH_VERSION in
d31 6
a36 5
PS1='#'; (( USER_ID )) && PS1='$'; [[ ${HOSTNAME:=$(\ulimit -c 0; hostname -s \
    2>/dev/null)} = *([	 ]|localhost) ]] && HOSTNAME=$(\ulimit -c 0; hostname \
    2>/dev/null); \: "${EDITOR:=/bin/ed} ${HOSTNAME:=nil} ${MKSH:=$(\builtin \
    whence -p mksh || \echo /bin/mksh)} ${TERM:=vt100} ${USER:=$(\ulimit -c 0; \
    id -un 2>/dev/null || \echo \?)}"
d49 1
a49 1
} '"$PS1 "; \export EDITOR HOSTNAME MKSH TERM USER
d77 2
a78 1
					(( pos )) && \builtin print -r -- "$dasc|"
d88 2
a89 1
				(( (pos++ & 15) == 7 )) && \builtin print -n -- '- '
d93 2
a94 1
				(( (pos++ & 15) == 7 )) && \builtin print -n -- '- '
d103 2
a104 1
DIRSTACKBASE=$(\builtin realpath ~/. 2>/dev/null || \builtin print -nr -- "${HOME:-/}")
d107 2
a108 1
	DIRSTACK[0]=$(\builtin realpath . 2>/dev/null || \builtin print -r -- "$PWD")
d308 1
a308 1
\set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
d327 2
a328 2
		t+=${Lb64encode_code[v >> 18]}${Lb64encode_code[v >> 12 & 63]}
		c=${Lb64encode_code[v >> 6 & 63]}
d330 1
a330 1
			t+=$c${Lb64encode_code[v & 63]}
d391 1
a391 1
# toggle built-in aliases and utilities, and aliases and functions from here
@


1.94
log
@“local x=$1” is supposed to not field-split and so
@
text
@d25 1
a25 1
# catch non-mksh (including lksh) trying to shell this file
d28 1
a28 1
*) \return 0 ;;
d33 4
a36 2
    2>/dev/null); \: ${EDITOR:=/bin/ed} ${HOSTNAME:=nil} ${TERM:=vt100}
\: ${MKSH:=$(\builtin whence -p mksh)}; PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
d40 1
a40 2
	REPLY+=${USER:=$(\ulimit -c 0; id -un 2>/dev/null || \echo \?)}
	REPLY+=@@${HOSTNAME%%.*}:
@


1.93
log
@implement “enable” (like GNU bash) to stop Harzilein from complaining
about mksh’s “rename” builtin
@
text
@d35 1
a35 1
	\builtin typeset e=$?
d41 2
a42 2
	\builtin typeset d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
	\builtin typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
d65 3
a67 3
		\builtin typeset -Uui16 -Z11 pos=0
		\builtin typeset -Uui16 -Z5 hv=2147483647
		\builtin typeset dasc line i
d70 1
a70 1
			\builtin typeset -i1 'line[*]'
d112 1
a112 1
	\builtin typeset d t=${1/#~/$DIRSTACKBASE}
d121 2
a122 2
	\builtin typeset d dwidth
	\builtin typeset -i fl=0 fv=0 fn=0 cpos=0
d165 2
a166 2
	\builtin typeset d fa
	\builtin typeset -i n=1
d201 2
a202 2
	\builtin typeset d fa
	\builtin typeset -i n=1
d266 1
a266 1
	[[ -o utf8-mode ]]; \builtin typeset u=$? c s="$*" t
d269 2
a270 2
	\builtin typeset -i i=0 j=0 n=${#s} p=0 v x
	\builtin typeset -i16 o
d304 1
a304 1
	[[ -o utf8-mode ]]; \builtin typeset u=$? c s t
d312 1
a312 1
	\builtin typeset -i i=0 n=${#s[*]} j v
d338 1
a338 1
\builtin typeset -Z11 -Uui16 Lbafh_v
d343 1
a343 1
	[[ -o utf8-mode ]]; \builtin typeset u=$? s
d351 1
a351 1
	\builtin typeset -i i=0 n=${#s[*]}
d361 1
a361 1
	\builtin typeset -Ui t
d386 2
a387 2
	\builtin typeset doprnt=0 mode=1 x y z rv=0
	\builtin typeset b_alias i_alias i_func nalias=0 nfunc=0 i_all
d393 2
a394 2
	i_alias[nalias]=autoload; b_alias[nalias++]='\builtin typeset -fu'
	i_alias[nalias]=functions; b_alias[nalias++]='\builtin typeset -f'
d397 2
a398 2
	i_alias[nalias]=integer; b_alias[nalias++]='\builtin typeset -i'
	i_alias[nalias]=local; b_alias[nalias++]='\builtin typeset'
d400 1
a400 1
	i_alias[nalias]=nameref; b_alias[nalias++]='\builtin typeset -n'
@


1.92
log
@• protect POSIX builtins and utilities from aliases, e.g:
  ‣ : → \:
  ‣ alias → \alias
    ⇒ except in some internally used cases, where we use \builtin alias
  ‣ command . → \command .
• protect Korn Shell builtins from aliases and functions, e.g:
  ‣ typeset → \builtin typeset
    ⇒ also unravels the “local” alias used
  ‣ print → \builtin print
• protect internally-used things from aliases
  ‣ “let]” is not a valid function name
  ‣ “set” is POSIX so we don’t expect anyone to override it in a function
• use “command -v” instead of “whence -p” (“which”) in most
  places; thanks izabera from #ed on IRC for pointing out
  that “command -v” is POSIX – except, “whence -p” a̲l̲w̲a̲y̲s̲ looks
  for an executable and shows its full pathname; “command -v”
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
• make most of dot.mkshrc work in the face of such aliases
  ‣ “ulimit -c” is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesn’t use them?
• update list of builtin aliases in the manpage
@
text
@d384 191
@


1.91
log
@• fix bug spotted by geirha: typeset args are glob-prone
• ormaaj suggested adding gsf’s homepage (still no new ast-ksh)
@
text
@d28 1
a28 1
*) return 0 ;;
d31 5
a35 5
PS1='#'; (( USER_ID )) && PS1='$'; [[ ${HOSTNAME:=$(ulimit -c 0; hostname -s \
    2>/dev/null)} = *([	 ]|localhost) ]] && HOSTNAME=$(ulimit -c 0; hostname \
    2>/dev/null); : ${EDITOR:=/bin/ed} ${HOSTNAME:=nil} ${TERM:=vt100}
: ${MKSH:=$(whence -p mksh)}; PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
	local e=$?
d38 1
a38 1
	REPLY+=${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?)}
d41 2
a42 2
	local d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
	local m=${%d} n p=...; (( m > 0 )) || m=${#d}
d46 10
a55 10
	return $e
} '"$PS1 "; export EDITOR HOSTNAME MKSH TERM USER
alias ls=ls
unalias ls
alias l='ls -F'
alias la='l -a'
alias ll='l -l'
alias lo='l -alo'
alias doch='sudo mksh -c "$(fc -ln -1)"'
whence -p rot13 >/dev/null || alias rot13='tr \
d58 1
a58 1
if whence -p hd >/dev/null; then :; elif whence -p hexdump >/dev/null; then
d65 3
a67 3
		local -Uui16 -Z11 pos=0
		local -Uui16 -Z5 hv=2147483647
		local dasc line i
d69 2
a70 2
		cat "$@@" | { set +U; if read -arN -1 line; then
			typeset -i1 'line[*]'
d75 2
a76 2
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
d79 1
a79 1
				print -n "${hv#16#} "
d85 1
a85 1
				(( (pos++ & 15) == 7 )) && print -n -- '- '
d88 2
a89 2
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
d91 1
a91 1
			(( hv == 2147483647 )) || print -r -- "$dasc|"
d98 1
a98 1
DIRSTACKBASE=$(realpath ~/. 2>/dev/null || print -nr -- "${HOME:-/}")
d101 1
a101 1
	DIRSTACK[0]=$(realpath . 2>/dev/null || print -r -- "$PWD")
d104 1
a104 1
	:
d106 1
a106 1
chpwd .
d108 2
a109 2
	builtin cd "$@@" || return $?
	chpwd "$@@"
d112 1
a112 1
	local d t=${1/#~/$DIRSTACKBASE}
d114 3
a116 3
	if ! d=$(builtin cd "$t" 2>&1); then
		print -u2 "${1}: ${d##*cd: $t: }."
		return 1
d118 1
a118 1
	cd "$t"
d121 2
a122 2
	local d dwidth
	local -i fl=0 fv=0 fn=0 cpos=0
d124 1
a124 1
	while getopts ":lvn" d; do
d129 2
a130 2
		(*)	print -u2 'Usage: dirs [-lvn].'
			return 1 ;;
d133 1
a133 1
	shift $((OPTIND - 1))
d135 2
a136 2
		print -u2 'Usage: dirs [-lvn].'
		return 1
d143 2
a144 2
			print -r -- "$fv	$d"
			let fv++
d154 1
a154 1
				print
d157 2
a158 2
			print -nr -- "$d "
			let fv++
d160 1
a160 1
		print
d162 1
a162 1
	return 0
d165 2
a166 2
	local d fa
	local -i n=1
d168 1
a168 1
	while getopts ":0123456789lvn" d; do
d172 3
a174 3
			break ;;
		(*)	print -u2 'Usage: popd [-lvn] [+<n>].'
			return 1 ;;
d177 1
a177 1
	shift $((OPTIND - n))
d180 2
a181 2
		print -u2 popd: Too many arguments.
		return 1
d184 2
a185 2
			print -u2 popd: Directory stack not that deep.
			return 1
d188 2
a189 2
		print -u2 popd: Bad directory.
		return 1
d192 2
a193 2
		print -u2 popd: Directory stack empty.
		return 1
d195 4
a198 4
	unset DIRSTACK[n]
	set -A DIRSTACK -- "${DIRSTACK[@@]}"
	cd_csh "${DIRSTACK[0]}" || return 1
	dirs $fa
d201 2
a202 2
	local d fa
	local -i n=1
d204 1
a204 1
	while getopts ":0123456789lvn" d; do
d208 3
a210 3
			break ;;
		(*)	print -u2 'Usage: pushd [-lvn] [<dir>|+<n>].'
			return 1 ;;
d213 1
a213 1
	shift $((OPTIND - n))
d216 2
a217 2
			print -u2 pushd: No other directory.
			return 1
d221 1
a221 1
		cd_csh "$d" || return 1
d223 2
a224 2
		print -u2 pushd: Too many arguments.
		return 1
d227 2
a228 2
			print -u2 pushd: Directory stack not that deep.
			return 1
d232 2
a233 2
			unset DIRSTACK[0]
			set -A DIRSTACK -- "${DIRSTACK[@@]}" "$d"
d235 1
a235 1
		cd_csh "${DIRSTACK[0]}" || return 1
d237 2
a238 2
		set -A DIRSTACK -- placeholder "${DIRSTACK[@@]}"
		cd_csh "$1" || return 1
d240 1
a240 1
	dirs $fa
d246 4
a249 4
		set +m
		cat "$@@" |&
		trap "rv=\$?; kill $! >/dev/null 2>&1; exit \$rv" EXIT
		while IFS= read -pr line; do
d254 3
a256 3
				print -n -- '\033[7m--more--\033[0m'
				read -u1 || exit $?
				[[ $REPLY = [Qq]* ]] && exit 0
d259 1
a259 1
			print -r -- "$line"
d266 5
a270 5
	[[ -o utf8-mode ]]; local u=$? c s="$*" t
	set +U
	[[ -n $s ]] || { s=$(cat; print x); s=${s%x}; }
	local -i i=0 j=0 n=${#s} p=0 v x
	local -i16 o
d275 1
a275 1
		(=)	break ;;
d281 1
a281 1
		(*)	continue ;;
d285 1
a285 1
		(0)	continue ;;
d293 2
a294 2
		(( ++j & 4095 )) && continue
		print -n $t
d297 2
a298 2
	print -n $t
	(( u )) || set -U
d301 1
a301 1
set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
d304 2
a305 2
	[[ -o utf8-mode ]]; local u=$? c s t
	set +U
d307 2
a308 2
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
d310 1
a310 1
		read -raN-1 s
d312 1
a312 1
	local -i i=0 n=${#s[*]} j v
d330 1
a330 1
			print $t
d334 1
a334 1
	(( u )) || set -U
d338 1
a338 1
typeset -Z11 -Uui16 Lbafh_v
d343 2
a344 2
	[[ -o utf8-mode ]]; local u=$? s
	set +U
d346 2
a347 2
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
d349 1
a349 1
		read -raN-1 s
d351 1
a351 1
	local -i i=0 n=${#s[*]}
d358 1
a358 1
	(( u )) || set -U
d361 1
a361 1
	local -Ui t
d367 1
a367 1
	:
d373 1
a373 1
	cat "$@@" | { set -o noglob; while read _line; do
d375 1
a375 1
		[[ -n $_line ]] && print -r -- $_line
d381 1
a381 1
	eval export "\"$1\""'="$2"'
d384 1
a384 1
: place customisations below this line
d387 1
a387 1
	[[ -d $p/. ]] || continue
d391 2
a392 2
export SHELL=$MKSH MANWIDTH=80 LESSHISTFILE=-
alias cls='print -n \\033c'
d394 1
a394 1
#unset LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_IDENTIFICATION LC_MONETARY \
d397 2
a398 2
#set -U
#export LANG=C LC_CTYPE=$p LC_MEASUREMENT=$p LC_MESSAGES=$p LC_PAPER=$p
d400 1
a400 1
unset p
d402 1
a402 1
: place customisations above this line
@


1.90
log
@• when using typeset to change the type of an array,
  use arrname[*] to denote changing it of all array elements
• optimise a bit: group local invocations
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.89 2014/07/28 21:45:44 tg Exp $
d70 1
a70 1
			typeset -i1 line[*]
@


1.89
log
@https://android-review.googlesource.com/102253

• permit interrupts during a write(2) loop in the cat builtin, too,
  not just in the read(2) loop – fixes inability to kill a clogged
  output cat

• kill the cat when smores finish

TODO: revisit this ⓐ in more depth, ⓑ for other functions, such as
      “hd”, and ⓒ test on AOSP as well
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.88 2014/01/11 18:09:39 tg Exp $
d5 1
a5 1
#		2011, 2012, 2013, 2014
d70 1
a70 1
			typeset -i1 line
d266 1
a266 1
	[[ -o utf8-mode ]]; local u=$?
a267 1
	local c s="$*" t=
d304 1
a304 1
	[[ -o utf8-mode ]]; local u=$?
a305 1
	local c s t
d343 1
a343 1
	[[ -o utf8-mode ]]; local u=$?
a344 1
	local s
@


1.89.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.91 2015/01/11 00:23:06 tg Exp $
d5 1
a5 1
#		2011, 2012, 2013, 2014, 2015
d70 1
a70 1
			typeset -i1 'line[*]'
d266 1
a266 1
	[[ -o utf8-mode ]]; local u=$? c s="$*" t
d268 1
d305 1
a305 1
	[[ -o utf8-mode ]]; local u=$? c s t
d307 1
d345 1
a345 1
	[[ -o utf8-mode ]]; local u=$? s
d347 1
@


1.89.2.2
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.89.2.1 2015/01/11 22:39:44 tg Exp $
d55 1
a55 1
command -v rot13 >/dev/null || alias rot13='tr \
d58 1
a58 1
if command -v hd >/dev/null; then :; elif command -v hexdump >/dev/null; then
@


1.89.2.3
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.96 2015/04/11 19:01:59 tg Exp $
d25 2
a26 2
# catch non-mksh (including lksh) trying to run this file
case ${KSH_VERSION:-} in
d31 4
a34 7
PS1='#'; (( USER_ID )) && PS1='$'; : "${TERM:=vt100}${HOSTNAME:=$(ulimit -c \
    0; hostname 2>/dev/null)}${EDITOR:=/bin/ed}${USER:=$(ulimit -c 0; id -un \
    2>/dev/null || echo \?)}${MKSH:=$(whence -p mksh)}"
HOSTNAME=${HOSTNAME%%*([	 ]).*}; HOSTNAME=${HOSTNAME##*([	 ])}
[[ $HOSTNAME = ?(ip6-)localhost?(6) ]] && HOSTNAME=
: "${HOSTNAME:=nil}${MKSH:=/bin/mksh}"; export EDITOR HOSTNAME MKSH TERM USER
PS4='[$EPOCHREALTIME] '; PS1=$'\001\r''${|
d38 2
a39 1
	REPLY+=${USER}@@${HOSTNAME%%.*}:
d47 1
a47 1
} '"$PS1 "
d75 1
a75 2
					(( pos )) && \
					    print -r -- "$dasc|"
d85 1
a85 2
				(( (pos++ & 15) == 7 )) && \
				    print -n -- '- '
d89 1
a89 2
				(( (pos++ & 15) == 7 )) && \
				    print -n -- '- '
d98 1
a98 2
DIRSTACKBASE=$(realpath ~/. 2>/dev/null || \
    print -nr -- "${HOME:-/}")
d101 1
a101 2
	DIRSTACK[0]=$(realpath . 2>/dev/null || \
	    print -r -- "$PWD")
@


1.88
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.87 2014/01/05 22:17:57 tg Exp $
d245 17
a261 14
	local dummy line llen curlin=0

	cat "$@@" | while IFS= read -r line; do
		llen=${%line}
		(( llen == -1 )) && llen=${#line}
		(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
		if (( (curlin += llen) >= LINES )); then
			print -n -- '\033[7m--more--\033[0m'
			read -u1 dummy
			[[ $dummy = [Qq]* ]] && return 0
			curlin=$llen
		fi
		print -r -- "$line"
	done
@


1.87
log
@avoid NZATMix returning false on its identity mapping (00000000h)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.86 2014/01/02 22:51:01 tg Exp $
d336 6
a341 3
# mksh NUL counting, never zero
typeset -Z11 -Uui16 Lnzathash_v
function Lnzathash_add {
d354 2
a355 2
		((# Lnzathash_v = (Lnzathash_v + s[i++] + 1) * 1025 ))
		((# Lnzathash_v ^= Lnzathash_v >> 6 ))
d360 2
a361 28
function Lnzaathash_end {
	((# Lnzathash_v *= 1025 ))
	((# Lnzathash_v ^= Lnzathash_v >> 6 ))
	((# Lnzathash_v += Lnzathash_v << 3 ))
	((# Lnzathash_v = (Lnzathash_v ^
	    (Lnzathash_v >> 11)) * 32769 ))
	print ${Lnzathash_v#16#}
}
function Lnzaathash {
	Lnzathash_v=0
	Lnzathash_add "$@@"
	Lnzaathash_end
}
function Lnzathash {
	Lnzathash_v=0
	Lnzathash_add "$@@"
	Lnzathash_end
}
function Lnzathash_end {
	if (( Lnzathash_v )); then
		Lnzaathash_end
	else
		Lnzathash_v=1
		print ${Lnzathash_v#16#}
	fi
}
function Lnzathash_mix {
	local -Uui16 t
d363 4
a366 4
	((# t = ((Lnzathash_v >> 7) & 0x01010101) * 0x1B ))
	((# t ^= (Lnzathash_v << 1) & 0xFEFEFEFE ))
	((# Lnzathash_v = t ^ (t <<< 24) ^ (Lnzathash_v <<< 8) ^ \
	    (Lnzathash_v <<< 16) ^ (Lnzathash_v <<< 24) ))
@


1.86
log
@• use Rĳndæl MixColumn for arc4random_roundhash avalanching;
  suggested in http://crypto.stackexchange.com/questions/12145
• add pure mksh™ implementation, too, while here (since it can
  replace NZAATFinish even though NZATMix is slower, both are
  bijective)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.85 2013/08/22 13:46:46 tg Exp $
d390 1
@


1.85
log
@• don’t eat builtin cd errorlevel in function cd
• fix extglob in function cd_csh to match current error strings
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.84 2013/08/10 13:43:50 tg Exp $
d5 1
a5 1
#		2011, 2012, 2013
d383 8
@


1.84
log
@by request of gecko2@@ make “doch” keep stdin at slight lack of privacy
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.83 2013/07/25 14:02:02 tg Exp $
d108 1
a108 1
	builtin cd "$@@"
d115 1
a115 1
		print -u2 "${1}: ${d##*$t - }."
@


1.83
log
@disable utf8-mode for hd function (temporarily)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.79 2013/04/05 15:39:52 tg Exp $
d54 1
a54 1
alias doch='fc -ln -1 | sudo mksh -s'
@


1.82
log
@implement VALSUBs
@
text
@d69 1
a69 1
		cat "$@@" | if read -arN -1 line; then
d92 1
a92 1
		fi
@


1.81
log
@pimp the hexdump function 'hd' for when there is none
@
text
@d34 1
a34 1
function precmd {
d37 9
a45 2
	(( e )) && print -n "$e|"
	# precmd is required to retain the errorlevel when ${ …;} is used
d47 1
a47 7
}
PS1=$'\001\r''${ precmd;}${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
	)}@@${HOSTNAME%%.*}:${ local e=$? d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || \
	d=${d/#$p/~}; local m=${%d} n p=...; (( m > 0 )) || m=${#d}
	(( m > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && d=${d:(-n)} || \
	p=; print -nr -- "$p$d"; return $e;} '"$PS1 "; PS4='[$EPOCHREALTIME] '
: ${MKSH:=$(whence -p mksh)}; export EDITOR HOSTNAME MKSH TERM USER
@


1.80
log
@lksh also reads $ENV so make sure it doesn’t try this one
@
text
@d57 37
a93 4
whence -p hd >/dev/null || function hd {
	hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
	    -e '"  |" "%_p"' -e '"|\n"' "$@@"
}
d265 1
a265 1
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
@


1.79
log
@Tonnerre Lombard’s contribution:

[17:27:44] Tonnerre: csh: alias doch sudo \!-1 bash: alias doch='sudo $(history -p !-1)' zsh: alias doch='sudo $(fc -ln -1)'
[17:28:03] mirabilos: ?
[17:28:34] Tonnerre: Na ganz einfach:
[17:28:36] Tonnerre: % ls /root
[17:28:39] Tonnerre: ls: cannot open directory /root: Permission denied
[17:28:42] Tonnerre: % doch
[17:28:45] Tonnerre: [sudo] password for tonnerre:
[17:28:49] Tonnerre: anaconda-ks.cfg  cgminer-1.6.2-1.rf.src.rpm  rpmbuild  upgrade.log  upgrade.log.syslog
[17:28:53] Tonnerre: %

This is one of two mksh variants; the other uses a tmpfile:
alias doch='sudo mksh -c "${ fc -ln -1;}"'

Both quote correctly, unlike the above.

Maybe use $MKSH instead? (Quoted or unquoted? Hm. Probably quoted.)
Input on that welcome…
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.78 2013/03/24 15:01:35 tg Exp $
d25 6
@


1.78
log
@set (but never export!) PS4 to something timestamped by default, as an example
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.77 2013/02/17 15:58:26 tg Exp $
d47 1
@


1.77
log
@eval is evil
Proper quoting is hard
Bugs galore
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.76 2013/02/10 23:30:47 tg Exp $
d39 1
a39 1
	p=; print -nr -- "$p$d"; return $e;} '"$PS1 "
@


1.76
log
@provide a layer of locality to FUNSUBs; get rid of a fork for each PS1 thus
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.75 2013/02/10 19:04:00 tg Exp $
d354 1
a354 1
	eval export $1'="$2"'
@


1.75
log
@do NOT close stdout or stderr, redirect to /dev/null instead
⇒ we did have issues with that, trust me…
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.74 2013/01/21 15:06:24 tg Exp $
d36 1
a36 1
	)}@@${HOSTNAME%%.*}:$(local d=${PWD:-?} p=~; [[ $p = ?(*/) ]] || \
d39 1
a39 1
	p=; print -nr -- "$p$d") '"$PS1 "
@


1.74
log
@precmd is required to retain the errorlevel when ${ …;} is used
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.73 2012/11/30 20:19:10 tg Exp $
d25 3
a27 3
: ${EDITOR:=/bin/ed} ${TERM:=vt100} ${HOSTNAME:=$(ulimit -c 0;hostname -s 2>&-)}
[[ $HOSTNAME = @@(localhost|*([	 ])) ]] && HOSTNAME=$(ulimit -c 0;hostname 2>&-)
: ${HOSTNAME:=nil}; if (( USER_ID )); then PS1='$'; else PS1='#'; fi
d47 1
a47 1
whence -p rot13 >&- || alias rot13='tr \
d50 1
a50 1
whence -p hd >&- || function hd {
d57 1
a57 1
DIRSTACKBASE=$(realpath ~/. 2>&- || print -nr -- "${HOME:-/}")
d60 1
a60 1
	DIRSTACK[0]=$(realpath . 2>&- || print -r -- "$PWD")
@


1.73
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.72 2012/10/30 21:04:56 tg Exp $
d5 1
a5 1
#		2011, 2012
d32 2
@


1.72
log
@make “set -o nounset” friendly (even though people who use THAT are at own fault, IMO!)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.71 2012/08/17 18:34:20 tg Exp $
d33 1
a33 1
PS1=$'\001\r''$(precmd)${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
@


1.71
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.70 2012/07/30 21:37:10 tg Exp $
d55 1
a55 1
DIRSTACKBASE=$(realpath ~/. 2>&- || print -nr -- "$HOME")
@


1.70
log
@implement ksh93 feature ${ foo;}
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.68 2011/11/25 23:58:04 tg Exp $
d33 1
a33 1
PS1=$'\001\r''${ precmd;}${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
@


1.69
log
@first part of LP: #909818; ${name@@#} will later be changed to ${name@@#expr} where expr is the IV ipv 0 (eval.c:377ﬀ)
@
text
@d4 2
a5 1
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
d33 1
a33 1
PS1=$'\001\r''$(precmd)${USER:=$(ulimit -c 0; id -un 2>/dev/null || echo \?
@


1.68
log
@use += and do some more mitigation of the alloc problem first
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.65 2011/08/27 18:06:40 tg Exp $
d329 3
@


1.67
log
@actually… the error paths didn’t se-unset noglob! after looking at the
code, until further proof I believe noglob is not even needed ⇒ drop it
@
text
@d126 1
a126 1
		(l|v|n)	fa="$fa -$d" ;;
d162 1
a162 1
		(l|v|n)	fa="$fa -$d" ;;
d223 1
a223 1
	local -i i=0 n=${#s} p=0 v x
d246 4
a249 1
		t=$t\\x${o#16#}
d275 1
a275 1
		t=$t${Lb64encode_code[v >> 18]}${Lb64encode_code[v >> 12 & 63]}
d278 1
a278 1
			t=$t$c${Lb64encode_code[v & 63]}
d280 1
a280 1
			t=$t$c=
d282 1
a282 1
			t=$t==
@


1.66
log
@== inside [[ is not nice, and parsing $(set +o) isn’t either,
since we don’t just have [[ -o ]] now, but can use standard $- here
@
text
@d78 1
a78 1
	local -i isnoglob=0 fl=0 fv=0 fn=0 cpos=0
a79 2
	[[ $- = *f* ]] && isnoglob=1
	set -o noglob
a117 1
	(( isnoglob )) || set +o noglob
d122 1
a122 1
	local -i isnoglob=0 n=1
a123 2
	[[ $- = *f* ]] && isnoglob=1
	set -o noglob
a153 1
	(( isnoglob )) || set +o noglob
d158 1
a158 1
	local -i isnoglob=0 n=1
a159 2
	[[ $- = *f* ]] && isnoglob=1
	set -o noglob
a195 1
	(( isnoglob )) || set +o noglob
@


1.65
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.64 2011/07/18 00:35:45 tg Exp $
d80 1
a80 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
d127 1
a127 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
d166 1
a166 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
@


1.64
log
@now that I got Hash.cs compiled and run, I’m amazed; make NZAAT (and NZAT!) all green with a small tweak; bit distribution and χ2 look OK as well
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.63 2011/07/06 22:21:56 tg Exp $
d32 5
a36 4
PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&-||print \?)}@@${HOSTNAME%%.*}:$(
	local d=${PWD:-?} n p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
	(( (${%d}>0 ? ${%d}: ${#d}) > (n = (COLUMNS/3<7 ? 7: COLUMNS/3)) )) && {
	d=${d:(-n)}; p=...; } || p=; print -nr -- "$p$d") '"$PS1 "
@


1.63
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.62 2011/07/05 20:19:17 tg Exp $
d319 2
@


1.62
log
@replace typeset with local, as style(9) now mandates
(keep globals for a while, until it’s widespread, though)

since we don’t export PS1 any longer, no need to stay AT&T ksh compatible
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.61 2011/07/03 23:26:47 tg Exp $
d297 3
a299 3
# DJB cdb hash (not via stdio, for speed)
typeset -Z11 -Uui16 Lcdbhash_result
function Lcdbhash_add {
d312 2
a313 1
		((# Lcdbhash_result = (Lcdbhash_result * 33) ^ s[i++] ))
d318 16
a333 15
function Lcdbhash {
	Lcdbhash_result=5381
	Lcdbhash_add "$@@"
	print ${Lcdbhash_result#16#}
}

# Jenkins one-at-a-time hash (not via stdio, for speed)
typeset -Z11 -Uui16 Loaathash_result
function Loaathash_add {
	[[ -o utf8-mode ]]; local u=$?
	set +U
	local s
	if (( $# )); then
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
d335 2
a336 1
		read -raN-1 s
a337 24
	local -i i=0 n=${#s[*]}

	while (( i < n )); do
		((# Loaathash_result = (Loaathash_result + s[i++]) *
		    1025 ))
		((# Loaathash_result ^= Loaathash_result >> 6 ))
	done

	(( u )) || set -U
}
function Loaathash_do {
	Loaathash_add "$@@"
	((# Loaathash_result += Loaathash_result << 3 ))
	((# Loaathash_result = (Loaathash_result ^
	    (Loaathash_result >> 11)) * 32769 ))
	print ${Loaathash_result#16#}
}
function Loaathash {
	Loaathash_result=0
	Loaathash_do "$@@"
}
function Loaathash1 {
	Loaathash_result=0x100
	Loaathash_do "$@@"
@


1.61
log
@new function for dot.mkshrc:
23:19⎜<laffer1:#midnightbsd> oddly enough the only cshism i like is setting environment variables at this point.
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.60 2011/05/29 02:18:49 tg Exp $
d28 1
a28 1
	typeset e=$?
d33 1
a33 1
	typeset d=${PWD:-?} n p=~; [[ $p = ?(*/) ]] || d=${d/#$p/~}
d67 1
a67 1
	typeset d t=${1/#~/$DIRSTACKBASE}
d76 2
a77 2
	typeset d dwidth
	typeset -i isnoglob=0 fl=0 fv=0 fn=0 cpos=0
d123 2
a124 2
	typeset d fa
	typeset -i isnoglob=0 n=1
d162 2
a163 2
	typeset d fa
	typeset -i isnoglob=0 n=1
d209 1
a209 1
	typeset dummy line llen curlin=0
d227 1
a227 1
	[[ -o utf8-mode ]]; typeset u=$?
d229 1
a229 1
	typeset c s="$*" t=
d231 2
a232 2
	typeset -i i=0 n=${#s} p=0 v x
	typeset -i16 o
d263 1
a263 1
	[[ -o utf8-mode ]]; typeset u=$?
d265 1
a265 1
	typeset c s t
d272 1
a272 1
	typeset -i i=0 n=${#s[*]} j v
d300 1
a300 1
	[[ -o utf8-mode ]]; typeset u=$?
d302 1
a302 1
	typeset s
d309 1
a309 1
	typeset -i i=0 n=${#s[*]}
d326 1
a326 1
	[[ -o utf8-mode ]]; typeset u=$?
d328 1
a328 1
	typeset s
d335 1
a335 1
	typeset -i i=0 n=${#s[*]}
@


1.60
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.59 2011/02/09 19:32:35 tg Exp $
d370 5
@


1.59
log
@add smores, a more(1)-like pager
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.58 2011/02/02 22:48:15 tg Exp $
d225 1
a225 1
# base64 encoder (not NUL safe) and decoder (NUL safe), RFC compliant
d265 8
a272 3
	typeset c s="$*" t
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
	typeset -i i=0 n=${#s} j v
d275 2
a276 4
		c=${s:(i++):1}
		(( v = 1#$c << 16 ))
		c=${s:(i++):1}
		(( j = ${#c} ? 1#$c : 0 ))
d278 1
a278 2
		c=${s:(i++):1}
		(( j = ${#c} ? 1#$c : 0 ))
d302 8
a309 3
	typeset s="$*"
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
	typeset -i i=0 n=${#s}
d312 1
a312 1
		((# Lcdbhash_result = (Lcdbhash_result * 33) ^ 1#${s:(i++):1} ))
d328 8
a335 3
	typeset s="$*"
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
	typeset -i i=0 n=${#s}
d338 1
a338 1
		((# Loaathash_result = (Loaathash_result + 1#${s:(i++):1}) *
@


1.58
log
@when setting a UTF-8 locale, also set -o utf8-mode
since we might start on e.g. GNU/Linux with a system-wide C locale
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.57 2010/11/26 21:08:54 tg Exp $
d207 18
@


1.57
log
@since dot.mkshrc is sourced by interactive shells anyway, and exporting
PS1 may hurt other shells, do not export it any more

reported by and fix suggestion / affected variables by Frank Terbeck
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.56 2010/07/11 13:54:37 tg Exp $
d4 1
a4 1
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010
d353 1
@


1.56
log
@use string width, not length, if we have it
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.55 2010/07/04 17:35:16 tg Exp $
d36 1
a36 1
: ${MKSH:=$(whence -p mksh)}; export EDITOR HOSTNAME MKSH PS1 TERM USER
@


1.55
log
@fix spelling
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.54 2010/02/25 20:48:10 tg Exp $
d34 1
a34 1
	(( ${#d} > (n = (COLUMNS/3 < 7 ? 7 : COLUMNS/3)) )) && {
d76 1
a76 1
	typeset d
d108 3
a110 1
			if (( fn && (cpos+=${#d}+1) >= 79 && ${#d} < 80 )); then
d112 1
a112 1
				(( cpos = ${#d} + 1 ))
@


1.54
log
@some OSes pre-define $ENV; let this be another hint to their users
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.53 2010/01/25 14:29:34 tg Exp $
d338 1
a338 1
: place customsations below this line
d355 1
a355 1
: place customsations above this line
@


1.53
log
@add Loaathash1 (iv=0x100 ipv 0)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.52 2009/12/12 22:27:14 tg Exp $
d22 1
a22 1
# ~/.mkshrc: mksh initialisation file for interactive shells
@


1.52
log
@use [[ -o … ]] instead of [[ $- = *U* ]] manipulation
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.51 2009/11/03 17:58:44 tg Exp $
d4 1
a4 1
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009
d313 1
a313 2
function Loaathash {
	Loaathash_result=0	# hmm...
d320 8
@


1.51
log
@like a pathfinder, one good commit a day:
add most of the mksh wtf edition dot.mkshrc patch, some commented
out; optimise some other cases (e.g. don't reset MKSH if set, don't
export already exported variables, etc.)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.50 2009/11/02 18:47:02 tg Exp $
d207 1
a207 1
	typeset u=$-
d237 1
a237 2
	[[ $u = *U* ]] && set -U
	:
d243 1
a243 1
	typeset u=$-
d272 1
a272 2
	[[ $u = *U* ]] && set -U
	:
d278 1
a278 1
	typeset u=$-
d288 1
a288 2
	[[ $u = *U* ]] && set -U
	:
d299 1
a299 1
	typeset u=$-
d311 1
a311 2
	[[ $u = *U* ]] && set -U
	:
@


1.50
log
@unalias which, to allow which -a sh, etc.
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.49 2009/08/27 16:52:12 tg Exp $
d36 1
a36 1
export EDITOR HOSTNAME LESSHISTFILE=- MKSH=$(whence -p mksh) PS1 TERM USER
d335 17
@


1.49
log
@we need more RCS IDs!
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.48 2009/08/27 16:40:08 tg Exp $
a42 1
alias which='whence -p'
@


1.48
log
@various fixes and optimisations:
• ensure unsigned arithmetics is used in the cdb hash
• make the hash functions print their result again
• now we can use the Lb64{en,de}code trick of using stdin if "$*"==""
• optimise the one-at-a-time code for shell
@
text
@d1 2
a2 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.47 2009/08/27 16:29:21 tg Exp $
@


1.47
log
@implement Jenkins’ one-at-a-time hash, which has better avalanche
behaviour than DJB’s CDB hash (good if using more than one byte)
and probably no funnels

the CDB hash is good for short (5-6 char) ASCII keys though
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.46 2009/08/27 16:03:52 tg Exp $
d283 1
d287 1
a287 1
		(( Lcdbhash_result = (Lcdbhash_result * 33) ^ 1#${s:(i++):1} ))
d296 1
d305 1
d309 2
a310 2
		((# Loaathash_result += 1#${s:(i++):1} ))
		((# Loaathash_result += Loaathash_result << 10 ))
d321 3
a323 2
	((# Loaathash_result ^= Loaathash_result >> 11 ))
	((# Loaathash_result += Loaathash_result << 15 ))
@


1.46
log
@this is Korn Shell, not C – less ops are always faster than many fast ops
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.45 2009/06/22 17:38:39 tg Rel $
d297 25
@


1.45
log
@add a DJB cdb hash implementation in mksh, which, for speed, uses a
global variable ipv print’ing the result for reparse. conveniently,
it’s already typeset just right (unsigned hex integer, zero padded)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.44 2009/06/22 17:27:22 tg Exp $
d286 1
a286 2
		(( Lcdbhash_result = ((Lcdbhash_result << 5) + \
		    Lcdbhash_result) ^ 1#${s:(i++):1} ))
@


1.44
log
@fix $@@ vs $* mix-up
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.43 2009/05/31 17:17:33 tg Rel $
d277 21
@


1.43
log
@add base64 decoder and encoder in mksh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.42 2009/05/16 16:59:33 tg Rel $
d246 1
a246 1
	typeset c s="$@@" t
@


1.42
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.41 2009/04/05 12:42:34 tg Rel $
d205 72
@


1.41
log
@shorten
@
text
@d1 19
a19 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.40 2008/12/29 21:34:19 tg Exp $
@


1.40
log
@always set COLUMNS and LINES; make use of the fact in dot.mkshrc
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.39 2008/12/13 17:09:45 tg Rel $
d9 1
a9 1
	typeset -i e=$?
d196 1
a196 1
: place customsations above this line!
@


1.39
log
@optimise: embed ^A and ^M inside the default PS1 string
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.38 2008/11/07 20:07:10 tg Stab $
d14 3
a16 3
	typeset p=~ d=${PWD:-?}; typeset -i n=${COLUMNS:-80}/3
	[[ $p = ?(*/) ]] || d=${d/#$p/~}; (( n=n<7?7:n )); (( ${#d}>n )) && {
	p=...; d=${d:(-n)}; } || p=; print -nr -- "$p$d") '"$PS1 "
@


1.38
log
@much simplify and shorten default $PS1 (uses even more magick now)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.37 2008/05/17 18:27:55 tg Exp $
d13 1
a13 1
PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&-||print \?)}@@${HOSTNAME%%.*}:$(
a16 1
PS1="$(print -n '\x1\r')$PS1"		# allow colour codes, framed with ^A
@


1.37
log
@add new builtin “realpath” calling realpath(3) on its argument, skipping
over “--” for compatibility to Debian realpath(1) and possibly busybox’

“sounds handy” replaced@@TNF
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.36 2008/05/16 22:22:11 tg Exp $
d13 4
a16 13
PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&- || print \?)}@@${HOSTNAME%%.*}:$(
	typeset pfx=~ wd=${PWD:-?}
	typeset -i n=${COLUMNS:-80}/3; (( n = n < 7 ? 7 : n ))
	[[ $pfx = ?(*/) ]] || wd=${wd/#$pfx/~}
	pfx=; while (( (${#pfx} + ${#wd}) > n )); do
		if [[ $wd = */* ]]; then
			pfx=.../
			wd=${wd#*/}
		else
			pfx=...
			wd=${wd#?????}
		fi
	done; print -nr -- "$pfx$wd") '"$PS1 "
@


1.36
log
@fix for $HOME with trailing slash (do not expand then either… we could just
strip it, but that might have other problems, better is to use realpath(2),
e.g. via readlink(1), for normalisation, or have the sysop fix it)

XXX make realpath a builtin?
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.35 2008/05/16 22:19:11 tg Exp $
d45 1
a45 1
DIRSTACKBASE=$(readlink -nf ~/. 2>&- || print -nr -- "$HOME")
d48 1
a48 1
	DIRSTACK[0]=$(readlink -nf . 2>&- || print -r -- "$PWD")
@


1.35
log
@if $HOME is / or empty, bash-style tilde replacement yielded funny results
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.34 2008/05/15 15:24:09 tg Exp $
d16 1
a16 1
	[[ $pfx = ?(/) ]] || wd=${wd/#$pfx/~}
d49 1
a49 1
	[[ $DIRSTACKBASE = ?(/) ]] || \
@


1.34
log
@mksh:
* initialise the integers PPID, OPTIND, RANDOM, SECONDS, and TMOUT to base-10
* bring back PGRP as base-10 integer to the process group via getpgrp(2)
* initialise USER_ID as base-10 integer to the effective user id as retrieved
  from geteuid(2) = $(id -u)
* use $USER_ID in dot.mkshrc instead of spawning an id(1) process
  -> dot.mkshrc,v 1.34 now requires mksh R34
* convert more int to bool where appropriate
* remove dead code - getpgrp(2) cannot fail
* sync manual page to reality
* bump to mksh R34(beta) - feature freeze

XXX check if our_pgrp in jobs.c is still really needed, the setpgid call
XXX probably just makes us our own pgrp leader, and we might have to use
XXX and update kshpgrp accordingly - need feedback/help here but I think
XXX this simplification should be possible if I grok the code correctly.

etc/profile:
* adjust to $USER_ID changes in mksh (speed-up here, too)

mksh.hts:
* sync changelog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.33 2008/04/22 13:48:15 tg Rel $
d16 1
a16 1
	wd=${wd/#$pfx/~}
d49 2
a50 1
	DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/~}
@


1.33
log
@• be friendlier to AT&T ksh: use only signed (standard) integers
  ‣ now, a “ksh93” just requires ‘function precmd { :; }; set -o emacs’
    afterwards to get rid of the annoying error messages
  ‣ I could lose that with the following idiom:
    - PS1='$(precmd)…
    + PS1='$(typeset -i e=$?; typeset -f precmd >&- && { (return $e); precmd })…
    but it didn’t seem worthwhile to me
• remove explicit licence blah, normal ./copyright applies
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.32 2008/04/19 22:03:19 tg Exp $
d7 1
a7 1
: ${HOSTNAME:=nil}; PS1='#'; [[ "$(ulimit -c 0; id -u 2>&-)" -eq 0 ]] || PS1='$'
@


1.32
log
@improve the use (parsing) of “set +o” output in the examples
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.31 2008/04/11 20:14:02 tg Stab $
d3 1
a3 24
# Copyright (c) 2007, 2008
#	Thorsten “mirabilos” Glaser <tg@@mirbsd.de>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# Advertising materials mentioning features or use of this work must
# display the following acknowledgement:
#	This product includes material provided by Thorsten Glaser.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# sample mksh initialisation file for interactive shells; install as
# /etc/skel/.mkshrc (as root, for new accounts) or copy to ~/.mkshrc
d9 1
a9 1
	typeset -Ui10 e=$?
d15 1
a15 1
	typeset -Ui n=${COLUMNS:-80}/3; (( n = n < 7 ? 7 : n ))
@


1.31
log
@• make sure “ls” is no shell alias:
  ‣ first alias ls=ls to define it (so that unalias won’t fail)
  ‣ then unalias ls
• don’t hardcode /bin/ls path
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.30 2008/03/03 20:22:37 tg Stab $
d93 1
a93 1
	[[ $(set +o) == *-o\ noglob* ]] && isnoglob=1
d138 1
a138 1
	[[ $(set +o) == *-o\ noglob* ]] && isnoglob=1
d177 1
a177 1
	[[ $(set +o) == *-o\ noglob* ]] && isnoglob=1
@


1.30
log
@no longer make the DIRSTACKBASE variable read-only – it makes too much
trouble when re-reading .mkshrc, and “we sell rope” after all
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.29 2008/03/03 18:44:32 tg Exp $
d51 3
a53 1
alias l='/bin/ls -F'
@


1.30.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.32 2008/04/19 22:03:19 tg Stab $
d51 1
a51 3
alias ls=ls
unalias ls
alias l='ls -F'
d91 1
a91 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
d136 1
a136 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
d175 1
a175 1
	[[ $(set +o) == *@@(-o noglob)@@(| *) ]] && isnoglob=1
@


1.30.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.37 2008/05/17 18:27:55 tg Exp $
d3 24
a26 1
# ~/.mkshrc: mksh initialisation file for interactive shells
d30 1
a30 1
: ${HOSTNAME:=nil}; if (( USER_ID )); then PS1='$'; else PS1='#'; fi
d32 1
a32 1
	typeset -i e=$?
d38 2
a39 2
	typeset -i n=${COLUMNS:-80}/3; (( n = n < 7 ? 7 : n ))
	[[ $pfx = ?(*/) ]] || wd=${wd/#$pfx/~}
d68 1
a68 1
DIRSTACKBASE=$(realpath ~/. 2>&- || print -nr -- "$HOME")
d71 2
a72 3
	DIRSTACK[0]=$(realpath . 2>&- || print -r -- "$PWD")
	[[ $DIRSTACKBASE = ?(*/) ]] || \
	    DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/~}
@


1.30.2.3
log
@MFC: mksh R36b
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.39 2008/12/13 17:09:45 tg Rel $
d13 14
a26 4
PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&-||print \?)}@@${HOSTNAME%%.*}:$(
	typeset p=~ d=${PWD:-?}; typeset -i n=${COLUMNS:-80}/3
	[[ $p = ?(*/) ]] || d=${d/#$p/~}; (( n=n<7?7:n )); (( ${#d}>n )) && {
	p=...; d=${d:(-n)}; } || p=; print -nr -- "$p$d") '"$PS1 "
@


1.29
log
@simplify
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.28 2008/03/01 21:24:58 tg Rel $
a66 1
typeset -r DIRSTACKBASE
@


1.28
log
@finally, all bugs fixed, adjust dot.mkshrc to use the subst code
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.27 2008/03/01 16:35:30 tg Exp $
d54 1
a54 1
alias lo='la -lo'
@


1.27
log
@oops. forgot to commit:
• bump © year
• document better too
• optimise
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.26 2008/02/29 16:38:41 tg Rel $
d39 1
a39 1
	[[ ${wd#$pfx} = $wd || $pfx = ?(/) ]] || wd=\~${wd#$pfx}
d71 1
a71 2
	[[ ${DIRSTACK[0]#$DIRSTACKBASE} = ${DIRSTACK[0]} ]] || \
	    DIRSTACK[0]=\~${DIRSTACK[0]#$DIRSTACKBASE}
d80 1
a80 1
	typeset d t=$1
a81 1
	[[ $t = ~* ]] && t=$DIRSTACKBASE${t#~}
d112 1
a112 1
			[[ $fl$d = 1~* ]] && d=$DIRSTACKBASE${d#~}
d120 1
a120 1
			[[ $fl$d = 1~* ]] && d=$DIRSTACKBASE${d#~}
@


1.26
log
@fix on Interix, where tr(1) is more weird than even Solaris’ XPG4 one…
just do not use ranges, no matter what.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.25 2008/02/29 11:48:32 tg Exp $
d3 2
a4 2
# Copyright (c) 2007
#	Thorsten Glaser <tg@@mirbsd.de>
d25 2
a26 1
# sample mksh initialisation file for interactive shells
d49 1
a49 1
PS1="$(print -n '\001\015')$PS1"	# allow colour codes, framed with ^A
d70 1
a70 1
	DIRSTACK[0]=$(readlink -nf . 2>&- || print -nr -- "$PWD")
@


1.25
log
@handle slowlaris idiotic /usr/xpg4/bin/tr(1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.24 2007/10/25 14:54:00 tg Exp $
d55 3
a57 5
whence -p rot13 >&- || if [[ -x /usr/ucb/tr ]]; then
	alias rot13="/usr/ucb/tr '[A-Za-z]' '[N-ZA-Mn-za-m]'"
else
	alias rot13="tr '[A-Za-z]' '[N-ZA-Mn-za-m]'"
fi
@


1.24
log
@small optimisations
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.23 2007/10/02 01:03:12 tg Stab $
d55 5
a59 1
whence -p rot13 >&- || alias rot13='tr [A-Za-z] [N-ZA-Mn-za-m]'
@


1.23
log
@enable to use colour escapes framed with ^A by default
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.22 2007/09/25 22:36:36 tg Exp $
d31 1
a31 1
	typeset -i10 e=$?
d33 1
a33 1
	(( e )) && print -n -- "$e|"
d37 1
a37 1
	typeset -i n=${COLUMNS:-80}/3; let n="n < 7 ? 7 : n"
d47 1
a47 1
	done; print -r -- "$pfx$wd") '"$PS1 "
@


1.22
log
@• reduce number of readlink(1) / realpath(3) calls by caching the result of
  running it on “~/.” (must be a directory) in a global readonly variable
• if readlink fails, use some more or less sane values (no idea what csh(1)
  does in these cases, maybe some feedback here?)
• optimise, while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.21 2007/09/25 15:48:45 tg Exp $
d48 1
@


1.21
log
@use precmd() to do the errorlevel-display dance, so that yofuh can disable
it more easily, and it got an actual use case
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.20 2007/09/24 20:30:04 tg Exp $
d62 2
d66 3
a68 6
	typeset d thome

	d=$(readlink -nf .)
	thome=$(readlink -nf ~/.)
	DIRSTACK[0]=$d
	[[ ${d##$thome} = $d ]] || DIRSTACK[0]=\~${d##$thome}
d79 1
a79 1
	[[ $t = ~* ]] && t=$HOME${t#~}
d110 1
a110 3
			if [[ $fl$d = 1~* ]]; then
				d=$HOME${d#~}
			fi
d118 2
a119 4
			if [[ $fl$d = 1~* ]]; then
				d=$HOME${d#~}
			fi
			if (( fn && (cpos += ${#d} + 1) >= 79 && ${#d} < 80 )); then
d132 1
a132 1
	typeset d fa=""
d171 1
a171 1
	typeset d fa=""
@


1.20
log
@by popular request, add
• dirs, pushd, popd like ports/shells/csh (Berkeley C shell)
• precmd, chpwd like ports/shells/zsh (Z shell)
and implement keeping ${DIRSTACK[0]} up to date via chpwd()
instead of doing it on entry of pushd and dirs (so that it
can be used directly)

this is slow compared to earlier, but people seem to want it
@
text
@d1 1
a1 1
# $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $
d31 3
a33 1
	:
d35 2
a36 2
PS1='$(e=$?; precmd; ((e)) && print $e\|)${USER:=$(ulimit -c 0; id -un 2>&- || \
    print nobody)}@@${HOSTNAME%%.*}:$(typeset pfx=~ wd=${PWD:-?}
@


1.19
log
@disable annoying privacy invasion, fight the Überwachungsstaat
@
text
@d1 26
d30 4
a33 1
PS1='$(((e = $?)) && print $e\|)${USER:=$(ulimit -c 0; id -un 2>&- || \
d58 161
d228 1
a228 3
# place customisations between this line and the “: RCSID” line below

: $MirOS: src/bin/mksh/dot.mkshrc,v 1.18 2007/07/26 13:37:21 tg Rel $
@


1.18
log
@if the shell doesn't know the cwd, “builtin pwd” won't either
@
text
@d17 1
a17 2
export EDITOR HOSTNAME MKSH=$(whence -p mksh) PS1 TERM USER

d40 1
a40 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.17 2007/06/20 13:38:18 tg Exp $
@


1.17
log
@accomodate stupid Slackware 11 (if you're a slack user, pity you)
@
text
@d5 1
a5 1
    print nobody)}@@${HOSTNAME%%.*}:$(typeset pfx=~ wd=${PWD:-$(builtin pwd)}
d41 1
a41 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.16 2007/06/15 22:00:00 tg Exp $
@


1.16
log
@if invoked as /bin/sh, -sh, sh.static, whatever, activate FPOSIX
this should help inferiour operating systems like Debian… (where
some of the devs, hi waldi@@, don't consider stop() { } invalid…)
@
text
@d3 1
a3 1
PS1='# '; [[ "$(ulimit -c 0; id -u 2>&-)" -eq 0 ]] || PS1='$ '
d5 1
a5 1
    print nobody)}@@${HOSTNAME:=nil}:$(typeset pfx=~ wd=${PWD:-$(builtin pwd)}
d16 1
a16 1
	done; print -r -- "$pfx$wd") '$PS1
d41 1
a41 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.15 2007/05/25 13:51:42 tg Rel $
@


1.15
log
@useful alias for embedded ones, speedup for all
@
text
@d4 3
a6 3
PS1='$(integer e=$?; ((e)) && print $e\|)${USER:=$(ulimit -c 0; id -un 2>&- || \
    print nobody)}@@${HOSTNAME:=nil}:$(local pfx=~ wd=${PWD:-$(builtin pwd)}
	integer n=${COLUMNS:-80}/3; let n="n < 7 ? 7 : n"
d41 1
a41 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.14 2007/05/19 16:35:02 tg Rel $
@


1.14
log
@oops, can't use single quotes inside of singly quoted string, of course…
@
text
@d23 1
d41 1
a41 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.13 2007/05/19 16:33:10 tg Exp $
@


1.13
log
@• whence -p can take closing fd 2 instead of pointing it to /dev/null
• hostname and id should too, besides it's mostly for the shell error
  message of not finding them anyway…
• shorten
@
text
@d6 1
a6 1
	integer n=${COLUMNS:-80}/3; let n='n < 7 ? 7 : n'
d40 1
a40 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.12 2007/04/17 20:07:09 tg Rel $
@


1.12
log
@• remove an unneeded pair of double quotes
• convert another pair of 'em to “…”
@
text
@d1 6
a6 10
: ${EDITOR:=/bin/ed} ${TERM:=vt100}
[[ ${HOSTNAME:=$(ulimit -c 0; hostname -s 2>/dev/null)} = \
    @@(localhost|*([ 	])) ]] && HOSTNAME=$(ulimit -c 0; hostname 2>/dev/null)
if [[ $(ulimit -c 0; id -u 2>/dev/null) -eq 0 ]]; then
	PS1='# '
else
	PS1='$ '
fi; PS1='$(integer rv=$?; ((rv)) && print -n $rv\|)${USER:=$(ulimit -c 0; \
    id -un 2>/dev/null || print -n nobody)}@@${HOSTNAME:=nil}:$(
	local pfx=~ wd=${PWD:-$(builtin pwd)}; integer n=${COLUMNS:-80}/3
d8 1
a8 2
	pfx=; let n="n < 7 ? 7 : n"
	while (( (${#pfx} + ${#wd}) > n )); do
d16 1
a16 2
	done
	print -nr -- "$pfx$wd") '$PS1
d23 2
a24 2
whence -p rot13 >/dev/null || alias rot13='tr [A-Za-z] [N-ZA-Mn-za-m]'
whence -p hd >/dev/null || function hd {
d40 1
a40 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.11 2007/04/17 20:04:08 tg Exp $
@


1.11
log
@change our coding style for shell:

we already do not 'function\nfoo\n{' for shell, like style(9) requires for
C programming, but 'function foo\n{' instead. however, we could treat the
function keyword as indentation initialiser and use 'function foo {' (on a
line for itself) – it looks different, unusual, but acceptable, and mksh's
own output (dumping with the “functions” builtin) does that too (although,
its indentation style sucks, but is legible enough)
@
text
@d23 1
a23 1
export EDITOR HOSTNAME MKSH="$(whence -p mksh)" PS1 TERM USER
d44 1
a44 1
# place customisations between this line and the ": RCSID" line below
d46 1
a46 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.10 2007/04/17 20:00:37 tg Exp $
@


1.10
log
@escape the quoting hell, use a function
tested on Interix
@
text
@d30 1
a30 2
whence -p hd >/dev/null || function hd
{
d37 1
a37 2
function Lstripcom
{
d46 1
a46 1
: $MirOS: src/bin/mksh/dot.mkshrc,v 1.9 2007/04/16 18:54:37 tg Exp $
@


1.9
log
@• from a MirOS point of view:
  place most stuff from /etc/profile in /etc/skel/.mkshrc; admins must make
  sure to copy this file to users' homes on upgrade (benefit: non-login but
  interactive shells also get all the goodies); fix some quoting; simplify,
  reformat, change comments
• from an mksh point of view:
  slight internal changes in dot.mkshrc; external commands are now prefixed
  with “ulimit -c 0”; $TERM is defined; improvement in determining the host
  name (e.g. on Debian if a FQDN is not given); declare locals as such both
  in $PS1 and outside; remove superfluous quoting, quote properly; simplify
  hd alias, add rot13 alias; place RCS ID at the bottom
@
text
@d30 5
a34 2
whence -p hd >/dev/null || alias hd="hexdump -e '"'"%08.8_ax  " 8/1 '\
'"%02X " " - " 8/1 "%02X "'"' -e '\"  |\" \"%_p\"' -e '\"|\\n\"'"
d48 1
a48 1
: $MirOS$
@


1.8
log
@add a 'true' at the end, to not start with an errorlevel >0
@
text
@d1 10
a10 5
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.7 2007/03/04 03:04:23 tg Exp $

: ${EDITOR:=/bin/ed} ${HOSTNAME:=$(hostname -s 2>/dev/null || hostname)}
PS1='$(((rv=$?)) && print $rv\|)${USER:=$(id -un)}@@${HOSTNAME:=nil}:$(
	local pfx=~ wd=${PWD:-$(pwd)}
d12 1
a12 1
	pfx=; let n="( (n = ${COLUMNS:-80} / 3) < 7 ? 7 : n)"
d16 1
a16 1
			wd="${wd#*/}"
d19 1
a19 1
			wd="${wd#?????}"
d22 2
a23 3
	print -r -- "$pfx$wd")'" $(if (( $(id -u) )); then
		print \$; else print \#; fi) "
export EDITOR HOSTNAME MKSH=$(whence -p mksh) PS1 USER
d29 3
a31 3
[ -x /usr/bin/hd ] || eval alias hd="'hexdump -e '\\''\"%08.8_ax  \" 8/1" \
	'"%02X " " - " 8/1 "%02X "'"'\\'' -e '\\''"'"  |" "%_p"'"'\\''" \
	"-e '\\''"'"|\n"'"'\\'' '"
d43 1
a43 1
# Your shell code goes below!
d45 1
a45 1
: Your shell code goes above!
@


1.7
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d1 1
a1 3
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.6 2007/02/17 06:34:46 tg Exp $
#-
# Add user-defined additions at the end, to prevent abortion on failure.
d38 4
@


1.6
log
@optimise away, this had not let me sleep; still the same output
shell quoting mystery ;)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.5 2007/02/17 06:04:48 tg Exp $
d20 2
a21 2
		print \$; else print \#; fi) " MKSH=$(whence -p mksh)
export EDITOR HOSTNAME MKSH PS1 USER
d35 1
a35 2
	cat "$@@" | while read _line; do
		set -o noglob
d38 1
a38 1
	done
@


1.5
log
@fix superfluous spaces appearing twice at the line continuation
points and expanding to larger than 80c, major oops, cought on fwrt
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.4 2007/01/04 23:40:50 tg Exp $
d27 3
a29 3
[ -x /usr/bin/hd ] || eval alias hd=\''hexdump -e '\''\'\'''\''"%08.8_ax' \
	\ '" 8/1 "%02X " " - " 8/1 "%02X "'\''\'\'''\'' -e '\''\'\'''\'\" \
	\ '|" "%_p"'\''\'\'''\'' -e '\''\'\'''\''"|\n"'\''\'\'''\'' '\'
@


1.4
log
@* mention additions go at the bottom (e.g. 'source' scripts), in case
  they fail (due to nonexistence), so that the rest is still executed
* export $MKSH (users can set SHELL=$MKSH here, but I'm conservative)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.3 2006/08/28 01:34:47 tg Exp $
d28 2
a29 2
	'  " 8/1 "%02X " " - " 8/1 "%02X "'\''\'\'''\'' -e '\''\'\'''\'\" \
	'  |" "%_p"'\''\'\'''\'' -e '\''\'\'''\''"|\n"'\''\'\'''\'' '\'
@


1.4.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.6 2007/02/17 06:34:46 tg Exp $
d27 3
a29 3
[ -x /usr/bin/hd ] || eval alias hd="'hexdump -e '\\''\"%08.8_ax  \" 8/1" \
	'"%02X " " - " 8/1 "%02X "'"'\\'' -e '\\''"'"  |" "%_p"'"'\\''" \
	"-e '\\''"'"|\n"'"'\\'' '"
@


1.3
log
@* add the 'hd' alias for hexdump from etc_profile
* optimise
@
text
@d1 3
a3 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.2 2006/08/14 20:32:44 tg Exp $
d20 2
a21 2
		print \$; else print \#; fi) "
export EDITOR HOSTNAME PS1 USER
@


1.2
log
@rewrite stripcom/Lstripcom function, making use of the 'last command
of a pipeline is executed in a subshell' trick, don't use co-process
(because that's verbose twice in an interactive shell profile), move
the noglob block into the while and rid the redundant +o and local.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.1 2006/07/23 18:44:22 tg Exp $
d3 1
a3 1
: ${HOSTNAME:=$(hostname -s 2>/dev/null || hostname)}
a18 1
: ${EDITOR:=/bin/ed}
d25 3
@


1.2.2.1
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.3 2006/08/28 01:34:47 tg Exp $
d3 1
a3 1
: ${EDITOR:=/bin/ed} ${HOSTNAME:=$(hostname -s 2>/dev/null || hostname)}
d19 1
a25 3
[ -x /usr/bin/hd ] || eval alias hd=\''hexdump -e '\''\'\'''\''"%08.8_ax' \
	'  " 8/1 "%02X " " - " 8/1 "%02X "'\''\'\'''\'' -e '\''\'\'''\'\" \
	'  |" "%_p"'\''\'\'''\'' -e '\''\'\'''\''"|\n"'\''\'\'''\'' '\'
@


1.1
log
@* get dot.mkshrc sample from Debian mksh-27.4-2
* sync dot.mkshrc sample with FreeWRT r383
* add some stuff from src/etc/profile and contrib/samples/etc_profile
* sync the latter two with reality and shorten
* teach the user in the mksh installation instructions to install the sample

NB: the sample is also covered by the MirOS licence
@
text
@d1 1
a1 1
# $MirOS$
d27 3
a29 1
function Lstripcom		# strip comments from file
a30 2
	local _line
	set -o noglob
d32 1
a35 1
	set +o noglob
@

