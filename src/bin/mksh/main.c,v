head	1.360;
access;
symbols
	mksh-R57:1.351
	mksh-R56c:1.347
	mksh-R56b:1.342
	mksh-R56:1.342
	mksh-R55:1.332
	mksh-R54:1.322
	mksh-R53a:1.317
	mksh-R53:1.317
	mksh-R52c:1.310
	mksh-R52b:1.306
	mksh-R52:1.306
	mksh-R51:1.300
	mksh-R50f:1.285.2.4
	mksh-R50e:1.285.2.2
	mksh-R50stable:1.285.0.2
	mksh-R50d:1.284
	mksh-R50c:1.284
	mksh-R50b:1.280
	mksh-R50:1.280
	mksh-R49:1.277
	mksh-R48b:1.269
	mksh-R48:1.269
	mksh-R47:1.268
	mksh-R46:1.264
	mksh-R45:1.262
	mksh-R44:1.260
	mksh-R43:1.260
	mksh-R42b:1.260
	mksh-R41c:1.245.2.4
	mksh-R41b:1.245.2.4
	mksh-R42:1.260
	mksh-R41:1.245
	mksh-R41stable:1.245.0.2
	mksh-wheezy:1.224.0.2
	tg-multikey-bind:1.222.0.2
	mksh-R40f:1.195.2.8
	mksh-R40e:1.195.2.7
	mksh-R40d:1.195.2.4
	mksh-R40c:1.195.2.4
	mksh-R40b:1.195.2.2
	mksh-R40stable:1.195.0.2
	mksh-R40:1.193
	mksh-R39c:1.162
	mksh-R39b:1.162
	tg-wcswidth-behaviour:1.154.0.2
	tg-nameref:1.143.0.2
	mksh-R39:1.136
	tg-mksh-printf-builtin:1.133.0.2
	mksh-R38c:1.132
	mksh-R38b:1.129
	mksh-R38:1.129
	mksh-R37c:1.125
	mksh-R37b:1.124
	mksh-R37:1.122
	mksh-R36b:1.116
	tg-aalloc-experimental_BASE:1.113
	tg-aalloc-experimental:1.113.0.2
	mksh-R36:1.104
	mksh-R35b:1.101
	mksh-R35:1.101
	mksh-R33d:1.95
	mksh-R33c:1.95
	mksh-R33b:1.94
	MIRBSD_10:1.92.0.2
	MIRBSD_10_BASE:1.92
	mksh-R33:1.92
	mksh-R32:1.89
	mksh-R31d:1.87
	mksh-R31c:1.87
	mksh-R31b:1.87
	mksh-R31:1.87
	mksh-R30:1.84
	mksh-R29g:1.74.2.2
	mksh-R29f:1.74.2.1
	mksh-R29e:1.74.2.1
	mksh-R29stable:1.74.0.2
	mksh-R29d:1.74
	mksh-R29c:1.74
	mksh-R29b:1.73
	mksh-R29:1.73
	mksh-R28:1.48
	tg-mksh-plan9ape_BASE:1.48
	tg-mksh-plan9ape:1.44.0.2
	mksh-R27e:1.40
	MIRBSD_9_BASE:1.39
	mksh-R27d:1.39
	mksh-R27:1.38
	mksh-R26c:1.33
	mksh-R26b:1.31
	MIRBSD_8:1.31.0.2
	MIRBSD_8_BASE:1.31
	mksh-R26:1.31
	mksh-R25:1.30
	mksh-R24c:1.26
	mksh-R24b:1.24
	mksh-R24:1.22
	mksh-R23:1.14
	mksh-R22:1.10
	mksh-R21:1.4;
locks; strict;
comment	@ * @;


1.360
date	2019.12.30.03.58.56;	author tg;	state Exp;
branches;
next	1.359;
commitid	1005E09760D6DFD4643;

1.359
date	2019.12.30.03.45.13;	author tg;	state Exp;
branches;
next	1.358;
commitid	1005E0972CA305775E7;

1.358
date	2019.12.30.01.29.53;	author tg;	state Exp;
branches;
next	1.357;
commitid	1005E09532721D23AB7;

1.357
date	2019.12.30.01.13.48;	author tg;	state Exp;
branches;
next	1.356;
commitid	1005E094F5633C8F0AB;

1.356
date	2019.12.30.01.10.57;	author tg;	state Exp;
branches;
next	1.355;
commitid	1005E094E9A55F97D93;

1.355
date	2019.12.30.00.45.15;	author tg;	state Exp;
branches;
next	1.354;
commitid	1005E0948AF5CC27EE6;

1.354
date	2019.12.11.23.58.19;	author tg;	state Exp;
branches;
next	1.353;
commitid	1005DF182AD50645981;

1.353
date	2019.12.11.20.11.13;	author tg;	state Exp;
branches;
next	1.352;
commitid	1005DF14D4D1BAFC22E;

1.352
date	2019.08.02.00.21.53;	author tg;	state Exp;
branches;
next	1.351;
commitid	1005D438238756E008E;

1.351
date	2019.01.05.13.24.18;	author tg;	state Exp;
branches;
next	1.350;
commitid	1005C30B01A0720D22C;

1.350
date	2018.10.30.17.10.15;	author tg;	state Exp;
branches;
next	1.349;
commitid	1005BD8907D11D25921;

1.349
date	2018.05.08.17.37.36;	author tg;	state Exp;
branches;
next	1.348;
commitid	1005AF1E0675260363E;

1.348
date	2018.04.27.16.54.45;	author tg;	state Exp;
branches;
next	1.347;
commitid	1005AE355E95FBE2884;

1.347
date	2018.01.13.21.45.07;	author tg;	state Exp;
branches;
next	1.346;
commitid	1005A5A7DF440A657B7;

1.346
date	2018.01.13.21.38.08;	author tg;	state Exp;
branches;
next	1.345;
commitid	1005A5A7C0944B414C1;

1.345
date	2017.10.14.21.05.22;	author tg;	state Exp;
branches;
next	1.344;
commitid	10059E27BDD53C0EC62;

1.344
date	2017.10.13.23.02.11;	author tg;	state Exp;
branches;
next	1.343;
commitid	10059E146084E33982C;

1.343
date	2017.10.10.21.19.43;	author tg;	state Exp;
branches;
next	1.342;
commitid	10059DD397B6059EE3B;

1.342
date	2017.04.28.11.13.47;	author tg;	state Exp;
branches;
next	1.341;
commitid	100590323E86CD0E167;

1.341
date	2017.04.28.01.15.50;	author tg;	state Exp;
branches;
next	1.340;
commitid	1005902978D70FC7074;

1.340
date	2017.04.27.23.35.09;	author tg;	state Exp;
branches;
next	1.339;
commitid	100590280444AFBDBF7;

1.339
date	2017.04.27.22.38.49;	author tg;	state Exp;
branches;
next	1.338;
commitid	1005902730E2BEC7242;

1.338
date	2017.04.27.20.22.25;	author tg;	state Exp;
branches;
next	1.337;
commitid	1005902531266D3FCB6;

1.337
date	2017.04.27.19.33.51;	author tg;	state Exp;
branches;
next	1.336;
commitid	100590247A92C66CAF9;

1.336
date	2017.04.27.19.16.08;	author tg;	state Exp;
branches;
next	1.335;
commitid	1005902438A577EF826;

1.335
date	2017.04.27.18.44.35;	author tg;	state Exp;
branches;
next	1.334;
commitid	10059023C2A2153697B;

1.334
date	2017.04.22.00.07.08;	author tg;	state Exp;
branches;
next	1.333;
commitid	10058FA9D043131DCC0;

1.333
date	2017.04.21.20.06.04;	author tg;	state Exp;
branches;
next	1.332;
commitid	10058FA66392543430F;

1.332
date	2017.04.12.16.01.45;	author tg;	state Exp;
branches;
next	1.331;
commitid	10058EE4F791111D6F8;

1.331
date	2017.04.08.01.07.17;	author tg;	state Exp;
branches;
next	1.330;
commitid	10058E837C565871E52;

1.330
date	2017.04.06.01.59.56;	author tg;	state Exp;
branches;
next	1.329;
commitid	10058E5A1067AFA1BBA;

1.329
date	2017.04.02.15.00.43;	author tg;	state Exp;
branches;
next	1.328;
commitid	10058E1121E64BBAB7B;

1.328
date	2017.03.19.22.31.27;	author tg;	state Exp;
branches;
next	1.327;
commitid	10058CF06C37397F386;

1.327
date	2017.03.19.22.23.45;	author tg;	state Exp;
branches;
next	1.326;
commitid	10058CF050B0C330CBC;

1.326
date	2017.03.19.20.59.26;	author tg;	state Exp;
branches;
next	1.325;
commitid	10058CEF1322163CCA4;

1.325
date	2017.03.19.20.36.07;	author tg;	state Exp;
branches;
next	1.324;
commitid	10058CEEBC01764DE9F;

1.324
date	2017.03.11.23.22.36;	author tg;	state Exp;
branches;
next	1.323;
commitid	10058C486CF5C28D59E;

1.323
date	2017.03.11.22.58.51;	author tg;	state Exp;
branches;
next	1.322;
commitid	10058C4813B00114587;

1.322
date	2016.11.11.23.48.30;	author tg;	state Exp;
branches;
next	1.321;
commitid	100582658D43CBE5F67;

1.321
date	2016.11.11.23.31.35;	author tg;	state Exp;
branches;
next	1.320;
commitid	100582654B972655F84;

1.320
date	2016.10.26.22.55.51;	author tg;	state Exp;
branches;
next	1.319;
commitid	1005811348569735E44;

1.319
date	2016.10.22.23.56.50;	author tg;	state Exp;
branches;
next	1.318;
commitid	100580BFCCF7344F495;

1.318
date	2016.09.01.12.59.10;	author tg;	state Exp;
branches;
next	1.317;
commitid	10057C8260A04757349;

1.317
date	2016.08.04.20.51.35;	author tg;	state Exp;
branches;
next	1.316;
commitid	10057A3AAA90034EF8B;

1.316
date	2016.08.04.20.32.14;	author tg;	state Exp;
branches;
next	1.315;
commitid	10057A3A66701A72552;

1.315
date	2016.08.04.20.31.01;	author tg;	state Exp;
branches;
next	1.314;
commitid	10057A3A5F96CCF061E;

1.314
date	2016.07.25.21.05.22;	author tg;	state Exp;
branches;
next	1.313;
commitid	10057967F184AB0E82A;

1.313
date	2016.07.25.20.36.27;	author tg;	state Exp;
branches;
next	1.312;
commitid	1005796785B4D2EFC61;

1.312
date	2016.07.25.00.04.45;	author tg;	state Exp;
branches;
next	1.311;
commitid	1005795579F14A3FE5C;

1.311
date	2016.07.24.23.10.03;	author tg;	state Exp;
branches;
next	1.310;
commitid	10057954AD0356E0260;

1.310
date	2016.02.26.21.53.36;	author tg;	state Exp;
branches;
next	1.309;
commitid	10056D0C89E7DCB5486;

1.309
date	2016.02.26.18.48.12;	author tg;	state Exp;
branches;
next	1.308;
commitid	10056D09DEF7B46FCA2;

1.308
date	2016.02.24.01.44.46;	author tg;	state Exp;
branches;
next	1.307;
commitid	10056CD0AFA12B0CBA5;

1.307
date	2016.01.21.18.24.42;	author tg;	state Exp;
branches;
next	1.306;
commitid	10056A12268001BF859;

1.306
date	2015.10.09.21.36.57;	author tg;	state Exp;
branches;
next	1.305;
commitid	100561833456A230F8F;

1.305
date	2015.10.09.17.48.51;	author tg;	state Exp;
branches;
next	1.304;
commitid	1005617FE066005352E;

1.304
date	2015.10.09.16.11.16;	author tg;	state Exp;
branches;
next	1.303;
commitid	1005617E72E4A2BA371;

1.303
date	2015.10.05.17.58.59;	author tg;	state Exp;
branches;
next	1.302;
commitid	1005612BA62412FC278;

1.302
date	2015.09.05.19.19.06;	author tg;	state Exp;
branches;
next	1.301;
commitid	10055EB402C54C3076B;

1.301
date	2015.08.13.22.06.22;	author tg;	state Exp;
branches;
next	1.300;
commitid	10055CD14E772441249;

1.300
date	2015.07.10.19.36.35;	author tg;	state Exp;
branches;
next	1.299;
commitid	10055A01EBD784EE31A;

1.299
date	2015.07.09.20.52.40;	author tg;	state Exp;
branches;
next	1.298;
commitid	100559EDF161DEE9DD2;

1.298
date	2015.07.09.19.46.42;	author tg;	state Exp;
branches;
next	1.297;
commitid	100559ECFAC4F39D69B;

1.297
date	2015.07.09.19.28.20;	author tg;	state Exp;
branches;
next	1.296;
commitid	100559ECB63048E9D39;

1.296
date	2015.07.09.19.19.10;	author tg;	state Exp;
branches;
next	1.295;
commitid	100559EC93854E741C4;

1.295
date	2015.07.06.17.48.34;	author tg;	state Exp;
branches;
next	1.294;
commitid	100559ABF230C8CC8EB;

1.294
date	2015.07.05.19.37.16;	author tg;	state Exp;
branches;
next	1.293;
commitid	1005599876B5247136B;

1.293
date	2015.04.29.20.07.33;	author tg;	state Exp;
branches;
next	1.292;
commitid	100554139453DB97755;

1.292
date	2015.04.19.18.50.37;	author tg;	state Exp;
branches;
next	1.291;
commitid	1005533F8D6407346B7;

1.291
date	2015.04.11.22.03.30;	author tg;	state Exp;
branches;
next	1.290;
commitid	1005529999F77F915AE;

1.290
date	2015.03.14.05.23.15;	author tg;	state Exp;
branches;
next	1.289;
commitid	1005503C5CA29059CD3;

1.289
date	2015.03.08.22.54.33;	author tg;	state Exp;
branches;
next	1.288;
commitid	10054FCD1444FC13F3C;

1.288
date	2015.03.08.21.30.21;	author tg;	state Exp;
branches;
next	1.287;
commitid	10054FCBF786B35A495;

1.287
date	2015.02.13.12.51.31;	author tg;	state Exp;
branches;
next	1.286;
commitid	10054DDF3221517B878;

1.286
date	2014.11.25.21.13.28;	author tg;	state Exp;
branches;
next	1.285;
commitid	1005474F00E09321C83;

1.285
date	2014.10.12.21.58.52;	author tg;	state Exp;
branches
	1.285.2.1;
next	1.284;
commitid	100543AF9780895A8EB;

1.284
date	2014.10.03.17.19.27;	author tg;	state Exp;
branches;
next	1.283;
commitid	100542EDAB6504F28CB;

1.283
date	2014.10.02.13.55.16;	author tg;	state Exp;
branches;
next	1.282;
commitid	100542D595C5B66936A;

1.282
date	2014.10.02.13.53.54;	author tg;	state Exp;
branches;
next	1.281;
commitid	100542D590A04B429DE;

1.281
date	2014.09.12.20.23.33;	author tg;	state Exp;
branches;
next	1.280;
commitid	1005413562C19BFAEF1;

1.280
date	2014.06.09.12.28.17;	author tg;	state Exp;
branches;
next	1.279;
commitid	1005395A8677E96EF7B;

1.279
date	2014.01.16.13.59.12;	author tg;	state Exp;
branches;
next	1.278;
commitid	10052D7E5C83D449607;

1.278
date	2014.01.16.13.54.45;	author tg;	state Exp;
branches;
next	1.277;
commitid	10052D7E4490050520F;

1.277
date	2014.01.11.18.09.40;	author tg;	state Exp;
branches;
next	1.276;
commitid	10052D188DD7DFEC194;

1.276
date	2014.01.11.16.26.28;	author tg;	state Exp;
branches;
next	1.275;
commitid	10052D170CC442C6ECB;

1.275
date	2014.01.05.21.57.26;	author tg;	state Exp;
branches;
next	1.274;
commitid	10052C9D445413B34DF;

1.274
date	2014.01.05.19.11.45;	author tg;	state Exp;
branches;
next	1.273;
commitid	10052C9AE727A4482D3;

1.273
date	2013.11.30.17.33.50;	author tg;	state Exp;
branches;
next	1.272;
commitid	100529A2193602D314C;

1.272
date	2013.11.17.22.23.28;	author tg;	state Exp;
branches;
next	1.271;
commitid	100528941F42B4F3BA7;

1.271
date	2013.10.09.11.59.29;	author tg;	state Exp;
branches;
next	1.270;
commitid	10052554535524C4C97;

1.270
date	2013.09.10.17.33.02;	author tg;	state Exp;
branches;
next	1.269;
commitid	100522F57C13E265FDE;

1.269
date	2013.07.25.18.07.46;	author tg;	state Exp;
branches;
next	1.268;
commitid	10051F1695C46761A92;

1.268
date	2013.07.21.18.47.19;	author tg;	state Exp;
branches;
next	1.267;
commitid	10051EC2CBD68BDF6A5;

1.267
date	2013.07.21.18.36.01;	author tg;	state Exp;
branches;
next	1.266;
commitid	10051EC29F9411252FA;

1.266
date	2013.06.03.22.28.04;	author tg;	state Exp;
branches;
next	1.265;
commitid	10051AD188C1F05BE20;

1.265
date	2013.06.02.03.09.16;	author tg;	state Exp;
branches;
next	1.264;
commitid	10051AAB6AE4E828507;

1.264
date	2013.05.02.20.21.43;	author tg;	state Exp;
branches;
next	1.263;
commitid	1005182CAE814B1B129;

1.263
date	2013.04.27.18.56.41;	author tg;	state Exp;
branches;
next	1.262;
commitid	100517C1F7D1BF97F87;

1.262
date	2013.04.26.21.22.46;	author tg;	state Exp;
branches;
next	1.261;
commitid	100517AEF6C22DD1AE7;

1.261
date	2013.03.29.17.33.07;	author tg;	state Exp;
branches;
next	1.260;
commitid	1005155D01655460A00;

1.260
date	2013.02.10.21.42.16;	author tg;	state Exp;
branches;
next	1.259;
commitid	100511814387670B07A;

1.259
date	2013.02.10.21.17.07;	author tg;	state Exp;
branches;
next	1.258;
commitid	10051180E6A57FFC1F3;

1.258
date	2013.02.10.19.05.37;	author tg;	state Exp;
branches;
next	1.257;
commitid	1005117EF9844D7B579;

1.257
date	2013.02.10.18.17.30;	author tg;	state Exp;
branches;
next	1.256;
commitid	1005117E43D0E3438DA;

1.256
date	2013.02.10.17.55.57;	author tg;	state Exp;
branches;
next	1.255;
commitid	1005117DF3777352F4C;

1.255
date	2013.02.10.17.43.07;	author tg;	state Exp;
branches;
next	1.254;
commitid	1005117DC37481F916D;

1.254
date	2013.02.10.17.41.05;	author tg;	state Exp;
branches;
next	1.253;
commitid	1005117DBC709D0BEB4;

1.253
date	2013.02.10.17.38.14;	author tg;	state Exp;
branches;
next	1.252;
commitid	1005117DB0F3E1A98CE;

1.252
date	2013.01.06.18.44.07;	author tg;	state Exp;
branches;
next	1.251;
commitid	10050E9C6082D2C1CD9;

1.251
date	2013.01.01.22.23.16;	author tg;	state Exp;
branches;
next	1.250;
commitid	10050E361E825906F7E;

1.250
date	2013.01.01.20.45.03;	author tg;	state Exp;
branches;
next	1.249;
commitid	10050E34AE3215C257E;

1.249
date	2012.12.17.23.18.07;	author tg;	state Exp;
branches;
next	1.248;
commitid	10050CFA81334F40D7F;

1.248
date	2012.12.07.23.46.36;	author tg;	state Exp;
branches;
next	1.247;
commitid	10050C27FDC255CF0A0;

1.247
date	2012.12.05.19.38.21;	author tg;	state Exp;
branches;
next	1.246;
commitid	10050BFA2C0046FB3B9;

1.246
date	2012.11.30.20.19.13;	author tg;	state Exp;
branches;
next	1.245;
commitid	10050B914D41435E735;

1.245
date	2012.11.30.19.58.47;	author tg;	state Exp;
branches
	1.245.2.1;
next	1.244;
commitid	10050B9100F36FFAD25;

1.244
date	2012.11.30.19.51.24;	author tg;	state Exp;
branches;
next	1.243;
commitid	10050B90E3B6BD12D5D;

1.243
date	2012.11.30.19.25.04;	author tg;	state Exp;
branches;
next	1.242;
commitid	10050B907135D4B5928;

1.242
date	2012.11.30.19.02.09;	author tg;	state Exp;
branches;
next	1.241;
commitid	10050B902B82AAA0C3F;

1.241
date	2012.11.26.22.49.48;	author tg;	state Exp;
branches;
next	1.240;
commitid	10050B3F2237B099269;

1.240
date	2012.11.20.18.07.42;	author tg;	state Exp;
branches;
next	1.239;
commitid	10050ABC70641D0E46B;

1.239
date	2012.11.20.17.42.29;	author tg;	state Exp;
branches;
next	1.238;
commitid	10050ABC11D40F1EAFA;

1.238
date	2012.11.12.18.28.39;	author tg;	state Exp;
branches;
next	1.237;
commitid	10050A13FEF109064C5;

1.237
date	2012.10.30.20.49.42;	author tg;	state Exp;
branches;
next	1.236;
commitid	10050903D7D16EDB58E;

1.236
date	2012.10.30.20.13.19;	author tg;	state Exp;
branches;
next	1.235;
commitid	100509034F50DD7C6D5;

1.235
date	2012.10.30.20.07.12;	author tg;	state Exp;
branches;
next	1.234;
commitid	10050903386452ACBF1;

1.234
date	2012.10.30.20.07.00;	author tg;	state Exp;
branches;
next	1.233;
commitid	1005090337C7A669439;

1.233
date	2012.10.22.20.19.14;	author tg;	state Exp;
branches;
next	1.232;
commitid	1005085AA537A17A752;

1.232
date	2012.10.22.16.53.22;	author tg;	state Exp;
branches;
next	1.231;
commitid	10050857A0A617725BC;

1.231
date	2012.10.21.21.39.04;	author tg;	state Exp;
branches;
next	1.230;
commitid	10050846B5B2B1A2932;

1.230
date	2012.10.21.21.26.40;	author tg;	state Exp;
branches;
next	1.229;
commitid	1005084678C510CF7E4;

1.229
date	2012.10.21.17.16.45;	author tg;	state Exp;
branches;
next	1.228;
commitid	10050842E15653ECAC0;

1.228
date	2012.09.21.17.20.21;	author tg;	state Exp;
branches;
next	1.227;
commitid	100505CA1BB6B435496;

1.227
date	2012.09.07.21.02.43;	author tg;	state Exp;
branches;
next	1.226;
commitid	100504A600348A7ECE5;

1.226
date	2012.07.22.15.56.50;	author tg;	state Exp;
branches;
next	1.225;
commitid	100500C22DA33CA17CF;

1.225
date	2012.07.01.15.38.06;	author tg;	state Exp;
branches;
next	1.224;
commitid	1004FF06EE567E89991;

1.224
date	2012.06.28.20.05.08;	author tg;	state Exp;
branches
	1.224.2.1;
next	1.223;
commitid	1004FECB8FB4B2757ED;

1.223
date	2012.06.24.20.15.47;	author tg;	state Exp;
branches;
next	1.222;
commitid	1004FE7757E2D446E8E;

1.222
date	2012.05.05.17.32.33;	author tg;	state Exp;
branches;
next	1.221;
commitid	1004FA5643909944950;

1.221
date	2012.05.04.22.34.51;	author tg;	state Exp;
branches;
next	1.220;
commitid	1004FA4598C7DB8428A;

1.220
date	2012.05.04.22.18.26;	author tg;	state Exp;
branches;
next	1.219;
commitid	1004FA455C411397094;

1.219
date	2012.05.04.21.47.02;	author tg;	state Exp;
branches;
next	1.218;
commitid	1004FA44E6C59CC7A07;

1.218
date	2012.05.04.21.15.33;	author tg;	state Exp;
branches;
next	1.217;
commitid	1004FA4470B7AD85C13;

1.217
date	2012.05.04.20.49.05;	author tg;	state Exp;
branches;
next	1.216;
commitid	1004FA4409A67B135DE;

1.216
date	2012.04.14.16.07.47;	author tg;	state Exp;
branches;
next	1.215;
commitid	1004F89A0D311D70891;

1.215
date	2012.04.06.12.59.26;	author tg;	state Exp;
branches;
next	1.214;
commitid	1004F7EE8B85815EBA4;

1.214
date	2012.03.31.17.30.00;	author tg;	state Exp;
branches;
next	1.213;
commitid	1004F773F2D0016E021;

1.213
date	2012.03.31.17.08.52;	author tg;	state Exp;
branches;
next	1.212;
commitid	1004F773A343DB57AB3;

1.212
date	2012.03.27.22.36.52;	author tg;	state Exp;
branches;
next	1.211;
commitid	1004F7240673EAD3A5A;

1.211
date	2012.03.25.14.28.14;	author tg;	state Exp;
branches;
next	1.210;
commitid	1004F6F2B60460FB25D;

1.210
date	2012.03.24.22.11.41;	author tg;	state Exp;
branches;
next	1.209;
commitid	1004F6E46B45C82FE79;

1.209
date	2012.03.23.22.36.23;	author tg;	state Exp;
branches;
next	1.208;
commitid	1004F6CFAED5CADF570;

1.208
date	2012.03.23.21.58.21;	author tg;	state Exp;
branches;
next	1.207;
commitid	1004F6CF1C82CE9B908;

1.207
date	2012.03.23.19.38.12;	author tg;	state Exp;
branches;
next	1.206;
commitid	1004F6CD13A7403AC2D;

1.206
date	2012.03.23.18.58.15;	author tg;	state Exp;
branches;
next	1.205;
commitid	1004F6CC7DE34F0AB29;

1.205
date	2012.03.03.21.30.56;	author tg;	state Exp;
branches;
next	1.204;
commitid	1004F528D8E7F3D0F12;

1.204
date	2012.03.03.21.13.50;	author tg;	state Exp;
branches;
next	1.203;
commitid	1004F5289A41DFEBF5D;

1.203
date	2012.02.11.22.45.04;	author tg;	state Exp;
branches;
next	1.202;
commitid	1004F36EF7417961ACB;

1.202
date	2012.01.29.01.41.14;	author tg;	state Exp;
branches;
next	1.201;
commitid	1004F24A3CB1AC86618;

1.201
date	2011.11.08.22.07.14;	author tg;	state Exp;
branches;
next	1.200;
commitid	1004EB9A7F80119200E;

1.200
date	2011.10.07.19.51.28;	author tg;	state Exp;
branches;
next	1.199;
commitid	1004E8F58575DF1C9F8;

1.199
date	2011.09.07.15.24.17;	author tg;	state Exp;
branches;
next	1.198;
commitid	1004E678C6929FE60A6;

1.198
date	2011.08.27.18.06.48;	author tg;	state Exp;
branches;
next	1.197;
commitid	1004E5932432420AA61;

1.197
date	2011.08.27.17.30.06;	author tg;	state Exp;
branches;
next	1.196;
commitid	1004E5929AF6944B2F7;

1.196
date	2011.07.16.17.08.19;	author tg;	state Exp;
branches;
next	1.195;
commitid	1004E21C5974E8E1C5E;

1.195
date	2011.07.06.22.21.57;	author tg;	state Exp;
branches
	1.195.2.1;
next	1.194;
commitid	1004E14E010182825E7;

1.194
date	2011.07.02.17.57.39;	author tg;	state Exp;
branches;
next	1.193;
commitid	1004E0F5C27271F5B00;

1.193
date	2011.06.05.19.58.18;	author tg;	state Exp;
branches;
next	1.192;
commitid	1004DEBDFBB243C0DCF;

1.192
date	2011.06.04.16.42.30;	author tg;	state Exp;
branches;
next	1.191;
commitid	1004DEA608B78E32C69;

1.191
date	2011.05.29.16.31.42;	author tg;	state Exp;
branches;
next	1.190;
commitid	1004DE274F9085CC4DD;

1.190
date	2011.04.17.12.24.43;	author tg;	state Exp;
branches;
next	1.189;
commitid	1004DAADC101DEEF61A;

1.189
date	2011.04.09.21.01.02;	author tg;	state Exp;
branches;
next	1.188;
commitid	1004DA0C9186AA3EA10;

1.188
date	2011.04.02.13.55.35;	author tg;	state Exp;
branches;
next	1.187;
commitid	1004D972AEF77778ACD;

1.187
date	2011.03.27.18.50.05;	author tg;	state Exp;
branches;
next	1.186;
commitid	1004D8F86AA0EB92572;

1.186
date	2011.03.26.19.43.47;	author tg;	state Exp;
branches;
next	1.185;
commitid	1004D8E4204410B09C9;

1.185
date	2011.03.26.19.35.35;	author tg;	state Exp;
branches;
next	1.184;
commitid	1004D8E401C12E4FD1E;

1.184
date	2011.03.16.20.56.33;	author tg;	state Exp;
branches;
next	1.183;
commitid	1004D8124057DD4A66A;

1.183
date	2011.03.16.20.43.34;	author tg;	state Exp;
branches;
next	1.182;
commitid	1004D81210C4B0F8E31;

1.182
date	2011.03.16.20.26.35;	author tg;	state Exp;
branches;
next	1.181;
commitid	1004D811CB27C272DCB;

1.181
date	2011.03.13.16.03.52;	author tg;	state Exp;
branches;
next	1.180;
commitid	1004D7CE9C2063207F0;

1.180
date	2011.03.13.01.20.21;	author tg;	state Exp;
branches;
next	1.179;
commitid	1004D7C1BE368F5B459;

1.179
date	2011.03.05.21.43.17;	author tg;	state Exp;
branches;
next	1.178;
commitid	1004D72AE603B079174;

1.178
date	2011.02.27.19.29.31;	author tg;	state Exp;
branches;
next	1.177;
commitid	1004D6AA6322ACDE0DB;

1.177
date	2011.02.18.22.26.10;	author tg;	state Exp;
branches;
next	1.176;
commitid	1004D5EF0ED2C0C9394;

1.176
date	2011.02.11.01.18.18;	author tg;	state Exp;
branches;
next	1.175;
commitid	1004D548C4E66D17A12;

1.175
date	2011.01.21.21.07.11;	author tg;	state Exp;
branches;
next	1.174;
commitid	1004D39F592365AB7E3;

1.174
date	2011.01.21.21.04.44;	author tg;	state Exp;
branches;
next	1.173;
commitid	1004D39F4C639F3DCA7;

1.173
date	2010.11.01.17.29.04;	author tg;	state Exp;
branches;
next	1.172;
commitid	1004CCEF8F323B360DC;

1.172
date	2010.09.14.21.26.14;	author tg;	state Exp;
branches;
next	1.171;
commitid	1004C8FE654576B0E25;

1.171
date	2010.09.14.21.00.13;	author tg;	state Exp;
branches;
next	1.170;
commitid	1004C8FE2003662B45F;

1.170
date	2010.08.28.20.22.20;	author tg;	state Exp;
branches;
next	1.169;
commitid	1004C796FE40C544CCE;

1.169
date	2010.08.28.18.50.54;	author tg;	state Exp;
branches;
next	1.168;
commitid	1004C795A82072326AF;

1.168
date	2010.08.28.15.39.19;	author tg;	state Exp;
branches;
next	1.167;
commitid	1004C792DBD73FFB797;

1.167
date	2010.07.04.17.45.15;	author tg;	state Exp;
branches;
next	1.166;
commitid	1004C30C8946816B0C1;

1.166
date	2010.07.04.17.33.55;	author tg;	state Exp;
branches;
next	1.165;
commitid	1004C30C5ED28DF693B;

1.165
date	2010.05.22.12.49.15;	author tg;	state Exp;
branches;
next	1.164;
commitid	1004BF7D29E03EBF637;

1.164
date	2010.04.20.17.28.20;	author tg;	state Exp;
branches;
next	1.163;
commitid	1004BCDE44A713F7C1F;

1.163
date	2010.03.27.20.36.26;	author tg;	state Exp;
branches;
next	1.162;
commitid	1004BAE6C4B05F1BFE4;

1.162
date	2010.01.29.09.34.29;	author tg;	state Exp;
branches;
next	1.161;
commitid	1004B62ABB7333ED94C;

1.161
date	2010.01.28.15.18.48;	author tg;	state Exp;
branches;
next	1.160;
commitid	1004B61A9B525E85DF5;

1.160
date	2010.01.25.14.38.02;	author tg;	state Exp;
branches;
next	1.159;
commitid	1004B5DACDC357C3689;

1.159
date	2010.01.25.14.07.38;	author tg;	state Exp;
branches;
next	1.158;
commitid	1004B5DA5BE4FE11A27;

1.158
date	2010.01.01.17.44.08;	author tg;	state Exp;
branches;
next	1.157;
commitid	1004B3E342E71FBD2B2;

1.157
date	2009.12.05.17.43.47;	author tg;	state Exp;
branches;
next	1.156;
commitid	1004B1A9BCF3E49BC5B;

1.156
date	2009.12.05.13.02.26;	author tg;	state Exp;
branches;
next	1.155;
commitid	1004B1A59F8418F8C58;

1.155
date	2009.11.28.15.38.29;	author tg;	state Exp;
branches;
next	1.154;
commitid	1004B1144002949633C;

1.154
date	2009.10.30.14.37.42;	author tg;	state Exp;
branches;
next	1.153;
commitid	1004AEAFA4D5BAFA082;

1.153
date	2009.10.17.21.16.02;	author tg;	state Exp;
branches;
next	1.152;
commitid	1004ADA339B53B8111A;

1.152
date	2009.10.02.18.08.34;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004AC641341D9D9D02;

1.151
date	2009.09.29.12.28.13;	author tg;	state Exp;
branches;
next	1.150;
commitid	1004AC1FD4F2AA51F2E;

1.150
date	2009.09.27.10.31.06;	author tg;	state Exp;
branches;
next	1.149;
commitid	1004ABF3E7C478CDC70;

1.149
date	2009.09.26.03.40.00;	author tg;	state Exp;
branches;
next	1.148;
commitid	1004ABD8CE62D55CFD8;

1.148
date	2009.09.26.01.08.27;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004ABD699B6AF085CB;

1.147
date	2009.09.24.17.15.31;	author tg;	state Exp;
branches;
next	1.146;
commitid	1004ABBA8D95908292B;

1.146
date	2009.09.23.18.04.57;	author tg;	state Exp;
branches;
next	1.145;
commitid	1004ABA62C8171BD8E4;

1.145
date	2009.09.20.16.40.55;	author tg;	state Exp;
branches;
next	1.144;
commitid	1004AB65AF3542D0922;

1.144
date	2009.09.06.17.42.13;	author tg;	state Exp;
branches;
next	1.143;
commitid	1004AA3F479204C1E97;

1.143
date	2009.08.29.11.26.44;	author tg;	state Exp;
branches
	1.143.2.1;
next	1.142;
commitid	1004A990B8A591CE9CC;

1.142
date	2009.08.28.21.01.26;	author tg;	state Exp;
branches;
next	1.141;
commitid	1004A9845725143AD02;

1.141
date	2009.08.28.20.38.42;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004A98405B0186F15C;

1.140
date	2009.08.28.20.30.57;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004A983E6B745731A0;

1.139
date	2009.08.28.19.57.42;	author tg;	state Exp;
branches;
next	1.138;
commitid	1004A98365B7809CDA1;

1.138
date	2009.08.28.18.53.59;	author tg;	state Exp;
branches;
next	1.137;
commitid	1004A9827D2091BAE42;

1.137
date	2009.08.08.13.08.51;	author tg;	state Exp;
branches;
next	1.136;
commitid	1004A7D785D73D49CFA;

1.136
date	2009.07.25.21.31.26;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004A6B79B87CB15A8B;

1.135
date	2009.07.25.20.52.41;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004A6B70886FFC8C3F;

1.134
date	2009.07.25.20.26.32;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004A6B6A5D6F28009F;

1.133
date	2009.06.11.12.42.19;	author tg;	state Exp;
branches;
next	1.132;
commitid	1004A30FBB114E3FED9;

1.132
date	2009.06.10.18.12.47;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004A2FF7913BD44883;

1.131
date	2009.06.08.20.06.47;	author tg;	state Exp;
branches;
next	1.130;
commitid	1004A2D6F3A31FB4CBC;

1.130
date	2009.06.07.22.28.04;	author tg;	state Exp;
branches;
next	1.129;
commitid	1004A2C3EEE42B8D086;

1.129
date	2009.05.27.19.52.37;	author tg;	state Exp;
branches;
next	1.128;
commitid	1004A1D99540BF61ECF;

1.128
date	2009.05.16.21.00.51;	author tg;	state Exp;
branches;
next	1.127;
commitid	1004A0F296C32088698;

1.127
date	2009.05.16.18.40.07;	author tg;	state Exp;
branches;
next	1.126;
commitid	1004A0F087409E93A5D;

1.126
date	2009.05.16.16.59.37;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004A0EF0664EF4168D;

1.125
date	2009.04.07.19.43.27;	author tg;	state Exp;
branches;
next	1.124;
commitid	10049DBACB7766F4210;

1.124
date	2009.04.05.12.35.31;	author tg;	state Exp;
branches;
next	1.123;
commitid	10049D8A5A72FBB1A39;

1.123
date	2009.04.05.11.44.56;	author tg;	state Exp;
branches;
next	1.122;
commitid	10049D899A94E2F421B;

1.122
date	2009.03.22.17.47.37;	author tg;	state Exp;
branches;
next	1.121;
commitid	10049C679C543D854C9;

1.121
date	2009.03.22.17.31.16;	author tg;	state Exp;
branches;
next	1.120;
commitid	10049C675F404D09353;

1.120
date	2009.03.14.18.12.53;	author tg;	state Exp;
branches;
next	1.119;
commitid	10049BBF38A0ADEDD54;

1.119
date	2008.12.29.21.34.20;	author tg;	state Exp;
branches;
next	1.118;
commitid	10049594263416D2C1C;

1.118
date	2008.12.29.20.52.09;	author tg;	state Exp;
branches;
next	1.117;
commitid	10049593890439F73A6;

1.117
date	2008.12.29.20.47.15;	author tg;	state Exp;
branches;
next	1.116;
commitid	10049593769614169C5;

1.116
date	2008.12.13.17.02.15;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004943EAA830C0300B;

1.115
date	2008.12.04.18.11.06;	author tg;	state Exp;
branches;
next	1.114;
commitid	10049381D2D4EEC022C;

1.114
date	2008.11.30.10.33.39;	author tg;	state Exp;
branches;
next	1.113;
commitid	10049326BED703E2AC2;

1.113
date	2008.11.15.09.00.19;	author tg;	state Exp;
branches
	1.113.2.1;
next	1.112;
commitid	100491E8FA25D360D54;

1.112
date	2008.11.15.08.42.35;	author tg;	state Exp;
branches;
next	1.111;
commitid	100491E8B8F448A9E71;

1.111
date	2008.11.15.07.35.24;	author tg;	state Exp;
branches;
next	1.110;
commitid	100491E7BBB79B0FECE;

1.110
date	2008.11.12.04.55.18;	author tg;	state Exp;
branches;
next	1.109;
commitid	100491A618E0C3BD225;

1.109
date	2008.11.12.00.54.49;	author tg;	state Exp;
branches;
next	1.108;
commitid	100491A295841A6D8EB;

1.108
date	2008.11.12.00.27.56;	author tg;	state Exp;
branches;
next	1.107;
commitid	100491A230649FC77C0;

1.107
date	2008.11.11.23.50.30;	author tg;	state Exp;
branches;
next	1.106;
commitid	100491A1A3D7C6B56F1;

1.106
date	2008.11.10.19.33.07;	author tg;	state Exp;
branches;
next	1.105;
commitid	10049188C7F54ACF524;

1.105
date	2008.10.28.14.32.41;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004907226D3DEFCCD1;

1.104
date	2008.10.20.19.29.23;	author tg;	state Exp;
branches;
next	1.103;
commitid	10048FCDBAF5C7D98EB;

1.103
date	2008.10.15.10.25.01;	author tg;	state Exp;
branches;
next	1.102;
commitid	10048F5C4D32F55458D;

1.102
date	2008.09.17.19.31.29;	author tg;	state Exp;
branches;
next	1.101;
commitid	10048D15ABE2EA76C75;

1.101
date	2008.07.10.18.34.08;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004876562E49316ECB;

1.100
date	2008.07.09.21.32.43;	author tg;	state Exp;
branches;
next	1.99;
commitid	10048752E6271CABA24;

1.99
date	2008.07.08.22.28.26;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004873E9F769A6FF23;

1.98
date	2008.05.17.18.47.00;	author tg;	state Exp;
branches;
next	1.97;
commitid	100482F280E7B53AA4C;

1.97
date	2008.05.15.15.24.10;	author tg;	state Exp;
branches;
next	1.96;
commitid	100482C558039271D26;

1.96
date	2008.05.04.01.58.14;	author tg;	state Exp;
branches;
next	1.95;
commitid	100481D183D7217B8F3;

1.95
date	2008.04.01.20.40.21;	author tg;	state Exp;
branches;
next	1.94;
commitid	10047F29D740D1FD5B8;

1.94
date	2008.03.28.18.47.52;	author tg;	state Exp;
branches;
next	1.93;
commitid	10047ED3D6B15668628;

1.93
date	2008.03.25.21.34.44;	author tg;	state Exp;
branches;
next	1.92;
commitid	10047E96EF5608C6FD5;

1.92
date	2008.03.01.13.57.36;	author tg;	state Exp;
branches
	1.92.2.1;
next	1.91;
commitid	10047C960DD0E4295A1;

1.91
date	2008.03.01.02.21.37;	author tg;	state Exp;
branches;
next	1.90;
commitid	10047C8BDBC04C448EC;

1.90
date	2008.02.25.00.58.26;	author tg;	state Exp;
branches;
next	1.89;
commitid	10047C2102904204374;

1.89
date	2007.10.25.15.23.10;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004720B4ED147A8549;

1.88
date	2007.10.25.15.19.16;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004720B40258F7886E;

1.87
date	2007.08.19.22.06.26;	author tg;	state Exp;
branches;
next	1.86;
commitid	10046C8BEC1249CCADD;

1.86
date	2007.08.13.19.39.19;	author tg;	state Exp;
branches;
next	1.85;
commitid	10046C0B31A6F414C8F;

1.85
date	2007.08.12.13.42.21;	author tg;	state Exp;
branches;
next	1.84;
commitid	10046BF0E4F7055959B;

1.84
date	2007.07.22.13.34.51;	author tg;	state Exp;
branches;
next	1.83;
commitid	10046A35CEC35BB7B5F;

1.83
date	2007.07.17.13.56.51;	author tg;	state Exp;
branches;
next	1.82;
commitid	100469CCA9508D35977;

1.82
date	2007.07.01.21.10.29;	author tg;	state Exp;
branches;
next	1.81;
commitid	100468818584C6286F7;

1.81
date	2007.07.01.19.04.53;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004687FAEA6DAA2FEC;

1.80
date	2007.06.17.00.50.07;	author tg;	state Exp;
branches;
next	1.79;
commitid	100467485062D380C8D;

1.79
date	2007.06.16.15.02.56;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004673FBB32FC07FD4;

1.78
date	2007.06.15.21.55.19;	author tg;	state Exp;
branches;
next	1.77;
commitid	10046730AA46E14A9D1;

1.77
date	2007.06.15.20.52.19;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004672FC013D4B1131;

1.76
date	2007.06.06.23.28.16;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004667430836D68E66;

1.75
date	2007.05.13.17.51.22;	author tg;	state Exp;
branches;
next	1.74;
commitid	10046474FB1292DF336;

1.74
date	2007.04.15.10.45.59;	author tg;	state Exp;
branches
	1.74.2.1;
next	1.73;
commitid	1004622020D73FDDAF8;

1.73
date	2007.03.04.03.04.26;	author tg;	state Exp;
branches;
next	1.72;
commitid	10045EA374B3374AB35;

1.72
date	2007.03.04.00.13.16;	author tg;	state Exp;
branches;
next	1.71;
commitid	10045EA0F2F6674C8B9;

1.71
date	2007.03.03.21.36.07;	author tg;	state Exp;
branches;
next	1.70;
commitid	10045E9EA54328B08FC;

1.70
date	2007.02.13.13.36.18;	author tg;	state Exp;
branches;
next	1.69;
commitid	10045D1BEDF2CE4C46E;

1.69
date	2007.02.10.21.59.15;	author tg;	state Exp;
branches;
next	1.68;
commitid	10045CE40341BE5E0A2;

1.68
date	2007.01.15.00.18.47;	author tg;	state Exp;
branches;
next	1.67;
commitid	10045AAC877551BD17C;

1.67
date	2007.01.12.10.18.21;	author tg;	state Exp;
branches
	1.67.2.1;
next	1.66;
commitid	10045A76059104E0EFB;

1.66
date	2007.01.12.02.06.34;	author tg;	state Exp;
branches;
next	1.65;
commitid	10045A6ED2005BADF84;

1.65
date	2007.01.11.00.32.31;	author tg;	state Exp;
branches;
next	1.64;
commitid	10045A5858664A950E2;

1.64
date	2007.01.06.17.08.14;	author tg;	state Exp;
branches;
next	1.63;
commitid	100459FD7720F90D30E;

1.63
date	2007.01.03.22.43.47;	author tg;	state Exp;
branches;
next	1.62;
commitid	100459C318675D901E0;

1.62
date	2006.11.16.13.35.07;	author tg;	state Exp;
branches;
next	1.61;
commitid	100455C692216B2C856;

1.61
date	2006.11.12.14.58.15;	author tg;	state Exp;
branches;
next	1.60;
commitid	100455735A7145E26AA;

1.60
date	2006.11.12.10.44.41;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004556FB165B715FFA;

1.59
date	2006.11.10.06.53.26;	author tg;	state Exp;
branches;
next	1.58;
commitid	100455421CB6900D8A1;

1.58
date	2006.11.10.06.31.47;	author tg;	state Exp;
branches;
next	1.57;
commitid	10045541CD83DCC9E54;

1.57
date	2006.11.10.06.27.09;	author tg;	state Exp;
branches;
next	1.56;
commitid	10045541B9967DE13F7;

1.56
date	2006.11.10.05.27.43;	author tg;	state Exp;
branches;
next	1.55;
commitid	10045540DA3023460F0;

1.55
date	2006.11.10.05.23.12;	author tg;	state Exp;
branches;
next	1.54;
commitid	10045540CCB39485995;

1.54
date	2006.11.10.03.23.49;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004553F0C348A7A034;

1.53
date	2006.11.10.01.13.51;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004553D1A316532A65;

1.52
date	2006.11.09.22.08.07;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004553A6D03FB3FB12;

1.51
date	2006.11.08.23.45.47;	author tg;	state Exp;
branches;
next	1.50;
commitid	10045526C372A4C60AB;

1.50
date	2006.11.05.12.11.14;	author tg;	state Exp;
branches;
next	1.49;
commitid	100454DD4E712F5401D;

1.49
date	2006.09.30.02.13.21;	author tg;	state Exp;
branches;
next	1.48;
commitid	100451DD2A867E0A573;

1.48
date	2006.08.24.20.32.53;	author tg;	state Exp;
branches;
next	1.47;
commitid	10044EE0CE2267A59CF;

1.47
date	2006.08.22.22.49.35;	author tg;	state Exp;
branches;
next	1.46;
commitid	10044EB89CB27D175DB;

1.46
date	2006.08.18.18.48.25;	author tg;	state Exp;
branches;
next	1.45;
commitid	10044E60B7F76A8563C;

1.45
date	2006.08.18.13.40.15;	author tg;	state Exp;
branches;
next	1.44;
commitid	10044E5C34431A7C593;

1.44
date	2006.08.01.13.43.27;	author tg;	state Exp;
branches
	1.44.2.1;
next	1.43;
commitid	10044CF5A93693A5C0A;

1.43
date	2006.08.01.12.22.26;	author tg;	state Exp;
branches;
next	1.42;
commitid	10044CF478D5EA22071;

1.42
date	2006.07.23.14.35.44;	author tg;	state Exp;
branches;
next	1.41;
commitid	10044C38956068FA76E;

1.41
date	2006.07.11.14.51.01;	author tg;	state Exp;
branches;
next	1.40;
commitid	10044B3BAD83E16AC82;

1.40
date	2006.07.03.12.16.30;	author tg;	state Exp;
branches;
next	1.39;
commitid	10044A90AAA1B255EDF;

1.39
date	2006.06.21.19.27.35;	author tg;	state Exp;
branches;
next	1.38;
commitid	10044999D9B6AABE232;

1.38
date	2006.05.26.23.36.19;	author tg;	state Exp;
branches;
next	1.37;
commitid	100447790437FAB8D3E;

1.37
date	2006.05.10.19.30.33;	author tg;	state Exp;
branches;
next	1.36;
commitid	10044623F60676FC8A1;

1.36
date	2006.05.10.18.54.11;	author tg;	state Exp;
branches;
next	1.35;
commitid	100446236E6726083C8;

1.35
date	2006.05.08.11.42.36;	author tg;	state Exp;
branches;
next	1.34;
commitid	100445F2E0E7C37DD2F;

1.34
date	2006.01.30.12.37.23;	author tg;	state Exp;
branches;
next	1.33;
commitid	10043DE088533ED5341;

1.33
date	2006.01.29.20.56.55;	author tg;	state Exp;
branches;
next	1.32;
commitid	10043DD2B834A41FF17;

1.32
date	2006.01.29.20.04.52;	author tg;	state Exp;
branches;
next	1.31;
commitid	10043DD1FE6328EF386;

1.31
date	2005.11.22.18.40.43;	author tg;	state Exp;
branches;
next	1.30;
commitid	108a438366254326;

1.30
date	2005.10.25.21.11.26;	author tg;	state Exp;
branches;
next	1.29;
commitid	4586435e9f8dd3c9;

1.29
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.28;
commitid	76cc435e8d34d8ce;

1.28
date	2005.10.21.12.41.55;	author tg;	state Exp;
branches;
next	1.27;
commitid	657d4358e1e6ede8;

1.27
date	2005.10.08.18.53.10;	author tg;	state Exp;
branches;
next	1.26;
commitid	1a5e434815a40ffe;

1.26
date	2005.09.11.00.32.30;	author tg;	state Exp;
branches;
next	1.25;
commitid	1e5543237b2a21d0;

1.25
date	2005.08.26.22.03.56;	author tg;	state Exp;
branches;
next	1.24;
commitid	57a8430f91c30d91;

1.24
date	2005.08.21.13.02.17;	author tg;	state Exp;
branches;
next	1.23;
commitid	521743087b5a03be;

1.23
date	2005.08.02.12.35.26;	author tg;	state Exp;
branches;
next	1.22;
commitid	6dd542ef687afd87;

1.22
date	2005.07.07.22.00.45;	author tg;	state Exp;
branches;
next	1.21;
commitid	32a042cda60d6277;

1.21
date	2005.07.06.00.02.06;	author tg;	state Exp;
branches;
next	1.20;
commitid	3c3f42cb1f724a1e;

1.20
date	2005.07.04.12.47.13;	author tg;	state Exp;
branches;
next	1.19;
commitid	499742c92fe4b090;

1.19
date	2005.07.04.12.34.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	4a8342c92cd61cc3;

1.18
date	2005.07.04.12.27.26;	author tg;	state Exp;
branches;
next	1.17;
commitid	3ec342c92b3a8874;

1.17
date	2005.07.04.11.57.55;	author tg;	state Exp;
branches;
next	1.16;
commitid	347442c9243dac0e;

1.16
date	2005.06.24.15.42.03;	author tg;	state Exp;
branches;
next	1.15;
commitid	62f542bc29dbab38;

1.15
date	2005.06.24.15.36.57;	author tg;	state Exp;
branches;
next	1.14;
commitid	e0142bc28a6abe3;

1.14
date	2005.06.08.22.35.45;	author tg;	state Exp;
branches;
next	1.13;
commitid	15a42a772c74664;

1.13
date	2005.06.08.22.34.03;	author tg;	state Exp;
branches;
next	1.12;
commitid	775142a7726c13a2;

1.12
date	2005.06.08.22.22.24;	author tg;	state Exp;
branches;
next	1.11;
commitid	40d642a76fac7c9d;

1.11
date	2005.06.08.21.51.21;	author tg;	state Exp;
branches;
next	1.10;
commitid	318442a76849872f;

1.10
date	2005.06.05.16.38.20;	author tg;	state Exp;
branches;
next	1.9;
commitid	329342a32a8e3325;

1.9
date	2005.05.28.21.02.02;	author tg;	state Exp;
branches;
next	1.8;
commitid	40b34298dc472142;

1.8
date	2005.05.26.23.01.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	789f4296553dac75;

1.7
date	2005.05.25.23.31.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	6fd242950a6e73e0;

1.6
date	2005.05.25.13.46.01;	author tg;	state Exp;
branches;
next	1.5;
commitid	503942948197230c;

1.5
date	2005.05.25.11.37.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	12224294637fc2bb;

1.4
date	2005.05.23.15.54.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	78044291fcc1aba2;

1.3
date	2005.05.23.15.36.55;	author tg;	state Exp;
branches;
next	1.2;
commitid	294b4291f8a10548;

1.2
date	2005.05.23.14.22.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	7f594291e70f38dd;

1.1
date	2005.05.23.03.06.08;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.285.2.1
date	2015.01.25.15.35.47;	author tg;	state Exp;
branches;
next	1.285.2.2;
commitid	10054C50D442D861FBF;

1.285.2.2
date	2015.03.01.15.43.01;	author tg;	state Exp;
branches;
next	1.285.2.3;
commitid	10054F33364551D895A;

1.285.2.3
date	2015.04.12.22.32.29;	author tg;	state Exp;
branches;
next	1.285.2.4;
commitid	100552AF26A429AA816;

1.285.2.4
date	2015.04.19.19.18.20;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.245.2.1
date	2012.12.05.19.58.30;	author tg;	state Exp;
branches;
next	1.245.2.2;
commitid	10050BFA7766B61F30F;

1.245.2.2
date	2012.12.07.23.46.26;	author tg;	state Exp;
branches;
next	1.245.2.3;
commitid	10050C27FDC255CF0A0;

1.245.2.3
date	2013.01.01.21.20.06;	author tg;	state Exp;
branches;
next	1.245.2.4;
commitid	10050E352F23B706399;

1.245.2.4
date	2013.01.01.22.23.22;	author tg;	state Exp;
branches;
next	;
commitid	10050E361E825906F7E;

1.224.2.1
date	2013.02.11.00.27.17;	author tg;	state Exp;
branches;
next	;
commitid	10051183A6D5475BB1E;

1.195.2.1
date	2011.07.07.21.42.13;	author tg;	state Exp;
branches;
next	1.195.2.2;
commitid	1004E162810137500DE;

1.195.2.2
date	2011.07.16.16.04.11;	author tg;	state Exp;
branches;
next	1.195.2.3;
commitid	1004E21B64E3A80D0DC;

1.195.2.3
date	2011.10.25.22.50.33;	author tg;	state Exp;
branches;
next	1.195.2.4;
commitid	1004EA73D456165B188;

1.195.2.4
date	2011.11.08.22.07.21;	author tg;	state Exp;
branches;
next	1.195.2.5;
commitid	1004EB9A7F80119200E;

1.195.2.5
date	2012.03.03.21.41.44;	author tg;	state Exp;
branches;
next	1.195.2.6;
commitid	1004F529027715CBC71;

1.195.2.6
date	2012.03.24.21.22.37;	author tg;	state Exp;
branches;
next	1.195.2.7;
commitid	1004F6E3A967ACCD93A;

1.195.2.7
date	2012.03.24.22.11.43;	author tg;	state Exp;
branches;
next	1.195.2.8;
commitid	1004F6E46B45C82FE79;

1.195.2.8
date	2012.04.06.14.40.20;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.143.2.1
date	2009.08.30.20.56.07;	author tg;	state Exp;
branches;
next	;
commitid	1004A9AE59203C5D0BB;

1.113.2.1
date	2008.11.22.13.20.33;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.92.2.1
date	2008.04.22.13.29.29;	author tg;	state Exp;
branches;
next	1.92.2.2;
commitid	100480DE80F32BAA72D;

1.92.2.2
date	2008.05.19.18.41.27;	author tg;	state Exp;
branches;
next	1.92.2.3;
commitid	1004831C9A63DA06745;

1.92.2.3
date	2008.07.11.11.49.28;	author tg;	state Exp;
branches;
next	1.92.2.4;
commitid	100487748D62394D033;

1.92.2.4
date	2008.12.14.00.07.44;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.74.2.1
date	2007.05.13.19.29.37;	author tg;	state Exp;
branches;
next	1.74.2.2;
commitid	1004647668D4636830B;

1.74.2.2
date	2007.07.05.11.49.21;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.67.2.1
date	2007.03.03.21.37.56;	author tg;	state Exp;
branches;
next	1.67.2.2;
commitid	10045E9EAC27ABA6ADF;

1.67.2.2
date	2007.03.03.21.43.50;	author tg;	state Exp;
branches;
next	1.67.2.3;
commitid	10045E9EC2B7AC589DE;

1.67.2.3
date	2007.03.03.23.38.37;	author tg;	state Exp;
branches;
next	1.67.2.4;
commitid	10045EA07113BF2F32A;

1.67.2.4
date	2007.03.03.23.45.14;	author tg;	state Exp;
branches;
next	1.67.2.5;
commitid	10045EA08A0437BD668;

1.67.2.5
date	2007.03.03.23.59.38;	author tg;	state Exp;
branches;
next	;
commitid	10045EA0C01765C8871;

1.44.2.1
date	2006.08.15.23.49.53;	author tg;	state Exp;
branches;
next	1.44.2.2;
commitid	10044E25D6841FC583E;

1.44.2.2
date	2006.08.24.19.18.21;	author tg;	state Exp;
branches;
next	1.44.2.3;
commitid	10044EDFB8B13F73354;

1.44.2.3
date	2006.08.24.20.20.12;	author tg;	state Exp;
branches;
next	1.44.2.4;
commitid	10044EE09F66C50BFFD;

1.44.2.4
date	2006.08.24.20.52.13;	author tg;	state Exp;
branches;
next	1.44.2.5;
commitid	10044EE117A130AF943;

1.44.2.5
date	2006.08.28.01.49.18;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.360
log
@move the “is inside eval” flag into struct env
@
text
@/*	$OpenBSD: main.c,v 1.57 2015/09/10 22:48:58 nicm Exp $	*/
/*	$OpenBSD: tty.c,v 1.10 2014/08/10 02:44:26 guenther Exp $	*/
/*	$OpenBSD: io.c,v 1.26 2015/09/11 08:00:27 guenther Exp $	*/
/*	$OpenBSD: table.c,v 1.16 2015/09/01 13:12:31 tedu Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#define EXTERN
#include "sh.h"

#if HAVE_LANGINFO_CODESET
#include <langinfo.h>
#endif
#if HAVE_SETLOCALE_CTYPE
#include <locale.h>
#endif

__RCSID("$MirOS: src/bin/mksh/main.c,v 1.359 2019/12/30 03:45:13 tg Exp $");

#ifndef MKSHRC_PATH
#define MKSHRC_PATH	"~/.mkshrc"
#endif

#ifndef MKSH_DEFAULT_TMPDIR
#define MKSH_DEFAULT_TMPDIR	MKSH_UNIXROOT "/tmp"
#endif

static uint8_t isuc(const char *);
static int main_init(int, const char *[], Source **, struct block **);
void chvt_reinit(void);
static void reclaim(void);
static void remove_temps(struct temp *);
static mksh_uari_t rndsetup(void);
static void init_environ(void);
#ifdef SIGWINCH
static void x_sigwinch(int);
#endif

static const char initsubs[] =
    "${PS2=> }"
    "${PS3=#? }"
    "${PS4=+ }"
    "${SECONDS=0}"
    "${TMOUT=0}"
    "${EPOCHREALTIME=}";

static const char *initcoms[] = {
	Ttypeset, "-r", initvsn, NULL,
	Ttypeset, "-x", "HOME", TPATH, TSHELL, NULL,
	Ttypeset, "-i10", "COLUMNS", "LINES", "SECONDS", "TMOUT", NULL,
	Talias,
	"integer=\\\\builtin typeset -i",
	"local=\\\\builtin typeset",
	/* not "alias -t --": hash -r needs to work */
	"hash=\\\\builtin alias -t",
	"type=\\\\builtin whence -v",
	"autoload=\\\\builtin typeset -fu",
	"functions=\\\\builtin typeset -f",
	"history=\\\\builtin fc -l",
	"nameref=\\\\builtin typeset -n",
	"nohup=nohup ",
	"r=\\\\builtin fc -e -",
	"login=\\\\builtin exec login",
	NULL,
	 /* this is what AT&T ksh seems to track, with the addition of emacs */
	Talias, "-tU",
	Tcat, "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
	"make", "mv", "pr", "rm", "sed", Tsh, "vi", "who", NULL,
	NULL
};

static const char *restr_com[] = {
	Ttypeset, "-r", TPATH, "ENV", TSHELL, NULL
};

static bool initio_done;

/* top-level parsing and execution environment */
static struct env env;
struct env *e = &env;

/* compile-time assertions */
#define cta(name, expr) struct cta_ ## name { char t[(expr) ? 1 : -1]; }

/* this one should be defined by the standard */
cta(char_is_1_char, (sizeof(char) == 1) && (sizeof(signed char) == 1) &&
    (sizeof(unsigned char) == 1));
cta(char_is_8_bits, ((CHAR_BIT) == 8) && ((int)(unsigned char)0xFF == 0xFF) &&
    ((int)(unsigned char)0x100 == 0) && ((int)(unsigned char)(int)-1 == 0xFF));
/* the next assertion is probably not really needed */
cta(short_is_2_char, sizeof(short) == 2);
cta(short_size_no_matter_of_signedness, sizeof(short) == sizeof(unsigned short));
/* the next assertion is probably not really needed */
cta(int_is_4_char, sizeof(int) == 4);
cta(int_size_no_matter_of_signedness, sizeof(int) == sizeof(unsigned int));

cta(long_ge_int, sizeof(long) >= sizeof(int));
cta(long_size_no_matter_of_signedness, sizeof(long) == sizeof(unsigned long));

#ifndef MKSH_LEGACY_MODE
/* the next assertion is probably not really needed */
cta(ari_is_4_char, sizeof(mksh_ari_t) == 4);
/* but this is */
cta(ari_has_31_bit, 0 < (mksh_ari_t)(((((mksh_ari_t)1 << 15) << 15) - 1) * 2 + 1));
/* the next assertion is probably not really needed */
cta(uari_is_4_char, sizeof(mksh_uari_t) == 4);
/* but the next three are; we REQUIRE unsigned integer wraparound */
cta(uari_has_31_bit, 0 < (mksh_uari_t)(((((mksh_uari_t)1 << 15) << 15) - 1) * 2 + 1));
cta(uari_has_32_bit, 0 < (mksh_uari_t)(((((mksh_uari_t)1 << 15) << 15) - 1) * 4 + 3));
cta(uari_wrap_32_bit,
    (mksh_uari_t)(((((mksh_uari_t)1 << 15) << 15) - 1) * 4 + 3) >
    (mksh_uari_t)(((((mksh_uari_t)1 << 15) << 15) - 1) * 4 + 4));
#endif
/* these are always required */
cta(ari_is_signed, (mksh_ari_t)-1 < (mksh_ari_t)0);
cta(uari_is_unsigned, (mksh_uari_t)-1 > (mksh_uari_t)0);
/* we require these to have the precisely same size and assume 2s complement */
cta(ari_size_no_matter_of_signedness, sizeof(mksh_ari_t) == sizeof(mksh_uari_t));

cta(sizet_size_no_matter_of_signedness, sizeof(ssize_t) == sizeof(size_t));
cta(sizet_voidptr_same_size, sizeof(size_t) == sizeof(void *));
cta(sizet_funcptr_same_size, sizeof(size_t) == sizeof(void (*)(void)));
/* our formatting routines assume this */
cta(ptr_fits_in_long, sizeof(size_t) <= sizeof(long));
cta(ari_fits_in_long, sizeof(mksh_ari_t) <= sizeof(long));

static mksh_uari_t
rndsetup(void)
{
	register uint32_t h;
	struct {
		ALLOC_ITEM alloc_INT;
		void *dataptr, *stkptr, *mallocptr;
#if defined(__GLIBC__) && (__GLIBC__ >= 2)
		sigjmp_buf jbuf;
#endif
		struct timeval tv;
	} *bufptr;
	char *cp;

	cp = alloc(sizeof(*bufptr) - sizeof(ALLOC_ITEM), APERM);
	/* clear the allocated space, for valgrind and to avoid UB */
	memset(cp, 0, sizeof(*bufptr) - sizeof(ALLOC_ITEM));
	/* undo what alloc() did to the malloc result address */
	bufptr = (void *)(cp - sizeof(ALLOC_ITEM));
	/* PIE or something similar provides us with deltas here */
	bufptr->dataptr = &rndsetupstate;
	/* ASLR in at least Windows, Linux, some BSDs */
	bufptr->stkptr = &bufptr;
	/* randomised malloc in BSD (and possibly others) */
	bufptr->mallocptr = bufptr;
#if defined(__GLIBC__) && (__GLIBC__ >= 2)
	/* glibc pointer guard */
	sigsetjmp(bufptr->jbuf, 1);
#endif
	/* introduce variation (and yes, second arg MBZ for portability) */
	mksh_TIME(bufptr->tv);

#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
	mprotect(((char *)bufptr) + 4096, 4096, PROT_READ | PROT_WRITE);
#endif
	h = chvt_rndsetup(bufptr, sizeof(*bufptr));

	afree(cp, APERM);
	return ((mksh_uari_t)h);
}

void
chvt_reinit(void)
{
	kshpid = procpid = getpid();
	ksheuid = geteuid();
	kshpgrp = getpgrp();
	kshppid = getppid();
}

static const char *empty_argv[] = {
	Tmksh, NULL
};

static uint8_t
isuc(const char *cx) {
	char *cp, *x;
	uint8_t rv = 0;

	if (!cx || !*cx)
		return (0);

	/* uppercase a string duplicate */
	strdupx(x, cx, ATEMP);
	cp = x;
	while ((*cp = ksh_toupper(*cp)))
		++cp;

	/* check for UTF-8 */
	if (strstr(x, "UTF-8") || strstr(x, "UTF8"))
		rv = 1;

	/* free copy and out */
	afree(x, ATEMP);
	return (rv);
}

static int
main_init(int argc, const char *argv[], Source **sp, struct block **lp)
{
	int argi, i;
	Source *s = NULL;
	struct block *l;
	unsigned char restricted_shell, errexit, utf_flag;
	char *cp;
	const char *ccp, **wp;
	struct tbl *vp;
	struct stat s_stdin;
#if !defined(_PATH_DEFPATH) && defined(_CS_PATH)
	ssize_t k;
#endif

#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
	ebcdic_init();
#endif
	set_ifs(TC_IFSWS);

#ifdef __OS2__
	os2_init(&argc, &argv);
#endif

	/* do things like getpgrp() et al. */
	chvt_reinit();

	/* make sure argv[] is sane, for weird OSes */
	if (!*argv) {
		argv = empty_argv;
		argc = 1;
	}
	kshname = argv[0];

	/* initialise permanent Area */
	ainit(&aperm);
	/* max. name length: -2147483648 = 11 (+ NUL) */
	vtemp = alloc(offsetof(struct tbl, name[0]) + 12, APERM);

	/* set up base environment */
	env.type = E_NONE;
	ainit(&env.area);
	/* set up global l->vars and l->funs */
	newblock();

	/* Do this first so output routines (eg, errorf, shellf) can work */
	initio();

	/* determine the basename (without '-' or path) of the executable */
	ccp = kshname;
	goto begin_parsing_kshname;
	while ((i = ccp[argi++])) {
		if (mksh_cdirsep(i)) {
			ccp += argi;
 begin_parsing_kshname:
			argi = 0;
			if (*ccp == '-')
				++ccp;
		}
	}
	if (!*ccp)
		ccp = empty_argv[0];

	/*
	 * Turn on nohup by default. (AT&T ksh does not have a nohup
	 * option - it always sends the hup).
	 */
	Flag(FNOHUP) = 1;

	/*
	 * Turn on brace expansion by default. AT&T kshs that have
	 * alternation always have it on.
	 */
	Flag(FBRACEEXPAND) = 1;

	/*
	 * Turn on "set -x" inheritance by default.
	 */
	Flag(FXTRACEREC) = 1;

	/* define built-in commands and see if we were called as one */
	ktinit(APERM, &builtins,
	    /* currently up to 54 builtins: 75% of 128 = 2^7 */
	    7);
	for (i = 0; mkshbuiltins[i].name != NULL; i++)
		if (!strcmp(ccp, builtin(mkshbuiltins[i].name,
		    mkshbuiltins[i].func)))
			Flag(FAS_BUILTIN) = 1;

	if (!Flag(FAS_BUILTIN)) {
		/* check for -T option early */
		argi = parse_args(argv, OF_FIRSTTIME, NULL);
		if (argi < 0)
			return (1);

#if defined(MKSH_BINSHPOSIX) || defined(MKSH_BINSHREDUCED)
		/* are we called as -sh or /bin/sh or so? */
		if (!strcmp(ccp, "sh" MKSH_EXE_EXT)) {
			/* either also turns off braceexpand */
#ifdef MKSH_BINSHPOSIX
			/* enable better POSIX conformance */
			change_flag(FPOSIX, OF_FIRSTTIME, true);
#endif
#ifdef MKSH_BINSHREDUCED
			/* enable kludge/compat mode */
			change_flag(FSH, OF_FIRSTTIME, true);
#endif
		}
#endif
	}

	initvar();

	inittraps();

	coproc_init();

	/* set up variable and command dictionaries */
	ktinit(APERM, &taliases, 0);
	ktinit(APERM, &aliases, 0);
#ifndef MKSH_NOPWNAM
	ktinit(APERM, &homedirs, 0);
#endif

	/* define shell keywords */
	initkeywords();

	init_histvec();

	/* initialise tty size before importing environment */
	change_winsz();

#ifdef _PATH_DEFPATH
	def_path = _PATH_DEFPATH;
#else
#ifdef _CS_PATH
	if ((k = confstr(_CS_PATH, NULL, 0)) > 0 &&
	    confstr(_CS_PATH, cp = alloc(k + 1, APERM), k + 1) == k + 1)
		def_path = cp;
	else
#endif
		/*
		 * this is uniform across all OSes unless it
		 * breaks somewhere hard; don't try to optimise,
		 * e.g. add stuff for Interix or remove /usr
		 * for HURD, because e.g. Debian GNU/HURD is
		 * "keeping a regular /usr"; this is supposed
		 * to be a sane 'basic' default PATH
		 */
		def_path = MKSH_UNIXROOT "/bin" MKSH_PATHSEPS
		    MKSH_UNIXROOT "/usr/bin" MKSH_PATHSEPS
		    MKSH_UNIXROOT "/sbin" MKSH_PATHSEPS
		    MKSH_UNIXROOT "/usr/sbin";
#endif

	/*
	 * Set PATH to def_path (will set the path global variable).
	 * (import of environment below will probably change this setting).
	 */
	vp = global(TPATH);
	/* setstr can't fail here */
	setstr(vp, def_path, KSH_RETURN_ERROR);

#ifndef MKSH_NO_CMDLINE_EDITING
	/*
	 * Set edit mode to emacs by default, may be overridden
	 * by the environment or the user. Also, we want tab completion
	 * on in vi by default.
	 */
	change_flag(FEMACS, OF_SPECIAL, true);
#if !MKSH_S_NOVI
	Flag(FVITABCOMPLETE) = 1;
#endif
#endif

	/* import environment */
	init_environ();

	/* for security */
	typeset(TinitIFS, 0, 0, 0, 0);

	/* assign default shell variable values */
	typeset("PATHSEP=" MKSH_PATHSEPS, 0, 0, 0, 0);
	substitute(initsubs, 0);

	/* Figure out the current working directory and set $PWD */
	vp = global(TPWD);
	cp = str_val(vp);
	/* Try to use existing $PWD if it is valid */
	set_current_wd((mksh_abspath(cp) && test_eval(NULL, TO_FILEQ, cp,
	    Tdot, true)) ? cp : NULL);
	if (current_wd[0])
		simplify_path(current_wd);
	/* Only set pwd if we know where we are or if it had a bogus value */
	if (current_wd[0] || *cp)
		/* setstr can't fail here */
		setstr(vp, current_wd, KSH_RETURN_ERROR);

	for (wp = initcoms; *wp != NULL; wp++) {
		c_builtin(wp);
		while (*wp != NULL)
			wp++;
	}
	setint_n(global("OPTIND"), 1, 10);

	kshuid = getuid();
	kshgid = getgid();
	kshegid = getegid();

	safe_prompt = ksheuid ? "$ " : "# ";
	vp = global("PS1");
	/* Set PS1 if unset or we are root and prompt doesn't contain a # */
	if (!(vp->flag & ISSET) ||
	    (!ksheuid && !strchr(str_val(vp), '#')))
		/* setstr can't fail here */
		setstr(vp, safe_prompt, KSH_RETURN_ERROR);
	setint_n((vp = global("BASHPID")), 0, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("PGRP")), (mksh_uari_t)kshpgrp, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("PPID")), (mksh_uari_t)kshppid, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("USER_ID")), (mksh_uari_t)ksheuid, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("KSHUID")), (mksh_uari_t)kshuid, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("KSHEGID")), (mksh_uari_t)kshegid, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("KSHGID")), (mksh_uari_t)kshgid, 10);
	vp->flag |= INT_U;
	setint_n((vp = global("RANDOM")), rndsetup(), 10);
	vp->flag |= INT_U;
	setint_n((vp_pipest = global("PIPESTATUS")), 0, 10);

	/* Set this before parsing arguments */
	Flag(FPRIVILEGED) = (kshuid != ksheuid || kshgid != kshegid) ? 2 : 0;

	/* record if monitor is set on command line (see j_init() in jobs.c) */
#ifndef MKSH_UNEMPLOYED
	Flag(FMONITOR) = 127;
#endif
	/* this to note if utf-8 mode is set on command line (see below) */
	UTFMODE = 2;

	if (!Flag(FAS_BUILTIN)) {
		argi = parse_args(argv, OF_CMDLINE, NULL);
		if (argi < 0)
			return (1);
	}

	/* process this later only, default to off (hysterical raisins) */
	utf_flag = UTFMODE;
	UTFMODE = 0;

	if (Flag(FAS_BUILTIN)) {
		/* auto-detect from environment variables, always */
		utf_flag = 3;
	} else if (Flag(FCOMMAND)) {
		s = pushs(SSTRINGCMDLINE, ATEMP);
		if (!(s->start = s->str = argv[argi++]))
			errorf(Tf_optfoo, "", "", 'c', Treq_arg);
		while (*s->str) {
			if (ctype(*s->str, C_QUOTE))
				break;
			s->str++;
		}
		if (!*s->str)
			s->flags |= SF_MAYEXEC;
		s->str = s->start;
#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
		/* compatibility to MidnightBSD 0.1 /bin/sh (kludge) */
		if (Flag(FSH) && argv[argi] && !strcmp(argv[argi], "--"))
			++argi;
#endif
		if (argv[argi])
			kshname = argv[argi++];
	} else if (argi < argc && !Flag(FSTDIN)) {
		s = pushs(SFILE, ATEMP);
#ifdef __OS2__
		/*
		 * A bug in OS/2 extproc (like shebang) handling makes
		 * it not pass the full pathname of a script, so we need
		 * to search for it. This changes the behaviour of a
		 * simple "mksh foo", but can't be helped.
		 */
		s->file = argv[argi++];
		if (search_access(s->file, X_OK) != 0)
			s->file = search_path(s->file, path, X_OK, NULL);
		if (!s->file || !*s->file)
			s->file = argv[argi - 1];
#else
		s->file = argv[argi++];
#endif
		s->u.shf = shf_open(s->file, O_RDONLY | O_MAYEXEC, 0,
		    SHF_MAPHI | SHF_CLEXEC);
		if (s->u.shf == NULL) {
			shl_stdout_ok = false;
			warningf(true, Tf_sD_s, s->file, cstrerror(errno));
			/* mandated by SUSv4 */
			exstat = 127;
			unwind(LERROR);
		}
		kshname = s->file;
	} else {
		Flag(FSTDIN) = 1;
		s = pushs(SSTDIN, ATEMP);
		s->file = "<stdin>";
		s->u.shf = shf_fdopen(0, SHF_RD | can_seek(0),
		    NULL);
		if (isatty(0) && isatty(2)) {
			Flag(FTALKING) = Flag(FTALKING_I) = 1;
			/* The following only if isatty(0) */
			s->flags |= SF_TTY;
			s->u.shf->flags |= SHF_INTERRUPT;
			s->file = NULL;
		}
	}

	/* this bizarreness is mandated by POSIX */
	if (fstat(0, &s_stdin) >= 0 && S_ISCHR(s_stdin.st_mode) &&
	    Flag(FTALKING))
		reset_nonblock(0);

	/* initialise job control */
	j_init();
	/* do this after j_init() which calls tty_init_state() */
	if (Flag(FTALKING)) {
		if (utf_flag == 2) {
#ifndef MKSH_ASSUME_UTF8
			/* auto-detect from locale or environment */
			utf_flag = 4;
#else /* this may not be an #elif */
#if MKSH_ASSUME_UTF8
			utf_flag = 1;
#else
			/* always disable UTF-8 (for interactive) */
			utf_flag = 0;
#endif
#endif
		}
#ifndef MKSH_NO_CMDLINE_EDITING
		x_init();
#endif
	}

#ifdef SIGWINCH
	sigtraps[SIGWINCH].flags |= TF_SHELL_USES;
	setsig(&sigtraps[SIGWINCH], x_sigwinch,
	    SS_RESTORE_ORIG|SS_FORCE|SS_SHTRAP);
#endif

	l = e->loc;
	if (Flag(FAS_BUILTIN)) {
		l->argc = argc;
		l->argv = argv;
		l->argv[0] = ccp;
	} else {
		l->argc = argc - argi;
		/*
		 * allocate a new array because otherwise, when we modify
		 * it in-place, ps(1) output changes; the meaning of argc
		 * here is slightly different as it excludes kshname, and
		 * we add a trailing NULL sentinel as well
		 */
		l->argv = alloc2(l->argc + 2, sizeof(void *), APERM);
		l->argv[0] = kshname;
		memcpy(&l->argv[1], &argv[argi], l->argc * sizeof(void *));
		l->argv[l->argc + 1] = NULL;
		getopts_reset(1);
	}

	/* divine the initial state of the utf8-mode Flag */
	ccp = null;
	switch (utf_flag) {

	/* auto-detect from locale or environment */
	case 4:
#if HAVE_SETLOCALE_CTYPE
		ccp = setlocale(LC_CTYPE, "");
#if HAVE_LANGINFO_CODESET
		if (!isuc(ccp))
			ccp = nl_langinfo(CODESET);
#endif
		if (!isuc(ccp))
			ccp = null;
#endif
		/* FALLTHROUGH */

	/* auto-detect from environment */
	case 3:
		/* these were imported from environ earlier */
		if (ccp == null)
			ccp = str_val(global("LC_ALL"));
		if (ccp == null)
			ccp = str_val(global("LC_CTYPE"));
		if (ccp == null)
			ccp = str_val(global("LANG"));
		UTFMODE = isuc(ccp);
		break;

	/* not set on command line, not FTALKING */
	case 2:
	/* unknown values */
	default:
		utf_flag = 0;
		/* FALLTHROUGH */

	/* known values */
	case 1:
	case 0:
		UTFMODE = utf_flag;
		break;
	}

	/* Disable during .profile/ENV reading */
	restricted_shell = Flag(FRESTRICTED);
	Flag(FRESTRICTED) = 0;
	errexit = Flag(FERREXIT);
	Flag(FERREXIT) = 0;

	/*
	 * Do this before profile/$ENV so that if it causes problems in them,
	 * user will know why things broke.
	 */
	if (!current_wd[0] && Flag(FTALKING))
		warningf(false, "can't determine current directory");

	if (Flag(FLOGIN))
		include(MKSH_SYSTEM_PROFILE, 0, NULL, true);
	if (Flag(FPRIVILEGED)) {
		include(MKSH_SUID_PROFILE, 0, NULL, true);
		/* note whether -p was enabled during startup */
		if (Flag(FPRIVILEGED) == 1)
			/* allow set -p to setuid() later */
			Flag(FPRIVILEGED) = 3;
		else
			/* turn off -p if not set explicitly */
			change_flag(FPRIVILEGED, OF_INTERNAL, false);
	} else {
		if (Flag(FLOGIN))
			include(substitute("$HOME/.profile", 0), 0, NULL, true);
		if (Flag(FTALKING)) {
			cp = substitute("${ENV:-" MKSHRC_PATH "}", DOTILDE);
			if (cp[0] != '\0')
				include(cp, 0, NULL, true);
		}
	}
	if (restricted_shell) {
		c_builtin(restr_com);
		/* After typeset command... */
		Flag(FRESTRICTED) = 1;
	}
	Flag(FERREXIT) = errexit;

	if (Flag(FTALKING) && s)
		hist_init(s);
	else
		/* set after ENV */
		Flag(FTRACKALL) = 1;

	alarm_init();

	*sp = s;
	*lp = l;
	return (0);
}

/* this indirection barrier reduces stack usage during normal operation */

int
main(int argc, const char *argv[])
{
	int rv;
	Source *s;
	struct block *l;

	if ((rv = main_init(argc, argv, &s, &l)) == 0) {
		if (Flag(FAS_BUILTIN)) {
			rv = c_builtin(l->argv);
		} else {
			shell(s, 0);
			/* NOTREACHED */
		}
	}
	return (rv);
}

int
include(const char *name, int argc, const char **argv, bool intr_ok)
{
	Source *volatile s = NULL;
	struct shf *shf;
	const char **volatile old_argv;
	volatile int old_argc;
	int i;

	shf = shf_open(name, O_RDONLY | O_MAYEXEC, 0, SHF_MAPHI | SHF_CLEXEC);
	if (shf == NULL)
		return (-1);

	if (argv) {
		old_argv = e->loc->argv;
		old_argc = e->loc->argc;
	} else {
		old_argv = NULL;
		old_argc = 0;
	}
	newenv(E_INCL);
	if ((i = kshsetjmp(e->jbuf))) {
		quitenv(s ? s->u.shf : NULL);
		if (old_argv) {
			e->loc->argv = old_argv;
			e->loc->argc = old_argc;
		}
		switch (i) {
		case LRETURN:
		case LERROR:
		case LERREXT:
			/* see below */
			return (exstat & 0xFF);
		case LINTR:
			/*
			 * intr_ok is set if we are including .profile or $ENV.
			 * If user ^Cs out, we don't want to kill the shell...
			 */
			if (intr_ok && ((exstat & 0xFF) - 128) != SIGTERM)
				return (1);
			/* FALLTHROUGH */
		case LEXIT:
		case LLEAVE:
		case LSHELL:
			unwind(i);
			/* NOTREACHED */
		default:
			internal_errorf(Tunexpected_type, Tunwind, Tsource, i);
			/* NOTREACHED */
		}
	}
	if (argv) {
		e->loc->argv = argv;
		e->loc->argc = argc;
	}
	s = pushs(SFILE, ATEMP);
	s->u.shf = shf;
	strdupx(s->file, name, ATEMP);
	i = shell(s, 1);
	quitenv(s->u.shf);
	if (old_argv) {
		e->loc->argv = old_argv;
		e->loc->argc = old_argc;
	}
	/* & 0xff to ensure value not -1 */
	return (i & 0xFF);
}

/* spawn a command into a shell optionally keeping track of the line number */
int
command(const char *comm, int line)
{
	Source *s, *sold = source;
	int rv;

	s = pushs(SSTRING, ATEMP);
	s->start = s->str = comm;
	s->line = line;
	rv = shell(s, 1);
	source = sold;
	return (rv);
}

/*
 * run the commands from the input source, returning status.
 */
int
shell(Source * volatile s, volatile int level)
{
	struct op *t;
	volatile bool wastty = tobool(s->flags & SF_TTY);
	volatile uint8_t attempts = 13;
	volatile bool interactive = (level == 0) && Flag(FTALKING);
	volatile bool sfirst = true;
	Source *volatile old_source = source;
	int i;

	newenv(level == 2 ? E_EVAL : E_PARSE);
	if (level == 2)
		e->flags |= EF_IN_EVAL;
	if (interactive)
		really_exit = false;
	switch ((i = kshsetjmp(e->jbuf))) {
	case 0:
		break;
	case LBREAK:
	case LCONTIN:
		/* assert: interactive == false */
		source = old_source;
		quitenv(NULL);
		if (level == 2) {
			/* keep on going */
			unwind(i);
			/* NOTREACHED */
		}
		internal_errorf(Tf_cant_s, Tshell,
		    i == LBREAK ? Tbreak : Tcontinue);
		/* NOTREACHED */
	case LINTR:
		/* we get here if SIGINT not caught or ignored */
	case LERROR:
	case LERREXT:
	case LSHELL:
		if (interactive) {
			if (i == LINTR)
				shellf("\n");
			/*
			 * Reset any eof that was read as part of a
			 * multiline command.
			 */
			if (Flag(FIGNOREEOF) && s->type == SEOF && wastty)
				s->type = SSTDIN;
			/*
			 * Used by exit command to get back to
			 * top level shell. Kind of strange since
			 * interactive is set if we are reading from
			 * a tty, but to have stopped jobs, one only
			 * needs FMONITOR set (not FTALKING/SF_TTY)...
			 */
			/* toss any input we have so far */
			yyrecursive_pop(true);
			s->start = s->str = null;
			retrace_info = NULL;
			herep = heres;
			break;
		}
		/* FALLTHROUGH */
	case LEXIT:
	case LLEAVE:
	case LRETURN:
		source = old_source;
		quitenv(NULL);
		if (i == LERREXT && level == 2)
			return (exstat & 0xFF);
		/* keep on going */
		unwind(i);
		/* NOTREACHED */
	default:
		source = old_source;
		quitenv(NULL);
		internal_errorf(Tunexpected_type, Tunwind, Tshell, i);
		/* NOTREACHED */
	}
	while (/* CONSTCOND */ 1) {
		if (trap)
			runtraps(0);

		if (s->next == NULL) {
			if (Flag(FVERBOSE))
				s->flags |= SF_ECHO;
			else
				s->flags &= ~SF_ECHO;
		}
		if (interactive) {
			j_notify();
			set_prompt(PS1, s);
		}
		t = compile(s, sfirst, true);
		if (interactive)
			histsave(&s->line, NULL, HIST_FLUSH, true);
		sfirst = false;
		if (!t)
			goto source_no_tree;
		if (t->type == TEOF) {
			if (wastty && Flag(FIGNOREEOF) && --attempts > 0) {
				shellf("Use 'exit' to leave mksh\n");
				s->type = SSTDIN;
			} else if (wastty && !really_exit &&
			    j_stopped_running()) {
				really_exit = true;
				s->type = SSTDIN;
			} else {
				/*
				 * this for POSIX which says EXIT traps
				 * shall be taken in the environment
				 * immediately after the last command
				 * executed.
				 */
				if (level == 0)
					unwind(LEXIT);
				break;
			}
		} else if ((s->flags & SF_MAYEXEC) && t->type == TCOM)
			t->u.evalflags |= DOTCOMEXEC;
		if (!Flag(FNOEXEC) || (s->flags & SF_TTY))
			exstat = execute(t, 0, NULL) & 0xFF;

		if (t->type != TEOF && interactive && really_exit)
			really_exit = false;

 source_no_tree:
		reclaim();
	}
	source = old_source;
	quitenv(NULL);
	return (exstat & 0xFF);
}

/* return to closest error handler or shell(), exit if none found */
/* note: i MUST NOT be 0 */
void
unwind(int i)
{
	/* during eval, skip FERREXIT trap */
	if (i == LERREXT && (e->flags & EF_IN_EVAL))
		goto defer_traps;

	/* ordering for EXIT vs ERR is a bit odd (this is what AT&T ksh does) */
	if (i == LEXIT || ((i == LERROR || i == LERREXT || i == LINTR) &&
	    sigtraps[ksh_SIGEXIT].trap &&
	    (!Flag(FTALKING) || Flag(FERREXIT)))) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGEXIT], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	} else if (Flag(FERREXIT) && (i == LERROR || i == LERREXT || i == LINTR)) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGERR], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	}
 defer_traps:

	while (/* CONSTCOND */ 1) {
		switch (e->type) {
		case E_PARSE:
		case E_FUNC:
		case E_INCL:
		case E_LOOP:
		case E_ERRH:
		case E_EVAL:
			kshlongjmp(e->jbuf, i);
			/* NOTREACHED */
		case E_NONE:
			if (i == LINTR)
				e->flags |= EF_FAKE_SIGDIE;
			/* FALLTHROUGH */
		default:
			quitenv(NULL);
		}
	}
}

void
newenv(int type)
{
	struct env *ep;
	char *cp;

	/*
	 * struct env includes ALLOC_ITEM for alignment constraints
	 * so first get the actually used memory, then assign it
	 */
	cp = alloc(sizeof(struct env) - sizeof(ALLOC_ITEM), ATEMP);
	/* undo what alloc() did to the malloc result address */
	ep = (void *)(cp - sizeof(ALLOC_ITEM));
	/* initialise public members of struct env (not the ALLOC_ITEM) */
	ainit(&ep->area);
	ep->oenv = e;
	ep->loc = e->loc;
	ep->savefd = NULL;
	ep->temps = NULL;
	ep->yyrecursive_statep = NULL;
	ep->type = type;
	ep->flags = e->flags & EF_IN_EVAL;
	e = ep;
}

void
quitenv(struct shf *shf)
{
	struct env *ep = e;
	char *cp;
	int fd;

	yyrecursive_pop(true);
	while (ep->oenv && ep->oenv->loc != ep->loc)
		popblock();
	if (ep->savefd != NULL) {
		for (fd = 0; fd < NUFILE; fd++)
			/* if ep->savefd[fd] < 0, means fd was closed */
			if (ep->savefd[fd])
				restfd(fd, ep->savefd[fd]);
		if (ep->savefd[2])
			/* Clear any write errors */
			shf_reopen(2, SHF_WR, shl_out);
	}
	/*
	 * Bottom of the stack.
	 * Either main shell is exiting or cleanup_parents_env() was called.
	 */
	if (ep->oenv == NULL) {
#ifdef DEBUG_LEAKS
		int i;
#endif

		if (ep->type == E_NONE) {
			/* Main shell exiting? */
#if HAVE_PERSISTENT_HISTORY
			if (Flag(FTALKING))
				hist_finish();
#endif
			j_exit();
			if (ep->flags & EF_FAKE_SIGDIE) {
				int sig = (exstat & 0xFF) - 128;

				/*
				 * ham up our death a bit (AT&T ksh
				 * only seems to do this for SIGTERM)
				 * Don't do it for SIGQUIT, since we'd
				 * dump a core..
				 */
				if ((sig == SIGINT || sig == SIGTERM) &&
				    (kshpgrp == kshpid)) {
					setsig(&sigtraps[sig], SIG_DFL,
					    SS_RESTORE_CURR | SS_FORCE);
					kill(0, sig);
				}
			}
		}
		if (shf)
			shf_close(shf);
		reclaim();
#ifdef DEBUG_LEAKS
#ifndef MKSH_NO_CMDLINE_EDITING
		x_done();
#endif
#ifndef MKSH_NOPROSPECTOFWORK
		/* block at least SIGCHLD during/after afreeall */
		sigprocmask(SIG_BLOCK, &sm_sigchld, NULL);
#endif
		afreeall(APERM);
		for (fd = 3; fd < NUFILE; fd++)
			if ((i = fcntl(fd, F_GETFD, 0)) != -1 &&
			    (i & FD_CLOEXEC))
				close(fd);
		close(2);
		close(1);
		close(0);
#endif
		exit(exstat & 0xFF);
	}
	if (shf)
		shf_close(shf);
	reclaim();

	e = e->oenv;

	/* free the struct env - tricky due to the ALLOC_ITEM inside */
	cp = (void *)ep;
	afree(cp + sizeof(ALLOC_ITEM), ATEMP);
}

/* Called after a fork to cleanup stuff left over from parents environment */
void
cleanup_parents_env(void)
{
	struct env *ep;
	int fd;

	/*
	 * Don't clean up temporary files - parent will probably need them.
	 * Also, can't easily reclaim memory since variables, etc. could be
	 * anywhere.
	 */

	/* close all file descriptors hiding in savefd */
	for (ep = e; ep; ep = ep->oenv) {
		if (ep->savefd) {
			for (fd = 0; fd < NUFILE; fd++)
				if (ep->savefd[fd] > 0)
					close(ep->savefd[fd]);
			afree(ep->savefd, &ep->area);
			ep->savefd = NULL;
		}
#ifdef DEBUG_LEAKS
		if (ep->type != E_NONE)
			ep->type = E_GONE;
#endif
	}
#ifndef DEBUG_LEAKS
	e->oenv = NULL;
#endif
}

/* Called just before an execve cleanup stuff temporary files */
void
cleanup_proc_env(void)
{
	struct env *ep;

	for (ep = e; ep; ep = ep->oenv)
		remove_temps(ep->temps);
}

/* remove temp files and free ATEMP Area */
static void
reclaim(void)
{
	struct block *l;

	while ((l = e->loc) && (!e->oenv || e->oenv->loc != l)) {
		e->loc = l->next;
		afreeall(&l->area);
	}

	remove_temps(e->temps);
	e->temps = NULL;

	/*
	 * if the memory backing source is reclaimed, things
	 * will end up badly when a function expecting it to
	 * be valid is run; a NULL pointer is easily debugged
	 */
	if (source && source->areap == &e->area)
		source = NULL;
	afreeall(&e->area);
}

static void
remove_temps(struct temp *tp)
{
	while (tp) {
		if (tp->pid == procpid)
			unlink(tp->tffn);
		tp = tp->next;
	}
}

/*
 * Initialise tty_fd. Used for tracking the size of the terminal,
 * saving/resetting tty modes upon forground job completion, and
 * for setting up the tty process group. Return values:
 *	0 = got controlling tty
 *	1 = got terminal but no controlling tty
 *	2 = cannot find a terminal
 *	3 = cannot dup fd
 *	4 = cannot make fd close-on-exec
 * An existing tty_fd is cached if no "better" one could be found,
 * i.e. if tty_devtty was already set or the new would not set it.
 */
int
tty_init_fd(void)
{
	int fd, rv, eno = 0;
	bool do_close = false, is_devtty = true;

	if (tty_devtty) {
		/* already got a tty which is /dev/tty */
		return (0);
	}

#ifdef _UWIN
	/*XXX imake style */
	if (isatty(3)) {
		/* fd 3 on UWIN _is_ /dev/tty (or our controlling tty) */
		fd = 3;
		goto got_fd;
	}
#endif
	if ((fd = open(T_devtty, O_RDWR, 0)) >= 0) {
		do_close = true;
		goto got_fd;
	}
	eno = errno;

	if (tty_fd >= 0) {
		/* already got a non-devtty one */
		rv = 1;
		goto out;
	}
	is_devtty = false;

	if (isatty((fd = 0)) || isatty((fd = 2)))
		goto got_fd;
	/* cannot find one */
	rv = 2;
	/* assert: do_close == false */
	goto out;

 got_fd:
	if ((rv = fcntl(fd, F_DUPFD, FDBASE)) < 0) {
		eno = errno;
		rv = 3;
		goto out;
	}
	if (fcntl(rv, F_SETFD, FD_CLOEXEC) < 0) {
		eno = errno;
		close(rv);
		rv = 4;
		goto out;
	}
	tty_fd = rv;
	tty_devtty = is_devtty;
	rv = eno = 0;
 out:
	if (do_close)
		close(fd);
	errno = eno;
	return (rv);
}

/* A shell error occurred (eg, syntax error, etc.) */

#define VWARNINGF_ERRORPREFIX	1
#define VWARNINGF_FILELINE	2
#define VWARNINGF_BUILTIN	4
#define VWARNINGF_INTERNAL	8

static void vwarningf(unsigned int, const char *, va_list)
    MKSH_A_FORMAT(__printf__, 2, 0);

static void
vwarningf(unsigned int flags, const char *fmt, va_list ap)
{
	if (fmt) {
		if (flags & VWARNINGF_INTERNAL)
			shf_fprintf(shl_out, Tf_sD_, "internal error");
		if (flags & VWARNINGF_ERRORPREFIX)
			error_prefix(tobool(flags & VWARNINGF_FILELINE));
		if ((flags & VWARNINGF_BUILTIN) &&
		    /* not set when main() calls parse_args() */
		    builtin_argv0 && builtin_argv0 != kshname)
			shf_fprintf(shl_out, Tf_sD_, builtin_argv0);
		shf_vfprintf(shl_out, fmt, ap);
		shf_putchar('\n', shl_out);
	}
	shf_flush(shl_out);
}

void
errorfx(int rc, const char *fmt, ...)
{
	va_list va;

	exstat = rc;

	/* debugging: note that stdout not valid */
	shl_stdout_ok = false;

	va_start(va, fmt);
	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE, fmt, va);
	va_end(va);
	unwind(LERROR);
}

void
errorf(const char *fmt, ...)
{
	va_list va;

	exstat = 1;

	/* debugging: note that stdout not valid */
	shl_stdout_ok = false;

	va_start(va, fmt);
	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE, fmt, va);
	va_end(va);
	unwind(LERROR);
}

/* like errorf(), but no unwind is done */
void
warningf(bool fileline, const char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	vwarningf(VWARNINGF_ERRORPREFIX | (fileline ? VWARNINGF_FILELINE : 0),
	    fmt, va);
	va_end(va);
}

/*
 * Used by built-in utilities to prefix shell and utility name to message
 * (also unwinds environments for special builtins).
 */
void
bi_errorf(const char *fmt, ...)
{
	va_list va;

	/* debugging: note that stdout not valid */
	shl_stdout_ok = false;

	exstat = 1;

	va_start(va, fmt);
	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE |
	    VWARNINGF_BUILTIN, fmt, va);
	va_end(va);

	/* POSIX special builtins cause non-interactive shells to exit */
	if (builtin_spec) {
		builtin_argv0 = NULL;
		/* may not want to use LERROR here */
		unwind(LERROR);
	}
}

/*
 * Used by functions called by builtins and not:
 * identical to errorfx if first argument is nil,
 * like bi_errorf storing the errorlevel into it otherwise
 */
void
maybe_errorf(int *ep, int rc, const char *fmt, ...)
{
	va_list va;

	/* debugging: note that stdout not valid */
	shl_stdout_ok = false;

	exstat = rc;

	va_start(va, fmt);
	vwarningf(VWARNINGF_ERRORPREFIX | VWARNINGF_FILELINE |
	    (ep ? VWARNINGF_BUILTIN : 0), fmt, va);
	va_end(va);

	if (!ep)
		goto and_out;
	*ep = rc;

	/* POSIX special builtins cause non-interactive shells to exit */
	if (builtin_spec) {
		builtin_argv0 = NULL;
		/* may not want to use LERROR here */
 and_out:
		unwind(LERROR);
	}
}

/* Called when something that shouldn't happen does */
void
internal_errorf(const char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	vwarningf(VWARNINGF_INTERNAL, fmt, va);
	va_end(va);
	unwind(LERROR);
}

void
internal_warningf(const char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	vwarningf(VWARNINGF_INTERNAL, fmt, va);
	va_end(va);
}

/* used by error reporting functions to print "ksh: .kshrc[25]: " */
void
error_prefix(bool fileline)
{
	/* Avoid foo: foo[2]: ... */
	if (!fileline || !source || !source->file ||
	    strcmp(source->file, kshname) != 0)
		shf_fprintf(shl_out, Tf_sD_, kshname + (*kshname == '-'));
	if (fileline && source && source->file != NULL) {
		shf_fprintf(shl_out, "%s[%lu]: ", source->file,
		    (unsigned long)(source->errline ?
		    source->errline : source->line));
		source->errline = 0;
	}
}

/* printf to shl_out (stderr) with flush */
void
shellf(const char *fmt, ...)
{
	va_list va;

	if (!initio_done)
		/* shl_out may not be set up yet... */
		return;
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	va_end(va);
	shf_flush(shl_out);
}

/* printf to shl_stdout (stdout) */
void
shprintf(const char *fmt, ...)
{
	va_list va;

	if (!shl_stdout_ok)
		internal_errorf("shl_stdout not valid");
	va_start(va, fmt);
	shf_vfprintf(shl_stdout, fmt, va);
	va_end(va);
}

/* test if we can seek backwards fd (returns 0 or SHF_UNBUF) */
int
can_seek(int fd)
{
	struct stat statb;

	return (fstat(fd, &statb) == 0 && !S_ISREG(statb.st_mode) ?
	    SHF_UNBUF : 0);
}

#ifdef DF
int shl_dbg_fd;
#define NSHF_IOB 4
#else
#define NSHF_IOB 3
#endif
struct shf shf_iob[NSHF_IOB];

void
initio(void)
{
#ifdef DF
	const char *lfp;
#endif

	/* force buffer allocation */
	shf_fdopen(1, SHF_WR, shl_stdout);
	shf_fdopen(2, SHF_WR, shl_out);
	shf_fdopen(2, SHF_WR, shl_xtrace);
#ifdef DF
	if ((lfp = getenv("SDMKSH_PATH")) == NULL) {
		if ((lfp = getenv("HOME")) == NULL || !mksh_abspath(lfp))
			errorf("can't get home directory");
		strpathx(lfp, lfp, "mksh-dbg.txt", 1);
	}

	if ((shl_dbg_fd = open(lfp, O_WRONLY | O_APPEND | O_CREAT, 0600)) < 0)
		errorf("can't open debug output file %s", lfp);
	if (shl_dbg_fd < FDBASE) {
		int nfd;

		nfd = fcntl(shl_dbg_fd, F_DUPFD, FDBASE);
		close(shl_dbg_fd);
		if ((shl_dbg_fd = nfd) == -1)
			errorf("can't dup debug output file");
	}
	fcntl(shl_dbg_fd, F_SETFD, FD_CLOEXEC);
	shf_fdopen(shl_dbg_fd, SHF_WR, shl_dbg);
	DF("=== open ===");
#endif
	initio_done = true;
}

/* A dup2() with error checking */
int
ksh_dup2(int ofd, int nfd, bool errok)
{
	int rv;

	if (((rv = dup2(ofd, nfd)) < 0) && !errok && (errno != EBADF))
		errorf(Ttoo_many_files);

#ifdef __ultrix
	/*XXX imake style */
	if (rv >= 0)
		fcntl(nfd, F_SETFD, 0);
#endif

	return (rv);
}

/*
 * Move fd from user space (0 <= fd < 10) to shell space (fd >= 10),
 * set close-on-exec flag. See FDBASE in sh.h, maybe 24 not 10 here.
 */
short
savefd(int fd)
{
	int nfd = fd;

	if (fd < FDBASE && (nfd = fcntl(fd, F_DUPFD, FDBASE)) < 0 &&
	    (errno == EBADF || errno == EPERM))
		return (-1);
	if (nfd < 0 || nfd > SHRT_MAX)
		errorf(Ttoo_many_files);
	fcntl(nfd, F_SETFD, FD_CLOEXEC);
	return ((short)nfd);
}

void
restfd(int fd, int ofd)
{
	if (fd == 2)
		shf_flush(&shf_iob[/* fd */ 2]);
	if (ofd < 0)
		/* original fd closed */
		close(fd);
	else if (fd != ofd) {
		/*XXX: what to do if this dup fails? */
		ksh_dup2(ofd, fd, true);
		close(ofd);
	}
}

void
openpipe(int *pv)
{
	int lpv[2];

	if (pipe(lpv) < 0)
		errorf("can't create pipe - try again");
	pv[0] = savefd(lpv[0]);
	if (pv[0] != lpv[0])
		close(lpv[0]);
	pv[1] = savefd(lpv[1]);
	if (pv[1] != lpv[1])
		close(lpv[1]);
#ifdef __OS2__
	setmode(pv[0], O_BINARY);
	setmode(pv[1], O_BINARY);
#endif
}

void
closepipe(int *pv)
{
	close(pv[0]);
	close(pv[1]);
}

/*
 * Called by iosetup() (deals with 2>&4, etc.), c_read, c_print to turn
 * a string (the X in 2>&X, read -uX, print -uX) into a file descriptor.
 */
int
check_fd(const char *name, int mode, const char **emsgp)
{
	int fd, fl;

	if (!name[0] || name[1])
		goto illegal_fd_name;
	if (name[0] == 'p')
		return (coproc_getfd(mode, emsgp));
	if (!ctype(name[0], C_DIGIT)) {
 illegal_fd_name:
		if (emsgp)
			*emsgp = "illegal file descriptor name";
		return (-1);
	}

	if ((fl = fcntl((fd = ksh_numdig(name[0])), F_GETFL, 0)) < 0) {
		if (emsgp)
			*emsgp = "bad file descriptor";
		return (-1);
	}
	fl &= O_ACCMODE;
	/*
	 * X_OK is a kludge to disable this check for dups (x<&1):
	 * historical shells never did this check (XXX don't know what
	 * POSIX has to say).
	 */
	if (!(mode & X_OK) && fl != O_RDWR && (
	    ((mode & R_OK) && fl != O_RDONLY) ||
	    ((mode & W_OK) && fl != O_WRONLY))) {
		if (emsgp)
			*emsgp = (fl == O_WRONLY) ?
			    "fd not open for reading" :
			    "fd not open for writing";
		return (-1);
	}
	return (fd);
}

/* Called once from main */
void
coproc_init(void)
{
	coproc.read = coproc.readw = coproc.write = -1;
	coproc.njobs = 0;
	coproc.id = 0;
}

/* Called by c_read() when eof is read - close fd if it is the co-process fd */
void
coproc_read_close(int fd)
{
	if (coproc.read >= 0 && fd == coproc.read) {
		coproc_readw_close(fd);
		close(coproc.read);
		coproc.read = -1;
	}
}

/*
 * Called by c_read() and by iosetup() to close the other side of the
 * read pipe, so reads will actually terminate.
 */
void
coproc_readw_close(int fd)
{
	if (coproc.readw >= 0 && coproc.read >= 0 && fd == coproc.read) {
		close(coproc.readw);
		coproc.readw = -1;
	}
}

/*
 * Called by c_print when a write to a fd fails with EPIPE and by iosetup
 * when co-process input is dup'd
 */
void
coproc_write_close(int fd)
{
	if (coproc.write >= 0 && fd == coproc.write) {
		close(coproc.write);
		coproc.write = -1;
	}
}

/*
 * Called to check for existence of/value of the co-process file descriptor.
 * (Used by check_fd() and by c_read/c_print to deal with -p option).
 */
int
coproc_getfd(int mode, const char **emsgp)
{
	int fd = (mode & R_OK) ? coproc.read : coproc.write;

	if (fd >= 0)
		return (fd);
	if (emsgp)
		*emsgp = "no coprocess";
	return (-1);
}

/*
 * called to close file descriptors related to the coprocess (if any)
 * Should be called with SIGCHLD blocked.
 */
void
coproc_cleanup(int reuse)
{
	/* This to allow co-processes to share output pipe */
	if (!reuse || coproc.readw < 0 || coproc.read < 0) {
		if (coproc.read >= 0) {
			close(coproc.read);
			coproc.read = -1;
		}
		if (coproc.readw >= 0) {
			close(coproc.readw);
			coproc.readw = -1;
		}
	}
	if (coproc.write >= 0) {
		close(coproc.write);
		coproc.write = -1;
	}
}

struct temp *
maketemp(Area *ap, Temp_type type, struct temp **tlist)
{
	char *cp;
	size_t len;
	int i, j;
	struct temp *tp;
	const char *dir;
	struct stat sb;

	dir = tmpdir ? tmpdir : MKSH_DEFAULT_TMPDIR;
	/* add "/shXXXXXX.tmp" plus NUL */
	len = strlen(dir);
	checkoktoadd(len, offsetof(struct temp, tffn[0]) + 14);
	tp = alloc(offsetof(struct temp, tffn[0]) + 14 + len, ap);

	tp->shf = NULL;
	tp->pid = procpid;
	tp->type = type;

	if (stat(dir, &sb) || !S_ISDIR(sb.st_mode)) {
		tp->tffn[0] = '\0';
		goto maketemp_out;
	}

	cp = (void *)tp;
	cp += offsetof(struct temp, tffn[0]);
	memcpy(cp, dir, len);
	cp += len;
	memcpy(cp, "/shXXXXXX.tmp", 14);
	/* point to the first of six Xes */
	cp += 3;

	/* cyclically attempt to open a temporary file */
	do {
		/* generate random part of filename */
		len = 0;
		do {
			cp[len++] = digits_lc[rndget() % 36];
		} while (len < 6);

		/* check if this one works */
		if ((i = binopen3(tp->tffn, O_CREAT | O_EXCL | O_RDWR,
		    0600)) < 0 && errno != EEXIST)
			goto maketemp_out;
	} while (i < 0);

	if (type == TT_FUNSUB) {
		/* map us high and mark as close-on-exec */
		if ((j = savefd(i)) != i) {
			close(i);
			i = j;
		}

		/* operation mode for the shf */
		j = SHF_RD;
	} else
		j = SHF_WR;

	/* shf_fdopen cannot fail, so no fd leak */
	tp->shf = shf_fdopen(i, j, NULL);

 maketemp_out:
	tp->next = *tlist;
	*tlist = tp;
	return (tp);
}

/*
 * We use a similar collision resolution algorithm as Python 2.5.4
 * but with a slightly tweaked implementation written from scratch.
 */

#define	INIT_TBLSHIFT	3	/* initial table shift (2^3 = 8) */
#define PERTURB_SHIFT	5	/* see Python 2.5.4 Objects/dictobject.c */

static void tgrow(struct table *);
static int tnamecmp(const void *, const void *);

static void
tgrow(struct table *tp)
{
	size_t i, j, osize, mask, perturb;
	struct tbl *tblp, **pp;
	struct tbl **ntblp, **otblp = tp->tbls;

	if (tp->tshift > 29)
		internal_errorf("hash table size limit reached");

	/* calculate old size, new shift and new size */
	osize = (size_t)1 << (tp->tshift++);
	i = osize << 1;

	ntblp = alloc2(i, sizeof(struct tbl *), tp->areap);
	/* multiplication cannot overflow: alloc2 checked that */
	memset(ntblp, 0, i * sizeof(struct tbl *));

	/* table can get very full when reaching its size limit */
	tp->nfree = (tp->tshift == 30) ? 0x3FFF0000UL :
	    /* but otherwise, only 75% */
	    ((i * 3) / 4);
	tp->tbls = ntblp;
	if (otblp == NULL)
		return;

	mask = i - 1;
	for (i = 0; i < osize; i++)
		if ((tblp = otblp[i]) != NULL) {
			if ((tblp->flag & DEFINED)) {
				/* search for free hash table slot */
				j = perturb = tblp->ua.hval;
				goto find_first_empty_slot;
 find_next_empty_slot:
				j = (j << 2) + j + perturb + 1;
				perturb >>= PERTURB_SHIFT;
 find_first_empty_slot:
				pp = &ntblp[j & mask];
				if (*pp != NULL)
					goto find_next_empty_slot;
				/* found an empty hash table slot */
				*pp = tblp;
				tp->nfree--;
			} else if (!(tblp->flag & FINUSE)) {
				afree(tblp, tp->areap);
			}
		}
	afree(otblp, tp->areap);
}

void
ktinit(Area *ap, struct table *tp, uint8_t initshift)
{
	tp->areap = ap;
	tp->tbls = NULL;
	tp->tshift = ((initshift > INIT_TBLSHIFT) ?
	    initshift : INIT_TBLSHIFT) - 1;
	tgrow(tp);
}

/* table, name (key) to search for, hash(name), rv pointer to tbl ptr */
struct tbl *
ktscan(struct table *tp, const char *name, uint32_t h, struct tbl ***ppp)
{
	size_t j, perturb, mask;
	struct tbl **pp, *p;

	mask = ((size_t)1 << (tp->tshift)) - 1;
	/* search for hash table slot matching name */
	j = perturb = h;
	goto find_first_slot;
 find_next_slot:
	j = (j << 2) + j + perturb + 1;
	perturb >>= PERTURB_SHIFT;
 find_first_slot:
	pp = &tp->tbls[j & mask];
	if ((p = *pp) != NULL && (p->ua.hval != h || !(p->flag & DEFINED) ||
	    strcmp(p->name, name)))
		goto find_next_slot;
	/* p == NULL if not found, correct found entry otherwise */
	if (ppp)
		*ppp = pp;
	return (p);
}

/* table, name (key) to enter, hash(n) */
struct tbl *
ktenter(struct table *tp, const char *n, uint32_t h)
{
	struct tbl **pp, *p;
	size_t len;

 Search:
	if ((p = ktscan(tp, n, h, &pp)))
		return (p);

	if (tp->nfree == 0) {
		/* too full */
		tgrow(tp);
		goto Search;
	}

	/* create new tbl entry */
	len = strlen(n);
	checkoktoadd(len, offsetof(struct tbl, name[0]) + 1);
	p = alloc(offsetof(struct tbl, name[0]) + ++len, tp->areap);
	p->flag = 0;
	p->type = 0;
	p->areap = tp->areap;
	p->ua.hval = h;
	p->u2.field = 0;
	p->u.array = NULL;
	memcpy(p->name, n, len);

	/* enter in tp->tbls */
	tp->nfree--;
	*pp = p;
	return (p);
}

void
ktwalk(struct tstate *ts, struct table *tp)
{
	ts->left = (size_t)1 << (tp->tshift);
	ts->next = tp->tbls;
}

struct tbl *
ktnext(struct tstate *ts)
{
	while (--ts->left >= 0) {
		struct tbl *p = *ts->next++;
		if (p != NULL && (p->flag & DEFINED))
			return (p);
	}
	return (NULL);
}

static int
tnamecmp(const void *p1, const void *p2)
{
	const struct tbl *a = *((const struct tbl * const *)p1);
	const struct tbl *b = *((const struct tbl * const *)p2);

	return (ascstrcmp(a->name, b->name));
}

struct tbl **
ktsort(struct table *tp)
{
	size_t i;
	struct tbl **p, **sp, **dp;

	/*
	 * since the table is never entirely full, no need to reserve
	 * additional space for the trailing NULL appended below
	 */
	i = (size_t)1 << (tp->tshift);
	p = alloc2(i, sizeof(struct tbl *), ATEMP);
	sp = tp->tbls;		/* source */
	dp = p;			/* dest */
	while (i--)
		if ((*dp = *sp++) != NULL && (((*dp)->flag & DEFINED) ||
		    ((*dp)->flag & ARRAY)))
			dp++;
	qsort(p, (i = dp - p), sizeof(struct tbl *), tnamecmp);
	p[i] = NULL;
	return (p);
}

#ifdef SIGWINCH
static void
x_sigwinch(int sig MKSH_A_UNUSED)
{
	/* this runs inside interrupt context, with errno saved */

	got_winch = 1;
}
#endif

#ifdef DF
void
DF(const char *fmt, ...)
{
	va_list args;
	struct timeval tv;
	mirtime_mjd mjd;

	mksh_lockfd(shl_dbg_fd);
	mksh_TIME(tv);
	timet2mjd(&mjd, tv.tv_sec);
	shf_fprintf(shl_dbg, "[%02u:%02u:%02u (%u) %u.%06u] ",
	    (unsigned)mjd.sec / 3600, ((unsigned)mjd.sec / 60) % 60,
	    (unsigned)mjd.sec % 60, (unsigned)getpid(),
	    (unsigned)tv.tv_sec, (unsigned)tv.tv_usec);
	va_start(args, fmt);
	shf_vfprintf(shl_dbg, fmt, args);
	va_end(args);
	shf_putc('\n', shl_dbg);
	shf_flush(shl_dbg);
	mksh_unlkfd(shl_dbg_fd);
}
#endif

void
x_mkraw(int fd, mksh_ttyst *ocb, bool forread)
{
	mksh_ttyst cb;

	if (ocb)
		mksh_tcget(fd, ocb);
	else
		ocb = &tty_state;

	cb = *ocb;
	if (forread) {
		cb.c_iflag &= ~(ISTRIP);
		cb.c_lflag &= ~(ICANON) | ECHO;
	} else {
		cb.c_iflag &= ~(INLCR | ICRNL | ISTRIP);
		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
	}
#if defined(VLNEXT) && defined(_POSIX_VDISABLE)
	/* OSF/1 processes lnext when ~icanon */
	cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
#endif
	/* SunOS 4.1.x and OSF/1 process discard(flush) when ~icanon */
#if defined(VDISCARD) && defined(_POSIX_VDISABLE)
	cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
#endif
	cb.c_cc[VTIME] = 0;
	cb.c_cc[VMIN] = 1;

	mksh_tcset(fd, &cb);
}

#ifdef MKSH_ENVDIR
static void
init_environ(void)
{
	char *xp;
	ssize_t n;
	XString xs;
	struct shf *shf;
	DIR *dirp;
	struct dirent *dent;

	if ((dirp = opendir(MKSH_ENVDIR)) == NULL) {
		warningf(false, "cannot read environment from %s: %s",
		    MKSH_ENVDIR, cstrerror(errno));
		return;
	}
	XinitN(xs, 256, ATEMP);
 read_envfile:
	errno = 0;
	if ((dent = readdir(dirp)) != NULL) {
		if (skip_varname(dent->d_name, true)[0] == '\0') {
			strpathx(xp, MKSH_ENVDIR, dent->d_name, 1);
			if (!(shf = shf_open(xp, O_RDONLY, 0, 0))) {
				warningf(false,
				    "cannot read environment %s from %s: %s",
				    dent->d_name, MKSH_ENVDIR,
				    cstrerror(errno));
				goto read_envfile;
			}
			afree(xp, ATEMP);
			n = strlen(dent->d_name);
			xp = Xstring(xs, xp);
			XcheckN(xs, xp, n + 32);
			memcpy(xp, dent->d_name, n);
			xp += n;
			*xp++ = '=';
			while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
				xp += n;
				if (Xnleft(xs, xp) <= 0)
					XcheckN(xs, xp, Xlength(xs, xp));
			}
			if (n < 0) {
				warningf(false,
				    "cannot read environment %s from %s: %s",
				    dent->d_name, MKSH_ENVDIR,
				    cstrerror(shf_errno(shf)));
			} else {
				*xp = '\0';
				xp = Xstring(xs, xp);
				rndpush(xp);
				typeset(xp, IMPORT | EXPORT, 0, 0, 0);
			}
			shf_close(shf);
		}
		goto read_envfile;
	} else if (errno)
		warningf(false, "cannot read environment from %s: %s",
		    MKSH_ENVDIR, cstrerror(errno));
	closedir(dirp);
	Xfree(xs, xp);
}
#else
extern char **environ;

static void
init_environ(void)
{
	const char **wp;

	if (environ == NULL)
		return;

	wp = (const char **)environ;
	while (*wp != NULL) {
		rndpush(*wp);
		typeset(*wp, IMPORT | EXPORT, 0, 0, 0);
		++wp;
	}
}
#endif

#ifdef MKSH_EARLY_LOCALE_TRACKING
void
recheck_ctype(void)
{
	const char *ccp;
	uint8_t old_utfmode = UTFMODE;

	ccp = str_val(global("LC_ALL"));
	if (ccp == null)
		ccp = str_val(global("LC_CTYPE"));
	if (ccp == null)
		ccp = str_val(global("LANG"));
	UTFMODE = isuc(ccp);
#if HAVE_SETLOCALE_CTYPE
	ccp = setlocale(LC_CTYPE, ccp);
#if HAVE_LANGINFO_CODESET
	if (!isuc(ccp))
		ccp = nl_langinfo(CODESET);
#endif
	if (isuc(ccp))
		UTFMODE = 1;
#endif

	if (Flag(FPOSIX) && UTFMODE && !old_utfmode)
		warningf(true, "early locale tracking enabled UTF-8 mode while in POSIX mode, you are now noncompliant");
}
#endif
@


1.359
log
@revamp errexit handling

we lose some trap runs but this gets us identical to GNU bash so who cares…
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.357 2019/12/30 01:13:48 tg Exp $");
d809 2
d935 1
a935 1
	if (i == LERREXT && Flag(FEVALERR))
d995 1
a995 2
	ep->flags = 0;
	/* jump buffer is invalid because flags == 0 */
@


1.358
log
@clean up and update comment
@
text
@d741 1
d816 6
a821 5
		if (level != 2) {
			source = old_source;
			quitenv(NULL);
			internal_errorf(Tf_cant_s, Tshell,
			    i == LBREAK ? Tbreak : Tcontinue);
d824 3
a826 2
		/* assert: interactive == false */
		/* FALLTHROUGH */
d830 1
d861 2
d922 1
a923 1
	source = old_source;
d932 3
a934 13
	/*
	 * This might still be a kludge. We need to restore "everything"
	 * changed in the new environment, see cid 1005090337C7A669439
	 * and 10050903386452ACBF1, but don't save things most of the
	 * time. We use FEVALERR since we haven't saved the flags; this
	 * is mostly cleanup behind *other* callers of unwind(LERROR)
	 * here; exec.c has the regular case. If this explodes, see cids
	 * 1005E094F5633C8F0AB 1005E094FE436511ED6 1005E0950692C5D1944
	 */
	if (Flag(FEVALERR)) {
		/* GNU bash does not run this trapsig */
		trapsig(ksh_SIGERR);
	}
d937 1
a937 1
	if (i == LEXIT || ((i == LERROR || i == LINTR) &&
d944 1
a944 1
	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
d950 1
@


1.357
log
@scared of this change but it passes tests: g/c some
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.353 2019/12/11 20:11:13 tg Exp $");
d932 2
a933 1
	 * here; exec.c has the regular case.
@


1.356
log
@introduce FEVALERR to replace (FERREXIT & 0x80)

fixes “set -e appears active within eval but isn’t”
reported by Martijn Dekker
@
text
@a936 1
		Flag(FEVALERR) = 0;
@


1.355
log
@FERREXIT can only be 1 there
@
text
@d927 1
a927 1
	 * This is a kludge. We need to restore everything that was
d929 4
a932 6
	 * and 10050903386452ACBF1, but fail to even save things most of
	 * the time. funcs.c:c_eval() changes FERREXIT temporarily to 0,
	 * which needs to be restored thus (related to Debian #696823).
	 * We did not save the shell flags, so we use a special or'd
	 * value here... this is mostly to clean up behind *other*
	 * callers of unwind(LERROR) here; exec.c has the regular case.
d934 1
a934 1
	if (Flag(FERREXIT) & 0x80) {
d937 1
a937 1
		Flag(FERREXIT) &= ~0x80;
@


1.354
log
@further memory optimisation
@
text
@d950 1
a950 1
	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
@


1.353
log
@implement run-time setting of privileged option to realise setugid fully

to avoid needing an extra tool in cases like Debian #946599

set +p drops privs fully and irrevocably of course
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.351 2019/01/05 13:24:18 tg Exp $");
d1468 1
a1468 1
		lfp = shf_smprintf(Tf_sSs, lfp, "mksh-dbg.txt");
d2030 1
a2030 1
			xp = shf_smprintf(Tf_sSs, MKSH_ENVDIR, dent->d_name);
@


1.352
log
@fix this one, too
@
text
@d653 10
a662 1
	if (!Flag(FPRIVILEGED)) {
a669 5
	} else {
		include(MKSH_SUID_PROFILE, 0, NULL, true);
		/* turn off -p if not set explicitly */
		if (Flag(FPRIVILEGED) != 1)
			change_flag(FPRIVILEGED, OF_INTERNAL, false);
a670 1

@


1.351
log
@fix MKSH_EARLY_LOCALE_TRACKING warning
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.349 2018/05/08 17:37:36 tg Exp $");
d1333 33
@


1.350
log
@add O_MAYEXEC support for CLIP OS, zero cost otherwise

cf. https://lwn.net/Articles/768819/
@
text
@d8 2
a9 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d2059 1
d2077 1
a2077 1
	if (Flag(FPOSIX))
@


1.349
log
@fix using “-m” on the command line; spotted by G.raud <graud@@gmx.com> on ML
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.347 2018/01/13 21:45:07 tg Exp $");
d516 1
a516 1
		s->u.shf = shf_open(s->file, O_RDONLY, 0,
d716 1
a716 1
	shf = shf_open(name, O_RDONLY, 0, SHF_MAPHI | SHF_CLEXEC);
@


1.348
log
@minor spelling in comment
@
text
@d460 1
a460 1
	/* this to note if monitor is set on command line (see below) */
@


1.347
log
@warn when entering POSuX noncompliance
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.345 2017/10/14 21:05:22 tg Exp $");
d1962 1
a1962 1
	/* SunOS 4.1.x & OSF/1 processes discard(flush) when ~icanon */
@


1.346
log
@implement early (mediæval) locale tracking, as a compile-time option,
for SuSE; slightly inspired by the original patch submitted by
From: Dr. Werner Fink <werner@@suse.de>
@
text
@d2074 3
@


1.345
log
@add MKSH_ENVDIR code for Jehanne (OS by Shamar (giacomotesio) from IRC):
instead of parsing extern char **environ; read it from a filesystem
(typical for Plan 9, though this one is __jehanne__ per ifdef)

tested on MirBSD and found to be working
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.337 2017/04/27 19:33:51 tg Exp $");
d2052 24
@


1.344
log
@fix a longstanding double substitution
@
text
@a38 2
extern char **environ;

d53 1
d399 1
a399 8
	if (environ != NULL) {
		wp = (const char **)environ;
		while (*wp != NULL) {
			rndpush(*wp);
			typeset(*wp, IMPORT | EXPORT, 0, 0, 0);
			++wp;
		}
	}
d1971 81
@


1.343
log
@remove redundant OS/2 codes (from komh)

os2_init() does it.
@
text
@d664 1
a664 2
			cp = substitute(substitute("${ENV:-" MKSHRC_PATH "}",
			    0), DOTILDE);
@


1.342
log
@add -DMKSH_FAUX_EBCDIC to test the codepaths better

waking up to: Lanfear - Just Another Broken Shell
@
text
@a244 4
	for (i = 0; i < 3; ++i)
		if (!isatty(i))
			setmode(i, O_BINARY);

@


1.341
log
@commit the EBCDIC run-time table conversion code, so it can be reviewed

XXX there’s still the issue of compile-time character conversion, and
XXX that runtime m̲u̲s̲t̲ use a compatible codepage, which we cannot check,
XXX and that we need the POSIX portable character set mapped, which we
XXX decide to not check (due to the above, mostly)
@
text
@d239 1
a239 1
#ifdef MKSH_EBCDIC
@


1.340
log
@remove debugging code again
@
text
@d239 3
@


1.339
log
@debugging bugs in optimising
@
text
@a412 101
#define d(p,c) do {					\
	if (c < 33 || c > 0x7E)				\
		shellf("%s\\x%02X", p, c);		\
	else						\
		shellf("%s%c", p, c);			\
} while (0)
#define dmpcf(a,f) do {					\
	int c = -1, lc = -3, il = 0;			\
	shellf("%s\t",a);				\
	while (++c < 256) {				\
		if (!f) continue;			\
		if (lc + 1 == c) {			\
			il = 1;				\
		} else {				\
			if (il)				\
				d("‥", lc);		\
			il = 0;				\
			d("", c);			\
		}					\
		lc = c;					\
	}						\
	if (il)						\
		d("‥", lc);				\
	shellf(" █\n");					\
} while (0)
#define dmpct(a,b) dmpcf(a,ctype(c,b))
dmpct("C_ALIAS", C_ALIAS);
dmpct("C_ALNUM", C_ALNUM);
dmpct("C_ALNUX", C_ALNUX);
dmpct("C_ALPHA", C_ALPHA);
dmpct("C_ALPHX", C_ALPHX);
dmpct("C_BLANK", C_BLANK);
dmpct("C_CFS", C_CFS);
dmpct("C_CNTRL", C_CNTRL);
dmpct("C_COLON", C_COLON);
dmpct("C_DIGIT", C_DIGIT);
dmpct("C_DOLAR", C_DOLAR);
dmpct("C_EDCMD", C_EDCMD);
dmpct("C_EDNWC", C_EDNWC);
dmpct("C_EDQ", C_EDQ);
dmpct("C_GRAPH", C_GRAPH);
dmpct("C_HASH", C_HASH);
dmpct("C_HEXLT", C_HEXLT);
dmpct("C_IFS", C_IFS);
dmpct("C_IFSWS", C_IFSWS);
dmpct("C_LEX1", C_LEX1);
dmpct("C_LF", C_LF);
dmpct("C_LOWER", C_LOWER);
dmpct("C_MFS", C_MFS);
dmpct("C_NL", C_NL);
dmpct("C_NL", C_NL);
dmpct("C_NUL", C_NUL);
dmpct("C_OCTAL", C_OCTAL);
dmpct("C_PATMO", C_PATMO);
dmpct("C_PRINT", C_PRINT);
dmpct("C_PUNCT", C_PUNCT);
dmpct("C_QC", C_QC);
dmpct("C_QUOTE", C_QUOTE);
dmpct("C_SEDEC", C_SEDEC);
dmpct("C_SPACE", C_SPACE);
dmpct("C_SPC", C_SPC);
dmpct("C_SUB1", C_SUB1);
dmpct("C_SUB2", C_SUB2);
dmpct("C_TAB", C_TAB);
dmpct("C_UNDER", C_UNDER);
dmpct("C_UPPER", C_UPPER);
dmpct("C_VAR1", C_VAR1);
dmpct("CiALIAS", CiALIAS);
dmpct("CiANGLE", CiANGLE);
dmpct("CiCBRK", CiCBRK);
dmpct("CiCNTRL", CiCNTRL);
dmpct("CiCOLON", CiCOLON);
dmpct("CiCR", CiCR);
dmpct("CiCURLY", CiCURLY);
dmpct("CiDIGIT", CiDIGIT);
dmpct("CiEQUAL", CiEQUAL);
dmpct("CiGRAVE", CiGRAVE);
dmpct("CiHASH", CiHASH);
dmpct("CiHEXLT", CiHEXLT);
dmpct("CiIFS", CiIFS);
dmpct("CiLOWER", CiLOWER);
dmpct("CiMINUS", CiMINUS);
dmpct("CiNL", CiNL);
dmpct("CiNUL", CiNUL);
dmpct("CiOCTAL", CiOCTAL);
dmpct("CiPERCT", CiPERCT);
dmpct("CiPLUS", CiPLUS);
dmpct("CiQC", CiQC);
dmpct("CiQCL", CiQCL);
dmpct("CiQCM", CiQCM);
dmpct("CiQCX", CiQCX);
dmpct("CiQUEST", CiQUEST);
dmpct("CiSP", CiSP);
dmpct("CiSPX", CiSPX);
dmpct("CiSS", CiSS);
dmpct("CiTAB", CiTAB);
dmpct("CiUNDER", CiUNDER);
dmpct("CiUPPER", CiUPPER);
dmpct("CiVAR1", CiVAR1);
exit(0);

@


1.338
log
@batch of optimisations
@
text
@d413 101
@


1.337
log
@eliminate legacy macros
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.327 2017/03/19 22:23:45 tg Exp $");
d494 1
a494 1
			if (*s->str != ' ' && ctype(*s->str, C_QUOTE))
@


1.336
log
@convert to the new fast character classes
@
text
@a412 56
#define dmpcf(a,f) do {					\
	int c = -1, lc = -3, il = 0;			\
	shellf("%s\t",a);				\
	while (++c < 256) {				\
		if (!f) continue;			\
		if (lc + 1 == c) {			\
			il = 1;				\
		} else {				\
			if (il)				\
				shellf("‥%02X", lc);	\
			il = 0;				\
			shellf(" %02X", c);		\
		}					\
		lc = c;					\
	}						\
	if (il)						\
		shellf("‥%02X", lc);			\
	shellf(" .\n");					\
} while (0)
#define dmpct(a,b) dmpcf(a,ctype(c,b))
dmpct("C_ALIAS",C_ALIAS);
dmpct("C_ALNUM",C_ALNUM);
dmpct("C_ALNUX",C_ALNUX);
dmpct("C_ALPHA",C_ALPHA);
dmpct("C_ALPHX",C_ALPHX);
dmpct("C_BLANK",C_BLANK);
dmpct("C_CFS",C_CFS);
dmpct("C_CNTRL",C_CNTRL);
dmpct("C_DIGIT",C_DIGIT);
dmpct("C_DOLAR",C_DOLAR);
dmpct("C_GRAPH",C_GRAPH);
dmpct("C_HEXLT",C_HEXLT);
dmpct("C_IFS",C_IFS);
dmpct("C_IFSWS",C_IFSWS);
dmpct("C_LEX1",C_LEX1);
dmpct("C_LF",C_LF);
dmpct("C_LOWER",C_LOWER);
dmpct("C_MFS",C_MFS);
dmpct("C_NL",C_NL);
dmpct("C_NUL",C_NUL);
dmpct("C_OCTAL",C_OCTAL);
dmpct("C_PRINT",C_PRINT);
dmpct("C_PUNCT",C_PUNCT);
dmpct("C_QC",C_QC);
dmpct("C_QUOTE",C_QUOTE);
dmpct("C_SEDEC",C_SEDEC);
dmpct("C_SPACE",C_SPACE);
dmpct("C_SPC",C_SPC);
dmpct("C_SUB1",C_SUB1);
dmpct("C_SUB2",C_SUB2);
dmpct("C_TAB",C_TAB);
dmpct("C_UNDER",C_UNDER);
dmpct("C_UPPER",C_UPPER);
dmpct("C_VAR1",C_VAR1);
exit(0);

d1551 1
a1551 1
	if (!ksh_isdigit(name[0])) {
@


1.335
log
@debugging 1/2
@
text
@d239 2
a337 3
	/*XXX do this earlier, just call set_ifs(TC_IFSWS); with the new scheme, then ifs0 need not be E_INIT’d, drop initctypes and setctypes from misc.c/sh.h then */
	initctypes();

d433 4
d438 3
d442 5
d448 18
a466 13
dmpct("C_IFSWS",C_IFSWS);
dmpct("C_SUB1",C_SUBOP1);
dmpct("C_QUOTE",C_QUOTE);
dmpct("C_IFS",C_IFS);
dmpcf("C_SUB2",ksh_issubop2(c));
dmpcf("C_ALIAS",ksh_isalias(c));
dmpcf("C_ALPHA",ksh_isalpha(c));
dmpcf("C_ALNUX",ksh_isalnux(c));
dmpcf("C_LOWER",ksh_islower(c));
dmpcf("C_UPPER",ksh_isupper(c));
dmpcf("C_SPACE",ksh_isspace(c));
dmpcf("C_CFS",is_cfs(c));
dmpcf("C_MFS",is_mfs(c));
@


1.334
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.333 2017/04/21 20:06:04 tg Exp $");
d414 39
@


1.333
log
@now actually do comparisons for sorting ASCIIbetically
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.327 2017/03/19 22:23:45 tg Exp $");
d336 1
d412 1
a412 1
	typeset("IFS= \t\n", 0, 0, 0, 0);
@


1.332
log
@now we have cheap cta move them into compile time
@
text
@d1890 1
a1890 1
	return (strcmp(a->name, b->name));
@


1.331
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d102 45
@


1.330
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d665 1
a665 1
			shell(s, true);
d718 1
a718 1
			internal_errorf("include %d", i);
d729 1
a729 1
	i = shell(s, false);
d749 1
a749 1
	rv = shell(s, false);
d758 1
a758 1
shell(Source * volatile s, volatile bool toplevel)
d763 1
a763 1
	volatile bool interactive = Flag(FTALKING) && toplevel;
d768 1
a768 1
	newenv(E_PARSE);
d774 11
d824 1
a824 1
		internal_errorf("shell %d", i);
d862 1
a862 1
				if (toplevel)
d925 1
d1395 1
a1395 1
			errorf("cannot get home directory");
d1400 1
a1400 1
		errorf("cannot open debug output file %s", lfp);
d1407 1
a1407 1
			errorf("cannot dup debug output file");
d1423 1
a1423 1
		errorf("too many files open in shell");
d1447 1
a1447 1
		errorf("too many files open in shell");
@


1.329
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d830 1
a830 1
		t = compile(s, sfirst);
@


1.328
log
@add standard variable PATHSEP, for better and easier OS/2 support
@
text
@d198 2
d472 3
a474 1
		s->file = search_path(argv[argi++], path, X_OK, NULL);
d1468 4
@


1.327
log
@embed
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.323 2017/03/11 22:58:51 tg Exp $");
d367 1
@


1.326
log
@use \\builtin ipv \let] and \set internally
@
text
@a58 2
static const char initifs[] = "IFS= \t\n";

d364 1
a364 1
	typeset(initifs, 0, 0, 0, 0);
@


1.325
log
@use the new “\builtin” builtin for quoting, everywhere
@
text
@d260 1
a260 1
	    /* currently up to 55 builtins: 75% of 128 = 2^7 */
@


1.324
log
@add “\builtin” utility
@
text
@d74 2
a75 2
	"integer=\\typeset -i",
	"local=\\typeset",
d77 6
a82 6
	"hash=\\builtin alias -t",
	"type=\\builtin whence -v",
	"autoload=\\typeset -fu",
	"functions=\\typeset -f",
	"history=\\builtin fc -l",
	"nameref=\\typeset -n",
d84 2
a85 2
	"r=\\builtin fc -e -",
	"login=\\exec login",
@


1.323
log
@remove odd use of KEEPASN, I believe it really unnecessary now
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.307 2016/01/21 18:24:42 tg Exp $");
d260 1
a260 1
	    /* currently up to 54 builtins: 75% of 128 = 2^7 */
d385 1
a385 1
		shcomexec(wp);
d630 1
a630 1
		shcomexec(restr_com);
d660 1
a660 1
			rv = shcomexec(l->argv);
@


1.322
log
@gcc 6.2 warnings (stupid uninitialised that wasn't, plus FALLTHROUGH fixes)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d1274 1
a1274 4
	/*
	 * POSIX special builtins and ksh special builtins cause
	 * non-interactive shells to exit. XXX may not want LERROR here
	 */
d1277 1
@


1.321
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d569 1
a570 1
#endif
@


1.320
log
@shave five spaces off .rodata with no functional difference
@
text
@d230 1
a230 1
		if (i == '/') {
@


1.319
log
@avoid even the chance at UB, it’s too risky with “postmodern” compilers
@
text
@d62 6
a67 1
    "${PS2=> } ${PS3=#? } ${PS4=+ } ${SECONDS=0} ${TMOUT=0} ${EPOCHREALTIME=}";
@


1.318
log
@fix English (thanks to Andreas Buschka); TIL:
• to start ⇒ a start
• to begin ⇒ a beginning
@
text
@d114 1
a114 2
#ifdef DEBUG
	/* clear the allocated space, for valgrind */
a115 1
#endif
@


1.317
log
@fixup a bad OpenBSD reaction on a bug afl showed:

set source to NULL only if the memory backing source is actually reclaimed;
fixes segfault due to NULL(+24) pointer dereference reported by Score_Under
(simplified testcase added; thanks!)
@
text
@d225 1
a225 1
	goto begin_parse_kshname;
d229 1
a229 1
 begin_parse_kshname:
@


1.316
log
@assorted code cleanup, while here anyway
@
text
@a915 7
			/*
			 * quitenv() may have reclaimed the memory
			 * used by source which will end badly when
			 * we jump to a function that expects it to
			 * be valid
			 */
			source = NULL;
d1086 8
@


1.315
log
@make command() not trash the global source variable

removes local save/restore around it in two of three callers;
the third one is in runtrap() which… probably *cough* ought
to have danced the same…
@
text
@d1099 1
a1099 1
	for (; tp != NULL; tp = tp->next)
d1102 2
@


1.314
log
@remove fd>9 support in favour of upcoming named file descriptors; bump
@
text
@d737 2
a738 1
	Source *s;
d743 3
a745 1
	return (shell(s, false));
@


1.313
log
@add a testcase as documentation (why POSIX isn’t everything); fix comments
@
text
@d1474 1
a1474 1
	int fd = 0, fl;
d1476 3
a1478 1
	if (name[0] == 'p' && !name[1])
d1480 2
a1481 10
	while (ksh_isdigit(*name)) {
		fd = fd * 10 + ksh_numdig(*name);
		if (fd >= FDBASE) {
			if (emsgp)
				*emsgp = "file descriptor too large";
			return (-1);
		}
		++name;
	}
	if (*name) {
d1486 2
a1487 1
	if ((fl = fcntl(fd, F_GETFL, 0)) < 0) {
@


1.312
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d320 1
a320 1
		 * breaks somewhere; don't try to optimise,
@


1.311
log
@invent builtin flags instead of special-casing cat and printf for prefer-external-over-builtin stuff
@
text
@d66 1
a66 1
	Ttypeset, "-x", "HOME", "PATH", "SHELL", NULL,
d85 1
a85 1
	"make", "mv", "pr", "rm", "sed", "sh", "vi", "who", NULL,
d90 1
a90 1
	Ttypeset, "-r", "PATH", "ENV", "SHELL", NULL
d152 1
a152 1
	"mksh", NULL
d336 1
a336 1
	vp = global("PATH");
d369 1
a369 1
	vp = global("PWD");
d372 2
a373 2
	set_current_wd((mksh_abspath(cp) && test_eval(NULL, TO_FILEQ, cp, ".",
	    true)) ? cp : NULL);
d443 1
a443 1
			errorf("-c %s", "requires an argument");
d478 1
a478 1
			warningf(true, "%s: %s", s->file, cstrerror(errno));
d1132 1
a1132 1
	if ((fd = open("/dev/tty", O_RDWR, 0)) >= 0) {
d1189 1
a1189 1
			shf_fprintf(shl_out, "internal error: ");
d1195 1
a1195 1
			shf_fprintf(shl_out, "%s: ", builtin_argv0);
d1304 1
a1304 1
		shf_fprintf(shl_out, "%s: ", kshname + (*kshname == '-'));
d1374 1
a1374 1
		lfp = shf_smprintf("%s/mksh-dbg.txt", lfp);
@


1.310
log
@clean up, avoid aliasing concerns in non-debug case
@
text
@@


1.309
log
@plug a few display problems with special parameter name expansions
reported by Stéphane Chazelas
@
text
@d113 1
a113 1
	cp = alloc(sizeof(*bufptr) - ALLOC_SIZE, APERM);
d116 1
a116 1
	memset(cp, 0, sizeof(*bufptr) - ALLOC_SIZE);
d119 1
a119 1
	bufptr = (void *)(cp - ALLOC_SIZE);
d934 1
a934 1
	cp = alloc(sizeof(struct env) - ALLOC_SIZE, ATEMP);
d936 1
a936 1
	ep = (void *)(cp - ALLOC_SIZE);
d1032 1
a1032 1
	afree(cp + ALLOC_SIZE, ATEMP);
@


1.308
log
@implement mmap-using mechanism to catch buffer underruns inside mksh
(pulls stdio, is rather BSD-specific and memory-hungry and a bit slow)
@
text
@d211 2
@


1.307
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.300 2015/07/10 19:36:35 tg Exp $");
d133 3
@


1.306
log
@make “source” into a built-in command (keepasn, to match ksh93 and “dot”);
remove the “stop” alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015
d438 1
a438 1
			errorf("%s %s", "-c", "requires an argument");
d707 1
a707 1
			internal_errorf("%s %d", "include", i);
d799 1
a799 1
		internal_errorf("%s %d", "shell", i);
@


1.305
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@a73 5
#if !defined(ANDROID) && !defined(MKSH_UNEMPLOYED)
	/* not in Android for political reasons */
	/* not in ARGE mksh due to no job control */
	"stop=\\kill -STOP",
#endif
a79 1
	"source=PATH=$PATH" MKSH_PATHSEPE ". \\command .",
d252 1
a252 1
	    /* currently up to 51 builtins: 75% of 128 = 2^7 */
@


1.304
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d1268 1
a1268 2
	 * non-interactive shells to exit.
	 * XXX odd use of KEEPASN; also may not want LERROR here
@


1.303
log
@stop using issetugid(2) for ±p check as it’s probably not the right tool
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2015/09/01 17:46:31 tedu Exp $	*/
d3 1
a3 1
/*	$OpenBSD: io.c,v 1.25 2014/08/11 20:28:47 guenther Exp $	*/
@


1.302
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d9 1
a9 1
 *	mirabilos <tg@@mirbsd.org>
d419 1
a419 5
	Flag(FPRIVILEGED) = (
#if HAVE_ISSETUGID
	    issetugid() ||
#endif
	    kshuid != ksheuid || kshgid != kshegid) ? 2 : 0;
@


1.301
log
@quote path separator if ; in some cases; pointed out by komh
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2015/02/09 09:09:30 jsg Exp $	*/
d4 1
a4 1
/*	$OpenBSD: table.c,v 1.15 2012/02/19 07:52:30 otto Exp $	*/
d9 1
a9 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d205 1
a205 1
	/* make sure argv[] is sane */
@


1.300
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.290 2015/03/14 05:23:15 tg Exp $");
d85 1
a85 1
	"source=PATH=$PATH" MKSH_PATHSEPS ". \\command .",
@


1.299
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d46 1
a46 1
#define MKSH_DEFAULT_TMPDIR	"/tmp"
d85 1
a85 1
	"source=PATH=$PATH:. \\command .",
d327 4
a330 1
		def_path = "/bin:/usr/bin:/sbin:/usr/sbin";
d373 1
a373 1
	set_current_wd((cp[0] == '/' && test_eval(NULL, TO_FILEQ, cp, ".",
d1378 1
a1378 1
		if ((lfp = getenv("HOME")) == NULL || *lfp != '/')
@


1.298
log
@more easy OS/2 fixes

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d196 6
d1646 1
a1646 1
		if ((i = open(tp->tffn, O_CREAT | O_EXCL | O_RDWR | O_BINARY,
@


1.297
log
@a few more mksh-os2 inspired fixes
@
text
@d457 11
d469 1
@


1.296
log
@add a few generic fixes from mksh-os2

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d267 1
a267 1
		if (!strcmp(ccp, "sh")) {
@


1.295
log
@• revert the cat hack for realpath and rename
  ‣ I was convinced by several that more magic is never the solution
• fix a comment: function cat already had precedence
• change cat loader to look for existence, FPATH included, before
  ditching the builtin; note that in manpage
@
text
@d1407 1
a1407 1
	    errno == EBADF)
@


1.294
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d90 1
a90 1
	"cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
@


1.293
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d806 2
@


1.292
log
@ordinarily, lineno must be mksh_uari_t, but edit.c most of all isn’t ready,
so we mitigate a bit (in var.c mostly) and tweak another type already, and
add some checks (mksh_{,u}ari_t must fit into {,unsigned }long) and print
line numbers with %lu already
@
text
@d1462 1
a1462 1
		fd = (fd * 10) + *name - '0';
a1615 6
	/* generate random part of filename */
	len = -1;
	do {
		i = rndget() % 36;
		cp[++len] = i < 26 ? 'a' + i : '0' + i - 26;
	} while (len < 5);
d1618 10
a1627 3
	while ((i = open(tp->tffn, O_CREAT | O_EXCL | O_RDWR | O_BINARY,
	    0600)) < 0) {
		if (errno != EEXIST)
d1629 1
a1629 10
		/* count down from z to a then from 9 to 0 */
		while (cp[len] == '0')
			if (!len--)
				goto maketemp_out;
		if (cp[len] == 'a')
			cp[len] = '9';
		else
			--cp[len];
		/* do another cycle */
	}
@


1.291
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d1289 3
a1291 2
		shf_fprintf(shl_out, "%s[%d]: ", source->file,
		    source->errline > 0 ? source->errline : source->line);
@


1.290
log
@“local x=$1” is supposed to not field-split and so
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285 2014/10/12 21:58:52 tg Exp $");
d1456 1
a1456 1
	int fd, fl;
d1460 1
a1460 1
	for (fd = 0; ksh_isdigit(*name); ++name)
d1462 8
a1469 1
	if (*name || fd >= FDBASE) {
@


1.289
log
@• protect POSIX builtins and utilities from aliases, e.g:
  ‣ : → \:
  ‣ alias → \alias
    ⇒ except in some internally used cases, where we use \builtin alias
  ‣ command . → \command .
• protect Korn Shell builtins from aliases and functions, e.g:
  ‣ typeset → \builtin typeset
    ⇒ also unravels the “local” alias used
  ‣ print → \builtin print
• protect internally-used things from aliases
  ‣ “let]” is not a valid function name
  ‣ “set” is POSIX so we don’t expect anyone to override it in a function
• use “command -v” instead of “whence -p” (“which”) in most
  places; thanks izabera from #ed on IRC for pointing out
  that “command -v” is POSIX – except, “whence -p” a̲l̲w̲a̲y̲s̲ looks
  for an executable and shows its full pathname; “command -v”
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
• make most of dot.mkshrc work in the face of such aliases
  ‣ “ulimit -c” is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesn’t use them?
• update list of builtin aliases in the manpage
@
text
@d69 2
a70 2
	"integer=\\builtin typeset -i",
	"local=\\builtin typeset",
d79 2
a80 2
	"autoload=\\builtin typeset -fu",
	"functions=\\builtin typeset -f",
d82 1
a82 1
	"nameref=\\builtin typeset -n",
@


1.288
log
@remove some unused string pooling stuff
@
text
@d69 2
a70 2
	"integer=typeset -i",
	Tlocal_typeset,
d72 2
a73 2
	"hash=alias -t",
	"type=whence -v",
d77 1
a77 1
	"stop=kill -STOP",
d79 4
a82 4
	"autoload=typeset -fu",
	"functions=typeset -f",
	"history=fc -l",
	"nameref=typeset -n",
d84 3
a86 3
	"r=fc -e -",
	"source=PATH=$PATH:. command .",
	"login=exec login",
@


1.287
log
@oksh sync; unsure if it applies (with us using old_source and all) but
better be safe than sorry; it at least passes our testsuite

NOTE: people who can figure out how afl can be used for mksh welcome! ;-)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014
d84 1
a84 1
	Tr_fc_e_dash,
@


1.286
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2013/11/28 10:33:37 sobrado Exp $	*/
d895 7
@


1.285
log
@POSIX says “command” loses SPEC_BI and means it too

reported by ormaaj, who even asked on the austin ML
http://thread.gmane.org/gmane.comp.standards.posix.austin.general/9907/focus=9931
clarified by jilles; also make errorlevels match ksh93
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.284 2014/10/03 17:19:27 tg Exp $");
a1016 2
	mkssert(e != NULL);

@


1.285.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285 2014/10/12 21:58:52 tg Exp $");
d1017 2
@


1.285.2.2
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.55 2015/02/09 09:09:30 jsg Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285.2.1 2015/01/25 15:35:47 tg Exp $");
a894 7
			/*
			 * quitenv() may have reclaimed the memory
			 * used by source which will end badly when
			 * we jump to a function that expects it to
			 * be valid
			 */
			source = NULL;
@


1.285.2.3
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285.2.2 2015/03/01 15:43:01 tg Exp $");
d1456 1
a1456 1
	int fd = 0, fl;
d1460 1
a1460 1
	while (ksh_isdigit(*name)) {
d1462 1
a1462 8
		if (fd >= FDBASE) {
			if (emsgp)
				*emsgp = "file descriptor too large";
			return (-1);
		}
		++name;
	}
	if (*name) {
@


1.285.2.4
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.285.2.3 2015/04/12 22:32:29 tg Exp $");
d1289 2
a1290 3
		shf_fprintf(shl_out, "%s[%lu]: ", source->file,
		    (unsigned long)(source->errline ?
		    source->errline : source->line));
@


1.284
log
@use issetugid(2) as additional aid in determining if we are FPRIVILEGED
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.283 2014/10/02 13:55:16 tg Exp $");
d1247 1
a1247 1
	if (builtin_flag & SPEC_BI) {
@


1.283
log
@restore C99 compatibility: do not use “restricted” as an identifier
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.282 2014/10/02 13:53:54 tg Exp $");
d410 5
a414 1
	Flag(FPRIVILEGED) = (kshuid != ksheuid || kshgid != kshegid) ? 2 : 0;
@


1.282
log
@cease exporting $RANDOM (Debian #760857)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.281 2014/09/12 20:23:33 tg Exp $");
d187 1
a187 1
	unsigned char restricted, errexit, utf_flag;
d576 1
a576 1
	restricted = Flag(FRESTRICTED);
d606 1
a606 1
	if (restricted) {
@


1.281
log
@keeping up with the jones; RCS ID sync only:
we already fixed the list of builtins ages ago,
and don’t use weird unportable ioctl(2)s
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.280 2014/06/09 12:28:17 tg Exp $");
d66 1
a66 1
	Ttypeset, "-x", "HOME", "PATH", "RANDOM", "SHELL", NULL,
@


1.280
log
@fix the “set ±p” issue for good
cf. http://blog.cmpxchg8b.com/2013/08/security-debianisms.html
@
text
@d2 2
a3 2
/*	$OpenBSD: tty.c,v 1.9 2006/03/14 22:08:01 deraadt Exp $	*/
/*	$OpenBSD: io.c,v 1.23 2013/12/17 16:37:06 deraadt Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.279 2014/01/16 13:59:12 tg Exp $");
@


1.279
log
@remove (#ifdef DEBUG) obsolete integer wraparound runtime test (maybe do something for unsigneds later… but then, it’s the standard, and you’d notice very quickly, and check.t would)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.277 2014/01/11 18:09:40 tg Exp $");
d410 1
a410 1
	Flag(FPRIVILEGED) = kshuid != ksheuid || kshgid != kshegid;
d588 1
a588 1
	if (Flag(FLOGIN)) {
d590 10
a599 5
		if (!Flag(FPRIVILEGED))
			include(substitute("$HOME/.profile", 0), 0,
			    NULL, true);
	}
	if (Flag(FPRIVILEGED))
d601 3
a603 8
	else if (Flag(FTALKING)) {
		char *env_file;

		/* include $ENV */
		env_file = substitute(substitute("${ENV:-" MKSHRC_PATH "}", 0),
		    DOTILDE);
		if (*env_file != '\0')
			include(env_file, 0, NULL, true);
@


1.278
log
@• turn on brace expansion earlier, so MKSH_BINSHREDUCED turns it off
• add first (uninstallable) draft of a dash-mksh package in the same
  spirit joe-jupp has; requested by Kaarlo “janPasi” Poski
@
text
@a424 38
#if defined(DEBUG) && !defined(MKSH_LEGACY_MODE)
	/* test wraparound of arithmetic types */
	{
		volatile long xl;
		volatile unsigned long xul;
		volatile int xi;
		volatile unsigned int xui;
		volatile mksh_ari_t xa;
		volatile mksh_uari_t xua, xua2;
		volatile uint8_t xc;

		xa = 2147483647;
		xua = 2147483647;
		++xa;
		++xua;
		xua2 = xa;
		xl = xa;
		xul = xua;
		xa = 0;
		xua = 0;
		--xa;
		--xua;
		xi = xa;
		xui = xua;
		xa = -1;
		xua = xa;
		++xa;
		++xua;
		xc = 0;
		--xc;
		if ((xua2 != 2147483648UL) ||
		    (xl != (-2147483647L-1)) || (xul != 2147483648UL) ||
		    (xi != -1) || (xui != 4294967295U) ||
		    (xa != 0) || (xua != 0) || (xc != 255))
			errorf("integer wraparound test failed");
	}
#endif

@


1.277
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.276 2014/01/11 16:26:28 tg Exp $");
d233 17
a331 19
	/*
	 * Turn on nohup by default for now - will change to off
	 * by default once people are aware of its existence
	 * (AT&T ksh does not have a nohup option - it always sends
	 * the hup).
	 */
	Flag(FNOHUP) = 1;

	/*
	 * Turn on brace expansion by default. AT&T kshs that have
	 * alternation always have it on.
	 */
	Flag(FBRACEEXPAND) = 1;

	/*
	 * Turn on "set -x" inheritance by default.
	 */
	Flag(FXTRACEREC) = 1;

@


1.276
log
@make the code to exec simple commands also available for mksh_small
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.275 2014/01/05 21:57:26 tg Exp $");
a144 15
uint32_t
chvt_rndsetup(const void *bp, size_t sz)
{
	register uint32_t h;

	NZATInit(h);
	/* variation through pid, ppid, and the works */
	NZATUpdateMem(h, &rndsetupstate, sizeof(rndsetupstate));
	/* some variation, some possibly entropy, depending on OE */
	NZATUpdateMem(h, bp, sz);
	NZAATFinish(h);

	return (h);
}

d347 4
a350 2
	if (environ != NULL)
		for (wp = (const char **)environ; *wp != NULL; wp++)
d352 3
@


1.275
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.274 2014/01/05 19:11:45 tg Exp $");
a485 1
#if !defined(MKSH_SMALL)
a493 1
#endif
d874 1
a874 3
		}
#if !defined(MKSH_SMALL)
		  else if ((s->flags & SF_MAYEXEC) && t->type == TCOM)
a875 1
#endif
@


1.274
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.273 2013/11/30 17:33:50 tg Exp $");
a50 1
uint32_t chvt_rndsetup(const void *, size_t);
d544 2
a545 1
#elif MKSH_ASSUME_UTF8
d551 1
@


1.273
log
@RCSID-only oksh sync (their whitespace changes don’t apply to us)
note that emacs.c partial peereboom rewrite is *not* merged, and kept that way
@
text
@d3 1
a3 1
/*	$OpenBSD: io.c,v 1.22 2006/03/17 16:30:13 millert Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.272 2013/11/17 22:23:28 tg Exp $");
@


1.272
log
@apply patch by Steffen Daode Nurpmeso to drop ISTRIP termios mode
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2013/09/04 15:49:19 millert Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.270 2013/09/10 17:33:02 tg Exp $");
@


1.271
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d1924 1
d1927 1
a1927 1
		cb.c_iflag &= ~(INLCR | ICRNL);
@


1.270
log
@integrate latest changes from oksh: Wed Sep 4 15:49:19 2013 UTC by millert

Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.266 2013/06/03 22:28:04 tg Exp $");
d1661 2
a1662 1
	while ((i = open(tp->tffn, O_CREAT | O_EXCL | O_RDWR, 0600)) < 0) {
@


1.269
log
@Steffen Daode Nurpmeso found an actual bug:

Whenever the SIGEXIT trap was set (to anything, really)
syntax errors and interruptions were not ignored any more
in an interactive shell (where they should be, unless
set -e is used); fix that.

tbd: traps should probably only be marked as pending
and run for LLEAVE/E_NONE
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2013/06/15 17:25:19 millert Exp $	*/
a78 1
	"suspend=kill -STOP $$",
@


1.268
log
@Fix most “set -x” problems (LP#1179287)

• “set -x” manually (cmdline too) snapshots fd#2 now
• “set -o inherit-xtrace” introduced; default still enabled
• reverted iodup printing to pre-R45 behaviour
• made Flag(FXTRACE) a proper state machine
@
text
@d917 3
a919 2
	if (i == LEXIT ||
	    ((i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
@


1.267
log
@partial merge and full RCS ID sync with oksh

merged:
• new regression tests
• check.pl (tests/th) better tmpfile handling
• exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
• ksh.1 1.147: document the above
• eval.c 1.39: “Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).”
  ‣ additionally make shf_open() return errno and actually show
    the error message from the system
• regression-39 test: remove the “maybe” marker
  ‣ but decide on correct POSIX behaviour

already been fixed in mksh:
• check.pl (tests/th) exit 1 if tests fail

not merged:
• main.c 1.52: run traps in unwind() before exiting;
  I’m pretty sure this is already working as-should in mksh
• eval.c 1.38: “Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status.” As discussed in IRC, this is
  just plainly WRONG.
@
text
@d346 5
d1396 1
a1396 1
	shf_fdopen(2, SHF_WR, shl_spare);
@


1.266
log
@support n̲o̲t̲ fork(2)ing for -T (by prepending the tty with ‘!’); especially useful on Linux since our own setsid(2) is more annoying; gets rid of the need for oneit_lite and similar hacks; WARNING: also removes chown/chmod on the tty!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2012/09/10 01:25:30 tedu Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.263 2013/04/27 18:56:41 tg Exp $");
@


1.265
log
@fix a number of warnings and other issues:
• sig_t detection was a bit insane, it is a function-pointer type after all
• fix uninitialised variable in c_select which led to mistakenly accepting
  invalid (nōn-numeric) input and acting, randomly, upon it
• keep SIGCHLD blocked in child after forking longer, for job list manip
• block SIGCHLD ifdef DEBUG_LEAKS to not run job foo during/after afreeall
• fix annoying ISO C90 vs. C99 (un)signed constant warning
@
text
@d51 1
d141 11
d156 1
a156 1
	NZATUpdateMem(h, bufptr, sizeof(*bufptr));
d159 1
a159 2
	afree(cp, APERM);
	return ((mksh_uari_t)h);
@


1.264
log
@• Allow setting both -o posix and -o sh (although only in the same
  command; setting one still unsets the other at first)
• Change subst_exstat to be conformant unless -o sh is set and -o posix isn’t
• In lksh, make subst_exstat (newly) conformant if -o posix
• New MKSH_BINSHPOSIX to accompany MKSH_BINSHREDUCED
• Sync lksh manpage precisely
@
text
@d454 1
a454 1
		    (xl != -2147483648L) || (xul != 2147483648UL) ||
d1018 4
@


1.263
log
@can test wraparound not in lksh
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.262 2013/04/26 21:22:46 tg Exp $");
d254 8
d263 1
a263 2
		/* set FSH if we're called as -sh or /bin/sh or so */
		if (!strcmp(ccp, "sh"))
d266 2
@


1.262
log
@Oh well… this looks well, is done done, and gcc-snapshot doesn’t complain:
• correct order of built-in commands; use POSIX special versus “all others”
  plus “keeps assignments” as distinction, no longer play POSIX regular vs.
  others game; sync manpage
• fix LP#1156707: map (( internally to “let]” which is no valid function
  name and so can’t be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
• we do not need -Wno-overflow any more, either
• bump to R45
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.261 2013/03/29 17:33:07 tg Exp $");
d414 1
a414 1
#ifdef DEBUG
@


1.261
log
@now that funsub() is a separate function, and we don’t have the clobber
issue from longjmp any more, and that I thought to rewind the fd, finally
implement ${ …;} on deleted-after-open tempfiles without the need to reopen
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.260 2013/02/10 21:42:16 tg Exp $");
d241 1
a241 1
	    /* currently up to 50 builtins: 75% of 128 = 2^7 */
@


1.260
log
@as a more general solution to fd leak detection, just do CLOEXEC manually
(this also allows us to see “real” leaks)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.259 2013/02/10 21:17:07 tg Exp $");
d1597 1
a1597 1
	int i;
a1646 2
		int nfd;

d1648 1
a1648 1
		if ((nfd = savefd(i)) != i) {
d1650 1
a1650 1
			i = nfd;
d1652 5
a1656 1
	}
d1659 1
a1659 1
	tp->shf = shf_fdopen(i, SHF_WR, NULL);
@


1.259
log
@when leak debugging, free everything even in builtins
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.258 2013/02/10 19:05:37 tg Exp $");
d974 4
d1010 4
a1013 2
		if (tty_fd >= 0)
			close(tty_fd);
@


1.258
log
@improve DEBUG_LEAKS handling and fix freeing some locs
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.257 2013/02/10 18:17:30 tg Exp $");
d1049 4
d1054 1
d1056 1
@


1.257
log
@make DEBUG_LEAKS safely free all resources before the main shell exits
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.255 2013/02/10 17:43:07 tg Exp $");
d958 1
a958 1
	if (ep->oenv && ep->oenv->loc != ep->loc)
a973 2
		struct block *l;

a999 7
#ifdef DEBUG_LEAKS
		l = e->loc;
		while (l) {
			afreeall(&l->area);
			l = l->next;
		}
#endif
d1003 1
a1003 2
		if (Flag(FTALKING))
			x_done();
d1067 7
@


1.256
log
@for DEBUG_LEAKS, prevent “leaking” of fds, even if they’re close-on-exit
@
text
@d974 2
d1002 7
@


1.255
log
@experimentally enable afreeall(APERM) too, LP#1106116
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.253 2013/02/10 17:38:14 tg Exp $");
d1007 5
@


1.254
log
@call it DEBUG_LEAKS so Android can always enable it
@
text
@d1006 1
a1006 1
//		afreeall(APERM);
@


1.253
log
@call afreeall(AEDIT) upon close; related to LP#1106116
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.252 2013/01/06 18:44:07 tg Exp $");
d1001 1
a1001 1
#ifdef DEBUG
@


1.252
log
@do not, ever, even in local-only debugging examples, create anything
in /tmp without the use of mkstemp(3) or similar!
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.251 2013/01/01 22:23:16 tg Exp $");
d1001 7
@


1.251
log
@fix the set +e cases, too
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.250 2013/01/01 20:45:03 tg Exp $");
d1339 5
a1343 2
	if ((lfp = getenv("SDMKSH_PATH")) == NULL)
		lfp = "/tmp/mksh-dbg.txt";
@


1.250
log
@fix running the ERR and EXIT traps in case of set -e and/or eval (includes Debian #696823)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.249 2012/12/17 23:18:07 tg Exp $");
a874 14
	/* ordering for EXIT vs ERR is a bit odd (this is what AT&T ksh does) */
	if (i == LEXIT || (Flag(FERREXIT) == 1 &&
	    (i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGEXIT], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGERR], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	}

d891 14
@


1.249
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d8 1
a8 1
 *		 2011, 2012
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.248 2012/12/07 23:46:36 tg Exp $");
d876 2
a877 2
	if (i == LEXIT || (Flag(FERREXIT) && (i == LERROR || i == LINTR) &&
	    sigtraps[ksh_SIGEXIT].trap)) {
d882 1
a882 1
	} else if (Flag(FERREXIT) && (i == LERROR || i == LINTR)) {
d888 17
@


1.248
log
@Correct mistake when doing hashtable lookup collision resolution… oops
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.247 2012/12/05 19:38:21 tg Exp $");
d487 1
a487 1
			warningf(true, "%s: %s", s->file, strerror(errno));
@


1.247
log
@fix libFirm/cparser -Wsign-compare
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.246 2012/11/30 20:19:13 tg Exp $");
d1657 1
a1657 1
				j = (perturb = tblp->ua.hval) & mask;
d1695 1
a1695 1
	j = (perturb = h) & mask;
@


1.246
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.245 2012/11/30 19:58:47 tg Exp $");
d257 1
a257 1
			change_flag(FSH, OF_FIRSTTIME, 1);
d332 1
a332 1
	change_flag(FEMACS, OF_SPECIAL, 1);
@


1.245
log
@… oh well, but MidnightBSD gcc picks on "" too, so just stick to NULL, it’s cheapest
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.241 2012/11/26 22:49:48 tg Exp $");
d463 1
a463 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
d852 1
a852 1
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_EXPERIMENTAL)
a1595 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a1604 1
#endif
@


1.245.2.1
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.245 2012/11/30 19:58:47 tg Exp $");
d257 1
a257 1
			change_flag(FSH, OF_FIRSTTIME, true);
d332 1
a332 1
	change_flag(FEMACS, OF_SPECIAL, true);
@


1.245.2.2
log
@Correct mistake when doing hashtable lookup collision resolution… oops
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.245.2.1 2012/12/05 19:58:30 tg Exp $");
d1659 1
a1659 1
				j = perturb = tblp->ua.hval;
d1697 1
a1697 1
	j = perturb = h;
@


1.245.2.3
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.245.2.2 2012/12/07 23:46:26 tg Exp $");
d876 2
a877 2
	if (i == LEXIT || (Flag(FERREXIT) == 1 &&
	    (i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
d882 1
a882 1
	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
a887 17

	/*
	 * This is a kludge. We need to restore everything that was
	 * changed in the new environment, see cid 1005090337C7A669439
	 * and 10050903386452ACBF1, but fail to even save things most of
	 * the time. funcs.c:c_eval() changes FERREXIT temporarily to 0,
	 * which needs to be restored thus (related to Debian #696823).
	 * We did not save the shell flags, so we use a special or'd
	 * value here... this is mostly to clean up behind *other*
	 * callers of unwind(LERROR) here; exec.c has the regular case.
	 */
	if (Flag(FERREXIT) & 0x80) {
		/* GNU bash does not run this trapsig */
		trapsig(ksh_SIGERR);
		Flag(FERREXIT) &= ~0x80;
	}

@


1.245.2.4
log
@fix the set +e cases, too
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.250 2013/01/01 20:45:03 tg Exp $");
d875 14
a904 14
	/* ordering for EXIT vs ERR is a bit odd (this is what AT&T ksh does) */
	if (i == LEXIT ||
	    ((i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGEXIT], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
		++trap_nested;
		runtrap(&sigtraps[ksh_SIGERR], trap_nested == 1);
		--trap_nested;
		i = LLEAVE;
	}

@


1.244
log
@The MidnightBSD/amd64 system compiler (Target: amd64-undermydesk-freebsd)
gcc version 4.2.1 20070719  [MidnightBSD] has stricter -Wformat checking
@
text
@d1138 1
a1138 1
	if (*fmt) {
@


1.243
log
@implement tty tracking and bump to R41 for feature completeness

• tty_fd is now never closed
• new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
• as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
• otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
• SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
• change the Uhr to match – it no longer calls stty(1) ☺
@
text
@d1138 1
a1138 1
	if (fmt) {
@


1.242
log
@use proper parenthesēs; int → bool; use same var (eno) for temp. errno
@
text
@d67 1
a67 1
	Ttypeset, "-i10", "SECONDS", "TMOUT", NULL,
d281 1
a281 3
#ifdef TIOCGWINSZ
	/* try to initialise tty size before importing environment */
	tty_init(false, false);
a282 2
	tty_close();
#endif
a366 2
	setint_n(global("COLUMNS"), 0, 10);
	setint_n(global("LINES"), 0, 10);
d515 1
a515 1
	/* Do this after j_init(), as tty_fd is not initialised until then */
d1053 10
a1062 2
 * Initialise tty_fd. Used for saving/reseting tty modes upon
 * foreground job completion and for setting up tty process group.
d1064 2
a1065 2
void
tty_init(bool init_ttystate, bool need_tty)
d1067 2
a1068 2
	bool do_close = true;
	int tfd;
d1070 3
a1072 3
	if (tty_fd >= 0) {
		close(tty_fd);
		tty_fd = -1;
a1073 1
	tty_devtty = true;
d1079 3
a1081 23
		tfd = 3;
		do_close = false;
	} else
#endif
	  if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
		tty_devtty = false;
#ifndef MKSH_DISABLE_TTY_WARNING
		if (need_tty)
			warningf(false, "%s: %s %s: %s",
			    "No controlling tty", "open", "/dev/tty",
			    strerror(errno));
#endif
	}
	if (tfd < 0) {
		do_close = false;
		if (isatty(0))
			tfd = 0;
		else if (isatty(2))
			tfd = 2;
		else {
#ifndef MKSH_DISABLE_TTY_WARNING
			if (need_tty)
				warningf(false, "can't find tty fd");
d1083 3
a1085 2
			return;
		}
d1087 1
a1087 15
	if ((tty_fd = fcntl(tfd, F_DUPFD, FDBASE)) < 0) {
		if (need_tty)
			warningf(false, "%s: %s %s: %s", "j_ttyinit",
			    "dup of tty fd", "failed", strerror(errno));
	} else if (fcntl(tty_fd, F_SETFD, FD_CLOEXEC) < 0) {
		if (need_tty)
			warningf(false, "%s: %s: %s", "j_ttyinit",
			    "can't set close-on-exec flag", strerror(errno));
		close(tty_fd);
		tty_fd = -1;
	} else if (init_ttystate)
		mksh_tcget(tty_fd, &tty_state);
	if (do_close)
		close(tfd);
}
a1088 3
void
tty_close(void)
{
d1090 3
a1092 2
		close(tty_fd);
		tty_fd = -1;
d1094 29
@


1.241
log
@use EPOCHREALTIME as variable, somewhat compatible with “zmodload zsh/datetime”, as ormaaj belatedly found out
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.240 2012/11/20 18:07:42 tg Exp $");
d1330 1
a1330 1
	if ((shl_dbg_fd = open(lfp, O_WRONLY | O_APPEND | O_CREAT, 0600)) == -1)
d1587 1
a1587 1
	while ((i = open(tp->tffn, O_CREAT | O_EXCL | O_RDWR, 0600)) == -1) {
@


1.240
log
@add MKSH_UNIXTIME
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.238 2012/11/12 18:28:39 tg Exp $");
d62 1
a62 1
    "${PS2=> } ${PS3=#? } ${PS4=+ } ${SECONDS=0} ${TMOUT=0} ${MKSH_UNIXTIME=}";
@


1.239
log
@introduce $BASHPID for ormaaj from #ksh
@
text
@d62 1
a62 1
    "${PS2=> } ${PS3=#? } ${PS4=+ } ${SECONDS=0} ${TMOUT=0}";
@


1.238
log
@save some space for error-less error messages
inspired by a bugfix for posh for something that was not a bug in here
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.237 2012/10/30 20:49:42 tg Exp $");
d386 2
@


1.237
log
@who would’ve thought proper ^C handling be so hard?
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.233 2012/10/22 20:19:14 tg Exp $");
d1141 1
a1141 1
	if (*fmt != 1) {
@


1.236
log
@int → bool
@
text
@d797 1
d799 1
d944 1
a944 2
	while (e->yyrecursive_statep)
		yyrecursive_pop();
@


1.235
log
@restore yyrecursive context in quitenv (LP#1069428)
@
text
@d620 1
a620 1
		include(MKSH_SYSTEM_PROFILE, 0, NULL, 1);
d623 1
a623 1
			    NULL, 1);
d626 1
a626 1
		include(MKSH_SUID_PROFILE, 0, NULL, 1);
d634 1
a634 1
			include(env_file, 0, NULL, 1);
d678 1
a678 1
include(const char *name, int argc, const char **argv, int intr_ok)
@


1.234
log
@when ^C’ing out of an interactive shell, also throw away the here documents (probably leaks, maybe not due to quitenv, but not much)
@
text
@d928 1
d942 2
@


1.233
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.231 2012/10/21 21:39:04 tg Exp $");
d798 1
@


1.232
log
@introduce MKSH_DISABLE_EXPERIMENTAL and wrap the new feature introduced
in cid 1005084678C510CF7E4 in it
@
text
@d1380 1
a1380 1
		shf_flush(&shf_iob[fd]);
d1594 12
@


1.231
log
@add some bounds, for a subsequent commit:
• all writers of exstat ensure the value is in [0; 0xFF]
• all readers of exstat AND it with 0xFF (not strictly needed thus)
• trap_exstat is “safe”, i.e. always either -1 or [0; 0xFF]
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.230 2012/10/21 21:26:40 tg Exp $");
d467 1
a467 1
#ifndef MKSH_SMALL
d853 1
a853 1
#ifndef MKSH_SMALL
@


1.230
log
@EXPERIMENTAL optimisation for “sh -c 'foo'” to equal “sh -c 'exit foo'” iff
several conditions are met as outlined below; for more background, refer to
http://www.FreeBSD.org/cgi/query-pr.cgi?pr=113860

We don’t yet optimise 「% sh -c '{ echo a; sleep 10;}&'; sleep 1; ps T」 so
the FreeBSD® sh approach cannot work for us, but scanning the “sh -c” argu‐
ment for disallowed characters and, if not, setting a flag that enables the
shell to exec the tree when parsed as TCOM *and not c_trap()* was possible.

Disallowed characters are currently C_QUOTE except space, that is:
Tab Newline " # $ & ' ( ) * ; < = > ? [ \ ] ` |

This should catch all cases of magic, variables, subshells, pipelines, etc.
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.229 2012/10/21 17:16:45 tg Exp $");
d714 1
a714 1
			if (intr_ok && (exstat - 128) != SIGTERM)
d858 1
a858 1
			exstat = execute(t, 0, NULL);
d868 1
a868 1
	return (exstat);
d964 1
a964 1
				int sig = exstat - 128;
d983 1
a983 1
		exit(exstat);
@


1.229
log
@add split-screen debugging; close-on-exec the logfile
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.228 2012/09/21 17:20:21 tg Exp $");
d467 10
d831 3
a833 1
		if (t != NULL && t->type == TEOF) {
d853 5
a857 1
		if (t && (!Flag(FNOEXEC) || (s->flags & SF_TTY)))
d860 1
a860 1
		if (t != NULL && t->type != TEOF && interactive && really_exit)
d863 1
@


1.228
log
@pure RCSID sync with OpenBSD, as we introduced SIGWINCH tracking earlier

XXX we could track whether tty_fd has already been successfully opened,
XXX the ttystate initialised, and then just never close it unless it is
XXX necessary, then we can keep COLUMNS/LINES accurate in scripts, even
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.227 2012/09/07 21:02:43 tg Exp $");
d1294 4
d1303 5
a1307 3
	if ((shl_dbg_fd = open("/tmp/mksh-dbg.txt",
	    O_WRONLY | O_APPEND | O_CREAT, 0600)) == -1)
		errorf("cannot open debug output file");
d1316 1
d1783 1
d1787 5
a1791 2
	shf_fprintf(shl_dbg, "[%d.%06d:%d] ", (int)tv.tv_sec, (int)tv.tv_usec,
	    (int)getpid());
@


1.227
log
@OpenBSD found out that "building argv for $* and $@@" manipulates l->argv
in place which affects ps(1) output on BSD; create a new array and copy
the original parts from argv[] there without touching argv passed to main
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2012/09/06 18:04:34 millert Exp $ */
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.226 2012/07/22 15:56:50 tg Exp $");
@


1.226
log
@note that some longjmp don’t handle 0 properly
cf. <500C1B2E.9030602@@zytor.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2011/09/07 11:33:25 otto Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.225 2012/07/01 15:38:06 tg Exp $");
d540 7
a546 1
		l->argv = &argv[argi - 1];
d548 2
@


1.225
log
@dissolve the hashtab nonsense, ¾ is good, and mirkev will also use that
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.224 2012/06/28 20:05:08 tg Exp $");
d847 1
@


1.224
log
@hackish work-around the lexer to make alias definitions in mksh -c
work (Closes: #517009) and mention in the manpage why they sometimes
do not work (doing so for COMSUBs is not worth the effort)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.223 2012/06/24 20:15:47 tg Exp $");
d241 2
a242 2
	    /* currently up to 50 builtins */
	    /* 80% of 64 = 2^6 */ 6, /* 66% of 128 = 2^7 */ 7);
d270 2
a271 2
	ktinit(APERM, &taliases, 0, 0);
	ktinit(APERM, &aliases, 0, 0);
d273 1
a273 1
	ktinit(APERM, &homedirs, 0, 0);
d1601 2
a1602 7
	    /* but otherwise, only 80% (MKSH_SMALL) or 66% (normal) */
#ifdef MKSH_SMALL
	    ((i * 4) / 5)
#else
	    ((i * 2) / 3)
#endif
	    ;
d1632 1
a1632 1
ktinit_real(Area *ap, struct table *tp, uint8_t initshift)
@


1.224.2.1
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.224 2012/06/28 20:05:08 tg Exp $");
d696 1
a696 1
			if (intr_ok && ((exstat & 0xFF) - 128) != SIGTERM)
d834 1
a834 1
			exstat = execute(t, 0, NULL) & 0xFF;
d843 1
a843 1
	return (exstat & 0xFF);
a849 16
	/*
	 * This is a kludge. We need to restore everything that was
	 * changed in the new environment, see cid 1005090337C7A669439
	 * and 10050903386452ACBF1, but fail to even save things most of
	 * the time. funcs.c:c_eval() changes FERREXIT temporarily to 0,
	 * which needs to be restored thus (related to Debian #696823).
	 * We did not save the shell flags, so we use a special or'd
	 * value here... this is mostly to clean up behind *other*
	 * callers of unwind(LERROR) here; exec.c has the regular case.
	 */
	if (Flag(FERREXIT) & 0x80) {
		/* GNU bash does not run this trapsig */
		trapsig(ksh_SIGERR);
		Flag(FERREXIT) &= ~0x80;
	}

d851 2
a852 2
	if (i == LEXIT ||
	    ((i == LERROR || i == LINTR) && sigtraps[ksh_SIGEXIT].trap)) {
d857 1
a857 1
	} else if (Flag(FERREXIT) == 1 && (i == LERROR || i == LINTR)) {
a862 1

d938 1
a938 1
				int sig = (exstat & 0xFF) - 128;
d957 1
a957 1
		exit(exstat & 0xFF);
@


1.223
log
@CID 703478: probably can’t happen, but…
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.222 2012/05/05 17:32:33 tg Exp $");
d464 1
a464 1
		s = pushs(SSTRING, ATEMP);
@


1.222
log
@move x_mkraw() to main.c from edit.c in order to be able to skip the latter
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.221 2012/05/04 22:34:51 tg Exp $");
d626 1
a626 1
	if (Flag(FTALKING))
@


1.221
log
@new MKSH_DISABLE_TTY_WARNING for ports that just can’t help it

TODO: add_cppflags this automatically in the TARGET_OS switch for some
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.219 2012/05/04 21:47:02 tg Exp $");
d1785 31
@


1.220
log
@last parts of Coherent patchkit: O_ACCMODE and termio
@
text
@d1051 1
d1056 1
d1065 1
d1068 1
@


1.219
log
@provide for Coherent not having gettimeofday(2), imake style (bad, but this is not for others to use without a second thought anyway)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.218 2012/05/04 21:15:33 tg Exp $");
d1079 1
a1079 1
		tcgetattr(tty_fd, &tty_state);
@


1.218
log
@more int→bool while trying to let ^D output CR+LF (which shan’t be, oh my…)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.217 2012/05/04 20:49:05 tg Exp $");
d138 1
a138 1
	gettimeofday(&bufptr->tv, NULL);
d1770 1
a1770 1
	gettimeofday(&tv, NULL);
@


1.217
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.216 2012/04/14 16:07:47 tg Exp $");
d742 1
a742 1
shell(Source * volatile s, volatile int toplevel)
d745 3
a747 3
	volatile int wastty = s->flags & SF_TTY;
	volatile int attempts = 13;
	volatile int interactive = Flag(FTALKING) && toplevel;
d754 1
a754 1
		really_exit = 0;
d819 1
a819 1
				really_exit = 1;
d837 1
a837 1
			really_exit = 0;
@


1.216
log
@rewrite maketemp() obsoleting tempnam(3) and mkstemp(3) external deps
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.215 2012/04/06 12:59:26 tg Exp $");
d330 1
d340 1
d522 1
d524 1
@


1.215
log
@drop the need for strcasestr: just uppercase a copy and compare with uppercased
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.214 2012/03/31 17:30:00 tg Exp $");
d1018 1
a1018 1
			unlink(tp->name);
d1502 3
a1505 3
	size_t len;
	int fd;
	char *pathname;
d1507 1
d1510 5
a1514 18
#if HAVE_MKSTEMP
	len = strlen(dir) + 6 + 10 + 1;
#else
	pathname = tempnam(dir, "mksh.");
	len = ((pathname == NULL) ? 0 : strlen(pathname)) + 1;
#endif
	/* reasonably sure that this will not overflow */
	tp = alloc(sizeof(struct temp) + len, ap);
	tp->name = (char *)&tp[1];
#if !HAVE_MKSTEMP
	if (pathname == NULL)
		tp->name[0] = '\0';
	else {
		memcpy(tp->name, pathname, len);
		free_ostempnam(pathname);
	}
#endif
	pathname = tp->name;
d1516 1
a1517 8
#if HAVE_MKSTEMP
	shf_snprintf(pathname, len, "%s%s", dir, "/mksh.XXXXXXXXXX");
	if ((fd = mkstemp(pathname)) >= 0)
#else
	if (tp->name[0] && (fd = open(tp->name, O_CREAT | O_RDWR, 0600)) >= 0)
#endif
		tp->shf = shf_fdopen(fd, SHF_WR, NULL);
	tp->pid = procpid;
d1519 38
@


1.214
log
@use _setjmp/_longjmp on NeXTstep: its Intel port always restores the signal mask on siglongjmp, which we never have
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.213 2012/03/31 17:08:52 tg Exp $");
d49 1
d164 23
a541 2
#define isuc(x)	(((x) != NULL) && \
	    (stristr((x), "UTF-8") || stristr((x), "utf8")))
a582 1
#undef isuc
@


1.213
log
@only pull entropy from glibc pointer guard if glibc is actually there
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.212 2012/03/27 22:36:52 tg Exp $");
d655 1
a655 2
	i = sigsetjmp(e->jbuf, 0);
	if (i) {
d730 26
a755 42
	i = sigsetjmp(e->jbuf, 0);
	if (i) {
		switch (i) {
		case LINTR:
			/* we get here if SIGINT not caught or ignored */
		case LERROR:
		case LSHELL:
			if (interactive) {
				if (i == LINTR)
					shellf("\n");
				/*
				 * Reset any eof that was read as part of a
				 * multiline command.
				 */
				if (Flag(FIGNOREEOF) && s->type == SEOF &&
				    wastty)
					s->type = SSTDIN;
				/*
				 * Used by exit command to get back to
				 * top level shell. Kind of strange since
				 * interactive is set if we are reading from
				 * a tty, but to have stopped jobs, one only
				 * needs FMONITOR set (not FTALKING/SF_TTY)...
				 */
				/* toss any input we have so far */
				s->start = s->str = null;
				break;
			}
			/* FALLTHROUGH */
		case LEXIT:
		case LLEAVE:
		case LRETURN:
			source = old_source;
			quitenv(NULL);
			/* keep on going */
			unwind(i);
			/* NOTREACHED */
		default:
			source = old_source;
			quitenv(NULL);
			internal_errorf("%s %d", "shell", i);
			/* NOTREACHED */
d757 14
d845 1
a845 1
			siglongjmp(e->jbuf, i);
@


1.212
log
@• implement fcntl(2)-based advisory locking as an alternative iff flock(2)
  is not found, from a suggestion by RT (LP: #912691)
• try harder (in a loop) to acquire a file lock if the locking mechanism
  documents EINTR is a possibility (fcntl always, flock on Linux not .Ox)
• use -std=c99 not -std=gnu99 if it must be at all
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.211 2012/03/25 14:28:14 tg Exp $");
d112 1
d114 1
d132 1
d135 1
@


1.211
log
@fix regression w.r.t. TTY and external programmes:
• release the TTY after the initial change_winsz()
• since we release it, we can skip initialising tty_state, too
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.210 2012/03/24 22:11:41 tg Exp $");
d1724 1
a1724 1
	(void)flock(shl_dbg_fd, LOCK_EX);
d1733 1
a1733 1
	(void)flock(shl_dbg_fd, LOCK_UN);
@


1.210
log
@lewellyn found QNX also doesn’t have a struct timezone ⇒ just DROP it!
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.209 2012/03/23 22:36:23 tg Exp $");
d255 1
a255 1
	tty_init(true, false);
d257 1
@


1.209
log
@meh, hit a regression again
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.208 2012/03/23 21:58:21 tg Exp $");
a113 4
#if !defined(_MINIX)
		/*XXX imake style */
		struct timezone tz;
#endif
d132 1
a132 4
	/* introduce variation */
#if !defined(_MINIX)
	gettimeofday(&bufptr->tv, &bufptr->tz);
#else
a133 1
#endif
@


1.208
log
@always keep x_cols and x_lins valid; check once at start including tty init
if we find any, but not later; do not check on every read

⇒ allows changing COLUMNS and LINES (independent of each other, or both)
  for script shells by passing them in an environment setting, even if
  we get a tty; interactive shells still check before each line is read…

reported by the PLD guys, thanks
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.207 2012/03/23 19:38:12 tg Exp $");
d263 1
a263 1
	tty_init(false, false);
@


1.207
log
@efficient debug-to-file output (/tmp racy, but hey)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.205 2012/03/03 21:30:56 tg Exp $");
d261 6
@


1.206
log
@another int → bool
@
text
@d1245 7
a1251 1
struct shf shf_iob[3];
a1258 1
	/* force buffer allocation */
d1260 15
d1717 20
@


1.205
log
@RCSID sync from oksh; reduce hash table #elements if !MKSH_SMALL to speed up
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.204 2012/03/03 21:13:50 tg Exp $");
d99 1
a99 1
static int initio_done;
d1255 1
a1255 1
	initio_done = 1;
@


1.204
log
@no "struct timezone" on Minix3, despite its manpage
@
text
@d4 1
a4 1
/*	$OpenBSD: table.c,v 1.14 2012/02/02 08:42:46 otto Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.203 2012/02/11 22:45:04 tg Exp $");
d221 2
a222 2
	    /* currently 50 builtins -> 80% of 64 (2^6) */
	    6);
d250 2
a251 2
	ktinit(APERM, &taliases, 0);
	ktinit(APERM, &aliases, 0);
d253 1
a253 1
	ktinit(APERM, &homedirs, 0);
d1531 9
a1539 2
	/* table can get 80% full except when reaching its limit */
	tp->nfree = (tp->tshift == 30) ? 0x3FFF0000UL : ((i * 4) / 5);
d1569 1
a1569 1
ktinit(Area *ap, struct table *tp, uint8_t initshift)
@


1.203
log
@RCSID sync with OpenBSD 5.1 ksh (we did the same checks ages ago)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.202 2012/01/29 01:41:14 tg Exp $");
d114 2
d117 1
d137 1
d139 3
@


1.202
log
@reduce stack usage a bit (several candidates for more, including $CC itself…)
@
text
@d4 1
a4 1
/*	$OpenBSD: table.c,v 1.13 2009/01/17 22:06:44 millert Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.201 2011/11/08 22:07:14 tg Exp $");
@


1.201
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d7 2
a8 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.200 2011/10/07 19:51:28 tg Exp $");
d49 1
d160 2
a161 2
int
main(int argc, const char *argv[])
d599 13
a611 2
	if (Flag(FAS_BUILTIN))
		return (shcomexec(l->argv));
d613 9
a621 4
	/* doesn't return */
	shell(s, true);
	/* NOTREACHED */
	return (0);
@


1.200
log
@remaining sync with oksh (pointless rcsid, no code diff)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.199 2011/09/07 15:24:17 tg Exp $");
d333 3
a335 3
	setint_n(global("COLUMNS"), 0);
	setint_n(global("LINES"), 0);
	setint_n(global("OPTIND"), 1);
d348 1
a348 1
	setint_n((vp = global("PGRP")), (mksh_uari_t)kshpgrp);
d350 1
a350 1
	setint_n((vp = global("PPID")), (mksh_uari_t)kshppid);
d352 1
a352 1
	setint_n((vp = global("USER_ID")), (mksh_uari_t)ksheuid);
d354 1
a354 1
	setint_n((vp = global("KSHUID")), (mksh_uari_t)kshuid);
d356 1
a356 1
	setint_n((vp = global("KSHEGID")), (mksh_uari_t)kshegid);
d358 1
a358 1
	setint_n((vp = global("KSHGID")), (mksh_uari_t)kshgid);
d360 1
a360 1
	setint_n((vp = global("RANDOM")), rndsetup());
d362 1
a362 1
	setint_n((vp_pipest = global("PIPESTATUS")), 0);
@


1.199
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2010/05/19 17:36:08 jasper Exp $	*/
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.198 2011/08/27 18:06:48 tg Exp $");
@


1.198
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.197 2011/08/27 17:30:06 tg Exp $");
d62 4
a65 4
	T_typeset, "-r", initvsn, NULL,
	T_typeset, "-x", "HOME", "PATH", "RANDOM", "SHELL", NULL,
	T_typeset, "-i10", "SECONDS", "TMOUT", NULL,
	T_alias,
d67 1
a67 1
	T_local_typeset,
d82 1
a82 1
	T_r_fc_e_,
d87 1
a87 1
	T_alias, "-tU",
d94 1
a94 1
	T_typeset, "-r", "PATH", "ENV", "SHELL", NULL
d108 1
a108 1
		ALLOC_ITEM __alloc_i;
d802 1
a802 1
	    sigtraps[SIGEXIT_].trap)) {
d804 1
a804 1
		runtrap(&sigtraps[SIGEXIT_], trap_nested == 1);
d809 1
a809 1
		runtrap(&sigtraps[SIGERR_], trap_nested == 1);
@


1.197
log
@jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.196 2011/07/16 17:08:19 tg Exp $");
d380 38
d602 1
d1437 1
a1437 1
	int len;
d1499 1
a1499 1
	osize = 1 << (tp->tshift++);
d1553 1
a1553 1
	mask = (1 << (tp->tshift)) - 1;
d1609 1
a1609 1
	ts->left = 1 << (tp->tshift);
d1643 1
a1643 1
	i = 1 << (tp->tshift);
@


1.196
log
@‣ merge from mksh R40-stable
move /etc/{,suid_}profile to /system/etc/ for Android (but do not make
the location of /etc configurable); rewrite manpage section about
/etc/{,suid_}profile, .profile, .mkshrc
@
text
@d26 1
a26 1
#define	EXTERN
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195 2011/07/06 22:21:57 tg Exp $");
@


1.195
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.194 2011/07/02 17:57:39 tg Exp $");
d527 1
a527 1
		include(KSH_SYSTEM_PROFILE, 0, NULL, 1);
d533 1
a533 1
		include("/etc/suid_profile", 0, NULL, 1);
@


1.195.2.1
log
@time to open the mksh R40-stable branch:
• bring back deprecated {build options,set ±o arc4random,OAAT1 internal hash}
• change version number in TFM
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195 2011/07/06 22:21:57 tg Exp $");
d134 1
a134 1
	oaat1_init_impl(h);
d136 1
a136 1
	oaat1_addmem_impl(h, &rndsetupstate, sizeof(rndsetupstate));
d138 2
a139 2
	oaat1_addmem_impl(h, bufptr, sizeof(*bufptr));
	oaat1_fini_impl(h);
@


1.195.2.2
log
@• move /etc/{,suid_}profile to /system/etc/ for Android (but do not make
  the location of /etc configurable)
• rewrite manpage section about /etc/{,suid_}profile, .profile, .mkshrc
• drop heredoc-weird-3 while here, it’s not deterministic by design(?)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195.2.1 2011/07/07 21:42:13 tg Exp $");
d527 1
a527 1
		include(MKSH_SYSTEM_PROFILE, 0, NULL, 1);
d533 1
a533 1
		include(MKSH_SUID_PROFILE, 0, NULL, 1);
@


1.195.2.3
log
@MFC from HEAD and adjust version

Build.sh:
- better handling of eval and CPPFLAGS in build system
- partial OPENSTEP support
- fix typo

check.t:
- mark utf8opt-2a as need-pass: no (1.481)

dot.mkshrc:
- do not close stderr (1.65)
- use only printable characters (1.65)

edit.c:
- upper bound Emacs mode command repeat by input line length

funcs.c, sh.h:
- optimise an if away, and possibly even the function bodies…

misc.c:
- jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr

mksh.1, sh.h. var.c:
- fix spelling

mksh.1:
- document "export -"

sh.h:
- undef optarg, optind in case the OE predefines them (1.493)

shf.c:
- handle %zu (size_t), %zd (ssize_t), etc. (1.43)

syn.c:
- avoid (not-)function-local externs (1.68)

multiple:
- do not use macros or identifiers ending with an underscore
- more {,s}size_t, type, lint, other cleanups (edit.c 1.220; eval.c 1.107;
  exec.c 1.95; expr.c 1.48; funcs.c 1.196; histrap.c 1.110; jobs.c 1.81;
  lalloc.c 1.18; lex.c 1.155; main.c 1.198; misc.c 1.171; sh.h 1.493;
  shf.c 1.43; tree.c 1.50; var.c 1.131)
- wrap access(2) (edit.c 1.221; exec.c 1.96; expr.c 1.49; funcs.c 1.197;
  histrap.c 1.111; sh.h 1.494)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2011/09/07 11:33:25 otto Exp $	*/
d26 1
a26 1
#define EXTERN
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195.2.2 2011/07/16 16:04:11 tg Exp $");
d62 4
a65 4
	Ttypeset, "-r", initvsn, NULL,
	Ttypeset, "-x", "HOME", "PATH", "RANDOM", "SHELL", NULL,
	Ttypeset, "-i10", "SECONDS", "TMOUT", NULL,
	Talias,
d67 1
a67 1
	Tlocal_typeset,
d82 1
a82 1
	Tr_fc_e_dash,
d87 1
a87 1
	Talias, "-tU",
d94 1
a94 1
	Ttypeset, "-r", "PATH", "ENV", "SHELL", NULL
d108 1
a108 1
		ALLOC_ITEM alloc_INT;
a379 38
#ifdef DEBUG
	/* test wraparound of arithmetic types */
	{
		volatile long xl;
		volatile unsigned long xul;
		volatile int xi;
		volatile unsigned int xui;
		volatile mksh_ari_t xa;
		volatile mksh_uari_t xua, xua2;
		volatile uint8_t xc;

		xa = 2147483647;
		xua = 2147483647;
		++xa;
		++xua;
		xua2 = xa;
		xl = xa;
		xul = xua;
		xa = 0;
		xua = 0;
		--xa;
		--xua;
		xi = xa;
		xui = xua;
		xa = -1;
		xua = xa;
		++xa;
		++xua;
		xc = 0;
		--xc;
		if ((xua2 != 2147483648UL) ||
		    (xl != -2147483648L) || (xul != 2147483648UL) ||
		    (xi != -1) || (xui != 4294967295U) ||
		    (xa != 0) || (xua != 0) || (xc != 255))
			errorf("integer wraparound test failed");
	}
#endif

a563 1
	/* NOTREACHED */
d763 1
a763 1
	    sigtraps[ksh_SIGEXIT].trap)) {
d765 1
a765 1
		runtrap(&sigtraps[ksh_SIGEXIT], trap_nested == 1);
d770 1
a770 1
		runtrap(&sigtraps[ksh_SIGERR], trap_nested == 1);
d1398 1
a1398 1
	size_t len;
d1460 1
a1460 1
	osize = (size_t)1 << (tp->tshift++);
d1514 1
a1514 1
	mask = ((size_t)1 << (tp->tshift)) - 1;
d1570 1
a1570 1
	ts->left = (size_t)1 << (tp->tshift);
d1604 1
a1604 1
	i = (size_t)1 << (tp->tshift);
@


1.195.2.4
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195.2.3 2011/10/25 22:50:33 tg Exp $");
d333 3
a335 3
	setint_n(global("COLUMNS"), 0, 10);
	setint_n(global("LINES"), 0, 10);
	setint_n(global("OPTIND"), 1, 10);
d348 1
a348 1
	setint_n((vp = global("PGRP")), (mksh_uari_t)kshpgrp, 10);
d350 1
a350 1
	setint_n((vp = global("PPID")), (mksh_uari_t)kshppid, 10);
d352 1
a352 1
	setint_n((vp = global("USER_ID")), (mksh_uari_t)ksheuid, 10);
d354 1
a354 1
	setint_n((vp = global("KSHUID")), (mksh_uari_t)kshuid, 10);
d356 1
a356 1
	setint_n((vp = global("KSHEGID")), (mksh_uari_t)kshegid, 10);
d358 1
a358 1
	setint_n((vp = global("KSHGID")), (mksh_uari_t)kshgid, 10);
d360 1
a360 1
	setint_n((vp = global("RANDOM")), rndsetup(), 10);
d362 1
a362 1
	setint_n((vp_pipest = global("PIPESTATUS")), 0, 10);
@


1.195.2.5
log
@MFC the Build.sh bugfix and the SkyOS and Minix stuff
@
text
@d4 1
a4 1
/*	$OpenBSD: table.c,v 1.15 2012/02/19 07:52:30 otto Exp $	*/
d7 1
a7 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195.2.4 2011/11/08 22:07:21 tg Exp $");
a111 2
#if !defined(_MINIX)
		/*XXX imake style */
a112 1
#endif
a131 1
#if !defined(_MINIX)
a132 3
#else
	gettimeofday(&bufptr->tv, NULL);
#endif
@


1.195.2.6
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.209 2012/03/23 22:36:23 tg Exp $");
d98 1
a98 1
static bool initio_done;
a259 6
#ifdef TIOCGWINSZ
	/* try to initialise tty size before importing environment */
	tty_init(true, false);
	change_winsz();
#endif

d1228 1
a1228 7
#ifdef DF
int shl_dbg_fd;
#define NSHF_IOB 4
#else
#define NSHF_IOB 3
#endif
struct shf shf_iob[NSHF_IOB];
d1236 1
d1238 1
a1238 16
#ifdef DF
	if ((shl_dbg_fd = open("/tmp/mksh-dbg.txt",
	    O_WRONLY | O_APPEND | O_CREAT, 0600)) == -1)
		errorf("cannot open debug output file");
	if (shl_dbg_fd < FDBASE) {
		int nfd;

		nfd = fcntl(shl_dbg_fd, F_DUPFD, FDBASE);
		close(shl_dbg_fd);
		if ((shl_dbg_fd = nfd) == -1)
			errorf("cannot dup debug output file");
	}
	shf_fdopen(shl_dbg_fd, SHF_WR, shl_dbg);
	DF("=== open ===");
#endif
	initio_done = true;
a1672 20

#ifdef DF
void
DF(const char *fmt, ...)
{
	va_list args;
	struct timeval tv;

	(void)flock(shl_dbg_fd, LOCK_EX);
	gettimeofday(&tv, NULL);
	shf_fprintf(shl_dbg, "[%d.%06d:%d] ", (int)tv.tv_sec, (int)tv.tv_usec,
	    (int)getpid());
	va_start(args, fmt);
	shf_vfprintf(shl_dbg, fmt, args);
	va_end(args);
	shf_putc('\n', shl_dbg);
	shf_flush(shl_dbg);
	(void)flock(shl_dbg_fd, LOCK_UN);
}
#endif
@


1.195.2.7
log
@lewellyn found QNX also doesn’t have a struct timezone ⇒ just DROP it!
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.195.2.6 2012/03/24 21:22:37 tg Exp $");
d113 4
d135 4
a138 1
	/* introduce variation (and yes, second arg MBZ for portability) */
d140 1
@


1.195.2.8
log
@MFC fixes from HEAD
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.215 2012/04/06 12:59:26 tg Exp $");
a48 1
static uint8_t isuc(const char *);
a110 1
#if defined(__GLIBC__) && (__GLIBC__ >= 2)
a111 1
#endif
a128 1
#if defined(__GLIBC__) && (__GLIBC__ >= 2)
a130 1
#endif
a157 23
static uint8_t
isuc(const char *cx) {
	char *cp, *x;
	uint8_t rv = 0;

	if (!cx || !*cx)
		return (0);

	/* uppercase a string duplicate */
	strdupx(x, cx, ATEMP);
	cp = x;
	while ((*cp = ksh_toupper(*cp)))
		++cp;

	/* check for UTF-8 */
	if (strstr(x, "UTF-8") || strstr(x, "UTF8"))
		rv = 1;

	/* free copy and out */
	afree(x, ATEMP);
	return (rv);
}

d254 1
a254 1
	tty_init(false, false);
a255 1
	tty_close();
d512 2
d555 1
d633 2
a634 1
	if ((i = kshsetjmp(e->jbuf))) {
d709 42
a750 26
	switch ((i = kshsetjmp(e->jbuf))) {
	case 0:
		break;
	case LINTR:
		/* we get here if SIGINT not caught or ignored */
	case LERROR:
	case LSHELL:
		if (interactive) {
			if (i == LINTR)
				shellf("\n");
			/*
			 * Reset any eof that was read as part of a
			 * multiline command.
			 */
			if (Flag(FIGNOREEOF) && s->type == SEOF && wastty)
				s->type = SSTDIN;
			/*
			 * Used by exit command to get back to
			 * top level shell. Kind of strange since
			 * interactive is set if we are reading from
			 * a tty, but to have stopped jobs, one only
			 * needs FMONITOR set (not FTALKING/SF_TTY)...
			 */
			/* toss any input we have so far */
			s->start = s->str = null;
			break;
a751 14
		/* FALLTHROUGH */
	case LEXIT:
	case LLEAVE:
	case LRETURN:
		source = old_source;
		quitenv(NULL);
		/* keep on going */
		unwind(i);
		/* NOTREACHED */
	default:
		source = old_source;
		quitenv(NULL);
		internal_errorf("%s %d", "shell", i);
		/* NOTREACHED */
d826 1
a826 1
			kshlongjmp(e->jbuf, i);
d1699 1
a1699 1
	mksh_lockfd(shl_dbg_fd);
d1708 1
a1708 1
	mksh_unlkfd(shl_dbg_fd);
@


1.194
log
@address "env RANDOM=1=2=3 mksh" DoS by integrifying more
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.193 2011/06/05 19:58:18 tg Exp $");
d134 1
a134 1
	oaat1_init_impl(h);
d136 1
a136 1
	oaat1_addmem_impl(h, &rndsetupstate, sizeof(rndsetupstate));
d138 2
a139 2
	oaat1_addmem_impl(h, bufptr, sizeof(*bufptr));
	oaat1_fini_impl(h);
@


1.193
log
@• rework hash table interna to avoid gcc-4.1 on Debian etch bug
• also improve behaviour with _a lot_ (>2²⁸) entries
• while here, improve comments and whitespace
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.192 2011/06/04 16:42:30 tg Exp $");
d64 1
a64 3
	T_typeset, "-i10", "COLUMNS", "KSHEGID", "KSHGID", "KSHUID", "LINES",
	    "OPTIND", "PGRP", "PPID", "RANDOM", "SECONDS", "TMOUT", "USER_ID",
	    NULL,
d93 4
d333 3
a335 3
	setint(global("COLUMNS"), 0);
	setint(global("LINES"), 0);
	setint(global("OPTIND"), 1);
d348 1
a348 1
	setint((vp = global("PGRP")), (mksh_uari_t)kshpgrp);
d350 1
a350 1
	setint((vp = global("PPID")), (mksh_uari_t)kshppid);
d352 1
a352 1
	setint((vp = global("USER_ID")), (mksh_uari_t)ksheuid);
d354 1
a354 1
	setint((vp = global("KSHUID")), (mksh_uari_t)kshuid);
d356 1
a356 1
	setint((vp = global("KSHEGID")), (mksh_uari_t)kshegid);
d358 1
a358 1
	setint((vp = global("KSHGID")), (mksh_uari_t)kshgid);
d360 1
a360 1
	setint((vp = global("RANDOM")), rndsetup());
d362 1
a362 1
	setint((vp_pipest = global("PIPESTATUS")), 0);
a544 5
		static const char *restr_com[] = {
			T_typeset, "-r", "PATH",
			"ENV", "SHELL",
			NULL
		};
@


1.192
log
@fix segfault due to limit of hashtable entries (global variables) discovered by Jb_boin: unlimit to 2^30 minus epsilon
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.191 2011/05/29 16:31:42 tg Exp $");
d209 3
a211 2
	ktinit(&builtins, APERM,
	    /* must be 80% of 2^n (currently 44 builtins) */ 64);
d239 2
a240 2
	ktinit(&taliases, APERM, 0);
	ktinit(&aliases, APERM, 0);
d242 1
a242 1
	ktinit(&homedirs, APERM, 0);
d1446 1
a1446 1
#define	INIT_TBLS	8	/* initial table size (power of 2) */
d1449 1
a1449 1
static void texpand(struct table *, size_t);
a1450 2
static struct tbl *ktscan(struct table *, const char *, uint32_t,
    struct tbl ***);
d1453 1
a1453 1
texpand(struct table *tp, size_t nsize)
d1455 1
a1455 1
	size_t i, j, osize = tp->size, perturb;
d1459 1
a1459 3
	i = 1;
	i <<= 30;
	if (nsize > i)
d1462 10
a1471 10
	ntblp = alloc2(nsize, sizeof(struct tbl *), tp->areap);
	memset(ntblp, 0, nsize * sizeof(struct tbl *));
	tp->size = nsize;
	if (nsize == i) {
		/* cannot be grown any more, use a fixed value */
		tp->nfree = i - 65536;
	} else /* (nsize < 2^30) */ {
		/* table can get 80% full */
		tp->nfree = (nsize * 4) / 5;
	}
d1476 1
a1476 2
	/* from here on nsize := mask */
	nsize--;
d1481 1
a1481 1
				j = (perturb = tblp->ua.hval) & nsize;
d1487 1
a1487 1
				pp = &ntblp[j & nsize];
d1501 1
a1501 1
ktinit(struct table *tp, Area *ap, size_t tsize)
d1505 3
a1507 3
	tp->size = tp->nfree = 0;
	if (tsize)
		texpand(tp, tsize);
d1511 1
a1511 1
static struct tbl *
d1517 1
a1517 1
	mask = tp->size - 1;
a1534 7
/* table, name (key) to search for, hash(n) */
struct tbl *
ktsearch(struct table *tp, const char *n, uint32_t h)
{
	return (tp->size ? ktscan(tp, n, h, NULL) : NULL);
}

a1541 2
	if (tp->size == 0)
		texpand(tp, INIT_TBLS);
d1548 1
a1548 1
		texpand(tp, 2 * tp->size);
d1573 1
a1573 1
	ts->left = tp->size;
d1603 6
a1608 2
	/* tp->size + 1 will not overflow */
	p = alloc2(tp->size + 1, sizeof(struct tbl *), ATEMP);
a1610 1
	i = (size_t)tp->size;
d1615 1
a1615 1
	qsort(p, (i = dp - p), sizeof(void *), tnamecmp);
@


1.191
log
@• AIX: display OS version better (tested on 5.3 by cnuke@@)
• IBM XL C: display version better (tested on V7.0 by cnuke@@)
• do not 'IFS=: read nr name', Cygwin 1.7 dash fails it
• disable cd-pe, glob-range-3 on Cygwin (the former cannot
  succeed because the mv fails, the latter fails from 1.7 on)
• mark heredoc-tmpfile-8 as need-pass: no
• apply __attribute__ only to a function prototype, not to
  the body (even if static), since xlC fails that
• bump version to R40 (beta)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.190 2011/04/17 12:24:43 tg Exp $");
d1460 5
d1466 1
a1466 2
	for (i = 0; i < nsize; i++)
		ntblp[i] = NULL;
d1468 7
a1474 2
	/* table can get 80% full */
	tp->nfree = (nsize * 4) / 5;
d1559 1
a1559 1
	if (tp->nfree <= 0) {
@


1.190
log
@always catch SIGALRM even in non-interactive shells to make sleep work
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.189 2011/04/09 21:01:02 tg Exp $");
d1013 4
a1016 1
static void MKSH_A_FORMAT(__printf__, 2, 0)
@


1.189
log
@avoid namespace conflicts with __attribute__(…)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.188 2011/04/02 13:55:35 tg Exp $");
d553 1
a553 1
	if (Flag(FTALKING)) {
d555 1
a555 2
		alarm_init();
	} else
d559 2
@


1.188
log
@shut up valgrind, thanks wbx@@ for prodding
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.187 2011/03/27 18:50:05 tg Exp $");
d1012 1
a1012 1
static void MKSH_A_FORMAT(printf, 2, 0)
@


1.187
log
@• Implement http://austingroupbugs.net/view.php?id=367 and align things
  a bit more with POSIX and the other shells

I considered http://austingroupbugs.net/view.php?id=253 but the use
of bi_errorf() is interesting, especially as it’s often enough a
noreturn function, and funnily enough, 'cd -P /foo' returns 0 while
'chdir -P /foo' fails (so idk where to put -e)…
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.186 2011/03/26 19:43:47 tg Exp $");
d115 4
@


1.186
log
@simplify code to use existing $PWD
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.184 2011/03/16 20:56:33 tg Exp $");
d1002 40
d1047 2
d1052 3
a1054 9
	exstat = 1;
	if (*fmt != 1) {
		error_prefix(true);
		va_start(va, fmt);
		shf_vfprintf(shl_out, fmt, va);
		va_end(va);
		shf_putchar('\n', shl_out);
	}
	shf_flush(shl_out);
a1063 1
	error_prefix(fileline);
d1065 2
a1066 1
	shf_vfprintf(shl_out, fmt, va);
a1067 2
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
d1083 6
a1088 11
	if (*fmt != 1) {
		error_prefix(true);
		/* not set when main() calls parse_args() */
		if (builtin_argv0 && builtin_argv0 != kshname)
			shf_fprintf(shl_out, "%s: ", builtin_argv0);
		va_start(va, fmt);
		shf_vfprintf(shl_out, fmt, va);
		va_end(va);
		shf_putchar('\n', shl_out);
	}
	shf_flush(shl_out);
a1101 9
internal_verrorf(const char *fmt, va_list ap)
{
	shf_fprintf(shl_out, "internal error: ");
	shf_vfprintf(shl_out, fmt, ap);
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
}

void
d1107 1
a1107 1
	internal_verrorf(fmt, va);
d1118 1
a1118 1
	internal_verrorf(fmt, va);
@


1.185
log
@use existing code
@
text
@d159 1
a164 1
	char *cp;
d309 11
a319 20
	{
		struct tbl *pwd_v = global("PWD");
		char *pwd = str_val(pwd_v);
		char *pwdx = pwd;

		/* Try to use existing $PWD if it is valid */
		if (pwd[0] != '/' ||
		    !test_eval(NULL, TO_FILEQ, pwd, ".", true))
			pwdx = NULL;
		set_current_wd(pwdx);
		if (current_wd[0])
			simplify_path(current_wd);
		/*
		 * Only set pwd if we know where we are or if it had a
		 * bogus value
		 */
		if (current_wd[0] || pwd != null)
			/* setstr can't fail here */
			setstr(pwd_v, current_wd, KSH_RETURN_ERROR);
	}
@


1.184
log
@actually, we need the android lsmod to be a builtin not an alias…
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.181 2011/03/13 16:03:52 tg Exp $");
a309 1
		struct stat s_pwd, s_dot;
d316 1
a316 3
		    stat(pwd, &s_pwd) < 0 || stat(".", &s_dot) < 0 ||
		    s_pwd.st_dev != s_dot.st_dev ||
		    s_pwd.st_ino != s_dot.st_ino)
@


1.183
log
@oops
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.182 2011/03/16 20:26:35 tg Exp $");
d73 1
a73 4
#if defined(ANDROID)
	/* evil hack */
	"lsmod=cat /proc/modules",
#elif !defined(MKSH_UNEMPLOYED)
@


1.182
log
@• introduce a virtual TARGET_OS=Android that just sets a check category
  and switches to the TARGET_OS=Linux
• introduce android as regression test suite category
• add an android specific standard alias
• clean up redundant ‘-o sh’ arg in a few checks
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.181 2011/03/13 16:03:52 tg Exp $");
d75 1
a75 1
	"lsmod='cat /proc/modules'",
@


1.181
log
@• speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
• parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.180 2011/03/13 01:20:21 tg Exp $");
d73 4
a76 1
#if !defined(ANDROID) && !defined(MKSH_UNEMPLOYED)
@


1.180
log
@lint is your friend
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.179 2011/03/05 21:43:17 tg Exp $");
d666 1
a669 3
	/* enable UTF-8 BOM check */
	s->flags |= SF_FIRST;

d731 2
a732 1
		t = compile(s);
@


1.179
log
@introduce macros for malloc, realloc, free to hide them from mksh

no code may henceforth use memory (de-)allocation functions directly
use these macros, porters can change them for abstraction
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.178 2011/02/27 19:29:31 tg Exp $");
d719 1
a719 1
	while (1) {
d784 1
a784 1
	while (1) {
@


1.178
log
@fix UWIN: don’t close fd #3 (also, int→bool)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.177 2011/02/18 22:26:10 tg Exp $");
d1405 1
a1405 1
		free(pathname);
@


1.177
log
@• add -u option (POSIX: unbuffered ⇒ nop) to the built-in cat
• PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
• add regression tests, documentation, etc.
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.176 2011/02/11 01:18:18 tg Exp $");
d960 1
a960 1
	tty_devtty = 1;
d963 3
a965 2
	/* XXX imake style */
	if (isatty(3))
d967 2
a968 1
	else
d970 2
a971 2
	if ((tfd = open("/dev/tty", O_RDWR, 0)) < 0) {
		tty_devtty = 0;
@


1.176
log
@• more comment and int→bool cleanup, add and improve some comments
• in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesn’t suffice
• add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
• for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
• when called as builtin, echo behaves POSIXish
• add domainname as alias for true on MirBSD only, to be able to link it
• sync mksh Makefiles with Build.sh output
• adjust manpage wrt release plans
• link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
• drop linked utilities and, except for echo and kill, their manpages
• adjust instbin and link a few more there as well
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.175 2011/01/21 21:07:11 tg Exp $");
d367 1
@


1.175
log
@drop suspend alias in Android too
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.174 2011/01/21 21:04:44 tg Exp $");
d70 2
a71 1
	"hash=alias -t",	/* not "alias -t --": hash -r needs to work */
d115 12
a126 6
	bufptr = (void *)(cp - ALLOC_SIZE);	/* undo what alloc() did */
	bufptr->dataptr = &rndsetupstate;	/* PIE or something */
	bufptr->stkptr = &bufptr;		/* ASLR in Win/Lin */
	bufptr->mallocptr = bufptr;		/* randomised malloc in BSD */
	sigsetjmp(bufptr->jbuf, 1);		/* glibc pointer guard */
	gettimeofday(&bufptr->tv, &bufptr->tz);	/* introduce variation */
d148 4
d156 1
a156 1
	Source *s;
d159 1
a159 1
	const char **wp;
a171 4
		static const char *empty_argv[] = {
			"mksh", NULL
		};

d175 1
a175 1
	kshname = *argv;
d177 2
a178 1
	ainit(&aperm);		/* initialise permanent Area */
d189 35
a223 3
	argi = parse_args(argv, OF_FIRSTTIME, NULL);
	if (argi < 0)
		return (1);
a242 6
	/* define built-in commands */
	ktinit(&builtins, APERM,
	    /* must be 80% of 2^n (currently 44 builtins) */ 64);
	for (i = 0; mkshbuiltins[i].name != NULL; i++)
		builtin(mkshbuiltins[i].name, mkshbuiltins[i].func);

a296 16
#ifdef MKSH_BINSHREDUCED
	/* set FSH if we're called as -sh or /bin/sh or so */
	{
		const char *cc;

		cc = kshname;
		i = 0; argi = 0;
		while (cc[i] != '\0')
			/* the following line matches '-' and '/' ;-) */
			if ((cc[i++] | 2) == '/')
				argi = i;
		if (((cc[argi] | 0x20) == 's') && ((cc[argi + 1] | 0x20) == 'h'))
			change_flag(FSH, OF_FIRSTTIME, 1);
	}
#endif

d302 2
a303 1
	typeset(initifs, 0, 0, 0, 0);	/* for security */
d378 5
a382 3
	argi = parse_args(argv, OF_CMDLINE, NULL);
	if (argi < 0)
		return (1);
d388 4
a391 1
	if (Flag(FCOMMAND)) {
a436 2
	/* set: 0/1; unset: 2->0 */
	UTFMODE = utf_flag & 1;
d441 2
a442 21
#define isuc(x)	(((x) != NULL) && \
		    (stristr((x), "UTF-8") || stristr((x), "utf8")))
		/* Check if we're in a UTF-8 locale */
			const char *ccp;

#if HAVE_SETLOCALE_CTYPE
			ccp = setlocale(LC_CTYPE, "");
#if HAVE_LANGINFO_CODESET
			if (!isuc(ccp))
				ccp = nl_langinfo(CODESET);
#endif
#else
			/* these were imported from environ earlier */
			ccp = str_val(global("LC_ALL"));
			if (ccp == null)
				ccp = str_val(global("LC_CTYPE"));
			if (ccp == null)
				ccp = str_val(global("LANG"));
#endif
			UTFMODE = isuc(ccp);
#undef isuc
d444 1
a444 1
			UTFMODE = 1;
d446 2
a447 1
			UTFMODE = 0;
d460 56
a515 4
	l->argv = &argv[argi - 1];
	l->argc = argc - argi;
	l->argv[0] = kshname;
	getopts_reset(1);
d564 5
a568 1
		Flag(FTRACKALL) = 1;	/* set after ENV */
d606 2
a607 1
			return (exstat & 0xff); /* see below */
d639 2
a640 1
	return (i & 0xff);	/* & 0xff to ensure value not -1 */
d668 2
a669 1
	s->flags |= SF_FIRST;	/* enable UTF-8 BOM check */
d677 2
a678 1
		case LINTR: /* we get here if SIGINT not caught or ignored */
d708 2
a709 1
			unwind(i);	/* keep on going */
d813 2
a814 1
	ep = (void *)(cp - ALLOC_SIZE);	/* undo what alloc() did */
d841 2
a842 1
		if (ep->savefd[2])	/* Clear any write errors */
d850 2
a851 1
		if (ep->type == E_NONE) {	/* Main shell exiting? */
d1017 3
a1019 1
	shl_stdout_ok = false;	/* debugging: note that stdout not valid */
d1055 3
a1057 1
	shl_stdout_ok = false;	/* debugging: note that stdout not valid */
d1062 1
a1062 1
		if (builtin_argv0)
d1133 2
a1134 1
	if (!initio_done) /* shl_out may not be set up yet... */
d1170 2
a1171 1
	shf_fdopen(1, SHF_WR, shl_stdout);	/* force buffer allocation */
d1173 2
a1174 1
	shf_fdopen(2, SHF_WR, shl_spare);	/* force buffer allocation */
d1188 1
a1188 1
	/* XXX imake style */
d1197 2
a1198 2
 * move fd from user space (0<=fd<10) to shell space (fd>=10),
 * set close-on-exec flag.
d1219 2
a1220 1
	if (ofd < 0)		/* original fd closed */
d1223 2
a1224 1
		ksh_dup2(ofd, fd, true); /* XXX: what to do if this fails? */
d1446 2
a1447 1
	tp->nfree = (nsize * 4) / 5;	/* table can get 80% full */
d1451 3
a1453 1
	nsize--;			/* from here on nsize := mask */
@


1.174
log
@• implement KSHEGID, KSHGID, KSHUID variables by suggestion of Richard K.
  (KSHEUID aka USER_ID already exists)
• simplify, speed up LCG and $RANDOM handling again
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.173 2010/11/01 17:29:04 tg Exp $");
d72 3
a74 2
#ifndef MKSH_UNEMPLOYED
#ifndef ANDROID
a75 1
#endif
@


1.173
log
@change behaviour of argument-less exit in traps to match SUSv4; Debian #599484 (original patch from Jonathan Nieder, thanks!) in a variant that appears to handle nested traps well
@
text
@d7 1
a7 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.172 2010/09/14 21:26:14 tg Exp $");
a39 5
#if !HAVE_SETRESUGID
extern uid_t kshuid;
extern gid_t kshgid, kshegid;
#endif

d48 1
d51 1
a51 2
void chvt_reinit(void);
Source *mksh_init(int, const char *[]);
d64 3
a66 2
	T_typeset, "-i10", "COLUMNS", "LINES", "OPTIND", "PGRP", "PPID",
	    "RANDOM", "SECONDS", "TMOUT", "USER_ID", NULL,
d96 35
a130 1
struct env *e = &kshstate_v.env_;
d141 2
a142 2
Source *
mksh_init(int argc, const char *argv[])
d173 4
a176 3
	kshstate_v.env_.type = E_NONE;
	ainit(&kshstate_v.env_.area);
	newblock();		/* set up global l->vars and l->funs */
d183 1
a183 1
		return (NULL);
d231 2
a232 1
	/* Set PATH to def_path (will set the path global variable).
d239 2
a240 1
	/* Turn on nohup by default for now - will change to off
d247 2
a248 1
	/* Turn on brace expansion by default. AT&T kshs that have
d253 2
a254 1
	/* Set edit mode to emacs by default, may be overridden
d256 2
a257 1
	 * on in vi by default. */
d305 2
a306 1
		/* Only set pwd if we know where we are or if it had a
d323 4
d338 5
a342 1
	setint((vp = global("RANDOM")), (mksh_uari_t)evilhash(kshname));
d344 3
a346 1
	setint((vp = global("USER_ID")), (mksh_uari_t)ksheuid);
d350 1
a350 6
#if HAVE_SETRESUGID
	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();
#else
	Flag(FPRIVILEGED) = (kshuid = getuid()) != ksheuid ||
	    (kshgid = getgid()) != (kshegid = getegid());
#endif
d361 1
a361 1
		return (NULL);
d467 2
a468 1
	/* Do this before profile/$ENV so that if it causes problems in them,
d510 3
a512 17
	return (s);
}

int
main(int argc, const char *argv[])
{
	Source *s;

	kshstate_v.lcg_state_ = 5381;

	if ((s = mksh_init(argc, argv))) {
		/* put more entropy into the LCG */
		change_random(s, sizeof(*s));
		/* doesn't return */
		shell(s, true);
	}
	return (1);
d548 2
a549 1
			/* intr_ok is set if we are including .profile or $ENV.
d620 2
a621 1
				/* Reset any eof that was read as part of a
d627 2
a628 1
				/* Used by exit command to get back to
d677 2
a678 1
				/* this for POSIX which says EXIT traps
d778 2
a779 1
	/* Bottom of the stack.
d792 2
a793 1
				/* ham up our death a bit (AT&T ksh
d877 2
a878 1
/* Initialise tty_fd. Used for saving/reseting tty modes upon
d976 2
a977 1
/* Used by built-in utilities to prefix shell and utility name to message
d998 2
a999 1
	/* POSIX special builtins and ksh special builtins cause
d1174 2
a1175 1
/* Called by iosetup() (deals with 2>&4, etc.), c_read, c_print to turn
d1198 2
a1199 1
	/* X_OK is a kludge to disable this check for dups (x<&1):
d1235 2
a1236 1
/* Called by c_read() and by iosetup() to close the other side of the
d1248 2
a1249 1
/* Called by c_print when a write to a fd fails with EPIPE and by iosetup
d1261 2
a1262 1
/* Called to check for existence of/value of the co-process file descriptor.
d1277 2
a1278 1
/* called to close file descriptors related to the coprocess (if any)
@


1.172
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.171 2010/09/14 21:00:13 tg Exp $");
d675 3
a677 1
		runtrap(&sigtraps[SIGEXIT_]);
d680 3
a682 1
		runtrap(&sigtraps[SIGERR_]);
@


1.171
log
@┌──┤ apply Android patch from Jeff Hamilton:
│Don't alias 'stop' to 'kill -STOP'
│
│Android has already has a stop command used
│to stop the main runtime and the alias
│interferes with testing tools that expect
│stop to kill the runtime.
│
│Change-Id: I02b7efb9203dc39e97f63eb702a54ff79935b316

Although, this is closer to his first patchset and only takes
care of the alias, not the testsuite (which doesn’t run, at
least not out-of-the-box, nicely anyway) using #ifdef ANDROID.

We certainly want a more flexible testsuite…
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.170 2010/08/28 20:22:20 tg Exp $");
d87 1
a87 1
	r_fc_e_,
d122 1
a122 1
	size_t k;
d184 1
a184 1
	if ((k = confstr(_CS_PATH, NULL, 0)) != (size_t)-1 && k > 0 &&
d1269 1
d1317 1
a1317 1
	ntblp = alloc(nsize * sizeof(struct tbl *), tp->areap);
d1396 1
a1396 1
	int len;
d1411 3
a1413 2
	len = strlen(n) + 1;
	p = alloc(offsetof(struct tbl, name[0]) + len, tp->areap);
d1461 2
a1462 1
	p = alloc((tp->size + 1) * sizeof(struct tbl *), ATEMP);
@


1.170
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.169 2010/08/28 18:50:54 tg Exp $");
d77 1
d79 1
@


1.169
log
@improve string pooling: saves 316 bytes in .text
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.168 2010/08/28 15:39:19 tg Exp $");
d427 1
a427 1
		warningf(false, "Cannot determine current working directory");
d478 1
a478 1
		/* doesn’t return */
d529 1
a529 1
			internal_errorf("include: %d", i);
d615 1
a615 1
			internal_errorf("shell: %d", i);
d860 2
a861 2
			warningf(false,
			    "No controlling tty (open /dev/tty: %s)",
d872 1
a872 2
				warningf(false,
				    "Can't find tty file descriptor");
d878 2
a879 2
			warningf(false, "%s: %s: %s", "j_ttyinit",
			    "dup of tty fd failed", strerror(errno));
d1281 1
a1281 1
	shf_snprintf(pathname, len, "%s/%s", dir, "mksh.XXXXXXXXXX");
@


1.168
log
@int → bool
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.167 2010/07/04 17:45:15 tg Exp $");
d71 1
a71 1
	"alias",
d90 1
a90 1
	"alias", "-tU",
d326 1
a326 1
			errorf("-c requires an argument");
d636 1
a636 1
				shellf("Use 'exit' to leave ksh\n");
d879 2
a880 2
			warningf(false, "j_ttyinit: dup of tty fd failed: %s",
			    strerror(errno));
d883 2
a884 3
			warningf(false,
			    "j_ttyinit: can't set close-on-exec flag: %s",
			    strerror(errno));
d1282 1
a1282 1
	shf_snprintf(pathname, len, "%s/mksh.XXXXXXXXXX", dir);
@


1.167
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.166 2010/07/04 17:33:55 tg Exp $");
d340 1
a340 1
			shl_stdout_ok = 0;
d909 1
a909 1
	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
d944 1
a944 1
	shl_stdout_ok = 0;	/* debugging: note that stdout not valid */
@


1.166
log
@to speed up mksh, get rid of arc4random(3) uses and use the LCG always;
depend on ASLR for seeding
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.165 2010/05/22 12:49:15 tg Exp $");
d57 3
d405 6
d1471 10
@


1.165
log
@apply diff from manuel giraud via oksh to keep track of LINENO in a trap
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.164 2010/04/20 17:28:20 tg Exp $");
d95 1
a95 2
static struct env env;
struct env *e = &env;
a103 4

#if !HAVE_ARC4RANDOM
	change_random(&kshstate_, sizeof(kshstate_));
#endif
d138 2
a139 2
	env.type = E_NONE;
	ainit(&env.area);
d292 1
a292 1
	setint((vp = global("RANDOM")), (mksh_uari_t)hash(kshname));
a295 3
#if HAVE_ARC4RANDOM
	Flag(FARC4RANDOM) = 1;		/* initialised */
#endif
d464 5
a468 1
	if ((s = mksh_init(argc, argv)))
d471 1
a1299 20
/* Bob Jenkins' one-at-a-time hash */
uint32_t
oaathash_full(register const uint8_t *bp)
{
	register uint32_t h = 0;
	register uint8_t c;

	while ((c = *bp++)) {
		h += c;
		h += h << 10;
		h ^= h >> 6;
	}

	h += h << 3;
	h ^= h >> 11;
	h += h << 15;

	return (h);
}

@


1.164
log
@add MKSH_DEFAULT_TMPDIR
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2009/01/29 23:27:26 jaredy Exp $	*/
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.163 2010/03/27 20:36:26 tg Exp $");
d543 1
d545 1
a545 1
command(const char *comm)
d551 1
@


1.163
log
@allow MKSHRC_PATH to change from 「"~/.mkshrc"」, for Android &c.
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.162 2010/01/29 09:34:29 tg Exp $");
d49 4
d1254 1
a1254 1
	dir = tmpdir ? tmpdir : "/tmp";
@


1.162
log
@remove some more of this ugliness
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.161 2010/01/28 15:18:48 tg Exp $");
d45 4
d436 1
a436 1
		env_file = substitute(substitute("${ENV:-~/.mkshrc}", 0),
@


1.161
log
@To solve the incompatibility issues between mksh-current, old mksh versions
and vendor pdksh versions, re-introduce FPOSIX alongside FSH. The semantics
are now:
‣ set -o posix ⇒
  • disable brace expansion and FSH when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
‣ set -o sh ⇒
  • set automatically #ifdef MKSH_BINSHREDUCED
  • disable brace expansion and FPOSIX when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
  • trigger MKSH_MIDNIGHTBSD01ASH_COMPAT mode if compiled in
  • make “set -- $(getopt ab:c "$@@")” construct work

Note that the set/getopt one used to behave POSIXly only with FSH or
FPOSIX (depending on the mksh version) set and Bourne-ish with it not
set, so this changes default mksh behaviour to POSIX!
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.160 2010/01/25 14:38:02 tg Exp $");
d508 1
a508 1
			/* FALLTHRU */
d588 1
a588 1
			/* FALLTHRU */
d675 1
a675 1
			/* FALLTHRU */
@


1.160
log
@remove some debugging code
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.159 2010/01/25 14:07:38 tg Exp $");
d325 1
a325 1
		/* compatibility to MidnightBSD 0.1 /bin/sh (not desired) */
@


1.159
log
@fix © year
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.158 2010/01/01 17:44:08 tg Exp $");
a1418 3
#ifdef notyet_ktremove
	p->tablep = tp;
#endif
a1429 22
#ifdef notyet_ktremove
void
ktremove(struct tbl *p)
{
	struct tbl **pp;

	if (p->tablep && p->tablep->size && ktscan(p->tablep, p->name,
	    p->ua.hval, &pp) == p) {
		/* ktremove p */
wontwork("cannot use NULL here, see r1.143 commit message");
		*pp = NULL;
		p->tablep->nfree++;
		/* get rid of p */
wontwork("need to check FINUSE, see texpand");
		afree(p, p->areap);
	} else {
		/* mark p as free for garbage collection via texpand */
		p->flag = 0;
	}
}
#endif

@


1.158
log
@• re-implement wcswidth-like behaviour for ${%foo} even in !UTFMODE
• merge the rest of branch tg-wcswidth-behaviour
• enhance test cases for wcswidth-like behaviour
• switch hash table collision resolution algorithm to Python’s as announced
• bump vsn
@
text
@d7 1
a7 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.157 2009/12/05 17:43:47 tg Exp $");
@


1.157
log
@llvm/clang scan-build is now content…
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.156 2009/12/05 13:02:26 tg Exp $");
d1280 5
d1286 1
d1316 2
a1317 2
	size_t i, osize = tp->size;
	struct tbl *tblp, **p;
d1328 1
d1332 12
a1343 5
				for (p = &ntblp[tblp->ua.hval &
				    (tp->size - 1)]; *p != NULL; p--)
					if (p == ntblp)	/* wrap */
						p += tp->size;
				*p = tblp;
d1362 1
a1362 1
/* table, name (key) to search for, hash(n) */
d1364 1
a1364 1
ktscan(struct table *tp, const char *n, uint32_t h, struct tbl ***ppp)
d1366 1
d1369 13
a1381 13
	/* search for name in hashed table */
	for (pp = &tp->tbls[h & (tp->size - 1)]; (p = *pp) != NULL; pp--) {
		if (p->ua.hval == h && !strcmp(p->name, n) &&
		    (p->flag & DEFINED))
			goto found;
		if (pp == tp->tbls)
			/* wrap */
			pp += tp->size;
	}
	/* not found */
	p = NULL;

 found:
@


1.156
log
@Kürzen!
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.155 2009/11/28 15:38:29 tg Exp $");
d772 4
a775 1
	/* Don't clean up temporary files - parent will probably need them.
@


1.155
log
@fix 'mksh -U -i' and 'mksh +U -i'
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.154 2009/10/30 14:37:42 tg Exp $");
d1315 1
a1315 1
	tp->nfree = 8 * nsize / 10;	/* table can get 80% full */
@


1.154
log
@• fix 「mksh -lT1」 (it was broken due to getpgrp() et al. being
  moved to early)
• allow ‘-T’ for MKSH_SMALL too, the installer needs it

sync clog
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.153 2009/10/17 21:16:02 tg Exp $");
d48 1
d103 2
a104 2
int
main(int argc, const char *argv[])
d109 1
a109 1
	unsigned char restricted, errexit;
d144 1
a144 1
		exit(1);
d309 3
d314 5
a318 1
		exit(1);
d366 2
d370 1
a374 1
		if (!UTFMODE) {
a391 1
		}
d394 1
a394 1
		UTFMODE = 1;
d396 1
a396 1
		UTFMODE = 0;
d398 1
d456 12
a467 2
	shell(s, true);	/* doesn't return */
	return (0);
@


1.153
log
@• overhaul handling of special variables
• use a combination of the one-at-a-time hash and an LCG for handling
  the $RANDOM special if !HAVE_ARC4RANDOM instead of rand(3)/srand(3)
  and get rid of time(3) usage to reduce import footprint
• raise entropy state (mostly in the !HAVE_ARC4RANDOM case though…)
• simplify handling of the $RANDOM_SPECIAL generally
• tweak hash() to save a temp var for non-optimising compilers
• some int → mksh_ari_t and other type fixes
• general tweaking of code and comments
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.152 2009/10/02 18:08:34 tg Exp $");
d47 1
d89 13
d117 2
a118 8
	kshpid = procpid = getpid();
	ksheuid = geteuid();
	kshpgrp = getpgrp();
	kshppid = getppid();

#if !HAVE_ARC4RANDOM
	change_random(&kshstate_, sizeof(kshstate_));
#endif
@


1.152
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.151 2009/09/29 12:28:13 tg Exp $");
a95 1
	pid_t ppid;
d106 1
a106 1
	ppid = getppid();
d109 1
a109 2
	change_random((unsigned long)time(NULL));
	change_random(((unsigned long)ksheuid << 16) | kshpid);
a267 9
	vp = global("RANDOM");
#if HAVE_ARC4RANDOM
	Flag(FARC4RANDOM) = 1;
	/* avoid calling setspec */
	vp->flag |= ISSET | INT_U;
#else
	vp->flag |= INT_U;
	setint(vp, (mksh_ari_t)((unsigned long)kshname + 33 * ppid));
#endif
d278 3
a280 1
	setint((vp = global("PPID")), (mksh_uari_t)ppid);
d284 3
d1258 1
a1258 1
hash(const char *cp)
a1261 1
	register const uint8_t *bp = (const uint8_t *)cp;
@


1.151
log
@SUSv4 says that there be exit 127; the old code tried but failed, so it
was an actual programmatical bug…
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.150 2009/09/27 10:31:06 tg Exp $");
d213 1
a213 1
	/* set FPOSIX if we're called as -sh or /bin/sh or so */
d224 1
a224 1
			change_flag(FPOSIX, OF_FIRSTTIME, 1);
d316 1
a316 1
		if (Flag(FPOSIX) && argv[argi] && !strcmp(argv[argi], "--"))
d349 1
a349 1
	/* This bizarreness is mandated by POSIX */
d1116 1
a1116 1
	 * posix has to say).
@


1.150
log
@• avoid calling arc4random_pushb for inheritance and other redundant items;
  call it only if $RANDOM is indeed set (although pool extension would be a
  possibility we do have arc4random_atexit which does it nicely too)
• avoid calling setspec for int→str conversion just before execve()
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.149 2009/09/26 03:40:00 tg Exp $");
d323 1
a323 1
		s->file = kshname = argv[argi++];
d327 5
a331 2
			exstat = 127; /* POSIX */
			errorf("%s: %s", s->file, strerror(errno));
d333 1
@


1.149
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.148 2009/09/26 01:08:27 tg Exp $");
d272 1
a273 1
	Flag(FARC4RANDOM) = 1;
@


1.148
log
@get rid of "U getenv"
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.147 2009/09/24 17:15:31 tg Exp $");
d50 2
a51 1
static const char initsubs[] = "${PS2=> } ${PS3=#? } ${PS4=+ }";
d54 4
a57 7
	"typeset", "-r", initvsn, NULL,
	"typeset", "-x", "SHELL", "PATH", "HOME", NULL,
	"typeset", "-i10", "COLUMNS=0", "LINES=0", "OPTIND=1", NULL,
	"typeset", "-Ui10", "PGRP", "PPID", "RANDOM", "USER_ID", NULL,
	"eval", "typeset -i10 SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"",
	NULL,
	"alias", "integer=typeset -i", "local=typeset", NULL,
d59 2
d104 5
d110 2
a111 1
	change_random((unsigned long)time(NULL) * getpid());
d213 1
a213 1
	/* Set FPOSIX if we're called as -sh or /bin/sh or so */
d220 1
a232 1
	kshpid = procpid = getpid();
a260 8
	ppid = getppid();
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
	change_random(((unsigned long)kshname) ^
	    ((unsigned long)time(NULL) * kshpid * ppid));
#endif
#if HAVE_ARC4RANDOM
	Flag(FARC4RANDOM) = 2;	/* use arc4random(3) until $RANDOM is written */
#endif
d267 12
d280 1
a280 1
	safe_prompt = (ksheuid = geteuid()) ? "$ " : "# ";
d287 6
a292 3
	setint(global("PGRP"), (mksh_uari_t)(kshpgrp = getpgrp()));
	setint(global("PPID"), (mksh_uari_t)ppid);
	setint(global("USER_ID"), (mksh_uari_t)ksheuid);
d424 1
a424 1
			"typeset", "-r", "PATH",
a1278 21
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
uint32_t
hashmem(const void *cp, size_t len)
{
	register uint32_t h = 0;
	register const uint8_t *bp = (const uint8_t *)cp;

	while (len--) {
		h += *bp++;
		h += h << 10;
		h ^= h >> 6;
	}

	h += h << 3;
	h ^= h >> 11;
	h += h << 15;

	return (h);
}
#endif

@


1.147
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.146 2009/09/23 18:04:57 tg Exp $");
d355 6
a360 6
			ccp = getenv("LC_ALL");
			if (!ccp || !*ccp) {
				ccp = getenv("LC_CTYPE");
				if (!ccp || !*ccp)
					ccp = getenv("LANG");
			}
@


1.146
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.145 2009/09/20 16:40:55 tg Exp $");
d202 1
a202 1
#ifndef MKSH_NOVI
@


1.145
log
@more of this:

• shell flags are now handled in one single place (sh_flags.h)
• sync comments (between enum and array) and manpage with reality
• FMONITOR is now no longer needed for Hartz IV shells
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.144 2009/09/06 17:42:13 tg Exp $");
d1266 21
@


1.144
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.143.2.1 2009/08/30 20:56:07 tg Exp $");
d290 1
d292 1
@


1.143
log
@a couple of overnight, phone call and code/doku read ideas:
• we must not set the item pointer to NULL, since subsequent ktscan()
  would stop there and not find any later occurrences
  possible resolution strategies:
  ‣ still keep tablep; store a dummy value (either (void *)-1 or, probably
    more portable, &ktenter or something like that) as is-free marker
    ⇒ retains benefit of keeping count of actually used entries
    ⇒ see below for further discussion
  ‣ don't keep tablep; revert back to setting entry->flag = 0
    ⇒ need to ktwalk() or ktsort() for getting number of entries
    ⇒ most simple code
  ‣ same but with a twist: make ktscan() set pp to the first one with
    !(entry->flag & DEFINED)¹ so that it can subsequently be re-used,
    or, more accurate, free’d and the entry pointer re-used
    ⇒ less chance of texpand()ing when not needed
  ‣ similar (from kabelaffe@@): in ktsearch(), move the one we DID find
    to the first unused one
    ⇒ doesn’t need tablep or something, but has the overall best
      memory use
    ⇒ more complicated ktscan(): needs to check pointer for NULL, for
      dummyval, then entry->flag
    ⇒ makes lookup more expensive
    ⇒ benefit: self-optimising hash tables
    ⇒ loss: still need ktwalk() or ktsort()
• when afree()ing in ktremove(), …
  ① need to take FINUSE into account
• Python-2.5.4/Objects/dictnotes.txt talks about cache lines
  ‣ linear backward scan is much worse than linear forward scan
    (even if we have to calculate the upper C-array bound)
  ‣ dereferencing the entry pointer in ktscan() is a penalty
• Python-2.5.4/Objects/dictobject.c has a lot of comments and
  a rather interesting collision resolution algorithm, which
  seems to de-cluster better than linear search at not much
  more cost
• clib and libobjfw have unusable (for looking-at-for-ideas)
  hash table implementations

this is a no-op change breaking ifdef-out-d code; the most likely
to happen is to switch to the following scheme:
• keep tablep in struct tbl
• use a magic pointer value for ktremove’d entries, deallocate
  the struct tbl as soon as possible – if not FINUSE, immediately
  inside ktremove()
  ‣ memory gain, despite needing to have tablep around
• nuke ktdelete, so that all ops go through kt{enter,remove}
  ‣ gains us accurate fill information
  ‣ speed gain: ktscan() needs no longer dereference removed entries
  ‣ memory (ktsort) and speed (ktwalk) gain: removed entries are now
    ignored right from the beginning, so tstate->left and the size
    of the sorted array are accurate
  ‣ removed entries no longer can cause texpand() to be invoked
⇒ this does not give us self-optimising tables, but a speed and
  memory benefit plus, probably, simplicity of code; we accurately
  know how many non-deleted entries are in a keytab so we can cal-
  culate if we need to expand, how much space ktsort() is going to
  need, and, for when indexed arrays will be converted to use key-
  tabs instead of singly linked linear lists, ${#foo[*]} is fast
  (although ${!foo[*]}² and ${foo[*]}³ will need some tweaking and
  may run a little less quickly)
• shuffle code around, so that things like search/scan and garbage
  collection can be re-used
• use Python’s collision resolution algorithm ipv linear search

② the list of keys needs to be sorted, at least for indexed arrays⁴
③ this needs to be sorted by keys, at least for indexed arrays⁴
④ … but this is a nice-to-have for associative arrays⁵ as well
⑤ which we however do not have
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.142 2009/08/28 21:01:26 tg Exp $");
d70 1
@


1.143.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic “typeset -n v=$1” or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.143 2009/08/29 11:26:44 tg Exp $");
a69 1
	"nameref=typeset -n",
@


1.142
log
@… but since I liked the bonus of having the hval stored so much, merge
it with the array index; var.c says that
│ 1244         /* The table entry is always [0] */
so that we can have a special flag and a union which stores hval for
the table index, the array index otherwise (coïncidentally *hint hint*
they have the same size)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.141 2009/08/28 20:38:42 tg Exp $");
d1383 1
d1387 1
@


1.141
log
@for now, until we really use kt*() otherwise, ifdef out tablep/hval
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.140 2009/08/28 20:30:57 tg Exp $");
d1281 1
a1281 5
#ifdef notyet_ktremove
				for (p = &ntblp[tblp->hval &
				    (tp->size - 1)]; *p != NULL; p--)
#else
				for (p = &ntblp[hash(tblp->name) &
a1282 1
#endif
d1312 1
a1312 4
#ifdef notyet_ktremove
		if (p->hval == h && !strcmp(p->name, n) && (p->flag & DEFINED))
#else
		if (*p->name == *n && !strcmp(p->name, n) &&
a1313 1
#endif
a1361 1
	p->hval = h;
d1363 1
d1381 1
a1381 1
	    p->hval, &pp) == p) {
@


1.140
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.138 2009/08/28 18:53:59 tg Exp $");
d1281 1
d1284 4
d1317 1
d1319 4
d1369 1
d1372 1
d1383 1
d1385 1
a1385 1
ktdelete(struct tbl *p)
d1401 1
@


1.139
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d1239 2
d1281 1
a1281 1
				for (p = &ntblp[hash(tblp->name) &
a1303 12
void
ktremove(struct table_entry *pte)
{
	struct tbl *p;

	p = *(pte->ep);
	*(pte->ep) = NULL;
	++(pte->tp->nfree);

	afree(p, p->areap);
}

d1305 2
a1306 2
struct tbl *
ktsearch(struct table *tp, const char *n, uint32_t h, struct table_entry *pte)
a1309 3
	if (tp->size == 0)
		return (NULL);

d1312 4
a1315 10
		if (*p->name == *n && strcmp(p->name, n) == 0 &&
		    (p->flag & DEFINED)) {
			/* found */
			if (pte) {
				pte->tp = tp;
				pte->ep = pp;
			}
			return (p);
		}
		if (pp == tp->tbls)	/* wrap */
d1318 8
d1327 5
a1331 1
	return (NULL);
d1336 1
a1336 1
ktenter(struct table *tp, const char *n, uint32_t h, struct table_entry *pte)
d1344 2
a1345 13
	/* search for name in hashed table */
	for (pp = &tp->tbls[h & (tp->size - 1)]; (p = *pp) != NULL; pp--) {
		if (*p->name == *n && strcmp(p->name, n) == 0) {
			/* found */
			if (pte) {
				pte->tp = tp;
				pte->ep = pp;
			}
			return (p);
		}
		if (pp == tp->tbls)	/* wrap */
			pp += tp->size;
	}
d1347 2
a1348 1
	if (tp->nfree <= 0) {	/* too full */
d1352 1
d1359 2
d1368 18
a1385 3
	if (pte) {
		pte->tp = tp;
		pte->ep = pp;
a1386 1
	return (p);
@


1.138
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.137 2009/08/08 13:08:51 tg Exp $");
d1302 12
d1316 1
a1316 1
ktsearch(struct table *tp, const char *n, uint32_t h)
d1326 6
a1331 1
		    (p->flag & DEFINED))
d1333 1
d1343 1
a1343 1
ktenter(struct table *tp, const char *n, uint32_t h)
d1353 8
a1360 2
		if (*p->name == *n && strcmp(p->name, n) == 0)
			return (p);	/* found */
d1382 4
@


1.137
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.136 2009/07/25 21:31:26 tg Exp $");
d151 2
a152 1
	ktinit(&builtins, APERM, 64); /* must be 2^n (currently 44 builtins) */
d1237 1
a1237 1
static void texpand(struct table *, int);
d1240 3
a1242 2
unsigned int
hash(const char *n)
d1244 3
a1246 1
	unsigned int h = 0;
d1248 9
a1256 4
	while (*n != '\0')
		h = 2*h + *n++;
	return (h * 32821);	/* scatter bits */
}
d1258 1
a1258 8
void
ktinit(struct table *tp, Area *ap, int tsize)
{
	tp->areap = ap;
	tp->tbls = NULL;
	tp->size = tp->nfree = 0;
	if (tsize)
		texpand(tp, tsize);
d1262 1
a1262 1
texpand(struct table *tp, int nsize)
d1264 1
a1264 1
	int i;
a1266 1
	int osize = tp->size;
d1292 11
a1302 3
/* table */
/* name to enter */
/* hash(n) */
d1304 1
a1304 1
ktsearch(struct table *tp, const char *n, unsigned int h)
d1323 1
a1323 3
/* table */
/* name to enter */
/* hash(n) */
d1325 1
a1325 1
ktenter(struct table *tp, const char *n, unsigned int h)
d1397 2
a1398 1
	for (i = 0; i < (size_t)tp->size; i++)
@


1.136
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.135 2009/07/25 20:52:41 tg Exp $");
d93 1
a93 1
	int restricted, errexit;
d415 1
a415 2
	if (errexit)
		Flag(FERREXIT) = 1;
d1375 2
a1376 2
	const struct tbl *a = *((struct tbl * const *)p1);
	const struct tbl *b = *((struct tbl * const *)p2);
@


1.135
log
@in an interesting piece of self humour, remove the stop and suspend
aliases from shells requiring the Arbeitsamt to get a job ;-)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.134 2009/07/25 20:26:32 tg Exp $");
d791 1
d1010 1
@


1.134
log
@improve MKSH_NOPWNAM handling, whether MKSH_SMALL or not; it will cause
the entire ~fac/ expansion code to be omitted
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.133 2009/06/11 12:42:19 tg Exp $");
d63 1
a63 2
#ifndef notyet_MKSH_UNEMPLOYED
	/* the alias list must be constant, for the regression test suite */
@


1.133
log
@capitalise AT&T®
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.132 2009/06/10 18:12:47 tg Exp $");
d144 1
a144 1
#ifndef MKSH_SMALL
@


1.132
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.131 2009/06/08 20:06:47 tg Exp $");
d76 1
a76 1
	 /* this is what at&t ksh seems to track, with the addition of emacs */
d187 1
a187 1
	 * (at&t ksh does not have a nohup option - it always sends
d613 1
a613 1
	/* ordering for EXIT vs ERR is a bit odd (this is what at&t ksh does) */
d695 1
a695 1
				/* ham up our death a bit (at&t ksh
@


1.131
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.130 2009/06/07 22:28:04 tg Exp $");
d192 1
a192 1
	/* Turn on brace expansion by default.  AT&T kshs that have
d198 1
a198 1
	 * by the environment or the user.  Also, we want tab completion
d538 1
a538 1
				 * top level shell.  Kind of strange since
d776 1
a776 1
/* Initialise tty_fd.  Used for saving/reseting tty modes upon
@


1.130
log
@new feature: -DMKSH_ASSUME_UTF8=0 assumes utf-8 is *not* set and skips
environment inspection; useful for initrd and the likes
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.129 2009/05/27 19:52:37 tg Exp $");
d426 1
a426 1
	return 0;
d440 1
a440 1
		return -1;
d460 1
a460 1
			return exstat & 0xff; /* see below */
d466 1
a466 1
				return 1;
d491 1
a491 1
	return i & 0xff;	/* & 0xff to ensure value not -1 */
d501 1
a501 1
	return shell(s, false);
d606 1
a606 1
	return exstat;
d651 1
a651 1
	cp = alloc(sizeof (struct env) - ALLOC_SIZE, ATEMP);
d985 2
a986 2
	return fstat(fd, &statb) == 0 && !S_ISREG(statb.st_mode) ?
	    SHF_UNBUF : 0;
d1028 1
a1028 1
		return -1;
d1162 1
a1162 1
		return fd;
d1165 1
a1165 1
	return -1;
d1207 1
a1207 1
	tp = alloc(sizeof (struct temp) + len, ap);
d1231 1
a1231 1
	return tp;
d1246 1
a1246 1
	return h * 32821;	/* scatter bits */
d1267 1
a1267 1
	ntblp = alloc(nsize * sizeof (struct tbl *), tp->areap);
d1300 1
a1300 1
		return NULL;
d1306 1
a1306 1
			return p;
d1311 1
a1311 1
	return NULL;
d1329 1
a1329 1
			return p;	/* found */
d1351 1
a1351 1
	return p;
d1367 1
a1367 1
			return p;
d1369 1
a1369 1
	return NULL;
d1387 1
a1387 1
	p = alloc((tp->size + 1) * sizeof (struct tbl *), ATEMP);
d1394 1
a1394 1
	qsort(p, (i = dp - p), sizeof (void *), tnamecmp);
d1396 1
a1396 1
	return p;
@


1.129
log
@implement an extension that an interactive mode input line, when
starting with an ‘!’ exclamation mark at the beginning of a com-
mand (PS1 not PS2), shall have the same effect as the predefined
“r” alias, to be compatible with csh and GNU bash’s “!string” to
«Execute last used command starting with string» – documentation
and feature request provided by wbx@@ (Waldemar Brodkorb)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.128 2009/05/16 21:00:51 tg Exp $");
d362 2
d365 1
a365 1
		UTFMODE = 1;
@


1.128
log
@laffer1 agreed they will need -DMKSH_MIDNIGHTBSD01ASH_COMPAT in the
short term, but only for /bin/sh – thus recommend to also define
-DMKSH_BINSHREDUCED and make it dependent on FPOSIX
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.127 2009/05/16 18:40:07 tg Exp $");
d72 1
a72 1
	"r=fc -e -",
@


1.127
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.126 2009/05/16 16:59:37 tg Exp $");
d300 1
a300 1
		if (argv[argi] && !strcmp(argv[argi], "--"))
@


1.126
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.125 2009/04/07 19:43:27 tg Exp $");
d298 1
a298 1
#if 0
@


1.125
log
@"evil" workaround to the alignment issues: embed an ALLOC_ITEM into
struct env (other structures defined have no "foreign type with pos-
sible alignment constraints" members) and take care of it while dea-
ling in a struct env instance
@
text
@d6 20
d36 1
a36 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.124 2009/04/05 12:35:31 tg Exp $");
@


1.124
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.122 2009/03/22 17:47:37 tg Exp $");
d623 1
d625 7
a631 3
	ep = alloc(sizeof (struct env), ATEMP);
	ep->type = type;
	ep->flags = 0;
d633 1
a635 1
	ep->oenv = e;
d637 3
d647 1
d696 4
a699 1
	afree(ep, ATEMP);
@


1.123
log
@add (commented out) compatibility to MidnightBSD 0.1 /bin/sh – not
desired, because it defaces standards compliance

cf. https://www.mirbsd.org/permalinks/wlog-10_e20090329-tg-g10024.htm
@
text
@d43 2
d47 1
d315 2
a316 4
	i = Flag(FMONITOR) != 127;
	Flag(FMONITOR) = 0;
	j_init(i);
	/* Do this after j_init(), as tty_fd is not initialised 'til then */
@


1.122
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.121 2009/03/22 17:31:16 tg Exp $");
d275 5
@


1.121
log
@sync with oksh (nop)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2008/07/05 07:25:18 djm Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.120 2009/03/14 18:12:53 tg Exp $");
d569 1
a569 1
			exstat = execute(t, 0);
@


1.120
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d4 1
a4 1
/*	$OpenBSD: table.c,v 1.12 2005/12/11 20:31:21 otto Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.119 2008/12/29 21:34:20 tg Exp $");
@


1.119
log
@always set COLUMNS and LINES; make use of the fact in dot.mkshrc
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.118 2008/12/29 20:52:09 tg Exp $");
d35 2
a36 2
	"typeset", "-i10", "COLUMNS=0", "LINES=0", "OPTIND=1", "PGRP", "PPID",
	    "RANDOM", "USER_ID", NULL,
d253 3
a255 3
	setint(global("PGRP"), (long)(kshpgrp = getpgrp()));
	setint(global("PPID"), (long)ppid);
	setint(global("USER_ID"), (long)ksheuid);
@


1.118
log
@do not lie
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.117 2008/12/29 20:47:15 tg Exp $");
d35 4
a38 2
	"typeset", "-i10", "OPTIND=1", "PGRP", "PPID", "USER_ID", NULL,
	"eval", "typeset -i10 RANDOM SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
@


1.117
log
@give tty_init() another argument for silent initialisation
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.116 2008/12/13 17:02:15 tg Exp $");
d127 1
a127 1
	ktinit(&builtins, APERM, 64); /* must be 2^n (currently 40 builtins) */
@


1.116
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.115 2008/12/04 18:11:06 tg Exp $");
d738 1
a738 1
tty_init(int init_ttystate)
d740 1
a740 1
	int do_close = 1;
d756 4
a759 2
		warningf(false, "No controlling tty (open /dev/tty: %s)",
		    strerror(errno));
d762 1
a762 1
		do_close = 0;
d768 3
a770 1
			warningf(false, "Can't find tty file descriptor");
d775 3
a777 2
		warningf(false, "j_ttyinit: dup of tty fd failed: %s",
		    strerror(errno));
d779 4
a782 2
		warningf(false, "j_ttyinit: can't set close-on-exec flag: %s",
		    strerror(errno));
@


1.115
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.114 2008/11/30 10:33:39 tg Exp $");
d25 1
a25 1
static void reclaim(bool);
d94 1
a94 1
	APERM = anew(256);	/* initialise permanent Area */
d98 1
a98 1
	env.areap = anew(32);
d138 1
a138 1
	    confstr(_CS_PATH, cp = alloc(1, k + 1, APERM), k + 1) == k + 1)
d572 1
a572 1
		reclaim(false);
d616 1
a616 1
	ep = alloc(1, sizeof (struct env), ATEMP);
d619 1
a619 1
	ep->areap = anew(16);
d671 1
a671 1
		reclaim(true);
d676 1
a676 1
	reclaim(true);
d700 1
a700 1
			afree(ep->savefd, ep->areap);
d719 1
a719 1
reclaim(bool finish)
d723 1
a723 3
	adelete(&e->areap);
	if (!finish)
		e->areap = anew(16);
d1143 1
a1143 1
maketemp(PArea ap, Temp_type type, struct temp **tlist)
d1158 1
a1158 1
	tp = alloc(1, sizeof (struct temp) + len, ap);
d1201 1
a1201 1
ktinit(struct table *tp, PArea ap, int tsize)
d1218 1
a1218 1
	ntblp = alloc(nsize, sizeof (struct tbl *), tp->areap);
d1291 1
a1291 1
	p = alloc(1, offsetof(struct tbl, name[0]) + len, tp->areap);
d1338 1
a1338 1
	p = alloc(tp->size + 1, sizeof (struct tbl *), ATEMP);
@


1.114
log
@if MKSH_SMALL and HAVE_ARC4RANDOM, there is no need to use rand()/srand(3)
ever, since MKSH_SMALL is not required to be as close to compatibility as
normal/generic shells; we can also get rid of time(3) calls
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.113 2008/11/15 09:00:19 tg Exp $");
d314 1
a314 1
		if (!Flag(FUTFHACK)) {
d331 1
a331 1
			Flag(FUTFHACK) = isuc(ccp);
d335 1
a335 1
		Flag(FUTFHACK) = 1;
@


1.113
log
@give hints to anew() according to aalloc stats output for testsuite and a
little interactive use, to reduce the number realloc(3) must be called
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.112 2008/11/15 08:42:35 tg Exp $");
d230 1
d233 1
@


1.113.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.113 2008/11/15 09:00:19 tg Exp $");
d25 1
a25 1
static void reclaim(void);
d94 1
a94 1
	galloc_new(APERM, NULL, 256  GALLOC_VST("APERM"));
d98 1
a98 1
	env.gp_env = galloc_new(NULL, APERM, 32  GALLOC_VST("toplev env"));
d138 1
a138 1
	    confstr(_CS_PATH, cp = galloc(1, k + 1, APERM), k + 1) == k + 1)
d570 1
a570 3
		reclaim();
		e->gp_env = galloc_new(NULL, e->oenv->gp_env, 16
		    GALLOC_VST("shell env"));
d614 1
a614 1
	ep = galloc(1, sizeof (struct env), ATEMP);
d617 1
a617 1
	ep->gp_env = galloc_new(NULL, ATEMP, 16  GALLOC_VST("newenv"));
d669 1
a669 1
		reclaim();
d674 1
a674 1
	reclaim();
d677 1
a677 1
	gfree(ep, ATEMP);
d698 1
a698 1
			gfree(ep->savefd, ep->gp_env);
d717 1
a717 1
reclaim(void)
d721 3
a723 2
	galloc_del(e->gp_env);
	e->gp_env = NULL;
d1143 1
a1143 1
maketemp(PGroup ap, Temp_type type, struct temp **tlist)
d1158 1
a1158 1
	tp = galloc(1, sizeof (struct temp) + len, ap);
d1201 1
a1201 1
ktinit(struct table *tp, PGroup ap, int tsize)
d1203 1
a1203 1
	tp->gp_table = ap;
d1218 1
a1218 1
	ntblp = galloc(nsize, sizeof (struct tbl *), tp->gp_table);
d1236 1
a1236 1
				gfree(tblp, tp->gp_table);
d1239 1
a1239 1
	gfree(otblp, tp->gp_table);
d1291 1
a1291 1
	p = galloc(1, offsetof(struct tbl, name[0]) + len, tp->gp_table);
d1294 1
a1294 1
	p->gp_tbl = tp->gp_table;
d1338 1
a1338 1
	p = galloc(tp->size + 1, sizeof (struct tbl *), ATEMP);
@


1.112
log
@globalise internal_verrorf()
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.111 2008/11/15 07:35:24 tg Exp $");
d94 1
a94 1
	APERM = anew(0);	/* initialise permanent Area */
d98 1
a98 1
	env.areap = anew(0);
d617 1
a617 1
	ep->areap = anew(0);
d723 1
a723 1
		e->areap = anew(0);
@


1.111
log
@enable passing of a hint how many pointers we’ll need to anew()
if 0, the default is used
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.110 2008/11/12 04:55:18 tg Exp $");
d858 1
a858 3
static void internal_verrorf(const char *, va_list)
    __attribute__((format (printf, 1, 0)));
static void
@


1.110
log
@prepare for aalloc.c, which I have just written myself, as an area-based
allocator using malloc and free, with mmap malloc and omalloc in mind,
not counterfeiting its security measures such as guard pages, and having
some of our own, e.g. XOR random cookies, optional mprotect, etc.

zero cost (for we have arc4random())
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.109 2008/11/12 00:54:49 tg Exp $");
d94 1
a94 1
	APERM = anew();		/* initialise permanent Area */
d98 1
a98 1
	env.areap = anew();
d617 1
a617 1
	ep->areap = anew();
d723 1
a723 1
		e->areap = anew();
@


1.109
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.108 2008/11/12 00:27:56 tg Exp $");
d79 4
@


1.108
log
@isolate all knowledge of the area-based allocator from the rest of the code

cost: bss -= (0, 0, 16, 16); text += (520, 504, 516, 480)
[ gcc,pcc X full,small ]
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.107 2008/11/11 23:50:30 tg Exp $");
d134 1
a134 1
	    confstr(_CS_PATH, cp = alloc(k + 1, APERM), k + 1) == k + 1)
d610 1
a610 1
	ep = (struct env *)alloc(sizeof (*ep), ATEMP);
d1156 1
a1156 1
	tp = (struct temp *)alloc(sizeof (struct temp) + len, ap);
d1216 1
a1216 1
	ntblp = (struct tbl **)alloc(sizeofN(struct tbl *, nsize), tp->areap);
d1234 1
a1234 1
				afree((void *)tblp, tp->areap);
d1237 1
a1237 1
	afree((void *)otblp, tp->areap);
d1289 1
a1289 2
	p = (struct tbl *)alloc(offsetof(struct tbl, name[0])+len,
	    tp->areap);
d1336 1
a1336 1
	p = (struct tbl **)alloc(sizeofN(struct tbl *, tp->size + 1), ATEMP);
@


1.107
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.106 2008/11/10 19:33:07 tg Exp $");
d25 1
a25 1
static void reclaim(void);
d90 1
a90 1
	ainit(&aperm);		/* initialise permanent Area */
d94 1
a94 1
	ainit(&env.area);
d566 1
a566 1
		reclaim();
d613 1
a613 1
	ainit(&ep->area);
d665 1
a665 1
		reclaim();
d670 1
a670 1
	reclaim();
d694 1
a694 1
			afree(ep->savefd, &ep->area);
d713 1
a713 1
reclaim(void)
d717 3
a719 1
	afreeall(&e->area);
@


1.106
log
@work around even more format string warning stuff
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.105 2008/10/28 14:32:41 tg Exp $");
d1139 1
a1139 1
maketemp(Area *ap, Temp_type type, struct temp **tlist)
d1197 1
a1197 1
ktinit(struct table *tp, Area *ap, int tsize)
@


1.105
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.104 2008/10/20 19:29:23 tg Exp $");
d795 1
a795 1
	if (*fmt) {
d830 1
a830 1
	if (*fmt) {
@


1.104
log
@• change mksh to only then behave more POSuXish when called as /bin/sh or
  “-sh” if -DMKSH_BINSHREDUCED was passed during compilation, for example
  for Debian, but d̲e̲f̲i̲n̲i̲t̲i̲v̲e̲l̲y̲ n̲̲o̲̲t̲̲ for MirBSD™
• split up regression test to force this behaviour
• remove the gunk from our MirBSD™ startup scripts again
• mention arc4random.c changes on website, sync clog, warn packagers
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.103 2008/10/15 10:25:01 tg Exp $");
d448 1
a448 1
	s->file = str_save(name, ATEMP);
@


1.103
log
@use less stack storage, prefer .bss storage (saves us a memset() call)
and .data instead of another initialisation; this was prompted by a bug
in scan-build (the value can never be NULL, but it doesn’t realise it),
although this doesn’t fix it, but less stack usage is always good
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.102 2008/09/17 19:31:29 tg Exp $");
d176 1
a176 1
#ifndef MKSH_SMALL
@


1.102
log
@• bring back automatic turn-on of FPOSIX if called as sh/-sh
  ‣ only if !MKSH_SMALL
  ‣ add appropriate regression test
• if FPOSIX is set, do not close fds > 2 on exec, Debian #499139
• add appropriate regression tests for keeping fds private or not
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.101 2008/07/10 18:34:08 tg Exp $");
d60 3
a70 1
	struct env env;
a92 1
	memset(&env, 0, sizeof(env));
a94 1
	e = &env;
@


1.101
log
@remove a line which accidentally got committed, oops
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.99 2008/07/08 22:28:26 tg Exp $");
d176 15
@


1.100
log
@• bump NUFILE and FDBASE, allowing for more than 10 fds used by scripts
• change the code to accept more than a single digit for an fd
@
text
@a0 1
#include <err.h>
@


1.99
log
@sync with openbsd: only the RCS IDs, because the changed code in
question either does not exist in mksh (lex.c) or refers to the
only “feature” we do not pull, GNU bash-like $PS1 (main.c)
@
text
@d1 1
d17 1
a17 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.98 2008/05/17 18:47:00 tg Exp $");
d1011 29
a1039 26
	if (ksh_isdigit(name[0]) && !name[1]) {
		if ((fl = fcntl(fd = name[0] - '0', F_GETFL, 0)) < 0) {
			if (emsgp)
				*emsgp = "bad file descriptor";
			return -1;
		}
		fl &= O_ACCMODE;
		/* X_OK is a kludge to disable this check for dups (x<&1):
		 * historical shells never did this check (XXX don't know what
		 * posix has to say).
		 */
		if (!(mode & X_OK) && fl != O_RDWR &&
		    (((mode & R_OK) && fl != O_RDONLY) ||
		    ((mode & W_OK) && fl != O_WRONLY))) {
			if (emsgp)
				*emsgp = (fl == O_WRONLY) ?
				    "fd not open for reading" :
				    "fd not open for writing";
			return -1;
		}
		return fd;
	} else if (name[0] == 'p' && !name[1])
		return coproc_getfd(mode, emsgp);
	if (emsgp)
		*emsgp = "illegal file descriptor name";
	return -1;
@


1.98
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2007/05/31 20:47:44 otto Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.97 2008/05/15 15:24:10 tg Exp $");
@


1.97
log
@mksh:
* initialise the integers PPID, OPTIND, RANDOM, SECONDS, and TMOUT to base-10
* bring back PGRP as base-10 integer to the process group via getpgrp(2)
* initialise USER_ID as base-10 integer to the effective user id as retrieved
  from geteuid(2) = $(id -u)
* use $USER_ID in dot.mkshrc instead of spawning an id(1) process
  -> dot.mkshrc,v 1.34 now requires mksh R34
* convert more int to bool where appropriate
* remove dead code - getpgrp(2) cannot fail
* sync manual page to reality
* bump to mksh R34(beta) - feature freeze

XXX check if our_pgrp in jobs.c is still really needed, the setpgid call
XXX probably just makes us our own pgrp leader, and we might have to use
XXX and update kshpgrp accordingly - need feedback/help here but I think
XXX this simplification should be possible if I grok the code correctly.

etc/profile:
* adjust to $USER_ID changes in mksh (speed-up here, too)

mksh.hts:
* sync changelog
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.96 2008/05/04 01:58:14 tg Exp $");
d595 1
a595 1
	ep = (struct env *) alloc(sizeof(*ep), ATEMP);
d1136 1
a1136 1
	tp = (struct temp *) alloc(sizeof(struct temp) + len, ap);
@


1.96
log
@if we don't have setlocale(), just look at the env vars ourselves
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.95 2008/04/01 20:40:21 tg Exp $");
d35 2
a36 2
	"typeset", "-i", "PPID", "OPTIND=1", NULL,
	"eval", "typeset -i RANDOM SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
a215 1
	setint(global("PPID"), (long)ppid);
d230 3
d641 1
a641 1
				    getpgrp() == kshpid) {
@


1.95
log
@• unify ksh_dup2() usage, use bool where appropriate
• apply diff from mirbsdksh-1.11:
  #ifdef DUP2_BROKEN
  /* Ultrix systems like to preserve the close-on-exec flag */
  ‣ XXX we do #ifdef __ultrix here (imake-style) instead of mirtoconfing it
    (but does anyone know of any other OS with the same problem? plus we’d
    see it as we now know the symptoms)
• remove ultrix Build.hs warn=' but might work…' in the hope it DOES
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.94 2008/03/28 18:47:52 tg Exp $");
a287 1
#if HAVE_SETLOCALE_CTYPE
d294 1
d300 8
a310 1
#endif
@


1.94
log
@fix namespace conflict
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.93 2008/03/25 21:34:44 tg Exp $");
d925 1
a925 1
ksh_dup2(int ofd, int nfd, int errok)
d927 1
a927 1
	int ret = dup2(ofd, nfd);
d929 1
a929 1
	if (ret < 0 && errno != EBADF && !errok)
d932 6
a937 1
	return ret;
@


1.93
log
@• Add support for Ultrix 4.5 and ucode cc (?)
  ‣ I/O redirection seems broken:
    $ (date; date >/dev/null; date) | wc -l
    1 (expected: 2)
  ‣ other than that: working fine
  ‣ -YBSD (default) and -YSYSTEM_FIVE don’t work, just -YPOSIX, somehow
• Fix $(…) to `…` for OSF/1 V2.0 /bin/sh
  ‣ this compiler is FUBAR though:
	$ cat >t.c
	main() { return (foo()); }
	$ cc t.c
	ld:
	Unresolved :
	foo
	$ echo $?
	0
	$ ls -l a.out
	-rwxr-xr-x   1 mirbsd   users      10835 Jul 21 17:12 a.out
  ‣ it seems to have ucode, but man is not installed
• new mirtoconf check: mkstemp(3)
• if !HAVE_MKSTEMP (Ultrix), use tempnam(3)
• only use printf(1) if it exists (it doesn’t on Ultrix)
• a few more signals
• add S_ISLNK if the OS doesn’t define it
• add strcasecmp(3) proto for Ultrix (it _is_ in <portability.h>, but
  only for -YBSD I think)
• fgrep(1) on Ultrix doesn’t do “-e ① -e ②”

10x DEChengst:#UnixNL for giving access
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.92 2008/03/01 13:57:36 tg Exp $");
d293 1
a293 1
			const char *cp;
d295 1
a295 1
			cp = setlocale(LC_CTYPE, "");
d297 2
a298 2
			if (!isuc(cp))
				cp = nl_langinfo(CODESET);
d300 1
a300 1
			Flag(FUTFHACK) = isuc(cp);
@


1.92
log
@fix compilation in corner case, my bad
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.91 2008/03/01 02:21:37 tg Exp $");
d1116 1
d1118 4
d1123 10
a1132 1
	tp->name = pathname = (char *)&tp[1];
d1135 1
d1138 3
@


1.92.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.95 2008/04/01 20:40:21 tg Exp $");
d293 1
a293 1
			const char *ccp;
d295 1
a295 1
			ccp = setlocale(LC_CTYPE, "");
d297 2
a298 2
			if (!isuc(ccp))
				ccp = nl_langinfo(CODESET);
d300 1
a300 1
			Flag(FUTFHACK) = isuc(ccp);
d925 1
a925 1
ksh_dup2(int ofd, int nfd, bool errok)
d927 1
a927 1
	int rv;
d929 1
a929 1
	if (((rv = dup2(ofd, nfd)) < 0) && !errok && (errno != EBADF))
d932 1
a932 6
#ifdef __ultrix
	if (rv >= 0)
		fcntl(nfd, F_SETFD, 0);
#endif

	return (rv);
a1115 1
#if HAVE_MKSTEMP
a1116 4
#else
	pathname = tempnam(dir, "mksh.");
	len = ((pathname == NULL) ? 0 : strlen(pathname)) + 1;
#endif
d1118 1
a1118 10
	tp->name = (char *)&tp[1];
#if !HAVE_MKSTEMP
	if (pathname == NULL)
		tp->name[0] = '\0';
	else {
		memcpy(tp->name, pathname, len);
		free(pathname);
	}
#endif
	pathname = tp->name;
a1120 1
#if HAVE_MKSTEMP
a1122 3
#else
	if (tp->name[0] && (fd = open(tp->name, O_CREAT | O_RDWR, 0600)) >= 0)
#endif
@


1.92.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.98 2008/05/17 18:47:00 tg Exp $");
d35 2
a36 2
	"typeset", "-i10", "OPTIND=1", "PGRP", "PPID", "USER_ID", NULL,
	"eval", "typeset -i10 RANDOM SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
d216 1
a230 3
	setint(global("PGRP"), (long)(kshpgrp = getpgrp()));
	setint(global("PPID"), (long)ppid);
	setint(global("USER_ID"), (long)ksheuid);
d288 1
a294 1
#if HAVE_SETLOCALE_CTYPE
a299 8
#else
			ccp = getenv("LC_ALL");
			if (!ccp || !*ccp) {
				ccp = getenv("LC_CTYPE");
				if (!ccp || !*ccp)
					ccp = getenv("LANG");
			}
#endif
d303 1
d586 1
a586 1
	ep = (struct env *)alloc(sizeof (*ep), ATEMP);
d632 1
a632 1
				    (kshpgrp == kshpid)) {
d1127 1
a1127 1
	tp = (struct temp *)alloc(sizeof (struct temp) + len, ap);
@


1.92.2.3
log
@MFC: mksh R35
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2008/07/05 07:25:18 djm Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.101 2008/07/10 18:34:08 tg Exp $");
d1010 26
a1035 29
	if (name[0] == 'p' && !name[1])
		return (coproc_getfd(mode, emsgp));
	for (fd = 0; ksh_isdigit(*name); ++name)
		fd = (fd * 10) + *name - '0';
	if (*name || fd >= FDBASE) {
		if (emsgp)
			*emsgp = "illegal file descriptor name";
		return (-1);
	}
	if ((fl = fcntl(fd, F_GETFL, 0)) < 0) {
		if (emsgp)
			*emsgp = "bad file descriptor";
		return (-1);
	}
	fl &= O_ACCMODE;
	/* X_OK is a kludge to disable this check for dups (x<&1):
	 * historical shells never did this check (XXX don't know what
	 * posix has to say).
	 */
	if (!(mode & X_OK) && fl != O_RDWR && (
	    ((mode & R_OK) && fl != O_RDONLY) ||
	    ((mode & W_OK) && fl != O_WRONLY))) {
		if (emsgp)
			*emsgp = (fl == O_WRONLY) ?
			    "fd not open for reading" :
			    "fd not open for writing";
		return (-1);
	}
	return (fd);
@


1.92.2.4
log
@MFC: mksh R36b
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.116 2008/12/13 17:02:15 tg Exp $");
a59 3
static struct env env;
struct env *e = &env;

d68 1
a76 4
#if !HAVE_ARC4RANDOM
	change_random((unsigned long)time(NULL) * getpid());
#endif

d91 1
d94 1
a175 15
#ifdef MKSH_BINSHREDUCED
	/* Set FPOSIX if we're called as -sh or /bin/sh or so */
	{
		const char *cc;

		cc = kshname;
		i = 0; argi = 0;
		while (cc[i] != '\0')
			if ((cc[i++] | 2) == '/')
				argi = i;
		if (((cc[argi] | 0x20) == 's') && ((cc[argi + 1] | 0x20) == 'h'))
			change_flag(FPOSIX, OF_FIRSTTIME, 1);
	}
#endif

a210 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
a212 1
#endif
d293 1
a293 1
		if (!UTFMODE) {
d310 1
a310 1
			UTFMODE = isuc(ccp);
d314 1
a314 1
		UTFMODE = 1;
d433 1
a433 1
	strdupx(s->file, name, ATEMP);
d595 1
a595 1
	ep = alloc(sizeof (struct env), ATEMP);
d780 1
a780 1
	if (*fmt != 1) {
d815 1
a815 1
	if (*fmt != 1) {
d837 3
a839 1
void
d1139 1
a1139 1
	tp = alloc(sizeof (struct temp) + len, ap);
d1199 1
a1199 1
	ntblp = alloc(nsize * sizeof (struct tbl *), tp->areap);
d1217 1
a1217 1
				afree(tblp, tp->areap);
d1220 1
a1220 1
	afree(otblp, tp->areap);
d1272 2
a1273 1
	p = alloc(offsetof(struct tbl, name[0]) + len, tp->areap);
d1320 1
a1320 1
	p = alloc((tp->size + 1) * sizeof (struct tbl *), ATEMP);
@


1.91
log
@we don't need to be special if called as -sh any longer now
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.90 2008/02/25 00:58:26 tg Exp $");
d293 3
a295 1
			cc = setlocale(LC_CTYPE, "");
d297 2
a298 2
			if (!isuc(cc))
				cc = nl_langinfo(CODESET);
d300 1
a300 1
			Flag(FUTFHACK) = isuc(cc);
@


1.90
log
@now we don’t need more special FPOSIX behaviour any more
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.89 2007/10/25 15:23:10 tg Exp $");
d67 1
a67 1
	const char **wp, *cc;
a175 9
	/* Set FPOSIX if we're called as -sh or /bin/sh or so */
	cc = kshname;
	i = 0; argi = 0;
	while (cc[i] != '\0')
		if ((cc[i++] | 2) == '/')
			argi = i;
	if (((cc[argi] | 0x20) == 's') && ((cc[argi + 1] | 0x20) == 'h'))
		change_flag(FPOSIX, OF_FIRSTTIME, 1);

@


1.89
log
@get rid of u_char, u_int, u_long
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.88 2007/10/25 15:19:16 tg Exp $");
a37 4
	NULL
};

static const char *initcoms_korn[] = {
a155 9
	/* Set FPOSIX if we're called as -sh or /bin/sh or so */
	cc = kshname;
	i = 0; argi = 0;
	while (cc[i] != '\0')
		if ((cc[i++] | 2) == '/')
			argi = i;
	if (((cc[argi] | 0x20) == 's') && ((cc[argi + 1] | 0x20) == 'h'))
		Flag(FPOSIX) = 1;

d176 9
a254 7
	if (!Flag(FPOSIX))
		for (wp = initcoms_korn; *wp != NULL; wp++) {
			shcomexec(wp);
			while (*wp != NULL)
				wp++;
		}

@


1.88
log
@optimise (struct padding, function→macro, etc.)
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.87 2007/08/19 22:06:26 tg Exp $");
d224 2
a225 1
	change_random(((u_long)kshname) ^ ((u_long)time(NULL) * kshpid * ppid));
@


1.87
log
@new builtin “rename” (this name sounds better than “mksh_mv_rescue” ☻)
to just call rename(2) directly, e.g. if /bin/mv needs /lib/ld-uClibc.so.0

some assorted code cleanup
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.86 2007/08/13 19:39:19 tg Exp $");
a715 1

d717 1
a717 1
		if (tp->pid == procpid) {
a718 1
		}
a1269 6
ktdelete(struct tbl *p)
{
	p->flag = 0;
}

void
@


1.86
log
@Implement the “source” command, as requested by some and agreed bsiegert@@
In contrast to AT&T ksh93, its semantics are like GNU bash in that it ap-
pends the current working directory to the search path; it is implemented
as a shell alias instead of enhancing funcs.c:shbuiltins[] like in ksh93.
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.85 2007/08/12 13:42:21 tg Exp $");
d128 2
a129 4
	for (i = 0; shbuiltins[i].name != NULL; i++)
		builtin(shbuiltins[i].name, shbuiltins[i].func);
	for (i = 0; kshbuiltins[i].name != NULL; i++)
		builtin(kshbuiltins[i].name, kshbuiltins[i].func);
@


1.85
log
@add “set -o arc4random”, RTFM for details
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.84 2007/07/22 13:34:51 tg Exp $");
d52 1
@


1.84
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.83 2007/07/17 13:56:51 tg Exp $");
d225 3
a227 2
#if !HAVE_ARC4RANDOM
	srand(((long)kshname) ^ ((long)time(NULL) * kshpid * ppid));
@


1.83
log
@• make the "if called as sh, set FPOSIX" not !SMALL-only
• bump to R30-gamma, feature freeze
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.82 2007/07/01 21:10:29 tg Exp $");
d487 1
a487 1
					shellf(newline);
@


1.82
log
@Borland C++ found these
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.81 2007/07/01 19:04:53 tg Exp $");
d66 1
a66 2
	int i;
	int argi;
d70 1
a70 1
	const char **wp;
a78 3
#if !defined(MKSH_SMALL) || HAVE_SETLOCALE_CTYPE
	const char *cc;
#endif
d161 1
a161 1
#ifndef MKSH_SMALL
d163 1
a163 3
	if (*cc == '-')
		++cc;
	i = 0;
d165 3
a167 7
		if (cc[i] == '/') {
			cc += i + 1;
			i = 0;
		} else
			++i;
	if ((cc[0] == 's' || cc[0] == 'S') &&
	    (cc[1] == 'h' || cc[1] == 'H'))
a168 1
#endif
@


1.81
log
@coerce this into running on UWIN - or rather sort of. Ugly.
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.80 2007/06/17 00:50:07 tg Exp $");
a1026 1
		fd = name[0] - '0';
@


1.80
log
@make sure that “integer” and “local” are defined even in FPOSIX mode, which
is a compromise anyway; these lunox people will have to live with that, too
many existing korn shell alike scripts depend on it even if not on the full
korn shell syntax availability (note: this doesn't mean using these in some
script with #!/bin/sh is ok)
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.79 2007/06/16 15:02:56 tg Exp $");
d749 5
@


1.79
log
@we can do all that
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.78 2007/06/15 21:55:19 tg Exp $");
d37 1
a42 1
	 /* Standard ksh aliases */
a49 1
	"integer=typeset -i",
a50 1
	"local=typeset",
a51 1
	 /* Aliases that are builtin commands in at&t */
@


1.78
log
@• check.t: add some FPOSIX regression tests (1 still fails)
• all: remove vi editing mode #if defined(MKSH_SMALL) || defined(MKSH_NOVI)
  saves 12608 byts on i386
• check.t: add $0 quoting
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2006/04/10 14:38:59 jaredy Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.77 2007/06/15 20:52:19 tg Exp $");
@


1.77
log
@implement that if we run in FPOSIX mode we don't set up the standard
Korn aliases
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.76 2007/06/06 23:28:16 tg Exp $");
d83 1
a83 1
#if HAVE_SETLOCALE_CTYPE
d168 16
d200 1
d202 1
@


1.76
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.75 2007/05/13 17:51:22 tg Exp $");
d37 4
a225 1
	/* execute initialisation statements */
d228 2
a229 2
		for (; *wp != NULL; wp++)
			;
d254 7
@


1.75
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.74 2007/04/15 10:45:59 tg Exp $");
d939 1
a939 1
int
d942 1
a942 1
	int nfd;
d944 5
a948 10
	if (fd < FDBASE) {
		nfd = fcntl(fd, F_DUPFD, FDBASE);
		if (nfd < 0) {
			if (errno == EBADF)
				return -1;
			else
				errorf("too many files open in shell");
		}
	} else
		nfd = fd;
d950 1
a950 1
	return nfd;
@


1.74
log
@ignore the UTF-8 Byte Order Mark at the beginning of the input (via a file
given to execute, standard input (interactive or not), via -c command line
argument, or after “eval”, but not for $(…) comsubs, at the beginning of a
subsequent line, or within a line, etc.); regression test for it

idea during my “week off” (despite the pain), bsiegert@@ thinks it's good –
and utf-8 capable tools ought to be able to do this anyway
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.73 2007/03/04 03:04:26 tg Exp $");
d417 1
a417 1
			internal_errorf(1, "include: %d", i);
d501 1
a501 1
			internal_errorf(1, "shell: %d", i);
d828 11
d840 12
a851 1
internal_errorf(int jump, const char *fmt, ...)
a854 2
	error_prefix(true);
	shf_fprintf(shl_out, "internal error: ");
d856 1
a856 1
	shf_vfprintf(shl_out, fmt, va);
a857 4
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
	if (jump)
		unwind(LERROR);
d896 1
a896 1
		internal_errorf(1, "shl_stdout not valid");
@


1.74.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.74 2007/04/15 10:45:59 tg Exp $");
d417 1
a417 1
			internal_errorf("include: %d", i);
d501 1
a501 1
			internal_errorf("shell: %d", i);
a827 11
static void internal_verrorf(const char *, va_list)
    __attribute__((format (printf, 1, 0)));
static void
internal_verrorf(const char *fmt, va_list ap)
{
	shf_fprintf(shl_out, "internal error: ");
	shf_vfprintf(shl_out, fmt, ap);
	shf_putchar('\n', shl_out);
	shf_flush(shl_out);
}

d829 1
a829 1
internal_errorf(const char *fmt, ...)
d833 2
d836 1
a836 12
	internal_verrorf(fmt, va);
	va_end(va);
	unwind(LERROR);
}

void
internal_warningf(const char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
	internal_verrorf(fmt, va);
d838 4
d880 1
a880 1
		internal_errorf("shl_stdout not valid");
@


1.74.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.74.2.1 2007/05/13 19:29:37 tg Exp $");
d1002 1
@


1.73
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.72 2007/03/04 00:13:16 tg Exp $");
d460 2
@


1.72
log
@merge the const branch +- a few
@
text
@d16 1
a16 1
__RCSID("$MirOS$");
d295 1
a295 1
		    (strcasestr((x), "UTF-8") || strcasestr((x), "utf8")))
@


1.71
log
@mirtoconf the checks if to use persistent history support
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.70 2007/02/13 13:36:18 tg Exp $");
d63 1
a63 1
main(int argc, char *argv[])
d70 1
a70 1
	char **wp;
d85 3
a87 2
		static char empty_argv0[] = "mksh",
		    *empty_argv[] = { empty_argv0, NULL };
d184 1
a184 1
		for (wp = environ; *wp != NULL; wp++)
d223 1
a223 1
	for (wp = (char **)initcoms; *wp != NULL; wp++) {
d316 1
a316 1
	l->argv[0] = (char *)kshname;
d350 1
a350 1
		static const char *const restr_com[] = {
d355 1
a355 1
		shcomexec((char **)restr_com);
d373 1
a373 1
include(const char *name, int argc, char **argv, int intr_ok)
d377 1
a377 1
	char **volatile old_argv;
d979 1
a979 1
check_fd(char *name, int mode, const char **emsgp)
@


1.70
log
@add a note about the default $PATH
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.69 2007/02/10 21:59:15 tg Exp $");
d618 1
a618 1
#ifdef V_HISTFILE
@


1.69
log
@add new #ifdef MKSH_ASSUME_UTF8 which saves us from needing to
call setlocale() if we know the result will always be UTF-8
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.68 2007/01/15 00:18:47 tg Exp $");
d145 8
@


1.68
log
@ok, -rHEAD shall be unbroken
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.67 2007/01/12 10:18:21 tg Exp $");
d283 1
d298 3
@


1.67
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.66 2007/01/12 02:06:34 tg Exp $");
d85 2
a86 3
		static const char *empty_argv[] = {
			"mksh", NULL
		};
@


1.67.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.71 2007/03/03 21:36:07 tg Exp $");
d85 3
a87 2
		static char empty_argv0[] = "mksh",
		    *empty_argv[] = { empty_argv0, NULL };
a145 8
		/*
		 * this is uniform across all OSes unless it
		 * breaks somewhere; don't try to optimise,
		 * e.g. add stuff for Interix or remove /usr
		 * for HURD, because e.g. Debian GNU/HURD is
		 * "keeping a regular /usr"; this is supposed
		 * to be a sane 'basic' default PATH
		 */
a283 1
#ifndef MKSH_ASSUME_UTF8
a297 3
#else
		Flag(FUTFHACK) = 1;
#endif
d607 1
a607 1
#if HAVE_PERSISTENT_HISTORY
@


1.67.2.2
log
@something in the merge didn't work out
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.67.2.1 2007/03/03 21:37:56 tg Exp $");
d85 2
a86 3
		static const char *empty_argv[] = {
			"mksh", NULL
		};
@


1.67.2.3
log
@more constification
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.67.2.2 2007/03/03 21:43:50 tg Exp $");
d63 1
a63 1
main(int argc, const char *argv[])
d70 1
a70 1
	const char **wp;
d184 1
a184 1
		for (wp = (const char **)environ; *wp != NULL; wp++)
d223 1
a223 1
	for (wp = initcoms; *wp != NULL; wp++) {
d373 1
a373 1
include(const char *name, int argc, const char **argv, int intr_ok)
d377 1
a377 1
	const char **volatile old_argv;
d979 1
a979 1
check_fd(const char *name, int mode, const char **emsgp)
@


1.67.2.4
log
@more constification
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.67.2.3 2007/03/03 23:38:37 tg Exp $");
d316 1
a316 1
	l->argv[0] = kshname;
d355 1
a355 1
		shcomexec(restr_com);
@


1.67.2.5
log
@finish constification for now, passes regression tests but untested
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.67.2.4 2007/03/03 23:45:14 tg Exp $");
d350 1
a350 1
		static const char *restr_com[] = {
@


1.66
log
@* histrap.c: picky /a1/sw/pkgs/gcc-3.4.3/bin/../lib/gcc/sparc-sun-solaris2.8/3.4.3/
* main.c: thinko
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.65 2007/01/11 00:32:31 tg Exp $");
d85 3
a87 2
		static char empty_argv0[] = "mksh",
		    *empty_argv[] = { empty_argv0, NULL };
d94 1
a94 1
	ainit(&aperm);		/* initialize permanent Area */
d278 1
a278 1
	/* initialize job control */
d282 1
a282 1
	/* Do this after j_init(), as tty_fd is not initialized 'til then */
d695 1
a695 1
/* Initialize tty_fd.  Used for saving/reseting tty modes upon
@


1.65
log
@expand ~foo to getpwnam("foo")->dir only #if !defined(MKSH_SMALL)
this makes it possible to build a (small) mksh on glibc systems statically
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.64 2007/01/06 17:08:14 tg Exp $");
d140 3
a142 4
	if ((len = confstr(_CS_PATH, NULL, 0)) != (size_t)-1 &&
	    len > 0 && confstr(_CS_PATH, new = alloc(len + 1, APERM),
	    len + 1) == len + 1)
		def_path = new;
@


1.64
log
@* main.c: prevent segmentation faults on inferiour operating systems
  such as Debian GNU/Linux "etch" 4.0 with not installed locale file
  corresponding to the current environmental settings. ばかたち!
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.63 2007/01/03 22:43:47 tg Exp $");
d120 1
d122 1
@


1.63
log
@* main.c: when doing the conversion from strcasecmp (wrongly used)
  to strcasestr, it was used in a wrong way (reverse logic error in
  checking its return value), turning to mis-detection of UTF-8 locale.
* sh.h, check.t: bump version
* copyright: bump year
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.62 2006/11/16 13:35:07 tg Exp $");
d283 2
d289 1
a289 1
			if (!strcasestr(cc, "UTF-8") && !strcasestr(cc, "utf8"))
d292 1
a292 2
			Flag(FUTFHACK) = strcasestr(cc, "UTF-8") ||
			    strcasestr(cc, "utf8");
d294 1
@


1.62
log
@support systems without setresugid
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.61 2006/11/12 14:58:15 tg Exp $");
d287 1
a287 1
			if (strcasestr(cc, "UTF-8") && strcasestr(cc, "utf8"))
d290 2
a291 2
			Flag(FUTFHACK) = !(strcasestr(cc, "UTF-8") &&
			    strcasestr(cc, "utf8"));
@


1.61
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.60 2006/11/12 10:44:41 tg Exp $");
d20 5
d228 1
d230 4
@


1.60
log
@only auto-enable set -o utf8-hack (set -U) for interactive shells
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.59 2006/11/10 06:53:26 tg Exp $");
d80 2
a81 3
		static const char *empty_argv[] = {
			"mksh", NULL
		};
d83 1
a83 1
		argv = (char **)empty_argv;
d1241 2
a1242 2
	const struct tbl *a = *((const struct tbl **)p1);
	const struct tbl *b = *((const struct tbl **)p2);
@


1.59
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.58 2006/11/10 06:31:47 tg Exp $");
a149 12

#if HAVE_SETLOCALE_CTYPE
	/* Check if we're in an UTF-8 locale */
	cc = setlocale(LC_CTYPE, "");
#if HAVE_LANGINFO_CODESET
	if (strcasestr(cc, "UTF-8") && strcasestr(cc, "utf8"))
		cc = nl_langinfo(CODESET);
#endif
	if (!strcasestr(cc, "UTF-8") || !strcasestr(cc, "utf8"))
		Flag(FUTFHACK) = 1;
#endif

d272 13
a284 1
	if (Flag(FTALKING))
d286 1
@


1.58
log
@use strcasestr not strcasecmp, oops
costs 55t 4d 1i
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.57 2006/11/10 06:27:09 tg Exp $");
d957 1
a957 1
	if (isdigit((unsigned char)name[0]) && !name[1]) {
@


1.57
log
@use setresuid(2) and friends instead, saves 88t 4d 1i
XXX revisit this if we encounter systems without at least
XXX one of setresuid, setresgid, setgroups - only tested on BSD
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.56 2006/11/10 05:27:43 tg Exp $");
d155 1
a155 1
	if (strcasecmp(cc, "UTF-8") && strcasecmp(cc, "utf8"))
d158 1
a158 1
	if (!strcasecmp(cc, "UTF-8") || !strcasecmp(cc, "utf8"))
@


1.56
log
@skip on cesu-8, we think nl_langinfo(CODESET) at least will
always return utf-8 for it (on wchar_t=16bit systems); 68t
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.55 2006/11/10 05:23:12 tg Exp $");
d227 1
a227 6
	ksheuid = geteuid();
	kshuid = getuid();
	kshegid = getegid();
	kshgid = getgid();

	safe_prompt = ksheuid ? "$ " : "# ";
d236 1
a236 1
	Flag(FPRIVILEGED) = kshuid != ksheuid || kshgid != kshegid;
@


1.55
log
@if MKSH_SMALL, disable persistent history code as well (like on Solaris,
where it can't work anyway), and fix that code to shrink
saves 2071t 20d 5i
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.54 2006/11/10 03:23:49 tg Exp $");
d155 1
a155 2
	if (strcasecmp(cc, "UTF-8") && strcasecmp(cc, "utf8") &&
	    strcasecmp(cc, "CESU-8") && strcasecmp(cc, "cesu8"))
d158 1
a158 2
	if (!strcasecmp(cc, "UTF-8") || !strcasecmp(cc, "utf8") ||
	    !strcasecmp(cc, "CESU-8") || !strcasecmp(cc, "cesu8"))
@


1.54
log
@use qsort(3) instead of rolling our own
saves 284 in .text, no added import since we already use qsort(3) once
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.53 2006/11/10 01:13:51 tg Exp $");
d600 1
d603 1
@


1.53
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.52 2006/11/09 22:08:07 tg Exp $");
d1101 1
a1101 1
static int tnamecmp(void *, void *);
d1244 1
a1244 1
tnamecmp(void *p1, void *p2)
d1246 4
a1249 1
	return strcmp(((struct tbl *)p1)->name, ((struct tbl *)p2)->name);
d1255 1
a1255 1
	int i;
d1261 1
a1261 1
	for (i = 0; i < tp->size; i++)
d1265 1
a1265 2
	i = dp - p;
	qsortp((void **)p, (size_t)i, tnamecmp);
@


1.52
log
@simplify getconf and confstr stuff
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.51 2006/11/08 23:45:47 tg Exp $");
d761 1
a761 1
warningf(int fileline, const char *fmt, ...)
d823 1
a823 1
error_prefix(int fileline)
@


1.51
log
@implement autoconf tests for langstuff; sync date
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.50 2006/11/05 12:11:14 tg Exp $");
d70 4
d130 1
d132 1
d134 7
a140 9
	{
		size_t len;
		char *new;

		if ((len = confstr(_CS_PATH, NULL, 0)) > 0) {
			confstr(_CS_PATH, new = alloc(len + 1, APERM), len + 1);
			def_path = new;
		}
	}
@


1.50
log
@add new "set -o utf8-hack", currently no effect
set automatically on startup if we have locale functions (on MirOS)
@
text
@d9 1
a9 1
#if (HAVE_LANGSTUFF - 0)
d11 2
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.49 2006/09/30 02:13:21 tg Exp $");
d70 1
a70 1
#if (HAVE_LANGSTUFF - 0)
d147 1
a147 1
#if (HAVE_LANGSTUFF - 0)
d150 1
a150 1
#ifdef CODESET
@


1.49
log
@* avoid unaligned memory access causing SIGBUS on IA-64 (Itanic)
  (incidentally, the information xor'd now is more random)
  only affects non-arc4random targets
* bump version
@
text
@d9 6
a14 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.48 2006/08/24 20:32:53 tg Exp $");
d68 3
d145 13
@


1.48
log
@merge non-Plan9-specific stuff from the branch, add KNF, etc.
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.47 2006/08/22 22:49:35 tg Exp $");
d191 1
a191 1
	srand((*((long *)kshname)) ^ ((long)time(NULL) * kshpid * ppid));
@


1.47
log
@* remove redundancy
* integrate compat.h, version.h into sh.h (dependency trick didn't work anyway)
* mention #ksh in mksh(1) since the founder (twkm) said it's on topic too
  (don't remove mention of #mksh despite it's usually empty because of control)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.46 2006/08/18 18:48:25 tg Exp $");
d117 1
a117 1
#if !defined(__CYGWIN__)
@


1.46
log
@restrict RANDOM to a positive 31-bit integer number, for use with modulo op
@
text
@d6 1
a6 1
#define	EXTERN				/* define EXTERNs in sh.h */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.44 2006/08/01 13:43:27 tg Exp $");
d14 1
a14 1
static void remove_temps(struct temp * tp);
d21 1
a21 1
	"typeset", "-r", "KSH_VERSION", NULL,
a193 2
	/* setstr can't fail here */
	setstr(global("KSH_VERSION"), MKSH_VERSION, KSH_RETURN_ERROR);
@


1.45
log
@as long as we're using arc4random(3) to generate $RANDOM,
let it be an uint32_t, like nbsh(1)
@
text
@d24 1
a24 1
	"eval", "typeset -Ui RANDOM SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
@


1.44
log
@style(9)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.43 2006/08/01 12:22:26 tg Exp $");
d24 1
a24 1
	"eval", "typeset -i RANDOM SECONDS=\"${SECONDS-0}\" TMOUT=\"${TMOUT-0}\"", NULL,
@


1.44.2.1
log
@initial attempt at porting mksh to the Plan 9 ANSI'n'POSIX Environment
struck dumb at SIGWINCH/TIOCGWINSZ, we'll have to ifdef out all of the
command line editing code as a next measure

incidentally, my qemu just crashed (not the guest OS - Plan 9 - no, it
really crashed the "outside" qemu programme, won't redraw or catch the
mouse any more), so I'll call it a day
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.44 2006/08/01 13:43:27 tg Exp $");
a23 3
#ifdef __Plan9__
	"eval", "HOME=\"$home\"", NULL,
#endif
@


1.44.2.2
log
@use confstr(3) only if _CS_PATH is defined
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.44.2.1 2006/08/15 23:49:53 tg Exp $");
d120 1
a120 1
#ifdef _CS_PATH
@


1.44.2.3
log
@don't emacs by default in Plan 9 - no editing mode works correctly,
maybe Benny can fix that, tab completing is broken even if bound to
^F (binding to tab won't work anyway)
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.44.2.2 2006/08/24 19:18:21 tg Exp $");
a151 1
#ifndef __Plan9__
a156 1
#endif
@


1.44.2.4
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d6 1
a6 1
#define	EXTERN
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.48 2006/08/24 20:32:53 tg Exp $");
d14 1
a14 1
static void remove_temps(struct temp *);
d21 1
a21 1
	"typeset", "-r", initvsn, NULL,
d199 2
@


1.44.2.5
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.43
log
@move version definition into extra file
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.42 2006/07/23 14:35:44 tg Exp $");
d1164 1
a1164 1
Search:
@


1.42
log
@dates
@
text
@d9 1
a9 3
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.41 2006/07/11 14:51:01 tg Exp $");

#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/07/23"
@


1.41
log
@* TNF needs more to silence char subscript warnings (on 3.0-stable)
* bump vsn
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.40 2006/07/03 12:16:30 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/07/11"
@


1.40
log
@fix the "char subscripts" issue, bump version
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.39 2006/06/21 19:27:35 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/07/03"
@


1.39
log
@* process ~/.mksrc only if FTALKING (i.e. interactive shell)
  From: hondza <miscreant@@tiscali.cz>
* document that in the manual page myself
* add regression test for that myself
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.38 2006/05/26 23:36:19 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/06/21"
d939 1
a939 1
	if (isdigit(name[0]) && !name[1]) {
@


1.38
log
@this is mksh R27, tested on
* MirOS HEAD (i386, gcc 3.4)
* Debian GNU/Linux 3.1 (i386, gcc 3.3)
* Interix 3.5 (i386, gcc 3.3) - perl too old for regression tests
* GNU/Cygwin 2006-03-* (i386, gcc 3.4) - no perl installed
* Solaris 8 (sparc64, gcc 3.4)

no testing been done on
* Mac
* other BSDs
* gcc 4.1.1
* Solaris 10
because I asked for community feedback but...
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.37 2006/05/10 19:30:33 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/05/26"
d297 1
a297 1
	else {
@


1.37
log
@* this is almost mksh R27, bump
* add the O'Reilly books as references
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.36 2006/05/10 18:54:11 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R27 2006/05/10"
@


1.36
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.35 2006/05/08 11:42:36 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R26 2006/05/08"
@


1.35
log
@New feature: read ~/.mkshrc during startup, after the profiles
have been read, for non-priviledgued shells only. If $ENV is
set, ~/.mkshrc is ignored (even if the file pointed to by $ENV
does not exist in the first place).
Feature requested by Jari Aalto for portable mksh because some
operating systems' vendors do not allow touching the profile.

Initial diff and manual page addition by Jari Aalto <jari.aalto@@cante.net>
Code changes and manual page correctness by me.
@
text
@d1 3
a3 3
/*	$OpenBSD: main.c,v 1.40 2005/12/11 20:31:21 otto Exp $	*/
/*	$OpenBSD: tty.c,v 1.8 2005/03/30 17:16:37 deraadt Exp $	*/
/*	$OpenBSD: io.c,v 1.21 2005/03/30 17:16:37 deraadt Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.34 2006/01/30 12:37:23 tg Exp $");
d679 3
a681 6
		if (tfd < 0) {
			tty_devtty = 0;
			warningf(false,
			    "No controlling tty (open /dev/tty: %s)",
			    strerror(errno));
		}
d878 1
a878 1
savefd(int fd, int noclose)
a889 2
		if (!noclose)
			close(fd);
d912 3
a914 1
	if (pipe(pv) < 0)
d916 6
a921 2
	pv[0] = savefd(pv[0], 0);
	pv[1] = savefd(pv[1], 0);
@


1.34
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.33 2006/01/29 20:56:55 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R26 2006/01/29"
d301 2
a302 1
		env_file = substitute(str_val(global("ENV")), DOTILDE);
@


1.33
log
@this can be released as mksh-R26c, works on Solaris, Interix (whose Perl
is too old for the testsuite), Debian and of course MirOS
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.32 2006/01/29 20:04:52 tg Exp $");
d484 1
a484 1
				/* this for POSIX, which says EXIT traps
@


1.32
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.31 2005/11/22 18:40:43 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R26 2005/11/22"
@


1.31
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2005/03/30 17:16:37 deraadt Exp $	*/
d4 1
a4 1
/*	$OpenBSD: table.c,v 1.11 2005/03/30 17:16:37 deraadt Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.30 2005/10/25 21:11:26 tg Exp $");
d102 3
a104 3
	tinit(&taliases, APERM, 0);
	tinit(&aliases, APERM, 0);
	tinit(&homedirs, APERM, 0);
d110 1
a110 1
	tinit(&builtins, APERM, 64); /* must be 2^n (currently 40 builtins) */
a661 8
void
aerror(Area *ap __attribute__((unused)), const char *msg)
{
	internal_errorf(1, "alloc: %s", msg);
	errorf(null); /* this is never executed - keeps gcc quiet */
	/*NOTREACHED*/
}

d1089 1
a1089 1
tinit(struct table *tp, Area *ap, int tsize)
d1134 1
a1134 1
tsearch(struct table *tp, const char *n, unsigned int h)
d1157 1
a1157 1
tenter(struct table *tp, const char *n, unsigned int h)
d1195 1
a1195 1
tdelete(struct tbl *p)
d1201 1
a1201 1
twalk(struct tstate *ts, struct table *tp)
d1208 1
a1208 1
tnext(struct tstate *ts)
d1225 1
a1225 1
tsort(struct table *tp)
@


1.30
log
@bump to mksh R25
@
text
@a0 1
/**	$MirOS: src/bin/mksh/main.c,v 1.29 2005/10/25 19:53:28 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.29 2005/10/25 19:53:28 tg Exp $");
d11 1
a11 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R25 2005/10/25"
@


1.29
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.28 2005/10/21 12:41:55 tg Exp $ */
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.28 2005/10/21 12:41:55 tg Exp $");
d12 1
a12 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R24 2005/10/21"
@


1.28
log
@follow OpenBSD and add mknod as mksh builtin (mknod <file> p acts as mkfifo)
but write a good chunk of that code myself (better structured, better error
handling, more gotos, less function calls, int -> bool)

passes all tests on mirbsd; this will become mksh R25 once tested on other
supported OSes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.27 2005/10/08 18:53:10 tg Exp $ */
a8 6
#include <sys/stat.h>
#include <ctype.h>
#include <pwd.h>
#if !HAVE_ARC4RANDOM
#include <time.h>
#endif
d10 1
a10 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.27 2005/10/08 18:53:10 tg Exp $");
@


1.27
log
@* bump version
* disable DEBUGPROGS
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.26 2005/09/11 00:32:30 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.26 2005/09/11 00:32:30 tg Exp $");
d18 1
a18 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R24 2005/10/08"
@


1.26
log
@revert to R24b since we don't printf ATM
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.24 2005/08/21 13:02:17 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.24 2005/08/21 13:02:17 tg Exp $");
d18 1
a18 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R24 2005/08/21"
@


1.25
log
@* add printf(1) as mksh(1) builtin on MirOS
  (or, more general, all systems using Makefile
  instead of Build.sh)
* document this fact
@
text
@d18 1
a18 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R25 2005/08/26 pre"
@


1.24
log
@* make 64-bit clean on GNU/Linux by default
* clean up and remove some .Xr from the man page
* bump version
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.23 2005/08/02 12:35:26 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.23 2005/08/02 12:35:26 tg Exp $");
d18 1
a18 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R24 2005/08/21"
@


1.23
log
@^V now is quote, not version, even in emacs mode. (From OpenBSD.)
Also, the "version" command got removed in its entirety.
Shaves off another global variable, even.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.22 2005/07/07 22:00:45 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.22 2005/07/07 22:00:45 tg Exp $");
d18 1
a18 1
#define	MKSH_VERSION	"@@(#)MIRBSD KSH R24 2005/08/02"
@


1.22
log
@undo fix for Debian PR #71256 which turned to be bogus and break make(1)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.21 2005/07/06 00:02:06 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.21 2005/07/06 00:02:06 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R24 2005/07/07";
d204 1
a204 1
	setstr(global("KSH_VERSION"), ksh_version, KSH_RETURN_ERROR);
@


1.21
log
@remove Korn's bizarre /dev/fd hack
(only affects Interix!)

Tests on /dev/fd are now officially unsupported in mksh too.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.20 2005/07/04 12:47:13 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.20 2005/07/04 12:47:13 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R24 2005/07/06";
@


1.20
log
@clean up code
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.19 2005/07/04 12:34:23 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.19 2005/07/04 12:34:23 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R24 2005/07/04";
@


1.19
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.18 2005/07/04 12:27:26 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.18 2005/07/04 12:27:26 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R23 2005/07/04";
d70 2
d141 3
a143 5
	{
		struct tbl *vp = global("PATH");
		/* setstr can't fail here */
		setstr(vp, def_path, KSH_RETURN_ERROR);
	}
d153 1
a153 1
	/* Turn on brace expansion by default.  At&t kshs that have
d219 6
a224 11
	{
		struct tbl *vp = global("PS1");

		/* Set PS1 if it isn't set, or we are root and prompt doesn't
		 * contain a #.
		 */
		if (!(vp->flag & ISSET) ||
		    (!ksheuid && !strchr(str_val(vp), '#')))
			/* setstr can't fail here */
			setstr(vp, safe_prompt, KSH_RETURN_ERROR);
	}
d266 3
a268 7
	{
		struct stat s_stdin;

		if (fstat(0, &s_stdin) >= 0 && S_ISCHR(s_stdin.st_mode) &&
		    Flag(FTALKING))
			reset_nonblock(0);
	}
@


1.18
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.17 2005/07/04 11:57:55 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.17 2005/07/04 11:57:55 tg Exp $");
d32 1
a32 2
	"typeset", "-i", "PGRP=0", "PPID", NULL,
	"typeset", "-i", "OPTIND=1", NULL,
a157 5
	/* Check to see if we're /bin/sh. */
	if (!strcmp(&kshname[strlen(kshname) - 3], "/sh") ||
	    !strcmp(kshname, "sh") || !strcmp(kshname, "-sh"))
		Flag(FSH) = 1;

d204 1
a204 2
	if (!Flag(FSH))
		setstr(global("KSH_VERSION"), ksh_version, KSH_RETURN_ERROR);
@


1.17
log
@mksh no longer looks at its own called name or $SHELL
to determine if it should be a restricted shell
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.16 2005/06/24 15:42:03 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.16 2005/06/24 15:42:03 tg Exp $");
d155 1
a155 3
	 * alternation always have it on.  BUT, posix doesn't have
	 * brace expansion, so set this before setting up FPOSIX
	 * (change_flag() clears FBRACEEXPAND when FPOSIX is set).
d808 1
a808 2
	if ((builtin_flag & SPEC_BI) ||
	    (Flag(FPOSIX) && (builtin_flag & KEEPASN))) {
@


1.16
log
@date of today
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.15 2005/06/24 15:36:57 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.15 2005/06/24 15:36:57 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R23 2005/06/24";
a23 1
static int is_restricted(char *name);
a330 2
	if (is_restricted(argv[0]) || is_restricted(str_val(global("SHELL"))))
		restricted = 1;
a686 12
/* Returns true if name refers to a restricted shell */
static int
is_restricted(char *name)
{
	char *p;

	if ((p = strrchr(name, '/')))
		name = p;
	/* accepts rsh, rksh, rmksh, rpdksh, pdrksh, etc. */
	return (p = strchr(name, 'r')) && strstr(p, "sh");
}

@


1.15
log
@first step for GNU/Cygwin support
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.14 2005/06/08 22:35:45 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.14 2005/06/08 22:35:45 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R23 2005/06/08";
@


1.14
log
@miRbsdkSH is now a restricted shell again, because this
shell is the mksh
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.13 2005/06/08 22:34:03 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.13 2005/06/08 22:34:03 tg Exp $");
d126 1
d136 1
@


1.13
log
@some lint cleanup
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.12 2005/06/08 22:22:24 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.12 2005/06/08 22:22:24 tg Exp $");
d697 1
a697 2
	return (p = strchr(name, 'r')) && strstr(p, "sh") &&
	    !strstr(p-2, "mirbsdksh") && !strstr(p-2, "mirosksh");
@


1.12
log
@run a bit of indent over it
not really suitable tho
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.11 2005/06/08 21:51:21 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.11 2005/06/08 21:51:21 tg Exp $");
d393 1
a393 1
			/* fall through... */
d398 1
a398 1
			/*NOREACHED*/
d401 1
a401 1
			/*NOREACHED*/
d471 1
a471 1
			/* fall through... */
d478 1
a478 1
			/*NOREACHED*/
d483 1
a483 1
			/*NOREACHED*/
d554 1
a554 2
			/*NOTREACHED*/

d558 1
a558 2
			/* Fall through... */

@


1.11
log
@* major revamp of build system
* whitespace cleanup; junk comment removal
* syndicate debian/copyright file from my port (shrinks sh.h)
* bump to R23
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.10 2005/06/05 16:38:20 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.10 2005/06/05 16:38:20 tg Exp $");
d22 3
a24 3
static void	reclaim(void);
static void	remove_temps(struct temp *tp);
static int	is_restricted(char *name);
d30 1
a30 1
static const char *initcoms [] = {
d38 11
a48 11
	  "hash=alias -t",	/* not "alias -t --": hash -r needs to work */
	  "type=whence -v",
	  "stop=kill -STOP",
	  "suspend=kill -STOP $$",
	  "autoload=typeset -fu",
	  "functions=typeset -f",
	  "history=fc -l",
	  "integer=typeset -i",
	  "nohup=nohup ",
	  "local=typeset",
	  "r=fc -e -",
d50 2
a51 2
	  "login=exec login",
	  NULL,
d54 2
a55 2
	  "cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
	  "make", "mv", "pr", "rm", "sed", "sh", "vi", "who", NULL,
d79 1
a79 1
		argv = (char **) empty_argv;
d174 1
a174 1
			typeset(*wp, IMPORT|EXPORT, 0, 0, 0);
d209 1
a209 1
	setint(global("PPID"), (long) ppid);
d215 1
a215 1
	for (wp = (char**) initcoms; *wp != NULL; wp++) {
d257 2
a258 1
		s->u.shf = shf_open(s->file, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
d298 1
a298 1
	l->argv[0] = (char *) kshname;
a318 1

d338 1
a338 1
		shcomexec((char **) restr_com);
d364 1
a364 1
	shf = shf_open(name, O_RDONLY, 0, SHF_MAPHI|SHF_CLEXEC);
d434 1
a434 1
shell(Source *volatile s, volatile int toplevel)
a485 1

a495 1

a499 1

a519 1

d596 1
a596 1
		if (ep->savefd[2]) /* Clear any write errors */
a598 1

d618 1
a618 1
					    SS_RESTORE_CURR|SS_FORCE);
d717 2
a718 2
	int	do_close = 1;
	int	tfd;
a733 1

d902 1
a902 1
struct shf	shf_iob[3];
d1110 1
a1110 1
	tp->name = pathname = (char *) &tp[1];
d1125 2
a1126 2
static void	texpand(struct table *, int);
static int	tnamecmp(void *, void *);
d1156 1
a1156 1
	ntblp = (struct tbl**) alloc(sizeofN(struct tbl *, nsize), tp->areap);
d1160 1
a1160 1
	tp->nfree = 8*nsize/10;	/* table can get 80% full */
d1166 1
a1166 1
			if ((tblp->flag&DEFINED)) {
d1168 2
a1169 2
				    (tp->size-1)]; *p != NULL; p--)
					if (p == ntblp) /* wrap */
d1174 1
a1174 1
				afree((void*)tblp, tp->areap);
d1177 1
a1177 1
	afree((void*)otblp, tp->areap);
d1192 1
a1192 1
	for (pp = &tp->tbls[h & (tp->size-1)]; (p = *pp) != NULL; pp--) {
d1194 1
a1194 1
		    (p->flag&DEFINED))
d1196 1
a1196 1
		if (pp == tp->tbls) /* wrap */
d1214 1
a1214 1
  Search:
d1216 1
a1216 1
	for (pp = &tp->tbls[h & (tp->size-1)]; (p = *pp) != NULL; pp--) {
d1219 1
a1219 1
		if (pp == tp->tbls) /* wrap */
d1224 1
a1224 1
		texpand(tp, 2*tp->size);
a1226 1

d1229 2
a1230 2
	p = (struct tbl *) alloc(offsetof(struct tbl, name[0]) + len,
				 tp->areap);
d1262 1
a1262 1
		if (p != NULL && (p->flag&DEFINED))
d1280 1
a1280 1
	p = (struct tbl **)alloc(sizeofN(struct tbl *, tp->size+1), ATEMP);
d1284 2
a1285 2
		if ((*dp = *sp++) != NULL && (((*dp)->flag&DEFINED) ||
		    ((*dp)->flag&ARRAY)))
d1288 1
a1288 1
	qsortp((void**)p, (size_t)i, tnamecmp);
@


1.10
log
@mksh R22d
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.9 2005/05/28 21:02:02 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.9 2005/05/28 21:02:02 tg Exp $");
d18 1
a18 1
const char ksh_version[] = "@@(#)MIRBSD KSH R22 2005/06/05";
@


1.9
log
@main.c: need <time.h> if not HAVE_ARC4RANDOM
strlfun.c: sync

found while creating debian source package

main.c, check.t: mksh R22c
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.8 2005/05/26 23:01:30 tg Exp $ */
d16 3
a18 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.8 2005/05/26 23:01:30 tg Exp $");
a25 2
const char ksh_version[] = "@@(#)MIRBSD KSH R22 2005/05/28";

@


1.8
log
@* fix logic for srand() I got reversed
* introduce HAVE_ARC4RANDOM tristate (0/1/undef) and fill it appropriately
* NetBSD(R) joins the list of OSes which don't have arc4random
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.7 2005/05/25 23:31:07 tg Exp $ */
d12 3
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.7 2005/05/25 23:31:07 tg Exp $");
d24 1
a24 1
const char ksh_version[] = "@@(#)MIRBSD KSH R22 2005/05/25";
@


1.7
log
@* fix emacs [ tabcompletion bug
  XXX it's probably a bug in vi mode too, it just doesn't show
* bring manual page and reality into closer sync'd state
* sort ulimits
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.6 2005/05/25 13:46:01 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.6 2005/05/25 13:46:01 tg Exp $");
d203 1
a203 1
#if !defined(__gnu_linux__) && !defined(__INTERIX) && !defined(__sun__)
@


1.6
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.5 2005/05/25 11:37:23 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.5 2005/05/25 11:37:23 tg Exp $");
d49 1
a49 1
	/* this is what at&t ksh seems to track, with the addition of emacs */
d52 1
a52 2
	  "mail", "make", "mv", "pr", "rm", "sed", "sh", "vi", "who",
	  NULL,
@


1.5
log
@mksh R22 (beta)
not yet released
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.4 2005/05/23 15:54:31 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.4 2005/05/23 15:54:31 tg Exp $");
d220 4
d238 1
a238 1
	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();
@


1.4
log
@now passes on Solaris (-Wall -W -Wno-char-subscripts) too
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.3 2005/05/23 15:36:55 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.3 2005/05/23 15:36:55 tg Exp $");
d21 1
a21 1
const char ksh_version[] = "@@(#)MIRBSD KSH R21 2005/05/23";
@


1.3
log
@no persistent history (flock missing), no arc4random, etc. for Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.2 2005/05/23 14:22:03 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.2 2005/05/23 14:22:03 tg Exp $");
d21 1
a21 1
const char ksh_version[] = "@@(#)MIRBSD KSH R21";
@


1.2
log
@always use rand(3) on platforms without arc4random(3) and seed it
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/main.c,v 1.1 2005/05/23 03:06:08 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/main.c,v 1.1 2005/05/23 03:06:08 tg Exp $");
d204 1
a204 1
#if !defined(__gnu_linux__) && !defined(__INTERIX)
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/main.c,v 1.12 2005/05/23 02:20:36 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: mksh/main.c,v 1.12 2005/05/23 02:20:36 tg Exp $");
d204 3
@

