head	1.829;
access;
symbols
	mksh-R57:1.812
	mksh-R56c:1.801
	mksh-R56b:1.797
	mksh-R56:1.796
	mksh-R55:1.775
	mksh-R54:1.756
	mksh-R53a:1.751
	mksh-R53:1.750
	mksh-R52c:1.728
	mksh-R52b:1.721
	mksh-R52:1.716
	mksh-R51:1.703
	mksh-R50f:1.667.2.7
	mksh-R50e:1.667.2.3
	mksh-R50stable:1.667.0.2
	mksh-R50d:1.661
	mksh-R50c:1.659
	mksh-R50b:1.658
	mksh-R50:1.654
	mksh-R49:1.640
	mksh-R48b:1.630
	mksh-R48:1.629
	mksh-R47:1.621
	mksh-R46:1.612
	mksh-R45:1.607
	mksh-R44:1.599
	mksh-R43:1.597
	mksh-R42b:1.594
	mksh-R41c:1.569.2.9
	mksh-R41b:1.569.2.8
	mksh-R42:1.593
	mksh-R41:1.569
	mksh-R41stable:1.569.0.2
	mksh-wheezy:1.549.0.2
	tg-multikey-bind:1.536.0.2
	mksh-R40f:1.474.2.15
	mksh-R40e:1.474.2.14
	mksh-R40d:1.474.2.10
	mksh-R40c:1.474.2.7
	mksh-R40b:1.474.2.2
	mksh-R40stable:1.474.0.2
	mksh-R40:1.467
	mksh-R39c:1.365
	mksh-R39b:1.359
	tg-wcswidth-behaviour:1.343.0.2
	tg-nameref:1.301.0.2
	mksh-R39:1.298
	tg-mksh-printf-builtin:1.293.0.2
	mksh-R38c:1.287
	mksh-R38b:1.282
	mksh-R38:1.281
	mksh-R37c:1.270
	mksh-R37b:1.268
	mksh-R37:1.266
	mksh-R36b:1.252
	tg-aalloc-experimental_BASE:1.243.2.1
	tg-aalloc-experimental:1.243.0.2
	mksh-R36:1.235
	mksh-R35b:1.219
	mksh-R35:1.213
	mksh-R33d:1.174
	mksh-R33c:1.173
	mksh-R33b:1.163
	MIRBSD_10:1.158.0.2
	MIRBSD_10_BASE:1.158
	mksh-R33:1.157
	mksh-R32:1.142
	mksh-R31d:1.140
	mksh-R31c:1.138
	mksh-R31b:1.138
	mksh-R31:1.136
	mksh-R30:1.131
	mksh-R29g:1.101.2.4
	mksh-R29f:1.101.2.3
	mksh-R29e:1.101.2.2
	mksh-R29stable:1.101.0.2
	mksh-R29d:1.101
	mksh-R29c:1.100
	mksh-R29b:1.93
	mksh-R29:1.92
	mksh-R28:1.64
	tg-mksh-plan9ape_BASE:1.63
	tg-mksh-plan9ape:1.56.0.2
	mksh-R27e:1.44
	MIRBSD_9_BASE:1.43
	mksh-R27d:1.43
	mksh-R27:1.42
	mksh-R26c:1.37
	mksh-R26b:1.36
	MIRBSD_8:1.36.0.2
	MIRBSD_8_BASE:1.36
	mksh-R26:1.36
	mksh-R25:1.34
	mksh-R24c:1.30
	mksh-R24b:1.28
	mksh-R24:1.26
	mksh-R23:1.17
	mksh-R22:1.16
	mksh-R21:1.10;
locks; strict;
comment	@# @;


1.829
date	2020.01.11.21.11.28;	author tg;	state Exp;
branches;
next	1.828;
commitid	1005E1A39F07C0CF4EA;

1.828
date	2020.01.03.22.04.06;	author tg;	state Exp;
branches;
next	1.827;
commitid	1005E0FB9FA362775D3;

1.827
date	2019.12.30.04.18.48;	author tg;	state Exp;
branches;
next	1.826;
commitid	1005E097AAE107DC225;

1.826
date	2019.12.30.03.45.09;	author tg;	state Exp;
branches;
next	1.825;
commitid	1005E0972CA305775E7;

1.825
date	2019.12.11.20.54.42;	author tg;	state Exp;
branches;
next	1.824;
commitid	1005DF157A04B1F229D;

1.824
date	2019.10.24.00.12.42;	author tg;	state Exp;
branches;
next	1.823;
commitid	1005DB0EC8D42D455C2;

1.823
date	2019.09.25.22.50.09;	author tg;	state Exp;
branches;
next	1.822;
commitid	1005D8BEF206C7DCA5F;

1.822
date	2019.08.02.19.27.12;	author tg;	state Exp;
branches;
next	1.821;
commitid	1005D448E820CFAF8FF;

1.821
date	2019.08.01.23.57.22;	author tg;	state Exp;
branches;
next	1.820;
commitid	1005D437C6655545E05;

1.820
date	2019.08.01.22.45.53;	author tg;	state Exp;
branches;
next	1.819;
commitid	1005D436B8A74995C84;

1.819
date	2019.08.01.20.17.27;	author tg;	state Exp;
branches;
next	1.818;
commitid	1005D4348E369CC5AE0;

1.818
date	2019.08.01.20.16.15;	author tg;	state Exp;
branches;
next	1.817;
commitid	1005D43487E0DCCC1B7;

1.817
date	2019.08.01.20.07.26;	author tg;	state Exp;
branches;
next	1.816;
commitid	1005D43467E0A766F87;

1.816
date	2019.08.01.20.03.35;	author tg;	state Exp;
branches;
next	1.815;
commitid	1005D4345A72F5604BD;

1.815
date	2019.04.26.15.52.40;	author tg;	state Exp;
branches;
next	1.814;
commitid	1005CC329596493431B;

1.814
date	2019.04.24.20.30.52;	author tg;	state Exp;
branches;
next	1.813;
commitid	1005CC0C78966A9AD9A;

1.813
date	2019.04.16.10.29.59;	author tg;	state Exp;
branches;
next	1.812;
commitid	1005CB5AEBB6641F0B2;

1.812
date	2019.03.01.16.17.29;	author tg;	state Exp;
branches;
next	1.811;
commitid	1005C795B227B7FBF72;

1.811
date	2019.01.05.12.47.38;	author tg;	state Exp;
branches;
next	1.810;
commitid	1005C30A75304FC7434;

1.810
date	2018.12.04.21.13.44;	author tg;	state Exp;
branches;
next	1.809;
commitid	1005C06EDFD15FD4F82;

1.809
date	2018.10.20.18.48.26;	author tg;	state Exp;
branches;
next	1.808;
commitid	1005BCB788E495F8B4B;

1.808
date	2018.08.10.02.53.31;	author tg;	state Exp;
branches;
next	1.807;
commitid	1005B6CFE0B5BDFE404;

1.807
date	2018.07.15.17.22.15;	author tg;	state Exp;
branches;
next	1.806;
commitid	1005B4B82DC5396F5B3;

1.806
date	2018.06.26.21.22.21;	author tg;	state Exp;
branches;
next	1.805;
commitid	1005B32AE7D3C0B22EA;

1.805
date	2018.05.08.17.37.33;	author tg;	state Exp;
branches;
next	1.804;
commitid	1005AF1E0675260363E;

1.804
date	2018.05.07.00.07.18;	author tg;	state Exp;
branches;
next	1.803;
commitid	1005AEF98C1361833B5;

1.803
date	2018.04.28.07.07.35;	author tg;	state Exp;
branches;
next	1.802;
commitid	1005AE41DB710ED1782;

1.802
date	2018.03.09.01.29.08;	author tg;	state Exp;
branches;
next	1.801;
commitid	1005AA1E36666A5C695;

1.801
date	2018.01.14.01.47.33;	author tg;	state Exp;
branches;
next	1.800;
commitid	1005A5AB6B60E91308B;

1.800
date	2017.12.15.13.35.34;	author tg;	state Exp;
branches;
next	1.799;
commitid	1005A33CFA35EC5A4FD;

1.799
date	2017.10.17.23.45.16;	author tg;	state Exp;
branches;
next	1.798;
commitid	10059E695CD2C830620;

1.798
date	2017.10.14.21.09.46;	author tg;	state Exp;
branches;
next	1.797;
commitid	10059E27D1D2A22ED17;

1.797
date	2017.08.29.13.38.29;	author tg;	state Exp;
branches;
next	1.796;
commitid	10059A56E5C5EA2D5AB;

1.796
date	2017.08.08.21.11.18;	author tg;	state Exp;
branches;
next	1.795;
commitid	100598A290E2AFE53F2;

1.795
date	2017.08.07.21.16.29;	author tg;	state Exp;
branches;
next	1.794;
commitid	1005988D8C64668C04F;

1.794
date	2017.07.26.23.02.23;	author tg;	state Exp;
branches;
next	1.793;
commitid	10059791F906168237F;

1.793
date	2017.05.14.19.05.44;	author tg;	state Exp;
branches;
next	1.792;
commitid	1005918AA8A7B123ACA;

1.792
date	2017.05.05.22.53.24;	author tg;	state Exp;
branches;
next	1.791;
commitid	100590D026845CD3DFF;

1.791
date	2017.05.05.21.17.31;	author tg;	state Exp;
branches;
next	1.790;
commitid	100590CEBF0559EFD63;

1.790
date	2017.05.05.19.43.50;	author tg;	state Exp;
branches;
next	1.789;
commitid	100590CD60A12E221FB;

1.789
date	2017.05.03.17.48.06;	author tg;	state Exp;
branches;
next	1.788;
commitid	100590A17CE405AEE2E;

1.788
date	2017.05.03.16.17.08;	author tg;	state Exp;
branches;
next	1.787;
commitid	100590A0297413F7251;

1.787
date	2017.05.01.19.44.26;	author tg;	state Exp;
branches;
next	1.786;
commitid	100590790345DC952B2;

1.786
date	2017.04.29.21.49.04;	author tg;	state Exp;
branches;
next	1.785;
commitid	10059050A1F555381AA;

1.785
date	2017.04.29.15.18.25;	author tg;	state Exp;
branches;
next	1.784;
commitid	1005904AECA3AA1265A;

1.784
date	2017.04.29.14.36.13;	author tg;	state Exp;
branches;
next	1.783;
commitid	1005904A4EC64ED4A4D;

1.783
date	2017.04.28.21.43.02;	author tg;	state Exp;
branches;
next	1.782;
commitid	1005903B77E0CD3928C;

1.782
date	2017.04.28.11.13.45;	author tg;	state Exp;
branches;
next	1.781;
commitid	100590323E86CD0E167;

1.781
date	2017.04.28.03.28.14;	author tg;	state Exp;
branches;
next	1.780;
commitid	1005902B6DC3ECE3910;

1.780
date	2017.04.28.02.24.54;	author tg;	state Exp;
branches;
next	1.779;
commitid	1005902A8007F54B819;

1.779
date	2017.04.28.00.38.25;	author tg;	state Exp;
branches;
next	1.778;
commitid	10059028F0E0808B3E9;

1.778
date	2017.04.20.20.50.09;	author tg;	state Exp;
branches;
next	1.777;
commitid	10058F91F0E764A8514;

1.777
date	2017.04.20.18.44.07;	author tg;	state Exp;
branches;
next	1.776;
commitid	10058F9018C277BE3FF;

1.776
date	2017.04.17.19.51.44;	author tg;	state Exp;
branches;
next	1.775;
commitid	10058F51CD7435931DA;

1.775
date	2017.04.12.17.38.41;	author tg;	state Exp;
branches;
next	1.774;
commitid	10058EE65E065F6F62F;

1.774
date	2017.04.11.12.34.02;	author tg;	state Exp;
branches;
next	1.773;
commitid	10058ECCD3F0D749F4C;

1.773
date	2017.04.08.01.07.12;	author tg;	state Exp;
branches;
next	1.772;
commitid	10058E837C565871E52;

1.772
date	2017.04.06.02.15.22;	author tg;	state Exp;
branches;
next	1.771;
commitid	10058E5A4CA1AB62F5D;

1.771
date	2017.04.06.01.59.51;	author tg;	state Exp;
branches;
next	1.770;
commitid	10058E5A1067AFA1BBA;

1.770
date	2017.04.06.00.41.38;	author tg;	state Exp;
branches;
next	1.769;
commitid	10058E58ECF695338FA;

1.769
date	2017.04.03.02.08.57;	author tg;	state Exp;
branches;
next	1.768;
commitid	10058E1AEC63BB0CE23;

1.768
date	2017.04.02.16.25.20;	author tg;	state Exp;
branches;
next	1.767;
commitid	10058E1260356DE82DA;

1.767
date	2017.04.02.14.14.04;	author tg;	state Exp;
branches;
next	1.766;
commitid	10058E106EA70D8ABF7;

1.766
date	2017.03.26.00.10.21;	author tg;	state Exp;
branches;
next	1.765;
commitid	10058D706207E0A1FF4;

1.765
date	2017.03.22.00.20.39;	author tg;	state Exp;
branches;
next	1.764;
commitid	10058D1C35C5D0C4C46;

1.764
date	2017.03.19.22.31.24;	author tg;	state Exp;
branches;
next	1.763;
commitid	10058CF06C37397F386;

1.763
date	2017.03.19.20.59.23;	author tg;	state Exp;
branches;
next	1.762;
commitid	10058CEF1322163CCA4;

1.762
date	2017.03.19.20.36.04;	author tg;	state Exp;
branches;
next	1.761;
commitid	10058CEEBC01764DE9F;

1.761
date	2017.03.19.18.05.25;	author tg;	state Exp;
branches;
next	1.760;
commitid	10058CEC80C3DBAE4A3;

1.760
date	2017.03.17.22.45.48;	author tg;	state Exp;
branches;
next	1.759;
commitid	10058CC671F1DF58730;

1.759
date	2017.03.12.02.35.32;	author tg;	state Exp;
branches;
next	1.758;
commitid	10058C4B40930FBD6E0;

1.758
date	2017.02.18.02.33.09;	author tg;	state Exp;
branches;
next	1.757;
commitid	10058A7B271530B4CED;

1.757
date	2017.02.17.22.40.09;	author tg;	state Exp;
branches;
next	1.756;
commitid	10058A77BD32DFE626F;

1.756
date	2016.11.11.23.31.31;	author tg;	state Exp;
branches;
next	1.755;
commitid	100582654B972655F84;

1.755
date	2016.11.07.16.58.45;	author tg;	state Exp;
branches;
next	1.754;
commitid	1005820B2DD17077C51;

1.754
date	2016.10.02.22.21.43;	author tg;	state Exp;
branches;
next	1.753;
commitid	10057F1888F65CBF445;

1.753
date	2016.09.01.12.59.05;	author tg;	state Exp;
branches;
next	1.752;
commitid	10057C8260A04757349;

1.752
date	2016.08.25.16.21.30;	author tg;	state Exp;
branches;
next	1.751;
commitid	10057BF1B1D101BE102;

1.751
date	2016.08.12.16.48.02;	author tg;	state Exp;
branches;
next	1.750;
commitid	10057ADFDDA517E115F;

1.750
date	2016.08.10.18.20.03;	author tg;	state Exp;
branches;
next	1.749;
commitid	10057AB706B2E3BA65B;

1.749
date	2016.08.04.20.51.32;	author tg;	state Exp;
branches;
next	1.748;
commitid	10057A3AAA90034EF8B;

1.748
date	2016.08.01.21.37.59;	author tg;	state Exp;
branches;
next	1.747;
commitid	100579FC12F14735847;

1.747
date	2016.08.01.21.29.05;	author tg;	state Exp;
branches;
next	1.746;
commitid	100579FBF3007A19476;

1.746
date	2016.07.28.21.39.16;	author tg;	state Exp;
branches;
next	1.745;
commitid	100579A7B9C449E55CC;

1.745
date	2016.07.26.21.50.42;	author tg;	state Exp;
branches;
next	1.744;
commitid	1005797DB49584A72A4;

1.744
date	2016.07.25.21.05.19;	author tg;	state Exp;
branches;
next	1.743;
commitid	10057967F184AB0E82A;

1.743
date	2016.07.25.20.38.00;	author tg;	state Exp;
branches;
next	1.742;
commitid	100579678BA313AF68F;

1.742
date	2016.07.25.20.36.24;	author tg;	state Exp;
branches;
next	1.741;
commitid	1005796785B4D2EFC61;

1.741
date	2016.07.25.00.04.37;	author tg;	state Exp;
branches;
next	1.740;
commitid	1005795579F14A3FE5C;

1.740
date	2016.07.12.23.07.06;	author tg;	state Exp;
branches;
next	1.739;
commitid	100578578165D391F66;

1.739
date	2016.06.26.00.44.55;	author tg;	state Exp;
branches;
next	1.738;
commitid	100576F259765932F2C;

1.738
date	2016.06.26.00.09.32;	author tg;	state Exp;
branches;
next	1.737;
commitid	100576F1D4100EFF065;

1.737
date	2016.06.26.00.06.43;	author tg;	state Exp;
branches;
next	1.736;
commitid	100576F1CA77D8B6754;

1.736
date	2016.06.26.00.04.30;	author tg;	state Exp;
branches;
next	1.735;
commitid	100576F1C233286BD77;

1.735
date	2016.06.26.00.00.53;	author tg;	state Exp;
branches;
next	1.734;
commitid	100576F1B4E205515EE;

1.734
date	2016.06.25.23.54.57;	author tg;	state Exp;
branches;
next	1.733;
commitid	100576F19E14572FB35;

1.733
date	2016.05.31.19.59.53;	author tg;	state Exp;
branches;
next	1.732;
commitid	100574DED4C5FD85388;

1.732
date	2016.05.17.15.36.31;	author tg;	state Exp;
branches;
next	1.731;
commitid	100573B39F5517EBA22;

1.731
date	2016.05.05.22.58.19;	author tg;	state Exp;
branches;
next	1.730;
commitid	100572BCFC37426FBEF;

1.730
date	2016.04.14.15.38.36;	author tg;	state Exp;
branches;
next	1.729;
commitid	100570FB99421ECAE64;

1.729
date	2016.04.09.13.55.09;	author tg;	state Exp;
branches;
next	1.728;
commitid	100570909A43DABCFC0;

1.728
date	2016.03.05.15.39.36;	author tg;	state Exp;
branches;
next	1.727;
commitid	10056DAFDC40EA6BC12;

1.727
date	2016.03.04.14.26.09;	author tg;	state Exp;
branches;
next	1.726;
commitid	10056D99B037D4D691D;

1.726
date	2016.03.01.18.30.01;	author tg;	state Exp;
branches;
next	1.725;
commitid	10056D5DFC11D3566D1;

1.725
date	2016.02.26.22.03.10;	author tg;	state Exp;
branches;
next	1.724;
commitid	10056D0CBB6638789A4;

1.724
date	2016.02.24.01.47.30;	author tg;	state Exp;
branches;
next	1.723;
commitid	10056CD0B7E394575BD;

1.723
date	2016.02.11.20.19.44;	author tg;	state Exp;
branches;
next	1.722;
commitid	10056BCECE0385CD6DF;

1.722
date	2016.01.21.18.24.35;	author tg;	state Exp;
branches;
next	1.721;
commitid	10056A12268001BF859;

1.721
date	2016.01.20.21.34.09;	author tg;	state Exp;
branches;
next	1.720;
commitid	100569FFD594609A81E;

1.720
date	2016.01.19.23.12.10;	author tg;	state Exp;
branches;
next	1.719;
commitid	100569EC2AE617A4288;

1.719
date	2016.01.14.23.19.12;	author tg;	state Exp;
branches;
next	1.718;
commitid	10056982CFC48BD72D7;

1.718
date	2016.01.13.17.20.46;	author tg;	state Exp;
branches;
next	1.717;
commitid	1005696877B782808CD;

1.717
date	2015.12.31.21.03.44;	author tg;	state Exp;
branches;
next	1.716;
commitid	100568598191D3EFE4F;

1.716
date	2015.12.12.23.31.15;	author tg;	state Exp;
branches;
next	1.715;
commitid	100566CAE4A0CFFE80D;

1.715
date	2015.12.12.22.25.12;	author tg;	state Exp;
branches;
next	1.714;
commitid	100566C9EDD3DC6C239;

1.714
date	2015.12.12.16.37.44;	author tg;	state Exp;
branches;
next	1.713;
commitid	100566C4D69308DF911;

1.713
date	2015.12.11.16.55.55;	author tg;	state Exp;
branches;
next	1.712;
commitid	100566B000F00224762;

1.712
date	2015.10.24.19.46.07;	author tg;	state Exp;
branches;
next	1.711;
commitid	100562BE0036C605830;

1.711
date	2015.10.13.21.39.53;	author tg;	state Exp;
branches;
next	1.710;
commitid	100561D7A333520B0AE;

1.710
date	2015.10.09.21.36.52;	author tg;	state Exp;
branches;
next	1.709;
commitid	100561833456A230F8F;

1.709
date	2015.10.09.17.48.46;	author tg;	state Exp;
branches;
next	1.708;
commitid	1005617FE066005352E;

1.708
date	2015.10.05.17.58.57;	author tg;	state Exp;
branches;
next	1.707;
commitid	1005612BA62412FC278;

1.707
date	2015.09.06.19.46.56;	author tg;	state Exp;
branches;
next	1.706;
commitid	10055EC98215F2B5F9C;

1.706
date	2015.09.05.20.20.42;	author tg;	state Exp;
branches;
next	1.705;
commitid	10055EB4EA5242ECCAA;

1.705
date	2015.08.13.22.06.19;	author tg;	state Exp;
branches;
next	1.704;
commitid	10055CD14E772441249;

1.704
date	2015.08.13.21.38.15;	author tg;	state Exp;
branches;
next	1.703;
commitid	10055CD0E35383B51C9;

1.703
date	2015.07.10.19.36.31;	author tg;	state Exp;
branches;
next	1.702;
commitid	10055A01EBD784EE31A;

1.702
date	2015.07.09.20.52.36;	author tg;	state Exp;
branches;
next	1.701;
commitid	100559EDF161DEE9DD2;

1.701
date	2015.07.09.20.11.45;	author tg;	state Exp;
branches;
next	1.700;
commitid	100559ED592471E50AC;

1.700
date	2015.07.09.19.28.18;	author tg;	state Exp;
branches;
next	1.699;
commitid	100559ECB63048E9D39;

1.699
date	2015.07.06.17.48.29;	author tg;	state Exp;
branches;
next	1.698;
commitid	100559ABF230C8CC8EB;

1.698
date	2015.07.05.19.37.11;	author tg;	state Exp;
branches;
next	1.697;
commitid	1005599876B5247136B;

1.697
date	2015.07.05.17.04.24;	author tg;	state Exp;
branches;
next	1.696;
commitid	1005599636613028AB4;

1.696
date	2015.07.05.15.12.04;	author tg;	state Exp;
branches;
next	1.695;
commitid	10055994954771386CF;

1.695
date	2015.06.28.16.23.22;	author tg;	state Exp;
branches;
next	1.694;
commitid	10055901F85432BD4FC;

1.694
date	2015.05.23.17.43.18;	author tg;	state Exp;
branches;
next	1.693;
commitid	1005560BBB87BB0247C;

1.693
date	2015.04.29.20.44.32;	author tg;	state Exp;
branches;
next	1.692;
commitid	100554142C5624212CA;

1.692
date	2015.04.29.20.13.47;	author tg;	state Exp;
branches;
next	1.691;
commitid	10055413B917A56A81D;

1.691
date	2015.04.29.20.07.30;	author tg;	state Exp;
branches;
next	1.690;
commitid	100554139453DB97755;

1.690
date	2015.04.19.19.18.03;	author tg;	state Exp;
branches;
next	1.689;
commitid	1005533FF4D64965277;

1.689
date	2015.04.11.23.28.17;	author tg;	state Exp;
branches;
next	1.688;
commitid	1005529AD8D33CF99B9;

1.688
date	2015.04.11.21.18.45;	author tg;	state Exp;
branches;
next	1.687;
commitid	10055298FBA6FED7EF3;

1.687
date	2015.03.20.23.37.52;	author tg;	state Exp;
branches;
next	1.686;
commitid	100550CAF6732AE1EA7;

1.686
date	2015.03.20.23.37.27;	author tg;	state Exp;
branches;
next	1.685;
commitid	100550CAF4E01CA838D;

1.685
date	2015.03.14.05.23.12;	author tg;	state Exp;
branches;
next	1.684;
commitid	1005503C5CA29059CD3;

1.684
date	2015.03.08.22.54.31;	author tg;	state Exp;
branches;
next	1.683;
commitid	10054FCD1444FC13F3C;

1.683
date	2015.03.07.20.46.26;	author tg;	state Exp;
branches;
next	1.682;
commitid	10054FB63890799A9FA;

1.682
date	2015.03.01.15.23.03;	author tg;	state Exp;
branches;
next	1.681;
commitid	10054F32EE078DD628C;

1.681
date	2015.02.20.07.14.26;	author tg;	state Exp;
branches;
next	1.680;
commitid	10054E6DEC961F3FFC5;

1.680
date	2015.02.19.22.26.47;	author tg;	state Exp;
branches;
next	1.679;
commitid	10054E6631B44A55260;

1.679
date	2015.02.13.12.51.30;	author tg;	state Exp;
branches;
next	1.678;
commitid	10054DDF3221517B878;

1.678
date	2015.02.06.10.56.44;	author tg;	state Exp;
branches;
next	1.677;
commitid	10054D49DF4344D0AFC;

1.677
date	2015.01.25.15.23.39;	author tg;	state Exp;
branches;
next	1.676;
commitid	10054C50A720861330B;

1.676
date	2015.01.04.21.08.08;	author tg;	state Exp;
branches;
next	1.675;
commitid	10054A9ABCF7F3049A5;

1.675
date	2015.01.04.20.23.51;	author tg;	state Exp;
branches;
next	1.674;
commitid	10054A9A16667A3099C;

1.674
date	2015.01.02.13.21.26;	author tg;	state Exp;
branches;
next	1.673;
commitid	10054A69B5C737AE4A2;

1.673
date	2014.12.15.23.18.44;	author tg;	state Exp;
branches;
next	1.672;
commitid	100548F6C16391FF689;

1.672
date	2014.12.15.22.50.08;	author tg;	state Exp;
branches;
next	1.671;
commitid	100548F65AB2DD01C69;

1.671
date	2014.11.25.21.13.19;	author tg;	state Exp;
branches;
next	1.670;
commitid	1005474F00E09321C83;

1.670
date	2014.11.19.18.44.09;	author tg;	state Exp;
branches;
next	1.669;
commitid	100546CE4F2089B6886;

1.669
date	2014.11.14.20.21.27;	author tg;	state Exp;
branches;
next	1.668;
commitid	1005466644F12462973;

1.668
date	2014.10.24.12.13.52;	author tg;	state Exp;
branches;
next	1.667;
commitid	100544A426A79659D90;

1.667
date	2014.10.19.22.26.13;	author tg;	state Exp;
branches
	1.667.2.1;
next	1.666;
commitid	10054443A97441CCBBF;

1.666
date	2014.10.19.21.53.05;	author tg;	state Exp;
branches;
next	1.665;
commitid	100544432BD7CEA2F06;

1.665
date	2014.10.19.21.39.35;	author tg;	state Exp;
branches;
next	1.664;
commitid	10054442FAC18EC3A91;

1.664
date	2014.10.19.20.56.30;	author tg;	state Exp;
branches;
next	1.663;
commitid	1005444249972F13F37;

1.663
date	2014.10.12.19.54.58;	author tg;	state Exp;
branches;
next	1.662;
commitid	100543ADCA73754295B;

1.662
date	2014.10.10.22.10.19;	author tg;	state Exp;
branches;
next	1.661;
commitid	1005438594F5D660DE1;

1.661
date	2014.10.07.15.22.14;	author tg;	state Exp;
branches;
next	1.660;
commitid	1005434053135366996;

1.660
date	2014.10.04.11.47.16;	author tg;	state Exp;
branches;
next	1.659;
commitid	100542FDE4766613707;

1.659
date	2014.10.03.17.32.09;	author tg;	state Exp;
branches;
next	1.658;
commitid	100542EDD596FD5FBF9;

1.658
date	2014.09.03.19.22.49;	author tg;	state Exp;
branches;
next	1.657;
commitid	10054076A8136C0C0D1;

1.657
date	2014.07.29.17.56.31;	author tg;	state Exp;
branches;
next	1.656;
commitid	10053D7E0603987F6FE;

1.656
date	2014.07.28.21.45.42;	author tg;	state Exp;
branches;
next	1.655;
commitid	10053D6C428265C691A;

1.655
date	2014.07.13.11.34.26;	author tg;	state Exp;
branches;
next	1.654;
commitid	10053C26EB832BD6A2E;

1.654
date	2014.06.29.11.28.26;	author tg;	state Exp;
branches;
next	1.653;
commitid	10053AFF8604CE197F5;

1.653
date	2014.06.24.20.47.42;	author tg;	state Exp;
branches;
next	1.652;
commitid	10053A9E3FD4EC55000;

1.652
date	2014.06.10.22.17.07;	author tg;	state Exp;
branches;
next	1.651;
commitid	100539783DC1BABB2C6;

1.651
date	2014.06.09.13.25.50;	author tg;	state Exp;
branches;
next	1.650;
commitid	1005395B5803902C8E9;

1.650
date	2014.06.09.11.16.06;	author tg;	state Exp;
branches;
next	1.649;
commitid	1005395977B5787B7BA;

1.649
date	2014.06.09.11.13.17;	author tg;	state Exp;
branches;
next	1.648;
commitid	100539596D30E12579C;

1.648
date	2014.06.09.10.41.01;	author tg;	state Exp;
branches;
next	1.647;
commitid	10053958F4C346B3377;

1.647
date	2014.05.29.21.30.45;	author tg;	state Exp;
branches;
next	1.646;
commitid	1005387A6E14DBA71BC;

1.646
date	2014.05.27.13.22.42;	author tg;	state Exp;
branches;
next	1.645;
commitid	1005384911C31753F0C;

1.645
date	2014.05.27.13.00.31;	author tg;	state Exp;
branches;
next	1.644;
commitid	10053848C7F67D88909;

1.644
date	2014.04.29.07.43.38;	author tg;	state Exp;
branches;
next	1.643;
commitid	100535F582B26E483E6;

1.643
date	2014.02.09.00.08.17;	author tg;	state Exp;
branches;
next	1.642;
commitid	10052F6C6FE794400A0;

1.642
date	2014.02.08.20.20.32;	author tg;	state Exp;
branches;
next	1.641;
commitid	10052F691A84ABBD1F7;

1.641
date	2014.01.22.19.53.50;	author tg;	state Exp;
branches;
next	1.640;
commitid	10052E021E52FD0AF33;

1.640
date	2014.01.11.18.09.37;	author tg;	state Exp;
branches;
next	1.639;
commitid	10052D188DD7DFEC194;

1.639
date	2014.01.05.21.57.22;	author tg;	state Exp;
branches;
next	1.638;
commitid	10052C9D445413B34DF;

1.638
date	2013.12.15.15.45.31;	author tg;	state Exp;
branches;
next	1.637;
commitid	10052ADCEB20D3DEE89;

1.637
date	2013.11.30.17.41.32;	author tg;	state Exp;
branches;
next	1.636;
commitid	100529A23520014334E;

1.636
date	2013.11.30.00.20.46;	author tg;	state Exp;
branches;
next	1.635;
commitid	10052992F754802C9BE;

1.635
date	2013.11.17.22.28.49;	author tg;	state Exp;
branches;
next	1.634;
commitid	1005289433447F6CA90;

1.634
date	2013.10.09.11.59.26;	author tg;	state Exp;
branches;
next	1.633;
commitid	10052554535524C4C97;

1.633
date	2013.09.24.20.19.40;	author tg;	state Exp;
branches;
next	1.632;
commitid	1005241F37044BDFFC4;

1.632
date	2013.09.10.17.32.58;	author tg;	state Exp;
branches;
next	1.631;
commitid	100522F57C13E265FDE;

1.631
date	2013.08.23.14.07.34;	author tg;	state Exp;
branches;
next	1.630;
commitid	10052176CB912FE954B;

1.630
date	2013.08.16.10.58.59;	author tg;	state Exp;
branches;
next	1.629;
commitid	100520E05EA33BA2E83;

1.629
date	2013.08.14.20.26.15;	author tg;	state Exp;
branches;
next	1.628;
commitid	100520BE7CE316FF2FE;

1.628
date	2013.08.11.14.57.07;	author tg;	state Exp;
branches;
next	1.627;
commitid	1005207A65963070688;

1.627
date	2013.08.10.13.47.16;	author tg;	state Exp;
branches;
next	1.626;
commitid	100520644762FA2353A;

1.626
date	2013.08.10.13.44.27;	author tg;	state Exp;
branches;
next	1.625;
commitid	100520643B4127D9BCA;

1.625
date	2013.07.26.20.33.35;	author tg;	state Exp;
branches;
next	1.624;
commitid	10051F2DD36363A1B44;

1.624
date	2013.07.25.18.07.44;	author tg;	state Exp;
branches;
next	1.623;
commitid	10051F1695C46761A92;

1.623
date	2013.07.25.16.41.30;	author tg;	state Exp;
branches;
next	1.622;
commitid	10051F15514581C3564;

1.622
date	2013.07.25.16.06.43;	author tg;	state Exp;
branches;
next	1.621;
commitid	10051F14D24568E0943;

1.621
date	2013.07.24.18.03.54;	author tg;	state Exp;
branches;
next	1.620;
commitid	10051F017226117F784;

1.620
date	2013.07.24.12.39.25;	author tg;	state Exp;
branches;
next	1.619;
commitid	10051EFCAFD588E97F5;

1.619
date	2013.07.21.18.47.16;	author tg;	state Exp;
branches;
next	1.618;
commitid	10051EC2CBD68BDF6A5;

1.618
date	2013.07.21.18.38.53;	author tg;	state Exp;
branches;
next	1.617;
commitid	10051EC2ACD697CBF6B;

1.617
date	2013.07.21.18.35.57;	author tg;	state Exp;
branches;
next	1.616;
commitid	10051EC29F9411252FA;

1.616
date	2013.06.03.22.28.28;	author tg;	state Exp;
branches;
next	1.615;
commitid	10051AD18A44752B56B;

1.615
date	2013.06.02.03.09.12;	author tg;	state Exp;
branches;
next	1.614;
commitid	10051AAB6AE4E828507;

1.614
date	2013.06.01.00.15.55;	author tg;	state Exp;
branches;
next	1.613;
commitid	10051A93D525FED429B;

1.613
date	2013.05.31.22.47.12;	author tg;	state Exp;
branches;
next	1.612;
commitid	10051A9287543AE1F04;

1.612
date	2013.05.02.21.59.45;	author tg;	state Exp;
branches;
next	1.611;
commitid	1005182E1E55272FF6B;

1.611
date	2013.05.02.20.28.10;	author tg;	state Exp;
branches;
next	1.610;
commitid	1005182CC714DDF0A48;

1.610
date	2013.05.02.20.21.38;	author tg;	state Exp;
branches;
next	1.609;
commitid	1005182CAE814B1B129;

1.609
date	2013.04.27.19.16.23;	author tg;	state Exp;
branches;
next	1.608;
commitid	100517C240B5F21EA3E;

1.608
date	2013.04.27.18.50.21;	author tg;	state Exp;
branches;
next	1.607;
commitid	100517C1D840086DC8F;

1.607
date	2013.04.26.21.22.42;	author tg;	state Exp;
branches;
next	1.606;
commitid	100517AEF6C22DD1AE7;

1.606
date	2013.04.26.19.40.42;	author tg;	state Exp;
branches;
next	1.605;
commitid	100517AD85106670209;

1.605
date	2013.04.01.02.37.47;	author tg;	state Exp;
branches;
next	1.604;
commitid	1005158F2D44922CF13;

1.604
date	2013.04.01.01.16.34;	author tg;	state Exp;
branches;
next	1.603;
commitid	1005158DFEE1ED14734;

1.603
date	2013.03.30.23.31.01;	author tg;	state Exp;
branches;
next	1.602;
commitid	100515775CB57F0EB86;

1.602
date	2013.03.29.17.33.53;	author tg;	state Exp;
branches;
next	1.601;
commitid	1005155D0985F77FD2A;

1.601
date	2013.03.24.15.01.46;	author tg;	state Exp;
branches;
next	1.600;
commitid	100514F15711E9EFAB7;

1.600
date	2013.03.24.00.56.19;	author tg;	state Exp;
branches;
next	1.599;
commitid	100514E4F1D5C90862C;

1.599
date	2013.02.24.14.22.41;	author tg;	state Exp;
branches;
next	1.598;
commitid	100512A22416D5A6B55;

1.598
date	2013.02.23.20.03.27;	author tg;	state Exp;
branches;
next	1.597;
commitid	1005129208E57646522;

1.597
date	2013.02.19.18.45.17;	author tg;	state Exp;
branches;
next	1.596;
commitid	1005123C815760131DF;

1.596
date	2013.02.18.22.55.37;	author tg;	state Exp;
branches;
next	1.595;
commitid	1005122B16E6B48945B;

1.595
date	2013.02.17.05.40.13;	author tg;	state Exp;
branches;
next	1.594;
commitid	10051206D50560C037D;

1.594
date	2013.02.15.18.50.11;	author tg;	state Exp;
branches;
next	1.593;
commitid	100511E837A3084211A;

1.593
date	2013.02.11.13.06.54;	author tg;	state Exp;
branches;
next	1.592;
commitid	1005118ECF1719865D3;

1.592
date	2013.02.10.23.59.23;	author tg;	state Exp;
branches;
next	1.591;
commitid	100511834521EDC159D;

1.591
date	2013.02.10.23.36.21;	author tg;	state Exp;
branches;
next	1.590;
commitid	10051182F0D153DA163;

1.590
date	2013.02.10.23.32.18;	author tg;	state Exp;
branches;
next	1.589;
commitid	10051182DF929D25B72;

1.589
date	2013.02.10.19.03.58;	author tg;	state Exp;
branches;
next	1.588;
commitid	1005117EF1D3942ADA8;

1.588
date	2013.01.19.19.47.05;	author tg;	state Exp;
branches;
next	1.587;
commitid	10050FAF850424A45DD;

1.587
date	2013.01.19.18.32.54;	author tg;	state Exp;
branches;
next	1.586;
commitid	10050FAE6D775E28DAF;

1.586
date	2013.01.06.18.51.39;	author tg;	state Exp;
branches;
next	1.585;
commitid	10050E9C7D31AD0F470;

1.585
date	2013.01.01.22.23.14;	author tg;	state Exp;
branches;
next	1.584;
commitid	10050E361E825906F7E;

1.584
date	2013.01.01.20.45.00;	author tg;	state Exp;
branches;
next	1.583;
commitid	10050E34AE3215C257E;

1.583
date	2013.01.01.03.32.41;	author tg;	state Exp;
branches;
next	1.582;
commitid	10050E258F01BA8A38D;

1.582
date	2012.12.28.07.45.55;	author tg;	state Exp;
branches;
next	1.581;
commitid	10050DD4E4B6E75114D;

1.581
date	2012.12.28.04.29.56;	author tg;	state Exp;
branches;
next	1.580;
commitid	10050DD205C25F6C07A;

1.580
date	2012.12.28.04.25.32;	author tg;	state Exp;
branches;
next	1.579;
commitid	10050DD1F531FCD979D;

1.579
date	2012.12.28.04.01.17;	author tg;	state Exp;
branches;
next	1.578;
commitid	10050DD19A400ADEADB;

1.578
date	2012.12.28.03.18.46;	author tg;	state Exp;
branches;
next	1.577;
commitid	10050DD0FA77D3C3AD3;

1.577
date	2012.12.28.02.28.30;	author tg;	state Exp;
branches;
next	1.576;
commitid	10050DD03E43C678B81;

1.576
date	2012.12.24.14.37.13;	author tg;	state Exp;
branches;
next	1.575;
commitid	10050D868B00BF4C700;

1.575
date	2012.12.22.00.03.39;	author tg;	state Exp;
branches;
next	1.574;
commitid	10050D4F8C95001AF1D;

1.574
date	2012.12.17.23.46.31;	author tg;	state Exp;
branches;
next	1.573;
commitid	10050CFAEEB2D5D31EB;

1.573
date	2012.12.07.23.46.33;	author tg;	state Exp;
branches;
next	1.572;
commitid	10050C27FDC255CF0A0;

1.572
date	2012.12.07.23.43.09;	author tg;	state Exp;
branches;
next	1.571;
commitid	10050C27F242B7BBEDE;

1.571
date	2012.12.05.19.38.18;	author tg;	state Exp;
branches;
next	1.570;
commitid	10050BFA2C0046FB3B9;

1.570
date	2012.12.04.01.18.24;	author tg;	state Exp;
branches;
next	1.569;
commitid	10050BD4F7642624FD1;

1.569
date	2012.11.30.19.25.01;	author tg;	state Exp;
branches
	1.569.2.1;
next	1.568;
commitid	10050B907135D4B5928;

1.568
date	2012.11.26.23.14.44;	author tg;	state Exp;
branches;
next	1.567;
commitid	10050B3F7FB39D688CF;

1.567
date	2012.11.25.22.23.31;	author tg;	state Exp;
branches;
next	1.566;
commitid	10050B29A7B664F1A9E;

1.566
date	2012.11.20.18.50.42;	author tg;	state Exp;
branches;
next	1.565;
commitid	10050ABD11751603401;

1.565
date	2012.11.12.19.13.44;	author tg;	state Exp;
branches;
next	1.564;
commitid	10050A14A6D512A123A;

1.564
date	2012.11.12.18.48.29;	author tg;	state Exp;
branches;
next	1.563;
commitid	10050A14495703712CD;

1.563
date	2012.10.30.20.07.10;	author tg;	state Exp;
branches;
next	1.562;
commitid	10050903386452ACBF1;

1.562
date	2012.10.22.20.19.10;	author tg;	state Exp;
branches;
next	1.561;
commitid	1005085AA537A17A752;

1.561
date	2012.10.21.21.55.01;	author tg;	state Exp;
branches;
next	1.560;
commitid	10050846F101988A117;

1.560
date	2012.10.21.17.38.22;	author tg;	state Exp;
branches;
next	1.559;
commitid	100508433245EAC86CE;

1.559
date	2012.10.03.17.24.14;	author tg;	state Exp;
branches;
next	1.558;
commitid	100506C74D35719B33B;

1.558
date	2012.09.07.21.02.40;	author tg;	state Exp;
branches;
next	1.557;
commitid	100504A600348A7ECE5;

1.557
date	2012.09.01.23.46.39;	author tg;	state Exp;
branches;
next	1.556;
commitid	10050429E542CD63CF1;

1.556
date	2012.08.24.21.33.47;	author tg;	state Exp;
branches;
next	1.555;
commitid	1005037F34F0A0722F6;

1.555
date	2012.08.17.18.34.18;	author tg;	state Exp;
branches;
next	1.554;
commitid	100502E8EAA4BFCF410;

1.554
date	2012.08.03.18.45.29;	author tg;	state Exp;
branches;
next	1.553;
commitid	100501C1C5E2739B581;

1.553
date	2012.07.30.21.37.08;	author tg;	state Exp;
branches;
next	1.552;
commitid	1005016FE9B27F9F4DC;

1.552
date	2012.07.30.19.58.03;	author tg;	state Exp;
branches;
next	1.551;
commitid	1005016E7627EF7B61F;

1.551
date	2012.07.20.23.22.07;	author tg;	state Exp;
branches;
next	1.550;
commitid	1005009E802250C41C1;

1.550
date	2012.07.01.15.54.51;	author tg;	state Exp;
branches;
next	1.549;
commitid	1004FF072DE3F1A3116;

1.549
date	2012.06.28.20.17.35;	author tg;	state Exp;
branches
	1.549.2.1;
next	1.548;
commitid	1004FECBBF10FC5C93C;

1.548
date	2012.06.28.20.14.15;	author tg;	state Exp;
branches;
next	1.547;
commitid	1004FECBB2E41E1396D;

1.547
date	2012.06.28.20.05.05;	author tg;	state Exp;
branches;
next	1.546;
commitid	1004FECB8FB4B2757ED;

1.546
date	2012.06.28.20.04.01;	author tg;	state Exp;
branches;
next	1.545;
commitid	1004FECB8BA4BE1EF25;

1.545
date	2012.06.28.20.03.17;	author tg;	state Exp;
branches;
next	1.544;
commitid	1004FECB89C0F69075F;

1.544
date	2012.06.26.19.33.30;	author tg;	state Exp;
branches;
next	1.543;
commitid	1004FEA0E9F218104F1;

1.543
date	2012.06.26.18.11.01;	author tg;	state Exp;
branches;
next	1.542;
commitid	1004FE9FB4B72E4DC0B;

1.542
date	2012.06.25.16.34.56;	author tg;	state Exp;
branches;
next	1.541;
commitid	1004FE89345267ADDF9;

1.541
date	2012.06.25.16.31.16;	author tg;	state Exp;
branches;
next	1.540;
commitid	1004FE892691AED522E;

1.540
date	2012.06.25.16.17.51;	author tg;	state Exp;
branches;
next	1.539;
commitid	1004FE88F4450CF3826;

1.539
date	2012.06.25.16.05.08;	author tg;	state Exp;
branches;
next	1.538;
commitid	1004FE88C477BD00898;

1.538
date	2012.06.24.20.39.24;	author tg;	state Exp;
branches;
next	1.537;
commitid	1004FE77ABD5A53682F;

1.537
date	2012.05.09.23.20.55;	author tg;	state Exp;
branches;
next	1.536;
commitid	1004FAAFBED1D226CAF;

1.536
date	2012.05.04.22.44.31;	author tg;	state Exp;
branches;
next	1.535;
commitid	1004FA45BE357DA71DC;

1.535
date	2012.05.04.21.42.51;	author tg;	state Exp;
branches;
next	1.534;
commitid	1004FA44D7024BF2AB1;

1.534
date	2012.04.27.16.16.21;	author tg;	state Exp;
branches;
next	1.533;
commitid	1004F9AC66A708942C6;

1.533
date	2012.04.22.21.50.29;	author tg;	state Exp;
branches;
next	1.532;
commitid	1004F947C3646B6F432;

1.532
date	2012.04.14.16.07.44;	author tg;	state Exp;
branches;
next	1.531;
commitid	1004F89A0D311D70891;

1.531
date	2012.04.07.11.19.47;	author tg;	state Exp;
branches;
next	1.530;
commitid	1004F8022E670BC1C0E;

1.530
date	2012.04.06.12.30.40;	author tg;	state Exp;
branches;
next	1.529;
commitid	1004F7EE2076215582C;

1.529
date	2012.04.06.12.27.15;	author tg;	state Exp;
branches;
next	1.528;
commitid	1004F7EE13A5EFA3A76;

1.528
date	2012.03.31.18.28.11;	author tg;	state Exp;
branches;
next	1.527;
commitid	1004F774CD253AC1AE1;

1.527
date	2012.03.31.18.26.53;	author tg;	state Exp;
branches;
next	1.526;
commitid	1004F774C8332BB4D71;

1.526
date	2012.03.31.18.18.41;	author tg;	state Exp;
branches;
next	1.525;
commitid	1004F774A85262FD1E9;

1.525
date	2012.03.29.19.22.55;	author tg;	state Exp;
branches;
next	1.524;
commitid	1004F74B525291EF6DE;

1.524
date	2012.03.27.22.36.49;	author tg;	state Exp;
branches;
next	1.523;
commitid	1004F7240673EAD3A5A;

1.523
date	2012.03.26.21.10.38;	author tg;	state Exp;
branches;
next	1.522;
commitid	1004F70DB64299CF262;

1.522
date	2012.03.26.00.25.52;	author tg;	state Exp;
branches;
next	1.521;
commitid	1004F6FB7A67F48E93A;

1.521
date	2012.03.25.14.28.11;	author tg;	state Exp;
branches;
next	1.520;
commitid	1004F6F2B60460FB25D;

1.520
date	2012.03.24.21.22.23;	author tg;	state Exp;
branches;
next	1.519;
commitid	1004F6E3A967ACCD93A;

1.519
date	2012.03.24.19.13.25;	author tg;	state Exp;
branches;
next	1.518;
commitid	1004F6E1CDE5344A082;

1.518
date	2012.03.23.23.25.23;	author tg;	state Exp;
branches;
next	1.517;
commitid	1004F6D064C65BE58AA;

1.517
date	2012.03.20.16.48.12;	author tg;	state Exp;
branches;
next	1.516;
commitid	1004F68B4B034E302DF;

1.516
date	2012.03.03.21.30.54;	author tg;	state Exp;
branches;
next	1.515;
commitid	1004F528D8E7F3D0F12;

1.515
date	2012.02.06.17.42.20;	author tg;	state Exp;
branches;
next	1.514;
commitid	1004F3010EC139BAB7F;

1.514
date	2012.01.29.01.41.09;	author tg;	state Exp;
branches;
next	1.513;
commitid	1004F24A3CB1AC86618;

1.513
date	2012.01.14.19.20.17;	author tg;	state Exp;
branches;
next	1.512;
commitid	1004F11D5885906B68E;

1.512
date	2012.01.05.11.52.48;	author tg;	state Exp;
branches;
next	1.511;
commitid	1004F058F271E277CF6;

1.511
date	2012.01.04.19.09.32;	author tg;	state Exp;
branches;
next	1.510;
commitid	1004F04A401028F581D;

1.510
date	2012.01.03.15.32.05;	author tg;	state Exp;
branches;
next	1.509;
commitid	1004F031F1C71A635C2;

1.509
date	2012.01.03.01.40.15;	author tg;	state Exp;
branches;
next	1.508;
commitid	1004F025C8A70617D83;

1.508
date	2012.01.03.00.58.07;	author tg;	state Exp;
branches;
next	1.507;
commitid	1004F025261140919C7;

1.507
date	2011.12.31.00.27.23;	author tg;	state Exp;
branches;
next	1.506;
commitid	1004EFE570218254BB1;

1.506
date	2011.12.29.23.36.21;	author tg;	state Exp;
branches;
next	1.505;
commitid	1004EFCF98C06684CE3;

1.505
date	2011.12.29.22.03.12;	author tg;	state Exp;
branches;
next	1.504;
commitid	1004EFCE3A84AB854A0;

1.504
date	2011.12.16.20.03.23;	author tg;	state Exp;
branches;
next	1.503;
commitid	1004EEBA4214501EA9D;

1.503
date	2011.12.11.01.56.41;	author tg;	state Exp;
branches;
next	1.502;
commitid	1004EE40DDD498FBB0D;

1.502
date	2011.12.11.01.35.08;	author tg;	state Exp;
branches;
next	1.501;
commitid	1004EE408E1382C1752;

1.501
date	2011.12.10.13.34.14;	author tg;	state Exp;
branches;
next	1.500;
commitid	1004EE35FEC458C37A0;

1.500
date	2011.12.09.20.40.02;	author tg;	state Exp;
branches;
next	1.499;
commitid	1004EE2723869988A49;

1.499
date	2011.12.08.22.19.04;	author tg;	state Exp;
branches;
next	1.498;
commitid	1004EE137ED7AAC8DC0;

1.498
date	2011.12.02.22.55.46;	author tg;	state Exp;
branches;
next	1.497;
commitid	1004ED9575E20B9B002;

1.497
date	2011.11.30.21.34.10;	author tg;	state Exp;
branches;
next	1.496;
commitid	1004ED6A06C18CCDBE5;

1.496
date	2011.11.26.00.45.18;	author tg;	state Exp;
branches;
next	1.495;
commitid	1004ED036B353923A89;

1.495
date	2011.11.25.23.33.42;	author tg;	state Exp;
branches;
next	1.494;
commitid	1004ED0253F6C36480B;

1.494
date	2011.11.25.23.29.31;	author tg;	state Exp;
branches;
next	1.493;
commitid	1004ED0249F2884E13A;

1.493
date	2011.11.22.18.01.37;	author tg;	state Exp;
branches;
next	1.492;
commitid	1004ECBE39656891872;

1.492
date	2011.11.19.21.22.00;	author tg;	state Exp;
branches;
next	1.491;
commitid	1004EC81E0F6AE3EBEC;

1.491
date	2011.11.19.17.25.55;	author tg;	state Exp;
branches;
next	1.490;
commitid	1004EC7E6A960777D92;

1.490
date	2011.11.11.22.14.15;	author tg;	state Exp;
branches;
next	1.489;
commitid	1004EBD9E4D2DCCBE71;

1.489
date	2011.11.09.22.17.23;	author tg;	state Exp;
branches;
next	1.488;
commitid	1004EBAFBE75B5A370F;

1.488
date	2011.11.08.23.10.58;	author tg;	state Exp;
branches;
next	1.487;
commitid	1004EB9B71979631657;

1.487
date	2011.11.08.22.07.11;	author tg;	state Exp;
branches;
next	1.486;
commitid	1004EB9A7F80119200E;

1.486
date	2011.11.05.23.39.02;	author tg;	state Exp;
branches;
next	1.485;
commitid	1004EB5C91C1FD111AE;

1.485
date	2011.10.26.20.46.13;	author tg;	state Exp;
branches;
next	1.484;
commitid	1004EA871AC0D94FE1C;

1.484
date	2011.10.24.19.41.09;	author tg;	state Exp;
branches;
next	1.483;
commitid	1004EA5BF6B41948165;

1.483
date	2011.10.07.19.51.42;	author tg;	state Exp;
branches;
next	1.482;
commitid	1004E8F58646396DFB2;

1.482
date	2011.09.07.15.24.10;	author tg;	state Exp;
branches;
next	1.481;
commitid	1004E678C6929FE60A6;

1.481
date	2011.08.27.18.06.38;	author tg;	state Exp;
branches;
next	1.480;
commitid	1004E5932432420AA61;

1.480
date	2011.08.27.17.30.02;	author tg;	state Exp;
branches;
next	1.479;
commitid	1004E5929AF6944B2F7;

1.479
date	2011.07.26.16.57.25;	author tg;	state Exp;
branches;
next	1.478;
commitid	1004E2EF1DA23EC569A;

1.478
date	2011.07.20.23.47.26;	author tg;	state Exp;
branches;
next	1.477;
commitid	1004E2769127AE0E854;

1.477
date	2011.07.18.00.35.44;	author tg;	state Exp;
branches;
next	1.476;
commitid	1004E237FF1656D5846;

1.476
date	2011.07.16.17.08.50;	author tg;	state Exp;
branches;
next	1.475;
commitid	1004E21C5B66E327FE0;

1.475
date	2011.07.16.17.08.35;	author tg;	state Exp;
branches;
next	1.474;
commitid	1004E21C5A7151D13A4;

1.474
date	2011.07.07.21.02.39;	author tg;	state Exp;
branches
	1.474.2.1;
next	1.473;
commitid	1004E161EF17151176A;

1.473
date	2011.07.07.20.24.50;	author tg;	state Exp;
branches;
next	1.472;
commitid	1004E1615FC6FBD8000;

1.472
date	2011.07.06.22.21.54;	author tg;	state Exp;
branches;
next	1.471;
commitid	1004E14E010182825E7;

1.471
date	2011.07.05.20.12.15;	author tg;	state Exp;
branches;
next	1.470;
commitid	1004E136FF75DBF04C7;

1.470
date	2011.07.02.17.57.37;	author tg;	state Exp;
branches;
next	1.469;
commitid	1004E0F5C27271F5B00;

1.469
date	2011.06.30.13.48.09;	author tg;	state Exp;
branches;
next	1.468;
commitid	1004E0C7EAF5586D53A;

1.468
date	2011.06.21.21.50.23;	author tg;	state Exp;
branches;
next	1.467;
commitid	1004E011236502496A9;

1.467
date	2011.06.12.14.58.43;	author tg;	state Exp;
branches;
next	1.466;
commitid	1004DF4D43A005DAB99;

1.466
date	2011.06.11.03.14.47;	author tg;	state Exp;
branches;
next	1.465;
commitid	1004DF2DDB52CEA0AB1;

1.465
date	2011.06.09.21.53.12;	author tg;	state Exp;
branches;
next	1.464;
commitid	1004DF140C1236A2FC4;

1.464
date	2011.06.09.21.26.21;	author tg;	state Exp;
branches;
next	1.463;
commitid	1004DF13A8F1A5102CA;

1.463
date	2011.06.09.21.10.50;	author tg;	state Exp;
branches;
next	1.462;
commitid	1004DF136EC1CB9552F;

1.462
date	2011.06.05.19.58.16;	author tg;	state Exp;
branches;
next	1.461;
commitid	1004DEBDFBB243C0DCF;

1.461
date	2011.06.05.16.49.54;	author tg;	state Exp;
branches;
next	1.460;
commitid	1004DEBB3C825354423;

1.460
date	2011.06.04.17.08.11;	author tg;	state Exp;
branches;
next	1.459;
commitid	1004DEA669273070090;

1.459
date	2011.06.04.16.42.28;	author tg;	state Exp;
branches;
next	1.458;
commitid	1004DEA608B78E32C69;

1.458
date	2011.06.04.16.11.16;	author tg;	state Exp;
branches;
next	1.457;
commitid	1004DEA592B5E41F86E;

1.457
date	2011.05.29.16.38.58;	author tg;	state Exp;
branches;
next	1.456;
commitid	1004DE276A92F927DD3;

1.456
date	2011.05.29.16.31.40;	author tg;	state Exp;
branches;
next	1.455;
commitid	1004DE274F9085CC4DD;

1.455
date	2011.05.29.02.18.47;	author tg;	state Exp;
branches;
next	1.454;
commitid	1004DE1AD11046BEFFC;

1.454
date	2011.05.07.02.02.45;	author tg;	state Exp;
branches;
next	1.453;
commitid	1004DC4A8485CCBD93D;

1.453
date	2011.05.07.00.51.09;	author tg;	state Exp;
branches;
next	1.452;
commitid	1004DC49710562ACCB2;

1.452
date	2011.05.07.00.02.26;	author tg;	state Exp;
branches;
next	1.451;
commitid	1004DC48C216861E5B0;

1.451
date	2011.05.06.15.41.21;	author tg;	state Exp;
branches;
next	1.450;
commitid	1004DC416672F61DF37;

1.450
date	2011.05.05.00.04.55;	author tg;	state Exp;
branches;
next	1.449;
commitid	1004DC1E8D640072140;

1.449
date	2011.05.04.23.16.00;	author tg;	state Exp;
branches;
next	1.448;
commitid	1004DC1DE466716BC29;

1.448
date	2011.05.02.22.52.49;	author tg;	state Exp;
branches;
next	1.447;
commitid	1004DBF35D72295ADB7;

1.447
date	2011.04.22.21.44.33;	author tg;	state Exp;
branches;
next	1.446;
commitid	1004DB1F6D813825DD9;

1.446
date	2011.04.17.12.24.42;	author tg;	state Exp;
branches;
next	1.445;
commitid	1004DAADC101DEEF61A;

1.445
date	2011.04.09.18.47.12;	author tg;	state Exp;
branches;
next	1.444;
commitid	1004DA0A9C665117993;

1.444
date	2011.04.09.15.39.50;	author tg;	state Exp;
branches;
next	1.443;
commitid	1004DA07DD273BEDC62;

1.443
date	2011.04.02.10.30.09;	author tg;	state Exp;
branches;
next	1.442;
commitid	1004D96FAB20883B7FB;

1.442
date	2011.03.28.21.58.06;	author tg;	state Exp;
branches;
next	1.441;
commitid	1004D91046C6E5458E6;

1.441
date	2011.03.28.21.30.59;	author tg;	state Exp;
branches;
next	1.440;
commitid	1004D90FE1962742D4E;

1.440
date	2011.03.28.21.18.00;	author tg;	state Exp;
branches;
next	1.439;
commitid	1004D90FAFF7CB5F058;

1.439
date	2011.03.28.08.40.40;	author tg;	state Exp;
branches;
next	1.438;
commitid	1004D90499F536528A9;

1.438
date	2011.03.27.18.50.02;	author tg;	state Exp;
branches;
next	1.437;
commitid	1004D8F86AA0EB92572;

1.437
date	2011.03.26.21.46.00;	author tg;	state Exp;
branches;
next	1.436;
commitid	1004D8E5E8E09438DF7;

1.436
date	2011.03.26.21.09.06;	author tg;	state Exp;
branches;
next	1.435;
commitid	1004D8E55EE760E733C;

1.435
date	2011.03.26.16.19.29;	author tg;	state Exp;
branches;
next	1.434;
commitid	1004D8E1228321D538C;

1.434
date	2011.03.26.16.11.41;	author tg;	state Exp;
branches;
next	1.433;
commitid	1004D8E104206A746DC;

1.433
date	2011.03.26.15.32.35;	author tg;	state Exp;
branches;
next	1.432;
commitid	1004D8E071E7181147C;

1.432
date	2011.03.23.18.47.04;	author tg;	state Exp;
branches;
next	1.431;
commitid	1004D8A3FE2288AD1B5;

1.431
date	2011.03.21.21.57.32;	author tg;	state Exp;
branches;
next	1.430;
commitid	1004D87C9AA1AA37C2E;

1.430
date	2011.03.17.22.09.20;	author tg;	state Exp;
branches;
next	1.429;
commitid	1004D8286A619CA67D7;

1.429
date	2011.03.16.20.56.30;	author tg;	state Exp;
branches;
next	1.428;
commitid	1004D8124057DD4A66A;

1.428
date	2011.03.16.20.26.34;	author tg;	state Exp;
branches;
next	1.427;
commitid	1004D811CB27C272DCB;

1.427
date	2011.03.13.17.07.08;	author tg;	state Exp;
branches;
next	1.426;
commitid	1004D7CF9D12F4B30ED;

1.426
date	2011.03.13.16.20.43;	author tg;	state Exp;
branches;
next	1.425;
commitid	1004D7CEEE36D4AFEF8;

1.425
date	2011.03.13.16.03.49;	author tg;	state Exp;
branches;
next	1.424;
commitid	1004D7CE9C2063207F0;

1.424
date	2011.03.13.15.57.21;	author tg;	state Exp;
branches;
next	1.423;
commitid	1004D7CE96D48E85688;

1.423
date	2011.03.13.01.20.14;	author tg;	state Exp;
branches;
next	1.422;
commitid	1004D7C1BE368F5B459;

1.422
date	2011.03.12.23.06.41;	author tg;	state Exp;
branches;
next	1.421;
commitid	1004D7BFC863E01C4BA;

1.421
date	2011.03.12.23.04.44;	author tg;	state Exp;
branches;
next	1.420;
commitid	1004D7BFC0825FC39FC;

1.420
date	2011.03.12.20.20.14;	author tg;	state Exp;
branches;
next	1.419;
commitid	1004D7BD58B625DCEEE;

1.419
date	2011.03.12.01.04.39;	author tg;	state Exp;
branches;
next	1.418;
commitid	1004D7AC6AF5830C908;

1.418
date	2011.03.08.18.49.48;	author tg;	state Exp;
branches;
next	1.417;
commitid	1004D767A1867ED392F;

1.417
date	2011.03.07.20.32.48;	author tg;	state Exp;
branches;
next	1.416;
commitid	1004D7540D21019BF2E;

1.416
date	2011.03.06.17.08.10;	author tg;	state Exp;
branches;
next	1.415;
commitid	1004D73BF8011CAE269;

1.415
date	2011.03.06.17.06.17;	author tg;	state Exp;
branches;
next	1.414;
commitid	1004D73BEAF0394E9FB;

1.414
date	2011.03.06.01.50.08;	author tg;	state Exp;
branches;
next	1.413;
commitid	1004D72E7B5122D1766;

1.413
date	2011.02.27.19.41.17;	author tg;	state Exp;
branches;
next	1.412;
commitid	1004D6AA8F241A7D94D;

1.412
date	2011.02.27.19.31.34;	author tg;	state Exp;
branches;
next	1.411;
commitid	1004D6AA6A36BBB0DEF;

1.411
date	2011.02.27.19.29.20;	author tg;	state Exp;
branches;
next	1.410;
commitid	1004D6AA624642CC00C;

1.410
date	2011.02.19.21.39.14;	author tg;	state Exp;
branches;
next	1.409;
commitid	1004D60389335112D60;

1.409
date	2011.02.18.22.26.06;	author tg;	state Exp;
branches;
next	1.408;
commitid	1004D5EF0ED2C0C9394;

1.408
date	2011.02.13.21.13.05;	author tg;	state Exp;
branches;
next	1.407;
commitid	1004D58496015725548;

1.407
date	2011.02.11.01.18.15;	author tg;	state Exp;
branches;
next	1.406;
commitid	1004D548C4E66D17A12;

1.406
date	2011.02.09.13.08.24;	author tg;	state Exp;
branches;
next	1.405;
commitid	1004D5291DC3026B343;

1.405
date	2011.02.03.15.57.49;	author tg;	state Exp;
branches;
next	1.404;
commitid	1004D4ACE420C09213B;

1.404
date	2011.01.30.02.18.25;	author tg;	state Exp;
branches;
next	1.403;
commitid	1004D44CA872095D3BD;

1.403
date	2011.01.30.01.35.56;	author tg;	state Exp;
branches;
next	1.402;
commitid	1004D44C0920D39CB07;

1.402
date	2011.01.30.01.35.32;	author tg;	state Exp;
branches;
next	1.401;
commitid	1004D44C07439762D63;

1.401
date	2011.01.22.20.33.11;	author tg;	state Exp;
branches;
next	1.400;
commitid	1004D3B3F1E5091C6CD;

1.400
date	2011.01.21.22.25.31;	author tg;	state Exp;
branches;
next	1.399;
commitid	1004D3A07DC22BE01C9;

1.399
date	2011.01.21.22.00.17;	author tg;	state Exp;
branches;
next	1.398;
commitid	1004D3A01F81243EE3A;

1.398
date	2011.01.09.21.57.22;	author tg;	state Exp;
branches;
next	1.397;
commitid	1004D2A2F086B2268F4;

1.397
date	2010.12.19.20.00.53;	author tg;	state Exp;
branches;
next	1.396;
commitid	1004D0E647B738BDF7F;

1.396
date	2010.11.01.17.29.00;	author tg;	state Exp;
branches;
next	1.395;
commitid	1004CCEF8F323B360DC;

1.395
date	2010.10.01.19.04.37;	author tg;	state Exp;
branches;
next	1.394;
commitid	1004CA6307E2EE8E957;

1.394
date	2010.09.19.19.28.21;	author tg;	state Exp;
branches;
next	1.393;
commitid	1004C96645E6EA59306;

1.393
date	2010.09.15.21.08.16;	author tg;	state Exp;
branches;
next	1.392;
commitid	1004C9135BE7A0C39AD;

1.392
date	2010.09.14.21.26.07;	author tg;	state Exp;
branches;
next	1.391;
commitid	1004C8FE654576B0E25;

1.391
date	2010.09.05.19.51.29;	author tg;	state Exp;
branches;
next	1.390;
commitid	1004C83F4BE00D43672;

1.390
date	2010.08.28.20.22.13;	author tg;	state Exp;
branches;
next	1.389;
commitid	1004C796FE40C544CCE;

1.389
date	2010.08.28.17.21.41;	author tg;	state Exp;
branches;
next	1.388;
commitid	1004C7945A20EB8DDA4;

1.388
date	2010.08.24.15.47.44;	author tg;	state Exp;
branches;
next	1.387;
commitid	1004C73E9B75CB3A5F6;

1.387
date	2010.08.24.14.42.00;	author tg;	state Exp;
branches;
next	1.386;
commitid	1004C73D9D62A68EAE7;

1.386
date	2010.07.25.11.35.38;	author tg;	state Exp;
branches;
next	1.385;
commitid	1004C4C211F2951575A;

1.385
date	2010.07.24.17.08.28;	author tg;	state Exp;
branches;
next	1.384;
commitid	1004C4B1E2355F50980;

1.384
date	2010.07.21.11.31.13;	author tg;	state Exp;
branches;
next	1.383;
commitid	1004C46DA7D68DDD451;

1.383
date	2010.07.19.22.41.01;	author tg;	state Exp;
branches;
next	1.382;
commitid	1004C44D3437C9C37AE;

1.382
date	2010.07.17.22.09.30;	author tg;	state Exp;
branches;
next	1.381;
commitid	1004C42295452E71B6E;

1.381
date	2010.07.13.13.12.28;	author tg;	state Exp;
branches;
next	1.380;
commitid	1004C3C662810A34ABB;

1.380
date	2010.07.11.11.17.29;	author tg;	state Exp;
branches;
next	1.379;
commitid	1004C39A83931615597;

1.379
date	2010.07.04.17.45.11;	author tg;	state Exp;
branches;
next	1.378;
commitid	1004C30C8946816B0C1;

1.378
date	2010.05.22.12.49.13;	author tg;	state Exp;
branches;
next	1.377;
commitid	1004BF7D29E03EBF637;

1.377
date	2010.05.16.19.17.41;	author tg;	state Exp;
branches;
next	1.376;
commitid	1004BF044D8775327C1;

1.376
date	2010.05.16.19.04.40;	author tg;	state Exp;
branches;
next	1.375;
commitid	1004BF041CB522EEEE3;

1.375
date	2010.04.27.21.39.06;	author tg;	state Exp;
branches;
next	1.374;
commitid	1004BD75943684FFAB4;

1.374
date	2010.04.20.09.10.05;	author tg;	state Exp;
branches;
next	1.373;
commitid	1004BCD6F5E78E50C4E;

1.373
date	2010.04.09.19.16.29;	author tg;	state Exp;
branches;
next	1.372;
commitid	1004BBF7CD656308A1C;

1.372
date	2010.04.09.14.46.43;	author tg;	state Exp;
branches;
next	1.371;
commitid	1004BBF3DDD1B0BEFEB;

1.371
date	2010.04.08.13.21.03;	author tg;	state Exp;
branches;
next	1.370;
commitid	1004BBDD84556472D84;

1.370
date	2010.03.27.16.53.15;	author tg;	state Exp;
branches;
next	1.369;
commitid	1004BAE380B7133518B;

1.369
date	2010.03.18.19.45.39;	author tg;	state Exp;
branches;
next	1.368;
commitid	1004BA282EB0AE29D07;

1.368
date	2010.03.16.21.32.47;	author tg;	state Exp;
branches;
next	1.367;
commitid	1004B9FF8FC2F159F09;

1.367
date	2010.03.14.11.58.30;	author tg;	state Exp;
branches;
next	1.366;
commitid	1004B9CCF5B34BE8F30;

1.366
date	2010.03.01.17.28.05;	author tg;	state Exp;
branches;
next	1.365;
commitid	1004B8BF9300396B2A4;

1.365
date	2010.02.25.20.18.14;	author tg;	state Exp;
branches;
next	1.364;
commitid	1004B86DB1A7C6BCE8B;

1.364
date	2010.02.25.11.47.33;	author tg;	state Exp;
branches;
next	1.363;
commitid	1004B86624714E5AA6A;

1.363
date	2010.02.23.21.51.49;	author tg;	state Exp;
branches;
next	1.362;
commitid	1004B844DFD34FFF311;

1.362
date	2010.02.23.18.13.00;	author tg;	state Exp;
branches;
next	1.361;
commitid	1004B841A9A1A72C896;

1.361
date	2010.02.18.17.31.22;	author tg;	state Exp;
branches;
next	1.360;
commitid	1004B7D796C24BBD8E1;

1.360
date	2010.02.18.17.30.19;	author tg;	state Exp;
branches;
next	1.359;
commitid	1004B7D793E5C62B3A2;

1.359
date	2010.01.29.09.34.25;	author tg;	state Exp;
branches;
next	1.358;
commitid	1004B62ABB7333ED94C;

1.358
date	2010.01.28.20.58.30;	author tg;	state Exp;
branches;
next	1.357;
commitid	1004B61FA7F4ADB96C5;

1.357
date	2010.01.28.15.18.46;	author tg;	state Exp;
branches;
next	1.356;
commitid	1004B61A9B525E85DF5;

1.356
date	2010.01.25.14.25.13;	author tg;	state Exp;
branches;
next	1.355;
commitid	1004B5DA9D162A0E82B;

1.355
date	2010.01.25.14.11.25;	author tg;	state Exp;
branches;
next	1.354;
commitid	1004B5DA60A56BFB604;

1.354
date	2010.01.08.22.21.03;	author tg;	state Exp;
branches;
next	1.353;
commitid	1004B47AF75223D4923;

1.353
date	2010.01.04.21.08.00;	author tg;	state Exp;
branches;
next	1.352;
commitid	1004B4258B12709215B;

1.352
date	2010.01.01.18.01.59;	author tg;	state Exp;
branches;
next	1.351;
commitid	1004B3E388722B20246;

1.351
date	2010.01.01.17.44.06;	author tg;	state Exp;
branches;
next	1.350;
commitid	1004B3E342E71FBD2B2;

1.350
date	2009.12.31.14.05.42;	author tg;	state Exp;
branches;
next	1.349;
commitid	1004B3CAF8C011FFD00;

1.349
date	2009.12.12.22.27.03;	author tg;	state Exp;
branches;
next	1.348;
commitid	1004B2418AF282F4231;

1.348
date	2009.12.05.17.43.43;	author tg;	state Exp;
branches;
next	1.347;
commitid	1004B1A9BCF3E49BC5B;

1.347
date	2009.12.01.19.15.31;	author tg;	state Exp;
branches;
next	1.346;
commitid	1004B156B29488E0456;

1.346
date	2009.11.28.15.38.28;	author tg;	state Exp;
branches;
next	1.345;
commitid	1004B1144002949633C;

1.345
date	2009.11.28.14.27.58;	author tg;	state Exp;
branches;
next	1.344;
commitid	1004B11334F4604E973;

1.344
date	2009.11.28.14.21.41;	author tg;	state Exp;
branches;
next	1.343;
commitid	1004B1131E93EDF1403;

1.343
date	2009.11.22.14.25.17;	author tg;	state Exp;
branches
	1.343.2.1;
next	1.342;
commitid	1004B0949E239806ED4;

1.342
date	2009.11.22.14.13.38;	author tg;	state Exp;
branches;
next	1.341;
commitid	1004B09472703F7AC0E;

1.341
date	2009.11.21.23.23.16;	author tg;	state Exp;
branches;
next	1.340;
commitid	1004B08764D5928E063;

1.340
date	2009.11.21.22.32.05;	author tg;	state Exp;
branches;
next	1.339;
commitid	1004B086A791F2A4544;

1.339
date	2009.11.21.22.30.34;	author tg;	state Exp;
branches;
next	1.338;
commitid	1004B0869F632AFA7FC;

1.338
date	2009.11.21.22.29.12;	author tg;	state Exp;
branches;
next	1.337;
commitid	1004B0869C13792921C;

1.337
date	2009.11.09.23.35.07;	author tg;	state Exp;
branches;
next	1.336;
commitid	1004AF8A72F40172587;

1.336
date	2009.10.30.00.57.35;	author tg;	state Exp;
branches;
next	1.335;
commitid	1004AEA39BD3F10ECFA;

1.335
date	2009.10.27.17.00.00;	author tg;	state Exp;
branches;
next	1.334;
commitid	1004AE726F77A03CF56;

1.334
date	2009.10.18.12.30.04;	author tg;	state Exp;
branches;
next	1.333;
commitid	1004ADB0A4708185E1A;

1.333
date	2009.10.17.21.16.01;	author tg;	state Exp;
branches;
next	1.332;
commitid	1004ADA339B53B8111A;

1.332
date	2009.10.15.16.36.25;	author tg;	state Exp;
branches;
next	1.331;
commitid	1004AD74F846B061D71;

1.331
date	2009.10.15.16.32.23;	author tg;	state Exp;
branches;
next	1.330;
commitid	1004AD74E934EDEF4D8;

1.330
date	2009.10.15.16.24.49;	author tg;	state Exp;
branches;
next	1.329;
commitid	1004AD74CB74FA718C4;

1.329
date	2009.10.15.16.15.03;	author tg;	state Exp;
branches;
next	1.328;
commitid	1004AD74A7A31147019;

1.328
date	2009.10.15.15.32.34;	author tg;	state Exp;
branches;
next	1.327;
commitid	1004AD7409140AF7580;

1.327
date	2009.10.15.15.23.41;	author tg;	state Exp;
branches;
next	1.326;
commitid	1004AD73E85603E916C;

1.326
date	2009.10.15.14.58.50;	author tg;	state Exp;
branches;
next	1.325;
commitid	1004AD738B244722004;

1.325
date	2009.10.15.14.12.46;	author tg;	state Exp;
branches;
next	1.324;
commitid	1004AD72DEB6F4CF9F6;

1.324
date	2009.10.15.12.50.11;	author tg;	state Exp;
branches;
next	1.323;
commitid	1004AD71A934E0E0BBF;

1.323
date	2009.10.14.18.06.57;	author tg;	state Exp;
branches;
next	1.322;
commitid	1004AD6132B0F54405C;

1.322
date	2009.10.14.18.04.52;	author tg;	state Exp;
branches;
next	1.321;
commitid	1004AD612D4723CDB68;

1.321
date	2009.10.10.21.17.28;	author tg;	state Exp;
branches;
next	1.320;
commitid	1004AD0F97B0E1CF3C3;

1.320
date	2009.10.10.17.39.48;	author tg;	state Exp;
branches;
next	1.319;
commitid	1004AD0C6FB3140C98E;

1.319
date	2009.10.04.13.19.32;	author tg;	state Exp;
branches;
next	1.318;
commitid	1004AC8A0EC1AB8E5E0;

1.318
date	2009.10.04.12.45.21;	author tg;	state Exp;
branches;
next	1.317;
commitid	1004AC898E1751BB935;

1.317
date	2009.10.04.12.44.18;	author tg;	state Exp;
branches;
next	1.316;
commitid	1004AC898AF2FF5CD5F;

1.316
date	2009.10.04.03.13.06;	author tg;	state Exp;
branches;
next	1.315;
commitid	1004AC812CD5B4C3E22;

1.315
date	2009.10.02.18.08.31;	author tg;	state Exp;
branches;
next	1.314;
commitid	1004AC641341D9D9D02;

1.314
date	2009.10.02.17.05.01;	author tg;	state Exp;
branches;
next	1.313;
commitid	1004AC632C378EB11C9;

1.313
date	2009.10.02.16.59.53;	author tg;	state Exp;
branches;
next	1.312;
commitid	1004AC6319E01CEF8CA;

1.312
date	2009.09.29.12.28.12;	author tg;	state Exp;
branches;
next	1.311;
commitid	1004AC1FD4F2AA51F2E;

1.311
date	2009.09.26.03.39.57;	author tg;	state Exp;
branches;
next	1.310;
commitid	1004ABD8CE62D55CFD8;

1.310
date	2009.09.24.17.15.29;	author tg;	state Exp;
branches;
next	1.309;
commitid	1004ABBA8D95908292B;

1.309
date	2009.09.23.18.04.53;	author tg;	state Exp;
branches;
next	1.308;
commitid	1004ABA62C8171BD8E4;

1.308
date	2009.09.20.17.23.49;	author tg;	state Exp;
branches;
next	1.307;
commitid	1004AB6650915B0514A;

1.307
date	2009.09.19.21.54.42;	author tg;	state Exp;
branches;
next	1.306;
commitid	1004AB552F7546C611E;

1.306
date	2009.09.19.18.36.57;	author tg;	state Exp;
branches;
next	1.305;
commitid	1004AB524D471D78F40;

1.305
date	2009.09.07.17.24.47;	author tg;	state Exp;
branches;
next	1.304;
commitid	1004AA541E5370FC6A6;

1.304
date	2009.09.06.17.55.53;	author tg;	state Exp;
branches;
next	1.303;
commitid	1004AA3F6E1614843D5;

1.303
date	2009.09.06.17.42.11;	author tg;	state Exp;
branches;
next	1.302;
commitid	1004AA3F479204C1E97;

1.302
date	2009.08.30.21.01.59;	author tg;	state Exp;
branches;
next	1.301;
commitid	1004A9AE8B12FB2C70D;

1.301
date	2009.08.28.22.46.19;	author tg;	state Exp;
branches
	1.301.2.1;
next	1.300;
commitid	1004A985E1C5618CC94;

1.300
date	2009.08.28.21.35.42;	author tg;	state Exp;
branches;
next	1.299;
commitid	1004A984DB66A4BFF43;

1.299
date	2009.08.08.13.08.48;	author tg;	state Exp;
branches;
next	1.298;
commitid	1004A7D785D73D49CFA;

1.298
date	2009.08.01.21.57.52;	author tg;	state Stab;
branches;
next	1.297;
commitid	1004A74BA73747FE283;

1.297
date	2009.08.01.14.21.29;	author tg;	state Exp;
branches;
next	1.296;
commitid	1004A744F781627353F;

1.296
date	2009.07.30.19.11.09;	author tg;	state Exp;
branches;
next	1.295;
commitid	1004A71F04C54EFD9CF;

1.295
date	2009.07.25.21.31.24;	author tg;	state Exp;
branches;
next	1.294;
commitid	1004A6B79B87CB15A8B;

1.294
date	2009.07.25.20.52.40;	author tg;	state Exp;
branches;
next	1.293;
commitid	1004A6B70886FFC8C3F;

1.293
date	2009.07.19.11.14.28;	author tg;	state Exp;
branches;
next	1.292;
commitid	1004A63001236648A6F;

1.292
date	2009.07.19.11.03.18;	author tg;	state Exp;
branches;
next	1.291;
commitid	1004A62FD6973CD37DE;

1.291
date	2009.07.16.15.06.42;	author tg;	state Exp;
branches;
next	1.290;
commitid	1004A5F412E6BBABCED;

1.290
date	2009.07.06.15.06.23;	author tg;	state Exp;
branches;
next	1.289;
commitid	1004A5212AD490123A5;

1.289
date	2009.07.05.13.56.46;	author tg;	state Exp;
branches;
next	1.288;
commitid	1004A50B0E3697D221C;

1.288
date	2009.06.11.12.42.15;	author tg;	state Exp;
branches;
next	1.287;
commitid	1004A30FBB114E3FED9;

1.287
date	2009.06.10.18.11.25;	author tg;	state Stab;
branches;
next	1.286;
commitid	1004A2FF764542B3C7D;

1.286
date	2009.06.08.20.34.38;	author tg;	state Exp;
branches;
next	1.285;
commitid	1004A2D75D22EFFE1BD;

1.285
date	2009.06.07.22.43.46;	author tg;	state Exp;
branches;
next	1.284;
commitid	1004A2C42A16AE665FA;

1.284
date	2009.06.07.22.28.04;	author tg;	state Exp;
branches;
next	1.283;
commitid	1004A2C3EEE42B8D086;

1.283
date	2009.06.06.14.23.17;	author tg;	state Exp;
branches;
next	1.282;
commitid	1004A2A7BE052D188F4;

1.282
date	2009.05.31.15.10.06;	author tg;	state Stab;
branches;
next	1.281;
commitid	1004A229DBA2308E628;

1.281
date	2009.05.27.19.52.35;	author tg;	state Stab;
branches;
next	1.280;
commitid	1004A1D99540BF61ECF;

1.280
date	2009.05.27.09.58.21;	author tg;	state Stab;
branches;
next	1.279;
commitid	1004A1D0E9B4EF3C493;

1.279
date	2009.05.21.14.28.32;	author tg;	state Exp;
branches;
next	1.278;
commitid	1004A156526780370CA;

1.278
date	2009.05.20.10.10.00;	author tg;	state Exp;
branches;
next	1.277;
commitid	1004A13D70259491252;

1.277
date	2009.05.16.18.40.04;	author tg;	state Exp;
branches;
next	1.276;
commitid	1004A0F087409E93A5D;

1.276
date	2009.05.16.16.59.32;	author tg;	state Exp;
branches;
next	1.275;
commitid	1004A0EF0664EF4168D;

1.275
date	2009.05.16.16.03.41;	author tg;	state Exp;
branches;
next	1.274;
commitid	1004A0EE3ED034006CF;

1.274
date	2009.05.16.15.53.00;	author tg;	state Exp;
branches;
next	1.273;
commitid	1004A0EE0AF7BF1B8E7;

1.273
date	2009.05.16.14.19.20;	author tg;	state Exp;
branches;
next	1.272;
commitid	1004A0ECB577CA34B34;

1.272
date	2009.04.22.16.43.18;	author tg;	state Exp;
branches;
next	1.271;
commitid	10049EF493039137B14;

1.271
date	2009.04.08.18.00.53;	author tg;	state Exp;
branches;
next	1.270;
commitid	10049DCE664266CCC38;

1.270
date	2009.04.07.19.43.26;	author tg;	state Exp;
branches;
next	1.269;
commitid	10049DBACB7766F4210;

1.269
date	2009.04.06.08.33.36;	author tg;	state Exp;
branches;
next	1.268;
commitid	10049D9BE5254CE65B8;

1.268
date	2009.04.05.12.35.29;	author tg;	state Exp;
branches;
next	1.267;
commitid	10049D8A5A72FBB1A39;

1.267
date	2009.04.03.09.39.03;	author tg;	state Exp;
branches;
next	1.266;
commitid	10049D5D94A2E5145F0;

1.266
date	2009.03.25.21.45.27;	author tg;	state Exp;
branches;
next	1.265;
commitid	10049CAA57F1436902F;

1.265
date	2009.03.22.18.50.42;	author tg;	state Exp;
branches;
next	1.264;
commitid	10049C68886608D7379;

1.264
date	2009.03.22.18.28.33;	author tg;	state Exp;
branches;
next	1.263;
commitid	10049C6834E4ED058A4;

1.263
date	2009.03.22.15.47.23;	author tg;	state Exp;
branches;
next	1.262;
commitid	10049C65D1659411931;

1.262
date	2009.03.21.11.09.35;	author tg;	state Exp;
branches;
next	1.261;
commitid	10049C4CAE318512B62;

1.261
date	2009.03.17.13.56.46;	author tg;	state Exp;
branches;
next	1.260;
commitid	10049BFAC131C8B19AE;

1.260
date	2009.03.16.15.50.11;	author tg;	state Exp;
branches;
next	1.259;
commitid	10049BE751056775D85;

1.259
date	2009.03.16.15.14.22;	author tg;	state Exp;
branches;
next	1.258;
commitid	10049BE6CB22E3BA1BA;

1.258
date	2009.03.15.16.13.37;	author tg;	state Exp;
branches;
next	1.257;
commitid	10049BD293E126777AC;

1.257
date	2009.03.14.18.12.50;	author tg;	state Exp;
branches;
next	1.256;
commitid	10049BBF38A0ADEDD54;

1.256
date	2009.02.22.18.02.30;	author tg;	state Exp;
branches;
next	1.255;
commitid	10049A192E10DAA38C8;

1.255
date	2009.02.20.13.25.08;	author tg;	state Exp;
branches;
next	1.254;
commitid	100499EAF33578C4C3D;

1.254
date	2008.12.29.21.34.18;	author tg;	state Exp;
branches;
next	1.253;
commitid	10049594263416D2C1C;

1.253
date	2008.12.17.19.39.21;	author tg;	state Exp;
branches;
next	1.252;
commitid	100494955754640680F;

1.252
date	2008.12.13.17.02.11;	author tg;	state Exp;
branches;
next	1.251;
commitid	1004943EAA830C0300B;

1.251
date	2008.12.08.13.57.35;	author tg;	state Exp;
branches;
next	1.250;
commitid	100493D27DC4CA4103F;

1.250
date	2008.12.04.18.11.03;	author tg;	state Exp;
branches;
next	1.249;
commitid	10049381D2D4EEC022C;

1.249
date	2008.12.02.13.19.28;	author tg;	state Exp;
branches;
next	1.248;
commitid	100493535F65A121AF9;

1.248
date	2008.12.02.12.48.16;	author tg;	state Exp;
branches;
next	1.247;
commitid	10049352E9F5DBF7056;

1.247
date	2008.12.02.12.39.36;	author tg;	state Exp;
branches;
next	1.246;
commitid	10049352BD82DFF462F;

1.246
date	2008.11.30.16.57.40;	author tg;	state Exp;
branches;
next	1.245;
commitid	1004932C5E13BE95032;

1.245
date	2008.11.30.16.53.15;	author tg;	state Exp;
branches;
next	1.244;
commitid	1004932C50019AA6D3B;

1.244
date	2008.11.30.10.45.42;	author tg;	state Exp;
branches;
next	1.243;
commitid	10049326EAC5BCD11BB;

1.243
date	2008.11.12.04.55.17;	author tg;	state Exp;
branches
	1.243.2.1;
next	1.242;
commitid	100491A618E0C3BD225;

1.242
date	2008.11.10.19.33.07;	author tg;	state Exp;
branches;
next	1.241;
commitid	10049188C7F54ACF524;

1.241
date	2008.11.09.20.32.16;	author tg;	state Exp;
branches;
next	1.240;
commitid	1004917488700179B64;

1.240
date	2008.11.08.17.36.35;	author tg;	state Exp;
branches;
next	1.239;
commitid	1004915CDEC427B69F6;

1.239
date	2008.11.02.23.03.45;	author tg;	state Exp;
branches;
next	1.238;
commitid	100490E31C36EC37DBF;

1.238
date	2008.11.02.22.29.35;	author tg;	state Exp;
branches;
next	1.237;
commitid	100490E29A42BDC6B59;

1.237
date	2008.10.28.14.32.37;	author tg;	state Exp;
branches;
next	1.236;
commitid	1004907226D3DEFCCD1;

1.236
date	2008.10.26.20.59.39;	author tg;	state Exp;
branches;
next	1.235;
commitid	1004904DA0662727312;

1.235
date	2008.10.24.21.35.42;	author tg;	state Exp;
branches;
next	1.234;
commitid	10049023FBE3B7E383F;

1.234
date	2008.10.24.19.54.22;	author tg;	state Exp;
branches;
next	1.233;
commitid	100490228041C0CEA7E;

1.233
date	2008.10.20.19.29.23;	author tg;	state Exp;
branches;
next	1.232;
commitid	10048FCDBAF5C7D98EB;

1.232
date	2008.10.19.20.15.42;	author tg;	state Exp;
branches;
next	1.231;
commitid	10048FB954E53F4A93C;

1.231
date	2008.10.15.10.24.59;	author tg;	state Exp;
branches;
next	1.230;
commitid	10048F5C4D32F55458D;

1.230
date	2008.10.13.23.06.01;	author tg;	state Exp;
branches;
next	1.229;
commitid	10048F3D44866CCA1C2;

1.229
date	2008.10.10.21.30.41;	author tg;	state Exp;
branches;
next	1.228;
commitid	10048EFC9600438B1CB;

1.228
date	2008.10.05.16.06.42;	author tg;	state Exp;
branches;
next	1.227;
commitid	10048E8E61D7FB7DA17;

1.227
date	2008.10.04.23.08.01;	author tg;	state Exp;
branches;
next	1.226;
commitid	10048E7F7686DB8B02F;

1.226
date	2008.09.30.19.36.15;	author tg;	state Exp;
branches;
next	1.225;
commitid	10048E27FA3426E07E4;

1.225
date	2008.09.30.18.43.06;	author tg;	state Exp;
branches;
next	1.224;
commitid	10048E2733A0C205E40;

1.224
date	2008.09.20.19.17.59;	author tg;	state Exp;
branches;
next	1.223;
commitid	10048D54C486245FBD7;

1.223
date	2008.09.19.10.41.55;	author tg;	state Exp;
branches;
next	1.222;
commitid	10048D381FB4FE85EE7;

1.222
date	2008.09.17.19.31.28;	author tg;	state Exp;
branches;
next	1.221;
commitid	10048D15ABE2EA76C75;

1.221
date	2008.09.14.20.24.57;	author tg;	state Exp;
branches;
next	1.220;
commitid	10048CD722B0B2BCCBE;

1.220
date	2008.08.02.17.45.10;	author tg;	state Exp;
branches;
next	1.219;
commitid	10048949D196A7C1390;

1.219
date	2008.07.18.11.33.11;	author tg;	state Exp;
branches;
next	1.218;
commitid	10048807F804EE06E7A;

1.218
date	2008.07.17.13.00.38;	author tg;	state Exp;
branches;
next	1.217;
commitid	100487F428C18E1E35B;

1.217
date	2008.07.17.12.57.59;	author tg;	state Exp;
branches;
next	1.216;
commitid	100487F41DD1AB6B1C9;

1.216
date	2008.07.14.12.29.04;	author tg;	state Exp;
branches;
next	1.215;
commitid	100487B467E068A55D6;

1.215
date	2008.07.12.18.09.36;	author tg;	state Exp;
branches;
next	1.214;
commitid	1004878F3774388017F;

1.214
date	2008.07.11.19.51.23;	author tg;	state Exp;
branches;
next	1.213;
commitid	1004877B9A442EF6CF3;

1.213
date	2008.07.11.00.23.59;	author tg;	state Exp;
branches;
next	1.212;
commitid	1004876A8134F8D18AC;

1.212
date	2008.07.10.21.55.08;	author tg;	state Exp;
branches;
next	1.211;
commitid	1004876854B3C9E6F3B;

1.211
date	2008.07.10.21.25.00;	author tg;	state Exp;
branches;
next	1.210;
commitid	10048767E3F5AE38DCD;

1.210
date	2008.07.10.21.20.22;	author tg;	state Exp;
branches;
next	1.209;
commitid	10048767D0F1689D51E;

1.209
date	2008.07.10.20.05.01;	author tg;	state Exp;
branches;
next	1.208;
commitid	10048766B7735C32A73;

1.208
date	2008.07.10.19.06.15;	author tg;	state Exp;
branches;
next	1.207;
commitid	10048765D9053D4998B;

1.207
date	2008.07.09.21.32.42;	author tg;	state Exp;
branches;
next	1.206;
commitid	10048752E6271CABA24;

1.206
date	2008.07.09.20.31.19;	author tg;	state Exp;
branches;
next	1.205;
commitid	1004875200900D4A6AF;

1.205
date	2008.07.08.22.29.00;	author tg;	state Exp;
branches;
next	1.204;
commitid	1004873EA351F36F30D;

1.204
date	2008.07.08.20.54.33;	author tg;	state Exp;
branches;
next	1.203;
commitid	1004873D390242FC589;

1.203
date	2008.07.08.20.08.02;	author tg;	state Exp;
branches;
next	1.202;
commitid	1004873C92D02477D52;

1.202
date	2008.07.06.22.41.07;	author tg;	state Exp;
branches;
next	1.201;
commitid	10048714A14702F5007;

1.201
date	2008.06.28.22.51.54;	author tg;	state Exp;
branches;
next	1.200;
commitid	1004866BFA427FDEFB9;

1.200
date	2008.06.21.19.30.49;	author tg;	state Exp;
branches;
next	1.199;
commitid	100485D56C35F5D7C55;

1.199
date	2008.06.21.19.20.15;	author tg;	state Exp;
branches;
next	1.198;
commitid	100485D546D2A4FC22F;

1.198
date	2008.06.08.17.15.29;	author tg;	state Exp;
branches;
next	1.197;
commitid	100484C13C7725BA294;

1.197
date	2008.06.02.20.44.07;	author tg;	state Exp;
branches;
next	1.196;
commitid	10048445B835C5E170D;

1.196
date	2008.05.17.18.27.54;	author tg;	state Exp;
branches;
next	1.195;
commitid	100482F238341D5E08C;

1.195
date	2008.05.15.15.24.09;	author tg;	state Exp;
branches;
next	1.194;
commitid	100482C558039271D26;

1.194
date	2008.05.10.03.16.07;	author tg;	state Exp;
branches;
next	1.193;
commitid	1004825133715611188;

1.193
date	2008.05.04.01.59.46;	author tg;	state Exp;
branches;
next	1.192;
commitid	100481D18A278423D59;

1.192
date	2008.05.04.01.51.29;	author tg;	state Exp;
branches;
next	1.191;
commitid	100481D16AF3E4A7EEA;

1.191
date	2008.05.04.01.39.12;	author tg;	state Exp;
branches;
next	1.190;
commitid	100481D13C830D53D71;

1.190
date	2008.05.04.01.38.04;	author tg;	state Exp;
branches;
next	1.189;
commitid	100481D137677DB4E1B;

1.189
date	2008.05.02.18.55.35;	author tg;	state Exp;
branches;
next	1.188;
commitid	100481B63B51233676D;

1.188
date	2008.04.22.19.00.40;	author tg;	state Exp;
branches;
next	1.187;
commitid	100480E35EF0AEDC30B;

1.187
date	2008.04.20.21.30.28;	author tg;	state Exp;
branches;
next	1.186;
commitid	100480BB5E564A443DA;

1.186
date	2008.04.20.01.23.49;	author tg;	state Exp;
branches;
next	1.185;
commitid	100480A9B283425738D;

1.185
date	2008.04.20.01.12.52;	author tg;	state Exp;
branches;
next	1.184;
commitid	100480A987E0448546D;

1.184
date	2008.04.20.00.56.17;	author tg;	state Exp;
branches;
next	1.183;
commitid	100480A94B60CE723CD;

1.183
date	2008.04.20.00.45.49;	author tg;	state Exp;
branches;
next	1.182;
commitid	100480A92412E7ED39A;

1.182
date	2008.04.20.00.28.30;	author tg;	state Exp;
branches;
next	1.181;
commitid	100480A8E2A26A01B6E;

1.181
date	2008.04.20.00.24.25;	author tg;	state Exp;
branches;
next	1.180;
commitid	100480A8D4556C8D90D;

1.180
date	2008.04.20.00.11.29;	author tg;	state Exp;
branches;
next	1.179;
commitid	100480A89DC506002DB;

1.179
date	2008.04.19.23.49.58;	author tg;	state Exp;
branches;
next	1.178;
commitid	100480A853206FB56FA;

1.178
date	2008.04.19.22.15.01;	author tg;	state Exp;
branches;
next	1.177;
commitid	100480A6CC85EC0197B;

1.177
date	2008.04.19.22.03.18;	author tg;	state Exp;
branches;
next	1.176;
commitid	100480A6C2D2168D617;

1.176
date	2008.04.19.21.04.08;	author tg;	state Exp;
branches;
next	1.175;
commitid	100480A5E532EE94633;

1.175
date	2008.04.16.21.56.00;	author tg;	state Exp;
branches;
next	1.174;
commitid	100480675E12E8ACD98;

1.174
date	2008.04.11.19.55.23;	author tg;	state Exp;
branches;
next	1.173;
commitid	10047FFC1677D373ADF;

1.173
date	2008.04.02.17.09.45;	author tg;	state Exp;
branches;
next	1.172;
commitid	10047F3BDD1120A1937;

1.172
date	2008.04.01.21.39.44;	author tg;	state Exp;
branches;
next	1.171;
commitid	10047F2AB9D6BAD2B9B;

1.171
date	2008.04.01.21.07.20;	author tg;	state Exp;
branches;
next	1.170;
commitid	10047F2A3D72AA337FC;

1.170
date	2008.04.01.20.40.21;	author tg;	state Exp;
branches;
next	1.169;
commitid	10047F29D740D1FD5B8;

1.169
date	2008.04.01.17.25.37;	author tg;	state Exp;
branches;
next	1.168;
commitid	10047F270227C3BD64A;

1.168
date	2008.04.01.17.22.54;	author tg;	state Exp;
branches;
next	1.167;
commitid	10047F26F7E1E387A7C;

1.167
date	2008.04.01.16.26.42;	author tg;	state Exp;
branches;
next	1.166;
commitid	10047F262500C561EB4;

1.166
date	2008.04.01.16.12.18;	author tg;	state Exp;
branches;
next	1.165;
commitid	10047F25EDB7CCCC21F;

1.165
date	2008.04.01.16.04.58;	author tg;	state Exp;
branches;
next	1.164;
commitid	10047F25D3E39FFA060;

1.164
date	2008.04.01.16.01.45;	author tg;	state Exp;
branches;
next	1.163;
commitid	10047F25C6F4BD3F9BA;

1.163
date	2008.03.28.13.46.51;	author tg;	state Exp;
branches;
next	1.162;
commitid	10047ECF6A15422B64A;

1.162
date	2008.03.25.21.34.44;	author tg;	state Exp;
branches;
next	1.161;
commitid	10047E96EF5608C6FD5;

1.161
date	2008.03.23.22.09.57;	author tg;	state Exp;
branches;
next	1.160;
commitid	10047E6D4C4222CC17E;

1.160
date	2008.03.23.20.54.29;	author tg;	state Exp;
branches;
next	1.159;
commitid	10047E6C38C68A226BC;

1.159
date	2008.03.23.20.43.51;	author tg;	state Exp;
branches;
next	1.158;
commitid	10047E6C1181328D84A;

1.158
date	2008.03.05.18.21.44;	author tg;	state Exp;
branches
	1.158.2.1;
next	1.157;
commitid	10047CEE3A0658866A1;

1.157
date	2008.03.01.22.58.22;	author tg;	state Rel;
branches;
next	1.156;
commitid	10047C9DF91418B07F0;

1.156
date	2008.03.01.21.24.58;	author tg;	state Rel;
branches;
next	1.155;
commitid	10047C9C9B76D05CEA1;

1.155
date	2008.03.01.21.10.25;	author tg;	state Exp;
branches;
next	1.154;
commitid	10047C9C64165F71A5A;

1.154
date	2008.03.01.17.14.17;	author tg;	state Exp;
branches;
next	1.153;
commitid	10047C98EF24733E10E;

1.153
date	2008.03.01.16.40.57;	author tg;	state Exp;
branches;
next	1.152;
commitid	10047C987267D5738C3;

1.152
date	2008.03.01.02.21.36;	author tg;	state Stab;
branches;
next	1.151;
commitid	10047C8BDBC04C448EC;

1.151
date	2008.02.29.16.38.40;	author tg;	state Exp;
branches;
next	1.150;
commitid	10047C8350F6BECB74A;

1.150
date	2008.02.29.11.48.32;	author tg;	state Exp;
branches;
next	1.149;
commitid	10047C7F11E25C9D944;

1.149
date	2008.02.27.12.49.53;	author tg;	state Exp;
branches;
next	1.148;
commitid	10047C55C8411C92E34;

1.148
date	2008.02.27.11.24.11;	author tg;	state Exp;
branches;
next	1.147;
commitid	10047C5484566B4BB83;

1.147
date	2008.02.26.20.43.10;	author tg;	state Exp;
branches;
next	1.146;
commitid	10047C479E866D4A3E1;

1.146
date	2008.02.25.00.58.24;	author tg;	state Exp;
branches;
next	1.145;
commitid	10047C2102904204374;

1.145
date	2008.02.24.22.12.36;	author tg;	state Exp;
branches;
next	1.144;
commitid	10047C1EBA57E4F4AF0;

1.144
date	2008.02.24.15.57.20;	author tg;	state Exp;
branches;
next	1.143;
commitid	10047C193886D1669C9;

1.143
date	2008.02.24.15.48.42;	author tg;	state Exp;
branches;
next	1.142;
commitid	10047C190EF15EAB550;

1.142
date	2007.10.25.13.51.18;	author tg;	state Exp;
branches;
next	1.141;
commitid	10047209F6430D35627;

1.141
date	2007.10.18.20.32.31;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004717C2CE427DDAE7;

1.140
date	2007.10.14.13.43.40;	author tg;	state Exp;
branches;
next	1.139;
commitid	10047121D1A56A79186;

1.139
date	2007.10.09.14.50.49;	author tg;	state Exp;
branches;
next	1.138;
commitid	100470B94ED68BBDDDB;

1.138
date	2007.09.09.18.06.38;	author tg;	state Exp;
branches;
next	1.137;
commitid	10046E436442CDF8871;

1.137
date	2007.09.07.23.57.14;	author tg;	state Exp;
branches;
next	1.136;
commitid	10046E1E56B59B81E06;

1.136
date	2007.08.19.22.06.25;	author tg;	state Exp;
branches;
next	1.135;
commitid	10046C8BEC1249CCADD;

1.135
date	2007.08.18.00.22.07;	author tg;	state Exp;
branches;
next	1.134;
commitid	10046C63BBA357F61D4;

1.134
date	2007.08.13.19.39.19;	author tg;	state Exp;
branches;
next	1.133;
commitid	10046C0B31A6F414C8F;

1.133
date	2007.08.12.13.42.20;	author tg;	state Exp;
branches;
next	1.132;
commitid	10046BF0E4F7055959B;

1.132
date	2007.07.31.11.11.23;	author tg;	state Exp;
branches;
next	1.131;
commitid	10046AF18D74B1B5DF4;

1.131
date	2007.07.26.13.23.51;	author tg;	state Exp;
branches;
next	1.130;
commitid	10046A8A03C41A44494;

1.130
date	2007.07.24.11.22.03;	author tg;	state Exp;
branches;
next	1.129;
commitid	10046A5E0B320FF6D65;

1.129
date	2007.07.23.14.28.51;	author tg;	state Exp;
branches;
next	1.128;
commitid	10046A4BABC39976409;

1.128
date	2007.07.23.14.10.48;	author tg;	state Exp;
branches;
next	1.127;
commitid	10046A4B6EF4765F3EA;

1.127
date	2007.07.22.13.46.14;	author tg;	state Exp;
branches;
next	1.126;
commitid	10046A35F6D6E418744;

1.126
date	2007.07.17.13.56.50;	author tg;	state Exp;
branches;
next	1.125;
commitid	100469CCA9508D35977;

1.125
date	2007.07.06.11.54.34;	author tg;	state Exp;
branches;
next	1.124;
commitid	100468E2D796F17D9A2;

1.124
date	2007.07.06.02.22.55;	author tg;	state Exp;
branches;
next	1.123;
commitid	100468DA78E140683C0;

1.123
date	2007.07.06.01.37.39;	author tg;	state Exp;
branches;
next	1.122;
commitid	100468D9CF32FFE8692;

1.122
date	2007.07.06.01.30.32;	author tg;	state Exp;
branches;
next	1.121;
commitid	100468D9B454CA0A0C3;

1.121
date	2007.07.05.11.49.07;	author tg;	state Exp;
branches;
next	1.120;
commitid	100468CDABA2D14BAC6;

1.120
date	2007.07.01.21.27.03;	author tg;	state Exp;
branches;
next	1.119;
commitid	10046881C10526620B9;

1.119
date	2007.07.01.19.04.52;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004687FAEA6DAA2FEC;

1.118
date	2007.06.27.23.12.58;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004682EDC82ADECDD6;

1.117
date	2007.06.23.22.48.47;	author tg;	state Exp;
branches;
next	1.116;
commitid	100467DA3531C67FC3A;

1.116
date	2007.06.22.23.34.40;	author tg;	state Exp;
branches;
next	1.115;
commitid	100467C5C9519B9C52A;

1.115
date	2007.06.21.16.04.45;	author tg;	state Exp;
branches;
next	1.114;
commitid	100467AA19E39838981;

1.114
date	2007.06.17.00.50.07;	author tg;	state Exp;
branches;
next	1.113;
commitid	100467485062D380C8D;

1.113
date	2007.06.15.21.55.18;	author tg;	state Exp;
branches;
next	1.112;
commitid	10046730AA46E14A9D1;

1.112
date	2007.06.09.22.02.04;	author tg;	state Exp;
branches;
next	1.111;
commitid	100466B23725C5F0D89;

1.111
date	2007.06.06.23.28.12;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004667430836D68E66;

1.110
date	2007.06.05.19.48.46;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004665BE264E72FCFA;

1.109
date	2007.06.04.21.33.27;	author tg;	state Exp;
branches;
next	1.108;
commitid	100466485304A0BD517;

1.108
date	2007.05.24.19.50.38;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004655EC9E76698127;

1.107
date	2007.05.22.19.31.00;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004653450509FD4B71;

1.106
date	2007.05.21.19.25.30;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004651F21443013C37;

1.105
date	2007.05.20.17.53.12;	author tg;	state Exp;
branches;
next	1.104;
commitid	10046508B0376038FC6;

1.104
date	2007.05.13.19.18.26;	author tg;	state Exp;
branches;
next	1.103;
commitid	1004647649434DA3FE1;

1.103
date	2007.05.10.19.22.10;	author tg;	state Exp;
branches;
next	1.102;
commitid	100464370BA2BF5141D;

1.102
date	2007.05.10.19.08.47;	author tg;	state Exp;
branches;
next	1.101;
commitid	10046436DC35AC3B04F;

1.101
date	2007.04.23.21.46.12;	author tg;	state Exp;
branches
	1.101.2.1;
next	1.100;
commitid	100462D29255C993722;

1.100
date	2007.04.17.23.51.32;	author tg;	state Exp;
branches;
next	1.99;
commitid	10046255D8C44AF10A4;

1.99
date	2007.04.17.14.00.00;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004624D2EA2F97574D;

1.98
date	2007.04.15.12.28.37;	author tg;	state Exp;
branches;
next	1.97;
commitid	10046221A4C48C9FA1F;

1.97
date	2007.04.15.12.09.56;	author tg;	state Exp;
branches;
next	1.96;
commitid	100462215D23B394727;

1.96
date	2007.04.15.10.58.55;	author tg;	state Exp;
branches;
next	1.95;
commitid	100462205464A560B6B;

1.95
date	2007.04.15.10.45.58;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004622020D73FDDAF8;

1.94
date	2007.03.14.02.41.08;	author tg;	state Exp;
branches;
next	1.93;
commitid	10045F760A869FD5E0F;

1.93
date	2007.03.10.00.42.00;	author tg;	state Exp;
branches;
next	1.92;
commitid	10045F1FEDD0DDDFF00;

1.92
date	2007.03.04.03.04.23;	author tg;	state Exp;
branches;
next	1.91;
commitid	10045EA374B3374AB35;

1.91
date	2007.02.16.17.46.41;	author tg;	state Exp;
branches;
next	1.90;
commitid	10045D5EDDE0036A745;

1.90
date	2007.02.07.02.31.06;	author tg;	state Exp;
branches;
next	1.89;
commitid	10045C93A007420BE03;

1.89
date	2007.01.26.18.27.33;	author tg;	state Exp;
branches;
next	1.88;
commitid	10045BA47F3716BA1F6;

1.88
date	2007.01.18.16.13.29;	author tg;	state Exp;
branches;
next	1.87;
commitid	10045AF9CB62D80C64D;

1.87
date	2007.01.18.16.05.05;	author tg;	state Exp;
branches;
next	1.86;
commitid	10045AF9AC06E556EEF;

1.86
date	2007.01.18.15.50.32;	author tg;	state Exp;
branches;
next	1.85;
commitid	10045AF974442B3F2AC;

1.85
date	2007.01.18.01.10.55;	author tg;	state Exp;
branches;
next	1.84;
commitid	10045AEC90F0029F8FC;

1.84
date	2007.01.17.01.24.28;	author tg;	state Exp;
branches;
next	1.83;
commitid	10045AD7A912A404713;

1.83
date	2007.01.15.00.38.19;	author tg;	state Exp;
branches;
next	1.82;
commitid	10045AACD0F0A446E5A;

1.82
date	2007.01.12.10.18.19;	author tg;	state Exp;
branches
	1.82.2.1;
next	1.81;
commitid	10045A76059104E0EFB;

1.81
date	2007.01.12.00.25.39;	author tg;	state Exp;
branches;
next	1.80;
commitid	10045A6D3B866AF7B2F;

1.80
date	2007.01.11.02.08.50;	author tg;	state Exp;
branches;
next	1.79;
commitid	10045A59C3424354B8C;

1.79
date	2007.01.11.00.32.30;	author tg;	state Exp;
branches;
next	1.78;
commitid	10045A5858664A950E2;

1.78
date	2007.01.06.17.08.14;	author tg;	state Exp;
branches;
next	1.77;
commitid	100459FD7720F90D30E;

1.77
date	2007.01.03.22.43.47;	author tg;	state Exp;
branches;
next	1.76;
commitid	100459C318675D901E0;

1.76
date	2006.12.11.16.09.49;	author tg;	state Exp;
branches;
next	1.75;
commitid	100457D82CF336F1707;

1.75
date	2006.11.19.16.43.41;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004560891159DD45F6;

1.74
date	2006.11.12.10.44.41;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004556FB165B715FFA;

1.73
date	2006.11.10.06.18.05;	author tg;	state Exp;
branches;
next	1.72;
commitid	100455419640DA65E63;

1.72
date	2006.11.10.01.13.50;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004553D1A316532A65;

1.71
date	2006.11.09.15.02.30;	author tg;	state Exp;
branches;
next	1.70;
commitid	100455343104AF09372;

1.70
date	2006.11.08.23.45.46;	author tg;	state Exp;
branches;
next	1.69;
commitid	10045526C372A4C60AB;

1.69
date	2006.11.05.17.01.46;	author tg;	state Exp;
branches;
next	1.68;
commitid	100454E18FF508FB3FE;

1.68
date	2006.11.05.12.11.13;	author tg;	state Exp;
branches;
next	1.67;
commitid	100454DD4E712F5401D;

1.67
date	2006.09.30.02.13.20;	author tg;	state Exp;
branches;
next	1.66;
commitid	100451DD2A867E0A573;

1.66
date	2006.09.21.22.08.26;	author tg;	state Exp;
branches;
next	1.65;
commitid	10045130D623B37AD66;

1.65
date	2006.09.07.13.25.14;	author tg;	state Exp;
branches;
next	1.64;
commitid	10045001DC65B30FBAE;

1.64
date	2006.08.28.17.42.55;	author tg;	state Exp;
branches;
next	1.63;
commitid	10044F32B27495FFC51;

1.63
date	2006.08.28.01.40.54;	author tg;	state Exp;
branches;
next	1.62;
commitid	10044F2496074AF1C95;

1.62
date	2006.08.26.20.30.27;	author tg;	state Exp;
branches;
next	1.61;
commitid	10044F0AF574E06B6B7;

1.61
date	2006.08.24.20.50.02;	author tg;	state Exp;
branches;
next	1.60;
commitid	10044EE11053CD24B77;

1.60
date	2006.08.24.20.35.40;	author tg;	state Exp;
branches;
next	1.59;
commitid	10044EE0D877DE1179E;

1.59
date	2006.08.22.22.49.33;	author tg;	state Exp;
branches;
next	1.58;
commitid	10044EB89CB27D175DB;

1.58
date	2006.08.18.13.41.09;	author tg;	state Exp;
branches;
next	1.57;
commitid	10044E5C38857D899E1;

1.57
date	2006.08.18.13.40.15;	author tg;	state Exp;
branches;
next	1.56;
commitid	10044E5C34431A7C593;

1.56
date	2006.08.14.20.41.21;	author tg;	state Exp;
branches
	1.56.2.1;
next	1.55;
commitid	10044E0DFE179777366;

1.55
date	2006.08.14.20.36.39;	author tg;	state Exp;
branches;
next	1.54;
commitid	10044E0DEDD65757709;

1.54
date	2006.08.09.20.44.15;	author tg;	state Exp;
branches;
next	1.53;
commitid	10044DA49163318158B;

1.53
date	2006.08.09.20.21.08;	author tg;	state Exp;
branches;
next	1.52;
commitid	10044DA43B975FB987F;

1.52
date	2006.08.08.20.17.20;	author tg;	state Exp;
branches;
next	1.51;
commitid	10044D8F142232C4BC7;

1.51
date	2006.08.02.13.34.02;	author tg;	state Exp;
branches;
next	1.50;
commitid	10044D0A9BF316488D2;

1.50
date	2006.08.02.12.38.45;	author tg;	state Exp;
branches;
next	1.49;
commitid	10044D09CDD46141E15;

1.49
date	2006.08.02.11.50.28;	author tg;	state Exp;
branches;
next	1.48;
commitid	10044D091507AB5F673;

1.48
date	2006.08.01.12.44.16;	author tg;	state Exp;
branches;
next	1.47;
commitid	10044CF4CA571D18180;

1.47
date	2006.07.23.14.35.43;	author tg;	state Exp;
branches;
next	1.46;
commitid	10044C38956068FA76E;

1.46
date	2006.07.11.14.51.00;	author tg;	state Exp;
branches;
next	1.45;
commitid	10044B3BAD83E16AC82;

1.45
date	2006.07.07.09.52.20;	author tg;	state Exp;
branches;
next	1.44;
commitid	10044AE2ED02BFE5C20;

1.44
date	2006.07.03.12.16.29;	author tg;	state Exp;
branches;
next	1.43;
commitid	10044A90AAA1B255EDF;

1.43
date	2006.06.21.19.27.35;	author tg;	state Exp;
branches;
next	1.42;
commitid	10044999D9B6AABE232;

1.42
date	2006.05.27.11.36.50;	author tg;	state Exp;
branches;
next	1.41;
commitid	100447839C50DE18438;

1.41
date	2006.05.26.23.36.18;	author tg;	state Exp;
branches;
next	1.40;
commitid	100447790437FAB8D3E;

1.40
date	2006.05.10.19.30.32;	author tg;	state Exp;
branches;
next	1.39;
commitid	10044623F60676FC8A1;

1.39
date	2006.05.08.11.59.41;	author tg;	state Exp;
branches;
next	1.38;
commitid	100445F328D5580A1BA;

1.38
date	2006.05.08.11.42.36;	author tg;	state Exp;
branches;
next	1.37;
commitid	100445F2E0E7C37DD2F;

1.37
date	2006.01.29.20.56.54;	author tg;	state Exp;
branches;
next	1.36;
commitid	10043DD2B834A41FF17;

1.36
date	2005.11.22.18.40.40;	author tg;	state Exp;
branches;
next	1.35;
commitid	108a438366254326;

1.35
date	2005.11.22.18.36.19;	author tg;	state Exp;
branches;
next	1.34;
commitid	659a438364faa8a1;

1.34
date	2005.10.25.21.11.25;	author tg;	state Exp;
branches;
next	1.33;
commitid	4586435e9f8dd3c9;

1.33
date	2005.10.21.12.41.54;	author tg;	state Exp;
branches;
next	1.32;
commitid	657d4358e1e6ede8;

1.32
date	2005.10.08.19.30.58;	author tg;	state Exp;
branches;
next	1.31;
commitid	512643481e5274c0;

1.31
date	2005.10.08.18.53.09;	author tg;	state Exp;
branches;
next	1.30;
commitid	1a5e434815a40ffe;

1.30
date	2005.09.11.00.32.29;	author tg;	state Exp;
branches;
next	1.29;
commitid	1e5543237b2a21d0;

1.29
date	2005.08.26.22.03.55;	author tg;	state Exp;
branches;
next	1.28;
commitid	57a8430f91c30d91;

1.28
date	2005.08.21.13.02.16;	author tg;	state Exp;
branches;
next	1.27;
commitid	521743087b5a03be;

1.27
date	2005.08.02.12.35.25;	author tg;	state Exp;
branches;
next	1.26;
commitid	6dd542ef687afd87;

1.26
date	2005.07.07.23.27.52;	author tg;	state Exp;
branches;
next	1.25;
commitid	419f42cdba670de9;

1.25
date	2005.07.07.22.00.45;	author tg;	state Exp;
branches;
next	1.24;
commitid	32a042cda60d6277;

1.24
date	2005.07.06.00.02.05;	author tg;	state Exp;
branches;
next	1.23;
commitid	3c3f42cb1f724a1e;

1.23
date	2005.07.05.21.48.42;	author tg;	state Exp;
branches;
next	1.22;
commitid	691742cafffaf84a;

1.22
date	2005.07.04.12.48.12;	author tg;	state Exp;
branches;
next	1.21;
commitid	583a42c9301bd265;

1.21
date	2005.07.04.12.47.13;	author tg;	state Exp;
branches;
next	1.20;
commitid	499742c92fe4b090;

1.20
date	2005.07.04.12.27.25;	author tg;	state Exp;
branches;
next	1.19;
commitid	3ec342c92b3a8874;

1.19
date	2005.07.04.11.57.55;	author tg;	state Exp;
branches;
next	1.18;
commitid	347442c9243dac0e;

1.18
date	2005.06.24.15.42.03;	author tg;	state Exp;
branches;
next	1.17;
commitid	62f542bc29dbab38;

1.17
date	2005.06.08.21.51.20;	author tg;	state Exp;
branches;
next	1.16;
commitid	318442a76849872f;

1.16
date	2005.06.05.16.38.19;	author tg;	state Exp;
branches;
next	1.15;
commitid	329342a32a8e3325;

1.15
date	2005.05.28.21.02.02;	author tg;	state Exp;
branches;
next	1.14;
commitid	40b34298dc472142;

1.14
date	2005.05.25.14.39.33;	author tg;	state Exp;
branches;
next	1.13;
commitid	4a5e42948e22e28a;

1.13
date	2005.05.25.14.20.53;	author tg;	state Exp;
branches;
next	1.12;
commitid	7e47429489c96e26;

1.12
date	2005.05.25.13.50.15;	author tg;	state Exp;
branches;
next	1.11;
commitid	2415429482a9df54;

1.11
date	2005.05.25.11.37.23;	author tg;	state Exp;
branches;
next	1.10;
commitid	12224294637fc2bb;

1.10
date	2005.05.23.17.24.23;	author tg;	state Exp;
branches;
next	1.9;
commitid	24084292117f040d;

1.9
date	2005.05.23.17.00.24;	author tg;	state Exp;
branches;
next	1.8;
commitid	89a42920c30a5fc;

1.8
date	2005.05.23.16.23.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	1d3a429203880b55;

1.7
date	2005.05.23.16.17.00;	author tg;	state Exp;
branches;
next	1.6;
commitid	536842920205b584;

1.6
date	2005.05.23.15.54.30;	author tg;	state Exp;
branches;
next	1.5;
commitid	78044291fcc1aba2;

1.5
date	2005.05.23.15.03.04;	author tg;	state Exp;
branches;
next	1.4;
commitid	25b84291f0b4ce37;

1.4
date	2005.05.23.15.02.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	78014291f06497b3;

1.3
date	2005.05.23.14.48.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	7bf94291ed463ca9;

1.2
date	2005.05.23.14.07.40;	author tg;	state Exp;
branches;
next	1.1;
commitid	de44291e3a943e6;

1.1
date	2005.05.23.03.06.05;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.667.2.1
date	2015.01.11.22.39.40;	author tg;	state Exp;
branches;
next	1.667.2.2;
commitid	10054B2FBC1440F88AD;

1.667.2.2
date	2015.01.25.15.35.36;	author tg;	state Exp;
branches;
next	1.667.2.3;
commitid	10054C50D442D861FBF;

1.667.2.3
date	2015.03.01.15.42.51;	author tg;	state Exp;
branches;
next	1.667.2.4;
commitid	10054F33364551D895A;

1.667.2.4
date	2015.03.20.22.20.53;	author tg;	state Exp;
branches;
next	1.667.2.5;
commitid	100550C9D521FCB4274;

1.667.2.5
date	2015.03.21.00.12.36;	author tg;	state Exp;
branches;
next	1.667.2.6;
commitid	100550CB7886DC367A3;

1.667.2.6
date	2015.04.12.22.32.17;	author tg;	state Exp;
branches;
next	1.667.2.7;
commitid	100552AF26A429AA816;

1.667.2.7
date	2015.04.19.19.18.10;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.569.2.1
date	2012.12.04.01.26.15;	author tg;	state Exp;
branches;
next	1.569.2.2;
commitid	10050BD5149729CD584;

1.569.2.2
date	2012.12.05.19.58.25;	author tg;	state Exp;
branches;
next	1.569.2.3;
commitid	10050BFA7766B61F30F;

1.569.2.3
date	2012.12.07.23.46.19;	author tg;	state Exp;
branches;
next	1.569.2.4;
commitid	10050C27FDC255CF0A0;

1.569.2.4
date	2012.12.22.00.03.44;	author tg;	state Exp;
branches;
next	1.569.2.5;
commitid	10050D4F8C95001AF1D;

1.569.2.5
date	2013.01.01.21.19.57;	author tg;	state Exp;
branches;
next	1.569.2.6;
commitid	10050E352F23B706399;

1.569.2.6
date	2013.01.01.22.23.18;	author tg;	state Exp;
branches;
next	1.569.2.7;
commitid	10050E361E825906F7E;

1.569.2.7
date	2013.01.06.18.59.08;	author tg;	state Exp;
branches;
next	1.569.2.8;
commitid	10050E9C9931FE4587F;

1.569.2.8
date	2013.02.10.23.59.30;	author tg;	state Exp;
branches;
next	1.569.2.9;
commitid	100511834521EDC159D;

1.569.2.9
date	2013.02.15.18.54.36;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.549.2.1
date	2012.07.20.23.31.02;	author tg;	state Exp;
branches;
next	1.549.2.2;
commitid	1005009EA495F76B281;

1.549.2.2
date	2012.09.03.19.11.11;	author tg;	state Exp;
branches;
next	1.549.2.3;
commitid	100504500E6588900BA;

1.549.2.3
date	2013.02.11.00.27.07;	author tg;	state Exp;
branches;
next	1.549.2.4;
commitid	10051183A6D5475BB1E;

1.549.2.4
date	2013.02.15.18.54.47;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.474.2.1
date	2011.07.07.21.42.10;	author tg;	state Exp;
branches;
next	1.474.2.2;
commitid	1004E162810137500DE;

1.474.2.2
date	2011.07.16.16.04.08;	author tg;	state Exp;
branches;
next	1.474.2.3;
commitid	1004E21B64E3A80D0DC;

1.474.2.3
date	2011.07.26.17.17.27;	author tg;	state Exp;
branches;
next	1.474.2.4;
commitid	1004E2EF6BB28A13224;

1.474.2.4
date	2011.10.25.22.50.29;	author tg;	state Exp;
branches;
next	1.474.2.5;
commitid	1004EA73D456165B188;

1.474.2.5
date	2011.11.08.22.07.17;	author tg;	state Exp;
branches;
next	1.474.2.6;
commitid	1004EB9A7F80119200E;

1.474.2.6
date	2011.11.19.22.21.54;	author tg;	state Exp;
branches;
next	1.474.2.7;
commitid	1004EC82C02177E0E27;

1.474.2.7
date	2011.11.22.18.01.42;	author tg;	state Exp;
branches;
next	1.474.2.8;
commitid	1004ECBE39656891872;

1.474.2.8
date	2011.11.26.18.23.16;	author tg;	state Exp;
branches;
next	1.474.2.9;
commitid	1004ED12E8854A4E765;

1.474.2.9
date	2011.12.04.19.59.42;	author tg;	state Exp;
branches;
next	1.474.2.10;
commitid	1004EDBD1266A61D50A;

1.474.2.10
date	2011.12.11.18.18.20;	author tg;	state Exp;
branches;
next	1.474.2.11;
commitid	1004EE4F3FF0C99C8CA;

1.474.2.11
date	2011.12.31.02.25.24;	author tg;	state Exp;
branches;
next	1.474.2.12;
commitid	1004EFE72A268DB0925;

1.474.2.12
date	2012.02.11.15.25.29;	author tg;	state Exp;
branches;
next	1.474.2.13;
commitid	1004F36887A2CA1070B;

1.474.2.13
date	2012.03.03.21.41.39;	author tg;	state Exp;
branches;
next	1.474.2.14;
commitid	1004F529027715CBC71;

1.474.2.14
date	2012.03.24.21.22.30;	author tg;	state Exp;
branches;
next	1.474.2.15;
commitid	1004F6E3A967ACCD93A;

1.474.2.15
date	2012.04.06.14.40.11;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.343.2.1
date	2009.11.28.14.27.46;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.301.2.1
date	2009.08.30.20.56.03;	author tg;	state Exp;
branches;
next	1.301.2.2;
commitid	1004A9AE59203C5D0BB;

1.301.2.2
date	2009.09.01.16.19.47;	author tg;	state Exp;
branches;
next	1.301.2.3;
commitid	1004A9D49AF6E36323F;

1.301.2.3
date	2009.09.01.16.32.51;	author tg;	state Exp;
branches;
next	;
commitid	1004A9D4CB5529C2464;

1.243.2.1
date	2008.11.19.21.08.25;	author tg;	state Exp;
branches;
next	;
commitid	1004924805F7FD79D3D;

1.158.2.1
date	2008.04.22.13.29.21;	author tg;	state Exp;
branches;
next	1.158.2.2;
commitid	100480DE80F32BAA72D;

1.158.2.2
date	2008.05.19.18.41.16;	author tg;	state Exp;
branches;
next	1.158.2.3;
commitid	1004831C9A63DA06745;

1.158.2.3
date	2008.07.11.11.49.23;	author tg;	state Exp;
branches;
next	1.158.2.4;
commitid	100487748D62394D033;

1.158.2.4
date	2008.07.18.13.29.41;	author tg;	state Exp;
branches;
next	1.158.2.5;
commitid	10048809AD278B142AC;

1.158.2.5
date	2008.12.14.00.07.34;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.101.2.1
date	2007.05.13.19.29.31;	author tg;	state Exp;
branches;
next	1.101.2.2;
commitid	1004647668D4636830B;

1.101.2.2
date	2007.05.22.21.34.28;	author tg;	state Exp;
branches;
next	1.101.2.3;
commitid	100465361F206BD615D;

1.101.2.3
date	2007.05.26.22.31.19;	author tg;	state Exp;
branches;
next	1.101.2.4;
commitid	1004658B53E3CC3259F;

1.101.2.4
date	2007.07.05.11.49.14;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.82.2.1
date	2007.03.03.21.37.51;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;

1.56.2.1
date	2006.08.18.19.02.21;	author tg;	state Exp;
branches;
next	1.56.2.2;
commitid	10044E60ECD062A26B8;

1.56.2.2
date	2006.08.24.20.52.09;	author tg;	state Exp;
branches;
next	1.56.2.3;
commitid	10044EE117A130AF943;

1.56.2.3
date	2006.08.28.01.49.14;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.829
log
@add a new testcase that ksh93 fails, from IRC discussion

this is how mksh, GNU bash, posh, yash,  behave and POSIX likely demands
@
text
@# $MirOS: src/bin/mksh/check.t,v 1.826 2019/12/30 03:45:09 tg Exp $
# -*- mode: sh -*-
#-
# Copyright  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
#	      2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
#	      2019, 2020
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided AS IS and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said persons immediate fault when using the work as intended.
#-
# You may also want to test IFS with the script at
# http://www.research.att.com/~gsf/public/ifs.sh
#
# More testsuites at:
# http://svnweb.freebsd.org/base/head/bin/test/tests/legacy_test.sh?view=co&content-type=text%2Fplain
#
# Integrated testsuites from:
# (2013/12/02 20:39:44) http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/regress/bin/ksh/?sortby=date

expected-stdout:
	KSH R57 2019/12/29
description:
	Check base version of full shell
stdin:
	vsn=${KSH_VERSION%%' +'*}
	echo "${vsn#* }"
name: KSH_VERSION
---
expected-stdout:
	@@(#)MIRBSD
description:
	Check this identifies as legacy shell
stdin:
	echo "${KSH_VERSION%% *}"
name: KSH_VERSION-modern
category: !shell:legacy-yes
---
expected-stdout:
	@@(#)LEGACY
description:
	Check this identifies as legacy shell
stdin:
	echo "${KSH_VERSION%% *}"
name: KSH_VERSION-legacy
category: !shell:legacy-no
---
name: KSH_VERSION-ascii
description:
	Check that the shell version tag does not include EBCDIC
category: !shell:ebcdic-yes
stdin:
	set -o noglob
	for x in $KSH_VERSION; do
		[[ $x = '+EBCDIC' ]] && exit 1
	done
	exit 0
---
name: KSH_VERSION-ebcdic
description:
	Check that the shell version tag includes EBCDIC
category: !shell:ebcdic-no
stdin:
	set -o noglob
	for x in $KSH_VERSION; do
		[[ $x = '+EBCDIC' ]] && exit 0
	done
	exit 1
---
name: KSH_VERSION-binmode
description:
	Check that the shell version tag does not include TEXTMODE
category: !shell:textmode-yes
stdin:
	set -o noglob
	for x in $KSH_VERSION; do
		[[ $x = '+TEXTMODE' ]] && exit 1
	done
	exit 0
---
name: KSH_VERSION-textmode
description:
	Check that the shell version tag includes TEXTMODE
category: !shell:textmode-no
stdin:
	set -o noglob
	for x in $KSH_VERSION; do
		[[ $x = '+TEXTMODE' ]] && exit 0
	done
	exit 1
---
name: selftest-1
description:
	Regression test self-testing
stdin:
	echo ${foo:-baz}
expected-stdout:
	baz
---
name: selftest-2
description:
	Regression test self-testing
env-setup: !foo=bar!
stdin:
	echo ${foo:-baz}
expected-stdout:
	bar
---
name: selftest-3
description:
	Regression test self-testing
env-setup: !ENV=fnord!
stdin:
	echo "<$ENV>"
expected-stdout:
	<fnord>
---
name: selftest-exec
description:
	Ensure that the test run directory (default /tmp but can be changed
	with check.pl flag -T or test.sh $TMPDIR) is not mounted noexec, as
	we execute scripts from the scratch directory during several tests.
stdin:
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	./lq
expected-stdout:
	tf
---
name: selftest-env
description:
	Just output the environment variables set (always fails)
category: disabled
stdin:
	set
---
name: selftest-direct-builtin-call
description:
	Check that direct builtin calls work
stdin:
	ln -s "$__progname" cat || cp "$__progname" cat
	ln -s "$__progname" echo || cp "$__progname" echo
	./echo -c 'echo  foo' | ./cat -u
expected-stdout:
	-c echo  foo
---
name: selftest-pathsep-unix
description:
	Check that $PATHSEP is set correctly.
category: !os:os2
stdin:
	PATHSEP=.; export PATHSEP
	"$__progname" -c 'print -r -- $PATHSEP'
expected-stdout:
	:
---
name: selftest-pathsep-dospath
description:
	Check that $PATHSEP is set correctly.
category: os:os2
stdin:
	PATHSEP=.; export PATHSEP
	"$__progname" -c 'print -r -- $PATHSEP'
expected-stdout:
	;
---
name: selftest-tty-absent
description:
	Check that a controlling tty is not present as regress:no-ctty was used
	(if this test fails for you DO NOT PASS regress:no-ctty and fix every
	other test that fails: why u use it if u haz ctty?)
category: regress:no-ctty
env-setup: !ENV=./envf!
file-setup: file 644 "envf"
	PS1=X
arguments: !-i!
stdin:
	echo ok
expected-stdout:
	ok
expected-stderr-pattern:
	/ksh: warning: won't have full job control\nXX/
---
name: selftest-tty-present
description:
	Check that a controlling tty is present as regress:no-ctty was not used
need-ctty: yes
env-setup: !ENV=./envf!
file-setup: file 644 "envf"
	PS1=X
arguments: !-i!
stdin:
	echo ok
expected-stdout:
	ok
expected-stderr: !
	XX
---
name: alias-1
description:
	Check that recursion is detected/avoided in aliases.
stdin:
	alias fooBar=fooBar
	fooBar
	exit 0
expected-stderr-pattern:
	/fooBar.*not found.*/
---
name: alias-2
description:
	Check that recursion is detected/avoided in aliases.
stdin:
	alias fooBar=barFoo
	alias barFoo=fooBar
	fooBar
	barFoo
	exit 0
expected-stderr-pattern:
	/fooBar.*not found.*\n.*barFoo.*not found/
---
name: alias-3
description:
	Check that recursion is detected/avoided in aliases.
stdin:
	alias Echo='echo '
	alias fooBar=barFoo
	alias barFoo=fooBar
	Echo fooBar
	unalias barFoo
	Echo fooBar
expected-stdout:
	fooBar
	barFoo
---
name: alias-4
description:
	Check that alias expansion isn't done on keywords (in keyword
	postitions).
stdin:
	alias Echo='echo '
	alias while=While
	while false; do echo hi ; done
	Echo while
expected-stdout:
	While
---
name: alias-5
description:
	Check that alias expansion done after alias with trailing space.
stdin:
	alias Echo='echo '
	alias foo='bar stuff '
	alias bar='Bar1 Bar2 '
	alias stuff='Stuff'
	alias blah='Blah'
	Echo foo blah
expected-stdout:
	Bar1 Bar2 Stuff Blah
---
name: alias-6
description:
	Check that alias expansion done after alias with trailing space.
stdin:
	alias Echo='echo '
	alias foo='bar bar'
	alias bar='Bar '
	alias blah=Blah
	Echo foo blah
expected-stdout:
	Bar Bar Blah
---
name: alias-7
description:
	Check that alias expansion done after alias with trailing space
	after a keyword.
stdin:
	alias X='case '
	alias Y=Z
	X Y in 'Y') echo is y ;; Z) echo is z ;; esac
expected-stdout:
	is z
---
name: alias-8
description:
	Check that newlines in an alias don't cause the command to be lost.
stdin:
	alias foo='
	
	
	echo hi
	
	
	
	echo there
	
	
	'
	foo
expected-stdout:
	hi
	there
---
name: alias-9
description:
	Check that recursion is detected/avoided in aliases.
	This check fails for slow machines or Cygwin, raise
	the time-limit clause (e.g. to 7) if this occurs.
time-limit: 3
stdin:
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	PATH=$PWD$PATHSEP$PATH
	alias lq=lq
	lq
	echo = now
	i=`lq`
	print -r -- $i
	echo = out
	exit 0
expected-stdout:
	tf
	= now
	tf
	= out
---
name: alias-10
description:
	Check that recursion is detected/avoided in aliases.
	Regression, introduced during an old bugfix.
stdin:
	alias foo='print hello '
	alias bar='foo world'
	echo $(bar)
expected-stdout:
	hello world
---
name: alias-11
description:
	Check that special argument handling still applies with escaped aliases
stdin:
	alias local1='\typeset'
	alias local2='\\builtin typeset'
	function fooa {
		local1 x=$1 y=z
		print -r -- "$x,$y"
	}
	function foob {
		local2 x=$1 y=z
		print -r -- "$x,$y"
	}
	x=1 y=2; fooa 'bar - baz'
	x=1 y=2; foob 'bar - baz'
expected-stdout:
	bar - baz,z
	bar - baz,z
---
name: alias-12
description:
	Something weird from Martijn Dekker
stdin:
	alias echo=print
	x() { echo a; (echo b); x=$(echo c); }
	typeset -f x
	alias OPEN='{' CLOSE='};'
	{ OPEN echo hi1; CLOSE }
	var=`{ OPEN echo hi2; CLOSE }` && echo "$var"
	var=$({ OPEN echo hi3; CLOSE }) && echo "$var"
expected-stdout:
	x() {
		\print a 
		( \print b ) 
		x=$(\print c ) 
	} 
	hi1
	hi2
	hi3
---
name: arith-compound
description:
	Check that arithmetic expressions are compound constructs
stdin:
	{ ! (( 0$(cat >&2) )) <<<1; } <<<2
expected-stderr:
	1
---
name: arith-lazy-1
description:
	Check that only one side of ternary operator is evaluated
stdin:
	x=i+=2
	y=j+=2
	typeset -i i=1 j=1
	echo $((1 ? 20 : (x+=2)))
	echo $i,$x
	echo $((0 ? (y+=2) : 30))
	echo $j,$y
expected-stdout:
	20
	1,i+=2
	30
	1,j+=2
---
name: arith-lazy-2
description:
	Check that assignments not done on non-evaluated side of ternary
	operator
stdin:
	x=i+=2
	y=j+=2
	typeset -i i=1 j=1
	echo $((1 ? 20 : (x+=2)))
	echo $i,$x
	echo $((0 ? (y+=2) : 30))
	echo $i,$y
expected-stdout:
	20
	1,i+=2
	30
	1,j+=2
---
name: arith-lazy-3
description:
	Check that assignments not done on non-evaluated side of ternary
	operator and this construct is parsed correctly (Debian #445651)
stdin:
	x=4
	y=$((0 ? x=1 : 2))
	echo = $x $y =
expected-stdout:
	= 4 2 =
---
name: arith-lazy-4
description:
	Check that preun/postun not done on non-evaluated side of ternary
	operator
stdin:
	(( m = n = 0, 1 ? n++ : m++ ? 2 : 3 ))
	echo "($n, $m)"
	m=0; echo $(( 0 ? ++m : 2 )); echo $m
	m=0; echo $(( 0 ? m++ : 2 )); echo $m
expected-stdout:
	(1, 0)
	2
	0
	2
	0
---
name: arith-lazy-5-arr-n
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((0&&b[a++],a))"
expected-stdout:
	0
---
name: arith-lazy-5-arr-p
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((0&&(b[a++]),a))"
expected-stdout:
	0
---
name: arith-lazy-5-str-n
description: Check lazy evaluation with side effects
stdin:
	a=0 b=a++; ((0&&b)); echo $a
expected-stdout:
	0
---
name: arith-lazy-5-str-p
description: Check lazy evaluation with side effects
stdin:
	a=0 b=a++; ((0&&(b))); echo $a
expected-stdout:
	0
---
name: arith-lazy-5-tern-l-n
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((0?b[a++]:999,a))"
expected-stdout:
	0
---
name: arith-lazy-5-tern-l-p
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((0?(b[a++]):999,a))"
expected-stdout:
	0
---
name: arith-lazy-5-tern-r-n
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((1?999:b[a++],a))"
expected-stdout:
	0
---
name: arith-lazy-5-tern-r-p
description: Check lazy evaluation with side effects
stdin:
	a=0; echo "$((1?999:(b[a++]),a))"
expected-stdout:
	0
---
name: arith-ternary-prec-1
description:
	Check precedence of ternary operator vs assignment
stdin:
	typeset -i x=2
	y=$((1 ? 20 : x+=2))
expected-exit: e != 0
expected-stderr-pattern:
	/.*:.*1 \? 20 : x\+=2.*lvalue.*\n$/
---
name: arith-ternary-prec-2
description:
	Check precedence of ternary operator vs assignment
stdin:
	typeset -i x=2
	echo $((0 ? x+=2 : 20))
expected-stdout:
	20
---
name: arith-prec-1
description:
	Prove arithmetic expressions with embedded parameter
	substitutions cannot be parsed ahead of time
stdin:
	a='3 + 4'
	print 1 $((2 * a)) .
	print 2 $((2 * $a)) .
expected-stdout:
	1 14 .
	2 10 .
---
name: arith-div-assoc-1
description:
	Check associativity of division operator
stdin:
	echo $((20 / 2 / 2))
expected-stdout:
	5
---
name: arith-div-byzero
description:
	Check division by zero errors out
stdin:
	x=$(echo $((1 / 0)))
	echo =$?:$x.
expected-stdout:
	=1:.
expected-stderr-pattern:
	/.*divisor/
---
name: arith-div-intmin-by-minusone
description:
	Check division overflow wraps around silently
category: int:32
stdin:
	echo signed:$((-2147483648 / -1))r$((-2147483648 % -1)).
	echo unsigned:$((# -2147483648 / -1))r$((# -2147483648 % -1)).
expected-stdout:
	signed:-2147483648r0.
	unsigned:0r2147483648.
---
name: arith-div-intmin-by-minusone-64
description:
	Check division overflow wraps around silently
category: int:64
stdin:
	echo signed:$((-9223372036854775808 / -1))r$((-9223372036854775808 % -1)).
	echo unsigned:$((# -9223372036854775808 / -1))r$((# -9223372036854775808 % -1)).
expected-stdout:
	signed:-9223372036854775808r0.
	unsigned:0r9223372036854775808.
---
name: arith-assop-assoc-1
description:
	Check associativity of assignment-operator operator
stdin:
	typeset -i i=1 j=2 k=3
	echo $((i += j += k))
	echo $i,$j,$k
expected-stdout:
	6
	6,5,3
---
name: arith-mandatory
description:
	Passing of this test is *mandatory* for a valid mksh executable!
category: shell:legacy-no
stdin:
	typeset -i sari=0
	typeset -Ui uari=0
	typeset -i x=0
	print -r -- $((x++)):$sari=$uari. #0
	let --sari --uari
	print -r -- $((x++)):$sari=$uari. #1
	sari=2147483647 uari=2147483647
	print -r -- $((x++)):$sari=$uari. #2
	let ++sari ++uari
	print -r -- $((x++)):$sari=$uari. #3
	let --sari --uari
	let 'sari *= 2' 'uari *= 2'
	let ++sari ++uari
	print -r -- $((x++)):$sari=$uari. #4
	let ++sari ++uari
	print -r -- $((x++)):$sari=$uari. #5
	sari=-2147483648 uari=-2147483648
	print -r -- $((x++)):$sari=$uari. #6
	let --sari --uari
	print -r -- $((x++)):$sari=$uari. #7
	(( sari = -5 >> 1 ))
	((# uari = -5 >> 1 ))
	print -r -- $((x++)):$sari=$uari. #8
	(( sari = -2 ))
	((# uari = sari ))
	print -r -- $((x++)):$sari=$uari. #9
expected-stdout:
	0:0=0.
	1:-1=4294967295.
	2:2147483647=2147483647.
	3:-2147483648=2147483648.
	4:-1=4294967295.
	5:0=0.
	6:-2147483648=2147483648.
	7:2147483647=2147483647.
	8:-3=2147483645.
	9:-2=4294967294.
---
name: arith-unsigned-1
description:
	Check if unsigned arithmetics work
category: int:32
stdin:
	# signed vs unsigned
	echo x1 $((-1)) $((#-1))
	# calculating
	typeset -i vs
	typeset -Ui vu
	vs=4123456789; vu=4123456789
	echo x2 $vs $vu
	(( vs %= 2147483647 ))
	(( vu %= 2147483647 ))
	echo x3 $vs $vu
	vs=4123456789; vu=4123456789
	(( # vs %= 2147483647 ))
	(( # vu %= 2147483647 ))
	echo x4 $vs $vu
	# make sure the calculation does not change unsigned flag
	vs=4123456789; vu=4123456789
	echo x5 $vs $vu
	# short form
	echo x6 $((# vs % 2147483647)) $((# vu % 2147483647))
	# array refs
	set -A va
	va[1975973142]=right
	va[4123456789]=wrong
	echo x7 ${va[#4123456789%2147483647]}
	# make sure multiple calculations don't interfere with each other
	let '# mca = -4 % -2' ' mcb = -4 % -2'
	echo x8 $mca $mcb
expected-stdout:
	x1 -1 4294967295
	x2 -171510507 4123456789
	x3 -171510507 4123456789
	x4 1975973142 1975973142
	x5 -171510507 4123456789
	x6 1975973142 1975973142
	x7 right
	x8 -4 0
---
name: arith-limit32-1
description:
	Check if arithmetics are 32 bit
category: int:32
stdin:
	# signed vs unsigned
	echo x1 $((-1)) $((#-1))
	# calculating
	typeset -i vs
	typeset -Ui vu
	vs=2147483647; vu=2147483647
	echo x2 $vs $vu
	let vs++ vu++
	echo x3 $vs $vu
	vs=4294967295; vu=4294967295
	echo x4 $vs $vu
	let vs++ vu++
	echo x5 $vs $vu
	let vs++ vu++
	echo x6 $vs $vu
expected-stdout:
	x1 -1 4294967295
	x2 2147483647 2147483647
	x3 -2147483648 2147483648
	x4 -1 4294967295
	x5 0 0
	x6 1 1
---
name: arith-limit64-1
description:
	Check if arithmetics are 64 bit
category: int:64
stdin:
	# signed vs unsigned
	echo x1 $((-1)) $((#-1))
	# calculating
	typeset -i vs
	typeset -Ui vu
	vs=9223372036854775807; vu=9223372036854775807
	echo x2 $vs $vu
	let vs++ vu++
	echo x3 $vs $vu
	vs=18446744073709551615; vu=18446744073709551615
	echo x4 $vs $vu
	let vs++ vu++
	echo x5 $vs $vu
	let vs++ vu++
	echo x6 $vs $vu
expected-stdout:
	x1 -1 18446744073709551615
	x2 9223372036854775807 9223372036854775807
	x3 -9223372036854775808 9223372036854775808
	x4 -1 18446744073709551615
	x5 0 0
	x6 1 1
---
name: bksl-nl-ign-1
description:
	Check that \newline is not collapsed after #
stdin:
	echo hi #there \
	echo folks
expected-stdout:
	hi
	folks
---
name: bksl-nl-ign-2
description:
	Check that \newline is not collapsed inside single quotes
stdin:
	echo 'hi \
	there'
	echo folks
expected-stdout:
	hi \
	there
	folks
---
name: bksl-nl-ign-3
description:
	Check that \newline is not collapsed inside single quotes
stdin:
	cat << \EOF
	hi \
	there
	EOF
expected-stdout:
	hi \
	there
---
name: bksl-nl-ign-4
description:
	Check interaction of aliases, single quotes and here-documents
	with backslash-newline
	(don't know what POSIX has to say about this)
stdin:
	a=2
	alias x='echo hi
	cat << "EOF"
	foo\
	bar
	some'
	x
	more\
	stuff$a
	EOF
expected-stdout:
	hi
	foo\
	bar
	some
	more\
	stuff$a
---
name: bksl-nl-ign-5
description:
	Check what happens with backslash at end of input
	(the old Bourne shell trashes them; so do we)
stdin: !
	echo `echo foo\\`bar
	echo hi\
expected-stdout:
	foobar
	hi
---
#
# Places \newline should be collapsed
#
name: bksl-nl-1
description:
	Check that \newline is collapsed before, in the middle of, and
	after words
stdin:
	 	 	\
			 echo hi\
	There, \
	folks
expected-stdout:
	hiThere, folks
---
name: bksl-nl-2
description:
	Check that \newline is collapsed in $ sequences
	(ksh93 fails this)
stdin:
	a=12
	ab=19
	echo $\
	a
	echo $a\
	b
	echo $\
	{a}
	echo ${a\
	b}
	echo ${ab\
	}
expected-stdout:
	12
	19
	12
	19
	19
---
name: bksl-nl-3
description:
	Check that \newline is collapsed in $(..) and `...` sequences
	(ksh93 fails this)
stdin:
	echo $\
	(echo foobar1)
	echo $(\
	echo foobar2)
	echo $(echo foo\
	bar3)
	echo $(echo foobar4\
	)
	echo `
	echo stuff1`
	echo `echo st\
	uff2`
expected-stdout:
	foobar1
	foobar2
	foobar3
	foobar4
	stuff1
	stuff2
---
name: bksl-nl-4
description:
	Check that \newline is collapsed in $((..)) sequences
	(ksh93 fails this)
stdin:
	echo $\
	((1+2))
	echo $(\
	(1+2+3))
	echo $((\
	1+2+3+4))
	echo $((1+\
	2+3+4+5))
	echo $((1+2+3+4+5+6)\
	)
expected-stdout:
	3
	6
	10
	15
	21
---
name: bksl-nl-5
description:
	Check that \newline is collapsed in double quoted strings
stdin:
	echo "\
	hi"
	echo "foo\
	bar"
	echo "folks\
	"
expected-stdout:
	hi
	foobar
	folks
---
name: bksl-nl-6
description:
	Check that \newline is collapsed in here document delimiters
	(ksh93 fails second part of this)
stdin:
	a=12
	cat << EO\
	F
	a=$a
	foo\
	bar
	EOF
	cat << E_O_F
	foo
	E_O_\
	F
	echo done
expected-stdout:
	a=12
	foobar
	foo
	done
---
name: bksl-nl-7
description:
	Check that \newline is collapsed in double-quoted here-document
	delimiter.
stdin:
	a=12
	cat << "EO\
	F"
	a=$a
	foo\
	bar
	EOF
	echo done
expected-stdout:
	a=$a
	foo\
	bar
	done
---
name: bksl-nl-8
description:
	Check that \newline is collapsed in various 2+ character tokens
	delimiter.
	(ksh93 fails this)
stdin:
	echo hi &\
	& echo there
	echo foo |\
	| echo bar
	cat <\
	< EOF
	stuff
	EOF
	cat <\
	<\
	- EOF
		more stuff
	EOF
	cat <<\
	EOF
	abcdef
	EOF
	echo hi >\
	> /dev/null
	echo $?
	i=1
	case $i in
	(\
	x|\
	1\
	) echo hi;\
	;
	(*) echo oops
	esac
expected-stdout:
	hi
	there
	foo
	stuff
	more stuff
	abcdef
	0
	hi
---
name: bksl-nl-9
description:
	Check that \ at the end of an alias is collapsed when followed
	by a newline
	(don't know what POSIX has to say about this)
stdin:
	alias x='echo hi\'
	x
	echo there
expected-stdout:
	hiecho there
---
name: bksl-nl-10
description:
	Check that \newline in a keyword is collapsed
stdin:
	i\
	f true; then\
	 echo pass; el\
	se echo fail; fi
expected-stdout:
	pass
---
#
# Places \newline should be collapsed (ksh extensions)
#
name: bksl-nl-ksh-1
description:
	Check that \newline is collapsed in extended globbing
	(ksh93 fails this)
stdin:
	xxx=foo
	case $xxx in
	(f*\
	(\
	o\
	)\
	) echo ok ;;
	*) echo bad
	esac
expected-stdout:
	ok
---
name: bksl-nl-ksh-2
description:
	Check that \newline is collapsed in ((...)) expressions
	(ksh93 fails this)
stdin:
	i=1
	(\
	(\
	i=i+2\
	)\
	)
	echo $i
expected-stdout:
	3
---
name: break-1
description:
	See if break breaks out of loops
stdin:
	for i in a b c; do echo $i; break; echo bad-$i; done
	echo end-1
	for i in a b c; do echo $i; break 1; echo bad-$i; done
	echo end-2
	for i in a b c; do
	    for j in x y z; do
		echo $i:$j
		break
		echo bad-$i
	    done
	    echo end-$i
	done
	echo end-3
	for i in a b c; do echo $i; eval break; echo bad-$i; done
	echo end-4
expected-stdout:
	a
	end-1
	a
	end-2
	a:x
	end-a
	b:x
	end-b
	c:x
	end-c
	end-3
	a
	end-4
---
name: break-2
description:
	See if break breaks out of nested loops
stdin:
	for i in a b c; do
	    for j in x y z; do
		echo $i:$j
		break 2
		echo bad-$i
	    done
	    echo end-$i
	done
	echo end
expected-stdout:
	a:x
	end
---
name: break-3
description:
	What if break used outside of any loops
	(ksh88,ksh93 don't print error messages here)
stdin:
	break
expected-stderr-pattern:
	/.*break.*/
---
name: break-4
description:
	What if break N used when only N-1 loops
	(ksh88,ksh93 don't print error messages here)
stdin:
	for i in a b c; do echo $i; break 2; echo bad-$i; done
	echo end
expected-stdout:
	a
	end
expected-stderr-pattern:
	/.*break.*/
---
name: break-5
description:
	Error if break argument isn't a number
stdin:
	for i in a b c; do echo $i; break abc; echo more-$i; done
	echo end
expected-stdout:
	a
expected-exit: e != 0
expected-stderr-pattern:
	/.*break.*/
---
name: continue-1
description:
	See if continue continues loops
stdin:
	for i in a b c; do echo $i; continue; echo bad-$i ; done
	echo end-1
	for i in a b c; do echo $i; continue 1; echo bad-$i; done
	echo end-2
	for i in a b c; do
	    for j in x y z; do
		echo $i:$j
		continue
		echo bad-$i-$j
	    done
	    echo end-$i
	done
	echo end-3
	for i in a b c; do echo $i; eval continue; echo bad-$i ; done
	echo end-4
expected-stdout:
	a
	b
	c
	end-1
	a
	b
	c
	end-2
	a:x
	a:y
	a:z
	end-a
	b:x
	b:y
	b:z
	end-b
	c:x
	c:y
	c:z
	end-c
	end-3
	a
	b
	c
	end-4
---
name: continue-2
description:
	See if continue breaks out of nested loops
stdin:
	for i in a b c; do
	    for j in x y z; do
		echo $i:$j
		continue 2
		echo bad-$i-$j
	    done
	    echo end-$i
	done
	echo end
expected-stdout:
	a:x
	b:x
	c:x
	end
---
name: continue-3
description:
	What if continue used outside of any loops
	(ksh88,ksh93 don't print error messages here)
stdin:
	continue
expected-stderr-pattern:
	/.*continue.*/
---
name: continue-4
description:
	What if continue N used when only N-1 loops
	(ksh88,ksh93 don't print error messages here)
stdin:
	for i in a b c; do echo $i; continue 2; echo bad-$i; done
	echo end
expected-stdout:
	a
	b
	c
	end
expected-stderr-pattern:
	/.*continue.*/
---
name: continue-5
description:
	Error if continue argument isn't a number
stdin:
	for i in a b c; do echo $i; continue abc; echo more-$i; done
	echo end
expected-stdout:
	a
expected-exit: e != 0
expected-stderr-pattern:
	/.*continue.*/
---
name: cd-history
description:
	Test someone's CD history package (uses arrays)
stdin:
	# go to known place before doing anything
	cd /
	
	alias cd=_cd
	function _cd
	{
		typeset -i cdlen i
		typeset t
	
		if [ $# -eq 0 ]
		then
			set -- $HOME
		fi
	
		if [ "$CDHISTFILE" -a -r "$CDHISTFILE" ] # if directory history exists
		then
			typeset CDHIST
			i=-1
			while read -r t			# read directory history file
			do
				CDHIST[i=i+1]=$t
			done <$CDHISTFILE
		fi
	
		if [ "${CDHIST[0]}" != "$PWD" -a "$PWD" != "" ]
		then
			_cdins				# insert $PWD into cd history
		fi
	
		cdlen=${#CDHIST[*]}			# number of elements in history
	
		case "$@@" in
		-)					# cd to new dir
			if [ "$OLDPWD" = "" ] && ((cdlen>1))
			then
				'print' ${CDHIST[1]}
				'cd' ${CDHIST[1]}
				_pwd
			else
				'cd' $@@
				_pwd
			fi
			;;
		-l)					# print directory list
			typeset -R3 num
			((i=cdlen))
			while (((i=i-1)>=0))
			do
				num=$i
				'print' "$num ${CDHIST[i]}"
			done
			return
			;;
		-[0-9]|-[0-9][0-9])			# cd to dir in list
			if (((i=${1#-})<cdlen))
			then
				'print' ${CDHIST[i]}
				'cd' ${CDHIST[i]}
				_pwd
			else
				'cd' $@@
				_pwd
			fi
			;;
		-*)					# cd to matched dir in list
			t=${1#-}
			i=1
			while ((i<cdlen))
			do
				case ${CDHIST[i]} in
				*$t*)
					'print' ${CDHIST[i]}
					'cd' ${CDHIST[i]}
					_pwd
					break
					;;
				esac
				((i=i+1))
			done
			if ((i>=cdlen))
			then
				'cd' $@@
				_pwd
			fi
			;;
		*)					# cd to new dir
			'cd' $@@
			_pwd
			;;
		esac
	
		_cdins					# insert $PWD into cd history
	
		if [ "$CDHISTFILE" ]
		then
			cdlen=${#CDHIST[*]}		# number of elements in history
	
			i=0
			while ((i<cdlen))
			do
				'print' -r ${CDHIST[i]}	# update directory history
				((i=i+1))
			done >$CDHISTFILE
		fi
	}
	
	function _cdins					# insert $PWD into cd history
	{						# meant to be called only by _cd
		typeset -i i
	
		((i=0))
		while ((i<${#CDHIST[*]}))		# see if dir is already in list
		do
			if [ "${CDHIST[$i]}" = "$PWD" ]
			then
				break
			fi
			((i=i+1))
		done
	
		if ((i>22))				# limit max size of list
		then
			i=22
		fi
	
		while (((i=i-1)>=0))			# bump old dirs in list
		do
			CDHIST[i+1]=${CDHIST[i]}
		done
	
		CDHIST[0]=$PWD				# insert new directory in list
	}
	
	
	function _pwd
	{
		if [ -n "$ECD" ]
		then
			pwd 1>&6
		fi
	}
	# Start of test
	cd /tmp
	cd /bin
	cd /etc
	cd -
	cd -2
	cd -l
expected-stdout:
	/bin
	/tmp
	  3 /
	  2 /etc
	  1 /bin
	  0 /tmp
---
name: cd-pe
description:
	Check package for cd -Pe
need-pass: no
# the mv command fails on Cygwin and z/OS
# Hurd aborts the testsuite (permission denied)
# QNX does not find subdir to cd into
category: !os:cygwin,!os:gnu,!os:midipix,!os:msys,!os:nto,!os:os390,!nosymlink
file-setup: file 644 "x"
	mkdir noread noread/target noread/target/subdir
	ln -s noread link
	chmod 311 noread
	cd -P$1 .
	echo 0=$?
	bwd=$PWD
	cd -P$1 link/target
	echo 1=$?,${PWD#$bwd/}
	epwd=$($TSHELL -c pwd 2>/dev/null)
	# This unexpectedly succeeds on GNU/Linux and MidnightBSD
	#echo pwd=$?,$epwd
	# expect:	pwd=1,
	mv ../../noread ../../renamed
	cd -P$1 subdir
	echo 2=$?,${PWD#$bwd/}
	cd $bwd
	chmod 755 noread renamed 2>/dev/null
	rm -rf noread link renamed
stdin:
	export TSHELL="$__progname"
	"$__progname" x
	echo "now with -e:"
	"$__progname" x e
expected-stdout:
	0=0
	1=0,noread/target
	2=0,noread/target/subdir
	now with -e:
	0=0
	1=0,noread/target
	2=1,noread/target/subdir
---
name: env-prompt
description:
	Check that prompt not printed when processing ENV
env-setup: !ENV=./foo!
file-setup: file 644 "foo"
	XXX=_
	PS1=X
	false && echo hmmm
need-ctty: yes
arguments: !-i!
stdin:
	echo hi${XXX}there
expected-stdout:
	hi_there
expected-stderr: !
	XX
---
name: expand-ugly
description:
	Check that weird ${foo+bar} constructs are parsed correctly
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "<$x> "; done' >pfs
	chmod +x pfn pfs
	(echo 1 ${IFS+'}'z}) 2>/dev/null || echo failed in 1
	(echo 2 "${IFS+'}'z}") 2>/dev/null || echo failed in 2
	(echo 3 "foo ${IFS+'bar} baz") 2>/dev/null || echo failed in 3
	(echo -n '4 '; ./pfn "foo ${IFS+"b   c"} baz") 2>/dev/null || echo failed in 4
	(echo -n '5 '; ./pfn "foo ${IFS+b   c} baz") 2>/dev/null || echo failed in 5
	(echo 6 ${IFS+"}"z}) 2>/dev/null || echo failed in 6
	(echo 7 "${IFS+"}"z}") 2>/dev/null || echo failed in 7
	(echo 8 "${IFS+\"}\"z}") 2>/dev/null || echo failed in 8
	(echo 9 "${IFS+\"\}\"z}") 2>/dev/null || echo failed in 9
	(echo 10 foo ${IFS+'bar} baz'}) 2>/dev/null || echo failed in 10
	(echo 11 "$(echo "${IFS+'}'z}")") 2>/dev/null || echo failed in 11
	(echo 12 "$(echo ${IFS+'}'z})") 2>/dev/null || echo failed in 12
	(echo 13 ${IFS+\}z}) 2>/dev/null || echo failed in 13
	(echo 14 "${IFS+\}z}") 2>/dev/null || echo failed in 14
	u=x; (echo -n '15 '; ./pfs "foo ${IFS+a"b$u{ {"{{\}b} c ${IFS+d{}} bar" ${IFS-e{}} baz; echo .) 2>/dev/null || echo failed in 15
	l=t; (echo 16 ${IFS+h`echo -n i ${IFS+$l}h`ere}) 2>/dev/null || echo failed in 16
	l=t; (echo 17 ${IFS+h$(echo -n i ${IFS+$l}h)ere}) 2>/dev/null || echo failed in 17
	l=t; (echo 18 "${IFS+h`echo -n i ${IFS+$l}h`ere}") 2>/dev/null || echo failed in 18
	l=t; (echo 19 "${IFS+h$(echo -n i ${IFS+$l}h)ere}") 2>/dev/null || echo failed in 19
	l=t; (echo 20 ${IFS+h`echo -n i "${IFS+$l}"h`ere}) 2>/dev/null || echo failed in 20
	l=t; (echo 21 ${IFS+h$(echo -n i "${IFS+$l}"h)ere}) 2>/dev/null || echo failed in 21
	l=t; (echo 22 "${IFS+h`echo -n i "${IFS+$l}"h`ere}") 2>/dev/null || echo failed in 22
	l=t; (echo 23 "${IFS+h$(echo -n i "${IFS+$l}"h)ere}") 2>/dev/null || echo failed in 23
	key=value; (echo -n '24 '; ./pfn "${IFS+'$key'}") 2>/dev/null || echo failed in 24
	key=value; (echo -n '25 '; ./pfn "${IFS+"'$key'"}") 2>/dev/null || echo failed in 25	# ksh93: '$key'
	key=value; (echo -n '26 '; ./pfn ${IFS+'$key'}) 2>/dev/null || echo failed in 26
	key=value; (echo -n '27 '; ./pfn ${IFS+"'$key'"}) 2>/dev/null || echo failed in 27
	(echo -n '28 '; ./pfn "${IFS+"'"x ~ x'}'x"'}"x}" #') 2>/dev/null || echo failed in 28
	u=x; (echo -n '29 '; ./pfs foo ${IFS+a"b$u{ {"{ {\}b} c ${IFS+d{}} bar ${IFS-e{}} baz; echo .) 2>/dev/null || echo failed in 29
	(echo -n '30 '; ./pfs ${IFS+foo 'b\
	ar' baz}; echo .) 2>/dev/null || (echo failed in 30; echo failed in 31)
	(echo -n '32 '; ./pfs ${IFS+foo "b\
	ar" baz}; echo .) 2>/dev/null || echo failed in 32
	(echo -n '33 '; ./pfs "${IFS+foo 'b\
	ar' baz}"; echo .) 2>/dev/null || echo failed in 33
	(echo -n '34 '; ./pfs "${IFS+foo "b\
	ar" baz}"; echo .) 2>/dev/null || echo failed in 34
	(echo -n '35 '; ./pfs ${v=a\ b} x ${v=c\ d}; echo .) 2>/dev/null || echo failed in 35
	(echo -n '36 '; ./pfs "${v=a\ b}" x "${v=c\ d}"; echo .) 2>/dev/null || echo failed in 36
	(echo -n '37 '; ./pfs ${v-a\ b} x ${v-c\ d}; echo .) 2>/dev/null || echo failed in 37
	(echo 38 ${IFS+x'a'y} / "${IFS+x'a'y}" .) 2>/dev/null || echo failed in 38
	foo="x'a'y"; (echo 39 ${foo%*'a'*} / "${foo%*'a'*}" .) 2>/dev/null || echo failed in 39
	foo="a b c"; (echo -n '40 '; ./pfs "${foo#a}"; echo .) 2>/dev/null || echo failed in 40
	(foo() { return 100; }; foo; echo 41 ${#+${#:+${#?}}\ \}\}\}}) 2>/dev/null || echo failed in 41
expected-stdout:
	1 }z
	2 ''z}
	3 foo 'bar baz
	4 foo b   c baz
	5 foo b   c baz
	6 }z
	7 }z
	8 ""z}
	9 "}"z
	10 foo bar} baz
	11 ''z}
	12 }z
	13 }z
	14 }z
	15 <foo abx{ {{{}b c d{} bar> <}> <baz> .
	16 hi there
	17 hi there
	18 hi there
	19 hi there
	20 hi there
	21 hi there
	22 hi there
	23 hi there
	24 'value'
	25 'value'
	26 $key
	27 'value'
	28 'x ~ x''x}"x}" #
	29 <foo> <abx{ {{> <{}b> <c> <d{}> <bar> <}> <baz> .
	30 <foo> <b\
	ar> <baz> .
	32 <foo> <bar> <baz> .
	33 <foo 'bar' baz> .
	34 <foo bar baz> .
	35 <a> <b> <x> <a> <b> .
	36 <a\ b> <x> <a\ b> .
	37 <a b> <x> <c d> .
	38 xay / x'a'y .
	39 x' / x' .
	40 < b c> .
	41 3 }}}
---
name: expand-unglob-dblq
description:
	Check that regular "${foo+bar}" constructs are parsed correctly
stdin:
	u=x
	tl_norm() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo "$1 plus norm foo ${v+'bar'} baz")
		(echo "$1 dash norm foo ${v-'bar'} baz")
		(echo "$1 eqal norm foo ${v='bar'} baz")
		(echo "$1 qstn norm foo ${v?'bar'} baz") 2>/dev/null || \
		    echo "$1 qstn norm -> error"
		(echo "$1 PLUS norm foo ${v:+'bar'} baz")
		(echo "$1 DASH norm foo ${v:-'bar'} baz")
		(echo "$1 EQAL norm foo ${v:='bar'} baz")
		(echo "$1 QSTN norm foo ${v:?'bar'} baz") 2>/dev/null || \
		    echo "$1 QSTN norm -> error"
	}
	tl_paren() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo "$1 plus parn foo ${v+(bar)} baz")
		(echo "$1 dash parn foo ${v-(bar)} baz")
		(echo "$1 eqal parn foo ${v=(bar)} baz")
		(echo "$1 qstn parn foo ${v?(bar)} baz") 2>/dev/null || \
		    echo "$1 qstn parn -> error"
		(echo "$1 PLUS parn foo ${v:+(bar)} baz")
		(echo "$1 DASH parn foo ${v:-(bar)} baz")
		(echo "$1 EQAL parn foo ${v:=(bar)} baz")
		(echo "$1 QSTN parn foo ${v:?(bar)} baz") 2>/dev/null || \
		    echo "$1 QSTN parn -> error"
	}
	tl_brace() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo "$1 plus brac foo ${v+a$u{{{\}b} c ${v+d{}} baz")
		(echo "$1 dash brac foo ${v-a$u{{{\}b} c ${v-d{}} baz")
		(echo "$1 eqal brac foo ${v=a$u{{{\}b} c ${v=d{}} baz")
		(echo "$1 qstn brac foo ${v?a$u{{{\}b} c ${v?d{}} baz") 2>/dev/null || \
		    echo "$1 qstn brac -> error"
		(echo "$1 PLUS brac foo ${v:+a$u{{{\}b} c ${v:+d{}} baz")
		(echo "$1 DASH brac foo ${v:-a$u{{{\}b} c ${v:-d{}} baz")
		(echo "$1 EQAL brac foo ${v:=a$u{{{\}b} c ${v:=d{}} baz")
		(echo "$1 QSTN brac foo ${v:?a$u{{{\}b} c ${v:?d{}} baz") 2>/dev/null || \
		    echo "$1 QSTN brac -> error"
	}
	: '}}}' '}}}' '}}}' '}}}' '}}}' '}}}' '}}}' '}}}'
	tl_norm 1 -
	tl_norm 2 ''
	tl_norm 3 x
	tl_paren 4 -
	tl_paren 5 ''
	tl_paren 6 x
	tl_brace 7 -
	tl_brace 8 ''
	tl_brace 9 x
expected-stdout:
	1 plus norm foo  baz
	1 dash norm foo 'bar' baz
	1 eqal norm foo 'bar' baz
	1 qstn norm -> error
	1 PLUS norm foo  baz
	1 DASH norm foo 'bar' baz
	1 EQAL norm foo 'bar' baz
	1 QSTN norm -> error
	2 plus norm foo 'bar' baz
	2 dash norm foo  baz
	2 eqal norm foo  baz
	2 qstn norm foo  baz
	2 PLUS norm foo  baz
	2 DASH norm foo 'bar' baz
	2 EQAL norm foo 'bar' baz
	2 QSTN norm -> error
	3 plus norm foo 'bar' baz
	3 dash norm foo x baz
	3 eqal norm foo x baz
	3 qstn norm foo x baz
	3 PLUS norm foo 'bar' baz
	3 DASH norm foo x baz
	3 EQAL norm foo x baz
	3 QSTN norm foo x baz
	4 plus parn foo  baz
	4 dash parn foo (bar) baz
	4 eqal parn foo (bar) baz
	4 qstn parn -> error
	4 PLUS parn foo  baz
	4 DASH parn foo (bar) baz
	4 EQAL parn foo (bar) baz
	4 QSTN parn -> error
	5 plus parn foo (bar) baz
	5 dash parn foo  baz
	5 eqal parn foo  baz
	5 qstn parn foo  baz
	5 PLUS parn foo  baz
	5 DASH parn foo (bar) baz
	5 EQAL parn foo (bar) baz
	5 QSTN parn -> error
	6 plus parn foo (bar) baz
	6 dash parn foo x baz
	6 eqal parn foo x baz
	6 qstn parn foo x baz
	6 PLUS parn foo (bar) baz
	6 DASH parn foo x baz
	6 EQAL parn foo x baz
	6 QSTN parn foo x baz
	7 plus brac foo  c } baz
	7 dash brac foo ax{{{}b c d{} baz
	7 eqal brac foo ax{{{}b c ax{{{}b} baz
	7 qstn brac -> error
	7 PLUS brac foo  c } baz
	7 DASH brac foo ax{{{}b c d{} baz
	7 EQAL brac foo ax{{{}b c ax{{{}b} baz
	7 QSTN brac -> error
	8 plus brac foo ax{{{}b c d{} baz
	8 dash brac foo  c } baz
	8 eqal brac foo  c } baz
	8 qstn brac foo  c } baz
	8 PLUS brac foo  c } baz
	8 DASH brac foo ax{{{}b c d{} baz
	8 EQAL brac foo ax{{{}b c ax{{{}b} baz
	8 QSTN brac -> error
	9 plus brac foo ax{{{}b c d{} baz
	9 dash brac foo x c x} baz
	9 eqal brac foo x c x} baz
	9 qstn brac foo x c x} baz
	9 PLUS brac foo ax{{{}b c d{} baz
	9 DASH brac foo x c x} baz
	9 EQAL brac foo x c x} baz
	9 QSTN brac foo x c x} baz
---
name: expand-unglob-unq
description:
	Check that regular ${foo+bar} constructs are parsed correctly
stdin:
	u=x
	tl_norm() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo $1 plus norm foo ${v+'bar'} baz)
		(echo $1 dash norm foo ${v-'bar'} baz)
		(echo $1 eqal norm foo ${v='bar'} baz)
		(echo $1 qstn norm foo ${v?'bar'} baz) 2>/dev/null || \
		    echo "$1 qstn norm -> error"
		(echo $1 PLUS norm foo ${v:+'bar'} baz)
		(echo $1 DASH norm foo ${v:-'bar'} baz)
		(echo $1 EQAL norm foo ${v:='bar'} baz)
		(echo $1 QSTN norm foo ${v:?'bar'} baz) 2>/dev/null || \
		    echo "$1 QSTN norm -> error"
	}
	tl_paren() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo $1 plus parn foo ${v+\(bar')'} baz)
		(echo $1 dash parn foo ${v-\(bar')'} baz)
		(echo $1 eqal parn foo ${v=\(bar')'} baz)
		(echo $1 qstn parn foo ${v?\(bar')'} baz) 2>/dev/null || \
		    echo "$1 qstn parn -> error"
		(echo $1 PLUS parn foo ${v:+\(bar')'} baz)
		(echo $1 DASH parn foo ${v:-\(bar')'} baz)
		(echo $1 EQAL parn foo ${v:=\(bar')'} baz)
		(echo $1 QSTN parn foo ${v:?\(bar')'} baz) 2>/dev/null || \
		    echo "$1 QSTN parn -> error"
	}
	tl_brace() {
		v=$2
		test x"$v" = x"-" && unset v
		(echo $1 plus brac foo ${v+a$u{{{\}b} c ${v+d{}} baz)
		(echo $1 dash brac foo ${v-a$u{{{\}b} c ${v-d{}} baz)
		(echo $1 eqal brac foo ${v=a$u{{{\}b} c ${v=d{}} baz)
		(echo $1 qstn brac foo ${v?a$u{{{\}b} c ${v?d{}} baz) 2>/dev/null || \
		    echo "$1 qstn brac -> error"
		(echo $1 PLUS brac foo ${v:+a$u{{{\}b} c ${v:+d{}} baz)
		(echo $1 DASH brac foo ${v:-a$u{{{\}b} c ${v:-d{}} baz)
		(echo $1 EQAL brac foo ${v:=a$u{{{\}b} c ${v:=d{}} baz)
		(echo $1 QSTN brac foo ${v:?a$u{{{\}b} c ${v:?d{}} baz) 2>/dev/null || \
		    echo "$1 QSTN brac -> error"
	}
	: '}}}' '}}}' '}}}' '}}}' '}}}' '}}}' '}}}' '}}}'
	tl_norm 1 -
	tl_norm 2 ''
	tl_norm 3 x
	tl_paren 4 -
	tl_paren 5 ''
	tl_paren 6 x
	tl_brace 7 -
	tl_brace 8 ''
	tl_brace 9 x
expected-stdout:
	1 plus norm foo baz
	1 dash norm foo bar baz
	1 eqal norm foo bar baz
	1 qstn norm -> error
	1 PLUS norm foo baz
	1 DASH norm foo bar baz
	1 EQAL norm foo bar baz
	1 QSTN norm -> error
	2 plus norm foo bar baz
	2 dash norm foo baz
	2 eqal norm foo baz
	2 qstn norm foo baz
	2 PLUS norm foo baz
	2 DASH norm foo bar baz
	2 EQAL norm foo bar baz
	2 QSTN norm -> error
	3 plus norm foo bar baz
	3 dash norm foo x baz
	3 eqal norm foo x baz
	3 qstn norm foo x baz
	3 PLUS norm foo bar baz
	3 DASH norm foo x baz
	3 EQAL norm foo x baz
	3 QSTN norm foo x baz
	4 plus parn foo baz
	4 dash parn foo (bar) baz
	4 eqal parn foo (bar) baz
	4 qstn parn -> error
	4 PLUS parn foo baz
	4 DASH parn foo (bar) baz
	4 EQAL parn foo (bar) baz
	4 QSTN parn -> error
	5 plus parn foo (bar) baz
	5 dash parn foo baz
	5 eqal parn foo baz
	5 qstn parn foo baz
	5 PLUS parn foo baz
	5 DASH parn foo (bar) baz
	5 EQAL parn foo (bar) baz
	5 QSTN parn -> error
	6 plus parn foo (bar) baz
	6 dash parn foo x baz
	6 eqal parn foo x baz
	6 qstn parn foo x baz
	6 PLUS parn foo (bar) baz
	6 DASH parn foo x baz
	6 EQAL parn foo x baz
	6 QSTN parn foo x baz
	7 plus brac foo c } baz
	7 dash brac foo ax{{{}b c d{} baz
	7 eqal brac foo ax{{{}b c ax{{{}b} baz
	7 qstn brac -> error
	7 PLUS brac foo c } baz
	7 DASH brac foo ax{{{}b c d{} baz
	7 EQAL brac foo ax{{{}b c ax{{{}b} baz
	7 QSTN brac -> error
	8 plus brac foo ax{{{}b c d{} baz
	8 dash brac foo c } baz
	8 eqal brac foo c } baz
	8 qstn brac foo c } baz
	8 PLUS brac foo c } baz
	8 DASH brac foo ax{{{}b c d{} baz
	8 EQAL brac foo ax{{{}b c ax{{{}b} baz
	8 QSTN brac -> error
	9 plus brac foo ax{{{}b c d{} baz
	9 dash brac foo x c x} baz
	9 eqal brac foo x c x} baz
	9 qstn brac foo x c x} baz
	9 PLUS brac foo ax{{{}b c d{} baz
	9 DASH brac foo x c x} baz
	9 EQAL brac foo x c x} baz
	9 QSTN brac foo x c x} baz
---
name: expand-threecolons-dblq
description:
	Check for a particular thing that used to segfault
stdin:
	TEST=1234
	echo "${TEST:1:2:3}"
	echo $? but still living
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: expand-threecolons-unq
description:
	Check for a particular thing that used to not error out
stdin:
	TEST=1234
	echo ${TEST:1:2:3}
	echo $? but still living
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: expand-weird-1
description:
	Check corner cases of trim expansion vs. $# vs. ${#var} vs. ${var?}
stdin:
	set 1 2 3 4 5 6 7 8 9 10 11
	echo ${#}	# value of $#
	echo ${##}	# length of $#
	echo ${##1}	# $# trimmed 1
	set 1 2 3 4 5 6 7 8 9 10 11 12
	echo ${##1}
	(exit 0)
	echo $? = ${#?} .
	(exit 111)
	echo $? = ${#?} .
expected-stdout:
	11
	2
	1
	2
	0 = 1 .
	111 = 3 .
---
name: expand-weird-2
description:
	Check more substitution and extension corner cases
stdin:
	:& set -C; pid=$$; sub=$!; flg=$-; set -- i; exec 3>x.tmp
	#echo "D: !=$! #=$# \$=$$ -=$- ?=$?"
	echo >&3 3 = s^${!-word} , ${#-word} , p^${$-word} , f^${--word} , ${?-word} .
	echo >&3 4 = ${!+word} , ${#+word} , ${$+word} , ${-+word} , ${?+word} .
	echo >&3 5 = s^${!=word} , ${#=word} , p^${$=word} , f^${-=word} , ${?=word} .
	echo >&3 6 = s^${!?word} , ${#?word} , p^${$?word} , f^${-?word} , ${??word} .
	echo >&3 7 = sl^${#!} , ${##} , pl^${#$} , fl^${#-} , ${#?} .
	echo >&3 8 = sw^${%!} , ${%#} , pw^${%$} , fw^${%-} , ${%?} .
	echo >&3 9 = ${!!} , s^${!#} , ${!$} , s^${!-} , s^${!?} .
	echo >&3 10 = s^${!#pattern} , ${##pattern} , p^${$#pattern} , f^${-#pattern} , ${?#pattern} .
	echo >&3 11 = s^${!%pattern} , ${#%pattern} , p^${$%pattern} , f^${-%pattern} , ${?%pattern} .
	echo >&3 12 = $# : ${##} , ${##1} .
	set --
	echo >&3 14 = $# : ${##} , ${##1} .
	set -- 1 2 3 4 5
	echo >&3 16 = $# : ${##} , ${##1} .
	set -- 1 2 3 4 5 6 7 8 9 a b c d e
	echo >&3 18 = $# : ${##} , ${##1} .
	exec 3>&-
	<x.tmp sed \
	    -e "s/ pl^${#pid} / PID /g" -e "s/ sl^${#sub} / SUB /g" -e "s/ fl^${#flg} / FLG /g" \
	    -e "s/ pw^${%pid} / PID /g" -e "s/ sw^${%sub} / SUB /g" -e "s/ fw^${%flg} / FLG /g" \
	    -e "s/ p^$pid / PID /g" -e "s/ s^$sub / SUB /g" -e "s/ f^$flg / FLG /g"
expected-stdout:
	3 = SUB , 1 , PID , FLG , 0 .
	4 = word , word , word , word , word .
	5 = SUB , 1 , PID , FLG , 0 .
	6 = SUB , 1 , PID , FLG , 0 .
	7 = SUB , 1 , PID , FLG , 1 .
	8 = SUB , 1 , PID , FLG , 1 .
	9 = ! , SUB , $ , SUB , SUB .
	10 = SUB , 1 , PID , FLG , 0 .
	11 = SUB , 1 , PID , FLG , 0 .
	12 = 1 : 1 , .
	14 = 0 : 1 , 0 .
	16 = 5 : 1 , 5 .
	18 = 14 : 2 , 4 .
---
name: expand-weird-3
description:
	Check that trimming works with positional parameters (Debian #48453)
stdin:
	A=9999-02
	B=9999
	echo 1=${A#$B?}.
	set -- $A $B
	echo 2=${1#$2?}.
expected-stdout:
	1=02.
	2=02.
---
name: expand-weird-4
description:
	Check that tilde expansion is enabled in ${x#~}
	and cases that are modelled after it (${x/~/~})
stdin:
	HOME=/etc
	a="~/x"
	echo "<${a#~}> <${a#\~}> <${b:-~}> <${b:-\~}> <${c:=~}><$c> <${a/~}> <${a/x/~}> <${a/x/\~}>"
expected-stdout:
	<~/x> </x> <~> <\~> <~><~> <~/x> <~//etc> <~/~>
---
name: expand-bang-1
description:
	Check corner case of ${!?} with ! being var vs. op
stdin:
	echo ${!?}
expected-exit: 1
expected-stderr-pattern: /not set/
---
name: expand-bang-2
description:
	Check corner case of ${!var} vs. ${var op} with var=!
stdin:
	echo 1 $! .
	echo 2 ${!#} .
	echo 3 ${!#[0-9]} .
	echo 4 ${!-foo} .
	# get an at least three-digit bg pid
	while :; do
		:&
		x=$!
		if [[ $x != +([0-9]) ]]; then
			echo >&2 "cannot test, pid '$x' not numeric"
			echo >&2 report this with as many details as possible
			exit 1
		fi
		[[ $x = [0-9][0-9][0-9]* ]] && break
	done
	y=${x#?}
	t=$!; [[ $t = $x ]]; echo 5 $? .
	t=${!#}; [[ $t = $x ]]; echo 6 $? .
	t=${!#[0-9]}; [[ $t = $y ]]; echo 7 $? .
	t=${!-foo}; [[ $t = $x ]]; echo 8 $? .
	t=${!?bar}; [[ $t = $x ]]; echo 9 $? .
expected-stdout:
	1 .
	2 .
	3 .
	4 foo .
	5 0 .
	6 0 .
	7 0 .
	8 0 .
	9 0 .
---
name: expand-number-1
description:
	Check that positional arguments do not overflow
stdin:
	echo "1 ${12345678901234567890} ."
expected-stdout:
	1  .
---
name: expand-slashes-1
description:
	Check that side effects in substring replacement are handled correctly
stdin:
	foo=n1n1n1n2n3
	i=2
	n=1
	echo 1 ${foo//n$((n++))/[$((++i))]} .
	echo 2 $n , $i .
expected-stdout:
	1 [3][3][3]n2n3 .
	2 2 , 3 .
---
name: expand-slashes-2
description:
	Check that side effects in substring replacement are handled correctly
stdin:
	foo=n1n1n1n2n3
	i=2
	n=1
	echo 1 ${foo@@/n$((n++))/[$((++i))]} .
	echo 2 $n , $i .
expected-stdout:
	1 [3]n1n1[4][5] .
	2 5 , 5 .
---
name: expand-slashes-3
description:
	Check that we can access the replaced string
stdin:
	foo=n1n1n1n2n3
	echo 1 ${foo@@/n[12]/[$KSH_MATCH]} .
expected-stdout:
	1 [n1][n1][n1][n2]n3 .
---
name: eglob-bad-1
description:
	Check that globbing isn't done when glob has syntax error
category: !os:cygwin,!os:midipix,!os:msys,!os:os2
file-setup: file 644 "@@(a[b|)c]foo"
stdin:
	echo @@(a[b|)c]*
expected-stdout:
	@@(a[b|)c]*
---
name: eglob-bad-2
description:
	Check that globbing isn't done when glob has syntax error
	(AT&T ksh fails this test)
file-setup: file 644 "abcx"
file-setup: file 644 "abcz"
file-setup: file 644 "bbc"
stdin:
	echo [a*(]*)z
expected-stdout:
	[a*(]*)z
---
name: eglob-infinite-plus
description:
	Check that shell doesn't go into infinite loop expanding +(...)
	expressions.
file-setup: file 644 "abc"
time-limit: 3
stdin:
	echo +()c
	echo +()x
	echo +(*)c
	echo +(*)x
expected-stdout:
	+()c
	+()x
	abc
	+(*)x
---
name: eglob-subst-1
description:
	Check that eglobbing isn't done on substitution results
file-setup: file 644 "abc"
stdin:
	x='@@(*)'
	echo $x
expected-stdout:
	@@(*)
---
name: eglob-nomatch-1
description:
	Check that the pattern doesn't match
stdin:
	echo 1: no-file+(a|b)stuff
	echo 2: no-file+(a*(c)|b)stuff
	echo 3: no-file+((((c)))|b)stuff
expected-stdout:
	1: no-file+(a|b)stuff
	2: no-file+(a*(c)|b)stuff
	3: no-file+((((c)))|b)stuff
---
name: eglob-match-1
description:
	Check that the pattern matches correctly
file-setup: file 644 "abd"
file-setup: file 644 "acd"
file-setup: file 644 "abac"
stdin:
	echo 1: a+(b|c)d
	echo 2: a!(@@(b|B))d
	echo 3: *(a(b|c))		# (...|...) can be used within X(..)
	echo 4: a[b*(foo|bar)]d		# patterns not special inside [...]
expected-stdout:
	1: abd acd
	2: acd
	3: abac
	4: abd
---
name: eglob-case-1
description:
	Simple negation tests
stdin:
	case foo in !(foo|bar)) echo yes;; *) echo no;; esac
	case bar in !(foo|bar)) echo yes;; *) echo no;; esac
expected-stdout:
	no
	no
---
name: eglob-case-2
description:
	Simple kleene tests
stdin:
	case foo in *(a|b[)) echo yes;; *) echo no;; esac
	case foo in *(a|b[)|f*) echo yes;; *) echo no;; esac
	case '*(a|b[)' in *(a|b[)) echo yes;; *) echo no;; esac
	case 'aab[b[ab[a' in *(a|b[)) echo yes;; *) echo no;; esac
expected-stdout:
	no
	yes
	no
	yes
---
name: eglob-trim-1
description:
	Eglobbing in trim expressions...
	(AT&T ksh fails this - docs say # matches shortest string, ## matches
	longest...)
stdin:
	x=abcdef
	echo 1: ${x#a|abc}
	echo 2: ${x##a|abc}
	echo 3: ${x%def|f}
	echo 4: ${x%%f|def}
expected-stdout:
	1: bcdef
	2: def
	3: abcde
	4: abc
---
name: eglob-trim-2
description:
	Check eglobbing works in trims...
stdin:
	x=abcdef
	echo 1: ${x#*(a|b)cd}
	echo 2: "${x#*(a|b)cd}"
	echo 3: ${x#"*(a|b)cd"}
	echo 4: ${x#a(b|c)}
expected-stdout:
	1: ef
	2: ef
	3: abcdef
	4: cdef
---
name: eglob-trim-3
description:
	Check eglobbing works in trims, for Korn Shell
	Ensure eglobbing does not work for reduced-feature /bin/sh
stdin:
	set +o sh
	x=foobar
	y=foobaz
	z=fooba\?
	echo "<${x%bar|baz},${y%bar|baz},${z%\?}>"
	echo "<${x%ba(r|z)},${y%ba(r|z)}>"
	set -o sh
	echo "<${x%bar|baz},${y%bar|baz},${z%\?}>"
	z='foo(bar'
	echo "<${z%(*}>"
expected-stdout:
	<foo,foo,fooba>
	<foo,foo>
	<foobar,foobaz,fooba>
	<foo>
---
name: eglob-substrpl-1
description:
	Check eglobbing works in substs... and they work at all
stdin:
	[[ -n $BASH_VERSION ]] && shopt -s extglob
	x=1222321_ab/cde_b/c_1221
	y=xyz
	echo 1: ${x/2} . ${x/}
	echo 2: ${x//2}
	echo 3: ${x/+(2)}
	echo 4: ${x//+(2)}
	echo 5: ${x/2/4}
	echo 6: ${x//2/4}
	echo 7: ${x/+(2)/4}
	echo 8: ${x//+(2)/4}
	echo 9: ${x/b/c/e/f}
	echo 10: ${x/b\/c/e/f}
	echo 11: ${x/b\/c/e\/f}
	echo 12: ${x/b\/c/e\\/f}
	echo 13: ${x/b\\/c/e\\/f}
	echo 14: ${x//b/c/e/f}
	echo 15: ${x//b\/c/e/f}
	echo 16: ${x//b\/c/e\/f}
	echo 17: ${x//b\/c/e\\/f}
	echo 18: ${x//b\\/c/e\\/f}
	echo 19: ${x/b\/*\/c/x}
	echo 20: ${x/\//.}
	echo 21: ${x//\//.}
	echo 22: ${x///.}
	echo 23: ${x/#1/9}
	echo 24: ${x//#1/9}
	echo 25: ${x/%1/9}
	echo 26: ${x//%1/9}
	echo 27: ${x//\%1/9}
	echo 28: ${x//\\%1/9}
	echo 29: ${x//\a/9}
	echo 30: ${x//\\a/9}
	echo 31: ${x/2/$y}
expected-stdout:
	1: 122321_ab/cde_b/c_1221 . 1222321_ab/cde_b/c_1221
	2: 131_ab/cde_b/c_11
	3: 1321_ab/cde_b/c_1221
	4: 131_ab/cde_b/c_11
	5: 1422321_ab/cde_b/c_1221
	6: 1444341_ab/cde_b/c_1441
	7: 14321_ab/cde_b/c_1221
	8: 14341_ab/cde_b/c_141
	9: 1222321_ac/e/f/cde_b/c_1221
	10: 1222321_ae/fde_b/c_1221
	11: 1222321_ae/fde_b/c_1221
	12: 1222321_ae\/fde_b/c_1221
	13: 1222321_ab/cde_b/c_1221
	14: 1222321_ac/e/f/cde_c/e/f/c_1221
	15: 1222321_ae/fde_e/f_1221
	16: 1222321_ae/fde_e/f_1221
	17: 1222321_ae\/fde_e\/f_1221
	18: 1222321_ab/cde_b/c_1221
	19: 1222321_ax_1221
	20: 1222321_ab.cde_b/c_1221
	21: 1222321_ab.cde_b.c_1221
	22: 1222321_ab/cde_b/c_1221
	23: 9222321_ab/cde_b/c_1221
	24: 1222321_ab/cde_b/c_1221
	25: 1222321_ab/cde_b/c_1229
	26: 1222321_ab/cde_b/c_1221
	27: 1222321_ab/cde_b/c_1221
	28: 1222321_ab/cde_b/c_1221
	29: 1222321_9b/cde_b/c_1221
	30: 1222321_ab/cde_b/c_1221
	31: 1xyz22321_ab/cde_b/c_1221
---
name: eglob-substrpl-2
description:
	Check anchored substring replacement works, corner cases
stdin:
	foo=123
	echo 1: ${foo/#/x}
	echo 2: ${foo/%/x}
	echo 3: ${foo/#/}
	echo 4: ${foo/#}
	echo 5: ${foo/%/}
	echo 6: ${foo/%}
expected-stdout:
	1: x123
	2: 123x
	3: 123
	4: 123
	5: 123
	6: 123
---
name: eglob-substrpl-3a
description:
	Check substring replacement works with variables and slashes, too
stdin:
	HOME=/etc
	pfx=/home/user
	wd=/home/user/tmp
	echo "${wd/#$pfx/~}"
	echo "${wd/#\$pfx/~}"
	echo "${wd/#"$pfx"/~}"
	echo "${wd/#'$pfx'/~}"
	echo "${wd/#"\$pfx"/~}"
	echo "${wd/#'\$pfx'/~}"
expected-stdout:
	/etc/tmp
	/home/user/tmp
	/etc/tmp
	/home/user/tmp
	/home/user/tmp
	/home/user/tmp
---
name: eglob-substrpl-3b
description:
	More of this, bash fails it (bash4 passes)
stdin:
	HOME=/etc
	pfx=/home/user
	wd=/home/user/tmp
	echo "${wd/#$(echo /home/user)/~}"
	echo "${wd/#"$(echo /home/user)"/~}"
	echo "${wd/#'$(echo /home/user)'/~}"
expected-stdout:
	/etc/tmp
	/etc/tmp
	/home/user/tmp
---
name: eglob-substrpl-3c
description:
	Even more weird cases
stdin:
	HOME=/etc
	pfx=/home/user
	wd='$pfx/tmp'
	echo 1: ${wd/#$pfx/~}
	echo 2: ${wd/#\$pfx/~}
	echo 3: ${wd/#"$pfx"/~}
	echo 4: ${wd/#'$pfx'/~}
	echo 5: ${wd/#"\$pfx"/~}
	echo 6: ${wd/#'\$pfx'/~}
	ts='a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)'
	tp=a/b
	tr=c/d
	[[ -n $BASH_VERSION ]] && shopt -s extglob
	echo 7: ${ts/a\/b/$tr}
	echo 8: ${ts/a\/b/\$tr}
	echo 9: ${ts/$tp/$tr}
	echo 10: ${ts/\$tp/$tr}
	echo 11: ${ts/\\$tp/$tr}
	echo 12: ${ts/$tp/c/d}
	echo 13: ${ts/$tp/c\/d}
	echo 14: ${ts/$tp/c\\/d}
	echo 15: ${ts/+(a\/b)/$tr}
	echo 16: ${ts/+(a\/b)/\$tr}
	echo 17: ${ts/+($tp)/$tr}
	echo 18: ${ts/+($tp)/c/d}
	echo 19: ${ts/+($tp)/c\/d}
	echo 20: ${ts//a\/b/$tr}
	echo 21: ${ts//a\/b/\$tr}
	echo 22: ${ts//$tp/$tr}
	echo 23: ${ts//$tp/c/d}
	echo 24: ${ts//$tp/c\/d}
	echo 25: ${ts//+(a\/b)/$tr}
	echo 26: ${ts//+(a\/b)/\$tr}
	echo 27: ${ts//+($tp)/$tr}
	echo 28: ${ts//+($tp)/c/d}
	echo 29: ${ts//+($tp)/c\/d}
	tp="+($tp)"
	echo 30: ${ts/$tp/$tr}
	echo 31: ${ts//$tp/$tr}
expected-stdout:
	1: $pfx/tmp
	2: /etc/tmp
	3: $pfx/tmp
	4: /etc/tmp
	5: /etc/tmp
	6: $pfx/tmp
	7: c/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	8: $tra/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	9: c/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	10: a/ba/bc/d$tp_a/b$tp_*(a/b)_*($tp)
	11: a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	12: c/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	13: c/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	14: c\/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	15: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
	16: $tr$tp$tp_a/b$tp_*(a/b)_*($tp)
	17: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
	18: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
	19: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
	20: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	21: $tr$tr$tp$tp_$tr$tp_*($tr)_*($tp)
	22: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	23: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	24: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	25: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	26: $tr$tp$tp_$tr$tp_*($tr)_*($tp)
	27: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	28: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	29: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	30: a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	31: a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)
#	This is what GNU bash does:
#	30: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
#	31: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
---
name: eglob-utf8-1
description:
	UTF-8 mode differences for eglobbing
category: !shell:ebcdic-yes
stdin:
	s=bld
	set +U
	print 1: ${s%???} .
	print 2: ${s/b???d/x} .
	set -U
	print 3: ${s%???} .
	print 4: ${s/b??d/x} .
	x=n
	print 5: ${x%?} ${x%%?} .
	x=h
	print 6: ${x#?} ${x##?} .
	x=
	print 7: ${x%?} ${x%%?} .
	x=m
	print 8: ${x%?} ${x%%?} .
	x=
	print 9: ${x%?} ${x%%?} .
expected-stdout:
	1: bl .
	2: x .
	3: b .
	4: x .
	5: n n .
	6: h h .
	7:   .
	8: m m .
	9: .
---
name: glob-bad-1
description:
	Check that [ matches itself if it's not a valid bracket expr
	but does not prevent globbing, while backslash-escaping does
file-setup: dir 755 "[x"
file-setup: file 644 "[x/foo"
stdin:
	echo [*
	echo *[x
	echo [x/*
	:>'ab[x'
	:>'a[a-z][x'
	echo a[a-z][*
	echo a[a-z]*
	echo a[a\-z]*
expected-stdout:
	[x
	[x
	[x/foo
	ab[x
	ab[x
	a[a-z]*
---
name: glob-bad-2
description:
	Check that symbolic links aren't stat()'d
# breaks on Dell UNIX 4.0 R2.2 (SVR4) where unlink also fails
# breaks on FreeMiNT (cannot unlink dangling symlinks)
# breaks on MSYS, OS/2 (do not support symlinks)
category: !os:mint,!os:msys,!os:svr4.0,!nosymlink
file-setup: dir 755 "dir"
file-setup: symlink 644 "dir/abc"
	non-existent-file
stdin:
	echo d*/*
	echo d*/abc
expected-stdout:
	dir/abc
	dir/abc
---
name: glob-bad-3
description:
	Check that the slash is parsed before the glob
stdin:
	mkdir a 'a[b'
	(cd 'a[b'; echo ok >'c]d')
	echo nok >abd
	echo fail >a/d
	cat a[b/c]d
expected-stdout:
	ok
---
name: glob-range-1
description:
	Test range matching
file-setup: file 644 ".bc"
file-setup: file 644 "abc"
file-setup: file 644 "bbc"
file-setup: file 644 "cbc"
file-setup: file 644 "-bc"
file-setup: file 644 "!bc"
file-setup: file 644 "^bc"
file-setup: file 644 "+bc"
file-setup: file 644 ",bc"
file-setup: file 644 "0bc"
file-setup: file 644 "1bc"
stdin:
	echo [ab-]*
	echo [-ab]*
	echo [!-ab]*
	echo [!ab]*
	echo []ab]*
	echo [^ab]*
	echo [+--]*
	echo [--1]*

expected-stdout:
	-bc abc bbc
	-bc abc bbc
	!bc +bc ,bc 0bc 1bc ^bc cbc
	!bc +bc ,bc -bc 0bc 1bc ^bc cbc
	abc bbc
	^bc abc bbc
	+bc ,bc -bc
	-bc 0bc 1bc
---
name: glob-range-2
description:
	Test range matching
	(AT&T ksh fails this; POSIX says invalid)
file-setup: file 644 "abc"
stdin:
	echo [a--]*
expected-stdout:
	[a--]*
---
name: glob-range-3
description:
	Check that globbing matches the right things...
# breaks on Mac OSX (HFS+ non-standard UTF-8 canonical decomposition)
# breaks on Cygwin 1.7 (files are now UTF-16 or something)
# breaks on QNX 6.4.1 (says RT)
category: !os:cygwin,!os:midipix,!os:darwin,!os:msys,!os:nto,!os:os2,!os:os390
need-pass: no
file-setup: file 644 "ac"
stdin:
	echo a[-]*
expected-stdout:
	ac
---
name: glob-range-4
description:
	Results unspecified according to POSIX
file-setup: file 644 ".bc"
stdin:
	echo [a.]*
expected-stdout:
	[a.]*
---
name: glob-range-5
description:
	Results unspecified according to POSIX
	(AT&T ksh treats this like [a-cc-e]*)
file-setup: file 644 "abc"
file-setup: file 644 "bbc"
file-setup: file 644 "cbc"
file-setup: file 644 "dbc"
file-setup: file 644 "ebc"
file-setup: file 644 "-bc"
file-setup: file 644 "@@bc"
stdin:
	echo [a-c-e]*
	echo [a--@@]*
expected-stdout:
	-bc abc bbc cbc ebc
	@@bc
---
name: glob-range-6
description:
	ksh93 fails this but POSIX probably demands it
file-setup: file 644 "abc"
file-setup: file 644 "cbc"
stdin:
	echo *b*
	[ '*b*' = *b* ] && echo yep; echo $?
expected-stdout:
	abc cbc
	2
expected-stderr-pattern: /.*/
---
name: glob-word-1
description:
	Check BSD word boundary matches
stdin:
	t() { [[ $1 = *[[:\<:]]bar[[:\>:]]* ]]; echo =$?; }
	t 'foo bar baz'
	t 'foobar baz'
	t 'foo barbaz'
	t 'bar'
	t '_bar'
	t 'bar_'
expected-stdout:
	=0
	=1
	=1
	=0
	=1
	=1
---
name: glob-trim-1
description:
	Check against a regression from fixing IFS-subst-2
stdin:
	x='#foo'
	print -r "before='$x'"
	x=${x%%#*}
	print -r "after ='$x'"
expected-stdout:
	before='#foo'
	after =''
---
name: heredoc-1
description:
	Check ordering/content of redundent here documents.
stdin:
	cat << EOF1 << EOF2
	hi
	EOF1
	there
	EOF2
expected-stdout:
	there
---
name: heredoc-2
description:
	Check quoted here-doc is protected.
stdin:
	a=foo
	cat << 'EOF'
	hi\
	there$a
	stuff
	EO\
	F
	EOF
expected-stdout:
	hi\
	there$a
	stuff
	EO\
	F
---
name: heredoc-3
description:
	Check that newline isn't needed after heredoc-delimiter marker.
stdin: !
	cat << EOF
	hi
	there
	EOF
expected-stdout:
	hi
	there
---
name: heredoc-4a
description:
	Check that an error occurs if the heredoc-delimiter is missing.
stdin: !
	cat << EOF
	hi
	there
expected-exit: e > 0
expected-stderr-pattern: /.*/
---
name: heredoc-4an
description:
	Check that an error occurs if the heredoc-delimiter is missing.
arguments: !-n!
stdin: !
	cat << EOF
	hi
	there
expected-exit: e > 0
expected-stderr-pattern: /.*/
---
name: heredoc-4b
description:
	Check that an error occurs if the heredoc is missing.
stdin: !
	cat << EOF
expected-exit: e > 0
expected-stderr-pattern: /.*/
---
name: heredoc-4bn
description:
	Check that an error occurs if the heredoc is missing.
arguments: !-n!
stdin: !
	cat << EOF
expected-exit: e > 0
expected-stderr-pattern: /.*/
---
name: heredoc-5
description:
	Check that backslash quotes a $, ` and \ and kills a \newline
stdin:
	a=BAD
	b=ok
	cat << EOF
	h\${a}i
	h\\${b}i
	th\`echo not-run\`ere
	th\\`echo is-run`ere
	fol\\ks
	more\\
	last \
	line
	EOF
expected-stdout:
	h${a}i
	h\oki
	th`echo not-run`ere
	th\is-runere
	fol\ks
	more\
	last line
---
name: heredoc-6
description:
	Check that \newline in initial here-delim word doesn't imply
	a quoted here-doc.
stdin:
	a=i
	cat << EO\
	F
	h$a
	there
	EOF
expected-stdout:
	hi
	there
---
name: heredoc-7
description:
	Check that double quoted $ expressions in here delimiters are
	not expanded and match the delimiter.
	POSIX says only quote removal is applied to the delimiter.
stdin:
	a=b
	cat << "E$a"
	hi
	h$a
	hb
	E$a
	echo done
expected-stdout:
	hi
	h$a
	hb
	done
---
name: heredoc-8
description:
	Check that double quoted escaped $ expressions in here
	delimiters are not expanded and match the delimiter.
	POSIX says only quote removal is applied to the delimiter
	(\ counts as a quote).
stdin:
	a=b
	cat << "E\$a"
	hi
	h$a
	h\$a
	hb
	h\b
	E$a
	echo done
expected-stdout:
	hi
	h$a
	h\$a
	hb
	h\b
	done
---
name: heredoc-9a
description:
	Check that here strings work.
stdin:
	bar="bar
		baz"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<foo
	"$__progname" -c "tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<foo"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<"$bar"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<'$bar'
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<\$bar
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<-foo
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<"$(echo "foo bar")"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<"A $(echo "foo bar") B"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<\$b\$b$bar
expected-stdout:
	sbb
	sbb
	one
		onm
	$one
	$one
	-sbb
	sbb one
	A sbb one B
	$o$oone
		onm
---
name: heredoc-9b
description:
	Check that a corner case of here strings works like bash
stdin:
	fnord=42
	bar="bar
		 \$fnord baz"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<$bar
expected-stdout:
	one $sabeq onm
category: bash
---
name: heredoc-9c
description:
	Check that a corner case of here strings works like ksh93, zsh
stdin:
	fnord=42
	bar="bar
		 \$fnord baz"
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<$bar
expected-stdout:
	one
		 $sabeq onm
---
name: heredoc-9d
description:
	Check another corner case of here strings
stdin:
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<< bar
expected-stdout:
	one
---
name: heredoc-9e
description:
	Check here string related regression with multiple iops
stdin:
	echo $(tr r z <<<'bar' 2>/dev/null)
expected-stdout:
	baz
---
name: heredoc-9f
description:
	Check long here strings
stdin:
	cat <<< "$(  :                                                             )aa"
expected-stdout:
	aa
---
name: heredoc-10
description:
	Check direct here document assignment
category: !shell:ebcdic-yes
stdin:
	x=u
	va=<<EOF
	=a $x \x40=
	EOF
	vb=<<'EOF'
	=b $x \x40=
	EOF
	function foo {
		vc=<<-EOF
			=c $x \x40=
		EOF
	}
	fnd=$(typeset -f foo)
	print -r -- "$fnd"
	function foo {
		echo blub
	}
	foo
	eval "$fnd"
	foo
	# rather nonsensical, but
	vd=<<<"=d $x \x40="
	ve=<<<'=e $x \x40='
	vf=<<<$'=f $x \x40='
	# now check
	print -r -- "| va={$va} vb={$vb} vc={$vc} vd={$vd} ve={$ve} vf={$vf} |"
	# check append
	v=<<-EOF
		vapp1
	EOF
	v+=<<-EOF
		vapp2
	EOF
	print -r -- "| ${v//$'\n'/^} |"
expected-stdout:
	function foo {
		vc=<<-EOF 
	=c $x \x40=
	EOF
	
	} 
	blub
	| va={=a u \x40=
	} vb={=b $x \x40=
	} vc={=c u \x40=
	} vd={=d u \x40=
	} ve={=e $x \x40=
	} vf={=f $x @@=
	} |
	| vapp1^vapp2^ |
---
name: heredoc-10-ebcdic
description:
	Check direct here document assignment
category: !shell:ebcdic-no
stdin:
	x=u
	va=<<EOF
	=a $x \x7C=
	EOF
	vb=<<'EOF'
	=b $x \x7C=
	EOF
	function foo {
		vc=<<-EOF
			=c $x \x7C=
		EOF
	}
	fnd=$(typeset -f foo)
	print -r -- "$fnd"
	function foo {
		echo blub
	}
	foo
	eval "$fnd"
	foo
	# rather nonsensical, but
	vd=<<<"=d $x \x7C="
	ve=<<<'=e $x \x7C='
	vf=<<<$'=f $x \x7C='
	# now check
	print -r -- "| va={$va} vb={$vb} vc={$vc} vd={$vd} ve={$ve} vf={$vf} |"
	# check append
	v=<<-EOF
		vapp1
	EOF
	v+=<<-EOF
		vapp2
	EOF
	print -r -- "| ${v//$'\n'/^} |"
expected-stdout:
	function foo {
		vc=<<-EOF 
	=c $x \x7C=
	EOF
	
	} 
	blub
	| va={=a u \x7C=
	} vb={=b $x \x7C=
	} vc={=c u \x7C=
	} vd={=d u \x7C=
	} ve={=e $x \x7C=
	} vf={=f $x @@=
	} |
	| vapp1^vapp2^ |
---
name: heredoc-11
description:
	Check here documents with no or empty delimiter
stdin:
	x=u
	va=<<
	=a $x \x40=
	<<
	vb=<<''
	=b $x \x40=
	
	function foo {
		vc=<<-
			=c $x \x40=
		<<
		vd=<<-''
			=d $x \x40=
	
	}
	fnd=$(typeset -f foo)
	print -r -- "$fnd"
	function foo {
		echo blub
	}
	foo
	eval "$fnd"
	foo
	print -r -- "| va={$va} vb={$vb} vc={$vc} vd={$vd} |"
	x=y
	foo
	typeset -f foo
	print -r -- "| vc={$vc} vd={$vd} |"
	# check append
	v=<<-
		vapp1
	<<
	v+=<<-''
		vapp2
	
	print -r -- "| ${v//$'\n'/^} |"
expected-stdout:
	function foo {
		vc=<<- 
	=c $x \x40=
	<<
	
		vd=<<-"" 
	=d $x \x40=
	
	
	} 
	blub
	| va={=a u \x40=
	} vb={=b $x \x40=
	} vc={=c u \x40=
	} vd={=d $x \x40=
	} |
	function foo {
		vc=<<- 
	=c $x \x40=
	<<
	
		vd=<<-"" 
	=d $x \x40=
	
	
	} 
	| vc={=c y \x40=
	} vd={=d $x \x40=
	} |
	| vapp1^vapp2^ |
---
name: heredoc-12
description:
	Check here documents can use $* and $@@; note shells vary:
	 pdksh 5.2.14 acts the same
	 dash has 1 and 2 the same but 3 lacks the space
	 ksh93, bash4 differ in 2 by using space ipv colon
stdin:
	set -- a b
	nl='
	'
	IFS=" 	$nl"; n=1
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
	IFS=":"; n=2
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
	IFS=; n=3
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
expected-stdout:
	1 foo a b foo
	1 bar "a b" bar
	1 baz a b baz
	1 bla "a b" bla
	2 foo a:b foo
	2 bar "a:b" bar
	2 baz a:b baz
	2 bla "a:b" bla
	3 foo a b foo
	3 bar "a b" bar
	3 baz a b baz
	3 bla "a b" bla
---
name: heredoc-14
description:
	Check that using multiple here documents works
stdin:
	foo() {
		echo "got $(cat) on stdin"
		echo "got $(cat <&4) on fd#4"
		echo "got $(cat <&5) on fd#5"
	}
	bar() {
		foo 4<<-a <<-b 5<<-c
		four
		a
		zero
		b
		five
		c
	}
	x=$(typeset -f bar)
	eval "$x"
	y=$(typeset -f bar)
	[[ $x = "$y" ]]; echo $?
	typeset -f bar
	bar
expected-stdout:
	0
	bar() {
		\foo 4<<-a <<-b 5<<-c 
	four
	a
	zero
	b
	five
	c
	
	} 
	got zero on stdin
	got four on fd#4
	got five on fd#5
---
name: heredoc-15
description:
	Check high-bit7 separators work
stdin:
	u=
	tr a-z A-Z <<-
		m${u}h
	
	echo ok
expected-stdout:
	MH
	ok
---
name: heredoc-comsub-1
description:
	Tests for here documents in COMSUB, taken from Austin ML
stdin:
	text=$(cat <<EOF
	here is the text
	EOF)
	echo = $text =
expected-stdout:
	= here is the text =
---
name: heredoc-comsub-2
description:
	Tests for here documents in COMSUB, taken from Austin ML
stdin:
	unbalanced=$(cat <<EOF
	this paren ) is a problem
	EOF)
	echo = $unbalanced =
expected-stdout:
	= this paren ) is a problem =
---
name: heredoc-comsub-3
description:
	Tests for here documents in COMSUB, taken from Austin ML
stdin:
	balanced=$(cat <<EOF
	these parens ( ) are not a problem
	EOF)
	echo = $balanced =
expected-stdout:
	= these parens ( ) are not a problem =
---
name: heredoc-comsub-4
description:
	Tests for here documents in COMSUB, taken from Austin ML
stdin:
	balanced=$(cat <<EOF
	these parens \( ) are a problem
	EOF)
	echo = $balanced =
expected-stdout:
	= these parens \( ) are a problem =
---
name: heredoc-comsub-5
description:
	Check heredoc and COMSUB mixture in input
stdin:
	prefix() { sed -e "s/^/$1:/"; }
	XXX() { echo x-en; }
	YYY() { echo y-es; }
	
	prefix A <<XXX && echo "$(prefix B <<XXX
	echo line 1
	XXX
	echo line 2)" && prefix C <<YYY
	echo line 3
	XXX
	echo line 4)"
	echo line 5
	YYY
	XXX
expected-stdout:
	A:echo line 3
	B:echo line 1
	line 2
	C:echo line 4)"
	C:echo line 5
	x-en
---
name: heredoc-comsub-6
description:
	Check here documents and here strings can be used
	without a specific command, like $(<) (extension)
stdin:
	foo=bar
	x=$(<<<EO${foo}F)
	echo "3<$x>"
		y=$(<<-EOF
			hi!
	
			$foo) is not a problem
	
	
		EOF)
	echo "7<$y>"
expected-stdout:
	3<EObarF>
	7<hi!
	
	bar) is not a problem>
---
name: heredoc-subshell-1
description:
	Tests for here documents in subshells, taken from Austin ML
stdin:
	(cat <<EOF
	some text
	EOF)
	echo end
expected-stdout:
	some text
	end
---
name: heredoc-subshell-2
description:
	Tests for here documents in subshells, taken from Austin ML
stdin:
	(cat <<EOF
	some text
	EOF
	)
	echo end
expected-stdout:
	some text
	end
---
name: heredoc-subshell-3
description:
	Tests for here documents in subshells, taken from Austin ML
stdin:
	(cat <<EOF; )
	some text
	EOF
	echo end
expected-stdout:
	some text
	end
---
name: heredoc-weird-1
description:
	Tests for here documents, taken from Austin ML
	Documents current state in mksh, *NOT* necessarily correct!
stdin:
	cat <<END
	hello
	END\
	END
	END
	echo end
expected-stdout:
	hello
	ENDEND
	end
---
name: heredoc-weird-2
description:
	Tests for here documents, taken from Austin ML
stdin:
	cat <<'    END    '
	hello
	    END    
	echo end
expected-stdout:
	hello
	end
---
name: heredoc-weird-4
description:
	Tests for here documents, taken from Austin ML
	Documents current state in mksh, *NOT* necessarily correct!
stdin:
	cat <<END
	hello\
	END
	END
	echo end
expected-stdout:
	helloEND
	end
---
name: heredoc-weird-5
description:
	Tests for here documents, taken from Austin ML
	Documents current state in mksh, *NOT* necessarily correct!
stdin:
	cat <<END
	hello
	\END
	END
	echo end
expected-stdout:
	hello
	\END
	end
---
name: heredoc-tmpfile-1
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in simple command.
stdin:
	TMPDIR=$PWD
	eval '
		cat <<- EOF
		hi
		EOF
		for i in a b ; do
			cat <<- EOF
			more
			EOF
		done
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	hi
	more
	more
	Left overs: *
---
name: heredoc-tmpfile-2
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in function, multiple calls to function.
stdin:
	TMPDIR=$PWD
	eval '
		foo() {
			cat <<- EOF
			hi
			EOF
		}
		foo
		foo
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	hi
	hi
	Left overs: *
---
name: heredoc-tmpfile-3
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in function in loop, multiple calls to function.
stdin:
	TMPDIR=$PWD
	eval '
		foo() {
			cat <<- EOF
			hi
			EOF
		}
		for i in a b; do
			foo
			foo() {
				cat <<- EOF
				folks $i
				EOF
			}
		done
		foo
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	hi
	folks b
	folks b
	Left overs: *
---
name: heredoc-tmpfile-4
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Backgrounded simple command with here doc
stdin:
	TMPDIR=$PWD
	eval '
		cat <<- EOF &
		hi
		EOF
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	hi
	Left overs: *
---
name: heredoc-tmpfile-5
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Backgrounded subshell command with here doc
stdin:
	TMPDIR=$PWD
	eval '
	      (
		sleep 1	# so parent exits
		echo A
		cat <<- EOF
		hi
		EOF
		echo B
	      ) &
	    ' &
	sleep 5
	echo Left overs: *
expected-stdout:
	A
	hi
	B
	Left overs: *
---
name: heredoc-tmpfile-6
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in pipeline.
stdin:
	TMPDIR=$PWD
	eval '
		cat <<- EOF | sed "s/hi/HI/"
		hi
		EOF
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	HI
	Left overs: *
---
name: heredoc-tmpfile-7
description:
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in backgrounded pipeline.
stdin:
	TMPDIR=$PWD
	eval '
		cat <<- EOF | sed 's/hi/HI/' &
		hi
		EOF
	    ' &
	sleep 1
	echo Left overs: *
expected-stdout:
	HI
	Left overs: *
---
name: heredoc-tmpfile-8
description:
	Check that heredoc temp files aren't removed too soon or too
	late. Heredoc in function, backgrounded call to function.
	This check can fail on slow machines (<100 MHz), or Cygwin,
	that's normal.
need-pass: no
stdin:
	TMPDIR=$PWD
	# Background eval so main shell doesn't do parsing
	eval '
		foo() {
			cat <<- EOF
			hi
			EOF
		}
		foo
		# sleep so eval can die
		(sleep 1; foo) &
		(sleep 1; foo) &
		foo
	    ' &
	sleep 5
	echo Left overs: *
expected-stdout:
	hi
	hi
	hi
	hi
	Left overs: *
---
name: heredoc-quoting-unsubst
description:
	Check for correct handling of quoted characters in
	here documents without substitution (marker is quoted).
stdin:
	foo=bar
	cat <<-'EOF'
		x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
	EOF
expected-stdout:
	x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
---
name: heredoc-quoting-subst
description:
	Check for correct handling of quoted characters in
	here documents with substitution (marker is not quoted).
stdin:
	foo=bar
	cat <<-EOF
		x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
	EOF
expected-stdout:
	x " \" \ \ $ $ baz `echo baz` bar $foo x
---
name: single-quotes-in-braces
description:
	Check that single quotes inside unquoted {} are treated as quotes
stdin:
	foo=1
	echo ${foo:+'blah  $foo'}
expected-stdout:
	blah  $foo
---
name: single-quotes-in-quoted-braces
description:
	Check that single quotes inside quoted {} are treated as
	normal char
stdin:
	foo=1
	echo "${foo:+'blah  $foo'}"
expected-stdout:
	'blah  1'
---
name: single-quotes-in-braces-nested
description:
	Check that single quotes inside unquoted {} are treated as quotes,
	even if that's inside a double-quoted command expansion
stdin:
	foo=1
	echo "$( echo ${foo:+'blah  $foo'})"
expected-stdout:
	blah  $foo
---
name: single-quotes-in-brace-pattern
description:
	Check that single quotes inside {} pattern are treated as quotes
stdin:
	foo=1234
	echo ${foo%'2'*} "${foo%'2'*}" ${foo%2'*'} "${foo%2'*'}"
expected-stdout:
	1 1 1234 1234
---
name: single-quotes-in-heredoc-braces
description:
	Check that single quotes inside {} in heredoc are treated
	as normal char
stdin:
	foo=1
	cat <<EOM
	${foo:+'blah  $foo'}
	EOM
expected-stdout:
	'blah  1'
---
name: single-quotes-in-nested-braces
description:
	Check that single quotes inside nested unquoted {} are
	treated as quotes
stdin:
	foo=1
	echo ${foo:+${foo:+'blah  $foo'}}
expected-stdout:
	blah  $foo
---
name: single-quotes-in-nested-quoted-braces
description:
	Check that single quotes inside nested quoted {} are treated
	as normal char
stdin:
	foo=1
	echo "${foo:+${foo:+'blah  $foo'}}"
expected-stdout:
	'blah  1'
---
name: single-quotes-in-nested-braces-nested
description:
	Check that single quotes inside nested unquoted {} are treated
	as quotes, even if that's inside a double-quoted command expansion
stdin:
	foo=1
	echo "$( echo ${foo:+${foo:+'blah  $foo'}})"
expected-stdout:
	blah  $foo
---
name: single-quotes-in-nested-brace-pattern
description:
	Check that single quotes inside nested {} pattern are treated as quotes
stdin:
	foo=1234
	echo ${foo:+${foo%'2'*}} "${foo:+${foo%'2'*}}" ${foo:+${foo%2'*'}} "${foo:+${foo%2'*'}}"
expected-stdout:
	1 1 1234 1234
---
name: single-quotes-in-heredoc-nested-braces
description:
	Check that single quotes inside nested {} in heredoc are treated
	as normal char
stdin:
	foo=1
	cat <<EOM
	${foo:+${foo:+'blah  $foo'}}
	EOM
expected-stdout:
	'blah  1'
---
name: single-quotes-in-heredoc-trim
description:
	In some cases, single quotes inside {} in heredoc are not normal
stdin:
	x=notOK
	cat <<EOF
	1: ${x#not} ${x:+${x#not}}
	2: ${x#\n\o\t} ${x:+${x#\n\o\t}}
	3: ${x#"not"} ${x:+${x#"not"}}
	4: ${x#'not'} ${x:+${x#'not'}}
	5: ${x#$'not'} ${x:+${x#$'not'}}
	EOF
expected-stdout:
	1: OK OK
	2: OK OK
	3: OK OK
	4: OK OK
	5: OK OK
---
name: history-basic
description:
	See if we can test history at all
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo hi
	fc -l
expected-stdout:
	hi
	1	echo hi
expected-stderr-pattern:
	/^X*$/
---
name: history-dups
description:
	Verify duplicates and spaces are not entered
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo hi
	 echo yo
	echo hi
	fc -l
expected-stdout:
	hi
	yo
	hi
	1	echo hi
expected-stderr-pattern:
	/^X*$/
---
name: history-unlink
description:
	Check if broken HISTFILEs do not cause trouble
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=foo/hist.file!
file-setup: file 644 "Env"
	PS1=X
file-setup: dir 755 "foo"
file-setup: file 644 "foo/hist.file"
	sometext
time-limit: 5
perl-setup: chmod(0555, "foo");
stdin:
	echo hi
	fc -l
	chmod 0755 foo
expected-stdout:
	hi
	1	echo hi
expected-stderr-pattern:
	/(.*can't unlink HISTFILE.*\n)?X*$/
---
name: history-multiline
description:
	Check correct multiline history, Debian #783978
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!
file-setup: file 644 "Env"
	PS1=X
	PS2=Y
stdin:
	for i in A B C
	do
	   print $i
	   print $i
	done
	fc -l
expected-stdout:
	A
	A
	B
	B
	C
	C
	1	for i in A B C
		do
		   print $i
		   print $i
		done
expected-stderr-pattern:
	/^XYYYYXX$/
---
name: history-e-minus-1
description:
	Check if more recent command is executed
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo hi
	echo there
	fc -e -
expected-stdout:
	hi
	there
	there
expected-stderr-pattern:
	/^X*echo there\nX*$/
---
name: history-e-minus-2
description:
	Check that repeated command is printed before command
	is re-executed.
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	exec 2>&1
	echo hi
	echo there
	fc -e -
expected-stdout-pattern:
	/X*hi\nX*there\nX*echo there\nthere\nX*/
expected-stderr-pattern:
	/^X*$/
---
name: history-e-minus-3
description:
	fc -e - fails when there is no history
	(ksh93 has a bug that causes this to fail)
	(ksh88 loops on this)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	fc -e -
	echo ok
expected-stdout:
	ok
expected-stderr-pattern:
	/^X*.*:.*history.*\nX*$/
---
name: history-e-minus-4
description:
	Check if "fc -e -" command output goes to stdout.
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc
	fc -e - | (read x; echo "A $x")
	echo ok
expected-stdout:
	abc
	A abc
	ok
expected-stderr-pattern:
	/^X*echo abc\nX*/
---
name: history-e-minus-5
description:
	fc is replaced in history by new command.
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	echo ghi jkl
	:
	fc -e - echo
	fc -l 2 5
expected-stdout:
	abc def
	ghi jkl
	ghi jkl
	2	echo ghi jkl
	3	:
	4	echo ghi jkl
	5	fc -l 2 5
expected-stderr-pattern:
	/^X*echo ghi jkl\nX*$/
---
name: history-list-1
description:
	List lists correct range
	(ksh88 fails 'cause it lists the fc command)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	fc -l -- -2
expected-stdout:
	line 1
	line 2
	line 3
	2	echo line 2
	3	echo line 3
expected-stderr-pattern:
	/^X*$/
---
name: history-list-2
description:
	Lists oldest history if given pre-historic number
	(ksh93 has a bug that causes this to fail)
	(ksh88 fails 'cause it lists the fc command)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	fc -l -- -40
expected-stdout:
	line 1
	line 2
	line 3
	1	echo line 1
	2	echo line 2
	3	echo line 3
expected-stderr-pattern:
	/^X*$/
---
name: history-list-3
description:
	Can give number 'options' to fc
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	fc -l -3 -2
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	2	echo line 2
	3	echo line 3
expected-stderr-pattern:
	/^X*$/
---
name: history-list-4
description:
	-1 refers to previous command
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	fc -l -1 -1
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	4	echo line 4
expected-stderr-pattern:
	/^X*$/
---
name: history-list-5
description:
	List command stays in history
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	fc -l -1 -1
	fc -l -2 -1
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	4	echo line 4
	4	echo line 4
	5	fc -l -1 -1
expected-stderr-pattern:
	/^X*$/
---
name: history-list-6
description:
	HISTSIZE limits about of history kept.
	(ksh88 fails 'cause it lists the fc command)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!HISTSIZE=3!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	echo line 5
	fc -l
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	line 5
	4	echo line 4
	5	echo line 5
expected-stderr-pattern:
	/^X*$/
---
name: history-list-7
description:
	fc allows too old/new errors in range specification
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!HISTSIZE=3!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	echo line 5
	fc -l 1 30
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	line 5
	4	echo line 4
	5	echo line 5
	6	fc -l 1 30
expected-stderr-pattern:
	/^X*$/
---
name: history-list-r-1
description:
	test -r flag in history
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	echo line 5
	fc -l -r 2 4
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	line 5
	4	echo line 4
	3	echo line 3
	2	echo line 2
expected-stderr-pattern:
	/^X*$/
---
name: history-list-r-2
description:
	If first is newer than last, -r is implied.
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	echo line 5
	fc -l 4 2
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	line 5
	4	echo line 4
	3	echo line 3
	2	echo line 2
expected-stderr-pattern:
	/^X*$/
---
name: history-list-r-3
description:
	If first is newer than last, -r is cancelled.
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2
	echo line 3
	echo line 4
	echo line 5
	fc -l -r 4 2
expected-stdout:
	line 1
	line 2
	line 3
	line 4
	line 5
	2	echo line 2
	3	echo line 3
	4	echo line 4
expected-stderr-pattern:
	/^X*$/
---
name: history-subst-1
description:
	Basic substitution
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	echo ghi jkl
	fc -e - abc=AB 'echo a'
expected-stdout:
	abc def
	ghi jkl
	AB def
expected-stderr-pattern:
	/^X*echo AB def\nX*$/
---
name: history-subst-2
description:
	Does subst find previous command?
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	echo ghi jkl
	fc -e - jkl=XYZQRT 'echo g'
expected-stdout:
	abc def
	ghi jkl
	ghi XYZQRT
expected-stderr-pattern:
	/^X*echo ghi XYZQRT\nX*$/
---
name: history-subst-3
description:
	Does subst find previous command when no arguments given
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	echo ghi jkl
	fc -e - jkl=XYZQRT
expected-stdout:
	abc def
	ghi jkl
	ghi XYZQRT
expected-stderr-pattern:
	/^X*echo ghi XYZQRT\nX*$/
---
name: history-subst-4
description:
	Global substitutions work
	(ksh88 and ksh93 do not have -g option)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def asjj sadjhasdjh asdjhasd
	fc -e - -g a=FooBAR
expected-stdout:
	abc def asjj sadjhasdjh asdjhasd
	FooBARbc def FooBARsjj sFooBARdjhFooBARsdjh FooBARsdjhFooBARsd
expected-stderr-pattern:
	/^X*echo FooBARbc def FooBARsjj sFooBARdjhFooBARsdjh FooBARsdjhFooBARsd\nX*$/
---
name: history-subst-5
description:
	Make sure searches don't find current (fc) command
	(ksh88/ksh93 don't have the ? prefix thing so they fail this test)
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	echo ghi jkl
	fc -e - abc=AB \?abc
expected-stdout:
	abc def
	ghi jkl
	AB def
expected-stderr-pattern:
	/^X*echo AB def\nX*$/
---
name: history-ed-1-old
description:
	Basic (ed) editing works (assumes you have generic ed editor
	that prints no prompts). This is for oldish ed(1) which write
	the character count to stdout.
category: stdout-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	fc echo
	s/abc/FOOBAR/
	w
	q
expected-stdout:
	abc def
	13
	16
	FOOBAR def
expected-stderr-pattern:
	/^X*echo FOOBAR def\nX*$/
---
name: history-ed-2-old
description:
	Correct command is edited when number given
category: stdout-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2 is here
	echo line 3
	echo line 4
	fc 2
	s/is here/is changed/
	w
	q
expected-stdout:
	line 1
	line 2 is here
	line 3
	line 4
	20
	23
	line 2 is changed
expected-stderr-pattern:
	/^X*echo line 2 is changed\nX*$/
---
name: history-ed-3-old
description:
	Newly created multi line commands show up as single command
	in history.
	(ksh88 fails 'cause it lists the fc command)
category: stdout-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	fc echo
	s/abc/FOOBAR/
	$a
	echo a new line
	.
	w
	q
	fc -l
expected-stdout:
	abc def
	13
	32
	FOOBAR def
	a new line
	1	echo abc def
	2	echo FOOBAR def
		echo a new line
expected-stderr-pattern:
	/^X*echo FOOBAR def\necho a new line\nX*$/
---
name: history-ed-1
description:
	Basic (ed) editing works (assumes you have generic ed editor
	that prints no prompts). This is for newish ed(1) and stderr.
category: !no-stderr-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	fc echo
	s/abc/FOOBAR/
	w
	q
expected-stdout:
	abc def
	FOOBAR def
expected-stderr-pattern:
	/^X*13\n16\necho FOOBAR def\nX*$/
---
name: history-ed-2
description:
	Correct command is edited when number given
category: !no-stderr-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo line 1
	echo line 2 is here
	echo line 3
	echo line 4
	fc 2
	s/is here/is changed/
	w
	q
expected-stdout:
	line 1
	line 2 is here
	line 3
	line 4
	line 2 is changed
expected-stderr-pattern:
	/^X*20\n23\necho line 2 is changed\nX*$/
---
name: history-ed-3
description:
	Newly created multi line commands show up as single command
	in history.
category: !no-stderr-ed
need-ctty: yes
need-pass: no
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo abc def
	fc echo
	s/abc/FOOBAR/
	$a
	echo a new line
	.
	w
	q
	fc -l
expected-stdout:
	abc def
	FOOBAR def
	a new line
	1	echo abc def
	2	echo FOOBAR def
		echo a new line
expected-stderr-pattern:
	/^X*13\n32\necho FOOBAR def\necho a new line\nX*$/
---
name: IFS-space-1
description:
	Simple test, default IFS
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	set -- A B C
	showargs 1 $*
	showargs 2 "$*"
	showargs 3 $@@
	showargs 4 "$@@"
expected-stdout:
	<1> <A> <B> <C> .
	<2> <A B C> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
---
name: IFS-colon-1
description:
	Simple test, IFS=:
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS=:
	set -- A B C
	showargs 1 $*
	showargs 2 "$*"
	showargs 3 $@@
	showargs 4 "$@@"
expected-stdout:
	<1> <A> <B> <C> .
	<2> <A:B:C> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
---
name: IFS-null-1
description:
	Simple test, IFS=""
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS=""
	set -- A B C
	showargs 1 $*
	showargs 2 "$*"
	showargs 3 $@@
	showargs 4 "$@@"
expected-stdout:
	<1> <A> <B> <C> .
	<2> <ABC> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
---
name: IFS-space-colon-1
description:
	Simple test, IFS=<white-space>:
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="$IFS:"
	set --
	showargs 1 $*
	showargs 2 "$*"
	showargs 3 $@@
	showargs 4 "$@@"
	showargs 5 : "$@@"
expected-stdout:
	<1> .
	<2> <> .
	<3> .
	<4> .
	<5> <:> .
---
name: IFS-space-colon-2
description:
	Simple test, IFS=<white-space>:
	AT&T ksh fails this, POSIX says the test is correct.
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="$IFS:"
	set --
	showargs :"$@@"
expected-stdout:
	<:> .
---
name: IFS-space-colon-4
description:
	Simple test, IFS=<white-space>:
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="$IFS:"
	set --
	showargs "$@@$@@"
expected-stdout:
	.
---
name: IFS-space-colon-5
description:
	Simple test, IFS=<white-space>:
	Don't know what POSIX thinks of this.  AT&T ksh does not do this.
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="$IFS:"
	set --
	showargs "${@@:-}"
expected-stdout:
	<> .
---
name: IFS-subst-1
description:
	Simple test, IFS=<white-space>:
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="$IFS:"
	x=":b: :"
	echo -n '1:'; for i in $x ; do echo -n " [$i]" ; done ; echo
	echo -n '2:'; for i in :b:: ; do echo -n " [$i]" ; done ; echo
	showargs 3 $x
	showargs 4 :b::
	x="a:b:"
	echo -n '5:'; for i in $x ; do echo -n " [$i]" ; done ; echo
	showargs 6 $x
	x="a::c"
	echo -n '7:'; for i in $x ; do echo -n " [$i]" ; done ; echo
	showargs 8 $x
	echo -n '9:'; for i in ${FOO-`echo -n h:i`th:ere} ; do echo -n " [$i]" ; done ; echo
	showargs 10 ${FOO-`echo -n h:i`th:ere}
	showargs 11 "${FOO-`echo -n h:i`th:ere}"
	x=" A :  B::D"
	echo -n '12:'; for i in $x ; do echo -n " [$i]" ; done ; echo
	showargs 13 $x
expected-stdout:
	1: [] [b] []
	2: [:b::]
	<3> <> <b> <> .
	<4> <:b::> .
	5: [a] [b]
	<6> <a> <b> .
	7: [a] [] [c]
	<8> <a> <> <c> .
	9: [h] [ith] [ere]
	<10> <h> <ith> <ere> .
	<11> <h:ith:ere> .
	12: [A] [B] [] [D]
	<13> <A> <B> <> <D> .
---
name: IFS-subst-2
description:
	Check leading whitespace after trim does not make a field
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	x="X 1 2"
	showargs 1 shift ${x#X}
expected-stdout:
	<1> <shift> <1> <2> .
---
name: IFS-subst-3-arr
description:
	Check leading IFS non-whitespace after trim does make a field
	but leading IFS whitespace does not, nor empty replacements
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	showargs 0 ${-+}
	IFS=:
	showargs 1 ${-+:foo:bar}
	IFS=' '
	showargs 2 ${-+ foo bar}
expected-stdout:
	<0> .
	<1> <> <foo> <bar> .
	<2> <foo> <bar> .
---
name: IFS-subst-3-ass
description:
	Check non-field semantics
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	showargs 0 x=${-+}
	IFS=:
	showargs 1 x=${-+:foo:bar}
	IFS=' '
	showargs 2 x=${-+ foo bar}
expected-stdout:
	<0> <x=> .
	<1> <x=> <foo> <bar> .
	<2> <x=> <foo> <bar> .
---
name: IFS-subst-3-lcl
description:
	Check non-field semantics, smaller corner case (LP#1381965)
stdin:
	set -x
	local regex=${2:-}
	exit 1
expected-exit: e != 0
expected-stderr-pattern:
	/regex=/
---
name: IFS-subst-4-1
description:
	reported by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\  ; set -- $a
	IFS= ; q="$*" ; nq=$*
	pfn "$*" $* "$q" "$nq"
	[ "$q" = "$nq" ] && echo =true || echo =false
expected-stdout:
	<spacedivdedargument
	here>
	<space>
	<divded>
	<argument
	here>
	<spacedivdedargument
	here>
	<spacedivdedargument
	here>
	=true
---
name: IFS-subst-4-2
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\  ; set -- $a
	IFS= ; q="$@@" ; nq=$@@
	pfn "$*" $* "$q" "$nq"
	[ "$q" = "$nq" ] && echo =true || echo =false
expected-stdout:
	<spacedivdedargument
	here>
	<space>
	<divded>
	<argument
	here>
	<space divded argument
	here>
	<space divded argument
	here>
	=true
---
name: IFS-subst-4-3
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\ ; set -- $a; IFS=
	qs="$*"
	nqs=$*
	qk="$@@"
	nqk=$@@
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~ qs '; pfn "$*"
	print -nr -- '~nqs '; pfn $*
	print -nr -- '~ qk '; pfn "$@@"
	print -nr -- '~nqk '; pfn $@@
expected-stdout:
	= qs <spacedivdedargument
	here>
	=nqs <spacedivdedargument
	here>
	= qk <space divded argument
	here>
	=nqk <space divded argument
	here>
	~ qs <spacedivdedargument
	here>
	~nqs <space>
	<divded>
	<argument
	here>
	~ qk <space>
	<divded>
	<argument
	here>
	~nqk <space>
	<divded>
	<argument
	here>
---
name: IFS-subst-4-4
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\ ; set -- $a; IFS=
	qs="$*"
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn "$*"
	nqs=$*
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn $*
	qk="$@@"
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn "$@@"
	nqk=$@@
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn $@@
expected-stdout:
	= qs <spacedivdedargument
	here>
	~ qs <spacedivdedargument
	here>
	=nqs <spacedivdedargument
	here>
	~nqs <space>
	<divded>
	<argument
	here>
	= qk <space divded argument
	here>
	~ qk <space>
	<divded>
	<argument
	here>
	=nqk <space divded argument
	here>
	~nqk <space>
	<divded>
	<argument
	here>
---
name: IFS-subst-4-4p
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\ ; set -- $a; IFS=
	unset v
	qs=${v:-"$*"}
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn ${v:-"$*"}
	nqs=${v:-$*}
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn ${v:-$*}
	qk=${v:-"$@@"}
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn ${v:-"$@@"}
	nqk=${v:-$@@}
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn ${v:-$@@}
expected-stdout:
	= qs <spacedivdedargument
	here>
	~ qs <spacedivdedargument
	here>
	=nqs <spacedivdedargument
	here>
	~nqs <space>
	<divded>
	<argument
	here>
	= qk <space divded argument
	here>
	~ qk <space>
	<divded>
	<argument
	here>
	=nqk <space divded argument
	here>
	~nqk <space>
	<divded>
	<argument
	here>
---
name: IFS-subst-4-5
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\ ; set -- $a; IFS=,
	qs="$*"
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn "$*"
	nqs=$*
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn $*
	qk="$@@"
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn "$@@"
	nqk=$@@
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn $@@
expected-stdout:
	= qs <space,divded,argument
	here>
	~ qs <space,divded,argument
	here>
	=nqs <space,divded,argument
	here>
	~nqs <space>
	<divded>
	<argument
	here>
	= qk <space divded argument
	here>
	~ qk <space>
	<divded>
	<argument
	here>
	=nqk <space divded argument
	here>
	~nqk <space>
	<divded>
	<argument
	here>
---
name: IFS-subst-4-5p
description:
	extended testsuite based on problem by mikeserv
stdin:
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
	a='space divded  argument
	here'
	IFS=\ ; set -- $a; IFS=,
	unset v
	qs=${v:-"$*"}
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn ${v:-"$*"}
	nqs=${v:-$*}
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn ${v:-$*}
	qk=${v:-"$@@"}
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn ${v:-"$@@"}
	nqk=${v:-$@@}
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn ${v:-$@@}
expected-stdout:
	= qs <space,divded,argument
	here>
	~ qs <space,divded,argument
	here>
	=nqs <space,divded,argument
	here>
	~nqs <space>
	<divded>
	<argument
	here>
	= qk <space divded argument
	here>
	~ qk <space>
	<divded>
	<argument
	here>
	=nqk <space divded argument
	here>
	~nqk <space>
	<divded>
	<argument
	here>
---
name: IFS-subst-5
description:
	extended testsuite based on IFS-subst-3
	differs slightly from ksh93:
	- omit trailing field in a3zna, a7ina (unquoted $@@ expansion)
	- has extra middle fields in b5ins, b7ina (IFS_NWS unquoted expansion)
	differs slightly from bash:
	- omit leading field in a5ins, a7ina (IFS_NWS unquoted expansion)
	differs slightly from zsh:
	- differs in assignment, not expansion; probably zsh bug
	- has extra middle fields in b5ins, b7ina (IFS_NWS unquoted expansion)
	'emulate sh' zsh has extra fields in
	- a5ins (IFS_NWS unquoted $*)
	- b5ins, matching mkshs
	!!WARNING!! more to come: http://austingroupbugs.net/view.php?id=888
stdin:
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb $*; x=$*; pfn "$x"'
	echo '=a1zns'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb "$*"; x="$*"; pfn "$x"'
	echo '=a2zqs'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb $@@; x=$@@; pfn "$x"'
	echo '=a3zna'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb "$@@"; x="$@@"; pfn "$x"'
	echo '=a4zqa'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb $*; x=$*; pfn "$x"'
	echo '=a5ins'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb "$*"; x="$*"; pfn "$x"'
	echo '=a6iqs'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb $@@; x=$@@; pfn "$x"'
	echo '=a7ina'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb "$@@"; x="$@@"; pfn "$x"'
	echo '=a8iqa'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb $*; x=$*; pfn "$x"'
	echo '=b1zns'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb "$*"; x="$*"; pfn "$x"'
	echo '=b2zqs'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb $@@; x=$@@; pfn "$x"'
	echo '=b3zna'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb "$@@"; x="$@@"; pfn "$x"'
	echo '=b4zqa'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb $*; x=$*; pfn "$x"'
	echo '=b5ins'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb "$*"; x="$*"; pfn "$x"'
	echo '=b6iqs'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb $@@; x=$@@; pfn "$x"'
	echo '=b7ina'
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb "$@@"; x="$@@"; pfn "$x"'
	echo '=b8iqa'
expected-stdout:
	[2]
	<2>
	=a1zns
	[2]
	<2>
	=a2zqs
	[2]
	< 2 >
	=a3zna
	[]
	[2]
	[]
	< 2 >
	=a4zqa
	[2]
	<,2,>
	=a5ins
	[,2,]
	<,2,>
	=a6iqs
	[2]
	< 2 >
	=a7ina
	[]
	[2]
	[]
	< 2 >
	=a8iqa
	[A]
	[B]
	[C]
	<ABC>
	=b1zns
	[ABC]
	<ABC>
	=b2zqs
	[A]
	[B]
	[C]
	<A B   C>
	=b3zna
	[A]
	[B]
	[]
	[]
	[C]
	<A B   C>
	=b4zqa
	[A]
	[B]
	[]
	[]
	[C]
	<A,B,,,C>
	=b5ins
	[A,B,,,C]
	<A,B,,,C>
	=b6iqs
	[A]
	[B]
	[]
	[]
	[C]
	<A B   C>
	=b7ina
	[A]
	[B]
	[]
	[]
	[C]
	<A B   C>
	=b8iqa
---
name: IFS-subst-6
description:
	Regression wrt. vector expansion in trim
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS=
	x=abc
	set -- a b
	showargs ${x#$*}
expected-stdout:
	<c> .
---
name: IFS-subst-7
description:
	ksh93 bug wrt. vector expansion in trim
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS="*"
	a=abcd
	set -- '' c
	showargs "$*" ${a##"$*"}
expected-stdout:
	<*c> <abcd> .
---
name: IFS-subst-8
description:
	http://austingroupbugs.net/view.php?id=221
stdin:
	n() { echo "$#"; }; n "${foo-$@@}"
expected-stdout:
	1
---
name: IFS-subst-9
description:
	Scalar context for $*/$@@ in [[ and case
stdin:
	"$__progname" -c 'IFS=; set a b; [[ $* = "$1$2" ]]; echo 1 $?' sh a b
	"$__progname" -c 'IFS=; [[ $* = ab ]]; echo 2 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$*" = ab ]]; echo 3 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ $* = a ]]; echo 4 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$*" = a ]]; echo 5 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$@@" = a ]]; echo 6 "$?"' sh a b
	"$__progname" -c 'IFS=; case "$@@" in a) echo 7 a;; ab) echo 7 b;; a\ b) echo 7 ok;; esac' sh a b
	"$__progname" -c 'IFS=; case $* in a) echo 8 a;; ab) echo 8 ok;; esac' sh a b
	"$__progname" -c 'pfsp() { for s_arg in "$@@"; do print -nr -- "<$s_arg> "; done; print .; }; IFS=; star=$* at="$@@"; pfsp 9 "$star" "$at"' sh a b
expected-stdout:
	1 0
	2 0
	3 0
	4 1
	5 1
	6 1
	7 ok
	8 ok
	<9> <ab> <a b> .
---
name: IFS-subst-10
description:
	Scalar context in ${var=$subst}
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	set -- one "two three" four
	unset -v var
	save_IFS=$IFS
	IFS=
	set -- ${var=$*}
	IFS=$save_IFS
	echo "var=$var"
	showargs "$@@"
expected-stdout:
	var=onetwo threefour
	<onetwo threefour> .
---
name: IFS-arith-1
description:
	http://austingroupbugs.net/view.php?id=832
stdin:
	${ZSH_VERSION+false} || emulate sh
	${BASH_VERSION+set -o posix}
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	IFS=0
	showargs $((1230456))
expected-stdout:
	<123> <456> .
---
name: integer-base-err-1
description:
	Can't have 0 base (causes shell to exit)
expected-exit: e != 0
stdin:
	typeset -i i
	i=3
	i=0#4
	echo $i
expected-stderr-pattern:
	/^.*:.*0#4.*\n$/
---
name: integer-base-err-2
description:
	Can't have multiple bases in a 'constant' (causes shell to exit)
	(ksh88 fails this test)
expected-exit: e != 0
stdin:
	typeset -i i
	i=3
	i=2#110#11
	echo $i
expected-stderr-pattern:
	/^.*:.*2#110#11.*\n$/
---
name: integer-base-err-3
description:
	Syntax errors in expressions and effects on bases
	(interactive so errors don't cause exits)
	(ksh88 fails this test - shell exits, even with -i)
need-ctty: yes
arguments: !-i!
stdin:
	PS1= # minimise prompt hassles
	typeset -i4 a=10
	typeset -i a=2+
	echo $a
	typeset -i4 a=10
	typeset -i2 a=2+
	echo $a
expected-stderr-pattern:
	/^([#\$] )?.*:.*2+.*\n.*:.*2+.*\n$/
expected-stdout:
	4#22
	4#22
---
name: integer-base-err-4
description:
	Are invalid digits (according to base) errors?
	(ksh93 fails this test)
expected-exit: e != 0
stdin:
	typeset -i i;
	i=3#4
expected-stderr-pattern:
	/^([#\$] )?.*:.*3#4.*\n$/
---
name: integer-base-1
description:
	Missing number after base is treated as 0.
stdin:
	typeset -i i
	i=3
	i=2#
	echo $i
expected-stdout:
	0
---
name: integer-base-2
description:
	Check 'stickyness' of base in various situations
stdin:
	typeset -i i=8
	echo $i
	echo ---------- A
	typeset -i4 j=8
	echo $j
	echo ---------- B
	typeset -i k=8
	typeset -i4 k=8
	echo $k
	echo ---------- C
	typeset -i4 l
	l=3#10
	echo $l
	echo ---------- D
	typeset -i m
	m=3#10
	echo $m
	echo ---------- E
	n=2#11
	typeset -i n
	echo $n
	n=10
	echo $n
	echo ---------- F
	typeset -i8 o=12
	typeset -i4 o
	echo $o
	echo ---------- G
	typeset -i p
	let p=8#12
	echo $p
expected-stdout:
	8
	---------- A
	4#20
	---------- B
	4#20
	---------- C
	4#3
	---------- D
	3#10
	---------- E
	2#11
	2#1010
	---------- F
	4#30
	---------- G
	8#12
---
name: integer-base-3
description:
	More base parsing (hmm doesn't test much..)
stdin:
	typeset -i aa
	aa=1+12#10+2
	echo $aa
	typeset -i bb
	bb=1+$aa
	echo $bb
	typeset -i bb
	bb=$aa
	echo $bb
	typeset -i cc
	cc=$aa
	echo $cc
expected-stdout:
	15
	16
	15
	15
---
name: integer-base-4
description:
	Check that things not declared as integers are not made integers,
	also, check if base is not reset by -i with no arguments.
	(ksh93 fails - prints 10#20 - go figure)
stdin:
	xx=20
	let xx=10
	typeset -i | grep '^xx='
	typeset -i4 a=10
	typeset -i a=20
	echo $a
expected-stdout:
	4#110
---
name: integer-base-5
description:
	More base stuff
stdin:
	typeset -i4 a=3#10
	echo $a
	echo --
	typeset -i j=3
	j='~3'
	echo $j
	echo --
	typeset -i k=1
	x[k=k+1]=3
	echo $k
	echo --
	typeset -i l
	for l in 1 2+3 4; do echo $l; done
expected-stdout:
	4#3
	--
	-4
	--
	2
	--
	1
	5
	4
---
name: integer-base-6
description:
	Even more base stuff
	(ksh93 fails this test - prints 0)
stdin:
	typeset -i7 i
	i=
	echo $i
expected-stdout:
	7#0
---
name: integer-base-7
description:
	Check that non-integer parameters don't get bases assigned
stdin:
	echo $(( zz = 8#100 ))
	echo $zz
expected-stdout:
	64
	64
---
name: integer-base-8
description:
	Check that base-36 works (full span)
stdin:
	echo 1:$((36#109AZ)).
	typeset -i36 x=1691675
	echo 2:$x.
	typeset -Uui36 x
	echo 3:$x.
expected-stdout:
	1:1691675.
	2:36#109az.
	3:36#109AZ.
---
name: integer-base-check-flat
description:
	Check behaviour does not match POSuX (except if set -o posix),
	because a not type-safe scripting language has *no* business
	interpreting the string "010" as octal number eight (dangerous).
stdin:
	echo 1 "$("$__progname" -c 'echo :$((10))/$((010)),$((0x10)):')" .
	echo 2 "$("$__progname" -o posix -c 'echo :$((10))/$((010)),$((0x10)):')" .
	echo 3 "$("$__progname" -o sh -c 'echo :$((10))/$((010)),$((0x10)):')" .
expected-stdout:
	1 :10/10,16: .
	2 :10/8,16: .
	3 :10/10,16: .
---
name: integer-base-check-numeric-from-1
description:
	Check behaviour for base one
category: !shell:ebcdic-yes
stdin:
	echo 1:$((1#1))0.
expected-stdout:
	1:490.
---
name: integer-base-check-numeric-from-1-ebcdic
description:
	Check behaviour for base one
category: !shell:ebcdic-no
stdin:
	echo 1:$((1#1))0.
expected-stdout:
	1:2410.
---
name: integer-base-check-numeric-from-2
description:
	Check behaviour for base two to 36, and that 37 degrades to 10
stdin:
	i=1
	while (( ++i <= 37 )); do
		eval 'echo '$i':$(('$i'#10)).'
	done
	echo 37:$($__progname -c 'echo $((37#10))').$?:
expected-stdout:
	2:2.
	3:3.
	4:4.
	5:5.
	6:6.
	7:7.
	8:8.
	9:9.
	10:10.
	11:11.
	12:12.
	13:13.
	14:14.
	15:15.
	16:16.
	17:17.
	18:18.
	19:19.
	20:20.
	21:21.
	22:22.
	23:23.
	24:24.
	25:25.
	26:26.
	27:27.
	28:28.
	29:29.
	30:30.
	31:31.
	32:32.
	33:33.
	34:34.
	35:35.
	36:36.
	37:10.
	37:10.0:
---
name: integer-base-check-numeric-to-1
description:
	Check behaviour for base one
category: !shell:ebcdic-yes
stdin:
	i=1
	typeset -Uui$i x=0x40
	eval "typeset -i10 y=$x"
	print $i:$x.$y.
expected-stdout:
	1:1#@@.64.
---
name: integer-base-check-numeric-to-1-ebcdic
description:
	Check behaviour for base one
category: !shell:ebcdic-no
stdin:
	i=1
	typeset -Uui$i x=0x7C
	eval "typeset -i10 y=$x"
	print $i:$x.$y.
expected-stdout:
	1:1#@@.124.
---
name: integer-base-check-numeric-to-2
description:
	Check behaviour for base two to 36, and that 37 degrades to 10
stdin:
	i=1
	while (( ++i <= 37 )); do
		typeset -Uui$i x=0x40
		eval "typeset -i10 y=$x"
		print $i:$x.$y.
	done
expected-stdout:
	2:2#1000000.64.
	3:3#2101.64.
	4:4#1000.64.
	5:5#224.64.
	6:6#144.64.
	7:7#121.64.
	8:8#100.64.
	9:9#71.64.
	10:64.64.
	11:11#59.64.
	12:12#54.64.
	13:13#4C.64.
	14:14#48.64.
	15:15#44.64.
	16:16#40.64.
	17:17#3D.64.
	18:18#3A.64.
	19:19#37.64.
	20:20#34.64.
	21:21#31.64.
	22:22#2K.64.
	23:23#2I.64.
	24:24#2G.64.
	25:25#2E.64.
	26:26#2C.64.
	27:27#2A.64.
	28:28#28.64.
	29:29#26.64.
	30:30#24.64.
	31:31#22.64.
	32:32#20.64.
	33:33#1V.64.
	34:34#1U.64.
	35:35#1T.64.
	36:36#1S.64.
	37:64.64.
---
name: integer-arithmetic-span
description:
	Check wraparound and size that is defined in mksh
category: int:32
stdin:
	echo s:$((2147483647+1)).$(((2147483647*2)+1)).$(((2147483647*2)+2)).
	echo u:$((#2147483647+1)).$((#(2147483647*2)+1)).$((#(2147483647*2)+2)).
expected-stdout:
	s:-2147483648.-1.0.
	u:2147483648.4294967295.0.
---
name: integer-arithmetic-span-64
description:
	Check wraparound and size that is defined in mksh
category: int:64
stdin:
	echo s:$((9223372036854775807+1)).$(((9223372036854775807*2)+1)).$(((9223372036854775807*2)+2)).
	echo u:$((#9223372036854775807+1)).$((#(9223372036854775807*2)+1)).$((#(9223372036854775807*2)+2)).
expected-stdout:
	s:-9223372036854775808.-1.0.
	u:9223372036854775808.18446744073709551615.0.
---
name: integer-size-FAIL-to-detect
description:
	Notify the user that their ints are not 32 or 64 bit
category: int:u
stdin:
	:
---
name: lineno-stdin
description:
	See if $LINENO is updated and can be modified.
stdin:
	echo A $LINENO
	echo B $LINENO
	LINENO=20
	echo C $LINENO
expected-stdout:
	A 1
	B 2
	C 20
---
name: lineno-inc
description:
	See if $LINENO is set for .'d files.
file-setup: file 644 "dotfile"
	echo dot A $LINENO
	echo dot B $LINENO
	LINENO=20
	echo dot C $LINENO
stdin:
	echo A $LINENO
	echo B $LINENO
	. ./dotfile
expected-stdout:
	A 1
	B 2
	dot A 1
	dot B 2
	dot C 20
---
name: lineno-func
description:
	See if $LINENO is set for commands in a function.
stdin:
	echo A $LINENO
	echo B $LINENO
	bar() {
	    echo func A $LINENO
	    echo func B $LINENO
	}
	bar
	echo C $LINENO
expected-stdout:
	A 1
	B 2
	func A 4
	func B 5
	C 8
---
name: lineno-unset
description:
	See if unsetting LINENO makes it non-magic.
file-setup: file 644 "dotfile"
	echo dot A $LINENO
	echo dot B $LINENO
stdin:
	unset LINENO
	echo A $LINENO
	echo B $LINENO
	bar() {
	    echo func A $LINENO
	    echo func B $LINENO
	}
	bar
	. ./dotfile
	echo C $LINENO
expected-stdout:
	A
	B
	func A
	func B
	dot A
	dot B
	C
---
name: lineno-unset-use
description:
	See if unsetting LINENO makes it non-magic even
	when it is re-used.
file-setup: file 644 "dotfile"
	echo dot A $LINENO
	echo dot B $LINENO
stdin:
	unset LINENO
	LINENO=3
	echo A $LINENO
	echo B $LINENO
	bar() {
	    echo func A $LINENO
	    echo func B $LINENO
	}
	bar
	. ./dotfile
	echo C $LINENO
expected-stdout:
	A 3
	B 3
	func A 3
	func B 3
	dot A 3
	dot B 3
	C 3
---
name: lineno-trap
description:
	Check if LINENO is tracked in traps
stdin:
	fail() {
		echo "line <$1>"
		exit 1
	}
	trap 'fail $LINENO' INT ERR
	false
expected-stdout:
	line <6>
expected-exit: 1
---
name: lineno-eval-alias
description:
	Check if LINENO is trapped in eval and aliases
stdin:
	${ZSH_VERSION+false} || emulate sh; echo $LINENO
	echo $LINENO
	eval '	echo $LINENO
		echo $LINENO
		echo $LINENO'
	echo $LINENO
expected-stdout:
	1
	2
	3
	3
	3
	6
---
name: unknown-trap
description:
	Ensure unknown traps are not a syntax error
stdin:
	(
	trap "echo trap 1 executed" UNKNOWNSIGNAL || echo "foo"
	echo =1
	trap "echo trap 2 executed" UNKNOWNSIGNAL EXIT 999999 FNORD
	echo = $?
	) 2>&1 | sed "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
expected-stdout:
	PROG: trap: bad signal 'UNKNOWNSIGNAL'
	foo
	=1
	PROG: trap: bad signal 'UNKNOWNSIGNAL'
	PROG: trap: bad signal '999999'
	PROG: trap: bad signal 'FNORD'
	= 1
	trap 2 executed
---
name: read-IFS-1
description:
	Simple test, default IFS
stdin:
	echo "A B " > IN
	unset x y z
	read x y z < IN
	echo 1: "x[$x] y[$y] z[$z]"
	echo 1a: ${z-z not set}
	read x < IN
	echo 2: "x[$x]"
expected-stdout:
	1: x[A] y[B] z[]
	1a:
	2: x[A B]
---
name: read-IFS-2
description:
	Complex tests, IFS either colon (IFS-NWS) or backslash (tricky)
stdin:
	n=0
	showargs() { print -nr "$1"; shift; for s_arg in "$@@"; do print -nr -- " [$s_arg]"; done; print; }
	(IFS=\\ a=\<\\\>; showargs 3 $a)
	(IFS=: b=\<:\>; showargs 4 $b)
	print -r '<\>' | (IFS=\\ read f g; showargs 5 "$f" "$g")
	print -r '<\\>' | (IFS=\\ read f g; showargs 6 "$f" "$g")
	print '<\\\n>' | (IFS=\\ read f g; showargs 7 "$f" "$g")
	print -r '<\>' | (IFS=\\ read f; showargs 8 "$f")
	print -r '<\\>' | (IFS=\\ read f; showargs 9 "$f")
	print '<\\\n>' | (IFS=\\ read f; showargs 10 "$f")
	print -r '<\>' | (IFS=\\ read -r f g; showargs 11 "$f" "$g")
	print -r '<\\>' | (IFS=\\ read -r f g; showargs 12 "$f" "$g")
	print '<\\\n>' | (IFS=\\ read -r f g; showargs 13 "$f" "$g")
	print -r '<\>' | (IFS=\\ read -r f; showargs 14 "$f")
	print -r '<\\>' | (IFS=\\ read -r f; showargs 15 "$f")
	print '<\\\n>' | (IFS=\\ read -r f; showargs 16 "$f")
	print -r '<:>' | (IFS=: read f g; showargs 17 "$f" "$g")
	print -r '<::>' | (IFS=: read f g; showargs 18 "$f" "$g")
	print '<:\n>' | (IFS=: read f g; showargs 19 "$f" "$g")
	print -r '<:>' | (IFS=: read f; showargs 20 "$f")
	print -r '<::>' | (IFS=: read f; showargs 21 "$f")
	print '<:\n>' | (IFS=: read f; showargs 22 "$f")
	print -r '<:>' | (IFS=: read -r f g; showargs 23 "$f" "$g")
	print -r '<::>' | (IFS=: read -r f g; showargs 24 "$f" "$g")
	print '<:\n>' | (IFS=: read -r f g; showargs 25 "$f" "$g")
	print -r '<:>' | (IFS=: read -r f; showargs 26 "$f")
	print -r '<::>' | (IFS=: read -r f; showargs 27 "$f")
	print '<:\n>' | (IFS=: read -r f; showargs 28 "$f")
expected-stdout:
	3 [<] [>]
	4 [<] [>]
	5 [<] [>]
	6 [<] [>]
	7 [<>] []
	8 [<>]
	9 [<\>]
	10 [<>]
	11 [<] [>]
	12 [<] [\>]
	13 [<] []
	14 [<\>]
	15 [<\\>]
	16 [<]
	17 [<] [>]
	18 [<] [:>]
	19 [<] []
	20 [<:>]
	21 [<::>]
	22 [<]
	23 [<] [>]
	24 [<] [:>]
	25 [<] []
	26 [<:>]
	27 [<::>]
	28 [<]
---
name: read-ksh-1
description:
	If no var specified, REPLY is used
stdin:
	echo "abc" > IN
	read < IN
	echo "[$REPLY]";
expected-stdout:
	[abc]
---
name: read-regress-1
description:
	Check a regression of read
file-setup: file 644 "foo"
	foo bar
	baz
	blah
stdin:
	while read a b c; do
		read d
		break
	done <foo
	echo "<$a|$b|$c><$d>"
expected-stdout:
	<foo|bar|><baz>
---
name: read-delim-1
description:
	Check read with delimiters
stdin:
	emit() {
		print -n 'foo bar\tbaz\nblah \0blub\tblech\nmyok meck \0'
	}
	emit | while IFS= read -d "" foo; do print -r -- "<$foo>"; done
	emit | while read -d "" foo; do print -r -- "<$foo>"; done
	emit | while read -d "eh?" foo; do print -r -- "<$foo>"; done
expected-stdout:
	<foo bar	baz
	blah >
	<blub	blech
	myok meck >
	<foo bar	baz
	blah>
	<blub	blech
	myok meck>
	<foo bar	baz
	blah blub	bl>
	<ch
	myok m>
---
name: read-ext-1
description:
	Check read with number of bytes specified, and -A
stdin:
	print 'foo\nbar' >x1
	print -n x >x2
	print 'foo\\ bar baz' >x3
	x1a=u; read x1a <x1
	x1b=u; read -N-1 x1b <x1
	x2a=u; read x2a <x2; r2a=$?
	x2b=u; read -N2 x2c <x2; r2b=$?
	x2c=u; read -n2 x2c <x2; r2c=$?
	x3a=u; read -A x3a <x3
	print -r "x1a=<$x1a>"
	print -r "x1b=<$x1b>"
	print -r "x2a=$r2a<$x2a>"
	print -r "x2b=$r2b<$x2b>"
	print -r "x2c=$r2c<$x2c>"
	print -r "x3a=<${x3a[0]}|${x3a[1]}|${x3a[2]}>"
expected-stdout:
	x1a=<foo>
	x1b=<foo
	bar>
	x2a=1<x>
	x2b=1<u>
	x2c=0<x>
	x3a=<foo bar|baz|>
---
name: regression-1
description:
	Lex array code had problems with this.
stdin:
	echo foo[
	n=bar
	echo "hi[ $n ]=1"
expected-stdout:
	foo[
	hi[ bar ]=1
---
name: regression-2
description:
	When PATH is set before running a command, the new path is
	not used in doing the path search
		$ echo echo hi > /tmp/q ; chmod a+rx /tmp/q
		$ PATH=/tmp q
		q: not found
		$
	in comexec() the two lines
		while (*vp != NULL)
			(void) typeset(*vp++, xxx, 0);
	need to be moved out of the switch to before findcom() is
	called - I don't know what this will break.
stdin:
	: "${PWD:-`pwd 2> /dev/null`}"
	: "${PWD:?"PWD not set - cannot do test"}"
	mkdir Y
	cat > Y/xxxscript << EOF
	#!/bin/sh
	# Need to restore path so echo can be found (some shells don't have
	# it as a built-in)
	PATH=\$OLDPATH
	echo hi
	exit 0
	EOF
	chmod a+rx Y/xxxscript
	export OLDPATH="$PATH"
	PATH=$PWD/Y xxxscript
	exit $?
expected-stdout:
	hi
---
name: regression-6
description:
	Parsing of $(..) expressions is non-optimal.  It is
	impossible to have any parentheses inside the expression.
	I.e.,
		$ ksh -c 'echo $(echo \( )'
		no closing quote
		$ ksh -c 'echo $(echo "(" )'
		no closing quote
		$
	The solution is to hack the parsing clode in lex.c, the
	question is how to hack it: should any parentheses be
	escaped by a backslash, or should recursive parsing be done
	(so quotes could also be used to hide hem).  The former is
	easier, the later better...
stdin:
	echo $(echo \( )
	echo $(echo "(" )
expected-stdout:
	(
	(
---
name: regression-9
description:
	Continue in a for loop does not work right:
		for i in a b c ; do
			if [ $i = b ] ; then
				continue
			fi
			echo $i
		done
	Prints a forever...
stdin:
	first=yes
	for i in a b c ; do
		if [ $i = b ] ; then
			if [ $first = no ] ; then
				echo 'continue in for loop broken'
				break	# hope break isn't broken too :-)
			fi
			first=no
			continue
		fi
	done
	echo bye
expected-stdout:
	bye
---
name: regression-10
description:
	The following:
		set -- `false`
		echo $?
	should print 0 according to POSIX (dash, bash, ksh93, posh)
	but not 0 according to the getopt(1) manual page, ksh88, and
	Bourne sh (such as /bin/sh on Solaris).
	We honour POSIX except when -o sh is set.
category: shell:legacy-no
stdin:
	showf() {
		[[ -o posix ]]; FPOSIX=$((1-$?))
		[[ -o sh ]]; FSH=$((1-$?))
		echo -n "FPOSIX=$FPOSIX FSH=$FSH "
	}
	set +o posix +o sh
	showf
	set -- `false`
	echo rv=$?
	set -o sh
	showf
	set -- `false`
	echo rv=$?
	set -o posix
	showf
	set -- `false`
	echo rv=$?
	set -o posix -o sh
	showf
	set -- `false`
	echo rv=$?
expected-stdout:
	FPOSIX=0 FSH=0 rv=0
	FPOSIX=0 FSH=1 rv=1
	FPOSIX=1 FSH=0 rv=0
	FPOSIX=1 FSH=1 rv=0
---
name: regression-10-legacy
description:
	The following:
		set -- `false`
		echo $?
	should print 0 according to POSIX (dash, bash, ksh93, posh)
	but not 0 according to the getopt(1) manual page, ksh88, and
	Bourne sh (such as /bin/sh on Solaris).
category: shell:legacy-yes
stdin:
	showf() {
		[[ -o posix ]]; FPOSIX=$((1-$?))
		[[ -o sh ]]; FSH=$((1-$?))
		echo -n "FPOSIX=$FPOSIX FSH=$FSH "
	}
	set +o posix +o sh
	showf
	set -- `false`
	echo rv=$?
	set -o sh
	showf
	set -- `false`
	echo rv=$?
	set -o posix
	showf
	set -- `false`
	echo rv=$?
	set -o posix -o sh
	showf
	set -- `false`
	echo rv=$?
expected-stdout:
	FPOSIX=0 FSH=0 rv=1
	FPOSIX=0 FSH=1 rv=1
	FPOSIX=1 FSH=0 rv=0
	FPOSIX=1 FSH=1 rv=0
---
name: regression-11
description:
	The following:
		x=/foo/bar/blah
		echo ${x##*/}
	should echo blah but on some machines echos /foo/bar/blah.
stdin:
	x=/foo/bar/blah
	echo ${x##*/}
expected-stdout:
	blah
---
name: regression-12
description:
	Both of the following echos produce the same output under sh/ksh.att:
		#!/bin/sh
		x="foo	bar"
		echo "`echo \"$x\"`"
		echo "`echo "$x"`"
	pdksh produces different output for the former (foo instead of foo\tbar)
stdin:
	x="foo	bar"
	echo "`echo \"$x\"`"
	echo "`echo "$x"`"
expected-stdout:
	foo	bar
	foo	bar
---
name: regression-13
description:
	The following command hangs forever:
		$ (: ; cat /etc/termcap) | sleep 2
	This is because the shell forks a shell to run the (..) command
	and this shell has the pipe open.  When the sleep dies, the cat
	doesn't get a SIGPIPE 'cause a process (ie, the second shell)
	still has the pipe open.
	
	NOTE: this test provokes a bizarre bug in ksh93 (shell starts reading
	      commands from /etc/termcap..)
time-limit: 10
stdin:
	echo A line of text that will be duplicated quite a number of times.> t1
	cat t1 t1 t1 t1  t1 t1 t1 t1  t1 t1 t1 t1  t1 t1 t1 t1  > t2
	cat t2 t2 t2 t2  t2 t2 t2 t2  t2 t2 t2 t2  t2 t2 t2 t2  > t1
	cat t1 t1 t1 t1 > t2
	(: ; cat t2 2>/dev/null) | sleep 1
---
name: regression-14
description:
	The command
		$ (foobar) 2> /dev/null
	generates no output under /bin/sh, but pdksh produces the error
		foobar: not found
	Also, the command
		$ foobar 2> /dev/null
	generates an error under /bin/sh and pdksh, but AT&T ksh88 produces
	no error (redirected to /dev/null).
stdin:
	(you/should/not/see/this/error/1) 2> /dev/null
	you/should/not/see/this/error/2 2> /dev/null
	true
---
name: regression-15
description:
	The command
		$ whence foobar
	generates a blank line under pdksh and sets the exit status to 0.
	AT&T ksh88 generates no output and sets the exit status to 1.  Also,
	the command
		$ whence foobar cat
	generates no output under AT&T ksh88 (pdksh generates a blank line
	and /bin/cat).
stdin:
	whence does/not/exist > /dev/null
	echo 1: $?
	echo 2: $(whence does/not/exist | wc -l)
	echo 3: $(whence does/not/exist cat | wc -l)
expected-stdout:
	1: 1
	2: 0
	3: 0
---
name: regression-16
description:
	${var%%expr} seems to be broken in many places.  On the mips
	the commands
		$ read line < /etc/passwd
		$ echo $line
		root:0:1:...
		$ echo ${line%%:*}
		root
		$ echo $line
		root
		$
	change the value of line.  On sun4s & pas, the echo ${line%%:*} doesn't
	work.  Haven't checked elsewhere...
script:
	read x
	y=$x
	echo ${x%%:*}
	echo $x
stdin:
	root:asdjhasdasjhs:0:1:Root:/:/bin/sh
expected-stdout:
	root
	root:asdjhasdasjhs:0:1:Root:/:/bin/sh
---
name: regression-17
description:
	The command
		. /foo/bar
	should set the exit status to non-zero (sh and AT&T ksh88 do).
	XXX doting a non existent file is a fatal error for a script
stdin:
	. does/not/exist
expected-exit: e != 0
expected-stderr-pattern: /.?/
---
name: regression-19
description:
	Both of the following echos should produce the same thing, but don't:
		$ x=foo/bar
		$ echo ${x%/*}
		foo
		$ echo "${x%/*}"
		foo/bar
stdin:
	x=foo/bar
	echo "${x%/*}"
expected-stdout:
	foo
---
name: regression-21
description:
	backslash does not work as expected in case labels:
	$ x='-x'
	$ case $x in
	-\?) echo hi
	esac
	hi
	$ x='-?'
	$ case $x in
	-\\?) echo hi
	esac
	hi
	$
stdin:
	case -x in
	-\?)	echo fail
	esac
---
name: regression-22
description:
	Quoting backquotes inside backquotes doesn't work:
	$ echo `echo hi \`echo there\` folks`
	asks for more info.  sh and AT&T ksh88 both echo
	hi there folks
stdin:
	echo `echo hi \`echo there\` folks`
expected-stdout:
	hi there folks
---
name: regression-23
description:
	)) is not treated `correctly':
	    $ (echo hi ; (echo there ; echo folks))
	    missing ((
	    $
	instead of (as sh and ksh.att)
	    $ (echo hi ; (echo there ; echo folks))
	    hi
	    there
	    folks
	    $
stdin:
	( : ; ( : ; echo hi))
expected-stdout:
	hi
---
name: regression-25
description:
	Check reading stdin in a while loop.  The read should only read
	a single line, not a whole stdio buffer; the cat should get
	the rest.
stdin:
	(echo a; echo b) | while read x ; do
	    echo $x
	    cat > /dev/null
	done
expected-stdout:
	a
---
name: regression-26
description:
	Check reading stdin in a while loop.  The read should read both
	lines, not just the first.
script:
	a=
	while [ "$a" != xxx ] ; do
	    last=$x
	    read x
	    cat /dev/null | sed 's/x/y/'
	    a=x$a
	done
	echo $last
stdin:
	a
	b
expected-stdout:
	b
---
name: regression-27
description:
	The command
		. /does/not/exist
	should cause a script to exit.
stdin:
	. does/not/exist
	echo hi
expected-exit: e != 0
expected-stderr-pattern: /does\/not\/exist/
---
name: regression-28
description:
	variable assignements not detected well
stdin:
	a.x=1 echo hi
expected-exit: e != 0
expected-stderr-pattern: /a\.x=1/
---
name: regression-29
description:
	alias expansion different from AT&T ksh88
stdin:
	alias a='for ' b='i in'
	a b hi ; do echo $i ; done
expected-stdout:
	hi
---
name: regression-30
description:
	strange characters allowed inside ${...}
stdin:
	echo ${a{b}}
expected-exit: e != 0
expected-stderr-pattern: /.?/
---
name: regression-31
description:
	Does read handle partial lines correctly
script:
	a= ret=
	while [ "$a" != xxx ] ; do
	    read x y z
	    ret=$?
	    a=x$a
	done
	echo "[$x]"
	echo $ret
stdin: !
	a A aA
	b B Bb
	c
expected-stdout:
	[c]
	1
---
name: regression-32
description:
	Does read set variables to null at eof?
script:
	a=
	while [ "$a" != xxx ] ; do
	    read x y z
	    a=x$a
	done
	echo 1: ${x-x not set} ${y-y not set} ${z-z not set}
	echo 2: ${x:+x not null} ${y:+y not null} ${z:+z not null}
stdin:
	a A Aa
	b B Bb
expected-stdout:
	1:
	2:
---
name: regression-33
description:
	Does umask print a leading 0 when umask is 3 digits?
stdin:
	# on MiNT, the first umask call seems to fail
	umask 022
	# now, the test proper
	umask 222
	umask
expected-stdout:
	0222
---
name: regression-35
description:
	Tempory files used for here-docs in functions get trashed after
	the function is parsed (before it is executed)
stdin:
	f1() {
		cat <<- EOF
			F1
		EOF
		f2() {
			cat <<- EOF
				F2
			EOF
		}
	}
	f1
	f2
	unset -f f1
	f2
expected-stdout:
	F1
	F2
	F2
---
name: regression-36
description:
	Command substitution breaks reading in while loop
	(test from <sjg@@void.zen.oz.au>)
stdin:
	(echo abcdef; echo; echo 123) |
	    while read line
	    do
	      # the following line breaks it
	      c=`echo $line | wc -c`
	      echo $c
	    done
expected-stdout:
	7
	1
	4
---
name: regression-37
description:
	Machines with broken times() (reported by <sjg@@void.zen.oz.au>)
	time does not report correct real time
stdin:
	time sleep 1
expected-stderr-pattern: !/^\s*0\.0[\s\d]+real|^\s*real[\s]+0+\.0/
---
name: regression-38
description:
	set -e doesn't ignore exit codes for if/while/until/&&/||/!.
arguments: !-e!
stdin:
	if false; then echo hi ; fi
	false || true
	false && true
	while false; do echo hi; done
	echo ok
expected-stdout:
	ok
---
name: regression-39
description:
	Only posh and oksh(2013-07) say hi below; FreeBSD sh,
	GNU bash in POSIX mode, dash, ksh93, mksh dont. All of
	them exit 0. The POSIX behaviour is needed by BSD make.
stdin:
	set -e
	echo `false; echo hi` $(<this-file-does-not-exist)
	echo $?
expected-stdout:
	
	0
expected-stderr-pattern: /this-file-does-not-exist/
---
name: regression-40
description:
	This used to cause a core dump
env-setup: !RANDOM=12!
stdin:
	echo hi
expected-stdout:
	hi
---
name: regression-41
description:
	foo should be set to bar (should not be empty)
stdin:
	foo=`
	echo bar`
	echo "($foo)"
expected-stdout:
	(bar)
---
name: regression-42
description:
	Can't use command line assignments to assign readonly parameters.
stdin:
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.$PATHSEP$PATH
	foo=bar
	readonly foo
	foo=stuff env | grep '^foo'
expected-exit: e != 0
expected-stderr-pattern:
	/read-only/
---
name: regression-43
description:
	Can subshells be prefixed by redirections (historical shells allow
	this)
stdin:
	< /dev/null (sed 's/^/X/')
---
name: regression-45
description:
	Parameter assignments with [] recognised correctly
stdin:
	FOO=*[12]
	BAR=abc[
	MORE=[abc]
	JUNK=a[bc
	echo "<$FOO>"
	echo "<$BAR>"
	echo "<$MORE>"
	echo "<$JUNK>"
expected-stdout:
	<*[12]>
	<abc[>
	<[abc]>
	<a[bc>
---
name: regression-46
description:
	Check that alias expansion works in command substitutions and
	at the end of file.
stdin:
	alias x='echo hi'
	FOO="`x` "
	echo "[$FOO]"
	x
expected-stdout:
	[hi ]
	hi
---
name: regression-47
description:
	Check that aliases are fully read.
stdin:
	alias x='echo hi;
	echo there'
	x
	echo done
expected-stdout:
	hi
	there
	done
---
name: regression-48
description:
	Check that (here doc) temp files are not left behind after an exec.
stdin:
	mkdir foo || exit 1
	TMPDIR=$PWD/foo "$__progname" <<- 'EOF'
		x() {
			sed 's/^/X /' << E_O_F
			hi
			there
			folks
			E_O_F
			echo "done ($?)"
		}
		echo=echo; [ -x /bin/echo ] && echo=/bin/echo
		exec $echo subtest-1 hi
	EOF
	echo subtest-1 foo/*
	TMPDIR=$PWD/foo "$__progname" <<- 'EOF'
		echo=echo; [ -x /bin/echo ] && echo=/bin/echo
		sed 's/^/X /' << E_O_F; exec $echo subtest-2 hi
		a
		few
		lines
		E_O_F
	EOF
	echo subtest-2 foo/*
expected-stdout:
	subtest-1 hi
	subtest-1 foo/*
	X a
	X few
	X lines
	subtest-2 hi
	subtest-2 foo/*
---
name: regression-49
description:
	Check that unset params with attributes are reported by set, those
	sans attributes are not.
stdin:
	unset FOO BAR
	echo X$FOO
	export BAR
	typeset -i BLAH
	set | grep FOO
	set | grep BAR
	set | grep BLAH
expected-stdout:
	X
	BAR
	BLAH
---
name: regression-50
description:
	Check that aliases do not use continuation prompt after trailing
	semi-colon.
file-setup: file 644 "envf"
	PS1=Y
	PS2=X
env-setup: !ENV=./envf!
need-ctty: yes
arguments: !-i!
stdin:
	alias foo='echo hi ; '
	foo
	foo echo there
expected-stdout:
	hi
	hi
	there
expected-stderr: !
	YYYY
---
name: regression-51
description:
	Check that set allows both +o and -o options on same command line.
stdin:
	set a b c
	set -o noglob +o allexport
	echo A: $*, *
expected-stdout:
	A: a b c, *
---
name: regression-52
description:
	Check that globbing works in pipelined commands
file-setup: file 644 "envf"
	PS1=P
file-setup: file 644 "abc"
	stuff
env-setup: !ENV=./envf!
need-ctty: yes
arguments: !-i!
stdin:
	sed 's/^/X /' < ab*
	echo mark 1
	sed 's/^/X /' < ab* | sed 's/^/Y /'
	echo mark 2
expected-stdout:
	X stuff
	mark 1
	Y X stuff
	mark 2
expected-stderr: !
	PPPPP
---
name: regression-53
description:
	Check that getopts works in functions
stdin:
	bfunc() {
	    echo bfunc: enter "(args: $*; OPTIND=$OPTIND)"
	    while getopts B oc; do
		case $oc in
		  (B)
		    echo bfunc: B option
		    ;;
		  (*)
		    echo bfunc: odd option "($oc)"
		    ;;
		esac
	    done
	    echo bfunc: leave
	}
	
	function kfunc {
	    echo kfunc: enter "(args: $*; OPTIND=$OPTIND)"
	    while getopts K oc; do
		case $oc in
		  (K)
		    echo kfunc: K option
		    ;;
		  (*)
		    echo bfunc: odd option "($oc)"
		    ;;
		esac
	    done
	    echo kfunc: leave
	}
	
	set -- -f -b -k -l
	echo "line 1: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 2: ret=$?, optc=$optc, OPTIND=$OPTIND"
	bfunc -BBB blah
	echo "line 3: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 4: ret=$?, optc=$optc, OPTIND=$OPTIND"
	kfunc -KKK blah
	echo "line 5: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 6: ret=$?, optc=$optc, OPTIND=$OPTIND"
	echo
	
	OPTIND=1
	set -- -fbkl
	echo "line 10: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 20: ret=$?, optc=$optc, OPTIND=$OPTIND"
	bfunc -BBB blah
	echo "line 30: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 40: ret=$?, optc=$optc, OPTIND=$OPTIND"
	kfunc -KKK blah
	echo "line 50: OPTIND=$OPTIND"
	getopts kbfl optc
	echo "line 60: ret=$?, optc=$optc, OPTIND=$OPTIND"
expected-stdout:
	line 1: OPTIND=1
	line 2: ret=0, optc=f, OPTIND=2
	bfunc: enter (args: -BBB blah; OPTIND=2)
	bfunc: B option
	bfunc: B option
	bfunc: leave
	line 3: OPTIND=2
	line 4: ret=0, optc=b, OPTIND=3
	kfunc: enter (args: -KKK blah; OPTIND=1)
	kfunc: K option
	kfunc: K option
	kfunc: K option
	kfunc: leave
	line 5: OPTIND=3
	line 6: ret=0, optc=k, OPTIND=4
	
	line 10: OPTIND=1
	line 20: ret=0, optc=f, OPTIND=2
	bfunc: enter (args: -BBB blah; OPTIND=2)
	bfunc: B option
	bfunc: B option
	bfunc: leave
	line 30: OPTIND=2
	line 40: ret=1, optc=?, OPTIND=2
	kfunc: enter (args: -KKK blah; OPTIND=1)
	kfunc: K option
	kfunc: K option
	kfunc: K option
	kfunc: leave
	line 50: OPTIND=2
	line 60: ret=1, optc=?, OPTIND=2
---
name: regression-54
description:
	Check that ; is not required before the then in if (( ... )) then ...
stdin:
	if (( 1 )) then
	    echo ok dparen
	fi
	if [[ -n 1 ]] then
	    echo ok dbrackets
	fi
expected-stdout:
	ok dparen
	ok dbrackets
---
name: regression-55
description:
	Check ${foo:%bar} is allowed (ksh88 allows it...)
stdin:
	x=fooXbarXblah
	echo 1 ${x%X*}
	echo 2 ${x:%X*}
	echo 3 ${x%%X*}
	echo 4 ${x:%%X*}
	echo 5 ${x#*X}
	echo 6 ${x:#*X}
	echo 7 ${x##*X}
	echo 8 ${x:##*X}
expected-stdout:
	1 fooXbar
	2 fooXbar
	3 foo
	4 foo
	5 barXblah
	6 barXblah
	7 blah
	8 blah
---
name: regression-57
description:
	Check if typeset output is correct for
	uninitialised array elements.
stdin:
	typeset -i xxx[4]
	echo A
	typeset -i | grep xxx | sed 's/^/    /'
	echo B
	typeset | grep xxx | sed 's/^/    /'
	
	xxx[1]=2+5
	echo M
	typeset -i | grep xxx | sed 's/^/    /'
	echo N
	typeset | grep xxx | sed 's/^/    /'
expected-stdout:
	A
	    xxx
	B
	    typeset -i xxx
	M
	    xxx[1]=7
	N
	    set -A xxx
	    typeset -i xxx[1]
---
name: regression-58
description:
	Check if trap exit is ok (exit not mistaken for signal name)
stdin:
	trap 'echo hi' exit
	trap exit 1
expected-stdout:
	hi
---
name: regression-59
description:
	Check if ${#array[*]} is calculated correctly.
stdin:
	a[12]=hi
	a[8]=there
	echo ${#a[*]}
expected-stdout:
	2
---
name: regression-60
description:
	Check if default exit status is previous command
stdin:
	(true; exit)
	echo A $?
	(false; exit)
	echo B $?
	( (exit 103) ; exit)
	echo C $?
expected-stdout:
	A 0
	B 1
	C 103
---
name: regression-61
description:
	Check if EXIT trap is executed for sub shells.
stdin:
	trap 'echo parent exit' EXIT
	echo start
	(echo A; echo A last)
	echo B
	(echo C; trap 'echo sub exit' EXIT; echo C last)
	echo parent last
expected-stdout:
	start
	A
	A last
	B
	C
	C last
	sub exit
	parent last
	parent exit
---
name: regression-62
description:
	Check if test -nt/-ot succeeds if second(first) file is missing.
stdin:
	:>a
	test a -nt b && echo nt OK || echo nt BAD
	test b -ot a && echo ot OK || echo ot BAD
expected-stdout:
	nt OK
	ot OK
---
name: regression-63
description:
	Check if typeset, export, and readonly work
stdin:
	{
		echo FNORD-0
		FNORD_A=1
		FNORD_B=2
		FNORD_C=3
		FNORD_D=4
		FNORD_E=5
		FNORD_F=6
		FNORD_G=7
		FNORD_H=8
		integer FNORD_E FNORD_F FNORD_G FNORD_H
		export FNORD_C FNORD_D FNORD_G FNORD_H
		readonly FNORD_B FNORD_D FNORD_F FNORD_H
		echo FNORD-1
		export
		echo FNORD-2
		export -p
		echo FNORD-3
		readonly
		echo FNORD-4
		readonly -p
		echo FNORD-5
		typeset
		echo FNORD-6
		typeset -p
		echo FNORD-7
		typeset -
		echo FNORD-8
	} | fgrep FNORD
	fnord=(42 23)
	typeset -p fnord
	echo FNORD-9
expected-stdout:
	FNORD-0
	FNORD-1
	FNORD_C
	FNORD_D
	FNORD_G
	FNORD_H
	FNORD-2
	export FNORD_C=3
	export FNORD_D=4
	export FNORD_G=7
	export FNORD_H=8
	FNORD-3
	FNORD_B
	FNORD_D
	FNORD_F
	FNORD_H
	FNORD-4
	readonly FNORD_B=2
	readonly FNORD_D=4
	readonly FNORD_F=6
	readonly FNORD_H=8
	FNORD-5
	typeset FNORD_A
	typeset -r FNORD_B
	typeset -x FNORD_C
	typeset -x -r FNORD_D
	typeset -i FNORD_E
	typeset -i -r FNORD_F
	typeset -i -x FNORD_G
	typeset -i -x -r FNORD_H
	FNORD-6
	typeset FNORD_A=1
	typeset -r FNORD_B=2
	typeset -x FNORD_C=3
	typeset -x -r FNORD_D=4
	typeset -i FNORD_E=5
	typeset -i -r FNORD_F=6
	typeset -i -x FNORD_G=7
	typeset -i -x -r FNORD_H=8
	FNORD-7
	FNORD_A=1
	FNORD_B=2
	FNORD_C=3
	FNORD_D=4
	FNORD_E=5
	FNORD_F=6
	FNORD_G=7
	FNORD_H=8
	FNORD-8
	set -A fnord
	typeset fnord[0]=42
	typeset fnord[1]=23
	FNORD-9
---
name: regression-64
description:
	Check that we can redefine functions calling time builtin
stdin:
	t() {
		time >/dev/null
	}
	t 2>/dev/null
	t() {
		time
	}
---
name: regression-65
description:
	check for a regression with sleep builtin and signal mask
category: !nojsig
time-limit: 5
stdin:
	sleep 1
	echo blub |&
	while read -p line; do :; done
	echo ok
expected-stdout:
	ok
---
name: regression-66
description:
	Check that quoting is sane
category: !nojsig
stdin:
	ac_space=' '
	ac_newline='
	'
	set | grep ^ac_ |&
	set -A lines
	while IFS= read -pr line; do
		if [[ $line = *space* ]]; then
			lines[0]=$line
		else
			lines[1]=$line
		fi
	done
	for line in "${lines[@@]}"; do
		print -r -- "$line"
	done
expected-stdout:
	ac_space=' '
	ac_newline=$'\n'
---
name: regression-67
description:
	Check that we can both break and use source on the same line
stdin:
	for s in s; do break; done; print -s s
---
name: regression-68
description:
	Check that all common arithmetic operators work as expected
stdin:
	echo 1 $(( a = 5 )) .
	echo 2 $(( ++a )) , $(( a++ )) , $(( a )) .
	echo 3 $(( --a )) , $(( a-- )) , $(( a )) .
	echo 4 $(( a == 5 )) , $(( a == 6 )) .
	echo 5 $(( a != 5 )) , $(( a != 6 )) .
	echo 6 $(( a *= 3 )) .
	echo 7 $(( a /= 5 )) .
	echo 8 $(( a %= 2 )) .
	echo 9 $(( a += 9 )) .
	echo 10 $(( a -= 4 )) .
	echo 11 $(( a <<= 1 )) .
	echo 12 $(( a >>= 1 )) .
	echo 13 $(( a &= 4 )) .
	echo 14 $(( a ^= a )) .
	echo 15 $(( a |= 5 )) .
	echo 16 $(( 5 << 1 )) .
	echo 17 $(( 5 >> 1 )) .
	echo 18 $(( 5 <= 6 )) , $(( 5 <= 5 )) , $(( 5 <= 4 )) .
	echo 19 $(( 5 >= 6 )) , $(( 5 >= 5 )) , $(( 5 >= 4 )) .
	echo 20 $(( 5 < 6 )) , $(( 5 < 5 )) , $(( 5 < 4 )) .
	echo 21 $(( 5 > 6 )) , $(( 5 > 5 )) , $(( 5 > 4 )) .
	echo 22 $(( 0 && 0 )) , $(( 0 && 1 )) , $(( 1 && 0 )) , $(( 1 && 1 )) .
	echo 23 $(( 0 || 0 )) , $(( 0 || 1 )) , $(( 1 || 0 )) , $(( 1 || 1 )) .
	echo 24 $(( 5 * 3 )) .
	echo 25 $(( 7 / 2 )) .
	echo 26 $(( 5 % 5 )) , $(( 5 % 4 )) , $(( 5 % 1 )) , $(( 5 % -1 )) , $(( 5 % -2 )) .
	echo 27 $(( 5 + 2 )) , $(( 5 + 0 )) , $(( 5 + -2 )) .
	echo 28 $(( 5 - 2 )) , $(( 5 - 0 )) , $(( 5 - -2 )) .
	echo 29 $(( 6 & 4 )) , $(( 6 & 8 )) .
	echo 30 $(( 4 ^ 2 )) , $(( 4 ^ 4 )) .
	echo 31 $(( 4 | 2 )) , $(( 4 | 4 )) , $(( 4 | 0 )) .
	echo 32 $(( 0 ? 1 : 2 )) , $(( 3 ? 4 : 5 )) .
	echo 33 $(( 5 , 2 , 3 )) .
	echo 34 $(( ~0 )) , $(( ~1 )) , $(( ~~1 )) , $(( ~~2 )) .
	echo 35 $(( !0 )) , $(( !1 )) , $(( !!1 )) , $(( !!2 )) .
	echo 36 $(( (5) )) .
expected-stdout:
	1 5 .
	2 6 , 6 , 7 .
	3 6 , 6 , 5 .
	4 1 , 0 .
	5 0 , 1 .
	6 15 .
	7 3 .
	8 1 .
	9 10 .
	10 6 .
	11 12 .
	12 6 .
	13 4 .
	14 0 .
	15 5 .
	16 10 .
	17 2 .
	18 1 , 1 , 0 .
	19 0 , 1 , 1 .
	20 1 , 0 , 0 .
	21 0 , 0 , 1 .
	22 0 , 0 , 0 , 1 .
	23 0 , 1 , 1 , 1 .
	24 15 .
	25 3 .
	26 0 , 1 , 0 , 0 , 1 .
	27 7 , 5 , 3 .
	28 3 , 5 , 7 .
	29 4 , 0 .
	30 6 , 0 .
	31 6 , 4 , 4 .
	32 2 , 4 .
	33 3 .
	34 -1 , -2 , 1 , 2 .
	35 1 , 0 , 1 , 1 .
	36 5 .
---
name: regression-69
description:
	Check that all non-lksh arithmetic operators work as expected
category: shell:legacy-no
stdin:
	a=5 b=0x80000005
	echo 1 $(( a ^<= 1 )) , $(( b ^<= 1 )) .
	echo 2 $(( a ^>= 2 )) , $(( b ^>= 2 )) .
	echo 3 $(( 5 ^< 1 )) .
	echo 4 $(( 5 ^> 1 )) .
expected-stdout:
	1 10 , 11 .
	2 -2147483646 , -1073741822 .
	3 10 .
	4 -2147483646 .
---
name: export-1
description:
	Check allexport works, basic
stdin:
	qa=1
	set -A qb 2 3
	set -a
	qc=4
	set -A qd 5 6
	export -p | grep '^export q'
expected-stdout:
	export qc=4
	export qd[0]=5
	export qd[1]=6
---
name: readonly-0
description:
	Ensure readonly is honoured for assignments and unset
stdin:
	"$__progname" -c 'u=x; echo $? $u .' || echo aborted, $?
	echo =
	"$__progname" -c 'readonly u; u=x; echo $? $u .' || echo aborted, $?
	echo =
	"$__progname" -c 'u=x; readonly u; unset u; echo $? $u .' || echo aborted, $?
expected-stdout:
	0 x .
	=
	aborted, 2
	=
	1 x .
expected-stderr-pattern:
	/read-only/
---
name: readonly-1
description:
	http://austingroupbugs.net/view.php?id=367 for export
stdin:
	"$__progname" -c 'readonly foo; export foo=a; echo $?' || echo aborted, $?
expected-stdout:
	aborted, 2
expected-stderr-pattern:
	/read-only/
---
name: readonly-2a
description:
	Check that getopts works as intended, for readonly-2b to be valid
stdin:
	"$__progname" -c 'set -- -a b; getopts a c; echo $? $c .; getopts a c; echo $? $c .' || echo aborted, $?
expected-stdout:
	0 a .
	1 ? .
---
name: readonly-2b
description:
	http://austingroupbugs.net/view.php?id=367 for getopts
stdin:
	"$__progname" -c 'readonly c; set -- -a b; getopts a c; echo $? $c .' || echo aborted, $?
expected-stdout:
	2 .
expected-stderr-pattern:
	/read-only/
---
name: readonly-3
description:
	http://austingroupbugs.net/view.php?id=367 for read
stdin:
	echo x | "$__progname" -c 'read s; echo $? $s .' || echo aborted, $?
	echo y | "$__progname" -c 'readonly s; read s; echo $? $s .' || echo aborted, $?
expected-stdout:
	0 x .
	2 .
expected-stderr-pattern:
	/read-only/
---
name: readonly-4
description:
	Do not permit bypassing readonly for first array item
stdin:
	set -A arr -- foo bar
	readonly arr
	arr=baz
	print -r -- "${arr[@@]}"
expected-exit: e != 0
expected-stderr-pattern:
	/read[ -]?only/
---
name: readonly-5
description:
	Ensure readonly is idempotent
stdin:
	readonly x=1
	readonly x
---
name: syntax-1
description:
	Check that lone ampersand is a syntax error
stdin:
	 &
expected-exit: e != 0
expected-stderr-pattern:
	/syntax error/
---
name: xxx-quoted-newline-1
description:
	Check that \<newline> works inside of ${}
stdin:
	abc=2
	echo ${ab\
	c}
expected-stdout:
	2
---
name: xxx-quoted-newline-2
description:
	Check that \<newline> works at the start of a here document
stdin:
	cat << EO\
	F
	hi
	EOF
expected-stdout:
	hi
---
name: xxx-quoted-newline-3
description:
	Check that \<newline> works at the end of a here document
stdin:
	cat << EOF
	hi
	EO\
	F
expected-stdout:
	hi
---
name: xxx-multi-assignment-cmd
description:
	Check that assignments in a command affect subsequent assignments
	in the same command
stdin:
	FOO=abc
	FOO=123 BAR=$FOO
	echo $BAR
expected-stdout:
	123
---
name: xxx-multi-assignment-posix-cmd
description:
	Check that the behaviour for multiple assignments with a
	command name matches POSIX. See:
	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
stdin:
	X=a Y=b; X=$Y Y=$X "$__progname" -c 'echo 1 $X $Y .'; echo 2 $X $Y .
	unset X Y Z
	X=a Y=${X=b} Z=$X "$__progname" -c 'echo 3 $Z .'
	unset X Y Z
	X=a Y=${X=b} Z=$X; echo 4 $Z .
expected-stdout:
	1 b a .
	2 a b .
	3 b .
	4 a .
---
name: xxx-multi-assignment-posix-nocmd
description:
	Check that the behaviour for multiple assignments with no
	command name matches POSIX (Debian #334182). See:
	http://thread.gmane.org/gmane.comp.standards.posix.austin.general/1925
stdin:
	X=a Y=b; X=$Y Y=$X; echo 1 $X $Y .
expected-stdout:
	1 b b .
---
name: xxx-multi-assignment-posix-subassign
description:
	Check that the behaviour for multiple assignments matches POSIX:
	- The assignment words shall be expanded in the current execution
	  environment.
	- The assignments happen in the temporary execution environment.
stdin:
	unset X Y Z
	Z=a Y=${X:=b} sh -c 'echo +$X+ +$Y+ +$Z+'
	echo /$X/
	# Now for the special case:
	unset X Y Z
	X= Y=${X:=b} sh -c 'echo +$X+ +$Y+'
	echo /$X/
expected-stdout:
	++ +b+ +a+
	/b/
	++ +b+
	/b/
---
name: xxx-exec-environment-1
description:
	Check to see if exec sets it's environment correctly
stdin:
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.$PATHSEP$PATH
	FOO=bar exec env
expected-stdout-pattern:
	/(^|.*\n)FOO=bar\n/
---
name: xxx-exec-environment-2
description:
	Check to make sure exec doesn't change environment if a program
	isn't exec-ed
stdin:
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.$PATHSEP$PATH
	env >bar1
	FOO=bar exec; env >bar2
	cmp -s bar1 bar2
---
name: exec-function-environment-1
description:
	Check assignments in function calls and whether they affect
	the current execution environment
stdin:
	f() { a=2; }; g() { b=3; echo y$c-; }; a=1 f; b=2; c=1 g
	echo x$a-$b- z$c-
expected-stdout:
	y1-
	x-3- z-
---
name: exec-modern-korn-shell
description:
	Check that exec can execute any command that makes it
	through syntax and parser
stdin:
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	PATH=$PWD
	exec 2>&1
	foo() { print two; }
	print =1
	(exec print one)
	print =2
	(exec foo)
	print =3
	(exec ls)
	print =4
	(exec lq)
expected-stdout-pattern:
	/=1\none\n=2\ntwo\n=3\n.*: ls: inaccessible or not found\n=4\ntf\n/
---
name: exec-ksh88
description:
	Check that exec only executes after a PATH search
arguments: !-o!posix!
stdin:
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	PATH=$PWD
	exec 2>&1
	foo() { print two; }
	print =1
	(exec print one)
	print =2
	(exec foo)
	print =3
	(exec ls)
	print =4
	(exec lq)
expected-stdout-pattern:
	/=1\n.*: print: inaccessible or not found\n=2\n.*: foo: inaccessible or not found\n=3\n.*: ls: inaccessible or not found\n=4\ntf\n/
---
name: xxx-what-do-you-call-this-1
stdin:
	echo "${foo:-"a"}*"
expected-stdout:
	a*
---
name: xxx-prefix-strip-1
stdin:
	foo='a cdef'
	echo ${foo#a c}
expected-stdout:
	def
---
name: xxx-prefix-strip-2
stdin:
	set a c
	x='a cdef'
	echo ${x#$*}
expected-stdout:
	def
---
name: xxx-variable-syntax-1
stdin:
	echo ${:}
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: xxx-variable-syntax-2
stdin:
	set 0
	echo ${*:0}
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: xxx-variable-syntax-3
stdin:
	set -A foo 0
	echo ${foo[*]:0}
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: xxx-variable-syntax-4
description:
	Not all kinds of trims are currently impossible, check those who do
stdin:
	foo() {
		echo "<$*> X${*:+ }X"
	}
	foo a b
	foo "" c
	foo ""
	foo "" ""
	IFS=:
	foo a b
	foo "" c
	foo ""
	foo "" ""
	IFS=
	foo a b
	foo "" c
	foo ""
	foo "" ""
expected-stdout:
	<a b> X X
	< c> X X
	<> XX
	< > X X
	<a:b> X X
	<:c> X X
	<> XX
	<:> X X
	<ab> X X
	<c> X X
	<> XX
	<> XX
---
name: xxx-substitution-eval-order
description:
	Check order of evaluation of expressions
stdin:
	i=1 x= y=
	set -A A abc def GHI j G k
	echo ${A[x=(i+=1)]#${A[y=(i+=2)]}}
	echo $x $y
expected-stdout:
	HI
	2 4
---
name: xxx-substitution-eval-order-2
description:
	Check some corner cases
stdin:
	unset var
	i=42
	: ${var+${q[i=777]}} required to be lazy by POSIX
	echo 1=$i
	var=meow
	i=42
	: ${var+${q[i=777]}} eval since var is now set
	echo 2=$i
	unset var
	i=42
	: ${var#${q[i=777]}} pattern is needed even if var is empty
	echo 3=$i
	var=meow
	i=42
	: ${var#${q[i=777]}}
	echo 4=$i
expected-stdout:
	1=42
	2=777
	3=777
	4=777
---
name: xxx-set-option-1
description:
	Check option parsing in set
stdin:
	set -vsA foo -- A 1 3 2
	echo ${foo[*]}
expected-stderr:
	echo ${foo[*]}
expected-stdout:
	1 2 3 A
---
name: xxx-exec-1
description:
	Check that exec exits for built-ins
need-ctty: yes
arguments: !-i!
stdin:
	exec echo hi
	echo still herre
expected-stdout:
	hi
expected-stderr-pattern: /.*/
---
name: xxx-while-1
description:
	Check the return value of while loops
	XXX need to do same for for/select/until loops
stdin:
	i=x
	while [ $i != xxx ] ; do
	    i=x$i
	    if [ $i = xxx ] ; then
		false
		continue
	    fi
	done
	echo loop1=$?
	
	i=x
	while [ $i != xxx ] ; do
	    i=x$i
	    if [ $i = xxx ] ; then
		false
		break
	    fi
	done
	echo loop2=$?
	
	i=x
	while [ $i != xxx ] ; do
	    i=x$i
	    false
	done
	echo loop3=$?
expected-stdout:
	loop1=0
	loop2=0
	loop3=1
---
name: xxx-status-1
description:
	Check that blank lines don't clear $?
need-ctty: yes
arguments: !-i!
stdin:
	(exit 1)
	echo $?
	(exit 1)
	
	echo $?
	true
expected-stdout:
	1
	1
expected-stderr-pattern: /.*/
---
name: xxx-status-2
description:
	Check that $? is preserved in subshells, includes, traps.
stdin:
	(exit 1)
	
	echo blank: $?
	
	(exit 2)
	(echo subshell: $?)
	
	echo 'echo include: $?' > foo
	(exit 3)
	. ./foo
	
	trap 'echo trap: $?' ERR
	(exit 4)
	echo exit: $?
expected-stdout:
	blank: 1
	subshell: 2
	include: 3
	trap: 4
	exit: 4
---
name: xxx-stat-1
description:
	Check that tests on files are consistent
	(fails when run as root, unfortunately)
category: disabled
stdin:
	mkdir a
	echo x >a/b
	test -e a/b; echo 1e $? .
	test -f a/b; echo 1f $? .
	chmod 0 a
	test -e a/b; echo 2e $? .
	test -f a/b; echo 2f $? .
	chmod 700 a
	test -e a/b; echo 3e $? .
	test -f a/b; echo 3f $? .
expected-stdout:
	1e 0 .
	1f 0 .
	2e 1 .
	2f 1 .
	3e 0 .
	3f 0 .
---
name: xxx-clean-chars-1
description:
	Check MAGIC character is stuffed correctly
stdin:
	echo `echo [`
expected-stdout:
	[
---
name: xxx-param-subst-qmark-1
description:
	Check suppresion of error message with null string.  According to
	POSIX, it shouldn't print the error as 'word' isn't ommitted.
	ksh88/93, Solaris /bin/sh and /usr/xpg4/bin/sh all print the error.
stdin:
	unset foo
	x=
	echo x${foo?$x}
expected-exit: 1
expected-stderr-pattern: !/not set/
---
name: xxx-param-subst-qmark-namespec
description:
	Check special names are output correctly
stdin:
	doit() {
		"$__progname" -c "$@@" >o1 2>o2
		rv=$?
		echo RETVAL: $rv
		sed -e "s^${__progname%.exe}\.*e*x*e*: PROG: " -e 's/^/STDOUT: /g' <o1
		sed -e "s^${__progname%.exe}\.*e*x*e*: PROG: " -e 's/^/STDERR: /g' <o2
	}
	doit 'echo ${1x}'
	doit 'echo "${1x}"'
	doit 'echo ${1?}'
	doit 'echo ${19?}'
	doit 'echo ${!:?}'
	doit -u 'echo ${*:?}' foo ""
expected-stdout:
	RETVAL: 1
	STDERR: PROG: ${1x}: bad substitution
	RETVAL: 1
	STDERR: PROG: ${1x}: bad substitution
	RETVAL: 1
	STDERR: PROG: 1: parameter null or not set
	RETVAL: 1
	STDERR: PROG: 19: parameter null or not set
	RETVAL: 1
	STDERR: PROG: !: parameter null or not set
	RETVAL: 1
	STDERR: foo: ${*:?}: bad substitution
---
name: xxx-param-_-1
# fails due to weirdness of execv stuff
category: !os:uwin-nt
description:
	Check c flag is set.
arguments: !-c!echo "[$-]"!
expected-stdout-pattern: /^\[.*c.*\]$/
---
name: tilde-expand-1
description:
	Check tilde expansion after equal signs
env-setup: !HOME=/sweet!
stdin:
	echo ${A=a=}~ b=~ c=d~ ~
	export e=~ f=d~
	command command export g=~ h=d~
	echo ". $e . $f ."
	echo ". $g . $h ."
	set -o posix
	unset A e f g h
	echo ${A=a=}~ b=~ c=d~ ~
	export e=~ f=d~
	command command export g=~ h=d~
	echo ". $e . $f ."
	echo ". $g . $h ."
expected-stdout:
	a=/sweet b=/sweet c=d~ /sweet
	. /sweet . d~ .
	. /sweet . d~ .
	a=~ b=~ c=d~ /sweet
	. /sweet . d~ .
	. /sweet . d~ .
---
name: tilde-expand-2
description:
	Check tilde expansion works
env-setup: !HOME=/sweet!
stdin:
	:>'c=a'
	typeset c=[ab]
	:>'d=a'
	x=typeset; $x d=[ab]
	echo "<$c>" "<$d>"
	wd=$PWD
	cd /
	plus=$(print -r -- ~+)
	minus=$(print -r -- ~-)
	nix=$(print -r -- ~)
	[[ $plus = / ]]; echo one $? .
	[[ $minus = "$wd" ]]; echo two $? .
	[[ $nix = /sweet ]]; echo nix $? .
expected-stdout:
	<[ab]> <a>
	one 0 .
	two 0 .
	nix 0 .
---
name: tilde-expand-3
description:
	Check mostly Austin 351 stuff
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	set "1 b=2" "3 d=4"
	export a=$1 \c=$2
	showargs 1 "$a" "$b" "$c" "$d"
	unset a b c d
	HOME=/tmp
	export \a=~ b=~
	command export c=~
	builtin export d=~
	\\builtin export e=~
	showargs 2 "$a" "$b" "$c" "$d" "$e" ksh
	unset a b c d e
	set -o posix
	export \a=~ b=~
	command export c=~
	builtin export d=~
	\\builtin export e=~
	showargs 3 "$a" "$b" "$c" "$d" "$e" posix
	unset a b c d e
	set +o posix
	export a=$1
	showargs 4 "$a" "$b" ksh
	unset a b
	showargs 5 a=$1 ksh
	export \a=$1
	showargs 6 "$a" "$b" ksh
	unset a b
	set -o posix
	export a=$1
	showargs 7 "$a" "$b" posix
	unset a b
	showargs 8 a=$1 posix
	export \a=$1
	showargs 9 "$a" "$b" posix
	unset a b
	set +o posix
	command echo 10 ksh a=~
	command command export a=~
	showargs 11 "$a"
	unset a
	set -o posix
	command echo 12 posix a=~
	command command export a=~
	showargs 13 "$a"
	unset a
	# unspecified whether /tmp or ~
	var=export; command $var a=~
	showargs 14 "$a"
	echo 'echo "<$foo>"' >bar
	"$__progname" bar
	var=foo
	export $var=1
	"$__progname" bar
	export $var=~
	"$__progname" bar
	# unspecified
	command -- export a=~
	showargs 18 "$a"
	set -A bla
	typeset bla[1]=~:~
	global gbl=~ g2=$1
	local lcl=~ l2=$1
	readonly ro=~ r2=$1
	showargs 19 "${bla[1]}" a=~ "$gbl" "$lcl" "$ro" "$g2" "$l2" "$r2"
	set +o posix
	echo "20 some arbitrary stuff "=~
	set -o posix
	echo "21 some arbitrary stuff "=~
expected-stdout:
	<1> <1 b=2> <> <3> <4> .
	<2> </tmp> </tmp> </tmp> </tmp> </tmp> <ksh> .
	<3> <~> </tmp> </tmp> <~> </tmp> <posix> .
	<4> <1 b=2> <> <ksh> .
	<5> <a=1> <b=2> <ksh> .
	<6> <1> <2> <ksh> .
	<7> <1 b=2> <> <posix> .
	<8> <a=1> <b=2> <posix> .
	<9> <1> <2> <posix> .
	10 ksh a=/tmp
	<11> </tmp> .
	12 posix a=~
	<13> </tmp> .
	<14> <~> .
	<>
	<1>
	<~>
	<18> <~> .
	<19> </tmp:/tmp> <a=~> </tmp> </tmp> </tmp> <1 b=2> <1 b=2> <1 b=2> .
	20 some arbitrary stuff =/tmp
	21 some arbitrary stuff =~
---
name: exit-err-1
description:
	Check some "exit on error" conditions
stdin:
	print '#!'"$__progname"'\nexec "$1"' >env
	print '#!'"$__progname"'\nexit 1' >false
	chmod +x env false
	PATH=.$PATHSEP$PATH
	set -ex
	env false && echo something
	echo END
expected-stdout:
	END
expected-stderr:
	+ env false
	+ echo END
---
name: exit-err-2
description:
	Check some "exit on error" edge conditions (POSIXly)
stdin:
	print '#!'"$__progname"'\nexec "$1"' >env
	print '#!'"$__progname"'\nexit 1' >false
	print '#!'"$__progname"'\nexit 0' >true
	chmod +x env false
	PATH=.$PATHSEP$PATH
	set -ex
	if env true; then
		env false && echo something
	fi
	echo END
expected-stdout:
	END
expected-stderr:
	+ env true
	+ env false
	+ echo END
---
name: exit-err-3
description:
	pdksh regression which AT&T ksh does right
	TFM says: [set] -e | errexit
		Exit (after executing the ERR trap) ...
stdin:
	trap 'echo EXIT' EXIT
	trap 'echo ERR' ERR
	set -e
	cd /XXXXX 2>/dev/null
	echo DONE
	exit 0
expected-stdout:
	ERR
	EXIT
expected-exit: e != 0
---
name: exit-err-4
description:
	"set -e" test suite (POSIX)
stdin:
	set -e
	echo pre
	if true ; then
		false && echo foo
	fi
	echo bar
expected-stdout:
	pre
	bar
---
name: exit-err-5
description:
	"set -e" test suite (POSIX)
stdin:
	set -e
	foo() {
		while [ "$1" ]; do
			for E in $x; do
				[ "$1" = "$E" ] && { shift ; continue 2 ; }
			done
			x="$x $1"
			shift
		done
		echo $x
	}
	echo pre
	foo a b b c
	echo post
expected-stdout:
	pre
	a b c
	post
---
name: exit-err-6
description:
	"set -e" test suite (BSD make)
category: os:mirbsd
stdin:
	mkdir zd zd/a zd/b
	print 'all:\n\t@@echo eins\n\t@@exit 42\n' >zd/a/Makefile
	print 'all:\n\t@@echo zwei\n' >zd/b/Makefile
	wd=$(pwd)
	set -e
	for entry in a b; do (  set -e;  if [[ -d $wd/zd/$entry.i386 ]]; then  _newdir_="$entry.i386";  else  _newdir_="$entry";  fi;  if [[ -z $_THISDIR_ ]]; then  _nextdir_="$_newdir_";  else  _nextdir_="$_THISDIR_/$_newdir_";  fi;  _makefile_spec_=;  [[ ! -f $wd/zd/$_newdir_/Makefile.bsd-wrapper ]]  || _makefile_spec_="-f Makefile.bsd-wrapper";  subskipdir=;  for skipdir in ; do  subentry=${skipdir#$entry};  if [[ $subentry != $skipdir ]]; then  if [[ -z $subentry ]]; then  echo "($_nextdir_ skipped)";  break;  fi;  subskipdir="$subskipdir ${subentry#/}";  fi;  done;  if [[ -z $skipdir || -n $subentry ]]; then  echo "===> $_nextdir_";  cd $wd/zd/$_newdir_;  make SKIPDIR="$subskipdir" $_makefile_spec_  _THISDIR_="$_nextdir_"   all;  fi;  ) done 2>&1 | sed "s!$wd!WD!g"
expected-stdout:
	===> a
	eins
	*** Error code 42
	
	Stop in WD/zd/a (line 2 of Makefile).
---
name: exit-err-7
description:
	"set -e" regression (LP#1104543)
stdin:
	set -e
	bla() {
		[ -x $PWD/nonexistant ] && $PWD/nonexistant
	}
	echo x
	bla
	echo y$?
expected-stdout:
	x
expected-exit: 1
---
name: exit-err-8
description:
	"set -e" regression (Debian #700526)
stdin:
	set -e
	_db_cmd() { return $1; }
	db_input() { _db_cmd 30; }
	db_go() { _db_cmd 0; }
	db_input || :
	db_go
	exit 0
---
name: exit-err-9
description:
	"set -e" versus bang pipelines
stdin:
	set -e
	! false | false
	echo 1 ok
	! false && false
	echo 2 wrong
expected-stdout:
	1 ok
expected-exit: 1
---
name: exit-err-10
description:
	Debian #269067 (cf. regression-38 but with eval)
arguments: !-e!
stdin:
	eval false || true
	echo = $? .
expected-stdout:
	= 0 .
---
name: exit-err-11
description:
	Fix -e inside eval, from Martijn Dekker; expected-stdout from ksh93
stdin:
	"$__progname" -c 'eval '\''echo ${-//[!eh]}; false; echo phantom e'\''; echo x$?'
	echo = $?
	"$__progname" -ec 'eval '\''echo ${-//[!eh]}; false; echo phantom e'\''; echo x$?'
	echo = $?
expected-stdout:
	h
	phantom e
	x0
	= 0
	eh
	= 1
---
name: exit-enoent-1
description:
	SUSv4 says that the shell should exit with 126/127 in some situations
stdin:
	i=0
	(echo; echo :) >x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	echo exit 42 >x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	rm -f x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
expected-stdout:
	0 0 .
	1 126 .
	2 42 .
	3 126 .
	4 127 .
	5 127 .
---
name: exit-eval-1
description:
	Check eval vs substitution exit codes (ksh93 alike)
stdin:
	(exit 12)
	eval $(false)
	echo A $?
	(exit 12)
	eval ' $(false)'
	echo B $?
	(exit 12)
	eval " $(false)"
	echo C $?
	(exit 12)
	eval "eval $(false)"
	echo D $?
	(exit 12)
	eval 'eval '"$(false)"
	echo E $?
	IFS="$IFS:"
	(exit 12)
	eval $(echo :; false)
	echo F $?
	echo -n "G "
	(exit 12)
	eval 'echo $?'
	echo H $?
expected-stdout:
	A 0
	B 1
	C 0
	D 0
	E 0
	F 0
	G 12
	H 0
---
name: exit-trap-1
description:
	Check that "exit" with no arguments behaves SUSv4 conformant.
stdin:
	trap 'echo hi; exit' EXIT
	exit 9
expected-stdout:
	hi
expected-exit: 9
---
name: exit-trap-2
description:
	Check that ERR and EXIT traps are run just like GNU bash does.
	ksh93 runs ERtrap after parameter null or not set (which mksh
	used to do) but (bug) continues and out, exit 0, in +e eval-undef.
file-setup: file 644 "x"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo "and run $2"
	eval $2
	echo and out
file-setup: file 644 "xt"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run true'
	true
	echo and out
file-setup: file 644 "xf"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run false'
	false
	echo and out
file-setup: file 644 "xu"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run ${v?}'
	${v?}
	echo and out
stdin:
	runtest() {
		rm -f rc
		(
			"$__progname" "$@@"
			echo $? >rc
		) 2>&1 | sed \
		    -e 's/parameter not set/parameter null or not set/' \
		    -e 's/[[]6]//' -e 's/: eval: line 1//' -e 's/: line 6//' \
		    -e "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
	}
	xe=-e
	echo : $xe
	runtest x $xe true
	echo = eval-true $(<rc) .
	runtest x $xe false
	echo = eval-false $(<rc) .
	runtest x $xe '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt $xe
	echo = noeval-true $(<rc) .
	runtest xf $xe
	echo = noeval-false $(<rc) .
	runtest xu $xe
	echo = noeval-undef $(<rc) .
	xe=+e
	echo : $xe
	runtest x $xe true
	echo = eval-true $(<rc) .
	runtest x $xe false
	echo = eval-false $(<rc) .
	runtest x $xe '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt $xe
	echo = noeval-true $(<rc) .
	runtest xf $xe
	echo = noeval-false $(<rc) .
	runtest xu $xe
	echo = noeval-undef $(<rc) .
expected-stdout:
	: -e
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	EXtrap
	= eval-false 1 .
	and run ${v?}
	x: v: parameter null or not set
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	EXtrap
	= noeval-false 1 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
	: +e
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	ERtrap
	and out
	EXtrap
	= eval-false 0 .
	and run ${v?}
	x: v: parameter null or not set
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	and out
	EXtrap
	= noeval-false 0 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
---
name: exit-trap-3
description:
	Check that the EXIT trap is run in many places, Debian #910276
stdin:
	fkt() {
		trap -- "echo $1 >&2" EXIT
	}
	fkt shell_exit
	$(fkt fn_exit)
	$(trap -- "echo comsub_exit >&2" EXIT)
	(trap -- "echo subshell_exit >&2" EXIT)
expected-stderr:
	fn_exit
	comsub_exit
	subshell_exit
	shell_exit
---
name: exit-trap-interactive
description:
	Check that interactive shell doesn't exit via EXIT trap on syntax error
arguments: !-i!
stdin:
	trap -- EXIT
	echo Syntax error <
	echo 'After error 1'
	trap 'echo Exit trap' EXIT
	echo Syntax error <
	echo 'After error 2'
	trap 'echo Exit trap' EXIT
	exit
	echo 'After exit'
expected-stdout:
	After error 1
	After error 2
	Exit trap
expected-stderr-pattern:
	/syntax error: unexpected 'newline'/
---
name: test-stlt-1
description:
	Check that test also can handle string1 < string2 etc.
stdin:
	test 2005/10/08 '<' 2005/08/21 && echo ja || echo nein
	test 2005/08/21 \< 2005/10/08 && echo ja || echo nein
	test 2005/10/08 '>' 2005/08/21 && echo ja || echo nein
	test 2005/08/21 \> 2005/10/08 && echo ja || echo nein
expected-stdout:
	nein
	ja
	ja
	nein
expected-stderr-pattern: !/unexpected op/
---
name: test-precedence-1
description:
	Check a weird precedence case (and POSIX echo)
stdin:
	test \( -f = -f \)
	rv=$?
	echo $rv
expected-stdout:
	0
---
name: test-option-1
description:
	Test the test -o operator
stdin:
	runtest() {
		test -o $1; echo $?
		[ -o $1 ]; echo $?
		[[ -o $1 ]]; echo $?
	}
	if_test() {
		test -o $1 -o -o !$1; echo $?
		[ -o $1 -o -o !$1 ]; echo $?
		[[ -o $1 || -o !$1 ]]; echo $?
		test -o ?$1; echo $?
	}
	echo 0y $(if_test utf8-mode) =
	echo 0n $(if_test utf8-hack) =
	echo 1= $(runtest utf8-hack) =
	echo 2= $(runtest !utf8-hack) =
	echo 3= $(runtest ?utf8-hack) =
	set +U
	echo 1+ $(runtest utf8-mode) =
	echo 2+ $(runtest !utf8-mode) =
	echo 3+ $(runtest ?utf8-mode) =
	set -U
	echo 1- $(runtest utf8-mode) =
	echo 2- $(runtest !utf8-mode) =
	echo 3- $(runtest ?utf8-mode) =
	echo = short flags =
	echo 0y $(if_test -U) =
	echo 0y $(if_test +U) =
	echo 0n $(if_test -_) =
	echo 0n $(if_test -U-) =
	echo 1= $(runtest -_) =
	echo 2= $(runtest !-_) =
	echo 3= $(runtest ?-_) =
	set +U
	echo 1+ $(runtest -U) =
	echo 2+ $(runtest !-U) =
	echo 3+ $(runtest ?-U) =
	echo 1+ $(runtest +U) =
	echo 2+ $(runtest !+U) =
	echo 3+ $(runtest ?+U) =
	set -U
	echo 1- $(runtest -U) =
	echo 2- $(runtest !-U) =
	echo 3- $(runtest ?-U) =
	echo 1- $(runtest +U) =
	echo 2- $(runtest !+U) =
	echo 3- $(runtest ?+U) =
expected-stdout:
	0y 0 0 0 0 =
	0n 1 1 1 1 =
	1= 1 1 1 =
	2= 1 1 1 =
	3= 1 1 1 =
	1+ 1 1 1 =
	2+ 0 0 0 =
	3+ 0 0 0 =
	1- 0 0 0 =
	2- 1 1 1 =
	3- 0 0 0 =
	= short flags =
	0y 0 0 0 0 =
	0y 0 0 0 0 =
	0n 1 1 1 1 =
	0n 1 1 1 1 =
	1= 1 1 1 =
	2= 1 1 1 =
	3= 1 1 1 =
	1+ 1 1 1 =
	2+ 0 0 0 =
	3+ 0 0 0 =
	1+ 1 1 1 =
	2+ 0 0 0 =
	3+ 0 0 0 =
	1- 0 0 0 =
	2- 1 1 1 =
	3- 0 0 0 =
	1- 0 0 0 =
	2- 1 1 1 =
	3- 0 0 0 =
---
name: test-varset-1
description:
	Test the test -v operator
stdin:
	[[ -v a ]]
	rv=$?; echo $((++i)) $rv
	a=
	[[ -v a ]]
	rv=$?; echo $((++i)) $rv
	unset a
	[[ -v a ]]
	rv=$?; echo $((++i)) $rv
	a=x
	[[ -v a ]]
	rv=$?; echo $((++i)) $rv
	nameref b=a
	[[ -v b ]]
	rv=$?; echo $((++i)) $rv
	unset a
	[[ -v b ]]
	rv=$?; echo $((++i)) $rv
	x[1]=y
	[[ -v x ]]
	rv=$?; echo $((++i)) $rv
	[[ -v x[0] ]]
	rv=$?; echo $((++i)) $rv
	[[ -v x[1] ]]
	rv=$?; echo $((++i)) $rv
	[[ -v x[2] ]]
	rv=$?; echo $((++i)) $rv
expected-stdout:
	1 1
	2 0
	3 1
	4 0
	5 0
	6 1
	7 1
	8 1
	9 0
	10 1
---
name: test-varset-2
description:
	test -v works only on scalars
stdin:
	[[ -v x[*] ]]
	echo ok
expected-exit: e != 0
expected-stderr-pattern:
	/unexpected '\*'/
---
name: test-stnze-1
description:
	Check that the short form [ $x ] works
stdin:
	i=0
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
	x=0
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
	x='1 -a 1 = 2'
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
expected-stdout:
	1 0
	2 1
	3 1
	4 1
	5 0
	6 0
	7 0
	8 0
	9 1
	10 1
	11 0
	12 0
---
name: test-stnze-2
description:
	Check that the short form [[ $x ]] works (ksh93 extension)
stdin:
	i=0
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
	x=0
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
	x='1 -a 1 = 2'
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
expected-stdout:
	1 1
	2 1
	3 1
	4 1
	5 0
	6 0
	7 0
	8 0
	9 0
	10 0
	11 0
	12 0
---
name: test-numeq
description:
	Check numeric -eq works (R40d regression); spotted by Martijn Dekker
stdin:
	tst() {
		eval "$2"
		case $? in
		(0) echo yepp 0 \#"$*" ;;
		(1) echo nope 1 \#"$*" ;;
		(2) echo terr 2 \#"$*" ;;
		(*) echo wtf\? $? \#"$*" ;;
		esac
	}
	tst 1 'test 2 -eq 2'
	tst 2 'test 2 -eq 2a'
	tst 3 'test 2 -eq 3'
	tst 4 'test 2 -ne 2'
	tst 5 'test 2 -ne 2a'
	tst 6 'test 2 -ne 3'
	tst 7 'test \! 2 -eq 2'
	tst 8 'test \! 2 -eq 2a'
	tst 9 'test \! 2 -eq 3'
expected-stdout:
	yepp 0 #1 test 2 -eq 2
	terr 2 #2 test 2 -eq 2a
	nope 1 #3 test 2 -eq 3
	nope 1 #4 test 2 -ne 2
	terr 2 #5 test 2 -ne 2a
	yepp 0 #6 test 2 -ne 3
	nope 1 #7 test \! 2 -eq 2
	terr 2 #8 test \! 2 -eq 2a
	yepp 0 #9 test \! 2 -eq 3
expected-stderr-pattern:
	/bad number/
---
name: mkshrc-1
description:
	Check that ~/.mkshrc works correctly.
	Part 1: verify user environment is not read (internal)
stdin:
	echo x $FNORD
expected-stdout:
	x
---
name: mkshrc-2a
description:
	Check that ~/.mkshrc works correctly.
	Part 2: verify mkshrc is not read (non-interactive shells)
file-setup: file 644 ".mkshrc"
	FNORD=42
env-setup: !HOME=.!ENV=!
stdin:
	echo x $FNORD
expected-stdout:
	x
---
name: mkshrc-2b
description:
	Check that ~/.mkshrc works correctly.
	Part 2: verify mkshrc can be read (interactive shells)
file-setup: file 644 ".mkshrc"
	FNORD=42
need-ctty: yes
arguments: !-i!
env-setup: !HOME=.!ENV=!PS1=!
stdin:
	echo x $FNORD
expected-stdout:
	x 42
expected-stderr-pattern:
	/(# )*/
---
name: mkshrc-3
description:
	Check that ~/.mkshrc works correctly.
	Part 3: verify mkshrc can be turned off
file-setup: file 644 ".mkshrc"
	FNORD=42
env-setup: !HOME=.!ENV=nonexistant!
stdin:
	echo x $FNORD
expected-stdout:
	x
---
name: sh-mode-1
description:
	Check that sh mode turns braceexpand off
	and that that works correctly
stdin:
	set -o braceexpand
	set +o sh
	[[ $(set +o) == *@@(-o sh)@@(| *) ]] && echo sh || echo nosh
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
	echo {a,b,c}
	set +o braceexpand
	echo {a,b,c}
	set -o braceexpand
	echo {a,b,c}
	set -o sh
	echo {a,b,c}
	[[ $(set +o) == *@@(-o sh)@@(| *) ]] && echo sh || echo nosh
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
	set -o braceexpand
	echo {a,b,c}
	[[ $(set +o) == *@@(-o sh)@@(| *) ]] && echo sh || echo nosh
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
expected-stdout:
	nosh
	brex
	a b c
	{a,b,c}
	a b c
	{a,b,c}
	sh
	nobrex
	a b c
	sh
	brex
---
name: sh-mode-2a
description:
	Check that posix or sh mode is *not* automatically turned on
category: !binsh
stdin:
	ln -s "$__progname" ksh || cp "$__progname" ksh
	ln -s "$__progname" sh || cp "$__progname" sh
	ln -s "$__progname" ./-ksh || cp "$__progname" ./-ksh
	ln -s "$__progname" ./-sh || cp "$__progname" ./-sh
	for shell in {,-}{,k}sh; do
		print -- $shell $(./$shell +l -c \
		    '[[ $(set +o) == *"-o "@@(sh|posix)@@(| *) ]] && echo sh || echo nosh')
	done
expected-stdout:
	sh nosh
	ksh nosh
	-sh nosh
	-ksh nosh
---
name: sh-mode-2b
description:
	Check that posix or sh mode *is* automatically turned on
category: binsh
stdin:
	ln -s "$__progname" ksh || cp "$__progname" ksh
	ln -s "$__progname" sh || cp "$__progname" sh
	ln -s "$__progname" ./-ksh || cp "$__progname" ./-ksh
	ln -s "$__progname" ./-sh || cp "$__progname" ./-sh
	for shell in {,-}{,k}sh; do
		print -- $shell $(./$shell +l -c \
		    '[[ $(set +o) == *"-o "@@(sh|posix)@@(| *) ]] && echo sh || echo nosh')
	done
expected-stdout:
	sh sh
	ksh nosh
	-sh sh
	-ksh nosh
---
name: pipeline-1
description:
	pdksh bug: last command of a pipeline is executed in a
	subshell - make sure it still is, scripts depend on it
file-setup: file 644 "abcx"
file-setup: file 644 "abcy"
stdin:
	echo *
	echo a | while read d; do
		echo $d
		echo $d*
		echo *
		set -o noglob
		echo $d*
		echo *
	done
	echo *
expected-stdout:
	abcx abcy
	a
	abcx abcy
	abcx abcy
	a*
	*
	abcx abcy
---
name: pipeline-2
description:
	check that co-processes work with TCOMs, TPIPEs and TPARENs
category: !nojsig
stdin:
	"$__progname" -c 'i=100; echo hi |& while read -p line; do echo "$((i++)) $line"; done'
	"$__progname" -c 'i=200; echo hi | cat |& while read -p line; do echo "$((i++)) $line"; done'
	"$__progname" -c 'i=300; (echo hi | cat) |& while read -p line; do echo "$((i++)) $line"; done'
expected-stdout:
	100 hi
	200 hi
	300 hi
---
name: pipeline-3
description:
	Check that PIPESTATUS does what it's supposed to
stdin:
	echo 1 $PIPESTATUS .
	echo 2 ${PIPESTATUS[0]} .
	echo 3 ${PIPESTATUS[1]} .
	(echo x; exit 12) | (cat; exit 23) | (cat; exit 42)
	echo 5 $? , $PIPESTATUS , ${PIPESTATUS[0]} , ${PIPESTATUS[1]} , ${PIPESTATUS[2]} , ${PIPESTATUS[3]} .
	echo 6 ${PIPESTATUS[0]} .
	set | fgrep PIPESTATUS
	echo 8 $(set | fgrep PIPESTATUS) .
expected-stdout:
	1 0 .
	2 0 .
	3 .
	x
	5 42 , 12 , 12 , 23 , 42 , .
	6 0 .
	PIPESTATUS[0]=0
	8 PIPESTATUS[0]=0 PIPESTATUS[1]=0 .
---
name: pipeline-4
description:
	Check that "set -o pipefail" does what it's supposed to
stdin:
	echo 1 "$("$__progname" -c '(exit 12) | (exit 23) | (exit 42); echo $?')" .
	echo 2 "$("$__progname" -c '! (exit 12) | (exit 23) | (exit 42); echo $?')" .
	echo 3 "$("$__progname" -o pipefail -c '(exit 12) | (exit 23) | (exit 42); echo $?')" .
	echo 4 "$("$__progname" -o pipefail -c '! (exit 12) | (exit 23) | (exit 42); echo $?')" .
	echo 5 "$("$__progname" -c '(exit 23) | (exit 42) | :; echo $?')" .
	echo 6 "$("$__progname" -c '! (exit 23) | (exit 42) | :; echo $?')" .
	echo 7 "$("$__progname" -o pipefail -c '(exit 23) | (exit 42) | :; echo $?')" .
	echo 8 "$("$__progname" -o pipefail -c '! (exit 23) | (exit 42) | :; echo $?')" .
	echo 9 "$("$__progname" -o pipefail -c 'x=$( (exit 23) | (exit 42) | :); echo $?')" .
expected-stdout:
	1 42 .
	2 0 .
	3 42 .
	4 0 .
	5 0 .
	6 1 .
	7 42 .
	8 0 .
	9 42 .
---
name: persist-history-1
description:
	Check if persistent history saving works
category: !no-histfile
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	cat hist.file
expected-stdout-pattern:
	/cat hist.file/
expected-stderr-pattern:
	/^X*$/
---
name: typeset-1
description:
	Check that typeset -g works correctly
stdin:
	set -A arrfoo 65
	foo() {
		typeset -g -Uui16 arrfoo[*]
	}
	echo before ${arrfoo[0]} .
	foo
	echo after ${arrfoo[0]} .
	set -A arrbar 65
	bar() {
		echo inside before ${arrbar[0]} .
		arrbar[0]=97
		echo inside changed ${arrbar[0]} .
		typeset -g -Uui16 arrbar[*]
		echo inside typeset ${arrbar[0]} .
		arrbar[0]=48
		echo inside changed ${arrbar[0]} .
	}
	echo before ${arrbar[0]} .
	bar
	echo after ${arrbar[0]} .
expected-stdout:
	before 65 .
	after 16#41 .
	before 65 .
	inside before 65 .
	inside changed 97 .
	inside typeset 16#61 .
	inside changed 16#30 .
	after 16#30 .
---
name: typeset-2
description:
	Check that typeset -p on arrays works correctly
stdin:
	set -A x -- a b c
	echo =
	typeset -p x
	echo =
	typeset -p x[1]
expected-stdout:
	=
	set -A x
	typeset x[0]=a
	typeset x[1]=b
	typeset x[2]=c
	=
	typeset x[1]=b
---
name: typeset-padding-1
description:
	Check if left/right justification works as per TFM
stdin:
	typeset -L10 ln=0hall0
	typeset -R10 rn=0hall0
	typeset -ZL10 lz=0hall0
	typeset -ZR10 rz=0hall0
	typeset -Z10 rx=" hallo "
	echo "<$ln> <$rn> <$lz> <$rz> <$rx>"
expected-stdout:
	<0hall0    > <    0hall0> <hall0     > <00000hall0> <0000 hallo>
---
name: typeset-padding-2
description:
	Check if base-!10 integers are padded right
stdin:
	typeset -Uui16 -L9 ln=16#1
	typeset -Uui16 -R9 rn=16#1
	typeset -Uui16 -Z9 zn=16#1
	typeset -L9 ls=16#1
	typeset -R9 rs=16#1
	typeset -Z9 zs=16#1
	echo "<$ln> <$rn> <$zn> <$ls> <$rs> <$zs>"
expected-stdout:
	<16#1     > <     16#1> <16#000001> <16#1     > <     16#1> <0000016#1>
---
name: typeset-padding-3
description:
	Check for a regression in which UTF-8 wasnt left-padded right
stdin:
	set -U
	nl=$'\n'
	typeset -L20 x='.  ak'
	typeset -R20 y='.  ak'
	print -r -- "<$x> (1$nl<12345678910 345678920$nl<$y> 1)"
	typeset -L20 x='.  a'
	typeset -R20 y='.  a'
	print -r -- "<$x> (2$nl<12345678910 345678920$nl<$y> 2)"
expected-stdout:
	<.  ak               > (1
	<12345678910 345678920
	<               .  ak> 1)
	<.  a               > (2
	<12345678910 345678920
	<               .  a> 2)
---
name: utf8bom-1
description:
	Check that the UTF-8 Byte Order Mark is ignored as the first
	multibyte character of the shell input (with -c, from standard
	input, as file, or as eval argument), but nowhere else
# breaks on Mac OSX (HFS+ non-standard UTF-8 canonical decomposition)
category: !os:darwin,!shell:ebcdic-yes
stdin:
	mkdir foo
	print '#!/bin/sh\necho ohne' >foo/fnord
	print '#!/bin/sh\necho mit' >foo/fnord
	print 'fnord\nfnord\nfnord\nfnord' >foo/bar
	print eval \''fnord\nfnord\nfnord\nfnord'\' >foo/zoo
	set -A anzahl -- foo/*
	echo got ${#anzahl[*]} files
	chmod +x foo/*
	export PATH=$(pwd)/foo$PATHSEP$PATH
	"$__progname" -c 'fnord'
	echo =
	"$__progname" -c 'fnord; fnord; fnord; fnord'
	echo =
	"$__progname" foo/bar
	echo =
	"$__progname" <foo/bar
	echo =
	"$__progname" foo/zoo
	echo =
	"$__progname" -c 'echo : $(fnord)'
	rm -rf foo
expected-stdout:
	got 4 files
	ohne
	=
	ohne
	ohne
	mit
	ohne
	=
	ohne
	ohne
	mit
	ohne
	=
	ohne
	ohne
	mit
	ohne
	=
	ohne
	ohne
	mit
	ohne
	=
	: ohne
---
name: utf8bom-2
description:
	Check that we can execute BOM-shebangs (failures not fatal)
	XXX if the OS can already execute them, we lose
	note: cygwin execve(2) doesn't return to us with ENOEXEC, we lose
	note: Ultrix perl5 t4 returns 65280 (exit-code 255) and no text
	XXX fails when LD_PRELOAD is set with -e and Perl chokes it (ASan)
need-pass: no
category: !os:cygwin,!os:midipix,!os:msys,!os:ultrix,!os:uwin-nt,!smksh
env-setup: !FOO=BAR!
stdin:
	print '#!'"$__progname"'\nprint "1 a=$ENV{FOO}";' >t1
	print '#!'"$__progname"'\nprint "2 a=$ENV{FOO}";' >t2
	print '#!'"$__perlname"'\nprint "3 a=$ENV{FOO}\n";' >t3
	print '#!'"$__perlname"'\nprint "4 a=$ENV{FOO}\n";' >t4
	chmod +x t?
	./t1
	./t2
	./t3
	./t4
expected-stdout:
	1 a=/nonexistant{FOO}
	2 a=/nonexistant{FOO}
	3 a=BAR
	4 a=BAR
expected-stderr-pattern:
	/(Unrecognized character .... ignored at \..t4 line 1)*/
---
name: utf8opt-1
description:
	Check that the utf8-mode flag is not set at non-interactive startup
env-setup: !PS1=!PS2=!LC_CTYPE=@@utflocale@@!
stdin:
	if [[ $- = *U* ]]; then
		echo is set
	else
		echo is not set
	fi
expected-stdout:
	is not set
---
name: utf8opt-2
description:
	Check that the utf8-mode flag is set at interactive startup.
	If your OS is old, try passing HAVE_SETLOCALE_CTYPE=0 to Build.sh
need-pass: no
category: !noutf8
need-ctty: yes
arguments: !-i!
env-setup: !PS1=!PS2=!LC_CTYPE=@@utflocale@@!
stdin:
	if [[ $- = *U* ]]; then
		echo is set
	else
		echo is not set
	fi
expected-stdout:
	is set
expected-stderr-pattern:
	/(# )*/
---
name: utf8opt-3a
description:
	Ensure U on the command line is honoured
	(these two tests may pass falsely depending on CPPFLAGS)
stdin:
	export i=0
	code='if [[ $- = *U* ]]; then echo $i on; else echo $i off; fi'
	let i++; "$__progname" -U -c "$code"
	let i++; "$__progname" +U -c "$code"
	echo $((++i)) done
expected-stdout:
	1 on
	2 off
	3 done
---
name: utf8opt-3b
description:
	Ensure U on the command line is honoured, interactive shells
need-ctty: yes
stdin:
	export i=0
	code='if [[ $- = *U* ]]; then echo $i on; else echo $i off; fi'
	let i++; "$__progname" -U -ic "$code"
	let i++; "$__progname" +U -ic "$code"
	echo $((++i)) done
expected-stdout:
	1 on
	2 off
	3 done
---
name: utf8bug-1
description:
	Ensure trailing combining characters are not lost
stdin:
	set -U
	a=a
	b=$'\u0301'
	x=$a$b
	print -r -- "<e$x>"
	x=$a
	x+=$b
	print -r -- "<e$x>"
	b=$'\u0301'b
	x=$a
	x+=$b
	print -r -- "<e$x>"
expected-stdout:
	<ea>
	<ea>
	<eab>
---
name: aliases-1
description:
	Check if built-in shell aliases are okay
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\\builtin typeset -fu'
	functions='\\builtin typeset -f'
	hash='\\builtin alias -t'
	history='\\builtin fc -l'
	integer='\\builtin typeset -i'
	local='\\builtin typeset'
	login='\\builtin exec login'
	nameref='\\builtin typeset -n'
	nohup='nohup '
	r='\\builtin fc -e -'
	type='\\builtin whence -v'
---
name: aliases-2b
description:
	Check if set -o sh does not influence built-in aliases
arguments: !-o!sh!
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\\builtin typeset -fu'
	functions='\\builtin typeset -f'
	hash='\\builtin alias -t'
	history='\\builtin fc -l'
	integer='\\builtin typeset -i'
	local='\\builtin typeset'
	login='\\builtin exec login'
	nameref='\\builtin typeset -n'
	nohup='nohup '
	r='\\builtin fc -e -'
	type='\\builtin whence -v'
---
name: aliases-3b
description:
	Check if running as sh does not influence built-in aliases
stdin:
	cp "$__progname" sh
	./sh -c 'alias; typeset -f'
	rm -f sh
expected-stdout:
	autoload='\\builtin typeset -fu'
	functions='\\builtin typeset -f'
	hash='\\builtin alias -t'
	history='\\builtin fc -l'
	integer='\\builtin typeset -i'
	local='\\builtin typeset'
	login='\\builtin exec login'
	nameref='\\builtin typeset -n'
	nohup='nohup '
	r='\\builtin fc -e -'
	type='\\builtin whence -v'
---
name: aliases-cmdline
description:
	Check that aliases work from the command line (Debian #517009)
	Note that due to the nature of the lexing process, defining
	aliases in COMSUBs then immediately using them, and things
	like 'alias foo=bar && foo', still fail.
stdin:
	"$__progname" -c $'alias a="echo OK"\na'
expected-stdout:
	OK
---
name: aliases-funcdef-1
description:
	Check if POSIX functions take precedences over aliases
stdin:
	alias foo='echo makro'
	foo() {
		echo funktion
	}
	foo
expected-stdout:
	makro
---
name: aliases-funcdef-2
description:
	Check if POSIX functions take precedences over aliases
stdin:
	alias foo='echo makro'
	foo () {
		echo funktion
	}
	foo
expected-stdout:
	makro
---
name: aliases-funcdef-3
description:
	Check if aliases take precedences over Korn functions
stdin:
	alias foo='echo makro'
	function foo {
		echo funktion
	}
	foo
expected-stdout:
	makro
---
name: aliases-funcdef-4
description:
	Functions should only take over if actually being defined
stdin:
	alias local
	:|| local() { :; }
	alias local
expected-stdout:
	local='\\builtin typeset'
	local='\\builtin typeset'
---
name: arrays-1
description:
	Check if Korn Shell arrays work as expected
stdin:
	v="c d"
	set -A foo -- a \$v "$v" '$v' b
	echo "${#foo[*]}|${foo[0]}|${foo[1]}|${foo[2]}|${foo[3]}|${foo[4]}|"
expected-stdout:
	5|a|$v|c d|$v|b|
---
name: arrays-2a
description:
	Check if bash-style arrays work as expected
stdin:
	v="c d"
	foo=(a \$v "$v" '$v' b)
	echo "${#foo[*]}|${foo[0]}|${foo[1]}|${foo[2]}|${foo[3]}|${foo[4]}|"
expected-stdout:
	5|a|$v|c d|$v|b|
---
name: arrays-2b
description:
	Check if bash-style arrays work as expected, with newlines
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "$x|"; done' >pfp
	chmod +x pfp
	test -n "$ZSH_VERSION" && setopt KSH_ARRAYS
	v="e f"
	foo=(a
		bc
		d \$v "$v" '$v' g
	)
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
	foo=(a\
		bc
		d \$v "$v" '$v' g
	)
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
	foo=(a\
	bc\\
		d \$v "$v" '$v'
	g)
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
expected-stdout:
	7|a|bc|d|$v|e f|$v|g|
	7|a|bc|d|$v|e f|$v|g|
	6|abc\|d|$v|e f|$v|g||
---
name: arrays-3
description:
	Check if array bounds are uint32_t
stdin:
	set -A foo a b c
	foo[4097]=d
	foo[2147483637]=e
	echo ${foo[*]}
	foo[-1]=f
	echo ${foo[4294967295]} g ${foo[*]}
expected-stdout:
	a b c d e
	f g a b c d e f
---
name: arrays-4
description:
	Check if Korn Shell arrays with specified indices work as expected
stdin:
	v="c d"
	set -A foo -- [1]=\$v [2]="$v" [4]='$v' [0]=a [5]=b
	echo "${#foo[*]}|${foo[0]}|${foo[1]}|${foo[2]}|${foo[3]}|${foo[4]}|${foo[5]}|"
	# we don't want this at all:
	#	5|a|$v|c d||$v|b|
	set -A arr "[5]=meh"
	echo "<${arr[0]}><${arr[5]}>"
expected-stdout:
	5|[1]=$v|[2]=c d|[4]=$v|[0]=a|[5]=b||
	<[5]=meh><>
---
name: arrays-5
description:
	Check if bash-style arrays with specified indices work as expected
	(taken out temporarily to fix arrays-4; see also arrays-9a comment)
category: disabled
stdin:
	v="c d"
	foo=([1]=\$v [2]="$v" [4]='$v' [0]=a [5]=b)
	echo "${#foo[*]}|${foo[0]}|${foo[1]}|${foo[2]}|${foo[3]}|${foo[4]}|${foo[5]}|"
	x=([128]=foo bar baz)
	echo k= ${!x[*]} .
	echo v= ${x[*]} .
	# Check that we do not break this by globbing
	:>b=blah
	bleh=5
	typeset -a arr
	arr+=([bleh]=blah)
	echo "<${arr[0]}><${arr[5]}>"
expected-stdout:
	5|a|$v|c d||$v|b|
	k= 128 129 130 .
	v= foo bar baz .
	<><blah>
---
name: arrays-6
description:
	Check if we can get the array keys (indices) for indexed arrays,
	Korn shell style
stdin:
	of() {
		i=0
		for x in "$@@"; do
			echo -n "$((i++))<$x>"
		done
		echo
	}
	foo[1]=eins
	set | grep '^foo'
	echo =
	foo[0]=zwei
	foo[4]=drei
	set | grep '^foo'
	echo =
	echo a $(of ${foo[*]}) = $(of ${bar[*]}) a
	echo b $(of "${foo[*]}") = $(of "${bar[*]}") b
	echo c $(of ${foo[@@]}) = $(of ${bar[@@]}) c
	echo d $(of "${foo[@@]}") = $(of "${bar[@@]}") d
	echo e $(of ${!foo[*]}) = $(of ${!bar[*]}) e
	echo f $(of "${!foo[*]}") = $(of "${!bar[*]}") f
	echo g $(of ${!foo[@@]}) = $(of ${!bar[@@]}) g
	echo h $(of "${!foo[@@]}") = $(of "${!bar[@@]}") h
expected-stdout:
	foo[1]=eins
	=
	foo[0]=zwei
	foo[1]=eins
	foo[4]=drei
	=
	a 0<zwei>1<eins>2<drei> = a
	b 0<zwei eins drei> = 0<> b
	c 0<zwei>1<eins>2<drei> = c
	d 0<zwei>1<eins>2<drei> = d
	e 0<0>1<1>2<4> = e
	f 0<0 1 4> = 0<> f
	g 0<0>1<1>2<4> = g
	h 0<0>1<1>2<4> = h
---
name: arrays-7
description:
	Check if we can get the array keys (indices) for indexed arrays,
	Korn shell style, in some corner cases
stdin:
	echo !arz: ${!arz}
	echo !arz[0]: ${!arz[0]}
	echo !arz[1]: ${!arz[1]}
	arz=foo
	echo !arz: ${!arz}
	echo !arz[0]: ${!arz[0]}
	echo !arz[1]: ${!arz[1]}
	unset arz
	echo !arz: ${!arz}
	echo !arz[0]: ${!arz[0]}
	echo !arz[1]: ${!arz[1]}
expected-stdout:
	!arz: arz
	!arz[0]: arz[0]
	!arz[1]: arz[1]
	!arz: arz
	!arz[0]: arz[0]
	!arz[1]: arz[1]
	!arz: arz
	!arz[0]: arz[0]
	!arz[1]: arz[1]
---
name: arrays-8
description:
	Check some behavioural rules for arrays.
stdin:
	fna() {
		set -A aa 9
	}
	fnb() {
		typeset ab
		set -A ab 9
	}
	fnc() {
		typeset ac
		set -A ac 91
		unset ac
		set -A ac 92
	}
	fnd() {
		set +A ad 9
	}
	fne() {
		unset ae
		set +A ae 9
	}
	fnf() {
		unset af[0]
		set +A af 9
	}
	fng() {
		unset ag[*]
		set +A ag 9
	}
	set -A aa 1 2
	set -A ab 1 2
	set -A ac 1 2
	set -A ad 1 2
	set -A ae 1 2
	set -A af 1 2
	set -A ag 1 2
	set -A ah 1 2
	typeset -Z3 aa ab ac ad ae af ag
	print 1a ${aa[*]} .
	print 1b ${ab[*]} .
	print 1c ${ac[*]} .
	print 1d ${ad[*]} .
	print 1e ${ae[*]} .
	print 1f ${af[*]} .
	print 1g ${ag[*]} .
	print 1h ${ah[*]} .
	fna
	fnb
	fnc
	fnd
	fne
	fnf
	fng
	typeset -Z5 ah[*]
	print 2a ${aa[*]} .
	print 2b ${ab[*]} .
	print 2c ${ac[*]} .
	print 2d ${ad[*]} .
	print 2e ${ae[*]} .
	print 2f ${af[*]} .
	print 2g ${ag[*]} .
	print 2h ${ah[*]} .
expected-stdout:
	1a 001 002 .
	1b 001 002 .
	1c 001 002 .
	1d 001 002 .
	1e 001 002 .
	1f 001 002 .
	1g 001 002 .
	1h 1 2 .
	2a 9 .
	2b 001 002 .
	2c 92 .
	2d 009 002 .
	2e 9 .
	2f 9 002 .
	2g 009 .
	2h 00001 00002 .
---
name: arrays-9a
description:
	Check that we can concatenate arrays
stdin:
	unset foo; foo=(bar); foo+=(baz); echo 1 ${!foo[*]} : ${foo[*]} .
	unset foo; foo=(foo bar); foo+=(baz); echo 2 ${!foo[*]} : ${foo[*]} .
#	unset foo; foo=([2]=foo [0]=bar); foo+=(baz [5]=quux); echo 3 ${!foo[*]} : ${foo[*]} .
expected-stdout:
	1 0 1 : bar baz .
	2 0 1 2 : foo bar baz .
#	3 0 2 3 5 : bar foo baz quux .
---
name: arrays-9b
description:
	Check that we can concatenate parameters too
stdin:
	unset foo; foo=bar; foo+=baz; echo 1 $foo .
	unset foo; typeset -i16 foo=10; foo+=20; echo 2 $foo .
expected-stdout:
	1 barbaz .
	2 16#a20 .
---
name: arrassign-basic
description:
	Check basic whitespace conserving properties of wdarrassign
stdin:
	a=($(echo a  b))
	b=($(echo "a  b"))
	c=("$(echo "a  b")")
	d=("$(echo a  b)")
	a+=($(echo c  d))
	b+=($(echo "c  d"))
	c+=("$(echo "c  d")")
	d+=("$(echo c  d)")
	echo ".a:${a[0]}.${a[1]}.${a[2]}.${a[3]}:"
	echo ".b:${b[0]}.${b[1]}.${b[2]}.${b[3]}:"
	echo ".c:${c[0]}.${c[1]}.${c[2]}.${c[3]}:"
	echo ".d:${d[0]}.${d[1]}.${d[2]}.${d[3]}:"
expected-stdout:
	.a:a.b.c.d:
	.b:a.b.c.d:
	.c:a  b.c  d..:
	.d:a b.c d..:
---
name: arrassign-eol
description:
	Commands after array assignments are not permitted
stdin:
	foo=(a b) env
expected-exit: e != 0
expected-stderr-pattern:
	/syntax error: unexpected 'env'/
---
name: arrassign-fnc-none
description:
	Check locality of array access inside a function
stdin:
	function fn {
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		if [[ -n $BASH_VERSION ]]; then
			y=()
		else
			set -A y
		fi
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	x=(m m)
	y=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:m.m.f.:
	.f1:m.m.f.:
	.fn:m.m.f.f:
	.f2:m.m.f.f:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:f...:
	.rfn:f...:
	.rf2:f...:
---
name: arrassign-fnc-local
description:
	Check locality of array access inside a function
	with the bash/mksh/ksh93 local/typeset keyword
	(note: ksh93 has no local; typeset works only in FKSH)
stdin:
	function fn {
		typeset x
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		if [[ -n $BASH_VERSION ]]; then
			y=()
		else
			set -A y
		fi
		typeset y
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	function fnr {
		typeset z
		if [[ -n $BASH_VERSION ]]; then
			z=()
		else
			set -A z
		fi
		z+=(f)
		echo ".fnr:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	}
	x=(m m)
	y=(m m)
	z=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	echo ".f0r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f1r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f2r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:f...:
	.f1:m.m..:
	.fn:f...:
	.f2:m.m..:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:...:
	.rfn:f...:
	.rf2:...:
	.f0r:m.m..:
	.fnr:f...:
	.f1r:m.m..:
	.fnr:f...:
	.f2r:m.m..:
---
name: arrassign-fnc-global
description:
	Check locality of array access inside a function
	with the bash4/mksh/yash/zsh typeset -g keyword
stdin:
	function fn {
		typeset -g x
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		set -A y
		typeset -g y
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	function fnr {
		typeset -g z
		set -A z
		z+=(f)
		echo ".fnr:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	}
	x=(m m)
	y=(m m)
	z=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	echo ".f0r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f1r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f2r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:m.m.f.:
	.f1:m.m.f.:
	.fn:m.m.f.f:
	.f2:m.m.f.f:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:f...:
	.rfn:f...:
	.rf2:f...:
	.f0r:m.m..:
	.fnr:f...:
	.f1r:f...:
	.fnr:f...:
	.f2r:f...:
---
name: strassign-fnc-none
description:
	Check locality of string access inside a function
stdin:
	function fn {
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		y+=f
		echo ".rfn:$y:"
	}
	x=m
	y=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
expected-stdout:
	.f0:m:
	.fn:mf:
	.f1:mf:
	.fn:mff:
	.f2:mff:
	.rf0:m:
	.rfn:f:
	.rf1:f:
	.rfn:f:
	.rf2:f:
---
name: strassign-fnc-local
description:
	Check locality of string access inside a function
	with the bash/mksh/ksh93 local/typeset keyword
	(note: ksh93 has no local; typeset works only in FKSH)
stdin:
	function fn {
		typeset x
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		typeset y
		y+=f
		echo ".rfn:$y:"
	}
	function fnr {
		typeset z
		z=
		z+=f
		echo ".fnr:$z:"
	}
	x=m
	y=m
	z=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
	echo ".f0r:$z:"
	fnr
	echo ".f1r:$z:"
	fnr
	echo ".f2r:$z:"
expected-stdout:
	.f0:m:
	.fn:f:
	.f1:m:
	.fn:f:
	.f2:m:
	.rf0:m:
	.rfn:f:
	.rf1::
	.rfn:f:
	.rf2::
	.f0r:m:
	.fnr:f:
	.f1r:m:
	.fnr:f:
	.f2r:m:
---
name: strassign-fnc-global
description:
	Check locality of string access inside a function
	with the bash4/mksh/yash/zsh typeset -g keyword
stdin:
	function fn {
		typeset -g x
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		typeset -g y
		y+=f
		echo ".rfn:$y:"
	}
	function fnr {
		typeset -g z
		z=
		z+=f
		echo ".fnr:$z:"
	}
	x=m
	y=m
	z=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
	echo ".f0r:$z:"
	fnr
	echo ".f1r:$z:"
	fnr
	echo ".f2r:$z:"
expected-stdout:
	.f0:m:
	.fn:mf:
	.f1:mf:
	.fn:mff:
	.f2:mff:
	.rf0:m:
	.rfn:f:
	.rf1:f:
	.rfn:f:
	.rf2:f:
	.f0r:m:
	.fnr:f:
	.f1r:f:
	.fnr:f:
	.f2r:f:
---
name: unset-fnc-local-ksh
description:
	Check that unset removes a previous local
	(ksh93 syntax compatible version); apparently,
	there are shells which fail this?
stdin:
	function f {
		echo f0: $x
		typeset x
		echo f1: $x
		x=fa
		echo f2: $x
		unset x
		echo f3: $x
		x=fb
		echo f4: $x
	}
	x=o
	echo before: $x
	f
	echo after: $x
expected-stdout:
	before: o
	f0: o
	f1:
	f2: fa
	f3: o
	f4: fb
	after: fb
---
name: unset-fnc-local-sh
description:
	Check that unset removes a previous local
	(Debian Policy 10.4 sh version); apparently,
	there are shells which fail this?
stdin:
	f() {
		echo f0: $x
		local x
		echo f1: $x
		x=fa
		echo f2: $x
		unset x
		echo f3: $x
		x=fb
		echo f4: $x
	}
	x=o
	echo before: $x
	f
	echo after: $x
expected-stdout:
	before: o
	f0: o
	f1:
	f2: fa
	f3: o
	f4: fb
	after: fb
---
name: varexpand-substr-1
description:
	Check if bash-style substring expansion works
	when using positive numerics
stdin:
	x=abcdefghi
	typeset -i y=123456789
	typeset -i 16 z=123456789	# 16#75bcd15
	echo a t${x:2:2} ${y:2:3} ${z:2:3} a
	echo b ${x::3} ${y::3} ${z::3} b
	echo c ${x:2:} ${y:2:} ${z:2:} c
	echo d ${x:2} ${y:2} ${z:2} d
	echo e ${x:2:6} ${y:2:6} ${z:2:7} e
	echo f ${x:2:7} ${y:2:7} ${z:2:8} f
	echo g ${x:2:8} ${y:2:8} ${z:2:9} g
expected-stdout:
	a tcd 345 #75 a
	b abc 123 16# b
	c c
	d cdefghi 3456789 #75bcd15 d
	e cdefgh 345678 #75bcd1 e
	f cdefghi 3456789 #75bcd15 f
	g cdefghi 3456789 #75bcd15 g
---
name: varexpand-substr-2
description:
	Check if bash-style substring expansion works
	when using negative numerics or expressions
stdin:
	x=abcdefghi
	typeset -i y=123456789
	typeset -i 16 z=123456789	# 16#75bcd15
	n=2
	echo a ${x:$n:3} ${y:$n:3} ${z:$n:3} a
	echo b ${x:(n):3} ${y:(n):3} ${z:(n):3} b
	echo c ${x:(-2):1} ${y:(-2):1} ${z:(-2):1} c
	echo d t${x: n:2} ${y: n:3} ${z: n:3} d
expected-stdout:
	a cde 345 #75 a
	b cde 345 #75 b
	c h 8 1 c
	d tcd 345 #75 d
---
name: varexpand-substr-3
description:
	Check that some things that work in bash fail.
	This is by design. Oh and vice versa, nowadays.
stdin:
	export x=abcdefghi n=2
	"$__progname" -c 'echo v${x:(n)}x'
	"$__progname" -c 'echo w${x: n}x'
	"$__progname" -c 'echo x${x:n}x'
	"$__progname" -c 'echo y${x:}x'
	"$__progname" -c 'echo z${x}x'
	# next fails only in bash
	"$__progname" -c 'x=abcdef;y=123;echo ${x:${y:2:1}:2}' >/dev/null 2>&1; echo $?
expected-stdout:
	vcdefghix
	wcdefghix
	zabcdefghix
	0
expected-stderr-pattern:
	/x:n.*bad substitution.*\n.*bad substitution/
---
name: varexpand-substr-4
description:
	Check corner cases for substring expansion
stdin:
	x=abcdefghi
	integer y=2
	echo a ${x:(y == 1 ? 2 : 3):4} a
expected-stdout:
	a defg a
---
name: varexpand-substr-5A
description:
	Check that substring expansions work on characters
stdin:
	set +U
	x=mh
	echo a ${x::1} ${x: -1} a
	echo b ${x::3} ${x: -3} b
	echo c ${x:1:2} ${x: -3:2} c
	echo d ${#x} d
expected-stdout:
	a m h a
	b m h b
	c   c
	d 4 d
---
name: varexpand-substr-5W
description:
	Check that substring expansions work on characters
stdin:
	set -U
	x=mh
	echo a ${x::1} ${x: -1} a
	echo b ${x::2} ${x: -2} b
	echo c ${x:1:1} ${x: -2:1} c
	echo d ${#x} d
expected-stdout:
	a m h a
	b m h b
	c   c
	d 3 d
---
name: varexpand-substr-6
description:
	Check that string substitution works correctly
stdin:
	foo=1
	bar=2
	baz=qwertyuiop
	echo a ${baz: foo: bar}
	echo b ${baz: foo: $bar}
	echo c ${baz: $foo: bar}
	echo d ${baz: $foo: $bar}
expected-stdout:
	a we
	b we
	c we
	d we
---
name: varexpand-special-hash
description:
	Check special ${var@@x} expansion for x=hash
category: !shell:ebcdic-yes
stdin:
	typeset -i8 foo=10
	bar=baz
	unset baz
	print ${foo@@#} ${bar@@#} ${baz@@#} .
expected-stdout:
	9B15FBFB CFBDD32B 00000000 .
---
name: varexpand-special-hash-ebcdic
description:
	Check special ${var@@x} expansion for x=hash
category: !shell:ebcdic-no
stdin:
	typeset -i8 foo=10
	bar=baz
	unset baz
	print ${foo@@#} ${bar@@#} ${baz@@#} .
expected-stdout:
	016AE33D 9769C4AF 00000000 .
---
name: varexpand-special-quote
description:
	Check special ${var@@Q} expansion for quoted strings
category: !shell:faux-ebcdic
stdin:
	set +U
	i=x
	j=a\ b
	k=$'c
	d\xA0''ef'
	print -r -- "<i=$i j=$j k=$k>"
	s="u=${i@@Q} v=${j@@Q} w=${k@@Q}"
	print -r -- "s=\"$s\""
	eval "$s"
	typeset -p u v w
expected-stdout:
	<i=x j=a b k=c
	def>
	s="u=x v='a b' w=$'c\nd\240e\u20ACf'"
	typeset u=x
	typeset v='a b'
	typeset w=$'c\nd\240e\u20ACf'
---
name: varexpand-special-quote-faux-EBCDIC
description:
	Check special ${var@@Q} expansion for quoted strings
category: shell:faux-ebcdic
stdin:
	set +U
	i=x
	j=a\ b
	k=$'c
	d\xA0''ef'
	print -r -- "<i=$i j=$j k=$k>"
	s="u=${i@@Q} v=${j@@Q} w=${k@@Q}"
	print -r -- "s=\"$s\""
	eval "$s"
	typeset -p u v w
expected-stdout:
	<i=x j=a b k=c
	def>
	s="u=x v='a b' w=$'c\nde\u20ACf'"
	typeset u=x
	typeset v='a b'
	typeset w=$'c\nde\u20ACf'
---
name: varexpand-null-1
description:
	Ensure empty strings expand emptily
stdin:
	print s ${a} . ${b} S
	print t ${a#?} . ${b%?} T
	print r ${a=} . ${b/c/d} R
	print q
	print s "${a}" . "${b}" S
	print t "${a#?}" . "${b%?}" T
	print r "${a=}" . "${b/c/d}" R
expected-stdout:
	s . S
	t . T
	r . R
	q
	s  .  S
	t  .  T
	r  .  R
---
name: varexpand-null-2
description:
	Ensure empty strings, when quoted, are expanded as empty strings
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "<$x> "; done' >pfs
	chmod +x pfs
	./pfs 1 "${a}" 2 "${a#?}" + "${b%?}" 3 "${a=}" + "${b/c/d}"
	echo .
expected-stdout:
	<1> <> <2> <> <+> <> <3> <> <+> <> .
---
name: varexpand-null-3
description:
	Ensure concatenating behaviour matches other shells
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	showargs 0 ""$@@
	x=; showargs 1 "$x"$@@
	set A; showargs 2 "${@@:+}"
	n() { echo "$#"; }
	unset e
	set -- a b
	n """$@@"
	n "$@@"
	n "$@@"""
	n "$e""$@@"
	n "$@@"
	n "$@@""$e"
	set --
	n """$@@"
	n "$@@"
	n "$@@"""
	n "$e""$@@"
	n "$@@"
	n "$@@""$e"
expected-stdout:
	<0> <> .
	<1> <> .
	<2> <> .
	2
	2
	2
	2
	2
	2
	1
	0
	1
	1
	0
	1
---
name: varexpand-funny-chars
description:
	Check some characters
	XXX \uEF80 is asymmetric, possibly buggy so we dont check this
stdin:
	x=$'<\x00>'; typeset -p x
	x=$'<\x01>'; typeset -p x
	x=$'<\u0000>'; typeset -p x
	x=$'<\u0001>'; typeset -p x
expected-stdout:
	typeset x='<'
	typeset x=$'<\001>'
	typeset x='<'
	typeset x=$'<\001>'
---
name: print-funny-chars
description:
	Check print builtin's capability to output designated characters
stdin:
	{
		print '<\0144\0344\xDB\u00DB\u20AC\uDB\x40>'
		print '<\x00>'
		print '<\x01>'
		print '<\u0000>'
		print '<\u0001>'
	} | {
		# integer-base-one-3Ar
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		dasc=
		if read -arN -1 line; then
			typeset -i1 line
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line[i-1]#1#}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
		fi
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  3C 64 E4 DB C3 9B E2 82 - AC C3 9B 40 3E 0A 3C 00  |<d.........@@>.<.|
	00000010  3E 0A 3C 01 3E 0A 3C 00 - 3E 0A 3C 01 3E 0A        |>.<.>.<.>.<.>.|
---
name: print-bksl-c
description:
	Check print builtin's \c escape
stdin:
	print '\ca'; print b
expected-stdout:
	ab
---
name: print-cr
description:
	Check that CR+LF is not collapsed into LF as some MSYS shells wrongly do
stdin:
	echo '#!'"$__progname" >foo
	cat >>foo <<-'EOF'
		print -n -- '220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT\r\n220->> Bitte keine Werbung einwerfen! <<\r\r\n220 Who do you wanna pretend to be today'
		print \?
	EOF
	chmod +x foo
	echo "[$(./foo)]"
	./foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT
	220->> Bitte keine Werbung einwerfen! <<
	220 Who do you wanna pretend to be today?]
	{220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT}
	{220->> Bitte keine Werbung einwerfen! <<}
	{220 Who do you wanna pretend to be today?}
---
name: print-crlf
description:
	Check that CR+LF is shown and read as-is
category: shell:textmode-no
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		echo .${#x} #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[.5
	<bar
	>]
	{.5}
	{<bar}
---
name: print-crlf-textmode
description:
	Check that CR+LF is treated as newline
category: shell:textmode-yes
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		echo .${#x} #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[.4
	<bar
	>]
	{.4}
	{<bar}
---
name: print-lf
description:
	Check that LF-only is shown and read as-is
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		echo .${#x} #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[.4
	<bar
	>]
	{.4}
	{<bar}
---
name: print-nul-chars
description:
	Check handling of NUL characters for print and COMSUB
stdin:
	x=$(print '<\0>')
	print $(($(print '<\0>' | wc -c))) $(($(print "$x" | wc -c))) \
	    ${#x} "$x" '<\0>'
expected-stdout-pattern:
	/^4 3 2 <> <\0>$/
---
name: print-array
description:
	Check that print -A works as expected
stdin:
	print -An 0x20AC 0xC3 0xBC 8#101
	set -U
	print -A 0x20AC 0xC3 0xBC 8#102
expected-stdout:
	AB
---
name: print-escapes
description:
	Check backslash expansion by the print builtin
stdin:
	print '\ \!\"\#\$\%\&'\\\''\(\)\*\+\,\-\.\/\0\1\2\3\4\5\6\7\8' \
	    '\9\:\;\<\=\>\?\@@\A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T' \
	    '\U\V\W\X\Y\Z\[\\\]\^\_\`\a\b  \d\e\f\g\h\i\j\k\l\m\n\o\p' \
	    '\q\r\s\t\u\v\w\x\y\z\{\|\}\~' '\u20acd' '\U20acd' '\x123' \
	    '\0x' '\0123' '\01234' | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  5C 20 5C 21 5C 22 5C 23 - 5C 24 5C 25 5C 26 5C 27  |\ \!\"\#\$\%\&\'|
	00000010  5C 28 5C 29 5C 2A 5C 2B - 5C 2C 5C 2D 5C 2E 5C 2F  |\(\)\*\+\,\-\.\/|
	00000020  5C 31 5C 32 5C 33 5C 34 - 5C 35 5C 36 5C 37 5C 38  |\1\2\3\4\5\6\7\8|
	00000030  20 5C 39 5C 3A 5C 3B 5C - 3C 5C 3D 5C 3E 5C 3F 5C  | \9\:\;\<\=\>\?\|
	00000040  40 5C 41 5C 42 5C 43 5C - 44 1B 5C 46 5C 47 5C 48  |@@\A\B\C\D.\F\G\H|
	00000050  5C 49 5C 4A 5C 4B 5C 4C - 5C 4D 5C 4E 5C 4F 5C 50  |\I\J\K\L\M\N\O\P|
	00000060  5C 51 5C 52 5C 53 5C 54 - 20 5C 55 5C 56 5C 57 5C  |\Q\R\S\T \U\V\W\|
	00000070  58 5C 59 5C 5A 5C 5B 5C - 5C 5D 5C 5E 5C 5F 5C 60  |X\Y\Z\[\\]\^\_\`|
	00000080  07 08 20 20 5C 64 1B 0C - 5C 67 5C 68 5C 69 5C 6A  |..  \d..\g\h\i\j|
	00000090  5C 6B 5C 6C 5C 6D 0A 5C - 6F 5C 70 20 5C 71 0D 5C  |\k\l\m.\o\p \q.\|
	000000A0  73 09 5C 75 0B 5C 77 5C - 78 5C 79 5C 7A 5C 7B 5C  |s.\u.\w\x\y\z\{\|
	000000B0  7C 5C 7D 5C 7E 20 E2 82 - AC 64 20 EF BF BD 20 12  ||\}\~ ...d ... .|
	000000C0  33 20 78 20 53 20 53 34 - 0A                       |3 x S S4.|
---
name: dollar-doublequoted-strings
description:
	Check that a $ preceding "" is ignored
stdin:
	echo $"Localise me!"
	cat <<<$"Me too!"
	V=X
	aol=aol
	cat <<-$"aol"
		I do not take a $V for a V!
	aol
expected-stdout:
	Localise me!
	Me too!
	I do not take a $V for a V!
---
name: dollar-quoted-strings
description:
	Check backslash expansion by $'' strings
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
	./pfn $'\ \!\"\#\$\%\&\'\(\)\*\+\,\-\.\/ \1\2\3\4\5\6' \
	    $'a\0b' $'a\01b' $'\7\8\9\:\;\<\=\>\?\@@\A\B\C\D\E\F\G\H\I' \
	    $'\J\K\L\M\N\O\P\Q\R\S\T\U1\V\W\X\Y\Z\[\\\]\^\_\`\a\b\d\e' \
	    $'\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u1\v\w\x1\y\z\{\|\}\~ $x' \
	    $'\u20acd' $'\U20acd' $'\x123' $'fn\x0rd' $'\0234' $'\234' \
	    $'\2345' $'\ca' $'\c!' $'\c?' $'\c' $'a\
	b' | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  20 21 22 23 24 25 26 27 - 28 29 2A 2B 2C 2D 2E 2F  | !"#$%&'()*+,-./|
	00000010  20 01 02 03 04 05 06 0A - 61 0A 61 01 62 0A 07 38  | .......a.a.b..8|
	00000020  39 3A 3B 3C 3D 3E 3F 40 - 41 42 43 44 1B 46 47 48  |9:;<=>?@@ABCD.FGH|
	00000030  49 0A 4A 4B 4C 4D 4E 4F - 50 51 52 53 54 01 56 57  |I.JKLMNOPQRST.VW|
	00000040  58 59 5A 5B 5C 5D 5E 5F - 60 07 08 64 1B 0A 0C 67  |XYZ[\]^_`..d...g|
	00000050  68 69 6A 6B 6C 6D 0A 6F - 70 71 0D 73 09 01 0B 77  |hijklm.opq.s...w|
	00000060  01 79 7A 7B 7C 7D 7E 20 - 24 78 0A E2 82 AC 64 0A  |.yz{|}~ $x....d.|
	00000070  EF BF BD 0A C4 A3 0A 66 - 6E 0A 13 34 0A 9C 0A 9C  |.......fn..4....|
	00000080  35 0A 01 0A 01 0A 7F 0A - 82 80 A6 0A 61 0A 62 0A  |5...........a.b.|
---
name: dollar-quotes-in-heredocs-strings
description:
	They are, however, not parsed in here documents, here strings
	(outside of string delimiters) or regular strings, but in
	parameter substitutions.
stdin:
	cat <<EOF
		dollar = strchr(s, '$');	/* ' */
		foo " bar \" baz
	EOF
	cat <<$'a\tb'
	a\tb
	a	b
	cat <<<"dollar = strchr(s, '$');	/* ' */"
	cat <<<'dollar = strchr(s, '\''$'\'');	/* '\'' */'
	x="dollar = strchr(s, '$');	/* ' */"
	cat <<<"$x"
	cat <<<$'a\E[0m\tb'
	unset nl; print -r -- "x${nl:=$'\n'}y"
	echo "1 foo\"bar"
	# cf & HEREDOC
	cat <<EOF
	2 foo\"bar
	EOF
	# probably never reached for here strings?
	cat <<<"3 foo\"bar"
	cat <<<"4 foo\\\"bar"
	cat <<<'5 foo\"bar'
	# old scripts use this (e.g. ncurses)
	echo "^$"
	# make sure this works, outside of quotes
	cat <<<'7'$'\t''.'
expected-stdout:
		dollar = strchr(s, '$');	/* ' */
		foo " bar \" baz
	a\tb
	dollar = strchr(s, '$');	/* ' */
	dollar = strchr(s, '$');	/* ' */
	dollar = strchr(s, '$');	/* ' */
	a[0m	b
	x
	y
	1 foo"bar
	2 foo\"bar
	3 foo"bar
	4 foo\"bar
	5 foo\"bar
	^$
	7	.
---
name: dot-needs-argument
description:
	check Debian #415167 solution: '.' without arguments should fail
stdin:
	"$__progname" -c .
	"$__progname" -c source
expected-exit: e != 0
expected-stderr-pattern:
	/\.: missing argument.*\n.*source: missing argument/
---
name: dot-errorlevel
description:
	Ensure dot resets $?
stdin:
	:>dotfile
	(exit 42)
	. ./dotfile
	echo 1 $? .
expected-stdout:
	1 0 .
---
name: alias-function-no-conflict
description:
	make aliases not conflict with function definitions
stdin:
	# POSIX function can be defined, but alias overrides it
	alias foo='echo bar'
	foo
	foo() {
		echo baz
	}
	foo
	unset -f foo
	foo 2>/dev/null || echo rab
	# alias overrides ksh function
	alias korn='echo bar'
	korn
	function korn {
		echo baz
	}
	korn
	# alias temporarily overrides POSIX function
	bla() {
		echo bfn
	}
	bla
	alias bla='echo bal'
	bla
	unalias bla
	bla
expected-stdout:
	bar
	bar
	bar
	bar
	bar
	bfn
	bal
	bfn
---
name: bash-function-parens
description:
	ensure the keyword function is ignored when preceding
	POSIX style function declarations (bashism)
stdin:
	mk() {
		echo '#!'"$__progname"
		echo "$1 {"
		echo '	echo "bar='\''$0'\'\"
		echo '}'
		print -r -- "${2:-foo}"
	}
	mk 'function foo' >f-korn
	mk 'foo ()' >f-dash
	mk 'function foo ()' >f-bash
	print '#!'"$__progname"'\nprint -r -- "${0%/f-argh}"' >f-argh
	chmod +x f-*
	u=$(./f-argh)
	x="korn: $(./f-korn)"; echo "${x/@@("$u")/.}"
	x="dash: $(./f-dash)"; echo "${x/@@("$u")/.}"
	x="bash: $(./f-bash)"; echo "${x/@@("$u")/.}"
expected-stdout:
	korn: bar='foo'
	dash: bar='./f-dash'
	bash: bar='./f-bash'
---
name: integer-base-one-1
description:
	check if the use of fake integer base 1 works
stdin:
	set -U
	typeset -Uui16 i0=1# i1=1#
	typeset -i1 o0a=64
	typeset -i1 o1a=0x263A
	typeset -Uui1 o0b=0x7E
	typeset -Uui1 o1b=0xFDD0
	integer px=0xCAFE 'p0=1# ' p1=1# pl=1#f
	echo "in <$i0> <$i1>"
	echo "out <${o0a#1#}|${o0b#1#}> <${o1a#1#}|${o1b#1#}>"
	typeset -Uui1 i0 i1
	echo "pass <$px> <$p0> <$p1> <$pl> <${i0#1#}|${i1#1#}>"
	typeset -Uui16 tv1=1#~ tv2=1# tv3=1# tv4=1# tv5=1# tv6=1# tv7=1# tv8=1#
	echo "specX <${tv1#16#}> <${tv2#16#}> <${tv3#16#}> <${tv4#16#}> <${tv5#16#}> <${tv6#16#}> <${tv7#16#}> <${tv8#16#}>"
	typeset -i1 tv1 tv2 tv3 tv4 tv5 tv6 tv7 tv8
	echo "specW <${tv1#1#}> <${tv2#1#}> <${tv3#1#}> <${tv4#1#}> <${tv5#1#}> <${tv6#1#}> <${tv7#1#}> <${tv8#1#}>"
	typeset -i1 xs1=0xEF7F xs2=0xEF80 xs3=0xFDD0
	echo "specU <${xs1#1#}> <${xs2#1#}> <${xs3#1#}>"
expected-stdout:
	in <16#EFEF> <16#20AC>
	out <@@|~> <|>
	pass <16#cafe> <1# > <1#> <1#f> <|>
	specX <7E> <7F> <EF80> <EF81> <EFC0> <EFC1> <A0> <80>
	specW <~> <> <> <> <> <> <> <>
	specU <> <> <>
---
name: integer-base-one-2a
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#foo
	echo /$x/
expected-stderr-pattern:
	/1#foo: unexpected 'oo'/
expected-exit: e != 0
---
name: integer-base-one-2b
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#
	echo /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2c1
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#
	echo /$x/
expected-stdout:
	/1#/
---
name: integer-base-one-2c2
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set +U
	integer x=1#
	echo /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d1
description:
	check if the use of fake integer base 1 handles octets okay
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid utf-8
expected-stdout:
	/16#efff/
---
name: integer-base-one-2d2
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 2-byte
expected-stdout:
	/16#efc2/
---
name: integer-base-one-2d3
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 2-byte
expected-stdout:
	/16#efef/
---
name: integer-base-one-2d4
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 3-byte
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d5
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d6
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-3As
description:
	some sample code for hexdumping
	not NUL safe; input lines must be NL terminated
stdin:
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\x${i#16#1}"
		done
		print '\0z'
	} | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\..|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  |................|
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |................|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F 80 81 82 83 84 85 86 - 87 88 89 8A 8B 8C 8D 8E  |................|
	000000B0  8F 90 91 92 93 94 95 96 - 97 98 99 9A 9B 9C 9D 9E  |................|
	000000C0  9F A0 A1 A2 A3 A4 A5 A6 - A7 A8 A9 AA AB AC AD AE  |................|
	000000D0  AF B0 B1 B2 B3 B4 B5 B6 - B7 B8 B9 BA BB BC BD BE  |................|
	000000E0  BF C0 C1 C2 C3 C4 C5 C6 - C7 C8 C9 CA CB CC CD CE  |................|
	000000F0  CF D0 D1 D2 D3 D4 D5 D6 - D7 D8 D9 DA DB DC DD DE  |................|
	00000100  DF E0 E1 E2 E3 E4 E5 E6 - E7 E8 E9 EA EB EC ED EE  |................|
	00000110  EF F0 F1 F2 F3 F4 F5 F6 - F7 F8 F9 FA FB FC FD FE  |................|
	00000120  FF 7A 0A                -                          |.z.|
---
name: integer-base-one-3Ws
description:
	some sample code for hexdumping UCS-2
	not NUL safe; input lines must be NL terminated
stdin:
	set -U
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
		print ''	# end of range
		print '\0z'		# embedded NUL
	} | {
		# integer-base-one-3Ws
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z7 hv
		typeset -i1 wc=0x0A
		typeset -i lpos
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			lpos=0
			while (( lpos < ${#line} )); do
				wc=1#${line:(lpos++):1}
				if (( (wc < 32) || \
				    ((wc > 126) && (wc < 160)) )); then
					dch=.
				elif (( (wc & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${wc#1#}
				fi
				if (( (pos & 7) == 7 )); then
					dasc=$dasc$dch
					dch=
				elif (( (pos & 7) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				let hv=wc
				print -n "${hv#16#} "
				(( (pos++ & 7) == 3 )) && \
				    print -n -- '- '
				dasc=$dasc$dch
			done
		done
		while (( pos & 7 )); do
			print -n '     '
			(( (pos++ & 7) == 3 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  0048 0065 006C 006C - 006F 002C 0020 0057  |Hello, W|
	00000008  006F 0072 006C 0064 - 0021 005C 000A 3053  |orld!\.|
	00000010  3093 306B 3061 306F - FF01 000A 0001 0002  |...|
	00000018  0003 0004 0005 0006 - 0007 0008 0009 000A  |........|
	00000020  000B 000C 000D 000E - 000F 0010 0011 0012  |........|
	00000028  0013 0014 0015 0016 - 0017 0018 0019 001A  |........|
	00000030  001B 001C 001D 001E - 001F 0020 0021 0022  |..... !"|
	00000038  0023 0024 0025 0026 - 0027 0028 0029 002A  |#$%&'()*|
	00000040  002B 002C 002D 002E - 002F 0030 0031 0032  |+,-./012|
	00000048  0033 0034 0035 0036 - 0037 0038 0039 003A  |3456789:|
	00000050  003B 003C 003D 003E - 003F 0040 0041 0042  |;<=>?@@AB|
	00000058  0043 0044 0045 0046 - 0047 0048 0049 004A  |CDEFGHIJ|
	00000060  004B 004C 004D 004E - 004F 0050 0051 0052  |KLMNOPQR|
	00000068  0053 0054 0055 0056 - 0057 0058 0059 005A  |STUVWXYZ|
	00000070  005B 005C 005D 005E - 005F 0060 0061 0062  |[\]^_`ab|
	00000078  0063 0064 0065 0066 - 0067 0068 0069 006A  |cdefghij|
	00000080  006B 006C 006D 006E - 006F 0070 0071 0072  |klmnopqr|
	00000088  0073 0074 0075 0076 - 0077 0078 0079 007A  |stuvwxyz|
	00000090  007B 007C 007D 007E - 007F 0080 0081 0082  |{|}~....|
	00000098  0083 0084 0085 0086 - 0087 0088 0089 008A  |........|
	000000A0  008B 008C 008D 008E - 008F 0090 0091 0092  |........|
	000000A8  0093 0094 0095 0096 - 0097 0098 0099 009A  |........|
	000000B0  009B 009C 009D 009E - 009F 00A0 00A1 00A2  |.....|
	000000B8  00A3 00A4 00A5 00A6 - 00A7 00A8 00A9 00AA  ||
	000000C0  00AB 00AC 00AD 00AE - 00AF 00B0 00B1 00B2  ||
	000000C8  00B3 00B4 00B5 00B6 - 00B7 00B8 00B9 00BA  ||
	000000D0  00BB 00BC 00BD 00BE - 00BF 00C0 00C1 00C2  ||
	000000D8  00C3 00C4 00C5 00C6 - 00C7 00C8 00C9 00CA  ||
	000000E0  00CB 00CC 00CD 00CE - 00CF 00D0 00D1 00D2  ||
	000000E8  00D3 00D4 00D5 00D6 - 00D7 00D8 00D9 00DA  ||
	000000F0  00DB 00DC 00DD 00DE - 00DF 00E0 00E1 00E2  ||
	000000F8  00E3 00E4 00E5 00E6 - 00E7 00E8 00E9 00EA  ||
	00000100  00EB 00EC 00ED 00EE - 00EF 00F0 00F1 00F2  ||
	00000108  00F3 00F4 00F5 00F6 - 00F7 00F8 00F9 00FA  ||
	00000110  00FB 00FC 00FD 00FE - 00FF 000A EFFF 000A  |..|
	00000118  EFC2 000A EFEF EFBF - EFC0 000A EFC0 EF80  |..|
	00000120  000A EFE0 EF80 EF80 - 000A FFFD EFEF EFBF  |..|
	00000128  EFBE EFEF EFBF EFBF - 000A 007A 000A       |.z.|
---
name: integer-base-one-3Ar
description:
	some sample code for hexdumping; NUL and binary safe
stdin:
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\x${i#16#1}"
		done
		print '\0z'
	} | {
		# integer-base-one-3Ar
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		dasc=
		if read -arN -1 line; then
			typeset -i1 line
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line[i-1]#1#}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
		fi
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\..|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  |................|
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |................|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F 80 81 82 83 84 85 86 - 87 88 89 8A 8B 8C 8D 8E  |................|
	000000B0  8F 90 91 92 93 94 95 96 - 97 98 99 9A 9B 9C 9D 9E  |................|
	000000C0  9F A0 A1 A2 A3 A4 A5 A6 - A7 A8 A9 AA AB AC AD AE  |................|
	000000D0  AF B0 B1 B2 B3 B4 B5 B6 - B7 B8 B9 BA BB BC BD BE  |................|
	000000E0  BF C0 C1 C2 C3 C4 C5 C6 - C7 C8 C9 CA CB CC CD CE  |................|
	000000F0  CF D0 D1 D2 D3 D4 D5 D6 - D7 D8 D9 DA DB DC DD DE  |................|
	00000100  DF E0 E1 E2 E3 E4 E5 E6 - E7 E8 E9 EA EB EC ED EE  |................|
	00000110  EF F0 F1 F2 F3 F4 F5 F6 - F7 F8 F9 FA FB FC FD FE  |................|
	00000120  FF 00 7A 0A             -                          |..z.|
---
name: integer-base-one-3Wr
description:
	some sample code for hexdumping UCS-2; NUL and binary safe
stdin:
	set -U
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
		print ''	# end of range
		print '\0z'		# embedded NUL
	} | {
		# integer-base-one-3Wr
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z7 hv=2147483647
		dasc=
		if read -arN -1 line; then
			typeset -i1 line
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (hv < 32) || \
				    ((hv > 126) && (hv < 160)) )); then
					dch=.
				elif (( (hv & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${line[i-1]#1#}
				fi
				if (( (pos & 7) == 7 )); then
					dasc=$dasc$dch
					dch=
				elif (( (pos & 7) == 0 )); then
					(( pos )) && print -r -- "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				(( (pos++ & 7) == 3 )) && \
				    print -n -- '- '
				dasc=$dasc$dch
			done
		fi
		while (( pos & 7 )); do
			print -n '     '
			(( (pos++ & 7) == 3 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print -r -- "$dasc|"
	}
expected-stdout:
	00000000  0048 0065 006C 006C - 006F 002C 0020 0057  |Hello, W|
	00000008  006F 0072 006C 0064 - 0021 005C 000A 3053  |orld!\.|
	00000010  3093 306B 3061 306F - FF01 000A 0001 0002  |...|
	00000018  0003 0004 0005 0006 - 0007 0008 0009 000A  |........|
	00000020  000B 000C 000D 000E - 000F 0010 0011 0012  |........|
	00000028  0013 0014 0015 0016 - 0017 0018 0019 001A  |........|
	00000030  001B 001C 001D 001E - 001F 0020 0021 0022  |..... !"|
	00000038  0023 0024 0025 0026 - 0027 0028 0029 002A  |#$%&'()*|
	00000040  002B 002C 002D 002E - 002F 0030 0031 0032  |+,-./012|
	00000048  0033 0034 0035 0036 - 0037 0038 0039 003A  |3456789:|
	00000050  003B 003C 003D 003E - 003F 0040 0041 0042  |;<=>?@@AB|
	00000058  0043 0044 0045 0046 - 0047 0048 0049 004A  |CDEFGHIJ|
	00000060  004B 004C 004D 004E - 004F 0050 0051 0052  |KLMNOPQR|
	00000068  0053 0054 0055 0056 - 0057 0058 0059 005A  |STUVWXYZ|
	00000070  005B 005C 005D 005E - 005F 0060 0061 0062  |[\]^_`ab|
	00000078  0063 0064 0065 0066 - 0067 0068 0069 006A  |cdefghij|
	00000080  006B 006C 006D 006E - 006F 0070 0071 0072  |klmnopqr|
	00000088  0073 0074 0075 0076 - 0077 0078 0079 007A  |stuvwxyz|
	00000090  007B 007C 007D 007E - 007F 0080 0081 0082  |{|}~....|
	00000098  0083 0084 0085 0086 - 0087 0088 0089 008A  |........|
	000000A0  008B 008C 008D 008E - 008F 0090 0091 0092  |........|
	000000A8  0093 0094 0095 0096 - 0097 0098 0099 009A  |........|
	000000B0  009B 009C 009D 009E - 009F 00A0 00A1 00A2  |.....|
	000000B8  00A3 00A4 00A5 00A6 - 00A7 00A8 00A9 00AA  ||
	000000C0  00AB 00AC 00AD 00AE - 00AF 00B0 00B1 00B2  ||
	000000C8  00B3 00B4 00B5 00B6 - 00B7 00B8 00B9 00BA  ||
	000000D0  00BB 00BC 00BD 00BE - 00BF 00C0 00C1 00C2  ||
	000000D8  00C3 00C4 00C5 00C6 - 00C7 00C8 00C9 00CA  ||
	000000E0  00CB 00CC 00CD 00CE - 00CF 00D0 00D1 00D2  ||
	000000E8  00D3 00D4 00D5 00D6 - 00D7 00D8 00D9 00DA  ||
	000000F0  00DB 00DC 00DD 00DE - 00DF 00E0 00E1 00E2  ||
	000000F8  00E3 00E4 00E5 00E6 - 00E7 00E8 00E9 00EA  ||
	00000100  00EB 00EC 00ED 00EE - 00EF 00F0 00F1 00F2  ||
	00000108  00F3 00F4 00F5 00F6 - 00F7 00F8 00F9 00FA  ||
	00000110  00FB 00FC 00FD 00FE - 00FF 000A EFFF 000A  |..|
	00000118  EFC2 000A EFEF EFBF - EFC0 000A EFC0 EF80  |..|
	00000120  000A EFE0 EF80 EF80 - 000A FFFD EFEF EFBF  |..|
	00000128  EFBE EFEF EFBF EFBF - 000A 0000 007A 000A  |..z.|
---
name: integer-base-one-4
description:
	Check if ksh93-style base-one integers work
category: !smksh
stdin:
	set -U
	echo 1 $(('a'))
	(echo 2f $(('aa'))) 2>&1 | sed "s/^[^']*'/2p '/"
	echo 3 $((''))
	x="'a'"
	echo "4 <$x>"
	echo 5 $(($x))
	echo 6 $((x))
expected-stdout:
	1 97
	2p 'aa': multi-character character constant
	3 8230
	4 <'a'>
	5 97
	6 97
---
name: integer-base-one-5A
description:
	Check to see that were NUL and UCS safe
category: !shell:ebcdic-yes
stdin:
	set +U
	print 'a\0b\xfdz' >x
	read -a y <x
	set -U
	typeset -Uui16 y
	print ${y[*]} .
expected-stdout:
	16#61 16#0 16#62 16#FD 16#7A .
---
name: integer-base-one-5E
description:
	Check to see that were NUL and UCS safe
category: !shell:ebcdic-no
stdin:
	set +U
	print 'a\0b\xfdz' >x
	read -a y <x
	set -U
	typeset -Uui16 y
	print ${y[*]} .
expected-stdout:
	16#81 16#0 16#82 16#FD 16#A9 .
---
name: integer-base-one-5W
description:
	Check to see that were NUL and UCS safe
stdin:
	set -U
	print 'a\0bc' >x
	read -a y <x
	set +U
	typeset -Uui16 y
	print ${y[*]} .
expected-stdout:
	16#61 16#0 16#62 16#20AC 16#63 .
---
name: ulimit-1
description:
	Check that ulimit as used in dot.mksh works or is stubbed
stdin:
	ulimit -c 0
---
name: ulimit-2
description:
	Check if we can use a specific syntax idiom for ulimit
	XXX Haiku works, but only for -n and -V
category: !os:haiku,!os:syllable
stdin:
	if ! x=$(ulimit -d) || [[ $x = unknown ]]; then
		#echo expected to fail on this OS
		echo okay
	else
		ulimit -dS $x && echo okay
	fi
expected-stdout:
	okay
---
name: ulimit-3
description:
	Check that there are no duplicate limits (if this fails,
	immediately contact with system information the developers)
stdin:
	[[ -z $(set | grep ^opt) ]]; mis=$?
	set | grep ^opt | sed 's/^/unexpectedly set in environment: /'
	opta='<used for showing all limits>'
	optH='<used to set hard limits>'
	optS='<used to set soft limits>'
	ulimit -a >tmpf
	set -o noglob
	while IFS= read -r line; do
		x=${line:1:1}
		if [[ -z $x || ${#x}/${%x} != 1/1 ]]; then
			print -r -- "weird line: $line"
			(( mis |= 1 ))
			continue
		fi
		set -- $line
		nameref v=opt$x
		if [[ -n $v ]]; then
			print -r -- "duplicate -$x \"$2\" already seen as \"$v\""
			(( mis |= 2 ))
		fi
		v=$2
	done <tmpf
	if (( mis & 2 )); then
		echo failed
	elif (( mis & 1 )); then
		echo inconclusive
	else
		echo done
	fi
expected-stdout:
	done
---
name: redir-1
description:
	Check some of the most basic invariants of I/O redirection
stdin:
	i=0
	function d {
		print o$i.
		print -u2 e$((i++)).
	}
	d >a 2>b
	echo =1=
	cat a
	echo =2=
	cat b
	echo =3=
	d 2>&1 >c
	echo =4=
	cat c
	echo =5=
expected-stdout:
	=1=
	o0.
	=2=
	e0.
	=3=
	e1.
	=4=
	o1.
	=5=
---
name: bashiop-1
description:
	Check if GNU bash-like I/O redirection works
	Part 1: this is also supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-2a
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3&>foo
	echo ===
	cat foo
expected-stdout:
	ras
	===
	dwa
	tri
---
name: bashiop-2b
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3>foo &>&3
	echo ===
	cat foo
expected-stdout:
	===
	ras
	dwa
	tri
---
name: bashiop-2c
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is supported by GNU bash 4 only
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	mir
	ras
	dwa
---
name: bashiop-3a
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 1: this is also supported by GNU bash
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	===
	mir
expected-stderr-pattern: /.*: can't (create|overwrite) .*/
---
name: bashiop-3b
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 2: this is *not* supported by GNU bash
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>|foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-4
description:
	Check if GNU bash-like I/O redirection works
	Part 4: this is also supported by GNU bash,
	but failed in some mksh versions
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	function blubb {
		[[ -e bar ]] && threeout "$bf" &>foo
	}
	blubb
	echo -n >bar
	blubb
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-5
description:
	Check if GNU bash-like I/O redirection is only supported
	in !POSIX !sh mode as it breaks existing scripts' syntax
stdin:
	:>x; echo 1 "$("$__progname" -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 2 "$("$__progname" -o posix -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 3 "$("$__progname" -o sh -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
expected-stdout:
	1  = foo echo bar .
	2  = bar .
	3  = bar .
---
name: oksh-eval
description:
	Check expansions.
stdin:
	a=
	for n in ${a#*=}; do echo 1hu ${n} .; done
	for n in "${a#*=}"; do echo 1hq ${n} .; done
	for n in ${a##*=}; do echo 2hu ${n} .; done
	for n in "${a##*=}"; do echo 2hq ${n} .; done
	for n in ${a%=*}; do echo 1pu ${n} .; done
	for n in "${a%=*}"; do echo 1pq ${n} .; done
	for n in ${a%%=*}; do echo 2pu ${n} .; done
	for n in "${a%%=*}"; do echo 2pq ${n} .; done
expected-stdout:
	1hq .
	2hq .
	1pq .
	2pq .
---
name: oksh-and-list-error-1
description:
	Test exit status of rightmost element in 2 element && list in -e mode
stdin:
	true && false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-and-list-error-2
description:
	Test exit status of rightmost element in 3 element && list in -e mode
stdin:
	true && true && false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-or-list-error-1
description:
	Test exit status of || list in -e mode
stdin:
	false || false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-longline-crash
description:
	This used to cause a core dump
stdin:
	ulimit -c 0
	deplibs="-lz -lpng /usr/local/lib/libjpeg.la -ltiff -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -ltiff -ljpeg -lz -lpng -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk_pixbuf.la -lz -lpng /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -lz -lz /usr/local/lib/libxml.la -lz -lz -lz /usr/local/lib/libxml.la -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lglib -lgmodule /usr/local/lib/libgdk.la /usr/local/lib/libgtk.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade.la -lz -lz -lz /usr/local/lib/libxml.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile /usr/local/lib/libesd.la -lm -lz /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lz /usr/local/lib/libgdk_imlib.la /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lz -lungif -lz -ljpeg -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade-gnome.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib"
	specialdeplibs="-lgnomeui -lart_lgpl -lgdk_imlib -ltiff -ljpeg -lungif -lpng -lz -lSM -lICE -lgtk -lgdk -lgmodule -lintl -lXext -lX11 -lgnome -lgnomesupport -lesd -laudiofile -lm -lglib"
	for deplib in $deplibs; do
		case $deplib in
		-L*)
			new_libs="$deplib $new_libs"
			;;
		*)
			case " $specialdeplibs " in
			*" $deplib "*)
				new_libs="$deplib $new_libs";;
			esac
			;;
		esac
	done
---
name: oksh-seterror-1
description:
	The -e flag should be ignored when executing a compound list
	followed by an if statement.
stdin:
	if true; then false && false; fi
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-2
description:
	The -e flag should be ignored when executing a compound list
	followed by an if statement.
stdin:
	if true; then if true; then false && false; fi; fi
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-3
description:
	The -e flag should be ignored when executing a compound list
	followed by an elif statement.
stdin:
	if true; then :; elif true; then false && false; fi
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-4
description:
	The -e flag should be ignored when executing a pipeline
	beginning with '!'
stdin:
	for i in 1 2 3
	do
		false && false
		true || false
	done
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-5
description:
	The -e flag should be ignored when executing a pipeline
	beginning with '!'
stdin:
	! true | false
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-6
description:
	When trapping ERR and EXIT, both traps should run in -e mode
	when an error occurs.
stdin:
	trap 'echo EXIT' EXIT
	trap 'echo ERR' ERR
	set -e
	false
	echo DONE
	exit 0
arguments: !-e!
expected-exit: e != 0
expected-stdout:
	ERR
	EXIT
---
name: oksh-seterror-7
description:
	The -e flag within a command substitution should be honored
stdin:
	echo $( set -e; false; echo foo )
arguments: !-e!
expected-stdout:
	
---
name: oksh-input-comsub
description:
	A command substitution using input redirection should exit with
	failure if the input file does not exist.
stdin:
	var=$(< non-existent)
expected-exit: e != 0
expected-stderr-pattern: /non-existent/
---
name: oksh-empty-for-list
description:
	A for list which expands to zero items should not execute the body.
stdin:
	set foo bar baz ; for out in ; do echo $out ; done
---
name: oksh-varfunction-mod1
description:
	(Inspired by PR 2450 on OpenBSD.) Calling
		FOO=bar f
	where f is a ksh style function, should not set FOO in the current
	env. If f is a Bourne style function, (new) also not. Furthermore,
	the function should receive a correct value of FOO. However, differing
	from oksh, setting FOO in the function itself must change the value in
	setting FOO in the function itself should not change the value in
	global environment.
stdin:
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.$PATHSEP$PATH
	function k {
		if [ x$FOO != xbar ]; then
			echo 1
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 2
			return 1;
		fi
		FOO=foo
		return 0
	}
	b () {
		if [ x$FOO != xbar ]; then
			echo 3
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 4
			return 1;
		fi
		FOO=foo
		return 0
	}
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != x ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != x ]; then
		exit 1
	fi
	FOO=barbar
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbarbar ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbarbar ]; then
		exit 1
	fi
---
name: fd-cloexec-1
description:
	Verify that file descriptors > 2 are private for Korn shells
	AT&T ksh93 does this still, which means we must keep it as well
	XXX fails on some old Perl installations
need-pass: no
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
expected-exit: e != 0
expected-stderr-pattern:
	/E: open /
---
name: fd-cloexec-2
description:
	Verify that file descriptors > 2 are not private for POSIX shells
	See Debian Bug #154540, Closes: #499139
	XXX fails on some old Perl installations
need-pass: no
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	test -n "$POSH_VERSION" || set -o posix
	exec 9>&1
	./cld
expected-stdout:
	Fowl
---
name: fd-cloexec-3
description:
	Another check for close-on-exec
stdin:
	print '#!'"$__progname" >ts
	cat >>ts <<'EOF'
	s=ERR
	read -rN-1 -u$1 s 2>/dev/null; e=$?
	print -r -- "($1, $((!e)), $s)"
	EOF
	chmod +x ts
	print foo >tx
	runtest() {
		s=$1; shift
		print -r -- $("$__progname" "$@@" -c "$s") "$@@" .
	}
	runtest 'exec 3<tx; ./ts 3 3<&3; ./ts 3'
	runtest 'exec 3<tx; ./ts 3 3<&3; ./ts 3' -o posix
	runtest 'exec 3<tx; ./ts 3 3<&3; ./ts 3' -o sh
	runtest 'exec 3<tx; ./ts 4 4<&3; ./ts 4 4<&3'
	runtest 'exec 3<tx; ./ts 3 3<&3; ./ts 3 3<&3'
expected-stdout:
	(3, 1, foo) (3, 0, ERR) .
	(3, 1, foo) (3, 1, ) -o posix .
	(3, 1, foo) (3, 1, ) -o sh .
	(4, 1, foo) (4, 1, ) .
	(3, 1, foo) (3, 1, ) .
---
name: comsub-1a
description:
	COMSUB are now parsed recursively, so this works
	see also regression-6: matching parenthess bug
	Fails on: pdksh bash2 bash3 zsh
	Passes on: bash4 ksh93 mksh(20110313+)
stdin:
	echo 1 $(case 1 in (1) echo yes;; (2) echo no;; esac) .
	echo 2 $(case 1 in 1) echo yes;; 2) echo no;; esac) .
	TEST=1234; echo 3 ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)} .
	TEST=5678; echo 4 ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)} .
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo 5 ${a[0]} .
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo 6 ${a[0]} .
expected-stdout:
	1 yes .
	2 yes .
	3 234 .
	4 678 .
	5 1 .
	6 1 .
---
name: comsub-1b
description:
	COMSUB are now parsed recursively, so this works
	Fails on: pdksh bash2 bash3 bash4 zsh
	Passes on: ksh93 mksh(20110313+)
stdin:
	echo 1 $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10)) .
	echo 2 $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20)) .
	(( a = $(case 1 in (1) echo 1;; (*) echo 2;; esac) )); echo 3 $a .
	(( a = $(case 1 in 1) echo 1;; *) echo 2;; esac) )); echo 4 $a .
	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo 5 ${a[0]} .
	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo 6 ${a[0]} .
expected-stdout:
	1 11 .
	2 21 .
	3 1 .
	4 1 .
	5 11 .
	6 21 .
---
name: comsub-2
description:
	RedHat BZ#496791  another case of missing recursion
	in parsing COMSUB expressions
	Fails on: pdksh bash2 bash3 bash4 zsh
	Passes on: ksh93 mksh(20110305+)
	 bash[34] seem to choke on comment ending with backslash-newline
stdin:
	# a comment with " ' \
	x=$(
	echo yes
	# a comment with " ' \
	)
	echo $x
expected-stdout:
	yes
---
name: comsub-3
description:
	Extended test for COMSUB explaining why a recursive parser
	is a must (a non-recursive parser cannot pass all three of
	these test cases, especially the # is difficult)
stdin:
	print '#!'"$__progname"'\necho 1234' >id; chmod +x id; PATH=.$PATHSEP$PATH
	echo $(typeset -i10 x=16#20; echo $x)
	echo $(typeset -Uui16 x=16#$(id -u)
	) .
	echo $(c=1; d=1
	typeset -Uui16 a=36#foo; c=2
	typeset -Uui16 b=36 #foo; d=2
	echo $a $b $c $d)
expected-stdout:
	32
	.
	16#4F68 16#24 2 1
---
name: comsub-4
description:
	Check the tree dump functions for !MKSH_SMALL functionality
category: !smksh
stdin:
	x() { case $1 in u) echo x ;;& *) echo $1 ;; esac; }
	typeset -f x
expected-stdout:
	x() {
		case $1 in
		(u)
			\echo x 
			;|
		(*)
			\echo $1 
			;;
		esac 
	} 
---
name: comsub-5
description:
	Check COMSUB works with aliases (does not expand them twice)
	and reentrancy safety
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
	alias echo='echo a'
	foo() {
		echo moo
		./pfn "$(echo foo)"
	}
	./pfn "$(echo b)"
	typeset -f foo >x
	cat x
	foo
	. ./x
	typeset -f foo
	foo
expected-stdout:
	a b
	foo() {
		\echo a moo 
		./pfn "$(\echo a foo )" 
	} 
	a moo
	a foo
	foo() {
		\echo a moo 
		./pfn "$(\echo a foo )" 
	} 
	a moo
	a foo
---
name: comsub-torture
description:
	Check the tree dump functions work correctly
stdin:
	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
	while IFS= read -r line; do
		if [[ $line = '#1' ]]; then
			lastf=0
			continue
		elif [[ $line = EOFN* ]]; then
			fbody=$fbody$'\n'$line
			continue
		elif [[ $line != '#'* ]]; then
			fbody=$fbody$'\n\t'$line
			continue
		fi
		if (( lastf )); then
			x="inline_${nextf}() {"$fbody$'\n}\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
		fi
		lastf=1
		fbody=
		nextf=${line#?}
	done <<'EOD'
	#1
	#TCOM
	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	#TPAREN_TPIPE_TLIST
	(echo $foo  |  tr -dc 0-9; echo)
	#TAND_TOR
	cmd  &&  echo ja  ||  echo nein
	#TSELECT
	select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	#TFOR_TTIME
	time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	#TCASE
	case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	#TIF_TBANG_TDBRACKET_TELIF
	if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	#TWHILE
	i=1; while (( i < 10 )); do echo $i; let ++i; done
	#TUNTIL
	i=10; until  (( !--i )) ; do echo $i; done
	#TCOPROC
	cat  *  |&  ls
	#TFUNCT_TBRACE_TASYNC
	function  korn  {  echo eins; echo zwei ;  }
	bourne  ()  {  logger *  &  }
	#IOREAD_IOCAT
	tr  x  u  0<foo  >>bar
	#IOWRITE_IOCLOB_IOHERE_noIOSKIP
	cat  >|bar  <<'EOFN'
	foo
	EOFN
	#IOWRITE_noIOCLOB_IOHERE_IOSKIP
	cat  1>bar  <<-EOFI
	foo
	EOFI
	#IORDWR_IODUP
	sh  1<>/dev/console  0<&1  2>&1
	#COMSUB_EXPRSUB_FUNSUB_VALSUB
	echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	#QCHAR_OQUOTE_CQUOTE
	echo fo\ob\"a\`r\'b\$az
	echo "fo\ob\"a\`r\'b\$az"
	echo 'fo\ob\"a\`r'\''b\$az'
	#OSUBST_CSUBST_OPAT_SPAT_CPAT
	[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	#heredoc_closed
	x=$(cat <<EOFN
	note there must be no space between EOFN and )
	EOFN); echo $x
	#heredoc_space
	x=$(cat <<EOFN\ 
	note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	#patch_motd
	x=$(sysctl -n kern.version | sed 1q)
	[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
	    ed -s /etc/motd 2>&1 <<-EOF
		1,/^\$/d
		0a
			$x
	
		.
		wq
	EOF)" = @@(?) ]] && rm -f /etc/motd
	if [[ ! -s /etc/motd ]]; then
		install -c -o root -g wheel -m 664 /dev/null /etc/motd
		print -- "$x\n" >/etc/motd
	fi
	#wdarrassign
	case x in
	x) a+=b; c+=(d e)
	esac
	#0
	EOD
expected-stdout:
	inline_TCOM() {
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	}
	inline_TCOM() {
		vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" 
	} 
	function comsub_TCOM { x=$(
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	); }
	function comsub_TCOM {
		x=$(vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" ) 
	} 
	function reread_TCOM { x=$((
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	)|tr u x); }
	function reread_TCOM {
		x=$( ( vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" ) | \tr u x ) 
	} 
	inline_TPAREN_TPIPE_TLIST() {
		(echo $foo  |  tr -dc 0-9; echo)
	}
	inline_TPAREN_TPIPE_TLIST() {
		( \echo $foo | \tr -dc 0-9 
		  \echo ) 
	} 
	function comsub_TPAREN_TPIPE_TLIST { x=$(
		(echo $foo  |  tr -dc 0-9; echo)
	); }
	function comsub_TPAREN_TPIPE_TLIST {
		x=$( ( \echo $foo | \tr -dc 0-9 ; \echo ) ) 
	} 
	function reread_TPAREN_TPIPE_TLIST { x=$((
		(echo $foo  |  tr -dc 0-9; echo)
	)|tr u x); }
	function reread_TPAREN_TPIPE_TLIST {
		x=$( ( ( \echo $foo | \tr -dc 0-9 ; \echo ) ) | \tr u x ) 
	} 
	inline_TAND_TOR() {
		cmd  &&  echo ja  ||  echo nein
	}
	inline_TAND_TOR() {
		\cmd && \echo ja || \echo nein 
	} 
	function comsub_TAND_TOR { x=$(
		cmd  &&  echo ja  ||  echo nein
	); }
	function comsub_TAND_TOR {
		x=$(\cmd && \echo ja || \echo nein ) 
	} 
	function reread_TAND_TOR { x=$((
		cmd  &&  echo ja  ||  echo nein
	)|tr u x); }
	function reread_TAND_TOR {
		x=$( ( \cmd && \echo ja || \echo nein ) | \tr u x ) 
	} 
	inline_TSELECT() {
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	}
	inline_TSELECT() {
		select file in * 
		do
			\echo "<$file>" 
			\break 
		done 
	} 
	function comsub_TSELECT { x=$(
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	); }
	function comsub_TSELECT {
		x=$(select file in * ; do \echo "<$file>" ; \break ; done ) 
	} 
	function reread_TSELECT { x=$((
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	)|tr u x); }
	function reread_TSELECT {
		x=$( ( select file in * ; do \echo "<$file>" ; \break ; done ) | \tr u x ) 
	} 
	inline_TFOR_TTIME() {
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	}
	inline_TFOR_TTIME() {
		time for i in {1,2,3} 
		do
			\echo $i 
		done 
	} 
	function comsub_TFOR_TTIME { x=$(
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	); }
	function comsub_TFOR_TTIME {
		x=$(time for i in {1,2,3} ; do \echo $i ; done ) 
	} 
	function reread_TFOR_TTIME { x=$((
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	)|tr u x); }
	function reread_TFOR_TTIME {
		x=$( ( time for i in {1,2,3} ; do \echo $i ; done ) | \tr u x ) 
	} 
	inline_TCASE() {
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	}
	inline_TCASE() {
		case $foo in
		(1)
			\echo eins 
			;&
		(2)
			\echo zwei 
			;|
		(*)
			\echo kann net bis drei zhlen 
			;;
		esac 
	} 
	function comsub_TCASE { x=$(
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	); }
	function comsub_TCASE {
		x=$(case $foo in (1) \echo eins  ;& (2) \echo zwei  ;| (*) \echo kann net bis drei zhlen  ;; esac ) 
	} 
	function reread_TCASE { x=$((
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	)|tr u x); }
	function reread_TCASE {
		x=$( ( case $foo in (1) \echo eins  ;& (2) \echo zwei  ;| (*) \echo kann net bis drei zhlen  ;; esac ) | \tr u x ) 
	} 
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	}
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if ! [[ 1 = 1 ]] 
		then
			\echo eins 
		elif [[ 1 = 2 ]] 
		then
			\echo zwei 
		else
			\echo drei 
		fi 
	} 
	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	); }
	function comsub_TIF_TBANG_TDBRACKET_TELIF {
		x=$(if ! [[ 1 = 1 ]] ; then \echo eins ; elif [[ 1 = 2 ]] ; then \echo zwei ; else \echo drei ; fi ) 
	} 
	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	)|tr u x); }
	function reread_TIF_TBANG_TDBRACKET_TELIF {
		x=$( ( if ! [[ 1 = 1 ]] ; then \echo eins ; elif [[ 1 = 2 ]] ; then \echo zwei ; else \echo drei ; fi ) | \tr u x ) 
	} 
	inline_TWHILE() {
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	}
	inline_TWHILE() {
		i=1 
		while {
			      \\builtin let " i < 10 " 
		      } 
		do
			\echo $i 
			\let ++i 
		done 
	} 
	function comsub_TWHILE { x=$(
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	); }
	function comsub_TWHILE {
		x=$(i=1 ; while { \\builtin let " i < 10 " ; } ; do \echo $i ; \let ++i ; done ) 
	} 
	function reread_TWHILE { x=$((
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	)|tr u x); }
	function reread_TWHILE {
		x=$( ( i=1 ; while { \\builtin let " i < 10 " ; } ; do \echo $i ; \let ++i ; done ) | \tr u x ) 
	} 
	inline_TUNTIL() {
		i=10; until  (( !--i )) ; do echo $i; done
	}
	inline_TUNTIL() {
		i=10 
		until {
			      \\builtin let " !--i " 
		      } 
		do
			\echo $i 
		done 
	} 
	function comsub_TUNTIL { x=$(
		i=10; until  (( !--i )) ; do echo $i; done
	); }
	function comsub_TUNTIL {
		x=$(i=10 ; until { \\builtin let " !--i " ; } ; do \echo $i ; done ) 
	} 
	function reread_TUNTIL { x=$((
		i=10; until  (( !--i )) ; do echo $i; done
	)|tr u x); }
	function reread_TUNTIL {
		x=$( ( i=10 ; until { \\builtin let " !--i " ; } ; do \echo $i ; done ) | \tr u x ) 
	} 
	inline_TCOPROC() {
		cat  *  |&  ls
	}
	inline_TCOPROC() {
		\cat * |& 
		\ls 
	} 
	function comsub_TCOPROC { x=$(
		cat  *  |&  ls
	); }
	function comsub_TCOPROC {
		x=$(\cat * |&  \ls ) 
	} 
	function reread_TCOPROC { x=$((
		cat  *  |&  ls
	)|tr u x); }
	function reread_TCOPROC {
		x=$( ( \cat * |&  \ls ) | \tr u x ) 
	} 
	inline_TFUNCT_TBRACE_TASYNC() {
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	}
	inline_TFUNCT_TBRACE_TASYNC() {
		function korn {
			\echo eins 
			\echo zwei 
		} 
		bourne() {
			\logger * & 
		} 
	} 
	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	); }
	function comsub_TFUNCT_TBRACE_TASYNC {
		x=$(function korn { \echo eins ; \echo zwei ; } ; bourne() { \logger * &  } ) 
	} 
	function reread_TFUNCT_TBRACE_TASYNC { x=$((
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	)|tr u x); }
	function reread_TFUNCT_TBRACE_TASYNC {
		x=$( ( function korn { \echo eins ; \echo zwei ; } ; bourne() { \logger * &  } ) | \tr u x ) 
	} 
	inline_IOREAD_IOCAT() {
		tr  x  u  0<foo  >>bar
	}
	inline_IOREAD_IOCAT() {
		\tr x u <foo >>bar 
	} 
	function comsub_IOREAD_IOCAT { x=$(
		tr  x  u  0<foo  >>bar
	); }
	function comsub_IOREAD_IOCAT {
		x=$(\tr x u <foo >>bar ) 
	} 
	function reread_IOREAD_IOCAT { x=$((
		tr  x  u  0<foo  >>bar
	)|tr u x); }
	function reread_IOREAD_IOCAT {
		x=$( ( \tr x u <foo >>bar ) | \tr u x ) 
	} 
	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	}
	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
		\cat >|bar <<"EOFN" 
		foo
	EOFN
	
	} 
	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$(
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	); }
	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
		x=$(\cat >|bar <<"EOFN" 
		foo
	EOFN
	) 
	} 
	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$((
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	)|tr u x); }
	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
		x=$( ( \cat >|bar <<"EOFN" 
		foo
	EOFN
	) | \tr u x ) 
	} 
	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
		cat  1>bar  <<-EOFI
		foo
		EOFI
	}
	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
		\cat >bar <<-EOFI 
	foo
	EOFI
	
	} 
	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$(
		cat  1>bar  <<-EOFI
		foo
		EOFI
	); }
	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
		x=$(\cat >bar <<-EOFI 
	foo
	EOFI
	) 
	} 
	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$((
		cat  1>bar  <<-EOFI
		foo
		EOFI
	)|tr u x); }
	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
		x=$( ( \cat >bar <<-EOFI 
	foo
	EOFI
	) | \tr u x ) 
	} 
	inline_IORDWR_IODUP() {
		sh  1<>/dev/console  0<&1  2>&1
	}
	inline_IORDWR_IODUP() {
		\sh 1<>/dev/console <&1 2>&1 
	} 
	function comsub_IORDWR_IODUP { x=$(
		sh  1<>/dev/console  0<&1  2>&1
	); }
	function comsub_IORDWR_IODUP {
		x=$(\sh 1<>/dev/console <&1 2>&1 ) 
	} 
	function reread_IORDWR_IODUP { x=$((
		sh  1<>/dev/console  0<&1  2>&1
	)|tr u x); }
	function reread_IORDWR_IODUP {
		x=$( ( \sh 1<>/dev/console <&1 2>&1 ) | \tr u x ) 
	} 
	inline_COMSUB_EXPRSUB_FUNSUB_VALSUB() {
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	}
	inline_COMSUB_EXPRSUB_FUNSUB_VALSUB() {
		\echo $(\true ) $((1+ 2)) ${ \: ;} ${|REPLY=x ;} 
	} 
	function comsub_COMSUB_EXPRSUB_FUNSUB_VALSUB { x=$(
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	); }
	function comsub_COMSUB_EXPRSUB_FUNSUB_VALSUB {
		x=$(\echo $(\true ) $((1+ 2)) ${ \: ;} ${|REPLY=x ;} ) 
	} 
	function reread_COMSUB_EXPRSUB_FUNSUB_VALSUB { x=$((
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	)|tr u x); }
	function reread_COMSUB_EXPRSUB_FUNSUB_VALSUB {
		x=$( ( \echo $(\true ) $((1+ 2)) ${ \: ;} ${|REPLY=x ;} ) | \tr u x ) 
	} 
	inline_QCHAR_OQUOTE_CQUOTE() {
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	}
	inline_QCHAR_OQUOTE_CQUOTE() {
		\echo fo\ob\"a\`r\'b\$az 
		\echo "fo\ob\"a\`r\'b\$az" 
		\echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" 
	} 
	function comsub_QCHAR_OQUOTE_CQUOTE { x=$(
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	); }
	function comsub_QCHAR_OQUOTE_CQUOTE {
		x=$(\echo fo\ob\"a\`r\'b\$az ; \echo "fo\ob\"a\`r\'b\$az" ; \echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) 
	} 
	function reread_QCHAR_OQUOTE_CQUOTE { x=$((
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	)|tr u x); }
	function reread_QCHAR_OQUOTE_CQUOTE {
		x=$( ( \echo fo\ob\"a\`r\'b\$az ; \echo "fo\ob\"a\`r\'b\$az" ; \echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) | \tr u x ) 
	} 
	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	}
	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]] 
	} 
	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$(
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	); }
	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT {
		x=$([[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) 
	} 
	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$((
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	)|tr u x); }
	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT {
		x=$( ( [[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) | \tr u x ) 
	} 
	inline_heredoc_closed() {
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	}
	inline_heredoc_closed() {
		x=$(\cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) 
		\echo $x 
	} 
	function comsub_heredoc_closed { x=$(
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	); }
	function comsub_heredoc_closed {
		x=$(x=$(\cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) ; \echo $x ) 
	} 
	function reread_heredoc_closed { x=$((
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	)|tr u x); }
	function reread_heredoc_closed {
		x=$( ( x=$(\cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) ; \echo $x ) | \tr u x ) 
	} 
	inline_heredoc_space() {
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	}
	inline_heredoc_space() {
		x=$(\cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) 
		\echo $x 
	} 
	function comsub_heredoc_space { x=$(
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	); }
	function comsub_heredoc_space {
		x=$(x=$(\cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) ; \echo $x ) 
	} 
	function reread_heredoc_space { x=$((
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	)|tr u x); }
	function reread_heredoc_space {
		x=$( ( x=$(\cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) ; \echo $x ) | \tr u x ) 
	} 
	inline_patch_motd() {
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	}
	inline_patch_motd() {
		x=$(\sysctl -n kern.version | \sed 1q ) 
		[[ -s /etc/motd && "$([[ "$(\head -1 /etc/motd )" != $x ]] && \ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && \rm -f /etc/motd 
		if [[ ! -s /etc/motd ]] 
		then
			\install -c -o root -g wheel -m 664 /dev/null /etc/motd 
			\print -- "$x\n" >/etc/motd 
		fi 
	} 
	function comsub_patch_motd { x=$(
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	); }
	function comsub_patch_motd {
		x=$(x=$(\sysctl -n kern.version | \sed 1q ) ; [[ -s /etc/motd && "$([[ "$(\head -1 /etc/motd )" != $x ]] && \ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && \rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then \install -c -o root -g wheel -m 664 /dev/null /etc/motd ; \print -- "$x\n" >/etc/motd ; fi ) 
	} 
	function reread_patch_motd { x=$((
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	)|tr u x); }
	function reread_patch_motd {
		x=$( ( x=$(\sysctl -n kern.version | \sed 1q ) ; [[ -s /etc/motd && "$([[ "$(\head -1 /etc/motd )" != $x ]] && \ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && \rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then \install -c -o root -g wheel -m 664 /dev/null /etc/motd ; \print -- "$x\n" >/etc/motd ; fi ) | \tr u x ) 
	} 
	inline_wdarrassign() {
		case x in
		x) a+=b; c+=(d e)
		esac
	}
	inline_wdarrassign() {
		case x in
		(x)
			a+=b 
			\\builtin set -A c+ -- d e 
			;;
		esac 
	} 
	function comsub_wdarrassign { x=$(
		case x in
		x) a+=b; c+=(d e)
		esac
	); }
	function comsub_wdarrassign {
		x=$(case x in (x) a+=b ; \\builtin set -A c+ -- d e  ;; esac ) 
	} 
	function reread_wdarrassign { x=$((
		case x in
		x) a+=b; c+=(d e)
		esac
	)|tr u x); }
	function reread_wdarrassign {
		x=$( ( case x in (x) a+=b ; \\builtin set -A c+ -- d e  ;; esac ) | \tr u x ) 
	} 
---
name: comsub-torture-io
description:
	Check the tree dump functions work correctly with I/O redirection
stdin:
	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
	while IFS= read -r line; do
		if [[ $line = '#1' ]]; then
			lastf=0
			continue
		elif [[ $line = EOFN* ]]; then
			fbody=$fbody$'\n'$line
			continue
		elif [[ $line != '#'* ]]; then
			fbody=$fbody$'\n\t'$line
			continue
		fi
		if (( lastf )); then
			x="inline_${nextf}() {"$fbody$'\n}\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
		fi
		lastf=1
		fbody=
		nextf=${line#?}
	done <<'EOD'
	#1
	#TCOM
	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	#TPAREN_TPIPE_TLIST
	(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	#TAND_TOR
	cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	#TSELECT
	select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	#TFOR_TTIME
	for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	#TCASE
	case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	#TIF_TBANG_TDBRACKET_TELIF
	if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	#TWHILE
	i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	#TUNTIL
	i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	#TCOPROC
	cat  *  >&3 |&  >&3 ls
	#TFUNCT_TBRACE_TASYNC
	function  korn  {  echo eins; echo >&3 zwei ;  }
	bourne  ()  {  logger *  >&3 &  }
	#COMSUB_EXPRSUB
	echo $(true >&3) $((1+ 2))
	#0
	EOD
expected-stdout:
	inline_TCOM() {
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	}
	inline_TCOM() {
		vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" >&3 
	} 
	function comsub_TCOM { x=$(
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	); }
	function comsub_TCOM {
		x=$(vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" >&3 ) 
	} 
	function reread_TCOM { x=$((
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	)|tr u x); }
	function reread_TCOM {
		x=$( ( vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" >&3 ) | \tr u x ) 
	} 
	inline_TPAREN_TPIPE_TLIST() {
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	}
	inline_TPAREN_TPIPE_TLIST() {
		( \echo $foo | \tr -dc 0-9 >&3 
		  \echo >&3 ) >&3 
	} 
	function comsub_TPAREN_TPIPE_TLIST { x=$(
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	); }
	function comsub_TPAREN_TPIPE_TLIST {
		x=$( ( \echo $foo | \tr -dc 0-9 >&3 ; \echo >&3 ) >&3 ) 
	} 
	function reread_TPAREN_TPIPE_TLIST { x=$((
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	)|tr u x); }
	function reread_TPAREN_TPIPE_TLIST {
		x=$( ( ( \echo $foo | \tr -dc 0-9 >&3 ; \echo >&3 ) >&3 ) | \tr u x ) 
	} 
	inline_TAND_TOR() {
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	}
	inline_TAND_TOR() {
		\cmd >&3 && \echo ja >&3 || \echo nein >&3 
	} 
	function comsub_TAND_TOR { x=$(
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	); }
	function comsub_TAND_TOR {
		x=$(\cmd >&3 && \echo ja >&3 || \echo nein >&3 ) 
	} 
	function reread_TAND_TOR { x=$((
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	)|tr u x); }
	function reread_TAND_TOR {
		x=$( ( \cmd >&3 && \echo ja >&3 || \echo nein >&3 ) | \tr u x ) 
	} 
	inline_TSELECT() {
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	}
	inline_TSELECT() {
		select file in * 
		do
			\echo "<$file>" 
			\break >&3 
		done >&3 
	} 
	function comsub_TSELECT { x=$(
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	); }
	function comsub_TSELECT {
		x=$(select file in * ; do \echo "<$file>" ; \break >&3 ; done >&3 ) 
	} 
	function reread_TSELECT { x=$((
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	)|tr u x); }
	function reread_TSELECT {
		x=$( ( select file in * ; do \echo "<$file>" ; \break >&3 ; done >&3 ) | \tr u x ) 
	} 
	inline_TFOR_TTIME() {
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	}
	inline_TFOR_TTIME() {
		for i in {1,2,3} 
		do
			time \echo $i >&3 
		done >&3 
	} 
	function comsub_TFOR_TTIME { x=$(
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	); }
	function comsub_TFOR_TTIME {
		x=$(for i in {1,2,3} ; do time \echo $i >&3 ; done >&3 ) 
	} 
	function reread_TFOR_TTIME { x=$((
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	)|tr u x); }
	function reread_TFOR_TTIME {
		x=$( ( for i in {1,2,3} ; do time \echo $i >&3 ; done >&3 ) | \tr u x ) 
	} 
	inline_TCASE() {
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	}
	inline_TCASE() {
		case $foo in
		(1)
			\echo eins >&3 
			;&
		(2)
			\echo zwei >&3 
			;|
		(*)
			\echo kann net bis drei zhlen >&3 
			;;
		esac >&3 
	} 
	function comsub_TCASE { x=$(
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	); }
	function comsub_TCASE {
		x=$(case $foo in (1) \echo eins >&3  ;& (2) \echo zwei >&3  ;| (*) \echo kann net bis drei zhlen >&3  ;; esac >&3 ) 
	} 
	function reread_TCASE { x=$((
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	)|tr u x); }
	function reread_TCASE {
		x=$( ( case $foo in (1) \echo eins >&3  ;& (2) \echo zwei >&3  ;| (*) \echo kann net bis drei zhlen >&3  ;; esac >&3 ) | \tr u x ) 
	} 
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	}
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if ! [[ 1 = 1 ]] >&3 
		then
			\echo eins 
		elif [[ 1 = 2 ]] >&3 
		then
			\echo zwei 
		else
			\echo drei 
		fi >&3 
	} 
	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	); }
	function comsub_TIF_TBANG_TDBRACKET_TELIF {
		x=$(if ! [[ 1 = 1 ]] >&3 ; then \echo eins ; elif [[ 1 = 2 ]] >&3 ; then \echo zwei ; else \echo drei ; fi >&3 ) 
	} 
	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	)|tr u x); }
	function reread_TIF_TBANG_TDBRACKET_TELIF {
		x=$( ( if ! [[ 1 = 1 ]] >&3 ; then \echo eins ; elif [[ 1 = 2 ]] >&3 ; then \echo zwei ; else \echo drei ; fi >&3 ) | \tr u x ) 
	} 
	inline_TWHILE() {
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	}
	inline_TWHILE() {
		i=1 
		while {
			      \\builtin let " i < 10 " 
		      } >&3 
		do
			\echo $i 
			\let ++i 
		done >&3 
	} 
	function comsub_TWHILE { x=$(
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	); }
	function comsub_TWHILE {
		x=$(i=1 ; while { \\builtin let " i < 10 " ; } >&3 ; do \echo $i ; \let ++i ; done >&3 ) 
	} 
	function reread_TWHILE { x=$((
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	)|tr u x); }
	function reread_TWHILE {
		x=$( ( i=1 ; while { \\builtin let " i < 10 " ; } >&3 ; do \echo $i ; \let ++i ; done >&3 ) | \tr u x ) 
	} 
	inline_TUNTIL() {
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	}
	inline_TUNTIL() {
		i=10 
		until {
			      \\builtin let " !--i " 
		      } >&3 
		do
			\echo $i 
		done >&3 
	} 
	function comsub_TUNTIL { x=$(
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	); }
	function comsub_TUNTIL {
		x=$(i=10 ; until { \\builtin let " !--i " ; } >&3 ; do \echo $i ; done >&3 ) 
	} 
	function reread_TUNTIL { x=$((
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	)|tr u x); }
	function reread_TUNTIL {
		x=$( ( i=10 ; until { \\builtin let " !--i " ; } >&3 ; do \echo $i ; done >&3 ) | \tr u x ) 
	} 
	inline_TCOPROC() {
		cat  *  >&3 |&  >&3 ls
	}
	inline_TCOPROC() {
		\cat * >&3 |& 
		\ls >&3 
	} 
	function comsub_TCOPROC { x=$(
		cat  *  >&3 |&  >&3 ls
	); }
	function comsub_TCOPROC {
		x=$(\cat * >&3 |&  \ls >&3 ) 
	} 
	function reread_TCOPROC { x=$((
		cat  *  >&3 |&  >&3 ls
	)|tr u x); }
	function reread_TCOPROC {
		x=$( ( \cat * >&3 |&  \ls >&3 ) | \tr u x ) 
	} 
	inline_TFUNCT_TBRACE_TASYNC() {
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	}
	inline_TFUNCT_TBRACE_TASYNC() {
		function korn {
			\echo eins 
			\echo zwei >&3 
		} 
		bourne() {
			\logger * >&3 & 
		} 
	} 
	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	); }
	function comsub_TFUNCT_TBRACE_TASYNC {
		x=$(function korn { \echo eins ; \echo zwei >&3 ; } ; bourne() { \logger * >&3 &  } ) 
	} 
	function reread_TFUNCT_TBRACE_TASYNC { x=$((
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	)|tr u x); }
	function reread_TFUNCT_TBRACE_TASYNC {
		x=$( ( function korn { \echo eins ; \echo zwei >&3 ; } ; bourne() { \logger * >&3 &  } ) | \tr u x ) 
	} 
	inline_COMSUB_EXPRSUB() {
		echo $(true >&3) $((1+ 2))
	}
	inline_COMSUB_EXPRSUB() {
		\echo $(\true >&3 ) $((1+ 2)) 
	} 
	function comsub_COMSUB_EXPRSUB { x=$(
		echo $(true >&3) $((1+ 2))
	); }
	function comsub_COMSUB_EXPRSUB {
		x=$(\echo $(\true >&3 ) $((1+ 2)) ) 
	} 
	function reread_COMSUB_EXPRSUB { x=$((
		echo $(true >&3) $((1+ 2))
	)|tr u x); }
	function reread_COMSUB_EXPRSUB {
		x=$( ( \echo $(\true >&3 ) $((1+ 2)) ) | \tr u x ) 
	} 
---
name: funsub-1
description:
	Check that non-subenvironment command substitution works
stdin:
	set -e
	foo=bar
	echo "ob $foo ."
	echo "${
		echo "ib $foo :"
		foo=baz
		echo "ia $foo :"
		false
	}" .
	echo "oa $foo ."
expected-stdout:
	ob bar .
	ib bar :
	ia baz : .
	oa baz .
---
name: funsub-2
description:
	You can now reliably use local and return in funsubs
	(not exit though)
stdin:
	x=q; e=1; x=${ echo a; e=2; echo x$e;}; echo 1:y$x,$e,$?.
	x=q; e=1; x=${ echo a; typeset e=2; echo x$e;}; echo 2:y$x,$e,$?.
	x=q; e=1; x=${ echo a; typeset e=2; return 3; echo x$e;}; echo 3:y$x,$e,$?.
expected-stdout:
	1:ya x2,2,0.
	2:ya x2,1,0.
	3:ya,1,3.
---
name: valsub-1
description:
	Check that "value substitutions" work as advertised
stdin:
	x=1
	y=2
	z=3
	REPLY=4
	echo "before:	x<$x> y<$y> z<$z> R<$REPLY>"
	x=${|
		local y
		echo "start:	x<$x> y<$y> z<$z> R<$REPLY>"
		x=5
		y=6
		z=7
		REPLY=8
		echo "end:	x<$x> y<$y> z<$z> R<$REPLY>"
	}
	echo "after:	x<$x> y<$y> z<$z> R<$REPLY>"
	# ensure trailing newlines are kept
	t=${|REPLY=$'foo\n\n';}
	typeset -p t
	echo -n this used to segfault
	echo ${|true;}$(true).
expected-stdout:
	before:	x<1> y<2> z<3> R<4>
	start:	x<1> y<> z<3> R<>
	end:	x<5> y<6> z<7> R<8>
	after:	x<8> y<2> z<7> R<4>
	typeset t=$'foo\n\n'
	this used to segfault.
---
name: event-subst-3
description:
	Check that '!' substitution in noninteractive mode is ignored
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
stdin:
	export PATH=.$PATHSEP$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	si
	meow
	= 0
	foo
---
name: event-subst-0
description:
	Check that '!' substitution in interactive mode is ignored
need-ctty: yes
arguments: !-i!
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
stdin:
	export PATH=.$PATHSEP$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	si
	meow
	= 0
	foo
expected-stderr-pattern:
	/.*/
---
name: nounset-1
description:
	Check that "set -u" matches (future) SUSv4 requirement
stdin:
	(set -u
	try() {
		local v
		eval v=\$$1
		if [[ -n $v ]]; then
			echo $1=nz
		else
			echo $1=zf
		fi
	}
	x=y
	(echo $x)
	echo =1
	(echo $y)
	echo =2
	(try x)
	echo =3
	(try y)
	echo =4
	(try 0)
	echo =5
	(try 2)
	echo =6
	(try)
	echo =7
	(echo at=$@@)
	echo =8
	(echo asterisk=$*)
	echo =9
	(echo $?)
	echo =10
	(echo $!)
	echo =11
	(echo $-)
	echo =12
	#(echo $_)
	#echo =13
	(echo $#)
	echo =14
	(mypid=$$; try mypid)
	echo =15
	) 2>&1 | sed -e 's/^[A-Za-z]://' -e 's/^[^]]*]//' -e 's/^[^:]*: *//'
	exit ${PIPESTATUS[0]}
expected-stdout:
	y
	=1
	y: parameter not set
	=2
	x=nz
	=3
	y: parameter not set
	=4
	0=nz
	=5
	2: parameter not set
	=6
	1: parameter not set
	=7
	at=
	=8
	asterisk=
	=9
	0
	=10
	!: parameter not set
	=11
	ush
	=12
	0
	=14
	mypid=nz
	=15
---
name: nameref-1
description:
	Testsuite for nameref (bound variables)
stdin:
	bar=global
	typeset -n ir2=bar
	typeset -n ind=ir2
	echo !ind: ${!ind}
	echo ind: $ind
	echo !ir2: ${!ir2}
	echo ir2: $ir2
	typeset +n ind
	echo !ind: ${!ind}
	echo ind: $ind
	typeset -n ir2=ind
	echo !ir2: ${!ir2}
	echo ir2: $ir2
	set|grep ^ir2|sed 's/^/s1: /'
	typeset|grep ' ir2'|sed -e 's/^/s2: /' -e 's/nameref/typeset -n/'
	set -A blub -- e1 e2 e3
	typeset -n ind=blub
	typeset -n ir2=blub[2]
	echo !ind[1]: ${!ind[1]}
	echo !ir2: $!ir2
	echo ind[1]: ${ind[1]}
	echo ir2: $ir2
expected-stdout:
	!ind: bar
	ind: global
	!ir2: bar
	ir2: global
	!ind: ind
	ind: ir2
	!ir2: ind
	ir2: ir2
	s1: ir2=ind
	s2: typeset -n ir2
	!ind[1]: blub[1]
	!ir2: ir2
	ind[1]: e2
	ir2: e3
---
name: nameref-2da
description:
	Testsuite for nameref (bound variables)
	Functions, argument given directly, after local
stdin:
	function foo {
		typeset bar=lokal baz=auch
		typeset -n v=bar
		echo entering
		echo !v: ${!v}
		echo !bar: ${!bar}
		echo !baz: ${!baz}
		echo bar: $bar
		echo v: $v
		v=123
		echo bar: $bar
		echo v: $v
		echo exiting
	}
	bar=global
	echo bar: $bar
	foo bar
	echo bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: lokal
	bar: 123
	v: 123
	exiting
	bar: global
---
name: nameref-3
description:
	Advanced testsuite for bound variables (ksh93 fails this)
stdin:
	typeset -n foo=bar[i]
	set -A bar -- b c a
	for i in 0 1 2 3; do
		print $i $foo .
	done
expected-stdout:
	0 b .
	1 c .
	2 a .
	3 .
---
name: nameref-4
description:
	Ensure we don't run in an infinite loop
time-limit: 3
stdin:
	baz() {
		typeset -n foo=fnord fnord=foo
		foo[0]=bar
	}
	set -A foo bad
	echo sind $foo .
	baz
	echo blah $foo .
expected-stdout:
	sind bad .
	blah bad .
expected-stderr-pattern:
	/fnord: expression recurses on parameter/
---
name: better-parens-1a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ( (echo fubar)|tr u x); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-1b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $( (echo fubar)|tr u x) $?
expected-stdout:
	fxbar 0
---
name: better-parens-1c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$( (echo fubar)|tr u x); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-2a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ((echo fubar)|tr u x); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-2b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $((echo fubar)|tr u x) $?
expected-stdout:
	fxbar 0
---
name: better-parens-2c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$((echo fubar)|tr u x); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-3a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ( (echo fubar)|(tr u x)); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-3b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $( (echo fubar)|(tr u x)) $?
expected-stdout:
	fxbar 0
---
name: better-parens-3c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$( (echo fubar)|(tr u x)); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-4a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ((echo fubar)|(tr u x)); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-4b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $((echo fubar)|(tr u x)) $?
expected-stdout:
	fxbar 0
---
name: better-parens-4c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$((echo fubar)|(tr u x)); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-5
description:
	Another corner case
stdin:
	( (echo 'fo	o$bar' "baz\$bla\"" m\$eh) | tr a A)
	((echo 'fo	o$bar' "baz\$bla\"" m\$eh) | tr a A)
expected-stdout:
	fo	o$bAr bAz$blA" m$eh
	fo	o$bAr bAz$blA" m$eh
---
name: echo-test-1
description:
	Test what the echo builtin does (mksh)
category: !shell:ebcdic-yes
stdin:
	echo -n 'foo\x40bar'
	echo -e '\tbaz'
expected-stdout:
	foo@@bar	baz
---
name: echo-test-1-ebcdic
description:
	Test what the echo builtin does (mksh)
category: !shell:ebcdic-no
stdin:
	echo -n 'foo\x7Cbar'
	echo -e '\tbaz'
expected-stdout:
	foo@@bar	baz
---
name: echo-test-2
description:
	Test what the echo builtin does (POSIX)
	Note: this follows Debian Policy 10.4 which mandates
	that -n shall be treated as an option, not XSI which
	mandates it shall be treated as string but escapes
	shall be expanded.
stdin:
	test -n "$POSH_VERSION" || set -o posix
	echo -n 'foo\x40bar'
	echo -e '\tbaz'
expected-stdout:
	foo\x40bar-e \tbaz
---
name: echo-test-3-mnbsd
description:
	Test what the echo builtin does, and test a compatibility flag.
category: mnbsdash
stdin:
	"$__progname" -c 'echo -n 1=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x40$1; echo -e \\x2E' -- foo bar
expected-stdout:
	1=@@foo.
	2=\x40foo-e \x2E
	3=\x40bar.
---
name: echo-test-3-normal
description:
	Test what the echo builtin does, and test a compatibility flag.
category: !mnbsdash,!shell:ebcdic-yes
stdin:
	"$__progname" -c 'echo -n 1=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x40$1; echo -e \\x2E' -- foo bar
expected-stdout:
	1=@@foo.
	2=\x40foo-e \x2E
	3=\x40foo-e \x2E
---
name: echo-test-3-ebcdic
description:
	Test what the echo builtin does, and test a compatibility flag.
category: !mnbsdash,!shell:ebcdic-no
stdin:
	"$__progname" -c 'echo -n 1=\\x7C$1; echo -e \\x4B' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x7C$1; echo -e \\x4B' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x7C$1; echo -e \\x4B' -- foo bar
expected-stdout:
	1=@@foo.
	2=\x7Cfoo-e \x4B
	3=\x7Cfoo-e \x4B
---
name: utilities-getopts-1
description:
	getopts sets OPTIND correctly for unparsed option
stdin:
	set -- -a -a -x
	while getopts :a optc; do
	    echo "OPTARG=$OPTARG, OPTIND=$OPTIND, optc=$optc."
	done
	echo done
expected-stdout:
	OPTARG=, OPTIND=2, optc=a.
	OPTARG=, OPTIND=3, optc=a.
	OPTARG=x, OPTIND=4, optc=?.
	done
---
name: utilities-getopts-2
description:
	Check OPTARG
stdin:
	set -- -a Mary -x
	while getopts a: optc; do
	    echo "OPTARG=$OPTARG, OPTIND=$OPTIND, optc=$optc."
	done
	echo done
expected-stdout:
	OPTARG=Mary, OPTIND=3, optc=a.
	OPTARG=, OPTIND=4, optc=?.
	done
expected-stderr-pattern: /.*-x.*option/
---
name: utilities-getopts-3
description:
	Check unsetting OPTARG
stdin:
	set -- -x arg -y
	getopts x:y opt && echo "${OPTARG-unset}"
	getopts x:y opt && echo "${OPTARG-unset}"
expected-stdout:
	arg
	unset
---
name: wcswidth-1
description:
	Check the new wcswidth feature
stdin:
	s=
	set +U
	print octets: ${#s} .
	print 8-bit width: ${%s} .
	set -U
	print characters: ${#s} .
	print columns: ${%s} .
	s=
	set +U
	print octets: ${#s} .
	print 8-bit width: ${%s} .
	set -U
	print characters: ${#s} .
	print columns: ${%s} .
expected-stdout:
	octets: 3 .
	8-bit width: -1 .
	characters: 1 .
	columns: 2 .
	octets: 3 .
	8-bit width: 3 .
	characters: 1 .
	columns: 1 .
---
name: wcswidth-2
description:
	Check some corner cases
stdin:
	print % $% .
	set -U
	x='a	b'
	print c ${%x} .
	set +U
	x='a	b'
	print d ${%x} .
expected-stdout:
	% $% .
	c -1 .
	d -1 .
---
name: wcswidth-3
description:
	Check some corner cases
stdin:
	print ${%} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4a
description:
	Check some corner cases
stdin:
	print ${%*} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4b
description:
	Check some corner cases
stdin:
	print ${%@@} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4c
description:
	Check some corner cases
stdin:
	:
	print ${%?} .
expected-stdout:
	1 .
---
name: realpath-1
description:
	Check proper return values for realpath
category: os:mirbsd
stdin:
	wd=$(realpath .)
	mkdir dir
	:>file
	:>dir/file
	ln -s dir lndir
	ln -s file lnfile
	ln -s nix lnnix
	ln -s . lnself
	i=0
	chk() {
		typeset x y
		x=$(realpath "$wd/$1" 2>&1); y=$?
		print $((++i)) "?$1" =${x##*$wd/} !$y
	}
	chk dir
	chk dir/
	chk dir/file
	chk dir/nix
	chk file
	chk file/
	chk file/file
	chk file/nix
	chk nix
	chk nix/
	chk nix/file
	chk nix/nix
	chk lndir
	chk lndir/
	chk lndir/file
	chk lndir/nix
	chk lnfile
	chk lnfile/
	chk lnfile/file
	chk lnfile/nix
	chk lnnix
	chk lnnix/
	chk lnnix/file
	chk lnnix/nix
	chk lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself
	rm lnself
expected-stdout:
	1 ?dir =dir !0
	2 ?dir/ =dir !0
	3 ?dir/file =dir/file !0
	4 ?dir/nix =dir/nix !0
	5 ?file =file !0
	6 ?file/ =file/: Not a directory !20
	7 ?file/file =file/file: Not a directory !20
	8 ?file/nix =file/nix: Not a directory !20
	9 ?nix =nix !0
	10 ?nix/ =nix !0
	11 ?nix/file =nix/file: No such file or directory !2
	12 ?nix/nix =nix/nix: No such file or directory !2
	13 ?lndir =dir !0
	14 ?lndir/ =dir !0
	15 ?lndir/file =dir/file !0
	16 ?lndir/nix =dir/nix !0
	17 ?lnfile =file !0
	18 ?lnfile/ =lnfile/: Not a directory !20
	19 ?lnfile/file =lnfile/file: Not a directory !20
	20 ?lnfile/nix =lnfile/nix: Not a directory !20
	21 ?lnnix =nix !0
	22 ?lnnix/ =nix !0
	23 ?lnnix/file =lnnix/file: No such file or directory !2
	24 ?lnnix/nix =lnnix/nix: No such file or directory !2
	25 ?lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself =lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself: Too many levels of symbolic links !62
---
name: realpath-2
description:
	Ensure that exactly two leading slashes are not collapsed
	POSIX guarantees this exception, e.g. for UNC paths on Cygwin
category: os:mirbsd
stdin:
	ln -s /bin t1
	ln -s //bin t2
	ln -s ///bin t3
	realpath /bin
	realpath //bin
	realpath ///bin
	realpath /usr/bin
	realpath /usr//bin
	realpath /usr///bin
	realpath t1
	realpath t2
	realpath t3
	rm -f t1 t2 t3
	cd //usr/bin
	pwd
	cd ../lib
	pwd
	realpath //usr/include/../bin
expected-stdout:
	/bin
	//bin
	/bin
	/usr/bin
	/usr/bin
	/usr/bin
	/bin
	//bin
	/bin
	//usr/bin
	//usr/lib
	//usr/bin
---
name: crash-1
description:
	Crashed during March 2011, fixed on vernal equinx 
category: os:mirbsd,os:openbsd
stdin:
	export MALLOC_OPTIONS=FGJRSX
	"$__progname" -c 'x=$(tr z r <<<baz); echo $x'
expected-stdout:
	bar
---
name: debian-117-1
description:
	Check test - bug#465250
stdin:
	test \( ! -e \) ; echo $?
expected-stdout:
	1
---
name: debian-117-2
description:
	Check test - bug#465250
stdin:
	test \(  -e \) ; echo $?
expected-stdout:
	0
---
name: debian-117-3
description:
	Check test - bug#465250
stdin:
	test ! -e  ; echo $?
expected-stdout:
	1
---
name: debian-117-4
description:
	Check test - bug#465250
stdin:
	test  -e  ; echo $?
expected-stdout:
	0
---
name: case-zsh
description:
	Check that zsh case variants work
stdin:
	case 'b' in
	  a) echo a ;;
	  b) echo b ;;
	  c) echo c ;;
	  *) echo x ;;
	esac
	echo =
	case 'b' in
	  a) echo a ;&
	  b) echo b ;&
	  c) echo c ;&
	  *) echo x ;&
	esac
	echo =
	case 'b' in
	  a) echo a ;|
	  b) echo b ;|
	  c) echo c ;|
	  *) echo x ;|
	esac
expected-stdout:
	b
	=
	b
	c
	x
	=
	b
	x
---
name: case-braces
description:
	Check that case end tokens are not mixed up (Debian #220272)
stdin:
	i=0
	for value in 'x' '}' 'esac'; do
		print -n "$((++i))($value)bourne "
		case $value in
		}) echo brace ;;
		*) echo no ;;
		esac
		print -n "$((++i))($value)korn "
		case $value {
		esac) echo esac ;;
		*) echo no ;;
		}
	done
expected-stdout:
	1(x)bourne no
	2(x)korn no
	3(})bourne brace
	4(})korn no
	5(esac)bourne no
	6(esac)korn esac
---
name: command-shift
description:
	Check that 'command shift' works
stdin:
	function snc {
		echo "before	0='$0' 1='$1' 2='$2'"
		shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	function swc {
		echo "before	0='$0' 1='$1' 2='$2'"
		command shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	echo = without command
	snc  
	echo = with command
	swc  
	echo = done
expected-stdout:
	= without command
	before	0='snc' 1='' 2=''
	after	0='snc' 1='' 2=''
	= with command
	before	0='swc' 1='' 2=''
	after	0='swc' 1='' 2=''
	= done
---
name: command-set
description:
	Same but with set
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	showargs 1 "$@@"
	set -- foo bar baz
	showargs 2 "$@@"
	command set -- miau 'meow nyao'
	showargs 3 "$@@"
expected-stdout:
	<1> .
	<2> <foo> <bar> <baz> .
	<3> <miau> <meow nyao> .
---
name: command-readonly
description:
	These should not exit on error when prefixed
stdin:
	exec 2>/dev/null
	"$__progname" -c 'readonly v; export v=foo || echo ok'
	echo ef=$?
	"$__progname" -c 'readonly v; command export v=foo || echo ok'
	echo en=$?
	"$__progname" -c 'readonly v; readonly v=foo || echo ok'
	echo rf=$?
	"$__progname" -c 'readonly v; command readonly v=foo || echo ok'
	echo rn=$?
expected-stdout:
	ef=2
	ok
	en=0
	rf=2
	ok
	rn=0
---
name: command-dot-regression
description:
	Check a regression in fixing the above does not appear
stdin:
	cat >test.mksh <<\EOF
	set -- one two
	shift
	for s_arg in "$#" "$@@"; do echo -n "<$s_arg> "; done; echo .
	EOF
	"$__progname" -c '. ./test.mksh' dummy oh dear this is not good
	echo =
	"$__progname" -c 'command . ./test.mksh' dummy oh dear this is not good
expected-stdout:
	<1> <two> .
	=
	<1> <two> .
---
name: command-pvV-posix-priorities
description:
	For POSIX compatibility, command -v should find aliases and reserved
	words, and command -p[vV] should find aliases, reserved words, and
	builtins over external commands.
stdin:
	PATH=/bin:/usr/bin
	alias foo="bar baz"
	bar() { :; }
	for word in 'if' 'foo' 'bar' 'set' 'true'; do
		command -v "$word"
		command -pv "$word"
		command -V "$word"
		command -pV "$word"
	done
expected-stdout:
	if
	if
	if is a reserved word
	if is a reserved word
	alias foo='bar baz'
	alias foo='bar baz'
	foo is an alias for 'bar baz'
	foo is an alias for 'bar baz'
	bar
	bar
	bar is a function
	bar is a function
	set
	set
	set is a special shell builtin
	set is a special shell builtin
	true
	true
	true is a shell builtin
	true is a shell builtin
---
name: whence-preserve-tradition
description:
	This regression test is to ensure that the POSIX compatibility
	changes for 'command' (see previous test) do not affect traditional
	'whence' behaviour.
category: os:mirbsd
stdin:
	PATH=/bin:/usr/bin
	alias foo="bar baz"
	bar() { :; }
	for word in 'if' 'foo' 'bar' 'set' 'true'; do
		whence "$word"
		whence -p "$word"
		whence -v "$word"
		whence -pv "$word"
	done
expected-stdout:
	if
	if is a reserved word
	if not found
	'bar baz'
	foo is an alias for 'bar baz'
	foo not found
	bar
	bar is a function
	bar not found
	set
	set is a special shell builtin
	set not found
	true
	/bin/true
	true is a shell builtin
	true is a tracked alias for /bin/true
---
name: duffs-device
description:
	Check that the compiler did not optimise-break them
	(lex.c has got a similar one in SHEREDELIM)
category: !shell:faux-ebcdic,!shell:ebcdic-yes
stdin:
	set +U
	s=
	typeset -i1 i=0
	while (( ++i < 256 )); do
		s+=${i#1#}
	done
	s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.'
	typeset -p s
expected-stdout:
	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377\u00A0\u20AC\uFFFD\357\277\276\357\277\277\360\220\200\200.'
---
name: duffs-device-ebcdic
description:
	Check that the compiler did not optimise-break them
category: !shell:ebcdic-no
stdin:
	set +U
	s=
	typeset -i1 i=0
	while (( ++i < 256 )); do
		s+=${i#1#}
	done
	#s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.' #XXX
	typeset -p s
expected-stdout:
	typeset s=$'\001\002\003\004\t\006\007\010\011\012\v\f\r\016\017\020\021\022\023\024\n\b\027\030\031\032\033\034\035\036\037\040\041\042\043\044\045\046\E\050\051\052\053\054\055\056\a\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077 .<(+|&!$*);^-/,%_>?`:#@@\175="abcdefghijklmnopqr~stuvwxyz[]{ABCDEFGHI}JKLMNOPQR\\STUVWXYZ0123456789\377'
---
name: duffs-device-faux-EBCDIC
description:
	Check that the compiler did not optimise-break them
category: shell:faux-ebcdic
stdin:
	set +U
	s=
	typeset -i1 i=0
	while (( ++i < 256 )); do
		s+=${i#1#}
	done
	s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.'
	typeset -p s
expected-stdout:
	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\u00A0\u20AC\uFFFD\220\200\200.'
---
name: stateptr-underflow
description:
	This check overflows an Xrestpos stored in a short in R40
category: fastbox
stdin:
	function Lb64decode {
		[[ -o utf8-mode ]]; local u=$?
		set +U
		local c s="$*" t=
		[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
		local -i i=0 n=${#s} p=0 v x
		local -i16 o
	
		while (( i < n )); do
			c=${s:(i++):1}
			case $c {
			(=)	break ;;
			([A-Z])	(( v = 1#$c - 65 )) ;;
			([a-z])	(( v = 1#$c - 71 )) ;;
			([0-9])	(( v = 1#$c + 4 )) ;;
			(+)	v=62 ;;
			(/)	v=63 ;;
			(*)	continue ;;
			}
			(( x = (x << 6) | v ))
			case $((p++)) {
			(0)	continue ;;
			(1)	(( o = (x >> 4) & 255 )) ;;
			(2)	(( o = (x >> 2) & 255 )) ;;
			(3)	(( o = x & 255 ))
				p=0
				;;
			}
			t=$t\\x${o#16#}
		done
		print -n $t
		(( u )) || set -U
	}
	
	i=-1
	s=
	while (( ++i < 12120 )); do
		s+=a
	done
	Lb64decode $s >/dev/null
---
name: xtrace-1
description:
	Check that "set -x" doesn't redirect too quickly
stdin:
	print '#!'"$__progname" >bash
	cat >>bash <<'EOF'
	echo 'GNU bash, version 2.05b.0(1)-release (i386-ecce-mirbsd10)
	Copyright (C) 2002 Free Software Foundation, Inc.'
	EOF
	chmod +x bash
	"$__progname" -xc 'foo=$(./bash --version 2>&1 | sed q); echo "=$foo="'
expected-stdout:
	=GNU bash, version 2.05b.0(1)-release (i386-ecce-mirbsd10)=
expected-stderr-pattern:
	/.*/
---
name: xtrace-2
description:
	Check that "set -x" is off during PS4 expansion
stdin:
	f() {
		print -n "(f1:$-)"
		set -x
		print -n "(f2:$-)"
	}
	PS4='[(p:$-)$(f)] '
	print "(o0:$-)"
	set -x -o inherit-xtrace
	print "(o1:$-)"
	set +x
	print "(o2:$-)"
expected-stdout:
	(o0:sh)
	(o1:shx)
	(o2:sh)
expected-stderr:
	[(p:sh)(f1:sh)(f2:sh)] print '(o1:shx)'
	[(p:sh)(f1:sh)(f2:sh)] set +x
---
name: fksh-flags
description:
	Check that FKSH functions have their own shell flags
category: shell:legacy-no
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	function foo {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 fh .
---
name: fksh-flags-legacy
description:
	Check that even FKSH functions share the shell flags
category: shell:legacy-yes
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
name: fsh-flags
description:
	Check that !FKSH functions share the shell flags
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
@


1.828
log
@fix test on OpenBSD, where mmap malloc lost the P option, by not
setting it (its also default on MirBSD, when someone sets p in
/etc/malloc.conf, theyre SOL)

From: Brian Callahan <callab5@@rpi.edu>
@
text
@d6 1
a6 1
#	      2019
d2542 13
@


1.827
log
@handle POSIX-style functions like ksh-style functions and external utilities

cf. Debian #935115
@
text
@d13316 1
a13316 1
	export MALLOC_OPTIONS=FGJPRSX
@


1.826
log
@revamp errexit handling

we lose some trap runs but this gets us identical to GNU bash so who cares
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.822 2019/08/02 19:27:12 tg Exp $
d7134 1
a7134 1
	the current execution environment (ksh93, SUSv4)
d7140 1
a7140 1
	x2-3- z1-
d11279 1
a11279 1
	env. If f is a Bourne style function, FOO should be set. Furthermore,
d11325 1
a11325 1
	if [ x$FOO != xfoo ]; then
d11340 1
a11340 1
	if [ x$FOO != xfoo ]; then
@


1.825
log
@make initial tests a bit more robust and easier to maintain
@
text
@d34 1
a34 1
	KSH R57 2019/12/11
d7779 26
d7876 3
a7878 5
	Check that ERR and EXIT traps are run just like ksh93 does.
	GNU bash does not run ERtrap in e eval-undef but runs it
	twice (bug?) in +e eval-false, so does ksh93 (bug?), which
	also has a bug to continue execution (echoing "and out" and
	returning 0) in +e eval-undef.
a7961 1
	ERtrap
d7983 1
a7988 1
	ERtrap
@


1.824
log
@fix selftest-tty-absent to work with lksh
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R57 2019/08/02
d38 2
a39 1
	echo ${KSH_VERSION%%' +'*}
d41 8
d52 1
a52 1
	@@(#)LEGACY KSH R57 2019/08/02
d54 1
a54 1
	Check base version of legacy shell
d56 1
a56 1
	echo ${KSH_VERSION%%' +'*}
d65 1
d76 1
d87 1
d98 1
@


1.823
log
@offer more C.UTF-8 (cf. Debian #609306) choice; drop LTO-specific paragraph
@
text
@d181 1
a181 1
	/mksh: warning: won't have full job control\nXX/
@


1.822
log
@fix regression found by, again, Martijn Dekker; tricky

GCC fails to optimise (ptr1 == ptr2) * (tp->flag & FOO), so dont do it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.818 2019/08/01 20:16:15 tg Exp $
a505 3
	This test also fails if your GCC is buggy with LTO;
	if so, remove -c lto from the Build.sh invocation
	and retry; NEVER ship a binary that fails this test!
@


1.821
log
@introduce another reproducer, for 'command readonly/export' exit on error

From: Martijn Dekker <martijn@@inlv.org>
Message-ID: <b1c4ef11-3cd9-dd36-c41c-55519f731d54@@inlv.org>
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R57 2019/08/01
d43 1
a43 1
	@@(#)LEGACY KSH R57 2019/08/01
d13443 17
@


1.820
log
@failed attempt at fixing 'command set' does not set PPs

bugreport by Martijn Dekker <martijn@@inlv.org>
Message-ID: <88ba843f-0a2d-ceb7-f3fa-8a880848cb07@@inlv.org>

this fails because the new argv is allocated in the temporary
environment unsure how best fix
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R57 2019/04/24
d43 1
a43 1
	@@(#)LEGACY KSH R57 2019/04/24
d13422 21
@


1.819
log
@disable xxx-stat-1 for now:

it fails, among other things, when run as root; many reports via IRC
@
text
@d10861 1
a10861 1
	while IFS= read -pr line; do
d13407 15
@


1.818
log
@make ulimit-3 test use a tempfile instead of |& which needs a full port

this reverts commit 693c6f90c530a93781372844606c12f4ebc61d84 (r1.816)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.814 2019/04/24 20:30:52 tg Exp $
d7395 2
@


1.817
log
@Remove drive letter first in nounset-1 test

In nounset-1 test, drive letter is not processed properly. For example,

-----
=3
F:/.../mksh.exe: y: parameter not set
-----

In the above output, only ':' following drive letter 'F' is removed. As
a result, the result filtered by sed becomes the following:

-----
=3
/.../mksh.exe: y: parameter not set
-----

After all, nounset-1 test fails on OS/2.

From: KO Myung-Hun <komh@@chollian.net>
@
text
@a10850 1
category: !nojsig
d10857 1
a10857 1
	ulimit -a |&
d10873 1
a10873 1
	done
@


1.816
log
@exclude ulimit-3 on nojsig platforms such as OS/2

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d12703 1
a12703 1
	) 2>&1 | sed -e 's/^[^]]*]//' -e 's/^[^:]*: *//'
@


1.815
log
@exclude the same tests on Midipix we exclude on Cygwin
@
text
@d10851 1
@


1.814
log
@add a test to fail if ulimit codes are duplicated
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.812 2019/03/01 16:17:29 tg Exp $
d1398 1
a1398 1
category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!os:os390,!nosymlink
d2005 1
a2005 1
category: !os:cygwin,!os:msys,!os:os2
d2497 1
a2497 1
category: !os:cygwin,!os:darwin,!os:msys,!os:nto,!os:os2,!os:os390
d8678 1
a8678 1
category: !os:cygwin,!os:msys,!os:ultrix,!os:uwin-nt,!smksh
@


1.813
log
@be more explicit about the GCC/LTO issue
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R57 2019/03/01
d43 1
a43 1
	@@(#)LEGACY KSH R57 2019/03/01
d10847 37
@


1.812
log
@Mach halt Dein Unix nicht kaputt, basta! (LP#1817959)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.811 2019/01/05 12:47:38 tg Exp $
d506 3
@


1.811
log
@unwind with LEXIT ipv LLEAVE in XEXEC in one more place (12 of 3)

this fixes Debian #910276 and runs EXIT traps in single-child TPIPEs
and I _hope_ it does not break anything
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.808 2018/08/10 02:53:31 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R56 2019/01/05
d43 1
a43 1
	@@(#)LEGACY KSH R56 2019/01/05
d7148 1
a7148 1
	/=1\none\n=2\ntwo\n=3\n.*: ls: not found\n=4\ntf\n/
d7169 1
a7169 1
	/=1\n.*: print: not found\n=2\n.*: foo: not found\n=3\n.*: ls: not found\n=4\ntf\n/
d7389 22
@


1.810
log
@fix ksh-style close-on-exec-for-fds-above-2 in dup-to-self scenario

bugreport by catern via IRC
@
text
@d5 2
a6 1
#	      2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d34 1
a34 1
	@@(#)MIRBSD KSH R56 2018/12/04
d43 1
a43 1
	@@(#)LEGACY KSH R56 2018/12/04
d7945 17
@


1.809
log
@catch up a little on test cases
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/10/20
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/10/20
d11267 28
@


1.808
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.807 2018/07/15 17:22:15 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/07/15
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/07/15
d3068 13
d7261 26
@


1.807
log
@add ctty tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.802 2018/03/09 01:29:08 tg Exp $
d2490 1
a2490 1
# breaks on Mac OSX (HFS+ non-standard Unicode canonical decomposition)
d8515 1
a8515 1
	Check for a regression in which Unicode wasnt left-padded right
d8538 1
a8538 1
# breaks on Mac OSX (HFS+ non-standard Unicode canonical decomposition)
d10417 1
a10417 1
	some sample code for hexdumping Unicode
d10585 1
a10585 1
	some sample code for hexdumping Unicode; NUL and binary safe
d10705 1
a10705 1
	Check to see that were NUL and Unicode safe
d10719 1
a10719 1
	Check to see that were NUL and Unicode safe
d10733 1
a10733 1
	Check to see that were NUL and Unicode safe
@


1.806
log
@Unicode 11.0.0
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/06/26
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/06/26
d165 32
@


1.805
log
@fix using -m on the command line; spotted by G.raud <graud@@gmx.com> on ML
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/05/08
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/05/08
@


1.804
log
@fix typeset -L vs. Unicode: snprintf second arg was wrong
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/05/07
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/05/07
@


1.803
log
@fix allexport for arrays; add testcase that also catches exporting arrays
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/04/28
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/04/28
d8481 20
@


1.802
log
@make ${foo#'bar'} in here document behave like ksh93
reported by Martijn Dekker <martijn@@inlv.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.797 2017/08/29 13:38:29 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/03/09
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/03/09
d6857 15
@


1.801
log
@bump; add testcase provided by @@mvdan on github
@
text
@d5 1
a5 1
#	      2011, 2012, 2013, 2014, 2015, 2016, 2017
d33 1
a33 1
	@@(#)MIRBSD KSH R56 2018/01/14
d42 1
a42 1
	@@(#)LEGACY KSH R56 2018/01/14
d3529 19
@


1.800
log
@increase some sleep and time limits, reported by Dr. Werner Fink
from OpenSuSE: their qemu-based powerpc systems have timing issues
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2017/10/17
d42 1
a42 1
	@@(#)LEGACY KSH R56 2017/10/17
d9029 9
@


1.799
log
@tentatively fix Debian #878947 by putting an end to (some) nesting

 also makes the error message nicer:
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)'
internal error: can't allocate 8388628 data bytes
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
mksh: no closing quote
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)'
./mksh: syntax error: unmatched '('
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
./mksh: syntax error: unmatched '('

 alternative fix would be to keep the block and do
-					} else {
+					} else if (source->type != SEOF) {
 but that would keep no closing quote for the case with newline,
and since this seems to not break nuking unused code is always good 
@
text
@d3331 1
a3331 1
	sleep 2
d3395 1
a3395 1
	sleep 2
d6705 1
a6705 1
time-limit: 3
@


1.798
log
@move getdrvwd() declaration out of OS/2-specific part:
each MKSH_DOSPATH port is required to define it (and, later, others)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2017/10/14
d42 1
a42 1
	@@(#)LEGACY KSH R56 2017/10/14
@


1.797
log
@monkey-patch offsetof for a klibc/dietlibc warning; bump to R56b (bugfixes)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.793 2017/05/14 19:05:44 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R56 2017/08/29
d42 1
a42 1
	@@(#)LEGACY KSH R56 2017/08/29
@


1.796
log
@bump
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2017/08/08
d42 1
a42 1
	@@(#)LEGACY KSH R56 2017/08/08
@


1.795
log
@fuck POSIX
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R56 2017/08/07
d42 1
a42 1
	@@(#)LEGACY KSH R56 2017/08/07
@


1.794
log
@make readonly idempotent; spotted by selk from Dragora
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/07/26
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/07/26
d7049 42
@


1.793
log
@exclude nn-HPFS-safe pathname-using test from OS/2 (thanks komh)
also exclude on cygwin/msys as not FAT/NTFS-safe
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.774 2017/04/11 12:34:02 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/05/05
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/05/01
d6909 7
@


1.792
log
@sprinkle tons more ord() around

this is really not funny mksh-ng will use even more unsigned only
@
text
@d1969 1
@


1.791
log
@catch z/OS not having $Config not filling in the __perlpath env correctly
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/05/01
@


1.790
log
@some more small EBCDIC fixes
@
text
@d8460 1
a8460 1
category: !os:cygwin,!os:msys,!os:ultrix,!os:uwin-nt,!smksh,!shell:ebcdic-yes
@


1.789
log
@first cut at the new matching code, IT WORKS!!! in the FIRST try!

missing:
- tons of new testcases
- EBCDIC support with ASCII ordering for POSIX ranges
@
text
@d1359 1
a1359 1
# the mv command fails on Cygwin
d1362 1
a1362 1
category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!nosymlink
d12745 3
a12747 3
	"$__progname" -c 'echo -n 1=\\x7C$1; echo -e \\x2E' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x7C$1; echo -e \\x2E' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x7C$1; echo -e \\x2E' -- foo bar
d12750 2
a12751 2
	2=\x7Cfoo-e \x2E
	3=\x7Cfoo-e \x2E
@


1.788
log
@split and adapt some testcases for EBCDIC
@
text
@d2490 1
a2490 2
	#XXX TODO: echo [a--@@]*
	# -> @@bc
d2493 1
@


1.787
log
@commit my WIP for the Beltane Snapshot of the Mainframe Korn Shell, not going to make finishing it tonight 
@
text
@d2328 1
d2769 1
d2822 56
d5165 10
a5174 1
name: integer-base-check-numeric-from
d5176 2
a5177 1
	Check behaviour for base one to 36, and that 37 degrades to 10
d5180 7
a5192 1
	1:490.
d5231 1
a5231 1
name: integer-base-check-numeric-to
d5233 2
a5234 1
	Check behaviour for base one to 36, and that 37 degrades to 10
d5236 24
a5259 1
	i=0
a5265 1
	1:1#@@.64.
d8403 1
a8403 1
category: !os:darwin
d8460 1
a8460 1
category: !os:cygwin,!os:msys,!os:ultrix,!os:uwin-nt,!smksh
d9481 1
d9490 12
d10561 1
d10572 14
d12683 1
d12690 10
d12730 1
a12730 1
category: !mnbsdash
d12740 13
d13188 1
a13188 1
category: !shell:faux-ebcdic
d13201 16
@


1.786
log
@reimplement has_globbing() with proper bracket expression parsing,
and take ahead parsing collating symbols, equivalence classes and
character classes already (heck my first draft of this already did
better than GNU bash, ksh93 I still dont grok its code at all)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/04/27
d35 1
a35 1
	Check version of shell.
d37 1
a37 1
	echo $KSH_VERSION
d39 1
a39 1
category: !shell:legacy-yes,!shell:textmode-yes,!shell:ebcdic-yes
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/04/27
d44 1
a44 1
	Check version of legacy shell.
d46 1
a46 1
	echo $KSH_VERSION
d48 1
a48 1
category: !shell:legacy-no,!shell:textmode-yes,!shell:ebcdic-yes
d50 1
a50 2
expected-stdout:
	@@(#)MIRBSD KSH R55 2017/04/27 +EBCDIC
d52 2
a53 1
	Check version of shell.
d55 5
a59 1
	echo $KSH_VERSION
a60 4
category: !shell:legacy-yes,!shell:textmode-yes,!shell:ebcdic-no
---
expected-stdout:
	@@(#)LEGACY KSH R55 2017/04/27 +EBCDIC
d62 2
a63 1
	Check version of legacy shell.
d65 4
a68 3
	echo $KSH_VERSION
name: KSH_VERSION-legacy-ebcdic
category: !shell:legacy-no,!shell:textmode-yes,!shell:ebcdic-no
d70 1
a70 2
expected-stdout:
	@@(#)MIRBSD KSH R55 2017/04/27 +TEXTMODE
d72 2
a73 1
	Check version of shell.
d75 5
a79 1
	echo $KSH_VERSION
a80 4
category: !shell:legacy-yes,!shell:textmode-no
---
expected-stdout:
	@@(#)LEGACY KSH R55 2017/04/27 +TEXTMODE
d82 2
a83 1
	Check version of legacy shell.
d85 4
a88 3
	echo $KSH_VERSION
name: KSH_VERSION-legacy-textmode
category: !shell:legacy-no,!shell:textmode-no
d2360 1
d2367 5
d2376 3
d2486 1
d2489 2
d2494 19
@


1.785
log
@clean up OS exclusions somewhat: have Perl substitute the UTF-8 locale
@
text
@d1965 1
a1965 3
file-setup: file 644 "abcx"
file-setup: file 644 "abcz"
file-setup: file 644 "bbc"
d1967 1
a1967 2
	echo !([*)*
	echo +(a|b[)*
d1969 1
a1969 2
	!([*)*
	+(a|b[)*
d2056 1
d2060 1
d2355 1
a2355 1
	Check that globbing isn't done when glob has syntax error
d2363 2
a2364 2
	[*
	*[x
d2404 6
a2415 2
	:>'./!bc'
	:>'./^bc'
d2417 3
a2419 1
	echo [!ab]*
d2423 2
a2424 2
	cbc
	-bc cbc
d2427 2
a2428 1
	!bc -bc ^bc cbc
@


1.784
log
@handle expected utf8opt-2a failures better (i.e. dont even try)
@
text
@d1358 1
a1358 1
category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!os:os390,!nosymlink
d2441 1
a2441 1
category: !os:cygwin,!os:darwin,!os:msys,!os:nto,!os:os2
d8343 1
a8343 1
name: utf8opt-1a
d8346 1
a8346 2
category: !os:hpux
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
d8356 1
a8356 15
name: utf8opt-1b
description:
	Check that the utf8-mode flag is not set at non-interactive startup
category: os:hpux
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.utf8!
stdin:
	if [[ $- = *U* ]]; then
		echo is set
	else
		echo is not set
	fi
expected-stdout:
	is not set
---
name: utf8opt-2a
d8361 1
a8361 20
category: !os:hpux,!noutf8
need-ctty: yes
arguments: !-i!
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
stdin:
	if [[ $- = *U* ]]; then
		echo is set
	else
		echo is not set
	fi
expected-stdout:
	is set
expected-stderr-pattern:
	/(# )*/
---
name: utf8opt-2b
description:
	Check that the utf8-mode flag is set at interactive startup
	Expected failure if -DMKSH_ASSUME_UTF8=0
category: os:hpux
d8364 1
a8364 1
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.utf8!
@


1.783
log
@since we have -DMKSH_ASSUME_UTF8=0 on z/OS, omit the known-to-fail check on OS/390
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.782 2017/04/28 11:13:45 tg Exp $
d8374 1
a8374 4
	-DMKSH_ASSUME_UTF8=0 => expected failure, please ignore
	-DMKSH_ASSUME_UTF8=1 => not expected, please investigate
	-UMKSH_ASSUME_UTF8 => not expected, but if your OS is old,
	 try passing HAVE_SETLOCALE_CTYPE=0 to Build.sh
d8376 1
a8376 1
category: !os:hpux,!os:msys,!os:os2,!os:os390
@


1.782
log
@add -DMKSH_FAUX_EBCDIC to test the codepaths better

waking up to: Lanfear - Just Another Broken Shell
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.774 2017/04/11 12:34:02 tg Exp $
d8379 1
a8379 1
category: !os:hpux,!os:msys,!os:os2
@


1.781
log
@control character madness, but more compiler-friendly
@
text
@d9392 1
d9412 23
d13036 1
d13049 16
@


1.780
log
@apply most of the remaining parts of the EBCDIC patch, sans the CTRL() changes
@
text
@d9751 1
a9751 1
	    $'\2345' $'\ca' $'\c!' $'\c?' $'\c' $'a\
d9793 1
a9793 1
	00000080  35 0A 01 0A 01 0A 7F 0A - 02 82 AC 0A 61 0A 62 0A  |5...........a.b.|
@


1.779
log
@commit the optimisation result from the new fast character classes
@
text
@d1376 1
a1376 1
	chmod 755 renamed
@


1.778
log
@restore . as allowed char in alias names
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/04/20
d39 1
a39 1
category: !shell:legacy-yes,!shell:textmode-yes
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/04/20
d48 1
a48 1
category: !shell:legacy-no,!shell:textmode-yes
d51 19
a69 1
	@@(#)MIRBSD KSH R55 2017/04/20 +TEXTMODE
d78 1
a78 1
	@@(#)LEGACY KSH R55 2017/04/20 +TEXTMODE
d11519 1
a11519 1
		\echo $(\true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} 
d11525 1
a11525 1
		x=$(\echo $(\true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) 
d11531 1
a11531 1
		x=$( ( \echo $(\true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) | \tr u x ) 
@


1.777
log
@useful testcase from POSIX
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/04/17
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/04/17
d51 1
a51 1
	@@(#)MIRBSD KSH R55 2017/04/17 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R55 2017/04/17 +TEXTMODE
@


1.776
log
@do not apply alias name restrictions to directories or hash
reported by Seb <sbb@@tuxfamily.org>
@
text
@d2368 12
@


1.775
log
@add test -v, initially from Martijn Dekker
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R55 2017/04/12
d42 1
a42 1
	@@(#)LEGACY KSH R55 2017/04/12
d51 1
a51 1
	@@(#)MIRBSD KSH R55 2017/04/12 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R55 2017/04/12 +TEXTMODE
@


1.774
log
@disambiguate $(()) vs. $(()) in typeset -f output
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.771 2017/04/06 01:59:51 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/04/07
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/04/07
d51 1
a51 1
	@@(#)MIRBSD KSH R54 2017/04/07 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R54 2017/04/07 +TEXTMODE
d7751 52
@


1.773
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d11100 1
a11100 1
		x=$(( vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" ) | \tr u x ) 
d11113 1
a11113 1
		x=$(( \echo $foo | \tr -dc 0-9 ; \echo ) ) 
d11119 1
a11119 1
		x=$(( ( \echo $foo | \tr -dc 0-9 ; \echo ) ) | \tr u x ) 
d11137 1
a11137 1
		x=$(( \cmd && \echo ja || \echo nein ) | \tr u x ) 
d11159 1
a11159 1
		x=$(( select file in * ; do \echo "<$file>" ; \break ; done ) | \tr u x ) 
d11180 1
a11180 1
		x=$(( time for i in {1,2,3} ; do \echo $i ; done ) | \tr u x ) 
d11208 1
a11208 1
		x=$(( case $foo in (1) \echo eins  ;& (2) \echo zwei  ;| (*) \echo kann net bis drei zhlen  ;; esac ) | \tr u x ) 
d11234 1
a11234 1
		x=$(( if ! [[ 1 = 1 ]] ; then \echo eins ; elif [[ 1 = 2 ]] ; then \echo zwei ; else \echo drei ; fi ) | \tr u x ) 
d11259 1
a11259 1
		x=$(( i=1 ; while { \\builtin let " i < 10 " ; } ; do \echo $i ; \let ++i ; done ) | \tr u x ) 
d11283 1
a11283 1
		x=$(( i=10 ; until { \\builtin let " !--i " ; } ; do \echo $i ; done ) | \tr u x ) 
d11302 1
a11302 1
		x=$(( \cat * |&  \ls ) | \tr u x ) 
d11329 1
a11329 1
		x=$(( function korn { \echo eins ; \echo zwei ; } ; bourne() { \logger * &  } ) | \tr u x ) 
d11347 1
a11347 1
		x=$(( \tr x u <foo >>bar ) | \tr u x ) 
d11377 1
a11377 1
		x=$(( \cat >|bar <<"EOFN" 
d11410 1
a11410 1
		x=$(( \cat >bar <<-EOFI 
d11431 1
a11431 1
		x=$(( \sh 1<>/dev/console <&1 2>&1 ) | \tr u x ) 
d11449 1
a11449 1
		x=$(( \echo $(\true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) | \tr u x ) 
d11475 1
a11475 1
		x=$(( \echo fo\ob\"a\`r\'b\$az ; \echo "fo\ob\"a\`r\'b\$az" ; \echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) | \tr u x ) 
d11493 1
a11493 1
		x=$(( [[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) | \tr u x ) 
d11524 1
a11524 1
		x=$(( x=$(\cat <<EOFN 
d11558 1
a11558 1
		x=$(( x=$(\cat <<EOFN\  
d11640 1
a11640 1
		x=$(( x=$(\sysctl -n kern.version | \sed 1q ) ; [[ -s /etc/motd && "$([[ "$(\head -1 /etc/motd )" != $x ]] && \ed -s /etc/motd 2>&1 <<-EOF 
d11677 1
a11677 1
		x=$(( case x in (x) a+=b ; \\builtin set -A c+ -- d e  ;; esac ) | \tr u x ) 
d11756 1
a11756 1
		x=$(( vara=1 varb="2  3" \cmd arg1 $arg2 "$arg3  4" >&3 ) | \tr u x ) 
d11769 1
a11769 1
		x=$(( \echo $foo | \tr -dc 0-9 >&3 ; \echo >&3 ) >&3 ) 
d11775 1
a11775 1
		x=$(( ( \echo $foo | \tr -dc 0-9 >&3 ; \echo >&3 ) >&3 ) | \tr u x ) 
d11793 1
a11793 1
		x=$(( \cmd >&3 && \echo ja >&3 || \echo nein >&3 ) | \tr u x ) 
d11815 1
a11815 1
		x=$(( select file in * ; do \echo "<$file>" ; \break >&3 ; done >&3 ) | \tr u x ) 
d11836 1
a11836 1
		x=$(( for i in {1,2,3} ; do time \echo $i >&3 ; done >&3 ) | \tr u x ) 
d11864 1
a11864 1
		x=$(( case $foo in (1) \echo eins >&3  ;& (2) \echo zwei >&3  ;| (*) \echo kann net bis drei zhlen >&3  ;; esac >&3 ) | \tr u x ) 
d11890 1
a11890 1
		x=$(( if ! [[ 1 = 1 ]] >&3 ; then \echo eins ; elif [[ 1 = 2 ]] >&3 ; then \echo zwei ; else \echo drei ; fi >&3 ) | \tr u x ) 
d11915 1
a11915 1
		x=$(( i=1 ; while { \\builtin let " i < 10 " ; } >&3 ; do \echo $i ; \let ++i ; done >&3 ) | \tr u x ) 
d11939 1
a11939 1
		x=$(( i=10 ; until { \\builtin let " !--i " ; } >&3 ; do \echo $i ; done >&3 ) | \tr u x ) 
d11958 1
a11958 1
		x=$(( \cat * >&3 |&  \ls >&3 ) | \tr u x ) 
d11985 1
a11985 1
		x=$(( function korn { \echo eins ; \echo zwei >&3 ; } ; bourne() { \logger * >&3 &  } ) | \tr u x ) 
d12003 1
a12003 1
		x=$(( \echo $(\true >&3 ) $((1+ 2)) ) | \tr u x ) 
@


1.772
log
@last tweak, to demonstrate brokenness of the old code
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/04/05
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/04/05
d51 1
a51 1
	@@(#)MIRBSD KSH R54 2017/04/05 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R54 2017/04/05 +TEXTMODE
d1004 2
d1018 2
d1089 2
d1113 4
@


1.771
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.767 2017/04/02 14:14:04 tg Exp $
d10944 1
d10957 1
d10960 1
d10963 1
d10966 1
@


1.770
log
@streamline some error messages
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/04/02
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/04/02
d51 1
a51 1
	@@(#)MIRBSD KSH R54 2017/04/02 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R54 2017/04/02 +TEXTMODE
d301 21
d2884 1
a2884 1
		foo 4<<-a <<-b 5<<-c 
d10927 1
a10927 1
			echo x 
d10930 1
a10930 1
			echo $1 
d10938 1
d10947 4
d10952 1
d10956 5
a10960 1
		./pfn "$(echo foo )" 
d10962 1
d11073 1
a11073 1
		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" 
d11079 1
a11079 1
		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) 
d11085 1
a11085 1
		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) | tr u x ) 
d11091 2
a11092 2
		( echo $foo | tr -dc 0-9 
		  echo ) 
d11098 1
a11098 1
		x=$(( echo $foo | tr -dc 0-9 ; echo ) ) 
d11104 1
a11104 1
		x=$(( ( echo $foo | tr -dc 0-9 ; echo ) ) | tr u x ) 
d11110 1
a11110 1
		cmd && echo ja || echo nein 
d11116 1
a11116 1
		x=$(cmd && echo ja || echo nein ) 
d11122 1
a11122 1
		x=$(( cmd && echo ja || echo nein ) | tr u x ) 
d11130 2
a11131 2
			echo "<$file>" 
			break 
d11138 1
a11138 1
		x=$(select file in * ; do echo "<$file>" ; break ; done ) 
d11144 1
a11144 1
		x=$(( select file in * ; do echo "<$file>" ; break ; done ) | tr u x ) 
d11152 1
a11152 1
			echo $i 
d11159 1
a11159 1
		x=$(time for i in {1,2,3} ; do echo $i ; done ) 
d11165 1
a11165 1
		x=$(( time for i in {1,2,3} ; do echo $i ; done ) | tr u x ) 
d11173 1
a11173 1
			echo eins 
d11176 1
a11176 1
			echo zwei 
d11179 1
a11179 1
			echo kann net bis drei zhlen 
d11187 1
a11187 1
		x=$(case $foo in (1) echo eins  ;& (2) echo zwei  ;| (*) echo kann net bis drei zhlen  ;; esac ) 
d11193 1
a11193 1
		x=$(( case $foo in (1) echo eins  ;& (2) echo zwei  ;| (*) echo kann net bis drei zhlen  ;; esac ) | tr u x ) 
d11201 1
a11201 1
			echo eins 
d11204 1
a11204 1
			echo zwei 
d11206 1
a11206 1
			echo drei 
d11213 1
a11213 1
		x=$(if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) 
d11219 1
a11219 1
		x=$(( if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) | tr u x ) 
d11230 2
a11231 2
			echo $i 
			let ++i 
d11238 1
a11238 1
		x=$(i=1 ; while { \\builtin let " i < 10 " ; } ; do echo $i ; let ++i ; done ) 
d11244 1
a11244 1
		x=$(( i=1 ; while { \\builtin let " i < 10 " ; } ; do echo $i ; let ++i ; done ) | tr u x ) 
d11255 1
a11255 1
			echo $i 
d11262 1
a11262 1
		x=$(i=10 ; until { \\builtin let " !--i " ; } ; do echo $i ; done ) 
d11268 1
a11268 1
		x=$(( i=10 ; until { \\builtin let " !--i " ; } ; do echo $i ; done ) | tr u x ) 
d11274 2
a11275 2
		cat * |& 
		ls 
d11281 1
a11281 1
		x=$(cat * |&  ls ) 
d11287 1
a11287 1
		x=$(( cat * |&  ls ) | tr u x ) 
d11295 2
a11296 2
			echo eins 
			echo zwei 
d11299 1
a11299 1
			logger * & 
d11307 1
a11307 1
		x=$(function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) 
d11314 1
a11314 1
		x=$(( function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) | tr u x ) 
d11320 1
a11320 1
		tr x u <foo >>bar 
d11326 1
a11326 1
		x=$(tr x u <foo >>bar ) 
d11332 1
a11332 1
		x=$(( tr x u <foo >>bar ) | tr u x ) 
d11340 1
a11340 1
		cat >|bar <<"EOFN" 
d11351 1
a11351 1
		x=$(cat >|bar <<"EOFN" 
d11362 1
a11362 1
		x=$(( cat >|bar <<"EOFN" 
d11365 1
a11365 1
	) | tr u x ) 
d11373 1
a11373 1
		cat >bar <<-EOFI 
d11384 1
a11384 1
		x=$(cat >bar <<-EOFI 
d11395 1
a11395 1
		x=$(( cat >bar <<-EOFI 
d11398 1
a11398 1
	) | tr u x ) 
d11404 1
a11404 1
		sh 1<>/dev/console <&1 2>&1 
d11410 1
a11410 1
		x=$(sh 1<>/dev/console <&1 2>&1 ) 
d11416 1
a11416 1
		x=$(( sh 1<>/dev/console <&1 2>&1 ) | tr u x ) 
d11422 1
a11422 1
		echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} 
d11428 1
a11428 1
		x=$(echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) 
d11434 1
a11434 1
		x=$(( echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) | tr u x ) 
d11442 3
a11444 3
		echo fo\ob\"a\`r\'b\$az 
		echo "fo\ob\"a\`r\'b\$az" 
		echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" 
d11452 1
a11452 1
		x=$(echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) 
d11460 1
a11460 1
		x=$(( echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) | tr u x ) 
d11478 1
a11478 1
		x=$(( [[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) | tr u x ) 
d11486 1
a11486 1
		x=$(cat <<EOFN 
d11490 1
a11490 1
		echo $x 
d11498 1
a11498 1
		x=$(x=$(cat <<EOFN 
d11501 1
a11501 1
	) ; echo $x ) 
d11509 1
a11509 1
		x=$(( x=$(cat <<EOFN 
d11512 1
a11512 1
	) ; echo $x ) | tr u x ) 
d11520 1
a11520 1
		x=$(cat <<EOFN\  
d11524 1
a11524 1
		echo $x 
d11532 1
a11532 1
		x=$(x=$(cat <<EOFN\  
d11535 1
a11535 1
	) ; echo $x ) 
d11543 1
a11543 1
		x=$(( x=$(cat <<EOFN\  
d11546 1
a11546 1
	) ; echo $x ) | tr u x ) 
d11565 2
a11566 2
		x=$(sysctl -n kern.version | sed 1q ) 
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
d11574 1
a11574 1
	)" = @@(?) ]] && rm -f /etc/motd 
d11577 2
a11578 2
			install -c -o root -g wheel -m 664 /dev/null /etc/motd 
			print -- "$x\n" >/etc/motd 
d11598 1
a11598 1
		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
d11606 1
a11606 1
	)" = @@(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) 
d11625 1
a11625 1
		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
d11633 1
a11633 1
	)" = @@(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) | tr u x ) 
d11662 1
a11662 1
		x=$(( case x in (x) a+=b ; \\builtin set -A c+ -- d e  ;; esac ) | tr u x ) 
d11729 1
a11729 1
		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 
d11735 1
a11735 1
		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) 
d11741 1
a11741 1
		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) | tr u x ) 
d11747 2
a11748 2
		( echo $foo | tr -dc 0-9 >&3 
		  echo >&3 ) >&3 
d11754 1
a11754 1
		x=$(( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) 
d11760 1
a11760 1
		x=$(( ( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) | tr u x ) 
d11766 1
a11766 1
		cmd >&3 && echo ja >&3 || echo nein >&3 
d11772 1
a11772 1
		x=$(cmd >&3 && echo ja >&3 || echo nein >&3 ) 
d11778 1
a11778 1
		x=$(( cmd >&3 && echo ja >&3 || echo nein >&3 ) | tr u x ) 
d11786 2
a11787 2
			echo "<$file>" 
			break >&3 
d11794 1
a11794 1
		x=$(select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) 
d11800 1
a11800 1
		x=$(( select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) | tr u x ) 
d11808 1
a11808 1
			time echo $i >&3 
d11815 1
a11815 1
		x=$(for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) 
d11821 1
a11821 1
		x=$(( for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) | tr u x ) 
d11829 1
a11829 1
			echo eins >&3 
d11832 1
a11832 1
			echo zwei >&3 
d11835 1
a11835 1
			echo kann net bis drei zhlen >&3 
d11843 1
a11843 1
		x=$(case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) 
d11849 1
a11849 1
		x=$(( case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) | tr u x ) 
d11857 1
a11857 1
			echo eins 
d11860 1
a11860 1
			echo zwei 
d11862 1
a11862 1
			echo drei 
d11869 1
a11869 1
		x=$(if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) 
d11875 1
a11875 1
		x=$(( if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) | tr u x ) 
d11886 2
a11887 2
			echo $i 
			let ++i 
d11894 1
a11894 1
		x=$(i=1 ; while { \\builtin let " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) 
d11900 1
a11900 1
		x=$(( i=1 ; while { \\builtin let " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
d11911 1
a11911 1
			echo $i 
d11918 1
a11918 1
		x=$(i=10 ; until { \\builtin let " !--i " ; } >&3 ; do echo $i ; done >&3 ) 
d11924 1
a11924 1
		x=$(( i=10 ; until { \\builtin let " !--i " ; } >&3 ; do echo $i ; done >&3 ) | tr u x ) 
d11930 2
a11931 2
		cat * >&3 |& 
		ls >&3 
d11937 1
a11937 1
		x=$(cat * >&3 |&  ls >&3 ) 
d11943 1
a11943 1
		x=$(( cat * >&3 |&  ls >&3 ) | tr u x ) 
d11951 2
a11952 2
			echo eins 
			echo zwei >&3 
d11955 1
a11955 1
			logger * >&3 & 
d11963 1
a11963 1
		x=$(function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) 
d11970 1
a11970 1
		x=$(( function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) | tr u x ) 
d11976 1
a11976 1
		echo $(true >&3 ) $((1+ 2)) 
d11982 1
a11982 1
		x=$(echo $(true >&3 ) $((1+ 2)) ) 
d11988 1
a11988 1
		x=$(( echo $(true >&3 ) $((1+ 2)) ) | tr u x ) 
@


1.769
log
@komh reports that OS/2 has no chance of supporting UTF-8 (like MSYS)
@
text
@d7610 1
a7610 1
	/syntax error: 'newline' unexpected/
@


1.768
log
@fix typeset -p x[2]
@
text
@d8266 1
a8266 1
category: !os:hpux,!os:msys
@


1.767
log
@introduce the -T flag to set TEXTMODE (ASCII CR+LF newline support)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.763 2017/03/19 20:59:23 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/03/25
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/03/25
d51 1
a51 1
	@@(#)MIRBSD KSH R54 2017/03/25 +TEXTMODE
d60 1
a60 1
	@@(#)LEGACY KSH R54 2017/03/25 +TEXTMODE
d8102 18
@


1.766
log
@small character classes overhaul:
 make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
 optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
 remove a misleading comment in initctypes() about \0 from pdksh
 rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
 sprinkle a few ord() in there
 add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
 there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d39 1
a39 1
category: shell:legacy-no
d48 19
a66 1
category: shell:legacy-yes
d133 1
a133 1
name: selftest-pathsep-os2
d9444 1
d9467 26
@


1.765
log
@fixup LINENO in eval and alias; patch and initial testcase
From: Martijn Dekker <martijn@@inlv.org>
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/03/21
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/03/21
@


1.764
log
@add standard variable PATHSEP, for better and easier OS/2 support
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/03/19
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/03/19
d5235 18
@


1.763
log
@use \\builtin ipv \let] and \set internally
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.757 2017/02/17 22:40:09 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/03/17
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/03/17
d105 20
@


1.762
log
@use the new \builtin builtin for quoting, everywhere
@
text
@d11094 1
a11094 1
			      \let] " i < 10 " 
d11105 1
a11105 1
		x=$(i=1 ; while { \let] " i < 10 " ; } ; do echo $i ; let ++i ; done ) 
d11111 1
a11111 1
		x=$(( i=1 ; while { \let] " i < 10 " ; } ; do echo $i ; let ++i ; done ) | tr u x ) 
d11119 1
a11119 1
			      \let] " !--i " 
d11129 1
a11129 1
		x=$(i=10 ; until { \let] " !--i " ; } ; do echo $i ; done ) 
d11135 1
a11135 1
		x=$(( i=10 ; until { \let] " !--i " ; } ; do echo $i ; done ) | tr u x ) 
d11511 1
a11511 1
			\set -A c+ -- d e 
d11521 1
a11521 1
		x=$(case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) 
d11529 1
a11529 1
		x=$(( case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) | tr u x ) 
d11750 1
a11750 1
			      \let] " i < 10 " 
d11761 1
a11761 1
		x=$(i=1 ; while { \let] " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) 
d11767 1
a11767 1
		x=$(( i=1 ; while { \let] " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
d11775 1
a11775 1
			      \let] " !--i " 
d11785 1
a11785 1
		x=$(i=10 ; until { \let] " !--i " ; } >&3 ; do echo $i ; done >&3 ) 
d11791 1
a11791 1
		x=$(( i=10 ; until { \let] " !--i " ; } >&3 ; do echo $i ; done >&3 ) | tr u x ) 
@


1.761
log
@Haiku-related ulimit overhaul:
 print ulimit -a with the flag, like most other shells do
 move ulimit-1 regression test to ulimit-2 and exclude on Haiku:
  it can only set the -n and -V limits AFAICT
 document that some OSes (here: Haiku) can only set the soft limits
  (so ulimit -nS 1024 is okay but -S is required)
 check ulimit -c 0, which dot.mkshrc uses, everywhere
  (if it errors out, hack around it or stub it out with MKSH_NO_LIMITS)
@
text
@d247 8
a254 3
	alias local='\typeset'
	function foo {
		local x=$1 y=z
d257 2
a258 1
	foo 'bar - baz'
d261 1
d8284 8
a8291 8
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
d8293 2
a8294 2
	r='\builtin fc -e -'
	type='\builtin whence -v'
d8304 8
a8311 8
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
d8313 2
a8314 2
	r='\builtin fc -e -'
	type='\builtin whence -v'
d8324 8
a8331 8
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
d8333 2
a8334 2
	r='\builtin fc -e -'
	type='\builtin whence -v'
d8391 2
a8392 2
	local='\typeset'
	local='\typeset'
@


1.760
log
@implement typeset -g, From: Martijn Dekker <martijn@@inlv.org>
also deprecate global; thanks!
@
text
@d10228 6
d10235 2
a10236 1
category: !os:syllable
@


1.759
log
@update testsuite accordingly
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/03/11
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/03/11
d8007 1
a8007 1
	Check that global does what typeset is supposed to do
d8011 1
a8011 1
		global -Uui16 arrfoo[*]
d8021 1
a8021 1
		global -Uui16 arrbar[*]
d8795 1
a8795 1
	with the mksh-specific global keyword
d8798 1
a8798 1
		global x
d8804 1
a8804 1
		global y
d8809 1
a8809 1
		global z
d8947 1
a8947 1
	with the mksh-specific global keyword
d8950 1
a8950 1
		global x
d8956 1
a8956 1
		global y
d8961 1
a8961 1
		global z
@


1.758
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/02/18
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/02/18
d6329 1
a6329 1
	touch a
d7061 5
d7075 1
d7080 95
d9325 1
a9325 1
					(( pos )) && print "$dasc|"
d9342 1
a9342 1
		(( hv == 2147483647 )) || print "$dasc|"
d9468 1
a9468 1
					(( pos )) && print "$dasc|"
d9486 1
a9486 1
		(( hv == 2147483647 )) || print "$dasc|"
d9495 7
a9501 7
	00000060  5C 51 5C 52 5C 53 5C 54 - 20 5C 56 5C 57 5C 58 5C  |\Q\R\S\T \V\W\X\|
	00000070  59 5C 5A 5C 5B 5C 5C 5D - 5C 5E 5C 5F 5C 60 07 08  |Y\Z\[\]\^\_\`..|
	00000080  20 20 5C 64 1B 0C 5C 67 - 5C 68 5C 69 5C 6A 5C 6B  |  \d..\g\h\i\j\k|
	00000090  5C 6C 5C 6D 0A 5C 6F 5C - 70 20 5C 71 0D 5C 73 09  |\l\m.\o\p \q.\s.|
	000000A0  0B 5C 77 5C 79 5C 7A 5C - 7B 5C 7C 5C 7D 5C 7E 20  |.\w\y\z\{\|\}\~ |
	000000B0  E2 82 AC 64 20 EF BF BD - 20 12 33 20 78 20 53 20  |...d ... .3 x S |
	000000C0  53 34 0A                -                          |S4.|
d9543 1
a9543 1
					(( pos )) && print "$dasc|"
d9561 1
a9561 1
		(( hv == 2147483647 )) || print "$dasc|"
d9871 1
a9871 1
					(( pos )) && print "$dasc|"
d9889 1
a9889 1
		(( hv == 2147483647 )) || print "$dasc|"
d9959 1
a9959 1
					(( pos )) && print "$dasc|"
d9974 1
a9974 1
		(( hv == 2147483647 )) || print "$dasc|"
d10040 1
a10040 1
					(( pos )) && print "$dasc|"
d10057 1
a10057 1
		(( hv == 2147483647 )) || print "$dasc|"
d10123 1
a10123 1
					(( pos )) && print "$dasc|"
d10137 1
a10137 1
		(( hv == 2147483647 )) || print "$dasc|"
@


1.757
log
@in ${foo=bar}, bar must be scalar context; spotted by Martijn Dekker
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.738 2016/06/26 00:09:32 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R54 2017/02/17
d42 1
a42 1
	@@(#)LEGACY KSH R54 2017/02/17
a94 17
name: selftest-legacy
description:
	Check some things in the LEGACY KSH
category: shell:legacy-yes
stdin:
	set +o emacs
	set +o vi
	[[ "$(set +o) -o" = *"-o emacs -o"* ]] && echo 1=emacs
	[[ "$(set +o) -o" = *"-o vi -o"* ]] && echo 1=vi
	set -o emacs
	set -o vi
	[[ "$(set +o) -o" = *"-o emacs -o"* ]] && echo 2=emacs
	[[ "$(set +o) -o" = *"-o vi -o"* ]] && echo 2=vi
expected-stdout:
	2=emacs
	2=vi
---
a10172 1
category: shell:legacy-no
a10192 1
category: shell:legacy-no
a10212 1
category: shell:legacy-no
a10232 1
category: shell:legacy-no
a10255 1
category: shell:legacy-no
a10276 1
category: shell:legacy-no
a10299 1
category: shell:legacy-no
d10321 1
a10321 1
name: bashiop-5-normal
a10324 1
category: shell:legacy-no
a10333 14
name: bashiop-5-legacy
description:
	Check if GNU bash-like I/O redirection is not parsed
	in lksh as it breaks existing scripts' syntax
category: shell:legacy-yes
stdin:
	:>x; echo 1 "$("$__progname" -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 2 "$("$__progname" -o posix -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 3 "$("$__progname" -o sh -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
expected-stdout:
	1  = bar .
	2  = bar .
	3  = bar .
---
a10569 1
category: shell:legacy-no
a10601 16
name: fd-cloexec-3
description:
	Verify that file descriptors > 2 are not private for LEGACY KSH
category: shell:legacy-yes
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
expected-stdout:
	Fowl
---
@


1.756
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS APEX (Ronald G. Minnich, Elbing Miss, lvaro Jurado)
more from komhs OS/2 port (KO Myung-Hun)
@
text
@d5 1
a5 1
#	      2011, 2012, 2013, 2014, 2015, 2016
d33 1
a33 1
	@@(#)MIRBSD KSH R54 2016/11/11
d42 1
a42 1
	@@(#)LEGACY KSH R54 2016/11/11
d4714 17
@


1.755
log
@fix lazy evaluation with side effects; spotted by ormaaj via IRC
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/11/07
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/11/07
d4951 1
a4951 1
	interpreting the string "010" as octal numer eight (dangerous).
@


1.754
log
@fix error propagation in TAND/TOR constructs, noted by Martijn Dekker

still a bit unsure about the whole XERROK and *xerrok stuff, but
it seems to work
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/10/02
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/10/02
d343 56
@


1.753
log
@fix English (thanks to Andreas Buschka); TIL:
 to start  a start
 to begin  a beginning
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/09/01
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/09/01
d7155 13
@


1.752
log
@outstanding bumps
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/08/25
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/08/25
d11757 1
a11757 1
		echo "begin:	x<$x> y<$y> z<$z> R<$REPLY>"
d11772 1
a11772 1
	begin:	x<1> y<> z<3> R<>
@


1.751
log
@fix refactoro, spotted by Natureshadow; add (working) testsuite for all operators
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/08/12
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/08/12
@


1.750
log
@fixes
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/08/04
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/08/04
d6426 94
@


1.749
log
@fixup a bad OpenBSD reaction on a bug afl showed:

set source to NULL only if the memory backing source is actually reclaimed;
fixes segfault due to NULL(+24) pointer dereference reported by Score_Under
(simplified testcase added; thanks!)
@
text
@d9378 1
a9378 1
expected-stdout: 
@


1.748
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtcs programmable tab completion)
to the manpage
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/08/01
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/08/01
d6420 6
@


1.747
log
@mark some tests as !need-pass due to Perl dependencies
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/07/28
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/07/28
d1794 35
@


1.746
log
@fix (POSIX) errorlevel of . when sourced file has no commands; issue discovered by Natureshadow
@
text
@d10386 2
d10406 2
@


1.745
log
@defer to external rename(1) too
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/07/26
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/07/26
d9329 11
@


1.744
log
@remove fd>9 support in favour of upcoming named file descriptors; bump
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R53 2016/07/25
d42 1
a42 1
	@@(#)LEGACY KSH R53 2016/07/25
@


1.743
log
@add print -A for R53
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/07/24
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/07/24
a10140 23
name: mkshiop-1
description:
	Check for support of more than 9 file descriptors
category: !convfds
stdin:
	read -u10 foo 10<<< bar
	echo x$foo
expected-stdout:
	xbar
---
name: mkshiop-2
description:
	Check for support of more than 9 file descriptors
category: !convfds
stdin:
	exec 12>foo
	print -u12 bar
	echo baz >&12
	cat foo
expected-stdout:
	bar
	baz
---
@


1.742
log
@add a testcase as documentation (why POSIX isnt everything); fix comments
@
text
@d9133 10
@


1.741
log
@rework string pooling; disable our own (rely on compilers)
 if HAVE_STRING_POOLING is set to 1
 if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
 if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d362 12
@


1.740
log
@experimentally use MKSH_CLRTOEOL_STRING instead of lots of spaces followed
by lots of backspaces for many clearing scenarios; requested by tmux user
slagtc on IRC
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/07/12
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/07/12
@


1.739
log
@efficient $(<<<foo) and $(<<EOF  ) implementation, requested by izabera
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/06/25
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/06/25
@


1.738
log
@fix var=<< implementation
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.719 2016/01/14 23:19:12 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/05/17
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/05/17
d2815 22
@


1.737
log
@testcases contributed by carstenh
@
text
@d2616 4
d2645 13
@


1.736
log
@hexdump the NUL away
@
text
@d1314 1
d1356 1
d1405 1
d1536 1
d12044 11
@


1.735
log
@I hate our patch(1), its not NUL-safe
@
text
@d8948 39
a8986 11
	print '<\0144\0344\xDB\u00DB\u20AC\uDB\x40>'
	print '<\x00>'
	print '<\x01>'
	print '<\u0000>'
	print '<\u0001>'
expected-stdout:
	<d@@>
	< >
	<>
	< >
	<>
@


1.734
log
@fix most of the ambiguous ${[prefix] var [op [word]]} corner cases

prodded by izabera and carstenh; resolution is:
 you cant trim a vector in mksh, still (consider ${@@:-1})
 future POSIX will require non-empty word for most ops
 dissolve in order of standard  extension
 dissolve to prefer op over prefix where still necessary, mostly
@
text
@d8955 3607
@


1.733
log
@typo, found by Joerg Schilling
@
text
@d30 1
a30 1
# (2013/12/02 20:39:44) http://openbsd.cs.toronto.edu/cgi-bin/cvsweb/src/regress/bin/ksh/?sortby=date
d1640 1
a1640 1
	Check corner case of trim expansion vs. $# vs. ${#var}
d1648 4
d1657 2
d1662 1
a1662 1
	Check corner case of ${var?} vs. ${#var}
d1664 37
a1700 7
	(exit 0)
	echo $? = ${#?} .
	(exit 111)
	echo $? = ${#?} .
expected-stdout:
	0 = 1 .
	111 = 3 .
a8954 3607
	< >
	<>
	< >
	<>
---
name: print-bksl-c
description:
	Check print builtin's \c escape
stdin:
	print '\ca'; print b
expected-stdout:
	ab
---
name: print-cr
description:
	Check that CR+LF is not collapsed into LF as some MSYS shells wrongly do
stdin:
	echo '#!'"$__progname" >foo
	cat >>foo <<-'EOF'
		print -n -- '220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT\r\n220->> Bitte keine Werbung einwerfen! <<\r\r\n220 Who do you wanna pretend to be today'
		print \?
	EOF
	chmod +x foo
	echo "[$(./foo)]"
	./foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT
	220->> Bitte keine Werbung einwerfen! <<
	220 Who do you wanna pretend to be today?]
	{220-blau.mirbsd.org ESMTP ready at Thu, 25 Jul 2013 15:57:57 GMT}
	{220->> Bitte keine Werbung einwerfen! <<}
	{220 Who do you wanna pretend to be today?}
---
name: print-crlf
description:
	Check that CR+LF is shown and read as-is
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		echo .${#x} #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[.5
	<bar
	>]
	{.5}
	{<bar}
---
name: print-lf
description:
	Check that LF-only is shown and read as-is
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		echo .${#x} #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[.4
	<bar
	>]
	{.4}
	{<bar}
---
name: print-nul-chars
description:
	Check handling of NUL characters for print and COMSUB
stdin:
	x=$(print '<\0>')
	print $(($(print '<\0>' | wc -c))) $(($(print "$x" | wc -c))) \
	    ${#x} "$x" '<\0>'
expected-stdout-pattern:
	/^4 3 2 <> <\0>$/
---
name: print-escapes
description:
	Check backslash expansion by the print builtin
stdin:
	print '\ \!\"\#\$\%\&'\\\''\(\)\*\+\,\-\.\/\0\1\2\3\4\5\6\7\8' \
	    '\9\:\;\<\=\>\?\@@\A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T' \
	    '\U\V\W\X\Y\Z\[\\\]\^\_\`\a\b  \d\e\f\g\h\i\j\k\l\m\n\o\p' \
	    '\q\r\s\t\u\v\w\x\y\z\{\|\}\~' '\u20acd' '\U20acd' '\x123' \
	    '\0x' '\0123' '\01234' | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  5C 20 5C 21 5C 22 5C 23 - 5C 24 5C 25 5C 26 5C 27  |\ \!\"\#\$\%\&\'|
	00000010  5C 28 5C 29 5C 2A 5C 2B - 5C 2C 5C 2D 5C 2E 5C 2F  |\(\)\*\+\,\-\.\/|
	00000020  5C 31 5C 32 5C 33 5C 34 - 5C 35 5C 36 5C 37 5C 38  |\1\2\3\4\5\6\7\8|
	00000030  20 5C 39 5C 3A 5C 3B 5C - 3C 5C 3D 5C 3E 5C 3F 5C  | \9\:\;\<\=\>\?\|
	00000040  40 5C 41 5C 42 5C 43 5C - 44 1B 5C 46 5C 47 5C 48  |@@\A\B\C\D.\F\G\H|
	00000050  5C 49 5C 4A 5C 4B 5C 4C - 5C 4D 5C 4E 5C 4F 5C 50  |\I\J\K\L\M\N\O\P|
	00000060  5C 51 5C 52 5C 53 5C 54 - 20 5C 56 5C 57 5C 58 5C  |\Q\R\S\T \V\W\X\|
	00000070  59 5C 5A 5C 5B 5C 5C 5D - 5C 5E 5C 5F 5C 60 07 08  |Y\Z\[\]\^\_\`..|
	00000080  20 20 5C 64 1B 0C 5C 67 - 5C 68 5C 69 5C 6A 5C 6B  |  \d..\g\h\i\j\k|
	00000090  5C 6C 5C 6D 0A 5C 6F 5C - 70 20 5C 71 0D 5C 73 09  |\l\m.\o\p \q.\s.|
	000000A0  0B 5C 77 5C 79 5C 7A 5C - 7B 5C 7C 5C 7D 5C 7E 20  |.\w\y\z\{\|\}\~ |
	000000B0  E2 82 AC 64 20 EF BF BD - 20 12 33 20 78 20 53 20  |...d ... .3 x S |
	000000C0  53 34 0A                -                          |S4.|
---
name: dollar-doublequoted-strings
description:
	Check that a $ preceding "" is ignored
stdin:
	echo $"Localise me!"
	cat <<<$"Me too!"
	V=X
	aol=aol
	cat <<-$"aol"
		I do not take a $V for a V!
	aol
expected-stdout:
	Localise me!
	Me too!
	I do not take a $V for a V!
---
name: dollar-quoted-strings
description:
	Check backslash expansion by $'' strings
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
	./pfn $'\ \!\"\#\$\%\&\'\(\)\*\+\,\-\.\/ \1\2\3\4\5\6' \
	    $'a\0b' $'a\01b' $'\7\8\9\:\;\<\=\>\?\@@\A\B\C\D\E\F\G\H\I' \
	    $'\J\K\L\M\N\O\P\Q\R\S\T\U1\V\W\X\Y\Z\[\\\]\^\_\`\a\b\d\e' \
	    $'\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u1\v\w\x1\y\z\{\|\}\~ $x' \
	    $'\u20acd' $'\U20acd' $'\x123' $'fn\x0rd' $'\0234' $'\234' \
	    $'\2345' $'\ca' $'\c!' $'\c?' $'\c' $'a\
	b' | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  20 21 22 23 24 25 26 27 - 28 29 2A 2B 2C 2D 2E 2F  | !"#$%&'()*+,-./|
	00000010  20 01 02 03 04 05 06 0A - 61 0A 61 01 62 0A 07 38  | .......a.a.b..8|
	00000020  39 3A 3B 3C 3D 3E 3F 40 - 41 42 43 44 1B 46 47 48  |9:;<=>?@@ABCD.FGH|
	00000030  49 0A 4A 4B 4C 4D 4E 4F - 50 51 52 53 54 01 56 57  |I.JKLMNOPQRST.VW|
	00000040  58 59 5A 5B 5C 5D 5E 5F - 60 07 08 64 1B 0A 0C 67  |XYZ[\]^_`..d...g|
	00000050  68 69 6A 6B 6C 6D 0A 6F - 70 71 0D 73 09 01 0B 77  |hijklm.opq.s...w|
	00000060  01 79 7A 7B 7C 7D 7E 20 - 24 78 0A E2 82 AC 64 0A  |.yz{|}~ $x....d.|
	00000070  EF BF BD 0A C4 A3 0A 66 - 6E 0A 13 34 0A 9C 0A 9C  |.......fn..4....|
	00000080  35 0A 01 0A 01 0A 7F 0A - 02 82 AC 0A 61 0A 62 0A  |5...........a.b.|
---
name: dollar-quotes-in-heredocs-strings
description:
	They are, however, not parsed in here documents, here strings
	(outside of string delimiters) or regular strings, but in
	parameter substitutions.
stdin:
	cat <<EOF
		dollar = strchr(s, '$');	/* ' */
		foo " bar \" baz
	EOF
	cat <<$'a\tb'
	a\tb
	a	b
	cat <<<"dollar = strchr(s, '$');	/* ' */"
	cat <<<'dollar = strchr(s, '\''$'\'');	/* '\'' */'
	x="dollar = strchr(s, '$');	/* ' */"
	cat <<<"$x"
	cat <<<$'a\E[0m\tb'
	unset nl; print -r -- "x${nl:=$'\n'}y"
	echo "1 foo\"bar"
	# cf & HEREDOC
	cat <<EOF
	2 foo\"bar
	EOF
	# probably never reached for here strings?
	cat <<<"3 foo\"bar"
	cat <<<"4 foo\\\"bar"
	cat <<<'5 foo\"bar'
	# old scripts use this (e.g. ncurses)
	echo "^$"
	# make sure this works, outside of quotes
	cat <<<'7'$'\t''.'
expected-stdout:
		dollar = strchr(s, '$');	/* ' */
		foo " bar \" baz
	a\tb
	dollar = strchr(s, '$');	/* ' */
	dollar = strchr(s, '$');	/* ' */
	dollar = strchr(s, '$');	/* ' */
	a[0m	b
	x
	y
	1 foo"bar
	2 foo\"bar
	3 foo"bar
	4 foo\"bar
	5 foo\"bar
	^$
	7	.
---
name: dot-needs-argument
description:
	check Debian #415167 solution: '.' without arguments should fail
stdin:
	"$__progname" -c .
	"$__progname" -c source
expected-exit: e != 0
expected-stderr-pattern:
	/\.: missing argument.*\n.*source: missing argument/
---
name: alias-function-no-conflict
description:
	make aliases not conflict with function definitions
stdin:
	# POSIX function can be defined, but alias overrides it
	alias foo='echo bar'
	foo
	foo() {
		echo baz
	}
	foo
	unset -f foo
	foo 2>/dev/null || echo rab
	# alias overrides ksh function
	alias korn='echo bar'
	korn
	function korn {
		echo baz
	}
	korn
	# alias temporarily overrides POSIX function
	bla() {
		echo bfn
	}
	bla
	alias bla='echo bal'
	bla
	unalias bla
	bla
expected-stdout:
	bar
	bar
	bar
	bar
	bar
	bfn
	bal
	bfn
---
name: bash-function-parens
description:
	ensure the keyword function is ignored when preceding
	POSIX style function declarations (bashism)
stdin:
	mk() {
		echo '#!'"$__progname"
		echo "$1 {"
		echo '	echo "bar='\''$0'\'\"
		echo '}'
		print -r -- "${2:-foo}"
	}
	mk 'function foo' >f-korn
	mk 'foo ()' >f-dash
	mk 'function foo ()' >f-bash
	print '#!'"$__progname"'\nprint -r -- "${0%/f-argh}"' >f-argh
	chmod +x f-*
	u=$(./f-argh)
	x="korn: $(./f-korn)"; echo "${x/@@("$u")/.}"
	x="dash: $(./f-dash)"; echo "${x/@@("$u")/.}"
	x="bash: $(./f-bash)"; echo "${x/@@("$u")/.}"
expected-stdout:
	korn: bar='foo'
	dash: bar='./f-dash'
	bash: bar='./f-bash'
---
name: integer-base-one-1
description:
	check if the use of fake integer base 1 works
stdin:
	set -U
	typeset -Uui16 i0=1# i1=1#
	typeset -i1 o0a=64
	typeset -i1 o1a=0x263A
	typeset -Uui1 o0b=0x7E
	typeset -Uui1 o1b=0xFDD0
	integer px=0xCAFE 'p0=1# ' p1=1# pl=1#f
	echo "in <$i0> <$i1>"
	echo "out <${o0a#1#}|${o0b#1#}> <${o1a#1#}|${o1b#1#}>"
	typeset -Uui1 i0 i1
	echo "pass <$px> <$p0> <$p1> <$pl> <${i0#1#}|${i1#1#}>"
	typeset -Uui16 tv1=1#~ tv2=1# tv3=1# tv4=1# tv5=1# tv6=1# tv7=1# tv8=1#
	echo "specX <${tv1#16#}> <${tv2#16#}> <${tv3#16#}> <${tv4#16#}> <${tv5#16#}> <${tv6#16#}> <${tv7#16#}> <${tv8#16#}>"
	typeset -i1 tv1 tv2 tv3 tv4 tv5 tv6 tv7 tv8
	echo "specW <${tv1#1#}> <${tv2#1#}> <${tv3#1#}> <${tv4#1#}> <${tv5#1#}> <${tv6#1#}> <${tv7#1#}> <${tv8#1#}>"
	typeset -i1 xs1=0xEF7F xs2=0xEF80 xs3=0xFDD0
	echo "specU <${xs1#1#}> <${xs2#1#}> <${xs3#1#}>"
expected-stdout:
	in <16#EFEF> <16#20AC>
	out <@@|~> <|>
	pass <16#cafe> <1# > <1#> <1#f> <|>
	specX <7E> <7F> <EF80> <EF81> <EFC0> <EFC1> <A0> <80>
	specW <~> <> <> <> <> <> <> <>
	specU <> <> <>
---
name: integer-base-one-2a
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#foo
	echo /$x/
expected-stderr-pattern:
	/1#foo: unexpected 'oo'/
expected-exit: e != 0
---
name: integer-base-one-2b
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#
	echo /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2c1
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -U
	integer x=1#
	echo /$x/
expected-stdout:
	/1#/
---
name: integer-base-one-2c2
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set +U
	integer x=1#
	echo /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d1
description:
	check if the use of fake integer base 1 handles octets okay
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid utf-8
expected-stdout:
	/16#efff/
---
name: integer-base-one-2d2
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 2-byte
expected-stdout:
	/16#efc2/
---
name: integer-base-one-2d3
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 2-byte
expected-stdout:
	/16#efef/
---
name: integer-base-one-2d4
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# invalid 3-byte
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d5
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d6
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -U
	typeset -i16 x=1#
	echo /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-3As
description:
	some sample code for hexdumping
	not NUL safe; input lines must be NL terminated
stdin:
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\x${i#16#1}"
		done
		print '\0z'
	} | {
		# integer-base-one-3As
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\..|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  |................|
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |................|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F 80 81 82 83 84 85 86 - 87 88 89 8A 8B 8C 8D 8E  |................|
	000000B0  8F 90 91 92 93 94 95 96 - 97 98 99 9A 9B 9C 9D 9E  |................|
	000000C0  9F A0 A1 A2 A3 A4 A5 A6 - A7 A8 A9 AA AB AC AD AE  |................|
	000000D0  AF B0 B1 B2 B3 B4 B5 B6 - B7 B8 B9 BA BB BC BD BE  |................|
	000000E0  BF C0 C1 C2 C3 C4 C5 C6 - C7 C8 C9 CA CB CC CD CE  |................|
	000000F0  CF D0 D1 D2 D3 D4 D5 D6 - D7 D8 D9 DA DB DC DD DE  |................|
	00000100  DF E0 E1 E2 E3 E4 E5 E6 - E7 E8 E9 EA EB EC ED EE  |................|
	00000110  EF F0 F1 F2 F3 F4 F5 F6 - F7 F8 F9 FA FB FC FD FE  |................|
	00000120  FF 7A 0A                -                          |.z.|
---
name: integer-base-one-3Ws
description:
	some sample code for hexdumping Unicode
	not NUL safe; input lines must be NL terminated
stdin:
	set -U
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
		print ''	# end of range
		print '\0z'		# embedded NUL
	} | {
		# integer-base-one-3Ws
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z7 hv
		typeset -i1 wc=0x0A
		typeset -i lpos
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			lpos=0
			while (( lpos < ${#line} )); do
				wc=1#${line:(lpos++):1}
				if (( (wc < 32) || \
				    ((wc > 126) && (wc < 160)) )); then
					dch=.
				elif (( (wc & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${wc#1#}
				fi
				if (( (pos & 7) == 7 )); then
					dasc=$dasc$dch
					dch=
				elif (( (pos & 7) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				let hv=wc
				print -n "${hv#16#} "
				(( (pos++ & 7) == 3 )) && \
				    print -n -- '- '
				dasc=$dasc$dch
			done
		done
		while (( pos & 7 )); do
			print -n '     '
			(( (pos++ & 7) == 3 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  0048 0065 006C 006C - 006F 002C 0020 0057  |Hello, W|
	00000008  006F 0072 006C 0064 - 0021 005C 000A 3053  |orld!\.|
	00000010  3093 306B 3061 306F - FF01 000A 0001 0002  |...|
	00000018  0003 0004 0005 0006 - 0007 0008 0009 000A  |........|
	00000020  000B 000C 000D 000E - 000F 0010 0011 0012  |........|
	00000028  0013 0014 0015 0016 - 0017 0018 0019 001A  |........|
	00000030  001B 001C 001D 001E - 001F 0020 0021 0022  |..... !"|
	00000038  0023 0024 0025 0026 - 0027 0028 0029 002A  |#$%&'()*|
	00000040  002B 002C 002D 002E - 002F 0030 0031 0032  |+,-./012|
	00000048  0033 0034 0035 0036 - 0037 0038 0039 003A  |3456789:|
	00000050  003B 003C 003D 003E - 003F 0040 0041 0042  |;<=>?@@AB|
	00000058  0043 0044 0045 0046 - 0047 0048 0049 004A  |CDEFGHIJ|
	00000060  004B 004C 004D 004E - 004F 0050 0051 0052  |KLMNOPQR|
	00000068  0053 0054 0055 0056 - 0057 0058 0059 005A  |STUVWXYZ|
	00000070  005B 005C 005D 005E - 005F 0060 0061 0062  |[\]^_`ab|
	00000078  0063 0064 0065 0066 - 0067 0068 0069 006A  |cdefghij|
	00000080  006B 006C 006D 006E - 006F 0070 0071 0072  |klmnopqr|
	00000088  0073 0074 0075 0076 - 0077 0078 0079 007A  |stuvwxyz|
	00000090  007B 007C 007D 007E - 007F 0080 0081 0082  |{|}~....|
	00000098  0083 0084 0085 0086 - 0087 0088 0089 008A  |........|
	000000A0  008B 008C 008D 008E - 008F 0090 0091 0092  |........|
	000000A8  0093 0094 0095 0096 - 0097 0098 0099 009A  |........|
	000000B0  009B 009C 009D 009E - 009F 00A0 00A1 00A2  |.....|
	000000B8  00A3 00A4 00A5 00A6 - 00A7 00A8 00A9 00AA  ||
	000000C0  00AB 00AC 00AD 00AE - 00AF 00B0 00B1 00B2  ||
	000000C8  00B3 00B4 00B5 00B6 - 00B7 00B8 00B9 00BA  ||
	000000D0  00BB 00BC 00BD 00BE - 00BF 00C0 00C1 00C2  ||
	000000D8  00C3 00C4 00C5 00C6 - 00C7 00C8 00C9 00CA  ||
	000000E0  00CB 00CC 00CD 00CE - 00CF 00D0 00D1 00D2  ||
	000000E8  00D3 00D4 00D5 00D6 - 00D7 00D8 00D9 00DA  ||
	000000F0  00DB 00DC 00DD 00DE - 00DF 00E0 00E1 00E2  ||
	000000F8  00E3 00E4 00E5 00E6 - 00E7 00E8 00E9 00EA  ||
	00000100  00EB 00EC 00ED 00EE - 00EF 00F0 00F1 00F2  ||
	00000108  00F3 00F4 00F5 00F6 - 00F7 00F8 00F9 00FA  ||
	00000110  00FB 00FC 00FD 00FE - 00FF 000A EFFF 000A  |..|
	00000118  EFC2 000A EFEF EFBF - EFC0 000A EFC0 EF80  |..|
	00000120  000A EFE0 EF80 EF80 - 000A FFFD EFEF EFBF  |..|
	00000128  EFBE EFEF EFBF EFBF - 000A 007A 000A       |.z.|
---
name: integer-base-one-3Ar
description:
	some sample code for hexdumping; NUL and binary safe
stdin:
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\x${i#16#1}"
		done
		print '\0z'
	} | {
		# integer-base-one-3Ar
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv=2147483647
		dasc=
		if read -arN -1 line; then
			typeset -i1 line
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line[i-1]#1#}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
		fi
		while (( pos & 15 )); do
			print -n '   '
			(( (pos++ & 15) == 7 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\..|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  |................|
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |................|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F 80 81 82 83 84 85 86 - 87 88 89 8A 8B 8C 8D 8E  |................|
	000000B0  8F 90 91 92 93 94 95 96 - 97 98 99 9A 9B 9C 9D 9E  |................|
	000000C0  9F A0 A1 A2 A3 A4 A5 A6 - A7 A8 A9 AA AB AC AD AE  |................|
	000000D0  AF B0 B1 B2 B3 B4 B5 B6 - B7 B8 B9 BA BB BC BD BE  |................|
	000000E0  BF C0 C1 C2 C3 C4 C5 C6 - C7 C8 C9 CA CB CC CD CE  |................|
	000000F0  CF D0 D1 D2 D3 D4 D5 D6 - D7 D8 D9 DA DB DC DD DE  |................|
	00000100  DF E0 E1 E2 E3 E4 E5 E6 - E7 E8 E9 EA EB EC ED EE  |................|
	00000110  EF F0 F1 F2 F3 F4 F5 F6 - F7 F8 F9 FA FB FC FD FE  |................|
	00000120  FF 00 7A 0A             -                          |..z.|
---
name: integer-base-one-3Wr
description:
	some sample code for hexdumping Unicode; NUL and binary safe
stdin:
	set -U
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
		print ''	# end of range
		print '\0z'		# embedded NUL
	} | {
		# integer-base-one-3Wr
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z7 hv=2147483647
		dasc=
		if read -arN -1 line; then
			typeset -i1 line
			i=0
			while (( i < ${#line[*]} )); do
				hv=${line[i++]}
				if (( (hv < 32) || \
				    ((hv > 126) && (hv < 160)) )); then
					dch=.
				elif (( (hv & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${line[i-1]#1#}
				fi
				if (( (pos & 7) == 7 )); then
					dasc=$dasc$dch
					dch=
				elif (( (pos & 7) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				(( (pos++ & 7) == 3 )) && \
				    print -n -- '- '
				dasc=$dasc$dch
			done
		fi
		while (( pos & 7 )); do
			print -n '     '
			(( (pos++ & 7) == 3 )) && print -n -- '- '
		done
		(( hv == 2147483647 )) || print "$dasc|"
	}
expected-stdout:
	00000000  0048 0065 006C 006C - 006F 002C 0020 0057  |Hello, W|
	00000008  006F 0072 006C 0064 - 0021 005C 000A 3053  |orld!\.|
	00000010  3093 306B 3061 306F - FF01 000A 0001 0002  |...|
	00000018  0003 0004 0005 0006 - 0007 0008 0009 000A  |........|
	00000020  000B 000C 000D 000E - 000F 0010 0011 0012  |........|
	00000028  0013 0014 0015 0016 - 0017 0018 0019 001A  |........|
	00000030  001B 001C 001D 001E - 001F 0020 0021 0022  |..... !"|
	00000038  0023 0024 0025 0026 - 0027 0028 0029 002A  |#$%&'()*|
	00000040  002B 002C 002D 002E - 002F 0030 0031 0032  |+,-./012|
	00000048  0033 0034 0035 0036 - 0037 0038 0039 003A  |3456789:|
	00000050  003B 003C 003D 003E - 003F 0040 0041 0042  |;<=>?@@AB|
	00000058  0043 0044 0045 0046 - 0047 0048 0049 004A  |CDEFGHIJ|
	00000060  004B 004C 004D 004E - 004F 0050 0051 0052  |KLMNOPQR|
	00000068  0053 0054 0055 0056 - 0057 0058 0059 005A  |STUVWXYZ|
	00000070  005B 005C 005D 005E - 005F 0060 0061 0062  |[\]^_`ab|
	00000078  0063 0064 0065 0066 - 0067 0068 0069 006A  |cdefghij|
	00000080  006B 006C 006D 006E - 006F 0070 0071 0072  |klmnopqr|
	00000088  0073 0074 0075 0076 - 0077 0078 0079 007A  |stuvwxyz|
	00000090  007B 007C 007D 007E - 007F 0080 0081 0082  |{|}~....|
	00000098  0083 0084 0085 0086 - 0087 0088 0089 008A  |........|
	000000A0  008B 008C 008D 008E - 008F 0090 0091 0092  |........|
	000000A8  0093 0094 0095 0096 - 0097 0098 0099 009A  |........|
	000000B0  009B 009C 009D 009E - 009F 00A0 00A1 00A2  |.....|
	000000B8  00A3 00A4 00A5 00A6 - 00A7 00A8 00A9 00AA  ||
	000000C0  00AB 00AC 00AD 00AE - 00AF 00B0 00B1 00B2  ||
	000000C8  00B3 00B4 00B5 00B6 - 00B7 00B8 00B9 00BA  ||
	000000D0  00BB 00BC 00BD 00BE - 00BF 00C0 00C1 00C2  ||
	000000D8  00C3 00C4 00C5 00C6 - 00C7 00C8 00C9 00CA  ||
	000000E0  00CB 00CC 00CD 00CE - 00CF 00D0 00D1 00D2  ||
	000000E8  00D3 00D4 00D5 00D6 - 00D7 00D8 00D9 00DA  ||
	000000F0  00DB 00DC 00DD 00DE - 00DF 00E0 00E1 00E2  ||
	000000F8  00E3 00E4 00E5 00E6 - 00E7 00E8 00E9 00EA  ||
	00000100  00EB 00EC 00ED 00EE - 00EF 00F0 00F1 00F2  ||
	00000108  00F3 00F4 00F5 00F6 - 00F7 00F8 00F9 00FA  ||
	00000110  00FB 00FC 00FD 00FE - 00FF 000A EFFF 000A  |..|
	00000118  EFC2 000A EFEF EFBF - EFC0 000A EFC0 EF80  |..|
	00000120  000A EFE0 EF80 EF80 - 000A FFFD EFEF EFBF  |..|
	00000128  EFBE EFEF EFBF EFBF - 000A 0000 007A 000A  |..z.|
---
name: integer-base-one-4
description:
	Check if ksh93-style base-one integers work
category: !smksh
stdin:
	set -U
	echo 1 $(('a'))
	(echo 2f $(('aa'))) 2>&1 | sed "s/^[^']*'/2p '/"
	echo 3 $((''))
	x="'a'"
	echo "4 <$x>"
	echo 5 $(($x))
	echo 6 $((x))
expected-stdout:
	1 97
	2p 'aa': multi-character character constant
	3 8230
	4 <'a'>
	5 97
	6 97
---
name: integer-base-one-5A
description:
	Check to see that were NUL and Unicode safe
stdin:
	set +U
	print 'a\0b\xfdz' >x
	read -a y <x
	set -U
	typeset -Uui16 y
	print ${y[*]} .
expected-stdout:
	16#61 16#0 16#62 16#FD 16#7A .
---
name: integer-base-one-5W
description:
	Check to see that were NUL and Unicode safe
stdin:
	set -U
	print 'a\0bc' >x
	read -a y <x
	set +U
	typeset -Uui16 y
	print ${y[*]} .
expected-stdout:
	16#61 16#0 16#62 16#20AC 16#63 .
---
name: ulimit-1
description:
	Check if we can use a specific syntax idiom for ulimit
category: !os:syllable
stdin:
	if ! x=$(ulimit -d) || [[ $x = unknown ]]; then
		#echo expected to fail on this OS
		echo okay
	else
		ulimit -dS $x && echo okay
	fi
expected-stdout:
	okay
---
name: redir-1
description:
	Check some of the most basic invariants of I/O redirection
stdin:
	i=0
	function d {
		print o$i.
		print -u2 e$((i++)).
	}
	d >a 2>b
	echo =1=
	cat a
	echo =2=
	cat b
	echo =3=
	d 2>&1 >c
	echo =4=
	cat c
	echo =5=
expected-stdout:
	=1=
	o0.
	=2=
	e0.
	=3=
	e1.
	=4=
	o1.
	=5=
---
name: bashiop-1
description:
	Check if GNU bash-like I/O redirection works
	Part 1: this is also supported by GNU bash
category: shell:legacy-no
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-2a
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
category: shell:legacy-no
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3&>foo
	echo ===
	cat foo
expected-stdout:
	ras
	===
	dwa
	tri
---
name: bashiop-2b
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
category: shell:legacy-no
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3>foo &>&3
	echo ===
	cat foo
expected-stdout:
	===
	ras
	dwa
	tri
---
name: bashiop-2c
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is supported by GNU bash 4 only
category: shell:legacy-no
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	mir
	ras
	dwa
---
name: bashiop-3a
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 1: this is also supported by GNU bash
category: shell:legacy-no
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	===
	mir
expected-stderr-pattern: /.*: can't (create|overwrite) .*/
---
name: bashiop-3b
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 2: this is *not* supported by GNU bash
category: shell:legacy-no
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>|foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-4
description:
	Check if GNU bash-like I/O redirection works
	Part 4: this is also supported by GNU bash,
	but failed in some mksh versions
category: shell:legacy-no
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	function blubb {
		[[ -e bar ]] && threeout "$bf" &>foo
	}
	blubb
	echo -n >bar
	blubb
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-5-normal
description:
	Check if GNU bash-like I/O redirection is only supported
	in !POSIX !sh mode as it breaks existing scripts' syntax
category: shell:legacy-no
stdin:
	:>x; echo 1 "$("$__progname" -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 2 "$("$__progname" -o posix -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 3 "$("$__progname" -o sh -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
expected-stdout:
	1  = foo echo bar .
	2  = bar .
	3  = bar .
---
name: bashiop-5-legacy
description:
	Check if GNU bash-like I/O redirection is not parsed
	in lksh as it breaks existing scripts' syntax
category: shell:legacy-yes
stdin:
	:>x; echo 1 "$("$__progname" -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 2 "$("$__progname" -o posix -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
	:>x; echo 3 "$("$__progname" -o sh -c 'echo foo>/dev/null&>x echo bar')" = "$(<x)" .
expected-stdout:
	1  = bar .
	2  = bar .
	3  = bar .
---
name: mkshiop-1
description:
	Check for support of more than 9 file descriptors
category: !convfds
stdin:
	read -u10 foo 10<<< bar
	echo x$foo
expected-stdout:
	xbar
---
name: mkshiop-2
description:
	Check for support of more than 9 file descriptors
category: !convfds
stdin:
	exec 12>foo
	print -u12 bar
	echo baz >&12
	cat foo
expected-stdout:
	bar
	baz
---
name: oksh-eval
description:
	Check expansions.
stdin:
	a=
	for n in ${a#*=}; do echo 1hu ${n} .; done
	for n in "${a#*=}"; do echo 1hq ${n} .; done
	for n in ${a##*=}; do echo 2hu ${n} .; done
	for n in "${a##*=}"; do echo 2hq ${n} .; done
	for n in ${a%=*}; do echo 1pu ${n} .; done
	for n in "${a%=*}"; do echo 1pq ${n} .; done
	for n in ${a%%=*}; do echo 2pu ${n} .; done
	for n in "${a%%=*}"; do echo 2pq ${n} .; done
expected-stdout:
	1hq .
	2hq .
	1pq .
	2pq .
---
name: oksh-and-list-error-1
description:
	Test exit status of rightmost element in 2 element && list in -e mode
stdin:
	true && false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-and-list-error-2
description:
	Test exit status of rightmost element in 3 element && list in -e mode
stdin:
	true && true && false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-or-list-error-1
description:
	Test exit status of || list in -e mode
stdin:
	false || false
	echo "should not print"
arguments: !-e!
expected-exit: e != 0
---
name: oksh-longline-crash
description:
	This used to cause a core dump
stdin:
	ulimit -c 0
	deplibs="-lz -lpng /usr/local/lib/libjpeg.la -ltiff -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -ltiff -ljpeg -lz -lpng -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk_pixbuf.la -lz -lpng /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -lz -lz /usr/local/lib/libxml.la -lz -lz -lz /usr/local/lib/libxml.la -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lglib -lgmodule /usr/local/lib/libgdk.la /usr/local/lib/libgtk.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade.la -lz -lz -lz /usr/local/lib/libxml.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile /usr/local/lib/libesd.la -lm -lz /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lz /usr/local/lib/libgdk_imlib.la /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lz -lungif -lz -ljpeg -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade-gnome.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib"
	specialdeplibs="-lgnomeui -lart_lgpl -lgdk_imlib -ltiff -ljpeg -lungif -lpng -lz -lSM -lICE -lgtk -lgdk -lgmodule -lintl -lXext -lX11 -lgnome -lgnomesupport -lesd -laudiofile -lm -lglib"
	for deplib in $deplibs; do
		case $deplib in
		-L*)
			new_libs="$deplib $new_libs"
			;;
		*)
			case " $specialdeplibs " in
			*" $deplib "*)
				new_libs="$deplib $new_libs";;
			esac
			;;
		esac
	done
---
name: oksh-seterror-1
description:
	The -e flag should be ignored when executing a compound list
	followed by an if statement.
stdin:
	if true; then false && false; fi
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-2
description:
	The -e flag should be ignored when executing a compound list
	followed by an if statement.
stdin:
	if true; then if true; then false && false; fi; fi
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-3
description:
	The -e flag should be ignored when executing a compound list
	followed by an elif statement.
stdin:
	if true; then :; elif true; then false && false; fi
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-4
description:
	The -e flag should be ignored when executing a pipeline
	beginning with '!'
stdin:
	for i in 1 2 3
	do
		false && false
		true || false
	done
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-5
description:
	The -e flag should be ignored when executing a pipeline
	beginning with '!'
stdin:
	! true | false
	true
arguments: !-e!
expected-exit: e == 0
---
name: oksh-seterror-6
description:
	When trapping ERR and EXIT, both traps should run in -e mode
	when an error occurs.
stdin:
	trap 'echo EXIT' EXIT
	trap 'echo ERR' ERR
	set -e
	false
	echo DONE
	exit 0
arguments: !-e!
expected-exit: e != 0
expected-stdout:
	ERR
	EXIT
---
name: oksh-seterror-7
description:
	The -e flag within a command substitution should be honored
stdin:
	echo $( set -e; false; echo foo )
arguments: !-e!
expected-stdout:
	
---
name: oksh-input-comsub
description:
	A command substitution using input redirection should exit with
	failure if the input file does not exist.
stdin:
	var=$(< non-existent)
expected-exit: e != 0
expected-stderr-pattern: /non-existent/
---
name: oksh-empty-for-list
description:
	A for list which expands to zero items should not execute the body.
stdin:
	set foo bar baz ; for out in ; do echo $out ; done
---
name: oksh-varfunction-mod1
description:
	(Inspired by PR 2450 on OpenBSD.) Calling
		FOO=bar f
	where f is a ksh style function, should not set FOO in the current
	env. If f is a Bourne style function, FOO should be set. Furthermore,
	the function should receive a correct value of FOO. However, differing
	from oksh, setting FOO in the function itself must change the value in
	setting FOO in the function itself should not change the value in
	global environment.
stdin:
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.$PATHSEP$PATH
	function k {
		if [ x$FOO != xbar ]; then
			echo 1
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 2
			return 1;
		fi
		FOO=foo
		return 0
	}
	b () {
		if [ x$FOO != xbar ]; then
			echo 3
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 4
			return 1;
		fi
		FOO=foo
		return 0
	}
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != x ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xfoo ]; then
		exit 1
	fi
	FOO=barbar
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbarbar ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xfoo ]; then
		exit 1
	fi
---
name: fd-cloexec-1
description:
	Verify that file descriptors > 2 are private for Korn shells
	AT&T ksh93 does this still, which means we must keep it as well
category: shell:legacy-no
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
expected-exit: e != 0
expected-stderr-pattern:
	/E: open /
---
name: fd-cloexec-2
description:
	Verify that file descriptors > 2 are not private for POSIX shells
	See Debian Bug #154540, Closes: #499139
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	test -n "$POSH_VERSION" || set -o posix
	exec 9>&1
	./cld
expected-stdout:
	Fowl
---
name: fd-cloexec-3
description:
	Verify that file descriptors > 2 are not private for LEGACY KSH
category: shell:legacy-yes
stdin:
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
expected-stdout:
	Fowl
---
name: comsub-1a
description:
	COMSUB are now parsed recursively, so this works
	see also regression-6: matching parenthess bug
	Fails on: pdksh bash2 bash3 zsh
	Passes on: bash4 ksh93 mksh(20110313+)
stdin:
	echo 1 $(case 1 in (1) echo yes;; (2) echo no;; esac) .
	echo 2 $(case 1 in 1) echo yes;; 2) echo no;; esac) .
	TEST=1234; echo 3 ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)} .
	TEST=5678; echo 4 ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)} .
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo 5 ${a[0]} .
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo 6 ${a[0]} .
expected-stdout:
	1 yes .
	2 yes .
	3 234 .
	4 678 .
	5 1 .
	6 1 .
---
name: comsub-1b
description:
	COMSUB are now parsed recursively, so this works
	Fails on: pdksh bash2 bash3 bash4 zsh
	Passes on: ksh93 mksh(20110313+)
stdin:
	echo 1 $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10)) .
	echo 2 $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20)) .
	(( a = $(case 1 in (1) echo 1;; (*) echo 2;; esac) )); echo 3 $a .
	(( a = $(case 1 in 1) echo 1;; *) echo 2;; esac) )); echo 4 $a .
	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo 5 ${a[0]} .
	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo 6 ${a[0]} .
expected-stdout:
	1 11 .
	2 21 .
	3 1 .
	4 1 .
	5 11 .
	6 21 .
---
name: comsub-2
description:
	RedHat BZ#496791  another case of missing recursion
	in parsing COMSUB expressions
	Fails on: pdksh bash2 bash3 bash4 zsh
	Passes on: ksh93 mksh(20110305+)
	 bash[34] seem to choke on comment ending with backslash-newline
stdin:
	# a comment with " ' \
	x=$(
	echo yes
	# a comment with " ' \
	)
	echo $x
expected-stdout:
	yes
---
name: comsub-3
description:
	Extended test for COMSUB explaining why a recursive parser
	is a must (a non-recursive parser cannot pass all three of
	these test cases, especially the # is difficult)
stdin:
	print '#!'"$__progname"'\necho 1234' >id; chmod +x id; PATH=.$PATHSEP$PATH
	echo $(typeset -i10 x=16#20; echo $x)
	echo $(typeset -Uui16 x=16#$(id -u)
	) .
	echo $(c=1; d=1
	typeset -Uui16 a=36#foo; c=2
	typeset -Uui16 b=36 #foo; d=2
	echo $a $b $c $d)
expected-stdout:
	32
	.
	16#4F68 16#24 2 1
---
name: comsub-4
description:
	Check the tree dump functions for !MKSH_SMALL functionality
category: !smksh
stdin:
	x() { case $1 in u) echo x ;;& *) echo $1 ;; esac; }
	typeset -f x
expected-stdout:
	x() {
		case $1 in
		(u)
			echo x 
			;|
		(*)
			echo $1 
			;;
		esac 
	} 
---
name: comsub-5
description:
	Check COMSUB works with aliases (does not expand them twice)
stdin:
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
	alias echo='echo a'
	foo() {
		./pfn "$(echo foo)"
	}
	./pfn "$(echo b)"
	typeset -f foo
expected-stdout:
	a b
	foo() {
		./pfn "$(echo foo )" 
	} 
---
name: comsub-torture
description:
	Check the tree dump functions work correctly
stdin:
	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
	while IFS= read -r line; do
		if [[ $line = '#1' ]]; then
			lastf=0
			continue
		elif [[ $line = EOFN* ]]; then
			fbody=$fbody$'\n'$line
			continue
		elif [[ $line != '#'* ]]; then
			fbody=$fbody$'\n\t'$line
			continue
		fi
		if (( lastf )); then
			x="inline_${nextf}() {"$fbody$'\n}\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
		fi
		lastf=1
		fbody=
		nextf=${line#?}
	done <<'EOD'
	#1
	#TCOM
	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	#TPAREN_TPIPE_TLIST
	(echo $foo  |  tr -dc 0-9; echo)
	#TAND_TOR
	cmd  &&  echo ja  ||  echo nein
	#TSELECT
	select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	#TFOR_TTIME
	time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	#TCASE
	case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	#TIF_TBANG_TDBRACKET_TELIF
	if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	#TWHILE
	i=1; while (( i < 10 )); do echo $i; let ++i; done
	#TUNTIL
	i=10; until  (( !--i )) ; do echo $i; done
	#TCOPROC
	cat  *  |&  ls
	#TFUNCT_TBRACE_TASYNC
	function  korn  {  echo eins; echo zwei ;  }
	bourne  ()  {  logger *  &  }
	#IOREAD_IOCAT
	tr  x  u  0<foo  >>bar
	#IOWRITE_IOCLOB_IOHERE_noIOSKIP
	cat  >|bar  <<'EOFN'
	foo
	EOFN
	#IOWRITE_noIOCLOB_IOHERE_IOSKIP
	cat  1>bar  <<-EOFI
	foo
	EOFI
	#IORDWR_IODUP
	sh  1<>/dev/console  0<&1  2>&1
	#COMSUB_EXPRSUB_FUNSUB_VALSUB
	echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	#QCHAR_OQUOTE_CQUOTE
	echo fo\ob\"a\`r\'b\$az
	echo "fo\ob\"a\`r\'b\$az"
	echo 'fo\ob\"a\`r'\''b\$az'
	#OSUBST_CSUBST_OPAT_SPAT_CPAT
	[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	#heredoc_closed
	x=$(cat <<EOFN
	note there must be no space between EOFN and )
	EOFN); echo $x
	#heredoc_space
	x=$(cat <<EOFN\ 
	note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	#patch_motd
	x=$(sysctl -n kern.version | sed 1q)
	[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
	    ed -s /etc/motd 2>&1 <<-EOF
		1,/^\$/d
		0a
			$x
	
		.
		wq
	EOF)" = @@(?) ]] && rm -f /etc/motd
	if [[ ! -s /etc/motd ]]; then
		install -c -o root -g wheel -m 664 /dev/null /etc/motd
		print -- "$x\n" >/etc/motd
	fi
	#wdarrassign
	case x in
	x) a+=b; c+=(d e)
	esac
	#0
	EOD
expected-stdout:
	inline_TCOM() {
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	}
	inline_TCOM() {
		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" 
	} 
	function comsub_TCOM { x=$(
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	); }
	function comsub_TCOM {
		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) 
	} 
	function reread_TCOM { x=$((
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4"
	)|tr u x); }
	function reread_TCOM {
		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" ) | tr u x ) 
	} 
	inline_TPAREN_TPIPE_TLIST() {
		(echo $foo  |  tr -dc 0-9; echo)
	}
	inline_TPAREN_TPIPE_TLIST() {
		( echo $foo | tr -dc 0-9 
		  echo ) 
	} 
	function comsub_TPAREN_TPIPE_TLIST { x=$(
		(echo $foo  |  tr -dc 0-9; echo)
	); }
	function comsub_TPAREN_TPIPE_TLIST {
		x=$(( echo $foo | tr -dc 0-9 ; echo ) ) 
	} 
	function reread_TPAREN_TPIPE_TLIST { x=$((
		(echo $foo  |  tr -dc 0-9; echo)
	)|tr u x); }
	function reread_TPAREN_TPIPE_TLIST {
		x=$(( ( echo $foo | tr -dc 0-9 ; echo ) ) | tr u x ) 
	} 
	inline_TAND_TOR() {
		cmd  &&  echo ja  ||  echo nein
	}
	inline_TAND_TOR() {
		cmd && echo ja || echo nein 
	} 
	function comsub_TAND_TOR { x=$(
		cmd  &&  echo ja  ||  echo nein
	); }
	function comsub_TAND_TOR {
		x=$(cmd && echo ja || echo nein ) 
	} 
	function reread_TAND_TOR { x=$((
		cmd  &&  echo ja  ||  echo nein
	)|tr u x); }
	function reread_TAND_TOR {
		x=$(( cmd && echo ja || echo nein ) | tr u x ) 
	} 
	inline_TSELECT() {
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	}
	inline_TSELECT() {
		select file in * 
		do
			echo "<$file>" 
			break 
		done 
	} 
	function comsub_TSELECT { x=$(
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	); }
	function comsub_TSELECT {
		x=$(select file in * ; do echo "<$file>" ; break ; done ) 
	} 
	function reread_TSELECT { x=$((
		select  file  in  *;  do  echo  "<$file>" ;  break ;  done
	)|tr u x); }
	function reread_TSELECT {
		x=$(( select file in * ; do echo "<$file>" ; break ; done ) | tr u x ) 
	} 
	inline_TFOR_TTIME() {
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	}
	inline_TFOR_TTIME() {
		time for i in {1,2,3} 
		do
			echo $i 
		done 
	} 
	function comsub_TFOR_TTIME { x=$(
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	); }
	function comsub_TFOR_TTIME {
		x=$(time for i in {1,2,3} ; do echo $i ; done ) 
	} 
	function reread_TFOR_TTIME { x=$((
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
	)|tr u x); }
	function reread_TFOR_TTIME {
		x=$(( time for i in {1,2,3} ; do echo $i ; done ) | tr u x ) 
	} 
	inline_TCASE() {
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	}
	inline_TCASE() {
		case $foo in
		(1)
			echo eins 
			;&
		(2)
			echo zwei 
			;|
		(*)
			echo kann net bis drei zhlen 
			;;
		esac 
	} 
	function comsub_TCASE { x=$(
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	); }
	function comsub_TCASE {
		x=$(case $foo in (1) echo eins  ;& (2) echo zwei  ;| (*) echo kann net bis drei zhlen  ;; esac ) 
	} 
	function reread_TCASE { x=$((
		case  $foo  in  1)  echo eins;& 2) echo zwei  ;| *) echo kann net bis drei zhlen;;  esac
	)|tr u x); }
	function reread_TCASE {
		x=$(( case $foo in (1) echo eins  ;& (2) echo zwei  ;| (*) echo kann net bis drei zhlen  ;; esac ) | tr u x ) 
	} 
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	}
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if ! [[ 1 = 1 ]] 
		then
			echo eins 
		elif [[ 1 = 2 ]] 
		then
			echo zwei 
		else
			echo drei 
		fi 
	} 
	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	); }
	function comsub_TIF_TBANG_TDBRACKET_TELIF {
		x=$(if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) 
	} 
	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
		if  !  [[  1  =  1  ]]  ;  then  echo eins;  elif [[ 1 = 2 ]]; then echo zwei  ;else echo drei; fi
	)|tr u x); }
	function reread_TIF_TBANG_TDBRACKET_TELIF {
		x=$(( if ! [[ 1 = 1 ]] ; then echo eins ; elif [[ 1 = 2 ]] ; then echo zwei ; else echo drei ; fi ) | tr u x ) 
	} 
	inline_TWHILE() {
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	}
	inline_TWHILE() {
		i=1 
		while {
			      \let] " i < 10 " 
		      } 
		do
			echo $i 
			let ++i 
		done 
	} 
	function comsub_TWHILE { x=$(
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	); }
	function comsub_TWHILE {
		x=$(i=1 ; while { \let] " i < 10 " ; } ; do echo $i ; let ++i ; done ) 
	} 
	function reread_TWHILE { x=$((
		i=1; while (( i < 10 )); do echo $i; let ++i; done
	)|tr u x); }
	function reread_TWHILE {
		x=$(( i=1 ; while { \let] " i < 10 " ; } ; do echo $i ; let ++i ; done ) | tr u x ) 
	} 
	inline_TUNTIL() {
		i=10; until  (( !--i )) ; do echo $i; done
	}
	inline_TUNTIL() {
		i=10 
		until {
			      \let] " !--i " 
		      } 
		do
			echo $i 
		done 
	} 
	function comsub_TUNTIL { x=$(
		i=10; until  (( !--i )) ; do echo $i; done
	); }
	function comsub_TUNTIL {
		x=$(i=10 ; until { \let] " !--i " ; } ; do echo $i ; done ) 
	} 
	function reread_TUNTIL { x=$((
		i=10; until  (( !--i )) ; do echo $i; done
	)|tr u x); }
	function reread_TUNTIL {
		x=$(( i=10 ; until { \let] " !--i " ; } ; do echo $i ; done ) | tr u x ) 
	} 
	inline_TCOPROC() {
		cat  *  |&  ls
	}
	inline_TCOPROC() {
		cat * |& 
		ls 
	} 
	function comsub_TCOPROC { x=$(
		cat  *  |&  ls
	); }
	function comsub_TCOPROC {
		x=$(cat * |&  ls ) 
	} 
	function reread_TCOPROC { x=$((
		cat  *  |&  ls
	)|tr u x); }
	function reread_TCOPROC {
		x=$(( cat * |&  ls ) | tr u x ) 
	} 
	inline_TFUNCT_TBRACE_TASYNC() {
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	}
	inline_TFUNCT_TBRACE_TASYNC() {
		function korn {
			echo eins 
			echo zwei 
		} 
		bourne() {
			logger * & 
		} 
	} 
	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	); }
	function comsub_TFUNCT_TBRACE_TASYNC {
		x=$(function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) 
	} 
	function reread_TFUNCT_TBRACE_TASYNC { x=$((
		function  korn  {  echo eins; echo zwei ;  }
		bourne  ()  {  logger *  &  }
	)|tr u x); }
	function reread_TFUNCT_TBRACE_TASYNC {
		x=$(( function korn { echo eins ; echo zwei ; } ; bourne() { logger * &  } ) | tr u x ) 
	} 
	inline_IOREAD_IOCAT() {
		tr  x  u  0<foo  >>bar
	}
	inline_IOREAD_IOCAT() {
		tr x u <foo >>bar 
	} 
	function comsub_IOREAD_IOCAT { x=$(
		tr  x  u  0<foo  >>bar
	); }
	function comsub_IOREAD_IOCAT {
		x=$(tr x u <foo >>bar ) 
	} 
	function reread_IOREAD_IOCAT { x=$((
		tr  x  u  0<foo  >>bar
	)|tr u x); }
	function reread_IOREAD_IOCAT {
		x=$(( tr x u <foo >>bar ) | tr u x ) 
	} 
	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	}
	inline_IOWRITE_IOCLOB_IOHERE_noIOSKIP() {
		cat >|bar <<"EOFN" 
		foo
	EOFN
	
	} 
	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$(
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	); }
	function comsub_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
		x=$(cat >|bar <<"EOFN" 
		foo
	EOFN
	) 
	} 
	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP { x=$((
		cat  >|bar  <<'EOFN'
		foo
	EOFN
	)|tr u x); }
	function reread_IOWRITE_IOCLOB_IOHERE_noIOSKIP {
		x=$(( cat >|bar <<"EOFN" 
		foo
	EOFN
	) | tr u x ) 
	} 
	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
		cat  1>bar  <<-EOFI
		foo
		EOFI
	}
	inline_IOWRITE_noIOCLOB_IOHERE_IOSKIP() {
		cat >bar <<-EOFI 
	foo
	EOFI
	
	} 
	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$(
		cat  1>bar  <<-EOFI
		foo
		EOFI
	); }
	function comsub_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
		x=$(cat >bar <<-EOFI 
	foo
	EOFI
	) 
	} 
	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP { x=$((
		cat  1>bar  <<-EOFI
		foo
		EOFI
	)|tr u x); }
	function reread_IOWRITE_noIOCLOB_IOHERE_IOSKIP {
		x=$(( cat >bar <<-EOFI 
	foo
	EOFI
	) | tr u x ) 
	} 
	inline_IORDWR_IODUP() {
		sh  1<>/dev/console  0<&1  2>&1
	}
	inline_IORDWR_IODUP() {
		sh 1<>/dev/console <&1 2>&1 
	} 
	function comsub_IORDWR_IODUP { x=$(
		sh  1<>/dev/console  0<&1  2>&1
	); }
	function comsub_IORDWR_IODUP {
		x=$(sh 1<>/dev/console <&1 2>&1 ) 
	} 
	function reread_IORDWR_IODUP { x=$((
		sh  1<>/dev/console  0<&1  2>&1
	)|tr u x); }
	function reread_IORDWR_IODUP {
		x=$(( sh 1<>/dev/console <&1 2>&1 ) | tr u x ) 
	} 
	inline_COMSUB_EXPRSUB_FUNSUB_VALSUB() {
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	}
	inline_COMSUB_EXPRSUB_FUNSUB_VALSUB() {
		echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} 
	} 
	function comsub_COMSUB_EXPRSUB_FUNSUB_VALSUB { x=$(
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	); }
	function comsub_COMSUB_EXPRSUB_FUNSUB_VALSUB {
		x=$(echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) 
	} 
	function reread_COMSUB_EXPRSUB_FUNSUB_VALSUB { x=$((
		echo $(true) $((1+ 2)) ${  :;} ${| REPLY=x;}
	)|tr u x); }
	function reread_COMSUB_EXPRSUB_FUNSUB_VALSUB {
		x=$(( echo $(true ) $((1+ 2)) ${ : ;} ${|REPLY=x ;} ) | tr u x ) 
	} 
	inline_QCHAR_OQUOTE_CQUOTE() {
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	}
	inline_QCHAR_OQUOTE_CQUOTE() {
		echo fo\ob\"a\`r\'b\$az 
		echo "fo\ob\"a\`r\'b\$az" 
		echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" 
	} 
	function comsub_QCHAR_OQUOTE_CQUOTE { x=$(
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	); }
	function comsub_QCHAR_OQUOTE_CQUOTE {
		x=$(echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) 
	} 
	function reread_QCHAR_OQUOTE_CQUOTE { x=$((
		echo fo\ob\"a\`r\'b\$az
		echo "fo\ob\"a\`r\'b\$az"
		echo 'fo\ob\"a\`r'\''b\$az'
	)|tr u x); }
	function reread_QCHAR_OQUOTE_CQUOTE {
		x=$(( echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\\ob\\\"a\\\`r"\'"b\\\$az" ) | tr u x ) 
	} 
	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	}
	inline_OSUBST_CSUBST_OPAT_SPAT_CPAT() {
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]] 
	} 
	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$(
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	); }
	function comsub_OSUBST_CSUBST_OPAT_SPAT_CPAT {
		x=$([[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) 
	} 
	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT { x=$((
		[[ ${foo#bl\(u\)b} = @@(bar|baz) ]]
	)|tr u x); }
	function reread_OSUBST_CSUBST_OPAT_SPAT_CPAT {
		x=$(( [[ ${foo#bl\(u\)b} = @@(bar|baz) ]] ) | tr u x ) 
	} 
	inline_heredoc_closed() {
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	}
	inline_heredoc_closed() {
		x=$(cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) 
		echo $x 
	} 
	function comsub_heredoc_closed { x=$(
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	); }
	function comsub_heredoc_closed {
		x=$(x=$(cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) ; echo $x ) 
	} 
	function reread_heredoc_closed { x=$((
		x=$(cat <<EOFN
		note there must be no space between EOFN and )
	EOFN); echo $x
	)|tr u x); }
	function reread_heredoc_closed {
		x=$(( x=$(cat <<EOFN 
		note there must be no space between EOFN and )
	EOFN
	) ; echo $x ) | tr u x ) 
	} 
	inline_heredoc_space() {
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	}
	inline_heredoc_space() {
		x=$(cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) 
		echo $x 
	} 
	function comsub_heredoc_space { x=$(
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	); }
	function comsub_heredoc_space {
		x=$(x=$(cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) ; echo $x ) 
	} 
	function reread_heredoc_space { x=$((
		x=$(cat <<EOFN\ 
		note the space between EOFN and ) is actually part of the here document marker
	EOFN ); echo $x
	)|tr u x); }
	function reread_heredoc_space {
		x=$(( x=$(cat <<EOFN\  
		note the space between EOFN and ) is actually part of the here document marker
	EOFN 
	) ; echo $x ) | tr u x ) 
	} 
	inline_patch_motd() {
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	}
	inline_patch_motd() {
		x=$(sysctl -n kern.version | sed 1q ) 
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && rm -f /etc/motd 
		if [[ ! -s /etc/motd ]] 
		then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd 
			print -- "$x\n" >/etc/motd 
		fi 
	} 
	function comsub_patch_motd { x=$(
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	); }
	function comsub_patch_motd {
		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) 
	} 
	function reread_patch_motd { x=$((
		x=$(sysctl -n kern.version | sed 1q)
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
		    ed -s /etc/motd 2>&1 <<-EOF
			1,/^\$/d
			0a
				$x
		
			.
			wq
		EOF)" = @@(?) ]] && rm -f /etc/motd
		if [[ ! -s /etc/motd ]]; then
			install -c -o root -g wheel -m 664 /dev/null /etc/motd
			print -- "$x\n" >/etc/motd
		fi
	)|tr u x); }
	function reread_patch_motd {
		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
	1,/^\$/d
	0a
	$x
	
	.
	wq
	EOF
	)" = @@(?) ]] && rm -f /etc/motd ; if [[ ! -s /etc/motd ]] ; then install -c -o root -g wheel -m 664 /dev/null /etc/motd ; print -- "$x\n" >/etc/motd ; fi ) | tr u x ) 
	} 
	inline_wdarrassign() {
		case x in
		x) a+=b; c+=(d e)
		esac
	}
	inline_wdarrassign() {
		case x in
		(x)
			a+=b 
			\set -A c+ -- d e 
			;;
		esac 
	} 
	function comsub_wdarrassign { x=$(
		case x in
		x) a+=b; c+=(d e)
		esac
	); }
	function comsub_wdarrassign {
		x=$(case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) 
	} 
	function reread_wdarrassign { x=$((
		case x in
		x) a+=b; c+=(d e)
		esac
	)|tr u x); }
	function reread_wdarrassign {
		x=$(( case x in (x) a+=b ; \set -A c+ -- d e  ;; esac ) | tr u x ) 
	} 
---
name: comsub-torture-io
description:
	Check the tree dump functions work correctly with I/O redirection
stdin:
	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
	while IFS= read -r line; do
		if [[ $line = '#1' ]]; then
			lastf=0
			continue
		elif [[ $line = EOFN* ]]; then
			fbody=$fbody$'\n'$line
			continue
		elif [[ $line != '#'* ]]; then
			fbody=$fbody$'\n\t'$line
			continue
		fi
		if (( lastf )); then
			x="inline_${nextf}() {"$fbody$'\n}\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
		fi
		lastf=1
		fbody=
		nextf=${line#?}
	done <<'EOD'
	#1
	#TCOM
	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	#TPAREN_TPIPE_TLIST
	(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	#TAND_TOR
	cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	#TSELECT
	select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	#TFOR_TTIME
	for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	#TCASE
	case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	#TIF_TBANG_TDBRACKET_TELIF
	if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	#TWHILE
	i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	#TUNTIL
	i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	#TCOPROC
	cat  *  >&3 |&  >&3 ls
	#TFUNCT_TBRACE_TASYNC
	function  korn  {  echo eins; echo >&3 zwei ;  }
	bourne  ()  {  logger *  >&3 &  }
	#COMSUB_EXPRSUB
	echo $(true >&3) $((1+ 2))
	#0
	EOD
expected-stdout:
	inline_TCOM() {
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	}
	inline_TCOM() {
		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 
	} 
	function comsub_TCOM { x=$(
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	); }
	function comsub_TCOM {
		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) 
	} 
	function reread_TCOM { x=$((
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	)|tr u x); }
	function reread_TCOM {
		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) | tr u x ) 
	} 
	inline_TPAREN_TPIPE_TLIST() {
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	}
	inline_TPAREN_TPIPE_TLIST() {
		( echo $foo | tr -dc 0-9 >&3 
		  echo >&3 ) >&3 
	} 
	function comsub_TPAREN_TPIPE_TLIST { x=$(
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	); }
	function comsub_TPAREN_TPIPE_TLIST {
		x=$(( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) 
	} 
	function reread_TPAREN_TPIPE_TLIST { x=$((
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	)|tr u x); }
	function reread_TPAREN_TPIPE_TLIST {
		x=$(( ( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) | tr u x ) 
	} 
	inline_TAND_TOR() {
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	}
	inline_TAND_TOR() {
		cmd >&3 && echo ja >&3 || echo nein >&3 
	} 
	function comsub_TAND_TOR { x=$(
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	); }
	function comsub_TAND_TOR {
		x=$(cmd >&3 && echo ja >&3 || echo nein >&3 ) 
	} 
	function reread_TAND_TOR { x=$((
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	)|tr u x); }
	function reread_TAND_TOR {
		x=$(( cmd >&3 && echo ja >&3 || echo nein >&3 ) | tr u x ) 
	} 
	inline_TSELECT() {
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	}
	inline_TSELECT() {
		select file in * 
		do
			echo "<$file>" 
			break >&3 
		done >&3 
	} 
	function comsub_TSELECT { x=$(
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	); }
	function comsub_TSELECT {
		x=$(select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) 
	} 
	function reread_TSELECT { x=$((
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	)|tr u x); }
	function reread_TSELECT {
		x=$(( select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) | tr u x ) 
	} 
	inline_TFOR_TTIME() {
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	}
	inline_TFOR_TTIME() {
		for i in {1,2,3} 
		do
			time echo $i >&3 
		done >&3 
	} 
	function comsub_TFOR_TTIME { x=$(
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	); }
	function comsub_TFOR_TTIME {
		x=$(for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) 
	} 
	function reread_TFOR_TTIME { x=$((
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	)|tr u x); }
	function reread_TFOR_TTIME {
		x=$(( for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) | tr u x ) 
	} 
	inline_TCASE() {
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	}
	inline_TCASE() {
		case $foo in
		(1)
			echo eins >&3 
			;&
		(2)
			echo zwei >&3 
			;|
		(*)
			echo kann net bis drei zhlen >&3 
			;;
		esac >&3 
	} 
	function comsub_TCASE { x=$(
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	); }
	function comsub_TCASE {
		x=$(case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) 
	} 
	function reread_TCASE { x=$((
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	)|tr u x); }
	function reread_TCASE {
		x=$(( case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) | tr u x ) 
	} 
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	}
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if ! [[ 1 = 1 ]] >&3 
		then
			echo eins 
		elif [[ 1 = 2 ]] >&3 
		then
			echo zwei 
		else
			echo drei 
		fi >&3 
	} 
	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	); }
	function comsub_TIF_TBANG_TDBRACKET_TELIF {
		x=$(if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) 
	} 
	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	)|tr u x); }
	function reread_TIF_TBANG_TDBRACKET_TELIF {
		x=$(( if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) | tr u x ) 
	} 
	inline_TWHILE() {
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	}
	inline_TWHILE() {
		i=1 
		while {
			      \let] " i < 10 " 
		      } >&3 
		do
			echo $i 
			let ++i 
		done >&3 
	} 
	function comsub_TWHILE { x=$(
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	); }
	function comsub_TWHILE {
		x=$(i=1 ; while { \let] " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) 
	} 
	function reread_TWHILE { x=$((
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	)|tr u x); }
	function reread_TWHILE {
		x=$(( i=1 ; while { \let] " i < 10 " ; } >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
	} 
	inline_TUNTIL() {
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	}
	inline_TUNTIL() {
		i=10 
		until {
			      \let] " !--i " 
		      } >&3 
		do
			echo $i 
		done >&3 
	} 
	function comsub_TUNTIL { x=$(
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	); }
	function comsub_TUNTIL {
		x=$(i=10 ; until { \let] " !--i " ; } >&3 ; do echo $i ; done >&3 ) 
	} 
	function reread_TUNTIL { x=$((
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	)|tr u x); }
	function reread_TUNTIL {
		x=$(( i=10 ; until { \let] " !--i " ; } >&3 ; do echo $i ; done >&3 ) | tr u x ) 
	} 
	inline_TCOPROC() {
		cat  *  >&3 |&  >&3 ls
	}
	inline_TCOPROC() {
		cat * >&3 |& 
		ls >&3 
	} 
	function comsub_TCOPROC { x=$(
		cat  *  >&3 |&  >&3 ls
	); }
	function comsub_TCOPROC {
		x=$(cat * >&3 |&  ls >&3 ) 
	} 
	function reread_TCOPROC { x=$((
		cat  *  >&3 |&  >&3 ls
	)|tr u x); }
	function reread_TCOPROC {
		x=$(( cat * >&3 |&  ls >&3 ) | tr u x ) 
	} 
	inline_TFUNCT_TBRACE_TASYNC() {
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	}
	inline_TFUNCT_TBRACE_TASYNC() {
		function korn {
			echo eins 
			echo zwei >&3 
		} 
		bourne() {
			logger * >&3 & 
		} 
	} 
	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	); }
	function comsub_TFUNCT_TBRACE_TASYNC {
		x=$(function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) 
	} 
	function reread_TFUNCT_TBRACE_TASYNC { x=$((
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	)|tr u x); }
	function reread_TFUNCT_TBRACE_TASYNC {
		x=$(( function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) | tr u x ) 
	} 
	inline_COMSUB_EXPRSUB() {
		echo $(true >&3) $((1+ 2))
	}
	inline_COMSUB_EXPRSUB() {
		echo $(true >&3 ) $((1+ 2)) 
	} 
	function comsub_COMSUB_EXPRSUB { x=$(
		echo $(true >&3) $((1+ 2))
	); }
	function comsub_COMSUB_EXPRSUB {
		x=$(echo $(true >&3 ) $((1+ 2)) ) 
	} 
	function reread_COMSUB_EXPRSUB { x=$((
		echo $(true >&3) $((1+ 2))
	)|tr u x); }
	function reread_COMSUB_EXPRSUB {
		x=$(( echo $(true >&3 ) $((1+ 2)) ) | tr u x ) 
	} 
---
name: funsub-1
description:
	Check that non-subenvironment command substitution works
stdin:
	set -e
	foo=bar
	echo "ob $foo ."
	echo "${
		echo "ib $foo :"
		foo=baz
		echo "ia $foo :"
		false
	}" .
	echo "oa $foo ."
expected-stdout:
	ob bar .
	ib bar :
	ia baz : .
	oa baz .
---
name: funsub-2
description:
	You can now reliably use local and return in funsubs
	(not exit though)
stdin:
	x=q; e=1; x=${ echo a; e=2; echo x$e;}; echo 1:y$x,$e,$?.
	x=q; e=1; x=${ echo a; typeset e=2; echo x$e;}; echo 2:y$x,$e,$?.
	x=q; e=1; x=${ echo a; typeset e=2; return 3; echo x$e;}; echo 3:y$x,$e,$?.
expected-stdout:
	1:ya x2,2,0.
	2:ya x2,1,0.
	3:ya,1,3.
---
name: valsub-1
description:
	Check that "value substitutions" work as advertised
stdin:
	x=1
	y=2
	z=3
	REPLY=4
	echo "before:	x<$x> y<$y> z<$z> R<$REPLY>"
	x=${|
		local y
		echo "begin:	x<$x> y<$y> z<$z> R<$REPLY>"
		x=5
		y=6
		z=7
		REPLY=8
		echo "end:	x<$x> y<$y> z<$z> R<$REPLY>"
	}
	echo "after:	x<$x> y<$y> z<$z> R<$REPLY>"
	# ensure trailing newlines are kept
	t=${|REPLY=$'foo\n\n';}
	typeset -p t
	echo -n this used to segfault
	echo ${|true;}$(true).
expected-stdout:
	before:	x<1> y<2> z<3> R<4>
	begin:	x<1> y<> z<3> R<>
	end:	x<5> y<6> z<7> R<8>
	after:	x<8> y<2> z<7> R<4>
	typeset t=$'foo\n\n'
	this used to segfault.
---
name: event-subst-3
description:
	Check that '!' substitution in noninteractive mode is ignored
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
stdin:
	export PATH=.$PATHSEP$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	si
	meow
	= 0
	foo
---
name: event-subst-0
description:
	Check that '!' substitution in interactive mode is ignored
need-ctty: yes
arguments: !-i!
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
stdin:
	export PATH=.$PATHSEP$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	si
	meow
	= 0
	foo
expected-stderr-pattern:
	/.*/
---
name: nounset-1
description:
	Check that "set -u" matches (future) SUSv4 requirement
stdin:
	(set -u
	try() {
		local v
		eval v=\$$1
		if [[ -n $v ]]; then
			echo $1=nz
		else
			echo $1=zf
		fi
	}
	x=y
	(echo $x)
	echo =1
	(echo $y)
	echo =2
	(try x)
	echo =3
	(try y)
	echo =4
	(try 0)
	echo =5
	(try 2)
	echo =6
	(try)
	echo =7
	(echo at=$@@)
	echo =8
	(echo asterisk=$*)
	echo =9
	(echo $?)
	echo =10
	(echo $!)
	echo =11
	(echo $-)
	echo =12
	#(echo $_)
	#echo =13
	(echo $#)
	echo =14
	(mypid=$$; try mypid)
	echo =15
	) 2>&1 | sed -e 's/^[^]]*]//' -e 's/^[^:]*: *//'
	exit ${PIPESTATUS[0]}
expected-stdout:
	y
	=1
	y: parameter not set
	=2
	x=nz
	=3
	y: parameter not set
	=4
	0=nz
	=5
	2: parameter not set
	=6
	1: parameter not set
	=7
	at=
	=8
	asterisk=
	=9
	0
	=10
	!: parameter not set
	=11
	ush
	=12
	0
	=14
	mypid=nz
	=15
---
name: nameref-1
description:
	Testsuite for nameref (bound variables)
stdin:
	bar=global
	typeset -n ir2=bar
	typeset -n ind=ir2
	echo !ind: ${!ind}
	echo ind: $ind
	echo !ir2: ${!ir2}
	echo ir2: $ir2
	typeset +n ind
	echo !ind: ${!ind}
	echo ind: $ind
	typeset -n ir2=ind
	echo !ir2: ${!ir2}
	echo ir2: $ir2
	set|grep ^ir2|sed 's/^/s1: /'
	typeset|grep ' ir2'|sed -e 's/^/s2: /' -e 's/nameref/typeset -n/'
	set -A blub -- e1 e2 e3
	typeset -n ind=blub
	typeset -n ir2=blub[2]
	echo !ind[1]: ${!ind[1]}
	echo !ir2: $!ir2
	echo ind[1]: ${ind[1]}
	echo ir2: $ir2
expected-stdout:
	!ind: bar
	ind: global
	!ir2: bar
	ir2: global
	!ind: ind
	ind: ir2
	!ir2: ind
	ir2: ir2
	s1: ir2=ind
	s2: typeset -n ir2
	!ind[1]: blub[1]
	!ir2: ir2
	ind[1]: e2
	ir2: e3
---
name: nameref-2da
description:
	Testsuite for nameref (bound variables)
	Functions, argument given directly, after local
stdin:
	function foo {
		typeset bar=lokal baz=auch
		typeset -n v=bar
		echo entering
		echo !v: ${!v}
		echo !bar: ${!bar}
		echo !baz: ${!baz}
		echo bar: $bar
		echo v: $v
		v=123
		echo bar: $bar
		echo v: $v
		echo exiting
	}
	bar=global
	echo bar: $bar
	foo bar
	echo bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: lokal
	bar: 123
	v: 123
	exiting
	bar: global
---
name: nameref-3
description:
	Advanced testsuite for bound variables (ksh93 fails this)
stdin:
	typeset -n foo=bar[i]
	set -A bar -- b c a
	for i in 0 1 2 3; do
		print $i $foo .
	done
expected-stdout:
	0 b .
	1 c .
	2 a .
	3 .
---
name: nameref-4
description:
	Ensure we don't run in an infinite loop
time-limit: 3
stdin:
	baz() {
		typeset -n foo=fnord fnord=foo
		foo[0]=bar
	}
	set -A foo bad
	echo sind $foo .
	baz
	echo blah $foo .
expected-stdout:
	sind bad .
	blah bad .
expected-stderr-pattern:
	/fnord: expression recurses on parameter/
---
name: better-parens-1a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ( (echo fubar)|tr u x); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-1b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $( (echo fubar)|tr u x) $?
expected-stdout:
	fxbar 0
---
name: better-parens-1c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$( (echo fubar)|tr u x); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-2a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ((echo fubar)|tr u x); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-2b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $((echo fubar)|tr u x) $?
expected-stdout:
	fxbar 0
---
name: better-parens-2c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$((echo fubar)|tr u x); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-3a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ( (echo fubar)|(tr u x)); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-3b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $( (echo fubar)|(tr u x)) $?
expected-stdout:
	fxbar 0
---
name: better-parens-3c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$( (echo fubar)|(tr u x)); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-4a
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	if ((echo fubar)|(tr u x)); then
		echo ja
	else
		echo nein
	fi
expected-stdout:
	fxbar
	ja
---
name: better-parens-4b
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	echo $((echo fubar)|(tr u x)) $?
expected-stdout:
	fxbar 0
---
name: better-parens-4c
description:
	Check support for (()) and $(()) vs () and $()
stdin:
	x=$((echo fubar)|(tr u x)); echo $x $?
expected-stdout:
	fxbar 0
---
name: better-parens-5
description:
	Another corner case
stdin:
	( (echo 'fo	o$bar' "baz\$bla\"" m\$eh) | tr a A)
	((echo 'fo	o$bar' "baz\$bla\"" m\$eh) | tr a A)
expected-stdout:
	fo	o$bAr bAz$blA" m$eh
	fo	o$bAr bAz$blA" m$eh
---
name: echo-test-1
description:
	Test what the echo builtin does (mksh)
stdin:
	echo -n 'foo\x40bar'
	echo -e '\tbaz'
expected-stdout:
	foo@@bar	baz
---
name: echo-test-2
description:
	Test what the echo builtin does (POSIX)
	Note: this follows Debian Policy 10.4 which mandates
	that -n shall be treated as an option, not XSI which
	mandates it shall be treated as string but escapes
	shall be expanded.
stdin:
	test -n "$POSH_VERSION" || set -o posix
	echo -n 'foo\x40bar'
	echo -e '\tbaz'
expected-stdout:
	foo\x40bar-e \tbaz
---
name: echo-test-3-mnbsd
description:
	Test what the echo builtin does, and test a compatibility flag.
category: mnbsdash
stdin:
	"$__progname" -c 'echo -n 1=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x40$1; echo -e \\x2E' -- foo bar
expected-stdout:
	1=@@foo.
	2=\x40foo-e \x2E
	3=\x40bar.
---
name: echo-test-3-normal
description:
	Test what the echo builtin does, and test a compatibility flag.
category: !mnbsdash
stdin:
	"$__progname" -c 'echo -n 1=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o posix -c 'echo -n 2=\\x40$1; echo -e \\x2E' -- foo bar
	"$__progname" -o sh -c 'echo -n 3=\\x40$1; echo -e \\x2E' -- foo bar
expected-stdout:
	1=@@foo.
	2=\x40foo-e \x2E
	3=\x40foo-e \x2E
---
name: utilities-getopts-1
description:
	getopts sets OPTIND correctly for unparsed option
stdin:
	set -- -a -a -x
	while getopts :a optc; do
	    echo "OPTARG=$OPTARG, OPTIND=$OPTIND, optc=$optc."
	done
	echo done
expected-stdout:
	OPTARG=, OPTIND=2, optc=a.
	OPTARG=, OPTIND=3, optc=a.
	OPTARG=x, OPTIND=4, optc=?.
	done
---
name: utilities-getopts-2
description:
	Check OPTARG
stdin:
	set -- -a Mary -x
	while getopts a: optc; do
	    echo "OPTARG=$OPTARG, OPTIND=$OPTIND, optc=$optc."
	done
	echo done
expected-stdout:
	OPTARG=Mary, OPTIND=3, optc=a.
	OPTARG=, OPTIND=4, optc=?.
	done
expected-stderr-pattern: /.*-x.*option/
---
name: wcswidth-1
description:
	Check the new wcswidth feature
stdin:
	s=
	set +U
	print octets: ${#s} .
	print 8-bit width: ${%s} .
	set -U
	print characters: ${#s} .
	print columns: ${%s} .
	s=
	set +U
	print octets: ${#s} .
	print 8-bit width: ${%s} .
	set -U
	print characters: ${#s} .
	print columns: ${%s} .
expected-stdout:
	octets: 3 .
	8-bit width: -1 .
	characters: 1 .
	columns: 2 .
	octets: 3 .
	8-bit width: 3 .
	characters: 1 .
	columns: 1 .
---
name: wcswidth-2
description:
	Check some corner cases
stdin:
	print % $% .
	set -U
	x='a	b'
	print c ${%x} .
	set +U
	x='a	b'
	print d ${%x} .
expected-stdout:
	% $% .
	c -1 .
	d -1 .
---
name: wcswidth-3
description:
	Check some corner cases
stdin:
	print ${%} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4a
description:
	Check some corner cases
stdin:
	print ${%*} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4b
description:
	Check some corner cases
stdin:
	print ${%@@} .
expected-stderr-pattern:
	/bad substitution/
expected-exit: 1
---
name: wcswidth-4c
description:
	Check some corner cases
stdin:
	:
	print ${%?} .
expected-stdout:
	1 .
---
name: realpath-1
description:
	Check proper return values for realpath
category: os:mirbsd
stdin:
	wd=$(realpath .)
	mkdir dir
	:>file
	:>dir/file
	ln -s dir lndir
	ln -s file lnfile
	ln -s nix lnnix
	ln -s . lnself
	i=0
	chk() {
		typeset x y
		x=$(realpath "$wd/$1" 2>&1); y=$?
		print $((++i)) "?$1" =${x##*$wd/} !$y
	}
	chk dir
	chk dir/
	chk dir/file
	chk dir/nix
	chk file
	chk file/
	chk file/file
	chk file/nix
	chk nix
	chk nix/
	chk nix/file
	chk nix/nix
	chk lndir
	chk lndir/
	chk lndir/file
	chk lndir/nix
	chk lnfile
	chk lnfile/
	chk lnfile/file
	chk lnfile/nix
	chk lnnix
	chk lnnix/
	chk lnnix/file
	chk lnnix/nix
	chk lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself
	rm lnself
expected-stdout:
	1 ?dir =dir !0
	2 ?dir/ =dir !0
	3 ?dir/file =dir/file !0
	4 ?dir/nix =dir/nix !0
	5 ?file =file !0
	6 ?file/ =file/: Not a directory !20
	7 ?file/file =file/file: Not a directory !20
	8 ?file/nix =file/nix: Not a directory !20
	9 ?nix =nix !0
	10 ?nix/ =nix !0
	11 ?nix/file =nix/file: No such file or directory !2
	12 ?nix/nix =nix/nix: No such file or directory !2
	13 ?lndir =dir !0
	14 ?lndir/ =dir !0
	15 ?lndir/file =dir/file !0
	16 ?lndir/nix =dir/nix !0
	17 ?lnfile =file !0
	18 ?lnfile/ =lnfile/: Not a directory !20
	19 ?lnfile/file =lnfile/file: Not a directory !20
	20 ?lnfile/nix =lnfile/nix: Not a directory !20
	21 ?lnnix =nix !0
	22 ?lnnix/ =nix !0
	23 ?lnnix/file =lnnix/file: No such file or directory !2
	24 ?lnnix/nix =lnnix/nix: No such file or directory !2
	25 ?lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself =lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself/lnself: Too many levels of symbolic links !62
---
name: realpath-2
description:
	Ensure that exactly two leading slashes are not collapsed
	POSIX guarantees this exception, e.g. for UNC paths on Cygwin
category: os:mirbsd
stdin:
	ln -s /bin t1
	ln -s //bin t2
	ln -s ///bin t3
	realpath /bin
	realpath //bin
	realpath ///bin
	realpath /usr/bin
	realpath /usr//bin
	realpath /usr///bin
	realpath t1
	realpath t2
	realpath t3
	rm -f t1 t2 t3
	cd //usr/bin
	pwd
	cd ../lib
	pwd
	realpath //usr/include/../bin
expected-stdout:
	/bin
	//bin
	/bin
	/usr/bin
	/usr/bin
	/usr/bin
	/bin
	//bin
	/bin
	//usr/bin
	//usr/lib
	//usr/bin
---
name: crash-1
description:
	Crashed during March 2011, fixed on vernal equinx 
category: os:mirbsd,os:openbsd
stdin:
	export MALLOC_OPTIONS=FGJPRSX
	"$__progname" -c 'x=$(tr z r <<<baz); echo $x'
expected-stdout:
	bar
---
name: debian-117-1
description:
	Check test - bug#465250
stdin:
	test \( ! -e \) ; echo $?
expected-stdout:
	1
---
name: debian-117-2
description:
	Check test - bug#465250
stdin:
	test \(  -e \) ; echo $?
expected-stdout:
	0
---
name: debian-117-3
description:
	Check test - bug#465250
stdin:
	test ! -e  ; echo $?
expected-stdout:
	1
---
name: debian-117-4
description:
	Check test - bug#465250
stdin:
	test  -e  ; echo $?
expected-stdout:
	0
---
name: case-zsh
description:
	Check that zsh case variants work
stdin:
	case 'b' in
	  a) echo a ;;
	  b) echo b ;;
	  c) echo c ;;
	  *) echo x ;;
	esac
	echo =
	case 'b' in
	  a) echo a ;&
	  b) echo b ;&
	  c) echo c ;&
	  *) echo x ;&
	esac
	echo =
	case 'b' in
	  a) echo a ;|
	  b) echo b ;|
	  c) echo c ;|
	  *) echo x ;|
	esac
expected-stdout:
	b
	=
	b
	c
	x
	=
	b
	x
---
name: case-braces
description:
	Check that case end tokens are not mixed up (Debian #220272)
stdin:
	i=0
	for value in 'x' '}' 'esac'; do
		print -n "$((++i))($value)bourne "
		case $value in
		}) echo brace ;;
		*) echo no ;;
		esac
		print -n "$((++i))($value)korn "
		case $value {
		esac) echo esac ;;
		*) echo no ;;
		}
	done
expected-stdout:
	1(x)bourne no
	2(x)korn no
	3(})bourne brace
	4(})korn no
	5(esac)bourne no
	6(esac)korn esac
---
name: command-shift
description:
	Check that 'command shift' works
stdin:
	function snc {
		echo "before	0='$0' 1='$1' 2='$2'"
		shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	function swc {
		echo "before	0='$0' 1='$1' 2='$2'"
		command shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	echo = without command
	snc  
	echo = with command
	swc  
	echo = done
expected-stdout:
	= without command
	before	0='snc' 1='' 2=''
	after	0='snc' 1='' 2=''
	= with command
	before	0='swc' 1='' 2=''
	after	0='swc' 1='' 2=''
	= done
---
name: command-pvV-posix-priorities
description:
	For POSIX compatibility, command -v should find aliases and reserved
	words, and command -p[vV] should find aliases, reserved words, and
	builtins over external commands.
stdin:
	PATH=/bin:/usr/bin
	alias foo="bar baz"
	bar() { :; }
	for word in 'if' 'foo' 'bar' 'set' 'true'; do
		command -v "$word"
		command -pv "$word"
		command -V "$word"
		command -pV "$word"
	done
expected-stdout:
	if
	if
	if is a reserved word
	if is a reserved word
	alias foo='bar baz'
	alias foo='bar baz'
	foo is an alias for 'bar baz'
	foo is an alias for 'bar baz'
	bar
	bar
	bar is a function
	bar is a function
	set
	set
	set is a special shell builtin
	set is a special shell builtin
	true
	true
	true is a shell builtin
	true is a shell builtin
---
name: whence-preserve-tradition
description:
	This regression test is to ensure that the POSIX compatibility
	changes for 'command' (see previous test) do not affect traditional
	'whence' behaviour.
category: os:mirbsd
stdin:
	PATH=/bin:/usr/bin
	alias foo="bar baz"
	bar() { :; }
	for word in 'if' 'foo' 'bar' 'set' 'true'; do
		whence "$word"
		whence -p "$word"
		whence -v "$word"
		whence -pv "$word"
	done
expected-stdout:
	if
	if is a reserved word
	if not found
	'bar baz'
	foo is an alias for 'bar baz'
	foo not found
	bar
	bar is a function
	bar not found
	set
	set is a special shell builtin
	set not found
	true
	/bin/true
	true is a shell builtin
	true is a tracked alias for /bin/true
---
name: duffs-device
description:
	Check that the compiler did not optimise-break them
	(lex.c has got a similar one in SHEREDELIM)
stdin:
	set +U
	s=
	typeset -i1 i=0
	while (( ++i < 256 )); do
		s+=${i#1#}
	done
	s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.'
	typeset -p s
expected-stdout:
	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377\u00A0\u20AC\uFFFD\357\277\276\357\277\277\360\220\200\200.'
---
name: stateptr-underflow
description:
	This check overflows an Xrestpos stored in a short in R40
category: fastbox
stdin:
	function Lb64decode {
		[[ -o utf8-mode ]]; local u=$?
		set +U
		local c s="$*" t=
		[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
		local -i i=0 n=${#s} p=0 v x
		local -i16 o
	
		while (( i < n )); do
			c=${s:(i++):1}
			case $c {
			(=)	break ;;
			([A-Z])	(( v = 1#$c - 65 )) ;;
			([a-z])	(( v = 1#$c - 71 )) ;;
			([0-9])	(( v = 1#$c + 4 )) ;;
			(+)	v=62 ;;
			(/)	v=63 ;;
			(*)	continue ;;
			}
			(( x = (x << 6) | v ))
			case $((p++)) {
			(0)	continue ;;
			(1)	(( o = (x >> 4) & 255 )) ;;
			(2)	(( o = (x >> 2) & 255 )) ;;
			(3)	(( o = x & 255 ))
				p=0
				;;
			}
			t=$t\\x${o#16#}
		done
		print -n $t
		(( u )) || set -U
	}
	
	i=-1
	s=
	while (( ++i < 12120 )); do
		s+=a
	done
	Lb64decode $s >/dev/null
---
name: xtrace-1
description:
	Check that "set -x" doesn't redirect too quickly
stdin:
	print '#!'"$__progname" >bash
	cat >>bash <<'EOF'
	echo 'GNU bash, version 2.05b.0(1)-release (i386-ecce-mirbsd10)
	Copyright (C) 2002 Free Software Foundation, Inc.'
	EOF
	chmod +x bash
	"$__progname" -xc 'foo=$(./bash --version 2>&1 | sed q); echo "=$foo="'
expected-stdout:
	=GNU bash, version 2.05b.0(1)-release (i386-ecce-mirbsd10)=
expected-stderr-pattern:
	/.*/
---
name: xtrace-2
description:
	Check that "set -x" is off during PS4 expansion
stdin:
	f() {
		print -n "(f1:$-)"
		set -x
		print -n "(f2:$-)"
	}
	PS4='[(p:$-)$(f)] '
	print "(o0:$-)"
	set -x -o inherit-xtrace
	print "(o1:$-)"
	set +x
	print "(o2:$-)"
expected-stdout:
	(o0:sh)
	(o1:shx)
	(o2:sh)
expected-stderr:
	[(p:sh)(f1:sh)(f2:sh)] print '(o1:shx)'
	[(p:sh)(f1:sh)(f2:sh)] set +x
---
name: fksh-flags
description:
	Check that FKSH functions have their own shell flags
category: shell:legacy-no
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	function foo {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 fh .
---
name: fksh-flags-legacy
description:
	Check that even FKSH functions share the shell flags
category: shell:legacy-yes
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
name: fsh-flags
description:
	Check that !FKSH functions share the shell flags
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
@


1.732
log
@fix shf.c-internal buffer overread on printing digits,
introduced by the utf_skipcols()-related fixes, more
specifically the check for combining multibyte characters
past end of given width (bogus mixed-up semantics we have here)
by rentroducing the NUL byte from commitid 1005474EE1E4024A4E4
@
text
@d202 1
a202 1
	X Y in 'Y') echo is y ;; Z) echo is z ; esac
@


1.731
log
@add, with a warning, regression testcases for:
 trailing combining character
 ${!#} and friends

the warning is: pid_t is signed (so PIDs could be negative) and may be
rather long, in some cases even longer than a C long; well need to
handle this by adding checks (sizeof pid_t=gid_t, sizeof pid_t must be
either mksh_ari_t or u_short) and code (always print $$/$! as unsigned,
set unsigned attribute on $BASHPID and friends)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/05/05
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/05/05
@


1.730
log
@bump
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/04/14
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/04/14
d1690 44
d7853 21
@


1.729
log
@commitid 10056D5D8AF01B31531 broke fix for Debian #783978 (add testsuite)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/04/09
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/04/09
@


1.728
log
@expanded tests for command/whence, from Martijn Dekker
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/03/04
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/03/04
d3176 31
@


1.727
log
@address latest Debian gcc-snapshots warnings (some actual bugs!)
@
text
@d12199 1
a12199 1
name: command-path
d12201 51
a12251 3
	Check 'command -p' is not 'whence -p'
stdin:
	command -pv if
d12254 15
@


1.726
log
@check not-begun heredocs at EOF earlier

izabera reported they were not caught with set -n
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/03/01
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/03/01
@


1.725
log
@sync clog
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/02/26
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/02/26
d2252 1
a2252 1
name: heredoc-4
d2262 28
@


1.724
log
@ADELIM can be } too, not just /, in code that checks for / vs. //
caught by new code after segfault report by bef0rd on IRC (thanks!)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/02/23
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/02/23
d2660 26
d6607 31
d12171 8
d12251 1
a12251 1
	"$__progname" -xc 'foo=$(./bash --version 2>&1 | sed 1q); echo "=$foo="'
@


1.723
log
@head(1) is not portable (-n 1 not pr-POSIX/ancient, -1 not busybox)
 use sed(1)

bug spotted by wbx@@
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/01/21
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/01/21
d1861 1
a1861 1
	echo 1: ${x/2}
d1893 1
a1893 1
	1: 122321_ab/cde_b/c_1221
@


1.722
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d12186 1
a12186 1
	"$__progname" -xc 'foo=$(./bash --version 2>&1 | head -1); echo "=$foo="'
@


1.721
log
@fix errno in print/echo builtin; optimise (with partial rewrite)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/01/20
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/01/20
@


1.720
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVARCMDASN
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/01/19
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/01/19
@


1.719
log
@somewhat surprisingly, we can do bashisms better than GNU bash now 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.717 2015/12/31 21:03:44 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/01/14
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/01/14
d6595 4
d6600 1
a6600 1
	unset A
d6602 4
d6608 2
d6611 2
@


1.718
log
@incorporate suggestions by Jrg Schilling
@
text
@d5 1
a5 1
#	      2011, 2012, 2013, 2014, 2015
d33 1
a33 1
	@@(#)MIRBSD KSH R52 2016/01/13
d42 1
a42 1
	@@(#)LEGACY KSH R52 2016/01/13
d8518 1
a8518 1
	This is by design. And that some things fail in both.
d8526 1
d8532 1
a8532 1
	1
@


1.717
log
@fstat(2) after open(2) for set -C case when initial stat(2) was !S_ISREG
to fix race condition as suggested by jilles
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.704 2015/08/13 21:38:15 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R52 2015/12/31
d42 1
a42 1
	@@(#)LEGACY KSH R52 2015/12/31
@


1.716
log
@sync with reality; clog already says:
     * [tg] Drop stop alias, [203]lksh(1) functionality to auto-unalias
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R52 2015/12/12
d42 1
a42 1
	@@(#)LEGACY KSH R52 2015/12/12
@


1.715
log
@update for recent changes
@
text
@a7753 1
category: shell:legacy-no
a7762 13
name: aliases-funcdef-1-legacy
description:
	Check if POSIX functions take precedences over aliases
category: shell:legacy-yes
stdin:
	alias foo='echo makro'
	foo() {
		echo funktion
	}
	foo
expected-stdout:
	funktion
---
a7765 1
category: shell:legacy-no
a7774 13
name: aliases-funcdef-2-legacy
description:
	Check if POSIX functions take precedences over aliases
category: shell:legacy-yes
stdin:
	alias foo='echo makro'
	foo () {
		echo funktion
	}
	foo
expected-stdout:
	funktion
---
a9005 42
name: alias-function-no-conflict-legacy
description:
	make aliases not conflict with functions, legacy version:
	undefine these aliases upon definition of the function
	note: for ksh functions, the order of preference differs in GNU bash
category: shell:legacy-yes
stdin:
	# POSIX function overrides and removes alias
	alias foo='echo bar'
	foo
	foo() {
		echo baz
	}
	foo
	unset -f foo
	foo 2>/dev/null || echo rab
	# alias overrides ksh function
	alias korn='echo bar'
	korn
	function korn {
		echo baz
	}
	korn
	# alias temporarily overrides POSIX function
	bla() {
		echo bfn
	}
	bla
	alias bla='echo bal'
	bla
	unalias bla
	bla
expected-stdout:
	bar
	baz
	rab
	bar
	bar
	bfn
	bal
	bfn
---
a9008 1
category: shell:legacy-no
@


1.714
log
@move tests that logically belong together; no change
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/10/24
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/10/24
d273 8
d1679 11
d1883 9
a1891 7
	echo 23: ${x//#1/9}
	echo 24: ${x//%1/9}
	echo 25: ${x//\%1/9}
	echo 26: ${x//\\%1/9}
	echo 27: ${x//\a/9}
	echo 28: ${x//\\a/9}
	echo 29: ${x/2/$y}
d1916 1
a1916 1
	24: 1222321_ab/cde_b/c_1229
d1919 5
a1923 3
	27: 1222321_9b/cde_b/c_1221
	28: 1222321_9b/cde_b/c_1221
	29: 1xyz22321_ab/cde_b/c_1221
d1948 1
d1958 1
a1958 1
	~/tmp
d1960 1
a1960 1
	~/tmp
d1969 1
d1976 2
a1977 2
	~/tmp
	~/tmp
d1984 1
d2010 10
a2019 10
	echo 25: ${ts//a\/b/$tr}
	echo 26: ${ts//a\/b/\$tr}
	echo 27: ${ts//$tp/$tr}
	echo 28: ${ts//$tp/c/d}
	echo 29: ${ts//$tp/c\/d}
	echo 30: ${ts//+(a\/b)/$tr}
	echo 31: ${ts//+(a\/b)/\$tr}
	echo 32: ${ts//+($tp)/$tr}
	echo 33: ${ts//+($tp)/c/d}
	echo 34: ${ts//+($tp)/c\/d}
d2021 2
a2022 2
	echo 40: ${ts/$tp/$tr}
	echo 41: ${ts//$tp/$tr}
d2025 1
a2025 1
	2: ~/tmp
d2027 3
a2029 3
	4: ~/tmp
	5: ~/tmp
	6: ~/tmp
d2034 1
a2034 1
	11: c/da/b$tp$tp_a/b$tp_*(a/b)_*($tp)
d2043 12
a2054 12
	25: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	26: $tr$tr$tp$tp_$tr$tp_*($tr)_*($tp)
	27: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	28: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	29: c/dc/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	30: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	31: $tr$tp$tp_$tr$tp_*($tr)_*($tp)
	32: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	33: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	34: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
	40: a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)
	41: a/ba/b$tp$tp_a/b$tp_*(a/b)_*($tp)
d2056 2
a2057 2
#	40: c/d$tp$tp_a/b$tp_*(a/b)_*($tp)
#	41: c/d$tp$tp_c/d$tp_*(c/d)_*($tp)
d6413 35
d7179 35
d10569 3
a10571 1
		while \let] " i < 10 " 
d10581 1
a10581 1
		x=$(i=1 ; while \let] " i < 10 " ; do echo $i ; let ++i ; done ) 
d10587 1
a10587 1
		x=$(( i=1 ; while \let] " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
d10594 3
a10596 1
		until \let] " !--i " 
d10605 1
a10605 1
		x=$(i=10 ; until \let] " !--i " ; do echo $i ; done ) 
d10611 1
a10611 1
		x=$(( i=10 ; until \let] " !--i " ; do echo $i ; done ) | tr u x ) 
d11225 3
a11227 1
		while \let] " i < 10 " >&3 
d11237 1
a11237 1
		x=$(i=1 ; while \let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
d11243 1
a11243 1
		x=$(( i=1 ; while \let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
d11250 3
a11252 1
		until \let] " !--i " >&3 
d11261 1
a11261 1
		x=$(i=10 ; until \let] " !--i " >&3 ; do echo $i ; done >&3 ) 
d11267 1
a11267 1
		x=$(( i=10 ; until \let] " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
d11764 10
@


1.713
log
@easy portability fix from Jilles Tjoelker <jilles@@stack.nl>; reason:

> In the Bourne shell, ksh93 and FreeBSD sh, the double-quote directly
> after the question mark starts an unquoted part inside the message.
@
text
@d7028 90
a11294 90
name: test-stnze-1
description:
	Check that the short form [ $x ] works
stdin:
	i=0
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
	x=0
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
	x='1 -a 1 = 2'
	[ -n $x ]
	rv=$?; echo $((++i)) $rv
	[ $x ]
	rv=$?; echo $((++i)) $rv
	[ -n "$x" ]
	rv=$?; echo $((++i)) $rv
	[ "$x" ]
	rv=$?; echo $((++i)) $rv
expected-stdout:
	1 0
	2 1
	3 1
	4 1
	5 0
	6 0
	7 0
	8 0
	9 1
	10 1
	11 0
	12 0
---
name: test-stnze-2
description:
	Check that the short form [[ $x ]] works (ksh93 extension)
stdin:
	i=0
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
	x=0
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
	x='1 -a 1 = 2'
	[[ -n $x ]]
	rv=$?; echo $((++i)) $rv
	[[ $x ]]
	rv=$?; echo $((++i)) $rv
	[[ -n "$x" ]]
	rv=$?; echo $((++i)) $rv
	[[ "$x" ]]
	rv=$?; echo $((++i)) $rv
expected-stdout:
	1 1
	2 1
	3 1
	4 1
	5 0
	6 0
	7 0
	8 0
	9 0
	10 0
	11 0
	12 0
---
@


1.712
log
@fix \u0000 and \x00 being ignored in $'' and print +r expansion
@
text
@d5071 1
a5071 1
	: "${PWD:?"PWD not set - can't do test"}"
@


1.711
log
@another testcase, before I go changing the way let] is handled
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/10/09
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/10/09
d8541 15
d8561 4
d8567 4
@


1.710
log
@make source into a built-in command (keepasn, to match ksh93 and dot);
remove the stop alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d478 3
d489 1
@


1.709
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/10/05
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/10/05
a7493 1
category: !android,!arge,!os:os2
a7507 44
	source='PATH=$PATH:. \command .'
	stop='\kill -STOP'
	type='\builtin whence -v'
---
name: aliases-1-hartz4
description:
	Check if built-in shell aliases are okay
category: android,arge
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH:. \command .'
	type='\builtin whence -v'
---
name: aliases-1-os2
description:
	Check if built-in shell aliases are okay
category: os:os2
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH\;. \command .'
a7512 1
category: !android,!arge,!os:os2
a7527 2
	source='PATH=$PATH:. \command .'
	stop='\kill -STOP'
a7532 90
category: !android,!arge,!os:os2
stdin:
	cp "$__progname" sh
	./sh -c 'alias; typeset -f'
	rm -f sh
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH:. \command .'
	stop='\kill -STOP'
	type='\builtin whence -v'
---
name: aliases-2b-hartz4
description:
	Check if set -o sh does not influence built-in aliases
category: android,arge
arguments: !-o!sh!
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH:. \command .'
	type='\builtin whence -v'
---
name: aliases-3b-hartz4
description:
	Check if running as sh does not influence built-in aliases
category: android,arge
stdin:
	cp "$__progname" sh
	./sh -c 'alias; typeset -f'
	rm -f sh
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH:. \command .'
	type='\builtin whence -v'
---
name: aliases-2b-os2
description:
	Check if set -o sh does not influence built-in aliases
category: os:os2
arguments: !-o!sh!
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='\typeset -fu'
	functions='\typeset -f'
	hash='\builtin alias -t'
	history='\builtin fc -l'
	integer='\typeset -i'
	local='\typeset'
	login='\exec login'
	nameref='\typeset -n'
	nohup='nohup '
	r='\builtin fc -e -'
	source='PATH=$PATH\;. \command .'
	type='\builtin whence -v'
---
name: aliases-3b-os2
description:
	Check if running as sh does not influence built-in aliases
category: os:os2
a7547 1
	source='PATH=$PATH\;. \command .'
d8819 1
a8819 1
	/\.: missing argument.*\n.*\.: missing argument/
a8917 2
	# lksh can do without the backslash, too (cf. aliases-funcdef-2-legacy)
	mk 'function stop ()' '\stop' >f-stop
a8923 1
	x="stop: $(./f-stop)"; echo "${x/@@("$u")/.}"
a8927 1
	stop: bar='./f-stop'
@


1.708
log
@stop using issetugid(2) for p check as its probably not the right tool
@
text
@d6508 1
a6508 2
	ksh88/93, Solaris /bin/sh and /usr/xpg4/bin/sh all print the error,
	that's why the condition is reversed.
d6514 1
a6514 5
# POSIX
#expected-fail: yes
#expected-stderr-pattern: !/not set/
# common use
expected-stderr-pattern: /parameter null or not set/
d6530 1
a6530 1
	set +o braceexpand
@


1.707
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d6 1
a6 1
#	mirabilos <tg@@mirbsd.org>
d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/09/06
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/09/06
@


1.706
log
@fix tree printing multiple heredocs in one command, bug found by izabera
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/09/05
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/09/05
d2328 2
d2339 3
@


1.705
log
@quote path separator if ; in some cases; pointed out by komh
@
text
@d6 1
a6 1
#	Thorsten Glaser <tg@@mirbsd.org>
d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/08/13
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/08/13
d2426 1
a2426 1
		vc=<<-EOF
d2479 1
a2479 1
		vc=<<-
d2483 1
a2483 1
		vd=<<-""
d2541 40
d10609 1
a10609 1
		cat >|bar <<"EOFN"
d10620 1
a10620 1
		x=$(cat >|bar <<"EOFN"
d10631 1
a10631 1
		x=$(( cat >|bar <<"EOFN"
d10642 1
a10642 1
		cat >bar <<-EOFI
d10653 1
a10653 1
		x=$(cat >bar <<-EOFI
d10664 1
a10664 1
		x=$(( cat >bar <<-EOFI
d10755 1
a10755 1
		x=$(cat <<EOFN
d10767 1
a10767 1
		x=$(x=$(cat <<EOFN
d10778 1
a10778 1
		x=$(( x=$(cat <<EOFN
d10789 1
a10789 1
		x=$(cat <<EOFN\ 
d10801 1
a10801 1
		x=$(x=$(cat <<EOFN\ 
d10812 1
a10812 1
		x=$(( x=$(cat <<EOFN\ 
d10835 1
a10835 1
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
d10867 1
a10867 1
		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
d10894 1
a10894 1
		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
@


1.704
log
@be more careful with signals and errorlevels; bounds-check them better;
dont trust the OS as POSuX comes up with more-than-8-bit exit codes now;
also, one more int  bool
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.687 2015/03/20 23:37:52 tg Exp $
d7512 1
a7512 1
	source='PATH=$PATH;. \command .'
d7624 1
a7624 1
	source='PATH=$PATH;. \command .'
d7646 1
a7646 1
	source='PATH=$PATH;. \command .'
@


1.703
log
@merge OS/2 style PATH (absolute with drive letters, ; as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/07/10
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/07/10
@


1.702
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/07/09
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/07/09
d235 1
a235 1
	PATH=$PWD:$PATH
d5560 1
a5560 1
	    done >env; chmod +x env; PATH=.:$PATH
d6266 1
a6266 1
	    done >env; chmod +x env; PATH=.:$PATH
d6278 1
a6278 1
	    done >env; chmod +x env; PATH=.:$PATH
d6522 1
a6522 1
	PATH=.:$PATH
d6540 1
a6540 1
	PATH=.:$PATH
d7284 1
a7284 1
	export PATH=$(pwd)/foo:$PATH
d7454 1
a7454 1
category: !android,!arge
d7494 21
d7518 1
a7518 1
category: !android,!arge
d7541 1
a7541 1
category: !android,!arge
d7605 44
d9975 1
a9975 1
	    done >env; chmod +x env; PATH=.:$PATH
d10147 1
a10147 1
	print '#!'"$__progname"'\necho 1234' >id; chmod +x id; PATH=.:$PATH
d11382 1
a11382 1
	export PATH=.:$PATH
d11412 1
a11412 1
	export PATH=.:$PATH
@


1.701
log
@SECURITY: quote the arguments to true
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/07/06
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/07/06
d8616 1
d8628 2
a8629 1
	[<bar
d8631 1
d8641 1
d8653 2
a8654 1
	[<bar
d8656 1
@


1.700
log
@a few more mksh-os2 inspired fixes
@
text
@a3557 1
	(NOTE: adjusted for COMPLEX HISTORY compile time option)
d5021 2
a5022 2
	: ${PWD:-`pwd 2> /dev/null`}
	: ${PWD:?"PWD not set - can't do test"}
@


1.699
log
@ revert the cat hack for realpath and rename
   I was convinced by several that more magic is never the solution
 fix a comment: function cat already had precedence
 change cat loader to look for existence, FPATH included, before
  ditching the builtin; note that in manpage
@
text
@d2078 1
d2080 1
a2080 2
# breaks on MSYS (does not support symlinks)
# breaks on Dell UNIX 4.0 R2.2 (SVR4) where unlink also fails
d2135 1
a2135 1
category: !os:cygwin,!os:darwin,!os:msys,!os:nto
@


1.698
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/07/05
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/07/05
d8536 1
a8536 1
	#showargs 0 ""$@@
d8556 1
a8571 11
name: varexpand-null-3a
description:
	Ensure concatenating behaviour matches other shells
	(currently broken cases)
expected-fail: yes
stdin:
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
	showargs 0 ""$@@
expected-stdout:
	<0> <> .
---
@


1.697
log
@now removes *all* trailing newlines (by reusing histsave result, saves code),
plus plugs an ancient memory leak (hist_execute afrees its arg now);
also partial revert of commitid 78014291f06497b3 as COMPLEX_HISTORY handles
multi-line commands correctly now (r1.4, 2005-05-23)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/06/28
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/06/28
@


1.696
log
@add new expected-fail from POSIX <Pine.BSM.4.64L.1410241226350.12660@@herc.mirbsd.org>
@
text
@d3585 1
a3585 1
	3	echo a new line
d3667 1
a3667 1
	3	echo a new line
@


1.695
log
@bump; nothing to merge from oksh, and nothing more from me today
@
text
@d8536 1
d8571 11
@


1.694
log
@The check for empty patterns and patterns matching the empty string
in commitid 1004D8283F068C41C3C was bogus; it fixed Jb_boins issue
but izaberss var=foo; echo "${var/*/x}" was broken; in fact we
only want to not do the looping for // if the pattern matches much.

Also, fix a spelling mistake in the manpage and change some wording
to also work with associative arrays (in the future; no change).
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/05/23
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/05/23
@


1.693
log
@overhaul the signal handling:
 support NSIG_MAX from http://austingroupbugs.net/view.php?id=741
  and make a TODO for later to use sysconf(_SC_NSIG) at runtime
 bounds-check signals (e.g. no smaller than 1, but smaller than NSIG)
 align trap errorlevel with other shells
 make trap match whats in POSIX and fixup the manpage
 refactor some code related to signals
 hide from kill builtin both EXIT and ERR pseudo-signals
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/04/29
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/04/29
@


1.692
log
@more OS/390 issues
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/04/19
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/04/19
d4840 1
a4840 1
	= 3
@


1.691
log
@more low-hanging fruits for EBCDIC; notes:

 ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
   used in some places
 (c - '0')  ksh_numdig(c)	# may take *x++ argument
 (c - 'A')  ksh_numuc(c)	# may NOT take *x+= argument
   idem for ksh_numlc(c) and 'a'
   these need changing for EBCDIC
   add testsuite for this
 use macros more, they exist already often
 use digits_lc[foo] instead of ('0' + foo), especially for letters
 caught another ksh_eq case
 also caught a maybe-UB overflow check, but we dont have TIME_T_MAX 
@
text
@d1201 1
a1201 1
category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!nosymlink
@


1.690
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d4548 14
@


1.689
log
@Implement the FKSH functions have local scope for shell options feature
for mksh but not lksh; bump to R51-alpha.

While here, tweak build scripts a bit, fixup MirBSD-specific Makefile
things, remove part of a comment thats uninteresting.
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R51 2015/04/11
d42 1
a42 1
	@@(#)LEGACY KSH R51 2015/04/11
d8594 44
@


1.688
log
@fix IFS='\' issues, found by edualbus (Eduardo A. Bustamante Lpez <dualbus@@gmail.com>)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/20
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/20
d12105 59
@


1.687
log
@only lksh now implies unalias for a POSIX function definition (used e.g. in Debian sysvinit scripts that use a stop function)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.670 2014/11/19 18:44:09 tg Exp $
d4845 60
@


1.686
log
@use a perl test for fd-cloexec to avoid testing the tester with the tester; improve fd-cloexec description
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/13
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/13
d7525 14
d7551 14
d8730 1
a8730 1
name: alias-function-no-conflict
d8732 4
a8735 3
	make aliases not conflict with functions
	note: for ksh-like functions, the order of preference is
	different; bash outputs baz instead of bar in line 2 below
d8737 1
d8739 1
d8743 4
d8748 1
d8752 31
a8783 1
	korn
d8786 16
a8802 1
	baz
d8804 7
a8810 1
	rab
d8822 1
a8822 1
		echo ${2:-foo}
d8827 2
a8828 1
	mk 'function stop ()' stop >f-stop
@


1.685
log
@local x=$1 is supposed to not field-split and so
@
text
@a9758 2
file-setup: file 644 "test.sh"
	echo >&3 Fowl
d9760 8
a9767 2
	exec 3>&1
	"$__progname" test.sh
d9770 1
a9770 1
	/bad file descriptor/
a9775 2
file-setup: file 644 "test.sh"
	echo >&3 Fowl
d9777 9
a9785 3
	test -n "$POSH_VERSION" || set -o sh
	exec 3>&1
	"$__progname" test.sh
a9792 2
file-setup: file 644 "test.sh"
	echo >&3 Fowl
d9794 8
a9801 2
	exec 3>&1
	"$__progname" test.sh
@


1.684
log
@ protect POSIX builtins and utilities from aliases, e.g:
   :  \:
   alias  \alias
     except in some internally used cases, where we use \builtin alias
   command .  \command .
 protect Korn Shell builtins from aliases and functions, e.g:
   typeset  \builtin typeset
     also unravels the local alias used
   print  \builtin print
 protect internally-used things from aliases
   let] is not a valid function name
   set is POSIX so we dont expect anyone to override it in a function
 use command -v instead of whence -p (which) in most
  places; thanks izabera from #ed on IRC for pointing out
  that command -v is POSIX  except, whence -p always looks
  for an executable and shows its full pathname; command -v
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
 make most of dot.mkshrc work in the face of such aliases
   ulimit -c is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesnt use them?
 update list of builtin aliases in the manpage
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/08
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/08
d260 13
d7386 2
a7387 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7390 2
a7391 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7393 1
a7393 1
	nameref='\builtin typeset -n'
d7408 2
a7409 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7412 2
a7413 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7415 1
a7415 1
	nameref='\builtin typeset -n'
d7430 2
a7431 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7434 2
a7435 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7437 1
a7437 1
	nameref='\builtin typeset -n'
d7453 2
a7454 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7457 2
a7458 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7460 1
a7460 1
	nameref='\builtin typeset -n'
d7476 2
a7477 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7480 2
a7481 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7483 1
a7483 1
	nameref='\builtin typeset -n'
d7498 2
a7499 2
	autoload='\builtin typeset -fu'
	functions='\builtin typeset -f'
d7502 2
a7503 2
	integer='\builtin typeset -i'
	local='\builtin typeset'
d7505 1
a7505 1
	nameref='\builtin typeset -n'
d7566 2
a7567 2
	local='\builtin typeset'
	local='\builtin typeset'
@


1.683
log
@SECURITY: make unset HISTFILE really work

additionally, make HISTFILE= the same, document the truncation and
re-reading process further and already-known bugs; this needs work
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/07
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/07
d7373 8
a7380 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7382 4
a7385 4
	r='fc -e -'
	source='PATH=$PATH:. command .'
	stop='kill -STOP'
	type='whence -v'
d7395 8
a7402 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7404 3
a7406 27
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
---
name: aliases-2a
description:
	Check if set -o sh disables built-in aliases (except a few)
category: disabled
arguments: !-o!sh!
stdin:
	alias
	typeset -f
expected-stdout:
	integer='typeset -i'
	local=typeset
---
name: aliases-3a
description:
	Check if running as sh disables built-in aliases (except a few)
category: disabled
stdin:
	cp "$__progname" sh
	./sh -c 'alias; typeset -f'
	rm -f sh
expected-stdout:
	integer='typeset -i'
	local=typeset
d7417 8
a7424 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7426 4
a7429 4
	r='fc -e -'
	source='PATH=$PATH:. command .'
	stop='kill -STOP'
	type='whence -v'
d7440 8
a7447 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7449 4
a7452 4
	r='fc -e -'
	source='PATH=$PATH:. command .'
	stop='kill -STOP'
	type='whence -v'
d7463 8
a7470 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7472 3
a7474 3
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
d7485 8
a7492 8
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
d7494 3
a7496 3
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
d7553 2
a7554 2
	local=typeset
	local=typeset
d10156 1
a10156 1
		while let] " i < 10 " 
d10166 1
a10166 1
		x=$(i=1 ; while let] " i < 10 " ; do echo $i ; let ++i ; done ) 
d10172 1
a10172 1
		x=$(( i=1 ; while let] " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
d10179 1
a10179 1
		until let] " !--i " 
d10188 1
a10188 1
		x=$(i=10 ; until let] " !--i " ; do echo $i ; done ) 
d10194 1
a10194 1
		x=$(( i=10 ; until let] " !--i " ; do echo $i ; done ) | tr u x ) 
d10570 1
a10570 1
			set -A c+ -- d e 
d10580 1
a10580 1
		x=$(case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) 
d10588 1
a10588 1
		x=$(( case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) | tr u x ) 
d10808 1
a10808 1
		while let] " i < 10 " >&3 
d10818 1
a10818 1
		x=$(i=1 ; while let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
d10824 1
a10824 1
		x=$(( i=1 ; while let] " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
d10831 1
a10831 1
		until let] " !--i " >&3 
d10840 1
a10840 1
		x=$(i=10 ; until let] " !--i " >&3 ; do echo $i ; done >&3 ) 
d10846 1
a10846 1
		x=$(( i=10 ; until let] " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
@


1.682
log
@keep set -x disabled during PS4 expansion, to avoid infinite looping
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/02
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/02
@


1.681
log
@can't set word=IFS_QUOTE if already IFS_WORD (something there)
or IFS_QUOTE (third dquote (second OQUOTE) in """something)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/02/20
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/02/20
d11933 23
@


1.680
log
@ fixup here document expansion (regression wrt. pdksh 5.2.14)
 adjust testsuite (and write tons of new tests) after todays commits
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/02/19
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/02/19
d8447 16
d8466 12
@


1.679
log
@oksh sync; unsure if it applies (with us using old_source and all) but
better be safe than sorry; it at least passes our testsuite

NOTE: people who can figure out how afl can be used for mksh welcome! ;-)
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/02/13
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/02/13
d2483 45
a4288 1
expected-fail: yes
d4292 24
d8413 15
a8427 7
	print x ${a} ${b} y
	print z ${a#?} ${b%?} w
	print v ${a=} ${b/c/d} u
expected-stdout:
	x y
	z w
	v u
a8446 1
expected-fail: yes
@


1.678
log
@add getopts for exec (unbreaks exec -- /bin/ls) and steal -a and -c from ksh93
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/02/06
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/02/06
@


1.677
log
@rcsid sync from obsd; misc sync; small improvements
 mksh testsuite no longer uses printf, again
 use MAXPATHLEN from <sys/param.h> as PATH_MAX fallback
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/01/25
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/01/25
@


1.676
log
@better
@
text
@d5 1
a5 1
#	      2011, 2012, 2013, 2014
d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/01/04
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/01/04
d3617 1
a3617 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3624 4
a3627 4
	 <1> <A> <B> <C>
	 <2> <A B C>
	 <3> <A> <B> <C>
	 <4> <A> <B> <C>
d3633 1
a3633 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3641 4
a3644 4
	 <1> <A> <B> <C>
	 <2> <A:B:C>
	 <3> <A> <B> <C>
	 <4> <A> <B> <C>
d3650 1
a3650 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3658 4
a3661 4
	 <1> <A> <B> <C>
	 <2> <ABC>
	 <3> <A> <B> <C>
	 <4> <A> <B> <C>
d3667 1
a3667 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3676 5
a3680 5
	 <1>
	 <2> <>
	 <3>
	 <4>
	 <5> <:>
d3687 1
a3687 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3692 1
a3692 1
	 <:>
d3698 1
a3698 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3703 1
a3703 1
	
d3710 1
a3710 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3715 1
a3715 1
	 <>
d3721 1
a3721 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3743 2
a3744 2
	 <3> <> <b> <>
	 <4> <:b::>
d3746 1
a3746 1
	 <6> <a> <b>
d3748 1
a3748 1
	 <8> <a> <> <c>
d3750 2
a3751 2
	 <10> <h> <ith> <ere>
	 <11> <h:ith:ere>
d3753 1
a3753 1
	 <13> <A> <B> <> <D>
d3759 1
a3759 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3763 1
a3763 1
	 <1> <shift> <1> <2>
d3770 1
a3770 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3777 3
a3779 3
	 <0>
	 <1> <> <foo> <bar>
	 <2> <foo> <bar>
d3785 1
a3785 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d3792 3
a3794 3
	 <0> <x=>
	 <1> <x=> <foo> <bar>
	 <2> <x=> <foo> <bar>
d3811 1
d3816 1
a3816 1
	printf '<%s>\n' "$*" $* "$q" "$nq"
d3835 1
d3840 1
a3840 1
	printf '<%s>\n' "$*" $* "$q" "$nq"
d3859 1
d3867 8
a3874 8
	printf '= qs '; printf '<%s>\n' "$qs"
	printf '=nqs '; printf '<%s>\n' "$nqs"
	printf '= qk '; printf '<%s>\n' "$qk"
	printf '=nqk '; printf '<%s>\n' "$nqk"
	printf '~ qs '; printf '<%s>\n' "$*"
	printf '~nqs '; printf '<%s>\n' $*
	printf '~ qk '; printf '<%s>\n' "$@@"
	printf '~nqk '; printf '<%s>\n' $@@
d3903 1
d3908 2
a3909 2
	printf '= qs '; printf '<%s>\n' "$qs"
	printf '~ qs '; printf '<%s>\n' "$*"
d3911 2
a3912 2
	printf '=nqs '; printf '<%s>\n' "$nqs"
	printf '~nqs '; printf '<%s>\n' $*
d3914 2
a3915 2
	printf '= qk '; printf '<%s>\n' "$qk"
	printf '~ qk '; printf '<%s>\n' "$@@"
d3917 2
a3918 2
	printf '=nqk '; printf '<%s>\n' "$nqk"
	printf '~nqk '; printf '<%s>\n' $@@
d3947 1
d3953 2
a3954 2
	printf '= qs '; printf '<%s>\n' "$qs"
	printf '~ qs '; printf '<%s>\n' ${v:-"$*"}
d3956 2
a3957 2
	printf '=nqs '; printf '<%s>\n' "$nqs"
	printf '~nqs '; printf '<%s>\n' ${v:-$*}
d3959 2
a3960 2
	printf '= qk '; printf '<%s>\n' "$qk"
	printf '~ qk '; printf '<%s>\n' ${v:-"$@@"}
d3962 2
a3963 2
	printf '=nqk '; printf '<%s>\n' "$nqk"
	printf '~nqk '; printf '<%s>\n' ${v:-$@@}
d3992 1
d3997 2
a3998 2
	printf '= qs '; printf '<%s>\n' "$qs"
	printf '~ qs '; printf '<%s>\n' "$*"
d4000 2
a4001 2
	printf '=nqs '; printf '<%s>\n' "$nqs"
	printf '~nqs '; printf '<%s>\n' $*
d4003 2
a4004 2
	printf '= qk '; printf '<%s>\n' "$qk"
	printf '~ qk '; printf '<%s>\n' "$@@"
d4006 2
a4007 2
	printf '=nqk '; printf '<%s>\n' "$nqk"
	printf '~nqk '; printf '<%s>\n' $@@
d4036 1
d4042 2
a4043 2
	printf '= qs '; printf '<%s>\n' "$qs"
	printf '~ qs '; printf '<%s>\n' ${v:-"$*"}
d4045 2
a4046 2
	printf '=nqs '; printf '<%s>\n' "$nqs"
	printf '~nqs '; printf '<%s>\n' ${v:-$*}
d4048 2
a4049 2
	printf '= qk '; printf '<%s>\n' "$qk"
	printf '~ qk '; printf '<%s>\n' ${v:-"$@@"}
d4051 2
a4052 2
	printf '=nqk '; printf '<%s>\n' "$nqk"
	printf '~nqk '; printf '<%s>\n' ${v:-$@@}
d4093 2
a4094 1
	"$__progname" -c 'IFS=; set -- "" 2 ""; printf "[%s]\n" $*; x=$*; printf "<%s>\n" "$x"'
d4096 2
a4097 1
	"$__progname" -c 'IFS=; set -- "" 2 ""; printf "[%s]\n" "$*"; x="$*"; printf "<%s>\n" "$x"'
d4099 2
a4100 1
	"$__progname" -c 'IFS=; set -- "" 2 ""; printf "[%s]\n" $@@; x=$@@; printf "<%s>\n" "$x"'
d4102 2
a4103 1
	"$__progname" -c 'IFS=; set -- "" 2 ""; printf "[%s]\n" "$@@"; x="$@@"; printf "<%s>\n" "$x"'
d4105 2
a4106 1
	"$__progname" -c 'IFS=,; set -- "" 2 ""; printf "[%s]\n" $*; x=$*; printf "<%s>\n" "$x"'
d4108 2
a4109 1
	"$__progname" -c 'IFS=,; set -- "" 2 ""; printf "[%s]\n" "$*"; x="$*"; printf "<%s>\n" "$x"'
d4111 2
a4112 1
	"$__progname" -c 'IFS=,; set -- "" 2 ""; printf "[%s]\n" $@@; x=$@@; printf "<%s>\n" "$x"'
d4114 2
a4115 1
	"$__progname" -c 'IFS=,; set -- "" 2 ""; printf "[%s]\n" "$@@"; x="$@@"; printf "<%s>\n" "$x"'
d4117 2
a4118 1
	"$__progname" -c 'IFS=; set -- A B "" "" C; printf "[%s]\n" $*; x=$*; printf "<%s>\n" "$x"'
d4120 2
a4121 1
	"$__progname" -c 'IFS=; set -- A B "" "" C; printf "[%s]\n" "$*"; x="$*"; printf "<%s>\n" "$x"'
d4123 2
a4124 1
	"$__progname" -c 'IFS=; set -- A B "" "" C; printf "[%s]\n" $@@; x=$@@; printf "<%s>\n" "$x"'
d4126 2
a4127 1
	"$__progname" -c 'IFS=; set -- A B "" "" C; printf "[%s]\n" "$@@"; x="$@@"; printf "<%s>\n" "$x"'
d4129 2
a4130 1
	"$__progname" -c 'IFS=,; set -- A B "" "" C; printf "[%s]\n" $*; x=$*; printf "<%s>\n" "$x"'
d4132 2
a4133 1
	"$__progname" -c 'IFS=,; set -- A B "" "" C; printf "[%s]\n" "$*"; x="$*"; printf "<%s>\n" "$x"'
d4135 2
a4136 1
	"$__progname" -c 'IFS=,; set -- A B "" "" C; printf "[%s]\n" $@@; x=$@@; printf "<%s>\n" "$x"'
d4138 2
a4139 1
	"$__progname" -c 'IFS=,; set -- A B "" "" C; printf "[%s]\n" "$@@"; x="$@@"; printf "<%s>\n" "$x"'
d4219 1
a4219 1
	showargs() { for x in "$@@"; do echo -n "<$x> "; done; echo .; }
d4231 1
a4231 1
	showargs() { for x in "$@@"; do echo -n "<$x> "; done; echo .; }
d4254 1
a4254 1
	showargs() { for x in "$@@"; do echo -n "<$x> "; done; echo .; }
d8368 1
a8368 1
	showargs() { for i; do echo -n " <$i>"; done; echo; }
d8373 2
a8374 2
	 <1> <>
	 <2> <>
@


1.675
log
@add an Ohcount modeline to recognise this as sh file
@
text
@d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/01/02
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/01/02
@


1.674
log
@bump version and, also, year I hate this 2014 is gonna follow us for a while
@
text
@d2 1
a2 1
# OpenBSD src/regress/bin/ksh updated: 2013/12/02 20:39:44
d28 3
@


1.673
log
@OpenBSD RCSID merge, and logical follow one change:
handle unknown bases as ksh93 does: larger downgrade to 10
(although our max will stay 36, as ksh93 doesnt have upper/lowecase)
and smaller downgrade for typeset -i, but not for arithmetics
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/12/15
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/12/15
@


1.672
log
@fix here string parsing problem found by Stphane Chazelas
@
text
@d4457 1
a4457 1
	Check behaviour for base one to 36, and that 37 errors out
d4461 1
a4461 1
	while (( ++i <= 36 )); do
d4502 2
a4503 3
	37:.0:
expected-stderr-pattern:
	/.*bad number '37#10'/
d4507 1
a4507 1
	Check behaviour for base one to 36, and that 37 errors out
d4552 1
a4552 3
	37:36#1S.64.
expected-stderr-pattern:
	/.*bad integer base: 37/
@


1.671
log
@ Build.sh: fix NSIG detection for gcc-snapshot
 all: bump version to R50-current; add more comments; whitespace
 all: remove all mkssert(); well do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
 check.t: fix a testcase (sed could exit false, but we dont care)
 eval.c: fix tilde_ok data type (only unsigned may shl constantly)
 exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/11/25
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/11/25
d2362 8
@


1.670
log
@fix buffer overflow found by zacts from IRC (bad length calculation)
now zsh and mksh are even :|
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.669 2014/11/14 20:21:27 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/11/19
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/11/19
d7144 1
d11064 1
@


1.669
log
@mark two ($@@/$* expansion-related) testcases as expected-fail, with more to come 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667 2014/10/19 22:26:13 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/11/14
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/11/14
@


1.668
log
@printf is the wrong tool, use showargs

XXX probably not all right, discussion ongoing:
    http://thread.gmane.org/gmane.comp.standards.posix.austin.general/9972
XXX change all tests to not use printf again
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/10/19
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/10/19
d4073 1
d4205 9
d8337 1
a8337 1
	x=; showargs 1 "$x$@@"
d8339 1
d8341 1
a8341 1
	 <1>
@


1.667
log
@oh well, new test location (10x jilles)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.664 2014/10/19 20:56:30 tg Exp $
a8324 1
	although the line 2<> is probably wrong? XNULLSUB case.
d8326 3
a8328 2
	x=; printf "1<%s>\n" "$x$@@"
	set A; printf "2<%s>\n" "${@@:+}"
d8330 2
a8331 2
	1<>
	2<>
@


1.667.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
 pull check.t,v up to 1.672 from 1.667
 pull dot.mkshrc,v up to 1.91 from 1.89
 pull edit.c,v up to 1.277 from 1.276
 pull exec.c,v up to 1.139 from 1.137
 pull lex.c,v up to 1.195 from 1.193
 pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
 apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
 apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after whence -v with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.672 2014/12/15 22:50:08 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2015/01/11
d39 1
a39 1
	@@(#)LEGACY KSH R50 2015/01/11
a2361 8
name: heredoc-9f
description:
	Check long here strings
stdin:
	cat <<< "$(  :                                                             )aa"
expected-stdout:
	aa
---
a4072 1
	!!WARNING!! more to come: http://austingroupbugs.net/view.php?id=888
a4203 9
name: IFS-subst-8
description:
	http://austingroupbugs.net/view.php?id=221
stdin:
	n() { echo "$#"; }; n "${foo-$@@}"
expected-fail: yes
expected-stdout:
	1
---
a7133 1
	XXX fails when LD_PRELOAD is set with -e and Perl chokes it (ASan)
d8325 1
d8327 2
a8328 4
	showargs() { for i; do echo -n " <$i>"; done; echo; }
	x=; showargs 1 "$x"$@@
	set A; showargs 2 "${@@:+}"
expected-fail: yes
d8330 2
a8331 2
	 <1> <>
	 <2> <>
a11051 1
	exit ${PIPESTATUS[0]}
@


1.667.2.2
log
@MFC:
 portability improvements and bugfixes (ptrdiff_t  size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
 drop old/useless asserts
 manpage fixes
 missing brace in syn.c
@
text
@d1 2
a2 2
# $MirOS: src/bin/mksh/check.t,v 1.667.2.1 2015/01/11 22:39:40 tg Exp $
# -*- mode: sh -*-
d5 1
a5 1
#	      2011, 2012, 2013, 2014, 2015
a27 3
#
# Integrated testsuites from:
# (2013/12/02 20:39:44) http://openbsd.cs.toronto.edu/cgi-bin/cvsweb/src/regress/bin/ksh/?sortby=date
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2015/01/24
d39 1
a39 1
	@@(#)LEGACY KSH R50 2015/01/24
d3614 1
a3614 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3621 4
a3624 4
	<1> <A> <B> <C> .
	<2> <A B C> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
d3630 1
a3630 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3638 4
a3641 4
	<1> <A> <B> <C> .
	<2> <A:B:C> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
d3647 1
a3647 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3655 4
a3658 4
	<1> <A> <B> <C> .
	<2> <ABC> .
	<3> <A> <B> <C> .
	<4> <A> <B> <C> .
d3664 1
a3664 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3673 5
a3677 5
	<1> .
	<2> <> .
	<3> .
	<4> .
	<5> <:> .
d3684 1
a3684 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3689 1
a3689 1
	<:> .
d3695 1
a3695 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3700 1
a3700 1
	.
d3707 1
a3707 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3712 1
a3712 1
	<> .
d3718 1
a3718 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3740 2
a3741 2
	<3> <> <b> <> .
	<4> <:b::> .
d3743 1
a3743 1
	<6> <a> <b> .
d3745 1
a3745 1
	<8> <a> <> <c> .
d3747 2
a3748 2
	<10> <h> <ith> <ere> .
	<11> <h:ith:ere> .
d3750 1
a3750 1
	<13> <A> <B> <> <D> .
d3756 1
a3756 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3760 1
a3760 1
	<1> <shift> <1> <2> .
d3767 1
a3767 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3774 3
a3776 3
	<0> .
	<1> <> <foo> <bar> .
	<2> <foo> <bar> .
d3782 1
a3782 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d3789 3
a3791 3
	<0> <x=> .
	<1> <x=> <foo> <bar> .
	<2> <x=> <foo> <bar> .
a3807 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3812 1
a3812 1
	pfn "$*" $* "$q" "$nq"
a3830 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3835 1
a3835 1
	pfn "$*" $* "$q" "$nq"
a3853 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3861 8
a3868 8
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~ qs '; pfn "$*"
	print -nr -- '~nqs '; pfn $*
	print -nr -- '~ qk '; pfn "$@@"
	print -nr -- '~nqk '; pfn $@@
a3896 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3901 2
a3902 2
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn "$*"
d3904 2
a3905 2
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn $*
d3907 2
a3908 2
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn "$@@"
d3910 2
a3911 2
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn $@@
a3939 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3945 2
a3946 2
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn ${v:-"$*"}
d3948 2
a3949 2
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn ${v:-$*}
d3951 2
a3952 2
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn ${v:-"$@@"}
d3954 2
a3955 2
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn ${v:-$@@}
a3983 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d3988 2
a3989 2
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn "$*"
d3991 2
a3992 2
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn $*
d3994 2
a3995 2
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn "$@@"
d3997 2
a3998 2
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn $@@
a4026 1
	pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; }
d4032 2
a4033 2
	print -nr -- '= qs '; pfn "$qs"
	print -nr -- '~ qs '; pfn ${v:-"$*"}
d4035 2
a4036 2
	print -nr -- '=nqs '; pfn "$nqs"
	print -nr -- '~nqs '; pfn ${v:-$*}
d4038 2
a4039 2
	print -nr -- '= qk '; pfn "$qk"
	print -nr -- '~ qk '; pfn ${v:-"$@@"}
d4041 2
a4042 2
	print -nr -- '=nqk '; pfn "$nqk"
	print -nr -- '~nqk '; pfn ${v:-$@@}
d4083 1
a4083 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb $*; x=$*; pfn "$x"'
d4085 1
a4085 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb "$*"; x="$*"; pfn "$x"'
d4087 1
a4087 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb $@@; x=$@@; pfn "$x"'
d4089 1
a4089 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- "" 2 ""; pfb "$@@"; x="$@@"; pfn "$x"'
d4091 1
a4091 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb $*; x=$*; pfn "$x"'
d4093 1
a4093 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb "$*"; x="$*"; pfn "$x"'
d4095 1
a4095 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb $@@; x=$@@; pfn "$x"'
d4097 1
a4097 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- "" 2 ""; pfb "$@@"; x="$@@"; pfn "$x"'
d4099 1
a4099 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb $*; x=$*; pfn "$x"'
d4101 1
a4101 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb "$*"; x="$*"; pfn "$x"'
d4103 1
a4103 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb $@@; x=$@@; pfn "$x"'
d4105 1
a4105 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=; set -- A B "" "" C; pfb "$@@"; x="$@@"; pfn "$x"'
d4107 1
a4107 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb $*; x=$*; pfn "$x"'
d4109 1
a4109 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb "$*"; x="$*"; pfn "$x"'
d4111 1
a4111 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb $@@; x=$@@; pfn "$x"'
d4113 1
a4113 2
	"$__progname" -c 'pfb() { for s_arg in "$@@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@@"; do print -r -- "<$s_arg>"; done; };
		IFS=,; set -- A B "" "" C; pfb "$@@"; x="$@@"; pfn "$x"'
d4193 1
a4193 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d4205 1
a4205 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d4228 1
a4228 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d8345 1
a8345 1
	showargs() { for s_arg in "$@@"; do echo -n "<$s_arg> "; done; echo .; }
d8350 2
a8351 2
	<1> <> .
	<2> <> .
@


1.667.2.3
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667.2.2 2015/01/25 15:35:36 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/01
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/01
a2482 45
name: heredoc-12
description:
	Check here documents can use $* and $@@; note shells vary:
	 pdksh 5.2.14 acts the same
	 dash has 1 and 2 the same but 3 lacks the space
	 ksh93, bash4 differ in 2 by using space ipv colon
stdin:
	set -- a b
	nl='
	'
	IFS=" 	$nl"; n=1
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
	IFS=":"; n=2
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
	IFS=; n=3
	cat <<EOF
	$n foo $* foo
	$n bar "$*" bar
	$n baz $@@ baz
	$n bla "$@@" bla
	EOF
expected-stdout:
	1 foo a b foo
	1 bar "a b" bar
	1 baz a b baz
	1 bla "a b" bla
	2 foo a:b foo
	2 bar "a:b" bar
	2 baz a:b baz
	2 bla "a:b" bla
	3 foo a b foo
	3 bar "a b" bar
	3 baz a b baz
	3 bla "a b" bla
---
d4244 1
a4247 24
name: IFS-subst-9
description:
	Scalar context for $*/$@@ in [[ and case
stdin:
	"$__progname" -c 'IFS=; set a b; [[ $* = "$1$2" ]]; echo 1 $?' sh a b
	"$__progname" -c 'IFS=; [[ $* = ab ]]; echo 2 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$*" = ab ]]; echo 3 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ $* = a ]]; echo 4 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$*" = a ]]; echo 5 "$?"' sh a b
	"$__progname" -c 'IFS=; [[ "$@@" = a ]]; echo 6 "$?"' sh a b
	"$__progname" -c 'IFS=; case "$@@" in a) echo 7 a;; ab) echo 7 b;; a\ b) echo 7 ok;; esac' sh a b
	"$__progname" -c 'IFS=; case $* in a) echo 8 a;; ab) echo 8 ok;; esac' sh a b
	"$__progname" -c 'pfsp() { for s_arg in "$@@"; do print -nr -- "<$s_arg> "; done; print .; }; IFS=; star=$* at="$@@"; pfsp 9 "$star" "$at"' sh a b
expected-stdout:
	1 0
	2 0
	3 0
	4 1
	5 1
	6 1
	7 ok
	8 ok
	<9> <ab> <a b> .
---
d8348 7
a8354 15
	print s ${a} . ${b} S
	print t ${a#?} . ${b%?} T
	print r ${a=} . ${b/c/d} R
	print q
	print s "${a}" . "${b}" S
	print t "${a#?}" . "${b%?}" T
	print r "${a=}" . "${b/c/d}" R
expected-stdout:
	s . S
	t . T
	r . R
	q
	s  .  S
	t  .  T
	r  .  R
d8374 1
a8374 16
	n() { echo "$#"; }
	unset e
	set -- a b
	n """$@@"
	n "$@@"
	n "$@@"""
	n "$e""$@@"
	n "$@@"
	n "$@@""$e"
	set --
	n """$@@"
	n "$@@"
	n "$@@"""
	n "$e""$@@"
	n "$@@"
	n "$@@""$e"
a8377 12
	2
	2
	2
	2
	2
	2
	1
	0
	1
	1
	0
	1
a11832 23
name: xtrace-2
description:
	Check that "set -x" is off during PS4 expansion
stdin:
	f() {
		print -n "(f1:$-)"
		set -x
		print -n "(f2:$-)"
	}
	PS4='[(p:$-)$(f)] '
	print "(o0:$-)"
	set -x -o inherit-xtrace
	print "(o1:$-)"
	set +x
	print "(o2:$-)"
expected-stdout:
	(o0:sh)
	(o1:shx)
	(o2:sh)
expected-stderr:
	[(p:sh)(f1:sh)(f2:sh)] print '(o1:shx)'
	[(p:sh)(f1:sh)(f2:sh)] set +x
---
@


1.667.2.4
log
@MFC most of mksh-current into R50-stable:
 alias protection of local=\typeset
 use of command -v in dot.mkshrc
 oksh RCSID sync, where appropriate
 fix read -n-1
 SECURITY (privacy): make unset HISTFILE work
 strip_nuls() rewrite
 manpage fixes and improvements and replacement hook
 dead constant elimination
remaining differences:
 integer-base interpretation change
 default alias protection
 dot.mkshrc enable support
 j_waitj() refactoring
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667.2.3 2015/03/01 15:42:51 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/03/19
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/03/19
a259 13
name: alias-11
description:
	Check that special argument handling still applies with escaped aliases
stdin:
	alias local='\typeset'
	function foo {
		local x=$1 y=z
		print -r -- "$x,$y"
	}
	foo 'bar - baz'
expected-stdout:
	bar - baz,z
---
@


1.667.2.5
log
@sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667.2.4 2015/03/20 22:20:53 tg Exp $
d8762 1
a8762 1
		print -r -- "${2:-foo}"
d8767 1
a8767 2
	# pre-R51 can do without a backslash in front of the second stop
	mk 'function stop ()' 'stop' >f-stop
d9786 2
d9789 2
a9790 8
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
d9793 1
a9793 1
	/E: open /
d9799 2
d9802 3
a9804 9
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	test -n "$POSH_VERSION" || set -o posix
	exec 9>&1
	./cld
d9812 2
d9815 2
a9816 8
	cat >cld <<-EOF
		#!$__perlname
		open(my \$fh, ">&", 9) or die "E: open \$!";
		syswrite(\$fh, "Fowl\\n", 5) or die "E: write \$!";
	EOF
	chmod +x cld
	exec 9>&1
	./cld
@


1.667.2.6
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667.2.5 2015/03/21 00:12:36 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/04/12
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/04/12
a4847 60
name: read-IFS-2
description:
	Complex tests, IFS either colon (IFS-NWS) or backslash (tricky)
stdin:
	n=0
	showargs() { print -nr "$1"; shift; for s_arg in "$@@"; do print -nr -- " [$s_arg]"; done; print; }
	(IFS=\\ a=\<\\\>; showargs 3 $a)
	(IFS=: b=\<:\>; showargs 4 $b)
	print -r '<\>' | (IFS=\\ read f g; showargs 5 "$f" "$g")
	print -r '<\\>' | (IFS=\\ read f g; showargs 6 "$f" "$g")
	print '<\\\n>' | (IFS=\\ read f g; showargs 7 "$f" "$g")
	print -r '<\>' | (IFS=\\ read f; showargs 8 "$f")
	print -r '<\\>' | (IFS=\\ read f; showargs 9 "$f")
	print '<\\\n>' | (IFS=\\ read f; showargs 10 "$f")
	print -r '<\>' | (IFS=\\ read -r f g; showargs 11 "$f" "$g")
	print -r '<\\>' | (IFS=\\ read -r f g; showargs 12 "$f" "$g")
	print '<\\\n>' | (IFS=\\ read -r f g; showargs 13 "$f" "$g")
	print -r '<\>' | (IFS=\\ read -r f; showargs 14 "$f")
	print -r '<\\>' | (IFS=\\ read -r f; showargs 15 "$f")
	print '<\\\n>' | (IFS=\\ read -r f; showargs 16 "$f")
	print -r '<:>' | (IFS=: read f g; showargs 17 "$f" "$g")
	print -r '<::>' | (IFS=: read f g; showargs 18 "$f" "$g")
	print '<:\n>' | (IFS=: read f g; showargs 19 "$f" "$g")
	print -r '<:>' | (IFS=: read f; showargs 20 "$f")
	print -r '<::>' | (IFS=: read f; showargs 21 "$f")
	print '<:\n>' | (IFS=: read f; showargs 22 "$f")
	print -r '<:>' | (IFS=: read -r f g; showargs 23 "$f" "$g")
	print -r '<::>' | (IFS=: read -r f g; showargs 24 "$f" "$g")
	print '<:\n>' | (IFS=: read -r f g; showargs 25 "$f" "$g")
	print -r '<:>' | (IFS=: read -r f; showargs 26 "$f")
	print -r '<::>' | (IFS=: read -r f; showargs 27 "$f")
	print '<:\n>' | (IFS=: read -r f; showargs 28 "$f")
expected-stdout:
	3 [<] [>]
	4 [<] [>]
	5 [<] [>]
	6 [<] [>]
	7 [<>] []
	8 [<>]
	9 [<\>]
	10 [<>]
	11 [<] [>]
	12 [<] [\>]
	13 [<] []
	14 [<\>]
	15 [<\\>]
	16 [<]
	17 [<] [>]
	18 [<] [:>]
	19 [<] []
	20 [<:>]
	21 [<::>]
	22 [<]
	23 [<] [>]
	24 [<] [:>]
	25 [<] []
	26 [<:>]
	27 [<::>]
	28 [<]
---
a11984 58
name: fksh-flags
description:
	Check that FKSH functions have their own shell flags
category: mksh-next
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	function foo {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 fh .
---
name: fksh-flags-legacy
description:
	Check that even FKSH functions share the shell flags
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
name: fsh-flags
description:
	Check that !FKSH functions share the shell flags
stdin:
	[[ $KSH_VERSION = Version* ]] && set +B
	foo() {
		set +f
		set -e
		echo 2 "${-/s}" .
	}
	set -fh
	echo 1 "${-/s}" .
	foo
	echo 3 "${-/s}" .
expected-stdout:
	1 fh .
	2 eh .
	3 eh .
---
@


1.667.2.7
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.667.2.6 2015/04/12 22:32:17 tg Exp $
d33 1
a33 1
	@@(#)MIRBSD KSH R50 2015/04/19
d42 1
a42 1
	@@(#)LEGACY KSH R50 2015/04/19
a8592 44
name: print-crlf
description:
	Check that CR+LF is shown and read as-is
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[<bar
	>]
	{<bar}
---
name: print-lf
description:
	Check that LF-only is shown and read as-is
stdin:
	cat >foo <<-'EOF'
		x='bar
		' #
		if test x"$KSH_VERSION" = x""; then #
			printf '<%s>' "$x" #
		else #
			print -nr -- "<$x>" #
		fi #
	EOF
	echo "[$("$__progname" foo)]"
	"$__progname" foo | while IFS= read -r line; do
		print -r -- "{$line}"
	done
expected-stdout:
	[<bar
	>]
	{<bar}
---
d8789 1
a8789 1
name: alias-function-no-conflict-legacy
d8791 3
a8793 3
	make aliases not conflict with functions, legacy version:
	undefine these aliases upon definition of the function
	note: for ksh functions, the order of preference differs in GNU bash
a8794 1
	# POSIX function overrides and removes alias
a8795 1
	foo
a8798 4
	foo
	unset -f foo
	foo 2>/dev/null || echo rab
	# alias overrides ksh function
a8799 1
	korn
d8803 1
d8805 2
a8806 9
	# alias temporarily overrides POSIX function
	bla() {
		echo bfn
	}
	bla
	alias bla='echo bal'
	bla
	unalias bla
	bla
d8808 1
a8809 1
	baz
a8810 5
	bar
	bar
	bfn
	bal
	bfn
d12045 20
@


1.666
log
@first cut at LP#1381993 (probably incomplete) plus test coverage
also remove fbsd testsuite link, its gone during cvssvn of theirs 
@
text
@d25 3
@


1.665
log
@better fix
@
text
@a24 3
#
# More testsuites at:
# http://www.freebsd.org/cgi/cvsweb.cgi/src/tools/regression/bin/test/regress.sh?rev=HEAD
d4177 24
@


1.664
log
@commit patch from LP#1381965 and two testcases, one showing this is fixed,
another showing deeper problems (probably LP#1381993 non-list contexts or
the IFS_WS/IFS_IWS story, perhaps *all* IFS_WS (not just ternaries) really
should be IFS_IWS instead?)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.663 2014/10/12 19:54:58 tg Exp $
a3772 1
expected-fail: yes
@


1.663
log
@fix x+=<<
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.662 2014/10/10 22:10:19 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/10/12
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/10/12
d3754 1
a3754 1
name: IFS-subst-3
d3770 27
@


1.662
log
@indeed, GNU bash (at least bash2 from MirPorts which I have at hand)
fails this test I found debugging https://bugs.gentoo.org/500942
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.661 2014/10/07 15:22:14 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/10/07
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/10/07
d2392 8
d2415 1
d2445 8
d2470 1
@


1.661
log
@fix severe regression in field splitting (LP#1378208)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.660 2014/10/04 11:47:16 tg Exp $
d8016 60
@


1.660
log
@fix null pointer deref on empty nameref assignment (no =)
found by Goodbox on IRC
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.659 2014/10/03 17:32:09 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/10/04
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/10/04
d3739 1
d3742 1
d3745 2
d3748 1
d3750 1
@


1.659
log
@overhaul IFS handling, fix bugs reported by Stephane Chazelas and mikeserv

now were at: 486 passed testsuite items, 0 failed
ifs.sh still: # tests 6856 passed 6856 failed 0
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.658 2014/09/03 19:22:49 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/10/03
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/10/03
@


1.658
log
@permit $1, $!, etc. to be namerefd again ($_ was); spotted by Jb_boin, 10x!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.657 2014/07/29 17:56:31 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/09/03
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/09/03
a3738 1
expected-fail: yes
d3746 384
d8188 11
@


1.657
log
@add testcase for todays mailing list bug report
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.655 2014/07/13 11:34:26 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/07/28
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/07/28
@


1.656
log
@https://android-review.googlesource.com/102253

 permit interrupts during a write(2) loop in the cat builtin, too,
  not just in the read(2) loop  fixes inability to kill a clogged
  output cat

 kill the cat when smores finish

TODO: revisit this  in more depth,  for other functions, such as
      hd, and  test on AOSP as well
@
text
@d3736 11
@


1.655
log
@fix rare infinite loop when invalid UTF-8 is in the edit buffer
From: Ivan Colona Delalande <colona@@ycc.fr>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.652 2014/06/10 22:17:07 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/07/13
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/07/13
@


1.654
log
@fix access-after-free crash spotted by Enjolras via IRC, thanks!
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/06/29
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/06/29
@


1.653
log
@bump
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/06/24
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/06/24
@


1.652
log
@fix set -o pipefail w/o PIPESTATUS, and PIPESTATUS inside COMSUBs and other sequences
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.651 2014/06/09 13:25:50 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/06/10
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/06/10
@


1.651
log
@fix some of the signal stuff (still didnt get rid of awk(1) and printf(1)
calls in Build.sh, we need HOSTCC for that which we should do, using BER
or something encoded for integers, and pregenerated hashtables as planned)

also, bump to R50 beta, due to todays language changes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.647 2014/05/29 21:30:45 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R50 2014/06/09
d39 1
a39 1
	@@(#)LEGACY KSH R50 2014/06/09
d6516 1
d6526 1
@


1.650
log
@LANGUAGE CHANGE: $(()) results are now IFS-split, as per POSIX 201x
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R49 2014/05/27
d39 1
a39 1
	@@(#)LEGACY KSH R49 2014/05/27
@


1.649
log
@SYNTAX CHANGE: remove x=([2]=foo [5]=bar) due to regressions
@
text
@a3738 1
expected-fail: yes
@


1.648
log
@next attempt at fixing IFS-subst-2
@
text
@d7070 2
a7071 10
expected-stdout:
	5|a|$v|c d||$v|b|
---
name: arrays-4-nopos
description:
	Check that we do not break assignment
	This is a regression against R20
	Possibly take out specified indics until resolved!
expected-fail: yes
stdin:
d7075 1
d7081 2
d7090 1
a7090 10
expected-stdout:
	5|a|$v|c d||$v|b|
	k= 128 129 130 .
	v= foo bar baz .
---
name: arrays-5-glob
description:
	Check that we do not break this by globbing
expected-fail: yes
stdin:
d7097 3
d7261 1
a7261 1
	unset foo; foo=([2]=foo [0]=bar); foo+=(baz [5]=quux); echo 3 ${!foo[*]} : ${foo[*]} .
d7265 1
a7265 1
	3 0 2 3 5 : bar foo baz quux .
@


1.647
log
@bugreport about x=([y]=z) from ormaaj and jilles, via #ksh on IRC
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.645 2014/05/27 13:00:31 tg Exp $
a3728 1
expected-fail: yes
@


1.646
log
@fix LP#1277691 (nameref RHS not syntax checked) and the inability to
use errorf() while nameref states were being changed (by almost completely
eliminating the global variable) and the readonly first array variable
bypass (typo/refactoro); also, whitespace, one int  bool, and add a
comment wrt. the parser rewrite talked about with igli during a fever ;)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.644 2014/04/29 07:43:38 tg Exp $
d7074 12
d7101 13
@


1.645
log
@fix ${!foo} for when foo is unset
@
text
@d30 1
a30 1
	@@(#)MIRBSD KSH R49 2014/01/16
d39 1
a39 1
	@@(#)LEGACY KSH R49 2014/01/16
a5490 1
expected-fail: yes
@


1.644
log
@POSIX clarification leads to ugly new bug (expected-fail, for now)
thanks ormaaj for noticing and forwarding to me
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.643 2014/02/09 00:08:17 tg Exp $
a7149 3
	!arz: 0
	!arz[0]:
	!arz[1]:
d7151 8
a7158 5
	!arz[0]: 0
	!arz[1]:
	!arz: 0
	!arz[0]:
	!arz[1]:
d10567 1
a10567 1
	!ind[1]: 1
@


1.643
log
@document known readonly bug from <52EFA07D.3010904@@posteo.de>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.642 2014/02/08 20:20:32 tg Exp $
d3737 13
@


1.642
log
@add a testcase specifically designed to check for noexec; spotted by gentoo/developer/Polynomial-C
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.641 2014/01/22 19:53:50 tg Exp $
d5475 13
@


1.641
log
@this was missed
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.640 2014/01/11 18:09:37 tg Exp $
d73 12
@


1.640
log
@ use BAFH for hash ipv NZAAT
 prep for release
 fix minor nits in manpage and tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.639 2014/01/05 21:57:22 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R49 2014/01/11
d39 1
a39 1
	@@(#)LEGACY KSH R49 2014/01/11
@


1.639
log
@ fix ${12345678901234567890} segfault (OOB access / integer overflow)
   not like oksh did, but using mkshs built-in features
 handle suggested __pure additions
 revert cid 1004F7F096867C83CF0
   always use our wcwidth code
   only use our strlcpy code if none found
 fix a couple of gcc-snapshot and clang/scan-build warnings
 mksh R49~rc1
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.636 2013/11/30 00:20:46 tg Exp $
d30 1
a30 1
	@@(#)MIRBSD KSH R49 2014/01/05
d39 1
a39 1
	@@(#)LEGACY KSH R49 2014/01/05
d2078 4
d2088 2
a7693 1
	bla=foo
a7694 2
	print ${foo@@#123} ${bar@@#456} ${baz@@#789} .
	print ${foo@@#bla} ${bar@@#bar} ${baz@@#OPTIND} .
d7696 1
a7696 3
	D50219A0 20E5DB5B 00000000 .
	554A1C76 004A212E CB209562 .
	6B21CF91 20E5DB5B 124EA49D .
@


1.638
log
@play catchup with weird obsd reorg (in which they lost a few tests, even)
@
text
@d5 1
a5 1
#	      2011, 2012, 2013
d30 1
a30 1
	@@(#)MIRBSD KSH R48 2013/11/30
d39 1
a39 1
	@@(#)LEGACY KSH R48 2013/11/30
d1639 8
@


1.637
log
@detect getsid(2), also spotted by RT, this on MSYS
@
text
@d2 1
a2 5
# $OpenBSD: bksl-nl.t,v 1.2 2001/01/28 23:04:56 niklas Exp $
# $OpenBSD: history.t,v 1.5 2001/01/28 23:04:56 niklas Exp $
# $OpenBSD: read.t,v 1.3 2003/03/10 03:48:16 david Exp $
# $OpenBSD: regress.t,v 1.16 2013/09/14 20:09:30 millert Exp $
# $OpenBSD: obsd-regress.t,v 1.5 2013/07/01 17:25:27 jca Exp $
d8792 1
a8792 1
	$OpenBSD: eval.sh,v 1.1 2010/03/24 08:29:44 fgsch Exp $
d8952 1
a8952 2
	$OpenBSD: varfunction.sh,v 1.1 2003/12/15 05:28:40 otto Exp $
	Calling
a8959 1
	Inspired by PR 2450.
@


1.636
log
@revert commit 1005289433447F6CA90 as it makes the system unbootable
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.635 2013/11/17 22:28:49 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/11/29
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/11/29
@


1.635
log
@fix initial IFSWS not ignored when expanding, noticed by Seb <sbb@@tuxfamily.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.633 2013/09/24 20:19:40 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/11/17
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/11/17
d2129 12
a3688 2
	x="X 1 2"
	showargs 14 shift ${x#X}
d3703 11
a3713 1
	 <14> <shift> <1> <2>
@


1.634
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/10/08
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/10/08
d3677 2
d3693 1
@


1.633
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (;), oksh rcsid sync (they did
accept I was right wrt. set -e), int  bool, and code merge/cleanup
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.632 2013/09/10 17:32:58 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/09/24
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/09/24
@


1.632
log
@integrate latest changes from oksh: Wed Sep 4 15:49:19 2013 UTC by millert

Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.630 2013/08/16 10:58:59 tg Exp $
d5 1
a5 1
# $OpenBSD: regress.t,v 1.15 2013/07/01 17:25:27 jca Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/09/10
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/09/10
d4809 1
a4809 1
	echo `false; echo hi`
d4814 1
@


1.631
log
@SECURITY: Unbreak set +p, broken by OpenBSD ksh change.

TODO: I am seriously considering following Chet and changing
the way this works, by explicitly dropping privs unless the
shell is run with -p. Every other shell does it like mksh,
except Heirloom sh, which on the other hand doesnt know any
explicit set -p or set +p (though it doesnt know set +foo
for any foo either).

 QUESTION: Do we need the ability to do this:
 tg@@blau:~ $ ./suidmksh -p -c 'whoami; set +p; whoami'
 root
 tg

If not, Im seriously considering to drop set p as well,
only parse -p on the command line, with +p being the default,
and dropping FPRIVILEGED.

Thanks to RT for noticing and jilles for initial follow-up
discussion, as well as Chet Ramey for doing the sane/secure
thing instead of following Debian.
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/08/23
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/08/23
a6735 1
	suspend='kill -STOP $$'
a6803 1
	suspend='kill -STOP $$'
a6826 1
	suspend='kill -STOP $$'
@


1.630
log
@Ypnose discovered a problem with multi-line prompts and SIGWINCH
related to caching some values (downside, pprompt gets back doprint option)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.629 2013/08/14 20:26:15 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/08/16
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/08/16
@


1.629
log
@fun: when writing this code I feared an off-by-one;
Steffen Daode Nurpmeso stumbled upon it and gave very detailed
instructions on how to reproduce it (thanks!); fix that

also only call x_bs0 if xcp < xep because *xep is undefined
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.628 2013/08/11 14:57:07 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/08/14
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/08/14
@


1.628
log
@improve density of .rodata (with net win on .text size(1)) via better struct packing
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.627 2013/08/10 13:47:16 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/08/11
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/08/11
@


1.627
log
@improve documentation and comments
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.626 2013/08/10 13:44:27 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R48 2013/08/10
d43 1
a43 1
	@@(#)LEGACY KSH R48 2013/08/10
@


1.626
log
@reduce amount of .bss memory needed; initialise via AEDIT at x_init
or even first run of x_vi
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.625 2013/07/26 20:33:35 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R47 2013/08/10
d43 1
a43 1
	@@(#)LEGACY KSH R47 2013/08/10
@


1.625
log
@ Completely overhaul prompt length calculation and
  prompt display routines; make Emacs and Vi share
  code, permitting reducing of duplication and code
  removal as well as more consistent behaviour; put
  some common code into shared helper functions, too
 New x_adjust() logic (Emacs mode): when determining
  what portion of a line to render use a much more
  sophisticated algorithm and try to fill up  of the
  total screen width (with line and prompt both) also
  as wished from Steffen Daode Nurpmeso
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.619 2013/07/21 18:47:16 tg Exp $
d34 1
a34 1
	@@(#)MIRBSD KSH R47 2013/07/26
d43 1
a43 1
	@@(#)LEGACY KSH R47 2013/07/26
@


1.624
log
@Steffen Daode Nurpmeso found an actual bug:

Whenever the SIGEXIT trap was set (to anything, really)
syntax errors and interruptions were not ignored any more
in an interactive shell (where they should be, unless
set -e is used); fix that.

tbd: traps should probably only be marked as pending
and run for LLEAVE/E_NONE
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R47 2013/07/25
d43 1
a43 1
	@@(#)LEGACY KSH R47 2013/07/25
@


1.623
log
@Apply patch from: Steffen "Daode" Nurpmeso for testing -i vs. EXIT trap
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R47 2013/07/24
d43 1
a43 1
	@@(#)LEGACY KSH R47 2013/07/24
@


1.622
log
@more checks for special char handling
@
text
@d6123 21
@


1.621
log
@fix another clobbered-by-setjmp/longjmp warning
@
text
@d7712 22
@


1.620
log
@Fix apparent programming mistake (newblock doesnt imply newenv)
that caused echo ${|true;}$(true) to segfault; problem reported
by pshevtsov and wbx@@ in IRC (thanks!); fix sponsored by tarent
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R47 2013/07/21
d43 1
a43 1
	@@(#)LEGACY KSH R47 2013/07/21
@


1.619
log
@Fix most set -x problems (LP#1179287)

 set -x manually (cmdline too) snapshots fd#2 now
 set -o inherit-xtrace introduced; default still enabled
 reverted iodup printing to pre-R45 behaviour
 made Flag(FXTRACE) a proper state machine
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.616 2013/06/03 22:28:28 tg Exp $
d10189 2
d10197 1
@


1.618
log
@fix postun in not evaluated side of e.g. ternary operator (LP#1187729)
@
text
@d34 1
a34 1
	@@(#)MIRBSD KSH R46 2013/06/03
d43 1
a43 1
	@@(#)LEGACY KSH R46 2013/06/03
d11110 16
@


1.617
log
@partial merge and full RCS ID sync with oksh

merged:
 new regression tests
 check.pl (tests/th) better tmpfile handling
 exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
 ksh.1 1.147: document the above
 eval.c 1.39: Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).
   additionally make shf_open() return errno and actually show
    the error message from the system
 regression-39 test: remove the maybe marker
   but decide on correct POSIX behaviour

already been fixed in mksh:
 check.pl (tests/th) exit 1 if tests fail

not merged:
 main.c 1.52: run traps in unwind() before exiting;
  Im pretty sure this is already working as-should in mksh
 eval.c 1.38: Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status. As discussed in IRC, this is
  just plainly WRONG.
@
text
@d295 16
@


1.616
log
@use z shf printf modifier for out-of-memory message, now that we have it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.612 2013/05/02 21:59:45 tg Exp $
d5 2
d4788 3
a4790 5
	set -e: errors in command substitutions aren't ignored
	Not clear if they should be or not... bash passes here
	this may actually be required for make, so changed the
	test to make this an mksh feature, not a bug
arguments: !-e!
d4792 1
d4794 1
a4794 3
#expected-fail: yes
#expected-stdout:
#	hi
d4797 1
d8714 38
a8751 1
name: oksh-shcrash
d8753 1
a8753 1
	src/regress/bin/ksh/shcrash.sh,v 1.1
d8755 10
d8781 93
@


1.615
log
@fix a number of warnings and other issues:
 sig_t detection was a bit insane, it is a function-pointer type after all
 fix uninitialised variable in c_select which led to mistakenly accepting
  invalid (nn-numeric) input and acting, randomly, upon it
 keep SIGCHLD blocked in child after forking longer, for job list manip
 block SIGCHLD ifdef DEBUG_LEAKS to not run job foo during/after afreeall
 fix annoying ISO C90 vs. C99 (un)signed constant warning
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R46 2013/06/01
d41 1
a41 1
	@@(#)LEGACY KSH R46 2013/06/01
@


1.614
log
@pull some quoting fixes from oksh; original patch from Alexander Polakov
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R46 2013/05/31
d41 1
a41 1
	@@(#)LEGACY KSH R46 2013/05/31
@


1.613
log
@prevent indirect recursion loops for namerefs; found by ormaaj, thanks!
@
text
@a2539 24
name: heredoc-quoting-unsubst
description:
	Check for correct handling of quoted characters in
	here documents without substitution (marker is quoted).
stdin:
	foo=bar
	cat <<-'EOF'
		x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
	EOF
expected-stdout:
	x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
---
name: heredoc-quoting-subst
description:
	Check for correct handling of quoted characters in
	here documents with substitution (marker is not quoted).
stdin:
	foo=bar
	cat <<-EOF
		x " \" \ \\ $ \$ `echo baz` \`echo baz\` $foo \$foo x
	EOF
expected-stdout:
	x " \" \ \ $ $ baz `echo baz` bar $foo x
---
d2722 125
@


1.612
log
@implement VALSUBs
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.609 2013/04/27 19:16:23 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R46 2013/05/02
d41 1
a41 1
	@@(#)LEGACY KSH R46 2013/05/02
d10264 1
a10264 1
		typeset -n foo=foo
d10273 3
a10275 1
	blah bar .
@


1.611
log
@implement set -o pipefail
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R45 2013/04/27
d41 1
a41 1
	@@(#)LEGACY KSH R45 2013/04/27
d8925 2
a8926 2
	#COMSUB_EXPRSUB
	echo $(true) $((1+ 2))
d9308 2
a9309 2
	inline_COMSUB_EXPRSUB() {
		echo $(true) $((1+ 2))
d9311 2
a9312 2
	inline_COMSUB_EXPRSUB() {
		echo $(true ) $((1+ 2)) 
d9314 2
a9315 2
	function comsub_COMSUB_EXPRSUB { x=$(
		echo $(true) $((1+ 2))
d9317 2
a9318 2
	function comsub_COMSUB_EXPRSUB {
		x=$(echo $(true ) $((1+ 2)) ) 
d9320 2
a9321 2
	function reread_COMSUB_EXPRSUB { x=$((
		echo $(true) $((1+ 2))
d9323 2
a9324 2
	function reread_COMSUB_EXPRSUB {
		x=$(( echo $(true ) $((1+ 2)) ) | tr u x ) 
d9910 29
@


1.610
log
@ Allow setting both -o posix and -o sh (although only in the same
  command; setting one still unsets the other at first)
 Change subst_exstat to be conformant unless -o sh is set and -o posix isnt
 In lksh, make subst_exstat (newly) conformant if -o posix
 New MKSH_BINSHPOSIX to accompany MKSH_BINSHREDUCED
 Sync lksh manpage precisely
@
text
@d6297 22
@


1.609
log
@sync and be even more explicit

XXX some day, write the *precise* delta of MKSH_LEGACY_MODE into lksh.1
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.607 2013/04/26 21:22:42 tg Exp $
d4257 1
a4257 1
	In mksh R39b, we honour POSIX except when -o sh is set.
d4277 4
d4285 1
d4314 4
d4321 2
a4322 1
	FPOSIX=1 FSH=0 rv=1
d6200 1
a6200 1
	Check that sh mode is *not* automatically turned on
d6209 1
a6209 1
		    '[[ $(set +o) == *@@(-o sh)@@(| *) ]] && echo sh || echo nosh')
d6219 1
a6219 1
	Check that sh mode *is* automatically turned on
d6228 1
a6228 1
		    '[[ $(set +o) == *@@(-o sh)@@(| *) ]] && echo sh || echo nosh')
@


1.608
log
@after enough complaints by POSIX sh advocates,
 make parsing numbers with leading digit-zero as octal independent of
  mksh/lksh and dependent on set -o posix; adjust manpages to match
 warn about these changes and why mksh uses 32-bit consistent arithmetics
  and point people to lksh for host-long undefined-behaviour arithmetics
 point out, explicitly, that it is *legal* for the operating environment
  to make 'print $((2147483647 + 1))' (on a 32-bit system; adjust for a
  64-bit system) to run 'rm -rf ~ /' instead
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R45 2013/04/26
d41 1
a41 1
	@@(#)LEGACY KSH R45 2013/04/26
@


1.607
log
@Oh well this looks well, is done done, and gcc-snapshot doesnt complain:
 correct order of built-in commands; use POSIX special versus all others
  plus keeps assignments as distinction, no longer play POSIX regular vs.
  others game; sync manpage
 fix LP#1156707: map (( internally to let] which is no valid function
  name and so cant be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
 we do not need -Wno-overflow any more, either
 bump to R45
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.606 2013/04/26 19:40:42 tg Exp $
d3782 11
a3792 16
	Check behaviour does not match POSuX, because a not type-safe
	scripting language has *no* business interpreting "010" as octal
category: shell:legacy-no
stdin:
	echo :$((10)).$((010)).$((0x10)).
expected-stdout:
	:10.10.16.
---
name: integer-base-check-flat-legacy
description:
	Check behaviour matches POSuX for LEGACY KSH
category: shell:legacy-yes
stdin:
	echo :$((10)).$((010)).$((0x10)).
expected-stdout:
	:10.8.16.
@


1.606
log
@and, finally for today, fixup the set -x mess I made
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.605 2013/04/01 02:37:47 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/04/26
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/04/26
d9093 1
a9093 1
		while let " i < 10 " 
d9103 1
a9103 1
		x=$(i=1 ; while let " i < 10 " ; do echo $i ; let ++i ; done ) 
d9109 1
a9109 1
		x=$(( i=1 ; while let " i < 10 " ; do echo $i ; let ++i ; done ) | tr u x ) 
d9116 1
a9116 1
		until let " !--i " 
d9125 1
a9125 1
		x=$(i=10 ; until let " !--i " ; do echo $i ; done ) 
d9131 1
a9131 1
		x=$(( i=10 ; until let " !--i " ; do echo $i ; done ) | tr u x ) 
d9745 1
a9745 1
		while let " i < 10 " >&3 
d9755 1
a9755 1
		x=$(i=1 ; while let " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
d9761 1
a9761 1
		x=$(( i=1 ; while let " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
d9768 1
a9768 1
		until let " !--i " >&3 
d9777 1
a9777 1
		x=$(i=10 ; until let " !--i " >&3 ; do echo $i ; done >&3 ) 
d9783 1
a9783 1
		x=$(( i=10 ; until let " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
@


1.605
log
@one cant cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(Im gonna have to revise lots more code)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.604 2013/04/01 01:16:34 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/03/31
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/03/31
d3923 7
d5675 2
a5676 2
	+ env false 
	+ echo END 
d5695 3
a5697 3
	+ env true 
	+ env false 
	+ echo END 
@


1.604
log
@ugh, signed >> on negative values is implementation-defined
(but, at least, not undefined, and usually right; regress-test for it)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.603 2013/03/30 23:31:01 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/03/30
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/03/30
d392 3
d405 1
@


1.603
log
@sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.602 2013/03/29 17:33:53 tg Exp $
d366 1
a366 2
	If MKSH_GCC55009 is set when compiling, passing of
	this test is *mandatory* for a valid mksh executable!
d372 1
a372 1
	print -r -- $((x++)):$sari=$uari.
d374 1
a374 1
	print -r -- $((x++)):$sari=$uari.
d376 1
a376 1
	print -r -- $((x++)):$sari=$uari.
d378 1
a378 1
	print -r -- $((x++)):$sari=$uari.
d382 1
a382 1
	print -r -- $((x++)):$sari=$uari.
d384 1
a384 1
	print -r -- $((x++)):$sari=$uari.
d386 1
a386 1
	print -r -- $((x++)):$sari=$uari.
d388 4
a391 1
	print -r -- $((x++)):$sari=$uari.
d401 1
@


1.602
log
@also do not, ever, use &> bashiop in lksh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.601 2013/03/24 15:01:46 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/03/29
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/03/29
@


1.601
log
@disable parsing of &> as GNU bash iop if -o posix or -o sh, based on IRC discussion where jilles(IIRC) pointed out it breaks existing valid scripts
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.600 2013/03/24 00:56:19 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/03/24
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/03/24
d8366 1
d8387 1
d8408 1
d8429 1
d8453 1
d8475 1
d8499 1
d8521 1
a8521 1
name: bashiop-5
d8525 15
a8539 2
	(tested only on MirBSD as it uses /dev/fd)
category: os:mirbsd
d8541 7
a8547 7
	"$__progname" -c 'echo foo>/dev/null&>/dev/fd/2 echo bar1'
	"$__progname" -o posix -c 'echo foo>/dev/null&>/dev/fd/2 echo bar2'
	"$__progname" -o sh -c 'echo foo>/dev/null&>/dev/fd/2 echo bar3'
expected-stderr:
	foo echo bar1
	bar2
	bar3
@


1.600
log
@ let mksh set -x print whole TCOM trees
 plug some memory leaks in debug (set -x) and warning paths while here
 one from Florian (friend of Natureshadow) for WTF
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.599 2013/02/24 14:22:41 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/03/23
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/03/23
d8514 15
@


1.599
log
@optimise prefer_cols print_columns display
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.598 2013/02/23 20:03:27 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/02/24
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/02/24
d5661 2
a5662 2
	+ env false
	+ echo END
d5681 3
a5683 3
	+ env true
	+ env false
	+ echo END
@


1.598
log
@both mksh(1) and POSIX say: "$@@" should always generate multiple words
issue in pdksh reported in IRC by engla, thanks!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.597 2013/02/19 18:45:17 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R44 2013/02/23
d41 1
a41 1
	@@(#)LEGACY KSH R44 2013/02/23
@


1.597
log
@one more int  bool; mention set -o sh may (on raare OSes) be enabled
automatically (and it differs between targets); test MidnightBSD 0.1 ash
compat code and adjust the testsuite so it passes with it enabled
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.596 2013/02/18 22:55:37 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R43 2013/02/19
d41 1
a41 1
	@@(#)LEGACY KSH R43 2013/02/19
d3469 1
a3469 1
	 <1> <A B C>
d3471 2
a3472 2
	 <3> <A B C>
	 <4> <A B C>
@


1.596
log
@put list of check_categories into Makefrag.inc generated; bump patchlevel
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.595 2013/02/17 05:40:13 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R43 2013/02/18
d41 1
a41 1
	@@(#)LEGACY KSH R43 2013/02/18
d6008 1
a6008 2
	test -n "$POSH_VERSION" || set -o sh
	echo -e $rv
d6010 1
a6010 1
	-e 0
d10303 1
a10303 1
	test -n "$POSH_VERSION" || set -o sh
d10309 26
@


1.595
log
@backpedal with $'' and $"" interpolation

it turns out this breaks more legacy scripts than anticipated
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.594 2013/02/15 18:50:11 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R43 2013/02/16
d41 1
a41 1
	@@(#)LEGACY KSH R43 2013/02/16
@


1.594
log
@fix too strict fix for LP#1104543 (Debian #700526)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.593 2013/02/11 13:06:54 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R42 2013/02/15
d41 1
a41 1
	@@(#)LEGACY KSH R42 2013/02/15
d7691 1
a7691 1
name: dollar-quotes-in-heredocs
d7693 3
a7695 1
	They are, however, not parsed in here documents
d7699 1
a7703 9
expected-stdout:
		dollar = strchr(s, '$');	/* ' */
	a\tb
---
name: dollar-quotes-in-herestrings
description:
	On the other hand, they are parsed in here strings and
	parameter substitutions
stdin:
d7711 1
d7715 1
d7719 4
d7724 5
a7728 1
	dollar = strchr(s, ');	/*  */
a7729 1
	dollar = strchr(s, ');	/*  */
d7738 2
@


1.593
log
@check at least *one* of our Duffs Device heavy occurrences
to make sure the compiler doesnt frag it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.592 2013/02/10 23:59:23 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R42 2013/02/10
d41 1
a41 1
	@@(#)LEGACY KSH R42 2013/02/10
d5772 12
@


1.592
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.591 2013/02/10 23:36:21 tg Exp $
d10642 16
@


1.591
log
@regression test for: return works in funsub (like AT&T ksh93), local works in funsub (like in functions), exit does not work in funsub (sadly unlike ksh93, like in functions)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.589 2013/02/10 19:03:58 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/01/19
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/01/19
d5757 15
@


1.590
log
@missed in cid 10050B914D41435E735
@
text
@d9790 13
@


1.589
log
@do NOT close stdout or stderr, redirect to /dev/null instead
 we did have issues with that, trust me
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.588 2013/01/19 19:47:05 tg Exp $
a9772 1
category: !noexperimental
@


1.588
log
@besides more code reuse, fix $'' everywhere (but keep it ignored in here document bodies that arent here strings)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.586 2013/01/06 18:51:39 tg Exp $
d1210 29
a1238 29
	(echo 1 ${IFS+'}'z}) 2>&- || echo failed in 1
	(echo 2 "${IFS+'}'z}") 2>&- || echo failed in 2
	(echo 3 "foo ${IFS+'bar} baz") 2>&- || echo failed in 3
	(echo -n '4 '; ./pfn "foo ${IFS+"b   c"} baz") 2>&- || echo failed in 4
	(echo -n '5 '; ./pfn "foo ${IFS+b   c} baz") 2>&- || echo failed in 5
	(echo 6 ${IFS+"}"z}) 2>&- || echo failed in 6
	(echo 7 "${IFS+"}"z}") 2>&- || echo failed in 7
	(echo 8 "${IFS+\"}\"z}") 2>&- || echo failed in 8
	(echo 9 "${IFS+\"\}\"z}") 2>&- || echo failed in 9
	(echo 10 foo ${IFS+'bar} baz'}) 2>&- || echo failed in 10
	(echo 11 "$(echo "${IFS+'}'z}")") 2>&- || echo failed in 11
	(echo 12 "$(echo ${IFS+'}'z})") 2>&- || echo failed in 12
	(echo 13 ${IFS+\}z}) 2>&- || echo failed in 13
	(echo 14 "${IFS+\}z}") 2>&- || echo failed in 14
	u=x; (echo -n '15 '; ./pfs "foo ${IFS+a"b$u{ {"{{\}b} c ${IFS+d{}} bar" ${IFS-e{}} baz; echo .) 2>&- || echo failed in 15
	l=t; (echo 16 ${IFS+h`echo -n i ${IFS+$l}h`ere}) 2>&- || echo failed in 16
	l=t; (echo 17 ${IFS+h$(echo -n i ${IFS+$l}h)ere}) 2>&- || echo failed in 17
	l=t; (echo 18 "${IFS+h`echo -n i ${IFS+$l}h`ere}") 2>&- || echo failed in 18
	l=t; (echo 19 "${IFS+h$(echo -n i ${IFS+$l}h)ere}") 2>&- || echo failed in 19
	l=t; (echo 20 ${IFS+h`echo -n i "${IFS+$l}"h`ere}) 2>&- || echo failed in 20
	l=t; (echo 21 ${IFS+h$(echo -n i "${IFS+$l}"h)ere}) 2>&- || echo failed in 21
	l=t; (echo 22 "${IFS+h`echo -n i "${IFS+$l}"h`ere}") 2>&- || echo failed in 22
	l=t; (echo 23 "${IFS+h$(echo -n i "${IFS+$l}"h)ere}") 2>&- || echo failed in 23
	key=value; (echo -n '24 '; ./pfn "${IFS+'$key'}") 2>&- || echo failed in 24
	key=value; (echo -n '25 '; ./pfn "${IFS+"'$key'"}") 2>&- || echo failed in 25	# ksh93: '$key'
	key=value; (echo -n '26 '; ./pfn ${IFS+'$key'}) 2>&- || echo failed in 26
	key=value; (echo -n '27 '; ./pfn ${IFS+"'$key'"}) 2>&- || echo failed in 27
	(echo -n '28 '; ./pfn "${IFS+"'"x ~ x'}'x"'}"x}" #') 2>&- || echo failed in 28
	u=x; (echo -n '29 '; ./pfs foo ${IFS+a"b$u{ {"{ {\}b} c ${IFS+d{}} bar ${IFS-e{}} baz; echo .) 2>&- || echo failed in 29
d1240 1
a1240 1
	ar' baz}; echo .) 2>&- || (echo failed in 30; echo failed in 31)
d1242 1
a1242 1
	ar" baz}; echo .) 2>&- || echo failed in 32
d1244 1
a1244 1
	ar' baz}"; echo .) 2>&- || echo failed in 33
d1246 7
a1252 7
	ar" baz}"; echo .) 2>&- || echo failed in 34
	(echo -n '35 '; ./pfs ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 35
	(echo -n '36 '; ./pfs "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 36
	(echo -n '37 '; ./pfs ${v-a\ b} x ${v-c\ d}; echo .) 2>&- || echo failed in 37
	(echo 38 ${IFS+x'a'y} / "${IFS+x'a'y}" .) 2>&- || echo failed in 38
	foo="x'a'y"; (echo 39 ${foo%*'a'*} / "${foo%*'a'*}" .) 2>&- || echo failed in 39
	foo="a b c"; (echo -n '40 '; ./pfs "${foo#a}"; echo .) 2>&- || echo failed in 40
d1306 1
a1306 1
		(echo "$1 qstn norm foo ${v?'bar'} baz") 2>&- || \
d1311 1
a1311 1
		(echo "$1 QSTN norm foo ${v:?'bar'} baz") 2>&- || \
d1320 1
a1320 1
		(echo "$1 qstn parn foo ${v?(bar)} baz") 2>&- || \
d1325 1
a1325 1
		(echo "$1 QSTN parn foo ${v:?(bar)} baz") 2>&- || \
d1334 1
a1334 1
		(echo "$1 qstn brac foo ${v?a$u{{{\}b} c ${v?d{}} baz") 2>&- || \
d1339 1
a1339 1
		(echo "$1 QSTN brac foo ${v:?a$u{{{\}b} c ${v:?d{}} baz") 2>&- || \
d1436 1
a1436 1
		(echo $1 qstn norm foo ${v?'bar'} baz) 2>&- || \
d1441 1
a1441 1
		(echo $1 QSTN norm foo ${v:?'bar'} baz) 2>&- || \
d1450 1
a1450 1
		(echo $1 qstn parn foo ${v?\(bar')'} baz) 2>&- || \
d1455 1
a1455 1
		(echo $1 QSTN parn foo ${v:?\(bar')'} baz) 2>&- || \
d1464 1
a1464 1
		(echo $1 qstn brac foo ${v?a$u{{{\}b} c ${v?d{}} baz) 2>&- || \
d1469 1
a1469 1
		(echo $1 QSTN brac foo ${v:?a$u{{{\}b} c ${v:?d{}} baz) 2>&- || \
d2299 1
a2299 1
	echo $(tr r z <<<'bar' 2>&-)
d4350 1
a4350 1
	(: ; cat t2 2>&-) | sleep 1
d7736 1
a7736 1
	foo 2>&- || echo rab
@


1.587
log
@use the full parser code for handling here strings (and here document words)
as ormaaj requested, including a testcase
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/01/06
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/01/06
d7680 2
a7681 1
	They are, not parsed in here strings either
d7688 8
d7697 1
d7699 1
a7699 2
	dollar = strchr(s, '$');	/* ' */
	dollar = strchr(s, '$');	/* ' */
d7701 7
@


1.586
log
@ormaaj reported command shift not working correctly; fix
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.585 2013/01/01 22:23:14 tg Exp $
d2252 1
d2261 1
@


1.585
log
@fix the set +e cases, too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.584 2013/01/01 20:45:00 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/01/01
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/01/01
d10569 28
@


1.584
log
@fix running the ERR and EXIT traps in case of set -e and/or eval (includes Debian #696823)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.583 2013/01/01 03:32:41 tg Exp $
d5827 4
a5830 1
	GNU bash does not run ERtrap in eval-undef.
d5835 3
a5837 3
	set -e
	echo "and run $1"
	eval $1
d5843 1
a5843 1
	set -e
d5851 1
a5851 1
	set -e
d5859 1
a5859 1
	set -e
d5874 17
a5890 2
	echo :
	runtest x true
d5892 1
a5892 1
	runtest x false
d5894 1
a5894 1
	runtest x '${v?}'
d5896 1
a5896 1
	runtest xt
d5898 1
a5898 1
	runtest xf
d5900 1
a5900 1
	runtest xu
d5903 1
a5903 1
	:
d5929 28
@


1.583
log
@while thinking about mirlibc I figured that sys_errlist[] entries may be NULL
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.582 2012/12/28 07:45:55 tg Exp $
d7 1
a7 1
#	      2011, 2012
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/31
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/31
d5824 88
@


1.582
log
@just blacklist cd-pe on QNX as well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.576 2012/12/24 14:37:13 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/27
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/27
@


1.581
log
@QNX 4 oh-so-argh!
@
text
@d1151 2
a1152 1
category: !os:cygwin,!os:gnu,!os:msys,!nosymlink
@


1.580
log
@meh, just dont ever use ls(1) in a test; on some, it shows dotdirs
@
text
@d7605 1
d7607 5
a7611 4
	x="korn: $("$PWD"/f-korn)"; echo "${x/@@("$PWD")/.}"
	x="dash: $("$PWD"/f-dash)"; echo "${x/@@("$PWD")/.}"
	x="bash: $("$PWD"/f-bash)"; echo "${x/@@("$PWD")/.}"
	x="stop: $("$PWD"/f-stop)"; echo "${x/@@("$PWD")/.}"
@


1.579
log
@experimental test rewriting for QNX fun
@
text
@d220 5
a224 3
	echo -n >tf
	alias ls=ls
	ls
d226 2
a227 5
	i=`ls`
	print -r -- $(for x in "$i"; do
		[[ $x = @@(.|..) ]] && continue
		print -r -- "$x"
	done)
@


1.578
log
@mark glob-range-3 as need-pass: no
@
text
@d223 7
a229 1
	echo $(ls)
d233 1
d235 1
d7607 4
a7610 4
	echo "korn: $(./f-korn)"
	echo "dash: $(./f-dash)"
	echo "bash: $(./f-bash)"
	echo "stop: $(./f-stop)"
@


1.577
log
@harmonise sys_{sig,err}list  checks,  uses,  _decl values when not needed,  prototypes;  const is a keyword and thus space-separated from the preceding * pointer indicator
@
text
@d2065 1
@


1.576
log
@RT says glob-range-3 breaks on QNX nowadays
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.575 2012/12/22 00:03:39 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/21
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/21
@


1.575
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.574 2012/12/17 23:46:31 tg Exp $
d2063 2
a2064 1
category: !os:cygwin,!os:darwin,!os:msys
@


1.574
log
@sync clog et al.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.573 2012/12/07 23:46:33 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/17
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/17
@


1.573
log
@Correct mistake when doing hashtable lookup collision resolution oops
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.571 2012/12/05 19:38:18 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/07
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/07
@


1.572
log
@add testcase for basic I/O redir which RT had issues with on Linux 0.11
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/05
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/05
@


1.571
log
@fix libFirm/cparser -Wsign-compare
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.570 2012/12/04 01:18:24 tg Exp $
d8137 30
@


1.570
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569 2012/11/30 19:25:01 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/03
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/03
@


1.569
log
@implement tty tracking and bump to R41 for feature completeness

 tty_fd is now never closed
 new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
 as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
 otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
 SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
 change the Uhr to match  it no longer calls stty(1) 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.568 2012/11/26 23:14:44 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/11/30
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/11/30
@


1.569.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569 2012/11/30 19:25:01 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/03
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/03
@


1.569.2.2
log
@MFC todays batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569.2.1 2012/12/04 01:26:15 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/05
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/05
@


1.569.2.3
log
@Correct mistake when doing hashtable lookup collision resolution oops
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569.2.2 2012/12/05 19:58:25 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/07
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/07
@


1.569.2.4
log
@gcc-snapshot (see below) issued a clobber warning, and both it and mgcc
yowled about the memmove test until I found a compromise
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569.2.3 2012/12/07 23:46:19 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2012/12/20
d41 1
a41 1
	@@(#)LEGACY KSH R41 2012/12/20
@


1.569.2.5
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.584 2013/01/01 20:45:00 tg Exp $
d7 1
a7 1
#	      2011, 2012, 2013
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/01/01 stable
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/01/01 stable
d220 4
a223 9
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	PATH=$PWD:$PATH
	alias lq=lq
	lq
	echo = now
	i=`lq`
	print -r -- $i
	echo = out
a226 1
	= now
a227 1
	= out
d1144 1
a1144 2
# QNX does not find subdir to cd into
category: !os:cygwin,!os:gnu,!os:msys,!os:nto,!nosymlink
d2063 1
a2063 3
# breaks on QNX 6.4.1 (says RT)
category: !os:cygwin,!os:darwin,!os:msys,!os:nto
need-pass: no
a5813 88
name: exit-trap-2
description:
	Check that ERR and EXIT traps are run just like ksh93 does.
	GNU bash does not run ERtrap in eval-undef.
file-setup: file 644 "x"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set -e
	echo "and run $1"
	eval $1
	echo and out
file-setup: file 644 "xt"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set -e
	echo 'and run true'
	true
	echo and out
file-setup: file 644 "xf"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set -e
	echo 'and run false'
	false
	echo and out
file-setup: file 644 "xu"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set -e
	echo 'and run ${v?}'
	${v?}
	echo and out
stdin:
	runtest() {
		rm -f rc
		(
			"$__progname" "$@@"
			echo $? >rc
		) 2>&1 | sed \
		    -e 's/parameter not set/parameter null or not set/' \
		    -e 's/[[]6]//' -e 's/: eval: line 1//' -e 's/: line 6//' \
		    -e "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
	}
	echo :
	runtest x true
	echo = eval-true $(<rc) .
	runtest x false
	echo = eval-false $(<rc) .
	runtest x '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt
	echo = noeval-true $(<rc) .
	runtest xf
	echo = noeval-false $(<rc) .
	runtest xu
	echo = noeval-undef $(<rc) .
expected-stdout:
	:
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	EXtrap
	= eval-false 1 .
	and run ${v?}
	x: v: parameter null or not set
	ERtrap
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	EXtrap
	= noeval-false 1 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
---
a7595 1
	print '#!'"$__progname"'\nprint -r -- "${0%/f-argh}"' >f-argh
d7597 4
a7600 5
	u=$(./f-argh)
	x="korn: $(./f-korn)"; echo "${x/@@("$u")/.}"
	x="dash: $(./f-dash)"; echo "${x/@@("$u")/.}"
	x="bash: $(./f-bash)"; echo "${x/@@("$u")/.}"
	x="stop: $(./f-stop)"; echo "${x/@@("$u")/.}"
a8136 30
name: redir-1
description:
	Check some of the most basic invariants of I/O redirection
stdin:
	i=0
	function d {
		print o$i.
		print -u2 e$((i++)).
	}
	d >a 2>b
	echo =1=
	cat a
	echo =2=
	cat b
	echo =3=
	d 2>&1 >c
	echo =4=
	cat c
	echo =5=
expected-stdout:
	=1=
	o0.
	=2=
	e0.
	=3=
	e1.
	=4=
	o1.
	=5=
---
@


1.569.2.6
log
@fix the set +e cases, too
@
text
@d5827 1
a5827 4
	GNU bash does not run ERtrap in e eval-undef but runs it
	twice (bug?) in +e eval-false, so does ksh93 (bug?), which
	also has a bug to continue execution (echoing "and out" and
	returning 0) in +e eval-undef.
d5832 3
a5834 3
	set $1
	echo "and run $2"
	eval $2
d5840 1
a5840 1
	set $1
d5848 1
a5848 1
	set $1
d5856 1
a5856 1
	set $1
d5871 2
a5872 17
	xe=-e
	echo : $xe
	runtest x $xe true
	echo = eval-true $(<rc) .
	runtest x $xe false
	echo = eval-false $(<rc) .
	runtest x $xe '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt $xe
	echo = noeval-true $(<rc) .
	runtest xf $xe
	echo = noeval-false $(<rc) .
	runtest xu $xe
	echo = noeval-undef $(<rc) .
	xe=+e
	echo : $xe
	runtest x $xe true
d5874 1
a5874 1
	runtest x $xe false
d5876 1
a5876 1
	runtest x $xe '${v?}'
d5878 1
a5878 1
	runtest xt $xe
d5880 1
a5880 1
	runtest xf $xe
d5882 1
a5882 1
	runtest xu $xe
d5885 1
a5885 1
	: -e
a5910 28
	: +e
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	and out
	EXtrap
	= eval-false 0 .
	and run ${v?}
	x: v: parameter null or not set
	ERtrap
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	and out
	EXtrap
	= noeval-false 0 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
@


1.569.2.7
log
@MFC cid 10050E9C7D31AD0F470
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.586 2013/01/06 18:51:39 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/01/05
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/01/05
a10568 28
name: command-shift
description:
	Check that 'command shift' works
stdin:
	function snc {
		echo "before	0='$0' 1='$1' 2='$2'"
		shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	function swc {
		echo "before	0='$0' 1='$1' 2='$2'"
		command shift
		echo "after	0='$0' 1='$1' 2='$2'"
	}
	echo = without command
	snc  
	echo = with command
	swc  
	echo = done
expected-stdout:
	= without command
	before	0='snc' 1='' 2=''
	after	0='snc' 1='' 2=''
	= with command
	before	0='swc' 1='' 2=''
	after	0='swc' 1='' 2=''
	= done
---
@


1.569.2.8
log
@fix set -e with and/or inside functions regression (LP#1104543)
cause was that use of && or || inside function switched it to xerrok
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569.2.7 2013/01/06 18:59:08 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/02/10
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/02/10
a5754 15
name: exit-err-7
description:
	"set -e" regression (LP#1104543)
stdin:
	set -e
	bla() {
		[ -x $PWD/nonexistant ] && $PWD/nonexistant
	}
	echo x
	bla
	echo y$?
expected-stdout:
	x
expected-exit: 1
---
@


1.569.2.9
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.569.2.8 2013/02/10 23:59:30 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R41 2013/02/15
d41 1
a41 1
	@@(#)LEGACY KSH R41 2013/02/15
a5769 12
name: exit-err-8
description:
	"set -e" regression (Debian #700526)
stdin:
	set -e
	_db_cmd() { return $1; }
	db_input() { _db_cmd 30; }
	db_go() { _db_cmd 0; }
	db_input || :
	db_go
	exit 0
---
@


1.568
log
@sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.567 2012/11/25 22:23:31 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/11/26
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/11/26
@


1.567
log
@make regression testsuite once again safe to run with -DMKSH_NOPROSPECTOFWORK
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.566 2012/11/20 18:50:42 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/11/20
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/11/20
@


1.566
log
@RT tells me Minix 2 (i386) also doesnt have gettimeofday(2)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.565 2012/11/12 19:13:44 tg Exp $
d5201 1
@


1.565
log
@add checks for ~+ and ~- (inspired by posh change) and bump date,
as Im not likely to continue hacking tonight
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.563 2012/10/30 20:07:10 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/11/12
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/11/12
@


1.564
log
@fix a test
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/10/30
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/10/30
d5616 18
@


1.563
log
@restore yyrecursive context in quitenv (LP#1069428)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.562 2012/10/22 20:19:10 tg Exp $
d5610 1
@


1.562
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.561 2012/10/21 21:55:01 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/10/22
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/10/22
@


1.561
log
@defer setting exstat for eval to 0 (the one used in case shell() is empty)
until after the stuff run in shell() has had a chance to toy with $?

bug forwarded by one of our packagers, found by one of their users
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.560 2012/10/21 17:38:22 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/10/21
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/10/21
d9556 21
@


1.560
log
@this is now http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55009
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.559 2012/10/03 17:24:14 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/10/03
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/10/03
d5751 1
d5754 1
d5757 1
d5760 1
d5763 1
d5767 1
d5770 4
d5781 2
@


1.559
log
@even more hacks to pass -O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver with gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)  plus make the rtchecks mandatory
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.558 2012/09/07 21:02:40 tg Exp $
d359 1
a359 1
	If MKSH_GCC565048 is set when compiling, passing of
@


1.558
log
@OpenBSD found out that "building argv for $* and $@@" manipulates l->argv
in place which affects ps(1) output on BSD; create a new array and copy
the original parts from argv[] there without touching argv passed to main
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.557 2012/09/01 23:46:39 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/09/07
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/09/07
d357 36
@


1.557
log
@Update wcwidth data from Unicode 6.1.0
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.556 2012/08/24 21:33:47 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/09/01
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/09/01
@


1.556
log
@sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.555 2012/08/17 18:34:18 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/08/24
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/08/24
@


1.555
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.554 2012/08/03 18:45:29 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/08/17
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/08/17
@


1.554
log
@bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.553 2012/07/30 21:37:08 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/08/03
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/08/03
a9507 20
name: funsub-1
description:
	Check that non-subenvironment command substitution works
stdin:
	set -e
	foo=bar
	echo "ob $foo ."
	echo "${
		echo "ib $foo :"
		foo=baz
		echo "ia $foo :"
		false
	}" .
	echo "oa $foo ."
expected-stdout:
	ob bar .
	ib bar :
	ia baz : .
	oa baz .
---
@


1.553
log
@implement ksh93 feature ${ foo;}
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.551 2012/07/20 23:22:07 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/30
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/30
@


1.552
log
@fix reentry of here documents (LP#1030581)
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/21
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/21
a6196 15
name: utf8bom-3
description:
	Reading the UTF-8 BOM should enable the utf8-mode flag
	(temporarily for COMSUBs)
stdin:
	"$__progname" -c ':; if [[ $- = *U* ]]; then echo 1 on; else echo 1 off; fi'
	"$__progname" -c ':; if [[ $- = *U* ]]; then echo 2 on; else echo 2 off; fi'
	"$__progname" -c 'if [[ $- = *U* ]]; then echo 3 on; else echo 3 off; fi; x=$(:; if [[ $- = *U* ]]; then echo 4 on; else echo 4 off; fi); echo $x; if [[ $- = *U* ]]; then echo 5 on; else echo 5 off; fi'
expected-stdout:
	1 off
	2 on
	3 off
	4 on
	5 off
---
d9508 20
a9620 1
category: !smksh
@


1.551
log
@do implement quoting, as ${foo@@Q} though, as hommage at mirmake
dedicate this release to Andi
and use tomorrows (UTC) day for version, to cover up my debian fuckup
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.550 2012/07/01 15:54:51 tg Exp $
d2271 7
a2277 1
	typeset -f foo
d2287 1
a2287 1
		vc= <<-EOF 
d2292 1
d2320 7
a2326 1
	typeset -f foo
d2331 1
a2331 1
		vc= <<- 
d2335 1
a2335 1
		vd= <<-"" 
d2340 1
d8876 1
a8876 1
		cat >|bar <<"EOFN" 
d8887 1
a8887 1
		x=$(cat >|bar <<"EOFN" 
d8898 1
a8898 1
		x=$(( cat >|bar <<"EOFN" 
d8909 1
a8909 1
		cat >bar <<-EOFI 
d8920 1
a8920 1
		x=$(cat >bar <<-EOFI 
d8931 1
a8931 1
		x=$(( cat >bar <<-EOFI 
d9022 1
a9022 1
		x=$(cat <<EOFN 
d9034 1
a9034 1
		x=$(x=$(cat <<EOFN 
d9045 1
a9045 1
		x=$(( x=$(cat <<EOFN 
d9056 1
a9056 1
		x=$(cat <<EOFN\  
d9068 1
a9068 1
		x=$(x=$(cat <<EOFN\  
d9079 1
a9079 1
		x=$(( x=$(cat <<EOFN\  
d9102 1
a9102 1
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
d9134 1
a9134 1
		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
d9161 1
a9161 1
		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF 
@


1.550
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/  add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.549 2012/06/28 20:17:35 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/01
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/01
d7254 22
@


1.549
log
@(mksh) tighten 32-bit requirements; (lksh) switch to long; allow any bitness
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.544 2012/06/26 19:33:30 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/06/28
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/06/28
@


1.549.2.1
log
@version this appropriately
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.549 2012/06/28 20:17:35 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/20 Debian-2
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/20 Debian-2
@


1.549.2.2
log
@MFC cid 1005016E7627EF7B61F: fix reentry of here documents (LP#1030581)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.549.2.1 2012/07/20 23:31:02 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/20 Debian-3
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/20 Debian-3
d2271 1
a2271 7
	fnd=$(typeset -f foo)
	print -r -- "$fnd"
	function foo {
		echo blub
	}
	foo
	eval "$fnd"
d2281 1
a2281 1
		vc=<<-EOF
a2285 1
	blub
d2313 1
a2313 7
	fnd=$(typeset -f foo)
	print -r -- "$fnd"
	function foo {
		echo blub
	}
	foo
	eval "$fnd"
d2318 1
a2318 1
		vc=<<-
d2322 1
a2322 1
		vd=<<-""
a2326 1
	blub
d8840 1
a8840 1
		cat >|bar <<"EOFN"
d8851 1
a8851 1
		x=$(cat >|bar <<"EOFN"
d8862 1
a8862 1
		x=$(( cat >|bar <<"EOFN"
d8873 1
a8873 1
		cat >bar <<-EOFI
d8884 1
a8884 1
		x=$(cat >bar <<-EOFI
d8895 1
a8895 1
		x=$(( cat >bar <<-EOFI
d8986 1
a8986 1
		x=$(cat <<EOFN
d8998 1
a8998 1
		x=$(x=$(cat <<EOFN
d9009 1
a9009 1
		x=$(( x=$(cat <<EOFN
d9020 1
a9020 1
		x=$(cat <<EOFN\ 
d9032 1
a9032 1
		x=$(x=$(cat <<EOFN\ 
d9043 1
a9043 1
		x=$(( x=$(cat <<EOFN\ 
d9066 1
a9066 1
		[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
d9098 1
a9098 1
		x=$(x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
d9125 1
a9125 1
		x=$(( x=$(sysctl -n kern.version | sed 1q ) ; [[ -s /etc/motd && "$([[ "$(head -1 /etc/motd )" != $x ]] && ed -s /etc/motd 2>&1 <<-EOF
@


1.549.2.3
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.592 2013/02/10 23:59:23 tg Exp $
d7 1
a7 1
#	      2011, 2012, 2013
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/20 Debian-5
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/20 Debian-5
d220 4
a223 9
	print '#!'"$__progname"'\necho tf' >lq
	chmod +x lq
	PATH=$PWD:$PATH
	alias lq=lq
	lq
	echo = now
	i=`lq`
	print -r -- $i
	echo = out
a226 1
	= now
a227 1
	= out
a2027 1
need-pass: no
a5573 1
	unset A
a5578 18
name: tilde-expand-2
description:
	Check tilde expansion works
env-setup: !HOME=/sweet!
stdin:
	wd=$PWD
	cd /
	plus=$(print -r -- ~+)
	minus=$(print -r -- ~-)
	nix=$(print -r -- ~)
	[[ $plus = / ]]; echo one $? .
	[[ $minus = "$wd" ]]; echo two $? .
	[[ $nix = /sweet ]]; echo nix $? .
expected-stdout:
	one 0 .
	two 0 .
	nix 0 .
---
a5688 15
name: exit-err-7
description:
	"set -e" regression (LP#1104543)
stdin:
	set -e
	bla() {
		[ -x $PWD/nonexistant ] && $PWD/nonexistant
	}
	echo x
	bla
	echo y$?
expected-stdout:
	x
expected-exit: 1
---
a5714 1
	(exit 12)
a5716 1
	(exit 12)
a5718 1
	(exit 12)
a5720 1
	(exit 12)
a5722 1
	(exit 12)
a5725 1
	(exit 12)
a5727 4
	echo -n "G "
	(exit 12)
	eval 'echo $?'
	echo H $?
a5734 2
	G 12
	H 0
a5745 134
name: exit-trap-2
description:
	Check that ERR and EXIT traps are run just like ksh93 does.
	GNU bash does not run ERtrap in e eval-undef but runs it
	twice (bug?) in +e eval-false, so does ksh93 (bug?), which
	also has a bug to continue execution (echoing "and out" and
	returning 0) in +e eval-undef.
file-setup: file 644 "x"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo "and run $2"
	eval $2
	echo and out
file-setup: file 644 "xt"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run true'
	true
	echo and out
file-setup: file 644 "xf"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run false'
	false
	echo and out
file-setup: file 644 "xu"
	v=; unset v
	trap 'echo EXtrap' EXIT
	trap 'echo ERtrap' ERR
	set $1
	echo 'and run ${v?}'
	${v?}
	echo and out
stdin:
	runtest() {
		rm -f rc
		(
			"$__progname" "$@@"
			echo $? >rc
		) 2>&1 | sed \
		    -e 's/parameter not set/parameter null or not set/' \
		    -e 's/[[]6]//' -e 's/: eval: line 1//' -e 's/: line 6//' \
		    -e "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
	}
	xe=-e
	echo : $xe
	runtest x $xe true
	echo = eval-true $(<rc) .
	runtest x $xe false
	echo = eval-false $(<rc) .
	runtest x $xe '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt $xe
	echo = noeval-true $(<rc) .
	runtest xf $xe
	echo = noeval-false $(<rc) .
	runtest xu $xe
	echo = noeval-undef $(<rc) .
	xe=+e
	echo : $xe
	runtest x $xe true
	echo = eval-true $(<rc) .
	runtest x $xe false
	echo = eval-false $(<rc) .
	runtest x $xe '${v?}'
	echo = eval-undef $(<rc) .
	runtest xt $xe
	echo = noeval-true $(<rc) .
	runtest xf $xe
	echo = noeval-false $(<rc) .
	runtest xu $xe
	echo = noeval-undef $(<rc) .
expected-stdout:
	: -e
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	EXtrap
	= eval-false 1 .
	and run ${v?}
	x: v: parameter null or not set
	ERtrap
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	EXtrap
	= noeval-false 1 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
	: +e
	and run true
	and out
	EXtrap
	= eval-true 0 .
	and run false
	ERtrap
	and out
	EXtrap
	= eval-false 0 .
	and run ${v?}
	x: v: parameter null or not set
	ERtrap
	EXtrap
	= eval-undef 1 .
	and run true
	and out
	EXtrap
	= noeval-true 0 .
	and run false
	ERtrap
	and out
	EXtrap
	= noeval-false 0 .
	and run ${v?}
	xu: v: parameter null or not set
	EXtrap
	= noeval-undef 1 .
---
a8061 30
name: redir-1
description:
	Check some of the most basic invariants of I/O redirection
stdin:
	i=0
	function d {
		print o$i.
		print -u2 e$((i++)).
	}
	d >a 2>b
	echo =1=
	cat a
	echo =2=
	cat b
	echo =3=
	d 2>&1 >c
	echo =4=
	cat c
	echo =5=
expected-stdout:
	=1=
	o0.
	=2=
	e0.
	=3=
	e1.
	=4=
	o1.
	=5=
---
@


1.549.2.4
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.549.2.3 2013/02/11 00:27:07 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/07/20 Debian-7
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/07/20 Debian-7
a5730 12
name: exit-err-8
description:
	"set -e" regression (Debian #700526)
stdin:
	set -e
	_db_cmd() { return $1; }
	db_input() { _db_cmd 30; }
	db_go() { _db_cmd 0; }
	db_input || :
	db_go
	exit 0
---
@


1.548
log
@fix emacs/vi lksh
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/06/26
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/06/26
d327 1
d335 11
d360 1
d398 1
d423 28
d3835 1
d3843 11
@


1.547
log
@hackish work-around the lexer to make alias definitions in mksh -c
work (Closes: #517009) and mention in the manpage why they sometimes
do not work (doing so for COMSUBs is not worth the effort)
@
text
@d87 8
a94 2
	(set -o emacs); echo 1 = $? .
	(set -o vi); echo 2 = $? .
d96 2
a97 4
	1 = 1 .
	2 = 1 .
expected-stderr-pattern:
	/set: emacs: bad option\n.*set: vi: bad option/
@


1.546
log
@ensure that case end tokens are not mixed up (Closes: #220272)

XXX token/tpeek/musthave should rescan the last input lexems
XXX if the new cf passed doesn't match the last cf passed
@
text
@d4088 2
a4089 1
	echo $(echo \()
d4092 1
d6400 11
@


1.545
log
@fix trimming with positional parameters (Closes: #48453)
@
text
@d10188 25
@


1.544
log
@mh all Im gonna hack on upstream today fix -t for manpage generation and cleanup code snippets; bump vsn; sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.543 2012/06/26 18:11:01 tg Exp $
d1515 13
@


1.543
log
@bump for mksh with lksh-except-long, so we get the ball moving
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.542 2012/06/25 16:34:56 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/06/25
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/06/25
@


1.542
log
@fix two inverse logic mistakes (Im apparently really fond of them )
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.541 2012/06/25 16:31:16 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/06/24
d41 1
a41 1
	@@(#)LEGACY KSH R40 2012/06/24
@


1.541
log
@also get back octal crap for LEGACY KSH
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.540 2012/06/25 16:17:51 tg Exp $
d4166 3
a4168 3
	FPOSIX=0 FSH=0 rv=0
	FPOSIX=0 FSH=1 rv=0
	FPOSIX=1 FSH=0 rv=0
d8235 1
d8258 12
@


1.540
log
@first LEGACY changes: keep filedescriptors always open; revert to historic set -- $(getopt ) behaviour
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.539 2012/06/25 16:05:08 tg Exp $
d3656 1
d3662 9
@


1.539
log
@add basic LEGACY KSH mode (Build.sh -L), no changes yet
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.538 2012/06/24 20:39:24 tg Exp $
d82 13
d4104 1
d4128 32
@


1.538
log
@bump after dealing with all things Benny had Coverity find
remainging CIDs not listed are either

 false positive (bug in coverity)
 intentional (possibly with lint override coverity doesn't parse)
 VLA (XXX find out how to mix C99 and ANSI VLAs)
 things flagged as possible resource leaks I have no idea about
  (no biggie though, and only in error cases I think)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.537 2012/05/09 23:20:55 tg Exp $
d38 10
@


1.537
log
@Fix typeset issues (LP: #993847)

This was actually more evil:
 use a recursive function to display blocks in reverse order,
  so that local variable values overwrite global ones
 add array support to typeset -p (from typeset -p -)
 display 'set -A varname' line before setting values, for -p
 if -p got arguments, only display those (from the innermost scope)

Also, the usual amount of code cleanup
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.536 2012/05/04 22:44:31 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/05/09
@


1.536
log
@keep up
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.533 2012/04/22 21:50:29 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/05/04
d4824 2
a4825 1
	    typeset -i xxx
d4926 3
d4979 4
@


1.535
log
@introduce a nosymlink check category (idea by RT); pass it to test.sh; use cp if ln -s fails (me)
@
text
@d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/04/27
@


1.534
log
@add experimental code to use sigprocmask+pause+sigprocmask ipv sigsuspend (and harden j_sigchld handler for that) to improve working on BeOS 5.0 and Coherent UNIX, found by RT
@
text
@d76 2
a77 2
	ln -s "$__progname" cat
	ln -s "$__progname" echo
d1039 1
a1039 1
category: !os:cygwin,!os:gnu,!os:msys
d1898 1
a1898 1
category: !os:mint,!os:msys,!os:svr4.0
d5783 4
a5786 4
	ln -s "$__progname" ksh
	ln -s "$__progname" sh
	ln -s "$__progname" ./-ksh
	ln -s "$__progname" ./-sh
d5802 4
a5805 4
	ln -s "$__progname" ksh
	ln -s "$__progname" sh
	ln -s "$__progname" ./-ksh
	ln -s "$__progname" ./-sh
@


1.533
log
@after discussion with ciruZ, switch mksh from NZAT to NZAAT fully
to get rid of the bias introduced by making the hash never zero

 he also pointed out a memory (heap) usage optimisation which
may impact code size a bit though as Id need to pass an additional
argument on hashtable function calls or, forgo the benefit of not
having to pointer-align the key in the structure, which can be as
much as 3/7 octets per item, heap storage OTOH the saved space is
4/8 octets per not-allocated item, possibly some code (use of an
multiply-add opcode), but the function call overhead/cost would
possibly be quite a bit I guess Ill have to measure
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.532 2012/04/14 16:07:44 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/04/22
@


1.532
log
@rewrite maketemp() obsoleting tempnam(3) and mkstemp(3) external deps
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.531 2012/04/07 11:19:47 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/04/14
d7092 1
a7092 1
	D50219A0 20E5DB5B 00000001 .
@


1.531
log
@drop all deprecated code, you have been warned
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.530 2012/04/06 12:30:40 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/04/07
@


1.530
log
@rewrite stateptr-underflow check to be perl-less
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.529 2012/04/06 12:27:15 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/29
a3424 1
category: nodeprecated
a3433 13
name: integer-base-err-1-deprecated
description:
	Can't have 0 base (causes shell to exit)
category: !nodeprecated
expected-exit: e != 0
stdin:
	typeset -i i
	i=3
	i=0#4
	echo $i
expected-stderr-pattern:
	/^.*octal is deprecated\n.*:.*0#4.*\n$/
---
d3629 1
a3629 12
name: integer-base-check-flat-posix
description:
	Check behaviour of POSuX bases
category: !nodeprecated
stdin:
	echo :$((10)).$((010)).$((0x10)).
expected-stdout:
	:10.8.16.
expected-stderr-pattern:
	/octal is deprecated/
---
name: integer-base-check-flat-right
a3632 1
category: nodeprecated
a9405 93
name: event-subst-1a
description:
	Check that '!' substitution in interactive mode works
category: !smksh,!nodeprecated
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
need-ctty: yes
arguments: !-i!
stdin:
	export PATH=.:$PATH
	falsetto
	echo yeap
	!false
expected-exit: 42
expected-stdout:
	molto bene
	yeap
	molto bene
expected-stderr-pattern:
	/.*/
---
name: event-subst-1b
description:
	Check that '!' substitution in interactive mode works
	even when a space separates it from the search command,
	which is not what GNU bash provides but required for the
	other regression tests below to check
category: !smksh,!nodeprecated
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!"
	#! /bin/sh
	echo si
need-ctty: yes
arguments: !-i!
stdin:
	export PATH=.:$PATH
	falsetto
	echo yeap
	! false
expected-exit: 42
expected-stdout:
	molto bene
	yeap
	molto bene
expected-stderr-pattern:
	/.*/
---
name: event-subst-2
description:
	Check that '!' substitution in interactive mode
	does not break things
category: !smksh,!nodeprecated
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!"
	#! /bin/sh
	echo si
need-ctty: yes
arguments: !-i!
env-setup: !ENV=./Env!
file-setup: file 644 "Env"
	PS1=X
stdin:
	export PATH=.:$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	molto bene
	meow
	molto bene
	= 42
	foo
expected-stderr-pattern:
	/.*/
---
a9437 1
category: nodeprecated
@


1.529
log
@omit glob-bad-2 test on Dell UNIX 4.0 R2.2 (SVR4), too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.528 2012/03/31 18:28:11 tg Exp $
d10247 5
a10251 1
	s=$("$__perlname" -e 'print "a"x12120;')
@


1.528
log
@write appropriate shell replacements for id(1) as well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.526 2012/03/31 18:18:41 tg Exp $
d1897 2
a1898 1
category: !os:mint,!os:msys
@


1.527
log
@write appropriate shell replacements for printf(1) as well
@
text
@d8272 1
@


1.526
log
@let regression testsuite pass without existence of /usr/bin/env, env(1)
by writing appropriate shell replacements
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.525 2012/03/29 19:22:55 tg Exp $
d1094 3
d1100 2
a1101 2
	(echo -n '4 '; printf '%s\n' "foo ${IFS+"b   c"} baz") 2>&- || echo failed in 4
	(echo -n '5 '; printf '%s\n' "foo ${IFS+b   c} baz") 2>&- || echo failed in 5
d1111 1
a1111 1
	u=x; (echo -n '15 '; printf '<%s> ' "foo ${IFS+a"b$u{ {"{{\}b} c ${IFS+d{}} bar" ${IFS-e{}} baz; echo .) 2>&- || echo failed in 15
d1120 7
a1126 7
	key=value; (echo -n '24 '; printf '%s\n' "${IFS+'$key'}") 2>&- || echo failed in 24
	key=value; (echo -n '25 '; printf '%s\n' "${IFS+"'$key'"}") 2>&- || echo failed in 25	# ksh93: '$key'
	key=value; (echo -n '26 '; printf '%s\n' ${IFS+'$key'}) 2>&- || echo failed in 26
	key=value; (echo -n '27 '; printf '%s\n' ${IFS+"'$key'"}) 2>&- || echo failed in 27
	(echo -n '28 '; printf '%s\n' "${IFS+"'"x ~ x'}'x"'}"x}" #') 2>&- || echo failed in 28
	u=x; (echo -n '29 '; printf '<%s> ' foo ${IFS+a"b$u{ {"{ {\}b} c ${IFS+d{}} bar ${IFS-e{}} baz; echo .) 2>&- || echo failed in 29
	(echo -n '30 '; printf '<%s> ' ${IFS+foo 'b\
d1128 1
a1128 1
	(echo -n '32 '; printf '<%s> ' ${IFS+foo "b\
d1130 1
a1130 1
	(echo -n '33 '; printf '<%s> ' "${IFS+foo 'b\
d1132 1
a1132 1
	(echo -n '34 '; printf '<%s> ' "${IFS+foo "b\
d1134 3
a1136 3
	(echo -n '35 '; printf '<%s> ' ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 35
	(echo -n '36 '; printf '<%s> ' "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 36
	(echo -n '37 '; printf '<%s> ' ${v-a\ b} x ${v-c\ d}; echo .) 2>&- || echo failed in 37
d1139 1
a1139 1
	foo="a b c"; (echo -n '40 '; printf '<%s> ' "${foo#a}"; echo .) 2>&- || echo failed in 40
d6407 2
d6415 1
a6415 1
	printf '%s|' "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d6420 1
a6420 1
	printf '%s|' "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d6425 1
a6425 1
	printf '%s|' "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d7137 3
a7139 1
	printf '<%s> ' 1 "${a}" 2 "${a#?}" + "${b%?}" 3 "${a=}" + "${b/c/d}"
d7245 3
a7247 1
	printf '%s\n' $'\ \!\"\#\$\%\&\'\(\)\*\+\,\-\.\/ \1\2\3\4\5\6' \
d8307 2
d8311 1
a8311 1
		printf '%s\n' "$(echo foo)"
d8313 1
a8313 1
	printf '%s\n' "$(echo b)"
d8318 1
a8318 1
		printf "%s\\n" "$(echo foo )" 
@


1.525
log
@couple of minor/cosmetic fixes from RTs compile farm:

 promote SCO OpenServer and UnixWare to !oswarn
 omit trying -O2/-O on OpenServer 5 and USL C
 cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
 skip ulimit-1 on syllable (which is still too broken)
 write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
 rewrite functions returning !void ending in NOTREACHED
  so theyve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
 cast struct stat.st_size to off_t or size_t explicitly when needed
 shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.524 2012/03/27 22:36:49 tg Exp $
d4523 3
d4641 1
a4641 1
file-setup: file 644 "env"
d4644 1
a4644 1
env-setup: !ENV=./env!
d4671 1
a4671 1
file-setup: file 644 "env"
d4675 1
a4675 1
env-setup: !ENV=./env!
d5208 3
d5220 5
a5224 3
	sortprog=$(whence -p sort) || sortprog=cat
	env | $sortprog | grep -v '^RANDOM=' >bar1
	FOO=bar exec; env | $sortprog | grep -v '^RANDOM=' >bar2
d5444 4
d5461 5
d8114 3
@


1.524
log
@ implement fcntl(2)-based advisory locking as an alternative iff flock(2)
  is not found, from a suggestion by RT (LP: #912691)
 try harder (in a loop) to acquire a file lock if the locking mechanism
  documents EINTR is a possibility (fcntl always, flock on Linux not .Ox)
 use -std=c99 not -std=gnu99 if it must be at all
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.523 2012/03/26 21:10:38 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/27
d7878 1
@


1.523
log
@Susv3mon says: rlim_t are unsigned
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.522 2012/03/26 00:25:52 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/26
@


1.522
log
@check both signed and unsigned variants of this
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.521 2012/03/25 14:28:11 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/25
@


1.521
log
@fix regression w.r.t. TTY and external programmes:
 release the TTY after the initial change_winsz()
 since we release it, we can skip initialising tty_state, too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.520 2012/03/24 21:22:23 tg Exp $
d301 2
a302 1
	echo :$((-2147483648 / -1))_$((-2147483648 % -1)).
d304 2
a305 1
	:-2147483648_0.
@


1.520
log
@ MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
 Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes todays latest fixes
 Also, sync clog (including MFC indicators)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.519 2012/03/24 19:13:25 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/24
@


1.519
log
@be really loud when doing unwise things that WILL break in R41
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.518 2012/03/23 23:25:23 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/23
@


1.518
log
@huh, I thought I had extended ${parameter@@#hash} already; make it so now,
but not yet things like ${parameter@@Fi} (1 if integer, 0 otherwise), etc.
also bump patchlevel and  years in recently changed files
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.517 2012/03/20 16:48:12 tg Exp $
d3419 1
d3429 13
d3645 2
@


1.517
log
@ printf(1) on BSD/OS 4.1 does not play nice with NUL characters
   use print builtin, everything else works; reported by RT
 extend the testsuite, ensure print can do NUL correctly
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.516 2012/03/03 21:30:54 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/03
d7072 1
d7074 2
d7078 2
@


1.516
log
@RCSID sync from oksh; reduce hash table #elements if !MKSH_SMALL to speed up
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.515 2012/02/06 17:42:20 tg Exp $
d3940 1
a3940 1
		printf 'foo bar\tbaz\nblah \0blub\tblech\nmyok meck \0'
d7115 1
a7115 3
	Check handling of NUL characters for print and read
	note: second line should output 4 3 but we cannot
	handle NUL characters in strings yet
a7116 1
	print $(($(print '<\0>' | wc -c)))
d7118 4
a7121 4
	print $(($(print "$x" | wc -c))) ${#x}
expected-stdout:
	4
	3 2
@


1.515
log
@make jobs reporting deal with UTF-8 (in utf8-mode)
reported by Andrew Kudryashov, 10x
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.514 2012/01/29 01:41:09 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/02/06
@


1.514
log
@reduce stack usage a bit (several candidates for more, including $CC itself)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.513 2012/01/14 19:20:17 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/01/28
@


1.513
log
@shave off some redundancy
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.512 2012/01/05 11:52:48 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/01/04
@


1.512
log
@I hate Cygwin. Adjust sed for the fact that an mksh called as mksh.exe gets mksh in argv[0]; reported by Chris Sutcliffe
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.511 2012/01/04 19:09:32 tg Exp $
d10193 1
a10193 1
	s=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
@


1.511
log
@fix regression escaping single-char strings
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.510 2012/01/03 15:32:05 tg Exp $
d3882 1
a3882 1
	) 2>&1 | sed "s^${__progname}: <stdin>\[[0-9]*]PROG"
@


1.510
log
@fix regression in jaredys security patch introduced in R35b
(cid 100487B467E068A55D6 and 10048949D196A7C1390) discovered
by Jb_boin: time with a not-TCOM subtree would now trash its
string argument (which is the loop variable for TFOR); amend
regression testsuite
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.509 2012/01/03 01:40:15 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/01/03
d5002 23
@


1.509
log
@MSYS implies -DMKSH_ASSUME_UTF8=0 and thus can skip the test thatd fail
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.508 2012/01/03 00:58:07 tg Exp $
d8287 1
a8287 1
	for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
d8429 1
a8429 1
		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
d8432 1
a8432 1
		for i in {1,2,3} 
d8434 1
a8434 1
			time echo $i 
d8438 1
a8438 1
		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
d8441 1
a8441 1
		x=$(for i in {1,2,3} ; do time echo $i ; done ) 
d8444 1
a8444 1
		for  i  in  {1,2,3}  ;  do  time  echo  $i ;  done
d8447 1
a8447 1
		x=$(( for i in {1,2,3} ; do time echo $i ; done ) | tr u x ) 
@


1.508
log
@move linkage check (which uses sh.h INCLUDES_ONLY) to when all of its
prerequisites are actually fulfilled, i.e. evrn further down than with
the last commit doing this, and move some prerequisites of stuff that
has wandered outside the !INCLUDES_ONLY block with the compile-time
assert changes to the outside, too

fixes FTBFS on MSYS which has neither <stdint.h> nor uint32_t
reported by RT
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.507 2011/12/31 00:27:23 tg Exp $
d6051 1
a6051 1
category: !os:hpux
@


1.507
log
@gc-sections found size optimisation chances
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.505 2011/12/29 22:03:12 tg Exp $
d6 2
a7 1
# Copyright  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2011/12/30
@


1.506
log
@dont clobber the tree used for printing IOACTs in process_TIF (LP: #907224)
@
text
@d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/29
@


1.505
log
@ensure aliases in COMSUB are not expanded twice
spotted by Jilles Tjoelker again, thanks
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.504 2011/12/16 20:03:23 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/16
d8942 322
@


1.504
log
@use sane spelling of read-only consistently
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.503 2011/12/11 01:56:41 tg Exp $
d8229 16
@


1.503
log
@actually, behave with silent wraparound; results validated by bc(1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.502 2011/12/11 01:35:08 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/10
d4509 1
a4509 1
	/.*read *only.*/
d5017 1
a5017 1
	/read *only/
d5027 1
a5027 1
	/read *only/
d5046 1
a5046 1
	/read *only/
d5058 1
a5058 1
	/read *only/
@


1.502
log
@catch intmin/-1 instead of dumping core on SIGFPE; from Jilles Tjoelker
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.501 2011/12/10 13:34:14 tg Exp $
d290 1
a290 1
	echo =$?.
d292 1
a292 1
	=1.
d298 1
a298 1
	Check division overflow errors out
d300 1
a300 2
	x=$(echo $((-2147483648 / -1)))
	echo =$?.
d302 1
a302 3
	=1.
expected-stderr-pattern:
	/.*divisor/
@


1.501
log
@ finally, the code and manual page text to deprecate, and code to not
  handle any more, octal 010 style constants, as promised
 overhaul the manpage re. arithmetic expressions, make the guarantees
  mksh code has explicitly, precisely, clear
 to reduce burden of the compiler, getint() now operates on mksh_uari_t
  internally; it already applied the sign after operation, anyway (C99
  guarantees wraparound on unsigned types, but for signed types we need
  specific compiler support; apparently, this comes from hardware limits)
 use const and shuffle order of locals around while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.500 2011/12/09 20:40:02 tg Exp $
d285 22
@


1.500
log
@add tests for
 integer base flat (10, 010, 0x10)
   posix, right variants (heh, just like timezones)
   both enabled, which means one test always fails right now,
    until the code changes are in
   mksh R21 and up, AT&T ksh93, posh, GNU bash, busybox sh, dash
    all use the posux variant
   mksh R20b and below, pdksh, zsh, python, perl, php all do it right
   posix is stupid to use C (strongly typed, compiled) semantics
    for an untyped _scripting_ language
 integer bases 1 (mksh specific), 2 to 36, and that 37 errors out
   both directions
 integer arithmetic, signed and unsigned, wraparound and value span
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.499 2011/12/08 22:19:04 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/09
d3606 1
d3616 1
@


1.499
log
@MKSH_DISABLE_DEPRECATED needs testsuite handling
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.498 2011/12/02 22:55:46 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/02
d3603 129
@


1.498
log
@ improve comments
 do shave off 20 bytes from c_test() and get rid of the ugly stack
  variable and double using despite not parsing
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.497 2011/11/30 21:34:10 tg Exp $
d8869 1
a8869 1
category: !smksh
d8898 1
a8898 1
category: !smksh
d8925 1
a8925 1
category: !smksh
d8988 33
@


1.497
log
@rewrite funcs.c:c_test(), i.e. test(1) and [(1), to follow POSIX and XSI
in the cases where they are defined unambiguously; bug reported by
Jilles Tjoelker in <20111129232526.GC14357@@stack.nl> due to a report
by Stefano Lattarini on bug-autoconf

in the ambiguous case, I stick to traditional pdksh behaviour, which means
	test ! a = b	vs.	test a = b
and
	test ! a -o b	vs.	test a -o b
behave different from each other (in the second case, the NOT operator
binds strong; POSIX demands a reduction to 3 arguments and negating
that result in the first case), so we're at two known not-ok in the
FreeBSD testsuite. (81 and 82 in regress.sh,v 1.3)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.496 2011/11/26 00:45:18 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/11/30
@


1.496
log
@fix stateptr-underflow; really do call fastbox regression checks; bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.495 2011/11/25 23:33:42 tg Exp $
d26 3
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/11/25
@


1.495
log
@another couple of verbose checks; the *-global are mksh specific but work;
mksh currently fails arrassign-fnc-local (never worked either)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.494 2011/11/25 23:29:31 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/21
d9606 1
a9606 1
name: alloc-overflow-1
d9608 1
a9608 2
	This check overflows mksh R40 memory allocation
	unless 't=$t' is changed to 't+='
@


1.494
log
@add a -f option to test.sh that runs tests of class fastbox
plus a test in that category for a bug spotted during development of
https://evolvis.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=shellsnippets/shellsnippets.git;a=blob;f=mksh/sysadmin/getjpics.cgi;h=d74018cbc1ae4e88408267ecc73a6df19aa4c99a;hb=HEAD
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.493 2011/11/22 18:01:37 tg Exp $
d6428 338
@


1.493
log
@Fix regression introduced by mixing the recursive parser and support
for ;| and ;& in TCASE: ;;-less last casepart produced ";\0" in the
SREREAD string which obviously cased reparsing to fail

test from http://www.in-ulm.de/~mascheck/various/cmd-subst/
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.492 2011/11/19 21:22:00 tg Exp $
d9268 43
@


1.492
log
@bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.491 2011/11/19 17:25:55 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/19
d7837 3
a7839 1
	a+=b; c+=(d e)
d8406 3
a8408 1
		a+=b; c+=(d e)
d8411 6
a8416 2
		a+=b 
		set -A c+ -- d e 
d8419 3
a8421 1
		a+=b; c+=(d e)
d8424 1
a8424 1
		x=$(a+=b ; set -A c+ -- d e ) 
d8427 3
a8429 1
		a+=b; c+=(d e)
d8432 1
a8432 1
		x=$(( a+=b ; set -A c+ -- d e ) | tr u x ) 
@


1.491
log
@disable cd-pe test on Hurd, it also wrecks havoc with check.pl
https://buildd.debian.org/status/fetch.php?pkg=mksh&arch=hurd-i386&ver=40.2-4&stamp=1321059202
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.490 2011/11/11 22:14:15 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/11
@


1.490
log
@promote x=(a b); x+=(c) to standard mksh functionality at cost of 932 MKSH_SMALL .text bytes on MirBSD/i386
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.489 2011/11/09 22:17:23 tg Exp $
d1013 2
a1014 1
category: !os:cygwin,!os:msys
@


1.489
log
@ select(0, ) misbehaves on Interix (by Markus Duft <mduft@@gentoo.org>)
 select(n, NULL, NULL, NULL, ) behaves the same (by Bruno Haible)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.488 2011/11/08 23:10:58 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/09
a6179 1
category: !smksh
a6189 1
category: !smksh
a6229 1
category: !smksh
a6239 1
category: !smksh
a6407 1
category: !smksh
d7649 13
a7661 9
	echo $(case 1 in (1) echo yes;; (2) echo no;; esac)
	echo $(case 1 in 1) echo yes;; 2) echo no;; esac)
	TEST=1234; echo ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)}
	TEST=5678; echo ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)}
expected-stdout:
	yes
	yes
	234
	678
d7666 2
a7667 1
	Fails on GNU bash even, ksh93 passes
d7669 13
a7681 25
	echo $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))
	echo $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))
	(( a = $(case 1 in (1) echo 1;; (*) echo 2;; esac) )); echo $a.
	(( a = $(case 1 in 1) echo 1;; *) echo 2;; esac) )); echo $a.
expected-stdout:
	11
	21
	1.
	1.
---
name: comsub-1c
description:
	COMSUB are now parsed recursively, so this works (ksh93, mksh)
	First test passes on bash4, second fails there
category: !smksh
stdin:
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo ${a[0]}.
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo ${a[0]}.
	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo ${a[0]}.
	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo ${a[0]}.
expected-stdout:
	1.
	1.
	11.
	21.
d7723 1
a7723 1
	x() { case $1 in a) a+=b ;;& *) c+=(d e) ;; esac; }
d7728 2
a7729 2
		(a)
			a+=b 
d7732 1
a7732 1
			set -A c+ -- d e 
d7835 2
d8402 19
@


1.488
log
@disable another symlink-using test on MSYS
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.487 2011/11/08 22:07:11 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/07
@


1.487
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.486 2011/11/05 23:39:02 tg Exp $
d1867 2
a1868 1
category: !os:mint
@


1.486
log
@make MSYS match Cygwin more closely; ignore its broken <stdint.h>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.485 2011/10/26 20:46:13 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/10/26
@


1.485
log
@forgotten in cid 1004EA5BF612F516747 to take '\n' presence as $'' quoting reason
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.484 2011/10/24 19:41:09 tg Exp $
d1013 1
a1013 1
category: !os:cygwin
d1914 1
a1914 1
category: !os:cygwin,!os:darwin
d5824 1
a5824 1
category: !os:cygwin,!os:uwin-nt,!os:ultrix,!smksh
@


1.484
log
@document export - accident found by Snader_LB
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.483 2011/10/07 19:51:42 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/10/24
@


1.483
log
@better handling of eval and CPPFLAGS in build system
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.482 2011/09/07 15:24:10 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/10/07
@


1.482
log
@ access(2) is broken in at least kFreeBSD 9.0 as modern OS, so bring
  back the wrapper code as well as refactor most other code calling it
 apparently, names cant end in _ or contain __ anywhere
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.481 2011/08/27 18:06:38 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/09/07
@


1.481
log
@patch most of Jerker Bcks concerns out, unless not applicable
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.480 2011/08/27 17:30:02 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/08/27
@


1.480
log
@jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.479 2011/07/26 16:57:25 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/26
@


1.479
log
@followup fix for 1004D90467358D6B13C regarding escaped substitutions
found in, out of all things, Debian/m68k, by Wouter Verhelst (Yoe)
fix hacked at DebConf 11,  ,  ,   
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.478 2011/07/20 23:47:26 tg Exp $
d5894 1
@


1.478
log
@optimise an if away, and possibly even the function bodies
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.477 2011/07/18 00:35:44 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/20
d1606 2
a1607 1
	echo "<${x%bar|baz},${y%bar|baz}>"
d1610 1
a1610 1
	echo "<${x%bar|baz},${y%bar|baz}>"
d1614 1
d1616 1
a1616 2
	<foo,foo>
	<foobar,foobaz>
@


1.477
log
@now that I got Hash.cs compiled and run, Im amazed; make NZAAT (and NZAT!) all green with a small tweak; bit distribution and 2 look OK as well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.476 2011/07/16 17:08:50 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/17
@


1.476
log
@finish merging from R40-stable; set version number to yesterday though
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.475 2011/07/16 17:08:35 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/15
d6560 1
a6560 1
	3BA2B200 9072C3DA 00000001 .
@


1.475
log
@ merge from mksh R40-stable
drop heredoc-weird-3 while here, its not deterministic by design(?)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474 2011/07/07 21:02:39 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/07
@


1.474
log
@utf8opt-3 needs to be split in half, part of it needs-ctty
10x arekm again
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.473 2011/07/07 20:24:50 tg Exp $
a2327 13
name: heredoc-weird-3
description:
	Tests for here documents, taken from Austin ML
need-pass: no
stdin:
	cat <<x*x & touch 'x*x'
	hello
	x*x
	echo end
expected-stdout:
	hello
	end
---
@


1.474.2.1
log
@time to open the mksh R40-stable branch:
 bring back deprecated {build options,set o arc4random,OAAT1 internal hash}
 change version number in TFM
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474 2011/07/07 21:02:39 tg Exp $
d6573 1
a6573 1
	E76664C2 57F1BA9A 04808901 .
@


1.474.2.2
log
@ move /etc/{,suid_}profile to /system/etc/ for Android (but do not make
  the location of /etc configurable)
 rewrite manpage section about /etc/{,suid_}profile, .profile, .mkshrc
 drop heredoc-weird-3 while here, its not deterministic by design(?)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.1 2011/07/07 21:42:10 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/16
d2328 13
@


1.474.2.3
log
@MFC cid 1004E2EF1DA23EC569A
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.2 2011/07/16 16:04:08 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/25
d1606 1
a1606 2
	z=fooba\?
	echo "<${x%bar|baz},${y%bar|baz},${z%\?}>"
d1609 1
a1609 1
	echo "<${x%bar|baz},${y%bar|baz},${z%\?}>"
a1612 1
	<foo,foo,fooba>
d1614 2
a1615 1
	<foobar,foobaz,fooba>
@


1.474.2.4
log
@MFC from HEAD and adjust version

Build.sh:
- better handling of eval and CPPFLAGS in build system
- partial OPENSTEP support
- fix typo

check.t:
- mark utf8opt-2a as need-pass: no (1.481)

dot.mkshrc:
- do not close stderr (1.65)
- use only printable characters (1.65)

edit.c:
- upper bound Emacs mode command repeat by input line length

funcs.c, sh.h:
- optimise an if away, and possibly even the function bodies

misc.c:
- jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr

mksh.1, sh.h. var.c:
- fix spelling

mksh.1:
- document "export -"

sh.h:
- undef optarg, optind in case the OE predefines them (1.493)

shf.c:
- handle %zu (size_t), %zd (ssize_t), etc. (1.43)

syn.c:
- avoid (not-)function-local externs (1.68)

multiple:
- do not use macros or identifiers ending with an underscore
- more {,s}size_t, type, lint, other cleanups (edit.c 1.220; eval.c 1.107;
  exec.c 1.95; expr.c 1.48; funcs.c 1.196; histrap.c 1.110; jobs.c 1.81;
  lalloc.c 1.18; lex.c 1.155; main.c 1.198; misc.c 1.171; sh.h 1.493;
  shf.c 1.43; tree.c 1.50; var.c 1.131)
- wrap access(2) (edit.c 1.221; exec.c 1.96; expr.c 1.49; funcs.c 1.197;
  histrap.c 1.111; sh.h 1.494)
@
text
@d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/10/25
a5893 1
need-pass: no
@


1.474.2.5
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.4 2011/10/25 22:50:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/08
@


1.474.2.6
log
@MFC mksh-current fixes and upcoming deprecation and promotion; sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.5 2011/11/08 22:07:17 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/18
d1013 1
a1013 2
# Hurd aborts the testsuite (permission denied)
category: !os:cygwin,!os:gnu,!os:msys
d1867 1
a1867 2
# breaks on MSYS (does not support symlinks)
category: !os:mint,!os:msys
d1914 1
a1914 1
category: !os:cygwin,!os:darwin,!os:msys
d5824 1
a5824 1
category: !os:cygwin,!os:msys,!os:ultrix,!os:uwin-nt,!smksh
d6179 1
d6190 1
d6231 1
d6242 1
d6411 1
d7653 9
a7661 13
	echo 1 $(case 1 in (1) echo yes;; (2) echo no;; esac) .
	echo 2 $(case 1 in 1) echo yes;; 2) echo no;; esac) .
	TEST=1234; echo 3 ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)} .
	TEST=5678; echo 4 ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)} .
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo 5 ${a[0]} .
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo 6 ${a[0]} .
expected-stdout:
	1 yes .
	2 yes .
	3 234 .
	4 678 .
	5 1 .
	6 1 .
d7666 1
a7666 2
	Fails on: pdksh bash2 bash3 bash4 zsh
	Passes on: ksh93 mksh(20110313+)
d7668 25
a7692 13
	echo 1 $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10)) .
	echo 2 $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20)) .
	(( a = $(case 1 in (1) echo 1;; (*) echo 2;; esac) )); echo 3 $a .
	(( a = $(case 1 in 1) echo 1;; *) echo 2;; esac) )); echo 4 $a .
	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo 5 ${a[0]} .
	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo 6 ${a[0]} .
expected-stdout:
	1 11 .
	2 21 .
	3 1 .
	4 1 .
	5 11 .
	6 21 .
d7734 1
a7734 1
	x() { case $1 in u) echo x ;;& *) echo $1 ;; esac; }
d7739 2
a7740 2
		(u)
			echo x 
d7743 1
a7743 1
			echo $1 
a7845 2
	#wdarrassign
	a+=b; c+=(d e)
a8410 19
	inline_wdarrassign() {
		a+=b; c+=(d e)
	}
	inline_wdarrassign() {
		a+=b 
		set -A c+ -- d e 
	} 
	function comsub_wdarrassign { x=$(
		a+=b; c+=(d e)
	); }
	function comsub_wdarrassign {
		x=$(a+=b ; set -A c+ -- d e ) 
	} 
	function reread_wdarrassign { x=$((
		a+=b; c+=(d e)
	)|tr u x); }
	function reread_wdarrassign {
		x=$(( a+=b ; set -A c+ -- d e ) | tr u x ) 
	} 
@


1.474.2.7
log
@Fix regression introduced by mixing the recursive parser and support
for ;| and ;& in TCASE: ;;-less last casepart produced ";\0" in the
SREREAD string which obviously cased reparsing to fail

test from http://www.in-ulm.de/~mascheck/various/cmd-subst/
@
text
@d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/22
d7837 1
a7837 3
	case x in
	x) a+=b; c+=(d e)
	esac
d8404 1
a8404 3
		case x in
		x) a+=b; c+=(d e)
		esac
d8407 2
a8408 6
		case x in
		(x)
			a+=b 
			set -A c+ -- d e 
			;;
		esac 
d8411 1
a8411 3
		case x in
		x) a+=b; c+=(d e)
		esac
d8414 1
a8414 1
		x=$(case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) 
d8417 1
a8417 3
		case x in
		x) a+=b; c+=(d e)
		esac
d8420 1
a8420 1
		x=$(( case x in (x) a+=b ; set -A c+ -- d e  ;; esac ) | tr u x ) 
@


1.474.2.8
log
@ MFC this weeks bag of misc fixes
 mark set o arc4random MKSH_DISABLE_DEPRECATED (for e.g. Android)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.6 2011/11/19 22:21:54 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/11/26
a6427 338
name: arrassign-basic
description:
	Check basic whitespace conserving properties of wdarrassign
stdin:
	a=($(echo a  b))
	b=($(echo "a  b"))
	c=("$(echo "a  b")")
	d=("$(echo a  b)")
	a+=($(echo c  d))
	b+=($(echo "c  d"))
	c+=("$(echo "c  d")")
	d+=("$(echo c  d)")
	echo ".a:${a[0]}.${a[1]}.${a[2]}.${a[3]}:"
	echo ".b:${b[0]}.${b[1]}.${b[2]}.${b[3]}:"
	echo ".c:${c[0]}.${c[1]}.${c[2]}.${c[3]}:"
	echo ".d:${d[0]}.${d[1]}.${d[2]}.${d[3]}:"
expected-stdout:
	.a:a.b.c.d:
	.b:a.b.c.d:
	.c:a  b.c  d..:
	.d:a b.c d..:
---
name: arrassign-fnc-none
description:
	Check locality of array access inside a function
stdin:
	function fn {
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		if [[ -n $BASH_VERSION ]]; then
			y=()
		else
			set -A y
		fi
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	x=(m m)
	y=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:m.m.f.:
	.f1:m.m.f.:
	.fn:m.m.f.f:
	.f2:m.m.f.f:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:f...:
	.rfn:f...:
	.rf2:f...:
---
name: arrassign-fnc-local
description:
	Check locality of array access inside a function
	with the bash/mksh/ksh93 local/typeset keyword
	(note: ksh93 has no local; typeset works only in FKSH)
stdin:
	function fn {
		typeset x
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		if [[ -n $BASH_VERSION ]]; then
			y=()
		else
			set -A y
		fi
		typeset y
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	function fnr {
		typeset z
		if [[ -n $BASH_VERSION ]]; then
			z=()
		else
			set -A z
		fi
		z+=(f)
		echo ".fnr:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	}
	x=(m m)
	y=(m m)
	z=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	echo ".f0r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f1r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f2r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:f...:
	.f1:m.m..:
	.fn:f...:
	.f2:m.m..:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:...:
	.rfn:f...:
	.rf2:...:
	.f0r:m.m..:
	.fnr:f...:
	.f1r:m.m..:
	.fnr:f...:
	.f2r:m.m..:
---
name: arrassign-fnc-global
description:
	Check locality of array access inside a function
	with the mksh-specific global keyword
stdin:
	function fn {
		global x
		x+=(f)
		echo ".fn:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	}
	function rfn {
		set -A y
		global y
		y+=(f)
		echo ".rfn:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	}
	function fnr {
		global z
		set -A z
		z+=(f)
		echo ".fnr:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	}
	x=(m m)
	y=(m m)
	z=(m m)
	echo ".f0:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f1:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	fn
	echo ".f2:${x[0]}.${x[1]}.${x[2]}.${x[3]}:"
	echo ".rf0:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf1:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	rfn
	echo ".rf2:${y[0]}.${y[1]}.${y[2]}.${y[3]}:"
	echo ".f0r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f1r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
	fnr
	echo ".f2r:${z[0]}.${z[1]}.${z[2]}.${z[3]}:"
expected-stdout:
	.f0:m.m..:
	.fn:m.m.f.:
	.f1:m.m.f.:
	.fn:m.m.f.f:
	.f2:m.m.f.f:
	.rf0:m.m..:
	.rfn:f...:
	.rf1:f...:
	.rfn:f...:
	.rf2:f...:
	.f0r:m.m..:
	.fnr:f...:
	.f1r:f...:
	.fnr:f...:
	.f2r:f...:
---
name: strassign-fnc-none
description:
	Check locality of string access inside a function
stdin:
	function fn {
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		y+=f
		echo ".rfn:$y:"
	}
	x=m
	y=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
expected-stdout:
	.f0:m:
	.fn:mf:
	.f1:mf:
	.fn:mff:
	.f2:mff:
	.rf0:m:
	.rfn:f:
	.rf1:f:
	.rfn:f:
	.rf2:f:
---
name: strassign-fnc-local
description:
	Check locality of string access inside a function
	with the bash/mksh/ksh93 local/typeset keyword
	(note: ksh93 has no local; typeset works only in FKSH)
stdin:
	function fn {
		typeset x
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		typeset y
		y+=f
		echo ".rfn:$y:"
	}
	function fnr {
		typeset z
		z=
		z+=f
		echo ".fnr:$z:"
	}
	x=m
	y=m
	z=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
	echo ".f0r:$z:"
	fnr
	echo ".f1r:$z:"
	fnr
	echo ".f2r:$z:"
expected-stdout:
	.f0:m:
	.fn:f:
	.f1:m:
	.fn:f:
	.f2:m:
	.rf0:m:
	.rfn:f:
	.rf1::
	.rfn:f:
	.rf2::
	.f0r:m:
	.fnr:f:
	.f1r:m:
	.fnr:f:
	.f2r:m:
---
name: strassign-fnc-global
description:
	Check locality of string access inside a function
	with the mksh-specific global keyword
stdin:
	function fn {
		global x
		x+=f
		echo ".fn:$x:"
	}
	function rfn {
		y=
		global y
		y+=f
		echo ".rfn:$y:"
	}
	function fnr {
		global z
		z=
		z+=f
		echo ".fnr:$z:"
	}
	x=m
	y=m
	z=m
	echo ".f0:$x:"
	fn
	echo ".f1:$x:"
	fn
	echo ".f2:$x:"
	echo ".rf0:$y:"
	rfn
	echo ".rf1:$y:"
	rfn
	echo ".rf2:$y:"
	echo ".f0r:$z:"
	fnr
	echo ".f1r:$z:"
	fnr
	echo ".f2r:$z:"
expected-stdout:
	.f0:m:
	.fn:mf:
	.f1:mf:
	.fn:mff:
	.f2:mff:
	.rf0:m:
	.rfn:f:
	.rf1:f:
	.rfn:f:
	.rf2:f:
	.f0r:m:
	.fnr:f:
	.f1r:f:
	.fnr:f:
	.f2r:f:
---
a9267 42
name: stateptr-underflow
description:
	This check overflows an Xrestpos stored in a short in R40
category: fastbox
stdin:
	function Lb64decode {
		[[ -o utf8-mode ]]; local u=$?
		set +U
		local c s="$*" t=
		[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
		local -i i=0 n=${#s} p=0 v x
		local -i16 o
	
		while (( i < n )); do
			c=${s:(i++):1}
			case $c {
			(=)	break ;;
			([A-Z])	(( v = 1#$c - 65 )) ;;
			([a-z])	(( v = 1#$c - 71 )) ;;
			([0-9])	(( v = 1#$c + 4 )) ;;
			(+)	v=62 ;;
			(/)	v=63 ;;
			(*)	continue ;;
			}
			(( x = (x << 6) | v ))
			case $((p++)) {
			(0)	continue ;;
			(1)	(( o = (x >> 4) & 255 )) ;;
			(2)	(( o = (x >> 2) & 255 )) ;;
			(3)	(( o = x & 255 ))
				p=0
				;;
			}
			t=$t\\x${o#16#}
		done
		print -n $t
		(( u )) || set -U
	}
	
	s=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	Lb64decode $s >/dev/null
---
@


1.474.2.9
log
@MFC recent changes to R40-stable, validate it, fix a pedantic warning
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.8 2011/11/26 18:23:16 tg Exp $
a25 3
#
# More testsuites at:
# http://www.freebsd.org/cgi/cvsweb.cgi/src/tools/regression/bin/test/regress.sh?rev=HEAD
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/12/04
@


1.474.2.10
log
@MFC
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.9 2011/12/04 19:59:42 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/11
a284 19
name: arith-div-byzero
description:
	Check division by zero errors out
stdin:
	x=$(echo $((1 / 0)))
	echo =$?:$x.
expected-stdout:
	=1:.
expected-stderr-pattern:
	/.*divisor/
---
name: arith-div-intmin-by-minusone
description:
	Check division overflow wraps around silently
stdin:
	echo :$((-2147483648 / -1))_$((-2147483648 % -1)).
expected-stdout:
	:-2147483648_0.
---
a3602 131
name: integer-base-check-flat-posix
description:
	Check behaviour of POSuX bases
category: !nodeprecated
stdin:
	echo :$((10)).$((010)).$((0x10)).
expected-stdout:
	:10.8.16.
---
name: integer-base-check-flat-right
description:
	Check behaviour does not match POSuX, because a not type-safe
	scripting language has *no* business interpreting "010" as octal
category: nodeprecated
stdin:
	echo :$((10)).$((010)).$((0x10)).
expected-stdout:
	:10.10.16.
---
name: integer-base-check-numeric-from
description:
	Check behaviour for base one to 36, and that 37 errors out
stdin:
	echo 1:$((1#1))0.
	i=1
	while (( ++i <= 36 )); do
		eval 'echo '$i':$(('$i'#10)).'
	done
	echo 37:$($__progname -c 'echo $((37#10))').$?:
expected-stdout:
	1:490.
	2:2.
	3:3.
	4:4.
	5:5.
	6:6.
	7:7.
	8:8.
	9:9.
	10:10.
	11:11.
	12:12.
	13:13.
	14:14.
	15:15.
	16:16.
	17:17.
	18:18.
	19:19.
	20:20.
	21:21.
	22:22.
	23:23.
	24:24.
	25:25.
	26:26.
	27:27.
	28:28.
	29:29.
	30:30.
	31:31.
	32:32.
	33:33.
	34:34.
	35:35.
	36:36.
	37:.0:
expected-stderr-pattern:
	/.*bad number '37#10'/
---
name: integer-base-check-numeric-to
description:
	Check behaviour for base one to 36, and that 37 errors out
stdin:
	i=0
	while (( ++i <= 37 )); do
		typeset -Uui$i x=0x40
		eval "typeset -i10 y=$x"
		print $i:$x.$y.
	done
expected-stdout:
	1:1#@@.64.
	2:2#1000000.64.
	3:3#2101.64.
	4:4#1000.64.
	5:5#224.64.
	6:6#144.64.
	7:7#121.64.
	8:8#100.64.
	9:9#71.64.
	10:64.64.
	11:11#59.64.
	12:12#54.64.
	13:13#4C.64.
	14:14#48.64.
	15:15#44.64.
	16:16#40.64.
	17:17#3D.64.
	18:18#3A.64.
	19:19#37.64.
	20:20#34.64.
	21:21#31.64.
	22:22#2K.64.
	23:23#2I.64.
	24:24#2G.64.
	25:25#2E.64.
	26:26#2C.64.
	27:27#2A.64.
	28:28#28.64.
	29:29#26.64.
	30:30#24.64.
	31:31#22.64.
	32:32#20.64.
	33:33#1V.64.
	34:34#1U.64.
	35:35#1T.64.
	36:36#1S.64.
	37:36#1S.64.
expected-stderr-pattern:
	/.*bad integer base: 37/
---
name: integer-arithmetic-span
description:
	Check wraparound and size that is defined in mksh
stdin:
	echo s:$((2147483647+1)).$(((2147483647*2)+1)).$(((2147483647*2)+2)).
	echo u:$((#2147483647+1)).$((#(2147483647*2)+1)).$((#(2147483647*2)+2)).
expected-stdout:
	s:-2147483648.-1.0.
	u:2147483648.4294967295.0.
---
d8869 1
a8869 1
category: !smksh,!nodeprecated
d8898 1
a8898 1
category: !smksh,!nodeprecated
d8925 1
a8925 1
category: !smksh,!nodeprecated
a8987 33
name: event-subst-0
description:
	Check that '!' substitution in interactive mode is ignored
category: nodeprecated
need-ctty: yes
arguments: !-i!
file-setup: file 755 "falsetto"
	#! /bin/sh
	echo molto bene
	exit 42
file-setup: file 755 "!false"
	#! /bin/sh
	echo si
stdin:
	export PATH=.:$PATH
	falsetto
	echo yeap
	!false
	echo meow
	! false
	echo = $?
	if
	! false; then echo foo; else echo bar; fi
expected-stdout:
	molto bene
	yeap
	si
	meow
	= 0
	foo
expected-stderr-pattern:
	/.*/
---
@


1.474.2.11
log
@MFC all those nice things (not all parts, by now); sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.10 2011/12/11 18:18:20 tg Exp $
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2011/12/31
a8228 16
name: comsub-5
description:
	Check COMSUB works with aliases (does not expand them twice)
stdin:
	alias echo='echo a'
	foo() {
		printf '%s\n' "$(echo foo)"
	}
	printf '%s\n' "$(echo b)"
	typeset -f foo
expected-stdout:
	a b
	foo() {
		printf "%s\\n" "$(echo foo )" 
	} 
---
a8925 322
name: comsub-torture-io
description:
	Check the tree dump functions work correctly with I/O redirection
stdin:
	if [[ -z $__progname ]]; then echo >&2 call me with __progname; exit 1; fi
	while IFS= read -r line; do
		if [[ $line = '#1' ]]; then
			lastf=0
			continue
		elif [[ $line = EOFN* ]]; then
			fbody=$fbody$'\n'$line
			continue
		elif [[ $line != '#'* ]]; then
			fbody=$fbody$'\n\t'$line
			continue
		fi
		if (( lastf )); then
			x="inline_${nextf}() {"$fbody$'\n}\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f inline_$nextf" | "$__progname"
			x="function comsub_$nextf { x=\$("$fbody$'\n); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f comsub_$nextf" | "$__progname"
			x="function reread_$nextf { x=\$(("$fbody$'\n)|tr u x); }\n'
			print -nr -- "$x"
			print -r -- "${x}typeset -f reread_$nextf" | "$__progname"
		fi
		lastf=1
		fbody=
		nextf=${line#?}
	done <<'EOD'
	#1
	#TCOM
	vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	#TPAREN_TPIPE_TLIST
	(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	#TAND_TOR
	cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	#TSELECT
	select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	#TFOR_TTIME
	for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	#TCASE
	case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	#TIF_TBANG_TDBRACKET_TELIF
	if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	#TWHILE
	i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	#TUNTIL
	i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	#TCOPROC
	cat  *  >&3 |&  >&3 ls
	#TFUNCT_TBRACE_TASYNC
	function  korn  {  echo eins; echo >&3 zwei ;  }
	bourne  ()  {  logger *  >&3 &  }
	#COMSUB_EXPRSUB
	echo $(true >&3) $((1+ 2))
	#0
	EOD
expected-stdout:
	inline_TCOM() {
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	}
	inline_TCOM() {
		vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 
	} 
	function comsub_TCOM { x=$(
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	); }
	function comsub_TCOM {
		x=$(vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) 
	} 
	function reread_TCOM { x=$((
		vara=1  varb='2  3'  cmd  arg1  $arg2  "$arg3  4" >&3
	)|tr u x); }
	function reread_TCOM {
		x=$(( vara=1 varb="2  3" cmd arg1 $arg2 "$arg3  4" >&3 ) | tr u x ) 
	} 
	inline_TPAREN_TPIPE_TLIST() {
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	}
	inline_TPAREN_TPIPE_TLIST() {
		( echo $foo | tr -dc 0-9 >&3 
		  echo >&3 ) >&3 
	} 
	function comsub_TPAREN_TPIPE_TLIST { x=$(
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	); }
	function comsub_TPAREN_TPIPE_TLIST {
		x=$(( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) 
	} 
	function reread_TPAREN_TPIPE_TLIST { x=$((
		(echo $foo  |  tr -dc 0-9 >&3; echo >&3) >&3
	)|tr u x); }
	function reread_TPAREN_TPIPE_TLIST {
		x=$(( ( echo $foo | tr -dc 0-9 >&3 ; echo >&3 ) >&3 ) | tr u x ) 
	} 
	inline_TAND_TOR() {
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	}
	inline_TAND_TOR() {
		cmd >&3 && echo ja >&3 || echo nein >&3 
	} 
	function comsub_TAND_TOR { x=$(
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	); }
	function comsub_TAND_TOR {
		x=$(cmd >&3 && echo ja >&3 || echo nein >&3 ) 
	} 
	function reread_TAND_TOR { x=$((
		cmd  >&3 &&  >&3 echo ja  ||  echo >&3 nein
	)|tr u x); }
	function reread_TAND_TOR {
		x=$(( cmd >&3 && echo ja >&3 || echo nein >&3 ) | tr u x ) 
	} 
	inline_TSELECT() {
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	}
	inline_TSELECT() {
		select file in * 
		do
			echo "<$file>" 
			break >&3 
		done >&3 
	} 
	function comsub_TSELECT { x=$(
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	); }
	function comsub_TSELECT {
		x=$(select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) 
	} 
	function reread_TSELECT { x=$((
		select  file  in  *;  do  echo  "<$file>" ;  break >&3 ;  done >&3
	)|tr u x); }
	function reread_TSELECT {
		x=$(( select file in * ; do echo "<$file>" ; break >&3 ; done >&3 ) | tr u x ) 
	} 
	inline_TFOR_TTIME() {
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	}
	inline_TFOR_TTIME() {
		for i in {1,2,3} 
		do
			time echo $i >&3 
		done >&3 
	} 
	function comsub_TFOR_TTIME { x=$(
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	); }
	function comsub_TFOR_TTIME {
		x=$(for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) 
	} 
	function reread_TFOR_TTIME { x=$((
		for  i  in  {1,2,3}  ;  do  time  >&3 echo  $i ;  done >&3
	)|tr u x); }
	function reread_TFOR_TTIME {
		x=$(( for i in {1,2,3} ; do time echo $i >&3 ; done >&3 ) | tr u x ) 
	} 
	inline_TCASE() {
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	}
	inline_TCASE() {
		case $foo in
		(1)
			echo eins >&3 
			;&
		(2)
			echo zwei >&3 
			;|
		(*)
			echo kann net bis drei zhlen >&3 
			;;
		esac >&3 
	} 
	function comsub_TCASE { x=$(
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	); }
	function comsub_TCASE {
		x=$(case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) 
	} 
	function reread_TCASE { x=$((
		case  $foo  in  1)  echo eins >&3;& 2) echo zwei >&3  ;| *) echo kann net bis drei zhlen >&3;;  esac >&3
	)|tr u x); }
	function reread_TCASE {
		x=$(( case $foo in (1) echo eins >&3  ;& (2) echo zwei >&3  ;| (*) echo kann net bis drei zhlen >&3  ;; esac >&3 ) | tr u x ) 
	} 
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	}
	inline_TIF_TBANG_TDBRACKET_TELIF() {
		if ! [[ 1 = 1 ]] >&3 
		then
			echo eins 
		elif [[ 1 = 2 ]] >&3 
		then
			echo zwei 
		else
			echo drei 
		fi >&3 
	} 
	function comsub_TIF_TBANG_TDBRACKET_TELIF { x=$(
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	); }
	function comsub_TIF_TBANG_TDBRACKET_TELIF {
		x=$(if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) 
	} 
	function reread_TIF_TBANG_TDBRACKET_TELIF { x=$((
		if  !  [[  1  =  1  ]]  >&3 ;  then  echo eins;  elif [[ 1 = 2 ]] >&3; then echo zwei  ;else echo drei; fi >&3
	)|tr u x); }
	function reread_TIF_TBANG_TDBRACKET_TELIF {
		x=$(( if ! [[ 1 = 1 ]] >&3 ; then echo eins ; elif [[ 1 = 2 ]] >&3 ; then echo zwei ; else echo drei ; fi >&3 ) | tr u x ) 
	} 
	inline_TWHILE() {
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	}
	inline_TWHILE() {
		i=1 
		while let " i < 10 " >&3 
		do
			echo $i 
			let ++i 
		done >&3 
	} 
	function comsub_TWHILE { x=$(
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	); }
	function comsub_TWHILE {
		x=$(i=1 ; while let " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) 
	} 
	function reread_TWHILE { x=$((
		i=1; while (( i < 10 )) >&3; do echo $i; let ++i; done >&3
	)|tr u x); }
	function reread_TWHILE {
		x=$(( i=1 ; while let " i < 10 " >&3 ; do echo $i ; let ++i ; done >&3 ) | tr u x ) 
	} 
	inline_TUNTIL() {
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	}
	inline_TUNTIL() {
		i=10 
		until let " !--i " >&3 
		do
			echo $i 
		done >&3 
	} 
	function comsub_TUNTIL { x=$(
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	); }
	function comsub_TUNTIL {
		x=$(i=10 ; until let " !--i " >&3 ; do echo $i ; done >&3 ) 
	} 
	function reread_TUNTIL { x=$((
		i=10; until  (( !--i )) >&3 ; do echo $i; done >&3
	)|tr u x); }
	function reread_TUNTIL {
		x=$(( i=10 ; until let " !--i " >&3 ; do echo $i ; done >&3 ) | tr u x ) 
	} 
	inline_TCOPROC() {
		cat  *  >&3 |&  >&3 ls
	}
	inline_TCOPROC() {
		cat * >&3 |& 
		ls >&3 
	} 
	function comsub_TCOPROC { x=$(
		cat  *  >&3 |&  >&3 ls
	); }
	function comsub_TCOPROC {
		x=$(cat * >&3 |&  ls >&3 ) 
	} 
	function reread_TCOPROC { x=$((
		cat  *  >&3 |&  >&3 ls
	)|tr u x); }
	function reread_TCOPROC {
		x=$(( cat * >&3 |&  ls >&3 ) | tr u x ) 
	} 
	inline_TFUNCT_TBRACE_TASYNC() {
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	}
	inline_TFUNCT_TBRACE_TASYNC() {
		function korn {
			echo eins 
			echo zwei >&3 
		} 
		bourne() {
			logger * >&3 & 
		} 
	} 
	function comsub_TFUNCT_TBRACE_TASYNC { x=$(
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	); }
	function comsub_TFUNCT_TBRACE_TASYNC {
		x=$(function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) 
	} 
	function reread_TFUNCT_TBRACE_TASYNC { x=$((
		function  korn  {  echo eins; echo >&3 zwei ;  }
		bourne  ()  {  logger *  >&3 &  }
	)|tr u x); }
	function reread_TFUNCT_TBRACE_TASYNC {
		x=$(( function korn { echo eins ; echo zwei >&3 ; } ; bourne() { logger * >&3 &  } ) | tr u x ) 
	} 
	inline_COMSUB_EXPRSUB() {
		echo $(true >&3) $((1+ 2))
	}
	inline_COMSUB_EXPRSUB() {
		echo $(true >&3 ) $((1+ 2)) 
	} 
	function comsub_COMSUB_EXPRSUB { x=$(
		echo $(true >&3) $((1+ 2))
	); }
	function comsub_COMSUB_EXPRSUB {
		x=$(echo $(true >&3 ) $((1+ 2)) ) 
	} 
	function reread_COMSUB_EXPRSUB { x=$((
		echo $(true >&3) $((1+ 2))
	)|tr u x); }
	function reread_COMSUB_EXPRSUB {
		x=$(( echo $(true >&3 ) $((1+ 2)) ) | tr u x ) 
	} 
---
@


1.474.2.12
log
@MFC pending stuff into mksh R40-stable branch
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.515 2012/02/06 17:42:20 tg Exp $
d6 1
a6 2
# Copyright  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
#	      2011, 2012
d31 1
a31 1
	@@(#)MIRBSD KSH R40 2012/02/11
d3881 1
a3881 1
	) 2>&1 | sed "s^${__progname%.exe}\.*e*x*e*: <stdin>\[[0-9]*]PROG"
a5000 24
name: regression-66
description:
	Check that quoting is sane
	XXX not really in R40-stable
stdin:
	ac_space=' '
	ac_newline='
	'
	set | grep ^ac_ |&
	set -A lines
	while IFS= read -pr line; do
		if [[ $line = *space* ]]; then
			lines[0]=$line
		else
			lines[1]=$line
		fi
	done
	for line in "${lines[@@]}"; do
		print -r -- "$line"
	done
expected-stdout:
	ac_space=' '
	ac_newline='
---
d6050 1
a6050 1
category: !os:hpux,!os:msys
d8286 1
a8286 1
	time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
d8428 1
a8428 1
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
d8431 1
a8431 1
		time for i in {1,2,3} 
d8433 1
a8433 1
			echo $i 
d8437 1
a8437 1
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
d8440 1
a8440 1
		x=$(time for i in {1,2,3} ; do echo $i ; done ) 
d8443 1
a8443 1
		time  for  i  in  {1,2,3}  ;  do  echo  $i ;  done
d8446 1
a8446 1
		x=$(( time for i in {1,2,3} ; do echo $i ; done ) | tr u x ) 
d10169 1
a10169 1
	s=$("$__perlname" -e 'print "a"x12120;')
@


1.474.2.13
log
@MFC the Build.sh bugfix and the SkyOS and Minix stuff
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.474.2.12 2012/02/11 15:25:29 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/02
@


1.474.2.14
log
@ MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
 Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes todays latest fixes
 Also, sync clog (including MFC indicators)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.519 2012/03/24 19:13:25 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/03/20
a3418 1
category: nodeprecated
a3427 13
name: integer-base-err-1-deprecated
description:
	Can't have 0 base (causes shell to exit)
category: !nodeprecated
expected-exit: e != 0
stdin:
	typeset -i i
	i=3
	i=0#4
	echo $i
expected-stderr-pattern:
	/^.*octal is deprecated\n.*:.*0#4.*\n$/
---
a3630 2
expected-stderr-pattern:
	/octal is deprecated/
d3940 1
a3940 1
		print -n 'foo bar\tbaz\nblah \0blub\tblech\nmyok meck \0'
d7116 3
a7118 1
	Check handling of NUL characters for print and COMSUB
d7120 1
d7122 4
a7125 4
	print $(($(print '<\0>' | wc -c))) $(($(print "$x" | wc -c))) \
	    ${#x} "$x" '<\0>'
expected-stdout-pattern:
	/^4 3 2 <> <\0>$/
@


1.474.2.15
log
@MFC fixes from HEAD
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.530 2012/04/06 12:30:40 tg Exp $
d32 1
a32 1
	@@(#)MIRBSD KSH R40 2012/04/06
d301 1
a301 2
	echo signed:$((-2147483648 / -1))r$((-2147483648 % -1)).
	echo unsigned:$((# -2147483648 / -1))r$((# -2147483648 % -1)).
d303 1
a303 2
	signed:-2147483648r0.
	unsigned:0r2147483648.
a1091 3
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "<$x> "; done' >pfs
	chmod +x pfn pfs
d1095 2
a1096 2
	(echo -n '4 '; ./pfn "foo ${IFS+"b   c"} baz") 2>&- || echo failed in 4
	(echo -n '5 '; ./pfn "foo ${IFS+b   c} baz") 2>&- || echo failed in 5
d1106 1
a1106 1
	u=x; (echo -n '15 '; ./pfs "foo ${IFS+a"b$u{ {"{{\}b} c ${IFS+d{}} bar" ${IFS-e{}} baz; echo .) 2>&- || echo failed in 15
d1115 7
a1121 7
	key=value; (echo -n '24 '; ./pfn "${IFS+'$key'}") 2>&- || echo failed in 24
	key=value; (echo -n '25 '; ./pfn "${IFS+"'$key'"}") 2>&- || echo failed in 25	# ksh93: '$key'
	key=value; (echo -n '26 '; ./pfn ${IFS+'$key'}) 2>&- || echo failed in 26
	key=value; (echo -n '27 '; ./pfn ${IFS+"'$key'"}) 2>&- || echo failed in 27
	(echo -n '28 '; ./pfn "${IFS+"'"x ~ x'}'x"'}"x}" #') 2>&- || echo failed in 28
	u=x; (echo -n '29 '; ./pfs foo ${IFS+a"b$u{ {"{ {\}b} c ${IFS+d{}} bar ${IFS-e{}} baz; echo .) 2>&- || echo failed in 29
	(echo -n '30 '; ./pfs ${IFS+foo 'b\
d1123 1
a1123 1
	(echo -n '32 '; ./pfs ${IFS+foo "b\
d1125 1
a1125 1
	(echo -n '33 '; ./pfs "${IFS+foo 'b\
d1127 1
a1127 1
	(echo -n '34 '; ./pfs "${IFS+foo "b\
d1129 3
a1131 3
	(echo -n '35 '; ./pfs ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 35
	(echo -n '36 '; ./pfs "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 36
	(echo -n '37 '; ./pfs ${v-a\ b} x ${v-c\ d}; echo .) 2>&- || echo failed in 37
d1134 1
a1134 1
	foo="a b c"; (echo -n '40 '; ./pfs "${foo#a}"; echo .) 2>&- || echo failed in 40
d1892 1
a1892 2
# breaks on Dell UNIX 4.0 R2.2 (SVR4) where unlink also fails
category: !os:mint,!os:msys,!os:svr4.0
a4520 3
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.:$PATH
d4636 1
a4636 1
file-setup: file 644 "envf"
d4639 1
a4639 1
env-setup: !ENV=./envf!
d4666 1
a4666 1
file-setup: file 644 "envf"
d4670 1
a4670 1
env-setup: !ENV=./envf!
a5203 3
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.:$PATH
d5213 3
a5215 5
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.:$PATH
	env >bar1
	FOO=bar exec; env >bar2
a5434 4
	print '#!'"$__progname"'\nexec "$1"' >env
	print '#!'"$__progname"'\nexit 1' >false
	chmod +x env false
	PATH=.:$PATH
a5447 5
	print '#!'"$__progname"'\nexec "$1"' >env
	print '#!'"$__progname"'\nexit 1' >false
	print '#!'"$__progname"'\nexit 0' >true
	chmod +x env false
	PATH=.:$PATH
a6385 2
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "$x|"; done' >pfp
	chmod +x pfp
d6392 1
a6392 1
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d6397 1
a6397 1
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d6402 1
a6402 1
	./pfp "${#foo[*]}" "${foo[0]}" "${foo[1]}" "${foo[2]}" "${foo[3]}" "${foo[4]}" "${foo[5]}" "${foo[6]}"; echo
d7109 1
a7109 3
	print '#!'"$__progname"'\nfor x in "$@@"; do print -nr -- "<$x> "; done' >pfs
	chmod +x pfs
	./pfs 1 "${a}" 2 "${a#?}" + "${b%?}" 3 "${a=}" + "${b/c/d}"
d7215 1
a7215 3
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
	./pfn $'\ \!\"\#\$\%\&\'\(\)\*\+\,\-\.\/ \1\2\3\4\5\6' \
a7871 1
category: !os:syllable
a8089 3
	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
	    done >env; chmod +x env; PATH=.:$PATH
a8235 1
	print '#!'"$__progname"'\necho 1234' >id; chmod +x id; PATH=.:$PATH
a8270 2
	print '#!'"$__progname"'\nfor x in "$@@"; do print -r -- "$x"; done' >pfn
	chmod +x pfn
d8273 1
a8273 1
		./pfn "$(echo foo)"
d8275 1
a8275 1
	./pfn "$(echo b)"
d8280 1
a8280 1
		./pfn "$(echo foo )" 
d10207 1
a10207 5
	i=-1
	s=
	while (( ++i < 12120 )); do
		s+=a
	done
@


1.473
log
@take down the entire xterm (or GNU screen tab), hard, with:
mksh-R40 -c 'x=$COLUMNS; awk "BEGIN{exit(1)}"'
10x to the PLD Linux guys for spotting _and_ bisecting this!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.472 2011/07/06 22:21:54 tg Exp $
d5940 1
a5940 1
name: utf8opt-3
d5943 1
a5943 1
	(this test may pass falsely depending on CPPFLAGS)
d5949 13
d5968 1
a5968 3
	3 on
	4 off
	5 done
@


1.472
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.471 2011/07/05 20:12:15 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/06
@


1.471
log
@ bump patchlevel to todays
 while here, reformat 'struct tbl' comment-wise and placement-wise
  and drop the Tflag typedef
 while here, write regression test for the "global" built-in, which
  does what typeset is supposed to do except that it doubles as "local"
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.470 2011/07/02 17:57:37 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/05
d6559 2
a6560 1
	print ${bar@@#} ${baz@@#} .
d6562 1
a6562 1
	57F1BA9A 04808901 .
@


1.470
log
@address "env RANDOM=1=2=3 mksh" DoS by integrifying more
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.469 2011/06/30 13:48:09 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/07/02
d5713 34
@


1.469
log
@tabcomplete ~ and ~foo like $FOO (idea by yofuh)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.468 2011/06/21 21:50:23 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/30
@


1.468
log
@pretty tricky thing, IBMs curses library does nameref foo=foo
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.467 2011/06/12 14:58:43 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/21
@


1.467
log
@HP-UX aCC suggested more  0 and parenthess
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.466 2011/06/11 03:14:47 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/12
d8758 17
@


1.466
log
@add missing shf_flush() before prompting
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.465 2011/06/09 21:53:12 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/10
@


1.465
log
@ fix empty input
 fix input without trailing newline for integer-base-one-3{A,W}r
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.464 2011/06/09 21:26:21 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/05
@


1.464
log
@bugfix for when the last line was full
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.463 2011/06/09 21:10:50 tg Exp $
d6588 1
d6590 1
a6590 1
		typeset -Uui16 -Z5 hv
d6617 1
a6617 1
		print "$dasc|"
d6661 1
d6663 1
a6663 1
		typeset -Uui16 -Z5 hv
d6690 1
a6690 1
		print "$dasc|"
d6930 1
d6942 1
d6944 1
a6944 1
		typeset -Uui16 -Z5 hv
d6971 1
a6971 1
		print "$dasc|"
d6997 1
d7017 1
d7056 1
a7056 1
		print "$dasc|"
d7100 1
a7100 1
	some sample code for hexdumping
d7112 1
d7114 1
a7114 1
		typeset -Uui16 -Z5 hv
d7116 1
a7116 1
		while read -ar line; do
a7117 1
			line[${#line[*]}]=10
d7134 1
a7134 1
		done
d7139 1
a7139 1
		print "$dasc|"
d7164 1
a7164 1
	some sample code for hexdumping Unicode
d7184 1
d7186 1
a7186 1
		typeset -Uui16 -Z7 hv
d7188 1
a7188 1
		while read -ar line; do
a7189 1
			line[${#line[*]}]=10
d7214 1
a7214 1
		done
d7219 1
a7219 1
		print "$dasc|"
@


1.463
log
@check for embedded NULs work
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.462 2011/06/05 19:58:16 tg Exp $
d6612 5
a6616 7
		if (( (pos & 15) != 1 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
d6684 5
a6688 7
		if (( (pos & 15) != 1 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
d6963 5
a6967 7
		if (( (pos & 15) != 1 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
d7046 5
a7050 7
		if (( pos & 7 )); then
			while (( pos & 7 )); do
				print -n '     '
				(( (pos++ & 7) == 3 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
d7129 5
a7133 7
		if (( (pos & 15) != 1 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
d7209 5
a7213 7
		if (( pos & 7 )); then
			while (( pos & 7 )); do
				print -n '     '
				(( (pos++ & 7) == 3 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
@


1.462
log
@ rework hash table interna to avoid gcc-4.1 on Debian etch bug
 also improve behaviour with _a lot_ (>2) entries
 while here, improve comments and whitespace
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.461 2011/06/05 16:49:54 tg Exp $
d6941 1
a6941 1
		print
d6994 1
a6994 1
	00000120  FF 0A                   -                          |..|
d7016 1
d7098 1
a7098 1
	00000128  EFBE EFEF EFBF EFBF - 000A                 |.|
d7112 1
a7112 1
		print
d7164 1
a7164 1
	00000120  FF 0A                   -                          |..|
d7186 1
d7265 1
a7265 1
	00000128  EFBE EFEF EFBF EFBF - 000A                 |.|
@


1.461
log
@heredoc-weird-3 is timing-critical  need-pass: no
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.460 2011/06/04 17:08:11 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/06/04
@


1.460
log
@mark all 23 history-ed tests as need-pass: no
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.459 2011/06/04 16:42:28 tg Exp $
d2331 1
@


1.459
log
@fix segfault due to limit of hashtable entries (global variables) discovered by Jb_boin: unlimit to 2^30 minus epsilon
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.458 2011/06/04 16:11:16 tg Exp $
d3094 1
d3118 1
d3151 1
d3184 1
d3206 1
d3235 1
@


1.458
log
@better parsing for x=()  bug noted by Frank Terbeck
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.457 2011/05/29 16:38:58 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R40 2011/05/29
@


1.457
log
@add test for x+=(y z) and ;;& functions in tree dumper (!MKSH_SMALL)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.456 2011/05/29 16:31:40 tg Exp $
d6135 1
a6135 1
name: arrays-2
d6146 27
d7705 1
a7705 1
			eval set -A c+ -- d e 
@


1.456
log
@ AIX: display OS version better (tested on 5.3 by cnuke@@)
 IBM XL C: display version better (tested on V7.0 by cnuke@@)
 do not 'IFS=: read nr name', Cygwin 1.7 dash fails it
 disable cd-pe, glob-range-3 on Cygwin (the former cannot
  succeed because the mv fails, the latter fails from 1.7 on)
 mark heredoc-tmpfile-8 as need-pass: no
 apply __attribute__ only to a function prototype, not to
  the body (even if static), since xlC fails that
 bump version to R40 (beta)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.455 2011/05/29 02:18:47 tg Exp $
d7664 19
@


1.455
log
@mksh R40 Release Candidate 1

Testsuite:
 add new need-pass: {yes|no} attribute, default yes
 exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
 mark utf8bom-2 as need-pass: no
Infrstructure:
 add housekeeping function for making a tty raw
 switch functions with unused results to void
 struct op: u.charflag contains last char of ;; in TPAT
 var.c:arraysearch is now a global function
Language:
 add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
 add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
 allow read -N -1 or -n -1 to slurp the entire input
 add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
 add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
 full rewrite of read builtin and its manpage section
 add regression tetss for most of the new functionality
 duplicate hexdump demo tests for use of read -a
 use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.454 2011/05/07 02:02:45 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/05/28
d1012 2
d1024 3
a1026 1
	echo pwd=$?,$epwd
a1040 1
	pwd=1,
a1044 1
	pwd=1,
d1912 2
a1913 1
category: !os:darwin
d2550 1
@


1.454
log
@handle MKSH_SMALL not doing foo+=()
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.453 2011/05/07 00:51:09 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/05/06
d1008 37
d3804 28
d5790 1
d6891 1
a6891 1
name: integer-base-one-3A
d6958 1
a6958 1
name: integer-base-one-3W
d7061 166
d7248 26
d7703 1
a7703 1
	case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zhlen;;  esac
d7860 1
a7860 1
		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zhlen;;  esac
d7866 1
a7866 1
			;;
d7869 1
a7869 1
			;;
d7876 1
a7876 1
		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zhlen;;  esac
d7879 1
a7879 1
		x=$(case $foo in (1) echo eins  ;; (2) echo zwei  ;; (*) echo kann net bis drei zhlen  ;; esac ) 
d7882 1
a7882 1
		case  $foo  in  1)  echo eins;; 2) echo zwei  ;; *) echo kann net bis drei zhlen;;  esac
d7885 1
a7885 1
		x=$(( case $foo in (1) echo eins  ;; (2) echo zwei  ;; (*) echo kann net bis drei zhlen  ;; esac ) | tr u x ) 
d9106 34
@


1.453
log
@ fix an inverted logic bug in the test I wrote
 only trigger deleting an alias in favour of a function for (), not
  just the opening parenthesis: stop( ) is not a function definition
  (well, actually it seems to be, but not according to POSIX, anyway)
 defer dropping the alias until the function is actually defined ()
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.452 2011/05/07 00:02:26 tg Exp $
d6270 1
a6270 1
name: arrays-9
d6272 14
a6285 1
	Check that we can concatenate parameters and arrays
a6288 3
	unset foo; foo=(bar); foo+=(baz); echo 3 ${!foo[*]} : ${foo[*]} .
	unset foo; foo=(foo bar); foo+=(baz); echo 4 ${!foo[*]} : ${foo[*]} .
	unset foo; foo=([2]=foo [0]=bar); foo+=(baz [5]=quux); echo 5 ${!foo[*]} : ${foo[*]} .
a6291 3
	3 0 1 : bar baz .
	4 0 1 2 : foo bar baz .
	5 0 2 3 5 : bar foo baz quux .
@


1.452
log
@a regression and a new bug, found during cvs development
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.451 2011/05/06 15:41:21 tg Exp $
d6049 1
a6049 1
	false || local() { :; }
@


1.451
log
@ add patch from Robert Luberda <robert@@debian.org> fixing the
  four-argument form of test (yet again), thanks
 drop the obsolete (pre-POSIX) form test -t without fd
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.450 2011/05/05 00:04:55 tg Exp $
d2093 8
d6044 11
@


1.450
log
@ use a flag for determining here strings, dont parse delimiter every time
 dont leak memory parsing possible I/O redirection tokens
 get rid of volatile by using more const (also helps codegen, methinks)
 support empty here document markers (mksh extension)
 pimp the manpage
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.449 2011/05/04 23:16:00 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/05/04
d8790 32
@


1.449
log
@+= support for variables and arrays
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.448 2011/05/02 22:52:49 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/05/02
d2132 39
@


1.448
log
@ fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
 merge tputS and wdstrip_internal
 net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.447 2011/04/22 21:44:33 tg Exp $
d6212 16
@


1.447
log
@sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.446 2011/04/17 12:24:42 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/04/22
d7395 1
a7395 1
	[[ ${foo#blub} = @@(bar|baz) ]]
d7812 1
a7812 1
		[[ ${foo#blub} = @@(bar|baz) ]]
d7815 1
a7815 1
		[[ ${foo#blub} = @@(bar|baz) ]] 
d7818 1
a7818 1
		[[ ${foo#blub} = @@(bar|baz) ]]
d7821 1
a7821 1
		x=$([[ ${foo#blub} = @@(bar|baz) ]] ) 
d7824 1
a7824 1
		[[ ${foo#blub} = @@(bar|baz) ]]
d7827 1
a7827 1
		x=$(( [[ ${foo#blub} = @@(bar|baz) ]] ) | tr u x ) 
@


1.446
log
@always catch SIGALRM even in non-interactive shells to make sleep work
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.445 2011/04/09 18:47:12 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/04/17
@


1.445
log
@sync various things
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.444 2011/04/09 15:39:50 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/04/09
@


1.444
log
@cnuke says Haiku is like GNU in that it has no /usr whatsoever
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.443 2011/04/02 10:30:09 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/04/01
d7215 1
d7217 1
a7217 1
	print -u3 Fowl
d7222 2
a7223 2
expected-stderr:
	test.sh[1]: print: -u: 3: bad file descriptor
d7230 1
a7230 1
	print -u3 Fowl
@


1.443
log
@skip the UTF-8 BOM early, then check the magic (ELF, a.out, COFF, )
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.442 2011/03/28 21:58:06 tg Exp $
d5129 1
a5129 1
	/usr/bin/env false && echo something
d5134 1
a5134 1
	+ /usr/bin/env false
d5142 2
a5143 2
	if /usr/bin/env true; then
		/usr/bin/env false && echo something
d5149 2
a5150 2
	+ /usr/bin/env true
	+ /usr/bin/env false
@


1.442
log
@Add -C regress:no-ctty option to test.sh for Fedora chroots

STRONGLY DISCOURAGED
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.441 2011/03/28 21:30:59 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/28
@


1.441
log
@we got a decision on pathnames with exactly two leading slashes
thanks, Eric and David!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.440 2011/03/28 21:18:00 tg Exp $
d1016 1
d2490 1
d2507 1
d2528 1
d2551 1
d2571 1
d2591 1
d2607 1
d2626 1
d2652 1
d2676 1
d2699 1
d2723 1
d2746 1
d2773 1
d2799 1
d2826 1
d2853 1
d2880 1
d2907 1
d2926 1
d2945 1
d2965 1
d2983 1
d3005 1
d3028 1
d3060 1
d3092 1
d3113 1
d3141 1
d3338 1
d4357 1
d4388 1
d4992 1
d5040 1
d5418 1
d5578 1
d5749 1
d5768 1
d8085 1
d8114 1
d8141 1
@


1.440
log
@I made a mistake in the tests; this stuff works always (and can be tested)
but triggers only for /bin/sh if MKSH_BINSHREDUCED (otherwise needs -o sh)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.439 2011/03/28 08:40:40 tg Exp $
d8667 1
a8667 2
	cd -P ../libexec
	pwd
d8679 2
a8680 2
	//usr/bin/../lib
	//usr/libexec
@


1.439
log
@add testcases, bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.438 2011/03/27 18:50:02 tg Exp $
d1558 1
a1558 1
name: eglob-trim-3a
d1561 1
a1561 1
category: !binsh
d1563 1
a1563 1
	set -o sh
a1567 9
expected-stdout:
	<foo,foo>
	<foo,foo>
---
name: eglob-trim-3b
description:
	Check eglobbing doesnt work in trims, for reduced-feature /bin/sh
category: binsh
stdin:
a1568 2
	x=foobar
	y=foobaz
d1573 2
@


1.438
log
@ Implement http://austingroupbugs.net/view.php?id=367 and align things
  a bit more with POSIX and the other shells

I considered http://austingroupbugs.net/view.php?id=253 but the use
of bi_errorf() is interesting, especially as its often enough a
noreturn function, and funnily enough, 'cd -P /foo' returns 0 while
'chdir -P /foo' fails (so idk where to put -e)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.437 2011/03/26 21:46:00 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/27
d1558 29
@


1.437
log
@ bring back test -H ifdef S_ISCDF (for HP-UX)
 whitespace, etc.
 bump version for tonight, Im not gonna hack on c_cd,
  all this pathname stuff is mind-boggling
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.436 2011/03/26 21:09:06 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/26
d4682 59
@


1.436
log
@ rewrite simplify_path() to keep more in line with do_realpath()
 add regression test to ensure that //foo pathnames are never simplified
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.435 2011/03/26 16:19:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/23
@


1.435
log
@one more from Austin ML
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.434 2011/03/26 16:11:41 tg Exp $
d8584 6
d8600 3
@


1.434
log
@special-case another bizarre POSIX corner case
after david korn agreed to change ksh93 to match
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.433 2011/03/26 15:32:35 tg Exp $
d1395 1
a1395 1
name: expand-trim-1
d1411 12
@


1.433
log
@new (some possible) testcases from Austin ML, and one fix
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.432 2011/03/23 18:47:04 tg Exp $
d1395 16
@


1.432
log
@ironhead reported in IRC that some Cygwin guys (not he, hes just the
packager) complain that mksh collapses two leading slashes; IIRC POSIX
has a clause for UNC pathnames, so stop doing that, plus add a test
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.431 2011/03/21 21:57:32 tg Exp $
d2083 150
@


1.431
log
@ save/restore here document pointer during yyrecursive(), fixes crash
 add mirbsd/openbsd (omalloc rules!) specific testcase for the above
 $__progname must be used quoted, fix in comsub-torture testcase (my bad)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.430 2011/03/17 22:09:20 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/21
d8387 30
@


1.430
log
@fix cast; bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.429 2011/03/16 20:56:30 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/17
d7043 1
a7043 1
			print -r -- "${x}typeset -f inline_$nextf" | $__progname
d7046 1
a7046 1
			print -r -- "${x}typeset -f comsub_$nextf" | $__progname
d7049 1
a7049 1
			print -r -- "${x}typeset -f reread_$nextf" | $__progname
d8387 10
@


1.429
log
@actually, we need the android lsmod to be a builtin not an alias
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.428 2011/03/16 20:26:34 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/16
@


1.428
log
@ introduce a virtual TARGET_OS=Android that just sets a check category
  and switches to the TARGET_OS=Linux
 introduce android as regression test suite category
 add an android specific standard alias
 clean up redundant -o sh arg in a few checks
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.427 2011/03/13 17:07:08 tg Exp $
d5531 1
a5531 1
category: arge
a5548 22
name: aliases-1-android
description:
	Check if built-in shell aliases are okay
category: android
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	lsmod='cat /proc/modules'
	nameref='typeset -n'
	nohup='nohup '
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
---
d5624 1
a5624 1
category: arge
d5646 1
a5646 46
category: arge
stdin:
	cp "$__progname" sh
	./sh -c 'alias; typeset -f'
	rm -f sh
expected-stdout:
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	nameref='typeset -n'
	nohup='nohup '
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
---
name: aliases-2b-android
description:
	Check if set -o sh does not influence built-in aliases
category: android
arguments: !-o!sh!
stdin:
	alias
	typeset -f
expected-stdout:
	autoload='typeset -fu'
	functions='typeset -f'
	hash='alias -t'
	history='fc -l'
	integer='typeset -i'
	local=typeset
	login='exec login'
	lsmod='cat /proc/modules'
	nameref='typeset -n'
	nohup='nohup '
	r='fc -e -'
	source='PATH=$PATH:. command .'
	type='whence -v'
---
name: aliases-3b-android
description:
	Check if running as sh does not influence built-in aliases
category: android
a5658 1
	lsmod='cat /proc/modules'
@


1.427
log
@testsuite for mksh-small needs adjusting
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.426 2011/03/13 16:20:43 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/13
d5508 1
a5508 1
category: !arge
d5549 22
a5586 1
arguments: !-o!sh!
d5598 1
a5598 1
category: !arge
d5622 1
a5622 2
category: !arge
arguments: !-o!sh!
d5669 22
d5693 22
d5726 1
@


1.426
log
@we need not only store into the retrace buffers recursively but also ungetsc
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.425 2011/03/13 16:03:49 tg Exp $
d6944 1
a6944 1
name: comsub-1
d6949 1
a6949 1
	Passes on: bash4 ksh93 mksh(20110305+)
d6953 13
a6967 4
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo ${a[0]}.
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo ${a[0]}.
	TEST=1234; echo ${TEST: $(case 1 in (1) echo 1;; (*) echo 2;; esac)}
	TEST=5678; echo ${TEST: $(case 1 in 1) echo 1;; *) echo 2;; esac)}
a6969 2
	a=($(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))); echo ${a[0]}.
	a=($(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))); echo ${a[0]}.
a6970 2
	yes
	yes
d6975 12
a6986 2
	234
	678
@


1.425
log
@ speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
 parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.424 2011/03/13 15:57:21 tg Exp $
d6961 2
d6974 2
@


1.424
log
@let SLETARRAY use SRETRACE, too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.423 2011/03/13 01:20:14 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/12
d5376 1
a5376 1
	: mit
d5407 1
d5411 1
d5415 3
@


1.423
log
@lint is your friend
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.422 2011/03/12 23:06:41 tg Exp $
d6950 2
d6961 2
a6967 11
name: comsub-1b
description:
	COMSUB inside SLETARRAY and SASPAREN/EXPRSUB
expected-fail: yes
stdin:
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo ${a[0]}.
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo ${a[0]}.
expected-stdout:
	1.
	1.
---
@


1.422
log
@now fix that segfault and other bug from yesternight
do it like ksh93 though, not like bash and zsh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.421 2011/03/12 23:04:44 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/08
d6948 2
d6957 2
a6968 2
	echo $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))
	echo $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))
a6971 2
	11
	21
@


1.421
log
@ back out the EXPRSUB change
 optimise some code
 split testcase into two, one with expected-fail
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.420 2011/03/12 20:20:14 tg Exp $
a1375 1
	XXX still does, and decide on stderr
a1379 2
expected-stdout:
	1 but still living
d1381 2
a1382 1
	/.*/
a1386 1
	XXX still doesn't, and decide on stderr
a1390 2
expected-stdout:
	1 but still living
d1392 2
a1393 1
	/.*/
@


1.420
log
@even more test cases for comsub (2 breaking, but one of them fixed already)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.419 2011/03/12 01:04:39 tg Exp $
a6951 2
	echo $(($(case 1 in (1) echo 1;; (*) echo 2;; esac)+10))
	echo $(($(case 1 in 1) echo 1;; *) echo 2;; esac)+20))
a6955 2
	a=($(case 1 in (1) echo 1;; (*) echo 2;; esac)); echo ${a[0]}.
	a=($(case 1 in 1) echo 1;; *) echo 2;; esac)); echo ${a[0]}.
a6958 2
	11
	21
d6963 13
@


1.419
log
@tests for a segfault and a failure-to-fail from Jb boin on dedior on IRC
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.418 2011/03/08 18:49:48 tg Exp $
d6952 8
d6963 8
@


1.418
log
@ add a tree debugging dumper #ifdef DEBUG
 use shf_putc (macro), shf_putchar (function) ipv tputc
 replace shf_putchar(x,y) calls for side-effect-less x with shf_putc
 plug another bug in the tree code  '\'  "\\" (backslashes must be
  escaped inside double quotes, too)
 adjust testsuite (and, I _had_ wondered)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.417 2011/03/07 20:32:48 tg Exp $
d1373 26
@


1.417
log
@ x=$(cat <<-EOF
	EOF) # works again now, plugging a regression
 rewrite the here document parsing code to be *much* more efficient
  (and a bit more readable too!) using goto, while here (no kidding)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.416 2011/03/06 17:08:10 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/07
d7437 1
a7437 1
		echo "fo\ob\\"a\\`r"\'"b\\$az" 
d7445 1
a7445 1
		x=$(echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\ob\\"a\\`r"\'"b\\$az" ) 
d7453 1
a7453 1
		x=$(( echo fo\ob\"a\`r\'b\$az ; echo "fo\ob\"a\`r\'b\$az" ; echo "fo\ob\\"a\\`r"\'"b\\$az" ) | tr u x ) 
@


1.416
log
@ more fixes (some regression, some new)
 more testcases, stricter testcases
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.415 2011/03/06 17:06:17 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/06
d6974 1
a6974 1
		elif [[ $line = EOFN ]]; then
d7040 23
d7473 155
@


1.415
log
@drop IFS-space-colon-3 because dash is the only shell which passes it,
but ksh93 passes ifs.sh which I assume is more correct, and mksh and
ksh93 have the same result for this (as do bash2/4, posh; zsh differs)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.414 2011/03/06 01:50:08 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/03/05
d2048 1
a2048 1
	    vc= <<- EOF 
d6965 486
d7833 1
a7833 1
	if ( (echo fubar) | tr u x); then
d7846 9
a7854 1
	echo $( (echo fubar) | tr u x) $?
d7862 1
a7862 1
	if ((echo fubar) | tr u x); then
d7875 9
a7883 1
	echo $((echo fubar) | tr u x) $?
d7891 1
a7891 1
	if ( (echo fubar) | (tr u x)); then
d7904 9
a7912 1
	echo $( (echo fubar) | (tr u x)) $?
d7920 1
a7920 1
	if ((echo fubar) | (tr u x)); then
d7933 9
a7941 1
	echo $((echo fubar) | (tr u x)) $?
@


1.414
log
@I thought of making COMSUB pass a pointer to the struct op *t->left around
instead, but the parser for the so-called backticks (U+0060) still emits
plaintext COMSUB wdstrings, and the evaluation code emits plaintext if the
code is not run (-n option), so its not worth the effort and memory ma-
nagement issues, even though it _would_ optimise the most common case

Bump version numbers, sync regression tests; add one testcase from the old
webpages too. Sync manpage, this now works, but keep the workaround in, as
portability issue with slightly changed wording.

Also, /bin/sleep must be used in one manpage example if sleep is built in.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.413 2011/02/27 19:41:17 tg Exp $
a2996 17
name: IFS-space-colon-3
description:
	Simple test, IFS=<white-space>:
	pdksh fails both of these tests
	not sure whether #2 is correct
stdin:
	showargs() { for i; do echo -n " <$i>"; done; echo; }
	IFS="$IFS:"
	x=
	set --
	showargs "$x$@@" 1
	showargs "$@@$x" 2
expected-fail: yes
expected-stdout:
	 <> <1>
	 <> <2>
---
@


1.413
log
@nvm, got it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.412 2011/02/27 19:31:34 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/02/18
d6936 4
a6939 5
	COMSUB are currently parsed by hacking lex.c instead of
	recursively (see regression-6): matching parenthess bug
	Fails on: pdksh mksh bash2 bash3 zsh
	Passes on: bash4 ksh93
expected-fail: yes
d6951 2
a6952 2
	Fails on: pdksh mksh bash2 bash3 bash4 zsh
	Passes on: ksh93
a6953 1
expected-fail: yes
d6964 18
@


1.412
log
@no idea why MiNT has this issue
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.411 2011/02/27 19:29:20 tg Exp $
d3896 4
a3899 1
	umask 333
d3902 1
a3902 1
	0333
@


1.411
log
@port to FreeMiNT: add OS uname and flags; 2>&- is evil; $UNIXMODE must be preserved; unlink(2) is weird
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.410 2011/02/19 21:39:14 tg Exp $
d3896 1
a3896 1
	umask 222
d3899 1
a3899 1
	0222
@


1.410
log
@MKSH_NOPROSPECTOFWORK has no co-processes. at all.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.409 2011/02/18 22:26:06 tg Exp $
d1755 2
@


1.409
log
@ add -u option (POSIX: unbuffered  nop) to the built-in cat
 PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
 add regression tests, documentation, etc.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.408 2011/02/13 21:13:05 tg Exp $
d4484 1
@


1.408
log
@* plug a regression introduced as a pasto (think, mira!)
* add selftest-direct-builtin-call regression test, while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.407 2011/02/11 01:18:15 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/02/13
d72 1
d74 1
a74 1
	./echo -c 'echo  foo'
d5248 22
@


1.407
log
@ more comment and intbool cleanup, add and improve some comments
 in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesnt suffice
 add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
 for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
 when called as builtin, echo behaves POSIXish
 add domainname as alias for true on MirBSD only, to be able to link it
 sync mksh Makefiles with Build.sh output
 adjust manpage wrt release plans
 link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
 drop linked utilities and, except for echo and kill, their manpages
 adjust instbin and link a few more there as well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.406 2011/02/09 13:08:24 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/02/11
d68 9
d4480 12
@


1.406
log
@fix warning about signed vs. unsigned comparision and potential truncation error
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.405 2011/02/03 15:57:49 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/02/09
@


1.405
log
@refactor code to be able to track whether we have a parameter substitution
or a proper glob expansion; if theres a dollar, but not a glob, refrain
from appending a space later (LP: #710539)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.404 2011/01/30 02:18:25 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/02/03
@


1.404
log
@fix typos
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.403 2011/01/30 01:35:56 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/01/29
@


1.403
log
@SUSv4 says trap foo UNKNOWN is not a syntax error, merely exit 0.
Inspired by 673dab8698b0399c967216c02262eaf95361a75c.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.402 2011/01/30 01:35:32 tg Exp $
d349 1
a349 1
	Check that \newline is not collasped after #
d359 1
a359 1
	Check that \newline is not collasped inside single quotes
d371 1
a371 1
	Check that \newline is not collasped inside single quotes
d421 1
a421 1
	Check that \newline is collasped before, in the middle of, and
d433 1
a433 1
	Check that \newline is collasped in $ sequences
d457 1
a457 1
	Check that \newline is collasped in $(..) and `...` sequences
d482 1
a482 1
	Check that \newline is collasped in $((..)) sequences
d504 1
a504 1
	Check that \newline is collasped in double quoted strings
d519 1
a519 1
	Check that \newline is collasped in here document delimiters
d542 1
a542 1
	Check that \newline is collasped in double-quoted here-document
d561 1
a561 1
	Check that \newline is collasped in various 2+ character tokens
@


1.402
log
@introduce MKSH_NOPROSPECTOFWORK which is like pdkshs JOB_SIGS in reverse, like MKSH_UNEMPLOYED is pdkshs JOBS in reverse; allows mksh to work (hah! no pun intended) with klibc (and possibly, Syllable Desktop and Plan 9) for now, until they fix their bugs
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.401 2011/01/22 20:33:11 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/01/22
d3388 20
@


1.401
log
@plug regression introduced with read -d by fixing the problem differently
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.400 2011/01/21 22:25:31 tg Exp $
d5196 1
@


1.400
log
@${foo@@x} is now special-expansion for values of x, defined for now:
# = hash of $foo
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.399 2011/01/21 22:00:17 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/01/21
d3414 16
@


1.399
log
@add read with delimiter, like AT&T ksh93 (thanks Dave for the suggestion)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.398 2011/01/09 21:57:22 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2011/01/08
d5944 10
@


1.398
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Ltzebuerg 

This was the third try. Where to put this was not palpable same for =()
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.397 2010/12/19 20:00:53 tg Exp $
d3414 24
@


1.397
log
@this is a bashism but might be from ksh93 IIRC still dead ugly as hell!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.396 2010/11/01 17:29:00 tg Exp $
d6 1
a6 1
# Copyright  2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/12/19
d2010 39
@


1.396
log
@change behaviour of argument-less exit in traps to match SUSv4; Debian #599484 (original patch from Jonathan Nieder, thanks!) in a variant that appears to handle nested traps well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.395 2010/10/01 19:04:37 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/11/01
d5987 16
@


1.395
log
@ Build.sh: fix a compiler warning which, had it not been irrelevant in
  a mirtoconf check, wouldve been a real problem on an LP64 platform
 sh.h: work around a bad interaction between -Wformat on gcc and manual
  string pooling for T_synerr, which is used in place of a format string
  in some places
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.394 2010/09/19 19:28:21 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/10/01
d4848 10
@


1.394
log
@while here, change SETUID_CAN_FAIL_WITH_EAGAIN to abort immediately
by suggestion of Chris Palmer again
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.393 2010/09/15 21:08:16 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/09/19
@


1.393
log
@revert part of the size reduction diff (zero size change though):
shellf() implies an shf_flush()
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.392 2010/09/14 21:26:07 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/09/15
@


1.392
log
@ Address concerns of Chris Palmer from the Android security team
   possible integer overflows in memory allocation, mostly
     multiplication: all are checked now
     addition: reviewed them, most were proven or guessed to be
      almost impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
     cost (MirBSD/i386 static): +76 .text
     cost (Debian sid/i386): +779 .text  -4 .data
   on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are insane)
     cost (Debian sid/i386): +192 .text (includes .rodata)
 setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
 define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.391 2010/09/05 19:51:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/09/14
@


1.391
log
@optimise error messages, option parsing, and make more builtins
recognise "--", costs us 20 .text 0 .data 0 .bss
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.390 2010/08/28 20:22:13 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/09/05
@


1.390
log
@shave off another 468 bytes: were 300 bytes smaller than BEFORE the
cat builtin was added now (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.389 2010/08/28 17:21:41 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/08/28
@


1.389
log
@make cat an mksh builtin, for things like here documents
if any options are given, the external programme is invoked instead
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.388 2010/08/24 15:47:44 tg Exp $
d2271 1
a2271 1
	/(.*cannot unlink HISTFILE.*\n)?X*$/
d6561 1
a6561 1
expected-stderr-pattern: /.*: cannot (create|overwrite) .*/
@


1.388
log
@this is category: os:mirbsd because of hardcoded errno and strerror values
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.387 2010/08/24 14:42:00 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/08/24
@


1.387
log
@fix realpath builtins handling of (source) pathnames with a trailing slash
as per POSIX (if a trailing slash is part of the symlink target it fails as
well, like GNU readlink -f does)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.386 2010/07/25 11:35:38 tg Exp $
d7378 1
@


1.386
log
@a tad annoying, when external programmes such as GNU screen are running,
we dont get SIGWINCH when the window size changes during the runtime of
that, so, the signal is only usable reliably during editing in the shell
and we re-check the window size before each interactive edit line again
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.385 2010/07/24 17:08:28 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/25
d7375 71
@


1.385
log
@int  bool
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.384 2010/07/21 11:31:13 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/24
@


1.384
log
@Michal Hlavinka from Red Hat found another SIGSEGV
fix: when iterating over all Sources, know when to stop
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.383 2010/07/19 22:41:01 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/21
@


1.383
log
@*sigh* this code is interesting: assume you want to output via shf to
a string buffer whose window size is currently 32 (initial), your data
is 96 bytes, this routine used to resize the buffer to 64, append your
first 64 bytes to it (no matter if there's already something in it)
and then writes the remaining bytes to stdio fd instead of the string
if it doesnt SIGABRT before

discovered by wbx@@  thanks  bug inherited from pdksh 5.2.14 (AD 1999)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.382 2010/07/17 22:09:30 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/19
d188 11
@


1.382
log
@ merge printf from OpenBSD
 deactivate %a and %A since our libc doesnt have it
 rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesnt support it
   saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
 fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
 fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
   a few enum warnings that relate to eglibcs {g,s}etrlimit() functions
    taking an enum instead of an int because theyre too stupid to adhere
    to POSIX interfaces they design by themselves
   all request for implicit conversion involving a "void *" on one side
 tweak the manual page somewhat more
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.381 2010/07/13 13:12:28 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/17
@


1.381
log
@partial oksh sync (RCSID and do add some parenthess to the list of
reserved words, but really only these which are only recognised at
the beginning of a line as the context says, not blindly all of them)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.380 2010/07/11 11:17:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/13
@


1.380
log
@on obsd/mbsd, entropy is cheap enough for us to do this (codepath in
kernel checked for both) for additional seeding ($RANDOM is still from
the LCG only)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.379 2010/07/04 17:45:11 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/11
@


1.379
log
@implement live SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.378 2010/05/22 12:49:13 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/07/04
@


1.378
log
@apply diff from manuel giraud via oksh to keep track of LINENO in a trap
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.377 2010/05/16 19:17:41 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/05/22
@


1.377
log
@related to 1004BF041CB522EEEE3 ${foo[*]} is a vector too; add testcases
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.376 2010/05/16 19:04:40 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/05/16
d3324 14
@


1.376
log
@disallow some more kinds to trim a vector; Debian #581867
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.375 2010/04/27 21:39:06 tg Exp $
d4503 16
@


1.375
log
@address two performance issues in do_realpath():
 avoid calling realloc twice in sequence, since the final
  size is known at the first call already
 do not lstat(2) the same path twice in the Hurd codepath
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.374 2010/04/20 09:10:05 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/04/27
@


1.374
log
@Fourth times a charm another bugfix related to the commitids
1004BBDD84556472D84, 1004BBF77B81D30DA7C and 1004BBF7CD656308A1C
to unbreak kwalletcli
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.373 2010/04/09 19:16:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/04/20
@


1.373
log
@draft a testcase to understand the problem fixed by cid 1004BBF77B81D30DA7C
and make it actually work: the OpenBSD fix failed since 1004BBDD84556472D84
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.372 2010/04/09 14:46:43 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/04/09
d1049 1
d1090 1
@


1.372
log
@more tests (from Herbert Xu) and answers (from Geoff Clare)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.371 2010/04/08 13:21:03 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/04/08
d5840 9
@


1.371
log
@Fix two more POSIX conformance bugs and minor documentation/comment issues
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.370 2010/03/27 16:53:15 tg Exp $
d4404 4
d4411 2
@


1.370
log
@fix another expand-ugly SUSv4 bug
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.369 2010/03/18 19:45:39 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/03/27
d1047 2
d1087 2
d4397 41
@


1.369
log
@lets just add more test cases
from Message-ID: <309618f38393fa1d57b69a67f1a6ce02@@austingroupbugs.net>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.368 2010/03/16 21:32:47 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/03/14
@


1.368
log
@correct #39 (but leave #38 as-is and hope POSIX gets fixed instead)
cf. Message-ID: <20100316102753.GB26711@@squonk.masqnet>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.367 2010/03/14 11:58:30 tg Exp $
d1039 8
a1046 7
	ar" baz}; echo .) 2>&- || (echo failed in 32; echo failed in 33)
	(echo -n '34 '; printf '<%s> ' "${IFS+foo 'b\
	ar' baz}"; echo .) 2>&- || (echo failed in 34; echo failed in 35)
	(echo -n '36 '; printf '<%s> ' "${IFS+foo "b\
	ar" baz}"; echo .) 2>&- || (echo failed in 36; echo failed in 37)
	(echo -n '38 '; printf '<%s> ' ${v=a\ b} x ${v=c\ d}; echo .) 2>&- || echo failed in 38
	(echo -n '39 '; printf '<%s> ' "${v=a\ b}" x "${v=c\ d}"; echo .) 2>&- || echo failed in 39
d1080 5
a1084 4
	34 <foo 'bar' baz> .
	36 <foo bar baz> .
	38 <a> <b> <x> <a> <b> .
	39 <a\ b> <x> <a\ b> .
@


1.367
log
@even better on Haiku:
* let ulimits work
* add a Haiku-specific ulimit
* always use UTF-8, they have no locales but a UTF-8 terminal
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.366 2010/03/01 17:28:05 tg Exp $
d1082 1
a1082 1
	39 <a b> <x> <a b> .
@


1.366
log
@another test (#39 is up for discussion on austin-group-l still)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.365 2010/02/25 20:18:14 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/02/25
d6345 3
a6347 2
	if ! x=$(ulimit -d); then
		echo expected to fail on this OS
@


1.365
log
@(hopefully) fix the substitution thing for good
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.364 2010/02/25 11:47:33 tg Exp $
d1044 2
d1081 2
@


1.364
log
@more/improved test cases
 expand-unglob-{dblq,unq} are the same as dash, but with \}  } as
  per austin-group-l discussion, although this is not (yet) a standards
  requirement, just a doesnt make sense otherwise thing
expand-ugly:
 printf '%s\n' "foo ${IFS+"b   c"} baz"  no field splitting, ksh93 is
  wrong here (2.6.2)
 \} vs. } as above
 ksh93 dropping a } is probably another ksh93 bug
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.363 2010/02/23 21:51:49 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/02/24
d1005 1
a1005 2
	Check that ${foo+bar} constructs are parsed correctly
	XXX pretty sure that 28 is wrong, but still under discussion
d1021 1
a1021 1
	u=x; (echo 15 "foo ${IFS+a$u{{{\}b} c ${IFS+d{}} bar" ${IFS-e{}} baz) 2>&- || echo failed in 15
d1035 9
d1059 1
a1059 1
	15 foo ax{{{}b c d{} bar } baz
d1071 8
a1078 4
	27 '$key'
	28 'x
	~
	x''x}"x}" #
d1082 1
a1082 1
	Check that ${foo+bar} constructs are parsed correctly
d1212 1
a1212 2
	Check that ${foo+bar} constructs are parsed correctly
	AT&T ksh93 slightly fails this
@


1.363
log
@begin fixing up ${foo+word}, see austin-group-l for discussion and DR
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.362 2010/02/23 18:13:00 tg Exp $
d1006 1
a1006 4
	XXX omitted (for my own sanity) for now:
	4 foo b
	c baz
	XXX actually, ksh93 is the *only* one doing that...
d1011 25
a1035 20
	(exit 1; echo -n '4 '; printf '%s\n' "foo ${IFS+"b   c"} baz") 2>&- || (echo failed in 4; echo failed in 5)
	(echo -n '6 '; printf '%s\n' "foo ${IFS+b   c} baz") 2>&- || echo failed in 6
	(echo 7 ${IFS+"}"z}) 2>&- || echo failed in 7
	(echo 8 "${IFS+"}"z}") 2>&- || echo failed in 8
	(echo 9 "${IFS+\"}\"z}") 2>&- || echo failed in 9
	(echo 10 "${IFS+\"\}\"z}") 2>&- || echo failed in 10
	(echo 11 foo ${IFS+'bar} baz'}) 2>&- || echo failed in 11
	(echo 12 "$(echo "${IFS+'}'z}")") 2>&- || echo failed in 12
	(echo 13 "$(echo ${IFS+'}'z})") 2>&- || echo failed in 13
	(echo 14 ${IFS+\}z}) 2>&- || echo failed in 14
	(echo 15 "${IFS+\}z}") 2>&- || echo failed in 15
	(echo -n '16 '; printf '%s\n' "foo ${IFS+"b   c"} baz") 2>&- || echo failed in 16
	l=t; (echo 17 ${IFS+h`echo -n i ${IFS+$l}h`ere}) 2>&- || echo failed in 17
	l=t; (echo 18 ${IFS+h$(echo -n i ${IFS+$l}h)ere}) 2>&- || echo failed in 18
	l=t; (echo 19 "${IFS+h`echo -n i ${IFS+$l}h`ere}") 2>&- || echo failed in 19
	l=t; (echo 20 "${IFS+h$(echo -n i ${IFS+$l}h)ere}") 2>&- || echo failed in 20
	l=t; (echo 21 ${IFS+h`echo -n i "${IFS+$l}"h`ere}) 2>&- || echo failed in 21
	l=t; (echo 22 ${IFS+h$(echo -n i "${IFS+$l}"h)ere}) 2>&- || echo failed in 22
	l=t; (echo 23 "${IFS+h`echo -n i "${IFS+$l}"h`ere}") 2>&- || echo failed in 23
	l=t; (echo 24 "${IFS+h$(echo -n i "${IFS+$l}"h)ere}") 2>&- || echo failed in 24
d1040 3
a1042 3
	failed in 4
	failed in 5
	6 foo b   c baz
d1044 5
a1048 5
	8 }z
	9 ""z}
	10 "}"z
	11 foo bar} baz
	12 ''z}
d1051 2
a1052 2
	15 }z
	16 foo b   c baz
d1060 7
a1066 1
	24 hi there
@


1.362
log
@x_bind cannot have the nonnull attribute
cought by Frank enstein Terbeck ft:#grml (efftee), 10x
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.361 2010/02/18 17:31:22 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/02/23
d1003 58
a1060 1
name: expand-unglob
a1062 3
	XXX this output differs from bash/dash/ksh93/zsh but
	XXX the exact interpretation of word in the construct
	XXX ${var+word} is still open and to be solved
d1064 1
d1067 1
d1081 1
d1093 15
a1107 1
	tl_norm 1
d1110 1
a1110 1
	tl_paren 4
d1113 8
a1120 5
expected-stdout:
	1 plus norm foo bar baz
	1 dash norm foo  baz
	1 eqal norm foo  baz
	1 qstn norm foo  baz
d1122 2
a1123 2
	1 DASH norm foo bar baz
	1 EQAL norm foo bar baz
d1125 1
a1125 1
	2 plus norm foo bar baz
d1130 2
a1131 2
	2 DASH norm foo bar baz
	2 EQAL norm foo bar baz
d1133 1
a1133 1
	3 plus norm foo bar baz
d1137 1
a1137 1
	3 PLUS norm foo bar baz
d1141 4
a1144 4
	4 plus parn foo (bar) baz
	4 dash parn foo  baz
	4 eqal parn foo  baz
	4 qstn parn foo  baz
d1165 155
@


1.361
log
@at least _parse_ the construct ${foo+(bar)} correctly
(whether the output is correct is still up for debate)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.359 2010/01/29 09:34:25 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/02/18
@


1.360
log
@this exclusion is unwarranted
@
text
@d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/01/29
d1003 89
@


1.359
log
@remove some more of this ugliness
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.358 2010/01/28 20:58:30 tg Exp $
a1893 1
category: !os:cygwin
@


1.358
log
@ unbreak testsuite for MKSH_SMALL
 sync version and  year
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.357 2010/01/28 15:18:46 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/01/28
@


1.357
log
@To solve the incompatibility issues between mksh-current, old mksh versions
and vendor pdksh versions, re-introduce FPOSIX alongside FSH. The semantics
are now:
 set -o posix 
   disable brace expansion and FSH when triggered
   use Debian Policy 10.4 compliant non-XSI echo builtin
   do not keep file descriptors > 2 to ksh
 set -o sh 
   set automatically #ifdef MKSH_BINSHREDUCED
   disable brace expansion and FPOSIX when triggered
   use Debian Policy 10.4 compliant non-XSI echo builtin
   do not keep file descriptors > 2 to ksh
   trigger MKSH_MIDNIGHTBSD01ASH_COMPAT mode if compiled in
   make set -- $(getopt ab:c "$@@") construct work

Note that the set/getopt one used to behave POSIXly only with FSH or
FPOSIX (depending on the mksh version) set and Bourne-ish with it not
set, so this changes default mksh behaviour to POSIX!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.356 2010/01/25 14:25:13 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/01/08
d6702 1
a6702 1
	bar=(b c a)
@


1.356
log
@introduce typeset -i foo[*], rationale see cid 1004B5DA60A56BFB604
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.355 2010/01/25 14:11:25 tg Exp $
d3091 32
a4411 29
name: exit-subst-1
description:
	Used to be regression-10 but was split into two tests.
	The following:
		set -- `false`
		echo $?
	should print 0 according to POSIX, but not 0 according to /bin/sh
	(XXX on which system?), AT&T ksh88, and the getopt(1) manual page
stdin:
	set -- `false`
	echo $?
expected-stdout:
	1
---
name: exit-subst-2
description:
	Used to be regression-10 but was split into two tests.
	The following:
		set -- `false`
		echo $?
	should print 0 according to POSIX, but not 0 according to /bin/sh
	(XXX on which system?), AT&T ksh88, and the getopt(1) manual page
stdin:
	test -n "$POSH_VERSION" || set -o sh
	set -- `false`
	echo $?
expected-stdout:
	0
---
@


1.355
log
@Add unset foo[*] mksh extension, which allows to unset the *contents*
of foo[0] (but not its attributes), and the rest of the array, so that
later set +A foo bar will set foo[0]=bar but retain the attributes.

This is important, because, in the future, arrays will have different
attributes per element, instead of all the same (which, actually, is
not entirely true right now either, since unset foo[0] will not mo-
dify the attributes of a foo[1] existing at that point in time), where
foo[$newkey] will inherit from foo[0], but typeset foo will only affect
foo[0] no longer foo[*] in the future. (The rules about typeset=local
will still apply, as they affect creation of variables in a scope.)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.354 2010/01/08 22:21:03 tg Exp $
d5266 1
d5275 1
d5283 1
d5291 1
d5300 1
d5308 1
@


1.354
log
@While we were supposed to use Ctrl-Arrowkey for wordwise jumping,
some idiotic terminal emulators and/or people seem to use the es-
cape codes normally denoting Alt-Arrowkey instead so let's simply
bind them to the vt_hack as well... (untested)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.353 2010/01/04 21:08:00 tg Exp $
d5227 77
@


1.353
log
@I don't care that AT&T ksh93 fails this nameref test case, but
it's important and we'll want it.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.352 2010/01/01 18:01:59 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2010/01/01
@


1.352
log
@make [[ -o -U ]] = [[ -o +U ]] = [[ -o utf8-mode ]]
where  is either nothing, ! or ? as usual.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.351 2010/01/01 17:44:06 tg Exp $
d6 1
a6 1
# Copyright  2003, 2004, 2005, 2006, 2007, 2008, 2009
d6611 15
@


1.351
log
@ re-implement wcswidth-like behaviour for ${%foo} even in !UTFMODE
 merge the rest of branch tg-wcswidth-behaviour
 enhance test cases for wcswidth-like behaviour
 switch hash table collision resolution algorithm to Pythons as announced
 bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.350 2009/12/31 14:05:42 tg Exp $
d4463 22
d4497 20
@


1.350
log
@jobs.c: apply patch from deraadt@@o:
remember to restore errno (ie. stop someone from making a mistake later)
ok guenther
check.t, sh.h: bump vsn

I wonder though why errno must be restored even if nothing was
called after reading it moid?
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.349 2009/12/12 22:27:03 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/12/31
d6712 9
a6720 1
	print octets: ${#s} ${%s} .
d6725 2
a6726 1
	octets: 3 3 .
d6729 4
d6739 6
d6747 2
@


1.349
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.348 2009/12/05 17:43:43 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/12/12
@


1.348
log
@llvm/clang scan-build is now content
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.347 2009/12/01 19:15:31 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/12/05
@


1.347
log
@* fix 'set -A foo -- [2]=a b c' contingency (tested against GNU bash4,
  which, in its latest sid incarnation, even received mksh's ability
  to produce ${!foo[*]} array keys, wow!)
* plug a memory leak while here (ATEMP only, but still)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.346 2009/11/28 15:38:28 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/12/01
@


1.346
log
@fix 'mksh -U -i' and 'mksh +U -i'
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.345 2009/11/28 14:27:58 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/11/28
d5107 3
d5112 2
@


1.345
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd it doesnt, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.343 2009/11/22 14:25:17 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/11/22
d4835 19
@


1.344
log
@switch ${%foo} to wcswidth-like behaviour  slightly problematic, and
the set +U case isnt even handled

committed to branch because Id like to get more input on this, for now
@
text
@a6701 3
	set -U
	x='a	b'
	print c ${%x} .
a6703 1
	c -1 .
@


1.343
log
@bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.342 2009/11/22 14:13:38 tg Exp $
d6702 3
d6707 1
@


1.343.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd it doesnt, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.344 2009/11/28 14:21:41 tg Exp $
a6701 3
	set -U
	x='a	b'
	print c ${%x} .
a6703 1
	c -1 .
@


1.342
log
@don't tell lies
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.341 2009/11/21 23:23:16 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/11/21
@


1.341
log
@since we have wcwidth anyway, expose it as ${%strvar} to the user, iff
utf8-mode is enabled (otherwise it'll be a synonym for ${#strvar} aka
the number of octets in it)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.340 2009/11/21 22:32:05 tg Exp $
a4357 1
	(current implementation fails coz it's ksh88 alike)
@


1.340
log
@fix that as well
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.339 2009/11/21 22:30:34 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/11/09
d6683 59
@


1.339
log
@improve globbing:
 a=bld; print ${a%???}  now printf 'b' not 'bl' in UTF-8 mode
 a=h; print ${a%?} still broken
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.337 2009/11/09 23:35:07 tg Exp $
d1364 1
a1364 1
	7:   .
@


1.338
log
@bugfix: ${x#?} should expand to nothing not '' if x was unset
@
text
@d1336 32
@


1.337
log
@make print_columns() aware that octetscharacterscolumns
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.336 2009/10/30 00:57:35 tg Exp $
d5252 12
@


1.336
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.335 2009/10/27 17:00:00 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/30
@


1.335
log
@do not use PATH_MAX on GNU/Hurd (even if it *was* defined), but use
some glibc-only functions that dont require its use instead

tested on gnubber, where (admittedly) sysconf(_PC_PATH_MAX) == 1024
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.334 2009/10/18 12:30:04 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/27
@


1.334
log
@ better IV for the oaathash-on-binary (as if we prepended a '\x01')
 better variable name for the LCG state
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.333 2009/10/17 21:16:01 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/18
@


1.333
log
@ overhaul handling of special variables
 use a combination of the one-at-a-time hash and an LCG for handling
  the $RANDOM special if !HAVE_ARC4RANDOM instead of rand(3)/srand(3)
  and get rid of time(3) usage to reduce import footprint
 raise entropy state (mostly in the !HAVE_ARC4RANDOM case though)
 simplify handling of the $RANDOM_SPECIAL generally
 tweak hash() to save a temp var for non-optimising compilers
 some int  mksh_ari_t and other type fixes
 general tweaking of code and comments
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.332 2009/10/15 16:36:25 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/17
@


1.332
log
@fix exit-eval-1 (Debian #550717), sync SUSv4 wording, improve comments
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.331 2009/10/15 16:32:23 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/15
@


1.331
log
@remove regression-44 in favour of utilities-getopts-1 (the former checked
the AT&T ksh88 behaviour, the latter the AT&T ksh93 behaviour, which dif-
fer from each other, on the very same thing with the exact same test)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.330 2009/10/15 16:24:49 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/10
a3426 1
expected-fail: no
a4326 1
expected-fail: yes
@


1.330
log
@modify the oksh-varfunction regression test to reflect that, indeed, a
change of a variable inside a Bourne style POSIX function will affect
the current execution environment of the function caller (to be consi-
stent with exec-function-environment-1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.329 2009/10/15 16:15:03 tg Exp $
a3467 15
name: regression-44
description:
	getopts sets OPTIND correctly for unparsed option
stdin:
	set -- -a -a -x
	while getopts :a optc; do
	    echo "OPTARG=$OPTARG, OPTIND=$OPTIND, optc=$optc."
	done
	echo done
expected-stdout:
	OPTARG=, OPTIND=2, optc=a.
	OPTARG=, OPTIND=3, optc=a.
	OPTARG=x, OPTIND=3, optc=?.
	done
---
@


1.329
log
@new exec-function-environment-1 replacing exec-simple-1 from posh, after
reading SUSv4 throughoutly
cf. Message-ID: <Pine.BSM.4.64L.0910151542460.4645@@herc.mirbsd.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.328 2009/10/15 15:32:34 tg Exp $
d6030 1
a6030 1
name: oksh-varfunction
d6037 2
a6038 1
	the function should receive a correct value of FOO. Additionally,
d6080 1
a6080 1
	if [ x$FOO != xbar ]; then
d6095 1
a6095 1
	if [ x$FOO != xbar ]; then
@


1.328
log
@poshs utilities-echo-2 is actually incorrect; reason here
cf. Message-ID: <Pine.BSM.4.64L.0910151525270.4645@@herc.mirbsd.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.327 2009/10/15 15:23:41 tg Exp $
d4021 11
@


1.327
log
@add two regression tests from Debian posh, adjusted to pass with ksh93
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.326 2009/10/15 14:58:50 tg Exp $
d6603 4
@


1.326
log
@another exit code in substitution questionable thing
split this one by set o sh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.325 2009/10/15 14:12:46 tg Exp $
d6610 30
@


1.325
log
@make some of these tests more posh-friendly
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.324 2009/10/15 12:50:11 tg Exp $
a3058 13
name: regression-10
description:
	The following:
		set -- `false`
		echo $?
	shoud not print 0. (according to /bin/sh, AT&T ksh88, and the
	getopt(1) man page - not according to POSIX)
stdin:
	set -- `false`
	echo $?
expected-stdout:
	1
---
d4355 29
@


1.324
log
@make exit-eval-1 an expected-fail for now, until we can fix this
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.323 2009/10/14 18:06:57 tg Exp $
d4389 1
a4389 1
	set -o sh
d6090 1
a6090 1
	set -o sh
a6586 1
arguments: !-o!sh!
d6588 1
@


1.323
log
@rename regression-56 into exit-eval-1 and change expected output
from what AT&T ksh88 does to what AT&T ksh93 does and POSuX expects

Reported by Clint Adams as Debian #550717, to be fixed...
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.322 2009/10/14 18:04:52 tg Exp $
d4344 2
@


1.322
log
@group exit-related tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.321 2009/10/10 21:17:28 tg Exp $
a3775 26
name: regression-56
description:
	Check eval vs substitution exit codes
	(this is what ksh88 does)
stdin:
	eval $(false)
	echo A $?
	eval ' $(false)'
	echo B $?
	eval " $(false)"
	echo C $?
	eval "eval $(false)"
	echo D $?
	eval 'eval '"$(false)"
	echo E $?
	IFS="$IFS:"
	eval $(echo :; false)
	echo F $?
expected-stdout:
	A 1
	B 1
	C 1
	D 0
	E 0
	F 1
---
d4341 25
@


1.321
log
@while testing haserl-0.9.26 on MirBSD, I discovered that the echo builtin
in FSH mode did in fact, contrary to POSIX and Debian Policy 10.4 behavi-
our (I think), interpret escape sequences; fix and add testsuite for echo
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.320 2009/10/10 17:39:48 tg Exp $
d4244 1
a4244 1
name: errexit-1
d4257 1
a4257 1
name: errexit-2
d4273 1
a4273 1
name: errexit-3
d4290 1
a4290 1
name: errexit-4
d4304 1
a4304 1
name: errexit-5
d4327 1
a4327 1
name: errexit-6
d4345 22
a6489 22
name: susv4-exit-enoent-1
description:
	SUSv4 says that the shell should exit with 126/127 in some situations
stdin:
	i=0
	(echo; echo :) >x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	echo exit 42 >x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	rm -f x
	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
expected-stdout:
	0 0 .
	1 126 .
	2 42 .
	3 126 .
	4 127 .
	5 127 .
---
@


1.320
log
@cygwin seems to force a+x for files beginning with ':\n' so prepend
a nop newline to make mksh.exe pass this test
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.319 2009/10/04 13:19:32 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/04
d6574 19
@


1.319
log
@fix lazy evaluation of assignments in ternary ops
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.318 2009/10/04 12:45:21 tg Exp $
d6473 1
a6473 1
	echo : >x
@


1.318
log
@fix long-standing parenthess problem: ((foo) || bar) is now parsed corr.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.316 2009/10/04 03:13:06 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/10/02
a226 1
expected-fail: yes
@


1.317
log
@fix dollar quotes in here strings and here documents (regression)
@
text
@d6491 84
@


1.316
log
@on the other hand, this is a regression in mksh, apparently
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.315 2009/10/02 18:08:31 tg Exp $
d5366 3
d5371 16
@


1.315
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.314 2009/10/02 17:05:01 tg Exp $
d5359 10
@


1.314
log
@make another Debian posh bug into a regression test (expected-fail)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.313 2009/10/02 16:59:53 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/29
d39 1
a39 1
	print ${foo:-baz}
d48 1
a48 1
	print ${foo:-baz}
d57 1
a57 1
	print "<$ENV>"
d278 1
a278 1
	print x1 $((-1)) $((#-1))
d283 1
a283 1
	print x2 $vs $vu
d286 1
a286 1
	print x3 $vs $vu
d290 1
a290 1
	print x4 $vs $vu
d293 1
a293 1
	print x5 $vs $vu
d295 1
a295 1
	print x6 $((# vs % 2147483647)) $((# vu % 2147483647))
d300 1
a300 1
	print x7 ${va[#4123456789%2147483647]}
d315 1
a315 1
	print x1 $((-1)) $((#-1))
d320 1
a320 1
	print x2 $vs $vu
d322 1
a322 1
	print x3 $vs $vu
d324 1
a324 1
	print x4 $vs $vu
d326 1
a326 1
	print x5 $vs $vu
d328 1
a328 1
	print x6 $vs $vu
d375 1
a375 1
	(don't know what posix has to say about this)
d398 1
a398 1
	(the old bourne shell trashes them; so do we)
d598 1
a598 1
	(don't know what posix has to say about this)
d3900 1
a3900 1
		print FNORD-0
d3912 1
a3912 1
		print FNORD-1
d3914 1
a3914 1
		print FNORD-2
d3916 1
a3916 1
		print FNORD-3
d3918 1
a3918 1
		print FNORD-4
d3920 1
a3920 1
		print FNORD-5
d3922 1
a3922 1
		print FNORD-6
d3924 1
a3924 1
		print FNORD-7
d3926 1
a3926 1
		print FNORD-8
d4117 1
a4117 1
	exec print hi
d4367 1
a4367 1
	set -o posix
d4461 1
a4461 1
name: posix-mode-1
d4463 1
a4463 1
	Check that posix mode turns braceexpand off
d4467 2
a4468 2
	set +o posix
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
d4475 1
a4475 1
	set -o posix
d4477 1
a4477 1
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
d4481 1
a4481 1
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
d4484 1
a4484 1
	noposix
d4490 1
a4490 1
	posix
d4493 1
a4493 1
	posix
d4496 1
a4496 1
name: posix-mode-2a
d4498 1
a4498 1
	Check that posix mode is *not* automatically turned on
d4507 1
a4507 1
		    '[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix')
d4510 4
a4513 4
	sh noposix
	ksh noposix
	-sh noposix
	-ksh noposix
d4515 1
a4515 1
name: posix-mode-2b
d4517 1
a4517 1
	Check that posix mode is automatically turned on
d4526 1
a4526 1
		    '[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix')
d4529 4
a4532 4
	sh posix
	ksh noposix
	-sh posix
	-ksh noposix
d4564 3
a4566 3
	"$__progname" -c 'i=100; print hi |& while read -p line; do print "$((i++)) $line"; done'
	"$__progname" -c 'i=200; print hi | cat |& while read -p line; do print "$((i++)) $line"; done'
	"$__progname" -c 'i=300; (print hi | cat) |& while read -p line; do print "$((i++)) $line"; done'
d4596 1
a4596 1
	print "<$ln> <$rn> <$lz> <$rz> <$rx>"
d4610 1
a4610 1
	print "<$ln> <$rn> <$zn> <$ls> <$rs> <$zs>"
d4628 1
a4628 1
	print got ${#anzahl[*]} files
d4641 1
a4641 1
	"$__progname" -c 'print : $(fnord)'
d4699 2
a4700 2
	"$__progname" -c ':; if [[ $- = *U* ]]; then print 1 on; else print 1 off; fi'
	"$__progname" -c ':; if [[ $- = *U* ]]; then print 2 on; else print 2 off; fi'
d4712 1
a4712 1
		print is set
d4714 1
a4714 1
		print is not set
d4726 1
a4726 1
		print is set
d4728 1
a4728 1
		print is not set
d4745 1
a4745 1
		print is set
d4747 1
a4747 1
		print is not set
d4763 1
a4763 1
		print is set
d4765 1
a4765 1
		print is not set
d4818 1
a4818 1
	Check if set -o posix disables built-in aliases (except a few)
d4820 1
a4820 1
arguments: !-o!posix!
d4832 1
a4832 1
arguments: !-o!posix!
d4843 1
a4843 1
	Check if set -o posix does not influence built-in aliases
d4845 1
a4845 1
arguments: !-o!posix!
d4869 1
a4869 1
arguments: !-o!posix!
d4892 1
a4892 1
	Check if set -o posix does not influence built-in aliases
d4894 1
a4894 1
arguments: !-o!posix!
d4916 1
a4916 1
arguments: !-o!posix!
d4999 1
a4999 1
	print ${foo[*]}
d5001 1
a5001 1
	print ${foo[4294967295]} g ${foo[*]}
d5076 3
a5078 3
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
d5080 3
a5082 3
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
d5084 3
a5086 3
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
d5106 7
a5112 7
	print a t${x:2:2} ${y:2:3} ${z:2:3} a
	print b ${x::3} ${y::3} ${z::3} b
	print c ${x:2:} ${y:2:} ${z:2:} c
	print d ${x:2} ${y:2} ${z:2} d
	print e ${x:2:6} ${y:2:6} ${z:2:7} e
	print f ${x:2:7} ${y:2:7} ${z:2:8} f
	print g ${x:2:8} ${y:2:8} ${z:2:9} g
d5131 4
a5134 4
	print a ${x:$n:3} ${y:$n:3} ${z:$n:3} a
	print b ${x:(n):3} ${y:(n):3} ${z:(n):3} b
	print c ${x:(-2):1} ${y:(-2):1} ${z:(-2):1} c
	print d t${x: n:2} ${y: n:3} ${z: n:3} d
d5167 1
a5167 1
	print a ${x:(y == 1 ? 2 : 3):4} a
d5177 4
a5180 4
	print a ${x::1} ${x: -1} a
	print b ${x::3} ${x: -3} b
	print c ${x:1:2} ${x: -3:2} c
	print d ${#x} d
d5193 4
a5196 4
	print a ${x::1} ${x: -1} a
	print b ${x::2} ${x: -2} b
	print c ${x:1:1} ${x: -2:1} c
	print d ${#x} d
d5430 2
a5431 2
	print "in <$i0> <$i1>"
	print "out <${o0a#1#}|${o0b#1#}> <${o1a#1#}|${o1b#1#}>"
d5433 1
a5433 1
	print "pass <$px> <$p0> <$p1> <$pl> <${i0#1#}|${i1#1#}>"
d5435 1
a5435 1
	print "specX <${tv1#16#}> <${tv2#16#}> <${tv3#16#}> <${tv4#16#}> <${tv5#16#}> <${tv6#16#}> <${tv7#16#}> <${tv8#16#}>"
d5437 1
a5437 1
	print "specW <${tv1#1#}> <${tv2#1#}> <${tv3#1#}> <${tv4#1#}> <${tv5#1#}> <${tv6#1#}> <${tv7#1#}> <${tv8#1#}>"
d5439 1
a5439 1
	print "specU <${xs1#1#}> <${xs2#1#}> <${xs3#1#}>"
d5454 1
a5454 1
	print /$x/
d5465 1
a5465 1
	print /$x/
d5476 1
a5476 1
	print /$x/
d5486 1
a5486 1
	print /$x/
d5497 1
a5497 1
	print /$x/	# invalid utf-8
d5507 1
a5507 1
	print /$x/	# invalid 2-byte
d5517 1
a5517 1
	print /$x/	# invalid 2-byte
d5527 1
a5527 1
	print /$x/	# invalid 3-byte
d5538 1
a5538 1
	print /$x/	# non-minimalistic
d5549 1
a5549 1
	print /$x/	# non-minimalistic
d5730 3
a5732 3
	print 1 $(('a'))
	(print 2f $(('aa'))) 2>&1 | sed "s/^[^']*'/2p '/"
	print 3 $((''))
d5734 3
a5736 3
	print "4 <$x>"
	print 5 $(($x))
	print 6 $((x))
d5750 1
a5750 1
		print expected to fail on this OS
d5752 1
a5752 1
		ulimit -dS $x && print okay
d5915 1
a5915 1
	print x$foo
d5926 1
a5926 1
	print baz >&12
d5958 1
a5958 1
	env. If f is a bourne style function, FOO should be set. Furthermore,
d6039 1
a6039 1
	set -o posix
d6288 1
a6288 1
	Check that "set -u" matches (future) POSIX requirement
d6369 4
a6372 4
	print !ind: ${!ind}
	print ind: $ind
	print !ir2: ${!ir2}
	print ir2: $ir2
d6374 2
a6375 2
	print !ind: ${!ind}
	print ind: $ind
d6377 2
a6378 2
	print !ir2: ${!ir2}
	print ir2: $ir2
d6384 4
a6387 4
	print !ind[1]: ${!ind[1]}
	print !ir2: $!ir2
	print ind[1]: ${ind[1]}
	print ir2: $ir2
d6412 6
a6417 6
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
d6419 3
a6421 3
		print bar: $bar
		print v: $v
		print exiting
d6424 1
a6424 1
	print bar: $bar
d6426 1
a6426 1
	print bar: $bar
@


1.313
log
@fix typos, From: Clint Adams <schizo@@debian.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.312 2009/09/29 12:28:12 tg Exp $
d223 12
@


1.312
log
@SUSv4 says that there be exit 127; the old code tried but failed, so it
was an actual programmatical bug
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.311 2009/09/26 03:39:57 tg Exp $
d225 1
a225 1
	Check precidance of ternary operator vs assignment
d235 1
a235 1
	Check precidance of ternary operator vs assignment
@


1.311
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.310 2009/09/24 17:15:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/25
d6428 22
@


1.310
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.309 2009/09/23 18:04:53 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/24
d4045 2
a4046 2
	env | $sortprog >bar1
	FOO=bar exec; env | $sortprog >bar2
@


1.309
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.308 2009/09/20 17:23:49 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/23
@


1.308
log
@Add a hack input function for VT100-style key sequences; support
Ctrl-CurLeft and Ctrl-CurRight (not quite ANSI, but fits the scheme)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.307 2009/09/19 21:54:42 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/20
d4972 1
d4997 1
d5008 1
d5715 1
d6158 1
d6186 1
d6212 1
d6248 1
d6369 1
a6369 1
	blub=(e1 e2 e3)
@


1.307
log
@$'' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.306 2009/09/19 18:36:57 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/19
@


1.306
log
@allow function stop () { (bashism, an evil one)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.305 2009/09/07 17:24:47 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/07
d5213 8
d5234 110
@


1.305
log
@another ksh93 feature: test -o ?foo (almost zero cost)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.304 2009/09/06 17:55:53 tg Exp $
d5259 27
@


1.304
log
@Support Dave Korns alternative 'a' (or '') form for base-one
integers in addition to my 1#a (or 1#), which also allows for
finer end-of-character checking. Note that this is locale-dependent in
ksh93, set U dependent in mksh, and mkshs OPTU-16 encoding is used.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.303 2009/09/06 17:42:11 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/09/06
d4360 41
@


1.303
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.301.2.3 2009/09/01 16:32:51 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/08/30
d5523 20
@


1.302
log
@add the chdir builtin from mircvs://contrib/hosted/tg/deb/mksh/ for
better dash compatibility (mksh is now a dash superset if printf is
compiled in)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.301 2009/08/28 22:46:19 tg Exp $
d4200 1
a4200 1
	ksh88, Solaris /bin/sh and /usr/xpg4/bin/sh all print the error,
d4734 1
d4757 1
d4804 1
d4829 1
d4853 1
d4876 1
d5015 27
d6136 78
@


1.301
log
@documentation and test suite for tonights new features,  gn8
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.300 2009/08/28 21:35:42 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/08/28
@


1.301.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic typeset -n v=$1 or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.301 2009/08/28 22:46:19 tg Exp $
a4733 1
	nameref='typeset -n'
a4755 1
	nameref='typeset -n'
a4801 1
	nameref='typeset -n'
a4825 1
	nameref='typeset -n'
a4848 1
	nameref='typeset -n'
a4870 1
	nameref='typeset -n'
a5008 38
name: arrays-6a
description:
	Check if we can get the array keys (indices) for indexed arrays,
	Korn shell style, in some corner cases
stdin:
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
	arz=foo
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
expected-stdout:
	!arz: 0
	!arz[0]:
	!arz[1]:
	!arz: arz
	!arz[0]: 0
	!arz[1]:
---
name: arrays-6b
description:
	Check if we can get the array keys (indices) for indexed arrays,
	Korn shell style, in some corner cases
expected-fail: yes
stdin:
	arz=foo
	print !arz: ${!arz}
	unset arz
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
expected-stdout:
	!arz: arz
	!arz: arz
	!arz[0]:
	!arz[1]:
---
a6102 70
name: nameref-1
description:
	Testsuite for nameref (bound variables)
stdin:
	function foo {
		typeset bar=lokal baz=auch
		typeset -n v=bar
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
		v=123
		print bar: $bar
		print v: $v
		print exiting
	}
	bar=global
	print bar: $bar
	foo bar
	print bar: $bar
	typeset -n ir2=bar
	typeset -n ind=ir2
	print !ind: ${!ind}
	print ind: $ind
	print !ir2: ${!ir2}
	print ir2: $ir2
	typeset +n ind
	print !ind: ${!ind}
	print ind: $ind
	typeset -n ir2=ind
	print !ir2: ${!ir2}
	print ir2: $ir2
	set|grep ^ir2|sed 's/^/s1: /'
	typeset|grep ' ir2'|sed -e 's/^/s2: /' -e 's/nameref/typeset -n/'
	blub=(e1 e2 e3)
	typeset -n ind=blub
	typeset -n ir2=blub[2]
	print !ind[1]: ${!ind[1]}
	print !ir2: $!ir2
	print ind[1]: ${ind[1]}
	print ir2: $ir2
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: lokal
	bar: 123
	v: 123
	exiting
	bar: global
	!ind: bar
	ind: global
	!ir2: bar
	ir2: global
	!ind: ind
	ind: ir2
	!ir2: ind
	ir2: ir2
	s1: ir2=ind
	s2: typeset -n ir2
	!ind[1]: 1
	!ir2: ir2
	ind[1]: e2
	ir2: e3
---
@


1.301.2.2
log
@David Korn confirmed this to be a bug in
.At
.Nm ksh .
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.301.2.1 2009/08/30 20:56:03 tg Exp $
d4200 1
a4200 1
	ksh88/93, Solaris /bin/sh and /usr/xpg4/bin/sh all print the error,
d5015 1
a5015 1
name: arrays-7
a5026 4
	unset arz
	print !arz: ${!arz}
	print !arz[0]: ${!arz[0]}
	print !arz[1]: ${!arz[1]}
d5034 16
a5049 1
	!arz: 0
@


1.301.2.3
log
@the rest of the nameref tests; apparently, ksh93 insists on this
behaviour (or weirdness)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.301.2.2 2009/09/01 16:19:47 tg Exp $
d6140 18
d6180 11
a6205 144
name: nameref-2da
description:
	Testsuite for nameref (bound variables)
	Functions, argument given directly, after local
stdin:
	function foo {
		typeset bar=lokal baz=auch
		typeset -n v=bar
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
		v=123
		print bar: $bar
		print v: $v
		print exiting
	}
	bar=global
	print bar: $bar
	foo bar
	print bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: lokal
	bar: 123
	v: 123
	exiting
	bar: global
---
name: nameref-2db
description:
	Testsuite for nameref (bound variables)
	Functions, argument given directly, before local
stdin:
	function foo {
		typeset -n v=bar
		typeset bar=lokal baz=auch
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
		v=123
		print bar: $bar
		print v: $v
		print exiting
	}
	bar=global
	print bar: $bar
	foo bar
	print bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: global
	bar: lokal
	v: 123
	exiting
	bar: 123
---
name: nameref-2ia
description:
	Testsuite for nameref (bound variables)
	Functions, argument given indirectly, after local
stdin:
	function foo {
		typeset bar=lokal baz=auch
		typeset -n v=$1
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
		v=123
		print bar: $bar
		print v: $v
		print exiting
	}
	bar=global
	print bar: $bar
	foo bar
	print bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: global
	bar: lokal
	v: 123
	exiting
	bar: 123
---
name: nameref-2ib
description:
	Testsuite for nameref (bound variables)
	Functions, argument given indirectly, before local
stdin:
	function foo {
		typeset -n v=$1
		typeset bar=lokal baz=auch
		print entering
		print !v: ${!v}
		print !bar: ${!bar}
		print !baz: ${!baz}
		print bar: $bar
		print v: $v
		v=123
		print bar: $bar
		print v: $v
		print exiting
	}
	bar=global
	print bar: $bar
	foo bar
	print bar: $bar
expected-stdout:
	bar: global
	entering
	!v: bar
	!bar: bar
	!baz: baz
	bar: lokal
	v: global
	bar: lokal
	v: 123
	exiting
	bar: 123
---
@


1.300
log
@spotted a missing substitute() call inside evaluate() call
incl. regression test
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.299 2009/08/08 13:08:48 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/08/08
d4946 63
@


1.299
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings  fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.298 2009/08/01 21:57:52 tg Stab $
d5051 17
@


1.298
log
@some bit of advice
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.297 2009/08/01 14:21:29 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/08/01
@


1.297
log
@bump version and rebuild+check on MirBSD
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.296 2009/07/30 19:11:09 tg Exp $
d4682 5
a4686 2
	Check that the utf8-mode flag is set at interactive startup
	Expected failure if -DMKSH_ASSUME_UTF8=0
@


1.296
log
@"official" but unsupported printf-as-builtin code, cleaner API than
in the branch; USE_PRINTF_BUILTIN=1 to enable it (Build.sh + Makefile)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.295 2009/07/25 21:31:24 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/07/30
@


1.295
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.294 2009/07/25 20:52:40 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/07/25
@


1.294
log
@in an interesting piece of self humour, remove the stop and suspend
aliases from shells requiring the Arbeitsamt to get a job ;-)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.293 2009/07/19 11:14:28 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R39 2009/07/16
@


1.293
log
@sync more tests with GNU bash2 (MirPorts), bash3 (sid), bash4 (experimental)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.291 2009/07/16 15:06:42 tg Exp $
d4719 1
d4738 20
d4786 1
d4809 1
d4830 43
@


1.292
log
@bash4 expands echo ~/foo even if the ~ is generated by a substitution;
add appropriate quotes and mention that bash_4.0-3 (experimental) succeeds
@
text
@d4926 6
a4931 6
	"$__progname" -c 'print v${x:(n)}x'
	"$__progname" -c 'print w${x: n}x'
	"$__progname" -c 'print x${x:n}x'
	"$__progname" -c 'print y${x:}x'
	"$__progname" -c 'print z${x}x'
	"$__progname" -c 'x=abcdef;y=123;echo ${x:${y:2:1}:2}' >/dev/null 2>&1; print $?
d5416 1
a5416 1
	Part 2: this is *not* supported by GNU bash
d5646 1
a5646 1
	Passes on: ksh93
d5659 1
a5659 1
	Fails on: pdksh mksh bash2 bash3 zsh
d5661 1
a5661 1
	 bash seems to choke on comment ending with backslash-newline
@


1.291
log
@ABI bump to R39: adhere to the future POSIX standard regarding -o nounset;
add appropriate regression test (except $_ *is* unset in non-interactive
shells). See the thread at:
http://article.gmane.org/gmane.os.miros.general/8863
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.290 2009/07/06 15:06:23 tg Exp $
d1219 6
a1224 6
	echo ${wd/#$pfx/~}
	echo ${wd/#\$pfx/~}
	echo ${wd/#"$pfx"/~}
	echo ${wd/#'$pfx'/~}
	echo ${wd/#"\$pfx"/~}
	echo ${wd/#'\$pfx'/~}
d1235 1
a1235 1
	More of this, bash fails it
d1239 3
a1241 3
	echo ${wd/#$(echo /home/user)/~}
	echo ${wd/#"$(echo /home/user)"/~}
	echo ${wd/#'$(echo /home/user)'/~}
@


1.290
log
@be more robust against things like Debian #535970
reverts and rewrites the code from cid 10047C1EBA57E4F4AF0

XXX find out if this is done right
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.289 2009/07/05 13:56:46 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/07/06
d5878 76
@


1.289
log
@another fix from oksh for Vi Mode word erase handling, appears to unbreak
more from cid 1004A2D72DD5A4E4B4F tried to be fixed in 1004A300A72701188E3
but Id appreciate someone who actually uses Vi Mode to test it:

   Revision 1.26: [7]download - view: [8]text, [9]markup, [10]annotated - [11]select for diffs
   Mon Jun 29 22:50:19 2009 UTC (5 days, 14 hours ago) by martynas
   Branches: [12]MAIN
   CVS tags: [13]OPENBSD_4_6_BASE, [14]OPENBSD_4_6, [15]HEAD
   Diff to: previous 1.25: [16]preferred, [17]coloured
   Changes since revision 1.25: +10 -5 lines
make VSEARCH werase act like regular werase after the last change.
vi back-words and emacs kill-region are not completely the same.
ok merdely@@, millert@@.  "Get it in" Darrin Chandler
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.288 2009/06/11 12:42:15 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/07/05
d4807 36
@


1.288
log
@capitalise AT&T
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.287 2009/06/10 18:11:25 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/06/10
@


1.287
log
@Save another couple of bytes in the !ulimit case
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.286 2009/06/08 20:34:38 tg Exp $
d1008 1
a1008 1
	(at&t ksh fails this test)
d1098 1
a1098 1
	(at&t ksh fails this - docs say # matches shortest string, ## matches
d1376 1
a1376 1
	(at&t ksh fails this; POSIX says invalid)
d1406 1
a1406 1
	(at&t ksh treats this like [a-cc-e]*)
d2535 1
a2535 1
	At&t ksh fails this, POSIX says the test is correct.
d2575 1
a2575 1
	Don't know what POSIX thinks of this.  at&t ksh does not do this.
d3053 1
a3053 1
	shoud not print 0. (according to /bin/sh, at&t ksh88, and the
d3116 1
a3116 1
	generates an error under /bin/sh and pdksh, but at&t ksh88 produces
d3128 1
a3128 1
	at&t ksh88 generates no output and sets the exit status to 1.  Also,
d3131 1
a3131 1
	generates no output under at&t ksh88 (pdksh generates a blank line
d3172 1
a3172 1
	should set the exit status to non-zero (sh and at&t ksh88 do).
d3216 1
a3216 1
	asks for more info.  sh and at&t ksh88 both echo
d3293 1
a3293 1
	alias expansion different from at&t ksh88
@


1.286
log
@ Check if killpg(3) is available; if not, use kill(2) with negative
  process ID and hope it works (is POSIXly killpg-endowed)
 bump version
 sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.285 2009/06/07 22:43:46 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/06/08
@


1.285
log
@these are expected failures if -DMKSH_ASSUME_UTF8=0 that cannot be
expressed as check.pl categories
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.284 2009/06/07 22:28:04 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/06/07
@


1.284
log
@new feature: -DMKSH_ASSUME_UTF8=0 assumes utf-8 is *not* set and skips
environment inspection; useful for initrd and the likes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.283 2009/06/06 14:23:17 tg Exp $
d4683 1
d4701 1
@


1.283
log
@fix event-subst-* regression tests on Cygwin, which insists on a shebang
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.282 2009/05/31 15:10:06 tg Stab $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/05/31
@


1.282
log
@fix bug exhibited by t0000-basic.sh introduced in R38 shortly before the
release: sometimes, a cd -P would cause memory corruption because lalloc
internal data was overwritten due to accidentally losing a continue;
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.281 2009/05/27 19:52:35 tg Stab $
d5729 1
d5733 1
d5756 1
d5760 1
d5781 1
d5785 1
d5816 1
d5820 1
@


1.281
log
@implement an extension that an interactive mode input line, when
starting with an ! exclamation mark at the beginning of a com-
mand (PS1 not PS2), shall have the same effect as the predefined
r alias, to be compatible with csh and GNU bashs !string to
Execute last used command starting with string  documentation
and feature request provided by wbx@@ (Waldemar Brodkorb)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.280 2009/05/27 09:58:21 tg Stab $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/05/27
@


1.280
log
@ Build.sh, strlcpy.c: gcc-current conversion &c. warnings cleanup
 histrap.c, lex.c, misc.c: get average stack frame size to <= 768 bytes
 check.t, sh.h: bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.279 2009/05/21 14:28:32 tg Exp $
d5725 107
@


1.279
log
@pgas mentioned ksh93 does [[ $foo ]] (ipv forced [[ -n $foo ]])
and it actually REDUCES code size to allow it as well; mention
in the manpage that its merely unportable (and of course exe-
cution time differs); sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.278 2009/05/20 10:10:00 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/05/21
@


1.278
log
@commit Syllable-related improvement: simplify p_time
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.277 2009/05/16 18:40:04 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/05/19
d5635 90
@


1.277
log
@ remove #if 0 and #ifdef notdef style old debugging code
 expose #ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT just in case they decide to
  require it and show it in the ksh version automatically
 sync the use of non-ASCII characters over files (unification)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.276 2009/05/16 16:59:32 tg Exp $
d28 1
a28 1
	@@(#)MIRBSD KSH R38 2009/05/16
@


1.276
log
@ sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression tests results while here, which have been
  broken since cid 10049D9BE5254CE65B8
 get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.275 2009/05/16 16:03:41 tg Exp $
d6 1
a6 1
# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d11 1
a11 1
# is granted to deal in this work without restriction, including un-
d15 1
a15 1
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
d22 1
a22 1
# of said person's immediate fault when using the work as intended.
@


1.275
log
@optimise the regression test 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.274 2009/05/16 15:53:00 tg Exp $
d6 18
@


1.274
log
@this began as a one-word change to the spec (manpage): that
${foo:1:2} operates on characters ipv bytes  which means:
 set +U: octets
 set -U: MirOS OPTU-8 characters

for consistency I also adapted ${#stringname} to deliver the
length in characters ipv bytes; more may follow; for example
Id like a way to expose the string width.

you can already get the MirOS OPTU-16 of a character in the
WTF-8 (set -U) mode with something like
 typeset -Uui16 -Z7 x=1#${stringname:position:1}
which will correctly use the PUA EF80EFFF mapping for octets.

due to this being an incompatible change, bump to R38

also change the unicode-hexdump sample regression test and
add two news for ${x:1:2} and ${#x} checks in A/W mode 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.273 2009/05/16 14:19:20 tg Exp $
d5206 1
a5208 1
		integer n
d5211 3
a5213 2
			while [[ -n $line ]]; do
				wc=1#${line::1}
d5222 1
a5222 1
				if (( (pos & 7) >= 7 )); then
d5225 1
a5225 2
				fi
				if (( (pos & 7) == 0 )); then
a5233 1
				line=${line:1}
@


1.273
log
@Add search-history-up and search-history-down keybindings (both unbound
by default) to the Emacs command line editing mode; patch originally by
James Butler <sweetnavelorange@@gmail.com> but slightly modified

10x
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.272 2009/04/22 16:43:18 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/05/16
d4894 32
d5115 1
a5115 1
name: integer-base-one-3a
d5182 1
a5182 1
name: integer-base-one-3b
d5204 1
a5204 1
		typeset -Uui16 -Z5 hv
d5212 1
a5212 21
				(( hv = 1#${line::1} & 0xFF ))
				if (( (hv < 0xC2) || (hv >= 0xF0) )); then
					n=1
				elif (( hv < 0xE0 )); then
					n=2
				else
					n=3
				fi
				if (( n > 1 )); then
					(( (1#${line:1:1} & 0xC0) == 0x80 )) || n=1
					(( hv == 0xE0 )) && \
					    (( (1#${line:1:1} & 0xFF) < 0xA0 )) && n=1
				fi
				if (( n > 2 )); then
					(( hv = 1#${line:2:1} & 0xFF ))
					(( (hv & 0xC0) == 0x80 )) || n=1
					(( (((1#${line::1} & 0xFF) == 0xEF) && \
					    ((1#${line:1:1} & 0xFF) == 0xBF) && \
					    (hv > 0xBD)) )) && n=1
				fi
				wc=1#${line::n}
d5221 1
a5221 1
				if (( (pos & 15) >= (n == 3 ? 14 : 15) )); then
d5225 10
a5234 12
				while (( n-- )); do
					if (( (pos & 15) == 0 )); then
						(( pos )) && print "$dasc|"
						print -n "${pos#16#}  "
						dasc=' |'
					fi
					hv=1#${line::1}
					print -n "${hv#16#} "
					(( (pos++ & 15) == 7 )) && \
					    print -n -- '- '
					line=${line:1}
				done
d5238 4
a5241 4
		if (( pos & 15 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
d5247 38
a5284 28
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\.|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  ||
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |...............|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F C2 80 C2 81 C2 82 C2 - 83 C2 84 C2 85 C2 86 C2  |.........|
	000000B0  87 C2 88 C2 89 C2 8A C2 - 8B C2 8C C2 8D C2 8E C2  |........|
	000000C0  8F C2 90 C2 91 C2 92 C2 - 93 C2 94 C2 95 C2 96 C2  |........|
	000000D0  97 C2 98 C2 99 C2 9A C2 - 9B C2 9C C2 9D C2 9E C2  |........|
	000000E0  9F C2 A0 C2 A1 C2 A2 C2 - A3 C2 A4 C2 A5 C2 A6 C2  ||
	000000F0  A7 C2 A8 C2 A9 C2 AA C2 - AB C2 AC C2 AD C2 AE C2  ||
	00000100  AF C2 B0 C2 B1 C2 B2 C2 - B3 C2 B4 C2 B5 C2 B6 C2  ||
	00000110  B7 C2 B8 C2 B9 C2 BA C2 - BB C2 BC C2 BD C2 BE C2  ||
	00000120  BF C3 80 C3 81 C3 82 C3 - 83 C3 84 C3 85 C3 86 C3  ||
	00000130  87 C3 88 C3 89 C3 8A C3 - 8B C3 8C C3 8D C3 8E C3  ||
	00000140  8F C3 90 C3 91 C3 92 C3 - 93 C3 94 C3 95 C3 96 C3  ||
	00000150  97 C3 98 C3 99 C3 9A C3 - 9B C3 9C C3 9D C3 9E C3  ||
	00000160  9F C3 A0 C3 A1 C3 A2 C3 - A3 C3 A4 C3 A5 C3 A6 C3  ||
	00000170  A7 C3 A8 C3 A9 C3 AA C3 - AB C3 AC C3 AD C3 AE C3  ||
	00000180  AF C3 B0 C3 B1 C3 B2 C3 - B3 C3 B4 C3 B5 C3 B6 C3  ||
	00000190  B7 C3 B8 C3 B9 C3 BA C3 - BB C3 BC C3 BD C3 BE C3  ||
	000001A0  BF 0A FF 0A C2 0A EF BF - C0 0A C0 80 0A E0 80 80  |.....|
	000001B0  0A EF BF BD EF BF BE EF - BF BF 0A                 |..|
@


1.272
log
@amend regression tests with expected-fail COMSUB parse bug
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.271 2009/04/08 18:00:53 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/04/07
@


1.271
log
@make UTF related regression tests more clear
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.270 2009/04/07 19:43:26 tg Exp $
d5566 32
@


1.270
log
@"evil" workaround to the alignment issues: embed an ALLOC_ITEM into
struct env (other structures defined have no "foreign type with pos-
sible alignment constraints" members) and take care of it while dea-
ling in a struct env instance
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.269 2009/04/06 08:33:36 tg Exp $
d4561 1
d4563 1
d4565 1
d4567 1
d4569 1
d4575 1
d4580 1
d4585 1
d4590 1
d4595 1
d4600 1
a4600 1
	Check that we can execute BOM-shebangs
d4607 4
a4610 4
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t1
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t2
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t3
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t4
d4617 4
a4620 4
	a=/nonexistant{FOO}
	a=/nonexistant{FOO}
	a=BAR
	a=BAR
d4628 2
a4629 2
	"$__progname" -c ':; if [[ $- = *U* ]]; then print on; else print off; fi'
	"$__progname" -c ':; if [[ $- = *U* ]]; then print on; else print off; fi'
d4631 2
a4632 2
	off
	on
@


1.269
log
@decouple conservative file descriptor use from MKSH_SMALL, with the
new MKSH_CONSERVATIVE_FDS prprocessor flag, because Minix 3, for
example, needs it (otherwise mksh Build.sh fails)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.268 2009/04/05 12:35:29 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/04/05
@


1.268
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.267 2009/04/03 09:39:03 tg Exp $
d5423 1
a5423 1
category: !smksh
d5433 1
a5433 1
category: !smksh
@


1.267
log
@(experimental) implement getrusage via times if not found
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.266 2009/03/25 21:45:27 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/04/03
@


1.266
log
@... and it did in fact require DEC ucode cc to spot this!
gcc, SUNWcc, pcc, llvm-gcc, clang, etc. all didn't say a thing!

now compiles warning-free (testsuite pass) on ULTRIX 4.5 (1986),
and OSF/1 X2.0-8 (testsuite norun: perl missing) has only the usual
bitchings about "volatile sig_atomic_t" because the latter part is
already volatile, but otherwise warning-free compile, works fine
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.265 2009/03/22 18:50:42 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/03/25
@


1.265
log
@bump to R37; the ;& and ;;& are postponed indefinitively for now,
as I don't get to it and it's nontrivial
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.264 2009/03/22 18:28:33 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R37 2009/03/22
@


1.264
log
@sync; fold oksh-seterror test into errexit-*; use print not printf
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.263 2009/03/22 15:47:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/22
@


1.263
log
@extend and fix the errexit tests:
* Debian pdksh fails #3 (trap) and #6 (BSD make)
* AT&T ksh93 passes all
* zsh does not pass them literally, but the actual functionality
  checked is right there
* dash fails #3 (trap) and does not pass #6 due to missing [[
* GNU bash 2 (MirPorts) and 3 (Debian) fails #6 (BSD make)
* oksh-current passes all
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.262 2009/03/21 11:09:35 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/17
d4304 2
a4305 2
	printf 'all:\n\t@@echo eins\n\t@@exit 42\n' >zd/a/Makefile
	printf 'all:\n\t@@echo zwei\n' >zd/b/Makefile
d4331 11
a5442 14
name: oksh-seterror
description:
	$OpenBSD: seterror.sh,v 1.1 2003/02/09 18:52:49 espie Exp $
	set -e is supposed to abort the script for errors that
	are not caught otherwise. pdksh fails this test.
stdin:
	set -e
	for i in 1 2 3
	do
		false && true
	done
	true
expected-fail: yes
---
@


1.262
log
@on GNU/Cygwin32 at least, env does not display its output sorted;
make sort(1) presence a conditional though
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.261 2009/03/17 13:56:46 tg Exp $
d4230 1
a4230 1
	Check some "exit on error" edge conditions needed for make(1)
d4238 1
d4242 1
a4242 1
expected-exit: e != 0
d4261 55
@


1.261
log
@another off-by-one, reported by macaronyde:#!/bin/mksh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.260 2009/03/16 15:50:11 tg Exp $
d4026 3
a4028 2
	env > bar1
	FOO=bar exec; env > bar2
@


1.260
log
@revert previous commit for now. testscript which breaks:

H4sIAAAAAAACA31TTUvDQBC951c804DtIQ0iiFhSPHiwiCDqzUpIuhO6JN2ETSS16n93Np+GFiGE
zM6bN2/fTPQOro5xENYuEVLzBz9eaF6RlWupSpyHaXqzVuvyljbbDCRV0UR7WeLiHEtT4D2GCcUy
pdNFh4pkg4wGZCV8Z6opTPOw3GI+swoq4ZIVZxqkSv0JqRAiWkBkmAJNegHIGG9vcAWcSnjM6dTo
uby8vsL7+wLllhQQKKr4SoFv/8nbXE5pQcdpk4nlwH6AE7zer17uVs/BmHVftnUdxYh0yHbV3ghY
9wh2rQlBkdMm8PmIe57Bjfs7dTW9X/OoEG6lwzwnzYKA7+8jHpsJTuFN4+IjKhKZM6dpZ0xuQ2Nz
7bGB1F74zlebmzTm/PS+OB0GZz4HLcPgz+BeDxyS9S7YU6e3qZaQk5gZgRHvQtI59Eet7QwBWFnL
O/F+ej9Fpmg0ug7OHrnqHy2+7y8x6DGEG3E0Az41RuPlYfXEEx0psrl8PAUebzf6ZklabgD8V3SS
Z7Vo6xfOuQS6gQMAAA==

mksh -o posix z failed in that it continues; mksh z correctly aborts
lets see what the obsd people have to say herefore
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.258 2009/03/15 16:13:37 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/15
@


1.259
log
@bring back the backed-out Debian patch if FPOSIX; test programmes fixed:

H4sIAAAAAAACAz1PywrDIBA8m68YgoT20EN7TMixX1F6yGNFIWhRSw2h/95VmuDB2XmsY2oDRVyo
Si1N2uHlMzQK0b8JHaImy4RQwxIITYPiUs4xqcyeGgdfrfumtWX5dMbGSHy0WQgP1PJa49lhdpkV
ynncYSxkOjjxd/V83dmcX9sQtFGRi0zORmO5042HbwnMzlIBqa9lAmfLVBIZ7XqpKBPDnDu+WXpi
wMhnOgQXYvUD+oKHAhUBAAA=

XXX OpenBSD has something different which may DTST or even DTRT (not break
XXX our make(1) wrt <bsd.subdir.mk>), check that
@
text
@d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/16 ~test
@


1.258
log
@sprinkle a few static and clean up the internal APIs
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.257 2009/03/14 18:12:50 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/15
@


1.257
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.256 2009/02/22 18:02:30 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/03/14
@


1.256
log
@when outputting in a row x column formatted way, but the available space
on the screen is not enough for two columns, just output the text line by
line, instead of trying to format it; gets rid of superfluous empty lines
if we did not even have space for one column on the screen (x_cols)

noticed by Gbor Gergely in irc, thanks!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.255 2009/02/20 13:25:08 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/02/22
d280 27
@


1.255
log
@<sys/file.h> is only required for, and only contains, flock(2)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.254 2008/12/29 21:34:18 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2009/02/20
@


1.254
log
@always set COLUMNS and LINES; make use of the fact in dot.mkshrc
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.253 2008/12/17 19:39:21 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/29
@


1.253
log
@implement unsigned arithmetics as an mksh extension
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.252 2008/12/13 17:02:11 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/17
@


1.252
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.251 2008/12/08 13:57:35 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/13
d243 37
@


1.251
log
@comment on slow machines and OEs like GNU/Cygwin32
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.250 2008/12/04 18:11:03 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/04
d4486 2
a4487 2
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then print on; else print off; fi'
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then print on; else print off; fi'
d4498 1
a4498 1
	if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then
d4512 1
a4512 1
	if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then
d4527 1
a4527 1
	if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then
d4544 1
a4544 1
	if [[ $(set +o) = *@@(-o utf8-mode)@@(| *) ]]; then
@


1.250
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.249 2008/12/02 13:19:28 tg Exp $
d157 2
d1702 4
a1705 3
	Check that heredoc temp files aren't removed too soon or too late.
	Heredoc in function, backgrounded call to function.
	This check can fail on slow machines (<100 MHz), that's normal.
@


1.249
log
@fix botched testcase from 10049352E9F5DBF7056 - check.pl offers
a time-limit functionality after all...
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.248 2008/12/02 12:48:16 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/02
d4481 1
a4481 1
	Reading the UTF-8 BOM should enable the utf8-hack flag
d4483 2
a4484 2
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then print on; else print off; fi'
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then print on; else print off; fi'
d4491 1
a4491 1
	Check that the utf8-hack flag is not set at non-interactive startup
d4495 1
a4495 1
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
d4505 1
a4505 1
	Check that the utf8-hack flag is not set at non-interactive startup
d4509 1
a4509 1
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
d4519 1
a4519 1
	Check that the utf8-hack flag is set at interactive startup
d4524 1
a4524 1
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
d4536 1
a4536 1
	Check that the utf8-hack flag is set at interactive startup
d4541 1
a4541 1
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
d4807 1
a4807 1
	set -o utf8-hack
d4836 1
a4836 1
	set -o utf8-hack
d4847 1
a4847 1
	set -o utf8-hack
d4858 1
a4858 1
	set -o utf8-hack
d4868 1
a4868 1
	set +o utf8-hack
d4879 1
a4879 1
	set -o utf8-hack
d4889 1
a4889 1
	set -o utf8-hack
d4899 1
a4899 1
	set -o utf8-hack
d4909 1
a4909 1
	set -o utf8-hack
d4920 1
a4920 1
	set -o utf8-hack
d4931 1
a4931 1
	set -o utf8-hack
d5009 1
a5009 1
	set -o utf8-hack
@


1.248
log
@add a test case for the recursion limit fix
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.246 2008/11/30 16:57:40 tg Exp $
d157 1
a159 2
	ls			# pre-fetch ls(1) binary
	(sleep 3; kill -9 $$) &	# may need to adjust for slow machines
a166 1
	tf
@


1.247
log
@Alias expansion has a recursion check which tries to break the cycle if
encountered. However, when reading end of input, the source type is set
to SEOF while popping, whereas the recursion check code only checks for
an SALIAS type.

Fix: add a new SF_HASALIAS flag; change u.tblp from being valid if type
is SALIAS to being valid if SF_HASALIAS is set; set SF_HASALIAS for the
created SALIAS sources; set SF_HASALIAS and u.tblp when creating SALIAS
whose next is SEOF on the SEOF source as well.

Reported by Michael Hlavinka as Redhat Bug #474115
@
text
@d154 16
@


1.246
log
@ah, so this is how it fails, in a function!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.245 2008/11/30 16:53:15 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/11/30
@


1.245
log
@add another regression test (XXX why did a similar thing fail?)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.244 2008/11/30 10:45:42 tg Exp $
d5257 4
a5260 1
	[[ -e bar ]] && threeout &>foo
d5262 1
a5262 1
	[[ -e bar ]] && threeout &>foo
@


1.244
log
@forgot to bump version here too

savings: 523 .text, 16 .data, 32 .bss (small), ceteris paribus (full)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.243 2008/11/12 04:55:17 tg Exp $
d5245 23
@


1.243
log
@prepare for aalloc.c, which I have just written myself, as an area-based
allocator using malloc and free, with mmap malloc and omalloc in mind,
not counterfeiting its security measures such as guard pages, and having
some of our own, e.g. XOR random cookies, optional mprotect, etc.

zero cost (for we have arc4random())
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.242 2008/11/10 19:33:07 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/11/11
@


1.243.2.1
log
@beginnings
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.243 2008/11/12 04:55:17 tg Exp $
d9 8
@


1.242
log
@work around even more format string warning stuff
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.241 2008/11/09 20:32:16 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/11/10
@


1.241
log
@build warning-free with LLVM+Clang on MirBSD itself
$ (CCC_LD=mgcc CC=ccc sh Build.sh -r && ./test.sh -v) 2>&1 | tee log
Total failed: 2 (as expected)
Total passed: 278

Just the result is huge, and we could of course build to intermediate
byte code to optimise globally
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.240 2008/11/08 17:36:35 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/11/09
@


1.240
log
@the QNX /bin/ed problem is worse than thought; use a new mechanism,
because categories in check.t are ORd:
 no-stderr-ed disables the newish-ed tests (tried using testcase)
 stdout-ed enables the oldish-ed tests (variable, if the above
  testcase succeeds, its added, but QNX overrides the variable)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.239 2008/11/02 23:03:45 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/11/02
@


1.239
log
@On QNX, do not run the tests involving /bin/ed at all, because it appears
oldish but is in fact broken. However, if /bin/ed is MirBSD ed(1), these
actually pass.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.238 2008/11/02 22:29:35 tg Exp $
d2208 1
a2208 1
category: oldish-ed,!os:nto
d2230 1
a2230 1
category: oldish-ed,!os:nto
d2261 1
a2261 1
category: oldish-ed,!os:nto
d2292 1
a2292 1
category: !oldish-ed
d2312 1
a2312 1
category: !oldish-ed
d2339 1
a2339 1
category: !oldish-ed
@


1.238
log
@experimental support for <strings.h>
cf. http://www.opengroup.org/onlinepubs/009695399/basedefs/strings.h.html
QNX seems to bury some functions in there
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.237 2008/10/28 14:32:37 tg Exp $
d2208 1
a2208 1
category: oldish-ed
d2230 1
a2230 1
category: oldish-ed
d2261 1
a2261 1
category: oldish-ed
@


1.237
log
@ rewrite code to no longer use statements-as-expressions
 optimise a little
 Build.sh: remove HAVE_EXPSTMT test
 Build.sh, */Makefile: sort tests, regenerate
 mksh.hts: sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.236 2008/10/26 20:59:39 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/10/28
@


1.236
log
@ do not use __typeof__ even if we have statements-as-expressions, to
  please pcc, prompted for by Anders ragge Magnusson, problem spotted
  originally by Adam replaced Hoka
   rewrote x_bs2() and utf_backch() into a combined x_bs3() function,
    since these are never used in any other way
 whitespace cleanup, while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.235 2008/10/24 21:35:42 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/10/26
@


1.235
log
@this will most certainly be mksh R36
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.234 2008/10/24 19:54:22 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/10/24
@


1.234
log
@ OSF/1 may not have MAP_FAILED defined either
  XXX mmap() works only on devices on some DEC OSes, not on files, so,
  XXX instead, it were best to disable it altogether
 bump date
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.233 2008/10/20 19:29:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/24
@


1.233
log
@ change mksh to only then behave more POSuXish when called as /bin/sh or
  -sh if -DMKSH_BINSHREDUCED was passed during compilation, for example
  for Debian, but definitively not for MirBSD
 split up regression test to force this behaviour
 remove the gunk from our MirBSD startup scripts again
 mention arc4random.c changes on website, sync clog, warn packagers
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.232 2008/10/19 20:15:42 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/20
@


1.232
log
@when doing a history search (^R), restore old input line on
abortion (^G  ^C is SIGINT and doesnt work like this, but
thats actually good IMO)

prompted by enquiry about the Emacs editing mode by <smultron:#MidnightBSD>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.231 2008/10/15 10:24:59 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/19
d4276 20
a4295 1
name: posix-mode-2
d4298 1
a4298 1
category: !smksh
@


1.231
log
@use less stack storage, prefer .bss storage (saves us a memset() call)
and .data instead of another initialisation; this was prompted by a bug
in scan-build (the value can never be NULL, but it doesnt realise it),
although this doesnt fix it, but less stack usage is always good
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.230 2008/10/13 23:06:01 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/15
@


1.230
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.229 2008/10/10 21:30:41 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/13
@


1.229
log
@fix prodded by cnuke@@ for AIX with IBM xlC 7.0:
fool the compiler into not doing static bounds checking when we do
one-past-the-array-boundary pointer assignments for cases where the
only accesses are like (*--pointer); bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.228 2008/10/05 16:06:42 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/10
@


1.228
log
@unbreak MKSH_SMALL after x_histp related changes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.227 2008/10/04 23:08:01 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/05
@


1.227
log
@implement Message-ID: <20081004171903.GA14184@@boetes.org>
in a somewhat hackish way, and its still quite different from zsh,
but probably closer to a desired functionality

XXX this makes state by abusing modified and xmp (the mark).
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.226 2008/09/30 19:36:15 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/10/04
@


1.226
log
@ check.t: change history-e-minus-5 regression test to avoid false failure
  caused by ignoredups history control
 histrap.c: enable ignoredups after fc -s editing too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.225 2008/09/30 18:43:06 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/09/30
@


1.225
log
@add regression tests, sync manpage, bump version number
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.224 2008/09/20 19:17:59 tg Exp $
d1853 1
d1855 1
a1855 1
	fc -l 2 4
d1861 3
a1863 2
	3	echo ghi jkl
	4	fc -l 2 4
@


1.224
log
@bump mksh patchlevel for todays sorta-tested half-done changes, with more
to follow (see <Pine.BSM.4.64L.0809201417560.22066@@herc.mirbsd.org>), as I
probably am not going to hack any more tonight
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.223 2008/09/19 10:41:55 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/09/20
d1729 20
@


1.223
log
@work around GNU getopt(3) violating every single standard in existence
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.222 2008/09/17 19:31:28 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/09/17
@


1.222
log
@ bring back automatic turn-on of FPOSIX if called as sh/-sh
   only if !MKSH_SMALL
   add appropriate regression test
 if FPOSIX is set, do not close fds > 2 on exec, Debian #499139
 add appropriate regression tests for keeping fds private or not
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.221 2008/09/14 20:24:57 tg Exp $
d4261 2
a4262 2
	ln -s "$__progname" -ksh
	ln -s "$__progname" -sh
@


1.221
log
@ merge vi_reset() and edit_reset() into x_vi() to allow for following:
 fix vi mode (which, however, is officially orphaned) multi-line $PS1 by
  using a similar algorithm for prompt skipping as emacs mode (changing
  the meaning of prompt_trunc variable and using prompt_redraw, just even
  more efficiently than vi mode); reported by asarch via IRC
 fix multi-line prompts if last line is too large by using emacs mode
  algorithm of just internally appending a newline, while here  this even
  saves us having to re-add the prompt_skip variable

WARNING: this is only barely tested, as almost nobody ever uses vi mode
 test yourself, there may be bugs (e.g. off-by-ones); already known is
  that the vi input line editing mode is NOT multibyte safe
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.220 2008/08/02 17:45:10 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/09/14
d4254 19
d5329 25
@


1.220
log
@ merge final version of the stack-free diff as committed by jaredy@@openbsd
  thanks for helping with the bug
 merge RCS IDs
 bump mksh version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.219 2008/07/18 11:33:11 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/08/02
@


1.219
log
@fixes for constant conditionals, from gcc-4.2 fat binary building
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.218 2008/07/17 13:00:38 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/18
@


1.218
log
@add comment
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.217 2008/07/17 12:57:59 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/14
@


1.217
log
@merge OpenBSDs non-standard <bsd.regress.mk> tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.216 2008/07/14 12:29:04 tg Exp $
d5212 1
a5212 1
	are not caught otherwise.
@


1.216
log
@fix attempt to free pointer to stack (function-local storage)
discovered by Elias Pipping
patch by Jared Yanovich
alloc/afree checker by Todd C. Miller
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.215 2008/07/12 18:09:36 tg Exp $
d5208 102
@


1.215
log
@bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.214 2008/07/11 19:51:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/12
d3846 12
@


1.214
log
@ Build.sh, check.t: bring back the 'smksh' check category, which was
  missing for a while yet its disappearance was unnoticed because
 distrib/special/mksh/Makefile: sync check categories, this was missed
 mksh.hts: sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.213 2008/07/11 00:23:59 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/10
@


1.213
log
@cygwin has... interesting fs semantics (I got an unaccessible yet
undeletable file on running this manually, which vanished after the
parent(!) process exited), so disable this test for it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.212 2008/07/10 21:55:08 tg Exp $
d4373 1
a4373 1
category: !os:cygwin,!os:uwin-nt,!os:ultrix
d5176 1
d5186 1
@


1.212
log
@bump versions (since we lowered the fd limit again)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.211 2008/07/10 21:25:00 tg Exp $
d1732 1
@


1.211
log
@oops, only half commit
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.209 2008/07/10 20:05:01 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/07/09
@


1.210
log
@switch back to en_US.UTF-8 for GNU/* too: Mandriva has issues with
en_US.utf8, and Debian (tested on gnubber) can do both
@
text
@d4405 1
a4405 1
category: !os:gnu,!os:hpux,!os:linux
d4450 1
a4450 1
category: os:gnu,os:hpux,os:linux
@


1.209
log
@on Solaris, this testcase won't produce the issue, but let's pass the test
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.208 2008/07/10 19:06:15 tg Exp $
d4419 1
a4419 1
category: os:gnu,os:gnukfreebsd,os:hpux,os:linux
d4433 1
a4433 1
category: !os:gnu,!os:gnukfreebsd,!os:hpux,!os:linux
@


1.208
log
@ remove bizarre test constraint
 make a test succeed on Tru64, whose cat likes to output
  Successful
  cat: output error
  on this test case
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.207 2008/07/09 21:32:42 tg Exp $
d1749 1
a1749 1
	/.*cannot unlink HISTFILE.*\nX*$/
@


1.207
log
@ bump NUFILE and FDBASE, allowing for more than 10 fds used by scripts
 change the code to accept more than a single digit for an fd
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.206 2008/07/09 20:31:19 tg Exp $
a2967 2
# no /etc/termcap on UWIN
category: !os:uwin-nt
d2984 1
a2984 1
	(: ; cat t2) | sleep 1
@


1.206
log
@add another corner case of here documents, which bash and zsh pass
inspired by:
20:14twkm:#ksh $ unset foo ; read -u10 foo 10<<< bar ; echo $foo
which works in ksh93 (whose fd>9-support is still incomplete though)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.205 2008/07/08 22:29:00 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/07/06
d5174 21
@


1.205
log
@Debian GNU/kFreeBSD $^O value, 10x tarzeau
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.204 2008/07/08 20:54:33 tg Exp $
d1501 8
@


1.204
log
@reverse the sense of check for en_US.UTF-8 vs en_US.utf8:
the latter is required by HP-sUX, okay, and apparently the
preferred one by glibc (GNU libdrepper?), but breaks on al-
most all other systems I have access to (Slowlaris, Midnight
DragonFly NetBSD, Darwin, at least)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.202 2008/07/06 22:41:07 tg Exp $
d4413 1
a4413 1
category: os:gnu,os:hpux,os:linux
d4427 1
a4427 1
category: !os:gnu,!os:hpux,!os:linux
@


1.203
log
@NetBSD 3.0_STABLE is a tad picky about the UTF-8 locales naming
@
text
@d4396 1
a4396 1
name: utf8opt-1
d4399 15
d4427 1
a4427 1
category: os:solaris,os:darwin,os:netbsd
d4444 1
a4444 1
category: !os:solaris,!os:darwin,!os:netbsd
@


1.202
log
@check return value of unlink(2) when trying to remove an existing HISTFILE,
since mksh(1) did go into an infinite loop if that fails first

bug spotted, initial patch and help drafting a test case
From: Decklin Foster <decklin@@red-bean.com>

note there are more instances of unlink(2) and others (like chmod(2), as
spotted by flawfinder) which arent checked but at least the other case
of unlink(2) use in histrap.c doesnt cause any trouble (I think)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.201 2008/06/28 22:51:54 tg Exp $
d4412 1
a4412 1
category: os:solaris,os:darwin
d4429 1
a4429 1
category: !os:solaris,!os:darwin
@


1.201
log
@ add code to support GNU bashs &> file I/O redirection extension,
  and make it fit into mkshs model (also gives us a couple of things
  GNU bash doesnt have
 add regression tests for all of these

Lukas smultron Upton from MidnightBSD spotted a script with /bin/sh
shebang invalidly using &> in some Apple backup toolkit, 10x

XXX why fds are limited to one digit?
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.200 2008/06/21 19:30:49 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/06/28
d1721 22
@


1.200
log
@Darwin also has other locale
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.199 2008/06/21 19:20:15 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/06/08
d5003 126
a5128 1

@


1.199
log
@remove check_category pdksh, it starts to make trouble and was never
taken seriously anyway, just historic ballast
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.198 2008/06/08 17:15:29 tg Exp $
d4390 1
a4390 1
category: os:solaris
d4407 1
a4407 1
category: !os:solaris
@


1.198
log
@ more usage fixes, inspired by sobrado
 bump mksh patchlevel
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.197 2008/06/02 20:44:07 tg Exp $
a12 1
category: pdksh
d4254 1
a4254 1
category: pdksh,!no-histfile
d4299 1
a4299 1
category: pdksh,!os:darwin
d4344 1
a4344 1
category: pdksh,!os:cygwin,!os:uwin-nt,!os:ultrix
a4366 1
category: pdksh
a4376 1
category: pdksh
d4390 1
a4390 1
category: pdksh,os:solaris
d4407 1
a4407 1
category: pdksh,!os:solaris
a4423 1
category: pdksh
a4444 1
#category: pdksh
a4456 1
#category: pdksh
a4469 1
category: pdksh
a4491 1
category: pdksh
@


1.197
log
@fix regression test: Solaris has $^O solaris not sunos, and locales of
the style xx.UTF-8 not xx.utf8, so just split the test into two
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.196 2008/05/17 18:27:54 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/05/17
@


1.196
log
@add new builtin realpath calling realpath(3) on its argument, skipping
over -- for compatibility to Debian realpath(1) and possibly busybox

sounds handy replaced@@TNF
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.195 2008/05/15 15:24:09 tg Exp $
d4390 1
a4390 1
name: utf8opt-2
d4393 18
a4410 1
category: pdksh
@


1.195
log
@mksh:
* initialise the integers PPID, OPTIND, RANDOM, SECONDS, and TMOUT to base-10
* bring back PGRP as base-10 integer to the process group via getpgrp(2)
* initialise USER_ID as base-10 integer to the effective user id as retrieved
  from geteuid(2) = $(id -u)
* use $USER_ID in dot.mkshrc instead of spawning an id(1) process
  -> dot.mkshrc,v 1.34 now requires mksh R34
* convert more int to bool where appropriate
* remove dead code - getpgrp(2) cannot fail
* sync manual page to reality
* bump to mksh R34(beta) - feature freeze

XXX check if our_pgrp in jobs.c is still really needed, the setpgid call
XXX probably just makes us our own pgrp leader, and we might have to use
XXX and update kshpgrp accordingly - need feedback/help here but I think
XXX this simplification should be possible if I grok the code correctly.

etc/profile:
* adjust to $USER_ID changes in mksh (speed-up here, too)

mksh.hts:
* sync changelog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.194 2008/05/10 03:16:07 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/05/15
@


1.194
log
@ on OpenBSD, default to HAVE_SETLOCALE_CTYPE=0 I wonder if thatll ever
  change  this might affect other OSes too in time for R34
 one of the regression tests had an unexpected failure if running as root
 www: sync clog; log newer mksh built on newer OpenBSD works fine
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.193 2008/05/04 01:59:46 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/05/04
@


1.193
log
@remove more dead mirtoconf code
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.192 2008/05/04 01:51:29 tg Exp $
d4404 2
@


1.192
log
@remove dead code and ifdefs, speed up configuring
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.191 2008/05/04 01:39:12 tg Exp $
d4255 1
a4255 1
category: !no-histfile,pdksh,!smksh
@


1.191
log
@this test even works with the defutf8 mkshen as the shell is !interactive
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.190 2008/05/04 01:38:04 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/05/02
@


1.190
log
@HP-sUX has en_US.utf8 but no en_US.UTF-8
as GNU has both, and I dont know which OS has what and which is more
common, just use that one instead
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.189 2008/05/02 18:55:35 tg Exp $
d4368 1
a4368 1
category: pdksh,!dutf
@


1.189
log
@thinko: multibyte characters are not always 1 column wide
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.188 2008/04/22 19:00:40 tg Exp $
d4380 1
a4380 1
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
d4395 1
a4395 1
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
@


1.188
log
@bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.187 2008/04/20 21:30:28 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/22
@


1.187
log
@ revert the oksh code to be able to set multiple ulimits in one
  invocation, until it works with a common idiom: ulimit -dS 262144
  (but keep some goodies)
 add a regression test for that
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.186 2008/04/20 01:23:49 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/20
@


1.186
log
@this example shows how to really do a hexdump parser in unicode mode (safe)
 this isnt recommended however
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.185 2008/04/20 01:12:52 tg Exp $
d4980 13
@


1.185
log
@ok, so instead of removing the -o utf8-hack behaviour of the 1#* operator
we just tell the user to only throw valid CESU-8 or single octets on it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.184 2008/04/20 00:56:17 tg Exp $
d4797 1
a4797 1
name: integer-base-one-3
d4864 116
@


1.184
log
@even like this, handling mis-formed UTF-8 is kind of impossible
except we duplicate all of the logic
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.183 2008/04/20 00:45:49 tg Exp $
d4734 64
a4797 1
name: integer-base-one-3a
a4863 117
name: integer-base-one-3b
description:
	some sample code for hexdumping Unicode
stdin:
	set -o utf8-hack
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
	} | {
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		integer n
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				(( hv = 1#${line::1} & 0xFF ))
				if (( (hv < 0xC2) || (hv >= 0xF0) )); then
					n=1
				elif (( hv < 0xE0 )); then
					n=2
				else
					n=3
				fi
				if (( n > 1 )); then
					(( hv = 1#${line:1:1} & 0xFF ))
					(( (hv & 0xC0) == 0x80 )) || n=1
				fi
				if (( n > 2 )); then
					(( hv = 1#${line:2:1} & 0xFF ))
					(( (hv & 0xC0) == 0x80 )) || n=1
				fi
				wc=1#${line::n}
				if (( (wc & 0xFF80) == 0xEF80 )); then
				#if (( ((n == 2) && ((wc < 0x80)) || \
				#      ((n == 3) && (wc < 0x800)) )); then
					n=1
					wc=1#${line::n}
				fi
				if (( (wc < 32) || \
				    ((wc > 126) && (wc < 160)) )); then
					dch=.
				elif (( (wc & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${wc#1#}
				fi
				if (( (pos & 15) >= (n == 3 ? 14 : 15) )); then
					dasc=$dasc$dch
					dch=
				fi
				while (( n-- )); do
					if (( (pos & 15) == 0 )); then
						(( pos )) && print "$dasc|"
						print -n "${pos#16#}  "
						dasc=' |'
					fi
					hv=1#${line::1}
					print -n "${hv#16#} "
					(( (pos++ & 15) == 7 )) && \
					    print -n -- '- '
					line=${line:1}
				done
				dasc=$dasc$dch
			done
		done
		if (( pos & 15 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\.|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  ||
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |...............|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F C2 80 C2 81 C2 82 C2 - 83 C2 84 C2 85 C2 86 C2  |.........|
	000000B0  87 C2 88 C2 89 C2 8A C2 - 8B C2 8C C2 8D C2 8E C2  |........|
	000000C0  8F C2 90 C2 91 C2 92 C2 - 93 C2 94 C2 95 C2 96 C2  |........|
	000000D0  97 C2 98 C2 99 C2 9A C2 - 9B C2 9C C2 9D C2 9E C2  |........|
	000000E0  9F C2 A0 C2 A1 C2 A2 C2 - A3 C2 A4 C2 A5 C2 A6 C2  ||
	000000F0  A7 C2 A8 C2 A9 C2 AA C2 - AB C2 AC C2 AD C2 AE C2  ||
	00000100  AF C2 B0 C2 B1 C2 B2 C2 - B3 C2 B4 C2 B5 C2 B6 C2  ||
	00000110  B7 C2 B8 C2 B9 C2 BA C2 - BB C2 BC C2 BD C2 BE C2  ||
	00000120  BF C3 80 C3 81 C3 82 C3 - 83 C3 84 C3 85 C3 86 C3  ||
	00000130  87 C3 88 C3 89 C3 8A C3 - 8B C3 8C C3 8D C3 8E C3  ||
	00000140  8F C3 90 C3 91 C3 92 C3 - 93 C3 94 C3 95 C3 96 C3  ||
	00000150  97 C3 98 C3 99 C3 9A C3 - 9B C3 9C C3 9D C3 9E C3  ||
	00000160  9F C3 A0 C3 A1 C3 A2 C3 - A3 C3 A4 C3 A5 C3 A6 C3  ||
	00000170  A7 C3 A8 C3 A9 C3 AA C3 - AB C3 AC C3 AD C3 AE C3  ||
	00000180  AF C3 B0 C3 B1 C3 B2 C3 - B3 C3 B4 C3 B5 C3 B6 C3  ||
	00000190  B7 C3 B8 C3 B9 C3 BA C3 - BB C3 BC C3 BD C3 BE C3  ||
	000001A0  BF 0A FF 0A C2 0A EF BF - C0 0A C0 80 0A E0 80 80  |.....|
	000001B0  0A                      -                          |.|
---
@


1.183
log
@I wish. But '1#\xC2\x0A' converts correctly, as the newline isn't seen
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.182 2008/04/20 00:28:30 tg Exp $
d4817 3
a4819 2
		print \\xef\\xbf\\x80	# invalid 3-byte
		print \\xc2\\x80	# non-minimalistic
d4838 8
a4845 3
	(( n == 1 )) || eval integer 'x=1#${line::n}' 2>/dev/null || print -u2 on 1#${line::n}
				(( n == 1 )) || \
				    (integer x=1#${line::n}) 2>/dev/null || n=1
d4847 6
d4915 2
a4916 1
	000001A0  BF 0A FF 0A C2 0A EF BF - 80 0A C2 80 0A           |.....|
@


1.182
log
@this one won't work so well though 
I tried to use a subshell to try to convert, to make it more robust
against invalid utf-8, but that didn't work out
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.181 2008/04/20 00:24:25 tg Exp $
d4815 4
d4829 4
a4832 3
				if (integer x=1#${line::3}) 2>&-; then
					n=3
				elif (integer x=1#${line::2}) 2>&-; then
d4835 1
a4835 1
					n=1
d4837 3
d4844 2
d4903 1
a4903 1
	000001A0  BF 0A                   -                          |.|
@


1.181
log
@mostly revert 100480A853206FB56FA and parse utf-8 lead bytes ourselves
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.180 2008/04/20 00:11:29 tg Exp $
d4825 3
a4827 4
				(( hv = 1#${line::1} & 0xFF ))
				if (( hv < 0xC2 )); then
					n=1
				elif (( hv < 0xE0 )); then
d4830 1
a4830 1
					n=3
@


1.180
log
@add a test more, except that we cannot fulfil a part of it yet
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.179 2008/04/19 23:49:58 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/19
d4825 4
a4828 3
				if (( ${#line} > 2 )) && let wc="1#${line::3}"; then
					n=3
				elif (( ${#line} > 1 )) && let wc="1#${line::2}"; then
d4831 1
a4831 2
					wc=1#${line::1}
					n=1
d4833 1
@


1.179
log
@solve the issue (although not quite how Id like it)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.178 2008/04/19 22:15:01 tg Exp $
d4616 13
d4741 2
d4809 2
@


1.178
log
@ more unsigned  unsigned int
 more int  bool
 more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
 make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
 optimise
 utf_wctomb: src  dst, as were writing to that char array (pasto?)
 edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
 edit.c:x_zotc3(): easier (and faster) handling of UTF-8
 implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the 1#,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80EFFF for the MirBSD encoding hack
  (print doesnt, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
 as an application example, add a hexdumper to the regression tests 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.177 2008/04/19 22:03:18 tg Exp $
d4725 8
a4732 1
	print 'Hello, World!\\\n' | {
d4768 17
a4784 1
	00000020  81 0A                   -                          |..|
a4788 2
	as of now, doesn't work because illicit assignments break
expected-fail: yes
d4791 8
a4798 1
	print 'Hello, World!\\\n' | {
d4808 1
a4808 1
				if (( ${#line} > 2 )) && wc=1#${line::3}; then
d4810 1
a4810 1
				elif (( ${#line} > 1 )) && wc=1#${line::2}; then
d4814 1
a4814 1
					n=3
d4818 7
a4824 3
					dasc=$dasc.
				elif (( wc < 0x0800 )); then
					dasc=$dasc${wc#1#}
d4834 2
a4835 1
					(( (pos++ & 15) == 7 )) && print -- '- '
d4838 1
a4838 1
				(( wc >= 0x0800 )) && dasc=$dasc${wc#1#}
d4844 1
a4844 1
				(( (pos++ & 15) == 7 )) && print -- '- '
d4850 27
a4876 3
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\.|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  ||
	00000020  81 0A                   -                          |.|
@


1.177
log
@improve the use (parsing) of set +o output in the examples
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.176 2008/04/19 21:04:08 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/16
d4376 29
d4649 172
@


1.176
log
@if typeset -i -Z<n>, pad the value not the base
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.175 2008/04/16 21:56:00 tg Exp $
d4186 2
a4187 2
	set +o | fgrep posix >/dev/null && echo posix || echo noposix
	set +o | fgrep braceexpand >/dev/null && echo brex || echo nobrex
d4195 2
a4196 2
	set +o | fgrep posix >/dev/null && echo posix || echo noposix
	set +o | fgrep braceexpand >/dev/null && echo brex || echo nobrex
d4199 2
a4200 2
	set +o | fgrep posix >/dev/null && echo posix || echo noposix
	set +o | fgrep braceexpand >/dev/null && echo brex || echo nobrex
d4370 2
a4371 2
	"$__progname" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
	"$__progname" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
@


1.175
log
@_careful_ (feature) sync with oksh:

   (3 weeks, 5 days ago) by millert
Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.174 2008/04/11 19:55:23 tg Exp $
d4280 14
@


1.174
log
@SECURITY fix: when spawning mksh on a new terminal (tty, not /dev/null),
flush all of its I/O first  someone could have written on it beforehand
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.173 2008/04/02 17:09:45 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/11
@


1.173
log
@disable utf8bom-2 check on Ultrix, its perl fails on us
(not a problem though, as the code works just fine)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.172 2008/04/01 21:39:44 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/01
@


1.172
log
@reorganise c_typeset code, fixing that regression test
also some intbool while here
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.171 2008/04/01 21:07:20 tg Exp $
d4330 2
a4331 1
category: pdksh,!os:cygwin,!os:uwin-nt
@


1.171
log
@ adjust the regression test so that the behaviour of export and readonly
  matches mksh pre-R29 (the one introducing the bug), and typeset matches
  the behaviour intended with the R29 changes (better AT&T ksh93 compati-
  bility) but never reached
 adjust the man page description of typeset -p, as its different from
  the typeset and typeset - actions
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.170 2008/04/01 20:40:21 tg Exp $
d3744 4
a3747 4
		FNORD_E=1
		FNORD_F=2
		FNORD_G=3
		FNORD_H=4
d3764 2
d3777 2
a3778 2
	export FNORD_G=3
	export FNORD_H=4
d3787 2
a3788 2
	readonly FNORD_F=2
	readonly FNORD_H=4
d3812 4
a3815 4
	FNORD_E=1
	FNORD_F=2
	FNORD_G=3
	FNORD_H=4
@


1.170
log
@ unify ksh_dup2() usage, use bool where appropriate
 apply diff from mirbsdksh-1.11:
  #ifdef DUP2_BROKEN
  /* Ultrix systems like to preserve the close-on-exec flag */
   XXX we do #ifdef __ultrix here (imake-style) instead of mirtoconfing it
    (but does anyone know of any other OS with the same problem? plus wed
    see it as we now know the symptoms)
 remove ultrix Build.hs warn=' but might work' in the hope it DOES
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.169 2008/04/01 17:25:37 tg Exp $
d3744 7
a3750 2
		export FNORD_C FNORD_D
		readonly FNORD_B FNORD_D
d3762 2
d3770 2
d3775 2
d3780 2
d3785 2
d3792 4
d3797 18
@


1.169
log
@easier way to fix it, WFM on BSD/OS
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.167 2008/04/01 16:26:42 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/03/28
@


1.168
log
@work around problems with old perl
@
text
@d4286 1
a4286 1
name: utf8bom-2a
d4291 1
a4291 23
category: pdksh,!os:cygwin,!os:uwin-nt,!oldish-perl
env-setup: !FOO=BAR!
stdin:
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t1
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t2
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t3
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t4
	chmod +x t?
	./t1
	./t2
	./t3
	./t4
expected-stdout:
	a=/nonexistant{FOO}
	a=/nonexistant{FOO}
	a=BAR
	a=BAR
---
name: utf8bom-2b
description:
	Check that we can execute BOM-shebangs
	XXX if the OS can already execute them, we lose
category: pdksh,oldish-perl
d4309 1
a4309 1
	/nrecogni.ed/
@


1.167
log
@ and $__perlname (for perl5 ipv perl, etc.)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.166 2008/04/01 16:12:18 tg Exp $
d4286 1
a4286 1
name: utf8bom-2
d4291 1
a4291 3
	note: perl 5.004_04 on Linux 2.0 doesn't support Unicode, t4 fails
	note: same for perl 5.003_02 on BSD/OS 3.1 and possibly others
category: pdksh,!os:cygwin,!os:uwin-nt
d4309 24
@


1.166
log
@add new regression test for funcs.c:c_typeset() output validity
oksh passes this test, mksh-current doesnt (yet)

From: Danijel Tasov <gmane@@korn.shell.la>
Message-ID: <fsqioj$te3$1@@ger.gmane.org>
Message-ID: <fsqnng$dq9$1@@ger.gmane.org>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.165 2008/04/01 16:04:58 tg Exp $
d44 7
d4298 2
a4299 2
	print '#!/usr/bin/env perl\nprint "a=$ENV{FOO}\n";' >t3
	print '#!/usr/bin/env perl\nprint "a=$ENV{FOO}\n";' >t4
@


1.165
log
@proper quotes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.164 2008/04/01 16:01:45 tg Exp $
d3727 45
@


1.164
log
@export __progname as environment to the test script,
so that the "$0" abuse can stop
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.163 2008/03/28 13:46:51 tg Exp $
d1457 1
a1457 1
	$__progname -c "tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<foo"
@


1.163
log
@ fix one more of the enum arithmetics complaints
 split Xinit into XinitN and Xinit macro, the former
  not initialising the xp argument of the latter,
  and use this to get rid of two variables that are
  only assigned but never referenced (gcc doesnt see
  this, but MIPSpro and IIRC SUNWcc do)
 re-indent while here
 bump patchlevel
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.162 2008/03/25 21:34:44 tg Exp $
d1457 1
a1457 1
	$0 -c "tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<foo"
d3378 1
a3378 1
	TMPDIR=$PWD/foo "$0" <<- 'EOF'
d3391 1
a3391 1
	TMPDIR=$PWD/foo "$0" <<- 'EOF'
d4153 3
a4155 3
	"$0" -c 'i=100; print hi |& while read -p line; do print "$((i++)) $line"; done'
	"$0" -c 'i=200; print hi | cat |& while read -p line; do print "$((i++)) $line"; done'
	"$0" -c 'i=300; (print hi | cat) |& while read -p line; do print "$((i++)) $line"; done'
d4206 6
a4211 6
	"$0" -c 'fnord'
	"$0" -c 'fnord; fnord; fnord; fnord'
	"$0" foo/bar
	"$0" <foo/bar
	"$0" foo/zoo
	"$0" -c 'print : $(fnord)'
d4244 2
a4245 2
	print '#!'"$0"'\nprint "a=$ENV{FOO}";' >t1
	print '#!'"$0"'\nprint "a=$ENV{FOO}";' >t2
d4264 2
a4265 2
	"$0" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
	"$0" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
d4312 1
a4312 1
	cp "$0" sh
d4348 1
a4348 1
	cp "$0" sh
d4449 6
a4454 6
	"$0" -c 'print v${x:(n)}x'
	"$0" -c 'print w${x: n}x'
	"$0" -c 'print x${x:n}x'
	"$0" -c 'print y${x:}x'
	"$0" -c 'print z${x}x'
	"$0" -c 'x=abcdef;y=123;echo ${x:${y:2:1}:2}' >/dev/null 2>&1; print $?
d4485 2
a4486 2
	"$0" -c .
	"$0" -c source
@


1.162
log
@ Add support for Ultrix 4.5 and ucode cc (?)
   I/O redirection seems broken:
    $ (date; date >/dev/null; date) | wc -l
    1 (expected: 2)
   other than that: working fine
   -YBSD (default) and -YSYSTEM_FIVE dont work, just -YPOSIX, somehow
 Fix $() to `` for OSF/1 V2.0 /bin/sh
   this compiler is FUBAR though:
	$ cat >t.c
	main() { return (foo()); }
	$ cc t.c
	ld:
	Unresolved :
	foo
	$ echo $?
	0
	$ ls -l a.out
	-rwxr-xr-x   1 mirbsd   users      10835 Jul 21 17:12 a.out
   it seems to have ucode, but man is not installed
 new mirtoconf check: mkstemp(3)
 if !HAVE_MKSTEMP (Ultrix), use tempnam(3)
 only use printf(1) if it exists (it doesnt on Ultrix)
 a few more signals
 add S_ISLNK if the OS doesnt define it
 add strcasecmp(3) proto for Ultrix (it _is_ in <portability.h>, but
  only for -YBSD I think)
 fgrep(1) on Ultrix doesnt do -e  -e 

10x DEChengst:#UnixNL for giving access
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.161 2008/03/23 22:09:57 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/03/25
@


1.161
log
@support dmonisation in mksh, for example
|	csh -cf '/command/svscanboot &'
and
|	/usr/mpkg/bin/pgrphack /usr/mpkg/bin/svscanboot &
can now be replaced with
|	/bin/mksh -T- /usr/mpkg/bin/svscanboot
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.160 2008/03/23 20:54:29 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/03/23
@


1.160
log
@fix environment handling for perl 5.003_02
gotta love 1997s software
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.159 2008/03/23 20:43:51 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/03/05
@


1.159
log
@add regression test self-tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.158 2008/03/05 18:21:44 tg Exp $
d4240 1
@


1.158
log
@ now this builds fine on DEChengsts Tru64 box:
  | OSF1 rubbereendje.dechengst.nl V5.1 2650 alpha
  with the vendor compiler:
  | Compaq C V6.5-011 on HP Tru64 UNIX V5.1B (Rev. 2650)
  | Compiler Driver V6.5-003 (sys) cc Driver
 the platforms sig_t is incompatible too (simplify check)
 no compile warnings at all
 results in:
  $ size mksh
  | text    data    bss     dec     hex
  | 327680  16384   17808   361872  58590
  $ file mksh
  | mksh:   COFF format alpha dynamically linked, demand paged executable or object module not stripped - version 3.13-14
  $ ldd mksh
  |
  |         Main  =>   mksh
  |         libc.so  =>   /usr/shlib/libc.so
  $ ls -l mksh
  | -rwxr-xr-x   1 mirbsd   users     395200 Mar  5 19:18 mksh
 minor testsuite issues:
  FAIL ./check.t:regression-13
        unexpected stderr - got too much output
        wanted nothing
        got:
                Successful
                cat: output error
   probably harmless
 works like a charm!
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.157 2008/03/01 22:58:22 tg Rel $
d18 26
@


1.158.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.174 2008/04/11 19:55:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/04/11
a17 33
name: selftest-1
description:
	Regression test self-testing
stdin:
	print ${foo:-baz}
expected-stdout:
	baz
---
name: selftest-2
description:
	Regression test self-testing
env-setup: !foo=bar!
stdin:
	print ${foo:-baz}
expected-stdout:
	bar
---
name: selftest-3
description:
	Regression test self-testing
env-setup: !ENV=fnord!
stdin:
	print "<$ENV>"
expected-stdout:
	<fnord>
---
name: selftest-env
description:
	Just output the environment variables set (always fails)
category: disabled
stdin:
	set
---
d1431 1
a1431 1
	"$__progname" -c "tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<<foo"
d3352 1
a3352 1
	TMPDIR=$PWD/foo "$__progname" <<- 'EOF'
d3365 1
a3365 1
	TMPDIR=$PWD/foo "$__progname" <<- 'EOF'
a3700 84
name: regression-63
description:
	Check if typeset, export, and readonly work
stdin:
	{
		print FNORD-0
		FNORD_A=1
		FNORD_B=2
		FNORD_C=3
		FNORD_D=4
		FNORD_E=5
		FNORD_F=6
		FNORD_G=7
		FNORD_H=8
		integer FNORD_E FNORD_F FNORD_G FNORD_H
		export FNORD_C FNORD_D FNORD_G FNORD_H
		readonly FNORD_B FNORD_D FNORD_F FNORD_H
		print FNORD-1
		export
		print FNORD-2
		export -p
		print FNORD-3
		readonly
		print FNORD-4
		readonly -p
		print FNORD-5
		typeset
		print FNORD-6
		typeset -p
		print FNORD-7
		typeset -
		print FNORD-8
	} | fgrep FNORD
expected-stdout:
	FNORD-0
	FNORD-1
	FNORD_C
	FNORD_D
	FNORD_G
	FNORD_H
	FNORD-2
	export FNORD_C=3
	export FNORD_D=4
	export FNORD_G=7
	export FNORD_H=8
	FNORD-3
	FNORD_B
	FNORD_D
	FNORD_F
	FNORD_H
	FNORD-4
	readonly FNORD_B=2
	readonly FNORD_D=4
	readonly FNORD_F=6
	readonly FNORD_H=8
	FNORD-5
	typeset FNORD_A
	typeset -r FNORD_B
	typeset -x FNORD_C
	typeset -x -r FNORD_D
	typeset -i FNORD_E
	typeset -i -r FNORD_F
	typeset -i -x FNORD_G
	typeset -i -x -r FNORD_H
	FNORD-6
	typeset FNORD_A=1
	typeset -r FNORD_B=2
	typeset -x FNORD_C=3
	typeset -x -r FNORD_D=4
	typeset -i FNORD_E=5
	typeset -i -r FNORD_F=6
	typeset -i -x FNORD_G=7
	typeset -i -x -r FNORD_H=8
	FNORD-7
	FNORD_A=1
	FNORD_B=2
	FNORD_C=3
	FNORD_D=4
	FNORD_E=5
	FNORD_F=6
	FNORD_G=7
	FNORD_H=8
	FNORD-8
---
d4127 3
a4129 3
	"$__progname" -c 'i=100; print hi |& while read -p line; do print "$((i++)) $line"; done'
	"$__progname" -c 'i=200; print hi | cat |& while read -p line; do print "$((i++)) $line"; done'
	"$__progname" -c 'i=300; (print hi | cat) |& while read -p line; do print "$((i++)) $line"; done'
d4180 6
a4185 6
	"$__progname" -c 'fnord'
	"$__progname" -c 'fnord; fnord; fnord; fnord'
	"$__progname" foo/bar
	"$__progname" <foo/bar
	"$__progname" foo/zoo
	"$__progname" -c 'print : $(fnord)'
d4213 2
a4214 2
	note: Ultrix perl5 t4 returns 65280 (exit-code 255) and no text
category: pdksh,!os:cygwin,!os:uwin-nt,!os:ultrix
d4217 4
a4220 4
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t1
	print '#!'"$__progname"'\nprint "a=$ENV{FOO}";' >t2
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t3
	print '#!'"$__perlname"'\nprint "a=$ENV{FOO}\n";' >t4
a4230 2
expected-stderr-pattern:
	/(Unrecognized character .... ignored at \..t4 line 1)*/
d4237 2
a4238 2
	"$__progname" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
	"$__progname" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
d4285 1
a4285 1
	cp "$__progname" sh
d4321 1
a4321 1
	cp "$__progname" sh
d4422 6
a4427 6
	"$__progname" -c 'print v${x:(n)}x'
	"$__progname" -c 'print w${x: n}x'
	"$__progname" -c 'print x${x:n}x'
	"$__progname" -c 'print y${x:}x'
	"$__progname" -c 'print z${x}x'
	"$__progname" -c 'x=abcdef;y=123;echo ${x:${y:2:1}:2}' >/dev/null 2>&1; print $?
d4458 2
a4459 2
	"$__progname" -c .
	"$__progname" -c source
@


1.158.2.2
log
@MFC: pull up mksh-R34 since itll be required by MirPorts soonish
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.196 2008/05/17 18:27:54 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R34 2008/05/17
d4186 2
a4187 2
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
d4195 2
a4196 2
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
d4199 2
a4200 2
	[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix
	[[ $(set +o) == *@@(-o braceexpand)@@(| *) ]] && echo brex || echo nobrex
d4255 1
a4255 1
category: pdksh,!no-histfile
a4279 14
name: typeset-padding-2
description:
	Check if base-!10 integers are padded right
stdin:
	typeset -Uui16 -L9 ln=16#1
	typeset -Uui16 -R9 rn=16#1
	typeset -Uui16 -Z9 zn=16#1
	typeset -L9 ls=16#1
	typeset -R9 rs=16#1
	typeset -Z9 zs=16#1
	print "<$ln> <$rn> <$zn> <$ls> <$rs> <$zs>"
expected-stdout:
	<16#1     > <     16#1> <16#000001> <16#1     > <     16#1> <0000016#1>
---
d4354 1
a4354 1
category: pdksh
d4356 2
a4357 2
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then print on; else print off; fi'
	"$__progname" -c ':; if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then print on; else print off; fi'
a4361 31
name: utf8opt-1
description:
	Check that the utf8-hack flag is not set at non-interactive startup
category: pdksh
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.utf8!
stdin:
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
		print is set
	else
		print is not set
	fi
expected-stdout:
	is not set
---
name: utf8opt-2
description:
	Check that the utf8-hack flag is set at interactive startup
category: pdksh
arguments: !-i!
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.utf8!
stdin:
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
		print is set
	else
		print is not set
	fi
expected-stdout:
	is set
expected-stderr-pattern:
	/(# )*/
---
a4572 13
name: print-nul-chars
description:
	Check handling of NUL characters for print and read
	note: second line should output 4 3 but we cannot
	handle NUL characters in strings yet
stdin:
	print $(($(print '<\0>' | wc -c)))
	x=$(print '<\0>')
	print $(($(print "$x" | wc -c))) ${#x}
expected-stdout:
	4
	3 2
---
a4605 331
name: integer-base-one-1
description:
	check if the use of fake integer base 1 works
stdin:
	set -o utf8-hack
	typeset -Uui16 i0=1# i1=1#
	typeset -i1 o0a=64
	typeset -i1 o1a=0x263A
	typeset -Uui1 o0b=0x7E
	typeset -Uui1 o1b=0xFDD0
	integer px=0xCAFE 'p0=1# ' p1=1# pl=1#f
	print "in <$i0> <$i1>"
	print "out <${o0a#1#}|${o0b#1#}> <${o1a#1#}|${o1b#1#}>"
	typeset -Uui1 i0 i1
	print "pass <$px> <$p0> <$p1> <$pl> <${i0#1#}|${i1#1#}>"
	typeset -Uui16 tv1=1#~ tv2=1# tv3=1# tv4=1# tv5=1# tv6=1# tv7=1# tv8=1#
	print "specX <${tv1#16#}> <${tv2#16#}> <${tv3#16#}> <${tv4#16#}> <${tv5#16#}> <${tv6#16#}> <${tv7#16#}> <${tv8#16#}>"
	typeset -i1 tv1 tv2 tv3 tv4 tv5 tv6 tv7 tv8
	print "specW <${tv1#1#}> <${tv2#1#}> <${tv3#1#}> <${tv4#1#}> <${tv5#1#}> <${tv6#1#}> <${tv7#1#}> <${tv8#1#}>"
	typeset -i1 xs1=0xEF7F xs2=0xEF80 xs3=0xFDD0
	print "specU <${xs1#1#}> <${xs2#1#}> <${xs3#1#}>"
expected-stdout:
	in <16#EFEF> <16#20AC>
	out <@@|~> <|>
	pass <16#cafe> <1# > <1#> <1#f> <|>
	specX <7E> <7F> <EF80> <EF81> <EFC0> <EFC1> <A0> <80>
	specW <~> <> <> <> <> <> <> <>
	specU <> <> <>
---
name: integer-base-one-2a
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -o utf8-hack
	integer x=1#foo
	print /$x/
expected-stderr-pattern:
	/1#foo: unexpected 'oo'/
expected-exit: e != 0
---
name: integer-base-one-2b
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -o utf8-hack
	integer x=1#
	print /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2c1
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set -o utf8-hack
	integer x=1#
	print /$x/
expected-stdout:
	/1#/
---
name: integer-base-one-2c2
description:
	check if the use of fake integer base 1 stops at correct characters
stdin:
	set +o utf8-hack
	integer x=1#
	print /$x/
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d1
description:
	check if the use of fake integer base 1 handles octets okay
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# invalid utf-8
expected-stdout:
	/16#efff/
---
name: integer-base-one-2d2
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# invalid 2-byte
expected-stdout:
	/16#efc2/
---
name: integer-base-one-2d3
description:
	check if the use of fake integer base 1 handles octets
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# invalid 2-byte
expected-stdout:
	/16#efef/
---
name: integer-base-one-2d4
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# invalid 3-byte
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d5
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-2d6
description:
	check if the use of fake integer base 1 stops at invalid input
stdin:
	set -o utf8-hack
	typeset -i16 x=1#
	print /$x/	# non-minimalistic
expected-stderr-pattern:
	/1#: unexpected ''/
expected-exit: e != 0
---
name: integer-base-one-3a
description:
	some sample code for hexdumping
stdin:
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\x${i#16#1}"
		done
		print
	} | {
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				hv=1#${line::1}
				if (( (pos & 15) == 0 )); then
					(( pos )) && print "$dasc|"
					print -n "${pos#16#}  "
					dasc=' |'
				fi
				print -n "${hv#16#} "
				if (( (hv < 32) || (hv > 126) )); then
					dasc=$dasc.
				else
					dasc=$dasc${line::1}
				fi
				(( (pos++ & 15) == 7 )) && print -n -- '- '
				line=${line:1}
			done
		done
		if (( (pos & 15) != 1 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\..|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  |................|
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |................|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F 80 81 82 83 84 85 86 - 87 88 89 8A 8B 8C 8D 8E  |................|
	000000B0  8F 90 91 92 93 94 95 96 - 97 98 99 9A 9B 9C 9D 9E  |................|
	000000C0  9F A0 A1 A2 A3 A4 A5 A6 - A7 A8 A9 AA AB AC AD AE  |................|
	000000D0  AF B0 B1 B2 B3 B4 B5 B6 - B7 B8 B9 BA BB BC BD BE  |................|
	000000E0  BF C0 C1 C2 C3 C4 C5 C6 - C7 C8 C9 CA CB CC CD CE  |................|
	000000F0  CF D0 D1 D2 D3 D4 D5 D6 - D7 D8 D9 DA DB DC DD DE  |................|
	00000100  DF E0 E1 E2 E3 E4 E5 E6 - E7 E8 E9 EA EB EC ED EE  |................|
	00000110  EF F0 F1 F2 F3 F4 F5 F6 - F7 F8 F9 FA FB FC FD FE  |................|
	00000120  FF 0A                   -                          |..|
---
name: integer-base-one-3b
description:
	some sample code for hexdumping Unicode
stdin:
	set -o utf8-hack
	{
		print 'Hello, World!\\\n'
		typeset -Uui16 i=0x100
		# change that to 0xFF once we can handle embedded
		# NUL characters in strings / here documents
		while (( i++ < 0x1FF )); do
			print -n "\u${i#16#1}"
		done
		print
		print \\xff		# invalid utf-8
		print \\xc2		# invalid 2-byte
		print \\xef\\xbf\\xc0	# invalid 3-byte
		print \\xc0\\x80	# non-minimalistic
		print \\xe0\\x80\\x80	# non-minimalistic
		print ''	# end of range
	} | {
		typeset -Uui16 -Z11 pos=0
		typeset -Uui16 -Z5 hv
		typeset -i1 wc=0x0A
		dasc=
		nl=${wc#1#}
		integer n
		while IFS= read -r line; do
			line=$line$nl
			while [[ -n $line ]]; do
				(( hv = 1#${line::1} & 0xFF ))
				if (( (hv < 0xC2) || (hv >= 0xF0) )); then
					n=1
				elif (( hv < 0xE0 )); then
					n=2
				else
					n=3
				fi
				if (( n > 1 )); then
					(( (1#${line:1:1} & 0xC0) == 0x80 )) || n=1
					(( hv == 0xE0 )) && \
					    (( (1#${line:1:1} & 0xFF) < 0xA0 )) && n=1
				fi
				if (( n > 2 )); then
					(( hv = 1#${line:2:1} & 0xFF ))
					(( (hv & 0xC0) == 0x80 )) || n=1
					(( (((1#${line::1} & 0xFF) == 0xEF) && \
					    ((1#${line:1:1} & 0xFF) == 0xBF) && \
					    (hv > 0xBD)) )) && n=1
				fi
				wc=1#${line::n}
				if (( (wc < 32) || \
				    ((wc > 126) && (wc < 160)) )); then
					dch=.
				elif (( (wc & 0xFF80) == 0xEF80 )); then
					dch=
				else
					dch=${wc#1#}
				fi
				if (( (pos & 15) >= (n == 3 ? 14 : 15) )); then
					dasc=$dasc$dch
					dch=
				fi
				while (( n-- )); do
					if (( (pos & 15) == 0 )); then
						(( pos )) && print "$dasc|"
						print -n "${pos#16#}  "
						dasc=' |'
					fi
					hv=1#${line::1}
					print -n "${hv#16#} "
					(( (pos++ & 15) == 7 )) && \
					    print -n -- '- '
					line=${line:1}
				done
				dasc=$dasc$dch
			done
		done
		if (( pos & 15 )); then
			while (( pos & 15 )); do
				print -n '   '
				(( (pos++ & 15) == 7 )) && print -n -- '- '
			done
			print "$dasc|"
		fi
	}
expected-stdout:
	00000000  48 65 6C 6C 6F 2C 20 57 - 6F 72 6C 64 21 5C 0A E3  |Hello, World!\.|
	00000010  81 93 E3 82 93 E3 81 AB - E3 81 A1 E3 81 AF EF BC  ||
	00000020  81 0A 01 02 03 04 05 06 - 07 08 09 0A 0B 0C 0D 0E  |...............|
	00000030  0F 10 11 12 13 14 15 16 - 17 18 19 1A 1B 1C 1D 1E  |................|
	00000040  1F 20 21 22 23 24 25 26 - 27 28 29 2A 2B 2C 2D 2E  |. !"#$%&'()*+,-.|
	00000050  2F 30 31 32 33 34 35 36 - 37 38 39 3A 3B 3C 3D 3E  |/0123456789:;<=>|
	00000060  3F 40 41 42 43 44 45 46 - 47 48 49 4A 4B 4C 4D 4E  |?@@ABCDEFGHIJKLMN|
	00000070  4F 50 51 52 53 54 55 56 - 57 58 59 5A 5B 5C 5D 5E  |OPQRSTUVWXYZ[\]^|
	00000080  5F 60 61 62 63 64 65 66 - 67 68 69 6A 6B 6C 6D 6E  |_`abcdefghijklmn|
	00000090  6F 70 71 72 73 74 75 76 - 77 78 79 7A 7B 7C 7D 7E  |opqrstuvwxyz{|}~|
	000000A0  7F C2 80 C2 81 C2 82 C2 - 83 C2 84 C2 85 C2 86 C2  |.........|
	000000B0  87 C2 88 C2 89 C2 8A C2 - 8B C2 8C C2 8D C2 8E C2  |........|
	000000C0  8F C2 90 C2 91 C2 92 C2 - 93 C2 94 C2 95 C2 96 C2  |........|
	000000D0  97 C2 98 C2 99 C2 9A C2 - 9B C2 9C C2 9D C2 9E C2  |........|
	000000E0  9F C2 A0 C2 A1 C2 A2 C2 - A3 C2 A4 C2 A5 C2 A6 C2  ||
	000000F0  A7 C2 A8 C2 A9 C2 AA C2 - AB C2 AC C2 AD C2 AE C2  ||
	00000100  AF C2 B0 C2 B1 C2 B2 C2 - B3 C2 B4 C2 B5 C2 B6 C2  ||
	00000110  B7 C2 B8 C2 B9 C2 BA C2 - BB C2 BC C2 BD C2 BE C2  ||
	00000120  BF C3 80 C3 81 C3 82 C3 - 83 C3 84 C3 85 C3 86 C3  ||
	00000130  87 C3 88 C3 89 C3 8A C3 - 8B C3 8C C3 8D C3 8E C3  ||
	00000140  8F C3 90 C3 91 C3 92 C3 - 93 C3 94 C3 95 C3 96 C3  ||
	00000150  97 C3 98 C3 99 C3 9A C3 - 9B C3 9C C3 9D C3 9E C3  ||
	00000160  9F C3 A0 C3 A1 C3 A2 C3 - A3 C3 A4 C3 A5 C3 A6 C3  ||
	00000170  A7 C3 A8 C3 A9 C3 AA C3 - AB C3 AC C3 AD C3 AE C3  ||
	00000180  AF C3 B0 C3 B1 C3 B2 C3 - B3 C3 B4 C3 B5 C3 B6 C3  ||
	00000190  B7 C3 B8 C3 B9 C3 BA C3 - BB C3 BC C3 BD C3 BE C3  ||
	000001A0  BF 0A FF 0A C2 0A EF BF - C0 0A C0 80 0A E0 80 80  |.....|
	000001B0  0A EF BF BD EF BF BE EF - BF BF 0A                 |..|
---
name: ulimit-1
description:
	Check if we can use a specific syntax idiom for ulimit
stdin:
	if ! x=$(ulimit -d); then
		print expected to fail on this OS
	else
		ulimit -dS $x && print okay
	fi
expected-stdout:
	okay
---

@


1.158.2.3
log
@MFC: mksh R35
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.213 2008/07/11 00:23:59 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/10
d13 1
a1501 8
name: heredoc-9d
description:
	Check another corner case of here strings
stdin:
	tr abcdefghijklmnopqrstuvwxyz nopqrstuvwxyzabcdefghijklm <<< bar
expected-stdout:
	one
---
a1721 23
name: history-unlink
description:
	Check if broken HISTFILEs do not cause trouble
category: !os:cygwin
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=foo/hist.file!
file-setup: file 644 "Env"
	PS1=X
file-setup: dir 755 "foo"
file-setup: file 644 "foo/hist.file"
	sometext
time-limit: 5
perl-setup: chmod(0555, "foo");
stdin:
	echo hi
	fc -l
	chmod 0755 foo
expected-stdout:
	hi
	1	echo hi
expected-stderr-pattern:
	/(.*cannot unlink HISTFILE.*\n)?X*$/
---
d2939 2
d2957 1
a2957 1
	(: ; cat t2 2>&-) | sleep 1
d4255 1
a4255 1
category: !no-histfile
d4300 1
a4300 1
category: !os:darwin
d4345 1
a4345 1
category: !os:cygwin,!os:uwin-nt,!os:ultrix
d4368 1
d4376 1
a4376 15
name: utf8opt-1a
description:
	Check that the utf8-hack flag is not set at non-interactive startup
category: !os:hpux
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
stdin:
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
		print is set
	else
		print is not set
	fi
expected-stdout:
	is not set
---
name: utf8opt-1b
d4379 1
a4379 1
category: os:hpux
d4390 1
a4390 1
name: utf8opt-2a
d4393 1
a4393 18
category: !os:hpux
arguments: !-i!
env-setup: !PS1=!PS2=!LC_CTYPE=en_US.UTF-8!
stdin:
	if [[ $(set +o) = *@@(-o utf8-hack)@@(| *) ]]; then
		print is set
	else
		print is not set
	fi
expected-stdout:
	is set
expected-stderr-pattern:
	/(# )*/
---
name: utf8opt-2b
description:
	Check that the utf8-hack flag is set at interactive startup
category: os:hpux
d4410 1
d4432 1
d4445 1
d4459 1
d4482 1
d4994 1
a4994 147
name: bashiop-1
description:
	Check if GNU bash-like I/O redirection works
	Part 1: this is also supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: bashiop-2a
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3&>foo
	echo ===
	cat foo
expected-stdout:
	ras
	===
	dwa
	tri
---
name: bashiop-2b
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout 3>foo &>&3
	echo ===
	cat foo
expected-stdout:
	===
	ras
	dwa
	tri
---
name: bashiop-2c
description:
	Check if GNU bash-like I/O redirection works
	Part 2: this is *not* supported by GNU bash
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>>foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	mir
	ras
	dwa
---
name: bashiop-3a
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 1: this is also supported by GNU bash
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>foo
	echo ===
	cat foo
expected-stdout:
	===
	mir
expected-stderr-pattern: /.*: cannot (create|overwrite) .*/
---
name: bashiop-3b
description:
	Check if GNU bash-like I/O redirection fails correctly
	Part 2: this is *not* supported by GNU bash
stdin:
	echo mir >foo
	set -o noclobber
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	threeout &>|foo
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
name: mkshiop-1
description:
	Check for support of more than 9 file descriptors
stdin:
	read -u10 foo 10<<< bar
	print x$foo
expected-stdout:
	xbar
---
name: mkshiop-2
description:
	Check for support of more than 9 file descriptors
stdin:
	exec 12>foo
	print -u12 bar
	print baz >&12
	cat foo
expected-stdout:
	bar
	baz
---
@


1.158.2.4
log
@MFC: mksh R35b
@
text
@d1 1
a1 1
# $MirOS$
d10 1
a10 1
	@@(#)MIRBSD KSH R35 2008/07/18
a3845 12
name: regression-64
description:
	Check that we can redefine functions calling time builtin
stdin:
	t() {
		time >/dev/null
	}
	t 2>/dev/null
	t() {
		time
	}
---
d4373 1
a4373 1
category: !os:cygwin,!os:uwin-nt,!os:ultrix,!smksh
a5175 1
category: !smksh
a5184 1
category: !smksh
a5193 102
name: oksh-seterror
description:
	$OpenBSD: seterror.sh,v 1.1 2003/02/09 18:52:49 espie Exp $
	set -e is supposed to abort the script for errors that
	are not caught otherwise. pdksh fails this test.
stdin:
	set -e
	for i in 1 2 3
	do
		false && true
	done
	true
expected-fail: yes
---
name: oksh-shcrash
description:
	src/regress/bin/ksh/shcrash.sh,v 1.1
stdin:
	deplibs="-lz -lpng /usr/local/lib/libjpeg.la -ltiff -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -ltiff -ljpeg -lz -lpng -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk_pixbuf.la -lz -lpng /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -lz -lz /usr/local/lib/libxml.la -lz -lz -lz /usr/local/lib/libxml.la -lm -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libglib.la /usr/local/lib/libgmodule.la -lintl -lglib -lgmodule /usr/local/lib/libgdk.la /usr/local/lib/libgtk.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade.la -lz -lz -lz /usr/local/lib/libxml.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile /usr/local/lib/libesd.la -lm -lz /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -lglib -lgmodule /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lz /usr/local/lib/libgdk_imlib.la /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lm -lz -lungif -lz -ljpeg -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib /usr/local/lib/libglade-gnome.la /usr/local/lib/libglib.la -lm -lm /usr/local/lib/libaudiofile.la -lm -lm -laudiofile -L/usr/local/lib /usr/local/lib/libesd.la -lm -lz -L/usr/local/lib /usr/local/lib/libgnomesupport.la -lm -lz -lm -lglib -L/usr/local/lib /usr/local/lib/libgnome.la -lX11 -lXext /usr/local/lib/libiconv.la -L/usr/local/lib -L/usr/ports/devel/gettext/w-gettext-0.10.40/gettext-0.10.40/intl/.libs /usr/local/lib/libintl.la /usr/local/lib/libgmodule.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgdk.la -lintl -lm -lX11 -lXext -L/usr/X11R6/lib -lglib -lgmodule -L/usr/local/lib /usr/local/lib/libgtk.la -lICE -lSM -lz -lpng /usr/local/lib/libungif.la /usr/local/lib/libjpeg.la -ltiff -lm -lz -lpng /usr/local/lib/libungif.la -lz /usr/local/lib/libjpeg.la -ltiff -L/usr/local/lib -L/usr/X11R6/lib /usr/local/lib/libgdk_imlib.la -lm -L/usr/local/lib /usr/local/lib/libart_lgpl.la -lm -lz -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -lICE -lSM -lm -lX11 -lXext -lintl -lglib -lgmodule -lgdk -lgtk -L/usr/X11R6/lib -lm -lz -lpng -lungif -lz -ljpeg -ltiff -ljpeg -lgdk_imlib -lglib -lm -laudiofile -lm -laudiofile -lesd -L/usr/local/lib /usr/local/lib/libgnomeui.la -L/usr/X11R6/lib -L/usr/local/lib"
	specialdeplibs="-lgnomeui -lart_lgpl -lgdk_imlib -ltiff -ljpeg -lungif -lpng -lz -lSM -lICE -lgtk -lgdk -lgmodule -lintl -lXext -lX11 -lgnome -lgnomesupport -lesd -laudiofile -lm -lglib"
	for deplib in $deplibs; do
		case $deplib in
		-L*)
			new_libs="$deplib $new_libs"
			;;
		*)
			case " $specialdeplibs " in
			*" $deplib "*)
				new_libs="$deplib $new_libs";;
			esac
			;;
		esac
	done
---
name: oksh-varfunction
description:
	$OpenBSD: varfunction.sh,v 1.1 2003/12/15 05:28:40 otto Exp $
	Calling
		FOO=bar f
	where f is a ksh style function, should not set FOO in the current
	env. If f is a bourne style function, FOO should be set. Furthermore,
	the function should receive a correct value of FOO. Additionally,
	setting FOO in the function itself should not change the value in
	global environment.
	Inspired by PR 2450.
stdin:
	function k {
		if [ x$FOO != xbar ]; then
			echo 1
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 2
			return 1;
		fi
		FOO=foo
		return 0
	}
	b () {
		if [ x$FOO != xbar ]; then
			echo 3
			return 1
		fi
		x=$(env | grep FOO)
		if [ "x$x" != "xFOO=bar" ]; then
			echo 4
			return 1;
		fi
		FOO=foo
		return 0
	}
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != x ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbar ]; then
		exit 1
	fi
	FOO=barbar
	FOO=bar k
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbarbar ]; then
		exit 1
	fi
	FOO=bar b
	if [ $? != 0 ]; then
		exit 1
	fi
	if [ x$FOO != xbar ]; then
		exit 1
	fi
---
@


1.158.2.5
log
@MFC: mksh R36b
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.252 2008/12/13 17:02:11 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R36 2008/12/13
a153 16
name: alias-9
description:
	Check that recursion is detected/avoided in aliases.
	This check fails for slow machines or Cygwin, raise
	the time-limit clause (e.g. to 7) if this occurs.
time-limit: 3
stdin:
	echo -n >tf
	alias ls=ls
	ls
	echo $(ls)
	exit 0
expected-stdout:
	tf
	tf
---
d1686 3
a1688 4
	Check that heredoc temp files aren't removed too soon or too
	late. Heredoc in function, backgrounded call to function.
	This check can fail on slow machines (<100 MHz), or Cygwin,
	that's normal.
a1728 20
name: history-dups
description:
	Verify duplicates and spaces are not entered
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	echo hi
	 echo yo
	echo hi
	fc -l
expected-stdout:
	hi
	yo
	hi
	1	echo hi
expected-stderr-pattern:
	/^X*$/
---
a1832 1
	:
d1834 1
a1834 1
	fc -l 2 5
d1840 2
a1841 3
	3	:
	4	echo ghi jkl
	5	fc -l 2 5
d2186 1
a2186 1
category: stdout-ed
d2208 1
a2208 1
category: stdout-ed
d2239 1
a2239 1
category: stdout-ed
d2270 1
a2270 1
category: !no-stderr-ed
d2290 1
a2290 1
category: !no-stderr-ed
d2317 1
a2317 1
category: !no-stderr-ed
a4253 38
name: posix-mode-2a
description:
	Check that posix mode is *not* automatically turned on
category: !binsh
stdin:
	ln -s "$__progname" ksh
	ln -s "$__progname" sh
	ln -s "$__progname" ./-ksh
	ln -s "$__progname" ./-sh
	for shell in {,-}{,k}sh; do
		print -- $shell $(./$shell +l -c \
		    '[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix')
	done
expected-stdout:
	sh noposix
	ksh noposix
	-sh noposix
	-ksh noposix
---
name: posix-mode-2b
description:
	Check that posix mode is automatically turned on
category: binsh
stdin:
	ln -s "$__progname" ksh
	ln -s "$__progname" sh
	ln -s "$__progname" ./-ksh
	ln -s "$__progname" ./-sh
	for shell in {,-}{,k}sh; do
		print -- $shell $(./$shell +l -c \
		    '[[ $(set +o) == *@@(-o posix)@@(| *) ]] && echo posix || echo noposix')
	done
expected-stdout:
	sh posix
	ksh noposix
	-sh posix
	-ksh noposix
---
d4407 1
a4407 1
	Reading the UTF-8 BOM should enable the utf8-mode flag
d4409 2
a4410 2
	"$__progname" -c ':; if [[ $- = *U* ]]; then print on; else print off; fi'
	"$__progname" -c ':; if [[ $- = *U* ]]; then print on; else print off; fi'
d4417 1
a4417 1
	Check that the utf8-mode flag is not set at non-interactive startup
d4421 1
a4421 1
	if [[ $- = *U* ]]; then
d4431 1
a4431 1
	Check that the utf8-mode flag is not set at non-interactive startup
d4435 1
a4435 1
	if [[ $- = *U* ]]; then
d4445 1
a4445 1
	Check that the utf8-mode flag is set at interactive startup
d4450 1
a4450 1
	if [[ $- = *U* ]]; then
d4462 1
a4462 1
	Check that the utf8-mode flag is set at interactive startup
d4467 1
a4467 1
	if [[ $- = *U* ]]; then
d4733 1
a4733 1
	set -U
d4762 1
a4762 1
	set -U
d4773 1
a4773 1
	set -U
d4784 1
a4784 1
	set -U
d4794 1
a4794 1
	set +U
d4805 1
a4805 1
	set -U
d4815 1
a4815 1
	set -U
d4825 1
a4825 1
	set -U
d4835 1
a4835 1
	set -U
d4846 1
a4846 1
	set -U
d4857 1
a4857 1
	set -U
d4935 1
a4935 1
	set -U
a5184 26
name: bashiop-4
description:
	Check if GNU bash-like I/O redirection works
	Part 4: this is also supported by GNU bash,
	but failed in some mksh versions
stdin:
	exec 3>&1
	function threeout {
		echo ras
		echo dwa >&2
		echo tri >&3
	}
	function blubb {
		[[ -e bar ]] && threeout "$bf" &>foo
	}
	blubb
	echo -n >bar
	blubb
	echo ===
	cat foo
expected-stdout:
	tri
	===
	ras
	dwa
---
a5309 25
name: fd-cloexec-1
description:
	Verify that file descriptors > 2 are private for Korn shells
file-setup: file 644 "test.sh"
	print -u3 Fowl
stdin:
	exec 3>&1
	"$__progname" test.sh
expected-exit: e != 0
expected-stderr:
	test.sh[1]: print: -u: 3: bad file descriptor
---
name: fd-cloexec-2
description:
	Verify that file descriptors > 2 are not private for POSIX shells
	See Debian Bug #154540, Closes: #499139
file-setup: file 644 "test.sh"
	print -u3 Fowl
stdin:
	set -o posix
	exec 3>&1
	"$__progname" test.sh
expected-stdout:
	Fowl
---
@


1.157
log
@add a much more crazy test now, for several occurences of escaped and
unescaped and variabled patterns and slashes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.156 2008/03/01 21:24:58 tg Rel $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/03/01
@


1.156
log
@finally, all bugs fixed, adjust dot.mkshrc to use the subst code
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.155 2008/03/01 21:10:25 tg Exp $
d1123 71
a1193 13
	echo ${wd/#$pfx/~}
	echo ${wd/#\$pfx/~}
	echo ${wd/#"$pfx"/~}
	echo ${wd/#'$pfx'/~}
	echo ${wd/#"\$pfx"/~}
	echo ${wd/#'\$pfx'/~}
expected-stdout:
	$pfx/tmp
	~/tmp
	$pfx/tmp
	~/tmp
	~/tmp
	~/tmp
@


1.155
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.154 2008/03/01 17:14:17 tg Exp $
d1001 1
d1003 1
d1032 1
d1062 1
@


1.154
log
@fix one of the bugs in this code still the one Im looking for left
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.153 2008/03/01 16:40:57 tg Exp $
d1079 1
a1079 1
name: eglob-substrpl-3
d1086 1
d1089 19
d1113 20
@


1.153
log
@add another two corner case checks - and mksh fails one of these oO
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.152 2008/03/01 02:21:36 tg Stab $
d1086 2
d1090 2
@


1.152
log
@we don't need to be special if called as -sh any longer now
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.151 2008/02/29 16:38:40 tg Exp $
d1060 29
@


1.151
log
@fix on Interix, where tr(1) is more weird than even Solaris XPG4 one
just do not use ranges, no matter what.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.150 2008/02/29 11:48:32 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/02/27
@


1.150
log
@handle slowlaris idiotic /usr/xpg4/bin/tr(1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.149 2008/02/27 12:49:53 tg Exp $
d1295 6
a1300 6
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<foo
	$0 -c "$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<foo"
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<"$bar"
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<'$bar'
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<\$bar
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<-foo
d1317 1
a1317 1
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<$bar
d1329 1
a1329 1
	$tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<$bar
@


1.149
log
@fix
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.148 2008/02/27 11:24:11 tg Exp $
d1295 6
a1300 6
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<foo
	$0 -c "tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<foo"
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<"$bar"
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<'$bar'
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<\$bar
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<-foo
d1317 1
a1317 1
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<$bar
d1329 1
a1329 1
	tr '[A-Za-z]' '[N-ZA-Mn-za-m]' <<<$bar
@


1.148
log
@almost hack ${foo//bar/baz} support for real, now
still one corner case left 
 11:09Han:#UnixNL Ik _haat_ bash
 kann ich mich nur anschlieen
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.147 2008/02/26 20:43:10 tg Exp $
d1027 3
a1029 1
#	echo 26: ${x//\%1/9}
d1056 3
a1058 1
#	26: 1222321_ab/cde_b/c_1221
@


1.147
log
@implement here strings
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.146 2008/02/25 00:58:24 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/02/26
d967 1
a967 1
	Eglobing in trim expressions...
d984 1
a984 1
	Check eglobing works in trims...
d997 59
d3293 1
a3293 1
	Check that globing works in pipelined commands
@


1.146
log
@now we dont need more special FPOSIX behaviour any more
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.145 2008/02/24 22:12:36 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R33 2008/02/24
d1226 45
@


1.145
log
@  * lex.c: Don't expand aliases if there's an opening bracket just after
    the token. Fixes unreported problem with pdksh reporting syntax error
    on the init scripts that define function named stop (clashing
    with an built-in alias.)

 -- Robert Luberda <robert@@debian.org>  Sun, 27 Feb 2005 18:36:55 +0100
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.144 2008/02/24 15:57:20 tg Exp $
d4022 1
a4022 1
name: aliases-2
d4025 27
d4058 4
d4064 7
d4072 1
a4072 1
name: aliases-3
d4074 1
a4074 1
	Check if running as sh disables built-in aliases (except a few)
d4082 4
d4088 7
@


1.144
log
@another one from debian: '.' needs an argument
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.143 2008/02/24 15:48:42 tg Exp $
d4172 23
@


1.143
log
@live code from FOSDEM: add print \xDB and \u20AC, including regression test
agreed bsiegert@@
good idea and manpage diff ok'd by some netbsd person sitting next to me
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.142 2007/10/25 13:51:18 tg Exp $
d4162 10
@


1.142
log
@ fix for the pipeline-as-coprocess problem
 bump to mksh R32
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.141 2007/10/18 20:32:31 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R32 2007/10/25
d4154 8
@


1.141
log
@first step towards mksh R32 
allow array indices in the uint32_t range (04294967295) and map negatives
into that range; adjust manual page and regression tests; to be used RSN 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.140 2007/10/14 13:43:40 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/10/18
d3854 1
a3854 1
name: pipeline-subshell-1
d3880 12
@


1.140
log
@clean up the CHARMASK mess
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.139 2007/10/09 14:50:49 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/10/14
d4055 14
@


1.139
log
@revert the return type of x_e_getc() back from u_char to int
this change broke abortion on failure to read input, was not
needed for gcc warnings and is the fault of Intels compiler

this should fix the other busy-loop problem occuring only on
GNU/Linux so far  10x spaetzle@@freewrt.o for pointing me to
the problem; reproduced on my work craptop
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.138 2007/09/09 18:06:38 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/10/09
@


1.138
log
@ fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
 avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
 escape ? as well (but not ] because thats wrong)
  reminded by cbiere@@netbsd via oksh
 Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
 Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@s mksh busy loop problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
 some KNF
 bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.137 2007/09/07 23:57:14 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/09/09
@


1.137
log
@fix typo (blsk -> bksl)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.136 2007/08/19 22:06:25 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/08/19
@


1.136
log
@new builtin rename (this name sounds better than mksh_mv_rescue )
to just call rename(2) directly, e.g. if /bin/mv needs /lib/ld-uClibc.so.0

some assorted code cleanup
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.135 2007/08/18 00:22:07 tg Exp $
d229 1
a229 1
name: blsk-nl-ign-4
d253 1
a253 1
name: blsk-nl-ign-5
d452 1
a452 1
name: blsk-nl-9
d464 1
a464 1
name: blsk-nl-10
d478 1
a478 1
name: blsk-nl-ksh-1
d495 1
a495 1
name: blsk-nl-ksh-2
@


1.135
log
@feature freeze for mksh R31, to be released as part of MirOS #10
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.134 2007/08/13 19:39:19 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R31 2007/08/18
@


1.134
log
@Implement the source command, as requested by some and agreed bsiegert@@
In contrast to AT&T ksh93, its semantics are like GNU bash in that it ap-
pends the current working directory to the search path; it is implemented
as a shell alias instead of enhancing funcs.c:shbuiltins[] like in ksh93.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.133 2007/08/12 13:42:20 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/08/13
@


1.133
log
@add set -o arc4random, RTFM for details
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.132 2007/07/31 11:11:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/08/12
d4005 1
@


1.132
log
@ new way of checking for mknod & friends, due to tcc vs glibc weirdness
 bump vsn for the code restructuring
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.131 2007/07/26 13:23:51 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/31
@


1.131
log
@ test on HURD (gnubber)
 fix unreachable code (break stmt) cought by suncc on yofuh's E420
 bump vsn to today
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.130 2007/07/24 11:22:03 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/26
@


1.130
log
@fix another errexit bug: unwind() is __dead, so the pseudo-signal was never
delivered to the process
 regression test by Clint Pachl, verified against Debian ksh93 by me
 place to fix it in the code discovered by Otto Moerbeek
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.129 2007/07/23 14:28:51 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/24
@


1.129
log
@ and fix that bug.

   
      
     
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.128 2007/07/23 14:10:48 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/23
d3739 17
@


1.128
log
@more testcase  currently broken had thought of this but apparently not done
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.127 2007/07/22 13:46:14 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/22
@


1.127
log
@ Build.sh: always prepend well-known signal names, so that some signals
  will not come up weirdly (e.g. on AIX: SIGSAK (SIGMAX?), SIGIO (SIGAIO?),
  SIGURG (SIGIOINT?)), and add a few more while here
 check.t, sh.h: bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.126 2007/07/17 13:56:50 tg Exp $
d4100 10
@


1.126
log
@ make the "if called as sh, set FPOSIX" not !SMALL-only
 bump to R30-gamma, feature freeze
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.125 2007/07/06 11:54:34 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R30 2007/07/17
@


1.125
log
@these can't be nested and are expected to fail, although our error message
is different from bash's that's okay
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.124 2007/07/06 02:22:55 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/07/05
d4007 1
a4007 1
category: pdksh,!smksh
@


1.124
log
@fix the rest of it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.121 2007/07/05 11:49:07 tg Exp $
d4083 1
a4083 1
	This is by design.
d4091 1
d4096 1
@


1.123
log
@more bash-like behaviour here, oeps
@
text
@d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/07/01
d4071 1
a4071 1
	print b ${x:n:3} ${y:n:3} ${z:n:3} b
d4073 1
a4073 1
expected-fail: yes
d4078 19
@


1.122
log
@fix the regression test, mksh fails it now
@
text
@d4055 1
a4055 1
	c    c
@


1.121
log
@remove some uwin kludges, just live with it
keep these that are indeed correct though
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.120 2007/07/01 21:27:03 tg Exp $
d4045 1
a4045 1
	print a ${x:2:3} ${y:2:3} ${z:2:3} a
d4053 1
a4053 1
	a cde 345 #75 a
@


1.120
log
@ add support for the Borland C++ Builder (on UWIN)
 add support for the Digital Mars compiler (on UWIN)
 clean up
 describe new build targets and that UWIN sucks
 bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.119 2007/07/01 19:04:52 tg Exp $
a2159 2
# hangs, no idea why
category: !os:uwin-nt
a2828 2
# hangs, no idea why
category: !os:uwin-nt
a3340 1
# note: hangs on UWIN half of the time, no idea why
a3366 2
# hangs, no idea why
category: !os:uwin-nt
a3411 2
# hangs, no idea why
category: !os:uwin-nt
a3426 2
# hangs, no idea why
category: !os:uwin-nt
a3625 2
# hangs, no idea why
category: !os:uwin-nt
a3641 2
# hangs, no idea why
category: !os:uwin-nt
@


1.119
log
@coerce this into running on UWIN - or rather sort of. Ugly.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.118 2007/06/27 23:12:58 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/27
@


1.118
log
@this is bash compatibility week, and by suggestion of actual users,
namely Dr. Robert Pfeffer Arnold (in this case, in FreeWRT), make
a half-completed attempt at implementing ${foo:2:3} substring evals
(of course, negatives can't work right now and that the numbers are
in face expressions is something I only read later too  this is to
be revisited later, but it's already late)

don't depend on this behaviour yet though

if someone wants to add more regression tests, feel free to
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.117 2007/06/23 22:48:47 tg Exp $
d2160 2
d2665 2
d2831 2
d3345 1
d3372 2
d3419 2
d3436 2
d3637 2
d3655 2
d3707 2
d3957 1
a3957 1
category: pdksh,!os:cygwin
@


1.117
log
@one check seems to fail on ecce!GNU/Linux 1.0  but that is perls fault
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.116 2007/06/22 23:34:40 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/22
d4033 42
@


1.116
log
@implement bash-style array initialisation, as requested by many
still experimental
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.115 2007/06/21 16:04:45 tg Exp $
d3937 1
@


1.115
log
@rewrite some code; bug found by HP's C compiler
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.114 2007/06/17 00:50:07 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/21
d4012 20
@


1.114
log
@make sure that integer and local are defined even in FPOSIX mode, which
is a compromise anyway; these lunox people will have to live with that, too
many existing korn shell alike scripts depend on it even if not on the full
korn shell syntax availability (note: this doesn't mean using these in some
script with #!/bin/sh is ok)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.113 2007/06/15 21:55:18 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/17
@


1.113
log
@ check.t: add some FPOSIX regression tests (1 still fails)
 all: remove vi editing mode #if defined(MKSH_SMALL) || defined(MKSH_NOVI)
  saves 12608 byts on i386
 check.t: add $0 quoting
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.112 2007/06/09 22:02:04 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/15
d3989 1
a3989 1
	Check if set -o posix disables built-in aliases
d3995 3
d4001 1
a4001 1
	Check if running as sh disables built-in aliases
d4008 3
@


1.112
log
@bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.111 2007/06/06 23:28:12 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/09
d3904 6
a3909 6
	$0 -c 'fnord'
	$0 -c 'fnord; fnord; fnord; fnord'
	$0 foo/bar
	$0 <foo/bar
	$0 foo/zoo
	$0 -c 'print : $(fnord)'
d3960 2
a3961 2
	$0 -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
	$0 -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
d3966 40
@


1.111
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.110 2007/06/05 19:48:46 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/06
@


1.110
log
@fix for the SUNpro 8 on yofuh's E420:
cc: Sun C 5.8 Patch 121015-04 2007/01/10
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.109 2007/06/04 21:33:27 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/05
@


1.109
log
@compile warning-free on SUNpro (regression test suite pass) for MirBSD
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.108 2007/05/24 19:50:38 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/06/04
d3958 1
a3958 2
	(unless both MKSH_ASSUME_UTF8 and MKSH_SMALL are set)
category: pdksh
@


1.108
log
@bump vsn, we had a regression
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.107 2007/05/22 19:31:00 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/24
@


1.107
log
@ah, of course, bump the date
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.106 2007/05/21 19:25:30 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/22
@


1.106
log
@ fix the third dramsey scrolling bug for both ^D at BOL and ^W at EOL
  (I hope)
 fix another one I found: after ^D'ing, insert at BOL, the > is displayed
  one character too late
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.105 2007/05/20 17:53:12 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/21
@


1.105
log
@fix the latest appearance of the dramsey backwards movement bug, cf.
Message-ID: <e3fded850705200935h6ac2c9ebgbc7a9b10ac034a49@@mail.gmail.com>
and Message-ID: <Pine.BSM.4.64L.0705201659500.8619@@odem.66h.42h.de>
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.104 2007/05/13 19:18:26 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/20
@


1.104
log
@bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.103 2007/05/10 19:22:10 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/13
@


1.103
log
@a certain size optimisation broke the utf8bom-3 regression test if
mksh was configured to have utf-8 mode always on (because it's
really only always on for interactive shells); setting it to really
always on would break the other half of this regression test, so
do the optimisation only if MKSH_SMALL
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.102 2007/05/10 19:08:47 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/10
@


1.102
log
@fix the dramsey horizontal scrolling bug  time for you to find another 
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.101 2007/04/23 21:46:12 tg Exp $
d3958 1
@


1.101
log
@mksh R29c was indeed broken on HFS+ filesystems thanks to Darwin/Mac OSX
brain-deadness
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.100 2007/04/17 23:51:32 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/04/17
@


1.101.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
 1004638EE466466C614
 100464368A065F40C08
 10046436B6D392D622C
 10046436DC35AC3B04F
 100464370BA2BF5141D
 10046474FB1292DF336
 100464753C139AD7515
 100464755C253EE3EA9
 100464759DE15635029
 10046475DAE4D3D3C05
 100464760593612AAF2
 100464763537E100BDF
 1004647649434DA3FE1
but not
 1004636486176FDA6FF
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.101 2007/04/23 21:46:12 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/13
a3957 1
	(unless both MKSH_ASSUME_UTF8 and MKSH_SMALL are set)
@


1.101.2.2
log
@MFC all the edit.c fixes; bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.101.2.1 2007/05/13 19:29:31 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/22
@


1.101.2.3
log
@pull up fixes for regressions
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.101.2.2 2007/05/22 21:34:28 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/05/24
@


1.101.2.4
log
@MFC:
 some harmless optimisations
 remove the -fno-tree-vrp and -fwhole-program --combine stuff
 fix a typo
 fix check for __attribute__
 remove the multi idstring check, always use ours
 fix signal stuff
 fix types
 pick up arc4random.c
 don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
 some regression test fixes
 fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.101.2.3 2007/05/26 22:31:19 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/07/05
d3904 6
a3909 6
	"$0" -c 'fnord'
	"$0" -c 'fnord; fnord; fnord; fnord'
	"$0" foo/bar
	"$0" <foo/bar
	"$0" foo/zoo
	"$0" -c 'print : $(fnord)'
d3961 2
a3962 2
	"$0" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
	"$0" -c ':; x=$(set +o); if [[ $x = *utf8* ]]; then print on; else print off; fi'
@


1.100
log
@version bump here, too (CR-LF shebang)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.99 2007/04/17 14:00:00 tg Exp $
d1058 1
a1058 1
# breaks on Mac OSX (probably UTF-8 issue)
d3892 2
a3893 1
category: pdksh
@


1.99
log
@GNU/Cygwin32 sucks, as operating environment. Plain sucks.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.98 2007/04/15 12:28:37 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/04/15
@


1.98
log
@if we read an utf-8 BOM, enable the utf8-hack flag (we can test for that on
mirbsd even because the main.c enabling is only run for interactive shells)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.97 2007/04/15 12:09:56 tg Exp $
d3935 2
a3936 1
category: pdksh
@


1.97
log
@ (re)implement shebang execution file parsing; this makes the and which
  do not start with a "#!shell" sequence part of mksh(1) true again; this
  was probably lost in mksh R21 or so when I decided/saw that our kernel
  always parses shebang lines (code written myself, not taken from pdksh
  again or MirBSD kernel, but verified against both)
 bom+shebang execution now works, no need setting EXECSHELL in the test
 bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.96 2007/04/15 10:58:55 tg Exp $
d3953 11
@


1.96
log
@commit a test (which mksh on MirOS BSD currently fails) to test if files
starting with an UTF-8 BOM before the shebang can be executed correctly;
this would succeed if either mksh parses the shebang line instead of re-
lying on $EXECSHELL or the kernel supports it

bsiegert@@ ok's my attempts to fix this
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.95 2007/04/15 10:45:58 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/03/14
d3934 1
a3942 2
	EXECSHELL=$0
	export EXECSHELL
@


1.95
log
@ignore the UTF-8 Byte Order Mark at the beginning of the input (via a file
given to execute, standard input (interactive or not), via -c command line
argument, or after eval, but not for $() comsubs, at the beginning of a
subsequent line, or within a line, etc.); regression test for it

idea during my week off (despite the pain), bsiegert@@ thinks it's good 
and utf-8 capable tools ought to be able to do this anyway
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.94 2007/03/14 02:41:08 tg Exp $
d3931 23
@


1.94
log
@ use wdcopy() not str_save() to duplicate an encoded string, whatever
 prevent out-of-bounds memory access, cought by glibc malloc on IA-64
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.93 2007/03/10 00:42:00 tg Exp $
d3887 44
@


1.93
log
@remove unused utf_width(); bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.92 2007/03/04 03:04:23 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/03/10
@


1.92
log
@ remove strcasestr.c, use home-grown implementation, call it stricmp,
  and have it return an API-correct const char *
 enhance and stylify comments
 a little KNF and simplifications
 #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
 new cstrchr, cstrstr (take and give const char *)
 new vstrchr, vstrstr (take const or not, give boolean value)
 new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
 new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
 replace the only use of strrchr with inlined code to shrink
 minor man page fixes
 Minix 3 signames are autogenerated with gcc
 rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
 dot.mkshrc: move MKSH= down to the export line
  to not disturb the PS1 visual impression 
 dot.mkshrc: Lstripcom(): optimise
 bump version

) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better 

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.91 2007/02/16 17:46:41 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/03/04
@


1.91
log
@* edit.c: when tabcompleting a newline to backslash+newline, this
  sequence is eaten before the command is called; cought by <TGEN>
  (Thomas E. Spanjaard) via IRC
  fix is to tabcomplete a newline to singlequote+newline+singlequote
* bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.90 2007/02/07 02:31:06 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/02/16
@


1.90
log
@bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.89 2007/01/26 18:27:33 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/02/07
@


1.89
log
@if mksh_small don't even support -T instead of ignoring it
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.88 2007/01/18 16:13:29 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/26
@


1.88
log
@history editing seems to work without persistent history sometimes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.87 2007/01/18 16:05:05 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/18
@


1.87
log
@autoscan for persistent history support
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.86 2007/01/18 15:50:32 tg Exp $
d1964 1
a1964 1
category: !no-histfile,!oldish-ed
d1984 1
a1984 1
category: !no-histfile,!oldish-ed
d2011 1
a2011 1
category: !no-histfile,!oldish-ed
@


1.86
log
@header overhaul: replace all #ifdef __OS__ with mirtoconf checks
(except the persistent history one)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.85 2007/01/18 01:10:55 tg Exp $
d1964 1
a1964 2
# we don't have persistent history on Solaris (no flock)
category: !os:solaris,!oldish-ed
d1984 1
a1984 1
category: !os:solaris,!oldish-ed
d2011 1
a2011 1
category: !os:solaris,!oldish-ed
d3862 1
a3862 2
# we don't have persistent history on Solaris (no flock)
category: !os:solaris,!os:plan9,pdksh,!smksh
@


1.85
log
@autoscan for the correct ed(1) type

XXX amend check_categories with stuff like persist history, etc.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.84 2007/01/17 01:24:28 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/17
@


1.84
log
@* Build.sh: add -fwrapv to standard CFLAGS, just to be on the safe
  side (I don't have capacities to scan 71711 files in MirOS for a
  standards-compliance whack)
* copyright: mention CVS changelogs as place of contributors' name
  and credit information, too
* check.t, sh.h: bump
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.83 2007/01/15 00:38:19 tg Exp $
d1879 2
a1880 3
	the character count to stdout. Found on MS Interix/SFU 3.5
	and Mac OSX 10.4 "Tiger".
category: os:interix,os:darwin,os:freebsd
d1902 1
a1902 1
category: os:interix,os:darwin,os:freebsd
d1933 1
a1933 1
category: os:interix,os:darwin,os:freebsd
d1965 1
a1965 1
category: !os:solaris,!os:interix,!os:darwin,!os:freebsd
d1985 1
a1985 1
category: !os:solaris,!os:interix,!os:darwin,!os:freebsd
d2012 1
a2012 1
category: !os:solaris,!os:interix,!os:darwin,!os:freebsd
@


1.83
log
@bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.82 2007/01/12 10:18:19 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/14
@


1.82
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.81 2007/01/12 00:25:39 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/12
@


1.82.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.91 2007/02/16 17:46:41 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/02/16
d1879 3
a1881 2
	the character count to stdout.
category: oldish-ed
d1903 1
a1903 1
category: oldish-ed
d1934 1
a1934 1
category: oldish-ed
d1965 2
a1966 1
category: !oldish-ed
d1986 1
a1986 1
category: !oldish-ed
d2013 1
a2013 1
category: !oldish-ed
d3864 2
a3865 1
category: !no-histfile,pdksh,!smksh
@


1.81
log
@Clean up the signal mess, saves 172 Bytes:
* 'sigseen' in Build.sh goes away
* Signal name existence is checked in this order:
  have our own -> sys_signame[] -> _sys_signame[] -> build our own
* Signal description existence is checked in this order:
  sys_siglist[] -> _sys_siglist[] -> strsignal() -> NULL
 Predefined list of items, for operating systems where we
  cannot build them, i.e. Plan 9 and Minix 3 (e.g. no $CPP -dD)
 The usual cpp(1) stuff
 Changed later, see below
* Make $CPP test dependent on $NEED_MKSH_SIGNAME (others can
  be added here, this is not absolute)
* Make signal name list generation dependent on $NEED_MKSH_SIGNAME
* Fix check if the generation worked
* Guarantee that sigtraps[*].name and sigtraps[*].mess are valid
  C strings; this makes the code shorter *and* removes a few pos-
  sible nil pointer dereferences
* Embed autoconf'd usages of sys_sig* / strsignal / mksh_sigpairs
  into inittraps()
* Check for each signal 0<=i<=NSIG that
  name is not NULL or "" -> replace with ("%d", i)
  mess is not NULL or "" -> replace with ("Signal %d", i)
  name does not start (case-insensitive) with "SIG" -> name += 3
* In gettrap(), fix check if signal name starts, case-sensitive
  or case-insensitive, depending on need, with "SIG" (bug from millert@@)

Other changes:
* Build.sh: ac_test[n]() are documented
* Build.sh: ac_test[n]() can have negative prereqs as well now
* Build.sh: use <<-'EOF' consistently
* bump patchlevel to today
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.80 2007/01/11 02:08:50 tg Exp $
d2229 1
a2229 1
	PS1= # minimize prompt hassles
d3062 1
a3062 1
	Parameter assignments with [] recognized correctly
d3369 1
a3369 1
	uninitialized array elements.
@


1.80
log
@if building a small mksh, don't check for persistent history,
since it's not supported anyway; makes regression tests pass there
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.79 2007/01/11 00:32:30 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/11
@


1.79
log
@expand ~foo to getpwnam("foo")->dir only #if !defined(MKSH_SMALL)
this makes it possible to build a (small) mksh on glibc systems statically
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.78 2007/01/06 17:08:14 tg Exp $
d3865 1
a3865 1
category: !os:solaris,!os:plan9,pdksh
@


1.78
log
@* main.c: prevent segmentation faults on inferiour operating systems
  such as Debian GNU/Linux "etch" 4.0 with not installed locale file
  corresponding to the current environmental settings. !
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.77 2007/01/03 22:43:47 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/06
@


1.77
log
@* main.c: when doing the conversion from strcasecmp (wrongly used)
  to strcasestr, it was used in a wrong way (reverse logic error in
  checking its return value), turning to mis-detection of UTF-8 locale.
* sh.h, check.t: bump version
* copyright: bump year
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.76 2006/12/11 16:09:49 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2007/01/03
@


1.76
log
@this is mksh, benzday edition (2006/12/07)
last code change was on 12/06
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.75 2006/11/19 16:43:41 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2006/12/07
@


1.75
log
@make mksh compatible to the AT&T ksh spec which says, according to
twkm (from #ksh on freenode), that $RANDOM is always an unsigned
15-bit decimal integer.

(RANDOM << 15 | RANDOM) thusly yields 30 bit, which is still more
than 36^5, so we can use it on the baselife CD to speed things up
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.74 2006/11/12 10:44:41 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2006/11/19
@


1.74
log
@only auto-enable set -o utf8-hack (set -U) for interactive shells
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.73 2006/11/10 06:18:05 tg Exp $
d10 1
a10 1
	@@(#)MIRBSD KSH R29 2006/11/12
@


1.73
log
@mark the test that fails ifdef MKSH_SMALL as category:pdksh too,
so people can skip it if they build a small one
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.72 2006/11/10 01:13:50 tg Exp $
d9 9
a3889 9
name: version-1
description:
	Check version of shell.
category: pdksh
stdin:
	echo $KSH_VERSION
expected-stdout:
	@@(#)MIRBSD KSH R29 2006/11/10
---
@


1.72
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.71 2006/11/09 15:02:30 tg Exp $
d3856 1
a3856 1
category: !os:solaris,!os:plan9
@


1.71
log
@get rid of the need of strlcat() altogether (only one use was left)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.70 2006/11/08 23:45:46 tg Exp $
d3868 13
d3888 1
a3888 1
	@@(#)MIRBSD KSH R29 2006/11/09
@


1.70
log
@implement autoconf tests for langstuff; sync date
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.69 2006/11/05 17:01:46 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R29 2006/11/08
@


1.69
log
@make this R29(beta), mksh -U turn on (or setlocale), and document.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.68 2006/11/05 12:11:13 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R29 2006/11/05
@


1.68
log
@add new "set -o utf8-hack", currently no effect
set automatically on startup if we have locale functions (on MirOS)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.67 2006/09/30 02:13:20 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/11/05
@


1.67
log
@* avoid unaligned memory access causing SIGBUS on IA-64 (Itanic)
  (incidentally, the information xor'd now is more random)
  only affects non-arc4random targets
* bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.66 2006/09/21 22:08:26 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/09/30
@


1.66
log
@fix posix-mode-1 test on GNU/Linux:
                grep: write error: Bad file descriptor
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.65 2006/09/07 13:25:14 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/08/28
@


1.65
log
@fgrep on some slowlarisen doesn't know -q
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.64 2006/08/28 17:42:55 tg Exp $
d3798 2
a3799 2
	set +o | fgrep posix >&- && echo posix || echo noposix
	set +o | fgrep braceexpand >&- && echo brex || echo nobrex
d3807 2
a3808 2
	set +o | fgrep posix >&- && echo posix || echo noposix
	set +o | fgrep braceexpand >&- && echo brex || echo nobrex
d3811 2
a3812 2
	set +o | fgrep posix >&- && echo posix || echo noposix
	set +o | fgrep braceexpand >&- && echo brex || echo nobrex
@


1.64
log
@17:38hondza:#mksh so I built new mksh, run tests and got:
17:38hondza:#mksh fail ../mksh/check.t:IFS-space-colon-3 (as expected)
17:38hondza:#mksh FAIL ../mksh/check.t:integer-base-5
17:39<mirabile:#mksh> interesting
17:40<mirabile:#mksh> why does integer-base-5 fail?
17:40hondza:#mksh     j=~3
17:40hondza:#mksh ~3 expands to /tmp/3
17:40<mirabile:#mksh> aah, nice catch
17:40<mirabile:#mksh> that must be quoted of course. bug in the test.
17:41<mirabile:#mksh> can you try with j='~3'
17:41<mirabile:#mksh> I'll commit that in an instant then
17:42hondza:#mksh yeah, quoting it worked
17:42<mirabile:#mksh> thanks
17:42hondza:#mksh :)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.63 2006/08/28 01:40:54 tg Exp $
d3798 2
a3799 2
	set +o | fgrep -q posix && echo posix || echo noposix
	set +o | fgrep -q braceexpand && echo brex || echo nobrex
d3807 2
a3808 2
	set +o | fgrep -q posix && echo posix || echo noposix
	set +o | fgrep -q braceexpand && echo brex || echo nobrex
d3811 2
a3812 2
	set +o | fgrep -q posix && echo posix || echo noposix
	set +o | fgrep -q braceexpand && echo brex || echo nobrex
@


1.63
log
@bump version

our regression tests:
Total failed: 1 (as expected)
Total passed: 213

the IFS testsuite:
# tests 6856 passed 5192 failed 1664
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.62 2006/08/26 20:30:27 tg Exp $
d2353 1
a2353 1
	j=~3
@


1.62
log
@use an autoconf-like approach to check for arc4random(3)
after gecko2 told me his mac recently has it and I found
out that Interix has it in -lcrypt and soon -lmirmake (:
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.61 2006/08/24 20:50:02 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/08/26
@


1.61
log
@regression test for file-based persistent history
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.60 2006/08/24 20:35:40 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/08/24
@


1.60
log
@bump version (hey, after all, I fixed the persistent history*!)
and that after submitting it to the FSF/UNESCO directory...

*) regression test for that? how?
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.59 2006/08/22 22:49:33 tg Exp $
d3852 16
@


1.59
log
@* remove redundancy
* integrate compat.h, version.h into sh.h (dependency trick didn't work anyway)
* mention #ksh in mksh(1) since the founder (twkm) said it's on topic too
  (don't remove mention of #mksh despite it's usually empty because of control)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.58 2006/08/18 13:41:09 tg Exp $
d3859 1
a3859 1
	@@(#)MIRBSD KSH R28 2006/08/22
@


1.58
log
@add a note about why this check can fail
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.57 2006/08/18 13:40:15 tg Exp $
d3859 1
a3859 1
	@@(#)MIRBSD KSH R28 2006/08/18
@


1.57
log
@as long as we're using arc4random(3) to generate $RANDOM,
let it be an uint32_t, like nbsh(1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.56 2006/08/14 20:41:21 tg Exp $
d1396 1
@


1.56
log
@* document the feature-not-bug status of pipeline-subshell-1
* fix spelling in regression test
* expand test-stlt-1 by reverse logic, just to make sure
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.55 2006/08/14 20:36:39 tg Exp $
d3858 1
a3858 1
	@@(#)MIRBSD KSH R28 2006/08/09
@


1.56.2.1
log
@merge diffs between tg-mksh-plan9ape_BASE and current HEAD
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.58 2006/08/18 13:41:09 tg Exp $
a1395 1
	This check can fail on slow machines (<100 MHz), that's normal.
d3858 1
a3858 1
	@@(#)MIRBSD KSH R28 2006/08/18
@


1.56.2.2
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.60 2006/08/24 20:35:40 tg Exp $
a3851 16
name: persist-history-1
description:
	Check if persistent history saving works
# we don't have persistent history on Solaris (no flock)
category: !os:solaris,!os:plan9
arguments: !-i!
env-setup: !ENV=./Env!HISTFILE=hist.file!
file-setup: file 644 "Env"
	PS1=X
stdin:
	cat hist.file
expected-stdout-pattern:
	/cat hist.file/
expected-stderr-pattern:
	/^X*$/
---
d3859 1
a3859 1
	@@(#)MIRBSD KSH R28 2006/08/24
@


1.56.2.3
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.63 2006/08/28 01:40:54 tg Exp $
d3875 1
a3875 1
	@@(#)MIRBSD KSH R28 2006/08/28
@


1.55
log
@check the last command of a pipeline is REALLY executed in a subshell
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.54 2006/08/09 20:44:15 tg Exp $
d3545 1
a3545 1
name: xxx-subsitution-eval-order
d3727 1
a3727 1
name: test-stlt
d3733 2
d3738 2
@


1.54
log
@re-implement "set -o posix" which doesn't do much ;)
but turns off 'braceexpand' when turned on as side effect,
just like oksh/pdksh.
document "set -o sh" too.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.53 2006/08/09 20:21:08 tg Exp $
d3821 26
@


1.53
log
@commit a test for posix mode (turning off braceexpand when turned on)
which mksh doesn't currently pass (oksh passes this test)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.52 2006/08/08 20:17:20 tg Exp $
d3828 1
a3828 1
	@@(#)MIRBSD KSH R28 2006/08/08
@


1.52
log
@remove the 'stuff' functionality altogether,
ksh93 doesn't have it, and I don't know, nor
do I care about what "the BRL ^T mini-systat
feature" is.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.51 2006/08/02 13:34:02 tg Exp $
d3786 35
@


1.51
log
@this is mksh R28 (beta)

I think of implementing multiline editing (bash-style) for R28 final,
but other than that, the new features already suffice for a new major
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.50 2006/08/02 12:38:45 tg Exp $
d3793 1
a3793 1
	@@(#)MIRBSD KSH R28 2006/08/02
@


1.50
log
@some thoughts on the two expected-fail tests
change one from bug to feature
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.49 2006/08/02 11:50:28 tg Exp $
d3793 1
a3793 1
	@@(#)MIRBSD KSH R27 2006/08/02
@


1.49
log
@* Build.sh: fix manpage generation defaults under Cygwin
* mksh.1: rework prompt ($PS1) section, simplify example,
  point to packaged dot.mkshrc example
* mksh.1: fix description of 'redraw' regarding redrawal
  of prompts longer than one screen line
* all: bump version/date
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.48 2006/08/01 12:44:16 tg Exp $
d2113 1
d2119 2
a2120 2
	showargs "$x$@@"
	showargs "$@@$x"
d2123 2
a2124 2
	 <>
	 <>
d2986 2
a2987 1
expected-fail: yes
d2991 4
d2996 1
a2996 1
	hi
@


1.48
log
@bring back the 'version' editing command at "ESC ^V" like AT&T ksh93+r
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.47 2006/07/23 14:35:43 tg Exp $
d3787 1
a3787 1
	@@(#)MIRBSD KSH R27 2006/08/01
@


1.47
log
@dates
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.46 2006/07/11 14:51:00 tg Exp $
d3787 1
a3787 1
	@@(#)MIRBSD KSH R27 2006/07/23
@


1.46
log
@* TNF needs more to silence char subscript warnings (on 3.0-stable)
* bump vsn
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.45 2006/07/07 09:52:20 tg Exp $
d3787 1
a3787 1
	@@(#)MIRBSD KSH R27 2006/07/11
@


1.45
log
@Certain Sourcemage GNU/Linux people like to build (cast?) as root...
adjust regression testsuite so that it doesn't fail w.r.t. $PS1
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.44 2006/07/03 12:16:29 tg Exp $
d3787 1
a3787 1
	@@(#)MIRBSD KSH R27 2006/07/03
@


1.44
log
@fix the "char subscripts" issue, bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.43 2006/06/21 19:27:35 tg Exp $
d3765 2
@


1.43
log
@* process ~/.mksrc only if FTALKING (i.e. interactive shell)
  From: hondza <miscreant@@tiscali.cz>
* document that in the manual page myself
* add regression test for that myself
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.42 2006/05/27 11:36:50 tg Exp $
d3785 1
a3785 1
	@@(#)MIRBSD KSH R27 2006/06/21
@


1.42
log
@we only need to check for error, not for 'error code 1',
that's sufficient for make; Solaris 10 gives us an exit
code of 255 (exit status 65280) here according to Tonnerre
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.41 2006/05/26 23:36:18 tg Exp $
d3741 1
a3741 1
name: mkshrc-2
d3744 1
a3744 1
	Part 2: verify mkshrc can be read
d3751 13
d3785 1
a3785 1
	@@(#)MIRBSD KSH R27 2006/05/26
@


1.41
log
@this is mksh R27, tested on
* MirOS HEAD (i386, gcc 3.4)
* Debian GNU/Linux 3.1 (i386, gcc 3.3)
* Interix 3.5 (i386, gcc 3.3) - perl too old for regression tests
* GNU/Cygwin 2006-03-* (i386, gcc 3.4) - no perl installed
* Solaris 8 (sparc64, gcc 3.4)

no testing been done on
* Mac
* other BSDs
* gcc 4.1.1
* Solaris 10
because I asked for community feedback but...
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.40 2006/05/10 19:30:32 tg Exp $
d3719 1
a3719 1
expected-exit: 1
@


1.40
log
@* this is almost mksh R27, bump
* add the O'Reilly books as references
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.39 2006/05/08 11:59:41 tg Exp $
d3772 1
a3772 1
	@@(#)MIRBSD KSH R27 2006/05/10
@


1.39
log
@* check.t: add two mkshrc-tests (turn on, turn off)
* check.pl, check.t: add mkshrc-test whether "real" $HOME/.mkshrc interfers
* mksh.1: sync with reality: $ENV unset isn't needed, $ENV='' is enough
  to turn on ~/.mkshrc processing
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.38 2006/05/08 11:42:36 tg Exp $
d3772 1
a3772 1
	@@(#)MIRBSD KSH R26 2006/05/08
@


1.38
log
@New feature: read ~/.mkshrc during startup, after the profiles
have been read, for non-priviledgued shells only. If $ENV is
set, ~/.mkshrc is ignored (even if the file pointed to by $ENV
does not exist in the first place).
Feature requested by Jari Aalto for portable mksh because some
operating systems' vendors do not allow touching the profile.

Initial diff and manual page addition by Jari Aalto <jari.aalto@@cante.net>
Code changes and manual page correctness by me.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.37 2006/01/29 20:56:54 tg Exp $
d3732 33
@


1.37
log
@this can be released as mksh-R26c, works on Solaris, Interix (whose Perl
is too old for the testsuite), Debian and of course MirOS
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.36 2005/11/22 18:40:40 tg Exp $
d3739 1
a3739 1
	@@(#)MIRBSD KSH R26 2006/01/29
@


1.36
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.35 2005/11/22 18:36:19 tg Exp $
d3739 1
a3739 1
	@@(#)MIRBSD KSH R26 2005/11/22
@


1.35
log
@Change interpretation of '\"' in here documents with substitution
according to SUSv3 and other modern shells (POSIX allows both).
Idea for the patch (add another lex state) from OpenBSD, but the
implementation differs slightly (and is better in quality).

Also add two testcases (/bin/sh passes both, old mksh only one),
and document the change in the manual page. Sync RCS IDs with OBSD.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.34 2005/10/25 21:11:25 tg Exp $
d3739 1
a3739 1
	@@(#)MIRBSD KSH R25 2005/10/25
@


1.34
log
@bump to mksh R25
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.33 2005/10/21 12:41:54 tg Exp $
d1217 24
@


1.33
log
@follow OpenBSD and add mknod as mksh builtin (mknod <file> p acts as mkfifo)
but write a good chunk of that code myself (better structured, better error
handling, more gotos, less function calls, int -> bool)

passes all tests on mirbsd; this will become mksh R25 once tested on other
supported OSes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.32 2005/10/08 19:30:58 tg Exp $
d3715 1
a3715 1
	@@(#)MIRBSD KSH R24 2005/10/21
@


1.32
log
@our test(1) promises we can do string1 < string2, and
our /bin/test uses mksh... so we pee (literally) on
POSIX and don't accept < and > only for [[ ... ]] operator
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.31 2005/10/08 18:53:09 tg Exp $
d3715 1
a3715 1
	@@(#)MIRBSD KSH R24 2005/10/08
@


1.31
log
@* bump version
* disable DEBUGPROGS
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.30 2005/09/11 00:32:29 tg Exp $
d3697 11
@


1.30
log
@revert to R24b since we don't printf ATM
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.28 2005/08/21 13:02:16 tg Exp $
d3704 1
a3704 1
	@@(#)MIRBSD KSH R24 2005/08/21
@


1.29
log
@* add printf(1) as mksh(1) builtin on MirOS
  (or, more general, all systems using Makefile
  instead of Build.sh)
* document this fact
@
text
@d3704 1
a3704 1
	@@(#)MIRBSD KSH R25 2005/08/26 pre
@


1.28
log
@* make 64-bit clean on GNU/Linux by default
* clean up and remove some .Xr from the man page
* bump version
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.27 2005/08/02 12:35:25 tg Exp $
d3704 1
a3704 1
	@@(#)MIRBSD KSH R24 2005/08/21
@


1.27
log
@^V now is quote, not version, even in emacs mode. (From OpenBSD.)
Also, the "version" command got removed in its entirety.
Shaves off another global variable, even.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.26 2005/07/07 23:27:52 tg Exp $
d3704 1
a3704 1
	@@(#)MIRBSD KSH R24 2005/08/02
@


1.26
log
@* move <sys/param.h> include to sh.h
* fix compilation and invocation of test suite with whitespace in
  the pathnames for real, this time
* clean up (especially whitespace)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.25 2005/07/07 22:00:45 tg Exp $
d3704 1
a3704 1
	@@(#)MIRBSD KSH R24 2005/07/07
@


1.25
log
@undo fix for Debian PR #71256 which turned to be bogus and break make(1)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.24 2005/07/06 00:02:05 tg Exp $
d225 1
a225 1
stdin: 
d448 1
a448 1
stdin: 
d458 1
a458 1
stdin: 
d473 1
a473 1
stdin: 
d490 1
a490 1
stdin: 
d1085 1
a1085 1
	cat << EOF1 << EOF2 
d1137 1
a1137 1
stdin: 
d1163 1
a1163 1
stdin: 
d1179 1
a1179 1
stdin: 
d1199 1
a1199 1
stdin: 
d2877 1
a2877 1
	echo 1: ${x-x not set} ${y-y not set} ${z-z not set} 
d2924 1
a2924 1
	(echo abcdef; echo; echo 123) | 
d2952 1
a2952 1
	while false; do echo hi; done 
d3069 1
a3069 1
	TMPDIR=$PWD/foo $0 <<- 'EOF'
d3082 1
a3082 1
	TMPDIR=$PWD/foo $0 <<- 'EOF'
d3130 1
a3130 1
expected-stdout: 
d3144 1
a3144 1
expected-stdout: 
d3161 1
a3161 1
expected-stdout: 
d3230 1
a3230 1
expected-stdout: 
d3273 1
a3273 1
expected-stdout: 
d3290 1
a3290 1
expected-stdout: 
d3318 1
a3318 1
expected-stdout: 
d3342 1
a3342 1
expected-stdout: 
d3358 1
a3358 1
expected-stdout: 
d3368 1
a3368 1
expected-stdout: 
d3381 1
a3381 1
expected-stdout: 
d3396 1
a3396 1
expected-stdout: 
d3414 1
a3414 1
expected-stdout: 
@


1.24
log
@remove Korn's bizarre /dev/fd hack
(only affects Interix!)

Tests on /dev/fd are now officially unsupported in mksh too.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.23 2005/07/05 21:48:42 tg Exp $
d3684 1
a3684 1
	Check some "exit on error" edge conditions
a3691 1
	END
d3695 1
a3695 1
	+ echo END
d3704 1
a3704 1
	@@(#)MIRBSD KSH R24 2005/07/06
@


1.23
log
@(this commit on an "AMD Sempron 2200+ (1.5GHz), 2x 256MB PC3200 DDR
 (running at PC2700 speed), some Maxtor 80GB 2MB 7200rpm drive" box running
 DragonFly draco.osr.netphreax.net 1.3-Preview DragonFly 1.3-Preview #0: Wed Apr 13 13:57:37 CEST 2005     root@@chlamydia.fs.ei.tum.de:/usr/obj/usr/src/sys/GENERIC  i386

DragonFly BSD is now officially supported
Thanks to Thomas E. Spanjaard for providing a testing environment.

This might fix or break FreeBSD support, who knows...
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.22 2005/07/04 12:48:12 tg Exp $
a3172 2
	#!/bin/ksh
	
d3705 1
a3705 1
	@@(#)MIRBSD KSH R24 2005/07/04
@


1.22
log
@more notes about a known fail
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.21 2005/07/04 12:47:13 tg Exp $
d1847 1
a1847 1
category: os:interix,os:darwin
d1869 1
a1869 1
category: os:interix,os:darwin
d1900 1
a1900 1
category: os:interix,os:darwin
d1932 1
a1932 1
category: !os:solaris,!os:interix,!os:darwin
d1952 1
a1952 1
category: !os:solaris,!os:interix,!os:darwin
d1979 1
a1979 1
category: !os:solaris,!os:interix,!os:darwin
@


1.21
log
@clean up code
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.20 2005/07/04 12:27:25 tg Exp $
d2960 1
a2960 1
	Not clear if they should be or not...
@


1.20
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.19 2005/07/04 11:57:55 tg Exp $
d3707 1
a3707 1
	@@(#)MIRBSD KSH R23 2005/07/04
@


1.19
log
@mksh no longer looks at its own called name or $SHELL
to determine if it should be a restricted shell
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.18 2005/06/24 15:42:03 tg Exp $
d3640 2
a3641 1
	ksh88, Solaris /bin/sh and /usr/xpg4/bin/sh all print the error?!
d3647 5
a3651 2
expected-fail: yes
expected-stderr-pattern: !/not set/
d3665 1
a3665 1
	set -o posix
@


1.18
log
@date of today
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.17 2005/06/08 21:51:20 tg Exp $
d3703 1
a3703 1
	@@(#)MIRBSD KSH R23 2005/06/24
@


1.17
log
@* major revamp of build system
* whitespace cleanup; junk comment removal
* syndicate debian/copyright file from my port (shrinks sh.h)
* bump to R23
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.16 2005/06/05 16:38:19 tg Exp $
d3703 1
a3703 1
	@@(#)MIRBSD KSH R23 2005/06/08
@


1.16
log
@mksh R22d
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.15 2005/05/28 21:02:02 tg Exp $
d6 2
a7 36
# Some information on tests:
# The bksl-nl tests deal with how \newline is handled in various situa-
#  tions. The first group of tests are places where it shouldn't be col-
#  lapsed, the next group tests are places where it should be collapsed.
# In history - Not tested yet:
#	- commands in history file are not numbered negatively
#  (and a few hundred other things)
#  You may also want to test IFS with the script at
#  http://www.research.att.com/~gsf/public/ifs.sh
# Read - To test:
#   POSIX:
#	- if no -r, \ is escape character
#	    - \newline disappear
#	    - \<IFS> -> don't break here
#	    - \<anything-else> -> <anything-else>
#	- if -r, backslash is not special
#	- if stdin is tty and shell interactive
#	    - prompt for continuation if \newline (prompt to stderr)
#	    - a here-document isn't terminated after newline ????
#	- remaining vars set to empty string (not null)
#	- check field splitting
#	- left over fields and their separators assigned to last var
#	- exit status is normally 0
#	- exit status is > 0 on eof
#	- exit status > 0 on error
#	- signals interrupt reads
#   extra:
#	- can't change read-only variables
#	- error if var name bogus
#	- set -o allexport effects read
# ksh:
#	x check default variable: REPLY
#	- check -p, -s, -u options
#	- check var?prompt stuff
#	- "echo a b | read x y" sets x,y in parent shell (at&t)
# Regression: The first 39 of these tests are from the old Bugs script.
d3703 1
a3703 1
	@@(#)MIRBSD KSH R22 2005/06/05
@


1.15
log
@main.c: need <time.h> if not HAVE_ARC4RANDOM
strlfun.c: sync

found while creating debian source package

main.c, check.t: mksh R22c
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.14 2005/05/25 14:39:33 tg Exp $
d3737 1
a3737 1
	@@(#)MIRBSD KSH R22 2005/05/28
@


1.14
log
@some more checks for debian bugtracker items
the rest is just "ksh is not bash, I want it so!" and similar stupidness
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.13 2005/05/25 14:20:53 tg Exp $
d3737 1
a3737 1
	@@(#)MIRBSD KSH R22 2005/05/25
@


1.13
log
@add regression test for our 'posix-ish' tilde mode
(well, ours IS allowed by posix, but...)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.12 2005/05/25 13:50:15 tg Exp $
d3701 29
@


1.12
log
@surprising results
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.11 2005/05/25 11:37:23 tg Exp $
d3689 12
@


1.11
log
@mksh R22 (beta)
not yet released
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.10 2005/05/23 17:24:23 tg Exp $
d3674 1
@


1.10
log
@* Mac OSX 10.4 "Tiger"
	- has an antiquated ed(1)
	  (I'm lucky it has one, some GNU/Linux don't...)
	- cannot build mksh statically linked
* Solaris (SunOS 5.8)
	- needs libdl when statically linked (NSSwitch problem)
	- /bin/sh is not XPG.4 compatible, don't use test -e
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.9 2005/05/23 17:00:24 tg Exp $
d3695 1
a3695 1
	@@(#)MIRBSD KSH R21 2005/05/23
@


1.9
log
@whitespace is belangrijk
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.8 2005/05/23 16:23:18 tg Exp $
d1879 3
a1881 2
	the character count to stdout. Found on MS Interix/SFU 3.5.
category: os:interix
d1903 1
a1903 1
category: os:interix
d1934 1
a1934 1
category: os:interix
d1966 1
a1966 1
category: !os:solaris,!os:interix
d1986 1
a1986 1
category: !os:solaris,!os:interix
d2013 1
a2013 1
category: !os:solaris,!os:interix
@


1.8
log
@aaaand: Interix.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.7 2005/05/23 16:17:00 tg Exp $
d1965 1
a1965 1
category: !os:solaris, !os:interix
d1985 1
a1985 1
category: !os:solaris, !os:interix
d2012 1
a2012 1
category: !os:solaris, !os:interix
@


1.7
log
@bring back old-ed(1) history-ed tests, for MS Interix
no comment...
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.6 2005/05/23 15:54:30 tg Exp $
d1878 2
a1879 1
	that prints no prompts).
d1931 1
a1931 1
	(NOTE: will fail if using COMPLEX HISTORY compile time option)
d1956 1
a1956 1
		echo a new line
d1963 1
a1963 1
	that prints no prompts).
a2011 2
	(NOTE: adapted for COMPLEX HISTORY compile time option)
	(ksh88 fails 'cause it lists the fc command)
@


1.6
log
@now passes on Solaris (-Wall -W -Wno-char-subscripts) too
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.5 2005/05/23 15:03:04 tg Exp $
d1875 84
d1964 1
a1964 1
category: !os:solaris
d1984 1
a1984 1
category: !os:solaris
d2013 1
a2013 1
category: !os:solaris
@


1.5
log
@we don't support OS/2 anyway (a pity)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.4 2005/05/23 15:02:04 tg Exp $
d1879 2
d1900 1
d1929 1
d3611 1
a3611 1
	@@(#)MIRBSD KSH R21
@


1.4
log
@* adapt the three history-ed tests to a modern ed(1) which prints the
  number of characters to stderr not stdout
* fix the history-ed-3 test to check for COMPLEX HISTORY option instead
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.3 2005/05/23 14:48:21 tg Exp $
a713 2
# Fails on OS/2, since directory names are prepended with drive letter.
category: !os:os2
a1038 1
category: !os:os2
a1878 2
# No ed on os/2 (yet?).
category: !os:os2
a1897 1
category: !os:os2
a1925 1
category: !os:os2
a3429 2
# Under os/2, _emx_sig environment variable changes.
category: !os:os2
@


1.3
log
@fix running of all tests
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.2 2005/05/23 14:07:40 tg Exp $
a1895 2
	13
	16
d1898 1
a1898 1
	/^X*echo FOOBAR def\nX*$/
a1921 2
	20
	23
d1924 1
a1924 1
	/^X*echo line 2 is changed\nX*$/
d1930 1
a1930 1
	(NOTE: will fail if using COMPLEX HISTORY compile time option)
a1948 2
	13
	32
d1953 1
a1953 1
		echo a new line
d1955 1
a1955 1
	/^X*echo FOOBAR def\necho a new line\nX*$/
@


1.2
log
@prevent Mac OSX from executing the test which crashes its perl
(still valid for Tiger)

with that, mksh R21 works on it (no build script yet, sorry)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.t,v 1.1 2005/05/23 03:06:05 tg Exp $
d1084 2
a1087 2
description:
	Check that globbing matches the right things...
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
# $MirOS: mksh/tests/alias.t,v 1.3 2005/05/23 02:27:31 tg Exp $
d1084 2
@
