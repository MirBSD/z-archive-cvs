head	1.106;
access;
symbols
	mksh-R57:1.105
	mksh-R56c:1.103
	mksh-R56b:1.100
	mksh-R56:1.100
	mksh-R55:1.93
	mksh-R54:1.90
	mksh-R53a:1.88
	mksh-R53:1.88
	mksh-R52c:1.83
	mksh-R52b:1.81
	mksh-R52:1.80
	mksh-R51:1.77
	mksh-R50f:1.76.2.1
	mksh-R50e:1.76.2.1
	mksh-R50stable:1.76.0.2
	mksh-R50d:1.76
	mksh-R50c:1.76
	mksh-R50b:1.76
	mksh-R50:1.76
	mksh-R49:1.75
	mksh-R48b:1.72
	mksh-R48:1.72
	mksh-R47:1.72
	mksh-R46:1.70
	mksh-R45:1.70
	mksh-R44:1.61
	mksh-R43:1.61
	mksh-R42b:1.61
	mksh-R41c:1.60.2.1
	mksh-R41b:1.60
	mksh-R42:1.60
	mksh-R41:1.60
	mksh-R41stable:1.60.0.2
	mksh-wheezy:1.58.0.2
	tg-multikey-bind:1.56.0.2
	mksh-R40f:1.51.2.2
	mksh-R40e:1.51.2.1
	mksh-R40d:1.51
	mksh-R40c:1.49
	mksh-R40b:1.47
	mksh-R40stable:1.51.0.2
	mksh-R40:1.47
	mksh-R39c:1.43
	mksh-R39b:1.43
	tg-wcswidth-behaviour:1.37.0.2
	tg-nameref:1.33.0.2
	mksh-R39:1.29
	tg-mksh-printf-builtin:1.29.0.2
	mksh-R38c:1.29
	mksh-R38b:1.26
	mksh-R38:1.26
	mksh-R37c:1.24
	mksh-R37b:1.23
	mksh-R37:1.23
	mksh-R36b:1.21
	tg-aalloc-experimental_BASE:1.20
	tg-aalloc-experimental:1.20.0.2
	mksh-R36:1.18
	mksh-R35b:1.18
	mksh-R35:1.17
	mksh-R33d:1.14
	mksh-R33c:1.14
	mksh-R33b:1.14
	MIRBSD_10:1.13.0.2
	MIRBSD_10_BASE:1.13
	mksh-R33:1.13
	mksh-R32:1.13
	mksh-R31d:1.12
	mksh-R31c:1.12
	mksh-R31b:1.12
	mksh-R31:1.12
	mksh-R30:1.12
	mksh-R29g:1.10
	mksh-R29f:1.10
	mksh-R29e:1.10
	mksh-R29stable:1.10.0.2
	mksh-R29d:1.10
	mksh-R29c:1.10
	mksh-R29b:1.10
	mksh-R29:1.10
	mksh-R28:1.4
	tg-mksh-plan9ape_BASE:1.4
	tg-mksh-plan9ape:1.4.0.2
	mksh-R27e:1.4
	MIRBSD_9_BASE:1.4
	mksh-R27d:1.4
	mksh-R27:1.4
	mksh-R26c:1.3
	mksh-R26b:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	mksh-R26:1.3
	mksh-R25:1.2
	mksh-R24c:1.1
	mksh-R24b:1.1
	mksh-R24:1.1
	mksh-R23:1.1
	mksh-R22:1.1
	mksh-R21:1.1;
locks; strict;
comment	@ * @;


1.106
date	2019.12.11.20.04.50;	author tg;	state Exp;
branches;
next	1.105;
commitid	1005DF14BD96C1B67D9;

1.105
date	2018.08.10.02.53.33;	author tg;	state Exp;
branches;
next	1.104;
commitid	1005B6CFE0B5BDFE404;

1.104
date	2018.06.26.21.22.21;	author tg;	state Exp;
branches;
next	1.103;
commitid	1005B32AE7D3C0B22EA;

1.103
date	2018.01.14.01.29.47;	author tg;	state Exp;
branches;
next	1.102;
commitid	1005A5AB29D07E6066B;

1.102
date	2018.01.13.23.55.10;	author tg;	state Exp;
branches;
next	1.101;
commitid	1005A5A9C627E45C2B1;

1.101
date	2017.11.18.12.01.53;	author tg;	state Exp;
branches;
next	1.100;
commitid	1005A1021487DBB486A;

1.100
date	2017.08.07.21.38.55;	author tg;	state Exp;
branches;
next	1.99;
commitid	1005988DDE03C3E8F11;

1.99
date	2017.07.08.15.11.52;	author tg;	state Exp;
branches;
next	1.98;
commitid	1005960F5F93CD53417;

1.98
date	2017.05.05.22.53.28;	author tg;	state Exp;
branches;
next	1.97;
commitid	100590D026845CD3DFF;

1.97
date	2017.05.05.20.36.02;	author tg;	state Exp;
branches;
next	1.96;
commitid	100590CE24264B3D492;

1.96
date	2017.04.27.23.12.46;	author tg;	state Exp;
branches;
next	1.95;
commitid	10059027AFC0DEF48C9;

1.95
date	2017.04.27.20.22.24;	author tg;	state Exp;
branches;
next	1.94;
commitid	1005902531266D3FCB6;

1.94
date	2017.04.27.19.33.48;	author tg;	state Exp;
branches;
next	1.93;
commitid	100590247A92C66CAF9;

1.93
date	2017.04.02.16.47.41;	author tg;	state Exp;
branches;
next	1.92;
commitid	10058E12B3D7E04D5CE;

1.92
date	2017.04.02.15.00.42;	author tg;	state Exp;
branches;
next	1.91;
commitid	10058E1121E64BBAB7B;

1.91
date	2017.03.26.00.10.23;	author tg;	state Exp;
branches;
next	1.90;
commitid	10058D706207E0A1FF4;

1.90
date	2016.11.07.16.58.48;	author tg;	state Exp;
branches;
next	1.89;
commitid	1005820B2DD17077C51;

1.89
date	2016.09.01.12.55.21;	author tg;	state Exp;
branches;
next	1.88;
commitid	10057C825090042F66C;

1.88
date	2016.07.27.00.55.27;	author tg;	state Exp;
branches;
next	1.87;
commitid	100579806802F9D6BB9;

1.87
date	2016.07.25.20.41.23;	author tg;	state Exp;
branches;
next	1.86;
commitid	1005796798377E704E1;

1.86
date	2016.07.25.00.04.42;	author tg;	state Exp;
branches;
next	1.85;
commitid	1005795579F14A3FE5C;

1.85
date	2016.05.05.22.56.13;	author tg;	state Exp;
branches;
next	1.84;
commitid	100572BCF9760C8313C;

1.84
date	2016.05.05.21.33.46;	author tg;	state Exp;
branches;
next	1.83;
commitid	100572BBC4A4629BADB;

1.83
date	2016.03.01.18.29.38;	author tg;	state Exp;
branches;
next	1.82;
commitid	10056D5DFAC55DEFD63;

1.82
date	2016.02.26.18.48.12;	author tg;	state Exp;
branches;
next	1.81;
commitid	10056D09DEF7B46FCA2;

1.81
date	2016.01.14.21.17.50;	author tg;	state Exp;
branches;
next	1.80;
commitid	1005698108D6AC95167;

1.80
date	2015.11.29.17.05.00;	author tg;	state Exp;
branches;
next	1.79;
commitid	100565B305567B17D70;

1.79
date	2015.10.24.19.45.23;	author tg;	state Exp;
branches;
next	1.78;
commitid	100562BDFBA097EA04B;

1.78
date	2015.09.05.19.19.03;	author tg;	state Exp;
branches;
next	1.77;
commitid	10055EB402C54C3076B;

1.77
date	2014.12.15.23.26.36;	author tg;	state Exp;
branches;
next	1.76;
commitid	100548F6E3443B3D986;

1.76
date	2014.06.24.19.53.19;	author tg;	state Exp;
branches
	1.76.2.1;
next	1.75;
commitid	10053A9D73D46F13830;

1.75
date	2014.01.05.21.57.26;	author tg;	state Exp;
branches;
next	1.74;
commitid	10052C9D445413B34DF;

1.74
date	2014.01.05.19.11.44;	author tg;	state Exp;
branches;
next	1.73;
commitid	10052C9AE727A4482D3;

1.73
date	2013.11.30.23.20.03;	author tg;	state Exp;
branches;
next	1.72;
commitid	100529A72B0084FADD6;

1.72
date	2013.07.21.18.38.56;	author tg;	state Exp;
branches;
next	1.71;
commitid	10051EC2ACD697CBF6B;

1.71
date	2013.05.31.23.27.13;	author tg;	state Exp;
branches;
next	1.70;
commitid	10051A931CB73794C1D;

1.70
date	2013.04.26.19.10.58;	author tg;	state Exp;
branches;
next	1.69;
commitid	100517AD14E22C17EA0;

1.69
date	2013.04.14.13.36.50;	author tg;	state Exp;
branches;
next	1.68;
commitid	100516AAFB97CDEA9BA;

1.68
date	2013.04.01.02.37.49;	author tg;	state Exp;
branches;
next	1.67;
commitid	1005158F2D44922CF13;

1.67
date	2013.04.01.02.28.35;	author tg;	state Exp;
branches;
next	1.66;
commitid	1005158EFDD67D1648A;

1.66
date	2013.04.01.01.29.47;	author tg;	state Exp;
branches;
next	1.65;
commitid	1005158E3247D0B39EE;

1.65
date	2013.04.01.01.16.37;	author tg;	state Exp;
branches;
next	1.64;
commitid	1005158DFEE1ED14734;

1.64
date	2013.04.01.01.02.09;	author tg;	state Exp;
branches;
next	1.63;
commitid	1005158DC9E3123AC04;

1.63
date	2013.03.31.18.33.13;	author tg;	state Exp;
branches;
next	1.62;
commitid	100515881203049B1AD;

1.62
date	2013.03.29.16.54.05;	author tg;	state Exp;
branches;
next	1.61;
commitid	1005155C7453F6D06A4;

1.61
date	2013.02.15.18.36.48;	author tg;	state Exp;
branches;
next	1.60;
commitid	100511E80597C703B9A;

1.60
date	2012.10.03.17.24.19;	author tg;	state Exp;
branches
	1.60.2.1;
next	1.59;
commitid	100506C74D35719B33B;

1.59
date	2012.09.01.23.46.41;	author tg;	state Exp;
branches;
next	1.58;
commitid	10050429E542CD63CF1;

1.58
date	2012.06.28.20.17.36;	author tg;	state Exp;
branches
	1.58.2.1;
next	1.57;
commitid	1004FECBBF10FC5C93C;

1.57
date	2012.06.28.20.02.27;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004FECB86B79975962;

1.56
date	2012.03.31.17.52.33;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004F77445B556D9339;

1.55
date	2012.03.31.17.29.59;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004F773F2D0016E021;

1.54
date	2012.03.29.19.22.58;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004F74B525291EF6DE;

1.53
date	2011.12.31.02.04.18;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004EFE6D783E94B328;

1.52
date	2011.12.16.20.03.02;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004EEBA40D2D986470;

1.51
date	2011.12.11.01.56.43;	author tg;	state Exp;
branches
	1.51.2.1;
next	1.50;
commitid	1004EE40DDD498FBB0D;

1.50
date	2011.12.11.01.35.10;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004EE408E1382C1752;

1.49
date	2011.09.07.15.24.14;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004E678C6929FE60A6;

1.48
date	2011.08.27.18.06.44;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004E5932432420AA61;

1.47
date	2010.12.11.16.05.03;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004D03A10A2DDE9B9B;

1.46
date	2010.11.01.17.28.49;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004CCEF8E76693F669;

1.45
date	2010.08.28.18.50.50;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004C795A82072326AF;

1.44
date	2010.08.14.21.35.13;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004C670C171B08A36C;

1.43
date	2010.01.25.14.38.00;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004B5DACDC357C3689;

1.42
date	2009.12.12.22.27.06;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004B2418AF282F4231;

1.41
date	2009.12.08.19.23.34;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004B1EA7943132FFB1;

1.40
date	2009.12.05.20.17.58;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004B1ABFF06BA6261A;

1.39
date	2009.11.28.14.28.00;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004B11334F4604E973;

1.38
date	2009.11.28.14.21.44;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004B1131E93EDF1403;

1.37
date	2009.10.04.13.19.33;	author tg;	state Exp;
branches
	1.37.2.1;
next	1.36;
commitid	1004AC8A0EC1AB8E5E0;

1.36
date	2009.09.26.04.01.32;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004ABD92036DD32E15;

1.35
date	2009.09.23.18.04.55;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004ABA62C8171BD8E4;

1.34
date	2009.09.06.17.55.54;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004AA3F6E1614843D5;

1.33
date	2009.08.28.21.01.25;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004A9845725143AD02;

1.32
date	2009.08.28.20.38.41;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004A98405B0186F15C;

1.31
date	2009.08.28.20.30.55;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004A983E6B745731A0;

1.30
date	2009.08.08.13.08.50;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004A7D785D73D49CFA;

1.29
date	2009.06.10.18.12.45;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004A2FF7913BD44883;

1.28
date	2009.06.08.20.13.07;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004A2D70D20F3D475C;

1.27
date	2009.06.08.20.06.45;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004A2D6F3A31FB4CBC;

1.26
date	2009.05.16.16.59.35;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004A0EF0664EF4168D;

1.25
date	2009.05.16.15.09.07;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004A0ED7131FB6A76E;

1.24
date	2009.04.07.18.41.35;	author tg;	state Exp;
branches;
next	1.23;
commitid	10049DB9E493037411A;

1.23
date	2009.03.14.18.12.52;	author tg;	state Exp;
branches;
next	1.22;
commitid	10049BBF38A0ADEDD54;

1.22
date	2008.12.17.19.39.21;	author tg;	state Exp;
branches;
next	1.21;
commitid	100494955754640680F;

1.21
date	2008.12.13.17.02.13;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004943EAA830C0300B;

1.20
date	2008.11.12.00.54.48;	author tg;	state Exp;
branches
	1.20.2.1;
next	1.19;
commitid	100491A295841A6D8EB;

1.19
date	2008.10.28.14.32.40;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004907226D3DEFCCD1;

1.18
date	2008.07.12.16.56.38;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004878E22B104A657A;

1.17
date	2008.04.20.00.24.25;	author tg;	state Exp;
branches;
next	1.16;
commitid	100480A8D4556C8D90D;

1.16
date	2008.04.19.23.49.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	100480A853206FB56FA;

1.15
date	2008.04.19.22.15.02;	author tg;	state Exp;
branches;
next	1.14;
commitid	100480A6CC85EC0197B;

1.14
date	2008.03.28.13.33.37;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047ECF3B77422FB05;

1.13
date	2007.10.25.15.19.16;	author tg;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	1004720B40258F7886E;

1.12
date	2007.07.22.14.01.48;	author tg;	state Exp;
branches;
next	1.11;
commitid	10046A36344350ACD7B;

1.11
date	2007.07.22.13.34.49;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046A35CEC35BB7B5F;

1.10
date	2007.03.04.03.04.25;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045EA374B3374AB35;

1.9
date	2007.03.03.21.12.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045E9E4E402C0B477;

1.8
date	2007.01.17.22.51.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045AEA86F7FE51B97;

1.7
date	2007.01.12.01.49.27;	author tg;	state Exp;
branches
	1.7.2.1;
next	1.6;
commitid	10045A6E8B92FCAC95A;

1.6
date	2006.11.10.07.52.02;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045542F8269E05F56;

1.5
date	2006.11.10.07.18.57;	author tg;	state Exp;
branches;
next	1.4;
commitid	100455427B90A1F6E32;

1.4
date	2006.05.10.18.54.10;	author tg;	state Exp;
branches;
next	1.3;
commitid	100446236E6726083C8;

1.3
date	2005.11.22.18.40.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	108a438366254326;

1.2
date	2005.10.25.19.53.27;	author tg;	state Exp;
branches;
next	1.1;
commitid	76cc435e8d34d8ce;

1.1
date	2005.05.23.03.06.07;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.76.2.1
date	2015.01.25.15.44.05;	author tg;	state Exp;
branches;
next	;
commitid	10054C50F46587DFA27;

1.60.2.1
date	2013.02.15.18.54.42;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.58.2.1
date	2012.09.03.19.10.41;	author tg;	state Exp;
branches;
next	1.58.2.2;
commitid	100504500CA4123EFA6;

1.58.2.2
date	2013.02.15.18.54.53;	author tg;	state Exp;
branches;
next	;
commitid	100511E84805BFD4FAE;

1.51.2.1
date	2011.12.31.02.25.28;	author tg;	state Exp;
branches;
next	1.51.2.2;
commitid	1004EFE72A268DB0925;

1.51.2.2
date	2012.04.06.14.40.17;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.37.2.1
date	2009.11.28.14.27.50;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.20.2.1
date	2008.11.22.13.20.28;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.13.2.1
date	2008.04.22.13.29.25;	author tg;	state Exp;
branches;
next	1.13.2.2;
commitid	100480DE80F32BAA72D;

1.13.2.2
date	2008.05.19.18.41.23;	author tg;	state Exp;
branches;
next	1.13.2.3;
commitid	1004831C9A63DA06745;

1.13.2.3
date	2008.07.18.13.29.43;	author tg;	state Exp;
branches;
next	1.13.2.4;
commitid	10048809AD278B142AC;

1.13.2.4
date	2008.12.14.00.07.40;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.7.2.1
date	2007.03.03.21.37.55;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;


desc
@@


1.106
log
@prepare for ksh{,e}[ug]id change:

the kshe[ug]id value will be the active, while ksh[ug]id will cache the one
from startup, to allow returning to it
@
text
@/*	$OpenBSD: expr.c,v 1.24 2014/12/08 14:26:31 otto Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2016, 2017, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.104 2018/06/26 21:22:21 tg Exp $");

#define EXPRTOK_DEFNS
#include "exprtok.h"

/* precisions; used to be enum prec but we do arithmetics on it */
#define P_PRIMARY	0	/* VAR, LIT, (), ! ~ ++ -- */
#define P_MULT		1	/* * / % */
#define P_ADD		2	/* + - */
#define P_SHIFT		3	/* ^< ^> << >> */
#define P_RELATION	4	/* < <= > >= */
#define P_EQUALITY	5	/* == != */
#define P_BAND		6	/* & */
#define P_BXOR		7	/* ^ */
#define P_BOR		8	/* | */
#define P_LAND		9	/* && */
#define P_LOR		10	/* || */
#define P_TERN		11	/* ?: */
	/* = += -= *= /= %= ^<= ^>= <<= >>= &= ^= |= */
#define P_ASSIGN	12
#define P_COMMA		13	/* , */
#define MAX_PREC	P_COMMA

enum token {
#define EXPRTOK_ENUM
#include "exprtok.h"
};

static const char opname[][4] = {
#define EXPRTOK_NAME
#include "exprtok.h"
};

static const uint8_t oplen[] = {
#define EXPRTOK_LEN
#include "exprtok.h"
};

static const uint8_t opprec[] = {
#define EXPRTOK_PREC
#include "exprtok.h"
};

typedef struct expr_state {
	/* expression being evaluated */
	const char *expression;
	/* lexical position */
	const char *tokp;
	/* value from token() */
	struct tbl *val;
	/* variable that is being recursively expanded (EXPRINEVAL flag set) */
	struct tbl *evaling;
	/* token from token() */
	enum token tok;
	/* don't do assignments (for ?:, &&, ||) */
	uint8_t noassign;
	/* evaluating an $(()) expression? */
	bool arith;
	/* unsigned arithmetic calculation */
	bool natural;
} Expr_state;

enum error_type {
	ET_UNEXPECTED, ET_BADLIT, ET_RECURSIVE,
	ET_LVALUE, ET_RDONLY, ET_STR
};

static void evalerr(Expr_state *, enum error_type, const char *)
    MKSH_A_NORETURN;
static struct tbl *evalexpr(Expr_state *, unsigned int);
static void exprtoken(Expr_state *);
static struct tbl *do_ppmm(Expr_state *, enum token, struct tbl *, bool);
static void assign_check(Expr_state *, enum token, struct tbl *);
static struct tbl *intvar(Expr_state *, struct tbl *);

/*
 * parse and evaluate expression
 */
int
evaluate(const char *expr, mksh_ari_t *rval, int error_ok, bool arith)
{
	struct tbl v;
	int ret;

	v.flag = DEFINED | INTEGER;
	v.type = 0;
	ret = v_evaluate(&v, expr, error_ok, arith);
	*rval = v.val.i;
	return (ret);
}

/*
 * parse and evaluate expression, storing result in vp.
 */
int
v_evaluate(struct tbl *vp, const char *expr, volatile int error_ok,
    bool arith)
{
	struct tbl *v;
	Expr_state curstate;
	Expr_state * const es = &curstate;
	int i;

	/* save state to allow recursive calls */
	memset(&curstate, 0, sizeof(curstate));
	curstate.expression = curstate.tokp = expr;
	curstate.tok = BAD;
	curstate.arith = arith;

	newenv(E_ERRH);
	if ((i = kshsetjmp(e->jbuf))) {
		/* Clear EXPRINEVAL in of any variables we were playing with */
		if (curstate.evaling)
			curstate.evaling->flag &= ~EXPRINEVAL;
		quitenv(NULL);
		if (i == LAEXPR) {
			if (error_ok == KSH_RETURN_ERROR)
				return (0);
			errorfz();
		}
		unwind(i);
		/* NOTREACHED */
	}

	exprtoken(es);
	if (es->tok == END) {
		es->tok = LIT;
		es->val = tempvar("");
	}
	v = intvar(es, evalexpr(es, MAX_PREC));

	if (es->tok != END)
		evalerr(es, ET_UNEXPECTED, NULL);

	if (es->arith && es->natural)
		vp->flag |= INT_U;
	if (vp->flag & INTEGER)
		setint_v(vp, v, es->arith);
	else
		/* can fail if readonly */
		setstr(vp, str_val(v), error_ok);

	quitenv(NULL);

	return (1);
}

static void
evalerr(Expr_state *es, enum error_type type, const char *str)
{
	char tbuf[2];
	const char *s;

	es->arith = false;
	switch (type) {
	case ET_UNEXPECTED:
		switch (es->tok) {
		case VAR:
			s = es->val->name;
			break;
		case LIT:
			s = str_val(es->val);
			break;
		case END:
			s = "end of expression";
			break;
		case BAD:
			tbuf[0] = *es->tokp;
			tbuf[1] = '\0';
			s = tbuf;
			break;
		default:
			s = opname[(int)es->tok];
		}
		warningf(true, Tf_sD_s_qs, es->expression,
		    Tunexpected, s);
		break;

	case ET_BADLIT:
		warningf(true, Tf_sD_s_qs, es->expression,
		    Tbadnum, str);
		break;

	case ET_RECURSIVE:
		warningf(true, Tf_sD_s_qs, es->expression,
		    "expression recurses on parameter", str);
		break;

	case ET_LVALUE:
		warningf(true, Tf_sD_s_s,
		    es->expression, str, "requires lvalue");
		break;

	case ET_RDONLY:
		warningf(true, Tf_sD_s_s,
		    es->expression, str, "applied to read-only variable");
		break;

	default: /* keep gcc happy */
	case ET_STR:
		warningf(true, Tf_sD_s, es->expression, str);
		break;
	}
	unwind(LAEXPR);
}

/* do a ++ or -- operation */
static struct tbl *
do_ppmm(Expr_state *es, enum token op, struct tbl *vasn, bool is_prefix)
{
	struct tbl *vl;
	mksh_uari_t oval;

	assign_check(es, op, vasn);

	vl = intvar(es, vasn);
	oval = vl->val.u;
	if (op == O_PLUSPLUS)
		++vl->val.u;
	else
		--vl->val.u;
	if (!es->noassign) {
		if (vasn->flag & INTEGER)
			setint_v(vasn, vl, es->arith);
		else
			setint(vasn, vl->val.i);
	}
	if (!is_prefix)
		/* undo the increment/decrement */
		vl->val.u = oval;

	return (vl);
}

static struct tbl *
evalexpr(Expr_state *es, unsigned int prec)
{
	struct tbl *vl, *vr = NULL, *vasn;
	enum token op;
	mksh_uari_t res = 0, t1, t2, t3;

	if (prec == P_PRIMARY) {
		switch ((int)(op = es->tok)) {
		case O_BNOT:
		case O_LNOT:
		case O_MINUS:
		case O_PLUS:
			exprtoken(es);
			vl = intvar(es, evalexpr(es, P_PRIMARY));
			switch ((int)op) {
			case O_BNOT:
				vl->val.u = ~vl->val.u;
				break;
			case O_LNOT:
				vl->val.u = !vl->val.u;
				break;
			case O_MINUS:
				vl->val.u = -vl->val.u;
				break;
			case O_PLUS:
				/* nop */
				break;
			}
			break;

		case OPEN_PAREN:
			exprtoken(es);
			vl = evalexpr(es, MAX_PREC);
			if (es->tok != CLOSE_PAREN)
				evalerr(es, ET_STR, "missing )");
			exprtoken(es);
			break;

		case O_PLUSPLUS:
		case O_MINUSMINUS:
			exprtoken(es);
			vl = do_ppmm(es, op, es->val, true);
			exprtoken(es);
			break;

		case VAR:
		case LIT:
			vl = es->val;
			exprtoken(es);
			break;

		default:
			evalerr(es, ET_UNEXPECTED, NULL);
			/* NOTREACHED */
		}

		if (es->tok == O_PLUSPLUS || es->tok == O_MINUSMINUS) {
			vl = do_ppmm(es, es->tok, vl, false);
			exprtoken(es);
		}

		return (vl);
		/* prec == P_PRIMARY */
	}

	vl = evalexpr(es, prec - 1);
	while ((int)(op = es->tok) >= (int)O_EQ && (int)op <= (int)O_COMMA &&
	    opprec[(int)op] == prec) {
		switch ((int)op) {
		case O_TERN:
		case O_LAND:
		case O_LOR:
			break;
		default:
			exprtoken(es);
		}

		vasn = vl;
		if (op != O_ASN)
			/* vl may not have a value yet */
			vl = intvar(es, vl);
		if (IS_ASSIGNOP(op)) {
			if (!es->noassign)
				assign_check(es, op, vasn);
			vr = intvar(es, evalexpr(es, P_ASSIGN));
		} else if (op == O_TERN) {
			bool ev = vl->val.u != 0;

			if (!ev)
				es->noassign++;
			exprtoken(es);
			vl = evalexpr(es, MAX_PREC);
			if (!ev)
				es->noassign--;
			if (es->tok != CTERN)
				evalerr(es, ET_STR, "missing :");
			if (ev)
				es->noassign++;
			exprtoken(es);
			vr = evalexpr(es, P_TERN);
			if (ev)
				es->noassign--;
			vl = ev ? vl : vr;
			continue;
		} else if (op != O_LAND && op != O_LOR)
			vr = intvar(es, evalexpr(es, prec - 1));

		/* common ops setup */
		switch ((int)op) {
		case O_DIV:
		case O_DIVASN:
		case O_MOD:
		case O_MODASN:
			if (vr->val.u == 0) {
				if (!es->noassign)
					evalerr(es, ET_STR, "zero divisor");
				vr->val.u = 1;
			}
			/* calculate the absolute values */
			t1 = vl->val.i < 0 ? -vl->val.u : vl->val.u;
			t2 = vr->val.i < 0 ? -vr->val.u : vr->val.u;
			break;
#ifndef MKSH_LEGACY_MODE
		case O_LSHIFT:
		case O_LSHIFTASN:
		case O_RSHIFT:
		case O_RSHIFTASN:
		case O_ROL:
		case O_ROLASN:
		case O_ROR:
		case O_RORASN:
			t1 = vl->val.u;
			t2 = vr->val.u & 31;
			break;
#endif
		case O_LAND:
		case O_LOR:
			t1 = vl->val.u;
			t2 = 0;	/* gcc */
			break;
		default:
			t1 = vl->val.u;
			t2 = vr->val.u;
			break;
		}

#define cmpop(op)	(es->natural ?			\
	(mksh_uari_t)(vl->val.u op vr->val.u) :		\
	(mksh_uari_t)(vl->val.i op vr->val.i)		\
)

		/* op calculation */
		switch ((int)op) {
		case O_TIMES:
		case O_TIMESASN:
			res = t1 * t2;
			break;
		case O_MOD:
		case O_MODASN:
			if (es->natural) {
				res = vl->val.u % vr->val.u;
				break;
			}
			goto signed_division;
		case O_DIV:
		case O_DIVASN:
			if (es->natural) {
				res = vl->val.u / vr->val.u;
				break;
			}
 signed_division:
			/*
			 * a / b = abs(a) / abs(b) * sgn((u)a^(u)b)
			 */
			t3 = t1 / t2;
#ifndef MKSH_LEGACY_MODE
			res = ((vl->val.u ^ vr->val.u) & 0x80000000) ? -t3 : t3;
#else
			res = ((t1 == vl->val.u ? 0 : 1) ^
			    (t2 == vr->val.u ? 0 : 1)) ? -t3 : t3;
#endif
			if (op == O_MOD || op == O_MODASN) {
				/*
				 * primitive modulo, to get the sign of
				 * the result correct:
				 * (a % b) = a - ((a / b) * b)
				 * the subtraction and multiplication
				 * are, amazingly enough, sign ignorant
				 */
				res = vl->val.u - (res * vr->val.u);
			}
			break;
		case O_PLUS:
		case O_PLUSASN:
			res = t1 + t2;
			break;
		case O_MINUS:
		case O_MINUSASN:
			res = t1 - t2;
			break;
#ifndef MKSH_LEGACY_MODE
		case O_ROL:
		case O_ROLASN:
			res = (t1 << t2) | (t1 >> (32 - t2));
			break;
		case O_ROR:
		case O_RORASN:
			res = (t1 >> t2) | (t1 << (32 - t2));
			break;
#endif
		case O_LSHIFT:
		case O_LSHIFTASN:
			res = t1 << t2;
			break;
		case O_RSHIFT:
		case O_RSHIFTASN:
			res = es->natural || vl->val.i >= 0 ?
			    t1 >> t2 :
			    ~(~t1 >> t2);
			break;
		case O_LT:
			res = cmpop(<);
			break;
		case O_LE:
			res = cmpop(<=);
			break;
		case O_GT:
			res = cmpop(>);
			break;
		case O_GE:
			res = cmpop(>=);
			break;
		case O_EQ:
			res = t1 == t2;
			break;
		case O_NE:
			res = t1 != t2;
			break;
		case O_BAND:
		case O_BANDASN:
			res = t1 & t2;
			break;
		case O_BXOR:
		case O_BXORASN:
			res = t1 ^ t2;
			break;
		case O_BOR:
		case O_BORASN:
			res = t1 | t2;
			break;
		case O_LAND:
			if (!t1)
				es->noassign++;
			exprtoken(es);
			vr = intvar(es, evalexpr(es, prec - 1));
			res = t1 && vr->val.u;
			if (!t1)
				es->noassign--;
			break;
		case O_LOR:
			if (t1)
				es->noassign++;
			exprtoken(es);
			vr = intvar(es, evalexpr(es, prec - 1));
			res = t1 || vr->val.u;
			if (t1)
				es->noassign--;
			break;
		case O_ASN:
		case O_COMMA:
			res = t2;
			break;
		}

#undef cmpop

		if (IS_ASSIGNOP(op)) {
			vr->val.u = res;
			if (!es->noassign) {
				if (vasn->flag & INTEGER)
					setint_v(vasn, vr, es->arith);
				else
					setint(vasn, vr->val.i);
			}
			vl = vr;
		} else
			vl->val.u = res;
	}
	return (vl);
}

static void
exprtoken(Expr_state *es)
{
	const char *cp = es->tokp;
	int c;
	char *tvar;

	/* skip whitespace */
 skip_spaces:
	--cp;
	do {
		c = ord(*++cp);
	} while (ctype(c, C_SPACE));
	if (es->tokp == es->expression && (unsigned int)c == ORD('#')) {
		/* expression begins with # */
		/* switch to unsigned */
		es->natural = true;
		++cp;
		goto skip_spaces;
	}
	es->tokp = cp;

	if (c == '\0')
		es->tok = END;
	else if (ctype(c, C_ALPHX)) {
		do {
			c = ord(*++cp);
		} while (ctype(c, C_ALNUX));
		if ((unsigned int)c == ORD('[')) {
			size_t len;

			len = array_ref_len(cp);
			if (len == 0)
				evalerr(es, ET_STR, "missing ]");
			cp += len;
		}
		if (es->noassign) {
			es->val = tempvar("");
			es->val->flag |= EXPRLVALUE;
		} else {
			strndupx(tvar, es->tokp, cp - es->tokp, ATEMP);
			es->val = global(tvar);
			afree(tvar, ATEMP);
		}
		es->tok = VAR;
	} else if (c == '1' && cp[1] == '#') {
		cp += 2;
		if (*cp)
			cp += utf_ptradj(cp);
		strndupx(tvar, es->tokp, cp - es->tokp, ATEMP);
		goto process_tvar;
#ifndef MKSH_SMALL
	} else if (c == '\'') {
		if (*++cp == '\0') {
			es->tok = END;
			evalerr(es, ET_UNEXPECTED, NULL);
		}
		cp += utf_ptradj(cp);
		if (*cp++ != '\'')
			evalerr(es, ET_STR,
			    "multi-character character constant");
		/* 'x' -> 1#x (x = one multibyte character) */
		c = cp - es->tokp;
		tvar = alloc(c + /* NUL */ 1, ATEMP);
		tvar[0] = '1';
		tvar[1] = '#';
		memcpy(tvar + 2, es->tokp + 1, c - 2);
		tvar[c] = '\0';
		goto process_tvar;
#endif
	} else if (ctype(c, C_DIGIT)) {
		while (ctype(c, C_ALNUM | C_HASH))
			c = ord(*cp++);
		strndupx(tvar, es->tokp, --cp - es->tokp, ATEMP);
 process_tvar:
		es->val = tempvar("");
		es->val->flag &= ~INTEGER;
		es->val->type = 0;
		es->val->val.s = tvar;
		if (setint_v(es->val, es->val, es->arith) == NULL)
			evalerr(es, ET_BADLIT, tvar);
		afree(tvar, ATEMP);
		es->tok = LIT;
	} else {
		int i, n0;

		for (i = 0; (n0 = ord(opname[i][0])); i++)
			if (c == n0 && strncmp(cp, opname[i],
			    (size_t)oplen[i]) == 0) {
				es->tok = (enum token)i;
				cp += oplen[i];
				break;
			}
		if (!n0)
			es->tok = BAD;
	}
	es->tokp = cp;
}

static void
assign_check(Expr_state *es, enum token op, struct tbl *vasn)
{
	if (es->tok == END || !vasn ||
	    (vasn->name[0] == '\0' && !(vasn->flag & EXPRLVALUE)))
		evalerr(es, ET_LVALUE, opname[(int)op]);
	else if (vasn->flag & RDONLY)
		evalerr(es, ET_RDONLY, opname[(int)op]);
}

struct tbl *
tempvar(const char *vname)
{
	struct tbl *vp;
	size_t vsize;

	vsize = strlen(vname) + 1;
	vp = alloc(offsetof(struct tbl, name[0]) + vsize, ATEMP);
	memcpy(vp->name, vname, vsize);
	vp->flag = ISSET|INTEGER;
	vp->type = 0;
	vp->areap = ATEMP;
	vp->ua.hval = 0;
	vp->val.i = 0;
	return (vp);
}

/* cast (string) variable to temporary integer variable */
static struct tbl *
intvar(Expr_state *es, struct tbl *vp)
{
	struct tbl *vq;

	/* try to avoid replacing a temp var with another temp var */
	if (vp->name[0] == '\0' &&
	    (vp->flag & (ISSET|INTEGER|EXPRLVALUE)) == (ISSET|INTEGER))
		return (vp);

	vq = tempvar("");
	if (setint_v(vq, vp, es->arith) == NULL) {
		if (vp->flag & EXPRINEVAL)
			evalerr(es, ET_RECURSIVE, vp->name);
		es->evaling = vp;
		vp->flag |= EXPRINEVAL;
		v_evaluate(vq, str_val(vp), KSH_UNWIND_ERROR, es->arith);
		vp->flag &= ~EXPRINEVAL;
		es->evaling = NULL;
	}
	return (vq);
}


/*
 * UTF-8 support code: high-level functions
 */

int
utf_widthadj(const char *src, const char **dst)
{
	size_t len;
	unsigned int wc;
	int width;

	if (!UTFMODE || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
	    wc == 0)
		len = width = 1;
	else if ((width = utf_wcwidth(wc)) < 0)
		/* XXX use 2 for x_zotc3 here? */
		width = 1;

	if (dst)
		*dst = src + len;
	return (width);
}

size_t
utf_mbswidth(const char *s)
{
	size_t len, width = 0;
	unsigned int wc;
	int cw;

	if (!UTFMODE)
		return (strlen(s));

	while (*s)
		if (((len = utf_mbtowc(&wc, s)) == (size_t)-1) ||
		    ((cw = utf_wcwidth(wc)) == -1)) {
			s++;
			width += 1;
		} else {
			s += len;
			width += cw;
		}
	return (width);
}

const char *
utf_skipcols(const char *p, int cols, int *colp)
{
	int c = 0;
	const char *q;

	while (c < cols) {
		if (!*p) {
			/* end of input; special handling for edit.c */
			if (!colp)
				return (p + cols - c);
			*colp = c;
			return (p);
		}
		c += utf_widthadj(p, &p);
	}
	if (UTFMODE)
		while (utf_widthadj(p, &q) == 0)
			p = q;
	if (colp)
		*colp = c;
	return (p);
}

size_t
utf_ptradj(const char *src)
{
	register size_t n;

	if (!UTFMODE || rtt2asc(*src) < 0xC2 ||
	    (n = utf_mbtowc(NULL, src)) == (size_t)-1)
		n = 1;
	return (n);
}

/*
 * UTF-8 support code: low-level functions
 */

/* CESU-8 multibyte and wide character conversion crafted for mksh */

size_t
utf_mbtowc(unsigned int *dst, const char *src)
{
	const unsigned char *s = (const unsigned char *)src;
	unsigned int c, wc;

	if ((wc = ord(rtt2asc(*s++))) < 0x80) {
 out:
		if (dst != NULL)
			*dst = wc;
		return (wc ? ((const char *)s - src) : 0);
	}
	if (wc < 0xC2 || wc >= 0xF0)
		/* < 0xC0: spurious second byte */
		/* < 0xC2: non-minimalistic mapping error in 2-byte seqs */
		/* > 0xEF: beyond BMP */
		goto ilseq;

	if (wc < 0xE0) {
		wc = (wc & 0x1F) << 6;
		if (((c = ord(rtt2asc(*s++))) & 0xC0) != 0x80)
			goto ilseq;
		wc |= c & 0x3F;
		goto out;
	}

	wc = (wc & 0x0F) << 12;

	if (((c = ord(rtt2asc(*s++))) & 0xC0) != 0x80)
		goto ilseq;
	wc |= (c & 0x3F) << 6;

	if (((c = ord(rtt2asc(*s++))) & 0xC0) != 0x80)
		goto ilseq;
	wc |= c & 0x3F;

	/* Check for non-minimalistic mapping error in 3-byte seqs */
	if (wc >= 0x0800 && wc <= 0xFFFD)
		goto out;
 ilseq:
	return ((size_t)(-1));
}

size_t
utf_wctomb(char *dst, unsigned int wc)
{
	unsigned char *d;

	if (wc < 0x80) {
		*dst = asc2rtt(wc);
		return (1);
	}

	d = (unsigned char *)dst;
	if (wc < 0x0800)
		*d++ = asc2rtt((wc >> 6) | 0xC0);
	else {
		*d++ = asc2rtt(((wc = wc > 0xFFFD ? 0xFFFD : wc) >> 12) | 0xE0);
		*d++ = asc2rtt(((wc >> 6) & 0x3F) | 0x80);
	}
	*d++ = asc2rtt((wc & 0x3F) | 0x80);
	return ((char *)d - dst);
}

/*
 * Wrapper around access(2) because it says root can execute everything
 * on some operating systems. Does not set errno, no user needs it. Use
 * this iff mode can have the X_OK bit set, access otherwise.
 */
int
ksh_access(const char *fn, int mode)
{
#ifdef __OS2__
	return (access_ex(access, fn, mode));
#else
	int rv;
	struct stat sb;

	if ((rv = access(fn, mode)) == 0 && (mode & X_OK) &&
	    (kshuid == 0 || ksheuid == 0) &&
	    (rv = stat(fn, &sb)) == 0 && !S_ISDIR(sb.st_mode) &&
	    (sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) == 0)
		rv = -1;

	return (rv);
#endif
}

#ifndef MIRBSD_BOOTFLOPPY
/* From: X11/xc/programs/xterm/wcwidth.c,v 1.10 */

struct mb_ucsrange {
	unsigned short beg;
	unsigned short end;
};

static int mb_ucsbsearch(const struct mb_ucsrange arr[], size_t elems,
    unsigned int val) MKSH_A_PURE;

/*
 * Generated from the UCD 11.0.0 by
 * MirOS: contrib/code/Snippets/eawparse,v 1.12 2017/09/06 16:05:45 tg Exp $
 */

static const struct mb_ucsrange mb_ucs_combining[] = {
	{ 0x0300, 0x036F },
	{ 0x0483, 0x0489 },
	{ 0x0591, 0x05BD },
	{ 0x05BF, 0x05BF },
	{ 0x05C1, 0x05C2 },
	{ 0x05C4, 0x05C5 },
	{ 0x05C7, 0x05C7 },
	{ 0x0610, 0x061A },
	{ 0x061C, 0x061C },
	{ 0x064B, 0x065F },
	{ 0x0670, 0x0670 },
	{ 0x06D6, 0x06DC },
	{ 0x06DF, 0x06E4 },
	{ 0x06E7, 0x06E8 },
	{ 0x06EA, 0x06ED },
	{ 0x0711, 0x0711 },
	{ 0x0730, 0x074A },
	{ 0x07A6, 0x07B0 },
	{ 0x07EB, 0x07F3 },
	{ 0x07FD, 0x07FD },
	{ 0x0816, 0x0819 },
	{ 0x081B, 0x0823 },
	{ 0x0825, 0x0827 },
	{ 0x0829, 0x082D },
	{ 0x0859, 0x085B },
	{ 0x08D3, 0x08E1 },
	{ 0x08E3, 0x0902 },
	{ 0x093A, 0x093A },
	{ 0x093C, 0x093C },
	{ 0x0941, 0x0948 },
	{ 0x094D, 0x094D },
	{ 0x0951, 0x0957 },
	{ 0x0962, 0x0963 },
	{ 0x0981, 0x0981 },
	{ 0x09BC, 0x09BC },
	{ 0x09C1, 0x09C4 },
	{ 0x09CD, 0x09CD },
	{ 0x09E2, 0x09E3 },
	{ 0x09FE, 0x09FE },
	{ 0x0A01, 0x0A02 },
	{ 0x0A3C, 0x0A3C },
	{ 0x0A41, 0x0A42 },
	{ 0x0A47, 0x0A48 },
	{ 0x0A4B, 0x0A4D },
	{ 0x0A51, 0x0A51 },
	{ 0x0A70, 0x0A71 },
	{ 0x0A75, 0x0A75 },
	{ 0x0A81, 0x0A82 },
	{ 0x0ABC, 0x0ABC },
	{ 0x0AC1, 0x0AC5 },
	{ 0x0AC7, 0x0AC8 },
	{ 0x0ACD, 0x0ACD },
	{ 0x0AE2, 0x0AE3 },
	{ 0x0AFA, 0x0AFF },
	{ 0x0B01, 0x0B01 },
	{ 0x0B3C, 0x0B3C },
	{ 0x0B3F, 0x0B3F },
	{ 0x0B41, 0x0B44 },
	{ 0x0B4D, 0x0B4D },
	{ 0x0B56, 0x0B56 },
	{ 0x0B62, 0x0B63 },
	{ 0x0B82, 0x0B82 },
	{ 0x0BC0, 0x0BC0 },
	{ 0x0BCD, 0x0BCD },
	{ 0x0C00, 0x0C00 },
	{ 0x0C04, 0x0C04 },
	{ 0x0C3E, 0x0C40 },
	{ 0x0C46, 0x0C48 },
	{ 0x0C4A, 0x0C4D },
	{ 0x0C55, 0x0C56 },
	{ 0x0C62, 0x0C63 },
	{ 0x0C81, 0x0C81 },
	{ 0x0CBC, 0x0CBC },
	{ 0x0CBF, 0x0CBF },
	{ 0x0CC6, 0x0CC6 },
	{ 0x0CCC, 0x0CCD },
	{ 0x0CE2, 0x0CE3 },
	{ 0x0D00, 0x0D01 },
	{ 0x0D3B, 0x0D3C },
	{ 0x0D41, 0x0D44 },
	{ 0x0D4D, 0x0D4D },
	{ 0x0D62, 0x0D63 },
	{ 0x0DCA, 0x0DCA },
	{ 0x0DD2, 0x0DD4 },
	{ 0x0DD6, 0x0DD6 },
	{ 0x0E31, 0x0E31 },
	{ 0x0E34, 0x0E3A },
	{ 0x0E47, 0x0E4E },
	{ 0x0EB1, 0x0EB1 },
	{ 0x0EB4, 0x0EB9 },
	{ 0x0EBB, 0x0EBC },
	{ 0x0EC8, 0x0ECD },
	{ 0x0F18, 0x0F19 },
	{ 0x0F35, 0x0F35 },
	{ 0x0F37, 0x0F37 },
	{ 0x0F39, 0x0F39 },
	{ 0x0F71, 0x0F7E },
	{ 0x0F80, 0x0F84 },
	{ 0x0F86, 0x0F87 },
	{ 0x0F8D, 0x0F97 },
	{ 0x0F99, 0x0FBC },
	{ 0x0FC6, 0x0FC6 },
	{ 0x102D, 0x1030 },
	{ 0x1032, 0x1037 },
	{ 0x1039, 0x103A },
	{ 0x103D, 0x103E },
	{ 0x1058, 0x1059 },
	{ 0x105E, 0x1060 },
	{ 0x1071, 0x1074 },
	{ 0x1082, 0x1082 },
	{ 0x1085, 0x1086 },
	{ 0x108D, 0x108D },
	{ 0x109D, 0x109D },
	{ 0x1160, 0x11FF },
	{ 0x135D, 0x135F },
	{ 0x1712, 0x1714 },
	{ 0x1732, 0x1734 },
	{ 0x1752, 0x1753 },
	{ 0x1772, 0x1773 },
	{ 0x17B4, 0x17B5 },
	{ 0x17B7, 0x17BD },
	{ 0x17C6, 0x17C6 },
	{ 0x17C9, 0x17D3 },
	{ 0x17DD, 0x17DD },
	{ 0x180B, 0x180E },
	{ 0x1885, 0x1886 },
	{ 0x18A9, 0x18A9 },
	{ 0x1920, 0x1922 },
	{ 0x1927, 0x1928 },
	{ 0x1932, 0x1932 },
	{ 0x1939, 0x193B },
	{ 0x1A17, 0x1A18 },
	{ 0x1A1B, 0x1A1B },
	{ 0x1A56, 0x1A56 },
	{ 0x1A58, 0x1A5E },
	{ 0x1A60, 0x1A60 },
	{ 0x1A62, 0x1A62 },
	{ 0x1A65, 0x1A6C },
	{ 0x1A73, 0x1A7C },
	{ 0x1A7F, 0x1A7F },
	{ 0x1AB0, 0x1ABE },
	{ 0x1B00, 0x1B03 },
	{ 0x1B34, 0x1B34 },
	{ 0x1B36, 0x1B3A },
	{ 0x1B3C, 0x1B3C },
	{ 0x1B42, 0x1B42 },
	{ 0x1B6B, 0x1B73 },
	{ 0x1B80, 0x1B81 },
	{ 0x1BA2, 0x1BA5 },
	{ 0x1BA8, 0x1BA9 },
	{ 0x1BAB, 0x1BAD },
	{ 0x1BE6, 0x1BE6 },
	{ 0x1BE8, 0x1BE9 },
	{ 0x1BED, 0x1BED },
	{ 0x1BEF, 0x1BF1 },
	{ 0x1C2C, 0x1C33 },
	{ 0x1C36, 0x1C37 },
	{ 0x1CD0, 0x1CD2 },
	{ 0x1CD4, 0x1CE0 },
	{ 0x1CE2, 0x1CE8 },
	{ 0x1CED, 0x1CED },
	{ 0x1CF4, 0x1CF4 },
	{ 0x1CF8, 0x1CF9 },
	{ 0x1DC0, 0x1DF9 },
	{ 0x1DFB, 0x1DFF },
	{ 0x200B, 0x200F },
	{ 0x202A, 0x202E },
	{ 0x2060, 0x2064 },
	{ 0x2066, 0x206F },
	{ 0x20D0, 0x20F0 },
	{ 0x2CEF, 0x2CF1 },
	{ 0x2D7F, 0x2D7F },
	{ 0x2DE0, 0x2DFF },
	{ 0x302A, 0x302D },
	{ 0x3099, 0x309A },
	{ 0xA66F, 0xA672 },
	{ 0xA674, 0xA67D },
	{ 0xA69E, 0xA69F },
	{ 0xA6F0, 0xA6F1 },
	{ 0xA802, 0xA802 },
	{ 0xA806, 0xA806 },
	{ 0xA80B, 0xA80B },
	{ 0xA825, 0xA826 },
	{ 0xA8C4, 0xA8C5 },
	{ 0xA8E0, 0xA8F1 },
	{ 0xA8FF, 0xA8FF },
	{ 0xA926, 0xA92D },
	{ 0xA947, 0xA951 },
	{ 0xA980, 0xA982 },
	{ 0xA9B3, 0xA9B3 },
	{ 0xA9B6, 0xA9B9 },
	{ 0xA9BC, 0xA9BC },
	{ 0xA9E5, 0xA9E5 },
	{ 0xAA29, 0xAA2E },
	{ 0xAA31, 0xAA32 },
	{ 0xAA35, 0xAA36 },
	{ 0xAA43, 0xAA43 },
	{ 0xAA4C, 0xAA4C },
	{ 0xAA7C, 0xAA7C },
	{ 0xAAB0, 0xAAB0 },
	{ 0xAAB2, 0xAAB4 },
	{ 0xAAB7, 0xAAB8 },
	{ 0xAABE, 0xAABF },
	{ 0xAAC1, 0xAAC1 },
	{ 0xAAEC, 0xAAED },
	{ 0xAAF6, 0xAAF6 },
	{ 0xABE5, 0xABE5 },
	{ 0xABE8, 0xABE8 },
	{ 0xABED, 0xABED },
	{ 0xFB1E, 0xFB1E },
	{ 0xFE00, 0xFE0F },
	{ 0xFE20, 0xFE2F },
	{ 0xFEFF, 0xFEFF },
	{ 0xFFF9, 0xFFFB }
};

static const struct mb_ucsrange mb_ucs_fullwidth[] = {
	{ 0x1100, 0x115F },
	{ 0x231A, 0x231B },
	{ 0x2329, 0x232A },
	{ 0x23E9, 0x23EC },
	{ 0x23F0, 0x23F0 },
	{ 0x23F3, 0x23F3 },
	{ 0x25FD, 0x25FE },
	{ 0x2614, 0x2615 },
	{ 0x2648, 0x2653 },
	{ 0x267F, 0x267F },
	{ 0x2693, 0x2693 },
	{ 0x26A1, 0x26A1 },
	{ 0x26AA, 0x26AB },
	{ 0x26BD, 0x26BE },
	{ 0x26C4, 0x26C5 },
	{ 0x26CE, 0x26CE },
	{ 0x26D4, 0x26D4 },
	{ 0x26EA, 0x26EA },
	{ 0x26F2, 0x26F3 },
	{ 0x26F5, 0x26F5 },
	{ 0x26FA, 0x26FA },
	{ 0x26FD, 0x26FD },
	{ 0x2705, 0x2705 },
	{ 0x270A, 0x270B },
	{ 0x2728, 0x2728 },
	{ 0x274C, 0x274C },
	{ 0x274E, 0x274E },
	{ 0x2753, 0x2755 },
	{ 0x2757, 0x2757 },
	{ 0x2795, 0x2797 },
	{ 0x27B0, 0x27B0 },
	{ 0x27BF, 0x27BF },
	{ 0x2B1B, 0x2B1C },
	{ 0x2B50, 0x2B50 },
	{ 0x2B55, 0x2B55 },
	{ 0x2E80, 0x3029 },
	{ 0x302E, 0x303E },
	{ 0x3040, 0x3098 },
	{ 0x309B, 0xA4CF },
	{ 0xA960, 0xA97F },
	{ 0xAC00, 0xD7A3 },
	{ 0xF900, 0xFAFF },
	{ 0xFE10, 0xFE19 },
	{ 0xFE30, 0xFE6F },
	{ 0xFF01, 0xFF60 },
	{ 0xFFE0, 0xFFE6 }
};

/* simple binary search in ranges, with bounds optimisation */
static int
mb_ucsbsearch(const struct mb_ucsrange arr[], size_t elems, unsigned int val)
{
	size_t min = 0, mid, max = elems;

	if (val < arr[min].beg || val > arr[max - 1].end)
		return (0);

	while (min < max) {
		mid = (min + max) / 2;

		if (val < arr[mid].beg)
			max = mid;
		else if (val > arr[mid].end)
			min = mid + 1;
		else
			return (1);
	}
	return (0);
}

/* Unix column width of a wide character (UCS code point, really) */
int
utf_wcwidth(unsigned int wc)
{
	/* except NUL, C0/C1 control characters and DEL yield -1 */
	if (wc < 0x20 || (wc >= 0x7F && wc < 0xA0))
		return (wc ? -1 : 0);

	/* combining characters use 0 screen columns */
	if (mb_ucsbsearch(mb_ucs_combining, NELEM(mb_ucs_combining), wc))
		return (0);

	/* all others use 1 or 2 screen columns */
	if (mb_ucsbsearch(mb_ucs_fullwidth, NELEM(mb_ucs_fullwidth), wc))
		return (2);
	return (1);
}
#endif
@


1.105
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2016, 2017, 2018
d867 2
a868 1
	if ((rv = access(fn, mode)) == 0 && kshuid == 0 && (mode & X_OK) &&
@


1.104
log
@Unicode 11.0.0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.103 2018/01/14 01:29:47 tg Exp $");
d888 1
a888 1
 * Generated from the Unicode Character Database, Version 11.0.0, by
d1180 1
a1180 1
/* Unix column width of a wide character (Unicode code point, really) */
@


1.103
log
@write ord’ed into c
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.101 2017/11/18 12:01:53 tg Exp $");
d888 1
a888 1
 * Generated from the Unicode Character Database, Version 10.0.0, by
d912 1
d918 1
a918 1
	{ 0x08D4, 0x08E1 },
d931 1
d958 1
d1078 1
@


1.102
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2016, 2017
d561 4
a564 2
	while (ctype((c = *cp), C_SPACE))
		++cp;
@


1.101
log
@refresh with up-to-date eawparse

thankfully, this is now all in glibc master, too
(thanks Mike FABIAN)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.92 2017/04/02 15:00:42 tg Exp $");
d561 1
a561 1
	while (ctype(ord((c = *cp)), C_SPACE))
d563 1
a563 1
	if (es->tokp == es->expression && c == ord('#')) {
d578 1
a578 1
		if (c == ord('[')) {
@


1.100
log
@fixup by regenerating with new eawparse which matches what I submitted to
https://sourceware.org/bugzilla/show_bug.cgi?id=21750 even if only FF00
actually changed due to the algorithms in use
@
text
@d887 1
a887 1
 * MirOS: contrib/code/Snippets/eawparse,v 1.10 2017/07/12 22:47:26 tg Exp $
a897 1
	{ 0x0600, 0x0605 },
d902 1
a902 1
	{ 0x06D6, 0x06DD },
a905 1
	{ 0x070F, 0x070F },
d915 2
a916 1
	{ 0x08D4, 0x0902 },
@


1.99
log
@Unicode 10.0.0
@
text
@d887 1
a887 1
 * MirOS: contrib/code/Snippets/eawparse,v 1.3 2014/11/16 12:16:24 tg Exp $
d1140 4
a1143 2
	{ 0x2E80, 0x303E },
	{ 0x3040, 0xA4CF },
d1149 1
a1149 1
	{ 0xFF00, 0xFF60 },
@


1.98
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d875 1
a875 1
/* From: X11/xc/programs/xterm/wcwidth.c,v 1.9 */
d886 1
a886 1
 * Generated from the Unicode Character Database, Version 9.0.0, by
d943 1
d966 2
a967 1
	{ 0x0D01, 0x0D01 },
d1052 1
a1052 1
	{ 0x1DC0, 0x1DF5 },
@


1.97
log
@switch EBCDIC to “nega-UTF8”
@
text
@d561 1
a561 1
	while (ctype((c = *cp), C_SPACE))
d563 1
a563 1
	if (es->tokp == es->expression && c == '#') {
d576 1
a576 1
			c = *++cp;
d578 1
a578 1
		if (c == '[') {
d622 1
a622 1
			c = *cp++;
d636 1
a636 1
		for (i = 0; (n0 = opname[i][0]); i++)
@


1.96
log
@fixup the remaining issues and last optimisations
@
text
@d775 1
a775 2
	if (!UTFMODE ||
	    *(const unsigned char *)(src) < 0xC2 ||
d793 1
a793 1
	if ((wc = *s++) < 0x80) {
d807 1
a807 1
		if (((c = *s++) & 0xC0) != 0x80)
d815 1
a815 1
	if (((c = *s++) & 0xC0) != 0x80)
d819 1
a819 1
	if (((c = *s++) & 0xC0) != 0x80)
d836 1
a836 1
		*dst = wc;
d842 1
a842 1
		*d++ = (wc >> 6) | 0xC0;
d844 2
a845 2
		*d++ = ((wc = wc > 0xFFFD ? 0xFFFD : wc) >> 12) | 0xE0;
		*d++ = ((wc >> 6) & 0x3F) | 0x80;
d847 1
a847 1
	*d++ = (wc & 0x3F) | 0x80;
@


1.95
log
@batch of optimisations
@
text
@d621 1
a621 1
		while (ctype(c, C_ALNUM) || c == '#')
@


1.94
log
@eliminate legacy macros
@
text
@d621 1
a621 1
		while (c != '_' && (ctype(c, C_ALNUX) || c == '#'))
@


1.93
log
@string pooling, and more consistent look for error messages
@
text
@d561 1
a561 1
	while ((c = *cp), ksh_isspace(c))
d574 1
a574 1
	else if (ksh_isalphx(c)) {
d577 1
a577 1
		} while (ksh_isalnux(c));
d620 2
a621 2
	} else if (ksh_isdigit(c)) {
		while (c != '_' && (ksh_isalnux(c) || c == '#'))
@


1.92
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.91 2017/03/26 00:10:23 tg Exp $");
d206 1
a206 1
		    "bad number", str);
@


1.91
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.89 2016/09/01 12:55:21 tg Exp $");
d860 3
d872 1
@


1.90
log
@fix lazy evaluation with side effects; spotted by ormaaj via IRC
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2016
d575 3
a577 2
		for (; ksh_isalnux(c); c = *cp)
			cp++;
@


1.89
log
@Unicode 9.0.0 (code and data part; FixedMisc font tbd)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.81 2016/01/14 21:17:50 tg Exp $");
d329 9
a337 1
		exprtoken(es);
d351 1
a356 1
			exprtoken(es);
d359 1
d514 1
d523 1
@


1.88
log
@shave off 12 bytes (with fixed gcc) by making the definitions more legible
(and dropping struct padding, tbh)
@
text
@d860 1
a860 1
/* From: X11/xc/programs/xterm/wcwidth.c,v 1.8 2014/06/24 19:53:53 tg Exp $ */
d871 2
a872 2
 * Generated by MirOS: contrib/code/Snippets/eawparse,v 1.2 2013/11/30 13:45:17 tg Exp $
 * from the Unicode Character Database, Version 7.0.0
d902 1
a902 1
	{ 0x08E4, 0x0902 },
d997 1
d1036 1
a1036 1
	{ 0x1DFC, 0x1DFF },
d1049 1
a1049 1
	{ 0xA69F, 0xA69F },
d1055 1
a1055 1
	{ 0xA8C4, 0xA8C4 },
d1082 1
a1082 1
	{ 0xFE20, 0xFE2D },
d1089 1
d1091 32
@


1.87
log
@use ^< and ^> for ROL and ROR in R53, schedule >>> as SAR for R54

cf. http://david.tribble.com/text/c0xrot.htm
@
text
@d28 2
a29 36
/* the order of these enums is constrained by the order of opinfo[] */
enum token {
	/* some (long) unary operators */
	O_PLUSPLUS = 0, O_MINUSMINUS,
	/* binary operators */
	O_EQ, O_NE,
	/* assignments are assumed to be in range O_ASN .. O_BORASN */
	O_ASN, O_TIMESASN, O_DIVASN, O_MODASN, O_PLUSASN, O_MINUSASN,
#ifndef MKSH_LEGACY_MODE
	O_ROLASN, O_RORASN,
#endif
	O_LSHIFTASN, O_RSHIFTASN, O_BANDASN, O_BXORASN, O_BORASN,
	/* binary non-assignment operators */
#ifndef MKSH_LEGACY_MODE
	O_ROL, O_ROR,
#endif
	O_LSHIFT, O_RSHIFT,
	O_LE, O_GE, O_LT, O_GT,
	O_LAND,
	O_LOR,
	O_TIMES, O_DIV, O_MOD,
	O_PLUS, O_MINUS,
	O_BAND,
	O_BXOR,
	O_BOR,
	O_TERN,
	O_COMMA,
	/* things after this aren't used as binary operators */
	/* unary that are not also binaries */
	O_BNOT, O_LNOT,
	/* misc */
	OPEN_PAREN, CLOSE_PAREN, CTERN,
	/* things that don't appear in the opinfo[] table */
	VAR, LIT, END, BAD
};
#define IS_ASSIGNOP(op)	((int)(op) >= (int)O_ASN && (int)(op) <= (int)O_BORASN)
d49 8
a56 6
struct opinfo {
	char name[4];
	/* name length */
	uint8_t len;
	/* precedence: lower is higher */
	uint8_t prec;
d59 8
a66 53
/*
 * Tokens in this table must be ordered so the longest are first
 * (eg, += before +). If you change something, change the order
 * of enum token too.
 */
static const struct opinfo opinfo[] = {
	{ "++",   2, P_PRIMARY },	/* before + */
	{ "--",   2, P_PRIMARY },	/* before - */
	{ "==",   2, P_EQUALITY },	/* before = */
	{ "!=",   2, P_EQUALITY },	/* before ! */
	{ "=",    1, P_ASSIGN },	/* keep assigns in a block */
	{ "*=",   2, P_ASSIGN },
	{ "/=",   2, P_ASSIGN },
	{ "%=",   2, P_ASSIGN },
	{ "+=",   2, P_ASSIGN },
	{ "-=",   2, P_ASSIGN },
#ifndef MKSH_LEGACY_MODE
	{ "^<=",  3, P_ASSIGN },	/* before ^< */
	{ "^>=",  3, P_ASSIGN },	/* before ^> */
#endif
	{ "<<=",  3, P_ASSIGN },
	{ ">>=",  3, P_ASSIGN },
	{ "&=",   2, P_ASSIGN },
	{ "^=",   2, P_ASSIGN },
	{ "|=",   2, P_ASSIGN },
#ifndef MKSH_LEGACY_MODE
	{ "^<",   2, P_SHIFT },		/* before ^ */
	{ "^>",   2, P_SHIFT },		/* before ^ */
#endif
	{ "<<",   2, P_SHIFT },
	{ ">>",   2, P_SHIFT },
	{ "<=",   2, P_RELATION },
	{ ">=",   2, P_RELATION },
	{ "<",    1, P_RELATION },
	{ ">",    1, P_RELATION },
	{ "&&",   2, P_LAND },
	{ "||",   2, P_LOR },
	{ "*",    1, P_MULT },
	{ "/",    1, P_MULT },
	{ "%",    1, P_MULT },
	{ "+",    1, P_ADD },
	{ "-",    1, P_ADD },
	{ "&",    1, P_BAND },
	{ "^",    1, P_BXOR },
	{ "|",    1, P_BOR },
	{ "?",    1, P_TERN },
	{ ",",    1, P_COMMA },
	{ "~",    1, P_PRIMARY },
	{ "!",    1, P_PRIMARY },
	{ "(",    1, P_PRIMARY },
	{ ")",    1, P_PRIMARY },
	{ ":",    1, P_PRIMARY },
	{ "",     0, P_PRIMARY }
d198 1
a198 1
			s = opinfo[(int)es->tok].name;
d328 1
a328 1
	    opinfo[(int)op].prec == prec) {
d624 3
a626 3
		for (i = 0; (n0 = opinfo[i].name[0]); i++)
			if (c == n0 && strncmp(cp, opinfo[i].name,
			    (size_t)opinfo[i].len) == 0) {
d628 1
a628 1
				cp += opinfo[i].len;
d642 1
a642 1
		evalerr(es, ET_LVALUE, opinfo[(int)op].name);
d644 1
a644 1
		evalerr(es, ET_RDONLY, opinfo[(int)op].name);
@


1.86
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d69 1
a69 1
#define P_SHIFT		3	/* <<< >>> << >> */
d78 1
a78 1
	/* = += -= *= /= %= <<<= >>>= <<= >>= &= ^= |= */
d84 1
a84 1
	char name[5];
d108 2
a109 2
	{ "<<<=", 4, P_ASSIGN },	/* before <<< */
	{ ">>>=", 4, P_ASSIGN },	/* before >>> */
d117 2
a118 2
	{ "<<<",  3, P_SHIFT },		/* before << */
	{ ">>>",  3, P_SHIFT },		/* before >> */
@


1.85
log
@fix utf_widthadj/utf_skipcols handling for the remaining cases I can spot
@
text
@d277 2
a278 2
		warningf(true, "%s: %s '%s'", es->expression,
		    "unexpected", s);
d282 1
a282 1
		warningf(true, "%s: %s '%s'", es->expression,
d287 1
a287 1
		warningf(true, "%s: %s '%s'", es->expression,
d292 1
a292 1
		warningf(true, "%s: %s %s",
d297 1
a297 1
		warningf(true, "%s: %s %s",
d303 1
a303 1
		warningf(true, "%s: %s", es->expression, str);
@


1.84
log
@handle combining characters at the end of the string correctly
@
text
@d812 1
a812 1
utf_skipcols(const char *p, int cols)
d818 7
a824 2
		if (!*p)
			return (p + cols - c);
d830 2
@


1.83
log
@fix invalid read for ksh93-style base-1 integers

(valgrind; reported by fmunozs via IRC, thanks!)
@
text
@d815 1
d822 3
@


1.82
log
@plug a few display problems with special parameter name expansions
reported by Stéphane Chazelas
@
text
@d668 4
a671 1
		++cp;
@


1.81
log
@fix buffer overrun (LP#1533394)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.75 2014/01/05 21:57:26 tg Exp $");
d230 1
a230 1
		es->val = tempvar();
d652 1
a652 1
			es->val = tempvar();
d687 1
a687 1
		es->val = tempvar();
d722 1
a722 1
tempvar(void)
d725 1
d727 3
a729 1
	vp = alloc(sizeof(struct tbl), ATEMP);
a734 1
	vp->name[0] = '\0';
d749 1
a749 1
	vq = tempvar();
@


1.80
log
@janitorial work
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d662 2
a663 1
		cp += utf_ptradj(cp);
@


1.79
log
@save ~1½K from the bootfloppy by reusing MirBSD libkern wcwidth(3)
but don’t bother for this for the regular /bin/mksh either
to keep the generic code path tested well
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
@


1.78
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d919 1
d1199 1
@


1.77
log
@oksh sync RCSIDs only:
• expr.c long done already
• mksh.1 does not apply to us (no character classes)
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.76
log
@Unicode 7.0.0
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.23 2013/12/17 16:37:06 deraadt Exp $	*/
@


1.76.2.1
log
@MFC most of the rest: int → bool, MAXPATHLEN, comments/whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.24 2014/12/08 14:26:31 otto Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.76 2014/06/24 19:53:19 tg Exp $");
@


1.75
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.73 2013/11/30 23:20:03 tg Exp $");
d919 1
a919 1
/* From: X11/xc/programs/xterm/wcwidth.c,v 1.7 2013/11/30 23:20:03 tg Exp $ */
d931 1
a931 1
 * from the Unicode Character Database, Version 6.3.0
d942 1
a942 1
	{ 0x0600, 0x0604 },
d961 1
a961 2
	{ 0x08E4, 0x08FE },
	{ 0x0900, 0x0902 },
d997 1
d1003 1
d1009 1
d1070 1
d1080 1
a1080 1
	{ 0x1BAB, 0x1BAB },
d1092 2
a1093 1
	{ 0x1DC0, 0x1DE6 },
d1121 1
d1127 1
d1140 1
a1140 1
	{ 0xFE20, 0xFE26 },
@


1.74
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
a918 1
#ifndef MKSH_mirbsd_wcwidth
d927 1
a927 1
    unsigned int val);
a1191 1
#endif
@


1.73
log
@Unicode 6.3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.22 2013/03/28 08:39:28 nicm Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.72 2013/07/21 18:38:56 tg Exp $");
@


1.72
log
@fix postun in not evaluated side of e.g. ternary operator (LP#1187729)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.71 2013/05/31 23:27:13 tg Exp $");
d920 1
a920 1
/* From: X11/xc/programs/xterm/wcwidth.c,v 1.6 2013/05/31 23:27:09 tg Exp $ */
d931 2
a932 2
 * Generated by MirOS: contrib/code/Snippets/eawparse,v 1.1 2013/05/31 23:27:16 tg Exp $
 * from Unicode 6.2.0
d945 1
d1054 1
a1054 1
	{ 0x180B, 0x180D },
d1061 1
d1095 1
a1095 1
	{ 0x206A, 0x206F },
@


1.71
log
@Replace wcwidth code by mine based on Unicode 6.2.0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.70 2013/04/26 19:10:58 tg Exp $");
d324 6
a329 4
	if (vasn->flag & INTEGER)
		setint_v(vasn, vl, es->arith);
	else
		setint(vasn, vl->val.i);
@


1.70
log
@fix remaining signed int nonsense I am aware of
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.69 2013/04/14 13:36:50 tg Exp $");
a897 123

#ifndef MKSH_mirbsd_wcwidth
/* --- begin of wcwidth.c excerpt --- */
/*-
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
 *
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 */

__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.11 2012/09/01 23:46:43 tg Exp $");

int
utf_wcwidth(unsigned int c)
{
	static const struct cbset {
		unsigned short first;
		unsigned short last;
	} comb[] = {
		/* Unicode 6.1.0 BMP */
		{ 0x0300, 0x036F }, { 0x0483, 0x0489 }, { 0x0591, 0x05BD },
		{ 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 }, { 0x05C4, 0x05C5 },
		{ 0x05C7, 0x05C7 }, { 0x0600, 0x0604 }, { 0x0610, 0x061A },
		{ 0x064B, 0x065F }, { 0x0670, 0x0670 }, { 0x06D6, 0x06DD },
		{ 0x06DF, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
		{ 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0816, 0x0819 },
		{ 0x081B, 0x0823 }, { 0x0825, 0x0827 }, { 0x0829, 0x082D },
		{ 0x0859, 0x085B }, { 0x08E4, 0x08FE }, { 0x0900, 0x0902 },
		{ 0x093A, 0x093A }, { 0x093C, 0x093C }, { 0x0941, 0x0948 },
		{ 0x094D, 0x094D }, { 0x0951, 0x0957 }, { 0x0962, 0x0963 },
		{ 0x0981, 0x0981 }, { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 },
		{ 0x09CD, 0x09CD }, { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 },
		{ 0x0A3C, 0x0A3C }, { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 },
		{ 0x0A4B, 0x0A4D }, { 0x0A51, 0x0A51 }, { 0x0A70, 0x0A71 },
		{ 0x0A75, 0x0A75 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
		{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
		{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
		{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B44 }, { 0x0B4D, 0x0B4D },
		{ 0x0B56, 0x0B56 }, { 0x0B62, 0x0B63 }, { 0x0B82, 0x0B82 },
		{ 0x0BC0, 0x0BC0 }, { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 },
		{ 0x0C46, 0x0C48 }, { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 },
		{ 0x0C62, 0x0C63 }, { 0x0CBC, 0x0CBC }, { 0x0CBF, 0x0CBF },
		{ 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD }, { 0x0CE2, 0x0CE3 },
		{ 0x0D41, 0x0D44 }, { 0x0D4D, 0x0D4D }, { 0x0D62, 0x0D63 },
		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F8D, 0x0F97 },
		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
		{ 0x1032, 0x1037 }, { 0x1039, 0x103A }, { 0x103D, 0x103E },
		{ 0x1058, 0x1059 }, { 0x105E, 0x1060 }, { 0x1071, 0x1074 },
		{ 0x1082, 0x1082 }, { 0x1085, 0x1086 }, { 0x108D, 0x108D },
		{ 0x109D, 0x109D }, { 0x1160, 0x11FF }, { 0x135D, 0x135F },
		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
		{ 0x1A17, 0x1A18 }, { 0x1A56, 0x1A56 }, { 0x1A58, 0x1A5E },
		{ 0x1A60, 0x1A60 }, { 0x1A62, 0x1A62 }, { 0x1A65, 0x1A6C },
		{ 0x1A73, 0x1A7C }, { 0x1A7F, 0x1A7F }, { 0x1B00, 0x1B03 },
		{ 0x1B34, 0x1B34 }, { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C },
		{ 0x1B42, 0x1B42 }, { 0x1B6B, 0x1B73 }, { 0x1B80, 0x1B81 },
		{ 0x1BA2, 0x1BA5 }, { 0x1BA8, 0x1BA9 }, { 0x1BAB, 0x1BAB },
		{ 0x1BE6, 0x1BE6 }, { 0x1BE8, 0x1BE9 }, { 0x1BED, 0x1BED },
		{ 0x1BEF, 0x1BF1 }, { 0x1C2C, 0x1C33 }, { 0x1C36, 0x1C37 },
		{ 0x1CD0, 0x1CD2 }, { 0x1CD4, 0x1CE0 }, { 0x1CE2, 0x1CE8 },
		{ 0x1CED, 0x1CED }, { 0x1CF4, 0x1CF4 }, { 0x1DC0, 0x1DE6 },
		{ 0x1DFC, 0x1DFF }, { 0x200B, 0x200F }, { 0x202A, 0x202E },
		{ 0x2060, 0x2064 }, { 0x206A, 0x206F }, { 0x20D0, 0x20F0 },
		{ 0x2CEF, 0x2CF1 }, { 0x2D7F, 0x2D7F }, { 0x2DE0, 0x2DFF },
		{ 0x302A, 0x302D }, { 0x3099, 0x309A }, { 0xA66F, 0xA672 },
		{ 0xA674, 0xA67D }, { 0xA69F, 0xA69F }, { 0xA6F0, 0xA6F1 },
		{ 0xA802, 0xA802 }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
		{ 0xA825, 0xA826 }, { 0xA8C4, 0xA8C4 }, { 0xA8E0, 0xA8F1 },
		{ 0xA926, 0xA92D }, { 0xA947, 0xA951 }, { 0xA980, 0xA982 },
		{ 0xA9B3, 0xA9B3 }, { 0xA9B6, 0xA9B9 }, { 0xA9BC, 0xA9BC },
		{ 0xAA29, 0xAA2E }, { 0xAA31, 0xAA32 }, { 0xAA35, 0xAA36 },
		{ 0xAA43, 0xAA43 }, { 0xAA4C, 0xAA4C }, { 0xAAB0, 0xAAB0 },
		{ 0xAAB2, 0xAAB4 }, { 0xAAB7, 0xAAB8 }, { 0xAABE, 0xAABF },
		{ 0xAAC1, 0xAAC1 }, { 0xAAEC, 0xAAED }, { 0xAAF6, 0xAAF6 },
		{ 0xABE5, 0xABE5 }, { 0xABE8, 0xABE8 }, { 0xABED, 0xABED },
		{ 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F }, { 0xFE20, 0xFE26 },
		{ 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
	};
	size_t min = 0, mid, max = NELEM(comb) - 1;

	/* test for 8-bit control characters */
	if (c < 32 || (c >= 0x7F && c < 0xA0))
		return (c ? -1 : 0);

	/* binary search in table of non-spacing characters */
	if (c >= comb[0].first && c <= comb[max].last)
		while (max >= min) {
			mid = (min + max) / 2;
			if (c > comb[mid].last)
				min = mid + 1;
			else if (c < comb[mid].first)
				max = mid - 1;
			else
				return (0);
		}

	/* if we arrive here, c is not a combining or C0/C1 control char */

	return ((c >= 0x1100 && (
	    c <= 0x115F || /* Hangul Jamo init. consonants */
	    c == 0x2329 || c == 0x232A ||
	    (c >= 0x2E80 && c <= 0xA4CF && c != 0x303F) || /* CJK ... Yi */
	    (c >= 0xAC00 && c <= 0xD7A3) || /* Hangul Syllables */
	    (c >= 0xF900 && c <= 0xFAFF) || /* CJK Compatibility Ideographs */
	    (c >= 0xFE10 && c <= 0xFE19) || /* Vertical forms */
	    (c >= 0xFE30 && c <= 0xFE6F) || /* CJK Compatibility Forms */
	    (c >= 0xFF00 && c <= 0xFF60) || /* Fullwidth Forms */
	    (c >= 0xFFE0 && c <= 0xFFE6))) ? 2 : 1);
}
/* --- end of wcwidth.c excerpt --- */
#endif

d916 274
@


1.69
log
@another intermediate step/commit to get arithmetics right:

do the correct operations for comparisons (just keep using the
signed/unsigned switch from bivui for them), division (by working
on absolutes and adding the sign at the end), modulo (stupidly by
divising in signed, multiplying and subtracting, to get the sign
of the result right)

also adds rotation

XXX to check: do we need to AND before assigning the result in division?
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.68 2013/04/01 02:37:49 tg Exp $");
d158 1
a158 1
	short noassign;
@


1.68
log
@one can’t cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(I’m gonna have to revise lots more code…)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.65 2013/04/01 01:16:37 tg Exp $");
d28 1
a28 15
#if !HAVE_SILENT_IDIVWRAPV
#if !defined(MKSH_LEGACY_MODE) || HAVE_LONG_32BIT
#define IDIVWRAPV_VL	(mksh_uari_t)0x80000000UL
#define IDIVWRAPV_VR	(mksh_uari_t)0xFFFFFFFFUL
#elif HAVE_LONG_64BIT
#define IDIVWRAPV_VL	(mksh_uari_t)0x8000000000000000UL
#define IDIVWRAPV_VR	(mksh_uari_t)0xFFFFFFFFFFFFFFFFUL
#else
# warning "cannot guarantee integer division wraparound"
#undef HAVE_SILENT_IDIVWRAPV
#define HAVE_SILENT_IDIVWRAPV 1
#endif
#endif

/* The order of these enums is constrained by the order of opinfo[] */
d36 3
d40 4
d66 1
a66 1
#define P_PRIMARY	0	/* VAR, LIT, (), ~ ! - + */
d69 1
a69 1
#define P_SHIFT		3	/* << >> */
d78 2
a79 1
#define P_ASSIGN	12	/* = *= /= %= += -= <<= >>= &= ^= |= */
d84 5
a88 3
	char		name[4];
	int		len;	/* name length */
	int		prec;	/* precedence: lower is higher */
d91 2
a92 1
/* Tokens in this table must be ordered so the longest are first
d97 47
a143 39
	{ "++",	 2, P_PRIMARY },	/* before + */
	{ "--",	 2, P_PRIMARY },	/* before - */
	{ "==",	 2, P_EQUALITY },	/* before = */
	{ "!=",	 2, P_EQUALITY },	/* before ! */
	{ "=",	 1, P_ASSIGN },		/* keep assigns in a block */
	{ "*=",	 2, P_ASSIGN },
	{ "/=",	 2, P_ASSIGN },
	{ "%=",	 2, P_ASSIGN },
	{ "+=",	 2, P_ASSIGN },
	{ "-=",	 2, P_ASSIGN },
	{ "<<=", 3, P_ASSIGN },
	{ ">>=", 3, P_ASSIGN },
	{ "&=",	 2, P_ASSIGN },
	{ "^=",	 2, P_ASSIGN },
	{ "|=",	 2, P_ASSIGN },
	{ "<<",	 2, P_SHIFT },
	{ ">>",	 2, P_SHIFT },
	{ "<=",	 2, P_RELATION },
	{ ">=",	 2, P_RELATION },
	{ "<",	 1, P_RELATION },
	{ ">",	 1, P_RELATION },
	{ "&&",	 2, P_LAND },
	{ "||",	 2, P_LOR },
	{ "*",	 1, P_MULT },
	{ "/",	 1, P_MULT },
	{ "%",	 1, P_MULT },
	{ "+",	 1, P_ADD },
	{ "-",	 1, P_ADD },
	{ "&",	 1, P_BAND },
	{ "^",	 1, P_BXOR },
	{ "|",	 1, P_BOR },
	{ "?",	 1, P_TERN },
	{ ",",	 1, P_COMMA },
	{ "~",	 1, P_PRIMARY },
	{ "!",	 1, P_PRIMARY },
	{ "(",	 1, P_PRIMARY },
	{ ")",	 1, P_PRIMARY },
	{ ":",	 1, P_PRIMARY },
	{ "",	 0, P_PRIMARY }
a164 6
/* to be replaced (later) */
#define bivui(x, op, y)	(es->natural ?			\
	(mksh_uari_t)((x)->val.u op (y)->val.u) :	\
	(mksh_uari_t)((x)->val.i op (y)->val.i)		\
)

d172 1
a172 1
static struct tbl *evalexpr(Expr_state *, int);
d187 1
a187 1
	v.flag = DEFINED|INTEGER;
d336 1
a336 1
evalexpr(Expr_state *es, int prec)
d340 1
a340 1
	mksh_uari_t res = 0;
d434 1
d440 58
d499 1
a499 3
			 * actually, the entire division routine needs
			 * a more high-level implementation using only
			 * unsigned arithmetics
d501 6
a506 17
			switch (vr->val.u) {
#if !HAVE_SILENT_IDIVWRAPV
			case IDIVWRAPV_VR:
				if (vl->val.u == IDIVWRAPV_VL && !es->natural) {
					/*
					 * these are the correct precalculated
					 * values for signed division of the
					 * most negative number (which has no
					 * positive representation) by -1:
					 * result INTMIN, modulo 0
					 */
					res = op == O_DIV || op == O_DIVASN ?
					    IDIVWRAPV_VL : 0;
					break;
				}
				if (0)
					/* FALLTHROUGH */
d508 9
a516 12
			case 0:
				  {
					if (!es->noassign) {
						evalerr(es, ET_STR,
						    "zero divisor");
					}
					vr->val.u = 1;
				}
				/* FALLTHROUGH */
			default:
				res = op == O_DIV || op == O_DIVASN ?
				    bivui(vl, /, vr) : bivui(vl, %, vr);
a518 4
		case O_TIMES:
		case O_TIMESASN:
			res = vl->val.u * vr->val.u;
			break;
d521 1
a521 1
			res = vl->val.u + vr->val.u;
d525 10
a534 1
			res = vl->val.u - vr->val.u;
d536 1
d539 1
a539 2
			/* how about ANDing with 31 (except lksh)? */
			res = vl->val.u << vr->val.u;
a542 1
			/* how about ANDing with 31 (except lksh)? */
d544 2
a545 2
			    vl->val.u >> vr->val.u :
			    ~(~vl->val.u >> vr->val.u);
a546 1
		/* how about rotation? */
d548 1
a548 2
			/* all bivui users need special handling */
			res = bivui(vl, <, vr);
d551 1
a551 1
			res = bivui(vl, <=, vr);
d554 1
a554 1
			res = bivui(vl, >, vr);
d557 1
a557 1
			res = bivui(vl, >=, vr);
d560 1
a560 1
			res = vl->val.u == vr->val.u;
d563 1
a563 1
			res = vl->val.u != vr->val.u;
d567 1
a567 1
			res = vl->val.u & vr->val.u;
d571 1
a571 1
			res = vl->val.u ^ vr->val.u;
d575 1
a575 1
			res = vl->val.u | vr->val.u;
d578 1
a578 1
			if (!vl->val.u)
d581 2
a582 2
			res = vl->val.u && vr->val.u;
			if (!vl->val.u)
d586 1
a586 1
			if (vl->val.u)
d589 2
a590 2
			res = vl->val.u || vr->val.u;
			if (vl->val.u)
d595 1
a595 1
			res = vr->val.u;
d599 2
d623 1
a623 1
	/* skip white space */
d629 2
a630 1
		es->natural = true;	/* switch to unsigned */
a647 6
		} else if (c == '(' /*)*/ ) {
			/* todo: add math functions (all take single argument):
			 * abs acos asin atan cos cosh exp int log sin sinh sqrt
			 * tan tanh
			 */
			;
@


1.67
log
@got an SAR, thanks to dalias on IRC
@
text
@d561 1
a561 1
					setint(vasn, (mksh_ari_t)res);
@


1.66
log
@do use val.u on the RHS of a shift
@
text
@d496 4
a499 13
			if (es->natural)
				res = vl->val.u >> vr->val.u;
			else {
				/*
				 * This is implementation-defined in ISO C,
				 * though not undefined, and all known twos
				 * complement implementations make an arith
				 * shift-right out of this, and open-coding
				 * it would probably hurt massively.
				 */
				/* how about ANDing? */
				res = (mksh_uari_t)(vl->val.i >> vr->val.u);
			}
@


1.65
log
@ugh, signed >> on negative values is implementation-defined
(but, at least, not undefined, and usually right; regress-test for it)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.64 2013/04/01 01:02:09 tg Exp $");
d506 2
a507 2
				/* how about ANDing? use vr->val.u? */
				res = (mksh_uari_t)(vl->val.i >> vr->val.i);
@


1.64
log
@looks like multiplication is also the same between signed and unsigned
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.63 2013/03/31 18:33:13 tg Exp $");
d496 13
a508 2
			/* all bivui users need special handling */
			res = bivui(vl, >>, vr);
d512 1
@


1.63
log
@begin using unsigned arithmetics internally as much as possible
(i.e. where signedness doesn’t matter, given -fwrapv) and note
where there’s work to do; note future improvements and additions;
optimise a little

mostly untested
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.62 2013/03/29 16:54:05 tg Exp $");
d479 1
a479 2
			/* all bivui users need special handling */
			res = bivui(vl, *, vr);
d496 1
@


1.62
log
@RCSID-only sync: oksh found out about idivwrapv
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.61 2013/02/15 18:36:48 tg Exp $");
a69 1
#define IS_BINOP(op) (((int)op) >= (int)O_EQ && ((int)op) <= (int)O_COMMA)
d160 1
d310 26
d344 5
a348 3
		op = es->tok;
		if (op == O_BNOT || op == O_LNOT || op == O_MINUS ||
		    op == O_PLUS) {
d351 17
a367 8
			if (op == O_BNOT)
				vl->val.i = ~vl->val.i;
			else if (op == O_LNOT)
				vl->val.i = !vl->val.i;
			else if (op == O_MINUS)
				vl->val.i = -vl->val.i;
			/* op == O_PLUS is a no-op */
		} else if (op == OPEN_PAREN) {
d373 4
a376 1
		} else if (op == O_PLUSPLUS || op == O_MINUSMINUS) {
d380 4
a383 1
		} else if (op == VAR || op == LIT) {
d386 3
a388 1
		} else {
d392 1
d397 1
d399 1
d401 1
d403 2
a404 2
	for (op = es->tok; IS_BINOP(op) && opinfo[(int)op].prec == prec;
	    op = es->tok) {
d414 19
a432 1
		} else if (op != O_TERN && op != O_LAND && op != O_LOR)
d434 1
a434 7
		if ((op == O_DIV || op == O_MOD || op == O_DIVASN ||
		    op == O_MODASN) && vr->val.i == 0) {
			if (es->noassign)
				vr->val.i = 1;
			else
				evalerr(es, ET_STR, "zero divisor");
		}
a435 4
		case O_TIMES:
		case O_TIMESASN:
			res = bivui(vl, *, vr);
			break;
d438 2
a439 1
#if !HAVE_SILENT_IDIVWRAPV
d441 3
a443 5
			 * we are doing the comparisons here for the
			 * signed arithmetics (!es->natural) case,
			 * but the exact value checks and the bypass
			 * case assignments are done unsignedly as
			 * several compilers bitch around otherwise
d445 17
a461 7
			if (!es->natural &&
			    vl->val.u == IDIVWRAPV_VL &&
			    vr->val.u == IDIVWRAPV_VR) {
				/* -2147483648 / -1 = 2147483648 */
				/* this ^ is really (1 << 31) though */
				res = IDIVWRAPV_VL;
			} else
d463 13
a475 1
				res = bivui(vl, /, vr);
d477 4
a480 12
		case O_MOD:
		case O_MODASN:
#if !HAVE_SILENT_IDIVWRAPV
			/* see O_DIV / O_DIVASN for the reason behind this */
			if (!es->natural &&
			    vl->val.u == IDIVWRAPV_VL &&
			    vr->val.u == IDIVWRAPV_VR) {
				/* -2147483648 % -1 = 0 */
				res = 0;
			} else
#endif
				res = bivui(vl, %, vr);
d484 1
a484 1
			res = bivui(vl, +, vr);
d488 1
a488 1
			res = bivui(vl, -, vr);
d492 2
a493 1
			res = bivui(vl, <<, vr);
d499 1
d513 1
a513 1
			res = bivui(vl, ==, vr);
d516 1
a516 1
			res = bivui(vl, !=, vr);
d520 1
a520 1
			res = bivui(vl, &, vr);
d524 1
a524 1
			res = bivui(vl, ^, vr);
d528 1
a528 1
			res = bivui(vl, |, vr);
d531 1
a531 1
			if (!vl->val.i)
d534 2
a535 2
			res = bivui(vl, &&, vr);
			if (!vl->val.i)
d539 1
a539 1
			if (vl->val.i)
d542 2
a543 2
			res = bivui(vl, ||, vr);
			if (vl->val.i)
a545 20
		case O_TERN:
			{
				bool ev = vl->val.i != 0;

				if (!ev)
					es->noassign++;
				vl = evalexpr(es, MAX_PREC);
				if (!ev)
					es->noassign--;
				if (es->tok != CTERN)
					evalerr(es, ET_STR, "missing :");
				exprtoken(es);
				if (ev)
					es->noassign++;
				vr = evalexpr(es, P_TERN);
				if (ev)
					es->noassign--;
				vl = ev ? vl : vr;
			}
			break;
a546 2
			res = vr->val.u;
			break;
d551 1
d561 1
a561 1
		} else if (op != O_TERN)
a663 33
/* Do a ++ or -- operation */
static struct tbl *
do_ppmm(Expr_state *es, enum token op, struct tbl *vasn, bool is_prefix)
{
	struct tbl *vl;
	mksh_ari_t oval;

	assign_check(es, op, vasn);

	vl = intvar(es, vasn);
	oval = vl->val.i;
	if (op == O_PLUSPLUS) {
		if (es->natural)
			++vl->val.u;
		else
			++vl->val.i;
	} else {
		if (es->natural)
			--vl->val.u;
		else
			--vl->val.i;
	}
	if (vasn->flag & INTEGER)
		setint_v(vasn, vl, es->arith);
	else
		setint(vasn, vl->val.i);
	if (!is_prefix)
		/* undo the increment/decrement */
		vl->val.i = oval;

	return (vl);
}

@


1.61
log
@prevent more access to invalid memories (Debian #700604)
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.21 2009/06/01 19:00:57 deraadt Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.60 2012/10/03 17:24:19 tg Exp $");
@


1.60
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d5 1
a5 1
 *		 2011, 2012
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.59 2012/09/01 23:46:41 tg Exp $");
d142 18
a159 12
typedef struct expr_state Expr_state;
struct expr_state {
	const char *expression;		/* expression being evaluated */
	const char *tokp;		/* lexical position */
	struct tbl *val;		/* value from token() */
	struct tbl *evaling;		/* variable that is being recursively
					 * expanded (EXPRINEVAL flag set) */
	int noassign;			/* don't do assigns (for ?:,&&,||) */
	enum token tok;			/* token from token() */
	bool arith;			/* evaluating an $(()) expression? */
	bool natural;			/* unsigned arithmetic calculation */
};
d208 1
d210 1
a210 1
	curstate.noassign = 0;
a211 2
	curstate.evaling = NULL;
	curstate.natural = false;
d649 1
a649 1
	if (es->tok == END ||
@


1.60.2.1
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.60 2012/10/03 17:24:19 tg Exp $");
a201 1
	memset(&curstate, 0, sizeof(curstate));
d203 1
a203 1
	curstate.tok = BAD;
d205 2
d644 1
a644 1
	if (es->tok == END || !vasn ||
@


1.59
log
@Update wcwidth data from Unicode 6.1.0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.58 2012/06/28 20:17:36 tg Exp $");
d156 2
a157 2
	(mksh_ari_t)((x)->val.u op (y)->val.u) :	\
	(mksh_ari_t)((x)->val.i op (y)->val.i)		\
a158 6
#define stvui(x, n)	do {			\
	if (es->natural)			\
		(x)->val.u = (n);		\
	else					\
		(x)->val.i = (n);		\
} while (/* CONSTCOND */ 0)
d310 1
a310 1
	mksh_ari_t res = 0;
d389 1
a389 1
				res = (mksh_ari_t)IDIVWRAPV_VL;
d490 1
a490 1
			res = vr->val.i;
d493 1
a493 1
			res = vr->val.i;
d497 1
a497 1
			stvui(vr, res);
d502 1
a502 1
					setint(vasn, res);
d506 1
a506 1
			stvui(vl, res);
@


1.58
log
@(mksh) tighten 32-bit requirements; (lksh) switch to long; allow any bitness
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.56 2012/03/31 17:52:33 tg Exp $");
d848 1
a848 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.10 2010/12/11 16:05:03 tg Exp $");
d857 1
a857 1
		/* Unicode 6.0.0 BMP */
d860 1
a860 1
		{ 0x05C7, 0x05C7 }, { 0x0600, 0x0603 }, { 0x0610, 0x061A },
d866 43
a908 42
		{ 0x0859, 0x085B }, { 0x0900, 0x0902 }, { 0x093A, 0x093A },
		{ 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
		{ 0x0951, 0x0957 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
		{ 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
		{ 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
		{ 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
		{ 0x0A51, 0x0A51 }, { 0x0A70, 0x0A71 }, { 0x0A75, 0x0A75 },
		{ 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC }, { 0x0AC1, 0x0AC5 },
		{ 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD }, { 0x0AE2, 0x0AE3 },
		{ 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C }, { 0x0B3F, 0x0B3F },
		{ 0x0B41, 0x0B44 }, { 0x0B4D, 0x0B4D }, { 0x0B56, 0x0B56 },
		{ 0x0B62, 0x0B63 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
		{ 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
		{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0C62, 0x0C63 },
		{ 0x0CBC, 0x0CBC }, { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 },
		{ 0x0CCC, 0x0CCD }, { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D44 },
		{ 0x0D4D, 0x0D4D }, { 0x0D62, 0x0D63 }, { 0x0DCA, 0x0DCA },
		{ 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
		{ 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
		{ 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
		{ 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
		{ 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
		{ 0x0F86, 0x0F87 }, { 0x0F8D, 0x0F97 }, { 0x0F99, 0x0FBC },
		{ 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1037 },
		{ 0x1039, 0x103A }, { 0x103D, 0x103E }, { 0x1058, 0x1059 },
		{ 0x105E, 0x1060 }, { 0x1071, 0x1074 }, { 0x1082, 0x1082 },
		{ 0x1085, 0x1086 }, { 0x108D, 0x108D }, { 0x109D, 0x109D },
		{ 0x1160, 0x11FF }, { 0x135D, 0x135F }, { 0x1712, 0x1714 },
		{ 0x1732, 0x1734 }, { 0x1752, 0x1753 }, { 0x1772, 0x1773 },
		{ 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
		{ 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD }, { 0x180B, 0x180D },
		{ 0x18A9, 0x18A9 }, { 0x1920, 0x1922 }, { 0x1927, 0x1928 },
		{ 0x1932, 0x1932 }, { 0x1939, 0x193B }, { 0x1A17, 0x1A18 },
		{ 0x1A56, 0x1A56 }, { 0x1A58, 0x1A5E }, { 0x1A60, 0x1A60 },
		{ 0x1A62, 0x1A62 }, { 0x1A65, 0x1A6C }, { 0x1A73, 0x1A7C },
		{ 0x1A7F, 0x1A7F }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
		{ 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
		{ 0x1B6B, 0x1B73 }, { 0x1B80, 0x1B81 }, { 0x1BA2, 0x1BA5 },
		{ 0x1BA8, 0x1BA9 }, { 0x1BE6, 0x1BE6 }, { 0x1BE8, 0x1BE9 },
		{ 0x1BED, 0x1BED }, { 0x1BEF, 0x1BF1 }, { 0x1C2C, 0x1C33 },
		{ 0x1C36, 0x1C37 }, { 0x1CD0, 0x1CD2 }, { 0x1CD4, 0x1CE0 },
		{ 0x1CE2, 0x1CE8 }, { 0x1CED, 0x1CED }, { 0x1DC0, 0x1DE6 },
d912 10
a921 9
		{ 0x302A, 0x302F }, { 0x3099, 0x309A }, { 0xA66F, 0xA672 },
		{ 0xA67C, 0xA67D }, { 0xA6F0, 0xA6F1 }, { 0xA802, 0xA802 },
		{ 0xA806, 0xA806 }, { 0xA80B, 0xA80B }, { 0xA825, 0xA826 },
		{ 0xA8C4, 0xA8C4 }, { 0xA8E0, 0xA8F1 }, { 0xA926, 0xA92D },
		{ 0xA947, 0xA951 }, { 0xA980, 0xA982 }, { 0xA9B3, 0xA9B3 },
		{ 0xA9B6, 0xA9B9 }, { 0xA9BC, 0xA9BC }, { 0xAA29, 0xAA2E },
		{ 0xAA31, 0xAA32 }, { 0xAA35, 0xAA36 }, { 0xAA43, 0xAA43 },
		{ 0xAA4C, 0xAA4C }, { 0xAAB0, 0xAAB0 }, { 0xAAB2, 0xAAB4 },
		{ 0xAAB7, 0xAAB8 }, { 0xAABE, 0xAABF }, { 0xAAC1, 0xAAC1 },
@


1.58.2.1
log
@MFC cid 10050429E542CD63CF1: update wcwidth data from Unicode 6.1.0
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.58 2012/06/28 20:17:36 tg Exp $");
d848 1
a848 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.11 2012/09/01 23:46:43 tg Exp $");
d857 1
a857 1
		/* Unicode 6.1.0 BMP */
d860 1
a860 1
		{ 0x05C7, 0x05C7 }, { 0x0600, 0x0604 }, { 0x0610, 0x061A },
d866 42
a907 43
		{ 0x0859, 0x085B }, { 0x08E4, 0x08FE }, { 0x0900, 0x0902 },
		{ 0x093A, 0x093A }, { 0x093C, 0x093C }, { 0x0941, 0x0948 },
		{ 0x094D, 0x094D }, { 0x0951, 0x0957 }, { 0x0962, 0x0963 },
		{ 0x0981, 0x0981 }, { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 },
		{ 0x09CD, 0x09CD }, { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 },
		{ 0x0A3C, 0x0A3C }, { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 },
		{ 0x0A4B, 0x0A4D }, { 0x0A51, 0x0A51 }, { 0x0A70, 0x0A71 },
		{ 0x0A75, 0x0A75 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
		{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
		{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
		{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B44 }, { 0x0B4D, 0x0B4D },
		{ 0x0B56, 0x0B56 }, { 0x0B62, 0x0B63 }, { 0x0B82, 0x0B82 },
		{ 0x0BC0, 0x0BC0 }, { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 },
		{ 0x0C46, 0x0C48 }, { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 },
		{ 0x0C62, 0x0C63 }, { 0x0CBC, 0x0CBC }, { 0x0CBF, 0x0CBF },
		{ 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD }, { 0x0CE2, 0x0CE3 },
		{ 0x0D41, 0x0D44 }, { 0x0D4D, 0x0D4D }, { 0x0D62, 0x0D63 },
		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F8D, 0x0F97 },
		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
		{ 0x1032, 0x1037 }, { 0x1039, 0x103A }, { 0x103D, 0x103E },
		{ 0x1058, 0x1059 }, { 0x105E, 0x1060 }, { 0x1071, 0x1074 },
		{ 0x1082, 0x1082 }, { 0x1085, 0x1086 }, { 0x108D, 0x108D },
		{ 0x109D, 0x109D }, { 0x1160, 0x11FF }, { 0x135D, 0x135F },
		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
		{ 0x1A17, 0x1A18 }, { 0x1A56, 0x1A56 }, { 0x1A58, 0x1A5E },
		{ 0x1A60, 0x1A60 }, { 0x1A62, 0x1A62 }, { 0x1A65, 0x1A6C },
		{ 0x1A73, 0x1A7C }, { 0x1A7F, 0x1A7F }, { 0x1B00, 0x1B03 },
		{ 0x1B34, 0x1B34 }, { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C },
		{ 0x1B42, 0x1B42 }, { 0x1B6B, 0x1B73 }, { 0x1B80, 0x1B81 },
		{ 0x1BA2, 0x1BA5 }, { 0x1BA8, 0x1BA9 }, { 0x1BAB, 0x1BAB },
		{ 0x1BE6, 0x1BE6 }, { 0x1BE8, 0x1BE9 }, { 0x1BED, 0x1BED },
		{ 0x1BEF, 0x1BF1 }, { 0x1C2C, 0x1C33 }, { 0x1C36, 0x1C37 },
		{ 0x1CD0, 0x1CD2 }, { 0x1CD4, 0x1CE0 }, { 0x1CE2, 0x1CE8 },
		{ 0x1CED, 0x1CED }, { 0x1CF4, 0x1CF4 }, { 0x1DC0, 0x1DE6 },
d911 9
a919 10
		{ 0x302A, 0x302D }, { 0x3099, 0x309A }, { 0xA66F, 0xA672 },
		{ 0xA674, 0xA67D }, { 0xA69F, 0xA69F }, { 0xA6F0, 0xA6F1 },
		{ 0xA802, 0xA802 }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
		{ 0xA825, 0xA826 }, { 0xA8C4, 0xA8C4 }, { 0xA8E0, 0xA8F1 },
		{ 0xA926, 0xA92D }, { 0xA947, 0xA951 }, { 0xA980, 0xA982 },
		{ 0xA9B3, 0xA9B3 }, { 0xA9B6, 0xA9B9 }, { 0xA9BC, 0xA9BC },
		{ 0xAA29, 0xAA2E }, { 0xAA31, 0xAA32 }, { 0xAA35, 0xAA36 },
		{ 0xAA43, 0xAA43 }, { 0xAA4C, 0xAA4C }, { 0xAAB0, 0xAAB0 },
		{ 0xAAB2, 0xAAB4 }, { 0xAAB7, 0xAAB8 }, { 0xAABE, 0xAABF },
		{ 0xAAC1, 0xAAC1 }, { 0xAAEC, 0xAAED }, { 0xAAF6, 0xAAF6 },
@


1.58.2.2
log
@MFC cid 100511E80597C703B9A and 100511E837A3084211A
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.58.2.1 2012/09/03 19:10:41 tg Exp $");
a207 1
	memset(&curstate, 0, sizeof(curstate));
d209 1
a209 1
	curstate.tok = BAD;
d211 2
d650 1
a650 1
	if (es->tok == END || !vasn ||
@


1.57
log
@make tempvar() and vtemp global
@
text
@d28 14
d391 2
a392 2
			    vl->val.u == (mksh_uari_t)0x80000000UL &&
			    vr->val.u == (mksh_uari_t)0xFFFFFFFFUL) {
d395 1
a395 1
				res = (mksh_ari_t)(mksh_uari_t)0x80000000UL;
d405 2
a406 2
			    vl->val.u == (mksh_uari_t)0x80000000UL &&
			    vr->val.u == (mksh_uari_t)0xFFFFFFFFUL) {
@


1.56
log
@I give up on writing (1 << 31) in any form.

Now we just use 0x80000000UL and cast that to mksh_uari_t and,
if required, that to mksh_ari_t afterwards.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.55 2012/03/31 17:29:59 tg Exp $");
a162 1
static struct tbl *tempvar(void);
d643 1
a643 1
static struct tbl *
@


1.55
log
@use _setjmp/_longjmp on NeXTstep: its Intel port always restores the signal mask on siglongjmp, which we never have
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.54 2012/03/29 19:22:58 tg Exp $");
d370 10
a379 2
			if (!es->natural && vr->val.i == -1 &&
			    vl->val.i == ((mksh_ari_t)-2147483648)) {
d382 1
a382 2
				/* 80000000 / FFFFFFFF = 80000000 */
				res = ((mksh_ari_t)-2147483648);
d390 4
a393 2
			if (!es->natural && vr->val.i == -1 &&
			    vl->val.i == ((mksh_ari_t)-2147483648)) {
@


1.54
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.53 2011/12/31 02:04:18 tg Exp $");
d202 1
a202 2
	i = sigsetjmp(e->jbuf, 0);
	if (i) {
@


1.53
log
@followup for cid 1004EE408E1382C1752 and 1004EE40DDD498FBB0D:
do a mirtoconf run-time check (ugh) to see whether the CPU designers
smoked/were brain-dead or if we don’t actually need the manual check
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.52 2011/12/16 20:03:02 tg Exp $");
d372 1
a372 1
			    vl->val.i == ((mksh_ari_t)1 << 31)) {
d374 1
d376 1
a376 1
				res = ((mksh_ari_t)1 << 31);
d385 1
a385 1
			    vl->val.i == ((mksh_ari_t)1 << 31)) {
@


1.52
log
@skip R/O check in an unevaluated ternary part; 10x jilles
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.51 2011/12/11 01:56:43 tg Exp $");
d369 1
d376 1
d381 1
d387 1
@


1.51
log
@actually, behave with silent wraparound; results validated by bc(1)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.49 2011/09/07 15:24:14 tg Exp $");
d287 1
a287 1
		    es->expression, str, "applied to read only variable");
d350 2
a351 1
			assign_check(es, op, vasn);
d613 2
a614 1
	if (!is_prefix)		/* undo the inc/dec */
@


1.51.2.1
log
@MFC all those nice things (not all parts, by now); sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.53 2011/12/31 02:04:18 tg Exp $");
d350 1
a350 2
			if (!es->noassign)
				assign_check(es, op, vasn);
a367 1
#if !HAVE_SILENT_IDIVWRAPV
a373 1
#endif
a377 1
#if !HAVE_SILENT_IDIVWRAPV
a382 1
#endif
d612 1
a612 2
	if (!is_prefix)
		/* undo the increment/decrement */
@


1.51.2.2
log
@MFC fixes from HEAD
@
text
@d4 1
a4 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.56 2012/03/31 17:52:33 tg Exp $");
d201 2
a202 1
	if ((i = kshsetjmp(e->jbuf))) {
d370 2
a371 10
			/*
			 * we are doing the comparisons here for the
			 * signed arithmetics (!es->natural) case,
			 * but the exact value checks and the bypass
			 * case assignments are done unsignedly as
			 * several compilers bitch around otherwise
			 */
			if (!es->natural &&
			    vl->val.u == (mksh_uari_t)0x80000000UL &&
			    vr->val.u == (mksh_uari_t)0xFFFFFFFFUL) {
d373 2
a374 2
				/* this ^ is really (1 << 31) though */
				res = (mksh_ari_t)(mksh_uari_t)0x80000000UL;
d382 2
a383 4
			/* see O_DIV / O_DIVASN for the reason behind this */
			if (!es->natural &&
			    vl->val.u == (mksh_uari_t)0x80000000UL &&
			    vr->val.u == (mksh_uari_t)0xFFFFFFFFUL) {
@


1.50
log
@catch intmin/-1 instead of dumping core on SIGFPE; from Jilles Tjoelker
@
text
@d346 2
a347 1
		if (op != O_ASN) /* vl may not have a value yet */
d355 1
a355 2
		    op == O_MODASN) && (vr->val.i == 0 || (!es->natural &&
		    vr->val.i == -1 && vl->val.i == -2147483648))) {
d359 1
a359 1
				evalerr(es, ET_STR, "invalid divisor");
d368 7
a374 1
			res = bivui(vl, /, vr);
d378 6
a383 1
			res = bivui(vl, %, vr);
@


1.49
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.48 2011/08/27 18:06:44 tg Exp $");
d354 2
a355 1
		    op == O_MODASN) && vr->val.i == 0) {
d359 1
a359 1
				evalerr(es, ET_STR, "zero divisor");
@


1.48
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.47 2010/12/11 16:05:03 tg Exp $");
d916 19
@


1.47
log
@regenerate all wcwidth code from UCD 6.0.0 and related tables,
and mgk25’s wcwidth.c 5.0 code; add check against 2-byte wchar_t;
optimise libc wcwidth(3) implementation taken from mksh and sync these
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.46 2010/11/01 17:28:49 tg Exp $");
a143 6
#define chvui(x, op)	do {			\
	if (es->natural)			\
		(x)->val.u = op (x)->val.u;	\
	else					\
		(x)->val.i = op (x)->val.i;	\
} while (/* CONSTCOND */ 0)
d312 1
a312 1
				chvui(vl, ~);
d314 1
a314 1
				chvui(vl, !);
d316 1
a316 1
				chvui(vl, -);
d502 1
a502 1
			int len;
d679 1
a679 1
int
d682 1
a682 1
	size_t len;
d684 1
a684 1
	int width = 0, cw;
@


1.46
log
@regenerate from Unicode 6.0.0
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.45 2010/08/28 18:50:50 tg Exp $");
d813 1
a813 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.8 2008/09/20 12:01:18 tg Exp $");
d892 1
a892 1
	if (c < 32 || (c >= 0x7f && c < 0xa0))
d908 1
d910 9
a918 9
	    c <= 0x115f || /* Hangul Jamo init. consonants */
	    c == 0x2329 || c == 0x232a ||
	    (c >= 0x2e80 && c <= 0xa4cf && c != 0x303f) || /* CJK ... Yi */
	    (c >= 0xac00 && c <= 0xd7a3) || /* Hangul Syllables */
	    (c >= 0xf900 && c <= 0xfaff) || /* CJK Compatibility Ideographs */
	    (c >= 0xfe10 && c <= 0xfe19) || /* Vertical forms */
	    (c >= 0xfe30 && c <= 0xfe6f) || /* CJK Compatibility Forms */
	    (c >= 0xff00 && c <= 0xff60) || /* Fullwidth Forms */
	    (c >= 0xffe0 && c <= 0xffe6))) ? 2 : 1);
@


1.45
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.44 2010/08/14 21:35:13 tg Exp $");
d822 6
a827 5
		{ 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
		{ 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
		{ 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
		{ 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
		{ 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
d829 3
a831 1
		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
d833 1
a833 1
		{ 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
d837 6
a842 5
		{ 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
		{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
		{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
		{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
		{ 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
d844 23
a866 18
		{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
		{ 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
		{ 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
		{ 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
		{ 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
		{ 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
d868 20
a887 6
		{ 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
		{ 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
		{ 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
		{ 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
		{ 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
		{ 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
@


1.44
log
@on MirBSD we can use the system wcwidth() and save ~800by on the ramdisc
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.43 2010/01/25 14:38:00 tg Exp $");
d272 2
a273 1
		warningf(true, "%s: unexpected '%s'", es->expression, s);
d277 2
a278 1
		warningf(true, "%s: bad number '%s'", es->expression, str);
d282 2
a283 2
		warningf(true, "%s: expression recurses on parameter '%s'",
		    es->expression, str);
d287 2
a288 2
		warningf(true, "%s: %s requires lvalue",
		    es->expression, str);
d292 2
a293 2
		warningf(true, "%s: %s applied to read only variable",
		    es->expression, str);
@


1.43
log
@remove some debugging code
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.42 2009/12/12 22:27:06 tg Exp $");
d801 1
d895 1
@


1.42
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.41 2009/12/08 19:23:34 tg Exp $");
a628 3
#ifdef notyet_ktremove
	vp->tablep = NULL;
#endif
@


1.41
log
@HP aCC tells me I'm using "const" twice, and /usr/ccs/bin/cc even
errors out here. Let's hope that this form will *still* have the
entirety of that array in .rodata...

XXX more to come, thanks to HP DSPP PvP, e.g. __attribute__ stuff
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.40 2009/12/05 20:17:58 tg Exp $");
d163 1
a163 1
    __attribute__((noreturn));
@


1.40
log
@attempt a better fix: break off widthadj upon encountering NUL,
add remaining columns as octets (should also speed optimise)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.39 2009/11/28 14:28:00 tg Exp $");
d821 1
a821 1
	} const comb[] = {
@


1.39
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.37 2009/10/04 13:19:33 tg Exp $");
d713 3
a715 1
	while (c < cols)
d717 1
@


1.38
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@a685 7
/**
 * In lenient mode, characters of width -1 are handled as one column
 * per octet (kind of as a strlen replacement). Users of lenient mo-
 * de should reconsider the code.
 * In strict mode, this behaves like wcswidth(3) and returns -1 upon
 * encounter of a control multibyte character.
 */
d687 1
a687 1
utf_mbswidth(const char *s, bool lenient)
d697 2
a698 2
		if ((len = utf_mbtowc(&wc, s)) == (size_t)-1) {
 by_octet:
a700 4
		} else if ((cw = utf_wcwidth(wc)) == -1) {
			if (lenient)
				goto by_octet;
			return (-1);
@


1.37
log
@fix lazy evaluation of assignments in ternary ops
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.36 2009/09/26 04:01:32 tg Exp $");
d686 7
d694 1
a694 1
utf_mbswidth(const char *s)
d704 2
a705 2
		if (((len = utf_mbtowc(&wc, s)) == (size_t)-1) ||
		    ((cw = utf_wcwidth(wc)) == -1)) {
d708 4
@


1.37.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.38 2009/11/28 14:21:44 tg Exp $");
a685 7
/**
 * In lenient mode, characters of width -1 are handled as one column
 * per octet (kind of as a strlen replacement). Users of lenient mo-
 * de should reconsider the code.
 * In strict mode, this behaves like wcswidth(3) and returns -1 upon
 * encounter of a control multibyte character.
 */
d687 1
a687 1
utf_mbswidth(const char *s, bool lenient)
d697 2
a698 2
		if ((len = utf_mbtowc(&wc, s)) == (size_t)-1) {
 by_octet:
a700 4
		} else if ((cw = utf_wcwidth(wc)) == -1) {
			if (lenient)
				goto by_octet;
			return (-1);
@


1.36
log
@* move the utf_* functions to a smaller file, to reduce the pain the
  CPU has to endure while gcc is crunching on edit.c
* comment on mksh not using _exactly_ OPTU-8/OPTU-16 (XXX)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.35 2009/09/23 18:04:55 tg Exp $");
d468 6
a473 4
			if (vasn->flag & INTEGER)
				setint_v(vasn, vr, es->arith);
			else
				setint(vasn, res);
@


1.35
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.34 2009/09/06 17:55:54 tg Exp $");
d659 233
@


1.34
log
@Support Dave Korn’s alternative 「'a'」 (or 「'…'」) form for base-one
integers in addition to my 「1#a」 (or 「1#…」), which also allows for
finer end-of-character checking. Note that this is locale-dependent in
ksh93, set ±U dependent in mksh, and mksh’s OPTU-16 encoding is used.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.33 2009/08/28 21:01:25 tg Exp $");
d531 1
d546 1
@


1.33
log
@… but since I liked the bonus of having the hval stored so much, merge
it with the array index; var.c says that
│ 1244         /* The table entry is always [0] */
so that we can have a special flag and a union which stores hval for
the table index, the array index otherwise (coïncidentally *hint hint*
they have the same size)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.32 2009/08/28 20:38:41 tg Exp $");
d531 14
@


1.32
log
@for now, until we really use kt*() otherwise, ifdef out tablep/hval
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.31 2009/08/28 20:30:55 tg Exp $");
a612 1
	vp->hval = 0;
d614 1
@


1.31
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.30 2009/08/08 13:08:50 tg Exp $");
d611 1
d614 1
@


1.30
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.29 2009/06/10 18:12:45 tg Exp $");
d611 2
@


1.29
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.28 2009/06/08 20:13:07 tg Exp $");
d548 2
a549 2
			if (c == n0 &&
			    strncmp(cp, opinfo[i].name, opinfo[i].len) == 0) {
@


1.28
log
@merge fix from oksh:
"let --" was crashing ksh; found by phy0@@rambler.ru.  Various other expressions
involving ++ and -- also ran into this. Insufficient checks for end of parse in
the tokenizer made it assume that an lvalue had been found
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.27 2009/06/08 20:06:45 tg Exp $");
d82 1
a82 1
 * (eg, += before +).  If you change something, change the order
d141 3
a143 3
	    (mksh_ari_t)((x)->val.u op (y)->val.u) :	\
	    (mksh_ari_t)((x)->val.i op (y)->val.i)	\
	)
@


1.27
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.19 2006/04/10 14:38:59 jaredy Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.26 2009/05/16 16:59:35 tg Exp $");
d595 2
a596 1
	if (vasn->name[0] == '\0' && !(vasn->flag & EXPRLVALUE))
@


1.26
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.25 2009/05/16 15:09:07 tg Exp $");
d606 1
a606 1
	vp = alloc(sizeof (struct tbl), ATEMP);
@


1.25
log
@split utf_ptradjx into utf_ptradj function (to save space) and
self-assignment macro; remove some uses of the macro in favour
of foo += utf_ptradj(foo)
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.24 2009/04/07 18:41:35 tg Exp $");
@


1.24
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.23 2009/03/14 18:12:52 tg Exp $");
d508 1
a508 1
		utf_ptradjx(cp, cp);
@


1.23
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.22 2008/12/17 19:39:21 tg Exp $");
a110 2
	enum token tok;			/* token from token() */
	int noassign;			/* don't do assigns (for ?:,&&,||) */
d114 2
@


1.22
log
@implement unsigned arithmetics as an mksh extension
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.21 2008/12/13 17:02:13 tg Exp $");
d120 3
a122 3
#define bivui(x, op, y)	(es->natural ?		\
	    (long)((x)->val.u op (y)->val.u) :	\
	    (long)((x)->val.i op (y)->val.i)	\
d155 1
a155 1
evaluate(const char *expr, long int *rval, int error_ok, bool arith)
d287 1
a287 1
	long res = 0;
d545 1
a545 1
	long oval;
@


1.21
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.20 2008/11/12 00:54:48 tg Exp $");
d117 1
d120 17
d184 1
d212 2
d296 1
a296 1
				vl->val.i = ~vl->val.i;
d298 1
a298 1
				vl->val.i = !vl->val.i;
d300 1
a300 1
				vl->val.i = -vl->val.i;
d326 1
a326 1
	for (op = es->tok; IS_BINOP(op) && opinfo[(int) op].prec == prec;
d344 1
a344 1
		switch ((int) op) {
d347 1
a347 1
			res = vl->val.i * vr->val.i;
d351 1
a351 1
			res = vl->val.i / vr->val.i;
d355 1
a355 1
			res = vl->val.i % vr->val.i;
d359 1
a359 1
			res = vl->val.i + vr->val.i;
d363 1
a363 1
			res = vl->val.i - vr->val.i;
d367 1
a367 1
			res = vl->val.i << vr->val.i;
d371 1
a371 1
			res = vl->val.i >> vr->val.i;
d374 1
a374 1
			res = vl->val.i < vr->val.i;
d377 1
a377 1
			res = vl->val.i <= vr->val.i;
d380 1
a380 1
			res = vl->val.i > vr->val.i;
d383 1
a383 1
			res = vl->val.i >= vr->val.i;
d386 1
a386 1
			res = vl->val.i == vr->val.i;
d389 1
a389 1
			res = vl->val.i != vr->val.i;
d393 1
a393 1
			res = vl->val.i & vr->val.i;
d397 1
a397 1
			res = vl->val.i ^ vr->val.i;
d401 1
a401 1
			res = vl->val.i | vr->val.i;
d407 1
a407 1
			res = vl->val.i && vr->val.i;
d415 1
a415 1
			res = vl->val.i || vr->val.i;
d421 1
a421 1
				int ev = vl->val.i != 0;
d447 1
a447 1
			vr->val.i = res;
d454 1
a454 1
			vl->val.i = res;
d462 1
a462 1
	const char *cp;
d467 9
a475 2
	for (cp = es->tokp; (c = *cp), ksh_isspace(c); cp++)
		;
d530 1
a530 1
				es->tok = (enum token) i;
d545 1
a545 1
	int oval;
d550 12
a561 1
	oval = op == O_PLUSPLUS ? vl->val.i++ : vl->val.i--;
d576 1
a576 1
		evalerr(es, ET_LVALUE, opinfo[(int) op].name);
d578 1
a578 1
		evalerr(es, ET_RDONLY, opinfo[(int) op].name);
@


1.20
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.19 2008/10/28 14:32:40 tg Exp $");
d547 1
a547 1
	vp = alloc(1, sizeof (struct tbl), ATEMP);
@


1.20.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.20 2008/11/12 00:54:48 tg Exp $");
d475 1
a475 1
			gfree(tvar, ATEMP);
d494 1
a494 1
		gfree(tvar, ATEMP);
d547 1
a547 1
	vp = galloc(1, sizeof (struct tbl), ATEMP);
d550 1
a550 1
	vp->gp_tbl = ATEMP;
@


1.19
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.18 2008/07/12 16:56:38 tg Exp $");
d547 1
a547 1
	vp = (struct tbl *)alloc(sizeof (struct tbl), ATEMP);
@


1.18
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.17 2008/04/20 00:24:25 tg Exp $");
d473 1
a473 1
			tvar = str_nsave(es->tokp, cp - es->tokp, ATEMP);
d479 3
a481 2
		utf_cptradj(cp + 2, &cp);
		tvar = str_nsave(es->tokp, cp - es->tokp, ATEMP);
a483 2
		int i;

d486 1
a486 2
		i = --cp - es->tokp;
		tvar = str_nsave(es->tokp, i, ATEMP);
@


1.17
log
@mostly revert 100480A853206FB56FA and parse utf-8 lead bytes ourselves
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.15 2008/04/19 22:15:02 tg Exp $");
d483 2
d487 2
a488 1
		tvar = str_nsave(es->tokp, --cp - es->tokp, ATEMP);
@


1.16
log
@solve the issue (although not quite how I’d like it)
@
text
@a480 5
		if (*cp) {
			*tvar = '\0';	/* produce an artificial error */
			while (*cp)	/* and skip until end of expr */
				++cp;
		}
@


1.15
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.14 2008/03/28 13:33:37 tg Exp $");
d481 5
@


1.14
log
@don’t do arithmetics on an enumerated type, sez the MIPSpro complainer
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.13 2007/10/25 15:19:16 tg Exp $");
d478 4
d483 2
a484 2
		for (; c != '_' && (ksh_isalnux(c) || c == '#'); c = *cp++)
			;
d486 1
@


1.13
log
@optimise (struct padding, function→macro, etc.)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.12 2007/07/22 14:01:48 tg Exp $");
d38 15
a52 16
enum prec {
	P_PRIMARY = 0,		/* VAR, LIT, (), ~ ! - + */
	P_MULT,			/* * / % */
	P_ADD,			/* + - */
	P_SHIFT,		/* << >> */
	P_RELATION,		/* < <= > >= */
	P_EQUALITY,		/* == != */
	P_BAND,			/* & */
	P_BXOR,			/* ^ */
	P_BOR,			/* | */
	P_LAND,			/* && */
	P_LOR,			/* || */
	P_TERN,			/* ?: */
	P_ASSIGN,		/* = *= /= %= += -= <<= >>= &= ^= |= */
	P_COMMA			/* , */
};
d58 1
a58 1
	enum prec	prec;	/* precedence: lower is higher */
d126 1
a126 1
static struct tbl *evalexpr(Expr_state *, enum prec);
d262 1
a262 1
evalexpr(Expr_state *es, enum prec prec)
d304 1
a304 1
	vl = evalexpr(es, ((int) prec) - 1);
d315 1
a315 1
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
d385 1
a385 1
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
d393 1
a393 1
			vr = intvar(es, evalexpr(es, ((int) prec) - 1));
@


1.13.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.14 2008/03/28 13:33:37 tg Exp $");
d38 16
a53 15
/* precisions; used to be enum prec but we do arithmetics on it */
#define P_PRIMARY	0	/* VAR, LIT, (), ~ ! - + */
#define P_MULT		1	/* * / % */
#define P_ADD		2	/* + - */
#define P_SHIFT		3	/* << >> */
#define P_RELATION	4	/* < <= > >= */
#define P_EQUALITY	5	/* == != */
#define P_BAND		6	/* & */
#define P_BXOR		7	/* ^ */
#define P_BOR		8	/* | */
#define P_LAND		9	/* && */
#define P_LOR		10	/* || */
#define P_TERN		11	/* ?: */
#define P_ASSIGN	12	/* = *= /= %= += -= <<= >>= &= ^= |= */
#define P_COMMA		13	/* , */
d59 1
a59 1
	int		prec;	/* precedence: lower is higher */
d127 1
a127 1
static struct tbl *evalexpr(Expr_state *, int);
d263 1
a263 1
evalexpr(Expr_state *es, int prec)
d305 1
a305 1
	vl = evalexpr(es, prec - 1);
d316 1
a316 1
			vr = intvar(es, evalexpr(es, prec - 1));
d386 1
a386 1
			vr = intvar(es, evalexpr(es, prec - 1));
d394 1
a394 1
			vr = intvar(es, evalexpr(es, prec - 1));
@


1.13.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.17 2008/04/20 00:24:25 tg Exp $");
a477 4
	} else if (c == '1' && cp[1] == '#') {
		utf_cptradj(cp + 2, &cp);
		tvar = str_nsave(es->tokp, cp - es->tokp, ATEMP);
		goto process_tvar;
d479 2
a480 2
		while (c != '_' && (ksh_isalnux(c) || c == '#'))
			c = *cp++;
a481 1
 process_tvar:
@


1.13.2.3
log
@MFC: mksh R35b
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
a482 2
		int i;

d485 1
a485 2
		i = --cp - es->tokp;
		tvar = str_nsave(es->tokp, i, ATEMP);
@


1.13.2.4
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.21 2008/12/13 17:02:13 tg Exp $");
d473 1
a473 1
			strndupx(tvar, es->tokp, cp - es->tokp, ATEMP);
d479 2
a480 3
		cp += 2;
		utf_ptradjx(cp, cp);
		strndupx(tvar, es->tokp, cp - es->tokp, ATEMP);
d483 2
d487 2
a488 1
		strndupx(tvar, es->tokp, --cp - es->tokp, ATEMP);
d549 1
a549 1
	vp = alloc(sizeof (struct tbl), ATEMP);
@


1.12
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.11 2007/07/22 13:34:49 tg Exp $");
a113 3
	bool arith;			/* true if evaluating an $(())
					 * expression
					 */
d116 2
a117 2
					 * expanded (EXPRINEVAL flag set)
					 */
@


1.11
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.10 2007/03/04 03:04:25 tg Exp $");
d181 1
a181 1
			errorf("");
@


1.10
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.9 2007/03/03 21:12:51 tg Exp $");
d181 1
a181 1
			errorf(null);
@


1.9
log
@don't have two functions token(), helps ctags
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.8 2007/01/17 22:51:46 tg Exp $");
d105 1
a105 1
	{ "",	 0, P_PRIMARY } /* end of table */
a107 1

d112 3
a114 3
	enum token  tok;		/* token from token() */
	int	    noassign;		/* don't do assigns (for ?:,&&,||) */
	bool	    arith;		/* true if evaluating an $(())
d131 1
a131 1
static void	   exprtoken(Expr_state *);
d133 1
a133 1
static void	   assign_check(Expr_state *, enum token, struct tbl *);
d150 1
a150 1
	return ret;
d180 1
a180 1
				return 0;
d205 1
a205 1
	return 1;
d306 1
a306 1
		return vl;
d439 1
a439 1
	return vl;
d528 1
a528 1
	return vl;
d545 1
a545 1
	vp = (struct tbl*) alloc(sizeof(struct tbl), ATEMP);
d551 1
a551 1
	return vp;
d563 1
a563 1
		return vp;
d575 1
a575 1
	return vq;
@


1.8
log
@* support old environments without libgen.h (ancient GNU/Linux)
  and stdbool.h (ancient GNU/Linux; NetBSD® 1.6.1)
* __dead must come after, not before, to accomodate gcc 2.7.2.3
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.7 2007/01/12 01:49:27 tg Exp $");
d132 1
a132 1
static void	   token(Expr_state *);
d188 1
a188 1
	token(es);
d277 1
a277 1
			token(es);
d287 1
a287 1
			token(es);
d291 1
a291 1
			token(es);
d293 1
a293 1
			token(es);
d295 1
a295 1
			token(es);
d298 1
a298 1
			token(es);
d305 1
a305 1
			token(es);
d312 1
a312 1
		token(es);
d414 1
a414 1
				token(es);
d444 1
a444 1
token(Expr_state *es)
@


1.7
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.6 2006/11/10 07:52:02 tg Exp $");
d129 2
a130 1
static __dead void evalerr(Expr_state *, enum error_type, const char *);
@


1.7.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.9 2007/03/03 21:12:51 tg Exp $");
d129 1
a129 2
static void evalerr(Expr_state *, enum error_type, const char *)
    __attribute__((noreturn));
d131 1
a131 1
static void	   exprtoken(Expr_state *);
d187 1
a187 1
	exprtoken(es);
d276 1
a276 1
			exprtoken(es);
d286 1
a286 1
			exprtoken(es);
d290 1
a290 1
			exprtoken(es);
d292 1
a292 1
			exprtoken(es);
d294 1
a294 1
			exprtoken(es);
d297 1
a297 1
			exprtoken(es);
d304 1
a304 1
			exprtoken(es);
d311 1
a311 1
		exprtoken(es);
d413 1
a413 1
				exprtoken(es);
d443 1
a443 1
exprtoken(Expr_state *es)
@


1.6
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.5 2006/11/10 07:18:57 tg Exp $");
d129 1
a129 2
static void	   evalerr(Expr_state *, enum error_type, const char *)
    __attribute__((__noreturn__));
@


1.5
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.4 2006/05/10 18:54:10 tg Exp $");
d457 2
a458 2
	else if (letter(c)) {
		for (; letnum(c); c = *cp)
d483 2
a484 2
	} else if (digit(c)) {
		for (; c != '_' && (letnum(c) || c == '#'); c = *cp++)
@


1.4
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.3 2005/11/22 18:40:42 tg Exp $");
d451 1
a451 1
	for (cp = es->tokp; (c = *cp), isspace(c); cp++)
@


1.3
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: expr.c,v 1.18 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.2 2005/10/25 19:53:27 tg Exp $");
d185 1
a185 1
		/*NOTREACHED*/
d301 1
a301 1
			/*NOTREACHED*/
@


1.2
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/expr.c,v 1.1 2005/05/23 03:06:07 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.1 2005/05/23 03:06:07 tg Exp $");
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/expr.c,v 1.6 2005/05/23 02:20:35 tg Exp $ */
a4 1
#include <ctype.h>
d6 1
a6 1
__RCSID("$MirOS: mksh/expr.c,v 1.6 2005/05/23 02:20:35 tg Exp $");
@

