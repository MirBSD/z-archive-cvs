head	1.101;
access;
symbols
	mksh-R57:1.98
	mksh-R56c:1.97
	mksh-R56b:1.95
	mksh-R56:1.95
	mksh-R55:1.79
	mksh-R54:1.76
	mksh-R53a:1.76
	mksh-R53:1.76
	mksh-R52c:1.70
	mksh-R52b:1.69
	mksh-R52:1.68
	mksh-R51:1.66
	mksh-R50f:1.62.2.2
	mksh-R50e:1.62.2.2
	mksh-R50stable:1.62.0.2
	mksh-R50d:1.62
	mksh-R50c:1.62
	mksh-R50b:1.62
	mksh-R50:1.62
	mksh-R49:1.62
	mksh-R48b:1.61
	mksh-R48:1.61
	mksh-R47:1.61
	mksh-R46:1.59
	mksh-R45:1.59
	mksh-R44:1.56
	mksh-R43:1.56
	mksh-R42b:1.56
	mksh-R41c:1.47.2.4
	mksh-R41b:1.47.2.4
	mksh-R42:1.56
	mksh-R41:1.47
	mksh-R41stable:1.47.0.2
	mksh-wheezy:1.45.0.6
	tg-multikey-bind:1.45.0.4
	mksh-R40f:1.45
	mksh-R40e:1.45
	mksh-R40d:1.45
	mksh-R40c:1.45
	mksh-R40b:1.41.2.1
	mksh-R40stable:1.45.0.2
	mksh-R40:1.41
	mksh-R39c:1.35
	mksh-R39b:1.35
	tg-wcswidth-behaviour:1.33.0.2
	tg-nameref:1.31.0.2
	mksh-R39:1.30
	tg-mksh-printf-builtin:1.30.0.2
	mksh-R38c:1.30
	mksh-R38b:1.28
	mksh-R38:1.28
	mksh-R37c:1.27
	mksh-R37b:1.25
	mksh-R37:1.25
	mksh-R36b:1.24
	tg-aalloc-experimental_BASE:1.23
	tg-aalloc-experimental:1.23.0.2
	mksh-R36:1.22
	mksh-R35b:1.21
	mksh-R35:1.21
	mksh-R33d:1.17
	mksh-R33c:1.17
	mksh-R33b:1.17
	MIRBSD_10:1.16.0.2
	MIRBSD_10_BASE:1.16
	mksh-R33:1.16
	mksh-R32:1.16
	mksh-R31d:1.15
	mksh-R31c:1.15
	mksh-R31b:1.15
	mksh-R31:1.15
	mksh-R30:1.15
	mksh-R29g:1.13.2.1
	mksh-R29f:1.13.2.1
	mksh-R29e:1.13.2.1
	mksh-R29stable:1.13.0.2
	mksh-R29d:1.13
	mksh-R29c:1.13
	mksh-R29b:1.13
	mksh-R29:1.12
	mksh-R28:1.6
	tg-mksh-plan9ape_BASE:1.6
	tg-mksh-plan9ape:1.6.0.2
	mksh-R27e:1.5
	MIRBSD_9_BASE:1.5
	mksh-R27d:1.5
	mksh-R27:1.5
	mksh-R26c:1.4
	mksh-R26b:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	mksh-R26:1.3
	mksh-R25:1.2
	mksh-R24c:1.1
	mksh-R24b:1.1
	mksh-R24:1.1
	mksh-R23:1.1
	mksh-R22:1.1
	mksh-R21:1.1;
locks; strict;
comment	@ * @;


1.101
date	2019.12.11.17.56.58;	author tg;	state Exp;
branches;
next	1.100;
commitid	1005DF12DE60B2B4285;

1.100
date	2019.08.01.20.10.57;	author tg;	state Exp;
branches;
next	1.99;
commitid	1005D43476720B583A4;

1.99
date	2019.08.01.20.02.33;	author tg;	state Exp;
branches;
next	1.98;
commitid	1005D4345213B9AFDA7;

1.98
date	2018.08.10.02.53.39;	author tg;	state Exp;
branches;
next	1.97;
commitid	1005B6CFE0B5BDFE404;

1.97
date	2018.01.14.01.28.16;	author tg;	state Exp;
branches;
next	1.96;
commitid	1005A5AB24160ED8F7B;

1.96
date	2018.01.13.23.55.14;	author tg;	state Exp;
branches;
next	1.95;
commitid	1005A5A9C627E45C2B1;

1.95
date	2017.05.05.22.45.58;	author tg;	state Exp;
branches;
next	1.94;
commitid	100590D00B820B45C19;

1.94
date	2017.05.03.21.50.33;	author tg;	state Exp;
branches;
next	1.93;
commitid	100590A50A479A26B40;

1.93
date	2017.05.03.17.51.06;	author tg;	state Exp;
branches;
next	1.92;
commitid	100590A18964D91F456;

1.92
date	2017.04.28.11.31.53;	author tg;	state Exp;
branches;
next	1.91;
commitid	1005903282B43B4C47B;

1.91
date	2017.04.28.11.27.58;	author tg;	state Exp;
branches;
next	1.90;
commitid	1005903273F4DF15DBB;

1.90
date	2017.04.28.11.13.49;	author tg;	state Exp;
branches;
next	1.89;
commitid	100590323E86CD0E167;

1.89
date	2017.04.28.04.13.19;	author tg;	state Exp;
branches;
next	1.88;
commitid	1005902C17451F16FD1;

1.88
date	2017.04.28.03.51.14;	author tg;	state Exp;
branches;
next	1.87;
commitid	1005902BC4656E69578;

1.87
date	2017.04.28.02.40.26;	author tg;	state Exp;
branches;
next	1.86;
commitid	1005902ABA9399AA66E;

1.86
date	2017.04.28.01.15.51;	author tg;	state Exp;
branches;
next	1.85;
commitid	1005902978D70FC7074;

1.85
date	2017.04.28.00.38.33;	author tg;	state Exp;
branches;
next	1.84;
commitid	10059028F0E0808B3E9;

1.84
date	2017.04.27.23.33.22;	author tg;	state Exp;
branches;
next	1.83;
commitid	10059027FC444EF0ED1;

1.83
date	2017.04.27.23.12.49;	author tg;	state Exp;
branches;
next	1.82;
commitid	10059027AFC0DEF48C9;

1.82
date	2017.04.27.19.33.53;	author tg;	state Exp;
branches;
next	1.81;
commitid	100590247A92C66CAF9;

1.81
date	2017.04.27.19.16.10;	author tg;	state Exp;
branches;
next	1.80;
commitid	1005902438A577EF826;

1.80
date	2017.04.22.00.07.10;	author tg;	state Exp;
branches;
next	1.79;
commitid	10058FA9D043131DCC0;

1.79
date	2017.04.12.17.08.49;	author tg;	state Exp;
branches;
next	1.78;
commitid	10058EE5F3760123C7A;

1.78
date	2017.04.12.16.46.22;	author tg;	state Exp;
branches;
next	1.77;
commitid	10058EE59ED44DAA3D5;

1.77
date	2017.04.02.15.00.45;	author tg;	state Exp;
branches;
next	1.76;
commitid	10058E1121E64BBAB7B;

1.76
date	2016.07.25.00.04.47;	author tg;	state Exp;
branches;
next	1.75;
commitid	1005795579F14A3FE5C;

1.75
date	2016.07.24.23.07.19;	author tg;	state Exp;
branches;
next	1.74;
commitid	10057954A3B63F8859D;

1.74
date	2016.05.17.15.36.35;	author tg;	state Exp;
branches;
next	1.73;
commitid	100573B39F5517EBA22;

1.73
date	2016.05.05.22.56.15;	author tg;	state Exp;
branches;
next	1.72;
commitid	100572BCF9760C8313C;

1.72
date	2016.05.05.21.38.12;	author tg;	state Exp;
branches;
next	1.71;
commitid	100572BBD532BF9D720;

1.71
date	2016.05.05.21.29.24;	author tg;	state Exp;
branches;
next	1.70;
commitid	100572BBB456EA67D07;

1.70
date	2016.03.04.14.26.16;	author tg;	state Exp;
branches;
next	1.69;
commitid	10056D99B037D4D691D;

1.69
date	2015.12.31.20.38.59;	author tg;	state Exp;
branches;
next	1.68;
commitid	100568592781736A6DA;

1.68
date	2015.10.09.15.38.36;	author tg;	state Exp;
branches;
next	1.67;
commitid	1005617DF8B5ED95EEC;

1.67
date	2015.09.05.19.19.11;	author tg;	state Exp;
branches;
next	1.66;
commitid	10055EB402C54C3076B;

1.66
date	2015.07.09.20.52.43;	author tg;	state Exp;
branches;
next	1.65;
commitid	100559EDF161DEE9DD2;

1.65
date	2015.04.29.20.07.35;	author tg;	state Exp;
branches;
next	1.64;
commitid	100554139453DB97755;

1.64
date	2015.02.06.10.09.07;	author tg;	state Exp;
branches;
next	1.63;
commitid	10054D492CC303A2CB1;

1.63
date	2014.11.25.21.01.14;	author tg;	state Exp;
branches;
next	1.62;
commitid	1005474EE1E4024A4E4;

1.62
date	2013.10.09.11.59.30;	author tg;	state Exp;
branches
	1.62.2.1;
next	1.61;
commitid	10052554535524C4C97;

1.61
date	2013.07.21.18.36.03;	author tg;	state Exp;
branches;
next	1.60;
commitid	10051EC29F9411252FA;

1.60
date	2013.06.01.20.34.01;	author tg;	state Exp;
branches;
next	1.59;
commitid	10051AA5AD1211D71C7;

1.59
date	2013.04.26.19.49.07;	author tg;	state Exp;
branches;
next	1.58;
commitid	100517ADA4C350507A9;

1.58
date	2013.04.26.17.39.30;	author tg;	state Exp;
branches;
next	1.57;
commitid	100517ABB8868994F9D;

1.57
date	2013.03.30.15.39.16;	author tg;	state Exp;
branches;
next	1.56;
commitid	1005157073C6C563D5F;

1.56
date	2013.01.01.03.32.44;	author tg;	state Exp;
branches;
next	1.55;
commitid	10050E258F01BA8A38D;

1.55
date	2012.12.28.03.20.35;	author tg;	state Exp;
branches;
next	1.54;
commitid	10050DD101A4F012982;

1.54
date	2012.12.28.02.28.39;	author tg;	state Exp;
branches;
next	1.53;
commitid	10050DD03E43C678B81;

1.53
date	2012.12.17.23.18.11;	author tg;	state Exp;
branches;
next	1.52;
commitid	10050CFA81334F40D7F;

1.52
date	2012.12.17.22.57.50;	author tg;	state Exp;
branches;
next	1.51;
commitid	10050CFA37459E35D3F;

1.51
date	2012.12.17.22.14.27;	author tg;	state Exp;
branches;
next	1.50;
commitid	10050CF9958429136E1;

1.50
date	2012.12.08.18.30.31;	author tg;	state Exp;
branches;
next	1.49;
commitid	10050C3875A3CBDA8F8;

1.49
date	2012.12.05.19.38.24;	author tg;	state Exp;
branches;
next	1.48;
commitid	10050BFA2C0046FB3B9;

1.48
date	2012.12.04.01.11.16;	author tg;	state Exp;
branches;
next	1.47;
commitid	10050BD4DCC1620D535;

1.47
date	2012.10.03.16.16.15;	author tg;	state Exp;
branches
	1.47.2.1;
next	1.46;
commitid	100506C64E4724B9215;

1.46
date	2012.07.01.15.55.00;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004FF072DE3F1A3116;

1.45
date	2011.10.25.22.36.38;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004EA73A0B4E5C1903;

1.44
date	2011.09.07.15.24.20;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004E678C6929FE60A6;

1.43
date	2011.08.27.18.06.51;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004E5932432420AA61;

1.42
date	2011.07.16.17.07.35;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004E21C56A65D7176B;

1.41
date	2011.03.13.01.20.23;	author tg;	state Exp;
branches
	1.41.2.1;
next	1.40;
commitid	1004D7C1BE368F5B459;

1.40
date	2010.09.14.21.26.17;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004C8FE654576B0E25;

1.39
date	2010.08.28.20.22.23;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004C796FE40C544CCE;

1.38
date	2010.08.28.18.50.57;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004C795A82072326AF;

1.37
date	2010.08.28.16.47.11;	author tg;	state Exp;
branches;
next	1.36;
commitid	1004C793DA0390DF065;

1.36
date	2010.07.19.22.41.04;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004C44D3437C9C37AE;

1.35
date	2009.11.28.14.28.03;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004B11334F4604E973;

1.34
date	2009.11.28.14.21.46;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004B1131E93EDF1403;

1.33
date	2009.09.20.13.33.48;	author tg;	state Exp;
branches
	1.33.2.1;
next	1.32;
commitid	1004AB62F5457733739;

1.32
date	2009.09.20.13.08.12;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004AB6294B732533ED;

1.31
date	2009.08.08.13.08.53;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004A7D785D73D49CFA;

1.30
date	2009.06.10.18.12.49;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004A2FF7913BD44883;

1.29
date	2009.06.08.20.06.49;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004A2D6F3A31FB4CBC;

1.28
date	2009.05.16.16.59.40;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004A0EF0664EF4168D;

1.27
date	2009.04.07.19.25.41;	author tg;	state Exp;
branches;
next	1.26;
commitid	10049DBA8B67B4D8B46;

1.26
date	2009.04.07.19.08.25;	author tg;	state Exp;
branches;
next	1.25;
commitid	10049DBA47F37F451E7;

1.25
date	2009.03.14.18.12.55;	author tg;	state Exp;
branches;
next	1.24;
commitid	10049BBF38A0ADEDD54;

1.24
date	2008.12.13.17.02.17;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004943EAA830C0300B;

1.23
date	2008.11.12.00.54.51;	author tg;	state Exp;
branches
	1.23.2.1;
next	1.22;
commitid	100491A295841A6D8EB;

1.22
date	2008.10.10.21.30.43;	author tg;	state Exp;
branches;
next	1.21;
commitid	10048EFC9600438B1CB;

1.21
date	2008.05.17.18.47.02;	author tg;	state Exp;
branches;
next	1.20;
commitid	100482F280E7B53AA4C;

1.20
date	2008.05.02.18.55.37;	author tg;	state Exp;
branches;
next	1.19;
commitid	100481B63B51233676D;

1.19
date	2008.04.19.22.15.05;	author tg;	state Exp;
branches;
next	1.18;
commitid	100480A6CC85EC0197B;

1.18
date	2008.04.19.17.21.55;	author tg;	state Exp;
branches;
next	1.17;
commitid	100480A2A2B32040FD7;

1.17
date	2008.03.28.13.28.33;	author tg;	state Exp;
branches;
next	1.16;
commitid	10047ECF2895608ED25;

1.16
date	2007.10.25.15.23.10;	author tg;	state Exp;
branches
	1.16.2.1;
next	1.15;
commitid	1004720B4ED147A8549;

1.15
date	2007.06.06.23.28.17;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004667430836D68E66;

1.14
date	2007.05.13.17.51.23;	author tg;	state Exp;
branches;
next	1.13;
commitid	10046474FB1292DF336;

1.13
date	2007.03.10.18.16.28;	author tg;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	10045F2F60A6B49F58A;

1.12
date	2007.03.04.03.04.27;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045EA374B3374AB35;

1.11
date	2007.01.15.02.48.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045AAEB8E4EE42CAE;

1.10
date	2007.01.15.00.37.42;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045AACCC62B4906F0;

1.9
date	2007.01.12.10.18.22;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10045A76059104E0EFB;

1.8
date	2006.11.10.07.52.04;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045542F8269E05F56;

1.7
date	2006.11.09.21.00.13;	author tg;	state Exp;
branches;
next	1.6;
commitid	100455396D36774B042;

1.6
date	2006.08.02.12.50.20;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044D09F9E49A5DC1F;

1.5
date	2006.05.10.18.54.12;	author tg;	state Exp;
branches;
next	1.4;
commitid	100446236E6726083C8;

1.4
date	2006.01.29.20.04.53;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043DD1FE6328EF386;

1.3
date	2005.11.22.18.40.43;	author tg;	state Exp;
branches;
next	1.2;
commitid	108a438366254326;

1.2
date	2005.10.25.19.53.29;	author tg;	state Exp;
branches;
next	1.1;
commitid	76cc435e8d34d8ce;

1.1
date	2005.05.23.03.06.10;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.62.2.1
date	2015.01.25.15.35.53;	author tg;	state Exp;
branches;
next	1.62.2.2;
commitid	10054C50D442D861FBF;

1.62.2.2
date	2015.03.01.15.43.07;	author tg;	state Exp;
branches;
next	;
commitid	10054F33364551D895A;

1.47.2.1
date	2012.12.04.01.26.35;	author tg;	state Exp;
branches;
next	1.47.2.2;
commitid	10050BD5149729CD584;

1.47.2.2
date	2012.12.05.19.58.35;	author tg;	state Exp;
branches;
next	1.47.2.3;
commitid	10050BFA7766B61F30F;

1.47.2.3
date	2013.01.01.21.20.10;	author tg;	state Exp;
branches;
next	1.47.2.4;
commitid	10050E352F23B706399;

1.47.2.4
date	2013.02.10.17.11.30;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.41.2.1
date	2011.07.16.13.16.46;	author tg;	state Exp;
branches;
next	;
commitid	1004E218F373D0F49ED;

1.33.2.1
date	2009.11.28.14.27.56;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.23.2.1
date	2008.11.22.13.20.36;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.16.2.1
date	2008.04.22.13.29.33;	author tg;	state Exp;
branches;
next	1.16.2.2;
commitid	100480DE80F32BAA72D;

1.16.2.2
date	2008.05.19.18.41.31;	author tg;	state Exp;
branches;
next	1.16.2.3;
commitid	1004831C9A63DA06745;

1.16.2.3
date	2008.12.14.00.07.50;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.13.2.1
date	2007.05.13.19.29.39;	author tg;	state Exp;
branches;
next	;
commitid	1004647668D4636830B;

1.9.2.1
date	2007.03.03.21.38.00;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;


desc
@@


1.101
log
@factor out complex ifdef into MKSH_SHF_NO_INLINE
since we may need it to make the code more portable to primitive compilers
@
text
@/*	$OpenBSD: shf.c,v 1.16 2013/04/19 17:36:09 millert Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
 *		 2012, 2013, 2015, 2016, 2017, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2015
 *	Daniel Richard G. <skunk@@iSKUNK.ORG>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Use %zX instead of %p and floating point isn't supported at all.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.100 2019/08/01 20:10:57 tg Exp $");

/* flags to shf_emptybuf() */
#define EB_READSW	0x01	/* about to switch to reading */
#define EB_GROW		0x02	/* grow buffer if necessary (STRING+DYNAMIC) */

/*
 * Replacement stdio routines. Stdio is too flakey on too many machines
 * to be useful when you have multiple processes using the same underlying
 * file descriptors.
 */

static int shf_fillbuf(struct shf *);
static int shf_emptybuf(struct shf *, int);

/*
 * Open a file. First three args are for open(), last arg is flags for
 * this package. Returns NULL if file could not be opened, or if a dup
 * fails.
 */
struct shf *
shf_open(const char *name, int oflags, int mode, int sflags)
{
	struct shf *shf;
	ssize_t bsize =
	    /* at most 512 */
	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
	int fd, eno;

	/* Done before open so if alloca fails, fd won't be lost. */
	shf = alloc(sizeof(struct shf) + bsize, ATEMP);
	shf->areap = ATEMP;
	shf->buf = (unsigned char *)&shf[1];
	shf->bsize = bsize;
	shf->flags = SHF_ALLOCS;
	/* Rest filled in by reopen. */

	fd = binopen3(name, oflags, mode);
	if (fd < 0) {
		eno = errno;
		afree(shf, shf->areap);
		errno = eno;
		return (NULL);
	}
	if ((sflags & SHF_MAPHI) && fd < FDBASE) {
		int nfd;

		nfd = fcntl(fd, F_DUPFD, FDBASE);
		eno = errno;
		close(fd);
		if (nfd < 0) {
			afree(shf, shf->areap);
			errno = eno;
			return (NULL);
		}
		fd = nfd;
	}
	sflags &= ~SHF_ACCMODE;
	sflags |= (oflags & O_ACCMODE) == O_RDONLY ? SHF_RD :
	    ((oflags & O_ACCMODE) == O_WRONLY ? SHF_WR : SHF_RDWR);

	return (shf_reopen(fd, sflags, shf));
}

/* helper function for shf_fdopen and shf_reopen */
static void
shf_open_hlp(int fd, int *sflagsp, const char *where)
{
	int sflags = *sflagsp;

	/* use fcntl() to figure out correct read/write flags */
	if (sflags & SHF_GETFL) {
		int flags = fcntl(fd, F_GETFL, 0);

		if (flags < 0)
			/* will get an error on first read/write */
			sflags |= SHF_RDWR;
		else {
			switch (flags & O_ACCMODE) {
			case O_RDONLY:
				sflags |= SHF_RD;
				break;
			case O_WRONLY:
				sflags |= SHF_WR;
				break;
			case O_RDWR:
				sflags |= SHF_RDWR;
				break;
			}
		}
		*sflagsp = sflags;
	}

	if (!(sflags & (SHF_RD | SHF_WR)))
		internal_errorf(Tf_sD_s, where, "missing read/write");
}

/* Set up the shf structure for a file descriptor. Doesn't fail. */
struct shf *
shf_fdopen(int fd, int sflags, struct shf *shf)
{
	ssize_t bsize =
	    /* at most 512 */
	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;

	shf_open_hlp(fd, &sflags, "shf_fdopen");
	if (shf) {
		if (bsize) {
			shf->buf = alloc(bsize, ATEMP);
			sflags |= SHF_ALLOCB;
		} else
			shf->buf = NULL;
	} else {
		shf = alloc(sizeof(struct shf) + bsize, ATEMP);
		shf->buf = (unsigned char *)&shf[1];
		sflags |= SHF_ALLOCS;
	}
	shf->areap = ATEMP;
	shf->fd = fd;
	shf->rp = shf->wp = shf->buf;
	shf->rnleft = 0;
	shf->rbsize = bsize;
	shf->wnleft = 0; /* force call to shf_emptybuf() */
	shf->wbsize = sflags & SHF_UNBUF ? 0 : bsize;
	shf->flags = sflags;
	shf->errnosv = 0;
	shf->bsize = bsize;
	if (sflags & SHF_CLEXEC)
		fcntl(fd, F_SETFD, FD_CLOEXEC);
	return (shf);
}

/* Set up an existing shf (and buffer) to use the given fd */
struct shf *
shf_reopen(int fd, int sflags, struct shf *shf)
{
	ssize_t bsize =
	    /* at most 512 */
	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;

	shf_open_hlp(fd, &sflags, "shf_reopen");
	if (!shf || !shf->buf || shf->bsize < bsize)
		internal_errorf(Tf_sD_s, "shf_reopen", Tbad_bsize);

	/* assumes shf->buf and shf->bsize already set up */
	shf->fd = fd;
	shf->rp = shf->wp = shf->buf;
	shf->rnleft = 0;
	shf->rbsize = bsize;
	shf->wnleft = 0; /* force call to shf_emptybuf() */
	shf->wbsize = sflags & SHF_UNBUF ? 0 : bsize;
	shf->flags = (shf->flags & (SHF_ALLOCS | SHF_ALLOCB)) | sflags;
	shf->errnosv = 0;
	if (sflags & SHF_CLEXEC)
		fcntl(fd, F_SETFD, FD_CLOEXEC);
	return (shf);
}

/*
 * Open a string for reading or writing. If reading, bsize is the number
 * of bytes that can be read. If writing, bsize is the maximum number of
 * bytes that can be written. If shf is not NULL, it is filled in and
 * returned, if it is NULL, shf is allocated. If writing and buf is NULL
 * and SHF_DYNAMIC is set, the buffer is allocated (if bsize > 0, it is
 * used for the initial size). Doesn't fail.
 * When writing, a byte is reserved for a trailing NUL - see shf_sclose().
 */
struct shf *
shf_sopen(char *buf, ssize_t bsize, int sflags, struct shf *shf)
{
	/* can't have a read+write string */
	if (!(!(sflags & SHF_RD) ^ !(sflags & SHF_WR)))
		internal_errorf(Tf_flags, "shf_sopen",
		    (unsigned int)sflags);

	if (!shf) {
		shf = alloc(sizeof(struct shf), ATEMP);
		sflags |= SHF_ALLOCS;
	}
	shf->areap = ATEMP;
	if (!buf && (sflags & SHF_WR) && (sflags & SHF_DYNAMIC)) {
		if (bsize <= 0)
			bsize = 64;
		sflags |= SHF_ALLOCB;
		buf = alloc(bsize, shf->areap);
	}
	shf->fd = -1;
	shf->buf = shf->rp = shf->wp = (unsigned char *)buf;
	shf->rnleft = bsize;
	shf->rbsize = bsize;
	shf->wnleft = bsize - 1;	/* space for a '\0' */
	shf->wbsize = bsize;
	shf->flags = sflags | SHF_STRING;
	shf->errnosv = 0;
	shf->bsize = bsize;

	return (shf);
}

/* Flush and close file descriptor, free the shf structure */
int
shf_close(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0) {
		ret = shf_flush(shf);
		if (close(shf->fd) < 0)
			ret = -1;
	}
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	else if (shf->flags & SHF_ALLOCB)
		afree(shf->buf, shf->areap);

	return (ret);
}

/* Flush and close file descriptor, don't free file structure */
int
shf_fdclose(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0) {
		ret = shf_flush(shf);
		if (close(shf->fd) < 0)
			ret = -1;
		shf->rnleft = 0;
		shf->rp = shf->buf;
		shf->wnleft = 0;
		shf->fd = -1;
	}

	return (ret);
}

/*
 * Close a string - if it was opened for writing, it is NUL terminated;
 * returns a pointer to the string and frees shf if it was allocated
 * (does not free string if it was allocated).
 */
char *
shf_sclose(struct shf *shf)
{
	unsigned char *s = shf->buf;

	/* NUL terminate */
	if (shf->flags & SHF_WR) {
		shf->wnleft++;
		shf_putc('\0', shf);
	}
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	return ((char *)s);
}

/*
 * Un-read what has been read but not examined, or write what has been
 * buffered. Returns 0 for success, -1 for (write) error.
 */
int
shf_flush(struct shf *shf)
{
	int rv = 0;

	if (shf->flags & SHF_STRING)
		rv = (shf->flags & SHF_WR) ? -1 : 0;
	else if (shf->fd < 0)
		internal_errorf(Tf_sD_s, "shf_flush", "no fd");
	else if (shf->flags & SHF_ERROR) {
		errno = shf->errnosv;
		rv = -1;
	} else if (shf->flags & SHF_READING) {
		shf->flags &= ~(SHF_EOF | SHF_READING);
		if (shf->rnleft > 0) {
			if (lseek(shf->fd, (off_t)-shf->rnleft,
			    SEEK_CUR) == -1) {
				shf->flags |= SHF_ERROR;
				shf->errnosv = errno;
				rv = -1;
			}
			shf->rnleft = 0;
			shf->rp = shf->buf;
		}
	} else if (shf->flags & SHF_WRITING)
		rv = shf_emptybuf(shf, 0);

	return (rv);
}

/*
 * Write out any buffered data. If currently reading, flushes the read
 * buffer. Returns 0 for success, -1 for (write) error.
 */
static int
shf_emptybuf(struct shf *shf, int flags)
{
	int ret = 0;

	if (!(shf->flags & SHF_STRING) && shf->fd < 0)
		internal_errorf(Tf_sD_s, "shf_emptybuf", "no fd");

	if (shf->flags & SHF_ERROR) {
		errno = shf->errnosv;
		return (-1);
	}

	if (shf->flags & SHF_READING) {
		if (flags & EB_READSW)
			/* doesn't happen */
			return (0);
		ret = shf_flush(shf);
		shf->flags &= ~SHF_READING;
	}
	if (shf->flags & SHF_STRING) {
		unsigned char *nbuf;

		/*
		 * Note that we assume SHF_ALLOCS is not set if
		 * SHF_ALLOCB is set... (changing the shf pointer could
		 * cause problems)
		 */
		if (!(flags & EB_GROW) || !(shf->flags & SHF_DYNAMIC) ||
		    !(shf->flags & SHF_ALLOCB))
			return (-1);
		/* allocate more space for buffer */
		nbuf = aresize2(shf->buf, 2, shf->wbsize, shf->areap);
		shf->rp = nbuf + (shf->rp - shf->buf);
		shf->wp = nbuf + (shf->wp - shf->buf);
		shf->rbsize += shf->wbsize;
		shf->wnleft += shf->wbsize;
		shf->wbsize <<= 1;
		shf->buf = nbuf;
	} else {
		if (shf->flags & SHF_WRITING) {
			ssize_t n, ntowrite = shf->wp - shf->buf;
			unsigned char *buf = shf->buf;

			while (ntowrite > 0) {
				n = write(shf->fd, buf, ntowrite);
				if (n < 0) {
					if (errno == EINTR &&
					    !(shf->flags & SHF_INTERRUPT))
						continue;
					shf->flags |= SHF_ERROR;
					shf->errnosv = errno;
					shf->wnleft = 0;
					if (buf != shf->buf) {
						/*
						 * allow a second flush
						 * to work
						 */
						memmove(shf->buf, buf,
						    ntowrite);
						shf->wp = shf->buf + ntowrite;
					}
					return (-1);
				}
				buf += n;
				ntowrite -= n;
			}
			if (flags & EB_READSW) {
				shf->wp = shf->buf;
				shf->wnleft = 0;
				shf->flags &= ~SHF_WRITING;
				return (0);
			}
		}
		shf->wp = shf->buf;
		shf->wnleft = shf->wbsize;
	}
	shf->flags |= SHF_WRITING;

	return (ret);
}

/* Fill up a read buffer. Returns -1 for a read error, 0 otherwise. */
static int
shf_fillbuf(struct shf *shf)
{
	ssize_t n;

	if (shf->flags & SHF_STRING)
		return (0);

	if (shf->fd < 0)
		internal_errorf(Tf_sD_s, "shf_fillbuf", "no fd");

	if (shf->flags & (SHF_EOF | SHF_ERROR)) {
		if (shf->flags & SHF_ERROR)
			errno = shf->errnosv;
		return (-1);
	}

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == -1)
		return (-1);

	shf->flags |= SHF_READING;

	shf->rp = shf->buf;
	while (/* CONSTCOND */ 1) {
		n = blocking_read(shf->fd, (char *)shf->buf, shf->rbsize);
		if (n < 0 && errno == EINTR && !(shf->flags & SHF_INTERRUPT))
			continue;
		break;
	}
	if (n < 0) {
		shf->flags |= SHF_ERROR;
		shf->errnosv = errno;
		shf->rnleft = 0;
		shf->rp = shf->buf;
		return (-1);
	}
	if ((shf->rnleft = n) == 0)
		shf->flags |= SHF_EOF;
	return (0);
}

/*
 * Read a buffer from shf. Returns the number of bytes read into buf, if
 * no bytes were read, returns 0 if end of file was seen, -1 if a read
 * error occurred.
 */
ssize_t
shf_read(char *buf, ssize_t bsize, struct shf *shf)
{
	ssize_t ncopy, orig_bsize = bsize;

	if (!(shf->flags & SHF_RD))
		internal_errorf(Tf_flags, Tshf_read,
		    (unsigned int)shf->flags);

	if (bsize <= 0)
		internal_errorf(Tf_szs, Tshf_read, bsize, Tbsize);

	while (bsize > 0) {
		if (shf->rnleft == 0 &&
		    (shf_fillbuf(shf) == -1 || shf->rnleft == 0))
			break;
		ncopy = shf->rnleft;
		if (ncopy > bsize)
			ncopy = bsize;
		memcpy(buf, shf->rp, ncopy);
		buf += ncopy;
		bsize -= ncopy;
		shf->rp += ncopy;
		shf->rnleft -= ncopy;
	}
	/* Note: fread(3S) returns 0 for errors - this doesn't */
	return (orig_bsize == bsize ? (shf_error(shf) ? -1 : 0) :
	    orig_bsize - bsize);
}

/*
 * Read up to a newline or -1. The newline is put in buf; buf is always
 * NUL terminated. Returns NULL on read error or if nothing was read
 * before end of file, returns a pointer to the NUL byte in buf
 * otherwise.
 */
char *
shf_getse(char *buf, ssize_t bsize, struct shf *shf)
{
	unsigned char *end;
	ssize_t ncopy;
	char *orig_buf = buf;

	if (!(shf->flags & SHF_RD))
		internal_errorf(Tf_flags, "shf_getse",
		    (unsigned int)shf->flags);

	if (bsize <= 0)
		return (NULL);

	/* save room for NUL */
	--bsize;
	do {
		if (shf->rnleft == 0) {
			if (shf_fillbuf(shf) == -1)
				return (NULL);
			if (shf->rnleft == 0) {
				*buf = '\0';
				return (buf == orig_buf ? NULL : buf);
			}
		}
		end = (unsigned char *)memchr((char *)shf->rp, '\n',
		    shf->rnleft);
		ncopy = end ? end - shf->rp + 1 : shf->rnleft;
		if (ncopy > bsize)
			ncopy = bsize;
		memcpy(buf, (char *) shf->rp, ncopy);
		shf->rp += ncopy;
		shf->rnleft -= ncopy;
		buf += ncopy;
		bsize -= ncopy;
#ifdef MKSH_WITH_TEXTMODE
		if (buf > orig_buf + 1 && ord(buf[-2]) == ORD('\r') &&
		    ord(buf[-1]) == ORD('\n')) {
			buf--;
			bsize++;
			buf[-1] = '\n';
		}
#endif
	} while (!end && bsize);
#ifdef MKSH_WITH_TEXTMODE
	if (!bsize && ord(buf[-1]) == ORD('\r')) {
		int c = shf_getc(shf);
		if (ord(c) == ORD('\n'))
			buf[-1] = '\n';
		else if (c != -1)
			shf_ungetc(c, shf);
	}
#endif
	*buf = '\0';
	return (buf);
}

/* Returns the char read. Returns -1 for error and end of file. */
int
shf_getchar(struct shf *shf)
{
	if (!(shf->flags & SHF_RD))
		internal_errorf(Tf_flags, "shf_getchar",
		    (unsigned int)shf->flags);

	if (shf->rnleft == 0 && (shf_fillbuf(shf) == -1 || shf->rnleft == 0))
		return (-1);
	--shf->rnleft;
	return (ord(*shf->rp++));
}

/*
 * Put a character back in the input stream. Returns the character if
 * successful, -1 if there is no room.
 */
int
shf_ungetc(int c, struct shf *shf)
{
	if (!(shf->flags & SHF_RD))
		internal_errorf(Tf_flags, "shf_ungetc",
		    (unsigned int)shf->flags);

	if ((shf->flags & SHF_ERROR) || c == -1 ||
	    (shf->rp == shf->buf && shf->rnleft))
		return (-1);

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == -1)
		return (-1);

	if (shf->rp == shf->buf)
		shf->rp = shf->buf + shf->rbsize;
	if (shf->flags & SHF_STRING) {
		/*
		 * Can unget what was read, but not something different;
		 * we don't want to modify a string.
		 */
		if ((int)(shf->rp[-1]) != c)
			return (-1);
		shf->flags &= ~SHF_EOF;
		shf->rp--;
		shf->rnleft++;
		return (c);
	}
	shf->flags &= ~SHF_EOF;
	*--(shf->rp) = c;
	shf->rnleft++;
	return (c);
}

/*
 * Write a character. Returns the character if successful, -1 if the
 * char could not be written.
 */
int
shf_putchar(int c, struct shf *shf)
{
	if (!(shf->flags & SHF_WR))
		internal_errorf(Tf_flags, "shf_putchar",
		    (unsigned int)shf->flags);

	if (c == -1)
		return (-1);

	if (shf->flags & SHF_UNBUF) {
		unsigned char cc = (unsigned char)c;
		ssize_t n;

		if (shf->fd < 0)
			internal_errorf(Tf_sD_s, "shf_putchar", "no fd");
		if (shf->flags & SHF_ERROR) {
			errno = shf->errnosv;
			return (-1);
		}
		while ((n = write(shf->fd, &cc, 1)) != 1)
			if (n < 0) {
				if (errno == EINTR &&
				    !(shf->flags & SHF_INTERRUPT))
					continue;
				shf->flags |= SHF_ERROR;
				shf->errnosv = errno;
				return (-1);
			}
	} else {
		/* Flush deals with strings and sticky errors */
		if (shf->wnleft == 0 && shf_emptybuf(shf, EB_GROW) == -1)
			return (-1);
		shf->wnleft--;
		*shf->wp++ = c;
	}

	return (c);
}

/*
 * Write a string. Returns the length of the string if successful, -1
 * if the string could not be written.
 */
ssize_t
shf_puts(const char *s, struct shf *shf)
{
	if (!s)
		return (-1);

	return (shf_write(s, strlen(s), shf));
}

/* Write a buffer. Returns nbytes if successful, -1 if there is an error. */
ssize_t
shf_write(const char *buf, ssize_t nbytes, struct shf *shf)
{
	ssize_t n, ncopy, orig_nbytes = nbytes;

	if (!(shf->flags & SHF_WR))
		internal_errorf(Tf_flags, Tshf_write,
		    (unsigned int)shf->flags);

	if (nbytes < 0)
		internal_errorf(Tf_szs, Tshf_write, nbytes, Tbytes);

	/* Don't buffer if buffer is empty and we're writting a large amount. */
	if ((ncopy = shf->wnleft) &&
	    (shf->wp != shf->buf || nbytes < shf->wnleft)) {
		if (ncopy > nbytes)
			ncopy = nbytes;
		memcpy(shf->wp, buf, ncopy);
		nbytes -= ncopy;
		buf += ncopy;
		shf->wp += ncopy;
		shf->wnleft -= ncopy;
	}
	if (nbytes > 0) {
		if (shf->flags & SHF_STRING) {
			/* resize buffer until there's enough space left */
			while (nbytes > shf->wnleft)
				if (shf_emptybuf(shf, EB_GROW) == -1)
					return (-1);
			/* then write everything into the buffer */
		} else {
			/* flush deals with sticky errors */
			if (shf_emptybuf(shf, EB_GROW) == -1)
				return (-1);
			/* write chunks larger than window size directly */
			if (nbytes > shf->wbsize) {
				ncopy = nbytes;
				if (shf->wbsize)
					ncopy -= nbytes % shf->wbsize;
				nbytes -= ncopy;
				while (ncopy > 0) {
					n = write(shf->fd, buf, ncopy);
					if (n < 0) {
						if (errno == EINTR &&
						    !(shf->flags & SHF_INTERRUPT))
							continue;
						shf->flags |= SHF_ERROR;
						shf->errnosv = errno;
						shf->wnleft = 0;
						/*
						 * Note: fwrite(3) returns 0
						 * for errors - this doesn't
						 */
						return (-1);
					}
					buf += n;
					ncopy -= n;
				}
			}
			/* ... and buffer the rest */
		}
		if (nbytes > 0) {
			/* write remaining bytes to buffer */
			memcpy(shf->wp, buf, nbytes);
			shf->wp += nbytes;
			shf->wnleft -= nbytes;
		}
	}

	return (orig_nbytes);
}

ssize_t
shf_fprintf(struct shf *shf, const char *fmt, ...)
{
	va_list args;
	ssize_t n;

	va_start(args, fmt);
	n = shf_vfprintf(shf, fmt, args);
	va_end(args);

	return (n);
}

ssize_t
shf_snprintf(char *buf, ssize_t bsize, const char *fmt, ...)
{
	struct shf shf;
	va_list args;
	ssize_t n;

	if (!buf || bsize <= 0)
		internal_errorf("shf_snprintf: buf %zX, bsize %zd",
		    (size_t)buf, bsize);

	shf_sopen(buf, bsize, SHF_WR, &shf);
	va_start(args, fmt);
	n = shf_vfprintf(&shf, fmt, args);
	va_end(args);
	/* NUL terminates */
	shf_sclose(&shf);
	return (n);
}

char *
shf_smprintf(const char *fmt, ...)
{
	struct shf shf;
	va_list args;

	shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
	va_start(args, fmt);
	shf_vfprintf(&shf, fmt, args);
	va_end(args);
	/* NUL terminates */
	return (shf_sclose(&shf));
}

#define	FL_HASH		0x001	/* '#' seen */
#define FL_PLUS		0x002	/* '+' seen */
#define FL_RIGHT	0x004	/* '-' seen */
#define FL_BLANK	0x008	/* ' ' seen */
#define FL_SHORT	0x010	/* 'h' seen */
#define FL_LONG		0x020	/* 'l' seen */
#define FL_ZERO		0x040	/* '0' seen */
#define FL_DOT		0x080	/* '.' seen */
#define FL_UPPER	0x100	/* format character was uppercase */
#define FL_NUMBER	0x200	/* a number was formated %[douxefg] */
#define FL_SIZET	0x400	/* 'z' seen */
#define FM_SIZES	0x430	/* h/l/z mask */

ssize_t
shf_vfprintf(struct shf *shf, const char *fmt, va_list args)
{
	const char *s;
	char c, *cp;
	int tmp = 0, flags;
	size_t field, precision, len;
	unsigned long lnum;
	/* %#o produces the longest output */
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1 + /* NUL */ 1];
	/* this stuff for dealing with the buffer */
	ssize_t nwritten = 0;

#define VA(type) va_arg(args, type)

	if (!fmt)
		return (0);

	while ((c = *fmt++)) {
		if (c != '%') {
			shf_putc(c, shf);
			nwritten++;
			continue;
		}
		/*
		 * This will accept flags/fields in any order - not just
		 * the order specified in printf(3), but this is the way
		 * _doprnt() seems to work (on BSD and SYSV). The only
		 * restriction is that the format character must come
		 * last :-).
		 */
		flags = 0;
		field = precision = 0;
		while ((c = *fmt++)) {
			switch (c) {
			case '#':
				flags |= FL_HASH;
				continue;

			case '+':
				flags |= FL_PLUS;
				continue;

			case '-':
				flags |= FL_RIGHT;
				continue;

			case ' ':
				flags |= FL_BLANK;
				continue;

			case '0':
				if (!(flags & FL_DOT))
					flags |= FL_ZERO;
				continue;

			case '.':
				flags |= FL_DOT;
				precision = 0;
				continue;

			case '*':
				tmp = VA(int);
				if (tmp < 0) {
					if (flags & FL_DOT)
						precision = 0;
					else {
						field = (unsigned int)-tmp;
						flags |= FL_RIGHT;
					}
				} else if (flags & FL_DOT)
					precision = (unsigned int)tmp;
				else
					field = (unsigned int)tmp;
				continue;

			case 'l':
				flags &= ~FM_SIZES;
				flags |= FL_LONG;
				continue;

			case 'h':
				flags &= ~FM_SIZES;
				flags |= FL_SHORT;
				continue;

			case 'z':
				flags &= ~FM_SIZES;
				flags |= FL_SIZET;
				continue;
			}
			if (ctype(c, C_DIGIT)) {
				bool overflowed = false;

				tmp = ksh_numdig(c);
				while (ctype((c = *fmt++), C_DIGIT))
					if (notok2mul(2147483647, tmp, 10))
						overflowed = true;
					else
						tmp = tmp * 10 + ksh_numdig(c);
				--fmt;
				if (overflowed)
					tmp = 0;
				if (flags & FL_DOT)
					precision = (unsigned int)tmp;
				else
					field = (unsigned int)tmp;
				continue;
			}
			break;
		}

		if (!c)
			/* nasty format */
			break;

		if (ctype(c, C_UPPER)) {
			flags |= FL_UPPER;
			c = ksh_tolower(c);
		}

		switch (c) {
		case 'd':
		case 'i':
			if (flags & FL_SIZET)
				lnum = (long)VA(ssize_t);
			else if (flags & FL_LONG)
				lnum = VA(long);
			else if (flags & FL_SHORT)
				lnum = (long)(short)VA(int);
			else
				lnum = (long)VA(int);
			goto integral;

		case 'o':
		case 'u':
		case 'x':
			if (flags & FL_SIZET)
				lnum = VA(size_t);
			else if (flags & FL_LONG)
				lnum = VA(unsigned long);
			else if (flags & FL_SHORT)
				lnum = (unsigned long)(unsigned short)VA(int);
			else
				lnum = (unsigned long)VA(unsigned int);

 integral:
			flags |= FL_NUMBER;
			cp = numbuf + sizeof(numbuf);
			*--cp = '\0';

			switch (c) {
			case 'd':
			case 'i':
				if (0 > (long)lnum) {
					lnum = -(long)lnum;
					tmp = 1;
				} else
					tmp = 0;
				/* FALLTHROUGH */
			case 'u':
				do {
					*--cp = digits_lc[lnum % 10];
					lnum /= 10;
				} while (lnum);

				if (c != 'u') {
					if (tmp)
						*--cp = '-';
					else if (flags & FL_PLUS)
						*--cp = '+';
					else if (flags & FL_BLANK)
						*--cp = ' ';
				}
				break;

			case 'o':
				do {
					*--cp = digits_lc[lnum & 0x7];
					lnum >>= 3;
				} while (lnum);

				if ((flags & FL_HASH) && *cp != '0')
					*--cp = '0';
				break;

			case 'x': {
				const char *digits = (flags & FL_UPPER) ?
				    digits_uc : digits_lc;
				do {
					*--cp = digits[lnum & 0xF];
					lnum >>= 4;
				} while (lnum);

				if (flags & FL_HASH) {
					*--cp = (flags & FL_UPPER) ? 'X' : 'x';
					*--cp = '0';
				}
			    }
			}
			len = numbuf + sizeof(numbuf) - 1 - (s = cp);
			if (flags & FL_DOT) {
				if (precision > len) {
					field = precision;
					flags |= FL_ZERO;
				} else
					/* no loss */
					precision = len;
			}
			break;

		case 's':
			if ((s = VA(const char *)) == NULL)
				s = "(null)";
			else if (flags & FL_HASH) {
				print_value_quoted(shf, s);
				continue;
			}
			len = utf_mbswidth(s);
			break;

		case 'c':
			flags &= ~FL_DOT;
			c = (char)(VA(int));
			/* FALLTHROUGH */

		case '%':
		default:
			numbuf[0] = c;
			numbuf[1] = 0;
			s = numbuf;
			len = 1;
			break;
		}

		/*
		 * At this point s should point to a string that is to be
		 * formatted, and len should be the length of the string.
		 */
		if (!(flags & FL_DOT) || len < precision)
			precision = len;
		if (field > precision) {
			field -= precision;
			if (!(flags & FL_RIGHT)) {
				/* skip past sign or 0x when padding with 0 */
				if ((flags & FL_ZERO) && (flags & FL_NUMBER)) {
					if (ctype(*s, C_SPC | C_PLUS | C_MINUS)) {
						shf_putc(*s, shf);
						s++;
						precision--;
						nwritten++;
					} else if (*s == '0') {
						shf_putc(*s, shf);
						s++;
						nwritten++;
						if (--precision &&
						    ksh_eq(*s, 'X', 'x')) {
							shf_putc(*s, shf);
							s++;
							precision--;
							nwritten++;
						}
					}
					c = '0';
				} else
					c = flags & FL_ZERO ? '0' : ' ';
				nwritten += field;
				while (field--)
					shf_putc(c, shf);
				field = 0;
			} else
				c = ' ';
		} else
			field = 0;

		nwritten += precision;
		precision = utf_skipcols(s, precision, &tmp) - s;
		while (precision--)
			shf_putc(*s++, shf);

		nwritten += field;
		while (field--)
			shf_putc(c, shf);
	}

	return (shf_error(shf) ? -1 : nwritten);
}

#ifdef MKSH_SHF_NO_INLINE
int
shf_getc(struct shf *shf)
{
	return (shf_getc_i(shf));
}

int
shf_putc(int c, struct shf *shf)
{
	return (shf_putc_i(c, shf));
}
#endif

#ifdef DEBUG
const char *
cstrerror(int errnum)
{
#undef strerror
	return (strerror(errnum));
#define strerror dontuse_strerror /* poisoned */
}
#elif !HAVE_STRERROR

#if HAVE_SYS_ERRLIST
#if !HAVE_SYS_ERRLIST_DECL
extern const int sys_nerr;
extern const char * const sys_errlist[];
#endif
#endif

const char *
cstrerror(int errnum)
{
	/* "Unknown error: " + sign + rough estimate + NUL */
	static char errbuf[15 + 1 + (8 * sizeof(int) + 2) / 3 + 1];

#if HAVE_SYS_ERRLIST
	if (errnum > 0 && errnum < sys_nerr && sys_errlist[errnum])
		return (sys_errlist[errnum]);
#endif

	switch (errnum) {
	case 0:
		return ("Undefined error: 0");
	case EPERM:
		return ("Operation not permitted");
	case ENOENT:
		return ("No such file or directory");
#ifdef ESRCH
	case ESRCH:
		return ("No such process");
#endif
#ifdef E2BIG
	case E2BIG:
		return ("Argument list too long");
#endif
	case ENOEXEC:
		return ("Exec format error");
	case EBADF:
		return ("Bad file descriptor");
#ifdef ENOMEM
	case ENOMEM:
		return ("Cannot allocate memory");
#endif
	case EACCES:
		return ("Permission denied");
	case EEXIST:
		return ("File exists");
	case ENOTDIR:
		return ("Not a directory");
#ifdef EINVAL
	case EINVAL:
		return ("Invalid argument");
#endif
#ifdef ELOOP
	case ELOOP:
		return ("Too many levels of symbolic links");
#endif
	default:
		shf_snprintf(errbuf, sizeof(errbuf),
		    "Unknown error: %d", errnum);
		return (errbuf);
	}
}
#endif

/* fast character classes */
const uint32_t tpl_ctypes[128] = {
	/* 0x00 */
	CiNUL,		CiCNTRL,	CiCNTRL,	CiCNTRL,
	CiCNTRL,	CiCNTRL,	CiCNTRL,	CiCNTRL,
	CiCNTRL,	CiTAB,		CiNL,		CiSPX,
	CiSPX,		CiCR,		CiCNTRL,	CiCNTRL,
	/* 0x10 */
	CiCNTRL,	CiCNTRL,	CiCNTRL,	CiCNTRL,
	CiCNTRL,	CiCNTRL,	CiCNTRL,	CiCNTRL,
	CiCNTRL,	CiCNTRL,	CiCNTRL,	CiCNTRL,
	CiCNTRL,	CiCNTRL,	CiCNTRL,	CiCNTRL,
	/* 0x20 */
	CiSP,		CiALIAS | CiVAR1,	CiQC,	CiHASH,
	CiSS,		CiPERCT,	CiQCL,		CiQC,
	CiQCL,		CiQCL,		CiQCX | CiVAR1,	CiPLUS,
	CiALIAS,	CiMINUS,	CiALIAS,	CiQCM,
	/* 0x30 */
	CiOCTAL,	CiOCTAL,	CiOCTAL,	CiOCTAL,
	CiOCTAL,	CiOCTAL,	CiOCTAL,	CiOCTAL,
	CiDIGIT,	CiDIGIT,	CiCOLON,	CiQCL,
	CiANGLE,	CiEQUAL,	CiANGLE,	CiQUEST,
	/* 0x40 */
	CiALIAS | CiVAR1,	CiUPPER | CiHEXLT,
	CiUPPER | CiHEXLT,	CiUPPER | CiHEXLT,
	CiUPPER | CiHEXLT,	CiUPPER | CiHEXLT,
	CiUPPER | CiHEXLT,	CiUPPER,
	CiUPPER,	CiUPPER,	CiUPPER,	CiUPPER,
	CiUPPER,	CiUPPER,	CiUPPER,	CiUPPER,
	/* 0x50 */
	CiUPPER,	CiUPPER,	CiUPPER,	CiUPPER,
	CiUPPER,	CiUPPER,	CiUPPER,	CiUPPER,
	CiUPPER,	CiUPPER,	CiUPPER,	CiQCX | CiBRACK,
	CiQCX,		CiBRACK,	CiQCM,		CiUNDER,
	/* 0x60 */
	CiGRAVE,		CiLOWER | CiHEXLT,
	CiLOWER | CiHEXLT,	CiLOWER | CiHEXLT,
	CiLOWER | CiHEXLT,	CiLOWER | CiHEXLT,
	CiLOWER | CiHEXLT,	CiLOWER,
	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
	/* 0x70 */
	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
	CiLOWER,	CiLOWER,	CiLOWER,	CiCURLY,
	CiQCL,		CiCURLY,	CiQCM,		CiCNTRL
};

void
set_ifs(const char *s)
{
#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
	int i = 256;

	memset(ksh_ctypes, 0, sizeof(ksh_ctypes));
	while (i--)
		if (ebcdic_map[i] < 0x80U)
			ksh_ctypes[i] = tpl_ctypes[ebcdic_map[i]];
#else
	memcpy(ksh_ctypes, tpl_ctypes, sizeof(tpl_ctypes));
	memset((char *)ksh_ctypes + sizeof(tpl_ctypes), '\0',
	    sizeof(ksh_ctypes) - sizeof(tpl_ctypes));
#endif
	ifs0 = *s;
	while (*s)
		ksh_ctypes[ord(*s++)] |= CiIFS;
}

#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
#include <locale.h>

/*
 * Many headaches with EBCDIC:
 * 1. There are numerous EBCDIC variants, and it is not feasible for us
 *    to support them all. But we can support the EBCDIC code pages that
 *    contain all (most?) of the characters in ASCII, and these
 *    usually tend to agree on the code points assigned to the ASCII
 *    subset. If you need a representative example, look at EBCDIC 1047,
 *    which is first among equals in the IBM MVS development
 *    environment: https://en.wikipedia.org/wiki/EBCDIC_1047
 *    Unfortunately, the square brackets are not consistently mapped,
 *    and for certain reasons, we need an unambiguous bijective
 *    mapping between EBCDIC and "extended ASCII".
 * 2. Character ranges that are contiguous in ASCII, like the letters
 *    in [A-Z], are broken up into segments (i.e. [A-IJ-RS-Z]), so we
 *    can't implement e.g. islower() as { return c >= 'a' && c <= 'z'; }
 *    because it will also return true for a handful of extraneous
 *    characters (like the plus-minus sign at 0x8F in EBCDIC 1047, a
 *    little after 'i'). But at least '_' is not one of these.
 * 3. The normal [0-9A-Za-z] characters are at codepoints beyond 0x80.
 *    Not only do they require all 8 bits instead of 7, if chars are
 *    signed, they will have negative integer values! Something like
 *    (c - 'A') could actually become (c + 63)! Use the ord() macro to
 *    ensure you're getting a value in [0, 255] (ORD for constants).
 * 4. '\n' is actually NL (0x15, U+0085) instead of LF (0x25, U+000A).
 *    EBCDIC has a proper newline character instead of "emulating" one
 *    with line feeds, although this is mapped to LF for our purposes.
 * 5. Note that it is possible to compile programs in ASCII mode on IBM
 *    mainframe systems, using the -qascii option to the XL C compiler.
 *    We can determine the build mode by looking at __CHARSET_LIB:
 *    0 == EBCDIC, 1 == ASCII
 */

void
ebcdic_init(void)
{
	int i = 256;
	unsigned char t;
	bool mapcache[256];

	while (i--)
		ebcdic_rtt_toascii[i] = i;
	memset(ebcdic_rtt_fromascii, 0xFF, sizeof(ebcdic_rtt_fromascii));
	setlocale(LC_ALL, "");
#ifdef MKSH_EBCDIC
	if (__etoa_l(ebcdic_rtt_toascii, 256) != 256) {
		write(2, "mksh: could not map EBCDIC to ASCII\n", 36);
		exit(255);
	}
#endif

	memset(mapcache, 0, sizeof(mapcache));
	i = 256;
	while (i--) {
		t = ebcdic_rtt_toascii[i];
		/* ensure unique round-trip capable mapping */
		if (mapcache[t]) {
			write(2, "mksh: duplicate EBCDIC to ASCII mapping\n", 40);
			exit(255);
		}
		/*
		 * since there are 256 input octets, this also ensures
		 * the other mapping direction is completely filled
		 */
		mapcache[t] = true;
		/* fill the complete round-trip map */
		ebcdic_rtt_fromascii[t] = i;
		/*
		 * Only use the converted value if it's in the range
		 * [0x00; 0x7F], which I checked; the "extended ASCII"
		 * characters can be any encoding, not just Latin1,
		 * and the C1 control characters other than NEL are
		 * hopeless, but we map EBCDIC NEL to ASCII LF so we
		 * cannot even use C1 NEL.
		 * If ever we map to UCS, bump the table width to
		 * an unsigned int, and or the raw unconverted EBCDIC
		 * values with 0x01000000 instead.
		 */
		if (t < 0x80U)
			ebcdic_map[i] = (unsigned short)ord(t);
		else
			ebcdic_map[i] = (unsigned short)(0x100U | ord(i));
	}
	if (ebcdic_rtt_toascii[0] || ebcdic_rtt_fromascii[0] || ebcdic_map[0]) {
		write(2, "mksh: NUL not at position 0\n", 28);
		exit(255);
	}
}
#endif
@


1.100
log
@slightly improve EBCDIC support
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.97 2018/01/14 01:28:16 tg Exp $");
d1077 1
a1077 1
#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
@


1.99
log
@improve crlf to lf conversion

Do not depend on 'end'. Instead, check the last consecutive indices.

If end is not NULL and ncopy is larger than bsize, ncopy is truncated to
bsize. In addition, if buf[-2] == '\r', '\r' is replaced with '\n' even
if buf[-1] != '\n'. For example,

     0123456789
     ...r.....n

Let bsize = 5, ncopy = 10. Then buf will point to index 5. BTW,
buf[-1](index 4) is not '\n'. Nevertheless '\r' of buf[-2](index 3) will
be replaced with '\n'. This is wrong.

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d5 1
a5 1
 *		 2012, 2013, 2015, 2016, 2017, 2018
d526 2
a527 1
		if (buf > orig_buf + 1 && buf[-2] == '\r' && buf[-1] == '\n') {
d535 1
a535 1
	if (!bsize && buf[-1] == '\r') {
d537 1
a537 1
		if (c == '\n')
@


1.98
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d526 1
a526 1
		if (end && buf > orig_buf + 1 && buf[-2] == '\r') {
@


1.97
log
@shf_getc{,har} need to return properly casted
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.95 2017/05/05 22:45:58 tg Exp $");
d1307 1
a1307 1
		 * If ever we map to Unicode, bump the table width to
@


1.96
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d5 1
a5 1
 *		 2012, 2013, 2015, 2016, 2017
d557 1
a557 1
	return (*shf->rp++);
@


1.95
log
@add EBCDIC primer and attribution for iSKUNK
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.93 2017/05/03 17:51:06 tg Exp $");
d1256 1
a1256 1
 *    ensure you're getting a value in [0, 255].
@


1.94
log
@we absolutely require unambiguous mapping between EBCDIC and extended ASCII
to be able to provide a global stronly monotonous order for comparisons and
bracket expression ranges
@
text
@d7 2
d1234 32
@


1.93
log
@ensure NUL in ASCII and EBCDIC both always occurs ordinal 0
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.91 2017/04/28 11:27:58 tg Exp $");
d1237 1
a1237 1
	bool mapcache[128];
d1254 10
d1277 1
a1277 6
		if (t < 0x80U) {
			if (mapcache[t]) {
				write(2, "mksh: duplicate EBCDIC to ASCII mapping\n", 40);
				exit(255);
			}
			mapcache[t] = true;
d1279 1
a1279 1
		} else
@


1.92
log
@keep ksh_ctypes[] array keys in EBCDIC

we set $IFS massively less often than use ctype()
@
text
@d1277 4
@


1.91
log
@fill the map backwards (to use first occurrence of duplicates);
add a cache to ensure basic ASCII mapping is bijective
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.90 2017/04/28 11:13:49 tg Exp $");
d1212 8
d1223 1
d1226 1
a1226 1
		ksh_ctypes[rtt2asc(*s++)] |= CiIFS;
@


1.90
log
@add -DMKSH_FAUX_EBCDIC to test the codepaths better

waking up to: Lanfear - Just Another Broken Shell
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.88 2017/04/28 03:51:14 tg Exp $");
a1211 1
	ifs0 = *s;
d1215 1
d1228 1
d1232 1
d1241 4
a1244 2
	i = 0;
	do {
d1246 1
a1246 1
		ebcdic_rtt_fromascii[ebcdic_rtt_toascii[i]] = i;
d1258 6
a1263 1
		if ((t = ebcdic_rtt_toascii[i]) < 0x80U)
d1265 1
a1265 1
		else
d1267 1
a1267 1
	} while (++i < 256);
@


1.89
log
@fix C array arithmetics
@
text
@d1220 1
a1220 1
#ifdef MKSH_EBCDIC
d1232 1
d1237 1
@


1.88
log
@oops, ctypes are indexed by ASCII value even on EBCDIC systems
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.87 2017/04/28 02:40:26 tg Exp $");
d1214 1
a1214 1
	memset(ksh_ctypes + sizeof(tpl_ctypes), '\0',
@


1.87
log
@fill two complete round-trip maps EBCDIC <-> ASCII
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.86 2017/04/28 01:15:51 tg Exp $");
d1217 1
a1217 1
		ksh_ctypes[ord(*s++)] |= CiIFS;
@


1.86
log
@commit the EBCDIC run-time table conversion code, so it can be reviewed

XXX there’s still the issue of compile-time character conversion, and
XXX that runtime m̲u̲s̲t̲ use a compatible codepage, which we cannot check,
XXX and that we need the POSIX portable character set mapped, which we
XXX decide to not check (due to the above, mostly)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.83 2017/04/27 23:12:49 tg Exp $");
a1227 1
	char buf[256];
d1230 1
a1230 1
		buf[i] = i;
d1232 1
a1232 1
	if (__etoa_l(buf, 256) != 256) {
d1239 2
d1252 1
a1252 1
		if ((t = (unsigned char)buf[i]) < 0x80U)
@


1.85
log
@commit the optimisation result from the new fast character classes
@
text
@d1219 39
@


1.84
log
@allow : and [ in alias names (but forbid [[ explicitly)
to make 'enable' completely work again
@
text
@d1032 1
a1032 2
					if (*s == '+' || *s == '-' ||
					    *s == ' ') {
@


1.83
log
@fixup the remaining issues and last optimisations
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.78 2017/04/12 16:46:22 tg Exp $");
d1194 2
a1195 2
	CiUPPER,	CiUPPER,	CiUPPER,	CiQCX,
	CiQCX,		CiCBRK,		CiQCM,		CiUNDER,
@


1.82
log
@eliminate legacy macros
@
text
@d1165 4
a1168 8
	CiCNTRL | CiNUL,	CiCNTRL,
	CiCNTRL,		CiCNTRL,
	CiCNTRL,		CiCNTRL,
	CiCNTRL,		CiCNTRL,
	CiCNTRL,		CiCNTRL | CiTAB,
	CiCNTRL | CiNL,		CiCNTRL | CiSPX,
	CiCNTRL | CiSPX,	CiCNTRL | CiCR,
	CiCNTRL,		CiCNTRL,
d1175 4
a1178 8
	CiSP,			CiALIAS | CiVAR1,
	CiQC,			CiQCX | CiVAR1 | CiSUB2,
	CiVAR1 | CiSS,		CiALIAS | CiSUB2,
	CiQCL,			CiQC,
	CiQCL,			CiQCL,
	CiQCX | CiVAR1,		CiQCM | CiSUB1,
	CiALIAS,		CiALIAS | CiVAR1 | CiSUB1,
	CiALIAS,		CiQCM,
d1182 2
a1183 2
	CiDIGIT,	CiDIGIT,	CiQCM,		CiQCL,
	CiQCL,		CiQCX | CiSUB1,	CiQCL,		CiQCX | CiVAR1 | CiSUB1,
d1189 2
a1190 4
	CiUPPER,		CiUPPER,
	CiUPPER,		CiUPPER,
	CiUPPER,		CiUPPER,
	CiUPPER,		CiUPPER,
d1195 1
a1195 1
	CiQCX,		CiQCX,		CiQCM,		CiUNDER,
d1197 1
a1197 1
	CiQCX,			CiLOWER | CiHEXLT,
d1201 2
a1202 4
	CiLOWER,		CiLOWER,
	CiLOWER,		CiLOWER,
	CiLOWER,		CiLOWER,
	CiLOWER,		CiLOWER,
d1206 2
a1207 2
	CiLOWER,	CiLOWER,	CiLOWER,	CiQCM,
	CiQCL,		CiQCM,		CiQCM,		CiCNTRL
@


1.81
log
@convert to the new fast character classes
@
text
@d877 1
a877 1
			if (ksh_isdigit(c)) {
d881 1
a881 1
				while (c = *fmt++, ksh_isdigit(c))
d902 1
a902 1
		if (ksh_isupper(c)) {
@


1.80
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@a1224 1
	setctypes(s, C_IFS);
d1226 5
@


1.79
log
@ok, you’ve got a point there
@
text
@d1161 67
@


1.78
log
@(very few) fixes and a couple of workarounds for Coverity
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.70 2016/03/04 14:26:16 tg Exp $");
d292 1
a292 1
	int rv;
a301 1
		rv = 0;
@


1.77
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d5 1
a5 1
 *		 2012, 2013, 2015, 2016
d292 2
d295 2
a296 3
		return ((shf->flags & SHF_WR) ? -1 : 0);

	if (shf->fd < 0)
d298 1
a298 2

	if (shf->flags & SHF_ERROR) {
d300 3
a302 4
		return (-1);
	}

	if (shf->flags & SHF_READING) {
d305 6
a310 1
			lseek(shf->fd, (off_t)-shf->rnleft, SEEK_CUR);
a313 1
		return (0);
d315 1
a315 1
		return (shf_emptybuf(shf, 0));
d317 1
a317 1
	return (0);
@


1.76
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d521 7
d529 9
@


1.75
log
@optimise away code for a case that’s almost unlikely to happen; fix pasto(?)
@
text
@d122 1
a122 1
		internal_errorf("%s: %s", where, "missing read/write");
d170 1
a170 1
		internal_errorf("%s: %s", "shf_reopen", "bad shf/buf/bsize");
d200 1
a200 1
		internal_errorf("%s: flags 0x%X", "shf_sopen",
d296 1
a296 1
		internal_errorf("%s: %s", "shf_flush", "no fd");
d327 1
a327 1
		internal_errorf("%s: %s", "shf_emptybuf", "no fd");
d413 1
a413 1
		internal_errorf("%s: %s", "shf_fillbuf", "no fd");
d456 1
a456 1
		internal_errorf("%s: flags 0x%X", "shf_read",
d460 1
a460 1
		internal_errorf("%s: %s %zd", "shf_read", "bsize", bsize);
d494 1
a494 1
		internal_errorf("%s: flags 0x%X", "shf_getse",
d531 1
a531 1
		internal_errorf("%s: flags 0x%X", "shf_getchar",
d548 1
a548 1
		internal_errorf("%s: flags 0x%X", "shf_ungetc",
d586 1
a586 1
		internal_errorf("%s: flags 0x%X", "shf_putchar",
d597 1
a597 1
			internal_errorf("%s: %s", "shf_putchar", "no fd");
d642 1
a642 1
		internal_errorf("%s: flags 0x%X", "shf_write",
d646 1
a646 1
		internal_errorf("%s: %s %zd", "shf_write", "nbytes", nbytes);
@


1.74
log
@fix shf.c-internal buffer overread on printing digits,
introduced by the utf_skipcols()-related fixes, more
specifically the check for combining multibyte characters
past end of given width (bogus mixed-up semantics we have here)
by reïntroducing the NUL byte from commitid 1005474EE1E4024A4E4
@
text
@d460 1
a460 1
		internal_errorf("%s: %s %zd", "shf_write", "bsize", bsize);
@


1.73
log
@fix utf_widthadj/utf_skipcols handling for the remaining cases I can spot
@
text
@d777 1
a777 1
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d917 1
d968 1
a968 1
			len = numbuf + sizeof(numbuf) - (s = cp);
@


1.72
log
@fix trailing combining characters in all shf functions
@
text
@d1044 1
a1044 1
		precision = utf_skipcols(s, precision) - s;
@


1.71
log
@fix potential off-by-one
@
text
@d1043 4
a1046 2
		if (precision) {
			const char *q;
a1047 6
			nwritten += precision;
			q = utf_skipcols(s, precision);
			while (s < q) {
				shf_putc(*s++, shf);
			}
		}
@


1.70
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.63 2014/11/25 21:01:14 tg Exp $");
d1048 3
a1050 3
			do {
				shf_putc(*s, shf);
			} while (++s < q);
@


1.69
log
@plug EEXIST
@
text
@d5 1
a5 1
 *		 2012, 2013, 2015
d200 2
a201 1
		internal_errorf("%s: flags 0x%X", "shf_sopen", sflags);
d456 2
a457 1
		internal_errorf("%s: flags 0x%X", "shf_read", shf->flags);
d494 2
a495 1
		internal_errorf("%s: flags 0x%X", "shf_getse", shf->flags);
d531 2
a532 1
		internal_errorf("%s: flags 0x%X", "shf_getchar", shf->flags);
d548 2
a549 1
		internal_errorf("%s: flags 0x%X", "shf_ungetc", shf->flags);
d586 2
a587 1
		internal_errorf("%s: flags 0x%X", "shf_putchar", shf->flags);
d642 2
a643 1
		internal_errorf("%s: flags 0x%X", "shf_write", shf->flags);
d774 1
a774 1
	ssize_t field, precision, len;
d801 1
a801 1
		for ( ; (c = *fmt++) ; ) {
d831 11
a841 6
				if (flags & FL_DOT)
					precision = tmp;
				else if ((field = tmp) < 0) {
					field = -field;
					flags |= FL_RIGHT;
				}
d863 1
a863 1
				while (c = *fmt++, ksh_isdigit(c)) {
d866 2
a867 2
					tmp = tmp * 10 + ksh_numdig(c);
				}
d872 1
a872 1
					precision = tmp;
d874 1
a874 1
					field = tmp;
a879 3
		if (precision < 0)
			precision = 0;

d965 1
a965 1
			}
a1010 1
				field = -field;
d1023 1
a1023 1
						if (--precision > 0 &&
d1034 4
a1037 7
				if (field < 0) {
					nwritten += -field;
					while (field < 0) {
						shf_putc(c, shf);
						++field;
					}
				}
d1043 1
a1043 1
		if (precision > 0) {
d1052 3
a1054 5
		if (field > 0) {
			nwritten += field;
			for ( ; field > 0 ; --field)
				shf_putc(c, shf);
		}
@


1.68
log
@clean up ifdefs; some errnos are mandatory anyway; add one of those
@
text
@d1124 2
@


1.67
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
a1101 1
#ifdef EPERM
a1103 2
#endif
#ifdef ENOENT
a1105 1
#endif
a1113 1
#ifdef ENOEXEC
d1116 2
a1117 1
#endif
a1121 1
#ifdef EACCES
a1123 2
#endif
#ifdef ENOTDIR
a1125 1
#endif
@


1.66
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.65
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d65 1
a65 1
	fd = open(name, oflags | O_BINARY, mode);
@


1.64
log
@stop (ab)using the OS symbolic constant EOF, always use -1; plus misc fixes
@
text
@d850 1
a850 1
				tmp = c - '0';
d854 1
a854 1
					tmp = tmp * 10 + c - '0';
d875 1
a875 1
		if (c >= 'A' && c <= 'Z') {
d920 1
a920 1
					*--cp = lnum % 10 + '0';
d936 1
a936 1
					*--cp = (lnum & 0x7) + '0';
d948 1
a948 1
					*--cp = digits[lnum & 0xf];
d1016 1
a1016 1
						    (*s | 0x20) == 'x') {
d1028 1
a1028 1
					for ( ; field < 0 ; field++)
d1030 2
@


1.63
log
@kill a Clang 3.2 scan-build workaround (completely; tested by valgrind and
gcc-snapshot’s sanitisers to never be a problem)
@
text
@d5 1
a5 1
 *		 2012, 2013
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.62 2013/10/09 11:59:30 tg Exp $");
d235 1
a235 1
			ret = EOF;
d254 1
a254 1
			ret = EOF;
d286 1
a286 1
 * buffered. Returns 0 for success, EOF for (write) error.
d292 1
a292 1
		return ((shf->flags & SHF_WR) ? EOF : 0);
d299 1
a299 1
		return (EOF);
d318 1
a318 1
 * buffer. Returns 0 for success, EOF for (write) error.
d330 1
a330 1
		return (EOF);
d350 1
a350 1
			return (EOF);
d382 1
a382 1
					return (EOF);
d402 1
a402 1
/* Fill up a read buffer. Returns EOF for a read error, 0 otherwise. */
d417 1
a417 1
		return (EOF);
d420 2
a421 2
	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return (EOF);
d437 1
a437 1
		return (EOF);
d446 1
a446 1
 * no bytes were read, returns 0 if end of file was seen, EOF if a read
d462 1
a462 1
		    (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
d474 1
a474 1
	return (orig_bsize == bsize ? (shf_error(shf) ? EOF : 0) :
d479 1
a479 1
 * Read up to a newline or EOF. The newline is put in buf; buf is always
d501 1
a501 1
			if (shf_fillbuf(shf) == EOF)
d523 1
a523 1
/* Returns the char read. Returns EOF for error and end of file. */
d530 2
a531 2
	if (shf->rnleft == 0 && (shf_fillbuf(shf) == EOF || shf->rnleft == 0))
		return (EOF);
d538 1
a538 1
 * successful, EOF if there is no room.
d546 1
a546 1
	if ((shf->flags & SHF_ERROR) || c == EOF ||
d548 1
a548 1
		return (EOF);
d550 2
a551 2
	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return (EOF);
d561 1
a561 1
			return (EOF);
d574 1
a574 1
 * Write a character. Returns the character if successful, EOF if the
d583 2
a584 2
	if (c == EOF)
		return (EOF);
d594 1
a594 1
			return (EOF);
d603 1
a603 1
				return (EOF);
d607 2
a608 2
		if (shf->wnleft == 0 && shf_emptybuf(shf, EB_GROW) == EOF)
			return (EOF);
d617 1
a617 1
 * Write a string. Returns the length of the string if successful, EOF
d624 1
a624 1
		return (EOF);
d629 1
a629 1
/* Write a buffer. Returns nbytes if successful, EOF if there is an error. */
d656 2
a657 2
				if (shf_emptybuf(shf, EB_GROW) == EOF)
					return (EOF);
d661 2
a662 2
			if (shf_emptybuf(shf, EB_GROW) == EOF)
				return (EOF);
d682 1
a682 1
						return (EOF);
d1052 1
a1052 1
	return (shf_error(shf) ? EOF : nwritten);
@


1.62
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.61 2013/07/21 18:36:03 tg Exp $");
d770 1
a770 6
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1
#ifdef DEBUG
		/* a NUL for LLVM/Clang scan-build */
		+ 1
#endif
	    ];
a907 10
#ifdef DEBUG
			/*
			 * this is necessary so Clang 3.2 realises
			 * utf_skipcols/shf_putc in the output loop
			 * terminate; these values are always ASCII
			 * so an out-of-bounds access cannot happen
			 * but Clang doesn't know that
			 */
			*--cp = '\0';
#endif
a958 4
#ifdef DEBUG
			/* see above comment for Clang 3.2 */
			--len;
#endif
@


1.62.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.63 2014/11/25 21:01:14 tg Exp $");
d770 6
a775 1
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d913 10
d974 4
@


1.62.2.2
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d5 1
a5 1
 *		 2012, 2013, 2015
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.62.2.1 2015/01/25 15:35:53 tg Exp $");
d235 1
a235 1
			ret = -1;
d254 1
a254 1
			ret = -1;
d286 1
a286 1
 * buffered. Returns 0 for success, -1 for (write) error.
d292 1
a292 1
		return ((shf->flags & SHF_WR) ? -1 : 0);
d299 1
a299 1
		return (-1);
d318 1
a318 1
 * buffer. Returns 0 for success, -1 for (write) error.
d330 1
a330 1
		return (-1);
d350 1
a350 1
			return (-1);
d382 1
a382 1
					return (-1);
d402 1
a402 1
/* Fill up a read buffer. Returns -1 for a read error, 0 otherwise. */
d417 1
a417 1
		return (-1);
d420 2
a421 2
	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == -1)
		return (-1);
d437 1
a437 1
		return (-1);
d446 1
a446 1
 * no bytes were read, returns 0 if end of file was seen, -1 if a read
d462 1
a462 1
		    (shf_fillbuf(shf) == -1 || shf->rnleft == 0))
d474 1
a474 1
	return (orig_bsize == bsize ? (shf_error(shf) ? -1 : 0) :
d479 1
a479 1
 * Read up to a newline or -1. The newline is put in buf; buf is always
d501 1
a501 1
			if (shf_fillbuf(shf) == -1)
d523 1
a523 1
/* Returns the char read. Returns -1 for error and end of file. */
d530 2
a531 2
	if (shf->rnleft == 0 && (shf_fillbuf(shf) == -1 || shf->rnleft == 0))
		return (-1);
d538 1
a538 1
 * successful, -1 if there is no room.
d546 1
a546 1
	if ((shf->flags & SHF_ERROR) || c == -1 ||
d548 1
a548 1
		return (-1);
d550 2
a551 2
	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == -1)
		return (-1);
d561 1
a561 1
			return (-1);
d574 1
a574 1
 * Write a character. Returns the character if successful, -1 if the
d583 2
a584 2
	if (c == -1)
		return (-1);
d594 1
a594 1
			return (-1);
d603 1
a603 1
				return (-1);
d607 2
a608 2
		if (shf->wnleft == 0 && shf_emptybuf(shf, EB_GROW) == -1)
			return (-1);
d617 1
a617 1
 * Write a string. Returns the length of the string if successful, -1
d624 1
a624 1
		return (-1);
d629 1
a629 1
/* Write a buffer. Returns nbytes if successful, -1 if there is an error. */
d656 2
a657 2
				if (shf_emptybuf(shf, EB_GROW) == -1)
					return (-1);
d661 2
a662 2
			if (shf_emptybuf(shf, EB_GROW) == -1)
				return (-1);
d682 1
a682 1
						return (-1);
d1052 1
a1052 1
	return (shf_error(shf) ? -1 : nwritten);
@


1.61
log
@partial merge and full RCS ID sync with oksh

merged:
• new regression tests
• check.pl (tests/th) better tmpfile handling
• exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
• ksh.1 1.147: document the above
• eval.c 1.39: “Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).”
  ‣ additionally make shf_open() return errno and actually show
    the error message from the system
• regression-39 test: remove the “maybe” marker
  ‣ but decide on correct POSIX behaviour

already been fixed in mksh:
• check.pl (tests/th) exit 1 if tests fail

not merged:
• main.c 1.52: run traps in unwind() before exiting;
  I’m pretty sure this is already working as-should in mksh
• eval.c 1.38: “Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status.” As discussed in IRC, this is
  just plainly WRONG.
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.60 2013/06/01 20:34:01 tg Exp $");
d65 1
a65 1
	fd = open(name, oflags, mode);
@


1.60
log
@-Wunused-macros
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.59 2013/04/26 19:49:07 tg Exp $");
d55 1
a55 1
	int fd;
d67 1
d69 1
d76 1
d80 1
@


1.59
log
@*** empty log message ***
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.57 2013/03/30 15:39:16 tg Exp $");
a743 2
#define BUF_SIZE	128

@


1.58
log
@rcsid-only sync with oksh, dropping this functionality:
• mail.c was removed anyway
• we do not use “long long” in mksh, since it’s not in ANSI C89

instead, we probably need some 64-bit ops in the long run, but we can
use some host types (might want to use time_t for tv_sec, but we cannot
print that yet); might need to handle them in some generic manner…
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
@


1.57
log
@make "%#s" into print_value_quoted (ignoring field width and precision), if you can get it around gcc’s __printf__ __format__ attribute that is…
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.15 2006/04/02 00:48:33 deraadt Exp $	*/
d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.56 2013/01/01 03:32:44 tg Exp $");
@


1.56
log
@while thinking about mirlibₘᵢₙc I figured that sys_errlist[] entries may be NULL
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.55 2012/12/28 03:20:35 tg Exp $");
d988 4
@


1.55
log
@now that we found out the root case for the recent QNX problem…
03:11⎜«RT|AO:#!/bin/mksh» YES it WORKS now!
… there’s no reason for sys_nerr to not be const, either ☺
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.53 2012/12/17 23:18:11 tg Exp $");
d1105 1
a1105 1
	if (errnum > 0 && errnum < sys_nerr)
@


1.54
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d1093 1
a1093 1
extern int sys_nerr;
@


1.53
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.51 2012/12/17 22:14:27 tg Exp $");
d1090 1
d1094 1
a1094 1
extern char *sys_errlist[];
d1097 1
@


1.52
log
@fix whitespace; ACK RT’s Minix-vmd stmts
@
text
@d1081 3
a1083 10
#if !HAVE_STRERROR
/*
 * This is absolutely minimalistic. We could catch a number of well-
 * known errors (like ENOENT) and provide real error strings for them,
 * but to do that, I'd like a survey of which errors usually occur on
 * what systems, to be worth it. Modern systems do have strerror; this
 * is a porting aid only right now.
 */
char *
strerror(int errnum)
d1085 16
a1100 2
	/* "Errno. " + sign + rounded(octal) bits + NUL */
	static char errbuf[7 + 1 + (8 * sizeof(int) + 2) / 3 + 1];
d1102 53
a1154 2
	shf_snprintf(errbuf, sizeof(errbuf), "Errno. %d", errnum);
	return (errbuf);
@


1.51
log
@RT also said what was missing on SunOS 4.1.1 (it also needs -DMKSH_UNEMPLOYED?)
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.50 2012/12/08 18:30:31 tg Exp $");
d493 1
a493 1
	--bsize;	
d725 1
a725 1
	shf_sclose(&shf); 
@


1.50
log
@add a few assertions for LLVM+Clang 3.2 scan-build; no !DEBUG changes
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.49 2012/12/05 19:38:24 tg Exp $");
d1080 19
@


1.49
log
@fix libFirm/cparser -Wsign-compare
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.48 2012/12/04 01:11:16 tg Exp $");
d767 6
a772 1
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d910 10
d971 4
@


1.48
log
@Be more careful with string array bounds! Found by LLVM+Clang scan-build.
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47 2012/10/03 16:16:15 tg Exp $");
d555 1
a555 1
		if (shf->rp[-1] != c)
@


1.47
log
@rewrite some code to avoid gcc 4.8 complaining
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.46 2012/07/01 15:55:00 tg Exp $");
d974 2
a975 4
			numbuf[0] = (char)(VA(int));
			s = numbuf;
			len = 1;
			break;
d980 1
@


1.47.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47 2012/10/03 16:16:15 tg Exp $");
d974 4
a977 2
			c = (char)(VA(int));
			/* FALLTHROUGH */
a981 1
			numbuf[1] = 0;
@


1.47.2.2
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47.2.1 2012/12/04 01:26:35 tg Exp $");
d555 1
a555 1
		if ((int)(shf->rp[-1]) != c)
@


1.47.2.3
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47.2.2 2012/12/05 19:58:35 tg Exp $");
d493 1
a493 1
	--bsize;
d725 1
a725 1
	shf_sclose(&shf);
d767 1
a767 6
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1
#ifdef DEBUG
		/* a NUL for LLVM/Clang scan-build */
		+ 1
#endif
	    ];
a904 10
#ifdef DEBUG
			/*
			 * this is necessary so Clang 3.2 realises
			 * utf_skipcols/shf_putc in the output loop
			 * terminate; these values are always ASCII
			 * so an out-of-bounds access cannot happen
			 * but Clang doesn't know that
			 */
			*--cp = '\0';
#endif
a955 4
#ifdef DEBUG
			/* see above comment for Clang 3.2 */
			--len;
#endif
@


1.47.2.4
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.47.2.3 2013/01/01 21:20:10 tg Exp $");
d493 1
a493 1
	--bsize;	
d725 1
a725 1
	shf_sclose(&shf); 
d767 6
a772 1
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d910 10
d971 4
@


1.46
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/ – add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.45 2011/10/25 22:36:38 tg Exp $");
d845 2
d848 3
a850 1
				while (c = *fmt++, ksh_isdigit(c))
d852 1
d854 1
a854 2
				if (tmp < 0)
					/* overflow? */
@


1.45
log
@rename more identifiers with trailing underscores
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.44 2011/09/07 15:24:20 tg Exp $");
d1045 1
a1045 1
#ifdef MKSH_SMALL
@


1.44
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.43 2011/08/27 18:06:51 tg Exp $");
d1049 1
a1049 1
	return (shf_getc_(shf));
d1055 1
a1055 1
	return (shf_putc_(c, shf));
@


1.43
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.42 2011/07/16 17:07:35 tg Exp $");
d148 1
a148 1
	shf->errno_ = 0;
d175 1
a175 1
	shf->errno_ = 0;
d215 1
a215 1
	shf->errno_ = 0;
d293 1
a293 1
		errno = shf->errno_;
d324 1
a324 1
		errno = shf->errno_;
d366 1
a366 1
					shf->errno_ = errno;
d411 1
a411 1
			errno = shf->errno_;
d429 1
a429 1
		shf->errno_ = errno;
d588 1
a588 1
			errno = shf->errno_;
d597 1
a597 1
				shf->errno_ = errno;
d671 1
a671 1
						shf->errno_ = errno;
@


1.42
log
@‣ merge from mksh R40-stable
use common macro bodies shf_{get,put}c_ for definition
of shf_{put,get}c as functions (MKSH_SMALL) or macros, respectively
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d22 1
a22 1
 * Use %lX instead of %p and floating point isn't supported at all.
d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.41 2011/03/13 01:20:23 tg Exp $");
d42 2
a43 1
/* Open a file. First three args are for open(), last arg is flags for
d51 2
a52 1
	int bsize = /* at most 512 */
d87 3
a89 3
/* Set up the shf structure for a file descriptor. Doesn't fail. */
struct shf *
shf_fdopen(int fd, int sflags, struct shf *shf)
d91 1
a91 2
	int bsize = /* at most 512 */
	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
d113 1
d117 10
a126 1
		internal_errorf("%s: %s", "shf_fdopen", "missing read/write");
d128 1
d159 2
a160 1
	int bsize = /* at most 512 */
d163 1
a163 24
	/* use fcntl() to figure out correct read/write flags */
	if (sflags & SHF_GETFL) {
		int flags = fcntl(fd, F_GETFL, 0);

		if (flags < 0)
			/* will get an error on first read/write */
			sflags |= SHF_RDWR;
		else {
			switch (flags & O_ACCMODE) {
			case O_RDONLY:
				sflags |= SHF_RD;
				break;
			case O_WRONLY:
				sflags |= SHF_WR;
				break;
			case O_RDWR:
				sflags |= SHF_RDWR;
				break;
			}
		}
	}

	if (!(sflags & (SHF_RD | SHF_WR)))
		internal_errorf("%s: %s", "shf_reopen", "missing read/write");
d181 2
a182 1
/* Open a string for reading or writing. If reading, bsize is the number
d184 2
a185 2
 * bytes that can be written. If shf is not null, it is filled in and
 * returned, if it is null, shf is allocated. If writing and buf is null
d188 1
a188 1
 * When writing, a byte is reserved for a trailing null - see shf_sclose().
d191 1
a191 1
shf_sopen(char *buf, int bsize, int sflags, struct shf *shf)
d259 2
a260 1
/* Close a string - if it was opened for writing, it is null terminated;
d269 1
a269 1
	/* null terminate */
d279 2
a280 1
/* Un-read what has been read but not examined, or write what has been
d311 2
a312 1
/* Write out any buffered data. If currently reading, flushes the read
d329 2
a330 1
		if (flags & EB_READSW) /* doesn't happen */
d338 4
a341 2
		/* Note that we assume SHF_ALLOCS is not set if SHF_ALLOCB
		 * is set... (changing the shf pointer could cause problems)
d352 1
a352 1
		shf->wbsize *= 2;
d356 1
a356 1
			int ntowrite = shf->wp - shf->buf;
a357 1
			int n;
d369 4
a372 2
						/* allow a second flush
						 * to work */
d439 4
a442 3
/* Read a buffer from shf. Returns the number of bytes read into buf,
 * if no bytes were read, returns 0 if end of file was seen, EOF if
 * a read error occurred.
d444 2
a445 2
int
shf_read(char *buf, int bsize, struct shf *shf)
d447 1
a447 2
	int orig_bsize = bsize;
	int ncopy;
d453 1
a453 1
		internal_errorf("%s: %s %d", "shf_write", "bsize", bsize);
d473 5
a477 3
/* Read up to a newline or EOF. The newline is put in buf; buf is always
 * null terminated. Returns NULL on read error or if nothing was read before
 * end of file, returns a pointer to the null byte in buf otherwise.
d480 1
a480 1
shf_getse(char *buf, int bsize, struct shf *shf)
d483 1
a483 1
	int ncopy;
d492 2
a493 1
	--bsize;	/* save room for null */
d503 1
a503 1
		end = (unsigned char *)memchr((char *) shf->rp, '\n',
d531 2
a532 1
/* Put a character back in the input stream. Returns the character if
d551 3
a553 2
		/* Can unget what was read, but not something different - we
		 * don't want to modify a string.
d568 3
a570 2
/* Write a character. Returns the character if successful, EOF if
 * the char could not be written.
d583 1
a583 1
		int n;
d611 3
a613 2
/* Write a string. Returns the length of the string if successful, EOF if
 * the string could not be written.
d615 1
a615 1
int
d625 2
a626 2
int
shf_write(const char *buf, int nbytes, struct shf *shf)
d628 1
a628 1
	int n, ncopy, orig_nbytes = nbytes;
d634 1
a634 1
		internal_errorf("%s: %s %d", "shf_write", "nbytes", nbytes);
d696 1
a696 1
int
d700 1
a700 1
	int n;
d709 2
a710 2
int
shf_snprintf(char *buf, int bsize, const char *fmt, ...)
d714 1
a714 1
	int n;
d717 2
a718 2
		internal_errorf("shf_snprintf: buf %lX, bsize %d",
		    (long)(ptrdiff_t)buf, bsize);
d724 2
a725 1
	shf_sclose(&shf); /* null terminates */
d739 2
a740 1
	return (shf_sclose(&shf)); /* null terminates */
a742 6
#undef FP			/* if you want floating point stuff */

#ifndef DMAXEXP
# define DMAXEXP	128	/* should be big enough */
#endif

a743 4
/* must be > MAX(DMAXEXP, log10(pow(2, DSIGNIF))) + ceil(log10(DMAXEXP)) + 8
 * (I think); since it's hard to express as a constant, just use a large buffer
 */
#define FPBUF_SIZE	(DMAXEXP+16)
d755 2
d758 1
a758 2

int
d763 2
a764 1
	int tmp = 0, field, precision, len, flags;
d769 3
a771 1
	int nwritten = 0;
d783 5
a787 5
		 * This will accept flags/fields in any order - not
		 * just the order specified in printf(3), but this is
		 * the way _doprnt() seems to work (on bsd and sysV).
		 * The only restriction is that the format character must
		 * come last :-).
d789 2
a790 1
		flags = field = precision = 0;
d820 1
a820 1
				tmp = va_arg(args, int);
d830 1
d835 1
d838 5
d849 2
a850 1
				if (tmp < 0)		/* overflow? */
d864 2
a865 1
		if (!c)		/* nasty format */
d876 10
d889 10
d901 1
a901 15
			/*-
			 * XXX any better way to do this?
			 * XXX hopefully the compiler optimises this out
			 *
			 * For shorts, we want sign extend for %d but not
			 * for %[oxu] - on 16 bit machines it doesn't matter.
			 * Assumes C compiler has converted shorts to ints
			 * before pushing them. XXX optimise this -tg
			 */
			if (flags & FL_LONG)
				lnum = va_arg(args, unsigned long);
			else if ((sizeof(int) < sizeof(long)) && (c == 'd'))
				lnum = (long)va_arg(args, int);
			else
				lnum = va_arg(args, unsigned int);
d957 2
a958 1
					precision = len; /* no loss */
d963 1
a963 1
			if (!(s = va_arg(args, const char *)))
d970 1
a970 1
			numbuf[0] = (char)(va_arg(args, int));
@


1.41
log
@lint is your friend
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.40 2010/09/14 21:26:17 tg Exp $");
d1031 1
a1031 2
	return ((shf)->rnleft > 0 ? (shf)->rnleft--, *(shf)->rp++ :
	    shf_getchar(shf));
d1037 1
a1037 2
	return ((shf)->wnleft == 0 ? shf_putchar((c), (shf)) :
	    ((shf)->wnleft--, *(shf)->wp++ = (c)));
@


1.41.2.1
log
@use common macro bodies shf_{get,put}c_ for definition
of shf_{put,get}c as functions (MKSH_SMALL) or macros, respectively
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.41 2011/03/13 01:20:23 tg Exp $");
d1031 2
a1032 1
	return (shf_getc_(shf));
d1038 2
a1039 1
	return (shf_putc_(c, shf));
@


1.40
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.39 2010/08/28 20:22:23 tg Exp $");
d423 1
a423 1
	while (1) {
@


1.39
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.38 2010/08/28 18:50:57 tg Exp $");
d50 2
a51 1
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
d89 2
a90 1
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
d147 2
a148 1
	int bsize = sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
d350 1
a350 1
		nbuf = aresize(shf->buf, 2 * shf->wbsize, shf->areap);
@


1.38
log
@improve string pooling: saves 316 bytes in .text
@
text
@d21 2
d27 1
a27 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.37 2010/08/28 16:47:11 tg Exp $");
d709 2
a710 1
		internal_errorf("shf_snprintf: buf %p, bsize %d", buf, bsize);
a859 5
		case 'p': /* pointer */
			flags &= ~(FL_LONG | FL_SHORT);
			flags |= (sizeof(char *) > sizeof(int)) ?
			    /* hope it fits.. */ FL_LONG : 0;
			/* aaahhh... */
a916 1
			case 'p':
@


1.37
log
@fix blocking_read prototype
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.36 2010/07/19 22:41:04 tg Exp $");
d111 1
a111 1
		internal_errorf("shf_fdopen: missing read/write");
d168 1
a168 1
		internal_errorf("shf_reopen: missing read/write");
d170 1
a170 1
		internal_errorf("shf_reopen: bad shf/buf/bsize");
d199 1
a199 1
		internal_errorf("shf_sopen: flags 0x%x", sflags);
d292 1
a292 1
		internal_errorf("shf_flush: no fd");
d322 1
a322 1
		internal_errorf("shf_emptybuf: no fd");
d404 1
a404 1
		internal_errorf("shf_fillbuf: no fd");
d447 1
a447 1
		internal_errorf("shf_read: flags %x", shf->flags);
d450 1
a450 1
		internal_errorf("shf_read: bsize %d", bsize);
d482 1
a482 1
		internal_errorf("shf_getse: flags %x", shf->flags);
d517 1
a517 1
		internal_errorf("shf_getchar: flags %x", shf->flags);
d532 1
a532 1
		internal_errorf("shf_ungetc: flags %x", shf->flags);
d567 1
a567 1
		internal_errorf("shf_putchar: flags %x", shf->flags);
d577 1
a577 1
			internal_errorf("shf_putchar: no fd");
d621 1
a621 1
		internal_errorf("shf_write: flags %x", shf->flags);
d624 1
a624 1
		internal_errorf("shf_write: nbytes %d", nbytes);
@


1.36
log
@*sigh* this code is interesting: assume you want to output via shf to
a string buffer whose window size is currently 32 (initial), your data
is 96 bytes, this routine used to resize the buffer to 64, append your
first 64 bytes to it (no matter if there's already something in it)
and then writes the remaining bytes to stdio fd instead of the string…
if it doesn’t SIGABRT before

discovered by wbx@@ – thanks – bug inherited from pdksh 5.2.14 (AD 1999)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.35 2009/11/28 14:28:03 tg Exp $");
d398 2
d419 2
a420 4
		shf->rnleft = blocking_read(shf->fd, (char *) shf->buf,
		    shf->rbsize);
		if (shf->rnleft < 0 && errno == EINTR &&
		    !(shf->flags & SHF_INTERRUPT))
d424 8
a431 8
	if (shf->rnleft <= 0) {
		if (shf->rnleft < 0) {
			shf->flags |= SHF_ERROR;
			shf->errno_ = errno;
			shf->rnleft = 0;
			shf->rp = shf->buf;
			return (EOF);
		}
a432 1
	}
@


1.35
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.33 2009/09/20 13:33:48 tg Exp $");
d639 4
a642 19
		/* Flush deals with strings and sticky errors */
		if (shf_emptybuf(shf, EB_GROW) == EOF)
			return (EOF);
		if (nbytes > shf->wbsize) {
			ncopy = nbytes;
			if (shf->wbsize)
				ncopy -= nbytes % shf->wbsize;
			nbytes -= ncopy;
			while (ncopy > 0) {
				n = write(shf->fd, buf, ncopy);
				if (n < 0) {
					if (errno == EINTR &&
					    !(shf->flags & SHF_INTERRUPT))
						continue;
					shf->flags |= SHF_ERROR;
					shf->errno_ = errno;
					shf->wnleft = 0;
					/* Note: fwrite(3S) returns 0 for
					 * errors - this doesn't */
d644 28
a672 2
				buf += n;
				ncopy -= n;
d674 1
d677 1
@


1.34
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d935 1
a935 1
			len = utf_mbswidth(s, true);
@


1.33
log
@optimise
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.32 2009/09/20 13:08:12 tg Exp $");
d935 1
a935 1
			len = utf_mbswidth(s);
@


1.33.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.34 2009/11/28 14:21:46 tg Exp $");
d935 1
a935 1
			len = utf_mbswidth(s, true);
@


1.32
log
@only one digits instance, thank you very much
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.31 2009/08/08 13:08:53 tg Exp $");
d841 1
a841 1
			c = c - 'A' + 'a';
@


1.31
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.30 2009/06/10 18:12:49 tg Exp $");
d910 1
a910 2
				    "0123456789ABCDEF" :
				    "0123456789abcdef";
@


1.30
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.29 2009/06/08 20:06:49 tg Exp $");
d302 1
a302 1
			lseek(shf->fd, (off_t) -shf->rnleft, SEEK_CUR);
@


1.29
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.28 2009/05/16 16:59:40 tg Exp $");
d32 1
a32 1
 * Replacement stdio routines.  Stdio is too flakey on too many machines
d40 2
a41 2
/* Open a file.  First three args are for open(), last arg is flags for
 * this package.  Returns NULL if file could not be opened, or if a dup
d82 1
a82 1
/* Set up the shf structure for a file descriptor.  Doesn't fail. */
d186 4
a189 4
/* Open a string for reading or writing.  If reading, bsize is the number
 * of bytes that can be read.  If writing, bsize is the maximum number of
 * bytes that can be written.  If shf is not null, it is filled in and
 * returned, if it is null, shf is allocated.  If writing and buf is null
d191 1
a191 1
 * used for the initial size).  Doesn't fail.
d283 1
a283 1
 * buffered.  Returns 0 for success, EOF for (write) error.
d313 2
a314 2
/* Write out any buffered data.  If currently reading, flushes the read
 * buffer.  Returns 0 for success, EOF for (write) error.
d394 1
a394 1
/* Fill up a read buffer.  Returns EOF for a read error, 0 otherwise. */
d437 1
a437 1
/* Read a buffer from shf.  Returns the number of bytes read into buf,
d471 2
a472 2
/* Read up to a newline or EOF.  The newline is put in buf; buf is always
 * null terminated.  Returns NULL on read error or if nothing was read before
d513 1
a513 1
/* Returns the char read.  Returns EOF for error and end of file. */
d526 1
a526 1
/* Put a character back in the input stream.  Returns the character if
d561 1
a561 1
/* Write a character.  Returns the character if successful, EOF if
d603 1
a603 1
/* Write a string.  Returns the length of the string if successful, EOF if
d615 1
a615 1
/* Write a buffer.  Returns nbytes if successful, EOF if there is an error. */
d764 5
a768 5
		 *  This will accept flags/fields in any order - not
		 *  just the order specified in printf(3), but this is
		 *  the way _doprnt() seems to work (on bsd and sysV).
		 *  The only restriction is that the format character must
		 *  come last :-).
d864 1
a864 1
			 * before pushing them.  XXX optimise this -tg
d908 1
a908 2
			case 'x':
			    {
d921 1
a921 1
			    }
@


1.28
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.27 2009/04/07 19:25:41 tg Exp $");
d52 1
a52 1
	shf = alloc(sizeof (struct shf) + bsize, ATEMP);
d62 1
a62 1
		return NULL;
d71 1
a71 1
			return NULL;
d79 1
a79 1
	return shf_reopen(fd, sflags, shf);
d120 1
a120 1
		shf = alloc(sizeof (struct shf) + bsize, ATEMP);
d136 1
a136 1
	return shf;
d183 1
a183 1
	return shf;
d202 1
a202 1
		shf = alloc(sizeof (struct shf), ATEMP);
d222 1
a222 1
	return shf;
d241 1
a241 1
	return ret;
d260 1
a260 1
	return ret;
d279 1
a279 1
	return (char *) s;
d289 1
a289 1
		return (shf->flags & SHF_WR) ? EOF : 0;
d296 1
a296 1
		return EOF;
d306 1
a306 1
		return 0;
d308 1
a308 1
		return shf_emptybuf(shf, 0);
d310 1
a310 1
	return 0;
d326 1
a326 1
		return EOF;
d331 1
a331 1
			return 0;
d343 1
a343 1
			return EOF;
d374 1
a374 1
					return EOF;
d383 1
a383 1
				return 0;
d391 1
a391 1
	return ret;
d399 1
a399 1
		return 0;
d407 1
a407 1
		return EOF;
d411 1
a411 1
		return EOF;
d430 1
a430 1
			return EOF;
d434 1
a434 1
	return 0;
d467 2
a468 2
	return orig_bsize == bsize ? (shf_error(shf) ? EOF : 0) :
	    orig_bsize - bsize;
d486 1
a486 1
		return NULL;
d492 1
a492 1
				return NULL;
d495 1
a495 1
				return buf == orig_buf ? NULL : buf;
d510 1
a510 1
	return buf;
d521 1
a521 1
		return EOF;
d523 1
a523 1
	return *shf->rp++;
d537 1
a537 1
		return EOF;
d540 1
a540 1
		return EOF;
d549 1
a549 1
			return EOF;
d553 1
a553 1
		return c;
d558 1
a558 1
	return c;
d571 1
a571 1
		return EOF;
d581 1
a581 1
			return EOF;
d590 1
a590 1
				return EOF;
d595 1
a595 1
			return EOF;
d600 1
a600 1
	return c;
d610 1
a610 1
		return EOF;
d612 1
a612 1
	return shf_write(s, strlen(s), shf);
d641 1
a641 1
			return EOF;
d658 1
a658 1
					return EOF;
d671 1
a671 1
	return orig_nbytes;
d684 1
a684 1
	return n;
d702 1
a702 1
	return n;
d715 1
a715 1
	return shf_sclose(&shf); /* null terminates */
d750 1
a750 1
	char numbuf[(8 * sizeof (long) + 2) / 3 + 1];
d755 1
a755 1
		return 0;
d856 1
a856 1
			cp = numbuf + sizeof (numbuf);
d868 1
a868 1
			else if ((sizeof (int) < sizeof (long)) && (c == 'd'))
d924 1
a924 1
			len = numbuf + sizeof (numbuf) - (s = cp);
d1014 1
a1014 1
	return shf_error(shf) ? EOF : nwritten;
@


1.27
log
@of *course* I had to introduce an inverse-logic error
d'oh. the XOR check's result needs to be reversed, as it tests for validity
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.26 2009/04/07 19:08:25 tg Exp $");
@


1.26
log
@simplify
	if ((flags & (1 | 2) == 0) || (flags & (1 | 2) == (1 | 2)))
to
	if (!(flags & 1) ^ !(flags & 2))
which works because ! returns 1 or 0, making the ^ an ^^, and
because XOR survives NOTting its arguments
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.25 2009/03/14 18:12:55 tg Exp $");
d178 1
a178 1
	if (!(sflags & SHF_RD) ^ !(sflags & SHF_WR))
@


1.25
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.24 2008/12/13 17:02:17 tg Exp $");
d178 1
a178 2
	if (!(sflags & (SHF_RD | SHF_WR)) ||
	    (sflags & (SHF_RD | SHF_WR)) == (SHF_RD | SHF_WR))
@


1.24
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.22 2008/10/10 21:30:43 tg Exp $");
d731 1
a731 1
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d850 1
a850 1
				lnum = (long) va_arg(args, int);
d856 4
a859 3
				if (0 > (long) lnum)
					lnum = - (long) lnum, tmp = 1;
				else
d861 1
a861 2
				/* aaahhhh..... */

@


1.23
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d32 1
a32 1
	shf = alloc(1, sizeof (struct shf) + bsize, ATEMP);
d95 1
a95 1
			shf->buf = alloc(1, bsize, ATEMP);
d100 1
a100 1
		shf = alloc(1, sizeof (struct shf) + bsize, ATEMP);
d183 1
a183 1
		shf = alloc(1, sizeof (struct shf), ATEMP);
d191 1
a191 1
		buf = alloc(1, bsize, shf->areap);
d326 1
a326 1
		nbuf = aresize(shf->buf, 2, shf->wbsize, shf->areap);
@


1.23.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.23 2008/11/12 00:54:51 tg Exp $");
d32 2
a33 2
	shf = galloc(1, sizeof (struct shf) + bsize, ATEMP);
	shf->gp_shf = ATEMP;
d41 1
a41 1
		gfree(shf, shf->gp_shf);
d50 1
a50 1
			gfree(shf, shf->gp_shf);
d95 1
a95 1
			shf->buf = galloc(1, bsize, ATEMP);
d100 1
a100 1
		shf = galloc(1, sizeof (struct shf) + bsize, ATEMP);
d104 1
a104 1
	shf->gp_shf = ATEMP;
d183 1
a183 1
		shf = galloc(1, sizeof (struct shf), ATEMP);
d186 1
a186 1
	shf->gp_shf = ATEMP;
d191 1
a191 1
		buf = galloc(1, bsize, shf->gp_shf);
d218 1
a218 1
		gfree(shf, shf->gp_shf);
d220 1
a220 1
		gfree(shf->buf, shf->gp_shf);
d259 1
a259 1
		gfree(shf, shf->gp_shf);
d326 1
a326 1
		nbuf = grealloc(shf->buf, 2, shf->wbsize, shf->gp_shf);
@


1.22
log
@fix prodded by cnuke@@ for AIX with IBM xlC 7.0:
fool the compiler into not doing static bounds checking when we do
one-past-the-array-boundary pointer assignments for cases where the
only accesses are like (*--pointer); bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.21 2008/05/17 18:47:02 tg Exp $");
d32 1
a32 1
	shf = (struct shf *)alloc(sizeof (struct shf) + bsize, ATEMP);
d95 1
a95 1
			shf->buf = (unsigned char *)alloc(bsize, ATEMP);
d100 1
a100 1
		shf = (struct shf *)alloc(sizeof (struct shf) + bsize, ATEMP);
d183 1
a183 1
		shf = (struct shf *)alloc(sizeof (struct shf), ATEMP);
d191 1
a191 1
		buf = alloc(bsize, shf->areap);
d326 1
a326 2
		nbuf = (unsigned char *)aresize(shf->buf, shf->wbsize * 2,
		    shf->areap);
@


1.21
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.20 2008/05/02 18:55:37 tg Exp $");
d838 1
a838 1
			cp = &numbuf[sizeof (numbuf)];
d906 1
a906 1
			len = &numbuf[sizeof (numbuf)] - (s = cp);
@


1.20
log
@thinko: multibyte characters are not always 1 column wide
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.19 2008/04/19 22:15:05 tg Exp $");
d32 1
a32 1
	shf = (struct shf *) alloc(sizeof(struct shf) + bsize, ATEMP);
d100 1
a100 1
		shf = (struct shf *)alloc(sizeof(struct shf) + bsize, ATEMP);
d183 1
a183 1
		shf = (struct shf *) alloc(sizeof(struct shf), ATEMP);
@


1.19
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.18 2008/04/19 17:21:55 tg Exp $");
d981 1
a981 1
			const char *q = s;
d984 1
a984 2
			while (precision-- > 0)
				utf_cptradj(q, &q);
@


1.18
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.17 2008/03/28 13:28:33 tg Exp $");
d34 1
a34 1
	shf->buf = (unsigned char *) &shf[1];
d95 1
a95 1
			shf->buf = (unsigned char *) alloc(bsize, ATEMP);
d100 2
a101 2
		shf = (struct shf *) alloc(sizeof(struct shf) + bsize, ATEMP);
		shf->buf = (unsigned char *) &shf[1];
d194 1
a194 1
	shf->buf = shf->rp = shf->wp = (unsigned char *) buf;
d317 1
a317 1
		unsigned char	*nbuf;
d326 1
a326 1
		nbuf = (unsigned char *) aresize(shf->buf, shf->wbsize * 2,
d480 1
a480 1
		end = (unsigned char *) memchr((char *) shf->rp, '\n',
d853 1
a853 1
				lnum = va_arg(args, unsigned);
d919 1
a919 1
			len = ksh_mbswidth(s);
d981 2
d984 3
a986 8
			if (Flag(FUTFHACK)) {
				const char *q = s;
				while (precision-- > 0)
					utf_cptradj(q, &q);
				do {
					shf_putc(*s, shf);
				} while (++s < q);
			} else while (precision-- > 0) {
d988 1
a988 2
				s++;
			}
@


1.17
log
@fix most of the fixable bitchings of MIPSpro compiler (complainer?)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.16 2007/10/25 15:23:10 tg Exp $");
d601 1
a601 3
	int orig_nbytes = nbytes;
	int n;
	int ncopy;
d919 1
a919 1
			len = strlen(s);
d982 8
a989 1
			for ( ; precision-- > 0 ; s++)
d991 2
@


1.16
log
@get rid of u_char, u_int, u_long
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.15 2007/06/06 23:28:17 tg Exp $");
d679 1
a679 2
		internal_errorf("shf_snprintf: buf %lx, bsize %d",
			(long)buf, bsize);
@


1.16.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.17 2008/03/28 13:28:33 tg Exp $");
d679 2
a680 1
		internal_errorf("shf_snprintf: buf %p, bsize %d", buf, bsize);
@


1.16.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.21 2008/05/17 18:47:02 tg Exp $");
d32 1
a32 1
	shf = (struct shf *)alloc(sizeof (struct shf) + bsize, ATEMP);
d34 1
a34 1
	shf->buf = (unsigned char *)&shf[1];
d95 1
a95 1
			shf->buf = (unsigned char *)alloc(bsize, ATEMP);
d100 2
a101 2
		shf = (struct shf *)alloc(sizeof (struct shf) + bsize, ATEMP);
		shf->buf = (unsigned char *)&shf[1];
d183 1
a183 1
		shf = (struct shf *)alloc(sizeof (struct shf), ATEMP);
d194 1
a194 1
	shf->buf = shf->rp = shf->wp = (unsigned char *)buf;
d317 1
a317 1
		unsigned char *nbuf;
d326 1
a326 1
		nbuf = (unsigned char *)aresize(shf->buf, shf->wbsize * 2,
d480 1
a480 1
		end = (unsigned char *)memchr((char *) shf->rp, '\n',
d601 3
a603 1
	int n, ncopy, orig_nbytes = nbytes;
d855 1
a855 1
				lnum = va_arg(args, unsigned int);
d921 1
a921 1
			len = utf_mbswidth(s);
a982 2
			const char *q;

d984 1
a984 2
			q = utf_skipcols(s, precision);
			do {
a985 1
			} while (++s < q);
@


1.16.2.3
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.24 2008/12/13 17:02:17 tg Exp $");
d32 1
a32 1
	shf = alloc(sizeof (struct shf) + bsize, ATEMP);
d95 1
a95 1
			shf->buf = alloc(bsize, ATEMP);
d100 1
a100 1
		shf = alloc(sizeof (struct shf) + bsize, ATEMP);
d183 1
a183 1
		shf = alloc(sizeof (struct shf), ATEMP);
d326 2
a327 1
		nbuf = aresize(shf->buf, 2 * shf->wbsize, shf->areap);
d838 1
a838 1
			cp = numbuf + sizeof (numbuf);
d906 1
a906 1
			len = numbuf + sizeof (numbuf) - (s = cp);
@


1.15
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.14 2007/05/13 17:51:23 tg Exp $");
d556 1
a556 1
		u_char cc = (u_char)c;
@


1.14
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.13 2007/03/10 18:16:28 tg Exp $");
d556 1
a556 1
		char cc = c;
d927 1
a927 1
			numbuf[0] = va_arg(args, int);
@


1.13
log
@some gcc 4.1.2pre warning shutup
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.12 2007/03/04 03:04:27 tg Exp $");
d91 1
a91 1
		internal_errorf(1, "shf_fdopen: missing read/write");
d148 1
a148 1
		internal_errorf(1, "shf_reopen: missing read/write");
d150 1
a150 1
		internal_errorf(1, "shf_reopen: bad shf/buf/bsize");
d180 1
a180 1
		internal_errorf(1, "shf_sopen: flags 0x%x", sflags);
d273 1
a273 1
		internal_errorf(1, "shf_flush: no fd");
d303 1
a303 1
		internal_errorf(1, "shf_emptybuf: no fd");
d384 1
a384 1
		internal_errorf(1, "shf_fillbuf: no fd");
d430 1
a430 1
		internal_errorf(1, "shf_read: flags %x", shf->flags);
d433 1
a433 1
		internal_errorf(1, "shf_read: bsize %d", bsize);
d465 1
a465 1
		internal_errorf(1, "shf_getse: flags %x", shf->flags);
d500 1
a500 1
		internal_errorf(1, "shf_getchar: flags %x", shf->flags);
d515 1
a515 1
		internal_errorf(1, "shf_ungetc: flags %x", shf->flags);
d550 1
a550 1
		internal_errorf(1, "shf_putchar: flags %x", shf->flags);
d560 1
a560 1
			internal_errorf(1, "shf_putchar: no fd");
d606 1
a606 1
		internal_errorf(1, "shf_write: flags %x", shf->flags);
d609 1
a609 1
		internal_errorf(1, "shf_write: nbytes %d", nbytes);
d679 2
a680 2
		internal_errorf(1, "shf_snprintf: buf %lx, bsize %d",
			(long) buf, bsize);
@


1.13.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.13 2007/03/10 18:16:28 tg Exp $");
d91 1
a91 1
		internal_errorf("shf_fdopen: missing read/write");
d148 1
a148 1
		internal_errorf("shf_reopen: missing read/write");
d150 1
a150 1
		internal_errorf("shf_reopen: bad shf/buf/bsize");
d180 1
a180 1
		internal_errorf("shf_sopen: flags 0x%x", sflags);
d273 1
a273 1
		internal_errorf("shf_flush: no fd");
d303 1
a303 1
		internal_errorf("shf_emptybuf: no fd");
d384 1
a384 1
		internal_errorf("shf_fillbuf: no fd");
d430 1
a430 1
		internal_errorf("shf_read: flags %x", shf->flags);
d433 1
a433 1
		internal_errorf("shf_read: bsize %d", bsize);
d465 1
a465 1
		internal_errorf("shf_getse: flags %x", shf->flags);
d500 1
a500 1
		internal_errorf("shf_getchar: flags %x", shf->flags);
d515 1
a515 1
		internal_errorf("shf_ungetc: flags %x", shf->flags);
d550 1
a550 1
		internal_errorf("shf_putchar: flags %x", shf->flags);
d560 1
a560 1
			internal_errorf("shf_putchar: no fd");
d606 1
a606 1
		internal_errorf("shf_write: flags %x", shf->flags);
d609 1
a609 1
		internal_errorf("shf_write: nbytes %d", nbytes);
d679 2
a680 2
		internal_errorf("shf_snprintf: buf %lx, bsize %d",
			(long)buf, bsize);
@


1.12
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.11 2007/01/15 02:48:28 tg Exp $");
d832 2
a833 2
			if (sizeof(char *) > sizeof(int))
				flags |= FL_LONG; /* hope it fits.. */
@


1.11
log
@shrink .data a little
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.10 2007/01/15 00:37:42 tg Exp $");
d17 2
a18 2
static int	shf_fillbuf(struct shf *);
static int	shf_emptybuf(struct shf *, int);
@


1.10
log
@fold POP_INT into code
XXX untested, may break things or have side effects
XXX not optimised and ugly as hell, can't we do it better?
XXX do I understand it entirely?

tested on sun4u -m64 only
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.9 2007/01/12 10:18:22 tg Exp $");
d730 6
a735 8
	char		c, *s;
	int		tmp = 0;
	int		field, precision;
	int		len;
	int		flags;
	unsigned long	lnum;
					/* %#o produces the longest output */
	char		numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d737 1
a737 3
	int		nwritten = 0;

	static char	nulls[] = "(null %s)";
d841 1
a841 1
			s = &numbuf[sizeof(numbuf)];
d868 1
a868 1
					*--s = lnum % 10 + '0';
d874 1
a874 1
						*--s = '-';
d876 1
a876 1
						*--s = '+';
d878 1
a878 1
						*--s = ' ';
d884 1
a884 1
					*--s = (lnum & 0x7) + '0';
d888 2
a889 2
				if ((flags & FL_HASH) && *s != '0')
					*--s = '0';
d899 1
a899 1
					*--s = digits[lnum & 0xf];
d904 2
a905 2
					*--s = (flags & FL_UPPER) ? 'X' : 'x';
					*--s = '0';
d909 1
a909 1
			len = &numbuf[sizeof(numbuf)] - s;
d920 2
a921 2
			if (!(s = va_arg(args, char *)))
				s = nulls;
d941 2
a942 3
		 *	At this point s should point to a string that is
		 *  to be formatted, and len should be the length of the
		 *  string.
d952 2
a953 1
					if (*s == '+' || *s == '-' || *s ==' ') {
@


1.9
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.8 2006/11/10 07:52:04 tg Exp $");
d710 4
a713 20
#define FPBUF_SIZE	(DMAXEXP+16)/* this must be >
				 *	MAX(DMAXEXP, log10(pow(2, DSIGNIF)))
				 *    + ceil(log10(DMAXEXP)) + 8 (I think).
				 * Since this is hard to express as a
				 * constant, just use a large buffer.
				 */

/*
 *	What kinda of machine we on?  Hopefully the C compiler will optimise
 *  this out...
 *
 *	For shorts, we want sign extend for %d but not for %[oxu] - on 16 bit
 *  machines it don't matter.  Assumes C compiler has converted shorts to
 *  ints before pushing them.
 */
#define POP_INT(f, s, a) \
	(((f) & FL_LONG) ? va_arg((a), unsigned long) :			\
	    (sizeof(int) < sizeof(long) ? ((s) ?			\
	    (long) va_arg((a), int) : va_arg((a), unsigned)) :		\
	    va_arg((a), unsigned)))
d846 15
a860 1
			lnum = POP_INT(flags, c == 'd', args);
@


1.9.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.11 2007/01/15 02:48:28 tg Exp $");
d710 20
a729 4
/* must be > MAX(DMAXEXP, log10(pow(2, DSIGNIF))) + ceil(log10(DMAXEXP)) + 8
 * (I think); since it's hard to express as a constant, just use a large buffer
 */
#define FPBUF_SIZE	(DMAXEXP+16)
d746 8
a753 6
	const char *s;
	char c, *cp;
	int tmp = 0, field, precision, len, flags;
	unsigned long lnum;
	/* %#o produces the longest output */
	char numbuf[(8 * sizeof(long) + 2) / 3 + 1];
d755 3
a757 1
	int nwritten = 0;
d861 2
a862 16
			cp = &numbuf[sizeof (numbuf)];
			/*-
			 * XXX any better way to do this?
			 * XXX hopefully the compiler optimises this out
			 *
			 * For shorts, we want sign extend for %d but not
			 * for %[oxu] - on 16 bit machines it doesn't matter.
			 * Assumes C compiler has converted shorts to ints
			 * before pushing them.  XXX optimise this -tg
			 */
			if (flags & FL_LONG)
				lnum = va_arg(args, unsigned long);
			else if ((sizeof (int) < sizeof (long)) && (c == 'd'))
				lnum = (long) va_arg(args, int);
			else
				lnum = va_arg(args, unsigned);
d874 1
a874 1
					*--cp = lnum % 10 + '0';
d880 1
a880 1
						*--cp = '-';
d882 1
a882 1
						*--cp = '+';
d884 1
a884 1
						*--cp = ' ';
d890 1
a890 1
					*--cp = (lnum & 0x7) + '0';
d894 2
a895 2
				if ((flags & FL_HASH) && *cp != '0')
					*--cp = '0';
d905 1
a905 1
					*--cp = digits[lnum & 0xf];
d910 2
a911 2
					*--cp = (flags & FL_UPPER) ? 'X' : 'x';
					*--cp = '0';
d915 1
a915 1
			len = &numbuf[sizeof (numbuf)] - (s = cp);
d926 2
a927 2
			if (!(s = va_arg(args, const char *)))
				s = "(null)";
d947 3
a949 2
		 * At this point s should point to a string that is to be
		 * formatted, and len should be the length of the string.
d959 1
a959 2
					if (*s == '+' || *s == '-' ||
					    *s == ' ') {
@


1.8
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.7 2006/11/09 21:00:13 tg Exp $");
d718 1
a718 1
 *	What kinda of machine we on?  Hopefully the C compiler will optimize
@


1.7
log
@optional (#ifdef MKSH_SMALL) saving of 364 more bytes of .text
intended e.g. for FreeWRT
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.6 2006/08/02 12:50:20 tg Exp $");
d822 1
a822 1
			if (digit(c)) {
d824 1
a824 1
				while (c = *fmt++, digit(c))
@


1.6
log
@rid junk
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.5 2006/05/10 18:54:12 tg Exp $");
d1003 16
@


1.5
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.4 2006/01/29 20:04:53 tg Exp $");
a730 3
#define ABIGNUM		32000	/* big numer that will fit in a short */
#define LOG2_10		3.321928094887362347870319429	/* log base 2 of 10 */

@


1.4
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.14 2005/12/11 18:53:51 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.3 2005/11/22 18:40:43 tg Exp $");
d283 1
a283 1
			lseek(shf->fd, (off_t) -shf->rnleft, 1);
@


1.3
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: shf.c,v 1.13 2005/03/30 17:16:37 deraadt Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.2 2005/10/25 19:53:29 tg Exp $");
a262 16
/* Flush and free file structure, don't close file descriptor */
int
shf_finish(struct shf *shf)
{
	int ret = 0;

	if (shf->fd >= 0)
		ret = shf_flush(shf);
	if (shf->flags & SHF_ALLOCS)
		afree(shf, shf->areap);
	else if (shf->flags & SHF_ALLOCB)
		afree(shf->buf, shf->areap);

	return ret;
}

a418 44
/* Seek to a new position in the file.  If writing, flushes the buffer
 * first.  If reading, optimizes small relative seeks that stay inside the
 * buffer.  Returns 0 for success, EOF otherwise.
 */
int
shf_seek(struct shf *shf, off_t where, int from)
{
	if (shf->fd < 0) {
		errno = EINVAL;
		return EOF;
	}

	if (shf->flags & SHF_ERROR) {
		errno = shf->errno_;
		return EOF;
	}

	if ((shf->flags & SHF_WRITING) && shf_emptybuf(shf, EB_READSW) == EOF)
		return EOF;

	if (shf->flags & SHF_READING) {
		if (from == SEEK_CUR &&
		    (where < 0 ? -where >= shf->rbsize - shf->rnleft :
		    where < shf->rnleft)) {
			shf->rnleft -= where;
			shf->rp += where;
			return 0;
		}
		shf->rnleft = 0;
		shf->rp = shf->buf;
	}

	shf->flags &= ~(SHF_EOF | SHF_READING | SHF_WRITING);

	if (lseek(shf->fd, where, from) < 0) {
		shf->errno_ = errno;
		shf->flags |= SHF_ERROR;
		return EOF;
	}

	return 0;
}


@


1.2
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/shf.c,v 1.1 2005/05/23 03:06:10 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.1 2005/05/23 03:06:10 tg Exp $");
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/shf.c,v 1.8 2005/05/23 02:37:16 tg Exp $ */
a4 1
#include <sys/stat.h>
d6 1
a6 1
__RCSID("$MirOS: mksh/shf.c,v 1.8 2005/05/23 02:37:16 tg Exp $");
@

