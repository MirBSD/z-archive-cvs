head	1.346;
access;
symbols
	mksh-R57:1.343
	mksh-R56c:1.342
	mksh-R56b:1.340
	mksh-R56:1.339
	mksh-R55:1.321
	mksh-R54:1.312
	mksh-R53a:1.306
	mksh-R53:1.306
	mksh-R52c:1.294
	mksh-R52b:1.292
	mksh-R52:1.292
	mksh-R51:1.290
	mksh-R50f:1.276.2.5
	mksh-R50e:1.276.2.3
	mksh-R50stable:1.276.0.2
	mksh-R50d:1.276
	mksh-R50c:1.276
	mksh-R50b:1.276
	mksh-R50:1.275
	mksh-R49:1.275
	mksh-R48b:1.271
	mksh-R48:1.270
	mksh-R47:1.267
	mksh-R46:1.266
	mksh-R45:1.265
	mksh-R44:1.265
	mksh-R43:1.265
	mksh-R42b:1.265
	mksh-R41c:1.256.2.2
	mksh-R41b:1.256.2.2
	mksh-R42:1.265
	mksh-R41:1.256
	mksh-R41stable:1.256.0.2
	mksh-wheezy:1.237.0.4
	tg-multikey-bind:1.237.0.2
	mksh-R40f:1.234
	mksh-R40e:1.230
	mksh-R40d:1.225
	mksh-R40c:1.222
	mksh-R40b:1.219
	mksh-R40stable:1.234.0.2
	mksh-R40:1.215
	mksh-R39c:1.190
	mksh-R39b:1.189
	tg-wcswidth-behaviour:1.184.0.2
	tg-nameref:1.175.0.2
	mksh-R39:1.173
	tg-mksh-printf-builtin:1.172.0.2
	mksh-R38c:1.170
	mksh-R38b:1.164
	mksh-R38:1.164
	mksh-R37c:1.160
	mksh-R37b:1.159
	mksh-R37:1.156
	mksh-R36b:1.148
	tg-aalloc-experimental_BASE:1.146
	tg-aalloc-experimental:1.146.0.2
	mksh-R36:1.139
	mksh-R35b:1.127
	mksh-R35:1.127
	mksh-R33d:1.119
	mksh-R33c:1.119
	mksh-R33b:1.118
	MIRBSD_10:1.117.0.2
	MIRBSD_10_BASE:1.117
	mksh-R33:1.117
	mksh-R32:1.117
	mksh-R31d:1.115
	mksh-R31c:1.113
	mksh-R31b:1.113
	mksh-R31:1.111
	mksh-R30:1.107
	mksh-R29g:1.87.2.4
	mksh-R29f:1.87.2.3
	mksh-R29e:1.87.2.2
	mksh-R29stable:1.87.0.2
	mksh-R29d:1.87
	mksh-R29c:1.87
	mksh-R29b:1.87
	mksh-R29:1.84
	mksh-R28:1.38
	tg-mksh-plan9ape_BASE:1.38
	tg-mksh-plan9ape:1.36.0.2
	mksh-R27e:1.22
	MIRBSD_9_BASE:1.21
	mksh-R27d:1.21
	mksh-R27:1.21
	mksh-R26c:1.18
	mksh-R26b:1.17
	MIRBSD_8:1.17.0.2
	MIRBSD_8_BASE:1.17
	mksh-R26:1.17
	mksh-R25:1.16
	mksh-R24c:1.13
	mksh-R24b:1.13
	mksh-R24:1.9
	mksh-R23:1.8
	mksh-R22:1.5
	mksh-R21:1.3;
locks; strict;
comment	@ * @;


1.346
date	2019.12.11.23.58.16;	author tg;	state Exp;
branches;
next	1.345;
commitid	1005DF182AD50645981;

1.345
date	2019.12.11.17.36.12;	author tg;	state Exp;
branches;
next	1.344;
commitid	1005DF1290A241F4E7F;

1.344
date	2019.12.11.17.31.22;	author tg;	state Exp;
branches;
next	1.343;
commitid	1005DF127FC4EA0D36F;

1.343
date	2018.07.15.16.16.38;	author tg;	state Exp;
branches;
next	1.342;
commitid	1005B4B737249BF6D4F;

1.342
date	2018.01.14.00.03.00;	author tg;	state Exp;
branches;
next	1.341;
commitid	1005A5A9E3D208A81CB;

1.341
date	2018.01.13.23.55.09;	author tg;	state Exp;
branches;
next	1.340;
commitid	1005A5A9C627E45C2B1;

1.340
date	2017.08.27.23.33.50;	author tg;	state Exp;
branches;
next	1.339;
commitid	10059A356DB182F3791;

1.339
date	2017.08.08.00.03.56;	author tg;	state Exp;
branches;
next	1.338;
commitid	1005988FFEF7E781EBB;

1.338
date	2017.08.07.23.23.12;	author tg;	state Exp;
branches;
next	1.337;
commitid	1005988F66D4BE6E590;

1.337
date	2017.05.05.22.53.26;	author tg;	state Exp;
branches;
next	1.336;
commitid	100590D026845CD3DFF;

1.336
date	2017.05.05.20.36.00;	author tg;	state Exp;
branches;
next	1.335;
commitid	100590CE24264B3D492;

1.335
date	2017.04.29.22.04.26;	author tg;	state Exp;
branches;
next	1.334;
commitid	10059050DFF02CF9B3E;

1.334
date	2017.04.29.14.20.23;	author tg;	state Exp;
branches;
next	1.333;
commitid	1005904A1366B51E1F2;

1.333
date	2017.04.28.03.37.43;	author tg;	state Exp;
branches;
next	1.332;
commitid	1005902B9086FFD0E52;

1.332
date	2017.04.28.03.28.17;	author tg;	state Exp;
branches;
next	1.331;
commitid	1005902B6DC3ECE3910;

1.331
date	2017.04.28.02.24.56;	author tg;	state Exp;
branches;
next	1.330;
commitid	1005902A8007F54B819;

1.330
date	2017.04.28.00.49.32;	author tg;	state Exp;
branches;
next	1.329;
commitid	100590291AF6848CD3A;

1.329
date	2017.04.28.00.38.28;	author tg;	state Exp;
branches;
next	1.328;
commitid	10059028F0E0808B3E9;

1.328
date	2017.04.27.23.12.44;	author tg;	state Exp;
branches;
next	1.327;
commitid	10059027AFC0DEF48C9;

1.327
date	2017.04.27.20.22.22;	author tg;	state Exp;
branches;
next	1.326;
commitid	1005902531266D3FCB6;

1.326
date	2017.04.27.19.33.46;	author tg;	state Exp;
branches;
next	1.325;
commitid	100590247A92C66CAF9;

1.325
date	2017.04.22.00.07.06;	author tg;	state Exp;
branches;
next	1.324;
commitid	10058FA9D043131DCC0;

1.324
date	2017.04.21.20.06.03;	author tg;	state Exp;
branches;
next	1.323;
commitid	10058FA66392543430F;

1.323
date	2017.04.21.19.50.06;	author tg;	state Exp;
branches;
next	1.322;
commitid	10058FA61D94E9BD833;

1.322
date	2017.04.21.19.08.17;	author tg;	state Exp;
branches;
next	1.321;
commitid	10058FA58B011749B28;

1.321
date	2017.04.12.16.46.20;	author tg;	state Exp;
branches;
next	1.320;
commitid	10058EE59ED44DAA3D5;

1.320
date	2017.04.12.15.54.47;	author tg;	state Exp;
branches;
next	1.319;
commitid	10058EE4DD038BE8CE6;

1.319
date	2017.04.08.20.35.03;	author tg;	state Exp;
branches;
next	1.318;
commitid	10058E9498414A8349F;

1.318
date	2017.04.06.01.59.53;	author tg;	state Exp;
branches;
next	1.317;
commitid	10058E5A1067AFA1BBA;

1.317
date	2017.04.05.22.54.51;	author tg;	state Exp;
branches;
next	1.316;
commitid	10058E575D1476F1D1C;

1.316
date	2017.04.02.15.43.24;	author tg;	state Exp;
branches;
next	1.315;
commitid	10058E11C312412E0CA;

1.315
date	2017.04.02.15.42.59;	author tg;	state Exp;
branches;
next	1.314;
commitid	10058E11C0D52C7FCF0;

1.314
date	2017.04.02.15.00.40;	author tg;	state Exp;
branches;
next	1.313;
commitid	10058E1121E64BBAB7B;

1.313
date	2017.03.11.22.49.54;	author tg;	state Exp;
branches;
next	1.312;
commitid	10058C47F07715C2B99;

1.312
date	2016.11.11.23.48.28;	author tg;	state Exp;
branches;
next	1.311;
commitid	100582658D43CBE5F67;

1.311
date	2016.11.11.23.31.33;	author tg;	state Exp;
branches;
next	1.310;
commitid	100582654B972655F84;

1.310
date	2016.11.11.21.13.21;	author tg;	state Exp;
branches;
next	1.309;
commitid	1005826347D6811313F;

1.309
date	2016.11.11.20.14.16;	author tg;	state Exp;
branches;
next	1.308;
commitid	100582626A23DD889A9;

1.308
date	2016.11.11.19.59.37;	author tg;	state Exp;
branches;
next	1.307;
commitid	1005826231A4E1347A4;

1.307
date	2016.09.01.12.59.08;	author tg;	state Exp;
branches;
next	1.306;
commitid	10057C8260A04757349;

1.306
date	2016.08.01.18.42.40;	author tg;	state Exp;
branches;
next	1.305;
commitid	100579F982F7FDB005E;

1.305
date	2016.08.01.14.25.39;	author tg;	state Exp;
branches;
next	1.304;
commitid	100579F5BD54EB3A22D;

1.304
date	2016.07.28.21.39.04;	author tg;	state Exp;
branches;
next	1.303;
commitid	100579A7B917689A864;

1.303
date	2016.07.26.22.55.35;	author tg;	state Exp;
branches;
next	1.302;
commitid	1005797EA754611E40B;

1.302
date	2016.07.26.21.37.24;	author tg;	state Exp;
branches;
next	1.301;
commitid	1005797D80749BA13A1;

1.301
date	2016.07.26.20.43.14;	author tg;	state Exp;
branches;
next	1.300;
commitid	1005797CB726D7DD2DD;

1.300
date	2016.07.26.20.13.40;	author tg;	state Exp;
branches;
next	1.299;
commitid	1005797C48A1DA92449;

1.299
date	2016.07.25.20.43.51;	author tg;	state Exp;
branches;
next	1.298;
commitid	10057967A0D0C01C9C9;

1.298
date	2016.07.25.00.04.39;	author tg;	state Exp;
branches;
next	1.297;
commitid	1005795579F14A3FE5C;

1.297
date	2016.07.12.23.07.09;	author tg;	state Exp;
branches;
next	1.296;
commitid	100578578165D391F66;

1.296
date	2016.05.05.22.56.12;	author tg;	state Exp;
branches;
next	1.295;
commitid	100572BCF9760C8313C;

1.295
date	2016.04.14.11.51.26;	author tg;	state Exp;
branches;
next	1.294;
commitid	100570F84162AA350D1;

1.294
date	2016.03.04.14.26.12;	author tg;	state Exp;
branches;
next	1.293;
commitid	10056D99B037D4D691D;

1.293
date	2016.01.21.18.24.37;	author tg;	state Exp;
branches;
next	1.292;
commitid	10056A12268001BF859;

1.292
date	2015.10.09.16.11.13;	author tg;	state Exp;
branches;
next	1.291;
commitid	1005617E72E4A2BA371;

1.291
date	2015.09.05.19.19.01;	author tg;	state Exp;
branches;
next	1.290;
commitid	10055EB402C54C3076B;

1.290
date	2015.07.10.19.36.34;	author tg;	state Exp;
branches;
next	1.289;
commitid	10055A01EBD784EE31A;

1.289
date	2015.07.10.18.41.05;	author tg;	state Exp;
branches;
next	1.288;
commitid	10055A0115F077A1AC9;

1.288
date	2015.07.10.17.31.09;	author tg;	state Exp;
branches;
next	1.287;
commitid	10055A00153609DFB88;

1.287
date	2015.07.05.19.37.13;	author tg;	state Exp;
branches;
next	1.286;
commitid	1005599876B5247136B;

1.286
date	2015.05.03.11.28.53;	author tg;	state Exp;
branches;
next	1.285;
commitid	1005546067C3837FCC3;

1.285
date	2015.04.29.20.07.31;	author tg;	state Exp;
branches;
next	1.284;
commitid	100554139453DB97755;

1.284
date	2015.04.11.22.09.48;	author tg;	state Exp;
branches;
next	1.283;
commitid	10055299BC3547AB433;

1.283
date	2015.03.14.05.17.16;	author tg;	state Exp;
branches;
next	1.282;
commitid	1005503C4736496672D;

1.282
date	2015.02.16.15.10.15;	author tg;	state Exp;
branches;
next	1.281;
commitid	10054E2086B7055A0F5;

1.281
date	2014.11.25.22.38.53;	author tg;	state Exp;
branches;
next	1.280;
commitid	1005475050A0290A058;

1.280
date	2014.11.25.21.13.22;	author tg;	state Exp;
branches;
next	1.279;
commitid	1005474F00E09321C83;

1.279
date	2014.11.19.21.52.16;	author tg;	state Exp;
branches;
next	1.278;
commitid	100546D11296C9A2EB6;

1.278
date	2014.11.19.21.49.10;	author tg;	state Exp;
branches;
next	1.277;
commitid	100546D105E468BE66D;

1.277
date	2014.11.14.20.00.40;	author tg;	state Exp;
branches;
next	1.276;
commitid	10054665F6C45FC6BEA;

1.276
date	2014.07.13.11.34.28;	author tg;	state Exp;
branches
	1.276.2.1;
next	1.275;
commitid	10053C26EB832BD6A2E;

1.275
date	2014.01.05.21.57.24;	author tg;	state Exp;
branches;
next	1.274;
commitid	10052C9D445413B34DF;

1.274
date	2014.01.05.19.11.43;	author tg;	state Exp;
branches;
next	1.273;
commitid	10052C9AE727A4482D3;

1.273
date	2013.11.30.17.33.48;	author tg;	state Exp;
branches;
next	1.272;
commitid	100529A2193602D314C;

1.272
date	2013.09.24.20.19.42;	author tg;	state Exp;
branches;
next	1.271;
commitid	1005241F37044BDFFC4;

1.271
date	2013.08.16.10.59.01;	author tg;	state Exp;
branches;
next	1.270;
commitid	100520E05EA33BA2E83;

1.270
date	2013.08.14.20.26.17;	author tg;	state Exp;
branches;
next	1.269;
commitid	100520BE7CE316FF2FE;

1.269
date	2013.08.10.13.44.29;	author tg;	state Exp;
branches;
next	1.268;
commitid	100520643B4127D9BCA;

1.268
date	2013.07.26.20.33.37;	author tg;	state Exp;
branches;
next	1.267;
commitid	10051F2DD36363A1B44;

1.267
date	2013.06.03.22.27.42;	author tg;	state Exp;
branches;
next	1.266;
commitid	10051AD18743D71583B;

1.266
date	2013.05.02.15.33.28;	author tg;	state Exp;
branches;
next	1.265;
commitid	1005182874A0CAD1AA6;

1.265
date	2013.02.10.19.05.36;	author tg;	state Exp;
branches;
next	1.264;
commitid	1005117EF9844D7B579;

1.264
date	2013.02.10.17.41.03;	author tg;	state Exp;
branches;
next	1.263;
commitid	1005117DBC709D0BEB4;

1.263
date	2013.02.10.17.39.36;	author tg;	state Exp;
branches;
next	1.262;
commitid	1005117DB705AA69563;

1.262
date	2013.02.10.17.38.13;	author tg;	state Exp;
branches;
next	1.261;
commitid	1005117DB0F3E1A98CE;

1.261
date	2013.02.10.17.18.47;	author tg;	state Exp;
branches;
next	1.260;
commitid	1005117D6794EBEDD21;

1.260
date	2012.12.28.02.28.33;	author tg;	state Exp;
branches;
next	1.259;
commitid	10050DD03E43C678B81;

1.259
date	2012.12.08.18.30.27;	author tg;	state Exp;
branches;
next	1.258;
commitid	10050C3875A3CBDA8F8;

1.258
date	2012.12.04.01.18.26;	author tg;	state Exp;
branches;
next	1.257;
commitid	10050BD4F7642624FD1;

1.257
date	2012.12.01.01.36.19;	author tg;	state Exp;
branches;
next	1.256;
commitid	10050B95F03690E9DEE;

1.256
date	2012.11.26.22.39.14;	author tg;	state Exp;
branches
	1.256.2.1;
next	1.255;
commitid	10050B3EF27625FBE7F;

1.255
date	2012.10.21.18.33.46;	author tg;	state Exp;
branches;
next	1.254;
commitid	10050843FC3294E3ACD;

1.254
date	2012.10.03.17.24.17;	author tg;	state Exp;
branches;
next	1.253;
commitid	100506C74D35719B33B;

1.253
date	2012.10.03.15.50.29;	author tg;	state Exp;
branches;
next	1.252;
commitid	100506C5EDD0A412A8E;

1.252
date	2012.09.21.17.20.20;	author tg;	state Exp;
branches;
next	1.251;
commitid	100505CA1BB6B435496;

1.251
date	2012.08.24.21.33.49;	author tg;	state Exp;
branches;
next	1.250;
commitid	1005037F34F0A0722F6;

1.250
date	2012.08.24.21.15.40;	author tg;	state Exp;
branches;
next	1.249;
commitid	1005037EEEC1CEDE454;

1.249
date	2012.08.24.20.57.44;	author tg;	state Exp;
branches;
next	1.248;
commitid	1005037EABE57131431;

1.248
date	2012.08.24.20.05.11;	author tg;	state Exp;
branches;
next	1.247;
commitid	1005037DE8E56F5392F;

1.247
date	2012.08.24.19.14.56;	author tg;	state Exp;
branches;
next	1.246;
commitid	1005037D2C82E041A1D;

1.246
date	2012.08.24.19.02.55;	author tg;	state Exp;
branches;
next	1.245;
commitid	1005037CFF74447266D;

1.245
date	2012.07.20.22.47.22;	author tg;	state Exp;
branches;
next	1.244;
commitid	1005009E00B54AE0DFB;

1.244
date	2012.07.20.20.50.07;	author tg;	state Exp;
branches;
next	1.243;
commitid	1005009C4975F510990;

1.243
date	2012.07.20.20.33.15;	author tg;	state Exp;
branches;
next	1.242;
commitid	1005009C0A314ABBC76;

1.242
date	2012.07.20.20.16.26;	author tg;	state Exp;
branches;
next	1.241;
commitid	1005009BCB2407373E7;

1.241
date	2012.07.20.18.39.53;	author tg;	state Exp;
branches;
next	1.240;
commitid	1005009A5F93EE46666;

1.240
date	2012.07.20.18.08.23;	author tg;	state Exp;
branches;
next	1.239;
commitid	10050099EAF36E415A3;

1.239
date	2012.07.01.15.54.53;	author tg;	state Exp;
branches;
next	1.238;
commitid	1004FF072DE3F1A3116;

1.238
date	2012.07.01.15.36.18;	author tg;	state Exp;
branches;
next	1.237;
commitid	1004FF06E8436CA88D9;

1.237
date	2012.05.05.17.32.31;	author tg;	state Exp;
branches
	1.237.2.1
	1.237.4.1;
next	1.236;
commitid	1004FA5643909944950;

1.236
date	2012.05.04.22.18.23;	author tg;	state Exp;
branches;
next	1.235;
commitid	1004FA455C411397094;

1.235
date	2012.05.04.20.49.01;	author tg;	state Exp;
branches;
next	1.234;
commitid	1004FA4409A67B135DE;

1.234
date	2012.04.06.15.06.42;	author tg;	state Exp;
branches;
next	1.233;
commitid	1004F7F06967E8F146E;

1.233
date	2012.03.31.19.52.34;	author tg;	state Exp;
branches;
next	1.232;
commitid	1004F77609961E0BA3E;

1.232
date	2012.03.31.19.20.12;	author tg;	state Exp;
branches;
next	1.231;
commitid	1004F7758FB1D4C1D9E;

1.231
date	2012.03.31.17.29.04;	author tg;	state Exp;
branches;
next	1.230;
commitid	1004F773ED162EDE2F2;

1.230
date	2012.03.23.23.25.25;	author tg;	state Exp;
branches;
next	1.229;
commitid	1004F6D064C65BE58AA;

1.229
date	2012.03.23.21.34.47;	author tg;	state Exp;
branches;
next	1.228;
commitid	1004F6CEC010168A803;

1.228
date	2012.03.23.21.15.34;	author tg;	state Exp;
branches;
next	1.227;
commitid	1004F6CE7C228937F99;

1.227
date	2012.01.29.01.41.12;	author tg;	state Exp;
branches;
next	1.226;
commitid	1004F24A3CB1AC86618;

1.226
date	2011.12.29.23.36.10;	author tg;	state Exp;
branches;
next	1.225;
commitid	1004EFCF98104A6DE49;

1.225
date	2011.12.11.18.07.45;	author tg;	state Exp;
branches;
next	1.224;
commitid	1004EE4F1875E2A0087;

1.224
date	2011.12.11.18.01.03;	author tg;	state Exp;
branches;
next	1.223;
commitid	1004EE4EFD3632036E6;

1.223
date	2011.12.04.23.22.59;	author tg;	state Exp;
branches;
next	1.222;
commitid	1004EDC00DF4797F1D4;

1.222
date	2011.10.07.19.45.08;	author tg;	state Exp;
branches;
next	1.221;
commitid	1004E8F56756104F061;

1.221
date	2011.09.07.15.24.12;	author tg;	state Exp;
branches;
next	1.220;
commitid	1004E678C6929FE60A6;

1.220
date	2011.08.27.18.06.41;	author tg;	state Exp;
branches;
next	1.219;
commitid	1004E5932432420AA61;

1.219
date	2011.07.16.18.15.45;	author tg;	state Exp;
branches;
next	1.218;
commitid	1004E21D5427084E93D;

1.218
date	2011.07.02.17.57.12;	author tg;	state Exp;
branches;
next	1.217;
commitid	1004E0F5C1030A0F765;

1.217
date	2011.06.30.14.09.04;	author tg;	state Exp;
branches;
next	1.216;
commitid	1004E0C83976DB09A91;

1.216
date	2011.06.30.13.48.12;	author tg;	state Exp;
branches;
next	1.215;
commitid	1004E0C7EAF5586D53A;

1.215
date	2011.06.04.16.44.30;	author tg;	state Exp;
branches;
next	1.214;
commitid	1004DEA610663BC4709;

1.214
date	2011.06.04.15.11.29;	author tg;	state Exp;
branches;
next	1.213;
commitid	1004DEA4B112114B15B;

1.213
date	2011.06.04.15.06.50;	author tg;	state Exp;
branches;
next	1.212;
commitid	1004DEA4A1D49DB8077;

1.212
date	2011.05.29.02.18.49;	author tg;	state Exp;
branches;
next	1.211;
commitid	1004DE1AD11046BEFFC;

1.211
date	2011.04.22.12.16.38;	author tg;	state Exp;
branches;
next	1.210;
commitid	1004DB171BD34BF5ED4;

1.210
date	2011.04.22.12.15.38;	author tg;	state Exp;
branches;
next	1.209;
commitid	1004DB17167553347A9;

1.209
date	2011.04.22.12.10.13;	author tg;	state Exp;
branches;
next	1.208;
commitid	1004DB1700F054E7B7E;

1.208
date	2011.04.09.21.01.00;	author tg;	state Exp;
branches;
next	1.207;
commitid	1004DA0C9186AA3EA10;

1.207
date	2011.03.16.20.31.32;	author tg;	state Exp;
branches;
next	1.206;
commitid	1004D811E0B6B302451;

1.206
date	2011.03.13.01.20.16;	author tg;	state Exp;
branches;
next	1.205;
commitid	1004D7C1BE368F5B459;

1.205
date	2011.03.07.20.30.35;	author tg;	state Exp;
branches;
next	1.204;
commitid	1004D75404D6F4BA14C;

1.204
date	2011.02.09.13.08.16;	author tg;	state Exp;
branches;
next	1.203;
commitid	1004D5291D85379A94E;

1.203
date	2011.02.03.15.57.50;	author tg;	state Exp;
branches;
next	1.202;
commitid	1004D4ACE420C09213B;

1.202
date	2011.01.21.22.43.17;	author tg;	state Exp;
branches;
next	1.201;
commitid	1004D3A0C080F86EFFD;

1.201
date	2010.09.14.21.26.09;	author tg;	state Exp;
branches;
next	1.200;
commitid	1004C8FE654576B0E25;

1.200
date	2010.09.05.19.51.31;	author tg;	state Exp;
branches;
next	1.199;
commitid	1004C83F4BE00D43672;

1.199
date	2010.08.28.20.22.15;	author tg;	state Exp;
branches;
next	1.198;
commitid	1004C796FE40C544CCE;

1.198
date	2010.08.28.18.50.47;	author tg;	state Exp;
branches;
next	1.197;
commitid	1004C795A82072326AF;

1.197
date	2010.08.28.16.47.08;	author tg;	state Exp;
branches;
next	1.196;
commitid	1004C793DA0390DF065;

1.196
date	2010.07.25.11.35.40;	author tg;	state Exp;
branches;
next	1.195;
commitid	1004C4C211F2951575A;

1.195
date	2010.07.17.22.09.32;	author tg;	state Exp;
branches;
next	1.194;
commitid	1004C42295452E71B6E;

1.194
date	2010.07.04.18.52.52;	author tg;	state Exp;
branches;
next	1.193;
commitid	1004C30D893665D84BB;

1.193
date	2010.07.04.17.45.12;	author tg;	state Exp;
branches;
next	1.192;
commitid	1004C30C8946816B0C1;

1.192
date	2010.05.22.12.37.49;	author tg;	state Exp;
branches;
next	1.191;
commitid	1004BF7CFC4552BC210;

1.191
date	2010.03.27.15.26.19;	author tg;	state Exp;
branches;
next	1.190;
commitid	1004BAE235C7BFB986D;

1.190
date	2010.02.23.18.13.02;	author tg;	state Exp;
branches;
next	1.189;
commitid	1004B841A9A1A72C896;

1.189
date	2010.01.29.09.34.26;	author tg;	state Exp;
branches;
next	1.188;
commitid	1004B62ABB7333ED94C;

1.188
date	2010.01.08.22.21.04;	author tg;	state Exp;
branches;
next	1.187;
commitid	1004B47AF75223D4923;

1.187
date	2009.12.12.22.27.05;	author tg;	state Exp;
branches;
next	1.186;
commitid	1004B2418AF282F4231;

1.186
date	2009.12.05.22.19.41;	author tg;	state Exp;
branches;
next	1.185;
commitid	1004B1ADC9423FC09DA;

1.185
date	2009.12.05.17.43.44;	author tg;	state Exp;
branches;
next	1.184;
commitid	1004B1A9BCF3E49BC5B;

1.184
date	2009.10.30.00.57.36;	author tg;	state Exp;
branches;
next	1.183;
commitid	1004AEA39BD3F10ECFA;

1.183
date	2009.09.26.04.01.31;	author tg;	state Exp;
branches;
next	1.182;
commitid	1004ABD92036DD32E15;

1.182
date	2009.09.24.17.15.30;	author tg;	state Exp;
branches;
next	1.181;
commitid	1004ABBA8D95908292B;

1.181
date	2009.09.23.18.04.54;	author tg;	state Exp;
branches;
next	1.180;
commitid	1004ABA62C8171BD8E4;

1.180
date	2009.09.20.17.23.50;	author tg;	state Exp;
branches;
next	1.179;
commitid	1004AB6650915B0514A;

1.179
date	2009.09.20.17.18.53;	author tg;	state Exp;
branches;
next	1.178;
commitid	1004AB6640D758BC4BB;

1.178
date	2009.09.20.17.00.52;	author tg;	state Exp;
branches;
next	1.177;
commitid	1004AB65FBD7253202C;

1.177
date	2009.09.20.15.38.05;	author tg;	state Exp;
branches;
next	1.176;
commitid	1004AB64C5E29E3250E;

1.176
date	2009.09.19.21.54.43;	author tg;	state Exp;
branches;
next	1.175;
commitid	1004AB552F7546C611E;

1.175
date	2009.08.28.20.30.54;	author tg;	state Exp;
branches;
next	1.174;
commitid	1004A983E6B745731A0;

1.174
date	2009.08.28.19.57.39;	author tg;	state Exp;
branches;
next	1.173;
commitid	1004A98365B7809CDA1;

1.173
date	2009.08.01.20.32.43;	author tg;	state Exp;
branches;
next	1.172;
commitid	1004A74A6770161F3E7;

1.172
date	2009.07.05.13.56.47;	author tg;	state Exp;
branches;
next	1.171;
commitid	1004A50B0E3697D221C;

1.171
date	2009.06.11.12.42.16;	author tg;	state Exp;
branches;
next	1.170;
commitid	1004A30FBB114E3FED9;

1.170
date	2009.06.10.19.34.18;	author tg;	state Exp;
branches;
next	1.169;
commitid	1004A300ACB2EE7878D;

1.169
date	2009.06.10.19.33.16;	author tg;	state Exp;
branches;
next	1.168;
commitid	1004A300A72701188E3;

1.168
date	2009.06.10.18.12.44;	author tg;	state Exp;
branches;
next	1.167;
commitid	1004A2FF7913BD44883;

1.167
date	2009.06.08.20.22.19;	author tg;	state Exp;
branches;
next	1.166;
commitid	1004A2D72DD5A4E4B4F;

1.166
date	2009.06.08.20.16.01;	author tg;	state Exp;
branches;
next	1.165;
commitid	1004A2D718400919648;

1.165
date	2009.06.08.20.06.44;	author tg;	state Exp;
branches;
next	1.164;
commitid	1004A2D6F3A31FB4CBC;

1.164
date	2009.05.16.16.59.33;	author tg;	state Exp;
branches;
next	1.163;
commitid	1004A0EF0664EF4168D;

1.163
date	2009.05.16.15.09.06;	author tg;	state Exp;
branches;
next	1.162;
commitid	1004A0ED7131FB6A76E;

1.162
date	2009.05.16.14.34.57;	author tg;	state Exp;
branches;
next	1.161;
commitid	1004A0ED19A31E8465B;

1.161
date	2009.05.16.14.19.21;	author tg;	state Exp;
branches;
next	1.160;
commitid	1004A0ECB577CA34B34;

1.160
date	2009.04.07.18.41.33;	author tg;	state Exp;
branches;
next	1.159;
commitid	10049DB9E493037411A;

1.159
date	2009.04.05.12.35.21;	author tg;	state Exp;
branches;
next	1.158;
commitid	10049D8A5A16984F99D;

1.158
date	2009.04.05.12.28.55;	author tg;	state Exp;
branches;
next	1.157;
commitid	10049D8A41E43689C5A;

1.157
date	2009.04.05.11.18.34;	author tg;	state Exp;
branches;
next	1.156;
commitid	10049D8938D01A15AB7;

1.156
date	2009.03.17.13.56.47;	author tg;	state Exp;
branches;
next	1.155;
commitid	10049BFAC131C8B19AE;

1.155
date	2009.03.15.18.48.43;	author tg;	state Exp;
branches;
next	1.154;
commitid	10049BD4D5A551AD7DB;

1.154
date	2009.03.15.18.30.39;	author tg;	state Exp;
branches;
next	1.153;
commitid	10049BD4955503E4A16;

1.153
date	2009.03.15.16.13.38;	author tg;	state Exp;
branches;
next	1.152;
commitid	10049BD293E126777AC;

1.152
date	2009.02.22.19.02.27;	author tg;	state Exp;
branches;
next	1.151;
commitid	10049A1A15A7F34A73B;

1.151
date	2009.02.22.18.57.19;	author tg;	state Exp;
branches;
next	1.150;
commitid	10049A19F8A3F7C174E;

1.150
date	2009.02.20.13.19.04;	author tg;	state Exp;
branches;
next	1.149;
commitid	100499EADD23B53A681;

1.149
date	2008.12.29.21.05.13;	author tg;	state Exp;
branches;
next	1.148;
commitid	10049593B8A55E8419D;

1.148
date	2008.12.13.17.02.12;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004943EAA830C0300B;

1.147
date	2008.12.04.18.11.04;	author tg;	state Exp;
branches;
next	1.146;
commitid	10049381D2D4EEC022C;

1.146
date	2008.11.15.09.00.18;	author tg;	state Exp;
branches
	1.146.2.1;
next	1.145;
commitid	100491E8FA25D360D54;

1.145
date	2008.11.15.07.35.23;	author tg;	state Exp;
branches;
next	1.144;
commitid	100491E7BBB79B0FECE;

1.144
date	2008.11.12.00.54.46;	author tg;	state Exp;
branches;
next	1.143;
commitid	100491A295841A6D8EB;

1.143
date	2008.11.12.00.27.54;	author tg;	state Exp;
branches;
next	1.142;
commitid	100491A230649FC77C0;

1.142
date	2008.11.11.23.50.28;	author tg;	state Exp;
branches;
next	1.141;
commitid	100491A1A3D7C6B56F1;

1.141
date	2008.10.28.14.32.38;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004907226D3DEFCCD1;

1.140
date	2008.10.26.20.59.39;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004904DA0662727312;

1.139
date	2008.10.19.20.15.43;	author tg;	state Exp;
branches;
next	1.138;
commitid	10048FB954E53F4A93C;

1.138
date	2008.10.13.23.06.02;	author tg;	state Exp;
branches;
next	1.137;
commitid	10048F3D44866CCA1C2;

1.137
date	2008.10.05.16.06.43;	author tg;	state Exp;
branches;
next	1.136;
commitid	10048E8E61D7FB7DA17;

1.136
date	2008.10.04.23.08.03;	author tg;	state Exp;
branches;
next	1.135;
commitid	10048E7F7686DB8B02F;

1.135
date	2008.09.30.19.28.12;	author tg;	state Exp;
branches;
next	1.134;
commitid	10048E27DDF2268C631;

1.134
date	2008.09.30.19.25.49;	author tg;	state Exp;
branches;
next	1.133;
commitid	10048E27D493BFBB014;

1.133
date	2008.09.30.17.49.24;	author tg;	state Exp;
branches;
next	1.132;
commitid	10048E266AB7BDA06AF;

1.132
date	2008.09.30.17.23.00;	author tg;	state Exp;
branches;
next	1.131;
commitid	10048E2607C7FE34924;

1.131
date	2008.09.20.15.59.23;	author tg;	state Exp;
branches;
next	1.130;
commitid	10048D51CD81469D5BA;

1.130
date	2008.09.20.14.10.23;	author tg;	state Exp;
branches;
next	1.129;
commitid	10048D503AC0F925008;

1.129
date	2008.09.20.12.29.31;	author tg;	state Exp;
branches;
next	1.128;
commitid	10048D4EC627B8EA2FB;

1.128
date	2008.09.14.20.24.58;	author tg;	state Exp;
branches;
next	1.127;
commitid	10048CD722B0B2BCCBE;

1.127
date	2008.05.17.18.46.57;	author tg;	state Exp;
branches;
next	1.126;
commitid	100482F280E7B53AA4C;

1.126
date	2008.05.02.18.55.35;	author tg;	state Exp;
branches;
next	1.125;
commitid	100481B63B51233676D;

1.125
date	2008.04.20.02.01.42;	author tg;	state Exp;
branches;
next	1.124;
commitid	100480AA4182E81A4BA;

1.124
date	2008.04.20.00.03.50;	author tg;	state Exp;
branches;
next	1.123;
commitid	100480A88364EB31FEB;

1.123
date	2008.04.19.22.50.01;	author tg;	state Exp;
branches;
next	1.122;
commitid	100480A771A701FFA0E;

1.122
date	2008.04.19.22.15.01;	author tg;	state Exp;
branches;
next	1.121;
commitid	100480A6CC85EC0197B;

1.121
date	2008.04.19.17.25.49;	author tg;	state Exp;
branches;
next	1.120;
commitid	100480A2B2745DC9545;

1.120
date	2008.04.19.17.21.52;	author tg;	state Exp;
branches;
next	1.119;
commitid	100480A2A2B32040FD7;

1.119
date	2008.04.01.21.50.57;	author tg;	state Exp;
branches;
next	1.118;
commitid	10047F2AE2966CBAC7A;

1.118
date	2008.03.23.21.31.29;	author tg;	state Exp;
branches;
next	1.117;
commitid	10047E6CC400321FE85;

1.117
date	2007.10.25.15.23.08;	author tg;	state Exp;
branches
	1.117.2.1;
next	1.116;
commitid	1004720B4ED147A8549;

1.116
date	2007.10.25.15.19.15;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004720B40258F7886E;

1.115
date	2007.10.14.13.43.41;	author tg;	state Exp;
branches;
next	1.114;
commitid	10047121D1A56A79186;

1.114
date	2007.10.09.14.50.50;	author tg;	state Exp;
branches;
next	1.113;
commitid	100470B94ED68BBDDDB;

1.113
date	2007.09.09.20.03.32;	author tg;	state Exp;
branches;
next	1.112;
commitid	10046E4518D703CC0A9;

1.112
date	2007.09.09.18.06.39;	author tg;	state Exp;
branches;
next	1.111;
commitid	10046E436442CDF8871;

1.111
date	2007.08.18.01.20.27;	author tg;	state Exp;
branches;
next	1.110;
commitid	10046C64959337B7951;

1.110
date	2007.07.31.15.42.50;	author tg;	state Exp;
branches;
next	1.109;
commitid	10046AF58744B319A05;

1.109
date	2007.07.31.15.29.39;	author tg;	state Exp;
branches;
next	1.108;
commitid	10046AF54DA06B43D9B;

1.108
date	2007.07.31.10.42.14;	author tg;	state Exp;
branches;
next	1.107;
commitid	10046AF121C3F451EF4;

1.107
date	2007.07.22.13.38.25;	author tg;	state Exp;
branches;
next	1.106;
commitid	10046A35DE715FF102D;

1.106
date	2007.07.22.13.34.48;	author tg;	state Exp;
branches;
next	1.105;
commitid	10046A35CEC35BB7B5F;

1.105
date	2007.07.01.21.10.27;	author tg;	state Exp;
branches;
next	1.104;
commitid	100468818584C6286F7;

1.104
date	2007.06.21.16.04.46;	author tg;	state Exp;
branches;
next	1.103;
commitid	100467AA19E39838981;

1.103
date	2007.06.15.22.00.00;	author tg;	state Exp;
branches;
next	1.102;
commitid	10046730BC105D2123A;

1.102
date	2007.06.09.22.01.41;	author tg;	state Exp;
branches;
next	1.101;
commitid	100466B23524CFD40D0;

1.101
date	2007.06.06.23.28.13;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004667430836D68E66;

1.100
date	2007.06.06.22.26.26;	author tg;	state Exp;
branches;
next	1.99;
commitid	10046673448498E9DE8;

1.99
date	2007.06.05.19.48.46;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004665BE264E72FCFA;

1.98
date	2007.05.24.19.15.46;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004655E45C547B7BE6;

1.97
date	2007.05.22.21.13.56;	author tg;	state Exp;
branches;
next	1.96;
commitid	10046535D2A0A26D444;

1.96
date	2007.05.22.21.01.38;	author tg;	state Exp;
branches;
next	1.95;
commitid	1004653599C2802E8ED;

1.95
date	2007.05.22.19.27.05;	author tg;	state Exp;
branches;
next	1.94;
commitid	100465343E957B0D904;

1.94
date	2007.05.21.19.25.31;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004651F21443013C37;

1.93
date	2007.05.21.12.24.44;	author tg;	state Exp;
branches;
next	1.92;
commitid	10046518F767D6ADCA3;

1.92
date	2007.05.20.17.53.13;	author tg;	state Exp;
branches;
next	1.91;
commitid	10046508B0376038FC6;

1.91
date	2007.05.13.17.51.20;	author tg;	state Exp;
branches;
next	1.90;
commitid	10046474FB1292DF336;

1.90
date	2007.05.10.19.08.48;	author tg;	state Exp;
branches;
next	1.89;
commitid	10046436DC35AC3B04F;

1.89
date	2007.05.10.18.58.31;	author tg;	state Exp;
branches;
next	1.88;
commitid	10046436B6D392D622C;

1.88
date	2007.05.10.18.46.38;	author tg;	state Exp;
branches;
next	1.87;
commitid	100464368A065F40C08;

1.87
date	2007.03.10.18.16.26;	author tg;	state Exp;
branches
	1.87.2.1;
next	1.86;
commitid	10045F2F60A6B49F58A;

1.86
date	2007.03.10.00.36.44;	author tg;	state Exp;
branches;
next	1.85;
commitid	10045F1FD4C67EEB74F;

1.85
date	2007.03.10.00.23.31;	author tg;	state Exp;
branches;
next	1.84;
commitid	10045F1F98502489EEA;

1.84
date	2007.03.04.03.04.24;	author tg;	state Exp;
branches;
next	1.83;
commitid	10045EA374B3374AB35;

1.83
date	2007.03.04.00.13.14;	author tg;	state Exp;
branches;
next	1.82;
commitid	10045EA0F2F6674C8B9;

1.82
date	2007.02.16.17.46.42;	author tg;	state Exp;
branches;
next	1.81;
commitid	10045D5EDDE0036A745;

1.81
date	2007.02.07.02.01.43;	author tg;	state Exp;
branches;
next	1.80;
commitid	10045C9330B7A51D499;

1.80
date	2007.01.15.02.14.02;	author tg;	state Exp;
branches;
next	1.79;
commitid	10045AAE38155273115;

1.79
date	2007.01.15.02.11.34;	author tg;	state Exp;
branches;
next	1.78;
commitid	10045AAE2686CC65EF0;

1.78
date	2007.01.14.01.56.23;	author tg;	state Exp;
branches
	1.78.2.1;
next	1.77;
commitid	10045A98D530BE57204;

1.77
date	2007.01.14.01.09.08;	author tg;	state Exp;
branches;
next	1.76;
commitid	10045A982725C7995A4;

1.76
date	2007.01.12.10.18.20;	author tg;	state Exp;
branches;
next	1.75;
commitid	10045A76059104E0EFB;

1.75
date	2007.01.12.01.49.27;	author tg;	state Exp;
branches;
next	1.74;
commitid	10045A6E8B92FCAC95A;

1.74
date	2006.11.19.20.43.12;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004560C1B06C73EF4A;

1.73
date	2006.11.12.14.58.13;	author tg;	state Exp;
branches;
next	1.72;
commitid	100455735A7145E26AA;

1.72
date	2006.11.10.07.52.01;	author tg;	state Exp;
branches;
next	1.71;
commitid	10045542F8269E05F56;

1.71
date	2006.11.10.07.18.56;	author tg;	state Exp;
branches;
next	1.70;
commitid	100455427B90A1F6E32;

1.70
date	2006.11.10.06.53.25;	author tg;	state Exp;
branches;
next	1.69;
commitid	100455421CB6900D8A1;

1.69
date	2006.11.10.06.45.27;	author tg;	state Exp;
branches;
next	1.68;
commitid	10045541FC2382F56E4;

1.68
date	2006.11.10.06.40.04;	author tg;	state Exp;
branches;
next	1.67;
commitid	10045541ED1100460E3;

1.67
date	2006.11.10.04.31.04;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004554007326926DB5;

1.66
date	2006.11.10.03.23.48;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004553F0C348A7A034;

1.65
date	2006.11.10.01.24.38;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004553D4EB7018F89F;

1.64
date	2006.11.10.01.13.50;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004553D1A316532A65;

1.63
date	2006.11.09.22.38.31;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004553ADFD6CE5255F;

1.62
date	2006.11.09.21.20.49;	author tg;	state Exp;
branches;
next	1.61;
commitid	10045539BBD70E1ADCD;

1.61
date	2006.11.09.15.02.30;	author tg;	state Exp;
branches;
next	1.60;
commitid	100455343104AF09372;

1.60
date	2006.11.09.00.39.27;	author tg;	state Exp;
branches;
next	1.59;
commitid	100455278AE1639F129;

1.59
date	2006.11.09.00.28.36;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004552761C5A49C605;

1.58
date	2006.11.09.00.01.36;	author tg;	state Exp;
branches;
next	1.57;
commitid	10045526FEF617BC67F;

1.57
date	2006.11.06.19.57.19;	author tg;	state Exp;
branches;
next	1.56;
commitid	100454F939852CF1992;

1.56
date	2006.11.05.21.11.17;	author tg;	state Exp;
branches;
next	1.55;
commitid	100454E538B5C49608F;

1.55
date	2006.11.05.21.00.08;	author tg;	state Exp;
branches;
next	1.54;
commitid	100454E50DF33E0AFEF;

1.54
date	2006.11.05.19.56.20;	author tg;	state Exp;
branches;
next	1.53;
commitid	100454E41F7086293E3;

1.53
date	2006.11.05.19.48.58;	author tg;	state Exp;
branches;
next	1.52;
commitid	100454E40346A99E7DE;

1.52
date	2006.11.05.19.35.52;	author tg;	state Exp;
branches;
next	1.51;
commitid	100454E3CFB65543F78;

1.51
date	2006.11.05.19.15.15;	author tg;	state Exp;
branches;
next	1.50;
commitid	100454E384D2F19E2E3;

1.50
date	2006.11.05.19.12.41;	author tg;	state Exp;
branches;
next	1.49;
commitid	100454E37B93C3AC732;

1.49
date	2006.11.05.17.54.46;	author tg;	state Exp;
branches;
next	1.48;
commitid	100454E25743A716635;

1.48
date	2006.11.05.17.34.39;	author tg;	state Exp;
branches;
next	1.47;
commitid	100454E20C17FE60A60;

1.47
date	2006.11.05.17.24.00;	author tg;	state Exp;
branches;
next	1.46;
commitid	100454E1E3C62C0D8ED;

1.46
date	2006.11.05.17.11.25;	author tg;	state Exp;
branches;
next	1.45;
commitid	100454E1B5330190521;

1.45
date	2006.11.05.16.53.34;	author tg;	state Exp;
branches;
next	1.44;
commitid	100454E17212C6A25C4;

1.44
date	2006.11.05.16.48.17;	author tg;	state Exp;
branches;
next	1.43;
commitid	100454E15DE6BD31111;

1.43
date	2006.11.05.16.43.57;	author tg;	state Exp;
branches;
next	1.42;
commitid	100454E14DC25BA7EE4;

1.42
date	2006.11.05.16.41.02;	author tg;	state Exp;
branches;
next	1.41;
commitid	100454E14196EEFF5E7;

1.41
date	2006.11.05.16.10.10;	author tg;	state Exp;
branches;
next	1.40;
commitid	100454E0CF30D9BBFF0;

1.40
date	2006.11.05.15.36.09;	author tg;	state Exp;
branches;
next	1.39;
commitid	100454E04F732C19E6A;

1.39
date	2006.11.05.15.31.36;	author tg;	state Exp;
branches;
next	1.38;
commitid	100454E03E319796BE0;

1.38
date	2006.08.24.20.32.52;	author tg;	state Exp;
branches;
next	1.37;
commitid	10044EE0CE2267A59CF;

1.37
date	2006.08.22.22.49.34;	author tg;	state Exp;
branches;
next	1.36;
commitid	10044EB89CB27D175DB;

1.36
date	2006.08.08.20.17.20;	author tg;	state Exp;
branches
	1.36.2.1;
next	1.35;
commitid	10044D8F142232C4BC7;

1.35
date	2006.08.08.20.07.52;	author tg;	state Exp;
branches;
next	1.34;
commitid	10044D8EEEE696BEC43;

1.34
date	2006.08.02.14.02.54;	author tg;	state Exp;
branches;
next	1.33;
commitid	10044D0B08F6BDAF5CF;

1.33
date	2006.08.02.14.00.18;	author tg;	state Exp;
branches;
next	1.32;
commitid	10044D0AFEA217B8066;

1.32
date	2006.08.02.13.32.17;	author tg;	state Exp;
branches;
next	1.31;
commitid	10044D0A93A6E3C2419;

1.31
date	2006.08.02.12.54.48;	author tg;	state Exp;
branches;
next	1.30;
commitid	10044D0A0AB54F5C5BD;

1.30
date	2006.08.02.12.49.04;	author tg;	state Exp;
branches;
next	1.29;
commitid	10044D09F47646B7C76;

1.29
date	2006.08.02.11.33.36;	author tg;	state Exp;
branches;
next	1.28;
commitid	10044D08D5007719200;

1.28
date	2006.08.01.14.59.50;	author tg;	state Exp;
branches;
next	1.27;
commitid	10044CF6C3D59DAED92;

1.27
date	2006.08.01.14.35.43;	author tg;	state Exp;
branches;
next	1.26;
commitid	10044CF66C856AB831E;

1.26
date	2006.08.01.14.10.24;	author tg;	state Exp;
branches;
next	1.25;
commitid	10044CF60E04E385000;

1.25
date	2006.08.01.14.09.18;	author tg;	state Exp;
branches;
next	1.24;
commitid	10044CF609314C13CBE;

1.24
date	2006.08.01.12.44.16;	author tg;	state Exp;
branches;
next	1.23;
commitid	10044CF4CA571D18180;

1.23
date	2006.07.11.14.51.01;	author tg;	state Exp;
branches;
next	1.22;
commitid	10044B3BAD83E16AC82;

1.22
date	2006.07.03.12.16.29;	author tg;	state Exp;
branches;
next	1.21;
commitid	10044A90AAA1B255EDF;

1.21
date	2006.05.10.18.54.09;	author tg;	state Exp;
branches;
next	1.20;
commitid	100446236E6726083C8;

1.20
date	2006.02.16.11.48.31;	author tg;	state Exp;
branches;
next	1.19;
commitid	10043F4664F31176871;

1.19
date	2006.01.30.12.37.21;	author tg;	state Exp;
branches;
next	1.18;
commitid	10043DE088533ED5341;

1.18
date	2006.01.29.20.04.49;	author tg;	state Exp;
branches;
next	1.17;
commitid	10043DD1FE6328EF386;

1.17
date	2005.11.22.18.40.41;	author tg;	state Exp;
branches;
next	1.16;
commitid	108a438366254326;

1.16
date	2005.10.25.19.53.26;	author tg;	state Exp;
branches;
next	1.15;
commitid	76cc435e8d34d8ce;

1.15
date	2005.10.07.18.34.18;	author tg;	state Exp;
branches;
next	1.14;
commitid	bce4346bfb5558c;

1.14
date	2005.10.07.18.32.23;	author tg;	state Exp;
branches;
next	1.13;
commitid	e314346bf40979f;

1.13
date	2005.08.21.13.02.17;	author tg;	state Exp;
branches;
next	1.12;
commitid	521743087b5a03be;

1.12
date	2005.08.02.12.35.26;	author tg;	state Exp;
branches;
next	1.11;
commitid	6dd542ef687afd87;

1.11
date	2005.07.12.13.30.37;	author tg;	state Exp;
branches;
next	1.10;
commitid	9d042d3c6108a63;

1.10
date	2005.07.12.13.23.59;	author tg;	state Exp;
branches;
next	1.9;
commitid	599e42d3c46ea960;

1.9
date	2005.07.04.12.07.40;	author tg;	state Exp;
branches;
next	1.8;
commitid	638742c926619991;

1.8
date	2005.06.08.22.34.02;	author tg;	state Exp;
branches;
next	1.7;
commitid	775142a7726c13a2;

1.7
date	2005.06.08.22.22.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	40d642a76fac7c9d;

1.6
date	2005.06.08.21.51.20;	author tg;	state Exp;
branches;
next	1.5;
commitid	318442a76849872f;

1.5
date	2005.05.25.23.39.10;	author tg;	state Exp;
branches;
next	1.4;
commitid	2a5a42950cb0ceb1;

1.4
date	2005.05.25.23.31.05;	author tg;	state Exp;
branches;
next	1.3;
commitid	6fd242950a6e73e0;

1.3
date	2005.05.23.16.23.18;	author tg;	state Exp;
branches;
next	1.2;
commitid	1d3a429203880b55;

1.2
date	2005.05.23.15.18.15;	author tg;	state Exp;
branches;
next	1.1;
commitid	3dc04291f43ca526;

1.1
date	2005.05.23.03.06.06;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.276.2.1
date	2015.01.11.22.39.45;	author tg;	state Exp;
branches;
next	1.276.2.2;
commitid	10054B2FBC1440F88AD;

1.276.2.2
date	2015.01.25.15.35.41;	author tg;	state Exp;
branches;
next	1.276.2.3;
commitid	10054C50D442D861FBF;

1.276.2.3
date	2015.03.01.15.42.56;	author tg;	state Exp;
branches;
next	1.276.2.4;
commitid	10054F33364551D895A;

1.276.2.4
date	2015.03.20.22.20.58;	author tg;	state Exp;
branches;
next	1.276.2.5;
commitid	100550C9D521FCB4274;

1.276.2.5
date	2015.04.12.22.32.22;	author tg;	state Exp;
branches;
next	;
commitid	100552AF26A429AA816;

1.256.2.1
date	2012.12.04.01.26.19;	author tg;	state Exp;
branches;
next	1.256.2.2;
commitid	10050BD5149729CD584;

1.256.2.2
date	2013.02.10.17.11.17;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.237.2.1
date	2012.05.09.21.34.26;	author tg;	state Exp;
branches;
next	;
commitid	1004FAAE2A93A87CC34;

1.237.4.1
date	2012.07.20.22.51.40;	author tg;	state Exp;
branches;
next	1.237.4.2;
commitid	1005009E10A72E016E4;

1.237.4.2
date	2012.09.03.19.10.53;	author tg;	state Exp;
branches;
next	1.237.4.3;
commitid	100504500D439E09A42;

1.237.4.3
date	2013.02.10.16.53.15;	author tg;	state Exp;
branches;
next	;
commitid	1005117D049535979A9;

1.146.2.1
date	2008.11.22.13.20.25;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.117.2.1
date	2008.04.22.13.29.23;	author tg;	state Exp;
branches;
next	1.117.2.2;
commitid	100480DE80F32BAA72D;

1.117.2.2
date	2008.05.19.18.41.18;	author tg;	state Exp;
branches;
next	1.117.2.3;
commitid	1004831C9A63DA06745;

1.117.2.3
date	2008.12.14.00.07.36;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.87.2.1
date	2007.05.13.19.29.33;	author tg;	state Exp;
branches;
next	1.87.2.2;
commitid	1004647668D4636830B;

1.87.2.2
date	2007.05.22.21.34.29;	author tg;	state Exp;
branches;
next	1.87.2.3;
commitid	100465361F206BD615D;

1.87.2.3
date	2007.05.26.22.31.19;	author tg;	state Exp;
branches;
next	1.87.2.4;
commitid	1004658B53E3CC3259F;

1.87.2.4
date	2007.07.05.11.49.16;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.78.2.1
date	2007.03.03.21.37.52;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;

1.36.2.1
date	2006.08.24.18.28.19;	author tg;	state Exp;
branches;
next	1.36.2.2;
commitid	10044EDEFC1463EFAE9;

1.36.2.2
date	2006.08.24.18.38.51;	author tg;	state Exp;
branches;
next	1.36.2.3;
commitid	10044EDF2484C8A7C31;

1.36.2.3
date	2006.08.24.20.52.10;	author tg;	state Exp;
branches;
next	1.36.2.4;
commitid	10044EE117A130AF943;

1.36.2.4
date	2006.08.28.01.49.16;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.346
log
@further memory optimisation
@
text
@/*	$OpenBSD: edit.c,v 1.41 2015/09/01 13:12:31 tedu Exp $	*/
/*	$OpenBSD: edit.h,v 1.9 2011/05/30 17:14:35 martynas Exp $	*/
/*	$OpenBSD: emacs.c,v 1.52 2015/09/10 22:48:58 nicm Exp $	*/
/*	$OpenBSD: vi.c,v 1.30 2015/09/10 22:48:58 nicm Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

#ifndef MKSH_NO_CMDLINE_EDITING

__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.345 2019/12/11 17:36:12 tg Exp $");

/*
 * in later versions we might use libtermcap for this, but since external
 * dependencies are problematic, this has not yet been decided on; another
 * good string is KSH_ESC_STRING "c" except on hardware terminals like the
 * DEC VT420 which do a full power cycle then...
 */
#ifndef MKSH_CLS_STRING
#define MKSH_CLS_STRING		KSH_ESC_STRING "[;H" KSH_ESC_STRING "[J"
#endif

/* tty driver characters we are interested in */
#define EDCHAR_DISABLED	0xFFFFU
#define EDCHAR_INITIAL	0xFFFEU
static struct {
	unsigned short erase;
	unsigned short kill;
	unsigned short werase;
	unsigned short intr;
	unsigned short quit;
	unsigned short eof;
} edchars;

#define isched(x,e) ((unsigned short)(unsigned char)(x) == (e))
#define isedchar(x) (!((x) & ~0xFF))
#ifndef _POSIX_VDISABLE
#define toedchar(x) ((unsigned short)(unsigned char)(x))
#else
#define toedchar(x) (((_POSIX_VDISABLE != -1) && ((x) == _POSIX_VDISABLE)) ? \
			((unsigned short)EDCHAR_DISABLED) : \
			((unsigned short)(unsigned char)(x)))
#endif

/* x_cf_glob() flags */
#define XCF_COMMAND	BIT(0)	/* Do command completion */
#define XCF_FILE	BIT(1)	/* Do file completion */
#define XCF_FULLPATH	BIT(2)	/* command completion: store full path */
#define XCF_COMMAND_FILE (XCF_COMMAND | XCF_FILE)
#define XCF_IS_COMMAND	BIT(3)	/* return flag: is command */
#define XCF_IS_NOSPACE	BIT(4)	/* return flag: do not append a space */

static char editmode;
static int xx_cols;			/* for Emacs mode */
static int modified;			/* buffer has been "modified" */
static char *holdbufp;			/* place to hold last edit buffer */

/* 0=dumb 1=tmux (for now) */
static uint8_t x_term_mode;

static void x_adjust(void);
static int x_getc(void);
static void x_putcf(int);
static void x_modified(void);
static void x_mode(bool);
static int x_do_comment(char *, ssize_t, ssize_t *);
static void x_print_expansions(int, char * const *, bool);
static int x_cf_glob(int *, const char *, int, int, int *, int *, char ***);
static size_t x_longest_prefix(int, char * const *);
static void x_glob_hlp_add_qchar(char *);
static char *x_glob_hlp_tilde_and_rem_qchar(char *, bool);
static size_t x_basename(const char *, const char *);
static void x_free_words(int, char **);
static int x_escape(const char *, size_t, int (*)(const char *, size_t));
static int x_emacs(char *);
static void x_init_prompt(bool);
#if !MKSH_S_NOVI
static int x_vi(char *);
#endif
static void x_intr(int, int) MKSH_A_NORETURN;

#define x_flush()	shf_flush(shl_out)
#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
#define x_putc(c)	x_putcf(c)
#else
#define x_putc(c)	shf_putc((c), shl_out)
#endif

static int path_order_cmp(const void *, const void *);
static void glob_table(const char *, XPtrV *, struct table *);
static void glob_path(int, const char *, XPtrV *, const char *);
static int x_file_glob(int *, char *, char ***);
static int x_command_glob(int, char *, char ***);
static int x_locate_word(const char *, int, int, int *, bool *);

static int x_e_getmbc(char *);

/* +++ generic editing functions +++ */

/*
 * read an edited command line
 */
int
x_read(char *buf)
{
	int i;

	x_mode(true);
	modified = 1;
	if (Flag(FEMACS) || Flag(FGMACS))
		i = x_emacs(buf);
#if !MKSH_S_NOVI
	else if (Flag(FVI))
		i = x_vi(buf);
#endif
	else
		/* internal error */
		i = -1;
	editmode = 0;
	x_mode(false);
	return (i);
}

/* tty I/O */

static int
x_getc(void)
{
#ifdef __OS2__
	return (_read_kbd(0, 1, 0));
#else
	char c;
	ssize_t n;

	while ((n = blocking_read(STDIN_FILENO, &c, 1)) < 0 && errno == EINTR)
		if (trap) {
			x_mode(false);
			runtraps(0);
#ifdef SIGWINCH
			if (got_winch) {
				change_winsz();
				if (x_cols != xx_cols && editmode == 1) {
					/* redraw line in Emacs mode */
					xx_cols = x_cols;
					x_init_prompt(false);
					x_adjust();
				}
			}
#endif
			x_mode(true);
		}
	return ((n == 1) ? (int)(unsigned char)c : -1);
#endif
}

static void
x_putcf(int c)
{
	shf_putc_i(c, shl_out);
}

/*********************************
 * Misc common code for vi/emacs *
 *********************************/

/*-
 * Handle the commenting/uncommenting of a line.
 * Returns:
 *	1 if a carriage return is indicated (comment added)
 *	0 if no return (comment removed)
 *	-1 if there is an error (not enough room for comment chars)
 * If successful, *lenp contains the new length. Note: cursor should be
 * moved to the start of the line after (un)commenting.
 */
static int
x_do_comment(char *buf, ssize_t bsize, ssize_t *lenp)
{
	ssize_t i, j, len = *lenp;

	if (len == 0)
		/* somewhat arbitrary - it's what AT&T ksh does */
		return (1);

	/* Already commented? */
	if (buf[0] == '#') {
		bool saw_nl = false;

		for (j = 0, i = 1; i < len; i++) {
			if (!saw_nl || buf[i] != '#')
				buf[j++] = buf[i];
			saw_nl = buf[i] == '\n';
		}
		*lenp = j;
		return (0);
	} else {
		int n = 1;

		/* See if there's room for the #s - 1 per \n */
		for (i = 0; i < len; i++)
			if (buf[i] == '\n')
				n++;
		if (len + n >= bsize)
			return (-1);
		/* Now add them... */
		for (i = len, j = len + n; --i >= 0; ) {
			if (buf[i] == '\n')
				buf[--j] = '#';
			buf[--j] = buf[i];
		}
		buf[0] = '#';
		*lenp += n;
		return (1);
	}
}

/****************************************************
 * Common file/command completion code for vi/emacs *
 ****************************************************/

static void
x_print_expansions(int nwords, char * const *words, bool is_command)
{
	bool use_copy = false;
	size_t prefix_len;
	XPtrV l = { NULL, 0, 0 };
	struct columnise_opts co;

	/*
	 * Check if all matches are in the same directory (in this
	 * case, we want to omit the directory name)
	 */
	if (!is_command &&
	    (prefix_len = x_longest_prefix(nwords, words)) > 0) {
		int i;

		/* Special case for 1 match (prefix is whole word) */
		if (nwords == 1)
			prefix_len = x_basename(words[0], NULL);
		/* Any (non-trailing) slashes in non-common word suffixes? */
		for (i = 0; i < nwords; i++)
			if (x_basename(words[i] + prefix_len, NULL) >
			    prefix_len)
				break;
		/* All in same directory? */
		if (i == nwords) {
			while (prefix_len > 0 &&
			    !mksh_cdirsep(words[0][prefix_len - 1]))
				prefix_len--;
			use_copy = true;
			XPinit(l, nwords + 1);
			for (i = 0; i < nwords; i++)
				XPput(l, words[i] + prefix_len);
			XPput(l, NULL);
		}
	}
	/*
	 * Enumerate expansions
	 */
	x_putc('\r');
	x_putc('\n');
	co.shf = shl_out;
	co.linesep = '\n';
	co.do_last = true;
	co.prefcol = false;
	pr_list(&co, use_copy ? (char **)XPptrv(l) : words);

	if (use_copy)
		/* not x_free_words() */
		XPfree(l);
}

/*
 * Convert backslash-escaped string to QCHAR-escaped
 * string useful for globbing; loses QCHAR unless it
 * can squeeze in, eg. by previous loss of backslash
 */
static void
x_glob_hlp_add_qchar(char *cp)
{
	char ch, *dp = cp;
	bool escaping = false;

	while ((ch = *cp++)) {
		if (ch == '\\' && !escaping) {
			escaping = true;
			continue;
		}
		if (escaping || (ch == QCHAR && (cp - dp) > 1)) {
			/*
			 * empirically made list of chars to escape
			 * for globbing as well as QCHAR itself
			 */
			switch (ord(ch)) {
			case QCHAR:
			case ORD('$'):
			case ORD('*'):
			case ORD('?'):
			case ORD('['):
			case ORD('\\'):
			case ORD('`'):
				*dp++ = QCHAR;
				break;
			}
			escaping = false;
		}
		*dp++ = ch;
	}
	*dp = '\0';
}

/*
 * Run tilde expansion on argument string, return the result
 * after unescaping; if the flag is set, the original string
 * is freed if changed and assumed backslash-escaped, if not
 * it is assumed QCHAR-escaped
 */
static char *
x_glob_hlp_tilde_and_rem_qchar(char *s, bool magic_flag)
{
	char ch, *cp, *dp;

	/*
	 * On the string, check whether we have a tilde expansion,
	 * and if so, discern "~foo/bar" and "~/baz" from "~blah";
	 * if we have a directory part (the former), try to expand
	 */
	if (*s == '~' && (cp = /* not sdirsep */ strchr(s, '/')) != NULL) {
		/* ok, so split into "~foo"/"bar" or "~"/"baz" */
		*cp++ = 0;
		/* try to expand the tilde */
		if (!(dp = do_tilde(s + 1))) {
			/* nope, revert damage */
			*--cp = '/';
		} else {
			/* ok, expand and replace */
			strpathx(cp, dp, cp, 1);
			if (magic_flag)
				afree(s, ATEMP);
			s = cp;
		}
	}

	/* ... convert it from backslash-escaped via QCHAR-escaped... */
	if (magic_flag)
		x_glob_hlp_add_qchar(s);
	/* ... to unescaped, for comparison with the matches */
	cp = dp = s;

	while ((ch = *cp++)) {
		if (ch == QCHAR && !(ch = *cp++))
			break;
		*dp++ = ch;
	}
	*dp = '\0';

	return (s);
}

/**
 * Do file globbing:
 *	- does expansion, checks for no match, etc.
 *	- sets *wordsp to array of matching strings
 *	- returns number of matching strings
 */
static int
x_file_glob(int *flagsp, char *toglob, char ***wordsp)
{
	char **words, *cp;
	int nwords;
	XPtrV w;
	struct source *s, *sold;

	/* remove all escaping backward slashes */
	x_glob_hlp_add_qchar(toglob);

	/*
	 * Convert "foo*" (toglob) to an array of strings (words)
	 */
	sold = source;
	s = pushs(SWSTR, ATEMP);
	s->start = s->str = toglob;
	source = s;
	if (yylex(ONEWORD | LQCHAR) != LWORD) {
		source = sold;
		internal_warningf(Tfg_badsubst);
		return (0);
	}
	source = sold;
	afree(s, ATEMP);
	XPinit(w, 32);
	cp = yylval.cp;
	while (*cp == CHAR || *cp == QCHAR)
		cp += 2;
	nwords = DOGLOB | DOTILDE | DOMARKDIRS;
	if (*cp != EOS) {
		/* probably a $FOO expansion */
		*flagsp |= XCF_IS_NOSPACE;
		/* this always results in at most one match */
		nwords = 0;
	}
	expand(yylval.cp, &w, nwords);
	XPput(w, NULL);
	words = (char **)XPclose(w);

	for (nwords = 0; words[nwords]; nwords++)
		;
	if (nwords == 1) {
		struct stat statb;

		/* Expand any tilde and drop all QCHAR for comparison */
		toglob = x_glob_hlp_tilde_and_rem_qchar(toglob, false);

		/*
		 * Check if globbing failed (returned glob pattern),
		 * but be careful (e.g. toglob == "ab*" when the file
		 * "ab*" exists is not an error).
		 * Also, check for empty result - happens if we tried
		 * to glob something which evaluated to an empty
		 * string (e.g., "$FOO" when there is no FOO, etc).
		 */
		if ((strcmp(words[0], toglob) == 0 &&
		    stat(words[0], &statb) < 0) ||
		    words[0][0] == '\0') {
			x_free_words(nwords, words);
			words = NULL;
			nwords = 0;
		}
	}

	if ((*wordsp = nwords ? words : NULL) == NULL && words != NULL)
		x_free_words(nwords, words);

	return (nwords);
}

/* Data structure used in x_command_glob() */
struct path_order_info {
	char *word;
	size_t base;
	size_t path_order;
};

/* Compare routine used in x_command_glob() */
static int
path_order_cmp(const void *aa, const void *bb)
{
	const struct path_order_info *a = (const struct path_order_info *)aa;
	const struct path_order_info *b = (const struct path_order_info *)bb;
	int t;

	if ((t = ascstrcmp(a->word + a->base, b->word + b->base)))
		return (t);
	if (a->path_order > b->path_order)
		return (1);
	if (a->path_order < b->path_order)
		return (-1);
	return (0);
}

static int
x_command_glob(int flags, char *toglob, char ***wordsp)
{
	char *pat, *fpath;
	size_t nwords;
	XPtrV w;
	struct block *l;

	/* Convert "foo*" (toglob) to a pattern for future use */
	pat = evalstr(toglob, DOPAT | DOTILDE);

	XPinit(w, 32);

	glob_table(pat, &w, &keywords);
	glob_table(pat, &w, &aliases);
	glob_table(pat, &w, &builtins);
	for (l = e->loc; l; l = l->next)
		glob_table(pat, &w, &l->funs);

	glob_path(flags, pat, &w, path);
	if ((fpath = str_val(global(TFPATH))) != null)
		glob_path(flags, pat, &w, fpath);

	nwords = XPsize(w);

	if (!nwords) {
		*wordsp = NULL;
		XPfree(w);
		return (0);
	}
	/* Sort entries */
	if (flags & XCF_FULLPATH) {
		/* Sort by basename, then path order */
		struct path_order_info *info, *last_info = NULL;
		char **words = (char **)XPptrv(w);
		size_t i, path_order = 0;

		info = (struct path_order_info *)
		    alloc2(nwords, sizeof(struct path_order_info), ATEMP);
		for (i = 0; i < nwords; i++) {
			info[i].word = words[i];
			info[i].base = x_basename(words[i], NULL);
			if (!last_info || info[i].base != last_info->base ||
			    strncmp(words[i], last_info->word, info[i].base) != 0) {
				last_info = &info[i];
				path_order++;
			}
			info[i].path_order = path_order;
		}
		qsort(info, nwords, sizeof(struct path_order_info),
		    path_order_cmp);
		for (i = 0; i < nwords; i++)
			words[i] = info[i].word;
		afree(info, ATEMP);
	} else {
		/* Sort and remove duplicate entries */
		char **words = (char **)XPptrv(w);
		size_t i, j;

		qsort(words, nwords, sizeof(void *), ascpstrcmp);
		for (i = j = 0; i < nwords - 1; i++) {
			if (strcmp(words[i], words[i + 1]))
				words[j++] = words[i];
			else
				afree(words[i], ATEMP);
		}
		words[j++] = words[i];
		w.len = nwords = j;
	}

	XPput(w, NULL);
	*wordsp = (char **)XPclose(w);

	return (nwords);
}

#define IS_WORDC(c)	(!ctype(c, C_EDNWC))

static int
x_locate_word(const char *buf, int buflen, int pos, int *startp,
    bool *is_commandp)
{
	int start, end;

	/* Bad call? Probably should report error */
	if (pos < 0 || pos > buflen) {
		*startp = pos;
		*is_commandp = false;
		return (0);
	}
	/* The case where pos == buflen happens to take care of itself... */

	start = pos;
	/*
	 * Keep going backwards to start of word (has effect of allowing
	 * one blank after the end of a word)
	 */
	for (; (start > 0 && IS_WORDC(buf[start - 1])) ||
	    (start > 1 && buf[start - 2] == '\\'); start--)
		;
	/* Go forwards to end of word */
	for (end = start; end < buflen && IS_WORDC(buf[end]); end++) {
		if (buf[end] == '\\' && (end + 1) < buflen)
			end++;
	}

	if (is_commandp) {
		bool iscmd;
		int p = start - 1;

		/* Figure out if this is a command */
		while (p >= 0 && ctype(buf[p], C_SPACE))
			p--;
		iscmd = p < 0 || ctype(buf[p], C_EDCMD);
		if (iscmd) {
			/*
			 * If command has a /, path, etc. is not searched;
			 * only current directory is searched which is just
			 * like file globbing.
			 */
			for (p = start; p < end; p++)
				if (mksh_cdirsep(buf[p]))
					break;
			iscmd = p == end;
		}
		*is_commandp = iscmd;
	}
	*startp = start;

	return (end - start);
}

static int
x_cf_glob(int *flagsp, const char *buf, int buflen, int pos, int *startp,
    int *endp, char ***wordsp)
{
	int len, nwords = 0;
	char **words = NULL;
	bool is_command;

	len = x_locate_word(buf, buflen, pos, startp, &is_command);
	if (!((*flagsp) & XCF_COMMAND))
		is_command = false;
	/*
	 * Don't do command globing on zero length strings - it takes too
	 * long and isn't very useful. File globs are more likely to be
	 * useful, so allow these.
	 */
	if (len == 0 && is_command)
		return (0);

	if (len >= 0) {
		char *toglob, *s;

		/*
		 * Given a string, copy it and possibly add a '*' to the end.
		 */

		strndupx(toglob, buf + *startp, len + /* the '*' */ 1, ATEMP);
		toglob[len] = '\0';

		/*
		 * If the pathname contains a wildcard (an unquoted '*',
		 * '?', or '[') or an extglob, then it is globbed based
		 * on that value (i.e., without the appended '*'). Same
		 * for parameter substitutions (as in “cat $HOME/.ss↹”)
		 * without appending a trailing space (LP: #710539), as
		 * well as for “~foo” (but not “~foo/”).
		 */
		for (s = toglob; *s; s++) {
			if (*s == '\\' && s[1])
				s++;
			else if (ctype(*s, C_QUEST | C_DOLAR) ||
			    ord(*s) == ORD('*') || ord(*s) == ORD('[') ||
			    /* ?() *() +() @@() !() but two already checked */
			    (ord(s[1]) == ORD('(' /*)*/) &&
			    (ord(*s) == ORD('+') || ord(*s) == ORD('@@') ||
			    ord(*s) == ORD('!')))) {
				/*
				 * just expand based on the extglob
				 * or parameter
				 */
				goto dont_add_glob;
			}
		}

		if (*toglob == '~' && /* not vdirsep */ !vstrchr(toglob, '/')) {
			/* neither for '~foo' (but '~foo/bar') */
			*flagsp |= XCF_IS_NOSPACE;
			goto dont_add_glob;
		}

		/* append a glob */
		toglob[len] = '*';
		toglob[len + 1] = '\0';
 dont_add_glob:
		/*
		 * Expand (glob) it now.
		 */

		nwords = is_command ?
		    x_command_glob(*flagsp, toglob, &words) :
		    x_file_glob(flagsp, toglob, &words);
		afree(toglob, ATEMP);
	}
	if (nwords == 0) {
		*wordsp = NULL;
		return (0);
	}
	if (is_command)
		*flagsp |= XCF_IS_COMMAND;
	*wordsp = words;
	*endp = *startp + len;

	return (nwords);
}

/*
 * Find longest common prefix
 */
static size_t
x_longest_prefix(int nwords, char * const * words)
{
	int i;
	size_t j, prefix_len;
	char *p;

	if (nwords <= 0)
		return (0);

	prefix_len = strlen(words[0]);
	for (i = 1; i < nwords; i++)
		for (j = 0, p = words[i]; j < prefix_len; j++)
			if (p[j] != words[0][j]) {
				prefix_len = j;
				break;
			}
	/* false for nwords==1 as 0 = words[0][prefix_len] then */
	if (UTFMODE && prefix_len && (rtt2asc(words[0][prefix_len]) & 0xC0) == 0x80)
		while (prefix_len && (rtt2asc(words[0][prefix_len]) & 0xC0) != 0xC0)
			--prefix_len;
	return (prefix_len);
}

static void
x_free_words(int nwords, char **words)
{
	while (nwords)
		afree(words[--nwords], ATEMP);
	afree(words, ATEMP);
}

/*-
 * Return the offset of the basename of string s (which ends at se - need not
 * be null terminated). Trailing slashes are ignored. If s is just a slash,
 * then the offset is 0 (actually, length - 1).
 *	s		Return
 *	/etc		1
 *	/etc/		1
 *	/etc//		1
 *	/etc/fo		5
 *	foo		0
 *	///		2
 *			0
 */
static size_t
x_basename(const char *s, const char *se)
{
	const char *p;

	if (se == NULL)
		se = strnul(s);
	if (s == se)
		return (0);

	/* skip trailing directory separators */
	p = se - 1;
	while (p > s && mksh_cdirsep(*p))
		--p;
	/* drop last component */
	while (p > s && !mksh_cdirsep(*p))
		--p;
	if (mksh_cdirsep(*p) && p + 1 < se)
		++p;

	return (p - s);
}

/*
 * Apply pattern matching to a table: all table entries that match a pattern
 * are added to wp.
 */
static void
glob_table(const char *pat, XPtrV *wp, struct table *tp)
{
	struct tstate ts;
	struct tbl *te;

	ktwalk(&ts, tp);
	while ((te = ktnext(&ts)))
		if (gmatchx(te->name, pat, false)) {
			char *cp;

			strdupx(cp, te->name, ATEMP);
			XPput(*wp, cp);
		}
}

static void
glob_path(int flags, const char *pat, XPtrV *wp, const char *lpath)
{
	const char *sp = lpath, *p;
	char *xp, **words;
	size_t pathlen, patlen, oldsize, newsize, i, j;
	XString xs;

	patlen = strlen(pat);
	checkoktoadd(patlen, 129 + X_EXTRA);
	++patlen;
	Xinit(xs, xp, patlen + 128, ATEMP);
	while (sp) {
		xp = Xstring(xs, xp);
		if (!(p = cstrchr(sp, MKSH_PATHSEPC)))
			p = strnul(sp);
		pathlen = p - sp;
		if (pathlen) {
			/*
			 * Copy sp into xp, stuffing any MAGIC characters
			 * on the way
			 */
			const char *s = sp;

			XcheckN(xs, xp, pathlen * 2);
			while (s < p) {
				if (ISMAGIC(*s))
					*xp++ = MAGIC;
				*xp++ = *s++;
			}
			*xp++ = '/';
			pathlen++;
		}
		sp = p;
		XcheckN(xs, xp, patlen);
		memcpy(xp, pat, patlen);

		oldsize = XPsize(*wp);
		/* mark dirs */
		glob_str(Xstring(xs, xp), wp, true);
		newsize = XPsize(*wp);

		/* Check that each match is executable... */
		words = (char **)XPptrv(*wp);
		for (i = j = oldsize; i < newsize; i++) {
			if (ksh_access(words[i], X_OK) == 0) {
				words[j] = words[i];
				if (!(flags & XCF_FULLPATH))
					memmove(words[j], words[j] + pathlen,
					    strlen(words[j] + pathlen) + 1);
				j++;
			} else
				afree(words[i], ATEMP);
		}
		wp->len = j;

		if (!*sp++)
			break;
	}
	Xfree(xs, xp);
}

/*
 * if argument string contains any special characters, they will
 * be escaped and the result will be put into edit buffer by
 * keybinding-specific function
 */
static int
x_escape(const char *s, size_t len, int (*putbuf_func)(const char *, size_t))
{
	size_t add = 0, wlen = len;
	int rval = 0;

	while (wlen - add > 0)
		if (ctype(s[add], C_IFS | C_EDQ)) {
			if (putbuf_func(s, add) != 0) {
				rval = -1;
				break;
			}
			putbuf_func(s[add] == '\n' ? "'" : "\\", 1);
			putbuf_func(&s[add], 1);
			if (s[add] == '\n')
				putbuf_func("'", 1);

			add++;
			wlen -= add;
			s += add;
			add = 0;
		} else
			++add;
	if (wlen > 0 && rval == 0)
		rval = putbuf_func(s, wlen);

	return (rval);
}


/* +++ emacs editing mode +++ */

static	Area	aedit;
#define	AEDIT	&aedit		/* area for kill ring and macro defns */

/* values returned by keyboard functions */
#define	KSTD	0
#define	KEOL	1		/* ^M, ^J */
#define	KINTR	2		/* ^G, ^C */

struct x_ftab {
	int (*xf_func)(int c);
	const char *xf_name;
	short xf_flags;
};

struct x_defbindings {
	unsigned char xdb_func;	/* XFUNC_* */
	unsigned char xdb_tab;
	unsigned char xdb_char;
};

#define XF_ARG		1	/* command takes number prefix */
#define	XF_NOBIND	2	/* not allowed to bind to function */
#define	XF_PREFIX	4	/* function sets prefix */

#define X_NTABS		4			/* normal, meta1, meta2, pc */
#define X_TABSZ		256			/* size of keydef tables etc */

/*-
 * Arguments for do_complete()
 * 0 = enumerate	M-=	complete as much as possible and then list
 * 1 = complete		M-Esc
 * 2 = list		M-?
 */
typedef enum {
	CT_LIST,	/* list the possible completions */
	CT_COMPLETE,	/* complete to longest prefix */
	CT_COMPLIST	/* complete and then list (if non-exact) */
} Comp_type;

/*
 * The following are used for my horizontal scrolling stuff
 */
static char *xbuf;		/* beg input buffer */
static char *xend;		/* end input buffer */
static char *xcp;		/* current position */
static char *xep;		/* current end */
static char *xbp;		/* start of visible portion of input buffer */
static char *xlp;		/* last char visible on screen */
static bool x_adj_ok;
/*
 * we use x_adj_done so that functions can tell
 * whether x_adjust() has been called while they are active.
 */
static int x_adj_done;		/* is incremented by x_adjust() */

static int x_displen;
static int x_arg;		/* general purpose arg */
static bool x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */

static bool xlp_valid;		/* lastvis pointer was recalculated */

static char **x_histp;		/* history position */
static int x_nextcmd;		/* for newline-and-next */
static char **x_histncp;	/* saved x_histp for " */
static char **x_histmcp;	/* saved x_histp for " */
static char *xmp;		/* mark pointer */
static unsigned char x_last_command;
static unsigned char (*x_tab)[X_TABSZ];	/* key definition */
#ifndef MKSH_SMALL
static char *(*x_atab)[X_TABSZ];	/* macro definitions */
#endif
static unsigned char x_bound[(X_TABSZ * X_NTABS + 7) / 8];
#define KILLSIZE	20
static char *killstack[KILLSIZE];
static int killsp, killtp;
static int x_curprefix;
#ifndef MKSH_SMALL
static char *macroptr;		/* bind key macro active? */
#endif
#if !MKSH_S_NOVI
static int winwidth;		/* width of window */
static char *wbuf[2];		/* window buffers */
static int wbuf_len;		/* length of window buffers (x_cols - 3) */
static int win;			/* window buffer in use */
static char morec;		/* more character at right of window */
static int lastref;		/* argument to last refresh() */
static int holdlen;		/* length of holdbuf */
#endif
static int pwidth;		/* width of prompt */
static int prompt_trunc;	/* how much of prompt to truncate or -1 */
static int x_col;		/* current column on line */

static int x_ins(const char *);
static void x_delete(size_t, bool);
static size_t x_bword(void);
static size_t x_fword(bool);
static void x_goto(char *);
static char *x_bs0(char *, char *) MKSH_A_PURE;
static void x_bs3(char **);
static int x_size2(char *, char **);
static void x_zots(char *);
static void x_zotc3(char **);
static void x_vi_zotc(int);
static void x_load_hist(char **);
static int x_search(char *, int, int);
#ifndef MKSH_SMALL
static int x_search_dir(int);
#endif
static int x_match(char *, char *);
static void x_redraw(int);
static void x_push(size_t);
static char *x_mapin(const char *, Area *);
static char *x_mapout(int);
static void x_mapout2(int, char **);
static void x_print(int, int);
static void x_e_ungetc(int);
static int x_e_getc(void);
static void x_e_putc2(int);
static void x_e_putc3(const char **);
static void x_e_puts(const char *);
#ifndef MKSH_SMALL
static int x_fold_case(int);
#endif
static char *x_lastcp(void);
static void x_lastpos(void);
static void do_complete(int, Comp_type);
static size_t x_nb2nc(size_t) MKSH_A_PURE;

static int unget_char = -1;

static int x_do_ins(const char *, size_t);
static void bind_if_not_bound(int, int, int);

enum emacs_funcs {
#define EMACSFN_ENUMS
#include "emacsfn.h"
	XFUNC_MAX
};

#define EMACSFN_DEFNS
#include "emacsfn.h"

static const struct x_ftab x_ftab[] = {
#define EMACSFN_ITEMS
#include "emacsfn.h"
};

static struct x_defbindings const x_defbindings[] = {
	{ XFUNC_del_back,		0,  CTRL_QM	},
	{ XFUNC_del_bword,		1,  CTRL_QM	},
	{ XFUNC_eot_del,		0,  CTRL_D	},
	{ XFUNC_del_back,		0,  CTRL_H	},
	{ XFUNC_del_bword,		1,  CTRL_H	},
	{ XFUNC_del_bword,		1,	'h'	},
	{ XFUNC_mv_bword,		1,	'b'	},
	{ XFUNC_mv_fword,		1,	'f'	},
	{ XFUNC_del_fword,		1,	'd'	},
	{ XFUNC_mv_back,		0,  CTRL_B	},
	{ XFUNC_mv_forw,		0,  CTRL_F	},
	{ XFUNC_search_char_forw,	0,  CTRL_BC	},
	{ XFUNC_search_char_back,	1,  CTRL_BC	},
	{ XFUNC_newline,		0,  CTRL_M	},
	{ XFUNC_newline,		0,  CTRL_J	},
	{ XFUNC_end_of_text,		0,  CTRL_US	},
	{ XFUNC_abort,			0,  CTRL_G	},
	{ XFUNC_prev_com,		0,  CTRL_P	},
	{ XFUNC_next_com,		0,  CTRL_N	},
	{ XFUNC_nl_next_com,		0,  CTRL_O	},
	{ XFUNC_search_hist,		0,  CTRL_R	},
	{ XFUNC_beg_hist,		1,	'<'	},
	{ XFUNC_end_hist,		1,	'>'	},
	{ XFUNC_goto_hist,		1,	'g'	},
	{ XFUNC_mv_end,			0,  CTRL_E	},
	{ XFUNC_mv_beg,			0,  CTRL_A	},
	{ XFUNC_draw_line,		0,  CTRL_L	},
	{ XFUNC_cls,			1,  CTRL_L	},
	{ XFUNC_meta1,			0,  CTRL_BO	},
	{ XFUNC_meta2,			0,  CTRL_X	},
	{ XFUNC_kill,			0,  CTRL_K	},
	{ XFUNC_yank,			0,  CTRL_Y	},
	{ XFUNC_meta_yank,		1,	'y'	},
	{ XFUNC_literal,		0,  CTRL_CA	},
	{ XFUNC_comment,		1,	'#'	},
	{ XFUNC_transpose,		0,  CTRL_T	},
	{ XFUNC_complete,		1,  CTRL_BO	},
	{ XFUNC_comp_list,		0,  CTRL_I	},
	{ XFUNC_comp_list,		1,	'='	},
	{ XFUNC_enumerate,		1,	'?'	},
	{ XFUNC_expand,			1,	'*'	},
	{ XFUNC_comp_file,		1,  CTRL_X	},
	{ XFUNC_comp_comm,		2,  CTRL_BO	},
	{ XFUNC_list_comm,		2,	'?'	},
	{ XFUNC_list_file,		2,  CTRL_Y	},
	{ XFUNC_set_mark,		1,	' '	},
	{ XFUNC_kill_region,		0,  CTRL_W	},
	{ XFUNC_xchg_point_mark,	2,  CTRL_X	},
	{ XFUNC_literal,		0,  CTRL_V	},
	{ XFUNC_version,		1,  CTRL_V	},
	{ XFUNC_prev_histword,		1,	'.'	},
	{ XFUNC_prev_histword,		1,	'_'	},
	{ XFUNC_set_arg,		1,	'0'	},
	{ XFUNC_set_arg,		1,	'1'	},
	{ XFUNC_set_arg,		1,	'2'	},
	{ XFUNC_set_arg,		1,	'3'	},
	{ XFUNC_set_arg,		1,	'4'	},
	{ XFUNC_set_arg,		1,	'5'	},
	{ XFUNC_set_arg,		1,	'6'	},
	{ XFUNC_set_arg,		1,	'7'	},
	{ XFUNC_set_arg,		1,	'8'	},
	{ XFUNC_set_arg,		1,	'9'	},
#ifndef MKSH_SMALL
	{ XFUNC_fold_upper,		1,	'U'	},
	{ XFUNC_fold_upper,		1,	'u'	},
	{ XFUNC_fold_lower,		1,	'L'	},
	{ XFUNC_fold_lower,		1,	'l'	},
	{ XFUNC_fold_capitalise,	1,	'C'	},
	{ XFUNC_fold_capitalise,	1,	'c'	},
#endif
	/*
	 * These for ANSI arrow keys: arguablely shouldn't be here by
	 * default, but its simpler/faster/smaller than using termcap
	 * entries.
	 */
	{ XFUNC_meta2,			1,	'['	},
	{ XFUNC_meta2,			1,	'O'	},
	{ XFUNC_prev_com,		2,	'A'	},
	{ XFUNC_next_com,		2,	'B'	},
	{ XFUNC_mv_forw,		2,	'C'	},
	{ XFUNC_mv_back,		2,	'D'	},
#ifndef MKSH_SMALL
	{ XFUNC_vt_hack,		2,	'1'	},
	{ XFUNC_mv_beg | 0x80,		2,	'7'	},
	{ XFUNC_mv_beg,			2,	'H'	},
	{ XFUNC_mv_end | 0x80,		2,	'4'	},
	{ XFUNC_mv_end | 0x80,		2,	'8'	},
	{ XFUNC_mv_end,			2,	'F'	},
	{ XFUNC_del_char | 0x80,	2,	'3'	},
	{ XFUNC_del_char,		2,	'P'	},
	{ XFUNC_search_hist_up | 0x80,	2,	'5'	},
	{ XFUNC_search_hist_dn | 0x80,	2,	'6'	},
#endif
	/* PC scancodes */
#if !defined(MKSH_SMALL) || defined(__OS2__)
	{ XFUNC_meta3,			0,	0	},
	{ XFUNC_mv_beg,			3,	71	},
	{ XFUNC_prev_com,		3,	72	},
#ifndef MKSH_SMALL
	{ XFUNC_search_hist_up,		3,	73	},
#endif
	{ XFUNC_mv_back,		3,	75	},
	{ XFUNC_mv_forw,		3,	77	},
	{ XFUNC_mv_end,			3,	79	},
	{ XFUNC_next_com,		3,	80	},
#ifndef MKSH_SMALL
	{ XFUNC_search_hist_dn,		3,	81	},
#endif
	{ XFUNC_del_char,		3,	83	},
#endif
#ifndef MKSH_SMALL
	/* more non-standard ones */
	{ XFUNC_eval_region,		1,  CTRL_E	},
	{ XFUNC_edit_line,		2,	'e'	}
#endif
};

static size_t
x_nb2nc(size_t nb)
{
	char *cp;
	size_t nc = 0;

	for (cp = xcp; cp < (xcp + nb); ++nc)
		cp += utf_ptradj(cp);
	return (nc);
}

static void
x_modified(void)
{
	if (!modified) {
		x_histmcp = x_histp;
		x_histp = histptr + 1;
		modified = 1;
	}
}

#ifdef MKSH_SMALL
#define XFUNC_VALUE(f) (f)
#else
#define XFUNC_VALUE(f) (f & 0x7F)
#endif

static int
x_e_getmbc(char *sbuf)
{
	int c, pos = 0;
	unsigned char *buf = (unsigned char *)sbuf;

	memset(buf, 0, 4);
	buf[pos++] = c = x_e_getc();
	if (c == -1)
		return (-1);
	if (UTFMODE) {
		if ((rtt2asc(buf[0]) >= (unsigned char)0xC2) &&
		    (rtt2asc(buf[0]) < (unsigned char)0xF0)) {
			c = x_e_getc();
			if (c == -1)
				return (-1);
			if ((rtt2asc(c) & 0xC0) != 0x80) {
				x_e_ungetc(c);
				return (1);
			}
			buf[pos++] = c;
		}
		if ((rtt2asc(buf[0]) >= (unsigned char)0xE0) &&
		    (rtt2asc(buf[0]) < (unsigned char)0xF0)) {
			/* XXX x_e_ungetc is one-octet only */
			buf[pos++] = c = x_e_getc();
			if (c == -1)
				return (-1);
		}
	}
	return (pos);
}

/*
 * minimum required space to work with on a line - if the prompt
 * leaves less space than this on a line, the prompt is truncated
 */
#define MIN_EDIT_SPACE	7

static void
x_init_prompt(bool doprint)
{
	prompt_trunc = pprompt(prompt, doprint ? 0 : -1);
	pwidth = prompt_trunc % x_cols;
	prompt_trunc -= pwidth;
	if ((mksh_uari_t)pwidth > ((mksh_uari_t)x_cols - 3 - MIN_EDIT_SPACE)) {
		/* force newline after prompt */
		prompt_trunc = -1;
		pwidth = 0;
		if (doprint)
			x_e_putc2('\n');
	}
}

static int
x_emacs(char *buf)
{
	int c, i;
	unsigned char f;

	xbp = xbuf = buf;
	xend = buf + LINE;
	xlp = xcp = xep = buf;
	*xcp = 0;
	xlp_valid = true;
	xmp = NULL;
	x_curprefix = 0;
	x_histmcp = x_histp = histptr + 1;
	x_last_command = XFUNC_error;

	x_init_prompt(true);
	x_displen = (xx_cols = x_cols) - 2 - (x_col = pwidth);
	x_adj_done = 0;
	x_adj_ok = true;

	x_histncp = NULL;
	if (x_nextcmd >= 0) {
		int off = source->line - x_nextcmd;
		if (histptr - history >= off) {
			x_load_hist(histptr - off);
			x_histncp = x_histp;
		}
		x_nextcmd = -1;
	}
	editmode = 1;
	while (/* CONSTCOND */ 1) {
		x_flush();
		if ((c = x_e_getc()) < 0)
			return (0);

		f = x_curprefix == -1 ? XFUNC_insert :
		    x_tab[x_curprefix][c];
#ifndef MKSH_SMALL
		if (f & 0x80) {
			f &= 0x7F;
			if ((i = x_e_getc()) != '~')
				x_e_ungetc(i);
		}

		/* avoid bind key macro recursion */
		if (macroptr && f == XFUNC_ins_string)
			f = XFUNC_insert;
#endif

		if (!(x_ftab[f].xf_flags & XF_PREFIX) &&
		    x_last_command != XFUNC_set_arg) {
			x_arg = 1;
			x_arg_defaulted = true;
		}
		i = c | (x_curprefix << 8);
		x_curprefix = 0;
		switch ((*x_ftab[f].xf_func)(i)) {
		case KSTD:
			if (!(x_ftab[f].xf_flags & XF_PREFIX))
				x_last_command = f;
			break;
		case KEOL:
			i = xep - xbuf;
			return (i);
		case KINTR:
			/* special case for interrupt */
			x_intr(SIGINT, c);
		}
		/* ad-hoc hack for fixing the cursor position */
		x_goto(xcp);
	}
}

static int
x_insert(int c)
{
	static int left, pos, save_arg;
	static char str[4];

	/*
	 * Should allow tab and control chars.
	 */
	if (c == 0) {
 invmbs:
		left = 0;
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	if (UTFMODE) {
		if (((rtt2asc(c) & 0xC0) == 0x80) && left) {
			str[pos++] = c;
			if (!--left) {
				str[pos] = '\0';
				x_arg = save_arg;
				while (x_arg--)
					x_ins(str);
			}
			return (KSTD);
		}
		if (left) {
			if (x_curprefix == -1) {
				/* flush invalid multibyte */
				str[pos] = '\0';
				while (save_arg--)
					x_ins(str);
			}
		}
		if ((c >= 0xC2) && (c < 0xE0))
			left = 1;
		else if ((c >= 0xE0) && (c < 0xF0))
			left = 2;
		else if (c > 0x7F)
			goto invmbs;
		else
			left = 0;
		if (left) {
			save_arg = x_arg;
			pos = 1;
			str[0] = c;
			return (KSTD);
		}
	}
	left = 0;
	str[0] = c;
	str[1] = '\0';
	while (x_arg--)
		x_ins(str);
	return (KSTD);
}

#ifndef MKSH_SMALL
static int
x_ins_string(int c)
{
	macroptr = x_atab[c >> 8][c & 255];
	/*
	 * we no longer need to bother checking if macroptr is
	 * not NULL but first char is NUL; x_e_getc() does it
	 */
	return (KSTD);
}
#endif

static int
x_do_ins(const char *cp, size_t len)
{
	if (xep + len >= xend) {
		x_e_putc2(KSH_BEL);
		return (-1);
	}
	memmove(xcp + len, xcp, xep - xcp + 1);
	memmove(xcp, cp, len);
	xcp += len;
	xep += len;
	x_modified();
	return (0);
}

static int
x_ins(const char *s)
{
	char *cp = xcp;
	int adj = x_adj_done;

	if (x_do_ins(s, strlen(s)) < 0)
		return (-1);
	/*
	 * x_zots() may result in a call to x_adjust()
	 * we want xcp to reflect the new position.
	 */
	xlp_valid = false;
	x_lastcp();
	x_adj_ok = tobool(xcp >= xlp);
	x_zots(cp);
	if (adj == x_adj_done)
		/* x_adjust() has not been called */
		x_lastpos();
	x_adj_ok = true;
	return (0);
}

static int
x_del_back(int c MKSH_A_UNUSED)
{
	ssize_t i = 0;

	if (xcp == xbuf) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	do {
		x_goto(xcp - 1);
	} while ((++i < x_arg) && (xcp != xbuf));
	x_delete(i, false);
	return (KSTD);
}

static int
x_del_char(int c MKSH_A_UNUSED)
{
	char *cp, *cp2;
	size_t i = 0;

	cp = xcp;
	while (i < (size_t)x_arg) {
		utf_ptradjx(cp, cp2);
		if (cp2 > xep)
			break;
		cp = cp2;
		i++;
	}

	if (!i) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	x_delete(i, false);
	return (KSTD);
}

/* Delete nc chars to the right of the cursor (including cursor position) */
static void
x_delete(size_t nc, bool push)
{
	size_t i, nb, nw;
	char *cp;

	if (nc == 0)
		return;

	nw = 0;
	cp = xcp;
	for (i = 0; i < nc; ++i) {
		char *cp2;
		int j;

		j = x_size2(cp, &cp2);
		if (cp2 > xep)
			break;
		cp = cp2;
		nw += j;
	}
	nb = cp - xcp;
	/* nc = i; */

	if (xmp != NULL && xmp > xcp) {
		if (xcp + nb > xmp)
			xmp = xcp;
		else
			xmp -= nb;
	}
	/*
	 * This lets us yank a word we have deleted.
	 */
	if (push)
		x_push(nb);

	xep -= nb;
	/* Copies the NUL */
	memmove(xcp, xcp + nb, xep - xcp + 1);
	/* don't redraw */
	x_adj_ok = false;
	xlp_valid = false;
	x_zots(xcp);
	/*
	 * if we are already filling the line,
	 * there is no need to ' ', '\b'.
	 * But if we must, make sure we do the minimum.
	 */
	if ((i = xx_cols - 2 - x_col) > 0 || xep - xlp == 0) {
		nw = i = (nw < i) ? nw : i;
		while (i--)
			x_e_putc2(' ');
		if (x_col == xx_cols - 2) {
			x_e_putc2((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
			++nw;
		}
		while (nw--)
			x_e_putc2('\b');
	}
	/*x_goto(xcp);*/
	x_adj_ok = true;
	xlp_valid = false;
	x_lastpos();
	x_modified();
	return;
}

static int
x_del_bword(int c MKSH_A_UNUSED)
{
	x_delete(x_bword(), true);
	return (KSTD);
}

static int
x_mv_bword(int c MKSH_A_UNUSED)
{
	x_bword();
	return (KSTD);
}

static int
x_mv_fword(int c MKSH_A_UNUSED)
{
	x_fword(true);
	return (KSTD);
}

static int
x_del_fword(int c MKSH_A_UNUSED)
{
	x_delete(x_fword(false), true);
	return (KSTD);
}

static size_t
x_bword(void)
{
	size_t nb = 0;
	char *cp = xcp;

	if (cp == xbuf) {
		x_e_putc2(KSH_BEL);
		return (0);
	}
	while (x_arg--) {
		while (cp != xbuf && ctype(cp[-1], C_MFS)) {
			cp--;
			nb++;
		}
		while (cp != xbuf && !ctype(cp[-1], C_MFS)) {
			cp--;
			nb++;
		}
	}
	x_goto(cp);
	return (x_nb2nc(nb));
}

static size_t
x_fword(bool move)
{
	size_t nc;
	char *cp = xcp;

	if (cp == xep) {
		x_e_putc2(KSH_BEL);
		return (0);
	}
	while (x_arg--) {
		while (cp != xep && ctype(*cp, C_MFS))
			cp++;
		while (cp != xep && !ctype(*cp, C_MFS))
			cp++;
	}
	nc = x_nb2nc(cp - xcp);
	if (move)
		x_goto(cp);
	return (nc);
}

static void
x_goto(char *cp)
{
	cp = cp >= xep ? xep : x_bs0(cp, xbuf);
	if (cp < xbp || cp >= utf_skipcols(xbp, x_displen, NULL)) {
		/* we are heading off screen */
		xcp = cp;
		x_adjust();
	} else if (cp < xcp) {
		/* move back */
		while (cp < xcp)
			x_bs3(&xcp);
	} else if (cp > xcp) {
		/* move forward */
		while (cp > xcp)
			x_zotc3(&xcp);
	}
}

static char *
x_bs0(char *cp, char *lower_bound)
{
	if (UTFMODE)
		while ((!lower_bound || (cp > lower_bound)) &&
		    ((rtt2asc(*cp) & 0xC0) == 0x80))
			--cp;
	return (cp);
}

static void
x_bs3(char **p)
{
	int i;

	*p = x_bs0((*p) - 1, NULL);
	i = x_size2(*p, NULL);
	while (i--)
		x_e_putc2('\b');
}

static int
x_size2(char *cp, char **dcp)
{
	uint8_t c = *(unsigned char *)cp;

	if (UTFMODE && (rtt2asc(c) > 0x7F))
		return (utf_widthadj(cp, (const char **)dcp));
	if (dcp)
		*dcp = cp + 1;
	if (c == '\t')
		/* Kludge, tabs are always four spaces. */
		return (4);
	if (ksh_isctrl(c))
		/* control unsigned char */
		return (2);
	return (1);
}

static void
x_zots(char *str)
{
	int adj = x_adj_done;

	x_lastcp();
	while (*str && str < xlp && x_col < xx_cols && adj == x_adj_done)
		x_zotc3(&str);
}

static void
x_zotc3(char **cp)
{
	unsigned char c = **(unsigned char **)cp;

	if (c == '\t') {
		/* Kludge, tabs are always four spaces. */
		x_e_puts(T4spaces);
		(*cp)++;
	} else if (ksh_isctrl(c)) {
		x_e_putc2('^');
		x_e_putc2(ksh_unctrl(c));
		(*cp)++;
	} else
		x_e_putc3((const char **)cp);
}

static int
x_mv_back(int c MKSH_A_UNUSED)
{
	if (xcp == xbuf) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	while (x_arg--) {
		x_goto(xcp - 1);
		if (xcp == xbuf)
			break;
	}
	return (KSTD);
}

static int
x_mv_forw(int c MKSH_A_UNUSED)
{
	char *cp = xcp, *cp2;

	if (xcp == xep) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	while (x_arg--) {
		utf_ptradjx(cp, cp2);
		if (cp2 > xep)
			break;
		cp = cp2;
	}
	x_goto(cp);
	return (KSTD);
}

static int
x_search_char_forw(int c MKSH_A_UNUSED)
{
	char *cp = xcp;
	char tmp[4];

	*xep = '\0';
	if (x_e_getmbc(tmp) < 0) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	while (x_arg--) {
		if ((cp = (cp == xep) ? NULL : strstr(cp + 1, tmp)) == NULL &&
		    (cp = strstr(xbuf, tmp)) == NULL) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
	}
	x_goto(cp);
	return (KSTD);
}

static int
x_search_char_back(int c MKSH_A_UNUSED)
{
	char *cp = xcp, *p, tmp[4];
	bool b;

	if (x_e_getmbc(tmp) < 0) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	for (; x_arg--; cp = p)
		for (p = cp; ; ) {
			if (p-- == xbuf)
				p = xep;
			if (p == cp) {
				x_e_putc2(KSH_BEL);
				return (KSTD);
			}
			if ((tmp[1] && ((p+1) > xep)) ||
			    (tmp[2] && ((p+2) > xep)))
				continue;
			b = true;
			if (*p != tmp[0])
				b = false;
			if (b && tmp[1] && p[1] != tmp[1])
				b = false;
			if (b && tmp[2] && p[2] != tmp[2])
				b = false;
			if (b)
				break;
		}
	x_goto(cp);
	return (KSTD);
}

static int
x_newline(int c MKSH_A_UNUSED)
{
	x_e_putc2('\r');
	x_e_putc2('\n');
	x_flush();
	*xep++ = '\n';
	return (KEOL);
}

static int
x_end_of_text(int c MKSH_A_UNUSED)
{
	unsigned char tmp[1], *cp = tmp;

	*tmp = isedchar(edchars.eof) ? (unsigned char)edchars.eof :
	    (unsigned char)CTRL_D;
	x_zotc3((char **)&cp);
	x_putc('\r');
	x_putc('\n');
	x_flush();
	return (KEOL);
}

static int
x_beg_hist(int c MKSH_A_UNUSED)
{
	x_load_hist(history);
	return (KSTD);
}

static int
x_end_hist(int c MKSH_A_UNUSED)
{
	x_load_hist(histptr);
	return (KSTD);
}

static int
x_prev_com(int c MKSH_A_UNUSED)
{
	x_load_hist(x_histp - x_arg);
	return (KSTD);
}

static int
x_next_com(int c MKSH_A_UNUSED)
{
	x_load_hist(x_histp + x_arg);
	return (KSTD);
}

/*
 * Goto a particular history number obtained from argument.
 * If no argument is given history 1 is probably not what you
 * want so we'll simply go to the oldest one.
 */
static int
x_goto_hist(int c MKSH_A_UNUSED)
{
	if (x_arg_defaulted)
		x_load_hist(history);
	else
		x_load_hist(histptr + x_arg - source->line);
	return (KSTD);
}

static void
x_load_hist(char **hp)
{
	char *sp = NULL;

	if (hp == histptr + 1) {
		sp = holdbufp;
		modified = 0;
	} else if (hp < history || hp > histptr) {
		x_e_putc2(KSH_BEL);
		return;
	}
	if (sp == NULL)
		sp = *hp;
	x_histp = hp;
	if (modified)
		strlcpy(holdbufp, xbuf, LINE);
	strlcpy(xbuf, sp, xend - xbuf);
	xbp = xbuf;
	xep = xcp = strnul(xbuf);
	x_adjust();
	modified = 0;
}

static int
x_nl_next_com(int c MKSH_A_UNUSED)
{
	if (!modified)
		x_histmcp = x_histp;
	if (!x_histncp || (x_histmcp != x_histncp && x_histmcp != histptr + 1))
		/* fresh start of ^O */
		x_histncp = x_histmcp;
	x_nextcmd = source->line - (histptr - x_histncp) + 1;
	return (x_newline('\n'));
}

static int
x_eot_del(int c)
{
	if (xep == xbuf && x_arg_defaulted)
		return (x_end_of_text(c));
	else
		return (x_del_char(c));
}

/* reverse incremental history search */
static int
x_search_hist(int c)
{
	int offset = -1;	/* offset of match in xbuf, else -1 */
	char pat[80 + 1];	/* pattern buffer */
	char *p = pat;
	unsigned char f;

	*p = '\0';
	while (/* CONSTCOND */ 1) {
		if (offset < 0) {
			x_e_puts("\nI-search: ");
			x_e_puts(pat);
		}
		x_flush();
		if ((c = x_e_getc()) < 0)
			return (KSTD);
		f = x_tab[0][c];
		if (c == CTRL_BO) {
			if ((f & 0x7F) == XFUNC_meta1) {
				if ((c = x_e_getc()) < 0)
					return (KSTD);
				f = x_tab[1][c] & 0x7F;
				if (f == XFUNC_meta1 || f == XFUNC_meta2)
					x_meta1(CTRL_BO);
				x_e_ungetc(c);
			}
			break;
		}
#ifndef MKSH_SMALL
		if (f & 0x80) {
			f &= 0x7F;
			if ((c = x_e_getc()) != '~')
				x_e_ungetc(c);
		}
#endif
		if (f == XFUNC_search_hist)
			offset = x_search(pat, 0, offset);
		else if (f == XFUNC_del_back) {
			if (p == pat) {
				offset = -1;
				break;
			}
			if (p > pat) {
				p = x_bs0(p - 1, pat);
				*p = '\0';
			}
			if (p == pat)
				offset = -1;
			else
				offset = x_search(pat, 1, offset);
			continue;
		} else if (f == XFUNC_insert) {
			/* add char to pattern */
			/* overflow check... */
			if ((size_t)(p - pat) >= sizeof(pat) - 1) {
				x_e_putc2(KSH_BEL);
				continue;
			}
			*p++ = c, *p = '\0';
			if (offset >= 0) {
				/* already have partial match */
				offset = x_match(xbuf, pat);
				if (offset >= 0) {
					x_goto(xbuf + offset + (p - pat) -
					    (*pat == '^'));
					continue;
				}
			}
			offset = x_search(pat, 0, offset);
		} else if (f == XFUNC_abort) {
			if (offset >= 0)
				x_load_hist(histptr + 1);
			break;
		} else {
			/* other command */
			x_e_ungetc(c);
			break;
		}
	}
	if (offset < 0)
		x_redraw('\n');
	return (KSTD);
}

/* search backward from current line */
static int
x_search(char *pat, int sameline, int offset)
{
	char **hp;
	int i;

	for (hp = x_histp - (sameline ? 0 : 1); hp >= history; --hp) {
		i = x_match(*hp, pat);
		if (i >= 0) {
			if (offset < 0)
				x_e_putc2('\n');
			x_load_hist(hp);
			x_goto(xbuf + i + strlen(pat) - (*pat == '^'));
			return (i);
		}
	}
	x_e_putc2(KSH_BEL);
	x_histp = histptr;
	return (-1);
}

#ifndef MKSH_SMALL
/* anchored search up from current line */
static int
x_search_hist_up(int c MKSH_A_UNUSED)
{
	return (x_search_dir(-1));
}

/* anchored search down from current line */
static int
x_search_hist_dn(int c MKSH_A_UNUSED)
{
	return (x_search_dir(1));
}

/* anchored search in the indicated direction */
static int
x_search_dir(int search_dir /* should've been bool */)
{
	char **hp = x_histp + search_dir;
	size_t curs = xcp - xbuf;

	while (histptr >= hp && hp >= history) {
		if (strncmp(xbuf, *hp, curs) == 0) {
			x_load_hist(hp);
			x_goto(xbuf + curs);
			break;
		}
		hp += search_dir;
	}
	return (KSTD);
}
#endif

/* return position of first match of pattern in string, else -1 */
static int
x_match(char *str, char *pat)
{
	if (*pat == '^') {
		return ((strncmp(str, pat + 1, strlen(pat + 1)) == 0) ? 0 : -1);
	} else {
		char *q = strstr(str, pat);
		return ((q == NULL) ? -1 : q - str);
	}
}

static int
x_del_line(int c MKSH_A_UNUSED)
{
	*xep = 0;
	x_push(xep - (xcp = xbuf));
	xlp = xbp = xep = xbuf;
	xlp_valid = true;
	*xcp = 0;
	xmp = NULL;
	x_redraw('\r');
	x_modified();
	return (KSTD);
}

static int
x_mv_end(int c MKSH_A_UNUSED)
{
	x_goto(xep);
	return (KSTD);
}

static int
x_mv_beg(int c MKSH_A_UNUSED)
{
	x_goto(xbuf);
	return (KSTD);
}

static int
x_draw_line(int c MKSH_A_UNUSED)
{
	x_redraw('\n');
	return (KSTD);
}

static int
x_cls(int c MKSH_A_UNUSED)
{
	shf_puts(MKSH_CLS_STRING, shl_out);
	x_redraw(0);
	return (KSTD);
}

/*
 * clear line from x_col (current cursor position) to xx_cols - 2,
 * then output lastch, then go back to x_col; if lastch is space,
 * clear with termcap instead of spaces, or not if line_was_cleared;
 * lastch MUST be an ASCII character with wcwidth(lastch) == 1
 */
static void
x_clrtoeol(int lastch, bool line_was_cleared)
{
	int col;

	if (lastch == ' ' && !line_was_cleared && x_term_mode == 1) {
		shf_puts(KSH_ESC_STRING "[K", shl_out);
		line_was_cleared = true;
	}
	if (lastch == ' ' && line_was_cleared)
		return;

	col = x_col;
	while (col < (xx_cols - 2)) {
		x_putc(' ');
		++col;
	}
	x_putc(lastch);
	++col;
	while (col > x_col) {
		x_putc('\b');
		--col;
	}
}

/* output the prompt, assuming a line has just been started */
static void
x_pprompt(void)
{
	if (prompt_trunc != -1)
		pprompt(prompt, prompt_trunc);
	x_col = pwidth;
}

/* output CR, then redraw the line, clearing to EOL if needed (cr ≠ 0, LF) */
static void
x_redraw(int cr)
{
	int lch;

	x_adj_ok = false;
	/* clear the line */
	x_e_putc2(cr ? cr : '\r');
	x_flush();
	/* display the prompt */
	if (xbp == xbuf)
		x_pprompt();
	x_displen = xx_cols - 2 - x_col;
	/* display the line content */
	xlp_valid = false;
	x_zots(xbp);
	/* check whether there is more off-screen */
	lch = xep > xlp ? (xbp > xbuf ? '*' : '>') : (xbp > xbuf) ? '<' : ' ';
	/* clear the rest of the line */
	x_clrtoeol(lch, !cr || cr == '\n');
	/* go back to actual cursor position */
	x_lastpos();
	x_adj_ok = true;
}

static int
x_transpose(int c MKSH_A_UNUSED)
{
	unsigned int tmpa, tmpb;

	/*-
	 * What transpose is meant to do seems to be up for debate. This
	 * is a general summary of the options; the text is abcd with the
	 * upper case character or underscore indicating the cursor position:
	 *	Who			Before	After	Before	After
	 *	AT&T ksh in emacs mode:	abCd	abdC	abcd_	(bell)
	 *	AT&T ksh in gmacs mode:	abCd	baCd	abcd_	abdc_
	 *	gnu emacs:		abCd	acbD	abcd_	abdc_
	 * Pdksh currently goes with GNU behavior since I believe this is the
	 * most common version of emacs, unless in gmacs mode, in which case
	 * it does the AT&T ksh gmacs mode.
	 * This should really be broken up into 3 functions so users can bind
	 * to the one they want.
	 */
	if (xcp == xbuf) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	} else if (xcp == xep || Flag(FGMACS)) {
		if (xcp - xbuf == 1) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		/*
		 * Gosling/Unipress emacs style: Swap two characters before
		 * the cursor, do not change cursor position
		 */
		x_bs3(&xcp);
		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		x_bs3(&xcp);
		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		utf_wctomb(xcp, tmpa);
		x_zotc3(&xcp);
		utf_wctomb(xcp, tmpb);
		x_zotc3(&xcp);
	} else {
		/*
		 * GNU emacs style: Swap the characters before and under the
		 * cursor, move cursor position along one.
		 */
		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		x_bs3(&xcp);
		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		utf_wctomb(xcp, tmpa);
		x_zotc3(&xcp);
		utf_wctomb(xcp, tmpb);
		x_zotc3(&xcp);
	}
	x_modified();
	return (KSTD);
}

static int
x_literal(int c MKSH_A_UNUSED)
{
	x_curprefix = -1;
	return (KSTD);
}

static int
x_meta1(int c MKSH_A_UNUSED)
{
	x_curprefix = 1;
	return (KSTD);
}

static int
x_meta2(int c MKSH_A_UNUSED)
{
	x_curprefix = 2;
	return (KSTD);
}

static int
x_meta3(int c MKSH_A_UNUSED)
{
	x_curprefix = 3;
	return (KSTD);
}

static int
x_kill(int c MKSH_A_UNUSED)
{
	size_t col = xcp - xbuf;
	size_t lastcol = xep - xbuf;
	size_t ndel, narg;

	if (x_arg_defaulted || (narg = x_arg) > lastcol)
		narg = lastcol;
	if (narg < col) {
		x_goto(xbuf + narg);
		ndel = col - narg;
	} else
		ndel = narg - col;
	x_delete(x_nb2nc(ndel), true);
	return (KSTD);
}

static void
x_push(size_t nchars)
{
	afree(killstack[killsp], AEDIT);
	strndupx(killstack[killsp], xcp, nchars, AEDIT);
	killsp = (killsp + 1) % KILLSIZE;
}

static int
x_yank(int c MKSH_A_UNUSED)
{
	if (killsp == 0)
		killtp = KILLSIZE;
	else
		killtp = killsp;
	killtp--;
	if (killstack[killtp] == 0) {
		x_e_puts("\nnothing to yank");
		x_redraw('\n');
		return (KSTD);
	}
	xmp = xcp;
	x_ins(killstack[killtp]);
	return (KSTD);
}

static int
x_meta_yank(int c MKSH_A_UNUSED)
{
	size_t len;

	if ((x_last_command != XFUNC_yank && x_last_command != XFUNC_meta_yank) ||
	    killstack[killtp] == 0) {
		killtp = killsp;
		x_e_puts("\nyank something first");
		x_redraw('\n');
		return (KSTD);
	}
	len = strlen(killstack[killtp]);
	x_goto(xcp - len);
	x_delete(x_nb2nc(len), false);
	do {
		if (killtp == 0)
			killtp = KILLSIZE - 1;
		else
			killtp--;
	} while (killstack[killtp] == 0);
	x_ins(killstack[killtp]);
	return (KSTD);
}

/* fake receiving an interrupt */
static void
x_intr(int signo, int c)
{
	x_vi_zotc(c);
	*xep = '\0';
	strip_nuls(xbuf, xep - xbuf);
	if (*xbuf)
		histsave(&source->line, xbuf, HIST_STORE, true);
	xlp = xep = xcp = xbp = xbuf;
	xlp_valid = true;
	*xcp = 0;
	x_modified();
	x_flush();
	trapsig(signo);
	x_mode(false);
	unwind(LSHELL);
}

static int
x_abort(int c MKSH_A_UNUSED)
{
	return (KINTR);
}

static int
x_error(int c MKSH_A_UNUSED)
{
	x_e_putc2(KSH_BEL);
	return (KSTD);
}

#ifndef MKSH_SMALL
/* special VT100 style key sequence hack */
static int
x_vt_hack(int c)
{
	/* we only support PF2-'1' for now */
	if (c != (2 << 8 | '1'))
		return (x_error(c));

	/* what's the next character? */
	switch ((c = x_e_getc())) {
	case '~':
		x_arg = 1;
		x_arg_defaulted = true;
		return (x_mv_beg(0));
	case ';':
		/* "interesting" sequence detected */
		break;
	default:
		goto unwind_err;
	}

	/* XXX x_e_ungetc is one-octet only */
	if ((c = x_e_getc()) != '5' && c != '3')
		goto unwind_err;

	/*-
	 * At this point, we have read the following octets so far:
	 * - ESC+[ or ESC+O or Ctrl-X (Prefix 2)
	 * - 1 (vt_hack)
	 * - ;
	 * - 5 (Ctrl key combiner) or 3 (Alt key combiner)
	 * We can now accept one more octet designating the key.
	 */

	switch ((c = x_e_getc())) {
	case 'C':
		return (x_mv_fword(c));
	case 'D':
		return (x_mv_bword(c));
	}

 unwind_err:
	x_e_ungetc(c);
	return (x_error(c));
}
#endif

static char *
x_mapin(const char *cp, Area *ap)
{
	char *news, *op;

	strdupx(news, cp, ap);
	op = news;
	while (*cp) {
		switch (*cp) {
		case '^':
			cp++;
			*op++ = ksh_toctrl(*cp);
			break;
		case '\\':
			if (cp[1] == '\\' || cp[1] == '^')
				++cp;
			/* FALLTHROUGH */
		default:
			*op++ = *cp;
		}
		cp++;
	}
	*op = '\0';

	return (news);
}

static void
x_mapout2(int c, char **buf)
{
	char *p = *buf;

	if (ksh_isctrl(c)) {
		*p++ = '^';
		*p++ = ksh_unctrl(c);
	} else
		*p++ = c;
	*p = 0;
	*buf = p;
}

static char *
x_mapout(int c)
{
	static char buf[8];
	char *bp = buf;

	x_mapout2(c, &bp);
	return (buf);
}

static void
x_print(int prefix, int key)
{
	int f = x_tab[prefix][key];

	if (prefix)
		/* prefix == 1 || prefix == 2 || prefix == 3 */
		shf_puts(x_mapout(prefix == 1 ? CTRL_BO :
		    prefix == 2 ? CTRL_X : 0), shl_stdout);
#ifdef MKSH_SMALL
	shprintf("%s = ", x_mapout(key));
#else
	shprintf("%s%s = ", x_mapout(key), (f & 0x80) ? "~" : "");
	if (XFUNC_VALUE(f) != XFUNC_ins_string)
#endif
		shprintf(Tf_sN, x_ftab[XFUNC_VALUE(f)].xf_name);
#ifndef MKSH_SMALL
	else
		shprintf("'%s'\n", x_atab[prefix][key]);
#endif
}

int
x_bind(const char *a1, const char *a2,
#ifndef MKSH_SMALL
    /* bind -m */
    bool macro,
#endif
    /* bind -l */
    bool list)
{
	unsigned char f;
	int prefix, key;
	char *m1, *m2;
#ifndef MKSH_SMALL
	char *sp = NULL;
	bool hastilde;
#endif

	if (x_tab == NULL) {
		bi_errorf("can't bind, not a tty");
		return (1);
	}
	/* List function names */
	if (list) {
		for (f = 0; f < NELEM(x_ftab); f++)
			if (!(x_ftab[f].xf_flags & XF_NOBIND))
				shprintf(Tf_sN, x_ftab[f].xf_name);
		return (0);
	}
	if (a1 == NULL) {
		for (prefix = 0; prefix < X_NTABS; prefix++)
			for (key = 0; key < X_TABSZ; key++) {
				f = XFUNC_VALUE(x_tab[prefix][key]);
				if (f == XFUNC_insert || f == XFUNC_error
#ifndef MKSH_SMALL
				    || (macro && f != XFUNC_ins_string)
#endif
				    )
					continue;
				x_print(prefix, key);
			}
		return (0);
	}
	m2 = m1 = x_mapin(a1, ATEMP);
	prefix = 0;
	for (;; m1++) {
		key = (unsigned char)*m1;
		f = XFUNC_VALUE(x_tab[prefix][key]);
		if (f == XFUNC_meta1)
			prefix = 1;
		else if (f == XFUNC_meta2)
			prefix = 2;
		else if (f == XFUNC_meta3)
			prefix = 3;
		else
			break;
	}
	if (*++m1
#ifndef MKSH_SMALL
	    && ((*m1 != '~') || *(m1 + 1))
#endif
	    ) {
		char msg[256];
		const char *c = a1;
		m1 = msg;
		while (*c && (size_t)(m1 - msg) < sizeof(msg) - 3)
			x_mapout2(*c++, &m1);
		bi_errorf("too long key sequence: %s", msg);
		return (1);
	}
#ifndef MKSH_SMALL
	hastilde = tobool(*m1);
#endif
	afree(m2, ATEMP);

	if (a2 == NULL) {
		x_print(prefix, key);
		return (0);
	}
	if (*a2 == 0) {
		f = XFUNC_insert;
#ifndef MKSH_SMALL
	} else if (macro) {
		f = XFUNC_ins_string;
		sp = x_mapin(a2, AEDIT);
#endif
	} else {
		for (f = 0; f < NELEM(x_ftab); f++)
			if (!strcmp(x_ftab[f].xf_name, a2))
				break;
		if (f == NELEM(x_ftab) || x_ftab[f].xf_flags & XF_NOBIND) {
			bi_errorf("%s: no such function", a2);
			return (1);
		}
	}

#ifndef MKSH_SMALL
	if (XFUNC_VALUE(x_tab[prefix][key]) == XFUNC_ins_string &&
	    x_atab[prefix][key])
		afree(x_atab[prefix][key], AEDIT);
#endif
	x_tab[prefix][key] = f
#ifndef MKSH_SMALL
	    | (hastilde ? 0x80 : 0)
#endif
	    ;
#ifndef MKSH_SMALL
	x_atab[prefix][key] = sp;
#endif

	/* Track what the user has bound so x_mode(true) won't toast things */
	if (f == XFUNC_insert)
		x_bound[(prefix * X_TABSZ + key) / 8] &=
		    ~(1 << ((prefix * X_TABSZ + key) % 8));
	else
		x_bound[(prefix * X_TABSZ + key) / 8] |=
		    (1 << ((prefix * X_TABSZ + key) % 8));

	return (0);
}

static void
bind_if_not_bound(int p, int k, int func)
{
	int t;

	/*
	 * Has user already bound this key?
	 * If so, do not override it.
	 */
	t = p * X_TABSZ + k;
	if (x_bound[t >> 3] & (1 << (t & 7)))
		return;

	x_tab[p][k] = func;
}

static int
x_set_mark(int c MKSH_A_UNUSED)
{
	xmp = xcp;
	return (KSTD);
}

static int
x_kill_region(int c MKSH_A_UNUSED)
{
	size_t rsize;
	char *xr;

	if (xmp == NULL) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	if (xmp > xcp) {
		rsize = xmp - xcp;
		xr = xcp;
	} else {
		rsize = xcp - xmp;
		xr = xmp;
	}
	x_goto(xr);
	x_delete(x_nb2nc(rsize), true);
	xmp = xr;
	return (KSTD);
}

static int
x_xchg_point_mark(int c MKSH_A_UNUSED)
{
	char *tmp;

	if (xmp == NULL) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	tmp = xmp;
	xmp = xcp;
	x_goto(tmp);
	return (KSTD);
}

static int
x_noop(int c MKSH_A_UNUSED)
{
	return (KSTD);
}

/*
 *	File/command name completion routines
 */
static int
x_comp_comm(int c MKSH_A_UNUSED)
{
	do_complete(XCF_COMMAND, CT_COMPLETE);
	return (KSTD);
}

static int
x_list_comm(int c MKSH_A_UNUSED)
{
	do_complete(XCF_COMMAND, CT_LIST);
	return (KSTD);
}

static int
x_complete(int c MKSH_A_UNUSED)
{
	do_complete(XCF_COMMAND_FILE, CT_COMPLETE);
	return (KSTD);
}

static int
x_enumerate(int c MKSH_A_UNUSED)
{
	do_complete(XCF_COMMAND_FILE, CT_LIST);
	return (KSTD);
}

static int
x_comp_file(int c MKSH_A_UNUSED)
{
	do_complete(XCF_FILE, CT_COMPLETE);
	return (KSTD);
}

static int
x_list_file(int c MKSH_A_UNUSED)
{
	do_complete(XCF_FILE, CT_LIST);
	return (KSTD);
}

static int
x_comp_list(int c MKSH_A_UNUSED)
{
	do_complete(XCF_COMMAND_FILE, CT_COMPLIST);
	return (KSTD);
}

static int
x_expand(int c MKSH_A_UNUSED)
{
	char **words;
	int start, end, nwords, i;

	i = XCF_FILE;
	nwords = x_cf_glob(&i, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words);

	if (nwords == 0) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	x_goto(xbuf + start);
	x_delete(x_nb2nc(end - start), false);

	i = 0;
	while (i < nwords) {
		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
		    (++i < nwords && x_ins(T1space) < 0)) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
	}
	x_adjust();

	return (KSTD);
}

static void
do_complete(
    /* XCF_{COMMAND,FILE,COMMAND_FILE} */
    int flags,
    /* 0 for list, 1 for complete and 2 for complete-list */
    Comp_type type)
{
	char **words;
	int start, end, nlen, olen, nwords;
	bool completed;

	nwords = x_cf_glob(&flags, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words);
	/* no match */
	if (nwords == 0) {
		x_e_putc2(KSH_BEL);
		return;
	}
	if (type == CT_LIST) {
		x_print_expansions(nwords, words,
		    tobool(flags & XCF_IS_COMMAND));
		x_redraw(0);
		x_free_words(nwords, words);
		return;
	}
	olen = end - start;
	nlen = x_longest_prefix(nwords, words);
	if (nwords == 1) {
		/*
		 * always complete single matches;
		 * any expansion of parameter substitution
		 * is always at most one result, too
		 */
		completed = true;
	} else {
		char *unescaped;

		/* make a copy of the original string part */
		strndupx(unescaped, xbuf + start, olen, ATEMP);

		/* expand any tilde and unescape the string for comparison */
		unescaped = x_glob_hlp_tilde_and_rem_qchar(unescaped, true);

		/*
		 * match iff entire original string is part of the
		 * longest prefix, implying the latter is at least
		 * the same size (after unescaping)
		 */
		completed = !strncmp(words[0], unescaped, strlen(unescaped));

		afree(unescaped, ATEMP);
	}
	if (type == CT_COMPLIST && nwords > 1) {
		/*
		 * print expansions, since we didn't get back
		 * just a single match
		 */
		x_print_expansions(nwords, words,
		    tobool(flags & XCF_IS_COMMAND));
	}
	if (completed) {
		/* expand on the command line */
		xmp = NULL;
		xcp = xbuf + start;
		xep -= olen;
		memmove(xcp, xcp + olen, xep - xcp + 1);
		x_escape(words[0], nlen, x_do_ins);
	}
	x_adjust();
	/*
	 * append a space if this is a single non-directory match
	 * and not a parameter or homedir substitution
	 */
	if (nwords == 1 && !mksh_cdirsep(words[0][nlen - 1]) &&
	    !(flags & XCF_IS_NOSPACE)) {
		x_ins(T1space);
	}

	x_free_words(nwords, words);
}

/*-
 * NAME:
 *	x_adjust - redraw the line adjusting starting point etc.
 *
 * DESCRIPTION:
 *	This function is called when we have exceeded the bounds
 *	of the edit window. It increments x_adj_done so that
 *	functions like x_ins and x_delete know that we have been
 *	called and can skip the x_bs() stuff which has already
 *	been done by x_redraw.
 *
 * RETURN VALUE:
 *	None
 */
static void
x_adjust(void)
{
	int col_left, n;

	/* flag the fact that we were called */
	x_adj_done++;

	/*
	 * calculate the amount of columns we need to "go back"
	 * from xcp to set xbp to (but never < xbuf) to 2/3 of
	 * the display width; take care of pwidth though
	 */
	if ((col_left = xx_cols * 2 / 3) < MIN_EDIT_SPACE) {
		/*
		 * cowardly refuse to do anything
		 * if the available space is too small;
		 * fall back to dumb pdksh code
		 */
		if ((xbp = xcp - (x_displen / 2)) < xbuf)
			xbp = xbuf;
		/* elide UTF-8 fixup as penalty */
		goto x_adjust_out;
	}

	/* fix up xbp to just past a character end first */
	xbp = xcp >= xep ? xep : x_bs0(xcp, xbuf);
	/* walk backwards */
	while (xbp > xbuf && col_left > 0) {
		xbp = x_bs0(xbp - 1, xbuf);
		col_left -= (n = x_size2(xbp, NULL));
	}
	/* check if we hit the prompt */
	if (xbp == xbuf && xcp != xbuf && col_left >= 0 && col_left < pwidth) {
		/* so we did; force scrolling occurs */
		xbp += utf_ptradj(xbp);
	}

 x_adjust_out:
	xlp_valid = false;
	x_redraw('\r');
	x_flush();
}

static void
x_e_ungetc(int c)
{
	unget_char = c < 0 ? -1 : (c & 255);
}

static int
x_e_getc(void)
{
	int c;

	if (unget_char >= 0) {
		c = unget_char;
		unget_char = -1;
		return (c);
	}

#ifndef MKSH_SMALL
	if (macroptr) {
		if ((c = (unsigned char)*macroptr++))
			return (c);
		macroptr = NULL;
	}
#endif

	return (x_getc());
}

static void
x_e_putc2(int c)
{
	int width = 1;

	if (ctype(c, C_CR | C_LF))
		x_col = 0;
	if (x_col < xx_cols) {
#ifndef MKSH_EBCDIC
		if (UTFMODE && (c > 0x7F)) {
			char utf_tmp[3];
			size_t x;

			if (c < 0xA0)
				c = 0xFFFD;
			x = utf_wctomb(utf_tmp, c);
			x_putc(utf_tmp[0]);
			if (x > 1)
				x_putc(utf_tmp[1]);
			if (x > 2)
				x_putc(utf_tmp[2]);
			width = utf_wcwidth(c);
		} else
#endif
			x_putc(c);
		switch (c) {
		case KSH_BEL:
			break;
		case '\r':
		case '\n':
			break;
		case '\b':
			x_col--;
			break;
		default:
			x_col += width;
			break;
		}
	}
	if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
		x_adjust();
}

static void
x_e_putc3(const char **cp)
{
	int width = 1, c = **(const unsigned char **)cp;

	if (ctype(c, C_CR | C_LF))
		x_col = 0;
	if (x_col < xx_cols) {
		if (UTFMODE && (c > 0x7F)) {
			char *cp2;

			width = utf_widthadj(*cp, (const char **)&cp2);
			if (cp2 == *cp + 1) {
				(*cp)++;
#ifdef MKSH_EBCDIC
				x_putc(asc2rtt(0xEF));
				x_putc(asc2rtt(0xBF));
				x_putc(asc2rtt(0xBD));
#else
				shf_puts("\xEF\xBF\xBD", shl_out);
#endif
			} else
				while (*cp < cp2)
					x_putcf(*(*cp)++);
		} else {
			(*cp)++;
			x_putc(c);
		}
		switch (c) {
		case KSH_BEL:
			break;
		case '\r':
		case '\n':
			break;
		case '\b':
			x_col--;
			break;
		default:
			x_col += width;
			break;
		}
	}
	if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
		x_adjust();
}

static void
x_e_puts(const char *s)
{
	int adj = x_adj_done;

	while (*s && adj == x_adj_done)
		x_e_putc3(&s);
}

/*-
 * NAME:
 *	x_set_arg - set an arg value for next function
 *
 * DESCRIPTION:
 *	This is a simple implementation of M-[0-9].
 *
 * RETURN VALUE:
 *	KSTD
 */
static int
x_set_arg(int c)
{
	unsigned int n = 0;
	bool first = true;

	/* strip command prefix */
	c &= 255;
	while (c >= 0 && ctype(c, C_DIGIT)) {
		n = n * 10 + ksh_numdig(c);
		if (n > LINE)
			/* upper bound for repeat */
			goto x_set_arg_too_big;
		c = x_e_getc();
		first = false;
	}
	if (c < 0 || first) {
 x_set_arg_too_big:
		x_e_putc2(KSH_BEL);
		x_arg = 1;
		x_arg_defaulted = true;
	} else {
		x_e_ungetc(c);
		x_arg = n;
		x_arg_defaulted = false;
	}
	return (KSTD);
}

/* Comment or uncomment the current line. */
static int
x_comment(int c MKSH_A_UNUSED)
{
	ssize_t len = xep - xbuf;
	int ret = x_do_comment(xbuf, xend - xbuf, &len);

	if (ret < 0)
		x_e_putc2(KSH_BEL);
	else {
		x_modified();
		xep = xbuf + len;
		*xep = '\0';
		xcp = xbp = xbuf;
		x_redraw('\r');
		if (ret > 0)
			return (x_newline('\n'));
	}
	return (KSTD);
}

static int
x_version(int c MKSH_A_UNUSED)
{
	char *o_xbuf = xbuf, *o_xend = xend;
	char *o_xbp = xbp, *o_xep = xep, *o_xcp = xcp;
	char *v;

	strdupx(v, KSH_VERSION, ATEMP);

	xbuf = xbp = xcp = v;
	xend = xep = strnul(v);
	x_redraw('\r');
	x_flush();

	c = x_e_getc();
	xbuf = o_xbuf;
	xend = o_xend;
	xbp = o_xbp;
	xep = o_xep;
	xcp = o_xcp;
	x_redraw('\r');

	if (c < 0)
		return (KSTD);
	/* This is what AT&T ksh seems to do... Very bizarre */
	if (c != ' ')
		x_e_ungetc(c);

	afree(v, ATEMP);
	return (KSTD);
}

#ifndef MKSH_SMALL
static int
x_edit_line(int c MKSH_A_UNUSED)
{
	if (x_arg_defaulted) {
		if (xep == xbuf) {
			x_e_putc2(KSH_BEL);
			return (KSTD);
		}
		if (modified) {
			*xep = '\0';
			histsave(&source->line, xbuf, HIST_STORE, true);
			x_arg = 0;
		} else
			x_arg = source->line - (histptr - x_histp);
	}
	if (x_arg)
		shf_snprintf(xbuf, xend - xbuf, Tf_sd,
		    "fc -e ${VISUAL:-${EDITOR:-vi}} --", x_arg);
	else
		strlcpy(xbuf, "fc -e ${VISUAL:-${EDITOR:-vi}} --", xend - xbuf);
	xep = strnul(xbuf);
	return (x_newline('\n'));
}
#endif

/*-
 * NAME:
 *	x_prev_histword - recover word from prev command
 *
 * DESCRIPTION:
 *	This function recovers the last word from the previous
 *	command and inserts it into the current edit line. If a
 *	numeric arg is supplied then the n'th word from the
 *	start of the previous command is used.
 *	As a side effect, trashes the mark in order to achieve
 *	being called in a repeatable fashion.
 *
 *	Bound to M-.
 *
 * RETURN VALUE:
 *	KSTD
 */
static int
x_prev_histword(int c MKSH_A_UNUSED)
{
	char *rcp, *cp;
	char **xhp;
	int m = 1;
	/* -1 = defaulted; 0+ = argument */
	static int last_arg = -1;

	if (x_last_command == XFUNC_prev_histword) {
		if (xmp && modified > 1)
			x_kill_region(0);
		if (modified)
			m = modified;
	} else
		last_arg = x_arg_defaulted ? -1 : x_arg;
	xhp = histptr - (m - 1);
	if ((xhp < history) || !(cp = *xhp)) {
		x_e_putc2(KSH_BEL);
		x_modified();
		return (KSTD);
	}
	x_set_mark(0);
	if ((x_arg = last_arg) == -1) {
		/* x_arg_defaulted */

		rcp = &cp[strlen(cp) - 1];
		/*
		 * ignore white-space after the last word
		 */
		while (rcp > cp && ctype(*rcp, C_CFS))
			rcp--;
		while (rcp > cp && !ctype(*rcp, C_CFS))
			rcp--;
		if (ctype(*rcp, C_CFS))
			rcp++;
		x_ins(rcp);
	} else {
		/* not x_arg_defaulted */
		char ch;

		rcp = cp;
		/*
		 * ignore white-space at start of line
		 */
		while (*rcp && ctype(*rcp, C_CFS))
			rcp++;
		while (x_arg-- > 0) {
			while (*rcp && !ctype(*rcp, C_CFS))
				rcp++;
			while (*rcp && ctype(*rcp, C_CFS))
				rcp++;
		}
		cp = rcp;
		while (*rcp && !ctype(*rcp, C_CFS))
			rcp++;
		ch = *rcp;
		*rcp = '\0';
		x_ins(cp);
		*rcp = ch;
	}
	if (!modified)
		x_histmcp = x_histp;
	modified = m + 1;
	return (KSTD);
}

#ifndef MKSH_SMALL
/* Uppercase N(1) words */
static int
x_fold_upper(int c MKSH_A_UNUSED)
{
	return (x_fold_case('U'));
}

/* Lowercase N(1) words */
static int
x_fold_lower(int c MKSH_A_UNUSED)
{
	return (x_fold_case('L'));
}

/* Titlecase N(1) words */
static int
x_fold_capitalise(int c MKSH_A_UNUSED)
{
	return (x_fold_case('C'));
}

/*-
 * NAME:
 *	x_fold_case - convert word to UPPER/lower/Capital case
 *
 * DESCRIPTION:
 *	This function is used to implement M-U/M-u, M-L/M-l, M-C/M-c
 *	to UPPER CASE, lower case or Capitalise Words.
 *
 * RETURN VALUE:
 *	None
 */
static int
x_fold_case(int c)
{
	char *cp = xcp;

	if (cp == xep) {
		x_e_putc2(KSH_BEL);
		return (KSTD);
	}
	while (x_arg--) {
		/*
		 * first skip over any white-space
		 */
		while (cp != xep && ctype(*cp, C_MFS))
			cp++;
		/*
		 * do the first char on its own since it may be
		 * a different action than for the rest.
		 */
		if (cp != xep) {
			if (c == 'L')
				/* lowercase */
				*cp = ksh_tolower(*cp);
			else
				/* uppercase, capitalise */
				*cp = ksh_toupper(*cp);
			cp++;
		}
		/*
		 * now for the rest of the word
		 */
		while (cp != xep && !ctype(*cp, C_MFS)) {
			if (c == 'U')
				/* uppercase */
				*cp = ksh_toupper(*cp);
			else
				/* lowercase, capitalise */
				*cp = ksh_tolower(*cp);
			cp++;
		}
	}
	x_goto(cp);
	x_modified();
	return (KSTD);
}
#endif

/*-
 * NAME:
 *	x_lastcp - last visible char
 *
 * DESCRIPTION:
 *	This function returns a pointer to that char in the
 *	edit buffer that will be the last displayed on the
 *	screen.
 */
static char *
x_lastcp(void)
{
	if (!xlp_valid) {
		int i = 0, j;
		char *xlp2;

		xlp = xbp;
		while (xlp < xep) {
			j = x_size2(xlp, &xlp2);
			if ((i + j) > x_displen)
				break;
			i += j;
			xlp = xlp2;
		}
	}
	xlp_valid = true;
	return (xlp);
}

/* correctly position the cursor on the screen from end of visible area */
static void
x_lastpos(void)
{
	char *cp = x_lastcp();

	while (cp > xcp)
		x_bs3(&cp);
}

static void
x_mode(bool onoff)
{
	static bool x_cur_mode;

	if (x_cur_mode == onoff)
		return;
	x_cur_mode = onoff;

	if (onoff) {
		x_mkraw(tty_fd, NULL, false);

		edchars.erase = toedchar(tty_state.c_cc[VERASE]);
		edchars.kill = toedchar(tty_state.c_cc[VKILL]);
		edchars.intr = toedchar(tty_state.c_cc[VINTR]);
		edchars.quit = toedchar(tty_state.c_cc[VQUIT]);
		edchars.eof = toedchar(tty_state.c_cc[VEOF]);
#ifdef VWERASE
		edchars.werase = toedchar(tty_state.c_cc[VWERASE]);
#else
		edchars.werase = 0;
#endif

		if (!edchars.erase)
			edchars.erase = CTRL_H;
		if (!edchars.kill)
			edchars.kill = CTRL_U;
		if (!edchars.intr)
			edchars.intr = CTRL_C;
		if (!edchars.quit)
			edchars.quit = CTRL_BK;
		if (!edchars.eof)
			edchars.eof = CTRL_D;
		if (!edchars.werase)
			edchars.werase = CTRL_W;

		if (isedchar(edchars.erase)) {
			bind_if_not_bound(0, edchars.erase, XFUNC_del_back);
			bind_if_not_bound(1, edchars.erase, XFUNC_del_bword);
		}
		if (isedchar(edchars.kill))
			bind_if_not_bound(0, edchars.kill, XFUNC_del_line);
		if (isedchar(edchars.werase))
			bind_if_not_bound(0, edchars.werase, XFUNC_del_bword);
		if (isedchar(edchars.intr))
			bind_if_not_bound(0, edchars.intr, XFUNC_abort);
		if (isedchar(edchars.quit))
			bind_if_not_bound(0, edchars.quit, XFUNC_noop);
	} else
		mksh_tcset(tty_fd, &tty_state);
}

#if !MKSH_S_NOVI
/* +++ vi editing mode +++ */

struct edstate {
	char *cbuf;
	ssize_t winleft;
	ssize_t cbufsize;
	ssize_t linelen;
	ssize_t cursor;
};

static int vi_hook(int);
static int nextstate(int);
static int vi_insert(int);
static int vi_cmd(int, const char *);
static int domove(int, const char *, int);
static int domovebeg(void);
static int redo_insert(int);
static void yank_range(int, int);
static int bracktype(int);
static void save_cbuf(void);
static void restore_cbuf(void);
static int putbuf(const char *, ssize_t, bool);
static void del_range(int, int);
static int findch(int, int, bool, bool) MKSH_A_PURE;
static int forwword(int);
static int backword(int);
static int endword(int);
static int Forwword(int);
static int Backword(int);
static int Endword(int);
static int grabhist(int, int);
static int grabsearch(int, int, int, const char *);
static void redraw_line(bool);
static void refresh(int);
static int outofwin(void);
static void rewindow(void);
static int newcol(unsigned char, int);
static void display(char *, char *, int);
static void ed_mov_opt(int, char *);
static int expand_word(int);
static int complete_word(int, int);
static int print_expansions(struct edstate *, int);
static void vi_error(void);
static void vi_macro_reset(void);
static int x_vi_putbuf(const char *, size_t);
#define char_len(c) (ksh_isctrl(c) ? 2 : 1)

#define vC	0x01		/* a valid command that isn't a vM, vE, vU */
#define vM	0x02		/* movement command (h, l, etc.) */
#define vE	0x04		/* extended command (c, d, y) */
#define vX	0x08		/* long command (@@, f, F, t, T, etc.) */
#define vU	0x10		/* an UN-undoable command (that isn't a vM) */
#define vB	0x20		/* bad command (^@@) */
#define vZ	0x40		/* repeat count defaults to 0 (not 1) */
#define vS	0x80		/* search (/, ?) */

#define is_bad(c)	(classify[rtt2asc(c) & 0x7F] & vB)
#define is_cmd(c)	(classify[rtt2asc(c) & 0x7F] & (vM | vE | vC | vU))
#define is_move(c)	(classify[rtt2asc(c) & 0x7F] & vM)
#define is_extend(c)	(classify[rtt2asc(c) & 0x7F] & vE)
#define is_long(c)	(classify[rtt2asc(c) & 0x7F] & vX)
#define is_undoable(c)	(!(classify[rtt2asc(c) & 0x7F] & vU))
#define is_srch(c)	(classify[rtt2asc(c) & 0x7F] & vS)
#define is_zerocount(c)	(classify[rtt2asc(c) & 0x7F] & vZ)

static const unsigned char classify[128] = {
/*	 0	1	2	3	4	5	6	7	*/
/* 0	^@@	^A	^B	^C	^D	^E	^F	^G	*/
	vB,	0,	0,	0,	0,	vC|vU,	vC|vZ,	0,
/* 1	^H	^I	^J	^K	^L	^M	^N	^O	*/
	vM,	vC|vZ,	0,	0,	vC|vU,	0,	vC,	0,
/* 2	^P	^Q	^R	^S	^T	^U	^V	^W	*/
	vC,	0,	vC|vU,	0,	0,	0,	vC,	0,
/* 3	^X	^Y	^Z	^[	^\	^]	^^	^_	*/
	vC,	0,	0,	vC|vZ,	0,	0,	0,	0,
/* 4	<space>	!	"	#	$	%	&	'	*/
	vM,	0,	0,	vC,	vM,	vM,	0,	0,
/* 5	(	)	*	+	,	-	.	/	*/
	0,	0,	vC,	vC,	vM,	vC,	0,	vC|vS,
/* 6	0	1	2	3	4	5	6	7	*/
	vM,	0,	0,	0,	0,	0,	0,	0,
/* 7	8	9	:	;	<	=	>	?	*/
	0,	0,	0,	vM,	0,	vC,	0,	vC|vS,
/* 8	@@	A	B	C	D	E	F	G	*/
	vC|vX,	vC,	vM,	vC,	vC,	vM,	vM|vX,	vC|vU|vZ,
/* 9	H	I	J	K	L	M	N	O	*/
	0,	vC,	0,	0,	0,	0,	vC|vU,	vU,
/* A	P	Q	R	S	T	U	V	W	*/
	vC,	0,	vC,	vC,	vM|vX,	vC,	0,	vM,
/* B	X	Y	Z	[	\	]	^	_	*/
	vC,	vC|vU,	0,	vU,	vC|vZ,	0,	vM,	vC|vZ,
/* C	`	a	b	c	d	e	f	g	*/
	0,	vC,	vM,	vE,	vE,	vM,	vM|vX,	vC|vZ,
/* D	h	i	j	k	l	m	n	o	*/
	vM,	vC,	vC|vU,	vC|vU,	vM,	0,	vC|vU,	0,
/* E	p	q	r	s	t	u	v	w	*/
	vC,	0,	vX,	vC,	vM|vX,	vC|vU,	vC|vU|vZ, vM,
/* F	x	y	z	{	|	}	~	^?	*/
	vC,	vE|vU,	0,	0,	vM|vZ,	0,	vC,	0
};

#define MAXVICMD	3
#define SRCHLEN		40

#define INSERT		1
#define REPLACE		2

#define VNORMAL		0		/* command, insert or replace mode */
#define VARG1		1		/* digit prefix (first, eg, 5l) */
#define VEXTCMD		2		/* cmd + movement (eg, cl) */
#define VARG2		3		/* digit prefix (second, eg, 2c3l) */
#define VXCH		4		/* f, F, t, T, @@ */
#define VFAIL		5		/* bad command */
#define VCMD		6		/* single char command (eg, X) */
#define VREDO		7		/* . */
#define VLIT		8		/* ^V */
#define VSEARCH		9		/* /, ? */
#define VVERSION	10		/* <ESC> ^V */
#define VPREFIX2	11		/* ^[[ and ^[O in insert mode */

static struct edstate	*save_edstate(struct edstate *old);
static void		restore_edstate(struct edstate *old, struct edstate *news);
static void		free_edstate(struct edstate *old);

static struct edstate	ebuf;
static struct edstate	undobuf;

static struct edstate	*vs;		/* current Vi editing mode state */
static struct edstate	*undo;

static char *ibuf;			/* input buffer */
static bool first_insert;		/* set when starting in insert mode */
static int saved_inslen;		/* saved inslen for first insert */
static int inslen;			/* length of input buffer */
static int srchlen;			/* length of current search pattern */
static char *ybuf;			/* yank buffer */
static int yanklen;			/* length of yank buffer */
static int fsavecmd = ' ';		/* last find command */
static int fsavech;			/* character to find */
static char lastcmd[MAXVICMD];		/* last non-move command */
static int lastac;			/* argcnt for lastcmd */
static int lastsearch = ' ';		/* last search command */
static char srchpat[SRCHLEN];		/* last search pattern */
static int insert;			/* <>0 in insert mode */
static int hnum;			/* position in history */
static int ohnum;			/* history line copied (after mod) */
static int hlast;			/* 1 past last position in history */
static int state;

/*
 * Information for keeping track of macros that are being expanded.
 * The format of buf is the alias contents followed by a NUL byte followed
 * by the name (letter) of the alias. The end of the buffer is marked by
 * a double NUL. The name of the alias is stored so recursive macros can
 * be detected.
 */
struct macro_state {
	unsigned char *p;	/* current position in buf */
	unsigned char *buf;	/* pointer to macro(s) being expanded */
	size_t len;		/* how much data in buffer */
};
static struct macro_state macro;

/* last input was expanded */
static enum expand_mode {
	NONE = 0, EXPAND, COMPLETE, PRINT
} expanded;

static int
x_vi(char *buf)
{
	int c;

	state = VNORMAL;
	ohnum = hnum = hlast = histnum(-1) + 1;
	insert = INSERT;
	saved_inslen = inslen;
	first_insert = true;
	inslen = 0;
	vi_macro_reset();

	ebuf.cbuf = buf;
	if (undobuf.cbuf == NULL) {
		ibuf = alloc(LINE, AEDIT);
		ybuf = alloc(LINE, AEDIT);
		undobuf.cbuf = alloc(LINE, AEDIT);
	}
	undobuf.cbufsize = ebuf.cbufsize = LINE;
	undobuf.linelen = ebuf.linelen = 0;
	undobuf.cursor = ebuf.cursor = 0;
	undobuf.winleft = ebuf.winleft = 0;
	vs = &ebuf;
	undo = &undobuf;

	x_init_prompt(true);
	x_col = pwidth;

	if (wbuf_len != x_cols - 3 && ((wbuf_len = x_cols - 3))) {
		wbuf[0] = aresize(wbuf[0], wbuf_len, AEDIT);
		wbuf[1] = aresize(wbuf[1], wbuf_len, AEDIT);
	}
	if (wbuf_len) {
		memset(wbuf[0], ' ', wbuf_len);
		memset(wbuf[1], ' ', wbuf_len);
	}
	winwidth = x_cols - pwidth - 3;
	win = 0;
	morec = ' ';
	lastref = 1;
	holdlen = 0;

	editmode = 2;
	x_flush();
	while (/* CONSTCOND */ 1) {
		if (macro.p) {
			c = (unsigned char)*macro.p++;
			/* end of current macro? */
			if (!c) {
				/* more macros left to finish? */
				if (*macro.p++)
					continue;
				/* must be the end of all the macros */
				vi_macro_reset();
				c = x_getc();
			}
		} else
			c = x_getc();

		if (c == -1)
			break;
		if (state != VLIT) {
			if (isched(c, edchars.intr) ||
			    isched(c, edchars.quit)) {
				/* shove input buffer away */
				xbuf = ebuf.cbuf;
				xep = xbuf;
				if (ebuf.linelen > 0)
					xep += ebuf.linelen;
				/* pretend we got an interrupt */
				x_intr(isched(c, edchars.intr) ?
				    SIGINT : SIGQUIT, c);
			} else if (isched(c, edchars.eof) &&
			    state != VVERSION) {
				if (vs->linelen == 0) {
					x_vi_zotc(c);
					c = -1;
					break;
				}
				continue;
			}
		}
		if (vi_hook(c))
			break;
		x_flush();
	}

	x_putc('\r');
	x_putc('\n');
	x_flush();

	if (c == -1 || (ssize_t)LINE <= vs->linelen)
		return (-1);

	if (vs->cbuf != buf)
		memcpy(buf, vs->cbuf, vs->linelen);

	buf[vs->linelen++] = '\n';

	return (vs->linelen);
}

static int
vi_hook(int ch)
{
	static char curcmd[MAXVICMD], locpat[SRCHLEN];
	static int cmdlen, argc1, argc2;

	switch (state) {

	case VNORMAL:
		/* PC scancodes */
		if (!ch) {
			cmdlen = 0;
			switch (ch = x_getc()) {
			case 71: ch = '0'; goto pseudo_vi_command;
			case 72: ch = 'k'; goto pseudo_vi_command;
			case 73: ch = 'A'; goto vi_xfunc_search_up;
			case 75: ch = 'h'; goto pseudo_vi_command;
			case 77: ch = 'l'; goto pseudo_vi_command;
			case 79: ch = '$'; goto pseudo_vi_command;
			case 80: ch = 'j'; goto pseudo_vi_command;
			case 83: ch = 'x'; goto pseudo_vi_command;
			default: ch = 0; goto vi_insert_failed;
			}
		}
		if (insert != 0) {
			if (ch == CTRL_V) {
				state = VLIT;
				ch = '^';
			}
			switch (vi_insert(ch)) {
			case -1:
 vi_insert_failed:
				vi_error();
				state = VNORMAL;
				break;
			case 0:
				if (state == VLIT) {
					vs->cursor--;
					refresh(0);
				} else
					refresh(insert != 0);
				break;
			case 1:
				return (1);
			}
		} else {
			if (ctype(ch, C_CR | C_LF))
				return (1);
			cmdlen = 0;
			argc1 = 0;
			if (ctype(ch, C_DIGIT) && ord(ch) != ORD('0')) {
				argc1 = ksh_numdig(ch);
				state = VARG1;
			} else {
 pseudo_vi_command:
				curcmd[cmdlen++] = ch;
				state = nextstate(ch);
				if (state == VSEARCH) {
					save_cbuf();
					vs->cursor = 0;
					vs->linelen = 0;
					if (putbuf(ch == '/' ? "/" : "?", 1,
					    false) != 0)
						return (-1);
					refresh(0);
				}
				if (state == VVERSION) {
					save_cbuf();
					vs->cursor = 0;
					vs->linelen = 0;
					putbuf(KSH_VERSION,
					    strlen(KSH_VERSION), false);
					refresh(0);
				}
			}
		}
		break;

	case VLIT:
		if (is_bad(ch)) {
			del_range(vs->cursor, vs->cursor + 1);
			vi_error();
		} else
			vs->cbuf[vs->cursor++] = ch;
		refresh(1);
		state = VNORMAL;
		break;

	case VVERSION:
		restore_cbuf();
		state = VNORMAL;
		refresh(0);
		break;

	case VARG1:
		if (ctype(ch, C_DIGIT))
			argc1 = argc1 * 10 + ksh_numdig(ch);
		else {
			curcmd[cmdlen++] = ch;
			state = nextstate(ch);
		}
		break;

	case VEXTCMD:
		argc2 = 0;
		if (ctype(ch, C_DIGIT) && ord(ch) != ORD('0')) {
			argc2 = ksh_numdig(ch);
			state = VARG2;
			return (0);
		} else {
			curcmd[cmdlen++] = ch;
			if (ch == curcmd[0])
				state = VCMD;
			else if (is_move(ch))
				state = nextstate(ch);
			else
				state = VFAIL;
		}
		break;

	case VARG2:
		if (ctype(ch, C_DIGIT))
			argc2 = argc2 * 10 + ksh_numdig(ch);
		else {
			if (argc1 == 0)
				argc1 = argc2;
			else
				argc1 *= argc2;
			curcmd[cmdlen++] = ch;
			if (ch == curcmd[0])
				state = VCMD;
			else if (is_move(ch))
				state = nextstate(ch);
			else
				state = VFAIL;
		}
		break;

	case VXCH:
		if (ch == CTRL_BO)
			state = VNORMAL;
		else {
			curcmd[cmdlen++] = ch;
			state = VCMD;
		}
		break;

	case VSEARCH:
		if (ctype(ch, C_CR | C_LF) /* || ch == CTRL_BO */ ) {
			restore_cbuf();
			/* Repeat last search? */
			if (srchlen == 0) {
				if (!srchpat[0]) {
					vi_error();
					state = VNORMAL;
					refresh(0);
					return (0);
				}
			} else {
				locpat[srchlen] = '\0';
				memcpy(srchpat, locpat, srchlen + 1);
			}
			state = VCMD;
		} else if (isched(ch, edchars.erase) || ch == CTRL_H) {
			if (srchlen != 0) {
				srchlen--;
				vs->linelen -= char_len(locpat[srchlen]);
				vs->cursor = vs->linelen;
				refresh(0);
				return (0);
			}
			restore_cbuf();
			state = VNORMAL;
			refresh(0);
		} else if (isched(ch, edchars.kill)) {
			srchlen = 0;
			vs->linelen = 1;
			vs->cursor = 1;
			refresh(0);
			return (0);
		} else if (isched(ch, edchars.werase)) {
			unsigned int i, n;
			struct edstate new_es, *save_es;

			new_es.cursor = srchlen;
			new_es.cbuf = locpat;

			save_es = vs;
			vs = &new_es;
			n = backword(1);
			vs = save_es;

			i = (unsigned)srchlen;
			while (i-- > n)
				vs->linelen -= char_len(locpat[i]);
			srchlen = (int)n;
			vs->cursor = vs->linelen;
			refresh(0);
			return (0);
		} else {
			if (srchlen == SRCHLEN - 1)
				vi_error();
			else {
				locpat[srchlen++] = ch;
				if (ksh_isctrl(ch)) {
					if ((size_t)vs->linelen + 2 >
					    (size_t)vs->cbufsize)
						vi_error();
					vs->cbuf[vs->linelen++] = '^';
					vs->cbuf[vs->linelen++] = ksh_unctrl(ch);
				} else {
					if (vs->linelen >= vs->cbufsize)
						vi_error();
					vs->cbuf[vs->linelen++] = ch;
				}
				vs->cursor = vs->linelen;
				refresh(0);
			}
			return (0);
		}
		break;

	case VPREFIX2:
 vi_xfunc_search_up:
		state = VFAIL;
		switch (ch) {
		case 'A':
			/* the cursor may not be at the BOL */
			if (!vs->cursor)
				break;
			/* nor further in the line than we can search for */
			if ((size_t)vs->cursor >= sizeof(srchpat) - 1)
				vs->cursor = sizeof(srchpat) - 2;
			/* anchor the search pattern */
			srchpat[0] = '^';
			/* take the current line up to the cursor */
			memmove(srchpat + 1, vs->cbuf, vs->cursor);
			srchpat[vs->cursor + 1] = '\0';
			/* set a magic flag */
			argc1 = 2 + (int)vs->cursor;
			/* and emulate a backwards history search */
			lastsearch = '/';
			*curcmd = 'n';
			goto pseudo_VCMD;
		}
		break;
	}

	switch (state) {
	case VCMD:
 pseudo_VCMD:
		state = VNORMAL;
		switch (vi_cmd(argc1, curcmd)) {
		case -1:
			vi_error();
			refresh(0);
			break;
		case 0:
			if (insert != 0)
				inslen = 0;
			refresh(insert != 0);
			break;
		case 1:
			refresh(0);
			return (1);
		case 2:
			/* back from a 'v' command - don't redraw the screen */
			return (1);
		}
		break;

	case VREDO:
		state = VNORMAL;
		if (argc1 != 0)
			lastac = argc1;
		switch (vi_cmd(lastac, lastcmd)) {
		case -1:
			vi_error();
			refresh(0);
			break;
		case 0:
			if (insert != 0) {
				if (lastcmd[0] == 's' ||
				    ksh_eq(lastcmd[0], 'C', 'c')) {
					if (redo_insert(1) != 0)
						vi_error();
				} else {
					if (redo_insert(lastac) != 0)
						vi_error();
				}
			}
			refresh(0);
			break;
		case 1:
			refresh(0);
			return (1);
		case 2:
			/* back from a 'v' command - can't happen */
			break;
		}
		break;

	case VFAIL:
		state = VNORMAL;
		vi_error();
		break;
	}
	return (0);
}

static int
nextstate(int ch)
{
	if (is_extend(ch))
		return (VEXTCMD);
	else if (is_srch(ch))
		return (VSEARCH);
	else if (is_long(ch))
		return (VXCH);
	else if (ch == '.')
		return (VREDO);
	else if (ch == CTRL_V)
		return (VVERSION);
	else if (is_cmd(ch))
		return (VCMD);
	else
		return (VFAIL);
}

static int
vi_insert(int ch)
{
	int tcursor;

	if (isched(ch, edchars.erase) || ch == CTRL_H) {
		if (insert == REPLACE) {
			if (vs->cursor == undo->cursor) {
				vi_error();
				return (0);
			}
			if (inslen > 0)
				inslen--;
			vs->cursor--;
			if (vs->cursor >= undo->linelen)
				vs->linelen--;
			else
				vs->cbuf[vs->cursor] = undo->cbuf[vs->cursor];
		} else {
			if (vs->cursor == 0)
				return (0);
			if (inslen > 0)
				inslen--;
			vs->cursor--;
			vs->linelen--;
			memmove(&vs->cbuf[vs->cursor], &vs->cbuf[vs->cursor + 1],
			    vs->linelen - vs->cursor + 1);
		}
		expanded = NONE;
		return (0);
	}
	if (isched(ch, edchars.kill)) {
		if (vs->cursor != 0) {
			inslen = 0;
			memmove(vs->cbuf, &vs->cbuf[vs->cursor],
			    vs->linelen - vs->cursor);
			vs->linelen -= vs->cursor;
			vs->cursor = 0;
		}
		expanded = NONE;
		return (0);
	}
	if (isched(ch, edchars.werase)) {
		if (vs->cursor != 0) {
			tcursor = backword(1);
			memmove(&vs->cbuf[tcursor], &vs->cbuf[vs->cursor],
			    vs->linelen - vs->cursor);
			vs->linelen -= vs->cursor - tcursor;
			if (inslen < vs->cursor - tcursor)
				inslen = 0;
			else
				inslen -= vs->cursor - tcursor;
			vs->cursor = tcursor;
		}
		expanded = NONE;
		return (0);
	}
	/*
	 * If any chars are entered before escape, trash the saved insert
	 * buffer (if user inserts & deletes char, ibuf gets trashed and
	 * we don't want to use it)
	 */
	if (first_insert && ch != CTRL_BO)
		saved_inslen = 0;
	switch (ch) {
	case '\0':
		return (-1);

	case '\r':
	case '\n':
		return (1);

	case CTRL_BO:
		expanded = NONE;
		if (first_insert) {
			first_insert = false;
			if (inslen == 0) {
				inslen = saved_inslen;
				return (redo_insert(0));
			}
			lastcmd[0] = 'a';
			lastac = 1;
		}
		if (lastcmd[0] == 's' || ksh_eq(lastcmd[0], 'C', 'c'))
			return (redo_insert(0));
		else
			return (redo_insert(lastac - 1));

	/* { start nonstandard vi commands */
	case CTRL_X:
		expand_word(0);
		break;

	case CTRL_F:
		complete_word(0, 0);
		break;

	case CTRL_E:
		print_expansions(vs, 0);
		break;

	case CTRL_I:
		if (Flag(FVITABCOMPLETE)) {
			complete_word(0, 0);
			break;
		}
		/* FALLTHROUGH */
	/* end nonstandard vi commands } */

	default:
		if (vs->linelen >= vs->cbufsize - 1)
			return (-1);
		ibuf[inslen++] = ch;
		if (insert == INSERT) {
			memmove(&vs->cbuf[vs->cursor + 1], &vs->cbuf[vs->cursor],
			    vs->linelen - vs->cursor);
			vs->linelen++;
		}
		vs->cbuf[vs->cursor++] = ch;
		if (insert == REPLACE && vs->cursor > vs->linelen)
			vs->linelen++;
		expanded = NONE;
	}
	return (0);
}

static int
vi_cmd(int argcnt, const char *cmd)
{
	int ncursor;
	int cur, c1, c2, c3 = 0;
	int any;
	struct edstate *t;

	if (argcnt == 0 && !is_zerocount(*cmd))
		argcnt = 1;

	if (is_move(*cmd)) {
		if ((cur = domove(argcnt, cmd, 0)) >= 0) {
			if (cur == vs->linelen && cur != 0)
				cur--;
			vs->cursor = cur;
		} else
			return (-1);
	} else {
		/* Don't save state in middle of macro.. */
		if (is_undoable(*cmd) && !macro.p) {
			undo->winleft = vs->winleft;
			memmove(undo->cbuf, vs->cbuf, vs->linelen);
			undo->linelen = vs->linelen;
			undo->cursor = vs->cursor;
			lastac = argcnt;
			memmove(lastcmd, cmd, MAXVICMD);
		}
		switch (ord(*cmd)) {

		case CTRL_L:
		case CTRL_R:
			redraw_line(true);
			break;

		case ORD('@@'):
			{
				static char alias[] = "_\0";
				struct tbl *ap;
				size_t olen, nlen;
				char *p, *nbuf;

				/* lookup letter in alias list... */
				alias[1] = cmd[1];
				ap = ktsearch(&aliases, alias, hash(alias));
				if (!cmd[1] || !ap || !(ap->flag & ISSET))
					return (-1);
				/* check if this is a recursive call... */
				if ((p = (char *)macro.p))
					while ((p = strnul(p)) && p[1])
						if (*++p == cmd[1])
							return (-1);
				/* insert alias into macro buffer */
				nlen = strlen(ap->val.s) + 1;
				olen = !macro.p ? 2 :
				    macro.len - (macro.p - macro.buf);
				/*
				 * at this point, it's fairly reasonable that
				 * nlen + olen + 2 doesn't overflow
				 */
				nbuf = alloc(nlen + 1 + olen, AEDIT);
				memcpy(nbuf, ap->val.s, nlen);
				nbuf[nlen++] = cmd[1];
				if (macro.p) {
					memcpy(nbuf + nlen, macro.p, olen);
					afree(macro.buf, AEDIT);
					nlen += olen;
				} else {
					nbuf[nlen++] = '\0';
					nbuf[nlen++] = '\0';
				}
				macro.p = macro.buf = (unsigned char *)nbuf;
				macro.len = nlen;
			}
			break;

		case ORD('a'):
			modified = 1;
			hnum = hlast;
			if (vs->linelen != 0)
				vs->cursor++;
			insert = INSERT;
			break;

		case ORD('A'):
			modified = 1;
			hnum = hlast;
			del_range(0, 0);
			vs->cursor = vs->linelen;
			insert = INSERT;
			break;

		case ORD('S'):
			vs->cursor = domovebeg();
			del_range(vs->cursor, vs->linelen);
			modified = 1;
			hnum = hlast;
			insert = INSERT;
			break;

		case ORD('Y'):
			cmd = "y$";
			/* ahhhhhh... */

			/* FALLTHROUGH */
		case ORD('c'):
		case ORD('d'):
		case ORD('y'):
			if (*cmd == cmd[1]) {
				c1 = *cmd == 'c' ? domovebeg() : 0;
				c2 = vs->linelen;
			} else if (!is_move(cmd[1]))
				return (-1);
			else {
				if ((ncursor = domove(argcnt, &cmd[1], 1)) < 0)
					return (-1);
				if (*cmd == 'c' && ksh_eq(cmd[1], 'W', 'w') &&
				    !ctype(vs->cbuf[vs->cursor], C_SPACE)) {
					do {
						--ncursor;
					} while (ctype(vs->cbuf[ncursor], C_SPACE));
					ncursor++;
				}
				if (ncursor > vs->cursor) {
					c1 = vs->cursor;
					c2 = ncursor;
				} else {
					c1 = ncursor;
					c2 = vs->cursor;
					if (cmd[1] == '%')
						c2++;
				}
			}
			if (*cmd != 'c' && c1 != c2)
				yank_range(c1, c2);
			if (*cmd != 'y') {
				del_range(c1, c2);
				vs->cursor = c1;
			}
			if (*cmd == 'c') {
				modified = 1;
				hnum = hlast;
				insert = INSERT;
			}
			break;

		case ORD('p'):
			modified = 1;
			hnum = hlast;
			if (vs->linelen != 0)
				vs->cursor++;
			while (putbuf(ybuf, yanklen, false) == 0 &&
			    --argcnt > 0)
				;
			if (vs->cursor != 0)
				vs->cursor--;
			if (argcnt != 0)
				return (-1);
			break;

		case ORD('P'):
			modified = 1;
			hnum = hlast;
			any = 0;
			while (putbuf(ybuf, yanklen, false) == 0 &&
			    --argcnt > 0)
				any = 1;
			if (any && vs->cursor != 0)
				vs->cursor--;
			if (argcnt != 0)
				return (-1);
			break;

		case ORD('C'):
			modified = 1;
			hnum = hlast;
			del_range(vs->cursor, vs->linelen);
			insert = INSERT;
			break;

		case ORD('D'):
			yank_range(vs->cursor, vs->linelen);
			del_range(vs->cursor, vs->linelen);
			if (vs->cursor != 0)
				vs->cursor--;
			break;

		case ORD('g'):
			if (!argcnt)
				argcnt = hlast;
			/* FALLTHROUGH */
		case ORD('G'):
			if (!argcnt)
				argcnt = 1;
			else
				argcnt = hlast - (source->line - argcnt);
			if (grabhist(modified, argcnt - 1) < 0)
				return (-1);
			else {
				modified = 0;
				hnum = argcnt - 1;
			}
			break;

		case ORD('i'):
			modified = 1;
			hnum = hlast;
			insert = INSERT;
			break;

		case ORD('I'):
			modified = 1;
			hnum = hlast;
			vs->cursor = domovebeg();
			insert = INSERT;
			break;

		case ORD('j'):
		case ORD('+'):
		case CTRL_N:
			if (grabhist(modified, hnum + argcnt) < 0)
				return (-1);
			else {
				modified = 0;
				hnum += argcnt;
			}
			break;

		case ORD('k'):
		case ORD('-'):
		case CTRL_P:
			if (grabhist(modified, hnum - argcnt) < 0)
				return (-1);
			else {
				modified = 0;
				hnum -= argcnt;
			}
			break;

		case ORD('r'):
			if (vs->linelen == 0)
				return (-1);
			modified = 1;
			hnum = hlast;
			if (cmd[1] == 0)
				vi_error();
			else {
				int n;

				if (vs->cursor + argcnt > vs->linelen)
					return (-1);
				for (n = 0; n < argcnt; ++n)
					vs->cbuf[vs->cursor + n] = cmd[1];
				vs->cursor += n - 1;
			}
			break;

		case ORD('R'):
			modified = 1;
			hnum = hlast;
			insert = REPLACE;
			break;

		case ORD('s'):
			if (vs->linelen == 0)
				return (-1);
			modified = 1;
			hnum = hlast;
			if (vs->cursor + argcnt > vs->linelen)
				argcnt = vs->linelen - vs->cursor;
			del_range(vs->cursor, vs->cursor + argcnt);
			insert = INSERT;
			break;

		case ORD('v'):
			if (!argcnt) {
				if (vs->linelen == 0)
					return (-1);
				if (modified) {
					vs->cbuf[vs->linelen] = '\0';
					histsave(&source->line, vs->cbuf,
					    HIST_STORE, true);
				} else
					argcnt = source->line + 1 -
					    (hlast - hnum);
			}
			if (argcnt)
				shf_snprintf(vs->cbuf, vs->cbufsize, Tf_sd,
				    "fc -e ${VISUAL:-${EDITOR:-vi}} --",
				    argcnt);
			else
				strlcpy(vs->cbuf,
				    "fc -e ${VISUAL:-${EDITOR:-vi}} --",
				    vs->cbufsize);
			vs->linelen = strlen(vs->cbuf);
			return (2);

		case ORD('x'):
			if (vs->linelen == 0)
				return (-1);
			modified = 1;
			hnum = hlast;
			if (vs->cursor + argcnt > vs->linelen)
				argcnt = vs->linelen - vs->cursor;
			yank_range(vs->cursor, vs->cursor + argcnt);
			del_range(vs->cursor, vs->cursor + argcnt);
			break;

		case ORD('X'):
			if (vs->cursor > 0) {
				modified = 1;
				hnum = hlast;
				if (vs->cursor < argcnt)
					argcnt = vs->cursor;
				yank_range(vs->cursor - argcnt, vs->cursor);
				del_range(vs->cursor - argcnt, vs->cursor);
				vs->cursor -= argcnt;
			} else
				return (-1);
			break;

		case ORD('u'):
			t = vs;
			vs = undo;
			undo = t;
			break;

		case ORD('U'):
			if (!modified)
				return (-1);
			if (grabhist(modified, ohnum) < 0)
				return (-1);
			modified = 0;
			hnum = ohnum;
			break;

		case ORD('?'):
			if (hnum == hlast)
				hnum = -1;
			/* ahhh */

			/* FALLTHROUGH */
		case ORD('/'):
			c3 = 1;
			srchlen = 0;
			lastsearch = *cmd;
			/* FALLTHROUGH */
		case ORD('n'):
		case ORD('N'):
			if (lastsearch == ' ')
				return (-1);
			if (lastsearch == '?')
				c1 = 1;
			else
				c1 = 0;
			if (*cmd == 'N')
				c1 = !c1;
			if ((c2 = grabsearch(modified, hnum,
			    c1, srchpat)) < 0) {
				if (c3) {
					restore_cbuf();
					refresh(0);
				}
				return (-1);
			} else {
				modified = 0;
				hnum = c2;
				ohnum = hnum;
			}
			if (argcnt >= 2) {
				/* flag from cursor-up command */
				vs->cursor = argcnt - 2;
				return (0);
			}
			break;
		case ORD('_'):
			{
				bool inspace;
				char *p, *sp;

				if (histnum(-1) < 0)
					return (-1);
				p = *histpos();
				if (argcnt) {
					while (ctype(*p, C_SPACE))
						p++;
					while (*p && --argcnt) {
						while (*p && !ctype(*p, C_SPACE))
							p++;
						while (ctype(*p, C_SPACE))
							p++;
					}
					if (!*p)
						return (-1);
					sp = p;
				} else {
					sp = p;
					inspace = false;
					while (*p) {
						if (ctype(*p, C_SPACE))
							inspace = true;
						else if (inspace) {
							inspace = false;
							sp = p;
						}
						p++;
					}
					p = sp;
				}
				modified = 1;
				hnum = hlast;
				if (vs->cursor != vs->linelen)
					vs->cursor++;
				while (*p && !ctype(*p, C_SPACE)) {
					argcnt++;
					p++;
				}
				if (putbuf(T1space, 1, false) != 0 ||
				    putbuf(sp, argcnt, false) != 0) {
					if (vs->cursor != 0)
						vs->cursor--;
					return (-1);
				}
				insert = INSERT;
			}
			break;

		case ORD('~'):
			{
				char *p;
				int i;

				if (vs->linelen == 0)
					return (-1);
				for (i = 0; i < argcnt; i++) {
					p = &vs->cbuf[vs->cursor];
					if (ctype(*p, C_LOWER)) {
						modified = 1;
						hnum = hlast;
						*p = ksh_toupper(*p);
					} else if (ctype(*p, C_UPPER)) {
						modified = 1;
						hnum = hlast;
						*p = ksh_tolower(*p);
					}
					if (vs->cursor < vs->linelen - 1)
						vs->cursor++;
				}
				break;
			}

		case ORD('#'):
			{
				int ret = x_do_comment(vs->cbuf, vs->cbufsize,
				    &vs->linelen);
				if (ret >= 0)
					vs->cursor = 0;
				return (ret);
			}

		/* AT&T ksh */
		case ORD('='):
		/* Nonstandard vi/ksh */
		case CTRL_E:
			print_expansions(vs, 1);
			break;


		/* Nonstandard vi/ksh */
		case CTRL_I:
			if (!Flag(FVITABCOMPLETE))
				return (-1);
			complete_word(1, argcnt);
			break;

		/* some annoying AT&T kshs */
		case CTRL_BO:
			if (!Flag(FVIESCCOMPLETE))
				return (-1);
			/* FALLTHROUGH */
		/* AT&T ksh */
		case ORD('\\'):
		/* Nonstandard vi/ksh */
		case CTRL_F:
			complete_word(1, argcnt);
			break;


		/* AT&T ksh */
		case ORD('*'):
		/* Nonstandard vi/ksh */
		case CTRL_X:
			expand_word(1);
			break;


		/* mksh: cursor movement */
		case ORD('['):
		case ORD('O'):
			state = VPREFIX2;
			if (vs->linelen != 0)
				vs->cursor++;
			insert = INSERT;
			return (0);
		}
		if (insert == 0 && vs->cursor != 0 && vs->cursor >= vs->linelen)
			vs->cursor--;
	}
	return (0);
}

static int
domove(int argcnt, const char *cmd, int sub)
{
	int ncursor = 0, i = 0, t;
	unsigned int bcount;

	switch (ord(*cmd)) {
	case ORD('b'):
		if (!sub && vs->cursor == 0)
			return (-1);
		ncursor = backword(argcnt);
		break;

	case ORD('B'):
		if (!sub && vs->cursor == 0)
			return (-1);
		ncursor = Backword(argcnt);
		break;

	case ORD('e'):
		if (!sub && vs->cursor + 1 >= vs->linelen)
			return (-1);
		ncursor = endword(argcnt);
		if (sub && ncursor < vs->linelen)
			ncursor++;
		break;

	case ORD('E'):
		if (!sub && vs->cursor + 1 >= vs->linelen)
			return (-1);
		ncursor = Endword(argcnt);
		if (sub && ncursor < vs->linelen)
			ncursor++;
		break;

	case ORD('f'):
	case ORD('F'):
	case ORD('t'):
	case ORD('T'):
		fsavecmd = *cmd;
		fsavech = cmd[1];
		/* FALLTHROUGH */
	case ORD(','):
	case ORD(';'):
		if (fsavecmd == ' ')
			return (-1);
		i = ksh_eq(fsavecmd, 'F', 'f');
		t = fsavecmd > 'a';
		if (*cmd == ',')
			t = !t;
		if ((ncursor = findch(fsavech, argcnt, tobool(t),
		    tobool(i))) < 0)
			return (-1);
		if (sub && t)
			ncursor++;
		break;

	case ORD('h'):
	case CTRL_H:
		if (!sub && vs->cursor == 0)
			return (-1);
		ncursor = vs->cursor - argcnt;
		if (ncursor < 0)
			ncursor = 0;
		break;

	case ORD(' '):
	case ORD('l'):
		if (!sub && vs->cursor + 1 >= vs->linelen)
			return (-1);
		if (vs->linelen != 0) {
			ncursor = vs->cursor + argcnt;
			if (ncursor > vs->linelen)
				ncursor = vs->linelen;
		}
		break;

	case ORD('w'):
		if (!sub && vs->cursor + 1 >= vs->linelen)
			return (-1);
		ncursor = forwword(argcnt);
		break;

	case ORD('W'):
		if (!sub && vs->cursor + 1 >= vs->linelen)
			return (-1);
		ncursor = Forwword(argcnt);
		break;

	case ORD('0'):
		ncursor = 0;
		break;

	case ORD('^'):
		ncursor = domovebeg();
		break;

	case ORD('|'):
		ncursor = argcnt;
		if (ncursor > vs->linelen)
			ncursor = vs->linelen;
		if (ncursor)
			ncursor--;
		break;

	case ORD('$'):
		if (vs->linelen != 0)
			ncursor = vs->linelen;
		else
			ncursor = 0;
		break;

	case ORD('%'):
		ncursor = vs->cursor;
		while (ncursor < vs->linelen &&
		    (i = bracktype(vs->cbuf[ncursor])) == 0)
			ncursor++;
		if (ncursor == vs->linelen)
			return (-1);
		bcount = 1;
		do {
			if (i > 0) {
				if (++ncursor >= vs->linelen)
					return (-1);
			} else {
				if (--ncursor < 0)
					return (-1);
			}
			t = bracktype(vs->cbuf[ncursor]);
			if (t == i)
				bcount++;
			else if (t == -i)
				bcount--;
		} while (bcount != 0);
		if (sub && i > 0)
			ncursor++;
		break;

	default:
		return (-1);
	}
	return (ncursor);
}

static int
domovebeg(void)
{
	int ncursor = 0;

	while (ncursor < vs->linelen - 1 &&
	    ctype(vs->cbuf[ncursor], C_SPACE))
		ncursor++;
	return (ncursor);
}

static int
redo_insert(int count)
{
	while (count-- > 0)
		if (putbuf(ibuf, inslen, tobool(insert == REPLACE)) != 0)
			return (-1);
	if (vs->cursor > 0)
		vs->cursor--;
	insert = 0;
	return (0);
}

static void
yank_range(int a, int b)
{
	yanklen = b - a;
	if (yanklen != 0)
		memmove(ybuf, &vs->cbuf[a], yanklen);
}

static int
bracktype(int ch)
{
	switch (ord(ch)) {

	case ORD('('):
		return (1);

	case ORD('['):
		return (2);

	case ORD('{'):
		return (3);

	case ORD(')'):
		return (-1);

	case ORD(']'):
		return (-2);

	case ORD('}'):
		return (-3);

	default:
		return (0);
	}
}

/*
 *	Non user interface editor routines below here
 */

static void
save_cbuf(void)
{
	memmove(holdbufp, vs->cbuf, vs->linelen);
	holdlen = vs->linelen;
	holdbufp[holdlen] = '\0';
}

static void
restore_cbuf(void)
{
	vs->cursor = 0;
	vs->linelen = holdlen;
	memmove(vs->cbuf, holdbufp, holdlen);
}

/* return a new edstate */
static struct edstate *
save_edstate(struct edstate *old)
{
	struct edstate *news;

	news = alloc(sizeof(struct edstate), AEDIT);
	news->cbuf = alloc(old->cbufsize, AEDIT);
	memcpy(news->cbuf, old->cbuf, old->linelen);
	news->cbufsize = old->cbufsize;
	news->linelen = old->linelen;
	news->cursor = old->cursor;
	news->winleft = old->winleft;
	return (news);
}

static void
restore_edstate(struct edstate *news, struct edstate *old)
{
	memcpy(news->cbuf, old->cbuf, old->linelen);
	news->linelen = old->linelen;
	news->cursor = old->cursor;
	news->winleft = old->winleft;
	free_edstate(old);
}

static void
free_edstate(struct edstate *old)
{
	afree(old->cbuf, AEDIT);
	afree(old, AEDIT);
}

/*
 * this is used for calling x_escape() in complete_word()
 */
static int
x_vi_putbuf(const char *s, size_t len)
{
	return (putbuf(s, len, false));
}

static int
putbuf(const char *buf, ssize_t len, bool repl)
{
	if (len == 0)
		return (0);
	if (repl) {
		if (vs->cursor + len >= vs->cbufsize)
			return (-1);
		if (vs->cursor + len > vs->linelen)
			vs->linelen = vs->cursor + len;
	} else {
		if (vs->linelen + len >= vs->cbufsize)
			return (-1);
		memmove(&vs->cbuf[vs->cursor + len], &vs->cbuf[vs->cursor],
		    vs->linelen - vs->cursor);
		vs->linelen += len;
	}
	memmove(&vs->cbuf[vs->cursor], buf, len);
	vs->cursor += len;
	return (0);
}

static void
del_range(int a, int b)
{
	if (vs->linelen != b)
		memmove(&vs->cbuf[a], &vs->cbuf[b], vs->linelen - b);
	vs->linelen -= b - a;
}

static int
findch(int ch, int cnt, bool forw, bool incl)
{
	int ncursor;

	if (vs->linelen == 0)
		return (-1);
	ncursor = vs->cursor;
	while (cnt--) {
		do {
			if (forw) {
				if (++ncursor == vs->linelen)
					return (-1);
			} else {
				if (--ncursor < 0)
					return (-1);
			}
		} while (vs->cbuf[ncursor] != ch);
	}
	if (!incl) {
		if (forw)
			ncursor--;
		else
			ncursor++;
	}
	return (ncursor);
}

static int
forwword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor < vs->linelen && argcnt--) {
		if (ctype(vs->cbuf[ncursor], C_ALNUX))
			while (ncursor < vs->linelen &&
			    ctype(vs->cbuf[ncursor], C_ALNUX))
				ncursor++;
		else if (!ctype(vs->cbuf[ncursor], C_SPACE))
			while (ncursor < vs->linelen &&
			    !ctype(vs->cbuf[ncursor], C_ALNUX | C_SPACE))
				ncursor++;
		while (ncursor < vs->linelen &&
		    ctype(vs->cbuf[ncursor], C_SPACE))
			ncursor++;
	}
	return (ncursor);
}

static int
backword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor > 0 && argcnt--) {
		while (--ncursor > 0 && ctype(vs->cbuf[ncursor], C_SPACE))
			;
		if (ncursor > 0) {
			if (ctype(vs->cbuf[ncursor], C_ALNUX))
				while (--ncursor >= 0 &&
				    ctype(vs->cbuf[ncursor], C_ALNUX))
					;
			else
				while (--ncursor >= 0 &&
				    !ctype(vs->cbuf[ncursor], C_ALNUX | C_SPACE))
					;
			ncursor++;
		}
	}
	return (ncursor);
}

static int
endword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor < vs->linelen && argcnt--) {
		while (++ncursor < vs->linelen - 1 &&
		    ctype(vs->cbuf[ncursor], C_SPACE))
			;
		if (ncursor < vs->linelen - 1) {
			if (ctype(vs->cbuf[ncursor], C_ALNUX))
				while (++ncursor < vs->linelen &&
				    ctype(vs->cbuf[ncursor], C_ALNUX))
					;
			else
				while (++ncursor < vs->linelen &&
				    !ctype(vs->cbuf[ncursor], C_ALNUX | C_SPACE))
					;
			ncursor--;
		}
	}
	return (ncursor);
}

static int
Forwword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor < vs->linelen && argcnt--) {
		while (ncursor < vs->linelen &&
		    !ctype(vs->cbuf[ncursor], C_SPACE))
			ncursor++;
		while (ncursor < vs->linelen &&
		    ctype(vs->cbuf[ncursor], C_SPACE))
			ncursor++;
	}
	return (ncursor);
}

static int
Backword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor > 0 && argcnt--) {
		while (--ncursor >= 0 && ctype(vs->cbuf[ncursor], C_SPACE))
			;
		while (ncursor >= 0 && !ctype(vs->cbuf[ncursor], C_SPACE))
			ncursor--;
		ncursor++;
	}
	return (ncursor);
}

static int
Endword(int argcnt)
{
	int ncursor;

	ncursor = vs->cursor;
	while (ncursor < vs->linelen - 1 && argcnt--) {
		while (++ncursor < vs->linelen - 1 &&
		    ctype(vs->cbuf[ncursor], C_SPACE))
			;
		if (ncursor < vs->linelen - 1) {
			while (++ncursor < vs->linelen &&
			    !ctype(vs->cbuf[ncursor], C_SPACE))
				;
			ncursor--;
		}
	}
	return (ncursor);
}

static int
grabhist(int save, int n)
{
	char *hptr;

	if (n < 0 || n > hlast)
		return (-1);
	if (n == hlast) {
		restore_cbuf();
		ohnum = n;
		return (0);
	}
	(void)histnum(n);
	if ((hptr = *histpos()) == NULL) {
		internal_warningf("grabhist: bad history array");
		return (-1);
	}
	if (save)
		save_cbuf();
	if ((vs->linelen = strlen(hptr)) >= vs->cbufsize)
		vs->linelen = vs->cbufsize - 1;
	memmove(vs->cbuf, hptr, vs->linelen);
	vs->cursor = 0;
	ohnum = n;
	return (0);
}

static int
grabsearch(int save, int start, int fwd, const char *pat)
{
	char *hptr;
	int hist;
	bool anchored;

	if ((start == 0 && fwd == 0) || (start >= hlast - 1 && fwd == 1))
		return (-1);
	if (fwd)
		start++;
	else
		start--;
	anchored = *pat == '^' ? (++pat, true) : false;
	if ((hist = findhist(start, fwd, pat, anchored)) < 0) {
		/* (start != 0 && fwd && match(holdbufp, pat) >= 0) */
		if (start != 0 && fwd && strcmp(holdbufp, pat) >= 0) {
			restore_cbuf();
			return (0);
		} else
			return (-1);
	}
	if (save)
		save_cbuf();
	histnum(hist);
	hptr = *histpos();
	if ((vs->linelen = strlen(hptr)) >= vs->cbufsize)
		vs->linelen = vs->cbufsize - 1;
	memmove(vs->cbuf, hptr, vs->linelen);
	vs->cursor = 0;
	return (hist);
}

static void
redraw_line(bool newl)
{
	if (wbuf_len)
		memset(wbuf[win], ' ', wbuf_len);
	if (newl) {
		x_putc('\r');
		x_putc('\n');
	}
	x_pprompt();
	morec = ' ';
}

static void
refresh(int leftside)
{
	if (leftside < 0)
		leftside = lastref;
	else
		lastref = leftside;
	if (outofwin())
		rewindow();
	display(wbuf[1 - win], wbuf[win], leftside);
	win = 1 - win;
}

static int
outofwin(void)
{
	int cur, col;

	if (vs->cursor < vs->winleft)
		return (1);
	col = 0;
	cur = vs->winleft;
	while (cur < vs->cursor)
		col = newcol((unsigned char)vs->cbuf[cur++], col);
	if (col >= winwidth)
		return (1);
	return (0);
}

static void
rewindow(void)
{
	int tcur, tcol;
	int holdcur1, holdcol1;
	int holdcur2, holdcol2;

	holdcur1 = holdcur2 = tcur = 0;
	holdcol1 = holdcol2 = tcol = 0;
	while (tcur < vs->cursor) {
		if (tcol - holdcol2 > winwidth / 2) {
			holdcur1 = holdcur2;
			holdcol1 = holdcol2;
			holdcur2 = tcur;
			holdcol2 = tcol;
		}
		tcol = newcol((unsigned char)vs->cbuf[tcur++], tcol);
	}
	while (tcol - holdcol1 > winwidth / 2)
		holdcol1 = newcol((unsigned char)vs->cbuf[holdcur1++],
		    holdcol1);
	vs->winleft = holdcur1;
}

static int
newcol(unsigned char ch, int col)
{
	if (ch == '\t')
		return ((col | 7) + 1);
	return (col + char_len(ch));
}

static void
display(char *wb1, char *wb2, int leftside)
{
	unsigned char ch;
	char *twb1, *twb2, mc;
	int cur, col, cnt;
	int ncol = 0;
	int moreright;

	col = 0;
	cur = vs->winleft;
	moreright = 0;
	twb1 = wb1;
	while (col < winwidth && cur < vs->linelen) {
		if (cur == vs->cursor && leftside)
			ncol = col + pwidth;
		if ((ch = vs->cbuf[cur]) == '\t')
			do {
				*twb1++ = ' ';
			} while (++col < winwidth && (col & 7) != 0);
		else if (col < winwidth) {
			if (ksh_isctrl(ch)) {
				*twb1++ = '^';
				if (++col < winwidth) {
					*twb1++ = ksh_unctrl(ch);
					col++;
				}
			} else {
				*twb1++ = ch;
				col++;
			}
		}
		if (cur == vs->cursor && !leftside)
			ncol = col + pwidth - 1;
		cur++;
	}
	if (cur == vs->cursor)
		ncol = col + pwidth;
	if (col < winwidth) {
		while (col < winwidth) {
			*twb1++ = ' ';
			col++;
		}
	} else
		moreright++;
	*twb1 = ' ';

	col = pwidth;
	cnt = winwidth;
	twb1 = wb1;
	twb2 = wb2;
	while (cnt--) {
		if (*twb1 != *twb2) {
			if (x_col != col)
				ed_mov_opt(col, wb1);
			x_putc(*twb1);
			x_col++;
		}
		twb1++;
		twb2++;
		col++;
	}
	if (vs->winleft > 0 && moreright)
		/*
		 * POSIX says to use * for this but that is a globbing
		 * character and may confuse people; + is more innocuous
		 */
		mc = '+';
	else if (vs->winleft > 0)
		mc = '<';
	else if (moreright)
		mc = '>';
	else
		mc = ' ';
	if (mc != morec) {
		ed_mov_opt(pwidth + winwidth + 1, wb1);
		x_putc(mc);
		x_col++;
		morec = mc;
	}
	if (x_col != ncol)
		ed_mov_opt(ncol, wb1);
}

static void
ed_mov_opt(int col, char *wb)
{
	if (col < x_col) {
		if (col + 1 < x_col - col) {
			x_putc('\r');
			x_pprompt();
			while (x_col++ < col)
				x_putcf(*wb++);
		} else {
			while (x_col-- > col)
				x_putc('\b');
		}
	} else {
		wb = &wb[x_col - pwidth];
		while (x_col++ < col)
			x_putcf(*wb++);
	}
	x_col = col;
}


/* replace word with all expansions (ie, expand word*) */
static int
expand_word(int cmd)
{
	static struct edstate *buf;
	int rval = 0, nwords, start, end, i;
	char **words;

	/* Undo previous expansion */
	if (cmd == 0 && expanded == EXPAND && buf) {
		restore_edstate(vs, buf);
		buf = 0;
		expanded = NONE;
		return (0);
	}
	if (buf) {
		free_edstate(buf);
		buf = 0;
	}

	i = XCF_COMMAND_FILE | XCF_FULLPATH;
	nwords = x_cf_glob(&i, vs->cbuf, vs->linelen, vs->cursor,
	    &start, &end, &words);
	if (nwords == 0) {
		vi_error();
		return (-1);
	}

	buf = save_edstate(vs);
	expanded = EXPAND;
	del_range(start, end);
	vs->cursor = start;
	i = 0;
	while (i < nwords) {
		if (x_escape(words[i], strlen(words[i]), x_vi_putbuf) != 0) {
			rval = -1;
			break;
		}
		if (++i < nwords && putbuf(T1space, 1, false) != 0) {
			rval = -1;
			break;
		}
	}
	i = buf->cursor - end;
	if (rval == 0 && i > 0)
		vs->cursor += i;
	modified = 1;
	hnum = hlast;
	insert = INSERT;
	lastac = 0;
	refresh(0);
	return (rval);
}

static int
complete_word(int cmd, int count)
{
	static struct edstate *buf;
	int rval, nwords, start, end, flags;
	size_t match_len;
	char **words;
	char *match;
	bool is_unique;

	/* Undo previous completion */
	if (cmd == 0 && expanded == COMPLETE && buf) {
		print_expansions(buf, 0);
		expanded = PRINT;
		return (0);
	}
	if (cmd == 0 && expanded == PRINT && buf) {
		restore_edstate(vs, buf);
		buf = 0;
		expanded = NONE;
		return (0);
	}
	if (buf) {
		free_edstate(buf);
		buf = 0;
	}

	/*
	 * XCF_FULLPATH for count 'cause the menu printed by
	 * print_expansions() was done this way.
	 */
	flags = XCF_COMMAND_FILE;
	if (count)
		flags |= XCF_FULLPATH;
	nwords = x_cf_glob(&flags, vs->cbuf, vs->linelen, vs->cursor,
	    &start, &end, &words);
	if (nwords == 0) {
		vi_error();
		return (-1);
	}
	if (count) {
		int i;

		count--;
		if (count >= nwords) {
			vi_error();
			x_print_expansions(nwords, words,
			    tobool(flags & XCF_IS_COMMAND));
			x_free_words(nwords, words);
			redraw_line(false);
			return (-1);
		}
		/*
		 * Expand the count'th word to its basename
		 */
		if (flags & XCF_IS_COMMAND) {
			match = words[count] +
			    x_basename(words[count], NULL);
			/* If more than one possible match, use full path */
			for (i = 0; i < nwords; i++)
				if (i != count &&
				    strcmp(words[i] + x_basename(words[i],
				    NULL), match) == 0) {
					match = words[count];
					break;
				}
		} else
			match = words[count];
		match_len = strlen(match);
		is_unique = true;
		/* expanded = PRINT;	next call undo */
	} else {
		match = words[0];
		match_len = x_longest_prefix(nwords, words);
		/* next call will list completions */
		expanded = COMPLETE;
		is_unique = nwords == 1;
	}

	buf = save_edstate(vs);
	del_range(start, end);
	vs->cursor = start;

	/*
	 * escape all shell-sensitive characters and put the result into
	 * command buffer
	 */
	rval = x_escape(match, match_len, x_vi_putbuf);

	if (rval == 0 && is_unique) {
		/*
		 * If exact match, don't undo. Allows directory completions
		 * to be used (ie, complete the next portion of the path).
		 */
		expanded = NONE;

		/*
		 * append a space if this is a non-directory match
		 * and not a parameter or homedir substitution
		 */
		if (match_len > 0 && !mksh_cdirsep(match[match_len - 1]) &&
		    !(flags & XCF_IS_NOSPACE))
			rval = putbuf(T1space, 1, false);
	}
	x_free_words(nwords, words);

	modified = 1;
	hnum = hlast;
	insert = INSERT;
	/* prevent this from being redone... */
	lastac = 0;
	refresh(0);

	return (rval);
}

static int
print_expansions(struct edstate *est, int cmd MKSH_A_UNUSED)
{
	int start, end, nwords, i;
	char **words;

	i = XCF_COMMAND_FILE | XCF_FULLPATH;
	nwords = x_cf_glob(&i, est->cbuf, est->linelen, est->cursor,
	    &start, &end, &words);
	if (nwords == 0) {
		vi_error();
		return (-1);
	}
	x_print_expansions(nwords, words, tobool(i & XCF_IS_COMMAND));
	x_free_words(nwords, words);
	redraw_line(false);
	return (0);
}
#endif /* !MKSH_S_NOVI */

/* Similar to x_zotc(emacs.c), but no tab weirdness */
static void
x_vi_zotc(int c)
{
	if (ksh_isctrl(c)) {
		x_putc('^');
		c = ksh_unctrl(c);
	}
	x_putc(c);
}

#if !MKSH_S_NOVI
static void
vi_error(void)
{
	/* Beem out of any macros as soon as an error occurs */
	vi_macro_reset();
	x_putc(KSH_BEL);
	x_flush();
}

static void
vi_macro_reset(void)
{
	if (macro.p) {
		afree(macro.buf, AEDIT);
		memset((char *)&macro, 0, sizeof(macro));
	}
}
#endif /* !MKSH_S_NOVI */

/* called from main.c */
void
x_init(void)
{
	int i, j;

	/*
	 * set edchars to force initial binding, except we need
	 * default values for ^W for some deficient systems…
	 */
	edchars.erase = edchars.kill = edchars.intr = edchars.quit =
	    edchars.eof = EDCHAR_INITIAL;
	edchars.werase = 027;

	/* command line editing specific memory allocation */
	ainit(AEDIT);
	holdbufp = alloc(LINE, AEDIT);

	/* initialise Emacs command line editing mode */
	x_nextcmd = -1;

	x_tab = alloc2(X_NTABS, sizeof(*x_tab), AEDIT);
	for (j = 0; j < X_TABSZ; j++)
		x_tab[0][j] = XFUNC_insert;
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_tab[i][j] = XFUNC_error;
	for (i = 0; i < (int)NELEM(x_defbindings); i++)
		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
		    = x_defbindings[i].xdb_func;

#ifndef MKSH_SMALL
	x_atab = alloc2(X_NTABS, sizeof(*x_atab), AEDIT);
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_atab[i][j] = NULL;
#endif
}

#ifdef DEBUG_LEAKS
void
x_done(void)
{
	if (x_tab != NULL)
		afreeall(AEDIT);
}
#endif

void
x_initterm(const char *termtype)
{
	/* default must be 0 (bss) */
	x_term_mode = 0;
	/* this is what tmux uses, don't ask me about it */
	if (!strcmp(termtype, "screen") || !strncmp(termtype, "screen-", 7))
		x_term_mode = 1;
}

#ifndef MKSH_SMALL
static char *
x_eval_region_helper(const char *cmd, size_t len)
{
	char * volatile cp;
	newenv(E_ERRH);

	if (!kshsetjmp(e->jbuf)) {
		char *wds = alloc(len + 3, ATEMP);

		wds[0] = FUNASUB;
		memcpy(wds + 1, cmd, len);
		wds[len + 1] = '\0';
		wds[len + 2] = EOS;

		cp = evalstr(wds, DOSCALAR);
		afree(wds, ATEMP);
		strdupx(cp, cp, AEDIT);
	} else
		cp = NULL;
	quitenv(NULL);
	return (cp);
}

static int
x_eval_region(int c MKSH_A_UNUSED)
{
	char *evbeg, *evend, *cp;
	size_t newlen;
	/* only for LINE overflow checking */
	size_t restlen;

	if (xmp == NULL) {
		evbeg = xbuf;
		evend = xep;
	} else if (xmp < xcp) {
		evbeg = xmp;
		evend = xcp;
	} else {
		evbeg = xcp;
		evend = xmp;
	}

	x_e_putc2('\r');
	x_clrtoeol(' ', false);
	x_flush();
	x_mode(false);
	cp = x_eval_region_helper(evbeg, evend - evbeg);
	x_mode(true);

	if (cp == NULL) {
		/* command cannot be parsed */
 x_eval_region_err:
		x_e_putc2(KSH_BEL);
		x_redraw('\r');
		return (KSTD);
	}

	newlen = strlen(cp);
	restlen = xep - evend;
	/* check for LINE overflow, until this is dynamically allocated */
	if (evbeg + newlen + restlen >= xend)
		goto x_eval_region_err;

	xmp = evbeg;
	xcp = evbeg + newlen;
	xep = xcp + restlen;
	memmove(xcp, evend, restlen + /* NUL */ 1);
	memcpy(xmp, cp, newlen);
	afree(cp, AEDIT);
	x_adjust();
	x_modified();
	return (KSTD);
}
#endif /* !MKSH_SMALL */
#endif /* !MKSH_NO_CMDLINE_EDITING */
@


1.345
log
@always inline shf_putc() into x_putcf() even if MKSH_SMALL
(as x_putcf gets called almost only if MKSH_SMALL)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.344 2019/12/11 17:31:22 tg Exp $");
d357 1
a357 1
			cp = shf_smprintf(Tf_sSs, dp, cp);
@


1.344
log
@try to be less clever to not break neatcc (also more readable)
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.342 2018/01/14 00:03:00 tg Exp $");
d180 1
a180 1
	shf_putc(c, shl_out);
@


1.343
log
@fix a vi mode segfault when using ^W during a search; from multiplexd
@
text
@d8 2
a9 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d3655 13
a3667 10
		if (!ch) switch (cmdlen = 0, (ch = x_getc())) {
		case 71: ch = '0'; goto pseudo_vi_command;
		case 72: ch = 'k'; goto pseudo_vi_command;
		case 73: ch = 'A'; goto vi_xfunc_search_up;
		case 75: ch = 'h'; goto pseudo_vi_command;
		case 77: ch = 'l'; goto pseudo_vi_command;
		case 79: ch = '$'; goto pseudo_vi_command;
		case 80: ch = 'j'; goto pseudo_vi_command;
		case 83: ch = 'x'; goto pseudo_vi_command;
		default: ch = 0; goto vi_insert_failed;
@


1.342
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.337 2017/05/05 22:53:26 tg Exp $");
d3834 1
a3834 1
			while (--i >= n)
@


1.341
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d315 6
a320 6
			case CORD('$'):
			case CORD('*'):
			case CORD('?'):
			case CORD('['):
			case CORD('\\'):
			case CORD('`'):
d4131 1
a4131 1
		case CORD('@@'):
d4172 1
a4172 1
		case CORD('a'):
d4180 1
a4180 1
		case CORD('A'):
d4188 1
a4188 1
		case CORD('S'):
d4196 1
a4196 1
		case CORD('Y'):
d4201 3
a4203 3
		case CORD('c'):
		case CORD('d'):
		case CORD('y'):
d4242 1
a4242 1
		case CORD('p'):
d4256 1
a4256 1
		case CORD('P'):
d4269 1
a4269 1
		case CORD('C'):
d4276 1
a4276 1
		case CORD('D'):
d4283 1
a4283 1
		case CORD('g'):
d4287 1
a4287 1
		case CORD('G'):
d4300 1
a4300 1
		case CORD('i'):
d4306 1
a4306 1
		case CORD('I'):
d4313 2
a4314 2
		case CORD('j'):
		case CORD('+'):
d4324 2
a4325 2
		case CORD('k'):
		case CORD('-'):
d4335 1
a4335 1
		case CORD('r'):
d4353 1
a4353 1
		case CORD('R'):
d4359 1
a4359 1
		case CORD('s'):
d4370 1
a4370 1
		case CORD('v'):
d4393 1
a4393 1
		case CORD('x'):
d4404 1
a4404 1
		case CORD('X'):
d4417 1
a4417 1
		case CORD('u'):
d4423 1
a4423 1
		case CORD('U'):
d4432 1
a4432 1
		case CORD('?'):
d4438 1
a4438 1
		case CORD('/'):
d4443 2
a4444 2
		case CORD('n'):
		case CORD('N'):
d4471 1
a4471 1
		case CORD('_'):
d4523 1
a4523 1
		case CORD('~'):
d4547 1
a4547 1
		case CORD('#'):
d4557 1
a4557 1
		case CORD('='):
d4577 1
a4577 1
		case CORD('\\'):
d4585 1
a4585 1
		case CORD('*'):
d4593 2
a4594 2
		case CORD('['):
		case CORD('O'):
d4614 1
a4614 1
	case CORD('b'):
d4620 1
a4620 1
	case CORD('B'):
d4626 1
a4626 1
	case CORD('e'):
d4634 1
a4634 1
	case CORD('E'):
d4642 4
a4645 4
	case CORD('f'):
	case CORD('F'):
	case CORD('t'):
	case CORD('T'):
d4649 2
a4650 2
	case CORD(','):
	case CORD(';'):
d4664 1
a4664 1
	case CORD('h'):
d4673 2
a4674 2
	case CORD(' '):
	case CORD('l'):
d4684 1
a4684 1
	case CORD('w'):
d4690 1
a4690 1
	case CORD('W'):
d4696 1
a4696 1
	case CORD('0'):
d4700 1
a4700 1
	case CORD('^'):
d4704 1
a4704 1
	case CORD('|'):
d4712 1
a4712 1
	case CORD('$'):
d4719 1
a4719 1
	case CORD('%'):
d4787 1
a4787 1
	case CORD('('):
d4790 1
a4790 1
	case CORD('['):
d4793 1
a4793 1
	case CORD('{'):
d4796 1
a4796 1
	case CORD(')'):
d4799 1
a4799 1
	case CORD(']'):
d4802 1
a4802 1
	case CORD('}'):
@


1.340
log
@unbreak vi mode '0' movement, bug introduced in r1.323
reported by Larry Hynes <larry@@larryhynes.com>
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d315 6
a320 6
			case ord('$'):
			case ord('*'):
			case ord('?'):
			case ord('['):
			case ord('\\'):
			case ord('`'):
d653 1
a653 1
			    ord(*s) == ord('*') || ord(*s) == ord('[') ||
d655 3
a657 3
			    (ord(s[1]) == ord('(' /*)*/) &&
			    (ord(*s) == ord('+') || ord(*s) == ord('@@') ||
			    ord(*s) == ord('!')))) {
d3691 1
a3691 1
			if (ctype(ch, C_DIGIT) && ord(ch) != ord('0')) {
d3746 1
a3746 1
		if (ctype(ch, C_DIGIT) && ord(ch) != ord('0')) {
d4131 1
a4131 1
		case ord('@@'):
d4172 1
a4172 1
		case ord('a'):
d4180 1
a4180 1
		case ord('A'):
d4188 1
a4188 1
		case ord('S'):
d4196 1
a4196 1
		case ord('Y'):
d4201 3
a4203 3
		case ord('c'):
		case ord('d'):
		case ord('y'):
d4242 1
a4242 1
		case ord('p'):
d4256 1
a4256 1
		case ord('P'):
d4269 1
a4269 1
		case ord('C'):
d4276 1
a4276 1
		case ord('D'):
d4283 1
a4283 1
		case ord('g'):
d4287 1
a4287 1
		case ord('G'):
d4300 1
a4300 1
		case ord('i'):
d4306 1
a4306 1
		case ord('I'):
d4313 2
a4314 2
		case ord('j'):
		case ord('+'):
d4324 2
a4325 2
		case ord('k'):
		case ord('-'):
d4335 1
a4335 1
		case ord('r'):
d4353 1
a4353 1
		case ord('R'):
d4359 1
a4359 1
		case ord('s'):
d4370 1
a4370 1
		case ord('v'):
d4393 1
a4393 1
		case ord('x'):
d4404 1
a4404 1
		case ord('X'):
d4417 1
a4417 1
		case ord('u'):
d4423 1
a4423 1
		case ord('U'):
d4432 1
a4432 1
		case ord('?'):
d4438 1
a4438 1
		case ord('/'):
d4443 2
a4444 2
		case ord('n'):
		case ord('N'):
d4471 1
a4471 1
		case ord('_'):
d4523 1
a4523 1
		case ord('~'):
d4547 1
a4547 1
		case ord('#'):
d4557 1
a4557 1
		case ord('='):
d4577 1
a4577 1
		case ord('\\'):
d4585 1
a4585 1
		case ord('*'):
d4593 2
a4594 2
		case ord('['):
		case ord('O'):
d4614 1
a4614 1
	case ord('b'):
d4620 1
a4620 1
	case ord('B'):
d4626 1
a4626 1
	case ord('e'):
d4634 1
a4634 1
	case ord('E'):
d4642 4
a4645 4
	case ord('f'):
	case ord('F'):
	case ord('t'):
	case ord('T'):
d4649 2
a4650 2
	case ord(','):
	case ord(';'):
d4664 1
a4664 1
	case ord('h'):
d4673 2
a4674 2
	case ord(' '):
	case ord('l'):
d4684 1
a4684 1
	case ord('w'):
d4690 1
a4690 1
	case ord('W'):
d4696 1
a4696 1
	case ord('0'):
d4700 1
a4700 1
	case ord('^'):
d4704 1
a4704 1
	case ord('|'):
d4712 1
a4712 1
	case ord('$'):
d4719 1
a4719 1
	case ord('%'):
d4787 1
a4787 1
	case ord('('):
d4790 1
a4790 1
	case ord('['):
d4793 1
a4793 1
	case ord('{'):
d4796 1
a4796 1
	case ord(')'):
d4799 1
a4799 1
	case ord(']'):
d4802 1
a4802 1
	case ord('}'):
@


1.339
log
@go home Coverity, you’re drunk

code refactoring to work around it not recognising the correct code path
@
text
@d3691 1
a3691 1
			if (ctype(ch, C_DIGIT)) {
d3746 1
a3746 1
		if (ctype(ch, C_DIGIT)) {
@


1.338
log
@Coverity 1416283
@
text
@d3388 1
d4189 1
a4189 1
			vs->cursor = domove(1, "^", 1);
d4205 1
a4205 3
				c1 = *cmd == 'c' ? domove(1, "^", 1) : 0;
				if (c1 < 0)
					return (-1);
d4309 1
a4309 1
			vs->cursor = domove(1, "^", 1);
d4701 1
a4701 4
		ncursor = 0;
		while (ncursor < vs->linelen - 1 &&
		    ctype(vs->cbuf[ncursor], C_SPACE))
			ncursor++;
d4752 11
@


1.337
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.332 2017/04/28 03:28:17 tg Exp $");
d4205 2
@


1.336
log
@switch EBCDIC to “nega-UTF8”
@
text
@d313 1
a313 1
			switch (ch) {
d315 6
a320 6
			case '$':
			case '*':
			case '?':
			case '[':
			case '\\':
			case '`':
d653 1
a653 1
			    *s == '*' || *s == '[' ||
d655 3
a657 2
			    (s[1] == '(' /*)*/ &&
			    (*s == '+' || *s == '@@' || *s == '!'))) {
d4123 1
a4123 1
		switch (*cmd) {
d4130 1
a4130 1
		case '@@':
d4171 1
a4171 1
		case 'a':
d4179 1
a4179 1
		case 'A':
d4187 1
a4187 1
		case 'S':
d4195 1
a4195 1
		case 'Y':
d4200 3
a4202 3
		case 'c':
		case 'd':
		case 'y':
d4241 1
a4241 1
		case 'p':
d4255 1
a4255 1
		case 'P':
d4268 1
a4268 1
		case 'C':
d4275 1
a4275 1
		case 'D':
d4282 1
a4282 1
		case 'g':
d4286 1
a4286 1
		case 'G':
d4299 1
a4299 1
		case 'i':
d4305 1
a4305 1
		case 'I':
d4312 2
a4313 2
		case 'j':
		case '+':
d4323 2
a4324 2
		case 'k':
		case '-':
d4334 1
a4334 1
		case 'r':
d4352 1
a4352 1
		case 'R':
d4358 1
a4358 1
		case 's':
d4369 1
a4369 1
		case 'v':
d4392 1
a4392 1
		case 'x':
d4403 1
a4403 1
		case 'X':
d4416 1
a4416 1
		case 'u':
d4422 1
a4422 1
		case 'U':
d4431 1
a4431 1
		case '?':
d4437 1
a4437 1
		case '/':
d4442 2
a4443 2
		case 'n':
		case 'N':
d4470 1
a4470 1
		case '_':
d4522 1
a4522 1
		case '~':
d4546 1
a4546 1
		case '#':
d4556 1
a4556 1
		case '=':
d4576 1
a4576 1
		case '\\':
d4584 1
a4584 1
		case '*':
d4592 2
a4593 2
		case '[':
		case 'O':
d4612 2
a4613 2
	switch (*cmd) {
	case 'b':
d4619 1
a4619 1
	case 'B':
d4625 1
a4625 1
	case 'e':
d4633 1
a4633 1
	case 'E':
d4641 4
a4644 4
	case 'f':
	case 'F':
	case 't':
	case 'T':
d4648 2
a4649 2
	case ',':
	case ';':
d4663 1
a4663 1
	case 'h':
d4672 2
a4673 2
	case ' ':
	case 'l':
d4683 1
a4683 1
	case 'w':
d4689 1
a4689 1
	case 'W':
d4695 1
a4695 1
	case '0':
d4699 1
a4699 1
	case '^':
d4706 1
a4706 1
	case '|':
d4714 1
a4714 1
	case '$':
d4721 1
a4721 1
	case '%':
d4776 1
a4776 1
	switch (ch) {
d4778 1
a4778 1
	case '(':
d4781 1
a4781 1
	case '[':
d4784 1
a4784 1
	case '{':
d4787 1
a4787 1
	case ')':
d4790 1
a4790 1
	case ']':
d4793 1
a4793 1
	case '}':
@


1.335
log
@use strnul(); optimise
@
text
@d717 2
a718 2
	if (UTFMODE && prefix_len && (words[0][prefix_len] & 0xC0) == 0x80)
		while (prefix_len && (words[0][prefix_len] & 0xC0) != 0xC0)
d1189 2
a1190 1
		if ((buf[0] >= 0xC2) && (buf[0] < 0xF0)) {
d1194 1
a1194 1
			if ((c & 0xC0) != 0x80) {
d1200 2
a1201 1
		if ((buf[0] >= 0xE0) && (buf[0] < 0xF0)) {
d1322 1
a1322 1
		if (((c & 0xC0) == 0x80) && left) {
d1619 1
a1619 1
		    ((*(unsigned char *)cp & 0xC0) == 0x80))
d1640 1
a1640 1
	if (UTFMODE && (c > 0x7F))
d2908 1
d2923 1
d2957 5
d2963 1
@


1.334
log
@instead of disabling, make it work
@
text
@d750 1
a750 1
		se = s + strlen(s);
d802 1
a802 1
			p = sp + strlen(sp);
d1855 1
a1855 1
	xep = xcp = xbuf + strlen(xbuf);
d3058 1
a3058 1
	xend = xep = v + strlen(v);
d3101 1
a3101 1
	xep = xbuf + strlen(xbuf);
@


1.333
log
@allow backslash escapes for bind for ^ and \ o̲n̲l̲y̲; also more EBCDIC-friendly
@
text
@d3417 8
a3424 8
#define is_bad(c)	(classify[(c)&0x7f]&vB)
#define is_cmd(c)	(classify[(c)&0x7f]&(vM|vE|vC|vU))
#define is_move(c)	(classify[(c)&0x7f]&vM)
#define is_extend(c)	(classify[(c)&0x7f]&vE)
#define is_long(c)	(classify[(c)&0x7f]&vX)
#define is_undoable(c)	(!(classify[(c)&0x7f]&vU))
#define is_srch(c)	(classify[(c)&0x7f]&vS)
#define is_zerocount(c)	(classify[(c)&0x7f]&vZ)
@


1.332
log
@control character madness, but more compiler-friendly
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.330 2017/04/28 00:49:32 tg Exp $");
d2397 2
a2398 2
		/* XXX -- should handle \^ escape? */
		if (*cp == '^') {
d2400 7
a2406 8
			/*XXX or ^^ escape? this is ugly. */
			if (rtt2asc(*cp) >= 0x3FU)
				*op++ = ksh_toctrl(*cp);
			else {
				*op++ = '^';
				cp--;
			}
		} else
d2408 1
@


1.331
log
@apply most of the remaining parts of the EBCDIC patch, sans the CTRL() changes
@
text
@d1034 5
a1038 5
	{ XFUNC_del_back,		0, CTRL('?')	},
	{ XFUNC_del_bword,		1, CTRL('?')	},
	{ XFUNC_eot_del,		0, CTRL('D')	},
	{ XFUNC_del_back,		0, CTRL('H')	},
	{ XFUNC_del_bword,		1, CTRL('H')	},
d1043 12
a1054 12
	{ XFUNC_mv_back,		0, CTRL('B')	},
	{ XFUNC_mv_forw,		0, CTRL('F')	},
	{ XFUNC_search_char_forw,	0, CTRL(']')	},
	{ XFUNC_search_char_back,	1, CTRL(']')	},
	{ XFUNC_newline,		0, CTRL('M')	},
	{ XFUNC_newline,		0, CTRL('J')	},
	{ XFUNC_end_of_text,		0, CTRL('_')	},
	{ XFUNC_abort,			0, CTRL('G')	},
	{ XFUNC_prev_com,		0, CTRL('P')	},
	{ XFUNC_next_com,		0, CTRL('N')	},
	{ XFUNC_nl_next_com,		0, CTRL('O')	},
	{ XFUNC_search_hist,		0, CTRL('R')	},
d1058 8
a1065 8
	{ XFUNC_mv_end,			0, CTRL('E')	},
	{ XFUNC_mv_beg,			0, CTRL('A')	},
	{ XFUNC_draw_line,		0, CTRL('L')	},
	{ XFUNC_cls,			1, CTRL('L')	},
	{ XFUNC_meta1,			0, CTRL('[')	},
	{ XFUNC_meta2,			0, CTRL('X')	},
	{ XFUNC_kill,			0, CTRL('K')	},
	{ XFUNC_yank,			0, CTRL('Y')	},
d1067 1
a1067 1
	{ XFUNC_literal,		0, CTRL('^')	},
d1069 3
a1071 3
	{ XFUNC_transpose,		0, CTRL('T')	},
	{ XFUNC_complete,		1, CTRL('[')	},
	{ XFUNC_comp_list,		0, CTRL('I')	},
d1075 2
a1076 2
	{ XFUNC_comp_file,		1, CTRL('X')	},
	{ XFUNC_comp_comm,		2, CTRL('[')	},
d1078 1
a1078 1
	{ XFUNC_list_file,		2, CTRL('Y')	},
d1080 4
a1083 4
	{ XFUNC_kill_region,		0, CTRL('W')	},
	{ XFUNC_xchg_point_mark,	2, CTRL('X')	},
	{ XFUNC_literal,		0, CTRL('V')	},
	{ XFUNC_version,		1, CTRL('V')	},
d1146 1
a1146 1
	{ XFUNC_eval_region,		1, CTRL('E')	},
d1645 1
a1645 1
	if (ISCTRL(c) && /* but not C1 */ c < 0x80)
d1670 1
a1670 1
	} else if (ISCTRL(c) && /* but not C1 */ c < 0x80) {
d1672 1
a1672 1
		x_e_putc2(UNCTRL(c));
d1785 1
a1785 1
	    (unsigned char)CTRL('D');
d1900 1
a1900 1
		if (c == CTRL('[')) {
d1906 1
a1906 1
					x_meta1(CTRL('['));
d2401 2
a2402 3
			if (*cp >= '?')
				/* includes '?'; ASCII */
				*op++ = CTRL(*cp);
d2421 1
a2421 1
	if (ISCTRL(c)) {
d2423 1
a2423 1
		*p++ = UNCTRL(c);
d2446 3
a2448 3
		/* prefix == 1 || prefix == 2 */
		shf_puts(x_mapout(prefix == 1 ? CTRL('[') :
		    prefix == 2 ? CTRL('X') : 0), shl_stdout);
d3333 1
a3333 1
			edchars.erase = CTRL('H');
d3335 1
a3335 1
			edchars.kill = CTRL('U');
d3337 1
a3337 1
			edchars.intr = CTRL('C');
d3339 1
a3339 1
			edchars.quit = CTRL('\\');
d3341 1
a3341 1
			edchars.eof = CTRL('D');
d3343 1
a3343 1
			edchars.werase = CTRL('W');
a3402 2
#define char_len(c)	((ISCTRL((unsigned char)c) && \
			/* but not C1 */ (unsigned char)c < 0x80) ? 2 : 1)
d3406 1
d3654 1
a3654 1
			if (ch == CTRL('v')) {
d3768 1
a3768 1
		if (ch == CTRL('['))
d3777 1
a3777 1
		if (ctype(ch, C_CR | C_LF) /* || ch == CTRL('[') */ ) {
d3792 1
a3792 1
		} else if (isched(ch, edchars.erase) || ch == CTRL('h')) {
d3833 1
a3833 1
				if (ISCTRL(ch) && /* but not C1 */ ch < 0x80) {
d3838 1
a3838 1
					vs->cbuf[vs->linelen++] = UNCTRL(ch);
d3950 1
a3950 1
	else if (ch == CTRL('v'))
d3963 1
a3963 1
	if (isched(ch, edchars.erase) || ch == CTRL('h')) {
d4020 1
a4020 1
	if (first_insert && ch != CTRL('['))
d4030 1
a4030 1
	case CTRL('['):
d4047 1
a4047 1
	case CTRL('x'):
d4051 1
a4051 1
	case CTRL('f'):
d4055 1
a4055 1
	case CTRL('e'):
d4059 1
a4059 1
	case CTRL('i'):
d4114 2
a4115 2
		case CTRL('l'):
		case CTRL('r'):
d4303 1
a4303 1
		case CTRL('n'):
d4314 1
a4314 1
		case CTRL('p'):
d4547 1
a4547 1
		case CTRL('e'):
d4553 1
a4553 1
		case CTRL('i'):
d4560 1
a4560 1
		case CTRL('['):
d4567 1
a4567 1
		case CTRL('f'):
d4575 1
a4575 1
		case CTRL('x'):
d4653 1
a4653 1
	case CTRL('h'):
d5189 1
a5189 1
			if (ISCTRL(ch) && /* but not C1 */ ch < 0x80) {
d5192 1
a5192 1
					*twb1++ = UNCTRL(ch);
d5468 1
a5468 1
	if (ISCTRL(c)) {
d5470 1
a5470 1
		c = UNCTRL(c);
@


1.330
log
@BEL was, and Vi mode is, not EBCDIC-safe
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.328 2017/04/27 23:12:44 tg Exp $");
d36 2
a37 2
 * good string is "\033c" except on hardware terminals like the DEC VT420
 * which do a full power cycle then...
d40 1
a40 1
#define MKSH_CLS_STRING		"\033[;H\033[J"
d2090 1
a2090 1
		shf_puts("\033[K", shl_out);
@


1.329
log
@commit the optimisation result from the new fast character classes
@
text
@d1316 1
a1316 1
		x_e_putc2(7);
d1378 1
a1378 1
		x_e_putc2(7);
d1418 1
a1418 1
		x_e_putc2(7);
d1444 1
a1444 1
		x_e_putc2(7);
d1554 1
a1554 1
		x_e_putc2(7);
d1578 1
a1578 1
		x_e_putc2(7);
d1682 1
a1682 1
		x_e_putc2(7);
d1699 1
a1699 1
		x_e_putc2(7);
d1720 1
a1720 1
		x_e_putc2(7);
d1726 1
a1726 1
			x_e_putc2(7);
d1741 1
a1741 1
		x_e_putc2(7);
d1749 1
a1749 1
				x_e_putc2(7);
d1845 1
a1845 1
		x_e_putc2(7);
d1938 1
a1938 1
				x_e_putc2(7);
d1984 1
a1984 1
	x_e_putc2(7);
d2164 1
a2164 1
		x_e_putc2(7);
d2168 1
a2168 1
			x_e_putc2(7);
d2177 1
a2177 1
			x_e_putc2(7);
d2182 1
a2182 1
			x_e_putc2(7);
d2195 1
a2195 1
			x_e_putc2(7);
d2200 1
a2200 1
			x_e_putc2(7);
d2337 1
a2337 1
	x_e_putc2(7);
d2613 1
a2613 1
		x_e_putc2(7);
d2635 1
a2635 1
		x_e_putc2(7);
d2713 1
a2713 1
		x_e_putc2(7);
d2723 1
a2723 1
			x_e_putc2(7);
d2747 1
a2747 1
		x_e_putc2(7);
d2923 1
a2923 1
		case 7:
d2963 1
a2963 1
		case 7:
d3017 1
a3017 1
		x_e_putc2(7);
d3036 1
a3036 1
		x_e_putc2(7);
d3087 1
a3087 1
			x_e_putc2(7);
d3142 1
a3142 1
		x_e_putc2(7);
d3230 1
a3230 1
		x_e_putc2(7);
d5483 1
a5483 1
	x_putc(7);
d5608 1
a5608 1
		x_e_putc2(7);
@


1.328
log
@fixup the remaining issues and last optimisations
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.319 2017/04/08 20:35:03 tg Exp $");
d652 2
a653 2
			else if (*s == '?' || *s == '*' || *s == '[' ||
			    *s == '$' ||
d2904 1
a2904 1
	if (c == '\r' || c == '\n')
d2945 1
a2945 1
	if (c == '\r' || c == '\n')
d3677 1
a3677 1
			if (ch == '\r' || ch == '\n')
d3779 1
a3779 1
		if (ch == '\r' || ch == '\n' /*|| ch == CTRL('[')*/ ) {
d3913 2
a3914 2
				if (lastcmd[0] == 's' || lastcmd[0] == 'c' ||
				    lastcmd[0] == 'C') {
d4043 1
a4043 2
		if (lastcmd[0] == 's' || lastcmd[0] == 'c' ||
		    lastcmd[0] == 'C')
d4202 1
a4202 2
				if (*cmd == 'c' &&
				    (cmd[1] == 'w' || cmd[1] == 'W') &&
d4643 1
a4643 1
		i = fsavecmd == 'f' || fsavecmd == 'F';
@


1.327
log
@batch of optimisations
@
text
@d556 1
a556 2
#define IS_WORDC(c)	(!ctype(c, C_LEX1 | C_QC) && \
			    (c) != '`' && (c) != '=' && (c) != ':')
d593 1
a593 1
		iscmd = p < 0 || vstrchr(";|&()`", buf[p]);
d861 1
a861 2
		if (vstrchr("#*=?[\\`" ":{}", s[add]) || /*…1…*/
		    ctype(s[add], C_IFS | C_QC | C_DOLAR | CiQCL)) {
@


1.326
log
@eliminate legacy macros
@
text
@d556 1
a556 1
#define IS_WORDC(c)	(!ctype(c, C_LEX1) && (c) != '\'' && (c) != '"' && \
d862 2
a863 2
		if (vstrchr("\"#$&'()*:;<=>?[\\`{|}", s[add]) ||
		    ctype(s[add], C_IFS)) {
a4472 1
#define issp(c)		(ctype(c, C_SPACE) || (c) == '\n')
d4474 1
a4474 1
					while (*p && issp(*p))
d4477 1
a4477 1
						while (*p && !issp(*p))
d4479 1
a4479 1
						while (*p && issp(*p))
d4489 1
a4489 1
						if (issp(*p))
d4503 1
a4503 1
				while (*p && !issp(*p)) {
d4929 1
a4929 2
			    !ctype(vs->cbuf[ncursor], C_ALNUX) &&
			    !ctype(vs->cbuf[ncursor], C_SPACE))
d4954 1
a4954 2
				    !ctype(vs->cbuf[ncursor], C_ALNUX) &&
				    !ctype(vs->cbuf[ncursor], C_SPACE))
d4979 1
a4979 2
				    !ctype(vs->cbuf[ncursor], C_ALNUX) &&
				    !ctype(vs->cbuf[ncursor], C_SPACE))
@


1.325
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@d592 1
a592 1
		while (p >= 0 && ksh_isspace(buf[p]))
d1560 1
a1560 1
		while (cp != xbuf && is_mfs(cp[-1])) {
d1564 1
a1564 1
		while (cp != xbuf && !is_mfs(cp[-1])) {
d1584 1
a1584 1
		while (cp != xep && is_mfs(*cp))
d1586 1
a1586 1
		while (cp != xep && !is_mfs(*cp))
d3009 1
a3009 1
	while (c >= 0 && ksh_isdigit(c)) {
d3156 1
a3156 1
		while (rcp > cp && is_cfs(*rcp))
d3158 1
a3158 1
		while (rcp > cp && !is_cfs(*rcp))
d3160 1
a3160 1
		if (is_cfs(*rcp))
d3171 1
a3171 1
		while (*rcp && is_cfs(*rcp))
d3174 1
a3174 1
			while (*rcp && !is_cfs(*rcp))
d3176 1
a3176 1
			while (*rcp && is_cfs(*rcp))
d3180 1
a3180 1
		while (*rcp && !is_cfs(*rcp))
d3239 1
a3239 1
		while (cp != xep && is_mfs(*cp))
d3257 1
a3257 1
		while (cp != xep && !is_mfs(*cp)) {
d3683 1
a3683 1
			if (ksh_isdigit(ch)) {
d3728 1
a3728 1
		if (ksh_isdigit(ch))
d3738 1
a3738 1
		if (ksh_isdigit(ch)) {
d3754 1
a3754 1
		if (ksh_isdigit(ch))
d4207 1
a4207 1
				    !ksh_isspace(vs->cbuf[vs->cursor])) {
d4210 1
a4210 1
					} while (ksh_isspace(vs->cbuf[ncursor]));
d4473 1
a4473 1
#define issp(c)		(ksh_isspace(c) || (c) == '\n')
d4527 1
a4527 1
					if (ksh_islower(*p)) {
d4531 1
a4531 1
					} else if (ksh_isupper(*p)) {
d4698 1
a4698 1
		    ksh_isspace(vs->cbuf[ncursor]))
d4924 1
a4924 1
		if (ksh_isalnux(vs->cbuf[ncursor]))
d4926 1
a4926 1
			    ksh_isalnux(vs->cbuf[ncursor]))
d4928 1
a4928 1
		else if (!ksh_isspace(vs->cbuf[ncursor]))
d4930 2
a4931 2
			    !ksh_isalnux(vs->cbuf[ncursor]) &&
			    !ksh_isspace(vs->cbuf[ncursor]))
d4934 1
a4934 1
		    ksh_isspace(vs->cbuf[ncursor]))
d4947 1
a4947 1
		while (--ncursor > 0 && ksh_isspace(vs->cbuf[ncursor]))
d4950 1
a4950 1
			if (ksh_isalnux(vs->cbuf[ncursor]))
d4952 1
a4952 1
				    ksh_isalnux(vs->cbuf[ncursor]))
d4956 2
a4957 2
				    !ksh_isalnux(vs->cbuf[ncursor]) &&
				    !ksh_isspace(vs->cbuf[ncursor]))
d4973 1
a4973 1
		    ksh_isspace(vs->cbuf[ncursor]))
d4976 1
a4976 1
			if (ksh_isalnux(vs->cbuf[ncursor]))
d4978 1
a4978 1
				    ksh_isalnux(vs->cbuf[ncursor]))
d4982 2
a4983 2
				    !ksh_isalnux(vs->cbuf[ncursor]) &&
				    !ksh_isspace(vs->cbuf[ncursor]))
d4999 1
a4999 1
		    !ksh_isspace(vs->cbuf[ncursor]))
d5002 1
a5002 1
		    ksh_isspace(vs->cbuf[ncursor]))
d5015 1
a5015 1
		while (--ncursor >= 0 && ksh_isspace(vs->cbuf[ncursor]))
d5017 1
a5017 1
		while (ncursor >= 0 && !ksh_isspace(vs->cbuf[ncursor]))
d5032 1
a5032 1
		    ksh_isspace(vs->cbuf[ncursor]))
d5036 1
a5036 1
			    !ksh_isspace(vs->cbuf[ncursor]))
@


1.324
log
@now actually do comparisons for sorting ASCIIbetically
@
text
@a911 5
/* Separator for completion */
#define	is_cfs(c)	((c) == ' ' || (c) == '\t' || (c) == '"' || (c) == '\'')
/* Separator for motion */
#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$' || ((c) & 0x80)))

@


1.323
log
@make ord() result unsigned int; add asc() which is:

• not designed to be emitted, only used in comparisons with
  other asc() results
• on EBCDIC platforms, the mapping of an EBCDIC octet to their
  corresponding ASCII or Unicode/UCS-4 codepoint or, if there
  is no mapping, a distinct value above all valid Unicode codepoints
• on nōn-EBCDIC platforms, just the identity mapping of the input
  octet into their ord() value

Intended use are ASCII-ish character ops, including ranges (“A-Z”),
mapping from those to the corresponding digit offset, and sorting
of things in an ASCIIbetical way
@
text
@d471 1
a471 1
	if ((t = strcmp(a->word + a->base, b->word + b->base)))
d539 1
a539 1
		qsort(words, nwords, sizeof(void *), xstrcmp);
@


1.322
log
@on ^C (INTR, QUIT edchars), shove input line into history
@
text
@d3688 1
a3688 1
			if (ch >= ord('1') && ch <= ord('9')) {
d3743 1
a3743 1
		if (ch >= ord('1') && ch <= ord('9')) {
@


1.321
log
@(very few) fixes and a couple of workarounds for Coverity
@
text
@d79 1
a79 1
static bool x_term_mode;
d100 1
d995 1
d1304 1
a1304 3
			trapsig(SIGINT);
			x_mode(false);
			unwind(LSHELL);
d2316 3
a2318 2
static int
x_abort(int c MKSH_A_UNUSED)
d2320 5
a2324 1
	/* x_zotc(c); */
d2329 9
a3412 1
static void x_vi_zotc(int);
d3603 5
d3609 2
a3610 6
				x_vi_zotc(c);
				x_flush();
				trapsig(isched(c, edchars.intr) ?
				    SIGINT : SIGQUIT);
				x_mode(false);
				unwind(LSHELL);
d5477 1
d5490 1
@


1.320
log
@fix ^O if modified; LP#1675842
@
text
@d1789 1
a1789 2
	unsigned char tmp;
	char *cp = (void *)&tmp;
d1791 1
a1791 1
	tmp = isedchar(edchars.eof) ? (unsigned char)edchars.eof :
d1793 1
a1793 1
	x_zotc3(&cp);
@


1.319
log
@make -masm=intel safe: don’t call a module-global variable “es”
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.315 2017/04/02 15:42:59 tg Exp $");
d956 1
d1171 1
d1248 1
a1248 1
	x_histp = histptr + 1;
d1871 3
a1873 1
	if (!x_histncp || (x_histp != x_histncp && x_histp != histptr + 1))
d1875 1
a1875 1
		x_histncp = x_histp;
d3179 2
@


1.318
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d3479 1
a3479 1
static struct edstate	*es;		/* current editor state */
d3543 1
a3543 1
	es = &ebuf;
d3594 1
a3594 1
				if (es->linelen == 0) {
d3611 1
a3611 1
	if (c == -1 || (ssize_t)LINE <= es->linelen)
d3614 2
a3615 2
	if (es->cbuf != buf)
		memcpy(buf, es->cbuf, es->linelen);
d3617 1
a3617 1
	buf[es->linelen++] = '\n';
d3619 1
a3619 1
	return (es->linelen);
d3656 1
a3656 1
					es->cursor--;
d3678 2
a3679 2
					es->cursor = 0;
					es->linelen = 0;
d3687 2
a3688 2
					es->cursor = 0;
					es->linelen = 0;
d3699 1
a3699 1
			del_range(es->cursor, es->cursor + 1);
d3702 1
a3702 1
			es->cbuf[es->cursor++] = ch;
d3785 2
a3786 2
				es->linelen -= char_len(locpat[srchlen]);
				es->cursor = es->linelen;
d3795 2
a3796 2
			es->linelen = 1;
			es->cursor = 1;
d3806 2
a3807 2
			save_es = es;
			es = &new_es;
d3809 1
a3809 1
			es = save_es;
d3813 1
a3813 1
				es->linelen -= char_len(locpat[i]);
d3815 1
a3815 1
			es->cursor = es->linelen;
d3824 2
a3825 2
					if ((size_t)es->linelen + 2 >
					    (size_t)es->cbufsize)
d3827 2
a3828 2
					es->cbuf[es->linelen++] = '^';
					es->cbuf[es->linelen++] = UNCTRL(ch);
d3830 1
a3830 1
					if (es->linelen >= es->cbufsize)
d3832 1
a3832 1
					es->cbuf[es->linelen++] = ch;
d3834 1
a3834 1
				es->cursor = es->linelen;
d3847 1
a3847 1
			if (!es->cursor)
d3850 2
a3851 2
			if ((size_t)es->cursor >= sizeof(srchpat) - 1)
				es->cursor = sizeof(srchpat) - 2;
d3855 2
a3856 2
			memmove(srchpat + 1, es->cbuf, es->cursor);
			srchpat[es->cursor + 1] = '\0';
d3858 1
a3858 1
			argc1 = 2 + (int)es->cursor;
d3955 1
a3955 1
			if (es->cursor == undo->cursor) {
d3961 3
a3963 3
			es->cursor--;
			if (es->cursor >= undo->linelen)
				es->linelen--;
d3965 1
a3965 1
				es->cbuf[es->cursor] = undo->cbuf[es->cursor];
d3967 1
a3967 1
			if (es->cursor == 0)
d3971 4
a3974 4
			es->cursor--;
			es->linelen--;
			memmove(&es->cbuf[es->cursor], &es->cbuf[es->cursor + 1],
			    es->linelen - es->cursor + 1);
d3980 1
a3980 1
		if (es->cursor != 0) {
d3982 4
a3985 4
			memmove(es->cbuf, &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen -= es->cursor;
			es->cursor = 0;
d3991 1
a3991 1
		if (es->cursor != 0) {
d3993 4
a3996 4
			memmove(&es->cbuf[tcursor], &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen -= es->cursor - tcursor;
			if (inslen < es->cursor - tcursor)
d3999 2
a4000 2
				inslen -= es->cursor - tcursor;
			es->cursor = tcursor;
d4047 1
a4047 1
		print_expansions(es, 0);
d4059 1
a4059 1
		if (es->linelen >= es->cbufsize - 1)
d4063 7
a4069 7
			memmove(&es->cbuf[es->cursor + 1], &es->cbuf[es->cursor],
			    es->linelen - es->cursor);
			es->linelen++;
		}
		es->cbuf[es->cursor++] = ch;
		if (insert == REPLACE && es->cursor > es->linelen)
			es->linelen++;
d4088 1
a4088 1
			if (cur == es->linelen && cur != 0)
d4090 1
a4090 1
			es->cursor = cur;
d4096 4
a4099 4
			undo->winleft = es->winleft;
			memmove(undo->cbuf, es->cbuf, es->linelen);
			undo->linelen = es->linelen;
			undo->cursor = es->cursor;
d4154 2
a4155 2
			if (es->linelen != 0)
				es->cursor++;
d4163 1
a4163 1
			es->cursor = es->linelen;
d4168 2
a4169 2
			es->cursor = domove(1, "^", 1);
			del_range(es->cursor, es->linelen);
d4185 1
a4185 1
				c2 = es->linelen;
d4193 1
a4193 1
				    !ksh_isspace(es->cbuf[es->cursor])) {
d4196 1
a4196 1
					} while (ksh_isspace(es->cbuf[ncursor]));
d4199 2
a4200 2
				if (ncursor > es->cursor) {
					c1 = es->cursor;
d4204 1
a4204 1
					c2 = es->cursor;
d4213 1
a4213 1
				es->cursor = c1;
d4225 2
a4226 2
			if (es->linelen != 0)
				es->cursor++;
d4230 2
a4231 2
			if (es->cursor != 0)
				es->cursor--;
d4243 2
a4244 2
			if (any && es->cursor != 0)
				es->cursor--;
d4252 1
a4252 1
			del_range(es->cursor, es->linelen);
d4257 4
a4260 4
			yank_range(es->cursor, es->linelen);
			del_range(es->cursor, es->linelen);
			if (es->cursor != 0)
				es->cursor--;
d4289 1
a4289 1
			es->cursor = domove(1, "^", 1);
d4316 1
a4316 1
			if (es->linelen == 0)
d4325 1
a4325 1
				if (es->cursor + argcnt > es->linelen)
d4328 2
a4329 2
					es->cbuf[es->cursor + n] = cmd[1];
				es->cursor += n - 1;
d4340 1
a4340 1
			if (es->linelen == 0)
d4344 3
a4346 3
			if (es->cursor + argcnt > es->linelen)
				argcnt = es->linelen - es->cursor;
			del_range(es->cursor, es->cursor + argcnt);
d4352 1
a4352 1
				if (es->linelen == 0)
d4355 2
a4356 2
					es->cbuf[es->linelen] = '\0';
					histsave(&source->line, es->cbuf,
d4363 1
a4363 1
				shf_snprintf(es->cbuf, es->cbufsize, Tf_sd,
d4367 1
a4367 1
				strlcpy(es->cbuf,
d4369 2
a4370 2
				    es->cbufsize);
			es->linelen = strlen(es->cbuf);
d4374 1
a4374 1
			if (es->linelen == 0)
d4378 4
a4381 4
			if (es->cursor + argcnt > es->linelen)
				argcnt = es->linelen - es->cursor;
			yank_range(es->cursor, es->cursor + argcnt);
			del_range(es->cursor, es->cursor + argcnt);
d4385 1
a4385 1
			if (es->cursor > 0) {
d4388 5
a4392 5
				if (es->cursor < argcnt)
					argcnt = es->cursor;
				yank_range(es->cursor - argcnt, es->cursor);
				del_range(es->cursor - argcnt, es->cursor);
				es->cursor -= argcnt;
d4398 2
a4399 2
			t = es;
			es = undo;
d4447 1
a4447 1
				es->cursor = argcnt - 2;
d4488 2
a4489 2
				if (es->cursor != es->linelen)
					es->cursor++;
d4496 2
a4497 2
					if (es->cursor != 0)
						es->cursor--;
d4509 1
a4509 1
				if (es->linelen == 0)
d4512 1
a4512 1
					p = &es->cbuf[es->cursor];
d4522 2
a4523 2
					if (es->cursor < es->linelen - 1)
						es->cursor++;
d4530 2
a4531 2
				int ret = x_do_comment(es->cbuf, es->cbufsize,
				    &es->linelen);
d4533 1
a4533 1
					es->cursor = 0;
d4541 1
a4541 1
			print_expansions(es, 1);
d4577 2
a4578 2
			if (es->linelen != 0)
				es->cursor++;
d4582 2
a4583 2
		if (insert == 0 && es->cursor != 0 && es->cursor >= es->linelen)
			es->cursor--;
d4596 1
a4596 1
		if (!sub && es->cursor == 0)
d4602 1
a4602 1
		if (!sub && es->cursor == 0)
d4608 1
a4608 1
		if (!sub && es->cursor + 1 >= es->linelen)
d4611 1
a4611 1
		if (sub && ncursor < es->linelen)
d4616 1
a4616 1
		if (!sub && es->cursor + 1 >= es->linelen)
d4619 1
a4619 1
		if (sub && ncursor < es->linelen)
d4647 1
a4647 1
		if (!sub && es->cursor == 0)
d4649 1
a4649 1
		ncursor = es->cursor - argcnt;
d4656 1
a4656 1
		if (!sub && es->cursor + 1 >= es->linelen)
d4658 4
a4661 4
		if (es->linelen != 0) {
			ncursor = es->cursor + argcnt;
			if (ncursor > es->linelen)
				ncursor = es->linelen;
d4666 1
a4666 1
		if (!sub && es->cursor + 1 >= es->linelen)
d4672 1
a4672 1
		if (!sub && es->cursor + 1 >= es->linelen)
d4683 2
a4684 2
		while (ncursor < es->linelen - 1 &&
		    ksh_isspace(es->cbuf[ncursor]))
d4690 2
a4691 2
		if (ncursor > es->linelen)
			ncursor = es->linelen;
d4697 2
a4698 2
		if (es->linelen != 0)
			ncursor = es->linelen;
d4704 3
a4706 3
		ncursor = es->cursor;
		while (ncursor < es->linelen &&
		    (i = bracktype(es->cbuf[ncursor])) == 0)
d4708 1
a4708 1
		if (ncursor == es->linelen)
d4713 1
a4713 1
				if (++ncursor >= es->linelen)
d4719 1
a4719 1
			t = bracktype(es->cbuf[ncursor]);
d4741 2
a4742 2
	if (es->cursor > 0)
		es->cursor--;
d4752 1
a4752 1
		memmove(ybuf, &es->cbuf[a], yanklen);
d4790 2
a4791 2
	memmove(holdbufp, es->cbuf, es->linelen);
	holdlen = es->linelen;
d4798 3
a4800 3
	es->cursor = 0;
	es->linelen = holdlen;
	memmove(es->cbuf, holdbufp, holdlen);
d4851 1
a4851 1
		if (es->cursor + len >= es->cbufsize)
d4853 2
a4854 2
		if (es->cursor + len > es->linelen)
			es->linelen = es->cursor + len;
d4856 1
a4856 1
		if (es->linelen + len >= es->cbufsize)
d4858 3
a4860 3
		memmove(&es->cbuf[es->cursor + len], &es->cbuf[es->cursor],
		    es->linelen - es->cursor);
		es->linelen += len;
d4862 2
a4863 2
	memmove(&es->cbuf[es->cursor], buf, len);
	es->cursor += len;
d4870 3
a4872 3
	if (es->linelen != b)
		memmove(&es->cbuf[a], &es->cbuf[b], es->linelen - b);
	es->linelen -= b - a;
d4880 1
a4880 1
	if (es->linelen == 0)
d4882 1
a4882 1
	ncursor = es->cursor;
d4886 1
a4886 1
				if (++ncursor == es->linelen)
d4892 1
a4892 1
		} while (es->cbuf[ncursor] != ch);
d4908 5
a4912 5
	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		if (ksh_isalnux(es->cbuf[ncursor]))
			while (ncursor < es->linelen &&
			    ksh_isalnux(es->cbuf[ncursor]))
d4914 4
a4917 4
		else if (!ksh_isspace(es->cbuf[ncursor]))
			while (ncursor < es->linelen &&
			    !ksh_isalnux(es->cbuf[ncursor]) &&
			    !ksh_isspace(es->cbuf[ncursor]))
d4919 2
a4920 2
		while (ncursor < es->linelen &&
		    ksh_isspace(es->cbuf[ncursor]))
d4931 1
a4931 1
	ncursor = es->cursor;
d4933 1
a4933 1
		while (--ncursor > 0 && ksh_isspace(es->cbuf[ncursor]))
d4936 1
a4936 1
			if (ksh_isalnux(es->cbuf[ncursor]))
d4938 1
a4938 1
				    ksh_isalnux(es->cbuf[ncursor]))
d4942 2
a4943 2
				    !ksh_isalnux(es->cbuf[ncursor]) &&
				    !ksh_isspace(es->cbuf[ncursor]))
d4956 4
a4959 4
	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		while (++ncursor < es->linelen - 1 &&
		    ksh_isspace(es->cbuf[ncursor]))
d4961 4
a4964 4
		if (ncursor < es->linelen - 1) {
			if (ksh_isalnux(es->cbuf[ncursor]))
				while (++ncursor < es->linelen &&
				    ksh_isalnux(es->cbuf[ncursor]))
d4967 3
a4969 3
				while (++ncursor < es->linelen &&
				    !ksh_isalnux(es->cbuf[ncursor]) &&
				    !ksh_isspace(es->cbuf[ncursor]))
d4982 4
a4985 4
	ncursor = es->cursor;
	while (ncursor < es->linelen && argcnt--) {
		while (ncursor < es->linelen &&
		    !ksh_isspace(es->cbuf[ncursor]))
d4987 2
a4988 2
		while (ncursor < es->linelen &&
		    ksh_isspace(es->cbuf[ncursor]))
d4999 1
a4999 1
	ncursor = es->cursor;
d5001 1
a5001 1
		while (--ncursor >= 0 && ksh_isspace(es->cbuf[ncursor]))
d5003 1
a5003 1
		while (ncursor >= 0 && !ksh_isspace(es->cbuf[ncursor]))
d5015 4
a5018 4
	ncursor = es->cursor;
	while (ncursor < es->linelen - 1 && argcnt--) {
		while (++ncursor < es->linelen - 1 &&
		    ksh_isspace(es->cbuf[ncursor]))
d5020 3
a5022 3
		if (ncursor < es->linelen - 1) {
			while (++ncursor < es->linelen &&
			    !ksh_isspace(es->cbuf[ncursor]))
d5049 4
a5052 4
	if ((es->linelen = strlen(hptr)) >= es->cbufsize)
		es->linelen = es->cbufsize - 1;
	memmove(es->cbuf, hptr, es->linelen);
	es->cursor = 0;
d5083 4
a5086 4
	if ((es->linelen = strlen(hptr)) >= es->cbufsize)
		es->linelen = es->cbufsize - 1;
	memmove(es->cbuf, hptr, es->linelen);
	es->cursor = 0;
d5121 1
a5121 1
	if (es->cursor < es->winleft)
d5124 3
a5126 3
	cur = es->winleft;
	while (cur < es->cursor)
		col = newcol((unsigned char)es->cbuf[cur++], col);
d5141 1
a5141 1
	while (tcur < es->cursor) {
d5148 1
a5148 1
		tcol = newcol((unsigned char)es->cbuf[tcur++], tcol);
d5151 1
a5151 1
		holdcol1 = newcol((unsigned char)es->cbuf[holdcur1++],
d5153 1
a5153 1
	es->winleft = holdcur1;
d5174 1
a5174 1
	cur = es->winleft;
d5177 2
a5178 2
	while (col < winwidth && cur < es->linelen) {
		if (cur == es->cursor && leftside)
d5180 1
a5180 1
		if ((ch = es->cbuf[cur]) == '\t')
d5196 1
a5196 1
		if (cur == es->cursor && !leftside)
d5200 1
a5200 1
	if (cur == es->cursor)
d5226 1
a5226 1
	if (es->winleft > 0 && moreright)
d5232 1
a5232 1
	else if (es->winleft > 0)
d5280 1
a5280 1
		restore_edstate(es, buf);
d5291 1
a5291 1
	nwords = x_cf_glob(&i, es->cbuf, es->linelen, es->cursor,
d5298 1
a5298 1
	buf = save_edstate(es);
d5301 1
a5301 1
	es->cursor = start;
d5315 1
a5315 1
		es->cursor += i;
d5341 1
a5341 1
		restore_edstate(es, buf);
d5358 1
a5358 1
	nwords = x_cf_glob(&flags, es->cbuf, es->linelen, es->cursor,
d5403 1
a5403 1
	buf = save_edstate(es);
d5405 1
a5405 1
	es->cursor = start;
@


1.317
log
@plug a small memory leak
@
text
@d5557 1
a5557 1
		wds[0] = FUNSUB;
@


1.316
log
@handle multibyte backspace in ^R
@
text
@d5563 1
@


1.315
log
@do not output incomplete multibyte chars in ^R
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.309 2016/11/11 20:14:16 tg Exp $");
d1929 4
a1932 2
			if (p > pat)
				*--p = '\0';
@


1.314
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.313 2017/03/11 22:49:54 tg Exp $");
d2940 6
a2945 2
			while (*cp < cp2)
				x_putcf(*(*cp)++);
@


1.313
log
@fixup tilde expansion comments; revert a few bogus dirsep changes

cf. <Pine.BSM.4.64L.1703112129500.29506@@herc.mirbsd.org>
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.309 2016/11/11 20:14:16 tg Exp $");
d148 3
d172 1
@


1.312
log
@gcc 6.2 warnings (stupid uninitialised that wasn't, plus FALLTHROUGH fixes)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d342 1
a342 1
	if (*s == '~' && (cp = mksh_sdirsep(s)) != NULL) {
d661 1
a661 1
		if (*toglob == '~' && !mksh_vdirsep(toglob)) {
@


1.311
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d4168 2
d4406 2
d4546 1
d4619 1
a4619 2
		/* drop through */

@


1.310
log
@make print -c honour line separator
@
text
@d261 2
a262 1
			while (prefix_len > 0 && words[0][prefix_len - 1] != '/')
d342 1
a342 1
	if (*s == '~' && (cp = strchr(s, '/')) != NULL) {
d597 1
a597 1
				if (buf[p] == '/')
d661 1
a661 1
		if (*toglob == '~' && !vstrchr(toglob, '/')) {
d750 9
a758 7
	/* Skip trailing slashes */
	for (p = se - 1; p > s && *p == '/'; p--)
		;
	for (; p > s && *p != '/'; p--)
		;
	if (*p == '/' && p + 1 < se)
		p++;
d2789 1
a2789 1
	if (nwords == 1 && words[0][nlen - 1] != '/' &&
d5410 1
a5410 1
		if (match_len > 0 && match[match_len - 1] != '/' &&
@


1.309
log
@put print_columns options into a helper struct, eases passing things around
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.294 2016/03/04 14:26:12 tg Exp $");
d276 2
@


1.308
log
@first implementation of “print -c” for columnising, currently hardcoded newlines
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.307 2016/09/01 12:59:08 tg Exp $");
d241 1
d275 3
a277 1
	pr_list(shl_out, use_copy ? (char **)XPptrv(l) : words);
@


1.307
log
@fix English (thanks to Andreas Buschka); TIL:
• to start ⇒ a start
• to begin ⇒ a beginning
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.294 2016/03/04 14:26:12 tg Exp $");
d274 1
a274 1
	pr_list(use_copy ? (char **)XPptrv(l) : words);
@


1.306
log
@clean up chtypes use
@
text
@d1051 1
a1051 1
	{ XFUNC_mv_begin,		0, CTRL('A')	},
d1109 2
a1110 2
	{ XFUNC_mv_begin | 0x80,	2,	'7'	},
	{ XFUNC_mv_begin,		2,	'H'	},
d1122 1
a1122 1
	{ XFUNC_mv_begin,		3,	71	},
d2047 1
a2047 1
x_mv_begin(int c MKSH_A_UNUSED)
d2331 1
a2331 1
		return (x_mv_begin(0));
d4019 1
a4019 1
	/* { Begin nonstandard vi commands */
d4038 1
a4038 1
	/* End nonstandard vi commands } */
@


1.305
log
@fix sign comparison warning pointed out by Debian’s GCC

this commit sponsored by ⮡ tarent
@
text
@a845 1
	const char *ifs = str_val(local("IFS", 0));
d850 1
a850 1
		    vstrchr(ifs, s[add])) {
@


1.304
log
@fix two int→size_t; reduce edchar struct size
@
text
@d1777 1
a1777 1
	char *cp = &tmp;
@


1.303
log
@this hack from commitid 1004651F21443013C37 is no longer necessary (thought so)
@
text
@d44 20
a63 10
typedef struct {
	int erase;
	int kill;
	int werase;
	int intr;
	int quit;
	int eof;
} X_chars;

static X_chars edchars;
d92 1
a92 1
static int x_basename(const char *, const char *);
d239 1
a239 1
	int prefix_len;
d448 2
a449 2
	int base;
	int path_order;
d460 7
a466 2
	t = strcmp(a->word + a->base, b->word + b->base);
	return (t ? t : a->path_order - b->path_order);
d734 1
a734 1
static int
d1776 1
a1776 1
	char tmp = edchars.eof;
d1779 2
d3293 5
a3297 5
		edchars.erase = tty_state.c_cc[VERASE];
		edchars.kill = tty_state.c_cc[VKILL];
		edchars.intr = tty_state.c_cc[VINTR];
		edchars.quit = tty_state.c_cc[VQUIT];
		edchars.eof = tty_state.c_cc[VEOF];
d3299 1
a3299 1
		edchars.werase = tty_state.c_cc[VWERASE];
d3317 1
a3317 17
#ifdef _POSIX_VDISABLE
		/* Convert unset values to internal 'unset' value */
		if (edchars.erase == _POSIX_VDISABLE)
			edchars.erase = -1;
		if (edchars.kill == _POSIX_VDISABLE)
			edchars.kill = -1;
		if (edchars.intr == _POSIX_VDISABLE)
			edchars.intr = -1;
		if (edchars.quit == _POSIX_VDISABLE)
			edchars.quit = -1;
		if (edchars.eof == _POSIX_VDISABLE)
			edchars.eof = -1;
		if (edchars.werase == _POSIX_VDISABLE)
			edchars.werase = -1;
#endif

		if (edchars.erase >= 0) {
d3321 1
a3321 1
		if (edchars.kill >= 0)
d3323 1
a3323 1
		if (edchars.werase >= 0)
d3325 1
a3325 1
		if (edchars.intr >= 0)
d3327 1
a3327 1
		if (edchars.quit >= 0)
d3566 2
a3567 1
			if (c == edchars.intr || c == edchars.quit) {
d3571 2
a3572 1
				trapsig(c == edchars.intr ? SIGINT : SIGQUIT);
d3575 2
a3576 1
			} else if (c == edchars.eof && state != VVERSION) {
d3578 1
a3578 1
					x_vi_zotc(edchars.eof);
d3765 1
a3765 1
		} else if (ch == edchars.erase || ch == CTRL('h')) {
d3776 1
a3776 1
		} else if (ch == edchars.kill) {
d3782 1
a3782 1
		} else if (ch == edchars.werase) {
d3936 1
a3936 1
	if (ch == edchars.erase || ch == CTRL('h')) {
d3962 1
a3962 1
	if (ch == edchars.kill) {
d3973 1
a3973 1
	if (ch == edchars.werase) {
d5475 2
a5476 2
	 * Set edchars to -2 to force initial binding, except
	 * we need default values for some deficient systems…
d5479 1
a5479 2
	    edchars.eof = -2;
	/* ^W */
@


1.302
log
@implement new evaluate-region editing command (!MKSH_SMALL)

while here, fixup x_redraw refactoring x_clrtoeol, x_pprompt, and x_lastpos
@
text
@d1384 1
a1384 3
	if (xlp == xep - 1)
		x_redraw('\r');
	else if (adj == x_adj_done)
@


1.301
log
@the limit parameter to x_redraw was completely bogus, drop it for now
@
text
@a963 1
static int x_size_str(char *);
d988 1
d1124 1
a1383 7
	/* has x_adjust() been called? */
	if (adj == x_adj_done) {
		/* no */
		cp = xlp;
		while (cp > xcp)
			x_bs3(&cp);
	}
d1386 3
d1495 1
a1495 4
	cp = x_lastcp();
	while (cp > xcp)
		x_bs3(&cp);

a1614 9
x_size_str(char *cp)
{
	int size = 0;
	while (*cp)
		size += x_size2(cp, &cp);
	return (size);
}

static int
d2054 41
a2094 1
/* output cr (if ≠ 0), then redraw the line, clearing to EOL if needed */
d2098 1
a2098 3
	int i, j;
	char *cp;
	int limit = xx_cols; /*XXX tbm in the next commit */
d2101 1
d2104 3
a2106 5
	if (xbp == xbuf) {
		if (prompt_trunc != -1)
			pprompt(prompt, prompt_trunc);
		x_col = pwidth;
	}
d2108 1
d2111 6
a2116 40
	if (limit >= xx_cols || xbp != xbuf || xep > xlp)
		limit = xx_cols;
	if (limit == xx_cols && x_term_mode == 1 && xbp == xbuf && xep <= xlp)
		shf_puts("\033[K", shl_out);
	else if (limit >= 0) {
		if (xep > xlp)
			/* we fill the line */
			i = 0;
		else {
			char *cpl = xbp;

			i = limit;
			while (cpl < xlp)
				i -= x_size2(cpl, &cpl);
		}

		j = 0;
		while ((j < i) || (x_col < (xx_cols - 2))) {
			if (!(x_col < (xx_cols - 2)))
				break;
			x_e_putc2(' ');
			j++;
		}
		i = ' ';
		if (xep > xlp) {
			/* more off screen */
			if (xbp > xbuf)
				i = '*';
			else
				i = '>';
		} else if (xbp > xbuf)
			i = '<';
		x_e_putc2(i);
		j++;
		while (j--)
			x_e_putc2('\b');
	}
	cp = xlp;
	while (cp > xcp)
		x_bs3(&cp);
a2117 1
	return;
a3230 3
 * SYNOPSIS:
 *	x_lastcp()
 *
d3234 1
a3234 10
 *	screen. The sequence:
 *
 *	cp = x_lastcp();
 *	while (cp > xcp)
 *		x_bs3(&cp);
 *
 *	Will position the cursor correctly on the screen.
 *
 * RETURN VALUE:
 *	cp or NULL
d3256 10
d5076 1
a5076 3
	if (prompt_trunc != -1)
		pprompt(prompt, prompt_trunc);
	x_col = pwidth;
d5231 1
a5231 3
			if (prompt_trunc != -1)
				pprompt(prompt, prompt_trunc);
			x_col = pwidth;
d5524 75
@


1.300
log
@eek, forgot some conditions
@
text
@d975 1
a975 1
static void x_push(int);
d1391 1
a1391 1
		x_redraw(xx_cols);
d1954 1
a1954 1
		x_redraw(-1);
a2028 2
	int i, j;

d2030 1
a2030 4
	i = xep - xbuf;
	j = x_size_str(xbuf);
	xcp = xbuf;
	x_push(i);
d2035 1
a2035 1
	x_redraw(j);
d2057 1
a2057 1
	x_redraw(-1);
d2065 1
a2065 1
	x_adjust();
d2069 1
a2069 5
/*
 * Redraw (part of) the line. If limit is < 0, the everything is redrawn
 * on a NEW line, otherwise limit is the screen column up to which needs
 * redrawing.
 */
d2071 1
a2071 1
x_redraw(int limit)
d2075 1
d2078 1
a2078 4
	if (limit == -1)
		x_e_putc2('\n');
	else
		x_e_putc2('\r');
d2247 1
a2247 1
x_push(int nchars)
d2264 1
a2264 1
		x_redraw(-1);
d2281 1
a2281 1
		x_redraw(-1);
d2841 1
a2841 1
	x_redraw(xx_cols);
d3012 1
a3012 1
		x_redraw(xx_cols);
a3023 2
	int lim = x_lastcp() - xbp;
	size_t vlen;
d3029 2
a3030 2
	xend = xep = v + (vlen = strlen(v));
	x_redraw(lim);
d3039 1
a3039 1
	x_redraw((int)vlen);
@


1.299
log
@make tmux hack workable for now (libtermcap is… ugly)

• track $TERM for the types tmux uses /^screen(-.*)?$/
• when tmux is in use (or GNU screen, really), use the, now
  hardcoded, clear-to-EOL string; otherwise, use the old behaviour
• drop unnecessary x_e_rebuildline()

carefully tested to behave no worse than R52b
@
text
@d2101 1
a2101 1
	if (limit == xx_cols && x_term_mode == 1)
@


1.298
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@a41 3
#ifndef MKSH_CLRTOEOL_STRING
#define MKSH_CLRTOEOL_STRING	"\033[K"
#endif
d68 4
a105 1
static int x_e_rebuildline(const char *);
d152 1
a152 1
					x_e_rebuildline(null);
a979 1
static void x_adjust(void);
d2067 1
a2067 1
x_e_rebuildline(const char *clrstr)
d2069 1
a2069 1
	shf_puts(clrstr, shl_out);
a2073 6
static int
x_cls(int c MKSH_A_UNUSED)
{
	return (x_e_rebuildline(MKSH_CLS_STRING));
}

d2100 3
a2102 1
		shf_puts(MKSH_CLRTOEOL_STRING, shl_out);
d5545 10
@


1.297
log
@experimentally use MKSH_CLRTOEOL_STRING instead of lots of spaces followed
by lots of backspaces for many clearing scenarios; requested by tmux user
slagtc on IRC
@
text
@d335 1
a335 1
			cp = shf_smprintf("%s/%s", dp, cp);
d474 1
a474 1
	if ((fpath = str_val(global("FPATH"))) != null)
d1665 1
a1665 1
		x_e_puts("    ");
d2446 1
a2446 1
		shprintf("%s\n", x_ftab[XFUNC_VALUE(f)].xf_name);
d2478 1
a2478 1
				shprintf("%s\n", x_ftab[f].xf_name);
d2712 1
a2712 1
		    (++i < nwords && x_ins(" ") < 0)) {
d2797 1
a2797 1
		x_ins(" ");
d3086 1
a3086 1
		shf_snprintf(xbuf, xend - xbuf, "%s %d",
d4374 1
a4374 1
				shf_snprintf(es->cbuf, es->cbufsize, "%s %d",
d4503 1
a4503 1
				if (putbuf(" ", 1, false) != 0 ||
d5321 1
a5321 1
		if (++i < nwords && putbuf(" ", 1, false) != 0) {
d5439 1
a5439 1
			rval = putbuf(" ", 1, false);
@


1.296
log
@fix utf_widthadj/utf_skipcols handling for the remaining cases I can spot
@
text
@d152 1
a152 1
					x_e_rebuildline(MKSH_CLRTOEOL_STRING);
d1186 6
a1834 1
	int oldsize;
a1846 1
	oldsize = x_size_str(xbuf);
d1852 1
a1852 5
	xlp_valid = false;
	if (xep <= x_lastcp()) {
		x_redraw(oldsize);
	}
	x_goto(xep);
d2106 3
a2108 3
	if (xbp != xbuf || xep > xlp)
		limit = xx_cols;
	if (limit >= 0) {
a3017 1
	int oldsize = x_size_str(xbuf);
d3028 1
a3028 1
		x_redraw(oldsize);
@


1.295
log
@fix order of bounds checks; inspired by NetBSD#50747
@
text
@d1579 1
a1579 1
	if (cp < xbp || cp >= utf_skipcols(xbp, x_displen)) {
@


1.294
log
@address latest Debian gcc-snapshot’s warnings (some actual bugs!)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.280 2014/11/25 21:13:22 tg Exp $");
d4921 2
a4922 2
			while (ksh_isalnux(es->cbuf[ncursor]) &&
			    ncursor < es->linelen)
d4925 3
a4927 3
			while (!ksh_isalnux(es->cbuf[ncursor]) &&
			    !ksh_isspace(es->cbuf[ncursor]) &&
			    ncursor < es->linelen)
d4929 2
a4930 2
		while (ksh_isspace(es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
d4994 2
a4995 2
		while (!ksh_isspace(es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
d4997 2
a4998 2
		while (ksh_isspace(es->cbuf[ncursor]) &&
		    ncursor < es->linelen)
@


1.293
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d4600 2
a4601 2
	int bcount, i = 0, t;
	int ncursor = 0;
@


1.292
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013, 2014, 2015
d384 1
a384 1
		internal_warningf("%s: %s", "fileglob", "bad substitution");
d2519 1
a2519 1
		bi_errorf("%s: %s", "too long key sequence", msg);
d2543 1
a2543 1
			bi_errorf("%s: %s %s", a2, "no such", Tfunction);
d5054 1
a5054 1
		internal_warningf("%s: %s", "grabhist", "bad history array");
@


1.291
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d3 2
a4 2
/*	$OpenBSD: emacs.c,v 1.51 2015/09/01 13:12:31 tedu Exp $	*/
/*	$OpenBSD: vi.c,v 1.29 2015/09/01 13:12:31 tedu Exp $	*/
d9 1
a9 1
 *	mirabilos <tg@@mirbsd.org>
@


1.290
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.40 2015/03/12 10:20:30 sthen Exp $	*/
d3 2
a4 2
/*	$OpenBSD: emacs.c,v 1.50 2015/03/25 12:10:52 jca Exp $	*/
/*	$OpenBSD: vi.c,v 1.28 2013/12/18 16:45:46 deraadt Exp $	*/
d8 2
a9 2
 *		 2011, 2012, 2013, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
d2265 2
a2266 6
	char *cp;

	strndupx(cp, xcp, nchars, AEDIT);
	if (killstack[killsp])
		afree(killstack[killsp], AEDIT);
	killstack[killsp] = cp;
@


1.289
log
@implement support for PC scancodes à la CHR$(0)+CHR$(&h48)
superseding an mksh-os2 patch which confirmed this is needed

Reference: my copy of the Schneider EURO PC manual 50032 for
Microsoft® GW-BASIC
@
text
@d774 1
a774 1
		if (!(p = cstrchr(sp, ':')))
@


1.288
log
@an edchar cannot conceivably be NUL, so set them to the default;
this is confirmed to help fix OS/2 and plugs an uninitialised read
on systems without werase
@
text
@d890 1
a890 1
#define X_NTABS		3			/* normal, meta1, meta2 */
d1102 1
a1102 1
       { XFUNC_del_char,               2,      'P'     },
d1105 19
d2238 7
d2442 2
a2443 2
		shf_puts(x_mapout(prefix == 1 ?
		    CTRL('[') : CTRL('X')), shl_stdout);
d2508 2
d3649 12
d3668 1
d3691 1
d3860 1
@


1.287
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d3294 2
d3298 13
@


1.286
log
@add binding for another well-known ANSI Del key

From: Ivan Delalande <colona@@ycc.fr>
@
text
@d3057 1
a3057 1
			histsave(&source->line, xbuf, true, true);
d4314 2
a4315 2
					histsave(&source->line, es->cbuf, true,
					    true);
@


1.285
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d1102 1
@


1.284
log
@just another oksh rcsid-only sync (we bind to the Delete key since forever)
@
text
@d2969 1
a2969 1
		n = n * 10 + (c - '0');
d3630 2
a3631 2
			if (ch >= '1' && ch <= '9') {
				argc1 = ch - '0';
d3675 1
a3675 1
			argc1 = argc1 * 10 + ch - '0';
d3684 2
a3685 2
		if (ch >= '1' && ch <= '9') {
			argc2 = ch - '0';
d3701 1
a3701 1
			argc2 = argc2 * 10 + ch - '0';
@


1.283
log
@oksh rcsid sync; we have no set -o csh-history, and the manpage changes are just wrong, so, a nop
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.49 2015/02/16 01:44:41 tedu Exp $	*/
@


1.282
log
@another oksh rcsid-only sync
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.39 2013/12/17 16:37:05 deraadt Exp $	*/
@


1.281
log
@no need for this explicit one, emacsfn.h already defines them
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.48 2013/12/17 16:37:05 deraadt Exp $	*/
@


1.280
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.279 2014/11/19 21:52:16 tg Exp $");
a88 1
static int x_meta1(int);
@


1.279
log
@prototype for a static function used before it’s defined

XXX add protos for all static functions (just: hard to find them)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.278 2014/11/19 21:49:10 tg Exp $");
a595 2
	mkssert(buf != NULL);

a2240 1
	mkssert(xcp != NULL);
@


1.278
log
@rename the “tilde” function; apparently, some system headers define it
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.277 2014/11/14 20:00:40 tg Exp $");
d89 1
@


1.277
log
@Get rid of left over NULL elements in x_ftab as NELEM() is used instead.
From Martin Natano. Also get rid of related checks.
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.274 2014/01/05 19:11:43 tg Exp $");
d330 1
a330 1
		if (!(dp = tilde(s + 1))) {
@


1.276
log
@fix rare infinite loop when invalid UTF-8 is in the edit buffer
From: Ivan “Colona” Delalande <colona@@ycc.fr>
@
text
@a1011 1
	{ 0, NULL, 0 }
d2457 1
a2457 2
			if (x_ftab[f].xf_name &&
			    !(x_ftab[f].xf_flags & XF_NOBIND))
d2518 1
a2518 2
			if (x_ftab[f].xf_name &&
			    strcmp(x_ftab[f].xf_name, a2) == 0)
@


1.276.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.277 2014/11/14 20:00:40 tg Exp $");
d1012 1
d2458 2
a2459 1
			if (!(x_ftab[f].xf_flags & XF_NOBIND))
d2520 2
a2521 1
			if (!strcmp(x_ftab[f].xf_name, a2))
@


1.276.2.2
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.276.2.1 2015/01/11 22:39:45 tg Exp $");
d330 1
a330 1
		if (!(dp = do_tilde(s + 1))) {
d595 2
d2242 1
@


1.276.2.3
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.49 2015/02/16 01:44:41 tedu Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.276.2.2 2015/01/25 15:35:41 tg Exp $");
@


1.276.2.4
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.40 2015/03/12 10:20:30 sthen Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.276.2.3 2015/03/01 15:42:56 tg Exp $");
@


1.276.2.5
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.50 2015/03/25 12:10:52 jca Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.276.2.4 2015/03/20 22:20:58 tg Exp $");
@


1.275
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d1631 1
a1631 1
	while (*str && str < xlp && adj == x_adj_done)
@


1.274
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@d8 1
a8 1
 *		 2011, 2012, 2013
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.273 2013/11/30 17:33:48 tg Exp $");
d964 1
a964 1
static char *x_bs0(char *, char *);
d993 1
a993 1
static size_t x_nb2nc(size_t);
d3356 1
a3356 1
static int findch(int, int, bool, bool);
d3766 1
a3766 1
			int i, n = srchlen;
d3769 1
a3769 1
			new_es.cursor = n;
d3777 2
a3778 1
			for (i = srchlen; --i >= n; )
d3780 1
a3780 1
			srchlen = n;
@


1.273
log
@RCSID-only oksh sync (their whitespace changes don’t apply to us)
note that emacs.c partial peereboom rewrite is *not* merged, and kept that way
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.38 2013/06/03 15:41:59 tedu Exp $	*/
d3 2
a4 2
/*	$OpenBSD: emacs.c,v 1.47 2013/11/28 10:33:37 sobrado Exp $	*/
/*	$OpenBSD: vi.c,v 1.26 2009/06/29 22:50:19 martynas Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.272 2013/09/24 20:19:42 tg Exp $");
d3550 1
a3550 1
			c = *macro.p++;
@


1.272
log
@slightly optimised and, more importantly, much more consistent (use only
one set of CTRL, UNCTRL, and new ISCTRL macros) C0 and DEL handling; the
optimisation only works for 7-bit ASCII, so those places 8-bit must pass
intact have an added check

also, while here, remove an editor oops (‘;’), oksh rcsid sync (they did
accept I was right wrt. set -e), int → bool, and code merge/cleanup
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.44 2011/09/05 04:50:33 marco Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.271 2013/08/16 10:59:01 tg Exp $");
@


1.271
log
@Ypnose discovered a problem with multi-line prompts and SIGWINCH
related to caching some values (downside, pprompt gets back doprint option)
@
text
@d1 1
a1 1
;/*	$OpenBSD: edit.c,v 1.38 2013/06/03 15:41:59 tedu Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.270 2013/08/14 20:26:17 tg Exp $");
a968 1
static void x_zotc2(int);
d1610 1
a1610 1
	int c = *(unsigned char *)cp;
d1619 1
a1619 1
	if (c < ' ' || c == 0x7f)
a1635 13
x_zotc2(int c)
{
	if (c == '\t') {
		/* Kludge, tabs are always four spaces. */
		x_e_puts("    ");
	} else if (c < ' ' || c == 0x7f) {
		x_e_putc2('^');
		x_e_putc2(UNCTRL(c));
	} else
		x_e_putc2(c);
}

static void
d1644 1
a1644 1
	} else if (c < ' ' || c == 0x7f) {
d1756 4
a1759 1
	x_zotc2(edchars.eof);
d2371 1
d2393 1
a2393 1
	if (c < ' ' || c == 0x7f) {
a3335 2
#define Ctrl(c)		(c&0x1f)

d3369 1
a3369 1
static int newcol(int, int);
d3375 2
a3376 1
#define char_len(c)	((c) < ' ' || (c) == 0x7F ? 2 : 1)
d3612 1
a3612 1
			if (ch == Ctrl('v')) {
d3724 1
a3724 1
		if (ch == Ctrl('['))
d3733 1
a3733 1
		if (ch == '\r' || ch == '\n' /*|| ch == Ctrl('[')*/ ) {
d3748 1
a3748 1
		} else if (ch == edchars.erase || ch == Ctrl('h')) {
d3751 1
a3751 1
				es->linelen -= char_len((unsigned char)locpat[srchlen]);
d3778 1
a3778 1
				es->linelen -= char_len((unsigned char)locpat[i]);
d3788 1
a3788 1
				if (ch < ' ' || ch == 0x7f) {
d3793 1
a3793 1
					es->cbuf[es->linelen++] = ch ^ '@@';
d3904 1
a3904 1
	else if (ch == Ctrl('v'))
d3917 1
a3917 1
	if (ch == edchars.erase || ch == Ctrl('h')) {
d3974 1
a3974 1
	if (first_insert && ch != Ctrl('['))
d3984 1
a3984 1
	case Ctrl('['):
d4002 1
a4002 1
	case Ctrl('x'):
d4006 1
a4006 1
	case Ctrl('f'):
d4010 1
a4010 1
	case Ctrl('e'):
d4014 1
a4014 1
	case Ctrl('i'):
d4069 2
a4070 2
		case Ctrl('l'):
		case Ctrl('r'):
d4257 1
a4257 1
		case Ctrl('n'):
d4268 1
a4268 1
		case Ctrl('p'):
d4500 1
a4500 1
		case Ctrl('e'):
d4506 1
a4506 1
		case Ctrl('i'):
d4513 1
a4513 1
		case Ctrl('['):
d4519 1
a4519 1
		case Ctrl('f'):
d4527 1
a4527 1
		case Ctrl('x'):
d4606 1
a4606 1
	case Ctrl('h'):
d5022 1
a5022 1
	int anchored;
d5030 1
a5030 1
	anchored = *pat == '^' ? (++pat, 1) : 0;
d5119 1
a5119 1
newcol(int ch, int col)
d5147 1
a5147 1
			if (ch < ' ' || ch == 0x7f) {
d5150 1
a5150 1
					*twb1++ = ch ^ '@@';
d5427 1
a5427 1
	if (c < ' ' || c == 0x7f) {
d5429 1
a5429 1
		c ^= '@@';
@


1.270
log
@fun: when writing this code I feared an off-by-one;
Steffen Daode Nurpmeso stumbled upon it and gave very detailed
instructions on how to reproduce it (thanks!); fix that

also only call x_bs0 if xcp < xep because *xep is undefined
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.38 2013/06/03 15:41:59 tedu Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.269 2013/08/10 13:44:29 tg Exp $");
d85 1
a85 1
static void x_init_prompt(void);
d151 1
d1171 1
a1171 1
x_init_prompt(void)
d1173 1
a1173 1
	prompt_trunc = pprompt(prompt, 0);
d1180 2
a1181 1
		x_e_putc2('\n');
d1201 1
a1201 1
	x_init_prompt();
d3540 1
a3540 1
	x_init_prompt();
@


1.269
log
@reduce amount of .bss memory needed; initialise via AEDIT at x_init
or even first run of x_vi
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.268 2013/07/26 20:33:37 tg Exp $");
d2831 2
a2832 2
	/* fix up xbp to character begin first */
	xbp = x_bs0(xcp, xbuf);
d2839 1
a2839 1
	if (xbp == xbuf && xcp != xbuf && col_left > 0 && col_left < pwidth) {
@


1.268
log
@• Completely overhaul prompt length calculation and
  prompt display routines; make Emacs and Vi share
  code, permitting reducing of duplication and code
  removal as well as more consistent behaviour; put
  some common code into shared helper functions, too
• New x_adjust() logic (Emacs mode): when determining
  what portion of a line to render use a much more
  sophisticated algorithm and try to fill up ⅔ of the
  total screen width (with line and prompt both) also
  as wished from Steffen Daode Nurpmeso
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.265 2013/02/10 19:05:36 tg Exp $");
d69 1
a69 1
static char holdbuf[LINE];		/* place to hold last edit buffer */
d84 1
a84 1
static int x_emacs(char *, size_t);
d87 1
a87 1
static int x_vi(char *, size_t);
d113 1
a113 1
x_read(char *buf, size_t len)
d120 1
a120 1
		i = x_emacs(buf, len);
d123 1
a123 1
		i = x_vi(buf, len);
d1184 1
a1184 1
x_emacs(char *buf, size_t len)
d1189 2
a1190 1
	xbp = xbuf = buf; xend = buf + len;
d1825 1
a1825 1
		sp = holdbuf;
d1836 1
a1836 1
		strlcpy(holdbuf, xbuf, sizeof(holdbuf));
d3364 1
a3364 1
static int putbuf(const char *, ssize_t, int);
d3366 1
a3366 1
static int findch(int, int, int, int);
a3463 2
static char		undocbuf[LINE];

d3469 1
a3469 1
static struct edstate	undobuf = { undocbuf, 0, LINE, 0, 0 };
d3471 1
a3471 1
static struct edstate	*es;			/* current editor state */
d3474 2
a3475 2
static char ibuf[LINE];			/* input buffer */
static int first_insert;		/* set when starting in insert mode */
d3479 1
a3479 1
static char ybuf[LINE];			/* yank buffer */
d3487 1
a3487 1
static int insert;			/* non-zero in insert mode */
d3513 1
a3513 1
x_vi(char *buf, size_t len)
d3521 1
a3521 1
	first_insert = 1;
d3525 10
a3535 1
	es->cbuf = buf;
a3536 5
	undo->cbufsize = es->cbufsize = len > LINE ? LINE : len;

	es->linelen = undo->linelen = 0;
	es->cursor = undo->cursor = 0;
	es->winleft = undo->winleft = 0;
d3541 3
a3543 4
	if (!wbuf_len || wbuf_len != x_cols - 3) {
		wbuf_len = x_cols - 3;
		wbuf[0] = aresize(wbuf[0], wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], wbuf_len, APERM);
d3600 1
a3600 1
	if (c == -1 || (ssize_t)len <= es->linelen)
d3604 1
a3604 1
		memmove(buf, es->cbuf, es->linelen);
d3655 2
a3656 4
					if (ch == '/') {
						if (putbuf("/", 1, 0) != 0)
							return (-1);
					} else if (putbuf("?", 1, 0) != 0)
d3665 1
a3665 1
					    strlen(KSH_VERSION), 0);
d3996 1
a3996 1
			first_insert = 0;
d4108 1
a4108 1
				nbuf = alloc(nlen + 1 + olen, APERM);
d4113 1
a4113 1
					afree(macro.buf, APERM);
d4198 2
a4199 1
			while (putbuf(ybuf, yanklen, 0) == 0 && --argcnt > 0)
d4211 2
a4212 1
			while (putbuf(ybuf, yanklen, 0) == 0 && --argcnt > 0)
d4463 2
a4464 2
				if (putbuf(" ", 1, 0) != 0 ||
				    putbuf(sp, argcnt, 0) != 0) {
d4607 2
a4608 1
		if ((ncursor = findch(fsavech, argcnt, t, i)) < 0)
d4708 1
a4708 1
		if (putbuf(ibuf, inslen, insert == REPLACE) != 0)
d4759 1
a4759 1
	memmove(holdbuf, es->cbuf, es->linelen);
d4761 1
a4761 1
	holdbuf[holdlen] = '\0';
d4769 1
a4769 1
	memmove(es->cbuf, holdbuf, holdlen);
d4778 2
a4779 2
	news = alloc(sizeof(struct edstate), APERM);
	news->cbuf = alloc(old->cbufsize, APERM);
d4801 2
a4802 2
	afree(old->cbuf, APERM);
	afree(old, APERM);
d4811 1
a4811 1
	return (putbuf(s, len, 0));
d4815 1
a4815 1
putbuf(const char *buf, ssize_t len, int repl)
d4845 1
a4845 1
findch(int ch, int cnt, int forw, int incl)
d5041 2
a5042 2
		/* (start != 0 && fwd && match(holdbuf, pat) >= 0) */
		if (start != 0 && fwd && strcmp(holdbuf, pat) >= 0) {
d5281 1
a5281 1
		if (++i < nwords && putbuf(" ", 1, 0) != 0) {
d5399 1
a5399 1
			rval = putbuf(" ", 1, 0);
d5456 1
a5456 1
		afree(macro.buf, APERM);
d5477 4
a5481 1
	ainit(AEDIT);
@


1.267
log
@RCSID sync with oksh (fixed by us 4 years ago already)
@
text
@a921 1
static int x_col;
a945 3
static int cur_col;		/* current column on line */
static int pwidth;		/* width of prompt */
static int prompt_trunc;	/* how much of prompt to truncate */
d954 3
a956 1
static bool prompt_redraw;	/* false if newline forced after prompt */
d963 1
d1172 7
a1178 12
	x_col = promptlen(prompt);
	x_adj_ok = true;
	prompt_redraw = true;
	if (x_col >= xx_cols)
		x_col %= xx_cols;
	x_displen = xx_cols - 2 - x_col;
	x_adj_done = 0;

	pprompt(prompt, 0);
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
a1179 1
		prompt_redraw = false;
a1197 1
	xx_cols = x_cols;
d1199 3
d1559 1
a1559 5
	if (cp >= xep)
		cp = xep;
	else if (UTFMODE)
		while ((cp > xbuf) && ((*cp & 0xC0) == 0x80))
			--cp;
d1575 10
d1590 1
a1590 5
	(*p)--;
	if (UTFMODE)
		while (((unsigned char)**p & 0xC0) == 0x80)
			(*p)--;

d2080 1
a2080 1
	int i, j, x_trunc = 0;
d2090 3
a2092 5
		x_col = promptlen(prompt);
		if (x_col >= xx_cols)
			x_trunc = (x_col / xx_cols) * xx_cols;
		if (prompt_redraw)
			pprompt(prompt, x_trunc);
a2093 2
	if (x_col >= xx_cols)
		x_col %= xx_cols;
a2094 4
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
	}
d2808 3
a2810 1
	/* flag the fact that we were called. */
d2812 1
d2814 3
a2816 1
	 * we had a problem if the prompt length > xx_cols / 2
d2818 26
a2843 5
	if ((xbp = xcp - (x_displen / 2)) < xbuf)
		xbp = xbuf;
	if (UTFMODE)
		while ((xbp > xbuf) && ((*xbp & 0xC0) == 0x80))
			--xbp;
d3535 2
a3536 12
	cur_col = promptlen(prompt);
	prompt_trunc = (cur_col / x_cols) * x_cols;
	cur_col -= prompt_trunc;

	pprompt(prompt, 0);
	if ((mksh_uari_t)cur_col > (mksh_uari_t)x_cols - 3 - MIN_EDIT_SPACE) {
		prompt_redraw = false;
		cur_col = 0;
		x_putc('\n');
	} else
		prompt_redraw = true;
	pwidth = cur_col;
d5065 1
a5065 1
	if (prompt_redraw)
d5067 1
a5067 1
	cur_col = pwidth;
d5185 1
a5185 1
			if (cur_col != col)
d5188 1
a5188 1
			cur_col++;
d5209 1
a5209 1
		cur_col++;
d5212 1
a5212 1
	if (cur_col != ncol)
d5219 2
a5220 2
	if (col < cur_col) {
		if (col + 1 < cur_col - col) {
d5222 1
a5222 1
			if (prompt_redraw)
d5224 2
a5225 2
			cur_col = pwidth;
			while (cur_col++ < col)
d5228 1
a5228 1
			while (cur_col-- > col)
d5232 2
a5233 2
		wb = &wb[cur_col - pwidth];
		while (cur_col++ < col)
d5236 1
a5236 1
	cur_col = col;
@


1.266
log
@for Yofuh: implement Emacs mode PgUp as Vi insert mode CurUp
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.37 2013/01/21 10:13:24 halex Exp $	*/
@


1.265
log
@improve DEBUG_LEAKS handling and fix freeing some locs
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.264 2013/02/10 17:41:03 tg Exp $");
d3414 1
a3414 1
	0,	vC,	0,	0,	0,	0,	vC|vU,	0,
d3418 1
a3418 1
	vC,	vC|vU,	0,	0,	vC|vZ,	0,	vM,	vC|vZ,
d3446 1
d3809 24
d3837 1
d4407 5
d4532 10
@


1.264
log
@call it DEBUG_LEAKS so Android can always enable it
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.263 2013/02/10 17:39:36 tg Exp $");
d5454 2
a5455 1
	afreeall(AEDIT);
@


1.263
log
@actually, only needed #ifdef DEBUG
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.262 2013/02/10 17:38:13 tg Exp $");
d5450 1
a5450 1
#ifdef DEBUG
@


1.262
log
@call afreeall(AEDIT) upon close; related to LP#1106116
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.261 2013/02/10 17:18:47 tg Exp $");
d5450 1
d5456 1
@


1.261
log
@pure RCSID sync with oksh, who also added a tabcompletion fix now, with
less code, but, even according to their own comments, not as good as ours
@
text
@d8 1
a8 1
 *		 2011, 2012
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.259 2012/12/08 18:30:27 tg Exp $");
a84 1
static void x_init_emacs(void);
a108 15
/* Called from main */
void
x_init(void)
{
	/*
	 * Set edchars to -2 to force initial binding, except
	 * we need default values for some deficient systems…
	 */
	edchars.erase = edchars.kill = edchars.intr = edchars.quit =
	    edchars.eof = -2;
	/* ^W */
	edchars.werase = 027;
	x_init_emacs();
}

a2572 26
x_init_emacs(void)
{
	int i, j;

	ainit(AEDIT);
	x_nextcmd = -1;

	x_tab = alloc2(X_NTABS, sizeof(*x_tab), AEDIT);
	for (j = 0; j < X_TABSZ; j++)
		x_tab[0][j] = XFUNC_insert;
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_tab[i][j] = XFUNC_error;
	for (i = 0; i < (int)NELEM(x_defbindings); i++)
		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
		    = x_defbindings[i].xdb_func;

#ifndef MKSH_SMALL
	x_atab = alloc2(X_NTABS, sizeof(*x_atab), AEDIT);
	for (i = 1; i < X_NTABS; i++)
		for (j = 0; j < X_TABSZ; j++)
			x_atab[i][j] = NULL;
#endif
}

static void
d5412 43
@


1.260
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.35 2012/09/10 01:25:30 tedu Exp $	*/
@


1.259
log
@add a few assertions for LLVM+Clang 3.2 scan-build; no !DEBUG changes
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.258 2012/12/04 01:18:26 tg Exp $");
d76 1
a76 1
static void x_print_expansions(int, char *const *, bool);
d78 1
a78 1
static size_t x_longest_prefix(int, char *const *);
@


1.258
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.257 2012/12/01 01:36:19 tg Exp $");
d610 2
@


1.257
log
@remove *all* nonnull assertions and other workarounds for clang scan-build

this beast evolved in the last 2½ years, and we’ve had trouble with
some of them earlier
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.256 2012/11/26 22:39:14 tg Exp $");
d2276 1
@


1.256
log
@fix regression wrt. pdksh (introduced between R40e and R40f)
about how and when the display is redrawn by reverting one
bool back to an int, as it’s used as a counter (hm, should
be an unsigned I guess but…)

on the other hand, xlp_valid should’ve been a bool, make it so
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.254 2012/10/03 17:24:17 tg Exp $");
d993 1
a993 2
static char *x_mapin(const char *, Area *)
    MKSH_A_NONNULL((__nonnull__ (1)));
a2396 3
	/* for clang's static analyser, the nonnull attribute isn't enough */
	mkssert(cp != NULL);

@


1.256.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.256 2012/11/26 22:39:14 tg Exp $");
d993 2
a994 1
static char *x_mapin(const char *, Area *);
a2276 1
	mkssert(xcp != NULL);
d2398 3
@


1.256.2.2
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.256.2.1 2012/12/04 01:26:19 tg Exp $");
d2276 1
@


1.255
log
@fix backslash-asterisk glob noise for nōn-existant targets and tilde
expansion completion; problem analysis and solution draft by Andrew
Kudryashov (thanks a lot!); this fix instead re-uses existing code
for solving the problem with multiple matches

debugged using “make d dr” targets, yay!
@
text
@d934 1
a934 1
static bool x_adj_done;
d941 1
a941 1
static int xlp_valid;
d1194 1
a1194 1
	x_adj_done = false;
d1367 1
a1367 1
	bool adj = x_adj_done;
d1644 1
a1644 1
	bool adj = x_adj_done;
d2863 1
a2863 1
	x_adj_done = true;
d2985 1
a2985 1
	bool adj = x_adj_done;
@


1.254
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.253 2012/10/03 15:50:29 tg Exp $");
d80 1
a80 1
static void x_glob_hlp_rem_qchar(char *);
d326 4
a329 1
 * Unescape a QCHAR-escaped string
d331 2
a332 2
static void
x_glob_hlp_rem_qchar(char *cp)
d334 28
a361 1
	char ch, *dp = cp;
d369 2
a374 1
 *	- appends * to (copy of) str if no globbing chars found
d424 2
a425 2
		/* Drop all QCHAR from toglob for strcmp below */
		x_glob_hlp_rem_qchar(toglob);
a2802 8
		if (*unescaped == '~') {
			/*
			 * do some tilde expansion; we know at this
			 * point (by means of having nwords > 1) that
			 * the string looks like "~foo/bar" and that
			 * the tilde resolves
			 */
			char *cp;
d2804 2
a2805 6
			cp = strchr(unescaped + 1, '/');
			*cp++ = 0;
			cp = shf_smprintf("%s/%s", tilde(unescaped + 1), cp);
			afree(unescaped, ATEMP);
			unescaped = cp;
		}
a2806 4
		/* ... convert it from backslash-escaped via QCHAR-escaped... */
		x_glob_hlp_add_qchar(unescaped);
		/* ... to unescaped, for comparison with the matches */
		x_glob_hlp_rem_qchar(unescaped);
@


1.253
log
@rewrite XPtrV to use size_t instead of pointer arithmetic, for gcc-snapshot (20120930-1) -fstrict-overflow -Wstrict-overflow=9
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.252 2012/09/21 17:20:20 tg Exp $");
d1381 1
a1381 1
	ssize_t i = 0;
d1384 1
a1384 1
	while (i < x_arg) {
d1907 1
a1907 1
			if (p >= &pat[sizeof(pat) - 1]) {
d2501 1
a2501 1
		while (*c && m1 < (msg + sizeof(msg) - 3))
d2587 8
a2594 3
	/* Has user already bound this key? If so, don't override it */
	if (x_bound[((p) * X_TABSZ + (k)) / 8] &
	    (1 << (((p) * X_TABSZ + (k)) % 8)))
d3552 1
a3552 1
	if (cur_col > x_cols - 3 - MIN_EDIT_SPACE) {
d3820 2
a3821 1
					if (es->linelen + 2 > es->cbufsize)
d4412 1
a4412 1
				int inspace;
d4433 1
a4433 1
					inspace = 0;
d4436 1
a4436 1
							inspace = 1;
d4438 1
a4438 1
							inspace = 0;
d4453 2
a4454 5
				if (putbuf(" ", 1, 0) != 0)
					argcnt = -1;
				else if (putbuf(sp, argcnt, 0) != 0)
					argcnt = -1;
				if (argcnt < 0) {
@


1.252
log
@pure RCSID sync with OpenBSD, as we introduced SIGWINCH tracking earlier

XXX we could track whether tty_fd has already been successfully opened,
XXX the ttystate initialised, and then just never close it unless it is
XXX necessary, then we can keep COLUMNS/LINES accurate in scripts, even
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.251 2012/08/24 21:33:49 tg Exp $");
d245 1
a245 1
	XPtrV l = { NULL, NULL, NULL };
d442 1
a442 1
	int nwords;
d473 1
a473 1
		int i, path_order = 0;
d495 1
a495 1
		int i, j;
d505 1
a505 2
		nwords = j;
		w.cur = (void **)&words[j];
d798 1
a798 1
		wp->cur = (void **)&words[j];
@


1.251
log
@sync clog
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.246 2012/08/24 19:02:55 tg Exp $");
@


1.250
log
@related to LP#1025843 fix tab completion for tilde

this code is insane, who wrote globbing and expansion for mksh’s
predecessor must have been on very interesting drugs
@
text
@d2777 1
a2777 1
			cp = ucstrchr(unescaped + 1, '/');
@


1.249
log
@second attempt at getting '$FOO/b*r/baz' tab-completed right,
plus the beginning of the tilde fix… do not use, this is fucking
impossible to get right, but I’d like an archival commit
@
text
@d382 1
a382 1
		nwords = DOKEEPQCHAR;
a814 1
	char ch;
d819 3
a821 4
	while (wlen - add > 0) {
		ch = s[add];
		if (vstrchr("\"#$&'()*:;<=>?[\\`{|}", ch) ||
		    ch == QCHAR || vstrchr(ifs, ch)) {
d826 1
a826 3
			putbuf_func(ch == '\n' ? "'" : "\\", 1);
			if (ch == QCHAR)
				++add;
d828 1
a828 1
			if (ch == '\n')
a836 1
	}
d2772 2
a2773 1
			 * the string looke like "~foo/bar"
d2775 1
a2775 1
			char *cp, *dp;
d2779 3
a2781 3
			if ((dp = tilde(unescaped + 1))) {
				/* got a match */
			}
@


1.248
log
@repair globbing $foo/ba*r/baz
@
text
@d64 1
a64 2
#define XCF_IS_SUBST	BIT(4)	/* return flag: is $FOO substitution */
#define XCF_IS_NOSPACE	BIT(5)	/* return flag: do not append a space */
d380 3
a382 2
		nwords = DOKEEPQUOTE;
		*flagsp |= XCF_IS_SUBST | XCF_IS_NOSPACE;
d604 4
a607 1
		 * on that value (i.e., without the appended '*').
a612 1
			    /* also skip this for variable expansion */
d617 4
a620 1
				/* just expand based on the extglob */
d815 1
d820 4
a823 3
	while (wlen - add > 0)
		if (vstrchr("\"#$&'()*:;<=>?[\\`{|}", s[add]) ||
		    vstrchr(ifs, s[add])) {
d828 3
a830 1
			putbuf_func(s[add] == '\n' ? "'" : "\\", 1);
d832 1
a832 1
			if (s[add] == '\n')
d841 1
d2761 1
a2761 1
	if (nwords == 1 || (flags & XCF_IS_SUBST)) {
d2763 3
a2765 2
		 * always complete the expansion of parameter and
		 * homedir substitution as well as single matches
d2771 1
a2771 1
		/* make a copy of the original string part and... */
d2773 15
d2815 1
a2815 4
		if (flags & XCF_IS_SUBST)
			x_do_ins(words[0], nlen);
		else
			x_escape(words[0], nlen, x_do_ins);
@


1.247
log
@leak less memory from tab completion
@
text
@d64 2
a65 2
#define XCF_IS_SUBGLOB	BIT(4)	/* return flag: is $FOO or ~foo substitution */
#define XCF_IS_EXTGLOB	BIT(5)	/* return flag: is foo* expansion */
d99 1
a99 1
static int path_order_cmp(const void *aa, const void *bb);
d101 2
a102 2
static void glob_path(int flags, const char *, XPtrV *, const char *);
static int x_file_glob(int, char *, char ***);
d350 1
a350 1
x_file_glob(int flags MKSH_A_UNUSED, char *toglob, char ***wordsp)
d352 1
a352 1
	char **words;
d375 10
a384 1
	expand(yylval.cp, &w, DOGLOB | DOTILDE | DOMARKDIRS);
a592 1
		bool saw_dollar = false, saw_glob = false;
d603 2
a604 3
		 * '?', or '[') or parameter expansion ('$'), or a ~username
		 * with no trailing slash, then it is globbed based on that
		 * value (i.e., without the appended '*').
d609 3
a611 8
			else if (*s == '$') {
				/*
				 * Do not append a space after the value
				 * if expanding a parameter substitution
				 * as in: “cat $HOME/.ss↹” (LP: #710539)
				 */
				saw_dollar = true;
			} else if (*s == '?' || *s == '*' || *s == '[' ||
d616 1
a616 1
				saw_glob = true;
d619 5
a623 15
		if (saw_glob) {
			/*
			 * do not append a glob, we already have a
			 * glob or extglob; it works even if this is
			 * a parameter expansion as we have a glob
			 */
			*flagsp |= XCF_IS_EXTGLOB;
		} else if (saw_dollar ||
		    (*toglob == '~' && !vstrchr(toglob, '/'))) {
			/* do not append a glob, nor later a space */
			*flagsp |= XCF_IS_SUBGLOB;
		} else {
			/* append a glob, this is not just a tilde */
			toglob[len] = '*';
			toglob[len + 1] = '\0';
d626 4
d636 1
a636 1
		    x_file_glob(*flagsp, toglob, &words);
d2751 1
a2751 1
	if (nwords == 1 || (flags & XCF_IS_SUBGLOB)) {
d2789 4
a2792 1
		x_escape(words[0], nlen, x_do_ins);
d2800 1
a2800 1
	    !(flags & XCF_IS_SUBGLOB)) {
d5356 1
a5356 1
		    !(flags & XCF_IS_SUBGLOB))
@


1.246
log
@more int → bool
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.245 2012/07/20 22:47:22 tg Exp $");
d373 1
@


1.245
log
@remove misleading comment fixed in last commit
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.244 2012/07/20 20:50:07 tg Exp $");
d782 1
a782 1
		glob_str(Xstring(xs, xp), wp, 1);
@


1.244
log
@fix more cases of x_delete() bytes vs. characters abuse (tested!); fix some int vs. size_t issues (XXX also fix x_cf_glob and friends some day…)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.243 2012/07/20 20:33:15 tg Exp $");
a1095 1
/* want size_t, not int */
@


1.243
log
@factor out common code (convert from "byte offset from cursor" to number of characters)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.242 2012/07/20 20:16:26 tg Exp $");
d943 3
a945 3
static void x_delete(int, int);
static int x_bword(void);
static int x_fword(bool);
d977 1
a977 1
static int x_nb2nc(int);
d1097 2
a1098 2
static int
x_nb2nc(int nb)
d1364 1
a1364 1
	int i = 0;
d1381 1
a1381 1
	int i = 0;
d1402 1
a1402 1
x_delete(int nc, int push)
d1404 1
a1404 1
	int i, nb, nw;
d1499 1
a1499 1
static int
d1502 1
a1502 1
	int nb = 0;
d1523 1
a1523 1
static int
d1526 1
a1526 1
	int nc;
d2226 12
a2237 14
	int col = xcp - xbuf;
	int lastcol = xep - xbuf;
	int ndel;

	if (x_arg_defaulted)
		x_arg = lastcol;
	else if (x_arg > lastcol)
		x_arg = lastcol;
	ndel = x_arg - col;
	if (ndel < 0) {
		x_goto(xbuf + x_arg);
		ndel = -ndel;
	}
	x_delete(ndel, true);
d2285 1
a2285 1
	x_delete(len, false);
d2605 1
a2605 1
	int rsize;
d2620 1
a2620 1
	x_delete(rsize, true);
d2713 1
a2713 1
	x_delete(end - start, false);
@


1.242
log
@fix no less than two more bugs and one regression in the Emacs tab completion code (LP#1025843)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.239 2012/07/01 15:54:53 tg Exp $");
d945 1
a945 1
static int x_fword(int);
d977 1
d1096 12
d1488 1
a1488 1
	x_fword(1);
d1495 1
a1495 1
	x_delete(x_fword(0), true);
d1502 1
a1502 1
	int nc = 0, nb = 0;
d1520 1
a1520 3
	for (cp = xcp; cp < (xcp + nb); ++nc)
		cp += utf_ptradj(cp);
	return (nc);
d1524 1
a1524 1
x_fword(int move)
d1526 2
a1527 2
	int nc = 0;
	char *cp = xcp, *cp2;
d1539 1
a1539 2
	for (cp2 = xcp; cp2 < cp; ++nc)
		cp2 += utf_ptradj(cp2);
@


1.241
log
@make QCHAR-for-glob {,un}escaping code into helper functions

no code change
@
text
@d2729 1
a2729 1
	bool completed = false;
d2747 40
a2786 4
	/* always complete */
	x_goto(xbuf + start);
	x_delete(olen, false);
	x_escape(words[0], nlen, x_do_ins);
a2787 3
	/* check if we did add something */
	if (xcp - (xbuf + start) > olen)
		completed = true;
a2794 1
		completed = true;
a2795 7
	if (type == CT_COMPLIST && !completed) {
		x_print_expansions(nwords, words,
		    tobool(flags & XCF_IS_COMMAND));
		completed = true;
	}
	if (completed)
		x_redraw(0);
@


1.240
log
@x_lastcp(); done by x_zots already
@
text
@d80 2
d287 4
a290 6
/**
 * Do file globbing:
 *	- appends * to (copy of) str if no globbing chars found
 *	- does expansion, checks for no match, etc.
 *	- sets *wordsp to array of matching strings
 *	- returns number of matching strings
d292 2
a293 2
static int
x_file_glob(int flags MKSH_A_UNUSED, char *toglob, char ***wordsp)
d295 2
a296 5
	char ch, **words;
	int nwords, i = 0, idx = 0;
	bool escaping;
	XPtrV w;
	struct source *s, *sold;
d298 1
a298 3
	/* remove all escaping backward slashes */
	escaping = false;
	while ((ch = toglob[i++])) {
d303 1
a303 1
		if (escaping) {
d306 1
a306 2
			 * for globbing; ASCII 0x02 probably too as
			 * that's what QCHAR is, but...
d309 1
d316 1
a316 1
				toglob[idx++] = QCHAR;
d321 1
a321 1
		toglob[idx++] = ch;
d323 36
a358 1
	toglob[idx] = '\0';
d384 1
a384 7
		i = 0;
		idx = 0;
		while ((ch = toglob[i++])) {
			if (ch != QCHAR)
				toglob[idx++] = ch;
		}
		toglob[idx] = '\0';
@


1.239
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/ – add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.237 2012/05/05 17:32:31 tg Exp $");
a2056 1
	x_lastcp();
@


1.238
log
@lessons learned during nullperf tests: inlining this is always bad
@
text
@d91 1
a91 1
#ifdef MKSH_SMALL
@


1.237
log
@move x_mkraw() to main.c from edit.c in order to be able to skip the latter
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.236 2012/05/04 22:18:23 tg Exp $");
d74 1
a1070 2
#ifdef MKSH_SMALL
static void x_modified(void);
d1079 2
a1082 6
#define x_modified() do {			\
	if (!modified) {			\
		x_histp = histptr + 1;		\
		modified = 1;			\
	}					\
} while (/* CONSTCOND */ 0)
@


1.237.4.1
log
@cherry-pick fixes not in this branch yet
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.237 2012/05/05 17:32:31 tg Exp $");
a78 2
static void x_glob_hlp_add_qchar(char *);
static void x_glob_hlp_rem_qchar(char *);
d284 6
a289 4
/*
 * Convert backslash-escaped string to QCHAR-escaped
 * string useful for globbing; loses QCHAR unless it
 * can squeeze in, eg. by previous loss of backslash
d291 2
a292 2
static void
x_glob_hlp_add_qchar(char *cp)
d294 5
a298 2
	char ch, *dp = cp;
	bool escaping = false;
d300 3
a302 1
	while ((ch = *cp++)) {
d307 1
a307 1
		if (escaping || (ch == QCHAR && (cp - dp) > 1)) {
d310 2
a311 1
			 * for globbing as well as QCHAR itself
a313 1
			case QCHAR:
d320 1
a320 1
				*dp++ = QCHAR;
d325 1
a325 1
		*dp++ = ch;
d327 1
a327 36
	*dp = '\0';
}

/*
 * Unescape a QCHAR-escaped string
 */
static void
x_glob_hlp_rem_qchar(char *cp)
{
	char ch, *dp = cp;

	while ((ch = *cp++)) {
		if (ch == QCHAR && !(ch = *cp++))
			break;
		*dp++ = ch;
	}
	*dp = '\0';
}

/**
 * Do file globbing:
 *	- appends * to (copy of) str if no globbing chars found
 *	- does expansion, checks for no match, etc.
 *	- sets *wordsp to array of matching strings
 *	- returns number of matching strings
 */
static int
x_file_glob(int flags MKSH_A_UNUSED, char *toglob, char ***wordsp)
{
	char **words;
	int nwords;
	XPtrV w;
	struct source *s, *sold;

	/* remove all escaping backward slashes */
	x_glob_hlp_add_qchar(toglob);
d353 7
a359 1
		x_glob_hlp_rem_qchar(toglob);
d918 3
a920 3
static void x_delete(size_t, bool);
static size_t x_bword(void);
static size_t x_fword(bool);
a951 1
static size_t x_nb2nc(size_t);
a1069 11
static size_t
x_nb2nc(size_t nb)
{
	char *cp;
	size_t nc = 0;

	for (cp = xcp; cp < (xcp + nb); ++nc)
		cp += utf_ptradj(cp);
	return (nc);
}

d1332 1
a1332 1
	ssize_t i = 0;
d1349 1
a1349 1
	ssize_t i = 0;
d1370 1
a1370 1
x_delete(size_t nc, bool push)
d1372 1
a1372 1
	size_t i, nb, nw;
d1456 1
a1456 1
	x_fword(true);
d1463 1
a1463 1
	x_delete(x_fword(false), true);
d1467 1
a1467 1
static size_t
d1470 1
a1470 1
	size_t nb = 0;
d1488 3
a1490 1
	return (x_nb2nc(nb));
d1493 2
a1494 2
static size_t
x_fword(bool move)
d1496 2
a1497 2
	size_t nc;
	char *cp = xcp;
d1509 2
a1510 1
	nc = x_nb2nc(cp - xcp);
d2198 14
a2211 12
	size_t col = xcp - xbuf;
	size_t lastcol = xep - xbuf;
	size_t ndel, narg;

	if (x_arg_defaulted || (narg = x_arg) > lastcol)
		narg = lastcol;
	if (narg < col) {
		x_goto(xbuf + narg);
		ndel = col - narg;
	} else
		ndel = narg - col;
	x_delete(x_nb2nc(ndel), true);
d2259 1
a2259 1
	x_delete(x_nb2nc(len), false);
d2579 1
a2579 1
	size_t rsize;
d2594 1
a2594 1
	x_delete(x_nb2nc(rsize), true);
d2687 1
a2687 1
	x_delete(x_nb2nc(end - start), false);
d2711 1
a2711 1
	bool completed;
d2729 7
a2735 5
	if (nwords == 1 || (flags & XCF_IS_SUBGLOB)) {
		/*
		 * always complete the expansion of parameter and
		 * homedir substitution as well as single matches
		 */
a2736 35
	} else {
		char *unescaped;

		/* make a copy of the original string part and... */
		strndupx(unescaped, xbuf + start, olen, ATEMP);
		/* ... convert it from backslash-escaped via QCHAR-escaped... */
		x_glob_hlp_add_qchar(unescaped);
		/* ... to unescaped, for comparison with the matches */
		x_glob_hlp_rem_qchar(unescaped);
		/*
		 * match iff entire original string is part of the
		 * longest prefix, implying the latter is at least
		 * the same size (after unescaping)
		 */
		completed = !strncmp(words[0], unescaped, strlen(unescaped));

		afree(unescaped, ATEMP);
	}
	if (type == CT_COMPLIST && nwords > 1) {
		/*
		 * print expansions, since we didn't get back
		 * just a single match
		 */
		x_print_expansions(nwords, words,
		    tobool(flags & XCF_IS_COMMAND));
	}
	if (completed) {
		/* expand on the command line */
		xmp = NULL;
		xcp = xbuf + start;
		xep -= olen;
		memmove(xcp, xcp + olen, xep - xcp + 1);
		x_escape(words[0], nlen, x_do_ins);
	}
	x_adjust();
d2744 1
d2746 7
@


1.237.4.2
log
@MFC cid 1005037D2C82E041A1D, 1005037DE8E56F5392F, 1005037EABE57131431, 1005037EEEC1CEDE454, 1005037F34F0A0722F6:
• quell tabcompletion memory leak
• fix tab completion for tilde, related to LP#1025843
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.237.4.1 2012/07/20 22:51:40 tg Exp $");
d64 2
a65 1
#define XCF_IS_NOSPACE	BIT(4)	/* return flag: do not append a space */
d101 1
a101 1
static int x_file_glob(int *, char *, char ***);
d349 1
a349 1
x_file_glob(int *flagsp, char *toglob, char ***wordsp)
d351 1
a351 1
	char **words, *cp;
a371 1
	afree(s, ATEMP);
d373 1
a373 11
	cp = yylval.cp;
	while (*cp == CHAR || *cp == QCHAR)
		cp += 2;
	nwords = DOGLOB | DOTILDE | DOMARKDIRS;
	if (*cp != EOS) {
		/* probably a $FOO expansion */
		*flagsp |= XCF_IS_NOSPACE;
		/* this always results in at most one match */
		nwords = 0;
	}
	expand(yylval.cp, &w, nwords);
d582 1
d593 3
a595 5
		 * '?', or '[') or an extglob, then it is globbed based
		 * on that value (i.e., without the appended '*'). Same
		 * for parameter substitutions (as in “cat $HOME/.ss↹”)
		 * without appending a trailing space (LP: #710539), as
		 * well as for “~foo” (but not “~foo/”).
d600 8
a607 2
			else if (*s == '?' || *s == '*' || *s == '[' ||
			    *s == '$' ||
d611 2
a612 5
				/*
				 * just expand based on the extglob
				 * or parameter
				 */
				goto dont_add_glob;
d615 15
a629 5

		if (*toglob == '~' && !vstrchr(toglob, '/')) {
			/* neither for '~foo' (but '~foo/bar') */
			*flagsp |= XCF_IS_NOSPACE;
			goto dont_add_glob;
a631 4
		/* append a glob */
		toglob[len] = '*';
		toglob[len + 1] = '\0';
 dont_add_glob:
d638 1
a638 1
		    x_file_glob(flagsp, toglob, &words);
d2760 1
a2760 1
	if (nwords == 1) {
d2762 2
a2763 3
		 * always complete single matches;
		 * any expansion of parameter substitution
		 * is always at most one result, too
d2769 1
a2769 1
		/* make a copy of the original string part */
a2770 16
		if (*unescaped == '~') {
			/*
			 * do some tilde expansion; we know at this
			 * point (by means of having nwords > 1) that
			 * the string looks like "~foo/bar" and that
			 * the tilde resolves
			 */
			char *cp;

			cp = strchr(unescaped + 1, '/');
			*cp++ = 0;
			cp = shf_smprintf("%s/%s", tilde(unescaped + 1), cp);
			afree(unescaped, ATEMP);
			unescaped = cp;
		}

d2806 1
a2806 1
	    !(flags & XCF_IS_NOSPACE)) {
d5362 1
a5362 1
		    !(flags & XCF_IS_NOSPACE))
@


1.237.4.3
log
@add patch scheduled for 40.9.20120630-5
in <Pine.BSM.4.64L.1211262241200.23257@@herc.mirbsd.org>:
Fix input command line editing display redrawing issue
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.237.4.2 2012/09/03 19:10:53 tg Exp $");
d903 1
a903 1
static int x_adj_done;
d1169 1
a1169 1
	x_adj_done = 0;
d1342 1
a1342 1
	int adj = x_adj_done;
d1619 1
a1619 1
	int adj = x_adj_done;
d2850 1
a2850 1
	x_adj_done++;
d2972 1
a2972 1
	int adj = x_adj_done;
@


1.237.2.1
log
@store away the first part of the emacs keybinding redesign

I’ve had this plan stashed for some time already but Ogre forced my hand
by committing something possibly offering similar functionality in a way
I’d not like to have new code written in

this does not compile
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.237 2012/05/05 17:32:31 tg Exp $");
d83 2
d108 15
d827 16
d848 3
d936 2
a937 2
static char *x_mapin(const char *, Area *);
static char *x_mapout_str(const void *);
a957 33
//XXX nukeold: X_NTABS
//XXX nukeold: X_TABSZ
//XXX nukeold: x_bound
//XXX nukeold: x_tab
//XXX nukeold: x_atab

/**
 * Bound keys are kept in one of three tables (normal, prefix-1,
 * prefix-2) which are pointers to bytes, sorted by the bytes
 * pointed to. They are structured as follows:
 * The first byte(s), up to a NUL, are the keys that need to
 * be pressed to activate this binding. Then, one byte is the
 * flags (XF_*), then there is either one byte with the function
 * code or a C string that is the macro text.
 * The tables point to 'uint8_t *', although those with XF_CONST
 * must not be written to; others are allocated from AEDIT.
 */

#define X_KP 3
static uint8_t *x_kpt[X_KP];	/* sorted table of bindings */
static size_t x_kpn[X_KP];	/* number of elements in them */
static size_t x_kpz[X_KP];	/* sizes of the tables */

static void x_init_emacs_one_defbinding(int, const uint8_t *, size_t);

/* flags for emacs mode keybindings */
#define XF_CONST	BIT(0)	/* not allocated in AEDIT */
#define XF_PREFIX	BIT(1)	/* is a prefix function */
#define XF_MACRO	BIT(2)	/* is a macro */
#define XF_NOBIND	BIT(3)	/* may not be bound */

typedef int (*emacsfn_ptr)(int);

a963 5
/* not side-effect safe */
#define XFN_ISPREFIX(x)	((x) == XFUNC_meta1 || (x) == XFUNC_meta2)
#define XFN_ISNOBIND(x)	((x) == XFUNC_set_arg) /* or ins_string (soon dead) */

//XXX nukeold: x_defbindings
d967 2
a968 3
//XXX nukeold: x_ftab
static emacsfn_ptr const x_emacsfnp[] = {
#define EMACSFN_PTRS
d970 1
d972 96
a1067 3
static const char * const x_emacsfns[] = {
#define EMACSFN_STRS
#include "emacsfn.h"
a1069 1

d1080 1
d1088 1
d1122 20
d1158 1
a1158 16
	/* initialise the prompt */
	x_col = promptlen(prompt);
	x_adj_ok = true;
	prompt_redraw = true;
	if (x_col >= xx_cols)
		x_col %= xx_cols;
	x_displen = xx_cols - 2 - x_col;
	x_adj_done = false;

	pprompt(prompt, 0);
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
		x_e_putc2('\n');
		prompt_redraw = false;
	}
d2288 4
a2291 2
static char *
x_mapin(const char *s, Area *ap)
d2293 16
a2308 1
	char c, *cp, *d;
d2310 18
a2327 15
	cp = d = alloc(strlen(s) + 1, ap);
	while ((c = *s++)) {
		if (c == '^') {
			if ((c = *s++) >= '?') {
				/* includes '?'; ASCII */
				*cp++ = CTRL(c);
			} else {
				*cp++ = '^';
				/* use '^ ' for a caret by convention */
				if (c != ' ')
					/* do not skip the second char */
					--s;
			}
		} else
			*cp++ = c;
d2329 4
a2332 2
	*cp++ = 0;
	return (aresize(d, cp - d, ap));
d2334 1
d2337 1
a2337 1
x_mapout_str(const void *src)
d2339 4
a2342 4
	uint8_t c;
	char *cp;
	const uint8_t *s = src;
	char *d;
d2344 13
a2356 13
	/*
	 * just allocate twice the string at ATEMP and don't shrink it,
	 * as the result is usually short-lived (for printing) anyway
	 */
	cp = d = alloc2(2, strlen(src) + 1, ATEMP);
	while ((c = *s++)) {
		if (c == '^') {
			/* use '^ ' for a caret by convention */
			*cp++ = '^';
			*cp++ = ' ';
		} else if (c < ' ' || c == 0x7F) {
			*cp++ = '^';
			*cp++ = UNCTRL(c);
d2358 2
a2359 1
			*cp++ = c;
d2361 3
a2363 2
	*cp = 0;
	return (d);
d2403 1
a2403 1
	if (f != XFUNC_ins_string)
d2405 1
a2405 1
		shprintf("%s\n", x_ftab[f].xf_name);
d2444 1
a2444 1
				f = x_tab[prefix][key];
d2459 1
a2459 1
		f = x_tab[prefix][key];
d2472 5
a2476 3
		char *msg;

		msg = x_mapout_str(a1);
a2477 1
		afree(msg, ATEMP);
d2508 1
a2508 1
	if (x_tab[prefix][key] == XFUNC_ins_string &&
d2533 1
a2533 1
x_init_emacs_one_defbinding(int dsttab, const uint8_t *src, size_t num)
d2535 4
a2538 2
	uint8_t *dst;
	union mksh_cchack p;
d2540 9
a2548 2
	x_kpt[dsttab] = dst = alloc2(num, sizeof(uint8_t *), AEDIT);
	x_kpz[dsttab] = num;
d2550 5
a2554 22
	num = 0;
	while (*src) {
		p.ro = (const void *)src;
		*dst++ = (void *)p.rw;
		while (*src++)
			;
#ifdef DEBUG
		/* check XF_CONST is set and XF_MACRO is not set */
		if ((*src & (XF_CONST | XF_MACRO)) != XF_CONST)
			internal_errorf("flags %02X for macro %s invalid!",
			    *src, x_mapout_str(p.ro));
		/* because the following code does not work for XF_MACRO */
		/* and since we have none, I did not bother writing it */
#endif
		++src;
		++src;
		++num;
#ifdef DEBUG
		/* check they are really sorted */
		if (*src && (strcmp(p.ro, (const void *)src) >= 0))
			internal_errorf("macro %s not < %s (please sort)",
			    x_mapout_str(p.ro), x_mapout_str(src));
a2555 2
	}
	x_kpn[dsttab] = num;
a5368 24

/* Called from main */
void
x_init(void)
{
	/*
	 * Set edchars to -2 to force initial binding, except
	 * we need default values for some deficient systems…
	 */
	edchars.erase = edchars.kill = edchars.intr = edchars.quit =
	    edchars.eof = -2;
	/* ^W */
	edchars.werase = 027;

	ainit(AEDIT);

	/* emacs mode ^O command */
	x_nextcmd = -1;

	/* for grepping: X_KP */
	x_init_emacs_one_defbinding(0, x_defbindings0, 32);
	x_init_emacs_one_defbinding(1, x_defbindings1, 48);
	x_init_emacs_one_defbinding(2, x_defbindings2, 24);
}
@


1.236
log
@last parts of Coherent patchkit: O_ACCMODE and termio
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.235 2012/05/04 20:49:01 tg Exp $");
a5369 31

void
x_mkraw(int fd, mksh_ttyst *ocb, bool forread)
{
	mksh_ttyst cb;

	if (ocb)
		mksh_tcget(fd, ocb);
	else
		ocb = &tty_state;

	cb = *ocb;
	if (forread) {
		cb.c_lflag &= ~(ICANON) | ECHO;
	} else {
		cb.c_iflag &= ~(INLCR | ICRNL);
		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
	}
#if defined(VLNEXT) && defined(_POSIX_VDISABLE)
	/* OSF/1 processes lnext when ~icanon */
	cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
#endif
	/* SunOS 4.1.x & OSF/1 processes discard(flush) when ~icanon */
#if defined(VDISCARD) && defined(_POSIX_VDISABLE)
	cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
#endif
	cb.c_cc[VTIME] = 0;
	cb.c_cc[VMIN] = 1;

	mksh_tcset(fd, &cb);
}
@


1.235
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.234 2012/04/06 15:06:42 tg Exp $");
d3277 1
a3277 1
		tcsetattr(tty_fd, TCSADRAIN, &tty_state);
d5372 1
a5372 1
x_mkraw(int fd, struct termios *ocb, bool forread)
d5374 1
a5374 1
	struct termios cb;
d5377 1
a5377 1
		tcgetattr(fd, ocb);
d5399 1
a5399 1
	tcsetattr(fd, TCSADRAIN, &cb);
@


1.234
log
@fix some comments
@
text
@d29 3
a31 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.232 2012/03/31 19:20:12 tg Exp $");
d5369 1
@


1.233
log
@add xep bounds check in x_goto, maybe this will fix the problem the Motorola guys are havink
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.231 2012/03/31 17:29:04 tg Exp $");
d3119 1
a3119 1
/* Lowercase N(1) words */
d3131 2
a3132 2
 *	This function is used to implement M-U,M-u,M-L,M-l,M-C and M-c
 *	to UPPER case, lower case or Capitalise words.
@


1.232
log
@a few more int → bool
@
text
@a1193 4
#ifdef DEBUG
		if (xcp > xep)
			abort();
#endif
d1517 3
a1519 1
	if (UTFMODE)
@


1.231
log
@add (#ifdef DEBUG) an assertion that xcp <= xep before doing an Emacs mode
command; DONG-DONG YANG reports they hit this condition
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.230 2012/03/23 23:25:25 tg Exp $");
d870 1
a870 1
static int x_adj_ok;
d875 1
a875 1
static int x_adj_done;
d913 1
a913 1
static int prompt_redraw;	/* 0 if newline forced after prompt */
d1124 2
a1125 2
	x_adj_ok = 1;
	prompt_redraw = 1;
d1129 1
a1129 1
	x_adj_done = 0;
d1136 1
a1136 1
		prompt_redraw = 0;
d1306 1
a1306 1
	int adj = x_adj_done;
d1316 1
a1316 1
	x_adj_ok = (xcp >= xlp);
d1327 1
a1327 1
	x_adj_ok = 1;
d1411 1
a1411 1
	x_adj_ok = 0;
d1431 1
a1431 1
	x_adj_ok = 1;
d1584 1
a1584 1
	int adj = x_adj_done;
d2041 1
a2041 1
	x_adj_ok = 0;
d2102 1
a2102 1
	x_adj_ok = 1;
d2775 1
a2775 1
	x_adj_done++;
d2897 1
a2897 1
	int adj = x_adj_done;
d3480 2
a3481 1
		prompt_redraw = cur_col = 0;
d3484 1
a3484 1
		prompt_redraw = 1;
@


1.230
log
@huh, I thought I had extended ${parameter@@#hash} already; make it so now,
but not yet things like ${parameter@@Fi} (1 if integer, 0 otherwise), etc.
also bump patchlevel and © years in recently changed files
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.229 2012/03/23 21:34:47 tg Exp $");
d1194 4
@


1.229
log
@fix real-life example From: Andrew Kudryashov <andrewinsilenthill@@gmail.com>
in <CABNd6wz3SSRWamUNQ-BNcp7z0pthOR156=Zy3qBYmXhTjvoYsg@@mail.gmail.com> but
by a different (cheaper) method than the one in his patch from message-id
<CABNd6ww7zFUQ4Ho2zQQzQyERy==8Hqg_y12Acmj1sF6ka4b4KQ@@mail.gmail.com>:

when completing, always replace the olen text with the new one, and only
then take the length of the x_expand()ed nlen text to compare and check
whether to set completed=true; this also means:

$ ls foo\+/<tab>
          ↓
$ ls foo+/

this matches reality even better and saves us a couple of string traversals
@
text
@d7 2
a8 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.228 2012/03/23 21:15:34 tg Exp $");
@


1.228
log
@address <CABNd6wz3SSRWamUNQ-BNcp7z0pthOR156=Zy3qBYmXhTjvoYsg@@mail.gmail.com>
From: Andrew Kudryashov <andrewinsilenthill@@gmail.com>

Hunk 1: “Also, I found that x_escape() does funny things to sequences
of backslashes” which was caused by improper quoting; use an empirical
list of chars to escape (only 0x20‥0x7E, everything else is SOL anyway)

Hunk 2: “and "\*" will be appended” was actually correct, but not in
all cases; handle these cases (and break 0x02 in filename)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.227 2012/01/29 01:41:12 tg Exp $");
d2724 7
a2730 6
	/* complete */
	if (nwords == 1 || nlen > olen) {
		x_goto(xbuf + start);
		x_delete(olen, false);
		x_escape(words[0], nlen, x_do_ins);
		x_adjust();
a2731 1
	}
@


1.227
log
@reduce stack usage a bit (several candidates for more, including $CC itself…)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.226 2011/12/29 23:36:10 tg Exp $");
d291 2
a292 2
	char **words;
	int nwords, i, idx;
d299 2
a300 2
	for (i = 0, idx = 0; toglob[i]; i++) {
		if (toglob[i] == '\\' && !escaping) {
d304 16
a319 8
		/* specially escape escaped [ or $ or ` for globbing */
		if (escaping && (toglob[i] == '[' ||
		    toglob[i] == '$' || toglob[i] == '`'))
			toglob[idx++] = QCHAR;

		toglob[idx] = toglob[i];
		idx++;
		if (escaping)
d321 2
d349 9
@


1.226
log
@when doing tab completion partial inserts in UTFMODE, honour multibyte character boundaries (LP: #909025)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.225 2011/12/11 18:07:45 tg Exp $");
d1805 1
a1805 1
	char pat[256 + 1];	/* pattern buffer */
@


1.225
log
@eek, mira, don’t leave debugging code lying around
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.224 2011/12/11 18:01:03 tg Exp $");
d627 4
@


1.224
log
@make ^O work like it did before we introduced x_modified(), that is,
editing the refetched input line doesn’t let it restart (but ^R does)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.223 2011/12/04 23:22:59 tg Exp $");
a1779 4
/*shellf( "x_histncp = %08X\n"
	"x_histp   = %08X\n"
	"histptr+1 = %08X\n", (uint32_t)x_histncp,
	(uint32_t)x_histp, (uint32_t)(histptr + 1));*/
@


1.223
log
@beautify a Vi function (no code change), from tech@@ discussion
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.222 2011/10/07 19:45:08 tg Exp $");
d862 1
d1134 1
d1137 1
a1137 1
		if (histptr - history >= off)
d1139 2
d1780 8
a1787 1
	x_nextcmd = source->line - (histptr - x_histp) + 1;
@


1.222
log
@merge “upper bound Emacs mode command repeat by input line length” from
oksh (slightly different implementation) and remark better plans (which
doesn’t mean bounding the repeat counter is bad, though…)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.221 2011/09/07 15:24:12 tg Exp $");
d3278 1
a3278 1
static int grabsearch(int, int, int, char *);
d4899 1
a4899 1
grabsearch(int save, int start, int fwd, char *pat)
d4913 1
a4913 2
		/* if (start != 0 && fwd && match(holdbuf, pat) >= 0) {} */
		/* XXX should strcmp be strncmp? */
@


1.221
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d1 1
a1 1
;/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.43 2011/03/14 21:20:01 okan Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.220 2011/08/27 18:06:41 tg Exp $");
d2881 1
a2881 1
	int n = 0;
d2888 3
d2895 1
@


1.220
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.219 2011/07/16 18:15:45 tg Exp $");
a697 1
	int staterr;
d737 1
a737 3
			staterr = 0;
			if ((search_access(words[i], X_OK, &staterr) >= 0) ||
			    (staterr == EISDIR)) {
d2467 1
a2467 1
			bi_errorf("%s: %s %s", a2, "no such", T_function);
d3291 17
a3307 17
#define C_	0x1		/* a valid command that isn't a M_, E_, U_ */
#define M_	0x2		/* movement command (h, l, etc.) */
#define E_	0x4		/* extended command (c, d, y) */
#define X_	0x8		/* long command (@@, f, F, t, T, etc.) */
#define U_	0x10		/* an UN-undoable command (that isn't a M_) */
#define B_	0x20		/* bad command (^@@) */
#define Z_	0x40		/* repeat count defaults to 0 (not 1) */
#define S_	0x80		/* search (/, ?) */

#define is_bad(c)	(classify[(c)&0x7f]&B_)
#define is_cmd(c)	(classify[(c)&0x7f]&(M_|E_|C_|U_))
#define is_move(c)	(classify[(c)&0x7f]&M_)
#define is_extend(c)	(classify[(c)&0x7f]&E_)
#define is_long(c)	(classify[(c)&0x7f]&X_)
#define is_undoable(c)	(!(classify[(c)&0x7f]&U_))
#define is_srch(c)	(classify[(c)&0x7f]&S_)
#define is_zerocount(c)	(classify[(c)&0x7f]&Z_)
d3312 1
a3312 1
	B_,	0,	0,	0,	0,	C_|U_,	C_|Z_,	0,
d3314 1
a3314 1
	M_,	C_|Z_,	0,	0,	C_|U_,	0,	C_,	0,
d3316 1
a3316 1
	C_,	0,	C_|U_,	0,	0,	0,	C_,	0,
d3318 1
a3318 1
	C_,	0,	0,	C_|Z_,	0,	0,	0,	0,
d3320 1
a3320 1
	M_,	0,	0,	C_,	M_,	M_,	0,	0,
d3322 1
a3322 1
	0,	0,	C_,	C_,	M_,	C_,	0,	C_|S_,
d3324 1
a3324 1
	M_,	0,	0,	0,	0,	0,	0,	0,
d3326 1
a3326 1
	0,	0,	0,	M_,	0,	C_,	0,	C_|S_,
d3328 1
a3328 1
	C_|X_,	C_,	M_,	C_,	C_,	M_,	M_|X_,	C_|U_|Z_,
d3330 1
a3330 1
	0,	C_,	0,	0,	0,	0,	C_|U_,	0,
d3332 1
a3332 1
	C_,	0,	C_,	C_,	M_|X_,	C_,	0,	M_,
d3334 1
a3334 1
	C_,	C_|U_,	0,	0,	C_|Z_,	0,	M_,	C_|Z_,
d3336 1
a3336 1
	0,	C_,	M_,	E_,	E_,	M_,	M_|X_,	C_|Z_,
d3338 1
a3338 1
	M_,	C_,	C_|U_,	C_|U_,	M_,	0,	C_|U_,	0,
d3340 1
a3340 1
	C_,	0,	X_,	C_,	M_|X_,	C_|U_,	C_|U_|Z_, M_,
d3342 1
a3342 1
	C_,	E_|U_,	0,	0,	M_|Z_,	0,	C_,	0
@


1.219
log
@somebody (who is probably inlining) complains about memset with the
third argument being 0; maybe (I think can only be this) fix that
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.34 2010/05/20 01:13:07 fgsch Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.218 2011/07/02 17:57:12 tg Exp $");
d72 1
a72 1
static int x_do_comment(char *, int, int *);
d75 1
a75 1
static int x_longest_prefix(int, char *const *);
d191 1
a191 1
x_do_comment(char *buf, int bsize, int *lenp)
d193 1
a193 1
	int i, j, len = *lenp;
d610 1
a610 1
static int
d613 2
a614 1
	int i, j, prefix_len;
d2216 1
a2216 1
	int len;
d2911 1
a2911 1
	int len = xep - xbuf;
d2933 2
a2934 1
	int vlen, lim = x_lastcp() - xbp;
d2950 1
a2950 1
	x_redraw(vlen);
d3251 4
a3254 4
	int winleft;
	int cbufsize;
	int linelen;
	int cursor;
d3267 1
a3267 1
static int putbuf(const char *, int, int);
d3407 1
a3407 1
	int len;		/* how much data in buffer */
d4686 1
a4686 1
putbuf(const char *buf, int len, int repl)
d4912 1
a4912 1
		/* if (start != 0 && fwd && match(holdbuf, pat) >= 0) { */
d5173 2
a5174 1
	int rval, nwords, start, end, match_len, flags;
@


1.218
log
@fix tab completion of "~/M↹"
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.217 2011/06/30 14:09:04 tg Exp $");
d3276 1
a3276 1
static void redraw_line(int);
d3453 4
a3456 2
	(void)memset(wbuf[0], ' ', wbuf_len);
	(void)memset(wbuf[1], ' ', wbuf_len);
d3964 1
a3964 1
			redraw_line(1);
d4930 1
a4930 1
redraw_line(int newl)
d4932 2
a4933 1
	(void)memset(wbuf[win], ' ', wbuf_len);
d5215 1
a5215 1
			redraw_line(0);
d5297 1
a5297 1
	redraw_line(0);
@


1.217
log
@fix, even removing code, good…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.216 2011/06/30 13:48:12 tg Exp $");
d576 2
a577 1
		} else if (saw_dollar || *toglob == '~') {
@


1.216
log
@tabcomplete ~ and ~foo like $FOO (idea by yofuh)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.215 2011/06/04 16:44:30 tg Exp $");
d536 1
a536 1
		bool saw_slash = false, saw_dollar = false, saw_glob = false;
d567 1
a567 2
			} else if (*s == '/')
				saw_slash = true;
d579 1
a579 1
		} else if (saw_slash) {
@


1.215
log
@typo in comment, from obsd
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.214 2011/06/04 15:11:29 tg Exp $");
d61 1
a61 1
#define XCF_IS_VARSUB	BIT(4)	/* return flag: is $FOO substitution */
d577 1
a577 1
		} else if (saw_dollar) {
d579 2
a580 2
			*flagsp |= XCF_IS_VARSUB;
		} else if (*toglob != '~' || saw_slash) {
d2704 4
a2707 1
	/* add space if single non-dir match and not parameter substitution */
d2709 1
a2709 1
	    !(flags & XCF_IS_VARSUB)) {
d5260 2
a5261 2
		 * append a space if this is not a directory or the
		 * result of a parameter substitution
d5264 1
a5264 1
		    !(flags & XCF_IS_VARSUB))
@


1.214
log
@fix regression found by hondza: the full path was shown when tab-completing
@
text
@d2 1
a2 1
/*	$OpenBSD: edit.h,v 1.8 2005/03/28 21:28:22 deraadt Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.213 2011/06/04 15:06:50 tg Exp $");
d55 1
a55 1
/* x_fc_glob() flags */
@


1.213
log
@we use tobool() nowadays
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.212 2011/05/29 02:18:49 tg Exp $");
d599 2
a600 1
	*flagsp |= XCF_IS_COMMAND;
@


1.212
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.211 2011/04/22 12:16:38 tg Exp $");
d59 1
a59 1
#define XCF_COMMAND_FILE (XCF_COMMAND|XCF_FILE)
d524 1
a524 1
	if (!(*flagsp & XCF_COMMAND))
d2687 2
a2688 1
		x_print_expansions(nwords, words, flags & XCF_IS_COMMAND);
d2710 2
a2711 1
		x_print_expansions(nwords, words, flags & XCF_IS_COMMAND);
d5206 1
a5206 1
			    flags & XCF_IS_COMMAND);
d5288 1
a5288 1
	x_print_expansions(nwords, words, i & XCF_IS_COMMAND);
@


1.211
log
@this one is trickier
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.210 2011/04/22 12:15:38 tg Exp $");
d71 1
a71 1
static bool x_mode(bool);
d3183 1
a3183 1
static bool
a3186 1
	bool prev;
d3189 1
a3189 2
		return (x_cur_mode);
	prev = x_cur_mode;
d3193 1
a3193 1
		struct termios cb;
d3195 5
a3199 7
		cb = tty_state;

		edchars.erase = cb.c_cc[VERASE];
		edchars.kill = cb.c_cc[VKILL];
		edchars.intr = cb.c_cc[VINTR];
		edchars.quit = cb.c_cc[VQUIT];
		edchars.eof = cb.c_cc[VEOF];
d3201 1
a3201 7
		edchars.werase = cb.c_cc[VWERASE];
#endif
		cb.c_iflag &= ~(INLCR | ICRNL);
		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
#if defined(VLNEXT) && defined(_POSIX_VDISABLE)
		/* OSF/1 processes lnext when ~icanon */
		cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
a3202 8
		/* SunOS 4.1.x & OSF/1 processes discard(flush) when ~icanon */
#if defined(VDISCARD) && defined(_POSIX_VDISABLE)
		cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
#endif
		cb.c_cc[VTIME] = 0;
		cb.c_cc[VMIN] = 1;

		tcsetattr(tty_fd, TCSADRAIN, &cb);
a3233 2

	return (prev);
d5321 31
@


1.210
log
@more static initialisers (verified using nm comparision between mksh
built with/-out "-ffunction-sections -fdata-sections -Wl,--gc-sections"
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.209 2011/04/22 12:10:13 tg Exp $");
d3423 4
a3426 4
enum expand_mode {
	NONE, EXPAND, COMPLETE, PRINT
};
static enum expand_mode expanded = NONE;	/* last input was expanded */
@


1.209
log
@static initialisers implicitly null out a variable (I think)
so take care of that (for global variables) to avoid them
moving from .bss to .data
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.208 2011/04/09 21:01:00 tg Exp $");
d1189 1
a1189 1
	static int left = 0, pos, save_arg;
@


1.208
log
@avoid namespace conflicts with __attribute__(…)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.207 2011/03/16 20:31:32 tg Exp $");
d875 1
a875 1
static char *macroptr = NULL;	/* bind key macro active? */
@


1.207
log
@RCSID sync with openbsd, one we had already, one Okan Demirmen stole
from mksh (but attributed, so it’s okay, considering the amount of
patch is not large enough to warrant copyright stuff)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.206 2011/03/13 01:20:16 tg Exp $");
d911 1
a911 1
    MKSH_A_NONNULL((nonnull (1)));
@


1.206
log
@lint is your friend
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.42 2009/06/02 06:47:47 halex Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.205 2011/03/07 20:30:35 tg Exp $");
@


1.205
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.204 2011/02/09 13:08:16 tg Exp $");
d1141 1
a1141 1
	while (1) {
d1800 1
a1800 1
	while (1) {
d3477 1
a3477 1
	while (1) {
@


1.204
log
@fix prev-hist-word again, thanks Jörg-Volker Peetz
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.203 2011/02/03 15:57:50 tg Exp $");
d2447 1
a2447 1
	hastilde = *m1;
@


1.203
log
@refactor code to be able to track whether we have a parameter substitution
or a “proper” glob expansion; if there’s a dollar, but not a glob, refrain
from appending a space later (LP: #710539)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.202 2011/01/21 22:43:17 tg Exp $");
d857 1
a857 1
static int x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */
d1163 1
a1163 1
			x_arg_defaulted = 1;
d2267 1
a2267 1
		x_arg_defaulted = 1;
d2877 2
a2878 1
	int n = 0, first = 1;
d2882 1
a2882 1
	for (; c >= 0 && ksh_isdigit(c); c = x_e_getc(), first = 0)
d2884 3
d2890 1
a2890 1
		x_arg_defaulted = 1;
d2894 1
a2894 1
		x_arg_defaulted = 0;
d3003 2
d3011 2
a3012 1
	}
d3020 3
a3022 1
	if (x_arg_defaulted) {
d3035 1
d3044 1
a3044 1
		while (x_arg-- > 1) {
@


1.202
log
@For prev-hist-word, when doing other things in between reset the counter
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.201 2010/09/14 21:26:09 tg Exp $");
d60 3
d74 1
a74 2
static int x_cf_glob(int, const char *, int, int, int *, int *, char ***,
    bool *);
a93 3
static char *add_glob(const char *, int)
    MKSH_A_NONNULL((nonnull (1)))
    MKSH_A_BOUNDED(string, 1, 2);
d96 2
a97 6
static int x_file_glob(int, const char *, int, char ***)
    MKSH_A_NONNULL((nonnull (2)))
    MKSH_A_BOUNDED(string, 2, 3);
static int x_command_glob(int, const char *, int, char ***)
    MKSH_A_NONNULL((nonnull (2)))
    MKSH_A_BOUNDED(string, 2, 3);
d109 4
a112 1
	/* set to -2 to force initial binding */
d115 2
a116 2
	/* default value for deficient systems */
	edchars.werase = 027;	/* ^W */
d137 2
a138 1
		i = -1;		/* internal error */
d181 2
a182 1
/* Handle the commenting/uncommenting of a line.
d196 2
a197 1
		return (1); /* somewhat arbitrary - it's what AT&T ksh does */
d242 2
a243 1
	/* Check if all matches are in the same directory (in this
d277 2
a278 1
		XPfree(l); /* not x_free_words() */
d289 1
a289 1
x_file_glob(int flags MKSH_A_UNUSED, const char *str, int slen, char ***wordsp)
d291 1
a291 1
	char *toglob, **words;
a296 5
	if (slen < 0)
		return (0);

	toglob = add_glob(str, slen);

d339 3
a341 2
		/* Check if globbing failed (returned glob pattern),
		 * but be careful (E.g. toglob == "ab*" when the file
a354 1
	afree(toglob, ATEMP);
d382 1
a382 1
x_command_glob(int flags, const char *str, int slen, char ***wordsp)
d384 1
a384 1
	char *toglob, *pat, *fpath;
a388 5
	if (slen < 0)
		return (0);

	toglob = add_glob(str, slen);

a390 1
	afree(toglob, ATEMP);
d476 2
a477 1
	/* Keep going backwards to start of word (has effect of allowing
d498 2
a499 1
			/* If command has a /, path, etc. is not searched;
d516 2
a517 2
x_cf_glob(int flags, const char *buf, int buflen, int pos, int *startp,
    int *endp, char ***wordsp, bool *is_commandp)
d519 1
a519 1
	int len, nwords;
d524 1
a524 1
	if (!(flags & XCF_COMMAND))
d526 2
a527 1
	/* Don't do command globing on zero length strings - it takes too
d534 61
a594 3
	nwords = is_command ?
	    x_command_glob(flags, buf + *startp, len, &words) :
	    x_file_glob(flags, buf + *startp, len, &words);
d599 1
a599 2
	if (is_commandp)
		*is_commandp = is_command;
a605 41
/* Given a string, copy it and possibly add a '*' to the end.
 * The new string is returned.
 */
static char *
add_glob(const char *str, int slen)
{
	char *toglob, *s;
	bool saw_slash = false;

	if (slen < 0)
		return (NULL);

	/* for clang's static analyser, the nonnull attribute isn't enough */
	mkssert(str != NULL);

	strndupx(toglob, str, slen + 1, ATEMP); /* + 1 for "*" */
	toglob[slen] = '\0';

	/*
	 * If the pathname contains a wildcard (an unquoted '*',
	 * '?', or '[') or parameter expansion ('$'), or a ~username
	 * with no trailing slash, then it is globbed based on that
	 * value (i.e., without the appended '*').
	 */
	for (s = toglob; *s; s++) {
		if (*s == '\\' && s[1])
			s++;
		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$' ||
		    (s[1] == '(' /*)*/ && /* *s in '*','?' already checked */
		    (*s == '+' || *s == '@@' || *s == '!')))
			break;
		else if (*s == '/')
			saw_slash = true;
	}
	if (!*s && (*toglob != '~' || saw_slash)) {
		toglob[slen] = '*';
		toglob[slen + 1] = '\0';
	}
	return (toglob);
}

d636 2
a637 1
/* Return the offset of the basename of string s (which ends at se - need not
d709 2
a710 1
			/* Copy sp into xp, stuffing any MAGIC characters
d729 2
a730 1
		glob_str(Xstring(xs, xp), wp, 1); /* mark dirs */
d826 2
a827 1
/* Arguments for do_complete()
d1018 2
a1019 1
	/* These for ansi arrow keys: arguablely shouldn't be here by
d1175 2
a1176 1
		case KINTR:	/* special case for interrupt */
d1287 2
a1288 1
	if (adj == x_adj_done) {	/* has x_adjust() been called? */
d1377 4
a1380 2
	memmove(xcp, xcp + nb, xep - xcp + 1);	/* Copies the NUL */
	x_adj_ok = 0;			/* don't redraw */
d1385 1
a1385 1
	 * there is no need to ' ','\b'.
d1497 2
a1498 1
	} else if (cp < xcp) {		/* move back */
d1501 2
a1502 1
	} else if (cp > xcp) {		/* move forward */
d1542 2
a1543 1
		return (4);	/* Kludge, tabs are always four spaces. */
d1545 2
a1546 1
		return (2);	/* control unsigned char */
d1729 2
a1730 1
/* Goto a particular history number obtained from argument.
d1863 2
a1864 1
		} else { /* other command */
d1996 2
a1997 1
/* Redraw (part of) the line. If limit is < 0, the everything is redrawn
d2034 2
a2035 1
			i = 0;			/* we fill the line */
d2052 2
a2053 1
		if (xep > xlp) {		/* more off screen */
d2077 2
a2078 1
	/* What transpose is meant to do seems to be up for debate. This
d2099 3
a2101 2
		/* Gosling/Unipress emacs style: Swap two characters before the
		 * cursor, do not change cursor position
d2118 2
a2119 1
		/* GNU emacs style: Swap the characters before and under the
d2316 2
a2317 1
			if (*cp >= '?')	/* includes '?'; ASCII */
d2381 2
a2382 1
    bool macro,			/* bind -m */
d2384 2
a2385 1
    bool list)			/* bind -l */
a2642 1
	bool is_command;
d2644 3
a2646 2
	nwords = x_cf_glob(XCF_FILE, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words, &is_command);
d2654 3
a2656 1
	for (i = 0; i < nwords;) {
a2667 1
/* type == 0 for list, 1 for complete and 2 for complete-list */
d2669 4
a2672 1
do_complete(int flags,	/* XCF_{COMMAND,FILE,COMMAND_FILE} */
d2677 1
a2677 1
	bool is_command, completed = false;
d2679 2
a2680 2
	nwords = x_cf_glob(flags, xbuf, xep - xbuf, xcp - xbuf,
	    &start, &end, &words, &is_command);
d2687 1
a2687 1
		x_print_expansions(nwords, words, is_command);
d2702 3
a2704 2
	/* add space if single non-dir match */
	if (nwords == 1 && words[0][nlen - 1] != '/') {
d2709 1
a2709 1
		x_print_expansions(nwords, words, is_command);
d2718 2
a2719 1
/* NAME:
d2735 2
a2736 1
	x_adj_done++;			/* flag the fact that we were called. */
d2864 2
a2865 1
/* NAME:
d2879 2
a2880 1
	c &= 255;	/* strip command prefix */
d2976 2
a2977 1
/* NAME:
d3074 2
a3075 1
/* NAME:
d3105 2
a3106 1
			if (c == 'L')		/* lowercase */
d3108 2
a3109 1
			else			/* uppercase, capitalise */
d3117 2
a3118 1
			if (c == 'U')		/* uppercase */
d3120 2
a3121 1
			else			/* lowercase, capitalise */
d3132 2
a3133 1
/* NAME:
d3200 1
a3200 1
		/* osf/1 processes lnext when ~icanon */
d3203 1
a3203 1
		/* sunos 4.1.x & osf/1 processes discard(flush) when ~icanon */
d3399 2
a3400 1
/* Information for keeping track of macros that are being expanded.
d3864 2
a3865 1
	/* If any chars are entered before escape, trash the saved insert
d4388 4
a4391 2
		case '=':			/* AT&T ksh */
		case Ctrl('e'):			/* Nonstandard vi/ksh */
d4396 2
a4397 1
		case Ctrl('i'):			/* Nonstandard vi/ksh */
d4403 2
a4404 1
		case Ctrl('['):			/* some annoying AT&T kshs */
d4407 4
a4410 2
		case '\\':			/* AT&T ksh */
		case Ctrl('f'):			/* Nonstandard vi/ksh */
d4415 4
a4418 2
		case '*':			/* AT&T ksh */
		case Ctrl('x'):			/* Nonstandard vi/ksh */
d5069 2
a5070 1
		/* POSIX says to use * for this but that is a globbing
d5119 1
a5119 3
	int rval = 0;
	int nwords;
	int start, end;
a5120 1
	int i;
d5134 3
a5136 3
	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
	    es->cbuf, es->linelen, es->cursor,
	    &start, &end, &words, NULL);
d5146 2
a5147 1
	for (i = 0; i < nwords; ) {
d5172 1
a5172 1
	int rval, nwords, start, end, match_len;
d5175 1
a5175 1
	bool is_command, is_unique;
d5194 3
a5196 2
	/* XCF_FULLPATH for count 'cause the menu printed by print_expansions()
	 * was done this way.
d5198 5
a5202 3
	nwords = x_cf_glob(XCF_COMMAND_FILE | (count ? XCF_FULLPATH : 0),
	    es->cbuf, es->linelen, es->cursor,
	    &start, &end, &words, &is_command);
d5213 2
a5214 1
			x_print_expansions(nwords, words, is_command);
d5222 1
a5222 1
		if (is_command) {
d5241 2
a5242 1
		expanded = COMPLETE;	/* next call will list completions */
d5250 4
a5253 2
	/* escape all shell-sensitive characters and put the result into
	 * command buffer */
d5257 2
a5258 1
		/* If exact match, don't undo. Allows directory completions
d5263 6
a5268 2
		/* If not a directory, add a space to the end... */
		if (match_len > 0 && match[match_len - 1] != '/')
d5276 2
a5277 1
	lastac = 0;	 /* prevent this from being redone... */
d5286 1
a5286 1
	int start, end, nwords;
a5287 1
	bool is_command;
d5289 3
a5291 3
	nwords = x_cf_glob(XCF_COMMAND_FILE | XCF_FULLPATH,
	    est->cbuf, est->linelen, est->cursor,
	    &start, &end, &words, &is_command);
d5296 1
a5296 1
	x_print_expansions(nwords, words, is_command);
@


1.201
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d7 1
a7 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.200 2010/09/05 19:51:31 tg Exp $");
d2953 1
a2953 1
	int m;
d2955 6
a2960 3
	if (xmp && modified > 1)
		x_kill_region(0);
	m = modified ? modified : 1;
@


1.200
log
@optimise error messages, option parsing, and make more builtins
recognise "--", costs us 20 .text 0 .data 0 .bss
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.199 2010/08/28 20:22:15 tg Exp $");
d427 1
a427 1
		    alloc(nwords * sizeof(struct path_order_info), ATEMP);
d681 1
a681 1
	const char *sp, *p;
d683 2
a684 1
	int staterr, pathlen, patlen, oldsize, newsize, i, j;
d687 3
a689 2
	patlen = strlen(pat) + 1;
	sp = lpath;
d2471 1
a2471 1
	x_tab = alloc(X_NTABS * sizeof(*x_tab), AEDIT);
d2482 1
a2482 1
	x_atab = alloc(X_NTABS * sizeof(*x_atab), AEDIT);
d3917 1
a3917 1
				int olen, nlen;
d3934 4
@


1.199
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.198 2010/08/28 18:50:47 tg Exp $");
d2406 1
a2406 1
		bi_errorf("%s: %s '%s'", "bind", "too long key sequence", msg);
@


1.198
log
@improve string pooling: saves 316 bytes in .text
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.197 2010/08/28 16:47:08 tg Exp $");
d327 1
a327 1
		internal_warningf("%s: %s", "fileglob", "substitute error");
d2248 1
a2248 1
	 * - ESC+[ or ESC+O or Ctrl-X (Præfix 2)
d2359 1
a2359 1
		bi_errorf("cannot bind, not a tty");
d2401 1
a2401 1
		char msg[256] = "key sequence '";
d2403 1
a2403 1
		m1 = msg + strlen(msg);
d2406 1
a2406 1
		bi_errorf("'%s' too long", msg);
d2431 1
a2431 1
			bi_errorf("%s: %s", a2, "no such function");
@


1.197
log
@fix blocking_read prototype
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.196 2010/07/25 11:35:40 tg Exp $");
d327 1
a327 1
		internal_warningf("fileglob: substitute error");
d2406 1
a2406 1
		bi_errorf("%s' too long", msg);
d2431 1
a2431 1
			bi_errorf("%s: no such function", a2);
d4814 1
a4814 1
		internal_warningf("grabhist: bad history array");
@


1.196
log
@a tad annoying, when external programmes such as GNU screen are running,
we don’t get SIGWINCH when the window size changes during the runtime of
that, so, the signal is only usable reliably during editing in the shell
and we re-check the window size before each interactive edit line again
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.195 2010/07/17 22:09:32 tg Exp $");
d151 1
a151 1
	int n;
@


1.195
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.194 2010/07/04 18:52:52 tg Exp $");
d62 1
d157 10
a836 1
static int xx_cols;
a3122 9
	if (onoff && got_winch) {
		change_winsz();
		if (x_cols != xx_cols && editmode == 1) {
			/* redraw line in Emacs mode */
			xx_cols = x_cols;
			x_e_rebuildline(MKSH_CLRTOEOL_STRING);
		}
	}

@


1.194
log
@this one was found by scan-build from llvm+clang
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.193 2010/07/04 17:45:12 tg Exp $");
d2261 1
a2261 1
	char *new, *op;
d2266 2
a2267 2
	strdupx(new, cp, ap);
	op = new;
d2284 1
a2284 1
	return (new);
d3314 1
a3314 1
static void		restore_edstate(struct edstate *old, struct edstate *new);
d4576 1
a4576 1
	struct edstate *new;
d4578 8
a4585 8
	new = alloc(sizeof(struct edstate), APERM);
	new->cbuf = alloc(old->cbufsize, APERM);
	memcpy(new->cbuf, old->cbuf, old->linelen);
	new->cbufsize = old->cbufsize;
	new->linelen = old->linelen;
	new->cursor = old->cursor;
	new->winleft = old->winleft;
	return (new);
d4589 1
a4589 1
restore_edstate(struct edstate *new, struct edstate *old)
d4591 4
a4594 4
	memcpy(new->cbuf, old->cbuf, old->linelen);
	new->linelen = old->linelen;
	new->cursor = old->cursor;
	new->winleft = old->winleft;
@


1.193
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.192 2010/05/22 12:37:49 tg Exp $");
d1947 1
a1947 1
	shf_fprintf(shl_out, clrstr);
@


1.192
log
@RCSID sync with oksh, and apply a simplification of theirs, but WITH a
comment what/why added (to aid understanding this code)

I wonder, though, why their x_escape now almost¹ looks like ours… is
that a coïncidence, or do they steal again (without understanding why)?

① they’re missing the semicolon but falsely added the closing bracket
@
text
@d28 14
a41 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.191 2010/03/27 15:26:19 tg Exp $");
d61 1
d84 3
d88 1
d105 1
a117 1
	change_winsz();
d139 1
a140 1
	change_winsz();
d1112 1
d1945 8
d1955 1
a1955 14
/*
 * in later versions we might use libtermcap for this, but since external
 * dependencies are problematic, this has not yet been decided on; another
 * good string is "\033c" except on hardware terminals like the DEC VT420
 * which do a full power cycle then...
 */
#ifndef MKSH_CLS_STRING
#define MKSH_CLS_STRING	"\033[;H\033[J"
#endif
	shf_fprintf(shl_out, MKSH_CLS_STRING);
	x_putc('\r');
	x_init_prompt();
	x_redraw(0);
	return (KSTD);
d3113 9
d3407 1
@


1.191
log
@Let hi-bit7 characters be “motion characters” for the Emacs editing mode;
this fixes the asymmetry of Esc+b/Esc+f on 「ls ディレクトリ」 as well as
doing ^W on it
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.33 2007/08/02 10:50:25 fgsch Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.190 2010/02/23 18:13:02 tg Exp $");
d553 2
a554 1
		    (s[1] == '(' && vstrchr("*+?@@!", *s)))
@


1.190
log
@x_bind cannot have the nonnull attribute
cought by Frank “enstein” Terbeck «ft:#grml» (efftee), 10x
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.189 2010/01/29 09:34:26 tg Exp $");
d774 2
a775 2
			/* Separator for motion */
#define	is_mfs(c)	(!(ksh_isalnux(c) || (c) == '$'))
@


1.189
log
@remove some more of this ugliness
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.188 2010/01/08 22:21:04 tg Exp $");
a859 3
int x_bind(const char *, const char *, bool, bool)
#else
int x_bind(const char *, const char *, bool)
a860 1
    MKSH_A_NONNULL((nonnull (1, 2)));
@


1.188
log
@While we were supposed to use Ctrl-Arrowkey for wordwise jumping,
some idiotic terminal emulators and/or people seem to use the es-
cape codes normally denoting Alt-Arrowkey instead so let's simply
bind them to the vt_hack as well... (untested)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.187 2009/12/12 22:27:05 tg Exp $");
d4037 1
a4037 1
			/* FALLTHRU */
d4191 1
a4191 1
			/* FALLTHRU */
@


1.187
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d7 1
a7 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.186 2009/12/05 22:19:41 tg Exp $");
d2222 1
a2222 1
	if ((c = x_e_getc()) != '5')
d2225 9
@


1.186
log
@strchr related fixes
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.185 2009/12/05 17:43:44 tg Exp $");
d74 2
a75 2
    __attribute__((nonnull (1)))
    __bound_att__((bounded (string, 1, 2)));
d79 2
a80 2
    __attribute__((nonnull (2)))
    __bound_att__((bounded (string, 2, 3)));
d82 2
a83 2
    __attribute__((nonnull (2)))
    __bound_att__((bounded (string, 2, 3)));
d257 1
a257 1
x_file_glob(int flags __unused, const char *str, int slen, char ***wordsp)
d864 1
a864 1
    __attribute__((nonnull (1, 2)));
d869 1
a869 1
    __attribute__((nonnull (1)));
d1255 1
a1255 1
x_del_back(int c __unused)
d1271 1
a1271 1
x_del_char(int c __unused)
d1363 1
a1363 1
x_del_bword(int c __unused)
d1370 1
a1370 1
x_mv_bword(int c __unused)
d1377 1
a1377 1
x_mv_fword(int c __unused)
d1384 1
a1384 1
x_del_fword(int c __unused)
d1539 1
a1539 1
x_mv_back(int c __unused)
d1554 1
a1554 1
x_mv_forw(int c __unused)
d1573 1
a1573 1
x_search_char_forw(int c __unused)
d1595 1
a1595 1
x_search_char_back(int c __unused)
d1630 1
a1630 1
x_newline(int c __unused)
d1640 1
a1640 1
x_end_of_text(int c __unused)
d1650 1
a1650 1
x_beg_hist(int c __unused)
d1657 1
a1657 1
x_end_hist(int c __unused)
d1664 1
a1664 1
x_prev_com(int c __unused)
d1671 1
a1671 1
x_next_com(int c __unused)
d1682 1
a1682 1
x_goto_hist(int c __unused)
d1722 1
a1722 1
x_nl_next_com(int c __unused)
d1845 1
a1845 1
x_search_hist_up(int c __unused)
d1852 1
a1852 1
x_search_hist_dn(int c __unused)
d1889 1
a1889 1
x_del_line(int c __unused)
d1908 1
a1908 1
x_mv_end(int c __unused)
d1915 1
a1915 1
x_mv_begin(int c __unused)
d1922 1
a1922 1
x_draw_line(int c __unused)
d1929 1
a1929 1
x_cls(int c __unused)
d2021 1
a2021 1
x_transpose(int c __unused)
d2086 1
a2086 1
x_literal(int c __unused)
d2093 1
a2093 1
x_meta1(int c __unused)
d2100 1
a2100 1
x_meta2(int c __unused)
d2107 1
a2107 1
x_kill(int c __unused)
d2139 1
a2139 1
x_yank(int c __unused)
d2157 1
a2157 1
x_meta_yank(int c __unused)
d2182 1
a2182 1
x_abort(int c __unused)
d2193 1
a2193 1
x_error(int c __unused)
d2469 1
a2469 1
x_set_mark(int c __unused)
d2476 1
a2476 1
x_kill_region(int c __unused)
d2499 1
a2499 1
x_xchg_point_mark(int c __unused)
d2514 1
a2514 1
x_noop(int c __unused)
d2523 1
a2523 1
x_comp_comm(int c __unused)
d2530 1
a2530 1
x_list_comm(int c __unused)
d2537 1
a2537 1
x_complete(int c __unused)
d2544 1
a2544 1
x_enumerate(int c __unused)
d2551 1
a2551 1
x_comp_file(int c __unused)
d2558 1
a2558 1
x_list_file(int c __unused)
d2565 1
a2565 1
x_comp_list(int c __unused)
d2572 1
a2572 1
x_expand(int c __unused)
d2821 1
a2821 1
x_comment(int c __unused)
d2842 1
a2842 1
x_version(int c __unused)
d2876 1
a2876 1
x_edit_line(int c __unused)
d2917 1
a2917 1
x_prev_histword(int c __unused)
d2975 1
a2975 1
x_fold_upper(int c __unused)
d2982 1
a2982 1
x_fold_lower(int c __unused)
d2989 1
a2989 1
x_fold_capitalise(int c __unused)
d5171 1
a5171 1
print_expansions(struct edstate *est, int cmd __unused)
@


1.185
log
@llvm/clang scan-build is now content…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.184 2009/10/30 00:57:36 tg Exp $");
d3894 1
a3894 1
					while ((p = strchr(p, '\0')) && p[1])
@


1.184
log
@make tab completing filenames with ':' '=' '$' '`' work as well as
others (colon and equals sign need to be simply escaped, while dollar
sign and accent gravis need double escaping like opening square brak-
ket did back then); add = to C_QUOTE to simplify (doesn't break any-
thing) and sort these strings asciibetically while here
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.183 2009/09/26 04:01:31 tg Exp $");
d73 3
a75 1
static char *add_glob(const char *, int);
d78 6
a83 2
static int x_file_glob(int, const char *, int, char ***);
static int x_command_glob(int, const char *, int, char ***);
d537 3
d860 1
a860 1
int x_bind(const char *, const char *, bool, bool);
d862 1
a862 1
int x_bind(const char *, const char *, bool);
d864 1
d868 2
a869 1
static char *x_mapin(const char *, Area *);
d2243 3
d2355 1
a2355 1
	prefix = key = 0;
@


1.183
log
@* move the utf_* functions to a smaller file, to reduce the pain the
  CPU has to endure while gcc is crunching on edit.c
* comment on mksh not using _exactly_ OPTU-8/OPTU-16 (XXX)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.182 2009/09/24 17:15:30 tg Exp $");
d254 2
a255 1
	int nwords, i, idx, escaping;
d265 1
a265 1
	escaping = 0;
d268 1
a268 1
			escaping = 1;
d271 3
a273 2
		/* specially escape escaped [ for globbing */
		if (escaping && toglob[i] == '[')
d279 1
a279 1
			escaping = 0;
d713 1
a713 1
		if (vstrchr("\\$()[?{}*&;#|<>\"'`", s[add]) ||
@


1.182
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.181 2009/09/23 18:04:54 tg Exp $");
a80 1
static int utf_wcwidth(unsigned int);
a733 226
/* UTF-8 hack: high-level functions */

int
utf_widthadj(const char *src, const char **dst)
{
	size_t len;
	unsigned int wc;
	int width;

	if (!UTFMODE || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
	    wc == 0)
		len = width = 1;
	else if ((width = utf_wcwidth(wc)) < 0)
		/* XXX use 2 for x_zotc3 here? */
		width = 1;

	if (dst)
		*dst = src + len;
	return (width);
}

int
utf_mbswidth(const char *s)
{
	size_t len;
	unsigned int wc;
	int width = 0, cw;

	if (!UTFMODE)
		return (strlen(s));

	while (*s)
		if (((len = utf_mbtowc(&wc, s)) == (size_t)-1) ||
		    ((cw = utf_wcwidth(wc)) == -1)) {
			s++;
			width += 1;
		} else {
			s += len;
			width += cw;
		}
	return (width);
}

const char *
utf_skipcols(const char *p, int cols)
{
	int c = 0;

	while (c < cols)
		c += utf_widthadj(p, &p);
	return (p);
}

size_t
utf_ptradj(const char *src)
{
	register size_t n;

	if (!UTFMODE ||
	    *(const unsigned char *)(src) < 0xC2 ||
	    (n = utf_mbtowc(NULL, src)) == (size_t)-1)
		n = 1;
	return (n);
}

/* UTF-8 hack: low-level functions */

/* --- begin of wcwidth.c excerpt --- */
/*-
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
 *
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 */

__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.8 2008/09/20 12:01:18 tg Exp $");

static int
utf_wcwidth(unsigned int c)
{
	static const struct cbset {
		unsigned short first;
		unsigned short last;
	} comb[] = {
		{ 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
		{ 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
		{ 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
		{ 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
		{ 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
		{ 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
		{ 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
		{ 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
		{ 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
		{ 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
		{ 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
		{ 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
		{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
		{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
		{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
		{ 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
		{ 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
		{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
		{ 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
		{ 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
		{ 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
		{ 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
		{ 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
		{ 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
		{ 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
		{ 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
		{ 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
		{ 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
		{ 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
		{ 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
	};
	size_t min = 0, mid, max = NELEM(comb) - 1;

	/* test for 8-bit control characters */
	if (c < 32 || (c >= 0x7f && c < 0xa0))
		return (c ? -1 : 0);

	/* binary search in table of non-spacing characters */
	if (c >= comb[0].first && c <= comb[max].last)
		while (max >= min) {
			mid = (min + max) / 2;
			if (c > comb[mid].last)
				min = mid + 1;
			else if (c < comb[mid].first)
				max = mid - 1;
			else
				return (0);
		}

	/* if we arrive here, c is not a combining or C0/C1 control char */
	return ((c >= 0x1100 && (
	    c <= 0x115f || /* Hangul Jamo init. consonants */
	    c == 0x2329 || c == 0x232a ||
	    (c >= 0x2e80 && c <= 0xa4cf && c != 0x303f) || /* CJK ... Yi */
	    (c >= 0xac00 && c <= 0xd7a3) || /* Hangul Syllables */
	    (c >= 0xf900 && c <= 0xfaff) || /* CJK Compatibility Ideographs */
	    (c >= 0xfe10 && c <= 0xfe19) || /* Vertical forms */
	    (c >= 0xfe30 && c <= 0xfe6f) || /* CJK Compatibility Forms */
	    (c >= 0xff00 && c <= 0xff60) || /* Fullwidth Forms */
	    (c >= 0xffe0 && c <= 0xffe6))) ? 2 : 1);
}
/* --- end of wcwidth.c excerpt --- */

/* +++ CESU-8 multibyte and wide character conversion crafted for mksh +++ */

size_t
utf_mbtowc(unsigned int *dst, const char *src)
{
	const unsigned char *s = (const unsigned char *)src;
	unsigned int c, wc;

	if ((wc = *s++) < 0x80) {
 out:
		if (dst != NULL)
			*dst = wc;
		return (wc ? ((const char *)s - src) : 0);
	}
	if (wc < 0xC2 || wc >= 0xF0)
		/* < 0xC0: spurious second byte */
		/* < 0xC2: non-minimalistic mapping error in 2-byte seqs */
		/* > 0xEF: beyond BMP */
		goto ilseq;

	if (wc < 0xE0) {
		wc = (wc & 0x1F) << 6;
		if (((c = *s++) & 0xC0) != 0x80)
			goto ilseq;
		wc |= c & 0x3F;
		goto out;
	}

	wc = (wc & 0x0F) << 12;

	if (((c = *s++) & 0xC0) != 0x80)
		goto ilseq;
	wc |= (c & 0x3F) << 6;

	if (((c = *s++) & 0xC0) != 0x80)
		goto ilseq;
	wc |= c & 0x3F;

	/* Check for non-minimalistic mapping error in 3-byte seqs */
	if (wc >= 0x0800 && wc <= 0xFFFD)
		goto out;
 ilseq:
	return ((size_t)(-1));
}

size_t
utf_wctomb(char *dst, unsigned int wc)
{
	unsigned char *d;

	if (wc < 0x80) {
		*dst = wc;
		return (1);
	}

	d = (unsigned char *)dst;
	if (wc < 0x0800)
		*d++ = (wc >> 6) | 0xC0;
	else {
		*d++ = ((wc = wc > 0xFFFD ? 0xFFFD : wc) >> 12) | 0xE0;
		*d++ = ((wc >> 6) & 0x3F) | 0x80;
	}
	*d++ = (wc & 0x3F) | 0x80;
	return ((char *)d - dst);
}
@


1.181
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.180 2009/09/20 17:23:50 tg Exp $");
d65 1
a65 1
#ifndef MKSH_NOVI
d110 1
a110 1
#ifndef MKSH_NOVI
d1047 1
a1047 1
#ifndef MKSH_NOVI
d3371 1
a3371 1
#ifndef MKSH_NOVI
d5429 1
a5429 1
#endif /* !MKSH_NOVI */
@


1.180
log
@Add a hack input function for VT100-style key sequences; support
Ctrl-CurLeft and Ctrl-CurRight (not quite ANSI, but fits the scheme)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.179 2009/09/20 17:18:53 tg Exp $");
d1036 1
d1038 1
d1044 1
d1046 1
d1076 3
a1323 1
#endif
d1328 1
d1412 1
d1423 1
d2515 1
a2516 1
	if (XFUNC_VALUE(f) != XFUNC_ins_string)
d2518 1
d2521 1
d2526 1
d2528 1
d2533 1
a2533 1
	char *sp = NULL, *m1, *m2;
d2535 1
d2555 5
a2559 2
				if (f == XFUNC_insert || f == XFUNC_error ||
				    (macro && f != XFUNC_ins_string))
d2599 1
a2599 1
	if (*a2 == 0)
d2601 6
a2606 1
	else if (!macro) {
a2614 3
	} else {
		f = XFUNC_ins_string;
		sp = x_mapin(a2, AEDIT);
d2617 1
d2621 1
d2627 1
d2629 1
d2660 1
d2665 1
d2904 1
d2910 1
@


1.179
log
@fix (another… *sigh*) inverse logic error
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.178 2009/09/20 17:00:52 tg Exp $");
d1194 1
a1194 1
	{ XFUNC_mv_begin | 0x80,	2,	'1'	},
d2404 39
@


1.178
log
@shrink MKSH_SMALL by removing certain editor functionality (e.g. the tilde
hack) and functions (up/down/titlecase words; search history PgUp/PgDn)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.177 2009/09/20 15:38:05 tg Exp $");
d1218 1
a1218 1
#define XFUNC_VALUE(f) (f & 0x7F)
d1226 1
a1226 1
#define XFUNC_VALUE(f) (f)
@


1.177
log
@if things need to be in a specific order, use automated means to provide
such order, instead of relying on manually retaining it…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.176 2009/09/19 21:54:43 tg Exp $");
d1070 1
d1072 1
d1086 1
d1088 1
d1175 1
d1182 1
d1193 1
d1205 1
d1218 1
d1226 1
d1311 1
d1317 1
d1972 1
d1978 1
d2047 1
d2079 1
d2136 6
a2141 1
/* in later versions we might use libtermcap for this */
d2463 3
d2467 3
a2469 2
	if ((f & 0x7F) != XFUNC_ins_string)
		shprintf("%s\n", x_ftab[f & 0x7F].xf_name);
d2482 1
d2484 1
d2501 1
a2501 1
				f = x_tab[prefix][key] & 0x7F;
d2513 1
a2513 1
		f = x_tab[prefix][key] & 0x7F;
d2521 5
a2525 1
	if (*++m1 && ((*m1 != '~') || *(m1+1))) {
d2534 1
d2536 1
d2559 1
a2559 1
	if ((x_tab[prefix][key] & 0x7F) == XFUNC_ins_string &&
d2562 5
a2566 1
	x_tab[prefix][key] = f | (hastilde ? 0x80 : 0);
d3019 1
d3043 1
d3117 1
d3190 1
@


1.176
log
@$'…' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.175 2009/08/28 20:30:54 tg Exp $");
d1093 8
a1100 119
#define XFUNC_abort 0
#define XFUNC_beg_hist 1
#define XFUNC_cls 2
#define XFUNC_comp_comm 3
#define XFUNC_comp_file 4
#define XFUNC_complete 5
#define XFUNC_del_back 6
#define XFUNC_del_bword 7
#define XFUNC_del_char 8
#define XFUNC_del_fword 9
#define XFUNC_del_line 10
#define XFUNC_draw_line 11
#define XFUNC_end_hist 12
#define XFUNC_end_of_text 13
#define XFUNC_enumerate 14
#define XFUNC_eot_del 15
#define XFUNC_error 16
#define XFUNC_goto_hist 17
#define XFUNC_ins_string 18
#define XFUNC_insert 19
#define XFUNC_kill 20
#define XFUNC_kill_region 21
#define XFUNC_list_comm 22
#define XFUNC_list_file 23
#define XFUNC_literal 24
#define XFUNC_meta1 25
#define XFUNC_meta2 26
#define XFUNC_meta_yank 27
#define XFUNC_mv_back 28
#define XFUNC_mv_begin 29
#define XFUNC_mv_bword 30
#define XFUNC_mv_end 31
#define XFUNC_mv_forw 32
#define XFUNC_mv_fword 33
#define XFUNC_newline 34
#define XFUNC_next_com 35
#define XFUNC_nl_next_com 36
#define XFUNC_noop 37
#define XFUNC_prev_com 38
#define XFUNC_prev_histword 39
#define XFUNC_search_char_forw 40
#define XFUNC_search_char_back 41
#define XFUNC_search_hist 42
#define XFUNC_set_mark 43
#define XFUNC_transpose 44
#define XFUNC_xchg_point_mark 45
#define XFUNC_yank 46
#define XFUNC_comp_list 47
#define XFUNC_expand 48
#define XFUNC_fold_capitalise 49
#define XFUNC_fold_lower 50
#define XFUNC_fold_upper 51
#define XFUNC_set_arg 52
#define XFUNC_comment 53
#define XFUNC_version 54
#define XFUNC_edit_line 55
#define XFUNC_search_hist_up 56
#define XFUNC_search_hist_dn 57

/* XFUNC_* must be < 128 */

static int x_abort(int);
static int x_beg_hist(int);
static int x_cls(int);
static int x_comp_comm(int);
static int x_comp_file(int);
static int x_complete(int);
static int x_del_back(int);
static int x_del_bword(int);
static int x_del_char(int);
static int x_del_fword(int);
static int x_del_line(int);
static int x_draw_line(int);
static int x_end_hist(int);
static int x_end_of_text(int);
static int x_enumerate(int);
static int x_eot_del(int);
static int x_error(int);
static int x_goto_hist(int);
static int x_ins_string(int);
static int x_insert(int);
static int x_kill(int);
static int x_kill_region(int);
static int x_list_comm(int);
static int x_list_file(int);
static int x_literal(int);
static int x_meta1(int);
static int x_meta2(int);
static int x_meta_yank(int);
static int x_mv_back(int);
static int x_mv_begin(int);
static int x_mv_bword(int);
static int x_mv_end(int);
static int x_mv_forw(int);
static int x_mv_fword(int);
static int x_newline(int);
static int x_next_com(int);
static int x_nl_next_com(int);
static int x_noop(int);
static int x_prev_com(int);
static int x_prev_histword(int);
static int x_search_char_forw(int);
static int x_search_char_back(int);
static int x_search_hist(int);
static int x_set_mark(int);
static int x_transpose(int);
static int x_xchg_point_mark(int);
static int x_yank(int);
static int x_comp_list(int);
static int x_expand(int);
static int x_fold_capitalise(int);
static int x_fold_lower(int);
static int x_fold_upper(int);
static int x_set_arg(int);
static int x_comment(int);
static int x_version(int);
static int x_edit_line(int);
static int x_search_hist_up(int);
static int x_search_hist_down(int);
d1103 3
a1105 59
	{ x_abort,		"abort",			0 },
	{ x_beg_hist,		"beginning-of-history",		0 },
	{ x_cls,		"clear-screen",			0 },
	{ x_comp_comm,		"complete-command",		0 },
	{ x_comp_file,		"complete-file",		0 },
	{ x_complete,		"complete",			0 },
	{ x_del_back,		"delete-char-backward",		XF_ARG },
	{ x_del_bword,		"delete-word-backward",		XF_ARG },
	{ x_del_char,		"delete-char-forward",		XF_ARG },
	{ x_del_fword,		"delete-word-forward",		XF_ARG },
	{ x_del_line,		"kill-line",			0 },
	{ x_draw_line,		"redraw",			0 },
	{ x_end_hist,		"end-of-history",		0 },
	{ x_end_of_text,	"eot",				0 },
	{ x_enumerate,		"list",				0 },
	{ x_eot_del,		"eot-or-delete",		XF_ARG },
	{ x_error,		"error",			0 },
	{ x_goto_hist,		"goto-history",			XF_ARG },
	{ x_ins_string,		"macro-string",			XF_NOBIND },
	{ x_insert,		"auto-insert",			XF_ARG },
	{ x_kill,		"kill-to-eol",			XF_ARG },
	{ x_kill_region,	"kill-region",			0 },
	{ x_list_comm,		"list-command",			0 },
	{ x_list_file,		"list-file",			0 },
	{ x_literal,		"quote",			0 },
	{ x_meta1,		"prefix-1",			XF_PREFIX },
	{ x_meta2,		"prefix-2",			XF_PREFIX },
	{ x_meta_yank,		"yank-pop",			0 },
	{ x_mv_back,		"backward-char",		XF_ARG },
	{ x_mv_begin,		"beginning-of-line",		0 },
	{ x_mv_bword,		"backward-word",		XF_ARG },
	{ x_mv_end,		"end-of-line",			0 },
	{ x_mv_forw,		"forward-char",			XF_ARG },
	{ x_mv_fword,		"forward-word",			XF_ARG },
	{ x_newline,		"newline",			0 },
	{ x_next_com,		"down-history",			XF_ARG },
	{ x_nl_next_com,	"newline-and-next",		0 },
	{ x_noop,		"no-op",			0 },
	{ x_prev_com,		"up-history",			XF_ARG },
	{ x_prev_histword,	"prev-hist-word",		XF_ARG },
	{ x_search_char_forw,	"search-character-forward",	XF_ARG },
	{ x_search_char_back,	"search-character-backward",	XF_ARG },
	{ x_search_hist,	"search-history",		0 },
	{ x_set_mark,		"set-mark-command",		0 },
	{ x_transpose,		"transpose-chars",		0 },
	{ x_xchg_point_mark,	"exchange-point-and-mark",	0 },
	{ x_yank,		"yank",				0 },
	{ x_comp_list,		"complete-list",		0 },
	{ x_expand,		"expand-file",			0 },
	{ x_fold_capitalise,	"capitalize-word",		XF_ARG },
	{ x_fold_lower,		"downcase-word",		XF_ARG },
	{ x_fold_upper,		"upcase-word",			XF_ARG },
	{ x_set_arg,		"set-arg",			XF_NOBIND },
	{ x_comment,		"comment",			0 },
	{ x_version,		"version",			0 },
	{ x_edit_line,		"edit-line",			XF_ARG },
	{ x_search_hist_up,	"search-history-up",		0 },
	{ x_search_hist_down,	"search-history-down",		0 },
	{ 0,			NULL,				0 }
d2042 1
a2042 1
x_search_hist_down(int c __unused)
@


1.175
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.173 2009/08/01 20:32:43 tg Exp $");
a966 4
#undef CTRL
#define	CTRL(x)		((x) == '?' ? 0x7F : (x) & 0x1F)	/* ASCII */
#define	UNCTRL(x)	((x) ^ 0x40)				/* ASCII */

@


1.174
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d4164 1
a4164 2
				ap = ktsearch(&aliases, alias, hash(alias),
				    NULL);
@


1.173
log
@more use of memcpy(3) when we know destination and source sizes
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.172 2009/07/05 13:56:47 tg Exp $");
d4164 2
a4165 1
				ap = ktsearch(&aliases, alias, hash(alias));
@


1.172
log
@another fix from oksh for Vi Mode word erase handling, appears to unbreak
more from cid 1004A2D72DD5A4E4B4F tried to be fixed in 1004A300A72701188E3
but I’d appreciate someone who actually uses Vi Mode to test it:

   Revision 1.26: [7]download - view: [8]text, [9]markup, [10]annotated - [11]select for diffs
   Mon Jun 29 22:50:19 2009 UTC (5 days, 14 hours ago) by martynas
   Branches: [12]MAIN
   CVS tags: [13]OPENBSD_4_6_BASE, [14]OPENBSD_4_6, [15]HEAD
   Diff to: previous 1.25: [16]preferred, [17]coloured
   Changes since revision 1.25: +10 -5 lines
make VSEARCH werase act like regular werase after the last change.
vi back-words and emacs kill-region are not completely the same.
ok merdely@@, millert@@.  "Get it in" Darrin Chandler
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.171 2009/06/11 12:42:16 tg Exp $");
d3853 1
a3853 1
				(void)strlcpy(srchpat, locpat, sizeof(srchpat));
@


1.171
log
@capitalise AT&T®
@
text
@d4 1
a4 1
/*	$OpenBSD: vi.c,v 1.25 2009/06/10 15:08:46 merdely Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.170 2009/06/10 19:34:18 tg Exp $");
d3874 10
a3883 2
			int i;
			int n = srchlen;
a3884 4
			while (n > 0 && !ksh_isalnux(locpat[n - 1]))
				n--;
			while (n > 0 && ksh_isalnux(locpat[n - 1]))
				n--;
@


1.170
log
@get rid of a redefinition warning
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.169 2009/06/10 19:33:16 tg Exp $");
d162 1
a162 1
		return (1); /* somewhat arbitrary - it's what at&t ksh does */
d2384 2
a2385 2
	 *	at&t ksh in emacs mode:	abCd	abdC	abcd_	(bell)
	 *	at&t ksh in gmacs mode:	abCd	baCd	abcd_	abdc_
d2389 1
a2389 1
	 * it does the at&t ksh gmacs mode.
d3145 1
a3145 1
	/* This is what at&t ksh seems to do... Very bizarre */
d4566 1
a4566 1
		case '=':			/* at&t ksh */
d4578 1
a4578 1
		case Ctrl('['):			/* some annoying at&t kshs */
d4581 1
a4581 1
		case '\\':			/* at&t ksh */
d4587 1
a4587 1
		case '*':			/* at&t ksh */
@


1.169
log
@• Fix problem with ^w fix that broke 'B'
  Found by Daniel LEVAI
  Fix by Darrin Chandler
  ok millert@@
  From merdely@@obsd
• more tabs→spaces while here
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.168 2009/06/10 18:12:44 tg Exp $");
d967 1
@


1.168
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d4 1
a4 1
/*	$OpenBSD: vi.c,v 1.24 2009/06/04 04:03:22 merdely Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.167 2009/06/08 20:22:19 tg Exp $");
d3440 5
a3444 5
	char	*cbuf;
	int	winleft;
	int	cbufsize;
	int	linelen;
	int	cursor;
d3447 31
a3477 31
static int	vi_hook(int);
static int	nextstate(int);
static int	vi_insert(int);
static int	vi_cmd(int, const char *);
static int	domove(int, const char *, int);
static int	redo_insert(int);
static void	yank_range(int, int);
static int	bracktype(int);
static void	save_cbuf(void);
static void	restore_cbuf(void);
static int	putbuf(const char *, int, int);
static void	del_range(int, int);
static int	findch(int, int, int, int);
static int	forwword(int);
static int	backword(int);
static int	endword(int);
static int	Forwword(int);
static int	Backword(int);
static int	Endword(int);
static int	grabhist(int, int);
static int	grabsearch(int, int, int, char *);
static void	redraw_line(int);
static void	refresh(int);
static int	outofwin(void);
static void	rewindow(void);
static int	newcol(int, int);
static void	display(char *, char *, int);
static void	ed_mov_opt(int, char *);
static int	expand_word(int);
static int	complete_word(int, int);
static int	print_expansions(struct edstate *, int);
d3479 4
a3482 4
static void	x_vi_zotc(int);
static void	vi_error(void);
static void	vi_macro_reset(void);
static int	x_vi_putbuf(const char *, size_t);
d3568 18
a3585 18
static char	ibuf[LINE];		/* input buffer */
static int	first_insert;		/* set when starting in insert mode */
static int	saved_inslen;		/* saved inslen for first insert */
static int	inslen;			/* length of input buffer */
static int	srchlen;		/* length of current search pattern */
static char	ybuf[LINE];		/* yank buffer */
static int	yanklen;		/* length of yank buffer */
static int	fsavecmd = ' ';		/* last find command */
static int	fsavech;		/* character to find */
static char	lastcmd[MAXVICMD];	/* last non-move command */
static int	lastac;			/* argcnt for lastcmd */
static int	lastsearch = ' ';	/* last search command */
static char	srchpat[SRCHLEN];	/* last search pattern */
static int	insert;			/* non-zero in insert mode */
static int	hnum;			/* position in history */
static int	ohnum;			/* history line copied (after mod) */
static int	hlast;			/* 1 past last position in history */
static int	state;
d4033 1
a4033 1
			tcursor = Backword(1);
d4938 1
a4938 1
	int	ncursor;
d4963 1
a4963 1
	int	ncursor;
d5006 1
a5006 1
	int	ncursor;
d5010 1
a5010 2
		while (--ncursor >= 0 &&
		    !ksh_isalnux(es->cbuf[ncursor]))
d5012 1
a5012 2
		while (ncursor >= 0 &&
		    ksh_isalnux(es->cbuf[ncursor]))
d5022 1
a5022 1
	int	ncursor;
@


1.167
log
@and today’s last oksh merge, from merdely: I quote:

"make ksh vi mode handle werase more like vi. It's really irritating to
have whole paths go away on ^W instead of just the last bit."

"That looks right to me" millert@@, "YES kthx bye!" thib@@


.oO(there are vi mode users?) We are not GNU bash, good idea! tg@@
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.166 2009/06/08 20:16:01 tg Exp $");
d144 3
a146 2
/* ------------------------------------------------------------------------- */
/*           Misc common code for vi/emacs				     */
d153 1
a153 1
 * If successful, *lenp contains the new length.  Note: cursor should be
d196 3
a198 2
/* ------------------------------------------------------------------------- */
/*           Common file/command completion code for vi/emacs	             */
d244 2
a245 2
/*
 *  Do file globbing:
d439 1
a439 1
	/* Bad call?  Probably should report error */
d497 1
a497 1
	 * long and isn't very useful.  File globs are more likely to be
d518 2
a519 2
/* Given a string, copy it and possibly add a '*' to the end.  The
 * new string is returned.
d542 2
a543 2
		else if (*s == '*' || *s == '[' || *s == '?' || *s == '$'
		    || (s[1] == '(' && vstrchr("*+?@@!", *s)))
d586 1
a586 1
 * be null terminated).  Trailing slashes are ignored.  If s is just a slash,
d619 1
a619 1
 *  Apply pattern matching to a table: all table entries that match a pattern
d967 1
a967 1
#define	MKCTRL(x)	((x) == '?' ? 0x7F : (x) & 0x1F)	/* ASCII */
d1000 3
a1002 3
 * 0 = enumerate  M-= complete as much as possible and then list
 * 1 = complete   M-Esc
 * 2 = list       M-?
d1279 68
a1346 68
	{ XFUNC_del_back,		0, MKCTRL('?')	},
	{ XFUNC_del_bword,		1, MKCTRL('?')	},
	{ XFUNC_eot_del,		0, MKCTRL('D')	},
	{ XFUNC_del_back,		0, MKCTRL('H')	},
	{ XFUNC_del_bword,		1, MKCTRL('H')	},
	{ XFUNC_del_bword,		1,	  'h'	},
	{ XFUNC_mv_bword,		1,	  'b'	},
	{ XFUNC_mv_fword,		1,	  'f'	},
	{ XFUNC_del_fword,		1,	  'd'	},
	{ XFUNC_mv_back,		0, MKCTRL('B')	},
	{ XFUNC_mv_forw,		0, MKCTRL('F')	},
	{ XFUNC_search_char_forw,	0, MKCTRL(']')	},
	{ XFUNC_search_char_back,	1, MKCTRL(']')	},
	{ XFUNC_newline,		0, MKCTRL('M')	},
	{ XFUNC_newline,		0, MKCTRL('J')	},
	{ XFUNC_end_of_text,		0, MKCTRL('_')	},
	{ XFUNC_abort,			0, MKCTRL('G')	},
	{ XFUNC_prev_com,		0, MKCTRL('P')	},
	{ XFUNC_next_com,		0, MKCTRL('N')	},
	{ XFUNC_nl_next_com,		0, MKCTRL('O')	},
	{ XFUNC_search_hist,		0, MKCTRL('R')	},
	{ XFUNC_beg_hist,		1,	  '<'	},
	{ XFUNC_end_hist,		1,	  '>'	},
	{ XFUNC_goto_hist,		1,	  'g'	},
	{ XFUNC_mv_end,			0, MKCTRL('E')	},
	{ XFUNC_mv_begin,		0, MKCTRL('A')	},
	{ XFUNC_draw_line,		0, MKCTRL('L')	},
	{ XFUNC_cls,			1, MKCTRL('L')	},
	{ XFUNC_meta1,			0, MKCTRL('[')	},
	{ XFUNC_meta2,			0, MKCTRL('X')	},
	{ XFUNC_kill,			0, MKCTRL('K')	},
	{ XFUNC_yank,			0, MKCTRL('Y')	},
	{ XFUNC_meta_yank,		1,	  'y'	},
	{ XFUNC_literal,		0, MKCTRL('^')	},
	{ XFUNC_comment,		1,	  '#'	},
	{ XFUNC_transpose,		0, MKCTRL('T')	},
	{ XFUNC_complete,		1, MKCTRL('[')	},
	{ XFUNC_comp_list,		0, MKCTRL('I')	},
	{ XFUNC_comp_list,		1,	  '='	},
	{ XFUNC_enumerate,		1,	  '?'	},
	{ XFUNC_expand,			1,	  '*'	},
	{ XFUNC_comp_file,		1, MKCTRL('X')	},
	{ XFUNC_comp_comm,		2, MKCTRL('[')	},
	{ XFUNC_list_comm,		2,	  '?'	},
	{ XFUNC_list_file,		2, MKCTRL('Y')	},
	{ XFUNC_set_mark,		1,	  ' '	},
	{ XFUNC_kill_region,		0, MKCTRL('W')	},
	{ XFUNC_xchg_point_mark,	2, MKCTRL('X')	},
	{ XFUNC_literal,		0, MKCTRL('V')	},
	{ XFUNC_version,		1, MKCTRL('V')	},
	{ XFUNC_prev_histword,		1,	  '.'	},
	{ XFUNC_prev_histword,		1,	  '_'	},
	{ XFUNC_set_arg,		1,	  '0'	},
	{ XFUNC_set_arg,		1,	  '1'	},
	{ XFUNC_set_arg,		1,	  '2'	},
	{ XFUNC_set_arg,		1,	  '3'	},
	{ XFUNC_set_arg,		1,	  '4'	},
	{ XFUNC_set_arg,		1,	  '5'	},
	{ XFUNC_set_arg,		1,	  '6'	},
	{ XFUNC_set_arg,		1,	  '7'	},
	{ XFUNC_set_arg,		1,	  '8'	},
	{ XFUNC_set_arg,		1,	  '9'	},
	{ XFUNC_fold_upper,		1,	  'U'	},
	{ XFUNC_fold_upper,		1,	  'u'	},
	{ XFUNC_fold_lower,		1,	  'L'	},
	{ XFUNC_fold_lower,		1,	  'l'	},
	{ XFUNC_fold_capitalise,	1,	  'C'	},
	{ XFUNC_fold_capitalise,	1,	  'c'	},
d1351 15
a1365 15
	{ XFUNC_meta2,			1,	  '['	},
	{ XFUNC_meta2,			1,	  'O'	},
	{ XFUNC_prev_com,		2,	  'A'	},
	{ XFUNC_next_com,		2,	  'B'	},
	{ XFUNC_mv_forw,		2,	  'C'	},
	{ XFUNC_mv_back,		2,	  'D'	},
	{ XFUNC_mv_begin | 0x80,	2,	  '1'	},
	{ XFUNC_mv_begin | 0x80,	2,	  '7'	},
	{ XFUNC_mv_begin,		2,	  'H'	},
	{ XFUNC_mv_end | 0x80,		2,	  '4'	},
	{ XFUNC_mv_end | 0x80,		2,	  '8'	},
	{ XFUNC_mv_end,			2,	  'F'	},
	{ XFUNC_del_char | 0x80,	2,	  '3'	},
	{ XFUNC_search_hist_up | 0x80,	2,	  '5'	},
	{ XFUNC_search_hist_dn | 0x80,	2,	  '6'	},
d1367 1
a1367 1
	{ XFUNC_edit_line,		2,	  'e'	}
d1513 1
a1513 1
	 *  Should allow tab and control chars.
d2119 1
a2119 1
		if (c == MKCTRL('[')) {
d2125 1
a2125 1
					x_meta1(MKCTRL('['));
d2301 1
a2301 1
/* Redraw (part of) the line.  If limit is < 0, the everything is redrawn
d2382 4
a2385 4
	 *     Who			Before	After  Before	After
	 *     at&t ksh in emacs mode:	abCd	abdC   abcd_	(bell)
	 *     at&t ksh in gmacs mode:	abCd	baCd   abcd_	abdc_
	 *     gnu emacs:		abCd	acbD   abcd_	abdc_
d2565 1
a2565 1
				*op++ = MKCTRL(*cp);
d2611 1
a2611 1
		    MKCTRL('[') : MKCTRL('X')), shl_stdout);
d2740 1
a2740 1
	/* Has user already bound this key?  If so, don't override it */
d2931 1
a2931 1
 *	of the edit window.  It increments x_adj_done so that
d3144 1
a3144 1
	/* This is what at&t ksh seems to do...  Very bizarre */
d3181 1
a3181 1
 *	command and inserts it into the current edit line.  If a
d3328 1
a3328 1
 *	This function returns a pointer to that  char in the
d3330 1
a3330 1
 *	screen.  The sequence:
d3503 33
a3535 33
   /*       0       1       2       3       4       5       6       7        */
   /*   0   ^@@     ^A      ^B      ^C      ^D      ^E      ^F      ^G        */
	    B_,     0,      0,      0,      0,      C_|U_,  C_|Z_,  0,
   /*  01   ^H     ^I      ^J      ^K      ^L      ^M      ^N      ^O        */
	    M_,     C_|Z_,  0,      0,      C_|U_,  0,      C_,     0,
   /*  02   ^P     ^Q      ^R      ^S      ^T      ^U      ^V      ^W        */
	    C_,     0,      C_|U_,  0,      0,      0,      C_,     0,
   /*  03   ^X     ^Y      ^Z      ^[      ^\      ^]      ^^      ^_        */
	    C_,     0,      0,      C_|Z_,  0,      0,      0,      0,
   /*  04  <space>  !       "       #       $       %       &       '        */
	    M_,     0,      0,      C_,     M_,     M_,     0,      0,
   /*  05   (       )       *       +       ,       -       .       /        */
	    0,      0,      C_,     C_,     M_,     C_,     0,      C_|S_,
   /*  06   0       1       2       3       4       5       6       7        */
	    M_,     0,      0,      0,      0,      0,      0,      0,
   /*  07   8       9       :       ;       <       =       >       ?        */
	    0,      0,      0,      M_,     0,      C_,     0,      C_|S_,
   /* 010   @@       A       B       C       D       E       F       G        */
	    C_|X_,  C_,     M_,     C_,     C_,     M_,     M_|X_,  C_|U_|Z_,
   /* 011   H       I       J       K       L       M       N       O        */
	    0,      C_,     0,      0,      0,      0,      C_|U_,  0,
   /* 012   P       Q       R       S       T       U       V       W        */
	    C_,     0,      C_,     C_,     M_|X_,  C_,     0,      M_,
   /* 013   X       Y       Z       [       \       ]       ^       _        */
	    C_,     C_|U_,  0,      0,      C_|Z_,  0,      M_,     C_|Z_,
   /* 014   `       a       b       c       d       e       f       g        */
	    0,      C_,     M_,     E_,     E_,     M_,     M_|X_,  C_|Z_,
   /* 015   h       i       j       k       l       m       n       o        */
	    M_,     C_,     C_|U_,  C_|U_,  M_,     0,      C_|U_,  0,
   /* 016   p       q       r       s       t       u       v       w        */
	    C_,     0,      X_,     C_,     M_|X_,  C_|U_,  C_|U_|Z_,M_,
   /* 017   x       y       z       {       |       }       ~      ^?        */
	    C_,     E_|U_,  0,      0,      M_|Z_,  0,      C_,     0
d3589 2
a3590 2
 * by the name (letter) of the alias.  The end of the buffer is marked by
 * a double NUL.  The name of the alias is stored so recursive macros can
d3763 1
a3763 1
					     strlen(KSH_VERSION), 0);
d4391 2
a4392 2
					argcnt = source->line + 1
					    - (hlast - hnum);
d5422 1
a5422 1
		/* If exact match, don't undo.  Allows directory completions
@


1.166
log
@RCSID sync with oksh: cid 10049D8938D01A15AB7, 10049D8A41E43689C5A
already provided this functionality with much more verbose ci msgs
@
text
@d4 1
a4 1
/*	$OpenBSD: vi.c,v 1.23 2006/04/10 14:38:59 jaredy Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.165 2009/06/08 20:06:44 tg Exp $");
d3874 1
a3874 1
			while (n > 0 && ksh_isspace(locpat[n - 1]))
d3876 1
a3876 1
			while (n > 0 && !ksh_isspace(locpat[n - 1]))
d5009 1
a5009 1
		    ksh_isspace(es->cbuf[ncursor]))
d5012 1
a5012 1
		    !ksh_isspace(es->cbuf[ncursor]))
@


1.165
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.41 2007/08/02 10:50:25 fgsch Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.164 2009/05/16 16:59:33 tg Exp $");
@


1.164
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.163 2009/05/16 15:09:06 tg Exp $");
d118 1
a118 1
	return i;
d161 1
a161 1
		return 1; /* somewhat arbitrary - it's what at&t ksh does */
d173 1
a173 1
		return 0;
d182 1
a182 1
			return -1;
d191 1
a191 1
		return 1;
d258 1
a258 1
		return 0;
d290 1
a290 1
		return 0;
d323 1
a323 1
	return nwords;
d342 1
a342 1
	return t ? t : a->path_order - b->path_order;
d354 1
a354 1
		return 0;
d379 1
a379 1
		return 0;
d389 1
a389 1
		    alloc(nwords * sizeof (struct path_order_info), ATEMP);
d410 1
a410 1
		qsort(words, nwords, sizeof (void *), xstrcmp);
d425 1
a425 1
	return nwords;
d441 1
a441 1
		return 0;
d480 1
a480 1
	return end - start;
d499 1
a499 1
		return 0;
d506 1
a506 1
		return 0;
d513 1
a513 1
	return nwords;
d526 1
a526 1
		return NULL;
d550 1
a550 1
	return toglob;
d563 1
a563 1
		return 0;
d572 1
a572 1
	return prefix_len;
d603 1
a603 1
		return 0;
d613 1
a613 1
	return p - s;
d1465 1
a1465 1
			return 0;
d1493 1
a1493 1
			return i;
d1517 1
a1517 1
		return KSTD;
d1558 1
a1558 1
	return KSTD;
d1569 1
a1569 1
	return KSTD;
d1577 1
a1577 1
		return -1;
d1584 1
a1584 1
	return 0;
d1594 1
a1594 1
		return -1;
d1612 1
a1612 1
	return 0;
d1628 1
a1628 1
	return KSTD;
d1648 1
a1648 1
		return KSTD;
d1651 1
a1651 1
	return KSTD;
d1727 1
a1727 1
	return KSTD;
d1734 1
a1734 1
	return KSTD;
d1741 1
a1741 1
	return KSTD;
d1748 1
a1748 1
	return KSTD;
d1759 1
a1759 1
		return 0;
d1774 1
a1774 1
	return nc;
d1785 1
a1785 1
		return 0;
d1797 1
a1797 1
	return nc;
d1840 1
a1840 1
	return size;
d1853 1
a1853 1
		return 4;	/* Kludge, tabs are always four spaces. */
d1855 2
a1856 2
		return 2;	/* control unsigned char */
	return 1;
d1904 1
a1904 1
		return KSTD;
d1911 1
a1911 1
	return KSTD;
d1921 1
a1921 1
		return KSTD;
d1930 1
a1930 1
	return KSTD;
d1942 1
a1942 1
		return KSTD;
d1948 1
a1948 1
			return KSTD;
d1952 1
a1952 1
	return KSTD;
d1963 1
a1963 1
		return KSTD;
d1971 1
a1971 1
				return KSTD;
d1987 1
a1987 1
	return KSTD;
d1997 1
a1997 1
	return KEOL;
d2007 1
a2007 1
	return KEOL;
d2014 1
a2014 1
	return KSTD;
d2021 1
a2021 1
	return KSTD;
d2028 1
a2028 1
	return KSTD;
d2035 1
a2035 1
	return KSTD;
d2049 1
a2049 1
	return KSTD;
d2070 1
a2070 1
		strlcpy(holdbuf, xbuf, sizeof (holdbuf));
d2115 1
a2115 1
			return KSTD;
d2120 1
a2120 1
					return KSTD;
d2176 1
a2176 1
	return KSTD;
d2193 1
a2193 1
			return i;
d2198 1
a2198 1
	return -1;
d2238 1
a2238 1
		return (strncmp(str, pat + 1, strlen(pat + 1)) == 0) ? 0 : -1;
d2241 1
a2241 1
		return (q == NULL) ? -1 : q - str;
d2261 1
a2261 1
	return KSTD;
d2268 1
a2268 1
	return KSTD;
d2275 1
a2275 1
	return KSTD;
d2282 1
a2282 1
	return KSTD;
d2392 1
a2392 1
		return KSTD;
d2396 1
a2396 1
			return KSTD;
d2404 1
a2404 1
			return KSTD;
d2409 1
a2409 1
			return KSTD;
d2421 1
a2421 1
			return KSTD;
d2426 1
a2426 1
			return KSTD;
d2434 1
a2434 1
	return KSTD;
d2441 1
a2441 1
	return KSTD;
d2448 1
a2448 1
	return KSTD;
d2455 1
a2455 1
	return KSTD;
d2475 1
a2475 1
	return KSTD;
d2501 1
a2501 1
		return KSTD;
d2505 1
a2505 1
	return KSTD;
d2518 1
a2518 1
		return KSTD;
d2530 1
a2530 1
	return KSTD;
d2541 1
a2541 1
	return KINTR;
d2548 1
a2548 1
	return KSTD;
d2574 1
a2574 1
	return new;
d2666 1
a2666 1
		while (*c && m1 < (msg + sizeof (msg) - 3))
d2719 1
a2719 1
	x_tab = alloc(X_NTABS * sizeof (*x_tab), AEDIT);
d2729 1
a2729 1
	x_atab = alloc(X_NTABS * sizeof (*x_atab), AEDIT);
d2750 1
a2750 1
	return KSTD;
d2761 1
a2761 1
		return KSTD;
d2773 1
a2773 1
	return KSTD;
d2783 1
a2783 1
		return KSTD;
d2788 1
a2788 1
	return KSTD;
d2794 1
a2794 1
	return KSTD;
d2804 1
a2804 1
	return KSTD;
d2811 1
a2811 1
	return KSTD;
d2818 1
a2818 1
	return KSTD;
d2825 1
a2825 1
	return KSTD;
d2832 1
a2832 1
	return KSTD;
d2839 1
a2839 1
	return KSTD;
d2846 1
a2846 1
	return KSTD;
d2861 1
a2861 1
		return KSTD;
d2869 1
a2869 1
			return KSTD;
d2874 1
a2874 1
	return KSTD;
d3092 1
a3092 1
	return KSTD;
d3112 1
a3112 1
			return x_newline('\n');
d3114 1
a3114 1
	return KSTD;
d3141 1
a3141 1
		return KSTD;
d3147 1
a3147 1
	return KSTD;
d3243 1
a3243 1
	return KSTD;
d3250 1
a3250 1
	return x_fold_case('U');
d3257 1
a3257 1
	return x_fold_case('L');
d3264 1
a3264 1
	return x_fold_case('C');
d3284 1
a3284 1
		return KSTD;
d3316 1
a3316 1
	return KSTD;
d3366 1
a3366 1
		return x_cur_mode;
d3429 1
a3429 1
	return prev;
d3695 1
a3695 1
		return -1;
d3702 1
a3702 1
	return es->linelen;
d3732 1
a3732 1
				return 1;
d3736 1
a3736 1
				return 1;
d3751 1
a3751 1
							return -1;
d3753 1
a3753 1
						return -1;
d3798 1
a3798 1
			return 0;
d3846 1
a3846 1
					return 0;
d3850 1
a3850 1
				(void)strlcpy(srchpat, locpat, sizeof srchpat);
d3859 1
a3859 1
				return 0;
d3869 1
a3869 1
			return 0;
d3883 1
a3883 1
			return 0;
d3902 1
a3902 1
			return 0;
d3922 1
a3922 1
			return 1;
d3925 1
a3925 1
			return 1;
d3953 1
a3953 1
			return 1;
d3965 1
a3965 1
	return 0;
d3972 1
a3972 1
		return VEXTCMD;
d3974 1
a3974 1
		return VSEARCH;
d3976 1
a3976 1
		return VXCH;
d3978 1
a3978 1
		return VREDO;
d3980 1
a3980 1
		return VVERSION;
d3982 1
a3982 1
		return VCMD;
d3984 1
a3984 1
		return VFAIL;
d3996 1
a3996 1
				return 0;
d4007 1
a4007 1
				return 0;
d4016 1
a4016 1
		return 0;
d4027 1
a4027 1
		return 0;
d4042 1
a4042 1
		return 0;
d4052 1
a4052 1
		return -1;
d4056 1
a4056 1
		return 1;
d4064 1
a4064 1
				return redo_insert(0);
d4071 1
a4071 1
			return redo_insert(0);
d4073 1
a4073 1
			return redo_insert(lastac - 1);
d4098 1
a4098 1
			return -1;
d4110 1
a4110 1
	return 0;
d4130 1
a4130 1
			return -1;
d4159 1
a4159 1
					return -1;
d4164 1
a4164 1
							return -1;
d4219 1
a4219 1
				return -1;
d4222 1
a4222 1
					return -1;
d4264 1
a4264 1
				return -1;
d4276 1
a4276 1
				return -1;
d4303 1
a4303 1
				return -1;
d4327 1
a4327 1
				return -1;
d4338 1
a4338 1
				return -1;
d4347 1
a4347 1
				return -1;
d4356 1
a4356 1
					return -1;
d4371 1
a4371 1
				return -1;
d4383 1
a4383 1
					return -1;
d4401 1
a4401 1
			return 2;
d4405 1
a4405 1
				return -1;
d4424 1
a4424 1
				return -1;
d4435 1
a4435 1
				return -1;
d4437 1
a4437 1
				return -1;
d4454 1
a4454 1
				return -1;
d4467 1
a4467 1
				return -1;
d4480 1
a4480 1
					return -1;
d4493 1
a4493 1
						return -1;
d4524 1
a4524 1
					return -1;
d4536 1
a4536 1
					return -1;
d4560 1
a4560 1
				return ret;
d4571 1
a4571 1
				return -1;
d4577 1
a4577 1
				return -1;
d4592 1
a4592 1
	return 0;
d4604 1
a4604 1
			return -1;
d4610 1
a4610 1
			return -1;
d4616 1
a4616 1
			return -1;
d4624 1
a4624 1
			return -1;
d4641 1
a4641 1
			return -1;
d4647 1
a4647 1
			return -1;
d4655 1
a4655 1
			return -1;
d4664 1
a4664 1
			return -1;
d4674 1
a4674 1
			return -1;
d4680 1
a4680 1
			return -1;
d4716 1
a4716 1
			return -1;
d4721 1
a4721 1
					return -1;
d4724 1
a4724 1
					return -1;
d4737 1
a4737 1
		return -1;
d4739 1
a4739 1
	return ncursor;
d4747 1
a4747 1
			return -1;
d4751 1
a4751 1
	return 0;
d4768 1
a4768 1
		return 1;
d4771 1
a4771 1
		return 2;
d4774 1
a4774 1
		return 3;
d4777 1
a4777 1
		return -1;
d4780 1
a4780 1
		return -2;
d4783 1
a4783 1
		return -3;
d4786 1
a4786 1
		return 0;
d4816 1
a4816 1
	new = alloc(sizeof (struct edstate), APERM);
d4823 1
a4823 1
	return new;
d4849 1
a4849 1
	return putbuf(s, len, 0);
d4856 1
a4856 1
		return 0;
d4859 1
a4859 1
			return -1;
d4864 1
a4864 1
			return -1;
d4871 1
a4871 1
	return 0;
d4888 1
a4888 1
		return -1;
d4894 1
a4894 1
					return -1;
d4897 1
a4897 1
					return -1;
d4907 1
a4907 1
	return ncursor;
d4930 1
a4930 1
	return ncursor;
d4955 1
a4955 1
	return ncursor;
d4981 1
a4981 1
	return ncursor;
d4998 1
a4998 1
	return ncursor;
d5016 1
a5016 1
	return ncursor;
d5036 1
a5036 1
	return ncursor;
d5045 1
a5045 1
		return -1;
d5049 1
a5049 1
		return 0;
d5054 1
a5054 1
		return -1;
d5063 1
a5063 1
	return 0;
d5074 1
a5074 1
		return -1;
d5085 1
a5085 1
			return 0;
d5087 1
a5087 1
			return -1;
d5097 1
a5097 1
	return hist;
d5133 1
a5133 1
		return 1;
d5139 2
a5140 2
		return 1;
	return 0;
d5171 2
a5172 2
		return (col | 7) + 1;
	return col + char_len(ch);
d5298 1
a5298 1
		return 0;
d5310 1
a5310 1
		return -1;
d5335 1
a5335 1
	return rval;
d5351 1
a5351 1
		return 0;
d5357 1
a5357 1
		return 0;
d5372 1
a5372 1
		return -1;
d5383 1
a5383 1
			return -1;
d5437 1
a5437 1
	return rval;
d5452 1
a5452 1
		return -1;
d5457 1
a5457 1
	return 0;
@


1.163
log
@split utf_ptradjx into utf_ptradj function (to save space) and
self-assignment macro; remove some uses of the macro in favour
of foo += utf_ptradj(foo)
@
text
@d6 20
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.162 2009/05/16 14:34:57 tg Exp $");
@


1.162
log
@bind new search-history-{up,down} to ANSI PgUp and PgDn keys
“because we can”
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.161 2009/05/16 14:19:21 tg Exp $");
d766 12
d1753 1
a1753 1
		utf_ptradjx(cp, cp);
d1774 1
a1774 1
		utf_ptradjx(cp2, cp2);
@


1.161
log
@Add search-history-up and search-history-down keybindings (both unbound
by default) to the Emacs command line editing mode; patch originally by
James Butler <sweetnavelorange@@gmail.com> but slightly modified

10x
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.160 2009/04/07 18:41:33 tg Exp $");
d1119 1
a1119 1
#define XFUNC_search_hist_down 57
d1330 2
@


1.160
log
@try to do some optimum struct packing except for struct env
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.159 2009/04/05 12:35:21 tg Exp $");
d1039 1
d1118 2
d1179 2
d1239 2
d2167 32
@


1.159
log
@add comments, remove dead code
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.158 2009/04/05 12:28:55 tg Exp $");
d3365 1
a3366 1
	char	*cbuf;
d3488 1
a3488 1
static struct edstate	undobuf = { 0, undocbuf, LINE, 0, 0 };
@


1.158
log
@From: Alexander Hall <alexander@@beard.se>
when following bind key macros, do not so recursively
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.157 2009/04/05 11:18:34 tg Exp $");
d1011 1
a1011 1
static char *macroptr = NULL;
a1522 4
	if (macroptr) {
		x_e_putc2(7);
		return KSTD;
	}
d1524 4
a1527 4
	if (macroptr && !*macroptr) {
		/* XXX bell? */
		macroptr = NULL;
	}
@


1.157
log
@From: Alexander Hall <alexander <at> beard.se>
support multi-line bind macros (part 1 of 2 of entire diff)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.156 2009/03/17 13:56:47 tg Exp $");
d1434 4
d2899 8
a2906 6
	} else if (macroptr) {
		c = (unsigned char)*macroptr++;
		if (!*macroptr)
			macroptr = NULL;
	} else
		c = x_getc();
d2908 1
a2908 1
	return (c);
@


1.156
log
@another off-by-one, reported by «macaronyde:#!/bin/mksh»
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.155 2009/03/15 18:48:43 tg Exp $");
d1011 1
a1011 1
static char *macroptr;
a1408 1
	macroptr = NULL;
@


1.155
log
@attempt to get the C1 control character problem temporarily solved:
just output them. sometimes you'll see U+FFFD even. real fix later.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.154 2009/03/15 18:30:39 tg Exp $");
d2245 1
a2245 1
		if (x_col > xx_cols)
d2250 1
a2250 1
	if (x_col > xx_cols)
@


1.154
log
@fix off-by-one calculation mistake making PS1 ending in newline double it
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.153 2009/03/15 16:13:38 tg Exp $");
d1833 1
a1833 1
		/*  Kludge, tabs are always four spaces.  */
a1846 8
	if (c == 0xC2 && UTFMODE) {
		unsigned char c2 = ((unsigned char *)*cp)[1];

		if (c2 >= 0x80 && c2 < 0xA0) {
			c = c2;
			(*cp)++;
		}
	}
d1848 1
a1848 1
		/*  Kludge, tabs are always four spaces.  */
d1851 1
a1851 1
	} else if (c < ' ' || (c >= 0x7F && c < 0xA0)) {
@


1.153
log
@sprinkle a few static and clean up the internal APIs
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.152 2009/02/22 19:02:27 tg Exp $");
d1383 1
a1383 1
	if (x_col > xx_cols)
@


1.152
log
@optimise utf_widthadj
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.151 2009/02/22 18:57:19 tg Exp $");
d20 1
a20 1
X_chars edchars;
d61 1
d779 1
a779 1
int
d2555 2
a2556 2
    int macro,			/* bind -m */
    int list)			/* bind -l */
d3434 1
a3434 1
const unsigned char	classify[128] = {
@


1.151
log
@preliminary fix for the ${foo/@@(%)/x} not working in UTFMODE problem:
the width for control characters (wcwidth(wc) == -1) was hard-coded
to 2 (!) in utf_widthadj, which is true for *only* one of the two x_zotc*
functions in Emacs editing mode, and none of the other functions which
use this piece of code

change to 1, to be more correct in the general case; use of the UTF C1
control characters U+0080‥U+009F is slightly broken anyway, and this
only shifts the brokenness to different places of code

XXX maybe we want to map U+0080‥U+009F into Unicode as if they were
XXX 0x80‥0x9F in ANSI cp1252 instead, at least for displaying?

the editing code is cruel…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.150 2009/02/20 13:19:04 tg Exp $");
d724 3
a726 2
	else
		width = utf_wcwidth(wc);
d730 1
a730 2
	/* XXX (width == -1 ? 2 : width) for x_zotc3 but appar. noth. else */
	return (width == -1 ? 1 : width);
@


1.150
log
@some systems’ (such as klibc) <termios.h> does not define _POSIX_VDISABLE
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.149 2008/12/29 21:05:13 tg Exp $");
d729 2
a730 1
	return (width == -1 ? 2 : width);
@


1.149
log
@use a more common/generic routine for TIOCGWINSZ;
ensure x_cols and x_lins always have a sane value
after them (even if not tty_fd)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.148 2008/12/13 17:02:12 tg Exp $");
d3317 1
a3317 1
#ifdef VLNEXT
d3322 1
a3322 1
#ifdef VDISCARD
d3330 1
d3344 1
@


1.148
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.147 2008/12/04 18:11:04 tg Exp $");
a51 4
#ifdef TIOCGWINSZ
static void chkwinsz(void);
#endif

d73 1
a73 3
#ifdef TIOCGWINSZ
	chkwinsz();
#endif
a76 27
#ifdef TIOCGWINSZ
static void
chkwinsz(void)
{
	struct winsize ws;

	if (procpid == kshpid && ioctl(tty_fd, TIOCGWINSZ, &ws) >= 0) {
		struct tbl *vp;

		/* Do NOT export COLUMNS/LINES.  Many applications
		 * check COLUMNS/LINES before checking ws.ws_col/row,
		 * so if the app is started with C/L in the environ
		 * and the window is then resized, the app won't
		 * see the change cause the environ doesn't change.
		 */
		if (ws.ws_col) {
			x_cols = ws.ws_col < MIN_COLS ? MIN_COLS : ws.ws_col;

			if ((vp = typeset("COLUMNS", 0, 0, 0, 0)))
				setint(vp, (long)ws.ws_col);
		}
		if (ws.ws_row && (vp = typeset("LINES", 0, 0, 0, 0)))
			setint(vp, (long)ws.ws_row);
	}
}
#endif

d96 1
a96 3
#ifdef TIOCGWINSZ
	chkwinsz();
#endif
@


1.147
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.146 2008/11/15 09:00:18 tg Exp $");
d403 1
a403 1
		    alloc(nwords, sizeof (struct path_order_info), ATEMP);
d963 2
a964 1
static PArea AEDIT;		/* area for kill ring and macro defns */
d1075 1
a1075 1
static char *x_mapin(const char *, PArea);
d2521 1
a2521 1
x_mapin(const char *cp, PArea ap)
d2685 1
a2685 1
	AEDIT = anew(8);
d2688 1
a2688 1
	x_tab = alloc(X_NTABS, sizeof (*x_tab), AEDIT);
d2698 1
a2698 1
	x_atab = alloc(X_NTABS, sizeof (*x_atab), AEDIT);
d3604 2
a3605 2
		wbuf[0] = aresize(wbuf[0], 1, wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], 1, wbuf_len, APERM);
d4134 1
a4134 1
				nbuf = alloc(1, nlen + 1 + olen, APERM);
d4781 2
a4782 2
	new = alloc(1, sizeof (struct edstate), APERM);
	new->cbuf = alloc(1, old->cbufsize, APERM);
@


1.146
log
@give hints to anew() according to aalloc stats output for testsuite and a
little interactive use, to reduce the number realloc(3) must be called
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.145 2008/11/15 07:35:23 tg Exp $");
d756 1
a756 1
	if (!Flag(FUTFHACK) || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
d774 1
a774 1
	if (!Flag(FUTFHACK))
d1388 1
a1388 1
	if (Flag(FUTFHACK)) {
d1507 1
a1507 1
	if (Flag(FUTFHACK)) {
d1795 1
a1795 1
	if (Flag(FUTFHACK))
d1817 1
a1817 1
	if (Flag(FUTFHACK))
d1840 1
a1840 1
	if (Flag(FUTFHACK) && (c > 0x7F))
d1879 1
a1879 1
	if (c == 0xC2 && Flag(FUTFHACK)) {
d2914 1
a2914 1
	if (Flag(FUTFHACK))
d2954 1
a2954 1
		if (Flag(FUTFHACK) && (c > 0x7F)) {
d2995 1
a2995 1
		if (Flag(FUTFHACK) && (c > 0x7F)) {
@


1.146.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.146 2008/11/15 09:00:18 tg Exp $");
d332 1
a332 1
	gfree(toglob, ATEMP);
d374 1
a374 1
	gfree(toglob, ATEMP);
d403 1
a403 1
		    galloc(nwords, sizeof (struct path_order_info), ATEMP);
d418 1
a418 1
		gfree(info, ATEMP);
d429 1
a429 1
				gfree(words[i], ATEMP);
d593 2
a594 2
		gfree(words[--nwords], ATEMP);
	gfree(words, ATEMP);
d701 1
a701 1
				gfree(words[i], ATEMP);
d963 1
a963 2
static TGroup aedit;		/* area for kill ring and macro defns */
#define AEDIT &aedit
d1074 1
a1074 1
static char *x_mapin(const char *, PGroup);
d2453 1
a2453 1
		gfree(killstack[killsp], AEDIT);
d2520 1
a2520 1
x_mapin(const char *cp, PGroup ap)
d2640 1
a2640 1
	gfree(m2, ATEMP);
d2664 1
a2664 1
		gfree(x_atab[prefix][key], AEDIT);
d2684 1
a2684 1
	galloc_new(AEDIT, NULL, 8  GALLOC_VST("AEDIT"));
d2687 1
a2687 1
	x_tab = galloc(X_NTABS, sizeof (*x_tab), AEDIT);
d2697 1
a2697 1
	x_atab = galloc(X_NTABS, sizeof (*x_atab), AEDIT);
d3112 1
a3112 1
	gfree(v, ATEMP);
d3603 2
a3604 2
		wbuf[0] = grealloc(wbuf[0], 1, wbuf_len, APERM);
		wbuf[1] = grealloc(wbuf[1], 1, wbuf_len, APERM);
d4133 1
a4133 1
				nbuf = galloc(1, nlen + 1 + olen, APERM);
d4138 1
a4138 1
					gfree(macro.buf, APERM);
d4780 2
a4781 2
	new = galloc(1, sizeof (struct edstate), APERM);
	new->cbuf = galloc(1, old->cbufsize, APERM);
d4803 2
a4804 2
	gfree(old->cbuf, APERM);
	gfree(old, APERM);
d5448 1
a5448 1
		gfree(macro.buf, APERM);
@


1.145
log
@enable passing of a hint how many pointers we’ll need to anew()
if 0, the default is used
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.144 2008/11/12 00:54:46 tg Exp $");
d2684 1
a2684 1
	AEDIT = anew(0);
@


1.144
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.143 2008/11/12 00:27:54 tg Exp $");
d2684 1
a2684 1
	AEDIT = anew();
@


1.143
log
@isolate all knowledge of the area-based allocator from the rest of the code

cost: bss -= (0, 0, 16, 16); text += (520, 504, 516, 480)
[ gcc,pcc X full,small ]
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.142 2008/11/11 23:50:28 tg Exp $");
d403 1
a403 1
		    alloc(sizeof (struct path_order_info) * nwords, ATEMP);
d418 1
a418 1
		afree((void *)info, ATEMP);
d2453 1
a2453 1
		afree((void *)killstack[killsp], AEDIT);
d2664 1
a2664 1
		afree((void *)x_atab[prefix][key], AEDIT);
d2687 1
a2687 1
	x_tab = (unsigned char (*)[X_TABSZ])alloc(sizeofN(*x_tab, X_NTABS), AEDIT);
d2697 1
a2697 1
	x_atab = (char *(*)[X_TABSZ])alloc(sizeofN(*x_atab, X_NTABS), AEDIT);
d3603 2
a3604 2
		wbuf[0] = aresize(wbuf[0], wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], wbuf_len, APERM);
d4133 1
a4133 1
				nbuf = alloc(nlen + 1 + olen, APERM);
d4780 2
a4781 2
	new = (struct edstate *)alloc(sizeof (struct edstate), APERM);
	new->cbuf = alloc(old->cbufsize, APERM);
d4804 1
a4804 1
	afree((char *)old, APERM);
@


1.142
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.141 2008/10/28 14:32:38 tg Exp $");
d963 1
a963 2
static struct TArea aedit;
#define	AEDIT	&aedit		/* area for kill ring and macro defns */
d2684 1
a2684 1
	ainit(AEDIT);
@


1.141
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.140 2008/10/26 20:59:39 tg Exp $");
d963 1
a963 1
static	Area	aedit;
d1075 1
a1075 1
static char *x_mapin(const char *, Area *);
d2521 1
a2521 1
x_mapin(const char *cp, Area *ap)
@


1.140
log
@• do not use __typeof__ even if we have statements-as-expressions, to
  please pcc, prompted for by Anders “ragge” Magnusson, problem spotted
  originally by Adam “replaced” Hoka
  ⇒ rewrote x_bs2() and utf_backch() into a combined x_bs3() function,
    since these are never used in any other way
• whitespace cleanup, while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.139 2008/10/19 20:15:43 tg Exp $");
d542 1
a542 1
	toglob = str_nsave(str, slen + 1, ATEMP); /* + 1 for "*" */
d640 8
a647 4
	for (ktwalk(&ts, tp); (te = ktnext(&ts)); ) {
		if (gmatchx(te->name, pat, false))
			XPput(*wp, str_save(te->name, ATEMP));
	}
a788 25
void
utf_cptradj(const char *src, const char **dst)
{
	size_t len;

	if (!Flag(FUTFHACK) || *(const unsigned char *)src < 0xC2 ||
	    (len = utf_mbtowc(NULL, src)) == (size_t)-1)
		len = 1;
	if (dst)
		*dst = src + len;
	/* return (len); */
}

#if HAVE_EXPSTMT
#define utf_ptradj(s,d) ({			\
	union mksh_cchack utf_ptradj_o;		\
	char **utf_ptradj_d = (d);		\
						\
	utf_cptradj((s), &utf_ptradj_o.ro);	\
	*utf_ptradj_d = utf_ptradj_o.rw;	\
})
#else
#define utf_ptradj(s,d) utf_cptradj((s), (const char **)(d))
#endif

d1632 1
a1632 1
		utf_ptradj(cp, &cp2);
d1766 1
a1766 1
		utf_ptradj(cp, &cp);
d1787 1
a1787 1
		utf_ptradj(cp2, &cp2);
d1925 1
a1925 1
		utf_ptradj(cp, &cp2);
d2450 3
a2452 1
	char *cp = str_nsave(xcp, nchars, AEDIT);
d2525 2
a2526 1
	op = new = str_save(cp, ap);
d3090 3
a3092 1
	char *v = str_save(KSH_VERSION, ATEMP);
d4191 3
a4193 2
					while (ksh_isspace(es->cbuf[--ncursor]))
						;
@


1.139
log
@when doing a history search (^R), restore old input line on
abortion (^G – ^C is SIGINT and doesn’t work like this, but
that’s actually good IMO)

prompted by enquiry about the Emacs editing mode by <smultron:#MidnightBSD>
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.138 2008/10/13 23:06:02 tg Exp $");
a744 24
#if HAVE_EXPSTMT
#define utf_backch(c)	(!Flag(FUTFHACK) ? (c) - 1 : ({		\
	unsigned char *utf_backch_cp = (unsigned char *)(c);	\
	--utf_backch_cp;					\
	while ((*utf_backch_cp >= 0x80) &&			\
	    (*utf_backch_cp < 0xC0))				\
		--utf_backch_cp;				\
	(__typeof__ (c))utf_backch_cp;				\
}))
#else
#define utf_backch(c)	(!Flag(FUTFHACK) ? (c) - 1 : 		\
	    (c) + (ptrdiff_t)(utf_backch_((unsigned char *)c) - \
	    ((unsigned char *)(c))))
static unsigned char *utf_backch_(unsigned char *);
static unsigned char *
utf_backch_(unsigned char *utf_backch_cp)
{
	--utf_backch_cp;
	while ((*utf_backch_cp >= 0x80) && (*utf_backch_cp < 0xC0))
		--utf_backch_cp;
	return (utf_backch_cp);
}
#endif

d1044 1
a1044 1
static int	x_adj_done;
d1046 11
a1056 11
static int	xx_cols;
static int	x_col;
static int	x_displen;
static int	x_arg;		/* general purpose arg */
static int	x_arg_defaulted;/* x_arg not explicitly set; defaulted to 1 */

static int	xlp_valid;

static char	**x_histp;	/* history position */
static int	x_nextcmd;	/* for newline-and-next */
static char	*xmp;		/* mark pointer */
d1059 7
a1065 7
static char	*(*x_atab)[X_TABSZ];	/* macro definitions */
static unsigned char	x_bound[(X_TABSZ * X_NTABS + 7) / 8];
#define	KILLSIZE	20
static char	*killstack[KILLSIZE];
static int	killsp, killtp;
static int	x_curprefix;
static char	*macroptr;
d1067 10
a1076 10
static int	cur_col;		/* current column on line */
static int	pwidth;			/* width of prompt */
static int	prompt_trunc;		/* how much of prompt to truncate */
static int	winwidth;		/* width of window */
static char	*wbuf[2];		/* window buffers */
static int	wbuf_len;		/* length of window buffers (x_cols-3)*/
static int	win;			/* window buffer in use */
static char	morec;			/* more character at right of window */
static int	lastref;		/* argument to last refresh() */
static int	holdlen;		/* length of holdbuf */
d1078 1
a1078 1
static int	prompt_redraw;		/* 0 if newline forced after prompt */
d1080 29
a1108 29
static int	x_ins(const char *);
static void	x_delete(int, int);
static int	x_bword(void);
static int	x_fword(int);
static void	x_goto(char *);
static void     x_bs2(char *);
static int      x_size_str(char *);
static int      x_size2(char *, char **);
static void     x_zots(char *);
static void     x_zotc2(int);
static void     x_zotc3(char **);
static void     x_load_hist(char **);
static int      x_search(char *, int, int);
static int      x_match(char *, char *);
static void	x_redraw(int);
static void	x_push(int);
static char *	x_mapin(const char *, Area *);
static char *	x_mapout(int);
static void	x_mapout2(int, char **);
static void     x_print(int, int);
static void	x_adjust(void);
static void	x_e_ungetc(int);
static int	x_e_getc(void);
static void	x_e_putc2(int);
static void	x_e_putc3(const char **);
static void	x_e_puts(const char *);
static int	x_fold_case(int);
static char	*x_lastcp(void);
static void	do_complete(int, Comp_type);
d1621 1
a1621 1
			x_bs2(cp = utf_backch(cp));
d1729 3
a1731 2
	for (cp = x_lastcp(); cp > xcp; )
		x_bs2(cp = utf_backch(cp));
d1826 1
a1826 1
			x_bs2(xcp = utf_backch(xcp));
d1834 1
a1834 1
x_bs2(char *cp)
d1838 6
a1843 1
	i = x_size2(cp, NULL);
d2355 3
a2357 2
	for (cp = xlp; cp > xcp; )
		x_bs2(cp = utf_backch(cp));
d2391 1
a2391 1
		x_bs2(xcp = utf_backch(xcp));
d2396 1
a2396 1
		x_bs2(xcp = utf_backch(xcp));
d2413 1
a2413 1
		x_bs2(xcp = utf_backch(xcp));
d2912 1
a2912 1
 *      x_adjust - redraw the line adjusting starting point etc.
d2915 5
a2919 5
 *      This function is called when we have exceeded the bounds
 *      of the edit window.  It increments x_adj_done so that
 *      functions like x_ins and x_delete know that we have been
 *      called and can skip the x_bs() stuff which has already
 *      been done by x_redraw.
d2922 1
a2922 1
 *      None
d3052 1
a3052 1
 *      x_set_arg - set an arg value for next function
d3055 1
a3055 1
 *      This is a simple implementation of M-[0-9].
d3058 1
a3058 1
 *      KSTD
d3158 1
a3158 1
 *      x_prev_histword - recover word from prev command
d3161 6
a3166 6
 *      This function recovers the last word from the previous
 *      command and inserts it into the current edit line.  If a
 *      numeric arg is supplied then the n'th word from the
 *      start of the previous command is used.
 *      As a side effect, trashes the mark in order to achieve
 *      being called in a repeatable fashion.
d3168 1
a3168 1
 *      Bound to M-.
d3171 1
a3171 1
 *      KSTD
d3251 1
a3251 1
 *      x_fold_case - convert word to UPPER/lower/Capital case
d3254 2
a3255 2
 *      This function is used to implement M-U,M-u,M-L,M-l,M-C and M-c
 *      to UPPER case, lower case or Capitalise words.
d3258 1
a3258 1
 *      None
d3303 1
a3303 1
 *      x_lastcp - last visible char
d3306 1
a3306 1
 *      x_lastcp()
d3309 3
a3311 3
 *      This function returns a pointer to that  char in the
 *      edit buffer that will be the last displayed on the
 *      screen.  The sequence:
d3313 3
a3315 2
 *      for (cp = x_lastcp(); cp > xcp; )
 *        x_bs2(cp = utf_backch(cp));
d3317 1
a3317 1
 *      Will position the cursor correctly on the screen.
d3320 1
a3320 1
 *      cp or NULL
@


1.138
log
@fix some of the things scan-build[1] found (but not some false positives)
10x

From: Elias Pipping <elias@@pipping.org>
[1] http://clang.llvm.org/StaticAnalysis.html
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.137 2008/10/05 16:06:43 tg Exp $");
d2205 4
@


1.137
log
@unbreak MKSH_SMALL after x_histp related changes
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.136 2008/10/04 23:08:03 tg Exp $");
d1520 1
a1520 1
		switch (i = (*x_ftab[f].xf_func)(i)) {
a1729 1
	cp = xcp;
d2334 1
a2334 1
	cp = x_lastcp();
@


1.136
log
@implement Message-ID: <20081004171903.GA14184@@boetes.org>
in a somewhat hackish way, and it’s still quite different from zsh,
but probably closer to a desired functionality

XXX this makes state by abusing 「modified」 and 「xmp」 (“the mark”).
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.135 2008/09/30 19:28:12 tg Exp $");
a30 19
#ifdef MKSH_SMALL
static void x_modified(void);
static void
x_modified(void)
{
	if (!modified) {
		x_histp = histptr + 1;
		modified = 1;
	}
}
#else
#define x_modified() do {			\
	if (!modified) {			\
		x_histp = histptr + 1;		\
		modified = 1;			\
	}					\
} while (/* CONSTCOND */ 0)
#endif

d1405 19
@


1.135
log
@optimise
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.134 2008/09/30 19:25:49 tg Exp $");
d3179 2
d3191 2
d3194 5
a3198 2
	cp = *histptr;
	if (!cp)
d3200 5
a3204 1
	else if (x_arg_defaulted) {
d3239 1
@


1.134
log
@ignore more dups
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.133 2008/09/30 17:49:24 tg Exp $");
a4361 2
			if (es->linelen == 0 && argcnt == 0)
				return -1;
d4363 2
@


1.133
log
@däs isch ei buul, koa int…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.132 2008/09/30 17:23:00 tg Exp $");
d3157 1
a3157 2
			source->line++;
			histsave(source->line, xbuf, true);
d4367 2
a4368 2
					source->line++;
					histsave(source->line, es->cbuf, true);
@


1.132
log
@implement ^Xe emacs history editing like ^[v vi history editing
cf. Message-ID: <Pine.BSM.4.64L.0809171944240.28480@@herc.mirbsd.org>
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.131 2008/09/20 15:59:23 tg Exp $");
d3158 1
a3158 1
			histsave(source->line, xbuf, 1);
d4369 1
a4369 1
					histsave(source->line, es->cbuf, 1);
@


1.131
log
@when using search-history, ESC ends the search, however, ESC often leads
in præfix sequences (like ANSI cursor keys), leading to annoying effects
if we forget that

this patch changes the behaviour so that another character is read/peeked
at (since this is done in the main loop after ESC anyway, no function loss
through the delay) if ESC leads in a prefix-1 sequence, and if the peeked
character leads in a prefix-1 or prefix-2 sequence when in state prefix-1,
it’s still enacted (XXX document this in manpage)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.130 2008/09/20 14:10:23 tg Exp $");
d1213 1
d1272 1
d1330 1
d1420 2
d2124 1
a2124 1
x_nl_next_com(int c)
d2127 1
a2127 1
	return (x_newline(c));
d3147 25
@


1.130
log
@EXPERIMENTAL: make it so that the last (not yet entered) line (even if
empty) appears pushed into the history, so that, when pressing cursor-up
or ^P, with a cursor-down or ^N you get it back, unless you modify a line
retrieved from the history, in which case it will overwrite the saved line
and place the current history pointer past the entered history lines

This is for Emacs mode; Vi mode had something similar already, and shares
some code and data

XXX there are several static buffers of size LINE (currently 4096) in here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.129 2008/09/20 12:29:31 tg Exp $");
d2153 11
d2169 1
a2169 3
		if (c == MKCTRL('['))
			break;
		else if (f == XFUNC_search_hist)
@


1.129
log
@• since libc has OPTU-8 while mksh has CESU-8 for UTF-8 handling, we cannot
  use the libc functions for converting between multibyte strings and wide
  strings in here any more, besides mksh has slightly different needs than
  SUSv3 compliance ⇒ hand-craft optimised and unrolled functions for that
• sync the mksh-internal wcwidth function with libc
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.128 2008/09/14 20:24:58 tg Exp $");
d28 22
d138 1
a1118 1
static char	holdbuf[LINE];		/* place to hold last edit buffer */
d1616 1
d1752 1
d2092 1
d2094 4
a2097 1
	if (hp < history || hp > histptr) {
d2101 2
d2105 3
a2107 1
	strlcpy(xbuf, *hp, xend - xbuf);
d2115 1
d2251 1
d2423 1
d2528 1
d3091 1
d3262 1
a3526 1
static int	modified;		/* buffer has been "modified" */
a3557 1
	modified = 1;
@


1.128
log
@• merge vi_reset() and edit_reset() into x_vi() to allow for following:
• fix vi mode (which, however, is officially orphaned) multi-line $PS1 by
  using a similar algorithm for prompt skipping as emacs mode (changing
  the meaning of prompt_trunc variable and using prompt_redraw, just even
  more efficiently than vi mode); reported by asarch via IRC
• fix multi-line prompts if last line is “too large” by using emacs mode
  algorithm of just internally appending a newline, while here ☺ this even
  saves us having to re-add the prompt_skip variable…

WARNING: this is only barely tested, as almost nobody ever uses vi mode
⇒ test yourself, there may be bugs (e.g. off-by-ones); already known is
  that the vi input line editing mode is NOT multibyte safe…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.127 2008/05/17 18:46:57 tg Exp $");
d843 2
a844 2
/*
 * Markus Kuhn -- 2007-05-25 (Unicode 5.0)
d851 1
a851 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.7 2007/07/31 23:52:23 tg Exp $");
d929 1
d936 1
a936 2
/* --- begin of mbrtowc.c excerpt --- */
__RCSID("$miros: src/lib/libc/i18n/mbrtowc.c,v 1.15 2007/02/02 21:06:21 tg Exp $");
d942 1
a942 1
	unsigned int c, wc, count;
d944 7
a950 4
	wc = *s++;
	if (wc < 0x80) {
		count = 0;
	} else if (wc < 0xC2) {
d953 1
d955 2
a956 2
	} else if (wc < 0xE0) {
		count = 1; /* one byte follows */
d958 4
a961 6
	} else if (wc < 0xF0) {
		count = 2; /* two bytes follow */
		wc = (wc & 0x0F) << 12;
	} else {
		/* we don't support more than UCS-2 */
		goto ilseq;
d964 5
a968 5
	while (count) {
		if (((c = *s++) & 0xC0) != 0x80)
			goto ilseq;
		c &= 0x3F;
		wc |= c << (6 * --count);
d970 3
a972 4
		/* Check for non-minimalistic mapping error in 3-byte seqs */
		if (count && (wc < 0x0800))
			goto ilseq;
	}
d974 3
a976 1
	if (wc > 0xFFFD) {
d978 1
a978 6
		return ((size_t)(-1));
	}

	if (dst != NULL)
		*dst = wc;
	return (wc ? ((const char *)s - src) : 0);
a979 4
/* --- end of mbrtowc.c excerpt --- */

/* --- begin of wcrtomb.c excerpt --- */
__RCSID("$miros: src/lib/libc/i18n/wcrtomb.c,v 1.17 2007/02/02 21:06:22 tg Exp $");
d984 1
a984 1
	unsigned char count, *d = (unsigned char *)dst;
a985 2
	if (wc > 0xFFFD)
		wc = 0xFFFD;
d987 2
a988 8
		count = 0;
		*d++ = wc;
	} else if (wc < 0x0800) {
		count = 1;
		*d++ = (wc >> 6) | 0xC0;
	} else {
		count = 2;
		*d++ = (wc >> 12) | 0xE0;
d991 6
a996 2
	while (count) {
		*d++ = ((wc >> (6 * --count)) & 0x3F) | 0x80;
d998 1
a1000 1
/* --- end of wcrtomb.c excerpt --- */
@


1.127
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.126 2008/05/02 18:55:35 tg Exp $");
a3361 1
static void	vi_reset(char *, size_t);
a3370 1
static void	edit_reset(char *, size_t);
d3525 43
a3567 2
	vi_reset(buf, len > LINE ? LINE : len);
	pprompt(prompt, prompt_trunc);
a3885 14
static void
vi_reset(char *buf, size_t len)
{
	state = VNORMAL;
	ohnum = hnum = hlast = histnum(-1) + 1;
	insert = INSERT;
	saved_inslen = inslen;
	first_insert = 1;
	inslen = 0;
	modified = 1;
	vi_macro_reset();
	edit_reset(buf, len);
}

a4759 37


static void
edit_reset(char *buf, size_t len)
{

	es = &ebuf;
	es->cbuf = buf;
	es->cbufsize = len;
	undo = &undobuf;
	undo->cbufsize = len;

	es->linelen = undo->linelen = 0;
	es->cursor = undo->cursor = 0;
	es->winleft = undo->winleft = 0;

	cur_col = pwidth = promptlen(prompt);
	if (pwidth > x_cols - 3 - MIN_EDIT_SPACE) {
		cur_col = x_cols - 3 - MIN_EDIT_SPACE;
		prompt_trunc = pwidth - cur_col;
		pwidth -= prompt_trunc;
	} else
		prompt_trunc = 0;
	if (!wbuf_len || wbuf_len != x_cols - 3) {
		wbuf_len = x_cols - 3;
		wbuf[0] = aresize(wbuf[0], wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], wbuf_len, APERM);
	}
	(void)memset(wbuf[0], ' ', wbuf_len);
	(void)memset(wbuf[1], ' ', wbuf_len);
	winwidth = x_cols - pwidth - 3;
	win = 0;
	morec = ' ';
	lastref = 1;
	holdlen = 0;
}

d5025 2
a5026 1
	pprompt(prompt, prompt_trunc);
d5181 2
a5182 1
			pprompt(prompt, prompt_trunc);
@


1.126
log
@thinko: multibyte characters are not always 1 column wide
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.125 2008/04/20 02:01:42 tg Exp $");
d399 1
a399 1
		    alloc(sizeof(struct path_order_info) * nwords, ATEMP);
d589 1
a589 1
		afreechk(words[--nwords]);
d4708 1
a4708 1
	new = (struct edstate *)alloc(sizeof(struct edstate), APERM);
@


1.125
log
@sync with updated libc functions
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.124 2008/04/20 00:03:50 tg Exp $");
a61 1
static inline char *utf_getcpfromcols(char *, int);
d830 2
a831 2
static inline char *
utf_getcpfromcols(char *p, int cols)
d836 1
a836 1
		c += utf_widthadj(p, (const char **)&p);
d1825 1
a1825 1
	if (cp < xbp || cp >= utf_getcpfromcols(xbp, x_displen)) {
@


1.124
log
@utf-8 function overhaul (size optimisation)
XXX maybe we can get more out of this?
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.123 2008/04/19 22:50:01 tg Exp $");
d845 1
a845 1
 * Markus Kuhn -- 2003-05-20 (Unicode 4.0)
d852 1
a852 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.4 2006/11/01 20:01:20 tg Exp $");
d862 6
a867 6
		{ 0x0591, 0x05B9 }, { 0x05BB, 0x05BD }, { 0x05BF, 0x05BF },
		{ 0x05C1, 0x05C2 }, { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 },
		{ 0x0600, 0x0603 }, { 0x0610, 0x0615 }, { 0x064B, 0x065E },
		{ 0x0670, 0x0670 }, { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 },
		{ 0x06EA, 0x06ED }, { 0x070F, 0x070F }, { 0x0711, 0x0711 },
		{ 0x0730, 0x074A }, { 0x07A6, 0x07B0 }, { 0x0901, 0x0902 },
d881 23
a903 21
		{ 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D }, { 0x0DCA, 0x0DCA },
		{ 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
		{ 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
		{ 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
		{ 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
		{ 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
		{ 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 }, { 0x0F99, 0x0FBC },
		{ 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1032 },
		{ 0x1036, 0x1037 }, { 0x1039, 0x1039 }, { 0x1058, 0x1059 },
		{ 0x1160, 0x11FF }, { 0x135F, 0x135F }, { 0x1712, 0x1714 },
		{ 0x1732, 0x1734 }, { 0x1752, 0x1753 }, { 0x1772, 0x1773 },
		{ 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
		{ 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD }, { 0x180B, 0x180D },
		{ 0x18A9, 0x18A9 }, { 0x1920, 0x1922 }, { 0x1927, 0x1928 },
		{ 0x1932, 0x1932 }, { 0x1939, 0x193B }, { 0x1A17, 0x1A18 },
		{ 0x1DC0, 0x1DC3 }, { 0x200B, 0x200F }, { 0x202A, 0x202E },
		{ 0x2060, 0x2063 }, { 0x206A, 0x206F }, { 0x20D0, 0x20EB },
		{ 0x302A, 0x302F }, { 0x3099, 0x309A }, { 0xA806, 0xA806 },
		{ 0xA80B, 0xA80B }, { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E },
		{ 0xFE00, 0xFE0F }, { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF },
		{ 0xFFF9, 0xFFFB }
d937 1
a937 1
__RCSID("$miros: src/lib/libc/i18n/mbrtowc.c,v 1.13 2006/11/01 20:01:19 tg Exp $");
d986 1
a986 1
__RCSID("$miros: src/lib/libc/i18n/wcrtomb.c,v 1.14 2006/11/01 20:12:44 tg Exp $");
@


1.123
log
@regression: interactive use didn’t work at all oO
the “fix” is to treat NUL bytes as width=len=1…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.122 2008/04/19 22:15:01 tg Exp $");
d62 1
a62 1
static char *utf_getcpfromcols(char *, int);
d806 1
a806 1
size_t
d811 2
a812 7
	if (!Flag(FUTFHACK) || *(const unsigned char *)src < 0xC2)
		len = 1;
	else if (*(const unsigned char *)src < 0xE0)
		len = 2;
	else if (*(const unsigned char *)src < 0xF0)
		len = 3;
	else
a813 7

	if (len > 1)
		if ((*(const unsigned char *)(src + 1) & 0xC0) != 0x80)
			len = 1;
	if (len > 2)
		if ((*(const unsigned char *)(src + 2) & 0xC0) != 0x80)
			len = 1;
d816 1
a816 1
	return (len);
d820 6
a825 8
#define utf_ptradj(s,d) ({		\
	union mksh_cchack out;		\
	char **dst = (d);		\
	size_t rv;			\
					\
	rv = utf_cptradj((s), &out.ro);	\
	if (dst)			\
		*dst = out.rw;		\
d831 1
a831 1
static char *
@


1.122
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.121 2008/04/19 17:25:49 tg Exp $");
d773 2
a774 1
	if (!Flag(FUTFHACK) || (len = utf_mbtowc(&wc, src)) == (size_t)-1)
@


1.121
log
@invalid 3-octet multibyte sequences are stripped to 1 not 2 bytes
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.120 2008/04/19 17:21:52 tg Exp $");
a60 3
static size_t mbxtowc(unsigned *, const char *);
static size_t wcxtomb(char *, unsigned);
static int wcxwidth(unsigned);
d770 1
a770 1
	unsigned wc;
d773 4
a776 6
	if (!Flag(FUTFHACK) || *(const unsigned char *)src <= 0x7F ||
	    (len = mbxtowc(&wc, src)) == (size_t)-1) {
		if (dst)
			*dst = src + 1;
		return (1);
	}
a779 1
	width = wcxwidth(wc);
d784 1
a784 1
ksh_mbswidth(const char *s)
d794 2
a795 2
		if (((len = mbxtowc(&wc, s)) == (size_t)-1) ||
		    ((cw = wcxwidth(wc)) == -1)) {
d867 2
a868 2
static int
wcxwidth(unsigned c)
d950 2
a951 2
static size_t
mbxtowc(unsigned *dst, const char *src)
d999 2
a1000 2
static size_t
wcxtomb(char *src, unsigned wc)
d1002 1
a1002 2
	unsigned char *s = (unsigned char *)src;
	unsigned int count;
d1008 1
a1008 1
		*s++ = wc;
d1011 1
a1011 1
		*s++ = (wc >> 6) | 0xC0;
d1014 1
a1014 1
		*s++ = (wc >> 12) | 0xE0;
d1018 1
a1018 1
		*s++ = ((wc >> (6 * --count)) & 0x3F) | 0x80;
d1020 1
a1020 1
	return ((char *)s - src);
d1431 1
a1431 1
			buf[pos++] = c = x_e_getc();
d1434 5
d1441 1
a1446 1
	buf[pos] = '\0';
d1911 4
a1914 1
	unsigned c = **(unsigned char **)cp;
d1916 5
d1925 1
a1925 2
	} else if (c < ' ' || c == 0x7f || (Flag(FUTFHACK) && c == 0xC2 &&
	    ((unsigned char *)*cp)[1] < 0xA0 && mbxtowc(&c, *cp))) {
d1928 1
a1928 1
		*cp += c & 0x80 ? 2 : 1;
d2380 1
a2380 1
		if (mbxtowc(&tmpa, xcp) == (size_t)-1) {
d2385 1
a2385 1
		if (mbxtowc(&tmpb, xcp) == (size_t)-1) {
d2389 1
a2389 1
		wcxtomb(xcp, tmpa);
d2391 1
a2391 1
		wcxtomb(xcp, tmpb);
d2397 1
a2397 1
		if (mbxtowc(&tmpa, xcp) == (size_t)-1) {
d2402 1
a2402 1
		if (mbxtowc(&tmpb, xcp) == (size_t)-1) {
d2406 1
a2406 1
		wcxtomb(xcp, tmpa);
d2408 1
a2408 1
		wcxtomb(xcp, tmpb);
d2965 1
a2965 1
			x = wcxtomb(utf_tmp, c);
d2971 1
a2971 1
			width = wcxwidth(c);
@


1.120
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.119 2008/04/01 21:50:57 tg Exp $");
d830 1
a830 1
			len = 2;
@


1.119
log
@more
• int → bool
• shprintf("foo") → shf_puts("foo", shl_stdout)
• shprintf("%s", foo) → shf_puts(foo, shl_stdout)
• shf_puts("x", foo) → shf_putc('x', foo)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.118 2008/03/23 21:31:29 tg Exp $");
d32 3
a34 2
static void x_print_expansions(int, char *const *, int);
static int x_cf_glob(int, const char *, int, int, int *, int *, char ***, int *);
d59 7
a65 1
static int x_locate_word(const char *, int, int, int *, int *);
d172 1
a172 2
	int i, j;
	int len = *lenp;
d179 1
a179 1
		int saw_nl = 0;
a211 1

d213 1
a213 1
x_print_expansions(int nwords, char * const *words, int is_command)
d215 1
a215 1
	int use_copy = 0;
d238 1
a238 1
			use_copy = 1;
d266 1
a266 2
	char *toglob;
	char **words;
d362 1
a362 3
	char *toglob;
	char *pat;
	char *fpath;
d398 1
a398 2
		struct path_order_info *info;
		struct path_order_info *last_info = 0;
d400 1
a400 2
		int path_order = 0;
		int i;
d447 1
a447 1
    int *is_commandp)
a448 1
	int p;
d454 1
a454 1
		*is_commandp = 0;
d473 2
a474 1
		int iscmd;
d477 2
a478 3
		for (p = start - 1; p >= 0 && ksh_isspace(buf[p]);
		    p--)
			;
d499 1
a499 1
    int *endp, char ***wordsp, int *is_commandp)
d501 1
a501 2
	int len;
	int nwords;
d503 1
a503 1
	int is_command;
d507 1
a507 1
		is_command = 0;
d536 1
a536 2
	char *toglob;
	char *s;
d573 1
a573 2
	int i, j;
	int prefix_len;
d592 2
a593 4
	int i;

	for (i = 0; i < nwords; i++)
		afreechk(words[i]);
d650 2
a651 6
	char *xp;
	int staterr;
	int pathlen;
	int patlen;
	int oldsize, newsize, i, j;
	char **words;
a742 9
/* +++ UTF-8 hack +++ */

static size_t mbxtowc(unsigned *, const char *);
static size_t wcxtomb(char *, unsigned);
static int wcxwidth(unsigned);
static int x_e_getmbc(char *);
static char *utf_getcpfromcols(char *, int);
static void utf_ptradj(char *, char **);

d789 24
a812 2
static void
utf_ptradj(char *src, char **dst)
d816 1
a816 1
	if (!Flag(FUTFHACK) || *(unsigned char *)src < 0xC2)
d818 1
a818 1
	else if (*(unsigned char *)src < 0xE0)
d820 1
a820 1
	else if (*(unsigned char *)src < 0xF0)
d826 1
a826 1
		if ((*(unsigned char *)(src + 1) & 0xC0) != 0x80)
d829 1
a829 1
		if ((*(unsigned char *)(src + 2) & 0xC0) != 0x80)
d833 1
d836 14
d960 1
a960 2
	unsigned c, wc;
	unsigned count;
d1009 1
a1009 1
	unsigned count;
d1987 2
a1988 3
	char *cp = xcp, *p;
	char tmp[4];
	int b;
d2005 1
a2005 1
			b = 1;
d2007 1
a2007 1
				b = 0;
d2009 1
a2009 1
				b = 0;
d2011 1
a2011 1
				b = 0;
d2348 1
a2348 1
	unsigned tmpa, tmpb;
d2482 1
d2592 1
a2592 2
	char *sp = NULL;
	char *m1, *m2;
d2821 2
a2822 4
	int nwords;
	int start, end;
	int is_command;
	int i;
d2851 2
a2852 4
	int nwords;
	int start, end, nlen, olen;
	int is_command;
	int completed = 0;
d2875 1
a2875 1
		completed = 1;
d2880 1
a2880 1
		completed = 1;
d2884 1
a2884 1
		completed = 1;
d3044 1
a3044 2
	int n = 0;
	int first = 1;
d3087 1
a3087 1
	int lim = x_lastcp() - xbp;
a3088 1
	int vlen;
d3130 1
a3130 2
	char *rcp;
	char *cp;
d5276 1
a5276 3
	int rval;
	int nwords;
	int start, end;
d5279 1
a5279 3
	int match_len;
	int is_unique;
	int is_command;
d5336 1
a5336 1
		is_unique = 1;
d5377 1
a5377 2
	int nwords;
	int start, end;
d5379 1
a5379 1
	int is_command;
@


1.118
log
@make rcs ids ident(1) capable
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.117 2007/10/25 15:23:08 tg Exp $");
d2559 2
a2560 2
		shprintf("%s", x_mapout(prefix == 1 ?
		    MKCTRL('[') : MKCTRL('X')));
@


1.117
log
@get rid of u_char, u_int, u_long
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.116 2007/10/25 15:19:15 tg Exp $");
d853 1
a853 1
__RCSID("_MirOS: src/lib/libc/i18n/wcwidth.c,v 1.4 2006/11/01 20:01:20 tg Exp $");
d936 1
a936 1
__RCSID("_MirOS: src/lib/libc/i18n/mbrtowc.c,v 1.13 2006/11/01 20:01:19 tg Exp $");
d986 1
a986 1
__RCSID("_MirOS: src/lib/libc/i18n/wcrtomb.c,v 1.14 2006/11/01 20:12:44 tg Exp $");
@


1.117.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.119 2008/04/01 21:50:57 tg Exp $");
d853 1
a853 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.4 2006/11/01 20:01:20 tg Exp $");
d936 1
a936 1
__RCSID("$miros: src/lib/libc/i18n/mbrtowc.c,v 1.13 2006/11/01 20:01:19 tg Exp $");
d986 1
a986 1
__RCSID("$miros: src/lib/libc/i18n/wcrtomb.c,v 1.14 2006/11/01 20:12:44 tg Exp $");
d2559 2
a2560 2
		shf_puts(x_mapout(prefix == 1 ?
		    MKCTRL('[') : MKCTRL('X')), shl_stdout);
@


1.117.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.127 2008/05/17 18:46:57 tg Exp $");
d32 2
a33 3
static void x_print_expansions(int, char *const *, bool);
static int x_cf_glob(int, const char *, int, int, int *, int *, char ***,
    bool *);
d58 1
a58 3
static int x_locate_word(const char *, int, int, int *, bool *);

static int x_e_getmbc(char *);
d165 2
a166 1
	int i, j, len = *lenp;
d173 1
a173 1
		bool saw_nl = false;
d206 1
d208 1
a208 1
x_print_expansions(int nwords, char * const *words, bool is_command)
d210 1
a210 1
	bool use_copy = false;
d233 1
a233 1
			use_copy = true;
d261 2
a262 1
	char *toglob, **words;
d358 3
a360 1
	char *toglob, *pat, *fpath;
d396 2
a397 1
		struct path_order_info *info, *last_info = NULL;
d399 2
a400 1
		int i, path_order = 0;
d403 1
a403 1
		    alloc(sizeof (struct path_order_info) * nwords, ATEMP);
d447 1
a447 1
    bool *is_commandp)
d449 1
d455 1
a455 1
		*is_commandp = false;
d474 1
a474 2
		bool iscmd;
		int p = start - 1;
d477 3
a479 2
		while (p >= 0 && ksh_isspace(buf[p]))
			p--;
d500 1
a500 1
    int *endp, char ***wordsp, bool *is_commandp)
d502 2
a503 1
	int len, nwords;
d505 1
a505 1
	bool is_command;
d509 1
a509 1
		is_command = false;
d538 2
a539 1
	char *toglob, *s;
d576 2
a577 1
	int i, j, prefix_len;
d596 4
a599 2
	while (nwords)
		afree(words[--nwords], ATEMP);
d656 6
a661 2
	char *xp, **words;
	int staterr, pathlen, patlen, oldsize, newsize, i, j;
d753 9
d792 1
a792 1
	unsigned int wc;
d795 6
a800 5
	if (!Flag(FUTFHACK) || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
	    wc == 0)
		len = width = 1;
	else
		width = utf_wcwidth(wc);
d804 1
d808 2
a809 2
int
utf_mbswidth(const char *s)
a811 2
	unsigned int wc;
	int width = 0, cw;
d813 8
a820 2
	if (!Flag(FUTFHACK))
		return (strlen(s));
d822 6
a827 20
	while (*s)
		if (((len = utf_mbtowc(&wc, s)) == (size_t)-1) ||
		    ((cw = utf_wcwidth(wc)) == -1)) {
			s++;
			width += 1;
		} else {
			s += len;
			width += cw;
		}
	return (width);
}

void
utf_cptradj(const char *src, const char **dst)
{
	size_t len;

	if (!Flag(FUTFHACK) || *(const unsigned char *)src < 0xC2 ||
	    (len = utf_mbtowc(NULL, src)) == (size_t)-1)
		len = 1;
a829 1
	/* return (len); */
d832 2
a833 14
#if HAVE_EXPSTMT
#define utf_ptradj(s,d) ({			\
	union mksh_cchack utf_ptradj_o;		\
	char **utf_ptradj_d = (d);		\
						\
	utf_cptradj((s), &utf_ptradj_o.ro);	\
	*utf_ptradj_d = utf_ptradj_o.rw;	\
})
#else
#define utf_ptradj(s,d) utf_cptradj((s), (const char **)(d))
#endif

const char *
utf_skipcols(const char *p, int cols)
d838 1
a838 1
		c += utf_widthadj(p, &p);
d846 1
a846 1
 * Markus Kuhn -- 2007-05-25 (Unicode 5.0)
d853 1
a853 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.7 2007/07/31 23:52:23 tg Exp $");
d855 2
a856 2
int
utf_wcwidth(unsigned int c)
d863 6
a868 6
		{ 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
		{ 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
		{ 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
		{ 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
		{ 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
		{ 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
d882 21
a902 23
		{ 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
		{ 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
		{ 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
		{ 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
		{ 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
		{ 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
		{ 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
		{ 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
		{ 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
		{ 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
		{ 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
		{ 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
		{ 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
		{ 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
		{ 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
		{ 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
		{ 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
		{ 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
		{ 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
		{ 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
		{ 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
		{ 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
		{ 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB }
d936 1
a936 1
__RCSID("$miros: src/lib/libc/i18n/mbrtowc.c,v 1.15 2007/02/02 21:06:21 tg Exp $");
d938 2
a939 2
size_t
utf_mbtowc(unsigned int *dst, const char *src)
d942 2
a943 1
	unsigned int c, wc, count;
d986 1
a986 1
__RCSID("$miros: src/lib/libc/i18n/wcrtomb.c,v 1.17 2007/02/02 21:06:22 tg Exp $");
d988 2
a989 2
size_t
utf_wctomb(char *dst, unsigned int wc)
d991 2
a992 1
	unsigned char count, *d = (unsigned char *)dst;
d998 1
a998 1
		*d++ = wc;
d1001 1
a1001 1
		*d++ = (wc >> 6) | 0xC0;
d1004 1
a1004 1
		*d++ = (wc >> 12) | 0xE0;
d1008 1
a1008 1
		*d++ = ((wc >> (6 * --count)) & 0x3F) | 0x80;
d1010 1
a1010 1
	return ((char *)d - dst);
d1421 1
a1421 1
			c = x_e_getc();
a1423 5
			if ((c & 0xC0) != 0x80) {
				x_e_ungetc(c);
				return (1);
			}
			buf[pos++] = c;
a1425 1
			/* XXX x_e_ungetc is one-octet only */
d1431 1
d1822 1
a1822 1
	if (cp < xbp || cp >= utf_skipcols(xbp, x_displen)) {
d1896 1
a1896 4
	unsigned char c = **(unsigned char **)cp;

	if (c == 0xC2 && Flag(FUTFHACK)) {
		unsigned char c2 = ((unsigned char *)*cp)[1];
a1897 5
		if (c2 >= 0x80 && c2 < 0xA0) {
			c = c2;
			(*cp)++;
		}
	}
d1902 2
a1903 1
	} else if (c < ' ' || (c >= 0x7F && c < 0xA0)) {
d1906 1
a1906 1
		(*cp)++;
d1970 3
a1972 2
	char *cp = xcp, *p, tmp[4];
	bool b;
d1989 1
a1989 1
			b = true;
d1991 1
a1991 1
				b = false;
d1993 1
a1993 1
				b = false;
d1995 1
a1995 1
				b = false;
d2332 1
a2332 1
	unsigned int tmpa, tmpb;
d2359 1
a2359 1
		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
d2364 1
a2364 1
		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
d2368 1
a2368 1
		utf_wctomb(xcp, tmpa);
d2370 1
a2370 1
		utf_wctomb(xcp, tmpb);
d2376 1
a2376 1
		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
d2381 1
a2381 1
		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
d2385 1
a2385 1
		utf_wctomb(xcp, tmpa);
d2387 1
a2387 1
		utf_wctomb(xcp, tmpb);
a2465 1

d2575 2
a2576 1
	char *sp = NULL, *m1, *m2;
d2805 4
a2808 2
	int start, end, nwords, i;
	bool is_command;
d2837 4
a2840 2
	int start, end, nlen, olen, nwords;
	bool is_command, completed = false;
d2863 1
a2863 1
		completed = true;
d2868 1
a2868 1
		completed = true;
d2872 1
a2872 1
		completed = true;
d2948 1
a2948 1
			x = utf_wctomb(utf_tmp, c);
d2954 1
a2954 1
			width = utf_wcwidth(c);
d3032 2
a3033 1
	int n = 0, first = 1;
d3076 1
a3076 1
	int vlen, lim = x_lastcp() - xbp;
d3078 1
d3120 2
a3121 1
	char *rcp, *cp;
d4706 1
a4706 1
	new = (struct edstate *)alloc(sizeof (struct edstate), APERM);
d5267 3
a5269 1
	int rval, nwords, start, end, match_len;
d5272 3
a5274 1
	bool is_command, is_unique;
d5331 1
a5331 1
		is_unique = true;
d5372 2
a5373 1
	int start, end, nwords;
d5375 1
a5375 1
	bool is_command;
@


1.117.2.3
log
@MFC: mksh R36b
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.148 2008/12/13 17:02:12 tg Exp $");
a27 3
static int modified;			/* buffer has been "modified" */
static char holdbuf[LINE];		/* place to hold last edit buffer */

a115 1
	modified = 1;
d399 1
a399 1
		    alloc(nwords * sizeof (struct path_order_info), ATEMP);
d414 1
a414 1
		afree(info, ATEMP);
d538 1
a538 1
	strndupx(toglob, str, slen + 1, ATEMP); /* + 1 for "*" */
d636 4
a639 8
	ktwalk(&ts, tp);
	while ((te = ktnext(&ts)))
		if (gmatchx(te->name, pat, false)) {
			char *cp;

			strdupx(cp, te->name, ATEMP);
			XPput(*wp, cp);
		}
d741 24
d772 1
a772 1
	if (!UTFMODE || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
d790 1
a790 1
	if (!UTFMODE)
d805 25
d843 2
a844 2
/*-
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
d851 1
a851 1
__RCSID("$miros: src/lib/libc/i18n/wcwidth.c,v 1.8 2008/09/20 12:01:18 tg Exp $");
a928 1
	    (c >= 0xfe10 && c <= 0xfe19) || /* Vertical forms */
d935 2
a936 1
/* +++ CESU-8 multibyte and wide character conversion crafted for mksh +++ */
d942 1
a942 1
	unsigned int c, wc;
d944 4
a947 7
	if ((wc = *s++) < 0x80) {
 out:
		if (dst != NULL)
			*dst = wc;
		return (wc ? ((const char *)s - src) : 0);
	}
	if (wc < 0xC2 || wc >= 0xF0)
a949 1
		/* > 0xEF: beyond BMP */
d951 10
d962 1
a962 2
	if (wc < 0xE0) {
		wc = (wc & 0x1F) << 6;
d965 6
a970 2
		wc |= c & 0x3F;
		goto out;
d973 4
a976 1
	wc = (wc & 0x0F) << 12;
d978 5
a982 3
	if (((c = *s++) & 0xC0) != 0x80)
		goto ilseq;
	wc |= (c & 0x3F) << 6;
d984 2
a985 10
	if (((c = *s++) & 0xC0) != 0x80)
		goto ilseq;
	wc |= c & 0x3F;

	/* Check for non-minimalistic mapping error in 3-byte seqs */
	if (wc >= 0x0800 && wc <= 0xFFFD)
		goto out;
 ilseq:
	return ((size_t)(-1));
}
d990 1
a990 1
	unsigned char *d;
d992 2
d995 8
a1002 2
		*dst = wc;
		return (1);
d1005 2
a1006 6
	d = (unsigned char *)dst;
	if (wc < 0x0800)
		*d++ = (wc >> 6) | 0xC0;
	else {
		*d++ = ((wc = wc > 0xFFFD ? 0xFFFD : wc) >> 12) | 0xE0;
		*d++ = ((wc >> 6) & 0x3F) | 0x80;
a1007 1
	*d++ = (wc & 0x3F) | 0x80;
d1010 1
d1074 1
a1074 1
static int x_adj_done;
d1076 11
a1086 11
static int xx_cols;
static int x_col;
static int x_displen;
static int x_arg;		/* general purpose arg */
static int x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */

static int xlp_valid;

static char **x_histp;		/* history position */
static int x_nextcmd;		/* for newline-and-next */
static char *xmp;		/* mark pointer */
d1089 7
a1095 7
static char *(*x_atab)[X_TABSZ];	/* macro definitions */
static unsigned char x_bound[(X_TABSZ * X_NTABS + 7) / 8];
#define KILLSIZE	20
static char *killstack[KILLSIZE];
static int killsp, killtp;
static int x_curprefix;
static char *macroptr;
d1097 11
a1107 10
static int cur_col;		/* current column on line */
static int pwidth;		/* width of prompt */
static int prompt_trunc;	/* how much of prompt to truncate */
static int winwidth;		/* width of window */
static char *wbuf[2];		/* window buffers */
static int wbuf_len;		/* length of window buffers (x_cols - 3) */
static int win;			/* window buffer in use */
static char morec;		/* more character at right of window */
static int lastref;		/* argument to last refresh() */
static int holdlen;		/* length of holdbuf */
d1109 1
a1109 1
static int prompt_redraw;	/* 0 if newline forced after prompt */
d1111 29
a1139 29
static int x_ins(const char *);
static void x_delete(int, int);
static int x_bword(void);
static int x_fword(int);
static void x_goto(char *);
static void x_bs3(char **);
static int x_size_str(char *);
static int x_size2(char *, char **);
static void x_zots(char *);
static void x_zotc2(int);
static void x_zotc3(char **);
static void x_load_hist(char **);
static int x_search(char *, int, int);
static int x_match(char *, char *);
static void x_redraw(int);
static void x_push(int);
static char *x_mapin(const char *, Area *);
static char *x_mapout(int);
static void x_mapout2(int, char **);
static void x_print(int, int);
static void x_adjust(void);
static void x_e_ungetc(int);
static int x_e_getc(void);
static void x_e_putc2(int);
static void x_e_putc3(const char **);
static void x_e_puts(const char *);
static int x_fold_case(int);
static char *x_lastcp(void);
static void do_complete(int, Comp_type);
a1200 1
#define XFUNC_edit_line 55
a1258 1
static int x_edit_line(int);
a1315 1
	{ x_edit_line,		"edit-line",			XF_ARG },
a1404 2
	/* more non-standard ones */
	{ XFUNC_edit_line,		2,	  'e'	}
a1406 19
#ifdef MKSH_SMALL
static void x_modified(void);
static void
x_modified(void)
{
	if (!modified) {
		x_histp = histptr + 1;
		modified = 1;
	}
}
#else
#define x_modified() do {			\
	if (!modified) {			\
		x_histp = histptr + 1;		\
		modified = 1;			\
	}					\
} while (/* CONSTCOND */ 0)
#endif

d1417 1
a1417 1
	if (UTFMODE) {
d1503 1
a1503 1
		switch ((*x_ftab[f].xf_func)(i)) {
d1536 1
a1536 1
	if (UTFMODE) {
a1603 1
	x_modified();
d1627 1
a1627 1
			x_bs3(&cp);
d1659 1
a1659 1
		utf_ptradjx(cp, cp2);
d1712 1
d1736 2
a1737 3
	cp = x_lastcp();
	while (cp > xcp)
		x_bs3(&cp);
a1738 1
	x_modified();
d1792 1
a1792 1
		utf_ptradjx(cp, cp);
d1813 1
a1813 1
		utf_ptradjx(cp2, cp2);
d1822 1
a1822 1
	if (UTFMODE)
d1831 1
a1831 1
			x_bs3(&xcp);
d1839 1
a1839 1
x_bs3(char **p)
d1843 1
a1843 6
	(*p)--;
	if (UTFMODE)
		while (((unsigned char)**p & 0xC0) == 0x80)
			(*p)--;

	i = x_size2(*p, NULL);
d1862 1
a1862 1
	if (UTFMODE && (c > 0x7F))
d1901 1
a1901 1
	if (c == 0xC2 && UTFMODE) {
d1946 1
a1946 1
		utf_ptradjx(cp, cp2);
a2077 1
	char *sp = NULL;
d2079 1
a2079 4
	if (hp == histptr + 1) {
		sp = holdbuf;
		modified = 0;
	} else if (hp < history || hp > histptr) {
a2082 2
	if (sp == NULL)
		sp = *hp;
d2085 1
a2085 3
	if (modified)
		strlcpy(holdbuf, xbuf, sizeof (holdbuf));
	strlcpy(xbuf, sp, xend - xbuf);
a2092 1
	modified = 0;
d2096 1
a2096 1
x_nl_next_com(int c __unused)
d2099 1
a2099 1
	return (x_newline('\n'));
a2129 11
		if (c == MKCTRL('[')) {
			if ((f & 0x7F) == XFUNC_meta1) {
				if ((c = x_e_getc()) < 0)
					return KSTD;
				f = x_tab[1][c] & 0x7F;
				if (f == XFUNC_meta1 || f == XFUNC_meta2)
					x_meta1(MKCTRL('['));
				x_e_ungetc(c);
			}
			break;
		}
d2135 3
a2137 1
		if (f == XFUNC_search_hist)
a2168 4
		} else if (f == XFUNC_abort) {
			if (offset >= 0)
				x_load_hist(histptr + 1);
			break;
a2227 1
	x_modified();
d2297 1
a2297 1
	x_lastcp();
d2332 2
a2333 3
	cp = xlp;
	while (cp > xcp)
		x_bs3(&cp);
d2367 1
a2367 1
		x_bs3(&xcp);
d2372 1
a2372 1
		x_bs3(&xcp);
d2389 1
a2389 1
		x_bs3(&xcp);
a2398 1
	x_modified();
d2446 1
a2446 3
	char *cp;

	strndupx(cp, xcp, nchars, AEDIT);
d2448 1
a2448 1
		afree(killstack[killsp], AEDIT);
a2502 1
	x_modified();
d2518 1
a2518 2
	strdupx(new, cp, ap);
	op = new;
d2657 1
a2657 1
		afree(x_atab[prefix][key], AEDIT);
d2680 1
a2680 1
	x_tab = alloc(X_NTABS * sizeof (*x_tab), AEDIT);
d2690 1
a2690 1
	x_atab = alloc(X_NTABS * sizeof (*x_atab), AEDIT);
d2886 1
a2886 1
 *	x_adjust - redraw the line adjusting starting point etc.
d2889 5
a2893 5
 *	This function is called when we have exceeded the bounds
 *	of the edit window.  It increments x_adj_done so that
 *	functions like x_ins and x_delete know that we have been
 *	called and can skip the x_bs() stuff which has already
 *	been done by x_redraw.
d2896 1
a2896 1
 *	None
d2907 1
a2907 1
	if (UTFMODE)
d2947 1
a2947 1
		if (UTFMODE && (c > 0x7F)) {
d2988 1
a2988 1
		if (UTFMODE && (c > 0x7F)) {
d3026 1
a3026 1
 *	x_set_arg - set an arg value for next function
d3029 1
a3029 1
 *	This is a simple implementation of M-[0-9].
d3032 1
a3032 1
 *	KSTD
a3064 1
		x_modified();
d3081 1
a3081 3
	char *v;

	strdupx(v, KSH_VERSION, ATEMP);
a3105 24
static int
x_edit_line(int c __unused)
{
	if (x_arg_defaulted) {
		if (xep == xbuf) {
			x_e_putc2(7);
			return (KSTD);
		}
		if (modified) {
			*xep = '\0';
			histsave(&source->line, xbuf, true, true);
			x_arg = 0;
		} else
			x_arg = source->line - (histptr - x_histp);
	}
	if (x_arg)
		shf_snprintf(xbuf, xend - xbuf, "%s %d",
		    "fc -e ${VISUAL:-${EDITOR:-vi}} --", x_arg);
	else
		strlcpy(xbuf, "fc -e ${VISUAL:-${EDITOR:-vi}} --", xend - xbuf);
	xep = xbuf + strlen(xbuf);
	return (x_newline('\n'));
}

d3107 1
a3107 1
 *	x_prev_histword - recover word from prev command
d3110 4
a3113 6
 *	This function recovers the last word from the previous
 *	command and inserts it into the current edit line.  If a
 *	numeric arg is supplied then the n'th word from the
 *	start of the previous command is used.
 *	As a side effect, trashes the mark in order to achieve
 *	being called in a repeatable fashion.
d3115 1
a3115 1
 *	Bound to M-.
d3118 1
a3118 1
 *	KSTD
a3123 2
	char **xhp;
	int m;
d3125 2
a3126 5
	if (xmp && modified > 1)
		x_kill_region(0);
	m = modified ? modified : 1;
	xhp = histptr - (m - 1);
	if ((xhp < history) || !(cp = *xhp)) {
d3128 1
a3128 5
		x_modified();
		return (KSTD);
	}
	x_set_mark(0);
	if (x_arg_defaulted) {
a3162 1
	modified = m + 1;
d3188 1
a3188 1
 *	x_fold_case - convert word to UPPER/lower/Capital case
d3191 2
a3192 2
 *	This function is used to implement M-U,M-u,M-L,M-l,M-C and M-c
 *	to UPPER case, lower case or Capitalise words.
d3195 1
a3195 1
 *	None
a3234 1
	x_modified();
d3239 1
a3239 1
 *	x_lastcp - last visible char
d3242 1
a3242 1
 *	x_lastcp()
d3245 3
a3247 3
 *	This function returns a pointer to that  char in the
 *	edit buffer that will be the last displayed on the
 *	screen.  The sequence:
d3249 2
a3250 3
 *	cp = x_lastcp();
 *	while (cp > xcp)
 *		x_bs3(&cp);
d3252 1
a3252 1
 *	Will position the cursor correctly on the screen.
d3255 1
a3255 1
 *	cp or NULL
d3362 1
d3372 1
d3501 1
d3527 2
a3528 42
	state = VNORMAL;
	ohnum = hnum = hlast = histnum(-1) + 1;
	insert = INSERT;
	saved_inslen = inslen;
	first_insert = 1;
	inslen = 0;
	vi_macro_reset();

	es = &ebuf;
	es->cbuf = buf;
	undo = &undobuf;
	undo->cbufsize = es->cbufsize = len > LINE ? LINE : len;

	es->linelen = undo->linelen = 0;
	es->cursor = undo->cursor = 0;
	es->winleft = undo->winleft = 0;

	cur_col = promptlen(prompt);
	prompt_trunc = (cur_col / x_cols) * x_cols;
	cur_col -= prompt_trunc;

	pprompt(prompt, 0);
	if (cur_col > x_cols - 3 - MIN_EDIT_SPACE) {
		prompt_redraw = cur_col = 0;
		x_putc('\n');
	} else
		prompt_redraw = 1;
	pwidth = cur_col;

	if (!wbuf_len || wbuf_len != x_cols - 3) {
		wbuf_len = x_cols - 3;
		wbuf[0] = aresize(wbuf[0], wbuf_len, APERM);
		wbuf[1] = aresize(wbuf[1], wbuf_len, APERM);
	}
	(void)memset(wbuf[0], ' ', wbuf_len);
	(void)memset(wbuf[1], ' ', wbuf_len);
	winwidth = x_cols - pwidth - 3;
	win = 0;
	morec = ' ';
	lastref = 1;
	holdlen = 0;

d3847 14
d4119 2
a4120 3
					do {
						--ncursor;
					} while (ksh_isspace(es->cbuf[ncursor]));
d4273 2
a4275 2
				if (es->linelen == 0)
					return -1;
d4278 2
a4279 2
					histsave(&source->line, es->cbuf, true,
					    true);
d4708 1
a4708 1
	new = alloc(sizeof (struct edstate), APERM);
d4732 38
a4769 1
	afree(old, APERM);
d5037 1
a5037 2
	if (prompt_redraw)
		pprompt(prompt, prompt_trunc);
d5192 1
a5192 2
			if (prompt_redraw)
				pprompt(prompt, prompt_trunc);
@


1.116
log
@optimise (struct padding, function→macro, etc.)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.115 2007/10/14 13:43:41 tg Exp $");
d765 7
a771 7
#define utf_backch(c)	(!Flag(FUTFHACK) ? (c) - 1 : ({	\
	u_char *utf_backch_cp = (u_char *)(c);		\
	--utf_backch_cp;				\
	while ((*utf_backch_cp >= 0x80) &&		\
	    (*utf_backch_cp < 0xC0))			\
		--utf_backch_cp;			\
	(__typeof__ (c))utf_backch_cp;			\
d774 6
a779 5
#define utf_backch(c)	(!Flag(FUTFHACK) ? (c) - 1 : 	\
	    (c) + (ptrdiff_t)(utf_backch_((u_char *)c) - ((u_char *)(c))))
static u_char *utf_backch_(u_char *);
static u_char *
utf_backch_(u_char *utf_backch_cp)
d1089 2
a1090 2
static u_char	x_last_command;
static u_char	(*x_tab)[X_TABSZ];	/* key definition */
d1459 1
a1459 1
	u_char f;
d1866 1
a1866 1
		return 2;	/* control u_char */
d2109 1
a2109 1
	u_char f;
d2573 1
a2573 1
	u_char f;
d2605 1
a2605 1
		key = (u_char)*m1;
d2671 1
a2671 1
	x_tab = (u_char (*)[X_TABSZ])alloc(sizeofN(*x_tab, X_NTABS), AEDIT);
d2925 1
a2925 1
		c = (u_char)*macroptr++;
@


1.115
log
@clean up the CHARMASK mess
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.114 2007/10/09 14:50:50 tg Exp $");
d29 1
a29 2
static void x_flush(void);
static void x_putc(int);
d45 3
d146 1
a146 7
x_flush(void)
{
	shf_flush(shl_out);
}

static void
x_putc(int c)
d442 2
a443 2
#define IS_WORDC(c)	!( ctype(c, C_LEX1) || (c) == '\'' || (c) == '"' || \
			    (c) == '`' || (c) == '=' || (c) == ':' )
d2987 1
a2987 1
				x_putc(*(*cp)++);
d5192 1
a5192 1
				x_putc(*wb++);
d5200 1
a5200 1
			x_putc(*wb++);
@


1.114
log
@revert the return type of x_e_getc() back from u_char to int
this change broke abortion on failure to read input, was not
needed for gcc warnings and is the fault of Intel’s compiler

this should fix the other busy-loop problem occuring only on
GNU/Linux so far – 10x spaetzle@@freewrt.o for pointing me to
the problem; reproduced on my work craptop
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.113 2007/09/09 20:03:32 tg Exp $");
a1050 1
#define CHARMASK	0xFF			/* 8-bit character mask */
d1052 1
a1052 1
#define X_TABSZ		(CHARMASK+1)		/* size of keydef tables etc */
d1489 1
a1489 1
		    x_tab[x_curprefix][c & CHARMASK];
d1585 1
a1585 1
	macroptr = x_atab[c >> 8][c & CHARMASK];
d2123 1
a2123 1
		f = x_tab[0][c & CHARMASK];
d2608 1
a2608 1
		key = *m1 & CHARMASK;
d2916 1
a2916 1
	unget_char = c;
d2927 6
a2932 8
	} else {
		if (macroptr) {
			c = *macroptr++;
			if (!*macroptr)
				macroptr = NULL;
		} else
			c = x_getc();
	}
d2934 1
a2934 1
	return c <= CHARMASK ? c : (c & CHARMASK);
d3038 1
a3038 1
	c &= CHARMASK;	/* strip command prefix */
@


1.113
log
@On Debian GNU/kFreeBSD, gcc version 4.2.1 (Debian 4.2.1-5):
../edit.c: In function ‘x_cf_glob’:
../edit.c:508: warning: ‘words’ may be used uninitialized in this function
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.112 2007/09/09 18:06:39 tg Exp $");
d1139 1
a1139 1
static u_char	x_e_getc(void);
d2920 1
a2920 1
static u_char
@


1.112
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.111 2007/08/18 01:20:27 tg Exp $");
d508 1
a508 1
	char **words;
@


1.111
log
@put clear-screen on ESC ^L as suggested by the AT&T ksh people in
http://www.opensolaris.org/os/community/on/flag-days/pages/2007081701/
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.31 2005/12/11 20:31:21 otto Exp $	*/
d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.40 2006/07/10 17:12:41 beck Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.110 2007/07/31 15:42:50 tg Exp $");
d328 1
d334 2
a335 1
	*wordsp = nwords ? words : NULL;
d734 1
a734 1
		if (vstrchr("\\$()[{}*&;#|<>\"'`", s[add]) ||
d1133 1
a1133 1
static char *	x_mapin(const char *);
d2508 1
a2508 1
x_mapin(const char *cp)
d2512 1
a2512 1
	op = new = str_save(cp, ATEMP);
d2581 1
d2606 1
a2606 1
	m1 = x_mapin(a1);
d2627 2
d2647 1
a2647 2
		m2 = x_mapin(a2);
		sp = str_save(m2, AEDIT);
d2653 1
a2653 1
	x_tab[prefix][key] = f | ((*m1) ? 0x80 : 0);
@


1.110
log
@make sure we don't show any junk in MKSH_CLS_STRING even if the terminal is
not standards compatible
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.109 2007/07/31 15:29:39 tg Exp $");
d1351 1
@


1.109
log
@add a new bindable command “clear-screen”, which can be bound to the ^L key
so that archite@@midnightbsd won’t have to add evil kludges to oksh again if
they switch their ksh to mksh ☺

both “clear-screen” and “error” aren’t bound; default binding for ^L stays,
as usual, “redraw” (principle of least surprise); however GNU bash converts
also might want to put “bind ^L=clear-screen” into their ~/.mkshrc.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.108 2007/07/31 10:42:14 tg Exp $");
d2252 1
@


1.108
log
@some steps towards building with tcc
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.107 2007/07/22 13:38:25 tg Exp $");
d41 1
d1152 53
a1204 52
#define XFUNC_comp_comm 2
#define XFUNC_comp_file 3
#define XFUNC_complete 4
#define XFUNC_del_back 5
#define XFUNC_del_bword 6
#define XFUNC_del_char 7
#define XFUNC_del_fword 8
#define XFUNC_del_line 9
#define XFUNC_draw_line 10
#define XFUNC_end_hist 11
#define XFUNC_end_of_text 12
#define XFUNC_enumerate 13
#define XFUNC_eot_del 14
#define XFUNC_error 15
#define XFUNC_goto_hist 16
#define XFUNC_ins_string 17
#define XFUNC_insert 18
#define XFUNC_kill 19
#define XFUNC_kill_region 20
#define XFUNC_list_comm 21
#define XFUNC_list_file 22
#define XFUNC_literal 23
#define XFUNC_meta1 24
#define XFUNC_meta2 25
#define XFUNC_meta_yank 26
#define XFUNC_mv_back 27
#define XFUNC_mv_begin 28
#define XFUNC_mv_bword 29
#define XFUNC_mv_end 30
#define XFUNC_mv_forw 31
#define XFUNC_mv_fword 32
#define XFUNC_newline 33
#define XFUNC_next_com 34
#define XFUNC_nl_next_com 35
#define XFUNC_noop 36
#define XFUNC_prev_com 37
#define XFUNC_prev_histword 38
#define XFUNC_search_char_forw 39
#define XFUNC_search_char_back 40
#define XFUNC_search_hist 41
#define XFUNC_set_mark 42
#define XFUNC_transpose 43
#define XFUNC_xchg_point_mark 44
#define XFUNC_yank 45
#define XFUNC_comp_list 46
#define XFUNC_expand 47
#define XFUNC_fold_capitalise 48
#define XFUNC_fold_lower 49
#define XFUNC_fold_upper 50
#define XFUNC_set_arg 51
#define XFUNC_comment 52
#define XFUNC_version 53
d1208 55
a1262 54
static int x_abort (int);
static int x_beg_hist (int);
static int x_comp_comm (int);
static int x_comp_file (int);
static int x_complete (int);
static int x_del_back (int);
static int x_del_bword (int);
static int x_del_char (int);
static int x_del_fword (int);
static int x_del_line (int);
static int x_draw_line (int);
static int x_end_hist (int);
static int x_end_of_text (int);
static int x_enumerate (int);
static int x_eot_del (int);
static int x_error (int);
static int x_goto_hist (int);
static int x_ins_string (int);
static int x_insert (int);
static int x_kill (int);
static int x_kill_region (int);
static int x_list_comm (int);
static int x_list_file (int);
static int x_literal (int);
static int x_meta1 (int);
static int x_meta2 (int);
static int x_meta_yank (int);
static int x_mv_back (int);
static int x_mv_begin (int);
static int x_mv_bword (int);
static int x_mv_end (int);
static int x_mv_forw (int);
static int x_mv_fword (int);
static int x_newline (int);
static int x_next_com (int);
static int x_nl_next_com (int);
static int x_noop (int);
static int x_prev_com (int);
static int x_prev_histword (int);
static int x_search_char_forw (int);
static int x_search_char_back (int);
static int x_search_hist (int);
static int x_set_mark (int);
static int x_transpose (int);
static int x_xchg_point_mark (int);
static int x_yank (int);
static int x_comp_list (int);
static int x_expand (int);
static int x_fold_capitalise (int);
static int x_fold_lower (int);
static int x_fold_upper (int);
static int x_set_arg (int);
static int x_comment (int);
static int x_version (int);
d1267 1
d1436 20
d1473 1
a1473 15
	x_col = promptlen(prompt);
	x_adj_ok = 1;
	prompt_redraw = 1;
	if (x_col > xx_cols)
		x_col %= xx_cols;
	x_displen = xx_cols - 2 - x_col;
	x_adj_done = 0;

	pprompt(prompt, 0);
	if (x_displen < 1) {
		x_col = 0;
		x_displen = xx_cols - 2;
		x_e_putc2('\n');
		prompt_redraw = 0;
	}
d2244 13
@


1.107
log
@some null/NUL
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.106 2007/07/22 13:34:48 tg Exp $");
d518 3
a520 2
	nwords = (is_command ? x_command_glob : x_file_glob)(flags,
	    buf + *startp, len, &words);
@


1.106
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.105 2007/07/01 21:10:27 tg Exp $");
d1700 1
a1700 1
	memmove(xcp, xcp + nb, xep - xcp + 1);	/* Copies the null */
d3479 1
a3479 1
 * The format of buf is the alias contents followed by a null byte followed
d3481 1
a3481 1
 * a double null.  The name of the alias is stored so recursive macros can
@


1.105
log
@Borland C++ found these
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.104 2007/06/21 16:04:46 tg Exp $");
d2795 1
a2795 1
		    (++i < nwords && x_ins(space) < 0)) {
d2841 1
a2841 1
		x_ins(space);
d4258 8
a4265 4
			shf_snprintf(es->cbuf, es->cbufsize,
			    argcnt ? "%s %d" : "%s",
			    "fc -e ${VISUAL:-${EDITOR:-vi}} --",
			    argcnt);
d4383 1
a4383 1
				if (putbuf(space, 1, 0) != 0)
d5223 1
a5223 1
		if (++i < nwords && putbuf(space, 1, 0) != 0) {
d5332 1
a5332 1
			rval = putbuf(space, 1, 0);
@


1.104
log
@rewrite some code; bug found by HP's C compiler
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.103 2007/06/15 22:00:00 tg Exp $");
d1684 1
a1684 1
	nc = i;
d1786 1
a1786 1
	int nb = 0, nc = 0;
d1794 1
a1794 1
		while (cp != xep && is_mfs(*cp)) {
d1796 1
a1796 3
			nb++;
		}
		while (cp != xep && !is_mfs(*cp)) {
a1797 2
			nb++;
		}
d2779 1
a2779 1
	int nwords = 0;
d5239 1
a5239 1
	int rval = 0;
@


1.103
log
@if invoked as /bin/sh, -sh, sh.static, whatever, activate FPOSIX
this should help inferiour operating systems like Debian… (where
some of the devs, hi waldi@@, don't consider stop() { } invalid…)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.102 2007/06/09 22:01:41 tg Exp $");
d725 1
a725 1
	size_t add, wlen;
d729 1
a729 1
	for (add = 0, wlen = len; wlen - add > 0; add++) {
d744 3
a746 3
			add = -1; /* after the increment it will go to 0 */
		}
	}
@


1.102
log
@don't use __extension__, cought by sunpro on linux
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.101 2007/06/06 23:28:13 tg Exp $");
d41 1
d43 1
d112 1
d115 1
d1098 1
a1101 1
static int	prompt_redraw;		/* 0 if newline forced after prompt */
d1110 2
d3326 1
d5394 1
@


1.101
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.100 2007/06/06 22:26:26 tg Exp $");
d761 8
a768 9
#define utf_backch(c)						\
	(!Flag(FUTFHACK) ? (c) - 1 : __extension__({		\
		u_char *utf_backch_cp = (u_char *)(c);		\
		--utf_backch_cp;				\
		while ((*utf_backch_cp >= 0x80) &&		\
		    (*utf_backch_cp < 0xC0))			\
			--utf_backch_cp;			\
		(__typeof__ (c))utf_backch_cp;			\
	}))
d770 1
a770 1
#define utf_backch(c)	(!Flag(FUTFHACK) ? (c) - 1 : \
@


1.100
log
@out of a 50-line diff which STILL didn't shut up icc, these are the actual
problems. icc's warnings are bogus:
• it says int x_getc(void); is invalid (hm well, it may be static?)
• char c, d; d = c | 0x40; -> warning because (c | 0x40) is an int
  (it apparently can't track value bounds)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.99 2007/06/05 19:48:46 tg Exp $");
d28 14
a41 15
int x_getc(void);
void x_flush(void);
void x_putc(int);
void x_puts(const u_char *);
bool x_mode(bool);
int x_do_comment(char *, int, int *);
void x_print_expansions(int, char *const *, int);
int x_cf_glob(int, const char *, int, int, int *, int *, char ***, int *);
int x_longest_prefix(int, char *const *);
int x_basename(const char *, const char *);
void x_free_words(int, char **);
int x_escape(const char *, size_t, int (*)(const char *, size_t));
int x_emacs(char *, size_t);
void x_init_emacs(void);
int x_vi(char *, size_t);
d123 1
a123 1
int
d138 1
a138 1
void
d144 1
a144 1
void
a149 7
void
x_puts(const u_char *s)
{
	while (*s != 0)
		shf_putc(*s++, shl_out);
}

d161 1
a161 1
int
d206 1
a206 1
void
d495 1
a495 1
int
d569 1
a569 1
int
d589 1
a589 1
void
d611 1
a611 1
int
d718 1
a718 1
int
d1426 1
a1426 1
int
d2636 1
a2636 1
void
d3250 1
a3250 1
bool
d3494 1
a3494 1
int
@


1.99
log
@fix for the SUNpro 8 on yofuh's E420:
cc: Sun C 5.8 Patch 121015-04 2007/01/10
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.98 2007/05/24 19:15:46 tg Exp $");
d1138 1
a1138 1
static int	x_e_getc(void);
d2897 1
a2897 1
static int
d3122 1
a3122 1
		int ch;
@


1.98
log
@fix Message-ID: <e3fded850705240816s50544d04u5c87edb905f1c123@@mail.gmail.com>
(maybe) by only emitting the >*< if we're at EOL
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.97 2007/05/22 21:13:56 tg Exp $");
d768 1
d778 13
@


1.97
log
@optimise
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.96 2007/05/22 21:01:38 tg Exp $");
d1699 1
a1699 1
		nw = (i = ((nw < i) ? nw : i)) + 1;
d1702 4
a1705 1
		x_e_putc2((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
@


1.96
log
@fix Message-ID: <e3fded850705221323w1442f15cr4375a5590acf8088@@mail.gmail.com>
(by dramsey again, you're DA MAN) by replicating some of the x_redraw() logic

Note that this is correct, a construct like the full-fledged
| x_e_putc2((xep > xlp) ? ((xbp > xbuf) ? '*' : '>') : (xbp > xbuf) ? '<' : ' ');
is not needed since if (xep > xlp) && (xbp > xbuf) – i.e. in the '*' case –
x_redraw() will be called anyway and because (xx_cols - 2 - x_col) == 0 the
code won't be triggered.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.95 2007/05/22 19:27:05 tg Exp $");
d1699 1
a1699 2
		nw = (nw < i) ? nw : i;
		i = nw;
d1703 1
a1703 2
		i = ++nw;
		while (i--)
@


1.95
log
@dramsey bug #4: regression introduced in 1004651F21443013C37 (fix for bug #3)
cf. Message-ID: <e3fded850705211623n20d2c695ke7b41d75ac439a6c@@mail.gmail.com>

this one was harder to track down, additional variables coming into the play…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.93 2007/05/21 12:24:44 tg Exp $");
a1699 2
		if (xbp == xbuf)
			++nw;
d1703 2
a1704 1
		i = nw;
@


1.94
log
@• fix the third dramsey scrolling bug for both ^D at BOL and ^W at EOL
  (I hope)
• fix another one I found: after ^D'ing, insert at BOL, the > is displayed
  one character too late
@
text
@d1700 3
a1702 1
		i = ++nw;
@


1.93
log
@unify the move-backwards redrawing bug fixes
cf. Message-ID: <Pine.BSM.4.64L.0705211156060.16459@@odem.66h.42h.de>
tested to not slow down _even_ more a 75 MHz sparc (neko.haemoglobin.org)
thanks to dramsey again for testing
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.92 2007/05/20 17:53:13 tg Exp $");
d1605 2
d1698 1
a1698 1
	if ((i = xx_cols - 2 - x_col) > 0) {
d1700 1
a1700 1
		i = nw;
@


1.92
log
@fix the latest appearance of the dramsey backwards movement bug, cf.
Message-ID: <e3fded850705200935h6ac2c9ebgbc7a9b10ac034a49@@mail.gmail.com>
and Message-ID: <Pine.BSM.4.64L.0705201659500.8619@@odem.66h.42h.de>
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.91 2007/05/13 17:51:20 tg Exp $");
d1017 4
a1020 4
struct	x_ftab {
	int		(*xf_func)(int c);
	const char	*xf_name;
	short		xf_flags;
d1024 3
a1026 3
	u_char		xdb_func;	/* XFUNC_* */
	unsigned char	xdb_tab;
	unsigned char	xdb_char;
d1492 2
a1621 1
	x_goto(xcp);
a1717 1
	x_goto(xcp);
a1724 1
	x_goto(xcp);
a1901 1
	x_goto(xcp);
d2641 1
a2641 1
		x_tab[(unsigned char)x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
d2837 1
a2837 8
	if (completed) {
		/*
		 * I don't quite get it: the x_goto(xcp) call is equivalent to
		 * x_adjust() if we are ASCII-only and "heading off screen",
		 * but putting x_adjust() here instead of x_goto(xcp) does not
		 * fix the dramsey horizontal scrolling bug. Weird.
		 */
		x_goto(xcp);
a2838 1
	}
@


1.91
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.90 2007/05/10 19:08:48 tg Exp $");
d1620 1
d1717 1
d1724 2
a1725 1
	(void)x_bword();
d1903 1
@


1.90
log
@fix the “dramsey horizontal scrolling bug” – time for you to find another ☺
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.89 2007/05/10 18:58:31 tg Exp $");
d306 1
a306 1
		internal_errorf(0, "fileglob: substitute error");
d4946 1
a4946 1
		internal_errorf(0, "grabhist: bad history array");
@


1.89
log
@const
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.88 2007/05/10 18:46:38 tg Exp $");
d2835 8
a2842 1
	if (completed)
d2844 1
@


1.88
log
@remove a redundant function
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.87 2007/03/10 18:16:26 tg Exp $");
d1102 1
a1102 1
static int	x_ins(char *);
d1582 1
a1582 1
x_ins(char *s)
@


1.87
log
@some gcc 4.1.2pre warning shutup
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.86 2007/03/10 00:36:44 tg Exp $");
a1130 1
static int	x_emacs_putbuf(const char *, size_t);
d1134 1
a1134 1
static int x_do_ins(const char *, int);
d1568 1
a1568 1
x_do_ins(const char *cp, int len)
a1606 13
/*
 * this is used for x_escape() in do_complete()
 */
static int
x_emacs_putbuf(const char *s, size_t len)
{
	int rval;

	if ((rval = x_do_ins(s, len)) != 0)
		return (rval);
	return (rval);
}

d2781 1
a2781 1
		if (x_escape(words[i], strlen(words[i]), x_emacs_putbuf) < 0 ||
d2822 1
a2822 1
		x_escape(words[0], nlen, x_emacs_putbuf);
@


1.87.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.87 2007/03/10 18:16:26 tg Exp $");
d306 1
a306 1
		internal_warningf("fileglob: substitute error");
d1102 1
a1102 1
static int	x_ins(const char *);
d1131 1
d1135 1
a1135 1
static int x_do_ins(const char *, size_t);
d1569 1
a1569 1
x_do_ins(const char *cp, size_t len)
d1583 1
a1583 1
x_ins(const char *s)
d1608 13
d2795 1
a2795 1
		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
d2836 1
a2836 1
		x_escape(words[0], nlen, x_do_ins);
d2849 1
a2849 8
	if (completed) {
		/*
		 * I don't quite get it: the x_goto(xcp) call is equivalent to
		 * x_adjust() if we are ASCII-only and "heading off screen",
		 * but putting x_adjust() here instead of x_goto(xcp) does not
		 * fix the dramsey horizontal scrolling bug. Weird.
		 */
		x_goto(xcp);
a2850 1
	}
d4952 1
a4952 1
		internal_warningf("grabhist: bad history array");
@


1.87.2.2
log
@MFC all the edit.c fixes; bump vsn
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.87.2.1 2007/05/13 19:29:33 tg Exp $");
d1017 4
a1020 4
struct x_ftab {
	int (*xf_func)(int c);
	const char *xf_name;
	short xf_flags;
d1024 3
a1026 3
	unsigned char xdb_func;	/* XFUNC_* */
	unsigned char xdb_tab;
	unsigned char xdb_char;
a1491 2
		/* ad-hoc hack for fixing the cursor position */
		x_goto(xcp);
a1602 2
	if (xlp == xep - 1)
		x_redraw(xx_cols);
d1694 3
a1696 2
	if ((i = xx_cols - 2 - x_col) > 0 || xep - xlp == 0) {
		nw = (i = ((nw < i) ? nw : i)) + 1;
d1699 2
a1700 2
		x_e_putc2((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
		while (nw--)
d1722 1
a1722 1
	x_bword();
d2639 1
a2639 1
		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
d2835 8
a2842 1
	if (completed)
d2844 1
@


1.87.2.3
log
@pull up fixes for regressions
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.87.2.2 2007/05/22 21:34:29 tg Exp $");
d1699 1
a1699 1
		nw = i = (nw < i) ? nw : i;
d1702 1
a1702 4
		if (x_col == xx_cols - 2) {
			x_e_putc2((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
			++nw;
		}
@


1.87.2.4
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.87.2.3 2007/05/26 22:31:19 tg Exp $");
d729 1
a729 1
	size_t add = 0, wlen = len;
d733 1
a733 1
	while (wlen - add > 0)
d748 3
a750 3
			add = 0;
		} else
			++add;
d1124 1
a1124 1
static u_char	x_e_getc(void);
d1673 1
a1673 1
	/* nc = i; */
d1775 1
a1775 1
	int nc = 0;
d1783 1
a1783 1
		while (cp != xep && is_mfs(*cp))
d1785 3
a1787 1
		while (cp != xep && !is_mfs(*cp))
d1789 2
d2772 1
a2772 1
	int nwords;
d2883 1
a2883 1
static u_char
d3108 1
a3108 1
		char ch;
d5231 1
a5231 1
	int rval;
@


1.86
log
@in the utf-8 mode, invalid multibytes are now handled more strongly:
• if it's in x_literal() (“quote” / ^V) mode, it's accepted like now
• if it's a mb sequence start, it's rejected with a beep
• if it's a mb continuation, the whole sequence is silently rejected

this makes command line editing when accidentally hitting, e.g. with
my mircvs://contrib/samples/dot.Xmodmap, Mode_switch-x much more ro-
bust.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.85 2007/03/10 00:23:31 tg Exp $");
d1514 1
a1514 2
			left--;
			if (!left) {
d1517 2
a1518 1
				goto x_insert_write;
a1528 1
			left = 0;
d1534 4
d1543 1
a1543 2
		} else if (c > 0x7F)
			goto invmbs;
a1547 1
 x_insert_write:
@


1.85
log
@bugfix: display UTF-8 control characters (U+0080..U+009F, i.e. width == -1)
the same as ASCII control characters (U+0001..U+001F), i.e. with a ctrl ca-
ret and its value XOR U+0040; treat their width as 2

fixes crash+cpu hog on 'meta-tab backspace'
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.84 2007/03/04 03:04:24 tg Exp $");
d1506 1
d1523 6
a1528 4
			/* flush invalid multibyte */
			str[pos] = '\0';
			while (save_arg--)
				x_ins(str);
d1540 2
a1541 1
		}
@


1.84
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.83 2007/03/04 00:13:14 tg Exp $");
d783 1
d794 2
a795 1
	return (wcxwidth(wc));
d1882 1
a1882 1
	int c = **(unsigned char **)cp;
d1888 2
a1889 1
	} else if (c < ' ' || c == 0x7f) {
d1892 1
a1892 1
		(*cp)++;
@


1.83
log
@merge the const branch +- a few
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.82 2007/02/16 17:46:42 tg Exp $");
d39 1
a39 1
int x_escape(const char *, size_t, int (*) (const char *, size_t));
d136 1
a136 3
	if (n != 1)
		return -1;
	return (int)(unsigned char)c;
d485 1
a485 1
		iscmd = p < 0 || strchr(";|&()`", buf[p]);
d522 1
a522 1
	nwords = (is_command ? x_command_glob : x_file_glob) (flags,
d562 1
a562 1
		    || (s[1] == '(' && strchr("*+?@@!", *s)))
d603 1
a603 1
		afreechk(words[i])
d673 1
a673 1
		if (!(p = strchr(sp, ':')))
d727 1
a727 1
x_escape(const char *s, size_t len, int (*putbuf_func) (const char *, size_t))
d734 2
a735 1
		if (strchr("\\$()[{}*&;#|<>\"'`", s[add]) || strchr(ifs, s[add])) {
d3360 1
a3360 1
#define char_len(c) ((c) < ' ' || (c) == 0x7F ? 2 : 1)
@


1.82
log
@* edit.c: when tabcompleting a newline to backslash+newline, this
  sequence is eaten before the command is called; cought by <TGEN>
  (Thomas E. Spanjaard) via IRC
  fix is to tabcomplete a newline to singlequote+newline+singlequote
* bump version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.81 2007/02/07 02:01:43 tg Exp $");
d605 1
a605 2
		if (words[i])
			afree(words[i], ATEMP);
@


1.81
log
@repair 'bind' builtin with no args output; damage taken in -r1.80
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.80 2007/01/15 02:14:02 tg Exp $");
d742 1
a742 1
			putbuf_func("\\", 1);
d744 2
@


1.80
log
@optimise
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.79 2007/01/15 02:11:34 tg Exp $");
d2526 5
a2530 3
	shprintf("%s%s%s = ", (prefix == 1) ? x_mapout(MKCTRL('[')) :
	    ((prefix == 2) ? x_mapout(MKCTRL('X')) : ""), x_mapout(key),
	    (f & 0x80) ? "~" : "");
@


1.79
log
@static int (which was const) -> integrated into its only use
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.78 2007/01/14 01:56:23 tg Exp $");
d2526 3
a2528 5
	if (prefix == 1)
		shprintf("%s", x_mapout(MKCTRL('[')));
	if (prefix == 2)
		shprintf("%s", x_mapout(MKCTRL('X')));
	shprintf("%s%s = ", x_mapout(key), (f & 0x80) ? "~" : "");
@


1.78
log
@okay, this didn't work out; changing window sizes when we're
actually within a (the emacs) editing mode does not work at
all, whether forced or not, only if we leave the editing mode
(at end of input); probably due to it saving stuff from e.g.
x_cols into xx_cols, etc.

-> remove SIGWINCH handling(!)
-> TIOCGWINSZ is now executed at end of every input line
-> use 'ESC #' if you direly need to change line size
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.77 2007/01/14 01:09:08 tg Exp $");
a1074 1
static int	x_prefix1 = MKCTRL('['), x_prefix2 = MKCTRL('X');
d2527 1
a2527 1
		shprintf("%s", x_mapout(x_prefix1));
d2529 1
a2529 1
		shprintf("%s", x_mapout(x_prefix2));
@


1.78.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.82 2007/02/16 17:46:42 tg Exp $");
d742 1
a742 1
			putbuf_func(s[add] == '\n' ? "'" : "\\", 1);
a743 2
			if (s[add] == '\n')
				putbuf_func("'", 1);
d1075 1
d2527 4
a2530 4
	if (prefix)
		/* prefix == 1 || prefix == 2 */
		shprintf("%s", x_mapout(prefix == 1 ?
		    MKCTRL('[') : MKCTRL('X')));
@


1.77
log
@* do *not* check the terminal size after each line processing,
  only if we got a SIGWINCH -> interactive use speed-up on the
  slower boxen (slowness courtesy of otto@@obsd)
* ^L (redraw line) now (always) checks window size; use this
  instead if required while editing the prompt; changes to the
  variables will still be propagated after the line is entered
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.76 2007/01/12 10:18:20 tg Exp $");
d44 2
a45 4
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
static void x_sigwinch(int);
static volatile sig_atomic_t got_sigwinch;
static void check_sigwinch(void);
d67 2
a68 6

#if defined(TIOCGWINSZ) && defined(SIGWINCH)
	if (setsig(&sigtraps[SIGWINCH], x_sigwinch,
	    SS_RESTORE_ORIG | SS_SHTRAP))
		sigtraps[SIGWINCH].flags |= TF_SHELL_USES;
	check_sigwinch();	/* force initial check */
a69 1

d73 1
a73 8
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
/* ARGSUSED */
static void
x_sigwinch(int sig __unused)
{
	got_sigwinch = 1;
}

d75 1
a75 1
check_sigwinch(void)
a78 1
	got_sigwinch = 0;
d116 2
a117 3
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
	if (got_sigwinch)
		check_sigwinch();
a2222 1
	check_sigwinch();
@


1.76
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.75 2007/01/12 01:49:27 tg Exp $");
d132 2
a133 1
	check_sigwinch();
d2239 1
a2241 1

@


1.75
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.74 2006/11/19 20:43:12 tg Exp $");
d1200 1
a1200 1
#define XFUNC_fold_capitalize 48
d1257 1
a1257 1
static int x_fold_capitalize (int);
d1313 1
a1313 1
	{ x_fold_capitalize,	"capitalize-word",		XF_ARG },
d1388 2
a1389 2
	{ XFUNC_fold_capitalize,	1,	  'C'	},
	{ XFUNC_fold_capitalize,	1,	  'c'	},
d3166 1
a3166 1
x_fold_capitalize(int c __unused)
@


1.74
log
@remove the "set -o sh" option (dummy anyway),
"set +o emacs-usemeta" and "set -o vi-show8" which are always on now,
since we have proper internationalisation (i.e. utf-8) support, and
assume the user either has a 'C' locale and can't enter 8-bit chars,
his terminal is 8bit-transparent, or he has a 'UTF-8' locale.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.73 2006/11/12 14:58:13 tg Exp $");
d83 1
a83 1
x_sigwinch(int sig __attribute__((unused)))
d283 1
a283 2
x_file_glob(int flags __attribute__((unused)), const char *str,
    int slen, char ***wordsp)
d1631 1
a1631 1
x_del_back(int c __attribute__((unused)))
d1647 1
a1647 1
x_del_char(int c __attribute__((unused)))
d1736 1
a1736 1
x_del_bword(int c __attribute__((unused)))
d1743 1
a1743 1
x_mv_bword(int c __attribute__((unused)))
d1750 1
a1750 1
x_mv_fword(int c __attribute__((unused)))
d1757 1
a1757 1
x_del_fword(int c __attribute__((unused)))
d1911 1
a1911 1
x_mv_back(int c __attribute__((unused)))
d1926 1
a1926 1
x_mv_forw(int c __attribute__((unused)))
d1945 1
a1945 1
x_search_char_forw(int c __attribute__((unused)))
d1967 1
a1967 1
x_search_char_back(int c __attribute__((unused)))
d2003 1
a2003 1
x_newline(int c __attribute__((unused)))
d2013 1
a2013 1
x_end_of_text(int c __attribute__((unused)))
d2023 1
a2023 1
x_beg_hist(int c __attribute__((unused)))
d2030 1
a2030 1
x_end_hist(int c __attribute__((unused)))
d2037 1
a2037 1
x_prev_com(int c __attribute__((unused)))
d2044 1
a2044 1
x_next_com(int c __attribute__((unused)))
d2055 1
a2055 1
x_goto_hist(int c __attribute__((unused)))
d2204 1
a2204 1
x_del_line(int c __attribute__((unused)))
d2222 1
a2222 1
x_mv_end(int c __attribute__((unused)))
d2229 1
a2229 1
x_mv_begin(int c __attribute__((unused)))
d2236 1
a2236 1
x_draw_line(int c __attribute__((unused)))
d2316 1
a2316 1
x_transpose(int c __attribute__((unused)))
d2380 1
a2380 1
x_literal(int c __attribute__((unused)))
d2387 1
a2387 1
x_meta1(int c __attribute__((unused)))
d2394 1
a2394 1
x_meta2(int c __attribute__((unused)))
d2401 1
a2401 1
x_kill(int c __attribute__((unused)))
d2431 1
a2431 1
x_yank(int c __attribute__((unused)))
d2449 1
a2449 1
x_meta_yank(int c __attribute__((unused)))
d2473 1
a2473 1
x_abort(int c __attribute__((unused)))
d2483 1
a2483 1
x_error(int c __attribute__((unused)))
d2683 1
a2683 1
x_set_mark(int c __attribute__((unused)))
d2690 1
a2690 1
x_kill_region(int c __attribute__((unused)))
d2713 1
a2713 1
x_xchg_point_mark(int c __attribute__((unused)))
d2728 1
a2728 1
x_noop(int c __attribute__((unused)))
d2737 1
a2737 1
x_comp_comm(int c __attribute__((unused)))
d2744 1
a2744 1
x_list_comm(int c __attribute__((unused)))
d2751 1
a2751 1
x_complete(int c __attribute__((unused)))
d2758 1
a2758 1
x_enumerate(int c __attribute__((unused)))
d2765 1
a2765 1
x_comp_file(int c __attribute__((unused)))
d2772 1
a2772 1
x_list_file(int c __attribute__((unused)))
d2779 1
a2779 1
x_comp_list(int c __attribute__((unused)))
d2786 1
a2786 1
x_expand(int c __attribute__((unused)))
d3038 1
a3038 1
x_comment(int c __attribute__((unused)))
d3058 1
a3058 1
x_version(int c __attribute__((unused)))
d3104 1
a3104 1
x_prev_histword(int c __attribute__((unused)))
d3152 1
a3152 1
x_fold_upper(int c __attribute__((unused)))
d3159 1
a3159 1
x_fold_lower(int c __attribute__((unused)))
d3166 1
a3166 1
x_fold_capitalize(int c __attribute__((unused)))
d5351 1
a5351 1
print_expansions(struct edstate *est, int cmd __attribute__((unused)))
@


1.73
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.72 2006/11/10 07:52:01 tg Exp $");
a1024 3
#define	META(x)		((x) & 0x7f)
#define	ISMETA(x)	(!Flag(FUTFHACK) && Flag(FEMACSUSEMETA) && ((x) & 0x80))

a1479 4
		if (ISMETA(c)) {
			c = META(c);
			x_curprefix = 1;
		}
a2669 2

	Flag(FEMACSUSEMETA) = 0;
d3378 1
a3378 1
static int	char_len(int);
a3751 7
				if ((ch & 0x80) && Flag(FVISHOW8)) {
					if (es->linelen + 2 > es->cbufsize)
						vi_error();
					es->cbuf[es->linelen++] = 'M';
					es->cbuf[es->linelen++] = '-';
					ch &= 0x7f;
				}
d5099 1
a5099 1
		if ((ch = es->cbuf[cur]) == '\t') {
d5103 3
a5105 3
		} else {
			if ((ch & 0x80) && Flag(FVISHOW8)) {
				*twb1++ = 'M';
d5107 1
a5107 14
					*twb1++ = '-';
					col++;
				}
				ch &= 0x7f;
			}
			if (col < winwidth) {
				if (ch < ' ' || ch == 0x7f) {
					*twb1++ = '^';
					if (++col < winwidth) {
						*twb1++ = ch ^ '@@';
						col++;
					}
				} else {
					*twb1++ = ch;
d5110 3
a5371 15
/* How long is char when displayed (not counting tabs) */
static int
char_len(int c)
{
	int len = 1;

	if ((c & 0x80) && Flag(FVISHOW8)) {
		len += 2;
		c &= 0x7f;
	}
	if (c < ' ' || c == 0x7f)
		len++;
	return len;
}

a5375 4
	if (Flag(FVISHOW8) && (c & 0x80)) {
		x_puts((const u_char *)"M-");
		c &= 0x7f;
	}
@


1.72
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.71 2006/11/10 07:18:56 tg Exp $");
d370 2
a371 2
	const struct path_order_info *a = (const struct path_order_info *) aa;
	const struct path_order_info *b = (const struct path_order_info *) bb;
d5418 1
a5418 1
		x_puts((u_char *)"M-");
@


1.71
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.70 2006/11/10 06:53:25 tg Exp $");
d1053 1
a1053 2
#define	is_mfs(c)	(!(ksh_isdigit(c) || ksh_islower(c) || \
			    ksh_isupper(c) || (c) == '_' || (c) == '$'))
a3344 1
#define	is_wordch(c)	(letnum(c))
d4842 2
a4843 2
		if (is_wordch(es->cbuf[ncursor]))
			while (is_wordch(es->cbuf[ncursor]) &&
d4847 1
a4847 1
			while (!is_wordch(es->cbuf[ncursor]) &&
d4868 1
a4868 1
			if (is_wordch(es->cbuf[ncursor]))
d4870 1
a4870 1
				    is_wordch(es->cbuf[ncursor]))
d4874 1
a4874 1
				    !is_wordch(es->cbuf[ncursor]) &&
d4894 1
a4894 1
			if (is_wordch(es->cbuf[ncursor]))
d4896 1
a4896 1
				    is_wordch(es->cbuf[ncursor]))
d4900 1
a4900 1
				    !is_wordch(es->cbuf[ncursor]) &&
@


1.70
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.69 2006/11/10 06:45:27 tg Exp $");
d500 1
a500 1
		for (p = start - 1; p >= 0 && isspace((unsigned char)buf[p]);
d1052 3
a1054 2
#define	is_mfs(c)	(!(isalnum((unsigned char)(c)) || (c) == '_' || \
			    (c) == '$'))	/* Separator for motion */
d3213 1
a3213 1
				*cp = _tolower((unsigned char)*cp);
d3215 1
a3215 1
				*cp = _toupper((unsigned char)*cp);
d3223 1
a3223 1
				*cp = _toupper((unsigned char)*cp);
d3225 1
a3225 1
				*cp = _tolower((unsigned char)*cp);
d3748 1
a3748 1
			while (n > 0 && isspace((unsigned char)locpat[n - 1]))
d3750 1
a3750 1
			while (n > 0 && !isspace((unsigned char)locpat[n - 1]))
d4120 2
a4121 2
				    !isspace((unsigned char)(es->cbuf[es->cursor]))) {
					while (isspace((unsigned char)(es->cbuf[--ncursor])))
d4372 1
a4372 1
#define issp(c)		(isspace((unsigned char)(c)) || (c) == '\n')
d4429 1
a4429 1
					if (ksh_islower((unsigned char)*p)) {
d4432 2
a4433 2
						*p = _toupper((unsigned char)*p);
					} else if (ksh_isupper((unsigned char)*p)) {
d4436 1
a4436 1
						*p = _tolower((unsigned char)*p);
d4581 1
a4581 1
		    isspace((unsigned char)(es->cbuf[ncursor])))
d4848 1
a4848 1
		else if (!isspace((unsigned char)(es->cbuf[ncursor])))
d4850 1
a4850 1
			    !isspace((unsigned char)(es->cbuf[ncursor])) &&
d4853 1
a4853 1
		while (isspace((unsigned char)(es->cbuf[ncursor])) &&
d4867 1
a4867 1
		while (--ncursor > 0 && isspace((unsigned char)(es->cbuf[ncursor])))
d4877 1
a4877 1
				    !isspace((unsigned char)(es->cbuf[ncursor])))
d4893 1
a4893 1
		    isspace((unsigned char)(es->cbuf[ncursor])))
d4903 1
a4903 1
				    !isspace((unsigned char)(es->cbuf[ncursor])))
d4918 1
a4918 1
		while (!isspace((unsigned char)(es->cbuf[ncursor])) &&
d4921 1
a4921 1
		while (isspace((unsigned char)(es->cbuf[ncursor])) &&
d4936 1
a4936 1
		    isspace((unsigned char)(es->cbuf[ncursor])))
d4939 1
a4939 1
		    !isspace((unsigned char)(es->cbuf[ncursor])))
d4954 1
a4954 1
		    isspace((unsigned char)(es->cbuf[ncursor])))
d4958 1
a4958 1
			    !isspace((unsigned char)(es->cbuf[ncursor])))
@


1.69
log
@use tolower_() and toupper_() macros (if not available, our quick 'C' ones)
76t 8d 2i
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.68 2006/11/10 06:40:04 tg Exp $");
d3032 1
a3032 1
	for (; c >= 0 && isdigit((unsigned char)c); c = x_e_getc(), first = 0)
d3211 4
a3214 7
			if (c == 'L') {		/* lowercase */
				if (isupper((unsigned char)*cp))
					*cp = _tolower((unsigned char)*cp);
			} else {		/* uppercase, capitalise */
				if (islower((unsigned char)*cp))
					*cp = _toupper((unsigned char)*cp);
			}
d3221 4
a3224 7
			if (c == 'U') {		/* uppercase */
				if (islower((unsigned char)*cp))
					*cp = _toupper((unsigned char)*cp);
			} else {		/* lowercase, capitalise */
				if (isupper((unsigned char)*cp))
					*cp = _tolower((unsigned char)*cp);
			}
d3658 1
a3658 1
		if (isdigit((unsigned char)ch))
d3684 1
a3684 1
		if (isdigit((unsigned char)ch))
d4428 1
a4428 1
					if (islower((unsigned char)*p)) {
d4432 1
a4432 1
					} else if (isupper((unsigned char)*p)) {
@


1.68
log
@kill two others, saves 55t 8d 2i
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.67 2006/11/10 04:31:04 tg Exp $");
d3186 1
a3186 1
 *      to UPPER case, lower case or Capitalize words.
d3213 2
a3214 2
					*cp = tolower((unsigned char)*cp);
			} else {		/* uppercase, capitalize */
d3216 1
a3216 1
					*cp = toupper((unsigned char)*cp);
d3226 2
a3227 2
					*cp = toupper((unsigned char)*cp);
			} else {		/* lowercase, capitalize */
d3229 1
a3229 1
					*cp = tolower((unsigned char)*cp);
d4437 1
a4437 1
						*p = toupper((unsigned char)*p);
d4441 1
a4441 1
						*p = tolower((unsigned char)*p);
@


1.67
log
@simplify. and, a few byte compares are cheaper than a structure
copy and a structure compare
gain: 103t 4d 1i
loss: had to move some code even though no diff (cvs issue)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.66 2006/11/10 03:23:48 tg Exp $");
d3073 1
a3073 1
	char *v = strdup(KSH_VERSION);
d3095 1
a3095 1
	free(v);
@


1.66
log
@use qsort(3) instead of rolling our own
saves 284 in .text, no added import since we already use qsort(3) once
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.65 2006/11/10 01:24:38 tg Exp $");
a41 1
void x_emacs_keys(X_chars *);
a174 63
bool
x_mode(bool onoff)
{
	static bool x_cur_mode;
	bool prev;

	if (x_cur_mode == onoff)
		return x_cur_mode;
	prev = x_cur_mode;
	x_cur_mode = onoff;

	if (onoff) {
		struct termios cb;
		X_chars oldchars;

		oldchars = edchars;
		cb = tty_state;

		edchars.erase = cb.c_cc[VERASE];
		edchars.kill = cb.c_cc[VKILL];
		edchars.intr = cb.c_cc[VINTR];
		edchars.quit = cb.c_cc[VQUIT];
		edchars.eof = cb.c_cc[VEOF];
#ifdef VWERASE
		edchars.werase = cb.c_cc[VWERASE];
#endif
		cb.c_iflag &= ~(INLCR | ICRNL);
		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
#ifdef VLNEXT
		/* osf/1 processes lnext when ~icanon */
		cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
#endif
		/* sunos 4.1.x & osf/1 processes discard(flush) when ~icanon */
#ifdef VDISCARD
		cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
#endif
		cb.c_cc[VTIME] = 0;
		cb.c_cc[VMIN] = 1;

		tcsetattr(tty_fd, TCSADRAIN, &cb);

		/* Convert unset values to internal 'unset' value */
		if (edchars.erase == _POSIX_VDISABLE)
			edchars.erase = -1;
		if (edchars.kill == _POSIX_VDISABLE)
			edchars.kill = -1;
		if (edchars.intr == _POSIX_VDISABLE)
			edchars.intr = -1;
		if (edchars.quit == _POSIX_VDISABLE)
			edchars.quit = -1;
		if (edchars.eof == _POSIX_VDISABLE)
			edchars.eof = -1;
		if (edchars.werase == _POSIX_VDISABLE)
			edchars.werase = -1;
		if (memcmp(&edchars, &oldchars, sizeof(edchars)) != 0) {
			x_emacs_keys(&edchars);
		}
	} else
		tcsetattr(tty_fd, TCSADRAIN, &tty_state);

	return prev;
}

d2644 1
a2644 1
	/* Track what the user has bound so x_emacs_keys() won't toast things */
a2691 17
void
x_emacs_keys(X_chars *ec)
{
	if (ec->erase >= 0) {
		bind_if_not_bound(0, ec->erase, XFUNC_del_back);
		bind_if_not_bound(1, ec->erase, XFUNC_del_bword);
	}
	if (ec->kill >= 0)
		bind_if_not_bound(0, ec->kill, XFUNC_del_line);
	if (ec->werase >= 0)
		bind_if_not_bound(0, ec->werase, XFUNC_del_bword);
	if (ec->intr >= 0)
		bind_if_not_bound(0, ec->intr, XFUNC_abort);
	if (ec->quit >= 0)
		bind_if_not_bound(0, ec->quit, XFUNC_noop);
}

d3277 71
@


1.65
log
@use NELEM
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.64 2006/11/10 01:13:50 tg Exp $");
d511 1
a511 2
		qsortp(XPptrv(w), (size_t)nwords, xstrcmp);

@


1.64
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.63 2006/11/09 22:38:31 tg Exp $");
d973 1
a973 1
	size_t min = 0, mid, max = sizeof (comb) / sizeof (struct cbset) - 1;
@


1.63
log
@save 464 text with restructuring
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.62 2006/11/09 21:20:49 tg Exp $");
a58 22
#if 0
static void D(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
static void
D(const char *fmt, ...)
{
	static FILE *_Dfp = NULL;
	va_list ap;

	if (_Dfp == NULL) {
		if ((_Dfp = fopen("/tmp/mksh.dbg", "ab+")) == NULL)
			abort();
		fprintf(_Dfp, "\n\nOpening from %ld\n", (long)getpid());
	}
	va_start(ap, fmt);
	vfprintf(_Dfp, fmt, ap);
	fflush(_Dfp);
}
#else
#define D(x)	/* nothing */
#endif

@


1.62
log
@make a few functions static that should be, and optimise a little
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.61 2006/11/09 15:02:30 tg Exp $");
a945 54
struct wcxwidth_interval {
	unsigned first;
	unsigned last;
};

/* auxiliary function for binary search in interval table */
static inline int wcxwidth_bisearch(unsigned, const struct wcxwidth_interval *, size_t);

/* sorted list of non-overlapping intervals of non-spacing characters */
/* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
static const struct wcxwidth_interval wcxwidth_combining[] = {
	{ 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
	{ 0x0591, 0x05B9 }, { 0x05BB, 0x05BD }, { 0x05BF, 0x05BF },
	{ 0x05C1, 0x05C2 }, { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 },
	{ 0x0600, 0x0603 }, { 0x0610, 0x0615 }, { 0x064B, 0x065E },
	{ 0x0670, 0x0670 }, { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 },
	{ 0x06EA, 0x06ED }, { 0x070F, 0x070F }, { 0x0711, 0x0711 },
	{ 0x0730, 0x074A }, { 0x07A6, 0x07B0 }, { 0x0901, 0x0902 },
	{ 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
	{ 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
	{ 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
	{ 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
	{ 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
	{ 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
	{ 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
	{ 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
	{ 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
	{ 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
	{ 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
	{ 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
	{ 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
	{ 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D }, { 0x0DCA, 0x0DCA },
	{ 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
	{ 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
	{ 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
	{ 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
	{ 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
	{ 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 }, { 0x0F99, 0x0FBC },
	{ 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1032 },
	{ 0x1036, 0x1037 }, { 0x1039, 0x1039 }, { 0x1058, 0x1059 },
	{ 0x1160, 0x11FF }, { 0x135F, 0x135F }, { 0x1712, 0x1714 },
	{ 0x1732, 0x1734 }, { 0x1752, 0x1753 }, { 0x1772, 0x1773 },
	{ 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
	{ 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD }, { 0x180B, 0x180D },
	{ 0x18A9, 0x18A9 }, { 0x1920, 0x1922 }, { 0x1927, 0x1928 },
	{ 0x1932, 0x1932 }, { 0x1939, 0x193B }, { 0x1A17, 0x1A18 },
	{ 0x1DC0, 0x1DC3 }, { 0x200B, 0x200F }, { 0x202A, 0x202E },
	{ 0x2060, 0x2063 }, { 0x206A, 0x206F }, { 0x20D0, 0x20EB },
	{ 0x302A, 0x302F }, { 0x3099, 0x309A }, { 0xA806, 0xA806 },
	{ 0xA80B, 0xA80B }, { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E },
	{ 0xFE00, 0xFE0F }, { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF },
	{ 0xFFF9, 0xFFFB }
};

d947 1
a947 1
wcxwidth_bisearch(unsigned ucs, const struct wcxwidth_interval *table, size_t max)
d949 47
a995 1
	size_t min = 0, mid;
d997 6
a1002 1
	if (ucs >= table[0].first && ucs <= table[max].last) {
d1005 1
a1005 1
			if (ucs > table[mid].last)
d1007 1
a1007 1
			else if (ucs < table[mid].first)
d1010 1
a1010 1
				return (1);
a1011 16
	}

	return (0);
}

static int
wcxwidth(unsigned c)
{
	/* test for 8-bit control characters */
	if (c < 32 || (c >= 0x7f && c < 0xa0))
		return (c ? -1 : 0);

	/* binary search in table of non-spacing characters */
	if (wcxwidth_bisearch(c, wcxwidth_combining,
	    sizeof (wcxwidth_combining) / sizeof (struct wcxwidth_interval) - 1))
		return (0);
a1013 1

@


1.61
log
@get rid of the need of strlcat() altogether (only one use was left)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.60 2006/11/09 00:39:27 tg Exp $");
d866 2
a867 1
char *utf_getcpfromcols(char *, int);
d884 1
a884 1
	size_t len = (size_t)-1;
d887 2
a888 4
	if (Flag(FUTFHACK) && *(const unsigned char *)src > 0x7F)
		len = mbxtowc(&wc, src);

	if (len == (size_t)-1) {
d899 1
a899 1
void
d923 1
a923 1
char *
d1020 1
a1020 1
int
d1049 1
a1049 1
size_t
@


1.60
log
@add the new function utf_ptradj() which does the same as utf_widthadj()
except it doesn't return a value and is much cheaper (no internal con-
version to UCS-2, just range checking on the multibytes)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.59 2006/11/09 00:28:36 tg Exp $");
d1181 7
a1187 7
static char   *xbuf;		/* beg input buffer */
static char   *xend;		/* end input buffer */
static char    *xcp;		/* current position */
static char    *xep;		/* current end */
static char    *xbp;		/* start of visible portion of input buffer */
static char    *xlp;		/* last char visible on screen */
static int	x_adj_ok;
d1202 8
a1209 8
static	int	x_prefix1 = MKCTRL('['), x_prefix2 = MKCTRL('X');
static	char   **x_histp;	/* history position */
static	int	x_nextcmd;	/* for newline-and-next */
static	char	*xmp;		/* mark pointer */
static	u_char	x_last_command;
static	u_char	(*x_tab)[X_TABSZ];	/* key definition */
static	char    *(*x_atab)[X_TABSZ];	/* macro definitions */
static	unsigned char	x_bound[(X_TABSZ * X_NTABS + 7) / 8];
d1211 4
a1214 4
static	char    *killstack[KILLSIZE];
static	int	killsp, killtp;
static	int	x_curprefix;
static	char    *macroptr;
d1228 2
a1229 2
static int      x_ins(char *);
static void     x_delete(int, int);
d1232 1
a1232 1
static void     x_goto(char *);
d1243 4
a1246 3
static void     x_push(int);
static char *   x_mapin(const char *);
static char *   x_mapout(int);
d2630 2
a2631 2
static char *
x_mapout(int c)
d2633 1
a2633 2
	static char buf[8];
	char *p = buf;
d2641 11
a2651 1
	return buf;
d2716 1
a2716 1
		char msg[256] = "bind: key sequence '";
d2718 3
a2720 2
		while (*c)
			strlcat(msg, x_mapout(*c++), sizeof (msg));
@


1.59
log
@fix another warning

now builds on MirOS, DragonFly, NetBSD, Debian stale (i386), Solaris 8,
Debian testing (s390x) - Solaris /bin/sh, bash, ksh93, mksh
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.58 2006/11/09 00:01:36 tg Exp $");
d900 24
d1769 1
a1769 1
		utf_widthadj(cp, (const char **)&cp2);
d1900 1
a1900 1
		utf_widthadj(cp, (const char **)&cp);
d1925 1
a1925 1
		utf_widthadj(cp2, (const char **)&cp2);
d2050 1
a2050 1
		utf_widthadj(cp, (const char **)&cp2);
@


1.58
log
@don't use __predict_false() here either
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.57 2006/11/06 19:57:19 tg Exp $");
d872 1
a872 1
		/*const*/ unsigned char *utf_backch_cp = (c);	\
@


1.57
log
@fix backward deletion off-by-one in non-border case
take #if 0'd back debugging code for a while, until
the next release comes out… you never know…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.55 2006/11/05 21:00:08 tg Exp $");
d1095 1
a1095 1
	while (__predict_false(count)) {
@


1.56
log
@remove debugging, simplify
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.54 2006/11/05 19:56:20 tg Exp $");
d59 22
d1730 1
a1730 1
	while (i++ < x_arg) {
d1732 1
a1732 3
		if (xcp == xbuf)
			break;
	}
@


1.55
log
@fix that inherited pdksh buglet as well... the xlp wasn't invalidated once…
@
text
@a58 22
#if 1
static void D(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)));
static void
D(const char *fmt, ...)
{
	static FILE *_Dfp = NULL;
	va_list ap;

	if (_Dfp == NULL) {
		if ((_Dfp = fopen("/tmp/mksh.dbg", "ab+")) == NULL)
			abort();
		fprintf(_Dfp, "\n\nOpening from %ld\n", (long)getpid());
	}
	va_start(ap, fmt);
	vfprintf(_Dfp, fmt, ap);
	fflush(_Dfp);
}
#else
#define D(x)	/* nothing */
#endif

a1948 1
	D(" x_zots:last=%02X,prev=%02X,xlp=%02X,col=%d", *(unsigned char *)str, *(unsigned char *)(str-1), *(unsigned char *)xlp, x_col);
a2348 1
	D("\nx_redraw lim=%d", limit);
d2360 4
a2363 6
		D(" x_col=%d,i=%d ", x_col, i);
		for (j = 0; j < i && x_col < (xx_cols - 2); j++) {
			x_e_putc2(' ');
			D(" x_col=%d,j=%d ", x_col, j);
		}
		while (x_col < (xx_cols - 2)) {
a2365 1
			D(" x_col=%d,SPC,j=%d ", x_col, j);
a3333 1
		D("\nx_lastcp(%d) ", x_displen);
d3337 1
a3337 3
			if ((i + j) > x_displen) {
				if (i > 94)
					D("%d.>.%02X%02X%02X", j, *((unsigned char *)xlp+0), *((unsigned char *)xlp+1), *((unsigned char *)xlp+2));
a3338 3
			}
			if (i > 94)
				D("%d[", j);
a3339 5
			if (i > 94) {
				while (xlp < xlp2)
					D("%02X", *(unsigned char *)xlp++);
				D("]=%d ", i);
			}
a3343 1
	D(" <lastcp:xlp=%02X>", *(unsigned char *)xlp);
@


1.54
log
@nuke some of the dbg
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.53 2006/11/05 19:48:58 tg Exp $");
d59 1
a59 1
#if 0
d1803 1
d1971 1
d2372 1
d2381 1
a2381 1
				i -= utf_widthadj(cpl, (const char **)&cpl);
d2384 6
a2389 1
		for (j = 0; j < i && x_col < (xx_cols - 2); j++)
d2391 3
d3361 1
d3365 3
a3367 1
			if ((i + j) > x_displen)
d3369 3
d3373 5
d3382 1
@


1.53
log
@fix another cursor positioning glitch (cause for \b at x_col == 0)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.52 2006/11/05 19:35:52 tg Exp $");
d59 1
a59 1
#if 1
a1606 1
	D("{%d}", left);
a1610 1
		D("->0 ");
a1619 1
				D("%02X]", c);
a1623 1
			D("%02X|", c);
a1637 1
			D("[%02X|", c);
d1643 1
a1643 3
		D("<%02X>", c);
	} else
		D("|%02X}", c);
a1687 1
	D(" x_ins(%s) ", s);
d1699 3
a1701 3
		D("H xlp=%td xcp=%td ", xlp-xbuf, xcp-xbuf); /* no */
		for (cp = xlp; cp > xcp; ) {
			D(":");
a1702 1
		}
a1703 1
	D("I");
a1910 7
	D("A");
	if (cp < xbuf)
		D(" cp < xbuf ");
	D("A1");
	if (cp > xep)
		D(" cp > xep ");
	D("A2 xbp=%td xcp=%td tgp=%td ", xbp-xbuf, xcp-xbuf, cp-xbuf);
d1912 1
a1912 1
		while ((cp > xbuf) && ((*cp & 0xC0) == 0x80)) {
a1913 2
			D("A2a xbp=%td xcp=%td tgp=%td ", xbp-xbuf, xcp-xbuf, cp-xbuf);
		}
a1914 1
		D("A3");
a1917 1
		D("A3a");
d1919 1
a1919 3
		D("A4");
		while (cp < xcp) {
			D("A4a %td %td ", cp-xbuf, xcp-xbuf);
a1920 1
		}
d1922 1
a1922 3
		D("A5");
		while (cp > xcp) {
			D("A5a");
a1923 1
		}
a1924 1
	D("B");
a1932 1
	D("M");
a1940 1
	D("C");
a1942 1
	D("D");
a1966 1
	D("E");
d1968 1
a1968 9
	D("F");
	if (!*str)
		D("-");
	if (adj != x_adj_done)
		D("%d!%d", adj, x_adj_done);
	if (str >= xlp)
		D(" str=%td xlp=%td ", str-xbuf, xlp-xbuf);
	while (*str && str < xlp && adj == x_adj_done) {
		D("'");
a1969 2
	}
	D("G");
a2170 1
	D("J");
a2171 1
		D("K %d ", oldsize);
a2173 1
	D("L");
a2174 1
	D("M");
a2392 1
		D("N");
a2975 1
	D(" x_adjust ");
a2985 1
	D("xbp=%td xcp=%td ", xbp-xbuf, xcp-xbuf);
d3023 1
a3023 3
	if (!x_col && (c == '\b'))
		D("O2 ");
	if ((x_col < xx_cols) && (x_col || (c != '\b'))) {
a3052 1
	D("\nx_e_putc:col=%d(%d) ", x_col, xx_cols - 2);
d3064 1
a3064 3
	if (!x_col && (c == '\b'))
		D("O3 ");
	if ((x_col < xx_cols) && (x_col || (c != '\b'))) {
a3088 1
	D("\nx_e_putc:col=%d(%d) ", x_col, xx_cols - 2);
@


1.52
log
@* catch limit off in x_redraw (bytes vs chars vs curpos)
  XXX should probably be screenpos, might need to use x_size* here
  XXX this seems to be the tab bug I noticed which we inherited from obsd
* catch backspace if x_col == 0 (XXX better)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.51 2006/11/05 19:15:15 tg Exp $");
d1927 6
a1932 1
	D("A2");
d1961 1
d2439 1
d3072 2
d3116 2
@


1.51
log
@fix issue with line splits inmidst of multibyte characters
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.50 2006/11/05 19:12:41 tg Exp $");
d2207 3
a2209 1
	if (xep <= x_lastcp())
d2211 2
d2214 1
d2413 7
a2419 2
		else
			i = limit - (xlp - xbp);
d3065 1
a3065 1
	if (x_col < xx_cols) {
d3107 1
a3107 1
	if (x_col < xx_cols) {
@


1.50
log
@track down an off-by-one and a segfault
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.49 2006/11/05 17:54:46 tg Exp $");
a3005 2
//	int i;

d3011 5
a3015 7
/*	xbp = xcp;
	for (i = 0; i < (x_displen / 2); ++i)
		xbp = utf_backch(xbp);
	if (xbp < xbuf)
		xbp = xbuf;*/
        if ((xbp = xcp - (x_displen / 2)) < xbuf)
                xbp = xbuf;
@


1.49
log
@multibyte search-character-{for,back}ward
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.48 2006/11/05 17:34:39 tg Exp $");
d866 1
d900 10
d1695 1
d1707 3
a1709 2
		D("H"); /* no */
		for (cp = xlp; cp > xcp; )
d1711 1
d1922 8
a1929 1
	if (cp < xbp || cp >= (xbp + x_displen)) {
d1933 1
d1935 3
a1937 1
		while (cp < xcp)
d1939 1
d1941 3
a1943 1
		while (cp > xcp)
d1945 1
d1995 8
a2002 1
	while (*str && str < xlp && adj == x_adj_done)
d2004 1
d3006 3
d3013 7
a3019 2
	if ((xbp = xcp - (x_displen / 2)) < xbuf)
		xbp = xbuf;
d3021 1
d3089 1
d3126 1
d3391 1
a3391 1
			if ((i + j) >= x_displen)
@


1.48
log
@fix deleting AND moving left
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.47 2006/11/05 17:24:00 tg Exp $");
d865 1
d1485 26
d2020 1
a2020 1
	int nleft = xep - xcp;
d2022 1
a2022 1
	if (!nleft) {
d2026 7
a2032 3
	if (x_arg > nleft)
		x_arg = nleft;
	x_goto(xcp + x_arg);
d2037 1
a2037 1
x_search_char_forw(int c)
d2040 1
d2043 4
a2046 1
	c = x_e_getc();
d2048 2
a2049 3
		if (c < 0 ||
		    ((cp = (cp == xep) ? NULL : strchr(cp + 1, c)) == NULL &&
		    (cp = strchr(xbuf, c)) == NULL)) {
d2059 1
a2059 1
x_search_char_back(int c)
d2062 2
d2065 4
a2068 1
	c = x_e_getc();
d2073 1
a2073 1
			if (c < 0 || p == cp) {
d2077 11
a2087 1
			if (*p == c)
@


1.47
log
@delete and move word fore- and backwards by the right amount, too
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.46 2006/11/05 17:11:25 tg Exp $");
d1693 1
a1693 2
	int i = x_arg;
	char *cp = xcp;
d1695 5
a1699 6
	while (i--) {
		if (xcp == xbuf) {
			x_goto(cp);
			x_e_putc2(7);
			return (KSTD);
		}
d1701 2
d1704 1
a1704 1
	x_delete(x_arg, false);
d1978 1
a1978 3
	int col = xcp - xbuf;

	if (col == 0) {
d1982 5
a1986 3
	if (x_arg > col)
		x_arg = col;
	x_goto(xcp - x_arg);
@


1.46
log
@eliminate segfault
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.45 2006/11/05 16:53:34 tg Exp $");
d1195 1
a1195 1
static int	x_fword(void);
d1813 1
a1813 1
	x_goto(xcp + x_fword());
d1820 1
a1820 1
	x_delete(x_fword(), true);
d1827 1
a1827 1
	int nc = 0;
d1837 1
a1837 1
			nc++;
d1841 1
a1841 1
			nc++;
d1845 2
d1851 1
a1851 1
x_fword(void)
d1853 2
a1854 2
	int nc = 0;
	char *cp = xcp;
d1863 1
a1863 1
			nc++;
d1867 1
a1867 1
			nc++;
d1870 4
@


1.45
log
@fix deleting forward with count
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.44 2006/11/05 16:48:17 tg Exp $");
d1743 10
a1752 2
	for (i = 0; i < nc; ++i)
		nw += x_size2(cp, &cp);
d1754 1
@


1.44
log
@if we can't delete, keep position, as before
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.43 2006/11/05 16:43:57 tg Exp $");
d1711 11
a1721 1
	int nleft = xep - xcp;
d1723 1
a1723 1
	if (!nleft) {
d1727 1
a1727 3
	if (x_arg > nleft)
		x_arg = nleft;
	x_delete(x_arg, false);
@


1.43
log
@backspace counting
rest'll follow
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.42 2006/11/05 16:41:02 tg Exp $");
d1694 1
d1698 1
d1700 1
a1700 1
			return KSTD;
@


1.42
log
@make backspacing (and moving forward and backward) work perfectly
(in Emacs mode, of course) - for count=1 only though (yet)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.41 2006/11/05 16:10:10 tg Exp $");
d1693 1
a1693 1
	int col = xcp - xbuf;
d1695 6
a1700 3
	if (col == 0) {
		x_e_putc2(7);
		return KSTD;
a1701 3
	if (x_arg > col)
		x_arg = col;
	x_goto(xcp - x_arg);
@


1.41
log
@multibyte insertion, the Plan 9 way
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.40 2006/11/05 15:36:09 tg Exp $");
d1725 1
a1725 1
	int i, j;
d1730 7
d1738 1
a1738 1
		if (xcp + nc > xmp)
d1741 1
a1741 1
			xmp -= nc;
d1747 1
a1747 1
		x_push(nc);
d1749 1
a1749 1
	xep -= nc;
d1751 1
a1751 6
	j = 0;
	i = nc;
	while (i--) {
		j += x_size2(cp, &cp);
	}
	memmove(xcp, xcp + nc, xep - xcp + 1);	/* Copies the null */
d1760 2
a1761 2
		j = (j < i) ? j : i;
		i = j;
d1764 1
a1764 1
		i = j;
@


1.40
log
@utf hack depends on emacs-usemeta off (the default)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.39 2006/11/05 15:31:36 tg Exp $");
d59 3
a61 2
#if 0
static void D(int);
d63 1
a63 1
D(int c)
d66 1
d73 2
a74 1
	putc(c, _Dfp);
d1566 2
a1567 1
	char str[2];
d1569 1
d1574 2
d1579 35
d1616 1
d1668 1
a1668 1
		/* no */
d1672 1
d1853 1
a1853 1
	D('A');
d1865 1
a1865 1
	D('B');
d1882 1
a1882 1
	D('C');
d1885 1
a1885 1
	D('D');
d1910 1
a1910 1
	D('E');
d1912 1
a1912 1
	D('F');
d1915 1
a1915 1
	D('G');
@


1.39
log
@first part of utf-8 ability in mksh, already works pretty well
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.38 2006/08/24 20:32:52 tg Exp $");
d1095 1
a1095 1
#define	ISMETA(x)	(Flag(FEMACSUSEMETA) && ((x) & 0x80))
@


1.38
log
@merge non-Plan9-specific stuff from the branch, add KNF, etc.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.37 2006/08/22 22:49:34 tg Exp $");
d59 19
d857 230
d1194 1
a1194 1
static void     x_bs(int);
d1196 4
a1199 3
static int      x_size(int);
static void     x_zots(u_char *);
static void     x_zotc(int);
d1211 2
a1212 1
static void	x_e_putc(int);
d1510 1
a1510 1
		x_e_putc('\n');
d1569 1
a1569 1
		x_e_putc(7);
d1583 1
a1583 1
		x_e_putc(7);
d1598 1
a1598 1
		x_e_putc(7);
d1611 1
a1611 1
	u_char *cp = (u_char *)xcp;
d1626 2
a1627 2
		for (cp = (u_char *)xlp; cp > (u_char *)xcp; )
			x_bs(*--cp);
d1652 1
a1652 1
		x_e_putc(7);
d1668 1
a1668 1
		x_e_putc(7);
d1682 1
a1682 1
	u_char *cp;
d1699 1
a1699 1
	cp = (u_char *)xcp;
d1703 1
a1703 1
		j += x_size(*(u_char *)cp++);
d1707 1
a1707 1
	x_zots((u_char *)xcp);
d1717 1
a1717 1
			x_e_putc(' ');
d1720 1
a1720 1
			x_e_putc('\b');
d1725 2
a1726 2
	for (cp = (u_char *)x_lastcp(); cp > (u_char *)xcp; )
		x_bs(*--cp);
d1766 1
a1766 1
		x_e_putc(7);
d1790 1
a1790 1
		x_e_putc(7);
d1809 1
d1815 2
a1816 4
		u_char *uxcp = (u_char *)xcp;
		while ((u_char *)cp < uxcp)
			x_bs(*--uxcp);
		xcp = (char *)uxcp;
d1818 2
a1819 4
		u_char *uxcp = (u_char *)xcp;
		while ((u_char *)cp > uxcp)
			x_zotc(*uxcp++);
		xcp = (char *)uxcp;
d1821 1
d1825 1
a1825 1
x_bs(int c)
d1829 1
a1829 1
	i = x_size(c);
d1831 1
a1831 1
		x_e_putc('\b');
d1838 1
d1840 2
a1841 1
		size += x_size(*(u_char *)cp++);
d1846 1
a1846 1
x_size(int c)
d1848 6
d1862 1
a1862 1
x_zots(u_char *str)
d1866 1
d1868 17
a1884 2
	while (*str && str < (u_char *)xlp && adj == x_adj_done)
		x_zotc(*str++);
d1888 1
a1888 1
x_zotc(int c)
d1890 2
d1895 1
d1897 3
a1899 2
		x_e_putc('^');
		x_e_putc(UNCTRL(c));
d1901 1
a1901 1
		x_e_putc(c);
d1910 1
a1910 1
		x_e_putc(7);
d1925 1
a1925 1
		x_e_putc(7);
d1945 1
a1945 1
			x_e_putc(7);
d1964 1
a1964 1
				x_e_putc(7);
d1977 2
a1978 2
	x_e_putc('\r');
	x_e_putc('\n');
d1987 1
a1987 1
	x_zotc(edchars.eof);
d2042 1
a2042 1
		x_e_putc(7);
d2116 1
a2116 1
				x_e_putc(7);
d2151 1
a2151 1
				x_e_putc('\n');
d2157 1
a2157 1
	x_e_putc(7);
d2222 1
a2222 1
	u_char *cp;
d2226 1
a2226 1
		x_e_putc('\n');
d2228 1
a2228 1
		x_e_putc('\r');
d2245 2
a2246 2
	cp = (u_char *)x_lastcp();
	x_zots((u_char *)xbp);
d2256 1
a2256 1
			x_e_putc(' ');
d2265 1
a2265 1
		x_e_putc(i);
d2268 1
a2268 1
			x_e_putc('\b');
d2270 2
a2271 2
	for (cp = (u_char *)xlp; cp > (u_char *)xcp; )
		x_bs(*--cp);
d2279 1
a2279 1
	char tmp;
d2295 1
a2295 1
		x_e_putc(7);
d2299 1
a2299 1
			x_e_putc(7);
d2305 14
a2318 7
		x_bs(((u_char *)xcp)[-1]);
		x_bs(((u_char *)xcp)[-2]);
		x_zotc(((u_char *)xcp)[-1]);
		x_zotc(((u_char *)xcp)[-2]);
		tmp = xcp[-1];
		xcp[-1] = xcp[-2];
		xcp[-2] = tmp;
d2323 13
a2335 8
		x_bs(((u_char *)xcp)[-1]);
		x_zotc(((u_char *)xcp)[0]);
		x_zotc(((u_char *)xcp)[-1]);
		tmp = xcp[-1];
		xcp[-1] = xcp[0];
		xcp[0] = tmp;
		x_bs(((u_char *)xcp)[0]);
		x_goto(xcp + 1);
d2446 1
a2446 1
	x_e_putc(7);
d2666 1
a2666 1
		x_e_putc(7);
d2688 1
a2688 1
		x_e_putc(7);
d2768 1
a2768 1
		x_e_putc(7);
d2776 1
a2776 1
			x_e_putc(7);
d2800 1
a2800 1
		x_e_putc(7);
d2888 1
a2888 1
x_e_putc(int c)
d2890 2
d2895 15
a2909 1
		x_putc(c);
d2920 37
a2956 1
			x_col++;
d2970 1
a2970 1
		x_e_putc(*s++);
d2992 1
a2992 1
		x_e_putc(7);
d3012 1
a3012 1
		x_e_putc(7);
d3078 1
a3078 1
		x_e_putc(7);
d3154 1
a3154 1
		x_e_putc(7);
d3206 2
a3207 2
 *      for (cp = x_lastcp(); cp > xcp; cp)
 *        x_bs(*--cp);
d3217 3
a3219 2
	char *rcp;
	int i;
d3221 8
a3228 4
	if (!xlp_valid) {
		for (i = 0, rcp = xbp; rcp < xep && i < x_displen; rcp++)
			i += x_size(*(u_char *)rcp);
		xlp = rcp;
@


1.37
log
@* remove redundancy
* integrate compat.h, version.h into sh.h (dependency trick didn't work anyway)
* mention #ksh in mksh(1) since the founder (twkm) said it's on topic too
  (don't remove mention of #mksh despite it's usually empty because of control)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.36 2006/08/08 20:17:20 tg Exp $");
d45 1
d49 1
d71 1
d76 1
d81 1
d114 1
d132 1
d134 1
d199 1
d201 1
d204 1
d207 1
@


1.36
log
@remove the 'stuff' functionality altogether,
ksh93 doesn't have it, and I don't know, nor
do I care about what "the BRL ^T mini-systat
feature" is.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.35 2006/08/08 20:07:52 tg Exp $");
d2677 1
a2677 1
	char *v = strdup(MKSH_VERSION + 4);
d3167 2
a3168 2
					putbuf(MKSH_VERSION + 4,
					    strlen(MKSH_VERSION + 4), 0);
@


1.36.2.1
log
@ifdef out some code based upon the existence of TIOCGWINSZ and SIGWINCH
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.36 2006/08/08 20:17:20 tg Exp $");
a44 1
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
a47 1
#endif
a68 1
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
a72 1
#endif
a76 1
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
a108 1
#endif
a125 1
#if defined(TIOCGWINSZ) && defined(SIGWINCH)
a126 1
#endif
@


1.36.2.2
log
@Plan 9 has limited line editing modes ;)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.36.2.1 2006/08/24 18:28:19 tg Exp $");
a198 1
#ifdef VWERASE
a199 1
#endif
a201 1
#ifdef VLNEXT
a203 1
#endif
@


1.36.2.3
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.38 2006/08/24 20:32:52 tg Exp $");
d2689 1
a2689 1
	char *v = strdup(KSH_VERSION);
d3179 2
a3180 2
					putbuf(KSH_VERSION,
					     strlen(KSH_VERSION), 0);
@


1.36.2.4
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.35
log
@* bind ^T to transpose-chars as documented in the manual page,
  not to stuff, even if TIOCSTI is available
* it's transpose-chars not transpose

bug spotted by hondza who wondered that on ^T the line repeats itself forever
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.34 2006/08/02 14:02:54 tg Exp $");
d1004 11
a1014 13
#define XFUNC_stuff 43
#define XFUNC_stuffreset 44
#define XFUNC_transpose 45
#define XFUNC_xchg_point_mark 46
#define XFUNC_yank 47
#define XFUNC_comp_list 48
#define XFUNC_expand 49
#define XFUNC_fold_capitalize 50
#define XFUNC_fold_lower 51
#define XFUNC_fold_upper 52
#define XFUNC_set_arg 53
#define XFUNC_comment 54
#define XFUNC_version 55
a1060 2
static int x_stuff (int);
static int x_stuffreset (int);
a1116 2
	{ x_stuff,		"stuff",			0 },
	{ x_stuffreset,		"stuff-reset",			0 },
a2148 30
static int
x_stuffreset(int c)
{
#ifdef TIOCSTI
	(void)x_stuff(c);
	return KINTR;
#else
	x_zotc(c);
	xlp = xcp = xep = xbp = xbuf;
	xlp_valid = true;
	*xcp = 0;
	x_redraw(-1);
	return KSTD;
#endif
}

static int
x_stuff(int c)
{
#ifdef TIOCSTI
	char ch = c;
	bool savmode = x_mode(false);

	(void)ioctl(tty_fd, TIOCSTI, &ch);
	(void)x_mode(savmode);
	x_redraw(-1);
#endif
	return KSTD;
}

@


1.34
log
@the 'delete' key does *not* act as Ctrl-D (EOT, cf. ascii(7))
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.33 2006/08/02 14:00:18 tg Exp $");
a1171 3
#if defined(TIOCSTI)
	{ XFUNC_stuff,			0, MKCTRL('T')	},
#else
a1172 1
#endif
@


1.33
log
@bind xterm-xfree86 and wscons (NetBSD®) wsvt25/vt220 too
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.32 2006/08/02 13:32:17 tg Exp $");
d1225 1
a1225 1
	{ XFUNC_eot_del | 0x80,		2,	  '3'	},
@


1.32
log
@implement a hack whereas you can now bind functions (and macros)
to keys with a trailing tilde (after prefix + control char); the
function is then invoked after prefices, control char and one more
character X are entered; if X is not a tilde, it is ungetc(3)d
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.30 2006/08/02 12:49:04 tg Exp $");
d1220 2
d1223 2
@


1.31
log
@save whitespace
@
text
@d1018 2
d1219 3
d1274 5
d1808 5
d2228 2
d2234 3
a2236 3
	shprintf("%s = ", x_mapout(key));
	if (x_tab[prefix][key] != XFUNC_ins_string)
		shprintf("%s\n", x_ftab[x_tab[prefix][key]].xf_name);
d2266 1
a2266 1
				f = x_tab[prefix][key];
d2278 2
a2279 1
		if (x_tab[prefix][key] == XFUNC_meta1)
d2281 1
a2281 1
		else if (x_tab[prefix][key] == XFUNC_meta2)
d2286 1
a2286 1
	if (*++m1) {
d2316 2
a2317 1
	if (x_tab[prefix][key] == XFUNC_ins_string && x_atab[prefix][key])
d2319 1
a2319 1
	x_tab[prefix][key] = f;
@


1.30
log
@cry if the 'bind' editing command gets too long arguments
minor KNF while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.29 2006/08/02 11:33:36 tg Exp $");
d1136 34
a1169 34
	{ XFUNC_del_back,		0, MKCTRL('?') },
	{ XFUNC_del_bword,		1, MKCTRL('?') },
	{ XFUNC_eot_del,		0, MKCTRL('D') },
	{ XFUNC_del_back,		0, MKCTRL('H') },
	{ XFUNC_del_bword,		1, MKCTRL('H') },
	{ XFUNC_del_bword,		1,	  'h'  },
	{ XFUNC_mv_bword,		1,	  'b'  },
	{ XFUNC_mv_fword,		1,	  'f'  },
	{ XFUNC_del_fword,		1,	  'd'  },
	{ XFUNC_mv_back,		0, MKCTRL('B') },
	{ XFUNC_mv_forw,		0, MKCTRL('F') },
	{ XFUNC_search_char_forw,	0, MKCTRL(']') },
	{ XFUNC_search_char_back,	1, MKCTRL(']') },
	{ XFUNC_newline,		0, MKCTRL('M') },
	{ XFUNC_newline,		0, MKCTRL('J') },
	{ XFUNC_end_of_text,		0, MKCTRL('_') },
	{ XFUNC_abort,			0, MKCTRL('G') },
	{ XFUNC_prev_com,		0, MKCTRL('P') },
	{ XFUNC_next_com,		0, MKCTRL('N') },
	{ XFUNC_nl_next_com,		0, MKCTRL('O') },
	{ XFUNC_search_hist,		0, MKCTRL('R') },
	{ XFUNC_beg_hist,		1,	  '<'  },
	{ XFUNC_end_hist,		1,	  '>'  },
	{ XFUNC_goto_hist,		1,	  'g'  },
	{ XFUNC_mv_end,			0, MKCTRL('E') },
	{ XFUNC_mv_begin,		0, MKCTRL('A') },
	{ XFUNC_draw_line,		0, MKCTRL('L') },
	{ XFUNC_meta1,			0, MKCTRL('[') },
	{ XFUNC_meta2,			0, MKCTRL('X') },
	{ XFUNC_kill,			0, MKCTRL('K') },
	{ XFUNC_yank,			0, MKCTRL('Y') },
	{ XFUNC_meta_yank,		1,	  'y'  },
	{ XFUNC_literal,		0, MKCTRL('^') },
	{ XFUNC_comment,		1,	  '#'  },
d1171 1
a1171 1
	{ XFUNC_stuff,			0, MKCTRL('T') },
d1173 1
a1173 1
	{ XFUNC_transpose,		0, MKCTRL('T') },
d1175 32
a1206 32
	{ XFUNC_complete,		1, MKCTRL('[') },
	{ XFUNC_comp_list,		0, MKCTRL('I') },
	{ XFUNC_comp_list,		1,	  '='  },
	{ XFUNC_enumerate,		1,	  '?'  },
	{ XFUNC_expand,			1,	  '*'  },
	{ XFUNC_comp_file,		1, MKCTRL('X') },
	{ XFUNC_comp_comm,		2, MKCTRL('[') },
	{ XFUNC_list_comm,		2,	  '?'  },
	{ XFUNC_list_file,		2, MKCTRL('Y') },
	{ XFUNC_set_mark,		1,	  ' '  },
	{ XFUNC_kill_region,		0, MKCTRL('W') },
	{ XFUNC_xchg_point_mark,	2, MKCTRL('X') },
	{ XFUNC_literal,		0, MKCTRL('V') },
	{ XFUNC_version,		1, MKCTRL('V') },
	{ XFUNC_prev_histword,		1,	  '.'  },
	{ XFUNC_prev_histword,		1,	  '_'  },
	{ XFUNC_set_arg,		1,	  '0'  },
	{ XFUNC_set_arg,		1,	  '1'  },
	{ XFUNC_set_arg,		1,	  '2'  },
	{ XFUNC_set_arg,		1,	  '3'  },
	{ XFUNC_set_arg,		1,	  '4'  },
	{ XFUNC_set_arg,		1,	  '5'  },
	{ XFUNC_set_arg,		1,	  '6'  },
	{ XFUNC_set_arg,		1,	  '7'  },
	{ XFUNC_set_arg,		1,	  '8'  },
	{ XFUNC_set_arg,		1,	  '9'  },
	{ XFUNC_fold_upper,		1,	  'U'  },
	{ XFUNC_fold_upper,		1,	  'u'  },
	{ XFUNC_fold_lower,		1,	  'L'  },
	{ XFUNC_fold_lower,		1,	  'l'  },
	{ XFUNC_fold_capitalize,	1,	  'C'  },
	{ XFUNC_fold_capitalize,	1,	  'c'  },
d1211 6
a1216 6
	{ XFUNC_meta2,			1,	  '['  },
	{ XFUNC_meta2,			1,	  'O'  },
	{ XFUNC_prev_com,		2,	  'A'  },
	{ XFUNC_next_com,		2,	  'B'  },
	{ XFUNC_mv_forw,		2,	  'C'  },
	{ XFUNC_mv_back,		2,	  'D'  },
@


1.29
log
@fix the prompt redrawal routines for multi-line prompts, prompts
with embedded newline (\n), and multi-line prompts with embedded
newlines. single-line prompts should be not affected; prompts with
embedded carriage return (\r) should be fixed by this as well.
also fix prompt_redraw comment (can't remove the variable though,
since it's required if the shell inserts a newline after the prompt
herself).
tested on cygwin and interix
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.28 2006/08/01 14:59:50 tg Exp $");
d2236 1
a2236 1
		return 1;
d2244 1
a2244 1
		return 0;
d2255 1
a2255 1
		return 0;
d2268 8
d2279 1
a2279 1
		return 0;
d2290 1
a2290 1
			return 1;
d2311 1
a2311 1
	return 0;
@


1.28
log
@fix multiline prompts with "delimiter chars"
(only the last line of the prompt is redrawn, keep this in mind
when doing the ANSI colour game)

TODO:
* maybe go back up one line and redraw whole prompt?
* optionally edit command on multiple lines, bash-like,
  instead of scrolling horizontally
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.27 2006/08/01 14:35:43 tg Exp $");
d918 1
a918 2
static int	prompt_skip;		/* how much of prompt to skip */
static int	prompt_redraw;		/* do we need to redraw the prompt? */
d1222 1
a1222 3
	int	c;
	const char *p;
	int	i;
d1236 1
a1236 2
	x_col = promptlen(prompt, &p);
	prompt_skip = p - prompt;
d1933 1
a1933 1
		x_col = promptlen(prompt, NULL);
d1937 1
a1937 1
			pprompt(prompt + prompt_skip, x_trunc);
a2932 1
static void	vi_pprompt(int);
d3065 1
a3065 1
	vi_pprompt(1);
a4279 1
	const char *p;
d4291 1
a4291 2
	cur_col = pwidth = promptlen(prompt, &p);
	prompt_skip = p - prompt;
d4577 1
a4577 1
	vi_pprompt(0);
d4742 1
a4742 1
			vi_pprompt(0);
a4972 6
vi_pprompt(int full)
{
	pprompt(prompt + (full ? 0 : prompt_skip), prompt_trunc);
}

static void
@


1.27
log
@* use modulo operation, Mr Glockner
* allow promptlen to return values > $COLUMNS
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.26 2006/08/01 14:10:24 tg Exp $");
d1944 1
a1944 1
		x_col = x_col - (x_col / xx_cols) * xx_cols;
@


1.26
log
@move promptlen from edit.c into lex.c
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.25 2006/08/01 14:09:18 tg Exp $");
d1244 1
a1244 1
		x_col = x_col - (x_col / xx_cols) * xx_cols;
@


1.25
log
@(partial) sync with openbsd (and fix after them),
gives us a better wrapping prompt and a manpage wording cleanup
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.24 2006/08/01 12:44:16 tg Exp $");
a32 1
int promptlen(const char *, const char **);
a226 39
int
promptlen(const char *cp, const char **spp)
{
	int count = 0;
	const char *sp = cp;
	char delimiter = 0;
	int indelimit = 0;

	/* Undocumented AT&T ksh feature:
	 * If the second char in the prompt string is \r then the first char
	 * is taken to be a non-printing delimiter and any chars between two
	 * instances of the delimiter are not considered to be part of the
	 * prompt length
	 */
	if (*cp && cp[1] == '\r') {
		delimiter = *cp;
		cp += 2;
	}
	for (; *cp; cp++) {
		if (indelimit && *cp != delimiter)
			;
		else if (*cp == '\n' || *cp == '\r') {
			count = 0;
			sp = cp + 1;
		} else if (*cp == '\t') {
			count = (count | 7) + 1;
		} else if (*cp == '\b') {
			if (count > 0)
				count--;
		} else if (*cp == delimiter)
			indelimit = !indelimit;
		else
			count++;
	}
	if (spp)
		*spp = sp;
	return count;
}

@


1.24
log
@bring back the 'version' editing command at "ESC ^V" like AT&T ksh93+r
@
text
@d3 1
a3 1
/*	$OpenBSD: emacs.c,v 1.39 2005/09/26 19:25:22 otto Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.23 2006/07/11 14:51:01 tg Exp $");
d959 1
d1282 3
d1289 6
d1967 1
a1967 1
	int i, j;
a1976 1
		pprompt(prompt + prompt_skip, 0);
d1978 4
d1983 2
d1986 4
@


1.23
log
@* TNF needs more to silence char subscript warnings (on 3.0-stable)
* bump vsn
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.22 2006/07/03 12:16:29 tg Exp $");
d50 4
a322 4
static char *add_glob(const char *, int);
static void glob_table(const char *, XPtrV *, struct table *);
static void glob_path(int flags, const char *, XPtrV *, const char *);

a457 2
static int path_order_cmp(const void *aa, const void *bb);

d996 5
d1056 1
d1113 1
d1171 1
d1228 1
a1360 2
static int x_do_ins(const char *cp, int len);

a2356 2
static void bind_if_not_bound(int p, int k, int func);

a2579 1

a2593 2
static int unget_char = -1;

a2662 1

a2683 1

d2705 31
a2750 1

a2828 1

a2894 1

d3033 1
d3118 1
a3118 1
			} else if (c == edchars.eof) {
d3198 8
d3220 6
d3442 2
@


1.22
log
@fix the "char subscripts" issue, bump version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.21 2006/05/10 18:54:09 tg Exp $");
d2824 1
a2824 1
					*cp = tolower(*cp);
d2827 1
a2827 1
					*cp = toupper(*cp);
d2837 1
a2837 1
					*cp = toupper(*cp);
d2840 1
a2840 1
					*cp = tolower(*cp);
d3957 1
a3957 1
						*p = toupper(*p);
d3961 1
a3961 1
						*p = tolower(*p);
@


1.21
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.20 2006/02/16 11:48:31 tg Exp $");
d595 2
a596 1
		for (p = start - 1; p >= 0 && isspace(buf[p]); p--)
d901 7
a907 6
#define	is_cfs(c)	(c == ' ' || c == '\t' || c == '"' || c == '\'')
#define	is_mfs(c)	(!(isalnum(c) || c == '_' || c == '$'))  /* Separator for motion */

# define CHARMASK	0xFF		/* 8-bit character mask */
# define X_NTABS	3		/* normal, meta1, meta2 */
#define X_TABSZ		(CHARMASK+1)	/* size of keydef tables etc */
d2671 1
a2671 1
	for (; c >= 0 && isdigit(c); c = x_e_getc(), first = 0)
d2823 1
a2823 1
				if (isupper(*cp))
d2826 1
a2826 1
				if (islower(*cp))
d2836 1
a2836 1
				if (islower(*cp))
d2839 1
a2839 1
				if (isupper(*cp))
d3186 1
a3186 1
		if (isdigit(ch))
d3212 1
a3212 1
		if (isdigit(ch))
d3275 1
a3275 1
			while (n > 0 && isspace(locpat[n - 1]))
d3277 1
a3277 1
			while (n > 0 && !isspace(locpat[n - 1]))
d3645 2
a3646 2
				    !isspace(es->cbuf[es->cursor])) {
					while (isspace(es->cbuf[--ncursor]))
d3897 1
a3897 1
#define issp(c)		(isspace((c)) || (c) == '\n')
d3954 1
a3954 1
					if (islower(*p)) {
d3958 1
a3958 1
					} else if (isupper(*p)) {
d4105 2
a4106 1
		while (ncursor < es->linelen - 1 && isspace(es->cbuf[ncursor]))
d4375 1
a4375 1
		else if (!isspace(es->cbuf[ncursor]))
d4377 1
a4377 1
			    !isspace(es->cbuf[ncursor]) &&
d4380 2
a4381 1
		while (isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d4394 1
a4394 1
		while (--ncursor > 0 && isspace(es->cbuf[ncursor]))
d4404 1
a4404 1
				    !isspace(es->cbuf[ncursor]))
d4420 1
a4420 1
		    isspace(es->cbuf[ncursor]))
d4430 1
a4430 1
				    !isspace(es->cbuf[ncursor]))
d4445 2
a4446 1
		while (!isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d4448 2
a4449 1
		while (isspace(es->cbuf[ncursor]) && ncursor < es->linelen)
d4462 2
a4463 1
		while (--ncursor >= 0 && isspace(es->cbuf[ncursor]))
d4465 2
a4466 1
		while (ncursor >= 0 && !isspace(es->cbuf[ncursor]))
d4481 1
a4481 1
		    isspace(es->cbuf[ncursor]))
d4485 1
a4485 1
			    !isspace(es->cbuf[ncursor]))
@


1.20
log
@* convert most of the interna of edit.c to unsigned where it's
  important for the signedness of the target, to enable using
  high-bit7 characters on the command line (eg. in UTF-8 locales)
* make emacs-usemeta and vi-show8 equivalent and document that
  in the manual page (i.e. beware if you're in a latin1 locale)
* do not reference SUSv3 (helps GNU groff), write \&" out instead
@
text
@d4 1
a4 1
/*	$OpenBSD: vi.c,v 1.22 2005/12/11 20:31:21 otto Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.19 2006/01/30 12:37:21 tg Exp $");
@


1.19
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.18 2006/01/29 20:04:49 tg Exp $");
d31 1
a31 1
void x_puts(const char *);
d159 1
a159 1
x_puts(const char *s)
d873 1
a873 1
#define	UNCTRL(x)	((x) == 0x7F ? '?' : (x) | 0x40)	/* ASCII */
d976 1
a976 1
static void     x_zots(char *);
d1371 1
a1371 1
	char *cp = xcp;
d1386 1
a1386 1
		for (cp = xlp; cp > xcp; )
d1442 1
a1442 1
	char *cp;
d1459 1
a1459 1
	cp = xcp;
d1463 1
a1463 1
		j += x_size(*cp++);
d1467 1
a1467 1
	x_zots(xcp);
d1485 1
a1485 1
	for (cp = x_lastcp(); cp > xcp;)
d1574 4
a1577 2
		while (cp < xcp)
			x_bs(*--xcp);
d1579 4
a1582 2
		while (cp > xcp)
			x_zotc(*xcp++);
d1601 1
a1601 1
		size += x_size(*cp++);
d1610 2
a1611 2
	if (iscntrl(c))		/* control char */
		return 2;
d1616 1
a1616 1
x_zots(char *str)
d1621 1
a1621 1
	while (*str && str < xlp && adj == x_adj_done)
d1631 1
a1631 1
	} else if (iscntrl(c)) {
d1951 1
a1951 1
	char *cp;
d1965 2
a1966 2
	cp = x_lastcp();
	x_zots(xbp);
d1990 1
a1990 1
	for (cp = xlp; cp > xcp; )
d2025 4
a2028 4
		x_bs(xcp[-1]);
		x_bs(xcp[-2]);
		x_zotc(xcp[-1]);
		x_zotc(xcp[-2]);
d2036 3
a2038 3
		x_bs(xcp[-1]);
		x_zotc(xcp[0]);
		x_zotc(xcp[-1]);
d2042 1
a2042 1
		x_bs(xcp[0]);
d2219 1
a2219 1
	if (iscntrl(c)) {
d2875 1
a2875 1
			i += x_size(*rcp);
d4939 1
a4939 1
		x_puts("M-");
@


1.18
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.17 2005/11/22 18:40:41 tg Exp $");
d600 1
a600 1
			 * only current directory is searched, which is just
@


1.17
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: edit.c,v 1.30 2005/09/11 18:08:47 otto Exp $	*/
d4 1
a4 1
/*	$OpenBSD: vi.c,v 1.21 2005/03/30 17:16:37 deraadt Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.16 2005/10/25 19:53:26 tg Exp $");
d763 1
a763 1
	for (twalk(&ts, tp); (te = tnext(&ts)); ) {
d3571 1
a3571 1
				ap = tsearch(&aliases, alias, hash(alias));
@


1.16
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.15 2005/10/07 18:34:18 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.15 2005/10/07 18:34:18 tg Exp $");
@


1.15
log
@Fix a redraw problem that occurs when a recalled history line has
length equal to screen width - 2. Spotted by jmc@@, tested by various.
ok deraadt@@
From otto@@obsd
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.14 2005/10/07 18:32:23 tg Exp $ */
a7 4
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <ctype.h>
#include <libgen.h>
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.14 2005/10/07 18:32:23 tg Exp $");
@


1.14
log
@Process window size changes after xread(). [change window size]
echo $COLUMS $LINES; will now print the new sizes immediately, instead
of after the second echo. ok millert@@
From otto@@obsd
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.13 2005/08/21 13:02:17 tg Exp $ */
d4 1
a4 1
/*	$OpenBSD: emacs.c,v 1.38 2005/08/01 04:27:31 deraadt Exp $	*/
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.13 2005/08/21 13:02:17 tg Exp $");
d1786 1
a1786 3
	if (xep > x_lastcp())
		x_goto(xep);
	else
d1788 1
@


1.13
log
@* make 64-bit clean on GNU/Linux by default
* clean up and remove some .Xr from the man page
* bump version
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/edit.c,v 1.12 2005/08/02 12:35:26 tg Exp $ */
/*	$OpenBSD: edit.c,v 1.29 2005/04/13 02:33:08 deraadt Exp $	*/
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.12 2005/08/02 12:35:26 tg Exp $");
a119 3
	if (got_sigwinch)
		check_sigwinch();

d128 1
@


1.12
log
@^V now is quote, not version, even in emacs mode. (From OpenBSD.)
Also, the "version" command got removed in its entirety.
Shaves off another global variable, even.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.11 2005/07/12 13:30:37 tg Exp $ */
d13 1
a13 3
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.11 2005/07/12 13:30:37 tg Exp $");

#define	BEL		0x07
d1334 1
a1334 1
		x_e_putc(BEL);
d1348 1
a1348 1
		x_e_putc(BEL);
d1365 1
a1365 1
		x_e_putc(BEL);
d1419 1
a1419 1
		x_e_putc(BEL);
d1435 1
a1435 1
		x_e_putc(BEL);
d1533 1
a1533 1
		x_e_putc(BEL);
d1557 1
a1557 1
		x_e_putc(BEL);
d1647 1
a1647 1
		x_e_putc(BEL);
d1662 1
a1662 1
		x_e_putc(BEL);
d1682 1
a1682 1
			x_e_putc(BEL);
d1701 1
a1701 1
				x_e_putc(BEL);
d1779 1
a1779 1
		x_e_putc(BEL);
d1849 1
a1849 1
				x_e_putc(BEL);
d1890 1
a1890 1
	x_e_putc(BEL);
d2019 1
a2019 1
		x_e_putc(BEL);
d2023 1
a2023 1
			x_e_putc(BEL);
d2158 1
a2158 1
	x_e_putc(BEL);
d2398 1
a2398 1
		x_e_putc(BEL);
d2420 1
a2420 1
		x_e_putc(BEL);
d2500 1
a2500 1
		x_e_putc(BEL);
d2508 1
a2508 1
			x_e_putc(BEL);
d2532 1
a2532 1
		x_e_putc(BEL);
d2630 1
a2630 1
		case BEL:
d2676 1
a2676 1
		x_e_putc(BEL);
d2697 1
a2697 1
		x_e_putc(BEL);
d2733 1
a2733 1
		x_e_putc(BEL);
d2810 1
a2810 1
		x_e_putc(BEL);
d3428 1
a3428 2
			if (es->cursor == 0) {
				/* x_putc(BEL); no annoying bell here */
a3429 1
			}
d4964 1
a4964 1
	x_putc(BEL);
@


1.11
log
@please ISO C99
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.9 2005/07/04 12:07:40 tg Exp $ */
d4 1
a4 1
/*	$OpenBSD: emacs.c,v 1.37 2005/03/30 17:16:37 deraadt Exp $	*/
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.9 2005/07/04 12:07:40 tg Exp $");
d1051 9
a1059 10
#define XFUNC_version 46
#define XFUNC_xchg_point_mark 47
#define XFUNC_yank 48
#define XFUNC_comp_list 49
#define XFUNC_expand 50
#define XFUNC_fold_capitalize 51
#define XFUNC_fold_lower 52
#define XFUNC_fold_upper 53
#define XFUNC_set_arg 54
#define XFUNC_comment 55
a1106 1
static int x_version (int);
a1163 1
	{ x_version,		"version",			0 },
d1228 1
a1228 1
	{ XFUNC_version,		0, MKCTRL('V') },
a2431 32
x_version(int c __attribute__((unused)))
{
	char *o_xbuf = xbuf, *o_xend = xend;
	char *o_xbp = xbp, *o_xep = xep, *o_xcp = xcp;
	int lim = x_lastcp() - xbp;
	char *v = strdup(ksh_version + 4);

	check_sigwinch();	/* mksh hack ;-) */
	xbuf = xbp = xcp = v;
	xend = xep = v + strlen(v);
	x_redraw(lim);
	x_flush();

	c = x_e_getc();
	xbuf = o_xbuf;
	xend = o_xend;
	xbp = o_xbp;
	xep = o_xep;
	xcp = o_xcp;
	x_redraw(strlen(ksh_version));

	if (c < 0)
		return KSTD;
	/* This is what at&t ksh seems to do...  Very bizarre */
	if (c != ' ')
		x_e_ungetc(c);

	free(v);
	return KSTD;
}

static int
a3010 1
#define VVERSION	10		/* <ESC> ^V */
d3095 1
a3095 1
			} else if (c == edchars.eof && state != VVERSION) {
a3174 8
				if (state == VVERSION) {
					save_cbuf();
					es->cursor = 0;
					es->linelen = 0;
					putbuf(ksh_version + 4,
					    strlen(ksh_version + 4), 0);
					refresh(0);
				}
a3188 6
	case VVERSION:
		restore_cbuf();
		state = VNORMAL;
		refresh(0);
		break;

a3404 2
	else if (ch == Ctrl('v'))
		return VVERSION;
@


1.10
log
@gcc 4.0 with -O2 -Wall thinks it finds these uninitialised variables,
so quieten gcc

found by Bastian "waldi" Blank
@
text
@d337 1
a337 1
	XPtrV l = {};
@


1.9
log
@mksh now does not look at $EDITOR and $VISUAL any more to determine
the editing mode; default is emacs (vi and gmacs off).
mksh also defaults to emacs-usemeta=OFF now.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.8 2005/06/08 22:34:02 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.8 2005/06/08 22:34:02 tg Exp $");
d337 1
a337 1
	XPtrV l;
@


1.8
log
@some lint cleanup
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.7 2005/06/08 22:22:23 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.7 2005/06/08 22:22:23 tg Exp $");
a271 18
void
set_editmode(const char *ed)
{
	static const enum sh_flag edit_flags[] = {
		FEMACS, FGMACS, FVI
	};
	char *rcp;
	unsigned i;

	if ((rcp = strrchr(ed, '/')))
		ed = ++rcp;
	for (i = 0; i < NELEM(edit_flags); i++)
		if (strstr(ed, options[(int)edit_flags[i]].name)) {
			change_flag(edit_flags[i], OF_SPECIAL, 1);
			return;
		}
}

d2356 1
a2356 1
	Flag(FEMACSUSEMETA) = 1;
@


1.7
log
@run a bit of indent over it
not really suitable tho
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.6 2005/06/08 21:51:20 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.6 2005/06/08 21:51:20 tg Exp $");
d3791 1
a3791 1
			/* fall through */
d3941 1
a3941 1
			/* fall through */
@


1.6
log
@* major revamp of build system
* whitespace cleanup; junk comment removal
* syndicate debian/copyright file from my port (shrinks sh.h)
* bump to R23
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.5 2005/05/25 23:39:10 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.5 2005/05/25 23:39:10 tg Exp $");
d35 17
a51 17
int	x_getc(void);
void	x_flush(void);
void	x_putc(int);
void	x_puts(const char *);
bool	x_mode(bool);
int	promptlen(const char *, const char **);
int	x_do_comment(char *, int, int *);
void	x_print_expansions(int, char *const *, int);
int	x_cf_glob(int, const char *, int, int, int *, int *, char ***, int *);
int	x_longest_prefix(int , char *const *);
int	x_basename(const char *, const char *);
void	x_free_words(int, char **);
int	x_escape(const char *, size_t, int (*)(const char *, size_t));
int	x_emacs(char *, size_t);
void	x_init_emacs(void);
void	x_emacs_keys(X_chars *);
int	x_vi(char *, size_t);
d57 3
a59 3
static int	x_file_glob(int, const char *, int, char ***);
static int	x_command_glob(int, const char *, int, char ***);
static int	x_locate_word(const char *, int, int, int *, int *);
d73 2
a74 1
	if (setsig(&sigtraps[SIGWINCH], x_sigwinch, SS_RESTORE_ORIG|SS_SHTRAP))
d107 1
a107 1
				setint(vp, (long) ws.ws_col);
d110 1
a110 1
			setint(vp, (long) ws.ws_row);
d120 1
a120 1
	int	i;
d152 1
a152 1
	return (int) (unsigned char) c;
d177 2
a178 2
	static bool	x_cur_mode;
	bool		prev;
d186 2
a187 2
		struct termios	cb;
		X_chars		oldchars;
d198 2
a199 2
		cb.c_iflag &= ~(INLCR|ICRNL);
		cb.c_lflag &= ~(ISIG|ICANON|ECHO);
a250 1

d284 1
a284 1
		if (strstr(ed, options[(int) edit_flags[i]].name)) {
d346 3
a348 3
static char	*add_glob(const char *, int);
static void	glob_table(const char *, XPtrV *, struct table *);
static void	glob_path(int flags, const char *, XPtrV *, const char *);
d351 1
a351 1
x_print_expansions(int nwords, char *const *words, int is_command)
a382 1

d388 1
a388 1
	pr_list(use_copy ? (char **) XPptrv(l) : words);
d429 2
a430 1
		if (escaping) escaping = 0;
d441 1
a441 1
	if (yylex(ONEWORD|LQCHAR) != LWORD) {
d448 1
a448 1
	expand(yylval.cp, &w, DOGLOB|DOTILDE|DOMARKDIRS);
d450 1
a450 1
	words = (char **) XPclose(w);
d515 1
a515 1
	pat = evalstr(toglob, DOPAT|DOTILDE);
a536 1

d542 1
a542 1
		char **words = (char **) XPptrv(w);
d547 1
a547 1
			alloc(sizeof(struct path_order_info) * nwords, ATEMP);
d559 1
a559 1
			path_order_cmp);
d562 1
a562 1
		afree((void *) info, ATEMP);
d565 1
a565 1
		char **words = (char **) XPptrv(w);
d568 1
a568 1
		qsortp(XPptrv(w), (size_t) nwords, xstrcmp);
d578 1
a578 1
		w.cur = (void **) &words[j];
d582 1
a582 1
	*wordsp = (char **) XPclose(w);
d610 1
a610 1
	    (start > 1 && buf[start-2] == '\\'); start--)
d614 1
a614 1
		if (buf[end] == '\\' && (end+1) < buflen)
a636 1

d661 1
a661 1
	nwords = (is_command ? x_command_glob : x_file_glob)(flags,
a666 1

d701 1
a701 1
			 || (s[1] == '(' /*)*/ && strchr("*+?@@!", *s)))
a709 1

d717 1
a717 1
x_longest_prefix(int nwords, char *const *words)
d840 1
a840 1
		words = (char **) XPptrv(*wp);
d853 1
a853 1
		wp->cur = (void **) &words[j];
d871 1
a871 1
	int rval=0;
a878 1

a1312 1

a1321 1

d1323 1
a1323 1
		    x_tab[x_curprefix][c&CHARMASK];
d1351 1
a1351 1
	char	str[2];
d1374 1
a1374 1
	macroptr = x_atab[c>>8][c & CHARMASK];
d1387 1
a1387 1
	if (xep+len >= xend) {
d1391 1
a1391 2

	memmove(xcp+len, xcp, xep - xcp + 1);
d1401 2
a1402 2
	char	*cp = xcp;
	int	adj = x_adj_done;
a1418 1

d1471 2
a1472 2
	int	i,j;
	char	*cp;
a1481 1

d1495 1
a1495 1
	memmove(xcp, xcp+nc, xep - xcp + 1);	/* Copies the null */
d1515 1
a1515 1
	for (cp = x_lastcp(); cp > xcp; )
d1552 2
a1553 2
	int	nc = 0;
	char	*cp = xcp;
d1576 2
a1577 2
	int	nc = 0;
	char	*cp = xcp;
d1634 1
a1634 1
	if (c=='\t')
d1644 1
a1644 1
	int	adj = x_adj_done;
d1799 1
a1799 1
	int	oldsize;
d1812 1
a1812 1
	  x_goto(xep);
d1814 1
a1814 1
	  x_redraw(oldsize);
d1838 1
a1838 1
	char pat [256+1];	/* pattern buffer */
d1851 1
a1851 1
		f = x_tab[0][c&CHARMASK];
d1903 1
a1903 1
	for (hp = x_histp - (sameline ? 0 : 1) ; hp >= history; --hp) {
d1923 1
a1923 1
		return (strncmp(str, pat+1, strlen(pat+1)) == 0) ? 0 : -1;
d1933 1
a1933 1
	int	i, j;
d1977 2
a1978 2
	int	i, j;
	char	*cp;
d2026 1
a2026 1
	char	tmp;
d2119 1
a2119 1
	char	*cp = str_nsave(xcp, nchars, AEDIT);
d2133 1
a2133 1
	killtp --;
d2147 1
a2147 1
	int	len;
d2205 2
a2206 2
	char	ch = c;
	bool	savmode = x_mode(false);
d2270 3
a2272 3
x_bind( const char *a1, const char *a2,
	int macro,		/* bind -m */
	int list)		/* bind -l */
a2282 1

a2290 1

a2301 1

a2317 1

d2359 1
a2359 1
	x_tab = (u_char (*)[X_TABSZ]) alloc(sizeofN(*x_tab, X_NTABS), AEDIT);
d2369 1
a2369 1
	x_atab = (char *(*)[X_TABSZ]) alloc(sizeofN(*x_atab, X_NTABS), AEDIT);
d2417 2
a2418 2
	int	rsize;
	char	*xr;
d2440 1
a2440 1
	char	*tmp;
d2448 1
a2448 1
	x_goto( tmp );
a2557 1

a2589 1

a2595 1

a2610 1

a2614 1

d2705 1
a2705 1
	int	adj = x_adj_done;
d3105 3
a3107 3
    unsigned char	*p;	/* current position in buf */
    unsigned char	*buf;	/* pointer to macro(s) being expanded */
    int			len;	/* how much data in buffer */
d3111 3
a3113 1
enum expand_mode { NONE, EXPAND, COMPLETE, PRINT };
d3119 1
a3119 1
	int	c;
d3163 3
a3165 1
	x_putc('\r'); x_putc('\n'); x_flush();
d3181 2
a3182 2
	static char	curcmd[MAXVICMD], locpat[SRCHLEN];
	static int	cmdlen, argc1, argc2;
d3323 1
a3323 1
				(void) strlcpy(srchpat, locpat, sizeof srchpat);
d3484 1
a3484 1
	int	tcursor;
d3508 1
a3508 1
			memmove(&es->cbuf[es->cursor], &es->cbuf[es->cursor+1],
d3597 1
a3597 1
			memmove(&es->cbuf[es->cursor+1], &es->cbuf[es->cursor],
d3612 4
a3615 4
	int		ncursor;
	int		cur, c1, c2, c3 = 0;
	int		any;
	struct edstate	*t;
d3648 2
a3649 2
				int	olen, nlen;
				char	*p, *nbuf;
d3657 1
a3657 1
				if ((p = (char *) macro.p))
d3676 1
a3676 1
				macro.p = macro.buf = (unsigned char *) nbuf;
d3682 2
a3683 1
			modified = 1; hnum = hlast;
d3690 2
a3691 1
			modified = 1; hnum = hlast;
d3700 2
a3701 1
			modified = 1; hnum = hlast;
d3720 1
a3720 1
				    (cmd[1]=='w' || cmd[1]=='W') &&
d3743 2
a3744 1
				modified = 1; hnum = hlast;
d3750 2
a3751 1
			modified = 1; hnum = hlast;
d3763 2
a3764 1
			modified = 1; hnum = hlast;
d3775 2
a3776 1
			modified = 1; hnum = hlast;
d3806 2
a3807 1
			modified = 1; hnum = hlast;
d3812 2
a3813 1
			modified = 1; hnum = hlast;
d3843 2
a3844 1
			modified = 1; hnum = hlast;
d3848 1
a3848 1
				int	n;
d3859 2
a3860 1
			modified = 1; hnum = hlast;
d3867 2
a3868 1
			modified = 1; hnum = hlast;
d3885 1
a3885 1
						- (hlast - hnum);
d3897 2
a3898 1
			modified = 1; hnum = hlast;
d3907 2
a3908 1
				modified = 1; hnum = hlast;
d3967 2
a3968 2
				int	inspace;
				char	*p, *sp;
d4023 2
a4024 2
				char	*p;
				int	i;
d4089 2
a4090 2
	int	bcount, i = 0, t;
	int	ncursor = 0;
d4236 1
a4236 1
		if (putbuf(ibuf, inslen, insert==REPLACE) != 0)
d4363 2
a4364 2
	(void) memset(wbuf[0], ' ', wbuf_len);
	(void) memset(wbuf[1], ' ', wbuf_len);
d4414 1
a4414 1
	int	ncursor;
d4442 1
a4442 1
	int	ncursor;
d4515 1
a4515 1
	int	ncursor;
d4566 1
a4566 1
	char	*hptr;
d4575 1
a4575 1
	(void) histnum(n);
d4593 3
a4595 3
	char	*hptr;
	int	hist;
	int	anchored;
d4597 1
a4597 1
	if ((start == 0 && fwd == 0) || (start >= hlast-1 && fwd == 1))
d4627 1
a4627 1
	(void) memset(wbuf[win], ' ', wbuf_len);
d4653 1
a4653 1
	int	cur, col;
d4660 1
a4660 1
		col = newcol((unsigned char) es->cbuf[cur++], col);
d4669 3
a4671 3
	int	tcur, tcol;
	int	holdcur1, holdcol1;
	int	holdcur2, holdcol2;
d4682 1
a4682 1
		tcol = newcol((unsigned char) es->cbuf[tcur++], tcol);
d4685 1
a4685 1
		holdcol1 = newcol((unsigned char) es->cbuf[holdcur1++],
d4702 4
a4705 4
	char	*twb1, *twb2, mc;
	int	cur, col, cnt;
	int	ncol = 0;
	int	moreright;
d4862 2
a4863 1
	modified = 1; hnum = hlast;
d4967 2
a4968 1
	modified = 1; hnum = hlast;
d4984 1
a4984 1
	nwords = x_cf_glob(XCF_COMMAND_FILE|XCF_FULLPATH,
d5047 1
a5047 1
		memset((char *) &macro, 0, sizeof(macro));
@


1.5
log
@some KNF
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.4 2005/05/25 23:31:05 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.4 2005/05/25 23:31:05 tg Exp $");
d1764 4
a1767 4
static int 
x_beg_hist(int c __attribute__((unused))) 
{ 
	x_load_hist(history); 
d1771 4
a1774 4
static int 
x_end_hist(int c __attribute__((unused))) 
{ 
	x_load_hist(histptr); 
d1778 4
a1781 4
static int 
x_prev_com(int c __attribute__((unused))) 
{ 
	x_load_hist(x_histp - x_arg); 
d1785 4
a1788 4
static int 
x_next_com(int c __attribute__((unused))) 
{ 
	x_load_hist(x_histp + x_arg); 
@


1.4
log
@* fix emacs [ tabcompletion bug
  XXX it's probably a bug in vi mode too, it just doesn't show
* bring manual page and reality into closer sync'd state
* sort ulimits
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.3 2005/05/23 16:23:18 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.3 2005/05/23 16:23:18 tg Exp $");
d90 1
a90 1
		struct winsize ws;
d92 12
a103 13
		got_sigwinch = 0;
		if (procpid == kshpid && ioctl(tty_fd, TIOCGWINSZ, &ws) >= 0) {
			struct tbl *vp;

			/* Do NOT export COLUMNS/LINES.  Many applications
			 * check COLUMNS/LINES before checking ws.ws_col/row,
			 * so if the app is started with C/L in the environ
			 * and the window is then resized, the app won't
			 * see the change cause the environ doesn't change.
			 */
			if (ws.ws_col) {
				x_cols = ws.ws_col < MIN_COLS ? MIN_COLS :
				    ws.ws_col;
d105 2
a106 5
				if ((vp = typeset("COLUMNS", 0, 0, 0, 0)))
					setint(vp, (long) ws.ws_col);
			}
			if (ws.ws_row && (vp = typeset("LINES", 0, 0, 0, 0)))
				setint(vp, (long) ws.ws_row);
d108 3
d226 1
a226 1
	} else {
a227 1
	}
d3966 4
a3969 3
		case '_': {
			int	inspace;
			char	*p, *sp;
d3971 3
a3973 3
			if (histnum(-1) < 0)
				return -1;
			p = *histpos();
d3975 2
a3976 5
			if (argcnt) {
				while (*p && issp(*p))
					p++;
				while (*p && --argcnt) {
					while (*p && !issp(*p))
d3978 19
a3996 1
					while (*p && issp(*p))
d3998 2
d4001 15
a4015 1
				if (!*p)
a4016 12
				sp = p;
			} else {
				sp = p;
				inspace = 0;
				while (*p) {
					if (issp(*p))
						inspace = 1;
					else if (inspace) {
						inspace = 0;
						sp = p;
					}
					p++;
d4018 1
a4018 19
				p = sp;
			}
			modified = 1; hnum = hlast;
			if (es->cursor != es->linelen)
				es->cursor++;
			while (*p && !issp(*p)) {
				argcnt++;
				p++;
			}
			if (putbuf(space, 1, 0) != 0)
				argcnt = -1;
			else if (putbuf(sp, argcnt, 0) != 0)
				argcnt = -1;
			if (argcnt < 0) {
				if (es->cursor != 0)
					es->cursor--;
				return -1;
			}
			insert = INSERT;
d4022 4
a4025 3
		case '~': {
			char	*p;
			int	i;
d4027 15
a4041 10
			if (es->linelen == 0)
				return -1;
			for (i = 0; i < argcnt; i++) {
				p = &es->cbuf[es->cursor];
				if (islower(*p)) {
					modified = 1; hnum = hlast;
					*p = toupper(*p);
				} else if (isupper(*p)) {
					modified = 1; hnum = hlast;
					*p = tolower(*p);
d4043 1
a4043 4
				if (es->cursor < es->linelen - 1)
					es->cursor++;
			}
			break;
d4047 7
a4053 7
		    {
			int ret = x_do_comment(es->cbuf, es->cbufsize,
			    &es->linelen);
			if (ret >= 0)
				es->cursor = 0;
			return ret;
		    }
a4093 1

@


1.3
log
@aaaand: Interix.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.2 2005/05/23 15:18:15 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.2 2005/05/23 15:18:15 tg Exp $");
d75 1
a75 2
	got_sigwinch = 1; /* force initial check */
	check_sigwinch();
a89 1
	if (got_sigwinch) {
a111 1
	}
d426 3
d443 1
a443 1
	if (yylex(ONEWORD) != LWORD) {
d880 1
a880 1
		if (strchr("\\$()[]{}*&;#|<>\"'`", s[add]) || strchr(ifs, s[add])) {
d2476 1
@


1.2
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/edit.c,v 1.1 2005/05/23 03:06:06 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.1 2005/05/23 03:06:06 tg Exp $");
d206 1
d208 1
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/edit.c,v 1.16 2005/05/23 01:31:54 tg Exp $ */
d13 1
a13 1
__RCSID("$MirOS: mksh/edit.c,v 1.16 2005/05/23 01:31:54 tg Exp $");
d795 1
a795 1
		if (gmatch(te->name, pat, false))
@

