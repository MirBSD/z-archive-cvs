head	1.26;
access;
symbols
	mksh-R57:1.26
	mksh-R56c:1.26
	mksh-R56b:1.26
	mksh-R56:1.26
	mksh-R55:1.26
	mksh-R54:1.26
	mksh-R53a:1.26
	mksh-R53:1.26
	mksh-R52c:1.26
	mksh-R52b:1.23
	mksh-R52:1.23
	mksh-R51:1.21
	mksh-R50f:1.20.2.1
	mksh-R50e:1.20.2.1
	mksh-R50stable:1.20.0.2
	mksh-R50d:1.20
	mksh-R50c:1.20
	mksh-R50b:1.20
	mksh-R50:1.20
	mksh-R49:1.20
	mksh-R48b:1.20
	mksh-R48:1.20
	mksh-R47:1.20
	mksh-R46:1.19
	mksh-R45:1.19
	mksh-R44:1.19
	mksh-R43:1.19
	mksh-R42b:1.19
	mksh-R41c:1.19
	mksh-R41b:1.19
	mksh-R42:1.19
	mksh-R41:1.19
	mksh-R41stable:1.19.0.8
	mksh-wheezy:1.19.0.6
	tg-multikey-bind:1.19.0.2
	mksh-R40f:1.19
	mksh-R40e:1.19
	mksh-R40d:1.19
	mksh-R40c:1.19
	mksh-R40b:1.17
	mksh-R40stable:1.19.0.4
	mksh-R40:1.17
	mksh-R39c:1.11
	mksh-R39b:1.11
	tg-wcswidth-behaviour:1.11.0.4
	tg-nameref:1.11.0.2
	mksh-R39:1.10
	tg-mksh-printf-builtin:1.10.0.2
	mksh-R38c:1.10
	mksh-R38b:1.10
	mksh-R38:1.10
	mksh-R37c:1.9
	mksh-R37b:1.7
	mksh-R37:1.7;
locks; strict;
comment	@ * @;


1.26
date	2016.02.26.21.53.36;	author tg;	state Exp;
branches;
next	1.25;
commitid	10056D0C89E7DCB5486;

1.25
date	2016.02.24.02.08.39;	author tg;	state Exp;
branches;
next	1.24;
commitid	10056CD10B37F67B062;

1.24
date	2016.02.24.01.44.46;	author tg;	state Exp;
branches;
next	1.23;
commitid	10056CD0AFA12B0CBA5;

1.23
date	2015.11.29.17.05.01;	author tg;	state Exp;
branches;
next	1.22;
commitid	100565B305567B17D70;

1.22
date	2015.09.05.19.19.06;	author tg;	state Exp;
branches;
next	1.21;
commitid	10055EB402C54C3076B;

1.21
date	2014.11.25.20.00.39;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005474DFFB1DC897E5;

1.20
date	2013.06.03.22.28.33;	author tg;	state Exp;
branches
	1.20.2.1;
next	1.19;
commitid	10051AD18A44752B56B;

1.19
date	2011.09.07.15.24.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004E678C6929FE60A6;

1.18
date	2011.08.27.18.06.47;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004E5932432420AA61;

1.17
date	2011.03.13.10.50.44;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004D7CA19525557004;

1.16
date	2011.03.05.21.48.09;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004D72AF6C540FBB78;

1.15
date	2011.03.05.21.43.16;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004D72AE603B079174;

1.14
date	2011.01.09.21.57.27;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004D2A2F086B2268F4;

1.13
date	2010.09.14.21.26.14;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004C8FE654576B0E25;

1.12
date	2010.08.28.20.22.19;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004C796FE40C544CCE;

1.11
date	2009.08.08.13.08.51;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004A7D785D73D49CFA;

1.10
date	2009.05.16.16.59.37;	author tg;	state Stab;
branches;
next	1.9;
commitid	1004A0EF0664EF4168D;

1.9
date	2009.04.07.18.56.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049DBA2033E87A04C;

1.8
date	2009.04.07.18.46.07;	author tg;	state Exp;
branches;
next	1.7;
commitid	10049DB9F806A153CF0;

1.7
date	2009.03.24.18.34.39;	author tg;	state Exp;
branches;
next	1.6;
commitid	10049C927AD7B58BA6D;

1.6
date	2009.03.24.14.07.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049C8E93044913E84;

1.5
date	2009.03.24.08.53.45;	author tg;	state Exp;
branches;
next	1.4;
commitid	10049C89FA139EADAFE;

1.4
date	2009.03.24.08.37.37;	author tg;	state Exp;
branches;
next	1.3;
commitid	10049C89BAA43E28170;

1.3
date	2009.03.23.10.31.15;	author tg;	state Exp;
branches;
next	1.2;
commitid	10049C764F555F37A1C;

1.2
date	2009.03.23.09.08.35;	author tg;	state Exp;
branches;
next	1.1;
commitid	10049C751992AEAD77C;

1.1
date	2009.03.22.16.55.38;	author tg;	state Exp;
branches;
next	;
commitid	10049C66D5D5A75A28F;

1.20.2.1
date	2015.01.25.15.35.47;	author tg;	state Exp;
branches;
next	;
commitid	10054C50D442D861FBF;


desc
@@


1.26
log
@clean up, avoid aliasing concerns in non-debug case
@
text
@/*-
 * Copyright (c) 2009, 2010, 2011, 2013, 2014, 2016
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"
#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
#include <err.h>
#endif

__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.24 2016/02/24 01:44:46 tg Exp $");

/* build with CPPFLAGS+= -DUSE_REALLOC_MALLOC=0 on ancient systems */
#if defined(USE_REALLOC_MALLOC) && (USE_REALLOC_MALLOC == 0)
#define remalloc(p,n)	((p) == NULL ? malloc_osi(n) : realloc_osi((p), (n)))
#else
#define remalloc(p,n)	realloc_osi((p), (n))
#endif


static struct lalloc_common *findptr(struct lalloc_common **, char *, Area *);

#ifndef MKSH_ALLOC_CATCH_UNDERRUNS
#define ALLOC_ISUNALIGNED(p) (((size_t)(p)) % sizeof(struct lalloc_common))
#else
#define ALLOC_ISUNALIGNED(p) (((size_t)(p)) & 4095)
#undef remalloc
#undef free_osimalloc

static void
free_osimalloc(void *ptr)
{
	struct lalloc_item *lp = ptr;

	if (munmap(lp, lp->len))
		err(1, "free_osimalloc");
}

static void *
remalloc(void *ptr, size_t size)
{
	struct lalloc_item *lp, *lold = ptr;

	size = (size + 4095) & ~(size_t)4095;

	if (lold && lold->len >= size)
		return (ptr);

	if ((lp = mmap(NULL, size, PROT_READ | PROT_WRITE,
	    MAP_ANON | MAP_PRIVATE, -1, (off_t)0)) == MAP_FAILED)
		err(1, "remalloc: mmap(%zu)", size);
	if (ALLOC_ISUNALIGNED(lp))
		errx(1, "remalloc: unaligned(%p)", lp);
	if (mprotect(((char *)lp) + 4096, 4096, PROT_NONE))
		err(1, "remalloc: mprotect");
	lp->len = size;

	if (lold) {
		memcpy(((char *)lp) + 8192, ((char *)lold) + 8192,
		    lold->len - 8192);
		if (munmap(lold, lold->len))
			err(1, "remalloc: munmap");
	}

	return (lp);
}
#endif

void
ainit(Area *ap)
{
#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
	if (sysconf(_SC_PAGESIZE) != 4096) {
		fprintf(stderr, "mksh: fatal: pagesize %lu not 4096!\n",
		    sysconf(_SC_PAGESIZE));
		fflush(stderr);
		abort();
	}
#endif
	/* area pointer and items share struct lalloc_common */
	ap->next = NULL;
}

static struct lalloc_common *
findptr(struct lalloc_common **lpp, char *ptr, Area *ap)
{
	void *lp;

#ifndef MKSH_SMALL
	if (ALLOC_ISUNALIGNED(ptr))
		goto fail;
#endif
	/* get address of ALLOC_ITEM from user item */
	/*
	 * note: the alignment of "ptr" to ALLOC_ITEM is checked
	 * above; the "void *" gets us rid of a gcc 2.95 warning
	 */
	*lpp = (lp = ptr - sizeof(ALLOC_ITEM));
	/* search for allocation item in group list */
	while (ap->next != lp)
		if ((ap = ap->next) == NULL) {
#ifndef MKSH_SMALL
 fail:
#endif
#ifdef DEBUG
			internal_warningf("rogue pointer %zX in ap %zX",
			    (size_t)ptr, (size_t)ap);
			/* try to get a coredump */
			abort();
#else
			internal_errorf("rogue pointer %zX", (size_t)ptr);
#endif
		}
	return (ap);
}

void *
aresize2(void *ptr, size_t fac1, size_t fac2, Area *ap)
{
	if (notoktomul(fac1, fac2))
		internal_errorf(Tintovfl, fac1, '*', fac2);
	return (aresize(ptr, fac1 * fac2, ap));
}

void *
aresize(void *ptr, size_t numb, Area *ap)
{
	struct lalloc_common *lp = NULL;

	/* resizing (true) or newly allocating? */
	if (ptr != NULL) {
		struct lalloc_common *pp;

		pp = findptr(&lp, ptr, ap);
		pp->next = lp->next;
	}

	if (notoktoadd(numb, sizeof(ALLOC_ITEM)) ||
	    (lp = remalloc(lp, numb + sizeof(ALLOC_ITEM))) == NULL
#ifndef MKSH_SMALL
	    || ALLOC_ISUNALIGNED(lp)
#endif
	    )
		internal_errorf(Toomem, numb);
	/* area pointer and items share struct lalloc_common */
	lp->next = ap->next;
	ap->next = lp;
	/* return user item address */
	return ((char *)lp + sizeof(ALLOC_ITEM));
}

void
afree(void *ptr, Area *ap)
{
	if (ptr != NULL) {
		struct lalloc_common *lp, *pp;

		pp = findptr(&lp, ptr, ap);
		/* unhook */
		pp->next = lp->next;
		/* now free ALLOC_ITEM */
		free_osimalloc(lp);
	}
}

void
afreeall(Area *ap)
{
	struct lalloc_common *lp;

	/* traverse group (linked list) */
	while ((lp = ap->next) != NULL) {
		/* make next ALLOC_ITEM head of list */
		ap->next = lp->next;
		/* free old head */
		free_osimalloc(lp);
	}
}
@


1.25
log
@share structures better, less (void *) casts when we can stay typed
@
text
@d39 1
a39 1
#define ALLOC_ISUNALIGNED(p) (((size_t)(p)) % ALLOC_SIZE)
d110 1
a110 1
	 * note: the alignment of "ptr" to ALLOC_SIZE is checked
d113 1
a113 1
	*lpp = (lp = ptr - ALLOC_SIZE);
d129 1
a129 1
	return ((void *)ap);
d153 2
a154 2
	if (notoktoadd(numb, ALLOC_SIZE) ||
	    (lp = remalloc(lp, numb + ALLOC_SIZE)) == NULL
d160 1
a160 1
	/* this only works because Area and ALLOC_ITEM share lalloc_common */
d164 1
a164 1
	return ((char *)lp + ALLOC_SIZE);
@


1.24
log
@implement mmap-using mechanism to catch buffer underruns inside mksh
(pulls stdio, is rather BSD-specific and memory-hungry and a bit slow)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.23 2015/11/29 17:05:01 tg Exp $");
d36 1
a36 1
static ALLOC_ITEM *findptr(ALLOC_ITEM **, char *, Area *);
d48 1
a48 1
	struct lalloc *lp = ptr;
d57 1
a57 1
	struct lalloc *lp, *lold = ptr;
d95 1
a95 1
	/* area pointer is an ALLOC_ITEM, just the head of the list */
d99 2
a100 2
static ALLOC_ITEM *
findptr(ALLOC_ITEM **lpp, char *ptr, Area *ap)
d143 1
a143 1
	ALLOC_ITEM *lp = NULL;
d147 1
a147 1
		ALLOC_ITEM *pp;
d160 1
a160 1
	/* this only works because Area is an ALLOC_ITEM */
d162 1
a162 1
	ap->next = (void *)lp;
d171 1
a171 1
		ALLOC_ITEM *lp, *pp;
d184 1
a184 1
	Area *lp;
@


1.23
log
@janitorial work
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010, 2011, 2013, 2014
d22 3
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.20 2013/06/03 22:28:33 tg Exp $");
d35 4
d40 18
d59 24
a82 1
static ALLOC_ITEM *findptr(ALLOC_ITEM **, char *, Area *);
d87 8
d129 1
a129 1
	return (ap);
d162 1
a162 1
	ap->next = lp;
d184 1
a184 1
	ALLOC_ITEM *lp;
@


1.22
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d3 1
a3 1
 *	mirabilos <tg@@mirbsd.org>
@


1.21
log
@stop using ptrdiff_t
@
text
@d3 1
a3 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.20
log
@use ‘z’ shf printf modifier for out-of-memory message, now that we have it
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010, 2011, 2013
d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.18 2011/08/27 18:06:47 tg Exp $");
d32 1
a32 1
#define ALLOC_ISUNALIGNED(p) (((ptrdiff_t)(p)) % ALLOC_SIZE)
@


1.20.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010, 2011, 2013, 2014
d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.20 2013/06/03 22:28:33 tg Exp $");
d32 1
a32 1
#define ALLOC_ISUNALIGNED(p) (((size_t)(p)) % ALLOC_SIZE)
@


1.19
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010, 2011
d103 1
a103 1
		internal_errorf(Toomem, (unsigned long)numb);
@


1.18
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.17 2011/03/13 10:50:44 tg Exp $");
d80 1
a80 1
		internal_errorf(T_intovfl, fac1, '*', fac2);
d103 1
a103 1
		internal_errorf(T_oomem, (unsigned long)numb);
@


1.17
log
@if DEBUG, abort() on rogue pointers
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.16 2011/03/05 21:48:09 tg Exp $");
d65 2
a66 2
			internal_warningf("rogue pointer %lX in ap %lX",
			    (long)(ptrdiff_t)ptr, (long)(ptrdiff_t)ap);
d70 1
a70 2
			internal_errorf("rogue pointer %lX",
			    (long)(ptrdiff_t)ptr);
d80 1
a80 2
		internal_errorf(T_intovfl, (unsigned long)fac1, '*',
		    (unsigned long)fac2);
@


1.16
log
@split malloc_os and friends further into
• functions called by mksh’s grouping memory allocator
• functions called by mksh code itself

the latter may be changed to call the internal grouping allocator,
if a porter so desires (but if this were recommended, the code in
question would already do so, so…)
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.15 2011/03/05 21:43:16 tg Exp $");
d64 6
d72 1
@


1.15
log
@introduce macros for malloc, realloc, free to hide them from mksh

no code may henceforth use memory (de-)allocation functions directly
use these macros, porters can change them for abstraction
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.14 2011/01/09 21:57:27 tg Exp $");
d27 1
a27 1
#define remalloc(p,n)	((p) == NULL ? malloc_os(n) : realloc_os((p), (n)))
d29 1
a29 1
#define remalloc(p,n)	realloc_os((p), (n))
d116 1
a116 1
		free_osmalloc(lp);
d130 1
a130 1
		free_osmalloc(lp);
@


1.14
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Lëtzebuerg ☺

This was the third try. Where to put this was not palpable… same for =(…)
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.13 2010/09/14 21:26:14 tg Exp $");
d27 1
a27 1
#define remalloc(p,n)	((p) == NULL ? malloc(n) : realloc((p), (n)))
d29 1
a29 1
#define remalloc(p,n)	realloc((p), (n))
d116 1
a116 1
		free(lp);
d130 1
a130 1
		free(lp);
@


1.13
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010
d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.12 2010/08/28 20:22:19 tg Exp $");
d73 1
a73 1
	if (fac1 && fac2 && (SIZE_MAX / fac1 < fac2))
d98 1
a98 2
		internal_errorf("can't allocate %lu data bytes",
		    (unsigned long)numb);
@


1.12
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.11 2009/08/08 13:08:51 tg Exp $");
d71 9
d92 1
a92 1
	if ((numb >= SIZE_MAX - ALLOC_SIZE) ||
@


1.11
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d2 1
a2 1
 * Copyright © 2009
d7 1
a7 1
 * is granted to deal in this work without restriction, including un‐
d11 1
a11 1
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
d18 1
a18 1
 * of said person’s immediate fault when using the work as intended.
d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.10 2009/05/16 16:59:37 tg Stab $");
d64 2
a65 1
			internal_errorf("rogue pointer %p", ptr);
d89 1
a89 1
		internal_errorf("cannot allocate %lu data bytes",
@


1.10
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.9 2009/04/07 18:56:51 tg Exp $");
d32 2
d46 6
d53 5
a57 1
	*lpp = (ALLOC_ITEM *)(ptr - ALLOC_SIZE);
d59 5
a63 2
	while (ap->next != *lpp)
		if ((ap = ap->next) == NULL)
d65 1
d83 5
a87 1
	    (lp = remalloc(lp, numb + ALLOC_SIZE)) == NULL)
@


1.9
log
@employ some "nice" constants and comment lalloc.c
@
text
@d1 20
d23 1
a23 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.7 2009/03/24 18:34:39 tg Exp $");
@


1.8
log
@globalise SIZE_MAX definition
@
text
@d12 1
a12 1
static struct lalloc *findptr(struct lalloc **, char *, Area *);
d17 1
d21 2
a22 2
static struct lalloc *
findptr(struct lalloc **lpp, char *ptr, Area *ap)
d24 3
a26 1
	*lpp = (struct lalloc *)(ptr - sizeof (struct lalloc));
d36 1
a36 1
	struct lalloc *lp = NULL;
d38 1
d40 1
a40 1
		struct lalloc *pp;
d46 2
a47 2
	if ((numb >= SIZE_MAX - sizeof (struct lalloc)) ||
	    (lp = remalloc(lp, numb + sizeof (struct lalloc))) == NULL)
d50 1
d53 2
a54 1
	return ((char *)lp + sizeof (struct lalloc));
d61 1
a61 1
		struct lalloc *lp, *pp;
d64 1
d66 1
d74 1
a74 1
	struct lalloc *lp;
d76 1
d78 1
d80 1
@


1.7
log
@just assume realloc(NULL, n) is ANSI C89 (for n>0) but provide a
define to do otherwise; shrinks the code and optimises for speed
@
text
@d3 1
a3 9
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.6 2009/03/24 14:07:41 tg Exp $");

#ifndef SIZE_MAX
#ifdef SIZE_T_MAX
#define SIZE_MAX	SIZE_T_MAX
#else
#define SIZE_MAX	((size_t)-1)
#endif
#endif
@


1.6
log
@fix up a bogus gcc4 uninitialised storage warning
(we’d initialise this to NULL anyway if we used realloc-can-take-NULL)
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.5 2009/03/24 08:53:45 tg Exp $");
d13 7
d51 1
a51 3
	    /* here I wish all realloc(3)s would take NULL */
	    (lp = ptr ? realloc(lp, numb + sizeof (struct lalloc)) :
	    malloc(numb + sizeof (struct lalloc))) == NULL)
@


1.5
log
@further simplify

XXX check whose platforms’ realloc(3) don’t take NULL
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.4 2009/03/24 08:37:37 tg Exp $");
d34 1
a34 1
	struct lalloc *lp;
@


1.4
log
@we do not need the group backpointer, except for a (very little) amount
of sanitising; since this is supposed to be the lightweight allocator,
with the guarding allocator coming back in later, remove it

reduces memory consumption below what espie's allocator used ☺
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.3 2009/03/23 10:31:15 tg Exp $");
d13 1
a13 5
struct lalloc {
	struct lalloc *next;	/* entry pointer, must be first */
};

static void findptr(struct lalloc **, struct lalloc **, char *, Area *);
d18 1
a18 1
	ap->ent = NULL;
d21 2
a22 2
static void
findptr(struct lalloc **lpp, struct lalloc **ppp, char *ptr, Area *ap)
d25 4
a28 4
	*ppp = (struct lalloc *)ap;
	while ((*ppp)->next != *lpp)
		if (((*ppp) = (*ppp)->next) == NULL)
			internal_errorf("pointer %p not in group %p", ptr, ap);
d34 1
a34 1
	struct lalloc *lp, *pp;
d36 2
a37 2
	if (numb >= SIZE_MAX - sizeof (struct lalloc))
		goto failure;
d39 2
a40 6
	if (ptr == NULL) {
		pp = (struct lalloc *)ap;
		lp = malloc(numb + sizeof (struct lalloc));
	} else {
		findptr(&lp, &pp, ptr, ap);
		lp = realloc(lp, numb + sizeof (struct lalloc));
d42 5
a46 2
	if (lp == NULL) {
 failure:
d49 2
a50 5
	}
	if (ptr == NULL) {
		lp->next = ap->ent;
	}
	pp->next = lp;
d57 2
a58 1
	struct lalloc *lp, *pp;
d60 4
a63 6
	if (ptr == NULL)
		return;

	findptr(&lp, &pp, ptr, ap);
	pp->next = lp->next;
	free(lp);
d71 2
a72 2
	while ((lp = ap->ent) != NULL) {
		ap->ent = lp->next;
@


1.3
log
@sometimes I have tomatoes on my eyes (or is it the CRT monitor?)
make SIZE_MAX portable, 10x to Jonathan “ciruZ” Schleifer for the hint
@
text
@d3 1
a3 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.2 2009/03/23 09:08:35 tg Exp $");
a14 1
	Area *group;		/* group backpointer */
a28 3
	if ((*lpp)->group != ap)
 notfound:
		internal_errorf("pointer %p not in group %p", ptr, ap);
d32 1
a32 1
			goto notfound;
a55 1
		lp->group = ap;
a71 1
	/* lp->group = NULL; */
a80 4
#ifndef MKSH_SMALL
		if (lp->group != ap)
			internal_errorf("rogue pointer in group %p", ap);
#endif
a81 1
		/* lp->group = NULL; */
@


1.2
log
@unbreak with dietlibc, whose <stdint.h> has no SIZE_MAX, defying SUSv3
@
text
@d3 9
a11 1
__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.1 2009/03/22 16:55:38 tg Exp $");
a43 1
#ifdef SIZE_MAX
a45 1
#endif
a54 1
#ifdef SIZE_MAX
a55 1
#endif
@


1.1
log
@remove espie's double-linked-list based allocator and write a
similarily simple one from scratch, which however performs
better than espie's with AFREE_DEBUG enabled which took away
the benefit of the double-linked-list approach

all of (core) mksh is now MirOS licenced
@
text
@d3 1
a3 1
__RCSID("$MirOS$");
d36 1
d38 2
a39 3
 failure:
		internal_errorf("cannot allocate %lu data bytes",
		    (unsigned long)numb);
d48 7
a54 2
	if (lp == NULL)
		goto failure;
@

