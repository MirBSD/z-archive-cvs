head	1.360;
access;
symbols
	mksh-R57:1.355
	mksh-R56c:1.353
	mksh-R56b:1.350
	mksh-R56:1.350
	mksh-R55:1.340
	mksh-R54:1.319
	mksh-R53a:1.305
	mksh-R53:1.305
	mksh-R52c:1.295
	mksh-R52b:1.293
	mksh-R52:1.288
	mksh-R51:1.280
	mksh-R50f:1.259.2.5
	mksh-R50e:1.259.2.2
	mksh-R50stable:1.259.0.2
	mksh-R50d:1.258
	mksh-R50c:1.258
	mksh-R50b:1.257
	mksh-R50:1.256
	mksh-R49:1.254
	mksh-R48b:1.244
	mksh-R48:1.244
	mksh-R47:1.244
	mksh-R46:1.243
	mksh-R45:1.242
	mksh-R44:1.238
	mksh-R43:1.238
	mksh-R42b:1.237
	mksh-R41c:1.230.2.3
	mksh-R41b:1.230.2.3
	mksh-R42:1.237
	mksh-R41:1.230
	mksh-R41stable:1.230.0.2
	mksh-wheezy:1.222.0.2
	tg-multikey-bind:1.218.0.2
	mksh-R40f:1.204.2.2
	mksh-R40e:1.204.2.1
	mksh-R40d:1.204
	mksh-R40c:1.199
	mksh-R40b:1.193
	mksh-R40stable:1.204.0.2
	mksh-R40:1.189
	mksh-R39c:1.151
	mksh-R39b:1.150
	tg-wcswidth-behaviour:1.142.0.2
	tg-nameref:1.127.0.2
	mksh-R39:1.119
	tg-mksh-printf-builtin:1.115.0.2
	mksh-R38c:1.114
	mksh-R38b:1.109
	mksh-R38:1.109
	mksh-R37c:1.104
	mksh-R37b:1.103
	mksh-R37:1.100
	mksh-R36b:1.93
	tg-aalloc-experimental_BASE:1.92
	tg-aalloc-experimental:1.92.0.2
	mksh-R36:1.89
	mksh-R35b:1.85
	mksh-R35:1.83
	mksh-R33d:1.75
	mksh-R33c:1.75
	mksh-R33b:1.72
	MIRBSD_10:1.69.0.2
	MIRBSD_10_BASE:1.69
	mksh-R33:1.69
	mksh-R32:1.67
	mksh-R31d:1.65
	mksh-R31c:1.65
	mksh-R31b:1.65
	mksh-R31:1.64
	mksh-R30:1.60
	mksh-R29g:1.49.2.2
	mksh-R29f:1.49.2.1
	mksh-R29e:1.49.2.1
	mksh-R29stable:1.49.0.2
	mksh-R29d:1.49
	mksh-R29c:1.49
	mksh-R29b:1.49
	mksh-R29:1.48
	mksh-R28:1.30
	tg-mksh-plan9ape_BASE:1.30
	tg-mksh-plan9ape:1.29.0.2
	mksh-R27e:1.28
	MIRBSD_9_BASE:1.27
	mksh-R27d:1.27
	mksh-R27:1.27
	mksh-R26c:1.25
	mksh-R26b:1.24
	MIRBSD_8:1.24.0.2
	MIRBSD_8_BASE:1.24
	mksh-R26:1.24
	mksh-R25:1.23
	mksh-R24c:1.18
	mksh-R24b:1.16
	mksh-R24:1.15
	mksh-R23:1.11
	mksh-R22:1.9
	mksh-R21:1.5;
locks; strict;
comment	@ * @;


1.360
date	2019.12.30.03.58.55;	author tg;	state Exp;
branches;
next	1.359;
commitid	1005E09760D6DFD4643;

1.359
date	2019.12.30.01.15.57;	author tg;	state Exp;
branches;
next	1.358;
commitid	1005E094FE436511ED6;

1.358
date	2019.12.30.01.10.56;	author tg;	state Exp;
branches;
next	1.357;
commitid	1005E094E9A55F97D93;

1.357
date	2019.08.02.19.27.15;	author tg;	state Exp;
branches;
next	1.356;
commitid	1005D448E820CFAF8FF;

1.356
date	2019.08.01.23.59.50;	author tg;	state Exp;
branches;
next	1.355;
commitid	1005D437D0C19D901EA;

1.355
date	2018.10.20.21.04.28;	author tg;	state Exp;
branches;
next	1.354;
commitid	1005BCB9859361CD756;

1.354
date	2018.08.10.02.53.34;	author tg;	state Exp;
branches;
next	1.353;
commitid	1005B6CFE0B5BDFE404;

1.353
date	2018.01.14.01.26.49;	author tg;	state Exp;
branches;
next	1.352;
commitid	1005A5AB1EE15F8550C;

1.352
date	2018.01.13.23.55.11;	author tg;	state Exp;
branches;
next	1.351;
commitid	1005A5A9C627E45C2B1;

1.351
date	2017.11.20.02.32.32;	author tg;	state Exp;
branches;
next	1.350;
commitid	1005A123ED742C612BD;

1.350
date	2017.05.05.22.53.28;	author tg;	state Exp;
branches;
next	1.349;
commitid	100590D026845CD3DFF;

1.349
date	2017.04.28.11.48.46;	author tg;	state Exp;
branches;
next	1.348;
commitid	10059032C385FDD2325;

1.348
date	2017.04.28.00.38.30;	author tg;	state Exp;
branches;
next	1.347;
commitid	10059028F0E0808B3E9;

1.347
date	2017.04.27.23.33.18;	author tg;	state Exp;
branches;
next	1.346;
commitid	10059027FC444EF0ED1;

1.346
date	2017.04.27.23.18.05;	author tg;	state Exp;
branches;
next	1.345;
commitid	10059027C4617FA775E;

1.345
date	2017.04.27.23.12.46;	author tg;	state Exp;
branches;
next	1.344;
commitid	10059027AFC0DEF48C9;

1.344
date	2017.04.27.20.22.24;	author tg;	state Exp;
branches;
next	1.343;
commitid	1005902531266D3FCB6;

1.343
date	2017.04.27.19.33.48;	author tg;	state Exp;
branches;
next	1.342;
commitid	100590247A92C66CAF9;

1.342
date	2017.04.21.19.50.07;	author tg;	state Exp;
branches;
next	1.341;
commitid	10058FA61D94E9BD833;

1.341
date	2017.04.17.19.51.46;	author tg;	state Exp;
branches;
next	1.340;
commitid	10058F51CD7435931DA;

1.340
date	2017.04.12.17.46.29;	author tg;	state Exp;
branches;
next	1.339;
commitid	10058EE68094658C8E6;

1.339
date	2017.04.12.17.38.44;	author tg;	state Exp;
branches;
next	1.338;
commitid	10058EE65E065F6F62F;

1.338
date	2017.04.08.01.07.15;	author tg;	state Exp;
branches;
next	1.337;
commitid	10058E837C565871E52;

1.337
date	2017.04.06.19.02.05;	author tg;	state Exp;
branches;
next	1.336;
commitid	10058E690B12E36D308;

1.336
date	2017.04.06.01.59.55;	author tg;	state Exp;
branches;
next	1.335;
commitid	10058E5A1067AFA1BBA;

1.335
date	2017.04.06.00.53.33;	author tg;	state Exp;
branches;
next	1.334;
commitid	10058E5919F0E16D269;

1.334
date	2017.04.02.16.47.41;	author tg;	state Exp;
branches;
next	1.333;
commitid	10058E12B3D7E04D5CE;

1.333
date	2017.04.02.15.51.19;	author tg;	state Exp;
branches;
next	1.332;
commitid	10058E11DFA37740F34;

1.332
date	2017.04.02.15.00.42;	author tg;	state Exp;
branches;
next	1.331;
commitid	10058E1121E64BBAB7B;

1.331
date	2017.03.22.00.20.41;	author tg;	state Exp;
branches;
next	1.330;
commitid	10058D1C35C5D0C4C46;

1.330
date	2017.03.19.20.59.25;	author tg;	state Exp;
branches;
next	1.329;
commitid	10058CEF1322163CCA4;

1.329
date	2017.03.19.18.05.28;	author tg;	state Exp;
branches;
next	1.328;
commitid	10058CEC80C3DBAE4A3;

1.328
date	2017.03.17.22.45.50;	author tg;	state Exp;
branches;
next	1.327;
commitid	10058CC671F1DF58730;

1.327
date	2017.03.12.02.31.01;	author tg;	state Exp;
branches;
next	1.326;
commitid	10058C4B2EC5EA5315F;

1.326
date	2017.03.12.02.04.13;	author tg;	state Exp;
branches;
next	1.325;
commitid	10058C4AC2520F8C875;

1.325
date	2017.03.11.23.22.35;	author tg;	state Exp;
branches;
next	1.324;
commitid	10058C486CF5C28D59E;

1.324
date	2017.03.11.23.10.40;	author tg;	state Exp;
branches;
next	1.323;
commitid	10058C483F21463C185;

1.323
date	2017.02.18.02.33.11;	author tg;	state Exp;
branches;
next	1.322;
commitid	10058A7B271530B4CED;

1.322
date	2017.02.18.01.27.24;	author tg;	state Exp;
branches;
next	1.321;
commitid	10058A7A314105B4908;

1.321
date	2017.02.17.22.28.25;	author tg;	state Exp;
branches;
next	1.320;
commitid	10058A7787B2AD8F280;

1.320
date	2017.02.08.15.27.27;	author tg;	state Exp;
branches;
next	1.319;
commitid	100589B38BF61621DC3;

1.319
date	2016.11.11.23.48.29;	author tg;	state Exp;
branches;
next	1.318;
commitid	100582658D43CBE5F67;

1.318
date	2016.11.11.22.17.08;	author tg;	state Exp;
branches;
next	1.317;
commitid	100582643716D65E29A;

1.317
date	2016.11.11.21.37.35;	author tg;	state Exp;
branches;
next	1.316;
commitid	10058263A3857C05DFD;

1.316
date	2016.11.11.21.13.23;	author tg;	state Exp;
branches;
next	1.315;
commitid	1005826347D6811313F;

1.315
date	2016.11.11.20.53.15;	author tg;	state Exp;
branches;
next	1.314;
commitid	10058262FC911A84022;

1.314
date	2016.11.11.20.14.17;	author tg;	state Exp;
branches;
next	1.313;
commitid	100582626A23DD889A9;

1.313
date	2016.11.11.19.59.39;	author tg;	state Exp;
branches;
next	1.312;
commitid	1005826231A4E1347A4;

1.312
date	2016.11.11.19.18.40;	author tg;	state Exp;
branches;
next	1.311;
commitid	100582619A15B2F5A66;

1.311
date	2016.11.11.19.12.52;	author tg;	state Exp;
branches;
next	1.310;
commitid	10058261844423887EA;

1.310
date	2016.11.11.19.09.44;	author tg;	state Exp;
branches;
next	1.309;
commitid	1005826177E6A5F3F44;

1.309
date	2016.11.11.19.02.26;	author tg;	state Exp;
branches;
next	1.308;
commitid	100582615D0701267F3;

1.308
date	2016.11.11.18.50.09;	author tg;	state Exp;
branches;
next	1.307;
commitid	100582612F673CFB8D7;

1.307
date	2016.11.11.18.44.31;	author tg;	state Exp;
branches;
next	1.306;
commitid	1005826119C559470A3;

1.306
date	2016.08.25.16.21.14;	author tg;	state Exp;
branches;
next	1.305;
commitid	10057BF1B130A5DA757;

1.305
date	2016.08.01.21.38.02;	author tg;	state Exp;
branches;
next	1.304;
commitid	100579FC12F14735847;

1.304
date	2016.08.01.14.23.24;	author tg;	state Exp;
branches;
next	1.303;
commitid	100579F5B684191026F;

1.303
date	2016.07.28.21.39.18;	author tg;	state Exp;
branches;
next	1.302;
commitid	100579A7B9C449E55CC;

1.302
date	2016.07.26.21.50.44;	author tg;	state Exp;
branches;
next	1.301;
commitid	1005797DB49584A72A4;

1.301
date	2016.07.25.20.38.02;	author tg;	state Exp;
branches;
next	1.300;
commitid	100579678BA313AF68F;

1.300
date	2016.07.25.00.04.42;	author tg;	state Exp;
branches;
next	1.299;
commitid	1005795579F14A3FE5C;

1.299
date	2016.07.24.23.11.50;	author tg;	state Exp;
branches;
next	1.298;
commitid	10057954B4566C36674;

1.298
date	2016.07.24.23.10.02;	author tg;	state Exp;
branches;
next	1.297;
commitid	10057954AD0356E0260;

1.297
date	2016.06.26.00.44.25;	author tg;	state Exp;
branches;
next	1.296;
commitid	100576F25784010816B;

1.296
date	2016.06.25.23.52.46;	author tg;	state Exp;
branches;
next	1.295;
commitid	100576F196341817163;

1.295
date	2016.02.26.20.56.43;	author tg;	state Exp;
branches;
next	1.294;
commitid	10056D0BC0C02AF3EE5;

1.294
date	2016.01.21.18.24.39;	author tg;	state Exp;
branches;
next	1.293;
commitid	10056A12268001BF859;

1.293
date	2016.01.20.21.34.11;	author tg;	state Exp;
branches;
next	1.292;
commitid	100569FFD594609A81E;

1.292
date	2016.01.20.20.29.48;	author tg;	state Exp;
branches;
next	1.291;
commitid	100569FEE484EBF7D53;

1.291
date	2016.01.19.23.12.13;	author tg;	state Exp;
branches;
next	1.290;
commitid	100569EC2AE617A4288;

1.290
date	2016.01.14.22.49.31;	author tg;	state Exp;
branches;
next	1.289;
commitid	100569825E73343E900;

1.289
date	2016.01.13.17.20.49;	author tg;	state Exp;
branches;
next	1.288;
commitid	1005696877B782808CD;

1.288
date	2015.12.12.19.27.36;	author tg;	state Exp;
branches;
next	1.287;
commitid	100566C751428736AD5;

1.287
date	2015.10.24.19.46.09;	author tg;	state Exp;
branches;
next	1.286;
commitid	100562BE0036C605830;

1.286
date	2015.10.09.21.36.55;	author tg;	state Exp;
branches;
next	1.285;
commitid	100561833456A230F8F;

1.285
date	2015.10.09.17.48.50;	author tg;	state Exp;
branches;
next	1.284;
commitid	1005617FE066005352E;

1.284
date	2015.10.09.16.11.14;	author tg;	state Exp;
branches;
next	1.283;
commitid	1005617E72E4A2BA371;

1.283
date	2015.09.05.19.19.04;	author tg;	state Exp;
branches;
next	1.282;
commitid	10055EB402C54C3076B;

1.282
date	2015.08.13.21.38.17;	author tg;	state Exp;
branches;
next	1.281;
commitid	10055CD0E35383B51C9;

1.281
date	2015.08.13.21.04.11;	author tg;	state Exp;
branches;
next	1.280;
commitid	10055CD064A7F3E0C1E;

1.280
date	2015.07.09.20.52.39;	author tg;	state Exp;
branches;
next	1.279;
commitid	100559EDF161DEE9DD2;

1.279
date	2015.07.09.20.20.42;	author tg;	state Exp;
branches;
next	1.278;
commitid	100559ED7A80A374D9C;

1.278
date	2015.07.09.19.46.41;	author tg;	state Exp;
branches;
next	1.277;
commitid	100559ECFAC4F39D69B;

1.277
date	2015.07.06.17.48.32;	author tg;	state Exp;
branches;
next	1.276;
commitid	100559ABF230C8CC8EB;

1.276
date	2015.07.05.19.37.14;	author tg;	state Exp;
branches;
next	1.275;
commitid	1005599876B5247136B;

1.275
date	2015.07.05.17.50.39;	author tg;	state Exp;
branches;
next	1.274;
commitid	10055996E6F5E6AD356;

1.274
date	2015.07.05.14.43.06;	author tg;	state Exp;
branches;
next	1.273;
commitid	100559942841CED5205;

1.273
date	2015.06.28.14.57.24;	author tg;	state Exp;
branches;
next	1.272;
commitid	10055900B357361C966;

1.272
date	2015.05.01.23.16.29;	author tg;	state Exp;
branches;
next	1.271;
commitid	100554409082C43CC56;

1.271
date	2015.04.29.20.44.34;	author tg;	state Exp;
branches;
next	1.270;
commitid	100554142C5624212CA;

1.270
date	2015.04.29.20.07.32;	author tg;	state Exp;
branches;
next	1.269;
commitid	100554139453DB97755;

1.269
date	2015.04.29.18.32.43;	author tg;	state Exp;
branches;
next	1.268;
commitid	100554123E246E02963;

1.268
date	2015.04.19.14.40.23;	author tg;	state Exp;
branches;
next	1.267;
commitid	1005533BE6B244DD087;

1.267
date	2015.04.11.21.18.47;	author tg;	state Exp;
branches;
next	1.266;
commitid	10055298FBA6FED7EF3;

1.266
date	2015.03.20.21.01.41;	author tg;	state Exp;
branches;
next	1.265;
commitid	100550C8AB742C7A57C;

1.265
date	2015.03.08.21.30.20;	author tg;	state Exp;
branches;
next	1.264;
commitid	10054FCBF786B35A495;

1.264
date	2015.01.04.21.08.09;	author tg;	state Exp;
branches;
next	1.263;
commitid	10054A9ABCF7F3049A5;

1.263
date	2015.01.04.20.37.59;	author tg;	state Exp;
branches;
next	1.262;
commitid	10054A9A4AF36B9DAFC;

1.262
date	2014.12.15.23.18.47;	author tg;	state Exp;
branches;
next	1.261;
commitid	100548F6C16391FF689;

1.261
date	2014.11.25.21.13.25;	author tg;	state Exp;
branches;
next	1.260;
commitid	1005474F00E09321C83;

1.260
date	2014.11.25.20.00.37;	author tg;	state Exp;
branches;
next	1.259;
commitid	1005474DFFB1DC897E5;

1.259
date	2014.10.12.21.58.51;	author tg;	state Exp;
branches
	1.259.2.1;
next	1.258;
commitid	100543AF9780895A8EB;

1.258
date	2014.09.03.19.55.51;	author tg;	state Exp;
branches;
next	1.257;
commitid	1005407724D3E42B05E;

1.257
date	2014.07.28.21.45.44;	author tg;	state Exp;
branches;
next	1.256;
commitid	10053D6C428265C691A;

1.256
date	2014.06.09.13.25.52;	author tg;	state Exp;
branches;
next	1.255;
commitid	1005395B5803902C8E9;

1.255
date	2014.05.27.13.22.44;	author tg;	state Exp;
branches;
next	1.254;
commitid	1005384911C31753F0C;

1.254
date	2014.01.05.19.20.31;	author tg;	state Exp;
branches;
next	1.253;
commitid	10052C9B08B0BF0A364;

1.253
date	2014.01.05.19.11.44;	author tg;	state Exp;
branches;
next	1.252;
commitid	10052C9AE727A4482D3;

1.252
date	2013.11.30.17.41.34;	author tg;	state Exp;
branches;
next	1.251;
commitid	100529A23520014334E;

1.251
date	2013.11.30.17.33.49;	author tg;	state Exp;
branches;
next	1.250;
commitid	100529A2193602D314C;

1.250
date	2013.11.17.22.21.17;	author tg;	state Exp;
branches;
next	1.249;
commitid	100528941705C91094F;

1.249
date	2013.11.17.22.20.20;	author tg;	state Exp;
branches;
next	1.248;
commitid	100528941373127E2E8;

1.248
date	2013.11.17.22.19.41;	author tg;	state Exp;
branches;
next	1.247;
commitid	100528941112B1A0586;

1.247
date	2013.10.09.11.59.27;	author tg;	state Exp;
branches;
next	1.246;
commitid	10052554535524C4C97;

1.246
date	2013.09.10.17.33.00;	author tg;	state Exp;
branches;
next	1.245;
commitid	100522F57C13E265FDE;

1.245
date	2013.09.10.16.30.49;	author tg;	state Exp;
branches;
next	1.244;
commitid	100522F49426994853D;

1.244
date	2013.06.03.22.28.32;	author tg;	state Exp;
branches;
next	1.243;
commitid	10051AD18A44752B56B;

1.243
date	2013.05.02.20.21.41;	author tg;	state Exp;
branches;
next	1.242;
commitid	1005182CAE814B1B129;

1.242
date	2013.04.26.21.22.45;	author tg;	state Exp;
branches;
next	1.241;
commitid	100517AEF6C22DD1AE7;

1.241
date	2013.04.26.17.39.28;	author tg;	state Exp;
branches;
next	1.240;
commitid	100517ABB8868994F9D;

1.240
date	2013.03.30.15.39.36;	author tg;	state Exp;
branches;
next	1.239;
commitid	100515707510F5AC6E1;

1.239
date	2013.03.24.21.34.13;	author tg;	state Exp;
branches;
next	1.238;
commitid	100514F71661744EE30;

1.238
date	2013.02.18.22.47.32;	author tg;	state Exp;
branches;
next	1.237;
commitid	1005122AF934BA2D211;

1.237
date	2013.01.01.20.45.02;	author tg;	state Exp;
branches;
next	1.236;
commitid	10050E34AE3215C257E;

1.236
date	2012.12.28.02.28.34;	author tg;	state Exp;
branches;
next	1.235;
commitid	10050DD03E43C678B81;

1.235
date	2012.12.17.23.18.04;	author tg;	state Exp;
branches;
next	1.234;
commitid	10050CFA81334F40D7F;

1.234
date	2012.12.17.23.09.15;	author tg;	state Exp;
branches;
next	1.233;
commitid	10050CFA62B7EDC8DD1;

1.233
date	2012.12.08.18.30.30;	author tg;	state Exp;
branches;
next	1.232;
commitid	10050C3875A3CBDA8F8;

1.232
date	2012.12.04.01.18.28;	author tg;	state Exp;
branches;
next	1.231;
commitid	10050BD4F7642624FD1;

1.231
date	2012.12.01.01.36.23;	author tg;	state Exp;
branches;
next	1.230;
commitid	10050B95F03690E9DEE;

1.230
date	2012.10.30.20.13.18;	author tg;	state Exp;
branches
	1.230.2.1;
next	1.229;
commitid	100509034F50DD7C6D5;

1.229
date	2012.10.30.20.06.49;	author tg;	state Exp;
branches;
next	1.228;
commitid	100509033714072F318;

1.228
date	2012.10.21.21.55.03;	author tg;	state Exp;
branches;
next	1.227;
commitid	10050846F101988A117;

1.227
date	2012.10.21.21.39.02;	author tg;	state Exp;
branches;
next	1.226;
commitid	10050846B5B2B1A2932;

1.226
date	2012.10.03.17.24.19;	author tg;	state Exp;
branches;
next	1.225;
commitid	100506C74D35719B33B;

1.225
date	2012.10.03.16.16.12;	author tg;	state Exp;
branches;
next	1.224;
commitid	100506C64E4724B9215;

1.224
date	2012.10.03.15.13.31;	author tg;	state Exp;
branches;
next	1.223;
commitid	100506C56316A8B5F1D;

1.223
date	2012.08.03.18.30.13;	author tg;	state Exp;
branches;
next	1.222;
commitid	100501C18CD123A6918;

1.222
date	2012.06.25.16.34.58;	author tg;	state Exp;
branches
	1.222.2.1;
next	1.221;
commitid	1004FE89345267ADDF9;

1.221
date	2012.06.25.16.17.54;	author tg;	state Exp;
branches;
next	1.220;
commitid	1004FE88F4450CF3826;

1.220
date	2012.06.24.20.00.51;	author tg;	state Exp;
branches;
next	1.219;
commitid	1004FE772034333E290;

1.219
date	2012.05.09.23.20.56;	author tg;	state Exp;
branches;
next	1.218;
commitid	1004FAAFBED1D226CAF;

1.218
date	2012.05.04.22.18.24;	author tg;	state Exp;
branches;
next	1.217;
commitid	1004FA455C411397094;

1.217
date	2012.05.04.22.05.00;	author tg;	state Exp;
branches;
next	1.216;
commitid	1004FA452A16C9E34E1;

1.216
date	2012.05.04.21.47.01;	author tg;	state Exp;
branches;
next	1.215;
commitid	1004FA44E6C59CC7A07;

1.215
date	2012.05.04.21.15.32;	author tg;	state Exp;
branches;
next	1.214;
commitid	1004FA4470B7AD85C13;

1.214
date	2012.05.04.20.49.03;	author tg;	state Exp;
branches;
next	1.213;
commitid	1004FA4409A67B135DE;

1.213
date	2012.05.04.20.08.24;	author tg;	state Exp;
branches;
next	1.212;
commitid	1004FA4373D2C11CAC3;

1.212
date	2012.04.06.13.28.59;	author tg;	state Exp;
branches;
next	1.211;
commitid	1004F7EEFB200419165;

1.211
date	2012.03.29.19.22.58;	author tg;	state Exp;
branches;
next	1.210;
commitid	1004F74B525291EF6DE;

1.210
date	2012.03.26.21.10.42;	author tg;	state Exp;
branches;
next	1.209;
commitid	1004F70DB64299CF262;

1.209
date	2012.03.24.18.47.04;	author tg;	state Exp;
branches;
next	1.208;
commitid	1004F6E165C444366BD;

1.208
date	2012.03.03.19.28.45;	author tg;	state Exp;
branches;
next	1.207;
commitid	1004F527104081A02C5;

1.207
date	2012.01.29.01.41.13;	author tg;	state Exp;
branches;
next	1.206;
commitid	1004F24A3CB1AC86618;

1.206
date	2011.12.29.22.54.19;	author tg;	state Exp;
branches;
next	1.205;
commitid	1004EFCEFA861A142CF;

1.205
date	2011.12.16.20.03.26;	author tg;	state Exp;
branches;
next	1.204;
commitid	1004EEBA4214501EA9D;

1.204
date	2011.12.09.20.40.25;	author tg;	state Exp;
branches
	1.204.2.1;
next	1.203;
commitid	1004EE272502524774F;

1.203
date	2011.12.09.20.40.14;	author tg;	state Exp;
branches;
next	1.202;
commitid	1004EE272454313DA6F;

1.202
date	2011.12.02.23.05.18;	author tg;	state Exp;
branches;
next	1.201;
commitid	1004ED959A47A28FFC5;

1.201
date	2011.12.02.22.55.48;	author tg;	state Exp;
branches;
next	1.200;
commitid	1004ED9575E20B9B002;

1.200
date	2011.11.30.21.34.12;	author tg;	state Exp;
branches;
next	1.199;
commitid	1004ED6A06C18CCDBE5;

1.199
date	2011.11.19.17.42.24;	author tg;	state Exp;
branches;
next	1.198;
commitid	1004EC7EA667D603F55;

1.198
date	2011.11.09.22.17.25;	author tg;	state Exp;
branches;
next	1.197;
commitid	1004EBAFBE75B5A370F;

1.197
date	2011.09.07.15.24.15;	author tg;	state Exp;
branches;
next	1.196;
commitid	1004E678C6929FE60A6;

1.196
date	2011.08.27.18.06.44;	author tg;	state Exp;
branches;
next	1.195;
commitid	1004E5932432420AA61;

1.195
date	2011.08.27.17.30.04;	author tg;	state Exp;
branches;
next	1.194;
commitid	1004E5929AF6944B2F7;

1.194
date	2011.07.20.23.47.28;	author tg;	state Exp;
branches;
next	1.193;
commitid	1004E2769127AE0E854;

1.193
date	2011.07.05.20.12.18;	author tg;	state Exp;
branches;
next	1.192;
commitid	1004E136FF75DBF04C7;

1.192
date	2011.07.05.19.56.24;	author tg;	state Exp;
branches;
next	1.191;
commitid	1004E136C5C48CE5C1C;

1.191
date	2011.07.02.17.57.23;	author tg;	state Exp;
branches;
next	1.190;
commitid	1004E0F5C1A676154AF;

1.190
date	2011.06.21.21.11.19;	author tg;	state Exp;
branches;
next	1.189;
commitid	1004E01090552E993D4;

1.189
date	2011.06.11.03.14.49;	author tg;	state Exp;
branches;
next	1.188;
commitid	1004DF2DDB52CEA0AB1;

1.188
date	2011.05.29.05.13.12;	author tg;	state Exp;
branches;
next	1.187;
commitid	1004DE1D5F85DAA1471;

1.187
date	2011.05.29.02.18.51;	author tg;	state Exp;
branches;
next	1.186;
commitid	1004DE1AD11046BEFFC;

1.186
date	2011.05.06.15.41.23;	author tg;	state Exp;
branches;
next	1.185;
commitid	1004DC416672F61DF37;

1.185
date	2011.04.09.21.01.01;	author tg;	state Exp;
branches;
next	1.184;
commitid	1004DA0C9186AA3EA10;

1.184
date	2011.04.09.15.21.36;	author tg;	state Exp;
branches;
next	1.183;
commitid	1004DA0799400B44257;

1.183
date	2011.04.09.15.14.52;	author tg;	state Exp;
branches;
next	1.182;
commitid	1004DA077823393B1E0;

1.182
date	2011.03.27.18.50.04;	author tg;	state Exp;
branches;
next	1.181;
commitid	1004D8F86AA0EB92572;

1.181
date	2011.03.27.01.30.36;	author tg;	state Exp;
branches;
next	1.180;
commitid	1004D8E935331A46B79;

1.180
date	2011.03.26.21.46.02;	author tg;	state Exp;
branches;
next	1.179;
commitid	1004D8E5E8E09438DF7;

1.179
date	2011.03.24.19.05.47;	author tg;	state Exp;
branches;
next	1.178;
commitid	1004D8B961A2724DA38;

1.178
date	2011.03.23.18.47.06;	author tg;	state Exp;
branches;
next	1.177;
commitid	1004D8A3FE2288AD1B5;

1.177
date	2011.03.16.20.56.32;	author tg;	state Exp;
branches;
next	1.176;
commitid	1004D8124057DD4A66A;

1.176
date	2011.03.13.01.20.19;	author tg;	state Exp;
branches;
next	1.175;
commitid	1004D7C1BE368F5B459;

1.175
date	2011.03.07.20.30.37;	author tg;	state Exp;
branches;
next	1.174;
commitid	1004D75404D6F4BA14C;

1.174
date	2011.03.05.21.48.08;	author tg;	state Exp;
branches;
next	1.173;
commitid	1004D72AF6C540FBB78;

1.173
date	2011.03.05.21.43.15;	author tg;	state Exp;
branches;
next	1.172;
commitid	1004D72AE603B079174;

1.172
date	2011.02.18.22.26.08;	author tg;	state Exp;
branches;
next	1.171;
commitid	1004D5EF0ED2C0C9394;

1.171
date	2011.02.13.21.13.06;	author tg;	state Exp;
branches;
next	1.170;
commitid	1004D58496015725548;

1.170
date	2011.02.11.01.18.17;	author tg;	state Exp;
branches;
next	1.169;
commitid	1004D548C4E66D17A12;

1.169
date	2011.02.11.00.41.34;	author tg;	state Exp;
branches;
next	1.168;
commitid	1004D5485D4414A9BFE;

1.168
date	2011.01.30.01.35.58;	author tg;	state Exp;
branches;
next	1.167;
commitid	1004D44C0920D39CB07;

1.167
date	2011.01.22.20.33.13;	author tg;	state Exp;
branches;
next	1.166;
commitid	1004D3B3F1E5091C6CD;

1.166
date	2011.01.21.22.00.15;	author tg;	state Exp;
branches;
next	1.165;
commitid	1004D3A01F81243EE3A;

1.165
date	2011.01.09.21.57.26;	author tg;	state Exp;
branches;
next	1.164;
commitid	1004D2A2F086B2268F4;

1.164
date	2010.11.01.17.29.02;	author tg;	state Exp;
branches;
next	1.163;
commitid	1004CCEF8F323B360DC;

1.163
date	2010.09.15.21.08.18;	author tg;	state Exp;
branches;
next	1.162;
commitid	1004C9135BE7A0C39AD;

1.162
date	2010.09.14.21.26.12;	author tg;	state Exp;
branches;
next	1.161;
commitid	1004C8FE654576B0E25;

1.161
date	2010.09.05.19.51.33;	author tg;	state Exp;
branches;
next	1.160;
commitid	1004C83F4BE00D43672;

1.160
date	2010.08.28.20.22.17;	author tg;	state Exp;
branches;
next	1.159;
commitid	1004C796FE40C544CCE;

1.159
date	2010.08.28.18.50.51;	author tg;	state Exp;
branches;
next	1.158;
commitid	1004C795A82072326AF;

1.158
date	2010.08.28.17.21.44;	author tg;	state Exp;
branches;
next	1.157;
commitid	1004C7945A20EB8DDA4;

1.157
date	2010.08.24.14.42.01;	author tg;	state Exp;
branches;
next	1.156;
commitid	1004C73D9D62A68EAE7;

1.156
date	2010.07.17.22.09.34;	author tg;	state Exp;
branches;
next	1.155;
commitid	1004C42295452E71B6E;

1.155
date	2010.04.27.21.39.08;	author tg;	state Exp;
branches;
next	1.154;
commitid	1004BD75943684FFAB4;

1.154
date	2010.04.09.18.59.29;	author tg;	state Exp;
branches;
next	1.153;
commitid	1004BBF79255AF0EE02;

1.153
date	2010.03.27.16.51.37;	author tg;	state Exp;
branches;
next	1.152;
commitid	1004BAE37A00499B2F0;

1.152
date	2010.03.14.11.58.32;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004B9CCF5B34BE8F30;

1.151
date	2010.02.23.18.13.03;	author tg;	state Exp;
branches;
next	1.150;
commitid	1004B841A9A1A72C896;

1.150
date	2010.01.28.15.18.48;	author tg;	state Exp;
branches;
next	1.149;
commitid	1004B61A9B525E85DF5;

1.149
date	2010.01.25.14.38.01;	author tg;	state Exp;
branches;
next	1.148;
commitid	1004B5DACDC357C3689;

1.148
date	2010.01.25.14.11.26;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004B5DA60A56BFB604;

1.147
date	2009.12.12.22.27.07;	author tg;	state Exp;
branches;
next	1.146;
commitid	1004B2418AF282F4231;

1.146
date	2009.12.05.17.43.46;	author tg;	state Exp;
branches;
next	1.145;
commitid	1004B1A9BCF3E49BC5B;

1.145
date	2009.12.01.13.12.30;	author tg;	state Exp;
branches;
next	1.144;
commitid	1004B15165457409EA5;

1.144
date	2009.11.28.14.28.01;	author tg;	state Exp;
branches;
next	1.143;
commitid	1004B11334F4604E973;

1.143
date	2009.11.28.14.21.44;	author tg;	state Exp;
branches;
next	1.142;
commitid	1004B1131E93EDF1403;

1.142
date	2009.11.09.23.35.09;	author tg;	state Exp;
branches
	1.142.2.1;
next	1.141;
commitid	1004AF8A72F40172587;

1.141
date	2009.10.27.17.00.01;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004AE726F77A03CF56;

1.140
date	2009.10.15.16.36.26;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004AD74F846B061D71;

1.139
date	2009.10.15.16.32.50;	author tg;	state Exp;
branches;
next	1.138;
commitid	1004AD74EBB7603C686;

1.138
date	2009.10.15.14.58.51;	author tg;	state Exp;
branches;
next	1.137;
commitid	1004AD738B244722004;

1.137
date	2009.10.10.21.17.29;	author tg;	state Exp;
branches;
next	1.136;
commitid	1004AD0F97B0E1CF3C3;

1.136
date	2009.10.02.18.08.33;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004AC641341D9D9D02;

1.135
date	2009.09.26.03.39.58;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004ABD8CE62D55CFD8;

1.134
date	2009.09.23.18.04.56;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004ABA62C8171BD8E4;

1.133
date	2009.09.19.21.54.44;	author tg;	state Exp;
branches;
next	1.132;
commitid	1004AB552F7546C611E;

1.132
date	2009.09.19.19.08.46;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004AB52C3C201A31B8;

1.131
date	2009.09.19.15.16.02;	author tg;	state Exp;
branches;
next	1.130;
commitid	1004AB4F5B430F7AA5A;

1.130
date	2009.09.07.17.24.48;	author tg;	state Exp;
branches;
next	1.129;
commitid	1004AA541E5370FC6A6;

1.129
date	2009.09.06.17.42.12;	author tg;	state Exp;
branches;
next	1.128;
commitid	1004AA3F479204C1E97;

1.128
date	2009.08.30.21.02.00;	author tg;	state Exp;
branches;
next	1.127;
commitid	1004A9AE8B12FB2C70D;

1.127
date	2009.08.30.13.30.07;	author tg;	state Exp;
branches
	1.127.2.1;
next	1.126;
commitid	1004A9A7EDF06F600FC;

1.126
date	2009.08.30.13.22.38;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004A9A7CF57ABC87F3;

1.125
date	2009.08.28.21.51.51;	author tg;	state Exp;
branches;
next	1.124;
commitid	1004A9851823C1B9AD2;

1.124
date	2009.08.28.21.01.25;	author tg;	state Exp;
branches;
next	1.123;
commitid	1004A9845725143AD02;

1.123
date	2009.08.28.20.30.56;	author tg;	state Exp;
branches;
next	1.122;
commitid	1004A983E6B745731A0;

1.122
date	2009.08.28.19.57.40;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004A98365B7809CDA1;

1.121
date	2009.08.28.18.53.58;	author tg;	state Exp;
branches;
next	1.120;
commitid	1004A9827D2091BAE42;

1.120
date	2009.08.08.13.08.50;	author tg;	state Exp;
branches;
next	1.119;
commitid	1004A7D785D73D49CFA;

1.119
date	2009.07.30.19.11.11;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004A71F04C54EFD9CF;

1.118
date	2009.07.25.21.31.25;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004A6B79B87CB15A8B;

1.117
date	2009.07.25.20.35.22;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004A6B6C9C62288591;

1.116
date	2009.07.25.20.26.32;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004A6B6A5D6F28009F;

1.115
date	2009.06.11.12.42.18;	author tg;	state Exp;
branches
	1.115.2.1;
next	1.114;
commitid	1004A30FBB114E3FED9;

1.114
date	2009.06.10.18.12.46;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004A2FF7913BD44883;

1.113
date	2009.06.10.18.11.26;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004A2FF764542B3C7D;

1.112
date	2009.06.08.20.52.27;	author tg;	state Exp;
branches;
next	1.111;
commitid	1004A2D79BE067C2178;

1.111
date	2009.06.08.20.34.39;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004A2D75D22EFFE1BD;

1.110
date	2009.06.08.20.06.46;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004A2D6F3A31FB4CBC;

1.109
date	2009.05.21.14.28.33;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004A156526780370CA;

1.108
date	2009.05.20.10.10.01;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004A13D70259491252;

1.107
date	2009.05.16.18.40.06;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004A0F087409E93A5D;

1.106
date	2009.05.16.17.33.10;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004A0EF8A22D45DD46;

1.105
date	2009.05.16.16.59.35;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004A0EF0664EF4168D;

1.104
date	2009.04.07.19.51.46;	author tg;	state Exp;
branches;
next	1.103;
commitid	10049DBAEE94DD17BA7;

1.103
date	2009.04.05.12.35.30;	author tg;	state Exp;
branches;
next	1.102;
commitid	10049D8A5A72FBB1A39;

1.102
date	2009.04.03.09.45.23;	author tg;	state Exp;
branches;
next	1.101;
commitid	10049D5DAB828D70A55;

1.101
date	2009.04.03.09.39.05;	author tg;	state Exp;
branches;
next	1.100;
commitid	10049D5D94A2E5145F0;

1.100
date	2009.03.22.18.28.34;	author tg;	state Exp;
branches;
next	1.99;
commitid	10049C6834E4ED058A4;

1.99
date	2009.03.22.17.58.58;	author tg;	state Exp;
branches;
next	1.98;
commitid	10049C67C716318AC21;

1.98
date	2009.03.22.17.53.50;	author tg;	state Exp;
branches;
next	1.97;
commitid	10049C67B3B2975FD0B;

1.97
date	2009.03.22.17.52.48;	author tg;	state Exp;
branches;
next	1.96;
commitid	10049C67AFB4978F9D6;

1.96
date	2009.03.22.17.47.36;	author tg;	state Exp;
branches;
next	1.95;
commitid	10049C679C543D854C9;

1.95
date	2009.03.15.16.13.39;	author tg;	state Exp;
branches;
next	1.94;
commitid	10049BD293E126777AC;

1.94
date	2009.03.14.18.12.52;	author tg;	state Exp;
branches;
next	1.93;
commitid	10049BBF38A0ADEDD54;

1.93
date	2008.12.13.17.02.14;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004943EAA830C0300B;

1.92
date	2008.11.12.00.54.48;	author tg;	state Exp;
branches
	1.92.2.1;
next	1.91;
commitid	100491A295841A6D8EB;

1.91
date	2008.11.12.00.27.55;	author tg;	state Exp;
branches;
next	1.90;
commitid	100491A230649FC77C0;

1.90
date	2008.10.28.14.32.40;	author tg;	state Exp;
branches;
next	1.89;
commitid	1004907226D3DEFCCD1;

1.89
date	2008.09.30.19.25.50;	author tg;	state Exp;
branches;
next	1.88;
commitid	10048E27D493BFBB014;

1.88
date	2008.09.30.17.49.25;	author tg;	state Exp;
branches;
next	1.87;
commitid	10048E266AB7BDA06AF;

1.87
date	2008.09.17.19.31.29;	author tg;	state Exp;
branches;
next	1.86;
commitid	10048D15ABE2EA76C75;

1.86
date	2008.08.02.17.45.11;	author tg;	state Exp;
branches;
next	1.85;
commitid	10048949D196A7C1390;

1.85
date	2008.07.14.12.29.05;	author tg;	state Exp;
branches;
next	1.84;
commitid	100487B467E068A55D6;

1.84
date	2008.07.12.16.56.39;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004878E22B104A657A;

1.83
date	2008.06.08.17.16.25;	author tg;	state Exp;
branches;
next	1.82;
commitid	100484C13FC58F3291E;

1.82
date	2008.06.08.17.15.29;	author tg;	state Exp;
branches;
next	1.81;
commitid	100484C13C7725BA294;

1.81
date	2008.05.17.18.46.58;	author tg;	state Exp;
branches;
next	1.80;
commitid	100482F280E7B53AA4C;

1.80
date	2008.05.17.18.27.55;	author tg;	state Exp;
branches;
next	1.79;
commitid	100482F238341D5E08C;

1.79
date	2008.04.22.18.58.20;	author tg;	state Exp;
branches;
next	1.78;
commitid	100480E354B219A5550;

1.78
date	2008.04.20.21.30.29;	author tg;	state Exp;
branches;
next	1.77;
commitid	100480BB5E564A443DA;

1.77
date	2008.04.19.22.15.03;	author tg;	state Exp;
branches;
next	1.76;
commitid	100480A6CC85EC0197B;

1.76
date	2008.04.16.21.56.01;	author tg;	state Exp;
branches;
next	1.75;
commitid	100480675E12E8ACD98;

1.75
date	2008.04.01.22.20.19;	author tg;	state Exp;
branches;
next	1.74;
commitid	10047F2B5302C15B5C3;

1.74
date	2008.04.01.21.50.57;	author tg;	state Exp;
branches;
next	1.73;
commitid	10047F2AE2966CBAC7A;

1.73
date	2008.04.01.21.39.45;	author tg;	state Exp;
branches;
next	1.72;
commitid	10047F2AB9D6BAD2B9B;

1.72
date	2008.03.28.18.46.59;	author tg;	state Exp;
branches;
next	1.71;
commitid	10047ED3D374E7A3EAA;

1.71
date	2008.03.28.13.46.52;	author tg;	state Exp;
branches;
next	1.70;
commitid	10047ECF6A15422B64A;

1.70
date	2008.03.28.13.28.33;	author tg;	state Exp;
branches;
next	1.69;
commitid	10047ECF2895608ED25;

1.69
date	2008.02.24.15.57.20;	author tg;	state Exp;
branches
	1.69.2.1;
next	1.68;
commitid	10047C193886D1669C9;

1.68
date	2008.02.24.15.48.42;	author tg;	state Exp;
branches;
next	1.67;
commitid	10047C190EF15EAB550;

1.67
date	2007.10.25.15.23.09;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004720B4ED147A8549;

1.66
date	2007.10.18.20.32.32;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004717C2CE427DDAE7;

1.65
date	2007.09.09.18.06.40;	author tg;	state Exp;
branches;
next	1.64;
commitid	10046E436442CDF8871;

1.64
date	2007.08.19.23.12.21;	author tg;	state Exp;
branches;
next	1.63;
commitid	10046C8CE5279B1E703;

1.63
date	2007.08.19.22.06.26;	author tg;	state Exp;
branches;
next	1.62;
commitid	10046C8BEC1249CCADD;

1.62
date	2007.07.31.13.55.26;	author tg;	state Exp;
branches;
next	1.61;
commitid	10046AF3F2323D2F78E;

1.61
date	2007.07.31.11.11.24;	author tg;	state Exp;
branches;
next	1.60;
commitid	10046AF18D74B1B5DF4;

1.60
date	2007.07.22.14.01.48;	author tg;	state Exp;
branches;
next	1.59;
commitid	10046A36344350ACD7B;

1.59
date	2007.07.22.13.34.49;	author tg;	state Exp;
branches;
next	1.58;
commitid	10046A35CEC35BB7B5F;

1.58
date	2007.07.01.21.10.28;	author tg;	state Exp;
branches;
next	1.57;
commitid	100468818584C6286F7;

1.57
date	2007.06.06.23.41.23;	author tg;	state Exp;
branches;
next	1.56;
commitid	100466746376C2C11A9;

1.56
date	2007.06.06.23.28.15;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004667430836D68E66;

1.55
date	2007.06.05.19.18.11;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004665B6C60E20066C;

1.54
date	2007.06.04.21.33.27;	author tg;	state Exp;
branches;
next	1.53;
commitid	100466485304A0BD517;

1.53
date	2007.05.13.18.49.00;	author tg;	state Exp;
branches;
next	1.52;
commitid	10046475DAE4D3D3C05;

1.52
date	2007.05.13.18.33.28;	author tg;	state Exp;
branches;
next	1.51;
commitid	100464759DE15635029;

1.51
date	2007.05.13.18.15.25;	author tg;	state Exp;
branches;
next	1.50;
commitid	100464755C253EE3EA9;

1.50
date	2007.05.13.17.51.21;	author tg;	state Exp;
branches;
next	1.49;
commitid	10046474FB1292DF336;

1.49
date	2007.03.10.18.16.26;	author tg;	state Exp;
branches
	1.49.2.1;
next	1.48;
commitid	10045F2F60A6B49F58A;

1.48
date	2007.03.04.03.04.25;	author tg;	state Exp;
branches;
next	1.47;
commitid	10045EA374B3374AB35;

1.47
date	2007.03.04.00.13.15;	author tg;	state Exp;
branches;
next	1.46;
commitid	10045EA0F2F6674C8B9;

1.46
date	2007.01.26.18.37.26;	author tg;	state Exp;
branches;
next	1.45;
commitid	10045BA4A7C34257B4F;

1.45
date	2007.01.15.00.18.47;	author tg;	state Exp;
branches;
next	1.44;
commitid	10045AAC877551BD17C;

1.44
date	2007.01.14.23.57.44;	author tg;	state Exp;
branches
	1.44.2.1;
next	1.43;
commitid	10045AAC38562F4C79B;

1.43
date	2007.01.12.10.18.20;	author tg;	state Exp;
branches;
next	1.42;
commitid	10045A76059104E0EFB;

1.42
date	2007.01.12.01.49.28;	author tg;	state Exp;
branches;
next	1.41;
commitid	10045A6E8B92FCAC95A;

1.41
date	2007.01.12.00.25.39;	author tg;	state Exp;
branches;
next	1.40;
commitid	10045A6D3B866AF7B2F;

1.40
date	2007.01.11.00.32.31;	author tg;	state Exp;
branches;
next	1.39;
commitid	10045A5858664A950E2;

1.39
date	2006.12.06.13.41.23;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004576C88D191C9B70;

1.38
date	2006.11.19.17.13.36;	author tg;	state Exp;
branches;
next	1.37;
commitid	100456090CE2FF180F3;

1.37
date	2006.11.12.14.58.14;	author tg;	state Exp;
branches;
next	1.36;
commitid	100455735A7145E26AA;

1.36
date	2006.11.10.07.52.02;	author tg;	state Exp;
branches;
next	1.35;
commitid	10045542F8269E05F56;

1.35
date	2006.11.10.06.53.26;	author tg;	state Exp;
branches;
next	1.34;
commitid	100455421CB6900D8A1;

1.34
date	2006.11.10.06.16.24;	author tg;	state Exp;
branches;
next	1.33;
commitid	100455419107E3FB2C1;

1.33
date	2006.11.10.03.45.56;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004553F5FF71731A58;

1.32
date	2006.11.09.23.19.52;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004553B7AB3606FEAD;

1.31
date	2006.11.09.22.18.10;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004553A9170C58FA40;

1.30
date	2006.08.24.20.32.52;	author tg;	state Exp;
branches;
next	1.29;
commitid	10044EE0CE2267A59CF;

1.29
date	2006.08.01.13.43.26;	author tg;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	10044CF5A93693A5C0A;

1.28
date	2006.07.03.12.16.30;	author tg;	state Exp;
branches;
next	1.27;
commitid	10044A90AAA1B255EDF;

1.27
date	2006.05.10.18.54.10;	author tg;	state Exp;
branches;
next	1.26;
commitid	100446236E6726083C8;

1.26
date	2006.01.30.12.37.22;	author tg;	state Exp;
branches;
next	1.25;
commitid	10043DE088533ED5341;

1.25
date	2006.01.29.20.04.51;	author tg;	state Exp;
branches;
next	1.24;
commitid	10043DD1FE6328EF386;

1.24
date	2005.11.22.18.40.42;	author tg;	state Exp;
branches;
next	1.23;
commitid	108a438366254326;

1.23
date	2005.10.25.19.53.27;	author tg;	state Exp;
branches;
next	1.22;
commitid	76cc435e8d34d8ce;

1.22
date	2005.10.25.19.35.14;	author tg;	state Exp;
branches;
next	1.21;
commitid	5eac435e88231d5f;

1.21
date	2005.10.21.12.41.55;	author tg;	state Exp;
branches;
next	1.20;
commitid	657d4358e1e6ede8;

1.20
date	2005.10.21.11.44.25;	author tg;	state Exp;
branches;
next	1.19;
commitid	616d4358d4a1f32f;

1.19
date	2005.10.08.19.30.59;	author tg;	state Exp;
branches;
next	1.18;
commitid	512643481e5274c0;

1.18
date	2005.09.12.19.28.18;	author tg;	state Exp;
branches;
next	1.17;
commitid	41354325d6de3bc8;

1.17
date	2005.08.26.22.03.55;	author tg;	state Exp;
branches;
next	1.16;
commitid	57a8430f91c30d91;

1.16
date	2005.08.21.12.52.29;	author tg;	state Exp;
branches;
next	1.15;
commitid	45964308791ed7aa;

1.15
date	2005.07.06.00.02.05;	author tg;	state Exp;
branches;
next	1.14;
commitid	3c3f42cb1f724a1e;

1.14
date	2005.07.04.12.34.22;	author tg;	state Exp;
branches;
next	1.13;
commitid	4a8342c92cd61cc3;

1.13
date	2005.07.04.12.27.26;	author tg;	state Exp;
branches;
next	1.12;
commitid	3ec342c92b3a8874;

1.12
date	2005.06.24.15.40.38;	author tg;	state Exp;
branches;
next	1.11;
commitid	73242bc29895ca6;

1.11
date	2005.06.08.10.25.40;	author tg;	state Exp;
branches;
next	1.10;
commitid	173f42a6c7adc00f;

1.10
date	2005.06.08.10.14.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	117142a6c4f4d0f4;

1.9
date	2005.05.25.23.31.06;	author tg;	state Exp;
branches;
next	1.8;
commitid	6fd242950a6e73e0;

1.8
date	2005.05.25.13.46.00;	author tg;	state Exp;
branches;
next	1.7;
commitid	503942948197230c;

1.7
date	2005.05.25.09.39.49;	author tg;	state Exp;
branches;
next	1.6;
commitid	365f429447fa353d;

1.6
date	2005.05.25.09.18.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	7b2c429442d9e922;

1.5
date	2005.05.23.15.24.42;	author tg;	state Exp;
branches;
next	1.4;
commitid	fa04291f5c8f5c4;

1.4
date	2005.05.23.15.23.12;	author tg;	state Exp;
branches;
next	1.3;
commitid	d404291f56e10fd;

1.3
date	2005.05.23.15.18.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	3dc04291f43ca526;

1.2
date	2005.05.23.14.19.13;	author tg;	state Exp;
branches;
next	1.1;
commitid	5e9f4291e64f3f3e;

1.1
date	2005.05.23.03.06.07;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.259.2.1
date	2015.01.11.22.39.49;	author tg;	state Exp;
branches;
next	1.259.2.2;
commitid	10054B2FBC1440F88AD;

1.259.2.2
date	2015.01.25.15.35.44;	author tg;	state Exp;
branches;
next	1.259.2.3;
commitid	10054C50D442D861FBF;

1.259.2.3
date	2015.03.20.22.21.01;	author tg;	state Exp;
branches;
next	1.259.2.4;
commitid	100550C9D521FCB4274;

1.259.2.4
date	2015.04.12.22.32.26;	author tg;	state Exp;
branches;
next	1.259.2.5;
commitid	100552AF26A429AA816;

1.259.2.5
date	2015.04.19.19.18.16;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.230.2.1
date	2012.12.04.01.26.23;	author tg;	state Exp;
branches;
next	1.230.2.2;
commitid	10050BD5149729CD584;

1.230.2.2
date	2013.01.01.21.20.04;	author tg;	state Exp;
branches;
next	1.230.2.3;
commitid	10050E352F23B706399;

1.230.2.3
date	2013.02.10.17.11.21;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.222.2.1
date	2013.02.11.00.27.13;	author tg;	state Exp;
branches;
next	;
commitid	10051183A6D5475BB1E;

1.204.2.1
date	2012.03.24.21.22.35;	author tg;	state Exp;
branches;
next	1.204.2.2;
commitid	1004F6E3A967ACCD93A;

1.204.2.2
date	2012.04.06.14.40.18;	author tg;	state Exp;
branches;
next	;
commitid	1004F7F0056695FD460;

1.142.2.1
date	2009.11.28.14.27.51;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.127.2.1
date	2009.08.30.20.56.05;	author tg;	state Exp;
branches;
next	;
commitid	1004A9AE59203C5D0BB;

1.115.2.1
date	2009.07.25.18.27.53;	author tg;	state Exp;
branches;
next	;
commitid	1004A6B4E471DB88B03;

1.92.2.1
date	2008.11.22.13.20.28;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.69.2.1
date	2008.04.22.13.29.25;	author tg;	state Exp;
branches;
next	1.69.2.2;
commitid	100480DE80F32BAA72D;

1.69.2.2
date	2008.05.19.18.41.23;	author tg;	state Exp;
branches;
next	1.69.2.3;
commitid	1004831C9A63DA06745;

1.69.2.3
date	2008.07.11.11.49.25;	author tg;	state Exp;
branches;
next	1.69.2.4;
commitid	100487748D62394D033;

1.69.2.4
date	2008.07.18.13.29.43;	author tg;	state Exp;
branches;
next	1.69.2.5;
commitid	10048809AD278B142AC;

1.69.2.5
date	2008.12.14.00.07.40;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.49.2.1
date	2007.05.13.19.29.35;	author tg;	state Exp;
branches;
next	1.49.2.2;
commitid	1004647668D4636830B;

1.49.2.2
date	2007.07.05.11.49.19;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.44.2.1
date	2007.03.03.21.37.55;	author tg;	state Exp;
branches;
next	1.44.2.2;
commitid	10045E9EAC27ABA6ADF;

1.44.2.2
date	2007.03.03.21.43.49;	author tg;	state Exp;
branches;
next	1.44.2.3;
commitid	10045E9EC2B7AC589DE;

1.44.2.3
date	2007.03.03.23.38.36;	author tg;	state Exp;
branches;
next	;
commitid	10045EA07113BF2F32A;

1.29.2.1
date	2006.08.15.23.49.52;	author tg;	state Exp;
branches;
next	1.29.2.2;
commitid	10044E25D6841FC583E;

1.29.2.2
date	2006.08.24.18.52.26;	author tg;	state Exp;
branches;
next	1.29.2.3;
commitid	10044EDF56C08E8BF07;

1.29.2.3
date	2006.08.24.20.52.11;	author tg;	state Exp;
branches;
next	1.29.2.4;
commitid	10044EE117A130AF943;

1.29.2.4
date	2006.08.28.01.49.17;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.360
log
@move the “is inside eval” flag into struct env
@
text
@/*	$OpenBSD: c_ksh.c,v 1.37 2015/09/10 22:48:58 nicm Exp $	*/
/*	$OpenBSD: c_sh.c,v 1.46 2015/07/20 20:46:24 guenther Exp $	*/
/*	$OpenBSD: c_test.c,v 1.18 2009/03/01 20:11:06 otto Exp $	*/
/*	$OpenBSD: c_ulimit.c,v 1.19 2013/11/28 10:33:37 sobrado Exp $	*/

/*-
 * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
 *		 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

#if HAVE_SELECT
#if HAVE_SYS_BSDTYPES_H
#include <sys/bsdtypes.h>
#endif
#if HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#if HAVE_BSTRING_H
#include <bstring.h>
#endif
#endif

__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.357 2019/08/02 19:27:15 tg Exp $");

#if HAVE_KILLPG
/*
 * use killpg if < -1 since -1 does special things
 * for some non-killpg-endowed kills
 */
#define mksh_kill(p,s)	((p) < -1 ? killpg(-(p), (s)) : kill((p), (s)))
#else
/* cross fingers and hope kill is killpg-endowed */
#define mksh_kill	kill
#endif

/* XXX conditions correct? */
#if !defined(RLIM_INFINITY) && !defined(MKSH_NO_LIMITS)
#define MKSH_NO_LIMITS	1
#endif

#ifdef MKSH_NO_LIMITS
#define c_ulimit	c_true
#endif

#if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
static int c_suspend(const char **);
#endif

static int do_whence(const char **, int, bool, bool);

/* getn() that prints error */
static int
bi_getn(const char *as, int *ai)
{
	int rv;

	if (!(rv = getn(as, ai)))
		bi_errorf(Tf_sD_s, Tbadnum, as);
	return (rv);
}

static int
c_true(const char **wp MKSH_A_UNUSED)
{
	return (0);
}

static int
c_false(const char **wp MKSH_A_UNUSED)
{
	return (1);
}

/*
 * A leading = means assignments before command are kept.
 * A leading * means a POSIX special builtin.
 * A leading ^ means declaration utility, - forwarder.
 */
const struct builtin mkshbuiltins[] = {
	{Tsgdot, c_dot},
	{"*=:", c_true},
	{Tbracket, c_test},
	/* no =: AT&T manual wrong */
	{Talias, c_alias},
	{Tsgbreak, c_brkcont},
	{T__builtin, c_builtin},
	{Tbuiltin, c_builtin},
	{Tbcat, c_cat},
	{Tcd, c_cd},
	/* dash compatibility hack */
	{"chdir", c_cd},
	{T_command, c_command},
	{Tsgcontinue, c_brkcont},
	{"echo", c_print},
	{"*=eval", c_eval},
	{"*=exec", c_exec},
	{"*=exit", c_exitreturn},
	{Tdsgexport, c_typeset},
	{Tfalse, c_false},
	{"fc", c_fc},
	{Tgetopts, c_getopts},
	/* deprecated, replaced by typeset -g */
	{"^=global", c_typeset},
	{Tjobs, c_jobs},
	{"kill", c_kill},
	{"let", c_let},
	{"print", c_print},
	{"pwd", c_pwd},
	{Tread, c_read},
	{Tdsgreadonly, c_typeset},
	{"!realpath", c_realpath},
	{"~rename", c_rename},
	{"*=return", c_exitreturn},
	{Tsghset, c_set},
	{"*=#shift", c_shift},
	{Tgsource, c_dot},
#if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
	{Tsuspend, c_suspend},
#endif
	{"test", c_test},
	{"*=times", c_times},
	{"*=trap", c_trap},
	{Ttrue, c_true},
	{Tdgtypeset, c_typeset},
	{"ulimit", c_ulimit},
	{"umask", c_umask},
	{Tunalias, c_unalias},
	{"*=unset", c_unset},
	{"wait", c_wait},
	{"whence", c_whence},
#ifndef MKSH_UNEMPLOYED
	{Tbg, c_fgbg},
	{Tfg, c_fgbg},
#endif
#ifndef MKSH_NO_CMDLINE_EDITING
	{"bind", c_bind},
#endif
#if HAVE_MKNOD
	{"mknod", c_mknod},
#endif
#ifdef MKSH_PRINTF_BUILTIN
	{"~printf", c_printf},
#endif
#if HAVE_SELECT
	{"sleep", c_sleep},
#endif
#ifdef __MirBSD__
	/* alias to "true" for historical reasons */
	{"domainname", c_true},
#endif
#ifdef __OS2__
	{Textproc, c_true},
#endif
	{NULL, (int (*)(const char **))NULL}
};

struct kill_info {
	int num_width;
	int name_width;
};

static const struct t_op {
	char op_text[4];
	Test_op op_num;
} u_ops[] = {
	{"-a",	TO_FILAXST },
	{"-b",	TO_FILBDEV },
	{"-c",	TO_FILCDEV },
	{"-d",	TO_FILID },
	{"-e",	TO_FILEXST },
	{"-f",	TO_FILREG },
	{"-G",	TO_FILGID },
	{"-g",	TO_FILSETG },
	{"-H",	TO_FILCDF },
	{"-h",	TO_FILSYM },
	{"-k",	TO_FILSTCK },
	{"-L",	TO_FILSYM },
	{"-n",	TO_STNZE },
	{"-O",	TO_FILUID },
	{"-o",	TO_OPTION },
	{"-p",	TO_FILFIFO },
	{"-r",	TO_FILRD },
	{"-S",	TO_FILSOCK },
	{"-s",	TO_FILGZ },
	{"-t",	TO_FILTT },
	{"-u",	TO_FILSETU },
	{"-v",	TO_ISSET },
	{"-w",	TO_FILWR },
	{"-x",	TO_FILEX },
	{"-z",	TO_STZER },
	{"",	TO_NONOP }
};
static const struct t_op b_ops[] = {
	{"=",	TO_STEQL },
	{"==",	TO_STEQL },
	{"!=",	TO_STNEQ },
	{"<",	TO_STLT },
	{">",	TO_STGT },
	{"-eq",	TO_INTEQ },
	{"-ne",	TO_INTNE },
	{"-gt",	TO_INTGT },
	{"-ge",	TO_INTGE },
	{"-lt",	TO_INTLT },
	{"-le",	TO_INTLE },
	{"-ef",	TO_FILEQ },
	{"-nt",	TO_FILNT },
	{"-ot",	TO_FILOT },
	{"",	TO_NONOP }
};

static int test_oexpr(Test_env *, bool);
static int test_aexpr(Test_env *, bool);
static int test_nexpr(Test_env *, bool);
static int test_primary(Test_env *, bool);
static Test_op ptest_isa(Test_env *, Test_meta);
static const char *ptest_getopnd(Test_env *, Test_op, bool);
static void ptest_error(Test_env *, int, const char *);
static void kill_fmt_entry(char *, size_t, unsigned int, const void *);
static void p_time(struct shf *, bool, long, int, int,
    const char *, const char *);

int
c_pwd(const char **wp)
{
	int optc;
	bool physical = tobool(Flag(FPHYSICAL));
	char *p, *allocd = NULL;

	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
		switch (optc) {
		case 'L':
			physical = false;
			break;
		case 'P':
			physical = true;
			break;
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	if (wp[0]) {
		bi_errorf(Ttoo_many_args);
		return (1);
	}
	p = current_wd[0] ? (physical ? allocd = do_realpath(current_wd) :
	    current_wd) : NULL;
	/* LINTED use of access */
	if (p && access(p, R_OK) < 0)
		p = NULL;
	if (!p && !(p = allocd = ksh_get_wd())) {
		bi_errorf(Tf_sD_s, "can't determine current directory",
		    cstrerror(errno));
		return (1);
	}
	shprintf(Tf_sN, p);
	afree(allocd, ATEMP);
	return (0);
}

static const char *s_ptr;
static int s_get(void);
static void s_put(int);

int
c_print(const char **wp)
{
	int c;
	const char *s;
	char *xp;
	XString xs;
	struct {
		/* storage for columnisation */
		XPtrV words;
		/* temporary storage for a wide character */
		mksh_ari_t wc;
		/* output file descriptor (if any) */
		int fd;
		/* temporary storage for a multibyte character */
		char ts[4];
		/* output word separator */
		char ws;
		/* output line separator */
		char ls;
		/* output a trailing line separator? */
		bool nl;
		/* expand backslash sequences? */
		bool exp;
		/* columnise output? */
		bool col;
		/* print to history instead of file descriptor / stdout? */
		bool hist;
		/* print words as wide characters? */
		bool chars;
		/* writing to a coprocess (SIGPIPE blocked)? */
		bool coproc;
		bool copipe;
	} po;

	memset(&po, 0, sizeof(po));
	po.fd = 1;
	po.ws = ' ';
	po.ls = '\n';
	po.nl = true;

	if (wp[0][0] == 'e') {
		/* "echo" builtin */
		if (Flag(FPOSIX) ||
#ifndef MKSH_MIDNIGHTBSD01ASH_COMPAT
		    Flag(FSH) ||
#endif
		    Flag(FAS_BUILTIN)) {
			/* BSD "echo" cmd, Debian Policy 10.4 compliant */
			++wp;
 bsd_echo:
			if (*wp && !strcmp(*wp, "-n")) {
				po.nl = false;
				++wp;
			}
			po.exp = false;
		} else {
			bool new_exp, new_nl = true;

			/*-
			 * compromise between various historic echos: only
			 * recognise -Een if they appear in arguments with
			 * no illegal options; e.g. echo -nq outputs '-nq'
			 */
#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
			/* MidnightBSD /bin/sh needs -e supported but off */
			if (Flag(FSH))
				new_exp = false;
			else
#endif
			/* otherwise compromise on -e enabled by default */
			  new_exp = true;
			goto print_tradparse_beg;

 print_tradparse_arg:
			if ((s = *wp) && *s++ == '-' && *s) {
 print_tradparse_ch:
				switch ((c = *s++)) {
				case 'E':
					new_exp = false;
					goto print_tradparse_ch;
				case 'e':
					new_exp = true;
					goto print_tradparse_ch;
				case 'n':
					new_nl = false;
					goto print_tradparse_ch;
				case '\0':
 print_tradparse_beg:
					po.exp = new_exp;
					po.nl = new_nl;
					++wp;
					goto print_tradparse_arg;
				}
			}
		}
	} else {
		/* "print" builtin */
		const char *opts = "AcelNnpRrsu,";
		const char *emsg;

		po.exp = true;

		while ((c = ksh_getopt(wp, &builtin_opt, opts)) != -1)
			switch (c) {
			case 'A':
				po.chars = true;
				break;
			case 'c':
				po.col = true;
				break;
			case 'e':
				po.exp = true;
				break;
			case 'l':
				po.ws = '\n';
				break;
			case 'N':
				po.ws = '\0';
				po.ls = '\0';
				break;
			case 'n':
				po.nl = false;
				break;
			case 'p':
				if ((po.fd = coproc_getfd(W_OK, &emsg)) < 0) {
					bi_errorf(Tf_coproc, emsg);
					return (1);
				}
				break;
			case 'R':
				/* fake BSD echo but don't reset other flags */
				wp += builtin_opt.optind;
				goto bsd_echo;
			case 'r':
				po.exp = false;
				break;
			case 's':
				po.hist = true;
				break;
			case 'u':
				if (!*(s = builtin_opt.optarg))
					po.fd = 0;
				else if ((po.fd = check_fd(s, W_OK, &emsg)) < 0) {
					bi_errorf("-u%s: %s", s, emsg);
					return (1);
				}
				break;
			case '?':
				return (1);
			}

		if (!(builtin_opt.info & GI_MINUSMINUS)) {
			/* treat a lone "-" like "--" */
			if (wp[builtin_opt.optind] &&
			    ksh_isdash(wp[builtin_opt.optind]))
				builtin_opt.optind++;
		}
		wp += builtin_opt.optind;
	}

	if (po.col) {
		if (*wp == NULL)
			return (0);

		XPinit(po.words, 16);
	}

	Xinit(xs, xp, 128, ATEMP);

	if (*wp == NULL)
		goto print_no_arg;
 print_read_arg:
	if (po.chars) {
		while (*wp != NULL) {
			s = *wp++;
			if (*s == '\0')
				break;
			if (!evaluate(s, &po.wc, KSH_RETURN_ERROR, true))
				return (1);
			Xcheck(xs, xp);
			if (UTFMODE) {
				po.ts[utf_wctomb(po.ts, po.wc)] = 0;
				c = 0;
				do {
					Xput(xs, xp, po.ts[c]);
				} while (po.ts[++c]);
			} else
				Xput(xs, xp, po.wc & 0xFF);
		}
	} else {
		s = *wp++;
		while ((c = *s++) != '\0') {
			Xcheck(xs, xp);
			if (po.exp && c == '\\') {
				s_ptr = s;
				c = unbksl(false, s_get, s_put);
				s = s_ptr;
				if (c == -1) {
					/* rejected by generic function */
					switch ((c = *s++)) {
					case 'c':
						po.nl = false;
						/* AT&T brain damage */
						continue;
					case '\0':
						--s;
						c = '\\';
						break;
					default:
						Xput(xs, xp, '\\');
					}
				} else if ((unsigned int)c > 0xFF) {
					/* generic function returned UCS */
					po.ts[utf_wctomb(po.ts, c - 0x100)] = 0;
					c = 0;
					do {
						Xput(xs, xp, po.ts[c]);
					} while (po.ts[++c]);
					continue;
				}
			}
			Xput(xs, xp, c);
		}
	}
	if (po.col) {
		Xput(xs, xp, '\0');
		XPput(po.words, Xclose(xs, xp));
		Xinit(xs, xp, 128, ATEMP);
	}
	if (*wp != NULL) {
		if (!po.col)
			Xput(xs, xp, po.ws);
		goto print_read_arg;
	}
	if (po.col) {
		size_t w = XPsize(po.words);
		struct columnise_opts co;

		XPput(po.words, NULL);
		co.shf = shf_sopen(NULL, 128, SHF_WR | SHF_DYNAMIC, NULL);
		co.linesep = po.ls;
		co.prefcol = co.do_last = false;
		pr_list(&co, (char **)XPptrv(po.words));
		while (w--)
			afree(XPptrv(po.words)[w], ATEMP);
		XPfree(po.words);
		w = co.shf->wp - co.shf->buf;
		XcheckN(xs, xp, w);
		memcpy(xp, co.shf->buf, w);
		xp += w;
		shf_sclose(co.shf);
	}
 print_no_arg:
	if (po.nl)
		Xput(xs, xp, po.ls);

	c = 0;
	if (po.hist) {
		Xput(xs, xp, '\0');
		histsave(&source->line, Xstring(xs, xp), HIST_STORE, false);
	} else {
		size_t len = Xlength(xs, xp);

		/*
		 * Ensure we aren't killed by a SIGPIPE while writing to
		 * a coprocess. AT&T ksh doesn't seem to do this (seems
		 * to just check that the co-process is alive which is
		 * not enough).
		 */
		if (coproc.write >= 0 && coproc.write == po.fd) {
			po.coproc = true;
			po.copipe = block_pipe();
		} else
			po.coproc = po.copipe = false;

		s = Xstring(xs, xp);
		while (len > 0) {
			ssize_t nwritten;

			if ((nwritten = write(po.fd, s, len)) < 0) {
				if (errno == EINTR) {
					if (po.copipe)
						restore_pipe();
					/* give the user a chance to ^C out */
					intrcheck();
					/* interrupted, try again */
					if (po.coproc)
						po.copipe = block_pipe();
					continue;
				}
				c = 1;
				break;
			}
			s += nwritten;
			len -= nwritten;
		}
		if (po.copipe)
			restore_pipe();
	}
	Xfree(xs, xp);

	return (c);
}

static int
s_get(void)
{
	return (ord(*s_ptr++));
}

static void
s_put(int c MKSH_A_UNUSED)
{
	--s_ptr;
}

int
c_whence(const char **wp)
{
	int optc;
	bool pflag = false, vflag = false;

	while ((optc = ksh_getopt(wp, &builtin_opt, Tpv)) != -1)
		switch (optc) {
		case 'p':
			pflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	return (do_whence(wp, pflag ? FC_PATH :
	    FC_BI | FC_FUNC | FC_PATH | FC_WHENCE, vflag, false));
}

/* note: command without -vV is dealt with in comexec() */
int
c_command(const char **wp)
{
	int optc, fcflags = FC_BI | FC_FUNC | FC_PATH | FC_WHENCE;
	bool vflag = false;

	while ((optc = ksh_getopt(wp, &builtin_opt, TpVv)) != -1)
		switch (optc) {
		case 'p':
			fcflags |= FC_DEFPATH;
			break;
		case 'V':
			vflag = true;
			break;
		case 'v':
			vflag = false;
			break;
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	return (do_whence(wp, fcflags, vflag, true));
}

static int
do_whence(const char **wp, int fcflags, bool vflag, bool iscommand)
{
	uint32_t h;
	int rv = 0;
	struct tbl *tp;
	const char *id;

	while ((vflag || rv == 0) && (id = *wp++) != NULL) {
		h = hash(id);
		tp = NULL;

		if (fcflags & FC_WHENCE)
			tp = ktsearch(&keywords, id, h);
		if (!tp && (fcflags & FC_WHENCE)) {
			tp = ktsearch(&aliases, id, h);
			if (tp && !(tp->flag & ISSET))
				tp = NULL;
		}
		if (!tp)
			tp = findcom(id, fcflags);

		switch (tp->type) {
		case CSHELL:
		case CFUNC:
		case CKEYWD:
			shf_puts(id, shl_stdout);
			break;
		}

		switch (tp->type) {
		case CSHELL:
			if (vflag)
				shprintf(" is a %sshell %s",
				    (tp->flag & SPEC_BI) ? "special " : "",
				    Tbuiltin);
			break;
		case CFUNC:
			if (vflag) {
				shf_puts(" is a", shl_stdout);
				if (tp->flag & EXPORT)
					shf_puts("n exported", shl_stdout);
				if (tp->flag & TRACE)
					shf_puts(" traced", shl_stdout);
				if (!(tp->flag & ISSET)) {
					shf_puts(" undefined", shl_stdout);
					if (tp->u.fpath)
						shprintf(" (autoload from %s)",
						    tp->u.fpath);
				}
				shf_puts(T_function, shl_stdout);
			}
			break;
		case CEXEC:
		case CTALIAS:
			if (tp->flag & ISSET) {
				if (vflag) {
					shprintf("%s is ", id);
					if (tp->type == CTALIAS)
						shprintf("a tracked %s%s for ",
						    (tp->flag & EXPORT) ?
						    "exported " : "",
						    Talias);
				}
				shf_puts(tp->val.s, shl_stdout);
			} else {
				if (vflag)
					shprintf(Tnot_found_s, id);
				rv = 1;
			}
			break;
		case CALIAS:
			if (vflag) {
				shprintf("%s is an %s%s for ", id,
				    (tp->flag & EXPORT) ? "exported " : "",
				    Talias);
			} else if (iscommand)
				shprintf("%s %s=", Talias, id);
			print_value_quoted(shl_stdout, tp->val.s);
			break;
		case CKEYWD:
			if (vflag)
				shf_puts(" is a reserved word", shl_stdout);
			break;
#ifndef MKSH_SMALL
		default:
			bi_errorf(Tunexpected_type, id, Tcommand, tp->type);
			return (1);
#endif
		}
		if (vflag || !rv)
			shf_putc('\n', shl_stdout);
	}
	return (rv);
}

bool
valid_alias_name(const char *cp)
{
	if (ord(*cp) == ORD('-'))
		return (false);
	if (ord(cp[0]) == ORD('[') && ord(cp[1]) == ORD('[') && !cp[2])
		return (false);
	while (*cp)
		if (ctype(*cp, C_ALIAS))
			++cp;
		else
			return (false);
	return (true);
}

int
c_alias(const char **wp)
{
	struct table *t = &aliases;
	int rv = 0, prefix = 0;
	bool rflag = false, tflag, Uflag = false, pflag = false, chkalias;
	uint32_t xflag = 0;
	int optc;

	builtin_opt.flags |= GF_PLUSOPT;
	while ((optc = ksh_getopt(wp, &builtin_opt, "dprtUx")) != -1) {
		prefix = builtin_opt.info & GI_PLUS ? '+' : '-';
		switch (optc) {
		case 'd':
#ifdef MKSH_NOPWNAM
			t = NULL;	/* fix "alias -dt" */
#else
			t = &homedirs;
#endif
			break;
		case 'p':
			pflag = true;
			break;
		case 'r':
			rflag = true;
			break;
		case 't':
			t = &taliases;
			break;
		case 'U':
			/*
			 * kludge for tracked alias initialization
			 * (don't do a path search, just make an entry)
			 */
			Uflag = true;
			break;
		case 'x':
			xflag = EXPORT;
			break;
		case '?':
			return (1);
		}
	}
#ifdef MKSH_NOPWNAM
	if (t == NULL)
		return (0);
#endif
	wp += builtin_opt.optind;

	if (!(builtin_opt.info & GI_MINUSMINUS) && *wp &&
	    ctype(wp[0][0], C_MINUS | C_PLUS) && wp[0][1] == '\0') {
		prefix = wp[0][0];
		wp++;
	}

	tflag = t == &taliases;
	chkalias = t == &aliases;

	/* "hash -r" means reset all the tracked aliases.. */
	if (rflag) {
		static const char *args[] = {
			Tunalias, "-ta", NULL
		};

		if (!tflag || *wp) {
			shprintf("%s: -r flag can only be used with -t"
			    " and without arguments\n", Talias);
			return (1);
		}
		ksh_getopt_reset(&builtin_opt, GF_ERROR);
		return (c_unalias(args));
	}

	if (*wp == NULL) {
		struct tbl *ap, **p;

		for (p = ktsort(t); (ap = *p++) != NULL; )
			if ((ap->flag & (ISSET|xflag)) == (ISSET|xflag)) {
				if (pflag)
					shprintf(Tf_s_, Talias);
				shf_puts(ap->name, shl_stdout);
				if (prefix != '+') {
					shf_putc('=', shl_stdout);
					print_value_quoted(shl_stdout, ap->val.s);
				}
				shf_putc('\n', shl_stdout);
			}
	}

	for (; *wp != NULL; wp++) {
		const char *alias = *wp, *val, *newval;
		char *xalias = NULL;
		struct tbl *ap;
		uint32_t h;

		if ((val = cstrchr(alias, '='))) {
			strndupx(xalias, alias, val++ - alias, ATEMP);
			alias = xalias;
		}
		if (chkalias && !valid_alias_name(alias)) {
			bi_errorf(Tinvname, alias, Talias);
			afree(xalias, ATEMP);
			return (1);
		}
		h = hash(alias);
		if (val == NULL && !tflag && !xflag) {
			ap = ktsearch(t, alias, h);
			if (ap != NULL && (ap->flag&ISSET)) {
				if (pflag)
					shprintf(Tf_s_, Talias);
				shf_puts(ap->name, shl_stdout);
				if (prefix != '+') {
					shf_putc('=', shl_stdout);
					print_value_quoted(shl_stdout, ap->val.s);
				}
				shf_putc('\n', shl_stdout);
			} else {
				shprintf(Tf_s_s_sN, alias, Talias, Tnot_found);
				rv = 1;
			}
			continue;
		}
		ap = ktenter(t, alias, h);
		ap->type = tflag ? CTALIAS : CALIAS;
		/* Are we setting the value or just some flags? */
		if ((val && !tflag) || (!val && tflag && !Uflag)) {
			if (ap->flag&ALLOC) {
				ap->flag &= ~(ALLOC|ISSET);
				afree(ap->val.s, APERM);
			}
			/* ignore values for -t (AT&T ksh does this) */
			newval = tflag ?
			    search_path(alias, path, X_OK, NULL) :
			    val;
			if (newval) {
				strdupx(ap->val.s, newval, APERM);
				ap->flag |= ALLOC|ISSET;
			} else
				ap->flag &= ~ISSET;
		}
		ap->flag |= DEFINED;
		if (prefix == '+')
			ap->flag &= ~xflag;
		else
			ap->flag |= xflag;
		afree(xalias, ATEMP);
	}

	return (rv);
}

int
c_unalias(const char **wp)
{
	struct table *t = &aliases;
	struct tbl *ap;
	int optc, rv = 0;
	bool all = false;

	while ((optc = ksh_getopt(wp, &builtin_opt, "adt")) != -1)
		switch (optc) {
		case 'a':
			all = true;
			break;
		case 'd':
#ifdef MKSH_NOPWNAM
			/* fix "unalias -dt" */
			t = NULL;
#else
			t = &homedirs;
#endif
			break;
		case 't':
			t = &taliases;
			break;
		case '?':
			return (1);
		}
#ifdef MKSH_NOPWNAM
	if (t == NULL)
		return (0);
#endif
	wp += builtin_opt.optind;

	for (; *wp != NULL; wp++) {
		ap = ktsearch(t, *wp, hash(*wp));
		if (ap == NULL) {
			/* POSIX */
			rv = 1;
			continue;
		}
		if (ap->flag&ALLOC) {
			ap->flag &= ~(ALLOC|ISSET);
			afree(ap->val.s, APERM);
		}
		ap->flag &= ~(DEFINED|ISSET|EXPORT);
	}

	if (all) {
		struct tstate ts;

		for (ktwalk(&ts, t); (ap = ktnext(&ts)); ) {
			if (ap->flag&ALLOC) {
				ap->flag &= ~(ALLOC|ISSET);
				afree(ap->val.s, APERM);
			}
			ap->flag &= ~(DEFINED|ISSET|EXPORT);
		}
	}

	return (rv);
}

int
c_let(const char **wp)
{
	int rv = 1;
	mksh_ari_t val;

	if (wp[1] == NULL)
		/* AT&T ksh does this */
		bi_errorf(Tno_args);
	else
		for (wp++; *wp; wp++)
			if (!evaluate(*wp, &val, KSH_RETURN_ERROR, true)) {
				/* distinguish error from zero result */
				rv = 2;
				break;
			} else
				rv = val == 0;
	return (rv);
}

int
c_jobs(const char **wp)
{
	int optc, flag = 0, nflag = 0, rv = 0;

	while ((optc = ksh_getopt(wp, &builtin_opt, "lpnz")) != -1)
		switch (optc) {
		case 'l':
			flag = 1;
			break;
		case 'p':
			flag = 2;
			break;
		case 'n':
			nflag = 1;
			break;
		case 'z':
			/* debugging: print zombies */
			nflag = -1;
			break;
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;
	if (!*wp) {
		if (j_jobs(NULL, flag, nflag))
			rv = 1;
	} else {
		for (; *wp; wp++)
			if (j_jobs(*wp, flag, nflag))
				rv = 1;
	}
	return (rv);
}

#ifndef MKSH_UNEMPLOYED
int
c_fgbg(const char **wp)
{
	bool bg = strcmp(*wp, Tbg) == 0;
	int rv = 0;

	if (!Flag(FMONITOR)) {
		bi_errorf("job control not enabled");
		return (1);
	}
	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	wp += builtin_opt.optind;
	if (*wp)
		for (; *wp; wp++)
			rv = j_resume(*wp, bg);
	else
		rv = j_resume("%%", bg);
	/* fg returns $? of the job unless POSIX */
	return ((bg | Flag(FPOSIX)) ? 0 : rv);
}
#endif

/* format a single kill item */
static void
kill_fmt_entry(char *buf, size_t buflen, unsigned int i, const void *arg)
{
	const struct kill_info *ki = (const struct kill_info *)arg;

	i++;
	shf_snprintf(buf, buflen, "%*u %*s %s",
	    ki->num_width, i,
	    ki->name_width, sigtraps[i].name,
	    sigtraps[i].mess);
}

int
c_kill(const char **wp)
{
	Trap *t = NULL;
	const char *p;
	bool lflag = false;
	int i, n, rv, sig;

	/* assume old style options if -digits or -UPPERCASE */
	if ((p = wp[1]) && *p == '-' && ctype(p[1], C_DIGIT | C_UPPER)) {
		if (!(t = gettrap(p + 1, false, false))) {
			bi_errorf(Tbad_sig_s, p + 1);
			return (1);
		}
		i = (wp[2] && strcmp(wp[2], "--") == 0) ? 3 : 2;
	} else {
		int optc;

		while ((optc = ksh_getopt(wp, &builtin_opt, "ls:")) != -1)
			switch (optc) {
			case 'l':
				lflag = true;
				break;
			case 's':
				if (!(t = gettrap(builtin_opt.optarg,
				    true, false))) {
					bi_errorf(Tbad_sig_s,
					    builtin_opt.optarg);
					return (1);
				}
				break;
			case '?':
				return (1);
			}
		i = builtin_opt.optind;
	}
	if ((lflag && t) || (!wp[i] && !lflag)) {
#ifndef MKSH_SMALL
		shf_puts("usage:\tkill [-s signame | -signum | -signame]"
		    " { job | pid | pgrp } ...\n"
		    "\tkill -l [exit_status ...]\n", shl_out);
#endif
		bi_errorfz();
		return (1);
	}

	if (lflag) {
		if (wp[i]) {
			for (; wp[i]; i++) {
				if (!bi_getn(wp[i], &n))
					return (1);
#if (ksh_NSIG <= 128)
				if (n > 128 && n < 128 + ksh_NSIG)
					n -= 128;
#endif
				if (n > 0 && n < ksh_NSIG)
					shprintf(Tf_sN, sigtraps[n].name);
				else
					shprintf(Tf_dN, n);
			}
		} else if (Flag(FPOSIX)) {
			n = 1;
			while (n < ksh_NSIG) {
				shf_puts(sigtraps[n].name, shl_stdout);
				shf_putc(++n == ksh_NSIG ? '\n' : ' ',
				    shl_stdout);
			}
		} else {
			ssize_t w, mess_cols = 0, mess_octs = 0;
			int j = ksh_NSIG - 1;
			struct kill_info ki = { 0, 0 };
			struct columnise_opts co;

			do {
				ki.num_width++;
			} while ((j /= 10));

			for (j = 1; j < ksh_NSIG; j++) {
				w = strlen(sigtraps[j].name);
				if (w > ki.name_width)
					ki.name_width = w;
				w = strlen(sigtraps[j].mess);
				if (w > mess_octs)
					mess_octs = w;
				w = utf_mbswidth(sigtraps[j].mess);
				if (w > mess_cols)
					mess_cols = w;
			}

			co.shf = shl_stdout;
			co.linesep = '\n';
			co.prefcol = co.do_last = true;

			print_columns(&co, (unsigned int)(ksh_NSIG - 1),
			    kill_fmt_entry, (void *)&ki,
			    ki.num_width + 1 + ki.name_width + 1 + mess_octs,
			    ki.num_width + 1 + ki.name_width + 1 + mess_cols);
		}
		return (0);
	}
	rv = 0;
	sig = t ? t->signal : SIGTERM;
	for (; (p = wp[i]); i++) {
		if (*p == '%') {
			if (j_kill(p, sig))
				rv = 1;
		} else if (!getn(p, &n)) {
			bi_errorf(Tf_sD_s, p,
			    "arguments must be jobs or process IDs");
			rv = 1;
		} else {
			if (mksh_kill(n, sig) < 0) {
				bi_errorf(Tf_sD_s, p, cstrerror(errno));
				rv = 1;
			}
		}
	}
	return (rv);
}

void
getopts_reset(int val)
{
	if (val >= 1) {
		ksh_getopt_reset(&user_opt, GF_NONAME |
		    (Flag(FPOSIX) ? 0 : GF_PLUSOPT));
		user_opt.optind = user_opt.uoptind = val;
	}
}

int
c_getopts(const char **wp)
{
	int argc, optc, rv;
	const char *opts, *var;
	char buf[3];
	struct tbl *vq, *voptarg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	wp += builtin_opt.optind;

	opts = *wp++;
	if (!opts) {
		bi_errorf(Tf_sD_s, "options", Tno_args);
		return (1);
	}

	var = *wp++;
	if (!var) {
		bi_errorf(Tf_sD_s, Tname, Tno_args);
		return (1);
	}
	if (!*var || *skip_varname(var, true)) {
		bi_errorf(Tf_sD_s, var, Tnot_ident);
		return (1);
	}

	if (e->loc->next == NULL) {
		internal_warningf(Tf_sD_s, Tgetopts, Tno_args);
		return (1);
	}
	/* Which arguments are we parsing... */
	if (*wp == NULL)
		wp = e->loc->next->argv;
	else
		*--wp = e->loc->next->argv[0];

	/* Check that our saved state won't cause a core dump... */
	for (argc = 0; wp[argc]; argc++)
		;
	if (user_opt.optind > argc ||
	    (user_opt.p != 0 &&
	    user_opt.p > strlen(wp[user_opt.optind - 1]))) {
		bi_errorf("arguments changed since last call");
		return (1);
	}

	user_opt.optarg = NULL;
	optc = ksh_getopt(wp, &user_opt, opts);

	if (optc >= 0 && optc != '?' && (user_opt.info & GI_PLUS)) {
		buf[0] = '+';
		buf[1] = optc;
		buf[2] = '\0';
	} else {
		/*
		 * POSIX says var is set to ? at end-of-options, AT&T ksh
		 * sets it to null - we go with POSIX...
		 */
		buf[0] = optc < 0 ? '?' : optc;
		buf[1] = '\0';
	}

	/* AT&T ksh93 in fact does change OPTIND for unknown options too */
	user_opt.uoptind = user_opt.optind;

	voptarg = global("OPTARG");
	/* AT&T ksh clears ro and int */
	voptarg->flag &= ~RDONLY;
	/* Paranoia: ensure no bizarre results. */
	if (voptarg->flag & INTEGER)
	    typeset("OPTARG", 0, INTEGER, 0, 0);
	if (user_opt.optarg == NULL)
		unset(voptarg, 1);
	else
		/* this can't fail (haing cleared readonly/integer) */
		setstr(voptarg, user_opt.optarg, KSH_RETURN_ERROR);

	rv = 0;

	vq = global(var);
	/* Error message already printed (integer, readonly) */
	if (!setstr(vq, buf, KSH_RETURN_ERROR))
		rv = 2;
	if (Flag(FEXPORT))
		typeset(var, EXPORT, 0, 0, 0);

	return (optc < 0 ? 1 : rv);
}

#ifndef MKSH_NO_CMDLINE_EDITING
int
c_bind(const char **wp)
{
	int optc, rv = 0;
#ifndef MKSH_SMALL
	bool macro = false;
#endif
	bool list = false;
	const char *cp;
	char *up;

	while ((optc = ksh_getopt(wp, &builtin_opt,
#ifndef MKSH_SMALL
	    "lm"
#else
	    "l"
#endif
	    )) != -1)
		switch (optc) {
		case 'l':
			list = true;
			break;
#ifndef MKSH_SMALL
		case 'm':
			macro = true;
			break;
#endif
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	if (*wp == NULL)
		/* list all */
		rv = x_bind(NULL, NULL,
#ifndef MKSH_SMALL
		    false,
#endif
		    list);

	for (; *wp != NULL; wp++) {
		if ((cp = cstrchr(*wp, '=')) == NULL)
			up = NULL;
		else {
			strdupx(up, *wp, ATEMP);
			up[cp++ - *wp] = '\0';
		}
		if (x_bind(up ? up : *wp, cp,
#ifndef MKSH_SMALL
		    macro,
#endif
		    false))
			rv = 1;
		afree(up, ATEMP);
	}

	return (rv);
}
#endif

int
c_shift(const char **wp)
{
	int n;
	mksh_ari_t val;
	const char *arg;
	struct block *l = e->loc;

	if ((l->flags & BF_RESETSPEC)) {
		/* prevent pollution */
		l->flags &= ~BF_RESETSPEC;
		/* operate on parent environment */
		l = l->next;
	}

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	arg = wp[builtin_opt.optind];

	if (!arg)
		n = 1;
	else if (!evaluate(arg, &val, KSH_RETURN_ERROR, false)) {
		/* error already printed */
		bi_errorfz();
		return (1);
	} else if (!(n = val)) {
		/* nothing to do */
		return (0);
	} else if (n < 0) {
		bi_errorf(Tf_sD_s, Tbadnum, arg);
		return (1);
	}

	if (l->argc < n) {
		bi_errorf("nothing to shift");
		return (1);
	}
	l->argv[n] = l->argv[0];
	l->argv += n;
	l->argc -= n;
	return (0);
}

int
c_umask(const char **wp)
{
	int i, optc;
	const char *cp;
	bool symbolic = false;
	mode_t old_umask;

	while ((optc = ksh_getopt(wp, &builtin_opt, "S")) != -1)
		switch (optc) {
		case 'S':
			symbolic = true;
			break;
		case '?':
			return (1);
		}
	cp = wp[builtin_opt.optind];
	if (cp == NULL) {
		old_umask = umask((mode_t)0);
		umask(old_umask);
		if (symbolic) {
			char buf[18], *p;
			int j;

			old_umask = ~old_umask;
			p = buf;
			for (i = 0; i < 3; i++) {
				*p++ = Tugo[i];
				*p++ = '=';
				for (j = 0; j < 3; j++)
					if (old_umask & (1 << (8 - (3*i + j))))
						*p++ = "rwx"[j];
				*p++ = ',';
			}
			p[-1] = '\0';
			shprintf(Tf_sN, buf);
		} else
			shprintf("%#3.3o\n", (unsigned int)old_umask);
	} else {
		mode_t new_umask;

		if (ctype(*cp, C_DIGIT)) {
			new_umask = 0;
			while (ctype(*cp, C_OCTAL)) {
				new_umask = new_umask * 8 + ksh_numdig(*cp);
				++cp;
			}
			if (*cp) {
				bi_errorf(Tbadnum);
				return (1);
			}
		} else {
			/* symbolic format */
			int positions, new_val;
			char op;

			old_umask = umask((mode_t)0);
			/* in case of error */
			umask(old_umask);
			old_umask = ~old_umask;
			new_umask = old_umask;
			positions = 0;
			while (*cp) {
				while (*cp && vstrchr(Taugo, *cp))
					switch (*cp++) {
					case 'a':
						positions |= 0111;
						break;
					case 'u':
						positions |= 0100;
						break;
					case 'g':
						positions |= 0010;
						break;
					case 'o':
						positions |= 0001;
						break;
					}
				if (!positions)
					/* default is a */
					positions = 0111;
				if (!ctype((op = *cp), C_EQUAL | C_MINUS | C_PLUS))
					break;
				cp++;
				new_val = 0;
				while (*cp && vstrchr("rwxugoXs", *cp))
					switch (*cp++) {
					case 'r': new_val |= 04; break;
					case 'w': new_val |= 02; break;
					case 'x': new_val |= 01; break;
					case 'u':
						new_val |= old_umask >> 6;
						break;
					case 'g':
						new_val |= old_umask >> 3;
						break;
					case 'o':
						new_val |= old_umask >> 0;
						break;
					case 'X':
						if (old_umask & 0111)
							new_val |= 01;
						break;
					case 's':
						/* ignored */
						break;
					}
				new_val = (new_val & 07) * positions;
				switch (op) {
				case '-':
					new_umask &= ~new_val;
					break;
				case '=':
					new_umask = new_val |
					    (new_umask & ~(positions * 07));
					break;
				case '+':
					new_umask |= new_val;
				}
				if (*cp == ',') {
					positions = 0;
					cp++;
				} else if (!ctype(*cp, C_EQUAL | C_MINUS | C_PLUS))
					break;
			}
			if (*cp) {
				bi_errorf("bad mask");
				return (1);
			}
			new_umask = ~new_umask;
		}
		umask(new_umask);
	}
	return (0);
}

int
c_dot(const char **wp)
{
	const char *file, *cp, **argv;
	int argc, rv, errcode;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);

	if ((cp = wp[builtin_opt.optind]) == NULL) {
		bi_errorf(Tno_args);
		return (1);
	}
	file = search_path(cp, path, R_OK, &errcode);
	if (!file && errcode == ENOENT && wp[0][0] == 's' &&
	    search_access(cp, R_OK) == 0)
		file = cp;
	if (!file) {
		bi_errorf(Tf_sD_s, cp, cstrerror(errcode));
		return (1);
	}

	/* Set positional parameters? */
	if (wp[builtin_opt.optind + 1]) {
		argv = wp + builtin_opt.optind;
		/* preserve $0 */
		argv[0] = e->loc->argv[0];
		for (argc = 0; argv[argc + 1]; argc++)
			;
	} else {
		argc = 0;
		argv = NULL;
	}
	/* SUSv4: OR with a high value never written otherwise */
	exstat |= 0x4000;
	if ((rv = include(file, argc, argv, false)) < 0) {
		/* should not happen */
		bi_errorf(Tf_sD_s, cp, cstrerror(errno));
		return (1);
	}
	if (exstat & 0x4000)
		/* detect old exstat, use 0 in that case */
		rv = 0;
	return (rv);
}

int
c_wait(const char **wp)
{
	int rv = 0, sig;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	wp += builtin_opt.optind;
	if (*wp == NULL) {
		while (waitfor(NULL, &sig) >= 0)
			;
		rv = sig;
	} else {
		for (; *wp; wp++)
			rv = waitfor(*wp, &sig);
		if (rv < 0)
			/* magic exit code: bad job-id */
			rv = sig ? sig : 127;
	}
	return (rv);
}

static const char REPLY[] = "REPLY";
int
c_read(const char **wp)
{
#define is_ifsws(c) (ctype((c), C_IFS) && ctype((c), C_IFSWS))
	int c, fd = 0, rv = 0;
	bool savehist = false, intoarray = false, aschars = false;
	bool rawmode = false, expanding = false;
	bool lastparmmode = false, lastparmused = false;
	enum { LINES, BYTES, UPTO, READALL } readmode = LINES;
	char delim = '\n';
	size_t bytesleft = 128, bytesread;
	struct tbl *vp /* FU gcc */ = NULL, *vq = NULL;
	char *cp, *allocd = NULL, *xp;
	const char *ccp;
	XString xs;
	size_t xsave = 0;
	mksh_ttyst tios;
	bool restore_tios = false;
	/* to catch read -aN2 foo[i] */
	bool subarray = false;
#if HAVE_SELECT
	bool hastimeout = false;
	struct timeval tv, tvlim;
#define c_read_opts "Aad:N:n:prst:u,"
#else
#define c_read_opts "Aad:N:n:prsu,"
#endif
#if defined(__OS2__) && defined(MKSH_WITH_TEXTMODE)
	int saved_mode;
	int saved_errno;
#endif

	while ((c = ksh_getopt(wp, &builtin_opt, c_read_opts)) != -1)
	switch (c) {
	case 'a':
		aschars = true;
		/* FALLTHROUGH */
	case 'A':
		intoarray = true;
		break;
	case 'd':
		delim = builtin_opt.optarg[0];
		break;
	case 'N':
	case 'n':
		readmode = c == 'N' ? BYTES : UPTO;
		if (!bi_getn(builtin_opt.optarg, &c))
			return (2);
		if (c == -1) {
			readmode = readmode == BYTES ? READALL : UPTO;
			bytesleft = 1024;
		} else
			bytesleft = (unsigned int)c;
		break;
	case 'p':
		if ((fd = coproc_getfd(R_OK, &ccp)) < 0) {
			bi_errorf(Tf_coproc, ccp);
			return (2);
		}
		break;
	case 'r':
		rawmode = true;
		break;
	case 's':
		savehist = true;
		break;
#if HAVE_SELECT
	case 't':
		if (parse_usec(builtin_opt.optarg, &tv)) {
			bi_errorf(Tf_sD_s_qs, Tsynerr, cstrerror(errno),
			    builtin_opt.optarg);
			return (2);
		}
		hastimeout = true;
		break;
#endif
	case 'u':
		if (!builtin_opt.optarg[0])
			fd = 0;
		else if ((fd = check_fd(builtin_opt.optarg, R_OK, &ccp)) < 0) {
			bi_errorf(Tf_sD_sD_s, "-u", builtin_opt.optarg, ccp);
			return (2);
		}
		break;
	case '?':
		return (2);
	}
	wp += builtin_opt.optind;
	if (*wp == NULL)
		*--wp = REPLY;

	if (intoarray && wp[1] != NULL) {
		bi_errorf(Ttoo_many_args);
		return (2);
	}

	if ((ccp = cstrchr(*wp, '?')) != NULL) {
		strdupx(allocd, *wp, ATEMP);
		allocd[ccp - *wp] = '\0';
		*wp = allocd;
		if (isatty(fd)) {
			/*
			 * AT&T ksh says it prints prompt on fd if it's open
			 * for writing and is a tty, but it doesn't do it
			 * (it also doesn't check the interactive flag,
			 * as is indicated in the Korn Shell book).
			 */
			shf_puts(ccp + 1, shl_out);
			shf_flush(shl_out);
		}
	}

	Xinit(xs, xp, bytesleft, ATEMP);

	if (readmode == LINES)
		bytesleft = 1;
	else if (isatty(fd)) {
		x_mkraw(fd, &tios, true);
		restore_tios = true;
	}

#if HAVE_SELECT
	if (hastimeout) {
		mksh_TIME(tvlim);
		timeradd(&tvlim, &tv, &tvlim);
	}
#endif

 c_read_readloop:
#if HAVE_SELECT
	if (hastimeout) {
		fd_set fdset;

		FD_ZERO(&fdset);
		FD_SET((unsigned int)fd, &fdset);
		mksh_TIME(tv);
		timersub(&tvlim, &tv, &tv);
		if (tv.tv_sec < 0) {
			/* timeout expired globally */
			rv = 3;
			goto c_read_out;
		}

		switch (select(fd + 1, &fdset, NULL, NULL, &tv)) {
		case 1:
			break;
		case 0:
			/* timeout expired for this call */
			bytesread = 0;
			rv = 3;
			goto c_read_readdone;
		default:
			bi_errorf(Tf_sD_s, Tselect, cstrerror(errno));
			rv = 2;
			goto c_read_out;
		}
	}
#endif

#if defined(__OS2__) && defined(MKSH_WITH_TEXTMODE)
	saved_mode = setmode(fd, O_TEXT);
#endif
	if ((bytesread = blocking_read(fd, xp, bytesleft)) == (size_t)-1) {
#if defined(__OS2__) && defined(MKSH_WITH_TEXTMODE)
		saved_errno = errno;
		setmode(fd, saved_mode);
		errno = saved_errno;
#endif
		if (errno == EINTR) {
			/* check whether the signal would normally kill */
			if (!fatal_trap_check()) {
				/* no, just ignore the signal */
				goto c_read_readloop;
			}
			/* pretend the read was killed */
		} else {
			/* unexpected error */
			bi_errorf(Tf_s, cstrerror(errno));
		}
		rv = 2;
		goto c_read_out;
	}
#if defined(__OS2__) && defined(MKSH_WITH_TEXTMODE)
	setmode(fd, saved_mode);
#endif

	switch (readmode) {
	case READALL:
		if (bytesread == 0) {
			/* end of file reached */
			rv = 1;
			goto c_read_readdone;
		}
		xp += bytesread;
		XcheckN(xs, xp, bytesleft);
		break;

	case UPTO:
		if (bytesread == 0)
			/* end of file reached */
			rv = 1;
		xp += bytesread;
		goto c_read_readdone;

	case BYTES:
		if (bytesread == 0) {
			/* end of file reached */
			rv = 1;
			/* may be partial read: $? = 1, but content */
			goto c_read_readdone;
		}
		xp += bytesread;
		if ((bytesleft -= bytesread) == 0)
			goto c_read_readdone;
		break;
	case LINES:
		if (bytesread == 0) {
			/* end of file reached */
			rv = 1;
			goto c_read_readdone;
		}
		if ((c = *xp) == '\0' && !aschars && delim != '\0') {
			/* skip any read NULs unless delimiter */
			break;
		}
		if (expanding) {
			expanding = false;
			if (c == delim) {
				if (Flag(FTALKING_I) && isatty(fd)) {
					/*
					 * set prompt in case this is
					 * called from .profile or $ENV
					 */
					set_prompt(PS2, NULL);
					pprompt(prompt, 0);
				}
				/* drop the backslash */
				--xp;
				/* and the delimiter */
				break;
			}
		} else if (c == delim) {
			goto c_read_readdone;
		} else if (!rawmode && c == '\\') {
			expanding = true;
		}
		Xcheck(xs, xp);
		++xp;
		break;
	}
	goto c_read_readloop;

 c_read_readdone:
	bytesread = Xlength(xs, xp);
	Xput(xs, xp, '\0');

	/*-
	 * state: we finished reading the input and NUL terminated it
	 * Xstring(xs, xp) -> xp-1 = input string without trailing delim
	 * rv = 3 if timeout, 1 if EOF, 0 otherwise (errors handled already)
	 */

	if (rv) {
		/* clean up coprocess if needed, on EOF/error/timeout */
		coproc_read_close(fd);
		if (readmode == READALL && (rv == 1 || (rv == 3 && bytesread)))
			/* EOF is no error here */
			rv = 0;
	}

	if (savehist)
		histsave(&source->line, Xstring(xs, xp), HIST_STORE, false);

	ccp = cp = Xclose(xs, xp);
	expanding = false;
	XinitN(xs, 128, ATEMP);
	if (intoarray) {
		vp = global(*wp);
		subarray = last_lookup_was_array;
		if (vp->flag & RDONLY) {
 c_read_splitro:
			bi_errorf(Tf_ro, *wp);
 c_read_spliterr:
			rv = 2;
			afree(cp, ATEMP);
			goto c_read_out;
		}
		/* counter for array index */
		c = subarray ? arrayindex(vp) : 0;
		/* exporting an array is currently pointless */
		unset(vp, subarray ? 0 : 1);
	}
	if (!aschars) {
		/* skip initial IFS whitespace */
		while (bytesread && is_ifsws(*ccp)) {
			++ccp;
			--bytesread;
		}
		/* trim trailing IFS whitespace */
		while (bytesread && is_ifsws(ccp[bytesread - 1])) {
			--bytesread;
		}
	}
 c_read_splitloop:
	xp = Xstring(xs, xp);
	/* generate next word */
	if (!bytesread) {
		/* no more input */
		if (intoarray)
			goto c_read_splitdone;
		/* zero out next parameters */
		goto c_read_gotword;
	}
	if (aschars) {
		Xput(xs, xp, '1');
		Xput(xs, xp, '#');
		bytesleft = utf_ptradj(ccp);
		while (bytesleft && bytesread) {
			*xp++ = *ccp++;
			--bytesleft;
			--bytesread;
		}
		if (xp[-1] == '\0') {
			xp[-1] = '0';
			xp[-3] = '2';
		}
		goto c_read_gotword;
	}

	if (!intoarray && wp[1] == NULL)
		lastparmmode = true;

 c_read_splitlast:
	/* copy until IFS character */
	while (bytesread) {
		char ch;

		ch = *ccp;
		if (expanding) {
			expanding = false;
			goto c_read_splitcopy;
		} else if (ctype(ch, C_IFS)) {
			break;
		} else if (!rawmode && ch == '\\') {
			expanding = true;
		} else {
 c_read_splitcopy:
			Xcheck(xs, xp);
			Xput(xs, xp, ch);
		}
		++ccp;
		--bytesread;
	}
	xsave = Xsavepos(xs, xp);
	/* copy word delimiter: IFSWS+IFS,IFSWS */
	expanding = false;
	while (bytesread) {
		char ch;

		ch = *ccp;
		if (!ctype(ch, C_IFS))
			break;
		if (lastparmmode && !expanding && !rawmode && ch == '\\') {
			expanding = true;
		} else {
			Xcheck(xs, xp);
			Xput(xs, xp, ch);
		}
		++ccp;
		--bytesread;
		if (expanding)
			continue;
		if (!ctype(ch, C_IFSWS))
			break;
	}
	while (bytesread && is_ifsws(*ccp)) {
		Xcheck(xs, xp);
		Xput(xs, xp, *ccp);
		++ccp;
		--bytesread;
	}
	/* if no more parameters, rinse and repeat */
	if (lastparmmode && bytesread) {
		lastparmused = true;
		goto c_read_splitlast;
	}
	/* get rid of the delimiter unless we pack the rest */
	if (!lastparmused)
		xp = Xrestpos(xs, xp, xsave);
 c_read_gotword:
	Xput(xs, xp, '\0');
	if (intoarray) {
		if (subarray) {
			/* array element passed, accept first read */
			if (vq) {
				bi_errorf("nested arrays not yet supported");
				goto c_read_spliterr;
			}
			vq = vp;
			if (c)
				/* [0] doesn't */
				vq->flag |= AINDEX;
		} else
			vq = arraysearch(vp, c++);
	} else {
		vq = global(*wp);
		/* must be checked before exporting */
		if (vq->flag & RDONLY)
			goto c_read_splitro;
		if (Flag(FEXPORT))
			typeset(*wp, EXPORT, 0, 0, 0);
	}
	if (!setstr(vq, Xstring(xs, xp), KSH_RETURN_ERROR))
		goto c_read_spliterr;
	if (aschars) {
		setint_v(vq, vq, false);
		/* protect from UTFMODE changes */
		vq->type = 0;
	}
	if (intoarray || *++wp != NULL)
		goto c_read_splitloop;

 c_read_splitdone:
	/* free up */
	afree(cp, ATEMP);

 c_read_out:
	afree(allocd, ATEMP);
	Xfree(xs, xp);
	if (restore_tios)
		mksh_tcset(fd, &tios);
	return (rv == 3 ? ksh_sigmask(SIGALRM) : rv);
#undef is_ifsws
}

int
c_eval(const char **wp)
{
	struct source *s, *saves = source;
	int rv;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	s = pushs(SWORDS, ATEMP);
	s->u.strv = wp + builtin_opt.optind;
	s->line = current_lineno;

	/*-
	 * The following code handles the case where the command is
	 * empty due to failed command substitution, for example by
	 *	eval "$(false)"
	 * This has historically returned 1 by AT&T ksh88. In this
	 * case, shell() will not set or change exstat because the
	 * compiled tree is empty, so it will use the value we pass
	 * from subst_exstat, which is cleared in execute(), so it
	 * should have been 0 if there were no substitutions.
	 *
	 * POSIX however says we don't do this, even though it is
	 * traditionally done. AT&T ksh93 agrees with POSIX, so we
	 * do. The following is an excerpt from SUSv4 [1003.2-2008]:
	 *
	 * 2.9.1: Simple Commands
	 *	... If there is a command name, execution shall
	 *	continue as described in 2.9.1.1 [Command Search
	 *	and Execution]. If there is no command name, but
	 *	the command contained a command substitution, the
	 *	command shall complete with the exit status of the
	 *	last command substitution performed.
	 * 2.9.1.1: Command Search and Execution
	 *	(1) a. If the command name matches the name of a
	 *	special built-in utility, that special built-in
	 *	utility shall be invoked.
	 * 2.14.5: eval
	 *	If there are no arguments, or only null arguments,
	 *	eval shall return a zero exit status; ...
	 */
	/* AT&T ksh88: use subst_exstat */
	/* exstat = subst_exstat; */
	/* SUSv4: OR with a high value never written otherwise */
	exstat |= 0x4000;

	rv = shell(s, 2);
	source = saves;
	afree(s, ATEMP);
	if (exstat & 0x4000)
		/* detect old exstat, use 0 in that case */
		rv = 0;
	return (rv);
}

int
c_trap(const char **wp)
{
	Trap *p = sigtraps;
	int i = ksh_NSIG;
	const char *s;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		return (1);
	wp += builtin_opt.optind;

	if (*wp == NULL) {
		do {
			if (p->trap) {
				shf_puts("trap -- ", shl_stdout);
				print_value_quoted(shl_stdout, p->trap);
				shprintf(Tf__sN, p->name);
			}
			++p;
		} while (i--);
		return (0);
	}

	if (getn(*wp, &i)) {
		/* first argument is a signal number, reset them all */
		s = NULL;
	} else {
		/* first argument must be a command, then */
		s = *wp++;
		/* reset traps? */
		if (ksh_isdash(s))
			s = NULL;
	}

	/* set/clear the traps */
	i = 0;
	while (*wp)
		if (!(p = gettrap(*wp++, true, true))) {
			warningf(true, Tbad_sig_ss, builtin_argv0, wp[-1]);
			i = 1;
		} else
			settrap(p, s);
	return (i);
}

int
c_exitreturn(const char **wp)
{
	int n, how = LEXIT;

	if (wp[1]) {
		if (wp[2])
			goto c_exitreturn_err;
		exstat = bi_getn(wp[1], &n) ? (n & 0xFF) : 1;
	} else if (trap_exstat != -1)
		exstat = trap_exstat;

	if (wp[0][0] == 'r') {
		/* return */
		struct env *ep;

		/*
		 * need to tell if this is exit or return so trap exit will
		 * work right (POSIX)
		 */
		for (ep = e; ep; ep = ep->oenv)
			if (STOP_RETURN(ep->type)) {
				how = LRETURN;
				break;
			}
	}

	if (how == LEXIT && !really_exit && j_stopped_running()) {
		really_exit = true;
		how = LSHELL;
	}

	/* get rid of any I/O redirections */
	quitenv(NULL);
	unwind(how);
	/* NOTREACHED */

 c_exitreturn_err:
	bi_errorf(Ttoo_many_args);
	return (1);
}

int
c_brkcont(const char **wp)
{
	unsigned int quit;
	int n;
	struct env *ep, *last_ep = NULL;
	const char *arg;

	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		goto c_brkcont_err;
	arg = wp[builtin_opt.optind];

	if (!arg)
		n = 1;
	else if (!bi_getn(arg, &n))
		goto c_brkcont_err;
	if (n <= 0) {
		/* AT&T ksh does this for non-interactive shells only - weird */
		bi_errorf("%s: bad value", arg);
		goto c_brkcont_err;
	}
	quit = (unsigned int)n;

	/* Stop at E_NONE, E_PARSE, E_FUNC, or E_INCL */
	for (ep = e; ep && !STOP_BRKCONT(ep->type); ep = ep->oenv)
		if (ep->type == E_LOOP) {
			if (--quit == 0)
				break;
			ep->flags |= EF_BRKCONT_PASS;
			last_ep = ep;
		}

	if (quit) {
		/*
		 * AT&T ksh doesn't print a message - just does what it
		 * can. We print a message 'cause it helps in debugging
		 * scripts, but don't generate an error (ie, keep going).
		 */
		if ((unsigned int)n == quit) {
			warningf(true, Tf_cant_s, wp[0], wp[0]);
			return (0);
		}
		/*
		 * POSIX says if n is too big, the last enclosing loop
		 * shall be used. Doesn't say to print an error but we
		 * do anyway 'cause the user messed up.
		 */
		if (last_ep)
			last_ep->flags &= ~EF_BRKCONT_PASS;
		warningf(true, "%s: can only %s %u level(s)",
		    wp[0], wp[0], (unsigned int)n - quit);
	}

	unwind(*wp[0] == 'b' ? LBREAK : LCONTIN);
	/* NOTREACHED */

 c_brkcont_err:
	return (1);
}

int
c_set(const char **wp)
{
	int argi;
	bool setargs;
	struct block *l = e->loc;

	if ((l->flags & BF_RESETSPEC)) {
		/* prevent pollution */
		l->flags &= ~BF_RESETSPEC;
		/* operate on parent environment */
		l = l->next;
	}

	if (wp[1] == NULL) {
		static const char *args[] = { Tset, "-", NULL };
		return (c_typeset(args));
	}

	if ((argi = parse_args(wp, OF_SET, &setargs)) < 0)
		return (2);
	/* set $# and $* */
	if (setargs) {
		const char **owp;

		wp += argi - 1;
		owp = wp;
		/* save $0 */
		wp[0] = l->argv[0];
		while (*++wp != NULL)
			strdupx(*wp, *wp, &l->area);
		l->argc = wp - owp - 1;
		l->argv = alloc2(l->argc + 2, sizeof(char *), &l->area);
		for (wp = l->argv; (*wp++ = *owp++) != NULL; )
			;
	}
	/*-
	 * POSIX says set exit status is 0, but old scripts that use
	 * getopt(1) use the construct
	 *	set -- $(getopt ab:c "$@@")
	 * which assumes the exit value set will be that of the $()
	 * (subst_exstat is cleared in execute() so that it will be 0
	 * if there are no command substitutions).
	 */
#ifdef MKSH_LEGACY_MODE
	/* traditional behaviour, unless set -o posix */
	return (Flag(FPOSIX) ? 0 : subst_exstat);
#else
	/* conformant behaviour, unless set -o sh +o posix */
	return (Flag(FSH) && !Flag(FPOSIX) ? subst_exstat : 0);
#endif
}

int
c_unset(const char **wp)
{
	const char *id;
	int optc, rv = 0;
	bool unset_var = true;

	while ((optc = ksh_getopt(wp, &builtin_opt, "fv")) != -1)
		switch (optc) {
		case 'f':
			unset_var = false;
			break;
		case 'v':
			unset_var = true;
			break;
		case '?':
			/*XXX not reached due to GF_ERROR */
			return (2);
		}
	wp += builtin_opt.optind;
	for (; (id = *wp) != NULL; wp++)
		if (unset_var) {
			/* unset variable */
			struct tbl *vp;
			char *cp = NULL;
			size_t n;

			n = strlen(id);
			if (n > 3 && ord(id[n - 3]) == ORD('[') &&
			    ord(id[n - 2]) == ORD('*') &&
			    ord(id[n - 1]) == ORD(']')) {
				strndupx(cp, id, n - 3, ATEMP);
				id = cp;
				optc = 3;
			} else
				optc = vstrchr(id, '[') ? 0 : 1;

			vp = global(id);
			afree(cp, ATEMP);

			if ((vp->flag&RDONLY)) {
				warningf(true, Tf_ro, vp->name);
				rv = 1;
			} else
				unset(vp, optc);
		} else
			/* unset function */
			define(id, NULL);
	return (rv);
}

static void
p_time(struct shf *shf, bool posix, long tv_sec, int tv_usec, int width,
    const char *prefix, const char *suffix)
{
	tv_usec /= 10000;
	if (posix)
		shf_fprintf(shf, "%s%*ld.%02d%s", prefix, width,
		    tv_sec, tv_usec, suffix);
	else
		shf_fprintf(shf, "%s%*ldm%02d.%02ds%s", prefix, width,
		    tv_sec / 60, (int)(tv_sec % 60), tv_usec, suffix);
}

int
c_times(const char **wp MKSH_A_UNUSED)
{
	struct rusage usage;

	getrusage(RUSAGE_SELF, &usage);
	p_time(shl_stdout, false, usage.ru_utime.tv_sec,
	    usage.ru_utime.tv_usec, 0, null, T1space);
	p_time(shl_stdout, false, usage.ru_stime.tv_sec,
	    usage.ru_stime.tv_usec, 0, null, "\n");

	getrusage(RUSAGE_CHILDREN, &usage);
	p_time(shl_stdout, false, usage.ru_utime.tv_sec,
	    usage.ru_utime.tv_usec, 0, null, T1space);
	p_time(shl_stdout, false, usage.ru_stime.tv_sec,
	    usage.ru_stime.tv_usec, 0, null, "\n");

	return (0);
}

/*
 * time pipeline (really a statement, not a built-in command)
 */
int
timex(struct op *t, int f, volatile int *xerrok)
{
#define TF_NOARGS	BIT(0)
#define TF_NOREAL	BIT(1)		/* don't report real time */
#define TF_POSIX	BIT(2)		/* report in POSIX format */
	int rv = 0, tf = 0;
	struct rusage ru0, ru1, cru0, cru1;
	struct timeval usrtime, systime, tv0, tv1;

	mksh_TIME(tv0);
	getrusage(RUSAGE_SELF, &ru0);
	getrusage(RUSAGE_CHILDREN, &cru0);
	if (t->left) {
		/*
		 * Two ways of getting cpu usage of a command: just use t0
		 * and t1 (which will get cpu usage from other jobs that
		 * finish while we are executing t->left), or get the
		 * cpu usage of t->left. AT&T ksh does the former, while
		 * pdksh tries to do the later (the j_usrtime hack doesn't
		 * really work as it only counts the last job).
		 */
		timerclear(&j_usrtime);
		timerclear(&j_systime);
		rv = execute(t->left, f | XTIME, xerrok);
		if (t->left->type == TCOM)
			tf |= t->left->str[0];
		mksh_TIME(tv1);
		getrusage(RUSAGE_SELF, &ru1);
		getrusage(RUSAGE_CHILDREN, &cru1);
	} else
		tf = TF_NOARGS;

	if (tf & TF_NOARGS) {
		/* ksh93 - report shell times (shell+kids) */
		tf |= TF_NOREAL;
		timeradd(&ru0.ru_utime, &cru0.ru_utime, &usrtime);
		timeradd(&ru0.ru_stime, &cru0.ru_stime, &systime);
	} else {
		timersub(&ru1.ru_utime, &ru0.ru_utime, &usrtime);
		timeradd(&usrtime, &j_usrtime, &usrtime);
		timersub(&ru1.ru_stime, &ru0.ru_stime, &systime);
		timeradd(&systime, &j_systime, &systime);
	}

	if (!(tf & TF_NOREAL)) {
		timersub(&tv1, &tv0, &tv1);
		if (tf & TF_POSIX)
			p_time(shl_out, true, tv1.tv_sec, tv1.tv_usec,
			    5, Treal_sp1, "\n");
		else
			p_time(shl_out, false, tv1.tv_sec, tv1.tv_usec,
			    5, null, Treal_sp2);
	}
	if (tf & TF_POSIX)
		p_time(shl_out, true, usrtime.tv_sec, usrtime.tv_usec,
		    5, Tuser_sp1, "\n");
	else
		p_time(shl_out, false, usrtime.tv_sec, usrtime.tv_usec,
		    5, null, Tuser_sp2);
	if (tf & TF_POSIX)
		p_time(shl_out, true, systime.tv_sec, systime.tv_usec,
		    5, "sys  ", "\n");
	else
		p_time(shl_out, false, systime.tv_sec, systime.tv_usec,
		    5, null, " system\n");
	shf_flush(shl_out);

	return (rv);
}

void
timex_hook(struct op *t, char **volatile *app)
{
	char **wp = *app;
	int optc, i, j;
	Getopt opt;

	ksh_getopt_reset(&opt, 0);
	/* start at the start */
	opt.optind = 0;
	while ((optc = ksh_getopt((const char **)wp, &opt, ":p")) != -1)
		switch (optc) {
		case 'p':
			t->str[0] |= TF_POSIX;
			break;
		case '?':
			errorf(Tf_optfoo, Ttime, Tcolsp,
			    opt.optarg[0], Tunknown_option);
		case ':':
			errorf(Tf_optfoo, Ttime, Tcolsp,
			    opt.optarg[0], Treq_arg);
		}
	/* Copy command words down over options. */
	if (opt.optind != 0) {
		for (i = 0; i < opt.optind; i++)
			afree(wp[i], ATEMP);
		for (i = 0, j = opt.optind; (wp[i] = wp[j]); i++, j++)
			;
	}
	if (!wp[0])
		t->str[0] |= TF_NOARGS;
	*app = wp;
}

/* exec with no args - args case is taken care of in comexec() */
int
c_exec(const char **wp MKSH_A_UNUSED)
{
	int i;

	/* make sure redirects stay in place */
	if (e->savefd != NULL) {
		for (i = 0; i < NUFILE; i++) {
			if (e->savefd[i] > 0)
				close(e->savefd[i]);
			/*
			 * keep all file descriptors > 2 private for ksh,
			 * but not for POSIX or legacy/kludge sh
			 */
			if (!Flag(FPOSIX) && !Flag(FSH) && i > 2 &&
			    e->savefd[i])
				fcntl(i, F_SETFD, FD_CLOEXEC);
		}
		e->savefd = NULL;
	}
	return (0);
}

#if HAVE_MKNOD && !defined(__OS2__)
int
c_mknod(const char **wp)
{
	int argc, optc, rv = 0;
	bool ismkfifo = false;
	const char **argv;
	void *set = NULL;
	mode_t mode = 0, oldmode = 0;

	while ((optc = ksh_getopt(wp, &builtin_opt, "m:")) != -1) {
		switch (optc) {
		case 'm':
			set = setmode(builtin_opt.optarg);
			if (set == NULL) {
				bi_errorf("invalid file mode");
				return (1);
			}
			mode = getmode(set, (mode_t)(DEFFILEMODE));
			free_ossetmode(set);
			break;
		default:
			goto c_mknod_usage;
		}
	}
	argv = &wp[builtin_opt.optind];
	if (argv[0] == NULL)
		goto c_mknod_usage;
	for (argc = 0; argv[argc]; argc++)
		;
	if (argc == 2 && argv[1][0] == 'p')
		ismkfifo = true;
	else if (argc != 4 || (argv[1][0] != 'b' && argv[1][0] != 'c'))
		goto c_mknod_usage;

	if (set != NULL)
		oldmode = umask((mode_t)0);
	else
		mode = DEFFILEMODE;

	mode |= (argv[1][0] == 'b') ? S_IFBLK :
	    (argv[1][0] == 'c') ? S_IFCHR : 0;

	if (!ismkfifo) {
		unsigned long majnum, minnum;
		dev_t dv;
		char *c;

		majnum = strtoul(argv[2], &c, 0);
		if ((c == argv[2]) || (*c != '\0')) {
			bi_errorf(Tf_nonnum, "device", "major", argv[2]);
			goto c_mknod_err;
		}
		minnum = strtoul(argv[3], &c, 0);
		if ((c == argv[3]) || (*c != '\0')) {
			bi_errorf(Tf_nonnum, "device", "minor", argv[3]);
			goto c_mknod_err;
		}
		dv = makedev(majnum, minnum);
		if ((unsigned long)(major(dv)) != majnum) {
			bi_errorf(Tf_toolarge, "device", "major", majnum);
			goto c_mknod_err;
		}
		if ((unsigned long)(minor(dv)) != minnum) {
			bi_errorf(Tf_toolarge, "device", "minor", minnum);
			goto c_mknod_err;
		}
		if (mknod(argv[0], mode, dv))
			goto c_mknod_failed;
	} else if (mkfifo(argv[0], mode)) {
 c_mknod_failed:
		bi_errorf(Tf_sD_s, argv[0], cstrerror(errno));
 c_mknod_err:
		rv = 1;
	}

	if (set)
		umask(oldmode);
	return (rv);
 c_mknod_usage:
	bi_errorf("usage: mknod [-m mode] name %s", "b|c major minor");
	bi_errorf("usage: mknod [-m mode] name %s", "p");
	return (1);
}
#endif

/*-
   test(1) roughly accepts the following grammar:
	oexpr	::= aexpr | aexpr "-o" oexpr ;
	aexpr	::= nexpr | nexpr "-a" aexpr ;
	nexpr	::= primary | "!" nexpr ;
	primary	::= unary-operator operand
		| operand binary-operator operand
		| operand
		| "(" oexpr ")"
		;

	unary-operator ::= "-a"|"-b"|"-c"|"-d"|"-e"|"-f"|"-G"|"-g"|"-H"|"-h"|
			   "-k"|"-L"|"-n"|"-O"|"-o"|"-p"|"-r"|"-S"|"-s"|"-t"|
			   "-u"|"-v"|"-w"|"-x"|"-z";

	binary-operator ::= "="|"=="|"!="|"<"|">"|"-eq"|"-ne"|"-gt"|"-ge"|
			    "-lt"|"-le"|"-ef"|"-nt"|"-ot";

	operand ::= <anything>
*/

/* POSIX says > 1 for errors */
#define T_ERR_EXIT 2

int
c_test(const char **wp)
{
	int argc, rv, invert = 0;
	Test_env te;
	Test_op op;
	Test_meta tm;
	const char *lhs, **swp;

	te.flags = 0;
	te.isa = ptest_isa;
	te.getopnd = ptest_getopnd;
	te.eval = test_eval;
	te.error = ptest_error;

	for (argc = 0; wp[argc]; argc++)
		;

	if (strcmp(wp[0], Tbracket) == 0) {
		if (strcmp(wp[--argc], "]") != 0) {
			bi_errorf("missing ]");
			return (T_ERR_EXIT);
		}
	}

	te.pos.wp = wp + 1;
	te.wp_end = wp + argc;

	/*
	 * Attempt to conform to POSIX special cases. This is pretty
	 * dumb code straight-forward from the 2008 spec, but unlike
	 * the old pdksh code doesn't live from so many assumptions.
	 * It does, though, inline some calls to '(*te.funcname)()'.
	 */
	switch (argc - 1) {
	case 0:
		return (1);
	case 1:
 ptest_one:
		op = TO_STNZE;
		goto ptest_unary;
	case 2:
 ptest_two:
		if (ptest_isa(&te, TM_NOT)) {
			++invert;
			goto ptest_one;
		}
		if ((op = ptest_isa(&te, TM_UNOP))) {
 ptest_unary:
			rv = test_eval(&te, op, *te.pos.wp++, NULL, true);
 ptest_out:
			if (te.flags & TEF_ERROR)
				return (T_ERR_EXIT);
			return ((invert & 1) ? rv : !rv);
		}
		/* let the parser deal with anything else */
		break;
	case 3:
 ptest_three:
		swp = te.pos.wp;
		/* use inside knowledge of ptest_getopnd inlined below */
		lhs = *te.pos.wp++;
		if ((op = ptest_isa(&te, TM_BINOP))) {
			/* test lhs op rhs */
			rv = test_eval(&te, op, lhs, *te.pos.wp++, true);
			goto ptest_out;
		}
		if (ptest_isa(&te, tm = TM_AND) || ptest_isa(&te, tm = TM_OR)) {
			/* XSI */
			argc = test_eval(&te, TO_STNZE, lhs, NULL, true);
			rv = test_eval(&te, TO_STNZE, *te.pos.wp++, NULL, true);
			if (tm == TM_AND)
				rv = argc && rv;
			else
				rv = argc || rv;
			goto ptest_out;
		}
		/* back up to lhs */
		te.pos.wp = swp;
		if (ptest_isa(&te, TM_NOT)) {
			++invert;
			goto ptest_two;
		}
		if (ptest_isa(&te, TM_OPAREN)) {
			swp = te.pos.wp;
			/* skip operand, without evaluation */
			te.pos.wp++;
			/* check for closing parenthesis */
			op = ptest_isa(&te, TM_CPAREN);
			/* back up to operand */
			te.pos.wp = swp;
			/* if there was a closing paren, handle it */
			if (op)
				goto ptest_one;
			/* backing up is done before calling the parser */
		}
		/* let the parser deal with it */
		break;
	case 4:
		if (ptest_isa(&te, TM_NOT)) {
			++invert;
			goto ptest_three;
		}
		if (ptest_isa(&te, TM_OPAREN)) {
			swp = te.pos.wp;
			/* skip two operands, without evaluation */
			te.pos.wp++;
			te.pos.wp++;
			/* check for closing parenthesis */
			op = ptest_isa(&te, TM_CPAREN);
			/* back up to first operand */
			te.pos.wp = swp;
			/* if there was a closing paren, handle it */
			if (op)
				goto ptest_two;
			/* backing up is done before calling the parser */
		}
		/* defer this to the parser */
		break;
	}

	/* "The results are unspecified." */
	te.pos.wp = wp + 1;
	return (test_parse(&te));
}

/*
 * Generic test routines.
 */

Test_op
test_isop(Test_meta meta, const char *s)
{
	char sc1;
	const struct t_op *tbl;

	tbl = meta == TM_UNOP ? u_ops : b_ops;
	if (*s) {
		sc1 = s[1];
		for (; tbl->op_text[0]; tbl++)
			if (sc1 == tbl->op_text[1] && !strcmp(s, tbl->op_text))
				return (tbl->op_num);
	}
	return (TO_NONOP);
}

#ifdef __OS2__
#define test_access(name, mode) access_ex(access, (name), (mode))
#define test_stat(name, buffer) stat_ex((name), (buffer))
#else
#define test_access(name, mode) access((name), (mode))
#define test_stat(name, buffer) stat((name), (buffer))
#endif

int
test_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    bool do_eval)
{
	int i, s;
	size_t k;
	struct stat b1, b2;
	mksh_ari_t v1, v2;
	struct tbl *vp;

	if (!do_eval)
		return (0);

#ifdef DEBUG
	switch (op) {
	/* Binary operators */
	case TO_STEQL:
	case TO_STNEQ:
	case TO_STLT:
	case TO_STGT:
	case TO_INTEQ:
	case TO_INTNE:
	case TO_INTGT:
	case TO_INTGE:
	case TO_INTLT:
	case TO_INTLE:
	case TO_FILEQ:
	case TO_FILNT:
	case TO_FILOT:
		/* consistency check, but does not happen in practice */
		if (!opnd2) {
			te->flags |= TEF_ERROR;
			return (1);
		}
		break;
	default:
		/* for completeness of switch */
		break;
	}
#endif

	switch (op) {

	/*
	 * Unary Operators
	 */

	/* -n */
	case TO_STNZE:
		return (*opnd1 != '\0');

	/* -z */
	case TO_STZER:
		return (*opnd1 == '\0');

	/* -v */
	case TO_ISSET:
		return ((vp = isglobal(opnd1, false)) && (vp->flag & ISSET));

	/* -o */
	case TO_OPTION:
		if ((i = *opnd1) == '!' || i == '?')
			opnd1++;
		if ((k = option(opnd1)) == (size_t)-1)
			return (0);
		return (i == '?' ? 1 : i == '!' ? !Flag(k) : Flag(k));

	/* -r */
	case TO_FILRD:
		/* LINTED use of access */
		return (test_access(opnd1, R_OK) == 0);

	/* -w */
	case TO_FILWR:
		/* LINTED use of access */
		return (test_access(opnd1, W_OK) == 0);

	/* -x */
	case TO_FILEX:
		return (ksh_access(opnd1, X_OK) == 0);

	/* -a */
	case TO_FILAXST:
	/* -e */
	case TO_FILEXST:
		return (test_stat(opnd1, &b1) == 0);

	/* -f */
	case TO_FILREG:
		return (test_stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode));

	/* -d */
	case TO_FILID:
		return (stat(opnd1, &b1) == 0 && S_ISDIR(b1.st_mode));

	/* -c */
	case TO_FILCDEV:
		return (stat(opnd1, &b1) == 0 && S_ISCHR(b1.st_mode));

	/* -b */
	case TO_FILBDEV:
		return (stat(opnd1, &b1) == 0 && S_ISBLK(b1.st_mode));

	/* -p */
	case TO_FILFIFO:
		return (stat(opnd1, &b1) == 0 && S_ISFIFO(b1.st_mode));

	/* -h or -L */
	case TO_FILSYM:
#ifdef MKSH__NO_SYMLINK
		return (0);
#else
		return (lstat(opnd1, &b1) == 0 && S_ISLNK(b1.st_mode));
#endif

	/* -S */
	case TO_FILSOCK:
		return (stat(opnd1, &b1) == 0 && S_ISSOCK(b1.st_mode));

	/* -H => HP context dependent files (directories) */
	case TO_FILCDF:
#ifdef S_ISCDF
	{
		char *nv;

		/*
		 * Append a + to filename and check to see if result is
		 * a setuid directory. CDF stuff in general is hookey,
		 * since it breaks for, e.g., the following sequence:
		 * echo hi >foo+; mkdir foo; echo bye >foo/default;
		 * chmod u+s foo (foo+ refers to the file with hi in it,
		 * there is no way to get at the file with bye in it;
		 * please correct me if I'm wrong about this).
		 */

		nv = shf_smprintf("%s+", opnd1);
		i = (stat(nv, &b1) == 0 && S_ISCDF(b1.st_mode));
		afree(nv, ATEMP);
		return (i);
	}
#else
		return (0);
#endif

	/* -u */
	case TO_FILSETU:
		return (stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISUID) == S_ISUID);

	/* -g */
	case TO_FILSETG:
		return (stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISGID) == S_ISGID);

	/* -k */
	case TO_FILSTCK:
#ifdef S_ISVTX
		return (stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISVTX) == S_ISVTX);
#else
		return (0);
#endif

	/* -s */
	case TO_FILGZ:
		return (stat(opnd1, &b1) == 0 && (off_t)b1.st_size > (off_t)0);

	/* -t */
	case TO_FILTT:
		if (opnd1 && !bi_getn(opnd1, &i)) {
			te->flags |= TEF_ERROR;
			i = 0;
		} else
			i = isatty(opnd1 ? i : 0);
		return (i);

	/* -O */
	case TO_FILUID:
		return (stat(opnd1, &b1) == 0 && (uid_t)b1.st_uid == ksheuid);

	/* -G */
	case TO_FILGID:
		return (stat(opnd1, &b1) == 0 && (gid_t)b1.st_gid == getegid());

	/*
	 * Binary Operators
	 */

	/* =, == */
	case TO_STEQL:
		if (te->flags & TEF_DBRACKET) {
			if ((i = gmatchx(opnd1, opnd2, false)))
				record_match(opnd1);
			return (i);
		}
		return (strcmp(opnd1, opnd2) == 0);

	/* != */
	case TO_STNEQ:
		if (te->flags & TEF_DBRACKET) {
			if ((i = gmatchx(opnd1, opnd2, false)))
				record_match(opnd1);
			return (!i);
		}
		return (strcmp(opnd1, opnd2) != 0);

	/* < */
	case TO_STLT:
		return (strcmp(opnd1, opnd2) < 0);

	/* > */
	case TO_STGT:
		return (strcmp(opnd1, opnd2) > 0);

	/* -nt */
	case TO_FILNT:
		/*
		 * ksh88/ksh93 succeed if file2 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return (stat(opnd1, &b1) == 0 &&
		    (((s = stat(opnd2, &b2)) == 0 &&
		    b1.st_mtime > b2.st_mtime) || s < 0));

	/* -ot */
	case TO_FILOT:
		/*
		 * ksh88/ksh93 succeed if file1 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return (stat(opnd2, &b2) == 0 &&
		    (((s = stat(opnd1, &b1)) == 0 &&
		    b1.st_mtime < b2.st_mtime) || s < 0));

	/* -ef */
	case TO_FILEQ:
		return (stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0 &&
		    b1.st_dev == b2.st_dev && b1.st_ino == b2.st_ino);

	/* all other cases */
	case TO_NONOP:
	case TO_NONNULL:
		/* throw the error */
		break;

	/* -eq */
	case TO_INTEQ:
	/* -ne */
	case TO_INTNE:
	/* -ge */
	case TO_INTGE:
	/* -gt */
	case TO_INTGT:
	/* -le */
	case TO_INTLE:
	/* -lt */
	case TO_INTLT:
		if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false) ||
		    !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false)) {
			/* error already printed.. */
			te->flags |= TEF_ERROR;
			return (1);
		}
		switch (op) {
		case TO_INTEQ:
			return (v1 == v2);
		case TO_INTNE:
			return (v1 != v2);
		case TO_INTGE:
			return (v1 >= v2);
		case TO_INTGT:
			return (v1 > v2);
		case TO_INTLE:
			return (v1 <= v2);
		case TO_INTLT:
			return (v1 < v2);
		default:
			/* NOTREACHED */
			break;
		}
		/* NOTREACHED */
	}
	(*te->error)(te, 0, "internal error: unknown op");
	return (1);
}

int
test_parse(Test_env *te)
{
	int rv;

	rv = test_oexpr(te, 1);

	if (!(te->flags & TEF_ERROR) && !(*te->isa)(te, TM_END))
		(*te->error)(te, 0, "unexpected operator/operand");

	return ((te->flags & TEF_ERROR) ? T_ERR_EXIT : !rv);
}

static int
test_oexpr(Test_env *te, bool do_eval)
{
	int rv;

	if ((rv = test_aexpr(te, do_eval)))
		do_eval = false;
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_OR))
		return (test_oexpr(te, do_eval) || rv);
	return (rv);
}

static int
test_aexpr(Test_env *te, bool do_eval)
{
	int rv;

	if (!(rv = test_nexpr(te, do_eval)))
		do_eval = false;
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_AND))
		return (test_aexpr(te, do_eval) && rv);
	return (rv);
}

static int
test_nexpr(Test_env *te, bool do_eval)
{
	if (!(te->flags & TEF_ERROR) && (*te->isa)(te, TM_NOT))
		return (!test_nexpr(te, do_eval));
	return (test_primary(te, do_eval));
}

static int
test_primary(Test_env *te, bool do_eval)
{
	const char *opnd1, *opnd2;
	int rv;
	Test_op op;

	if (te->flags & TEF_ERROR)
		return (0);
	if ((*te->isa)(te, TM_OPAREN)) {
		rv = test_oexpr(te, do_eval);
		if (te->flags & TEF_ERROR)
			return (0);
		if (!(*te->isa)(te, TM_CPAREN)) {
			(*te->error)(te, 0, "missing )");
			return (0);
		}
		return (rv);
	}
	/*
	 * Binary should have precedence over unary in this case
	 * so that something like test \( -f = -f \) is accepted
	 */
	if ((te->flags & TEF_DBRACKET) || (&te->pos.wp[1] < te->wp_end &&
	    !test_isop(TM_BINOP, te->pos.wp[1]))) {
		if ((op = (*te->isa)(te, TM_UNOP))) {
			/* unary expression */
			opnd1 = (*te->getopnd)(te, op, do_eval);
			if (!opnd1) {
				(*te->error)(te, -1, Tno_args);
				return (0);
			}

			return ((*te->eval)(te, op, opnd1, NULL, do_eval));
		}
	}
	opnd1 = (*te->getopnd)(te, TO_NONOP, do_eval);
	if (!opnd1) {
		(*te->error)(te, 0, "expression expected");
		return (0);
	}
	if ((op = (*te->isa)(te, TM_BINOP))) {
		/* binary expression */
		opnd2 = (*te->getopnd)(te, op, do_eval);
		if (!opnd2) {
			(*te->error)(te, -1, "missing second argument");
			return (0);
		}

		return ((*te->eval)(te, op, opnd1, opnd2, do_eval));
	}
	return ((*te->eval)(te, TO_STNZE, opnd1, NULL, do_eval));
}

/*
 * Plain test (test and [ .. ]) specific routines.
 */

/*
 * Test if the current token is a whatever. Accepts the current token if
 * it is. Returns 0 if it is not, non-zero if it is (in the case of
 * TM_UNOP and TM_BINOP, the returned value is a Test_op).
 */
static Test_op
ptest_isa(Test_env *te, Test_meta meta)
{
	/* Order important - indexed by Test_meta values */
	static const char * const tokens[] = {
		"-o", "-a", "!", "(", ")"
	};
	Test_op rv;

	if (te->pos.wp >= te->wp_end)
		return (meta == TM_END ? TO_NONNULL : TO_NONOP);

	if (meta == TM_UNOP || meta == TM_BINOP)
		rv = test_isop(meta, *te->pos.wp);
	else if (meta == TM_END)
		rv = TO_NONOP;
	else
		rv = !strcmp(*te->pos.wp, tokens[(int)meta]) ?
		    TO_NONNULL : TO_NONOP;

	/* Accept the token? */
	if (rv != TO_NONOP)
		te->pos.wp++;

	return (rv);
}

static const char *
ptest_getopnd(Test_env *te, Test_op op, bool do_eval MKSH_A_UNUSED)
{
	if (te->pos.wp >= te->wp_end)
		return (op == TO_FILTT ? "1" : NULL);
	return (*te->pos.wp++);
}

static void
ptest_error(Test_env *te, int ofs, const char *msg)
{
	const char *op;

	te->flags |= TEF_ERROR;
	if ((op = te->pos.wp + ofs >= te->wp_end ? NULL : te->pos.wp[ofs]))
		bi_errorf(Tf_sD_s, op, msg);
	else
		bi_errorf(Tf_s, msg);
}

#ifndef MKSH_NO_LIMITS
#define SOFT	0x1
#define HARD	0x2

/* Magic to divine the 'm' and 'v' limits */

#ifdef RLIMIT_AS
#if !defined(RLIMIT_VMEM) || (RLIMIT_VMEM == RLIMIT_AS) || \
    !defined(RLIMIT_RSS) || (RLIMIT_VMEM == RLIMIT_RSS)
#define ULIMIT_V_IS_AS
#elif defined(RLIMIT_VMEM)
#if !defined(RLIMIT_RSS) || (RLIMIT_RSS == RLIMIT_AS)
#define ULIMIT_V_IS_AS
#else
#define ULIMIT_V_IS_VMEM
#endif
#endif
#endif

#ifdef RLIMIT_RSS
#ifdef ULIMIT_V_IS_VMEM
#define ULIMIT_M_IS_RSS
#elif defined(RLIMIT_VMEM) && (RLIMIT_VMEM == RLIMIT_RSS)
#define ULIMIT_M_IS_VMEM
#else
#define ULIMIT_M_IS_RSS
#endif
#if defined(ULIMIT_M_IS_RSS) && defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)
#undef ULIMIT_M_IS_RSS
#endif
#endif

#if !defined(RLIMIT_AS) && !defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_VMEM)
#define ULIMIT_V_IS_VMEM
#endif

#if !defined(ULIMIT_V_IS_VMEM) && defined(RLIMIT_VMEM) && \
    (!defined(RLIMIT_RSS) || (defined(RLIMIT_AS) && (RLIMIT_RSS == RLIMIT_AS)))
#define ULIMIT_M_IS_VMEM
#endif

#if defined(ULIMIT_M_IS_VMEM) && defined(RLIMIT_AS) && \
    (RLIMIT_VMEM == RLIMIT_AS)
#undef ULIMIT_M_IS_VMEM
#endif

#if defined(ULIMIT_M_IS_RSS) && defined(ULIMIT_M_IS_VMEM)
# error nonsensical m ulimit
#endif

#if defined(ULIMIT_V_IS_VMEM) && defined(ULIMIT_V_IS_AS)
# error nonsensical v ulimit
#endif

struct limits {
	/* limit resource */
	int resource;
	/* multiply by to get rlim_{cur,max} values */
	unsigned int factor;
	/* getopts char */
	char optchar;
	/* limit name */
	char name[1];
};

#define RLIMITS_DEFNS
#define FN(lname,lid,lfac,lopt)				\
	static const struct {				\
		int resource;				\
		unsigned int factor;			\
		char optchar;				\
		char name[sizeof(lname)];		\
	} rlimits_ ## lid = {				\
		lid, lfac, lopt, lname			\
	};
#include "rlimits.gen"

static void print_ulimit(const struct limits *, int);
static int set_ulimit(const struct limits *, const char *, int);

static const struct limits * const rlimits[] = {
#define RLIMITS_ITEMS
#include "rlimits.gen"
};

static const char rlimits_opts[] =
#define RLIMITS_OPTCS
#include "rlimits.gen"
    ;

int
c_ulimit(const char **wp)
{
	size_t i = 0;
	int how = SOFT | HARD, optc, what = 'f';
	bool all = false;

	while ((optc = ksh_getopt(wp, &builtin_opt, rlimits_opts)) != -1)
		switch (optc) {
		case 'H':
			how = HARD;
			break;
		case 'S':
			how = SOFT;
			break;
		case 'a':
			all = true;
			break;
		case '?':
			bi_errorf("usage: ulimit [-%s] [value]", rlimits_opts);
			return (1);
		default:
			what = optc;
		}

	while (i < NELEM(rlimits)) {
		if (rlimits[i]->optchar == what)
			goto found;
		++i;
	}
	internal_warningf("ulimit: %c", what);
	return (1);
 found:
	if (wp[builtin_opt.optind]) {
		if (all || wp[builtin_opt.optind + 1]) {
			bi_errorf(Ttoo_many_args);
			return (1);
		}
		return (set_ulimit(rlimits[i], wp[builtin_opt.optind], how));
	}
	if (!all)
		print_ulimit(rlimits[i], how);
	else for (i = 0; i < NELEM(rlimits); ++i) {
		shprintf("-%c: %-20s  ", rlimits[i]->optchar, rlimits[i]->name);
		print_ulimit(rlimits[i], how);
	}
	return (0);
}

static int
set_ulimit(const struct limits *l, const char *v, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (strcmp(v, "unlimited") == 0)
		val = (rlim_t)RLIM_INFINITY;
	else {
		mksh_uari_t rval;

		if (!evaluate(v, (mksh_ari_t *)&rval, KSH_RETURN_ERROR, false))
			return (1);
		/*
		 * Avoid problems caused by typos that evaluate misses due
		 * to evaluating unset parameters to 0...
		 * If this causes problems, will have to add parameter to
		 * evaluate() to control if unset params are 0 or an error.
		 */
		if (!rval && !ctype(v[0], C_DIGIT)) {
			bi_errorf("invalid %s limit: %s", l->name, v);
			return (1);
		}
		val = (rlim_t)((rlim_t)rval * l->factor);
	}

	if (getrlimit(l->resource, &limit) < 0) {
#ifndef MKSH_SMALL
		bi_errorf("limit %s could not be read, contact the mksh developers: %s",
		    l->name, cstrerror(errno));
#endif
		/* some can't be read */
		limit.rlim_cur = RLIM_INFINITY;
		limit.rlim_max = RLIM_INFINITY;
	}
	if (how & SOFT)
		limit.rlim_cur = val;
	if (how & HARD)
		limit.rlim_max = val;
	if (!setrlimit(l->resource, &limit))
		return (0);
	if (errno == EPERM)
		bi_errorf("%s exceeds allowable %s limit", v, l->name);
	else
		bi_errorf("bad %s limit: %s", l->name, cstrerror(errno));
	return (1);
}

static void
print_ulimit(const struct limits *l, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (getrlimit(l->resource, &limit)) {
		shf_puts("unknown\n", shl_stdout);
		return;
	}
	if (how & SOFT)
		val = limit.rlim_cur;
	else if (how & HARD)
		val = limit.rlim_max;
	if (val == (rlim_t)RLIM_INFINITY)
		shf_puts("unlimited\n", shl_stdout);
	else
		shprintf("%lu\n", (unsigned long)(val / l->factor));
}
#endif

int
c_rename(const char **wp)
{
	int rv = 1;

	/* skip argv[0] */
	++wp;
	if (wp[0] && !strcmp(wp[0], "--"))
		/* skip "--" (options separator) */
		++wp;

	/* check for exactly two arguments */
	if (wp[0] == NULL	/* first argument */ ||
	    wp[1] == NULL	/* second argument */ ||
	    wp[2] != NULL	/* no further args please */)
		bi_errorf(Tsynerr);
	else if ((rv = rename(wp[0], wp[1])) != 0) {
		rv = errno;
		bi_errorf(Tf_sD_s, "failed", cstrerror(rv));
	}

	return (rv);
}

int
c_realpath(const char **wp)
{
	int rv = 1;
	char *buf;

	/* skip argv[0] */
	++wp;
	if (wp[0] && !strcmp(wp[0], "--"))
		/* skip "--" (options separator) */
		++wp;

	/* check for exactly one argument */
	if (wp[0] == NULL || wp[1] != NULL)
		bi_errorf(Tsynerr);
	else if ((buf = do_realpath(wp[0])) == NULL) {
		rv = errno;
		bi_errorf(Tf_sD_s, wp[0], cstrerror(rv));
		if ((unsigned int)rv > 255)
			rv = 255;
	} else {
		shprintf(Tf_sN, buf);
		afree(buf, ATEMP);
		rv = 0;
	}

	return (rv);
}

int
c_cat(const char **wp)
{
	int fd = STDIN_FILENO, rv;
	ssize_t n, w;
	const char *fn = "<stdin>";
	char *buf, *cp;
	bool opipe;
#define MKSH_CAT_BUFSIZ 4096

	/* parse options: POSIX demands we support "-u" as no-op */
	while ((rv = ksh_getopt(wp, &builtin_opt, "u")) != -1) {
		switch (rv) {
		case 'u':
			/* we already operate unbuffered */
			break;
		default:
			bi_errorf(Tsynerr);
			return (1);
		}
	}
	wp += builtin_opt.optind;
	rv = 0;

	if ((buf = malloc_osfunc(MKSH_CAT_BUFSIZ)) == NULL) {
		bi_errorf(Toomem, (size_t)MKSH_CAT_BUFSIZ);
		return (1);
	}

	/* catch SIGPIPE */
	opipe = block_pipe();

	do {
		if (*wp) {
			fn = *wp++;
			if (ksh_isdash(fn))
				fd = STDIN_FILENO;
			else if ((fd = binopen2(fn, O_RDONLY)) < 0) {
				bi_errorf(Tf_sD_s, fn, cstrerror(errno));
				rv = 1;
				continue;
			}
		}
		while (/* CONSTCOND */ 1) {
			if ((n = blocking_read(fd, (cp = buf),
			    MKSH_CAT_BUFSIZ)) == -1) {
				if (errno == EINTR) {
					if (opipe)
						restore_pipe();
					/* give the user a chance to ^C out */
					intrcheck();
					/* interrupted, try again */
					opipe = block_pipe();
					continue;
				}
				/* an error occured during reading */
				bi_errorf(Tf_sD_s, fn, cstrerror(errno));
				rv = 1;
				break;
			} else if (n == 0)
				/* end of file reached */
				break;
			while (n) {
				if (intrsig)
					goto has_intrsig;
				if ((w = write(STDOUT_FILENO, cp, n)) != -1) {
					n -= w;
					cp += w;
					continue;
				}
				if (errno == EINTR) {
 has_intrsig:
					if (opipe)
						restore_pipe();
					/* give the user a chance to ^C out */
					intrcheck();
					/* interrupted, try again */
					opipe = block_pipe();
					continue;
				}
				if (errno == EPIPE) {
					/* fake receiving signal */
					rv = ksh_sigmask(SIGPIPE);
				} else {
					/* an error occured during writing */
					bi_errorf(Tf_sD_s, "<stdout>",
					    cstrerror(errno));
					rv = 1;
				}
				if (fd != STDIN_FILENO)
					close(fd);
				goto out;
			}
		}
		if (fd != STDIN_FILENO)
			close(fd);
	} while (*wp);

 out:
	if (opipe)
		restore_pipe();
	free_osfunc(buf);
	return (rv);
}

#if HAVE_SELECT
int
c_sleep(const char **wp)
{
	struct timeval tv;
	int rv = 1;

	/* skip argv[0] */
	++wp;
	if (wp[0] && !strcmp(wp[0], "--"))
		/* skip "--" (options separator) */
		++wp;

	if (!wp[0] || wp[1])
		bi_errorf(Tsynerr);
	else if (parse_usec(wp[0], &tv))
		bi_errorf(Tf_sD_s_qs, Tsynerr, cstrerror(errno), wp[0]);
	else {
#ifndef MKSH_NOPROSPECTOFWORK
		sigset_t omask, bmask;

		/* block a number of signals from interrupting us, though */
		(void)sigemptyset(&bmask);
		(void)sigaddset(&bmask, SIGPIPE);
		(void)sigaddset(&bmask, SIGCHLD);
#ifdef SIGWINCH
		(void)sigaddset(&bmask, SIGWINCH);
#endif
#ifdef SIGINFO
		(void)sigaddset(&bmask, SIGINFO);
#endif
#ifdef SIGUSR1
		(void)sigaddset(&bmask, SIGUSR1);
#endif
#ifdef SIGUSR2
		(void)sigaddset(&bmask, SIGUSR2);
#endif
		sigprocmask(SIG_BLOCK, &bmask, &omask);
#endif
		if (select(1, NULL, NULL, NULL, &tv) == 0 || errno == EINTR)
			/*
			 * strictly speaking only for SIGALRM, but the
			 * execution may be interrupted by other signals
			 */
			rv = 0;
		else
			bi_errorf(Tf_sD_s, Tselect, cstrerror(errno));
#ifndef MKSH_NOPROSPECTOFWORK
		/* this will re-schedule signal delivery */
		sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
	}
	return (rv);
}
#endif

#if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
static int
c_suspend(const char **wp)
{
	if (wp[1] != NULL) {
		bi_errorf(Ttoo_many_args);
		return (1);
	}
	if (Flag(FLOGIN)) {
		/* Can't suspend an orphaned process group. */
		if (getpgid(kshppid) == getpgid(0) ||
		    getsid(kshppid) != getsid(0)) {
			bi_errorf("can't suspend a login shell");
			return (1);
		}
	}
	j_suspend();
	return (0);
}
#endif
@


1.359
log
@scared of this change but it passes tests: g/c some more
@
text
@a2076 1
	Flag(FEVALERR) = 1;
a2077 1
	Flag(FEVALERR) = 0;
@


1.358
log
@introduce FEVALERR to replace (FERREXIT & 0x80)

fixes “set -e appears active within eval but isn’t”
reported by Martijn Dekker
@
text
@a2034 1
	unsigned char savef;
a2076 1
	savef = Flag(FERREXIT);
a2078 1
	Flag(FERREXIT) = savef;
@


1.357
log
@fix regression found by, again, Martijn Dekker; tricky…

GCC fails to optimise (ptr1 == ptr2) * (tp->flag & FOO), so don’t do it
@
text
@d42 1
a42 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.353 2018/01/14 01:26:49 tg Exp $");
d2079 1
a2079 1
	Flag(FERREXIT) |= 0x80;
d2082 1
@


1.356
log
@fix one of the issues
@
text
@d133 2
a134 2
	{Tsgset, c_set},
	{"*=shift", c_shift},
a1350 1
	struct block *l;
d1354 8
a1380 4
	if (((l = e->loc)->flags & BF_RESETSPEC))
		/* operate on parent environment */
		l = l->next;

d2242 8
a2259 1
		struct block *l;
a2261 4
		if (((l = e->loc)->flags & BF_RESETSPEC))
			/* operate on parent environment */
			l = l->next;

@


1.355
log
@move a largish block of code around to trick a GCC warning

(the fallthrough detection is thrown off by the other comments,
and it doesn’t recognise NOTREACHED anyway…)
@
text
@d8 2
a9 1
 *		 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017
d1351 1
a1351 1
	struct block *l = e->loc;
d1373 5
a2238 2
	struct block *l = e->loc;
	const char **owp;
d2249 7
@


1.354
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@d2967 31
a3033 31

	/* -nt */
	case TO_FILNT:
		/*
		 * ksh88/ksh93 succeed if file2 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return (stat(opnd1, &b1) == 0 &&
		    (((s = stat(opnd2, &b2)) == 0 &&
		    b1.st_mtime > b2.st_mtime) || s < 0));

	/* -ot */
	case TO_FILOT:
		/*
		 * ksh88/ksh93 succeed if file1 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return (stat(opnd2, &b2) == 0 &&
		    (((s = stat(opnd1, &b1)) == 0 &&
		    b1.st_mtime < b2.st_mtime) || s < 0));

	/* -ef */
	case TO_FILEQ:
		return (stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0 &&
		    b1.st_dev == b2.st_dev && b1.st_ino == b2.st_ino);

	/* all other cases */
	case TO_NONOP:
	case TO_NONNULL:
		/* throw the error */
		break;
@


1.353
log
@this callback also needs to cast cleanly
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.352 2018/01/13 23:55:11 tg Exp $");
d496 1
a496 1
					/* generic function returned Unicode */
@


1.352
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.346 2017/04/27 23:18:05 tg Exp $");
d591 1
a591 1
	return (*s_ptr++);
@


1.351
log
@fix typo in comment
@
text
@d748 1
a748 1
	if (ord(*cp) == ord('-'))
d750 1
a750 1
	if (ord(cp[0]) == ord('[') && ord(cp[1]) == ord('[') && !cp[2])
d2301 3
a2303 3
			if (n > 3 && ord(id[n - 3]) == ord('[') &&
			    ord(id[n - 2]) == ord('*') &&
			    ord(id[n - 1]) == ord(']')) {
@


1.350
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d3536 1
a3536 1
					/* fake receiving signel */
@


1.349
log
@const
@
text
@d2301 3
a2303 2
			if (n > 3 && id[n-3] == '[' && id[n-2] == '*' &&
			    id[n-1] == ']') {
@


1.348
log
@commit the optimisation result from the new fast character classes
@
text
@d1586 1
a1586 1
static char REPLY[] = "REPLY";
@


1.347
log
@allow : and [ in alias names (but forbid [[ explicitly)
to make 'enable' completely work again
@
text
@d810 1
a810 1
	    (wp[0][0] == '-' || wp[0][0] == '+') && wp[0][1] == '\0') {
@


1.346
log
@refactor
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.339 2017/04/12 17:38:44 tg Exp $");
d750 2
@


1.345
log
@fixup the remaining issues and last optimisations
@
text
@d748 2
d857 1
a857 1
		if (chkalias && (!valid_alias_name(alias) || *alias == '-')) {
@


1.344
log
@batch of optimisations
@
text
@d1459 1
a1459 1
				if (!vstrchr("=+-", op = *cp))
d1500 1
a1500 1
				} else if (!vstrchr("=+-", *cp))
@


1.343
log
@eliminate legacy macros
@
text
@d749 3
a751 1
		if (!ctype(*cp, C_ALIAS))
a752 2
		else
			++cp;
d1070 1
a1070 2
	if ((p = wp[1]) && *p == '-' && (ctype(p[1], C_DIGIT) ||
	    ctype(p[1], C_UPPER))) {
d1421 1
a1421 1
			while (asc(*cp) >= asc('0') && asc(*cp) <= asc('7')) {
@


1.342
log
@make ord() result unsigned int; add asc() which is:

• not designed to be emitted, only used in comparisons with
  other asc() results
• on EBCDIC platforms, the mapping of an EBCDIC octet to their
  corresponding ASCII or Unicode/UCS-4 codepoint or, if there
  is no mapping, a distinct value above all valid Unicode codepoints
• on nōn-EBCDIC platforms, just the identity mapping of the input
  octet into their ord() value

Intended use are ASCII-ish character ops, including ranges (“A-Z”),
mapping from those to the corresponding digit offset, and sorting
of things in an ASCIIbetical way
@
text
@d749 1
a749 1
		if (!ksh_isalias(*cp))
d1070 2
a1071 2
	if ((p = wp[1]) && *p == '-' && (ksh_isdigit(p[1]) ||
	    ksh_isupper(p[1]))) {
d1420 1
a1420 1
		if (ksh_isdigit(*cp)) {
d3348 1
a3348 1
		if (!rval && !ksh_isdigit(v[0])) {
@


1.341
log
@do not apply alias name restrictions to directories or “hash”
reported by Seb <sbb@@tuxfamily.org>
@
text
@d1422 1
a1422 1
			while (*cp >= ord('0') && *cp <= ord('7')) {
@


1.340
log
@fix test operator comment descriptions
@
text
@d761 1
a761 1
	bool rflag = false, tflag, Uflag = false, pflag = false;
d812 1
d855 1
a855 1
		if (!valid_alias_name(alias) || *alias == '-') {
@


1.339
log
@add test -v, initially from Martijn Dekker
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.333 2017/04/02 15:51:19 tg Exp $");
d2581 7
a2587 8
	unary-operator ::= "-a"|"-r"|"-w"|"-x"|"-e"|"-f"|"-d"|"-c"|"-b"|"-p"|
			   "-u"|"-g"|"-k"|"-s"|"-t"|"-z"|"-n"|"-o"|"-O"|"-G"|
			   "-L"|"-h"|"-S"|"-H";

	binary-operator ::= "="|"=="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"|
			    "-nt"|"-ot"|"-ef"|
			    "<"|">"	# rules used for [[ ... ]] expressions
			    ;
d2835 1
a2835 1
	/* -r */
d2936 1
a2936 1
	/* = */
@


1.338
log
@allow 'eval break', from Martijn Dekker

also, more string pooling, while here
@
text
@d192 1
a193 1
	{"-H",	TO_FILCDF },
d201 1
a202 1
	{"-S",	TO_FILSOCK },
d205 1
d2757 1
d2804 4
@


1.337
log
@put the hyphen-minus back into the allowed alias name characters, for
Steffen Nurpmeso <steffen@@sdaoden.eu>, except disallow it at the start
@
text
@d103 1
a103 1
	{"*=break", c_brkcont},
d111 1
a111 1
	{"*=continue", c_brkcont},
d134 1
a134 1
	{"=source", c_dot},
d734 1
a734 1
			bi_errorf("%s is of unknown type %d", id, tp->type);
d1266 1
a1266 1
		/* This can't fail (have cleared readonly/integer) */
d2066 1
a2066 1
	rv = shell(s, false);
d2202 1
a2202 1
			warningf(true, "%s: can't %s", wp[0], wp[0]);
@


1.336
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d853 1
a853 1
		if (!valid_alias_name(alias)) {
@


1.335
log
@limit alias characters to what POSIX requires
@
text
@d744 11
d853 5
a857 8
		newval = alias;
		while (*newval)
			if (!ksh_isalias(*newval)) {
				bi_errorf(Tinvname, alias, Talias);
				afree(xalias, ATEMP);
				return (1);
			} else
				++newval;
@


1.334
log
@string pooling, and more consistent look for error messages
@
text
@d842 8
@


1.333
log
@move c_typeset() to var.c so we have access to either array_index_calc() or innermost_refflag for 'typeset -p x[2]'
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.330 2017/03/19 20:59:25 tg Exp $");
d76 1
a76 1
		bi_errorf(Tf_sD_s, as, "bad number");
d1348 1
a1348 1
		bi_errorf(Tf_sD_s, arg, "bad number");
d1409 1
a1409 1
				bi_errorf("bad number");
@


1.332
log
@merge mksh-os2 by KO Myung-Hun <komh@@chollian.net> from https://github.com/komh/mksh-os2
@
text
@a743 379
/* typeset, global(deprecated), export, and readonly */
static void c_typeset_vardump(struct tbl *, uint32_t, int, bool, bool);
static void c_typeset_vardump_recursive(struct block *, uint32_t, int, bool,
    bool);
int
c_typeset(const char **wp)
{
	struct tbl *vp, **p;
	uint32_t fset = 0, fclr = 0, flag;
	int thing = 0, field = 0, base = 0, i;
	struct block *l;
	const char *opts;
	const char *fieldstr = NULL, *basestr = NULL;
	bool localv = false, func = false, pflag = false, istset = true;
	enum namerefflag new_refflag = SRF_NOP;

	switch (**wp) {

	/* export */
	case 'e':
		fset |= EXPORT;
		istset = false;
		break;

	/* readonly */
	case 'r':
		fset |= RDONLY;
		istset = false;
		break;

	/* set */
	case 's':
		/* called with 'typeset -' */
		break;

	/* typeset */
	case 't':
		localv = true;
		break;
	}

	/* see comment below regarding possible opions */
	opts = istset ? "L#R#UZ#afgi#lnprtux" : "p";

	builtin_opt.flags |= GF_PLUSOPT;
	/*
	 * AT&T ksh seems to have 0-9 as options which are multiplied
	 * to get a number that is used with -L, -R, -Z or -i (eg, -1R2
	 * sets right justify in a field of 12). This allows options
	 * to be grouped in an order (eg, -Lu12), but disallows -i8 -L3 and
	 * does not allow the number to be specified as a separate argument
	 * Here, the number must follow the RLZi option, but is optional
	 * (see the # kludge in ksh_getopt()).
	 */
	while ((i = ksh_getopt(wp, &builtin_opt, opts)) != -1) {
		flag = 0;
		switch (i) {
		case 'L':
			flag = LJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'R':
			flag = RJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'U':
			/*
			 * AT&T ksh uses u, but this conflicts with
			 * upper/lower case. If this option is changed,
			 * need to change the -U below as well
			 */
			flag = INT_U;
			break;
		case 'Z':
			flag = ZEROFIL;
			fieldstr = builtin_opt.optarg;
			break;
		case 'a':
			/*
			 * this is supposed to set (-a) or unset (+a) the
			 * indexed array attribute; it does nothing on an
			 * existing regular string or indexed array though
			 */
			break;
		case 'f':
			func = true;
			break;
		case 'g':
			localv = (builtin_opt.info & GI_PLUS) ? true : false;
			break;
		case 'i':
			flag = INTEGER;
			basestr = builtin_opt.optarg;
			break;
		case 'l':
			flag = LCASEV;
			break;
		case 'n':
			new_refflag = (builtin_opt.info & GI_PLUS) ?
			    SRF_DISABLE : SRF_ENABLE;
			break;
		/* export, readonly: POSIX -p flag */
		case 'p':
			/* typeset: show values as well */
			pflag = true;
			if (istset)
				continue;
			break;
		case 'r':
			flag = RDONLY;
			break;
		case 't':
			flag = TRACE;
			break;
		case 'u':
			/* upper case / autoload */
			flag = UCASEV_AL;
			break;
		case 'x':
			flag = EXPORT;
			break;
		case '?':
			return (1);
		}
		if (builtin_opt.info & GI_PLUS) {
			fclr |= flag;
			fset &= ~flag;
			thing = '+';
		} else {
			fset |= flag;
			fclr &= ~flag;
			thing = '-';
		}
	}

	if (fieldstr && !bi_getn(fieldstr, &field))
		return (1);
	if (basestr) {
		if (!getn(basestr, &base)) {
			bi_errorf(Tf_sD_s, "bad integer base", basestr);
			return (1);
		}
		if (base < 1 || base > 36)
			base = 10;
	}

	if (!(builtin_opt.info & GI_MINUSMINUS) && wp[builtin_opt.optind] &&
	    (wp[builtin_opt.optind][0] == '-' ||
	    wp[builtin_opt.optind][0] == '+') &&
	    wp[builtin_opt.optind][1] == '\0') {
		thing = wp[builtin_opt.optind][0];
		builtin_opt.optind++;
	}

	if (func && (((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT)) ||
	    new_refflag != SRF_NOP)) {
		bi_errorf("only -t, -u and -x options may be used with -f");
		return (1);
	}
	if (wp[builtin_opt.optind]) {
		/*
		 * Take care of exclusions.
		 * At this point, flags in fset are cleared in fclr and vice
		 * versa. This property should be preserved.
		 */
		if (fset & LCASEV)
			/* LCASEV has priority over UCASEV_AL */
			fset &= ~UCASEV_AL;
		if (fset & LJUST)
			/* LJUST has priority over RJUST */
			fset &= ~RJUST;
		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) {
			/* -Z implies -ZR */
			fset |= RJUST;
			fclr &= ~RJUST;
		}
		/*
		 * Setting these attributes clears the others, unless they
		 * are also set in this command
		 */
		if ((fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
		    INTEGER | INT_U | INT_L)) || new_refflag != SRF_NOP)
			fclr |= ~fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL |
			    LCASEV | INTEGER | INT_U | INT_L);
	}
	if (new_refflag != SRF_NOP) {
		fclr &= ~(ARRAY | ASSOC);
		fset &= ~(ARRAY | ASSOC);
		fclr |= EXPORT;
		fset |= ASSOC;
		if (new_refflag == SRF_DISABLE)
			fclr |= ASSOC;
	}

	/* set variables and attributes */
	if (wp[builtin_opt.optind] &&
	    /* not "typeset -p varname" */
	    !(!func && pflag && !(fset | fclr))) {
		int rv = 0;
		struct tbl *f;

		if (localv && !func)
			fset |= LOCAL;
		for (i = builtin_opt.optind; wp[i]; i++) {
			if (func) {
				f = findfunc(wp[i], hash(wp[i]),
				    tobool(fset & UCASEV_AL));
				if (!f) {
					/* AT&T ksh does ++rv: bogus */
					rv = 1;
					continue;
				}
				if (fset | fclr) {
					f->flag |= fset;
					f->flag &= ~fclr;
				} else {
					fpFUNCTf(shl_stdout, 0,
					    tobool(f->flag & FKSH),
					    wp[i], f->val.t);
					shf_putc('\n', shl_stdout);
				}
			} else if (!typeset(wp[i], fset, fclr, field, base)) {
				bi_errorf(Tf_sD_s, wp[i], Tnot_ident);
				return (1);
			}
		}
		return (rv);
	}

	/* list variables and attributes */

	/* no difference at this point.. */
	flag = fset | fclr;
	if (func) {
		for (l = e->loc; l; l = l->next) {
			for (p = ktsort(&l->funs); (vp = *p++); ) {
				if (flag && (vp->flag & flag) == 0)
					continue;
				if (thing == '-')
					fpFUNCTf(shl_stdout, 0,
					    tobool(vp->flag & FKSH),
					    vp->name, vp->val.t);
				else
					shf_puts(vp->name, shl_stdout);
				shf_putc('\n', shl_stdout);
			}
		}
	} else if (wp[builtin_opt.optind]) {
		for (i = builtin_opt.optind; wp[i]; i++) {
			varsearch(e->loc, &vp, wp[i], hash(wp[i]));
			c_typeset_vardump(vp, flag, thing, pflag, istset);
		}
	} else
		c_typeset_vardump_recursive(e->loc, flag, thing, pflag, istset);
	return (0);
}

static void
c_typeset_vardump_recursive(struct block *l, uint32_t flag, int thing,
    bool pflag, bool istset)
{
	struct tbl **blockvars, *vp;

	if (l->next)
		c_typeset_vardump_recursive(l->next, flag, thing, pflag, istset);
	blockvars = ktsort(&l->vars);
	while ((vp = *blockvars++))
		c_typeset_vardump(vp, flag, thing, pflag, istset);
	/*XXX doesn’t this leak? */
}

static void
c_typeset_vardump(struct tbl *vp, uint32_t flag, int thing, bool pflag,
    bool istset)
{
	struct tbl *tvp;
	int any_set = 0;
	char *s;

	if (!vp)
		return;

	/*
	 * See if the parameter is set (for arrays, if any
	 * element is set).
	 */
	for (tvp = vp; tvp; tvp = tvp->u.array)
		if (tvp->flag & ISSET) {
			any_set = 1;
			break;
		}

	/*
	 * Check attributes - note that all array elements
	 * have (should have?) the same attributes, so checking
	 * the first is sufficient.
	 *
	 * Report an unset param only if the user has
	 * explicitly given it some attribute (like export);
	 * otherwise, after "echo $FOO", we would report FOO...
	 */
	if (!any_set && !(vp->flag & USERATTRIB))
		return;
	if (flag && (vp->flag & flag) == 0)
		return;
	if (!(vp->flag & ARRAY))
		/* optimise later conditionals */
		any_set = 0;
	do {
		/*
		 * Ignore array elements that aren't set unless there
		 * are no set elements, in which case the first is
		 * reported on
		 */
		if (any_set && !(vp->flag & ISSET))
			continue;
		/* no arguments */
		if (!thing && !flag) {
			if (any_set == 1) {
				shprintf(Tf_s_s_sN, Tset, "-A", vp->name);
				any_set = 2;
			}
			/*
			 * AT&T ksh prints things like export, integer,
			 * leftadj, zerofill, etc., but POSIX says must
			 * be suitable for re-entry...
			 */
			shprintf(Tf_s_s, Ttypeset, "");
			if (((vp->flag & (ARRAY | ASSOC)) == ASSOC))
				shprintf(Tf__c_, 'n');
			if ((vp->flag & INTEGER))
				shprintf(Tf__c_, 'i');
			if ((vp->flag & EXPORT))
				shprintf(Tf__c_, 'x');
			if ((vp->flag & RDONLY))
				shprintf(Tf__c_, 'r');
			if ((vp->flag & TRACE))
				shprintf(Tf__c_, 't');
			if ((vp->flag & LJUST))
				shprintf("-L%d ", vp->u2.field);
			if ((vp->flag & RJUST))
				shprintf("-R%d ", vp->u2.field);
			if ((vp->flag & ZEROFIL))
				shprintf(Tf__c_, 'Z');
			if ((vp->flag & LCASEV))
				shprintf(Tf__c_, 'l');
			if ((vp->flag & UCASEV_AL))
				shprintf(Tf__c_, 'u');
			if ((vp->flag & INT_U))
				shprintf(Tf__c_, 'U');
		} else if (pflag) {
			shprintf(Tf_s_s, istset ? Ttypeset :
			    (flag & EXPORT) ? Texport : Treadonly, "");
		}
		if (any_set)
			shprintf("%s[%lu]", vp->name, arrayindex(vp));
		else
			shf_puts(vp->name, shl_stdout);
		if ((!thing && !flag && pflag) ||
		    (thing == '-' && (vp->flag & ISSET))) {
			s = str_val(vp);
			shf_putc('=', shl_stdout);
			/* AT&T ksh can't have justified integers... */
			if ((vp->flag & (INTEGER | LJUST | RJUST)) == INTEGER)
				shf_puts(s, shl_stdout);
			else
				print_value_quoted(shl_stdout, s);
		}
		shf_putc('\n', shl_stdout);

		/*
		 * Only report first 'element' of an array with
		 * no set elements.
		 */
		if (!any_set)
			return;
	} while ((vp = vp->u.array));
}

@


1.331
log
@fixup LINENO in eval and alias; patch and initial testcase
From: Martijn Dekker <martijn@@inlv.org>
@
text
@d1972 4
d2104 3
d2108 5
d2127 3
d2846 1
a2846 1
#if HAVE_MKNOD
d3103 8
d3176 1
a3176 1
		return (access(opnd1, R_OK) == 0);
d3181 1
a3181 1
		return (access(opnd1, W_OK) == 0);
d3191 1
a3191 1
		return (stat(opnd1, &b1) == 0);
d3195 1
a3195 1
		return (stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode));
@


1.330
log
@use \\builtin ipv \let] and \set internally
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.320 2017/02/08 15:27:27 tg Exp $");
d2376 1
@


1.329
log
@Haiku-related ulimit overhaul:
• print ulimit -a with the flag, like most other shells do
• move ulimit-1 regression test to ulimit-2 and exclude on Haiku:
  it can only set the -n and -V limits AFAICT
• document that some OSes (here: Haiku) can only set the soft limits
  (so “ulimit -nS 1024” is okay but -S is required)
• check “ulimit -c 0”, which dot.mkshrc uses, everywhere
  (if it errors out, hack around it or stub it out with MKSH_NO_LIMITS)
@
text
@a124 2
	/* deprecated, to be replaced by \\builtin let */
	{"let]", c_let},
@


1.328
log
@implement “typeset -g”, From: Martijn Dekker <martijn@@inlv.org>
also deprecate “global”; thanks!
@
text
@d3658 1
a3658 1
		shprintf("%-20s ", rlimits[i]->name);
@


1.327
log
@document the declaration utility stuff and the new \builtin
also, make global a declaration utility
@
text
@d120 1
d746 1
a746 1
/* typeset, global, export, and readonly */
d788 1
a788 1
	opts = istset ? "L#R#UZ#afi#lnprtux" : "p";
d833 3
@


1.326
log
@add a “\builtin” builtin, make it forward assignments, fix some bugs
related to that:
• while AT&T ksh may do it, POSIX says nothing about allowing
  declaration commands only without vars and redirections, and
  “without vars” especially seems against which commands they are
• fix relationship between forwarders and real declaration commands
• clean up c_builtin vs shcomexec mess

Also, re-run “make repool” with a fixed src/scripts/stringpool.sh,v 1.3
@
text
@d120 1
a120 1
	{"=global", c_typeset},
d124 1
@


1.325
log
@add “\builtin” utility
@
text
@d95 1
d104 1
a104 1
	{T_builtin, c_builtin},
d110 1
a110 1
	{Tcommand, c_command},
d116 1
a116 1
	{Tsgexport, c_typeset},
d128 1
a128 1
	{Tsgreadonly, c_typeset},
d142 1
a142 1
	{Tgtypeset, c_typeset},
@


1.324
log
@make “builtin” and “wait” not special

(“\builtin” likely also doesn’t need it, as “command” isn’t)
@
text
@d103 1
@


1.323
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d103 1
a103 1
	{Tgbuiltin, c_builtin},
d145 1
a145 1
	{"=wait", c_wait},
@


1.322
log
@less assignments
@
text
@a2811 1
#ifndef MKSH_LEGACY_MODE
a2818 1
#endif
@


1.321
log
@there’s no evidence for -e in any BSD echo (but in ksh93 print)

spotted by Jean Delvare <jdelvare@@suse.de> and Werner Fink <werner@@suse.de>
@
text
@a319 1
	po.exp = true;
d381 2
@


1.320
log
@fix broken indentation accidentally introduced in -r1.293
(after checking whether indeed indentation or braces are wrong)

spotted by Jean Delvare <jdelvare@@suse.de> via mailing list, thanks!
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.316 2016/11/11 21:13:23 tg Exp $");
a309 2
		/* print a "--" argument? */
		bool pminusminus;
a323 11
		++wp;
#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT
		if (Flag(FSH)) {
			/*
			 * MidnightBSD /bin/sh needs a BSD echo, that is,
			 * one that supports -e but does not enable it by
			 * default
			 */
			po.exp = false;
		}
#endif
d329 3
a331 1
			/* Debian Policy 10.4 compliant "echo" builtin */
a332 1
				/* recognise "-n" only as the first arg */
a335 1
			/* print everything as-is */
d338 1
a338 1
			bool new_exp = po.exp, new_nl = po.nl;
d340 4
a343 9
			/**
			 * a compromise between sysV and BSD echo commands:
			 * escape sequences are enabled by default, and -n,
			 * -e and -E are recognised if they appear in argu-
			 * ments with no illegal options (ie, echo -nq will
			 * print -nq).
			 * Different from sysV echo since options are reco-
			 * gnised, different from BSD echo since escape se-
			 * quences are enabled by default.
d345 9
d369 1
d379 1
a379 1
		const char *opts = "AclNnpRrsu,";
a381 2
		po.pminusminus = false;

d410 3
a412 5
				/* fake BSD echo command */
				po.pminusminus = true;
				po.exp = false;
				opts = "en";
				break;
d436 1
a436 2
		} else if (po.pminusminus)
			builtin_opt.optind--;
@


1.319
log
@gcc 6.2 warnings (stupid uninitialised that wasn't, plus FALLTHROUGH fixes)
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013, 2014, 2015, 2016
d448 2
a449 2
			} else if (po.pminusminus)
				builtin_opt.optind--;
@


1.318
log
@return 128+SIGALRM if read with timeout timeouts, inspired by GNU bash
@
text
@a286 1
	XPtrV words;
d288 2
d317 1
a322 3
	po.col = false;
	po.hist = false;
	po.chars = false;
d457 1
a457 1
		XPinit(words, 16);
d519 1
a519 1
		XPput(words, Xclose(xs, xp));
d528 1
a528 1
		size_t w = XPsize(words);
d531 1
a531 1
		XPput(words, NULL);
d535 1
a535 1
		pr_list(&co, (char **)XPptrv(words));
d537 2
a538 2
			afree(XPptrv(words)[w], ATEMP);
		XPfree(words);
@


1.317
log
@fix print -cn
@
text
@d2088 1
a2088 1
			rv = 1;
d2098 2
a2099 2
			/* fake EOF read; all cases return 1 */
			goto c_read_didread;
a2123 1
 c_read_didread:
d2197 1
a2197 1
	 * rv = 1 if EOF, 0 otherwise (errors handled already)
d2200 2
a2201 2
	if (rv == 1) {
		/* clean up coprocess if needed, on EOF */
d2203 1
a2203 1
		if (readmode == READALL)
d2369 1
a2369 1
	return (rv);
@


1.316
log
@make print -c honour line separator
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.301 2016/07/25 20:38:02 tg Exp $");
d297 4
a300 2
		/* output line separator ('!' to not print any) */
		char nl;
d318 2
a319 1
	po.nl = '\n';
d346 1
a346 1
				po.nl = '!';
d352 1
a352 2
			bool new_exp = po.exp;
			char new_nl = po.nl;
d376 1
a376 1
					new_nl = '!';
d409 1
a409 1
				po.nl = '\0';
d412 1
a412 1
				po.nl = '!';
d495 1
a495 1
						po.nl = '!';
d534 1
a534 1
		co.linesep = po.nl;
d547 2
a548 2
	if (po.nl != '!')
		Xput(xs, xp, po.nl);
@


1.315
log
@just 'print -c' outputs not even a newline; plug a memleak while here
@
text
@a527 1
		char *cp;
d532 2
a533 1
		co.prefcol = false;
d538 1
a538 3
		cp = shf_sclose(co.shf);
		w = strlen(cp);

d540 1
a540 1
		memcpy(xp, cp, w);
d542 1
a542 3
		afree(cp, ATEMP);

		po.nl = '!'; /* for now */
d1519 2
a1520 1
			co.prefcol = true;
@


1.314
log
@put print_columns options into a helper struct, eases passing things around
@
text
@d452 7
a462 2
	if (po.col)
		XPinit(words, 16);
a555 1
		Xfree(xs, xp);
d595 1
@


1.313
log
@first implementation of “print -c” for columnising, currently hardcoded newlines
@
text
@d524 1
a524 1
		struct shf shf;
a525 1
		shf_sopen(NULL, 128, SHF_WR | SHF_DYNAMIC, &shf);
d527 3
a529 1
		pr_list(&shf, (char **)XPptrv(words));
d533 1
a533 1
		cp = shf_sclose(&shf);
d1499 1
d1517 4
a1520 1
			print_columns(shl_stdout, (unsigned int)(ksh_NSIG - 1),
d1523 1
a1523 2
			    ki.num_width + 1 + ki.name_width + 1 + mess_cols,
			    true);
@


1.312
log
@implement print -N: set output word and line separator to NUL
@
text
@d287 1
d301 2
d318 1
d386 1
a386 1
		const char *opts = "AlNnpRrsu,";
d396 3
d456 2
d511 5
d517 2
a518 1
		Xput(xs, xp, po.ws);
d521 21
@


1.311
log
@implement print -l: change output word separator to newline
@
text
@d295 3
a297 3
		char ows;
		/* print trailing newline? */
		bool nl;
d312 2
a313 2
	po.ows = ' ';
	po.nl = true;
d339 1
a339 1
				po.nl = false;
d345 2
a346 1
			bool new_exp = po.exp, new_nl = po.nl;
d370 1
a370 1
					new_nl = false;
d382 1
a382 1
		const char *opts = "AlnpRrsu,";
d396 5
a400 1
				po.ows = '\n';
d403 1
a403 1
				po.nl = false;
d479 1
a479 1
						po.nl = false;
d503 1
a503 1
		Xput(xs, xp, po.ows);
d507 2
a508 2
	if (po.nl)
		Xput(xs, xp, '\n');
@


1.310
log
@goto keeps us from evaluating the loop condition twice in immediate succession
(and shaves off an indentation level)
@
text
@d294 2
d312 1
d381 1
a381 1
		const char *opts = "AnpRrsu,";
d394 3
d498 1
a498 1
		Xput(xs, xp, ' ');
@


1.309
log
@implement: empty arg in print -A is input word separator
@
text
@d436 45
a480 12
	while (*wp != NULL) {
		if (po.chars) {
			while (*wp != NULL) {
				s = *wp++;
				if (*s == '\0')
					break;
				if (!evaluate(s, &po.wc,
				    KSH_RETURN_ERROR, true))
					return (1);
				Xcheck(xs, xp);
				if (UTFMODE) {
					po.ts[utf_wctomb(po.ts, po.wc)] = 0;
d485 1
a485 35
				} else
					Xput(xs, xp, po.wc & 0xFF);
			}
		} else {
			s = *wp++;
			while ((c = *s++) != '\0') {
				Xcheck(xs, xp);
				if (po.exp && c == '\\') {
					s_ptr = s;
					c = unbksl(false, s_get, s_put);
					s = s_ptr;
					if (c == -1) {
						/* rejected by generic unbksl */
						switch ((c = *s++)) {
						case 'c':
							po.nl = false;
							/* AT&T brain damage */
							continue;
						case '\0':
							--s;
							c = '\\';
							break;
						default:
							Xput(xs, xp, '\\');
						}
					} else if ((unsigned int)c > 0xFF) {
						/* unbksl returned Unicode */
						po.ts[utf_wctomb(po.ts,
						    c - 0x100)] = 0;
						c = 0;
						do {
							Xput(xs, xp, po.ts[c]);
						} while (po.ts[++c]);
						continue;
					}
a486 1
				Xput(xs, xp, c);
d488 1
a489 2
		if (*wp != NULL)
			Xput(xs, xp, ' ');
d491 5
@


1.308
log
@refactor c_print into a loop
@
text
@d438 5
a442 2
			do {
				if (!evaluate(*wp, &po.wc,
d454 1
a454 1
			} while (*++wp);
d456 1
a456 1
			s = *wp;
a489 2
			if (*++wp != NULL)
				Xput(xs, xp, ' ');
d491 2
@


1.307
log
@pack local bools into a struct, for tighter stack packing
@
text
@d436 9
a444 40
	if (*wp != NULL && po.chars) {
		do {
			if (!evaluate(*wp, &po.wc, KSH_RETURN_ERROR, true))
				return (1);
			Xcheck(xs, xp);
			if (UTFMODE) {
				po.ts[utf_wctomb(po.ts, po.wc)] = 0;
				c = 0;
				do {
					Xput(xs, xp, po.ts[c]);
				} while (po.ts[++c]);
			} else
				Xput(xs, xp, po.wc & 0xFF);
		} while (*++wp);
	} else if (*wp != NULL) {
 print_read_arg:
		s = *wp;
		while ((c = *s++) != '\0') {
			Xcheck(xs, xp);
			if (po.exp && c == '\\') {
				s_ptr = s;
				c = unbksl(false, s_get, s_put);
				s = s_ptr;
				if (c == -1) {
					/* rejected by generic function */
					switch ((c = *s++)) {
					case 'c':
						po.nl = false;
						/* AT&T brain damage */
						continue;
					case '\0':
						--s;
						c = '\\';
						break;
					default:
						Xput(xs, xp, '\\');
					}
				} else if ((unsigned int)c > 0xFF) {
					/* generic function returned Unicode */
					po.ts[utf_wctomb(po.ts, c - 0x100)] = 0;
d449 35
a483 1
					continue;
d485 1
d487 2
a488 5
			Xput(xs, xp, c);
		}
		if (*++wp != NULL) {
			Xput(xs, xp, ' ');
			goto print_read_arg;
@


1.306
log
@read(2) and write(2) don’t EINTR for fast input (LP#1616692)
@
text
@d283 1
a283 1
	int fd = 1, c;
d285 1
d287 27
a313 8
	char *xp;
	/* print newline;  expand backslash sequences */
	bool po_nl = true, po_exp = true;
	/* print to history instead of file descriptor / stdout */
	bool po_hist = false;
	/* print characters */
	bool po_char = false;
	char ts[4];
d325 1
a325 1
			po_exp = false;
d336 1
a336 1
				po_nl = false;
d340 1
a340 1
			po_exp = false;
d342 1
a342 1
			bool new_exp = po_exp, new_nl = po_nl;
d369 2
a370 2
					po_exp = new_exp;
					po_nl = new_nl;
d380 2
a381 2
		/* print a "--" argument */
		bool po_pminusminus = false;
d386 1
a386 1
				po_char = true;
d389 1
a389 1
				po_exp = true;
d392 1
a392 1
				po_nl = false;
d395 1
a395 1
				if ((fd = coproc_getfd(W_OK, &emsg)) < 0) {
d402 2
a403 2
				po_pminusminus = true;
				po_exp = false;
d407 1
a407 1
				po_exp = false;
d410 1
a410 1
				po_hist = true;
d414 2
a415 2
					fd = 0;
				else if ((fd = check_fd(s, W_OK, &emsg)) < 0) {
d429 1
a429 1
			} else if (po_pminusminus)
d436 1
a436 3
	if (*wp != NULL && po_char) {
		mksh_ari_t wc;

d438 1
a438 1
			if (!evaluate(*wp, &wc, KSH_RETURN_ERROR, true))
d442 1
a442 1
				ts[utf_wctomb(ts, wc)] = 0;
d445 2
a446 2
					Xput(xs, xp, ts[c]);
				} while (ts[++c]);
d448 1
a448 1
				Xput(xs, xp, wc & 0xFF);
d455 1
a455 1
			if (po_exp && c == '\\') {
d463 1
a463 1
						po_nl = false;
d475 1
a475 1
					ts[utf_wctomb(ts, c - 0x100)] = 0;
d478 2
a479 2
						Xput(xs, xp, ts[c]);
					} while (ts[++c]);
d490 1
a490 1
	if (po_nl)
d494 1
a494 1
	if (po_hist) {
a499 2
		bool po_coproc = false;
		int opipe = 0;
d507 5
a511 4
		if (coproc.write >= 0 && coproc.write == fd) {
			po_coproc = true;
			opipe = block_pipe();
		}
d517 1
a517 1
			if ((nwritten = write(fd, s, len)) < 0) {
d519 2
a520 2
					if (po_coproc)
						restore_pipe(opipe);
d524 2
a525 2
					if (po_coproc)
						opipe = block_pipe();
d534 2
a535 2
		if (po_coproc)
			restore_pipe(opipe);
d3741 1
a3741 1
	int opipe = 0;
d3781 2
a3782 1
					restore_pipe(opipe);
d3806 2
a3807 1
					restore_pipe(opipe);
d3833 2
a3834 1
	restore_pipe(opipe);
@


1.305
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtc’s programmable tab completion)
to the manpage
@
text
@d3779 2
d3787 1
@


1.304
log
@fix missing Xcheck leading to overflow for strings > 127 array elements
@
text
@d3205 5
a3209 2
		if (te->flags & TEF_DBRACKET)
			return (gmatchx(opnd1, opnd2, false));
d3214 5
a3218 2
		if (te->flags & TEF_DBRACKET)
			return (!gmatchx(opnd1, opnd2, false));
@


1.303
log
@fix (POSIX) errorlevel of ‘.’ when sourced file has no commands; issue discovered by Natureshadow
@
text
@d422 1
@


1.302
log
@defer to external rename(1) too
@
text
@d1809 1
a1809 1
	int argc, i, errcode;
d1838 3
a1840 1
	if ((i = include(file, argc, argv, false)) < 0) {
d1845 4
a1848 1
	return (i);
@


1.301
log
@add print -A for R53
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.289 2016/01/13 17:20:49 tg Exp $");
d128 1
a128 1
	{Trename, c_rename},
@


1.300
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d291 3
d358 1
a358 1
		const char *opts = "npRrsu,";
d365 3
d416 16
a431 1
	if (*wp != NULL) {
a455 2
					char ts[4];

@


1.299
log
@re-add realpath to prefer-external-if-argument, needed by Debian
@
text
@d76 1
a76 1
		bi_errorf("%s: %s", as, "bad number");
d97 1
a97 1
	{"*=.", c_dot},
d99 1
a99 1
	{"[", c_test},
d104 2
a105 2
	{"!cat", c_cat},
	{"cd", c_cd},
d115 1
a115 1
	{"false", c_false},
d117 1
a117 1
	{"getopts", c_getopts},
d119 1
a119 1
	{"jobs", c_jobs},
d125 1
a125 1
	{"read", c_read},
d128 1
a128 1
	{"rename", c_rename},
d134 1
a134 1
	{"suspend", c_suspend},
d139 2
a140 2
	{"true", c_true},
	{T_typeset, c_typeset},
d148 2
a149 2
	{"bg", c_fgbg},
	{"fg", c_fgbg},
d258 1
a258 1
		bi_errorf("too many arguments");
d267 1
a267 1
		bi_errorf("%s: %s", "can't determine current directory",
d271 1
a271 1
	shprintf("%s\n", p);
d370 1
a370 1
					bi_errorf("-p: %s", emsg);
d522 1
a522 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "pv")) != -1)
d546 1
a546 2
	/* options not sorted to facilitate string pooling */
	while ((optc = ksh_getopt(wp, &builtin_opt, "Vpv")) != -1)
d632 1
a632 1
					shprintf("%s not found", id);
d797 1
a797 1
			bi_errorf("%s: %s", "bad integer base", basestr);
d880 1
a880 1
				bi_errorf("%s: %s", wp[i], "is not an identifier");
d977 1
a977 1
				shprintf("%s %s %s\n", Tset, "-A", vp->name);
d985 1
a985 1
			shprintf("%s %s", Ttypeset, "");
d987 1
a987 1
				shprintf("-%c ", 'n');
d989 1
a989 1
				shprintf("-%c ", 'i');
d991 1
a991 1
				shprintf("-%c ", 'x');
d993 1
a993 1
				shprintf("-%c ", 'r');
d995 1
a995 1
				shprintf("-%c ", 't');
d1001 1
a1001 1
				shprintf("-%c ", 'Z');
d1003 1
a1003 1
				shprintf("-%c ", 'l');
d1005 1
a1005 1
				shprintf("-%c ", 'u');
d1007 1
a1007 1
				shprintf("-%c ", 'U');
d1009 1
a1009 1
			shprintf("%s %s", istset ? Ttypeset :
d1115 1
a1115 1
					shprintf("%s ", Talias);
d1140 1
a1140 1
					shprintf("%s ", Talias);
d1148 1
a1148 2
				shprintf("%s %s %s\n", alias, Talias,
				    "not found");
d1252 1
a1252 1
		bi_errorf("no arguments");
d1303 1
a1303 1
	bool bg = strcmp(*wp, "bg") == 0;
d1348 1
a1348 1
			bi_errorf("bad signal '%s'", p + 1);
d1363 1
a1363 1
					bi_errorf("bad signal '%s'",
d1393 1
a1393 1
					shprintf("%s\n", sigtraps[n].name);
d1395 1
a1395 1
					shprintf("%d\n", n);
d1440 1
a1440 1
			bi_errorf("%s: %s", p,
d1445 1
a1445 1
				bi_errorf("%s: %s", p, cstrerror(errno));
d1477 1
a1477 1
		bi_errorf("missing %s argument", "options");
d1483 1
a1483 1
		bi_errorf("missing %s argument", "name");
d1487 1
a1487 1
		bi_errorf("%s: %s", var, "is not an identifier");
d1492 1
a1492 1
		internal_warningf("%s: %s", "c_getopts", "no argv");
d1637 1
a1637 1
		bi_errorf("%s: %s", arg, "bad number");
d1677 1
a1677 1
				*p++ = "ugo"[i];
d1685 1
a1685 1
			shprintf("%s\n", buf);
d1713 1
a1713 1
				while (*cp && vstrchr("augo", *cp))
d1796 1
a1796 1
		bi_errorf("missing argument");
d1804 1
a1804 1
		bi_errorf("%s: %s", cp, cstrerror(errcode));
d1821 1
a1821 1
		bi_errorf("%s: %s", cp, cstrerror(errno));
d1902 1
a1902 1
			bi_errorf("-p: %s", ccp);
d1915 1
a1915 1
			bi_errorf("%s: %s '%s'", Tsynerr, cstrerror(errno),
d1926 1
a1926 1
			bi_errorf("%s: %s: %s", "-u", builtin_opt.optarg, ccp);
d1938 1
a1938 1
		bi_errorf("too many arguments");
d1998 1
a1998 1
			bi_errorf("%s: %s", Tselect, cstrerror(errno));
d2015 1
a2015 1
			bi_errorf("%s", cstrerror(errno));
d2117 1
a2117 1
			bi_errorf("read-only: %s", *wp);
d2345 1
a2345 1
				shprintf(" %s\n", p->name);
d2367 1
a2367 2
			warningf(true, "%s: bad signal '%s'",
			    builtin_argv0, wp[-1]);
d2412 1
a2412 1
	bi_errorf("too many arguments");
d2561 1
a2561 1
				warningf(true, "read-only: %s", vp->name);
d2591 1
a2591 1
	    usage.ru_utime.tv_usec, 0, null, " ");
d2597 1
a2597 1
	    usage.ru_utime.tv_usec, 0, null, " ");
d2656 1
a2656 1
			    5, "real ", "\n");
d2659 1
a2659 1
			    5, null, " real ");
d2663 1
a2663 1
		    5, "user ", "\n");
d2666 1
a2666 1
		    5, null, " user ");
d2694 2
a2695 2
			errorf("time: -%s %s", opt.optarg,
			    "unknown option");
d2697 2
a2698 2
			errorf("time: -%s %s", opt.optarg,
			    "requires an argument");
d2788 1
a2788 1
			bi_errorf("non-numeric %s %s '%s'", "device", "major", argv[2]);
d2793 1
a2793 1
			bi_errorf("non-numeric %s %s '%s'", "device", "minor", argv[3]);
d2798 1
a2798 1
			bi_errorf("%s %s too large: %lu", "device", "major", majnum);
d2802 1
a2802 1
			bi_errorf("%s %s too large: %lu", "device", "minor", minnum);
d2809 1
a2809 1
		bi_errorf("%s: %s", argv[0], cstrerror(errno));
d2867 1
a2867 1
	if (strcmp(wp[0], "[") == 0) {
d3344 1
a3344 1
				(*te->error)(te, -1, "missing argument");
d3420 1
a3420 1
		bi_errorf("%s: %s", op, msg);
d3422 1
a3422 1
		bi_errorf("%s", msg);
d3550 1
a3550 1
			bi_errorf("too many arguments");
d3651 1
a3651 1
		bi_errorf("%s: %s", "failed", cstrerror(rv));
d3674 1
a3674 1
		bi_errorf("%s: %s", wp[0], cstrerror(rv));
d3678 1
a3678 1
		shprintf("%s\n", buf);
d3724 1
a3724 1
				bi_errorf("%s: %s", fn, cstrerror(errno));
d3741 1
a3741 1
				bi_errorf("%s: %s", fn, cstrerror(errno));
d3766 1
a3766 1
					bi_errorf("%s: %s", "<stdout>",
d3801 1
a3801 1
		bi_errorf("%s: %s '%s'", Tsynerr, cstrerror(errno), wp[0]);
d3831 1
a3831 1
			bi_errorf("%s: %s", Tselect, cstrerror(errno));
d3846 1
a3846 1
		bi_errorf("too many arguments");
@


1.298
log
@invent builtin flags instead of special-casing cat and printf for prefer-external-over-builtin stuff
@
text
@d127 1
a127 1
	{"realpath", c_realpath},
@


1.297
log
@since we already support XSI test -a/-o, they better behave
@
text
@d104 1
a104 1
	{Tcat, c_cat},
d158 1
a158 1
	{Tprintf, c_printf},
@


1.296
log
@abort read builtin in case of read(2) errors

noticed by arekm, persuaded by jilles, compared with other equivalent
pieces of code reading in mksh
@
text
@d2858 1
d2919 10
@


1.295
log
@I didn’t like the code behind command -[Vv] and whence, so I rewrote it.
Bugreport by Martijn Dekker <martijn@@inlv.org> about POSIX non-compliance
@
text
@d2007 11
a2017 11
	bytesread = blocking_read(fd, xp, bytesleft);
	if (bytesread == (size_t)-1) {
		/* interrupted */
		if (errno == EINTR && fatal_trap_check()) {
			/*
			 * Was the offending signal one that would
			 * normally kill a process? If so, pretend
			 * the read was killed.
			 */
			rv = 2;
			goto c_read_out;
d2019 2
a2020 2
		/* just ignore the signal */
		goto c_read_readloop;
@


1.294
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d67 2
d519 2
a520 6
	struct tbl *tp;
	const char *id;
	bool pflag = false, vflag = false, Vflag = false;
	int rv = 0, optc, fcflags;
	bool iam_whence = wp[0][0] == 'w';
	const char *opts = iam_whence ? "pv" : "pvV";
d522 1
a522 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1)
d530 22
d553 4
a556 1
			Vflag = true;
d563 10
a572 14
	fcflags = FC_BI | FC_PATH | FC_FUNC;
	if (!iam_whence) {
		/* Note that -p on its own is deal with in comexec() */
		if (pflag)
			fcflags |= FC_DEFPATH;
		/*
		 * Convert command options to whence options - note that
		 * command -pV uses a different path search than whence -v
		 * or whence -pv. This should be considered a feature.
		 */
		vflag = Vflag;
	}
	if (pflag)
		fcflags &= ~(FC_BI | FC_FUNC);
d575 2
a576 1
		uint32_t h = 0;
d578 4
a581 5
		tp = NULL;
		if (!pflag)
			tp = ktsearch(&keywords, id, h = hash(id));
		if (!tp && !pflag) {
			tp = ktsearch(&aliases, id, h ? h : hash(id));
d587 5
a591 2
		if (vflag || (tp->type != CALIAS && tp->type != CEXEC &&
		    tp->type != CTALIAS))
d593 1
a593 17
		if (vflag) {
			switch (tp->type) {
			case CKEYWD:
			case CALIAS:
			case CFUNC:
			case CSHELL:
				shf_puts(" is a", shl_stdout);
				break;
			}
			switch (tp->type) {
			case CKEYWD:
			case CSHELL:
			case CTALIAS:
			case CEXEC:
				shf_putc(' ', shl_stdout);
				break;
			}
d597 1
a597 5
		case CKEYWD:
			if (vflag)
				shf_puts("reserved word", shl_stdout);
			break;
		case CALIAS:
d599 3
a601 5
				shprintf("n %salias for ",
				    (tp->flag & EXPORT) ? "exported " : null);
			if (!iam_whence && !vflag)
				shprintf("%s %s=", Talias, id);
			print_value_quoted(shl_stdout, tp->val.s);
d605 1
d619 1
a619 7
		case CSHELL:
			if (vflag) {
				if (tp->flag & SPEC_BI)
					shf_puts("special ", shl_stdout);
				shprintf("%s %s", "shell", Tbuiltin);
			}
			break;
a620 1
		case CEXEC:
d623 1
a623 1
					shf_puts("is ", shl_stdout);
d627 1
a627 1
						    "exported " : null,
d633 1
a633 1
					shf_puts("not found", shl_stdout);
d637 14
d652 3
a654 2
			shf_puts(" is *GOK*", shl_stdout);
			break;
a661 11
/* Deal with command -vV - command -p dealt with in comexec() */
int
c_command(const char **wp)
{
	/*
	 * Let c_whence do the work. Note that c_command() must be
	 * a distinct function from c_whence() (tested in comexec()).
	 */
	return (c_whence(wp));
}

@


1.293
log
@fix errno in print/echo builtin; optimise (with partial rewrite)
@
text
@d597 2
a598 3
				shprintf("n %s%s for ",
				    (tp->flag & EXPORT) ? "exported " : null,
				    Talias);
d990 1
a990 1
				shprintf("%s ", "-n");
d992 1
a992 1
				shprintf("%s ", "-i");
d994 1
a994 1
				shprintf("%s ", "-x");
d996 1
a996 1
				shprintf("%s ", "-r");
d998 1
a998 1
				shprintf("%s ", "-t");
d1004 1
a1004 1
				shprintf("%s ", "-Z");
d1006 1
a1006 1
				shprintf("%s ", "-l");
d1008 1
a1008 1
				shprintf("%s ", "-u");
d1010 1
a1010 1
				shprintf("%s ", "-U");
d1906 1
a1906 1
			bi_errorf("%s: %s", "-p", ccp);
d2371 2
a2372 2
			warningf(true, "%s: %s '%s'", builtin_argv0,
			    "bad signal", wp[-1]);
d2439 1
a2439 1
		bi_errorf("%s: %s", arg, "bad value");
d2460 1
a2460 1
			warningf(true, "%s: %s %s", wp[0], "can't", wp[0]);
d2823 2
a2824 2
	bi_errorf("%s: %s", "usage", "mknod [-m mode] name b|c major minor");
	bi_errorf("%s: %s", "usage", "mknod [-m mode] name p");
@


1.292
log
@handle SIGPIPE in built-in cat correctly (LP#1532621)
@
text
@a280 5
#define PO_NL		BIT(0)	/* print newline */
#define PO_EXPAND	BIT(1)	/* expand backslash sequences */
#define PO_PMINUSMINUS	BIT(2)	/* print a -- argument */
#define PO_HIST		BIT(3)	/* print to history instead of stdout */
#define PO_COPROC	BIT(4)	/* printing to coprocess: block SIGPIPE */
d282 1
a282 2
	int flags = PO_EXPAND | PO_NL;
	const char *s, *emsg;
d285 4
d291 2
a292 2
		/* echo builtin */
		wp++;
d300 1
a300 1
			flags = PO_NL;
d310 6
a315 6
				/* we recognise "-n" only as the first arg */
				flags = 0;
				wp++;
			} else
				/* otherwise, we print everything as-is */
				flags = PO_NL;
d317 1
a317 1
			int nflags = flags;
d330 19
a348 19
			while ((s = *wp) && *s == '-' && s[1]) {
				while (*++s)
					if (*s == 'n')
						nflags &= ~PO_NL;
					else if (*s == 'e')
						nflags |= PO_EXPAND;
					else if (*s == 'E')
						nflags &= ~PO_EXPAND;
					else
						/*
						 * bad option: don't use
						 * nflags, print argument
						 */
						break;

				if (*s)
					break;
				wp++;
				flags = nflags;
d352 5
a356 2
		int optc;
		const char *opts = "Rnprsu,";
d358 2
a359 8
		while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1)
			switch (optc) {
			case 'R':
				/* fake BSD echo command */
				flags |= PO_PMINUSMINUS;
				flags &= ~PO_EXPAND;
				opts = "ne";
				break;
d361 1
a361 1
				flags |= PO_EXPAND;
d364 1
a364 1
				flags &= ~PO_NL;
d368 1
a368 1
					bi_errorf("%s: %s", "-p", emsg);
d372 6
d379 1
a379 1
				flags &= ~PO_EXPAND;
d382 1
a382 1
				flags |= PO_HIST;
d388 1
a388 1
					bi_errorf("%s: %s: %s", "-u", s, emsg);
d397 1
a397 1
			/* treat a lone - like -- */
d401 2
a402 2
		} else if (flags & PO_PMINUSMINUS)
			builtin_opt.optind--;
d408 2
a409 1
	while (*wp != NULL) {
d413 1
a413 1
			if ((flags & PO_EXPAND) && c == '\\') {
d421 1
a421 1
						flags &= ~PO_NL;
d425 1
a425 1
						s--;
d445 1
a445 1
		if (*++wp != NULL)
d447 2
d450 1
a450 1
	if (flags & PO_NL)
d453 2
a454 1
	if (flags & PO_HIST) {
d459 2
a460 1
		int len = Xlength(xs, xp);
d470 1
a470 1
			flags |= PO_COPROC;
d473 6
a478 4
		for (s = Xstring(xs, xp); len > 0; ) {
			if ((c = write(fd, s, len)) < 0) {
				if (flags & PO_COPROC)
					restore_pipe(opipe);
d480 3
a482 1
					/* allow user to ^C out */
d484 2
a485 1
					if (flags & PO_COPROC)
d489 2
a490 1
				return (1);
d492 2
a493 2
			s += c;
			len -= c;
d495 1
a495 1
		if (flags & PO_COPROC)
d499 1
a499 1
	return (0);
@


1.291
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVAR→CMDASN
@
text
@d3672 1
a3672 1
	int fd = STDIN_FILENO, rv, eno;
d3676 1
d3698 3
d3707 1
a3707 2
				eno = errno;
				bi_errorf("%s: %s", fn, cstrerror(eno));
d3713 6
a3718 6
			n = blocking_read(fd, (cp = buf), MKSH_CAT_BUFSIZ);
			eno = errno;
			/* give the user a chance to ^C out */
			intrcheck();
			if (n == -1) {
				if (eno == EINTR) {
d3720 1
d3724 1
a3724 1
				bi_errorf("%s: %s", fn, cstrerror(eno));
d3731 17
a3747 8
				w = write(STDOUT_FILENO, cp, n);
				eno = errno;
				/* give the user a chance to ^C out */
				intrcheck();
				if (w == -1) {
					if (eno == EINTR)
						/* interrupted, try again */
						continue;
d3750 1
a3750 1
					    cstrerror(eno));
a3751 3
					if (fd != STDIN_FILENO)
						close(fd);
					goto out;
d3753 3
a3755 2
				n -= w;
				cp += w;
d3763 1
@


1.290
log
@permit 'read -A/-a arr[idx]' as long as only one element is read;
fix corruption of array indicēs with this construct (LP#1533396)
@
text
@d106 1
a106 1
	{"command", c_command},
@


1.289
log
@incorporate suggestions by J�rg Schilling
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.281 2015/08/13 21:04:11 tg Exp $");
d1854 1
a1854 1
	struct tbl *vp /* FU gcc */ = NULL, *vq;
d1861 2
d2107 1
d2116 2
d2119 1
a2119 3
		unset(vp, 1);
		/* counter for array index */
		c = 0;
d2221 12
a2232 1
		vq = arraysearch(vp, c++);
@


1.288
log
@fix regression introduced with test(1) rewrite in R40d:
evaluation errors were not returned any more

Bug spotted and patch by Martijn Dekker <martijn@@inlv.org>
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013, 2014, 2015
a2357 1
	const char *arg;
d2359 6
a2364 3
	if (ksh_getopt(wp, &builtin_opt, null) == '?')
		goto c_exitreturn_err;
	arg = wp[builtin_opt.optind];
a2365 4
	if (arg)
		exstat = bi_getn(arg, &n) ? (n & 0xFF) : 1;
	else if (trap_exstat != -1)
		exstat = trap_exstat;
d2386 1
a2386 1
	/* get rid of any i/o redirections */
d2392 1
@


1.287
log
@fix \u0000 and \x00 being ignored in $'…' and print +r expansion
@
text
@d2859 1
a2859 1
	 * dumb code straight-forward from the 2008 spec, but unless
d2880 2
@


1.286
log
@make “source” into a built-in command (keepasn, to match ksh93 and “dot”);
remove the “stop” alias and drop old Android and OS/2 hacks and auto-unalias
@
text
@d434 2
a435 1
					for (c = 0; ts[c]; ++c)
d437 1
@


1.285
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d130 1
d1790 5
a1794 1
	if ((file = search_path(cp, path, R_OK, &errcode)) == NULL) {
@


1.284
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d1308 2
a1309 1
	return (bg ? 0 : rv);
d1387 7
d1447 2
a1448 1
		ksh_getopt_reset(&user_opt, GF_NONAME | GF_PLUSOPT);
@


1.283
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.35 2015/09/01 13:12:31 tedu Exp $	*/
d9 1
a9 1
 *	mirabilos <tg@@mirbsd.org>
@


1.282
log
@be more careful with signals and errorlevels; bounds-check them better;
don’t trust the OS as POSuX comes up with more-than-8-bit exit codes now;
also, one more int → bool
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.34 2013/12/17 16:37:05 deraadt Exp $	*/
d9 1
a9 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.281
log
@oksh sync: one rcsid-only plus this one by guenther:
Zero-pad the seconds in the output of 'time' to make columns line up
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.271 2015/04/29 20:44:34 tg Exp $");
d1377 1
a1377 1
#if (ksh_NSIG < 128)
d1388 1
a1388 1
			int j = ksh_NSIG;
d2296 1
a2296 1
	int i = ksh_NSIG + 1;
d2311 1
a2311 1
		} while (--i);
@


1.280
log
@harden the crlf vs lf tests even more; use binary mode explicitly on OS/2
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.45 2014/08/27 08:26:04 jmc Exp $	*/
d2545 1
a2545 1
		shf_fprintf(shf, "%s%*ldm%d.%02ds%s", prefix, width,
@


1.279
log
@apply the new cat hack to printf, too, to prefer it over the builtin
@
text
@d3671 1
a3671 1
			else if ((fd = open(fn, O_RDONLY | O_BINARY)) < 0) {
@


1.278
log
@more easy OS/2 fixes

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d155 1
a155 1
	{"printf", c_printf},
@


1.277
log
@• revert the cat hack for realpath and rename
  ‣ I was convinced by several that more magic is never the solution
• fix a comment: function cat already had precedence
• change cat loader to look for existence, FPATH included, before
  ditching the builtin; note that in manpage
@
text
@d164 3
@


1.276
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d102 1
a102 1
	{"cat", c_cat},
@


1.275
log
@fix 'command -v' for "shell reserved words"
From: Martijn Dekker <martijn@@inlv.org>

also adjust manpage accordingly
@
text
@d445 1
a445 1
		histsave(&source->line, Xstring(xs, xp), true, false);
d2079 1
a2079 1
		histsave(&source->line, Xstring(xs, xp), true, false);
@


1.274
log
@simplify print_columns func argument: no need to return the first arg any more
@
text
@d541 1
a541 1
		if ((iam_whence || vflag) && !pflag)
@


1.273
log
@permit read -N n (n ≠ -1) and read -t to return partial reads with $? == 1

issue spotted by carstenh, could have been a documentation ambiguity issue
(as -N was designed to read and return exactly n bytes), but this resolves
it in a way both backwards-compatible and user-pleasing
@
text
@d227 1
a227 1
static char *kill_fmt_entry(char *, size_t, unsigned int, const void *);
d1310 1
a1310 1
static char *
a1319 1
	return (buf);
@


1.272
log
@sometimes, I feel pretty stupid

separate the backslash+newline things out of the *.opt files,
logically not 100% clean, but better as it is not generated
content anyway (keeping the one-liners in there for now, even
though more consistent would be shifting them out as well)
@
text
@d1967 3
a1969 2
			rv = 1;
			goto c_read_out;
d1994 1
d2017 1
a2017 1
			xp = Xstring(xs, xp);
@


1.271
log
@overhaul the signal handling:
• support NSIG_MAX from http://austingroupbugs.net/view.php?id=741
  and make a TODO for later to use sysconf(_SC_NSIG) at runtime
• bounds-check signals (e.g. no smaller than 1, but smaller than NSIG)
• align trap errorlevel with other shells
• make trap match what’s in POSIX and fixup the manpage
• refactor some code related to signals
• hide from kill builtin both EXIT and ERR pseudo-signals
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.266 2015/03/20 21:01:41 tg Exp $");
d3427 11
d3439 9
@


1.270
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d1334 1
a1334 1
		if (!(t = gettrap(p + 1, false))) {
d1348 2
a1349 1
				if (!(t = gettrap(builtin_opt.optarg, true))) {
d1375 2
a1376 2
#if (NSIG < 128)
				if (n > 128 && n < 128 + NSIG)
d1379 1
a1379 1
				if (n > 0 && n < NSIG)
d1385 3
a1387 3
			ssize_t w, mess_cols, mess_octs;
			int j;
			struct kill_info ki;
d1389 1
a1389 1
			for (j = NSIG, ki.num_width = 1; j >= 10; j /= 10)
d1391 3
a1393 2
			ki.name_width = mess_cols = mess_octs = 0;
			for (j = 0; j < NSIG; j++) {
d1405 1
a1405 1
			print_columns(shl_stdout, (unsigned int)(NSIG - 1),
d2291 2
a2292 1
	int i;
a2293 1
	Trap *p;
d2300 2
a2301 2
		for (p = sigtraps, i = NSIG + 1; --i >= 0; p++)
			if (p->trap != NULL) {
d2306 2
d2311 2
a2312 8
	/*
	 * Use case sensitive lookup for first arg so the
	 * command 'exit' isn't confused with the pseudo-signal
	 * 'EXIT'.
	 */
	/* get command */
	s = (gettrap(*wp, false) == NULL) ? *wp++ : NULL;
	if (s != NULL && ksh_isdash(s))
d2314 7
d2322 1
a2322 1
	/* set/clear traps */
d2324 2
a2325 2
	while (*wp != NULL)
		if ((p = gettrap(*wp++, true)) == NULL) {
d2328 1
a2328 1
			++i;
@


1.269
log
@use already-existing ksh_isdash helper macro
@
text
@d1669 5
a1673 2
			for (new_umask = 0; *cp >= '0' && *cp <= '7'; cp++)
				new_umask = new_umask * 8 + (*cp - '0');
@


1.268
log
@a bit review-inspired getn/bi_getn review
@
text
@d2311 1
a2311 1
	if (s != NULL && s[0] == '-' && s[1] == '\0')
d3637 1
a3637 1
			if (fn[0] == '-' && fn[1] == '\0')
@


1.267
log
@fix IFS='\' issues, found by edualbus (Eduardo A. Bustamante López <dualbus@@gmail.com>)
@
text
@d782 1
a782 1
		if (!bi_getn(basestr, &base)) {
d2336 3
a2338 7
	if (arg) {
		if (!getn(arg, &n)) {
			exstat = 1;
			warningf(true, "%s: %s", arg, "bad number");
		} else
			exstat = n & 0xFF;
	} else if (trap_exstat != -1)
@


1.266
log
@fix “read -n-1”, which still returns once the first read() succeeds
(it’s not identical to “read -N-1”!)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.262 2014/12/15 23:18:47 tg Exp $");
d1824 1
a1824 1
	int c, fd = 0, rv = 0, lastparm = 0;
d1827 1
d2131 1
a2131 1
		lastparm = 1;
d2156 1
d2163 6
a2168 2
		Xcheck(xs, xp);
		Xput(xs, xp, ch);
d2171 2
d2183 2
a2184 2
	if (lastparm && bytesread) {
		++lastparm;
d2188 1
a2188 1
	if (lastparm < 2)
@


1.265
log
@remove some unused string pooling stuff
@
text
@d1862 1
a1862 1
			readmode = READALL;
@


1.264
log
@better
@
text
@d141 1
a141 1
	{Tsgunset, c_unset},
@


1.263
log
@fix mksh regression: empty line after “whence -v” with not found
spotted by Ypnose via IRC
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013, 2014
d553 1
a553 1
		if (vflag)
d562 9
d575 1
a575 1
				shf_puts(" reserved word", shl_stdout);
d602 5
a606 4
			if (vflag)
				shprintf("%s %s %s",
				    (tp->flag & SPEC_BI) ? " special" : null,
				    "shell", Tbuiltin);
a609 2
			if (vflag)
				shf_putc(' ', shl_stdout);
d627 1
a627 1
			shprintf("%s is *GOK*", id);
@


1.262
log
@OpenBSD RCSID merge, and logical follow one change:
handle unknown bases as ksh93 does: larger downgrade to 10
(although our max will stay 36, as ksh93 doesn’t have upper/lowecase)
and smaller downgrade for typeset -i, but not for arithmetics
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.260 2014/11/25 20:00:37 tg Exp $");
d600 2
d604 1
a604 1
					shf_puts(" is ", shl_stdout);
d614 1
a614 1
					shprintf(" %s\n", "not found");
@


1.261
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d771 7
a777 3
	if (basestr && (!bi_getn(basestr, &base) || base < 1 || base > 36)) {
		bi_errorf("%s: %s", "bad integer base", basestr);
		return (1);
@


1.260
log
@stop using ptrdiff_t
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259 2014/10/12 21:58:51 tg Exp $");
a2799 2
	mkssert(argc > 0);
	mkssert(wp[0] != NULL);
@


1.259
log
@POSIX says “command” loses SPEC_BI and means it too

reported by ormaaj, who even asked on the austin ML
http://thread.gmane.org/gmane.comp.standards.posix.austin.general/9907/focus=9931
clarified by jilles; also make errorlevels match ksh93
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.258 2014/09/03 19:55:51 tg Exp $");
d1820 1
a1820 1
	ptrdiff_t xsave = 0;
@


1.259.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013, 2014, 2015
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259 2014/10/12 21:58:51 tg Exp $");
d553 1
a553 1
		if (vflag) {
a561 9
			switch (tp->type) {
			case CKEYWD:
			case CSHELL:
			case CTALIAS:
			case CEXEC:
				shf_putc(' ', shl_stdout);
				break;
			}
		}
d566 1
a566 1
				shf_puts("reserved word", shl_stdout);
d593 4
a596 5
			if (vflag) {
				if (tp->flag & SPEC_BI)
					shf_puts("special ", shl_stdout);
				shprintf("%s %s", "shell", Tbuiltin);
			}
d602 1
a602 1
					shf_puts("is ", shl_stdout);
d612 1
a612 1
					shf_puts("not found", shl_stdout);
d617 1
a617 1
			shf_puts(" is *GOK*", shl_stdout);
@


1.259.2.2
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259.2.1 2015/01/11 22:39:49 tg Exp $");
d1830 1
a1830 1
	size_t xsave = 0;
d2810 2
@


1.259.2.3
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259.2.2 2015/01/25 15:35:44 tg Exp $");
d1858 1
a1858 1
			readmode = readmode == BYTES ? READALL : UPTO;
@


1.259.2.4
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259.2.3 2015/03/20 22:21:01 tg Exp $");
d1820 1
a1820 1
	int c, fd = 0, rv = 0;
a1822 1
	bool lastparmmode = false, lastparmused = false;
d2126 1
a2126 1
		lastparmmode = true;
a2150 1
	expanding = false;
d2157 2
a2158 6
		if (lastparmmode && !expanding && !rawmode && ch == '\\') {
			expanding = true;
		} else {
			Xcheck(xs, xp);
			Xput(xs, xp, ch);
		}
a2160 2
		if (expanding)
			continue;
d2171 2
a2172 2
	if (lastparmmode && bytesread) {
		lastparmused = true;
d2176 1
a2176 1
	if (!lastparmused)
@


1.259.2.5
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.259.2.4 2015/04/12 22:32:26 tg Exp $");
d781 1
a781 1
	if (basestr && (!getn(basestr, &base) || base < 1 || base > 36)) {
d2332 7
a2338 3
	if (arg)
		exstat = bi_getn(arg, &n) ? (n & 0xFF) : 1;
	else if (trap_exstat != -1)
@


1.258
log
@mksh R50b
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.257 2014/07/28 21:45:44 tg Exp $");
d1590 1
a1590 4
	if (arg) {
		evaluate(arg, &val, KSH_UNWIND_ERROR, false);
		n = val;
	} else
d1592 8
a1599 1
	if (n < 0) {
d2424 2
a2425 3
	argi = parse_args(wp, OF_SET, &setargs);
	if (argi < 0)
		return (1);
@


1.257
log
@https://android-review.googlesource.com/102253

• permit interrupts during a write(2) loop in the cat builtin, too,
  not just in the read(2) loop – fixes inability to kill a clogged
  output cat

• kill the cat when smores finish

TODO: revisit this ⓐ in more depth, ⓑ for other functions, such as
      “hd”, and ⓒ test on AOSP as well
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.44 2013/09/04 15:49:18 millert Exp $	*/
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.256 2014/06/09 13:25:52 tg Exp $");
@


1.256
log
@fix some of the signal stuff (still didn’t get rid of awk(1) and printf(1)
calls in Build.sh, we need HOSTCC for that… which we should do, using BER
or something encoded for integers, and pregenerated hashtables as planned)

also, bump to R50 beta, due to today’s language changes
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.254 2014/01/05 19:20:31 tg Exp $");
d3646 3
d3650 1
a3650 1
					if (errno == EINTR)
a3653 1
					eno = errno;
@


1.255
log
@fix LP#1277691 (“nameref RHS not syntax checked”) and the inability to
use errorf() while nameref states were being changed (by almost completely
eliminating the global variable) and the readonly first array variable
bypass (typo/refactoro); also, whitespace, one int → bool, and add a
comment wrt. the parser rewrite talked about with igli during a fever ;)
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013
d1360 1
d1363 1
@


1.254
log
@revert unfinished change (listed in mksh.hts)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.252 2013/11/30 17:41:34 tg Exp $");
d651 1
d732 1
a732 1
			set_refflag = (builtin_opt.info & GI_PLUS) ?
a755 2
 errout:
			set_refflag = SRF_NOP;
d770 1
a770 1
		goto errout;
d773 1
a773 1
		goto errout;
d785 1
a785 1
	    set_refflag != SRF_NOP)) {
d787 1
a787 1
		goto errout;
d811 1
a811 1
		    INTEGER | INT_U | INT_L)) || set_refflag != SRF_NOP)
d815 8
d853 1
a853 1
				goto errout;
a855 1
		set_refflag = SRF_NOP;
a858 1
	set_refflag = SRF_NOP;
@


1.253
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@a3252 1
/*XXX TODO: !test_opin(b_ops_xsi, … */
@


1.252
log
@detect getsid(2), also spotted by RT, this on MSYS
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.33 2009/02/07 14:03:24 kili Exp $	*/
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.251 2013/11/30 17:33:49 tg Exp $");
@


1.251
log
@RCSID-only oksh sync (their whitespace changes don’t apply to us)
note that emacs.c partial peereboom rewrite is *not* merged, and kept that way
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.250 2013/11/17 22:21:17 tg Exp $");
d63 1
a63 1
#ifndef MKSH_UNEMPLOYED
d130 1
a130 1
#ifndef MKSH_UNEMPLOYED
d3722 1
a3722 1
#ifndef MKSH_UNEMPLOYED
@


1.250
log
@more clueful (automatic) getopt string generation
@
text
@d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.18 2013/11/14 15:23:30 espie Exp $	*/
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.246 2013/09/10 17:33:00 tg Exp $");
@


1.249
log
@drop RLIMIT_LOCKS completely, it was for early Linux 2.4 versions only
@
text
@a3343 10
struct limits {
	const char *name;
	int resource;		/* resource to get/set */
	unsigned int factor;	/* multiply by to get rlim_{cur,max} values */
	char option;
};

static void print_ulimit(const struct limits *, int);
static int set_ulimit(const struct limits *, const char *, int);

d3386 23
d3413 1
a3413 144
	static const struct limits limits[] = {
		/* do not use options -H, -S or -a or change the order */
#ifdef RLIMIT_CPU
		{ "time(cpu-seconds)", RLIMIT_CPU, 1, 't' },
#endif
#ifdef RLIMIT_FSIZE
		{ "file(blocks)", RLIMIT_FSIZE, 512, 'f' },
#endif
#ifdef RLIMIT_CORE
		{ "coredump(blocks)", RLIMIT_CORE, 512, 'c' },
#endif
#ifdef RLIMIT_DATA
		{ "data(KiB)", RLIMIT_DATA, 1024, 'd' },
#endif
#ifdef RLIMIT_STACK
		{ "stack(KiB)", RLIMIT_STACK, 1024, 's' },
#endif
#ifdef RLIMIT_MEMLOCK
		{ "lockedmem(KiB)", RLIMIT_MEMLOCK, 1024, 'l' },
#endif
#ifdef RLIMIT_NOFILE
		{ "nofiles(descriptors)", RLIMIT_NOFILE, 1, 'n' },
#endif
#ifdef RLIMIT_NPROC
		{ "processes", RLIMIT_NPROC, 1, 'p' },
#endif
#ifdef RLIMIT_SWAP
		{ "swap(KiB)", RLIMIT_SWAP, 1024, 'w' },
#endif
#ifdef RLIMIT_TIME
		{ "humantime(seconds)", RLIMIT_TIME, 1, 'T' },
#endif
#ifdef RLIMIT_NOVMON
		{ "vnodemonitors", RLIMIT_NOVMON, 1, 'V' },
#endif
#ifdef RLIMIT_SIGPENDING
		{ "sigpending", RLIMIT_SIGPENDING, 1, 'i' },
#endif
#ifdef RLIMIT_MSGQUEUE
		{ "msgqueue(bytes)", RLIMIT_MSGQUEUE, 1, 'q' },
#endif
#ifdef RLIMIT_AIO_MEM
		{ "AIOlockedmem(KiB)", RLIMIT_AIO_MEM, 1024, 'M' },
#endif
#ifdef RLIMIT_AIO_OPS
		{ "AIOoperations", RLIMIT_AIO_OPS, 1, 'O' },
#endif
#ifdef RLIMIT_TCACHE
		{ "cachedthreads", RLIMIT_TCACHE, 1, 'C' },
#endif
#ifdef RLIMIT_SBSIZE
		{ "sockbufsiz(KiB)", RLIMIT_SBSIZE, 1024, 'B' },
#endif
#ifdef RLIMIT_PTHREAD
		{ "threadsperprocess", RLIMIT_PTHREAD, 1, 'P' },
#endif
#ifdef RLIMIT_NICE
		{ "maxnice", RLIMIT_NICE, 1, 'e' },
#endif
#ifdef RLIMIT_RTPRIO
		{ "maxrtprio", RLIMIT_RTPRIO, 1, 'r' },
#endif
#if defined(ULIMIT_M_IS_RSS)
		{ "resident-set(KiB)", RLIMIT_RSS, 1024, 'm' },
#elif defined(ULIMIT_M_IS_VMEM)
		{ "memory(KiB)", RLIMIT_VMEM, 1024, 'm' },
#endif
#if defined(ULIMIT_V_IS_VMEM)
		{ "virtual-memory(KiB)", RLIMIT_VMEM, 1024, 'v' },
#elif defined(ULIMIT_V_IS_AS)
		{ "address-space(KiB)", RLIMIT_AS, 1024, 'v' },
#endif
		{ NULL, 0, 0, 0 }
	};
	static const char opts[] = "a"
#ifdef RLIMIT_SBSIZE
	    "B"
#endif
#ifdef RLIMIT_TCACHE
	    "C"
#endif
#ifdef RLIMIT_CORE
	    "c"
#endif
#ifdef RLIMIT_DATA
	    "d"
#endif
#ifdef RLIMIT_NICE
	    "e"
#endif
#ifdef RLIMIT_FSIZE
	    "f"
#endif
	    "H"
#ifdef RLIMIT_SIGPENDING
	    "i"
#endif
#ifdef RLIMIT_MEMLOCK
	    "l"
#endif
#ifdef RLIMIT_AIO_MEM
	    "M"
#endif
#if defined(ULIMIT_M_IS_RSS) || defined(ULIMIT_M_IS_VMEM)
	    "m"
#endif
#ifdef RLIMIT_NOFILE
	    "n"
#endif
#ifdef RLIMIT_AIO_OPS
	    "O"
#endif
#ifdef RLIMIT_PTHREAD
	    "P"
#endif
#ifdef RLIMIT_NPROC
	    "p"
#endif
#ifdef RLIMIT_MSGQUEUE
	    "q"
#endif
#ifdef RLIMIT_RTPRIO
	    "r"
#endif
	    "S"
#ifdef RLIMIT_STACK
	    "s"
#endif
#ifdef RLIMIT_TIME
	    "T"
#endif
#ifdef RLIMIT_CPU
	    "t"
#endif
#ifdef RLIMIT_NOVMON
	    "V"
#endif
#if defined(ULIMIT_V_IS_VMEM) || defined(ULIMIT_V_IS_AS)
	    "v"
#endif
#ifdef RLIMIT_SWAP
	    "w"
#endif
	    ;
a3415 1
	const struct limits *l;
d3417 1
a3417 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1)
d3429 1
a3429 1
			bi_errorf("usage: ulimit [-%s] [value]", opts);
d3435 4
a3438 5
	for (l = limits; l->name && l->option != what; l++)
		;
	if (!l->name) {
		internal_warningf("ulimit: %c", what);
		return (1);
d3440 3
a3442 1

d3448 1
a3448 1
		return (set_ulimit(l, wp[builtin_opt.optind], how));
d3451 4
a3454 4
		print_ulimit(l, how);
	else for (l = limits; l->name; l++) {
		shprintf("%-20s ", l->name);
		print_ulimit(l, how);
@


1.248
log
@oksh sync (RCSID only)
@
text
@a3428 3
#ifdef RLIMIT_LOCKS
		{ "flocks", RLIMIT_LOCKS, -1, 'L' },
#endif
a3496 3
#ifdef RLIMIT_LOCKS
	    "L"
#endif
d3616 5
a3620 1
		/* some can't be read, e.g. Linux RLIMIT_LOCKS */
@


1.247
log
@add O_BINARY to all open() calls except tty_fd
cf. http://svn.netlabs.org/libc/wiki/Faq#Whydoesntreadfdbufsize_of_filereturnsize_of_file
@
text
@d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.17 2008/03/21 12:51:19 millert Exp $	*/
@


1.246
log
@integrate latest changes from oksh: Wed Sep 4 15:49:19 2013 UTC by millert

Add a proper suspend builtin that saves/restores the tty and pgrp
as needed instead of an alias that just sends SIGSTOP.  Login shells
may be suspended if they are not running in an orphan process group.
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.242 2013/04/26 21:22:45 tg Exp $");
d3746 1
a3746 1
			else if ((fd = open(fn, O_RDONLY)) < 0) {
@


1.245
log
@int → bool; commit as a TODO comment a begun change attempt
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.43 2013/04/19 17:39:45 deraadt Exp $	*/
d63 4
d130 3
d3853 21
@


1.244
log
@use ‘z’ shf printf modifier for out-of-memory message, now that we have it
@
text
@d3246 1
@


1.243
log
@• Allow setting both -o posix and -o sh (although only in the same
  command; setting one still unsets the other at first)
• Change subst_exstat to be conformant unless -o sh is set and -o posix isn’t
• In lksh, make subst_exstat (newly) conformant if -o posix
• New MKSH_BINSHPOSIX to accompany MKSH_BINSHREDUCED
• Sync lksh manpage precisely
@
text
@d3729 1
a3729 1
		bi_errorf(Toomem, (unsigned long)MKSH_CAT_BUFSIZ);
@


1.242
log
@Oh well… this looks well, is done done, and gcc-snapshot doesn’t complain:
• correct order of built-in commands; use POSIX special versus “all others”
  plus “keeps assignments” as distinction, no longer play POSIX regular vs.
  others game; sync manpage
• fix LP#1156707: map (( internally to “let]” which is no valid function
  name and so can’t be overridden but is unlikely to be used otherwhere
  and not strictly permitted (by POSIX) anyway
• we do not need -Wno-overflow any more, either
• bump to R45
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.241 2013/04/26 17:39:28 tg Exp $");
a2428 1
	 * Switched ksh (!posix !sh) to POSIX in mksh R39b.
d2431 2
a2432 1
	return (subst_exstat);
d2434 2
a2435 1
	return (Flag(FSH) ? subst_exstat : 0);
@


1.241
log
@rcsid-only sync with oksh, dropping this functionality:
• mail.c was removed anyway
• we do not use “long long” in mksh, since it’s not in ANSI C89

instead, we probably need some 64-bit ops in the long run, but we can
use some host types (might want to use time_t for tv_sec, but we cannot
print that yet); might need to handle them in some generic manner…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.240 2013/03/30 15:39:36 tg Exp $");
d87 2
a88 4
 * A leading = means assignments before command are kept;
 * a leading * means a POSIX special builtin;
 * a leading + means a POSIX regular builtin
 * (* and + should not be combined).
d94 2
d98 5
d104 1
a107 20
	{"+false", c_false},
	{"*=return", c_exitreturn},
	{Tsgset, c_set},
	{"*=shift", c_shift},
	{"=times", c_times},
	{"*=trap", c_trap},
	{"+=wait", c_wait},
	{"+read", c_read},
	{"test", c_test},
	{"+true", c_true},
	{"ulimit", c_ulimit},
	{"+umask", c_umask},
	{Tsgunset, c_unset},
	/* no =: AT&T manual wrong */
	{Tpalias, c_alias},
	{"+cd", c_cd},
	/* dash compatibility hack */
	{"chdir", c_cd},
	{"+command", c_command},
	{"echo", c_print},
d109 3
a111 2
	{"+fc", c_fc},
	{"+getopts", c_getopts},
d113 2
a114 2
	{"+jobs", c_jobs},
	{"+kill", c_kill},
d116 1
a117 3
#ifdef MKSH_PRINTF_BUILTIN
	{"printf", c_printf},
#endif
d119 1
d121 9
d131 5
a135 1
	{Tpunalias, c_unalias},
d138 2
a139 2
	{"+bg", c_fgbg},
	{"+fg", c_fgbg},
a143 1
	{"cat", c_cat},
d147 3
a149 2
	{"realpath", c_realpath},
	{"rename", c_rename},
@


1.240
log
@use nicer (and same as in other places!) error message for typeset
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.42 2013/03/20 21:05:00 millert Exp $	*/
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.239 2013/03/24 21:34:13 tg Exp $");
@


1.239
log
@RCSID sync w/ oksh; whitespace (KNF)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.238 2013/02/18 22:47:32 tg Exp $");
d839 1
a839 1
				bi_errorf("%s: %s", wp[i], "not identifier");
@


1.238
log
@another MidnightBSD /bin/sh kludge: classic BSD echo
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.41 2010/03/27 09:10:01 jmc Exp $	*/
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.237 2013/01/01 20:45:02 tg Exp $");
d2256 1
a2256 1
		for (p = sigtraps, i = NSIG+1; --i >= 0; p++)
@


1.237
log
@fix running the ERR and EXIT traps in case of set -e and/or eval (includes Debian #696823)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.236 2012/12/28 02:28:34 tg Exp $");
d277 1
a277 1
	int flags = PO_EXPAND|PO_NL;
d285 15
a299 1
		if (Flag(FPOSIX) || Flag(FSH) || Flag(FAS_BUILTIN)) {
@


1.236
log
@harmonise sys_{sig,err}list ⓐ checks, ⓑ uses, ⓒ _decl values when not needed, ⓓ prototypes; ⓔ “const” is a keyword and thus space-separated from the preceding ‘*’ pointer indicator
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.235 2012/12/17 23:18:04 tg Exp $");
d2219 1
a2219 1
	Flag(FERREXIT) = 0;
@


1.235
log
@thanks to ISC (Interactive) Unix, we now know a few samples of errnos
that get used, plus one for the realpath-1 regression test; also make
sys_siglist_decl detection nicer and poison strerror() with non-const
return value ifdef DEBUG, make it always const
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.233 2012/12/08 18:30:30 tg Exp $");
d3275 1
a3275 1
	static const char *const tokens[] = {
@


1.234
log
@__CRAZY=Yes clean wants switch(enum) to be complete
@
text
@d256 1
a256 1
		    strerror(errno));
d1382 1
a1382 1
				bi_errorf("%s: %s", p, strerror(errno));
d1729 1
a1729 1
		bi_errorf("%s: %s", cp, strerror(errcode));
d1746 1
a1746 1
		bi_errorf("%s: %s", cp, strerror(errno));
d1837 1
a1837 1
			bi_errorf("%s: %s '%s'", Tsynerr, strerror(errno),
d1919 1
a1919 1
			bi_errorf("%s: %s", Tselect, strerror(errno));
d2713 1
a2713 1
		bi_errorf("%s: %s", argv[0], strerror(errno));
d3613 1
a3613 1
		bi_errorf("bad %s limit: %s", l->name, strerror(errno));
d3656 1
a3656 1
		bi_errorf("%s: %s", "failed", strerror(rv));
d3679 1
a3679 1
		bi_errorf("%s: %s", wp[0], strerror(rv));
d3726 1
a3726 1
				bi_errorf("%s: %s", fn, strerror(eno));
d3742 1
a3742 1
				bi_errorf("%s: %s", fn, strerror(eno));
d3757 1
a3757 1
					    strerror(eno));
d3792 1
a3792 1
		bi_errorf("%s: %s '%s'", Tsynerr, strerror(errno), wp[0]);
d3822 1
a3822 1
			bi_errorf("%s: %s", Tselect, strerror(errno));
@


1.233
log
@add a few assertions for LLVM+Clang 3.2 scan-build; no !DEBUG changes
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.232 2012/12/04 01:18:28 tg Exp $");
d2922 3
@


1.232
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.231 2012/12/01 01:36:23 tg Exp $");
d2900 25
@


1.231
log
@remove *all* nonnull assertions and other workarounds for clang scan-build

this beast evolved in the last 2½ years, and we’ve had trouble with
some of them earlier
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.230 2012/10/30 20:13:18 tg Exp $");
a854 2
			if (!vp)
				continue;
d884 3
d2769 2
@


1.230
log
@int → bool
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.228 2012/10/21 21:55:03 tg Exp $");
d223 1
a223 2
    const char *, const char *)
    MKSH_A_NONNULL((__nonnull__ (6, 7)));
@


1.230.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.230 2012/10/30 20:13:18 tg Exp $");
d223 2
a224 1
    const char *, const char *);
d856 2
a886 3
	if (!vp)
		return;

a2768 2
	mkssert(argc > 0);
	mkssert(wp[0] != NULL);
@


1.230.2.2
log
@MFC all bugfixes and most portability fixes (but not changes / new targets)
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.230.2.1 2012/12/04 01:26:23 tg Exp $");
d2219 1
a2219 1
	Flag(FERREXIT) |= 0x80;
@


1.230.2.3
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.230.2.2 2013/01/01 21:20:04 tg Exp $");
d2769 2
@


1.229
log
@while we do not condone killing of cats, fix LP#1058815
@
text
@d1744 1
a1744 1
	if ((i = include(file, argc, argv, 0)) < 0) {
@


1.228
log
@defer setting exstat for eval to 0 (the one used in case shell() is empty)
until after the stuff run in shell() has had a chance to toy with $?

bug forwarded by one of our packagers, found by one of their users
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.227 2012/10/21 21:39:02 tg Exp $");
d3664 1
a3664 1
	int fd = STDIN_FILENO, rv;
d3695 2
a3696 2
				rv = errno;
				bi_errorf("%s: %s", fn, strerror(rv));
d3703 3
d3707 1
a3707 3
				if (errno == EINTR) {
					/* give the user a chance to ^C out */
					intrcheck();
d3712 1
a3712 2
				rv = errno;
				bi_errorf("%s: %s", fn, strerror(rv));
d3725 1
a3725 1
					rv = errno;
d3727 1
a3727 1
					    strerror(rv));
@


1.227
log
@add some bounds, for a subsequent commit:
• all writers of exstat ensure the value is in [0; 0xFF]
• all readers of exstat AND it with 0xFF (not strictly needed thus)
• trap_exstat is “safe”, i.e. always either -1 or [0; 0xFF]
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.226 2012/10/03 17:24:19 tg Exp $");
d2213 4
a2216 2
	/* exstat = subst_exstat; */	/* AT&T ksh88 */
	exstat = 0;			/* SUSv4 */
d2224 3
@


1.226
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.225 2012/10/03 16:16:12 tg Exp $");
d2283 1
a2283 1
			exstat = n;
@


1.225
log
@rewrite some code to avoid gcc 4.8 complaining
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.224 2012/10/03 15:13:31 tg Exp $");
d1902 1
a1902 1
		FD_SET(fd, &fdset);
d2318 2
a2319 1
	int n, quit;
d2336 1
a2336 1
	quit = n;
d2353 1
a2353 1
		if (n == quit) {
d2364 2
a2365 2
		warningf(true, "%s: can only %s %d level(s)",
		    wp[0], wp[0], n - quit);
@


1.224
log
@repair choiceless select builtin
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.223 2012/08/03 18:30:13 tg Exp $");
d979 3
a981 1
	} while (any_set && (vp = vp->u.array));
@


1.223
log
@ulimit: precompute option string for getopt and usage; noticed by bsiegert@@
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.222 2012/06/25 16:34:58 tg Exp $");
d221 1
a221 1
static char *kill_fmt_entry(char *, size_t, int, const void *);
d1270 1
a1270 1
kill_fmt_entry(char *buf, size_t buflen, int i, const void *arg)
d1275 1
a1275 1
	shf_snprintf(buf, buflen, "%*d %*s %s",
d1360 1
a1360 1
			print_columns(shl_stdout, NSIG - 1,
@


1.222
log
@fix two inverse logic mistakes (I’m apparently r̲e̲a̲l̲l̲y̲ fond of them… ☹)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.221 2012/06/25 16:17:54 tg Exp $");
d3417 73
a3489 1
	static char opts[3 + NELEM(limits)];
a3493 10
	if (!opts[0]) {
		/* build options string on first call - yuck */
		char *p = opts;

		*p++ = 'H'; *p++ = 'S'; *p++ = 'a';
		for (l = limits; l->name; l++)
			*p++ = l->option;
		*p = '\0';
	}

d3506 1
a3506 2
			bi_errorf("%s: %s", "usage",
			    "ulimit [-acdfHLlmnpSsTtvw] [value]");
@


1.222.2.1
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012, 2013
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.222 2012/06/25 16:34:58 tg Exp $");
d2211 2
a2212 4
	/* AT&T ksh88: use subst_exstat */
	/* exstat = subst_exstat; */
	/* SUSv4: OR with a high value never written otherwise */
	exstat |= 0x4000;
d2215 1
a2215 1
	Flag(FERREXIT) |= 0x80;
a2219 3
	if (exstat & 0x4000)
		/* detect old exstat, use 0 in that case */
		rv = 0;
d2281 1
a2281 1
			exstat = n & 0xFF;
@


1.221
log
@first LEGACY changes: keep filedescriptors always open; revert to historic ‘set -- $(getopt …)’ behaviour
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.220 2012/06/24 20:00:51 tg Exp $");
d2619 1
a2619 1
#ifdef MKSH_LEGACY_MODE
@


1.220
log
@CID 703484: resource leak in error path
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.219 2012/05/09 23:20:56 tg Exp $");
d2410 3
d2414 1
d2619 1
d2627 1
@


1.219
log
@Fix typeset issues (LP: #993847)

This was actually more evil:
• use a recursive function to display blocks in reverse order,
  so that local variable values overwrite global ones
• add array support to typeset -p (from typeset -p -)
• display 'set -A varname' line before setting values, for -p
• if -p got arguments, only display those (from the innermost scope)

Also, the usual amount of code cleanup…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.218 2012/05/04 22:18:24 tg Exp $");
a3594 5
	if ((buf = malloc_osfunc(MKSH_CAT_BUFSIZ)) == NULL) {
		bi_errorf(Toomem, (unsigned long)MKSH_CAT_BUFSIZ);
		return (1);
	}

d3609 5
@


1.218
log
@last parts of Coherent patchkit: O_ACCMODE and termio
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.217 2012/05/04 22:05:00 tg Exp $");
d114 1
a114 1
	{"*=unset", c_unset},
d122 1
a122 1
	{"*=export", c_typeset},
d134 1
a134 1
	{"*=readonly", c_typeset},
d619 3
a624 1
	struct block *l;
d627 2
a628 1
	int thing = 0, field = 0, base = 0, optc;
d671 1
a671 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1) {
d673 1
a673 1
		switch (optc) {
d799 4
a802 2
	if (wp[builtin_opt.optind]) {
		int i, rv = 0;
d834 1
d853 43
a895 14
	} else {
		for (l = e->loc; l; l = l->next) {
			for (p = ktsort(&l->vars); (vp = *p++); ) {
				struct tbl *tvp;
				bool any_set = false;
				/*
				 * See if the parameter is set (for arrays, if any
				 * element is set).
				 */
				for (tvp = vp; tvp; tvp = tvp->u.array)
					if (tvp->flag & ISSET) {
						any_set = true;
						break;
					}
d897 29
a925 111
				/*
				 * Check attributes - note that all array elements
				 * have (should have?) the same attributes, so checking
				 * the first is sufficient.
				 *
				 * Report an unset param only if the user has
				 * explicitly given it some attribute (like export);
				 * otherwise, after "echo $FOO", we would report FOO...
				 */
				if (!any_set && !(vp->flag & USERATTRIB))
					continue;
				if (flag && (vp->flag & flag) == 0)
					continue;
				for (; vp; vp = vp->u.array) {
					/*
					 * Ignore array elements that aren't
					 * set unless there are no set elements,
					 * in which case the first is reported on
					 */
					if ((vp->flag&ARRAY) && any_set &&
					    !(vp->flag & ISSET))
						continue;
					/* no arguments */
					if (thing == 0 && flag == 0) {
						/*
						 * AT&T ksh prints things
						 * like export, integer,
						 * leftadj, zerofill, etc.,
						 * but POSIX says must
						 * be suitable for re-entry...
						 */
						shf_puts("typeset ", shl_stdout);
						if (((vp->flag&(ARRAY|ASSOC))==ASSOC))
							shprintf("%s ", "-n");
						if ((vp->flag&INTEGER))
							shprintf("%s ", "-i");
						if ((vp->flag&EXPORT))
							shprintf("%s ", "-x");
						if ((vp->flag&RDONLY))
							shprintf("%s ", "-r");
						if ((vp->flag&TRACE))
							shprintf("%s ", "-t");
						if ((vp->flag&LJUST))
							shprintf("-L%d ", vp->u2.field);
						if ((vp->flag&RJUST))
							shprintf("-R%d ", vp->u2.field);
						if ((vp->flag&ZEROFIL))
							shprintf("%s ", "-Z");
						if ((vp->flag&LCASEV))
							shprintf("%s ", "-l");
						if ((vp->flag&UCASEV_AL))
							shprintf("%s ", "-u");
						if ((vp->flag&INT_U))
							shprintf("%s ", "-U");
						shf_puts(vp->name, shl_stdout);
						if (pflag) {
							char *s = str_val(vp);

							shf_putc('=', shl_stdout);
							/*
							 * AT&T ksh can't have
							 * justified integers...
							 */
							if ((vp->flag &
							    (INTEGER|LJUST|RJUST)) ==
							    INTEGER)
								shf_puts(s, shl_stdout);
							else
								print_value_quoted(shl_stdout, s);
						}
						shf_putc('\n', shl_stdout);
						if (vp->flag & ARRAY)
							break;
					} else {
						if (pflag)
							shf_puts(istset ?
							    "typeset " :
							    (flag & EXPORT) ?
							    "export " :
							    "readonly ",
							    shl_stdout);
						if ((vp->flag&ARRAY) && any_set)
							shprintf("%s[%lu]",
							    vp->name,
							    arrayindex(vp));
						else
							shf_puts(vp->name, shl_stdout);
						if (thing == '-' && (vp->flag&ISSET)) {
							char *s = str_val(vp);

							shf_putc('=', shl_stdout);
							/*
							 * AT&T ksh can't have
							 * justified integers...
							 */
							if ((vp->flag &
							    (INTEGER|LJUST|RJUST)) ==
							    INTEGER)
								shf_puts(s, shl_stdout);
							else
								print_value_quoted(shl_stdout, s);
						}
						shf_putc('\n', shl_stdout);
					}
					/*
					 * Only report first 'element' of an array with
					 * no set elements.
					 */
					if (!any_set)
						break;
				}
d927 31
d959 21
a979 3
	}
	set_refflag = SRF_NOP;
	return (0);
@


1.217
log
@more symlink(7) nonexistence support code
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.216 2012/05/04 21:47:01 tg Exp $");
d1786 1
a1786 1
	struct termios tios;
d2163 1
a2163 1
		tcsetattr(fd, TCSADRAIN, &tios);
@


1.216
log
@provide for Coherent not having gettimeofday(2), imake style (bad, but this is not for others to use without a second thought anyway)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.215 2012/05/04 21:15:32 tg Exp $");
d2946 3
d2950 1
@


1.215
log
@more int→bool while trying to let ^D output CR+LF (which shan’t be, oh my…)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.214 2012/05/04 20:49:03 tg Exp $");
d1887 1
a1887 1
		gettimeofday(&tvlim, NULL);
d1899 1
a1899 1
		gettimeofday(&tv, NULL);
d2507 1
a2507 1
	gettimeofday(&tv0, NULL);
d2524 1
a2524 1
		gettimeofday(&tv1, NULL);
@


1.214
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.213 2012/05/04 20:08:24 tg Exp $");
d2298 1
a2298 1
		really_exit = 1;
@


1.213
log
@move bi_getn from misc.c to funcs.c and make it static

even antique gcc versions will usually inline it now
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.212 2012/04/06 13:28:59 tg Exp $");
d142 1
d144 1
d1486 1
d1545 1
@


1.212
log
@drop str{,n}casecmp, too
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.211 2012/03/29 19:22:58 tg Exp $");
d63 11
@


1.211
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.210 2012/03/26 21:10:42 tg Exp $");
d1278 1
a1278 1
		if (!(t = gettrap(p + 1, true))) {
@


1.210
log
@Susv3mon says: rlim_t are unsigned
@
text
@d8 1
a8 1
 *		 2010, 2011
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.209 2012/03/24 18:47:04 tg Exp $");
d2256 1
a2256 1
		return (1);
d2291 3
d2304 1
a2304 1
		return (1);
d2310 2
a2311 3
		return (1);
	quit = n;
	if (quit <= 0) {
d2314 1
a2314 1
		return (1);
d2316 1
d2350 3
d2983 1
a2983 1
		return (stat(opnd1, &b1) == 0 && b1.st_size > 0L);
@


1.209
log
@block things like SIGWINCH¹ during builtin sleep, they get rescheduled
on unblock just fine and hurt since they interrupt select(2)

① and² SIGPIPE, SIGINFO, SIGUSR{1,2} in addition to already blocked SIGCHLD
② exact list open for suggestions – I’ve got no idea what I’m doing…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.208 2012/03/03 19:28:45 tg Exp $");
d3254 1
a3254 1
	int factor;		/* multiply by to get rlim_{cur,max} values */
d3450 1
a3450 1
		mksh_ari_t rval;
d3452 1
a3452 1
		if (!evaluate(v, &rval, KSH_RETURN_ERROR, false))
d3502 1
a3502 1
		shprintf("%ld\n", (long)(val / l->factor));
@


1.208
log
@drop Android-specific lsmod builtin (for now), they don’t use it anyway
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.207 2012/01/29 01:41:13 tg Exp $");
d3663 1
a3663 1
		sigset_t omask;
d3665 17
a3681 2
		/* block SIGCHLD from interrupting us, though */
		sigprocmask(SIG_BLOCK, &sm_sigchld, &omask);
d3692 1
@


1.207
log
@reduce stack usage a bit (several candidates for more, including $CC itself…)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.206 2011/12/29 22:54:19 tg Exp $");
a62 4
#if defined(ANDROID)
static int c_android_lsmod(const char **);
#endif

a144 3
#if defined(ANDROID)
	{"lsmod", c_android_lsmod},
#endif
a3682 11

#if defined(ANDROID)
static int
c_android_lsmod(const char **wp MKSH_A_UNUSED)
{
	const char *cwp[3] = { "cat", "/proc/modules", NULL };

	builtin_argv0 = cwp[0];
	return (c_cat(cwp));
}
#endif
@


1.206
log
@give dumptree an dumpioact helper
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.205 2011/12/16 20:03:26 tg Exp $");
d1762 1
a1766 1
	static char REPLY[] = "REPLY";
@


1.205
log
@use sane spelling of read-only consistently
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.204 2011/12/09 20:40:25 tg Exp $");
d550 1
a550 1
			print_value_quoted(tp->val.s);
d924 1
a924 1
								print_value_quoted(s);
d956 1
a956 1
								print_value_quoted(s);
d1056 1
a1056 1
					print_value_quoted(ap->val.s);
d1081 1
a1081 1
					print_value_quoted(ap->val.s);
d2228 1
a2228 1
				print_value_quoted(p->trap);
@


1.204
log
@actually catch out of [1;36] bounds integer bases
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.202 2011/12/02 23:05:18 tg Exp $");
d2024 1
a2024 1
			bi_errorf("%s: %s", *wp, "is read only");
d2437 1
a2437 2
				warningf(true, "%s: %s", vp->name,
				    "is read only");
@


1.204.2.1
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.209 2012/03/24 18:47:04 tg Exp $");
d63 4
d149 3
a1761 1
static char REPLY[] = "REPLY";
d1766 1
d3671 1
a3671 1
		sigset_t omask, bmask;
d3673 2
a3674 17
		/* block a number of signals from interrupting us, though */
		(void)sigemptyset(&bmask);
		(void)sigaddset(&bmask, SIGPIPE);
		(void)sigaddset(&bmask, SIGCHLD);
#ifdef SIGWINCH
		(void)sigaddset(&bmask, SIGWINCH);
#endif
#ifdef SIGINFO
		(void)sigaddset(&bmask, SIGINFO);
#endif
#ifdef SIGUSR1
		(void)sigaddset(&bmask, SIGUSR1);
#endif
#ifdef SIGUSR2
		(void)sigaddset(&bmask, SIGUSR2);
#endif
		sigprocmask(SIG_BLOCK, &bmask, &omask);
a3684 1
		/* this will re-schedule signal delivery */
d3691 11
@


1.204.2.2
log
@MFC fixes from HEAD
@
text
@d8 1
a8 1
 *		 2010, 2011, 2012
d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.212 2012/04/06 13:28:59 tg Exp $");
d2256 1
a2256 1
		goto c_exitreturn_err;
a2290 3

 c_exitreturn_err:
	return (1);
d2301 1
a2301 1
		goto c_brkcont_err;
d2307 3
a2309 2
		goto c_brkcont_err;
	if (n <= 0) {
d2312 1
a2312 1
		goto c_brkcont_err;
a2313 1
	quit = n;
a2346 3

 c_brkcont_err:
	return (1);
d2978 1
a2978 1
		return (stat(opnd1, &b1) == 0 && (off_t)b1.st_size > (off_t)0);
d3255 1
a3255 1
	unsigned int factor;	/* multiply by to get rlim_{cur,max} values */
d3451 1
a3451 1
		mksh_uari_t rval;
d3453 1
a3453 1
		if (!evaluate(v, (mksh_ari_t *)&rval, KSH_RETURN_ERROR, false))
d3503 1
a3503 1
		shprintf("%lu\n", (unsigned long)(val / l->factor));
@


1.203
log
@BUGFIX: make typeset -n flag more robust (catch ALL exits)
@
text
@d619 1
a619 1
	int thing = 0, field, base, optc;
d621 1
a621 1
	const char *fieldstr, *basestr;
a651 1
	fieldstr = basestr = NULL;
a741 1
	field = 0;
d744 2
a745 2
	base = 0;
	if (basestr && !bi_getn(basestr, &base))
d747 1
@


1.202
log
@oh well, shove it; inline some things, the most legible ones
mostly for benefit of not-the-latest-llvm-or-gcc compilers
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.201 2011/12/02 22:55:48 tg Exp $");
d728 2
d745 1
a745 1
		return (1);
d748 1
a748 1
		return (1);
d761 1
a761 2
		set_refflag = SRF_NOP;
		return (1);
d817 1
a817 2
				set_refflag = SRF_NOP;
				return (1);
d971 1
@


1.201
log
@• improve comments
• do shave off 20 bytes from c_test() and get rid of the ugly stack
  variable and double “using” despite not parsing
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.200 2011/11/30 21:34:12 tg Exp $");
d2755 1
d2766 1
a2766 1
		if ((*te.isa)(&te, TM_NOT)) {
d2770 1
a2770 1
		if ((op = (*te.isa)(&te, TM_UNOP))) {
d2772 1
a2772 2
			rv = (*te.eval)(&te, op,
			    (*te.getopnd)(&te, op, true), NULL, true);
d2781 3
a2783 4
		/* inside knowledge shows ptest_getopnd never evaluates */
		/* skip lhs, without evaluation; assign with */
		lhs = (*te.getopnd)(&te, TO_NONOP, true);
		if ((op = (*te.isa)(&te, TM_BINOP))) {
d2785 1
a2785 2
			rv = (*te.eval)(&te, op, lhs,
			    (*te.getopnd)(&te, op, true), true);
d2790 1
a2790 1
		if ((*te.isa)(&te, TM_NOT)) {
d2794 1
a2794 1
		if ((*te.isa)(&te, TM_OPAREN)) {
d2797 1
a2797 1
			(*te.getopnd)(&te, TO_NONOP, false);
d2799 1
a2799 1
			op = (*te.isa)(&te, TM_CPAREN);
d2810 1
a2810 1
		if ((*te.isa)(&te, TM_NOT)) {
d2814 1
a2814 1
		if ((*te.isa)(&te, TM_OPAREN)) {
d2817 2
a2818 2
			(*te.getopnd)(&te, TO_NONOP, false);
			(*te.getopnd)(&te, TO_NONOP, false);
d2820 1
a2820 1
			op = (*te.isa)(&te, TM_CPAREN);
@


1.200
log
@rewrite funcs.c:c_test(), i.e. test(1) and [(1), to follow POSIX and XSI
in the cases where they are defined unambiguously; bug reported by
Jilles Tjoelker in <20111129232526.GC14357@@stack.nl> due to a report
by Stefano Lattarini on bug-autoconf

in the ambiguous case, I stick to traditional pdksh behaviour, which means
	test ! a = b	vs.	test a = b
and
	test ! a -o b	vs.	test a -o b
behave different from each other (in the second case, the NOT operator
binds strong; POSIX demands a reduction to 3 arguments and negating
that result in the first case), so we're at two known not-ok in the
FreeBSD® testsuite. (81 and 82 in regress.sh,v 1.3)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.199 2011/11/19 17:42:24 tg Exp $");
d2700 1
a2700 1
   test(1) accepts the following grammar:
d2716 1
a2716 1
			    "<"|">"	# rules used for [[ .. ]] expressions
d2718 1
a2718 1
	operand ::= <any thing>
d2722 1
a2722 1
#define T_ERR_EXIT	2
d2781 3
a2783 2
		/* skip lhs, without evaluation */
		(*te.getopnd)(&te, TO_NONOP, false);
d2785 3
a2787 10
			const char *rhs;

			/* read rhs, with evaluation */
			rhs = (*te.getopnd)(&te, op, true);
			/* back up to lhs */
			te.pos.wp = swp;
			/* re-read lhs, with evaluation */
			lhs = (*te.getopnd)(&te, op, true);
			/* finally run the test of lhs op rhs */
			rv = (*te.eval)(&te, op, lhs, rhs, true);
@


1.199
log
@add explicit casts to uid_t and gid_t of the struct stat slots, for some
architectures on Linux have a truly horrible struct stat definition, as
seen in dietlibc’s source code
https://buildd.debian.org/status/fetch.php?pkg=mksh&arch=mipsel&ver=40.2-4&stamp=1321054539
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.198 2011/11/09 22:17:25 tg Exp $");
d2727 1
a2727 1
	int argc, res;
d2729 2
d2752 3
a2754 3
	 * Handle the special cases from POSIX.2, section 4.62.4.
	 * Implementation of all the rules isn't necessary since
	 * our parser does the right thing for the omitted steps.
d2756 58
a2813 16
	if (argc <= 5) {
		const char **owp = wp, **owpend = te.wp_end;
		int invert = 0;
		Test_op op;
		const char *opnd1, *opnd2;

		if (argc >= 2 && ((*te.isa)(&te, TM_OPAREN))) {
			te.pos.wp = te.wp_end - 1;
			if ((*te.isa)(&te, TM_CPAREN)) {
				argc -= 2;
				te.wp_end--;
				te.pos.wp = owp + 2;
			} else {
				te.pos.wp = owp + 1;
				te.wp_end = owpend;
			}
d2815 20
a2834 31

		while (--argc >= 0) {
			if ((*te.isa)(&te, TM_END))
				return (!0);
			if (argc == 3) {
				opnd1 = (*te.getopnd)(&te, TO_NONOP, 1);
				if ((op = (*te.isa)(&te, TM_BINOP))) {
					opnd2 = (*te.getopnd)(&te, op, 1);
					res = (*te.eval)(&te, op, opnd1,
					    opnd2, 1);
					if (te.flags & TEF_ERROR)
						return (T_ERR_EXIT);
					if (invert & 1)
						res = !res;
					return (!res);
				}
				/* back up to opnd1 */
				te.pos.wp--;
			}
			if (argc == 1) {
				opnd1 = (*te.getopnd)(&te, TO_NONOP, 1);
				res = (*te.eval)(&te, TO_STNZE, opnd1,
				    NULL, 1);
				if (invert & 1)
					res = !res;
				return (!res);
			}
			if ((*te.isa)(&te, TM_NOT)) {
				invert++;
			} else
				break;
d2836 2
a2837 2
		te.pos.wp = owp + 1;
		te.wp_end = owpend;
d2840 2
@


1.198
log
@• select(0, …) misbehaves on Interix (by Markus Duft <mduft@@gentoo.org>)
• select(n, NULL, NULL, NULL, …) behaves the same (by Bruno Haible)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.197 2011/09/07 15:24:15 tg Exp $");
d2971 1
a2971 1
		return (stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid);
d2975 1
a2975 1
		return (stat(opnd1, &b1) == 0 && b1.st_gid == getegid());
@


1.197
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.196 2011/08/27 18:06:44 tg Exp $");
d3649 1
a3649 1
		if (select(0, NULL, NULL, NULL, &tv) == 0 || errno == EINTR)
@


1.196
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.195 2011/08/27 17:30:04 tg Exp $");
d90 1
a90 1
	{T_gbuiltin, c_builtin},
d97 1
a97 1
	{T_sgset, c_set},
d109 1
a109 1
	{T_palias, c_alias},
d128 2
a129 2
	{T__typeset, c_typeset},
	{T_punalias, c_unalias},
a207 1
static int test_eaccess(const char *, int);
d246 1
d547 1
a547 1
				    T_alias);
d549 1
a549 1
				shprintf("%s %s=", T_alias, id);
d564 1
a564 1
				shf_puts(T__function, shl_stdout);
d571 1
a571 1
				    "shell", T_builtin);
d582 1
a582 1
						    T_alias);
d1034 1
a1034 1
			T_unalias, "-ta", NULL
d1039 1
a1039 1
			    " and without arguments\n", T_alias);
d1052 1
a1052 1
					shprintf("%s ", T_alias);
d1077 1
a1077 1
					shprintf("%s ", T_alias);
d1085 1
a1085 1
				shprintf("%s %s %s\n", alias, T_alias,
d1100 3
a1102 1
			newval = tflag ? search(alias, path, X_OK, NULL) : val;
d1716 2
a1717 3
	if ((file = search(cp, path, R_OK, &errcode)) == NULL) {
		bi_errorf("%s: %s", cp,
		    errcode ? strerror(errcode) : "not found");
d1825 1
a1825 1
			bi_errorf("%s: %s '%s'", T_synerr, strerror(errno),
d1907 1
a1907 1
			bi_errorf("%s: %s", T_select, strerror(errno));
d2365 1
a2365 1
		static const char *args[] = { T_set, "-", NULL };
d2866 2
a2867 1
		return (test_eaccess(opnd1, R_OK) == 0);
d2871 2
a2872 1
		return (test_eaccess(opnd1, W_OK) == 0);
d2876 1
a2876 1
		return (test_eaccess(opnd1, X_OK) == 0);
a3072 20
/* On most/all unixen, access() says everything is executable for root... */
static int
test_eaccess(const char *pathl, int mode)
{
	int rv;

	if ((rv = access(pathl, mode)) == 0 && ksheuid == 0 && (mode & X_OK)) {
		struct stat statb;

		if (stat(pathl, &statb) < 0)
			rv = -1;
		else if (S_ISDIR(statb.st_mode))
			rv = 0;
		else
			rv = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) ?
			    0 : -1;
	}
	return (rv);
}

d3502 1
a3502 1
		bi_errorf(T_synerr);
d3525 1
a3525 1
		bi_errorf(T_synerr);
d3550 1
a3550 1
		bi_errorf(T_oomem, (unsigned long)MKSH_CAT_BUFSIZ);
d3561 1
a3561 1
			bi_errorf(T_synerr);
d3639 1
a3639 1
		bi_errorf(T_synerr);
d3641 1
a3641 1
		bi_errorf("%s: %s '%s'", T_synerr, strerror(errno), wp[0]);
d3656 1
a3656 1
			bi_errorf("%s: %s", T_select, strerror(errno));
@


1.195
log
@jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.194 2011/07/20 23:47:28 tg Exp $");
d216 1
a216 1
static char *kill_fmt_entry(char *, int, int, const void *);
d404 1
a404 2
					c = utf_wctomb(ts, c - 0x100);
					ts[c] = 0;
d1260 1
a1260 1
kill_fmt_entry(char *buf, int buflen, int i, const void *arg)
d1331 2
a1332 1
			int w, j, mess_cols, mess_octs;
@


1.194
log
@optimise an if away, and possibly even the function bodies…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.193 2011/07/05 20:12:18 tg Exp $");
d56 1
a56 1
#define MKSH_NO_LIMITS
d60 1
a60 1
#define c_ulimit c_true
@


1.193
log
@• bump patchlevel to today’s
• while here, reformat 'struct tbl' comment-wise and placement-wise
  and drop the Tflag typedef
• while here, write regression test for the "global" built-in, which
  does what typeset is supposed to do except that it doubles as "local"
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.192 2011/07/05 19:56:24 tg Exp $");
d60 1
a60 1
#define c_ulimit c_label
d67 12
d87 1
a87 1
	{"*=:", c_label},
d95 1
a95 1
	{"+false", c_label},
d104 1
a104 1
	{"+true", c_label},
d147 1
a147 1
	{"domainname", c_label},
a1536 11
/**
 * :, false and true
 * ulimit if MKSH_NO_LIMITS
 * domainname on MirBSD (hysterical raisins, just don't ask)
 */
int
c_label(const char **wp)
{
	return (wp[0][0] == 'f' ? 1 : 0);
}

@


1.192
log
@allow ^Cing the built-in cat, spotted by Johannes (jal) in IRC
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.191 2011/07/02 17:57:23 tg Exp $");
d607 1
a607 1
	Tflag fset = 0, fclr = 0, flag;
d969 1
a969 1
	Tflag xflag = 0;
@


1.191
log
@add new experimental "global" command
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.190 2011/06/21 21:11:19 tg Exp $");
d3599 3
a3601 1
				if (errno == EINTR)
d3604 1
@


1.190
log
@make set_refflag an enum to get easier to understand code
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.189 2011/06/11 03:14:49 tg Exp $");
d106 1
d601 1
a601 1
/* typeset, export, and readonly */
@


1.189
log
@add missing shf_flush() before prompting
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.188 2011/05/29 05:13:12 tg Exp $");
a66 2
extern uint8_t set_refflag;

d692 2
a693 1
			set_refflag = (builtin_opt.info & GI_PLUS) ? 2 : 1;
d744 2
a745 1
	if (func && (((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT)) || set_refflag)) {
d747 1
a747 1
		set_refflag = 0;
d772 1
a772 1
		    INTEGER | INT_U | INT_L)) || set_refflag)
d804 1
a804 1
				set_refflag = 0;
d808 1
a808 1
		set_refflag = 0;
@


1.188
log
@now we only fail 416 ipv 1664 tests of ifs.sh
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.187 2011/05/29 02:18:51 tg Exp $");
d1861 1
@


1.187
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.186 2011/05/06 15:41:23 tg Exp $");
d1764 1
a1764 1
	int c, fd = 0, rv = 0;
d1766 1
a1766 1
	bool rawmode = false, expanding = false, lastparm = false;
d1774 1
d2031 11
d2069 1
a2069 1
		lastparm = true;
d2071 1
a2071 5
	/* skip initial IFS whitespace */
	while (is_ifsws(*ccp)) {
		++ccp;
		--bytesread;
	}
d2076 1
a2076 2
		ch = *ccp++;
		--bytesread;
d2079 1
d2081 1
a2081 3
			if (!lastparm)
				break;
			/* last parameter, copy all */
d2084 4
a2087 1
			continue;
d2089 11
d2102 4
d2107 5
a2111 4
	if (lastparm) {
		/* remove trailing IFS whitespace */
		while (Xlength(xs, xp) && is_ifsws(xp[-1]))
			--xp;
d2113 8
@


1.186
log
@• add patch from Robert Luberda <robert@@debian.org> fixing the
  four-argument form of test (yet again…), thanks
• drop the obsolete (pre-POSIX) form “test -t” without fd
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.185 2011/04/09 21:01:01 tg Exp $");
d1762 1
a1762 7
	int c, ecode = 0, fd = 0, optc;
	bool expande = true, historyr = false, expanding;
	const char *cp, *emsg;
	struct shf *shf;
	XString cs, xs = { NULL, NULL, 0, NULL};
	struct tbl *vp;
	char *ccp, *xp = NULL, *wpalloc = NULL, delim = '\n';
d1764 19
d1784 50
a1833 27
	while ((optc = ksh_getopt(wp, &builtin_opt, "d:prsu,")) != -1)
		switch (optc) {
		case 'd':
			delim = builtin_opt.optarg[0];
			break;
		case 'p':
			if ((fd = coproc_getfd(R_OK, &emsg)) < 0) {
				bi_errorf("%s: %s", "-p", emsg);
				return (1);
			}
			break;
		case 'r':
			expande = false;
			break;
		case 's':
			historyr = true;
			break;
		case 'u':
			if (!*(cp = builtin_opt.optarg))
				fd = 0;
			else if ((fd = check_fd(cp, R_OK, &emsg)) < 0) {
				bi_errorf("%s: %s: %s", "-u", cp, emsg);
				return (1);
			}
			break;
		case '?':
			return (1);
d1835 4
a1839 1

d1843 4
a1846 5
	/*
	 * Since we can't necessarily seek backwards on non-regular files,
	 * don't buffer them so we can't read too much.
	 */
	shf = shf_reopen(fd, SHF_RD | SHF_INTERRUPT | can_seek(fd), shl_spare);
d1848 4
a1851 4
	if ((cp = cstrchr(*wp, '?')) != NULL) {
		strdupx(wpalloc, *wp, ATEMP);
		wpalloc[cp - *wp] = '\0';
		*wp = wpalloc;
d1859 61
a1919 1
			shellf("%s", cp + 1);
d1921 2
d1925 17
a1941 11
	/*
	 * If we are reading from the co-process for the first time,
	 * make sure the other side of the pipe is closed first. This allows
	 * the detection of eof.
	 *
	 * This is not compatible with AT&T ksh... the fd is kept so another
	 * coproc can be started with same output, however, this means eof
	 * can't be detected... This is why it is closed here.
	 * If this call is removed, remove the eof check below, too.
	 * coproc_readw_close(fd);
	 */
d1943 25
a1967 22
	if (historyr)
		Xinit(xs, xp, 128, ATEMP);
	expanding = false;
	Xinit(cs, ccp, 128, ATEMP);
	/* initialise to something not EOF or delim or any character */
	c = 0x100;
	for (; *wp != NULL; wp++) {
		for (ccp = Xstring(cs, ccp); ; ) {
			if (c == delim || c == EOF)
				break;
			/* loop to read one character */
			while (/* CONSTCOND */ 1) {
				c = shf_getc(shf);
				/* we break unless NUL or EOF, so... */
				if (c == delim)
					/* in case delim == NUL */
					break;
				if (c == '\0')
					/* skip any read NUL byte */
					continue;
				if (c == EOF && shf_error(shf) &&
				    shf_errno(shf) == EINTR) {
d1969 2
a1970 3
					 * Was the offending signal one that
					 * would normally kill a process?
					 * If so, pretend the read was killed.
d1972 2
a1973 7
					ecode = fatal_trap_check();

					/* non fatal (eg, CHLD), carry on */
					if (!ecode) {
						shf_clearerr(shf);
						continue;
					}
d1975 3
d1980 4
a1983 34
			if (historyr) {
				Xcheck(xs, xp);
				Xput(xs, xp, c);
			}
			Xcheck(cs, ccp);
			if (expanding) {
				expanding = false;
				if (c == delim) {
					c = 0;
					if (Flag(FTALKING_I) && isatty(fd)) {
						/*
						 * set prompt in case this is
						 * called from .profile or $ENV
						 */
						set_prompt(PS2, NULL);
						pprompt(prompt, 0);
					}
				} else if (c != EOF)
					Xput(cs, ccp, c);
				continue;
			}
			if (expande && c == '\\') {
				expanding = true;
				continue;
			}
			if (c == delim || c == EOF)
				break;
			if (ctype(c, C_IFS)) {
				if (Xlength(cs, ccp) == 0 && ctype(c, C_IFSWS))
					continue;
				if (wp[1])
					break;
			}
			Xput(cs, ccp, c);
d1985 31
a2015 6
		/* strip trailing IFS white space from last variable */
		if (!wp[1])
			while (Xlength(cs, ccp) && ctype(ccp[-1], C_IFS) &&
			    ctype(ccp[-1], C_IFSWS))
				ccp--;
		Xput(cs, ccp, '\0');
a2016 1
		/* Must be done before setting export. */
d2018 1
a2018 1
			shf_flush(shf);
d2020 59
a2078 2
			afree(wpalloc, ATEMP);
			return (2);
d2080 17
a2098 5
		if (!setstr(vp, Xstring(cs, ccp), KSH_RETURN_ERROR)) {
			shf_flush(shf);
			afree(wpalloc, ATEMP);
			return (1);
		}
d2100 13
d2114 7
a2120 16
	shf_flush(shf);
	if (historyr) {
		Xput(xs, xp, '\0');
		histsave(&source->line, Xstring(xs, xp), true, false);
		Xfree(xs, xp);
	}
	/*
	 * if this is the co-process fd, close the file descriptor
	 * (can get eof if and only if all processes are have died,
	 * i.e. coproc.njobs is 0 and the pipe is closed).
	 */
	if (c == EOF && !ecode)
		coproc_read_close(fd);

	afree(wpalloc, ATEMP);
	return (ecode ? ecode : c == EOF);
@


1.185
log
@avoid namespace conflicts with __attribute__(…)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.184 2011/04/09 15:21:36 tg Exp $");
d2545 1
a2545 1
		const char **owp = wp;
d2550 12
a2581 2
				if (strcmp(opnd1, "-t") == 0)
				    break;
d2594 1
@


1.184
log
@missed one FKSH use
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.183 2011/04/09 15:14:52 tg Exp $");
d208 1
a208 1
    MKSH_A_NONNULL((nonnull (6, 7)));
@


1.183
log
@• no longer use <stdbool.h> even if it’s available
• ensure that bool/true/false are cpp macros, overriding any pre-defined
• document the requirement that tobool(x) must map any-type 'x' into bool
• document the requirement that a bool must only be true or false, and
  that it (tobool() rather) must have an identity mapping to 'short'
• possibly fix ksh_func for/and fpFUNCTf – maybe spotted by cnuke@@
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.182 2011/03/27 18:50:04 tg Exp $");
d823 1
a823 1
					    vp->flag & FKSH,
@


1.182
log
@• Implement http://austingroupbugs.net/view.php?id=367 and align things
  a bit more with POSIX and the other shells

I considered http://austingroupbugs.net/view.php?id=253 but the use
of bi_errorf() is interesting, especially as it’s often enough a
noreturn function, and funnily enough, 'cd -P /foo' returns 0 while
'chdir -P /foo' fails (so idk where to put -e)…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.181 2011/03/27 01:30:36 tg Exp $");
d797 2
a798 1
					fpFUNCTf(shl_stdout, 0, f->flag & FKSH,
@


1.181
log
@don’t leak memory (pdksh did), and forgot a hunk
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.180 2011/03/26 21:46:02 tg Exp $");
d1457 1
a1457 1
		rv = 1;
d1920 1
a1920 1
			return (1);
d2190 1
a2190 1
	int optc;
d2202 2
a2203 1
			return (1);
d2226 5
a2230 4
				bi_errorf("%s: %s", vp->name, "is read only");
				return (1);
			}
			unset(vp, optc);
d2234 1
a2234 1
	return (0);
@


1.180
log
@• bring back test -H ifdef S_ISCDF (for HP-UX)
• whitespace, etc.
• bump version for tonight, I’m not gonna hack on c_cd,
  all this pathname stuff is mind-boggling…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.179 2011/03/24 19:05:47 tg Exp $");
d2703 3
a2705 1
		return (stat(nv, &b1) == 0 && S_ISCDF(b1.st_mode));
@


1.179
log
@• move funcs.c:do_realpath() to misc.c and make it global
  ⇒ consider merging simplify_path()
• move funcs.c:c_cd() to misc.c
• make misc.c:make_path() static, c_cd() is its only user
  ⇒ mark as obsolete
• tweak misc.c:set_current_wd() to drop ksh_get_wd() argument

should be no code change, but the entire path stuff is a mess…
so expect actual implementation changes or even rewrites shortly
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.178 2011/03/23 18:47:06 tg Exp $");
d2618 2
a2619 1
	switch ((int)op) {
d2623 2
a2625 1
		/* -n */
d2627 2
a2629 1
		/* -z */
d2631 2
a2633 1
		/* -o */
d2639 2
a2641 1
		/* -r */
d2643 2
a2645 1
		/* -w */
d2647 2
a2649 1
		/* -x */
d2651 2
d2654 1
a2654 1
		/* -a */
a2655 1
		/* -e */
d2657 2
a2659 1
		/* -r */
d2661 2
a2663 1
		/* -d */
d2665 2
a2667 1
		/* -c */
d2669 2
a2671 1
		/* -b */
d2673 2
a2675 1
		/* -p */
d2677 2
a2679 1
		/* -h -L */
d2681 2
a2683 1
		/* -S */
d2685 2
d2688 18
a2705 1
		/* -H HP context dependent files (directories) */
d2707 3
a2710 1
		/* -u */
d2713 2
a2715 1
		/* -g */
d2718 2
a2720 1
		/* -k */
d2727 2
a2729 1
		/* -s */
d2731 2
a2733 1
		/* -t */
d2740 2
a2742 1
		/* -O */
d2744 2
a2746 1
		/* -G */
d2748 1
d2752 2
a2754 1
		/* = */
d2758 2
a2760 1
		/* != */
d2764 2
a2766 1
		/* < */
d2768 2
a2770 1
		/* > */
d2772 2
d2775 1
a2775 1
		/* -eq */
d2777 1
a2777 1
		/* -ne */
d2779 1
a2779 1
		/* -ge */
d2781 1
a2781 1
		/* -gt */
d2783 1
a2783 1
		/* -le */
a2784 1
		/* -lt */
d2791 1
a2791 1
		switch ((int)op) {
d2804 3
d2808 3
a2811 1
		/* -nt */
d2819 2
a2821 1
		/* -ot */
d2829 2
a2831 1
		/* -ef */
d2834 6
@


1.178
log
@ironhead reported in IRC that some Cygwin guys (not he, he’s just the
packager) complain that mksh collapses two leading slashes; IIRC POSIX
has a clause for UNC pathnames, so stop doing that, plus add a test
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.177 2011/03/16 20:56:32 tg Exp $");
a208 352
static char *do_realpath(const char *);

static char *
do_realpath(const char *upath)
{
	char *xp, *ip, *tp, *ipath, *ldest = NULL;
	XString xs;
	ptrdiff_t pos;
	size_t len;
	int llen;
	struct stat sb;
#ifdef NO_PATH_MAX
	size_t ldestlen = 0;
#define pathlen sb.st_size
#define pathcnd (ldestlen < (pathlen + 1))
#else
#define pathlen PATH_MAX
#define pathcnd (!ldest)
#endif
	/* max. recursion depth */
	int symlinks = 32;

	if (upath[0] == '/') {
		/* upath is an absolute pathname */
		strdupx(ipath, upath, ATEMP);
	} else {
		/* upath is a relative pathname, prepend cwd */
		if ((tp = ksh_get_wd(NULL)) == NULL || tp[0] != '/')
			return (NULL);
		ipath = shf_smprintf("%s%s%s", tp, "/", upath);
		afree(tp, ATEMP);
	}

	/* ipath and upath are in memory at the same time -> unchecked */
	Xinit(xs, xp, strlen(ip = ipath) + 1, ATEMP);

	/* now jump into the deep of the loop */
	goto beginning_of_a_pathname;

	while (*ip) {
		/* skip slashes in input */
		while (*ip == '/')
			++ip;
		if (!*ip)
			break;

		/* get next pathname component from input */
		tp = ip;
		while (*ip && *ip != '/')
			++ip;
		len = ip - tp;

		/* check input for "." and ".." */
		if (tp[0] == '.') {
			if (len == 1)
				/* just continue with the next one */
				continue;
			else if (len == 2 && tp[1] == '.') {
				/* strip off last pathname component */
				while (xp > Xstring(xs, xp))
					if (*--xp == '/')
						break;
				/* then continue with the next one */
				continue;
			}
		}

		/* store output position away, then append slash to output */
		pos = Xsavepos(xs, xp);
		/* 1 for the '/' and len + 1 for tp and the NUL from below */
		XcheckN(xs, xp, 1 + len + 1);
		Xput(xs, xp, '/');

		/* append next pathname component to output */
		memcpy(xp, tp, len);
		xp += len;
		*xp = '\0';

		/* lstat the current output, see if it's a symlink */
		if (lstat(Xstring(xs, xp), &sb)) {
			/* lstat failed */
			if (errno == ENOENT) {
				/* because the pathname does not exist */
				while (*ip == '/')
					/* skip any trailing slashes */
					++ip;
				/* no more components left? */
				if (!*ip)
					/* we can still return successfully */
					break;
				/* more components left? fall through */
			}
			/* not ENOENT or not at the end of ipath */
			goto notfound;
		}

		/* check if we encountered a symlink? */
		if (S_ISLNK(sb.st_mode)) {
			/* reached maximum recursion depth? */
			if (!symlinks--) {
				/* yep, prevent infinite loops */
				errno = ELOOP;
				goto notfound;
			}

			/* get symlink(7) target */
			if (pathcnd) {
#ifdef NO_PATH_MAX
				if (notoktoadd(pathlen, 1)) {
					errno = ENAMETOOLONG;
					goto notfound;
				}
#endif
				ldest = aresize(ldest, pathlen + 1, ATEMP);
			}
			llen = readlink(Xstring(xs, xp), ldest, pathlen);
			if (llen < 0)
				/* oops... */
				goto notfound;
			ldest[llen] = '\0';

			/*
			 * restart if symlink target is an absolute path,
			 * otherwise continue with currently resolved prefix
			 */
			/* append rest of current input path to link target */
			tp = shf_smprintf("%s%s%s", ldest, *ip ? "/" : "", ip);
			afree(ipath, ATEMP);
			ip = ipath = tp;
			if (ldest[0] != '/') {
				/* symlink target is a relative path */
				xp = Xrestpos(xs, xp, pos);
			} else {
				/* symlink target is an absolute path */
				xp = Xstring(xs, xp);
 beginning_of_a_pathname:
				/* assert: (ip == ipath)[0] == '/' */
				/* assert: xp == xs.beg => start of path */

				if (ip[1] == '/' && ip[2] != '/') {
					/* keep UNC names, per POSIX */
					Xput(xs, xp, '/');
				}
			}
		}
		/* otherwise (no symlink) merely go on */
	}

	/*
	 * either found the target and successfully resolved it,
	 * or found its parent directory and may create it
	 */
	if (Xlength(xs, xp) == 0)
		/*
		 * if the resolved pathname is "", make it "/",
		 * otherwise do not add a trailing slash
		 */
		Xput(xs, xp, '/');
	Xput(xs, xp, '\0');

	/*
	 * if source path had a trailing slash, check if target path
	 * is not a non-directory existing file
	 */
	if (ip > ipath && ip[-1] == '/') {
		if (stat(Xstring(xs, xp), &sb)) {
			if (errno != ENOENT)
				goto notfound;
		} else if (!S_ISDIR(sb.st_mode)) {
			errno = ENOTDIR;
			goto notfound;
		}
		/* target now either does not exist or is a directory */
	}

	/* return target path */
	if (ldest != NULL)
		afree(ldest, ATEMP);
	afree(ipath, ATEMP);
	return (Xclose(xs, xp));

 notfound:
	/* save; freeing memory might trash it */
	llen = errno;
	if (ldest != NULL)
		afree(ldest, ATEMP);
	afree(ipath, ATEMP);
	Xfree(xs, xp);
	errno = llen;
	return (NULL);

#undef pathlen
#undef pathcnd
}

int
c_cd(const char **wp)
{
	int optc, rv, phys_path;
	bool physical = tobool(Flag(FPHYSICAL));
	/* was a node from cdpath added in? */
	int cdnode;
	/* print where we cd'd? */
	bool printpath = false;
	struct tbl *pwd_s, *oldpwd_s;
	XString xs;
	char *dir, *allocd = NULL, *tryp, *pwd, *cdpath;

	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != -1)
		switch (optc) {
		case 'L':
			physical = false;
			break;
		case 'P':
			physical = true;
			break;
		case '?':
			return (1);
		}
	wp += builtin_opt.optind;

	if (Flag(FRESTRICTED)) {
		bi_errorf("restricted shell - can't cd");
		return (1);
	}

	pwd_s = global("PWD");
	oldpwd_s = global("OLDPWD");

	if (!wp[0]) {
		/* No arguments - go home */
		if ((dir = str_val(global("HOME"))) == null) {
			bi_errorf("no home directory (HOME not set)");
			return (1);
		}
	} else if (!wp[1]) {
		/* One argument: - or dir */
		strdupx(allocd, wp[0], ATEMP);
		if (ksh_isdash((dir = allocd))) {
			afree(allocd, ATEMP);
			allocd = NULL;
			dir = str_val(oldpwd_s);
			if (dir == null) {
				bi_errorf("no OLDPWD");
				return (1);
			}
			printpath = true;
		}
	} else if (!wp[2]) {
		/* Two arguments - substitute arg1 in PWD for arg2 */
		size_t ilen, olen, nlen, elen;
		char *cp;

		if (!current_wd[0]) {
			bi_errorf("can't determine current directory");
			return (1);
		}
		/*
		 * substitute arg1 for arg2 in current path.
		 * if the first substitution fails because the cd fails
		 * we could try to find another substitution. For now
		 * we don't
		 */
		if ((cp = strstr(current_wd, wp[0])) == NULL) {
			bi_errorf("bad substitution");
			return (1);
		}
		/*-
		 * ilen = part of current_wd before wp[0]
		 * elen = part of current_wd after wp[0]
		 * because current_wd and wp[1] need to be in memory at the
		 * same time beforehand the addition can stay unchecked
		 */
		ilen = cp - current_wd;
		olen = strlen(wp[0]);
		nlen = strlen(wp[1]);
		elen = strlen(current_wd + ilen + olen) + 1;
		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
		memcpy(dir, current_wd, ilen);
		memcpy(dir + ilen, wp[1], nlen);
		memcpy(dir + ilen + nlen, current_wd + ilen + olen, elen);
		printpath = true;
	} else {
		bi_errorf("too many arguments");
		return (1);
	}

#ifdef NO_PATH_MAX
	/* only a first guess; make_path will enlarge xs if necessary */
	XinitN(xs, 1024, ATEMP);
#else
	XinitN(xs, PATH_MAX, ATEMP);
#endif

	cdpath = str_val(global("CDPATH"));
	do {
		cdnode = make_path(current_wd, dir, &cdpath, &xs, &phys_path);
		if (physical)
			rv = chdir(tryp = Xstring(xs, xp) + phys_path);
		else {
			simplify_path(Xstring(xs, xp));
			rv = chdir(tryp = Xstring(xs, xp));
		}
	} while (rv < 0 && cdpath != NULL);

	if (rv < 0) {
		if (cdnode)
			bi_errorf("%s: %s", dir, "bad directory");
		else
			bi_errorf("%s: %s", tryp, strerror(errno));
		afree(allocd, ATEMP);
		return (1);
	}

	/* allocd (above) => dir, which is no longer used */
	afree(allocd, ATEMP);
	allocd = NULL;

	/* Clear out tracked aliases with relative paths */
	flushcom(false);

	/*
	 * Set OLDPWD (note: unsetting OLDPWD does not disable this
	 * setting in AT&T ksh)
	 */
	if (current_wd[0])
		/* Ignore failure (happens if readonly or integer) */
		setstr(oldpwd_s, current_wd, KSH_RETURN_ERROR);

	if (Xstring(xs, xp)[0] != '/') {
		pwd = NULL;
	} else if (!physical || !(pwd = allocd = do_realpath(Xstring(xs, xp))))
		pwd = Xstring(xs, xp);

	/* Set PWD */
	if (pwd) {
		char *ptmp = pwd;

		set_current_wd(ptmp);
		/* Ignore failure (happens if readonly or integer) */
		setstr(pwd_s, ptmp, KSH_RETURN_ERROR);
	} else {
		set_current_wd(null);
		pwd = Xstring(xs, xp);
		/* XXX unset $PWD? */
	}
	if (printpath || cdnode)
		shprintf("%s\n", pwd);

	afree(allocd, ATEMP);
	return (0);
}
d238 1
a238 1
	if (!p && !(p = allocd = ksh_get_wd(NULL))) {
@


1.177
log
@actually, we need the android lsmod to be a builtin not an alias…
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.176 2011/03/13 01:20:19 tg Exp $");
d245 3
d334 1
a334 2
			xp = (ldest[0] == '/') ? Xstring(xs, xp) :
			    Xrestpos(xs, xp, pos);
d338 15
@


1.176
log
@lint is your friend
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.175 2011/03/07 20:30:37 tg Exp $");
d63 4
d138 3
d3727 11
@


1.175
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.174 2011/03/05 21:48:08 tg Exp $");
d2175 1
a2175 1
			while (1) {
d3639 1
a3639 1
		while (1) {
@


1.174
log
@split malloc_os and friends further into
• functions called by mksh’s grouping memory allocator
• functions called by mksh code itself

the latter may be changed to call the internal grouping allocator,
if a porter so desires (but if this were recommended, the code in
question would already do so, so…)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.173 2011/03/05 21:43:15 tg Exp $");
d384 1
a384 1
	bool physical = Flag(FPHYSICAL) ? true : false;
d542 1
a542 1
	bool physical = Flag(FPHYSICAL) ? true : false;
d1115 1
a1115 1
				    (fset&UCASEV_AL) ? true : false);
@


1.173
log
@introduce macros for malloc, realloc, free to hide them from mksh

no code may henceforth use memory (de-)allocation functions directly
use these macros, porters can change them for abstraction
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.172 2011/02/18 22:26:08 tg Exp $");
d3608 1
a3608 1
	if ((buf = malloc_os(MKSH_CAT_BUFSIZ)) == NULL) {
d3677 1
a3677 1
	free_osmalloc(buf);
@


1.172
log
@• add -u option (POSIX: unbuffered ⇒ nop) to the built-in cat
• PIPESTATUS now supported (like bash 2) whose last member
  may actually differ from $? since the latter may not be the
  result of a pipeline partial command
• add regression tests, documentation, etc.
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.171 2011/02/13 21:13:06 tg Exp $");
d367 1
a367 1
	/* save; free(3) might trash it */
d2747 1
a2747 1
			free(set);
d3608 1
a3608 2
	/* XXX uses malloc instead of lalloc (for alignment/speed) */
	if ((buf = malloc(MKSH_CAT_BUFSIZ)) == NULL) {
d3677 1
a3677 1
	free(buf);
@


1.171
log
@* plug a regression introduced as a pasto (think, mira!)
* add selftest-direct-builtin-call regression test, while here
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.170 2011/02/11 01:18:17 tg Exp $");
d3602 1
a3602 1
	int fd = STDIN_FILENO, rv = 0;
d3614 13
a3626 5
	/* skip argv[0] */
	++wp;
	if (wp[0] && !strcmp(wp[0], "--"))
		/* skip "--" (options separator) */
		++wp;
@


1.170
log
@• more comment and int→bool cleanup, add and improve some comments
• in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesn’t suffice
• add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
• for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
• when called as builtin, echo behaves POSIXish
• add domainname as alias for true on MirBSD only, to be able to link it
• sync mksh Makefiles with Build.sh output
• adjust manpage wrt release plans
• link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
• drop linked utilities and, except for echo and kill, their manpages
• adjust instbin and link a few more there as well
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.169 2011/02/11 00:41:34 tg Exp $");
d3707 1
a3707 1
		sigprocmask(SIG_BLOCK, &omask, NULL);
@


1.169
log
@add a sleep builtin that can deal with fractions too
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.168 2011/01/30 01:35:58 tg Exp $");
d130 4
d504 1
a504 1
	flushcom(0);
d597 1
a597 1
		if (Flag(FPOSIX) || Flag(FSH)) {
d1851 5
a1855 1
/* :, false and true (and ulimit if MKSH_NO_LIMITS) */
@


1.168
log
@SUSv4 says trap foo UNKNOWN is not a syntax error, merely exit ≠0.
Inspired by 673dab8698b0399c967216c02262eaf95361a75c.
@
text
@d29 13
a41 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.167 2011/01/22 20:33:13 tg Exp $");
d127 3
d3665 40
@


1.167
log
@plug regression introduced with read -d by fixing the problem differently
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.166 2011/01/21 22:00:15 tg Exp $");
d2339 9
a2347 9
	while (*wp != NULL) {
		p = gettrap(*wp++, true);
		if (p == NULL) {
			bi_errorf("bad signal '%s'", wp[-1]);
			return (1);
		}
		settrap(p, s);
	}
	return (0);
@


1.166
log
@add read with delimiter, like AT&T ksh93 (thanks Dave for the suggestion)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.165 2011/01/09 21:57:26 tg Exp $");
d53 2
a54 1
/* A leading = means assignments before command are kept;
d82 2
a83 1
	{T_palias, c_alias},	/* no =: AT&T manual wrong */
d85 2
a86 1
	{"chdir", c_cd},	/* dash compatibility hack */
a191 1
	int symlinks = 32;	/* max. recursion depth */
d202 2
d348 2
a349 1
	llen = errno;	/* save; free(3) might trash it */
d366 4
a369 2
	int cdnode;			/* was a node from cdpath added in? */
	bool printpath = false;		/* print where we cd'd? */
d423 2
a424 1
		/* substitute arg1 for arg2 in current path.
d487 2
a488 1
	/* Set OLDPWD (note: unsetting OLDPWD does not disable this
d628 2
a629 1
			case 'R': /* fake BSD echo command */
d725 2
a726 1
		/* Ensure we aren't killed by a SIGPIPE while writing to
d801 2
a802 1
		/* Convert command options to whence options - note that
d904 2
a905 1
	/* Let c_whence do the work. Note that c_command() must be
d924 3
a926 1
	case 'e':		/* export */
d930 3
a932 1
	case 'r':		/* readonly */
d936 3
a938 1
	case 's':		/* set */
d941 3
a943 1
	case 't':		/* typeset */
d953 2
a954 1
	/* AT&T ksh seems to have 0-9 as options which are multiplied
d974 2
a975 1
			/* AT&T ksh uses u, but this conflicts with
d1005 1
a1006 1
			/* export, readonly: POSIX -p flag */
d1019 2
a1020 1
			flag = UCASEV_AL;	/* upper case / autoload */
d1060 2
a1061 1
		/* Take care of exclusions.
d1065 2
a1066 1
		if (fset & LCASEV)	/* LCASEV has priority over UCASEV_AL */
d1068 2
a1069 1
		if (fset & LJUST)	/* LJUST has priority over RJUST */
d1071 2
a1072 1
		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) { /* -Z implies -ZR */
d1076 2
a1077 1
		/* Setting these attributes clears the others, unless they
d1121 3
a1123 1
	flag = fset | fclr; /* no difference at this point.. */
d1167 2
a1168 1
					/* Ignore array elements that aren't
d1170 2
a1171 1
					 * in which case the first is reported on */
d1177 2
a1178 1
						/* AT&T ksh prints things
d1244 4
a1247 2
							/* AT&T ksh can't have
							 * justified integers.. */
d1257 2
a1258 1
					/* Only report first 'element' of an array with
d1429 2
a1430 1
			t = NULL;	/* fix "unalias -dt" */
d1450 2
a1451 1
			rv = 1;	/* POSIX */
d1482 2
a1483 1
	if (wp[1] == NULL) /* AT&T ksh does this */
d1488 2
a1489 1
				rv = 2;	/* distinguish error from zero result */
d1512 2
a1513 1
		case 'z':	/* debugging: print zombies */
d1738 2
a1739 1
		/* POSIX says var is set to ? at end-of-options, AT&T ksh
d1750 2
a1751 1
	voptarg->flag &= ~RDONLY;	/* AT&T ksh clears ro and int */
d1805 2
a1806 1
	if (*wp == NULL)	/* list all */
d1924 2
a1925 1
			umask(old_umask); /* in case of error */
d1946 2
a1947 1
					positions = 0111; /* default is a */
d2025 2
a2026 1
		argv[0] = e->loc->argv[0]; /* preserve $0 */
d2057 2
a2058 1
			rv = sig ? sig : 127; /* magic exit code: bad job-id */
d2066 1
a2066 1
	int c = 0, ecode = 0, fd = 0, optc;
d2145 2
d2149 3
d2154 1
d2156 1
d2159 1
d2163 2
a2164 1
					/* Was the offending signal one that
d2185 1
a2185 1
				if (c == '\n') {
d2333 2
a2334 1
	s = (gettrap(*wp, false) == NULL) ? *wp++ : NULL; /* get command */
d2368 2
a2369 1
	if (wp[0][0] == 'r') { /* return */
d2372 2
a2373 1
		/* need to tell if this is exit or return so trap exit will
d2388 2
a2389 1
	quitenv(NULL);	/* get rid of any i/o redirections */
d2426 2
a2427 1
		/* AT&T ksh doesn't print a message - just does what it
d2435 2
a2436 1
		/* POSIX says if n is too big, the last enclosing loop
d2470 2
a2471 1
		wp[0] = l->argv[0]; /* save $0 */
d2511 2
a2512 1
		if (unset_var) {	/* unset variable */
d2534 2
a2535 1
		} else			/* unset function */
d2609 2
a2610 1
	if (tf & TF_NOARGS) { /* ksh93 - report shell times (shell+kids) */
d2655 2
a2656 1
	opt.optind = 0;	/* start at the start */
d2791 2
a2792 1
/* test(1) accepts the following grammar:
d2813 2
a2814 1
#define T_ERR_EXIT	2	/* POSIX says > 1 for errors */
d2927 2
a2928 1
	case TO_STNZE: /* -n */
d2930 2
a2931 1
	case TO_STZER: /* -z */
d2933 2
a2934 1
	case TO_OPTION: /* -o */
d2940 2
a2941 1
	case TO_FILRD: /* -r */
d2943 2
a2944 1
	case TO_FILWR: /* -w */
d2946 2
a2947 1
	case TO_FILEX: /* -x */
d2949 4
a2952 2
	case TO_FILAXST: /* -a */
	case TO_FILEXST: /* -e */
d2954 2
a2955 1
	case TO_FILREG: /* -r */
d2957 2
a2958 1
	case TO_FILID: /* -d */
d2960 2
a2961 1
	case TO_FILCDEV: /* -c */
d2963 2
a2964 1
	case TO_FILBDEV: /* -b */
d2966 2
a2967 1
	case TO_FILFIFO: /* -p */
d2969 2
a2970 1
	case TO_FILSYM: /* -h -L */
d2972 2
a2973 1
	case TO_FILSOCK: /* -S */
d2975 2
a2976 1
	case TO_FILCDF:/* -H HP context dependent files (directories) */
d2978 2
a2979 1
	case TO_FILSETU: /* -u */
d2982 2
a2983 1
	case TO_FILSETG: /* -g */
d2986 2
a2987 1
	case TO_FILSTCK: /* -k */
d2994 2
a2995 1
	case TO_FILGZ: /* -s */
d2997 2
a2998 1
	case TO_FILTT: /* -t */
d3005 2
a3006 1
	case TO_FILUID: /* -O */
d3008 2
a3009 1
	case TO_FILGID: /* -G */
d3014 2
a3015 1
	case TO_STEQL: /* = */
d3019 2
a3020 1
	case TO_STNEQ: /* != */
d3024 2
a3025 1
	case TO_STLT: /* < */
d3027 2
a3028 1
	case TO_STGT: /* > */
d3030 12
a3041 6
	case TO_INTEQ: /* -eq */
	case TO_INTNE: /* -ne */
	case TO_INTGE: /* -ge */
	case TO_INTGT: /* -gt */
	case TO_INTLE: /* -le */
	case TO_INTLT: /* -lt */
d3062 4
a3065 2
	case TO_FILNT: /* -nt */
		/* ksh88/ksh93 succeed if file2 can't be stated
d3071 4
a3074 2
	case TO_FILOT: /* -ot */
		/* ksh88/ksh93 succeed if file1 can't be stated
d3080 2
a3081 1
	case TO_FILEQ: /* -ef */
@


1.165
log
@New functionality: assign here document to string variable directly,
without cat and temp files. Hacked in Lëtzebuerg ☺

This was the third try. Where to put this was not palpable… same for =(…)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.164 2010/11/01 17:29:02 tg Exp $");
d2023 1
a2023 1
	char *ccp, *xp = NULL, *wpalloc = NULL;
d2026 1
a2026 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "prsu,")) != -1)
d2028 3
d2059 2
a2060 1
	/* Since we can't necessarily seek backwards on non-regular files,
d2070 2
a2071 1
			/* AT&T ksh says it prints prompt on fd if it's open
d2074 1
a2074 1
			 * as is indicated in the Kornshell book).
d2076 1
a2076 1
			shellf("%s", cp+1);
d2080 2
a2081 1
	/* If we are reading from the co-process for the first time,
a2097 2
			if (c == '\n' || c == EOF)
				break;
d2100 2
d2130 2
a2131 1
						/* set prompt in case this is
d2145 1
a2145 1
			if (c == '\n' || c == EOF)
d2184 4
a2187 3
	/* if this is the co-process fd, close the file descriptor
	 * (can get eof if and only if all processes are have died, ie,
	 * coproc.njobs is 0 and the pipe is closed).
@


1.164
log
@change behaviour of argument-less exit in traps to match SUSv4; Debian #599484 (original patch from Jonathan Nieder, thanks!) in a variant that appears to handle nested traps well
@
text
@d7 2
a8 1
 * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.163 2010/09/15 21:08:18 tg Exp $");
d1178 4
a1181 2
							/* AT&T ksh can't have
							 * justified integers.. */
d3470 1
a3470 2
		bi_errorf("can't allocate %lu data bytes",
		    (unsigned long)MKSH_CAT_BUFSIZ);
@


1.163
log
@revert part of the “size reduction” diff (zero size change though):
shellf() implies an shf_flush()…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.162 2010/09/14 21:26:12 tg Exp $");
d2296 2
a2297 1
	}
@


1.162
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.161 2010/09/05 19:51:33 tg Exp $");
d2068 1
a2068 1
			shf_puts(cp + 1, shl_out);
@


1.161
log
@optimise error messages, option parsing, and make more builtins
recognise "--", costs us 20 .text 0 .data 0 .bss
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.160 2010/08/28 20:22:17 tg Exp $");
d211 1
d281 7
a287 1
			if (pathcnd)
d289 1
d408 1
a408 1
		int ilen, olen, nlen, elen;
d424 6
d2398 1
a2398 1
		l->argv = alloc((l->argc + 2) * sizeof(char *), &l->area);
@


1.160
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.159 2010/08/28 18:50:51 tg Exp $");
d2681 1
a2681 1
		bi_errorf("%s: %s", *wp, strerror(errno));
a2695 7
/* dummy function, special case in comexec() */
int
c_builtin(const char **wp MKSH_A_UNUSED)
{
	return (0);
}

d3393 10
a3402 5
	if (wp == NULL		/* argv */ ||
	    wp[0] == NULL	/* name of builtin */ ||
	    wp[1] == NULL	/* first argument */ ||
	    wp[2] == NULL	/* second argument */ ||
	    wp[3] != NULL	/* no further args please */)
d3404 1
a3404 1
	else if ((rv = rename(wp[1], wp[2])) != 0) {
d3418 5
a3422 13
	if (wp != NULL && wp[0] != NULL && wp[1] != NULL) {
		if (strcmp(wp[1], "--")) {
			if (wp[2] == NULL) {
				wp += 1;
				rv = 0;
			}
		} else {
			if (wp[2] != NULL && wp[3] == NULL) {
				wp += 2;
				rv = 0;
			}
		}
	}
d3424 2
a3425 1
	if (rv)
d3427 1
a3427 1
	else if ((buf = do_realpath(*wp)) == NULL) {
d3429 1
a3429 1
		bi_errorf("%s: %s", *wp, strerror(rv));
d3435 1
d3457 5
a3461 3
	++wp;		/* argv[0] */
	if (wp[0] && wp[0][0] == '-' && wp[0][1] == '-' && wp[0][2] == '\0')
		++wp;	/* "--" (options separator) */
@


1.159
log
@improve string pooling: saves 316 bytes in .text
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.158 2010/08/28 17:21:44 tg Exp $");
d207 1
a207 1
		ipath = shf_smprintf("%s/%s", tp, upath);
d404 1
a404 1
			bi_errorf("don't know current directory");
d524 2
a525 1
		bi_errorf("%s: %s", "can't get current directory", strerror(errno));
d836 1
a836 1
				shf_puts(" function", shl_stdout);
d1061 5
a1065 5
				} else
					fptreef(shl_stdout, 0,
					    f->flag & FKSH ?
					    "function %s %T\n" :
					    "%s() %T\n", wp[i], f->val.t);
d1084 2
a1085 2
					fptreef(shl_stdout, 0, vp->flag & FKSH ?
					    "function %s %T\n" : "%s() %T\n",
d1088 2
a1089 1
					shprintf("%s\n", vp->name);
d2054 1
a2054 1
			shellf("%s", cp+1);
d2141 1
a2141 1
			bi_errorf("%s is read only", *wp);
d2343 1
a2343 1
			warningf(true, "%s: %s %s", wp[0], "cannot", wp[0]);
d2438 1
a2438 1
				bi_errorf("%s is read only", vp->name);
d3357 1
a3357 1
		/* some cannot be read, e.g. Linux RLIMIT_LOCKS */
d3460 1
a3460 1
		bi_errorf("cannot allocate %lu data bytes",
@


1.158
log
@make cat an mksh builtin, for things like here documents
if any options are given, the external programme is invoked instead
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.157 2010/08/24 14:42:01 tg Exp $");
d62 1
a62 1
	{"=builtin", c_builtin},
d69 1
a69 1
	{"*=set", c_set},
d80 1
a80 1
	{"+alias", c_alias},	/* no =: AT&T manual wrong */
d98 1
a98 1
	{"+unalias", c_unalias},
d450 1
a450 1
			bi_errorf("%s: bad directory", dir);
d452 1
a452 1
			bi_errorf("%s - %s", tryp, strerror(errno));
d524 1
a524 1
		bi_errorf("can't get current directory - %s", strerror(errno));
d616 1
a616 1
					bi_errorf("-p: %s", emsg);
d630 1
a630 1
					bi_errorf("-u: %s: %s", s, emsg);
d799 10
d812 1
a812 1
				shf_puts(" is a reserved word", shl_stdout);
d816 3
a818 2
				shprintf(" is an %salias for ",
				    (tp->flag & EXPORT) ? "exported " : null);
d820 1
a820 1
				shprintf("alias %s=", id);
a824 1
				shf_puts(" is a", shl_stdout);
d840 3
a842 2
				shprintf(" is a%s shell builtin",
				    (tp->flag & SPEC_BI) ? " special" : null);
d850 1
a850 1
						shprintf("a tracked %salias for ",
d852 2
a853 1
						    "exported " : null);
d858 1
a858 1
					shf_puts(" not found", shl_stdout);
d1066 1
a1066 1
				bi_errorf("%s: not identifier", wp[i]);
d1135 1
a1135 1
							shf_puts("-n ", shl_stdout);
d1137 1
a1137 1
							shf_puts("-i ", shl_stdout);
d1139 1
a1139 1
							shf_puts("-x ", shl_stdout);
d1141 1
a1141 1
							shf_puts("-r ", shl_stdout);
d1143 1
a1143 1
							shf_puts("-t ", shl_stdout);
d1149 1
a1149 1
							shf_puts("-Z ", shl_stdout);
d1151 1
a1151 1
							shf_puts("-l ", shl_stdout);
d1153 1
a1153 1
							shf_puts("-u ", shl_stdout);
d1155 1
a1155 1
							shf_puts("-U ", shl_stdout);
d1274 1
a1274 1
			"unalias", "-ta", NULL
d1278 2
a1279 2
			shf_puts("alias: -r flag can only be used with -t"
			    " and without arguments\n", shl_stdout);
d1292 1
a1292 1
					shf_puts("alias ", shl_stdout);
d1317 1
a1317 1
					shf_puts("alias ", shl_stdout);
d1325 2
a1326 1
				shprintf("%s alias not found\n", alias);
d1599 2
a1600 2
			bi_errorf("%s: arguments must be jobs or process IDs",
			    p);
d1635 1
a1635 1
		bi_errorf("missing options argument");
d1641 1
a1641 1
		bi_errorf("missing name argument");
d1645 1
a1645 1
		bi_errorf("%s: is not an identifier", var);
d1650 1
a1650 1
		internal_warningf("c_getopts: no argv");
d1793 1
a1793 1
		bi_errorf("%s: bad number", arg);
d2011 1
a2011 1
				bi_errorf("-p: %s", emsg);
d2025 1
a2025 1
				bi_errorf("-u: %s: %s", cp, emsg);
d2256 1
a2256 1
			bi_errorf("bad signal %s", wp[-1]);
d2277 1
a2277 1
			warningf(true, "%s: bad number", arg);
d2322 1
a2322 1
		bi_errorf("%s: bad value", arg);
d2341 1
a2341 1
			warningf(true, "%s: cannot %s", wp[0], wp[0]);
d2367 1
a2367 1
		static const char *args[] = { "set", "-", NULL };
d2566 2
a2567 1
			errorf("time: -%s unknown option", opt.optarg);
d2569 2
a2570 2
			errorf("time: -%s requires an argument",
			    opt.optarg);
d2658 1
a2658 1
			bi_errorf("non-numeric device major '%s'", argv[2]);
d2663 1
a2663 1
			bi_errorf("non-numeric device minor '%s'", argv[3]);
d2668 1
a2668 1
			bi_errorf("device major too large: %lu", majnum);
d2672 1
a2672 1
			bi_errorf("device minor too large: %lu", minnum);
d2688 2
a2689 2
	bi_errorf("usage: mknod [-m mode] name b|c major minor");
	bi_errorf("usage: mknod [-m mode] name p");
d3038 1
a3038 1
			(*te->error)(te, 0, "missing closing paren");
d3298 2
a3299 1
			bi_errorf("usage: ulimit [-acdfHLlmnpSsTtvw] [value]");
d3406 1
a3406 1
		bi_errorf("failed: %s", strerror(rv));
@


1.157
log
@fix realpath builtin’s handling of (source) pathnames with a trailing slash
as per POSIX (if a trailing slash is part of the symlink target it fails as
well, like GNU readlink -f does)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.156 2010/07/17 22:09:34 tg Exp $");
d105 1
d3431 74
@


1.156
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.155 2010/04/27 21:39:08 tg Exp $");
d293 1
a293 1
			tp = shf_smprintf("%s/%s", ldest, ip);
d312 16
@


1.155
log
@address two performance issues in do_realpath():
• avoid calling realloc twice in sequence, since the final
  size is known at the first call already
• do not lstat(2) the same path twice in the Hurd codepath
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.154 2010/04/09 18:59:29 tg Exp $");
d171 1
a171 1
static int ptest_isa(Test_env *, Test_meta);
d339 1
a339 1
	char *dir, *allocd = NULL, *try, *pwd, *cdpath;
d424 1
a424 1
			rv = chdir(try = Xstring(xs, xp) + phys_path);
d427 1
a427 1
			rv = chdir(try = Xstring(xs, xp));
d435 1
a435 1
			bi_errorf("%s - %s", try, strerror(errno));
d2636 1
a2636 1
		if ((unsigned long)major(dv) != majnum) {
d2640 1
a2640 1
		if ((unsigned long)minor(dv) != minnum) {
d3051 2
a3052 1
/* Test if the current token is a whatever. Accepts the current token if
d3056 1
a3056 1
static int
d3063 1
a3063 1
	int rv;
d3066 1
a3066 1
		return (meta == TM_END);
d3071 1
a3071 1
		rv = 0;
d3073 2
a3074 1
		rv = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;
d3077 1
a3077 1
	if (rv)
@


1.154
log
@oksh merge
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.153 2010/03/27 16:51:37 tg Exp $");
d190 8
d242 2
a243 1
		Xcheck(xs, xp);
a246 1
		XcheckN(xs, xp, len + 1);
d279 4
a282 20
#ifdef NO_PATH_MAX
			if (ldest) {
				afree(ldest, ATEMP);
				ldest = NULL;
			}
			{
				struct stat hurd_sb;

				if (lstat(Xstring(xs, xp), &hurd_sb))
					goto notfound;
				ldest = alloc(hurd_sb.st_size + 1, ATEMP);
				if ((llen = readlink(Xstring(xs, xp), ldest,
				    hurd_sb.st_size)) < 0)
					goto notfound;
			}
#else
			if (!ldest)
				ldest = alloc(PATH_MAX + 1, ATEMP);
			if ((llen = readlink(Xstring(xs, xp), ldest,
			    PATH_MAX)) < 0)
a284 1
#endif
d325 3
@


1.153
log
@rework ‘m’ and ‘v’ ulimits; add more (seen at zsh)
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.40 2009/05/05 17:59:55 millert Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.152 2010/03/14 11:58:32 tg Exp $");
d2663 1
a2663 1
	bi_errorf("usage: mknod [-m mode] name [b | c] major minor");
@


1.152
log
@even better on Haiku:
* let ulimits work
* add a Haiku-specific ulimit
* always use UTF-8, they have no locales but a UTF-8 terminal
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.151 2010/02/23 18:13:03 tg Exp $");
d3121 43
a3186 3
#ifdef RLIMIT_RSS
		{ "memory(KiB)", RLIMIT_RSS, 1024, 'm' },
#endif
a3192 3
#ifdef RLIMIT_VMEM
		{ "vmemory(KiB)", RLIMIT_VMEM, 1024, 'v' },
#endif
d3205 37
@


1.151
log
@x_bind cannot have the nonnull attribute
cought by Frank “enstein” Terbeck «ft:#grml» (efftee), 10x
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.150 2010/01/28 15:18:48 tg Exp $");
d3165 3
@


1.150
log
@To solve the incompatibility issues between mksh-current, old mksh versions
and vendor pdksh versions, re-introduce FPOSIX alongside FSH. The semantics
are now:
‣ set -o posix ⇒
  • disable brace expansion and FSH when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
‣ set -o sh ⇒
  • set automatically #ifdef MKSH_BINSHREDUCED
  • disable brace expansion and FPOSIX when triggered
  • use Debian Policy 10.4 compliant non-XSI “echo” builtin
  • do not keep file descriptors > 2 to ksh
  • trigger MKSH_MIDNIGHTBSD01ASH_COMPAT mode if compiled in
  • make “set -- $(getopt ab:c "$@@")” construct work

Note that the set/getopt one used to behave POSIXly only with FSH or
FPOSIX (depending on the mksh version) set and Bourne-ish with it not
set, so this changes default mksh behaviour to POSIX!
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.149 2010/01/25 14:38:01 tg Exp $");
a1685 6
#ifndef MKSH_SMALL
extern int x_bind(const char *, const char *, bool, bool);
#else
extern int x_bind(const char *, const char *, bool);
#endif

@


1.149
log
@remove some debugging code
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.148 2010/01/25 14:11:26 tg Exp $");
d542 1
a542 1
		if (Flag(FSH)) {
d2375 1
d2377 1
a2377 1
	return (Flag(FSH) ? 0 : subst_exstat);
d2576 6
a2581 2
			/* For ksh (but not sh), keep anything > 2 private */
			if (!Flag(FSH) && i > 2 && e->savefd[i])
@


1.148
log
@Add “unset foo[*]” mksh extension, which allows to unset the *contents*
of foo[0] (but not its attributes), and the rest of the array, so that
later “set +A foo bar” will set foo[0]=bar but retain the attributes.

This is important, because, in the future, arrays will have different
attributes per element, instead of all the same (which, actually, is
not entirely true right now either, since “unset foo[0]” will not mo-
dify the attributes of a foo[1] existing at that point in time), where
foo[$newkey] will inherit from foo[0], but typeset foo will only affect
foo[0] no longer foo[*] in the future. (The rules about typeset=local
will still apply, as they affect creation of variables in a scope.)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.147 2009/12/12 22:27:07 tg Exp $");
a2663 4
#if 0
	/* XXX doesn't help */
	builtin_argv0 = NULL;
#endif
@


1.147
log
@re-vamp __attribute__ handling; let this pass on HP-UX bundled compiler
as well as HP aCC
@
text
@d7 1
a7 1
 * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.146 2009/12/05 17:43:46 tg Exp $");
d1669 1
a1669 1
		unset(voptarg, 0);
d2400 15
a2414 1
			struct tbl *vp = global(id);
d2420 1
a2420 1
			unset(vp, vstrchr(id, '[') ? 1 : 0);
@


1.146
log
@llvm/clang scan-build is now content…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.145 2009/12/01 13:12:30 tg Exp $");
d176 2
a177 1
    const char *, const char *) __attribute__((nonnull (6, 7)));
d727 1
a727 1
s_put(int c __unused)
d2426 1
a2426 1
c_times(const char **wp __unused)
d2552 1
a2552 1
c_exec(const char **wp __unused)
d2662 1
a2662 1
c_builtin(const char **wp __unused)
d3079 1
a3079 1
ptest_getopnd(Test_env *te, Test_op op, bool do_eval __unused)
@


1.145
log
@explicit cast, since Bionic headers aren’t type safe, apparently
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.144 2009/11/28 14:28:01 tg Exp $");
d2342 2
a2343 1
	int argi, setargs;
d2357 2
a2358 1
		owp = wp += argi - 1;
@


1.144
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.142 2009/11/09 23:35:09 tg Exp $");
d3269 1
a3269 1
	if (val == RLIM_INFINITY)
@


1.143
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d1554 1
a1554 1
				w = utf_mbswidth(sigtraps[j].mess, true);
@


1.142
log
@make print_columns() aware that octets≠characters≠columns
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.141 2009/10/27 17:00:01 tg Exp $");
d1554 1
a1554 1
				w = utf_mbswidth(sigtraps[j].mess);
@


1.142.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.143 2009/11/28 14:21:44 tg Exp $");
d1554 1
a1554 1
				w = utf_mbswidth(sigtraps[j].mess, true);
@


1.141
log
@do not use PATH_MAX on GNU/Hurd (even if it *was* defined), but use
some glibc-only functions that don’t require its use instead

tested on gnubber, where (admittedly) sysconf(_PC_PATH_MAX) == 1024…
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.140 2009/10/15 16:36:26 tg Exp $");
d174 1
a174 1
static char *kill_fmt_entry(const void *, int, char *, int);
d1470 1
a1470 1
kill_fmt_entry(const void *arg, int i, char *buf, int buflen)
d1541 1
a1541 2
			int w, j;
			int mess_width;
d1546 1
a1546 1
			ki.name_width = mess_width = 0;
d1552 5
a1556 2
				if (w > mess_width)
					mess_width = w;
d1561 3
a1563 1
			    ki.num_width + ki.name_width + mess_width + 3, 1);
@


1.140
log
@fix exit-eval-1 (Debian #550717), sync SUSv4 wording, improve comments
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.139 2009/10/15 16:32:50 tg Exp $");
d270 16
d292 1
d418 4
d423 1
@


1.139
log
@fix utilities-getopts-1 and utilities-getopts-2
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.138 2009/10/15 14:58:51 tg Exp $");
d647 1
a647 1
				}			
d2136 9
a2144 7
	/*
	 * Handle case where the command is empty due to failed
	 * command substitution, eg, eval "$(false)".
	 * In this case, shell() will not set/change exstat (because
	 * compiled tree is empty), so will use this value.
	 * subst_exstat is cleared in execute(), so should be 0 if
	 * there were no substitutions.
d2146 3
a2148 2
	 * A strict reading of POSIX says we don't do this (though
	 * it is traditionally done). [from 1003.2-1992]
d2150 1
a2150 1
	 * 3.9.1: Simple Commands
d2152 8
a2159 7
	 *	continue as described in 3.9.1.1. If there
	 *	is no command name, but the command contained a command
	 *	substitution, the command shall complete with the exit
	 *	status of the last command substitution
	 * 3.9.1.1: Command Search and Execution
	 *	...(1)...(a) If the command name matches the name of
	 *	a special built-in utility, that special built-in
d2161 3
a2163 3
	 * 3.14.5: Eval
	 *	... If there are no arguments, or only null arguments,
	 *	eval shall return an exit status of zero.
d2165 2
a2166 1
	exstat = subst_exstat;
d2339 1
a2339 1
	/*
d2341 2
a2342 1
	 * getopt(1) use the construct: set -- $(getopt ab:c "$@@")
@


1.138
log
@another exit code in substitution questionable thing
split this one by set ±o sh
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.137 2009/10/10 21:17:29 tg Exp $");
d1633 2
a1634 7
	/* AT&T ksh does not change OPTIND if it was an unknown option.
	 * Scripts counting on this are prone to break... (ie, don't count
	 * on this staying).
	 */
	if (optc != '?') {
		user_opt.uoptind = user_opt.optind;
	}
@


1.137
log
@while testing haserl-0.9.26 on MirBSD, I discovered that the echo builtin
in FSH mode did in fact, contrary to POSIX and Debian Policy 10.4 behavi-
our (I think), interpret escape sequences; fix and add testsuite for echo
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.136 2009/10/02 18:08:33 tg Exp $");
d2339 3
a2341 2
	/* POSIX says set exit status is 0, but old scripts that use
	 * getopt(1), use the construct: set -- $(getopt ab:c "$@@")
d2346 1
a2346 1
	return (subst_exstat);
@


1.136
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.135 2009/09/26 03:39:58 tg Exp $");
d510 1
a510 1
	int fd = 1;
d516 3
a518 13
	if (wp[0][0] == 'e') {	/* echo command */
		int nflags = flags;

		/* A compromise between sysV and BSD echo commands:
		 * escape sequences are enabled by default, and
		 * -n, -e and -E are recognised if they appear
		 * in arguments with no illegal options (ie, echo -nq
		 * will print -nq).
		 * Different from sysV echo since options are recognised,
		 * different from BSD echo since escape sequences are enabled
		 * by default.
		 */
		wp += 1;
d520 4
a523 2
			if (*wp && strcmp(*wp, "-n") == 0) {
				flags &= ~PO_NL;
d525 17
a541 2
			}
		} else
d556 1
d562 1
d566 1
d603 1
a616 1
		int c;
d662 1
a662 1
		int n, len = Xlength(xs, xp);
d675 1
a675 2
			n = write(fd, s, len);
			if (n < 0) {
d687 2
a688 2
			s += n;
			len -= n;
@


1.135
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.134 2009/09/23 18:04:56 tg Exp $");
d529 1
a529 1
		if (Flag(FPOSIX)) {
d2413 1
a2413 1
#define TF_POSIX	BIT(2)		/* report in posix format */
d2522 1
a2522 1
			if (!Flag(FPOSIX) && i > 2 && e->savefd[i])
@


1.134
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.133 2009/09/19 21:54:44 tg Exp $");
d97 1
a97 1
	{"=typeset", c_typeset},
d2312 1
a2312 1
		static const char *args [] = { "set", "-", NULL };
@


1.133
log
@$'…' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.132 2009/09/19 19:08:46 tg Exp $");
d1655 6
d1665 4
a1668 1
	bool macro = false, list = false;
d1672 7
a1678 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "lm")) != -1)
d1683 1
d1687 1
d1694 5
a1698 1
		rv = x_bind(NULL, NULL, 0, list);
d1707 5
a1711 1
		if (x_bind(up ? up : *wp, cp, macro, 0))
@


1.132
log
@align with C standard (optional C style); document differences to C style
for print builtin (align with ksh93 ipv GNU bash)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.131 2009/09/19 15:16:02 tg Exp $");
d498 4
d611 4
a614 1
				if ((c = unbksl(&s, false)) == -1) {
d628 1
a628 1
				} else if (c > 0xFF) {
d688 12
@


1.131
log
@new function unbksl doing "backslash expansion" independent of c_print();
also make a separate subsection about it in the manpage
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.130 2009/09/07 17:24:48 tg Exp $");
d607 1
a607 1
				if ((c = unbksl(&s)) == -1) {
@


1.130
log
@another ksh93 feature: test -o ?foo (almost zero cost)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.129 2009/09/06 17:42:12 tg Exp $");
d607 22
a628 12
				int i;

				switch ((c = *s++)) {
				/* Oddly enough, \007 seems more portable than
				 * \a (due to HP-UX cc, Ultrix cc, old PCCs,
				 * etc.).
				 */
				case 'a': c = '\007'; break;
				case 'b': c = '\b'; break;
				case 'c':
					flags &= ~PO_NL;
					/* AT&T brain damage */
d630 1
a630 74
				case 'f': c = '\f'; break;
				case 'n': c = '\n'; break;
				case 'r': c = '\r'; break;
				case 't': c = '\t'; break;
				case 'v': c = 0x0B; break;
				case '0':
					/* Look for an octal number: can have
					 * three digits (not counting the
					 * leading 0). Truly burnt.
					 */
					c = 0;
					for (i = 0; i < 3; i++) {
						if (*s >= '0' && *s <= '7')
							c = c*8 + *s++ - '0';
						else
							break;
					}
					break;
				case 'x':
					/* Look for a hexadecimal number of
					 * up to 2 digits, write raw octet.
					 */
					c = 0;
					for (i = 0; i < 2; i++) {
						c <<= 4;
						if (*s >= '0' && *s <= '9')
							c += *s++ - '0';
						else if (*s >= 'A' && *s <= 'F')
							c += *s++ - 'A' + 10;
						else if (*s >= 'a' && *s <= 'f')
							c += *s++ - 'a' + 10;
						else {
							c >>= 4;
							break;
						}
					}
					break;
				case 'u':
					/* Look for a hexadecimal number of
					 * up to 4 digits, write Unicode.
					 */
					c = 0;
					for (i = 0; i < 4; i++) {
						c <<= 4;
						if (*s >= '0' && *s <= '9')
							c += *s++ - '0';
						else if (*s >= 'A' && *s <= 'F')
							c += *s++ - 'A' + 10;
						else if (*s >= 'a' && *s <= 'f')
							c += *s++ - 'a' + 10;
						else {
							c >>= 4;
							break;
						}
					}
					if (c < 0x80)
						/* Xput below writes ASCII */;
					else if (c < 0x0800) {
						Xput(xs, xp, (c >> 6) | 0xC0);
						c = 0x80 | (c & 0x3F);
						/* leave 2nd octet to below */
					} else {
						Xput(xs, xp, (c >> 12) | 0xE0);
						Xput(xs, xp,
						    ((c >> 6) & 0x3F) | 0x80);
						c = 0x80 | (c & 0x3F);
						/* leave 3rd octet to below */
					}
					break;
				case '\0': s--; c = '\\'; break;
				case '\\': break;
				default:
					Xput(xs, xp, '\\');
				}
@


1.129
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.127.2.1 2009/08/30 20:56:05 tg Exp $");
d2785 1
a2785 1
		if ((i = *opnd1 == '!'))
d2789 1
a2789 2
		s = Flag(k);
		return (i ? !s : s);
@


1.128
log
@add the chdir builtin from mircvs://contrib/hosted/tg/deb/mksh/ for
better dash compatibility (mksh is now a dash superset if printf is
compiled in)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.127 2009/08/30 13:30:07 tg Exp $");
d50 2
d901 1
a901 1
	opts = istset ? "L#R#UZ#afi#lprtux" : "p";
d952 3
d1003 1
a1003 1
	if (func && ((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT))) {
d1005 1
d1010 1
a1010 1
		 * At this point, flags in fset are cleared in fclr and vise
d1024 2
a1025 2
		if (fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
		    INTEGER | INT_U | INT_L))
d1056 1
d1060 1
d1123 2
d1173 1
a1173 3
							    vp->flag & AINDEX ?
							    (unsigned long)vp->ua.index :
							    0);
@


1.127
log
@replace pdksh’s get_phys_path() and do_phys_path() with my new
do_realpath() function – looking fine, review welcome though
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.126 2009/08/30 13:22:38 tg Exp $");
d80 1
@


1.127.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic “typeset -n v=$1” or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.127 2009/08/30 13:30:07 tg Exp $");
a49 2
extern uint8_t set_refflag;

d898 1
a898 1
	opts = istset ? "L#R#UZ#afi#lnprtux" : "p";
a948 3
		case 'n':
			set_refflag = (builtin_opt.info & GI_PLUS) ? 2 : 1;
			break;
d997 1
a997 1
	if (func && (((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT)) || set_refflag)) {
a998 1
		set_refflag = 0;
d1003 1
a1003 1
		 * At this point, flags in fset are cleared in fclr and vice
d1017 2
a1018 2
		if ((fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
		    INTEGER | INT_U | INT_L)) || set_refflag)
a1048 1
				set_refflag = 0;
a1051 1
		set_refflag = 0;
a1113 2
						if (((vp->flag&(ARRAY|ASSOC))==ASSOC))
							shf_puts("-n ", shl_stdout);
d1162 3
a1164 1
							    arrayindex(vp));
@


1.126
log
@add a do_realpath() implementation replacing the use of the external
libc function realpath(3) which may not be available on the target
system; compile the realpath builtin unconditionally

looks fine to me, but review is appreciated; this is (very) lightly
based upon MirBSD libc’s realpath(3) and pdksh’s get_phys_path()
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.125 2009/08/28 21:51:51 tg Exp $");
d420 4
d436 1
a436 2
	} else
	if (!physical || !(pwd = get_phys_path(Xstring(xs, xp))))
d442 1
d482 1
a482 1
	p = current_wd[0] ? (physical ? get_phys_path(current_wd) :
@


1.125
log
@implement "typeset ±a" as no-op
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.124 2009/08/28 21:01:25 tg Exp $");
a104 1
#if HAVE_REALPATH
a105 1
#endif
d174 140
a3264 1
#if HAVE_REALPATH
d3269 1
d3287 7
a3293 8
	else {
		char *buf;

		if (realpath(*wp, (buf = alloc(PATH_MAX, ATEMP))) == NULL) {
			rv = errno;
			bi_errorf("%s: %s", *wp, strerror(rv));
		} else
			shprintf("%s\n", buf);
a3298 1
#endif
@


1.124
log
@… but since I liked the bonus of having the hval stored so much, merge
it with the array index; var.c says that
│ 1244         /* The table entry is always [0] */
so that we can have a special flag and a union which stores hval for
the table index, the array index otherwise (coïncidentally *hint hint*
they have the same size)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.123 2009/08/28 20:30:56 tg Exp $");
d756 1
a756 1
	opts = istset ? "L#R#UZ#fi#lprtux" : "p";
d790 7
@


1.123
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.121 2009/08/28 18:53:58 tg Exp $");
d1013 3
a1015 1
							    (unsigned long)vp->index);
@


1.122
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d640 2
d644 1
a644 1
			tp = ktsearch(&keywords, id, hash(id), NULL);
d646 1
a646 1
			tp = ktsearch(&aliases, id, hash(id), NULL);
d884 1
a884 1
				    (fset&UCASEV_AL) ? true : false, NULL);
d1143 1
a1143 1
			ap = ktsearch(t, alias, h, NULL);
d1159 1
a1159 1
		ap = ktenter(t, alias, h, NULL);
d1219 1
a1219 1
		ap = ktsearch(t, *wp, hash(*wp), NULL);
@


1.121
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.120 2009/08/08 13:08:50 tg Exp $");
d642 1
a642 1
			tp = ktsearch(&keywords, id, hash(id));
d644 1
a644 1
			tp = ktsearch(&aliases, id, hash(id));
d882 1
a882 1
				    (fset&UCASEV_AL) ? true : false);
d1141 1
a1141 1
			ap = ktsearch(t, alias, h);
d1157 1
a1157 1
		ap = ktenter(t, alias, h);
d1217 1
a1217 1
		ap = ktsearch(t, *wp, hash(*wp));
@


1.120
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.119 2009/07/30 19:11:11 tg Exp $");
d1133 1
a1133 1
		int h;
@


1.119
log
@"official" but unsupported printf-as-builtin code, cleaner API than
in the branch; USE_PRINTF_BUILTIN=1 to enable it (Build.sh + Makefile)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.118 2009/07/25 21:31:25 tg Exp $");
d1632 1
a1632 1
		old_umask = umask(0);
d1667 1
a1667 1
			old_umask = umask(0);
d1981 1
a1981 1
	char savef;
d2405 1
a2405 1
			mode = getmode(set, DEFFILEMODE);
d2423 1
a2423 1
		oldmode = umask(0);
d2626 3
a2628 7
			k = 0;
		else {
			k = Flag(k);
			if (i)
				k = !k;
		}
		return (k);
@


1.118
log
@* improve CPPFLAGS vs #define handling again: do not touch CPPFLAGS from
  Build.sh but use 'if defined(PRECOND) && !defined(TOBEDEFINED)'if possible
* for all of the source code, drop annotations "imake style" (if we check
  for specific OSes, bad, instead of using mirtoconf checks proper) and
  "conditions correct?" (if I'm not entirely sure if that #if catches all
  cases and no false positives) where I can see it by grepping immediately
* bump mksh patchlevel
* refresh Makefiles
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.117 2009/07/25 20:35:22 tg Exp $");
d89 3
@


1.117
log
@another duplicate defn avoidance
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.116 2009/07/25 20:26:32 tg Exp $");
d41 1
@


1.116
log
@improve MKSH_NOPWNAM handling, whether MKSH_SMALL or not; it will cause
the entire ~fac/ expansion code to be omitted
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.115 2009/06/11 12:42:18 tg Exp $");
d41 1
a41 1
#ifndef RLIM_INFINITY
@


1.115
log
@capitalise AT&T®
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.114 2009/06/10 18:12:46 tg Exp $");
d1051 2
a1052 2
#ifdef MKSH_SMALL
			return (0);
d1080 4
d1194 2
a1195 2
#ifdef MKSH_SMALL
			return (0);
d1206 4
@


1.115.2.1
log
@prepare for another stab at having a printf(1) builtin in mksh(1) again,
since people like Md aren't, ever, going to see the light, I suppose...

API:
#ifdef MKSH_PRINTF_BUILTIN
void mksh_flush(void);
extern int c_printf(const char **);
^-> must call mksh_flush() first, then process as usual (calling main),
    then call fflush(NULL) again, then return; MUST NOT exit/abort/err!
#endif

XXX still need to think at how to embed it in portable mksh
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.115 2009/06/11 12:42:18 tg Exp $");
a48 12
#ifdef MKSH_PRINTF_BUILTIN
extern int c_printf(const char **);

void mksh_flush(void);
void
mksh_flush(void)
{
	shf_flush(shl_stdout);
	shf_flush(shl_out);
}
#endif

a87 3
#ifdef MKSH_PRINTF_BUILTIN
	{"printf", c_printf},
#endif
@


1.114
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.113 2009/06/10 18:11:26 tg Exp $");
d77 1
a77 1
	{"+alias", c_alias},	/* no =: at&t manual wrong */
d282 1
a282 1
	 * setting in at&t ksh)
d754 1
a754 1
	/* at&t ksh seems to have 0-9 as options which are multiplied
d774 1
a774 1
			/* at&t ksh uses u, but this conflicts with
d880 1
a880 1
					/* at&t ksh does ++rv: bogus */
d952 1
a952 1
						/* at&t ksh prints things
d984 1
a984 1
							/* at&t ksh can't have
d1014 1
a1014 1
							/* at&t ksh can't have
d1157 1
a1157 1
			/* ignore values for -t (at&t ksh does this) */
d1238 1
a1238 1
	if (wp[1] == NULL) /* at&t ksh does this */
d1487 1
a1487 1
		/* POSIX says var is set to ? at end-of-options, at&t ksh
d1494 1
a1494 1
	/* at&t ksh does not change OPTIND if it was an unknown option.
d1503 1
a1503 1
	voptarg->flag &= ~RDONLY;	/* at&t ksh clears ro and int */
d1843 1
a1843 1
			/* at&t ksh says it prints prompt on fd if it's open
d1856 1
a1856 1
	 * This is not compatible with at&t ksh... the fd is kept so another
d2112 1
a2112 1
		/* at&t ksh does this for non-interactive shells only - weird */
d2127 1
a2127 1
		/* at&t ksh doesn't print a message - just does what it
d2271 1
a2271 1
		 * cpu usage of t->left. at&t ksh does the former, while
@


1.113
log
@Save another couple of bytes in the !ulimit case
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.112 2009/06/08 20:52:27 tg Exp $");
d171 1
a171 2
    const char *, const char *)
    __attribute__((nonnull (6, 7)));
d467 4
a470 2
				case 'c': flags &= ~PO_NL;
					  continue; /* AT&T brain damage */
d479 1
a479 1
					 * leading 0).  Truly burnt.
d563 1
a563 1
		 * a coprocess.  at&t ksh doesn't seem to do this (seems
d628 1
a628 1
		 * or whence -pv.  This should be considered a feature.
d714 1
a714 1
	/* Let c_whence do the work.  Note that c_command() must be
d756 1
a756 1
	 * sets right justify in a field of 12).  This allows options
d775 1
a775 1
			 * upper/lower case.  If this option is changed,
d849 1
a849 1
		 * versa.  This property should be preserved.
d1687 11
a1697 7
					case 'u': new_val |= old_umask >> 6;
						  break;
					case 'g': new_val |= old_umask >> 3;
						  break;
					case 'o': new_val |= old_umask >> 0;
						  break;
					case 'X': if (old_umask & 0111)
d1699 4
a1702 3
						  break;
					case 's': /* ignored */
						  break;
d1853 1
a1853 1
	 * make sure the other side of the pipe is closed first.  This allows
d1858 1
a1858 1
	 * can't be detected...  This is why it is closed here.
d1987 2
a1988 1
	 *    3.9.1: Simple Commands
d1990 1
a1990 1
	 *	continue as described in 3.9.1.1.  If there
d1994 1
a1994 1
	 *    3.9.1.1: Command Search and Execution
d2128 1
a2128 1
		 * can.  We print a message 'cause it helps in debugging
d2136 1
a2136 1
		 * shall be used.  Doesn't say to print an error but we
d2858 2
a2859 2
/* Test if the current token is a whatever.  Accepts the current token if
 * it is.  Returns 0 if it is not, non-zero if it is (in the case of
d3094 5
a3098 5
	if (wp == NULL /* argv */ ||
	    wp[0] == NULL /* name of builtin */ ||
	    wp[1] == NULL /* first argument */ ||
	    wp[2] == NULL /* second argument */ ||
	    wp[3] != NULL /* no further args please */)
@


1.112
log
@Add MKSH_NO_LIMITS, to define which has the same effect as the
absence of RLIM_INFINITY, namely make c_ulimit() into a true
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.111 2009/06/08 20:34:39 tg Exp $");
d45 4
d1563 1
a1563 1
/* :, false and true */
a2913 1
#endif
a2917 1
#ifndef MKSH_NO_LIMITS
a3013 1
#endif
a3016 1
#ifndef MKSH_NO_LIMITS
@


1.111
log
@• Check if killpg(3) is available; if not, use kill(2) with negative
  process ID and hope it works (is POSIXly killpg-endowed)
• bump version
• sync clog
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.110 2009/06/08 20:06:46 tg Exp $");
d41 4
d2897 1
a2897 1
#ifdef RLIM_INFINITY
d2915 1
a2915 1
#ifdef RLIM_INFINITY
d3016 1
a3016 1
#ifdef RLIM_INFINITY
@


1.110
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d28 12
a39 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.109 2009/05/21 14:28:33 tg Exp $");
d1404 1
a1404 4
			/* use killpg if < -1 since -1 does special things for
			 * some non-killpg-endowed kills
			 */
			if ((n < -1 ? killpg(-n, sig) : kill(n, sig)) < 0) {
@


1.109
log
@pgas mentioned ksh93 does [[ $foo ]] (ipv forced [[ -n $foo ]])
and it actually REDUCES code size to allow it as well; mention
in the manpage that it’s merely unportable (and of course exe-
cution time differs); sync clog
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.108 2009/05/20 10:10:01 tg Exp $");
d175 1
a175 1
			return 1;
d181 1
a181 1
		return 1;
d191 1
a191 1
			return 1;
d202 1
a202 1
				return 1;
d213 1
a213 1
			return 1;
d222 1
a222 1
			return 1;
d235 1
a235 1
		return 1;
d257 1
a257 1
		return 1;
d291 1
a291 1
	return 0;
d310 1
a310 1
			return 1;
d316 1
a316 1
		return 1;
d328 1
a328 1
	return 0;
d402 1
a402 1
					return 1;
d416 1
a416 1
					return 1;
d420 1
a420 1
				return 1;
d563 1
a563 1
				return 1;
d572 1
a572 1
	return 0;
d597 1
a597 1
			return 1;
d687 1
a687 1
	return rv;
d697 1
a697 1
	return c_whence(wp);
d794 1
a794 1
			return 1;
d809 1
a809 1
		return 1;
d812 1
a812 1
		return 1;
d824 1
a824 1
		return 1;
d874 1
a874 1
				return 1;
d877 1
a877 1
		return rv;
d1014 1
a1014 1
	return 0;
d1057 1
a1057 1
			return 1;
d1079 1
a1079 1
			return 1;
d1082 1
a1082 1
		return c_unalias(args);
d1153 1
a1153 1
	return rv;
d1180 1
a1180 1
			return 1;
d1209 1
a1209 1
	return rv;
d1227 1
a1227 1
	return rv;
d1250 1
a1250 1
			return 1;
d1261 1
a1261 1
	return rv;
d1273 1
a1273 1
		return 1;
d1276 1
a1276 1
		return 1;
d1283 1
a1283 1
	return bg ? 0 : rv;
d1298 1
a1298 1
	return buf;
d1314 1
a1314 1
			return 1;
d1329 1
a1329 1
					return 1;
d1333 1
a1333 1
				return 1;
d1344 1
a1344 1
		return 1;
d1351 1
a1351 1
					return 1;
d1380 1
a1380 1
		return 0;
d1402 1
a1402 1
	return rv;
d1423 1
a1423 1
		return 1;
d1429 1
a1429 1
		return 1;
d1435 1
a1435 1
		return 1;
d1439 1
a1439 1
		return 1;
d1444 1
a1444 1
		return 1;
d1459 1
a1459 1
		return 1;
d1505 1
a1505 1
	return optc < 0 ? 1 : rv;
d1525 1
a1525 1
			return 1;
d1544 1
a1544 1
	return rv;
d1551 1
a1551 1
	return wp[0][0] == 'f' ? 1 : 0;
d1563 1
a1563 1
		return 1;
d1582 1
a1582 1
	return 0;
d1599 1
a1599 1
			return 1;
d1631 1
a1631 1
				return 1;
d1702 1
a1702 1
				return 1;
d1754 1
a1754 1
		return 1;
d1766 1
a1766 1
	return rv;
d1786 1
a1786 1
				return 1;
d1800 1
a1800 1
				return 1;
d1804 1
a1804 1
			return 1;
d1915 1
a1915 1
			return 1;
d1922 1
a1922 1
			return 1;
d1940 1
a1940 1
	return ecode ? ecode : c == EOF;
d1951 1
a1951 1
		return 1;
d1998 1
a1998 1
		return 1;
d2008 1
a2008 1
		return 0;
d2025 1
a2025 1
			return 1;
d2029 1
a2029 1
	return 0;
d2039 1
a2039 1
		return 1;
d2080 1
a2080 1
		return 1;
d2086 1
a2086 1
		return 1;
d2091 1
a2091 1
		return 1;
d2110 1
a2110 1
			return 0;
d2135 1
a2135 1
		return c_typeset(args);
d2140 1
a2140 1
		return 1;
d2148 1
a2148 1
		l->argv = alloc((l->argc + 2) * sizeof (char *), &l->area);
d2158 1
a2158 1
	return subst_exstat;
d2224 1
a2224 1
	return 0;
d2349 1
a2349 1
	return 0;
d2446 1
a2446 1
	return 0;
d2490 1
a2490 1
			return T_ERR_EXIT;
d2510 1
a2510 1
				return !0;
d2518 1
a2518 1
						return T_ERR_EXIT;
d2521 1
a2521 1
					return !res;
d2534 1
a2534 1
				return !res;
d2544 1
a2544 1
	return test_parse(&te);
d2562 1
a2562 1
				return tbl->op_num;
d2564 1
a2564 1
	return TO_NONOP;
d2577 1
a2577 1
		return 0;
d2584 1
a2584 1
		return *opnd1 != '\0';
d2586 1
a2586 1
		return *opnd1 == '\0';
d2597 1
a2597 1
		return k;
d2599 1
a2599 1
		return test_eaccess(opnd1, R_OK) == 0;
d2601 1
a2601 1
		return test_eaccess(opnd1, W_OK) == 0;
d2603 1
a2603 1
		return test_eaccess(opnd1, X_OK) == 0;
d2606 1
a2606 1
		return stat(opnd1, &b1) == 0;
d2608 1
a2608 1
		return stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode);
d2610 1
a2610 1
		return stat(opnd1, &b1) == 0 && S_ISDIR(b1.st_mode);
d2612 1
a2612 1
		return stat(opnd1, &b1) == 0 && S_ISCHR(b1.st_mode);
d2614 1
a2614 1
		return stat(opnd1, &b1) == 0 && S_ISBLK(b1.st_mode);
d2616 1
a2616 1
		return stat(opnd1, &b1) == 0 && S_ISFIFO(b1.st_mode);
d2618 1
a2618 1
		return lstat(opnd1, &b1) == 0 && S_ISLNK(b1.st_mode);
d2620 1
a2620 1
		return stat(opnd1, &b1) == 0 && S_ISSOCK(b1.st_mode);
d2622 1
a2622 1
		return 0;
d2624 2
a2625 2
		return stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISUID) == S_ISUID;
d2627 2
a2628 2
		return stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISGID) == S_ISGID;
d2631 2
a2632 2
		return stat(opnd1, &b1) == 0 &&
		    (b1.st_mode & S_ISVTX) == S_ISVTX;
d2637 1
a2637 1
		return stat(opnd1, &b1) == 0 && b1.st_size > 0L;
d2646 1
a2646 1
		return stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid;
d2648 1
a2648 1
		return stat(opnd1, &b1) == 0 && b1.st_gid == getegid();
d2654 2
a2655 2
			return gmatchx(opnd1, opnd2, false);
		return strcmp(opnd1, opnd2) == 0;
d2658 2
a2659 2
			return !gmatchx(opnd1, opnd2, false);
		return strcmp(opnd1, opnd2) != 0;
d2661 1
a2661 1
		return strcmp(opnd1, opnd2) < 0;
d2663 1
a2663 1
		return strcmp(opnd1, opnd2) > 0;
d2674 1
a2674 1
			return 1;
d2694 1
a2694 1
		return stat(opnd1, &b1) == 0 &&
d2696 1
a2696 1
		    b1.st_mtime > b2.st_mtime) || s < 0);
d2701 1
a2701 1
		return stat(opnd2, &b2) == 0 &&
d2703 1
a2703 1
		    b1.st_mtime < b2.st_mtime) || s < 0);
d2705 2
a2706 2
		return stat (opnd1, &b1) == 0 && stat (opnd2, &b2) == 0 &&
		    b1.st_dev == b2.st_dev && b1.st_ino == b2.st_ino;
d2709 1
a2709 1
	return 1;
d2729 1
a2729 1
	return rv;
d2742 1
a2742 1
	return (te->flags & TEF_ERROR) ? T_ERR_EXIT : !rv;
d2753 2
a2754 2
		return test_oexpr(te, do_eval) || rv;
	return rv;
d2765 2
a2766 2
		return test_aexpr(te, do_eval) && rv;
	return rv;
d2773 2
a2774 2
		return !test_nexpr(te, do_eval);
	return test_primary(te, do_eval);
d2785 1
a2785 1
		return 0;
d2789 1
a2789 1
			return 0;
d2792 1
a2792 1
			return 0;
d2794 1
a2794 1
		return rv;
d2807 1
a2807 1
				return 0;
d2810 1
a2810 1
			return (*te->eval)(te, op, opnd1, NULL, do_eval);
d2816 1
a2816 1
		return 0;
d2823 1
a2823 1
			return 0;
d2826 1
a2826 1
		return (*te->eval)(te, op, opnd1, opnd2, do_eval);
d2828 1
a2828 1
	return (*te->eval)(te, TO_STNZE, opnd1, NULL, do_eval);
d2849 1
a2849 1
		return meta == TM_END;
d2862 1
a2862 1
	return rv;
d2869 2
a2870 2
		return op == TO_FILTT ? "1" : NULL;
	return *te->pos.wp++;
@


1.108
log
@commit Syllable-related improvement: simplify p_time
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.107 2009/05/16 18:40:06 tg Exp $");
a2827 4
	if (te->flags & TEF_DBRACKET) {
		(*te->error)(te, -1, "missing expression operator");
		return 0;
	}
@


1.107
log
@• remove “#if 0” and “#ifdef notdef” style old debugging code
• expose “#ifdef MKSH_MIDNIGHTBSD01ASH_COMPAT” just in case they decide to
  require it and show it in the ksh version automatically
• sync the use of non-ASCII characters over files (unification)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.106 2009/05/16 17:33:10 tg Exp $");
d151 3
a153 2
static void p_time(struct shf *, int, struct timeval *, int,
    const char *, const char *);
d2195 1
a2195 1
p_time(struct shf *shf, int posix, struct timeval *tv, int width,
d2198 1
d2200 2
a2201 2
		shf_fprintf(shf, "%s%*ld.%02d%s", prefix ? prefix : "",
		    width, (long)tv->tv_sec, (int)tv->tv_usec / 10000, suffix);
d2203 2
a2204 3
		shf_fprintf(shf, "%s%*ldm%d.%02ds%s", prefix ? prefix : "",
		    width, (long)tv->tv_sec / 60, (int)tv->tv_sec % 60,
		    (int)tv->tv_usec / 10000, suffix);
d2213 4
a2216 2
	p_time(shl_stdout, 0, &usage.ru_utime, 0, NULL, " ");
	p_time(shl_stdout, 0, &usage.ru_stime, 0, NULL, "\n");
d2219 4
a2222 2
	p_time(shl_stdout, 0, &usage.ru_utime, 0, NULL, " ");
	p_time(shl_stdout, 0, &usage.ru_stime, 0, NULL, "\n");
d2277 2
a2278 1
			p_time(shl_out, 1, &tv1, 5, "real ", "\n");
d2280 2
a2281 1
			p_time(shl_out, 0, &tv1, 5, NULL, " real ");
d2284 2
a2285 1
		p_time(shl_out, 1, &usrtime, 5, "user ", "\n");
d2287 2
a2288 1
		p_time(shl_out, 0, &usrtime, 5, NULL, " user ");
d2290 2
a2291 1
		p_time(shl_out, 1, &systime, 5, "sys  ", "\n");
d2293 2
a2294 1
		p_time(shl_out, 0, &systime, 5, NULL, " system\n");
@


1.106
log
@apply most of OpenBSD’s
│ Fix usage string for mknod builtin.
but don’t do a binary change as it doesn’t actually change anything

XXX fix all these usages anyway
XXX cd: cd: /home/tg/... - No such file or directory
XXX /bin/mksh: mknod: usage: mknod [-m mode] name [b | c] major minor
XXX /bin/mksh: mknod: mknod: No such file or directory
XXX etc. – but find out what POSuX demands ☹
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.105 2009/05/16 16:59:35 tg Exp $");
d2422 1
a2422 1
	/* XXX doesn’t help */
@


1.105
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.39 2009/01/29 23:27:26 jaredy Exp $	*/
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.104 2009/04/07 19:51:46 tg Exp $");
d2367 1
a2367 1
	if (argv[0] == '\0')
d2421 4
@


1.104
log
@tabs, bools
@
text
@d6 20
d28 1
a28 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.103 2009/04/05 12:35:30 tg Exp $");
@


1.103
log
@fix jobless mksh so much to make it work on Minix 3
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.102 2009/04/03 09:45:23 tg Exp $");
d75 2
a76 2
	char	op_text[4];
	Test_op	op_num;
d2470 1
a2470 1
		Test_op	op;
@


1.102
log
@make {get,set}rlimit code depend on RLIM_INFINITY existence (PW32, Minix 3)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.101 2009/04/03 09:39:05 tg Exp $");
d54 1
d57 1
d1243 1
d1264 1
@


1.101
log
@(experimental) implement getrusage via times if not found
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.100 2009/03/22 18:28:34 tg Exp $");
d2850 1
d2863 1
d2868 1
d2965 1
d2969 1
d3033 1
@


1.100
log
@sync; fold oksh-seterror test into errexit-*; use print not printf
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.99 2009/03/22 17:58:58 tg Exp $");
d2187 1
a2187 2
#ifdef RUSAGE_SELF
	(void) getrusage(RUSAGE_SELF, &usage);
a2189 1
#endif
d2191 1
a2191 2
#ifdef RUSAGE_CHILDREN
	(void) getrusage(RUSAGE_CHILDREN, &usage);
a2193 1
#endif
a2206 3
#if !defined(RUSAGE_SELF) || !defined(RUSAGE_CHILDREN)
	return (0);
#else
a2262 1
#endif
@


1.99
log
@   Revision  1.18: [7]download - view: [8]text, [9]markup, [10]annotated -
   [11]select for diffs
   Sun Mar 1 20:11:06 2009 UTC (2 weeks, 6 days ago) by otto
   Branches: [12]MAIN
   CVS tags: [13]HEAD
   Diff to: previous 1.17: [14]preferred, [15]coloured
   Changes since revision 1.17: +17 -9 lines
Fix PR #[16]723: [17]test(1) operator precedence inconsistent with POSIX
Make sure ksh builtin test and [18]test(1) do not differ.
From Christiano Farina Haesbaert. ok miod@@
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.98 2009/03/22 17:53:50 tg Exp $");
d2770 1
a2770 1
	    !test_isop(te, TM_BINOP, te->pos.wp[1]))) {
@


1.98
log
@   Revision  1.33: [7]download - view: [8]text, [9]markup, [10]annotated -
   [11]select for diffs
   Sat Feb 7 14:03:24 2009 UTC (6 weeks, 1 day ago) by kili
   Branches: [12]MAIN
   CVS tags: [13]OPENBSD_4_5_BASE, [14]OPENBSD_4_5, [15]HEAD
   Diff to: previous 1.32: [16]preferred, [17]coloured
   Changes since revision 1.32: +2 -2 lines

Ensure that *wp isn't NULL.

ok otto@@
@
text
@d3 1
a3 1
/*	$OpenBSD: c_test.c,v 1.17 2005/03/30 17:16:37 deraadt Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.97 2009/03/22 17:52:48 tg Exp $");
d2765 15
a2779 6
	if ((op = (*te->isa)(te, TM_UNOP))) {
		/* unary expression */
		opnd1 = (*te->getopnd)(te, op, do_eval);
		if (!opnd1) {
			(*te->error)(te, -1, "missing argument");
			return 0;
a2780 2

		return (*te->eval)(te, op, opnd1, NULL, do_eval);
@


1.97
log
@revision 1.32
date: 2009/02/07 07:24:37;  author: guenther;  state: Exp;  lines: +24 -17
Make built-in echo behave according to POSIX when set -o posix is in effect:
the only option is -n, and only one of those is parsed.

diff from Ingo Schwarze
ok otto@@ kili@@; manpage changes ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.32 2009/02/07 07:24:37 guenther Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.96 2009/03/22 17:47:36 tg Exp $");
d336 1
a336 1
			if (strcmp(*wp, "-n") == 0) {
@


1.96
log
@patch from oksh (except manpage, I'll merge that later):

pass "xerrok" status across the execution call stack to more closely
match what both POSIX and [18]ksh.1 already describe in regards to set
-e/errexit's behavior in determining when to exit from nonzero return
values.

specifically, the truth values tested as operands to &&' and ||', as
well as the resulting compound expression itself, along with the truth
value resulting from a negated command (i.e. a pipeline prefixed !'),
should not make the shell exit when -e is in effect.

issue reported by matthieu.
testing matthieu, naddy.
ok miod (earlier version), otto.
man page ok jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.31 2008/05/17 23:31:52 sobrado Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.95 2009/03/15 16:13:39 tg Exp $");
d335 21
a355 12
		while ((s = *wp) && *s == '-' && s[1]) {
			while (*++s)
				if (*s == 'n')
					nflags &= ~PO_NL;
				else if (*s == 'e')
					nflags |= PO_EXPAND;
				else if (*s == 'E')
					nflags &= ~PO_EXPAND;
				else
					/* bad option: don't use nflags, print
					 * argument
					 */
d357 3
a359 5
			if (*s)
				break;
			wp++;
			flags = nflags;
		}
@


1.95
log
@sprinkle a few static and clean up the internal APIs
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.38 2008/07/23 16:34:38 jaredy Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.94 2009/03/14 18:12:52 tg Exp $");
d2199 1
a2199 1
timex(struct op *t, int f)
d2225 1
a2225 1
		rv = execute(t->left, f | XTIME);
@


1.94
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.93 2008/12/13 17:02:14 tg Exp $");
d1498 1
a1498 1
		rv = x_bind((char*)NULL, (char*)NULL, 0, list);
@


1.93
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.92 2008/11/12 00:54:48 tg Exp $");
d1186 1
a1186 1
	long val;
d1527 1
a1527 1
	long val;
d2536 1
a2536 1
	long v1, v2;
d2968 1
a2968 1
		long rval;
@


1.92
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.91 2008/11/12 00:27:55 tg Exp $");
d205 1
a205 1
		dir = allocd = alloc(1, ilen + nlen + elen, ATEMP);
d2114 1
a2114 1
			strdupx(*wp, *wp, l->areap);
d2116 1
a2116 1
		l->argv = alloc(l->argc + 2, sizeof (char *), l->areap);
d3067 1
a3067 1
		if (realpath(*wp, (buf = alloc(1, PATH_MAX, ATEMP))) == NULL) {
@


1.92.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.92 2008/11/12 00:54:48 tg Exp $");
d174 1
a174 1
			gfree(allocd, ATEMP);
d205 1
a205 1
		dir = allocd = galloc(1, ilen + nlen + elen, ATEMP);
d233 1
a233 1
		gfree(allocd, ATEMP);
d267 1
a267 1
	gfree(allocd, ATEMP);
d304 1
a304 1
	gfree(allocd, ATEMP);
d1105 1
a1105 1
				gfree(ap->val.s, APERM);
d1120 1
a1120 1
		gfree(xalias, ATEMP);
d1162 1
a1162 1
			gfree(ap->val.s, APERM);
d1173 1
a1173 1
				gfree(ap->val.s, APERM);
d1509 1
a1509 1
		gfree(up, ATEMP);
d1882 1
a1882 1
			gfree(wpalloc, ATEMP);
d1889 1
a1889 1
			gfree(wpalloc, ATEMP);
d1907 1
a1907 1
	gfree(wpalloc, ATEMP);
d1954 1
a1954 1
	gfree(s, ATEMP);
d2114 1
a2114 1
			strdupx(*wp, *wp, l->gp_block);
d2116 1
a2116 1
		l->argv = galloc(l->argc + 2, sizeof (char *), l->gp_block);
d2289 1
a2289 1
			gfree(wp[i], ATEMP);
d3067 1
a3067 1
		if (realpath(*wp, (buf = galloc(1, PATH_MAX, ATEMP))) == NULL) {
d3072 1
a3072 1
		gfree(buf, ATEMP);
@


1.91
log
@isolate all knowledge of the area-based allocator from the rest of the code

cost: bss -= (0, 0, 16, 16); text += (520, 504, 516, 480)
[ gcc,pcc X full,small ]
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.90 2008/10/28 14:32:40 tg Exp $");
d205 1
a205 1
		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
d1105 1
a1105 1
				afree((void*)ap->val.s, APERM);
d1162 1
a1162 1
			afree((void*)ap->val.s, APERM);
d1173 1
a1173 1
				afree((void*)ap->val.s, APERM);
d2116 1
a2116 2
		l->argv = (const char **)alloc(sizeofN(char *, l->argc+2),
		     l->areap);
d3067 1
a3067 1
		if (realpath(*wp, (buf = alloc(PATH_MAX, ATEMP))) == NULL) {
@


1.90
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.89 2008/09/30 19:25:50 tg Exp $");
d2114 1
a2114 1
			strdupx(*wp, *wp, &l->area);
d2117 1
a2117 1
		     &l->area);
@


1.89
log
@ignore more dups
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.88 2008/09/30 17:49:25 tg Exp $");
d172 2
a173 1
		if (ksh_isdash((dir = allocd = str_save(wp[0], ATEMP)))) {
d1078 2
a1079 2
			h = val++ - alias;
			alias = xalias = str_nsave(alias, h, ATEMP);
d1110 1
a1110 1
				ap->val.s = str_save(newval, APERM);
d1504 1
a1504 1
			up = str_save(*wp, ATEMP);
d1785 1
a1785 1
		wpalloc = str_save(*wp, ATEMP);
d2114 1
a2114 1
			*wp = str_save(*wp, &l->area);
@


1.88
log
@däs isch ei buul, koa int…
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.87 2008/09/17 19:31:29 tg Exp $");
d505 1
a505 2
		source->line++;
		histsave(source->line, Xstring(xs, xp), true);
d1896 1
a1896 2
		source->line++;
		histsave(source->line, Xstring(xs, xp), true);
@


1.87
log
@• bring back automatic turn-on of FPOSIX if called as sh/-sh
  ‣ only if !MKSH_SMALL
  ‣ add appropriate regression test
• if FPOSIX is set, do not close fds > 2 on exec, Debian #499139
• add appropriate regression tests for keeping fds private or not
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.86 2008/08/02 17:45:11 tg Exp $");
d506 1
a506 1
		histsave(source->line, Xstring(xs, xp), 1);
d1898 1
a1898 1
		histsave(source->line, Xstring(xs, xp), 1);
@


1.86
log
@• merge final version of the stack-free diff as committed by jaredy@@openbsd
  thanks for helping with the bug
• merge RCS IDs
• bump mksh version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.85 2008/07/14 12:29:05 tg Exp $");
d2311 2
a2312 2
			/* For ksh keep anything > 2 private */
			if (i > 2 && e->savefd[i])
@


1.85
log
@fix attempt to free pointer to stack (function-local storage)
discovered by Elias Pipping
patch by Jared Yanovich
alloc/afree checker by Todd C. Miller
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.37 2007/09/03 13:54:23 otto Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.84 2008/07/12 16:56:39 tg Exp $");
d2228 2
a2229 1
		tf |= t->left->str[0];
@


1.84
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.83 2008/06/08 17:16:25 tg Exp $");
a2211 1
	char opts[1];
a2226 3
		if (t->left->type == TCOM)
			t->left->str = opts;
		opts[0] = 0;
d2228 1
a2228 1
		tf |= opts[0];
@


1.83
log
@fix the RCS IDs
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.82 2008/06/08 17:15:29 tg Exp $");
d1077 4
a1080 2
		if ((val = cstrchr(alias, '=')))
			alias = xalias = str_nsave(alias, val++ - alias, ATEMP);
d1108 1
a1108 2
			newval = tflag ? search(alias, path, X_OK, NULL) :
			    val;
@


1.82
log
@• more usage fixes, inspired by sobrado
• bump mksh patchlevel
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.30 2007/08/02 10:50:25 fgsch Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.81 2008/05/17 18:46:58 tg Exp $");
@


1.81
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.80 2008/05/17 18:27:55 tg Exp $");
d1306 3
a1308 3
		shf_fprintf(shl_out,
		    "Usage: kill [ -s signame | -signum | -signame ] {pid|job}...\n"
		    "       kill -l [exit_status]\n");
@


1.80
log
@add new builtin “realpath” calling realpath(3) on its argument, skipping
over “--” for compatibility to Debian realpath(1) and possibly busybox’

“sounds handy” replaced@@TNF
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.79 2008/04/22 18:58:20 tg Exp $");
d141 1
a141 2
	char *dir, *try, *pwd, *cdpath;
	bool dir_ = false;
d172 3
a174 3
		dir = str_save(wp[0], ATEMP);
		if (ksh_isdash(dir)) {
			afree(dir, ATEMP);
d181 1
a181 2
		} else
			dir_ = true;
d204 1
a204 2
		dir = alloc(ilen + nlen + elen, ATEMP);
		dir_ = true;
d232 1
a232 1
		afreechv(dir_, dir);
d266 1
a266 1
	afreechv(dir_, dir);
d275 1
a275 2
	char *p;
	bool p_ = false;
d294 2
a295 2
	p = current_wd[0] ? (physical ? get_phys_path(current_wd) : current_wd) :
	    NULL;
d298 3
a300 7
	if (!p) {
		if (!(p = ksh_get_wd(NULL))) {
			bi_errorf("can't get current directory - %s",
			    strerror(errno));
			return 1;
		}
		p_ = true;
d303 1
a303 1
	afreechv(p_, p);
d1119 1
a1119 1
		afreechk(xalias);
d1508 1
a1508 1
		afreechk(up);
d1881 1
a1881 1
			afreechk(wpalloc);
d1888 1
a1888 1
			afreechk(wpalloc);
d1907 1
a1907 1
	afreechk(wpalloc);
d2116 1
a2116 1
		l->argv = (const char **) alloc(sizeofN(char *, l->argc+2),
d3071 1
a3071 2
		buf = alloc(PATH_MAX, ATEMP);
		if (realpath(*wp, buf) == NULL) {
@


1.79
log
@take most of the goodies of the recent c_ulimit() changes, but retain the
old way of working (also add some more casts and simplify the code)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.78 2008/04/20 21:30:29 tg Exp $");
d60 3
d3053 38
@


1.78
log
@• revert the oksh code to be able to set multiple ulimits in one
  invocation, until it works with a common idiom: “ulimit -dS 262144”
  (but keep some goodies)
• add a regression test for that
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.77 2008/04/19 22:15:03 tg Exp $");
d2863 3
d2913 2
a2914 3
	rlim_t val = (rlim_t)0;
	int how = SOFT | HARD, optc, what;
	bool all = false, set;
a2915 1
	struct rlimit limit;
d2926 1
a2926 1
	what = 'f';
d2939 1
d2952 2
a2953 3
	wp += builtin_opt.optind;
	if ((set = *wp ? true : false)) {
		if (all || wp[1]) {
d2957 21
a2977 4
		if (strcmp(wp[0], "unlimited") == 0)
			val = (rlim_t)RLIM_INFINITY;
		else {
			long rval;
d2979 11
a2989 14
			if (!evaluate(wp[0], &rval, KSH_RETURN_ERROR, false))
				return (1);
			/* Avoid problems caused by typos that
			 * evaluate misses due to evaluating unset
			 * parameters to 0...
			 * If this causes problems, will have to
			 * add parameter to evaluate() to control
			 * if unset params are 0 or an error.
			 */
			if (!rval && !ksh_isdigit(wp[0][0])) {
				bi_errorf("invalid limit: %s", wp[0]);
				return (1);
			}
			val = (rlim_t)((rlim_t)rval * l->factor);
d2991 1
d2993 1
a2993 20
	if (all) {
		for (l = limits; l->name; l++) {
			shprintf("%-20s ", l->name);
			if (getrlimit(l->resource, &limit)) {
				shf_puts("unknown\n", shl_stdout);
				continue;
			}
			if (how & SOFT)
				val = limit.rlim_cur;
			else if (how & HARD)
				val = limit.rlim_max;
			if (val == (rlim_t)RLIM_INFINITY)
				shf_puts("unlimited\n", shl_stdout);
			else {
				val = (rlim_t)(val / l->factor);
				shprintf("%ld\n", (long)val);
			}
		}
		return 0;
	}
a2995 4
		if (!set) {
			shf_puts("unknown\n", shl_stdout);
			return (0);
		}
a2998 13
	if (!set) {
		if (how & SOFT)
			val = limit.rlim_cur;
		else if (how & HARD)
			val = limit.rlim_max;
		if (val == (rlim_t)RLIM_INFINITY)
			shf_puts("unlimited\n", shl_stdout);
		else {
			val = (rlim_t)(val / l->factor);
			shprintf("%ld\n", (long)val);
		}
		return (0);
	}
d3003 18
a3020 6
	if (setrlimit(l->resource, &limit) < 0) {
		if (errno == EPERM)
			bi_errorf("%s exceeds allowable limit", l->name);
		else
			bi_errorf("bad %s limit: %s", l->name, strerror(errno));
		return (1);
d3022 8
a3029 1
	return (0);
@


1.77
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.76 2008/04/16 21:56:01 tg Exp $");
a2862 3
static void print_ulimit(const struct limits *, int);
static int set_ulimit(const struct limits *, const char *, int);

d2909 4
a2912 3
	static char opts[4 + NELEM(limits) * 2];
	int how = SOFT | HARD, optc;
	bool all = false;
d2914 1
d2921 1
a2921 1
		for (l = limits; l->name; l++) {
a2922 2
			*p++ = '#';
		}
d2925 1
a2925 1
	/* first check for -a, -H and -S */
d2940 1
a2940 1
			break;
d2943 4
a2946 2
	if (wp[builtin_opt.optind] != NULL) {
		bi_errorf("usage: ulimit [-acdfHLlmnpSsTtvw] [value]");
d2950 4
a2953 9
	/* then parse and act on the actual limits, one at a time */
	ksh_getopt_reset(&builtin_opt, GF_ERROR);
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != -1)
		switch (optc) {
		case 'a':
		case 'H':
		case 'S':
			break;
		case '?':
d2955 17
a2971 5
		default:
			for (l = limits; l->name && l->option != optc; l++)
				;
			if (!l->name) {
				internal_warningf("ulimit: %c", optc);
d2974 1
a2974 5
			if (!builtin_opt.optarg)
				print_ulimit(l, how);
			else if (set_ulimit(l, builtin_opt.optarg, how))
				return (1);
			break;
d2976 2
a2977 4

	wp += builtin_opt.optind;

	if (all)
d2980 14
a2993 1
			print_ulimit(l, how);
d2995 1
a2995 44
	else if (builtin_opt.optind == 1) {
		/* no limit specified, use file size as default */
#ifndef RLIMIT_FSIZE
		internal_warningf("ulimit: need argument");
		return (1);
#else
#ifdef RLIMIT_CPU
		l = &limits[1];
#else
		l = &limits[0];
#endif
		if (!wp[0])
			print_ulimit(l, how);
		else if (set_ulimit(l, wp[0], how))
			return(1);
#endif
	}
	return (0);
}

static int
set_ulimit(const struct limits *l, const char *v, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (strcmp(v, "unlimited") == 0)
		val = (rlim_t)RLIM_INFINITY;
	else {
		long rval;

		if (!evaluate(v, &rval, KSH_RETURN_ERROR, false))
			return (1);
		/*
		 * Avoid problems caused by typos that evaluate misses due
		 * to evaluating unset parameters to 0...
		 * If this causes problems, will have to add parameter to
		 * evaluate() to control if unset params are 0 or an error.
		 */
		if (!rval && !ksh_isdigit(v[0])) {
			bi_errorf("invalid limit: %s", v);
			return (1);
		}
		val = (rlim_t)rval * l->factor;
a2996 1

d2999 4
d3006 13
a3032 22
static void
print_ulimit(const struct limits *l, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (getrlimit(l->resource, &limit)) {
		shf_puts("unknown\n", shl_stdout);
		return;
	}
	if (how & SOFT)
		val = limit.rlim_cur;
	else if (how & HARD)
		val = limit.rlim_max;
	if (val == RLIM_INFINITY)
		shf_puts("unlimited\n", shl_stdout);
	else {
		val /= l->factor;
		shprintf("%ld\n", (long)val);
	}
}

@


1.76
log
@_careful_ (feature) sync with oksh:

   (3 weeks, 5 days ago) by millert
Make ulimit able to get and set multiple limits in a single invocation
like bash and zsh do.  Requested by espie@@, OK deraadt@@
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.75 2008/04/01 22:20:19 tg Exp $");
d1594 1
a1594 1
			shprintf("%#3.3o\n", (unsigned) old_umask);
@


1.75
log
@some more code “folding”
should decrease size
@
text
@d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.16 2006/11/20 21:53:39 miod Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.74 2008/04/01 21:50:57 tg Exp $");
d2856 10
d2869 8
a2876 9
	static const struct limits {
		const char	*name;
		enum { RLIMIT, ULIMIT } which;
		int	gcmd;	/* get command */
		int	scmd;	/* set command (or -1, if no set command) */
		int	factor;	/* multiply by to get rlim_{cur,max} values */
		char	option;
	} limits[] = {
		/* Do not use options -H, -S or -a */
d2878 1
a2878 2
		{ "coredump(blocks)", RLIMIT, RLIMIT_CORE, RLIMIT_CORE,
		    512, 'c' },
d2881 1
a2881 2
		{ "data(KiB)", RLIMIT, RLIMIT_DATA, RLIMIT_DATA,
		    1024, 'd' },
d2883 2
a2884 7
#ifdef RLIMIT_FSIZE
		{ "file(blocks)", RLIMIT, RLIMIT_FSIZE, RLIMIT_FSIZE,
		    512, 'f' },
#endif
#ifdef RLIMIT_LOCKS
		{ "flocks", RLIMIT, RLIMIT_LOCKS, RLIMIT_LOCKS,
		    -1, 'L' },
d2887 1
a2887 2
		{ "lockedmem(KiB)", RLIMIT, RLIMIT_MEMLOCK, RLIMIT_MEMLOCK,
		    1024, 'l' },
d2890 1
a2890 2
		{ "memory(KiB)", RLIMIT, RLIMIT_RSS, RLIMIT_RSS,
		    1024, 'm' },
d2893 1
a2893 2
		{ "nofiles(descriptors)", RLIMIT, RLIMIT_NOFILE, RLIMIT_NOFILE,
		    1, 'n' },
d2896 1
a2896 2
		{ "processes", RLIMIT, RLIMIT_NPROC, RLIMIT_NPROC,
		    1, 'p' },
d2898 2
a2899 3
#ifdef RLIMIT_STACK
		{ "stack(KiB)", RLIMIT, RLIMIT_STACK, RLIMIT_STACK,
		    1024, 's' },
d2901 2
a2902 3
#ifdef RLIMIT_TIME
		{ "humantime(seconds)", RLIMIT, RLIMIT_TIME, RLIMIT_TIME,
		    1, 'T' },
d2904 2
a2905 3
#ifdef RLIMIT_CPU
		{ "time(cpu-seconds)", RLIMIT, RLIMIT_CPU, RLIMIT_CPU,
		    1, 't' },
d2907 2
a2908 3
#ifdef RLIMIT_VMEM
		{ "vmemory(KiB)", RLIMIT, RLIMIT_VMEM, RLIMIT_VMEM,
		    1024, 'v' },
d2910 1
a2910 5
#ifdef RLIMIT_SWAP
		{ "swap(KiB)", RLIMIT, RLIMIT_SWAP, RLIMIT_SWAP,
		    1024, 'w' },
#endif
		{ NULL, RLIMIT, 0, 0, 0, 0 }
d2912 3
a2914 4
	static char opts[3 + NELEM(limits)];
	rlim_t val = (rlim_t)0;
	int how = SOFT | HARD, optc, what;
	bool all = false, set;
a2915 1
	struct rlimit limit;
d2922 1
a2922 1
		for (l = limits; l->name; l++)
d2924 2
d2928 1
a2928 1
	what = 'f';
d2941 1
a2941 1
			return 1;
d2943 1
a2943 1
			what = optc;
d2946 3
a2948 5
	for (l = limits; l->name && l->option != what; l++)
		;
	if (!l->name) {
		internal_warningf("ulimit: %c", what);
		return 1;
d2951 24
a2975 9
	if ((set = *wp ? true : false)) {
		if (all || wp[1]) {
			bi_errorf("too many arguments");
			return 1;
		}
		if (strcmp(wp[0], "unlimited") == 0)
			val = (rlim_t)RLIM_INFINITY;
		else {
			long rval;
d2977 4
a2980 14
			if (!evaluate(wp[0], &rval, KSH_RETURN_ERROR, false))
				return 1;
			/* Avoid problems caused by typos that
			 * evaluate misses due to evaluating unset
			 * parameters to 0...
			 * If this causes problems, will have to
			 * add parameter to evaluate() to control
			 * if unset params are 0 or an error.
			 */
			if (!rval && !ksh_isdigit(wp[0][0])) {
				bi_errorf("invalid limit: %s", wp[0]);
				return 1;
			}
			val = (rlim_t)((rlim_t)rval * l->factor);
d2982 8
a2989 11
	}
	if (all) {
		for (l = limits; l->name; l++) {
			if (l->which == RLIMIT) {
#ifdef RLIMIT_LOCKS
				if (getrlimit(l->gcmd, &limit) < 0)
					if ((errno == EINVAL) &&
					    (l->gcmd == RLIMIT_LOCKS)) {
						limit.rlim_cur = RLIM_INFINITY;
						limit.rlim_max = RLIM_INFINITY;
					}
d2991 6
a2996 1
				getrlimit(l->gcmd, &limit);
a2997 14
				if (how & SOFT)
					val = limit.rlim_cur;
				else if (how & HARD)
					val = limit.rlim_max;
			}
			shprintf("%-20s ", l->name);
			if (val == (rlim_t)RLIM_INFINITY)
				shf_puts("unlimited\n", shl_stdout);
			else {
				val = (rlim_t)(val / l->factor);
				shprintf("%ld\n", (long)val);
			}
		}
		return 0;
d2999 25
a3023 21
	if (l->which == RLIMIT) {
		getrlimit(l->gcmd, &limit);
		if (set) {
			if (how & SOFT)
				limit.rlim_cur = val;
			if (how & HARD)
				limit.rlim_max = val;
			if (setrlimit(l->scmd, &limit) < 0) {
				how = errno;
				if (how == EPERM)
					bi_errorf("exceeds allowable limit");
				else
					bi_errorf("bad limit: %s",
					    strerror(how));
				return 1;
			}
		} else {
			if (how & SOFT)
				val = limit.rlim_cur;
			else if (how & HARD)
				val = limit.rlim_max;
d3025 1
d3027 16
a3042 7
	if (!set) {
		if (val == (rlim_t)RLIM_INFINITY)
			shf_puts("unlimited\n", shl_stdout);
		else {
			val = (rlim_t)(val / l->factor);
			shprintf("%ld\n", (long)val);
		}
d3047 22
@


1.74
log
@more
• int → bool
• shprintf("foo") → shf_puts("foo", shl_stdout)
• shprintf("%s", foo) → shf_puts(foo, shl_stdout)
• shf_puts("x", foo) → shf_putc('x', foo)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.72 2008/03/28 18:46:59 tg Exp $");
d118 4
a121 4
static int test_oexpr(Test_env *, int);
static int test_aexpr(Test_env *, int);
static int test_nexpr(Test_env *, int);
static int test_primary(Test_env *, int);
d123 1
a123 1
static const char *ptest_getopnd(Test_env *, Test_op, int);
d132 1
a132 1
	int optc;
a135 1
	int rval;
d138 1
a138 3
	char *dir, *try, *pwd;
	int phys_path;
	char *cdpath;
d220 1
a220 1
			rval = chdir(try = Xstring(xs, xp) + phys_path);
d223 1
a223 1
			rval = chdir(try = Xstring(xs, xp));
d225 1
a225 1
	} while (rval < 0 && cdpath != NULL);
d227 1
a227 1
	if (rval < 0) {
d274 1
a274 1
	int physical = Flag(FPHYSICAL) ? true : false;
d322 1
a322 2
	const char *s;
	const char *emsg;
d556 2
a557 4
	int ret = 0;
	int optc;
	int iam_whence = wp[0][0] == 'w';
	int fcflags;
a575 1

d590 1
a590 1
	while ((vflag || ret == 0) && (id = *wp++) != NULL) {
d652 1
a652 1
				ret = 1;
d659 1
a659 1
		if (vflag || !ret)
d662 1
a662 1
	return ret;
d825 1
a825 2
		int i;
		int rval = 0;
d835 2
a836 2
					/* at&t ksh does ++rval: bogus */
					rval = 1;
d852 1
a852 1
		return rval;
d874 1
a874 1
				int any_set = 0;
d881 1
a881 1
						any_set = 1;
d1077 1
a1077 1
		const char *alias = *wp;
a1078 2
		const char *val;
		const char *newval;
d1389 3
a1391 6
	int	argc;
	const char *opts;
	const char *var;
	int	optc;
	int	ret;
	char	buf[3];
d1468 1
a1468 1
	ret = 0;
d1473 1
a1473 1
	    ret = 1;
d1477 1
a1477 1
	return optc < 0 ? 1 : ret;
d1560 1
a1560 1
	int i;
d1562 1
a1562 1
	bool symbolic = 0;
a1563 1
	int optc;
d1686 2
a1687 6
	const char *file;
	const char *cp;
	const char **argv;
	int argc;
	int i;
	int err;
d1696 3
a1698 3
	file = search(cp, path, R_OK, &err);
	if (file == NULL) {
		bi_errorf("%s: %s", cp, err ? strerror(err) : "not found");
d1712 2
a1713 2
	i = include(file, argc, argv, 0);
	if (i < 0) { /* should not happen */
d1723 1
a1723 2
	int rv = 0;
	int sig;
d1744 3
a1746 7
	int c = 0;
	int expande = 1, historyr = 0;
	int expanding;
	int ecode = 0;
	const char *cp;
	char *ccp;
	int fd = 0;
a1747 2
	int optc;
	const char *emsg;
d1750 1
a1750 1
	char *xp = NULL, *wpalloc = NULL;
d1762 1
a1762 1
			expande = 0;
d1765 1
a1765 1
			historyr = 1;
d1815 1
a1815 1
	expanding = 0;
d1847 1
a1847 1
				expanding = 0;
d1862 1
a1862 1
				expanding = 1;
d2008 1
a2008 2
	int how = LEXIT;
	int n;
d2213 1
a2213 1
	int rv = 0;
a2215 1
	int tf = 0;
d2279 1
a2279 2
	int optc;
	int i, j;
d2446 1
a2446 2
	int argc;
	int res;
d2540 1
a2540 1
    int do_eval)
d2542 1
a2542 1
	int i;
d2545 1
d2641 19
a2659 23
		{
			long v1, v2;

			if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false) ||
			    !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false)) {
				/* error already printed.. */
				te->flags |= TEF_ERROR;
				return 1;
			}
			switch ((int) op) {
			case TO_INTEQ:
				return v1 == v2;
			case TO_INTNE:
				return v1 != v2;
			case TO_INTGE:
				return v1 >= v2;
			case TO_INTGT:
				return v1 > v2;
			case TO_INTLE:
				return v1 <= v2;
			case TO_INTLT:
				return v1 < v2;
			}
d2662 6
a2667 9
		{
			int s2;
			/* ksh88/ksh93 succeed if file2 can't be stated
			 * (subtly different from 'does not exist').
			 */
			return stat(opnd1, &b1) == 0 &&
			    (((s2 = stat(opnd2, &b2)) == 0 &&
			    b1.st_mtime > b2.st_mtime) || s2 < 0);
		}
d2669 6
a2674 9
		{
			int s1;
			/* ksh88/ksh93 succeed if file1 can't be stated
			 * (subtly different from 'does not exist').
			 */
			return stat(opnd2, &b2) == 0 &&
			    (((s1 = stat(opnd1, &b1)) == 0 &&
			    b1.st_mtime < b2.st_mtime) || s1 < 0);
		}
d2687 1
a2687 1
	int res = access(pathl, mode);
d2689 1
a2689 1
	if (res == 0 && ksheuid == 0 && (mode & X_OK)) {
d2693 1
a2693 1
			res = -1;
d2695 1
a2695 1
			res = 0;
d2697 1
a2697 1
			res = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) ?
d2700 1
a2700 1
	return res;
d2706 1
a2706 1
	int res;
d2708 1
a2708 1
	res = test_oexpr(te, 1);
d2713 1
a2713 1
	return (te->flags & TEF_ERROR) ? T_ERR_EXIT : !res;
d2717 1
a2717 1
test_oexpr(Test_env *te, int do_eval)
d2719 1
a2719 1
	int res;
d2721 2
a2722 3
	res = test_aexpr(te, do_eval);
	if (res)
		do_eval = 0;
d2724 2
a2725 2
		return test_oexpr(te, do_eval) || res;
	return res;
d2729 1
a2729 1
test_aexpr(Test_env *te, int do_eval)
d2731 1
a2731 1
	int res;
d2733 2
a2734 3
	res = test_nexpr(te, do_eval);
	if (!res)
		do_eval = 0;
d2736 2
a2737 2
		return test_aexpr(te, do_eval) && res;
	return res;
d2741 1
a2741 1
test_nexpr(Test_env *te, int do_eval)
d2749 1
a2749 1
test_primary(Test_env *te, int do_eval)
d2752 1
a2752 1
	int res;
d2758 1
a2758 1
		res = test_oexpr(te, do_eval);
d2765 1
a2765 1
		return res;
d2814 1
a2814 1
	int ret;
d2820 1
a2820 1
		ret = test_isop(meta, *te->pos.wp);
d2822 1
a2822 1
		ret = 0;
d2824 1
a2824 1
		ret = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;
d2827 1
a2827 1
	if (ret)
d2830 1
a2830 1
	return ret;
d2834 1
a2834 1
ptest_getopnd(Test_env *te, Test_op op, int do_eval __unused)
d2842 1
a2842 1
ptest_error(Test_env *te, int offset, const char *msg)
d2844 1
a2844 2
	const char *op = te->pos.wp + offset >= te->wp_end ?
	    NULL : te->pos.wp[offset];
d2847 1
a2847 1
	if (op)
d2922 7
a2928 7
	static char	opts[3 + NELEM(limits)];
	rlim_t		val = (rlim_t)0;
	int		how = SOFT | HARD;
	const struct limits	*l;
	int		set, all = 0;
	int		optc, what;
	struct rlimit	limit;
d2948 1
a2948 1
			all = 1;
d2964 1
a2964 2
	set = *wp ? 1 : 0;
	if (set) {
@


1.73
log
@reorganise c_typeset code, fixing that regression test
also some int→bool while here
@
text
@d133 1
a133 1
	int physical = Flag(FPHYSICAL);
d135 1
a135 1
	int printpath = 0;		/* print where we cd'd? */
d147 1
a147 1
			physical = 0;
d150 1
a150 1
			physical = 1;
d181 1
a181 1
			printpath++;
d211 1
a211 1
		printpath++;
d277 1
a277 1
	int physical = Flag(FPHYSICAL);
d284 1
a284 1
			physical = 0;
d287 1
a287 1
			physical = 1;
d559 1
a559 1
	int pflag = 0, vflag = 0, Vflag = 0;
d569 1
a569 1
			pflag = 1;
d572 1
a572 1
			vflag = 1;
d575 1
a575 1
			Vflag = 1;
d610 1
a610 1
			shprintf("%s", id);
d614 1
a614 1
				shprintf(" is a reserved word");
d619 1
a619 2
				    (tp->flag & EXPORT) ? "exported " :
				    null);
d626 1
a626 1
				shprintf(" is a");
d628 1
a628 1
					shprintf("n exported");
d630 1
a630 1
					shprintf(" traced");
d632 1
a632 1
					shprintf(" undefined");
d637 1
a637 1
				shprintf(" function");
d649 1
a649 1
					shprintf(" is ");
d655 1
a655 1
				shprintf("%s", tp->val.s);
d658 1
a658 1
					shprintf(" not found");
d921 1
a921 1
						shprintf("typeset ");
d923 1
a923 1
							shprintf("-i ");
d925 1
a925 1
							shprintf("-x ");
d927 1
a927 1
							shprintf("-r ");
d929 1
a929 1
							shprintf("-t ");
d935 1
a935 1
							shprintf("-Z ");
d937 1
a937 1
							shprintf("-l ");
d939 1
a939 1
							shprintf("-u ");
d972 1
a972 1
							shprintf("%s", vp->name);
d976 1
a976 1
							shprintf("=");
d982 1
a982 1
								shprintf("%s", s);
d989 2
a990 2
					* no set elements.
					*/
d1004 2
a1005 2
	int rv = 0, rflag = 0, tflag, Uflag = 0, pflag = 0;
	int prefix = 0;
d1021 1
a1021 1
			pflag = 1;
d1024 1
a1024 1
			rflag = 1;
d1034 1
a1034 1
			Uflag = 1;
d1060 2
a1061 2
			shprintf("alias: -r flag can only be used with -t"
			    " and without arguments\n");
d1145 2
a1146 2
	int rv = 0, all = 0;
	int optc;
d1151 1
a1151 1
			all = 1;
d1217 1
a1217 4
	int optc;
	int flag = 0;
	int nflag = 0;
	int rv = 0;
d1251 1
a1251 1
	int bg = strcmp(*wp, "bg") == 0;
d1288 1
a1288 1
	int lflag = 0;
d1305 1
a1305 1
				lflag = 1;
d1496 2
a1497 1
	int optc, rv = 0, macro = 0, list = 0;
d1504 1
a1504 1
			list = 1;
d1507 1
a1507 1
			macro = 1;
d1575 1
a1575 1
	int symbolic = 0;
d1582 1
a1582 1
			symbolic = 1;
d2002 1
a2002 1
				shprintf("trap -- ");
d3052 1
a3052 1
				shprintf("unlimited\n");
d3085 1
a3085 1
			shprintf("unlimited\n");
@


1.72
log
@revert wrong fix
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.70 2008/03/28 13:28:33 tg Exp $");
d689 3
a691 3
	Tflag fset = 0, fclr = 0;
	int thing = 0, func = 0, localv = 0;
	const char *opts = "L#R#UZ#fi#lprtux";	/* see comment below */
d693 1
a693 4
	int field, base;
	int optc;
	Tflag flag;
	int pflag = 0;
d698 1
a698 1
		opts = "p";
d702 1
a702 1
		opts = "p";
d708 1
a708 1
		localv = 1;
d712 3
d748 1
a748 1
			func = 1;
d758 6
a763 6
			/* posix export/readonly -p flag.
			 * typeset -p is the same as typeset (in pdksh);
			 * here for compatibility with ksh93.
			 */
			pflag = 1;
			continue;
d942 18
a959 4
							shprintf("-U ");
						shprintf("%s\n", vp->name);
						    if (vp->flag&ARRAY)
						break;
d962 6
a967 1
							shprintf("typeset ");
@


1.71
log
@• fix one more of the enum arithmetics complaints
• split Xinit into XinitN and Xinit macro, the former
  not initialising the “xp” argument of the latter,
  and use this to get rid of two variables that are
  only assigned but never referenced (gcc doesn’t see
  this, but MIPSpro and IIRC SUNWcc do)
• re-indent while here
• bump patchlevel
@
text
@d2497 1
a2497 1
				if ((op = (*te.isa)(&te, TM_BINOP)) != TO_NONOP) {
d2791 1
a2791 1
	if ((op = (*te->isa)(te, TM_UNOP)) != TO_NONOP) {
d2806 1
a2806 1
	if ((op = (*te->isa)(te, TM_BINOP)) != TO_NONOP) {
@


1.70
log
@fix most of the fixable bitchings of MIPSpro compiler (complainer?)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.69 2008/02/24 15:57:20 tg Exp $");
a138 1
	char *xp;
d217 1
a217 5
	Xinit(xs, xp, PATH_MAX, ATEMP);
	/* xp will have a bogus value after make_path() - set it to 0
	 * so that if it's used, it will cause a dump
	 */
	xp = NULL;
d2806 1
a2806 1
	if ((op = (*te->isa)(te, TM_BINOP))) {
@


1.69
log
@another one from debian: '.' needs an argument
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.68 2008/02/24 15:48:42 tg Exp $");
d2502 1
a2502 1
				if ((op = (*te.isa)(&te, TM_BINOP))) {
d2796 1
a2796 1
	if ((op = (*te->isa)(te, TM_UNOP))) {
d2950 1
a2950 1
		{ NULL, 0, 0, 0, 0, 0 }
@


1.69.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.75 2008/04/01 22:20:19 tg Exp $");
d118 4
a121 4
static int test_oexpr(Test_env *, bool);
static int test_aexpr(Test_env *, bool);
static int test_nexpr(Test_env *, bool);
static int test_primary(Test_env *, bool);
d123 1
a123 1
static const char *ptest_getopnd(Test_env *, Test_op, bool);
d132 2
a133 2
	int optc, rv, phys_path;
	bool physical = Flag(FPHYSICAL) ? true : false;
d135 2
a136 1
	bool printpath = false;		/* print where we cd'd? */
d139 4
a142 1
	char *dir, *try, *pwd, *cdpath;
d148 1
a148 1
			physical = false;
d151 1
a151 1
			physical = true;
d182 1
a182 1
			printpath = true;
d212 1
a212 1
		printpath = true;
d218 5
a222 1
	XinitN(xs, PATH_MAX, ATEMP);
d228 1
a228 1
			rv = chdir(try = Xstring(xs, xp) + phys_path);
d231 1
a231 1
			rv = chdir(try = Xstring(xs, xp));
d233 1
a233 1
	} while (rv < 0 && cdpath != NULL);
d235 1
a235 1
	if (rv < 0) {
d282 1
a282 1
	bool physical = Flag(FPHYSICAL) ? true : false;
d289 1
a289 1
			physical = false;
d292 1
a292 1
			physical = true;
d330 2
a331 1
	const char *s, *emsg;
d564 5
a568 3
	bool pflag = false, vflag = false, Vflag = false;
	int rv = 0, optc, fcflags;
	bool iam_whence = wp[0][0] == 'w';
d574 1
a574 1
			pflag = true;
d577 1
a577 1
			vflag = true;
d580 1
a580 1
			Vflag = true;
d587 1
d602 1
a602 1
	while ((vflag || rv == 0) && (id = *wp++) != NULL) {
d615 1
a615 1
			shf_puts(id, shl_stdout);
d619 1
a619 1
				shf_puts(" is a reserved word", shl_stdout);
d624 2
a625 1
				    (tp->flag & EXPORT) ? "exported " : null);
d632 1
a632 1
				shf_puts(" is a", shl_stdout);
d634 1
a634 1
					shf_puts("n exported", shl_stdout);
d636 1
a636 1
					shf_puts(" traced", shl_stdout);
d638 1
a638 1
					shf_puts(" undefined", shl_stdout);
d643 1
a643 1
				shf_puts(" function", shl_stdout);
d655 1
a655 1
					shf_puts(" is ", shl_stdout);
d661 1
a661 1
				shf_puts(tp->val.s, shl_stdout);
d664 2
a665 2
					shf_puts(" not found", shl_stdout);
				rv = 1;
d672 1
a672 1
		if (vflag || !rv)
d675 1
a675 1
	return rv;
d694 3
a696 3
	Tflag fset = 0, fclr = 0, flag;
	int thing = 0, field, base, optc;
	const char *opts;
d698 4
a701 1
	bool localv = false, func = false, pflag = false, istset = true;
d706 1
a706 1
		istset = false;
d710 1
a710 1
		istset = false;
d716 1
a716 1
		localv = true;
a719 3
	/* see comment below regarding possible opions */
	opts = istset ? "L#R#UZ#fi#lprtux" : "p";

d753 1
a753 1
			func = true;
d763 6
a768 6
			/* export, readonly: POSIX -p flag */
			/* typeset: show values as well */
			pflag = true;
			if (istset)
				continue;
			break;
d838 2
a839 1
		int i, rv = 0;
d849 2
a850 2
					/* at&t ksh does ++rv: bogus */
					rv = 1;
d866 1
a866 1
		return rv;
d888 1
a888 1
				bool any_set = false;
d895 1
a895 1
						any_set = true;
d927 1
a927 1
						shf_puts("typeset ", shl_stdout);
d929 1
a929 1
							shf_puts("-i ", shl_stdout);
d931 1
a931 1
							shf_puts("-x ", shl_stdout);
d933 1
a933 1
							shf_puts("-r ", shl_stdout);
d935 1
a935 1
							shf_puts("-t ", shl_stdout);
d941 1
a941 1
							shf_puts("-Z ", shl_stdout);
d943 1
a943 1
							shf_puts("-l ", shl_stdout);
d945 1
a945 1
							shf_puts("-u ", shl_stdout);
d947 4
a950 18
							shf_puts("-U ", shl_stdout);
						shf_puts(vp->name, shl_stdout);
						if (pflag) {
							char *s = str_val(vp);

							shf_putc('=', shl_stdout);
							/* at&t ksh can't have
							 * justified integers.. */
							if ((vp->flag &
							    (INTEGER|LJUST|RJUST)) ==
							    INTEGER)
								shf_puts(s, shl_stdout);
							else
								print_value_quoted(s);
						}
						shf_putc('\n', shl_stdout);
						if (vp->flag & ARRAY)
							break;
d953 1
a953 6
							shf_puts(istset ?
							    "typeset " :
							    (flag & EXPORT) ?
							    "export " :
							    "readonly ",
							    shl_stdout);
d959 1
a959 1
							shf_puts(vp->name, shl_stdout);
d963 1
a963 1
							shf_putc('=', shl_stdout);
d969 1
a969 1
								shf_puts(s, shl_stdout);
d976 2
a977 2
					 * no set elements.
					 */
d991 2
a992 2
	int rv = 0, prefix = 0;
	bool rflag = false, tflag, Uflag = false, pflag = false;
d1008 1
a1008 1
			pflag = true;
d1011 1
a1011 1
			rflag = true;
d1021 1
a1021 1
			Uflag = true;
d1047 2
a1048 2
			shf_puts("alias: -r flag can only be used with -t"
			    " and without arguments\n", shl_stdout);
d1072 1
a1072 1
		const char *alias = *wp, *val, *newval;
d1074 2
d1132 2
a1133 2
	int optc, rv = 0;
	bool all = false;
d1138 1
a1138 1
			all = true;
d1204 4
a1207 1
	int optc, flag = 0, nflag = 0, rv = 0;
d1241 1
a1241 1
	bool bg = strcmp(*wp, "bg") == 0;
d1278 1
a1278 1
	bool lflag = false;
d1295 1
a1295 1
				lflag = true;
d1389 6
a1394 3
	int argc, optc, rv;
	const char *opts, *var;
	char buf[3];
d1471 1
a1471 1
	rv = 0;
d1476 1
a1476 1
		rv = 1;
d1480 1
a1480 1
	return optc < 0 ? 1 : rv;
d1486 1
a1486 2
	int optc, rv = 0;
	bool macro = false, list = false;
d1493 1
a1493 1
			list = true;
d1496 1
a1496 1
			macro = true;
d1562 1
a1562 1
	int i, optc;
d1564 1
a1564 1
	bool symbolic = false;
d1566 1
d1571 1
a1571 1
			symbolic = true;
d1689 6
a1694 2
	const char *file, *cp, **argv;
	int argc, i, errcode;
d1703 3
a1705 3
	if ((file = search(cp, path, R_OK, &errcode)) == NULL) {
		bi_errorf("%s: %s", cp,
		    errcode ? strerror(errcode) : "not found");
d1719 2
a1720 2
	if ((i = include(file, argc, argv, 0)) < 0) {
		/* should not happen */
d1730 2
a1731 1
	int rv = 0, sig;
d1752 7
a1758 3
	int c = 0, ecode = 0, fd = 0, optc;
	bool expande = true, historyr = false, expanding;
	const char *cp, *emsg;
d1760 2
d1764 1
a1764 1
	char *ccp, *xp = NULL, *wpalloc = NULL;
d1776 1
a1776 1
			expande = false;
d1779 1
a1779 1
			historyr = true;
d1829 1
a1829 1
	expanding = false;
d1861 1
a1861 1
				expanding = false;
d1876 1
a1876 1
				expanding = true;
d1991 1
a1991 1
				shf_puts("trap -- ", shl_stdout);
d2022 2
a2023 1
	int n, how = LEXIT;
d2228 1
a2228 1
	int rv = 0, tf = 0;
d2231 1
d2295 2
a2296 1
	int optc, i, j;
d2463 2
a2464 1
	int argc, res;
d2558 1
a2558 1
    bool do_eval)
d2560 1
a2560 1
	int i, s;
a2562 1
	long v1, v2;
d2658 23
a2680 5
		if (!evaluate(opnd1, &v1, KSH_RETURN_ERROR, false) ||
		    !evaluate(opnd2, &v2, KSH_RETURN_ERROR, false)) {
			/* error already printed.. */
			te->flags |= TEF_ERROR;
			return 1;
d2682 9
a2690 13
		switch ((int)op) {
		case TO_INTEQ:
			return (v1 == v2);
		case TO_INTNE:
			return (v1 != v2);
		case TO_INTGE:
			return (v1 >= v2);
		case TO_INTGT:
			return (v1 > v2);
		case TO_INTLE:
			return (v1 <= v2);
		case TO_INTLT:
			return (v1 < v2);
a2691 7
	case TO_FILNT: /* -nt */
		/* ksh88/ksh93 succeed if file2 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return stat(opnd1, &b1) == 0 &&
		    (((s = stat(opnd2, &b2)) == 0 &&
		    b1.st_mtime > b2.st_mtime) || s < 0);
d2693 9
a2701 6
		/* ksh88/ksh93 succeed if file1 can't be stated
		 * (subtly different from 'does not exist').
		 */
		return stat(opnd2, &b2) == 0 &&
		    (((s = stat(opnd1, &b1)) == 0 &&
		    b1.st_mtime < b2.st_mtime) || s < 0);
d2714 1
a2714 1
	int rv;
d2716 1
a2716 1
	if ((rv = access(pathl, mode)) == 0 && ksheuid == 0 && (mode & X_OK)) {
d2720 1
a2720 1
			rv = -1;
d2722 1
a2722 1
			rv = 0;
d2724 1
a2724 1
			rv = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) ?
d2727 1
a2727 1
	return rv;
d2733 1
a2733 1
	int rv;
d2735 1
a2735 1
	rv = test_oexpr(te, 1);
d2740 1
a2740 1
	return (te->flags & TEF_ERROR) ? T_ERR_EXIT : !rv;
d2744 1
a2744 1
test_oexpr(Test_env *te, bool do_eval)
d2746 1
a2746 1
	int rv;
d2748 3
a2750 2
	if ((rv = test_aexpr(te, do_eval)))
		do_eval = false;
d2752 2
a2753 2
		return test_oexpr(te, do_eval) || rv;
	return rv;
d2757 1
a2757 1
test_aexpr(Test_env *te, bool do_eval)
d2759 1
a2759 1
	int rv;
d2761 3
a2763 2
	if (!(rv = test_nexpr(te, do_eval)))
		do_eval = false;
d2765 2
a2766 2
		return test_aexpr(te, do_eval) && rv;
	return rv;
d2770 1
a2770 1
test_nexpr(Test_env *te, bool do_eval)
d2778 1
a2778 1
test_primary(Test_env *te, bool do_eval)
d2781 1
a2781 1
	int rv;
d2787 1
a2787 1
		rv = test_oexpr(te, do_eval);
d2794 1
a2794 1
		return rv;
d2843 1
a2843 1
	int rv;
d2849 1
a2849 1
		rv = test_isop(meta, *te->pos.wp);
d2851 1
a2851 1
		rv = 0;
d2853 1
a2853 1
		rv = strcmp(*te->pos.wp, tokens[(int) meta]) == 0;
d2856 1
a2856 1
	if (rv)
d2859 1
a2859 1
	return rv;
d2863 1
a2863 1
ptest_getopnd(Test_env *te, Test_op op, bool do_eval __unused)
d2871 1
a2871 1
ptest_error(Test_env *te, int ofs, const char *msg)
d2873 2
a2874 1
	const char *op;
d2877 1
a2877 1
	if ((op = te->pos.wp + ofs >= te->wp_end ? NULL : te->pos.wp[ofs]))
d2950 1
a2950 1
		{ NULL, RLIMIT, 0, 0, 0, 0 }
d2952 7
a2958 7
	static char opts[3 + NELEM(limits)];
	rlim_t val = (rlim_t)0;
	int how = SOFT | HARD, optc, what;
	bool all = false, set;
	const struct limits *l;
	struct rlimit limit;

d2978 1
a2978 1
			all = true;
d2994 2
a2995 1
	if ((set = *wp ? true : false)) {
d3041 1
a3041 1
				shf_puts("unlimited\n", shl_stdout);
d3074 1
a3074 1
			shf_puts("unlimited\n", shl_stdout);
@


1.69.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.17 2008/03/21 12:51:19 millert Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.81 2008/05/17 18:46:58 tg Exp $");
a59 3
#if HAVE_REALPATH
	{"realpath", c_realpath},
#endif
d138 2
a139 1
	char *dir, *allocd = NULL, *try, *pwd, *cdpath;
d170 3
a172 3
		if (ksh_isdash((dir = allocd = str_save(wp[0], ATEMP)))) {
			afree(allocd, ATEMP);
			allocd = NULL;
d179 2
a180 1
		}
d203 2
a204 1
		dir = allocd = alloc(ilen + nlen + elen, ATEMP);
d232 1
a232 1
		afree(allocd, ATEMP);
d266 1
a266 1
	afree(allocd, ATEMP);
d275 2
a276 1
	char *p, *allocd = NULL;
d295 2
a296 2
	p = current_wd[0] ? (physical ? get_phys_path(current_wd) :
	    current_wd) : NULL;
d299 7
a305 3
	if (!p && !(p = allocd = ksh_get_wd(NULL))) {
		bi_errorf("can't get current directory - %s", strerror(errno));
		return (1);
d308 1
a308 1
	afree(allocd, ATEMP);
d1124 1
a1124 1
		afree(xalias, ATEMP);
d1513 1
a1513 1
		afree(up, ATEMP);
d1594 1
a1594 1
			shprintf("%#3.3o\n", (unsigned int)old_umask);
d1886 1
a1886 1
			afree(wpalloc, ATEMP);
d1893 1
a1893 1
			afree(wpalloc, ATEMP);
d1912 1
a1912 1
	afree(wpalloc, ATEMP);
d2121 1
a2121 1
		l->argv = (const char **)alloc(sizeofN(char *, l->argc+2),
a2855 10
struct limits {
	const char *name;
	int resource;		/* resource to get/set */
	int factor;		/* multiply by to get rlim_{cur,max} values */
	char option;
};

static void print_ulimit(const struct limits *, int);
static int set_ulimit(const struct limits *, const char *, int);

d2859 9
a2867 8
	static const struct limits limits[] = {
		/* do not use options -H, -S or -a or change the order */
#ifdef RLIMIT_CPU
		{ "time(cpu-seconds)", RLIMIT_CPU, 1, 't' },
#endif
#ifdef RLIMIT_FSIZE
		{ "file(blocks)", RLIMIT_FSIZE, 512, 'f' },
#endif
d2869 2
a2870 1
		{ "coredump(blocks)", RLIMIT_CORE, 512, 'c' },
d2873 2
a2874 1
		{ "data(KiB)", RLIMIT_DATA, 1024, 'd' },
d2876 7
a2882 2
#ifdef RLIMIT_STACK
		{ "stack(KiB)", RLIMIT_STACK, 1024, 's' },
d2885 2
a2886 1
		{ "lockedmem(KiB)", RLIMIT_MEMLOCK, 1024, 'l' },
d2889 2
a2890 1
		{ "memory(KiB)", RLIMIT_RSS, 1024, 'm' },
d2893 2
a2894 1
		{ "nofiles(descriptors)", RLIMIT_NOFILE, 1, 'n' },
d2897 14
a2910 1
		{ "processes", RLIMIT_NPROC, 1, 'p' },
d2913 2
a2914 1
		{ "vmemory(KiB)", RLIMIT_VMEM, 1024, 'v' },
d2917 2
a2918 7
		{ "swap(KiB)", RLIMIT_SWAP, 1024, 'w' },
#endif
#ifdef RLIMIT_LOCKS
		{ "flocks", RLIMIT_LOCKS, -1, 'L' },
#endif
#ifdef RLIMIT_TIME
		{ "humantime(seconds)", RLIMIT_TIME, 1, 'T' },
d2920 1
a2920 1
		{ NULL, 0, 0, 0 }
d2923 3
a2925 2
	int how = SOFT | HARD, optc, what = 'f';
	bool all = false;
d2927 1
d2938 1
a2938 1

d2951 1
a2951 2
			bi_errorf("usage: ulimit [-acdfHLlmnpSsTtvw] [value]");
			return (1);
d2960 1
a2960 1
		return (1);
d2963 3
a2965 2
	if (wp[builtin_opt.optind]) {
		if (all || wp[builtin_opt.optind + 1]) {
d2967 48
a3014 1
			return (1);
d3016 1
a3016 1
		return (set_ulimit(l, wp[builtin_opt.optind], how));
d3018 22
a3039 5
	if (!all)
		print_ulimit(l, how);
	else for (l = limits; l->name; l++) {
		shprintf("%-20s ", l->name);
		print_ulimit(l, how);
d3041 6
a3046 25
	return (0);
}

static int
set_ulimit(const struct limits *l, const char *v, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (strcmp(v, "unlimited") == 0)
		val = (rlim_t)RLIM_INFINITY;
	else {
		long rval;

		if (!evaluate(v, &rval, KSH_RETURN_ERROR, false))
			return (1);
		/*
		 * Avoid problems caused by typos that evaluate misses due
		 * to evaluating unset parameters to 0...
		 * If this causes problems, will have to add parameter to
		 * evaluate() to control if unset params are 0 or an error.
		 */
		if (!rval && !ksh_isdigit(v[0])) {
			bi_errorf("invalid %s limit: %s", l->name, v);
			return (1);
a3047 1
		val = (rlim_t)((rlim_t)rval * l->factor);
d3049 1
a3049 37

	if (getrlimit(l->resource, &limit) < 0) {
		/* some cannot be read, e.g. Linux RLIMIT_LOCKS */
		limit.rlim_cur = RLIM_INFINITY;
		limit.rlim_max = RLIM_INFINITY;
	}
	if (how & SOFT)
		limit.rlim_cur = val;
	if (how & HARD)
		limit.rlim_max = val;
	if (!setrlimit(l->resource, &limit))
		return (0);
	if (errno == EPERM)
		bi_errorf("%s exceeds allowable %s limit", v, l->name);
	else
		bi_errorf("bad %s limit: %s", l->name, strerror(errno));
	return (1);
}

static void
print_ulimit(const struct limits *l, int how)
{
	rlim_t val = (rlim_t)0;
	struct rlimit limit;

	if (getrlimit(l->resource, &limit)) {
		shf_puts("unknown\n", shl_stdout);
		return;
	}
	if (how & SOFT)
		val = limit.rlim_cur;
	else if (how & HARD)
		val = limit.rlim_max;
	if (val == RLIM_INFINITY)
		shf_puts("unlimited\n", shl_stdout);
	else
		shprintf("%ld\n", (long)(val / l->factor));
a3069 37

#if HAVE_REALPATH
int
c_realpath(const char **wp)
{
	int rv = 1;

	if (wp != NULL && wp[0] != NULL && wp[1] != NULL) {
		if (strcmp(wp[1], "--")) {
			if (wp[2] == NULL) {
				wp += 1;
				rv = 0;
			}
		} else {
			if (wp[2] != NULL && wp[3] == NULL) {
				wp += 2;
				rv = 0;
			}
		}
	}

	if (rv)
		bi_errorf(T_synerr);
	else {
		char *buf;

		if (realpath(*wp, (buf = alloc(PATH_MAX, ATEMP))) == NULL) {
			rv = errno;
			bi_errorf("%s: %s", *wp, strerror(rv));
		} else
			shprintf("%s\n", buf);
		afree(buf, ATEMP);
	}

	return (rv);
}
#endif
@


1.69.2.3
log
@MFC: mksh R35
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.31 2008/05/17 23:31:52 sobrado Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.83 2008/06/08 17:16:25 tg Exp $");
d1306 3
a1308 3
		shf_puts("usage:\tkill [-s signame | -signum | -signame]"
		    " { job | pid | pgrp } ...\n"
		    "\tkill -l [exit_status ...]\n", shl_out);
@


1.69.2.4
log
@MFC: mksh R35b
@
text
@d8 1
a8 1
__RCSID("$MirOS$");
d1077 2
a1078 4
		if ((val = cstrchr(alias, '='))) {
			h = val++ - alias;
			alias = xalias = str_nsave(alias, h, ATEMP);
		}
d1106 2
a1107 1
			newval = tflag ? search(alias, path, X_OK, NULL) : val;
d2211 1
d2227 3
d2231 1
a2231 1
		tf |= t->left->str[0];
@


1.69.2.5
log
@MFC: mksh R36b
@
text
@d2 1
a2 1
/*	$OpenBSD: c_sh.c,v 1.38 2008/07/23 16:34:38 jaredy Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.93 2008/12/13 17:02:14 tg Exp $");
d172 1
a172 2
		strdupx(allocd, wp[0], ATEMP);
		if (ksh_isdash((dir = allocd))) {
d505 2
a506 1
		histsave(&source->line, Xstring(xs, xp), true, false);
d1078 2
a1079 2
			strndupx(xalias, alias, val++ - alias, ATEMP);
			alias = xalias;
d1105 1
a1105 1
				afree(ap->val.s, APERM);
d1110 1
a1110 1
				strdupx(ap->val.s, newval, APERM);
d1162 1
a1162 1
			afree(ap->val.s, APERM);
d1173 1
a1173 1
				afree(ap->val.s, APERM);
d1504 1
a1504 1
			strdupx(up, *wp, ATEMP);
d1785 1
a1785 1
		strdupx(wpalloc, *wp, ATEMP);
d1897 2
a1898 1
		histsave(&source->line, Xstring(xs, xp), true, false);
d2115 1
a2115 1
			strdupx(*wp, *wp, &l->area);
d2117 2
a2118 1
		l->argv = alloc((l->argc + 2) * sizeof (char *), &l->area);
d2228 1
a2228 2
		if (t->left->type == TCOM)
			tf |= t->left->str[0];
d2310 2
a2311 2
			/* For ksh (but not sh), keep anything > 2 private */
			if (!Flag(FPOSIX) && i > 2 && e->savefd[i])
@


1.68
log
@live code from FOSDEM: add print \xDB and \u20AC, including regression test
agreed bsiegert@@
good idea and manpage diff ok'd by some netbsd person sitting next to me
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.67 2007/10/25 15:23:09 tg Exp $");
d1683 1
a1683 1
	return 0;
d1697 1
a1697 1
		return 1;
d1699 4
a1702 2
	if ((cp = wp[builtin_opt.optind]) == NULL)
		return 0;
d1706 1
a1706 1
		return 1;
d1722 1
a1722 1
		return 1;
d1724 1
a1724 1
	return i;
@


1.67
log
@get rid of u_char, u_int, u_long
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.66 2007/10/18 20:32:32 tg Exp $");
d452 51
@


1.66
log
@first step towards mksh R32 ☺
allow array indices in the uint32_t range (0‥4294967295) and map negatives
into that range; adjust manual page and regression tests; to be used RSN ☻
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.65 2007/09/09 18:06:40 tg Exp $");
d906 1
a906 1
							    (u_long)vp->index);
@


1.65
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.64 2007/08/19 23:12:21 tg Exp $");
d904 3
a906 2
							shprintf("%s[%d]",
							    vp->name, vp->index);
@


1.64
log
@employ string pooling techniques to save off a few more bytes
(probably more than the new “rename” builtin ever required…)
@
text
@d1 2
a2 2
/*	$OpenBSD: c_ksh.c,v 1.29 2006/03/12 00:26:58 deraadt Exp $	*/
/*	$OpenBSD: c_sh.c,v 1.35 2006/04/10 14:38:59 jaredy Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.63 2007/08/19 22:06:26 tg Exp $");
d284 1
d307 7
a313 3
	if (!p && !(p = ksh_get_wd(NULL))) {
		bi_errorf("can't get current directory - %s", strerror(errno));
		return 1;
d316 1
d1919 1
d2100 2
a2101 2
	int optc, unset_var = 1;
	int ret = 0;
d2106 1
a2106 1
			unset_var = 0;
d2109 1
a2109 1
			unset_var = 1;
d2112 1
a2112 1
			return 1;
a2118 2
			if (!(vp->flag & ISSET))
			    ret = 1;
d2121 1
a2121 1
				return 1;
d2124 3
a2126 5
		} else {		/* unset function */
			if (define(id, (struct op *) NULL))
				ret = 1;
		}
	return ret;
@


1.63
log
@new builtin “rename” (this name sounds better than “mksh_mv_rescue” ☻)
to just call rename(2) directly, e.g. if /bin/mv needs /lib/ld-uClibc.so.0

some assorted code cleanup
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.62 2007/07/31 13:55:26 tg Exp $");
d3036 1
a3036 1
		bi_errorf("syntax error");
@


1.62
log
@do the rlim_t for tcc cast dance for Debian GNU/kFreeBSD
@
text
@d8 120
a127 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.61 2007/07/31 11:11:24 tg Exp $");
a1200 6
struct kill_info {
	int num_width;
	int name_width;
};
static char *kill_fmt_entry(const void *, int, char *, int);

a1214 1

a1462 31
/* A leading = means assignments before command are kept;
 * a leading * means a POSIX special builtin;
 * a leading + means a POSIX regular builtin
 * (* and + should not be combined).
 */
const struct builtin kshbuiltins [] = {
	{"+alias", c_alias},	/* no =: at&t manual wrong */
	{"+cd", c_cd},
	{"+command", c_command},
	{"echo", c_print},
	{"*=export", c_typeset},
	{"+fc", c_fc},
	{"+getopts", c_getopts},
	{"+jobs", c_jobs},
	{"+kill", c_kill},
	{"let", c_let},
	{"print", c_print},
	{"pwd", c_pwd},
	{"*=readonly", c_typeset},
	{"=typeset", c_typeset},
	{"+unalias", c_unalias},
	{"whence", c_whence},
	{"+bg", c_fgbg},
	{"+fg", c_fgbg},
	{"bind", c_bind},
	{NULL, (int (*)(const char **))NULL}
};

static void p_time(struct shf *, int, struct timeval *, int,
    const char *, const char *);

d2288 1
a2288 1
static int
a2379 34
/* A leading = means assignments before command are kept;
 * a leading * means a POSIX special builtin;
 * a leading + means a POSIX regular builtin
 * (* and + should not be combined).
 */
const struct builtin shbuiltins [] = {
	{"*=.", c_dot},
	{"*=:", c_label},
	{"[", c_test},
	{"*=break", c_brkcont},
	{"=builtin", c_builtin},
	{"*=continue", c_brkcont},
	{"*=eval", c_eval},
	{"*=exec", c_exec},
	{"*=exit", c_exitreturn},
	{"+false", c_label},
	{"*=return", c_exitreturn},
	{"*=set", c_set},
	{"*=shift", c_shift},
	{"=times", c_times},
	{"*=trap", c_trap},
	{"+=wait", c_wait},
	{"+read", c_read},
	{"test", c_test},
	{"+true", c_label},
	{"ulimit", c_ulimit},
	{"+umask", c_umask},
	{"*=unset", c_unset},
#if HAVE_MKNOD
	{"mknod", c_mknod},
#endif
	{NULL, (int (*)(const char **))NULL}
};

a2402 58
struct t_op {
	char	op_text[4];
	Test_op	op_num;
};
static const struct t_op u_ops [] = {
	{"-a",	TO_FILAXST },
	{"-b",	TO_FILBDEV },
	{"-c",	TO_FILCDEV },
	{"-d",	TO_FILID },
	{"-e",	TO_FILEXST },
	{"-f",	TO_FILREG },
	{"-G",	TO_FILGID },
	{"-g",	TO_FILSETG },
	{"-h",	TO_FILSYM },
	{"-H",	TO_FILCDF },
	{"-k",	TO_FILSTCK },
	{"-L",	TO_FILSYM },
	{"-n",	TO_STNZE },
	{"-O",	TO_FILUID },
	{"-o",	TO_OPTION },
	{"-p",	TO_FILFIFO },
	{"-r",	TO_FILRD },
	{"-s",	TO_FILGZ },
	{"-S",	TO_FILSOCK },
	{"-t",	TO_FILTT },
	{"-u",	TO_FILSETU },
	{"-w",	TO_FILWR },
	{"-x",	TO_FILEX },
	{"-z",	TO_STZER },
	{"",	TO_NONOP }
};
static const struct t_op b_ops [] = {
	{"=",	TO_STEQL },
	{"==",	TO_STEQL },
	{"!=",	TO_STNEQ },
	{"<",	TO_STLT },
	{">",	TO_STGT },
	{"-eq",	TO_INTEQ },
	{"-ne",	TO_INTNE },
	{"-gt",	TO_INTGT },
	{"-ge",	TO_INTGE },
	{"-lt",	TO_INTLT },
	{"-le",	TO_INTLE },
	{"-ef",	TO_FILEQ },
	{"-nt",	TO_FILNT },
	{"-ot",	TO_FILOT },
	{"",	TO_NONOP }
};

static int	test_eaccess(const char *, int);
static int	test_oexpr(Test_env *, int);
static int	test_aexpr(Test_env *, int);
static int	test_nexpr(Test_env *, int);
static int	test_primary(Test_env *, int);
static int	ptest_isa(Test_env *, Test_meta);
static const char *ptest_getopnd(Test_env *, Test_op, int);
static void	ptest_error(Test_env *, int, const char *);

d3025 19
@


1.61
log
@• new way of checking for mknod & friends, due to tcc vs glibc weirdness
• bump vsn for the code restructuring
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.60 2007/07/22 14:01:48 tg Exp $");
d2907 1
a2907 1
	rlim_t		val = 0;
d2955 1
a2955 1
			val = RLIM_INFINITY;
d2972 1
a2972 1
			val = (rlim_t)rval * l->factor;
d2997 2
a2998 2
				val /= l->factor;
				shprintf("%ld\n", (long) val);
d3030 2
a3031 2
			val /= l->factor;
			shprintf("%ld\n", (long) val);
@


1.60
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.59 2007/07/22 13:34:49 tg Exp $");
d2206 1
a2206 1
#if !defined(MKSH_SMALL) || defined(MKSH_NEED_MKNOD)
d2327 1
a2327 1
#if !defined(MKSH_SMALL) || defined(MKSH_NEED_MKNOD)
@


1.59
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.58 2007/07/01 21:10:28 tg Exp $");
d1145 1
a1145 1
		bi_errorf("");
@


1.58
log
@Borland C++ found these
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.57 2007/06/06 23:41:23 tg Exp $");
d497 1
a497 1
			shprintf(newline);
d796 1
a796 1
						shprintf(newline);
d890 1
a890 1
				shprintf(newline);
d915 1
a915 1
				shprintf(newline);
d1145 1
a1145 1
		bi_errorf(null);
@


1.57
log
@more errno cleanup
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.56 2007/06/06 23:28:15 tg Exp $");
d516 1
a516 1
	struct block *l = e->loc;
d1977 1
a1977 1
	const char **owp = wp;
@


1.56
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.55 2007/06/05 19:18:11 tg Exp $");
d3011 2
a3012 1
				if (errno == EPERM)
d3016 1
a3016 1
					    strerror(errno));
@


1.55
log
@On Solaris:

../mksh/funcs.c:2254: warning: declaration of 'major' shadows a global declaration
/usr/include/sys/mkdev.h:68: warning: shadowed declaration is here
../mksh/funcs.c:2254: warning: declaration of 'minor' shadows a global declaration
/usr/include/sys/mkdev.h:69: warning: shadowed declaration is here

(that's yofuh's system)
SunOS mirfoo 5.10 Generic_125100-04 sun4u sparc SUNW,Ultra-80
Reading specs from /usr/local/lib/gcc/sparc-sun-solaris2.10/3.4.6/specs
Configured with: ../configure --with-as=/usr/ccs/bin/as --with-ld=/usr/ccs/bin/ld --enable-shared --enable-languages=c,c++,f77
Thread model: posix
gcc version 3.4.6
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.54 2007/06/04 21:33:27 tg Exp $");
d1793 2
a1794 1
	int savef, rv;
d1847 2
a1848 6
		int anydfl = 0;

		for (p = sigtraps, i = NSIG+1; --i >= 0; p++) {
			if (p->trap == NULL)
				anydfl = 1;
			else {
a1852 1
		}
d2266 1
a2266 1
			bi_errorf("device major too large: %ld", majnum);
d2270 1
a2270 1
			bi_errorf("device minor too large: %ld", minnum);
@


1.54
log
@compile warning-free on SUNpro (regression test suite pass) for MirBSD
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.53 2007/05/13 18:49:00 tg Exp $");
d2254 1
a2254 1
		unsigned long major, minor;
d2258 1
a2258 1
		major = strtoul(argv[2], &c, 0);
d2263 1
a2263 1
		minor = strtoul(argv[3], &c, 0);
d2268 3
a2270 3
		dv = makedev(major, minor);
		if ((unsigned long)major(dv) != major) {
			bi_errorf("device major too large: %ld", major);
d2273 2
a2274 2
		if ((unsigned long)minor(dv) != minor) {
			bi_errorf("device minor too large: %ld", minor);
@


1.53
log
@dead code removal
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.52 2007/05/13 18:33:28 tg Exp $");
d1376 1
a1376 1
	{NULL, NULL}
d2334 1
a2334 1
	{NULL, NULL}
@


1.52
log
@Possible fix for Coverity CID#7:
convert options() prototype to unsigned (size_t, in fact), and make an
explicitly casted (size_t)-1 the error return code, modelled after what
is often used in Unix libraries
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.51 2007/05/13 18:15:25 tg Exp $");
a2415 2
static int	ptest_eval(Test_env *, Test_op, const char *,
		    const char *, int);
d2428 1
a2428 1
	te.eval = ptest_eval;
a2827 7
static int
ptest_eval(Test_env *te, Test_op op, const char *opnd1, const char *opnd2,
    int do_eval)
{
	return test_eval(te, op, opnd1, opnd2, do_eval);
}

@


1.51
log
@Fix for Coverity CID #6 (null pointer dereference in error path)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.50 2007/05/13 17:51:21 tg Exp $");
d2520 2
a2521 2
	int res;
	int not;
d2527 1
a2527 1
	switch ((int) op) {
d2536 1
a2536 1
		if ((not = *opnd1 == '!'))
d2538 2
a2539 2
		if ((res = option(opnd1)) < 0)
			res = 0;
d2541 3
a2543 3
			res = Flag(res);
			if (not)
				res = !res;
d2545 1
a2545 1
		return res;
d2587 1
a2587 1
		if (opnd1 && !bi_getn(opnd1, &res)) {
d2589 1
a2589 1
			res = 0;
d2591 2
a2592 2
			res = isatty(opnd1 ? res : 0);
		return res;
@


1.50
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.49 2007/03/10 18:16:26 tg Exp $");
d1966 2
a1967 1
		last_ep->flags &= ~EF_BRKCONT_PASS;
@


1.49
log
@some gcc 4.1.2pre warning shutup
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.48 2007/03/04 03:04:25 tg Exp $");
d1248 1
a1248 1
		internal_errorf(0, "c_getopts: no argv");
d2955 1
a2955 1
		internal_errorf(0, "ulimit: %c", what);
@


1.49.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.49 2007/03/10 18:16:26 tg Exp $");
d1248 1
a1248 1
		internal_warningf("c_getopts: no argv");
d1966 1
a1966 2
		if (last_ep)
			last_ep->flags &= ~EF_BRKCONT_PASS;
d2415 2
d2429 1
a2429 1
	te.eval = test_eval;
d2519 2
a2520 2
	int i;
	size_t k;
d2526 1
a2526 1
	switch ((int)op) {
d2535 1
a2535 1
		if ((i = *opnd1 == '!'))
d2537 2
a2538 2
		if ((k = option(opnd1)) == (size_t)-1)
			k = 0;
d2540 3
a2542 3
			k = Flag(k);
			if (i)
				k = !k;
d2544 1
a2544 1
		return k;
d2586 1
a2586 1
		if (opnd1 && !bi_getn(opnd1, &i)) {
d2588 1
a2588 1
			i = 0;
d2590 2
a2591 2
			i = isatty(opnd1 ? i : 0);
		return (i);
d2829 7
d2955 1
a2955 1
		internal_warningf("ulimit: %c", what);
@


1.49.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.49.2.1 2007/05/13 19:29:35 tg Exp $");
d516 1
a516 1
	struct block *l;
d1981 1
a1981 1
	const char **owp;
@


1.48
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d8 1
a8 1
__RCSID("$MirOS$");
a1919 1
	return 0;
a2096 1
	extern struct timeval j_usrtime, j_systime; /* computed by j_wait */
@


1.47
log
@merge the const branch +- a few
@
text
@d56 1
a56 1
		if (strcmp(dir, "-") == 0) {
d283 1
a283 1
			    strcmp(wp[builtin_opt.optind], "-") == 0)
d1317 2
a1318 1
	char *cp;
d1337 7
a1343 4
		cp = strchr(*wp, '=');
		if (cp != NULL)
			*cp++ = '\0';
		if (x_bind(*wp, cp, macro, 0))
d1345 1
d1480 1
a1480 1
				while (*cp && strchr("augo", *cp))
d1497 1
a1497 1
				if (!strchr("=+-", op = *cp))
d1501 1
a1501 1
				while (*cp && strchr("rwxugoXs", *cp))
d1533 1
a1533 1
				} else if (!strchr("=+-", *cp))
d2041 1
a2041 1
			unset(vp, strchr(id, '[') ? 1 : 0);
@


1.46
log
@add c_mknod() if MKSH_NEED_MKNOD even if MKSH_SMALL
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.45 2007/01/15 00:18:47 tg Exp $");
d11 1
a11 1
c_cd(char **wp)
d24 1
d55 1
a55 1
		dir = wp[0];
d57 1
d64 2
a65 1
		}
d89 1
d121 1
d155 1
d160 1
a160 1
c_pwd(char **wp)
d196 1
a196 1
c_print(char **wp)
d205 1
a205 1
	char *s;
d384 1
a384 1
c_whence(char **wp)
d387 1
a387 1
	char *id;
d504 1
a504 1
c_command(char **wp)
d514 1
a514 1
c_typeset(char **wp)
d521 1
a521 1
	char *fieldstr, *basestr;
d811 1
a811 1
c_alias(char **wp)
d865 3
a867 2
		static char args0[] = "unalias", args1[] = "-ta",
		    *args[] = { args0, args1, NULL };
d895 3
a897 2
		char *alias = *wp;
		char *val = strchr(alias, '=');
d902 2
a903 2
		if (val)
			alias = str_nsave(alias, val++ - alias, ATEMP);
d944 1
a944 2
		if (val)
			afree(alias, ATEMP);
d951 1
a951 1
c_unalias(char **wp)
d1007 1
a1007 1
c_let(char **wp)
d1025 1
a1025 1
c_jobs(char **wp)
d1062 1
a1062 1
c_fgbg(char **wp)
d1104 1
a1104 1
c_kill(char **wp)
d1107 1
a1107 1
	char *p;
d1217 1
a1217 1
c_getopts(char **wp)
d1314 1
a1314 1
c_bind(char **wp)
d1379 1
a1379 1
c_label(char **wp)
d1385 1
a1385 1
c_shift(char **wp)
d1390 1
a1390 1
	char *arg;
d1416 1
a1416 1
c_umask(char **wp)
d1419 1
a1419 1
	char *cp;
d1437 1
a1437 1
			char buf[18];
d1441 1
a1441 1
			cp = buf;
d1443 2
a1444 2
				*cp++ = "ugo"[i];
				*cp++ = '=';
d1447 2
a1448 2
						*cp++ = "rwx"[j];
				*cp++ = ',';
d1450 1
a1450 1
			cp[-1] = '\0';
d1543 1
a1543 1
c_dot(char **wp)
d1546 2
a1547 2
	char *cp;
	char **argv;
d1582 1
a1582 1
c_wait(char **wp)
d1604 1
a1604 1
c_read(char **wp)
d1610 2
a1611 1
	char *cp;
d1618 1
a1618 1
	char *xp = NULL;
d1656 4
a1659 2
	if ((cp = strchr(*wp, '?')) != NULL) {
		*cp = 0;
d1684 1
a1684 1
	Xinit(cs, cp, 128, ATEMP);
d1686 1
a1686 1
		for (cp = Xstring(cs, cp); ; ) {
d1713 1
a1713 1
			Xcheck(cs, cp);
d1726 1
a1726 1
					Xput(cs, cp, c);
d1736 1
a1736 1
				if (Xlength(cs, cp) == 0 && ctype(c, C_IFSWS))
d1741 1
a1741 1
			Xput(cs, cp, c);
d1745 4
a1748 4
			while (Xlength(cs, cp) && ctype(cp[-1], C_IFS) &&
			    ctype(cp[-1], C_IFSWS))
				cp--;
		Xput(cs, cp, '\0');
d1754 1
d1759 4
a1762 3
		if (!setstr(vp, Xstring(cs, cp), KSH_RETURN_ERROR)) {
		    shf_flush(shf);
		    return 1;
d1780 1
d1785 1
a1785 1
c_eval(char **wp)
d1830 1
a1830 1
c_trap(char **wp)
d1833 1
a1833 1
	char *s;
d1877 1
a1877 1
c_exitreturn(char **wp)
d1881 1
a1881 1
	char *arg;
d1919 1
a1919 1
c_brkcont(char **wp)
d1923 1
a1923 1
	char *arg;
d1972 1
a1972 1
c_set(char **wp)
d1976 1
a1976 1
	char **owp = wp;
d1979 1
a1979 2
		static char args0[] = "set", args1[] = "-",
		    *args[] = { args0, args1, NULL };
d1993 2
a1994 1
		l->argv = (char **) alloc(sizeofN(char *, l->argc+2), &l->area);
d2008 1
a2008 1
c_unset(char **wp)
d2010 1
a2010 1
	char *id;
d2058 1
a2058 1
c_times(char **wp __unused)
d2163 1
a2163 1
	while ((optc = ksh_getopt(wp, &opt, ":p")) != -1)
d2188 1
a2188 1
c_exec(char **wp __unused)
d2208 1
a2208 1
c_mknod(char **wp)
d2212 1
a2212 1
	char **argv;
d2294 1
a2294 1
c_builtin(char **wp __unused)
d2417 1
a2417 1
c_test(char **wp)
d2448 1
a2448 1
		char **owp = wp;
d2850 1
a2850 1
c_ulimit(char **wp)
@


1.45
log
@ok, -rHEAD shall be unbroken
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.44 2007/01/14 23:57:44 tg Exp $");
d2193 1
a2193 1
#ifndef MKSH_SMALL
d2314 1
a2314 1
#ifndef MKSH_SMALL
@


1.44
log
@solaris 8 / gcc 3.4.3 / -m64 warnings
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.43 2007/01/12 10:18:20 tg Exp $");
d859 2
a860 3
		static const char *const args[] = {
			"unalias", "-ta", NULL
		};
d1966 2
a1967 1
		static const char *const args [] = { "set", "-", NULL };
@


1.44.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.46 2007/01/26 18:37:26 tg Exp $");
d859 3
a861 2
		static char args0[] = "unalias", args1[] = "-ta",
		    *args[] = { args0, args1, NULL };
d1967 1
a1967 2
		static char args0[] = "set", args1[] = "-",
		    *args[] = { args0, args1, NULL };
d2193 1
a2193 1
#if !defined(MKSH_SMALL) || defined(MKSH_NEED_MKNOD)
d2314 1
a2314 1
#if !defined(MKSH_SMALL) || defined(MKSH_NEED_MKNOD)
@


1.44.2.2
log
@something in the merge didn't work out
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.44.2.1 2007/03/03 21:37:55 tg Exp $");
d859 2
a860 3
		static const char *const args[] = {
			"unalias", "-ta", NULL
		};
d1966 2
a1967 1
		static const char *const args [] = { "set", "-", NULL };
@


1.44.2.3
log
@more constification
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.44.2.2 2007/03/03 21:43:49 tg Exp $");
d11 1
a11 1
c_cd(const char **wp)
a23 1
	bool dir_ = false;
d54 1
a54 1
		dir = str_save(wp[0], ATEMP);
a55 1
			afree(dir, ATEMP);
d62 1
a62 2
		} else
			dir_ = true;
a85 1
		dir_ = true;
a116 2
		if (dir_)
			afree(dir, ATEMP);
a149 2
	if (dir_)
		afree(dir, ATEMP);
d154 1
a154 1
c_pwd(const char **wp)
d190 1
a190 1
c_print(const char **wp)
d199 1
a199 1
	const char *s;
d378 1
a378 1
c_whence(const char **wp)
d381 1
a381 1
	const char *id;
d498 1
a498 1
c_command(const char **wp)
d508 1
a508 1
c_typeset(const char **wp)
d515 1
a515 1
	const char *fieldstr, *basestr;
d805 1
a805 1
c_alias(const char **wp)
d859 1
a859 1
		static const char *args[] = {
d889 2
a890 3
		const char *alias = *wp;
		char *xalias = NULL;
		const char *val;
d895 2
a896 2
		if ((val = cstrchr(alias, '=')))
			alias = xalias = str_nsave(alias, val++ - alias, ATEMP);
d937 2
a938 1
		afreechk(xalias);
d945 1
a945 1
c_unalias(const char **wp)
d1001 1
a1001 1
c_let(const char **wp)
d1019 1
a1019 1
c_jobs(const char **wp)
d1056 1
a1056 1
c_fgbg(const char **wp)
d1098 1
a1098 1
c_kill(const char **wp)
d1101 1
a1101 1
	const char *p;
d1211 1
a1211 1
c_getopts(const char **wp)
d1308 1
a1308 1
c_bind(const char **wp)
d1373 1
a1373 1
c_label(const char **wp)
d1379 1
a1379 1
c_shift(const char **wp)
d1384 1
a1384 1
	const char *arg;
d1410 1
a1410 1
c_umask(const char **wp)
d1413 1
a1413 1
	const char *cp;
d1431 1
a1431 1
			char buf[18], *p;
d1435 1
a1435 1
			p = buf;
d1437 2
a1438 2
				*p++ = "ugo"[i];
				*p++ = '=';
d1441 2
a1442 2
						*p++ = "rwx"[j];
				*p++ = ',';
d1444 1
a1444 1
			p[-1] = '\0';
d1537 1
a1537 1
c_dot(const char **wp)
d1540 2
a1541 2
	const char *cp;
	const char **argv;
d1576 1
a1576 1
c_wait(const char **wp)
d1598 1
a1598 1
c_read(const char **wp)
d1604 1
a1604 2
	const char *cp;
	char *ccp;
d1611 1
a1611 1
	char *xp = NULL, *wpalloc = NULL;
d1649 2
a1650 4
	if ((cp = cstrchr(*wp, '?')) != NULL) {
		wpalloc = str_save(*wp, ATEMP);
		wpalloc[cp - *wp] = '\0';
		*wp = wpalloc;
d1675 1
a1675 1
	Xinit(cs, ccp, 128, ATEMP);
d1677 1
a1677 1
		for (ccp = Xstring(cs, ccp); ; ) {
d1704 1
a1704 1
			Xcheck(cs, ccp);
d1717 1
a1717 1
					Xput(cs, ccp, c);
d1727 1
a1727 1
				if (Xlength(cs, ccp) == 0 && ctype(c, C_IFSWS))
d1732 1
a1732 1
			Xput(cs, ccp, c);
d1736 4
a1739 4
			while (Xlength(cs, ccp) && ctype(ccp[-1], C_IFS) &&
			    ctype(ccp[-1], C_IFSWS))
				ccp--;
		Xput(cs, ccp, '\0');
a1744 1
			afreechk(wpalloc);
d1749 3
a1751 4
		if (!setstr(vp, Xstring(cs, ccp), KSH_RETURN_ERROR)) {
			shf_flush(shf);
			afreechk(wpalloc);
			return 1;
a1768 1
	afreechk(wpalloc);
d1773 1
a1773 1
c_eval(const char **wp)
d1818 1
a1818 1
c_trap(const char **wp)
d1821 1
a1821 1
	const char *s;
d1865 1
a1865 1
c_exitreturn(const char **wp)
d1869 1
a1869 1
	const char *arg;
d1907 1
a1907 1
c_brkcont(const char **wp)
d1911 1
a1911 1
	const char *arg;
d1960 1
a1960 1
c_set(const char **wp)
d1964 1
a1964 1
	const char **owp = wp;
d1967 1
a1967 1
		static const char *args [] = { "set", "-", NULL };
d1981 1
a1981 2
		l->argv = (const char **) alloc(sizeofN(char *, l->argc+2),
		     &l->area);
d1995 1
a1995 1
c_unset(const char **wp)
d1997 1
a1997 1
	const char *id;
d2045 1
a2045 1
c_times(const char **wp __unused)
d2150 1
a2150 1
	while ((optc = ksh_getopt((const char **)wp, &opt, ":p")) != -1)
d2175 1
a2175 1
c_exec(const char **wp __unused)
d2195 1
a2195 1
c_mknod(const char **wp)
d2199 1
a2199 1
	const char **argv;
d2281 1
a2281 1
c_builtin(const char **wp __unused)
d2404 1
a2404 1
c_test(const char **wp)
d2435 1
a2435 1
		const char **owp = wp;
d2837 1
a2837 1
c_ulimit(const char **wp)
@


1.43
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.42 2007/01/12 01:49:28 tg Exp $");
d2990 1
a2990 1
			if (val == RLIM_INFINITY)
d3022 1
a3022 1
		if (val == RLIM_INFINITY)
@


1.42
log
@* Scan for __attribute__((...)) in general (the earliest was 2.5,
  where we had 'noreturn' etc. but no '__noreturn__')
* Scan for __attribute__((bounded)) and __attribute__((used))
  if we have __attribute__((noreturn))
* To be able to scan if certain attributes give warnings,
  scan for -Werror with a simple programme which hopefully triggers none
* Convert __attribute__((unused)) to __unused, noreturn -> __dead
* Unify other attributes
* Clean up typography a little more
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.41 2007/01/12 00:25:39 tg Exp $");
d209 1
a209 1
		 * -n, -e and -E are recognized if they appear
d212 1
a212 1
		 * Different from sysV echo since options are recognized,
d859 3
a861 2
		static char args0[] = "unalias", args1[] = "-ta",
		    *args[] = { args0, args1, NULL };
d1967 1
a1967 2
		static char args0[] = "set", args1[] = "-",
		    *args[] = { args0, args1, NULL };
@


1.41
log
@Clean up the signal mess, saves 172 Bytes:
* 'sigseen' in Build.sh goes away
* Signal name existence is checked in this order:
  have our own¹ -> sys_signame[] -> _sys_signame[] -> build our own²
* Signal description existence is checked in this order:
  sys_siglist[] -> _sys_siglist[] -> strsignal() -> NULL³
¹ Predefined list of items, for operating systems where we
  cannot build² them, i.e. Plan 9 and Minix 3 (e.g. no $CPP -dD)
² The usual cpp(1) stuff
³ Changed later, see below
* Make $CPP test dependent on $NEED_MKSH_SIGNAME (others can
  be added here, this is not absolute)
* Make signal name list generation² dependent on $NEED_MKSH_SIGNAME
* Fix check if the generation worked
* Guarantee that sigtraps[*].name and sigtraps[*].mess are valid
  C strings; this makes the code shorter *and* removes a few pos-
  sible nil pointer dereferences
* Embed autoconf'd usages of sys_sig* / strsignal / mksh_sigpairs
  into inittraps()
* Check for each signal 0<=i<=NSIG that
  name is not NULL or "" -> replace with ("%d", i)
  mess is not NULL or "" -> replace with ("Signal %d", i)
  name does not start (case-insensitive) with "SIG" -> name += 3
* In gettrap(), fix check if signal name starts, case-sensitive
  or case-insensitive, depending on need, with "SIG" (bug from millert@@)

Other changes:
* Build.sh: ac_test[n]() are documented
* Build.sh: ac_test[n]() can have negative prereqs as well now
* Build.sh: use <<-'EOF' consistently
* bump patchlevel to today
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.40 2007/01/11 00:32:31 tg Exp $");
d2045 1
a2045 1
c_times(char **wp __attribute__((unused)))
d2175 1
a2175 1
c_exec(char **wp __attribute__((unused)))
d2281 1
a2281 1
c_builtin(char **wp __attribute__((unused)))
d2806 1
a2806 1
ptest_getopnd(Test_env *te, Test_op op, int do_eval __attribute__((unused)))
@


1.40
log
@expand ~foo to getpwnam("foo")->dir only #if !defined(MKSH_SMALL)
this makes it possible to build a (small) mksh on glibc systems statically
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.39 2006/12/06 13:41:23 tg Exp $");
d1088 4
a1091 10
	if (sigtraps[i].name)
		shf_snprintf(buf, buflen, "%*d %*s %s",
		    ki->num_width, i,
		    ki->name_width, sigtraps[i].name,
		    sigtraps[i].mess);
	else
		shf_snprintf(buf, buflen, "%*d %*d %s",
		    ki->num_width, i,
		    ki->name_width, sigtraps[i].signal,
		    sigtraps[i].mess);
d1149 1
a1149 1
				if (n > 0 && n < NSIG && sigtraps[n].name)
d1163 1
a1163 3
				w = sigtraps[j].name ?
				    (int)strlen(sigtraps[j].name) :
				    ki.num_width;
d1172 1
a1172 1
			    kill_fmt_entry, (void *) &ki,
@


1.39
log
@   Revision  [7]1.16  /  ([8]download)  -  [9]annotate  - [10][select for
   diffs] , Mon Nov 20 21:53:39 2006 UTC (2 weeks, 1 day ago) by miod
Compute user-given ulimit value times ulimit unit as an rlim_t value, not a
long value; catches some 32 bit overflows on 32 bit platforms.

Found by drahn@@, ok otto@@
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.38 2006/11/19 17:13:36 tg Exp $");
d818 3
d822 1
d957 3
d961 1
@


1.38
log
@fix 'typeset -p' to act according to TFM and ksh93
@
text
@d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.15 2006/03/12 00:26:58 deraadt Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.37 2006/11/12 14:58:14 tg Exp $");
d2968 1
a2968 1
			val = rval * l->factor;
@


1.37
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.36 2006/11/10 07:52:02 tg Exp $");
d586 1
a586 1
			break;
d771 1
a771 3
							shprintf("%s ",
							    (flag & EXPORT) ?
							    "export" : "readonly");
@


1.36
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.35 2006/11/10 06:53:26 tg Exp $");
d857 2
a858 3
		static const char *const args[] = {
			"unalias", "-ta", NULL
		};
d866 1
a866 1
		return c_unalias((char **) args);
d888 1
a888 1
		char *newval;
d1073 1
a1073 1
static char *kill_fmt_entry(void *arg, int i, char *buf, int buflen);
d1077 1
a1077 1
kill_fmt_entry(void *arg, int i, char *buf, int buflen)
d1079 1
a1079 1
	struct kill_info *ki = (struct kill_info *) arg;
d1540 2
a1541 1
	char *file, *cp;
d1968 3
a1970 2
		static const char *const args [] = { "set", "-", NULL };
		return c_typeset((char **) args);
@


1.35
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.34 2006/11/10 06:16:24 tg Exp $");
d1106 2
a1107 2
	if ((p = wp[1]) && *p == '-' && (digit(p[1]) ||
	    ksh_isupper((unsigned char)p[1]))) {
d1453 1
a1453 1
		if (digit(*cp)) {
d2965 1
a2965 1
			if (!rval && !digit(wp[0][0])) {
@


1.34
log
@don't use setreuid(2) etc. stuff, like OpenBSD
only affects suid shell scripts, which are *ugh* anyway,
and I really have no idea what the old code did, when, why, etc.
262t 16d 2i
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.33 2006/11/10 03:45:56 tg Exp $");
d1107 1
a1107 1
	    isupper((unsigned char)p[1]))) {
@


1.33
log
@correct a few protos and comments
saves 4 .text bytes and my nerves
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.32 2006/11/09 23:19:52 tg Exp $");
d179 1
a179 1
	if (p && eaccess(p, R_OK) < 0)
d2658 1
a2658 1
	int res = eaccess(pathl, mode);
@


1.32
log
@omit usage msg if small
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.31 2006/11/09 22:18:10 tg Exp $");
d181 3
a183 7
	if (!p) {
		p = ksh_get_wd(NULL, 0);
		if (!p) {
			bi_errorf("can't get current directory - %s",
			    strerror(errno));
			return 1;
		}
@


1.31
log
@don't compile mknod(1) builtin if MKSH_SMALL
saves 1037 text, 20 data (on i386)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.30 2006/08/24 20:32:52 tg Exp $");
d1138 1
d1142 1
@


1.30
log
@merge non-Plan9-specific stuff from the branch, add KNF, etc.
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.29 2006/08/01 13:43:26 tg Exp $");
d2196 1
d2280 1
d2317 1
d2319 1
@


1.29
log
@style(9)
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.28 2006/07/03 12:16:30 tg Exp $");
d2052 1
d2056 1
d2058 1
d2062 1
d2076 3
d2139 2
a2140 1
	return rv;
d2560 1
d2563 3
d3028 1
a3028 1
	return 0;
@


1.29.2.1
log
@initial attempt at porting mksh to the Plan 9 ANSI'n'POSIX Environment
struck dumb at SIGWINCH/TIOCGWINSZ, we'll have to ifdef out all of the
command line editing code as a next measure

incidentally, my qemu just crashed (not the guest OS - Plan 9 - no, it
really crashed the "outside" qemu programme, won't redraw or catch the
mouse any more), so I'll call it a day
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.29 2006/08/01 13:43:26 tg Exp $");
a2187 1
#ifndef __Plan9__
a2270 1
#endif
a2306 1
#ifndef __Plan9__
a2307 1
#endif
@


1.29.2.2
log
@some rlimit/ulimit stuff won't work on Plan 9
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.29.2.1 2006/08/15 23:49:52 tg Exp $");
a2051 1
#ifdef RUSAGE_SELF
a2054 1
#endif
a2055 1
#ifdef RUSAGE_CHILDREN
a2058 1
#endif
a2062 1

a2071 3
#if !defined(RUSAGE_SELF) || !defined(RUSAGE_CHILDREN)
	return (0);
#else
d2132 1
a2132 2
	return (rv);
#endif
a2555 1
#ifdef S_ISVTX
a2557 3
#else
		return (0);
#endif
a2829 1
#ifndef __Plan9__
d3020 1
a3020 2
#endif
	return (0);
@


1.29.2.3
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.30 2006/08/24 20:32:52 tg Exp $");
d2067 1
@


1.29.2.4
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.28
log
@fix the "char subscripts" issue, bump version
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.27 2006/05/10 18:54:10 tg Exp $");
d2257 1
a2257 1
c_mknod_failed:
d2259 1
a2259 1
c_mknod_err:
d2266 1
a2266 1
c_mknod_usage:
@


1.27
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.26 2006/01/30 12:37:22 tg Exp $");
d1110 2
a1111 1
	if ((p = wp[1]) && *p == '-' && (digit(p[1]) || isupper(p[1]))) {
@


1.26
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d1 2
a2 2
/*	$OpenBSD: c_ksh.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
/*	$OpenBSD: c_sh.c,v 1.31 2005/10/08 18:07:31 otto Exp $	*/
d4 1
a4 1
/*	$OpenBSD: c_ulimit.c,v 1.14 2005/03/30 17:16:37 deraadt Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.25 2006/01/29 20:04:51 tg Exp $");
d25 1
a25 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != EOF)
d160 1
a160 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "LP")) != EOF)
d242 1
a242 1
		while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != EOF)
d393 1
a393 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != EOF)
d552 1
a552 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != EOF) {
d820 1
a820 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "dprtUx")) != EOF) {
d954 1
a954 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "adt")) != EOF)
d1024 1
a1024 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "lpnz")) != EOF)
d1119 1
a1119 1
		while ((optc = ksh_getopt(wp, &builtin_opt, "ls:")) != EOF)
d1316 1
a1316 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "lm")) != EOF)
d1421 1
a1421 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "S")) != EOF)
d1616 1
a1616 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "prsu,")) != EOF)
d1904 1
a1904 1
	/*NOTREACHED*/
d1958 1
a1958 1
	/*NOTREACHED*/
d2003 1
a2003 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "fv")) != EOF)
d2144 1
a2144 1
	while ((optc = ksh_getopt(wp, &opt, ":p")) != EOF)
d2196 1
a2196 1
	while ((optc = ksh_getopt(wp, &builtin_opt, "m:")) != EOF) {
d2905 1
a2905 1
	while ((optc = ksh_getopt(wp, &builtin_opt, opts)) != EOF)
@


1.25
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.24 2005/11/22 18:40:42 tg Exp $");
d350 1
a350 1
		 * to just check that the co-process is alive, which is
d544 1
a544 1
	/* at&t ksh seems to have 0-9 as options, which are multiplied
@


1.24
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: c_ksh.c,v 1.27 2005/03/30 17:16:37 deraadt Exp $	*/
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.23 2005/10/25 19:53:27 tg Exp $");
d427 1
a427 1
			tp = tsearch(&keywords, id, hash(id));
d429 1
a429 1
			tp = tsearch(&aliases, id, hash(id));
d695 1
a695 1
			for (p = tsort(&l->funs); (vp = *p++); ) {
d708 1
a708 1
			for (p = tsort(&l->vars); (vp = *p++); ) {
d877 1
a877 1
		for (p = tsort(t); (ap = *p++) != NULL; )
d901 1
a901 1
			ap = tsearch(t, alias, h);
d917 1
a917 1
		ap = tenter(t, alias, h);
d971 1
a971 1
		ap = tsearch(t, *wp, hash(*wp));
d986 1
a986 1
		for (twalk(&ts, t); (ap = tnext(&ts)); ) {
@


1.23
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@a0 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.22 2005/10/25 19:35:14 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.22 2005/10/25 19:35:14 tg Exp $");
@


1.22
log
@another Slowlaris speciality...
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.21 2005/10/21 12:41:55 tg Exp $ */
a7 10
#include <sys/time.h>
#if defined(__sun__)
#include <sys/mkdev.h>
#endif
#include <sys/stat.h>
#include <sys/resource.h>
#include <ctype.h>
#if !defined(__OpenBSD__) && !defined(__CYGWIN__)
#include <ulimit.h>
#endif
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.21 2005/10/21 12:41:55 tg Exp $");
@


1.21
log
@follow OpenBSD and add mknod as mksh builtin (mknod <file> p acts as mkfifo)
but write a good chunk of that code myself (better structured, better error
handling, more gotos, less function calls, int -> bool)

passes all tests on mirbsd; this will become mksh R25 once tested on other
supported OSes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.20 2005/10/21 11:44:25 tg Exp $ */
d9 3
d19 1
a19 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.20 2005/10/21 11:44:25 tg Exp $");
@


1.20
log
@remove USE_PRINTF hooks, it never worked anyway, and probably nobody
is going to fix it...
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.19 2005/10/08 19:30:59 tg Exp $ */
d3 1
a3 1
/*	$OpenBSD: c_sh.c,v 1.29 2005/03/30 17:16:37 deraadt Exp $	*/
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.16 2005/08/21 12:52:29 tg Exp $");
d2195 84
d2314 1
@


1.19
log
@our test(1) promises we can do string1 < string2, and
our /bin/test uses mksh... so we pee (literally) on
POSIX and don't accept < and > only for [[ ... ]] operator
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.18 2005/09/12 19:28:18 tg Exp $ */
d16 1
a16 5
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.18 2005/09/12 19:28:18 tg Exp $");

#ifdef USE_PRINTF
int c_printf(char **);
#endif
a1081 14
#ifdef USE_PRINTF
int
c_printf(char **wp)
{
	extern int progprintf(int, char *[]);
	int argc;

	for (argc = 0; wp[argc]; argc++)
		;

	return progprintf(argc, wp);
}
#endif

a1375 3
#ifdef USE_PRINTF
	{"printf", c_printf},
#endif
@


1.18
log
@fix uber-pedantic Apple GCC 4
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.17 2005/08/26 22:03:55 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.17 2005/08/26 22:03:55 tg Exp $");
d2418 1
a2418 1
test_isop(Test_env *te, Test_meta meta, const char *s)
d2421 1
a2421 1
	const struct t_op *otab;
d2423 1
a2423 1
	otab = meta == TM_UNOP ? u_ops : b_ops;
d2426 3
a2428 6
		for (; otab->op_text[0]; otab++)
			if (sc1 == otab->op_text[1] &&
			    strcmp(s, otab->op_text) == 0 &&
			    ((te->flags & TEF_DBRACKET) ||
			    (otab->op_num != TO_STLT && otab->op_num != TO_STGT)))
				return otab->op_num;
d2722 1
a2722 1
		ret = test_isop(te, meta, *te->pos.wp);
@


1.17
log
@* add printf(1) as mksh(1) builtin on MirOS
  (or, more general, all systems using Makefile
  instead of Build.sh)
* document this fact
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.16 2005/08/21 12:52:29 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.16 2005/08/21 12:52:29 tg Exp $");
d1640 1
a1640 1
	XString cs, xs;
@


1.16
log
@follow style(9) ;)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.15 2005/07/06 00:02:05 tg Exp $ */
d16 5
a20 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.15 2005/07/06 00:02:05 tg Exp $");
d1086 14
d1394 3
@


1.15
log
@remove Korn's bizarre /dev/fd hack
(only affects Interix!)

Tests on /dev/fd are now officially unsupported in mksh too.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.14 2005/07/04 12:34:22 tg Exp $ */
d8 1
a9 1
#include <sys/time.h>
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.14 2005/07/04 12:34:22 tg Exp $");
@


1.14
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.13 2005/07/04 12:27:26 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.13 2005/07/04 12:27:26 tg Exp $");
a2304 1
static int	test_stat(const char *, struct stat *);
a2451 1
		return test_stat(opnd1, &b1) == 0;
a2452 3
		/* at&t ksh does not appear to do the /dev/fd/ thing for
		 * this (unless the os itself handles it)
		 */
d2455 1
a2455 1
		return test_stat(opnd1, &b1) == 0 && S_ISREG(b1.st_mode);
d2457 1
a2457 1
		return test_stat(opnd1, &b1) == 0 && S_ISDIR(b1.st_mode);
d2459 1
a2459 1
		return test_stat(opnd1, &b1) == 0 && S_ISCHR(b1.st_mode);
d2461 1
a2461 1
		return test_stat(opnd1, &b1) == 0 && S_ISBLK(b1.st_mode);
d2463 1
a2463 1
		return test_stat(opnd1, &b1) == 0 && S_ISFIFO(b1.st_mode);
d2467 1
a2467 1
		return test_stat(opnd1, &b1) == 0 && S_ISSOCK(b1.st_mode);
d2471 1
a2471 1
		return test_stat(opnd1, &b1) == 0 &&
d2474 1
a2474 1
		return test_stat(opnd1, &b1) == 0 &&
d2477 1
a2477 1
		return test_stat(opnd1, &b1) == 0 &&
d2480 1
a2480 1
		return test_stat(opnd1, &b1) == 0 && b1.st_size > 0L;
d2489 1
a2489 1
		return test_stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid;
d2491 1
a2491 1
		return test_stat(opnd1, &b1) == 0 && b1.st_gid == getegid();
d2565 1
a2565 17
/* Nasty kludge to handle Korn's bizarre /dev/fd hack */
static int
test_stat(const char *pathl, struct stat *statb)
{
#ifdef __INTERIX
	int fd;

	if (strncmp(pathl, "/dev/fd/", 8) == 0 && getn(pathl + 8, &fd))
		return fstat(fd, statb);
#endif

	return stat(pathl, statb);
}

/* Routine to handle Korn's /dev/fd hack, and to deal with X_OK on
 * non-directories when running as root.
 */
d2569 1
a2569 17
	int res;

#ifdef __INTERIX
	int fd;

	/* Note: doesn't handle //dev/fd, etc.. (this is ok) */
	if (strncmp(pathl, "/dev/fd/", 8) == 0 && getn(pathl + 8, &fd)) {
		int flags;

		if ((flags = fcntl(fd, F_GETFL, 0)) < 0
		    || (mode & X_OK)
		    || ((mode & W_OK) && (flags & O_ACCMODE) == O_RDONLY)
		    || ((mode & R_OK) && (flags & O_ACCMODE) == O_WRONLY))
			return -1;
		return 0;
	}
#endif /* !HAVE_DEV_FD */
a2570 5
	res = eaccess(pathl, mode);
	/*
	 * On most (all?) unixes, access() says everything is executable for
	 * root - avoid this on files by using stat().
	 */
a2581 1

@


1.13
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.12 2005/06/24 15:40:38 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.12 2005/06/24 15:40:38 tg Exp $");
d2186 2
a2187 7
			/*
			 * For ksh keep anything > 2 private,
			 * for sh, let them be (POSIX says what
			 * happens is unspecified and the bourne shell
			 * keeps them open).
			 */
			if (!Flag(FSH) && i > 2 && e->savefd[i])
@


1.12
log
@missing piece
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.11 2005/06/08 10:25:40 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.11 2005/06/08 10:25:40 tg Exp $");
d1079 1
a1079 4
	/* POSIX says fg shall return 0 (unless an error occurs).
	 * at&t ksh returns the exit value of the job...
	 */
	return (bg || Flag(FPOSIX)) ? 0 : rv;
a1163 6
		} else if (Flag(FPOSIX)) {
			p = null;
			for (i = 1; i < NSIG; i++, p = space)
				if (sigtraps[i].name)
					shprintf("%s%s", p, sigtraps[i].name);
			shprintf(newline);
d1216 1
a1216 2
		ksh_getopt_reset(&user_opt,
		    GF_NONAME | (Flag(FPOSIX) ? 0 : GF_PLUSOPT));
d1792 26
a1817 27
	if (!Flag(FPOSIX)) {
		/*
		 * Handle case where the command is empty due to failed
		 * command substitution, eg, eval "$(false)".
		 * In this case, shell() will not set/change exstat (because
		 * compiled tree is empty), so will use this value.
		 * subst_exstat is cleared in execute(), so should be 0 if
		 * there were no substitutions.
		 *
		 * A strict reading of POSIX says we don't do this (though
		 * it is traditionally done). [from 1003.2-1992]
		 *    3.9.1: Simple Commands
		 *	... If there is a command name, execution shall
		 *	continue as described in 3.9.1.1.  If there
		 *	is no command name, but the command contained a command
		 *	substitution, the command shall complete with the exit
		 *	status of the last command substitution
		 *    3.9.1.1: Command Search and Execution
		 *	...(1)...(a) If the command name matches the name of
		 *	a special built-in utility, that special built-in
		 *	utility shall be invoked.
		 * 3.14.5: Eval
		 *	... If there are no arguments, or only null arguments,
		 *	eval shall return an exit status of zero.
		 */
		exstat = subst_exstat;
	}
d2001 1
a2001 1
	return Flag(FPOSIX) ? 0 : subst_exstat;
d2379 1
a2379 5
				/* Historically, -t by itself test if fd 1
				 * is a file descriptor, but POSIX says its
				 * a string test...
				 */
				if (!Flag(FPOSIX) && strcmp(opnd1, "-t") == 0)
d2495 1
a2495 2
		} else {
			/* generate error if in FPOSIX mode? */
a2496 1
		}
@


1.11
log
@Interix defines RLIMIT_VMEM to RLIMIT_AS, no need for us to act (sigh)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.10 2005/06/08 10:14:08 tg Exp $ */
d12 1
a12 1
#if !defined(__OpenBSD__)
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.10 2005/06/08 10:14:08 tg Exp $");
@


1.10
log
@use RLIMIT_AS if RLIMIT_VMEM is not available
they roughly equal each other anyway
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.9 2005/05/25 23:31:06 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.9 2005/05/25 23:31:06 tg Exp $");
a2871 3
#elif defined(RLIMIT_AS)
		{ "amemory(KiB)", RLIMIT, RLIMIT_AS, RLIMIT_AS,
		    1024, 'v' },
@


1.9
log
@* fix emacs [ tabcompletion bug
  XXX it's probably a bug in vi mode too, it just doesn't show
* bring manual page and reality into closer sync'd state
* sort ulimits
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.8 2005/05/25 13:46:00 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.8 2005/05/25 13:46:00 tg Exp $");
d2872 3
@


1.8
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.7 2005/05/25 09:39:49 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.7 2005/05/25 09:39:49 tg Exp $");
a2824 12
#ifdef RLIMIT_CPU
		{ "time(cpu-seconds)", RLIMIT, RLIMIT_CPU, RLIMIT_CPU,
		    1, 't' },
#endif
#ifdef RLIMIT_TIME
		{ "humantime(seconds)", RLIMIT, RLIMIT_TIME, RLIMIT_TIME,
		    1, 'T' },
#endif
#ifdef RLIMIT_FSIZE
		{ "file(blocks)", RLIMIT, RLIMIT_FSIZE, RLIMIT_FSIZE,
		    512, 'f' },
#endif
d2833 7
a2839 3
#ifdef RLIMIT_STACK
		{ "stack(KiB)", RLIMIT, RLIMIT_STACK, RLIMIT_STACK,
		    1024, 's' },
d2857 12
a2876 4
#ifdef RLIMIT_LOCKS
		{ "flocks", RLIMIT, RLIMIT_LOCKS, RLIMIT_LOCKS,
		    -1, 'L' },
#endif
@


1.7
log
@make mksh -exc 'eval false || true'; echo $? echo 0 not 1
From Debian bug #269067
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.6 2005/05/25 09:18:16 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.6 2005/05/25 09:18:16 tg Exp $");
d187 1
a187 1
	if (p && access(p, R_OK) < 0)
d2630 1
a2630 1
	res = access(pathl, mode);
@


1.6
log
@* add RLIMIT_LOCKS from Debian pdksh diff
* unify ifdef and spacing of all RLIMITs
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.5 2005/05/23 15:24:42 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.5 2005/05/23 15:24:42 tg Exp $");
d1795 2
a1796 1
	struct source *s;
d1830 6
a1835 1
	return shell(s, false);
@


1.5
log
@missing preprocessor defines on Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.4 2005/05/23 15:23:12 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.4 2005/05/23 15:23:12 tg Exp $");
d2819 4
a2822 1
		{ "time(cpu-seconds)", RLIMIT, RLIMIT_CPU, RLIMIT_CPU, 1, 't' },
d2824 18
a2841 1
		{ "humantime(seconds)", RLIMIT, RLIMIT_TIME, RLIMIT_TIME, 1, 'T' },
a2842 4
		{ "file(blocks)", RLIMIT, RLIMIT_FSIZE, RLIMIT_FSIZE, 512, 'f' },
		{ "coredump(blocks)", RLIMIT, RLIMIT_CORE, RLIMIT_CORE, 512, 'c' },
		{ "data(KiB)", RLIMIT, RLIMIT_DATA, RLIMIT_DATA, 1024, 'd' },
		{ "stack(KiB)", RLIMIT, RLIMIT_STACK, RLIMIT_STACK, 1024, 's' },
d2848 2
a2849 1
		{ "memory(KiB)", RLIMIT, RLIMIT_RSS, RLIMIT_RSS, 1024, 'm' },
d2851 1
d2854 1
d2856 2
a2857 1
		{ "processes", RLIMIT, RLIMIT_NPROC, RLIMIT_NPROC, 1, 'p' },
d2860 3
a2862 2
		{ "vmemory(KiB)", RLIMIT, RLIMIT_VMEM, RLIMIT_VMEM, 1024, 'v' },
#endif /* RLIMIT_VMEM */
d2864 6
a2869 1
		{ "swap(KiB)", RLIMIT, RLIMIT_SWAP, RLIMIT_SWAP, 1024, 'w' },
d2945 8
d2954 1
@


1.4
log
@-Wformat catched on solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.3 2005/05/23 15:18:16 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.3 2005/05/23 15:18:16 tg Exp $");
d2827 1
d2830 2
d2833 1
d2836 1
d2838 1
@


1.3
log
@* Solaris misses sig_t
* our gmatch becomes gmatchx, it's extended against sh(C)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.2 2005/05/23 14:19:13 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.2 2005/05/23 14:19:13 tg Exp $");
d1468 1
a1468 1
			shprintf("%#3.3o\n", old_umask);
@


1.2
log
@* add definition of __RCSID if not yet existant (GNU/Linux)
* add declarations of strlcpy and strlcat (for GNU/Linux, again)
* always include <sys/resource.h>
* some more compile / warning fixes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/funcs.c,v 1.1 2005/05/23 03:06:07 tg Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.1 2005/05/23 03:06:07 tg Exp $");
d2518 1
a2518 1
			return gmatch(opnd1, opnd2, false);
d2522 1
a2522 1
			return !gmatch(opnd1, opnd2, false);
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/funcs.c,v 1.4 2005/05/23 02:37:16 tg Exp $ */
a9 1
#if defined(__OpenBSD__)
d11 2
a12 1
#else
a14 1
#include <ctype.h>
d16 1
a16 1
__RCSID("$MirOS: mksh/funcs.c,v 1.4 2005/05/23 02:37:16 tg Exp $");
@

