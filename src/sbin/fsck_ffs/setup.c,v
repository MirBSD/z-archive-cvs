head	1.7;
access;
symbols
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	cvs-200703180320:1.1.1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2017.08.07.20.16.45;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005988C69344442E37;

1.6
date	2010.09.21.21.24.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004C992261692DCA0F;

1.5
date	2008.07.06.16.30.32;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004870F3395F88C26E;

1.4
date	2007.03.18.04.14.56;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045FCBCD3679AFB9F;

1.3
date	2006.08.18.18.05.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044E6018100C580D3;

1.2
date	2005.03.06.19.49.56;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.26.30;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.18.03.29.16;	author tg;	state Exp;
branches;
next	;
commitid	10045FCB21A22D66DA7;


desc
@@


1.7
log
@filesystem
@
text
@/*	$OpenBSD: setup.c,v 1.29 2007/02/16 08:34:29 otto Exp $	*/
/*	$NetBSD: setup.c,v 1.27 1996/09/27 22:45:19 christos Exp $	*/

/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define DKTYPENAMES
#include <sys/param.h>
#include <sys/time.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

__SCCSID("@@(#)setup.c	8.5 (Berkeley) 11/23/94");
__RCSID("$MirOS: src/sbin/fsck_ffs/setup.c,v 1.6 2010/09/21 21:24:17 tg Exp $");

#define altsblock (*asblk.b_un.b_fs)
#define POWEROF2(num)	(((num) & ((num) - 1)) == 0)

void badsb(int, char *);
int calcsb(char *, int, struct fs *);
static struct disklabel *getdisklabel(char *, int);
static int readsb(int);
static int cmpsb(struct fs *, struct fs *);

long numdirs, listmax, inplast;

int
setup(char *dev)
{
	long cg, size, asked, i, j, bmapsize;
	struct disklabel *lp;
	off_t sizepb;
	struct stat statb;
	struct fs proto;
	int doskipclean;
	u_int64_t maxfilesize;

	havesb = 0;
	fswritefd = fsreadfd = -1;
	doskipclean = skipclean;
	if (stat(dev, &statb) < 0) {
		printf("Can't stat %s: %s\n", dev, strerror(errno));
		return (0);
	}
	if (!S_ISCHR(statb.st_mode)) {
		pfatal("%s is not a character device", dev);
		if (reply("CONTINUE") == 0)
			return (0);
	}
	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
		printf("Can't open %s: %s\n", dev, strerror(errno));
		return (0);
	}
	if (preen == 0)
		printf("** %s", dev);
	if (nflag || (fswritefd = open(dev, O_WRONLY)) < 0) {
		fswritefd = -1;
		if (preen)
			pfatal("NO WRITE ACCESS");
		printf(" (NO WRITE)");
	}
	if (preen == 0)
		printf("\n");
	fsmodified = 0;
	lfdir = 0;
	initbarea(&sblk);
	initbarea(&asblk);
	sblk.b_un.b_buf = malloc(SBSIZE);
	asblk.b_un.b_buf = malloc(SBSIZE);
	if (sblk.b_un.b_buf == NULL || asblk.b_un.b_buf == NULL)
		errexit("cannot allocate space for superblock\n");
	if ((lp = getdisklabel(NULL, fsreadfd)) != NULL)
		dev_bsize = secsize = lp->d_secsize;
	else
		dev_bsize = secsize = DEV_BSIZE;
	/*
	 * Read in the superblock, looking for alternates if necessary
	 */
	if (readsb(1) == 0) {
		if (bflag || preen || calcsb(dev, fsreadfd, &proto) == 0)
			return(0);
		if (reply("LOOK FOR ALTERNATE SUPERBLOCKS") == 0)
			return (0);
		for (cg = 0; cg < proto.fs_ncg; cg++) {
			bflag = fsbtodb(&proto, cgsblock(&proto, cg));
			if (readsb(0) != 0)
				break;
		}
		if (cg >= proto.fs_ncg) {
			printf("%s %s\n%s %s\n%s %s\n",
			    "SEARCH FOR ALTERNATE SUPER-BLOCK",
			    "FAILED. YOU MUST USE THE",
			    "-b OPTION TO FSCK_FFS TO SPECIFY THE",
			    "LOCATION OF AN ALTERNATE",
			    "SUPER-BLOCK TO SUPPLY NEEDED",
			    "INFORMATION; SEE fsck_ffs(8).");
			return(0);
		}
		doskipclean = 0;
		pwarn("USING ALTERNATE SUPERBLOCK AT %d\n", bflag);
	}
	if (debug)
		printf("clean = %d\n", sblock.fs_clean);
	if (sblock.fs_clean & FS_ISCLEAN) {
		if (doskipclean) {
			pwarn("%sile system is clean; not checking\n",
			    preen ? "f" : "** F");
			return (-1);
		}
		if (!preen)
			pwarn("** Filesystem is already clean\n");
	}
	maxfsblock = sblock.fs_size;
	maxino = sblock.fs_ncg * sblock.fs_ipg;
	sizepb = sblock.fs_bsize;
	maxfilesize = sblock.fs_bsize * NDADDR - 1;
	for (i = 0; i < NIADDR; i++) {
		sizepb *= NINDIR(&sblock);
		maxfilesize += sizepb;
	}
	/*
	 * Check and potentially fix certain fields in the super block.
	 */
	arc4random_pushb_fast(sblock.fs_historic_start,
	    sizeof(sblock.fs_historic_start));
	arc4random_buf(sblock.fs_historic_start,
	    sizeof(sblock.fs_historic_start));
	sbdirty();
	if (sblock.fs_optim != FS_OPTTIME && sblock.fs_optim != FS_OPTSPACE) {
		pfatal("UNDEFINED OPTIMIZATION IN SUPERBLOCK");
		if (reply("SET TO DEFAULT") == 1) {
			sblock.fs_optim = FS_OPTTIME;
			sbdirty();
		}
	}
	if ((sblock.fs_minfree < 0 || sblock.fs_minfree > 99)) {
		pfatal("IMPOSSIBLE MINFREE=%d IN SUPERBLOCK",
		    sblock.fs_minfree);
		if (reply("SET TO DEFAULT") == 1) {
			sblock.fs_minfree = 10;
			sbdirty();
		}
	}
	if (sblock.fs_interleave < 1 ||
	    sblock.fs_interleave > sblock.fs_nsect) {
		pwarn("IMPOSSIBLE INTERLEAVE=%d IN SUPERBLOCK",
		    sblock.fs_interleave);
		sblock.fs_interleave = 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("SET TO DEFAULT") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_npsect < sblock.fs_nsect ||
	    sblock.fs_npsect > sblock.fs_nsect*2) {
		pwarn("IMPOSSIBLE NPSECT=%d IN SUPERBLOCK",
		    sblock.fs_npsect);
		sblock.fs_npsect = sblock.fs_nsect;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("SET TO DEFAULT") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_bmask != ~(sblock.fs_bsize - 1)) {
		pwarn("INCORRECT BMASK=%x IN SUPERBLOCK",
		    sblock.fs_bmask);
		sblock.fs_bmask = ~(sblock.fs_bsize - 1);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_fmask != ~(sblock.fs_fsize - 1)) {
		pwarn("INCORRECT FMASK=%x IN SUPERBLOCK",
		    sblock.fs_fmask);
		sblock.fs_fmask = ~(sblock.fs_fsize - 1);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (1 << sblock.fs_bshift != sblock.fs_bsize) {
		pwarn("INCORRECT BSHIFT=%d IN SUPERBLOCK", sblock.fs_bshift);
		sblock.fs_bshift = ffs(sblock.fs_bsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (1 << sblock.fs_fshift != sblock.fs_fsize) {
		pwarn("INCORRECT FSHIFT=%d IN SUPERBLOCK", sblock.fs_fshift);
		sblock.fs_fshift = ffs(sblock.fs_fsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.fs_inodefmt >= FS_44INODEFMT) {
		if (sblock.fs_maxfilesize != maxfilesize) {
			pwarn("INCORRECT MAXFILESIZE=%llu IN SUPERBLOCK",
			    (unsigned long long)sblock.fs_maxfilesize);
			sblock.fs_maxfilesize = maxfilesize;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		if (sblock.fs_maxsymlinklen != MAXSYMLINKLEN_UFS1) {
			pwarn("INCORRECT MAXSYMLINKLEN=%d IN SUPERBLOCK",
			    sblock.fs_maxsymlinklen);
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		if (sblock.fs_qbmask != ~sblock.fs_bmask) {
			pwarn("INCORRECT QBMASK=%lx IN SUPERBLOCK",
			    (unsigned long)sblock.fs_qbmask);
			sblock.fs_qbmask = ~sblock.fs_bmask;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		if (sblock.fs_qfmask != ~sblock.fs_fmask) {
			pwarn("INCORRECT QFMASK=%lx IN SUPERBLOCK",
			    (unsigned long)sblock.fs_qfmask);
			sblock.fs_qfmask = ~sblock.fs_fmask;
			if (preen)
				printf(" (FIXED)\n");
			if (preen || reply("FIX") == 1) {
				sbdirty();
				dirty(&asblk);
			}
		}
		newinofmt = 1;
	} else {
		sblock.fs_qbmask = ~sblock.fs_bmask;
		sblock.fs_qfmask = ~sblock.fs_fmask;
		newinofmt = 0;
	}
	/*
	 * Convert to new inode format.
	 */
	if (cvtlevel >= 2 && sblock.fs_inodefmt < FS_44INODEFMT) {
		if (preen)
			pwarn("CONVERTING TO NEW INODE FORMAT\n");
		else if (!reply("CONVERT TO NEW INODE FORMAT"))
			return(0);
		doinglevel2++;
		sblock.fs_inodefmt = FS_44INODEFMT;
		sblock.fs_maxfilesize = maxfilesize;
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
		sblock.fs_qbmask = ~sblock.fs_bmask;
		sblock.fs_qfmask = ~sblock.fs_fmask;
		sbdirty();
		dirty(&asblk);
	}
	/*
	 * Convert to new cylinder group format.
	 */
	if (cvtlevel >= 1 && sblock.fs_postblformat == FS_42POSTBLFMT) {
		if (preen)
			pwarn("CONVERTING TO NEW CYLINDER GROUP FORMAT\n");
		else if (!reply("CONVERT TO NEW CYLINDER GROUP FORMAT"))
			return(0);
		doinglevel1++;
		sblock.fs_postblformat = FS_DYNAMICPOSTBLFMT;
		sblock.fs_nrpos = 8;
		sblock.fs_postbloff =
		    (char *)(&sblock.fs_opostbl_start) -
		    (char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
		sblock.fs_cgsize =
			fragroundup(&sblock, CGSIZE(&sblock));
		sbdirty();
		dirty(&asblk);
	}
	if (sblock.fs_cgsize != fragroundup(&sblock, CGSIZE(&sblock))) {
		pwarn("INCONSISTENT CGSIZE=%d\n", sblock.fs_cgsize);
		sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (INOPB(&sblock) != sblock.fs_bsize / sizeof(struct ufs1_dinode)) {
		pwarn("INCONSISTENT INOPB=%d\n", INOPB(&sblock));
		sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (NINDIR(&sblock) != sblock.fs_bsize / sizeof(ufs1_daddr_t)) {
		pwarn("INCONSISTENT NINDIR=%d\n", NINDIR(&sblock));
		sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr_t);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (asblk.b_dirty && !bflag) {
		memcpy(&altsblock, &sblock, (size_t)sblock.fs_sbsize);
		flush(fswritefd, &asblk);
	}
	/*
	 * read in the summary info.
	 */
	asked = 0;
	sblock.fs_csp = calloc(1, sblock.fs_cssize);
	if (sblock.fs_csp == NULL) {
		printf("cannot alloc %u bytes for cylinder group summary area\n",
		    (unsigned)sblock.fs_cssize);
		goto badsblabel;
	}
	for (i = 0, j = 0; i < sblock.fs_cssize; i += sblock.fs_bsize, j++) {
		size = sblock.fs_cssize - i < sblock.fs_bsize ?
		    sblock.fs_cssize - i : sblock.fs_bsize;
		if (bread(fsreadfd, (char *)sblock.fs_csp + i,
		    fsbtodb(&sblock, sblock.fs_csaddr + j * sblock.fs_frag),
		    size) != 0 && !asked) {
			pfatal("BAD SUMMARY INFORMATION");
			if (reply("CONTINUE") == 0) {
				ckfini(0);
				errexit("%s", "");
			}
			asked++;
		}
	}
	/*
	 * allocate and initialize the necessary maps
	 */
	bmapsize = roundup(howmany(maxfsblock, NBBY), sizeof(int16_t));
	blockmap = calloc((unsigned)bmapsize, sizeof(char));
	if (blockmap == NULL) {
		printf("cannot alloc %u bytes for blockmap\n",
		    (unsigned)bmapsize);
		goto badsblabel;
	}
	statemap = calloc((unsigned)(maxino + 1), sizeof(char));
	if (statemap == NULL) {
		printf("cannot alloc %u bytes for statemap\n",
		    (unsigned)(maxino + 1));
		goto badsblabel;
	}
	typemap = calloc((unsigned)(maxino + 1), sizeof(char));
	if (typemap == NULL) {
		printf("cannot alloc %u bytes for typemap\n",
		    (unsigned)(maxino + 1));
		goto badsblabel;
	}
	lncntp = calloc((unsigned)(maxino + 1), sizeof(int16_t));
	if (lncntp == NULL) {
		printf("cannot alloc %lu bytes for lncntp\n",
		    (unsigned long)(maxino + 1) * sizeof(int16_t));
		goto badsblabel;
	}
	numdirs = sblock.fs_cstotal.cs_ndir;
	inplast = 0;
	listmax = numdirs + 10;
	inpsort = calloc((unsigned)listmax, sizeof(struct inoinfo *));
	inphead = calloc((unsigned)numdirs, sizeof(struct inoinfo *));
	if (inpsort == NULL || inphead == NULL) {
		printf("cannot alloc %lu bytes for inphead\n",
		    (unsigned long)numdirs * sizeof(struct inoinfo *));
		goto badsblabel;
	}
	bufinit();
	if (sblock.fs_flags & FS_DOSOFTDEP)
		usedsoftdep = 1;
	else
		usedsoftdep = 0;
	return (1);

badsblabel:
	ckfini(0);
	return (0);
}

/*
 * Read in the super block and its summary info.
 */
static int
readsb(int listerr)
{
	daddr_t super = bflag ? bflag : SBOFF / dev_bsize;

	if (bread(fsreadfd, (char *)&sblock, super, (long)SBSIZE) != 0)
		return (0);
	sblk.b_bno = super;
	sblk.b_size = SBSIZE;
	/*
	 * run a few consistency checks of the super block
	 */
	if (sblock.fs_magic != FS_MAGIC) {
		badsb(listerr, "MAGIC NUMBER WRONG");
		return (0);
	}
	if (sblock.fs_ncg < 1) {
		badsb(listerr, "NCG OUT OF RANGE");
		return (0);
	}
	if (sblock.fs_cpg < 1) {
		badsb(listerr, "CPG OUT OF RANGE");
		return (0);
	}
	if (sblock.fs_ncg * sblock.fs_cpg < sblock.fs_ncyl ||
	    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl) {
		badsb(listerr, "NCYL LESS THAN NCG*CPG");
		return (0);
	}
	if (sblock.fs_sbsize > SBSIZE) {
		badsb(listerr, "SBSIZE PREPOSTEROUSLY LARGE");
		return (0);
	}

	if (!POWEROF2(sblock.fs_bsize) || sblock.fs_bsize < MINBSIZE ||
	    sblock.fs_bsize > MAXBSIZE)
		badsb(listerr, "ILLEGAL BLOCK SIZE");

	if (!POWEROF2(sblock.fs_fsize) || sblock.fs_fsize > sblock.fs_bsize ||
	    sblock.fs_fsize < sblock.fs_bsize / MAXFRAG)
		badsb(listerr, "ILLEGAL FRAGMENT SIZE");


	/*
	 * Compute block size that the filesystem is based on,
	 * according to fsbtodb, and adjust superblock block number
	 * so we can tell if this is an alternate later.
	 */
	super *= dev_bsize;
	dev_bsize = sblock.fs_fsize / fsbtodb(&sblock, 1);
	sblk.b_bno = super / dev_bsize;
	if (bflag) {
		havesb = 1;
		return (1);
	}
	getblk(&asblk, cgsblock(&sblock, sblock.fs_ncg - 1), sblock.fs_sbsize);
	if (asblk.b_errs)
		return (0);
	if (cmpsb(&sblock, &altsblock)) {
		if (debug) {
			long *nlp, *olp, *endlp;

			printf("superblock mismatches\n");
			nlp = (long *)&altsblock;
			olp = (long *)&sblock;
			endlp = olp + (sblock.fs_sbsize / sizeof *olp);
			for ( ; olp < endlp; olp++, nlp++) {
				if (*olp == *nlp)
					continue;
				printf("offset %d, original %ld, alternate %ld\n",
				    (int)(olp - (long *)&sblock), *olp, *nlp);
			}
		}
		badsb(listerr,
		    "VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
		return (0);
	}
	havesb = 1;
	return (1);
}

void
badsb(int listerr, char *s)
{

	if (!listerr)
		return;
	if (preen)
		printf("%s: ", cdevname());
	pfatal("BAD SUPER BLOCK: %s\n", s);
}

/*
 * Calculate a prototype superblock based on information in the disk label.
 * When done the cgsblock macro can be calculated and the fs_ncg field
 * can be used. Do NOT attempt to use other macros without verifying that
 * their needed information is available!
 */
int
calcsb(char *dev, int devfd, struct fs *fs)
{
	struct disklabel *lp;
	struct partition *pp;
	char *cp;
	int i;

	cp = strchr(dev, '\0') - 1;
	if ((cp == (char *)-1 || (*cp < 'a' || *cp >= 'a' + MAXPARTITIONS)) &&
	    !isdigit(*cp)) {
		pfatal("%s: CANNOT FIGURE OUT FILESYSTEM PARTITION\n", dev);
		return (0);
	}
	lp = getdisklabel(dev, devfd);
	if (isdigit(*cp))
		pp = &lp->d_partitions[0];
	else
		pp = &lp->d_partitions[*cp - 'a'];
	if (pp->p_fstype != FS_BSDFFS) {
		pfatal("%s: NOT LABELED AS A BSD FILESYSTEM (%s)\n",
		    dev, pp->p_fstype < FSMAXTYPES ?
		    fstypenames[pp->p_fstype] : "unknown");
		return (0);
	}
	memset(fs, 0, sizeof(struct fs));
	fs->fs_fsize = pp->p_fsize;
	fs->fs_frag = pp->p_frag;
	fs->fs_bsize = fs->fs_fsize * fs->fs_frag;
	fs->fs_cpg = pp->p_cpg;
	fs->fs_nspf = fs->fs_fsize / lp->d_secsize;
	/* unit for fs->fs_size is fragments, for pp->p_size it is sectors */
	fs->fs_size = pp->p_size / fs->fs_nspf;
	fs->fs_ntrak = lp->d_ntracks;
	fs->fs_nsect = lp->d_nsectors;
	fs->fs_spc = lp->d_secpercyl;
	/* we can't use lp->d_sbsize, it is the max sb size */
	fs->fs_sblkno = roundup(
		howmany(lp->d_bbsize + SBSIZE, fs->fs_fsize),
		fs->fs_frag);
again:
	fs->fs_cgmask = 0xffffffff;
	for (i = fs->fs_ntrak; i > 1; i >>= 1)
		fs->fs_cgmask <<= 1;
	if (!POWEROF2(fs->fs_ntrak))
		fs->fs_cgmask <<= 1;
	fs->fs_cgoffset = roundup(
		howmany(fs->fs_nsect, NSPF(fs)), fs->fs_frag);
	fs->fs_fpg = (fs->fs_cpg * fs->fs_spc) / NSPF(fs);
	fs->fs_ncg = howmany(pp->p_size / fs->fs_spc, fs->fs_cpg);
	for (fs->fs_fsbtodb = 0, i = NSPF(fs); i > 1; i >>= 1)
		fs->fs_fsbtodb++;
	/*
	 * Mimick what mkfs is doing to get an acceptable cgsize,
	 * not all fields used by CGSIZE() are filled in, but it's a best
	 * effort anyway.
	 */
	if (CGSIZE(fs) > fs->fs_bsize && fs->fs_ntrak > 1) {
		fs->fs_ntrak >>= 1;
		fs->fs_spc >>= 1;
		goto again;
	}
	dev_bsize = lp->d_secsize;
	return (1);
}

static struct disklabel *
getdisklabel(char *s, int fd)
{
	static struct disklabel lab;

	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
		if (s == NULL)
			return (NULL);
		pwarn("ioctl (GCINFO): %s\n", strerror(errno));
		errexit("%s: can't read disk label\n", s);
	}
	return (&lab);
}

/*
 * Compare two superblocks
 */
static int
cmpsb(struct fs *sb, struct fs *asb)
{
	/*
	 * Only compare fields which should be the same, and ignore ones
	 * likely to change to ensure future compatibility.
	 */
	if (asb->fs_sblkno != sb->fs_sblkno ||
	    asb->fs_cblkno != sb->fs_cblkno ||
	    asb->fs_iblkno != sb->fs_iblkno ||
	    asb->fs_dblkno != sb->fs_dblkno ||
	    asb->fs_cgoffset != sb->fs_cgoffset ||
	    asb->fs_cgmask != sb->fs_cgmask ||
	    asb->fs_ncg != sb->fs_ncg ||
	    asb->fs_bsize != sb->fs_bsize ||
	    asb->fs_fsize != sb->fs_fsize ||
	    asb->fs_frag != sb->fs_frag ||
	    asb->fs_bmask != sb->fs_bmask ||
	    asb->fs_fmask != sb->fs_fmask ||
	    asb->fs_bshift != sb->fs_bshift ||
	    asb->fs_fshift != sb->fs_fshift ||
	    asb->fs_fragshift != sb->fs_fragshift ||
	    asb->fs_fsbtodb != sb->fs_fsbtodb ||
	    asb->fs_sbsize != sb->fs_sbsize ||
	    asb->fs_nindir != sb->fs_nindir ||
	    asb->fs_inopb != sb->fs_inopb ||
	    asb->fs_cssize != sb->fs_cssize ||
	    asb->fs_cpg != sb->fs_cpg ||
	    asb->fs_ipg != sb->fs_ipg ||
	    asb->fs_fpg != sb->fs_fpg ||
	    asb->fs_magic != sb->fs_magic)
		    return (1);
	/* they're the same */
	return (0);
}
@


1.6
log
@use arc4random() a bit more efficiently
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/sbin/fsck_ffs/setup.c,v 1.5 2008/07/06 16:30:32 tg Exp $");
d151 1
a151 1
			pwarn("** File system is already clean\n");
d559 1
a559 1
		pfatal("%s: CANNOT FIGURE OUT FILE SYSTEM PARTITION\n", dev);
d568 1
a568 1
		pfatal("%s: NOT LABELED AS A BSD FILE SYSTEM (%s)\n",
@


1.5
log
@improve arc4random_pushb handling
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/sbin/fsck_ffs/setup.c,v 1.4 2007/03/18 04:14:56 tg Exp $");
d164 4
a167 3
	sblock.fs_firstfield = arc4random_pushb(&(sblock.fs_firstfield),
	    sizeof (sblock.fs_firstfield) + sizeof (sblock.fs_unused_1));
	sblock.fs_unused_1 = arc4random();
@


1.4
log
@merge import of new fsck_* tools
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/sbin/fsck_ffs/setup.c,v 1.3 2006/08/18 18:05:48 tg Exp $");
d164 1
a164 1
	arc4random_pushb(&(sblock.fs_firstfield),
a165 1
	sblock.fs_firstfield = arc4random();
@


1.3
log
@simplify and speed up by using arc4random_pushb and update a comment
@
text
@d1 1
a1 2
/**	$MirOS: src/sbin/fsck_ffs/setup.c,v 1.2 2005/03/06 19:49:56 tg Exp $	*/
/*	$OpenBSD: setup.c,v 1.21 2003/09/25 04:19:39 deraadt Exp $	*/
a32 4
#include <sys/cdefs.h>
__SCCSID("@@(#)setup.c	8.5 (Berkeley) 11/23/94");
__RCSID("$MirOS: src/sbin/fsck_ffs/setup.c,v 1.2 2005/03/06 19:49:56 tg Exp $");

d53 3
a55 1
struct bufarea asblk;
d70 1
a70 2
	long cg, size, asked, i, j;
	long bmapsize;
d79 1
a79 1
	fswritefd = -1;
d131 6
a136 6
				"SEARCH FOR ALTERNATE SUPER-BLOCK",
				"FAILED. YOU MUST USE THE",
				"-b OPTION TO FSCK_FFS TO SPECIFY THE",
				"LOCATION OF AN ALTERNATE",
				"SUPER-BLOCK TO SUPPLY NEEDED",
				"INFORMATION; SEE fsck_ffs(8).");
d178 1
a178 1
			sblock.fs_minfree);
d187 1
a187 1
			sblock.fs_interleave);
d199 1
a199 1
			sblock.fs_npsect);
d210 1
a210 1
			sblock.fs_bmask);
d221 1
a221 1
			sblock.fs_fmask);
d230 20
d253 1
a253 1
				(unsigned long long)sblock.fs_maxfilesize);
d262 1
a262 1
		if (sblock.fs_maxsymlinklen != MAXSYMLINKLEN) {
d264 2
a265 2
				sblock.fs_maxsymlinklen);
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
d275 1
a275 1
				(unsigned long)sblock.fs_qbmask);
d286 1
a286 1
				(unsigned long)sblock.fs_qfmask);
d312 1
a312 1
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
d330 1
a330 1
		    (char *)(&sblock.fs_opostbl[0][0]) -
d339 30
d462 12
a473 6
	if (sblock.fs_magic != FS_MAGIC)
		{ badsb(listerr, "MAGIC NUMBER WRONG"); return (0); }
	if (sblock.fs_ncg < 1)
		{ badsb(listerr, "NCG OUT OF RANGE"); return (0); }
	if (sblock.fs_cpg < 1)
		{ badsb(listerr, "CPG OUT OF RANGE"); return (0); }
d475 18
a492 4
	    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl)
		{ badsb(listerr, "NCYL LESS THAN NCG*CPG"); return (0); }
	if (sblock.fs_sbsize > SBSIZE)
		{ badsb(listerr, "SIZE PREPOSTEROUSLY LARGE"); return (0); }
d524 1
a524 1
		"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
d557 2
a558 1
	if ((cp == (char *)-1 || (*cp < 'a' || *cp > 'h')) && !isdigit(*cp)) {
d569 2
a570 2
			dev, pp->p_fstype < FSMAXTYPES ?
			fstypenames[pp->p_fstype] : "unknown");
d576 1
d578 3
a580 1
	fs->fs_size = pp->p_size;
d584 1
a584 1
	fs->fs_nspf = fs->fs_fsize / lp->d_secsize;
d586 1
a586 1
		howmany(lp->d_bbsize + lp->d_sbsize, fs->fs_fsize),
d588 1
d597 1
a597 1
	fs->fs_ncg = howmany(fs->fs_size / fs->fs_spc, fs->fs_cpg);
d600 10
@


1.2
log
@merge src/sbin
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d36 1
a36 1
__RCSID("$MirOS$");
d168 5
a172 9
#ifdef	__MirBSD__
	if (sblock.fs_unused_1) {
		arc4random_push(sblock.fs_firstfield);
		arc4random_push(sblock.fs_unused_1);
		sblock.fs_firstfield = arc4random();
		sblock.fs_unused_1 = arc4random();
		sbdirty();
	}
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
d34 3
a36 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)setup.c	8.5 (Berkeley) 11/23/94";
#else
static const char rcsid[] = "$OpenBSD: setup.c,v 1.21 2003/09/25 04:19:39 deraadt Exp $";
#endif
#endif /* not lint */
d168 9
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import openbsd's fixes for fsck stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.29 2007/02/16 08:34:29 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: setup.c,v 1.29 2007/02/16 08:34:29 otto Exp $";
d61 1
d76 2
a77 1
	long cg, size, asked, i, j, bmapsize;
d86 1
a86 1
	fswritefd = fsreadfd = -1;
d138 6
a143 6
			    "SEARCH FOR ALTERNATE SUPER-BLOCK",
			    "FAILED. YOU MUST USE THE",
			    "-b OPTION TO FSCK_FFS TO SPECIFY THE",
			    "LOCATION OF AN ALTERNATE",
			    "SUPER-BLOCK TO SUPPLY NEEDED",
			    "INFORMATION; SEE fsck_ffs(8).");
d180 1
a180 1
		    sblock.fs_minfree);
d189 1
a189 1
		    sblock.fs_interleave);
d201 1
a201 1
		    sblock.fs_npsect);
d212 1
a212 1
		    sblock.fs_bmask);
d223 1
a223 1
		    sblock.fs_fmask);
a231 20
	if (1 << sblock.fs_bshift != sblock.fs_bsize) {
		pwarn("INCORRECT BSHIFT=%d IN SUPERBLOCK", sblock.fs_bshift);
		sblock.fs_bshift = ffs(sblock.fs_bsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (1 << sblock.fs_fshift != sblock.fs_fsize) {
		pwarn("INCORRECT FSHIFT=%d IN SUPERBLOCK", sblock.fs_fshift);
		sblock.fs_fshift = ffs(sblock.fs_fsize) - 1;
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
d235 1
a235 1
			    (unsigned long long)sblock.fs_maxfilesize);
d244 1
a244 1
		if (sblock.fs_maxsymlinklen != MAXSYMLINKLEN_UFS1) {
d246 2
a247 2
			    sblock.fs_maxsymlinklen);
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
d257 1
a257 1
			    (unsigned long)sblock.fs_qbmask);
d268 1
a268 1
			    (unsigned long)sblock.fs_qfmask);
d294 1
a294 1
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
d312 1
a312 1
		    (char *)(&sblock.fs_opostbl_start) -
a320 30
	if (sblock.fs_cgsize != fragroundup(&sblock, CGSIZE(&sblock))) {
		pwarn("INCONSISTENT CGSIZE=%d\n", sblock.fs_cgsize);
		sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (INOPB(&sblock) != sblock.fs_bsize / sizeof(struct ufs1_dinode)) {
		pwarn("INCONSISTENT INOPB=%d\n", INOPB(&sblock));
		sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
	if (NINDIR(&sblock) != sblock.fs_bsize / sizeof(ufs1_daddr_t)) {
		pwarn("INCONSISTENT NINDIR=%d\n", NINDIR(&sblock));
		sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr_t);
		if (preen)
			printf(" (FIXED)\n");
		if (preen || reply("FIX") == 1) {
			sbdirty();
			dirty(&asblk);
		}
	}
d414 6
a419 12
	if (sblock.fs_magic != FS_MAGIC) {
		badsb(listerr, "MAGIC NUMBER WRONG");
		return (0);
	}
	if (sblock.fs_ncg < 1) {
		badsb(listerr, "NCG OUT OF RANGE");
		return (0);
	}
	if (sblock.fs_cpg < 1) {
		badsb(listerr, "CPG OUT OF RANGE");
		return (0);
	}
d421 4
a424 18
	    (sblock.fs_ncg - 1) * sblock.fs_cpg >= sblock.fs_ncyl) {
		badsb(listerr, "NCYL LESS THAN NCG*CPG");
		return (0);
	}
	if (sblock.fs_sbsize > SBSIZE) {
		badsb(listerr, "SBSIZE PREPOSTEROUSLY LARGE");
		return (0);
	}

	if (!POWEROF2(sblock.fs_bsize) || sblock.fs_bsize < MINBSIZE ||
	    sblock.fs_bsize > MAXBSIZE)
		badsb(listerr, "ILLEGAL BLOCK SIZE");

	if (!POWEROF2(sblock.fs_fsize) || sblock.fs_fsize > sblock.fs_bsize ||
	    sblock.fs_fsize < sblock.fs_bsize / MAXFRAG)
		badsb(listerr, "ILLEGAL FRAGMENT SIZE");


d456 1
a456 1
		    "VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
d489 1
a489 2
	if ((cp == (char *)-1 || (*cp < 'a' || *cp >= 'a' + MAXPARTITIONS)) &&
	    !isdigit(*cp)) {
d500 2
a501 2
		    dev, pp->p_fstype < FSMAXTYPES ?
		    fstypenames[pp->p_fstype] : "unknown");
a506 1
	fs->fs_bsize = fs->fs_fsize * fs->fs_frag;
d508 1
a508 3
	fs->fs_nspf = fs->fs_fsize / lp->d_secsize;
	/* unit for fs->fs_size is fragments, for pp->p_size it is sectors */
	fs->fs_size = pp->p_size / fs->fs_nspf;
d512 1
a512 1
	/* we can't use lp->d_sbsize, it is the max sb size */
d514 1
a514 1
		howmany(lp->d_bbsize + SBSIZE, fs->fs_fsize),
a515 1
again:
d524 1
a524 1
	fs->fs_ncg = howmany(pp->p_size / fs->fs_spc, fs->fs_cpg);
a526 10
	/*
	 * Mimick what mkfs is doing to get an acceptable cgsize,
	 * not all fields used by CGSIZE() are filled in, but it's a best
	 * effort anyway.
	 */
	if (CGSIZE(fs) > fs->fs_bsize && fs->fs_ntrak > 1) {
		fs->fs_ntrak >>= 1;
		fs->fs_spc >>= 1;
		goto again;
	}
@

