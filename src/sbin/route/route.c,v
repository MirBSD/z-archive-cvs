head	1.4;
access;
symbols
	MIRBSD_10:1.4.0.4
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.10.26.17.57.06;	author tg;	state Exp;
branches;
next	1.3;
commitid	6760435fc37f2949;

1.3
date	2005.10.26.17.47.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	2d88435fc131eb50;

1.2
date	2005.03.06.19.50.34;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.26.42;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.42;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.57.31;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.4
log
@* merge OpenBSD
* fix stuff
@
text
@/**	$MirOS: src/sbin/route/route.c,v 1.3 2005/10/26 17:47:14 tg Exp $	*/
/*	$OpenBSD: route.c,v 1.91 2005/06/09 08:07:45 markus Exp $	*/
/*	$NetBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netipx/ipx.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <err.h>

#include "keywords.h"
#include "show.h"

__RCSID("$MirOS: src/sbin/route/route.c,v 1.3 2005/10/26 17:47:14 tg Exp $");

union	sockunion {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
	struct sockaddr_ipx	sipx;
	struct sockaddr_dl	sdl;
	struct sockaddr_rtlabel	rtlabel;
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_label;

typedef union sockunion *sup;
pid_t	pid;
int	rtm_addrs, s;
int	forcehost, forcenet, nflag, af, qflag, tflag;
int	iflag, verbose, aflen = sizeof(struct sockaddr_in);
int	locking, lockrest, debugonly;
u_long	rtm_inits;
uid_t	uid;

struct rt_metrics	rt_metrics;

void	 flushroutes(int, char **);
int	 newroute(int, char **);
void	 show(int, char *[]);
int	 keyword(char *);
void	 monitor(void);
int	 prefixlen(char *);
void	 sockaddr(char *, struct sockaddr *);
void	 sodump(sup, char *);
void	 print_getmsg(struct rt_msghdr *, int);
void	 print_rtmsg(struct rt_msghdr *, int);
void	 pmsg_common(struct rt_msghdr *);
void	 pmsg_addrs(char *, int);
void	 bprintf(FILE *, int, char *);
void	 mask_addr(union sockunion *, union sockunion *, int);
int	 inet6_makenetandmask(struct sockaddr_in6 *);
int	 getaddr(int, char *, struct hostent **);
int	 rtmsg(int, int, int);
__dead void usage(char *);
void	 set_metric(char *, int);
void	 inet_makenetandmask(u_int32_t, struct sockaddr_in *, int);
void	 interfaces(void);
void	 getlabel(char *);

__dead void
usage(char *cp)
{
	extern char *__progname;

	if (cp)
		warnx("botched keyword: %s", cp);
	fprintf(stderr,
	    "usage: %s [-dnqtv] command [[modifiers] args]\n",
	    __progname);
	fprintf(stderr,
	    "commands: add, change, delete, flush, get, monitor, show\n");
	exit(1);
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

int
main(int argc, char **argv)
{
	int ch;
	int rval = 0;

	if (argc < 2)
		usage(NULL);

	while ((ch = getopt(argc, argv, "dnqtv")) != -1)
		switch (ch) {
		case 'n':
			nflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case 't':
			tflag = 1;
			break;
		case 'd':
			debugonly = 1;
			break;
		default:
			usage(NULL);
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	pid = getpid();
	uid = geteuid();
	if (tflag)
		s = open(_PATH_DEVNULL, O_WRONLY);
	else
		s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s == -1)
		err(1, "socket");
	if (*argv == NULL)
		usage(NULL);
	switch (keyword(*argv)) {
	case K_GET:
		uid = 0;
		/* FALLTHROUGH */
	case K_CHANGE:
	case K_ADD:
	case K_DELETE:
		rval = newroute(argc, argv);
		break;
	case K_SHOW:
		uid = 0;
		show(argc, argv);
		break;
	case K_MONITOR:
		monitor();
		break;
	case K_FLUSH:
		flushroutes(argc, argv);
		break;
	default:
		usage(*argv);
		/* NOTREACHED */
	}
	exit(rval);
}

/*
 * Purge all entries in the routing tables not
 * associated with network interfaces.
 */
void
flushroutes(int argc, char **argv)
{
	size_t needed;
	int mib[6], rlen, seqno;
	char *buf = NULL, *next, *lim = NULL;
	struct rt_msghdr *rtm;
	struct sockaddr *sa;

	if (uid)
		errx(1, "must be root to alter routing table");
	shutdown(s, 0); /* Don't want to read back our messages */
	if (argc > 1) {
		argv++;
		if (argc == 2 && **argv == '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_IPX:
				af = AF_IPX;
				break;
			case K_LINK:
				af = AF_LINK;
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;		/* protocol */
	mib[3] = 0;		/* wildcard address family */
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;		/* no flags */
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed) {
		if ((buf = malloc(needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
			err(1, "actual retrieval of routing table");
		lim = buf + needed;
	}
	if (verbose) {
		printf("Examining routing table from sysctl\n");
		if (af)
			printf("(address family %s)\n", (*argv + 1));
	}
	if (buf == NULL)
		return;

	seqno = 0;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (verbose)
			print_rtmsg(rtm, rtm->rtm_msglen);
		if ((rtm->rtm_flags & (RTF_GATEWAY|RTF_STATIC|RTF_LLINFO)) == 0)
			continue;
		sa = (struct sockaddr *)(rtm + 1);
		if (af && sa->sa_family != af)
			continue;
		if (sa->sa_family == AF_KEY)
			continue;  /* Don't flush SPD */
		if (debugonly)
			continue;
		rtm->rtm_type = RTM_DELETE;
		rtm->rtm_seq = seqno;
		rlen = write(s, next, rtm->rtm_msglen);
		if (rlen < (int)rtm->rtm_msglen) {
			warn("write to routing socket");
			printf("got only %d for rlen\n", rlen);
			break;
		}
		seqno++;
		if (qflag)
			continue;
		if (verbose)
			print_rtmsg(rtm, rlen);
		else {
			struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
			printf("%-20.20s ", rtm->rtm_flags & RTF_HOST ?
			    routename(sa) : netname(sa, NULL)); /* XXX extract
								   netmask */
			sa = (struct sockaddr *)
			    (ROUNDUP(sa->sa_len) + (char *)sa);
			printf("%-20.20s ", routename(sa));
			printf("done\n");
		}
	}
	free(buf);
}

void
set_metric(char *value, int key)
{
	int flag = 0;
	u_long noval, *valp = &noval;

	switch (key) {
	case K_MTU:
		valp = &rt_metrics.rmx_mtu;
		flag = RTV_MTU;
		break;
	case K_HOPCOUNT:
		valp = &rt_metrics.rmx_hopcount;
		flag = RTV_HOPCOUNT;
		break;
	case K_EXPIRE:
		valp = &rt_metrics.rmx_expire;
		flag = RTV_EXPIRE;
		break;
	case K_RECVPIPE:
		valp = &rt_metrics.rmx_recvpipe;
		flag = RTV_RPIPE;
		break;
	case K_SENDPIPE:
		valp = &rt_metrics.rmx_sendpipe;
		flag = RTV_SPIPE;
		break;
	case K_SSTHRESH:
		valp = &rt_metrics.rmx_ssthresh;
		flag = RTV_SSTHRESH;
		break;
	case K_RTT:
		valp = &rt_metrics.rmx_rtt;
		flag = RTV_RTT;
		break;
	case K_RTTVAR:
		valp = &rt_metrics.rmx_rttvar;
		flag = RTV_RTTVAR;
		break;
	default:
		errx(1, "king bula sez: set_metric with invalid key");
	}
	rtm_inits |= flag;
	if (lockrest || locking)
		rt_metrics.rmx_locks |= flag;
	if (locking)
		locking = 0;
	*valp = atoi(value);
}

int
newroute(int argc, char **argv)
{
	char *cmd, *dest = "", *gateway = "", *error;
	int ishost = 0, ret = 0, attempts, oerrno, flags = RTF_STATIC;
	int fmask = 0;
	int key;
	struct hostent *hp = NULL;

	if (uid)
		errx(1, "must be root to alter routing table");
	cmd = argv[0];
	if (*cmd != 'g')
		shutdown(s, 0); /* Don't want to read back our messages */
	while (--argc > 0) {
		if (**(++argv)== '-') {
			switch (key = keyword(1 + *argv)) {
			case K_LINK:
				af = AF_LINK;
				aflen = sizeof(struct sockaddr_dl);
				break;
			case K_INET:
				af = AF_INET;
				aflen = sizeof(struct sockaddr_in);
				break;
			case K_INET6:
				af = AF_INET6;
				aflen = sizeof(struct sockaddr_in6);
				break;
			case K_SA:
				af = PF_ROUTE;
				aflen = sizeof(union sockunion);
				break;
			case K_IPX:
				af = AF_IPX;
				aflen = sizeof(struct sockaddr_ipx);
				break;
			case K_IFACE:
			case K_INTERFACE:
				iflag++;
				break;
			case K_NOSTATIC:
				flags &= ~RTF_STATIC;
				break;
			case K_LLINFO:
				flags |= RTF_LLINFO;
				break;
			case K_LOCK:
				locking = 1;
				break;
			case K_LOCKREST:
				lockrest = 1;
				break;
			case K_HOST:
				forcehost++;
				break;
			case K_REJECT:
				flags |= RTF_REJECT;
				break;
			case K_BLACKHOLE:
				flags |= RTF_BLACKHOLE;
				break;
			case K_PROTO1:
				flags |= RTF_PROTO1;
				break;
			case K_PROTO2:
				flags |= RTF_PROTO2;
				break;
			case K_CLONING:
				flags |= RTF_CLONING;
				break;
			case K_XRESOLVE:
				flags |= RTF_XRESOLVE;
				break;
			case K_STATIC:
				flags |= RTF_STATIC;
				break;
			case K_IFA:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_IFA, *++argv, NULL);
				break;
			case K_IFP:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_IFP, *++argv, NULL);
				break;
			case K_GENMASK:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_GENMASK, *++argv, NULL);
				break;
			case K_GATEWAY:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_GATEWAY, *++argv, NULL);
				gateway = *argv;
				break;
			case K_DST:
				if (!--argc)
					usage(1+*argv);
				ishost = getaddr(RTA_DST, *++argv, &hp);
				dest = *argv;
				break;
			case K_LABEL:
				if (!--argc)
					usage(1+*argv);
				getlabel(*++argv);
				break;
			case K_NETMASK:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_NETMASK, *++argv, NULL);
				/* FALLTHROUGH */
			case K_NET:
				forcenet++;
				break;
			case K_PREFIXLEN:
				if (!--argc)
					usage(1+*argv);
				ishost = prefixlen(*++argv);
				break;
			case K_MPATH:
				flags |= RTF_MPATH;
				break;
			case K_JUMBO:
				flags |= RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
			case K_NOJUMBO:
				flags &= ~RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
			case K_MTU:
			case K_HOPCOUNT:
			case K_EXPIRE:
			case K_RECVPIPE:
			case K_SENDPIPE:
			case K_SSTHRESH:
			case K_RTT:
			case K_RTTVAR:
				if (!--argc)
					usage(1+*argv);
				set_metric(*++argv, key);
				break;
			default:
				usage(1+*argv);
				/* NOTREACHED */
			}
		} else {
			if ((rtm_addrs & RTA_DST) == 0) {
				dest = *argv;
				ishost = getaddr(RTA_DST, *argv, &hp);
			} else if ((rtm_addrs & RTA_GATEWAY) == 0) {
				gateway = *argv;
				getaddr(RTA_GATEWAY, *argv, &hp);
			} else {
				int hops = atoi(*argv);

				if (hops == 0) {
				    if (!qflag && strcmp(*argv, "0") == 0)
					printf("%s,%s",
					    "old usage of trailing 0",
					    "assuming route to if\n");
				    else
					usage(NULL);
				    iflag = 1;
				    continue;
				} else if (hops > 0 && hops < 10) {
				    if (!qflag) {
					printf("old usage of trailing digit, ");
					printf("assuming route via gateway\n");
				    }
				    iflag = 0;
				    continue;
				}
				getaddr(RTA_NETMASK, *argv, NULL);
			}
		}
	}
	if (forcehost)
		ishost = 1;
	if (forcenet)
		ishost = 0;
	if (forcenet && !(rtm_addrs & RTA_NETMASK))
		errx(1, "netmask missing");
	flags |= RTF_UP;
	if (ishost)
		flags |= RTF_HOST;
	if (iflag == 0)
		flags |= RTF_GATEWAY;
	for (attempts = 1; ; attempts++) {
		errno = 0;
		if ((ret = rtmsg(*cmd, flags, fmask)) == 0)
			break;
		if (errno != ENETUNREACH && errno != ESRCH)
			break;
		if (af == AF_INET && *gateway && hp && hp->h_addr_list[1]) {
			hp->h_addr_list++;
			memcpy(&so_gate.sin.sin_addr, hp->h_addr_list[0],
			    hp->h_length);
		} else
			break;
	}
	if (*cmd == 'g')
		exit(0);
	oerrno = errno;
	if (!qflag) {
		printf("%s %s %s", cmd, ishost ? "host" : "net", dest);
		if (*gateway) {
			printf(": gateway %s", gateway);
			if (attempts > 1 && ret == 0 && af == AF_INET)
			    printf(" (%s)", inet_ntoa(so_gate.sin.sin_addr));
		}
		if (ret == 0)
			printf("\n");
		if (ret != 0) {
			switch (oerrno) {
			case ESRCH:
				error = "not in table";
				break;
			case EBUSY:
				error = "entry in use";
				break;
			case ENOBUFS:
				error = "routing table overflow";
				break;
			default:
				error = strerror(oerrno);
				break;
			}
			printf(": %s\n", error);
		}
	}
	return (ret != 0);
}

void
show(int argc, char *argv[])
{
	int	af = 0;

	if (argc > 1) {
		argv++;
		if (argc == 2 && **argv == '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_IPX:
				af = AF_IPX;
				break;
			case K_LINK:
				af = AF_LINK;
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}

	p_rttables(af, 0);
}

void
inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits)
{
	u_int32_t addr, mask = 0;
	char *cp;

	rtm_addrs |= RTA_NETMASK;
	if (net == 0)
		mask = addr = 0;
	else if (bits) {
		addr = net;
		mask = 0xffffffff << (32 - bits);
	} else if (net < 128) {
		addr = net << IN_CLASSA_NSHIFT;
		mask = IN_CLASSA_NET;
	} else if (net < 65536) {
		addr = net << IN_CLASSB_NSHIFT;
		mask = IN_CLASSB_NET;
	} else if (net < 16777216L) {
		addr = net << IN_CLASSC_NSHIFT;
		mask = IN_CLASSC_NET;
	} else {
		addr = net;
		if ((addr & IN_CLASSA_HOST) == 0)
			mask = IN_CLASSA_NET;
		else if ((addr & IN_CLASSB_HOST) == 0)
			mask = IN_CLASSB_NET;
		else if ((addr & IN_CLASSC_HOST) == 0)
			mask = IN_CLASSC_NET;
		else
			mask = 0xffffffff;
	}
	addr &= mask;
	sin->sin_addr.s_addr = htonl(addr);
	sin = &so_mask.sin;
	sin->sin_addr.s_addr = htonl(mask);
	sin->sin_len = 0;
	sin->sin_family = 0;
	cp = (char *)(&sin->sin_addr + 1);
	while (*--cp == '\0' && cp > (char *)sin)
		;
	sin->sin_len = 1 + cp - (char *)sin;
}

/*
 * XXX the function may need more improvement...
 */
int
inet6_makenetandmask(struct sockaddr_in6 *sin6)
{
	char *plen = NULL;
	struct in6_addr in6;

	if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
	    sin6->sin6_scope_id == 0) {
		plen = "0";
	} else if ((sin6->sin6_addr.s6_addr[0] & 0xe0) == 0x20) {
		/* aggregatable global unicast - RFC2374 */
		memset(&in6, 0, sizeof(in6));
		if (!memcmp(&sin6->sin6_addr.s6_addr[8], &in6.s6_addr[8], 8))
			plen = "64";
	}

	if (!plen || strcmp(plen, "128") == 0)
		return (1);
	else {
		rtm_addrs |= RTA_NETMASK;
		prefixlen(plen);
		return (0);
	}
}

/*
 * Interpret an argument as a network address of some kind,
 * returning 1 if a host address, 0 if a network address.
 */
int
getaddr(int which, char *s, struct hostent **hpp)
{
	sup su = NULL;
	struct hostent *hp;
	struct netent *np;
	int afamily, bits;

	if (af == 0) {
		af = AF_INET;
		aflen = sizeof(struct sockaddr_in);
	}
	afamily = af;	/* local copy of af so we can change it */

	rtm_addrs |= which;
	switch (which) {
	case RTA_DST:
		su = &so_dst;
		break;
	case RTA_GATEWAY:
		su = &so_gate;
		break;
	case RTA_NETMASK:
		su = &so_mask;
		break;
	case RTA_GENMASK:
		su = &so_genmask;
		break;
	case RTA_IFP:
		su = &so_ifp;
		afamily = AF_LINK;
		break;
	case RTA_IFA:
		su = &so_ifa;
		break;
	default:
		errx(1, "internal error");
		/* NOTREACHED */
	}
	su->sa.sa_len = aflen;
	su->sa.sa_family = afamily;

	if (strcmp(s, "default") == 0) {
		switch (which) {
		case RTA_DST:
			forcenet++;
			getaddr(RTA_NETMASK, s, NULL);
			break;
		case RTA_NETMASK:
		case RTA_GENMASK:
			su->sa.sa_len = 0;
		}
		return (0);
	}

	switch (afamily) {
	case AF_INET6:
	    {
		struct addrinfo hints, *res;

		memset(&hints, 0, sizeof(hints));
		hints.ai_family = afamily;	/*AF_INET6*/
		hints.ai_flags = AI_NUMERICHOST;
		hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
		if (getaddrinfo(s, "0", &hints, &res) != 0) {
			hints.ai_flags = 0;
			if (getaddrinfo(s, "0", &hints, &res) != 0)
				errx(1, "%s: bad value", s);
		}
		if (sizeof(su->sin6) != res->ai_addrlen)
			errx(1, "%s: bad value", s);
		if (res->ai_next)
			errx(1, "%s: resolved to multiple values", s);
		memcpy(&su->sin6, res->ai_addr, sizeof(su->sin6));
		freeaddrinfo(res);
		if ((IN6_IS_ADDR_LINKLOCAL(&su->sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&su->sin6.sin6_addr)) &&
		    su->sin6.sin6_scope_id) {
			*(u_int16_t *)&su->sin6.sin6_addr.s6_addr[2] =
				htons(su->sin6.sin6_scope_id);
			su->sin6.sin6_scope_id = 0;
		}
		if (hints.ai_flags == AI_NUMERICHOST) {
			if (which == RTA_DST)
				return (inet6_makenetandmask(&su->sin6));
			return (0);
		} else
			return (1);
	    }

	case AF_IPX:
		if (which == RTA_DST) {
			extern short ipx_bh[3];
			struct sockaddr_ipx *sms = &(so_mask.sipx);
			memset(sms, 0, sizeof(*sms));
			sms->sipx_family = 0;
			sms->sipx_len = 6;
			sms->sipx_addr.ipx_net = *(union ipx_net *)ipx_bh;
			rtm_addrs |= RTA_NETMASK;
		}
		su->sipx.sipx_addr = ipx_addr(s);
		return (!ipx_nullhost(su->sipx.sipx_addr));

	case AF_LINK:
		link_addr(s, &su->sdl);
		return (1);

	case PF_ROUTE:
		su->sa.sa_len = sizeof(*su);
		sockaddr(s, &su->sa);
		return (1);

	case AF_INET:
		if (hpp != NULL)
			*hpp = NULL;
		if (which == RTA_DST && !forcehost) {
			bits = inet_net_pton(AF_INET, s, &su->sin.sin_addr,
			    sizeof(su->sin.sin_addr));
			if (bits == 32)
				return (1);
			if (bits >= 0) {
				inet_makenetandmask(ntohl(
				    su->sin.sin_addr.s_addr),
				    &su->sin, bits);
				return (0);
			}
			np = getnetbyname(s);
			if (np != NULL && np->n_net != 0) {
				inet_makenetandmask(np->n_net, &su->sin, 0);
				return (0);
			}
			if (forcenet)
				errx(1, "%s: not a network", s);
		}
		if (inet_pton(AF_INET, s, &su->sin.sin_addr) == 1)
			return (1);
		hp = gethostbyname(s);
		if (hp != NULL) {
			if (hpp != NULL)
				*hpp = hp;
			su->sin.sin_addr = *(struct in_addr *)hp->h_addr;
			return (1);
		}
		errx(1, "%s: bad address", s);
		/* NOTREACHED */

	default:
		errx(1, "%d: bad address family", afamily);
		/* NOTREACHED */
	}
}

int
prefixlen(char *s)
{
	int len = atoi(s), q, r;
	int max;

	switch (af) {
	case AF_INET:
		max = sizeof(struct in_addr) * 8;
		break;
	case AF_INET6:
		max = sizeof(struct in6_addr) * 8;
		break;
	default:
		errx(1, "prefixlen is not supported with af %d", af);
		/* NOTREACHED */
	}

	rtm_addrs |= RTA_NETMASK;
	if (len < -1 || len > max)
		errx(1, "%s: bad value", s);

	q = len >> 3;
	r = len & 7;
	switch (af) {
	case AF_INET:
		memset(&so_mask, 0, sizeof(so_mask));
		so_mask.sin.sin_family = AF_INET;
		so_mask.sin.sin_len = sizeof(struct sockaddr_in);
		so_mask.sin.sin_addr.s_addr = htonl(0xffffffff << (32 - len));
		break;
	case AF_INET6:
		so_mask.sin6.sin6_family = AF_INET6;
		so_mask.sin6.sin6_len = sizeof(struct sockaddr_in6);
		memset((void *)&so_mask.sin6.sin6_addr, 0,
			sizeof(so_mask.sin6.sin6_addr));
		if (q > 0)
			memset((void *)&so_mask.sin6.sin6_addr, 0xff, q);
		if (r > 0)
			*((u_char *)&so_mask.sin6.sin6_addr + q) =
			    (0xff00 >> r) & 0xff;
		break;
	}
	return (len == max);
}

void
interfaces(void)
{
	size_t needed;
	int mib[6];
	char *buf = NULL, *lim, *next;
	struct rt_msghdr *rtm;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;		/* protocol */
	mib[3] = 0;		/* wildcard address family */
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;		/* no flags */
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed) {
		if ((buf = malloc(needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
			err(1, "actual retrieval of interface table");
		lim = buf + needed;
		for (next = buf; next < lim; next += rtm->rtm_msglen) {
			rtm = (struct rt_msghdr *)next;
			print_rtmsg(rtm, rtm->rtm_msglen);
		}
		free(buf);
	}
}

void
monitor(void)
{
	int n;
	char msg[2048];
	time_t now;

	verbose = 1;
	if (debugonly) {
		interfaces();
		exit(0);
	}
	for (;;) {
		if ((n = read(s, msg, sizeof(msg))) == -1) {
			if (errno == EINTR)
				continue;
			err(1, "read");
		}
		now = time(NULL);
		printf("got message of size %d on %s", n, ctime(&now));
		print_rtmsg((struct rt_msghdr *)msg, n);
	}
}

struct {
	struct rt_msghdr	m_rtm;
	char			m_space[512];
} m_rtmsg;

int
rtmsg(int cmd, int flags, int fmask)
{
	static int seq;
	char *cp = m_rtmsg.m_space;
	int l;

#define NEXTADDR(w, u)				\
	if (rtm_addrs & (w)) {			\
		l = ROUNDUP(u.sa.sa_len);	\
		memcpy(cp, &(u), l);		\
		cp += l;			\
		if (verbose)			\
			sodump(&(u), #u);	\
	}

	errno = 0;
	memset(&m_rtmsg, 0, sizeof(m_rtmsg));
	if (cmd == 'a')
		cmd = RTM_ADD;
	else if (cmd == 'c')
		cmd = RTM_CHANGE;
	else if (cmd == 'g') {
		cmd = RTM_GET;
		if (so_ifp.sa.sa_family == 0) {
			so_ifp.sa.sa_family = AF_LINK;
			so_ifp.sa.sa_len = sizeof(struct sockaddr_dl);
			rtm_addrs |= RTA_IFP;
		}
	} else
		cmd = RTM_DELETE;
#define rtm m_rtmsg.m_rtm
	rtm.rtm_type = cmd;
	rtm.rtm_flags = flags;
	rtm.rtm_fmask = fmask;
	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_seq = ++seq;
	rtm.rtm_addrs = rtm_addrs;
	rtm.rtm_rmx = rt_metrics;
	rtm.rtm_inits = rtm_inits;

	if (rtm_addrs & RTA_NETMASK)
		mask_addr(&so_dst, &so_mask, RTA_DST);
	NEXTADDR(RTA_DST, so_dst);
	NEXTADDR(RTA_GATEWAY, so_gate);
	NEXTADDR(RTA_NETMASK, so_mask);
	NEXTADDR(RTA_GENMASK, so_genmask);
	NEXTADDR(RTA_IFP, so_ifp);
	NEXTADDR(RTA_IFA, so_ifa);
	NEXTADDR(RTA_LABEL, so_label);
	rtm.rtm_msglen = l = cp - (char *)&m_rtmsg;
	if (verbose)
		print_rtmsg(&rtm, l);
	if (debugonly)
		return (0);
	if (write(s, &m_rtmsg, l) != l) {
		if (qflag == 0)
			warn("writing to routing socket");
		return (-1);
	}
	if (cmd == RTM_GET) {
		do {
			l = read(s, &m_rtmsg, sizeof(m_rtmsg));
		} while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));
		if (l == -1)
			warn("read from routing socket");
		else
			print_getmsg(&rtm, l);
	}
#undef rtm
	return (0);
}

void
mask_addr(union sockunion *addr, union sockunion *mask, int which)
{
	int olen = mask->sa.sa_len;
	char *cp1 = olen + (char *)mask, *cp2;

	for (mask->sa.sa_len = 0; cp1 > (char *)mask; )
		if (*--cp1 != '\0') {
			mask->sa.sa_len = 1 + cp1 - (char *)mask;
			break;
		}
	if ((rtm_addrs & which) == 0)
		return;
	switch (addr->sa.sa_family) {
	case AF_IPX:
	case AF_INET:
	case AF_INET6:
	case 0:
		return;
	}
	cp1 = mask->sa.sa_len + 1 + (char *)addr;
	cp2 = addr->sa.sa_len + 1 + (char *)addr;
	while (cp2 > cp1)
		*--cp2 = '\0';
	cp2 = mask->sa.sa_len + 1 + (char *)mask;
	while (cp1 > addr->sa.sa_data)
		*--cp1 &= *--cp2;
}

char *msgtypes[] = {
	"",
	"RTM_ADD: Add Route",
	"RTM_DELETE: Delete Route",
	"RTM_CHANGE: Change Metrics or flags",
	"RTM_GET: Report Metrics",
	"RTM_LOSING: Kernel Suspects Partitioning",
	"RTM_REDIRECT: Told to use different route",
	"RTM_MISS: Lookup failed on this address",
	"RTM_LOCK: fix specified metrics",
	"RTM_OLDADD: caused by SIOCADDRT",
	"RTM_OLDDEL: caused by SIOCDELRT",
	"RTM_RESOLVE: Route created by cloning",
	"RTM_NEWADDR: address being added to iface",
	"RTM_DELADDR: address being removed from iface",
	"RTM_IFINFO: iface status change",
	"RTM_IFANNOUNCE: iface arrival/departure",
	NULL
};

char metricnames[] =
"\011pksent\010rttvar\7rtt\6ssthresh\5sendpipe\4recvpipe\3expire\2hopcount\1mtu";
char routeflags[] =
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING"
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED";
char ifnetflags[] =
"\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5PTP\6NOTRAILERS\7RUNNING\010NOARP\011PPROMISC"
"\012ALLMULTI\013OACTIVE\014SIMPLEX\015LINK0\016LINK1\017LINK2\020MULTICAST";
char addrnames[] =
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\13LABEL";

void
print_rtmsg(struct rt_msghdr *rtm, int msglen)
{
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam;
	struct if_announcemsghdr *ifan;
	const char *state = "unknown";
	char ifname[IF_NAMESIZE];

	if (verbose == 0)
		return;
	if (rtm->rtm_version != RTM_VERSION) {
		warnx("routing message version %d not understood",
		    rtm->rtm_version);
		return;
	}
	printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
	switch (rtm->rtm_type) {
	case RTM_IFINFO:
		ifm = (struct if_msghdr *)rtm;
		(void) printf("if# %d, ", ifm->ifm_index);
		if (!nflag && if_indextoname(ifm->ifm_index, ifname) != NULL)
			printf("name: %s, ", ifname);
		switch (ifm->ifm_data.ifi_link_state) {
		case LINK_STATE_DOWN:
			state = "down";
			break;
		case LINK_STATE_UP:
			state = "up";
			break;
		}
		printf("link: %s, flags:", state);
		bprintf(stdout, ifm->ifm_flags, ifnetflags);
		pmsg_addrs((char *)(ifm + 1), ifm->ifm_addrs);
		break;
	case RTM_NEWADDR:
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;
		printf("metric %d, flags:", ifam->ifam_metric);
		bprintf(stdout, ifam->ifam_flags, routeflags);
		pmsg_addrs((char *)(ifam + 1), ifam->ifam_addrs);
		break;
	case RTM_IFANNOUNCE:
		ifan = (struct if_announcemsghdr *)rtm;
		printf("if# %d, name %s, what: ",
		    ifan->ifan_index, ifan->ifan_name);
		switch (ifan->ifan_what) {
		case IFAN_ARRIVAL:
			printf("arrival");
			break;
		case IFAN_DEPARTURE:
			printf("departure");
			break;
		default:
			printf("#%d", ifan->ifan_what);
			break;
		}
		printf("\n");
		break;
	default:
		printf("pid: %ld, seq %d, errno %d, flags:",
		    (long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
		bprintf(stdout, rtm->rtm_flags, routeflags);
		pmsg_common(rtm);
	}
}

void
print_getmsg(struct rt_msghdr *rtm, int msglen)
{
	struct sockaddr *dst = NULL, *gate = NULL, *mask = NULL, *ifa = NULL;
	struct sockaddr_dl *ifp = NULL;
	struct sockaddr_rtlabel *sa_rl = NULL;
	struct sockaddr *sa;
	char *cp;
	int i;

	printf("   route to: %s\n", routename(&so_dst.sa));
	if (rtm->rtm_version != RTM_VERSION) {
		warnx("routing message version %d not understood",
		    rtm->rtm_version);
		return;
	}
	if (rtm->rtm_msglen > msglen)
		warnx("message length mismatch, in packet %d, returned %d",
		    rtm->rtm_msglen, msglen);
	if (rtm->rtm_errno) {
		warnx("RTM_GET: %s (errno %d)",
		    strerror(rtm->rtm_errno), rtm->rtm_errno);
		return;
	}
	cp = ((char *)(rtm + 1));
	if (rtm->rtm_addrs)
		for (i = 1; i; i <<= 1)
			if (i & rtm->rtm_addrs) {
				sa = (struct sockaddr *)cp;
				switch (i) {
				case RTA_DST:
					dst = sa;
					break;
				case RTA_GATEWAY:
					gate = sa;
					break;
				case RTA_NETMASK:
					mask = sa;
					break;
				case RTA_IFA:
					ifa = sa;
					break;
				case RTA_IFP:
					if (sa->sa_family == AF_LINK &&
					   ((struct sockaddr_dl *)sa)->sdl_nlen)
						ifp = (struct sockaddr_dl *)sa;
					break;
				case RTA_LABEL:
					sa_rl = (struct sockaddr_rtlabel *)sa;
					break;
				}
				ADVANCE(cp, sa);
			}
	if (dst && mask)
		mask->sa_family = dst->sa_family;	/* XXX */
	if (dst)
		printf("destination: %s\n", routename(dst));
	if (mask) {
		int savenflag = nflag;

		nflag = 1;
		printf("       mask: %s\n", routename(mask));
		nflag = savenflag;
	}
	if (gate && rtm->rtm_flags & RTF_GATEWAY)
		printf("    gateway: %s\n", routename(gate));
	if (ifp)
		printf("  interface: %.*s\n",
		    ifp->sdl_nlen, ifp->sdl_data);
	if (ifa)
		printf(" if address: %s\n", routename(ifa));
	printf("      flags: ");
	bprintf(stdout, rtm->rtm_flags, routeflags);
	printf("\n");
	if (sa_rl != NULL)
		printf("      label: %s\n", sa_rl->sr_label);

#define lock(f)	((rtm->rtm_rmx.rmx_locks & __CONCAT(RTV_,f)) ? 'L' : ' ')
#define msec(u)	(((u) + 500) / 1000)		/* usec to msec */

	printf("%s\n", "\
 recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire");
	printf("%8lu%c ", rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_mtu, lock(MTU));
	if (rtm->rtm_rmx.rmx_expire)
		rtm->rtm_rmx.rmx_expire -= time(NULL);
	printf("%8ld%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
#undef lock
#undef msec
#define	RTA_IGN	(RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_IFP|RTA_IFA|RTA_BRD)
	if (verbose)
		pmsg_common(rtm);
	else if (rtm->rtm_addrs &~ RTA_IGN) {
		printf("sockaddrs: ");
		bprintf(stdout, rtm->rtm_addrs, addrnames);
		putchar('\n');
	}
#undef	RTA_IGN
}

void
pmsg_common(struct rt_msghdr *rtm)
{
	printf("\nlocks: ");
	bprintf(stdout, rtm->rtm_rmx.rmx_locks, metricnames);
	printf(" inits: ");
	bprintf(stdout, rtm->rtm_inits, metricnames);
	pmsg_addrs(((char *)(rtm + 1)), rtm->rtm_addrs);
}

void
pmsg_addrs(char *cp, int addrs)
{
	struct sockaddr *sa;
	int i;

	if (addrs != 0) {
		printf("\nsockaddrs: ");
		bprintf(stdout, addrs, addrnames);
		putchar('\n');
		for (i = 1; i; i <<= 1)
			if (i & addrs) {
				sa = (struct sockaddr *)cp;
				printf(" %s", routename(sa));
				ADVANCE(cp, sa);
			}
	}
	putchar('\n');
	fflush(stdout);
}

void
bprintf(FILE *fp, int b, char *s)
{
	int i;
	int gotsome = 0;

	if (b == 0)
		return;
	while ((i = *s++)) {
		if ((b & (1 << (i-1)))) {
			if (gotsome == 0)
				i = '<';
			else
				i = ',';
			putc(i, fp);
			gotsome = 1;
			for (; (i = *s) > 32; s++)
				putc(i, fp);
		} else
			while (*s > 32)
				s++;
	}
	if (gotsome)
		putc('>', fp);
}

int
keyword(char *cp)
{
	struct keytab *kt = keywords;

	while (kt->kt_cp && strcmp(kt->kt_cp, cp))
		kt++;
	return (kt->kt_i);
}

void
sodump(sup su, char *which)
{
	switch (su->sa.sa_family) {
	case AF_LINK:
		printf("%s: link %s; ", which, link_ntoa(&su->sdl));
		break;
	case AF_INET:
		printf("%s: inet %s; ", which, inet_ntoa(su->sin.sin_addr));
		break;
	case AF_INET6:
	    {
		char ntop_buf[NI_MAXHOST];

		printf("%s: inet6 %s; ",
		    which, inet_ntop(AF_INET6, &su->sin6.sin6_addr,
		    ntop_buf, sizeof(ntop_buf)));
		break;
	    }
	case AF_IPX:
		printf("%s: ipx %s; ", which, ipx_ntoa(su->sipx.sipx_addr));
		break;
	}
	fflush(stdout);
}

/* States*/
#define VIRGIN	0
#define GOTONE	1
#define GOTTWO	2
/* Inputs */
#define	DIGIT	(4*0)
#define	END	(4*1)
#define DELIM	(4*2)

void
sockaddr(char *addr, struct sockaddr *sa)
{
	char *cp = (char *)sa;
	int size = sa->sa_len;
	char *cplim = cp + size;
	int byte = 0, state = VIRGIN, new = 0;

	memset(cp, 0, size);
	cp++;
	do {
		if ((*addr >= '0') && (*addr <= '9')) {
			new = *addr - '0';
		} else if ((*addr >= 'a') && (*addr <= 'f')) {
			new = *addr - 'a' + 10;
		} else if ((*addr >= 'A') && (*addr <= 'F')) {
			new = *addr - 'A' + 10;
		} else if (*addr == '\0')
			state |= END;
		else
			state |= DELIM;
		addr++;
		switch (state /* | INPUT */) {
		case GOTTWO | DIGIT:
			*cp++ = byte; /*FALLTHROUGH*/
		case VIRGIN | DIGIT:
			state = GOTONE; byte = new; continue;
		case GOTONE | DIGIT:
			state = GOTTWO; byte = new + (byte << 4); continue;
		default: /* | DELIM */
			state = VIRGIN; *cp++ = byte; byte = 0; continue;
		case GOTONE | END:
		case GOTTWO | END:
			*cp++ = byte; /* FALLTHROUGH */
		case VIRGIN | END:
			break;
		}
		break;
	} while (cp < cplim);
	sa->sa_len = cp - (char *)sa;
}

void
getlabel(char *name)
{
	so_label.rtlabel.sr_len = sizeof(so_label.rtlabel);
	so_label.rtlabel.sr_family = AF_UNSPEC;
	if (strlcpy(so_label.rtlabel.sr_label, name,
	    sizeof(so_label.rtlabel.sr_label)) >=
	    sizeof(so_label.rtlabel.sr_label))
		errx(1, "label too long");
	rtm_addrs |= RTA_LABEL;
}
@


1.3
log
@NS, ISO/OSI and CCITT are gone...
@
text
@d1 2
a2 2
/**	$MirOS: src/sbin/route/route.c,v 1.2 2005/03/06 19:50:34 tg Exp $	*/
/*	$OpenBSD: route.c,v 1.66 2004/05/15 07:43:34 claudio Exp $	*/
a33 6
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1989, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

d41 2
a43 1
#include <net/if_dl.h>
d54 1
d58 1
d61 1
d63 1
a63 1
__RCSID("$MirOS: src/sbin/route/route.c,v 1.2 2005/03/06 19:50:34 tg Exp $");
d66 7
a72 8
	struct	sockaddr sa;
	struct	sockaddr_in sin;
#ifdef INET6
	struct	sockaddr_in6 sin6;
#endif
	struct	sockaddr_ipx sipx;
	struct	sockaddr_dl sdl;
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp;
d77 2
a78 2
int	forcehost, forcenet, doflush, nflag, af, qflag, tflag, keyword(char *);
int	iflag, verbose, aflen = sizeof (struct sockaddr_in);
d80 1
a80 2
struct	rt_metrics rt_metrics;
u_long  rtm_inits;
d83 2
a84 2
char	*routename(struct sockaddr *);
char	*netname(struct sockaddr *);
d87 2
d97 3
a99 5
void	 bprintf(FILE *, int, u_char *);
void	 mask_addr(void);
#ifdef INET6
static int inet6_makenetandmask(struct sockaddr_in6 *);
#endif
d101 6
a106 11
int	 rtmsg(int, int);
int	 x25_makemask(void);
__dead void usage(char *cp);
void	quit(char *s);
char	*any_ntoa(const struct sockaddr *sa);
void	set_metric(char *value, int key);
void	inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits);
char	*ipx_print(struct sockaddr_ipx *sipx);
void	interfaces(void);

extern void show(int, char **);	/* XXX - from show.c */
d111 2
d114 6
a119 5
		(void) fprintf(stderr, "route: botched keyword: %s\n", cp);
	(void) fprintf(stderr,
	    "usage: route [ -nqv ] cmd [[ -<modifiers> ] args ]\n");
	(void) fprintf(stderr,
	    "keywords: get, add, change, delete, show, flush, monitor.\n");
a120 14
	/* NOTREACHED */
}

void
quit(char *s)
{
	int sverrno = errno;

	(void) fprintf(stderr, "route: ");
	if (s)
		(void) fprintf(stderr, "%s: ", s);
	(void) fprintf(stderr, "%s\n", strerror(sverrno));
	exit(1);
	/* NOTREACHED */
d136 2
a137 2
	while ((ch = getopt(argc, argv, "nqdtv")) != -1)
		switch(ch) {
d155 1
d166 2
a167 2
	if (s < 0)
		quit("socket");
d169 1
a169 1
		goto no_cmd;
a188 1
	no_cmd:
d191 1
d209 2
a210 4
	if (uid) {
		errno = EACCES;
		quit("must be root to alter routing table");
	}
d215 1
a215 1
		    switch (keyword(*argv + 1)) {
a218 1
#ifdef INET6
a221 1
#endif
d229 5
a233 3
				goto bad;
		} else
bad:			usage(*argv);
d242 1
a242 1
		quit("route-sysctl-estimate");
d245 1
a245 1
			quit("malloc");
d247 1
a247 1
			quit("actual retrieval of routing table");
d251 2
a252 2
		(void) printf("Examining routing table from sysctl\n");
		 if (af)
d258 1
a258 1
	seqno = 0;		/* ??? */
d266 2
a267 4
		if (af) {
			if (sa->sa_family != af)
				continue;
		}
d276 2
a277 4
			(void) fprintf(stderr,
			    "route: write to routing socket: %s\n",
			    strerror(errno));
			(void) printf("got only %d for rlen\n", rlen);
d287 7
a293 5
			(void) printf("%-20.20s ", rtm->rtm_flags & RTF_HOST ?
			    routename(sa) : netname(sa));
			sa = (struct sockaddr *)(ROUNDUP(sa->sa_len) + (char *)sa);
			(void) printf("%-20.20s ", routename(sa));
			(void) printf("done\n");
a298 214
static char hexlist[] = "0123456789abcdef";

char *
any_ntoa(const struct sockaddr *sa)
{
	static char obuf[240];
	const char *in = sa->sa_data;
	char *out = obuf;
	int len = sa->sa_len - 2;

	*out++ = 'Q';
	do {
		*out++ = hexlist[(*in >> 4) & 15];
		*out++ = hexlist[(*in++)    & 15];
		*out++ = '.';
	} while (--len > 0 && (out + 3) < &obuf[sizeof obuf-1]);
	out[-1] = '\0';
	return (obuf);
}

char *
routename(struct sockaddr *sa)
{
	char *cp = NULL;
	static char line[MAXHOSTNAMELEN];
	struct hostent *hp;
	static char domain[MAXHOSTNAMELEN];
	static int first = 1;
	char *ipx_print(struct sockaddr_ipx *);

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof domain) == 0 &&
		    (cp = strchr(domain, '.')))
			(void) strlcpy(domain, cp + 1, sizeof domain);
		else
			domain[0] = 0;
		cp = NULL;
	}

	if (sa->sa_len == 0)
		(void) strlcpy(line, "default", sizeof line);
	else switch (sa->sa_family) {

	case AF_INET:
	    {	struct in_addr in;
		in = ((struct sockaddr_in *)sa)->sin_addr;

		if (in.s_addr == INADDR_ANY || sa->sa_len < 4)
			cp = "default";
		if (!cp && !nflag) {
			if ((hp = gethostbyaddr((char *)&in.s_addr,
			    sizeof (in.s_addr), AF_INET)) != NULL) {
				if ((cp = strchr(hp->h_name, '.')) &&
				    !strcmp(cp + 1, domain))
					*cp = 0;
				cp = hp->h_name;
			}
		}
		strlcpy(line, cp ? cp : inet_ntoa(in), sizeof line);
		break;
	    }

#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;
		int niflags;

#ifdef NI_WITHSCOPEID
		niflags = NI_WITHSCOPEID;
#else
		niflags = 0;
#endif
		if (nflag)
			niflags |= NI_NUMERICHOST;
		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_family = AF_INET6;
#ifdef __KAME__
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
		    line, sizeof(line), NULL, 0, niflags) != 0)
			strncpy(line, "invalid", sizeof(line));
		break;
	    }
#endif

	case AF_IPX:
		return (ipx_print((struct sockaddr_ipx *)sa));

	case AF_LINK:
		return (link_ntoa((struct sockaddr_dl *)sa));

	default:
		(void) snprintf(line, sizeof line, "(%d) %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname(struct sockaddr *sa)
{
	char *cp = NULL;
	static char line[MAXHOSTNAMELEN];
	struct netent *np = 0;
	in_addr_t net, mask, subnetshift;
	char *ipx_print(struct sockaddr_ipx *);

	switch (sa->sa_family) {

	case AF_INET:
	    {
		struct in_addr in = ((struct sockaddr_in *)sa)->sin_addr;

		in.s_addr = ntohl(in.s_addr);
		if (in.s_addr == 0)
			cp = "default";
		else if (!nflag) {
			if (IN_CLASSA(in.s_addr)) {
				mask = IN_CLASSA_NET;
				subnetshift = 8;
			} else if (IN_CLASSB(in.s_addr)) {
				mask = IN_CLASSB_NET;
				subnetshift = 8;
			} else {
				mask = IN_CLASSC_NET;
				subnetshift = 4;
			}
			/*
			 * If there are more bits than the standard mask
			 * would suggest, subnets must be in use.
			 * Guess at the subnet mask, assuming reasonable
			 * width subnet fields.
			 */
			while (in.s_addr &~ mask)
				mask = (int)mask >> subnetshift;
			net = in.s_addr & mask;
			while ((mask & 1) == 0)
				mask >>= 1, net >>= 1;
			np = getnetbyaddr(net, AF_INET);
			if (np)
				cp = np->n_name;
		}
		in = ((struct sockaddr_in *)sa)->sin_addr;
		strlcpy(line, cp ? cp : inet_ntoa(in), sizeof line);
		break;
	    }

#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;
		int niflags;

#ifdef NI_WITHSCOPEID
		niflags = NI_WITHSCOPEID;
#else
		niflags = 0;
#endif
		if (nflag)
			niflags |= NI_NUMERICHOST;
		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_family = AF_INET6;
#ifdef __KAME__
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
		    line, sizeof(line), NULL, 0, niflags) != 0)
			strncpy(line, "invalid", sizeof(line));
		break;
	    }
#endif

	case AF_IPX:
		return (ipx_print((struct sockaddr_ipx *)sa));

	case AF_LINK:
		return (link_ntoa((struct sockaddr_dl *)sa));

	default:
		snprintf(line, sizeof line, "af %d: %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

d306 34
a339 9
#define caseof(x, y, z)	case x: valp = &rt_metrics.z; flag = y; break
	caseof(K_MTU, RTV_MTU, rmx_mtu);
	caseof(K_HOPCOUNT, RTV_HOPCOUNT, rmx_hopcount);
	caseof(K_EXPIRE, RTV_EXPIRE, rmx_expire);
	caseof(K_RECVPIPE, RTV_RPIPE, rmx_recvpipe);
	caseof(K_SENDPIPE, RTV_SPIPE, rmx_sendpipe);
	caseof(K_SSTHRESH, RTV_SSTHRESH, rmx_ssthresh);
	caseof(K_RTT, RTV_RTT, rmx_rtt);
	caseof(K_RTTVAR, RTV_RTTVAR, rmx_rttvar);
d352 1
a352 1
	char *cmd, *dest = "", *gateway = "", *err;
d354 1
d356 1
a356 1
	struct hostent *hp = 0;
d358 2
a359 4
	if (uid) {
		errno = EACCES;
		quit("must be root to alter routing table");
	}
a373 1
#ifdef INET6
a377 1
#endif
d429 1
a429 1
				(void) getaddr(RTA_IFA, *++argv, 0);
d434 1
a434 1
				(void) getaddr(RTA_IFP, *++argv, 0);
d439 1
a439 1
				(void) getaddr(RTA_GENMASK, *++argv, 0);
d444 1
a444 1
				(void) getaddr(RTA_GATEWAY, *++argv, 0);
d453 5
d461 1
a461 1
				(void) getaddr(RTA_NETMASK, *++argv, 0);
d471 11
d496 1
d504 1
a504 1
				(void) getaddr(RTA_GATEWAY, *argv, &hp);
d525 1
a525 1
				(void) getaddr(RTA_NETMASK, *argv, 0);
d533 2
d542 1
a542 1
		if ((ret = rtmsg(*cmd, flags)) == 0)
d557 1
a557 1
		(void) printf("%s %s %s", cmd, ishost? "host" : "net", dest);
d559 1
a559 1
			(void) printf(": gateway %s", gateway);
d561 1
a561 2
			    (void) printf(" (%s)",
				inet_ntoa(so_gate.sin.sin_addr));
d564 1
a564 1
			(void) printf("\n");
d568 1
a568 1
				err = "not in table";
d571 1
a571 1
				err = "entry in use";
d574 1
a574 1
				err = "routing table overflow";
d577 1
a577 1
				err = strerror(oerrno);
d580 1
a580 1
			(void) printf(": %s\n", err);
d587 32
d642 1
a642 1
			mask =  IN_CLASSA_NET;
d644 1
a644 1
			mask =  IN_CLASSB_NET;
d646 1
a646 1
			mask =  IN_CLASSC_NET;
d648 1
a648 1
			mask = -1;
d650 1
d657 1
a657 1
	while (*--cp == 0 && cp > (char *)sin)
a661 1
#ifdef INET6
d665 1
a665 1
static int
d682 1
a682 1
		return 1;
d685 2
a686 2
		(void)prefixlen(plen);
		return 0;
a688 1
#endif
d700 1
a700 3
	u_long val;
	char *q, qs;
	int afamily;
d707 1
a727 1
		su->sa.sa_family = af;
d730 2
a731 2
		usage("Internal Error");
		/*NOTREACHED*/
d734 2
a735 1
	su->sa.sa_family = afamily; /* cases that don't want it have left already */
d740 1
a740 1
			(void) getaddr(RTA_NETMASK, s, 0);
d748 1
a749 1
#ifdef INET6
d760 2
a761 13
			if (getaddrinfo(s, "0", &hints, &res) != 0) {
				(void) fprintf(stderr, "%s: bad value\n", s);
				exit(1);
			}
		}
		if (sizeof(su->sin6) != res->ai_addrlen) {
			(void) fprintf(stderr, "%s: bad value\n", s);
			exit(1);
		}
		if (res->ai_next) {
			(void) fprintf(stderr,
			    "%s: resolved to multiple values\n", s);
			exit(1);
d763 4
a768 1
#ifdef __KAME__
a775 1
#endif
a782 1
#endif
d807 20
a826 17
	default:
		break;
	}

	if (hpp == NULL)
		hpp = &hp;
	*hpp = NULL;

	q = strchr(s,'/');
	if (q && which == RTA_DST) {
		qs = *q;
		*q = '\0';
		val = inet_addr(s);
		if (val != INADDR_NONE) {
			inet_makenetandmask(htonl(val), &su->sin,
			    strtoul(q+1, 0, 0));
			return (0);
d828 7
a834 6
		*q =qs;
	}
	if (((val = inet_addr(s)) != INADDR_NONE) &&
	    (which != RTA_DST || forcenet == 0)) {
		su->sin.sin_addr.s_addr = val;
		if (inet_lnaof(su->sin.sin_addr) != INADDR_ANY)
a835 3
		else {
			val = ntohl(val);
			goto netdone;
d837 6
a843 17
	if ((val = inet_network(s)) != INADDR_NONE ||
	    (forcehost == 0 && (np = getnetbyname(s)) != NULL &&
	    (val = np->n_net) != 0)) {
netdone:
		if (which == RTA_DST)
			inet_makenetandmask(val, &su->sin, 0);
		return (0);
	}
	hp = gethostbyname(s);
	if (hp) {
		*hpp = hp;
		su->sin.sin_family = hp->h_addrtype;
		memcpy(&su->sin.sin_addr, hp->h_addr, hp->h_length);
		return (1);
	}
	(void) fprintf(stderr, "route: %s: bad value\n", s);
	exit(1);
a855 1
#ifdef INET6
a858 1
#endif
d860 2
a861 3
		(void) fprintf(stderr,
		    "prefixlen is not supported with af %d\n", af);
		exit(1);
d865 2
a866 4
	if (len < -1 || len > max) {
		(void) fprintf(stderr, "%s: bad value\n", s);
		exit(1);
	}
a876 1
#ifdef INET6
a887 1
#endif
a891 47
short ipx_nullh[] = {0,0,0};
short ipx_bh[] = {-1,-1,-1};

char *
ipx_print(struct sockaddr_ipx *sipx)
{
	struct ipx_addr work;
	union { union ipx_net net_e; u_int32_t long_e; } net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN], cport[10], chost[25];
	char *host = "";
	char *p;
	u_char *q;

	work = sipx->sipx_addr;
	port = ntohs(work.ipx_port);
	work.ipx_port = 0;
	net.net_e  = work.ipx_net;
	if (ipx_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%XH", port);
		return (mybuf);
	}

	if (memcmp(ipx_bh, work.ipx_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ipx_nullh, work.ipx_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.ipx_host.c_host;
		(void) snprintf(chost, sizeof chost, "%02X%02X%02X%02X%02X%02XH",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		for (p = chost; *p == '0' && p < chost + 12; p++)
			/* void */;
		host = p;
	}
	if (port)
		(void) snprintf(cport, sizeof cport, ".%XH", htons(port));
	else
		*cport = 0;

	(void) snprintf(mybuf, sizeof mybuf, "%XH.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
}

d907 1
a907 1
		quit("route-sysctl-estimate");
d910 1
a910 1
			quit("malloc");
d912 1
a912 1
			quit("actual retrieval of interface table");
d927 1
d934 6
a939 3
	for(;;) {
		time_t now;
		n = read(s, msg, 2048);
d941 1
a941 1
		(void) printf("got message of size %d on %s", n, ctime(&now));
d947 2
a948 2
	struct	rt_msghdr m_rtm;
	char	m_space[512];
d952 1
a952 1
rtmsg(int cmd, int flags)
a954 1
	int rlen;
d958 7
a964 4
#define NEXTADDR(w, u) \
	if (rtm_addrs & (w)) {\
	    l = ROUNDUP(u.sa.sa_len); memcpy(cp, &(u), l); cp += l;\
	    if (verbose) sodump(&(u),"u");\
d985 1
d993 1
a993 1
		mask_addr();
d1000 1
d1006 1
a1006 1
	if ((rlen = write(s, (char *)&m_rtmsg, l)) < 0) {
d1008 1
a1008 1
			perror("writing to routing socket");
d1013 1
a1013 1
			l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
d1015 2
a1016 4
		if (l < 0)
			(void) fprintf(stderr,
			    "route: read from routing socket: %s\n",
			    strerror(errno));
d1025 1
a1025 1
mask_addr(void)
d1027 2
a1028 2
	int olen = so_mask.sa.sa_len;
	char *cp1 = olen + (char *)&so_mask, *cp2;
d1030 3
a1032 3
	for (so_mask.sa.sa_len = 0; cp1 > (char *)&so_mask; )
		if (*--cp1 != 0) {
			so_mask.sa.sa_len = 1 + cp1 - (char *)&so_mask;
d1035 1
a1035 1
	if ((rtm_addrs & RTA_DST) == 0)
d1037 1
a1037 1
	switch (so_dst.sa.sa_family) {
a1039 1
#ifdef INET6
a1040 1
#endif
d1044 2
a1045 2
	cp1 = so_mask.sa.sa_len + 1 + (char *)&so_dst;
	cp2 = so_dst.sa.sa_len + 1 + (char *)&so_dst;
d1047 3
a1049 3
		*--cp2 = 0;
	cp2 = so_mask.sa.sa_len + 1 + (char *)&so_mask;
	while (cp1 > so_dst.sa.sa_data)
d1070 1
a1070 1
	0,
d1076 2
a1077 1
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING\012XRESOLVE\013LLINFO\014STATIC\017PROTO2\020PROTO1\040CLONED";
d1079 2
a1080 1
"\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5PTP\6NOTRAILERS\7RUNNING\010NOARP\011PPROMISC\012ALLMULTI\013OACTIVE\014SIMPLEX\015LINK0\016LINK1\017LINK2\020MULTICAST";
d1082 1
a1082 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD";
d1091 1
d1096 1
a1096 1
		(void) printf("routing message version %d not understood\n",
d1100 1
a1100 1
	(void)printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
d1105 2
d1115 1
a1115 1
		(void) printf("link: %s, flags:", state);
d1122 1
a1122 1
		(void) printf("metric %d, flags:", ifam->ifam_metric);
d1128 1
a1128 1
		(void) printf("if# %d, name %s, what: ",
d1144 2
a1145 2
		(void) printf("pid: %ld, seq %d, errno %d, flags:",
			(long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
d1154 1
a1154 1
	struct sockaddr *dst = NULL, *gate = NULL, *mask = NULL;
d1156 1
d1161 1
a1161 1
	(void) printf("   route to: %s\n", routename(&so_dst.sa));
d1163 1
a1163 2
		(void)fprintf(stderr,
		    "routing message version %d not understood\n",
d1167 2
a1168 3
	if (rtm->rtm_msglen > msglen) {
		(void)fprintf(stderr,
		    "message length mismatch, in packet %d, returned %d\n",
d1170 2
a1171 3
	}
	if (rtm->rtm_errno)  {
		(void) fprintf(stderr, "RTM_GET: %s (errno %d)\n",
d1190 3
d1198 3
d1207 1
a1207 1
		(void)printf("destination: %s\n", routename(dst));
d1212 1
a1212 1
		(void)printf("       mask: %s\n", routename(mask));
d1216 1
a1216 1
		(void)printf("    gateway: %s\n", routename(gate));
d1218 1
a1218 1
		(void)printf("  interface: %.*s\n",
d1220 3
a1222 1
	(void)printf("      flags: ");
d1224 3
d1231 1
a1231 1
	(void) printf("\n%s\n", "\
d1233 7
a1239 7
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8d%c ", (int)msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8d%c ", (int)msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_mtu, lock(MTU));
d1241 2
a1242 2
		rtm->rtm_rmx.rmx_expire -= time(0);
	printf("%8d%c\n", (int)rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
d1249 1
a1249 1
		(void) printf("sockaddrs: ");
d1259 1
a1259 1
	(void) printf("\nlocks: ");
d1261 1
a1261 1
	(void) printf(" inits: ");
d1273 1
a1273 1
		(void) printf("\nsockaddrs: ");
d1275 1
a1275 1
		(void) putchar('\n');
d1279 1
a1279 1
				(void) printf(" %s", routename(sa));
d1283 2
a1284 2
	(void) putchar('\n');
	(void) fflush(stdout);
d1288 1
a1288 1
bprintf(FILE *fp, int b, u_char *s)
d1301 1
a1301 1
			(void) putc(i, fp);
d1304 1
a1304 1
				(void) putc(i, fp);
d1310 1
a1310 1
		(void) putc('>', fp);
a1325 4
#ifdef INET6
	char ntop_buf[NI_MAXHOST];	/*for inet_ntop()*/
#endif

d1328 1
a1328 2
		(void) printf("%s: link %s; ",
		    which, link_ntoa(&su->sdl));
d1331 1
a1331 2
		(void) printf("%s: inet %s; ",
		    which, inet_ntoa(su->sin.sin_addr));
a1332 1
#ifdef INET6
d1334 4
a1337 1
		(void) printf("%s: inet6 %s; ",
d1339 1
a1339 1
				     ntop_buf, sizeof(ntop_buf)));
d1341 1
a1341 1
#endif
d1343 1
a1343 2
		(void) printf("%s: ipx %s; ",
		    which, ipx_ntoa(su->sipx.sipx_addr));
d1346 1
a1346 1
	(void) fflush(stdout);
d1375 1
a1375 1
		} else if (*addr == 0)
d1399 12
@


1.2
log
@merge src/sbin
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d65 1
a65 1
__RCSID("$MirOS$");
a244 3
			case K_XNS:
				af = AF_NS;
				break;
a250 7
			case K_ISO:
			case K_OSI:
				af = AF_ISO;
				break;
			case K_X25:
				af = AF_CCITT;
				break;
@


1.1
log
@Initial revision
@
text
@d1 1
a39 8
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)route.c	8.3 (Berkeley) 3/19/94";
#else
static const char rcsid[] = "$OpenBSD: route.c,v 1.66 2004/05/15 07:43:34 claudio Exp $";
#endif
#endif /* not lint */

a49 1
#include <netns/ns.h>
a50 2
#include <netiso/iso.h>
#include <netccitt/x25.h>
d65 2
a72 1
	struct	sockaddr_ns sns;
a73 1
	struct	sockaddr_iso siso;
a74 1
	struct	sockaddr_x25 sx25;
a111 1
char	*ns_print(struct sockaddr_ns *sns);
a359 1
	char *ns_print(struct sockaddr_ns *);
a429 3
	case AF_NS:
		return (ns_print((struct sockaddr_ns *)sa));

a435 5
	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

a454 1
	char *ns_print(struct sockaddr_ns *);
a531 3
	case AF_NS:
		return (ns_print((struct sockaddr_ns *)sa));

a537 5
	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

a592 5
			case K_OSI:
			case K_ISO:
				af = AF_ISO;
				aflen = sizeof(struct sockaddr_iso);
				break;
a602 4
			case K_X25:
				af = AF_CCITT;
				aflen = sizeof(struct sockaddr_x25);
				break;
a606 4
			case K_XNS:
				af = AF_NS;
				aflen = sizeof(struct sockaddr_ns);
				break;
a873 1
	struct ccitt_addr *ccitt_addr(char *, struct sockaddr_x25 *);
a970 13
	case AF_NS:
		if (which == RTA_DST) {
			extern short ns_bh[3];
			struct sockaddr_ns *sms = &(so_mask.sns);
			memset(sms, 0, sizeof(*sms));
			sms->sns_family = 0;
			sms->sns_len = 6;
			sms->sns_addr.x_net = *(union ns_net *)ns_bh;
			rtm_addrs |= RTA_NETMASK;
		}
		su->sns.sns_addr = ns_addr(s);
		return (!ns_nullhost(su->sns.sns_addr));

a983 12
	case AF_OSI:
		su->siso.siso_addr = *iso_addr(s);
		if (which == RTA_NETMASK || which == RTA_GENMASK) {
			char *cp = (char *)TSEL(&su->siso);
			su->siso.siso_nlen = 0;
			do {
				--cp;
			} while ((cp > (char *)su) && (*cp == 0));
			su->siso.siso_len = 1 + cp - (char *)su;
		}
		return (1);

a987 4
	case AF_CCITT:
		ccitt_addr(s, &su->sx25);
		return (which == RTA_DST ? x25_makemask() : 1);

a1095 60
int
x25_makemask(void)
{
	char *cp;

	if ((rtm_addrs & RTA_NETMASK) == 0) {
		rtm_addrs |= RTA_NETMASK;
		for (cp = (char *)&so_mask.sx25.x25_net;
		     cp < &so_mask.sx25.x25_opts.op_flags; cp++)
			*cp = -1;
		so_mask.sx25.x25_len = (u_char)&(((sup)0)->sx25.x25_opts);
	}
	return (0);
}

short ns_nullh[] = {0,0,0};
short ns_bh[] = {-1,-1,-1};

char *
ns_print(struct sockaddr_ns *sns)
{
	struct ns_addr work;
	union { union ns_net net_e; u_int32_t long_e; } net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN];
	char cport[10], chost[25];
	char *host = "";
	u_char *q;

	work = sns->sns_addr;
	port = ntohs(work.x_port);
	work.x_port = 0;
	net.net_e  = work.x_net;
	if (ns_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%x", port);
		return (mybuf);
	}

	if (memcmp(ns_bh, work.x_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ns_nullh, work.x_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.x_host.c_host;
		(void) snprintf(chost, sizeof chost, "0x%02x%02x%02x%02x%02x%02x",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		host = chost;
	}
	if (port)
		(void) snprintf(cport, sizeof cport, ".0x%x", htons(port));
	else
		*cport = '\0';

	(void) snprintf(mybuf, sizeof mybuf, "0x%x.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
}

a1282 1
	case AF_NS:
a1287 1
	case AF_CCITT:
a1289 4
	case AF_ISO:
		olen = MIN(so_dst.siso.siso_nlen,
			   MAX(so_mask.sa.sa_len - 6, 0));
		break;
a1297 5
	switch (so_dst.sa.sa_family) {
	case AF_ISO:
		so_dst.siso.siso_nlen = olen;
		break;
	}
a1567 4
	case AF_ISO:
		(void) printf("%s: iso %s; ",
		    which, iso_ntoa(&su->siso.siso_addr));
		break;
a1578 4
	case AF_NS:
		(void) printf("%s: xns %s; ",
		    which, ns_ntoa(su->sns.sns_addr));
		break;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.91 2005/06/09 08:07:45 markus Exp $	*/
d33 14
d54 1
a55 2
#include <net/if_types.h>
#include <net/route.h>
d57 1
d59 2
a68 1
#include <stddef.h>
a71 1
#include <err.h>
a73 1
#include "show.h"
d76 11
a86 7
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
	struct sockaddr_ipx	sipx;
	struct sockaddr_dl	sdl;
	struct sockaddr_rtlabel	rtlabel;
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_label;
d91 2
a92 2
int	forcehost, forcenet, nflag, af, qflag, tflag;
int	iflag, verbose, aflen = sizeof(struct sockaddr_in);
d94 2
a95 1
u_long	rtm_inits;
d98 2
a99 2
struct rt_metrics	rt_metrics;

a101 2
void	 show(int, char *[]);
int	 keyword(char *);
d110 5
a114 3
void	 bprintf(FILE *, int, char *);
void	 mask_addr(union sockunion *, union sockunion *, int);
int	 inet6_makenetandmask(struct sockaddr_in6 *);
d116 12
a127 6
int	 rtmsg(int, int, int);
__dead void usage(char *);
void	 set_metric(char *, int);
void	 inet_makenetandmask(u_int32_t, struct sockaddr_in *, int);
void	 interfaces(void);
void	 getlabel(char *);
d132 14
a145 1
	extern char *__progname;
d147 4
a150 7
	if (cp)
		warnx("botched keyword: %s", cp);
	fprintf(stderr,
	    "usage: %s [-dnqtv] command [[modifiers] args]\n",
	    __progname);
	fprintf(stderr,
	    "commands: add, change, delete, flush, get, monitor, show\n");
d152 1
d168 2
a169 2
	while ((ch = getopt(argc, argv, "dnqtv")) != -1)
		switch (ch) {
a186 1
			/* NOTREACHED */
d197 2
a198 2
	if (s == -1)
		err(1, "socket");
d200 1
a200 1
		usage(NULL);
d220 1
a222 1
		/* NOTREACHED */
d240 4
a243 2
	if (uid)
		errx(1, "must be root to alter routing table");
d248 1
a248 1
			switch (keyword(*argv + 1)) {
d252 1
d256 4
d266 7
d274 3
a276 5
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
d285 1
a285 1
		err(1, "route-sysctl-estimate");
d288 1
a288 1
			err(1, "malloc");
d290 1
a290 1
			err(1, "actual retrieval of routing table");
d294 2
a295 2
		printf("Examining routing table from sysctl\n");
		if (af)
d301 1
a301 1
	seqno = 0;
d309 4
a312 2
		if (af && sa->sa_family != af)
			continue;
d321 4
a324 2
			warn("write to routing socket");
			printf("got only %d for rlen\n", rlen);
d334 5
a338 7
			printf("%-20.20s ", rtm->rtm_flags & RTF_HOST ?
			    routename(sa) : netname(sa, NULL)); /* XXX extract
								   netmask */
			sa = (struct sockaddr *)
			    (ROUNDUP(sa->sa_len) + (char *)sa);
			printf("%-20.20s ", routename(sa));
			printf("done\n");
d344 232
d583 9
a591 34
	case K_MTU:
		valp = &rt_metrics.rmx_mtu;
		flag = RTV_MTU;
		break;
	case K_HOPCOUNT:
		valp = &rt_metrics.rmx_hopcount;
		flag = RTV_HOPCOUNT;
		break;
	case K_EXPIRE:
		valp = &rt_metrics.rmx_expire;
		flag = RTV_EXPIRE;
		break;
	case K_RECVPIPE:
		valp = &rt_metrics.rmx_recvpipe;
		flag = RTV_RPIPE;
		break;
	case K_SENDPIPE:
		valp = &rt_metrics.rmx_sendpipe;
		flag = RTV_SPIPE;
		break;
	case K_SSTHRESH:
		valp = &rt_metrics.rmx_ssthresh;
		flag = RTV_SSTHRESH;
		break;
	case K_RTT:
		valp = &rt_metrics.rmx_rtt;
		flag = RTV_RTT;
		break;
	case K_RTTVAR:
		valp = &rt_metrics.rmx_rttvar;
		flag = RTV_RTTVAR;
		break;
	default:
		errx(1, "king bula sez: set_metric with invalid key");
d604 1
a604 1
	char *cmd, *dest = "", *gateway = "", *error;
a605 1
	int fmask = 0;
d607 1
a607 1
	struct hostent *hp = NULL;
d609 4
a612 2
	if (uid)
		errx(1, "must be root to alter routing table");
d623 5
d632 1
d637 5
d646 4
d697 1
a697 1
				getaddr(RTA_IFA, *++argv, NULL);
d702 1
a702 1
				getaddr(RTA_IFP, *++argv, NULL);
d707 1
a707 1
				getaddr(RTA_GENMASK, *++argv, NULL);
d712 1
a712 1
				getaddr(RTA_GATEWAY, *++argv, NULL);
a720 5
			case K_LABEL:
				if (!--argc)
					usage(1+*argv);
				getlabel(*++argv);
				break;
d724 1
a724 1
				getaddr(RTA_NETMASK, *++argv, NULL);
a733 11
			case K_MPATH:
				flags |= RTF_MPATH;
				break;
			case K_JUMBO:
				flags |= RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
			case K_NOJUMBO:
				flags &= ~RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
a747 1
				/* NOTREACHED */
d755 1
a755 1
				getaddr(RTA_GATEWAY, *argv, &hp);
d776 1
a776 1
				getaddr(RTA_NETMASK, *argv, NULL);
a783 2
	if (forcenet && !(rtm_addrs & RTA_NETMASK))
		errx(1, "netmask missing");
d791 1
a791 1
		if ((ret = rtmsg(*cmd, flags, fmask)) == 0)
d806 1
a806 1
		printf("%s %s %s", cmd, ishost ? "host" : "net", dest);
d808 1
a808 1
			printf(": gateway %s", gateway);
d810 2
a811 1
			    printf(" (%s)", inet_ntoa(so_gate.sin.sin_addr));
d814 1
a814 1
			printf("\n");
d818 1
a818 1
				error = "not in table";
d821 1
a821 1
				error = "entry in use";
d824 1
a824 1
				error = "routing table overflow";
d827 1
a827 1
				error = strerror(oerrno);
d830 1
a830 1
			printf(": %s\n", error);
a836 32
show(int argc, char *argv[])
{
	int	af = 0;

	if (argc > 1) {
		argv++;
		if (argc == 2 && **argv == '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_IPX:
				af = AF_IPX;
				break;
			case K_LINK:
				af = AF_LINK;
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}

	p_rttables(af, 0);
}

void
d860 1
a860 1
			mask = IN_CLASSA_NET;
d862 1
a862 1
			mask = IN_CLASSB_NET;
d864 1
a864 1
			mask = IN_CLASSC_NET;
d866 1
a866 1
			mask = 0xffffffff;
a867 1
	addr &= mask;
d874 1
a874 1
	while (*--cp == '\0' && cp > (char *)sin)
d879 1
d883 1
a883 1
int
d900 1
a900 1
		return (1);
d903 2
a904 2
		prefixlen(plen);
		return (0);
d907 1
d917 1
d920 3
a922 1
	int afamily, bits;
a928 1

d949 1
d952 2
a953 2
		errx(1, "internal error");
		/* NOTREACHED */
d956 1
a956 2
	su->sa.sa_family = afamily;

d961 1
a961 1
			getaddr(RTA_NETMASK, s, NULL);
a968 1

d970 1
d981 13
a993 2
			if (getaddrinfo(s, "0", &hints, &res) != 0)
				errx(1, "%s: bad value", s);
a994 4
		if (sizeof(su->sin6) != res->ai_addrlen)
			errx(1, "%s: bad value", s);
		if (res->ai_next)
			errx(1, "%s: resolved to multiple values", s);
d997 1
d1005 1
d1013 14
d1041 12
d1057 4
d1067 17
a1083 20
		if (hpp != NULL)
			*hpp = NULL;
		if (which == RTA_DST && !forcehost) {
			bits = inet_net_pton(AF_INET, s, &su->sin.sin_addr,
			    sizeof(su->sin.sin_addr));
			if (bits == 32)
				return (1);
			if (bits >= 0) {
				inet_makenetandmask(ntohl(
				    su->sin.sin_addr.s_addr),
				    &su->sin, bits);
				return (0);
			}
			np = getnetbyname(s);
			if (np != NULL && np->n_net != 0) {
				inet_makenetandmask(np->n_net, &su->sin, 0);
				return (0);
			}
			if (forcenet)
				errx(1, "%s: not a network", s);
d1085 6
a1090 7
		if (inet_pton(AF_INET, s, &su->sin.sin_addr) == 1)
			return (1);
		hp = gethostbyname(s);
		if (hp != NULL) {
			if (hpp != NULL)
				*hpp = hp;
			su->sin.sin_addr = *(struct in_addr *)hp->h_addr;
d1092 3
a1095 6
		errx(1, "%s: bad address", s);
		/* NOTREACHED */

	default:
		errx(1, "%d: bad address family", afamily);
		/* NOTREACHED */
d1097 17
d1126 1
d1130 1
d1132 3
a1134 2
		errx(1, "prefixlen is not supported with af %d", af);
		/* NOTREACHED */
d1138 4
a1141 2
	if (len < -1 || len > max)
		errx(1, "%s: bad value", s);
d1152 1
d1164 1
d1169 107
d1291 1
a1291 1
		err(1, "route-sysctl-estimate");
d1294 1
a1294 1
			err(1, "malloc");
d1296 1
a1296 1
			err(1, "actual retrieval of interface table");
a1310 1
	time_t now;
d1317 3
a1319 6
	for (;;) {
		if ((n = read(s, msg, sizeof(msg))) == -1) {
			if (errno == EINTR)
				continue;
			err(1, "read");
		}
d1321 1
a1321 1
		printf("got message of size %d on %s", n, ctime(&now));
d1327 2
a1328 2
	struct rt_msghdr	m_rtm;
	char			m_space[512];
d1332 1
a1332 1
rtmsg(int cmd, int flags, int fmask)
d1335 1
d1339 4
a1342 7
#define NEXTADDR(w, u)				\
	if (rtm_addrs & (w)) {			\
		l = ROUNDUP(u.sa.sa_len);	\
		memcpy(cp, &(u), l);		\
		cp += l;			\
		if (verbose)			\
			sodump(&(u), #u);	\
a1362 1
	rtm.rtm_fmask = fmask;
d1370 1
a1370 1
		mask_addr(&so_dst, &so_mask, RTA_DST);
a1376 1
	NEXTADDR(RTA_LABEL, so_label);
d1382 1
a1382 1
	if (write(s, &m_rtmsg, l) != l) {
d1384 1
a1384 1
			warn("writing to routing socket");
d1389 1
a1389 1
			l = read(s, &m_rtmsg, sizeof(m_rtmsg));
d1391 4
a1394 2
		if (l == -1)
			warn("read from routing socket");
d1403 1
a1403 1
mask_addr(union sockunion *addr, union sockunion *mask, int which)
d1405 2
a1406 2
	int olen = mask->sa.sa_len;
	char *cp1 = olen + (char *)mask, *cp2;
d1408 3
a1410 3
	for (mask->sa.sa_len = 0; cp1 > (char *)mask; )
		if (*--cp1 != '\0') {
			mask->sa.sa_len = 1 + cp1 - (char *)mask;
d1413 1
a1413 1
	if ((rtm_addrs & which) == 0)
d1415 2
a1416 1
	switch (addr->sa.sa_family) {
d1419 1
d1421 2
d1425 4
d1430 2
a1431 2
	cp1 = mask->sa.sa_len + 1 + (char *)addr;
	cp2 = addr->sa.sa_len + 1 + (char *)addr;
d1433 3
a1435 3
		*--cp2 = '\0';
	cp2 = mask->sa.sa_len + 1 + (char *)mask;
	while (cp1 > addr->sa.sa_data)
d1437 5
d1461 1
a1461 1
	NULL
d1467 1
a1467 2
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING"
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED";
d1469 1
a1469 2
"\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5PTP\6NOTRAILERS\7RUNNING\010NOARP\011PPROMISC"
"\012ALLMULTI\013OACTIVE\014SIMPLEX\015LINK0\016LINK1\017LINK2\020MULTICAST";
d1471 1
a1471 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\13LABEL";
a1479 1
	char ifname[IF_NAMESIZE];
d1484 1
a1484 1
		warnx("routing message version %d not understood",
d1488 1
a1488 1
	printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
a1492 2
		if (!nflag && if_indextoname(ifm->ifm_index, ifname) != NULL)
			printf("name: %s, ", ifname);
d1501 1
a1501 1
		printf("link: %s, flags:", state);
d1508 1
a1508 1
		printf("metric %d, flags:", ifam->ifam_metric);
d1514 1
a1514 1
		printf("if# %d, name %s, what: ",
d1530 2
a1531 2
		printf("pid: %ld, seq %d, errno %d, flags:",
		    (long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
d1540 1
a1540 1
	struct sockaddr *dst = NULL, *gate = NULL, *mask = NULL, *ifa = NULL;
a1541 1
	struct sockaddr_rtlabel *sa_rl = NULL;
d1546 1
a1546 1
	printf("   route to: %s\n", routename(&so_dst.sa));
d1548 2
a1549 1
		warnx("routing message version %d not understood",
d1553 3
a1555 2
	if (rtm->rtm_msglen > msglen)
		warnx("message length mismatch, in packet %d, returned %d",
d1557 3
a1559 2
	if (rtm->rtm_errno) {
		warnx("RTM_GET: %s (errno %d)",
a1577 3
				case RTA_IFA:
					ifa = sa;
					break;
a1582 3
				case RTA_LABEL:
					sa_rl = (struct sockaddr_rtlabel *)sa;
					break;
d1589 1
a1589 1
		printf("destination: %s\n", routename(dst));
d1594 1
a1594 1
		printf("       mask: %s\n", routename(mask));
d1598 1
a1598 1
		printf("    gateway: %s\n", routename(gate));
d1600 1
a1600 1
		printf("  interface: %.*s\n",
d1602 1
a1602 3
	if (ifa)
		printf(" if address: %s\n", routename(ifa));
	printf("      flags: ");
a1603 3
	printf("\n");
	if (sa_rl != NULL)
		printf("      label: %s\n", sa_rl->sr_label);
d1608 1
a1608 1
	printf("%s\n", "\
d1610 7
a1616 7
	printf("%8lu%c ", rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_mtu, lock(MTU));
d1618 2
a1619 2
		rtm->rtm_rmx.rmx_expire -= time(NULL);
	printf("%8ld%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
d1626 1
a1626 1
		printf("sockaddrs: ");
d1636 1
a1636 1
	printf("\nlocks: ");
d1638 1
a1638 1
	printf(" inits: ");
d1650 1
a1650 1
		printf("\nsockaddrs: ");
d1652 1
a1652 1
		putchar('\n');
d1656 1
a1656 1
				printf(" %s", routename(sa));
d1660 2
a1661 2
	putchar('\n');
	fflush(stdout);
d1665 1
a1665 1
bprintf(FILE *fp, int b, char *s)
d1678 1
a1678 1
			putc(i, fp);
d1681 1
a1681 1
				putc(i, fp);
d1687 1
a1687 1
		putc('>', fp);
d1703 4
d1709 6
a1714 1
		printf("%s: link %s; ", which, link_ntoa(&su->sdl));
d1717 2
a1718 1
		printf("%s: inet %s; ", which, inet_ntoa(su->sin.sin_addr));
d1720 1
d1722 1
a1722 4
	    {
		char ntop_buf[NI_MAXHOST];

		printf("%s: inet6 %s; ",
d1724 6
a1729 1
		    ntop_buf, sizeof(ntop_buf)));
a1730 1
	    }
d1732 2
a1733 1
		printf("%s: ipx %s; ", which, ipx_ntoa(su->sipx.sipx_addr));
d1736 1
a1736 1
	fflush(stdout);
d1765 1
a1765 1
		} else if (*addr == '\0')
a1788 12

void
getlabel(char *name)
{
	so_label.rtlabel.sr_len = sizeof(so_label.rtlabel);
	so_label.rtlabel.sr_family = AF_UNSPEC;
	if (strlcpy(so_label.rtlabel.sr_label, name,
	    sizeof(so_label.rtlabel.sr_label)) >=
	    sizeof(so_label.rtlabel.sr_label))
		errx(1, "label too long");
	rtm_addrs |= RTA_LABEL;
}
@

