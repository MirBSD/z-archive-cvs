head	1.9;
access;
symbols
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	cvs-200702170300:1.1.1.5
	OPENBSD_4_0:1.1.1.4
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.3
	cvs-200504291700:1.1.1.2
	cvs-200504170300:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2009.07.24.17.22.54;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004A69EDCB2719364C;

1.8
date	2009.07.24.17.15.16;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004A69EBB804F7D58F;

1.7
date	2007.02.17.03.23.43;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D675555105AC23;

1.6
date	2006.09.20.20.03.32;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045119E9F677AC322;

1.5
date	2006.06.30.20.58.58;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044A590916A489828;

1.4
date	2005.11.23.16.43.51;	author tg;	state Exp;
branches;
next	1.3;
commitid	560c43849c55498d;

1.3
date	2005.04.17.04.24.11;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.19.49.50;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.26.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.17.03.33.14;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.20.56.52;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2006.09.20.19.06.46;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045119150397FC669;

1.1.1.5
date	2007.02.17.03.06.16;	author tg;	state Exp;
branches;
next	;
commitid	10045D67134732A8703;


desc
@@


1.9
log
@even better: retain and accept the white space, as resolv.conf(5) says
that an ASCII space or tab is allowed as "search" separator

BTW, dhclient(8) is *not* vulnerable to CVE-2009-0692 ;) 10x OpenBSD
@
text
@/*	$OpenBSD: dhclient.c,v 1.109 2007/02/13 21:54:22 stevesk Exp $	*/

/*
 * Copyright 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.    All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 *
 * This client was substantially modified and enhanced by Elliot Poger
 * for use on Linux while he was working on the MosquitoNet project at
 * Stanford.
 *
 * The current version owes much to Elliot's Linux enhancements, but
 * was substantially reorganized and partially rewritten by Ted Lemon
 * so as to use the same networking framework that the Internet Software
 * Consortium DHCP server uses.   Much system-specific configuration code
 * was moved into a shell script so that as support for more operating
 * systems is added, it will not be necessary to port and maintain
 * system-specific configuration code to these operating systems - instead,
 * the shell script can invoke the native tools to accomplish the same
 * purpose.
 */

#include <ctype.h>
#include <poll.h>
#include <pwd.h>
#include <stdbool.h>

#include "dhcpd.h"
#include "privsep.h"

__RCSID("$MirOS: src/sbin/dhclient/dhclient.c,v 1.7 2007/02/17 03:23:43 tg Exp $");

#define	CLIENT_PATH "PATH=/usr/bin:/usr/sbin:/bin:/sbin"

time_t cur_time;
time_t default_lease_time = 43200; /* 12 hours... */

char *path_dhclient_conf = _PATH_DHCLIENT_CONF;
char *path_dhclient_db = NULL;

int log_perror = 1;
int privfd;
int nullfd = -1;
int no_daemon;
int unknown_ok = 1;
int routefd = -1;

struct iaddr iaddr_broadcast = { 4, { 255, 255, 255, 255 } };
struct in_addr inaddr_any;
struct sockaddr_in sockaddr_broadcast;

#define TIME_MAX 2147483647

struct interface_info *ifi;
struct client_state *client;
struct client_config *config;

int		 findproto(char *, int);
struct sockaddr	*get_ifa(char *, int);
void		 usage(void);
int		 check_option(struct client_lease *l, int option);
int		 ipv4addrs(char * buf);
int		 res_hnok(const char *dn, bool wsp_ok);
char		*option_as_string(unsigned int code, unsigned char *data, int len);
int		 fork_privchld(int, int);

#define	ROUNDUP(a) \
	    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define	ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

time_t	scripttime;

int
findproto(char *cp, int n)
{
	struct sockaddr *sa;
	int i;

	if (n == 0)
		return -1;
	for (i = 1; i; i <<= 1) {
		if (i & n) {
			sa = (struct sockaddr *)cp;
			switch (i) {
			case RTA_IFA:
			case RTA_DST:
			case RTA_GATEWAY:
			case RTA_NETMASK:
				if (sa->sa_family == AF_INET)
					return AF_INET;
				if (sa->sa_family == AF_INET6)
					return AF_INET6;
				break;
			case RTA_IFP:
				break;
			}
			ADVANCE(cp, sa);
		}
	}
	return (-1);
}

struct sockaddr *
get_ifa(char *cp, int n)
{
	struct sockaddr *sa;
	int i;

	if (n == 0)
		return (NULL);
	for (i = 1; i; i <<= 1)
		if (i & n) {
			sa = (struct sockaddr *)cp;
			if (i == RTA_IFA)
				return (sa);
			ADVANCE(cp, sa);
		}

	return (NULL);
}
struct iaddr defaddr = { 4 };

/* ARGSUSED */
void
routehandler(void)
{
	char msg[2048];
	struct rt_msghdr *rtm;
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam;
	struct if_announcemsghdr *ifan;
	struct client_lease *l;
	time_t t = time(NULL);
	struct sockaddr *sa;
	struct iaddr a;
	ssize_t n;

	do {
		n = read(routefd, &msg, sizeof(msg));
	} while (n == -1 && errno == EINTR);

	rtm = (struct rt_msghdr *)msg;
	if (n < sizeof(rtm->rtm_msglen) || n < rtm->rtm_msglen ||
	    rtm->rtm_version != RTM_VERSION)
		return;

	switch (rtm->rtm_type) {
	case RTM_NEWADDR:
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			break;
		if (findproto((char *)(ifam + 1), ifam->ifam_addrs) != AF_INET)
			break;
		sa = get_ifa((char *)(ifam + 1), ifam->ifam_addrs);
		if (sa == NULL)
			goto die;

		if ((a.len = sizeof(struct in_addr)) > sizeof(a.iabuf))
			error("king bula sez: len mismatch");
		memcpy(a.iabuf, &((struct sockaddr_in *)sa)->sin_addr, a.len);
		if (addr_eq(a, defaddr))
			break;

		for (l = client->active; l != NULL; l = l->next)
			if (addr_eq(a, l->address))
				break;

		if (l != NULL || (client->alias &&
		    addr_eq(a, client->alias->address)))
			/* new addr is the one we set */
			break;

		goto die;
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;
		if (ifam->ifam_index != ifi->index)
			break;
		if (findproto((char *)(ifam + 1), ifam->ifam_addrs) != AF_INET)
			break;
		if (scripttime == 0 || t < scripttime + 10)
			break;
		goto die;
	case RTM_IFINFO:
		ifm = (struct if_msghdr *)rtm;
		if (ifm->ifm_index != ifi->index)
			break;
		if ((rtm->rtm_flags & RTF_UP) == 0)
			goto die;
		break;
	case RTM_IFANNOUNCE:
		ifan = (struct if_announcemsghdr *)rtm;
		if (ifan->ifan_what == IFAN_DEPARTURE &&
		    ifan->ifan_index == ifi->index)
			goto die;
		break;
	default:
		break;
	}
	return;

die:
	script_init("FAIL", NULL);
	if (client->alias)
		script_write_params("alias_", client->alias);
	script_go();
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	 ch, fd, quiet = 0, i = 0, pipe_fd[2];
	extern char *__progname;
	struct passwd *pw;

	/* Initially, log errors to stderr as well as to syslogd. */
	openlog(__progname, LOG_PID | LOG_NDELAY, DHCPD_LOG_FACILITY);
	setlogmask(LOG_UPTO(LOG_INFO));

	while ((ch = getopt(argc, argv, "c:dl:qu")) != -1)
		switch (ch) {
		case 'c':
			path_dhclient_conf = optarg;
			break;
		case 'd':
			no_daemon = 1;
			break;
		case 'l':
			path_dhclient_db = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'u':
			unknown_ok = 0;
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	ifi = calloc(1, sizeof(*ifi));
	if (ifi == NULL)
		error("ifi calloc");
	client = calloc(1, sizeof(*client));
	if (client == NULL)
		error("client calloc");
	config = calloc(1, sizeof(*config));
	if (config == NULL)
		error("config calloc");

	if (strlcpy(ifi->name, argv[0], IFNAMSIZ) >= IFNAMSIZ)
		error("Interface name too long");
	if (path_dhclient_db == NULL && asprintf(&path_dhclient_db, "%s.%s",
	    _PATH_DHCLIENT_DB, ifi->name) == -1)
		error("asprintf");

	if (quiet)
		log_perror = 0;

	tzset();
	time(&cur_time);

	memset(&sockaddr_broadcast, 0, sizeof(sockaddr_broadcast));
	sockaddr_broadcast.sin_family = AF_INET;
	sockaddr_broadcast.sin_port = htons(REMOTE_PORT);
	sockaddr_broadcast.sin_addr.s_addr = INADDR_BROADCAST;
	sockaddr_broadcast.sin_len = sizeof(sockaddr_broadcast);
	inaddr_any.s_addr = INADDR_ANY;

	read_client_conf();

	if (!interface_link_status(ifi->name)) {
		int linkstat = interface_link_forceup(ifi->name);

		fprintf(stderr, "%s: no link ...", ifi->name);
		if (config->link_timeout == 0) {
			fprintf(stderr, " giving up\n");
			if (linkstat == 0)
				interface_link_forcedown(ifi->name);
			exit(1);
		}
		fflush(stderr);
		sleep(1);
		while (!interface_link_status(ifi->name)) {
			fprintf(stderr, ".");
			fflush(stderr);
			if (++i > config->link_timeout) {
				fprintf(stderr, " giving up\n");
				if (linkstat == 0)
					interface_link_forcedown(ifi->name);
				exit(1);
			}
			sleep(1);
		}
		fprintf(stderr, " got link\n");
	}

	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
		error("cannot open %s: %m", _PATH_DEVNULL);

	if ((pw = getpwnam("_dhcp")) == NULL) {
		warning("no such user: _dhcp, falling back to \"nobody\"");
		if ((pw = getpwnam("nobody")) == NULL)
			error("no such user: nobody");
	}

	if (pipe(pipe_fd) == -1)
		error("pipe");

	fork_privchld(pipe_fd[0], pipe_fd[1]);

	close(pipe_fd[0]);
	privfd = pipe_fd[1];

	if ((fd = open(path_dhclient_db, O_RDONLY|O_EXLOCK|O_CREAT, 0)) == -1)
		error("can't open and lock %s: %m", path_dhclient_db);
	read_client_leases();
	rewrite_client_leases();
	close(fd);

	priv_script_init("PREINIT", NULL);
	if (client->alias)
		priv_script_write_params("alias_", client->alias);
	priv_script_go();

	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) == -1)
		error("socket(PF_ROUTE, SOCK_RAW): %m");

	/* set up the interface */
	discover_interface();

	if (chroot(_PATH_VAREMPTY) == -1)
		error("chroot");
	if (chdir("/") == -1)
		error("chdir(\"/\")");

	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
		error("setresgid");
	if (setgroups(1, &pw->pw_gid) == -1)
		error("setgroups");
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
		error("setresuid");

	endpwent();

	setproctitle("%s", ifi->name);

	client->state = S_INIT;
	state_reboot();

	dispatch();

	/* not reached */
	return (0);
}

void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dqu] ", __progname);
	fprintf(stderr, "[-c conffile] [-l leasefile] interface\n");
	exit(1);
}

/*
 * Individual States:
 *
 * Each routine is called from the dhclient_state_machine() in one of
 * these conditions:
 * -> entering INIT state
 * -> recvpacket_flag == 0: timeout in this state
 * -> otherwise: received a packet in this state
 *
 * Return conditions as handled by dhclient_state_machine():
 * Returns 1, sendpacket_flag = 1: send packet, reset timer.
 * Returns 1, sendpacket_flag = 0: just reset the timer (wait for a milestone).
 * Returns 0: finish the nap which was interrupted for no good reason.
 *
 * Several per-interface variables are used to keep track of the process:
 *   active_lease: the lease that is being used on the interface
 *                 (null pointer if not configured yet).
 *   offered_leases: leases corresponding to DHCPOFFER messages that have
 *                   been sent to us by DHCP servers.
 *   acked_leases: leases corresponding to DHCPACK messages that have been
 *                 sent to us by DHCP servers.
 *   sendpacket: DHCP packet we're trying to send.
 *   destination: IP address to send sendpacket to
 * In addition, there are several relevant per-lease variables.
 *   T1_expiry, T2_expiry, lease_expiry: lease milestones
 * In the active lease, these control the process of renewing the lease;
 * In leases on the acked_leases list, this simply determines when we
 * can no longer legitimately use the lease.
 */
void
state_reboot(void)
{
	/* If we don't remember an active lease, go straight to INIT. */
	if (!client->active || client->active->is_bootp) {
		state_init();
		return;
	}

	/* We are in the rebooting state. */
	client->state = S_REBOOTING;

	/* make_request doesn't initialize xid because it normally comes
	   from the DHCPDISCOVER, but we haven't sent a DHCPDISCOVER,
	   so pick an xid now. */
	client->xid = arc4random();

	/* Make a DHCPREQUEST packet, and set appropriate per-interface
	   flags. */
	make_request(client->active);
	client->destination = iaddr_broadcast;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;

	/* Zap the medium list... */
	client->medium = NULL;

	/* Send out the first DHCPREQUEST packet. */
	send_request();
}

/*
 * Called when a lease has completely expired and we've
 * been unable to renew it.
 */
void
state_init(void)
{
	/* Make a DHCPDISCOVER packet, and set appropriate per-interface
	   flags. */
	make_discover(client->active);
	client->xid = client->packet.xid;
	client->destination = iaddr_broadcast;
	client->state = S_SELECTING;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;

	/* Add an immediate timeout to cause the first DHCPDISCOVER packet
	   to go out. */
	send_discover();
}

/*
 * state_selecting is called when one or more DHCPOFFER packets
 * have been received and a configurable period of time has passed.
 */
void
state_selecting(void)
{
	struct client_lease *lp, *next, *picked;

	/* Cancel state_selecting and send_discover timeouts, since either
	   one could have got us here. */
	cancel_timeout(state_selecting);
	cancel_timeout(send_discover);

	/* We have received one or more DHCPOFFER packets.   Currently,
	   the only criterion by which we judge leases is whether or
	   not we get a response when we arp for them. */
	picked = NULL;
	for (lp = client->offered_leases; lp; lp = next) {
		next = lp->next;

		/* Check to see if we got an ARPREPLY for the address
		   in this particular lease. */
		if (!picked) {
			script_init("ARPCHECK", lp->medium);
			script_write_params("check_", lp);

			/* If the ARPCHECK code detects another
			   machine using the offered address, it exits
			   nonzero.  We need to send a DHCPDECLINE and
			   toss the lease. */
			if (script_go()) {
				make_decline(lp);
				send_decline();
				goto freeit;
			}
			picked = lp;
			picked->next = NULL;
		} else {
freeit:
			free_client_lease(lp);
		}
	}
	client->offered_leases = NULL;

	/* If we just tossed all the leases we were offered, go back
	   to square one. */
	if (!picked) {
		client->state = S_INIT;
		state_init();
		return;
	}

	/* If it was a BOOTREPLY, we can just take the address right now. */
	if (!picked->options[DHO_DHCP_MESSAGE_TYPE].len) {
		client->new = picked;

		/* Make up some lease expiry times
		   XXX these should be configurable. */
		client->new->expiry = cur_time + 12000;
		client->new->renewal += cur_time + 8000;
		client->new->rebind += cur_time + 10000;

		client->state = S_REQUESTING;

		/* Bind to the address we received. */
		bind_lease();
		return;
	}

	/* Go to the REQUESTING state. */
	client->destination = iaddr_broadcast;
	client->state = S_REQUESTING;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;

	/* Make a DHCPREQUEST packet from the lease we picked. */
	make_request(picked);
	client->xid = client->packet.xid;

	/* Toss the lease we picked - we'll get it back in a DHCPACK. */
	free_client_lease(picked);

	/* Add an immediate timeout to send the first DHCPREQUEST packet. */
	send_request();
}

/*
 * state_requesting is called when we receive a DHCPACK message after
 * having sent out one or more DHCPREQUEST packets.
 */
void
dhcpack(struct iaddr client_addr, struct option_data *options)
{
	struct client_lease *lease;

	if (client->xid != client->packet.xid)
		return;

	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING)
		return;

	note("DHCPACK from %s", piaddr(client_addr));

	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("packet_to_lease failed.");
		return;
	}

	client->new = lease;

	/* Stop resending DHCPREQUEST. */
	cancel_timeout(send_request);

	/* Figure out the lease time. */
	if (client->new->options[DHO_DHCP_LEASE_TIME].data)
		client->new->expiry =
		    getULong(client->new->options[DHO_DHCP_LEASE_TIME].data);
	else
		client->new->expiry = default_lease_time;
	/* A number that looks negative here is really just very large,
	   because the lease expiry offset is unsigned. */
	if (client->new->expiry < 0)
		client->new->expiry = TIME_MAX;
	/* XXX should be fixed by resetting the client state */
	if (client->new->expiry < 60)
		client->new->expiry = 60;

	/* Take the server-provided renewal time if there is one;
	   otherwise figure it out according to the spec. */
	if (client->new->options[DHO_DHCP_RENEWAL_TIME].len)
		client->new->renewal =
		    getULong(client->new->options[DHO_DHCP_RENEWAL_TIME].data);
	else
		client->new->renewal = client->new->expiry / 2;

	/* Same deal with the rebind time. */
	if (client->new->options[DHO_DHCP_REBINDING_TIME].len)
		client->new->rebind =
		    getULong(client->new->options[DHO_DHCP_REBINDING_TIME].data);
	else
		client->new->rebind = client->new->renewal +
		    client->new->renewal / 2 + client->new->renewal / 4;

	client->new->expiry += cur_time;
	/* Lease lengths can never be negative. */
	if (client->new->expiry < cur_time)
		client->new->expiry = TIME_MAX;
	client->new->renewal += cur_time;
	if (client->new->renewal < cur_time)
		client->new->renewal = TIME_MAX;
	client->new->rebind += cur_time;
	if (client->new->rebind < cur_time)
		client->new->rebind = TIME_MAX;

	bind_lease();
}

void
bind_lease(void)
{
	/* Remember the medium. */
	client->new->medium = client->medium;

	/* Write out the new lease. */
	write_client_lease(client->new, 0);

	/* Run the client script with the new parameters. */
	script_init((client->state == S_REQUESTING ? "BOUND" :
	    (client->state == S_RENEWING ? "RENEW" :
	    (client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    client->new->medium);
	if (client->active && client->state != S_REBOOTING)
		script_write_params("old_", client->active);
	script_write_params("new_", client->new);
	if (client->alias)
		script_write_params("alias_", client->alias);
	script_go();

	/* Replace the old active lease with the new one. */
	if (client->active)
		free_client_lease(client->active);
	client->active = client->new;
	client->new = NULL;

	/* Set up a timeout to start the renewal process. */
	add_timeout(client->active->renewal, state_bound);

	note("bound to %s -- renewal in %ld seconds.",
	    piaddr(client->active->address),
	    (long)(client->active->renewal - cur_time));
	client->state = S_BOUND;
	reinitialize_interface();
	go_daemon();
}

/*
 * state_bound is called when we've successfully bound to a particular
 * lease, but the renewal time on that lease has expired.   We are
 * expected to unicast a DHCPREQUEST to the server that gave us our
 * original lease.
 */
void
state_bound(void)
{
	/* T1 has expired. */
	make_request(client->active);
	client->xid = client->packet.xid;

	if (client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(client->destination.iabuf,
		    client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
		    4);
		client->destination.len = 4;
	} else
		client->destination = iaddr_broadcast;

	client->first_sending = cur_time;
	client->interval = config->initial_interval;
	client->state = S_RENEWING;

	/* Send the first packet immediately. */
	send_request();
}

void
dhcpoffer(struct iaddr client_addr, struct option_data *options)
{
	struct client_lease *lease, *lp;
	int i;
	int arp_timeout_needed, stop_selecting;
	char *name = options[DHO_DHCP_MESSAGE_TYPE].len ? "DHCPOFFER" :
	    "BOOTREPLY";

	if (client->xid != client->packet.xid)
		return;

	if (client->state != S_SELECTING)
		return;

	note("%s from %s", name, piaddr(client_addr));

	/* If this lease doesn't supply the minimum required parameters,
	   blow it off. */
	for (i = 0; config->required_options[i]; i++) {
		if (!options[config->required_options[i]].len) {
			note("%s isn't satisfactory.", name);
			return;
		}
	}

	/* If we've already seen this lease, don't record it again. */
	for (lease = client->offered_leases;
	    lease; lease = lease->next) {
		if (lease->address.len == sizeof(client->packet.yiaddr) &&
		    !memcmp(lease->address.iabuf,
		    &client->packet.yiaddr, lease->address.len)) {
			debug("%s already seen.", name);
			return;
		}
	}

	lease = packet_to_lease(client_addr, options);
	if (!lease) {
		note("packet_to_lease failed.");
		return;
	}

	/* If this lease was acquired through a BOOTREPLY, record that
	   fact. */
	if (!options[DHO_DHCP_MESSAGE_TYPE].len)
		lease->is_bootp = 1;

	/* Record the medium under which this lease was offered. */
	lease->medium = client->medium;

	/* Send out an ARP Request for the offered IP address. */
	script_init("ARPSEND", lease->medium);
	script_write_params("check_", lease);
	/* If the script can't send an ARP request without waiting,
	   we'll be waiting when we do the ARPCHECK, so don't wait now. */
	if (script_go())
		arp_timeout_needed = 0;
	else
		arp_timeout_needed = 2;

	/* Figure out when we're supposed to stop selecting. */
	stop_selecting = client->first_sending + config->select_interval;

	/* If this is the lease we asked for, put it at the head of the
	   list, and don't mess with the arp request timeout. */
	if (lease->address.len == client->requested_address.len &&
	    !memcmp(lease->address.iabuf,
	    client->requested_address.iabuf,
	    client->requested_address.len)) {
		lease->next = client->offered_leases;
		client->offered_leases = lease;
	} else {
		/* If we already have an offer, and arping for this
		   offer would take us past the selection timeout,
		   then don't extend the timeout - just hope for the
		   best. */
		if (client->offered_leases &&
		    (cur_time + arp_timeout_needed) > stop_selecting)
			arp_timeout_needed = 0;

		/* Put the lease at the end of the list. */
		lease->next = NULL;
		if (!client->offered_leases)
			client->offered_leases = lease;
		else {
			for (lp = client->offered_leases; lp->next;
			    lp = lp->next)
				;	/* nothing */
			lp->next = lease;
		}
	}

	/* If we're supposed to stop selecting before we've had time
	   to wait for the ARPREPLY, add some delay to wait for
	   the ARPREPLY. */
	if (stop_selecting - cur_time < arp_timeout_needed)
		stop_selecting = cur_time + arp_timeout_needed;

	/* If the selecting interval has expired, go immediately to
	   state_selecting().  Otherwise, time out into
	   state_selecting at the select interval. */
	if (stop_selecting <= 0)
		state_selecting();
	else {
		add_timeout(stop_selecting, state_selecting);
		cancel_timeout(send_discover);
	}
}

/*
 * Allocate a client_lease structure and initialize it from the
 * parameters in the specified packet.
 */
struct client_lease *
packet_to_lease(struct iaddr client_addr, struct option_data *options)
{
	struct client_lease *lease;
	int i;

	lease = malloc(sizeof(struct client_lease));

	if (!lease) {
		warning("dhcpoffer: no memory to record lease.");
		return (NULL);
	}

	memset(lease, 0, sizeof(*lease));

	/* Copy the lease options. */
	for (i = 0; i < 256; i++) {
		if (options[i].len) {
			lease->options[i] = options[i];
			options[i].data = NULL;
			options[i].len = 0;
			if (!check_option(lease, i)) {
				warning("Invalid lease option - ignoring offer");
				free_client_lease(lease);
				return (NULL);
			}
		}
	}

	lease->address.len = sizeof(client->packet.yiaddr);
	memcpy(lease->address.iabuf, &client->packet.yiaddr,
	    lease->address.len);

	/* If the server name was filled out, copy it. */
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
	    client->packet.sname[0]) {
		lease->server_name = malloc(DHCP_SNAME_LEN + 1);
		if (!lease->server_name) {
			warning("dhcpoffer: no memory for server name.");
			free_client_lease(lease);
			return (NULL);
		}
		memcpy(lease->server_name, client->packet.sname,
		    DHCP_SNAME_LEN);
		lease->server_name[DHCP_SNAME_LEN] = '\0';
		if (!res_hnok(lease->server_name, false)) {
			warning("Bogus server name %s", lease->server_name);
			free(lease->server_name);
			lease->server_name = NULL;
		}
	}

	/* Ditto for the filename. */
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
	    client->packet.file[0]) {
		/* Don't count on the NUL terminator. */
		lease->filename = malloc(DHCP_FILE_LEN + 1);
		if (!lease->filename) {
			warning("dhcpoffer: no memory for filename.");
			free_client_lease(lease);
			return (NULL);
		}
		memcpy(lease->filename, client->packet.file, DHCP_FILE_LEN);
		lease->filename[DHCP_FILE_LEN] = '\0';
	}
	return lease;
}

void
dhcpnak(struct iaddr client_addr, struct option_data *options)
{
	if (client->xid != client->packet.xid)
		return;

	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING)
		return;

	note("DHCPNAK from %s", piaddr(client_addr));

	if (!client->active) {
		note("DHCPNAK with no active lease.");
		return;
	}

	free_client_lease(client->active);
	client->active = NULL;

	/* Stop sending DHCPREQUEST packets... */
	cancel_timeout(send_request);

	client->state = S_INIT;
	state_init();
}

/*
 * Send out a DHCPDISCOVER packet, and set a timeout to send out another
 * one after the right interval has expired.  If we don't get an offer by
 * the time we reach the panic interval, call the panic function.
 */
void
send_discover(void)
{
	int interval, increase = 1;

	/* Figure out how long it's been since we started transmitting. */
	interval = cur_time - client->first_sending;

	/* If we're past the panic timeout, call the script and tell it
	   we haven't found anything for this interface yet. */
	if (interval > config->timeout) {
		state_panic();
		return;
	}

	/* If we're selecting media, try the whole list before doing
	   the exponential backoff, but if we've already received an
	   offer, stop looping, because we obviously have it right. */
	if (!client->offered_leases && config->media) {
		int fail = 0;
again:
		if (client->medium) {
			client->medium = client->medium->next;
			increase = 0;
		}
		if (!client->medium) {
			if (fail)
				error("No valid media types for %s!", ifi->name);
			client->medium = config->media;
			increase = 1;
		}

		note("Trying medium \"%s\" %d", client->medium->string,
		    increase);
		script_init("MEDIUM", client->medium);
		if (script_go())
			goto again;
	}

	/*
	 * If we're supposed to increase the interval, do so.  If it's
	 * currently zero (i.e., we haven't sent any packets yet), set
	 * it to initial_interval; otherwise, add to it a random
	 * number between zero and two times itself.  On average, this
	 * means that it will double with every transmission.
	 */
	if (increase) {
		if (!client->interval)
			client->interval = config->initial_interval;
		else {
			client->interval += (arc4random() >> 2) %
			    (2 * client->interval);
		}

		/* Don't backoff past cutoff. */
		if (client->interval > config->backoff_cutoff)
			client->interval = ((config->backoff_cutoff / 2)
				 + ((arc4random() >> 2) %
				    config->backoff_cutoff));
	} else if (!client->interval)
		client->interval = config->initial_interval;

	/* If the backoff would take us to the panic timeout, just use that
	   as the interval. */
	if (cur_time + client->interval >
	    client->first_sending + config->timeout)
		client->interval = (client->first_sending +
			 config->timeout) - cur_time + 1;

	/* Record the number of seconds since we started sending. */
	if (interval < 65536)
		client->packet.secs = htons(interval);
	else
		client->packet.secs = htons(65535);
	client->secs = client->packet.secs;

	note("DHCPDISCOVER on %s to %s port %d interval %ld",
	    ifi->name, inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port), (long)client->interval);

	/* Send out a packet. */
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);

	add_timeout(cur_time + client->interval, send_discover);
}

/*
 * state_panic gets called if we haven't received any offers in a preset
 * amount of time.   When this happens, we try to use existing leases
 * that haven't yet expired, and failing that, we call the client script
 * and hope it can do something.
 */
void
state_panic(void)
{
	struct client_lease *loop = client->active;
	struct client_lease *lp;

	note("No DHCPOFFERS received.");

	/* We may not have an active lease, but we may have some
	   predefined leases that we can try. */
	if (!client->active && client->leases)
		goto activate_next;

	/* Run through the list of leases and see if one can be used. */
	while (client->active) {
		if (client->active->expiry > cur_time) {
			note("Trying recorded lease %s",
			    piaddr(client->active->address));
			/* Run the client script with the existing
			   parameters. */
			script_init("TIMEOUT",
			    client->active->medium);
			script_write_params("new_", client->active);
			if (client->alias)
				script_write_params("alias_",
				    client->alias);

			/* If the old lease is still good and doesn't
			   yet need renewal, go into BOUND state and
			   timeout at the renewal time. */
			if (!script_go()) {
				if (cur_time <
				    client->active->renewal) {
					client->state = S_BOUND;
					note("bound: renewal in %ld seconds.",
					    (long)(client->active->renewal -
					    cur_time));
					add_timeout(client->active->renewal,
					    state_bound);
				} else {
					client->state = S_BOUND;
					note("bound: immediate renewal.");
					state_bound();
				}
				reinitialize_interface();
				go_daemon();
				return;
			}
		}

		/* If there are no other leases, give up. */
		if (!client->leases) {
			client->leases = client->active;
			client->active = NULL;
			break;
		}

activate_next:
		/* Otherwise, put the active lease at the end of the
		   lease list, and try another lease.. */
		for (lp = client->leases; lp->next; lp = lp->next)
			;
		lp->next = client->active;
		if (lp->next)
			lp->next->next = NULL;
		client->active = client->leases;
		client->leases = client->leases->next;

		/* If we already tried this lease, we've exhausted the
		   set of leases, so we might as well give up for
		   now. */
		if (client->active == loop)
			break;
		else if (!loop)
			loop = client->active;
	}

	/* No leases were available, or what was available didn't work, so
	   tell the shell script that we failed to allocate an address,
	   and try again later. */
	note("No working leases in persistent database - sleeping.");
	script_init("FAIL", NULL);
	if (client->alias)
		script_write_params("alias_", client->alias);
	script_go();
	client->state = S_INIT;
	add_timeout(cur_time + config->retry_interval, state_init);
	go_daemon();
}

void
send_request(void)
{
	struct sockaddr_in destination;
	struct in_addr from;
	int interval;

	/* Figure out how long it's been since we started transmitting. */
	interval = cur_time - client->first_sending;

	/* If we're in the INIT-REBOOT or REQUESTING state and we're
	   past the reboot timeout, go to INIT and see if we can
	   DISCOVER an address... */
	/* XXX In the INIT-REBOOT state, if we don't get an ACK, it
	   means either that we're on a network with no DHCP server,
	   or that our server is down.  In the latter case, assuming
	   that there is a backup DHCP server, DHCPDISCOVER will get
	   us a new address, but we could also have successfully
	   reused our old address.  In the former case, we're hosed
	   anyway.  This is not a win-prone situation. */
	if ((client->state == S_REBOOTING ||
	    client->state == S_REQUESTING) &&
	    interval > config->reboot_timeout) {
cancel:
		client->state = S_INIT;
		cancel_timeout(send_request);
		state_init();
		return;
	}

	/* If we're in the reboot state, make sure the media is set up
	   correctly. */
	if (client->state == S_REBOOTING &&
	    !client->medium &&
	    client->active->medium) {
		script_init("MEDIUM", client->active->medium);

		/* If the medium we chose won't fly, go to INIT state. */
		if (script_go())
			goto cancel;

		/* Record the medium. */
		client->medium = client->active->medium;
	}

	/* If the lease has expired, relinquish the address and go back
	   to the INIT state. */
	if (client->state != S_REQUESTING &&
	    cur_time > client->active->expiry) {
		/* Run the client script with the new parameters. */
		script_init("EXPIRE", NULL);
		script_write_params("old_", client->active);
		if (client->alias)
			script_write_params("alias_", client->alias);
		script_go();

		/* Now do a preinit on the interface so that we can
		   discover a new address. */
		script_init("PREINIT", NULL);
		if (client->alias)
			script_write_params("alias_", client->alias);
		script_go();

		client->state = S_INIT;
		state_init();
		return;
	}

	/* Do the exponential backoff... */
	if (!client->interval)
		client->interval = config->initial_interval;
	else
		client->interval += ((arc4random() >> 2) %
		    (2 * client->interval));

	/* Don't backoff past cutoff. */
	if (client->interval > config->backoff_cutoff)
		client->interval = ((config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % client->interval));

	/* If the backoff would take us to the expiry time, just set the
	   timeout to the expiry time. */
	if (client->state != S_REQUESTING && cur_time + client->interval >
	    client->active->expiry)
		client->interval = client->active->expiry - cur_time + 1;

	/* If the lease T2 time has elapsed, or if we're not yet bound,
	   broadcast the DHCPREQUEST rather than unicasting. */
	memset(&destination, 0, sizeof(destination));
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING ||
	    cur_time > client->active->rebind)
		destination.sin_addr.s_addr = INADDR_BROADCAST;
	else
		memcpy(&destination.sin_addr.s_addr, client->destination.iabuf,
		    sizeof(destination.sin_addr.s_addr));
	destination.sin_port = htons(REMOTE_PORT);
	destination.sin_family = AF_INET;
	destination.sin_len = sizeof(destination);

	if (client->state != S_REQUESTING)
		memcpy(&from, client->active->address.iabuf, sizeof(from));
	else
		from.s_addr = INADDR_ANY;

	/* Record the number of seconds since we started sending. */
	if (client->state == S_REQUESTING)
		client->packet.secs = client->secs;
	else {
		if (interval < 65536)
			client->packet.secs = htons(interval);
		else
			client->packet.secs = htons(65535);
	}

	note("DHCPREQUEST on %s to %s port %d", ifi->name,
	    inet_ntoa(destination.sin_addr), ntohs(destination.sin_port));

	/* Send out a packet. */
	send_packet(from, &destination, NULL);

	add_timeout(cur_time + client->interval, send_request);
}

void
send_decline(void)
{
	note("DHCPDECLINE on %s to %s port %d", ifi->name,
	    inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port));

	/* Send out a packet. */
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);
}

void
make_discover(struct client_lease *lease)
{
	unsigned char discover = DHCPDISCOVER;
	struct option_data options[256];
	int i;

	memset(options, 0, sizeof(options));
	memset(&client->packet, 0, sizeof(client->packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPDISCOVER */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &discover;
	options[i].len = sizeof(discover);

	/* Request the options we want */
	i  = DHO_DHCP_PARAMETER_REQUEST_LIST;
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;

	/* If we had an address, try to get it again. */
	if (lease) {
		client->requested_address = lease->address;
		i = DHO_DHCP_REQUESTED_ADDRESS;
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
	} else
		client->requested_address.len = 0;

	/* Send any options requested in the config file. */
	for (i = 0; i < 256; i++)
		if (!options[i].data &&
		    config->send_options[i].data) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
		}

	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPDISCOVER packet.");
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = arc4random();
	client->packet.secs = 0; /* filled in by send_discover. */
	client->packet.flags = 0;

	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
}

void
make_request(struct client_lease * lease)
{
	unsigned char request = DHCPREQUEST;
	struct option_data options[256];
	int i;

	memset(options, 0, sizeof(options));
	memset(&client->packet, 0, sizeof(client->packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPREQUEST */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &request;
	options[i].len = sizeof(request);

	/* Request the options we want */
	i = DHO_DHCP_PARAMETER_REQUEST_LIST;
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;

	/* If we are requesting an address that hasn't yet been assigned
	   to us, use the DHCP Requested Address option. */
	if (client->state == S_REQUESTING) {
		/* Send back the server identifier... */
		i = DHO_DHCP_SERVER_IDENTIFIER;
		options[i].data = lease->options[i].data;
		options[i].len = lease->options[i].len;
	}
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING) {
		client->requested_address = lease->address;
		i = DHO_DHCP_REQUESTED_ADDRESS;
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
	} else
		client->requested_address.len = 0;

	/* Send any options requested in the config file. */
	for (i = 0; i < 256; i++)
		if (!options[i].data && config->send_options[i].data) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
		}

	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPREQUEST packet.");
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;

	/* If we own the address we're requesting, put it in ciaddr;
	   otherwise set ciaddr to zero. */
	if (client->state == S_BOUND ||
	    client->state == S_RENEWING ||
	    client->state == S_REBINDING) {
		memcpy(&client->packet.ciaddr,
		    lease->address.iabuf, lease->address.len);
	} else {
		memset(&client->packet.ciaddr, 0,
		    sizeof(client->packet.ciaddr));
	}

	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
}

void
make_decline(struct client_lease *lease)
{
	struct option_data options[256];
	unsigned char decline = DHCPDECLINE;
	int i;

	memset(options, 0, sizeof(options));
	memset(&client->packet, 0, sizeof(client->packet));

	/* Set DHCP_MESSAGE_TYPE to DHCPDECLINE */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i].data = &decline;
	options[i].len = sizeof(decline);

	/* Send back the server identifier... */
	i = DHO_DHCP_SERVER_IDENTIFIER;
	options[i].data = lease->options[i].data;
	options[i].len = lease->options[i].len;

	/* Send back the address we're declining. */
	i = DHO_DHCP_REQUESTED_ADDRESS;
	options[i].data = lease->address.iabuf;
	options[i].len = lease->address.len;

	/* Send the uid if the user supplied one. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (config->send_options[i].len) {
		options[i].data = config->send_options[i].data;
		options[i].len = config->send_options[i].len;
	}

	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPDECLINE packet.");
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;

	/* ciaddr must always be zero. */
	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
}

void
free_client_lease(struct client_lease *lease)
{
	int i;

	if (lease->server_name)
		free(lease->server_name);
	if (lease->filename)
		free(lease->filename);
	for (i = 0; i < 256; i++) {
		if (lease->options[i].len)
			free(lease->options[i].data);
	}
	free(lease);
}

FILE *leaseFile;

void
rewrite_client_leases(void)
{
	struct client_lease *lp;

	if (!leaseFile) {
		leaseFile = fopen(path_dhclient_db, "w");
		if (!leaseFile)
			error("can't create %s: %m", path_dhclient_db);
	} else {
		fflush(leaseFile);
		rewind(leaseFile);
	}

	for (lp = client->leases; lp; lp = lp->next)
		write_client_lease(lp, 1);
	if (client->active)
		write_client_lease(client->active, 1);

	fflush(leaseFile);
	ftruncate(fileno(leaseFile), ftello(leaseFile));
	fsync(fileno(leaseFile));
}

void
write_client_lease(struct client_lease *lease, int rewrite)
{
	static int leases_written;
	struct tm *t;
	int i;

	if (!rewrite) {
		if (leases_written++ > 20) {
			rewrite_client_leases();
			leases_written = 0;
		}
	}

	/* If the lease came from the config file, we don't need to stash
	   a copy in the lease database. */
	if (lease->is_static)
		return;

	if (!leaseFile) {	/* XXX */
		leaseFile = fopen(path_dhclient_db, "w");
		if (!leaseFile)
			error("can't create %s: %m", path_dhclient_db);
	}

	fprintf(leaseFile, "lease {\n");
	if (lease->is_bootp)
		fprintf(leaseFile, "  bootp;\n");
	fprintf(leaseFile, "  interface \"%s\";\n", ifi->name);
	fprintf(leaseFile, "  fixed-address %s;\n", piaddr(lease->address));
	if (lease->filename)
		fprintf(leaseFile, "  filename \"%s\";\n", lease->filename);
	if (lease->server_name)
		fprintf(leaseFile, "  server-name \"%s\";\n",
		    lease->server_name);
	if (lease->medium)
		fprintf(leaseFile, "  medium \"%s\";\n", lease->medium->string);
	for (i = 0; i < 256; i++)
		if (lease->options[i].len)
			fprintf(leaseFile, "  option %s %s;\n",
			    dhcp_options[i].name,
			    pretty_print_option(i, lease->options[i].data,
			    lease->options[i].len, 1, 1));

	t = gmtime(&lease->renewal);
	fprintf(leaseFile, "  renew %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	t = gmtime(&lease->rebind);
	fprintf(leaseFile, "  rebind %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	t = gmtime(&lease->expiry);
	fprintf(leaseFile, "  expire %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
	    t->tm_hour, t->tm_min, t->tm_sec);
	fprintf(leaseFile, "}\n");
	fflush(leaseFile);
}

void
script_init(char *reason, struct string_list *medium)
{
	size_t		 len, mediumlen = 0;
	struct imsg_hdr	 hdr;
	struct buf	*buf;

	if (medium != NULL && medium->string != NULL)
		mediumlen = strlen(medium->string);

	hdr.code = IMSG_SCRIPT_INIT;
	hdr.len = sizeof(struct imsg_hdr) +
	    sizeof(size_t) + mediumlen +
	    sizeof(size_t) + strlen(reason);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	buf_add(buf, &mediumlen, sizeof(mediumlen));
	if (mediumlen > 0)
		buf_add(buf, medium->string, mediumlen);
	len = strlen(reason);
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, reason, len);

	buf_close(privfd, buf);
}

void
priv_script_init(char *reason, char *medium)
{
	client->scriptEnvsize = 100;
	if (client->scriptEnv == NULL)
		client->scriptEnv =
		    malloc(client->scriptEnvsize * sizeof(char *));
	if (client->scriptEnv == NULL)
		error("script_init: no memory for environment");

	client->scriptEnv[0] = strdup(CLIENT_PATH);
	if (client->scriptEnv[0] == NULL)
		error("script_init: no memory for environment");

	client->scriptEnv[1] = NULL;

	script_set_env("", "interface", ifi->name);

	if (medium)
		script_set_env("", "medium", medium);

	script_set_env("", "reason", reason);
}

void
priv_script_write_params(char *prefix, struct client_lease *lease)
{
	u_int8_t dbuf[1500];
	int i, len = 0;
	char tbuf[128];

	script_set_env(prefix, "ip_address", piaddr(lease->address));

	if (lease->options[DHO_SUBNET_MASK].len &&
	    (lease->options[DHO_SUBNET_MASK].len <
	    sizeof(lease->address.iabuf))) {
		struct iaddr netmask, subnet, broadcast;

		memcpy(netmask.iabuf, lease->options[DHO_SUBNET_MASK].data,
		    lease->options[DHO_SUBNET_MASK].len);
		netmask.len = lease->options[DHO_SUBNET_MASK].len;

		subnet = subnet_number(lease->address, netmask);
		if (subnet.len) {
			script_set_env(prefix, "network_number",
			    piaddr(subnet));
			if (!lease->options[DHO_BROADCAST_ADDRESS].len) {
				broadcast = broadcast_addr(subnet, netmask);
				if (broadcast.len)
					script_set_env(prefix,
					    "broadcast_address",
					    piaddr(broadcast));
			}
		}
	}

	if (lease->filename)
		script_set_env(prefix, "filename", lease->filename);
	if (lease->server_name)
		script_set_env(prefix, "server_name",
		    lease->server_name);
	for (i = 0; i < 256; i++) {
		u_int8_t *dp = NULL;

		if (config->defaults[i].len) {
			if (lease->options[i].len) {
				switch (config->default_actions[i]) {
				case ACTION_DEFAULT:
					dp = lease->options[i].data;
					len = lease->options[i].len;
					break;
				case ACTION_SUPERSEDE:
supersede:
					dp = config->defaults[i].data;
					len = config->defaults[i].len;
					break;
				case ACTION_PREPEND:
					len = config->defaults[i].len +
					    lease->options[i].len;
					if (len > sizeof(dbuf)) {
						warning("no space to %s %s",
						    "prepend option",
						    dhcp_options[i].name);
						goto supersede;
					}
					dp = dbuf;
					memcpy(dp,
					    config->defaults[i].data,
					    config->defaults[i].len);
					memcpy(dp +
					    config->defaults[i].len,
					    lease->options[i].data,
					    lease->options[i].len);
					dp[len] = '\0';
					break;
				case ACTION_APPEND:
					len = config->defaults[i].len +
					    lease->options[i].len;
					if (len > sizeof(dbuf)) {
						warning("no space to %s %s",
						    "append option",
						    dhcp_options[i].name);
						goto supersede;
					}
					dp = dbuf;
					memcpy(dp, lease->options[i].data,
					    lease->options[i].len);
					memcpy(dp + lease->options[i].len,
					    config->defaults[i].data,
					    config->defaults[i].len);
					dp[len] = '\0';
				}
			} else {
				dp = config->defaults[i].data;
				len = config->defaults[i].len;
			}
		} else if (lease->options[i].len) {
			len = lease->options[i].len;
			dp = lease->options[i].data;
		} else {
			len = 0;
		}
		if (len) {
			char name[256];

			if (dhcp_option_ev_name(name, sizeof(name),
			    &dhcp_options[i]))
				script_set_env(prefix, name,
				    pretty_print_option(i, dp, len, 0, 0));
		}
	}
	snprintf(tbuf, sizeof(tbuf), "%d", (int)lease->expiry);
	script_set_env(prefix, "expiry", tbuf);
}

void
script_write_params(char *prefix, struct client_lease *lease)
{
	size_t		 fn_len = 0, sn_len = 0, pr_len = 0;
	struct imsg_hdr	 hdr;
	struct buf	*buf;
	int		 i;

	if (lease->filename != NULL)
		fn_len = strlen(lease->filename);
	if (lease->server_name != NULL)
		sn_len = strlen(lease->server_name);
	if (prefix != NULL)
		pr_len = strlen(prefix);

	hdr.code = IMSG_SCRIPT_WRITE_PARAMS;
	hdr.len = sizeof(hdr) + sizeof(struct client_lease) +
	    sizeof(size_t) + fn_len + sizeof(size_t) + sn_len +
	    sizeof(size_t) + pr_len;

	for (i = 0; i < 256; i++)
		hdr.len += sizeof(int) + lease->options[i].len;

	scripttime = time(NULL);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	buf_add(buf, lease, sizeof(struct client_lease));
	buf_add(buf, &fn_len, sizeof(fn_len));
	buf_add(buf, lease->filename, fn_len);
	buf_add(buf, &sn_len, sizeof(sn_len));
	buf_add(buf, lease->server_name, sn_len);
	buf_add(buf, &pr_len, sizeof(pr_len));
	buf_add(buf, prefix, pr_len);

	for (i = 0; i < 256; i++) {
		buf_add(buf, &lease->options[i].len,
		    sizeof(lease->options[i].len));
		buf_add(buf, lease->options[i].data,
		    lease->options[i].len);
	}

	buf_close(privfd, buf);
}

int
script_go(void)
{
	struct imsg_hdr	 hdr;
	struct buf	*buf;
	int		 ret;

	scripttime = time(NULL);

	hdr.code = IMSG_SCRIPT_GO;
	hdr.len = sizeof(struct imsg_hdr);

	buf = buf_open(hdr.len);

	buf_add(buf, &hdr, sizeof(hdr));
	buf_close(privfd, buf);

	bzero(&hdr, sizeof(hdr));
	buf_read(privfd, &hdr, sizeof(hdr));
	if (hdr.code != IMSG_SCRIPT_GO_RET)
		error("unexpected msg type %u", hdr.code);
	if (hdr.len != sizeof(hdr) + sizeof(int))
		error("received corrupted message");
	buf_read(privfd, &ret, sizeof(ret));

	return (ret);
}

int
priv_script_go(void)
{
	char *scriptName, *argv[2], **envp;
	int pid, wpid, wstatus;

	scripttime = time(NULL);

	scriptName = config->script_name;
	envp = client->scriptEnv;

	argv[0] = scriptName;
	argv[1] = NULL;

	pid = fork();
	if (pid < 0) {
		error("fork: %m");
		wstatus = 0;
	} else if (pid) {
		do {
			wpid = wait(&wstatus);
		} while (wpid != pid && wpid > 0);
		if (wpid < 0) {
			error("wait: %m");
			wstatus = 0;
		}
	} else {
		execve(scriptName, argv, envp);
		error("execve (%s, ...): %m", scriptName);
	}

	script_flush_env();

	return (wstatus & 0xff);
}

void
script_set_env(const char *prefix, const char *name, const char *value)
{
	int i, j, namelen;

	namelen = strlen(name);

	for (i = 0; client->scriptEnv[i]; i++)
		if (strncmp(client->scriptEnv[i], name, namelen) == 0 &&
		    client->scriptEnv[i][namelen] == '=')
			break;

	if (client->scriptEnv[i])
		/* Reuse the slot. */
		free(client->scriptEnv[i]);
	else {
		/* New variable.  Expand if necessary. */
		if (i >= client->scriptEnvsize - 1) {
			char **newscriptEnv;
			int newscriptEnvsize = client->scriptEnvsize + 50;

			newscriptEnv = realloc(client->scriptEnv,
			    newscriptEnvsize);
			if (newscriptEnv == NULL) {
				free(client->scriptEnv);
				client->scriptEnv = NULL;
				client->scriptEnvsize = 0;
				error("script_set_env: no memory for variable");
			}
			client->scriptEnv = newscriptEnv;
			client->scriptEnvsize = newscriptEnvsize;
		}
		/* need to set the NULL pointer at end of array beyond
		   the new slot. */
		client->scriptEnv[i + 1] = NULL;
	}
	/* Allocate space and format the variable in the appropriate slot. */
	client->scriptEnv[i] = malloc(strlen(prefix) + strlen(name) + 1 +
	    strlen(value) + 1);
	if (client->scriptEnv[i] == NULL)
		error("script_set_env: no memory for variable assignment");

	/* No `` or $() command substitution allowed in environment values! */
	for (j = 0; j < strlen(value); j++)
		switch (value[j]) {
		case '`':
		case '$':
			error("illegal character (%c) in value '%s'", value[j],
			    value);
			/* not reached */
		}
	snprintf(client->scriptEnv[i], strlen(prefix) + strlen(name) +
	    1 + strlen(value) + 1, "%s%s=%s", prefix, name, value);
}

void
script_flush_env(void)
{
	int i;

	for (i = 0; client->scriptEnv[i]; i++) {
		free(client->scriptEnv[i]);
		client->scriptEnv[i] = NULL;
	}
	client->scriptEnvsize = 0;
}

int
dhcp_option_ev_name(char *buf, size_t buflen, const struct option *option)
{
	int i;

	for (i = 0; option->name[i]; i++) {
		if (i + 1 == buflen)
			return 0;
		if (option->name[i] == '-')
			buf[i] = '_';
		else
			buf[i] = option->name[i];
	}

	buf[i] = 0;
	return 1;
}

void
go_daemon(void)
{
	static int state = 0;

	if (no_daemon || state)
		return;

	state = 1;

	/* Stop logging to stderr... */
	log_perror = 0;

	if (daemon(1, 0) == -1)
		error("daemon");

	/* we are chrooted, daemon(3) fails to open /dev/null */
	if (nullfd != -1) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
		close(nullfd);
		nullfd = -1;
	}
}

int
check_option(struct client_lease *l, int option)
{
	char *opbuf;
	char *sbuf;

	/* we use this, since this is what gets passed to dhclient-script */

	opbuf = pretty_print_option(option, l->options[option].data,
	    l->options[option].len, 0, 0);

	sbuf = option_as_string(option, l->options[option].data,
	    l->options[option].len);

	switch (option) {
	case DHO_SUBNET_MASK:
	case DHO_TIME_SERVERS:
	case DHO_NAME_SERVERS:
	case DHO_ROUTERS:
	case DHO_DOMAIN_NAME_SERVERS:
	case DHO_LOG_SERVERS:
	case DHO_COOKIE_SERVERS:
	case DHO_LPR_SERVERS:
	case DHO_IMPRESS_SERVERS:
	case DHO_RESOURCE_LOCATION_SERVERS:
	case DHO_SWAP_SERVER:
	case DHO_BROADCAST_ADDRESS:
	case DHO_NIS_SERVERS:
	case DHO_NTP_SERVERS:
	case DHO_NETBIOS_NAME_SERVERS:
	case DHO_NETBIOS_DD_SERVER:
	case DHO_FONT_SERVERS:
	case DHO_DHCP_SERVER_IDENTIFIER:
		if (!ipv4addrs(opbuf)) {
			warning("Invalid IP address in option: %s", opbuf);
			return (0);
		}
		return (1);
	case DHO_HOST_NAME:
	case DHO_DOMAIN_NAME:
	case DHO_NIS_DOMAIN:
		if (!res_hnok(sbuf, option == DHO_DOMAIN_NAME)) {
			warning("Bogus Host Name option %d: %s (%s)", option,
			    sbuf, opbuf);
			l->options[option].len = 0;
			free(l->options[option].data);
		}
		return (1);
	case DHO_PAD:
	case DHO_TIME_OFFSET:
	case DHO_BOOT_SIZE:
	case DHO_MERIT_DUMP:
	case DHO_ROOT_PATH:
	case DHO_EXTENSIONS_PATH:
	case DHO_IP_FORWARDING:
	case DHO_NON_LOCAL_SOURCE_ROUTING:
	case DHO_POLICY_FILTER:
	case DHO_MAX_DGRAM_REASSEMBLY:
	case DHO_DEFAULT_IP_TTL:
	case DHO_PATH_MTU_AGING_TIMEOUT:
	case DHO_PATH_MTU_PLATEAU_TABLE:
	case DHO_INTERFACE_MTU:
	case DHO_ALL_SUBNETS_LOCAL:
	case DHO_PERFORM_MASK_DISCOVERY:
	case DHO_MASK_SUPPLIER:
	case DHO_ROUTER_DISCOVERY:
	case DHO_ROUTER_SOLICITATION_ADDRESS:
	case DHO_STATIC_ROUTES:
	case DHO_TRAILER_ENCAPSULATION:
	case DHO_ARP_CACHE_TIMEOUT:
	case DHO_IEEE802_3_ENCAPSULATION:
	case DHO_DEFAULT_TCP_TTL:
	case DHO_TCP_KEEPALIVE_INTERVAL:
	case DHO_TCP_KEEPALIVE_GARBAGE:
	case DHO_VENDOR_ENCAPSULATED_OPTIONS:
	case DHO_NETBIOS_NODE_TYPE:
	case DHO_NETBIOS_SCOPE:
	case DHO_X_DISPLAY_MANAGER:
	case DHO_DHCP_REQUESTED_ADDRESS:
	case DHO_DHCP_LEASE_TIME:
	case DHO_DHCP_OPTION_OVERLOAD:
	case DHO_DHCP_MESSAGE_TYPE:
	case DHO_DHCP_PARAMETER_REQUEST_LIST:
	case DHO_DHCP_MESSAGE:
	case DHO_DHCP_MAX_MESSAGE_SIZE:
	case DHO_DHCP_RENEWAL_TIME:
	case DHO_DHCP_REBINDING_TIME:
	case DHO_DHCP_CLASS_IDENTIFIER:
	case DHO_DHCP_CLIENT_IDENTIFIER:
	case DHO_DHCP_USER_CLASS_ID:
	case DHO_END:
		return (1);
	default:
		warning("unknown dhcp option value 0x%x", option);
		return (unknown_ok);
	}
}

int
res_hnok(const char *name, bool wsp_ok)
{
	const char *dn = name;
	int pch = '.', ch = *dn++;
	bool warn_us = false, warn_sp = false;
	const char *warntext = NULL;

	while (ch != '\0') {
		int nch = *dn++;

		if (ch == ' ' || ch == '\t') {
			ch = '.';	/* reset to initial state */
			if (!warn_sp) {
				warntext = "whitespace";
				warn_sp = true;
			}
		} else if (ch == '.') {
			;
		} else if (pch == '.' || nch == '.' || nch == '\0') {
			if (!isalnum(ch))
				return (0);
		} else if (!isalnum(ch) && ch != '-' && ch != '_')
				return (0);
		else if (ch == '_' && !warn_us) {
			warn_us = true;
			warntext = "an underscore";
		}
		if (warntext) {
			warning("warning: hostname %s contains %s "
			    "which violates RFC 952", name, warntext);
			warntext = NULL;
		}
		pch = ch, ch = nch;
	}
	return (1);
}

/* Does buf consist only of dotted decimal ipv4 addrs?
 * return how many if so,
 * otherwise, return 0
 */
int
ipv4addrs(char * buf)
{
	struct in_addr jnk;
	int count = 0;

	while (inet_aton(buf, &jnk) == 1){
		count++;
		while (*buf == '.' || isdigit(*buf))
			buf++;
		if (*buf == '\0')
			return (count);
		while (*buf ==  ' ')
			buf++;
	}
	return (0);
}

char *
option_as_string(unsigned int code, unsigned char *data, int len)
{
	static char optbuf[32768]; /* XXX */
	char *op = optbuf;
	int opleft = sizeof(optbuf);
	unsigned char *dp = data;

	if (code > 255)
		error("option_as_string: bad code %d", code);

	for (; dp < data + len; dp++) {
		if (!isascii(*dp) || !isprint(*dp)) {
			if (dp + 1 != data + len || *dp != 0) {
				snprintf(op, opleft, "\\%03o", *dp);
				op += 4;
				opleft -= 4;
			}
		} else if (*dp == '"' || *dp == '\'' || *dp == '$' ||
		    *dp == '`' || *dp == '\\') {
			*op++ = '\\';
			*op++ = *dp;
			opleft -= 2;
		} else {
			*op++ = *dp;
			opleft--;
		}
	}
	if (opleft < 1)
		goto toobig;
	*op = 0;
	return optbuf;
toobig:
	warning("dhcp option too large");
	return "<error>";
}

int
fork_privchld(int fd, int fd2)
{
	struct pollfd pfd[1];
	int nfds;

	switch (fork()) {
	case -1:
		error("cannot fork");
		break;
	case 0:
		break;
	default:
		return (0);
	}

	if (chdir("/") == -1)
		error("chdir(\"/\")");

	setproctitle("%s [priv]", ifi->name);

	dup2(nullfd, STDIN_FILENO);
	dup2(nullfd, STDOUT_FILENO);
	dup2(nullfd, STDERR_FILENO);
	close(nullfd);
	close(fd2);

	for (;;) {
		pfd[0].fd = fd;
		pfd[0].events = POLLIN;
		if ((nfds = poll(pfd, 1, INFTIM)) == -1)
			if (errno != EINTR)
				error("poll error");

		if (nfds == 0 || !(pfd[0].revents & POLLIN))
			continue;

		dispatch_imsg(fd);
	}
}
@


1.8
log
@Univention Bonus: if dns-search (DHO domain-name) contains a space or tab,
cut it (and everything after) off and try if it'll validate then; if so,
still warn about being invalid but use it (the stuff before the space/tab)
@
text
@d96 1
a96 1
int		 res_hnok(const char *dn);
d876 1
a876 1
		if (!res_hnok(lease->server_name)) {
d1978 5
a1982 25
		if (!res_hnok(sbuf)) {
			bool ignoring_error = false;

			if (option == DHO_DOMAIN_NAME) {
				unsigned char *cp = l->options[option].data;

				while (cp < l->options[option].data +
				    l->options[option].len)
					if (*cp == ' ' || *cp == '\t') {
						l->options[option].len = cp -
						    l->options[option].data;
						if (l->options[option].len)
							ignoring_error = true;
						break;
					} else
						++cp;
			}

			warning("Bogus Host Name option %d: %s (%s)%s",
			    option, sbuf, opbuf,
			    ignoring_error ? ", using anyway" : "");
			if (!ignoring_error) {
				l->options[option].len = 0;
				free(l->options[option].data);
			}
d2036 1
a2036 1
res_hnok(const char *name)
d2040 2
a2041 1
	int warn = 0;
d2046 7
a2052 1
		if (ch == '.') {
d2059 8
a2066 4
		else if (ch == '_' && warn == 0) {
			warning("warning: hostname %s contains an "
			    "underscore which violates RFC 952", name);
			warn++;
@


1.7
log
@merge dhclient upgrade
@
text
@d59 1
d64 1
a64 1
__RCSID("$MirOS$");
d1979 24
a2002 4
			warning("Bogus Host Name option %d: %s (%s)", option,
			    sbuf, opbuf);
			l->options[option].len = 0;
			free(l->options[option].data);
@


1.6
log
@merge fdisk, dhcp stuff
fix fdisk units
@
text
@d1 1
a1 2
/**	$MirOS: src/sbin/dhclient/dhclient.c,v 1.5 2006/06/30 20:58:58 tg Exp $ */
/*	$OpenBSD: dhclient.c,v 1.88 2006/08/31 10:12:18 deraadt Exp $	*/
d57 2
d63 2
a66 2
__RCSID("$MirOS: src/sbin/dhclient/dhclient.c,v 1.5 2006/06/30 20:58:58 tg Exp $");

d78 1
a78 1
int routefd;
a83 6
/*
 * ASSERT_STATE() does nothing now; it used to be
 * assert (state_is == state_shouldbe).
 */
#define ASSERT_STATE(state_is, state_shouldbe) {}

d86 3
a88 1
struct interface_info	*ifi;
a91 1
void		 routehandler(struct protocol *);
d157 1
a157 1
routehandler(struct protocol *p)
a185 2
		if (ifi == NULL)
			goto die;
d196 1
a196 1
		for (l = ifi->client->active; l != NULL; l = l->next)
d200 2
a201 1
		if (l != NULL || addr_eq(a, ifi->client->alias->address))
d235 2
a236 2
	if (ifi->client->alias)
		script_write_params("alias_", ifi->client->alias);
d282 6
a287 6
	ifi->client = calloc(1, sizeof(*(ifi->client)));
	if (ifi->client == NULL)
		error("ifi->client calloc");
	ifi->client->config = calloc(1, sizeof(*(ifi->client->config)));
	if (ifi->client->config == NULL)
		error("ifi->client->config calloc");
d314 1
a314 1
		if (ifi->client->config->link_timeout == 0) {
d325 1
a325 1
			if (++i > ifi->client->config->link_timeout) {
d360 2
a361 2
	if (ifi->client->alias)
		priv_script_write_params("alias_", ifi->client->alias);
d364 2
a365 2
	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) != -1)
		add_protocol("AF_ROUTE", routefd, routehandler, ifi);
d368 1
a368 1
	discover_interfaces(ifi);
d386 2
a387 4
	ifi->client->state = S_INIT;
	state_reboot(ifi);

	bootp_packet_handler = do_packet;
d435 1
a435 1
state_reboot(void *ipp)
a436 2
	struct interface_info *ip = ipp;

d438 2
a439 2
	if (!ip->client->active || ip->client->active->is_bootp) {
		state_init(ip);
d444 1
a444 1
	ip->client->state = S_REBOOTING;
d449 1
a449 1
	ip->client->xid = arc4random();
d453 4
a456 4
	make_request(ip, ip->client->active);
	ip->client->destination = iaddr_broadcast;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d459 1
a459 1
	ip->client->medium = NULL;
d462 1
a462 1
	send_request(ip);
d470 1
a470 1
state_init(void *ipp)
a471 4
	struct interface_info *ip = ipp;

	ASSERT_STATE(state, S_INIT);

d474 6
a479 6
	make_discover(ip, ip->client->active);
	ip->client->xid = ip->client->packet.xid;
	ip->client->destination = iaddr_broadcast;
	ip->client->state = S_SELECTING;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d483 1
a483 1
	send_discover(ip);
d491 1
a491 1
state_selecting(void *ipp)
a492 1
	struct interface_info *ip = ipp;
a494 2
	ASSERT_STATE(state, S_SELECTING);

d497 2
a498 2
	cancel_timeout(state_selecting, ip);
	cancel_timeout(send_discover, ip);
d504 1
a504 1
	for (lp = ip->client->offered_leases; lp; lp = next) {
d518 2
a519 2
				make_decline(ip, lp);
				send_decline(ip);
d529 1
a529 1
	ip->client->offered_leases = NULL;
d534 2
a535 2
		ip->client->state = S_INIT;
		state_init(ip);
d541 1
a541 1
		ip->client->new = picked;
d545 3
a547 3
		ip->client->new->expiry = cur_time + 12000;
		ip->client->new->renewal += cur_time + 8000;
		ip->client->new->rebind += cur_time + 10000;
d549 1
a549 1
		ip->client->state = S_REQUESTING;
d552 1
a552 1
		bind_lease(ip);
d557 4
a560 4
	ip->client->destination = iaddr_broadcast;
	ip->client->state = S_REQUESTING;
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
d563 2
a564 2
	make_request(ip, picked);
	ip->client->xid = ip->client->packet.xid;
d570 1
a570 1
	send_request(ip);
d578 1
a578 1
dhcpack(struct packet *packet)
a579 1
	struct interface_info *ip = packet->interface;
d582 1
a582 6
	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
	    packet->raw->chaddr, packet->raw->hlen)))
d585 4
a588 4
	if (ip->client->state != S_REBOOTING &&
	    ip->client->state != S_REQUESTING &&
	    ip->client->state != S_RENEWING &&
	    ip->client->state != S_REBINDING)
d591 1
a591 1
	note("DHCPACK from %s", piaddr(packet->client_addr));
d593 1
a593 1
	lease = packet_to_lease(packet);
d599 1
a599 1
	ip->client->new = lease;
d602 1
a602 1
	cancel_timeout(send_request, ip);
d605 3
a607 3
	if (ip->client->new->options[DHO_DHCP_LEASE_TIME].data)
		ip->client->new->expiry =
		    getULong(ip->client->new->options[DHO_DHCP_LEASE_TIME].data);
d609 1
a609 1
		ip->client->new->expiry = default_lease_time;
d612 2
a613 2
	if (ip->client->new->expiry < 0)
		ip->client->new->expiry = TIME_MAX;
d615 2
a616 2
	if (ip->client->new->expiry < 60)
		ip->client->new->expiry = 60;
d620 3
a622 3
	if (ip->client->new->options[DHO_DHCP_RENEWAL_TIME].len)
		ip->client->new->renewal =
		    getULong(ip->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d624 1
a624 1
		ip->client->new->renewal = ip->client->new->expiry / 2;
d627 3
a629 3
	if (ip->client->new->options[DHO_DHCP_REBINDING_TIME].len)
		ip->client->new->rebind =
		    getULong(ip->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d631 2
a632 2
		ip->client->new->rebind = ip->client->new->renewal +
		    ip->client->new->renewal / 2 + ip->client->new->renewal / 4;
d634 1
a634 1
	ip->client->new->expiry += cur_time;
d636 8
a643 8
	if (ip->client->new->expiry < cur_time)
		ip->client->new->expiry = TIME_MAX;
	ip->client->new->renewal += cur_time;
	if (ip->client->new->renewal < cur_time)
		ip->client->new->renewal = TIME_MAX;
	ip->client->new->rebind += cur_time;
	if (ip->client->new->rebind < cur_time)
		ip->client->new->rebind = TIME_MAX;
d645 1
a645 1
	bind_lease(ip);
d649 1
a649 1
bind_lease(struct interface_info *ip)
d652 1
a652 1
	ip->client->new->medium = ip->client->medium;
d655 1
a655 1
	write_client_lease(ip, ip->client->new, 0);
d658 9
a666 9
	script_init((ip->client->state == S_REQUESTING ? "BOUND" :
	    (ip->client->state == S_RENEWING ? "RENEW" :
	    (ip->client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    ip->client->new->medium);
	if (ip->client->active && ip->client->state != S_REBOOTING)
		script_write_params("old_", ip->client->active);
	script_write_params("new_", ip->client->new);
	if (ip->client->alias)
		script_write_params("alias_", ip->client->alias);
d670 4
a673 4
	if (ip->client->active)
		free_client_lease(ip->client->active);
	ip->client->active = ip->client->new;
	ip->client->new = NULL;
d676 1
a676 1
	add_timeout(ip->client->active->renewal, state_bound, ip);
d678 5
a682 5
	note("bound to %s -- renewal in %lld seconds.",
	    piaddr(ip->client->active->address),
	    ip->client->active->renewal - (int64_t)cur_time);
	ip->client->state = S_BOUND;
	reinitialize_interfaces();
d693 1
a693 1
state_bound(void *ipp)
a694 4
	struct interface_info *ip = ipp;

	ASSERT_STATE(state, S_BOUND);

d696 2
a697 2
	make_request(ip, ip->client->active);
	ip->client->xid = ip->client->packet.xid;
d699 3
a701 3
	if (ip->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(ip->client->destination.iabuf,
		    ip->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
d703 1
a703 1
		ip->client->destination.len = 4;
d705 1
a705 1
		ip->client->destination = iaddr_broadcast;
d707 3
a709 3
	ip->client->first_sending = cur_time;
	ip->client->interval = ip->client->config->initial_interval;
	ip->client->state = S_RENEWING;
d712 1
a712 57
	send_request(ip);
}

void
bootp(struct packet *packet)
{
	struct iaddrlist *ap;

	if (packet->raw->op != BOOTREPLY)
		return;

	/* If there's a reject list, make sure this packet's sender isn't
	   on it. */
	for (ap = packet->interface->client->config->reject_list;
	    ap; ap = ap->next) {
		if (addr_eq(packet->client_addr, ap->addr)) {
			note("BOOTREPLY from %s rejected.", piaddr(ap->addr));
			return;
		}
	}
	dhcpoffer(packet);
}

void
dhcp(struct packet *packet)
{
	struct iaddrlist *ap;
	void (*handler)(struct packet *);
	char *type;

	switch (packet->packet_type) {
	case DHCPOFFER:
		handler = dhcpoffer;
		type = "DHCPOFFER";
		break;
	case DHCPNAK:
		handler = dhcpnak;
		type = "DHCPNACK";
		break;
	case DHCPACK:
		handler = dhcpack;
		type = "DHCPACK";
		break;
	default:
		return;
	}

	/* If there's a reject list, make sure this packet's sender isn't
	   on it. */
	for (ap = packet->interface->client->config->reject_list;
	    ap; ap = ap->next) {
		if (addr_eq(packet->client_addr, ap->addr)) {
			note("%s from %s rejected.", type, piaddr(ap->addr));
			return;
		}
	}
	(*handler)(packet);
d716 1
a716 1
dhcpoffer(struct packet *packet)
a717 1
	struct interface_info *ip = packet->interface;
d721 2
a722 2
	char *name = packet->options[DHO_DHCP_MESSAGE_TYPE].len ?
	    "DHCPOFFER" : "BOOTREPLY";
d724 1
a724 7
	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (ip->client->state != S_SELECTING ||
	    packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
	    packet->raw->chaddr, packet->raw->hlen)))
d727 2
a728 1
	note("%s from %s", name, piaddr(packet->client_addr));
d730 1
d734 2
a735 2
	for (i = 0; ip->client->config->required_options[i]; i++) {
		if (!packet->options[ip->client->config->required_options[i]].len) {
d742 1
a742 1
	for (lease = ip->client->offered_leases;
d744 1
a744 1
		if (lease->address.len == sizeof(packet->raw->yiaddr) &&
d746 1
a746 1
		    &packet->raw->yiaddr, lease->address.len)) {
d752 1
a752 1
	lease = packet_to_lease(packet);
d760 1
a760 1
	if (!packet->options[DHO_DHCP_MESSAGE_TYPE].len)
d764 1
a764 1
	lease->medium = ip->client->medium;
d777 1
a777 2
	stop_selecting =
	    ip->client->first_sending + ip->client->config->select_interval;
d781 1
a781 1
	if (lease->address.len == ip->client->requested_address.len &&
d783 4
a786 4
	    ip->client->requested_address.iabuf,
	    ip->client->requested_address.len)) {
		lease->next = ip->client->offered_leases;
		ip->client->offered_leases = lease;
d792 1
a792 1
		if (ip->client->offered_leases &&
d798 2
a799 2
		if (!ip->client->offered_leases)
			ip->client->offered_leases = lease;
d801 1
a801 1
			for (lp = ip->client->offered_leases; lp->next;
d818 1
a818 1
		state_selecting(ip);
d820 2
a821 2
		add_timeout(stop_selecting, state_selecting, ip);
		cancel_timeout(send_discover, ip);
d830 1
a830 1
packet_to_lease(struct packet *packet)
d846 5
a850 18
		if (packet->options[i].len) {
			lease->options[i].data =
			    malloc(packet->options[i].len + 1);
			if (!lease->options[i].data) {
				warning("dhcpoffer: no memory for option %d", i);
				free_client_lease(lease);
				return (NULL);
			} else {
				memcpy(lease->options[i].data,
				    packet->options[i].data,
				    packet->options[i].len);
				lease->options[i].len =
				    packet->options[i].len;
				lease->options[i].data[lease->options[i].len] =
				    0;
			}
			if (!check_option(lease,i)) {
				/* ignore a bogus lease offer */
d858 3
a860 2
	lease->address.len = sizeof(packet->raw->yiaddr);
	memcpy(lease->address.iabuf, &packet->raw->yiaddr, lease->address.len);
d863 3
a865 3
	if ((!packet->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
	    packet->raw->sname[0]) {
d872 3
a874 2
		memcpy(lease->server_name, packet->raw->sname, DHCP_SNAME_LEN);
		lease->server_name[DHCP_SNAME_LEN]='\0';
d883 3
a885 3
	if ((!packet->options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
	    packet->raw->file[0]) {
d893 2
a894 2
		memcpy(lease->filename, packet->raw->file, DHCP_FILE_LEN);
		lease->filename[DHCP_FILE_LEN]='\0';
d900 1
a900 1
dhcpnak(struct packet *packet)
d902 1
a902 8
	struct interface_info *ip = packet->interface;

	/* If we're not receptive to an offer right now, or if the offer
	   has an unrecognizable transaction id, then just drop it. */
	if (packet->interface->client->xid != packet->raw->xid ||
	    (packet->interface->hw_address.hlen != packet->raw->hlen) ||
	    (memcmp(packet->interface->hw_address.haddr,
	    packet->raw->chaddr, packet->raw->hlen)))
d905 4
a908 4
	if (ip->client->state != S_REBOOTING &&
	    ip->client->state != S_REQUESTING &&
	    ip->client->state != S_RENEWING &&
	    ip->client->state != S_REBINDING)
d911 1
a911 1
	note("DHCPNAK from %s", piaddr(packet->client_addr));
d913 2
a914 2
	if (!ip->client->active) {
		note("DHCPNAK with no active lease.\n");
d918 2
a919 2
	free_client_lease(ip->client->active);
	ip->client->active = NULL;
d922 1
a922 1
	cancel_timeout(send_request, ip);
d924 2
a925 2
	ip->client->state = S_INIT;
	state_init(ip);
d934 1
a934 1
send_discover(void *ipp)
a935 1
	struct interface_info *ip = ipp;
d939 1
a939 1
	interval = cur_time - ip->client->first_sending;
d943 2
a944 2
	if (interval > ip->client->config->timeout) {
		state_panic(ip);
d951 1
a951 2
	if (!ip->client->offered_leases &&
	    ip->client->config->media) {
d954 2
a955 2
		if (ip->client->medium) {
			ip->client->medium = ip->client->medium->next;
d958 1
a958 1
		if (!ip->client->medium) {
d960 2
a961 2
				error("No valid media types for %s!", ip->name);
			ip->client->medium = ip->client->config->media;
d965 1
a965 1
		note("Trying medium \"%s\" %d", ip->client->medium->string,
d967 1
a967 1
		script_init("MEDIUM", ip->client->medium);
d975 3
a977 3
	 * it to one; otherwise, add to it a random number between zero
	 * and two times itself.  On average, this means that it will
	 * double with every transmission.
d980 2
a981 3
		if (!ip->client->interval)
			ip->client->interval =
			    ip->client->config->initial_interval;
d983 2
a984 2
			ip->client->interval += (arc4random() >> 2) %
			    (2 * ip->client->interval);
d988 2
a989 4
		if (ip->client->interval >
		    ip->client->config->backoff_cutoff)
			ip->client->interval =
				((ip->client->config->backoff_cutoff / 2)
d991 3
a993 4
				    ip->client->config->backoff_cutoff));
	} else if (!ip->client->interval)
		ip->client->interval =
			ip->client->config->initial_interval;
d997 4
a1000 5
	if (cur_time + ip->client->interval >
	    ip->client->first_sending + ip->client->config->timeout)
		ip->client->interval =
			(ip->client->first_sending +
			 ip->client->config->timeout) - cur_time + 1;
d1004 1
a1004 1
		ip->client->packet.secs = htons(interval);
d1006 2
a1007 2
		ip->client->packet.secs = htons(65535);
	ip->client->secs = ip->client->packet.secs;
d1009 3
a1011 4
	note("DHCPDISCOVER on %s to %s port %d interval %lld",
	    ip->name, inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port),
	    (int64_t)(ip->client->interval));
d1014 1
a1014 2
	(void)send_packet(ip, &ip->client->packet, ip->client->packet_length,
	    inaddr_any, &sockaddr_broadcast, NULL);
d1016 1
a1016 1
	add_timeout(cur_time + ip->client->interval, send_discover, ip);
d1026 1
a1026 1
state_panic(void *ipp)
d1028 1
a1028 2
	struct interface_info *ip = ipp;
	struct client_lease *loop = ip->client->active;
d1035 1
a1035 1
	if (!ip->client->active && ip->client->leases)
d1039 2
a1040 2
	while (ip->client->active) {
		if (ip->client->active->expiry > cur_time) {
d1042 1
a1042 1
			    piaddr(ip->client->active->address));
d1046 3
a1048 3
			    ip->client->active->medium);
			script_write_params("new_", ip->client->active);
			if (ip->client->alias)
d1050 1
a1050 1
				    ip->client->alias);
d1057 7
a1063 7
				    ip->client->active->renewal) {
					ip->client->state = S_BOUND;
					note("bound: renewal in %lld seconds.",
					    ip->client->active->renewal -
					    (int64_t)cur_time);
					add_timeout(ip->client->active->renewal,
					    state_bound, ip);
d1065 1
a1065 1
					ip->client->state = S_BOUND;
d1067 1
a1067 1
					state_bound(ip);
d1069 1
a1069 1
				reinitialize_interfaces();
d1076 3
a1078 3
		if (!ip->client->leases) {
			ip->client->leases = ip->client->active;
			ip->client->active = NULL;
d1085 1
a1085 1
		for (lp = ip->client->leases; lp->next; lp = lp->next)
d1087 1
a1087 1
		lp->next = ip->client->active;
d1090 2
a1091 2
		ip->client->active = ip->client->leases;
		ip->client->leases = ip->client->leases->next;
d1096 1
a1096 1
		if (ip->client->active == loop)
d1099 1
a1099 1
			loop = ip->client->active;
d1105 1
a1105 1
	note("No working leases in persistent database - sleeping.\n");
d1107 2
a1108 2
	if (ip->client->alias)
		script_write_params("alias_", ip->client->alias);
d1110 2
a1111 3
	ip->client->state = S_INIT;
	add_timeout(cur_time + ip->client->config->retry_interval, state_init,
	    ip);
d1116 1
a1116 1
send_request(void *ipp)
a1117 1
	struct interface_info *ip = ipp;
d1123 1
a1123 1
	interval = cur_time - ip->client->first_sending;
d1135 3
a1137 3
	if ((ip->client->state == S_REBOOTING ||
	    ip->client->state == S_REQUESTING) &&
	    interval > ip->client->config->reboot_timeout) {
d1139 3
a1141 3
		ip->client->state = S_INIT;
		cancel_timeout(send_request, ip);
		state_init(ip);
d1147 4
a1150 4
	if (ip->client->state == S_REBOOTING &&
	    !ip->client->medium &&
	    ip->client->active->medium ) {
		script_init("MEDIUM", ip->client->active->medium);
d1157 1
a1157 1
		ip->client->medium = ip->client->active->medium;
d1162 2
a1163 2
	if (ip->client->state != S_REQUESTING &&
	    cur_time > ip->client->active->expiry) {
d1166 3
a1168 3
		script_write_params("old_", ip->client->active);
		if (ip->client->alias)
			script_write_params("alias_", ip->client->alias);
d1174 2
a1175 2
		if (ip->client->alias)
			script_write_params("alias_", ip->client->alias);
d1178 2
a1179 2
		ip->client->state = S_INIT;
		state_init(ip);
d1184 2
a1185 2
	if (!ip->client->interval)
		ip->client->interval = ip->client->config->initial_interval;
d1187 2
a1188 2
		ip->client->interval += ((arc4random() >> 2) %
		    (2 * ip->client->interval));
d1191 3
a1193 5
	if (ip->client->interval >
	    ip->client->config->backoff_cutoff)
		ip->client->interval =
		    ((ip->client->config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % ip->client->interval));
d1197 3
a1199 5
	if (ip->client->state != S_REQUESTING &&
	    cur_time + ip->client->interval >
	    ip->client->active->expiry)
		ip->client->interval =
		    ip->client->active->expiry - cur_time + 1;
d1204 3
a1206 3
	if (ip->client->state == S_REQUESTING ||
	    ip->client->state == S_REBOOTING ||
	    cur_time > ip->client->active->rebind)
d1209 1
a1209 2
		memcpy(&destination.sin_addr.s_addr,
		    ip->client->destination.iabuf,
d1215 2
a1216 3
	if (ip->client->state != S_REQUESTING)
		memcpy(&from, ip->client->active->address.iabuf,
		    sizeof(from));
d1221 2
a1222 2
	if (ip->client->state == S_REQUESTING)
		ip->client->packet.secs = ip->client->secs;
d1225 1
a1225 1
			ip->client->packet.secs = htons(interval);
d1227 1
a1227 1
			ip->client->packet.secs = htons(65535);
d1230 1
a1230 1
	note("DHCPREQUEST on %s to %s port %d", ip->name,
d1234 1
a1234 2
	(void) send_packet(ip, &ip->client->packet, ip->client->packet_length,
	    from, &destination, NULL);
d1236 1
a1236 1
	add_timeout(cur_time + ip->client->interval, send_request, ip);
d1240 1
a1240 1
send_decline(void *ipp)
d1242 1
a1242 3
	struct interface_info *ip = ipp;

	note("DHCPDECLINE on %s to %s port %d", ip->name,
d1247 1
a1247 2
	(void) send_packet(ip, &ip->client->packet, ip->client->packet_length,
	    inaddr_any, &sockaddr_broadcast, NULL);
d1251 1
a1251 1
make_discover(struct interface_info *ip, struct client_lease *lease)
d1258 1
a1258 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1267 2
a1268 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1272 1
a1272 1
		ip->client->requested_address = lease->address;
d1277 1
a1277 1
		ip->client->requested_address.len = 0;
d1282 3
a1284 5
		    ip->client->config->send_options[i].data) {
			options[i].data =
			    ip->client->config->send_options[i].data;
			options[i].len =
			    ip->client->config->send_options[i].len;
d1288 1
a1288 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1290 1
a1290 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1292 18
a1309 22
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = arc4random();
	ip->client->packet.secs = 0; /* filled in by send_discover. */
	ip->client->packet.flags = 0;

	memset(&(ip->client->packet.ciaddr),
	    0, sizeof(ip->client->packet.ciaddr));
	memset(&(ip->client->packet.yiaddr),
	    0, sizeof(ip->client->packet.yiaddr));
	memset(&(ip->client->packet.siaddr),
	    0, sizeof(ip->client->packet.siaddr));
	memset(&(ip->client->packet.giaddr),
	    0, sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
a1311 1

d1313 1
a1313 1
make_request(struct interface_info *ip, struct client_lease * lease)
d1320 1
a1320 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1329 2
a1330 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1334 1
a1334 1
	if (ip->client->state == S_REQUESTING) {
d1340 3
a1342 3
	if (ip->client->state == S_REQUESTING ||
	    ip->client->state == S_REBOOTING) {
		ip->client->requested_address = lease->address;
d1347 1
a1347 1
		ip->client->requested_address.len = 0;
d1351 3
a1353 6
		if (!options[i].data &&
		    ip->client->config->send_options[i].data) {
			options[i].data =
			    ip->client->config->send_options[i].data;
			options[i].len =
			    ip->client->config->send_options[i].len;
d1357 1
a1357 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1359 1
a1359 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1361 11
a1371 10
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = ip->client->xid;
	ip->client->packet.secs = 0; /* Filled in by send_request. */
d1375 4
a1378 4
	if (ip->client->state == S_BOUND ||
	    ip->client->state == S_RENEWING ||
	    ip->client->state == S_REBINDING) {
		memcpy(&ip->client->packet.ciaddr,
a1379 1
		ip->client->packet.flags = 0;
d1381 2
a1382 3
		memset(&ip->client->packet.ciaddr, 0,
		    sizeof(ip->client->packet.ciaddr));
		ip->client->packet.flags = 0;
d1385 5
a1389 8
	memset(&ip->client->packet.yiaddr, 0,
	    sizeof(ip->client->packet.yiaddr));
	memset(&ip->client->packet.siaddr, 0,
	    sizeof(ip->client->packet.siaddr));
	memset(&ip->client->packet.giaddr, 0,
	    sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
d1393 1
a1393 1
make_decline(struct interface_info *ip, struct client_lease *lease)
d1400 1
a1400 1
	memset(&ip->client->packet, 0, sizeof(ip->client->packet));
d1419 3
a1421 3
	if (ip->client->config->send_options[i].len) {
		options[i].data = ip->client->config->send_options[i].data;
		options[i].len = ip->client->config->send_options[i].len;
d1425 1
a1425 1
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
d1427 1
a1427 1
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
d1429 11
a1439 11
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (ip->client->packet_length < BOOTP_MIN_LEN)
		ip->client->packet_length = BOOTP_MIN_LEN;

	ip->client->packet.op = BOOTREQUEST;
	ip->client->packet.htype = ip->hw_address.htype;
	ip->client->packet.hlen = ip->hw_address.hlen;
	ip->client->packet.hops = 0;
	ip->client->packet.xid = ip->client->xid;
	ip->client->packet.secs = 0; /* Filled in by send_request. */
	ip->client->packet.flags = 0;
d1442 6
a1447 10
	memset(&ip->client->packet.ciaddr, 0,
	    sizeof(ip->client->packet.ciaddr));
	memset(&ip->client->packet.yiaddr, 0,
	    sizeof(ip->client->packet.yiaddr));
	memset(&ip->client->packet.siaddr, 0,
	    sizeof(ip->client->packet.siaddr));
	memset(&ip->client->packet.giaddr, 0,
	    sizeof(ip->client->packet.giaddr));
	memcpy(ip->client->packet.chaddr,
	    ip->hw_address.haddr, ip->hw_address.hlen);
d1482 4
a1485 4
	for (lp = ifi->client->leases; lp; lp = lp->next)
		write_client_lease(ifi, lp, 1);
	if (ifi->client->active)
		write_client_lease(ifi, ifi->client->active, 1);
d1493 1
a1493 2
write_client_lease(struct interface_info *ip, struct client_lease *lease,
    int rewrite)
d1520 1
a1520 1
	fprintf(leaseFile, "  interface \"%s\";\n", ip->name);
d1537 2
a1538 2
	fprintf(leaseFile, "  renew %d %lld/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int64_t)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
d1541 2
a1542 2
	fprintf(leaseFile, "  rebind %d %lld/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int64_t)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
d1545 2
a1546 2
	fprintf(leaseFile, "  expire %d %lld/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, (int64_t)t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
a1582 2
	struct client_state *client = ifi->client;

a1606 1
	struct interface_info *ip = ifi;
d1644 1
a1644 1
		if (ip->client->config->defaults[i].len) {
d1646 1
a1646 1
				switch (ip->client->config->default_actions[i]) {
d1653 2
a1654 2
					dp = ip->client->config->defaults[i].data;
					len = ip->client->config->defaults[i].len;
d1657 1
a1657 1
					len = ip->client->config->defaults[i].len +
d1667 2
a1668 2
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
d1670 1
a1670 1
					    ip->client->config->defaults[i].len,
d1676 1
a1676 1
					len = ip->client->config->defaults[i].len +
d1685 1
a1685 2
					memcpy(dp,
					    lease->options[i].data,
d1688 2
a1689 2
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
d1693 2
a1694 2
				dp = ip->client->config->defaults[i].data;
				len = ip->client->config->defaults[i].len;
d1797 2
a1798 2
	scriptName = ifi->client->config->script_name;
	envp = ifi->client->scriptEnv;
a1827 1
	struct client_state *client = ifi->client;
a1882 1
	struct client_state *client = ifi->client;
a2082 1

d2129 1
@


1.5
log
@build this on sparc w/o EXPERIMENTAL=yes (untested)
@
text
@d1 2
a2 2
/**	$MirOS: src/sbin/dhclient/dhclient.c,v 1.4 2005/11/23 16:43:51 tg Exp $ */
/*	$OpenBSD: dhclient.c,v 1.76 2005/07/16 14:09:51 krw Exp $	*/
d64 1
a64 1
__RCSID("$MirOS: src/sbin/dhclient/dhclient.c,v 1.4 2005/11/23 16:43:51 tg Exp $");
d206 2
a207 1
		if (l != NULL)	/* new addr is the one we set */
d284 10
a293 2
	if ((ifi = calloc(1, sizeof(struct interface_info))) == NULL)
		error("calloc");
d316 2
d319 6
d330 1
a330 1
			if (++i > 10) {
d332 2
d380 6
a385 4
	if (setgroups(1, &pw->pw_gid) ||
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
		error("can't drop privileges: %m");
a1704 1
	int		 errs;
d1714 1
a1714 2
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");
d1716 2
a1717 3
	errs = 0;
	errs += buf_add(buf, &hdr, sizeof(hdr));
	errs += buf_add(buf, &mediumlen, sizeof(mediumlen));
d1719 1
a1719 1
		errs += buf_add(buf, medium->string, mediumlen);
d1721 2
a1722 5
	errs += buf_add(buf, &len, sizeof(len));
	errs += buf_add(buf, reason, len);

	if (errs)
		error("buf_add: %m");
d1724 1
a1724 2
	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
d1730 8
a1737 1
	struct interface_info *ip = ifi;
d1739 3
a1741 11
	if (ip) {
		ip->client->scriptEnvsize = 100;
		if (ip->client->scriptEnv == NULL)
			ip->client->scriptEnv =
			    malloc(ip->client->scriptEnvsize * sizeof(char *));
		if (ip->client->scriptEnv == NULL)
			error("script_init: no memory for environment");

		ip->client->scriptEnv[0] = strdup(CLIENT_PATH);
		if (ip->client->scriptEnv[0] == NULL)
			error("script_init: no memory for environment");
d1743 1
a1743 1
		ip->client->scriptEnv[1] = NULL;
d1745 1
a1745 1
		script_set_env(ip->client, "", "interface", ip->name);
d1747 2
a1748 2
		if (medium)
			script_set_env(ip->client, "", "medium", medium);
d1750 1
a1750 2
		script_set_env(ip->client, "", "reason", reason);
	}
d1761 1
a1761 2
	script_set_env(ip->client, prefix, "ip_address",
	    piaddr(lease->address));
d1774 1
a1774 1
			script_set_env(ip->client, prefix, "network_number",
d1779 1
a1779 1
					script_set_env(ip->client, prefix,
d1787 1
a1787 1
		script_set_env(ip->client, prefix, "filename", lease->filename);
d1789 1
a1789 1
		script_set_env(ip->client, prefix, "server_name",
d1858 1
a1858 1
				script_set_env(ip->client, prefix, name,
d1863 1
a1863 1
	script_set_env(ip->client, prefix, "expiry", tbuf);
d1872 1
a1872 1
	int		 errs, i;
d1891 1
a1891 2
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");
d1893 8
a1900 9
	errs = 0;
	errs += buf_add(buf, &hdr, sizeof(hdr));
	errs += buf_add(buf, lease, sizeof(struct client_lease));
	errs += buf_add(buf, &fn_len, sizeof(fn_len));
	errs += buf_add(buf, lease->filename, fn_len);
	errs += buf_add(buf, &sn_len, sizeof(sn_len));
	errs += buf_add(buf, lease->server_name, sn_len);
	errs += buf_add(buf, &pr_len, sizeof(pr_len));
	errs += buf_add(buf, prefix, pr_len);
d1903 1
a1903 1
		errs += buf_add(buf, &lease->options[i].len,
d1905 1
a1905 1
		errs += buf_add(buf, lease->options[i].data,
d1909 1
a1909 5
	if (errs)
		error("buf_add: %m");

	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
d1924 1
a1924 2
	if ((buf = buf_open(hdr.len)) == NULL)
		error("buf_open: %m");
d1926 2
a1927 5
	if (buf_add(buf, &hdr, sizeof(hdr)))
		error("buf_add: %m");

	if (buf_close(privfd, buf) == -1)
		error("buf_close: %m");
d1943 1
a1943 3
	char *scriptName, *argv[2], **envp, *epp[3], reason[] = "REASON=NBI";
	static char client_path[] = CLIENT_PATH;
	struct interface_info *ip = ifi;
d1948 2
a1949 10
	if (ip) {
		scriptName = ip->client->config->script_name;
		envp = ip->client->scriptEnv;
	} else {
		scriptName = top_level_config.script_name;
		epp[0] = reason;
		epp[1] = client_path;
		epp[2] = NULL;
		envp = epp;
	}
d1971 1
a1971 2
	if (ip)
		script_flush_env(ip->client);
d1977 1
a1977 2
script_set_env(struct client_state *client, const char *prefix,
    const char *name, const char *value)
d1979 1
d2033 1
a2033 1
script_flush_env(struct client_state *client)
d2035 1
d2133 2
a2134 1
			return (0);
d2289 3
@


1.4
log
@fastmerge
@
text
@d1 1
a1 1
/**	$MirOS: src/sbin/dhclient/dhclient.c,v 1.3 2005/04/17 04:24:11 tg Exp $ */
d64 1
a64 1
__RCSID("$MirOS: src/sbin/dhclient/dhclient.c,v 1.3 2005/04/17 04:24:11 tg Exp $");
d681 1
a681 1
	    ip->client->active->renewal - cur_time);
d1103 2
a1104 1
	    ntohs(sockaddr_broadcast.sin_port), ip->client->interval);
d1156 1
a1156 1
					    cur_time);
@


1.3
log
@merge all but httpd
@
text
@d1 2
a2 2
/**	$MirOS: src/sbin/dhclient/dhclient.c,v 1.2 2005/03/06 19:49:50 tg Exp $ */
/*	$OpenBSD: dhclient.c,v 1.67 2005/04/08 14:21:36 henning Exp $	*/
d64 1
a64 1
__RCSID("$MirOS: src/sbin/dhclient/dhclient.c,v 1.2 2005/03/06 19:49:50 tg Exp $");
d75 3
a90 5
int		log_priority;
int		no_daemon;
int		unknown_ok = 1;
int		routefd;

d248 3
a250 4
	extern char		*__progname;
	int			 ch, fd, quiet = 0, i = 0;
	int			 pipe_fd[2];
	struct passwd		*pw;
a419 1

d568 4
a571 3
/* state_requesting is called when we receive a DHCPACK message after
   having sent out one or more DHCPREQUEST packets. */

d607 2
a608 2
		ip->client->new->expiry = getULong(
		    ip->client->new->options[DHO_DHCP_LEASE_TIME].data);
d622 2
a623 2
		ip->client->new->renewal = getULong(
		    ip->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d629 2
a630 2
		ip->client->new->rebind = getULong(
		    ip->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d705 3
a707 2
		memcpy(ip->client->destination.iabuf, ip->client->active->
		    options[DHO_DHCP_SERVER_IDENTIFIER].data, 4);
d801 1
a801 2
		if (!packet->options[ip->client->config->
		    required_options[i]].len) {
d892 4
a895 3
/* Allocate a client_lease structure and initialize it from the parameters
   in the specified packet. */

d953 4
a956 4
		if (!res_hnok(lease->server_name) ) {
			warning("Bogus server name %s",  lease->server_name );
			free_client_lease(lease);
			return (NULL);
a957 1

d1013 5
a1017 4
/* Send out a DHCPDISCOVER packet, and set a timeout to send out another
   one after the right interval has expired.  If we don't get an offer by
   the time we reach the panic interval, call the panic function. */

d1156 1
a1156 2
					add_timeout(
					    ip->client->active->renewal,
d1360 1
a1360 2
	struct tree_cache *options[256];
	struct tree_cache option_elements[256];
a1362 1
	memset(option_elements, 0, sizeof(option_elements));
d1368 2
a1369 5
	options[i] = &option_elements[i];
	options[i]->value = &discover;
	options[i]->len = sizeof(discover);
	options[i]->buf_size = sizeof(discover);
	options[i]->timeout = 0xFFFFFFFF;
d1373 2
a1374 6
	options[i] = &option_elements[i];
	options[i]->value = ip->client->config->requested_options;
	options[i]->len = ip->client->config->requested_option_count;
	options[i]->buf_size =
		ip->client->config->requested_option_count;
	options[i]->timeout = 0xFFFFFFFF;
d1380 2
a1381 5
		options[i] = &option_elements[i];
		options[i]->value = lease->address.iabuf;
		options[i]->len = lease->address.len;
		options[i]->buf_size = lease->address.len;
		options[i]->timeout = 0xFFFFFFFF;
d1387 1
a1387 1
		if (!options[i] &&
d1389 1
a1389 2
			options[i] = &option_elements[i];
			options[i]->value =
d1391 1
a1391 1
			options[i]->len =
a1392 3
			options[i]->buf_size =
			    ip->client->config->send_options[i].len;
			options[i]->timeout = 0xFFFFFFFF;
d1395 6
a1400 3
	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
d1429 1
a1429 2
	struct tree_cache *options[256];
	struct tree_cache option_elements[256];
d1437 2
a1438 5
	options[i] = &option_elements[i];
	options[i]->value = &request;
	options[i]->len = sizeof(request);
	options[i]->buf_size = sizeof(request);
	options[i]->timeout = 0xFFFFFFFF;
d1442 2
a1443 6
	options[i] = &option_elements[i];
	options[i]->value = ip->client->config->requested_options;
	options[i]->len = ip->client->config->requested_option_count;
	options[i]->buf_size =
		ip->client->config->requested_option_count;
	options[i]->timeout = 0xFFFFFFFF;
d1450 2
a1451 5
		options[i] = &option_elements[i];
		options[i]->value = lease->options[i].data;
		options[i]->len = lease->options[i].len;
		options[i]->buf_size = lease->options[i].len;
		options[i]->timeout = 0xFFFFFFFF;
d1457 2
a1458 5
		options[i] = &option_elements[i];
		options[i]->value = lease->address.iabuf;
		options[i]->len = lease->address.len;
		options[i]->buf_size = lease->address.len;
		options[i]->timeout = 0xFFFFFFFF;
d1464 1
a1464 1
		if (!options[i] &&
d1466 1
a1466 2
			options[i] = &option_elements[i];
			options[i]->value =
d1468 1
a1468 3
			options[i]->len =
			    ip->client->config->send_options[i].len;
			options[i]->buf_size =
a1469 1
			options[i]->timeout = 0xFFFFFFFF;
d1472 6
a1477 3
	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
d1515 1
a1515 3
	struct tree_cache *options[256], message_type_tree;
	struct tree_cache requested_address_tree;
	struct tree_cache server_id_tree, client_id_tree;
d1524 2
a1525 5
	options[i] = &message_type_tree;
	options[i]->value = &decline;
	options[i]->len = sizeof(decline);
	options[i]->buf_size = sizeof(decline);
	options[i]->timeout = 0xFFFFFFFF;
d1529 2
a1530 5
	options[i] = &server_id_tree;
	options[i]->value = lease->options[i].data;
	options[i]->len = lease->options[i].len;
	options[i]->buf_size = lease->options[i].len;
	options[i]->timeout = 0xFFFFFFFF;
d1534 2
a1535 5
	options[i] = &requested_address_tree;
	options[i]->value = lease->address.iabuf;
	options[i]->len = lease->address.len;
	options[i]->buf_size = lease->address.len;
	options[i]->timeout = 0xFFFFFFFF;
d1540 2
a1541 5
		options[i] = &client_id_tree;
		options[i]->value = ip->client->config->send_options[i].data;
		options[i]->len = ip->client->config->send_options[i].len;
		options[i]->buf_size = ip->client->config->send_options[i].len;
		options[i]->timeout = 0xFFFFFFFF;
d1544 6
a1549 4

	/* Set up the option buffer... */
	ip->client->packet_length = cons_options(NULL, &ip->client->packet, 0,
	    options, 0, 0, 0, NULL, 0);
d1784 1
a1784 2
				switch (
				    ip->client->config->default_actions[i]) {
d1791 2
a1792 4
					dp = ip->client->
						config->defaults[i].data;
					len = ip->client->
						config->defaults[i].len;
d1795 1
a1795 2
					len = ip->client->
					    config->defaults[i].len +
d1805 6
a1810 8
						ip->client->
						config->defaults[i].data,
						ip->client->
						config->defaults[i].len);
					memcpy(dp + ip->client->
						config->defaults[i].len,
						lease->options[i].data,
						lease->options[i].len);
d1814 1
a1814 2
					len = ip->client->
					    config->defaults[i].len +
d1824 2
a1825 2
						lease->options[i].data,
						lease->options[i].len);
d1827 2
a1828 4
						ip->client->
						config->defaults[i].data,
						ip->client->
						config->defaults[i].len);
d1832 2
a1833 4
				dp = ip->client->
					config->defaults[i].data;
				len = ip->client->
					config->defaults[i].len;
d2029 1
a2029 1
	for (j=0; j < strlen(value); j++)
d2054 1
a2054 1
dhcp_option_ev_name(char *buf, size_t buflen, struct option *option)
d2134 1
a2134 1
		return (1)  ;
@


1.2
log
@merge src/sbin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: dhclient.c,v 1.61 2004/11/25 11:05:10 claudio Exp $	*/
d57 2
a61 13
#define	PERIOD 0x2e
#define	hyphenchar(c) ((c) == 0x2d)
#define	bslashchar(c) ((c) == 0x5c)
#define	periodchar(c) ((c) == PERIOD)
#define	asterchar(c) ((c) == 0x2a)
#define	alphachar(c) (((c) >= 0x41 && (c) <= 0x5a) || \
	    ((c) >= 0x61 && (c) <= 0x7a))
#define	digitchar(c) ((c) >= 0x30 && (c) <= 0x39)

#define	borderchar(c) (alphachar(c) || digitchar(c))
#define	middlechar(c) (borderchar(c) || hyphenchar(c))
#define	domainchar(c) ((c) > 0x20 && (c) < 0x7f)

d64 1
a64 1
__RCSID("$MirOS$");
d176 4
a179 1
	n = read(routefd, &msg, sizeof(msg));
d218 1
a218 1
		if (scripttime == 0 || t < scripttime + 3)
d310 1
a310 1
		fprintf(stderr, "%s: no link ", ifi->name);
d322 1
a322 1
		fprintf(stderr, "got link\n");
d2249 1
a2249 1
res_hnok(const char *dn)
d2251 3
a2253 1
	int pch = PERIOD, ch = *dn++;
d2258 1
a2258 1
		if (periodchar(ch)) {
d2260 2
a2261 2
		} else if (periodchar(pch)) {
			if (!borderchar(ch))
d2263 1
a2263 5
		} else if (periodchar(nch) || nch == '\0') {
			if (!borderchar(ch))
				return (0);
		} else {
			if (!middlechar(ch))
d2265 4
d2287 1
a2287 1
		while (periodchar(*buf) || digitchar(*buf))
@


1.1
log
@Initial revision
@
text
@d1 1
d75 2
d690 1
a690 1
	note("bound to %s -- renewal in %d seconds.",
d1111 1
a1111 1
	note("DHCPDISCOVER on %s to %s port %d interval %d",
d1163 1
a1163 1
					note("bound: renewal in %d seconds.",
d1713 2
a1714 2
	fprintf(leaseFile, "  renew %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
d1717 2
a1718 2
	fprintf(leaseFile, "  rebind %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
d1721 2
a1722 2
	fprintf(leaseFile, "  expire %d %d/%d/%d %02d:%02d:%02d;\n",
	    t->tm_wday, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@some more updates/fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.67 2005/04/08 14:21:36 henning Exp $	*/
a55 2
#include <ctype.h>

d59 13
d184 1
a184 4
	do {
		n = read(routefd, &msg, sizeof(msg));
	} while (n == -1 && errno == EINTR);

d223 1
a223 1
		if (scripttime == 0 || t < scripttime + 10)
d315 1
a315 1
		fprintf(stderr, "%s: no link ...", ifi->name);
d327 1
a327 1
		fprintf(stderr, " got link\n");
d2254 1
a2254 1
res_hnok(const char *name)
d2256 1
a2256 3
	const char *dn = name;
	int pch = '.', ch = *dn++;
	int warn = 0;
d2261 1
a2261 1
		if (ch == '.') {
d2263 2
a2264 2
		} else if (pch == '.' || nch == '.' || nch == '\0') {
			if (!isalnum(ch))
d2266 5
a2270 1
		} else if (!isalnum(ch) && ch != '-' && ch != '_')
a2271 4
		else if (ch == '_' && warn == 0) {
			warning("warning: hostname %s contains an "
			    "underscore which violates RFC 952", name);
			warn++;
d2290 1
a2290 1
		while (*buf == '.' || isdigit(*buf))
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.76 2005/07/16 14:09:51 krw Exp $	*/
a71 3
int no_daemon;
int unknown_ok = 1;
int routefd;
d85 5
d247 4
a250 3
	int	 ch, fd, quiet = 0, i = 0, pipe_fd[2];
	extern char *__progname;
	struct passwd *pw;
d420 1
d569 3
a571 4
/*
 * state_requesting is called when we receive a DHCPACK message after
 * having sent out one or more DHCPREQUEST packets.
 */
d607 2
a608 2
		ip->client->new->expiry =
		    getULong(ip->client->new->options[DHO_DHCP_LEASE_TIME].data);
d622 2
a623 2
		ip->client->new->renewal =
		    getULong(ip->client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d629 2
a630 2
		ip->client->new->rebind =
		    getULong(ip->client->new->options[DHO_DHCP_REBINDING_TIME].data);
d705 2
a706 3
		memcpy(ip->client->destination.iabuf,
		    ip->client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
		    4);
d800 2
a801 1
		if (!packet->options[ip->client->config->required_options[i]].len) {
d892 3
a894 4
/*
 * Allocate a client_lease structure and initialize it from the
 * parameters in the specified packet.
 */
d952 4
a955 4
		if (!res_hnok(lease->server_name)) {
			warning("Bogus server name %s", lease->server_name);
			free(lease->server_name);
			lease->server_name = NULL;
d957 1
d1013 4
a1016 5
/*
 * Send out a DHCPDISCOVER packet, and set a timeout to send out another
 * one after the right interval has expired.  If we don't get an offer by
 * the time we reach the panic interval, call the panic function.
 */
d1155 2
a1156 1
					add_timeout(ip->client->active->renewal,
d1360 2
a1361 1
	struct option_data options[256];
d1364 1
d1370 5
a1374 2
	options[i].data = &discover;
	options[i].len = sizeof(discover);
d1378 6
a1383 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1389 5
a1393 2
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
d1399 1
a1399 1
		if (!options[i].data &&
d1401 2
a1402 1
			options[i].data =
d1404 1
a1404 1
			options[i].len =
d1406 3
d1411 3
a1413 6
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPDISCOVER packet.");
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
d1442 2
a1443 1
	struct option_data options[256];
d1451 5
a1455 2
	options[i].data = &request;
	options[i].len = sizeof(request);
d1459 6
a1464 2
	options[i].data = ip->client->config->requested_options;
	options[i].len = ip->client->config->requested_option_count;
d1471 5
a1475 2
		options[i].data = lease->options[i].data;
		options[i].len = lease->options[i].len;
d1481 5
a1485 2
		options[i].data = lease->address.iabuf;
		options[i].len = lease->address.len;
d1491 1
a1491 1
		if (!options[i].data &&
d1493 2
a1494 1
			options[i].data =
d1496 3
a1498 1
			options[i].len =
d1500 1
d1503 3
a1505 6
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPREQUEST packet.");
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
d1543 3
a1545 1
	struct option_data options[256];
d1554 5
a1558 2
	options[i].data = &decline;
	options[i].len = sizeof(decline);
d1562 5
a1566 2
	options[i].data = lease->options[i].data;
	options[i].len = lease->options[i].len;
d1570 5
a1574 2
	options[i].data = lease->address.iabuf;
	options[i].len = lease->address.len;
d1579 5
a1583 2
		options[i].data = ip->client->config->send_options[i].data;
		options[i].len = ip->client->config->send_options[i].len;
d1586 4
a1589 6
	/* Set up the option buffer to fit in a minimal UDP packet. */
	i = cons_options(ip->client->packet.options, 576 - DHCP_FIXED_LEN,
	    options);
	if (i == -1 || ip->client->packet.options[i] != DHO_END)
		error("options do not fit in DHCPDECLINE packet.");
	ip->client->packet_length = DHCP_FIXED_NON_UDP+i+1;
d1824 2
a1825 1
				switch (ip->client->config->default_actions[i]) {
d1832 4
a1835 2
					dp = ip->client->config->defaults[i].data;
					len = ip->client->config->defaults[i].len;
d1838 2
a1839 1
					len = ip->client->config->defaults[i].len +
d1849 8
a1856 6
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
					memcpy(dp +
					    ip->client->config->defaults[i].len,
					    lease->options[i].data,
					    lease->options[i].len);
d1860 2
a1861 1
					len = ip->client->config->defaults[i].len +
d1871 2
a1872 2
					    lease->options[i].data,
					    lease->options[i].len);
d1874 4
a1877 2
					    ip->client->config->defaults[i].data,
					    ip->client->config->defaults[i].len);
d1881 4
a1884 2
				dp = ip->client->config->defaults[i].data;
				len = ip->client->config->defaults[i].len;
d2080 1
a2080 1
	for (j = 0; j < strlen(value); j++)
d2105 1
a2105 1
dhcp_option_ev_name(char *buf, size_t buflen, const struct option *option)
d2185 1
a2185 1
		return (1);
@


1.1.1.4
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.88 2006/08/31 10:12:18 deraadt Exp $	*/
d203 1
a203 2
		if (l != NULL || addr_eq(a, ifi->client->alias->address))
			/* new addr is the one we set */
d280 2
a281 10
	ifi = calloc(1, sizeof(*ifi));
	if (ifi == NULL)
		error("ifi calloc");
	ifi->client = calloc(1, sizeof(*(ifi->client)));
	if (ifi->client == NULL)
		error("ifi->client calloc");
	ifi->client->config = calloc(1, sizeof(*(ifi->client->config)));
	if (ifi->client->config == NULL)
		error("ifi->client->config calloc");

a303 2
		int linkstat = interface_link_forceup(ifi->name);

a304 6
		if (ifi->client->config->link_timeout == 0) {
			fprintf(stderr, " giving up\n");
			if (linkstat == 0)
				interface_link_forcedown(ifi->name);
			exit(1);
		}
d310 1
a310 1
			if (++i > ifi->client->config->link_timeout) {
a311 2
				if (linkstat == 0)
					interface_link_forcedown(ifi->name);
d358 4
a361 6
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
		error("setresgid");
	if (setgroups(1, &pw->pw_gid) == -1)
		error("setgroups");
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
		error("setresuid");
d1680 1
d1690 2
a1691 1
	buf = buf_open(hdr.len);
d1693 3
a1695 2
	buf_add(buf, &hdr, sizeof(hdr));
	buf_add(buf, &mediumlen, sizeof(mediumlen));
d1697 1
a1697 1
		buf_add(buf, medium->string, mediumlen);
d1699 5
a1703 2
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, reason, len);
d1705 2
a1706 1
	buf_close(privfd, buf);
d1712 1
a1712 1
	struct client_state *client = ifi->client;
d1714 11
a1724 6
	client->scriptEnvsize = 100;
	if (client->scriptEnv == NULL)
		client->scriptEnv =
		    malloc(client->scriptEnvsize * sizeof(char *));
	if (client->scriptEnv == NULL)
		error("script_init: no memory for environment");
d1726 1
a1726 3
	client->scriptEnv[0] = strdup(CLIENT_PATH);
	if (client->scriptEnv[0] == NULL)
		error("script_init: no memory for environment");
d1728 1
a1728 1
	client->scriptEnv[1] = NULL;
d1730 2
a1731 1
	script_set_env("", "interface", ifi->name);
d1733 2
a1734 4
	if (medium)
		script_set_env("", "medium", medium);

	script_set_env("", "reason", reason);
d1745 2
a1746 1
	script_set_env(prefix, "ip_address", piaddr(lease->address));
d1759 1
a1759 1
			script_set_env(prefix, "network_number",
d1764 1
a1764 1
					script_set_env(prefix,
d1772 1
a1772 1
		script_set_env(prefix, "filename", lease->filename);
d1774 1
a1774 1
		script_set_env(prefix, "server_name",
d1843 1
a1843 1
				script_set_env(prefix, name,
d1848 1
a1848 1
	script_set_env(prefix, "expiry", tbuf);
d1857 1
a1857 1
	int		 i;
d1876 2
a1877 1
	buf = buf_open(hdr.len);
d1879 9
a1887 8
	buf_add(buf, &hdr, sizeof(hdr));
	buf_add(buf, lease, sizeof(struct client_lease));
	buf_add(buf, &fn_len, sizeof(fn_len));
	buf_add(buf, lease->filename, fn_len);
	buf_add(buf, &sn_len, sizeof(sn_len));
	buf_add(buf, lease->server_name, sn_len);
	buf_add(buf, &pr_len, sizeof(pr_len));
	buf_add(buf, prefix, pr_len);
d1890 1
a1890 1
		buf_add(buf, &lease->options[i].len,
d1892 1
a1892 1
		buf_add(buf, lease->options[i].data,
d1896 5
a1900 1
	buf_close(privfd, buf);
d1915 2
a1916 1
	buf = buf_open(hdr.len);
d1918 5
a1922 2
	buf_add(buf, &hdr, sizeof(hdr));
	buf_close(privfd, buf);
d1938 3
a1940 1
	char *scriptName, *argv[2], **envp;
d1945 10
a1954 2
	scriptName = ifi->client->config->script_name;
	envp = ifi->client->scriptEnv;
d1976 2
a1977 1
	script_flush_env();
d1983 2
a1984 1
script_set_env(const char *prefix, const char *name, const char *value)
a1985 1
	struct client_state *client = ifi->client;
d2039 1
a2039 1
script_flush_env(void)
a2040 1
	struct client_state *client = ifi->client;
d2138 1
a2138 2
			l->options[option].len = 0;
			free(l->options[option].data);
a2292 3
	if (chdir("/") == -1)
		error("chdir(\"/\")");

@


1.1.1.5
log
@Import spamd and dhclient from OpenBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: dhclient.c,v 1.109 2007/02/13 21:54:22 stevesk Exp $	*/
a56 2
#include <poll.h>
#include <pwd.h>
d74 1
a74 1
int routefd = -1;
d80 6
d88 1
a88 3
struct interface_info *ifi;
struct client_state *client;
struct client_config *config;
d92 1
d158 1
a158 1
routehandler(void)
d187 2
d199 1
a199 1
		for (l = client->active; l != NULL; l = l->next)
d203 1
a203 2
		if (l != NULL || (client->alias &&
		    addr_eq(a, client->alias->address)))
d237 2
a238 2
	if (client->alias)
		script_write_params("alias_", client->alias);
d284 6
a289 6
	client = calloc(1, sizeof(*client));
	if (client == NULL)
		error("client calloc");
	config = calloc(1, sizeof(*config));
	if (config == NULL)
		error("config calloc");
d316 1
a316 1
		if (config->link_timeout == 0) {
d327 1
a327 1
			if (++i > config->link_timeout) {
d362 2
a363 2
	if (client->alias)
		priv_script_write_params("alias_", client->alias);
d366 2
a367 2
	if ((routefd = socket(PF_ROUTE, SOCK_RAW, 0)) == -1)
		error("socket(PF_ROUTE, SOCK_RAW): %m");
d370 1
a370 1
	discover_interface();
d388 4
a391 2
	client->state = S_INIT;
	state_reboot();
d439 1
a439 1
state_reboot(void)
d441 2
d444 2
a445 2
	if (!client->active || client->active->is_bootp) {
		state_init();
d450 1
a450 1
	client->state = S_REBOOTING;
d455 1
a455 1
	client->xid = arc4random();
d459 4
a462 4
	make_request(client->active);
	client->destination = iaddr_broadcast;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;
d465 1
a465 1
	client->medium = NULL;
d468 1
a468 1
	send_request();
d476 1
a476 1
state_init(void)
d478 4
d484 6
a489 6
	make_discover(client->active);
	client->xid = client->packet.xid;
	client->destination = iaddr_broadcast;
	client->state = S_SELECTING;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;
d493 1
a493 1
	send_discover();
d501 1
a501 1
state_selecting(void)
d503 1
d506 2
d510 2
a511 2
	cancel_timeout(state_selecting);
	cancel_timeout(send_discover);
d517 1
a517 1
	for (lp = client->offered_leases; lp; lp = next) {
d531 2
a532 2
				make_decline(lp);
				send_decline();
d542 1
a542 1
	client->offered_leases = NULL;
d547 2
a548 2
		client->state = S_INIT;
		state_init();
d554 1
a554 1
		client->new = picked;
d558 3
a560 3
		client->new->expiry = cur_time + 12000;
		client->new->renewal += cur_time + 8000;
		client->new->rebind += cur_time + 10000;
d562 1
a562 1
		client->state = S_REQUESTING;
d565 1
a565 1
		bind_lease();
d570 4
a573 4
	client->destination = iaddr_broadcast;
	client->state = S_REQUESTING;
	client->first_sending = cur_time;
	client->interval = config->initial_interval;
d576 2
a577 2
	make_request(picked);
	client->xid = client->packet.xid;
d583 1
a583 1
	send_request();
d591 1
a591 1
dhcpack(struct iaddr client_addr, struct option_data *options)
d593 1
d596 6
a601 1
	if (client->xid != client->packet.xid)
d604 4
a607 4
	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING)
d610 1
a610 1
	note("DHCPACK from %s", piaddr(client_addr));
d612 1
a612 1
	lease = packet_to_lease(client_addr, options);
d618 1
a618 1
	client->new = lease;
d621 1
a621 1
	cancel_timeout(send_request);
d624 3
a626 3
	if (client->new->options[DHO_DHCP_LEASE_TIME].data)
		client->new->expiry =
		    getULong(client->new->options[DHO_DHCP_LEASE_TIME].data);
d628 1
a628 1
		client->new->expiry = default_lease_time;
d631 2
a632 2
	if (client->new->expiry < 0)
		client->new->expiry = TIME_MAX;
d634 2
a635 2
	if (client->new->expiry < 60)
		client->new->expiry = 60;
d639 3
a641 3
	if (client->new->options[DHO_DHCP_RENEWAL_TIME].len)
		client->new->renewal =
		    getULong(client->new->options[DHO_DHCP_RENEWAL_TIME].data);
d643 1
a643 1
		client->new->renewal = client->new->expiry / 2;
d646 3
a648 3
	if (client->new->options[DHO_DHCP_REBINDING_TIME].len)
		client->new->rebind =
		    getULong(client->new->options[DHO_DHCP_REBINDING_TIME].data);
d650 2
a651 2
		client->new->rebind = client->new->renewal +
		    client->new->renewal / 2 + client->new->renewal / 4;
d653 1
a653 1
	client->new->expiry += cur_time;
d655 8
a662 8
	if (client->new->expiry < cur_time)
		client->new->expiry = TIME_MAX;
	client->new->renewal += cur_time;
	if (client->new->renewal < cur_time)
		client->new->renewal = TIME_MAX;
	client->new->rebind += cur_time;
	if (client->new->rebind < cur_time)
		client->new->rebind = TIME_MAX;
d664 1
a664 1
	bind_lease();
d668 1
a668 1
bind_lease(void)
d671 1
a671 1
	client->new->medium = client->medium;
d674 1
a674 1
	write_client_lease(client->new, 0);
d677 9
a685 9
	script_init((client->state == S_REQUESTING ? "BOUND" :
	    (client->state == S_RENEWING ? "RENEW" :
	    (client->state == S_REBOOTING ? "REBOOT" : "REBIND"))),
	    client->new->medium);
	if (client->active && client->state != S_REBOOTING)
		script_write_params("old_", client->active);
	script_write_params("new_", client->new);
	if (client->alias)
		script_write_params("alias_", client->alias);
d689 4
a692 4
	if (client->active)
		free_client_lease(client->active);
	client->active = client->new;
	client->new = NULL;
d695 1
a695 1
	add_timeout(client->active->renewal, state_bound);
d698 4
a701 4
	    piaddr(client->active->address),
	    client->active->renewal - cur_time);
	client->state = S_BOUND;
	reinitialize_interface();
d712 1
a712 1
state_bound(void)
d714 4
d719 2
a720 2
	make_request(client->active);
	client->xid = client->packet.xid;
d722 3
a724 3
	if (client->active->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		memcpy(client->destination.iabuf,
		    client->active->options[DHO_DHCP_SERVER_IDENTIFIER].data,
d726 1
a726 1
		client->destination.len = 4;
d728 1
a728 1
		client->destination = iaddr_broadcast;
d730 3
a732 3
	client->first_sending = cur_time;
	client->interval = config->initial_interval;
	client->state = S_RENEWING;
d735 57
a791 1
	send_request();
d795 1
a795 1
dhcpoffer(struct iaddr client_addr, struct option_data *options)
d797 1
d801 2
a802 2
	char *name = options[DHO_DHCP_MESSAGE_TYPE].len ? "DHCPOFFER" :
	    "BOOTREPLY";
d804 7
a810 1
	if (client->xid != client->packet.xid)
d813 1
a813 2
	if (client->state != S_SELECTING)
		return;
a814 1
	note("%s from %s", name, piaddr(client_addr));
d818 2
a819 2
	for (i = 0; config->required_options[i]; i++) {
		if (!options[config->required_options[i]].len) {
d826 1
a826 1
	for (lease = client->offered_leases;
d828 1
a828 1
		if (lease->address.len == sizeof(client->packet.yiaddr) &&
d830 1
a830 1
		    &client->packet.yiaddr, lease->address.len)) {
d836 1
a836 1
	lease = packet_to_lease(client_addr, options);
d844 1
a844 1
	if (!options[DHO_DHCP_MESSAGE_TYPE].len)
d848 1
a848 1
	lease->medium = client->medium;
d861 2
a862 1
	stop_selecting = client->first_sending + config->select_interval;
d866 1
a866 1
	if (lease->address.len == client->requested_address.len &&
d868 4
a871 4
	    client->requested_address.iabuf,
	    client->requested_address.len)) {
		lease->next = client->offered_leases;
		client->offered_leases = lease;
d877 1
a877 1
		if (client->offered_leases &&
d883 2
a884 2
		if (!client->offered_leases)
			client->offered_leases = lease;
d886 1
a886 1
			for (lp = client->offered_leases; lp->next;
d903 1
a903 1
		state_selecting();
d905 2
a906 2
		add_timeout(stop_selecting, state_selecting);
		cancel_timeout(send_discover);
d915 1
a915 1
packet_to_lease(struct iaddr client_addr, struct option_data *options)
d931 18
a948 5
		if (options[i].len) {
			lease->options[i] = options[i];
			options[i].data = NULL;
			options[i].len = 0;
			if (!check_option(lease, i)) {
d956 2
a957 3
	lease->address.len = sizeof(client->packet.yiaddr);
	memcpy(lease->address.iabuf, &client->packet.yiaddr,
	    lease->address.len);
d960 3
a962 3
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)) &&
	    client->packet.sname[0]) {
d969 2
a970 3
		memcpy(lease->server_name, client->packet.sname,
		    DHCP_SNAME_LEN);
		lease->server_name[DHCP_SNAME_LEN] = '\0';
d979 3
a981 3
	if ((!options[DHO_DHCP_OPTION_OVERLOAD].len ||
	    !(options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)) &&
	    client->packet.file[0]) {
d989 2
a990 2
		memcpy(lease->filename, client->packet.file, DHCP_FILE_LEN);
		lease->filename[DHCP_FILE_LEN] = '\0';
d996 1
a996 1
dhcpnak(struct iaddr client_addr, struct option_data *options)
d998 8
a1005 1
	if (client->xid != client->packet.xid)
d1008 4
a1011 4
	if (client->state != S_REBOOTING &&
	    client->state != S_REQUESTING &&
	    client->state != S_RENEWING &&
	    client->state != S_REBINDING)
d1014 1
a1014 1
	note("DHCPNAK from %s", piaddr(client_addr));
d1016 2
a1017 2
	if (!client->active) {
		note("DHCPNAK with no active lease.");
d1021 2
a1022 2
	free_client_lease(client->active);
	client->active = NULL;
d1025 1
a1025 1
	cancel_timeout(send_request);
d1027 2
a1028 2
	client->state = S_INIT;
	state_init();
d1037 1
a1037 1
send_discover(void)
d1039 1
d1043 1
a1043 1
	interval = cur_time - client->first_sending;
d1047 2
a1048 2
	if (interval > config->timeout) {
		state_panic();
d1055 2
a1056 1
	if (!client->offered_leases && config->media) {
d1059 2
a1060 2
		if (client->medium) {
			client->medium = client->medium->next;
d1063 1
a1063 1
		if (!client->medium) {
d1065 2
a1066 2
				error("No valid media types for %s!", ifi->name);
			client->medium = config->media;
d1070 1
a1070 1
		note("Trying medium \"%s\" %d", client->medium->string,
d1072 1
a1072 1
		script_init("MEDIUM", client->medium);
d1080 3
a1082 3
	 * it to initial_interval; otherwise, add to it a random
	 * number between zero and two times itself.  On average, this
	 * means that it will double with every transmission.
d1085 3
a1087 2
		if (!client->interval)
			client->interval = config->initial_interval;
d1089 2
a1090 2
			client->interval += (arc4random() >> 2) %
			    (2 * client->interval);
d1094 4
a1097 2
		if (client->interval > config->backoff_cutoff)
			client->interval = ((config->backoff_cutoff / 2)
d1099 4
a1102 3
				    config->backoff_cutoff));
	} else if (!client->interval)
		client->interval = config->initial_interval;
d1106 5
a1110 4
	if (cur_time + client->interval >
	    client->first_sending + config->timeout)
		client->interval = (client->first_sending +
			 config->timeout) - cur_time + 1;
d1114 1
a1114 1
		client->packet.secs = htons(interval);
d1116 2
a1117 2
		client->packet.secs = htons(65535);
	client->secs = client->packet.secs;
d1120 2
a1121 2
	    ifi->name, inet_ntoa(sockaddr_broadcast.sin_addr),
	    ntohs(sockaddr_broadcast.sin_port), client->interval);
d1124 2
a1125 1
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);
d1127 1
a1127 1
	add_timeout(cur_time + client->interval, send_discover);
d1137 1
a1137 1
state_panic(void)
d1139 2
a1140 1
	struct client_lease *loop = client->active;
d1147 1
a1147 1
	if (!client->active && client->leases)
d1151 2
a1152 2
	while (client->active) {
		if (client->active->expiry > cur_time) {
d1154 1
a1154 1
			    piaddr(client->active->address));
d1158 3
a1160 3
			    client->active->medium);
			script_write_params("new_", client->active);
			if (client->alias)
d1162 1
a1162 1
				    client->alias);
d1169 2
a1170 2
				    client->active->renewal) {
					client->state = S_BOUND;
d1172 1
a1172 1
					    client->active->renewal -
d1174 2
a1175 2
					add_timeout(client->active->renewal,
					    state_bound);
d1177 1
a1177 1
					client->state = S_BOUND;
d1179 1
a1179 1
					state_bound();
d1181 1
a1181 1
				reinitialize_interface();
d1188 3
a1190 3
		if (!client->leases) {
			client->leases = client->active;
			client->active = NULL;
d1197 1
a1197 1
		for (lp = client->leases; lp->next; lp = lp->next)
d1199 1
a1199 1
		lp->next = client->active;
d1202 2
a1203 2
		client->active = client->leases;
		client->leases = client->leases->next;
d1208 1
a1208 1
		if (client->active == loop)
d1211 1
a1211 1
			loop = client->active;
d1217 1
a1217 1
	note("No working leases in persistent database - sleeping.");
d1219 2
a1220 2
	if (client->alias)
		script_write_params("alias_", client->alias);
d1222 3
a1224 2
	client->state = S_INIT;
	add_timeout(cur_time + config->retry_interval, state_init);
d1229 1
a1229 1
send_request(void)
d1231 1
d1237 1
a1237 1
	interval = cur_time - client->first_sending;
d1249 3
a1251 3
	if ((client->state == S_REBOOTING ||
	    client->state == S_REQUESTING) &&
	    interval > config->reboot_timeout) {
d1253 3
a1255 3
		client->state = S_INIT;
		cancel_timeout(send_request);
		state_init();
d1261 4
a1264 4
	if (client->state == S_REBOOTING &&
	    !client->medium &&
	    client->active->medium) {
		script_init("MEDIUM", client->active->medium);
d1271 1
a1271 1
		client->medium = client->active->medium;
d1276 2
a1277 2
	if (client->state != S_REQUESTING &&
	    cur_time > client->active->expiry) {
d1280 3
a1282 3
		script_write_params("old_", client->active);
		if (client->alias)
			script_write_params("alias_", client->alias);
d1288 2
a1289 2
		if (client->alias)
			script_write_params("alias_", client->alias);
d1292 2
a1293 2
		client->state = S_INIT;
		state_init();
d1298 2
a1299 2
	if (!client->interval)
		client->interval = config->initial_interval;
d1301 2
a1302 2
		client->interval += ((arc4random() >> 2) %
		    (2 * client->interval));
d1305 5
a1309 3
	if (client->interval > config->backoff_cutoff)
		client->interval = ((config->backoff_cutoff / 2) +
		    ((arc4random() >> 2) % client->interval));
d1313 5
a1317 3
	if (client->state != S_REQUESTING && cur_time + client->interval >
	    client->active->expiry)
		client->interval = client->active->expiry - cur_time + 1;
d1322 3
a1324 3
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING ||
	    cur_time > client->active->rebind)
d1327 2
a1328 1
		memcpy(&destination.sin_addr.s_addr, client->destination.iabuf,
d1334 3
a1336 2
	if (client->state != S_REQUESTING)
		memcpy(&from, client->active->address.iabuf, sizeof(from));
d1341 2
a1342 2
	if (client->state == S_REQUESTING)
		client->packet.secs = client->secs;
d1345 1
a1345 1
			client->packet.secs = htons(interval);
d1347 1
a1347 1
			client->packet.secs = htons(65535);
d1350 1
a1350 1
	note("DHCPREQUEST on %s to %s port %d", ifi->name,
d1354 2
a1355 1
	send_packet(from, &destination, NULL);
d1357 1
a1357 1
	add_timeout(cur_time + client->interval, send_request);
d1361 1
a1361 1
send_decline(void)
d1363 3
a1365 1
	note("DHCPDECLINE on %s to %s port %d", ifi->name,
d1370 2
a1371 1
	send_packet(inaddr_any, &sockaddr_broadcast, NULL);
d1375 1
a1375 1
make_discover(struct client_lease *lease)
d1382 1
a1382 1
	memset(&client->packet, 0, sizeof(client->packet));
d1391 2
a1392 2
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;
d1396 1
a1396 1
		client->requested_address = lease->address;
d1401 1
a1401 1
		client->requested_address.len = 0;
d1406 5
a1410 3
		    config->send_options[i].data) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
d1414 1
a1414 1
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
d1416 1
a1416 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1418 22
a1439 18
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = arc4random();
	client->packet.secs = 0; /* filled in by send_discover. */
	client->packet.flags = 0;

	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
d1442 1
d1444 1
a1444 1
make_request(struct client_lease * lease)
d1451 1
a1451 1
	memset(&client->packet, 0, sizeof(client->packet));
d1460 2
a1461 2
	options[i].data = config->requested_options;
	options[i].len = config->requested_option_count;
d1465 1
a1465 1
	if (client->state == S_REQUESTING) {
d1471 3
a1473 3
	if (client->state == S_REQUESTING ||
	    client->state == S_REBOOTING) {
		client->requested_address = lease->address;
d1478 1
a1478 1
		client->requested_address.len = 0;
d1482 6
a1487 3
		if (!options[i].data && config->send_options[i].data) {
			options[i].data = config->send_options[i].data;
			options[i].len = config->send_options[i].len;
d1491 1
a1491 1
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
d1493 1
a1493 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1495 10
a1504 11
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;
d1508 4
a1511 4
	if (client->state == S_BOUND ||
	    client->state == S_RENEWING ||
	    client->state == S_REBINDING) {
		memcpy(&client->packet.ciaddr,
d1513 1
d1515 3
a1517 2
		memset(&client->packet.ciaddr, 0,
		    sizeof(client->packet.ciaddr));
d1520 8
a1527 5
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
d1531 1
a1531 1
make_decline(struct client_lease *lease)
d1538 1
a1538 1
	memset(&client->packet, 0, sizeof(client->packet));
d1557 3
a1559 3
	if (config->send_options[i].len) {
		options[i].data = config->send_options[i].data;
		options[i].len = config->send_options[i].len;
d1563 1
a1563 1
	i = cons_options(client->packet.options, 576 - DHCP_FIXED_LEN,
d1565 1
a1565 1
	if (i == -1 || client->packet.options[i] != DHO_END)
d1567 11
a1577 11
	client->packet_length = DHCP_FIXED_NON_UDP+i+1;
	if (client->packet_length < BOOTP_MIN_LEN)
		client->packet_length = BOOTP_MIN_LEN;

	client->packet.op = BOOTREQUEST;
	client->packet.htype = ifi->hw_address.htype;
	client->packet.hlen = ifi->hw_address.hlen;
	client->packet.hops = 0;
	client->packet.xid = client->xid;
	client->packet.secs = 0; /* Filled in by send_request. */
	client->packet.flags = 0;
d1580 10
a1589 6
	memset(&client->packet.ciaddr, 0, sizeof(client->packet.ciaddr));
	memset(&client->packet.yiaddr, 0, sizeof(client->packet.yiaddr));
	memset(&client->packet.siaddr, 0, sizeof(client->packet.siaddr));
	memset(&client->packet.giaddr, 0, sizeof(client->packet.giaddr));
	memcpy(client->packet.chaddr, ifi->hw_address.haddr,
	    ifi->hw_address.hlen);
d1624 4
a1627 4
	for (lp = client->leases; lp; lp = lp->next)
		write_client_lease(lp, 1);
	if (client->active)
		write_client_lease(client->active, 1);
d1635 2
a1636 1
write_client_lease(struct client_lease *lease, int rewrite)
d1663 1
a1663 1
	fprintf(leaseFile, "  interface \"%s\";\n", ifi->name);
d1726 2
d1752 1
d1790 1
a1790 1
		if (config->defaults[i].len) {
d1792 1
a1792 1
				switch (config->default_actions[i]) {
d1799 2
a1800 2
					dp = config->defaults[i].data;
					len = config->defaults[i].len;
d1803 1
a1803 1
					len = config->defaults[i].len +
d1813 2
a1814 2
					    config->defaults[i].data,
					    config->defaults[i].len);
d1816 1
a1816 1
					    config->defaults[i].len,
d1822 1
a1822 1
					len = config->defaults[i].len +
d1831 2
a1832 1
					memcpy(dp, lease->options[i].data,
d1835 2
a1836 2
					    config->defaults[i].data,
					    config->defaults[i].len);
d1840 2
a1841 2
				dp = config->defaults[i].data;
				len = config->defaults[i].len;
d1944 2
a1945 2
	scriptName = config->script_name;
	envp = client->scriptEnv;
d1975 1
d2031 1
d2232 1
a2278 1
		break;
@


