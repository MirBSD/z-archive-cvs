head	1.5;
access;
symbols
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200702170300:1.1.1.4
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.1
	cvs-200504170300:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2007.02.17.03.23.43;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D675555105AC23;

1.4
date	2006.09.20.20.03.32;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045119E9F677AC322;

1.3
date	2005.11.23.16.43.52;	author tg;	state Exp;
branches;
next	1.2;
commitid	560c43849c55498d;

1.2
date	2005.03.06.19.49.50;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.26.30;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.56.53;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2006.09.20.19.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045119150397FC669;

1.1.1.4
date	2007.02.17.03.06.20;	author tg;	state Exp;
branches;
next	;
commitid	10045D67134732A8703;


desc
@@


1.5
log
@merge dhclient upgrade
@
text
@/*	$OpenBSD: parse.c,v 1.18 2007/01/08 13:34:38 krw Exp $	*/

/* Common parser code for dhcpd and dhclient. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include "dhcpd.h"
#include "dhctoken.h"

__RCSID("$MirOS: src/sbin/dhclient/parse.c,v 1.4 2006/09/20 20:03:32 tg Exp $");

/*
 * Skip to the semicolon ending the current statement.   If we encounter
 * braces, the matching closing brace terminates the statement.   If we
 * encounter a right brace but haven't encountered a left brace, return
 * leaving the brace in the token buffer for the caller.   If we see a
 * semicolon and haven't seen a left brace, return.   This lets us skip
 * over:
 *
 *	statement;
 *	statement foo bar { }
 *	statement foo bar { statement { } }
 *	statement}
 *
 *	...et cetera.
 */
void
skip_to_semi(FILE *cfile)
{
	int		 token;
	char		*val;
	int		 brace_count = 0;

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			if (brace_count) {
				token = next_token(&val, cfile);
				if (!--brace_count)
					return;
			} else
				return;
		} else if (token == '{') {
			brace_count++;
		} else if (token == ';' && !brace_count) {
			token = next_token(&val, cfile);
			return;
		} else if (token == '\n') {
			/*
			 * EOL only happens when parsing
			 * /etc/resolv.conf, and we treat it like a
			 * semicolon because the resolv.conf file is
			 * line-oriented.
			 */
			token = next_token(&val, cfile);
			return;
		}
		token = next_token(&val, cfile);
	} while (token != EOF);
}

int
parse_semi(FILE *cfile)
{
	int token;
	char *val;

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return (0);
	}
	return (1);
}

/*
 * string-parameter :== STRING SEMI
 */
char *
parse_string(FILE *cfile)
{
	char *val, *s;
	int token;

	token = next_token(&val, cfile);
	if (token != TOK_STRING) {
		parse_warn("filename must be a string");
		skip_to_semi(cfile);
		return (NULL);
	}
	s = malloc(strlen(val) + 1);
	if (!s)
		error("no memory for string %s.", val);
	strlcpy(s, val, strlen(val) + 1);

	if (!parse_semi(cfile)) {
		free(s);
		return (NULL);
	}
	return (s);
}

int
parse_ip_addr(FILE *cfile, struct iaddr *addr)
{
	addr->len = 4;
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, '.',
	    10));
}

/*
 * hardware-parameter :== HARDWARE ETHERNET csns SEMI
 * csns :== NUMBER | csns COLON NUMBER
 */
void
parse_hardware_param(FILE *cfile, struct hardware *hardware)
{
	int token;
	char *val;

	token = next_token(&val, cfile);
	switch (token) {
	case TOK_ETHERNET:
		hardware->htype = HTYPE_ETHER;
		hardware->hlen = 6;
		break;
	case TOK_TOKEN_RING:
		hardware->htype = HTYPE_IEEE802;
		hardware->hlen = 6;
		break;
	case TOK_FDDI:
		hardware->htype = HTYPE_FDDI;
		hardware->hlen = 6;
		break;
	default:
		parse_warn("expecting a network hardware type");
		skip_to_semi(cfile);
		return;
	}

	if (parse_numeric_aggregate(cfile, hardware->haddr, hardware->hlen,
	    ':', 16) == 0)
		return;

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
}

/*
 * lease-time :== NUMBER SEMI
 */
void
parse_lease_time(FILE *cfile, time_t *timep)
{
	char *val;
	int token;
	uint32_t tmp = 0;

	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("Expecting numeric lease time");
		skip_to_semi(cfile);
		return;
	}
	convert_num((unsigned char *)&tmp, val, 10, 32);
	/* Unswap the number - convert_num returns stuff in NBO. */
	*timep = ntohl(tmp);

	parse_semi(cfile);
}

/*
 * Parse a sequence of numbers separated by the token specified in separator.
 * Exactly max numbers are expected.
 */
int
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int max, int separator,
    int base)
{
	char *val;
	int token, count;

	if (buf == NULL || max == 0)
		error("no space for numeric aggregate");

	for (count = 0; count < max; count++, buf++) {
		if (count && (peek_token(&val, cfile) == separator))
			token = next_token(&val, cfile);

		token = next_token(&val, cfile);

		if (token == TOK_NUMBER || (base == 16 && token == TOK_NUMBER_OR_NAME))
			/* XXX Need to check if conversion was successful. */
			convert_num(buf, val, base, 8);
		else
			break;
	}

	if (count < max) {
		parse_warn("numeric aggregate too short.");
		return (0);
	}

	return (1);
}

void
convert_num(unsigned char *buf, char *str, int base, int size)
{
	int negative = 0, tval, max;
	u_int32_t val = 0;
	char *ptr = str;

	if (*ptr == '-') {
		negative = 1;
		ptr++;
	}

	/* If base wasn't specified, figure it out from the data. */
	if (!base) {
		if (ptr[0] == '0') {
			if (ptr[1] == 'x') {
				base = 16;
				ptr += 2;
			} else if (isascii(ptr[1]) && isdigit(ptr[1])) {
				base = 8;
				ptr += 1;
			} else
				base = 10;
		} else
			base = 10;
	}

	do {
		tval = *ptr++;
		/* XXX assumes ASCII... */
		if (tval >= 'a')
			tval = tval - 'a' + 10;
		else if (tval >= 'A')
			tval = tval - 'A' + 10;
		else if (tval >= '0')
			tval -= '0';
		else {
			warning("Bogus number: %s.", str);
			break;
		}
		if (tval >= base) {
			warning("Bogus number: %s: digit %d not in base %d",
			    str, tval, base);
			break;
		}
		val = val * base + tval;
	} while (*ptr);

	if (negative)
		max = (1 << (size - 1));
	else
		max = (1 << (size - 1)) + ((1 << (size - 1)) - 1);
	if (val > max) {
		switch (base) {
		case 8:
			warning("value %s%o exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		case 16:
			warning("value %s%x exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		default:
			warning("value %s%u exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		}
	}

	if (negative)
		switch (size) {
		case 8:
			*buf = -(unsigned long)val;
			break;
		case 16:
			putShort(buf, -(unsigned long)val);
			break;
		case 32:
			putLong(buf, -(unsigned long)val);
			break;
		default:
			warning("Unexpected integer size: %d", size);
			break;
		}
	else
		switch (size) {
		case 8:
			*buf = (u_int8_t)val;
			break;
		case 16:
			putUShort(buf, (u_int16_t)val);
			break;
		case 32:
			putULong(buf, val);
			break;
		default:
			warning("Unexpected integer size: %d", size);
			break;
		}
}

/*
 * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER
 *		NUMBER COLON NUMBER COLON NUMBER SEMI
 *
 * Dates are always in GMT; first number is day of week; next is
 * year/month/day; next is hours:minutes:seconds on a 24-hour
 * clock.
 */
time_t
parse_date(FILE *cfile)
{
	static int months[11] = { 31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334 };
	int guess, token;
	struct tm tm;
	char *val;

	/* Day of week... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of week expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_wday = atoi(val);

	/* Year... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric year expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_year = atoi(val);
	if (tm.tm_year > 1900)
		tm.tm_year -= 1900;

	/* Slash separating year from month... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating year from month.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Month... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_mon = atoi(val) - 1;

	/* Slash separating month from day... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating month from day.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Day... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_mday = atoi(val);

	/* Hour... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric hour expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_hour = atoi(val);

	/* Colon separating hour from minute... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating hour from minute.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Minute... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric minute expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_min = atoi(val);

	/* Colon separating minute from second... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating minute from second.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Second... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric second expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_sec = atoi(val);
	tm.tm_isdst = 0;

	/* XXX: We assume that mktime does not use tm_yday. */
	tm.tm_yday = 0;

	/* Make sure the date ends in a semicolon... */
	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return (0);
	}

	/* Guess the time value... */
	guess = ((((((365 * (tm.tm_year - 70) +	/* Days in years since '70 */
	    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
	    (tm.tm_mon			/* Days in months this year */
	    ? months[tm.tm_mon - 1] : 0) +
	    (tm.tm_mon > 1 &&		/* Leap day this year */
	    !((tm.tm_year - 72) & 3)) +
	    tm.tm_mday - 1) * 24) +	/* Day of month */
	    tm.tm_hour) * 60) + tm.tm_min) * 60) + tm.tm_sec;

	/*
	 * This guess could be wrong because of leap seconds or other
	 * weirdness we don't know about that the system does.   For
	 * now, we're just going to accept the guess, but at some point
	 * it might be nice to do a successive approximation here to get
	 * an exact value.   Even if the error is small, if the server
	 * is restarted frequently (and thus the lease database is
	 * reread), the error could accumulate into something
	 * significant.
	 */
	return (guess);
}
@


1.4
log
@merge fdisk, dhcp stuff
fix fdisk units
@
text
@d1 1
a1 2
/**	$MirOS: src/sbin/dhclient/parse.c,v 1.3 2005/11/23 16:43:52 tg Exp $ */
/*	$OpenBSD: parse.c,v 1.14 2006/04/18 19:17:54 deraadt Exp $	*/
d46 1
a46 1
__RCSID("$MirOS: src/sbin/dhclient/parse.c,v 1.3 2005/11/23 16:43:52 tg Exp $");
d48 2
a49 1
/* Skip to the semicolon ending the current statement.   If we encounter
d66 3
a68 2
	int brace_count = 0, token;
	char *val;
d133 2
a134 1
	if (!parse_semi(cfile))
d136 1
d197 1
a197 1
	uint32_t tmp;
d237 1
a237 1
	};
d415 1
a415 1
	/* Month... */
d457 1
a457 1
		parse_warn("expected colon separating hour from minute.");
d463 1
a463 1
	/* Minute... */
d466 1
a466 1
		parse_warn("numeric minute expected.");
d487 7
a493 9
		    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
		    (tm.tm_mon			/* Days in months this year */
		    ? months[tm.tm_mon - 1]
		    : 0) +
		    (tm.tm_mon > 1 &&		/* Leap day this year */
		    !((tm.tm_year - 72) & 3)) +
		    tm.tm_mday - 1) * 24) +	/* Day of month */
		    tm.tm_hour) * 60) +
		    tm.tm_min) * 60) + tm.tm_sec;
@


1.3
log
@fastmerge
@
text
@d1 2
a2 2
/**	$MirOS: src/sbin/dhclient/parse.c,v 1.2 2005/03/06 19:49:50 tg Exp $ */
/*	$OpenBSD: parse.c,v 1.13 2005/07/17 19:33:55 krw Exp $	*/
d47 1
a47 1
__RCSID("$MirOS: src/sbin/dhclient/parse.c,v 1.2 2005/03/06 19:49:50 tg Exp $");
d71 1
a71 1
		if (token == RBRACE) {
d78 1
a78 1
		} else if (token == LBRACE) {
d80 1
a80 1
		} else if (token == SEMI && !brace_count) {
d104 1
a104 1
	if (token != SEMI) {
d122 1
a122 1
	if (token != STRING) {
d141 1
a141 1
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, DOT,
d157 1
a157 1
	case ETHERNET:
d161 1
a161 1
	case TOKEN_RING:
d165 1
a165 1
	case FDDI:
d176 1
a176 1
	    COLON, 16) == 0)
d180 1
a180 1
	if (token != SEMI) {
d197 1
a197 1
	if (token != NUMBER) {
d229 1
a229 1
		if (token == NUMBER || (base == 16 && token == NUMBER_OR_NAME))
d364 1
a364 1
	if (token != NUMBER) {
d366 1
a366 1
		if (token != SEMI)
d374 1
a374 1
	if (token != NUMBER) {
d376 1
a376 1
		if (token != SEMI)
d386 1
a386 1
	if (token != SLASH) {
d388 1
a388 1
		if (token != SEMI)
d395 1
a395 1
	if (token != NUMBER) {
d397 1
a397 1
		if (token != SEMI)
d405 1
a405 1
	if (token != SLASH) {
d407 1
a407 1
		if (token != SEMI)
d414 1
a414 1
	if (token != NUMBER) {
d416 1
a416 1
		if (token != SEMI)
d424 1
a424 1
	if (token != NUMBER) {
d426 1
a426 1
		if (token != SEMI)
d434 1
a434 1
	if (token != COLON) {
d436 1
a436 1
		if (token != SEMI)
d443 1
a443 1
	if (token != NUMBER) {
d445 1
a445 1
		if (token != SEMI)
d453 1
a453 1
	if (token != COLON) {
d455 1
a455 1
		if (token != SEMI)
d462 1
a462 1
	if (token != NUMBER) {
d464 1
a464 1
		if (token != SEMI)
d476 1
a476 1
	if (token != SEMI) {
@


1.2
log
@merge src/sbin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: parse.c,v 1.11 2004/05/05 23:07:47 deraadt Exp $	*/
d47 1
a47 1
__RCSID("$MirOS$");
d141 2
a142 4
	if (parse_numeric_aggregate(cfile, addr->iabuf,
	    &addr->len, DOT, 10, 8))
		return (1);
	return (0);
d152 1
a152 2
	unsigned char *t;
	int token, hlen;
d159 1
d163 1
d167 1
d175 2
a176 12
	/*
	 * Parse the hardware address information.   Technically, it
	 * would make a lot of sense to restrict the length of the data
	 * we'll accept here to the length of a particular hardware
	 * address type.   Unfortunately, there are some broken clients
	 * out there that put bogus data in the chaddr buffer, and we
	 * accept that data in the lease file rather than simply failing
	 * on such clients.   Yuck.
	 */
	hlen = 0;
	t = parse_numeric_aggregate(cfile, NULL, &hlen, COLON, 16, 8);
	if (!t)
a177 12
	if (hlen > sizeof(hardware->haddr)) {
		free(t);
		parse_warn("hardware address too long");
	} else {
		hardware->hlen = hlen;
		memcpy((unsigned char *)&hardware->haddr[0], t,
		    hardware->hlen);
		if (hlen < sizeof(hardware->haddr))
			memset(&hardware->haddr[hlen], 0,
			    sizeof(hardware->haddr) - hlen);
		free(t);
	}
d210 2
a211 6
 * No BNF for numeric aggregates - that's defined by the caller.  What
 * this function does is to parse a sequence of numbers separated by the
 * token specified in separator.  If max is zero, any number of numbers
 * will be parsed; otherwise, exactly max numbers are expected.  Base
 * and size tell us how to internalize the numbers once they've been
 * tokenized.
d213 3
a215 3
unsigned char *
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int *max,
    int separator, int base, int size)
d217 2
a218 11
	unsigned char *bufp = buf, *s = NULL;
	int token, count = 0;
	char *val, *t;
	pair c = NULL;

	if (!bufp && *max) {
		bufp = malloc(*max * size / 8);
		if (!bufp)
			error("can't allocate space for numeric aggregate");
	} else
		s = bufp;
d220 5
a224 13
	do {
		if (count) {
			token = peek_token(&val, cfile);
			if (token != separator) {
				if (!*max)
					break;
				if (token != RBRACE && token != LBRACE)
					token = next_token(&val, cfile);
				parse_warn("too few numbers.");
				if (token != SEMI)
					skip_to_semi(cfile);
				return (NULL);
			}
d226 1
a226 1
		}
d229 4
a232 2
		if (token == EOF) {
			parse_warn("unexpected end of file");
d234 1
a234 1
		}
d236 4
a239 22
		/* Allow NUMBER_OR_NAME if base is 16. */
		if (token != NUMBER &&
		    (base != 16 || token != NUMBER_OR_NAME)) {
			parse_warn("expecting numeric value.");
			skip_to_semi(cfile);
			return (NULL);
		}
		/*
		 * If we can, convert the number now; otherwise, build a
		 * linked list of all the numbers.
		 */
		if (s) {
			convert_num(s, val, base, size);
			s += size / 8;
		} else {
			t = malloc(strlen(val) + 1);
			if (!t)
				error("no temp space for number.");
			strlcpy(t, val, strlen(val) + 1);
			c = cons(t, c);
		}
	} while (++count != *max);
d241 1
a241 18
	/* If we had to cons up a list, convert it now. */
	if (c) {
		bufp = malloc(count * size / 8);
		if (!bufp)
			error("can't allocate space for numeric aggregate.");
		s = bufp + count - size / 8;
		*max = count;
	}
	while (c) {
		pair cdr = c->cdr;
		convert_num(s, (char *)c->car, base, size);
		s -= size / 8;
		/* Free up temp space. */
		free(c->car);
		free(c);
		c = cdr;
	}
	return (bufp);
d368 1
a368 1
		return 0;
d378 1
a378 1
		return 0;
d390 1
a390 1
		return 0;
d399 1
a399 1
		return 0;
d409 1
a409 1
		return 0;
d418 1
a418 1
		return 0;
d428 1
a428 1
		return 0;
d438 1
a438 1
		return 0;
d447 1
a447 1
		return 0;
d457 1
a457 1
		return 0;
d466 1
a466 1
		return 0;
d479 1
a479 1
		return 0;
@


1.1
log
@Initial revision
@
text
@d1 1
d47 2
d216 1
d224 1
a224 1
	convert_num((unsigned char *)timep, val, 10, 32);
d226 1
a226 1
	*timep = ntohl(*timep); /* XXX */
d444 1
a444 1
		return (NULL);
d454 1
a454 1
		return (NULL);
d466 1
a466 1
		return (NULL);
d475 1
a475 1
		return (NULL);
d485 1
a485 1
		return (NULL);
d494 1
a494 1
		return (NULL);
d504 1
a504 1
		return (NULL);
d514 1
a514 1
		return (NULL);
d523 1
a523 1
		return (NULL);
d533 1
a533 1
		return (NULL);
d542 1
a542 1
		return (NULL);
d555 1
a555 1
		return (NULL);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 2005/07/17 19:33:55 krw Exp $	*/
d138 4
a141 2
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, DOT,
	    10));
d151 2
a152 1
	int token;
a158 1
		hardware->hlen = 6;
a161 1
		hardware->hlen = 6;
a164 1
		hardware->hlen = 6;
d172 12
a183 2
	if (parse_numeric_aggregate(cfile, hardware->haddr, hardware->hlen,
	    COLON, 16) == 0)
d185 12
d228 6
a233 2
 * Parse a sequence of numbers separated by the token specified in separator.
 * Exactly max numbers are expected.
d235 3
a237 3
int
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int max, int separator,
    int base)
d239 11
a249 2
	char *val;
	int token, count;
d251 13
a263 5
	if (buf == NULL || max == 0)
		error("no space for numeric aggregate");

	for (count = 0; count < max; count++, buf++) {
		if (count && (peek_token(&val, cfile) == separator))
d265 1
a265 1

d268 2
a269 4
		if (token == NUMBER || (base == 16 && token == NUMBER_OR_NAME))
			/* XXX Need to check if conversion was successful. */
			convert_num(buf, val, base, 8);
		else
d271 1
a271 1
	};
d273 39
a311 3
	if (count < max) {
		parse_warn("numeric aggregate too short.");
		return (0);
d313 1
a313 2

	return (1);
d440 1
a440 1
		return (0);
d450 1
a450 1
		return (0);
d462 1
a462 1
		return (0);
d471 1
a471 1
		return (0);
d481 1
a481 1
		return (0);
d490 1
a490 1
		return (0);
d500 1
a500 1
		return (0);
d510 1
a510 1
		return (0);
d519 1
a519 1
		return (0);
d529 1
a529 1
		return (0);
d538 1
a538 1
		return (0);
d551 1
a551 1
		return (0);
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 2006/04/18 19:17:54 deraadt Exp $	*/
d68 1
a68 1
		if (token == '}') {
d75 1
a75 1
		} else if (token == '{') {
d77 1
a77 1
		} else if (token == ';' && !brace_count) {
d101 1
a101 1
	if (token != ';') {
d119 1
a119 1
	if (token != TOK_STRING) {
d138 1
a138 1
	return (parse_numeric_aggregate(cfile, addr->iabuf, addr->len, '.',
d154 1
a154 1
	case TOK_ETHERNET:
d158 1
a158 1
	case TOK_TOKEN_RING:
d162 1
a162 1
	case TOK_FDDI:
d173 1
a173 1
	    ':', 16) == 0)
d177 1
a177 1
	if (token != ';') {
d193 1
a193 1
	if (token != TOK_NUMBER) {
d225 1
a225 1
		if (token == TOK_NUMBER || (base == 16 && token == TOK_NUMBER_OR_NAME))
d360 1
a360 1
	if (token != TOK_NUMBER) {
d362 1
a362 1
		if (token != ';')
d370 1
a370 1
	if (token != TOK_NUMBER) {
d372 1
a372 1
		if (token != ';')
d382 1
a382 1
	if (token != '/') {
d384 1
a384 1
		if (token != ';')
d391 1
a391 1
	if (token != TOK_NUMBER) {
d393 1
a393 1
		if (token != ';')
d401 1
a401 1
	if (token != '/') {
d403 1
a403 1
		if (token != ';')
d410 1
a410 1
	if (token != TOK_NUMBER) {
d412 1
a412 1
		if (token != ';')
d420 1
a420 1
	if (token != TOK_NUMBER) {
d422 1
a422 1
		if (token != ';')
d430 1
a430 1
	if (token != ':') {
d432 1
a432 1
		if (token != ';')
d439 1
a439 1
	if (token != TOK_NUMBER) {
d441 1
a441 1
		if (token != ';')
d449 1
a449 1
	if (token != ':') {
d451 1
a451 1
		if (token != ';')
d458 1
a458 1
	if (token != TOK_NUMBER) {
d460 1
a460 1
		if (token != ';')
d472 1
a472 1
	if (token != ';') {
@


1.1.1.4
log
@Import spamd and dhclient from OpenBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.18 2007/01/08 13:34:38 krw Exp $	*/
d46 1
a46 2
/*
 * Skip to the semicolon ending the current statement.   If we encounter
d63 2
a64 3
	int		 token;
	char		*val;
	int		 brace_count = 0;
d129 1
a129 2
	if (!parse_semi(cfile)) {
		free(s);
a130 1
	}
d200 1
a200 1
	*timep = ntohl(*timep);	/* XXX */
d230 1
a230 1
	}
d408 1
a408 1
	/* Day... */
d450 1
a450 1
		parse_warn("expected colon separating minute from second.");
d456 1
a456 1
	/* Second... */
d459 1
a459 1
		parse_warn("numeric second expected.");
d480 9
a488 7
	    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
	    (tm.tm_mon			/* Days in months this year */
	    ? months[tm.tm_mon - 1] : 0) +
	    (tm.tm_mon > 1 &&		/* Leap day this year */
	    !((tm.tm_year - 72) & 3)) +
	    tm.tm_mday - 1) * 24) +	/* Day of month */
	    tm.tm_hour) * 60) + tm.tm_min) * 60) + tm.tm_sec;
@


