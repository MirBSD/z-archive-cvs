head	1.9;
access;
symbols
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.10.09.21.26.07;	author tg;	state Exp;
branches;
next	1.8;
commitid	10057FAB5FF6634B3B1;

1.8
date	2015.10.05.17.51.19;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005612B8A15FFBE11C;

1.7
date	2014.10.16.20.03.59;	author tg;	state Exp;
branches;
next	1.6;
commitid	100544024852D88C0CC;

1.6
date	2014.03.12.23.16.52;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005320EADE31197977;

1.5
date	2012.08.24.18.08.03;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005037C2E85CD2DC77;

1.4
date	2012.07.14.12.06.55;	author tg;	state Exp;
branches;
next	1.3;
commitid	100500160B800C0B996;

1.3
date	2011.02.19.14.41.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004D5FD6AD4C707315;

1.2
date	2007.05.29.08.19.30;	author tg;	state Exp;
branches;
next	1.1;
commitid	100465BE20D49DF40AF;

1.1
date	2005.02.05.17.26.42;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.42;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.57.29;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.9
log
@let randshuffle behave a bit more notrunc
@
text
@/*	$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $	*/
/*	$NetBSD: reboot.c,v 1.8 1995/10/05 05:36:22 mycroft Exp $	*/

/*
 * Copyright (c) 2011, 2014, 2015, 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/reboot.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <dev/rndioctl.h>
#include <signal.h>
#include <pwd.h>
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <termios.h>
#include <syslog.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <util.h>
#include "pathnames.h"

__COPYRIGHT("@@(#) Copyright (c) 1980, 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n");
__SCCSID("@@(#)reboot.c	8.1 (Berkeley) 6/5/93");
__RCSID("$MirOS: src/sbin/reboot/reboot.c,v 1.6 2014/03/12 23:16:52 tg Exp $");

extern const char *__progname;
extern void arc4random_atexit(void);

static void
pull_console(bool do_setsid)
{
	int fd;
	struct termios t;

	if (revoke(_PATH_CONSOLE) == -1)
		warn("revoke");
	if (do_setsid) {
		if (setsid() == -1)
			warn("setsid");
	}
	fd = open(_PATH_CONSOLE, O_RDWR);
	if (fd == -1)
		warn("open");
	dup2(fd, 0);
	dup2(fd, 1);
	dup2(fd, 2);
	if (fd > 2)
		close(fd);

	/* At a minimum... */
	tcgetattr(0, &t);
	t.c_oflag |= (ONLCR | OPOST);
	tcsetattr(0, TCSANOW, &t);
}

int
main(int argc, char *argv[])
{
	int i, ch, howto, rnd_fd, arnd_fd;
	struct passwd *pw;
	bool dohalt, lflag, nflag, pflag, qflag;
	const char *p, *user;
	char rnd_buf[128];
	static const int death_sigs[7] = {
		SIGHUP, SIGTERM, SIGKILL, SIGKILL, SIGKILL, SIGKILL, SIGKILL
	};

	if (chdir("/"))
		warn("chdir(\"/\")");

	p = __progname;

	/* Nuke login shell */
	if (*p == '-')
		p++;

	howto = 0;
	dohalt = lflag = nflag = pflag = qflag = false;
	if (!strcmp(p, "halt")) {
		dohalt = true;
		howto = RB_HALT;
	}

	while ((ch = getopt(argc, argv, "dlnpq")) != -1)
		switch (ch) {
		case 'd':
			howto |= RB_DUMP;
			break;
		case 'l':	/* Undocumented; used by shutdown. */
			lflag = true;
			break;
		case 'n':
			nflag = true;
			howto |= RB_NOSYNC;
			break;
		case 'p':
			/* Only works if we're called as halt. */
			if (dohalt) {
				pflag = true;
				howto |= RB_POWERDOWN;
			}
			break;
		case 'q':
			qflag = true;
			break;
		default:
			goto usage;
		}
	argc -= optind;
	argv += optind;

	if (argc)
		goto usage;

	if (geteuid())
		errx(1, "%s", strerror(EPERM));

	if (qflag) {
		reboot(howto);
		err(1, "reboot");
	}

	/* Log the reboot. */
	if (!lflag)  {
		if ((user = getlogin()) == NULL)
			user = (pw = getpwuid(getuid())) ?
			    pw->pw_name : "???";
		if (dohalt) {
			openlog("halt", 0, LOG_AUTH | LOG_CONS);
			if (pflag) {
				syslog(LOG_CRIT,
					"halted (with powerdown) by %s", user);
			} else {
				syslog(LOG_CRIT, "halted by %s", user);
			}
		} else {
			openlog("reboot", 0, LOG_AUTH | LOG_CONS);
			syslog(LOG_CRIT, "rebooted by %s", user);
		}
	}
	logwtmp("~", "shutdown", "");

	/*
	 * Do a sync early on, so disks start transfers while we're off
	 * killing processes.  Don't worry about writes done before the
	 * processes die, the reboot system call syncs the disks.
	 */
	if (!nflag)
		sync();

	/* Just stop init -- if we fail, we'll restart it. */
	if (kill(1, SIGTSTP) == -1)
		err(1, "SIGTSTP init");

	/* Ignore the SIGHUP we get when our parent shell dies. */
	(void)signal(SIGHUP, SIG_IGN);

	/*
	 * If we're running in a pipeline, we don't want to die
	 * after killing whatever we're writing to.
	 */
	(void)signal(SIGPIPE, SIG_IGN);

	if (access(_PATH_RUNCOM, R_OK) != -1) {
		pid_t pid;

		switch ((pid = fork())) {
		case -1:
			break;
		case 0:
			pull_console(true);
			execl(_PATH_BSHELL, "sh", _PATH_RUNCOM, "shutdown", (char *)NULL);
			_exit(1);
		default:
			waitpid(pid, NULL, 0);
		}
	}

	pull_console(false);
	arnd_fd = open(_PATH_ARANDOMDEV, O_RDWR);
	rnd_fd = open(_PATH_HOSTRANDOM, O_WRONLY | O_APPEND | O_SYNC);

	for (i = 0; i < 7; ++i) {
		warnx("Sending SIG%s to all processes...",
		    sys_signame[death_sigs[i]]);

		if (kill(-1, death_sigs[i]) == -1) {
			if (errno != ESRCH) {
				warn("signalling processes");
				goto restart;
			}
			if (i > 1)
				/* terminate loop after SIGKILL */
				i = 10;
		}

		if (i == 0) {
			sleep(2);
			if (!nflag)
				sync();
		} else if (i == 1) {
			sleep(3);
		} else if (i == 10) {
			sleep(1);
		} else {
			sleep(2 * (i - 2));
		}

		if (arnd_fd != -1)
			/* reset lopool, arandom */
			ioctl(arnd_fd, RNDSTIRARC4);
		if (rnd_fd != -1) {
			if (arnd_fd != -1)
				read(arnd_fd, rnd_buf, sizeof(rnd_buf));
			else
				arc4random_buf(rnd_buf, sizeof(rnd_buf));
			write(rnd_fd, rnd_buf, sizeof(rnd_buf));
		}
	}

	if (i == 7)
		warnx("WARNING: some process(es) wouldn't die");

	if (rnd_fd != -1)
		close(rnd_fd);
	arc4random_atexit();
	if (arnd_fd != -1) {
		ioctl(arnd_fd, RNDSTIRARC4);
		close(arnd_fd);
	}

	reboot(howto);
	/* FALLTHROUGH */

 restart:
	errx(1, kill(1, SIGHUP) == -1 ? "(can't restart init): " : "");
	/* NOTREACHED */

 usage:
	fprintf(stderr, "usage: %s [-dn%sq]\n", __progname,
	    dohalt ? "p" : "");
	return (1);
}
@


1.8
log
@this utility is never invoked setuid, drop useless -p flag
@
text
@d5 1
a5 1
 * Copyright (c) 2011, 2014, 2015
d98 1
a98 1
	char rnd_buf[512];
@


1.7
log
@fix execution of /etc/rc with euid=0 for suid-root shutdown with fixed mksh
@
text
@d5 2
a6 2
 * Copyright (c) 2011, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
d207 1
a207 1
			execl(_PATH_BSHELL, "sh", "-p", _PATH_RUNCOM, "shutdown", (char *)NULL);
@


1.6
log
@stop using arc4random_stir; use arc4random_atexit before RNDSTIRARC4 instead
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/sbin/reboot/reboot.c,v 1.5 2012/08/24 18:08:03 tg Exp $");
d207 1
a207 1
			execl(_PATH_BSHELL, "sh", _PATH_RUNCOM, "shutdown", (char *)NULL);
@


1.5
log
@that wasn't the cause, revert cid 100500160B800C0B996

maybe one of the RAIDframe kernel helper processes gets sent the signals
and doesn't handle them?
@
text
@d5 1
a5 1
 * Copyright (c) 2011
d59 1
a59 1
__RCSID("$MirOS: src/sbin/reboot/reboot.c,v 1.2 2007/05/29 08:19:30 tg Exp $");
d62 1
a216 1
	ch = 3;
a243 4
		if (!ch)
			/* three writes already done */
			continue;

a252 1
			--ch;
a254 2
	/* we need four writes in total, though */
	++ch;
d259 3
a265 8
	if (rnd_fd != -1) {
		arc4random_stir();
		while (ch--) {
			arc4random_buf(rnd_buf, sizeof(rnd_buf));
			write(rnd_fd, rnd_buf, sizeof(rnd_buf));
		}
		close(rnd_fd);
	}
@


1.4
log
@for now, don’t send SIGHUP on reboot, until the crash is diagnosed
@
text
@d5 1
a5 1
 * Copyright (c) 2011, 2012
d59 1
a59 1
__RCSID("$MirOS: src/sbin/reboot/reboot.c,v 1.3 2011/02/19 14:41:39 tg Exp $");
d99 1
a99 6
#ifdef notyet /* weirdly enough, herc crashes hard since we did that */
		SIGHUP,
#else
		SIGTERM,
#endif
		SIGTERM, SIGKILL, SIGKILL, SIGKILL, SIGKILL, SIGKILL
@


1.3
log
@• kernel: merge rnd_flush() declarations into <randimpl.h>
• randomioctl: let RNDSTIRARC4 invoke rnd_flush() if called from init(8)
• init, reboot/halt: use unified "pathnames.h"
• init: use RNDSTIRARC4 to reset all pools (lopool, arc4random) on halt
• init: write 2048 bytes to /var/db/host.random to make it an even 8 KiB
• init: redesign code for that, minimise sleep calls, tested with tempo-
  rary printf/warning/etc. calls in userspace and kernel
• init: upon SIGTSTP, invoke RNDSTIRARC4 to help halt/reboot
• halt/reboot: do similar things like init wrt. signals, output, seed file
@
text
@d5 1
a5 1
 * Copyright (c) 2011
d59 1
a59 1
__RCSID("$MirOS: src/sbin/reboot/reboot.c,v 1.2 2007/05/29 08:19:30 tg Exp $");
d99 6
a104 1
		SIGHUP, SIGTERM, SIGKILL, SIGKILL, SIGKILL, SIGKILL, SIGKILL
@


1.2
log
@• chdir to / before shutdowning, to avoid umount failures…
• rcsids, __CRAZY=Yes cleanup, etc. while here
@
text
@d5 2
d38 1
d40 1
d49 1
a52 1
#include <paths.h>
d54 1
d59 1
a59 2
__RCSID("$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $");
__RCSID("$MirOS$");
a60 1
void usage(void) __dead;
d63 5
a67 1
int	dohalt;
d69 20
a88 1
#define _PATH_RC	"/etc/rc"
d93 1
a93 1
	int i;
d95 1
a95 1
	int ch, howto, lflag, nflag, pflag, qflag;
d97 4
d111 2
a112 1
	howto = dohalt = lflag = nflag = pflag = qflag = 0;
d114 1
a114 1
		dohalt = 1;
d124 1
a124 1
			lflag = 1;
d127 1
a127 1
			nflag = 1;
d133 1
a133 1
				pflag = 1;
d138 1
a138 1
			qflag = 1;
d141 1
a141 1
			usage();
d147 1
a147 1
		usage();
d198 1
a198 1
	if (access(_PATH_RC, R_OK) != -1) {
a199 2
		struct termios t;
		int fd;
d205 2
a206 19
			if (revoke(_PATH_CONSOLE) == -1)
				warn("revoke");
			if (setsid() == -1)
				warn("setsid");
			fd = open(_PATH_CONSOLE, O_RDWR);
			if (fd == -1)
				warn("open");
			dup2(fd, 0);
			dup2(fd, 1);
			dup2(fd, 2);
			if (fd > 2)
				close(fd);

			/* At a minimum... */
			tcgetattr(0, &t);
			t.c_oflag |= (ONLCR | OPOST);
			tcsetattr(0, TCSANOW, &t);

			execl(_PATH_BSHELL, "sh", _PATH_RC, "shutdown", (char *)NULL);
d213 45
a257 10
	/* Send a SIGTERM first, a chance to save the buffers. */
	if (kill(-1, SIGTERM) == -1) {
		/*
		 * If ESRCH, everything's OK: we're the only non-system
		 * process!  That can happen e.g. via 'exec reboot' in
		 * single-user mode.
		 */
		if (errno != ESRCH) {
			warn("SIGTERM processes");
			goto restart;
d260 2
d263 2
a264 9
	/*
	 * After the processes receive the signal, start the rest of the
	 * buffers on their way.  Wait 5 seconds between the SIGTERM and
	 * the SIGKILL to give everybody a chance.
	 */
	sleep(2);
	if (!nflag)
		sync();
	sleep(3);
d266 9
a274 5
	for (i = 1;; ++i) {
		if (kill(-1, SIGKILL) == -1) {
			if (errno == ESRCH)
				break;
			goto restart;
d276 1
a276 5
		if (i > 5) {
			warnx("WARNING: some process(es) wouldn't die");
			break;
		}
		(void)sleep(2 * i);
d282 1
a282 1
restart:
a284 1
}
d286 1
a286 3
void
usage(void)
{
d289 1
a289 1
	exit(1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.25 2003/06/02 20:06:16 millert Exp $	*/
a32 14
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)reboot.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: reboot.c,v 1.25 2003/06/02 20:06:16 millert Exp $";
#endif
#endif /* not lint */

d51 10
a60 2
void usage(void);
extern char *__progname;
d69 5
a73 2
	int ch, howto, dohalt, lflag, nflag, pflag, qflag, sverrno;
	char *p, *user;
d78 2
a79 1
	if(*p == '-') p++;
d88 1
a88 1
		switch(ch) {
d92 1
a92 1
		case 'l':		/* Undocumented; used by shutdown. */
a108 1
		case '?':
d115 3
a240 1
	sverrno = errno;
d248 2
a249 1
	(void)fprintf(stderr, "usage: %s [-dlnpq]\n", __progname);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: reboot.c,v 1.26 2004/07/09 18:49:57 deraadt Exp $";
d65 1
a65 1
void	usage(void);
a67 2
int	dohalt;

d75 1
a75 1
	int ch, howto, lflag, nflag, pflag, qflag;
d81 1
a81 2
	if (*p == '-')
		p++;
d90 1
a90 1
		switch (ch) {
d94 1
a94 1
		case 'l':	/* Undocumented; used by shutdown. */
d111 1
a117 3
	if (argc)
		usage();

d241 1
d249 1
a249 2
	fprintf(stderr, "usage: %s [-dn%sq]\n", __progname,
	    dohalt ? "p" : "");
@

