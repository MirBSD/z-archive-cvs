head	1.2;
access;
symbols
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.07.14.21.03.48;	author tg;	state Exp;
branches;
next	1.1;
commitid	10046993A465B2DE8DC;

1.1
date	2005.02.05.17.26.38;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.38;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.57.20;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.2
log
@add a quiet mode for list
@
text
@/*	$OpenBSD: kbd_wscons.c,v 1.23 2005/05/07 15:31:23 miod Exp $ */

/*
 * Copyright (c) 2001 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>

#include <err.h>
#include <errno.h>
#include <kvm.h>
#include <fcntl.h>
#include <limits.h>
#include <nlist.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

__RCSID("$MirOS$");

#define	NUM_KBD	10

const char *kbtype_tab[] = {
	"pc-xt/pc-at",
	"usb",
	"adb",
	"lk201",
	"sun",
	"sun5",
	"hil",
	"gsc",
	"domain"
};
enum {	SA_PCKBD,
	SA_UKBD,
	SA_AKBD,
	SA_ZSKBD,
	SA_SUNKBD,
	SA_SUN5KBD,
	SA_HILKBD,
	SA_GSCKBD,
	SA_DOMAINKBD,

	SA_MAX
};

#ifndef NOKVM
struct nlist nl[] = {
	{ "_pckbd_keydesctab" },
	{ "_ukbd_keydesctab" },
	{ "_akbd_keydesctab" },
	{ "_zskbd_keydesctab" },
	{ "_sunkbd_keydesctab" },
	{ "_sunkbd5_keydesctab" },
	{ "_hilkbd_keydesctab" },
	{ "_gsckbd_keydesctab" },
	{ "_dnkbd_keydesctab" },
	{ NULL },
};
#endif /* NOKVM */

int rebuild = 0;

struct nameint {
	int value;
	const char *name;
};

struct nameint kbdenc_tab[] = {
	KB_ENCTAB
	,
	{ 0, 0 }
};

struct nameint kbdvar_tab[] = {
	KB_VARTAB
	,
	{ 0, 0 }
};

extern const char *__progname;

static void kbd_show_enc(kvm_t *, int, int);
void	kbd_list(int);
void	kbd_set(char *name, int verbose);

void
kbd_show_enc(kvm_t *kd, int idx, int v)
{
#ifndef NOKVM
	struct wscons_keydesc r;
	unsigned long p;
	int found;
	u_int32_t variant;
	struct nameint *n;
#else
	int i;
#endif /* NOKVM */

#ifndef NOKVM
	p = nl[idx].n_value;
	if (p == 0) {
		if (v)
			printf("no tables available for %s keyboard\n\n",
			    kbtype_tab[idx]);
		return;
	}
#endif

	if (v)
		printf("tables available for %s keyboard:\nencoding\n\n",
		    kbtype_tab[idx]);

#ifdef NOKVM
	for (i = 0; kbdenc_tab[i].value; i++)
		printf("%s\n", kbdenc_tab[i].name);
#else
	kvm_read(kd, p, &r, sizeof(r));
	while (r.name != 0) {
		n = &kbdenc_tab[0];
		found = 0;
		while (n->value) {
			if (n->value == KB_ENCODING(r.name)) {
				printf("%s",n->name);
				found++;
			}
			n++;
		}
		if (found == 0) {
			printf("<encoding 0x%04x>",KB_ENCODING(r.name));
			rebuild++;
		}
		n = &kbdvar_tab[0];
		found = 0;
		variant = KB_VARIANT(r.name);
		while (n->value) {
			if ((n->value & KB_VARIANT(r.name)) == n->value) {
				printf(".%s",n->name);
				variant &= ~n->value;
			}
			n++;
		}
		if (variant != 0) {
			printf(".<variant 0x%08x>",variant);
			rebuild++;
		}
		printf("\n");
		p += sizeof(r);
		kvm_read(kd, p, &r, sizeof(r));
	}
#endif
	if (v)
		printf("\n");
}

void
kbd_list(int vb)
{
	int	kbds[SA_MAX];
	int	fd, i, kbtype;
	char	device[MAXPATHLEN];
	kvm_t	*kd = NULL;
#ifndef NOKVM
	char	errbuf[LINE_MAX];
#endif

	bzero(kbds, sizeof(kbds));

	/* Go through all keyboards. */
	for (i = 0; i < NUM_KBD; i++) {
		(void) snprintf(device, sizeof device, "/dev/wskbd%d", i);
		fd = open(device, O_WRONLY);
		if (fd < 0)
			fd = open(device, O_RDONLY);
		if (fd >= 0) {
			if (ioctl(fd, WSKBDIO_GTYPE, &kbtype) < 0)
				err(1, "WSKBDIO_GTYPE");
			switch (kbtype) {
			case WSKBD_TYPE_PC_XT:
			case WSKBD_TYPE_PC_AT:
				kbds[SA_PCKBD]++;
				break;
			case WSKBD_TYPE_USB:
				kbds[SA_UKBD]++;
				break;
			case WSKBD_TYPE_ADB:
				kbds[SA_AKBD]++;
				break;
			case WSKBD_TYPE_LK201:
				kbds[SA_ZSKBD]++;
				break;
			case WSKBD_TYPE_SUN:
				kbds[SA_SUNKBD]++;
				break;
			case WSKBD_TYPE_SUN5:
				kbds[SA_SUN5KBD]++;
				break;
			case WSKBD_TYPE_HIL:
				kbds[SA_HILKBD]++;
				break;
			case WSKBD_TYPE_GSC:
				kbds[SA_GSCKBD]++;
				break;
			case WSKBD_TYPE_DOMAIN:
				kbds[SA_DOMAINKBD]++;
				break;
			};
			close(fd);
		}
	}

#ifndef NOKVM
	if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == 0)
		errx(1, "kvm_openfiles: %s", errbuf);

	if (kvm_nlist(kd, nl) == -1)
		errx(1, "kvm_nlist: %s", kvm_geterr(kd));
#endif

	for (i = 0; i < SA_MAX; i++)
		if (kbds[i] != 0)
			kbd_show_enc(kd, i, vb);

#ifndef NOKVM
	kvm_close(kd);
#endif
	if (rebuild > 0 && vb)
		printf("Unknown encoding or variant. kbd(8) needs to be rebuilt.\n");
}

void
kbd_set(char *name, int verbose)
{
	char	buf[LINE_MAX], *c, *b, device[sizeof "/dev/wskbd00"];
	int	map = 0, v, i, fd;
	struct nameint *n;

	c = name;
	b = buf;
	while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
		*b++ = *c++;
	*b = '\0';
	n = &kbdenc_tab[0];
	while (n->value) {
		if (strcmp(n->name, buf) == 0)
			map = n->value;
		n++;
	}
	if (map == 0)
		errx(1, "unknown encoding %s", buf);
	while (*c == '.') {
		b = buf;
		c++;
		while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
			*b++ = *c++;
		*b = '\0';
		v = 0;
		n = &kbdvar_tab[0];
		while (n->value) {
			if (strcmp(n->name, buf) == 0)
				v = n->value;
			n++;
		}
		if (v == 0)
			errx(1, "unknown variant %s", buf);
		map |= v;
	}

	/* Go through all keyboards. */
	v = 0;
	for (i = 0; i < NUM_KBD; i++) {
		(void) snprintf(device, sizeof device, "/dev/wskbd%d", i);
		fd = open(device, O_WRONLY);
		if (fd < 0)
			fd = open(device, O_RDONLY);
		if (fd >= 0) {
			if (ioctl(fd, WSKBDIO_SETENCODING, &map) < 0) {
				if (errno == EINVAL) {
					fprintf(stderr,
					    "%s: unsupported encoding %s on %s\n",
					    __progname, name, device);
				} else
					err(1, "WSKBDIO_SETENCODING: %s", device);
				v--;
			}
			v++;
			close(fd);
		}
	}

	if (verbose && v > 0)
		fprintf(stderr, "kbd: keyboard mapping set to %s\n", name);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.16 2004/05/09 03:21:52 deraadt Exp $ */
d43 2
d47 23
a69 8
#define SA_PCKBD 0
#define SA_UKBD  1
#define SA_AKBD	 2
#define SA_ZSKBD 3
#define SA_SUNKBD 4
#define SA_SUN5KBD 5
#define SA_HILKBD 6
#define	SA_GSCKBD 7
d71 1
d81 1
d84 1
d86 1
a86 10
char *kbtype_tab[] = {
	"pc-xt/pc-at",
	"usb",
	"adb",
	"lk201",
	"sun",
	"sun5",
	"hil",
	"gsc",
};
d90 1
a90 1
	char *name;
d105 1
a105 2
extern char *__progname;
int rebuild = 0;
d107 2
a108 2
void	kbd_show_enc(kvm_t *kd, int idx);
void	kbd_list(void);
a110 1
#ifndef NOKVM
d112 1
a112 1
kbd_show_enc(kvm_t *kd, int idx)
d114 1
a116 1
	struct nameint *n;
d119 4
d124 1
a124 2
	printf("tables available for %s keyboard:\nencoding\n\n",
	       kbtype_tab[idx]);
d126 16
d175 3
a177 1
	printf("\n");
a178 1
#endif
d181 1
a181 1
kbd_list(void)
d183 1
a184 1
	kvm_t	*kd;
d186 6
a191 9
	char	errbuf[_POSIX2_LINE_MAX];
	int	pc_kbd = 0;
	int	usb_kbd = 0;
	int	adb_kbd = 0;
	int	zs_kbd = 0;
	int	sun_kbd = 0;
	int	sun5_kbd = 0;
	int	hil_kbd = 0;
	int	gsc_kbd = 0;
d202 30
a231 17
			if ((kbtype == WSKBD_TYPE_PC_XT) ||
			    (kbtype == WSKBD_TYPE_PC_AT))
				pc_kbd++;
			if (kbtype == WSKBD_TYPE_USB)
				usb_kbd++;
			if (kbtype == WSKBD_TYPE_ADB)
				adb_kbd++;
			if (kbtype == WSKBD_TYPE_LK201)
				zs_kbd++;
			if (kbtype == WSKBD_TYPE_SUN)
				sun_kbd++;
			if (kbtype == WSKBD_TYPE_SUN5)
				sun5_kbd++;
			if (kbtype == WSKBD_TYPE_HIL)
				hil_kbd++;
			if (kbtype == WSKBD_TYPE_GSC)
				gsc_kbd++;
d242 1
d244 3
a246 23
	if (pc_kbd > 0)
		kbd_show_enc(kd, SA_PCKBD);

	if (usb_kbd > 0)
		kbd_show_enc(kd, SA_UKBD);

	if (adb_kbd > 0)
		kbd_show_enc(kd, SA_AKBD);

	if (zs_kbd > 0)
		kbd_show_enc(kd, SA_ZSKBD);

	if (sun_kbd > 0)
		kbd_show_enc(kd, SA_SUNKBD);

	if (sun5_kbd > 0)
		kbd_show_enc(kd, SA_SUN5KBD);

	if (hil_kbd > 0)
		kbd_show_enc(kd, SA_HILKBD);

	if (gsc_kbd > 0)
		kbd_show_enc(kd, SA_GSCKBD);
d248 1
a249 6

	if (rebuild > 0) {
		printf("Unknown encoding or variant. kbd(1) needs to be rebuilt.\n");
	}
#else
	printf("List not available; sorry.\n");
d251 2
d258 2
a259 2
	char	buf[_POSIX2_LINE_MAX];
	char	*c,*b;
a260 2
	int	map = 0,v,i,fd;
	char	device[sizeof "/dev/wskbd00"];
d264 1
a264 1
	while ((*c != '.') && (*c != '\0')) {
a265 1
	}
d269 1
a269 1
		if (strcmp(n->name,buf) == 0) {
a270 1
		}
d278 1
a278 1
		while ((*c != '.') && (*c != '\0')) {
a279 1
		}
d284 1
a284 1
			if (strcmp(n->name,buf) == 0) {
a285 1
			}
d306 1
a306 1
				} else {
a307 1
				}
d316 1
a316 1
		fprintf(stderr, "keyboard mapping set to %s\n", name);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: kbd_wscons.c,v 1.23 2005/05/07 15:31:23 miod Exp $ */
d45 8
a52 23
char *kbtype_tab[] = {
	"pc-xt/pc-at",
	"usb",
	"adb",
	"lk201",
	"sun",
	"sun5",
	"hil",
	"gsc",
	"domain"
};
enum {	SA_PCKBD,
	SA_UKBD,
	SA_AKBD,
	SA_ZSKBD,
	SA_SUNKBD,
	SA_SUN5KBD,
	SA_HILKBD,
	SA_GSCKBD,
	SA_DOMAINKBD,

	SA_MAX
};
a53 1
#ifndef NOKVM
a62 1
	{ "_dnkbd_keydesctab" },
a64 1
#endif /* NOKVM */
d66 10
a75 1
int rebuild = 0;
d95 1
d101 1
a104 1
#ifndef NOKVM
d107 1
a109 4
	struct nameint *n;
#else
	int i;
#endif /* NOKVM */
d111 2
a112 1
#ifndef NOKVM
a113 14
	if (p == 0) {
		printf("no tables available for %s keyboard\n\n",
		    kbtype_tab[idx]);
		return;
	}
#endif

	printf("tables available for %s keyboard:\nencoding\n\n",
	    kbtype_tab[idx]);

#ifdef NOKVM
	for (i = 0; kbdenc_tab[i].value; i++)
		printf("%s\n", kbdenc_tab[i].name);
#else
a146 1
#endif
d149 1
a153 1
	int	kbds[SA_MAX];
d155 1
d157 9
a165 6
	kvm_t	*kd = NULL;
#ifndef NOKVM
	char	errbuf[LINE_MAX];
#endif

	bzero(kbds, sizeof(kbds));
d176 17
a192 30
			switch (kbtype) {
			case WSKBD_TYPE_PC_XT:
			case WSKBD_TYPE_PC_AT:
				kbds[SA_PCKBD]++;
				break;
			case WSKBD_TYPE_USB:
				kbds[SA_UKBD]++;
				break;
			case WSKBD_TYPE_ADB:
				kbds[SA_AKBD]++;
				break;
			case WSKBD_TYPE_LK201:
				kbds[SA_ZSKBD]++;
				break;
			case WSKBD_TYPE_SUN:
				kbds[SA_SUNKBD]++;
				break;
			case WSKBD_TYPE_SUN5:
				kbds[SA_SUN5KBD]++;
				break;
			case WSKBD_TYPE_HIL:
				kbds[SA_HILKBD]++;
				break;
			case WSKBD_TYPE_GSC:
				kbds[SA_GSCKBD]++;
				break;
			case WSKBD_TYPE_DOMAIN:
				kbds[SA_DOMAINKBD]++;
				break;
			};
a202 1
#endif
d204 23
a226 3
	for (i = 0; i < SA_MAX; i++)
		if (kbds[i] != 0)
			kbd_show_enc(kd, i);
a227 1
#ifndef NOKVM
d229 6
a235 2
	if (rebuild > 0)
		printf("Unknown encoding or variant. kbd(8) needs to be rebuilt.\n");
d241 2
a242 2
	char	buf[LINE_MAX], *c, *b, device[sizeof "/dev/wskbd00"];
	int	map = 0, v, i, fd;
d244 2
d249 1
a249 1
	while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
d251 1
d255 1
a255 1
		if (strcmp(n->name, buf) == 0)
d257 1
d265 1
a265 1
		while (*c != '.' && *c != '\0' && b < buf + sizeof(buf) - 1)
d267 1
d272 1
a272 1
			if (strcmp(n->name, buf) == 0)
d274 1
d295 1
a295 1
				} else
d297 1
d306 1
a306 1
		fprintf(stderr, "kbd: keyboard mapping set to %s\n", name);
@

