# XXX experimental, doesn't really work yet, quick hack ONLY for tg@

# $MirOS: mklogci,v 1.31 2007/11/18 21:58:46 bsiegert Exp $
#-
# Copyright (c) 2005, 2006, 2007
#	Thorsten Glaser <tg@mirbsd.de>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# Advertising materials mentioning features or use of this work must
# display the following acknowledgement:
#	This product includes material provided by Thorsten Glaser.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# CVS helper to create log messages from cvs commits, rewritten from
# scratch. The design pattern is a perl script originally written by
# David Hampton and hacked by Greg A. Woods, OpenBSD, and Th. Glaser
# for MirBSD, later The MirOS Project.
#-
# Usage: mklogci commitid [-D] [-C root] [-f file] [-I uri] [-M module]
#		 [-m mailto] -p pathr [-R replyto] file ...
#	commitid	= GNU CVS 1.12.12 + MirOS mode %I, PGRP else
#	-C root		= CVSROOT (the %r argument)
#	-D		= mail: append diffs themselves not commands
#	-f logfile	= create ChangeLog file from commit messages
#	-I loguri	= reduce size of import mails, refer to URI
#	-M module	= set module name
#	-m mailto	= send commit messages to mailto
#	-p pathr	= the %p argument
#	-R replyto	= set Reply-To: replyto header

function die
{
	print -r Error: "$@"
	rm -f $repo/.tmp/cl.*.$id
	exit 1
}

function makeheader
{
	cat <<-EOF
		Commit ID:	$id
		CVSROOT:	$repo
		Module name:	$module
		Changes by:	${USER}@$hn	$(TZ=UTC date '+%Y/%m/%d %T' 2>/dev/null) UTC

	EOF
}

function writelog
{
	{
		cat "$@"
		print ________________________________________________________________________
		print
	} | $SHELL $repo/CVSROOT/genlog $logfile $repo/CVSROOT/history
}

function writemail
{
	sendmail -t |&
	print -pr -- To: $mailto
	print -pr -- Subject: CVS: $hn: $module
	if [[ -n $replyto ]]; then
		print -pr -- Mail-Followup-To: $replyto
		print -pr -- Reply-To: $replyto
	fi
	print -p
	exec 3>&p
	cat "$@" >&3
	exec 3>&-
}

function addnames
{
	integer i
	integer linln

	dir=${dir##+(./)}
	dir=${dir%%+(/)}
	[[ -z $dir ]] && dir=.

	line=$(printf '%-15s:' "$dir")
	let i=0
	let linln=${#line}
	line="	$line"
	while (( i < ${#add_names[*]} )); do
		while :; do
			linadd=${add_names[i++]}
			line="$line $linadd"
			let "linln += ${#linadd} + 1"
			(( i < ${#add_names[*]} )) || break
			(( (linln + 1 + ${#add_names[i]}) < 72 )) || break
		done
		print -r -- "$line"
		line='			'
		let linln=16
	done
}

function addflist
{
	set -A add_names
	IFS= read dir
	[[ $dir = */ ]] || die addflist "($dir)" does not look like a directory
	while IFS= read fn; do
		if [[ $fn = */ ]]; then
			addnames
			dir=$fn
			set -A add_names
		elif [[ -z $fn || $fn = *([	 ]) ]]; then
			break
		else
			add_names[${#add_names[*]}]=$fn
		fi
	done
	addnames
}

SHELL=/bin/mksh
id=$1
[[ -z $id ]] && exit 255
shift

logfile=
loguri=
module=
mailto=
pathr=
replyto=
integer do_diff=0

while getopts "C:Df:I:M:m:p:R: :" flag; do
	case $flag {
	(C)	repo=$OPTARG ;;
	(D)	do_diff=1 ;;
	(f)	logfile=$OPTARG ;;
	(I)	loguri=$OPTARG ;;
	(M)	module=$OPTARG ;;
	(m)	mailto=$OPTARG ;;
	(p)	pathr=$OPTARG ;;
	(R)	replyto=$OPTARG ;;
	(\ )	let 'OPTIND -= 2'
		break ;;
	(*)	die check usage
	}
done
shift $((OPTIND - 1))

[[ -z $repo ]] && repo=$CVSROOT
[[ -n $logfile && ! -e $logfile ]] && die logfile "($logfile)" does not exist
[[ -z $pathr ]] && die give a path please
hn=$(hostname 2>/dev/null)
[[ $hn = *.* ]] || hn=$hn.$(domainname 2>/dev/null)
[[ $hn = *. ]] && hn=${hn}invalid
if [[ $pathr = */* ]]; then
	pathd=${pathr#*/}
else
	pathd=.
fi

if [[ -e $repo/.tmp/do-dump ]]; then
	if DUMPFN=$(mktemp $repo/.tmp/dump.XXXXXXXXXXXX); then
		cat >$DUMPFN
		(
			local argv
			set -A argv -- "$0" "$@"
			print "BEGIN calling information"
			integer i=0
			while (( i < ${#argv[*]} )); do
				print -nr -- "<${argv[i++]}> "
			done
			print
			cat $DUMPFN
			print "END calling information"
		) | logger -t "CVS:dump"
	else
		DUMPFN=0
	fi
else
	DUMPFN=0
fi

diff=$repo/.tmp/cl.log.dif.$id
difc=$repo/.tmp/cl.log.dfc.$id
msgf=$repo/.tmp/cl.log.msg.$id
outf=$repo/.tmp/cl.log.out.$id
tmpf=$repo/.tmp/cl.log.tmp.$id
modf=$repo/.tmp/cl.module.$id
prefix=$repo/.tmp/cl.lst
let i=0

[[ -z $module ]] && module=${pathr%%/*}
[[ -n $logfile && $logfile != */* ]] && logfile=$repo/$module/$logfile
if [[ -e $modf ]]; then
	[[ "$(<$modf)" = $module ]] || print \(multiple\) >$modf
else
	print $module >$modf
fi

# Prepare the final commit message
makeheader >$tmpf
let i=0
while [[ -e $prefix.msg.$i.$id ]]; do
	let j=0
	if [[ -s $prefix.chg.$i.$id ]]; then
		print Modified files: >>$tmpf
		addflist <$prefix.chg.$i.$id >>$tmpf
		let ++j
	fi
	if [[ -s $prefix.add.$i.$id ]]; then
		print Added files: >>$tmpf
		addflist <$prefix.add.$i.$id >>$tmpf
		let ++j
	fi
	if [[ -s $prefix.del.$i.$id ]]; then
		print Removed files: >>$tmpf
		addflist <$prefix.del.$i.$id >>$tmpf
		let ++j
	fi
	(( j > 0 )) && print >>$tmpf
	if [[ -s $prefix.msg.$i.$id ]]; then
		print Log message: >>$tmpf
		cat $prefix.msg.$i.$id >>$tmpf
		print >>$tmpf
	fi
	let ++i
done
if [[ -s $diff ]]; then
	if (( do_diff )); then
		print Please note that the following diffs are not public \
		    domain, they are >$difc
		print copyrighted and covered by the licence terms of the \
		    files themselves. >>$difc
		print >>$difc
		CVSROOT="$repo" $SHELL $diff >>$difc
	else
		difc=$diff
	fi
	print '0a\nTo generate a diff of this changeset, execute the' \
	    'following commands:\n.\nwq' | ed -s $diff
fi

# And out with it
[[ -n $logfile ]] && writelog $tmpf $diff
[[ -n $mailto ]] && writemail $tmpf $difc
rm $repo/.tmp/cl.*.$id
print Committed revision $id.
exit 0
