head	1.48;
access;
symbols;
locks; strict;
comment	@# @;


1.48
date	2015.12.09.14.26.20;	author tg;	state Exp;
branches;
next	1.47;
commitid	10056683A19534CDB03;

1.47
date	2015.10.09.14.55.09;	author tg;	state Exp;
branches;
next	1.46;
commitid	1005617D55A108AE790;

1.46
date	2015.10.09.14.51.36;	author tg;	state Exp;
branches;
next	1.45;
commitid	1005617D3BD0B50DF7C;

1.45
date	2011.07.25.09.43.37;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004E2D3AE171CE7FCC;

1.44
date	2011.06.11.21.43.58;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004DF3E19F66DE2805;

1.43
date	2008.08.05.06.10.32;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004897EEDE3BCA4CFA;

1.42
date	2008.08.05.06.07.33;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004897EE14797653E9;

1.41
date	2008.08.04.10.15.45;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004896D6E348976015;

1.40
date	2008.08.04.10.15.11;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004896D6B10D86EA0D;

1.39
date	2008.07.04.19.54.08;	author tg;	state Exp;
branches;
next	1.38;
commitid	100486E7FED3ECA13BD;

1.38
date	2008.07.03.18.41.13;	author tg;	state Exp;
branches;
next	1.37;
commitid	100486D1D5A5200CA53;

1.37
date	2008.07.03.18.35.08;	author tg;	state Exp;
branches;
next	1.36;
commitid	100486D1BF0010E9523;

1.36
date	2008.07.03.18.29.49;	author tg;	state Exp;
branches;
next	1.35;
commitid	100486D1AB04B13C8CE;

1.35
date	2008.07.03.18.09.36;	author tg;	state Exp;
branches;
next	1.34;
commitid	100486D15E35EC6CA32;

1.34
date	2008.07.03.17.32.16;	author tg;	state Exp;
branches;
next	1.33;
commitid	100486D0D2A68EE39F6;

1.33
date	2008.07.03.17.26.14;	author tg;	state Exp;
branches;
next	1.32;
commitid	100486D0BC802857FE7;

1.32
date	2008.07.03.17.24.31;	author tg;	state Exp;
branches;
next	1.31;
commitid	100486D0B5B4793FDFD;

1.31
date	2007.11.18.21.58.46;	author bsiegert;	state Exp;
branches;
next	1.30;
commitid	1004740B5AD00016555;

1.30
date	2007.11.18.21.57.31;	author bsiegert;	state Exp;
branches;
next	1.29;
commitid	1004740B56200016524;

1.29
date	2007.11.18.21.37.21;	author bsiegert;	state Exp;
branches;
next	1.28;
commitid	1004740B0A800016203;

1.28
date	2007.11.18.21.34.32;	author bsiegert;	state Exp;
branches;
next	1.27;
commitid	1004740AFFF00000000;

1.27
date	2007.04.03.20.52.36;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004612BEA957A621ED;

1.26
date	2007.04.03.20.42.04;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004612BB874AABAFEF;

1.25
date	2007.02.16.20.08.53;	author tg;	state Exp;
branches;
next	1.24;
commitid	10045D60F0D41B8E1DF;

1.24
date	2007.02.16.19.46.40;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045D60A2F7D914B64;

1.23
date	2007.02.16.19.40.26;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045D608AF6A65F847;

1.22
date	2006.09.21.00.08.11;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004511D7FE55A6CA7B;

1.21
date	2006.09.21.00.04.49;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004511D72E17149604;

1.20
date	2006.07.21.04.21.16;	author tg;	state Exp;
branches;
next	1.19;
commitid	10044C0563A6875B7DB;

1.19
date	2006.05.12.12.10.44;	author tg;	state Exp;
branches;
next	1.18;
commitid	10044647B424385100D;

1.18
date	2006.01.14.01.31.36;	author tg;	state Exp;
branches;
next	1.17;
commitid	10043C854723BB89653;

1.17
date	2006.01.14.01.20.31;	author tg;	state Exp;
branches;
next	1.16;
commitid	10043C851E86DCFFCCF;

1.16
date	2006.01.14.01.20.01;	author tg;	state Exp;
branches;
next	1.15;
commitid	10043C851C824C939E4;

1.15
date	2005.12.22.01.14.31;	author tg;	state Exp;
branches;
next	1.14;
commitid	10043A9FE02729DE57E;

1.14
date	2005.12.19.18.12.50;	author tg;	state Exp;
branches;
next	1.13;
commitid	10043A6F830075428EE;

1.13
date	2005.12.18.16.49.53;	author tg;	state Exp;
branches;
next	1.12;
commitid	10043A593283F82DD28;

1.12
date	2005.12.15.02.05.34;	author tg;	state Exp;
branches;
next	1.11;
commitid	10043A0CF77247C192E;

1.11
date	2005.12.15.02.04.34;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043A0CF3D0AFC2B73;

1.10
date	2005.12.15.02.03.37;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043A0CEFF390D7815;

1.9
date	2005.12.15.01.55.52;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043A0CD1626BD30F6;

1.8
date	2005.12.15.01.25.41;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A0C61F44564723;

1.7
date	2005.12.14.23.49.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A0AFAB6F6338DB;

1.6
date	2005.12.06.13.44.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	1e80439595d09bbd;

1.5
date	2005.12.06.03.11.40;	author tg;	state Exp;
branches;
next	1.4;
commitid	70554395015a9795;

1.4
date	2005.12.06.02.04.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	8214394f1c7c9c9;

1.3
date	2005.12.06.02.03.05;	author tg;	state Exp;
branches;
next	1.2;
commitid	463c4394f16a97b8;

1.2
date	2005.12.06.00.29.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	e174394db940dc6;

1.1
date	2005.12.05.21.25.09;	author tg;	state Exp;
branches;
next	;
commitid	49854394b01a7fd0;


desc
@@


1.48
log
@adjust per <20151209111821.GA13100@@home.ouaza.com> (I hope I donâ€™t need
to add even more extra headers this way)
@
text
@#!/bin/mksh
# $MirOS: CVSROOT/mklogci,v 1.47 2015/10/09 14:55:09 tg Exp $
#-
# Copyright (c) 2005, 2006, 2007, 2011, 2015
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# CVS helper to create log messages from cvs commits, rewritten from
# scratch. The design pattern is a perl script originally written by
# David Hampton and hacked by Greg A. Woods, OpenBSD, and Th. Glaser
# for MirBSD, later The MirOS Project.
#-
# Usage: mklogci commitid [-D] [-C root] [-f file] [-I uri] [-M module]
#		 [-m mailto] [-P debpkg] -p pathr [-R replyto] file ...
#	commitid	= GNU CVS 1.12.12 + MirOS mode %I, PGRP else
#	-C root		= CVSROOT (the %r argument)
#	-D		= mail: append diffs themselves not commands
#	-f logfile	= create ChangeLog file from commit messages
#	-I loguri	= reduce size of import mails, refer to URI
#	-M module	= set module name
#	-m mailto	= send commit messages to mailto
#	-P debpkg	= send mails to PTS for debpkg with cvs tag
#	-p pathr	= the %p argument
#	-R replyto	= set Reply-To: replyto header

export LC_ALL=C
unset LANGUAGE

function die {
	print -r Error: "$@@"
	rm -f $repo/.tmp/cl.*.$id
	exit 1
}

function makeheader {
	(( cidline )) && cat <<-EOF
		Commit ID:	$id
	EOF
	cat <<-EOF
		CVSROOT:	$repo
		Module name:	$module
		Changes by:	${USER}@@$hn	$(TZ=UTC date '+%Y/%m/%d %T' 2>/dev/null) UTC

	EOF
}

function writelog {
	{
		cat "$@@"
		print ________________________________________________________________________
		print
	} | $SHELL $repo/CVSROOT/genlog $logfile $repo/CVSROOT/history
}

function writemail {
	sendmail -t |&
	(( cidline )) && print -pr -- "Message-ID: <commitid.$id.CVS-ci@@$hn>"
	print -pr -- 'MIME-Version: 1.0'
	print -pr -- 'Content-Type: text/plain; charset=UTF-8'
	print -pr -- 'Content-Transfer-Encoding: 8bit'
	print -pr -- To: $(set -A x $mailto; IFS=,; print -r -- "${x[*]}")
	[[ -n $replyto ]] && print -pr -- Reply-To: $replyto
	(( opt_pts )) && print -pr -- X-PTS-Approved: 1
	#XXX RFC2047 encoding tbd
	print -pr -- Subject: CVS: $hn: $module
	print -pr -- 'Auto-Submitted: auto-generated'
	#XXX should be done by the mailing list manager instead (list, not bulk)
	print -pr -- 'Precedence: bulk' #XXX for now
	print -p
	exec 3>&p
	cat "$@@" >&3
	exec 3>&-
}

function addnames {
	integer i
	integer linln

	dir=${dir##+(./)}
	dir=${dir%%+(/)}
	[[ -z $dir ]] && dir=.

	line=$(printf '%-15s:' "$dir")
	i=0
	linln=${#line}
	line="	$line"
	while (( i < ${#add_names[*]} )); do
		while :; do
			linadd=${add_names[i++]}
			line="$line $linadd"
			(( linln += ${#linadd} + 1 ))
			(( i < ${#add_names[*]} )) || break
			(( (linln + 1 + ${#add_names[i]}) < 72 )) || break
		done
		print -r -- "$line"
		line='			'
		linln=16
	done
}

function addflist {
	set -A add_names
	IFS= read dir
	[[ $dir = */ ]] || die addflist "($dir)" does not look like a directory
	while IFS= read fn; do
		if [[ $fn = */ ]]; then
			addnames
			dir=$fn
			set -A add_names
		elif [[ -z $fn || $fn = *([	 ]) ]]; then
			continue
		else
			add_names[${#add_names[*]}]=$fn
		fi
	done
	addnames
}

function getdirs {
	local dir=$1
	integer i

	[[ -s $repo/.tmp/cl.dirs.$id ]] || return 0
	set -A dirnames
	set -A dircounts
	integer dircounts
	. $repo/.tmp/cl.dirs.$id
	i=0
	while (( i < ${#dirnames[*]} )); do
		[[ ${dirnames[i]} = $dir ]] && break
		let i++
	done
	(( i < ${#dirnames[*]} )) || return 0	# not found
	(( dircounts[i] )) || return 0		# count zero

	let dircounts[i]--
	if (( !dircounts[i] )); then
		unset dircounts[i]
		unset dirnames[i]
	fi
	set -A dirnames -- "${dirnames[@@]}"
	set -A dircounts -- "${dircounts[@@]}"

	(( ${#dirnames[*]} )) || return 0	# none left
	ln="set -A dirnames --"
	lc="set -A dircounts"
	i=0
	while (( i < ${#dirnames[*]} )); do
		ln="$ln '${dirnames[i]}'"
		lc="$lc ${dircounts[i]}"
		let i++
	done
	print -r -- "$ln$nl$lc" >$repo/.tmp/cl.dirs.$id
	return 1				# some left
}


SHELL=$(whence -p mksh) || SHELL=/bin/mksh
id=$1
shift
if [[ -z $id || $id = @@(-|%I) ]]; then
	if (( PGRP )); then
		id=$PGRP	# mksh pre-R24 or post-R33
	else
		id=$(perl -e 'print getpgrp();' 2>&-) || id=
	fi
	if [[ -z $id || $id -eq 0 ]]; then
		print -u2 Cannot determine PGRP, upgrade mksh or check
		print -u2 your \$PATH for perl.
		exit 255
	fi
	cidline=0
elif [[ $id != +([0-9A-Za-z]) ]]; then
	cidline=0
else
	cidline=1
fi

logfile=
loguri=
module=
mailto=
pathr=
replyto=
integer do_diff=0
integer opt_pts=0

while getopts "C:Df:I:M:m:P:p:R: :" flag; do
	case $flag {
	(C)	repo=$OPTARG ;;
	(D)	do_diff=1 ;;
	(f)	logfile=$OPTARG ;;
	(I)	loguri=$OPTARG ;;
	(M)	module=$OPTARG ;;
	(m)	mailto="$mailto $OPTARG" ;;
	(P)	opt_pts=1
		mailto="$mailto dispatch+${OPTARG}_vcs@@tracker.debian.org"
		;;
	(p)	pathr=$OPTARG ;;
	(R)	replyto=$OPTARG ;;
	(\ )	let 'OPTIND -= 2'
		break ;;
	(*)	die check usage
	}
done
shift $((OPTIND - 1))

[[ -z $repo ]] && repo=$CVSROOT
[[ -d $repo/.tmp/. ]] || die temporary directory "($repo/.tmp)" does not exist
[[ -n $logfile && ! -e $logfile ]] && die logfile "($logfile)" does not exist
[[ -z $pathr ]] && die give a path please
hn=$(hostname 2>/dev/null)
[[ $hn = *.* ]] || hn=$hn.$(domainname 2>/dev/null)
[[ $hn = *. ]] && hn=${hn}invalid
if [[ $pathr = */* ]]; then
	pathd=${pathr#*/}
else
	pathd=.
fi

if [[ -e $repo/.tmp/do-dump ]]; then
	if DUMPFN=$(mktemp $repo/.tmp/dump.XXXXXXXXXXXX); then
		cat >$DUMPFN
		{
			local argv
			set -A argv -- "$0" "$@@"
			print "BEGIN calling information for commit $id"
			integer i=0
			while (( i < ${#argv[*]} )); do
				print -nr -- "[$i]<${argv[i++]}> "
			done
			print
			cat $DUMPFN
			print "END calling information"
		} | logger -t "CVS:dump"
	else
		DUMPFN=0
	fi
else
	DUMPFN=0
fi

diff=$repo/.tmp/cl.log.dif.$id
difc=$repo/.tmp/cl.log.dfc.$id
msgf=$repo/.tmp/cl.log.msg.$id
outf=$repo/.tmp/cl.log.out.$id
tmpf=$repo/.tmp/cl.log.tmp.$id
modf=$repo/.tmp/cl.module.$id
prefix=$repo/.tmp/cl.lst
set -A files
set -A fold
set -A fnew
integer i=0
integer j
nl='
'

while (( $# > 2 )); do
	files[i]=$1
	fold[i]=$2
	fnew[i]=$3
	shift; shift; shift

	if [[ $i = 0 && ${fold[i]} = @@(- )* && ${fnew[i]} = NONE ]]; then
		# cvs import or cvs add directory
		[[ $1 = NONE ]] && shift
		break
	fi

	let ++i
done

while (( $# )); do
	print -u2 "warning: junk argument '$1'"
	shift
done

[[ -z $module ]] && module=${pathr%%/*}
[[ -n $logfile && $logfile != */* ]] && logfile=$repo/$module/$logfile
if [[ -e $modf ]]; then
	[[ "$(<$modf)" = $module ]] || print \(multiple\) >$modf
else
	print $module >$modf
fi

# Check for newly created dir
if [[ ${fold[0]} = "- New directory" ]]; then
	makeheader >$tmpf
	print -r -- "${files[0]}" >>$tmpf
	print >>$tmpf
	if [[ $DUMPFN = 0 ]]; then
		cat >>$tmpf
	else
		cat $DUMPFN >>$tmpf
		rm -f $DUMPFN
	fi
	[[ -n $logfile ]] && writelog $tmpf
	[[ -n $mailto ]] && writemail $tmpf
	rm $repo/.tmp/cl.*.$id
	exit 0
fi

# Iterate over the message body
status=none
set -A changed_files
set -A added_files
set -A removed_files
set -A log_lines
if [[ $DUMPFN = 0 ]]; then
	_i=
else
	cat $DUMPFN |&
	_i=-p
fi
while IFS= read ${_i} -r line; do
	case $line {
	(Modified\ Files*)
		status=changed
		continue ;;
	(Added\ Files*)
		status=added
		continue ;;
	(Removed\ Files*)
		status=removed
		continue ;;
	(Log\ Message*)
		status=log
		continue ;;
	}

	# Delete leading/trailing whitespace
	[[ $status = log ]] || line=${line##*([	 ])}
	line=${line%%*([	 ])}

	case $status {
	(changed)
		for f in $line; do
			changed_files[${#changed_files[*]}]=$f
		done ;;
	(added)
		for f in $line; do
			added_files[${#added_files[*]}]=$f
		done ;;
	(removed)
		for f in $line; do
			removed_files[${#removed_files[*]}]=$f
		done ;;
	(log)
		log_lines[${#log_lines[*]}]=$line
		;;
	}

done
[[ $DUMPFN = 0 ]] || rm -f $DUMPFN

# Strip trailing blank lines from the log message; multiple blank
# lines are compressed into one, and leading blank lines are removed
i=${#log_lines[*]}
while (( i )) && [[ ${log_lines[i-1]} = *([	 ]) ]]; do
	unset log_lines[--i]
done
i=0
while (( i < ${#log_lines[*]} )); do
	[[ ${log_lines[i]} = *([	 ]) ]] || break
	let ++i
done
print -n >$msgf
sp=
[[ ${fold[0]} = "- Imported sources" ]] && sp='    '
while (( i < ${#log_lines[*]} )); do
	if [[ ${log_lines[i]} = *([	 ]) ]]; then
		let ++i
		(( isblank )) && continue
		print >>$msgf
		isblank=1
	else
		print -r -- "$sp${log_lines[i++]}" >>$msgf
		isblank=0
	fi
done

# Check for an import command
if [[ ${fold[0]} = "- Imported sources" ]]; then
	makeheader >$tmpf
	print Log message: >>$tmpf
	ed -s $msgf <<-'EOF'
		%g/^    \(Status:\)$/s//\1/
		%g/^    \(Vendor Tag:\)/s//\1/
		%g/^    \(Release Tags:\)/s//\1/
		wq
	EOF
	if [[ -n $loguri ]]; then
		cat $tmpf >$outf
		sed -n '1,/Release Tags/p' <$msgf >>$outf
		cat >>$outf <<-EOF

			To reduce mail sizes, imports only send out the log message
			and tags; the (rather large) ChangeLog data can be found at
			|	${loguri}
			Please remember that it can take some time to synchronise.
		EOF
	else
		cat $tmpf $msgf >$outf
	fi
	[[ -n $logfile ]] && writelog $tmpf $msgf
	[[ -n $mailto ]] && writemail $outf
	rm $repo/.tmp/cl.*.$id
	exit 0
fi

getdirs "$repo/$pathr"
leave=$?

# Look for a log file which matches this log message
i=0
lmsg=$(<$msgf)
while :; do
	if [[ ! -e $prefix.msg.$i.$id ]]; then
		cp $msgf $prefix.msg.$i.$id
		break
	fi
	[[ $lmsg = "$(<$prefix.msg.$i.$id)" ]] && break
	let ++i
done

# Write information collected during this run
[[ ${#changed_files[*]} -gt 0 ]] && print -r -- "$pathd/" >>$prefix.chg.$i.$id
j=0
while (( j < ${#changed_files[*]} )); do
	print -r -- "${changed_files[j++]}" >>$prefix.chg.$i.$id
done
[[ ${#added_files[*]} -gt 0 ]] && print -r -- "$pathd/" >>$prefix.add.$i.$id
j=0
while (( j < ${#added_files[*]} )); do
	print -r -- "${added_files[j++]}" >>$prefix.add.$i.$id
done
[[ ${#removed_files[*]} -gt 0 ]] && print -r -- "$pathd/" >>$prefix.del.$i.$id
j=0
while (( j < ${#removed_files[*]} )); do
	print -r -- "${removed_files[j++]}" >>$prefix.del.$i.$id
done

# Collect changeset diff information
j=0
while (( j < ${#files[*]} )); do
	fn=$pathr/${files[j]}
	old=${fold[j]}
	[[ $old = NONE ]] && old=0
	new=${fnew[j]}
	[[ $new = NONE ]] && new=0
	print -r -- "cvs -R rdiff -kk -upr$old -r$new $fn" >>$diff
	[[ -n $logfile ]] && print -r -- "$id	$fn" >>${logfile%/*}/idcache
	let ++j
done

# End here if this is not my last invocation
(( leave )) && exit 0
module=$(<$modf)

# Prepare the final commit message
makeheader >$tmpf
i=0
while [[ -e $prefix.msg.$i.$id ]]; do
	j=0
	if [[ -s $prefix.chg.$i.$id ]]; then
		print Modified files: >>$tmpf
		addflist <$prefix.chg.$i.$id >>$tmpf
		let ++j
	fi
	if [[ -s $prefix.add.$i.$id ]]; then
		print Added files: >>$tmpf
		addflist <$prefix.add.$i.$id >>$tmpf
		let ++j
	fi
	if [[ -s $prefix.del.$i.$id ]]; then
		print Removed files: >>$tmpf
		addflist <$prefix.del.$i.$id >>$tmpf
		let ++j
	fi
	(( j > 0 )) && print >>$tmpf
	if [[ -s $prefix.msg.$i.$id ]]; then
		print Log message: >>$tmpf
		cat $prefix.msg.$i.$id >>$tmpf
		print >>$tmpf
	fi
	let ++i
done
if [[ -s $diff ]]; then
	if (( do_diff )); then
		print Please note that the following diffs are not public \
		    domain, they are >$difc
		print copyrighted and covered by the licence terms of the \
		    files themselves. >>$difc
		print >>$difc
		CVSROOT=$repo $SHELL $diff >>$difc
	else
		difc=$diff
	fi
	print '0a\nTo generate a diff of this changeset, execute the' \
	    'following commands:\n.\nwq' | ed -s $diff
fi

# And out with it
[[ -n $logfile ]] && writelog $tmpf $diff
[[ -n $mailto ]] && writemail $tmpf $difc
rm $repo/.tmp/cl.*.$id
print Committed revision $id.
exit 0
@


1.47
log
@harsher checks for the commitid

(allow both upstream and our formats)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.46 2015/10/09 14:51:36 tg Exp $
d211 1
a211 1
		mailto="$mailto ${OPTARG}_cvs@@packages.qa.debian.org"
@


1.46
log
@first overhaul of CVS commit/tag log mail headers:
â€¢ indicate MIME text/plain, UTF-8, 8bit encoding
â€¢ drop Mail-Followup-To routing header (for consistency with evolvis recvhook)
â€¢ set Message-ID from CVS commitid if any
â€¢ include Auto-Submitted header
TODO for second overhaul:
â€¢ keeping Subject as-is, not RFC2047 encodedÂ², it works in practice for now
â€¢ add Precedence: bulk headerÂ¹ (we really want Precedence: list, though)
â‘  until we have a mailing list managerÂ²
â‘¡ until we have up-to-date php5 in MirPorts
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $
d187 2
@


1.45
log
@fix when -m"" is used
@
text
@d1 2
a2 2
#!/usr/bin/env mksh
# $MirOS: CVSROOT/mklogci,v 1.44 2011/06/11 21:43:58 tg Exp $
d4 2
a5 2
# Copyright (c) 2005, 2006, 2007, 2011
#	Thorsten Glaser <tg@@mirbsd.org>
d71 4
d76 1
d78 1
d80 3
a82 4
	if [[ -n $replyto ]]; then
		print -pr -- Mail-Followup-To: $replyto
		print -pr -- Reply-To: $replyto
	fi
@


1.44
log
@send mails to the Debian PTS for packages with VCS-CVS inside here
(list of packages/paths is maintained manually!)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.43 2008/08/05 06:10:32 tg Exp $
d365 3
a367 3
(( ${#log_lines[*]} )) && \
    while [[ ${log_lines[${#log_lines[*]}-1]} = *([	 ]) ]]; do
	unset log_lines[${#log_lines[*]}-1]
@


1.43
log
@error out in a controlled way if $CVSROOT/.tmp is no directory
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.42 2008/08/05 06:07:33 tg Exp $
d4 2
a5 2
# Copyright (c) 2005, 2006, 2007
#	Thorsten Glaser <tg@@mirbsd.de>
d28 1
a28 1
#		 [-m mailto] -p pathr [-R replyto] file ...
d36 1
d71 2
a72 1
	print -pr -- To: $mailto
d193 1
d195 1
a195 1
while getopts "C:Df:I:M:m:p:R: :" flag; do
d202 4
a205 1
	(m)	mailto=$OPTARG ;;
@


1.42
log
@â€¢ set locale to "C" for !MirBSD
â€¢ better warnings for the case of not finding the process group
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.41 2008/08/04 10:15:45 tg Exp $
d210 1
@


1.41
log
@pastoâ€¦
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.40 2008/08/04 10:15:11 tg Exp $
d39 3
d174 5
a178 1
	[[ -z $id || $id -eq 0 ]] && exit 255
@


1.40
log
@if not passing commit id via %I MirOS extension, don't emit Commit ID: line
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.39 2008/07/04 19:54:08 tg Exp $
d46 1
a46 1
	(( cidline )) && cat >$T <<-EOF
@


1.39
log
@we do have junk arguments on 'cvs add <directory>'
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.38 2008/07/03 18:41:13 tg Exp $
d46 3
a49 1
		Commit ID:	$id
d172 3
@


1.38
log
@break is illogical here
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.37 2008/07/03 18:35:08 tg Exp $
d252 5
a256 2
	# cvs import or cvs add directory
	[[ $i = 0 && ${fold[i]} = @@(- )* && ${fnew[i]} = NONE ]] && break
@


1.37
log
@fix exit code confusion
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.36 2008/07/03 18:29:49 tg Exp $
d113 1
a113 1
			break
@


1.36
log
@fix integer abuse
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.35 2008/07/03 18:09:36 tg Exp $
d396 2
a397 1
leave=$(getdirs "$repo/$pathr")
@


1.35
log
@experimental: track directories visited in a (ksh) DB, leave if entries left
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.34 2008/07/03 17:32:16 tg Exp $
d86 2
a87 2
	let i=0
	let linln=${#line}
d93 1
a93 1
			let "linln += ${#linadd} + 1"
d99 1
a99 1
		let linln=16
d242 1
d322 2
a323 2
		for i in $line; do
			changed_files[${#changed_files[*]}]=$i
d326 2
a327 2
		for i in $line; do
			added_files[${#added_files[*]}]=$i
d330 2
a331 2
		for i in $line; do
			removed_files[${#removed_files[*]}]=$i
d347 1
a347 1
let i=0
d399 1
a399 1
let i=0
d412 1
a412 1
let j=0
d417 1
a417 1
let j=0
d422 1
a422 1
let j=0
d428 1
a428 1
let j=0
d446 1
a446 1
let i=0
d448 1
a448 1
	let j=0
@


1.34
log
@if commitid is not given, use the PGRP, as (much) earlier
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.33 2008/07/03 17:26:14 tg Exp $
d121 39
d241 3
a243 1
let i=0
d395 1
a395 2
[[ "$(<$repo/.tmp/cl.lastdir.$id)" = $repo/$pathr ]]
leave=$?
@


1.33
log
@dump junk arguments
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.32 2008/07/03 17:24:31 tg Exp $
a122 1
[[ -z $id ]] && exit 255
d124 8
d176 1
a176 1
			print "BEGIN calling information"
@


1.32
log
@more licence updates and style improvements
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.31 2007/11/18 21:58:46 bsiegert Exp $
d201 11
a211 7
	if [[ $i = 0 && $2 = @@(- )* && $3 = NONE ]]; then
		# cvs import or cvs add directory
		break
	else
		let ++i
		shift; shift; shift
	fi
@


1.31
log
@Remove traces, hopefully everything runs now
@
text
@d1 2
a2 2
#!/bin/mksh
# $MirOS: CVSROOT/mklogci,v 1.30 2007-11-18 21:57:31 bsiegert Exp $
a12 4
# Advertising materials mentioning features or use of this work must
# display the following acknowledgement:
#	This product includes material provided by Thorsten Glaser.
#
d39 1
a39 2
function die
{
d45 1
a45 2
function makeheader
{
d55 1
a55 2
function writelog
{
d63 1
a63 2
function writemail
{
d77 1
a77 2
function addnames
{
d103 1
a103 2
function addflist
{
d121 1
a121 1
SHELL=/bin/mksh
d166 1
a166 1
		(
d172 1
a172 1
				print -nr -- "<${argv[i++]}> "
d177 1
a177 1
		) | logger -t "CVS:dump"
d201 1
a201 1
	if [[ $i = 0 && $2 = -\ * && $3 = NONE ]]; then
d290 1
a290 1
[[ ${#log_lines[*]} -gt 0 ]] && \
d305 1
a305 1
		[[ $isblank = 1 ]] && continue
d349 1
a349 1
while : ; do
d389 1
a389 1
[[ $leave = 1 ]] && exit 0
d427 1
a427 1
		CVSROOT="$repo" $SHELL $diff >>$difc
@


1.30
log
@hardcode /bin/mksh as shell as it is set to /bin/bash here
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.29 2007-11-18 21:37:21 bsiegert Exp $
a130 2
print $*

@


1.29
log
@maybe this fixes the problem
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.28 2007-11-18 21:34:32 bsiegert Exp $
d133 1
a133 1
SHELL=${SHELL:-/bin/mksh}
@


1.28
log
@Add some logging, DEBUG
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.27 2007-04-03 20:52:36 tg Exp $
d209 1
a209 1
while (( $# > 0 )); do
@


1.27
log
@mergo, oopsâ€¦
@
text
@d2 1
a2 1
# $MirOS: mklogci,v 1.26 2007/04/03 20:42:04 tg Exp $
d131 2
@


1.26
log
@logic error: fix forever-loop in case the directory name plus the name
of the first file mentioned in it (per line) is longer than 80c

replaced by completely new logic (tail-controlled loop instead of
head-controlled), fix another off-by-one while here; the new logic
ensures that the maximum line size is 79c iff possible, and that
each line at least has <tab><dirname+colon><space><filename>, or
<tab><tab><tab><space><filename> for subsequent lines; dirname is
padded to at least 15c to make it line up nicely; the format is
loosely the same as the old one, except that it breaks better

triggered by commitid 1004612AC977E789195:
        lang/ezm3/patches: patch-language_modula3_m3compiler_m3bootstrap_src_m3makefile
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.25 2007/02/16 20:08:53 tg Exp $
d100 1
@


1.25
log
@* mklogci: new option -D: when sending out emails, append the actual
  unified context diff instead of the commands required to get it;
  doesn't affect ChangeLog generation
* loginfo: use mklogci -D for fwcf
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.24 2007/02/16 19:46:40 tg Exp $
d28 2
a29 1
# David Hampton and hacked by Greg A. Woods, OpenBSD and MirBSD.
d87 2
a88 1
	local i
d93 7
a99 6
	line=$(printf '\t%-15s:' "$dir")
	linadd=${add_names[0]}
	let i=1
	let linln=3
	while (( i <= ${#add_names[*]} )); do
		while (( ( linln + ${#linadd} ) < 58 )); do
d102 2
a103 7
			if (( i < ${#add_names[*]} )); then
				linadd=${add_names[i++]}
			else
				linadd=
				let i++
				break
			fi
d107 1
a107 1
		let linln=3
@


1.24
log
@suggest to use cvs rdiff -up
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.23 2007/02/16 19:40:26 tg Exp $
d30 1
a30 1
# Usage: mklogci commitid [-C root] [-f file] [-I uri] [-M module]
d34 1
d143 1
d145 1
a145 1
while getopts "C:f:I:M:m:p:R: :" flag; do
d148 1
d197 1
d432 12
a443 3
	print To generate a diff of this changeset, execute the \
	    following commands: >>$tmpf
	cat $diff >>$tmpf
d447 2
a448 2
[[ -n $logfile ]] && writelog $tmpf
[[ -n $mailto ]] && writemail $tmpf
@


1.23
log
@* use -kk as argument to cvs rdiff
* sync licence
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $
d390 1
a390 1
	print -r -- "cvs -R rdiff -kk -ur$old -r$new $fn" >>$diff
@


1.22
log
@I guess I botched
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.21 2006/09/21 00:04:49 tg Exp $
d4 1
a4 1
# Copyright (c) 2005, 2006
d7 5
a11 6
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publicly perform, modify,
# merge, distribute, sell, give away or sublicence, provided all co-
# pyright notices above, these terms and the disclaimer are retained
# in all redistributions or reproduced in accompanying documentation
# or other materials provided with binary redistributions.
d17 8
a24 8
# Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
# express, or implied, to the maximum extent permitted by applicable
# law, without malicious intent or gross negligence; in no event may
# licensor, an author or contributor be held liable for any indirect
# or other damage, or direct damage except proven a consequence of a
# direct error of said person and intended use of this work, loss or
# other issues arising in any way out of its use, even if advised of
# the possibility of such damage or existence of a defect.
d390 1
a390 1
	print -r -- "cvs -R rdiff -ur$old -r$new $fn" >>$diff
@


1.21
log
@in case I ever want to debug how cvs(1) calls these scripts...
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.14 2006/08/09 19:35:23 tg Rel $
d176 2
d180 2
a181 3
			while (( i <= $# )); do
				print -nr -- "<${$i}> "
				let ++i
@


1.20
log
@be a little verbose, bsiegert@@ will like it
(I still think unix commands shouldn't be verbose if successful.)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.19 2006/05/12 12:10:44 tg Exp $
d5 1
a5 1
#	Thorsten "mirabile" Glaser <tg@@mirbsd.de>
d14 2
a15 2
# All advertising materials mentioning features or use of this soft-
# ware must display the following acknowledgement:
d25 1
a25 1
# the possibility of such damage or existence of a nontrivial bug.
d172 21
d230 6
a235 1
	cat >>$tmpf
d248 7
a254 1
while IFS= read -r line; do
d293 1
@


1.19
log
@abort on filelists if reading empty filename
"can't happen" but better be careful with hanging commits...
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.18 2006/01/14 01:31:36 tg Exp $
d404 1
@


1.18
log
@Test commit with '\'' and \
backslash continued lines (
no change in code sorry...)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.17 2006/01/14 01:20:31 tg Exp $
d123 2
@


1.17
log
@bump year \
will fix message for commitid 10043C84F4E496C148A manually
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.16 2006/01/14 01:20:01 tg Exp $
@


1.16
log
@read => read -r
causes lines ending in backslash to be honoured
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.15 2005/12/22 01:14:31 tg Exp $
d4 1
a4 1
# Copyright (c) 2005
@


1.15
log
@fix the (one of? hope not) problem with empty log messages
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.14 2005/12/19 18:12:50 tg Exp $
d220 1
a220 1
while IFS= read line; do
@


1.14
log
@we don't need locking for rdiff on old chunks
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.13 2005/12/18 16:49:53 tg Exp $
d262 2
a263 1
while [[ ${log_lines[${#log_lines[*]}-1]} = *([	 ]) ]]; do
@


1.13
log
@In contrast to $var, $(<file) must be quoted inside [[ ... ]]
to prevent it from being parsed (sorry for the 66 KiB commit mail)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.12 2005/12/15 02:05:34 tg Exp $
d354 1
a354 1
	print -r -- "cvs rdiff -ur$old -r$new $fn" >>$diff
@


1.12
log
@* revert debugging, fix the final problem
  (it was a stupid typo)
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.9 2005/12/15 01:55:52 tg Exp $
d197 1
a197 1
	[[ $(<$modf) = $module ]] || print \(multiple\) >$modf
d314 1
a314 1
[[ $(<$repo/.tmp/cl.lastdir.$id) = $repo/$pathr ]]
d325 1
a325 1
	[[ $lmsg = $(<$prefix.msg.$i.$id) ]] && break
@


1.11
log
@some more debugging
 - the error is before
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.10 2005/12/15 02:03:37 tg Exp $
a220 1
print -u2 "read <$line>"
d237 1
a237 1
	[[ $state = log ]] || line=${line##*([	 ])}
a254 2
print -u2 "line <$line> to log_lines"
print -u2 "logl <$line>"
@


1.10
log
@add some debugging code
 to help with whitespace issues
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.9 2005/12/15 01:55:52 tg Exp $
d221 1
a282 1
print -ru2 -- "logging <$sp${log_lines[i]}>"
a286 3
print -u2 -- -- msgf begin
cat $msgf >&2
print -u2 -- -- msgf end
@


1.9
log
@I just discovered a new mksh syntaxlet to preserve
whitespace in a line on a "read" command.

Test:
0
 1
  2
	tab
	 tab+1
    4
   3
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.8 2005/12/15 01:25:41 tg Exp $
d255 2
d282 1
d287 3
@


1.8
log
@parentheses around the "multiple" if we do a multi-module commit
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.7 2005/12/14 23:49:48 tg Exp $
d116 1
a116 1
	read dir
d118 1
a118 1
	while read fn; do
d220 1
a220 1
while read line; do
@


1.7
log
@locate idcache where ChangeLog is
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.6 2005/12/06 13:44:50 tg Exp $
d197 1
a197 1
	[[ $(<$modf) = $module ]] || print multiple >$modf
@


1.6
log
@Collect a list of files belonging to a changeset in a cache,
to be read out later by e.g. CVSweb
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.5 2005/12/06 03:11:40 tg Exp $
d5 1
a5 1
#	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d355 1
a355 1
	print -r -- "$id	$fn" >>$repo/Logs/idcache
@


1.5
log
@by suggestion of Han Boetes, use a temporary directory which is
only group-writable yet sticky, for the temporary files, since
we cannot use mktemp/mkdtemp
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.4 2005/12/06 02:04:33 tg Exp $
d346 1
a346 1
# Collect diff information
d355 1
@


1.4
log
@oops, dot hash
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.3 2005/12/06 02:03:05 tg Exp $
d45 1
a45 1
	rm -f /var/tmp/.\#mcvs.*.$id
d132 1
a132 1
[[ -z $id ]] && die no commitid given
a133 6
diff=/var/tmp/.\#mcvs.log.dif.$id
msgf=/var/tmp/.\#mcvs.log.msg.$id
outf=/var/tmp/.\#mcvs.log.out.$id
tmpf=/var/tmp/.\#mcvs.log.tmp.$id
modf=/var/tmp/.\#mcvs.module.$id
prefix=/var/tmp/.\#mcvs.lst
d170 6
d210 1
a210 1
	rm /var/tmp/.\#mcvs.*.$id
d310 1
a310 1
	rm /var/tmp/.\#mcvs.*.$id
d314 1
a314 1
[[ $(</var/tmp/.\#mcvs.lastdir.$id) = $repo/$pathr ]]
d399 1
a399 1
rm /var/tmp/.\#mcvs.*.$id
@


1.3
log
@use /var/tmp like the rest
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.2 2005/12/06 00:29:59 tg Exp $
d45 1
a45 1
	rm -f /var/tmp/\#.mcvs.*.$id
d134 6
a139 6
diff=/var/tmp/\#.mcvs.log.dif.$id
msgf=/var/tmp/\#.mcvs.log.msg.$id
outf=/var/tmp/\#.mcvs.log.out.$id
tmpf=/var/tmp/\#.mcvs.log.tmp.$id
modf=/var/tmp/\#.mcvs.module.$id
prefix=/var/tmp/\#.mcvs.lst
d210 1
a210 1
	rm /var/tmp/\#.mcvs.*.$id
d310 1
a310 1
	rm /var/tmp/\#.mcvs.*.$id
d314 1
a314 1
[[ $(</var/tmp/\#.mcvs.lastdir.$id) = $repo/$pathr ]]
d399 1
a399 1
rm /var/tmp/\#.mcvs.*.$id
@


1.2
log
@move ChangeLog files to /cvs/Logs/ to keep them apart
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/mklogci,v 1.1 2005/12/05 21:25:09 tg Exp $
d45 1
a45 1
	rm -f /tmp/\#cvs.*.$id
d134 6
a139 6
diff=/tmp/\#cvs.log.dif.$id
msgf=/tmp/\#cvs.log.msg.$id
outf=/tmp/\#cvs.log.out.$id
tmpf=/tmp/\#cvs.log.tmp.$id
modf=/tmp/\#cvs.module.$id
prefix=/tmp/\#cvs.lst
d210 1
a210 1
	rm /tmp/\#cvs.*.$id
d310 1
a310 1
	rm /tmp/\#cvs.*.$id
d314 1
a314 1
[[ $(</tmp/\#cvs.lastdir.$id) = $repo/$pathr ]]
d399 1
a399 1
rm /tmp/\#cvs.*.$id
@


1.1
log
@rename the files a bit (to clean the attic which moves into ocvs):
* commit_prep2	-> tracker
* log_accum2	-> mklogci
* log_write2	-> genlog
* tag_accum2	-> mklogtag
@
text
@d2 1
a2 1
# $MirOS: CVSROOT/log_accum2,v 1.8 2005/12/05 21:04:11 tg Exp $
d66 1
a66 1
	} | $SHELL $repo/CVSROOT/genlog $logfile
@

