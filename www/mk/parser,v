head	1.33;
access;
symbols;
locks; strict;
comment	@# @;


1.33
date	2018.05.06.13.23.36;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005AEF01EF5CE84E73;

1.32
date	2018.05.06.13.17.21;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005AEF006B3B8242F7;

1.31
date	2018.05.05.17.40.36;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005AEDEC757B8FE8AE;

1.30
date	2018.05.01.22.07.23;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005AE8E51E26BB06F1;

1.29
date	2018.05.01.21.50.50;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005AE8E15177E45162;

1.28
date	2018.05.01.21.34.56;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005AE8DD9312AEFD5D;

1.27
date	2018.05.01.21.15.51;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005AE8D9012C91B17D;

1.26
date	2015.12.12.23.16.51;	author tg;	state Exp;
branches;
next	1.25;
commitid	100566CAAF62D97DD97;

1.25
date	2015.04.08.16.43.58;	author tg;	state Exp;
branches;
next	1.24;
commitid	10055255A8A254C0757;

1.24
date	2014.04.14.19.29.41;	author tg;	state Exp;
branches;
next	1.23;
commitid	100534C3730417ACF22;

1.23
date	2012.07.15.14.21.44;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005002D20E4D26F99C;

1.22
date	2012.07.15.14.16.44;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005002D0836F391385;

1.21
date	2011.07.25.09.33.53;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004E2D38974938F919;

1.20
date	2008.12.04.20.55.12;	author tg;	state Exp;
branches;
next	1.19;
commitid	100493843BC3B816E4F;

1.19
date	2008.12.04.19.38.48;	author tg;	state Exp;
branches;
next	1.18;
commitid	100493831A54A1FB1A8;

1.18
date	2008.12.04.19.10.47;	author tg;	state Exp;
branches;
next	1.17;
commitid	10049382B4A4373B7F3;

1.17
date	2008.12.04.18.49.00;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004938262B3BB33855;

1.16
date	2008.12.04.18.34.05;	author tg;	state Exp;
branches;
next	1.15;
commitid	100493822885B29AF99;

1.15
date	2008.12.04.18.25.50;	author tg;	state Exp;
branches;
next	1.14;
commitid	100493820C535ECC262;

1.14
date	2008.12.04.18.24.37;	author tg;	state Exp;
branches;
next	1.13;
commitid	100493820764F31CFCA;

1.13
date	2008.12.04.18.23.19;	author tg;	state Exp;
branches;
next	1.12;
commitid	10049381F9935030BCA;

1.12
date	2008.12.04.18.20.02;	author tg;	state Exp;
branches;
next	1.11;
commitid	10049381F5928153949;

1.11
date	2008.12.04.14.14.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004937E5C833BF84C9;

1.10
date	2008.12.04.14.04.44;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004937E37C77E9654E;

1.9
date	2008.12.04.13.23.35;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004937D9D04B90976B;

1.8
date	2008.11.08.16.28.45;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004915BE2D4E504864;

1.7
date	2008.09.17.21.52.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	10048D17C0865DB7CBA;

1.6
date	2008.09.17.21.21.39;	author tg;	state Exp;
branches;
next	1.5;
commitid	10048D174ED72003551;

1.5
date	2008.07.24.13.09.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	10048887F203CB94359;

1.4
date	2008.07.18.13.20.47;	author tg;	state Exp;
branches;
next	1.3;
commitid	100488098AA7231BB91;

1.3
date	2008.04.13.00.39.09;	author tg;	state Exp;
branches;
next	1.2;
commitid	100480156313964A4DD;

1.2
date	2007.08.29.19.46.31;	author tg;	state Exp;
branches;
next	1.1;
commitid	10046D5CD2D329C00FB;

1.1
date	2007.06.09.23.29.54;	author tg;	state Exp;
branches;
next	;
commitid	100466B37F0373CAEA0;


desc
@@


1.33
log
@fix
@
text
@rcsid_parser='$MirOS: www/mk/parser,v 1.31 2018/05/05 17:40:36 tg Exp $'
#-
# This file is part of the MirBSD website; see LICENCE for details.

set -A e_author
set -A e_id
set -A ei_body
set -A ei_indir
set -A ei_srcf
set -A ei_skip
set -A ei_time
set -A ei_del

nl='
'
save_IFS=$IFS
integer entry=0
integer guid
integer state
typeset -l parser_lctmp

function parsedate {
	local ta tv=${e_date[entry]} to nt nd
	local -i10 -Z2 ra rb rc
	local -i10 -Z4 ry
	if [[ $tv = *=* ]]; then
		print -ru2 "Invalid date in $srcd/$srcf.inc: $line"
		exit 1
	fi

	set -A ta -- $tv = = =
	if [[ ${ta[0]} = +([0-9]).+([0-9]).+([0-9]) ]]; then
		rc=1
	elif [[ ${ta[0]} != +([0-9])-+([0-9])-+([0-9]) ]]; then
		print -ru2 "Invalid day in $srcd/$srcf.inc: $line"
		exit 1
	fi

	IFS=.-
	set -A nt -- ${ta[0]}
	IFS=$save_IFS

	(( rb = 10#${nt[1]} ))
	if (( rc )); then
		(( ra = 10#${nt[0]} ))
		(( ry = 10#${nt[2]} ))
	else
		(( ra = 10#${nt[2]} ))
		(( ry = 10#${nt[0]} ))
	fi
	nd=$ry-$rb-$ra

	if [[ ${ta[1]} = = ]]; then
		:
	elif [[ ${ta[1]} != +([0-9]):+([0-9])?(:+([0-9])) ]]; then
		print -ru2 "Invalid tod in $srcd/$srcf.inc: $line"
		exit 1
	else
		IFS=:
		set -A nt -- ${ta[1]}
		IFS=$save_IFS
		(( ra = 10#${nt[0]} ))
		(( rb = 10#${nt[1]} ))
		(( rc = 10#${nt[2]} ))
		nd+=" $ra:$rb:$rc"
	fi
	if [[ ${ta[2]} = = ]]; then
		ei_time[entry]='+0000'
		to=0
	elif [[ ${ta[2]} != [+-]@@([01][0-9]|2[0-3])@@([03]0|[14]5) ]]; then
		#XXX other offsets might apply (non-15min-multiples)
		print -ru2 "Invalid tz offset in $srcd/$srcf.inc: $line"
		exit 1
	else
		ei_time[entry]=${ta[2]}
		to=$((0${ta[2]::1}$((${ta[2]:1:2}*60+${ta[2]:3}))))
		nd+=" ${ta[2]}"
	fi
	if [[ ${ta[3]} != = ]]; then
		print -ru2 "Invalid date in $srcd/$srcf.inc: $line"
		exit 1
	fi
	IFS=$IFS:-
	set -A ta -- $nd 0 0 0
	IFS=$save_IFS
	set -A nt -- $((10#0${ta[5]})) $((10#0${ta[4]})) $((10#0${ta[3]})) \
	    $((10#0${ta[2]})) $((10#0${ta[1]}-1)) $((10#0${ta[0]}-1900)) \
	    x x x $((60 * to)) x
	# tz offset needed by RSS generator to issue local publication time
	ei_time[entry]="$(mjd_implode "${nt[@@]}") $to ${ei_time[entry]}"
	e_date[entry]=$nd
}

for srcf in $sources; do
	eval srcd=\$sourcedir_${srcf//\-/_}
	: ${srcd:=data}
	eval parser_lctmp=\$tags_${srcf//\-/_}
	tags=:
	for x in $parser_lctmp; do
		tags=$tags$x:
	done
	guid=10000
	ids=:
	state=1
	rcsid_parsed=
	usenn=0
	incfile_isold=0
	while IFS= read -r line; do
		if [[ -z $rcsid_parsed ]]; then
			if [[ $line = RCSID:* ]]; then
				rcsid_parsed=${line##RCSID:*([	 ])}
				continue
			fi
			if [[ $line = Flags:* ]]; then
				[[ "$line " = *' USENN '* ]] && usenn=1
				[[ "$line " = *' ISOLD '* ]] && incfile_isold=1
				continue
			fi
		fi
		if [[ $line = ---- ]]; then
			(( incfile_isold )) && ei_isold[entry]=1
			if [[ -z ${e_id[entry]} ]]; then
				if [[ -n ${e_date[entry]} ]]; then
					id=${e_date[entry]%% *}
					id=e${id//-}
				else
					id=g$((guid++))
				fi
				if [[ -n ${e_author[entry]} ]]; then
					id=${id}-${e_author[entry]%%@@(@@)*}
				elif (( usenn )); then
					id=${id}-nn
				fi
				e_id[entry]=$id
			fi
			while [[ :$ids = *:${e_id[entry]}:* ]]; do
				e_id[entry]=${e_id[entry]}-g$guid
				let guid++
			done
			ei_srcf[entry]=$srcf
			ids=$ids${e_id[entry]}:
			if [[ $tags != : ]]; then
				ei_skip[entry]=1
				for x in ${e_tag[entry]}; do
					[[ $tags = *:$x:* ]] || continue
					unset ei_skip[entry]
					break
				done
			fi
			if [[ ${e_deleted[entry]} = *1* ]]; then
				unset e_author[entry]
				unset e_language[entry]
				unset e_title[entry]
				unset e_tag[entry]
				unset e_pictures[entry]
				ei_body[entry]='â€‹'
				e_deleted[entry]=1
			fi
			let ++entry
			state=2
		elif (( state > 0 )); then
			if [[ $line = @@([A-Za-z]*([A-Za-z0-9_]):\ *) ]]; then
				x=${line##+([A-Za-z0-9_]):+([	 ])}	# value
				parser_lctmp=${line/%:+([	 ])"$x"} # key
				eval e_$parser_lctmp[entry]=\$x
			elif [[ -z $line ]]; then
				state=0
				continue
			elif [[ $line = \#* ]]; then
				continue	# ignore comment
			else
				print -ru2 "Unknown header in $srcd/$srcf.inc:" \
				    "$line"
				exit 1
			fi
			state=1
			if [[ $parser_lctmp = date ]]; then
				parsedate
			elif [[ $parser_lctmp = tag ]]; then
				parser_lctmp=${e_tag[entry]}
				unset e_tag[entry]
				for x in $parser_lctmp; do
					if [[ $x != +([0-9a-z_]) ]]; then
						print -ru2 "Invalid tag '$x' in" \
						    "$srcd/$srcf.inc: $line"
						continue
					fi
					e_tag[entry]=${e_tag[entry]}${e_tag[entry]+ }$x
				done
			fi
		elif [[ $line = '<?'* ]]; then
			interp=${line:2}
			x=
			while :; do
				if ! IFS= read -r line; then
					print -ru2 "EOF while looking for matching ?> in data/$srcf.inc!"
					exit 1
				fi
				[[ $line = '?>' ]] && break
				x+=$line$nl
			done
			if [[ -z $interp ]]; then
				line=$(eval "$x")
				state=$?
			elif ! whence -p "$interp" >/dev/null; then
				print -ru2 "Snippet interpreter '$interp' not found in data/$srcf.inc!"
				exit 1
			else
				[[ $interp = php ]] && x='<?php'$nl$x
				line=$(print -nr -- "$x" | "$interp")
				state=$?
			fi
			if (( state )); then
				print -ru2 "${interp:+Snippet for \"}${interp:-Inline shell snippet}${interp:+\"} returned errorlevel $state in data/$srcf.inc!"
				exit 1
			fi
			ei_body[entry]=${ei_body[entry]}${ei_body[entry]+$nl}$line
		else
			ei_body[entry]=${ei_body[entry]}${ei_body[entry]+$nl}$line
		fi
	done <"$TOP/$srcd/$srcf.inc"
	if (( state != 2 )); then
		print -ru2 "Last line of $srcd/$srcf.inc not a separator!"
		exit 1
	fi
	[[ -z $rcsid_parsed ]] || rcsid_db[${#rcsid_db[*]}]=$rcsid_parsed
done
integer entries=entry e=-1
if [[ -n $notimesort ]]; then
	state=0
	while (( ++e < entries )); do
		[[ ${ei_skip[e]} = 1 ]] || ei_indir[state++]=$e
	done
else
	while (( ++e < entries )); do
	[[ ${ei_skip[e]} = 1 ]] || print -- ${ei_time[e]} $e
	done | sort -nbk1,1 -k2,2 -k5,5 |&
	state=0
	while read -p MJD SEC GMT TZO entry; do
		ei_indir[state++]=$entry
	done
fi
entries=$state
return 0
@


1.32
log
@and, per flag in the .inc, for permalink pages
@
text
@d107 1
a107 1
	incfile_isold=1
@


1.31
log
@consolidate users/ subdirectory; I think this is as good as I get

also, do not use -nn any more, stop using Author: in .inc files,
change some MirOS/MirSolutions to MirBSD
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.29 2018/05/01 21:50:50 tg Exp $'
d107 1
d115 2
a116 1
				[[ $line = *USENN* ]] && usenn=1
d121 1
@


1.30
log
@document what the gmtoff is used for and add timezone offset string (faster)
@
text
@d3 1
a3 2
# This file is part of the website of The MirOS Project, which is
# copyrighted material, please read the LICENCE file for details.
d106 1
d108 11
a118 3
		if [[ $line = RCSID:* && -z $rcsid_parsed ]]; then
			rcsid_parsed=${line##RCSID:*([	 ])}
		elif [[ $line = ---- ]]; then
d128 1
a128 1
				else
@


1.29
log
@legibility improvements
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.24 2014/04/14 19:29:41 tg Exp $'
d69 1
d76 1
d90 2
a91 1
	ei_time[entry]="$(mjd_implode "${nt[@@]}") $to"
d226 1
a226 1
	done | sort -nbk1,1 -k2,2 -k4,4 |&
d228 1
a228 2
	# extra TZO used by inc2rss
	while read -p MJD SEC TZO entry; do
@


1.28
log
@g/c parser_usedate: the faster code was sorting wrong
@
text
@d31 2
a32 1
	set -A ta -- $tv =
d34 1
a34 7
		IFS=.
		set -A nt -- ${ta[0]}
		IFS=$save_IFS
		(( ra = 10#${nt[0]} ))
		(( rb = 10#${nt[1]} ))
		(( ry = 10#${nt[2]} ))
		ta[0]=$ry-$rb-$ra
d38 10
a48 3
		IFS=-
		set -A nt -- ${ta[0]}
		IFS=$save_IFS
a49 1
		(( rb = 10#${nt[1]} ))
d55 1
a55 2
		ta[1]=00:00:00
		ta[2]==
d69 1
a69 2
		ta[2]=+0000
		ta[3]==
d75 1
a81 1
	to=$((0${ta[2]::1}$((${ta[2]:1:2}*60+${ta[2]:3}))))
d83 1
a83 1
	set -A ta -- ${ta[0]} ${ta[1]}
d85 4
a88 8
	ei_time[entry]="$(mjd_implode \
	    $((10#0${ta[5]})) \
	    $((10#0${ta[4]})) \
	    $((10#0${ta[3]})) \
	    $((10#0${ta[2]})) \
	    $((10#0${ta[1]}-1)) \
	    $((10#0${ta[0]}-1900)) \
	    x x x $((60 * to)) x) $to"
d221 3
a223 3
	( integer e=-1; while (( ++e < entries )); do
		[[ ${ei_skip[e]} = 1 ]] || print ${ei_time[e]} $e
	  done | sort -nbk1,1 -k2,2 ) |&
d225 1
@


1.27
log
@switch to ISO 8601 dates:
â€¢ parse both obsolete German-format (dd.mm.YYYY) and ISO 8601 dates
â€¢ emit ISO 8601-format dates oÌ²nÌ²lÌ²yÌ²
@
text
@d23 29
a51 30
if (( parser_usedate )); then
	function parsedate {
		local ta tv=${e_date[entry]} to nt nd
		local -i10 -Z2 ra rb rc
		local -i10 -Z4 ry
		if [[ $tv = *=* ]]; then
			print -ru2 "Invalid date in $srcd/$srcf.inc: $line"
			exit 1
		fi
		set -A ta -- $tv =
		if [[ ${ta[0]} = +([0-9]).+([0-9]).+([0-9]) ]]; then
			IFS=.
			set -A nt -- ${ta[0]}
			IFS=$save_IFS
			(( ra = 10#${nt[0]} ))
			(( rb = 10#${nt[1]} ))
			(( ry = 10#${nt[2]} ))
			ta[0]=$ry-$rb-$ra
		elif [[ ${ta[0]} != +([0-9])-+([0-9])-+([0-9]) ]]; then
			print -ru2 "Invalid day in $srcd/$srcf.inc: $line"
			exit 1
		else
			IFS=-
			set -A nt -- ${ta[0]}
			IFS=$save_IFS
			(( ra = 10#${nt[2]} ))
			(( rb = 10#${nt[1]} ))
			(( ry = 10#${nt[0]} ))
		fi
		nd=$ry-$rb-$ra
d53 9
a61 32
		if [[ ${ta[1]} = = ]]; then
			ta[1]=00:00:00
			ta[2]==
		elif [[ ${ta[1]} != +([0-9]):+([0-9])?(:+([0-9])) ]]; then
			print -ru2 "Invalid tod in $srcd/$srcf.inc: $line"
			exit 1
		else
			IFS=:
			set -A nt -- ${ta[1]}
			IFS=$save_IFS
			(( ra = 10#${nt[0]} ))
			(( rb = 10#${nt[1]} ))
			(( rc = 10#${nt[2]} ))
			nd+=" $ra:$rb:$rc"
		fi
		if [[ ${ta[2]} = = ]]; then
			ta[2]=+0000
			ta[3]==
		elif [[ ${ta[2]} != [+-]@@([01][0-9]|2[0-3])@@([03]0|[14]5) ]]; then
			#XXX other offsets might apply (non-15min-multiples)
			print -ru2 "Invalid tz offset in $srcd/$srcf.inc: $line"
			exit 1
		else
			nd+=" ${ta[2]}"
		fi
		if [[ ${ta[3]} != = ]]; then
			print -ru2 "Invalid date in $srcd/$srcf.inc: $line"
			exit 1
		fi
		to=$((0${ta[2]::1}$((${ta[2]:1:2}*60+${ta[2]:3}))))
		IFS=$IFS:-
		set -A ta -- ${ta[0]} ${ta[1]}
d63 33
a95 35
		ei_time[entry]="$(mjd_implode \
		    $((10#0${ta[5]})) \
		    $((10#0${ta[4]})) \
		    $((10#0${ta[3]})) \
		    $((10#0${ta[2]})) \
		    $((10#0${ta[1]}-1)) \
		    $((10#0${ta[0]}-1900)) \
		    x x x $((60 * to)) x) $to"
		e_date[entry]=$nd
	}
else
	# split up ISO 8610 (YYYY-mm-dd [HH:MM:SS])
	# or older german format (d.m.yyyy [H:M:S])
	# date, then pad to YYYY-mm-dd and store it
	function parsedate {
		local ta
		IFS=$IFS:.-
		set -A ta -- ${e_date[entry]}
		IFS=$save_IFS
		typeset -i -Z2 e_tmpd e_tmpm
		typeset -i -Z4 e_tmpy
		if [[ ${e_date[entry]} = +([0-9]).+([0-9]).+([0-9])* ]]; then
			e_tmpd=10#0${ta[0]}
			e_tmpm=10#0${ta[1]}
			e_tmpy=10#0${ta[2]}
		else
			e_tmpd=10#0${ta[2]}
			e_tmpm=10#0${ta[1]}
			e_tmpy=10#0${ta[0]}
		fi
		e_date[entry]=$e_tmpy-$e_tmpm-$e_tmpd
		# only used if [[ -z $notimesort ]]
		ei_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) $((10#0${ta[3]})) $((10#0${ta[4]})) $((10#0${ta[5]}))"
	}
fi
d219 1
a219 1
integer entries=entry
a220 1
	entry=-1
d222 2
a223 2
	while (( ++entry < entries )); do
		[[ ${ei_skip[entry]} = 1 ]] || ei_indir[state++]=$entry
d225 1
a225 1
elif (( parser_usedate )); then
a232 8
else
	( integer e=-1; while (( ++e < entries )); do
		[[ ${ei_skip[e]} = 1 ]] || print ${ei_time[e]} $e
	  done | sort -nbk1,1 -k2,2 -k3,3 -k4,4 -k5,5 -k6,6 ) |&
	state=0
	while read -p y m d H M S entry; do
		ei_indir[state++]=$entry
	done
@


1.26
log
@update for compatibility with newer mksh
@
text
@d25 3
a27 1
		local ta tv=${e_date[entry]} to
d33 9
a41 1
		if [[ ${ta[0]} != +([0-9]).+([0-9]).+([0-9]) ]]; then
d44 7
d52 2
d56 1
a56 2
			ta[2]=+0000
			ta[3]==
d60 8
d73 1
d76 2
d84 1
a84 1
		IFS=$IFS:.
d91 1
a91 1
		    $((10#0${ta[0]})) \
d93 1
a93 1
		    $((10#0${ta[2]}-1900)) \
d95 1
a95 13
	}
elif [[ -n $notimesort ]]; then
	# split up german format (d.m.yyyy [H:M:S])
	# date, then pad to dd.mm.yyyy and store it
	function parsedate {
		local ta
		IFS=$IFS:.
		set -A ta -- ${e_date[entry]}
		IFS=$save_IFS
		typeset -i -Z2 e_tmpd=10#0${ta[0]}
		typeset -i -Z2 e_tmpm=10#0${ta[1]}
		typeset -i -Z4 e_tmpy=10#0${ta[2]}
		e_date[entry]=$e_tmpd.$e_tmpm.$e_tmpy
d98 3
a100 2
	# split up german format (d.m.yyyy [H:M:S])
	# date, then pad to dd.mm.yyyy and store it
d103 1
a103 1
		IFS=$IFS:.
d106 14
a119 7
		typeset -i -Z2 e_tmpd=10#0${ta[0]}
		typeset -i -Z2 e_tmpm=10#0${ta[1]}
		typeset -i -Z4 e_tmpy=10#0${ta[2]}
		e_date[entry]=$e_tmpd.$e_tmpm.$e_tmpy
		ei_time[entry]="$(print -r -- \
		    $((e_tmpy)) $((e_tmpm)) $((e_tmpd)) \
		    $((10#0${ta[3]})) $((10#0${ta[4]})) $((10#0${ta[5]})))"
d141 2
a142 2
					id=${e_date[entry]}
					id=e${id:6:4}${id:3:2}${id::2}
@


1.25
log
@add the ability to put stuff like
<?
<?php
<?/usr/local/bin/php5
etc. into *.inc files, developed for Teckids e.V.

The <? must be at the beginning of a line and eats until a line consisting
solely of ?>; anything after <? is the interpreter, using a $PATH search;
just <? uses a subshell (with read-only access to MirWebseite interna);
<?php is copied into the input, anything else loses the <?* line.
@
text
@d156 1
a156 1
				parser_lctmp=${line/%:+([	 ])$x}	# key
@


1.24
log
@this should allow reading waypoint info (and wlog entries) from a users/ subdir
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.23 2012/07/15 14:21:44 tg Exp $'
d183 27
@


1.23
log
@remove debugging comments again
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.22 2012/07/15 14:16:44 tg Exp $'
d27 1
a27 1
			print -ru2 "Invalid date in data/$srcf.inc: $line"
d32 1
a32 1
			print -ru2 "Invalid day in data/$srcf.inc: $line"
d40 1
a40 1
			print -ru2 "Invalid tod in data/$srcf.inc: $line"
d47 1
a47 1
			print -ru2 "Invalid tz offset in data/$srcf.inc: $line"
d51 1
a51 1
			print -ru2 "Invalid date in data/$srcf.inc: $line"
d99 2
d164 1
a164 1
				print -ru2 "Unknown header in data/$srcf.inc:" \
d177 1
a177 1
						    "data/$srcf.inc: $line"
d186 1
a186 1
	done <"$TOP/data/$srcf.inc"
d188 1
a188 1
		print -ru2 "Last line of data/$srcf.inc not a separator!"
@


1.22
log
@use the mkah time manipulation code instead of spawning a C helper

\o/

actually, we can now write wlog entries with timezones!
they're mostly ignored for the HTML output, which stupidly takes
the day.month.year for the output (and the d.m.y H:M:S for sorting)
but used in the RSS feed (for sorting â€“ subtracting the time zone
offset appropriately â€“ and the entry date, which shows the original
time zone offset now)
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.21 2011/07/25 09:33:53 tg Exp $'
a203 1
		#print -u2 "D: read MJD=$MJD SEC=$SEC TZO=$TZO e=$entry"
a211 1
		#print -u2 "D: read y=$y m=$m d=$d H=$H M=$M S=$S e=$entry"
@


1.21
log
@*** empty log message ***
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.20 2008/12/04 20:55:12 tg Exp $'
d23 75
d162 1
a162 1
				print -u2 "Unknown header in data/$srcf.inc:" \
d168 1
a168 12
				# split up german format (d.m.yyyy [H:M:S])
				# date, then pad to dd.mm.yyyy and store as
				# y m d H M S for strftm
				IFS=$IFS:.
				set -A e_tmp ${e_date[entry]}
				IFS=$save_IFS
				typeset -i -Z2 e_tmpd=10#0${e_tmp[0]}
				typeset -i -Z2 e_tmpm=10#0${e_tmp[1]}
				typeset -i -Z4 e_tmpy=10#0${e_tmp[2]}
				e_date[entry]=$e_tmpd.$e_tmpm.$e_tmpy
				# make sure there are no leading zeroes
				ei_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) $((10#0${e_tmp[3]})) $((10#0${e_tmp[4]})) $((10#0${e_tmp[5]}))"
d174 1
a174 1
						print -u2 "Invalid tag '$x' in" \
d186 1
a186 1
		print -u2 "Last line of data/$srcf.inc not a separator!"
d198 9
d213 1
@


1.20
log
@fix RCS IDs for the db-generated files
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.19 2008/12/04 19:38:48 tg Exp $'
d13 1
d65 9
@


1.19
log
@allow *.cfg files with different *.inc files, and more than one,
and selection by tags
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.18 2008/12/04 19:10:47 tg Exp $'
d115 1
@


1.18
log
@do the date sort
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.17 2008/12/04 18:49:00 tg Exp $'
d11 1
d22 6
a27 1
for srcf in $name; do
d56 8
d97 1
a97 1
				e_tag[entry]=
d119 1
d121 1
a121 1
		ei_indir[entry]=$entry
d125 2
a126 2
		print ${ei_time[e]} $e
	  done | tee /tmp/x1 | sort -nbk1,1 -k2,2 -k3,3 -k4,4 -k5,5 -k6,6 | tee /tmp/x2 ) |&
d132 1
@


1.17
log
@mostly revert 10049381F5928153949, it does not help
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.16 2008/12/04 18:34:05 tg Exp $'
a18 1
integer tai
a49 1
			ei_indir[entry]=$entry
d60 2
d103 15
@


1.16
log
@add a level of indirection to the entry accesses; we will use this
to sort entries by mtime (because the order in the file is relevant
for the permalinks, so we cannot add between two other entries in
some cases) and, later, for tag collections
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.15 2008/12/04 18:25:50 tg Exp $'
d70 2
a71 2
				# date, then pad to dd.mm.yyyy HH:MM:SS and
				# store for strftm as y m d H M S
d78 1
a78 4
				typeset -i -Z2 e_tmpH=10#0${e_tmp[3]}
				typeset -i -Z2 e_tmpM=10#0${e_tmp[4]}
				typeset -i -Z2 e_tmpS=10#0${e_tmp[5]}
				e_date[entry]="$e_tmpd.$e_tmpm.$e_tmpy $e_tmpH:$e_tmpM:$e_tmpS"
d80 1
a80 1
				ei_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) $((e_tmpH)) $((e_tmpM)) $((e_tmpS))"
@


1.15
log
@optimise
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.14 2008/12/04 18:24:37 tg Exp $'
d9 1
d51 1
@


1.14
log
@move per-file initialisations into the loop
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.13 2008/12/04 18:23:19 tg Exp $'
d9 2
a84 1
				sp=
d91 1
a91 2
					e_tag[entry]=${e_tag[entry]}$sp$x
					sp=' '
@


1.13
log
@wrap the main operation thing in a one-element loop
(whitespace change and rewrapping only, no functional change)
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.12 2008/12/04 18:20:02 tg Exp $'
d14 2
a15 3
integer guid=10000
ids=:
integer state=1
a17 1
rcsid_parsed=
d20 4
@


1.12
log
@operate e_date as fixed-format "dd.mm.yyyy HH:MM:SS" internally
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.11 2008/12/04 14:14:17 tg Exp $'
d21 35
a55 10
srcf=$name

while IFS= read -r line; do
	if [[ $line = RCSID:* && -z $rcsid_parsed ]]; then
		rcsid_parsed=${line##RCSID:*([	 ])}
	elif [[ $line = ---- ]]; then
		if [[ -z ${e_id[entry]} ]]; then
			if [[ -n ${e_date[entry]} ]]; then
				id=${e_date[entry]}
				id=e${id:6:4}${id:3:2}${id::2}
d57 3
a59 1
				id=g$((guid++))
d61 30
a90 4
			if [[ -n ${e_author[entry]} ]]; then
				id=${id}-${e_author[entry]%%@@(@@)*}
			else
				id=${id}-nn
a91 18
			e_id[entry]=$id
		fi
		while [[ :$ids = *:${e_id[entry]}:* ]]; do
			e_id[entry]=${e_id[entry]}-g$guid
			let guid++
		done
		ei_srcf[entry]=$srcf
		ids=$ids${e_id[entry]}:
		let ++entry
		state=2
	elif (( state > 0 )); then
		if [[ $line = @@([A-Za-z]*([A-Za-z0-9_]):\ *) ]]; then
			x=${line##+([A-Za-z0-9_]):+([	 ])}	# value
			parser_lctmp=${line/%:+([	 ])$x}	# key
			eval e_$parser_lctmp[entry]=\$x
		elif [[ -z $line ]]; then
			state=0
			continue
d93 1
a93 31
			print -u2 "Unknown header in data/$srcf.inc: $line"
			exit 1
		fi
		state=1
		if [[ $parser_lctmp = date ]]; then
			# split up german format (d.m.yyyy [H:M:S]) date, then
			# pad to dd.mm.yyyy HH:MM:SS and store as y m d H M S
			IFS=$IFS:.; set -A e_tmp ${e_date[entry]}; IFS=$save_IFS
			typeset -i -Z2 e_tmpd=10#0${e_tmp[0]}
			typeset -i -Z2 e_tmpm=10#0${e_tmp[1]}
			typeset -i -Z4 e_tmpy=10#0${e_tmp[2]}
			typeset -i -Z2 e_tmpH=10#0${e_tmp[3]}
			typeset -i -Z2 e_tmpM=10#0${e_tmp[4]}
			typeset -i -Z2 e_tmpS=10#0${e_tmp[5]}
			e_date[entry]="$e_tmpd.$e_tmpm.$e_tmpy $e_tmpH:$e_tmpM:$e_tmpS"
			# make sure there are no leading zeroes
			ei_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) \
			    $((e_tmpH)) $((e_tmpM)) $((e_tmpS))"
		elif [[ $parser_lctmp = tag ]]; then
			parser_lctmp=${e_tag[entry]}
			e_tag[entry]=
			sp=
			for x in $parser_lctmp; do
				if [[ $x != +([0-9a-z_]) ]]; then
					print -u2 "Invalid tag '$x' in" \
					    "data/$srcf.inc: $line"
					continue
				fi
				e_tag[entry]=${e_tag[entry]}$sp$x
				sp=' '
			done
d95 4
a98 2
	else
		ei_body[entry]=${ei_body[entry]}${ei_body[entry]+$nl}$line
d100 1
a100 5
done <"$TOP/data/$srcf.inc"
if (( state != 2 )); then
	print -u2 "Last line of data/$srcf.inc not a separator!"
	exit 1
fi
@


1.11
log
@decouple *.cfg file name from *.inc file name
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.10 2008/12/04 14:04:44 tg Exp $'
d30 1
a30 1
				id=e${id:6}${id:3:2}${id::2}
d64 1
a64 1
			# pad to dd.mm.yyyy and store as S,M,H,d,m,y
d69 4
a72 1
			e_date[entry]=$e_tmpd.$e_tmpm.$e_tmpy
d75 1
a75 1
			    $((10#0${e_tmp[3]})) $((10#0${e_tmp[4]})) $((10#0${e_tmp[5]}))"
@


1.10
log
@e_* variables are for header lines (author, title, date, tag, ...)
and ei_* are for internal stuff (body, date, ...)
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.9 2008/12/04 13:23:35 tg Exp $'
d21 2
d45 1
d58 1
a58 1
			print -u2 "Unknown header in data/$name.inc: $line"
d80 1
a80 1
					    "data/$name.inc: $line"
d90 1
a90 1
done <"$TOP/data/$name.inc"
d92 1
a92 1
	print -u2 "Last line of data/$name.inc not a separator!"
@


1.9
log
@syntax-check tags: [0-9a-z_]+
they are auto-converted to lower case
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.8 2008/11/08 16:28:45 tg Exp $'
d8 1
a8 1
set -A e_body
d68 1
a68 1
			e_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) \
d85 1
a85 1
		e_body[entry]=${e_body[entry]}${e_body[entry]+$nl}$line
@


1.8
log
@use a C tool (statically linked for speed) instead of perl for calculating
the RSS time stamps, because this is much faster (and brings back dst info)
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.7 2008/09/17 21:52:07 tg Exp $'
d70 13
@


1.7
log
@â€¢ ensure UTC
â€¢ calculate things only when needed
â€¢ fold calculations many-into-one
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.6 2008/09/17 21:21:39 tg Exp $'
d68 2
a69 1
			e_time[entry]=$((10#0${e_tmp[5]})),$((10#0${e_tmp[4]})),$((10#0${e_tmp[3]})),$((e_tmpd)),$((e_tmpm - 1)),$((e_tmpy - 1900))
@


1.6
log
@retire getdate
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.5 2008/07/24 13:09:39 tg Exp $'
a5 1
set -A ei_date
d26 3
a28 2
			if [[ -n ${ei_date[entry]} ]]; then
				id=e$(date -r ${ei_date[entry]} +'%Y%m%d')
d30 1
a30 2
				id=g$guid
				let guid++
d61 1
a61 1
			# pad to dd.mm.yyyy and scan as yyyy-mm-dd [H:M:S] UTC
a65 3
			typeset -i -Z2 e_tmpH=10#0${e_tmp[3]}
			typeset -i -Z2 e_tmpM=10#0${e_tmp[4]}
			typeset -i -Z2 e_tmpS=10#0${e_tmp[5]}
d67 2
a68 3
			integer ei_date[entry]=$(perl -MPOSIX -e "print
			    mktime($e_tmpS, $e_tmpM, $e_tmpH,
			    $e_tmpd, $e_tmpm, $((e_tmpy - 1900)));")
@


1.5
log
@add better rcs ids, copyright, etc.
@
text
@d1 1
a1 1
rcsid_parser='$MirOS: www/mk/parser,v 1.4 2008/07/18 13:20:47 tg Exp $'
d71 3
a73 7
			tdate="$e_tmpy-$e_tmpm-$e_tmpd $e_tmpH:$e_tmpM:$e_tmpS"
			"$DST"/getdate "$tdate" |&
			while read -p tai rest; do
				integer ei_date[entry]=tai
				break
			done
			while read -p rest; do :; done	# flush co-process
@


1.4
log
@use mksh-current feature (substrpl) to avoid parsing bug
(apparently, ${foo%bar} is buggy if bar contains [])
@
text
@d1 1
a1 1
# $MirOS: www/mk/parser,v 1.3 2008/04/13 00:39:09 tg Exp $
d20 1
d23 3
a25 1
	if [[ $line = ---- ]]; then
@


1.3
log
@allow time-of-the-day numbers in Date: headers
@
text
@d1 1
a1 1
# $MirOS: www/mk/parser,v 1.2 2007/08/29 19:46:31 tg Exp $
d47 1
a47 1
			parser_lctmp=${line%:+([	 ])$x}	# key
@


1.2
log
@â€¢ fix logic error: e_grdate[] is the german format date (dd.mm.yyyy), not
  the international format date (yyyy-mm-dd), affects output
â€¢ rename e_date[] to ei_date[] (so it is shown that the array is integer)
â€¢ rename e_grdate[] to e_date[]
â€¢ pad the german format date by zeroes if some lazy git forgot it
â€¢ simplify the header parser, makes adding more lines possible/flexible
â€¢ mkshify the parser; save a few spawns too
â€¢ improve error messages
â€¢ possibly improve performance@
text
@d1 1
a1 1
# $MirOS: www/mk/parser,v 1.1 2007/06/09 23:29:54 tg Exp $
d58 12
a69 6
			# split up german format (d.m.yyyy) date, then
			# pad to dd.mm.yyyy and scan as yyyy-mm-dd UTC
			IFS=.; set -A e_tmp ${e_date[entry]}; IFS=$save_IFS
			typeset -Z4 e_tmp
			e_date[entry]=${e_tmp[0]#00}.${e_tmp[1]#00}.${e_tmp[2]}
			"$DST"/getdate "${e_tmp[2]}-${e_tmp[1]#00}-${e_tmp[0]#00} 00:00:00Z" |&
@


1.1
log
@switch to the new website system, keeping legacy content around
@
text
@d1 1
a1 1
# $MirOS: www/mk/parser,v 1.4 2007/06/03 21:01:18 tg Exp $
d6 1
a6 2
set -A e_date
set -A e_grdate
a8 1
set -A e_title
d13 1
d17 3
a19 1
state=1
d24 2
a25 2
			if [[ -n ${e_date[entry]} ]]; then
				id=e$(date -r ${e_date[entry]} +'%Y%m%d')
d44 5
a48 13
	elif [[ $state = @@(1|2) ]]; then
		state=1
		if [[ $line = @@(Date:)* ]]; then
			e_grdate[entry]=$(print ${line##@@(Date:)+([ 	])} | \
			    sed 's/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\3-\2-\1/')
			x=$("$DST"/getdate "${e_grdate[entry]} 00:00:00Z")
			let "e_date[entry]=${x%%*([	 ])=*}"
		elif [[ $line = @@(Author:)* ]]; then
			e_author[entry]=${line##@@(Author:)+([	 ])}
		elif [[ $line = @@(Title:)* ]]; then
			e_title[entry]=${line##@@(Title:)+([	 ])}
		elif [[ $line = @@(Id:)* ]]; then
			e_id[entry]=${line##@@(Id:)+([	 ])}
d51 1
d53 16
a68 1
			print -u2 "Unknown header: $line"
d74 1
a74 1
if [[ $state != 2 ]]; then
@

