head	1.9;
access;
symbols
	autoconf-2_60:1.1.101.2
	autoconf-2_59:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@# @;


1.9
date	2008.05.03.20.24.30;	author tg;	state Exp;
branches;
next	1.8;
commitid	100481CCA0558996D8A;

1.8
date	2008.05.03.18.42.40;	author tg;	state Exp;
branches;
next	1.7;
commitid	100481CB22D0CD0420A;

1.7
date	2008.05.02.23.42.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	100481BA6F962D736F1;

1.6
date	2006.06.30.21.08.06;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044A592C9255BC5C1;

1.5
date	2006.06.12.19.10.32;	author tg;	state Exp;
branches;
next	1.4;
commitid	100448DBC3A751BBC33;

1.4
date	2006.06.12.19.04.30;	author tg;	state Exp;
branches;
next	1.3;
commitid	100448DBAB6767F408A;

1.3
date	2005.02.28.22.36.19;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.11.00.37.33;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.10.19.34.36;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2006.06.12.18.29.02;	author tg;	state Exp;
branches;
next	1.1.101.2;
commitid	100448DB27B78EB359F;

1.1.101.2
date	2006.06.12.18.29.39;	author tg;	state Exp;
branches;
next	1.1.101.3;
commitid	100448DB29F646070DD;

1.1.101.3
date	2006.06.30.21.06.46;	author tg;	state Exp;
branches;
next	1.1.101.4;
commitid	10044A59275182C566A;

1.1.101.4
date	2008.05.03.17.55.27;	author tg;	state Exp;
branches;
next	;
commitid	100481CA71E436D39BB;


desc
@@


1.9
log
@remove some code which throws
| m4: m4sugar.inc at line 1655: null definition.
fix welcome
@
text
@divert(-1)#                                                  -*- Autoconf -*-
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.8 2008/05/03 18:42:40 tg Exp $
#-
# This file is part of Autoconf.
# Base M4 layer.
# Hacked for MirOS m4.
#
# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
# 2008 Free Software Foundation, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
#
# As a special exception, the Free Software Foundation gives unlimited
# permission to copy, distribute and modify the configure scripts that
# are the output of Autoconf.  You need not follow the terms of the GNU
# General Public License when using or distributing such scripts, even
# though portions of the text of Autoconf appear in them.  The GNU
# General Public License (GPL) does govern all other use of the material
# that constitutes the Autoconf program.
#
# Certain portions of the Autoconf source text are designed to be copied
# (in certain cases, depending on the input) into the output of
# Autoconf.  We call these the "data" portions.  The rest of the Autoconf
# source text consists of comments plus executable code that decides which
# of the data portions to output in any given case.  We call these
# comments and executable code the "non-data" portions.  Autoconf never
# copies any of the non-data portions into its output.
#
# This special exception to the GPL applies to versions of Autoconf
# released by the Free Software Foundation.  When you make and
# distribute a modified version of Autoconf, you may extend this special
# exception to the GPL to apply to your modified version as well, *unless*
# your modified version has the potential to copy into its output some
# of the text that was the non-data portion of the version that you started
# with.  (In other words, unless your change moves or copies text from
# the non-data portions to the data portions.)  If your modification has
# such potential, you must delete any notice of this special exception
# to the GPL from your modified version.
#
# Written by Akim Demaille.
#

# Set the quotes, whatever the current quoting system.
changequote()
changequote([, ])

# Some old m4's don't support m4exit.  But they provide
# equivalent functionality by core dumping because of the
# long macros we define.
ifdef([__gnu__], ,
[errprint(M4sugar requires GNU M4. Install it before installing M4sugar or
set the M4 environment variable to its absolute file name.)
m4exit(2)])


## ------------------------------- ##
## 1. Simulate --prefix-builtins.  ##
## ------------------------------- ##

# m4_define
# m4_defn
# m4_undefine
define([m4_define],   defn([define]))
define([m4_defn],     defn([defn]))
define([m4_undefine], defn([undefine]))

m4_undefine([define])
m4_undefine([defn])
m4_undefine([undefine])


# m4_copy(SRC, DST)
# -----------------
# Define DST as the definition of SRC.
# What's the difference between:
# 1. m4_copy([from], [to])
# 2. m4_define([to], [from($@@)])
# Well, obviously 1 is more expensive in space.  Maybe 2 is more expensive
# in time, but because of the space cost of 1, it's not that obvious.
# Nevertheless, one huge difference is the handling of `$0'.  If `from'
# uses `$0', then with 1, `to''s `$0' is `to', while it is `from' in 2.
# The user would certainly prefer to see `to'.
m4_define([m4_copy],
[m4_define([$2], m4_defn([$1]))])


# m4_rename(SRC, DST)
# -------------------
# Rename the macro SRC to DST.
m4_define([m4_rename],
[m4_copy([$1], [$2])m4_undefine([$1])])


# m4_rename_m4(MACRO-NAME)
# ------------------------
# Rename MACRO-NAME to m4_MACRO-NAME.
m4_define([m4_rename_m4],
[m4_rename([$1], [m4_$1])])


# m4_copy_unm4(m4_MACRO-NAME)
# ---------------------------
# Copy m4_MACRO-NAME to MACRO-NAME.
m4_define([m4_copy_unm4],
[m4_copy([$1], m4_bpatsubst([$1], [^m4_\(.*\)], [[\1]]))])


# Some m4 internals have names colliding with tokens we might use.
# Rename them a` la `m4 --prefix-builtins'.
m4_rename_m4([builtin])
m4_rename_m4([changecom])
m4_rename_m4([changequote])
m4_undefine([changeword])
m4_rename_m4([debugfile])
m4_rename_m4([debugmode])
m4_rename_m4([decr])
m4_undefine([divert])
m4_rename_m4([divnum])
m4_rename_m4([dumpdef])
m4_rename_m4([errprint])
m4_rename_m4([esyscmd])

m4_define([m4_eval], [builtin([eval], $@@)])

m4_rename_m4([format])
m4_rename_m4([ifdef])
m4_rename([ifelse], [m4_if])
m4_undefine([include])
m4_rename_m4([incr])
m4_rename_m4([index])
m4_rename_m4([indir])
m4_rename_m4([len])
m4_rename([m4exit], [m4_exit])
m4_undefine([m4wrap])
m4_ifdef([mkstemp],dnl added in M4 1.4.8
[m4_rename_m4([mkstemp])
m4_copy([m4_mkstemp], [m4_maketemp])
m4_undefine([maketemp])],
[m4_rename_m4([maketemp])
m4_copy([m4_maketemp], [m4_mkstemp])])
m4_copy([patsubst], [m4_patsubst])
m4_rename([patsubst], [m4_bpatsubst])
m4_undefine([popdef])
m4_rename_m4([pushdef])
m4_copy([regexp], [m4_regexp])
m4_rename([regexp], [m4_bregexp])

m4_define([m4_shift], [builtin([shift], $@@)])

m4_rename_m4([sinclude])
dnl m4_undefine([sinclude])

m4_rename_m4([substr])
m4_rename_m4([symbols])
m4_rename_m4([syscmd])
m4_rename_m4([sysval])
m4_rename_m4([traceoff])
m4_rename_m4([traceon])
m4_rename_m4([translit])
m4_undefine([undivert])


## ------------------- ##
## 2. Error messages.  ##
## ------------------- ##


# m4_location
# -----------
m4_define([m4_location],
[__file__:__line__])


# m4_errprintn(MSG)
# -----------------
# Same as `errprint', but with the missing end of line.
m4_define([m4_errprintn],
[m4_errprint([$1
])])


# m4_warning(MSG)
# ---------------
# Warn the user.
m4_define([m4_warning],
[m4_errprintn(m4_location[: warning: $1])])


# m4_fatal(MSG, [EXIT-STATUS])
# ----------------------------
# Fatal the user.                                                      :)
m4_define([m4_fatal],
[m4_errprintn(m4_location[: error: $1])dnl
m4_expansion_stack_dump()dnl
m4_exit(m4_if([$2],, 1, [$2]))])


# m4_assert(EXPRESSION, [EXIT-STATUS = 1])
# ----------------------------------------
# This macro ensures that EXPRESSION evaluates to true, and exits if
# EXPRESSION evaluates to false.
m4_define([m4_assert],
[m4_if(m4_eval([$1]), 0,
       [m4_fatal([assert failed: $1], [$2])])])



## ------------- ##
## 3. Warnings.  ##
## ------------- ##


# _m4_warn(CATEGORY, MESSAGE, STACK-TRACE)
# ----------------------------------------
# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
# This is for traces only.
# The STACK-TRACE is a \n-separated list of "LOCATION: MESSAGE".
#
# Within m4, the macro is a no-op.  This macro really matters
# when autom4te post-processes the trace output.
m4_define([_m4_warn], [])


# m4_warn(CATEGORY, MESSAGE)
# --------------------------
# Report a MESSAGE to the autoconf user if the CATEGORY of warnings
# is requested (in fact, not disabled).
m4_define([m4_warn],
[_m4_warn([$1], [$2],
m4_ifdef([m4_expansion_stack],
	 [m4_defn([m4_expansion_stack])
m4_location[: the top level]]))dnl
])



## ------------------- ##
## 4. File inclusion.  ##
## ------------------- ##


# We also want to neutralize include (and sinclude for symmetry),
# but we want to extend them slightly: warn when a file is included
# several times.  This is, in general, a dangerous operation, because
# too many people forget to quote the first argument of m4_define.
#
# For instance in the following case:
#   m4_define(foo, [bar])
# then a second reading will turn into
#   m4_define(bar, [bar])
# which is certainly not what was meant.

# m4_include_unique(FILE)
# -----------------------
# Declare that the FILE was loading; and warn if it has already
# been included.
m4_define([m4_include_unique],
[m4_ifdef([m4_include($1)],
	  [m4_warn([syntax], [file `$1' included several times])])dnl
m4_define([m4_include($1)])])


# m4_include(FILE)
# ----------------
# Like the builtin include, but warns against multiple inclusions.
m4_define([m4_include],
[m4_include_unique([$1])dnl
m4_builtin([include], [$1])])


# m4_sinclude(FILE)
# -----------------
# Like the builtin sinclude, but warns against multiple inclusions.
m4_define([m4_sinclude],
[m4_include_unique([$1])dnl
m4_builtin([sinclude], [$1])])



## ------------------------------------ ##
## 5. Additional branching constructs.  ##
## ------------------------------------ ##

# Both `m4_ifval' and `m4_ifset' tests against the empty string.  The
# difference is that `m4_ifset' is specialized on macros.
#
# In case of arguments of macros, eg. $1, it makes little difference.
# In the case of a macro `FOO', you don't want to check `m4_ifval(FOO,
# TRUE)', because if `FOO' expands with commas, there is a shifting of
# the arguments.  So you want to run `m4_ifval([FOO])', but then you just
# compare the *string* `FOO' against `', which, of course fails.
#
# So you want the variation `m4_ifset' that expects a macro name as $1.
# If this macro is both defined and defined to a non empty value, then
# it runs TRUE, etc.


# m4_ifval(COND, [IF-TRUE], [IF-FALSE])
# -------------------------------------
# If COND is not the empty string, expand IF-TRUE, otherwise IF-FALSE.
# Comparable to m4_ifdef.
m4_define([m4_ifval],
[m4_if([$1], [], [$3], [$2])])


# m4_n(TEXT)
# ----------
# If TEXT is not empty, return TEXT and a new line, otherwise nothing.
m4_define([m4_n],
[m4_if([$1],
       [], [],
	   [$1
])])


# m4_ifvaln(COND, [IF-TRUE], [IF-FALSE])
# --------------------------------------
# Same as `m4_ifval', but add an extra newline to IF-TRUE or IF-FALSE
# unless that argument is empty.
m4_define([m4_ifvaln],
[m4_if([$1],
       [],   [m4_n([$3])],
	     [m4_n([$2])])])


# m4_ifset(MACRO, [IF-TRUE], [IF-FALSE])
# --------------------------------------
# If MACRO has no definition, or of its definition is the empty string,
# expand IF-FALSE, otherwise IF-TRUE.
m4_define([m4_ifset],
[m4_ifdef([$1],
	  [m4_ifval(m4_defn([$1]), [$2], [$3])],
	  [$3])])


# m4_ifndef(NAME, [IF-NOT-DEFINED], [IF-DEFINED])
# -----------------------------------------------
m4_define([m4_ifndef],
[m4_ifdef([$1], [$3], [$2])])


# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
# -----------------------------------------------------------
# m4 equivalent of
# switch (SWITCH)
# {
#   case VAL1:
#     IF-VAL1;
#     break;
#   case VAL2:
#     IF-VAL2;
#     break;
#   ...
#   default:
#     DEFAULT;
#     break;
# }.
# All the values are optional, and the macro is robust to active
# symbols properly quoted.
m4_define([m4_case],
[m4_if([$#], 0, [],
       [$#], 1, [],
       [$#], 2, [$2],
       [$1], [$2], [$3],
       [m4_case([$1], m4_shift3($@@))])])


# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
# -----------------------------------------------------
# m4 equivalent of
#
# if (SWITCH =~ RE1)
#   VAL1;
# elif (SWITCH =~ RE2)
#   VAL2;
# elif ...
#   ...
# else
#   DEFAULT
#
# All the values are optional, and the macro is robust to active symbols
# properly quoted.
m4_define([m4_bmatch],
[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
       [$#], 2, [$2],
       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shift3($@@))],
	      [$3])])])
m4_copy([m4_bmatch], [m4_match])


# m4_car(LIST)
# m4_cdr(LIST)
# ------------
# Manipulate m4 lists.
m4_define([m4_car], [[$1]])
m4_define([m4_cdr],
[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
       [$#], 1, [],
       [m4_dquote(m4_shift($@@))])])

# _m4_cdr(LIST)
# -------------
# Like m4_cdr, except include a leading comma unless only one element
# remains.  Why?  Because comparing a large list against [] is more
# expensive in expansion time than comparing the number of arguments; so
# _m4_cdr can be used to reduce the number of arguments when it is time
# to end recursion.
m4_define([_m4_cdr],
[m4_if([$#], 1, [],
       [, m4_dquote(m4_shift($@@))])])



# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
# -------------------------------------------------------------------
# Similar to m4_if, except that each TEST is expanded when encountered.
# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
# The result is DEFAULT if no tests passed.  This macro allows
# short-circuiting of expensive tests, where it pays to arrange quick
# filter tests to run first.
#
# For an example, consider a previous implementation of _AS_QUOTE_IFELSE:
#
#    m4_if(m4_index([$1], [\]), [-1], [$2],
#          m4_eval(m4_index([$1], [\\]) >= 0), [1], [$2],
#          m4_eval(m4_index([$1], [\$]) >= 0), [1], [$2],
#          m4_eval(m4_index([$1], [\`]) >= 0), [1], [$3],
#          m4_eval(m4_index([$1], [\"]) >= 0), [1], [$3],
#          [$2])
#
# Here, m4_index is computed 5 times, and m4_eval 4, even if $1 contains
# no backslash.  It is more efficient to do:
#
#    m4_cond([m4_index([$1], [\])], [-1], [$2],
#            [m4_eval(m4_index([$1], [\\]) >= 0)], [1], [$2],
#            [m4_eval(m4_index([$1], [\$]) >= 0)], [1], [$2],
#            [m4_eval(m4_index([$1], [\`]) >= 0)], [1], [$3],
#            [m4_eval(m4_index([$1], [\"]) >= 0)], [1], [$3],
#            [$2])
#
# In the common case of $1 with no backslash, only one m4_index expansion
# occurs, and m4_eval is avoided altogether.
m4_define([m4_cond],
[m4_if([$#], [0], [m4_fatal([$0: cannot be called without arguments])],
       [$#], [1], [$1],
       [$#], [2], [m4_fatal([$0: missing an argument])],
       [m4_if($1, [$2], [$3], [$0(m4_shift3($@@))])])])


## ---------------------------------------- ##
## 6. Enhanced version of some primitives.  ##
## ---------------------------------------- ##

# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
# ----------------------------------------------------
# m4 equivalent of
#
#   $_ = STRING;
#   s/RE1/SUBST1/g;
#   s/RE2/SUBST2/g;
#   ...
#
# All the values are optional, and the macro is robust to active symbols
# properly quoted.
#
# I would have liked to name this macro `m4_bpatsubst', unfortunately,
# due to quotation problems, I need to double quote $1 below, therefore
# the anchors are broken :(  I can't let users be trapped by that.
#
# Recall that m4_shift3 always results in an argument.  Hence, we need
# to distinguish between a final deletion vs. ending recursion.
m4_define([m4_bpatsubsts],
[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
       [$#], 2, [m4_builtin([patsubst], [$1], [$2])],
       [_$0($@@m4_if(m4_eval($# & 1), 0, [,]))])])
m4_define([_m4_bpatsubsts],
[m4_if([$#], 2, [$1],
       [$0(m4_builtin([patsubst], [[$1]], [$2], [$3]),
	   m4_shift3($@@))])])


# m4_define_default(MACRO, VALUE)
# -------------------------------
# If MACRO is undefined, set it to VALUE.
m4_define([m4_define_default],
[m4_ifndef([$1], [m4_define($@@)])])


# m4_default(EXP1, EXP2)
# ----------------------
# Returns EXP1 if non empty, otherwise EXP2.
#
# This macro is called on hot paths, so inline the contents of m4_ifval,
# for one less round of expansion.
m4_define([m4_default],
[m4_if([$1], [], [$2], [$1])])


# m4_defn(NAME)
# -------------
# Like the original, except don't tolerate popping something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
m4_define([m4_defn],
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([defn], [$1])])


# _m4_dumpdefs_up(NAME)
# ---------------------
m4_define([_m4_dumpdefs_up],
[m4_ifdef([$1],
	  [m4_pushdef([_m4_dumpdefs], m4_defn([$1]))dnl
m4_dumpdef([$1])dnl
m4_popdef([$1])dnl
_m4_dumpdefs_up([$1])])])


# _m4_dumpdefs_down(NAME)
# -----------------------
m4_define([_m4_dumpdefs_down],
[m4_ifdef([_m4_dumpdefs],
	  [m4_pushdef([$1], m4_defn([_m4_dumpdefs]))dnl
m4_popdef([_m4_dumpdefs])dnl
_m4_dumpdefs_down([$1])])])


# m4_dumpdefs(NAME)
# -----------------
# Similar to `m4_dumpdef(NAME)', but if NAME was m4_pushdef'ed, display its
# value stack (most recent displayed first).
m4_define([m4_dumpdefs],
[_m4_dumpdefs_up([$1])dnl
_m4_dumpdefs_down([$1])])


# m4_popdef(NAME)
# ---------------
# Like the original, except don't tolerate popping something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
m4_define([m4_popdef],
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([popdef], [$1])])


# m4_shiftn(N, ...)
# -----------------
# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
#
# Autoconf does not use this macro, because it is inherently slower than
# calling the common cases of m4_shift2 or m4_shift3 directly.  But it
# might as well be fast for other clients, such as Libtool.  One way to
# do this is to expand $@@ only once in _m4_shiftn (otherwise, for long
# lists, the expansion of m4_if takes twice as much memory as what the
# list itself occupies, only to throw away the unused branch).  The end
# result is strictly equivalent to
#   m4_if([$1], 1, [m4_shift(,m4_shift(m4_shift($@@)))],
#         [_m4_shiftn(m4_decr([$1]), m4_shift(m4_shift($@@)))])
# but with the final `m4_shift(m4_shift($@@)))' shared between the two
# paths.  The first leg uses a no-op m4_shift(,$@@) to balance out the ().
m4_define([m4_shiftn],
[m4_assert(0 < $1 && $1 < $#)_$0($@@)])

m4_define([_m4_shiftn],
[m4_if([$1], 1, [m4_shift(],
       [$0(m4_decr([$1])]), m4_shift(m4_shift($@@)))])

# m4_shift2(...)
# m4_shift3(...)
# -----------------
# Returns ... shifted twice, and three times.  Faster than m4_shiftn.
m4_define([m4_shift2], [m4_shift(m4_shift($@@))])
m4_define([m4_shift3], [m4_shift(m4_shift(m4_shift($@@)))])

# _m4_shift2(...)
# _m4_shift3(...)
# ---------------
# Like m4_shift2 or m4_shift3, except include a leading comma unless shifting
# consumes all arguments.  Why?  Because in recursion, it is nice to
# distinguish between 1 element left and 0 elements left, based on how many
# arguments this shift expands to.
m4_define([_m4_shift2],
[m4_if([$#], [2], [],
       [, m4_shift(m4_shift($@@))])])
m4_define([_m4_shift3],
[m4_if([$#], [3], [],
       [, m4_shift(m4_shift(m4_shift($@@)))])])


# m4_undefine(NAME)
# -----------------
# Like the original, except don't tolerate undefining something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
m4_define([m4_undefine],
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([undefine], [$1])])

# _m4_wrap(PRE, POST)
# -------------------
# Helper macro for m4_wrap and m4_wrap_lifo.  Allows nested calls to
# m4_wrap within wrapped text.
# Skip m4_defn and m4_popdef for speed.
m4_define([_m4_wrap],
[m4_ifdef([$0_text],
	  [m4_define([$0_text], [$1]m4_builtin([defn], [$0_text])[$2])],
	  [m4_builtin([m4wrap], [m4_unquote(m4_builtin([defn],
  [$0_text])m4_builtin([popdef], [$0_text]))])m4_define([$0_text], [$1$2])])])

# m4_wrap(TEXT)
# -------------
# Append TEXT to the list of hooks to be executed at the end of input.
# Whereas the order of the original may be LIFO in the underlying m4,
# this version is always FIFO.
m4_define([m4_wrap],
[_m4_wrap([], [$1[]])])

# m4_wrap_lifo(TEXT)
# ------------------
# Prepend TEXT to the list of hooks to be executed at the end of input.
# Whereas the order of m4_wrap may be FIFO in the underlying m4, this
# version is always LIFO.
m4_define([m4_wrap_lifo],
[_m4_wrap([$1[]])])

## ------------------------- ##
## 7. Quoting manipulation.  ##
## ------------------------- ##


# m4_apply(MACRO, LIST)
# ---------------------
# Invoke MACRO, with arguments provided from the quoted list of
# comma-separated quoted arguments.  If LIST is empty, invoke MACRO
# without arguments.
m4_define([m4_apply],
[m4_if([$2], [], [$1], [$1($2)])[]])


# m4_count(ARGS)
# --------------
# Return a count of how many ARGS are present.
m4_define([m4_count], [$#])


# m4_do(STRING, ...)
# ------------------
# This macro invokes all its arguments (in sequence, of course).  It is
# useful for making your macros more structured and readable by dropping
# unnecessary dnl's and have the macros indented properly.
m4_define([m4_do],
[m4_if([$#], 0, [],
       [$#], 1, [$1],
       [$1[]m4_do(m4_shift($@@))])])


# m4_dquote(ARGS)
# ---------------
# Return ARGS as a quoted list of quoted arguments.
m4_define([m4_dquote],  [[$@@]])


# m4_dquote_elt(ARGS)
# -------------------
# Return ARGS as an unquoted list of double-quoted arguments.
m4_define([m4_dquote_elt],
[m4_if([$#], [0], [],
       [$#], [1], [[[$1]]],
       [[[$1]],$0(m4_shift($@@))])])


# m4_echo(ARGS)
# -------------
# Return the ARGS, with the same level of quoting.  Whitespace after
# unquoted commas are consumed.
m4_define([m4_echo], [$@@])


# m4_expand(ARG)
# --------------
# Return the expansion of ARG as a single string.  Unlike m4_quote($1), this
# correctly preserves whitespace following single-quoted commas that appeared
# within ARG.
#
#   m4_define([active], [ACT, IVE])
#   m4_define([active2], [[ACT, IVE]])
#   m4_quote(active, active2)
#   => ACT,IVE,ACT, IVE
#   m4_expand([active, active2])
#   => ACT, IVE, ACT, IVE
#
# Unfortunately, due to limitations in m4, ARG must expand to something
# with balanced quotes (use quadrigraphs to get around this).  The input
# is not likely to have unbalanced -=<{(/)}>=- quotes, and it is possible
# to have unbalanced (), provided it was specified with proper [] quotes.
#
# Exploit that extra () will group unquoted commas and the following
# whitespace, then convert () to [].  m4_bpatsubst can't handle newlines
# inside $1, and m4_substr strips quoting.  So we (ab)use m4_changequote.
m4_define([m4_expand], [_$0(-=<{($1)}>=-)])
m4_define([_m4_expand],
[m4_changequote([-=<{(], [)}>=-])$1m4_changequote([, ])])


# m4_ignore(ARGS)
# ---------------
# Expands to nothing.  Useful for conditionally ignoring an arbitrary
# number of arguments (see _m4_list_cmp for an example).
m4_define([m4_ignore])


# m4_make_list(ARGS)
# ------------------
# Similar to m4_dquote, this creates a quoted list of quoted ARGS.  This
# version is less efficient than m4_dquote, but separates each argument
# with a comma and newline, rather than just comma, for readability.
# When developing an m4sugar algorithm, you could temporarily use
#   m4_pushdef([m4_dquote],m4_defn([m4_make_list]))
# around your code to make debugging easier.
m4_define([m4_make_list], [m4_join([,
], m4_dquote_elt($@@))])


# m4_noquote(STRING)
# ------------------
# Return the result of ignoring all quotes in STRING and invoking the
# macros it contains.  Amongst other things, this is useful for enabling
# macro invocations inside strings with [] blocks (for instance regexps
# and help-strings).  On the other hand, since all quotes are disabled,
# any macro expanded during this time that relies on nested [] quoting
# will likely crash and burn.  This macro is seldom useful; consider
# m4_unquote or m4_expand instead.
m4_define([m4_noquote],
[m4_changequote([-=<{(],[)}>=-])$1-=<{()}>=-m4_changequote([,])])


# m4_quote(ARGS)
# --------------
# Return ARGS as a single argument.  Any whitespace after unquoted commas
# is stripped.  There is always output, even when there were no arguments.
#
# It is important to realize the difference between `m4_quote(exp)' and
# `[exp]': in the first case you obtain the quoted *result* of the
# expansion of EXP, while in the latter you just obtain the string
# `exp'.
m4_define([m4_quote],  [[$*]])


# _m4_quote(ARGS)
# ---------------
# Like m4_quote, except that when there are no arguments, there is no
# output.  For conditional scenarios (such as passing _m4_quote as the
# macro name in m4_map), this feature can be used to distinguish between
# one argument of the empty string vs. no arguments.  However, in the
# normal case with arguments present, this is less efficient than m4_quote.
m4_define([_m4_quote],
[m4_if([$#], [0], [], [[$*]])])


# m4_unquote(ARGS)
# ----------------
# Remove one layer of quotes from each ARG, performing one level of
# expansion.  For one argument, m4_unquote([arg]) is more efficient than
# m4_do([arg]), but for multiple arguments, the difference is that
# m4_unquote separates arguments with commas while m4_do concatenates.
m4_define([m4_unquote], [$*])


## -------------------------- ##
## 8. Implementing m4 loops.  ##
## -------------------------- ##


# m4_for(VARIABLE, FIRST, LAST, [STEP = +/-1], EXPRESSION)
# --------------------------------------------------------
# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO with
# increments of STEP.
# Both limits are included, and bounds are checked for consistency.
# The algorithm is robust to indirect VARIABLE names, and uses m4_builtin
# to avoid some of the m4_defn overhead.
m4_define([m4_for],
[m4_pushdef([$1], m4_eval([$2]))dnl
m4_cond([m4_eval(([$3]) > m4_builtin([defn], [$1]))], 1,
[m4_pushdef([_m4_step], m4_eval(m4_default([$4], 1)))dnl
m4_assert(_m4_step > 0)dnl
_m4_for([$1], m4_eval((([$3]) - m4_builtin([defn], [$1]))
		      / _m4_step * _m4_step + m4_builtin([defn], [$1])),
	_m4_step, [$5])],
	[m4_eval(([$3]) < m4_builtin([defn], [$1]))], 1,
[m4_pushdef([_m4_step], m4_eval(m4_default([$4], -1)))dnl
m4_assert(_m4_step < 0)dnl
_m4_for([$1], m4_eval((m4_builtin([defn], [$1]) - ([$3]))
		      / -(_m4_step) * _m4_step + m4_builtin([defn], [$1])),
	_m4_step, [$5])],
	[m4_pushdef([_m4_step])dnl
$5])[]dnl
m4_popdef([_m4_step])dnl
m4_popdef([$1])])


# _m4_for(VARIABLE, LAST, STEP, EXPRESSION)
# -----------------------------------------
# Core of the loop, no consistency checks, all arguments are plain numbers.
m4_define([_m4_for],
[$4[]dnl
m4_if(m4_defn([$1]), [$2], [],
      [m4_define([$1], m4_eval(m4_defn([$1])+[$3]))$0($@@)])])


# Implementing `foreach' loops in m4 is much more tricky than it may
# seem.  For example, the old M4 1.4.4 manual had an incorrect example,
# which looked like this (when translated to m4sugar):
#
# | # foreach(VAR, (LIST), STMT)
# | m4_define([foreach],
# |   [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
# | m4_define([_arg1], [$1])
# | m4_define([_foreach],
# |   [m4_if([$2], [()], ,
# |     [m4_define([$1], _arg1$2)$3[]_foreach([$1], (m4_shift$2), [$3])])])
#
# But then if you run
#
# | m4_define(a, 1)
# | m4_define(b, 2)
# | m4_define(c, 3)
# | foreach([f], [([a], [(b], [c)])], [echo f
# | ])
#
# it gives
#
#  => echo 1
#  => echo (2,3)
#
# which is not what is expected.
#
# Of course the problem is that many quotes are missing.  So you add
# plenty of quotes at random places, until you reach the expected
# result.  Alternatively, if you are a quoting wizard, you directly
# reach the following implementation (but if you really did, then
# apply to the maintenance of m4sugar!).
#
# | # foreach(VAR, (LIST), STMT)
# | m4_define([foreach], [m4_pushdef([$1])_foreach($@@)m4_popdef([$1])])
# | m4_define([_arg1], [[$1]])
# | m4_define([_foreach],
# |  [m4_if($2, [()], ,
# |    [m4_define([$1], [_arg1$2])$3[]_foreach([$1], [(m4_shift$2)], [$3])])])
#
# which this time answers
#
#  => echo a
#  => echo (b
#  => echo c)
#
# Bingo!
#
# Well, not quite.
#
# With a better look, you realize that the parens are more a pain than
# a help: since anyway you need to quote properly the list, you end up
# with always using an outermost pair of parens and an outermost pair
# of quotes.  Rejecting the parens both eases the implementation, and
# simplifies the use:
#
# | # foreach(VAR, (LIST), STMT)
# | m4_define([foreach], [m4_pushdef([$1])_foreach($@@)m4_popdef([$1])])
# | m4_define([_arg1], [$1])
# | m4_define([_foreach],
# |  [m4_if($2, [], ,
# |    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1], [m4_shift($2)], [$3])])])
#
#
# Now, just replace the `$2' with `m4_quote($2)' in the outer `m4_if'
# to improve robustness, and you come up with a nice implementation
# that doesn't require extra parentheses in the user's LIST.
#
# But wait -  now the algorithm is quadratic, because every recursion of
# the algorithm keeps the entire LIST and merely adds another m4_shift to
# the quoted text.  If the user has a lot of elements in LIST, you can
# bring the system to its knees with the memory m4 then requires, or trip
# the m4 --nesting-limit recursion factor.  The only way to avoid
# quadratic growth is ensure m4_shift is expanded prior to the recursion.
# Hence the design below.
#
# The M4 manual now includes a chapter devoted to this issue, with
# the lessons learned from m4sugar.


# m4_foreach(VARIABLE, LIST, EXPRESSION)
# --------------------------------------
#
# Expand EXPRESSION assigning each value of the LIST to VARIABLE.
# LIST should have the form `item_1, item_2, ..., item_n', i.e. the
# whole list must *quoted*.  Quote members too if you don't want them
# to be expanded.
#
# This macro is robust to active symbols:
#      | m4_define(active, [ACT, IVE])
#      | m4_foreach(Var, [active, active], [-Var-])
#     => -ACT--IVE--ACT--IVE-
#
#      | m4_foreach(Var, [[active], [active]], [-Var-])
#     => -ACT, IVE--ACT, IVE-
#
#      | m4_foreach(Var, [[[active]], [[active]]], [-Var-])
#     => -active--active-
#
# This macro is called frequently, so avoid extra expansions such as
# m4_ifval and dnl.  Also, since $2 might be quite large, try to use it
# as little as possible in _m4_foreach; each extra use requires that much
# more memory for expansion.  So, rather than directly compare $2 against
# [] and use m4_car/m4_cdr for recursion, we instead unbox the list (which
# requires swapping the argument order in the helper) and use _m4_shift3
# to detect when recursion is complete.
m4_define([m4_foreach],
[m4_pushdef([$1])_$0([$1], [$3]m4_if([$2], [], [], [, $2]))m4_popdef([$1])])

m4_define([_m4_foreach],
[m4_if([$#], [2], [],
       [m4_define([$1], [$3])$2[]$0([$1], [$2]_m4_shift3($@@))])])


# m4_foreach_w(VARIABLE, LIST, EXPRESSION)
# ----------------------------------------
#
# Like m4_foreach, but the list is whitespace separated.
#
# This macro is robust to active symbols:
#    m4_foreach_w([Var], [ active
#    b	act\
#    ive  ], [-Var-])end
#    => -active--b--active-end
#
m4_define([m4_foreach_w],
[m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])


# m4_map(MACRO, LIST)
# -------------------
# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements
# of LIST.  $1, $2... must in turn be lists, appropriate for m4_apply.
#
# Since LIST may be quite large, we want to minimize how often it appears
# in the expansion.  Rather than use m4_car/m4_cdr iteration, we unbox the
# list, and use _m4_shift2 to detect the end of recursion.
m4_define([m4_map],
[m4_if([$2], [], [],
       [_$0([$1], $2)])])
m4_define([_m4_map],
[m4_if([$#], [1], [],
       [m4_apply([$1], [$2])$0([$1]_m4_shift2($@@))])])


# m4_map_sep(MACRO, SEPARATOR, LIST)
# ----------------------------------
# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1, $2... $N
# are the elements of LIST, and are in turn lists appropriate for m4_apply.
# SEPARATOR is not further expanded.
m4_define([m4_map_sep],
[m4_if([$3], [], [],
       [m4_apply([$1], m4_car($3))m4_map([[$2]$1]_m4_cdr($3))])])


## --------------------------- ##
## 9. More diversion support.  ##
## --------------------------- ##


# _m4_divert(DIVERSION-NAME or NUMBER)
# ------------------------------------
# If DIVERSION-NAME is the name of a diversion, return its number,
# otherwise if it is a NUMBER return it.
m4_define([_m4_divert],
[m4_ifdef([_m4_divert($1)],
	  [m4_indir([_m4_divert($1)])],
	  [$1])])

# KILL is only used to suppress output.
m4_define([_m4_divert(KILL)],           -1)

# The empty diversion name is a synonym for 0.
m4_define([_m4_divert()],                0)


# _m4_divert_n_stack
# ------------------
# Print m4_divert_stack with newline prepended, if it's nonempty.
m4_define([_m4_divert_n_stack],
[m4_ifdef([m4_divert_stack], [
m4_defn([m4_divert_stack])])])


# m4_divert(DIVERSION-NAME)
# -------------------------
# Change the diversion stream to DIVERSION-NAME.
m4_define([m4_divert],
[m4_define([m4_divert_stack], m4_location[: $0: $1]_m4_divert_n_stack)dnl
m4_builtin([divert], _m4_divert([$1]))dnl
])


# m4_divert_push(DIVERSION-NAME)
# ------------------------------
# Change the diversion stream to DIVERSION-NAME, while stacking old values.
m4_define([m4_divert_push],
[m4_pushdef([m4_divert_stack], m4_location[: $0: $1]_m4_divert_n_stack)dnl
m4_pushdef([_m4_divert_diversion], [$1])dnl
m4_builtin([divert], _m4_divert([$1]))dnl
])


# m4_divert_pop([DIVERSION-NAME])
# -------------------------------
# Change the diversion stream to its previous value, unstacking it.
# If specified, verify we left DIVERSION-NAME.
# When we pop the last value from the stack, we divert to -1.
m4_define([m4_divert_pop],
[m4_ifndef([_m4_divert_diversion],
	   [m4_fatal([too many m4_divert_pop])])dnl
m4_if([$1], [], [],
      [$1], m4_defn([_m4_divert_diversion]), [],
      [m4_fatal([$0($1): diversion mismatch: ]_m4_divert_n_stack)])dnl
m4_popdef([m4_divert_stack])dnl
m4_popdef([_m4_divert_diversion])dnl
m4_builtin([divert],
	   m4_ifdef([_m4_divert_diversion],
		    [_m4_divert(m4_defn([_m4_divert_diversion]))],
		    -1))dnl
])


# m4_divert_text(DIVERSION-NAME, CONTENT)
# ---------------------------------------
# Output CONTENT into DIVERSION-NAME (which may be a number actually).
# An end of line is appended for free to CONTENT.
m4_define([m4_divert_text],
[m4_divert_push([$1])dnl
$2
m4_divert_pop([$1])dnl
])


# m4_divert_once(DIVERSION-NAME, CONTENT)
# ---------------------------------------
# Output CONTENT into DIVERSION-NAME once, if not already there.
# An end of line is appended for free to CONTENT.
m4_define([m4_divert_once],
[m4_expand_once([m4_divert_text([$1], [$2])])])


# m4_undivert(DIVERSION-NAME)
# ---------------------------
# Undivert DIVERSION-NAME.  Unlike the M4 version, this only takes a single
# diversion identifier, and should not be used to undivert files.
m4_define([m4_undivert],
[m4_builtin([undivert], _m4_divert([$1]))])


## --------------------------------------------- ##
## 10. Defining macros with bells and whistles.  ##
## --------------------------------------------- ##

# `m4_defun' is basically `m4_define' but it equips the macro with the
# needed machinery for `m4_require'.  A macro must be m4_defun'd if
# either it is m4_require'd, or it m4_require's.
#
# Two things deserve attention and are detailed below:
#  1. Implementation of m4_require
#  2. Keeping track of the expansion stack
#
# 1. Implementation of m4_require
# ===============================
#
# Of course m4_defun AC_PROVIDE's the macro, so that a macro which has
# been expanded is not expanded again when m4_require'd, but the
# difficult part is the proper expansion of macros when they are
# m4_require'd.
#
# The implementation is based on two ideas, (i) using diversions to
# prepare the expansion of the macro and its dependencies (by Franc,ois
# Pinard), and (ii) expand the most recently m4_require'd macros _after_
# the previous macros (by Axel Thimm).
#
#
# The first idea: why use diversions?
# -----------------------------------
#
# When a macro requires another, the other macro is expanded in new
# diversion, GROW.  When the outer macro is fully expanded, we first
# undivert the most nested diversions (GROW - 1...), and finally
# undivert GROW.  To understand why we need several diversions,
# consider the following example:
#
# | m4_defun([TEST1], [Test...REQUIRE([TEST2])1])
# | m4_defun([TEST2], [Test...REQUIRE([TEST3])2])
# | m4_defun([TEST3], [Test...3])
#
# Because m4_require is not required to be first in the outer macros, we
# must keep the expansions of the various levels of m4_require separated.
# Right before executing the epilogue of TEST1, we have:
#
#	   GROW - 2: Test...3
#	   GROW - 1: Test...2
#	   GROW:     Test...1
#	   BODY:
#
# Finally the epilogue of TEST1 undiverts GROW - 2, GROW - 1, and
# GROW into the regular flow, BODY.
#
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:        Test...3; Test...2; Test...1
#
# (The semicolons are here for clarification, but of course are not
# emitted.)  This is what Autoconf 2.0 (I think) to 2.13 (I'm sure)
# implement.
#
#
# The second idea: first required first out
# -----------------------------------------
#
# The natural implementation of the idea above is buggy and produces
# very surprising results in some situations.  Let's consider the
# following example to explain the bug:
#
# | m4_defun([TEST1],  [REQUIRE([TEST2a])REQUIRE([TEST2b])])
# | m4_defun([TEST2a], [])
# | m4_defun([TEST2b], [REQUIRE([TEST3])])
# | m4_defun([TEST3],  [REQUIRE([TEST2a])])
# |
# | AC_INIT
# | TEST1
#
# The dependencies between the macros are:
#
#		 3 --- 2b
#		/        \              is m4_require'd by
#	       /          \       left -------------------- right
#	    2a ------------ 1
#
# If you strictly apply the rules given in the previous section you get:
#
#	   GROW - 2: TEST3
#	   GROW - 1: TEST2a; TEST2b
#	   GROW:     TEST1
#	   BODY:
#
# (TEST2a, although required by TEST3 is not expanded in GROW - 3
# because is has already been expanded before in GROW - 1, so it has
# been AC_PROVIDE'd, so it is not expanded again) so when you undivert
# the stack of diversions, you get:
#
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:        TEST3; TEST2a; TEST2b; TEST1
#
# i.e., TEST2a is expanded after TEST3 although the latter required the
# former.
#
# Starting from 2.50, we use an implementation provided by Axel Thimm.
# The idea is simple: the order in which macros are emitted must be the
# same as the one in which macros are expanded.  (The bug above can
# indeed be described as: a macro has been AC_PROVIDE'd before its
# dependent, but it is emitted after: the lack of correlation between
# emission and expansion order is guilty).
#
# How to do that?  You keep the stack of diversions to elaborate the
# macros, but each time a macro is fully expanded, emit it immediately.
#
# In the example above, when TEST2a is expanded, but it's epilogue is
# not run yet, you have:
#
#	   GROW - 2:
#	   GROW - 1: TEST2a
#	   GROW:     Elaboration of TEST1
#	   BODY:
#
# The epilogue of TEST2a emits it immediately:
#
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a
#
# TEST2b then requires TEST3, so right before the epilogue of TEST3, you
# have:
#
#	   GROW - 2: TEST3
#	   GROW - 1: Elaboration of TEST2b
#	   GROW:     Elaboration of TEST1
#	   BODY:      TEST2a
#
# The epilogue of TEST3 emits it:
#
#	   GROW - 2:
#	   GROW - 1: Elaboration of TEST2b
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a; TEST3
#
# TEST2b is now completely expanded, and emitted:
#
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a; TEST3; TEST2b
#
# and finally, TEST1 is finished and emitted:
#
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:     TEST2a; TEST3; TEST2b: TEST1
#
# The idea is simple, but the implementation is a bit evolved.  If you
# are like me, you will want to see the actual functioning of this
# implementation to be convinced.  The next section gives the full
# details.
#
#
# The Axel Thimm implementation at work
# -------------------------------------
#
# We consider the macros above, and this configure.ac:
#
#	    AC_INIT
#	    TEST1
#
# You should keep the definitions of _m4_defun_pro, _m4_defun_epi, and
# m4_require at hand to follow the steps.
#
# This implements tries not to assume that the current diversion is
# BODY, so as soon as a macro (m4_defun'd) is expanded, we first
# record the current diversion under the name _m4_divert_dump (denoted
# DUMP below for short).  This introduces an important difference with
# the previous versions of Autoconf: you cannot use m4_require if you
# are not inside an m4_defun'd macro, and especially, you cannot
# m4_require directly from the top level.
#
# We have not tried to simulate the old behavior (better yet, we
# diagnose it), because it is too dangerous: a macro m4_require'd from
# the top level is expanded before the body of `configure', i.e., before
# any other test was run.  I let you imagine the result of requiring
# AC_STDC_HEADERS for instance, before AC_PROG_CC was actually run....
#
# After AC_INIT was run, the current diversion is BODY.
# * AC_INIT was run
#   DUMP:                undefined
#   diversion stack:     BODY |-
#
# * TEST1 is expanded
# The prologue of TEST1 sets _m4_divert_dump, which is the diversion
# where the current elaboration will be dumped, to the current
# diversion.  It also m4_divert_push to GROW, where the full
# expansion of TEST1 and its dependencies will be elaborated.
#   DUMP:        BODY
#   BODY:        empty
#   diversions:  GROW, BODY |-
#
# * TEST1 requires TEST2a
# _m4_require_call m4_divert_pushes another temporary diversion,
# GROW - 1, and expands TEST2a in there.
#   DUMP:        BODY
#   BODY:        empty
#   GROW - 1:    TEST2a
#   diversions:  GROW - 1, GROW, BODY |-
# Than the content of the temporary diversion is moved to DUMP and the
# temporary diversion is popped.
#   DUMP:        BODY
#   BODY:        TEST2a
#   diversions:  GROW, BODY |-
#
# * TEST1 requires TEST2b
# Again, _m4_require_call pushes GROW - 1 and heads to expand TEST2b.
#   DUMP:        BODY
#   BODY:        TEST2a
#   diversions:  GROW - 1, GROW, BODY |-
#
# * TEST2b requires TEST3
# _m4_require_call pushes GROW - 2 and expands TEST3 here.
# (TEST3 requires TEST2a, but TEST2a has already been m4_provide'd, so
# nothing happens.)
#   DUMP:        BODY
#   BODY:        TEST2a
#   GROW - 2:    TEST3
#   diversions:  GROW - 2, GROW - 1, GROW, BODY |-
# Than the diversion is appended to DUMP, and popped.
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3
#   diversions:  GROW - 1, GROW, BODY |-
#
# * TEST1 requires TEST2b (contd.)
# The content of TEST2b is expanded...
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3
#   GROW - 1:    TEST2b,
#   diversions:  GROW - 1, GROW, BODY |-
# ... and moved to DUMP.
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3; TEST2b
#   diversions:  GROW, BODY |-
#
# * TEST1 is expanded: epilogue
# TEST1's own content is in GROW...
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3; TEST2b
#   GROW:        TEST1
#   diversions:  BODY |-
# ... and it's epilogue moves it to DUMP and then undefines DUMP.
#   DUMP:       undefined
#   BODY:       TEST2a; TEST3; TEST2b; TEST1
#   diversions: BODY |-
#
#
# 2. Keeping track of the expansion stack
# =======================================
#
# When M4 expansion goes wrong it is often extremely hard to find the
# path amongst macros that drove to the failure.  What is needed is
# the stack of macro `calls'. One could imagine that GNU M4 would
# maintain a stack of macro expansions, unfortunately it doesn't, so
# we do it by hand.  This is of course extremely costly, but the help
# this stack provides is worth it.  Nevertheless to limit the
# performance penalty this is implemented only for m4_defun'd macros,
# not for define'd macros.
#
# The scheme is simplistic: each time we enter an m4_defun'd macros,
# we prepend its name in m4_expansion_stack, and when we exit the
# macro, we remove it (thanks to pushdef/popdef).
#
# In addition, we want to detect circular m4_require dependencies.
# Each time we expand a macro FOO we define _m4_expanding(FOO); and
# m4_require(BAR) simply checks whether _m4_expanding(BAR) is defined.


# m4_expansion_stack_push(TEXT)
# -----------------------------
# Use m4_builtin to avoid m4_defn overhead.
m4_define([m4_expansion_stack_push],
[m4_pushdef([m4_expansion_stack],
	    [$1]m4_ifdef([m4_expansion_stack], [
m4_builtin([defn], [m4_expansion_stack])]))])


# m4_expansion_stack_pop
# ----------------------
m4_define([m4_expansion_stack_pop],
[m4_popdef([m4_expansion_stack])])


# m4_expansion_stack_dump
# -----------------------
# Dump the expansion stack.
m4_define([m4_expansion_stack_dump],
[m4_ifdef([m4_expansion_stack],
	  [m4_errprintn(m4_defn([m4_expansion_stack]))])dnl
m4_errprintn(m4_location[: the top level])])


# _m4_divert(GROW)
# ----------------
# This diversion is used by the m4_defun/m4_require machinery.  It is
# important to keep room before GROW because for each nested
# AC_REQUIRE we use an additional diversion (i.e., two m4_require's
# will use GROW - 2.  More than 3 levels has never seemed to be
# needed.)
#
# ...
# - GROW - 2
#   m4_require'd code, 2 level deep
# - GROW - 1
#   m4_require'd code, 1 level deep
# - GROW
#   m4_defun'd macros are elaborated here.

m4_define([_m4_divert(GROW)],       10000)


# _m4_defun_pro(MACRO-NAME)
# -------------------------
# The prologue for Autoconf macros.
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and m4_defn overhead.
m4_define([_m4_defun_pro],
m4_do([[m4_ifdef([m4_expansion_stack], [], [_m4_defun_pro_outer[]])]],
      [[m4_expansion_stack_push(m4_builtin([defn],
	  [m4_location($1)])[: $1 is expanded from...])]],
      [[m4_pushdef([_m4_expanding($1)])]]))

m4_define([_m4_defun_pro_outer],
[m4_copy([_m4_divert_diversion], [_m4_divert_dump])m4_divert_push([GROW])])

# _m4_defun_epi(MACRO-NAME)
# -------------------------
# The Epilogue for Autoconf macros.  MACRO-NAME only helps tracing
# the PRO/EPI pairs.
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and m4_popdef overhead.
m4_define([_m4_defun_epi],
m4_do([[m4_builtin([popdef], [_m4_expanding($1)])]],
      [[m4_expansion_stack_pop()]],
      [[m4_ifdef([m4_expansion_stack], [], [_m4_defun_epi_outer[]])]],
      [[m4_provide([$1])]]))

m4_define([_m4_defun_epi_outer],
m4_do([[m4_builtin([undefine], [_m4_divert_dump])]],
      [[m4_divert_pop([GROW])]],
      [[m4_undivert([GROW])]]))


# m4_defun(NAME, EXPANSION)
# -------------------------
# Define a macro which automatically provides itself.  Add machinery
# so the macro automatically switches expansion to the diversion
# stack if it is not already using it.  In this case, once finished,
# it will bring back all the code accumulated in the diversion stack.
# This, combined with m4_require, achieves the topological ordering of
# macros.  We don't use this macro to define some frequently called
# macros that are not involved in ordering constraints, to save m4
# processing.
m4_define([m4_defun],
[m4_define([m4_location($1)], m4_location)dnl
m4_define([$1],
	  [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])


# m4_defun_once(NAME, EXPANSION)
# ------------------------------
# As m4_defun, but issues the EXPANSION only once, and warns if used
# several times.
m4_define([m4_defun_once],
[m4_define([m4_location($1)], m4_location)dnl
m4_define([$1],
	  [m4_provide_if([$1],
			 [m4_warn([syntax], [$1 invoked multiple times])],
			 [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])])


# m4_pattern_forbid(ERE, [WHY])
# -----------------------------
# Declare that no token matching the forbidden extended regular
# expression ERE should be seen in the output unless...
m4_define([m4_pattern_forbid],
[m4_file_append(m4_defn([m4_tmpdir])/forbidden.rx, [$1])])


# m4_pattern_allow(ERE)
# ---------------------
# ... that token also matches the allowed extended regular expression ERE.
m4_define([m4_pattern_allow],
[m4_file_append(m4_defn([m4_tmpdir])/allowed.rx, [$1])])


## --------------------------------- ##
## 11. Dependencies between macros.  ##
## --------------------------------- ##


# m4_before(THIS-MACRO-NAME, CALLED-MACRO-NAME)
# ---------------------------------------------
# Issue a warning if CALLED-MACRO-NAME was called before THIS-MACRO-NAME.
m4_define([m4_before],
[m4_provide_if([$2],
	       [m4_warn([syntax], [$2 was called before $1])])])


# m4_require(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
# -----------------------------------------------------------
# If NAME-TO-CHECK has never been expanded (actually, if it is not
# m4_provide'd), expand BODY-TO-EXPAND *before* the current macro
# expansion.  Once expanded, emit it in _m4_divert_dump.  Keep track
# of the m4_require chain in m4_expansion_stack.
#
# The normal cases are:
#
# - NAME-TO-CHECK == BODY-TO-EXPAND
#   Which you can use for regular macros with or without arguments, e.g.,
#     m4_require([AC_PROG_CC], [AC_PROG_CC])
#     m4_require([AC_CHECK_HEADERS(limits.h)], [AC_CHECK_HEADERS(limits.h)])
#   which is just the same as
#     m4_require([AC_PROG_CC])
#     m4_require([AC_CHECK_HEADERS(limits.h)])
#
# - BODY-TO-EXPAND == m4_indir([NAME-TO-CHECK])
#   In the case of macros with irregular names.  For instance:
#     m4_require([AC_LANG_COMPILER(C)], [indir([AC_LANG_COMPILER(C)])])
#   which means `if the macro named `AC_LANG_COMPILER(C)' (the parens are
#   part of the name, it is not an argument) has not been run, then
#   call it.'
#   Had you used
#     m4_require([AC_LANG_COMPILER(C)], [AC_LANG_COMPILER(C)])
#   then m4_require would have tried to expand `AC_LANG_COMPILER(C)', i.e.,
#   call the macro `AC_LANG_COMPILER' with `C' as argument.
#
#   You could argue that `AC_LANG_COMPILER', when it receives an argument
#   such as `C' should dispatch the call to `AC_LANG_COMPILER(C)'.  But this
#   `extension' prevents `AC_LANG_COMPILER' from having actual arguments that
#   it passes to `AC_LANG_COMPILER(C)'.
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and other overhead on the common path.
m4_define([m4_require],
m4_do([[m4_ifdef([_m4_expanding($1)],
		 [m4_fatal([$0: circular dependency of $1])])]],
      [[m4_ifdef([_m4_divert_dump], [],
		 [m4_fatal([$0($1): cannot be used outside of an ]dnl
m4_bmatch([$0], [^AC_], [[AC_DEFUN]], [[m4_defun]])['d macro])])]],
      [[m4_provide_if([$1],
		      [],
		      [_m4_require_call([$1], [$2])])]]))


# _m4_require_call(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
# -----------------------------------------------------------------
# If m4_require decides to expand the body, it calls this macro.
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and other overhead on the common path.
m4_define([_m4_require_call],
m4_do([[m4_define([_m4_divert_grow], m4_decr(_m4_divert_grow))]],
      [[m4_divert_push(_m4_divert_grow)]],
      [[m4_default([$2], [$1])
m4_provide_if([$1],
	      [],
	      [m4_warn([syntax],
		       [$1 is m4_require'd but not m4_defun'd])])]],
      [[m4_divert(m4_builtin([defn], [_m4_divert_dump]))]],
      [[m4_undivert(_m4_divert_grow)]],
      [[m4_divert_pop(_m4_divert_grow)]],
      [[m4_define([_m4_divert_grow], m4_incr(_m4_divert_grow))]]))


# _m4_divert_grow
# ---------------
# The counter for _m4_require_call.
m4_define([_m4_divert_grow], _m4_divert([GROW]))


# m4_expand_once(TEXT, [WITNESS = TEXT])
# --------------------------------------
# If TEXT has never been expanded, expand it *here*.  Use WITNESS as
# as a memory that TEXT has already been expanded.
m4_define([m4_expand_once],
[m4_provide_if(m4_ifval([$2], [[$2]], [[$1]]),
	       [],
	       [m4_provide(m4_ifval([$2], [[$2]], [[$1]]))[]$1])])


# m4_provide(MACRO-NAME)
# ----------------------
m4_define([m4_provide],
[m4_define([m4_provide($1)])])


# m4_provide_if(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
# -------------------------------------------------------
# If MACRO-NAME is provided do IF-PROVIDED, else IF-NOT-PROVIDED.
# The purpose of this macro is to provide the user with a means to
# check macros which are provided without letting her know how the
# information is coded.
m4_define([m4_provide_if],
[m4_ifdef([m4_provide($1)],
	  [$2], [$3])])
m4_copy([m4_provide_if], [m4_provide_ifelse])


## --------------------- ##
## 12. Text processing.  ##
## --------------------- ##


# m4_cr_letters
# m4_cr_LETTERS
# m4_cr_Letters
# -------------
m4_define([m4_cr_letters], [abcdefghijklmnopqrstuvwxyz])
m4_define([m4_cr_LETTERS], [ABCDEFGHIJKLMNOPQRSTUVWXYZ])
m4_define([m4_cr_Letters],
m4_defn([m4_cr_letters])dnl
m4_defn([m4_cr_LETTERS])dnl
)


# m4_cr_digits
# ------------
m4_define([m4_cr_digits], [0123456789])


# m4_cr_alnum
# -----------
m4_define([m4_cr_alnum],
m4_defn([m4_cr_Letters])dnl
m4_defn([m4_cr_digits])dnl
)


# m4_cr_symbols1
# m4_cr_symbols2
# -------------------------------
m4_define([m4_cr_symbols1],
m4_defn([m4_cr_Letters])dnl
_)

m4_define([m4_cr_symbols2],
m4_defn([m4_cr_symbols1])dnl
m4_defn([m4_cr_digits])dnl
)


# m4_newline
# ----------
# Expands to a newline.  Exists for formatting reasons.
m4_define([m4_newline], [
])


# m4_re_escape(STRING)
# --------------------
# Escape RE active characters in STRING.
m4_define([m4_re_escape],
[m4_bpatsubst([$1],
	      [[][*+.?\^$]], [\\\&])])


# m4_re_string
# ------------
# Regexp for `[a-zA-Z_0-9]*'
# m4_dquote provides literal [] for the character class.
m4_define([m4_re_string],
m4_dquote(m4_defn([m4_cr_symbols2]))dnl
[*]dnl
)


# m4_re_word
# ----------
# Regexp for `[a-zA-Z_][a-zA-Z_0-9]*'
m4_define([m4_re_word],
m4_dquote(m4_defn([m4_cr_symbols1]))dnl
m4_defn([m4_re_string])dnl
)

# m4_tolower(STRING)
# m4_toupper(STRING)
# ------------------
# These macros convert STRING to lowercase or uppercase.
#
# Rather than expand the m4_defn each time, we inline them up front.
m4_define([m4_tolower],
[m4_translit([$1],
             [ABCDEFGHIJKLMNOPQRSTUVWXYZ],
             [abcdefghijklmnopqrstuvwxyz])])

m4_define([m4_toupper],
[m4_translit([$1],
             [abcdefghijklmnopqrstuvwxyz],
             [ABCDEFGHIJKLMNOPQRSTUVWXYZ])])


# m4_split(STRING, [REGEXP])
# --------------------------
#
# Split STRING into an m4 list of quoted elements.  The elements are
# quoted with [ and ].  Beginning spaces and end spaces *are kept*.
# Use m4_strip to remove them.
#
# REGEXP specifies where to split.  Default is [\t ]+.
#
# If STRING is empty, the result is an empty list.
#
# Pay attention to the m4_changequotes.  When m4 reads the definition of
# m4_split, it still has quotes set to [ and ].  Luckily, these are matched
# in the macro body, so the definition is stored correctly.  Use the same
# alternate quotes as m4_noquote; it must be unlikely to appear in $1.
#
# Also, notice that $1 is quoted twice, since we want the result to
# be quoted.  Then you should understand that the argument of
# patsubst is -=<{(STRING)}>=- (i.e., with additional -=<{( and )}>=-).
#
# This macro is safe on active symbols, i.e.:
#   m4_define(active, ACTIVE)
#   m4_split([active active ])end
#   => [active], [active], []end
#
# Optimize on regex of ` ' (space), since m4_foreach_w already guarantees
# that the list contains single space separators, and a common case is
# splitting a single-element list.  This macro is called frequently,
# so avoid unnecessary dnl inside the definition.
m4_define([m4_split],
[m4_if([$1], [], [],
       [$2], [ ], [m4_if(m4_index([$1], [ ]), [-1], [[[$1]]], [_$0($@@)])],
       [$2], [], [_$0([$1], [[	 ]+])],
       [_$0($@@)])])

m4_define([_m4_split],
[m4_changequote([-=<{(],[)}>=-])]dnl
[[m4_bpatsubst(-=<{(-=<{($1)}>=-)}>=-, -=<{($2)}>=-,
	       -=<{(], [)}>=-)]m4_changequote([, ])])



# m4_flatten(STRING)
# ------------------
# If STRING contains end of lines, replace them with spaces.  If there
# are backslashed end of lines, remove them.  This macro is safe with
# active symbols.
#    m4_define(active, ACTIVE)
#    m4_flatten([active
#    act\
#    ive])end
#    => active activeend
#
# In m4, m4_bpatsubst is expensive, so first check for a newline.
m4_define([m4_flatten],
[m4_if(m4_index([$1], [
]), [-1], [[$1]],
       [m4_translit(m4_bpatsubst([[[$1]]], [\\
]), [
], [ ])])])


# m4_strip(STRING)
# ----------------
# Expands into STRING with tabs and spaces singled out into a single
# space, and removing leading and trailing spaces.
#
# This macro is robust to active symbols.
#    m4_define(active, ACTIVE)
#    m4_strip([  active <tab> <tab>active ])end
#    => active activeend
#
# First, notice that we guarantee trailing space.  Why?  Because regular
# expressions are greedy, and `.* ?' would always group the space into the
# .* portion.  The algorithm is simpler by avoiding `?' at the end.  The
# algorithm correctly strips everything if STRING is just ` '.
#
# Then notice the second pattern: it is in charge of removing the
# leading/trailing spaces.  Why not just `[^ ]'?  Because they are
# applied to over-quoted strings, i.e. more or less [STRING], due
# to the limitations of m4_bpatsubsts.  So the leading space in STRING
# is the *second* character; equally for the trailing space.
m4_define([m4_strip],
[m4_bpatsubsts([$1 ],
	       [[	 ]+], [ ],
	       [^. ?\(.*\) .$], [[[\1]]])])


# m4_normalize(STRING)
# --------------------
# Apply m4_flatten and m4_strip to STRING.
#
# The argument is quoted, so that the macro is robust to active symbols:
#
#    m4_define(active, ACTIVE)
#    m4_normalize([  act\
#    ive
#    active ])end
#    => active activeend

m4_define([m4_normalize],
[m4_strip(m4_flatten([$1]))])



# m4_join(SEP, ARG1, ARG2...)
# ---------------------------
# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
# is the empty string.  No expansion is performed on SEP or ARGs.
#
# Since the number of arguments to join can be arbitrarily long, we
# want to avoid having more than one $@@ in the macro definition;
# otherwise, the expansion would require twice the memory of the already
# long list.  Hence, m4_join merely looks for the first non-empty element,
# and outputs just that element; while _m4_join looks for all non-empty
# elements, and outputs them following a separator.  The final trick to
# note is that we decide between recursing with $0 or _$0 based on the
# nested m4_if ending with `_'.
m4_define([m4_join],
[m4_if([$#], [1], [],
       [$#], [2], [[$2]],
       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift2($@@))])])
m4_define([_m4_join],
[m4_if([$#$2], [2], [],
       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift2($@@))])])


# m4_combine([SEPARATOR], PREFIX-LIST, [INFIX], SUFFIX...)
# --------------------------------------------------------
# Produce the pairwise combination of every element in the quoted,
# comma-separated PREFIX-LIST with every element from the SUFFIX arguments.
# Each pair is joined with INFIX, and pairs are separated by SEPARATOR.
# No expansion occurs on SEPARATOR, INFIX, or elements of either list.
#
# For example:
#   m4_combine([, ], [[a], [b], [c]], [-], [1], [2], [3])
#   => a-1, a-2, a-3, b-1, b-2, b-3, c-1, c-2, c-3
#
# In order to have the correct number of SEPARATORs, we use a temporary
# variable that redefines itself after the first use.  We use m4_builtin
# to avoid m4_defn overhead, but must use defn rather than overquoting
# in case PREFIX or SUFFIX contains $1.  Likewise, we compute the m4_shift3
# only once, rather than in each iteration of the outer m4_foreach.
m4_define([m4_combine],
[m4_if(m4_eval([$# > 3]), [1],
       [m4_pushdef([m4_Separator], [m4_define([m4_Separator],
				    m4_builtin([defn], [m4_echo]))])]]dnl
[[m4_foreach([m4_Prefix], [$2],
	     [m4_foreach([m4_Suffix], ]m4_dquote(m4_dquote(m4_shift3($@@)))[,
			 [m4_Separator([$1])[]m4_builtin([defn],
				      [m4_Prefix])[$3]m4_builtin([defn],
						      [m4_Suffix])])])]]dnl
[[m4_builtin([popdef], [m4_Separator])])])


# m4_append(MACRO-NAME, STRING, [SEPARATOR])
# ------------------------------------------
# Redefine MACRO-NAME to hold its former content plus `SEPARATOR`'STRING'
# at the end.  It is valid to use this macro with MACRO-NAME undefined,
# in which case no SEPARATOR is added.  Be aware that the criterion is
# `not being defined', and not `not being empty'.
#
# Note that neither STRING nor SEPARATOR are expanded here; rather, when
# you expand MACRO-NAME, they will be expanded at that point in time.
#
# This macro is robust to active symbols.  It can be used to grow
# strings.
#
#    | m4_define(active, ACTIVE)dnl
#    | m4_append([sentence], [This is an])dnl
#    | m4_append([sentence], [ active ])dnl
#    | m4_append([sentence], [symbol.])dnl
#    | sentence
#    | m4_undefine([active])dnl
#    | sentence
#    => This is an ACTIVE symbol.
#    => This is an active symbol.
#
# It can be used to define hooks.
#
#    | m4_define(active, ACTIVE)dnl
#    | m4_append([hooks], [m4_define([act1], [act2])])dnl
#    | m4_append([hooks], [m4_define([act2], [active])])dnl
#    | m4_undefine([active])dnl
#    | act1
#    | hooks
#    | act1
#    => act1
#    =>
#    => active
#
# It can also be used to create lists, although this particular usage was
# broken prior to autoconf 2.62.
#    | m4_append([list], [one], [, ])dnl
#    | m4_append([list], [two], [, ])dnl
#    | m4_append([list], [three], [, ])dnl
#    | list
#    | m4_dquote(list)
#    => one, two, three
#    => [one],[two],[three]
#
# Use m4_builtin to avoid overhead of m4_defn.
m4_define([m4_append],
[m4_define([$1],
	   m4_ifdef([$1], [m4_builtin([defn], [$1])[$3]])[$2])])


# m4_list_append(MACRO-NAME, STRING)
# ----------------------------------
# Same as `m4_append', but each element is separated by `, '.
m4_define([m4_list_append],
[m4_define([$1],
           m4_ifdef([$1], [m4_defn([$1]), ])[$2])])


# m4_foreach_quoted(VARIABLE, LIST, EXPRESSION)
# ---------------------------------------------
# FIXME: This macro should not exists.  Currently it's used only in
# m4_wrap, which needs to be rewritten.  But it's godam hard.
m4_define([m4_foreach_quoted],
[m4_pushdef([$1], [])_m4_foreach_quoted($@@)m4_popdef([$1])])

# Low level macros used to define m4_foreach.
m4_define([m4_car_quoted], [[$1]])
m4_define([_m4_foreach_quoted],
[m4_if($2, [()], ,
       [m4_define([$1], [m4_car_quoted$2])$3[]_m4_foreach_quoted([$1],
                                                               [(m4_shift$2)],
                                                               [$3])])])


# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR], [IF-UNIQ], [IF-DUP])
# --------------------------------------------------------------------
# Like `m4_append', but append only if not yet present.  Additionally,
# expand IF-UNIQ if STRING was appended, or IF-DUP if STRING was already
# present.  Also, warn if SEPARATOR is not empty and occurs within STRING,
# as the algorithm no longer guarantees uniqueness.
m4_define([m4_append_uniq],
[m4_ifval([$3], [m4_if(m4_index([$2], [$3]), [-1], [],
		       [m4_warn([syntax],
				[$0: `$2' contains `$3'])])])_$0($@@)])
m4_define([_m4_append_uniq],
[m4_ifdef([$1],
	  [m4_if(m4_index([$3]m4_builtin([defn], [$1])[$3], [$3$2$3]), [-1],
		 [m4_append([$1], [$2], [$3])$4], [$5])],
	  [m4_append([$1], [$2], [$3])$4])])

# m4_append_uniq_w(MACRO-NAME, STRINGS)
# -------------------------------------
# For each of the words in the whitespace separated list STRINGS, append
# only the unique strings to the definition of MACRO-NAME.
#
# Avoid overhead of m4_defn by using m4_builtin.
m4_define([m4_append_uniq_w],
[m4_foreach_w([m4_Word], [$2],
	      [_m4_append_uniq([$1], m4_builtin([defn], [m4_Word]), [ ])])])


# m4_text_wrap(STRING, [PREFIX], [FIRST-PREFIX], [WIDTH])
# -------------------------------------------------------
# Expands into STRING wrapped to hold in WIDTH columns (default = 79).
# If PREFIX is given, each line is prefixed with it.  If FIRST-PREFIX is
# specified, then the first line is prefixed with it.  As a special case,
# if the length of FIRST-PREFIX is greater than that of PREFIX, then
# FIRST-PREFIX will be left alone on the first line.
#
# No expansion occurs on the contents STRING, PREFIX, or FIRST-PREFIX,
# although quadrigraphs are correctly recognized.
#
# Typical outputs are:
#
# m4_text_wrap([Short string */], [   ], [/* ], 20)
#  => /* Short string */
#
# m4_text_wrap([Much longer string */], [   ], [/* ], 20)
#  => /* Much longer
#  =>    string */
#
# m4_text_wrap([Short doc.], [          ], [  --short ], 30)
#  =>   --short Short doc.
#
# m4_text_wrap([Short doc.], [          ], [  --too-wide ], 30)
#  =>   --too-wide
#  =>           Short doc.
#
# m4_text_wrap([Super long documentation.], [          ], [  --too-wide ], 30)
#  =>   --too-wide
#  =>      Super long
#  =>      documentation.
#
# FIXME: there is no checking of a longer PREFIX than WIDTH, but do
# we really want to bother with people trying each single corner
# of a software?
#
# This macro does not leave a trailing space behind the last word of a line,
# which complicates it a bit.  The algorithm is otherwise stupid and simple:
# all the words are preceded by m4_Separator which is defined to empty for
# the first word, and then ` ' (single space) for all the others.
#
# The algorithm uses a helper that uses $2 through $4 directly, rather than
# using local variables, to avoid m4_defn overhead, or expansion swallowing
# any $.  It also bypasses m4_popdef overhead with m4_builtin since no user
# macro expansion occurs in the meantime.  Also, the definition is written
# with m4_do, to avoid time wasted on dnl during expansion (since this is
# already a time-consuming macro).
m4_define([m4_text_wrap],
[_$0([$1], [$2], m4_if([$3], [], [[$2]], [[$3]]),
     m4_if([$4], [], [79], [[$4]]))])
m4_define([_m4_text_wrap],
m4_do(dnl set up local variables, to avoid repeated calculations
[[m4_pushdef([m4_Indent], m4_qlen([$2]))]],
[[m4_pushdef([m4_Cursor], m4_qlen([$3]))]],
[[m4_pushdef([m4_Separator], [m4_define([m4_Separator], [ ])])]],
dnl expand the first prefix, then check its length vs. regular prefix
dnl same length: nothing special
dnl prefix1 longer: output on line by itself, and reset cursor
dnl prefix1 shorter: pad to length of prefix, and reset cursor
[[[$3]m4_cond([m4_Cursor], m4_Indent, [],
	      [m4_eval(m4_Cursor > m4_Indent)], [1], [
[$2]m4_define([m4_Cursor], m4_Indent)],
	      [m4_format([%*s], m4_max([0],
  m4_eval(m4_Indent - m4_Cursor)), [])m4_define([m4_Cursor], m4_Indent)])]],
dnl now, for each word, compute the curser after the word is output, then
dnl check if the cursor would exceed the wrap column
dnl if so, reset cursor, and insert newline and prefix
dnl if not, insert the separator (usually a space)
dnl either way, insert the word
[[m4_foreach_w([m4_Word], [$1],
  [m4_define([m4_Cursor],
	     m4_eval(m4_Cursor + m4_qlen(m4_builtin([defn], [m4_Word]))
		     + 1))m4_if(m4_eval(m4_Cursor > ([$4])),
      [1], [m4_define([m4_Cursor],
		      m4_eval(m4_Indent
			      + m4_qlen(m4_builtin([defn], [m4_Word])) + 1))
[$2]],
      [m4_Separator[]])m4_builtin([defn], [m4_Word])])]],
dnl finally, clean up the local variabls
[[m4_builtin([popdef], [m4_Separator])]],
[[m4_builtin([popdef], [m4_Cursor])]],
[[m4_builtin([popdef], [m4_Indent])]]))


# m4_text_box(MESSAGE, [FRAME-CHARACTER = `-'])
# ---------------------------------------------
# Turn MESSAGE into:
#  ## ------- ##
#  ## MESSAGE ##
#  ## ------- ##
# using FRAME-CHARACTER in the border.
m4_define([m4_text_box],
[m4_pushdef([m4_Border],
	    m4_translit(m4_format([%*s], m4_qlen(m4_expand([$1])), []),
			[ ], m4_if([$2], [], [[-]], [[$2]])))dnl
@@%:@@@@%:@@ m4_Border @@%:@@@@%:@@
@@%:@@@@%:@@ $1 @@%:@@@@%:@@
@@%:@@@@%:@@ m4_Border @@%:@@@@%:@@dnl
m4_builtin([popdef], [m4_Border])dnl
])


# m4_qlen(STRING)
# ---------------
# Expands to the length of STRING after autom4te converts all quadrigraphs.
#
# Avoid bpatsubsts for the common case of no quadrigraphs.
m4_define([m4_qlen],
[m4_if(m4_index([$1], [@@]), [-1], [m4_len([$1])],
       [m4_len(m4_bpatsubst([[$1]],
			    [@@\(\(<:\|:>\|S|\|%:\|\{:\|:\}\)\(@@\)\|&t@@\)],
			    [\3]))])])


# m4_qdelta(STRING)
# -----------------
# Expands to the net change in the length of STRING from autom4te converting the
# quadrigraphs in STRING.  This number is always negative or zero.
m4_define([m4_qdelta],
[m4_eval(m4_qlen([$1]) - m4_len([$1]))])



## ----------------------- ##
## 13. Number processing.  ##
## ----------------------- ##

# m4_cmp(A, B)
# ------------
# Compare two integer expressions.
# A < B -> -1
# A = B ->  0
# A > B ->  1
m4_define([m4_cmp],
[m4_eval((([$1]) > ([$2])) - (([$1]) < ([$2])))])


# m4_list_cmp(A, B)
# -----------------
#
# Compare the two lists of integer expressions A and B.  For instance:
#   m4_list_cmp([1, 0],     [1])    ->  0
#   m4_list_cmp([1, 0],     [1, 0]) ->  0
#   m4_list_cmp([1, 2],     [1, 0]) ->  1
#   m4_list_cmp([1, 2, 3],  [1, 2]) ->  1
#   m4_list_cmp([1, 2, -3], [1, 2]) -> -1
#   m4_list_cmp([1, 0],     [1, 2]) -> -1
#   m4_list_cmp([1],        [1, 2]) -> -1
#   m4_define([xa], [oops])dnl
#   m4_list_cmp([[0xa]],    [5+5])  -> 0
#
# Rather than face the overhead of m4_case, we use a helper function whose
# expansion includes the name of the macro to invoke on the tail, either
# m4_ignore or m4_unquote.  This is particularly useful when comparing
# long lists, since less text is being expanded for deciding when to end
# recursion.
m4_define([m4_list_cmp],
[m4_if([$1$2], [], 0,
       [$1], [], [$0(0, [$2])],
       [$2], [], [$0([$1], 0)],
       [$1], [$2], 0,
       [_$0(m4_cmp(m4_car($1), m4_car($2)))([$0(m4_cdr($1), m4_cdr($2))])])])
m4_define([_m4_list_cmp],
[m4_if([$1], 0, [m4_unquote], [$1m4_ignore])])

# m4_max(EXPR, ...)
# m4_min(EXPR, ...)
# -----------------
# Return the decimal value of the maximum (or minimum) in a series of
# integer expressions.
#
# M4 1.4.x doesn't provide ?:.  Hence this huge m4_eval.  Avoid m4_eval
# if both arguments are identical, but be aware of m4_max(0xa, 10) (hence
# the use of <=, not just <, in the second multiply).
m4_define([m4_max],
[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
       [$#], [1], [m4_eval([$1])],
       [$#$1], [2$2], [m4_eval([$1])],
       [$#], [2],
       [m4_eval((([$1]) > ([$2])) * ([$1]) + (([$1]) <= ([$2])) * ([$2]))],
       [$0($0([$1], [$2]), m4_shift2($@@))])])
m4_define([m4_min],
[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
       [$#], [1], [m4_eval([$1])],
       [$#$1], [2$2], [m4_eval([$1])],
       [$#], [2],
       [m4_eval((([$1]) < ([$2])) * ([$1]) + (([$1]) >= ([$2])) * ([$2]))],
       [$0($0([$1], [$2]), m4_shift2($@@))])])


# m4_sign(A)
# ----------
# The sign of the integer expression A.
m4_define([m4_sign],
[m4_eval((([$1]) > 0) - (([$1]) < 0))])



## ------------------------ ##
## 14. Version processing.  ##
## ------------------------ ##


# m4_version_unletter(VERSION)
# ----------------------------
# Normalize beta version numbers with letters to numeric expressions, which
# can then be handed to m4_eval for the purpose of comparison.
#
#   Nl -> (N+1).-1.(l#)
#
# for example:
#   [2.14a] -> [2.14+1.-1.[0r36:a]] -> 2.15.-1.10
#   [2.14b] -> [2.15+1.-1.[0r36:b]] -> 2.15.-1.11
#   [2.61aa.b] -> [2.61+1.-1.[0r36:aa],+1.-1.[0r36:b]] -> 2.62.-1.370.1.-1.11
#
# This macro expects reasonable version numbers, but can handle double
# letters and does not expand any macros.  Original version strings can
# use both `.' and `-' separators.
#
# Inline constant expansions, to avoid m4_defn overhead.
# _m4_version_unletter is the real workhorse used by m4_version_compare,
# but since [0r36:a] is less readable than 10, we provide a wrapper for
# human use.
m4_define([m4_version_unletter],
[m4_map_sep([m4_eval], [.],
	    m4_dquote(m4_dquote_elt(m4_unquote(_$0([$1])))))])
m4_define([_m4_version_unletter],
[m4_bpatsubst(m4_translit([[[$1]]], [.-], [,,]),]dnl
m4_dquote(m4_dquote(m4_defn([m4_cr_Letters])))[[+],
	      [+1,-1,[0r36:\&]])])


# m4_version_compare(VERSION-1, VERSION-2)
# ----------------------------------------
# Compare the two version numbers and expand into
#  -1 if VERSION-1 < VERSION-2
#   0 if           =
#   1 if           >
m4_define([m4_version_compare],
[m4_list_cmp(_m4_version_unletter([$1]), _m4_version_unletter([$2]))])


## ------------------- ##
## 15. File handling.  ##
## ------------------- ##


# It is a real pity that M4 comes with no macros to bind a diversion
# to a file.  So we have to deal without, which makes us a lot more
# fragile than we should.


# m4_file_append(FILE-NAME, CONTENT)
# ----------------------------------
m4_define([m4_file_append],
[m4_syscmd([cat >>$1 <<_m4eof
$2
_m4eof
])
m4_if(m4_sysval, [0], [],
      [m4_fatal([$0: cannot write: $1])])])



## ------------------------ ##
## 16. Setting M4sugar up.  ##
## ------------------------ ##


# m4_init
# -------
# Initialize the m4sugar language.
m4_define([m4_init],
[# We need a tmp directory.
m4_ifndef([m4_tmpdir],
          [m4_define([m4_tmpdir], [/tmp])])

# M4sugar reserves `m4_[A-Za-z0-9_]*'.  We'd need \b and +,
# but they are not portable.
m4_pattern_forbid([^m4_])
m4_pattern_forbid([^dnl$])

# _m4_divert_diversion should be defined:
m4_divert_push([KILL])

# Check the divert push/pop perfect balance.
m4_wrap([m4_divert_pop([])
	 m4_ifdef([_m4_divert_diversion],
	   [m4_fatal([$0: unbalanced m4_divert_push:]_m4_divert_n_stack)])[]])
])
@


1.8
log
@careful fastmerge, lets see what breaks 
@
text
@d2 1
a2 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.7 2008/05/02 23:42:41 tg Exp $
a1637 46
# m4_cr_all
# ---------
# The character range representing everything, with `-' as the last
# character, since it is special to m4_translit.  Use with care, because
# it contains characters special to M4 (fortunately, both ASCII and EBCDIC
# have [] in order, so m4_defn([m4_cr_all]) remains a valid string).  It
# also contains characters special to terminals, so it should never be
# displayed in an error message.  Also, attempts to map [ and ] to other
# characters via m4_translit must deal with the fact that m4_translit does
# not add quotes to the output.
#
# It is mainly useful in generating inverted character range maps, for use
# in places where m4_translit is faster than an equivalent m4_bpatsubst;
# the regex `[^a-z]' is equivalent to:
#  m4_translit(m4_dquote(m4_defn([m4_cr_all])), [a-z])
m4_define([m4_cr_all],
m4_translit(m4_dquote(m4_format(m4_dquote(m4_for(
  ,1,255,,[[%c]]))m4_for([i],1,255,,[,i]))), [-])-)


# _m4_define_cr_not(CATEGORY)
# ---------------------------
# Define m4_cr_not_CATEGORY as the inverse of m4_cr_CATEGORY.
m4_define([_m4_define_cr_not],
[m4_define([m4_cr_not_$1],
	   m4_translit(m4_dquote(m4_defn([m4_cr_all])),
		       m4_defn([m4_cr_$1])))])


# m4_cr_not_letters
# m4_cr_not_LETTERS
# m4_cr_not_Letters
# m4_cr_not_digits
# m4_cr_not_alnum
# m4_cr_not_symbols1
# m4_cr_not_symbols2
# ------------------
# Inverse character sets
_m4_define_cr_not([letters])
_m4_define_cr_not([LETTERS])
_m4_define_cr_not([Letters])
_m4_define_cr_not([digits])
_m4_define_cr_not([alnum])
_m4_define_cr_not([symbols1])
_m4_define_cr_not([symbols2])

@


1.7
log
@beautify, simplify licence (no advertising clause any more), etc.
@
text
@d2 1
a2 1
# $MirOS$
d8 2
a9 2
# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software
# Foundation, Inc.
d11 1
a11 1
# This program is free software; you can redistribute it and/or modify
d95 1
a95 1
# The user will certainly prefer to see `to'.
d102 1
a102 1
# Rename the macro SRC as DST.
d109 1
a109 1
# Rename MACRO-NAME as m4_MACRO-NAME.
d116 1
a116 1
# Copy m4_MACRO-NAME as MACRO-NAME.
d126 1
d147 7
a153 2
m4_rename([m4wrap], [m4_wrap])
m4_rename_m4([maketemp])
d226 9
a234 56
# m4_warning_ifelse(CATEGORY, IF-TRUE, IF-FALSE)
# ----------------------------------------------
# If the CATEGORY of warnings is enabled, expand IF_TRUE otherwise
# IF-FALSE.
#
# The variable `m4_warnings' contains a comma separated list of
# warnings which order is the converse from the one specified by
# the user, i.e., if she specified `-W error,none,obsolete',
# `m4_warnings' is `obsolete,none,error'.  We read it from left to
# right, and:
# - if none or noCATEGORY is met, run IF-FALSE
# - if all or CATEGORY is met, run IF-TRUE
# - if there is nothing left, run IF-FALSE.
m4_define([m4_warning_ifelse],
[_m4_warning_ifelse([$1], [$2], [$3], m4_warnings)])


# _m4_warning_ifelse(CATEGORY, IF-TRUE, IF-FALSE, WARNING1, ...)
# --------------------------------------------------------------
# Implementation of the loop described above.
m4_define([_m4_warning_ifelse],
[m4_case([$4],
         [$1],    [$2],
         [all],   [$2],
         [],      [$3],
         [none],  [$3],
         [no-$1], [$3],
         [$0([$1], [$2], [$3], m4_shiftn(4, $@@))])])


# _m4_warning_error_ifelse(IF-TRUE, IF-FALSE)
# -------------------------------------------
# The same as m4_warning_ifelse, but scan for `error' only.
m4_define([_m4_warning_error_ifelse],
[__m4_warning_error_ifelse([$1], [$2], m4_warnings)])


# __m4_warning_error_ifelse(IF-TRUE, IF-FALSE)
# --------------------------------------------
# The same as _m4_warning_ifelse, but scan for `error' only.
m4_define([__m4_warning_error_ifelse],
[m4_case([$3],
         [error],    [$1],
         [],         [$2],
         [no-error], [$2],
         [$0([$1], [$2], m4_shiftn(3, $@@))])])



# _m4_warn(MESSAGE)
# -----------------
# Report MESSAGE as a warning, unless the user requested -W error,
# in which case report a fatal error.
m4_define([_m4_warn],
[_m4_warning_error_ifelse([m4_fatal([$1])],
                          [m4_warning([$1])])])
d242 5
a246 2
[m4_warning_ifelse([$1], [_m4_warn([$2])])])

d257 2
a258 2
# several times.  This is in general a dangerous operation because
# quite nobody quotes the first argument of m4_define.
d278 1
a278 1
# As the builtin include, but warns against multiple inclusions.
d286 1
a286 1
# As the builtin sinclude, but warns against multiple inclusions.
d300 1
a300 1
# In case of arguments of macros, eg $[1], it makes little difference.
d306 1
a306 1
# So you want a variation of `m4_ifset' that expects a macro name as $[1].
d308 1
a308 1
# it runs TRUE etc.
d378 1
a378 1
       [m4_case([$1], m4_shiftn(3, $@@))])])
d400 1
a400 1
       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shiftn(3, $@@))],
d415 10
a425 11
# m4_map(MACRO, LIST)
# -------------------
# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements
# of LIST (which can be lists themselves, for multiple arguments MACROs).
m4_define([m4_fst], [$1])
m4_define([m4_map],
[m4_if([$2], [[]], [],
       [_m4_map([$1], [$2])])])
m4_define([_m4_map],
[m4_ifval([$2],
	  [$1(m4_fst($2))[]_m4_map([$1], m4_cdr($2))])])
d428 34
a461 8
# m4_map_sep(MACRO, SEPARATOR, LIST)
# ----------------------------------
# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1, $2... $N
# are the elements of LIST (which can be lists themselves, for multiple
# arguments MACROs).
m4_define([m4_map_sep],
[m4_if([$3], [[]], [],
       [$1(m4_fst($3))[]_m4_map([$2[]$1], m4_cdr($3))])])
d483 3
d489 4
a492 1
       [$#], 2, [m4_builtin([patsubst], $@@)],
d494 1
a494 13
	   m4_shiftn(3, $@@))])])



# m4_do(STRING, ...)
# ------------------
# This macro invokes all its arguments (in sequence, of course).  It is
# useful for making your macros more structured and readable by dropping
# unnecessary dnl's and have the macros indented properly.
m4_define([m4_do],
[m4_if($#, 0, [],
       $#, 1, [$1],
       [$1[]m4_do(m4_shift($@@))])])
d507 3
d511 1
a511 1
[m4_ifval([$1], [$1], [$2])])
d516 5
a520 2
# Unlike to the original, don't tolerate popping something which is
# undefined.
d522 3
a524 3
[m4_ifndef([$1],
	   [m4_fatal([$0: undefined macro: $1])])dnl
m4_builtin([defn], $@@)])
d557 5
a561 2
# Unlike to the original, don't tolerate popping something which is
# undefined.
d563 3
a565 3
[m4_ifndef([$1],
	   [m4_fatal([$0: undefined macro: $1])])dnl
m4_builtin([popdef], $@@)])
d568 98
a665 1
# m4_quote(ARGS)
d667 18
a684 7
# Return ARGS as a single arguments.
#
# It is important to realize the difference between `m4_quote(exp)' and
# `[exp]': in the first case you obtain the quoted *result* of the
# expansion of EXP, while in the latter you just obtain the string
# `exp'.
m4_define([m4_quote],  [[$*]])
d688 61
d752 6
a757 3
# macros it contains.  Amongst other things useful for enabling macro
# invocations inside strings with [] blocks (for instance regexps and
# help-strings).
d759 1
a759 1
[m4_changequote(-=<{,}>=-)$1-=<{}>=-m4_changequote([,])])
d762 11
a772 6
# m4_shiftn(N, ...)
# -----------------
# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
m4_define([m4_shiftn],
[m4_assert(($1 >= 0) && ($# > $1))dnl
_m4_shiftn($@@)])
d774 9
a782 4
m4_define([_m4_shiftn],
[m4_if([$1], 0,
       [m4_shift($@@)],
       [_m4_shiftn(m4_eval([$1]-1), m4_shift(m4_shift($@@)))])])
d785 7
a791 8
# m4_undefine(NAME)
# -----------------
# Unlike to the original, don't tolerate undefining something which is
# undefined.
m4_define([m4_undefine],
[m4_ifndef([$1],
	   [m4_fatal([$0: undefined macro: $1])])dnl
m4_builtin([undefine], $@@)])
d795 1
a795 1
## 7. Implementing m4 loops.  ##
d801 2
a802 1
# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO.
d804 2
d808 1
a808 1
m4_if(m4_eval(([$3]) > $1), 1,
d811 4
a814 2
_m4_for([$1], m4_eval((([$3]) - $1) / _m4_step * _m4_step + $1), _m4_step, [$5])],
      m4_eval(([$3]) < $1), 1,
d817 4
a820 2
_m4_for([$1], m4_eval(($1 - ([$3])) / -(_m4_step) * _m4_step + $1), _m4_step, [$5])],
      [m4_pushdef(_m4_step,[])dnl
d831 2
a832 2
m4_if($1, [$2], [],
      [m4_define([$1], m4_eval($1+[$3]))_m4_for([$1], [$2], [$3], [$4])])])
d836 2
a837 5
# seem.  Actually, the example of a `foreach' loop in the m4
# documentation is wrong: it does not quote the arguments properly,
# which leads to undesirable expansions.
#
# The example in the documentation is:
d841 1
a841 1
# |        [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
d844 2
a845 4
# |	       [m4_if([$2], [()], ,
# |		     [m4_define([$1], _arg1$2)$3[]_foreach([$1],
# |                                                        (shift$2),
# |                                                        [$3])])])
d873 1
a873 3
# |	     [m4_define([$1], [_arg1$2])$3[]_foreach([$1],
# |                                                 [(shift$2)],
# |                                                 [$3])])])
d896 1
a896 3
# |	     [m4_define([$1], [_arg1($2)])$3[]_foreach([$1],
# |                                                   [shift($2)],
# |                                                   [$3])])])
d900 13
a912 2
# to improve robustness, and you come up with a quite satisfactory
# implementation.
d933 8
d942 1
a942 1
[m4_pushdef([$1])_m4_foreach($@@)m4_popdef([$1])])
d945 2
a946 3
[m4_ifval([$2],
	  [m4_define([$1], m4_car($2))$3[]dnl
_m4_foreach([$1], m4_cdr($2), [$3])])])
d961 2
a962 1
[m4_foreach([$1], m4_split(m4_normalize([$2])), [$3])])
d964 24
d991 1
a991 1
## 8. More diversion support.  ##
d1007 3
d1045 1
a1045 1
           [m4_fatal([too many m4_divert_pop])])dnl
d1071 2
a1072 2
# Output once CONTENT into DIVERSION-NAME (which may be a number
# actually).  An end of line is appended for free to CONTENT.
d1079 2
a1080 1
# Undivert DIVERSION-NAME.
d1085 3
a1087 3
## -------------------------------------------- ##
## 8. Defining macros with bells and whistles.  ##
## -------------------------------------------- ##
d1111 2
a1112 2
# The first idea: why using diversions?
# -------------------------------------
d1125 1
a1125 1
# must keep the expansions of the various level of m4_require separated.
d1188 1
a1188 1
# Starting from 2.50, uses an implementation provided by Axel Thimm.
d1190 4
a1193 4
# same as the one in which macro are expanded.  (The bug above can
# indeed be described as: a macro has been AC_PROVIDE'd, but it is
# emitted after: the lack of correlation between emission and expansion
# order is guilty).
d1195 1
a1195 1
# How to do that?  You keeping the stack of diversions to elaborate the
d1365 1
d1369 1
a1369 1
m4_defn([m4_expansion_stack])]))])
d1409 3
d1413 4
a1416 4
[m4_ifndef([m4_expansion_stack], [_m4_defun_pro_outer[]])dnl
m4_expansion_stack_push(m4_defn([m4_location($1)])[: $1 is expanded from...])dnl
m4_pushdef([_m4_expanding($1)])dnl
])
d1419 1
a1419 3
[m4_copy([_m4_divert_diversion], [_m4_divert_dump])dnl
m4_divert_push([GROW])dnl
])
d1425 3
d1429 4
a1432 5
[m4_popdef([_m4_expanding($1)])dnl
m4_expansion_stack_pop()dnl
m4_ifndef([m4_expansion_stack], [_m4_defun_epi_outer[]])dnl
m4_provide([$1])dnl
])
d1435 3
a1437 4
[m4_undefine([_m4_divert_dump])dnl
m4_divert_pop([GROW])dnl
m4_undivert([GROW])dnl
])
d1470 2
a1471 2
# Declare that no token matching the extended regular expression ERE
# should be seen in the output but if...
d1478 1
a1478 1
# ... but if that token matches the extended regular expression ERE.
d1483 3
a1485 3
## ----------------------------- ##
## Dependencies between macros.  ##
## ----------------------------- ##
d1490 1
d1528 3
d1532 8
a1539 9
[m4_ifdef([_m4_expanding($1)],
	 [m4_fatal([$0: circular dependency of $1])])dnl
m4_ifndef([_m4_divert_dump],
	  [m4_fatal([$0($1): cannot be used outside of an ]dnl
m4_bmatch([$0], [^AC_], [[AC_DEFUN]], [[m4_defun]])['d macro])])dnl
m4_provide_if([$1],
	      [],
	      [_m4_require_call([$1], [$2])])dnl
])
d1542 2
a1543 2
# _m4_require_call(BODY-TO-EXPAND)
# --------------------------------
d1545 3
d1549 3
a1551 3
[m4_define([_m4_divert_grow], m4_decr(_m4_divert_grow))dnl
m4_divert_push(_m4_divert_grow)dnl
m4_default([$2], [$1])
d1555 5
a1559 6
		       [$1 is m4_require'd but not m4_defun'd])])dnl
m4_divert(m4_defn([_m4_divert_dump]))dnl
m4_undivert(_m4_divert_grow)dnl
m4_divert_pop(_m4_divert_grow)dnl
m4_define([_m4_divert_grow], m4_incr(_m4_divert_grow))dnl
])
d1596 3
a1598 3
## -------------------- ##
## 9. Text processing.  ##
## -------------------- ##
d1618 10
a1627 1
# m4_cr_symbols1 & m4_cr_symbols2
d1638 53
d1721 3
a1723 1
# These macros lowercase and uppercase strings.
d1748 2
a1749 1
# in the macro body, so the definition is stored correctly.
d1753 1
a1753 1
# patsubst is ``STRING'' (i.e., with additional `` and '').
d1759 5
a1763 1

d1765 4
a1768 1
[m4_ifval([$1], [_m4_split($@@)])])
d1771 3
a1773 7
[m4_changequote(``, '')dnl
[dnl Can't use m4_default here instead of m4_if, because m4_default uses
dnl [ and ] as quotes.
m4_bpatsubst(````$1'''',
	     m4_if(``$2'',, ``[	 ]+'', ``$2''),
	     ``], ['')]dnl
m4_changequote([, ])])
d1787 2
d1790 3
a1792 1
[m4_translit(m4_bpatsubst([[[$1]]], [\\
d1794 1
a1794 1
], [ ])])
d1807 4
a1810 1
# Because we want to preserve active symbols, STRING must be double-quoted.
d1812 1
a1812 1
# Then notice the 2 last patterns: they are in charge of removing the
d1814 3
a1816 3
# applied to doubly quoted strings, i.e. more or less [[STRING]].  So
# if there is a leading space in STRING, then it is the *third*
# character, since there are two leading `['; equally for the last pattern.
d1818 1
a1818 1
[m4_bpatsubsts([[$1]],
d1820 1
a1820 2
	       [^\(..\) ],    [\1],
	       [ \(..\)$],    [\1])])
d1842 18
a1859 6
# Produce ARG1SEPARG2...SEPARGn.
m4_defun([m4_join],
[m4_case([$#],
	 [1], [],
	 [2], [[$2]],
	 [[$2][$1]$0([$1], m4_shiftn(2, $@@))])])
d1862 27
d1897 3
d1903 4
a1906 4
#    | m4_define(active, ACTIVE)
#    | m4_append([sentence], [This is an])
#    | m4_append([sentence], [ active ])
#    | m4_append([sentence], [symbol.])
d1915 4
a1918 4
#    | m4_define(active, ACTIVE)
#    | m4_append([hooks], [m4_define([act1], [act2])])
#    | m4_append([hooks], [m4_define([act2], [active])])
#    | m4_undefine([active])
d1925 12
d1939 1
a1939 1
	   m4_ifdef([$1], [m4_defn([$1])$3])[$2])])
d1966 27
d2001 3
d2029 11
a2039 4
# This macro does not leave a trailing space behind the last word,
# what complicates it a bit.  The algorithm is stupid simple: all the
# words are preceded by m4_Separator which is defined to empty for the
# first word, and then ` ' (single space) for all the others.
d2041 34
a2074 32
[m4_pushdef([m4_Prefix], [$2])dnl
m4_pushdef([m4_Prefix1], m4_default([$3], [m4_Prefix]))dnl
m4_pushdef([m4_Width], m4_default([$4], 79))dnl
m4_pushdef([m4_Cursor], m4_qlen(m4_Prefix1))dnl
m4_pushdef([m4_Separator], [])dnl
m4_Prefix1[]dnl
m4_if(m4_eval(m4_qlen(m4_Prefix1) > m4_len(m4_Prefix)),
      1, [m4_define([m4_Cursor], m4_len(m4_Prefix))
m4_Prefix],
      m4_if(m4_eval(m4_qlen(m4_Prefix1) < m4_len(m4_Prefix)),
	    [0], [],
	    [m4_define([m4_Cursor], m4_len(m4_Prefix))[]dnl
m4_for(m4_Space, m4_qlen(m4_Prefix1), m4_eval(m4_len(m4_Prefix) - 1),
		    [], [ ])])[]dnl
)[]dnl
m4_foreach_w([m4_Word], [$1],
[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_qlen(m4_defn([m4_Word])) + 1))dnl
dnl New line if too long, else insert a space unless it is the first
dnl of the words.
m4_if(m4_eval(m4_Cursor > m4_Width),
      1, [m4_define([m4_Cursor],
		    m4_eval(m4_len(m4_Prefix) + m4_qlen(m4_defn([m4_Word])) + 1))]
m4_Prefix,
       [m4_Separator])[]dnl
m4_defn([m4_Word])[]dnl
m4_define([m4_Separator], [ ])])dnl
m4_popdef([m4_Separator])dnl
m4_popdef([m4_Cursor])dnl
m4_popdef([m4_Width])dnl
m4_popdef([m4_Prefix1])dnl
m4_popdef([m4_Prefix])dnl
])
d2079 5
d2085 4
a2088 1
[@@%:@@@@%:@@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @@%:@@@@%:@@
d2090 2
a2091 1
@@%:@@@@%:@@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @@%:@@@@%:@@[]dnl
d2098 2
d2101 4
a2104 1
[m4_len(m4_bpatsubsts([[$1]], [@@\(<:\|:>\|S|\|%:\)@@], [P], [@@&t@@]))])
d2117 1
a2117 1
## 10. Number processing.  ##
a2119 10
# m4_sign(A)
# ----------
#
# The sign of the integer A.
m4_define([m4_sign],
[m4_bmatch([$1],
	   [^-], -1,
	   [^0+], 0,
		  1)])

d2122 1
a2122 2
#
# Compare two integers.
d2127 1
a2127 1
[m4_sign(m4_eval([$1 - $2]))])
d2133 16
a2148 8
# Compare the two lists of integers A and B.  For instance:
#   m4_list_cmp((1, 0),     (1))    ->  0
#   m4_list_cmp((1, 0),     (1, 0)) ->  0
#   m4_list_cmp((1, 2),     (1, 0)) ->  1
#   m4_list_cmp((1, 2, 3),  (1, 2)) ->  1
#   m4_list_cmp((1, 2, -3), (1, 2)) -> -1
#   m4_list_cmp((1, 0),     (1, 2)) -> -1
#   m4_list_cmp((1),        (1, 2)) -> -1
d2150 38
a2187 7
[m4_if([$1$2], [()()], 0,
       [$1], [()], [$0((0), [$2])],
       [$2], [()], [$0([$1], (0))],
       [m4_case(m4_cmp(m4_car$1, m4_car$2),
		-1, -1,
		 1, 1,
		 0, [$0((m4_shift$1), (m4_shift$2))])])])
d2192 1
a2192 1
## 11. Version processing.  ##
d2198 2
a2199 1
# Normalize beta version numbers with letters to numbers only for comparison.
d2203 13
a2215 3
#i.e., 2.14a -> 2.15.-1.1, 2.14b -> 2.15.-1.2, etc.
# This macro is absolutely not robust to active macro, it expects
# reasonable version numbers and is valid up to `z', no double letters.
d2217 6
a2222 9
[m4_translit(m4_bpatsubsts([$1],
			   [\([0-9]+\)\([abcdefghi]\)],
			     [m4_eval(\1 + 1).-1.\2],
			   [\([0-9]+\)\([jklmnopqrs]\)],
			     [m4_eval(\1 + 1).-1.1\2],
			   [\([0-9]+\)\([tuvwxyz]\)],
			     [m4_eval(\1 + 1).-1.2\2]),
	     [abcdefghijklmnopqrstuvwxyz],
	     [12345678901234567890123456])])
d2232 1
a2232 3
[m4_list_cmp((m4_split(m4_version_unletter([$1]), [\.])),
	     (m4_split(m4_version_unletter([$2]), [\.])))])

d2236 1
a2236 1
## 12. File handling.  ##
d2242 1
a2242 1
# fragile that we should.
d2258 1
a2258 1
## 13. Setting M4sugar up.  ##
d2264 1
@


1.6
log
@automerge autoconf-2.60 and libtool-branch_1_5-20060630
@
text
@d2 2
a4 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.5 2006/06/12 19:10:32 tg Exp $
@


1.5
log
@sync, add missing funcs
@
text
@d3 1
a3 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.4 2006/06/12 19:04:30 tg Exp $
d1834 3
d1838 2
a1839 1
m4_wrap([m4_ifdef([_m4_divert_diversion],
a1840 3

m4_divert_push([KILL])
m4_wrap([m4_divert_pop([KILL])[]])
@


1.4
log
@merge the upgrade - no change in libobjc/configure (ac2.13)
this only worked after reducing the diff to FSF to about 40%
of the "pure" merge, though... and with +h
@
text
@d3 1
a3 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.3 2005/02/28 22:36:19 tg Exp $
d117 1
a117 1
[m4_copy([$1], m4_patsubst([$1], [^m4_\(.*\)], [[\1]]))])
d439 1
@


1.3
log
@GNU m4 only has 'eval' but no 'expr' builtin;
we have both (I hope and TFM says)
@
text
@d3 1
a3 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.2 2005/02/11 00:37:33 tg Exp $
d6 3
a8 2
# Copyright 1999, 2000, 2001, 2005
# Free Software Foundation, Inc.
d22 2
a23 2
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
d64 1
a64 1
set the M4 environment variable to its path name.)
d89 2
a90 2
# 2. m4_define([from], [to($@@)])
# Well, obviously 1 is more expansive in space.  Maybe 2 is more expansive
d94 1
a94 1
# The user will certainly prefer see `from'.
d139 1
a139 1
m4_rename_m4([include])
d147 2
a148 1
m4_rename_m4([patsubst])
d151 2
a152 1
m4_rename_m4([regexp])
d157 2
d213 1
d309 1
a309 1
          [m4_warn([syntax], [file `$1' included several times])])dnl
d362 1
a362 1
           [$1
d373 1
a373 1
             [m4_n([$2])])])
d382 2
a383 2
          [m4_if(m4_defn([$1]), [], [$3], [$2])],
          [$3])])
d418 2
a419 2
# m4_match(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
# ----------------------------------------------------
d433 15
a447 2
m4_define([m4_match],
[m4_if([$#], 0, [],
d449 15
a463 3
       [$#], 2, [$2],
       m4_regexp([$1], [$2]), -1, [m4_match([$1], m4_shiftn(3, $@@))],
       [$3])])
d465 8
d479 24
d507 1
a507 1
# unecessary dnl's and have the macros indented properly.
d514 7
d534 1
a534 1
           [m4_fatal([$0: undefined macro: $1])])dnl
d542 1
a542 1
          [m4_pushdef([_m4_dumpdefs], m4_defn([$1]))dnl
d552 1
a552 1
          [m4_pushdef([$1], m4_defn([_m4_dumpdefs]))dnl
d572 1
a572 1
           [m4_fatal([$0: undefined macro: $1])])dnl
d576 3
a578 3
# m4_quote(STRING)
# ----------------
# Return STRING quoted.
d584 2
a585 2
m4_define([m4_quote], [[$*]])
m4_define([m4_dquote], [[[$*]]])
d617 1
a617 1
           [m4_fatal([$0: undefined macro: $1])])dnl
d631 12
a642 7
[m4_case(m4_sign(m4_eval($3 - $2)),
         1, [m4_assert(m4_sign(m4_default($4, 1)) == 1)],
        -1, [m4_assert(m4_sign(m4_default($4, -1)) == -1)])dnl
m4_pushdef([$1], [$2])dnl
m4_if(m4_eval([$3 > $2]), 1,
      [_m4_for([$1], [$3], m4_default([$4], 1), [$5])],
      [_m4_for([$1], [$3], m4_default([$4], -1), [$5])])dnl
d646 3
a648 3
# _m4_for(VARIABLE, FIRST, LAST, STEP, EXPRESSION)
# ------------------------------------------------
# Core of the loop, no consistency checks.
d658 1
a658 1
# which leads to undesired expansions.
d667 2
a668 2
# | 	      [m4_if([$2], [()], ,
# | 		     [m4_define([$1], _arg1$2)$3[]_foreach([$1],
d698 1
a698 1
# | 	    [m4_define([$1], [_arg1$2])$3[]_foreach([$1],
d723 1
a723 1
# | 	    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1],
a753 2
# Low level macros used to define m4_foreach.
m4_define([m4_car], [$1])
d755 18
a772 4
[m4_if(m4_quote($2), [], [],
       [m4_define([$1], [m4_car($2)])$3[]_m4_foreach([$1],
                                                     [m4_shift($2)],
                                                     [$3])])])
d784 1
a784 1
# otherwise if is a NUMBER return it.
d787 2
a788 2
          [m4_indir([_m4_divert($1)])],
          [$1])])
d794 8
d806 1
a806 3
[m4_define([m4_divert_stack],
           m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
m4_defn([m4_divert_stack])]))dnl
d815 1
a815 3
[m4_pushdef([m4_divert_stack],
            m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
m4_defn([m4_divert_stack])]))dnl
d817 1
a817 1
m4_builtin([divert], _m4_divert(_m4_divert_diversion))dnl
d825 1
d827 6
a832 3
[m4_ifval([$1],
     [m4_if(_m4_divert([$1]), m4_divnum, [],
            [m4_fatal([$0($1): unexpected current diversion: ]m4_divnum)])])dnl
a833 2
dnl m4_ifndef([_m4_divert_diversion],
dnl           [m4_fatal([too many m4_divert_pop])])dnl
d835 3
a837 3
           m4_ifdef([_m4_divert_diversion],
                    [_m4_divert(_m4_divert_diversion)], -1))dnl
m4_popdef([m4_divert_stack])dnl
a866 2


d888 1
a888 1
# prepare the expansion of the macro and its dependencies (by Franois
d910 4
a913 4
# 	   GROW - 2: Test...3
# 	   GROW - 1: Test...2
# 	   GROW:     Test...1
# 	   BODY:
d918 4
a921 4
# 	   GROW - 2:
# 	   GROW - 1:
# 	   GROW:
# 	   BODY:        Test...3; Test...2; Test...1
d945 4
a948 4
# 		 3 --- 2b
# 		/        \              is m4_require'd by
# 	       /          \       left -------------------- right
# 	    2a ------------ 1
d952 4
a955 4
# 	   GROW - 2: TEST3
# 	   GROW - 1: TEST2a; TEST2b
# 	   GROW:     TEST1
# 	   BODY:
d962 4
a965 4
# 	   GROW - 2:
# 	   GROW - 1:
# 	   GROW:
# 	   BODY:        TEST3; TEST2a; TEST2b; TEST1
d983 4
a986 4
# 	   GROW - 2:
# 	   GROW - 1: TEST2a
# 	   GROW:     Elaboration of TEST1
# 	   BODY:
d990 4
a993 4
# 	   GROW - 2:
# 	   GROW - 1:
# 	   GROW:     Elaboration of TEST1
# 	   BODY:     TEST2a
d998 4
a1001 4
# 	   GROW - 2: TEST3
# 	   GROW - 1: Elaboration of TEST2b
# 	   GROW:     Elaboration of TEST1
# 	   BODY:      TEST2a
d1005 4
a1008 4
# 	   GROW - 2:
# 	   GROW - 1: Elaboration of TEST2b
# 	   GROW:     Elaboration of TEST1
# 	   BODY:     TEST2a; TEST3
d1012 4
a1015 4
# 	   GROW - 2:
# 	   GROW - 1:
# 	   GROW:     Elaboration of TEST1
# 	   BODY:     TEST2a; TEST3; TEST2b
d1019 4
a1022 4
# 	   GROW - 2:
# 	   GROW - 1:
# 	   GROW:
# 	   BODY:     TEST2a; TEST3; TEST2b: TEST1
d1024 1
a1024 1
# The idea, is simple, but the implementation is a bit evolved.  If you
d1035 2
a1036 2
# 	    AC_INIT
# 	    TEST1
d1041 1
a1041 1
# This implements tries not to assume that of the current diversion is
d1046 1
a1046 1
# were not inside an m4_defun'd macro, and especially, you cannot
d1061 1
a1061 1
# The prologue of TEST1 sets AC_DIVERSION_DUMP, which is the diversion
a1064 19
#   DUMP:       BODY
#   BODY:       empty
#   diversions: GROW, BODY |-
#
# * TEST1 requires TEST2a: prologue
# m4_require m4_divert_pushes another temporary diversion GROW - 1 (in
# fact, the diversion whose number is one less than the current
# diversion), and expands TEST2a in there.
#   DUMP:       BODY
#   BODY:       empty
#   diversions: GROW-1, GROW, BODY |-
#
# * TEST2a is expanded.
# Its prologue pushes the current diversion again.
#   DUMP:       BODY
#   BODY:       empty
#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
# It is expanded in GROW - 1, and GROW - 1 is popped by the epilogue
# of TEST2a.
d1066 8
a1073 1
#   BODY:        nothing
d1076 24
d1101 10
a1110 60
# * TEST1 requires TEST2a: epilogue
# The content of the current diversion is appended to DUMP (and removed
# from the current diversion).  A diversion is popped.
#   DUMP:       BODY
#   BODY:       TEST2a
#   diversions: GROW, BODY |-
#
# * TEST1 requires TEST2b: prologue
# m4_require pushes GROW - 1 and expands TEST2b.
#   DUMP:       BODY
#   BODY:       TEST2a
#   diversions: GROW - 1, GROW, BODY |-
#
# * TEST2b is expanded.
# Its prologue pushes the current diversion again.
#   DUMP:       BODY
#   BODY:       TEST2a
#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
# The body is expanded here.
#
# * TEST2b requires TEST3: prologue
# m4_require pushes GROW - 2 and expands TEST3.
#   DUMP:       BODY
#   BODY:       TEST2a
#   diversions: GROW - 2, GROW - 1, GROW - 1, GROW, BODY |-
#
# * TEST3 is expanded.
# Its prologue pushes the current diversion again.
#   DUMP:       BODY
#   BODY:       TEST2a
#   diversions: GROW-2, GROW-2, GROW-1, GROW-1, GROW, BODY |-
# TEST3 requires TEST2a, but TEST2a has already been AC_PROVIDE'd, so
# nothing happens.  It's body is expanded here, and its epilogue pops a
# diversion.
#   DUMP:       BODY
#   BODY:       TEST2a
#   GROW - 2:   TEST3
#   diversions: GROW - 2, GROW - 1, GROW - 1, GROW, BODY |-
#
# * TEST2b requires TEST3: epilogue
# The current diversion is appended to DUMP, and a diversion is popped.
#   DUMP:       BODY
#   BODY:       TEST2a; TEST3
#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
# The content of TEST2b is expanded here.
#   DUMP:       BODY
#   BODY:       TEST2a; TEST3
#   GROW - 1:   TEST2b,
#   diversions: GROW - 1, GROW - 1, GROW, BODY |-
# The epilogue of TEST2b pops a diversion.
#   DUMP:       BODY
#   BODY:       TEST2a; TEST3
#   GROW - 1:   TEST2b,
#   diversions: GROW - 1, GROW, BODY |-
#
# * TEST1 requires TEST2b: epilogue
# The current diversion is appended to DUMP, and a diversion is popped.
#   DUMP:       BODY
#   BODY:       TEST2a; TEST3; TEST2b
#   diversions: GROW, BODY |-
d1113 6
a1118 8
# TEST1's own content is in GROW, and it's epilogue pops a diversion.
#   DUMP:       BODY
#   BODY:       TEST2a; TEST3; TEST2b
#   GROW:       TEST1
#   diversions: BODY |-
# Here, the epilogue of TEST1 notices the elaboration is done because
# DUMP and the current diversion are the same, it then undiverts
# GROW by hand, and undefines DUMP.
d1140 3
a1142 18
# In addition, we want to use the expansion stack to detect circular
# m4_require dependencies.  This means we need to browse the stack to
# check whether a macro being expanded is m4_require'd.  For ease of
# implementation, and certainly for the benefit of performances, we
# don't browse the m4_expansion_stack, rather each time we expand a
# macro FOO we define _m4_expanding(FOO).  Then m4_require(BAR) simply
# needs to check whether _m4_expanding(BAR) is defined to diagnose a
# circular dependency.
#
# To improve the diagnostic, in addition to keeping track of the stack
# of macro calls, m4_expansion_stack also records the m4_require
# stack.  Note that therefore an m4_defun'd macro being required will
# appear twice in the stack: the first time because it is required,
# the second because it is expanded.  We can avoid this, but it has
# two small drawbacks: (i) the implementation is slightly more
# complex, and (ii) it hides the difference between define'd macros
# (which don't appear in m4_expansion_stack) and m4_defun'd macros
# (which do).  The more debugging information, the better.
d1149 1
a1149 1
            [$1]m4_ifdef([m4_expansion_stack], [
a1154 1
# Dump the expansion stack.
d1164 1
a1164 1
          [m4_errprintn(m4_defn([m4_expansion_stack]))])dnl
d1191 2
a1192 1
[m4_expansion_stack_push(m4_defn([m4_location($1)])[: $1 is expanded from...])dnl
a1193 4
m4_ifdef([_m4_divert_dump],
         [m4_divert_push(m4_defn([_m4_divert_diversion]))],
         [m4_copy([_m4_divert_diversion], [_m4_divert_dump])dnl
m4_divert_push([GROW])])dnl
d1196 4
d1206 1
a1206 4
[m4_divert_pop()dnl
m4_if(_m4_divert_dump, _m4_divert_diversion,
      [m4_undivert([GROW])dnl
m4_undefine([_m4_divert_dump])])dnl
d1208 1
a1208 1
m4_popdef([_m4_expanding($1)])dnl
d1212 6
d1232 1
a1232 1
          [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])
d1242 3
a1244 3
          [m4_provide_ifelse([$1],
                             [m4_warn([syntax], [$1 invoked multiple times])],
                             [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])])
d1247 2
a1248 2
# m4_pattern_forbid(ERE)
# ----------------------
d1270 2
a1271 2
[m4_provide_ifelse([$2],
                   [m4_warn([syntax], [$2 was called before $1])])])
d1307 2
a1308 3
[m4_expansion_stack_push(m4_location[: $1 is required by...])dnl
m4_ifdef([_m4_expanding($1)],
         [m4_fatal([$0: circular dependency of $1])])dnl
d1310 14
a1323 4
          [m4_fatal([$0: cannot be used outside of an m4_defun'd macro])])dnl
m4_provide_ifelse([$1],
                  [],
                  [m4_divert_push(m4_eval(m4_divnum - 1))dnl
d1325 4
d1330 3
a1332 7
m4_undivert(m4_defn([_m4_divert_diversion]))dnl
m4_divert_pop(m4_defn([_m4_divert_dump]))])dnl
m4_provide_ifelse([$1],
                  [],
                  [m4_warn([syntax],
                           [$1 is m4_require'd but is not m4_defun'd])])dnl
m4_expansion_stack_pop()dnl
d1336 6
d1347 3
a1349 3
[m4_provide_ifelse(m4_ifval([$2], [[$2]], [[$1]]),
                   [],
                   [m4_provide(m4_ifval([$2], [[$2]], [[$1]]))[]$1])])
d1358 2
a1359 2
# m4_provide_ifelse(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
# -----------------------------------------------------------
d1364 1
a1364 1
m4_define([m4_provide_ifelse],
d1366 2
a1367 1
          [$2], [$3])])
d1374 1
d1386 1
d1404 8
d1415 1
d1454 5
a1458 5
# Pay attention to the m4_changequotes.  Inner m4_changequotes exist for
# obvious reasons (we want to insert square brackets).  Outer
# m4_changequotes are needed because otherwise the m4 parser, when it
# sees the closing bracket we add to the result, believes it is the
# end of the body of the macro we define.
d1469 5
a1473 3
m4_changequote(<<, >>)
m4_define(<<m4_split>>,
<<m4_changequote(``, '')dnl
d1476 4
a1479 5
m4_patsubst(````$1'''',
	    m4_if(``$2'',, ``[ 	]+'', ``$2''),
	    ``], ['')]dnl
m4_changequote([, ])>>)
m4_changequote([, ])
d1494 1
a1494 1
[m4_translit(m4_patsubst([[[$1]]], [\\
d1506 1
a1506 1
#    m4_strip([  active  		active ])end
d1509 7
a1515 11
# This macro is fun!  Because we want to preserve active symbols, STRING
# must be quoted for each evaluation, which explains there are 4 levels
# of brackets around $1 (don't forget that the result must be quoted
# too, hence one more quoting than applications).
#
# Then notice the patsubst of the middle: it is in charge of removing
# the leading space.  Why not just `patsubst(..., [^ ])'?  Because this
# macro will receive the output of the preceding patsubst, i.e. more or
# less [[STRING]].  So if there is a leading space in STRING, then it is
# the *third* character, since there are two leading `['; Equally for
# the outer patsubst.
d1517 4
a1520 4
[m4_patsubst(m4_patsubst(m4_patsubst([[[[$1]]]],
                            [[ 	]+], [ ]),
                   [^\(..\) ], [\1]),
          [ \(.\)$], [\1])])
d1545 3
a1547 3
         [1], [],
         [2], [[$2]],
         [[$2][$1]m4_join([$1], m4_shift(m4_shift($@@)))])])
d1551 6
a1556 4
# m4_append(MACRO-NAME, STRING)
# -----------------------------
# Redefine MACRO-NAME to hold its former content plus STRING at the
# end.  It is valid to use this macro with MACRO-NAME undefined.
d1585 1
a1585 1
           m4_ifdef([$1], [m4_defn([$1])])[$2])])
d1615 4
a1618 4
# If prefix is set, each line is prefixed with it.  If FIRST-PREFIX is
# specified, then the first line is prefixed with it.  As a special
# case, if the length of the first prefix is greater than that of
# PREFIX, then FIRST-PREFIX will be left alone on the first line.
d1638 2
a1639 2
#  => 	  Super long
#  => 	  documentation.
d1650 1
a1650 1
[m4_pushdef([m4_Prefix], m4_default([$2], []))dnl
d1653 1
a1653 1
m4_pushdef([m4_Cursor], m4_len(m4_Prefix1))dnl
d1656 1
a1656 1
m4_if(m4_eval(m4_Cursor > m4_len(m4_Prefix)),
d1658 9
a1666 3
m4_Prefix])[]dnl
m4_foreach_quoted([m4_Word], (m4_split(m4_normalize([$1]))),
[m4_define([m4_Cursor], m4_eval(m4_Cursor + len(m4_Word) + 1))dnl
d1671 1
a1671 1
                    m4_eval(m4_len(m4_Prefix) + m4_len(m4_Word) + 1))]
d1674 1
a1674 1
m4_Word[]dnl
d1684 24
d1718 4
a1721 4
[m4_match([$1],
          [^-], -1,
          [^0+], 0,
                 1)])
d1747 2
a1748 2
       [$1], [()], [m4_list_cmp((0), [$2])],
       [$2], [()], [m4_list_cmp([$1], (0))],
d1750 3
a1752 3
                -1, -1,
                 1, 1,
                 0, [m4_list_cmp((m4_shift$1), (m4_shift$2))])])])
d1771 9
a1779 9
[m4_translit(m4_patsubst(m4_patsubst(m4_patsubst([$1],
                                                 [\([0-9]+\)\([abcdefghi]\)],
                                                 [m4_eval(\1 + 1).-1.\2]),
                                     [\([0-9]+\)\([jklmnopqrs]\)],
                                     [m4_eval(\1 + 1).-1.1\2]),
                         [\([0-9]+\)\([tuvwxyz]\)],
                         [m4_eval(\1 + 1).-1.2\2]),
             [abcdefghijklmnopqrstuvwxyz],
             [12345678901234567890123456])])
d1790 1
a1790 1
             (m4_split(m4_version_unletter([$2]), [\.])))])
d1835 1
a1835 2
         [m4_fatal([$0: unbalanced m4_divert_push:]
m4_defn([m4_divert_stack]))])[]])
@


1.2
log
@hack so that m4_wrap_text() works again
-> unveils incompatibility between our m4 and GNU m4
@
text
@d3 1
a3 1
# $MirOS: contrib/gnu/libtool/m4sugar.inc,v 1.1 2005/02/10 19:34:36 tg Exp $
d133 1
a133 1
m4_define([m4_eval], [builtin([expr], $@@)])
@


1.1
log
@rename m4{salt,sugar}.m4 to *.inc
so that aclocal doesn't pick them
@
text
@d3 1
a3 1
# $MirOS: contrib/gnu/libtool/m4sugar.m4,v 1.2 2005/02/09 23:42:07 tg Exp $
d5 3
a7 2
# Requires GNU M4.
# Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d132 3
a134 1
m4_rename_m4([eval])
d150 3
a152 1
m4_rename_m4([shift])
@


1.1.101.1
log
@import m4sugar.m4 from autoconf 2.59, for upgrading
@
text
@d3 1
d6 1
a6 3
#
# Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation,
# Inc.
d115 1
a115 1
[m4_copy([$1], m4_bpatsubst([$1], [^m4_\(.*\)], [[\1]]))])
d143 1
a143 1
m4_rename([patsubst], [m4_bpatsubst])
d146 1
a146 1
m4_rename([regexp], [m4_bregexp])
a202 1

d208 56
a263 6
# _m4_warn(CATEGORY, MESSAGE, STACK-TRACE)
# ----------------------------------------
# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
# This is for traces only.
# The STACK-TRACE is a \n-separated list of "LOCATION: MESSAGE".
m4_define([_m4_warn], [])
d268 2
a269 1
# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
d271 2
a272 5
[_m4_warn([$1], [$2],
m4_ifdef([m4_expansion_stack],
         [m4_defn([m4_expansion_stack])
m4_location[: the top level]]))dnl
])
d298 1
a298 1
	  [m4_warn([syntax], [file `$1' included several times])])dnl
d351 1
a351 1
	   [$1
d362 1
a362 1
	     [m4_n([$2])])])
d371 2
a372 2
	  [m4_if(m4_defn([$1]), [], [$3], [$2])],
	  [$3])])
d404 1
a404 1
       [$0([$1], m4_shiftn(3, $@@))])])
d407 2
a408 2
# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
# -----------------------------------------------------
d422 1
a422 1
m4_define([m4_bmatch],
d426 2
a427 14
       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shiftn(3, $@@))],
	      [$3])])])


# m4_map(MACRO, LIST)
# -------------------
# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements
# of LIST (which can be lists themselves, for multiple arguments MACROs).
m4_define([m4_fst], [$1])
m4_define([m4_map],
[m4_if([$2], [[]], [],
       [$1(m4_fst($2))[]dnl
m4_map([$1], m4_cdr($2))])])

a428 12
# m4_map_sep(MACRO, SEPARATOR, LIST)
# ----------------------------------
# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1, $2... $N
# are the elements of LIST (which can be lists themselves, for multiple
# arguments MACROs).
m4_define([m4_map_sep],
[m4_if([$3], [[]], [],
       [$1(m4_fst($3))[]dnl
m4_if(m4_cdr($3),
      [[]], [],
      [$2])[]dnl
m4_map_sep([$1], [$2], m4_cdr($3))])])
a434 24
# m4_patsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
# ---------------------------------------------------
# m4 equivalent of
#
#   $_ = STRING;
#   s/RE1/SUBST1/g;
#   s/RE2/SUBST2/g;
#   ...
#
# All the values are optional, and the macro is robust to active symbols
# properly quoted.
#
# I would have liked to name this macro `m4_patsubst', unfortunately,
# due to quotation problems, I need to double quote $1 below, therefore
# the anchors are broken :(  I can't let users be trapped by that.
m4_define([m4_bpatsubsts],
[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
       [$#], 2, [m4_builtin([patsubst], $@@)],
       [$0(m4_builtin([patsubst], [[$1]], [$2], [$3]),
	   m4_shiftn(3, $@@))])])



d439 1
a439 1
# unnecessary dnl's and have the macros indented properly.
a445 7
# m4_define_default(MACRO, VALUE)
# -------------------------------
# If MACRO is undefined, set it to VALUE.
m4_define([m4_define_default],
[m4_ifndef([$1], [m4_define($@@)])])


d459 1
a459 1
	   [m4_fatal([$0: undefined macro: $1])])dnl
d467 1
a467 1
	  [m4_pushdef([_m4_dumpdefs], m4_defn([$1]))dnl
d477 1
a477 1
	  [m4_pushdef([$1], m4_defn([_m4_dumpdefs]))dnl
d497 1
a497 1
	   [m4_fatal([$0: undefined macro: $1])])dnl
d501 3
a503 3
# m4_quote(ARGS)
# --------------
# Return ARGS as a single arguments.
d509 2
a510 2
m4_define([m4_quote],  [[$*]])
m4_define([m4_dquote],  [[$@@]])
d542 1
a542 1
	   [m4_fatal([$0: undefined macro: $1])])dnl
d557 2
a558 2
	 1, [m4_assert(m4_sign(m4_default($4, 1)) == 1)],
	-1, [m4_assert(m4_sign(m4_default($4, -1)) == -1)])dnl
d578 1
a578 1
# which leads to undesirable expansions.
d587 2
a588 2
# |	       [m4_if([$2], [()], ,
# |		     [m4_define([$1], _arg1$2)$3[]_foreach([$1],
d618 1
a618 1
# |	     [m4_define([$1], [_arg1$2])$3[]_foreach([$1],
d643 1
a643 1
# |	     [m4_define([$1], [_arg1($2)])$3[]_foreach([$1],
d675 1
a675 2
m4_define([m4_car], [[$1]])
m4_define([m4_cdr], [m4_dquote(m4_shift($@@))])
d677 4
a680 4
[m4_if([$2], [[]], [],
       [m4_define([$1], m4_car($2))$3[]_m4_foreach([$1],
						   m4_cdr($2),
						   [$3])])])
d695 2
a696 2
	  [m4_indir([_m4_divert($1)])],
	  [$1])])
d707 1
a707 1
	   m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
d718 1
a718 1
	    m4_location[: $0: $1]m4_ifdef([m4_divert_stack], [
d732 1
a732 2
	    [m4_fatal([$0($1): diversion mismatch: ]
m4_defn([m4_divert_stack]))])])dnl
d737 2
a738 2
	   m4_ifdef([_m4_divert_diversion],
		    [_m4_divert(_m4_divert_diversion)], -1))dnl
d769 2
d792 1
a792 1
# prepare the expansion of the macro and its dependencies (by Franc,ois
d814 4
a817 4
#	   GROW - 2: Test...3
#	   GROW - 1: Test...2
#	   GROW:     Test...1
#	   BODY:
d822 4
a825 4
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:        Test...3; Test...2; Test...1
d849 4
a852 4
#		 3 --- 2b
#		/        \              is m4_require'd by
#	       /          \       left -------------------- right
#	    2a ------------ 1
d856 4
a859 4
#	   GROW - 2: TEST3
#	   GROW - 1: TEST2a; TEST2b
#	   GROW:     TEST1
#	   BODY:
d866 4
a869 4
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:        TEST3; TEST2a; TEST2b; TEST1
d887 4
a890 4
#	   GROW - 2:
#	   GROW - 1: TEST2a
#	   GROW:     Elaboration of TEST1
#	   BODY:
d894 4
a897 4
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a
d902 4
a905 4
#	   GROW - 2: TEST3
#	   GROW - 1: Elaboration of TEST2b
#	   GROW:     Elaboration of TEST1
#	   BODY:      TEST2a
d909 4
a912 4
#	   GROW - 2:
#	   GROW - 1: Elaboration of TEST2b
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a; TEST3
d916 4
a919 4
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:     Elaboration of TEST1
#	   BODY:     TEST2a; TEST3; TEST2b
d923 4
a926 4
#	   GROW - 2:
#	   GROW - 1:
#	   GROW:
#	   BODY:     TEST2a; TEST3; TEST2b: TEST1
d939 2
a940 2
#	    AC_INIT
#	    TEST1
d1108 1
a1108 1
	    [$1]m4_ifdef([m4_expansion_stack], [
d1124 1
a1124 1
	  [m4_errprintn(m4_defn([m4_expansion_stack]))])dnl
d1154 2
a1155 2
	 [m4_divert_push(m4_defn([_m4_divert_diversion]))],
	 [m4_copy([_m4_divert_diversion], [_m4_divert_dump])dnl
d1188 1
a1188 1
	  [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])
d1198 3
a1200 3
	  [m4_provide_if([$1],
			 [m4_warn([syntax], [$1 invoked multiple times])],
			 [_m4_defun_pro([$1])$2[]_m4_defun_epi([$1])])])])
d1203 2
a1204 2
# m4_pattern_forbid(ERE, [WHY])
# -----------------------------
d1207 2
a1208 1
m4_define([m4_pattern_forbid], [])
d1214 2
a1215 2
# Both used via traces.
m4_define([m4_pattern_allow], [])
d1226 2
a1227 2
[m4_provide_if([$2],
	       [m4_warn([syntax], [$2 was called before $1])])])
d1265 1
a1265 1
	 [m4_fatal([$0: circular dependency of $1])])dnl
d1267 4
a1270 4
	  [m4_fatal([$0: cannot be used outside of an m4_defun'd macro])])dnl
m4_provide_if([$1],
	      [],
	      [m4_divert_push(m4_eval(m4_divnum - 1))dnl
d1275 4
a1278 4
m4_provide_if([$1],
	      [],
	      [m4_warn([syntax],
		       [$1 is m4_require'd but is not m4_defun'd])])dnl
d1288 3
a1290 3
[m4_provide_if(m4_ifval([$2], [[$2]], [[$1]]),
	       [],
	       [m4_provide(m4_ifval([$2], [[$2]], [[$1]]))[]$1])])
d1299 2
a1300 2
# m4_provide_if(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
# -------------------------------------------------------
d1305 1
a1305 1
m4_define([m4_provide_if],
d1307 1
a1307 1
	  [$2], [$3])])
a1313 1

a1324 1

a1341 8
# m4_re_escape(STRING)
# --------------------
# Escape BRE active characters in STRING.
m4_define([m4_re_escape],
[m4_bpatsubst([$1],
	      [[][+*.]], [\\\&])])


d1346 1
a1346 1
m4_defn([m4_cr_symbols2])dnl
d1355 1
a1355 1
m4_defn([m4_cr_symbols1])dnl
a1358 1

d1364 4
a1367 1
[m4_translit([$1], m4_defn([m4_cr_LETTERS]), m4_defn([m4_cr_letters]))])
d1369 3
a1371 1
[m4_translit([$1], m4_defn([m4_cr_letters]), m4_defn([m4_cr_LETTERS]))])
d1403 3
a1405 3
m4_bpatsubst(````$1'''',
	     m4_if(``$2'',, ``[	 ]+'', ``$2''),
	     ``], ['')]dnl
d1422 1
a1422 1
[m4_translit(m4_bpatsubst([[[$1]]], [\\
d1434 1
a1434 1
#    m4_strip([  active 	 	active ])end
d1442 6
a1447 5
# Then notice the 2 last patterns: they are in charge of removing the
# leading/trailing spaces.  Why not just `[^ ]'?  Because they are
# applied to doubly quoted strings, i.e. more or less [[STRING]].  So
# if there is a leading space in STRING, then it is the *third*
# character, since there are two leading `['; equally for the last pattern.
d1449 4
a1452 4
[m4_bpatsubsts([[$1]],
	       [[	 ]+], [ ],
	       [^\(..\) ],    [\1],
	       [ \(..\)$],    [\1])])
d1477 3
a1479 3
	 [1], [],
	 [2], [[$2]],
	 [[$2][$1]$0([$1], m4_shiftn(2, $@@))])])
d1483 4
a1486 6
# m4_append(MACRO-NAME, STRING, [SEPARATOR])
# ------------------------------------------
# Redefine MACRO-NAME to hold its former content plus `SEPARATOR`'STRING'
# at the end.  It is valid to use this macro with MACRO-NAME undefined,
# in which case no SEPARATOR is added.  Be aware that the criterion is
# `not being defined', and not `not being empty'.
d1515 9
a1523 1
	   m4_ifdef([$1], [m4_defn([$1])$3])[$2])])
d1526 14
a1539 8
# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR])
# -----------------------------------------------
# As `m4_append', but append only if not yet present.
m4_define([m4_append_uniq],
[m4_ifdef([$1],
	  [m4_bmatch([$3]m4_defn([$1])[$3], m4_re_escape([$3$2$3]), [],
		     [m4_append($@@)])],
	  [m4_append($@@)])])
d1568 2
a1569 2
#  =>      Super long
#  =>      documentation.
d1589 2
a1590 2
m4_foreach([m4_Word], m4_quote(m4_split(m4_normalize([$1]))),
[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_len(m4_defn([m4_Word])) + 1))dnl
d1595 1
a1595 1
		    m4_eval(m4_len(m4_Prefix) + m4_len(m4_defn([m4_Word])) + 1))]
d1598 1
a1598 1
m4_defn([m4_Word])[]dnl
a1607 9
# m4_text_box(MESSAGE, [FRAME-CHARACTER = `-'])
# ---------------------------------------------
m4_define([m4_text_box],
[@@%:@@@@%:@@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @@%:@@@@%:@@
@@%:@@@@%:@@ $1 @@%:@@@@%:@@
@@%:@@@@%:@@ m4_bpatsubst([$1], [.], m4_if([$2], [], [[-]], [[$2]])) @@%:@@@@%:@@[]dnl
])


d1618 4
a1621 4
[m4_bmatch([$1],
	   [^-], -1,
	   [^0+], 0,
		  1)])
d1647 2
a1648 2
       [$1], [()], [$0((0), [$2])],
       [$2], [()], [$0([$1], (0))],
d1650 3
a1652 3
		-1, -1,
		 1, 1,
		 0, [$0((m4_shift$1), (m4_shift$2))])])])
d1671 9
a1679 9
[m4_translit(m4_bpatsubsts([$1],
			   [\([0-9]+\)\([abcdefghi]\)],
			     [m4_eval(\1 + 1).-1.\2],
			   [\([0-9]+\)\([jklmnopqrs]\)],
			     [m4_eval(\1 + 1).-1.1\2],
			   [\([0-9]+\)\([tuvwxyz]\)],
			     [m4_eval(\1 + 1).-1.2\2]),
	     [abcdefghijklmnopqrstuvwxyz],
	     [12345678901234567890123456])])
d1690 1
a1690 22
	     (m4_split(m4_version_unletter([$2]), [\.])))])


# m4_PACKAGE_NAME
# m4_PACKAGE_TARNAME
# m4_PACKAGE_VERSION
# m4_PACKAGE_STRING
# m4_PACKAGE_BUGREPORT
# --------------------
m4_include([m4sugar/version.m4])


# m4_version_prereq(VERSION, [IF-OK], [IF-NOT = FAIL])
# ----------------------------------------------------
# Check this Autoconf version against VERSION.
m4_define([m4_version_prereq],
[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]), [$1]), -1,
       [m4_default([$3],
		   [m4_fatal([Autoconf version $1 or higher is required],
			     63)])],
       [$2])[]dnl
])
d1724 7
a1730 3
[# All the M4sugar macros start with `m4_', except `dnl' kept as is
# for sake of simplicity.
m4_pattern_forbid([^_?m4_])
d1735 1
a1735 1
		  [m4_fatal([$0: unbalanced m4_divert_push:]
@


1.1.101.2
log
@this is what will be (99% sure) in autoconf 2.60, due next weekend
@
text
@d6 2
a7 2
# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software
# Foundation, Inc.
d21 2
a22 2
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
d63 1
a63 1
set the M4 environment variable to its absolute file name.)
d88 2
a89 2
# 2. m4_define([to], [from($@@)])
# Well, obviously 1 is more expensive in space.  Maybe 2 is more expensive
d93 1
a93 1
# The user will certainly prefer to see `to'.
d136 1
a136 1
m4_undefine([include])
d149 1
a149 1
m4_undefine([sinclude])
d325 1
a325 1
	  [m4_ifval(m4_defn([$1]), [$2], [$3])],
d377 2
a378 2
[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
a383 11
# m4_car(LIST)
# m4_cdr(LIST)
# ------------
# Manipulate m4 lists.
m4_define([m4_car], [[$1]])
m4_define([m4_cdr],
[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
       [$#], 1, [],
       [m4_dquote(m4_shift($@@))])])


d391 2
a392 4
       [_m4_map([$1], [$2])])])
m4_define([_m4_map],
[m4_ifval([$2],
	  [$1(m4_fst($2))[]_m4_map([$1], m4_cdr($2))])])
d402 5
a406 1
       [$1(m4_fst($3))[]_m4_map([$2[]$1], m4_cdr($3))])])
d413 2
a414 2
# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
# ----------------------------------------------------
d425 1
a425 1
# I would have liked to name this macro `m4_bpatsubst', unfortunately,
d565 7
a571 12
[m4_pushdef([$1], m4_eval([$2]))dnl
m4_if(m4_eval(([$3]) > $1), 1,
[m4_pushdef([_m4_step], m4_eval(m4_default([$4], 1)))dnl
m4_assert(_m4_step > 0)dnl
_m4_for([$1], m4_eval((([$3]) - $1) / _m4_step * _m4_step + $1), _m4_step, [$5])],
      m4_eval(([$3]) < $1), 1,
[m4_pushdef([_m4_step], m4_eval(m4_default([$4], -1)))dnl
m4_assert(_m4_step < 0)dnl
_m4_for([$1], m4_eval(($1 - ([$3])) / -(_m4_step) * _m4_step + $1), _m4_step, [$5])],
      [m4_pushdef(_m4_step,[])dnl
$5])[]dnl
m4_popdef([_m4_step])dnl
d575 3
a577 3
# _m4_for(VARIABLE, LAST, STEP, EXPRESSION)
# -----------------------------------------
# Core of the loop, no consistency checks, all arguments are plain numbers.
d683 3
d687 4
a690 18
[m4_ifval([$2],
	  [m4_define([$1], m4_car($2))$3[]dnl
_m4_foreach([$1], m4_cdr($2), [$3])])])


# m4_foreach_w(VARIABLE, LIST, EXPRESSION)
# ----------------------------------------
#
# Like m4_foreach, but the list is whitespace separated.
#
# This macro is robust to active symbols:
#    m4_foreach_w([Var], [ active
#    b	act\
#    ive  ], [-Var-])end
#    => -active--b--active-end
#
m4_define([m4_foreach_w],
[m4_foreach([$1], m4_split(m4_normalize([$2])), [$3])])
d702 1
a702 1
# otherwise if it is a NUMBER return it.
a711 8
# _m4_divert_n_stack
# ------------------
# Print m4_divert_stack with newline prepended, if it's nonempty.
m4_define([_m4_divert_n_stack],
[m4_ifdef([m4_divert_stack], [
m4_defn([m4_divert_stack])])])


d716 3
a718 1
[m4_define([m4_divert_stack], m4_location[: $0: $1]_m4_divert_n_stack)dnl
d727 3
a729 1
[m4_pushdef([m4_divert_stack], m4_location[: $0: $1]_m4_divert_n_stack)dnl
d731 1
a731 1
m4_builtin([divert], _m4_divert([$1]))dnl
a738 1
# When we pop the last value from the stack, we divert to -1.
d740 4
a743 6
[m4_ifndef([_m4_divert_diversion],
           [m4_fatal([too many m4_divert_pop])])dnl
m4_if([$1], [], [],
      [$1], m4_defn([_m4_divert_diversion]), [],
      [m4_fatal([$0($1): diversion mismatch: ]_m4_divert_n_stack)])dnl
m4_popdef([m4_divert_stack])dnl
d745 2
d749 2
a750 2
		    [_m4_divert(m4_defn([_m4_divert_diversion]))],
		    -1))dnl
d937 1
a937 1
# The idea is simple, but the implementation is a bit evolved.  If you
d954 1
a954 1
# This implements tries not to assume that the current diversion is
d959 1
a959 1
# are not inside an m4_defun'd macro, and especially, you cannot
d974 1
a974 1
# The prologue of TEST1 sets _m4_divert_dump, which is the diversion
d978 19
d998 1
a998 8
#   BODY:        empty
#   diversions:  GROW, BODY |-
#
# * TEST1 requires TEST2a
# _m4_require_call m4_divert_pushes another temporary diversion,
# GROW - 1, and expands TEST2a in there.
#   DUMP:        BODY
#   BODY:        empty
a1000 5
# Than the content of the temporary diversion is moved to DUMP and the
# temporary diversion is popped.
#   DUMP:        BODY
#   BODY:        TEST2a
#   diversions:  GROW, BODY |-
d1002 60
a1061 29
# * TEST1 requires TEST2b
# Again, _m4_require_call pushes GROW - 1 and heads to expand TEST2b.
#   DUMP:        BODY
#   BODY:        TEST2a
#   diversions:  GROW - 1, GROW, BODY |-
#
# * TEST2b requires TEST3
# _m4_require_call pushes GROW - 2 and expands TEST3 here.
# (TEST3 requires TEST2a, but TEST2a has already been m4_provide'd, so
# nothing happens.)
#   DUMP:        BODY
#   BODY:        TEST2a
#   GROW - 2:    TEST3
#   diversions:  GROW - 2, GROW - 1, GROW, BODY |-
# Than the diversion is appended to DUMP, and popped.
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3
#   diversions:  GROW - 1, GROW, BODY |-
#
# * TEST1 requires TEST2b (contd.)
# The content of TEST2b is expanded...
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3
#   GROW - 1:    TEST2b,
#   diversions:  GROW - 1, GROW, BODY |-
# ... and moved to DUMP.
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3; TEST2b
#   diversions:  GROW, BODY |-
d1064 8
a1071 6
# TEST1's own content is in GROW...
#   DUMP:        BODY
#   BODY:        TEST2a; TEST3; TEST2b
#   GROW:        TEST1
#   diversions:  BODY |-
# ... and it's epilogue moves it to DUMP and then undefines DUMP.
d1093 18
a1110 3
# In addition, we want to detect circular m4_require dependencies.
# Each time we expand a macro FOO we define _m4_expanding(FOO); and
# m4_require(BAR) simply checks whether _m4_expanding(BAR) is defined.
d1123 1
d1160 1
a1160 2
[m4_ifndef([m4_expansion_stack], [_m4_defun_pro_outer[]])dnl
m4_expansion_stack_push(m4_defn([m4_location($1)])[: $1 is expanded from...])dnl
d1162 4
a1167 4
m4_define([_m4_defun_pro_outer],
[m4_copy([_m4_divert_diversion], [_m4_divert_dump])dnl
m4_divert_push([GROW])dnl
])
d1174 4
a1177 1
[m4_popdef([_m4_expanding($1)])dnl
d1179 1
a1179 1
m4_ifndef([m4_expansion_stack], [_m4_defun_epi_outer[]])dnl
a1182 6
m4_define([_m4_defun_epi_outer],
[m4_undefine([_m4_divert_dump])dnl
m4_divert_pop([GROW])dnl
m4_undivert([GROW])dnl
])

d1271 2
a1272 1
[m4_ifdef([_m4_expanding($1)],
d1275 1
a1275 2
	  [m4_fatal([$0($1): cannot be used outside of an ]dnl
m4_bmatch([$0], [^AC_], [[AC_DEFUN]], [[m4_defun]])['d macro])])dnl
d1278 1
a1278 10
	      [_m4_require_call([$1], [$2])])dnl
])


# _m4_require_call(BODY-TO-EXPAND)
# --------------------------------
# If m4_require decides to expand the body, it calls this macro.
m4_define([_m4_require_call],
[m4_define([_m4_divert_grow], m4_decr(_m4_divert_grow))dnl
m4_divert_push(_m4_divert_grow)dnl
d1280 3
d1286 2
a1287 5
		       [$1 is m4_require'd but not m4_defun'd])])dnl
m4_divert(m4_defn([_m4_divert_dump]))dnl
m4_undivert(_m4_divert_grow)dnl
m4_divert_pop(_m4_divert_grow)dnl
m4_define([_m4_divert_grow], m4_incr(_m4_divert_grow))dnl
a1290 6
# _m4_divert_grow
# ---------------
# The counter for _m4_require_call.
m4_define([_m4_divert_grow], _m4_divert([GROW]))


d1354 1
a1354 1
# Escape RE active characters in STRING.
d1357 1
a1357 1
	      [[][*+.?\^$]], [\\\&])])
a1362 1
# m4_dquote provides literal [] for the character class.
d1364 1
a1364 1
m4_dquote(m4_defn([m4_cr_symbols2]))dnl
d1373 1
a1373 1
m4_dquote(m4_defn([m4_cr_symbols1]))dnl
d1397 5
a1401 5
# If STRING is empty, the result is an empty list.
#
# Pay attention to the m4_changequotes.  When m4 reads the definition of
# m4_split, it still has quotes set to [ and ].  Luckily, these are matched
# in the macro body, so the definition is stored correctly.
d1412 3
a1414 5
m4_define([m4_split],
[m4_ifval([$1], [_m4_split($@@)])])

m4_define([_m4_split],
[m4_changequote(``, '')dnl
d1420 2
a1421 1
m4_changequote([, ])])
d1448 1
a1448 1
#    m4_strip([  active <tab> <tab>active ])end
d1451 4
a1454 1
# Because we want to preserve active symbols, STRING must be double-quoted.
d1546 4
a1549 4
# If PREFIX is given, each line is prefixed with it.  If FIRST-PREFIX is
# specified, then the first line is prefixed with it.  As a special case,
# if the length of FIRST-PREFIX is greater than that of PREFIX, then
# FIRST-PREFIX will be left alone on the first line.
d1581 1
a1581 1
[m4_pushdef([m4_Prefix], [$2])dnl
d1584 1
a1584 1
m4_pushdef([m4_Cursor], m4_qlen(m4_Prefix1))dnl
d1587 1
a1587 1
m4_if(m4_eval(m4_qlen(m4_Prefix1) > m4_len(m4_Prefix)),
d1589 3
a1591 9
m4_Prefix],
      m4_if(m4_eval(m4_qlen(m4_Prefix1) < m4_len(m4_Prefix)),
	    [0], [],
	    [m4_define([m4_Cursor], m4_len(m4_Prefix))[]dnl
m4_for(m4_Space, m4_qlen(m4_Prefix1), m4_eval(m4_len(m4_Prefix) - 1),
		    [], [ ])])[]dnl
)[]dnl
m4_foreach_w([m4_Word], [$1],
[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_qlen(m4_defn([m4_Word])) + 1))dnl
d1596 1
a1596 1
		    m4_eval(m4_len(m4_Prefix) + m4_qlen(m4_defn([m4_Word])) + 1))]
a1617 15
# m4_qlen(STRING)
# ---------------
# Expands to the length of STRING after autom4te converts all quadrigraphs.
m4_define([m4_qlen],
[m4_len(m4_bpatsubsts([[$1]], [@@\(<:\|:>\|S|\|%:\)@@], [P], [@@&t@@]))])


# m4_qdelta(STRING)
# -----------------
# Expands to the net change in the length of STRING from autom4te converting the
# quadrigraphs in STRING.  This number is always negative or zero.
m4_define([m4_qdelta],
[m4_eval(m4_qlen([$1]) - m4_len([$1]))])


d1762 2
a1763 1
	   [m4_fatal([$0: unbalanced m4_divert_push:]_m4_divert_n_stack)])[]])
@


1.1.101.3
log
@from autoconf 2.60 (release)
@
text
@a1772 3
# _m4_divert_diversion should be defined:
m4_divert_push([KILL])

d1774 1
a1774 2
m4_wrap([m4_divert_pop([])
	 m4_ifdef([_m4_divert_diversion],
d1776 3
@


1.1.101.4
log
@merge from upstream via
cvs -d :pserver:anonymous@@pserver.git.sv.gnu.org:/autoconf.git co -PA HEAD
@
text
@d6 2
a7 2
# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
# 2008 Free Software Foundation, Inc.
d9 1
a9 1
# This program is free software: you can redistribute it and/or modify
d93 1
a93 1
# The user would certainly prefer to see `to'.
d100 1
a100 1
# Rename the macro SRC to DST.
d107 1
a107 1
# Rename MACRO-NAME to m4_MACRO-NAME.
d114 1
a114 1
# Copy m4_MACRO-NAME to MACRO-NAME.
a123 1
m4_undefine([changeword])
d142 2
a143 7
m4_undefine([m4wrap])
m4_ifdef([mkstemp],dnl added in M4 1.4.8
[m4_rename_m4([mkstemp])
m4_copy([m4_mkstemp], [m4_maketemp])
m4_undefine([maketemp])],
[m4_rename_m4([maketemp])
m4_copy([m4_maketemp], [m4_mkstemp])])
a214 3
#
# Within m4, the macro is a no-op.  This macro really matters
# when autom4te post-processes the trace output.
d224 1
a224 1
	 [m4_defn([m4_expansion_stack])
d237 2
a238 2
# several times.  This is, in general, a dangerous operation, because
# too many people forget to quote the first argument of m4_define.
d258 1
a258 1
# Like the builtin include, but warns against multiple inclusions.
d266 1
a266 1
# Like the builtin sinclude, but warns against multiple inclusions.
d280 1
a280 1
# In case of arguments of macros, eg. $1, it makes little difference.
d286 1
a286 1
# So you want the variation `m4_ifset' that expects a macro name as $1.
d288 1
a288 1
# it runs TRUE, etc.
d358 1
a358 1
       [$0([$1], m4_shift3($@@))])])
d380 1
a380 1
       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shift3($@@))],
a393 10
# _m4_cdr(LIST)
# -------------
# Like m4_cdr, except include a leading comma unless only one element
# remains.  Why?  Because comparing a large list against [] is more
# expensive in expansion time than comparing the number of arguments; so
# _m4_cdr can be used to reduce the number of arguments when it is time
# to end recursion.
m4_define([_m4_cdr],
[m4_if([$#], 1, [],
       [, m4_dquote(m4_shift($@@))])])
d395 11
d408 8
a415 34
# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
# -------------------------------------------------------------------
# Similar to m4_if, except that each TEST is expanded when encountered.
# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
# The result is DEFAULT if no tests passed.  This macro allows
# short-circuiting of expensive tests, where it pays to arrange quick
# filter tests to run first.
#
# For an example, consider a previous implementation of _AS_QUOTE_IFELSE:
#
#    m4_if(m4_index([$1], [\]), [-1], [$2],
#          m4_eval(m4_index([$1], [\\]) >= 0), [1], [$2],
#          m4_eval(m4_index([$1], [\$]) >= 0), [1], [$2],
#          m4_eval(m4_index([$1], [\`]) >= 0), [1], [$3],
#          m4_eval(m4_index([$1], [\"]) >= 0), [1], [$3],
#          [$2])
#
# Here, m4_index is computed 5 times, and m4_eval 4, even if $1 contains
# no backslash.  It is more efficient to do:
#
#    m4_cond([m4_index([$1], [\])], [-1], [$2],
#            [m4_eval(m4_index([$1], [\\]) >= 0)], [1], [$2],
#            [m4_eval(m4_index([$1], [\$]) >= 0)], [1], [$2],
#            [m4_eval(m4_index([$1], [\`]) >= 0)], [1], [$3],
#            [m4_eval(m4_index([$1], [\"]) >= 0)], [1], [$3],
#            [$2])
#
# In the common case of $1 with no backslash, only one m4_index expansion
# occurs, and m4_eval is avoided altogether.
m4_define([m4_cond],
[m4_if([$#], [0], [m4_fatal([$0: cannot be called without arguments])],
       [$#], [1], [$1],
       [$#], [2], [m4_fatal([$0: missing an argument])],
       [m4_if($1, [$2], [$3], [$0(m4_shift3($@@))])])])
a436 3
#
# Recall that m4_shift3 always results in an argument.  Hence, we need
# to distinguish between a final deletion vs. ending recursion.
d440 1
a440 4
       [$#], 2, [m4_builtin([patsubst], [$1], [$2])],
       [_$0($@@m4_if(m4_eval($# & 1), 0, [,]))])])
m4_define([_m4_bpatsubsts],
[m4_if([$#], 2, [$1],
d442 13
a454 1
	   m4_shift3($@@))])])
a466 3
#
# This macro is called on hot paths, so inline the contents of m4_ifval,
# for one less round of expansion.
d468 1
a468 1
[m4_if([$1], [], [$2], [$1])])
d473 2
a474 5
# Like the original, except don't tolerate popping something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
d476 3
a478 3
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([defn], [$1])])
d511 2
a512 5
# Like the original, except don't tolerate popping something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
d514 3
a516 3
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([popdef], [$1])])
d519 3
a521 3
# m4_shiftn(N, ...)
# -----------------
# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
d523 5
a527 113
# Autoconf does not use this macro, because it is inherently slower than
# calling the common cases of m4_shift2 or m4_shift3 directly.  But it
# might as well be fast for other clients, such as Libtool.  One way to
# do this is to expand $@@ only once in _m4_shiftn (otherwise, for long
# lists, the expansion of m4_if takes twice as much memory as what the
# list itself occupies, only to throw away the unused branch).  The end
# result is strictly equivalent to
#   m4_if([$1], 1, [m4_shift(,m4_shift(m4_shift($@@)))],
#         [_m4_shiftn(m4_decr([$1]), m4_shift(m4_shift($@@)))])
# but with the final `m4_shift(m4_shift($@@)))' shared between the two
# paths.  The first leg uses a no-op m4_shift(,$@@) to balance out the ().
m4_define([m4_shiftn],
[m4_assert(0 < $1 && $1 < $#)_$0($@@)])

m4_define([_m4_shiftn],
[m4_if([$1], 1, [m4_shift(],
       [$0(m4_decr([$1])]), m4_shift(m4_shift($@@)))])

# m4_shift2(...)
# m4_shift3(...)
# -----------------
# Returns ... shifted twice, and three times.  Faster than m4_shiftn.
m4_define([m4_shift2], [m4_shift(m4_shift($@@))])
m4_define([m4_shift3], [m4_shift(m4_shift(m4_shift($@@)))])

# _m4_shift2(...)
# _m4_shift3(...)
# ---------------
# Like m4_shift2 or m4_shift3, except include a leading comma unless shifting
# consumes all arguments.  Why?  Because in recursion, it is nice to
# distinguish between 1 element left and 0 elements left, based on how many
# arguments this shift expands to.
m4_define([_m4_shift2],
[m4_if([$#], [2], [],
       [, m4_shift(m4_shift($@@))])])
m4_define([_m4_shift3],
[m4_if([$#], [3], [],
       [, m4_shift(m4_shift(m4_shift($@@)))])])


# m4_undefine(NAME)
# -----------------
# Like the original, except don't tolerate undefining something which is
# undefined, and only support one argument.
#
# This macro is called frequently, so minimize the amount of additional
# expansions by skipping m4_ifndef.
m4_define([m4_undefine],
[m4_ifdef([$1], [],
	  [m4_fatal([$0: undefined macro: $1])])]dnl
[m4_builtin([undefine], [$1])])

# _m4_wrap(PRE, POST)
# -------------------
# Helper macro for m4_wrap and m4_wrap_lifo.  Allows nested calls to
# m4_wrap within wrapped text.
# Skip m4_defn and m4_popdef for speed.
m4_define([_m4_wrap],
[m4_ifdef([$0_text],
	  [m4_define([$0_text], [$1]m4_builtin([defn], [$0_text])[$2])],
	  [m4_builtin([m4wrap], [m4_unquote(m4_builtin([defn],
  [$0_text])m4_builtin([popdef], [$0_text]))])m4_define([$0_text], [$1$2])])])

# m4_wrap(TEXT)
# -------------
# Append TEXT to the list of hooks to be executed at the end of input.
# Whereas the order of the original may be LIFO in the underlying m4,
# this version is always FIFO.
m4_define([m4_wrap],
[_m4_wrap([], [$1[]])])

# m4_wrap_lifo(TEXT)
# ------------------
# Prepend TEXT to the list of hooks to be executed at the end of input.
# Whereas the order of m4_wrap may be FIFO in the underlying m4, this
# version is always LIFO.
m4_define([m4_wrap_lifo],
[_m4_wrap([$1[]])])

## ------------------------- ##
## 7. Quoting manipulation.  ##
## ------------------------- ##


# m4_apply(MACRO, LIST)
# ---------------------
# Invoke MACRO, with arguments provided from the quoted list of
# comma-separated quoted arguments.  If LIST is empty, invoke MACRO
# without arguments.
m4_define([m4_apply],
[m4_if([$2], [], [$1], [$1($2)])[]])


# m4_count(ARGS)
# --------------
# Return a count of how many ARGS are present.
m4_define([m4_count], [$#])


# m4_do(STRING, ...)
# ------------------
# This macro invokes all its arguments (in sequence, of course).  It is
# useful for making your macros more structured and readable by dropping
# unnecessary dnl's and have the macros indented properly.
m4_define([m4_do],
[m4_if([$#], 0, [],
       [$#], 1, [$1],
       [$1[]m4_do(m4_shift($@@))])])


# m4_dquote(ARGS)
# ---------------
# Return ARGS as a quoted list of quoted arguments.
a530 61
# m4_dquote_elt(ARGS)
# -------------------
# Return ARGS as an unquoted list of double-quoted arguments.
m4_define([m4_dquote_elt],
[m4_if([$#], [0], [],
       [$#], [1], [[[$1]]],
       [[[$1]],$0(m4_shift($@@))])])


# m4_echo(ARGS)
# -------------
# Return the ARGS, with the same level of quoting.  Whitespace after
# unquoted commas are consumed.
m4_define([m4_echo], [$@@])


# m4_expand(ARG)
# --------------
# Return the expansion of ARG as a single string.  Unlike m4_quote($1), this
# correctly preserves whitespace following single-quoted commas that appeared
# within ARG.
#
#   m4_define([active], [ACT, IVE])
#   m4_define([active2], [[ACT, IVE]])
#   m4_quote(active, active2)
#   => ACT,IVE,ACT, IVE
#   m4_expand([active, active2])
#   => ACT, IVE, ACT, IVE
#
# Unfortunately, due to limitations in m4, ARG must expand to something
# with balanced quotes (use quadrigraphs to get around this).  The input
# is not likely to have unbalanced -=<{(/)}>=- quotes, and it is possible
# to have unbalanced (), provided it was specified with proper [] quotes.
#
# Exploit that extra () will group unquoted commas and the following
# whitespace, then convert () to [].  m4_bpatsubst can't handle newlines
# inside $1, and m4_substr strips quoting.  So we (ab)use m4_changequote.
m4_define([m4_expand], [_$0(-=<{($1)}>=-)])
m4_define([_m4_expand],
[m4_changequote([-=<{(], [)}>=-])$1m4_changequote([, ])])


# m4_ignore(ARGS)
# ---------------
# Expands to nothing.  Useful for conditionally ignoring an arbitrary
# number of arguments (see _m4_list_cmp for an example).
m4_define([m4_ignore])


# m4_make_list(ARGS)
# ------------------
# Similar to m4_dquote, this creates a quoted list of quoted ARGS.  This
# version is less efficient than m4_dquote, but separates each argument
# with a comma and newline, rather than just comma, for readability.
# When developing an m4sugar algorithm, you could temporarily use
#   m4_pushdef([m4_dquote],m4_defn([m4_make_list]))
# around your code to make debugging easier.
m4_define([m4_make_list], [m4_join([,
], m4_dquote_elt($@@))])


d534 3
a536 6
# macros it contains.  Amongst other things, this is useful for enabling
# macro invocations inside strings with [] blocks (for instance regexps
# and help-strings).  On the other hand, since all quotes are disabled,
# any macro expanded during this time that relies on nested [] quoting
# will likely crash and burn.  This macro is seldom useful; consider
# m4_unquote or m4_expand instead.
d538 1
a538 1
[m4_changequote([-=<{(],[)}>=-])$1-=<{()}>=-m4_changequote([,])])
d541 6
a546 10
# m4_quote(ARGS)
# --------------
# Return ARGS as a single argument.  Any whitespace after unquoted commas
# is stripped.  There is always output, even when there were no arguments.
#
# It is important to realize the difference between `m4_quote(exp)' and
# `[exp]': in the first case you obtain the quoted *result* of the
# expansion of EXP, while in the latter you just obtain the string
# `exp'.
m4_define([m4_quote],  [[$*]])
d548 4
a552 9
# _m4_quote(ARGS)
# ---------------
# Like m4_quote, except that when there are no arguments, there is no
# output.  For conditional scenarios (such as passing _m4_quote as the
# macro name in m4_map), this feature can be used to distinguish between
# one argument of the empty string vs. no arguments.  However, in the
# normal case with arguments present, this is less efficient than m4_quote.
m4_define([_m4_quote],
[m4_if([$#], [0], [], [[$*]])])
d554 8
a561 8

# m4_unquote(ARGS)
# ----------------
# Remove one layer of quotes from each ARG, performing one level of
# expansion.  For one argument, m4_unquote([arg]) is more efficient than
# m4_do([arg]), but for multiple arguments, the difference is that
# m4_unquote separates arguments with commas while m4_do concatenates.
m4_define([m4_unquote], [$*])
d565 1
a565 1
## 8. Implementing m4 loops.  ##
d571 1
a571 2
# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO with
# increments of STEP.
a572 2
# The algorithm is robust to indirect VARIABLE names, and uses m4_builtin
# to avoid some of the m4_defn overhead.
d575 1
a575 1
m4_cond([m4_eval(([$3]) > m4_builtin([defn], [$1]))], 1,
d578 2
a579 4
_m4_for([$1], m4_eval((([$3]) - m4_builtin([defn], [$1]))
		      / _m4_step * _m4_step + m4_builtin([defn], [$1])),
	_m4_step, [$5])],
	[m4_eval(([$3]) < m4_builtin([defn], [$1]))], 1,
d582 2
a583 4
_m4_for([$1], m4_eval((m4_builtin([defn], [$1]) - ([$3]))
		      / -(_m4_step) * _m4_step + m4_builtin([defn], [$1])),
	_m4_step, [$5])],
	[m4_pushdef([_m4_step])dnl
d594 2
a595 2
m4_if(m4_defn([$1]), [$2], [],
      [m4_define([$1], m4_eval(m4_defn([$1])+[$3]))$0($@@)])])
d599 5
a603 2
# seem.  For example, the old M4 1.4.4 manual had an incorrect example,
# which looked like this (when translated to m4sugar):
d607 1
a607 1
# |   [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
d610 4
a613 2
# |   [m4_if([$2], [()], ,
# |     [m4_define([$1], _arg1$2)$3[]_foreach([$1], (m4_shift$2), [$3])])])
d641 3
a643 1
# |    [m4_define([$1], [_arg1$2])$3[]_foreach([$1], [(m4_shift$2)], [$3])])])
d666 3
a668 1
# |    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1], [m4_shift($2)], [$3])])])
d672 2
a673 13
# to improve robustness, and you come up with a nice implementation
# that doesn't require extra parentheses in the user's LIST.
#
# But wait -  now the algorithm is quadratic, because every recursion of
# the algorithm keeps the entire LIST and merely adds another m4_shift to
# the quoted text.  If the user has a lot of elements in LIST, you can
# bring the system to its knees with the memory m4 then requires, or trip
# the m4 --nesting-limit recursion factor.  The only way to avoid
# quadratic growth is ensure m4_shift is expanded prior to the recursion.
# Hence the design below.
#
# The M4 manual now includes a chapter devoted to this issue, with
# the lessons learned from m4sugar.
a693 8
#
# This macro is called frequently, so avoid extra expansions such as
# m4_ifval and dnl.  Also, since $2 might be quite large, try to use it
# as little as possible in _m4_foreach; each extra use requires that much
# more memory for expansion.  So, rather than directly compare $2 against
# [] and use m4_car/m4_cdr for recursion, we instead unbox the list (which
# requires swapping the argument order in the helper) and use _m4_shift3
# to detect when recursion is complete.
d695 1
a695 1
[m4_pushdef([$1])_$0([$1], [$3]m4_if([$2], [], [], [, $2]))m4_popdef([$1])])
d698 3
a700 2
[m4_if([$#], [2], [],
       [m4_define([$1], [$3])$2[]$0([$1], [$2]_m4_shift3($@@))])])
d715 1
a715 2
[m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])])

a716 24
# m4_map(MACRO, LIST)
# -------------------
# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements
# of LIST.  $1, $2... must in turn be lists, appropriate for m4_apply.
#
# Since LIST may be quite large, we want to minimize how often it appears
# in the expansion.  Rather than use m4_car/m4_cdr iteration, we unbox the
# list, and use _m4_shift2 to detect the end of recursion.
m4_define([m4_map],
[m4_if([$2], [], [],
       [_$0([$1], $2)])])
m4_define([_m4_map],
[m4_if([$#], [1], [],
       [m4_apply([$1], [$2])$0([$1]_m4_shift2($@@))])])


# m4_map_sep(MACRO, SEPARATOR, LIST)
# ----------------------------------
# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1, $2... $N
# are the elements of LIST, and are in turn lists appropriate for m4_apply.
# SEPARATOR is not further expanded.
m4_define([m4_map_sep],
[m4_if([$3], [], [],
       [m4_apply([$1], m4_car($3))m4_map([[$2]$1]_m4_cdr($3))])])
d720 1
a720 1
## 9. More diversion support.  ##
a735 3
# The empty diversion name is a synonym for 0.
m4_define([_m4_divert()],                0)

d771 1
a771 1
	   [m4_fatal([too many m4_divert_pop])])dnl
d797 2
a798 2
# Output CONTENT into DIVERSION-NAME once, if not already there.
# An end of line is appended for free to CONTENT.
d805 1
a805 2
# Undivert DIVERSION-NAME.  Unlike the M4 version, this only takes a single
# diversion identifier, and should not be used to undivert files.
d810 3
a812 3
## --------------------------------------------- ##
## 10. Defining macros with bells and whistles.  ##
## --------------------------------------------- ##
d836 2
a837 2
# The first idea: why use diversions?
# -----------------------------------
d850 1
a850 1
# must keep the expansions of the various levels of m4_require separated.
d913 1
a913 1
# Starting from 2.50, we use an implementation provided by Axel Thimm.
d915 4
a918 4
# same as the one in which macros are expanded.  (The bug above can
# indeed be described as: a macro has been AC_PROVIDE'd before its
# dependent, but it is emitted after: the lack of correlation between
# emission and expansion order is guilty).
d920 1
a920 1
# How to do that?  You keep the stack of diversions to elaborate the
a1089 1
# Use m4_builtin to avoid m4_defn overhead.
d1093 1
a1093 1
m4_builtin([defn], [m4_expansion_stack])]))])
a1132 3
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and m4_defn overhead.
d1134 4
a1137 4
m4_do([[m4_ifdef([m4_expansion_stack], [], [_m4_defun_pro_outer[]])]],
      [[m4_expansion_stack_push(m4_builtin([defn],
	  [m4_location($1)])[: $1 is expanded from...])]],
      [[m4_pushdef([_m4_expanding($1)])]]))
d1140 3
a1142 1
[m4_copy([_m4_divert_diversion], [_m4_divert_dump])m4_divert_push([GROW])])
a1147 3
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and m4_popdef overhead.
d1149 5
a1153 4
m4_do([[m4_builtin([popdef], [_m4_expanding($1)])]],
      [[m4_expansion_stack_pop()]],
      [[m4_ifdef([m4_expansion_stack], [], [_m4_defun_epi_outer[]])]],
      [[m4_provide([$1])]]))
d1156 4
a1159 3
m4_do([[m4_builtin([undefine], [_m4_divert_dump])]],
      [[m4_divert_pop([GROW])]],
      [[m4_undivert([GROW])]]))
d1192 2
a1193 2
# Declare that no token matching the forbidden extended regular
# expression ERE should be seen in the output unless...
d1199 1
a1199 1
# ... that token also matches the allowed extended regular expression ERE.
d1204 3
a1206 3
## --------------------------------- ##
## 11. Dependencies between macros.  ##
## --------------------------------- ##
a1210 1
# Issue a warning if CALLED-MACRO-NAME was called before THIS-MACRO-NAME.
a1247 3
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and other overhead on the common path.
d1249 9
a1257 8
m4_do([[m4_ifdef([_m4_expanding($1)],
		 [m4_fatal([$0: circular dependency of $1])])]],
      [[m4_ifdef([_m4_divert_dump], [],
		 [m4_fatal([$0($1): cannot be used outside of an ]dnl
m4_bmatch([$0], [^AC_], [[AC_DEFUN]], [[m4_defun]])['d macro])])]],
      [[m4_provide_if([$1],
		      [],
		      [_m4_require_call([$1], [$2])])]]))
d1260 2
a1261 2
# _m4_require_call(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
# -----------------------------------------------------------------
a1262 3
#
# This is called frequently, so minimize the number of macro invocations
# by avoiding dnl and other overhead on the common path.
d1264 3
a1266 3
m4_do([[m4_define([_m4_divert_grow], m4_decr(_m4_divert_grow))]],
      [[m4_divert_push(_m4_divert_grow)]],
      [[m4_default([$2], [$1])
d1270 6
a1275 5
		       [$1 is m4_require'd but not m4_defun'd])])]],
      [[m4_divert(m4_builtin([defn], [_m4_divert_dump]))]],
      [[m4_undivert(_m4_divert_grow)]],
      [[m4_divert_pop(_m4_divert_grow)]],
      [[m4_define([_m4_divert_grow], m4_incr(_m4_divert_grow))]]))
d1311 3
a1313 3
## --------------------- ##
## 12. Text processing.  ##
## --------------------- ##
d1333 1
a1333 10
# m4_cr_alnum
# -----------
m4_define([m4_cr_alnum],
m4_defn([m4_cr_Letters])dnl
m4_defn([m4_cr_digits])dnl
)


# m4_cr_symbols1
# m4_cr_symbols2
a1343 53
# m4_cr_all
# ---------
# The character range representing everything, with `-' as the last
# character, since it is special to m4_translit.  Use with care, because
# it contains characters special to M4 (fortunately, both ASCII and EBCDIC
# have [] in order, so m4_defn([m4_cr_all]) remains a valid string).  It
# also contains characters special to terminals, so it should never be
# displayed in an error message.  Also, attempts to map [ and ] to other
# characters via m4_translit must deal with the fact that m4_translit does
# not add quotes to the output.
#
# It is mainly useful in generating inverted character range maps, for use
# in places where m4_translit is faster than an equivalent m4_bpatsubst;
# the regex `[^a-z]' is equivalent to:
#  m4_translit(m4_dquote(m4_defn([m4_cr_all])), [a-z])
m4_define([m4_cr_all],
m4_translit(m4_dquote(m4_format(m4_dquote(m4_for(
  ,1,255,,[[%c]]))m4_for([i],1,255,,[,i]))), [-])-)


# _m4_define_cr_not(CATEGORY)
# ---------------------------
# Define m4_cr_not_CATEGORY as the inverse of m4_cr_CATEGORY.
m4_define([_m4_define_cr_not],
[m4_define([m4_cr_not_$1],
	   m4_translit(m4_dquote(m4_defn([m4_cr_all])),
		       m4_defn([m4_cr_$1])))])


# m4_cr_not_letters
# m4_cr_not_LETTERS
# m4_cr_not_Letters
# m4_cr_not_digits
# m4_cr_not_alnum
# m4_cr_not_symbols1
# m4_cr_not_symbols2
# ------------------
# Inverse character sets
_m4_define_cr_not([letters])
_m4_define_cr_not([LETTERS])
_m4_define_cr_not([Letters])
_m4_define_cr_not([digits])
_m4_define_cr_not([alnum])
_m4_define_cr_not([symbols1])
_m4_define_cr_not([symbols2])


# m4_newline
# ----------
# Expands to a newline.  Exists for formatting reasons.
m4_define([m4_newline], [
])

d1375 1
a1375 3
# These macros convert STRING to lowercase or uppercase.
#
# Rather than expand the m4_defn each time, we inline them up front.
d1377 1
a1377 2
[m4_translit([$1], ]m4_dquote(m4_defn([m4_cr_LETTERS]))[,
		   ]m4_dquote(m4_defn([m4_cr_letters]))[)])
d1379 1
a1379 2
[m4_translit([$1], ]m4_dquote(m4_defn([m4_cr_letters]))[,
		   ]m4_dquote(m4_defn([m4_cr_LETTERS]))[)])
d1395 1
a1395 2
# in the macro body, so the definition is stored correctly.  Use the same
# alternate quotes as m4_noquote; it must be unlikely to appear in $1.
d1399 1
a1399 1
# patsubst is -=<{(STRING)}>=- (i.e., with additional -=<{( and )}>=-).
d1405 1
a1405 5
#
# Optimize on regex of ` ' (space), since m4_foreach_w already guarantees
# that the list contains single space separators, and a common case is
# splitting a single-element list.  This macro is called frequently,
# so avoid unnecessary dnl inside the definition.
d1407 1
a1407 4
[m4_if([$1], [], [],
       [$2], [ ], [m4_if(m4_index([$1], [ ]), [-1], [[[$1]]], [_$0($@@)])],
       [$2], [], [_$0([$1], [[	 ]+])],
       [_$0($@@)])])
d1410 7
a1416 3
[m4_changequote([-=<{(],[)}>=-])]dnl
[[m4_bpatsubst(-=<{(-=<{($1)}>=-)}>=-, -=<{($2)}>=-,
	       -=<{(], [)}>=-)]m4_changequote([, ])])
a1429 2
#
# In m4, m4_bpatsubst is expensive, so first check for a newline.
d1431 1
a1431 3
[m4_if(m4_index([$1], [
]), [-1], [[$1]],
       [m4_translit(m4_bpatsubst([[[$1]]], [\\
d1433 1
a1433 1
], [ ])])])
d1446 1
a1446 4
# First, notice that we guarantee trailing space.  Why?  Because regular
# expressions are greedy, and `.* ?' would always group the space into the
# .* portion.  The algorithm is simpler by avoiding `?' at the end.  The
# algorithm correctly strips everything if STRING is just ` '.
d1448 1
a1448 1
# Then notice the second pattern: it is in charge of removing the
d1450 3
a1452 3
# applied to over-quoted strings, i.e. more or less [STRING], due
# to the limitations of m4_bpatsubsts.  So the leading space in STRING
# is the *second* character; equally for the trailing space.
d1454 1
a1454 1
[m4_bpatsubsts([$1 ],
d1456 2
a1457 1
	       [^. ?\(.*\) .$], [[[\1]]])])
d1479 6
a1484 19
# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
# is the empty string.  No expansion is performed on SEP or ARGs.
#
# Since the number of arguments to join can be arbitrarily long, we
# want to avoid having more than one $@@ in the macro definition;
# otherwise, the expansion would require twice the memory of the already
# long list.  Hence, m4_join merely looks for the first non-empty element,
# and outputs just that element; while _m4_join looks for all non-empty
# elements, and outputs them following a separator.  The final trick to
# note is that we decide between recursing with $0 or _$0 based on the
# nested m4_if ending with `_'.
m4_define([m4_join],
[m4_if([$#], [1], [],
       [$#], [2], [[$2]],
       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift2($@@))])])
m4_define([_m4_join],
[m4_if([$#$2], [2], [],
       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift2($@@))])])

a1485 26
# m4_combine([SEPARATOR], PREFIX-LIST, [INFIX], SUFFIX...)
# --------------------------------------------------------
# Produce the pairwise combination of every element in the quoted,
# comma-separated PREFIX-LIST with every element from the SUFFIX arguments.
# Each pair is joined with INFIX, and pairs are separated by SEPARATOR.
# No expansion occurs on SEPARATOR, INFIX, or elements of either list.
#
# For example:
#   m4_combine([, ], [[a], [b], [c]], [-], [1], [2], [3])
#   => a-1, a-2, a-3, b-1, b-2, b-3, c-1, c-2, c-3
#
# In order to have the correct number of SEPARATORs, we use a temporary
# variable that redefines itself after the first use.  We use m4_builtin
# to avoid m4_defn overhead, but must use defn rather than overquoting
# in case PREFIX or SUFFIX contains $1.  Likewise, we compute the m4_shift3
# only once, rather than in each iteration of the outer m4_foreach.
m4_define([m4_combine],
[m4_if(m4_eval([$# > 3]), [1],
       [m4_pushdef([m4_Separator], [m4_define([m4_Separator],
				    m4_builtin([defn], [m4_echo]))])]]dnl
[[m4_foreach([m4_Prefix], [$2],
	     [m4_foreach([m4_Suffix], ]m4_dquote(m4_dquote(m4_shift3($@@)))[,
			 [m4_Separator([$1])[]m4_builtin([defn],
				      [m4_Prefix])[$3]m4_builtin([defn],
						      [m4_Suffix])])])]]dnl
[[m4_builtin([popdef], [m4_Separator])])])
a1494 3
# Note that neither STRING nor SEPARATOR are expanded here; rather, when
# you expand MACRO-NAME, they will be expanded at that point in time.
#
d1498 4
a1501 4
#    | m4_define(active, ACTIVE)dnl
#    | m4_append([sentence], [This is an])dnl
#    | m4_append([sentence], [ active ])dnl
#    | m4_append([sentence], [symbol.])dnl
d1510 4
a1513 4
#    | m4_define(active, ACTIVE)dnl
#    | m4_append([hooks], [m4_define([act1], [act2])])dnl
#    | m4_append([hooks], [m4_define([act2], [active])])dnl
#    | m4_undefine([active])dnl
a1519 12
#
# It can also be used to create lists, although this particular usage was
# broken prior to autoconf 2.62.
#    | m4_append([list], [one], [, ])dnl
#    | m4_append([list], [two], [, ])dnl
#    | m4_append([list], [three], [, ])dnl
#    | list
#    | m4_dquote(list)
#    => one, two, three
#    => [one],[two],[three]
#
# Use m4_builtin to avoid overhead of m4_defn.
d1522 1
a1522 1
	   m4_ifdef([$1], [m4_builtin([defn], [$1])[$3]])[$2])])
d1525 3
a1527 6
# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR], [IF-UNIQ], [IF-DUP])
# --------------------------------------------------------------------
# Like `m4_append', but append only if not yet present.  Additionally,
# expand IF-UNIQ if STRING was appended, or IF-DUP if STRING was already
# present.  Also, warn if SEPARATOR is not empty and occurs within STRING,
# as the algorithm no longer guarantees uniqueness.
a1528 4
[m4_ifval([$3], [m4_if(m4_index([$2], [$3]), [-1], [],
		       [m4_warn([syntax],
				[$0: `$2' contains `$3'])])])_$0($@@)])
m4_define([_m4_append_uniq],
d1530 3
a1532 13
	  [m4_if(m4_index([$3]m4_builtin([defn], [$1])[$3], [$3$2$3]), [-1],
		 [m4_append([$1], [$2], [$3])$4], [$5])],
	  [m4_append([$1], [$2], [$3])$4])])

# m4_append_uniq_w(MACRO-NAME, STRINGS)
# -------------------------------------
# For each of the words in the whitespace separated list STRINGS, append
# only the unique strings to the definition of MACRO-NAME.
#
# Avoid overhead of m4_defn by using m4_builtin.
m4_define([m4_append_uniq_w],
[m4_foreach_w([m4_Word], [$2],
	      [_m4_append_uniq([$1], m4_builtin([defn], [m4_Word]), [ ])])])
a1542 3
# No expansion occurs on the contents STRING, PREFIX, or FIRST-PREFIX,
# although quadrigraphs are correctly recognized.
#
d1568 4
a1571 11
# This macro does not leave a trailing space behind the last word of a line,
# which complicates it a bit.  The algorithm is otherwise stupid and simple:
# all the words are preceded by m4_Separator which is defined to empty for
# the first word, and then ` ' (single space) for all the others.
#
# The algorithm uses a helper that uses $2 through $4 directly, rather than
# using local variables, to avoid m4_defn overhead, or expansion swallowing
# any $.  It also bypasses m4_popdef overhead with m4_builtin since no user
# macro expansion occurs in the meantime.  Also, the definition is written
# with m4_do, to avoid time wasted on dnl during expansion (since this is
# already a time-consuming macro).
d1573 32
a1604 34
[_$0([$1], [$2], m4_if([$3], [], [[$2]], [[$3]]),
     m4_if([$4], [], [79], [[$4]]))])
m4_define([_m4_text_wrap],
m4_do(dnl set up local variables, to avoid repeated calculations
[[m4_pushdef([m4_Indent], m4_qlen([$2]))]],
[[m4_pushdef([m4_Cursor], m4_qlen([$3]))]],
[[m4_pushdef([m4_Separator], [m4_define([m4_Separator], [ ])])]],
dnl expand the first prefix, then check its length vs. regular prefix
dnl same length: nothing special
dnl prefix1 longer: output on line by itself, and reset cursor
dnl prefix1 shorter: pad to length of prefix, and reset cursor
[[[$3]m4_cond([m4_Cursor], m4_Indent, [],
	      [m4_eval(m4_Cursor > m4_Indent)], [1], [
[$2]m4_define([m4_Cursor], m4_Indent)],
	      [m4_format([%*s], m4_max([0],
  m4_eval(m4_Indent - m4_Cursor)), [])m4_define([m4_Cursor], m4_Indent)])]],
dnl now, for each word, compute the curser after the word is output, then
dnl check if the cursor would exceed the wrap column
dnl if so, reset cursor, and insert newline and prefix
dnl if not, insert the separator (usually a space)
dnl either way, insert the word
[[m4_foreach_w([m4_Word], [$1],
  [m4_define([m4_Cursor],
	     m4_eval(m4_Cursor + m4_qlen(m4_builtin([defn], [m4_Word]))
		     + 1))m4_if(m4_eval(m4_Cursor > ([$4])),
      [1], [m4_define([m4_Cursor],
		      m4_eval(m4_Indent
			      + m4_qlen(m4_builtin([defn], [m4_Word])) + 1))
[$2]],
      [m4_Separator[]])m4_builtin([defn], [m4_Word])])]],
dnl finally, clean up the local variabls
[[m4_builtin([popdef], [m4_Separator])]],
[[m4_builtin([popdef], [m4_Cursor])]],
[[m4_builtin([popdef], [m4_Indent])]]))
a1608 5
# Turn MESSAGE into:
#  ## ------- ##
#  ## MESSAGE ##
#  ## ------- ##
# using FRAME-CHARACTER in the border.
d1610 1
a1610 4
[m4_pushdef([m4_Border],
	    m4_translit(m4_format([%*s], m4_qlen(m4_expand([$1])), []),
			[ ], m4_if([$2], [], [[-]], [[$2]])))dnl
@@%:@@@@%:@@ m4_Border @@%:@@@@%:@@
d1612 1
a1612 2
@@%:@@@@%:@@ m4_Border @@%:@@@@%:@@dnl
m4_builtin([popdef], [m4_Border])dnl
a1618 2
#
# Avoid bpatsubsts for the common case of no quadrigraphs.
d1620 1
a1620 4
[m4_if(m4_index([$1], [@@]), [-1], [m4_len([$1])],
       [m4_len(m4_bpatsubst([[$1]],
			    [@@\(\(<:\|:>\|S|\|%:\|\{:\|:\}\)\(@@\)\|&t@@\)],
			    [\3]))])])
d1633 1
a1633 1
## 13. Number processing.  ##
d1636 10
d1648 2
a1649 1
# Compare two integer expressions.
d1654 1
a1654 1
[m4_eval((([$1]) > ([$2])) - (([$1]) < ([$2])))])
d1660 8
a1667 16
# Compare the two lists of integer expressions A and B.  For instance:
#   m4_list_cmp([1, 0],     [1])    ->  0
#   m4_list_cmp([1, 0],     [1, 0]) ->  0
#   m4_list_cmp([1, 2],     [1, 0]) ->  1
#   m4_list_cmp([1, 2, 3],  [1, 2]) ->  1
#   m4_list_cmp([1, 2, -3], [1, 2]) -> -1
#   m4_list_cmp([1, 0],     [1, 2]) -> -1
#   m4_list_cmp([1],        [1, 2]) -> -1
#   m4_define([xa], [oops])dnl
#   m4_list_cmp([[0xa]],    [5+5])  -> 0
#
# Rather than face the overhead of m4_case, we use a helper function whose
# expansion includes the name of the macro to invoke on the tail, either
# m4_ignore or m4_unquote.  This is particularly useful when comparing
# long lists, since less text is being expanded for deciding when to end
# recursion.
d1669 7
a1675 38
[m4_if([$1$2], [], 0,
       [$1], [], [$0(0, [$2])],
       [$2], [], [$0([$1], 0)],
       [$1], [$2], 0,
       [_$0(m4_cmp(m4_car($1), m4_car($2)))([$0(m4_cdr($1), m4_cdr($2))])])])
m4_define([_m4_list_cmp],
[m4_if([$1], 0, [m4_unquote], [$1m4_ignore])])

# m4_max(EXPR, ...)
# m4_min(EXPR, ...)
# -----------------
# Return the decimal value of the maximum (or minimum) in a series of
# integer expressions.
#
# M4 1.4.x doesn't provide ?:.  Hence this huge m4_eval.  Avoid m4_eval
# if both arguments are identical, but be aware of m4_max(0xa, 10) (hence
# the use of <=, not just <, in the second multiply).
m4_define([m4_max],
[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
       [$#], [1], [m4_eval([$1])],
       [$#$1], [2$2], [m4_eval([$1])],
       [$#], [2],
       [m4_eval((([$1]) > ([$2])) * ([$1]) + (([$1]) <= ([$2])) * ([$2]))],
       [$0($0([$1], [$2]), m4_shift2($@@))])])
m4_define([m4_min],
[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
       [$#], [1], [m4_eval([$1])],
       [$#$1], [2$2], [m4_eval([$1])],
       [$#], [2],
       [m4_eval((([$1]) < ([$2])) * ([$1]) + (([$1]) >= ([$2])) * ([$2]))],
       [$0($0([$1], [$2]), m4_shift2($@@))])])


# m4_sign(A)
# ----------
# The sign of the integer expression A.
m4_define([m4_sign],
[m4_eval((([$1]) > 0) - (([$1]) < 0))])
d1680 1
a1680 1
## 14. Version processing.  ##
d1686 1
a1686 2
# Normalize beta version numbers with letters to numeric expressions, which
# can then be handed to m4_eval for the purpose of comparison.
d1690 3
a1692 13
# for example:
#   [2.14a] -> [2.14+1.-1.[0r36:a]] -> 2.15.-1.10
#   [2.14b] -> [2.15+1.-1.[0r36:b]] -> 2.15.-1.11
#   [2.61aa.b] -> [2.61+1.-1.[0r36:aa],+1.-1.[0r36:b]] -> 2.62.-1.370.1.-1.11
#
# This macro expects reasonable version numbers, but can handle double
# letters and does not expand any macros.  Original version strings can
# use both `.' and `-' separators.
#
# Inline constant expansions, to avoid m4_defn overhead.
# _m4_version_unletter is the real workhorse used by m4_version_compare,
# but since [0r36:a] is less readable than 10, we provide a wrapper for
# human use.
d1694 9
a1702 6
[m4_map_sep([m4_eval], [.],
	    m4_dquote(m4_dquote_elt(m4_unquote(_$0([$1])))))])
m4_define([_m4_version_unletter],
[m4_bpatsubst(m4_translit([[[$1]]], [.-], [,,]),]dnl
m4_dquote(m4_dquote(m4_defn([m4_cr_Letters])))[[+],
	      [+1,-1,[0r36:\&]])])
d1712 2
a1713 1
[m4_list_cmp(_m4_version_unletter([$1]), _m4_version_unletter([$2]))])
d1729 1
a1729 2
[m4_if(m4_version_compare(]m4_dquote(m4_defn([m4_PACKAGE_VERSION]))[, [$1]),
       [-1],
d1732 3
a1734 2
			     [63])])],
       [$2])])
d1739 1
a1739 1
## 15. File handling.  ##
d1745 1
a1745 1
# fragile than we should.
d1761 1
a1761 1
## 16. Setting M4sugar up.  ##
a1766 1
# Initialize the m4sugar language.
@


