head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2006.06.01.22.17.27;	author tg;	state dead;
branches;
next	1.14;
commitid	100447F676243262322;

1.14
date	2006.05.30.23.06.34;	author tg;	state Exp;
branches;
next	1.13;
commitid	100447CCFF00015071B;

1.13
date	2006.05.30.22.08.46;	author tg;	state Exp;
branches;
next	1.12;
commitid	100447CC2820334EEE3;

1.12
date	2006.05.30.22.05.00;	author tg;	state Exp;
branches;
next	1.11;
commitid	100447CC1A030C722F7;

1.11
date	2006.05.30.22.02.55;	author tg;	state Exp;
branches;
next	1.10;
commitid	100447CC11E077A8BA7;

1.10
date	2006.05.30.22.01.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	100447CC0E27AF44FBE;

1.9
date	2006.05.30.21.57.25;	author tg;	state Exp;
branches;
next	1.8;
commitid	100447CBFD4589F0371;

1.8
date	2006.05.30.21.56.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	100447CBFA804676723;

1.7
date	2006.05.30.21.52.32;	author tg;	state Exp;
branches;
next	1.6;
commitid	100447CBEB424B0C4E5;

1.6
date	2006.05.30.21.44.03;	author tg;	state Exp;
branches;
next	1.5;
commitid	100447CBCBA56B43D3C;

1.5
date	2006.05.30.21.40.38;	author tg;	state Exp;
branches;
next	1.4;
commitid	100447CBBEA18C3FBAC;

1.4
date	2006.05.30.21.38.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	100447CBB7547D26D12;

1.3
date	2006.05.30.21.36.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	100447CBAFD25BAB161;

1.2
date	2006.05.30.21.35.56;	author tg;	state Exp;
branches;
next	1.1;
commitid	100447CBAC457A68663;

1.1
date	2006.05.30.21.29.48;	author tg;	state Exp;
branches;
next	;
commitid	100447CB94F0EF65C4A;


desc
@@


1.15
log
@move freely licenced functions from libhaible into libc;
add missing wcsxfrm(3); sort and style; remove some stubs
@
text
@/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.14 2006/05/30 23:06:34 tg Exp $ */

/*-
 * Copyright (c) 2006
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
 */

#include <errno.h>
#include <wchar.h>

#include "mir18n.h"

__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.14 2006/05/30 23:06:34 tg Exp $");

size_t
mbsrtowcs(wchar_t *__restrict__ pwcs, const char **__restrict__ sb,
    size_t n, mbstate_t *__restrict__ ps)
{
	static mbstate_t internal_mbstate = { 0, 0 };
	const unsigned char *s = (const unsigned char *)(*sb);
	wint_t c, w;
	size_t frag, numb = 0;

	if (__predict_false(ps == NULL))
		ps = &internal_mbstate;

	frag = __locale_is_utf8 ? ps->count : 0;

	while (((pwcs == NULL) ? 1 : n--) > 0) {
		if (__predict_true(frag == 0)) {
			if ((w = *s++) == L'\0')
				goto one_char;
			if (__predict_true(!__locale_is_utf8)) {
				if (__predict_true(w <= MIR18N_SB_CVT))
					goto one_char;
 ilseq:
				errno = EILSEQ;
				return ((size_t)(-1));
			}
			if (w < 0x80) {
				goto one_char;
			} else if (w < 0xC2) {
				/* < 0xC0: spurious second byte */
				/* < 0xC2: would map to 0x80 */
				goto ilseq;
			} else if (w < 0xE0) {
				frag = 1; /* one byte follows */
				w = (w & 0x1F) << 6;
			} else if (w < 0xF0) {
				frag = 2; /* two bytes follow */
				w = (w & 0x0F) << 12;
			} else {
				/* we don't support more than UCS-2 */
				goto ilseq;
			}
		} else
			w = ps->value << 6;

 conv_byte:
		if (((c = *s++) & 0xC0) != 0x80)
			goto ilseq;
		c &= 0x3F;
		w |= c << (6 * --frag);

		if (__predict_false(frag)) {
			/* Check for non-minimalistic mapping
			 * encoding error in 3-byte sequences */
			if (__predict_false(w < 0x800))
				goto ilseq;
			else
				goto conv_byte;
		}

		if (__predict_false(w > MIR18N_MB_MAX))
			goto ilseq;

 one_char:
		if (pwcs != NULL)
			pwcs[numb] = w;
		if (w == L'\0') {
			s = NULL;
			break;
		}
		numb++;
	}
	if (pwcs != NULL) {
		*sb = (const char *)s;
		ps->count = 0;
	}
	return (numb);
}
@


1.14
log
@sync mbrtowc(3) and mbsrtowcs(3) to share the same code base,
now rewritten by myself, and compile warning-free
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.7 2006/04/09 22:08:49 tg Rel $ */
d33 1
a33 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.13 2006/05/30 22:08:46 tg Exp $");
@


1.13
log
@fix ps->count handling
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.12 2006/05/30 22:05:00 tg Exp $ */
a5 3
 * Based upon code written by Bruno Haible for GNU libutf8:
 * Copyright (c) 1999, 2000, 2001
 *	Free Software Foundation, Inc.
d7 10
a16 2
 * This work is licenced under the terms of the GNU Library General
 * Public License, Version 2, as in /usr/share/doc/legal/COPYING.LIB-2
d28 1
a29 1
#include <errno.h>
d33 1
a33 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.12 2006/05/30 22:05:00 tg Exp $");
d36 1
a36 1
mbsrtowcs(wchar_t *__restrict__ pwcs, const char **__restrict__ s,
d39 2
a40 2
	static mbstate_t internal = { 0, 0 };
	const unsigned char *src = (const unsigned char *)(*s);
d42 4
a45 1
	size_t num, numb = 0;
d47 1
a47 2
	if (ps == NULL)
		ps = &internal;
d49 7
a55 4
	if (!__locale_is_utf8) {
		while (((pwcs == NULL) ? 1 : n--) > 0) {
			c = *src++;
			if (c > MIR18N_SB_CVT) {
d60 15
a74 5
			if (pwcs != NULL)
				pwcs[numb] = (wchar_t)c;
			if (c == '\0') {
				src = NULL;
				break;
d76 16
a91 1
			numb++;
d93 10
a102 41
	} else {
		num = ps->count;
		while (((pwcs == NULL) ? 1 : n--) > 0) {
			if (num == 0) {
				c = *src;
				if (c < 0x80) {
					if (pwcs != NULL)
						pwcs[numb] = (wchar_t)c;
					if (c == '\0') {
						src = NULL;
						break;
					}
					src++;
					numb++;
					continue;
				} else if (c < 0xC2)
					goto ilseq;
				if (c < 0xE0) {
					w = (wchar_t)(c & 0x1F) << 6;
					num = 1;
				} else if (c < 0xF0) {
					w = (wchar_t)(c & 0x0F) << 12;
					num = 2;
				} else
					goto ilseq;
				src++;
			} else
				w = ps->value << 6;
			for (;;) {
				c = *src++ ^ 0x80;
				if (!(c < 0x40))
					goto ilseq;
				w |= (wchar_t)c << (6 * --num);
				if (num == 0)
					break;
				if (w < (1 << (5 * num + 6)))
					goto ilseq;
			}
			if (pwcs != NULL)
				pwcs[numb] = w;
			numb++;
d104 1
d107 1
a107 1
		*s = (const char *)src;
@


1.12
log
@misleading name
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.11 2006/05/30 22:02:55 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.11 2006/05/30 22:02:55 tg Exp $");
d59 1
d61 1
a61 1
			if (ps->count == 0) {
d84 1
a84 1
			} else {
a85 2
				num = ps->count;
			}
d96 1
a96 1
			if (pwcs != NULL) {
a97 2
				ps->count = 0;
			}
d101 1
a101 1
	if (pwcs != NULL)
d103 2
@


1.11
log
@get rid of src_backup too (can, now)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.10 2006/05/30 22:01:50 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.10 2006/05/30 22:01:50 tg Exp $");
d37 1
a37 1
	size_t num, count = 0;
d51 1
a51 1
				pwcs[count] = (wchar_t)c;
d56 1
a56 1
			count++;
d64 1
a64 1
						pwcs[count] = (wchar_t)c;
d70 1
a70 1
					count++;
d98 1
a98 1
				pwcs[count] = w;
d101 1
a101 1
			count++;
d106 1
a106 1
	return (count);
@


1.10
log
@sync  more with src/lib/libc/i18n/mbrtowc.c
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.9 2006/05/30 21:57:25 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.9 2006/05/30 21:57:25 tg Exp $");
a59 1
			const unsigned char *s2 = src;
d90 1
a90 1
					goto bad_input_backup;
d95 1
a95 1
					goto bad_input_backup;
a101 4
			continue;
 bad_input_backup:
			src = s2;
			goto ilseq;
@


1.9
log
@don't modify ps if pwcs == NULL either
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.8 2006/05/30 21:56:46 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.8 2006/05/30 21:56:46 tg Exp $");
d37 1
a37 1
	size_t num, rv = 0;
d45 5
d51 1
a51 1
				pwcs[rv] = (wchar_t)c;
d56 1
a56 1
			rv++;
d65 1
a65 1
						pwcs[rv] = (wchar_t)c;
d71 1
a71 1
					rv++;
d74 1
a74 1
					goto bad_input;
d82 1
a82 1
					goto bad_input;
d99 1
a99 1
				pwcs[rv] = w;
d102 1
a102 1
			rv++;
d106 1
a106 1
			goto bad_input;
d111 1
a111 4
	return (rv);
 bad_input:
	errno = EILSEQ;
	return ((size_t)(-1));
@


1.8
log
@don't modify *s in certain places (checked with manpage and SUSv3)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.7 2006/05/30 21:52:32 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.7 2006/05/30 21:52:32 tg Exp $");
d93 1
a93 1
			if (pwcs != NULL)
d95 2
a96 1
			ps->count = 0;
@


1.7
log
@make similar to src/lib/libc/i18n/mbrtowc.c
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.6 2006/05/30 21:44:03 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.6 2006/05/30 21:44:03 tg Exp $");
d103 2
a104 1
	*s = src;
a106 1
	*s = src;
@


1.6
log
@consolidate
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.5 2006/05/30 21:40:38 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.5 2006/05/30 21:40:38 tg Exp $");
d31 2
a32 2
mbsrtowcs(wchar_t *__restrict__ dest, const char **__restrict__ srcps,
    size_t len, mbstate_t *__restrict__ ps)
d34 4
a37 7
	const unsigned char **__restrict__ srcp =
	    (const unsigned char **__restrict__) srcps;
	static mbstate_t internal;
	const unsigned char *src;
	size_t cnt = 0, count;
	unsigned char c;
	wchar_t wc;
a41 1
	src = *srcp;
d43 1
a43 1
		while (((dest == NULL) ? 1 : len--) > 0) {
d45 2
a46 2
			if (dest != NULL)
				dest[cnt] = (wchar_t)c;
d51 1
a51 1
			cnt++;
d54 1
a54 1
		while (((dest == NULL) ? 1 : len--) > 0) {
d59 2
a60 2
					if (dest != NULL)
						dest[cnt] = (wchar_t)c;
d66 1
a66 1
					cnt++;
d71 2
a72 2
					wc = (wchar_t)(c & 0x1F) << 6;
					count = 1;
d74 2
a75 2
					wc = (wchar_t)(c & 0x0F) << 12;
					count = 2;
d80 2
a81 2
				wc = ps->value << 6;
				count = ps->count;
d87 2
a88 2
				wc |= (wchar_t)c << (6 * --count);
				if (count == 0)
d90 1
a90 1
				if (wc < (1 << (5 * count + 6)))
d93 2
a94 2
			if (dest != NULL)
				dest[cnt] = wc;
d96 1
a96 1
			cnt++;
d103 2
a104 2
	*srcp = src;
	return (cnt);
d106 1
a106 1
	*srcp = src;
@


1.5
log
@make it compile, for now
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.4 2006/05/30 21:38:38 tg Exp $ */
d28 1
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.4 2006/05/30 21:38:38 tg Exp $");
d57 2
a58 5
		*srcp = src;
		return (cnt);
	}
	if (dest != NULL) {
		while (len-- > 0) {
d63 2
a64 1
					dest[cnt] = (wchar_t)c;
d97 2
a98 1
			dest[cnt] = wc;
a105 46
	} else {
		/* ignore dest and len */
		while (1) {
			const unsigned char *s2 = src;
			if (ps->count == 0) {
				c = *src;
				if (c < 0x80) {
					if (c == '\0') {
						src = NULL;
						break;
					}
					src++;
					cnt++;
					continue;
				} else if (c < 0xC2)
					goto bad_input;
				if (c < 0xE0) {
					wc = (wchar_t)(c & 0x1F) << 6;
					count = 1;
				} else if (c < 0xF0) {
					wc = (wchar_t)(c & 0x0F) << 12;
					count = 2;
				} else
					goto bad_input;
				src++;
			} else {
				wc = ps->value << 6;
				count = ps->count;
			}
			for (;;) {
				c = *src++ ^ 0x80;
				if (!(c < 0x40))
					goto bad_input_backup2;
				wc |= (wchar_t)c << (6 * --count);
				if (count == 0)
					break;
				if (wc < (1 << (5 * count + 6)))
					goto bad_input_backup2;
			}
			ps->count = 0;
			cnt++;
			continue;
 bad_input_backup2:
			src = s2;
			goto bad_input;
		}
@


1.4
log
@consolidate
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.3 2006/05/30 21:36:44 tg Exp $ */
d24 1
d26 3
a28 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.3 2006/05/30 21:36:44 tg Exp $");
d31 1
a31 1
mbsrtowcs(wchar_t *__restrict__ dest, const char **__restrict__ srcp,
d34 2
@


1.3
log
@step 2 (luckily, len is unused)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.2 2006/05/30 21:35:56 tg Exp $ */
d25 1
a25 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.2 2006/05/30 21:35:56 tg Exp $");
d42 7
a48 16
		if (dest == NULL)
			while (len > 0) {
				dest[cnt] = (wchar_t)(c = *src);
				if (c == '\0') {
					src = NULL;
					break;
				}
				src++; cnt++; len--;
			}
		else	/* ignore dest and len */
			while (1) {
				if (*src == '\0') {
					src = NULL;
					break;
				}
				src++; cnt++;
d50 2
@


1.2
log
@first step in converting for loops into while loops
(I'd like goto loops better here...)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.1 2006/05/30 21:29:48 tg Exp $ */
d25 1
a25 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.1 2006/05/30 21:29:48 tg Exp $");
d63 1
a63 1
		for ( ; len > 0; len--) {
@


1.1
log
@initial version, based upon libutf8
much to change
@
text
@d1 1
a1 1
/* $MirOS$ */
d25 1
a25 1
__RCSID("$MirOS$");
d43 1
a43 1
			for ( ; len > 0; src++, cnt++, len--) {
d49 2
d52 1
a52 1
			for ( ; ; src++, cnt++) {
d57 1
d63 1
a63 1
		for ( ; len > 0; cnt++, len--) {
d74 1
d103 1
a108 2
		*srcp = src;
		return (cnt);
d111 1
a111 1
		for ( ; ; cnt++) {
d121 1
d149 1
a154 2
		*srcp = src;
		return (cnt);
d156 2
@

