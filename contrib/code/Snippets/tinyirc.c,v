head	1.43;
access;
symbols
	mirbsd:1.1.7;
locks; strict;
comment	@ * @;


1.43
date	2017.08.10.21.12.32;	author tg;	state Exp;
branches;
next	1.42;
commitid	100598CCC523A66AC06;

1.42
date	2013.10.31.20.05.42;	author tg;	state Exp;
branches;
next	1.41;
commitid	1005272B7081B0E5655;

1.41
date	2011.07.18.00.35.41;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004E237FF1656D5846;

1.40
date	2011.07.06.22.22.04;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004E14E010182825E7;

1.39
date	2010.09.21.21.24.03;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004C992261692DCA0F;

1.38
date	2009.12.27.22.25.58;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004B37DEFB61D48096;

1.37
date	2009.11.29.15.21.20;	author tg;	state Exp;
branches;
next	1.36;
commitid	1004B1291782E3D5DF1;

1.36
date	2009.08.02.14.35.00;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004A75A41A5D07D5B1;

1.35
date	2009.01.18.15.44.09;	author tg;	state Exp;
branches;
next	1.34;
commitid	10049734E5D0FA9D269;

1.34
date	2009.01.17.14.08.22;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004971E66B769DC8A3;

1.33
date	2009.01.08.20.23.32;	author tg;	state Exp;
branches;
next	1.32;
commitid	100496660B46A83B0A4;

1.32
date	2008.12.29.22.19.26;	author tg;	state Exp;
branches;
next	1.31;
commitid	10049594CEA47D682AA;

1.31
date	2008.12.29.22.12.42;	author tg;	state Exp;
branches;
next	1.30;
commitid	10049594B6D1204C003;

1.30
date	2008.12.29.22.07.07;	author tg;	state Exp;
branches;
next	1.29;
commitid	10049594A1E50CA8DF8;

1.29
date	2008.12.29.21.52.53;	author tg;	state Exp;
branches;
next	1.28;
commitid	100495946C65B91F363;

1.28
date	2008.12.29.21.46.32;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004959454E377CEFC6;

1.27
date	2008.12.20.17.29.44;	author tg;	state Exp;
branches;
next	1.26;
commitid	100494D2B943BDEEBAC;

1.26
date	2008.12.20.17.02.04;	author tg;	state Exp;
branches;
next	1.25;
commitid	100494D251E5F922DF4;

1.25
date	2008.12.20.17.01.31;	author tg;	state Exp;
branches;
next	1.24;
commitid	100494D24F77022FF2B;

1.24
date	2008.12.20.16.58.22;	author tg;	state Exp;
branches;
next	1.23;
commitid	100494D24297041E663;

1.23
date	2008.12.09.20.37.12;	author tg;	state Exp;
branches;
next	1.22;
commitid	100493ED7032FB29230;

1.22
date	2008.12.09.20.27.02;	author tg;	state Exp;
branches;
next	1.21;
commitid	100493ED4543947682E;

1.21
date	2008.12.09.19.48.35;	author tg;	state Exp;
branches;
next	1.20;
commitid	100493ECB97653751EB;

1.20
date	2008.12.09.18.34.41;	author tg;	state Exp;
branches;
next	1.19;
commitid	100493EBA517B0E33A4;

1.19
date	2008.12.02.17.12.00;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049356C69746DDB9B;

1.18
date	2008.12.02.16.46.19;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004935666C3994F31D;

1.17
date	2008.12.02.16.37.00;	author tg;	state Exp;
branches;
next	1.16;
commitid	100493563CD2700B7A1;

1.16
date	2008.12.02.15.18.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004935513A68B78A20;

1.15
date	2008.12.02.13.34.28;	author tg;	state Exp;
branches;
next	1.14;
commitid	100493539715ED351C9;

1.14
date	2007.07.18.21.17.44;	author tg;	state Exp;
branches;
next	1.13;
commitid	100469E836332620C35;

1.13
date	2007.07.18.20.30.43;	author tg;	state Exp;
branches;
next	1.12;
commitid	100469E787F7E43C4A1;

1.12
date	2007.07.17.20.08.16;	author tg;	state Exp;
branches;
next	1.11;
commitid	100469D21BC33C3E7EC;

1.11
date	2007.07.17.19.23.04;	author tg;	state Exp;
branches;
next	1.10;
commitid	100469D17263D3F873B;

1.10
date	2006.12.20.16.28.20;	author tg;	state Exp;
branches;
next	1.9;
commitid	100458964B56B8FF240;

1.9
date	2006.06.15.19.18.45;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004491B2706C2443B2;

1.8
date	2006.06.09.20.36.37;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004489DBE95A6DAE68;

1.7
date	2006.05.29.18.43.18;	author tg;	state Exp;
branches;
next	1.6;
commitid	100447B40DD5C5BAA05;

1.6
date	2006.05.29.15.56.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	100447B19D632AD8B8D;

1.5
date	2006.05.21.11.10.51;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044704ACE08DE52DF;

1.4
date	2006.05.21.10.53.15;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004470469F477211C4;

1.3
date	2006.05.21.10.48.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	100447045875D0D6130;

1.2
date	2006.01.13.03.49.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043C722F46A94D38C;

1.1
date	2005.02.05.02.36.15;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.1.7.1
date	2005.02.05.02.36.15;	author tg;	state Exp;
branches;
next	;


desc
@@


1.43
log
@update the FSF’s postal address
@
text
@#if 0
.if "0" == "1"
#endif

/* Debian: gcc -O2 -s -o tinyirc tinyirc.c -lbsd -ltermcap */

/* Configuration options */
/* please change the default server to one near you. */
#define DEFAULTSERVER	"irc.mirbsd.org"
#define DEFAULTPORT	6667
#define COMMANDCHAR	'/'
/* each line of history adds 512 bytes to resident size */
#define HISTLEN		8

#if defined(__MirBSD__)
#define RELEASE_OS	"MirBSD"
#elif defined(__OpenBSD__)
#define RELEASE_OS	"OpenBSD"
#elif defined(__CYGWIN32__)
#define RELEASE_OS	"GNU/Cygwin32"
#elif defined(__gnu_linux__)
#define RELEASE_OS	"GNU/Linux"
#else
#define RELEASE_OS	"unknown OS"
#endif

#define RELEASE_VER	"TinyIRC 20110717"
#define RELEASE_L	RELEASE_VER " (" RELEASE_OS ") MirOS-contrib"
#define RELEASE_S	RELEASE_VER " MirOS"

/*-
   TinyIRC - MirOS Fork
   Copyright (C) 1994 Nathan I. Laredo <laredo@@gnu.org>
   Copyright (c) 1999-2013 Thorsten Glaser <tg@@mirbsd.org>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License Version 1
   as published by the Free Software Foundation.

   This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
   the utmost extent permitted by applicable law, neither express nor
   implied; without malicious intent or gross negligence. In no event
   may a licensor, author or contributor be held liable for indirect,
   direct, other damage, loss, or other issues arising in any way out
   of dealing in the work, even if advised of the possibility of such
   damage or existence of a defect, except proven that it results out
   of said person's immediate fault when using the work as intended.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA

   The copyright holders consider the licence's condition of source
   publication to be fulfilled if all of the sources in the exact
   state used to build a combined binary, e.g. using crunchgen(1),
   that includes this work as part of it are published, without the
   other, independent works part of said combined binary requiring
   to be distributed under the terms of the GNU GPL.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <ctype.h>
#include <curses.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef _USE_OLD_CURSES_
#include <term.h>
#endif
#include <termios.h>
#include <time.h>
#include <unistd.h>

#ifndef __RCSID
#define	__RCSID(x)	static const char __rcsid[] __attribute__((__used__)) = (x)
#endif

__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.41 2011/07/18 00:35:41 tg Exp $");

#ifndef __dead
#define __dead
#endif

#if defined(__CYGWIN__) || defined(WIN32)
u_int32_t arc4random(void);
uint32_t arc4random_pushb(const void *, size_t);
#define RELEASE_PAPI	"Win32"
#define dopush		arc4random_pushb
#elif defined(arc4random_pushb_fast)
#define RELEASE_PAPI	"pfast"
#define dopush		arc4random_pushb_fast
#elif defined(__MirBSD__)
#define RELEASE_PAPI	"pushb"
#define dopush		arc4random_pushb
#elif defined(arc4random_pushk)
#define RELEASE_PAPI	"pushk"
#define dopush		arc4random_pushk
#else
#define RELEASE_PAPI	"none"
#define dopush(buf,n)	arc4random_addrandom((u_char *)(buf), (int)(n))
#endif

struct dlist {
    char name[64];
    struct dlist *next;
};
struct dlist *object = NULL, *objlist = NULL, *newobj;
u_short IRCPORT = DEFAULTPORT;
#define LINELEN 512
int sockfd, sok = 1, stdinfd, stdoutfd, histline, dumb = 0,
    maxcol, maxlin, column;
char *linein, lineout[LINELEN], *history[HISTLEN], localhost[64],
*tok_in[256], *tok_out[256], *tmp, serverdata[512], termcap[1024],
*ptr, *term, *fromhost, IRCNAME[16], inputbuf[512], beenden = 0;
char bp[4096], *cap_cm, *cap_cs, *cap_ce, *cap_so, *cap_se, *cap_dc;
#define NLASTCHAN 12
char *lastchans[NLASTCHAN];
int cursd = 0, curli = 0, curx = 0;
fd_set readfs;
struct timeval time_out;
struct tm *timenow;
static time_t idletimer, datenow, wasdate;
static volatile sig_atomic_t sigwinch = 0;

char null[] = "";
char s_cm[] = "cm";
char s_CM[] = "CM";
char s_so[] = "so";
char s_se[] = "se";
char s_cs[] = "cs";
char s_ce[] = "ce";
char s_dc[] = "dc";
struct termios _tty;
tcflag_t _res_iflg, _res_lflg;
#define raw() (_tty.c_lflag &= ~(ICANON | ECHO | ISIG), \
	tcsetattr(stdinfd, TCSANOW, &_tty))
#define savetty() ((void) tcgetattr(stdinfd, &_tty), \
	_res_iflg = _tty.c_iflag, _res_lflg = _tty.c_lflag)
#define resetty() (_tty.c_iflag = _res_iflg, _tty.c_lflag = _res_lflg,\
	(void) tcsetattr(stdinfd, TCSADRAIN, &_tty))

#ifdef _USE_OLD_CURSES_
#define	tputs_x		_puts
#else
#define	tputs_x(s)	(tputs(s, 0, putchar))
#endif

int my_stricmp(const char *, const char *);
struct dlist *additem(char *, struct dlist *);
struct dlist *finditem(char *, struct dlist *);
struct dlist *removeitem(char *, struct dlist *);
int makeconnect(const char *);
int sendline(void);
void updatestatus(void);
static int nop(void);
static int doerror(void);
static int doinvite(void);
static int dojoin(void);
static int dokick(void);
static int dokill(void);
static int domode(void);
static int donick(void);
static int donotice(void);
static int dopart(void);
static int dopong(void);
static int doprivmsg(void);
static int doquit(void);
static int dosquit(void);
static int dotime(void);
static int dotopic(void);
int donumeric(int);
int wordwrapout(char *, size_t);
int parsedata(void);
int serverinput(void);
void parseinput(void);
void histupdate(void);
void printpartial(int);
void userinput(void);
__dead void cleanup(int);
static void dowinch(int);
static void dowinsz(int);
int main(int, char *[]);
static void pushlastchan(char *);
#define arc4hashpush(x) arc4hashpush_((const void *)(x))
void arc4hashpush_(const uint8_t *);

void arc4hashpush_(const uint8_t *buf)
{
	static uint32_t s = 0;
	register uint32_t h;
	register uint8_t c;
	uint32_t pv;

	if (!s)
		s = arc4random();

	h = s;
	while ((c = *buf++)) {
		h += c;
		++h;
		h += h << 10;
		h ^= h >> 6;
	}
	s = h;

	h += h << 10;
	h ^= h >> 6;
	h += h << 3;
	h ^= h >> 11;
	h += h << 15;

	pv = h;
	dopush(&pv, sizeof(pv));
}

int my_stricmp(const char *str1, const char *str2)
{
    int compare;

    while (*str1 != 0 && str2 != 0) {
	if (isalpha(*str1) && isalpha(*str2)) {
	    compare = *str1 ^ *str2;
	    if ((compare != 32) && (compare != 0))
		return (*str1 - *str2);
	} else {
	    if (*str1 != *str2)
		return (*str1 - *str2);
	}
	str1++;
	str2++;
    }
    return (*str1 - *str2);
}

struct dlist *additem(char *item, struct dlist *ptrx)
{
    newobj = (struct dlist *) malloc(sizeof(struct dlist));
    strlcpy(newobj->name, item, 64);
    newobj->next = ptrx;
    return newobj;
}

struct dlist *finditem(char *item, struct dlist *ptrx)
{
    while (ptrx != NULL)
	if (my_stricmp(item, ptrx->name) == 0)
	    break;
	else
	    ptrx = ptrx->next;
    return ptrx;
}

struct dlist *removeitem(char *item, struct dlist *ptrx)
{
    struct dlist *prev = NULL, *start = ptrx;
    while (ptrx != NULL)
	if (my_stricmp(item, ptrx->name) == 0) {
	    newobj = ptrx->next;
	    if (object == ptrx)
		object = NULL;
	    free (ptrx);
	    if (prev == NULL)
		return newobj;
	    else {
		prev->next = newobj;
		return start;
	    }
	} else {
	    prev = ptrx;
	    ptrx = ptrx->next;
	}
    return start;
}

int makeconnect(const char *hostname)
{
    struct sockaddr_in sa;
    struct hostent *hp;
    int s;

    if ((hp = gethostbyname(hostname)) == NULL)
	return -1;
    bzero(&sa, sizeof(sa));
    memmove((char *) &sa.sin_addr, hp->h_addr, hp->h_length);
    sa.sin_family = hp->h_addrtype;
    sa.sin_port = htons((u_short) IRCPORT);
    if ((s = socket(hp->h_addrtype, SOCK_STREAM, 0)) < 0)
	return -1;
    if (connect(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
	close(s);
	return -1;
    }
    fcntl(s, F_SETFL, O_NDELAY);
    return s;
}

int sendline(void)
{
    arc4hashpush(lineout);
    if (write(sockfd, lineout, strlen(lineout)) < 1)
	return 0;
    return 1;
}

void updatestatus(void)
{
    int n;
    if (!dumb) {
	if (60 < (datenow = time(NULL)) - wasdate) {
	    wasdate = datenow;
	    timenow = localtime(&datenow);
	    tputs_x(tgoto(cap_cm, 0, maxlin - 1));
	    tputs_x(cap_so);
	    n = printf("[%02d:%02d] %s on %s : %s", timenow->tm_hour,
		timenow->tm_min, IRCNAME, object == NULL ||
		object->name == NULL ? "*" : object->name, RELEASE_S);
	    for (; n < maxcol; n++)
		putchar(' ');
	    tputs_x(cap_se);
	}
    }
}

static int nop(void)
{
    return 1;
}

static int doerror(void)
{
    column = printf("*** ERROR:");
    return 2;
}

static int doinvite(void)
{
    printf("*** %s (%s) invites you to join %s.",
	   tok_in[0], fromhost, &tok_in[2][1]);
    return 0;
}

static int dojoin(void)
{
    if (strcmp(tok_in[0], IRCNAME) == 0) {
	object = objlist = additem(tok_in[2], objlist);
	wasdate = 0;
	printf("*** Now talking in %s", object->name);
    } else
	printf("*** %s (%s) joined %s", tok_in[0], fromhost, tok_in[2]);
    return 0;
}

static int dokick(void)
{
    printf("*** %s was kicked from %s by %s (%s)",
	   tok_in[3], tok_in[2], tok_in[0], tok_in[4]);
    if (strcmp(tok_in[3], IRCNAME) == 0) {
	objlist = removeitem(tok_in[2], objlist);
	if (object == NULL)
	    object = objlist;
	if (object != NULL)
	    printf("\n\r*** Now talking in %s", object->name);
	wasdate = 0;
    }
    return 0;
}

static int dokill(void)
{
    printf("*** %s killed by %s (%s)", tok_in[3], tok_in[0], tok_in[4]);
    return 0;
}

static int domode(void)
{
    printf("*** %s changed %s to:", tok_in[0], tok_in[2]);
    return 3;
}

static int donick(void)
{
    if (strcmp(tok_in[0], IRCNAME) == 0) {
	wasdate = 0;
	strlcpy(IRCNAME, tok_in[2], sizeof(IRCNAME));
    }
    printf("*** %s is now known as %s", tok_in[0], tok_in[2]);
    return 0;
}

static int donotice(void)
{
    if (*tok_in[2] != '#')
	column = printf("-%s-", tok_in[0]);
    else
	column = printf("-%s:%s-", tok_in[0], tok_in[2]);
    return 3;
}

static int dopart(void)
{
    printf("*** %s (%s) left %s", tok_in[0], fromhost,
	   tok_in[2]);
    if (strcmp(tok_in[0], IRCNAME) == 0) {
	objlist = removeitem(tok_in[2], objlist);
	if (object == NULL)
	    object = objlist;
	if (object != NULL)
	    printf("\n\r*** Now talking in %s", object->name);
	wasdate = 0;
    }
    return 0;
}

static int dopong(void)
{
    column = printf("*** Got PONG from %s:", tok_in[0]);
    return 3;
}

static int doprivmsg(void)
{
    if (*tok_in[3] == 1) {
	/* rudimentary CTCP handler */
	char ch, ctcp[50];
	int i = 1, skipout = 0;

	while ((ch = tok_in[3][i]) && ch != 1 && ch != ' ' && i < 50)
		ctcp[i++ - 1] = toupper(ch);
	if (i == 50 || tok_in[3][strlen(tok_in[3]) - 1] != 1)
		goto noctcp;
	ctcp[i++ - 1] = 0;
	tok_in[3][strlen(tok_in[3]) - 1] = 0;
	if (!strcmp(ctcp, "ENTROPY")) {
		dopush(serverdata, sizeof(serverdata));
		snprintf(bp, sizeof(bp),
		    "%s initiated the RANDEX protocol with %s",
		    tok_in[0], *tok_in[2] == '#' ? tok_in[2] : "you");
		column = printf("*C*");
		column = wordwrapout(bp, column);
		skipout = 1;
		snprintf(lineout, LINELEN, "NOTICE %s :\001RANDOM ",
		    tok_in[0]);
		while (strlen(lineout) < 240) {
			char buf[9];

			snprintf(buf, 9, "%08X", arc4random());
			strlcat(lineout, buf, LINELEN);
		}
		strlcat(lineout, "\001\n", LINELEN);
		sendline();
	} else if (!strcmp(ctcp, "RANDOM")) {
		dopush(serverdata, sizeof(serverdata));
		snprintf(bp, sizeof(bp),
		    "%s queried RANDEX protocol information from %s",
		    tok_in[0], *tok_in[2] == '#' ? tok_in[2] : "you");
		column = printf("*C*");
		column = wordwrapout(bp, column);
		skipout = 1;
		snprintf(lineout, LINELEN,
		    "PRIVMSG %s :\001ACTION uses %s with built-in support"
		    " for the RANDEX protocol, push API: %s\001\n", tok_in[0],
		    RELEASE_L, RELEASE_PAPI);
		sendline();
	} else if (!strcmp(ctcp, "VERSION")) {
		snprintf(lineout, LINELEN,
		    "NOTICE %s :\001VERSION %s (RANDOM=%u)\001\n",
		    tok_in[0], RELEASE_L, arc4random());
		sendline();
	} else if (!strcmp(ctcp, "CLIENTINFO")) {
		snprintf(lineout, LINELEN,
		    "NOTICE %s :\001CLIENTINFO ACTION, CLIENTINFO, ECHO, "
		    "ENTROPY, ERRMSG, PING, RANDOM, TIME, VERSION\001\n",
		    tok_in[0]);
		sendline();
	} else if (!strcmp(ctcp, "PING") ||
	    !strcmp(ctcp, "ECHO") || !strcmp(ctcp, "ERRMSG")) {
		snprintf(lineout, LINELEN,
		    "NOTICE %s :\001%s %s\001\n",
		    tok_in[0], ctcp, tok_in[3] + i);
		sendline();
	} else if (!strcmp(ctcp, "TIME")) {
		time_t t;

		time(&t);
		snprintf(lineout, LINELEN,
		    "NOTICE %s :\001TIME ", tok_in[0]);
		strftime(lineout + strlen(lineout),
		    LINELEN - strlen(lineout),
		    "%c\001\n", localtime(&t));
		sendline();
	} else if (!strcmp(ctcp, "ACTION")) {
		if (*tok_in[2] != '#')
			column = printf("[*] %s", tok_in[0]);
		else if (object != NULL && object->name != NULL &&
		    my_stricmp(object->name, tok_in[2]))
			column = printf("* %s:%s", tok_in[0], tok_in[2]);
		else
			column = printf("* %s", tok_in[0]);
		column = wordwrapout(tok_in[3] + i, column);
		skipout = 1;
	}
	if (!skipout) {
		snprintf(bp, sizeof(bp), "%s did a CTCP %s%s%s to %s",
		    tok_in[0], ctcp, tok_in[3][i] ? " " : "",
		    tok_in[3] + i, *tok_in[2] == '#' ? tok_in[2] : "you");
		column = printf("*C*");
		column = wordwrapout(bp, column);
	}
	i = 4;
	while (tok_in[i])
		column = wordwrapout(tok_in[i++], column);
	return (0);
    }
 noctcp:
    if (*tok_in[2] != '#')
	column = printf("*%s*", tok_in[0]);
    else if (object != NULL && object->name != NULL &&
      my_stricmp(object->name, tok_in[2]))
	column = printf("<%s:%s>", tok_in[0], tok_in[2]);
    else
	column = printf("<%s>", tok_in[0]);
    return 3;
}

static int doquit(void)
{
    printf("*** %s (%s) Quit (%s)", tok_in[0], fromhost, tok_in[2]);
    return 0;
}

static int dosquit(void)
{
    return 1;
}

static int dotime(void)
{
    return 1;
}

static int dotopic(void)
{
    printf("*** %s set %s topic to \"%s\"", tok_in[0], tok_in[2],
	   tok_in[3]);
    return 0;
}

int donumeric(int num)
{
    if (num == 352) {		/* rpl_whoreply */
	column = printf("%-14s %-10s %-3s %s@@%s :", tok_in[3], tok_in[7],
			tok_in[8], tok_in[4], tok_in[5]);
	return 9;
    } else if (num == 432 || num == 433) {
	char ch;
	printf("*** You've chosen an invalid nick.  Choose again.");
	tputs_x(tgoto(cap_cm, 0, maxlin));
	tputs_x(cap_ce);
	printf("New Nick? ");
	fflush(stdout);
	resetty();
	tmp = IRCNAME;
	while ((ch = getchar()) != '\n')
	    if (strlen(IRCNAME) < sizeof(IRCNAME) - 1)
		*(tmp++) = ch;
        *tmp = '\0';
	wasdate = 0;
	raw();
	snprintf(lineout, LINELEN, "NICK :%s\n", IRCNAME);
	sendline();
	tputs_x(tgoto(cap_cm, 0, maxlin));
	tputs_x(cap_ce);
    } else {			/* all remaining numerics */
	column = printf("%s", tok_in[1]);
	return 3;
    }
    return (0);
}

#define	LISTSIZE	55
#define	DO_JOIN		12
#define	DO_MSG		18
#define	DO_PRIVMSG	30
#define	DO_QUIT		32
#define	DO_QUOTE	31
#define	DO_W		46
#define	DO_WHOIS	49
#define DO_ME		51
#define DO_DESCRIBE	52
#define DO_CTCP		53
#define DO_NOTICE	21
#define DO_NAMES	23
#define DO_NS		54
static const char *cmdlist[LISTSIZE] =
{"AWAY", "ADMIN", "CONNECT", "CLOSE", "DIE", "DNS", "ERROR", "HELP",
 "HASH", "INVITE", "INFO", "ISON", "JOIN", "KICK", "KILL", "LIST", "LINKS",
 "LUSERS", "MSG", "MODE", "MOTD", "NOTICE", "NICK", "NAMES", "NOTE", "OPER",
 "PART", "PASS", "PING", "PONG", "PRIVMSG", "QUOTE", "QUIT", "REHASH", "RESTART",
 "SERVER", "SQUIT", "STATS", "SUMMON", "TIME", "TOPIC", "TRACE", "USER",
 "USERHOST", "USERS", "VERSION", "W", "WALLOPS", "WHO", "WHOIS", "WHOWAS",
 "ME", "DESCRIBE", "CTCP", "NS"};
static int numargs[LISTSIZE] =
{1, 1, 3, 1, 1, 1, 1, 1,
 1, 2, 1, 1, 1, 3, 2, 1, 1,
 2, 2, 2, 1, 2, 1, 1, 1, 2,
 1, 1, 1, 1, 2, 0, 1, 1, 1,
 3, 2, 1, 3, 1, 2, 2, 4,
 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 0
};
static int (*docommand[LISTSIZE]) (void) =
{nop, nop, nop, nop, nop, nop, doerror, nop,
 nop, doinvite, nop, nop, dojoin, dokick, dokill, nop, nop,
 nop, nop, domode, nop, donotice, donick, nop, nop, nop,
 dopart, nop, nop, dopong, doprivmsg, nop, doquit, nop, nop,
 nop, dosquit, nop, nop, dotime, dotopic, nop, nop,
 nop, nop, nop, nop, nop, nop, nop, nop,
 nop, nop, nop, nop
};

int wordwrapout(char *ptrx, size_t count)
{
    while(ptrx != NULL) {
	if ((tmp = strchr(ptrx, ' ')) != NULL)
	    *(tmp++) = '\0';
	if (strlen(ptrx) < maxcol - count)
	    count += printf(" %s", ptrx);
	else
	    count = printf("\n\r   %s", ptrx);
	ptrx = tmp;
    }
    return count;
}

int parsedata(void)
{
    int i, found = 0;

/* take care of ping silently */
    if (serverdata[0] == 'P') {
	snprintf(lineout, LINELEN, "PONG :%s\n", &serverdata[6]);
	return sendline();
    }
    if (!dumb)
	tputs_x(tgoto(cap_cm, 0, maxlin - 2));

    tok_in[i = 0] = serverdata;
    tok_in[i]++;
    while (tok_in[i] != NULL)
	if (*tok_in[i] == ':')
	    break;
	else {
	    if ((tmp = strchr(tok_in[i], ' ')) != NULL) {
		tok_in[++i] = &tmp[1];
		*tmp = '\0';
	   } else
		tok_in[++i] = NULL;
	}
    if (tok_in[i] != NULL)
	tok_in[i]++;
    tok_in[++i] = NULL;

    if (!dumb)
	putchar('\n');
    if ((tmp = strchr(tok_in[0], '!')) != NULL) {
	fromhost = &tmp[1];
	*tmp = '\0';
    } else
	fromhost = NULL;

    column = 0;
    if ((i = atoi(tok_in[1])))
	i = donumeric(i);
    else {
	for (i = 0; i < LISTSIZE && !found; i++)
	    found = (strcmp(cmdlist[i], tok_in[1]) == 0);
	if (found)
	    i = (*docommand[i - 1]) ();
	else
	    i = nop();
    }

    if (i)
	while (tok_in[i])	/* output remainder with word wrap */
	    column = wordwrapout(tok_in[i++], column);
    if (dumb)
	putchar('\n');
    if (strncmp(tok_in[1], "Closing", 7) == 0)
	return 0;
    return 1;
}

int serverinput(void)
{
    char ich;
    while (read(sockfd, &ich, 1) > 0)
	if (ich != '\n' && ich != '\r')
	    serverdata[cursd++] = ich;
	else {
	    serverdata[cursd] = 0;
	    arc4hashpush(serverdata);
	    if (cursd) {
		cursd = 0;
		return parsedata();
	    }
	}
    return 1;
}

void parseinput(void)
{
    int i = 0, j = 0, outcol = 0, found = 0;

    arc4hashpush(linein);
    while (linein[i] == ' ')
	++i;
    if (linein[i] == '\0')
	return;
    if (linein[i] == COMMANDCHAR) {
	++i;
	if (linein[i] == ' ')
		j = ++i;
	while (linein[i] == ' ')
		++i;
	if (linein[i] == '\0')
		return;
    }

    strlcpy(inputbuf, linein, 512);
    tok_out[i = 0] = strtok(inputbuf," ");
    while((tok_out[++i] = strtok(NULL, " ")) != NULL);
    if (!dumb) {
	tputs_x(tgoto(cap_cm, 0, maxlin - 2));
	putchar('\n');
    }
    if (j) {
	linein += j;
	j = 1;
	goto do_say;
    }
    if (*tok_out[0] == COMMANDCHAR) {
	tok_out[0]++;
	for (i = 0; (size_t)i < strlen(tok_out[0]) && isalpha(tok_out[0][i]); i++)
	    tok_out[0][i] = toupper(tok_out[0][i]);
	for (i = 0; i < LISTSIZE && !found; i++)
	    found = (strncmp(cmdlist[i], tok_out[0], strlen(tok_out[0])) == 0);
	i--;
	if (!found) {
	    printf("*** Invalid command");
	    return;
	}
	if (i == DO_ME) {
		if (object == NULL || object->name == NULL) {
			printf("*** Nowhere to send");
			return;
		}
		while ((*linein) && (*linein != ' '))
			++linein;
		snprintf(lineout, LINELEN, "PRIVMSG %s :%cACTION%s%c\n",
		    object->name, 1, linein, 1);
		outcol = printf("* %s", IRCNAME);
		j = 0;
		while(tok_out[++j])
		   outcol = wordwrapout(tok_out[j], outcol);
		goto parseinput_done;
	}
	if (i == DO_DESCRIBE) {
		while ((*linein) && (*linein != ' '))
			++linein;
		while ((*linein) && (*linein == ' '))
			++linein;
		tmp = linein;
		while ((*linein) && (*linein != ' '))
			++linein;
		if (!*tmp || !*linein || tmp >= linein) {
			printf("*** Nothing to send");
			return;
		}
		*linein++ = '\0';
		if (!strcmp(tmp, "*")) {
			if (object == NULL || (tmp = object->name) == NULL) {
				printf("*** Nowhere to send");
				return;
			}
		} else if (object && object->name && strcmp(tmp, object->name))
			pushlastchan(tmp);
		snprintf(lineout, LINELEN, "PRIVMSG %s :\001ACTION %s\001\n",
		    tmp, linein);
		if (*tmp == '#')
			outcol = printf("* %s:%s", IRCNAME, tmp);
		else
			outcol = printf("*-> %s: %s", tmp, IRCNAME);
		linein[-1] = ' ';
		j = 1;
		while(tok_out[++j])
			outcol = wordwrapout(tok_out[j], outcol);
		goto parseinput_done;
	}
	if (i == DO_CTCP) {
		char *tmp2;

		while ((*linein) && (*linein != ' '))
			++linein;
		while ((*linein) && (*linein == ' '))
			++linein;
		tmp = linein;
		while ((*linein) && (*linein != ' '))
			++linein;
		if (!*tmp || !*linein || tmp >= linein) {
			printf("*** Nothing to send");
			return;
		}
		*linein++ = '\0';
		tmp2 = linein;
		while (*tmp2 && *tmp2 != ' ')
			*tmp2++ = toupper(*tmp2);
		if (!strcmp(tmp, "*")) {
			if (object == NULL || (tmp = object->name) == NULL) {
				printf("*** Nowhere to send");
				return;
			}
		} else if (object && object->name && strcmp(tmp, object->name))
			pushlastchan(tmp);
		snprintf(lineout, LINELEN, "PRIVMSG %s :\001%s\001\n",
		    tmp, linein);
		snprintf(bp, sizeof(bp),
		    "Sending a CTCP %s to %s", linein, tmp);
		linein[-1] = ' ';
		column = printf("*C*");
		outcol = wordwrapout(bp, outcol);
		goto parseinput_done;
	}
	if (i == DO_JOIN)
	    if ((newobj = finditem(tok_out[1], objlist)) != NULL) {
		object = newobj;
		wasdate = 0;
		printf("*** Now talking in %s", object->name);
		return;
	    }
	if (i == DO_MSG)
	    i = DO_PRIVMSG;
	if (i == DO_W) {
		snprintf(lineout, LINELEN, "WHOIS %s %s",
		    tok_out[1], tok_out[1]);
		outcol = printf("= %s", lineout);
		goto parseinput_cont;
	}
	if (i == DO_NAMES && !tok_out[1]) {
		if (object == NULL) {
			printf("*** Nowhere to send");
			return;
		}
		snprintf(lineout, LINELEN, "NAMES %s", object->name);
		outcol = printf("= %s", lineout);
		goto parseinput_cont;
	}

	if (i == DO_PRIVMSG || i == DO_JOIN || i == DO_NOTICE)
		pushlastchan(tok_out[1]);

	strlcpy(lineout, (i == DO_QUOTE) ? "" : cmdlist[i], LINELEN);
	j = 0;
	if (i == DO_QUIT)
	    snprintf(&lineout[strlen(lineout)], LINELEN - strlen(lineout),
		" :using %s (RANDOM=%u)", RELEASE_L, arc4random());
	outcol = printf("= %s", lineout);
	while (tok_out[++j]) {
	   snprintf(&lineout[strlen(lineout)], LINELEN - strlen(lineout),
		   "%s%s", ((j == numargs[i] &&
		   tok_out[j + 1] != NULL) ? " :" : " "), tok_out[j]);
	   outcol = wordwrapout(tok_out[j], outcol);
	}
	if (i == DO_NS && strstr(lineout, "%s") != NULL) {
		char ch;

		strlcpy(inputbuf, lineout, 384);
		tmp = inputbuf + 384;
		tputs_x(tgoto(cap_cm, 0, maxlin));
		tputs_x(cap_ce);
		printf("Password? ");
		fflush(stdout);
		while ((ch = getchar()) != '\n')
			if (ch == 8 || ch == 127) {
				if (tmp > inputbuf + 384)
					--tmp;
			} else if (tmp < inputbuf + sizeof(inputbuf) - 2)
				*tmp++ = ch;
		*tmp = '\0';
		wasdate = 0;
		tputs_x(tgoto(cap_cm, 0, maxlin));
		tputs_x(cap_ce);
		snprintf(lineout, LINELEN, inputbuf, inputbuf + 384);
		bzero(inputbuf, sizeof(inputbuf));
	}

 parseinput_cont:
	strlcat(lineout, "\n", LINELEN);
    } else {
	j = 0;
 do_say:
	if (object == NULL) {
	    printf ("*** Nowhere to send");
	    return;
	}
	snprintf(lineout, LINELEN, "PRIVMSG %s :%s\n", object->name, linein);
	outcol = printf("> %s", tok_out[j]);
	while(tok_out[++j])
	   outcol = wordwrapout(tok_out[j], outcol);
    }
 parseinput_done:
    sendline();
    idletimer = time(NULL);
}

void histupdate(void)
{
    linein = history[histline];
    curx = curli = strlen(linein);
    tputs_x(tgoto(cap_cm, 0, maxlin));
    printf("%s", &linein[(curli / maxcol) * maxcol]);
    tputs_x(cap_ce);
}

void printpartial(int fromx)
{
    int i;
    tputs_x(tgoto(cap_cm, 0, maxlin));
    for(i = fromx; i < fromx + maxcol && i < curli; i++)
	putchar(linein[i]);
    tputs_x(cap_ce);
    tputs_x(tgoto(cap_cm, curx % maxcol, maxlin));
}

void userinput(void)
{
    int i, z;
    char ch;
    static int lasttab = -1;

    if (dumb) {
	fgets(linein, 500, stdin);
	tmp = strchr(linein, '\n');
	if (tmp != NULL)	/* get rid of newline */
	    *tmp = '\0';
	parseinput();
	putchar('\n');
    } else {
	read(stdinfd, &ch, 1);
	if (ch == '\177')
	    ch = '\10';
	if (ch != '\t')
		lasttab = -1;
	switch (ch) {
	case '\1':		/* C-a */
	    if (curx >= maxcol)
	        printpartial(curx = 0);
	    else
		tputs_x(tgoto(cap_cm, curx = 0, maxlin));
	    break;
	case '\10':		/* C-h */
	    if (curx)
	case '\4':		/* C-d */
	    if (curli) {
		if ((ch == '\4') && (curx < curli))
		    curx++;
		if (curli == curx)
		    linein[(--curx)] = '\0';
		else		/* delete somewhere in the middle */
		    for (i = (--curx); i < curli; i++)
			linein[i] = linein[i + 1];
		curli--;
		if (cap_dc != NULL && curx % maxcol != maxcol - 1) {
		    tputs_x(tgoto(cap_cm, curx % maxcol, maxlin));
		    tputs_x(cap_dc);
		} else
		    printpartial((curx / maxcol) * maxcol);
	    }
	    break;
	case '\2':		/* C-b */
	    if (curx > 0)
		curx--;
	    if (curx % maxcol == maxcol - 1)
		printpartial((curx / maxcol) * maxcol);
	    else
		tputs_x(tgoto(cap_cm, curx % maxcol, maxlin));
	    break;
	case '\3':		/* C-c */
	    beenden = 1;
	    break;
	case '\5':		/* C-e */
	    curx = curli;
	case '\14':		/* C-l */
	    dowinsz(2);
	    break;
	case '\6':		/* C-f */
	    if (curx < curli)
		curx++;
	    tputs_x(tgoto(cap_cm, curx % maxcol, maxlin));
	    break;
	case '\16':		/* C-n */
	    if ((++histline) >= HISTLEN)
		histline = 0;
	    histupdate();
	    break;
	case '\20':		/* C-p */
	    if ((--histline) < 0)
		histline = HISTLEN - 1;
	    histupdate();
	    break;
	case '\25':		/* ^U */
	case '\r':
	case '\n':
	    if (!curli)
		return;
	    tputs_x(tgoto(cap_cm, 0, maxlin));
	    tputs_x(cap_ce);
	    if (ch != '\25')
		parseinput();
	    if ((++histline) >= HISTLEN)
		histline = 0;
	    curx = curli = 0;
	    linein = history[histline];
	    break;
	case '\27':
	    if (object == NULL)
		break;
	    object = object->next;
	    if (object == NULL)
		object = objlist;
	    wasdate = 0;
	    break;
	case '\t':
	    if (++lasttab == 0) {
		if (lastchans[0] == NULL)
			break;
		if (curli) {
			if ((++histline) >= HISTLEN)
				histline = 0;
			linein = history[histline];
		}
	    }
	    for (;;) {
		if (lasttab >= NLASTCHAN)
			lasttab = 0;
		if (lastchans[lasttab])
			break;
		++lasttab;
	    }
	    snprintf(history[histline], 512, "/m %s ", lastchans[lasttab]);
	    histupdate();
	    break;
	case '\26':		/* ^V */
	    /* quote - press ^V^V^A to insert a ^A, it's invisible tho */
	    read(stdinfd, &ch, 1);
	    /* FALLTHROUGH */
	default:
	    if (curli < 499) {
		if (curli == curx) {	/* append character */
		    linein[++curli] = '\0';
		    linein[curx++] = ch;
		    putchar(ch);
		    tputs_x(cap_ce);
		} else {	/* insert somewhere in the middle */
		    for (i = (++curli); i >= curx; i--)
			linein[i + 1] = linein[i];
		    linein[curx] = ch;
		    for (i = (curx % maxcol); i < maxcol &&
			(z = (curx / maxcol) * maxcol + i) < curli; i++)
			putchar(linein[z]);
		    tputs_x(cap_ce);
		    curx++;
		}
	    }
	    break;
	}
    }
}

void cleanup(int sig)
{
    tputs_x(tgoto(cap_cs, -1, -1));
    tputs_x(tgoto(cap_cm, 0, maxlin));
    resetty();
    printf("\ngot signal %d\n", sig);
    exit(128 + sig);
}

static void
dowinch(int sig __attribute__((__unused__)))
{
	sigwinch = 1;
}

static void
dowinsz(int scrupdate)
{
	struct winsize ws;

	maxcol = maxlin = -1;
	if (ioctl(stdoutfd, TIOCGWINSZ, &ws) >= 0) {
		maxcol = ws.ws_col - 2;
		maxlin = ws.ws_row - 1;
	}
	if (maxcol < 5)
		maxcol = 78;
	if (maxlin < 5)
		maxlin = 23;

	wasdate = 0;
	if (scrupdate) {
		tputs_x(tgoto(cap_cs, maxlin - 2, 0));
		updatestatus();
		printpartial((curx / maxcol) * maxcol);
	}
}

int
main(int argc, char *argv[])
{
    char hostname[64];
    char *ircusername, *ircgecosname;
    int i;

    for (i = 0; i < NLASTCHAN; ++i)
	lastchans[i] = NULL;
    stdinfd = fileno(stdin);
    stdoutfd = fileno(stdout);
    ircusername = getenv("IRCUSER");
    ircgecosname = getenv("IRCNAME");
    if (!ircusername || !ircgecosname) {
	struct passwd *userinfo;
	userinfo = getpwuid(getuid());
	ircusername = ircusername ? ircusername : userinfo->pw_name;
	ircgecosname = ircgecosname ? ircgecosname : userinfo->pw_gecos;
    }
    strlcpy(hostname, DEFAULTSERVER, sizeof(hostname));
    tmp = getenv("IRCNICK");
    strlcpy(IRCNAME, tmp ? tmp : ircusername, sizeof(IRCNAME));
    if (argc > 1) {
	for (i = 1; i < argc; i++)
	    if (argv[i][0] == '-') {
		if (argv[i][1] == 'd')
		    dumb = 1;
		else {
		    fprintf(stderr, "usage: %s %s\n", argv[0],
			    "[nick] [server] [port] [-dumb]");
		    exit(1);
		}
	    } else if (strchr(argv[i], '.')) {
		strlcpy(hostname, argv[i], sizeof(hostname));
	    } else if (atoi(argv[i]) > 255) {
		IRCPORT = atoi(argv[i]);
	    } else
		strlcpy(IRCNAME, argv[i], sizeof(IRCNAME));
    }
    printf("*** trying port %d of %s\n\n", IRCPORT, hostname);
    if ((sockfd = makeconnect(hostname)) < 0) {
	fprintf(stderr, "*** %s connection refused, aborting\n", hostname);
	exit(0);
    }
    if (gethostname(localhost, sizeof(hostname)) || !*localhost)
	strlcpy(localhost, "localhost", sizeof(hostname));
    snprintf(lineout, LINELEN, "USER %s %s %s :%s\n", ircusername,
	localhost, hostname, ircgecosname);
    sendline();
    snprintf(lineout, LINELEN, "NICK :%s\n", IRCNAME);
    sendline();
    idletimer = time(NULL);
    if (!dumb) {
	ptr = termcap;
	if ((term = getenv("TERM")) == NULL) {
	    fprintf(stderr, "tinyirc: TERM not set\n");
	    exit(1);
	}
	if (tgetent(bp, term) < 1) {
	    fprintf(stderr, "tinyirc: no termcap entry for %s\n", term);
	    exit(1);
	}
	if ((cap_cm = tgetstr(s_cm, &ptr)) == NULL)
		cap_cm = tgetstr(s_CM, &ptr);
	if ((cap_so = tgetstr(s_so, &ptr)) == NULL)
		cap_so = null;
	if ((cap_se = tgetstr(s_se, &ptr)) == NULL)
		cap_se = null;
	cap_cs = tgetstr(s_cs, &ptr);
	cap_ce = tgetstr(s_ce, &ptr);
	cap_dc = tgetstr(s_dc, &ptr);
	dowinsz(0);
	if (!cap_cm || !cap_cs || !cap_ce) {
	    printf("tinyirc: sorry, no termcap cm,cs,ce: dumb mode set\n");
	    dumb = 1;
	}
	if (!dumb) {
	    signal(SIGINT, cleanup);
	    signal(SIGHUP, cleanup);
	    signal(SIGKILL, cleanup);
	    signal(SIGQUIT, cleanup);
	    signal(SIGSTOP, cleanup);
	    signal(SIGSEGV, cleanup);
	    signal(SIGWINCH, dowinch);
	    savetty();
	    raw();
	    tputs_x(tgoto(cap_cs, maxlin - 2, 0));
	    updatestatus();
	}
    }
    for (i = 0; i < HISTLEN; i++)
	history[i] = calloc(512, sizeof(char));
    linein = history[histline = 0];
    while (sok && !beenden) {
	FD_ZERO(&readfs);
	FD_SET(sockfd, &readfs);
	FD_SET(stdinfd, &readfs);
	if (!dumb) {
	    time_out.tv_sec = 61;
	    time_out.tv_usec = 0;
	}
	i = select(FD_SETSIZE, &readfs, NULL, NULL, (dumb ? NULL : &time_out));
	if (i < 0 && errno != EINTR)
	    beenden = 1;
	else if (i > 0) {
	    if (FD_ISSET(stdinfd, &readfs))
		userinput();
	    if (FD_ISSET(sockfd, &readfs))
		sok = serverinput();
	    if (!wasdate)
		updatestatus();
	} else if (sigwinch) {
	    dowinsz(1);
	    sigwinch = 0;
	} else
	    updatestatus();
	if (!dumb) {
	    tputs_x(tgoto(cap_cm, curx % maxcol, maxlin));
	    fflush(stdout);
	}
    }
    if (!dumb) {
	tputs_x(tgoto(cap_cs, -1, -1));
	tputs_x(tgoto(cap_cm, 0, maxlin));
	resetty();
    }
    exit(0);
}

static void
pushlastchan(char *cname)
{
	int i;

	for (i = 0; i < NLASTCHAN; ++i)
		if (lastchans[i] && !strcmp(lastchans[i], cname))
			break;
	if (i < NLASTCHAN)
		cname = lastchans[i];
	else {
		if ((cname = strdup(cname)) == NULL)
			return;
		i = NLASTCHAN - 1;
		if (lastchans[i])
			free(lastchans[i]);
	}
	while (i > 0) {
		lastchans[i] = lastchans[i - 1];
		--i;
	}
	lastchans[0] = cname;
}

#if 0
.endif

PROG=		tinyirc
NOMAN=		Yes

.ifdef SMALL
CPPFLAGS+=	-D_USE_OLD_CURSES_
LDADD+=		-lotermcap
DPADD+=		${LIBOTERMCAP}
.else
LDADD+=		-ltermcap
DPADD+=		${LIBTERMCAP}
.endif

.include <bsd.prog.mk>
#endif
@


1.42
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d51 1
a51 1
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@


1.41
log
@now that I got Hash.cs compiled and run, I’m amazed; make NZAAT (and NZAT!) all green with a small tweak; bit distribution and χ2 look OK as well
@
text
@d34 1
a34 1
   Copyright (c) 1999-2011 Thorsten Glaser <tg@@mirbsd.org>
d86 1
a86 1
#define	__RCSID(x)	static const char __rcsid[] __attribute__((used)) = (x)
d89 1
a89 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.40 2011/07/06 22:22:04 tg Exp $");
d1100 1
a1100 1
dowinch(int sig __attribute__((unused)))
@


1.40
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d27 1
a27 1
#define RELEASE_VER	"TinyIRC 20100921"
d89 1
a89 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.39 2010/09/21 21:24:03 tg Exp $");
d217 2
@


1.39
log
@use arc4random() a bit more efficiently
@
text
@d34 1
a34 1
   Copyright (c) 1999-2010 Thorsten Glaser <tg@@mirbsd.org>
d89 1
a89 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.38 2009/12/27 22:25:58 tg Exp $");
d206 1
a206 1
		s = arc4random() & 0xFFFFFF00;
d211 1
@


1.38
log
@fix a segfault (NULL pointer deref) and some more related weirdnesses
@
text
@a25 9
#if defined(__CYGWIN__) || defined(WIN32)
#define RELEASE_PAPI	"Win32"
#elif defined(__MirBSD__)
#define RELEASE_PAPI	"pushb"
#elif defined(arc4random_pushk)
#define RELEASE_PAPI	"pushk"
#else
#define RELEASE_PAPI	"none"
#endif
d27 1
a27 1
#define RELEASE_VER	"TinyIRC 20091227"
d34 1
a34 1
   Copyright (c) 1999-2009 Thorsten Glaser <tg@@mirbsd.org>
d89 1
a89 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.37 2009/11/29 15:21:20 tg Exp $");
d98 11
a108 3
#elif !defined(__MirBSD__)
#ifdef arc4random_pushk
#define arc4random_pushb arc4random_pushk
d110 2
a111 3
#define arc4random_pushb(buf, len) arc4random_addrandom((u_char *)(buf), \
	    (int)(len))
#endif
d221 1
a221 1
	arc4random_pushb(&pv, sizeof(pv));
d442 1
a442 1
		arc4random_pushb(serverdata, sizeof(serverdata));
d460 1
a460 1
		arc4random_pushb(serverdata, sizeof(serverdata));
@


1.37
log
@these days, arc4random_pushb(3) timestamps, and it’s reasonable to assume
so; also sync
@
text
@d36 1
a36 1
#define RELEASE_VER	"TinyIRC 20091129"
d98 1
a98 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.36 2009/08/02 14:35:00 tg Exp $");
d722 1
a722 1
    int i, j, outcol = 0, found = 0;
d725 3
a727 1
    if (*linein == '\0')
d729 9
d746 5
a751 8
	if (!tok_out[0][1]) {
		j = 1;
		while ((*linein) && (*linein != ' '))
			++linein;
		while ((*linein) && (*linein == ' '))
			++linein;
		goto do_say;
	}
@


1.36
log
@CTCP RANDOM is now part of the new RANDEX protocol as well
@
text
@d5 1
a5 1
/* Debian: gcc -O2 -s -o tinyirc tinyirc.c -lbsd -ltermcap -lz */
d30 2
d36 1
a36 1
#define RELEASE_VER	"TinyIRC 20090802"
d98 1
a98 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.35 2009/01/18 15:44:09 tg Exp $");
d108 3
d114 1
a114 2

extern unsigned long adler32(unsigned long, const void *, unsigned int);
d197 2
a198 1
void arc4adlerpush(const void *);
d200 1
a200 1
void arc4adlerpush(const void *buf)
d202 7
a208 2
	static unsigned long s = 1;
	time_t v;
d210 14
a223 4
	v = arc4random();
	s = adler32(adler32(s, &v, sizeof(v)), buf, strlen(buf));
	v = time(NULL) ^ (time_t)s;
	arc4random_pushb(&v, sizeof(v));
d309 1
a309 1
    arc4adlerpush(lineout);
d711 1
a711 1
	    arc4adlerpush(serverdata);
d724 1
a724 1
    arc4adlerpush(linein);
a1277 3
LDADD+=		-lz
DPADD+=		${LIBZ}

@


1.35
log
@bugfixes
@
text
@d14 1
d26 9
a34 1
#define RELEASE_VER	"TinyIRC 20090118"
d37 1
d39 1
a39 1
   TinyIRC – MirOS Fork
d41 1
a41 1
   Copyright (c) 1999-2008 Thorsten Glaser <tg@@mirbsd.org>
d60 6
a65 3

   Please visit the MirBSD project pages
   at http://mirbsd.de/ or http://www.mirbsd.org/
d96 1
a96 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.34 2009/01/17 14:08:22 tg Exp $");
d201 1
a201 1
	s = adler32(adler32(s, &v, sizeof (v)), buf, strlen(buf));
d203 1
a203 1
	arc4random_pushb(&v, sizeof (v));
d374 1
a374 1
	strlcpy(IRCNAME, tok_in[2], sizeof (IRCNAME));
d424 2
a425 2
		arc4random_pushb(serverdata, sizeof (serverdata));
		snprintf(bp, sizeof (bp),
d441 13
d461 2
a462 2
		    "NOTICE %s :\001CLIENTINFO ACTION, CLIENTINFO, "
		    "ECHO, ENTROPY, ERRMSG, PING, TIME, VERSION\001\n",
d493 1
a493 1
		snprintf(bp, sizeof (bp), "%s did a CTCP %s%s%s to %s",
d554 1
a554 1
	    if (strlen(IRCNAME) < sizeof (IRCNAME) - 1)
d808 1
a808 1
		snprintf(bp, sizeof (bp),
d868 1
a868 1
			} else if (tmp < inputbuf + sizeof (inputbuf) - 2)
d875 1
a875 1
		bzero(inputbuf, sizeof (inputbuf));
d1118 1
a1118 1
    strlcpy(hostname, DEFAULTSERVER, sizeof (hostname));
d1120 1
a1120 1
    strlcpy(IRCNAME, tmp ? tmp : ircusername, sizeof (IRCNAME));
d1132 1
a1132 1
		strlcpy(hostname, argv[i], sizeof (hostname));
d1136 1
a1136 1
		strlcpy(IRCNAME, argv[i], sizeof (IRCNAME));
d1143 2
a1144 2
    if (gethostname(localhost, sizeof (hostname)) || !*localhost)
	strlcpy(localhost, "localhost", sizeof (hostname));
@


1.34
log
@fix on leenocks
@
text
@d25 1
a25 1
#define RELEASE_VER	"TinyIRC 20090117"
d83 1
a83 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.33 2009/01/08 20:23:32 tg Exp $");
d1117 2
a1118 1
    gethostname(localhost, sizeof (hostname));
@


1.33
log
@do unto these my favourites the same, in a slightly more standardised
and hooked way as the plugin one, with some quirks for tinyirc
@
text
@d5 2
d20 2
d25 1
a25 1
#define RELEASE_VER	"TinyIRC 20090108"
d83 1
a83 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.32 2008/12/29 22:19:26 tg Exp $");
d93 1
a93 1
#define arc4random_pushb(buf, len) arc4random_addrandom((u_char *)(buf),
@


1.32
log
@• fix mail addresses
• bump IRCNAME size
• change a few hard-coded lengths with sizeof ()
• fix compilation with pcc
• bump version
@
text
@d21 1
a21 1
#define RELEASE_VER	"TinyIRC 20081229"
d79 1
a79 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.31 2008/12/29 22:12:42 tg Exp $");
d93 2
d176 12
d272 1
d661 1
d674 1
d1227 3
@


1.31
log
@now do the signal handling right
@
text
@d21 1
a21 1
#define RELEASE_VER	"TinyIRC 20081220"
d24 4
a27 5
/* tinyirc 1.0

   TinyIRC Alpha Release
   Copyright (C) 1994 Nathan I. Laredo
   Copyright (c) 1999-2008 Thorsten Glaser
a45 4
   Send your comments and all your spare pocket change to
   laredo@@gnu.ai.mit.edu (Nathan Laredo) or to 1604 Lilac Lane,
   Plano, TX 75074, USA.  Any donations are welcome.

d60 1
d79 1
a79 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.30 2008/12/29 22:07:07 tg Exp $");
d104 1
a104 1
*ptr, *term, *fromhost, IRCNAME[10], inputbuf[512], beenden = 0;
d342 1
a342 1
	strlcpy(IRCNAME, tok_in[2], 10);
d509 1
a509 1
	    if (strlen(IRCNAME) < 9)
d1071 3
a1073 2
    strlcpy(hostname, DEFAULTSERVER, 64);
    strlcpy(IRCNAME, getenv("IRCNICK") ? : ircusername, sizeof (IRCNAME));
d1085 1
a1085 1
		strlcpy(hostname, argv[i], 64);
d1089 1
a1089 1
		strncpy(IRCNAME, argv[i], sizeof(IRCNAME));
d1096 1
a1096 1
    gethostname(localhost, 64);
@


1.30
log
@make ocurses compatible
@
text
@d83 1
a83 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.29 2008/12/29 21:52:53 tg Exp $");
d887 1
a887 14
	ssize_t rv;

 again:
	rv = read(stdinfd, &ch, 1);
	if (sigwinch) {
		dowinsz(1);
		sigwinch = 0;
	}
	if (rv == -1 && errno == EINTR)
		goto again;
	if (rv < 1 || ch == 3) {
		beenden = 1;
		return;
	}
d926 3
d1155 4
a1158 1
	if (select(FD_SETSIZE, &readfs, NULL, NULL, (dumb ? NULL : &time_out))) {
d1165 3
@


1.29
log
@use TIOCGWINSZ, not termcap
@
text
@d72 1
d74 1
d83 1
a83 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.27 2008/12/20 17:29:44 tg Exp $");
d104 2
a105 1
int sockfd, sok = 1, stdinfd, stdoutfd, histline, dumb = 0, CO, LI, column;
d109 1
a109 2
const char *CM, *CS, *CE, *SO, *SE, *DC;
char bp[4096];
d119 1
a119 2
char s_co[] = "co";
char s_li[] = "li";
d136 5
a140 1
#define	tputs_x(s) (tputs(s,0,putchar))
d274 2
a275 2
	    tputs_x(tgoto(CM, 0, LI - 2));
	    tputs_x(SO);
d279 1
a279 1
	    for (; n < CO; n++)
d281 1
a281 1
	    tputs_x(SE);
d506 2
a507 2
	tputs_x(tgoto(CM, 0, LI - 1));
	tputs_x(CE);
d520 2
a521 2
	tputs_x(tgoto(CM, 0, LI - 1));
	tputs_x(CE);
d575 1
a575 1
	if (strlen(ptrx) < CO - count)
d594 1
a594 1
	tputs_x(tgoto(CM, 0, LI - 3));
d669 1
a669 1
	tputs_x(tgoto(CM, 0, LI - 3));
d817 2
a818 2
		tputs_x(tgoto(CM, 0, LI - 1));
		tputs_x(CE);
d829 2
a830 2
		tputs_x(tgoto(CM, 0, LI - 1));
		tputs_x(CE);
d858 3
a860 3
    tputs_x(tgoto(CM, 0, LI - 1));
    printf("%s", &linein[(curli / CO) * CO]);
    tputs_x(CE);
d866 2
a867 2
    tputs_x(tgoto(CM, 0, LI - 1));
    for(i = fromx; i < fromx + CO && i < curli; i++)
d869 2
a870 2
    tputs_x(CE);
    tputs_x(tgoto(CM, curx % CO, LI - 1));
d907 1
a907 1
	    if (curx >= CO)
d910 1
a910 1
		tputs_x(tgoto(CM, curx = 0, LI - 1));
d924 3
a926 3
		if (DC != NULL && curx % CO != CO - 1) {
		    tputs_x(tgoto(CM, curx % CO, LI - 1));
		    tputs_x(DC);
d928 1
a928 1
		    printpartial((curx / CO) * CO);
d934 2
a935 2
	    if (curx % CO == CO - 1)
		printpartial((curx / CO) * CO);
d937 1
a937 1
		tputs_x(tgoto(CM, curx % CO, LI - 1));
d947 1
a947 1
	    tputs_x(tgoto(CM, curx % CO, LI - 1));
d964 2
a965 2
	    tputs_x(tgoto(CM, 0, LI - 1));
	    tputs_x(CE);
d1011 1
a1011 1
		    tputs_x(CE);
d1016 2
a1017 2
		    for (i = (curx % CO); i < CO &&
			(z = (curx / CO) * CO + i) < curli; i++)
d1019 1
a1019 1
		    tputs_x(CE);
d1030 2
a1031 2
    tputs_x(tgoto(CS, -1, -1));
    tputs_x(tgoto(CM, 0, LI - 1));
d1048 1
a1048 1
	CO = LI = -1;
d1050 2
a1051 2
		CO = ws.ws_col - 2;
		LI = ws.ws_row;
d1053 4
a1056 4
	if (CO < 5)
		CO = 78;
	if (LI < 5)
		LI = 24;
d1060 1
a1060 1
		tputs_x(tgoto(CS, LI - 3, 0));
d1062 1
a1062 1
		printpartial((curx / CO) * CO);
d1126 9
a1134 9
	if ((CM = tgetstr(s_cm, &ptr)) == NULL)
		CM = tgetstr(s_CM, &ptr);
	if ((SO = tgetstr(s_so, &ptr)) == NULL)
		SO = "";
	if ((SE = tgetstr(s_se, &ptr)) == NULL)
		SE = "";
	CS = tgetstr(s_cs, &ptr);
	CE = tgetstr(s_ce, &ptr);
	DC = tgetstr(s_dc, &ptr);
d1136 1
a1136 1
	if (!CM || !CS || !CE) {
d1150 1
a1150 1
	    tputs_x(tgoto(CS, LI - 3, 0));
d1175 1
a1175 1
	    tputs_x(tgoto(CM, curx % CO, LI - 1));
d1180 2
a1181 2
	tputs_x(tgoto(CS, -1, -1));
	tputs_x(tgoto(CM, 0, LI - 1));
d1217 5
d1224 1
@


1.28
log
@try some signal safety
@
text
@d59 1
d170 1
a170 1
static void tcsetup(int);
d887 1
a887 1
		tcsetup(1);
d937 1
a937 1
	    tcsetup(2);
d1039 1
a1039 1
tcsetup(int scrupdate)
d1041 6
a1046 3
	if (tgetent(bp, term) < 1) {
	    fprintf(stderr, "tinyirc: no termcap entry for %s\n", term);
	    exit(1);
d1048 1
a1048 1
	if ((CO = tgetnum(s_co) - 2) < 1)
d1050 1
a1050 1
	if ((LI = tgetnum(s_li)) == -1)
d1052 1
a1052 9
	if ((CM = tgetstr(s_cm, &ptr)) == NULL)
		CM = tgetstr(s_CM, &ptr);
	if ((SO = tgetstr(s_so, &ptr)) == NULL)
		SO = "";
	if ((SE = tgetstr(s_se, &ptr)) == NULL)
		SE = "";
	CS = tgetstr(s_cs, &ptr);
	CE = tgetstr(s_ce, &ptr);
	DC = tgetstr(s_dc, &ptr);
d1117 14
a1130 1
	tcsetup(0);
@


1.27
log
@add a SIGWINCH handler and appropriate termcap handling; bump vsn
@
text
@d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.26 2008/12/20 17:02:04 tg Exp $");
d881 4
a884 1
	read(stdinfd, &ch, 1);
d889 6
a932 3
	case '\3':		/* C-c */
	    beenden = 1;
	    break;
@


1.26
log
@clear inputbuf from password later
@
text
@d21 1
a21 1
#define RELEASE_VER	"TinyIRC 20081209"
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.25 2008/12/20 17:01:31 tg Exp $");
d114 1
d168 2
d882 4
d930 1
a930 1
	    printpartial((curx / CO) * CO);
d1025 34
d1115 2
a1116 16
	if (tgetent(bp, term) < 1) {
	    fprintf(stderr, "tinyirc: no termcap entry for %s\n", term);
	    exit(1);
	}
	if ((CO = tgetnum(s_co) - 2) < 1)
	    CO = 78;
	if ((LI = tgetnum(s_li)) == -1)
	    LI = 24;
	if ((CM = tgetstr(s_cm, &ptr)) == NULL)
	    CM = tgetstr(s_CM, &ptr);
	if ((SO = tgetstr(s_so, &ptr)) == NULL)
	    SO = "";
	if ((SE = tgetstr(s_se, &ptr)) == NULL)
	    SE = "";
	if (!CM || !(CS = tgetstr(s_cs, &ptr)) ||
	    !(CE = tgetstr(s_ce, &ptr))) {
a1120 2
	    DC = tgetstr(s_dc, &ptr);
	    wasdate = 0;
d1127 1
@


1.25
log
@make it work in screen: libotermcap has wrong “li” capability
@
text
@d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.24 2008/12/20 16:58:22 tg Exp $");
d823 1
@


1.24
log
@• add /ns command (freenode: nickserv)
• for /ns, if “%s” is found, ask for password and substitute
• integrate a BSDmakefile in the .c file
@
text
@d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.23 2008/12/09 20:37:12 tg Exp $");
d1170 2
a1171 2
LDADD+=		-lotermcap
DPADD+=		${LIBOTERMCAP}
@


1.23
log
@add " (RANDOM=%u)" to quit message too, like MirSirc
@
text
@d1 4
d21 3
a23 2
#define RELEASE_L	"TinyIRC 20081209 (" RELEASE_OS ") MirOS-contrib"
#define RELEASE_S	"TinyIRC MirOS"
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.22 2008/12/09 20:27:02 tg Exp $");
d520 1
a520 1
#define	LISTSIZE	54
d533 1
d541 1
a541 1
 "ME", "DESCRIBE", "CTCP"};
d549 1
a549 1
 1, 1, 1
d558 1
a558 1
 nop, nop, nop
d803 22
d1163 12
@


1.22
log
@the randex protocol bearers shall be identifyable by a CTCP CLIENTINFO
entry of "ENTROPY" as well as their user agent (CTCP VERSION) matching
".*[[:space:]]\(RANDOM=[0-9]*\).*" so no negatives over here
@
text
@d75 1
a75 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.21 2008/12/09 19:48:35 tg Exp $");
d789 1
a789 1
		" :using %s ", RELEASE_L);
@


1.21
log
@catch some NULL pointer derefs and one uninitialised variable at -O0/-O1
@
text
@d75 1
a75 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.20 2008/12/09 18:34:41 tg Exp $");
d401 1
a401 1
		    "NOTICE %s :\001VERSION %s (RANDOM=%d)\001\n",
@


1.20
log
@work on cygwin
@
text
@d75 1
a75 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.19 2008/12/02 17:12:00 tg Exp $");
d263 2
a264 2
			timenow->tm_min, IRCNAME, (object->name == NULL ?
			"*" : object->name), RELEASE_S);
d429 1
a429 1
		else if (object != NULL &&
d452 2
a453 1
    else if (object != NULL && my_stricmp(object->name, tok_in[2]))
d645 1
a645 1
    int i, j, outcol, found = 0;
d677 1
a677 1
		if (object == NULL) {
d704 6
a709 3
		if (!strcmp(tmp, "*"))
			tmp = object->name;
		if (strcmp(tmp, object->name))
d741 6
a746 3
		if (!strcmp(tmp, "*"))
			tmp = object->name;
		if (strcmp(tmp, object->name))
@


1.19
log
@fix /w trailing newline and add /names-without-argument protection
@
text
@d8 10
a17 1
#define RELEASE_L	"TinyIRC 20081202 MirOS-contrib"
d75 1
a75 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.18 2008/12/02 16:46:19 tg Exp $");
d81 8
a381 1
#ifdef __MirBSD__
a382 4
#else
		arc4random_addrandom((unsigned char *)serverdata,
		    (int)sizeof (serverdata));
#endif
@


1.18
log
@fix missing argument
@
text
@d66 1
a66 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.17 2008/12/02 16:37:00 tg Exp $");
d514 1
d665 2
a666 2
		    printf ("*** Nowhere to send");
		    return;
d687 1
a687 1
			printf ("*** Nothing to send");
d718 1
a718 1
			printf ("*** Nothing to send");
d748 1
a748 1
		snprintf(lineout, LINELEN, "WHOIS %s %s\n",
d751 10
a760 1
		goto parseinput_done;
d778 1
@


1.17
log
@* fix history for those who manipulate *linein
* add mirsirc-like tab completion of talk channels, albeit
  in a 12-entry buffer, with /j /de /ctcp /n contributing
  as well, and history-safe

why am I still hacking on two(!) IRC clients under GNU GPL(!)
(tinyirc GPLv1, sirc GPLv2) in languages which are so totally
not suited for it (tinyirc C, sirc perl4), instead of hacking
an irc client in mksh, MirOS licenced, using ssfe until there
is an ssfe clone under MirOS Licence as well?
@
text
@d66 1
a66 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.16 2008/12/02 15:18:58 tg Exp $");
d377 2
a378 1
		snprintf(lineout, LINELEN, "NOTICE %s :\001RANDOM ");
@


1.16
log
@* add a rudimentary CTCP enquiry (PRIVMSG) yet not response (NOTICE)
  handler and informator for the following cases:
  - ENTROPY (randex protocol, other party is initiator) => no print
  - VERSION, CLIENTINFO, TIME (standard behaviour)
  - PING, ECHO, ERRMSG (just echo back)
  - ACTION (/me, /de[scribe]) => no print
  - generic (no handler, just print)
* add /describe (/de) and /ctcp commands (* == current talk channel)
* fix /me output to be in sync
* add sole / command (similar to /say), like in MirSirc
* fix /w X command to do /q whois X X
@
text
@d66 1
a66 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.15 2008/12/02 13:34:28 tg Exp $");
d85 2
d146 1
d512 1
d691 2
d699 1
d725 2
d731 1
d752 3
d808 2
d821 2
d902 20
d965 2
d1080 24
@


1.15
log
@make this compile on GNU/Linux (with -ltermcap -lbsd)
@
text
@a0 2
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.14 2007/07/18 21:17:44 tg Exp $ */

d8 1
a8 1
#define RELEASE_L	"TinyIRC 20070718 MirOS-contrib"
d14 1
a14 1
   Copyright (c) 1999-2007 Thorsten Glaser
a19 5
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

a39 8

   Missing features:
    * KNF - man 9 style
    * Security auditing
   Added:
    * /quote command (shortcut: Q)
    * command re-ordering for shortcuts
    * ^C command for instant exiting
d66 1
a66 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.14 2007/07/18 21:17:44 tg Exp $");
d350 84
d498 1
a498 1
#define	LISTSIZE	52
d507 2
d516 1
a516 1
 "ME"};
d524 1
a524 1
 1
d533 1
a533 1
 nop
d639 8
d666 1
a666 1
		outcol = printf("*");
d672 54
d735 6
a740 2
	if (i == DO_W)
	    i = DO_WHOIS;
d756 2
d763 1
a763 1
	outcol = printf("> %s", tok_out[j = 0]);
@


1.14
log
@fix ^D sigsegv and add comment how to use quote
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.13 2007/07/18 20:30:43 tg Exp $ */
d74 1
d81 5
a85 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.13 2007/07/18 20:30:43 tg Exp $");
@


1.13
log
@implement quoting and fix ctrl-d at bol (or so I hope)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.12 2007/07/17 20:08:16 tg Exp $ */
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.12 2007/07/17 20:08:16 tg Exp $");
d672 1
a672 1
	    {
d742 1
@


1.12
log
@allow overriding the irc username, too
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.11 2007/07/17 19:23:04 tg Exp $ */
d10 1
a10 1
#define RELEASE_L	"TinyIRC 20070717 MirOS-contrib"
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.11 2007/07/17 19:23:04 tg Exp $");
d669 2
d672 1
a672 2
	case '\10':		/* C-h */
	    if (curx) {
d741 3
@


1.11
log
@use irc.mirbsd.org:6667 (i.e., freenode)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.10 2006/12/20 16:28:20 tg Exp $ */
d16 1
a16 1
   Copyright (c) 1999-2006 Thorsten Glaser
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.10 2006/12/20 16:28:20 tg Exp $");
a99 1
struct passwd *userinfo;
d776 1
d781 8
a788 1
    userinfo = getpwuid(getuid());
d790 1
a790 4
    if (!getenv("IRCNICK"))
	strncpy(IRCNAME, userinfo->pw_name, sizeof(IRCNAME));
    else
	strncpy(IRCNAME, (char *) getenv("IRCNICK"), sizeof(IRCNAME));
d814 2
a815 6
    if (!getenv("IRCNAME"))
	snprintf(lineout, LINELEN, "USER %s %s %s :%s\n", userinfo->pw_name,
		localhost, hostname, userinfo->pw_gecos);
    else
	snprintf(lineout, LINELEN, "USER %s %s %s :%s\n", userinfo->pw_name, localhost,
		hostname, (char *)getenv("IRCNAME"));
d822 1
a822 1
	if ((term = (char *) getenv("TERM")) == NULL) {
@


1.10
log
@licence, utf-8
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.9 2006/06/15 19:18:45 tg Exp $ */
a3 1
static const char DEFAULTSERVER[] = "irc.mirbsd.org";
d5 2
a6 1
#define DEFAULTPORT	6666
d10 1
a10 1
#define RELEASE_L	"TinyIRC 20060529 MirOS-contrib"
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.9 2006/06/15 19:18:45 tg Exp $");
@


1.9
log
@mirbsd.org, 66h.42h.de, bsdadvocacy.org, and whatnot
we changed that too often, try to clean up the mess
mostly outside the www/ module which is dead anyway.
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.8 2006/06/09 20:36:37 tg Exp $ */
d27 8
a34 8
   Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
   express, or implied, to the maximum extent permitted by applicable
   law, without malicious intent or gross negligence; in no event may
   licensor, an author or contributor be held liable for any indirect
   or other damage, or direct damage except proven a consequence of a
   direct error of said person and intended use of this work, loss or
   other issues arising in any way out of its use, even if advised of
   the possibility of such damage or existence of a nontrivial bug.
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.8 2006/06/09 20:36:37 tg Exp $");
@


1.8
log
@add explicit braces
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.7 2006/05/29 18:43:18 tg Exp $ */
d46 1
a46 1
   at http://mirbsd.de/ or http://mirbsd.org/
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.7 2006/05/29 18:43:18 tg Exp $");
@


1.7
log
@bump
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.6 2006/05/29 15:56:56 tg Exp $ */
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.6 2006/05/29 15:56:56 tg Exp $");
d673 1
a673 1
		if (ch == '\4' && curx < curli)
@


1.6
log
@add ^U (command line editing), /me (command)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.5 2006/05/21 11:10:51 tg Exp $ */
d10 1
a10 1
#define RELEASE_L	"TinyIRC 20060521 MirOS-contrib"
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.5 2006/05/21 11:10:51 tg Exp $");
@


1.5
log
@__CRAZY=Yes clean
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.4 2006/05/21 10:53:15 tg Exp $ */
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.4 2006/05/21 10:53:15 tg Exp $");
d425 1
a425 1
#define	LISTSIZE	51
d433 1
d440 2
a441 1
 "USERHOST", "USERS", "VERSION", "W", "WALLOPS", "WHO", "WHOIS", "WHOWAS"};
d448 2
a449 1
 1, 1, 1, 1, 1, 1, 1, 1
d457 2
a458 1
 nop, nop, nop, nop, nop, nop, nop, nop
d574 15
d624 1
d719 1
d726 2
a727 1
	    parseinput();
@


1.4
log
@* get rid of sgtty
* sort includes
* const char *...
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.3 2006/05/21 10:48:26 tg Exp $ */
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.3 2006/05/21 10:48:26 tg Exp $");
d90 4
a93 3
char *CM, *CS, *CE, *linein, lineout[LINELEN], *history[HISTLEN], localhost[64],
*SO, *SE, *tok_in[256], *tok_out[256], *tmp, serverdata[512], termcap[1024],
*DC, *ptr, *term, *fromhost, IRCNAME[10], inputbuf[512], beenden = 0;
d102 9
d120 1
a120 5
int putchar_x(c)
int c;
{
    return putchar(c);
}
d122 33
a154 1
#define	tputs_x(s) (tputs(s,0,putchar_x))
d156 1
a156 2
int my_stricmp(str1, str2)
char *str1, *str2;
d175 1
a175 3
struct dlist *additem(item, ptr)
char *item;
struct dlist *ptr;
d179 1
a179 1
    newobj->next = ptr;
d182 2
a183 3
struct dlist *finditem(item, ptr)
char *item;
struct dlist *ptr;
d185 2
a186 2
    while (ptr != NULL)
	if (my_stricmp(item, ptr->name) == 0)
d189 2
a190 2
	    ptr = ptr->next;
    return ptr;
d192 8
a199 9
struct dlist *removeitem(item, ptr)
char *item;
struct dlist *ptr;
{
    struct dlist *prev = NULL, *start = ptr;
    while (ptr != NULL) 
	if (my_stricmp(item, ptr->name) == 0) {
	    newobj = ptr->next;
	    if (object == ptr)
d201 1
a201 1
	    free (ptr);
d209 2
a210 2
	    prev = ptr;
	    ptr = ptr->next;
d214 2
a215 2
int makeconnect(hostname)
char *hostname;
d237 1
a237 1
int sendline()
d244 1
a244 1
void updatestatus()
d263 1
a263 1
static int nop()
d267 2
a268 1
static int doerror()
d273 2
a274 1
static int doinvite()
d280 2
a281 1
static int dojoin()
d291 2
a292 1
static int dokick()
d306 2
a307 1
static int dokill()
d312 2
a313 1
static int domode()
d318 2
a319 1
static int donick()
d328 2
a329 1
static int donotice()
d333 1
a333 1
    else 
d337 2
a338 1
static int dopart()
d352 2
a353 1
static int dopong()
d358 2
a359 1
static int doprivmsg()
d369 2
a370 1
static int doquit()
d375 2
a376 1
static int dosquit()
d380 2
a381 1
static int dotime()
d385 2
a386 1
static int dotopic()
d393 1
a393 2
int donumeric(num)
int num;
d433 1
a433 1
static char *cmdlist[LISTSIZE] =
d448 1
a448 1
static int (*docommand[LISTSIZE]) () =
d457 1
a457 3
int wordwrapout(ptr, count)
char *ptr;
int count;
d459 2
a460 2
    while(ptr != NULL) {
	if ((tmp = strchr(ptr, ' ')) != NULL)
d462 2
a463 2
	if (strlen(ptr) < CO - count)
	    count += printf(" %s", ptr);
d465 2
a466 2
	    count = printf("\n\r   %s", ptr);
	ptr = tmp;
d470 2
a471 1
int parsedata()
d529 3
a531 2
int serverinput()
{   char ich;
d545 1
a545 1
void parseinput()
d561 1
a561 1
	for (i = 0; i < strlen(tok_out[0]) && isalpha(tok_out[0][i]); i++)
d609 1
a609 1
void histupdate()
d618 1
a618 2
void printpartial(fromx)
int fromx;
d627 2
a628 1
void userinput()
d742 1
a742 2
void cleanup(sig)
int sig;
d752 1
a752 3
main(argc, argv)
int argc;
char **argv;
d808 1
a808 1
	if ((CO = tgetnum("co") - 2) < 1)
d810 1
a810 1
	if ((LI = tgetnum("li")) == -1)
d812 3
a814 3
	if ((CM = (char *) tgetstr("cm", &ptr)) == NULL)
	    CM = (char *) tgetstr("CM", &ptr);
	if ((SO = (char *) tgetstr("so", &ptr)) == NULL)
d816 1
a816 1
	if ((SE = (char *) tgetstr("se", &ptr)) == NULL)
d818 2
a819 2
	if (!CM || !(CS = (char *) tgetstr("cs", &ptr)) ||
	    !(CE = (char *) tgetstr("ce", &ptr))) {
d824 1
a824 1
	    DC = (char *) tgetstr("dc", &ptr);
d839 1
a839 1
	history[i] = (char *) calloc(512, sizeof(char));
@


1.3
log
@pimp my tinyirc, part 1: change server and metadata
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.2 2006/01/13 03:49:28 tg Exp $ */
d4 1
a4 1
static char *DEFAULTSERVER = "irc.mirbsd.org";
a56 16
#include <stdio.h>
#ifndef USETERMIOS
#include <sgtty.h>
#define	USE_OLD_TTY
#include <sys/ioctl.h>
#if !defined(sun) && !defined(sequent) && !defined(hpux) && \
	!defined(_AIX_)
#include <strings.h>
#define strchr index
#else
#include <string.h>
#endif
#else
#include <string.h>
#include <termios.h>
#endif
a57 1
#include <pwd.h>
a59 1
#include <fcntl.h>
d61 1
d63 3
d67 1
d69 1
a69 2
#include <ctype.h>
#include <curses.h>
d71 1
a71 1
#include <sys/uio.h>
d73 1
d77 1
a77 1
#define __RCSID(x)	static const char _rcsid[] = (x)
d80 1
a80 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.2 2006/01/13 03:49:28 tg Exp $");
a100 1
#ifdef	USETERMIOS
a108 10
#else
struct sgttyb _tty;
int _res_flg;
#define raw() (_tty.sg_flags |= RAW, _tty.sg_flags &= ~ECHO, \
	ioctl(stdinfd, TIOCSETP, &_tty))
#define savetty() ((void) ioctl(stdinfd, TIOCGETP, &_tty), \
	_res_flg = _tty.sg_flags)
#define resetty() (_tty.sg_flags = _res_flg, \
	(void) ioctl(stdinfd, TIOCSETP, &_tty))
#endif
@


1.2
log
@* mirbsd.bsdadvocacy.org -> www.66h.42h.de
* mirbsd.mirsolutions.de -> www.66h.42h.de (loses SSL)
* http*/cvs.cgi/ -> cvs.mirbsd.de
* mirsolutions.de -> mirbsd.org

No complete transition yet, but this helps a lot with
the recent and upcoming(!) domain issues.

Please use only http://mirbsd.de/ as mirror redirector
and only http://cvs.mirbsd.de/ as CVSweb redirector.
Please do not use mirbsd.de for anything else save eMail.
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/tinyirc.c,v 1.1.7.1 2005/02/05 02:36:15 tg Exp $ */
d4 1
a4 2
static char *DEFAULTSERVER = "217.160.142.142";
/*			reads: irc6.oftc.net         */
d6 1
a6 1
#define DEFAULTPORT	6667
d10 1
a10 1
#define RELEASE_L	"TinyIRC pre1.0-mirabile-MirOS-contrib"
d16 1
a16 1
   Copyright (c) 1999-2004 Thorsten Glaser
d27 9
d45 1
a45 3
   Please do not forget to donate to the OpenBSD project
   at http://www.OpenBSD.org/ - the daemons will thank you.
   While you're at it, visit the MirBSD project pages
d93 1
a93 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.1.7.1 2005/02/05 02:36:15 tg Exp $");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS$ */
d40 1
a40 1
   at http://mirbsd.de/ or http://mirbsd.bsdadvocacy.org/
d87 1
a87 1
__RCSID("$MirOS: contrib/code/Snippets/tinyirc.c,v 1.1.15.1 2004/12/19 14:25:08 tg Exp $");
@


1.1.7.1
log
@All the code in the contributed section
@
text
@@
