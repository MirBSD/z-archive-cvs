head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2008.11.19.02.30.52;	author tg;	state Rel;
branches;
next	1.16;
commitid	10049237A101B9540A4;

1.16
date	2008.11.19.02.17.30;	author tg;	state Rel;
branches;
next	1.15;
commitid	100492376F71A87F970;

1.15
date	2008.11.19.01.53.56;	author tg;	state Exp;
branches;
next	1.14;
commitid	100492371CA61A615F8;

1.14
date	2008.11.19.01.28.00;	author tg;	state Rel;
branches;
next	1.13;
commitid	10049236B5649C7EBE3;

1.13
date	2008.11.19.01.23.12;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004923691D46FAC75B;

1.12
date	2008.06.23.20.33.06;	author tg;	state Rel;
branches;
next	1.11;
commitid	1004860086F2669BB84;

1.11
date	2008.06.23.19.59.04;	author tg;	state Rel;
branches;
next	1.10;
commitid	1004860009D482BF650;

1.10
date	2008.06.23.19.02.17;	author tg;	state Stab;
branches;
next	1.9;
commitid	100485FF34C39182462;

1.9
date	2008.06.23.19.00.48;	author tg;	state Exp;
branches;
next	1.8;
commitid	100485FF2353AC04D3C;

1.8
date	2008.06.23.18.30.16;	author tg;	state Exp;
branches;
next	1.7;
commitid	100485FEBB726041D6D;

1.7
date	2008.06.23.18.14.38;	author tg;	state Exp;
branches;
next	1.6;
commitid	100485FE8144CC6B2B2;

1.6
date	2008.06.23.18.12.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	100485FE7A6360A80F3;

1.5
date	2008.06.23.18.06.42;	author tg;	state Exp;
branches;
next	1.4;
commitid	100485FE63B52902827;

1.4
date	2008.06.20.15.41.26;	author tg;	state Exp;
branches;
next	1.3;
commitid	100485BCF0A0402BA93;

1.3
date	2008.06.20.15.32.12;	author tg;	state Exp;
branches;
next	1.2;
commitid	100485BCD62648E5D9A;

1.2
date	2008.06.18.20.42.00;	author tg;	state Exp;
branches;
next	1.1;
commitid	10048597307731A162E;

1.1
date	2008.06.18.20.27.16;	author tg;	state Exp;
branches;
next	;
commitid	10048596EEC61D87BC9;


desc
@@


1.17
log
@use a more tabular output format for the demo, to show it better; clean up
@
text
@/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.16 2008/11/19 02:17:30 tg Rel $ */

/*-
 * $Id: coroutine.h $ is
 * Copyright (c) 2008
 *	Felix Fietkau <nbd@@openwrt.org>
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Thanks to Simon Tatham for the idea and a reference for the
 * implementation.  For more information about this, refer to:
 * http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
 */

/**
 * Information on how to use this header file:
 *
 * You will need to include <stdlib.h> for malloc/free, abort, NULL.
 * To create a coroutine, use this:

 * once per <typename>, in a header file:
__coroutine_decl(<typename>, <return type>, <arguments>);
__coroutine_decl_na(<typename>, <return type>);

 * once per function <name>, in a header file:
__coroutine_proto(<typename>, <name>, <return type>, <arguments>);
__coroutine_proto_na(<typename>, <name>, <return type>);

 * once per <typename>, in a source file, with no trailing semicolon:
__coroutine_impl(<typename>)

 * once per function <name>, in a source (*.c) file:
__coroutine_defn(<typename>, <name>, <return type>, <arguments>)
__coroutine_defn_na(<typename>, <name>, <return type>)
{
	<local variables>
	__cr_begin(<name>);
	< your code goes here >
	__cr_end(<name>);
	return (<value>);
}

 * A coroutine can yield by using __cr_return(<value>); and pass execu-
 * tion to another function with the same <typename> with __cr_pass (or
 * __cr_passv if the function return type is "void") or __cr_pass_na or
 * __cr_passv_na, respectively, for functions taking no arguments.
 * Local variables can be accessed in a coroutine with __cr_var(<name>)
 *
 * To access a coroutine, first create a pointer to a state variable
 * of its <typename> and initialise it with something like
 *	__cr_init(<typename>, <pointervar>, <name>);
 * and call the coroutine using __cr_call(<pointervar>, <arguments>) or
 * __cr_call_na(<pointervar>).
 *
 * Example:

#include <stdlib.h>
#include <stdio.h>
#include "coroutine.h"

static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.16 2008/11/19 02:17:30 tg Rel $";

__coroutine_decl(footype, int, int);
__coroutine_decl(foovtype, void, int);
__coroutine_decl_na(foontype, int);
__coroutine_decl_na(foovntype, void);

__coroutine_proto(footype, foo, int, int);
__coroutine_proto(footype, bar, int, int);
__coroutine_proto(foovtype, foov, void, int);
__coroutine_proto(foovtype, barv, void, int);
__coroutine_proto_na(foontype, foon, int);
__coroutine_proto_na(foontype, barn, int);
__coroutine_proto_na(foovntype, foovn, void);
__coroutine_proto_na(foovntype, barvn, void);

__coroutine_impl(footype)
__coroutine_impl(foovtype)
__coroutine_impl(foontype)
__coroutine_impl(foovntype)

int gvar;

__coroutine_defn(footype,
foo, int, int arg)
{
	int a;

	__cr_begin(foo);
	__cr_var(a) = 0;
	while (__cr_var(a) < 1000000) {
		if (arg > 3)
			__cr_pass(footype, bar, arg);
		__cr_var(a) += arg;
		__cr_return(__cr_var(a));
	}
	__cr_end(foo);
	return (0);
}

__coroutine_defn(footype,
bar, int, int arg)
{
	unsigned short k;

	__cr_begin(bar);
	__cr_var(k) = 0;
	while (__cr_var(k) < 10000) {
		__cr_var(k) += arg;
		__cr_return(1000 + __cr_var(k));
	}
	__cr_end(bar);
	return (0);
}

__coroutine_defn(foovtype,
foov, void, int arg)
{
	int a;

	__cr_begin(foov);
	__cr_var(a) = 0;
	while (__cr_var(a) < 1000000) {
		if (arg > 3)
			__cr_passv(foovtype, barv, arg);
		__cr_var(a) += arg;
		gvar = __cr_var(a);
		__cr_return();
	}
	__cr_end(foov);
	return;
}

__coroutine_defn(foovtype,
barv, void, int arg)
{
	unsigned short k;

	__cr_begin(barv);
	__cr_var(k) = 0;
	while (__cr_var(k) < 10000) {
		__cr_var(k) += arg;
		gvar = 1000 + __cr_var(k);
		__cr_return();
	}
	__cr_end(barv);
	return;
}

__coroutine_defn_na(foontype,
foon, int)
{
	int a;

	__cr_begin(foon);
	__cr_var(a) = 0;
	while (__cr_var(a) < 1000000) {
		if (__cr_var(a) > 3)
			__cr_pass_na(foontype, barn);
		++__cr_var(a);
		__cr_return(__cr_var(a));
	}
	__cr_end(foon);
	return (0);
}

__coroutine_defn_na(foontype,
barn, int)
{
	unsigned short k;

	__cr_begin(barn);
	__cr_var(k) = 0;
	while (__cr_var(k) < 10000) {
		++__cr_var(k);
		__cr_return(1000 + __cr_var(k));
	}
	__cr_end(barn);
	return (0);
}

__coroutine_defn_na(foovntype,
foovn, void)
{
	int a;

	__cr_begin(foovn);
	__cr_var(a) = 0;
	while (__cr_var(a) < 1000000) {
		if (__cr_var(a) > 3)
			__cr_passv_na(foovntype, barvn);
		++__cr_var(a);
		gvar = __cr_var(a);
		__cr_return();
	}
	__cr_end(foovn);
	return;
}

__coroutine_defn_na(foovntype,
barvn, void)
{
	unsigned short k;

	__cr_begin(barvn);
	__cr_var(k) = 0;
	while (__cr_var(k) < 10000) {
		++__cr_var(k);
		gvar = 1000 + __cr_var(k);
		__cr_return();
	}
	__cr_end(barvn);
	return;
}

int
main(int argc, char *argv[])
{
	__cr_init(footype, c, foo);
	__cr_init(foovtype, cv, foov);
	__cr_init(foontype, n, foon);
	__cr_init(foovntype, nv, foovn);
	int i;

	printf("%s\n", rcsid);

	gvar = 0;
	for (i = 1; i <= 6; ++i) {
		__cr_call(cv, i);
		printf("#%d: ret = %d\t\tgv = %d\n", i, __cr_call(c, i), gvar);
	}
	printf("%s[%d]: ret = %d\n", argv[0], argc, __cr_call(c, argc));

	gvar = 0;
	for (i = 1; i <= 6; ++i) {
		__cr_call_na(nv);
		printf("#%d: ret = %d\t\tgv = %d\n", i, __cr_call_na(n), gvar);
	}

	return (0);
}

 */

#ifndef __COROUTINE_H
#define __COROUTINE_H

/* configuration: malloc/free functions to use */
#ifndef __coroutine_malloc
#define __coroutine_malloc	malloc
#endif

#ifndef __coroutine_free
#define __coroutine_free	free
#endif

/* configuration: implementation style to use */
#if !defined(__COROUTINE_DUFF)
#ifdef __GNUC__
#define __COROUTINE_DUFF	0	/* use address of local label */
#else
#define __COROUTINE_DUFF	1	/* use Duff's Device (ANSI C) */
#endif
#endif


/* concatenation macro, used internally */
#define __CR(x, y)		__coroutine_ ## x ## _ ## y


#if __COROUTINE_DUFF
#define __coroutine_content	unsigned long lno
#else
#define __coroutine_content	void *ptr
#endif

/* declare a <typename>, its structures, and initialiser function */
#define __coroutine_decl(_typename, _rettype, ...)			\
	struct __CR(struct, _typename);					\
	typedef _rettype (*__CR(ptr, _typename))(struct			\
	    __CR(struct, _typename) **, __VA_ARGS__);			\
	typedef struct __CR(struct, _typename) {			\
		__CR(ptr, _typename) __fptr;				\
		__coroutine_content;					\
	} _typename;							\
	_typename *__CR(init, _typename)(void (*)(_typename **))

#define __coroutine_decl_na(_typename, _rettype)			\
	struct __CR(struct, _typename);					\
	typedef _rettype (*__CR(ptr, _typename))(struct			\
	    __CR(struct, _typename) **);				\
	typedef struct __CR(struct, _typename) {			\
		__CR(ptr, _typename) __fptr;				\
		__coroutine_content;					\
	} _typename;							\
	_typename *__CR(init, _typename)(void (*)(_typename **))

/* implement a <typename>'s initialiser function */
#define __coroutine_impl(_typename)					\
	_typename *							\
	__CR(init, _typename)(void (*__cr_ptr)(_typename **))		\
	{								\
		_typename *__cr_tmp1 = NULL;				\
		(*__cr_ptr)(&__cr_tmp1);				\
		return (__cr_tmp1);					\
	}

/* declare and initialise a context pointer variable */
#define __coroutine_init(_typename, _ptrvar, _name)			\
	_typename *_ptrvar =						\
	    __CR(init, _typename)((void (*)(_typename **))&(_name))

/* pass execution to another coroutine of the same <typename> ret. non-void */
#define __coroutine_pass(_typename, _name, ...) do {			\
	__coroutine_free(*__cr_ectx);					\
	*__cr_ectx =							\
	    __CR(init, _typename)((void (*)(_typename **))&(_name));	\
	return ((*__cr_ectx)->__fptr(__cr_ectx, __VA_ARGS__));		\
} while (/* CONSTCOND */ 0)

#define __coroutine_pass_na(_typename, _name) do {			\
	__coroutine_free(*__cr_ectx);					\
	*__cr_ectx =							\
	    __CR(init, _typename)((void (*)(_typename **))&(_name));	\
	return ((*__cr_ectx)->__fptr(__cr_ectx));			\
} while (/* CONSTCOND */ 0)

/* pass execution to another coroutine of the same <typename> returning void */
#define __coroutine_passv(_typename, _name, ...) do {			\
	__coroutine_free(*__cr_ectx);					\
	*__cr_ectx =							\
	    __CR(init, _typename)((void (*)(_typename **))&(_name));	\
	(*__cr_ectx)->__fptr(__cr_ectx, __VA_ARGS__);			\
	return;								\
} while (/* CONSTCOND */ 0)

#define __coroutine_passv_na(_typename, _name) do {			\
	__coroutine_free(*__cr_ectx);					\
	*__cr_ectx =							\
	    __CR(init, _typename)((void (*)(_typename **))&(_name));	\
	(*__cr_ectx)->__fptr(__cr_ectx);				\
	return;								\
} while (/* CONSTCOND */ 0)

/* declare a coroutine function prototype */
#define __coroutine_proto(_typename, _name, _rettype, ...)		\
	_rettype _name(_typename **, __VA_ARGS__)

#define __coroutine_proto_na(_typename, _name, _rettype)		\
	_rettype _name(_typename **)

/* define a coroutine function */
#define __coroutine_defn(_typename, _name, _rettype, ...)		\
	_rettype							\
	_name(_typename **__cr_ectx, __VA_ARGS__)			\
	{								\
		struct __CR(internal, _name) {				\
			/* __cr_internal must be first */		\
			_typename __cr_internal;			\
			struct	/* ... yes, here the macro ends */

#define __coroutine_defn_na(_typename, _name, _rettype)			\
	_rettype							\
	_name(_typename **__cr_ectx)					\
	{								\
		struct __CR(internal, _name) {				\
			/* __cr_internal must be first */		\
			_typename __cr_internal;			\
			struct	/* ... yes, here the macro ends */


#if __COROUTINE_DUFF

/* begin execution of a coroutine function */
#define __coroutine_begin(_name)					\
			} __cr_data;					\
		} *__cr_ictx;						\
									\
	if (*__cr_ectx == NULL) {					\
		__coroutine_initctx(_name);				\
		(*__cr_ectx)->lno = 0;					\
		goto __CR(endlbl, _name);				\
	} else								\
		__coroutine_checkctx(_name);				\
	switch ((*__cr_ectx)->lno) {					\
	case 0:

/* yield from a coroutine to its caller */
#define __coroutine_return(x) do {					\
	/* the following must all be on the same line */		\
	(*__cr_ectx)->lno = __LINE__; return x; case __LINE__: ;	\
} while (/* CONSTCOND */ 0)

/* finish execution of a coroutine function */
#define __coroutine_end(_name)						\
		if (*__cr_ectx != NULL) {				\
			__coroutine_free(*__cr_ectx);			\
			*__cr_ectx = NULL;				\
		}							\
	}								\
	__CR(endlbl, _name):

#else /* !__COROUTINE_DUFF */

/* begin execution of a coroutine function */
#define __coroutine_begin(_name)					\
			} __cr_data;					\
		} *__cr_ictx;						\
									\
	if (*__cr_ectx == NULL) {					\
		__coroutine_initctx(_name);				\
		(*__cr_ectx)->ptr = NULL;				\
		goto __CR(endlbl, _name);				\
	} else								\
		__coroutine_checkctx(_name);				\
	if ((*__cr_ectx)->ptr != NULL)					\
		__extension__({ goto *((*__cr_ectx)->ptr); })

/* yield from a coroutine to its caller */
#define __coroutine_return(value) __extension__({			\
	__label__ __cr_tmplbl;						\
									\
	(*__cr_ectx)->ptr = &&__cr_tmplbl;				\
	return value;	/* no parens: void function support */		\
 __cr_tmplbl:								\
	;								\
})

/* finish execution of a coroutine function */
#define __coroutine_end(_name)						\
	if (*__cr_ectx != NULL) {					\
		__coroutine_free(*__cr_ectx);				\
		*__cr_ectx = NULL;					\
	}								\
	__CR(endlbl, _name):

#endif /* !__COROUTINE_DUFF */


/* internal: fill in a context pointer and local variables variable */
#define __coroutine_initctx(_name) do {					\
	*__cr_ectx = __coroutine_malloc(sizeof (*__cr_ictx));		\
	(*__cr_ectx)->__fptr = &(_name);				\
} while (/* CONSTCOND */ 0)

/* internal: check a context pointer for validity and load it */
#define __coroutine_checkctx(_name) do {				\
	/* check if the struct passed matches */			\
	if ((*__cr_ectx)->__fptr != &(_name))				\
		abort();						\
	__cr_ictx = (struct __CR(internal, _name) *)(*__cr_ectx);	\
} while (/* CONSTCOND */ 0)


/* API exported to the user */
#define __cr_init		__coroutine_init
#define __cr_free		__coroutine_free
#define __cr_begin		__coroutine_begin
#define __cr_end		__coroutine_end
#define __cr_call(_ctx, ...)	((_ctx)->__fptr(&(_ctx), __VA_ARGS__))
#define __cr_call_na(_ctx)	((_ctx)->__fptr(&(_ctx)))
#define __cr_pass		__coroutine_pass
#define __cr_pass_na		__coroutine_pass_na
#define __cr_passv		__coroutine_passv
#define __cr_passv_na		__coroutine_passv_na
#define __cr_return(v)		__coroutine_return(v)
#define __cr_var(_name)		((__cr_ictx->__cr_data)._name)

#endif /* __COROUTINE_H */
@


1.16
log
@meh, remove the GNU cpp dependency and always just use ISO C variadic
macros and the *_na ones for them; enhance example by na ones as well
as passv ones which had been untested previously

works with gcc3.4.6-MirOS-10uA3 (-pedantic), pcc20081028-MirPorts-1
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.15 2008/11/19 01:53:56 tg Exp $ */
d75 1
a75 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.15 2008/11/19 01:53:56 tg Exp $";
d96 1
a96 1
int global_state;
d141 1
a141 1
		global_state = __cr_var(a);
d157 1
a157 1
		global_state = 1000 + __cr_var(k);
d174 1
a174 1
		__cr_var(a) += 1;
d189 1
a189 1
		__cr_var(k) += 1;
d206 2
a207 2
		__cr_var(a) += 1;
		global_state = __cr_var(a);
d222 2
a223 2
		__cr_var(k) += 1;
		global_state = 1000 + __cr_var(k);
d235 2
a236 2
	__cr_init(foontype, cn, foon);
	__cr_init(foovntype, cvn, foovn);
d241 1
a241 3
	global_state = 0;
	for (i = 1; i <= 6; ++i)
		printf("#%d: ret = %d\n", i, __cr_call(c, i));
d244 1
a244 1
		printf("#%d: ret = %d\n", i, global_state);
d246 3
a248 3
	global_state = 0;
	for (i = 1; i <= 6; ++i)
		printf("#%d: ret = %d\n", i, __cr_call_na(cn));
d250 2
a251 2
		__cr_call_na(cvn);
		printf("#%d: ret = %d\n", i, global_state);
a253 2
	printf("%s[%d]: ret = %d\n", argv[0], argc, __cr_call(c, argc));

@


1.15
log
@add *_na macros for nōn-GNU C Præprocessor implementations; mention that;
test with pcc-cpp
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.14 2008/11/19 01:28:00 tg Exp $ */
d33 1
a33 3
 * Note that ", <arguments>" is NOT optional unless you use GNU cpp,
 * but compilers such as pcc work fine for functions WITH arguments;
 * see below for *_na macros. To create a coroutine, use this:
d36 2
a37 1
__coroutine_decl(<typename>, <return type> [, <arguments>]);
d40 2
a41 1
__coroutine_proto(<typename>, <name>, <return type> [, <arguments>]);
d47 2
a48 1
__coroutine_defn(<typename>, <name>, <return type> [, <arguments>])
d59 2
a60 1
 * __cr_passv if the function return type is "void").
d66 2
a67 5
 * and call the coroutine using __cr_call(<pointervar> [, <arguments>]).
 *
 * The __coroutine_decl_na, __coroutine_pass_na, __coroutine_passv_na,
 * __coroutine_proto_na, __coroutine_defn_na, __cr_call_na variants are
 * provided for ISO C variadic macro cpp implementations.
d75 1
a75 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.14 2008/11/19 01:28:00 tg Exp $";
d78 3
d84 6
d92 5
d130 100
d234 3
d239 1
a239 2
	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'v')
		printf("%s\n", rcsid);
d241 1
d244 13
d299 1
a299 1
	    __CR(struct, _typename) **, ##__VA_ARGS__);			\
d336 1
a336 1
	return ((*__cr_ectx)->__fptr(__cr_ectx, ##__VA_ARGS__));	\
d351 1
a351 1
	(*__cr_ectx)->__fptr(__cr_ectx, ##__VA_ARGS__);			\
d365 1
a365 1
	_rettype _name(_typename **, ##__VA_ARGS__)
d373 1
a373 1
	_name(_typename **__cr_ectx, ##__VA_ARGS__)			\
d478 1
a478 1
#define __cr_call(_ctx, ...)	((_ctx)->__fptr(&(_ctx), ##__VA_ARGS__))
@


1.14
log
@fix comment about __coroutine_defn placement – while, in a one-file
implementation, __coroutine_decl and __coroutine_proto surely live
in a source file instead of a header file, __coroutine_impl¹ and
__coroutine_defn always live in source files, usually *.c files.

① inlining would be possible, but __coroutine_decl does not help there
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.13 2008/11/19 01:23:12 tg Exp $ */
d33 3
a35 1
 * To create a coroutine, use this:
d66 4
d76 1
a76 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.13 2008/11/19 01:23:12 tg Exp $";
d177 10
d210 7
d226 8
d238 3
d251 9
d350 1
d352 1
d354 1
@


1.13
log
@I just found a rather ironic way of honouring KNF – style(9) – which
demands that function names start at column 1, to be able to grep for
their implementations using '^name', by simply breaking the macro
arguments to __coroutine_defn before the name. Tested.
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.12 2008/06/23 20:33:06 tg Rel $ */
d44 1
a44 1
 * once per function <name>, in a header file:
d70 1
a70 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.12 2008/06/23 20:33:06 tg Rel $";
@


1.12
log
@a little more type, argument (add parens) and namespace (__cr_ to avoid
shadowing a global) safety doesn’t hurt

tested except (again) __cr_passv
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.11 2008/06/23 19:59:04 tg Rel $ */
d70 1
a70 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.11 2008/06/23 19:59:04 tg Rel $";
d79 2
a80 1
__coroutine_defn(footype, foo, int, int arg)
d96 2
a97 1
__coroutine_defn(footype, bar, int, int arg)
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.10 2008/06/23 19:02:17 tg Stab $ */
d70 1
a70 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.10 2008/06/23 19:02:17 tg Stab $";
d161 2
a162 2
	typedef _rettype (*__CR(ptr, _typename))(			\
	    struct __CR(struct, _typename) **, ##__VA_ARGS__);		\
d172 1
a172 1
	__CR(init, _typename)(void (*ptr)(_typename **))		\
d175 1
a175 1
		(*ptr)(&__cr_tmp1);					\
d182 1
a182 1
	    __CR(init, _typename)((void (*)(_typename **))&_name)
d188 1
a188 1
	    __CR(init, _typename)((void (*)(_typename **))&_name);	\
d196 1
a196 1
	    __CR(init, _typename)((void (*)(_typename **))&_name);	\
d287 1
a287 1
	(*__cr_ectx)->__fptr = &_name;					\
d293 1
a293 1
	if ((*__cr_ectx)->__fptr != &_name)				\
d308 1
a308 1
#define __cr_var(_name)		(__cr_ictx->__cr_data._name)
@


1.10
log
@oops, no /* inside /*
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.9 2008/06/23 19:00:48 tg Exp $ */
d70 1
a70 1
static const char rcsid[] = "$MirOS: contrib/code/Snippets/coroutine.h,v 1.9 2008/06/23 19:00:48 tg Exp $";
d171 2
a172 1
	_typename *__CR(init, _typename)(void (*ptr)(_typename **))	\
d207 2
a208 1
	_rettype _name(_typename **__cr_ectx, ##__VA_ARGS__)		\
@


1.9
log
@• add more comments
• add __cr_passv for coroutine functions returning void, if they make sense
• example programme: add -v option for version ☺
• new __coroutine_impl for implementing a <typename> initialiser function
• new __cr_init replacing __cr_new:
  -footype *ctx; […] __cr_new(footype, ctx, foo);
  +__cr_init(footype, ctx, foo);
• remove #define __extension__ /* away */, as we no longer use it outside
  of the gcc-extensions block
• move internal macros to bottom, exposed macros to top
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.4 2008/06/20 15:41:26 tg Exp $ */
d70 1
a70 1
static const char rcsid[] = "$MirOS$";
d77 1
a77 1
__coroutine_impl(footype)	/* no trailing semicolon here, sadly */
@


1.8
log
@clean warnings for
• lint
• pcc -O -WW -Werror
@
text
@d32 1
d35 1
d38 1
d41 4
d55 2
a56 1
 * tion to another function with the same <typename> with __cr_pass.
d60 2
a61 2
 * of its <typename>, initialise it with something like
 *	__cr_new(<pointervar>, <typename>, <name>);
d70 2
d77 2
d110 1
a110 1
main(void)
d112 1
a112 1
	footype *c;
d115 3
a117 1
	__cr_new(c, footype, foo);
d158 1
d166 2
a167 1
	} _typename
d169 8
a176 4
#define __coroutine_initctx(_name) do {					\
	*__cr_ectx = __coroutine_malloc(sizeof (*__cr_ictx));		\
	(*__cr_ectx)->__fptr = &_name;					\
} while (/* CONSTCOND */ 0)
d178 4
a181 6
#define __coroutine_checkctx(_name) do {				\
	/* check if the struct passed matches */			\
	if ((*__cr_ectx)->__fptr != &_name)				\
		abort();						\
	__cr_ictx = (struct __CR(internal, _name) *)(*__cr_ectx);	\
} while (/* CONSTCOND */ 0)
d183 1
d186 2
a187 1
	__coroutine_new(*__cr_ectx, _typename, _name);			\
d191 10
d204 1
d213 1
d216 1
a216 4
#ifndef __extension__
#define __extension__		/* nothing */
#endif

d230 1
d236 1
d247 1
d261 1
d271 1
d281 5
a285 6
#define __coroutine_new(_ptrvar, _typename, _name) do {			\
	_typename *__cr_tmp1 = NULL;					\
	void (*__cr_tmp2)(_typename **) =				\
	    (void (*)(_typename **))&_name;				\
	(*__cr_tmp2)(&__cr_tmp1);					\
	_ptrvar = __cr_tmp1;						\
d288 11
a298 1
#define __cr_new		__coroutine_new
d304 1
@


1.7
log
@avoid use of the GCCism “typeof” keyword in __cr_pass
now compiled on pcc (and still warning-free on gcc)
@
text
@d73 1
a73 1
	while (1) {
d89 1
a89 1
	while (1) {
@


1.6
log
@change __cr_new syntax to avoid use of a compound expression (GCCism)
@
text
@d75 1
a75 1
			__cr_pass(bar, arg);
d165 1
a165 1
#define __coroutine_pass(_name, ...) do {				\
d167 1
a167 1
	__coroutine_new(*__cr_ectx, typeof (**__cr_ectx), _name);	\
@


1.5
log
@enhance the example to use all facets of the current functionality for once
@
text
@d53 1
a53 1
 *	<pointervar> = __cr_new(<typename>, <name>);
d103 1
a103 1
	c = __cr_new(footype, foo);
d167 1
a167 1
	*__cr_ectx = __coroutine_new(typeof (**__cr_ectx), _name);	\
d247 1
a247 1
#define __coroutine_new(_typename, _name) __extension__({		\
d252 2
a253 2
	(__cr_tmp1);							\
})
@


1.4
log
@new: __cr_pass to pass execution to another coroutine with the same
typename transparently, from nbd’s git repository
• use __coroutine_new instead of the __cr_new user-alias
• expand __cr_call instead of invoking the user-alias
• enhance documentation

this is somewhat kludgy:
• it uses “return value;” and thusly cannot be used in functions
  returning a void type (if they make sense anyway for coroutines;
  do they?)
• it uses the GNU Complainer Collection’s “typeof” keyword, which
  is non-portable (solution would be to have a typename argument)

missing:
• enhance usage example by __cr_pass and a second co-routine
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.3 2008/06/20 15:32:12 tg Exp $ */
d65 1
d67 1
a67 1
__coroutine_defn(footype, foo, int, int bar)
d74 3
a76 1
		__cr_var(a) += bar;
d83 14
d101 1
a101 1
	int i = 0;
d104 2
a105 3
	for (i = 1; i <= 3; i++) {
		printf("%d: ret=%d\n", i, __cr_call(c, i));
	}
@


1.3
log
@move __coroutine_checkctx, so that the trailing “struct” of
__coroutine_defn and the initial ‘}’ of __coroutine_begin
line up nicely again (cosmetical change)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.2 2008/06/18 20:42:00 tg Exp $ */
d47 2
a48 1
 * A coroutine can yield by using __cr_return(<value>);
d149 6
d244 1
@


1.2
log
@ok, I’m a Verpeiler
switch (i.e. correct) order of code in branches of #if __COROUTINE_DUFF

‣ still builds with __CRAZY=Yes for both Duff’s Device and GCC’s Extension
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/coroutine.h,v 1.1 2008/06/18 20:27:16 tg Exp $ */
d141 7
a158 7
#define __coroutine_checkctx(_name) do {				\
	/* check if the struct passed matches */			\
	if ((*__cr_ectx)->__fptr != &_name)				\
		abort();						\
	__cr_ictx = (struct __CR(internal, _name) *)(*__cr_ectx);	\
} while (/* CONSTCOND */ 0)

@


1.1
log
@preliminary version of a coroutines-in-C header file written by
Felix “nbd” Fietkau after an idea (and self-criticism) of Simon
Tatham, plus design improvements discussed with and implemented
by me. Felix kindly agreed to put this under MirOS licence.

This is the preliminary version ack’d by Felix,
• with some namespace improvements (e.g. __CR_DUFF)
• with a new macro __coroutine_proto for function prototypes if
  -Wstrict-prototypes is used

With this the sample programme included builds with __CRAZY=Yes

Changes to the final version (missing):
• do not use __extension__({ on non-gcc (or at all)
  ‣ possible change of syntax a̲n̲d̲ semantics of __cr_new()
• test with pcc and SUNw,cc (and possibly others)
• get an ack from Felix for the changed versions again
• send to Simon for review
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.24 2008/04/22 11:43:31 tg Rel $ */
d110 1
a110 1
#define __COROUTINE_DUFF	0
d112 1
a112 1
#define __COROUTINE_DUFF	1
d122 2
a124 2
#else
#define __coroutine_content	unsigned long lno
d161 4
d171 1
a171 1
		(*__cr_ectx)->ptr = NULL;				\
d175 2
a176 2
	if ((*__cr_ectx)->ptr != NULL)					\
		__extension__({ goto *((*__cr_ectx)->ptr); })
d178 4
a181 8
#define __coroutine_return(value) __extension__({			\
	__label__ __cr_tmplbl;						\
									\
	(*__cr_ectx)->ptr = &&__cr_tmplbl;				\
	return value;	/* no parens: void function support */		\
 __cr_tmplbl:								\
	;								\
})
d184 4
a187 3
	if (*__cr_ectx != NULL) {					\
		__coroutine_free(*__cr_ectx);				\
		*__cr_ectx = NULL;					\
a192 4
#ifndef __extension__
#define __extension__		/* nothing */
#endif

d199 1
a199 1
		(*__cr_ectx)->lno = 0;					\
d203 2
a204 2
	switch ((*__cr_ectx)->lno) {					\
	case 0:
d206 8
a213 4
#define __coroutine_return(x) do {					\
	/* the following must all be on the same line */		\
	(*__cr_ectx)->lno = __LINE__; return x; case __LINE__: ;	\
} while (/* CONSTCOND */ 0)
d216 3
a218 4
		if (*__cr_ectx != NULL) {				\
			__coroutine_free(*__cr_ectx);			\
			*__cr_ectx = NULL;				\
		}							\
@

