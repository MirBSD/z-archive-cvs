head	1.30;
access;
symbols
	BSD__arc4random-1_43:1.23;
locks; strict;
comment	@ * @;


1.30
date	2014.12.20.21.38.07;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005495EC5633DB7781;

1.29
date	2012.10.19.18.59.38;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005081A33215C2F05A;

1.28
date	2010.09.12.12.24.27;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004C8CC69150D1B4BD;

1.27
date	2010.01.28.16.48.12;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004B61BFE43CFDC9F2;

1.26
date	2010.01.28.16.47.48;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004B61BFC216C9068A;

1.25
date	2010.01.06.17.52.31;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004B44CDF76EA71CDB;

1.24
date	2009.11.29.18.24.21;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004B12BC29222D2EDA;

1.23
date	2009.11.29.15.29.24;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004B1293503FBA3433;

1.22
date	2009.11.29.14.57.00;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004B128BD37E8B48DA;

1.21
date	2009.11.09.22.35.49;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004AF8995013E8DF46;

1.20
date	2009.11.09.18.12.50;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004AF85BAD20F93D56;

1.19
date	2009.09.27.10.45.56;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004ABF427B0C01542F;

1.18
date	2009.09.20.13.29.17;	author tg;	state Stab;
branches;
next	1.17;
commitid	1004AB62DF51E47759B;

1.17
date	2009.09.20.12.51.07;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004AB6253F25FA36C0;

1.16
date	2009.08.02.13.09.12;	author tg;	state Stab;
branches;
next	1.15;
commitid	1004A758FAE27A96B15;

1.15
date	2009.08.02.11.24.40;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004A75778561DED6E0;

1.14
date	2009.05.27.09.52.42;	author tg;	state Stab;
branches;
next	1.12;
commitid	1004A1D0D6A5E616685;

1.12
date	2008.12.08.18.51.53;	author tg;	state Exp;
branches;
next	1.11;
commitid	100493D6CDD24BB45EE;

1.11
date	2008.12.08.18.46.01;	author tg;	state Exp;
branches;
next	1.10;
commitid	100493D6B253598B1F5;

1.10
date	2008.12.08.13.45.18;	author tg;	state Exp;
branches;
next	1.9;
commitid	100493D25015FAB7DB2;

1.9
date	2008.12.08.13.37.44;	author tg;	state Exp;
branches;
next	1.8;
commitid	100493D233652B37C21;

1.8
date	2008.12.08.13.31.58;	author tg;	state Exp;
branches;
next	1.7;
commitid	100493D21CE226A01DF;

1.7
date	2008.12.08.12.41.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	100493D15BD5189AE88;

1.6
date	2008.10.24.21.15.21;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049023AF361C68EA5;

1.5
date	2008.10.24.21.14.38;	author tg;	state Exp;
branches;
next	1.4;
commitid	10049023AC47DC47DBF;

1.4
date	2008.10.20.11.37.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	10048FC6D833E7D55CD;

1.3
date	2008.03.04.22.53.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	10047CDD2E534273D4D;

1.2
date	2007.09.09.22.14.04;	author tg;	state Exp;
branches;
next	1.1;
commitid	10046E4703E29699E3C;

1.1
date	2007.09.07.19.28.08;	author tg;	state Exp;
branches;
next	;
commitid	10046E1A6517F0CB3FB;


desc
@@


1.30
log
@x32 hack
@
text
@static const char __vcsid[] = "@@(#) MirOS contributed arc4random.c (old)"
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.29 2012/10/19 18:59:38 tg Exp $"
    ;

/*-
 * Arc4 random number generator for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
 *
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
 */

/*-
 * This code is derived from section 17.1 of Applied Cryptography,
 * second edition, which describes a stream cipher allegedly
 * compatible with RSA Labs "RC4" cipher (the actual description of
 * which is a trade secret).  The same algorithm is used as a stream
 * cipher called "arcfour" in Tatu Ylonen's ssh package.
 *
 * Here the stream cipher has been modified always to include the time
 * when initializing the state.  That makes it impossible to
 * regenerate the same random sequence twice, so this can't be used
 * for encryption, but will generate good random numbers.
 *
 * RC4 is a registered trademark of RSA Laboratories.
 */

/*-
 * Modified by Robert Connolly from OpenBSD lib/libc/crypt/arc4random.c v1.11.
 * This is arc4random(3) using urandom.
 */

/*-
 * Copyright (c) 2008, 2009, 2010, 2012, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
 * This is arc4random(3) made more portable,
 * as well as arc4random_pushb(3) for Cygwin.
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#if defined(__linux__) && defined(__x86_64__) && defined(__ILP32__)
/* no sysctl on Linux/x32 */
#undef HAVE_SYS_SYSCTL_H
#endif
#if defined(HAVE_SYS_SYSCTL_H) && HAVE_SYS_SYSCTL_H
#include <sys/sysctl.h>
#endif
#include <fcntl.h>
#if defined(HAVE_STDINT_H) && HAVE_STDINT_H
#include <stdint.h>
#elif defined(USE_INTTYPES)
#include <inttypes.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#if defined(__CYGWIN__) || defined(WIN32)
#define USE_MS_CRYPTOAPI
#define REDEF_USCORETYPES
#endif

#ifdef USE_MS_CRYPTOAPI
#define WIN32_WINNT 0x400
#define _WIN32_WINNT 0x400
#include <windows.h>
#include <wincrypt.h>

static uint8_t w32_buf[16*16384];	/* force reseed */
static uint8_t w32_hklm[80];		/* registry key (MS, Admin) */
static uint8_t w32_hkcu[256];		/* registry key (per user) */
static struct timeval w32_last;		/* last time CGR was used */

static char w32_subkey[] = "SOFTWARE\\Microsoft\\Cryptography\\RNG";
#endif

#ifndef MIN
#define	MIN(a,b)	(((a)<(b))?(a):(b))
#endif
#ifndef MAX
#define	MAX(a,b)	(((a)>(b))?(a):(b))
#endif

#ifdef REDEF_USCORETYPES
#define u_int32_t	uint32_t
#endif

#ifndef _PATH_URANDOM
#define _PATH_URANDOM	"/dev/urandom"
#endif

static struct arc4_stream {
	uint8_t i;
	uint8_t j;
	uint8_t s[256];
} arc4_ctx;

static int rs_initialized;
static pid_t arc4_stir_pid;
static int arc4_count;
static const char __randomdev[] = _PATH_URANDOM;

static uint8_t arc4_getbyte(void);
static void stir_finish(uint8_t);
static void arc4_atexit(void);
static char arc4_writeback(uint8_t *, size_t, char);

#ifndef arc4random_pushk
u_int32_t arc4random(void);
void arc4random_addrandom(u_char *, int);
void arc4random_stir(void);
#if defined(USE_MS_CRYPTOAPI) || defined(OPPORTUNISTIC_ROOT_PUSHB)
uint32_t arc4random_pushb(const void *, size_t);
#endif
#endif

#define NEED_UNIFORM_BUF_PROTO
#if defined(__OpenBSD__) && defined(OpenBSD) && (OpenBSD > 200805)
#undef NEED_UNIFORM_BUF_PROTO
#elif defined(__MirBSD__) && defined(MirBSD) && (MirBSD > 0x0AA4)
#undef NEED_UNIFORM_BUF_PROTO
#endif

#ifdef NEED_UNIFORM_BUF_PROTO
u_int32_t arc4random_uniform(u_int32_t);
void arc4random_buf(void *, size_t);
#endif

static void
arc4_init(void)
{
	int n;

	for (n = 0; n < 256; n++)
		arc4_ctx.s[n] = (uint8_t)n;
	arc4_ctx.i = 0;
	arc4_ctx.j = 0;
}

static void
arc4_addrandom(const u_char *dat, size_t datlen)
{
	size_t n = 0;
	uint8_t si;

	arc4_ctx.i--;
	while (n < 256) {
		arc4_ctx.i++;
		si = arc4_ctx.s[arc4_ctx.i];
		arc4_ctx.j = (uint8_t)(arc4_ctx.j + si + dat[n++ % datlen]);
		arc4_ctx.s[arc4_ctx.i] = arc4_ctx.s[arc4_ctx.j];
		arc4_ctx.s[arc4_ctx.j] = si;
	}
	arc4_ctx.i++;
	arc4_ctx.j = arc4_ctx.i;
}

#if defined(USE_MS_CRYPTOAPI)
#define RNDEV_BYTES	128
#elif defined(__INTERIX)
#define RNDEV_BYTES	4	/* slow /dev/urandom */
#elif defined(__OpenBSD__)
#define RNDEV_BYTES	(256 - (sizeof(struct timeval) + sizeof(pid_t)))
#elif defined(__CYGWIN__)
#define RNDEV_BYTES	64	/* /dev/urandom probably CryptoAPI */
#elif defined(__FreeBSD__)
#define RNDEV_BYTES	16	/* Yarrow has few state */
#elif defined(__GLIBC__)
#define RNDEV_BYTES	16	/* requested by maintainers */
#else
#define RNDEV_BYTES	8	/* unknown OS? */
#endif

static void
arc4_stir(void)
{
	int fd;
	struct {
		struct timeval tv;
		pid_t pid;
		u_int rnd[(RNDEV_BYTES + sizeof(u_int) - 1) / sizeof(u_int)];
	} rdat;
	size_t sz = 0;

	gettimeofday(&rdat.tv, NULL);
	rdat.pid = getpid();
	memcpy(rdat.rnd, __vcsid, MIN(sizeof(__vcsid), sizeof(rdat.rnd)));

#ifdef USE_MS_CRYPTOAPI
	if (arc4_writeback((char *)rdat.rnd, sizeof(rdat.rnd), 1))
		goto stir_okay;
#endif

	/* /dev/urandom is a multithread interface, sysctl is not. */
	/* Try to use /dev/urandom before sysctl. */
	fd = open(__randomdev, O_RDONLY);
	if (fd != -1) {
		sz = (size_t)read(fd, rdat.rnd, sizeof(rdat.rnd));
		close(fd);
	}
	if (sz > sizeof(rdat.rnd))
		sz = 0;
	if (fd == -1 || sz != sizeof(rdat.rnd)) {
		/* /dev/urandom failed? Maybe we're in a chroot. */
#if /* Linux */ defined(_LINUX_SYSCTL_H) || \
    /* OpenBSD */ (defined(CTL_KERN) && defined(KERN_ARND))
		int mib[3], nmib = 3;
		size_t i = sz / sizeof(u_int), len;

#ifdef _LINUX_SYSCTL_H
		mib[0] = CTL_KERN;
		mib[1] = KERN_RANDOM;
		mib[2] = RANDOM_UUID;
#else
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nmib = 2;
#endif

		while (i < sizeof(rdat.rnd) / sizeof(u_int)) {
			len = sizeof(u_int);
			if (sysctl(mib, nmib, &rdat.rnd[i++], &len,
			    NULL, 0) == -1) {
				fputs("warning: no entropy source\n", stderr);
				break;
			}
		}
#else
		/* XXX kFreeBSD doesn't seem to have KERN_ARND or so */
		;
#endif
	}

#ifdef USE_MS_CRYPTOAPI
 stir_okay:
#endif
	fd = arc4_getbyte();

	/*
	 * Time to give up. If no entropy could be found then we will just
	 * use gettimeofday and getpid.
	 */
	arc4_addrandom((u_char *)&rdat, sizeof(rdat));

	stir_finish(fd);
}

static void
stir_finish(uint8_t av)
{
	size_t n;
	uint8_t tb[16];

	arc4_stir_pid = getpid();

	/*
	 * Discard early keystream, as per recommendations in:
	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps
	 * "(Not So) Random Shuffles of RC4" by Ilya Mironov says to
	 * drop at least 256 * 2 bytes, with 256 * 12 being suggested.
	 * We also discard a randomly fuzzed amount.
	 */
	n = 256 * 12 + (arc4_getbyte() & 0x0FU) + (av & 0xF0U);
	av &= 0x0FU;
	while (n--)
		arc4_getbyte();
	while (++n < sizeof(tb))
		tb[n] = arc4_getbyte();
	if (arc4_writeback(tb, sizeof(tb), 0))
		arc4_getbyte();
	while (av--)
		arc4_getbyte();
	arc4_count = 1600000;
}

static uint8_t
arc4_getbyte(void)
{
	uint8_t si, sj;

	arc4_ctx.i++;
	si = arc4_ctx.s[arc4_ctx.i];
	arc4_ctx.j = (uint8_t)(arc4_ctx.j + si);
	sj = arc4_ctx.s[arc4_ctx.j];
	arc4_ctx.s[arc4_ctx.i] = sj;
	arc4_ctx.s[arc4_ctx.j] = si;
	return (arc4_ctx.s[(si + sj) & 0xff]);
}

static uint32_t
arc4_getword(void)
{
	uint32_t val;
	val = (uint32_t)arc4_getbyte() << 24;
	val |= (uint32_t)arc4_getbyte() << 16;
	val |= (uint32_t)arc4_getbyte() << 8;
	val |= (uint32_t)arc4_getbyte();
	return (val);
}

void
arc4random_stir(void)
{
	if (!rs_initialized) {
		arc4_init();
		rs_initialized = 1;
		atexit(arc4_atexit);
	}
	arc4_stir();
}

void
arc4random_addrandom(u_char *dat, int datlen)
{
	if (!rs_initialized)
		arc4random_stir();
	arc4_addrandom(dat, datlen);
}

u_int32_t
arc4random(void)
{
	arc4_count -= 4;
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != getpid())
		arc4random_stir();
	return arc4_getword();
}

/*
 * Returns 0 if write error; 0 if do_rd and read error;
 * 1 if !do_rd and read error but not write error;
 * 1 if no error occured.
 */
static char
arc4_writeback(uint8_t *buf, size_t len, char do_rd)
{
#ifdef USE_MS_CRYPTOAPI
	static char has_provider = 0;
	static HCRYPTPROV p;
	HKEY hKeyLM, hKeyCU;
	DWORD ksz;
	char rc = 6, has_rkey = 0, w32_a4b[16];
	size_t i, j, xlen;
	struct timeval tv;

	for (i = 0; i < sizeof(w32_a4b); ++i)
		w32_a4b[i] = arc4_getbyte();
	for (i = arc4_getbyte() & 15; i; --i)
		arc4_getbyte();

	ksz = sizeof(w32_buf);
	if ((/* read-write */ RegOpenKeyEx(HKEY_LOCAL_MACHINE, w32_subkey,
	    0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyLM) == ERROR_SUCCESS ||
	    /* try read-only */ RegOpenKeyEx(HKEY_LOCAL_MACHINE, w32_subkey,
	    0, KEY_QUERY_VALUE, &hKeyLM) == ERROR_SUCCESS) && /* get value */
	    (RegQueryValueEx(hKeyLM, "Seed", NULL, NULL, w32_buf, &ksz) ==
	    ERROR_SUCCESS) && /* got any content? */ ksz) {
		/* we got HKLM key, read-write or read-only */
		has_rkey |= 1;
		/* move content to destination */
		memset(w32_hklm, '\0', sizeof(w32_hklm));
		for (i = 0; i < MAX(ksz, sizeof(w32_hklm)); ++i)
			w32_hklm[i % sizeof(w32_hklm)] ^= w32_buf[i % ksz];
	}
	ksz = sizeof(w32_buf);
	if ((/* read-write */ RegCreateKeyEx(HKEY_CURRENT_USER, w32_subkey,
	    0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKeyCU,
	    NULL) == ERROR_SUCCESS || /* R/O */ RegOpenKeyEx(HKEY_CURRENT_USER,
	    w32_subkey, 0, KEY_QUERY_VALUE, &hKeyLM) == ERROR_SUCCESS) &&
	    /* get value */ (RegQueryValueEx(hKeyLM, "Seed", NULL, NULL,
	    w32_buf, &ksz) == ERROR_SUCCESS) && /* got any content? */ ksz) {
		/* we got HKCU key, created, read-write or read-only */
		has_rkey |= 2;
		/* move content to destination */
		memset(w32_hkcu, '\0', sizeof(w32_hkcu));
		for (i = 0; i < MAX(ksz, sizeof(w32_hkcu)); ++i)
			w32_hkcu[i % sizeof(w32_hkcu)] ^= w32_buf[i % ksz];
	}

	if (!do_rd)
		goto nogen_out;

	if (has_rkey && gettimeofday(&tv, NULL) == 0) {
		/* we have registry key; rate-limit CryptGenRandom */
		if (tv.tv_sec - w32_last.tv_sec < 128 + (arc4_getbyte() & 127))
			goto nogen_out;
		/* nope, more than 2-4 minutes, call it */
		w32_last.tv_sec = tv.tv_sec;
	}

	if (!has_provider) {
		if (!CryptAcquireContext(&p, NULL, NULL, PROV_RSA_FULL, 0)) {
			if ((HRESULT)GetLastError() != NTE_BAD_KEYSET)
				goto nogen_out;
			if (!CryptAcquireContext(&p, NULL, NULL, PROV_RSA_FULL,
			    CRYPT_NEWKEYSET))
				goto nogen_out;
		}
		has_provider = 1;
	}
	i = 0;
	while (i < 256)
		w32_buf[i++] = arc4_getbyte();
	if (!CryptGenRandom(p, sizeof(w32_buf), w32_buf)) {
		w32_last.tv_sec = 0;
 nogen_out:
		rc |= 1;
		memset(w32_buf, '\0', 256);
	}
	xlen = MIN(sizeof(w32_buf) - sizeof(w32_hklm) - sizeof(w32_hkcu) -
	    sizeof(w32_a4b), len);
	j = xlen + sizeof(w32_hklm) + sizeof(w32_hkcu) + sizeof(w32_a4b);
	for (i = 0; i < MAX(j, len); ++i)
		w32_buf[i % j] ^= w32_hklm[i % sizeof(w32_hklm)] ^
		    w32_hkcu[i % sizeof(w32_hkcu)] ^ buf[i % len] ^
		    arc4_getbyte();
	if (has_rkey & 1) {
		if (RegSetValueEx(hKeyLM, "Seed", 0, REG_BINARY,
		    w32_buf, sizeof(w32_hklm)) == ERROR_SUCCESS)
			rc &= ~2;
		RegCloseKey(hKeyLM);
	}
	if (has_rkey & 2) {
		if (RegSetValueEx(hKeyCU, "Seed", 0, REG_BINARY,
		    w32_buf + sizeof(w32_hklm), sizeof(w32_hkcu)) ==
		    ERROR_SUCCESS)
			rc &= ~4;
		RegCloseKey(hKeyCU);
	}
	for (i = 0; i < sizeof(w32_a4b); ++i)
		w32_a4b[i] ^= w32_buf[sizeof(w32_hklm) + sizeof(w32_hkcu) + i];
	arc4_addrandom(w32_a4b, sizeof(w32_a4b));

	i = sizeof(w32_hklm) + sizeof(w32_hkcu) + sizeof(w32_a4b);
	while (len) {
		j = MIN(len, xlen);
		memcpy(buf, w32_buf + i, j);
		buf += j;
		len -= j;
	}

	memset(w32_buf, '\0', sizeof(w32_buf));

	return (
	    /* read error occured */
	    (!has_rkey && (rc & 1)) ? 0 :
	    /* don't care about write errors */
	    !do_rd ? 1 :
	    /* couldn't write */
	    (rc & 6) == 6 ? 0 :
	    /* at least one RegSetValueEx succeeded */
	    1);
#elif defined(arc4random_pushk)
	uint32_t num;

	num = arc4random_pushk(buf, len);
	memcpy(buf, &num, sizeof(num));
	return (do_rd ? 0 : 1);
#else
	int fd;

	if ((fd = open(__randomdev, O_WRONLY)) != -1) {
		if (write(fd, buf, len) < 4)
			do_rd = 1;
		close(fd);
	}
	return (do_rd || fd == -1 ? 0 : 1);
#endif
}

#if defined(USE_MS_CRYPTOAPI) || defined(arc4random_pushk) || \
    defined(OPPORTUNISTIC_ROOT_PUSHB)
uint32_t
arc4random_pushb(const void *src, size_t len)
{
	size_t rlen;
	union {
		uint8_t buf[256];
		struct {
			struct timeval tv;
			const void *sp, *dp;
			size_t sz;
			uint32_t vu;
		} s;
		uint32_t xbuf;
	} idat;
	uint32_t res = 1;

	if (!rs_initialized) {
		arc4_init();
		rs_initialized = 1;
	}

	idat.s.sp = &idat;
	idat.s.dp = src;
	idat.s.sz = len;
	idat.s.vu = arc4_getword();
	gettimeofday(&idat.s.tv, NULL);

	rlen = MAX(sizeof(idat.s), len);
	while (rlen--)
		idat.buf[rlen % sizeof(idat.buf)] ^=
		    ((const uint8_t *)src)[rlen % len];
	rlen = MIN(sizeof(idat), MAX(sizeof(idat.s), len));

	if (arc4_writeback((void *)&idat, rlen, 1))
		res = 0;
	arc4_addrandom((void *)&idat, rlen);
	rlen = arc4_getbyte() & 1;
	if (res)
		res = idat.xbuf;
	else
		/* we got entropy from the kernel, so consider us stirred */
		stir_finish(idat.buf[5]);
	if (rlen)
		(void)arc4_getbyte();
	return (res ^ arc4_getword());
}
#endif

static void
arc4_atexit(void)
{
	struct {
		pid_t spid;
		int cnt;
		uint8_t carr[240];
	} buf;
	int i = 0;

	while (i < 240)
		buf.carr[i++] = arc4_getbyte();
	buf.spid = arc4_stir_pid;
	buf.cnt = arc4_count;

	arc4_writeback((uint8_t *)&buf, sizeof(buf), 0);
}

void
arc4random_buf(void *_buf, size_t n)
{
	uint8_t *buf = (uint8_t *)_buf;

	if (!rs_initialized || arc4_stir_pid != getpid())
		arc4random_stir();
	buf[0] = arc4_getbyte() % 3;
	while (buf[0]--)
		(void)arc4_getbyte();
	while (n--) {
		if (--arc4_count <= 0)
			arc4_stir();
		buf[n] = arc4_getbyte();
	}
}

/*-
 * Written by Damien Miller.
 * With simplifications by Jinmei Tatuya.
 */

/*
 * Calculate a uniformly distributed random number less than
 * upper_bound avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers
 * until the one returned is outside the range
 * [0, 2^32 % upper_bound[. This guarantees the selected
 * random number will be inside the range
 * [2^32 % upper_bound, 2^32[ which maps back to
 * [0, upper_bound[ after reduction modulo upper_bound.
 */
uint32_t
arc4random_uniform(uint32_t upper_bound)
{
	uint32_t r, min;

	if (upper_bound < 2)
		return (0);

#if defined(ULONG_MAX) && (ULONG_MAX > 0xFFFFFFFFUL)
	min = 0x100000000UL % upper_bound;
#else
	/* calculate (2^32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000U)
		/* 2^32 - upper_bound (only one "value area") */
		min = 1 + ~upper_bound;
	else
		/* ((2^32 - x) % x) == (2^32 % x) when x <= 2^31 */
		min = (0xFFFFFFFFU - upper_bound + 1) % upper_bound;
#endif

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll (at all).
	 */
	arc4_count -= 4;
	if (!rs_initialized || arc4_stir_pid != getpid() || arc4_count <= 0)
		arc4random_stir();
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
	do {
		r = arc4_getword();
	} while (r < min);

	return (r % upper_bound);
}
@


1.29
log
@The arc4random code in libevent suggests to look at the papers in more
detail and skip 256 * 12 bytes (plus fuzz) instead of 256 * 4 bytes
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.28 2010/09/12 12:24:27 tg Exp $"
d35 1
a35 1
 * Copyright (c) 2008, 2009, 2010, 2012
d59 4
@


1.28
log
@• kern/c/arc4random_uniform.c, kern/include/libckern.h: move
  arc4random_uniform(3) implementation here
• kern/c/Makefile.inc: build arc4random_uniform.c kernel/user
• lib/libc/crypt/arc4random.c, sys/dev/rnd.c: remove implementation here
• sys/dev/rndvar.h: prototype is now in <libckern.h>
• contrib/code/Snippets/arc4random.c: sync with master implementation
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.27 2010/01/28 16:48:12 tg Exp $"
d35 1
a35 1
 * Copyright (c) 2008, 2009, 2010
d274 2
a275 1
	 * We discard 256 words. A long word is 4 bytes.
d278 1
a278 1
	n = 256 * 4 + (arc4_getbyte() & 0x0FU) + (av & 0xF0U);
@


1.27
log
@sync copyright year
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.26 2010/01/28 16:47:48 tg Exp $"
d570 5
d576 2
a577 2
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
d579 6
a584 5
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
d586 2
a587 2
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
d589 1
a589 1
	u_int32_t r, min;
d594 1
a594 1
#if defined(ULONG_MAX) && (ULONG_MAX > 0xffffffffUL)
d597 7
a603 7
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;
	}
d610 1
a610 1
	 * to re-roll.
d612 2
a613 1
	if (!rs_initialized || arc4_stir_pid != getpid())
d617 1
a617 4
	for (;;) {
		arc4_count -= 4;
		if (arc4_count <= 0)
			arc4random_stir();
d619 1
a619 3
		if (r >= min)
			break;
	}
@


1.26
log
@fix uninitialised memory error cought by Valgrind on mksh
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.25 2010/01/06 17:52:31 tg Exp $"
d35 1
a35 1
 * Copyright (c) 2008, 2009
@


1.25
log
@fix a coding error in the KSA found by myself reading several descriptions of aRC4
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.24 2009/11/29 18:24:21 tg Exp $"
d281 2
a282 2
	while (n < sizeof(tb))
		tb[n++] = arc4_getbyte();
@


1.24
log
@#ifdef OPPORTUNISTIC_ROOT_PUSHB
assume we’re root and can write to /dev/urandom (dangerous)
mirrors mkshdroid’s cid 1004B12B53704274E9F into FreeWRT
#endif
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.23 2009/11/29 15:29:24 tg Exp $"
d169 1
@


1.23
log
@make things const that should be const where we can,
complain about things where we cannot change the API
designed by const-dirty OpenBSDdiots
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.22 2009/11/29 14:57:00 tg Exp $"
d127 1
a127 1
#ifdef USE_MS_CRYPTOAPI
d484 2
a485 1
#if defined(USE_MS_CRYPTOAPI) || defined(arc4random_pushk)
@


1.22
log
@again, improved entropy pass behaviour in arc4random_pushb (and pushk,
which has been the same for quite a while)
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.21 2009/11/09 22:35:49 tg Exp $"
d156 1
a156 1
arc4_addrandom(u_char *dat, int datlen)
d158 1
a158 1
	int n;
d162 1
a162 1
	for (n = 0; n < 256; n++) {
d165 1
a165 1
		arc4_ctx.j = (uint8_t)(arc4_ctx.j + si + dat[n % datlen]);
@


1.21
log
@feature- and style-sync Snippets/arc4random.c and libc’s with each other
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.20 2009/11/09 18:12:50 tg Exp $"
d491 6
a496 1
		struct timeval tv;
d506 11
a516 4
	gettimeofday(&idat.tv, NULL);
	for (rlen = 0; rlen < len; ++rlen)
		idat.buf[rlen % sizeof(idat)] ^= ((const uint8_t *)src)[rlen];
	rlen = MIN(sizeof(idat), MAX(sizeof(struct timeval), len));
d518 1
a518 1
	if (arc4_writeback(&idat.buf[0], rlen, 1))
d520 2
a521 1
	arc4_addrandom(&idat.buf[0], rlen);
d527 2
@


1.20
log
@adapt from contrib/code/mirmake/dist/contrib/arc4random.c that Interix
has very slow /dev/urandom; also some others
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.19 2009/09/27 10:45:56 tg Exp $"
d119 1
a119 1
static void stir_finish(int);
d132 12
d263 1
a263 1
stir_finish(int av)
d276 2
a277 5
	n = 256 * 4 + (arc4_getbyte() & 0x0FU);
	while (av) {
		n += (av & 0x0F);
		av >>= 4;
	}
d284 3
a286 1
	arc4_count = 400000;
d336 2
a337 1
	if (--arc4_count == 0 || !rs_initialized || arc4_stir_pid != getpid())
a493 1
	const uint8_t *cbuf = (const uint8_t *)src;
d503 1
a503 1
		idat.buf[rlen % sizeof(idat)] ^= cbuf[rlen];
d535 69
@


1.19
log
@don't call the (expensive) MS CryptoAPI if we don’t need to _read_ any
entropy from the system either, no matter if the registry method works
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.18 2009/09/20 13:29:17 tg Stab $"
d160 16
d183 1
a183 1
		u_int rnd[(128 - (sizeof(struct timeval) + sizeof(pid_t))) / sizeof(u_int)];
@


1.18
log
@use a slightly different algorithm for arc4random_pushb interfacing:
rate-limit calls to CryptGenRandom to every 2‥4 minutes, if the last
call was successful, and operate with hash() on rnd_cache[], so that
it is mixed in a better way
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.16 2009/08/02 13:09:12 tg Stab $"
d365 3
@


1.17
log
@fix buffer overflows̲ in win32 specific code
@
text
@d87 1
d329 1
d365 8
d387 1
@


1.16
log
@• overhaul Win32 arc4random_push*() implementation:
  ‣ use HKCU\SOFTWARE\Microsoft\Cryptography\RNG\Seed in addition to
    the HKLMSOFTWARE\Microsoft\Cryptography\RNG\Seed key we might not
    have write permissions for on Vista
  ‣ HKCU\SOFTWARE\Microsoft\Cryptography\RNG\Seed is created if needed
  ‣ if opening a registry key R/W fails, use it R/O
  ‣ much better data-shuffling-and-XORing scheme
• add comments
• KNF, a.k.a. style(9)

Works with mksh.exe for me
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.15 2009/08/02 11:24:40 tg Exp $"
d383 1
a383 2
	j = xlen + sizeof(w32_buf) + sizeof(w32_hklm) + sizeof(w32_hkcu) +
	    sizeof(w32_a4b);
d407 4
a410 4
		memcpy(buf, w32_buf + i, xlen);
		buf += xlen;
		i += xlen;
		len -= xlen;
@


1.15
log
@get rid of passing (&rs) along
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.14 2009/05/27 09:52:42 tg Stab $"
d85 4
a88 1
static uint8_t w32_rng[128];		/* registry key */
d166 1
a166 1
		u_int rnd[(128 - (sizeof (struct timeval) + sizeof (pid_t))) / sizeof(u_int)];
d172 1
a172 1
	memcpy(rdat.rnd, __vcsid, MIN(sizeof (__vcsid), sizeof (rdat.rnd)));
d175 1
a175 1
	if (arc4_writeback((char *)rdat.rnd, sizeof (rdat.rnd), 1))
d183 1
a183 1
		sz = (size_t)read(fd, rdat.rnd, sizeof (rdat.rnd));
d186 1
a186 1
	if (sz > sizeof (rdat.rnd))
d188 1
a188 1
	if (fd == -1 || sz != sizeof (rdat.rnd)) {
d193 1
a193 1
		size_t i = sz / sizeof (u_int), len;
d205 1
a205 1
		while (i < sizeof (rdat.rnd) / sizeof (u_int)) {
d254 1
a254 1
	while (n < sizeof (tb))
d256 1
a256 1
	if (arc4_writeback(tb, sizeof (tb), 0))
d313 5
d324 39
a362 10
	HKEY hKey;
	DWORD ksz = sizeof (w32_rng);
	size_t i, rv = 1, has_rkey = 0;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
	    "SOFTWARE\\Microsoft\\Cryptography\\RNG", 0,
	    KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey) == ERROR_SUCCESS &&
	    RegQueryValueEx(hKey, "Seed", NULL, NULL, w32_rng, &ksz)
	    == ERROR_SUCCESS)
		has_rkey = 1;
d373 4
a376 1
	if (!CryptGenRandom(p, sizeof (w32_buf), w32_buf)) {
d378 23
a400 1
		rv = 0;
d402 23
a424 22
	if (has_rkey) {
		for (i = 0; i < MAX(96, ksz); ++i)
			w32_buf[i % 96] ^= w32_rng[i % ksz]
			    ^ (i < 96 ? arc4_getbyte() : 0);
		for (i = 97; i < sizeof (w32_buf) - len; ++i)
			w32_buf[i % 96] ^= w32_buf[i];
		for (i = 0; i < MAX(96, len); ++i)
			w32_buf[i % 96] ^= buf[i % len];
		if (rv && RegSetValueEx(hKey, "Seed", 0, REG_BINARY,
		    w32_buf, 80) != ERROR_SUCCESS && !do_rd)
			rv = 0;
		RegCloseKey(hKey);
		arc4_addrandom(w32_buf + 80, 16);
		memset(w32_rng, '\0', sizeof (w32_rng));
	}
	if (rv)
		memcpy(buf, w32_buf + sizeof (w32_buf) - len, len);
	else if (has_rkey)
		for (i = 0; i < MAX(80, len); ++i)
			buf[i % len] ^= w32_buf[i % 80];
	memset(w32_buf, '\0', sizeof (w32_buf));
	return (rv);
d429 1
a429 1
	memcpy(buf, &num, sizeof (num));
d463 2
a464 2
		idat.buf[rlen % sizeof (idat)] ^= cbuf[rlen];
	rlen = MIN(sizeof (idat), MAX(sizeof (struct timeval), len));
d493 1
a493 1
	arc4_writeback((uint8_t *)&buf, sizeof (buf), 0);
@


1.14
log
@apply some -Warning -fixes from
gcc version 4.5.0 20090516 (experimental) [trunk revision 147610] (Debian 20090516-1)
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.12 2008/12/08 18:51:53 tg Exp $"
d35 2
a36 2
 * Copyright (c) 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d103 1
a103 1
struct arc4_stream {
d107 1
a107 1
};
a109 1
static struct arc4_stream rs;
d114 2
a115 2
static uint8_t arc4_getbyte(struct arc4_stream *);
static void stir_finish(struct arc4_stream *, int);
d129 1
a129 1
arc4_init(struct arc4_stream *as)
d131 1
a131 1
	int     n;
d134 3
a136 3
		as->s[n] = (uint8_t)n;
	as->i = 0;
	as->j = 0;
d140 1
a140 1
arc4_addrandom(struct arc4_stream *as, u_char *dat, int datlen)
d142 1
a142 1
	int     n;
d145 1
a145 1
	as->i--;
d147 5
a151 5
		as->i++;
		si = as->s[as->i];
		as->j = (uint8_t)(as->j + si + dat[n % datlen]);
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
d153 1
a153 1
	as->j = as->i;
d157 1
a157 1
arc4_stir(struct arc4_stream *as)
d219 1
a219 1
	fd = arc4_getbyte(as);
d225 1
a225 1
	arc4_addrandom(as, (u_char *)&rdat, sizeof(rdat));
d227 1
a227 1
	stir_finish(as, fd);
d231 1
a231 1
stir_finish(struct arc4_stream *as, int av)
d244 1
a244 1
	n = 256 * 4 + (arc4_getbyte(as) & 0x0FU);
d250 1
a250 1
		arc4_getbyte(as);
d252 1
a252 1
		tb[n++] = arc4_getbyte(as);
d254 1
a254 1
		arc4_getbyte(as);
d259 1
a259 1
arc4_getbyte(struct arc4_stream *as)
d263 7
a269 7
	as->i++;
	si = as->s[as->i];
	as->j = (uint8_t)(as->j + si);
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (as->s[(si + sj) & 0xff]);
d273 1
a273 1
arc4_getword(struct arc4_stream *as)
d276 4
a279 4
	val = (uint32_t)arc4_getbyte(as) << 24;
	val |= (uint32_t)arc4_getbyte(as) << 16;
	val |= (uint32_t)arc4_getbyte(as) << 8;
	val |= (uint32_t)arc4_getbyte(as);
d287 1
a287 1
		arc4_init(&rs);
d291 1
a291 1
	arc4_stir(&rs);
d299 1
a299 1
	arc4_addrandom(&rs, dat, datlen);
d307 1
a307 1
	return arc4_getword(&rs);
d343 1
a343 1
			    ^ (i < 96 ? arc4_getbyte(&rs) : 0);
d352 1
a352 1
		arc4_addrandom(&rs, w32_buf + 80, 16);
d394 1
a394 1
		arc4_init(&rs);
d405 1
a405 1
	arc4_addrandom(&rs, &idat.buf[0], rlen);
d410 2
a411 2
		stir_finish(&rs, idat.buf[5]);
	return (res ^ arc4_getword(&rs));
d426 1
a426 1
		buf.carr[i++] = arc4_getbyte(&rs);
@


1.12
log
@MinGW32
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.11 2008/12/08 18:46:01 tg Exp $"
d135 1
a135 1
		as->s[n] = n;
d148 1
a148 1
		as->i = (as->i + 1);
d150 1
a150 1
		as->j = (as->j + si + dat[n % datlen]);
d226 1
a226 1
	arc4_addrandom(as, (void *)&rdat, sizeof(rdat));
d245 1
a245 1
	n = 256 * 4 + (arc4_getbyte(as) & 0x0F);
d264 1
a264 1
	as->i = (as->i + 1);
d266 1
a266 1
	as->j = (as->j + si);
d277 5
a281 5
	val = arc4_getbyte(as) << 24;
	val |= arc4_getbyte(as) << 16;
	val |= arc4_getbyte(as) << 8;
	val |= arc4_getbyte(as);
	return val;
@


1.11
log
@while EGD socket support (for EGD control sockets and PRNGD sockets only)
is still pending, this will attempt to write into the Win32 registry global
state on pushback, as the CryptoAPI state is only per-process; furthermore,
ensure always 128 KiB are read from CryptoAPI to force its eight RC4(tm)
generators to re-seed on each arc4random_stir(3) operation
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.10 2008/12/08 13:45:18 tg Exp $"
d73 1
a73 1
#if defined(__CYGWIN__)
d75 1
d422 1
a422 1
		u_int8_t carr[240];
@


1.10
log
@some minor cygwin warning
@
text
@d2 1
a2 1
    "\n	@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.9 2008/12/08 13:37:44 tg Exp $"
d59 1
a59 1
#if HAVE_SYS_SYSCTL_H
d63 1
a63 1
#if HAVE_STDINT_H
d82 3
a116 4
#ifdef USE_MS_CRYPTOAPI
static char w32_cryptoapi_getrand(uint8_t *, size_t);
#define arc4_writeback(buf, n, do_rd)	w32_cryptoapi_getrand((buf), (n))
#else
a117 1
#endif
d172 1
a172 1
	if (w32_cryptoapi_getrand((char *)rdat.rnd, sizeof (rdat.rnd)))
a309 1
#ifdef USE_MS_CRYPTOAPI
d311 1
a311 1
w32_cryptoapi_getrand(uint8_t *buf, size_t len)
d313 1
d316 10
a325 1

d329 1
a329 1
				return (0);
d332 1
a332 1
				return (0);
d336 32
a367 2
	return (CryptGenRandom(p, len, buf) ? 1 : 0);
}
a368 3
static char
arc4_writeback(uint8_t *buf, size_t n, char do_rd)
{
a370 5
#ifdef arc4random_pushk
	fd = arc4random_pushk(buf, n);
	memcpy(buf, &fd, sizeof (fd));
	return (do_rd ? 0 : 1);
#else
d372 1
a372 1
		if (write(fd, buf, n) < 4)
a378 1
#endif
@


1.9
log
@improve further: obsd; different name for random device
@
text
@d1 2
a2 2
static const char __vcsid[] =
    "@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.8 2008/12/08 13:31:58 tg Exp $"
a113 1
static char arc4_writeback(uint8_t *, size_t, char);
d117 2
@


1.8
log
@merge stuff from BSD::arc4random arc4random.c; make easier to build
on MirBSD; enhance functionality if OS provides
@
text
@d2 1
a2 1
    "@@(#)rcsid_master: $MirOS: contrib/code/Snippets/arc4random.c,v 1.7 2008/12/08 12:41:04 tg Exp $"
d95 4
d109 1
d179 1
a179 1
	fd = open("/dev/urandom", O_RDONLY);
d188 3
a190 5
//#if defined(CTL_KERN) && defined(KERN_RANDOM) && defined(RANDOM_UUID)
#ifdef _LINUX_SYSCTL_H
		/* XXX this is for Linux, which uses enums */

		int mib[3];
d193 1
d197 5
d205 3
a207 2
			if (sysctl(mib, 3, &rdat.rnd[i++], &len, NULL, 0) == -1) {
				fprintf(stderr, "warning: no entropy source\n");
d341 1
a341 1
	if ((fd = open("/dev/urandom", O_WRONLY)) != -1) {
@


1.7
log
@* add arc4_count from base
* change ifdef __CYGWIN__ into USE_MS_CRYPTOAPI and set it true
  for GNU/Cygwin32 (might want to use it for pcc, mingw, etc. too?)
* add arc4_atexit from base if we have push (MS CryptoAPI)
@
text
@d1 3
a3 1
static const char __rcsid[] = "$MirOS: contrib/code/Snippets/arc4random.c,v 1.6 2008/10/24 21:15:21 tg Exp $";
d65 2
a77 2
#include <stdbool.h>

d91 4
d108 2
d111 2
a112 2
static bool w32_cryptoapi_getrand(uint8_t *, size_t);
static void arc4_atexit(void);
d115 1
d122 1
d158 2
a159 1
		u_int rnd[(128 - sizeof(struct timeval)) / sizeof(u_int)];
d164 2
a165 1
	memcpy(rdat.rnd, __rcsid, MIN(sizeof (__rcsid), sizeof (rdat.rnd)));
d214 1
a214 1
	 * use gettimeofday.
d225 1
d242 4
a279 1
#ifdef USE_MS_CRYPTOAPI
a280 1
#endif
d302 1
a302 1
static bool
d305 1
a305 1
	static bool has_provider = false;
d311 1
a311 1
				return (false);
d314 1
a314 1
				return (false);
d316 1
a316 1
		has_provider = true;
d318 1
a318 1
	return (CryptGenRandom(p, len, buf) ? true : false);
d320 20
d341 1
d364 1
a364 1
	if (w32_cryptoapi_getrand(&idat.buf[0], rlen))
d374 1
d391 1
a391 1
	w32_cryptoapi_getrand((uint8_t *)&buf, sizeof (buf));
a392 1
#endif
@


1.6
log
@label defined but not used on !cygwin (gcc, Solaris)
@
text
@d1 1
a1 1
static const char __rcsid[] = "$MirOS: contrib/code/Snippets/arc4random.c,v 1.5 2008/10/24 21:14:38 tg Exp $";
d69 5
a73 1
#ifdef __CYGWIN__
d98 1
d102 1
a102 1
#ifdef __CYGWIN__
d104 1
d110 1
a110 1
#ifdef __CYGWIN__
d155 1
a155 1
#ifdef __CYGWIN__
d195 1
a195 1
#ifdef __CYGWIN__
d229 1
d263 3
d281 1
a281 1
	if (!rs_initialized || arc4_stir_pid != getpid())
d286 1
a286 1
#ifdef __CYGWIN__
d338 18
@


1.5
log
@add <string.h> and MIN, MAX if not defined
caught by SUNWcc on Solaris (thanks yofuh)
@
text
@d1 1
a1 1
static const char __rcsid[] = "$MirOS: contrib/code/Snippets/arc4random.c,v 1.4 2008/10/20 11:37:38 tg Exp $";
d189 1
d191 1
@


1.4
log
@* allow arc4random_pushb(3) on GNU/Cygwin32
* improve code while here
@
text
@d1 1
a1 1
static const char __rcsid[] = "$MirOS: contrib/code/Snippets/arc4random.c,v 1.3 2008/03/04 22:53:14 tg Exp $";
d66 1
d78 7
@


1.3
log
@arc4random.c:100: warning: ignoring return value of 'read', declared with attribute warn_unused_result
on fedora
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/arc4random.c,v 1.2 2007/09/09 22:14:04 tg Exp $ */
d32 22
d68 9
d88 4
d96 3
d131 1
a131 1
	int     n, fd;
d139 6
d181 3
a183 1
	arc4_stir_pid = getpid();
d190 10
d204 1
d206 6
a211 1
	for (n = 0; n < 256 * 4; n ++)
d265 54
@


1.2
log
@fix for OSF/1
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/Snippets/arc4random.c,v 1.1 2007/09/07 19:28:08 tg Exp $ */
d97 2
a98 1
	}       rdat;
d106 1
a106 1
		read(fd, rdat.rnd, sizeof(rdat.rnd));
d108 4
a111 1
	} else {
d118 1
a118 1
		size_t i, len;
d124 1
a124 1
		for (i = 0; i < sizeof(rdat.rnd) / sizeof(u_int); i ++) {
d126 1
a126 1
			if (sysctl(mib, 3, &rdat.rnd[i], &len, NULL, 0) == -1) {
@


1.1
log
@add arc4random.c from debian mksh-30.1-1 package, plus rcsid
@
text
@d1 1
a1 1
/* $MirOS$ */
d39 3
d47 3
a49 3
	u_int8_t i;
	u_int8_t j;
	u_int8_t s[256];
d56 1
a56 1
static u_int8_t arc4_getbyte(struct arc4_stream *);
d77 1
a77 1
	u_int8_t si;
d149 1
a149 1
static u_int8_t
d152 1
a152 1
	u_int8_t si, sj;
d163 1
a163 1
static u_int32_t
d166 1
a166 1
	u_int32_t val;
@

