head	1.45;
access;
symbols
	joe-3_1jupp38:1.45
	joe-3_1jupp37:1.43
	joe-3_1jupp36:1.43
	joe-3_1jupp35:1.43
	joe-3_1jupp34:1.43
	joe-3_1jupp33:1.43
	joe-3_1jupp32:1.40
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.31
	joe-3_1jupp30:1.28
	joe-3_1jupp29:1.26
	joe-3_1jupp28:1.23
	joe-3_1jupp27:1.23
	joe-3_1jupp26:1.22
	joe-3_1jupp25:1.21
	joe-3_1jupp24:1.20
	joe-3_1jupp23:1.19
	joe-3_1jupp22:1.17
	joe-3_1jupp21:1.17
	joe-3_1jupp20:1.17
	joe-3_1jupp19:1.17
	joe-3_1jupp18:1.15
	joe-3_1jupp17:1.14
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.14
	joe-3_1jupp15:1.12
	joe-3_1jupp14:1.10
	joe-3_1jupp12:1.9
	joe-3_1jupp11:1.8
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.5
	joe-3_1jupp9:1.4
	joe-3_1jupp8:1.3
	joe-3_1jupp7:1.3
	joe-3_1jupp6:1.3
	joe-3_1jupp5:1.3
	joe-3_1jupp4:1.3
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.45
date	2018.11.11.18.51.26;	author tg;	state Exp;
branches;
next	1.44;
commitid	1005BE87A3C06B598B6;

1.44
date	2018.11.11.18.15.37;	author tg;	state Exp;
branches;
next	1.43;
commitid	1005BE871D325833018;

1.43
date	2018.01.07.20.32.46;	author tg;	state Exp;
branches;
next	1.42;
commitid	1005A5284063C3E386D;

1.42
date	2018.01.06.14.06.56;	author tg;	state Exp;
branches;
next	1.41;
commitid	1005A50D7E14BD7CEF8;

1.41
date	2018.01.06.00.28.31;	author tg;	state Exp;
branches;
next	1.40;
commitid	1005A50184621FA8455;

1.40
date	2017.12.08.03.24.15;	author tg;	state Exp;
branches;
next	1.39;
commitid	1005A2A05EB07C8D953;

1.39
date	2017.12.08.02.28.05;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005A29F8C708B176AB;

1.38
date	2017.12.07.02.10.16;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005A28A3145E1FF911;

1.37
date	2017.12.06.23.02.03;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005A2876FC4FFE7EF5;

1.36
date	2017.12.06.21.16.58;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005A285E5918D423C7;

1.35
date	2017.12.03.02.39.32;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A2363FB473B43ED;

1.34
date	2017.12.03.02.36.02;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A2363204B0C4612;

1.33
date	2017.12.02.04.32.40;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A222CF2122034D9;

1.32
date	2017.12.02.02.07.28;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A220AD65C90E687;

1.31
date	2017.08.08.21.39.28;	author tg;	state Exp;
branches;
next	1.30;
commitid	100598A2FA50A3266A7;

1.30
date	2017.08.08.21.30.47;	author tg;	state Exp;
branches;
next	1.29;
commitid	100598A2D911B6F8739;

1.29
date	2017.08.08.21.27.39;	author tg;	state Exp;
branches;
next	1.28;
commitid	100598A2CDB77FB3564;

1.28
date	2017.01.11.21.48.58;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005876A846752BE184;

1.27
date	2017.01.11.19.26.54;	author tg;	state Exp;
branches;
next	1.26;
commitid	100587686986AD3A77F;

1.26
date	2016.10.29.23.44.45;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005815347F236258ED;

1.25
date	2016.10.07.20.09.55;	author tg;	state Exp;
branches;
next	1.24;
commitid	10057F8012D3102E599;

1.24
date	2016.01.16.23.03.40;	author tg;	state Exp;
branches;
next	1.23;
commitid	100569ACC5E522AD548;

1.23
date	2014.03.04.23.04.11;	author tg;	state Exp;
branches;
next	1.22;
commitid	10053165C030FE8B28B;

1.22
date	2013.11.07.21.15.04;	author tg;	state Exp;
branches;
next	1.21;
commitid	100527C02E5787F5D7D;

1.21
date	2013.08.19.23.05.11;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005212A4BB2412C92E;

1.20
date	2013.01.05.22.16.31;	author tg;	state Exp;
branches;
next	1.19;
commitid	10050E8A62658CA1DDF;

1.19
date	2012.12.30.21.45.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	10050E0B5FE41C91584;

1.18
date	2012.12.22.00.06.12;	author tg;	state Exp;
branches;
next	1.17;
commitid	10050D4F965570AEE79;

1.17
date	2012.06.07.23.38.17;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FD13B7F5D8CFBBB;

1.16
date	2012.06.07.22.39.54;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004FD12DD10ADFC4F7;

1.15
date	2011.10.04.22.25.52;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004E8B8807642C8708;

1.14
date	2011.07.16.22.01.28;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004E220A4F356CB704;

1.13
date	2011.07.16.21.57.57;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004E2209506F4A1334;

1.12
date	2011.07.03.00.35.04;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004E0FB941774BF3C1;

1.11
date	2011.07.02.23.47.57;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004E0FAE34164651D4;

1.10
date	2010.04.08.15.31.02;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004BBDF6C54CC9A0DB;

1.9
date	2009.10.18.14.17.34;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004ADB237E67C2F65E;

1.8
date	2009.08.02.16.13.25;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004A75BB3707CB4EAC;

1.7
date	2009.08.02.16.06.29;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004A75B99B119B5778;

1.6
date	2009.08.02.15.47.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004A75B5265F7C4E4F;

1.5
date	2008.07.28.00.12.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	100488D0E7907247606;

1.4
date	2008.05.13.13.08.23;	author tg;	state Exp;
branches;
next	1.3;
commitid	100482992BC01EE89A1;

1.3
date	2005.02.12.14.39.09;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.21;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.45
log
@this should fix opening files called +DESC (MirPorts)
@
text
@#define JUPP_IS_COPYRIGHT_C_BY "2018 mirabilos"

/*-
 * Copyright (c) 2004ff. Thorsten Glaser
 * Copyright (C) 1992 Joseph H. Allen
 *
 * This file is part of "jupp", a variant of Joe's Own Editor "JOE".
 *
 * jupp is free software; you can redistribute and/or modify it, deal
 * in the work, etc. under the terms of the GNU General Public Licen-
 * se, version 1 (of February 1989) as published by the Free Software
 * Foundation, reproduced in the file COPYING in the jupp source code
 * distribution. If jupp is combined with other independent work, for
 * example libraries or when using crunchgen, into a combined binary,
 * that may be conveyed under any version of the GPL, as published by
 * the Free Software Foundation, and any compatible licence permitted
 * by any version of the GPL, as above.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Editor startup and main edit loop
 */

#define EXTERN
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.44 2018/11/11 18:15:37 tg Exp $");

#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "b.h"
#include "help.h"
#include "kbd.h"
#include "macro.h"
#include "main.h"
#include "path.h"
#include "rc.h"
#include "scrn.h"
#include "termcap.h"
#include "tw.h"
#include "vfile.h"
#include "vs.h"
#include "w.h"
#include "charmap.h"
#include "syntax.h"
#include "utils.h"

extern int mid, dspasis, pgamnt, nobackups, lightoff, exask, lines, columns, dopadding, marking, dobeep;

extern int idleout;		/* Clear to use /dev/tty for screen */
extern unsigned char *joeterm;
int help = 0;			/* Set to have help on when starting */
int nonotice = 0;		/* Set to prevent copyright notice */
int orphan = 0;
unsigned char *exmsg = NULL;		/* Message to display when exiting the editor */

SCREEN *maint;			/* Main edit screen */

const char null[] = "";

#ifdef __CYGWIN__
extern unsigned char *cygwin32_cmdline(void);
#endif

#define is_ofsopt(ap) (0[ap] == '+' && 1[ap] >= '0' && 1[ap] <= '9')

/* Make windows follow cursor */

void dofollows(void)
{
	W *w = maint->curwin;

	do {
		if (w->y != -1 && w->watom->follow && w->object.base)
			w->watom->follow(w->object);
		w = (W *) (w->link.next);
	} while (w != maint->curwin);
}

/* Update screen */

int dostaupd = 1;
extern int staupd;

void edupd(int flg)
{
	W *w;
	int wid, hei;

	if (dostaupd) {
		staupd = 1;
		dostaupd = 0;
	}
	ttgtsz(&wid, &hei);
	if ((wid >= 2 && wid != maint->w) || (hei >= 1 && hei != maint->h)) {
		nresize(maint->t, wid, hei);
		sresize(maint);
	}
	dofollows();
	ttflsh();
	nscroll(maint->t);
	help_display(maint);
	w = maint->curwin;
	do {
		if (w->y != -1) {
			if (w->object.base && w->watom->disp)
				w->watom->disp(w->object, flg);
			msgout(w);
		}
		w = (W *) (w->link.next);
	} while (w != maint->curwin);
	cpos(maint->t, maint->curwin->x + maint->curwin->curx, maint->curwin->y + maint->curwin->cury);
	staupd = 0;
}

static int ahead = 0;
static int ungot = 0;
static int ungotc = 0;

void nungetc(int c)
{
	if (c != 'C' - '@@' && c != 'M' - '@@') {
		chmac();
		ungot = 1;
		ungotc = c;
	}
}

int edloop(int flg)
{
	int term = 0;
	int ret = 0;

	if (flg) {
		if (maint->curwin->watom->what == TYPETW)
			return 0;
		else
			maint->curwin->notify = &term;
	}
	while (!leave && (!flg || !term)) {
		MACRO *m;
		int c;

		if (exmsg && !flg) {
			vsrm(exmsg);
			exmsg = NULL;
		}
		edupd(1);
		if (!ahead && !have)
			ahead = 1;
		if (ungot) {
			c = ungotc;
			ungot = 0;
		} else
			c = ttgetc();

		if (!ahead && c == 10)
			c = 13;
		m = dokey(maint->curwin->kbd, c);
		if (maint->curwin->main && maint->curwin->main != maint->curwin) {
			int x = maint->curwin->kbd->x;

			maint->curwin->main->kbd->x = x;
			if (x)
				maint->curwin->main->kbd->seq[x - 1] = maint->curwin->kbd->seq[x - 1];
		}
		if (m)
			ret = exemac(m);
	}

	if (term == -1)
		return -1;
	else
		return ret;
}

unsigned char **mainenv;

static int
main_init(int argc, char **argv, char **envp, SCRN **np)
{
	CAP *cap;
	unsigned char *s;
	unsigned char *run;
	SCRN *n;
	W *opened = NULL;
	int omid;
	int backopt;
	int c;

	jalloc_init();
	init_JOERC();
	joe_locale();

	mainenv = (unsigned char **)envp;
	run = namprt(argv[0]);

	if ((s = (unsigned char *)getenv("LINES")) != NULL)
		lines = ustol(s, NULL, USTOL_DEC | USTOL_EOS);
	if ((s = (unsigned char *)getenv("COLUMNS")) != NULL)
		columns = ustol(s, NULL, USTOL_DEC | USTOL_EOS);
	if ((s = (unsigned char *)getenv("BAUD")) != NULL)
		Baud = ustol(s, NULL, USTOL_DEC | USTOL_EOS);
	if (getenv("DOPADDING"))
		dopadding = 1;
	if (getenv("NOXON"))
		noxon = 1;
	if ((s = (unsigned char *)getenv("JOETERM")) != NULL)
		joeterm = s;

	if (!(cap = getcap(NULL, 9600, NULL, NULL))) {
		fprintf(stderr, "Couldn't load termcap/terminfo entry\n");
		return 1;
	}

	s = (unsigned char *)getenv("HOME");
	if (s) {
		s = vsncpy(NULL, 0, sz(s));
		s = vsncpy(sv(s), sc("/."));
		s = vsncpy(sv(s), sv(run));
		s = vsncpy(sv(s), sc("rc"));
		c = procrc(cap, s);
		if (c == 0)
			goto donerc;
		if (c == 1) {
			unsigned char buf[8];

			fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
			fflush(stderr);
			if (fgets((char *)buf, 8, stdin) != NULL &&
			    (buf[0] | 0x20) == 'y')
				goto donerc;
		}
	}

	if (has_JOERC) {
		vsrm(s);
		s = vsncpy(NULL, 0, sz(get_JOERC));
		s = vsncpy(sv(s), sv(run));
		s = vsncpy(sv(s), sc("rc"));
		c = procrc(cap, s);
		if (c == 0)
			goto donerc;
		if (c == 1) {
			unsigned char buf[8];

			fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
			fflush(stderr);
			if (fgets((char *)buf, 8, stdin) != NULL &&
			    (buf[0] | 0x20) == 'y')
				goto donerc;
		}
	}

	/* Try built-in joerc */
	vsrm(s);
	s = vsncpy(NULL, 0, sc("*"));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush(stderr);
		if (fgets((char *)buf, 8, stdin) != NULL &&
		    (buf[0] | 0x20) == 'y')
			goto donerc;
	}

	fprintf(stderr, "Couldn't open '%s'\n", s);
	return 1;

 donerc:
	help_init(s);
	for (c = 1; argv[c]; ++c) {
		if (argv[c][0] == '-') {
#ifdef __CYGWIN__
			if (!strcmp(argv[c], "-CYGhack")) {
				s = cygwin32_cmdline();
				s = strstr(s, "-CYGhack");
				if (s) {
					s += /* strlen("-CYGhack") */ 8;
					while (*s == ' ' || *s == '\t')
						++s;
					argv[c] = s;
					argv[c + 1] = NULL;
					break;
				}
			}
#endif
			if (argv[c][1])
				switch (glopt(argv[c] + 1, argv[c + 1], NULL, 1)) {
				case 0:
					fprintf(stderr, "Unknown option '%s'\n", argv[c]);
					break;
				case 1:
					break;
				case 2:
					++c;
					break;
			} else
				idleout = 0;
		}
	}

#if HAVE_ISATTY
	if (idleout && (!isatty(0) || !isatty(1)))
		idleout = 0;
#endif

	if (!(n = nopen(cap)))
		return 1;
	maint = screate(n);
	vmem = vtmp();

	for (c = 1, backopt = 0; argv[c]; ++c)
		if (is_ofsopt(argv[c])) {
			if (!backopt)
				backopt = c;
		} else if (argv[c][0] == '-' && argv[c][1]) {
			if (!backopt)
				backopt = c;
			if (glopt(argv[c] + 1, argv[c + 1], NULL, 0) == 2)
				++c;
		} else {
			B *b = bfind(argv[c]);
			BW *bw = NULL;
			int er = error;

			if (!orphan || !opened) {
				bw = wmktw(maint, b);
				if (!bw)
					goto wmktw_failed;
				if (er)
					msgnwt(bw->parent, msgs[-er]);
			} else
				b->orphan = 1;
			if (bw) {
				long lnum = 0;

				bw->o.readonly = bw->b->rdonly;
				if (backopt) {
					unsigned char *old_context;

					old_context = bw->o.context;
					while (backopt != c) {
						if (is_ofsopt(argv[backopt])) {
							lnum = ustol(argv[backopt] + 1, NULL, USTOL_TRIM | USTOL_EOS);
							++backopt;
						} else {
							if (glopt(argv[backopt] + 1, argv[backopt + 1], &bw->o, 0) == 2)
								backopt += 2;
							else
								backopt += 1;
							lazy_opts(&bw->o);
						}
					}
					if (old_context != bw->o.context) {
						/* update keymap */
						rmkbd(bw->parent->kbd);
						bw->parent->kbd =
						    mkkbd(kmap_getcontext(bw->o.context, 1));
					}
				}
				bw->b->o = bw->o;
				bw->b->rdonly = bw->o.readonly;
				if (!opened || opened == (void *)&opened)
					opened = bw->parent;
				maint->curwin = bw->parent;
				if (er == -1 && bw->o.mnew)
					exemac(bw->o.mnew);
				if (er == 0 && bw->o.mold)
					exemac(bw->o.mold);
				maint->curwin = opened;
				if (lnum > 0)
					pline(bw->cursor, lnum - 1);
			}
			if (!opened)
				opened = (void *)&opened;
			backopt = 0;
		}

	maint->curwin = opened == (void *)&opened ? NULL : opened;
	if (opened) {
		wshowall(maint);
		omid = mid;
		mid = 1;
		dofollows();
		mid = omid;
	} else {
		BW *bw = wmktw(maint, bfind(UC ""));

		if (!bw) {
 wmktw_failed:
			fprintf(stderr, "maint->h < 1, cannot happen\n");
			return (1);
		}
		if (bw->o.mnew)
			exemac(bw->o.mnew);
	}
	maint->curwin = maint->topwin;

	if (help) {
		help_on(maint);
	}
	if (!nonotice) {
		int uninvert = fdefault.hmsg &&
		    fdefault.hmsg[0] == '\\' &&
		    fdefault.hmsg[1] == 'i';

		joe_snprintf_5((char *)msgbuf, JOE_MSGBUFSIZE,
		    "\\i[ Joe's Own Editor v" VERSION
		    " | %s | %s " JUPP_IS_COPYRIGHT_C_BY " ]%s%s%s",
		    locale_map->name, locale_map->type ? "©" : "(c)",
		    uninvert ? "\\i " : fdefault.hmsg ? " " : "",
		    uninvert ? fdefault.hmsg + 2 : fdefault.hmsg ?
		    fdefault.hmsg : "", uninvert ? "" : "\\i");
		msgnw(lastw(maint)->object.base->parent, msgbuf);
	}

	*np = n;
	return 0;
}

int main_rv;

int
main(int argc, char **argv, char **envp)
{
	SCRN *n;

	if ((main_rv = main_init(argc, argv, envp, &n)))
		return (main_rv);

	edloop(0);
	vclose(vmem);
	nclose(n);
	if (exmsg)
		fprintf(stderr, "\n%s\n", exmsg);
	return (main_rv);
}
@


1.44
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.42 2018/01/06 14:06:56 tg Exp $");
d76 2
d331 1
a331 1
		if (argv[c][0] == '+' && argv[c][1]) {
d361 1
a361 1
						if (argv[backopt][0] == '+') {
@


1.43
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d344 2
d405 5
@


1.42
log
@if -hmsg begins with exactly \i, do not invert it and the preceding space
(also does not require a trailing \i); make all hmsg in blinking bold
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.40 2017/12/08 03:24:15 tg Exp $");
d200 1
@


1.41
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d411 5
a415 1
		joe_snprintf_4((char *)msgbuf,JOE_MSGBUFSIZE,
d417 1
a417 1
		    " | %s | %s " JUPP_IS_COPYRIGHT_C_BY " ]%s%s\\i",
d419 3
a421 2
		    fdefault.hmsg ? " " : "",
		    fdefault.hmsg ? fdefault.hmsg : "");
@


1.40
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@d1 1
a1 1
#define JUPP_IS_COPYRIGHT_C_BY "2017 mirabilos"
d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.38 2017/12/07 02:10:16 tg Exp $");
d400 1
a400 1
		BW *bw = wmktw(maint, bfind(US ""));
@


1.39
log
@label indent; small tweaks while here
@
text
@d239 1
a239 1
			    (buf[0] == 'y' || buf[0] == 'Y'))
d258 1
a258 1
			    (buf[0] == 'y' || buf[0] == 'Y'))
d277 1
a277 1
		    (buf[0] == 'y' || buf[0] == 'Y'))
@


1.38
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.37 2017/12/06 23:02:03 tg Exp $");
d284 1
a284 1
      donerc:
@


1.37
log
@lots of fixes related to prototyping
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.36 2017/12/06 21:16:58 tg Exp $");
d83 1
a83 1
		if (w->y != -1 && w->watom->follow && w->object)
d115 1
a115 1
			if (w->object && w->watom->disp)
d417 1
a417 1
		msgnw(((BASE *)lastw(maint)->object)->parent, msgbuf);
@


1.36
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.35 2017/12/03 02:39:32 tg Exp $");
d46 1
d59 1
a59 1
extern int mid, dspasis, help, pgamnt, nobackups, lightoff, exask, lines, columns, dopadding, marking, dobeep;
@


1.35
log
@missing header
@
text
@d35 1
a35 1
__RCSID("$MirOS: contrib/code/jupp/main.c,v 1.32 2017/12/02 02:07:28 tg Exp $");
a38 1
#ifdef HAVE_STDLIB_H
a39 1
#endif
@


1.34
log
@first cut at getting rid of stdio: scanf half
@
text
@d58 1
@


1.33
log
@some fallout of the includes changes, some more reduction
@
text
@d207 1
a207 1
		sscanf((char *)s, "%d", &lines);
d209 1
a209 1
		sscanf((char *)s, "%d", &columns);
d211 1
a211 1
		sscanf((char *)s, "%u", &Baud);
d357 1
a357 1
							sscanf((char *)(argv[backopt] + 1), "%ld", &lnum);
@


1.32
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d35 1
a35 1
__RCSID("$MirOS$");
a55 1
#include "utf8.h"
@


1.31
log
@new command abendjoe to exit 1
@
text
@a0 2
/* $MirOS: contrib/code/jupp/main.c,v 1.29 2017/08/08 21:27:39 tg Exp $ */

d31 1
d35 2
a36 1
#include <stdio.h>
@


1.30
log
@make “find … | xargs jupp” work in the absence of BSD xargs -o (e.g. GNU)
@
text
@d425 2
a429 1
	int rv;
d432 2
a433 2
	if ((rv = main_init(argc, argv, envp, &n)))
		return (rv);
d440 1
a440 1
	return (0);
@


1.29
log
@small code reorganisation to reduce total stack (etc.) size
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.23 2014/03/04 23:04:11 tg Exp $ */
d42 1
d318 5
@


1.28
log
@consolidate anything using <windows.h> into one .c file existing precisely for that purpose
@
text
@d188 2
a189 1
int main(int argc, char **argv, char **envp)
d415 13
d433 1
a433 1
	return 0;
@


1.27
log
@add -CYGhack command line option; use it in right-click menu…

the details are buried deep in cygwin32 source code, but it boils down to:

C:\>ga \\foo\bar baz.txt
argv[1] = \\foo\bar
argv[2] = baz.txt
C:\>ga "\\foo\bar baz.txt"
argv[1] = \foo\bar baz.txt
argv[2] IS NULL

I consider this a bug, but as it’s there, let’s parse our command line
on our own… again with the codepage dance we already use in utf8.c…
(and now I also know why the set of permissible filenames is so limited)

… anyway, it works (I tested it on my win2k VM)!
@
text
@d73 1
a73 1
static unsigned char *cygwin32_cmdline(void);
a420 16

#ifdef __CYGWIN__
#include <windows.h>

/* return command line as passed to the .EXE (just like cygwin32’s dcrt0.cc) */
static unsigned char *
cygwin32_cmdline(void)
{
	char *cp;

	cp = strdup(GetCommandLineA());
	if (!AreFileApisANSI())
		CharToOemA(cp, cp);
	return ((unsigned char *)cp);
}
#endif
@


1.26
log
@first cut at win32 self-relocation
@
text
@d3 1
a3 1
#define JUPP_IS_COPYRIGHT_C_BY "2016 mirabilos"
d72 4
d287 14
d421 16
@


1.25
log
@mop up a bit
@
text
@d195 1
d239 10
a248 9
	vsrm(s);
	s = vsncpy(NULL, 0, sc(JOERC));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];
d250 6
a255 5
		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush(stderr);
		if (fgets((char *)buf, 8, stdin) != NULL &&
		    (buf[0] == 'y' || buf[0] == 'Y'))
			goto donerc;
@


1.24
log
@document better the library exception for later GPL versions
@
text
@d3 1
a3 1
#define JUPP_IS_COPYRIGHT_C_BY "2014 mirabilos"
@


1.23
log
@fix compilation on SuSE Linux 1.0
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.22 2013/11/07 21:15:04 tg Exp $ */
d19 1
a19 1
 * by the GPL.
@


1.22
log
@fix -mold etc. when passing multiple files on the cmdline
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.21 2013/08/19 23:05:11 tg Exp $ */
d3 1
a3 1
#define JUPP_IS_COPYRIGHT_C_BY "2013 mirabilos"
@


1.21
log
@refresh
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.20 2013/01/05 22:16:31 tg Exp $ */
d190 1
a190 1
	int opened = 0;
d349 3
a351 2
				if (!opened)
					maint->curwin = bw->parent;
d356 1
d360 2
a361 1
			opened = 1;
d365 1
@


1.20
log
@BUGFIX: using -guess_indent, which is a global option, in per-file context
leads to… surprises (two-space indentation in asm.h WTF‽); fix and release
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.19 2012/12/30 21:45:16 tg Exp $ */
a181 5
#ifdef __MSDOS__
extern void setbreak();
extern int breakflg;
#endif

a188 3
#ifdef __MSDOS__
	unsigned char *rundir;
#endif
a197 13

#ifdef __MSDOS__
	_fmode = O_BINARY;
	strcpy(stdbuf, argv[0]);
	joesep(stdbuf);
	run = namprt(stdbuf);
	rundir = dirprt(stdbuf);
	for (c = 0; run[c]; ++c)
		if (run[c] == '.') {
			run = vstrunc(run, c);
			break;
		}
#else
a198 1
#endif
a212 1
#ifndef __MSDOS__
a216 36
#endif

#ifdef __MSDOS__

	s = vsncpy(NULL, 0, sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush(stderr);
		fgets(buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y')
			goto donerc;
	}

	vsrm(s);
	s = vsncpy(NULL, 0, sv(rundir));
	s = vsncpy(sv(s), sv(run));
	s = vsncpy(sv(s), sc("rc"));
	c = procrc(cap, s);
	if (c == 0)
		goto donerc;
	if (c == 1) {
		unsigned char buf[8];

		fprintf(stderr, "There were errors in '%s'.  Use it anyway?", s);
		fflush(stderr);
		fgets(buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y')
			goto donerc;
	}
#else
a271 1
#endif
@


1.19
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.17 2012/06/07 23:38:17 tg Exp $ */
d3 1
a3 1
#define JUPP_IS_COPYRIGHT_C_BY "2012 mirabilos"
@


1.18
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d404 1
a404 1
						    mkkbd(kmap_getcontext(bw->o.context));
@


1.17
log
@use less (slightly different) copies of licences, and allow (even static) linking with an {,L}GPLv[23]{,+} libc/libtermcap/libselinux/…
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.15 2011/10/04 22:25:52 tg Exp $ */
d70 2
@


1.16
log
@bump to 3.1.19
@
text
@d5 3
a7 4
/*
 *	Editor startup and main edit loop
 *	Copyright
 *		(C) 1992 Joseph H. Allen
d9 22
a30 1
 * 	This file is part of JOE (Joe's Own Editor)
d32 1
@


1.15
log
@Unbreak passing -keymap on the command line
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.14 2011/07/16 22:01:28 tg Exp $ */
d3 1
a3 1
#define JUPP_IS_COPYRIGHT_C_BY "2011 mirabilos"
@


1.14
log
@bump
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.13 2011/07/16 21:57:57 tg Exp $ */
d362 3
d377 6
@


1.13
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 4
a4 1
/* $MirOS: contrib/code/jupp/main.c,v 1.12 2011/07/03 00:35:04 tg Exp $ */
d410 1
a410 1
		    " | %s | %s 2011 mirabilos ]%s%s\\i",
@


1.12
log
@dynamic help string needed, e.g. jpico has ^G for help…
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.11 2011/07/02 23:47:57 tg Exp $ */
d265 2
a266 2
			fgets((char *)buf, 8, stdin);
			if (buf[0] == 'y' || buf[0] == 'Y')
d283 2
a284 2
		fgets((char *)buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y')
d301 2
a302 2
		fgets((char *)buf, 8, stdin);
		if (buf[0] == 'y' || buf[0] == 'Y')
@


1.11
log
@forgot to bump © year and something I promised gecko2@@ and other cow-orkers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.10 2010/04/08 15:31:02 tg Exp $ */
d405 6
a410 4
		joe_snprintf_2((char *)msgbuf,JOE_MSGBUFSIZE,
		    "\\i** Joe's Own Editor v" VERSION
		    " ** (%s) ** %s 2011 mirabilos ** ^J = Help **\\i",
		    locale_map->name, locale_map->type ? "©" : "(c)");
@


1.10
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.9 2009/10/18 14:17:34 tg Exp $ */
d407 1
a407 1
		    " ** (%s) ** Copyright %s 2010 mirabilos **\\i",
@


1.9
log
@add built-in (minimal) jupprc, for stand-alone things
backported from joe 3.7 (Debian)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.8 2009/08/02 16:13:25 tg Exp $ */
d35 1
a35 1
extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff, exask, skiptop, noxon, lines, staen, columns, Baud, dopadding, marking, dobeep;
d407 1
a407 1
		    " ** (%s) ** Copyright %s 2009 **\\i",
@


1.8
log
@more typos in one line than that… gah!
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.7 2009/08/02 16:06:29 tg Exp $ */
d287 18
@


1.7
log
@awesome typo
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.6 2009/08/02 15:47:31 tg Exp $ */
d390 1
a390 1
		    locale_map->type ? "©" : "(c)", locale_map->name);
@


1.6
log
@bump to joe 3.1jupp11
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.5 2008/07/28 00:12:06 tg Exp $ */
d390 1
a390 1
		    locale_map->type ? "©" ? "(c)", locale_map->name);
@


1.5
log
@rename symbol to avoid clash:

/usr/bin/ld: warning multiple definitions of symbol _beep
cmd.o definition of _beep in section (__DATA,__data)
/private/var/tglaser/iSDK/lib/libncurses.dylib(single module) definition of _beep

found during native(!) compilation on iPhone 3G (Darwin 9.3.1
iPhoneOS 2.0 iPhone1,2 arm N82AP), with gcc from saurik iphone-gcc
and headers and libraries copied from the 2.0 SDK. (It works fine.)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/main.c,v 1.4 2008/05/13 13:08:23 tg Exp $ */
d387 4
a390 5
		if (locale_map->type)
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright © 2005 **\\i",locale_map->name);
		else
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright (C) 2005 **\\i",locale_map->name);

@


1.4
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d35 1
a35 1
extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff, exask, skiptop, noxon, lines, staen, columns, Baud, dopadding, marking, beep;
@


1.3
log
@bump year here, too
@
text
@d1 1
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d387 1
a387 1
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright © 2004 **\\i",locale_map->name);
d389 1
a389 1
			joe_snprintf_1((char *)msgbuf,JOE_MSGBUFSIZE,"\\i** Joe's Own Editor v" VERSION " ** (%s) ** Copyright (C) 2004 **\\i",locale_map->name);
@


1.1
log
@Initial revision
@
text
@d162 1
a162 1
int main(int argc, unsigned char **argv, unsigned char **envv)
d178 1
a178 1
	mainenv = envv;
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
 /* Editor startup and main edit loop
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d13 6
a18 3
#include "config.h"
#include "w.h"
#include "tty.h"
a19 5
#include "rc.h"
#include "vfile.h"
#include "b.h"
#include "bw.h"
#include "tw.h"
a21 1
#include "vs.h"
d23 2
d26 16
a41 12
#include "main.h"

extern int mid, dspasis, force, help, pgamnt, nobackups, lightoff,
           exask, skiptop, noxon, lines, staen, columns, Baud, dopadding,
           marking, beep;

extern int idleout;	/* Clear to use /dev/tty for screen */
extern char *joeterm;
int help=0;		/* Set to have help on when starting */
int nonotice=0;		/* Set to prevent copyright notice */
int orphan=0;
char *exmsg=0;		/* Message to display when exiting the editor */
d43 1
a43 1
SCREEN *maint;		/* Main edit screen */
d47 10
a56 10
void dofollows()
 {
 W *w=maint->curwin;
 do
  {
  if(w->y!= -1 && w->watom->follow && w->object) w->watom->follow(w->object);
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 }
d60 1
a60 1
int dostaupd=1;
d63 91
a153 81
void edupd(flg)
 {
 W *w;
 int wid,hei;
 if(dostaupd) staupd=1, dostaupd=0;
 ttgtsz(&wid,&hei);
 if(wid>=2 && wid!=maint->w ||
    hei>=1 && hei!=maint->h)
  {
  nresize(maint->t,wid,hei);
  sresize(maint);
  }
 dofollows();
 ttflsh();
 nscroll(maint->t);
 dsphlp(maint);
 w=maint->curwin; do
  {
  if(w->y!= -1)
   {
   if(w->object && w->watom->disp) w->watom->disp(w->object,flg);
   msgout(w);
   }
  w=(W *)(w->link.next);
  }
  while(w!=maint->curwin);
 cpos(maint->t,
      maint->curwin->x+maint->curwin->curx,
      maint->curwin->y+maint->curwin->cury);
 staupd=0;
 }

static int ahead=0;
static int ungot=0;
static int ungotc=0;

void nungetc(c)
 {
 if(c!='C'-'@@' && c!='M'-'@@')
  {
  chmac();
  ungot=1;
  ungotc=c;
  }
 }

int edloop(flg)
 {
 int term=0;
 int ret=0;
 SCRN *n=maint->t;
 if(flg)
  if(maint->curwin->watom->what==TYPETW) return 0;
  else maint->curwin->notify= &term;
 while(!leave && (!flg || !term))
  {
  MACRO *m;
  int c;
  if(exmsg && !flg)
   {
   vsrm(exmsg);
   exmsg=0;
   }
  edupd(1);
  if(!ahead && !have) ahead=1;
  if(ungot) c=ungotc, ungot=0;
  else c=ttgetc();
  if(!ahead && c==10) c=13;
  m=dokey(maint->curwin->kbd,c);
  if(maint->curwin->main && maint->curwin->main!=maint->curwin)
   {
   int x=maint->curwin->kbd->x;
   maint->curwin->main->kbd->x=x;
   if(x)
    maint->curwin->main->kbd->seq[x-1]=maint->curwin->kbd->seq[x-1];
   }
  if(m) ret=exemac(m);
  }
 if(term== -1) return -1;
 else return ret;
 }
d160 1
a160 1
char **mainenv;
d162 15
a176 14
int main(argc,argv,envv)
int argc;
char *argv[];
char *envv[];
 {
 CAP *cap;
 char *s;
 char *run;
 char *rundir;
 SCRN *n;
 int opened=0;
 int omid;
 int backopt;
 int c;
d178 1
a178 1
 mainenv=envv;
d181 10
a190 11
 _fmode=O_BINARY;
 zcpy(stdbuf,argv[0]);
 joesep(stdbuf);
 run=namprt(stdbuf);
 rundir=dirprt(stdbuf);
 for(c=0;run[c];++c)
  if(run[c]=='.')
   {
   run=vstrunc(run,c);
   break;
   }
d192 2
a193 2
 run=namprt(argv[0]);
#endif 
d195 12
a206 6
 if(s=getenv("LINES")) sscanf(s,"%d",&lines);
 if(s=getenv("COLUMNS")) sscanf(s,"%d",&columns);
 if(s=getenv("BAUD")) sscanf(s,"%u",&Baud);
 if(getenv("DOPADDING")) dopadding=1;
 if(getenv("NOXON")) noxon=1;
 if(s=getenv("JOETERM")) joeterm=s;
d209 4
a212 5
 if(!(cap=getcap(NULL,9600,NULL,NULL)))
  {
  fprintf(stderr,"Couldn't load termcap/terminfo entry\n");
  return 1;
  }
d217 31
a247 28
 s=vsncpy(NULL,0,sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

 vsrm(s);
 s=vsncpy(NULL,0,sv(rundir));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

d250 36
a285 49
 s=vsncpy(NULL,0,sc("."));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

 vsrm(s);
 s=getenv("HOME");
 if(s)
  {
  s=vsncpy(NULL,0,sz(s));
  s=vsncpy(sv(s),sc("/."));
  s=vsncpy(sv(s),sv(run));
  s=vsncpy(sv(s),sc("rc"));
  c=procrc(cap,s);
  if(c==0) goto donerc;
  if(c==1)
   {
   char buf[8];
   fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
   fflush(stderr);
   fgets(buf,8,stdin);
   if(buf[0]=='y' || buf[0]=='Y') goto donerc;
   }
  }

 vsrm(s);
 s=vsncpy(NULL,0,sc(JOERC));
 s=vsncpy(sv(s),sv(run));
 s=vsncpy(sv(s),sc("rc"));
 c=procrc(cap,s);
 if(c==0) goto donerc;
 if(c==1)
  {
  char buf[8];
  fprintf(stderr,"There were errors in '%s'.  Use it anyway?",s);
  fflush(stderr);
  fgets(buf,8,stdin);
  if(buf[0]=='y' || buf[0]=='Y') goto donerc;
  }

d288 2
a289 2
 fprintf(stderr,"Couldn't open '%s'\n",s);
 return 1;
d291 110
a400 84
 donerc:
 izhelp();
 for(c=1;argv[c];++c)
  if(argv[c][0]=='-')
   if(argv[c][1])
    switch(glopt(argv[c]+1,argv[c+1],NULL,1))
     {
     case 0: fprintf(stderr,"Unknown option '%s'\n",argv[c]); break;
     case 1: break;
     case 2: ++c; break;
     }
   else idleout=0;

 if(!(n=nopen(cap))) return 1;
 maint=screate(n);
 vmem=vtmp();

 for(c=1,backopt= 0;argv[c];++c)
  if(argv[c][0]=='+' && argv[c][1])
   {
   if(!backopt) backopt=c;
   }
  else if(argv[c][0]=='-' && argv[c][1])
   {
   if(!backopt) backopt=c;
   if(glopt(argv[c]+1,argv[c+1],NULL,0)==2) ++c;
   }
  else
   {
   B *b=bfind(argv[c]);
   BW *bw=0;
   int er=error;
   if(!orphan || !opened)
    {
    bw=wmktw(maint,b);
    if(er) msgnwt(bw,msgs[5+er]);
    }
   else b->orphan=1;
   if(bw)
    {
    long lnum=0;
    bw->o.readonly=bw->b->rdonly;
    if(backopt) while(backopt!=c)
     if(argv[backopt][0]=='+')
      {
      sscanf(argv[backopt]+1,"%ld",&lnum);
      ++backopt;
      }
     else
      if(glopt(argv[backopt]+1,argv[backopt+1],&bw->o,0)==2) backopt+=2;
      else backopt+=1;
    bw->b->o=bw->o;
    bw->b->rdonly=bw->o.readonly;
    maint->curwin=bw->parent;
    if(er== -1 && bw->o.mnew) exemac(bw->o.mnew);
    if(er==0 && bw->o.mold) exemac(bw->o.mold);
    if(lnum>0) pline(bw->cursor,lnum-1);
    }
   opened=1;
   backopt=0;
   }

 if(opened)
  {
  wshowall(maint);
  omid=mid; mid=1;
  dofollows();
  mid=omid;
  }
 else
  {
  BW *bw=wmktw(maint,bfind(""));
  if(bw->o.mnew) exemac(bw->o.mnew);
  }
 maint->curwin=maint->topwin;
 if(help) helpon(maint);
 if(!nonotice)
  msgnw(lastw(maint)->object,"\\i** Joe's Own Editor v2.8 ** Copyright (C) 1995 Joseph H. Allen **\\i");
 edloop(0);
 vclose(vmem);
 nclose(n);
 if(exmsg) fprintf(stderr,"\n%s\n",exmsg);
 return 0;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
