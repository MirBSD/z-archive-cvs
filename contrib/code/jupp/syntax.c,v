head	1.25;
access;
symbols
	joe-3_1jupp38:1.25
	joe-3_1jupp37:1.24
	joe-3_1jupp36:1.24
	joe-3_1jupp35:1.24
	joe-3_1jupp34:1.24
	joe-3_1jupp33:1.24
	joe-3_1jupp32:1.21
	joe-3_1jupp31:1.17
	joe-3_1jupp30:1.16
	joe-3_1jupp29:1.13
	joe-3_1jupp28:1.11
	joe-3_1jupp27:1.11
	joe-3_1jupp26:1.10
	joe-3_1jupp25:1.9
	joe-3_1jupp24:1.9
	joe-3_1jupp23:1.9
	joe-3_1jupp22:1.8
	joe-3_1jupp21:1.8
	joe-3_1jupp20:1.7
	joe-3_1jupp19:1.7
	joe-3_1jupp18:1.6
	joe-3_1jupp17:1.6
	joe-3_1jupp16:1.6
	joe-3_1jupp15:1.6
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.25
date	2018.11.11.18.15.38;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005BE871D325833018;

1.24
date	2018.01.07.23.51.35;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A52B281212EC267;

1.23
date	2018.01.07.20.32.46;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A5284063C3E386D;

1.22
date	2018.01.06.00.28.32;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A50184621FA8455;

1.21
date	2017.12.08.02.00.41;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A29F2506E789D2B;

1.20
date	2017.12.02.04.36.56;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A222DF06C22B1AF;

1.19
date	2017.12.02.03.52.34;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A222399180EAD68;

1.18
date	2017.12.02.02.07.32;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A220AD65C90E687;

1.17
date	2017.07.08.16.15.12;	author tg;	state Exp;
branches;
next	1.16;
commitid	10059610517467C5D36;

1.16
date	2017.01.11.22.04.33;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005876ABFE790F0CC3;

1.15
date	2017.01.10.20.55.03;	author tg;	state Exp;
branches;
next	1.14;
commitid	10058754A38055D1712;

1.14
date	2017.01.10.19.27.36;	author tg;	state Exp;
branches;
next	1.13;
commitid	100587535BD5C0B4624;

1.13
date	2016.10.29.23.44.45;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005815347F236258ED;

1.12
date	2016.10.07.19.43.55;	author tg;	state Exp;
branches;
next	1.11;
commitid	10057F7FB0D4D3E4027;

1.11
date	2014.06.26.17.51.14;	author tg;	state Exp;
branches;
next	1.10;
commitid	10053AC5DA510B4E4DF;

1.10
date	2013.09.27.00.51.52;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005244D6B15896B869;

1.9
date	2012.12.22.00.06.14;	author tg;	state Exp;
branches;
next	1.8;
commitid	10050D4F965570AEE79;

1.8
date	2012.07.18.17.02.56;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005006EC5062D8A8CE;

1.7
date	2012.06.07.22.34.52;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004FD12CA36C733748;

1.6
date	2011.07.02.16.26.10;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E0F46B81B5D6507;

1.5
date	2011.07.02.16.17.07;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004E0F449746AE3E2F;

1.4
date	2010.04.08.17.54.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBE184A709C3F5C;

1.3
date	2008.05.13.13.08.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.25
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Syntax highlighting DFA interpreter
 *	Copyright
 *		(C) 2004 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */

#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/syntax.c,v 1.23 2018/01/07 20:32:46 tg Exp $");

#include <stdlib.h>
#include <string.h>
#include "b.h"
#include "scrn.h"
#include "utils.h"
#include "hash.h"
#include "path.h"
#include "charmap.h"
#include "syntax.h"

static struct {
	unsigned char buf[7];
	unsigned char start;
	unsigned char limit;
	unsigned eaten : 1;
	unsigned ebbed : 1;
	unsigned unget : 1;
	unsigned first : 1;
} utfstate;

static int
utfoctet(P *p)
{
	int c;

	utfstate.first = 0;
	if (utfstate.eaten) {
 ate:
		if (utfstate.start < utfstate.limit)
			return (utfstate.buf[utfstate.start++]);
		if (utfstate.ebbed)
			return (NO_MORE_DATA);
		utfstate.eaten = utfstate.limit = 0;
	}
	if (!utfstate.limit) {
		utfstate.first = 1;
		if (utfstate.unget) {
			c = utfstate.buf[utfstate.start];
			utfstate.unget = 0;
		} else
			c = pgetb(p);
		if ((c == NO_MORE_DATA) || (c < 0x80))
			return (c);
		if ((c < 0xC2) || (c >= 0xFE))
			return (0xFF);
		utfstate.start = 0;
		utfstate.buf[utfstate.start++] = (unsigned char)c;
		utfstate.limit = (c < 0xE0) ? 2 : (c < 0xF0) ? 3 :
		    (c < 0xF8) ? 4 : (c < 0xFC) ? 5 : 6;
	}
	while (utfstate.start < utfstate.limit) {
		if (((c = pgetb(p)) == NO_MORE_DATA) || ((c ^ 0x80) > 0x3F)) {
			/* invalid follow byte, invalidate all previous ones */
			utfstate.limit = 0;
			while (utfstate.limit < utfstate.start)
				utfstate.buf[utfstate.limit++] = 0xFF;
			/* append this as ungetch unless the well is dry */
			if (c == NO_MORE_DATA)
				utfstate.ebbed = 1;
			else {
				utfstate.buf[utfstate.limit] = (unsigned char)c;
				utfstate.unget = 1;
			}
			/* now return those bytes */
			break;
		}
		utfstate.buf[utfstate.start++] = (unsigned char)c;
	}
	utfstate.start = 0;
	utfstate.eaten = 1;
	goto ate;
}

static int
octetutf(P *p)
{
	int c;

	utfstate.first = 0;
	if (!(utfstate.start < utfstate.limit)) {
		if ((c = pgetb(p)) == NO_MORE_DATA)
			return (NO_MORE_DATA);

		utfstate.limit = utf8_encode(utfstate.buf,
		    to_uni(p->b->o.charmap, c));
		utfstate.start = 0;
		utfstate.first = 1;
	}
	return (utfstate.buf[utfstate.start++]);
}

/* Parse one line.  Returns new state.
   'syntax' is the loaded syntax definition for this buffer.
   'line' is advanced to start of next line.
   Global array 'attr_buf' end up with coloring for each character of line.
   'state' is initial parser state for the line (0 is initial state).
*/

int *attr_buf = 0;
int attr_size = 0;

int parse(struct high_syntax *syntax, P *line, int state)
{
	struct high_state *h = syntax->states[state];
			/* Current state */
	unsigned char buf[20];	/* Name buffer (trunc after 19 characters) */
	int buf_idx = 0;	/* Index into buffer */
	int buf_len = 0;	/* counts only starting characters */
	int buf_en = 0;		/* Set for name buffering */
	int *attr_end = attr_buf+attr_size;
	int *attr = attr_buf;
	int c;			/* Current character */
	int ofst = 0;	/* record length after we've stopped buffering */
	int (*getoctet)(P *) = line->b->o.charmap->type ? utfoctet : octetutf;

	memset(&utfstate, 0, sizeof(utfstate));
	buf[0] = 0;

	/* Get next character */
	while((c = getoctet(line)) != NO_MORE_DATA) {
		struct high_cmd *cmd, *kw_cmd;
		int x;

		/* Expand attribute array if necessary */
		if(attr==attr_end) {
			attr_buf = realloc(attr_buf,
			    sizeof(int) * (attr_size * 2));
			attr = attr_buf + attr_size;
			attr_size *= 2;
			attr_end = attr_buf + attr_size;
		}

		/* Advance to next attribute position (note attr[-1] below) */
		if (utfstate.first)
			attr++;

		/* Loop while noeat */
		do {
			/* Color with current state */
			attr[-1] = h->color;
			/* Get command for this character */
			cmd = h->cmd[c];
			/* Determine new state */
			if (cmd->keywords && (cmd->ignore ?
			    (kw_cmd = htfind(cmd->keywords, joe_strtolower(buf))) :
			    (kw_cmd = htfind(cmd->keywords, buf)))) {
				cmd = kw_cmd;
				h = cmd->new_state;
				/* Recolor keyword */
				for (x = -(buf_len + 1); x < -1; ++x)
					attr[x - ofst] = h->color;
			} else {
				h = cmd->new_state;
			}
			/* Recolor if necessary */
			x = cmd->recolor;
			while (&attr[x] < attr_buf)
				++x;
			while (x < 0)
				attr[x++] = h->color;

			/* Start buffering? */
			if (cmd->start_buffering) {
				buf_idx = 0;
				buf_len = 0;
				buf_en = 1;
				ofst = 0;
			}

			/* Stop buffering? */
			if (cmd->stop_buffering)
				buf_en = 0;
		} while(cmd->noeat);

		/* Save character in buffer */
		if (!buf_en)
			ofst += utfstate.first;
		else if (buf_idx < 19) {
			buf[buf_idx++] = c;
			buf[buf_idx] = 0;
			buf_len += utfstate.first;
		}

		if (c == '\n')
			break;
	}
	/* Return new state number */
	return h->no;
}

/* Subroutines for load_dfa() */

static struct high_state *find_state(struct high_syntax *syntax, const unsigned char *name)
{
	int x;
	struct high_state *state;

	/* Find state */
	for(x=0;x!=syntax->nstates;++x)
		if(!strcmp(syntax->states[x]->name,name))
			break;

	/* It doesn't exist, so create it */
	if(x==syntax->nstates) {
		int y;
		state = malloc(sizeof(struct high_state));
		state->name=(const unsigned char *)strdup((const char *)name);
		state->no=syntax->nstates;
		state->color=FG_WHITE;
		if(!syntax->nstates)
			/* We're the first state */
			syntax->default_cmd.new_state = state;
		if(syntax->nstates==syntax->szstates)
			syntax->states = realloc(syntax->states,
			   sizeof(struct high_state *) * (syntax->szstates *= 2));
		syntax->states[syntax->nstates++]=state;
		for(y=0; y!=256; ++y)
			state->cmd[y] = &syntax->default_cmd;
	} else
		state = syntax->states[x];
	return state;
}

/* Load syntax file */

struct high_syntax *syntax_list;

struct high_syntax *load_dfa(const unsigned char *name)
{
	unsigned char buf[1024];
	unsigned char bf[256];
	unsigned char bf1[256];
	int clist[256];
	unsigned char *p;
	int c;
	FILE *f = NULL;
	struct high_state *state=0;	/* Current state */
	struct high_syntax *syntax;	/* New syntax table */
	int line = 0;
	void *np;

	if (!name)
		return NULL;

	if (!attr_buf)
		attr_buf = ralloc((size_t)(attr_size = 1024), sizeof(int));

	/* Find syntax table */

	/* Already loaded? */
	for(syntax=syntax_list;syntax;syntax=syntax->next)
		if(!strcmp(syntax->name,name))
			return syntax;

	/* Load it */
	p = (unsigned char *)getenv("HOME");
	if (p) {
		joe_snprintf_2((char *)buf,sizeof(buf),"%s/.jupp/syntax/%s.jsf",p,name);
		f = fopen((char *)buf,"r");
	}

	if (!f && has_JOERC) {
		joe_snprintf_2((char *)buf,sizeof(buf),"%ssyntax/%s.jsf",get_JOERC,name);
		f = fopen((char *)buf,"r");
	}
	if(!f)
		return 0;

	/* Create new one */
	syntax = calloc(1, sizeof(struct high_syntax));
	syntax->name = (const unsigned char *)strdup((const char *)name);
	syntax->next = syntax_list;
	syntax_list = syntax;
	syntax->states = ralloc((size_t)(syntax->szstates = 64),
	    sizeof(struct high_state *));
	syntax->sync_lines = 120;

	memset(clist, 0, sizeof(clist));

	/* Parse file */
	while(fgets((char *)buf,1023,f)) {
		++line;
		p = buf;
		parse_ws(&p,'#');
		if(!parse_char(&p, ':')) {
			if(!parse_ident(&p, bf, 255)) {

				state = find_state(syntax,bf);

				parse_ws(&p,'#');
				if(!parse_ident(&p,bf,255)) {
					struct high_color *color;
					for(color=syntax->color;color;color=color->next)
						if(!strcmp(color->name,bf))
							break;
					if(color)
						state->color=color->color;
					else {
						state->color=0;
						fprintf(stderr,"%s:%d: Unknown class '%s'\n", name, line, bf);
					}
				} else
					fprintf(stderr,"%s:%d: Missing color for state definition\n", name, line);
			} else
				fprintf(stderr,"%s:%d: Missing state name\n", name, line);
		} else if(!parse_char(&p, '=')) {
			if(!parse_ident(&p, bf, 255)) {
				struct high_color *color;

				/* Find color */
				for(color=syntax->color;color;color=color->next)
					if(!strcmp(color->name,bf))
						break;
				/* If it doesn't exist, create it */
				if(!color) {
					color = calloc(1, sizeof(struct high_color));
					color->name = (unsigned char *)strdup((char *)bf);
					color->next = syntax->color;
					syntax->color = color;
				} else {
					fprintf(stderr,"%s:%d: Class '%s' already defined\n", name, line, bf);
				}

				/* Parse color definition */
				while(parse_ws(&p,'#'), !parse_ident(&p,bf,255)) {
					color->color |= meta_color(bf);
				}
			}
		} else if(!parse_char(&p, '-')) { /* No. sync lines */
			syntax->sync_lines = (int)ustolb(p, &np,
			    INT_MIN, INT_MAX, USTOL_TRIM);
			if (!np)
				syntax->sync_lines = -1;
			else
				p = np;
		} else {
			c = parse_ws(&p,'#');

			if (!c) {
			} else if (c=='"' || c=='*') {
				if (state) {
					if (!parse_field(&p, UC "*")) {
						int z;
						for(z=0;z!=256;++z)
							clist[z] = 1;
					} else {
						c = parse_string(&p, bf, 255);
						if(c)
							fprintf(stderr,"%s:%d: Bad string\n", name, line);
						else {
							int z;
							int first, second;
							unsigned char *t = bf;
							for(z=0;z!=256;++z)
								clist[z] = 0;
							while(!parse_range(&t, &first, &second)) {
								if(first>second)
									second = first;
								while(first<=second)
									clist[first++] = 1;
							}
						}
					}
					/* Create command */
					parse_ws(&p,'#');
					if(!parse_ident(&p,bf,255)) {
						struct high_cmd *cmd = calloc(1, sizeof(struct high_cmd));
						int z;

						cmd->new_state = find_state(syntax,bf);

						/* Parse options */
						while (parse_ws(&p,'#'), !parse_ident(&p,bf,255))
							if(!strcmp(bf,"buffer")) {
								cmd->start_buffering = 1;
							} else if(!strcmp(bf,"hold")) {
								cmd->stop_buffering = 1;
							} else if(!strcmp(bf,"recolor")) {
								parse_ws(&p,'#');
								if(!parse_char(&p,'=')) {
									parse_ws(&p,'#');
									cmd->recolor = (int)ustolb(p, &np,
									    INT_MIN, INT_MAX, USTOL_TRIM);
									if (!np)
										fprintf(stderr,"%s:%d: Missing value for option %s\n", name, line, bf);
									else
										p = np;
								} else
									fprintf(stderr,"%s:%d: Missing value for option %s\n", name, line, bf);
							} else if(!strcmp(bf,"strings") || !strcmp(bf,"istrings")) {
								if (bf[0]=='i')
									cmd->ignore = 1;
								while(fgets((char *)buf,1023,f)) {
									++line;
									p = buf;
									parse_ws(&p,'#');
									if (*p) {
										if (!parse_field(&p, UC "done"))
											break;
										if(!parse_string(&p,bf,255)) {
											parse_ws(&p,'#');
											if (cmd->ignore)
												joe_strtolower(bf);
											if(!parse_ident(&p,bf1,255)) {
												struct high_cmd *kw_cmd = calloc(1, sizeof(struct high_cmd));
												kw_cmd->noeat=1;
												kw_cmd->new_state = find_state(syntax,bf1);
												if(!cmd->keywords)
													cmd->keywords = htmk(64);
												htadd(cmd->keywords,(unsigned char *)strdup((char *)bf),kw_cmd);
												while (parse_ws(&p,'#'), !parse_ident(&p,bf,255))
													if(!strcmp(bf,"buffer")) {
														kw_cmd->start_buffering = 1;
													} else if(!strcmp(bf,"hold")) {
														kw_cmd->stop_buffering = 1;
													} else if(!strcmp(bf,"recolor")) {
														parse_ws(&p,'#');
														if(!parse_char(&p,'=')) {
															parse_ws(&p,'#');
															kw_cmd->recolor = (int)ustolb(p, &np,
															    INT_MIN, INT_MAX, USTOL_TRIM);
															if (!np)
																fprintf(stderr,"%s:%d: Missing value for option %s\n", name, line, bf);
															else
																p = np;
														} else
															fprintf(stderr,"%s:%d: Missing value for option %s\n", name, line, bf);
													} else
														fprintf(stderr,"%s:%d: Unknown option '%s'\n", name, line, bf);
											} else
												fprintf(stderr,"%s:%d: Missing state name\n", name, line);
										} else
											fprintf(stderr,"%s:%d: Missing string\n", name, line);
									}
								}
							} else if(!strcmp(bf,"noeat")) {
								cmd->noeat = 1;
							} else if(!strcmp(bf,"mark")) {
								/* not implemented yet */ ;
							} else if(!strcmp(bf,"markend")) {
								/* not implemented yet */ ;
							} else if(!strcmp(bf,"recolormark")) {
								/* not implemented yet */ ;
							} else
								fprintf(stderr,"%s:%d: Unknown option '%s'\n", name, line, bf);

						/* Install command */
						for(z=0;z!=256;++z)
							if(clist[z])
								state->cmd[z]=cmd;
					} else
						fprintf(stderr,"%s:%d: Missing jump\n", name, line);
				} else
					fprintf(stderr,"%s:%d: No state\n", name, line);
			} else
				fprintf(stderr,"%s:%d: Unknown character\n", name, line);
		}
	}

	fclose(f);

	return syntax;
}
@


1.24
log
@new ralloc(x,y) = malloc(x*y) with checks, but not, unlike calloc,
with implizit size_t casting nor memory cleansing
@
text
@a354 1
					struct high_cmd *cmd;
a377 1
					cmd = calloc(1, sizeof(struct high_cmd));
d380 1
d382 1
@


1.23
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/syntax.c,v 1.21 2017/12/08 02:00:41 tg Exp $");
d258 2
a259 4
	if(!attr_buf) {
		attr_size = 1024;
		attr_buf = calloc(attr_size, sizeof(int));
	}
d287 2
a288 1
	syntax->states = malloc(sizeof(struct high_state *) * (syntax->szstates = 64));
@


1.22
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@a13 1
#include <limits.h>
@


1.21
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/syntax.c,v 1.20 2017/12/02 04:36:56 tg Exp $");
d358 1
a358 1
					if(!parse_field(&p, US "*")) {
d413 1
a413 1
										if(!parse_field(&p,US "done"))
@


1.20
log
@more includes and warning cleanup madness

since GCC bombs on me let’s test the noFPU case first…
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/syntax.c,v 1.19 2017/12/02 03:52:34 tg Exp $");
d140 2
a141 1
			attr_buf = realloc(attr_buf,sizeof(int)*(attr_size*2));
d220 1
a220 1
		state=malloc(sizeof(struct high_state));
d228 2
a229 1
			syntax->states=realloc(syntax->states,sizeof(struct high_state *)*(syntax->szstates*=2));
d261 1
a261 1
		attr_buf = malloc(sizeof(int)*attr_size);
d290 1
a290 1
	syntax->states = malloc(sizeof(struct high_state *)*(syntax->szstates=64));
@


1.19
log
@banish parse_int()
@
text
@d10 1
d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/syntax.c,v 1.18 2017/12/02 02:07:32 tg Exp $");
d14 1
a17 1
#include "types.h"
d252 1
a252 1
	unsigned char *np;
@


1.18
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d251 1
d342 3
a344 1
			if(parse_int(&p, &syntax->sync_lines))
d346 2
d394 3
a396 1
									if(parse_int(&p,&cmd->recolor))
d398 2
d432 3
a434 1
															if(parse_int(&p,&kw_cmd->recolor))
d436 2
@


1.17
log
@6-byte UTF-8 plus trailing NUL makes 7 octets buffer
@
text
@a0 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.12 2016/10/07 19:43:55 tg Exp $ */
d10 3
@


1.16
log
@use ~/.jupp/ (for now) not ~/.joe/ to not conflict with joe 4.x
@
text
@d23 1
a23 1
	unsigned char buf[6];
@


1.15
log
@unbreak syntax highlighting in nōn-UTF8 locales
@
text
@d268 1
a268 1
		joe_snprintf_2((char *)buf,sizeof(buf),"%s/.joe/syntax/%s.jsf",p,name);
@


1.14
log
@few more malloc → calloc
@
text
@d90 1
d98 1
@


1.13
log
@first cut at win32 self-relocation
@
text
@a230 16
/* Create empty command */

static struct high_cmd *
mkcmd(void)
{
	struct high_cmd *cmd = malloc(sizeof(struct high_cmd));
	cmd->noeat = 0;
	cmd->recolor = 0;
	cmd->start_buffering = 0;
	cmd->stop_buffering = 0;
	cmd->new_state = 0;
	cmd->keywords = 0;
	cmd->ignore = 0;
	return cmd;
}

d278 1
a278 1
	syntax = malloc(sizeof(struct high_syntax));
a281 2
	syntax->nstates = 0;
	syntax->color = 0;
a283 5
	syntax->default_cmd.noeat = 0;
	syntax->default_cmd.recolor = 0;
	syntax->default_cmd.start_buffering = 0;
	syntax->default_cmd.new_state = 0;
	syntax->default_cmd.keywords = 0;
d323 1
a323 1
					color = malloc(sizeof(struct high_color));
a324 1
					color->color = 0;
d369 1
a369 1
					cmd = mkcmd();
d404 1
a404 1
												struct high_cmd *kw_cmd=mkcmd();
@


1.12
log
@UTF-8 syntax highlighting
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.10 2013/09/27 00:51:52 tg Exp $ */
d18 1
d286 2
a287 2
	if (!f) {
		joe_snprintf_2((char *)buf,sizeof(buf),"%ssyntax/%s.jsf",JOERC,name);
@


1.11
log
@refactor, sort, etc.
@
text
@d21 79
d110 1
a110 1
int parse(struct high_syntax *syntax,P *line,int state)
d115 3
a117 2
	int buf_idx=0;	/* Index into buffer */
	int c;		/* Current character */
d120 6
a125 2
	int buf_en = 0;	/* Set for name buffering */
	int ofst = 0;	/* record offset after we've stopped buffering */
d128 1
a128 1
	while((c=pgetb(line))!=NO_MORE_DATA) {
d141 2
a142 1
		attr++;
d157 2
a158 2
				for(x= -(buf_idx+1);x<-1;++x)
					attr[x-ofst] = h -> color;
d172 1
a182 2
		if (buf_idx<19 && buf_en)
			buf[buf_idx++]=c;
d184 6
a189 2
			++ofst;
		buf[buf_idx] = 0;
d191 1
a191 1
		if(c=='\n')
d200 1
a200 1
static struct high_state *find_state(struct high_syntax *syntax,unsigned char *name)
d214 1
a214 1
		state->name=(unsigned char *)strdup((char *)name);
d250 1
a250 1
struct high_syntax *load_dfa(unsigned char *name)
d294 1
a294 1
	syntax->name = (unsigned char *)strdup((char *)name);
@


1.10
log
@Natureshadows Nachtnervpatch
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.9 2012/12/22 00:06:14 tg Exp $ */
d66 3
a68 1
			if (cmd->keywords && (cmd->ignore ? (kw_cmd=htfind(cmd->keywords,lowerize(buf))) : (kw_cmd=htfind(cmd->keywords,buf)))) {
d337 1
a337 1
												lowerize(bf);
@


1.9
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.8 2012/07/18 17:02:56 tg Exp $ */
d44 1
a44 1
	while((c=pgetc(line))!=NO_MORE_DATA) {
a47 4
		/* Hack so we can have UTF-8 characters without crashing */
		if (c < 0 || c > 255)
			c = 0x1F;

@


1.8
log
@valgrind found a possible buffer underflow
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.7 2012/06/07 22:34:52 tg Exp $ */
d221 2
d227 1
a227 1
		c = parse_ws(&p,'#');
d332 1
a332 1
									c = parse_ws(&p,'#');
@


1.7
log
@use 120 sync lines by default; should fix natureshadow’s problem
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.6 2011/07/02 16:26:10 tg Exp $ */
d80 5
a84 2
			for(x=cmd->recolor;x<0;++x)
				attr[x] = h -> color;
@


1.6
log
@Ignore syntax keywords from joe-3.7 diff.jsf that are not yet implemented
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.5 2011/07/02 16:17:07 tg Exp $ */
d211 1
a211 1
	syntax->sync_lines = 50;
@


1.5
log
@Better error messages when parsing syntax and rc files
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.4 2010/04/08 17:54:19 tg Exp $ */
d365 6
@


1.4
log
@pass __CRAZY=Yes except -Wno-missing-field-initializers -Wno-cast-qual
 -Wno-strict-prototypes -Wno-missing-prototypes -Wno-missing-declarations
 -Wno-unused
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/syntax.c,v 1.3 2008/05/13 13:08:26 tg Exp $ */
d238 1
a238 1
						fprintf(stderr,"%s %d: Unknown class\n",name,line);
d241 1
a241 1
					fprintf(stderr,"%s %d: Missing color for state definition\n",name,line);
d243 1
a243 1
				fprintf(stderr,"%s %d: Missing state name\n",name,line);
d260 1
a260 1
					fprintf(stderr,"%s %d: Class already defined\n",name,line);
d285 1
a285 1
							fprintf(stderr,"%s %d: Bad string\n",name,line);
d318 1
a318 1
										fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d320 1
a320 1
									fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d352 1
a352 1
																fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d354 1
a354 1
															fprintf(stderr,"%s %d: Missing value for option\n",name,line);
d356 1
a356 1
														fprintf(stderr,"%s %d: Unknown option\n",name,line);
d358 1
a358 1
												fprintf(stderr,"%s %d: Missing state name\n",name,line);
d360 1
a360 1
											fprintf(stderr,"%s %d: Missing string\n",name,line);
d366 1
a366 1
								fprintf(stderr,"%s %d: Unknown option\n",name,line);
d373 1
a373 1
						fprintf(stderr,"%s %d: Missing jump\n",name,line);
d375 1
a375 1
					fprintf(stderr,"%s %d: No state\n",name,line);
d377 1
a377 1
				fprintf(stderr,"%s %d: Unknown character\n",name,line);
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d143 2
a144 1
static struct high_cmd *mkcmd()
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d12 1
d167 1
a167 1
	FILE *f;
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
