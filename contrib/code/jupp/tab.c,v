head	1.14;
access;
symbols
	joe-3_1jupp38:1.14
	joe-3_1jupp37:1.13
	joe-3_1jupp36:1.13
	joe-3_1jupp35:1.13
	joe-3_1jupp34:1.13
	joe-3_1jupp33:1.13
	joe-3_1jupp32:1.12
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.6
	joe-3_1jupp30:1.6
	joe-3_1jupp29:1.5
	joe-3_1jupp28:1.4
	joe-3_1jupp27:1.4
	joe-3_1jupp26:1.4
	joe-3_1jupp25:1.4
	joe-3_1jupp24:1.4
	joe-3_1jupp23:1.4
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.4
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.14
date	2018.11.11.18.15.38;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005BE871D325833018;

1.13
date	2017.12.20.23.49.06;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A3AF70215E0374F;

1.12
date	2017.12.08.02.00.41;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A29F2506E789D2B;

1.11
date	2017.12.07.02.10.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A28A3145E1FF911;

1.10
date	2017.12.06.23.02.05;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A2876FC4FFE7EF5;

1.9
date	2017.12.06.21.41.03;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A28640547F64250;

1.8
date	2017.12.06.21.17.00;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A285E5918D423C7;

1.7
date	2017.12.02.02.07.32;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A220AD65C90E687;

1.6
date	2017.01.10.19.16.28;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005875332028CA2A36;

1.5
date	2016.10.08.14.58.46;	author tg;	state Exp;
branches;
next	1.4;
commitid	10057F909BA47132811;

1.4
date	2010.04.08.15.31.03;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBDF6C54CC9A0DB;

1.3
date	2008.07.28.00.12.07;	author tg;	state Exp;
branches;
next	1.2;
commitid	100488D0E7907247606;

1.2
date	2008.05.13.13.08.26;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	File selection menu
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.13 2017/12/20 23:49:06 tg Exp $");

#include <sys/stat.h>
#include <stdlib.h>

#include "b.h"
#include "blocks.h"
#include "menu.h"
#include "path.h"
#include "tab.h"
#include "tty.h"
#include "utils.h"
#include "va.h"
#include "w.h"

typedef struct tab TAB;

extern int smode;		/* ??? */
extern int dobeep;
int menu_explorer = 0;		/* Stay in menu system when directory selected */

struct tab {
	int first_len;			/* Original size of path */
	int ofst;			/* Starting offset to path */
	unsigned char *path;		/* current directory */
	unsigned char *pattern;		/* search pattern */
	int len;		/* no. entries in files */
	unsigned char **files;		/* array of file names */
	unsigned char **list;
	unsigned char *type;		/* file type array */
	int prv;
	unsigned char *orgpath;
	unsigned char *orgnam;
};

#define F_DIR		1	/* type codes for file type array */
#define F_NORMAL	2
#define F_EXEC		4

/* Read matching files from a directory
 *  Directory is given in tab.path
 *  Pattern is given in tab.pattern
 *
 * Returns with -1 if there was an error
 * Otherwise returns index to file with inode given in prv
 * len and files are set with the file names
 * type is set with the file types
 */

static int get_entries(TAB *tab, int prv)
{
	int a;
	int which = 0;
	unsigned char *oldpwd = pwd();
	unsigned char **files;

	if (chpwd(tab->path))
		return -1;
	files = rexpnd(tab->pattern);
	if (!files) {
		chpwd(oldpwd);
		return -1;
	}
	tab->len = aLEN(files);
	varm(tab->files);
	tab->files = files;
	vasort(files, tab->len);
	if (tab->type)
		free(tab->type);
	tab->type = malloc(tab->len);
	for (a = 0; a != tab->len; a++) {
		struct stat buf;

		if (stat((char *)(files[a]), &buf)) {
			tab->type[a] = 0;
			continue;
		}
		if ((int)buf.st_ino == prv)
			which = a;
		if ((buf.st_mode & S_IFMT) == S_IFDIR)
			tab->type[a] = F_DIR;
		else if (buf.st_mode & (0100 | 0010 | 0001))
			tab->type[a] = F_EXEC;
		else
			tab->type[a] = F_NORMAL;
	}
	chpwd(oldpwd);
	return which;
}

static void insnam(BW *bw, unsigned char *path, unsigned char *nam, int dir, int ofst)
{
	P *p = pdup(bw->cursor);

	pgoto(p, ofst);
	p_goto_eol(bw->cursor);
	bdel(p, bw->cursor);
	if (sLEN(path)) {
		binsm(bw->cursor, sv(path));
		p_goto_eol(bw->cursor);
		if (path[sLEN(path) - 1] != '/') {
			binsm(bw->cursor, sc("/"));
			p_goto_eol(bw->cursor);
		}
	}
	binsm(bw->cursor, sv(nam));
	p_goto_eol(bw->cursor);
	if (dir) {
		binsm(bw->cursor, sc("/"));
		p_goto_eol(bw->cursor);
	}
	prm(p);
	bw->cursor->xcol = piscol(bw->cursor);
}

/* Given a menu structure with a tab structure as its object,
 * a pattern and path set in the tab structure:
 *
 * Load the menu with a list of file names and set the file name in
 * the prompt window to the directory the menu was read in from.
 * If flg is set, treload attempts to position to the previous directory
 * which was visited.
 *
 * Returns with -1 if there was an error
 * Returns with 0 for success
 */

static unsigned char **treload(TAB *tab,MENU *m, BW *bw, int flg,int *defer)
{
	int x;
	int which;
	struct stat buf;

	if ((which = get_entries(tab, tab->prv)) < 0)
		return 0;
	tab->prv = stat((tab->path && tab->path[0]) ? (char *)tab->path : ".",
	    &buf) ? 0 : buf.st_ino;
	if (!flg)
		which = 0;

	tab->list = vatrunc(tab->list, aLEN(tab->files));

	for (x = 0; tab->files[x]; ++x) {
		unsigned char *s = vsncpy(NULL, 0, sv(tab->files[x]));

		tab->list = vaset(tab->list, x, s);
		if (tab->type[x] == F_DIR)
			tab->list[x] = vsadd(tab->list[x], '/');
		else if (tab->type[x] == F_EXEC)
			tab->list[x] = vsadd(tab->list[x], '*');
	}
	if (defer) {
		*defer = which;
		insnam(bw, tab->path, tab->pattern, 0, tab->ofst);
		return tab->list;
	} else {
		ldmenu(m, tab->list, which);
		insnam(bw, tab->path, tab->pattern, 0, tab->ofst);
		return tab->list;
	}
}

static void rmtab(TAB *tab)
{
	vsrm(tab->orgpath);
	vsrm(tab->orgnam);
	varm(tab->list);
	vsrm(tab->path);
	vsrm(tab->pattern);
	varm(tab->files);
	if (tab->type)
		free(tab->type);
	free(tab);
}
/*****************************************************************************/
/****************** The user hit return **************************************/
/*****************************************************************************/
static int tabrtn(MENU *m, int cursor, TAB *tab)
{
	if (menu_explorer && tab->type[cursor] == F_DIR) {	/* Switch directories */
		unsigned char *orgpath = tab->path;
		unsigned char *orgpattern = tab->pattern;
		unsigned char *e = endprt(tab->path);

		/* if (!strcmp(tab->files[cursor], "..") && sLEN(e)
		    && !(e[0] == '.' && e[1] == '.' && (!e[2] || e[2] == '/')))
			tab->path = begprt(tab->path);
		else */ {
			tab->path = vsncpy(NULL, 0, sv(tab->path));
			tab->path = vsncpy(sv(tab->path), sv(m->list[cursor]));
		}
		vsrm(e);
		tab->pattern = vsncpy(NULL, 0, sc("*"));
		if (!treload(m->object, m, m->parent->win->object.bw, 0, NULL)) {
			msgnw(m->parent, UC "Couldn't read directory ");
			vsrm(tab->pattern);
			tab->pattern = orgpattern;
			vsrm(tab->path);
			tab->path = orgpath;
			return -1;
		} else {
			vsrm(orgpattern);
			vsrm(orgpath);
			return 0;
		}
	} else {		/* Select name */
		BW *bw = m->parent->win->object.bw;

		insnam(bw, tab->path, tab->files[cursor], (tab->type[cursor]==F_DIR), tab->ofst);
		rmtab(tab);
		m->object = NULL;
		m->abrt = NULL;
		wabort(m->parent);
		return 0;
	}
}

/* Like above, but treats directories as files (adds them to path instead of
 * traverse hierarchy) */

static int tabrtn1(MENU *m, int cursor, TAB *tab)
{
	/* New way: just add directory to path */
	BW *bw = m->parent->win->object.bw;

	insnam(bw, tab->path, tab->files[cursor], (tab->type[cursor]==F_DIR ? 1 : 0), tab->ofst);
	rmtab(tab);
	m->object = NULL;
	m->abrt = NULL;
	wabort(m->parent);
	return 0;
}


/*****************************************************************************/
/****************** The user hit backspace ***********************************/
/*****************************************************************************/
static int tabbacks(MENU *m, int cursor, TAB *tab)
{
	unsigned char *orgpath = tab->path;
	unsigned char *orgpattern = tab->pattern;
	unsigned char *e = endprt(tab->path);

	if (sLEN(e) && sLEN(tab->path)!=tab->first_len)
		tab->path = begprt(tab->path);
	else {
		wabort(m->parent);
		return 0;
	}
	vsrm(e);
	tab->pattern = vsncpy(NULL, 0, sc("*"));

	if (!treload(m->object, m, m->parent->win->object.bw, 1, NULL)) {
		msgnw(m->parent, UC "Couldn't read directory ");
		vsrm(tab->pattern);
		tab->pattern = orgpattern;
		vsrm(tab->path);
		tab->path = orgpath;
		return -1;
	} else {
		vsrm(orgpattern);
		vsrm(orgpath);
		return 0;
	}
}
/*****************************************************************************/
static int tababrt(BW *bw, int cursor, TAB *tab)
{
	insnam(bw, tab->orgpath, tab->orgnam, 0, tab->ofst);
	rmtab(tab);
	return -1;
}

static void p_goto_start_of_path(P *p)
{
	while (/* CONSTCOND */ 1)
		switch (prgetc(p)) {
		case '\n':
			pgetc(p);
			/* FALLTHROUGH */
		case NO_MORE_DATA:
			return;
		}
}

/*****************************************************************************/
/****************** Create a tab window **************************************/
/*****************************************************************************/
int cmplt(BW *bw)
{
	MENU *new;
	TAB *tab;
	P *p, *q;
	unsigned char *cline, *tmp;
	long a, b;
	int which;
	unsigned char **l;
	int ofst;

	tab = malloc(sizeof(TAB));
	tab->files = NULL;
	tab->type = NULL;
	tab->list = NULL;
	tab->prv = 0;
	tab->len = 0;

	q = pdup(bw->cursor);
	p_goto_eol(q);
	p = pdup(q);
	p_goto_start_of_path(p);
	ofst = p->byte;

	tmp = brvs(p, (int) (q->byte - p->byte));
	cline = parsens(tmp, &a, &b);
	vsrm(tmp);
	prm(p);
	prm(q);

	tab->ofst = ofst;
	tab->pattern = namprt(cline);
	tab->path = dirprt(cline);
	tab->first_len = sLEN(tab->path);
	tab->orgnam = vsncpy(NULL, 0, sv(tab->pattern));
	tab->orgpath = vsncpy(NULL, 0, sv(tab->path));
	tab->pattern = vsadd(tab->pattern, '*');
	vsrm(cline);

	l = treload(tab, 0, bw, 0, &which);

	if (l && (new = mkmenu(bw->parent, l, tabrtn, tababrt, tabbacks, which, tab, NULL))) {
		if (sLEN(tab->files) == 1)
			return tabrtn1(new, 0, tab);
		else if (smode || isreg(tab->orgnam))
			return 0;
		else {
			unsigned char *com = mcomplete(new);

			vsrm(tab->orgnam);
			tab->orgnam = com;
			wabort(new->parent);
			smode = 2;
			/* if(dobeep) */
				ttputc(7);
			return 0;
		}
	} else {
		/* if(dobeep) */
			ttputc(7);
		rmtab(tab);
		return -1;
	}
}
@


1.13
log
@this is not a leak but code that can’t happen: rexpnd() can’t return 0-len array
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.12 2017/12/08 02:00:41 tg Exp $");
a82 1
		mset(&buf, 0, sizeof(struct stat));
d84 4
a87 1
		stat((char *)(files[a]), &buf);
d146 2
a147 5
	if (tab->path && tab->path[0])
		stat((char *)tab->path, &buf);
	else
		stat(".", &buf);
	tab->prv = buf.st_ino;
@


1.12
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.11 2017/12/07 02:10:17 tg Exp $");
a73 4
	if (!aLEN(files)) {
		chpwd(oldpwd);
		return -1;
	}
@


1.11
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.10 2017/12/06 23:02:05 tg Exp $");
d83 2
a84 2
		joe_free(tab->type);
	tab->type = (unsigned char *) joe_malloc(tab->len);
d187 2
a188 2
		joe_free(tab->type);
	joe_free(tab);
d315 1
a315 1
	tab = (TAB *) joe_malloc(sizeof(TAB));
@


1.10
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.9 2017/12/06 21:41:03 tg Exp $");
d209 1
a209 1
		if (!treload(m->object, m, m->parent->win->object, 0, NULL)) {
d222 1
a222 1
		BW *bw = m->parent->win->object;
d239 1
a239 1
	BW *bw = m->parent->win->object;
d268 1
a268 1
	if (!treload(m->object, m, m->parent->win->object, 1, NULL)) {
@


1.9
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tab.c,v 1.7 2017/12/02 02:07:32 tg Exp $");
d20 1
@


1.8
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d209 1
a209 1
			msgnw(m->parent, US "Couldn't read directory ");
d268 1
a268 1
		msgnw(m->parent, US "Couldn't read directory ");
@


1.7
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a12 1
#ifdef HAVE_SYS_STAT_H
a13 2
#endif

@


1.6
log
@these now all need <stdlib.h>
@
text
@a0 1
/* $MirOS: contrib/code/jupp/tab.c,v 1.3 2008/07/28 00:12:07 tg Exp $ */
d11 2
a12 3
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.5
log
@fixup some tab completion madness
@
text
@d19 2
@


1.4
log
@Add --disable-getpwnam and clean up warnings
@
text
@d291 1
a291 1
P *p_goto_start_of_path(P *p)
d293 8
a300 9
	int c;
	do
		c = prgetc(p);
	while (c!=NO_MORE_DATA && c!=' ' && c!='\n');

	if (c!=NO_MORE_DATA)
		pgetc(p);

	return p;
@


1.3
log
@rename symbol to avoid clash:

/usr/bin/ld: warning multiple definitions of symbol _beep
cmd.o definition of _beep in section (__DATA,__data)
/private/var/tglaser/iSDK/lib/libncurses.dylib(single module) definition of _beep

found during native(!) compilation on iPhone 3G (Darwin 9.3.1
iPhoneOS 2.0 iPhone1,2 arm N82AP), with gcc from saurik iphone-gcc
and headers and libraries copied from the 2.0 SDK. (It works fine.)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tab.c,v 1.2 2008/05/13 13:08:26 tg Exp $ */
d92 1
a92 1
		if (buf.st_ino == prv)
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d31 1
a31 1
extern int beep;
d360 1
a360 1
			/* if(beep) */
d365 1
a365 1
		/* if(beep) */
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 8
/* File selection menu
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
d11 1
a11 10
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include <stdio.h>
d13 2
d16 5
a20 7
#include "config.h"
#include "scrn.h"
#include "kbd.h"
#include "vs.h"
#include "w.h"
#include "bw.h"
#include "zstr.h"
d22 2
d25 1
a25 4
#include "menu.h"
#include "tty.h"
#include "blocks.h"
#include "tab.h"
d29 17
a45 16
extern int smode;

struct tab
 {
 char *path;	/* Current directory */
 char *pattern;	/* Search pattern */
 int len;	/* No. entries in files */
 char **files;	/* Array of file names */
 char **list;
 char *type;	/* File type array */
 int prv;
 char *orgpath;
 char *orgnam;
 };

/* Type codes for file type array */
d47 1
a47 1
#define F_DIR		1
d61 67
a127 55
static int get_entries(tab,prv)
TAB *tab;
 {
 int a;
 int which=0;
 char *oldpwd=pwd();
 char **files;
 if(chpwd(tab->path)) return -1;
 files=(char **)rexpnd(tab->pattern);
 if(!files)
  {
  chpwd(oldpwd);
  return -1;
  }
 if(!aLEN(files))
  {
  chpwd(oldpwd);
  return -1;
  }
 tab->len=aLEN(files);
 varm(tab->files); tab->files=files;
 vasort(files,tab->len);
 if(tab->type) free(tab->type);
 tab->type=(char *)malloc(tab->len);
 for(a=0;a!=tab->len;a++)
  {
  struct stat buf;
  mset(&buf,0,sizeof(struct stat));
  stat(files[a],&buf);
  if(buf.st_ino==prv) which=a;
  if((buf.st_mode&S_IFMT)==S_IFDIR) tab->type[a]=F_DIR;
  else if(buf.st_mode&(0100|0010|0001)) tab->type[a]=F_EXEC;
  else tab->type[a]=F_NORMAL;
  }
 chpwd(oldpwd);
 return which;
 }

void insnam(bw,path,nam)
BW *bw;
char *path, *nam;
 {
 P *p=pdup(bw->cursor); pbol(p);
 peol(bw->cursor);
 bdel(p,bw->cursor);
 if(sLEN(path))
  {
  binsm(bw->cursor,sv(path)), peol(bw->cursor);
  if(path[sLEN(path)-1]!='/')
   binsm(bw->cursor,sc("/")), peol(bw->cursor);
  }
 binsm(bw->cursor,sv(nam)); peol(bw->cursor);
 prm(p);
 bw->cursor->xcol=piscol(bw->cursor);
 }
d141 229
a369 192
int treload(m,flg)
MENU *m;
 {
 TAB *tab=(TAB *)m->object;	/* The menu */
 W *w=m->parent;		/* Window menu is in */
 BW *bw=(BW *)w->win->object;	/* The prompt window */
 int x;
 int which;
 struct stat buf;

 if((which=get_entries(tab,tab->prv))<0) return -1;
 if(tab->path && tab->path[0]) stat(tab->path,&buf);
 else stat(".",&buf);
 tab->prv=buf.st_ino;
 if(!flg) which=0;

 tab->list=vatrunc(tab->list,aLEN(tab->files));

 for(x=0;tab->files[x];++x)
  {
  char *s=vsncpy(NULL,0,sv(tab->files[x]));
  tab->list=vaset(tab->list,x,s);
  if(tab->type[x]==F_DIR)
   tab->list[x]=vsadd(tab->list[x],'/');
  else if(tab->type[x]==F_EXEC)
   tab->list[x]=vsadd(tab->list[x],'*');
  }
 ldmenu(m,tab->list,which);
 insnam(bw,tab->path,tab->pattern);
 return 0;
 }
 
void rmtab(tab)
TAB *tab;
 {
 vsrm(tab->orgpath);
 vsrm(tab->orgnam);
 varm(tab->list);
 vsrm(tab->path);
 vsrm(tab->pattern);
 varm(tab->files);
 if(tab->type) free(tab->type);
 free(tab);
 }

/* The user hit return */

int tabrtn(m,cursor,tab)
MENU *m;
TAB *tab;
 {
 if(tab->type[cursor]==F_DIR)
  { /* Switch directories */
  char *orgpath=tab->path;
  char *orgpattern=tab->pattern;
  char *e=endprt(tab->path);
  if(!zcmp(tab->files[cursor],"..") && sLEN(e) &&
     !(e[0]=='.' && e[1]=='.' && (!e[2] || e[2]=='/')))
   tab->path=begprt(tab->path);
  else
   {
   tab->path=vsncpy(NULL,0,sv(tab->path));
   tab->path=vsncpy(sv(tab->path),sv(m->list[cursor]));
   }
  vsrm(e);
  tab->pattern=vsncpy(NULL,0,sc("*"));
  if(treload(m,0))
   {
   msgnw(m,"Couldn't read directory ");
   vsrm(tab->pattern); tab->pattern=orgpattern;
   vsrm(tab->path); tab->path=orgpath;
   return -1;
   }
  else
   {
   vsrm(orgpattern);
   vsrm(orgpath);
   return 0;
   }
  }
 else
  { /* Select name */
  BW *bw=m->parent->win->object;
  insnam(bw,tab->path,tab->files[cursor]);
  rmtab(tab);
  m->object=0; m->abrt=0;
  wabort(m->parent);
  return 0;
  }
 }

/* The user hit backspace */

int tabbacks(m,cursor,tab)
MENU *m;
TAB *tab;
 {
 char *orgpath=tab->path;
 char *orgpattern=tab->pattern;
 char *e=endprt(tab->path);
 if(sLEN(e)) tab->path=begprt(tab->path);
 else
  {
  wabort(m->parent);
  return 0;
  }
 vsrm(e);
 tab->pattern=vsncpy(NULL,0,sc("*"));

 if(treload(m,1))
  {
  msgnw(m,"Couldn't read directory ");
  vsrm(tab->pattern); tab->pattern=orgpattern;
  vsrm(tab->path); tab->path=orgpath;
  return -1;
  }
 else
  {
  vsrm(orgpattern);
  vsrm(orgpath);
  return 0;
  }
 }

int tababrt(bw,cursor,tab)
BW *bw;
TAB *tab;
 {
 insnam(bw,tab->orgpath,tab->orgnam);
 rmtab(tab);
 return -1;
 }

/* Create a tab window */

int cmplt(bw)
BW *bw;
 {
 MENU *new;
 TAB *tab;
 P *p, *q;
 char *cline, *tmp;
 long a,b;

 tab=(TAB *)malloc(sizeof(TAB));
 new=mkmenu(bw,NULL,tabrtn,tababrt,tabbacks,0,tab,NULL);
 if(!new)
  {
  free(tab);
  return -1;
  }

 tab->files=0;
 tab->type=0;
 tab->list=0;
 tab->prv=0;
 tab->len=0;

 p=pdup(bw->cursor); pbol(p);
 q=pdup(bw->cursor); peol(q);
 tmp=brvs(p,(int)(q->byte-p->byte));
 cline=parsens(tmp,&a,&b);
 vsrm(tmp);
 prm(p); prm(q);

 tab->pattern=namprt(cline);
 tab->path=dirprt(cline);
 tab->orgnam=vsncpy(NULL,0,sv(tab->pattern));
 tab->orgpath=vsncpy(NULL,0,sv(tab->path));
 tab->pattern=vsadd(tab->pattern,'*');
 vsrm(cline);

 if(treload(new,0))
  {
  wabort(new->parent);
  ttputc(7);
  return -1;
  }
 else
  if(sLEN(tab->files)==1) return tabrtn(new,0,tab);
  else if(smode || isreg(tab->orgnam)) return 0;
  else
   {
   char *com=mcomplete(new);
   vsrm(tab->orgnam);
   tab->orgnam=com;
   wabort(new->parent);
   smode=2;
   ttputc(7);
   return 0;
   }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
