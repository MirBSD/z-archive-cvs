head	1.11;
access;
symbols
	joe-3_1jupp38:1.11
	joe-3_1jupp37:1.11
	joe-3_1jupp36:1.11
	joe-3_1jupp35:1.11
	joe-3_1jupp34:1.11
	joe-3_1jupp33:1.11
	joe-3_1jupp32:1.10
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.3
	joe-3_1jupp30:1.3
	joe-3_1jupp29:1.3
	joe-3_1jupp28:1.3
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.11
date	2017.12.17.03.04.47;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A35DEE615898FB7;

1.10
date	2017.12.08.02.28.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A29F8C708B176AB;

1.9
date	2017.12.08.02.00.43;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A29F2506E789D2B;

1.8
date	2017.12.06.23.02.07;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A2876FC4FFE7EF5;

1.7
date	2017.12.06.21.41.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A28640547F64250;

1.6
date	2017.12.06.21.17.03;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A285E5918D423C7;

1.5
date	2017.12.02.18.50.03;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A22F5E2328F5222;

1.4
date	2017.12.02.02.07.36;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005A220AD65C90E687;

1.3
date	2010.04.08.15.31.05;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004BBDF6C54CC9A0DB;

1.2
date	2008.05.13.13.08.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@fix redefinition warning
@
text
@/*
 *	UNDO system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/undo.c,v 1.9 2017/12/08 02:00:43 tg Exp $");

#include <stdlib.h>

#include "b.h"
#include "blocks.h"
#include "queue.h"
#include "ublock.h"
#include "undo.h"
#include "utils.h"
#include "w.h"

#define SMALL_UNDOREC 1024

static UNDO undos = { {&undos, &undos}, NULL, 0, { {NULL, NULL}, NULL, 0, 0, 0, 0, 0, NULL, NULL }, NULL, NULL, NULL };
static UNDO frdos = { {&frdos, &frdos}, NULL, 0, { {NULL, NULL}, NULL, 0, 0, 0, 0, 0, NULL, NULL }, NULL, NULL, NULL };

int inundo = 0;
int inredo = 0;

extern int dostaupd;

UNDOREC yanked = { {&yanked, &yanked}, NULL, 0, 0, 0, 0, 0, NULL, NULL };
int nyanked = 0;
int inyank = 0;
int justkilled = 0;

UNDOREC frrecs = { {&frrecs, &frrecs}, NULL, 0, 0, 0, 0, 0, NULL, NULL };

static UNDOREC *alrec(void)
{
	UNDOREC *rec = (UNDOREC *) alitem(&frrecs, sizeof(UNDOREC));

	return rec;
}

static void frrec(UNDOREC *rec)
{
	if (rec->del) {
		if (rec->len < SMALL_UNDOREC)
			free(rec->small);
		else {
			B *b = rec->big;

			bonline(b);
			brm(b);
		}
	}
	enquef(UNDOREC, link, &frrecs, rec);
}

UNDO *undomk(B *b)
{
	UNDO *undo = (UNDO *) alitem(&frdos, sizeof(UNDO));

	undo->nrecs = 0;
	undo->ptr = NULL;
	undo->last = NULL;
	undo->first = NULL;
	undo->b = b;
	izque(UNDOREC, link, &undo->recs);
	enquef(UNDO, link, &undos, undo);
	return undo;
}

void undorm(UNDO *undo)
{
	frchn(&frrecs, &undo->recs);
	demote(UNDO, link, &frdos, undo);
}

static void doundo(BW *bw, UNDOREC *ptr)
{
	dostaupd = 1;

	if (ptr->del) {
		if (ptr->len < SMALL_UNDOREC)
			binsm(bw->cursor, ptr->small, (int) ptr->len);
		else {
			B *b = ptr->big;

			bonline(b);
			binsb(bw->cursor, bcpy(b->bof, b->eof));
			boffline(b);
		}
	} else {
		P *q = pdup(bw->cursor);

		pfwrd(q, ptr->len);
		bdel(bw->cursor, q);
		prm(q);
	}
	bw->b->changed = ptr->changed;
}

int uundo(BW *bw)
{
	UNDOREC *upto;
	UNDO *undo = bw->b->undo;

	if (!undo)
		return -1;
	if (!undo->nrecs)
		return -1;
	if (!undo->ptr) {
		pgoto(bw->cursor, undo->recs.link.prev->where);
		undo->ptr = &undo->recs;
		/* If this return is uncommented, then uundo will jump
		   to where the undo is about to occur before actually
		   undoing anything */
		/* return 0; */
	}
	if (undo->ptr->link.prev == &undo->recs)
		return -1;
	upto = undo->ptr->link.prev->unit;
 loop:
	undo->ptr = undo->ptr->link.prev;
	pgoto(bw->cursor, undo->ptr->where);
	inundo = 1;
	doundo(bw, undo->ptr);
	inundo = 0;
	if (upto && upto != undo->ptr)
		goto loop;
	return 0;
}

int uredo(BW *bw)
{
	UNDOREC *upto;
	UNDOREC *ptr;
	UNDO *undo = bw->b->undo;

	if (!undo)
		return -1;
	if (!undo->ptr)
		return -1;
	if (undo->ptr == &undo->recs)
		return -1;
	upto = undo->recs.link.prev->unit;
	do {
		ptr = undo->recs.link.prev;
		pgoto(bw->cursor, ptr->where);
		inredo = 1;
		doundo(bw, ptr);
		inredo = 0;
		frrec(deque_f(UNDOREC, link, ptr));
		undo->ptr = undo->ptr->link.next;
	} while (upto && upto != ptr);
	return 0;
}

void umclear(void)
{
	UNDO *undo;

	for (undo = undos.link.next; undo != &undos; undo = undo->link.next) {
		UNDOREC *rec;

		for (rec = undo->recs.link.next; rec != &undo->recs; rec = rec->link.next)
			rec->min = 0;
	}
}

/* Eliminate excess undo records */

static void undogc(UNDO *undo)
{
	UNDOREC *unit = undo->recs.link.next->unit;
	int flg = 0;

	if (undo->ptr && undo->ptr->link.prev == &undo->recs)
		flg = 1;
	if (unit)
		while (unit != undo->recs.link.next)
			frrec(deque_f(UNDOREC, link, undo->recs.link.next));
	frrec(deque_f(UNDOREC, link, undo->recs.link.next));
	--undo->nrecs;
	if (flg)
		undo->ptr = undo->recs.link.next;
}

void undomark(void)
{
	UNDO *undo;

	for (undo = undos.link.next; undo != &undos; undo = undo->link.next)
		if (undo->first) {
			undo->first->unit = undo->last;
			undo->last->unit = undo->first;
			undo->first = undo->last = 0;
			if (++undo->nrecs == UNDOKEEP)
				undogc(undo);
		}
}

/* Delete the alternate time-line after the user has resumed editing after
 * undoing some number of changes
 */

static void undoover(UNDO *undo)
{
	undo->ptr = NULL;
}

void undoins(UNDO *undo, P *p, long size)
{
	UNDOREC *rec;

	if (inredo)
		return;
	if (!inundo)
		if (undo->ptr && undo->ptr != &undo->recs)
			undoover(undo);
	rec = undo->recs.link.prev;
	if (rec != &undo->recs && rec->min && !rec->del && (p->byte == rec->where + rec->len || p->byte == rec->where))
		rec->len += size;
	else {
		rec = alrec();
		rec->del = 0;
		if (!undo->first)
			undo->first = rec;
		undo->last = rec;
		rec->where = p->byte;
		rec->min = 1;
		rec->unit = NULL;
		rec->len = size;
		rec->changed = undo->b->changed;
		enqueb(UNDOREC, link, &undo->recs, rec);
	}
}


int uyapp(BW *bw)
{
	UNDOREC *rec = yanked.link.prev;

	if (rec != &yanked)
		rec->where = bw->cursor->byte;
	return 0;
}

static void yankdel(long where, B *b)
{
	UNDOREC *rec;
	long size = b->eof->byte;

	/* Store in yank buffer */
	rec = yanked.link.prev;
	if (!inyank) {
		if (rec != &yanked && where == rec->where && justkilled) {
			if (rec->len + size >= SMALL_UNDOREC) {
				if (rec->len < SMALL_UNDOREC) {
					rec->big = bmk(NULL);
					binsm(rec->big->bof, rec->small, (int) rec->len);
					boffline(rec->big);
					free(rec->small);
				}
				bonline(rec->big);
				binsb(rec->big->eof, bcpy(b->bof, b->eof));
				boffline(rec->big);
			} else {
				rec->small = realloc(rec->small, rec->len + size);
				brmem(b->bof, rec->small + rec->len, (int) size);
			}
			rec->len += size;
		} else if (rec != &yanked && where + size == rec->where && justkilled) {
			if (rec->len + size >= SMALL_UNDOREC) {
				if (rec->len < SMALL_UNDOREC) {
					rec->big = bmk(NULL);
					binsm(rec->big->bof, rec->small, (int) rec->len);
					boffline(rec->big);
					free(rec->small);
				}
				bonline(rec->big);
				binsb(rec->big->bof, bcpy(b->bof, b->eof));
				boffline(rec->big);
			} else {
				rec->small = realloc(rec->small, rec->len + size);
				mmove(rec->small + size, rec->small, (int) rec->len);
				brmem(b->bof, rec->small, (int) size);
			}
			rec->len += size;
			rec->where = where;
		} else {
			if (++nyanked == 100) {
				frrec(deque_f(UNDOREC, link, yanked.link.next));
				--nyanked;
			}
			rec = alrec();
			if (size < SMALL_UNDOREC) {
				rec->small = malloc(size);
				brmem(b->bof, rec->small, (int)b->eof->byte);
			} else {
				rec->big = bcpy(b->bof, b->eof);
				boffline(rec->big);
			}
			rec->where = where;
			rec->len = size;
			rec->del = 1;
			enqueb(UNDOREC, link, &yanked, rec);
		}
	}
}

void undodel(UNDO *undo, long where, B *b)
{
	UNDOREC *rec;
	long size = b->eof->byte;

	if (inredo) {
		brm(b);
		return;
	}
	if (!inundo)
		if (undo->ptr && undo->ptr != &undo->recs)
			undoover(undo);

	yankdel(where, b);

	/* Store in undo buffer */
	rec = undo->recs.link.prev;
	if (rec != &undo->recs && rec->min && rec->del && where == rec->where) {
		if (rec->len + size >= SMALL_UNDOREC) {
			if (rec->len < SMALL_UNDOREC) {
				rec->big = bmk(NULL);
				binsm(rec->big->bof, rec->small, (int) rec->len);
				boffline(rec->big);
				free(rec->small);
			}
			bonline(rec->big);
			binsb(rec->big->eof, b);
			boffline(rec->big);
		} else {
			rec->small = realloc(rec->small, rec->len + size);
			brmem(b->bof, rec->small + rec->len, (int) size);
			brm(b);
		}
		rec->len += size;
	} else if (rec != &undo->recs && rec->min && rec->del && where + size == rec->where) {
		if (rec->len + size >= SMALL_UNDOREC) {
			if (rec->len < SMALL_UNDOREC) {
				rec->big = bmk(NULL);
				binsm(rec->big->bof, rec->small, (int) rec->len);
				boffline(rec->big);
				free(rec->small);
			}
			bonline(rec->big);
			binsb(rec->big->bof, b);
			boffline(rec->big);
		} else {
			rec->small = realloc(rec->small, rec->len + size);
			mmove(rec->small + size, rec->small, (int) rec->len);
			brmem(b->bof, rec->small, (int) size);
			brm(b);
		}
		rec->len += size;
		rec->where = where;
	} else {
		rec = alrec();
		if (size < SMALL_UNDOREC) {
			rec->small = malloc(size);
			brmem(b->bof, rec->small, (int) b->eof->byte);
			brm(b);
		} else {
			rec->big = b;
			boffline(b);
		}
		if (!undo->first)
			undo->first = rec;
		undo->last = rec;
		rec->where = where;
		rec->min = 1;
		rec->unit = NULL;
		rec->len = size;
		rec->del = 1;
		rec->changed = undo->b->changed;
		enqueb(UNDOREC, link, &undo->recs, rec);
	}
}

B *yankbuf = NULL;
long yankwhere = -1;

int uyank(BW *bw)
{
	UNDOREC *ptr = yanked.link.prev;

	if (ptr != &yanked) {
		if (ptr->len < SMALL_UNDOREC)
			binsm(bw->cursor, ptr->small, (int) ptr->len);
		else {
			B *b = ptr->big;

			bonline(b);
			binsb(bw->cursor, bcpy(b->bof, b->eof));
			boffline(b);
		}
		pfwrd(bw->cursor, ptr->len);
		yankbuf = bw->b;
		yankwhere = bw->cursor->byte;
		return 0;
	} else
		return -1;
}

int uyankpop(BW *bw)
{
	if (bw->b == yankbuf && bw->cursor->byte == yankwhere) {
		P *q;
		UNDOREC *ptr = yanked.link.prev;

		deque(UNDOREC, link, &yanked);
		enqueb(UNDOREC, link, ptr, &yanked);
		q = pdup(bw->cursor);
		pbkwd(q, ptr->len);
		inyank = 1;
		bdel(q, bw->cursor);
		inyank = 0;
		prm(q);
		return uyank(bw);
	} else
		return uyank(bw);
}

/* Clear changed-flag: make buffer look unmodified */

int unotmod(BW *bw)
{
	bw->b->changed = 0;
	msgnw(bw->parent, UC "Modified flag cleared");
	return 0;
}

int ucopy(BW *bw)
{
	if (markv(1) && !square) {
		B *b = bcpy(markb, markk);

		yankdel(markb->byte, b);
		brm(b);
		if (lightoff)
			unmark(bw);
		return 0;
	} else {
		msgnw(bw->parent, UC "No block");
		return -1;
	}
}
@


1.10
log
@label indent; small tweaks while here
@
text
@d23 1
a23 1
#define SMALL 1024
d50 1
a50 1
		if (rec->len < SMALL)
d87 1
a87 1
		if (ptr->len < SMALL)
d261 2
a262 2
			if (rec->len + size >= SMALL) {
				if (rec->len < SMALL) {
d277 2
a278 2
			if (rec->len + size >= SMALL) {
				if (rec->len < SMALL) {
d300 1
a300 1
			if (size < SMALL) {
d333 2
a334 2
		if (rec->len + size >= SMALL) {
			if (rec->len < SMALL) {
d350 2
a351 2
		if (rec->len + size >= SMALL) {
			if (rec->len < SMALL) {
d370 1
a370 1
		if (size < SMALL) {
d399 1
a399 1
		if (ptr->len < SMALL)
@


1.9
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/undo.c,v 1.8 2017/12/06 23:02:07 tg Exp $");
d126 1
a126 1
      loop:
@


1.8
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/undo.c,v 1.7 2017/12/06 21:41:04 tg Exp $");
d51 1
a51 1
			joe_free(rec->small);
d266 1
a266 1
					joe_free(rec->small);
d272 1
a272 1
				rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
d282 1
a282 1
					joe_free(rec->small);
d288 1
a288 1
				rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
d301 2
a302 2
				rec->small = (unsigned char *) joe_malloc(size);
				brmem(b->bof, rec->small, (int) b->eof->byte);
d338 1
a338 1
				joe_free(rec->small);
d344 1
a344 1
			rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
d355 1
a355 1
				joe_free(rec->small);
d361 1
a361 1
			rec->small = (unsigned char *) joe_realloc(rec->small, rec->len + size);
d371 1
a371 1
			rec->small = (unsigned char *) joe_malloc(size);
@


1.7
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/undo.c,v 1.5 2017/12/02 18:50:03 tg Exp $");
d19 1
@


1.6
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d439 1
a439 1
	msgnw(bw->parent, US "Modified flag cleared");
d454 1
a454 1
		msgnw(bw->parent, US "No block");
@


1.5
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/undo.c,v 1.4 2017/12/02 02:07:36 tg Exp $");
a12 1
#ifdef HAVE_STDLIB_H
a13 1
#endif
@


1.4
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d26 2
a27 2
static UNDO undos = { {&undos, &undos} };
static UNDO frdos = { {&frdos, &frdos} };
d34 1
a34 1
UNDOREC yanked = { {&yanked, &yanked} };
d39 1
a39 1
UNDOREC frrecs = { {&frrecs, &frrecs} };
@


1.3
log
@Add --disable-getpwnam and clean up warnings
@
text
@a0 1
/* $MirOS: contrib/code/jupp/undo.c,v 1.2 2008/05/13 13:08:28 tg Exp $ */
d11 2
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
a22 2
extern int lightoff;

@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 4
/* UNDO system
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)
d11 3
a13 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
a15 1
#include "bw.h"
d17 1
d19 2
a20 1
#include "undo.h"
d26 2
a27 7
static UNDO undos={{&undos,&undos}};
static UNDO frdos={{&frdos,&frdos}};

int inundo=0;
int inredo=0;

UNDOREC frrecs={{&frrecs,&frrecs}};
d29 2
a30 40
UNDOREC *alrec()
 {
 UNDOREC *rec=(UNDOREC *)alitem(&frrecs,sizeof(UNDOREC));
 return rec;
 }

void frrec(rec)
UNDOREC *rec;
 {
 if(rec->del)
  if(rec->len<SMALL) free(rec->small);
  else
   {
   B *b=rec->big;
   bonline(b);
   brm(b);
   }
 enquef(UNDOREC,link,&frrecs,rec);
 }

UNDO *undomk(b)
B *b;
 {
 UNDO *undo=(UNDO *)alitem(&frdos,sizeof(UNDO));
 undo->nrecs=0;
 undo->ptr=0;
 undo->last=0;
 undo->first=0;
 undo->b=b;
 izque(UNDOREC,link,&undo->recs);
 enquef(UNDO,link,&undos,undo);
 return undo;
 }

void undorm(undo)
UNDO *undo;
 {
 frchn(&frrecs,&undo->recs);
 demote(UNDO,link,&frdos,undo);
 }
d34 140
a173 87
void doundo(bw,ptr)
BW *bw;
UNDOREC *ptr;
 {
 dostaupd=1;
 if(ptr->del)
  {
  if(ptr->len<SMALL)
   binsm(bw->cursor,ptr->small,(int)ptr->len);
  else
   {
   B *b=ptr->big;
   bonline(b);
   binsb(bw->cursor,bcpy(b->bof,b->eof));
   boffline(b);
   }
  }
 else
  {
  P *q=pdup(bw->cursor);
  pfwrd(q,ptr->len);
  bdel(bw->cursor,q);
  prm(q);
  }
 bw->b->changed=ptr->changed;
 }

int uundo(bw)
BW *bw;
 {
 UNDOREC *upto;
 UNDO *undo=bw->b->undo;
 if(!undo) return -1;
 if(!undo->nrecs) return -1;
 if(!undo->ptr)
  {
  pgoto(bw->cursor,undo->recs.link.prev->where);
  undo->ptr= &undo->recs;
  /* If this return is uncommented, then uundo will jump to where the undo
  is about to occur before actually undoing anything
  return 0; */
  }
 if(undo->ptr->link.prev==&undo->recs) return -1;
 upto=undo->ptr->link.prev->unit;
 loop:
 undo->ptr=undo->ptr->link.prev;
 pgoto(bw->cursor,undo->ptr->where);
 inundo=1;
 doundo(bw,undo->ptr);
 inundo=0;
 if(upto && upto!=undo->ptr) goto loop;
 return 0;
 }

int uredo(bw)
BW *bw;
 {
 UNDOREC *upto;
 UNDOREC *ptr;
 UNDO *undo=bw->b->undo;
 if(!undo) return -1;
 if(!undo->ptr) return -1;
 if(undo->ptr==&undo->recs) return -1;
 upto=undo->recs.link.prev->unit;
 do
  {
  ptr=undo->recs.link.prev;
  pgoto(bw->cursor,ptr->where);
  inredo=1;
  doundo(bw,ptr);
  inredo=0;
  frrec(deque(UNDOREC,link,ptr));
  undo->ptr=undo->ptr->link.next;
  }
  while(upto && upto!=ptr);
 return 0;
 }

void umclear()
 {
 UNDO *undo;
 for(undo=undos.link.next;undo!=&undos;undo=undo->link.next)
  {
  UNDOREC *rec;
  for(rec=undo->recs.link.next;rec!=&undo->recs;rec=rec->link.next) rec->min=0;
  }
 }
d177 29
a205 26
static void undogc(undo)
UNDO *undo;
 {
 UNDOREC *unit=undo->recs.link.next->unit;
 int flg=0;
 if(undo->ptr && undo->ptr->link.prev==&undo->recs) flg=1;
 if(unit)
  while(unit!=undo->recs.link.next)
   frrec(deque(UNDOREC,link,undo->recs.link.next));
 frrec(deque(UNDOREC,link,undo->recs.link.next));
 --undo->nrecs;
 if(flg) undo->ptr=undo->recs.link.next;
 }

void undomark()
 {
 UNDO *undo;
 for(undo=undos.link.next;undo!=&undos;undo=undo->link.next)
  if(undo->first)
   {
   undo->first->unit=undo->last;
   undo->last->unit=undo->first;
   undo->first=undo->last=0;
   if(++undo->nrecs==UNDOKEEP) undogc(undo);
   }
 }
d211 224
a434 260
static void undoover(undo)
UNDO *undo;
 {
 undo->ptr=0;
 }

void undoins(undo,p,size)
UNDO *undo;
P *p;
long size;
 {
 UNDOREC *rec;
 if(inredo) return;
 if(!inundo) if(undo->ptr && undo->ptr!=&undo->recs) undoover(undo);
 rec=undo->recs.link.prev;
 if(rec!=&undo->recs && rec->min && !rec->del &&
    (p->byte==rec->where+rec->len || p->byte==rec->where)) rec->len+=size;
 else
  {
  rec=alrec();
  rec->del=0;
  if(!undo->first) undo->first=rec;
  undo->last=rec;
  rec->where=p->byte;
  rec->min=1;
  rec->unit=0;
  rec->len=size;
  rec->changed=undo->b->changed;
  enqueb(UNDOREC,link,&undo->recs,rec);
  }
 }

UNDOREC yanked={{&yanked,&yanked}};
int nyanked=0;
int inyank=0;
int justkilled=0;

int uyapp(bw)
BW *bw;
 {
 UNDOREC *rec=yanked.link.prev;
 if(rec!=&yanked) rec->where=bw->cursor->byte;
 return 0;
 }

void yankdel(where,b)
long where;
B *b;
 {
 UNDOREC *rec;
 long size=b->eof->byte;

 /* Store in yank buffer */
 rec=yanked.link.prev;
 if(!inyank)
 if(rec!=&yanked && where==rec->where && justkilled)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->eof,bcpy(b->bof,b->eof));
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   brmem(b->bof,rec->small+rec->len,(int)size);
   }
  rec->len+=size;
  }
 else if(rec!=&yanked && where+size==rec->where && justkilled)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->bof,bcpy(b->bof,b->eof));
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   mbkwd(rec->small+size,rec->small,(int)rec->len);
   brmem(b->bof,rec->small,(int)size);
   }
  rec->len+=size;
  rec->where=where;
  }
 else
  {
  if(++nyanked==100)
   frrec(deque(UNDOREC,link,yanked.link.next)), --nyanked;
  rec=alrec();
  if(size<SMALL)
   {
   rec->small=(char *)malloc(size);
   brmem(b->bof,rec->small,(int)b->eof->byte);
   }
  else
   {
   rec->big=bcpy(b->bof,b->eof);
   boffline(rec->big);
   }
  rec->where=where;
  rec->len=size;
  rec->del=1;
  enqueb(UNDOREC,link,&yanked,rec);
  }
 }

void undodel(undo,where,b)
UNDO *undo;
long where;
B *b;
 {
 UNDOREC *rec;
 long size=b->eof->byte;
 if(inredo)
  {
  brm(b);
  return;
  }
 if(!inundo) if(undo->ptr && undo->ptr!=&undo->recs) undoover(undo);

 yankdel(where,b);

 /* Store in undo buffer */
 rec=undo->recs.link.prev;
 if(rec!=&undo->recs && rec->min && rec->del && where==rec->where)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->eof,b);
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   brmem(b->bof,rec->small+rec->len,(int)size);
   brm(b);
   }
  rec->len+=size;
  }
 else if(rec!=&undo->recs && rec->min && rec->del && where+size==rec->where)
  {
  if(rec->len+size>=SMALL)
   {
   if(rec->len<SMALL)
    {
    rec->big=bmk(NULL);
    binsm(rec->big->bof,rec->small,(int)rec->len);
    boffline(rec->big);
    free(rec->small);
    }
   bonline(rec->big);
   binsb(rec->big->bof,b);
   boffline(rec->big);
   }
  else
   {
   rec->small=(char *)realloc(rec->small,rec->len+size);
   mbkwd(rec->small+size,rec->small,(int)rec->len);
   brmem(b->bof,rec->small,(int)size);
   brm(b);
   }
  rec->len+=size;
  rec->where=where;
  }
 else
  {
  rec=alrec();
  if(size<SMALL)
   {
   rec->small=(char *)malloc(size);
   brmem(b->bof,rec->small,(int)b->eof->byte);
   brm(b);
   }
  else
   {
   rec->big=b;
   boffline(b);
   }
  if(!undo->first) undo->first=rec;
  undo->last=rec;
  rec->where=where;
  rec->min=1;
  rec->unit=0;
  rec->len=size;
  rec->del=1;
  rec->changed=undo->b->changed;
  enqueb(UNDOREC,link,&undo->recs,rec);
  }
 }

B *yankbuf=0;
long yankwhere= -1;

int uyank(bw)
BW *bw;
 {
 UNDOREC *ptr=yanked.link.prev;
 if(ptr!=&yanked)
  {
  if(ptr->len<SMALL)
   binsm(bw->cursor,ptr->small,(int)ptr->len);
  else
   {
   B *b=ptr->big;
   bonline(b);
   binsb(bw->cursor,bcpy(b->bof,b->eof));
   boffline(b);
   }
  pfwrd(bw->cursor,ptr->len);
  yankbuf=bw->b;
  yankwhere=bw->cursor->byte;
  return 0;
  }
 else return -1;
 }

int uyankpop(bw)
BW *bw;
 {
 if(bw->b==yankbuf && bw->cursor->byte==yankwhere)
  {
  P *q;
  UNDOREC *ptr=yanked.link.prev;
  deque(UNDOREC,link,&yanked);
  enqueb(UNDOREC,link,ptr,&yanked);
  q=pdup(bw->cursor);
  pbkwd(q,ptr->len);
  inyank=1;
  bdel(q,bw->cursor);
  inyank=0;
  prm(q);
  return uyank(bw);
  }
 else return uyank(bw);
 }
d438 22
a459 25
int unotmod(bw)
BW *bw;
 {
 bw->b->changed=0;
 msgnw(bw,"Modified flag cleared");
 return 0;
 }

int ucopy(bw)
BW *bw;
 {
 if(markv(1) && !square)
  {
  B *b=bcpy(markb,markk);
  yankdel(markb->byte,b);
  brm(b);
  if(lightoff) unmark(bw);
  return 0;
  }
 else
  {
  msgnw(bw,"No block");
  return -1;
  }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
