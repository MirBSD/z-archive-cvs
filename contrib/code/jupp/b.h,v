head	1.10;
access;
symbols
	joe-3_1jupp38:1.10
	joe-3_1jupp37:1.10
	joe-3_1jupp36:1.10
	joe-3_1jupp35:1.10
	joe-3_1jupp34:1.10
	joe-3_1jupp33:1.10
	joe-3_1jupp32:1.9
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.4
	joe-3_1jupp30:1.4
	joe-3_1jupp29:1.4
	joe-3_1jupp28:1.4
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.10
date	2018.01.06.00.28.30;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A50184621FA8455;

1.9
date	2017.12.07.00.35.13;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A288CD6119BD663;

1.8
date	2017.12.06.23.17.32;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A287AA407E73F9C;

1.7
date	2017.12.06.21.16.54;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A285E5918D423C7;

1.6
date	2017.12.02.17.00.47;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A22DC570063953B;

1.5
date	2017.12.02.02.07.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A220AD65C90E687;

1.4
date	2014.10.23.16.10.28;	author tg;	state Exp;
branches;
next	1.3;
commitid	100544928830E6B4DD2;

1.3
date	2010.04.08.15.31.00;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004BBDF6C54CC9A0DB;

1.2
date	2008.05.13.13.08.20;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.07;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.20;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.07;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@/*
 *	Editor engine
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_B_H
#define _JOE_B_H 1

#ifdef EXTERN
__IDSTRING(rcsid_b_h, "$MirOS: contrib/code/jupp/b.h,v 1.9 2017/12/07 00:35:13 tg Exp $");
#endif

extern unsigned char stdbuf[stdsiz];

extern int force;		/* Set to have final '\n' added to file */
extern int tabwidth;		/* Default tab width */

extern VFILE *vmem;		/* Virtual memory file used for buffer system */

extern const unsigned char *msgs[];

B *bmk(B *prop);
void brm(B *b);

B *bfind(const unsigned char *s);
B *bfind_scratch(const unsigned char *s);
B *bcheck_loaded(const unsigned char *s);
B *bfind_reload(const unsigned char *s);

P *pdup(P *p);
P *pdupown(P *p, P **o);
P *poffline(P *p);
P *ponline(P *p);
B *bonline(B *b);
B *boffline(B *b);

void prm(P *p);
P *pset(P *n, P *p);

P *p_goto_bof(P *p);		/* move cursor to begging of file */
P *p_goto_eof(P *p);		/* move cursor to end of file */
P *p_goto_bol(P *p);		/* move cursor to begging of line */
P *p_goto_eol(P *p);		/* move cursor to end of line */

P *p_goto_indent(P *p,int c);	/* move cursor to indentation point */

int pisbof(P *p);
int piseof(P *p);
int piseol(P *p);
int pisbol(P *p);
int pisbow(P *p);
int piseow(P *p);

#define piscol(p) ((p)->valcol ? (p)->col : (pfcol(p), (p)->col))

int pisblank(P *p);
int piseolblank(P *p);

long pisindent(P *p);
int pispure(P *p,int c);

int pnext(P *p);
int pprev(P *p);

int pgetb(P *p);
int prgetb(P *p);

int pgetc(P *p);
int prgetc(P *p);

P *pgoto(P *p, long int loc);
P *pfwrd(P *p, long int n);
P *pbkwd(P *p, long int n);

P *pfcol(P *p);

P *pnextl(P *p);
P *pprevl(P *p);

P *pline(P *p, long int line);

P *pcolwse(P *p, long int goalcol);
P *pcol(P *p, long int goalcol);
P *pcoli(P *p, long int goalcol);
void pbackws(P *p);
void pfill(P *p, long int to, int usetabs);

P *pfind(P *p, unsigned char *s, int len);
P *pifind(P *p, unsigned char *s, int len);
P *prfind(P *p, unsigned char *s, int len);
P *prifind(P *p, unsigned char *s, int len);

/* copy text between 'from' and 'to' into new buffer */
B *bcpy(P *from, P *to);

void pcoalesce(P *p);

void bdel(P *from, P *to);

/* insert buffer 'b' into another at 'p' */
P *binsb(P *p, B *b);
/* insert a block 'blk' of size 'amnt' into buffer at 'p' */
P *binsm(P *p, const unsigned char *blk, int amnt);

/* insert character 'c' into buffer at 'p' */
P *binsc(P *p, int c);

/* insert byte 'c' into buffer at at 'p' */
P *binsbyte(P *p, unsigned char c);

/* insert zero term. string 's' into buffer at 'p' */
P *binss(P *p, unsigned char *s);

/* B *bload(char *s);
 * Load a file into a new buffer
 *
 * Returns with errno set to 0 for success,
 * -1 for new file (file doesn't exist)
 * -2 for read error
 * -3 for seek error
 * -4 for open error
 */
B *bload(const unsigned char *s);
B *bread(int fi, long int max);
B *borphan(void);

/* Save 'size' bytes beginning at 'p' into file with name in 's' */
int bsave(P *p, unsigned char *s, long int size,int flag);
int bsavefd(P *p, int fd, long int size);

unsigned char *parsens(const unsigned char *s, long int *skip, long int *amnt);

/* Get byte at pointer or return NO_MORE_DATA if pointer is at end of buffer */
int brc(P *p);

/* Get character at pointer or return NO_MORE_DATA if pointer is at end of buffer */
int brch(P *p);

/* Copy 'size' bytes from a buffer beginning at p into block 'blk' */
unsigned char *brmem(P *p, unsigned char *blk, int size);

/* Copy 'size' bytes from a buffer beginning at p into a zero-terminated
 * C-string in an malloc block.
 */
unsigned char *brs(P *p, int size);

/* Copy 'size' bytes from a buffer beginning at p into a variable length string. */
unsigned char *brvs(P *p, int size);

/* Copy line into buffer.  Maximum of size bytes will be copied.  Buffer needs
   to be one bigger for NIL */
unsigned char *brzs(P *p, unsigned char *buf, int size);

B *bnext(void);
B *bprev(void);

#define error berror
extern int berror;

unsigned char **getbufs(void);

#endif
@


1.9
log
@#ifdef SMALL, use 8K less .bss
@
text
@d12 1
a12 1
__IDSTRING(rcsid_b_h, "$MirOS: contrib/code/jupp/b.h,v 1.7 2017/12/06 21:16:54 tg Exp $");
d27 4
a30 4
B *bfind(unsigned char *s);
B *bfind_scratch(unsigned char *s);
B *bcheck_loaded(unsigned char *s);
B *bfind_reload(unsigned char *s);
d105 1
a105 1
P *binsm(P *p, unsigned char *blk, int amnt);
d125 1
a125 1
B *bload(unsigned char *s);
d133 1
a133 1
unsigned char *parsens(unsigned char *s, long int *skip, long int *amnt);
@


1.8
log
@whitespace at EOL annoys me
@
text
@a14 1
/* 31744 */
@


1.7
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__IDSTRING(rcsid_b_h, "$MirOS: contrib/code/jupp/b.h,v 1.6 2017/12/02 17:00:47 tg Exp $");
d97 1
a97 1
B *bcpy(P *from, P *to);	
d106 1
a106 1
P *binsm(P *p, unsigned char *blk, int amnt); 
@


1.6
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_b_h, "$MirOS: contrib/code/jupp/b.h,v 1.5 2017/12/02 02:07:23 tg Exp $");
d25 2
a26 2
B *bmk PARAMS((B *prop));
void brm PARAMS((B *b));
d28 28
a55 28
B *bfind PARAMS((unsigned char *s));
B *bfind_scratch PARAMS((unsigned char *s));
B *bcheck_loaded PARAMS((unsigned char *s));
B *bfind_reload PARAMS((unsigned char *s));

P *pdup PARAMS((P *p));
P *pdupown PARAMS((P *p, P **o));
P *poffline PARAMS((P *p));
P *ponline PARAMS((P *p));
B *bonline PARAMS((B *b));
B *boffline PARAMS((B *b));

void prm PARAMS((P *p));
P *pset PARAMS((P *n, P *p));

P *p_goto_bof PARAMS((P *p));		/* move cursor to begging of file */
P *p_goto_eof PARAMS((P *p));		/* move cursor to end of file */
P *p_goto_bol PARAMS((P *p));		/* move cursor to begging of line */
P *p_goto_eol PARAMS((P *p));		/* move cursor to end of line */

P *p_goto_indent PARAMS((P *p,int c));	/* move cursor to indentation point */

int pisbof PARAMS((P *p));
int piseof PARAMS((P *p));
int piseol PARAMS((P *p));
int pisbol PARAMS((P *p));
int pisbow PARAMS((P *p));
int piseow PARAMS((P *p));
d59 2
a60 2
int pisblank PARAMS((P *p));
int piseolblank PARAMS((P *p));
d62 2
a63 2
long pisindent PARAMS((P *p));
int pispure PARAMS((P *p,int c));
d65 2
a66 2
int pnext PARAMS((P *p));
int pprev PARAMS((P *p));
d68 2
a69 2
int pgetb PARAMS((P *p));
int prgetb PARAMS((P *p));
d71 2
a72 2
int pgetc PARAMS((P *p));
int prgetc PARAMS((P *p));
d74 3
a76 3
P *pgoto PARAMS((P *p, long int loc));
P *pfwrd PARAMS((P *p, long int n));
P *pbkwd PARAMS((P *p, long int n));
d78 1
a78 1
P *pfcol PARAMS((P *p));
d80 2
a81 2
P *pnextl PARAMS((P *p));
P *pprevl PARAMS((P *p));
d83 1
a83 1
P *pline PARAMS((P *p, long int line));
d85 5
a89 5
P *pcolwse PARAMS((P *p, long int goalcol));
P *pcol PARAMS((P *p, long int goalcol));
P *pcoli PARAMS((P *p, long int goalcol));
void pbackws PARAMS((P *p));
void pfill PARAMS((P *p, long int to, int usetabs));
d91 4
a94 4
P *pfind PARAMS((P *p, unsigned char *s, int len));
P *pifind PARAMS((P *p, unsigned char *s, int len));
P *prfind PARAMS((P *p, unsigned char *s, int len));
P *prifind PARAMS((P *p, unsigned char *s, int len));
d97 1
a97 1
B *bcpy PARAMS((P *from, P *to));	
d99 1
a99 1
void pcoalesce PARAMS((P *p));
d101 1
a101 1
void bdel PARAMS((P *from, P *to));
d104 1
a104 1
P *binsb PARAMS((P *p, B *b));
d106 1
a106 1
P *binsm PARAMS((P *p, unsigned char *blk, int amnt)); 
d109 1
a109 1
P *binsc PARAMS((P *p, int c));
d112 1
a112 1
P *binsbyte PARAMS((P *p, unsigned char c));
d115 1
a115 1
P *binss PARAMS((P *p, unsigned char *s));
d126 3
a128 3
B *bload PARAMS((unsigned char *s));
B *bread PARAMS((int fi, long int max));
B *borphan PARAMS((void));
d131 2
a132 2
int bsave PARAMS((P *p, unsigned char *s, long int size,int flag));
int bsavefd PARAMS((P *p, int fd, long int size));
d134 1
a134 1
unsigned char *parsens PARAMS((unsigned char *s, long int *skip, long int *amnt));
d137 1
a137 1
int brc PARAMS((P *p));
d140 1
a140 1
int brch PARAMS((P *p));
d143 1
a143 1
unsigned char *brmem PARAMS((P *p, unsigned char *blk, int size));
d148 1
a148 1
unsigned char *brs PARAMS((P *p, int size));
d151 1
a151 1
unsigned char *brvs PARAMS((P *p, int size));
d155 1
a155 1
unsigned char *brzs PARAMS((P *p, unsigned char *buf, int size));
d157 2
a158 2
B *bnext PARAMS((void));
B *bprev PARAMS((void));
d163 1
a163 1
unsigned char **getbufs PARAMS((void));
@


1.5
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.4
log
@omit the “New File” in new scratch buffers
@
text
@a0 1
/* $MirOS: contrib/code/jupp/b.h,v 1.3 2010/04/08 15:31:00 tg Exp $ */
d11 3
a13 2
#include "config.h"
#include "types.h"
@


1.3
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.h,v 1.2 2008/05/13 13:08:20 tg Exp $ */
d23 1
a23 1
extern unsigned char *msgs[];
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
a127 1
B *bfind PARAMS((unsigned char *s));
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
#ifndef _Ib
#define _Ib 1
d12 1
a12 3
#include "queue.h"
#include "rc.h"
#include "vfile.h"
a13 1
#define stdsiz 8192
d15 54
a68 1
extern char stdbuf[stdsiz];
d70 2
a71 124
typedef struct buffer B;
typedef struct point P;
typedef struct header H;

struct header
 {
 LINK(H) link;
 long seg;
 int hole;
 int ehole;
 int nlines;
 };

struct point
 {
 LINK(P) link;
 
 B *b;
 int ofst;
 char *ptr;
 H *hdr;
 
 long byte;
 long line;
 long col;
 long xcol;
 int valcol;
 int end;
 
 P **owner;
 };

struct buffer
 {
 LINK(B) link;
 P *bof;
 P *eof;
 char *name;
 int orphan;
 int count;
 int changed;
 int backup;
 void *undo;
 P *marks[10];			/* Bookmarks */
 OPTIONS o;			/* Options */
 P *oldcur;			/* Last cursor position before orphaning */
 P *oldtop;			/* Last top screen position before orphaning */
 int rdonly;			/* Set for read-only */
 int internal;			/* Set for internal buffers */
 int er;			/* Error code when file was loaded */
 };

extern int force;	/* Set to have final '\n' added to file */
extern int tabwidth;	/* Default tab width */

extern VFILE *vmem;	/* Virtual memory file used for buffer system */

extern char *msgs[];

B *bmk();
void brm();

B *bfind();

P *pdup();
P *pdupown();
P *poffline();
P *ponline();
B *bonline();
B *boffline();

void prm();
P *pset();

P *pbof();
P *peof();

int pisbof();
int piseof();
int piseol();
int pisbol();
int pisbow();
int piseow();

#define piscol(p) ((p)->valcol?(p)->col:(pfcol(p),(p)->col))

int pisblank();

long pisindent();

int pnext();
int pprev();

int pgetc();

P *pfwrd();

int prgetc();

P *pbkwd();
P *pgoto();

P *pfcol();

P *pbol();

P *peol();

P *pnextl();

P *pprevl();

P *pline();

P *pcolwse();
P *pcol();
P *pcoli();
void pbackws();
void pfill();

P *pfind();
P *pifind();
P *prfind();
P *prifind();
d73 24
a96 4
/* B *bcpy(P *from,P *to);
 * Copy text between from and to into a new buffer
 */
B *bcpy();
d98 1
a98 1
void pcoalesce();
d100 1
a100 1
void bdel();
d102 4
a105 4
/* P *binsb(P *p,B *b);
 * Insert an entire buffer 'b' into another buffer at 'p'
 */
P *binsb();
d107 2
a108 4
/* P *binsm(P *p,char *blk,int amnt);
 * Insert a block 'blk' of size 'amnt' into buffer at 'p'
 */
P *binsm();
d110 2
a111 4
/* P *binsc(P *p,char c);
 * Insert character into buffer at P
 */
P *binsc();
d113 2
a114 4
/* P *binss(P *p,char *s);
 * Insert zero terminated string into buffer at P
 */
P *binss();
d125 4
a128 4
B *bread();
B *bload();
B *bfind();
B *borphan();
d130 5
a134 5
/* int bsave(P *p,char *s,long size);
 * Save 'size' bytes beginning at 'p' into file with name in 's'
 */
int bsavefd();
int bsave();
d136 2
a137 1
char *parsens();
d139 2
a140 4
/* int brc(P *p);
 * Get character at pointer or return MAXINT if pointer is at end of buffer
 */
int brc();
d142 2
a143 4
/* char *brmem(P *p,char *blk,int size);
 * Copy 'size' bytes from a buffer beginning at p into block 'blk'
 */
char *brmem();
d145 1
a145 2
/* char *brs(P *p,int size);
 * Copy 'size' bytes from a buffer beginning at p into a zero-terminated
d148 1
a148 1
char *brs();
d150 6
a155 5
/* char *brvs(P *p,int size);
 * Copy 'size' bytes from a buffer beginning at p into a variable length
 * string.
 */
char *brvs();
d157 2
a158 2
B *bnext();
B *bprev();
d160 2
a161 1
extern int error;
d163 1
a163 1
char **getbufs();
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
