head	1.32;
access;
symbols
	joe-3_1jupp38:1.32
	joe-3_1jupp37:1.31
	joe-3_1jupp36:1.31
	joe-3_1jupp35:1.31
	joe-3_1jupp34:1.31
	joe-3_1jupp33:1.31
	joe-3_1jupp32:1.30
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.10
	joe-3_1jupp30:1.10
	joe-3_1jupp29:1.10
	joe-3_1jupp28:1.10
	joe-3_1jupp27:1.10
	joe-3_1jupp26:1.10
	joe-3_1jupp25:1.10
	joe-3_1jupp24:1.8
	joe-3_1jupp23:1.8
	joe-3_1jupp22:1.6
	joe-3_1jupp21:1.6
	joe-3_1jupp20:1.6
	joe-3_1jupp19:1.6
	joe-3_1jupp18:1.6
	joe-3_1jupp17:1.6
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.6
	joe-3_1jupp15:1.5
	joe-3_1jupp14:1.5
	joe-3_1jupp12:1.4
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.32
date	2018.11.11.18.15.39;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005BE871D325833018;

1.31
date	2018.01.07.20.32.47;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A5284063C3E386D;

1.30
date	2017.12.08.02.28.07;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A29F8C708B176AB;

1.29
date	2017.12.08.02.17.23;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A29F64A06DEB239;

1.28
date	2017.12.08.01.42.02;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A29EE00599384E3;

1.27
date	2017.12.08.01.29.59;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A29EB2C65E8B9EA;

1.26
date	2017.12.08.01.18.06;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A29E8612AAA086B;

1.25
date	2017.12.08.01.16.37;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A29E8063D55F339;

1.24
date	2017.12.06.23.58.37;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A2884424C3F3AD8;

1.23
date	2017.12.06.23.02.06;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A2876FC4FFE7EF5;

1.22
date	2017.12.06.21.41.03;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A28640547F64250;

1.21
date	2017.12.06.21.17.01;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A285E5918D423C7;

1.20
date	2017.12.04.22.15.39;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A25C91E16B3B365;

1.19
date	2017.12.02.18.50.03;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A22F5E2328F5222;

1.18
date	2017.12.02.04.32.41;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A222CF2122034D9;

1.17
date	2017.12.02.02.07.34;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A220AD65C90E687;

1.16
date	2017.12.02.00.16.44;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A21F0FB306AFC87;

1.15
date	2017.12.01.22.31.05;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A21D83E25479F2D;

1.14
date	2017.11.18.16.30.21;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A10602E3DB3F6B8;

1.13
date	2017.11.18.16.08.57;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A105B314AD016BA;

1.12
date	2017.11.18.16.02.05;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A1059874C70192A;

1.11
date	2017.11.18.15.48.38;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A10565B48DE7292;

1.10
date	2013.08.19.22.04.15;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005212965366A5886D;

1.9
date	2013.07.05.15.16.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	10051D6E34C01466237;

1.8
date	2012.12.30.18.43.40;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050E08B740266C96F;

1.7
date	2012.12.30.18.18.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050E085670C2F3A0B;

1.6
date	2011.07.16.21.57.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E2209506F4A1334;

1.5
date	2010.04.08.15.31.04;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004BBDF6C54CC9A0DB;

1.4
date	2009.10.18.14.52.58;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004ADB2BD317498872;

1.3
date	2008.05.13.13.08.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.32
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 * 	Highlighted block functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.31 2018/01/07 20:32:47 tg Exp $");

#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>

#include "b.h"
#include "pw.h"
#include "queue.h"
#include "scrn.h"
#include "tty.h"
#include "ublock.h"
#include "uedit.h"
#include "utils.h"
#include "vs.h"
#include "path.h"
#include "poshist.h"
#include "ushell.h"
#include "charmap.h"
#include "w.h"

/* Global options */

int square = 0;			/* Set for rectangle mode */
int lightoff = 0;		/* Set if highlighting should turn off

				   after block operations */
extern int marking;

/* Global variables */

P *markb = NULL;		/* Beginning and end of block */
P *markk = NULL;

/* Push markb & markk */

typedef struct marksav MARKSAV;
struct marksav {
	LINK(MARKSAV) link;
	P *markb, *markk;
} markstack = { { &markstack, &markstack}, NULL, NULL };
MARKSAV markfree = { {&markfree, &markfree}, NULL, NULL };
int nstack = 0;

int upsh(BW *bw)
{
	MARKSAV *m = alitem(&markfree, sizeof(MARKSAV));

	m->markb = 0;
	m->markk = 0;
	if (markk)
		pdupown(markk, &m->markk);
	if (markb)
		pdupown(markb, &m->markb);
	enqueb(MARKSAV, link, &markstack, m);
	++nstack;
	return 0;
}

int upop(BW *bw)
{
	MARKSAV *m = markstack.link.prev;

	if (m != &markstack) {
		--nstack;
		prm(markk);
		prm(markb);
		markk = m->markk;
		if (markk)
			markk->owner = &markk;
		markb = m->markb;
		if (markb)
			markb->owner = &markb;
		demote(MARKSAV, link, &markfree, m);
		if (lightoff)
			unmark(bw);
		updall();
		return 0;
	} else
		return -1;
}

/* Return true if markb/markk are valid */
/* If r is set, swap markb with markk if necessary */

int autoswap;

int markv(int r)
{
	if (markb && markk && markb->b == markk->b && markk->byte > markb->byte && (!square || markk->xcol > markb->xcol)) {
		return 1;
	} else if(autoswap && r && markb && markk && markb->b == markk->b && markb->byte > markk->byte && (!square || markk->xcol < markb->xcol)) {
		P *p = pdup(markb);
		prm(markb); markb=0; pdupown(markk, &markb);
		prm(markk); markk=0; pdupown(p, &markk);
		prm(p);
		return 1;
	} else
		return 0;
}

/* Rectangle-mode subroutines */

/* B *pextrect(P *org,long height,long left,long right);
 * Copy a rectangle into a new buffer
 *
 * org points to top-left corner of rectangle.
 * height is number of lines in rectangle.
 * right is rightmost column of rectangle + 1
 */

B *pextrect(P *org, long int height, long int right)
{
	P *p = pdup(org);	/* Left part of text to extract */
	P *q = pdup(p);		/* After right part of text to extract */
	B *tmp = bmk(NULL);	/* Buffer to extract to */
	P *z = pdup(tmp->eof);	/* Buffer pointer */

	while (height--) {
		pcol(p, org->xcol);
		pset(q, p);
		pcolwse(q, right);
		p_goto_eof(z);
		binsb(z, bcpy(p, q));
		p_goto_eof(z);
		binsc(z, '\n');
		pnextl(p);
	}
	prm(p);
	prm(q);
	prm(z);
	return tmp;
}

/* void pdelrect(P *org,long height,long right);
 * Delete a rectangle.
 */

void pdelrect(P *org, long int height, long int right)
{
	P *p = pdup(org);
	P *q = pdup(p);

	while (height--) {
		pcol(p, org->xcol);
		pset(q, p);
		pcol(q, right);
		bdel(p, q);
		pnextl(p);
	}
	prm(p);
	prm(q);
}

/* void pclrrect(P *org,long height,long right,int usetabs);
 * Blank-out a rectangle.
 */

void pclrrect(P *org, long int height, long int right, int usetabs)
{
	P *p = pdup(org);
	P *q = pdup(p);

	while (height--) {
		long pos;

		pcol(p, org->xcol);
		pset(q, p);
		pcoli(q, right);
		pos = q->col;
		bdel(p, q);
		pfill(p, pos, usetabs);
		pnextl(p);
	}
	prm(p);
	prm(q);
}

/* int ptabrect(P *org,long height,long right)
 * Check if there are any TABs in a rectangle
 */

int ptabrect(P *org, long int height, long int right)
{
	P *p = pdup(org);

	while (height--) {
		int c;

		pcol(p, org->xcol);
		while ((c = pgetc(p)) != NO_MORE_DATA && c != '\n') {
			if (c == '\t') {
				prm(p);
				return '\t';
			} else if (piscol(p) > right)
				break;
		}
		if (c != '\n')
			pnextl(p);
	}
	prm(p);
	return ' ';
}

/* Insert rectangle */

void pinsrect(P *cur, B *tmp, long int width, int usetabs)
{
	P *p = pdup(cur);	/* We insert at & move this pointer */
	P *q = pdup(tmp->bof);	/* These are for scanning through 'tmp' */
	P *r = pdup(q);

	if (width)
		while (pset(r, q), p_goto_eol(q), (q->line != tmp->eof->line || piscol(q))) {
			pcol(p, cur->xcol);
			if (piscol(p) < cur->xcol)
				pfill(p, cur->xcol, usetabs);
			binsb(p, bcpy(r, q));
			pfwrd(p, q->byte - r->byte);
			if (piscol(p) < cur->xcol + width)
				pfill(p, cur->xcol + width, usetabs);
			if (piseol(p))
				pbackws(p);
			if (!pnextl(p)) {
				binsc(p, '\n');
				pgetc(p);
			}
			if (pgetc(q) == NO_MORE_DATA)
				break;
		}
	prm(p);
	prm(q);
	prm(r);
}

/* Block functions */

/* Set beginning */

int umarkb(BW *bw)
{
	pdupown(bw->cursor, &markb);
	markb->xcol = bw->cursor->xcol;
	updall();
	return 0;
}

int udrop(BW *bw)
{
	prm(markk);
	if (marking && markb)
		prm(markb);
	else
		umarkb(bw);
	return 0;
}

int ubegin_marking(BW *bw)
{
	if (marking)
		/* We're marking now... don't stop */
		return 0;
	else if (markv(0) && bw->cursor->b==markb->b) {
		/* Try to extend current block */
		if (bw->cursor->byte==markb->byte) {
			pset(markb,markk);
			prm(markk); markk=0;
			marking = 1;
			return 0;
		} else if(bw->cursor->byte==markk->byte) {
			prm(markk); markk=0;
			marking = 1;
			return 0;
		}
	}
	/* Start marking - no message */
	prm(markb); markb=0;
	prm(markk); markk=0;
	updall();
	marking = 1;
	return umarkb(bw);
}

int utoggle_marking(BW *bw)
{
	if (markv(0) && bw->cursor->b==markb->b && bw->cursor->byte>=markb->byte && bw->cursor->byte<=markk->byte) {
		/* Just clear selection */
		prm(markb); markb=0;
		prm(markk); markk=0;
		updall();
		marking = 0;
		msgnw(bw->parent, UC "Selection cleared.");
		return 0;
	} else if (markk) {
		/* Clear selection and start new one */
		prm(markb); markb=0;
		prm(markk); markk=0;
		updall();
		marking = 1;
		msgnw(bw->parent, UC "Selection started.");
		return umarkb(bw);
	} else if (markb && markb->b==bw->cursor->b) {
		marking = 0;
		if (bw->cursor->byte<markb->byte) {
			pdupown(markb, &markk);
			prm(markb); markb=0;
			pdupown(bw->cursor, &markb);
			markb->xcol = bw->cursor->xcol;
		} else {
			pdupown(bw->cursor, &markk);
			markk->xcol = bw->cursor->xcol;
		}
		updall(); /* Because other windows could be changed */
		return 0;
	} else {
		marking = 1;
		msgnw(bw->parent, UC "Selection started.");
		return umarkb(bw);
	}
}

int uselect(BW *bw)
{
	if (!markb)
		umarkb(bw);
	return 0;
}

/* Set end */

int umarkk(BW *bw)
{
	pdupown(bw->cursor, &markk);
	markk->xcol = bw->cursor->xcol;
	updall();
	return 0;
}

/* Unset marks */

int unmark(BW *bw)
{
	prm(markb);
	prm(markk);
	updall();
	return 0;
}

/* Mark line */

int umarkl(BW *bw)
{
	p_goto_bol(bw->cursor);
	umarkb(bw);
	pnextl(bw->cursor);
	umarkk(bw);
	utomarkb(bw);
	pcol(bw->cursor, bw->cursor->xcol);
	return 0;
}

int utomarkb(BW *bw)
{
	if (markb && markb->b == bw->b) {
		pset(bw->cursor, markb);
		return 0;
	} else
		return -1;
}

int utomarkk(BW *bw)
{
	if (markk && markk->b == bw->b) {
		pset(bw->cursor, markk);
		return 0;
	} else
		return -1;
}

int uswap(BW *bw)
{
	if (markb && markb->b == bw->b) {
		P *q = pdup(markb);

		umarkb(bw);
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else
		return -1;
}

int utomarkbk(BW *bw)
{
	if (markb && markb->b == bw->b && bw->cursor->byte != markb->byte) {
		pset(bw->cursor, markb);
		return 0;
	} else if (markk && markk->b == bw->b && bw->cursor->byte != markk->byte) {
		pset(bw->cursor, markk);
		return 0;
	} else
		return -1;
}

/* Delete block */

int ublkdel(BW *bw)
{
	if (markv(1)) {
		if (square)
			if (bw->o.overtype) {
				long ocol = markk->xcol;

				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, ptabrect(markb, markk->line - markb->line + 1, markk->xcol));
				pcol(markk, ocol);
				markk->xcol = ocol;
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
		else
			bdel(markb, markk);
		if (lightoff)
			unmark(bw);
	} else {
		msgnw(bw->parent, UC "No block");
		return -1;
	}
	return 0;
}

/* Special delete block function for PICO */

int upicokill(BW *bw)
{
	upsh(bw);
	umarkk(bw);
	if (markv(1)) {
		if (square)
			if (bw->o.overtype) {
				long ocol = markk->xcol;

				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, ptabrect(markb, markk->line - markb->line + 1, markk->xcol));
				pcol(markk, ocol);
				markk->xcol = ocol;
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
		else
			bdel(markb, markk);
		if (lightoff)
			unmark(bw);
	} else
		udelln(bw);
	return 0;
}

/* Move highlighted block */

int ublkmove(BW *bw)
{
	if (markv(1)) {
		if (markb->b->rdonly) {
			msgnw(bw->parent, UC "Read only");
			return -1;
		}
		if (square) {
			long height = markk->line - markb->line + 1;
			long width = markk->xcol - markb->xcol;
			int usetabs = ptabrect(markb, height, markk->xcol);
			long ocol = piscol(bw->cursor);
			B *tmp = pextrect(markb, height, markk->xcol);
			int update_xcol = (bw->cursor->xcol >= markk->xcol && bw->cursor->line >= markb->line && bw->cursor->line <= markk->line);

			ublkdel(bw);
			/* now we can't use markb and markk until we set them again */
			/* ublkdel() frees them */
			if (bw->o.overtype) {
				/* If cursor was in block, blkdel moves it to left edge of block, so fix it
				 * back to its original place here */
				pcol(bw->cursor, ocol);
				pfill(bw->cursor, ocol, ' ');
				pdelrect(bw->cursor, height, piscol(bw->cursor) + width);
			} else if (update_xcol)
				/* If cursor was to right of block, xcol was not properly updated */
				bw->cursor->xcol -= width;
			pinsrect(bw->cursor, tmp, width, usetabs);
			brm(tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			return 0;
		} else if (bw->cursor->b != markk->b || bw->cursor->byte > markk->byte || bw->cursor->byte < markb->byte) {
			long size = markk->byte - markb->byte;

			binsb(bw->cursor, bcpy(markb, markk));
			bdel(markb, markk);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pfwrd(markk, size);
			}
			updall();
			return 0;
		}
	}
	msgnw(bw->parent, UC "No block");
	return -1;
}

/* Duplicate highlighted block */

int ublkcpy(BW *bw)
{
	if (markv(1)) {
		if (square) {
			long height = markk->line - markb->line + 1;
			long width = markk->xcol - markb->xcol;
			int usetabs = ptabrect(markb, height, markk->xcol);
			B *tmp = pextrect(markb, height, markk->xcol);

			if (bw->o.overtype)
				pdelrect(bw->cursor, height, piscol(bw->cursor) + width);
			pinsrect(bw->cursor, tmp, width, usetabs);
			brm(tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			return 0;
		} else {
			long size = markk->byte - markb->byte;
			B *tmp = bcpy(markb, markk);

			/* Simple overtype for hex mode */
			if (bw->o.hex && bw->o.overtype) {
				P *q = pdup(bw->cursor);
				if (q->byte + size >= q->b->eof->byte)
					pset(q, q->b->eof);
				else
					pfwrd(q, size);
				bdel(bw->cursor, q);
				prm(q);
			}

			binsb(bw->cursor, tmp);
			if (lightoff)
				unmark(bw);
			else {
				umarkb(bw);
				umarkk(bw);
				pfwrd(markk, size);
			}
			updall();
			return 0;
		}
	} else {
		msgnw(bw->parent, UC "No block");
		return -1;
	}
}

/* Write highlighted block to a file */
/* This is called by ublksave in ufile.c */

int dowrite(BW *bw, unsigned char *s, void *object, int *notify)
{
	int fl;
	int ret = 0;

	if (notify)
		*notify = 1;
	if (!markv(1)) {
		vsrm(s);
		msgnw(bw->parent, UC "No block");
		return (-1);
	}
	if (square) {
		B *tmp = pextrect(markb,
				  markk->line - markb->line + 1,
				  markk->xcol);

		fl = bsave(tmp->bof, s, tmp->eof->byte, 0);
		brm(tmp);
	} else {
		fl = bsave(markb, s, markk->byte - markb->byte, 0);
	}
	if (fl != 0) {
		msgnw(bw->parent, msgs[-fl]);
		ret = -1;
	}
	if (lightoff)
		unmark(bw);
	vsrm(s);
	return (ret);
}

/* Set highlighted block on a program block */

void setindent(BW *bw)
{
	P *p, *q;
	long indent;

	if (pisblank(bw->cursor))
		return;

	p = pdup(bw->cursor);
	q = pdup(p);
	indent = pisindent(p);

	do {
		if (!pprevl(p))
			goto done;
		else
			p_goto_bol(p);
	} while (pisindent(p) >= indent || pisblank(p));
	pnextl(p);
	/* Maybe skip blank lines at beginning */
 done:
	p_goto_bol(p);
	p->xcol = piscol(p);
	if (markb)
		prm(markb);
	markb = p;
	p->owner = &markb;

	do {
		if (!pnextl(q))
			break;
	} while (pisindent(q) >= indent || pisblank(q));
	/* Maybe skip blank lines at end */
	if (markk)
		prm(markk);
	q->xcol = piscol(q);
	markk = q;
	q->owner = &markk;

	updall();
}

/* Purity check */
/* Verifies that at least n indentation characters (for non-blank lines) match c */
/* If n is 0 (for urindent), this fails if c is space but indentation begins with tab */

static int
purity_check(int c, int n)
{
	P *p = pdup(markb);
	while (p->byte < markk->byte) {
		int x;
		p_goto_bol(p);
		if (!n && c==' ' && brc(p)=='\t') {
			prm(p);
			return 0;
		} else if (!piseol(p))
			for (x=0; x!=n; ++x)
				if (pgetc(p)!=c) {
					prm(p);
					return 0;
				}
		pnextl(p);
	}
	prm(p);
	return 1;
}

/* Left indent check */
/* Verify that there is enough whitespace to do the left indent */

static int
lindent_check(int c, int n)
{
	P *p = pdup(markb);
	int indwid;
	if (c=='\t')
		indwid = n * p->b->o.tab;
	else
		indwid = n;
	while (p->byte < markk->byte) {
		p_goto_bol(p);
		if (!piseol(p) && pisindent(p)<indwid) {
			prm(p);
			return 0;
		}
		pnextl(p);
	}
	prm(p);
	return 1;
}

/* Indent more */

int urindent(BW *bw)
{
	if (square) {
		if (markb && markk && markb->b == markk->b && markb->byte <= markk->byte && markb->xcol <= markk->xcol) {
			P *p = pdup(markb);

			do {
				pcol(p, markb->xcol);
				pfill(p, markb->xcol + bw->o.istep, bw->o.indentc);
			} while (pnextl(p) && p->line <= markk->line);
			prm(p);
		}
	} else {
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte) {
			setindent(bw);
		} else if ( 1 /* bw->o.purify */) {
			P *p = pdup(markb);
			P *q = pdup(markb);
			int indwid;

			if (bw->o.indentc=='\t')
				indwid = bw->o.tab * bw->o.istep;
			else
				indwid = bw->o.istep;

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p)) {
					int col;
					pset(q, p);
					p_goto_indent(q, bw->o.indentc);
					col = piscol(q);
					bdel(p,q);
					pfill(p,col+indwid,bw->o.indentc);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else if (purity_check(bw->o.indentc,0)) {
			P *p = pdup(markb);

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p))
					while (piscol(p) < bw->o.istep) {
						binsc(p, bw->o.indentc);
						pgetc(p);
					}
				pnextl(p);
			}
			prm(p);
		} else {
			/* Purity failure */
			msgnw(bw->parent,UC "Selected lines not properly indented");
			return 1;
		}
	}
	return 0;
}

/* Indent less */

int ulindent(BW *bw)
{
	if (square) {
		if (markb && markk && markb->b == markk->b && markb->byte <= markk->byte && markb->xcol <= markk->xcol) {
			P *p = pdup(markb);
			P *q = pdup(p);

			do {
				pcol(p, markb->xcol);
				while (piscol(p) < markb->xcol + bw->o.istep) {
					int c = pgetc(p);

					if (c != ' ' && c != '\t' && c != bw->o.indentc) {
						prm(p);
						prm(q);
						return -1;
					}
				}
			} while (pnextl(p) && p->line <= markk->line);
			pset(p, markb);
			do {
				pcol(p, markb->xcol);
				pset(q, p);
				pcol(q, markb->xcol + bw->o.istep);
				bdel(p, q);
			} while (pnextl(p) && p->line <= markk->line);
			prm(p);
			prm(q);
		}
	} else {
		if (!markb || !markk || markb->b != markk->b || bw->cursor->byte < markb->byte || bw->cursor->byte > markk->byte || markb->byte == markk->byte) {
			setindent(bw);
		} else if (1 /* bw->o.purify */ && lindent_check(bw->o.indentc,bw->o.istep)) {
			P *p = pdup(markb);
			P *q = pdup(markb);
			int indwid;

			if (bw->o.indentc=='\t')
				indwid = bw->o.tab * bw->o.istep;
			else
				indwid = bw->o.istep;

			while (p->byte < markk->byte) {
				p_goto_bol(p);
				if (!piseol(p)) {
					int col;
					pset(q, p);
					p_goto_indent(q, bw->o.indentc);
					col = piscol(q);
					bdel(p,q);
					pfill(p,col-indwid,bw->o.indentc);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else if (purity_check(bw->o.indentc,bw->o.istep)) {
			P *p = pdup(markb);
			P *q = pdup(p);

			p_goto_bol(p);
			while (p->byte < markk->byte) {
				if (!piseol(p)) {
					pset(q, p);
					while (piscol(q) < bw->o.istep)
						pgetc(q);
					bdel(p, q);
				}
				pnextl(p);
			}
			prm(p);
			prm(q);
		} else {
			/* Purity failure */
			msgnw(bw->parent, UC "Selected lines not properly indented");
			return 1;
		}
	}
	return 0;
}

/* Insert a file */

int doinsf(BW *bw, unsigned char *s, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (square) {
		if (markv(1)) {
			B *tmp;
			long width = markk->xcol - markb->xcol;
			long height;
			int usetabs = ptabrect(markb,
					       markk->line - markb->line + 1,
					       markk->xcol);

			tmp = bload(s);
			if (error) {
				msgnw(bw->parent, msgs[-error]);
				brm(tmp);
				vsrm(s);
				return -1;
			}
			if (piscol(tmp->eof))
				height = tmp->eof->line + 1;
			else
				height = tmp->eof->line;
			if (bw->o.overtype) {
				pclrrect(markb, long_max(markk->line - markb->line + 1, height), markk->xcol, usetabs);
				pdelrect(markb, height, width + markb->xcol);
			}
			pinsrect(markb, tmp, width, usetabs);
			pdupown(markb, &markk);
			markk->xcol = markb->xcol;
			if (height) {
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			brm(tmp);
			updall();
			vsrm(s);
			return 0;
		} else {
			vsrm(s);
			msgnw(bw->parent, UC "No block");
			return -1;
		}
	} else {
		int ret = 0;
		B *tmp = bload(s);

		if (error) {
			msgnw(bw->parent, msgs[-error]), brm(tmp);
			ret = -1;
		} else {
			P *pafter;

			pafter = pdup(bw->cursor);
			pgetc(pafter);
			binsb(bw->cursor, tmp);
			prgetc(pafter);
			aftermove(bw->parent, pafter);
		}
		vsrm(s);
		bw->cursor->xcol = piscol(bw->cursor);
		return ret;
	}
}


/* Filter highlighted block through a UNIX command */

static int filtflg = 0;

#if WANT_FORK
#define v_or_fork() fork()
#else
#define v_or_fork() vfork()
#endif

/*
 * This isn't optimal, but until the home-brewn VM system is removed
 * it is the best we can do: we cannot use bsavefd() in a concurrent
 * child because it uses JOE's VM subsystem which then copies around
 * content in file-backed memory that's not unshared, leading to da-
 * ta corruption if the content is big enough.
 *
 * TBH, I'd rather love to see that VM system gone and revert to the
 * JOE original code for dofilt... --mirabilos
 */
static int dofilt(BW *bw, unsigned char *s, void *object, int *notify)
{
	int fr[2];
	int fw;
	volatile int flg = 0;
	unsigned char *tf;
	const char *sh;
#if defined(HAVE_PUTENV) && (WANT_FORK || defined(HAVE_UNSETENV))
	unsigned char *fname;
#endif

	if (notify)
		*notify = 1;
	if (markb && markk && !square && markb->b == bw->b && markk->b == bw->b && markb->byte == markk->byte) {
		flg = 1;
		goto ok;
	} if (!markv(1)) {
		vsrm(s);
		msgnw(bw->parent, UC "No block");
		return -1;
	}
 ok:
	if (pipe(fr)) {
		vsrm(s);
		msgnw(bw->parent, UC "Pipe error");
		return (-1);
	}
	if ((tf = mktmp(NULL, &fw)) == NULL) {
		msgnw(bw->parent, UC "Cannot create temporary file");
 lseekoops:
		close(fr[0]);
		close(fr[1]);
		vsrm(s);
		return (-1);
	}
	unlink((char *)tf);
	vsrm(tf);
	npartial(bw->parent->t->t);
	ttclsn();
	if (square) {
		B *tmp = pextrect(markb,
				  markk->line - markb->line + 1,
				  markk->xcol);

		bsavefd(tmp->bof, fw, tmp->eof->byte);
	} else
		bsavefd(markb, fw, markk->byte - markb->byte);
	if (lseek(fw, (off_t)0, SEEK_SET) < 0) {
		msgnw(bw->parent, UC "lseek failed");
		close(fw);
		goto lseekoops;
	}
#if defined(HAVE_PUTENV) && (WANT_FORK || defined(HAVE_UNSETENV))
	fname = vsncpy(NULL, 0, sc("JOE_FILENAME="));
	tf = bw->b->name ? bw->b->name : (unsigned char *)"Unnamed";
	fname = vsncpy(sv(fname), sz(tf));
#if !WANT_FORK
	putenv((char *)fname);
#endif
#endif
	sh = getushell();
	if (!v_or_fork()) {
#if defined(HAVE_PUTENV) && WANT_FORK
		putenv((char *)fname);
#endif
		signrm(1);
		close(0);
		close(1);
		close(2);
		/* these dups will not fail */
		if (dup(fw)) {}
		if (dup(fr[1])) {}
		if (dup(fr[1])) {}
		close(fw);
		close(fr[1]);
		close(fr[0]);
		execl(sh, sh, "-c", s, NULL);
		_exit(0);
	}
	close(fr[1]);
	close(fw);
#if defined(HAVE_PUTENV) && (WANT_FORK || defined(HAVE_UNSETENV))
#if !WANT_FORK
	unsetenv("JOE_FILENAME");
#endif
	vsrm(fname);
#endif
	if (square) {
		B *tmp;
		long width = markk->xcol - markb->xcol;
		long height;
		int usetabs = ptabrect(markb,
				       markk->line - markb->line + 1,
				       markk->xcol);

		tmp = bread(fr[0], LONG_MAX);
		if (piscol(tmp->eof))
			height = tmp->eof->line + 1;
		else
			height = tmp->eof->line;
		if (bw->o.overtype) {
			pclrrect(markb, markk->line - markb->line + 1, markk->xcol, usetabs);
			pdelrect(markb, long_max(height, markk->line - markb->line + 1), width + markb->xcol);
		} else
			pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
		pinsrect(markb, tmp, width, usetabs);
		pdupown(markb, &markk);
		markk->xcol = markb->xcol;
		if (height) {
			pline(markk, markk->line + height - 1);
			pcol(markk, markb->xcol + width);
			markk->xcol = markb->xcol + width;
		}
		if (lightoff)
			unmark(bw);
		brm(tmp);
		updall();
	} else {
		P *p = pdup(markk);
		if (!flg)
			prgetc(p);
		bdel(markb, p);
		binsb(p, bread(fr[0], LONG_MAX));
		if (!flg) {
			pset(p,markk);
			prgetc(p);
			bdel(p,markk);
		}
		prm(p);
		if (lightoff)
			unmark(bw);
	}
	close(fr[0]);
	wait(NULL);
	vsrm(s);
	ttopnn();
	if (filtflg)
		unmark(bw);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

static B *filthist = NULL;

static void markall(BW *bw)
{
	pdupown(bw->cursor->b->bof, &markb);
	markb->xcol = 0;
	pdupown(bw->cursor->b->eof, &markk);
	markk->xcol = piscol(markk);
	updall();
}

static int checkmark(BW *bw)
{
	if (!markv(1))
		if (square)
			return 2;
		else {
			markall(bw);
			filtflg = 1;
			return 1;
	} else {
		filtflg = 0;
		return 0;
	}
}

int ufilt(BW *bw)
{
	switch (checkmark(bw)) {
	case 0:
		if (wmkpw(bw->parent, UC "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
			return 0;
		else
			return -1;
	case 1:
		if (wmkpw(bw->parent, UC "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
			return 0;
		else
			return -1;
	case 2:
	default:
		msgnw(bw->parent, UC "No block");
		return -1;
	}
}

/* Force region to lower case */

int ulower(BW *bw)
{
	if (markv(1)) {
		P *q;
		P *p;
		int c;
		B *b = bcpy(markb,markk);
		/* Leave one character in buffer to keep pointers set properly... */
		q = pdup(markk);
		prgetc(q);
		bdel(markb,q);
		b->o.charmap = markb->b->o.charmap;
		p=pdup(b->bof);
		while ((c=pgetc(p))!=NO_MORE_DATA) {
			c = joe_tolower(b->o.charmap,c);
			binsc(q,c);
			pgetc(q);
		}
		prm(p);
		bdel(q,markk);
		prm(q);
		brm(b);
		bw->cursor->xcol = piscol(bw->cursor);
		return 0;
	} else
		return -1;
}

/* Force region to upper case */

int uupper(BW *bw)
{
	if (markv(1)) {
		P *q;
		P *p;
		int c;
		B *b = bcpy(markb,markk);
		q = pdup(markk);
		prgetc(q);
		bdel(markb,q);
		b->o.charmap = markb->b->o.charmap;
		p=pdup(b->bof);
		while ((c=pgetc(p))!=NO_MORE_DATA) {
			c = joe_toupper(b->o.charmap,c);
			binsc(q,c);
			pgetc(q);
		}
		prm(p);
		bdel(q,markk);
		prm(q);
		brm(b);
		bw->cursor->xcol = piscol(bw->cursor);
		return 0;
	} else
		return -1;
}
@


1.31
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.29 2017/12/08 02:17:23 tg Exp $");
d976 2
a980 1
		msgnw(bw->parent, UC "Cannot create temporary file");
d995 5
a999 1
	lseek(fw, (off_t)0, SEEK_SET);
@


1.30
log
@label indent; small tweaks while here
@
text
@a13 1
#include <limits.h>
@


1.29
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.28 2017/12/08 01:42:02 tg Exp $");
d641 1
a641 1
      done:
@


1.28
log
@refactor to save lots of .text
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.22 2017/12/06 21:41:03 tg Exp $");
d1138 2
a1139 2
	        P *p;
	        int c;
d1168 2
a1169 2
	        P *p;
	        int c;
@


1.27
log
@more memory leak plugs
@
text
@d589 3
d594 9
a602 20
	if (markv(1)) {
		if (square) {
			int fl;
			int ret = 0;
			B *tmp = pextrect(markb,
					  markk->line - markb->line + 1,
					  markk->xcol);

			if ((fl = bsave(tmp->bof, s, tmp->eof->byte, 0)) != 0) {
				msgnw(bw->parent, msgs[-fl]);
				ret = -1;
			}
			brm(tmp);
			if (lightoff)
				unmark(bw);
			vsrm(s);
			return ret;
		} else {
			int fl;
			int ret = 0;
d604 2
a605 9
			if ((fl = bsave(markb, s, markk->byte - markb->byte, 0)) != 0) {
				msgnw(bw->parent, msgs[-fl]);
				ret = -1;
			}
			if (lightoff)
				unmark(bw);
			vsrm(s);
			return ret;
		}
d607 5
a611 3
		vsrm(s);
		msgnw(bw->parent, UC "No block");
		return -1;
d613 4
@


1.26
log
@fixup a WTF wrt. if scoping and indenting
@
text
@d887 1
d908 1
d911 1
@


1.25
log
@fix a couple of prompt window result string memory leaks
@
text
@d874 1
a874 1
	if (square)
d911 1
@


1.24
log
@make wmkpw const again
@
text
@d971 1
d975 1
a975 2
      ok:

d977 1
d984 1
@


1.23
log
@lots of fixes related to prototyping
@
text
@d1119 1
a1119 1
		if (wmkpw(bw->parent, US "Command to filter block through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
d1124 1
a1124 1
		if (wmkpw(bw->parent, US "Command to filter file through (^C to abort): ", &filthist, dofilt, NULL, NULL, utypebw, NULL, NULL, locale_map))
@


1.22
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.20 2017/12/04 22:15:39 tg Exp $");
d676 2
a677 1
int purity_check(int c, int n)
d701 2
a702 1
int lindent_check(int c, int n)
@


1.21
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d303 1
a303 1
		msgnw(bw->parent, US "Selection cleared.");
d311 1
a311 1
		msgnw(bw->parent, US "Selection started.");
d328 1
a328 1
		msgnw(bw->parent, US "Selection started.");
d435 1
a435 1
		msgnw(bw->parent, US "No block");
d472 1
a472 1
			msgnw(bw->parent, US "Read only");
d523 1
a523 1
	msgnw(bw->parent, US "No block");
d579 1
a579 1
		msgnw(bw->parent, US "No block");
d623 1
a623 1
		msgnw(bw->parent, US "No block");
d776 1
a776 1
			msgnw(bw->parent,US "Selected lines not properly indented");
d859 1
a859 1
			msgnw(bw->parent,US "Selected lines not properly indented");
d907 1
a907 1
			msgnw(bw->parent, US "No block");
d969 1
a969 1
		msgnw(bw->parent, US "No block");
d975 1
a975 1
		msgnw(bw->parent, US "Pipe error");
d981 1
a981 1
		msgnw(bw->parent, US "Cannot create temporary file");
d1128 1
a1128 1
		msgnw(bw->parent, US "No block");
@


1.20
log
@clean up some unused/MS-DOS® stuff
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ublock.c,v 1.17 2017/12/02 02:07:34 tg Exp $");
a12 5
#include <unistd.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_SYS_WAIT_H
a13 1
#endif
d15 2
@


1.19
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@a1118 4
#ifdef __MSDOS__
	msgnw(bw->parent, "Sorry, no sub-processes in DOS (yet)");
	return -1;
#else
a1134 1
#endif
@


1.18
log
@some fallout of the includes changes, some more reduction
@
text
@d56 2
a57 2
} markstack = { { &markstack, &markstack} };
MARKSAV markfree = { {&markfree, &markfree} };
@


1.17
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a33 1
#include "utf8.h"
@


1.16
log
@what a mess, indeed!

use LONG_MAX instead of homegrown MAXINT/MAXLONG
@
text
@a0 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.14 2017/11/18 16:30:21 tg Exp $ */
d11 2
a16 3
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.15
log
@merge fixes developed on Debian
@
text
@d22 1
d1047 1
a1047 1
		tmp = bread(fr[0], MAXLONG);
d1074 1
a1074 1
		binsb(p, bread(fr[0], MAXLONG));
@


1.14
log
@implement ^K/ with vfork if we don’t want to fork(2)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.13 2017/11/18 16:08:57 tg Exp $ */
d962 1
a962 1
	int flg = 0;
@


1.13
log
@oops, more like this
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.9 2013/07/05 15:16:05 tg Exp $ */
d942 6
d965 1
a965 1
#ifdef HAVE_PUTENV
d1003 1
a1003 1
#ifdef HAVE_PUTENV
d1007 3
d1012 2
a1013 2
	if (!fork()) {
#ifdef HAVE_PUTENV
d1032 4
a1035 1
#ifdef HAVE_PUTENV
@


1.12
log
@prepare making ublock.c vfork-safe:
avoid overwriting a global variable in the child
@
text
@a1000 1
	putenv((char *)fname);
d1004 3
@


1.11
log
@move shell and JOE_FILENAME determination out of child process
also, don’t limit JOE_FILENAME to 512 octets any more
@
text
@d1005 1
a1005 1
		signrm();
@


1.10
log
@fix source of data corruption (LP#1198221): JOE’s VM system uses
file-backed storage that is not properly unshared when trying to
do concurrent I/O with the piped subprocesses
@
text
@d958 4
a996 2
	if (!fork()) {
		const char *sh;
d998 4
a1001 2
		unsigned char		*fname, *name;
		unsigned	len;
d1003 2
a1015 9
#ifdef HAVE_PUTENV
		fname = vsncpy(NULL, 0, sc("JOE_FILENAME="));
		name = bw->b->name ? bw->b->name : (unsigned char *)"Unnamed";
		if((len = slen(name)) >= 512)	/* limit filename length */
			len = 512;
		fname = vsncpy(sv(fname), name, len);
		putenv((char *)fname);
#endif
		sh = getushell();
d1021 3
@


1.9
log
@the putenv() argument MUST NOT be free()d, it becomes part of the environment
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.8 2012/12/30 18:43:40 tg Exp $ */
d32 1
d942 10
d955 1
a955 1
	int fw[2];
d957 1
a970 1
 piperr:
d974 1
a974 1
	if (pipe(fw)) {
d977 2
a978 1
		goto piperr;
d980 2
d984 9
d1004 1
a1004 1
		if (dup(fw[0])) {}
d1007 1
a1007 1
		close(fw[0]);
a1008 1
		close(fw[1]);
d1023 26
a1048 47
	close(fw[0]);
	if (fork()) {
		close(fw[1]);
		if (square) {
			B *tmp;
			long width = markk->xcol - markb->xcol;
			long height;
			int usetabs = ptabrect(markb,
					       markk->line - markb->line + 1,
					       markk->xcol);

			tmp = bread(fr[0], MAXLONG);
			if (piscol(tmp->eof))
				height = tmp->eof->line + 1;
			else
				height = tmp->eof->line;
			if (bw->o.overtype) {
				pclrrect(markb, markk->line - markb->line + 1, markk->xcol, usetabs);
				pdelrect(markb, long_max(height, markk->line - markb->line + 1), width + markb->xcol);
			} else
				pdelrect(markb, markk->line - markb->line + 1, markk->xcol);
			pinsrect(markb, tmp, width, usetabs);
			pdupown(markb, &markk);
			markk->xcol = markb->xcol;
			if (height) {
				pline(markk, markk->line + height - 1);
				pcol(markk, markb->xcol + width);
				markk->xcol = markb->xcol + width;
			}
			if (lightoff)
				unmark(bw);
			brm(tmp);
			updall();
		} else {
			P *p = pdup(markk);
			if (!flg)
				prgetc(p);
			bdel(markb, p);
			binsb(p, bread(fr[0], MAXLONG));
			if (!flg) {
				pset(p,markk);
				prgetc(p);
				bdel(p,markk);
			}
			prm(p);
			if (lightoff)
				unmark(bw);
d1050 4
a1053 3
		close(fr[0]);
		wait(NULL);
		wait(NULL);
d1055 13
a1067 10
		if (square) {
			B *tmp = pextrect(markb,
					  markk->line - markb->line + 1,
					  markk->xcol);

			bsavefd(tmp->bof, fw[1], tmp->eof->byte);
		} else
			bsavefd(markb, fw[1], markk->byte - markb->byte);
		close(fw[1]);
		_exit(0);
d1069 2
@


1.8
log
@after ^KR now can jump to end of insertion with ^QP
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.6 2011/07/16 21:57:58 tg Exp $ */
a994 1
		vsrm(fname);
@


1.7
log
@use SHELL and EXECSHELL in favour of /bin/sh (with stat and access checks)
@
text
@d32 1
d921 5
a925 1
		} else
d927 3
@


1.6
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.5 2010/04/08 15:31:04 tg Exp $ */
d32 1
d963 1
d989 2
a990 1
		execl("/bin/sh", "/bin/sh", "-c", s, NULL);
@


1.5
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.4 2009/10/18 14:52:58 tg Exp $ */
d949 10
a958 2
	pipe(fr);
	pipe(fw);
d970 4
a973 3
		dup(fw[0]);
		dup(fr[1]);
		dup(fr[1]);
@


1.4
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ublock.c,v 1.3 2008/05/13 13:08:27 tg Exp $ */
a420 2
extern int udelln(BW *bw);

@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d559 1
d561 12
a572 1
			binsb(bw->cursor, bcpy(markb, markk));
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d276 1
a276 1
	else if (markv(0) && bw->cursor->b==markb->b)
d288 1
a700 1
		int x;
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Highlighted block functions
   Copyright (C) 1992 Joseph H. Allen
d11 10
a20 1
This file is part of JOE (Joe's Own Editor)
a21 14
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include "config.h"
d23 2
a24 1
#include "bw.h"
d26 2
a27 3
#include "w.h"
#include "pw.h"
#include "qw.h"
d29 1
a29 1
#include "zstr.h"
d31 3
a33 1
#include "ublock.h"
d37 4
a40 3
int square=0;				/* Set for rectangle mode */
int lightoff=0;				/* Set if highlighting should turn off
					   after block operations */
d45 2
a46 2
P *markb=0;				/* Beginning and end of block */
P *markk=0;
d51 44
a94 38
struct marksav
 {
 LINK(MARKSAV) link;
 P *markb, *markk;
 } markstack={{&markstack,&markstack}};
MARKSAV markfree={{&markfree,&markfree}};
int nstack=0;

int upsh(bw) 
BW *bw;
 {
 MARKSAV *m=alitem(&markfree,sizeof(MARKSAV));
 m->markb=0; m->markk=0;
 if(markk) pdupown(markk,&m->markk);
 if(markb) pdupown(markb,&m->markb);
 enqueb(MARKSAV,link,&markstack,m);
 ++nstack;
 return 0;
 }

int upop(bw)
BW *bw;
 {
 MARKSAV *m=markstack.link.prev;
 if(m!=&markstack)
  {
  --nstack;
  prm(markk);
  prm(markb);
  markk=m->markk; if(markk) markk->owner= &markk;
  markb=m->markb; if(markb) markb->owner= &markb;
  demote(MARKSAV,link,&markfree,m);
  if(lightoff) unmark(bw);
  updall();
  return 0;
  }
 else return -1;
 }
d97 3
d101 13
a113 16
int markv(r)
 {
 if(markb && markk && markb->b==markk->b && markk->byte>markb->byte &&
    (!square || markk->xcol>markb->xcol)) return 1;
 else if(r && markb && markk && markb->b==markk->b &&
         markk->byte<markb->byte && (!square || markk->xcol<markb->xcol))
  {
  P *t=markb;
  markb=markk;
  markk=t;
  markb->owner= &markb;
  markk->owner= &markk;
  return 1;
  }
 else return 0;
 }
d125 22
a146 20
B *pextrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);	/* Left part of text to extract */
 P *q=pdup(p);		/* After right part of text to extract */
 B *tmp=bmk(NULL);	/* Buffer to extract to */
 P *z=pdup(tmp->eof);	/* Buffer pointer */
 while(height--)
  {
  pcol(p,org->xcol);
  pset(q,p);
  pcolwse(q,right); 
  peof(z); binsb(z,bcpy(p,q));
  peof(z); binsc(z,'\n');
  pnextl(p);
  }
 prm(p); prm(q); prm(z);
 return tmp;
 }
d152 15
a166 16
void pdelrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);
 P *q=pdup(p);
 while(height--)
  {
  pcol(p,org->xcol);
  pset(q,p);
  pcol(q,right);
  bdel(p,q);
  pnextl(p);
  }
 prm(p); prm(q);
 }
d172 19
a190 19
void pclrrect(org,height,right,usetabs)
P *org;
long height,right;
 {
 P *p=pdup(org);
 P *q=pdup(p);
 while(height--)
  {
  long pos;
  pcol(p,org->xcol);
  pset(q,p);
  pcoli(q,right);
  pos=q->col;
  bdel(p,q);
  pfill(p,pos,usetabs);
  pnextl(p);
  }
 prm(p); prm(q);
 }
d193 1
a193 1
 * Check if there are any TABs in a rectange
d196 21
a216 19
int ptabrect(org,height,right)
P *org;
long height,right;
 {
 P *p=pdup(org);
 while(height--)
  {
  int c;
  pcol(p,org->xcol);
  while(c=pgetc(p), c!=MAXINT && c!='\n')
   if(c=='\t')
    {
    prm(p); return 1;
    }
   else if(piscol(p)>right) break;
  if(c!='\n') pnextl(p);
  }
 prm(p); return 0;
 }
d220 28
a247 21
void pinsrect(cur,tmp,width,usetabs)
P *cur;
B *tmp;
long width;
 {
 P *p=pdup(cur);		/* We insert at & move this pointer */
 P *q=pdup(tmp->bof);		/* These are for scanning through 'tmp' */
 P *r=pdup(q);
 if(width)
  while(pset(r,q), peol(q), (q->line!=tmp->eof->line || piscol(q)))
   {
   pcol(p,cur->xcol);
   if(piscol(p)<cur->xcol) pfill(p,cur->xcol,usetabs);
   binsb(p,bcpy(r,q)); pfwrd(p,q->byte-r->byte);
   if(piscol(p)<cur->xcol+width) pfill(p,cur->xcol+width,usetabs);
   if(piseol(p)) pbackws(p);
   if(!pnextl(p)) binsc(p,'\n'), pgetc(p);
   if(pgetc(q)==MAXINT) break;
   }
 prm(p); prm(q); prm(r);
 }
d253 87
a339 19
int umarkb(bw)
BW *bw;
 {
 pdupown(bw->cursor,&markb);
 markb->xcol=bw->cursor->xcol;
 updall();
 return 0;
 }

int udrop(bw)
BW *bw;
 {
 prm(markk);
 if(marking && markb)
  prm(markb);
 else
  umarkb(bw);
 return 0;
 }
d343 7
a349 8
int umarkk(bw)
BW *bw;
 {
 pdupown(bw->cursor,&markk);
 markk->xcol=bw->cursor->xcol;
 updall();
 return 0;
 }
d353 7
a359 8
int unmark(bw)
BW *bw;
 {
 prm(markb);
 prm(markk);
 updall();
 return 0;
 }
d363 53
a415 48
int umarkl(bw)
BW *bw;
 {
 pbol(bw->cursor);
 umarkb(bw);
 pnextl(bw->cursor);
 umarkk(bw);
 utomarkb(bw);
 pcol(bw->cursor,bw->cursor->xcol);
 return 0;
 }

int utomarkb(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b) { pset(bw->cursor,markb); return 0; }
 else return -1;
 }

int utomarkk(bw)
BW *bw;
 {
 if(markk && markk->b==bw->b) { pset(bw->cursor,markk); return 0; }
 else return -1;
 }

int uswap(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b)
  {
  P *q=pdup(markb);
  umarkb(bw);
  pset(bw->cursor,q); prm(q);
  return 0;
  }
 else return -1;
 }

int utomarkbk(bw)
BW *bw;
 {
 if(markb && markb->b==bw->b && bw->cursor->byte!=markb->byte)
  { pset(bw->cursor,markb); return 0; }
 else if(markk && markk->b==bw->b && bw->cursor->byte!=markk->byte)
  { pset(bw->cursor,markk); return 0; }
 else return -1;
 }
d419 1
a419 1
extern int udelln();
d421 22
a442 22
int ublkdel(bw)
BW *bw;
 {
 if(markv(1))
  {
  if(square)
   if(bw->o.overtype)
    {
    long ocol=markk->xcol;
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,
             ptabrect(markb,markk->line-markb->line+1,markk->xcol));
    pcol(markk,ocol); markk->xcol=ocol;
    }
   else
    pdelrect(markb,markk->line-markb->line+1,markk->xcol);
  else
   bdel(markb,markk);
  if(lightoff) unmark(bw);
  }
 else { msgnw(bw,"No block"); return -1; }
 return 0;
 }
d446 22
a467 24
int upicokill(bw)
BW *bw;
 {
 upsh(bw);
 umarkk(bw);
 if(markv(1))
  {
  if(square)
   if(bw->o.overtype)
    {
    long ocol=markk->xcol;
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,
             ptabrect(markb,markk->line-markb->line+1,markk->xcol));
    pcol(markk,ocol); markk->xcol=ocol;
    }
   else
    pdelrect(markb,markk->line-markb->line+1,markk->xcol);
  else
   bdel(markb,markk);
  if(lightoff) unmark(bw);
  }
 else udelln(bw);
 return 0;
 }
d471 58
a528 60
int ublkmove(bw)
BW *bw;
 {
 if(markv(1))
  {
  if(markb->b->rdonly) { msgnw(bw,"Read only"); return -1; }
  if(square)
   {
   long height=markk->line-markb->line+1;
   long width=markk->xcol-markb->xcol;
   int usetabs=ptabrect(markb,height,markk->xcol);
   long ocol=piscol(bw->cursor);
   B *tmp=pextrect(markb,height,markk->xcol);
   ublkdel(bw);
   if(bw->o.overtype)
    {
    /* If cursor was in block, blkdel moves it to left edge of block, so fix it
     * back to its original place here */
    pcol(bw->cursor,ocol);
    pfill(bw->cursor,ocol,0);
    pdelrect(bw->cursor,height,piscol(bw->cursor)+width);
    }
   else if(bw->cursor->xcol>=markk->xcol &&
           bw->cursor->line>=markb->line &&
           bw->cursor->line<=markk->line)
    /* If cursor was to right of block, xcol was not properly updated */
    bw->cursor->xcol-=width;
   pinsrect(bw->cursor,tmp,width,usetabs);
   brm(tmp);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   return 0;
   }
  else if(bw->cursor->b!=markk->b ||
          bw->cursor->byte>markk->byte ||
          bw->cursor->byte<markb->byte)
   {
   long size=markk->byte-markb->byte;
   binsb(bw->cursor,bcpy(markb,markk));
   bdel(markb,markk);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pfwrd(markk,size);
    }
   updall();
   return 0;
   }
  }
 msgnw(bw,"No block");
 return -1;
 }
d532 42
a573 39
int ublkcpy(bw)
BW *bw;
 {
 if(markv(1))
  if(square)
   {
   long height=markk->line-markb->line+1;
   long width=markk->xcol-markb->xcol;
   int usetabs=ptabrect(markb,height,markk->xcol);
   B *tmp=pextrect(markb,height,markk->xcol);
   if(bw->o.overtype) pdelrect(bw->cursor,height,piscol(bw->cursor)+width);
   pinsrect(bw->cursor,tmp,width,usetabs);
   brm(tmp);
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   return 0;
   }
  else
   {
   long size=markk->byte-markb->byte;
   binsb(bw->cursor,bcpy(markb,markk));
   if(lightoff) unmark(bw);
   else
    {
    umarkb(bw);
    umarkk(bw);
    pfwrd(markk,size);
    }
   updall();
   return 0;
   }
 else { msgnw(bw,"No block"); return -1; }
 }
d578 40
a617 35
int dowrite(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(markv(1))
  if(square)
   {
   int fl;
   int ret=0;
   B *tmp=pextrect(markb,markk->line-markb->line+1,markk->xcol);
   if(fl=bsave(tmp->bof,s,tmp->eof->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
   brm(tmp);
   if(lightoff) unmark(bw);
   vsrm(s);
   return ret;
   }
  else
   {
   int fl;
   int ret=0;
   if(fl=bsave(markb,s,markk->byte-markb->byte)) msgnw(bw,msgs[5+fl]), ret= -1;
   if(lightoff) unmark(bw);
   vsrm(s);
   return ret;
   }
 else
  {
  vsrm(s);
  msgnw(bw,"No block");
  return -1;
  }
 }
d621 90
a710 32
void setindent(bw)
BW *bw;
 {
 P *p, *q;
 long indent;
 if(pisblank(bw->cursor)) return;
 
 p=pdup(bw->cursor);
 q=pdup(p);
 indent=pisindent(p);
 
 do
  if(!pprevl(p)) goto done;
  else pbol(p);
  while(pisindent(p)>=indent && !pisblank(p));
 pnextl(p);
 done:
 pbol(p);
 p->xcol=piscol(p);
 if(markb) prm(markb);
 markb=p; p->owner= &markb;
 
 do
  if(!pnextl(q)) break;
  while(pisindent(q)>=indent && !pisblank(q));
 
 if(markk) prm(markk);
 q->xcol=piscol(q);
 markk=q; q->owner= &markk;
 
 updall();
 }
d714 60
a773 37
int urindent(bw)
BW *bw;
 {
 if(square)
  {
  if(markb && markk && markb->b==markk->b &&
     markb->byte<=markk->byte && markb->xcol<=markk->xcol)
   {
   P *p=pdup(markb);
   do
    {
    pcol(p,markb->xcol);
    pfill(p,markb->xcol+bw->o.istep,bw->o.indentc=='\t'?1:0);
    } while(pnextl(p) && p->line<=markk->line);
   prm(p);
   }
  }
 else
  {
  if(!markb || !markk || markb->b!=markk->b ||
     bw->cursor->byte<markb->byte || bw->cursor->byte>markk->byte ||
     markb->byte==markk->byte)
   setindent(bw);
  else
   {
   P *p=pdup(markb);
   while(p->byte<markk->byte)
    {
    pbol(p);
    if(!piseol(p)) while(piscol(p)<bw->o.istep) binsc(p,bw->o.indentc), pgetc(p);
    pnextl(p);
    }
   prm(p);
   }
  }
 return 0;
 }
d777 80
a856 77
int ulindent(bw)
BW *bw;
 {
 if(square)
  {
  if(markb && markk && markb->b==markk->b &&
     markb->byte<=markk->byte && markb->xcol<=markk->xcol)
   {
   P *p=pdup(markb);
   P *q=pdup(p);
   do
    {
    pcol(p,markb->xcol);
    while(piscol(p)<markb->xcol+bw->o.istep)
     {
     int c=pgetc(p);
     if(c!=' ' && c!='\t' && c!=bw->o.indentc)
      {
      prm(p);
      prm(q);
      return -1;
      }
     }
    } while(pnextl(p) && p->line<=markk->line);
   pset(p,markb);
   do
    {
    pcol(p,markb->xcol);
    pset(q,p);
    pcol(q,markb->xcol+bw->o.istep);
    bdel(p,q);
    } while(pnextl(p) && p->line<=markk->line);
   prm(p); prm(q);
   }
  }
 else
  {
  if(!markb || !markk || markb->b!=markk->b ||
     bw->cursor->byte<markb->byte || bw->cursor->byte>markk->byte ||
     markb->byte==markk->byte)
   setindent(bw);
  else
   {
   P *p=pdup(markb);
   P *q=pdup(p);
   pbol(p);
   while(p->byte<markk->byte)
    {
    if(!piseol(p)) while(piscol(p)<bw->o.istep)
     {
     int c=pgetc(p);
     if(c!=' ' && c!='\t' && c!=bw->o.indentc)
      {
      prm(p);
      prm(q);
      return -1;
      }
     }
    pnextl(p);
    }
   pset(p,markb);
   pbol(p);
   while(p->byte<markk->byte)
    {
    if(!piseol(p))
     {
     pset(q,p);
     while(piscol(q)<bw->o.istep) pgetc(q);
     bdel(p,q);
     }
    pnextl(p);
    }
   prm(p); prm(q);
   }
  }
 return 0;
 }
d860 55
a914 52
int doinsf(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(square)
  if(markv(1))
   {
   B *tmp;
   long width=markk->xcol-markb->xcol;
   long height;
   int usetabs=ptabrect(markb,markk->line-markb->line+1,markk->xcol);
   tmp=bload(s); 
   if(error)
    {
    msgnw(bw,msgs[error+5]);
    brm(tmp);
    return -1;
    }
   if(piscol(tmp->eof)) height=tmp->eof->line+1;
   else height=tmp->eof->line;
   if(bw->o.overtype)
    {
    pclrrect(markb,Lmax(markk->line-markb->line+1,height),markk->xcol,usetabs);
    pdelrect(markb,height,width+markb->xcol);
    }
   pinsrect(markb,tmp,width,usetabs);
   pdupown(markb,&markk);
   markk->xcol=markb->xcol;
   if(height)
    {
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   brm(tmp);
   updall();
   return 0;
   }
  else { msgnw(bw,"No block"); return -1; }
 else
  {
  int ret=0;
  B *tmp=bload(s);
  if(error) msgnw(bw,msgs[error+5]), brm(tmp), ret= -1;
  else binsb(bw->cursor,tmp);
  vsrm(s);
  bw->cursor->xcol=piscol(bw->cursor);
  return ret;
  }
 }
d919 1
a919 1
static int filtflg=0;
d921 149
a1069 131
static int dofilt(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int fr[2];
 int fw[2];
 if(notify) *notify=1; 
 if(markb && markk && !square &&
    markb->b==bw->b && markk->b==bw->b && markb->byte==markk->byte) goto ok;
 if(!markv(1))
  {
  msgnw(bw,"No block");
  return -1;
  }
 ok:
 
 pipe(fr);
 pipe(fw);
 npartial(bw->parent->t->t);
 ttclsn();
 if(!fork())
  {
  signrm();
  close(0);
  close(1);
  close(2);
  dup(fw[0]);
  dup(fr[1]);
  dup(fr[1]);
  close(fw[0]);
  close(fr[1]);
  close(fw[1]);
  close(fr[0]);
  execl("/bin/sh","/bin/sh","-c",s,NULL);
  _exit(0);
  }
 close(fr[1]);
 close(fw[0]);
 if(fork())
  {
  long szz;
  close(fw[1]);
  if(square)
   {
   B *tmp;
   long width=markk->xcol-markb->xcol;
   long height;
   int usetabs=ptabrect(markb,markk->line-markb->line+1,markk->xcol);
   tmp=bread(fr[0],MAXLONG);
   if(piscol(tmp->eof)) height=tmp->eof->line+1;
   else height=tmp->eof->line;
   if(bw->o.overtype)
    {
    pclrrect(markb,markk->line-markb->line+1,markk->xcol,usetabs);
    pdelrect(markb,Lmax(height,markk->line-markb->line+1),width+markb->xcol);
    }
   else pdelrect(markb,markk->line-markb->line+1,markk->xcol);
   pinsrect(markb,tmp,width,usetabs);
   pdupown(markb,&markk);
   markk->xcol=markb->xcol;
   if(height)
    {
    pline(markk,markk->line+height-1);
    pcol(markk,markb->xcol+width); markk->xcol=markb->xcol+width;
    }
   if(lightoff) unmark(bw);
   brm(tmp);
   updall();
   }
  else
   {
   bdel(markb,markk);
   szz=markk->b->eof->byte;
   binsb(markk,bread(fr[0],MAXLONG));
   pfwrd(markk,markk->b->eof->byte-szz);
   if(lightoff) unmark(bw);
   }
  close(fr[0]);
  wait(0);
  wait(0);
  }
 else
  {
  if(square)
   {
   B *tmp=pextrect(markb,markk->line-markb->line+1,markk->xcol);
   bsavefd(tmp->bof,fw[1],tmp->eof->byte);
   }
  else bsavefd(markb,fw[1],markk->byte-markb->byte);
  close(fw[1]);
  _exit(0);
  }
 vsrm(s);
 ttopnn();
 if(filtflg) unmark(bw);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

static B *filthist=0;

void markall(bw)
BW *bw;
 {
 pdupown(bw->cursor->b->bof,&markb); markb->xcol=0;
 pdupown(bw->cursor->b->eof,&markk); markk->xcol=piscol(markk);
 updall();
 }

int checkmark(bw)
BW *bw;
 {
 if(!markv(1))
  if(square) return 2;
  else
   {
   markall(bw), filtflg=1;
   return 1;
   }
 else
  {
  filtflg=0;
  return 0;
  }
 }

int ufilt(bw)
BW *bw;
 {
d1071 2
a1072 2
 msgnw(bw,"Sorry, no sub-processes in DOS (yet)");
 return -1;
d1074 16
a1089 18
 switch(checkmark(bw))
  {
  case 0:
  if(wmkpw(bw,
           "Command to filter block through (^C to abort): ",
           &filthist,dofilt,NULL,NULL,utypebw,NULL,NULL)) return 0;
  else return -1;

  case 1:
  if(wmkpw(bw,
           "Command to filter file through (^C to abort): ",
           &filthist,dofilt,NULL,NULL,utypebw,NULL,NULL)) return 0;
  else return -1;

  case 2:
  msgnw(bw,"No block");
  return -1;
  }
d1091 60
a1150 1
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
