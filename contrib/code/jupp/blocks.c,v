head	1.8;
access;
symbols
	joe-3_1jupp38:1.8
	joe-3_1jupp37:1.8
	joe-3_1jupp36:1.8
	joe-3_1jupp35:1.8
	joe-3_1jupp34:1.8
	joe-3_1jupp33:1.8
	joe-3_1jupp32:1.6
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.5
	joe-3_1jupp30:1.4
	joe-3_1jupp29:1.4
	joe-3_1jupp28:1.4
	joe-3_1jupp27:1.4
	joe-3_1jupp26:1.4
	joe-3_1jupp25:1.4
	joe-3_1jupp24:1.4
	joe-3_1jupp23:1.4
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.8
date	2018.01.06.00.28.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A50184621FA8455;

1.7
date	2017.12.20.21.30.33;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A3AD61F39A5B6C8;

1.6
date	2017.12.02.02.07.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A220AD65C90E687;

1.5
date	2017.08.08.16.09.43;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005989E25A6D58D2BB;

1.4
date	2012.06.08.16.55.27;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004FD22E961A7F5A95;

1.3
date	2010.01.03.18.22.03;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004B40E05D33D0D68A;

1.2
date	2008.05.13.13.08.21;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.20;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@/*
 *	Fast block move/copy subroutines
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"

__RCSID("$MirOS: contrib/code/jupp/blocks.c,v 1.7 2017/12/20 21:30:33 tg Exp $");

/* This module requires ALIGNED and SIZEOF_INT to be defined correctly */

#include "blocks.h"

#define BITS 8

#if SIZEOF_INT == 8
#  define SHFT 3
#elif SIZEOF_INT == 4
#  define SHFT 2
#endif

/* Set 'sz' 'int's beginning at 'd' to the value 'c' */
/* Returns address of block.  Does nothing if 'sz' equals zero */

int *msetI(void *dest, int c, int sz)
{
	int	*d = dest;
	int	*orgd = dest;

	while (sz >= 16) {
		d[0] = c;
		d[1] = c;
		d[2] = c;
		d[3] = c;
		d[4] = c;
		d[5] = c;
		d[6] = c;
		d[7] = c;
		d[8] = c;
		d[9] = c;
		d[10] = c;
		d[11] = c;
		d[12] = c;
		d[13] = c;
		d[14] = c;
		d[15] = c;
		d += 16;
		sz -= 16;
	}
	switch (sz) {
	case 15:	d[14] = c;	/* FALLTHROUGH */
	case 14:	d[13] = c;	/* FALLTHROUGH */
	case 13:	d[12] = c;	/* FALLTHROUGH */
	case 12:	d[11] = c;	/* FALLTHROUGH */
	case 11:	d[10] = c;	/* FALLTHROUGH */
	case 10:	d[9] = c;	/* FALLTHROUGH */
	case 9:		d[8] = c;	/* FALLTHROUGH */
	case 8:		d[7] = c;	/* FALLTHROUGH */
	case 7:		d[6] = c;	/* FALLTHROUGH */
	case 6:		d[5] = c;	/* FALLTHROUGH */
	case 5:		d[4] = c;	/* FALLTHROUGH */
	case 4:		d[3] = c;	/* FALLTHROUGH */
	case 3:		d[2] = c;	/* FALLTHROUGH */
	case 2:		d[1] = c;	/* FALLTHROUGH */
	case 1:		d[0] = c;	/* FALLTHROUGH */
	case 0:		/* do nothing */;
	}
	return orgd;
}

/* Set 'sz' 'int's beginning at 'd' to the value 'c' */
/* Returns address of block.  Does nothing if 'sz' equals zero */

void **msetP(void **d, void *c, int sz)
{
	void	**orgd = d;

	while (sz >= 16) {
		d[0] = c;
		d[1] = c;
		d[2] = c;
		d[3] = c;
		d[4] = c;
		d[5] = c;
		d[6] = c;
		d[7] = c;
		d[8] = c;
		d[9] = c;
		d[10] = c;
		d[11] = c;
		d[12] = c;
		d[13] = c;
		d[14] = c;
		d[15] = c;
		d += 16;
		sz -= 16;
	}
	switch (sz) {
	case 15:	d[14] = c;	/* FALLTHROUGH */
	case 14:	d[13] = c;	/* FALLTHROUGH */
	case 13:	d[12] = c;	/* FALLTHROUGH */
	case 12:	d[11] = c;	/* FALLTHROUGH */
	case 11:	d[10] = c;	/* FALLTHROUGH */
	case 10:	d[9] = c;	/* FALLTHROUGH */
	case 9:		d[8] = c;	/* FALLTHROUGH */
	case 8:		d[7] = c;	/* FALLTHROUGH */
	case 7:		d[6] = c;	/* FALLTHROUGH */
	case 6:		d[5] = c;	/* FALLTHROUGH */
	case 5:		d[4] = c;	/* FALLTHROUGH */
	case 4:		d[3] = c;	/* FALLTHROUGH */
	case 3:		d[2] = c;	/* FALLTHROUGH */
	case 2:		d[1] = c;	/* FALLTHROUGH */
	case 1:		d[0] = c;	/* FALLTHROUGH */
	case 0:		/* do nothing */;
	}
	return orgd;
}

/* Set 'sz' 'char's beginning at 'd' to the value 'c' */
/* Returns address of block.  Does nothing if 'sz' equals zero */

unsigned char *mset(void *dest, unsigned char c, int sz)
{
	unsigned char	*d = dest;
	unsigned char	*orgd = dest;

	if (sz < 16) {
		switch (sz) {
		case 15:	d[14] = c;	/* FALLTHROUGH */
		case 14:	d[13] = c;	/* FALLTHROUGH */
		case 13:	d[12] = c;	/* FALLTHROUGH */
		case 12:	d[11] = c;	/* FALLTHROUGH */
		case 11:	d[10] = c;	/* FALLTHROUGH */
		case 10:	d[9] = c;	/* FALLTHROUGH */
		case 9:		d[8] = c;	/* FALLTHROUGH */
		case 8:		d[7] = c;	/* FALLTHROUGH */
		case 7:		d[6] = c;	/* FALLTHROUGH */
		case 6:		d[5] = c;	/* FALLTHROUGH */
		case 5:		d[4] = c;	/* FALLTHROUGH */
		case 4:		d[3] = c;	/* FALLTHROUGH */
		case 3:		d[2] = c;	/* FALLTHROUGH */
		case 2:		d[1] = c;	/* FALLTHROUGH */
		case 1:		d[0] = c;	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
	} else {
		unsigned z = SIZEOF_INT - ((unsigned long)d & (SIZEOF_INT - 1));

		switch (z) {
		case SIZEOF_INT: break;
#if SIZEOF_INT >= 8
		case 7:		d[6] = c;	/* FALLTHROUGH */
		case 6:		d[5] = c;	/* FALLTHROUGH */
		case 5:		d[4] = c;	/* FALLTHROUGH */
		case 4:		d[3] = c;	/* FALLTHROUGH */
#endif
		case 3:		d[2] = c;	/* FALLTHROUGH */
		case 2:		d[1] = c;	/* FALLTHROUGH */
		case 1:		d[0] = c;	/* FALLTHROUGH */
		case 0:
			d += z;
			sz -= z;
			break;
		}
		msetI(d,
#if SIZEOF_INT >= 8
		      (c << (BITS * 7)) + (c << (BITS * 6)) + (c << (BITS * 5)) + (c << (BITS * 4)) +
#endif
#if SIZEOF_INT >= 4
		      (c << (BITS * 3)) + (c << (BITS * 2)) +
#endif
#if SIZEOF_INT >= 2
		      (c << BITS) +
#endif
		      c, sz >> SHFT);
		d += sz & ~(SIZEOF_INT - 1);
		switch (sz & (SIZEOF_INT - 1)) {
#if SIZEOF_INT >= 8
		case 7:		d[6] = c;	/* FALLTHROUGH */
		case 6:		d[5] = c;	/* FALLTHROUGH */
		case 5:		d[4] = c;	/* FALLTHROUGH */
		case 4:		d[3] = c;	/* FALLTHROUGH */
#endif
		case 3:		d[2] = c;	/* FALLTHROUGH */
		case 2:		d[1] = c;	/* FALLTHROUGH */
		case 1:		d[0] = c;	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
	}
	return orgd;
}

/* Copy a block of integers */
/* Copy from highest address to lowest */

static int *mbkwdI(void *dest, const void *src, int sz)
{
	int	*d = dest;
	const int *s = src;

	if (d == s)
		return d;
	d += sz;
	s += sz;
	while (sz >= 16) {
		d -= 16;
		s -= 16;
		d[15] = s[15];
		d[14] = s[14];
		d[13] = s[13];
		d[12] = s[12];
		d[11] = s[11];
		d[10] = s[10];
		d[9] = s[9];
		d[8] = s[8];
		d[7] = s[7];
		d[6] = s[6];
		d[5] = s[5];
		d[4] = s[4];
		d[3] = s[3];
		d[2] = s[2];
		d[1] = s[1];
		d[0] = s[0];
		sz -= 16;
	}
	d -= sz;
	s -= sz;
	switch (sz) {
	case 15:	d[14] = s[14];	/* FALLTHROUGH */
	case 14:	d[13] = s[13];	/* FALLTHROUGH */
	case 13:	d[12] = s[12];	/* FALLTHROUGH */
	case 12:	d[11] = s[11];	/* FALLTHROUGH */
	case 11:	d[10] = s[10];	/* FALLTHROUGH */
	case 10:	d[9] = s[9];	/* FALLTHROUGH */
	case 9:		d[8] = s[8];	/* FALLTHROUGH */
	case 8:		d[7] = s[7];	/* FALLTHROUGH */
	case 7:		d[6] = s[6];	/* FALLTHROUGH */
	case 6:		d[5] = s[5];	/* FALLTHROUGH */
	case 5:		d[4] = s[4];	/* FALLTHROUGH */
	case 4:		d[3] = s[3];	/* FALLTHROUGH */
	case 3:		d[2] = s[2];	/* FALLTHROUGH */
	case 2:		d[1] = s[1];	/* FALLTHROUGH */
	case 1:		d[0] = s[0];	/* FALLTHROUGH */
	case 0:		/* do nothing */;
	}
	return d;
}

/* Copy a block of 'int's.  Copy from lowest address to highest */

static int *mfwrdI(void *dest, const void *src, int sz)
{
	int	*d = dest;
	const int *s = src;
	int	*od = d;

	if (s == d)
		return d;
	while (sz >= 16) {
		d[0] = s[0];
		d[1] = s[1];
		d[2] = s[2];
		d[3] = s[3];
		d[4] = s[4];
		d[5] = s[5];
		d[6] = s[6];
		d[7] = s[7];
		d[8] = s[8];
		d[9] = s[9];
		d[10] = s[10];
		d[11] = s[11];
		d[12] = s[12];
		d[13] = s[13];
		d[14] = s[14];
		d[15] = s[15];
		s += 16;
		d += 16;
		sz -= 16;
	}
	s -= 15 - sz;
	d -= 15 - sz;
	switch (sz) {
	case 15:	d[0] = s[0];	/* FALLTHROUGH */
	case 14:	d[1] = s[1];	/* FALLTHROUGH */
	case 13:	d[2] = s[2];	/* FALLTHROUGH */
	case 12:	d[3] = s[3];	/* FALLTHROUGH */
	case 11:	d[4] = s[4];	/* FALLTHROUGH */
	case 10:	d[5] = s[5];	/* FALLTHROUGH */
	case 9:		d[6] = s[6];	/* FALLTHROUGH */
	case 8:		d[7] = s[7];	/* FALLTHROUGH */
	case 7:		d[8] = s[8];	/* FALLTHROUGH */
	case 6:		d[9] = s[9];	/* FALLTHROUGH */
	case 5:		d[10] = s[10];	/* FALLTHROUGH */
	case 4:		d[11] = s[11];	/* FALLTHROUGH */
	case 3:		d[12] = s[12];	/* FALLTHROUGH */
	case 2:		d[13] = s[13];	/* FALLTHROUGH */
	case 1:		d[14] = s[14];	/* FALLTHROUGH */
	case 0:		/* do nothing */;
	}
	return od;
}

/* Copy the block of 'sz' bytes beginning at 's' to 'd'.  If 'sz' is zero or
 * if 's'=='d', nothing happens.  The bytes at the highest address ('s'+'sz'-1)
 * are copied before the ones at the lowest ('s') are.
 */

static unsigned char *mbkwd(register unsigned char *d, register const unsigned char *s, register int sz)
{
	if (s == d)
		return d;
	s += sz;
	d += sz;
#ifdef ALIGNED
	if (sz >= 16)
#else
	if (((unsigned long)s & (SIZEOF_INT - 1)) == ((unsigned long)d & (SIZEOF_INT - 1)) && sz >= 16)
#endif
	{
		unsigned z = ((unsigned long) s & (SIZEOF_INT - 1));

		s -= z;
		d -= z;
		switch (z) {
#if SIZEOF_INT >= 8
		case 7:		d[6] = s[6];	/* FALLTHROUGH */
		case 6:		d[5] = s[5];	/* FALLTHROUGH */
		case 5:		d[4] = s[4];	/* FALLTHROUGH */
		case 4:		d[3] = s[3];	/* FALLTHROUGH */
#endif
		case 3:		d[2] = s[2];	/* FALLTHROUGH */
		case 2:		d[1] = s[1];	/* FALLTHROUGH */
		case 1:		d[0] = s[0];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
		sz -= z;
		mbkwdI(d - (sz & ~(SIZEOF_INT - 1)), s - (sz & ~(SIZEOF_INT - 1)), sz >> SHFT);
		d -= sz;
		s -= sz;
		switch (sz & (SIZEOF_INT - 1)) {
#if SIZEOF_INT >= 8
		case 7:		d[6] = s[6];	/* FALLTHROUGH */
		case 6:		d[5] = s[5];	/* FALLTHROUGH */
		case 5:		d[4] = s[4];	/* FALLTHROUGH */
		case 4:		d[3] = s[3];	/* FALLTHROUGH */
#endif
		case 3:		d[2] = s[2];	/* FALLTHROUGH */
		case 2:		d[1] = s[1];	/* FALLTHROUGH */
		case 1:		d[0] = s[0];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
	} else {
		while (sz >= 16) {
			d -= 16;
			s -= 16;
			d[15] = s[15];
			d[14] = s[14];
			d[13] = s[13];
			d[12] = s[12];
			d[11] = s[11];
			d[10] = s[10];
			d[9] = s[9];
			d[8] = s[8];
			d[7] = s[7];
			d[6] = s[6];
			d[5] = s[5];
			d[4] = s[4];
			d[3] = s[3];
			d[2] = s[2];
			d[1] = s[1];
			d[0] = s[0];
			sz -= 16;
		}
		d -= sz;
		s -= sz;
		switch (sz) {
		case 15:	d[14] = s[14];	/* FALLTHROUGH */
		case 14:	d[13] = s[13];	/* FALLTHROUGH */
		case 13:	d[12] = s[12];	/* FALLTHROUGH */
		case 12:	d[11] = s[11];	/* FALLTHROUGH */
		case 11:	d[10] = s[10];	/* FALLTHROUGH */
		case 10:	d[9] = s[9];	/* FALLTHROUGH */
		case 9:		d[8] = s[8];	/* FALLTHROUGH */
		case 8:		d[7] = s[7];	/* FALLTHROUGH */
		case 7:		d[6] = s[6];	/* FALLTHROUGH */
		case 6:		d[5] = s[5];	/* FALLTHROUGH */
		case 5:		d[4] = s[4];	/* FALLTHROUGH */
		case 4:		d[3] = s[3];	/* FALLTHROUGH */
		case 3:		d[2] = s[2];	/* FALLTHROUGH */
		case 2:		d[1] = s[1];	/* FALLTHROUGH */
		case 1:		d[0] = s[0];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
	}
	return d;
}

/* Copy the block of 'sz' bytes beginning at 's' to 'd'.  If 'sz' is zero or
 * if 's'=='d', nothing happens.  The bytes at the lowest address ('s')
 * are copied before the ones at the highest ('s'+'sz'-1) are.
 */

static unsigned char *mfwrd(register unsigned char *d, register const unsigned char *s, register int sz)
{
	unsigned char *od = d;

	if (d == s)
		return d;
#ifdef ALIGNED
	if (sz >= 16)
#else
	if (((unsigned long)d & (SIZEOF_INT - 1)) == ((unsigned long)s & (SIZEOF_INT - 1)) && sz >= 16)
#endif
	{
		unsigned z = ((unsigned long)s & (SIZEOF_INT - 1));

		if (z) {
			s -= z;
			d -= z;
			switch (SIZEOF_INT - z) {
#if SIZEOF_INT == 8
			case 7:		d[1] = s[1];	/* FALLTHROUGH */
			case 6:		d[2] = s[2];	/* FALLTHROUGH */
			case 5:		d[3] = s[3];	/* FALLTHROUGH */
			case 4:		d[4] = s[4];	/* FALLTHROUGH */
			case 3:		d[5] = s[5];	/* FALLTHROUGH */
			case 2:		d[6] = s[6];	/* FALLTHROUGH */
			case 1:		d[7] = s[7];	/* FALLTHROUGH */
			case 0:		/* do nothing */;
#elif SIZEOF_INT == 4
			case 3:		d[1] = s[1];	/* FALLTHROUGH */
			case 2:		d[2] = s[2];	/* FALLTHROUGH */
			case 1:		d[3] = s[3];	/* FALLTHROUGH */
			case 0:		/* do nothing */;
#endif
			}
			s += SIZEOF_INT;
			d += SIZEOF_INT;
			sz -= SIZEOF_INT - z;
		}
		mfwrdI(d, s, sz >> SHFT);
		s += sz - (SIZEOF_INT - 1);
		d += sz - (SIZEOF_INT - 1);
		switch (sz & (SIZEOF_INT - 1)) {
#if SIZEOF_INT == 8
		case 7:		d[0] = s[0];	/* FALLTHROUGH */
		case 6:		d[1] = s[1];	/* FALLTHROUGH */
		case 5:		d[2] = s[2];	/* FALLTHROUGH */
		case 4:		d[3] = s[3];	/* FALLTHROUGH */
		case 3:		d[4] = s[4];	/* FALLTHROUGH */
		case 2:		d[5] = s[5];	/* FALLTHROUGH */
		case 1:		d[6] = s[6];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
#elif SIZEOF_INT == 4
		case 3:		d[0] = s[0];	/* FALLTHROUGH */
		case 2:		d[1] = s[1];	/* FALLTHROUGH */
		case 1:		d[2] = s[2];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
#endif
		}
	} else {
		while (sz >= 16) {
			d[0] = s[0];
			d[1] = s[1];
			d[2] = s[2];
			d[3] = s[3];
			d[4] = s[4];
			d[5] = s[5];
			d[6] = s[6];
			d[7] = s[7];
			d[8] = s[8];
			d[9] = s[9];
			d[10] = s[10];
			d[11] = s[11];
			d[12] = s[12];
			d[13] = s[13];
			d[14] = s[14];
			d[15] = s[15];
			s += 16;
			d += 16;
			sz -= 16;
		}
		s -= 15 - sz;
		d -= 15 - sz;
		switch (sz) {
		case 15:	d[0] = s[0];	/* FALLTHROUGH */
		case 14:	d[1] = s[1];	/* FALLTHROUGH */
		case 13:	d[2] = s[2];	/* FALLTHROUGH */
		case 12:	d[3] = s[3];	/* FALLTHROUGH */
		case 11:	d[4] = s[4];	/* FALLTHROUGH */
		case 10:	d[5] = s[5];	/* FALLTHROUGH */
		case 9:		d[6] = s[6];	/* FALLTHROUGH */
		case 8:		d[7] = s[7];	/* FALLTHROUGH */
		case 7:		d[8] = s[8];	/* FALLTHROUGH */
		case 6:		d[9] = s[9];	/* FALLTHROUGH */
		case 5:		d[10] = s[10];	/* FALLTHROUGH */
		case 4:		d[11] = s[11];	/* FALLTHROUGH */
		case 3:		d[12] = s[12];	/* FALLTHROUGH */
		case 2:		d[13] = s[13];	/* FALLTHROUGH */
		case 1:		d[14] = s[14];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
		}
	}
	return od;
}

void *mmove(void *d, const void *s, int sz)
{
	if (d > s)
		mbkwd(d, s, sz);
	else
		mfwrd(d, s, sz);
	return d;
}

/* Utility to count number of lines within a segment */

int mcnt(register const unsigned char *blk, register unsigned char c, int size)
{
	register int nlines = 0;

	while (size >= 16) {
		if (blk[0] == c) ++nlines;
		if (blk[1] == c) ++nlines;
		if (blk[2] == c) ++nlines;
		if (blk[3] == c) ++nlines;
		if (blk[4] == c) ++nlines;
		if (blk[5] == c) ++nlines;
		if (blk[6] == c) ++nlines;
		if (blk[7] == c) ++nlines;
		if (blk[8] == c) ++nlines;
		if (blk[9] == c) ++nlines;
		if (blk[10] == c) ++nlines;
		if (blk[11] == c) ++nlines;
		if (blk[12] == c) ++nlines;
		if (blk[13] == c) ++nlines;
		if (blk[14] == c) ++nlines;
		if (blk[15] == c) ++nlines;
		blk += 16;
		size -= 16;
	}
	switch (size) {
	case 15:	if (blk[14] == c) ++nlines;	/* FALLTHROUGH */
	case 14:	if (blk[13] == c) ++nlines;	/* FALLTHROUGH */
	case 13:	if (blk[12] == c) ++nlines;	/* FALLTHROUGH */
	case 12:	if (blk[11] == c) ++nlines;	/* FALLTHROUGH */
	case 11:	if (blk[10] == c) ++nlines;	/* FALLTHROUGH */
	case 10:	if (blk[9] == c) ++nlines;	/* FALLTHROUGH */
	case 9:		if (blk[8] == c) ++nlines;	/* FALLTHROUGH */
	case 8:		if (blk[7] == c) ++nlines;	/* FALLTHROUGH */
	case 7:		if (blk[6] == c) ++nlines;	/* FALLTHROUGH */
	case 6:		if (blk[5] == c) ++nlines;	/* FALLTHROUGH */
	case 5:		if (blk[4] == c) ++nlines;	/* FALLTHROUGH */
	case 4:		if (blk[3] == c) ++nlines;	/* FALLTHROUGH */
	case 3:		if (blk[2] == c) ++nlines;	/* FALLTHROUGH */
	case 2:		if (blk[1] == c) ++nlines;	/* FALLTHROUGH */
	case 1:		if (blk[0] == c) ++nlines;	/* FALLTHROUGH */
	case 0:		/* do nothing */;
	}
	return nlines;
}
@


1.7
log
@eliminate dead code on systems with int sizes below 64 bits;
drop (some) support for 16-bit int (leaving us with 32/64)

spotted by Coverity Scan
@
text
@d10 1
a10 1
__RCSID("$MirOS: contrib/code/jupp/blocks.c,v 1.6 2017/12/02 02:07:23 tg Exp $");
d520 1
a520 1
int mcnt(register unsigned char *blk, register unsigned char c, int size)
@


1.6
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d10 1
a10 1
__RCSID("$MirOS$");
a21 2
#elif SIZEOF_INT == 2
#  define SHFT 1
d151 12
a162 11
		if (z != SIZEOF_INT) {
			switch (z) {
			case 7:		d[6] = c;	/* FALLTHROUGH */
			case 6:		d[5] = c;	/* FALLTHROUGH */
			case 5:		d[4] = c;	/* FALLTHROUGH */
			case 4:		d[3] = c;	/* FALLTHROUGH */
			case 3:		d[2] = c;	/* FALLTHROUGH */
			case 2:		d[1] = c;	/* FALLTHROUGH */
			case 1:		d[0] = c;	/* FALLTHROUGH */
			case 0:		/* do nothing */;
			}
d165 1
d180 1
d185 1
d327 1
d332 1
d343 1
d348 1
d432 1
a432 2
#else
#if SIZEOF_INT == 4
a436 6
#else
#if SIZEOF_INT == 2
			case 1:		d[1] = s[1];	/* FALLTHROUGH */
			case 0:		/* do nothing */;
#endif
#endif
d456 1
a456 2
#else
#if SIZEOF_INT == 4
a460 6
#else
#if SIZEOF_INT == 2
		case 1:		d[0] = s[0];	/* FALLTHROUGH */
		case 0:		/* do nothing */;
#endif
#endif
@


1.5
log
@GCC 7 has stricter /* FALLTHROUGH */ rules
@
text
@a0 1
/* $MirOS: contrib/code/jupp/blocks.c,v 1.3 2010/01/03 18:22:03 tg Exp $ */
d10 2
@


1.4
log
@nuke junk
@
text
@d54 15
a68 15
	case 15:	d[14] = c;
	case 14:	d[13] = c;
	case 13:	d[12] = c;
	case 12:	d[11] = c;
	case 11:	d[10] = c;
	case 10:	d[9] = c;
	case 9:		d[8] = c;
	case 8:		d[7] = c;
	case 7:		d[6] = c;
	case 6:		d[5] = c;
	case 5:		d[4] = c;
	case 4:		d[3] = c;
	case 3:		d[2] = c;
	case 2:		d[1] = c;
	case 1:		d[0] = c;
d102 15
a116 15
	case 15:	d[14] = c;
	case 14:	d[13] = c;
	case 13:	d[12] = c;
	case 12:	d[11] = c;
	case 11:	d[10] = c;
	case 10:	d[9] = c;
	case 9:		d[8] = c;
	case 8:		d[7] = c;
	case 7:		d[6] = c;
	case 6:		d[5] = c;
	case 5:		d[4] = c;
	case 4:		d[3] = c;
	case 3:		d[2] = c;
	case 2:		d[1] = c;
	case 1:		d[0] = c;
d132 15
a146 15
		case 15:	d[14] = c;
		case 14:	d[13] = c;
		case 13:	d[12] = c;
		case 12:	d[11] = c;
		case 11:	d[10] = c;
		case 10:	d[9] = c;
		case 9:		d[8] = c;
		case 8:		d[7] = c;
		case 7:		d[6] = c;
		case 6:		d[5] = c;
		case 5:		d[4] = c;
		case 4:		d[3] = c;
		case 3:		d[2] = c;
		case 2:		d[1] = c;
		case 1:		d[0] = c;
d154 7
a160 7
			case 7:		d[6] = c;
			case 6:		d[5] = c;
			case 5:		d[4] = c;
			case 4:		d[3] = c;
			case 3:		d[2] = c;
			case 2:		d[1] = c;
			case 1:		d[0] = c;
d179 7
a185 7
		case 7:		d[6] = c;
		case 6:		d[5] = c;
		case 5:		d[4] = c;
		case 4:		d[3] = c;
		case 3:		d[2] = c;
		case 2:		d[1] = c;
		case 1:		d[0] = c;
d228 15
a242 15
	case 15:	d[14] = s[14];
	case 14:	d[13] = s[13];
	case 13:	d[12] = s[12];
	case 12:	d[11] = s[11];
	case 11:	d[10] = s[10];
	case 10:	d[9] = s[9];
	case 9:		d[8] = s[8];
	case 8:		d[7] = s[7];
	case 7:		d[6] = s[6];
	case 6:		d[5] = s[5];
	case 5:		d[4] = s[4];
	case 4:		d[3] = s[3];
	case 3:		d[2] = s[2];
	case 2:		d[1] = s[1];
	case 1:		d[0] = s[0];
d282 15
a296 15
	case 15:	d[0] = s[0];
	case 14:	d[1] = s[1];
	case 13:	d[2] = s[2];
	case 12:	d[3] = s[3];
	case 11:	d[4] = s[4];
	case 10:	d[5] = s[5];
	case 9:		d[6] = s[6];
	case 8:		d[7] = s[7];
	case 7:		d[8] = s[8];
	case 6:		d[9] = s[9];
	case 5:		d[10] = s[10];
	case 4:		d[11] = s[11];
	case 3:		d[12] = s[12];
	case 2:		d[13] = s[13];
	case 1:		d[14] = s[14];
d324 7
a330 7
		case 7:		d[6] = s[6];
		case 6:		d[5] = s[5];
		case 5:		d[4] = s[4];
		case 4:		d[3] = s[3];
		case 3:		d[2] = s[2];
		case 2:		d[1] = s[1];
		case 1:		d[0] = s[0];
d338 7
a344 7
		case 7:		d[6] = s[6];
		case 6:		d[5] = s[5];
		case 5:		d[4] = s[4];
		case 4:		d[3] = s[3];
		case 3:		d[2] = s[2];
		case 2:		d[1] = s[1];
		case 1:		d[0] = s[0];
d372 15
a386 15
		case 15:	d[14] = s[14];
		case 14:	d[13] = s[13];
		case 13:	d[12] = s[12];
		case 12:	d[11] = s[11];
		case 11:	d[10] = s[10];
		case 10:	d[9] = s[9];
		case 9:		d[8] = s[8];
		case 8:		d[7] = s[7];
		case 7:		d[6] = s[6];
		case 6:		d[5] = s[5];
		case 5:		d[4] = s[4];
		case 4:		d[3] = s[3];
		case 3:		d[2] = s[2];
		case 2:		d[1] = s[1];
		case 1:		d[0] = s[0];
d417 7
a423 7
			case 7:		d[1] = s[1];
			case 6:		d[2] = s[2];
			case 5:		d[3] = s[3];
			case 4:		d[4] = s[4];
			case 3:		d[5] = s[5];
			case 2:		d[6] = s[6];
			case 1:		d[7] = s[7];
d427 3
a429 3
			case 3:		d[1] = s[1];
			case 2:		d[2] = s[2];
			case 1:		d[3] = s[3];
d433 1
a433 1
			case 1:		d[1] = s[1];
d448 7
a454 7
		case 7:		d[0] = s[0];
		case 6:		d[1] = s[1];
		case 5:		d[2] = s[2];
		case 4:		d[3] = s[3];
		case 3:		d[4] = s[4];
		case 2:		d[5] = s[5];
		case 1:		d[6] = s[6];
d458 3
a460 3
		case 3:		d[0] = s[0];
		case 2:		d[1] = s[1];
		case 1:		d[2] = s[2];
d464 1
a464 1
		case 1:		d[0] = s[0];
d495 15
a509 15
		case 15:	d[0] = s[0];
		case 14:	d[1] = s[1];
		case 13:	d[2] = s[2];
		case 12:	d[3] = s[3];
		case 11:	d[4] = s[4];
		case 10:	d[5] = s[5];
		case 9:		d[6] = s[6];
		case 8:		d[7] = s[7];
		case 7:		d[8] = s[8];
		case 6:		d[9] = s[9];
		case 5:		d[10] = s[10];
		case 4:		d[11] = s[11];
		case 3:		d[12] = s[12];
		case 2:		d[13] = s[13];
		case 1:		d[14] = s[14];
d552 15
a566 15
	case 15:	if (blk[14] == c) ++nlines;
	case 14:	if (blk[13] == c) ++nlines;
	case 13:	if (blk[12] == c) ++nlines;
	case 12:	if (blk[11] == c) ++nlines;
	case 11:	if (blk[10] == c) ++nlines;
	case 10:	if (blk[9] == c) ++nlines;
	case 9:		if (blk[8] == c) ++nlines;
	case 8:		if (blk[7] == c) ++nlines;
	case 7:		if (blk[6] == c) ++nlines;
	case 6:		if (blk[5] == c) ++nlines;
	case 5:		if (blk[4] == c) ++nlines;
	case 4:		if (blk[3] == c) ++nlines;
	case 3:		if (blk[2] == c) ++nlines;
	case 2:		if (blk[1] == c) ++nlines;
	case 1:		if (blk[0] == c) ++nlines;
@


1.3
log
@begin const cleanup
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/blocks.c,v 1.2 2008/05/13 13:08:21 tg Exp $ */
a570 28

#ifdef junk

unsigned char *mchr(blk, c)
register unsigned char *blk, c;
{
    loop:
	if (blk[0] == c) return blk + 0;
	if (blk[1] == c) return blk + 1;
	if (blk[2] == c) return blk + 2;
	if (blk[3] == c) return blk + 3;
	if (blk[4] == c) return blk + 4;
	if (blk[5] == c) return blk + 5;
	if (blk[6] == c) return blk + 6;
	if (blk[7] == c) return blk + 7;
	if (blk[8] == c) return blk + 8;
	if (blk[9] == c) return blk + 9;
	if (blk[10] == c) return blk + 10;
	if (blk[11] == c) return blk + 11;
	if (blk[12] == c) return blk + 12;
	if (blk[13] == c) return blk + 13;
	if (blk[14] == c) return blk + 14;
	if (blk[15] == c) return blk + 15;
	blk += 15;
	goto loop;
}

#endif
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d195 1
a195 1
static int *mbkwdI(void *dest, void *src, int sz)
d198 1
a198 1
	int	*s = src;
d250 1
a250 1
static int *mfwrdI(void *dest, void *src, int sz)
d253 1
a253 1
	int	*s = src;
d307 1
a307 1
static unsigned char *mbkwd(register unsigned char *d, register unsigned char *s, register int sz)
d398 1
a398 1
static unsigned char *mfwrd(register unsigned char *d, register unsigned char *s, register int sz)
d516 1
a516 1
void *mmove(void *d, void *s, int sz)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 14
a14 2
/* Fast block move/copy subroutines
   Copyright (C) 1992 Joseph H. Allen
d16 7
a22 1
This file is part of JOE (Joe's Own Editor)
d24 2
a25 17
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

/* Take a look at the configuration information in config.h */
/* This module requires that AUTOINC, ALIGNED, ISIZ, SHFT and BITS be defined
 * correctly
 */
d27 45
a71 1
#include "blocks.h"
d76 44
a119 56
int *msetI(d,c,sz)
register int *d, c;
register int sz;
 {
 int *orgd=d;
 while(sz>=16)
  {
#ifdef AUTOINC
  *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c;
  *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c; *d++=c;
#else
  d[0]=c; d[1]=c; d[2]=c; d[3]=c; d[4]=c; d[5]=c; d[6]=c; d[7]=c;
  d[8]=c; d[9]=c; d[10]=c; d[11]=c; d[12]=c; d[13]=c; d[14]=c; d[15]=c;
  d+=16;
#endif
  sz-=16;
  }
 switch(sz)
  {
#ifdef AUTOINC
 case 15: *d++=c;
 case 14: *d++=c;
 case 13: *d++=c;
 case 12: *d++=c;
 case 11: *d++=c;
 case 10: *d++=c;
 case 9: *d++=c;
 case 8: *d++=c;
 case 7: *d++=c;
 case 6: *d++=c;
 case 5: *d++=c;
 case 4: *d++=c;
 case 3: *d++=c;
 case 2: *d++=c;
 case 1: *d++=c;
#else
 case 15: d[14]=c;
 case 14: d[13]=c;
 case 13: d[12]=c;
 case 12: d[11]=c;
 case 11: d[10]=c;
 case 10: d[9]=c;
 case 9: d[8]=c;
 case 8: d[7]=c;
 case 7: d[6]=c;
 case 6: d[5]=c;
 case 5: d[4]=c;
 case 4: d[3]=c;
 case 3: d[2]=c;
 case 2: d[1]=c;
 case 1: d[0]=c;
#endif
 case 0:;
  }
 return orgd;
 }
d124 66
a189 108
char *mset(d,c,sz)
register char *d;
register unsigned char c;
register int sz;
 {
 char *orgd=d;
 if(sz<16)
  switch(sz)
   {
#ifdef AUTOINC
   case 15: *d++=c;
   case 14: *d++=c;
   case 13: *d++=c;
   case 12: *d++=c;
   case 11: *d++=c;
   case 10: *d++=c;
   case 9: *d++=c;
   case 8: *d++=c;
   case 7: *d++=c;
   case 6: *d++=c;
   case 5: *d++=c;
   case 4: *d++=c;
   case 3: *d++=c;
   case 2: *d++=c;
   case 1: *d++=c;
#else
   case 15: d[14]=c;
   case 14: d[13]=c;
   case 13: d[12]=c;
   case 12: d[11]=c;
   case 11: d[10]=c;
   case 10: d[9]=c;
   case 9: d[8]=c;
   case 8: d[7]=c;
   case 7: d[6]=c;
   case 6: d[5]=c;
   case 5: d[4]=c;
   case 4: d[3]=c;
   case 3: d[2]=c;
   case 2: d[1]=c;
   case 1: d[0]=c;
#endif
   case 0:;
   }
 else
  {
  int z=ISIZ-((int)d&(ISIZ-1));
  if(z!=ISIZ)
   switch(z)
    {
#ifdef AUTOINC
   case 7: *d++=c;
   case 6: *d++=c;
   case 5: *d++=c;
   case 4: *d++=c;
   case 3: *d++=c;
   case 2: *d++=c;
   case 1: *d++=c;
   case 0:;
#else
   case 7: d[6]=c;
   case 6: d[5]=c;
   case 5: d[4]=c;
   case 4: d[3]=c;
   case 3: d[2]=c;
   case 2: d[1]=c;
   case 1: d[0]=c;
   case 0:;
           d+=z;
#endif
    sz-=z;
    }
  msetI(d,
#if ISIZ>=8
  (c<<(BITS*7))+(c<<(BITS*6))+(c<<(BITS*5))+(c<<(BITS*4))+
#endif
#if ISIZ>=4
  (c<<(BITS*3))+(c<<(BITS*2))+
#endif
#if ISIZ>=2
  (c<<BITS)+
#endif
  c,sz>>SHFT);
  d+=sz&~(ISIZ-1);
  switch(sz&(ISIZ-1))
   {
#ifdef AUTOINC
  case 7: *d++=c;
  case 6: *d++=c;
  case 5: *d++=c;
  case 4: *d++=c;
  case 3: *d++=c;
  case 2: *d++=c;
  case 1: *d++=c;
#else
  case 7: d[6]=c;
  case 6: d[5]=c;
  case 5: d[4]=c;
  case 4: d[3]=c;
  case 3: d[2]=c;
  case 2: d[1]=c;
  case 1: d[0]=c;
#endif
  case 0:;
   }
  }
 return orgd;
 }
d194 52
a245 62
static int *mbkwdI(d,s,sz)
register int *d, *s;
register int sz;
 {
 if(d==s) return d;
 d+=sz; s+=sz;
 while(sz>=16)
  {
#ifdef AUTOINC
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; 
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s; 
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
#else
  d-=16; s-=16;
  d[15]=s[15]; d[14]=s[14]; d[13]=s[13]; d[12]=s[12]; d[11]=s[11]; d[10]=s[10];
  d[9]=s[9]; d[8]=s[8]; d[7]=s[7]; d[6]=s[6]; d[5]=s[5]; d[4]=s[4]; d[3]=s[3];
  d[2]=s[2]; d[1]=s[1]; d[0]=s[0];
#endif
  sz-=16;
  }
#ifndef AUTOINC
  d-=sz; s-=sz;
#endif
 switch(sz)
  {
#ifdef AUTOINC
  case 15: *--d= *--s;
  case 14: *--d= *--s;
  case 13: *--d= *--s;
  case 12: *--d= *--s;
  case 11: *--d= *--s;
  case 10: *--d= *--s;
  case 9: *--d= *--s;
  case 8: *--d= *--s;
  case 7: *--d= *--s;
  case 6: *--d= *--s;
  case 5: *--d= *--s;
  case 4: *--d= *--s;
  case 3: *--d= *--s;
  case 2: *--d= *--s;
  case 1: *--d= *--s;
#else
  case 15: d[14]=s[14];
  case 14: d[13]=s[13];
  case 13: d[12]=s[12];
  case 12: d[11]=s[11];
  case 11: d[10]=s[10];
  case 10: d[9]=s[9];
  case 9: d[8]=s[8];
  case 8: d[7]=s[7];
  case 7: d[6]=s[6];
  case 6: d[5]=s[5];
  case 5: d[4]=s[4];
  case 4: d[3]=s[3];
  case 3: d[2]=s[2];
  case 2: d[1]=s[1];
  case 1: d[0]=s[0];
#endif
  case 0:;
  }
 return d;
 }
d249 51
a299 63
static int *mfwrdI(d,s,sz)
register int *d, *s;
register int sz;
 {
 int *od=d;
 if(s==d) return d;
 while(sz>=16)
  {
#ifdef AUTOINC
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
#else
  d[0]=s[0]; d[1]=s[1]; d[2]=s[2]; d[3]=s[3]; d[4]=s[4]; d[5]=s[5]; d[6]=s[6];
  d[7]=s[7]; d[8]=s[8]; d[9]=s[9]; d[10]=s[10]; d[11]=s[11]; d[12]=s[12];
  d[13]=s[13]; d[14]=s[14]; d[15]=s[15];
  s+=16; d+=16;
#endif
  sz-=16;
  }
#ifndef AUTOINC
 s-=15-sz; d-=15-sz;
#endif
 switch(sz)
  {
#ifdef AUTOINC
  case 15: *d++= *s++;
  case 14: *d++= *s++;
  case 13: *d++= *s++;
  case 12: *d++= *s++;
  case 11: *d++= *s++;
  case 10: *d++= *s++;
  case 9: *d++= *s++;
  case 8: *d++= *s++;
  case 7: *d++= *s++;
  case 6: *d++= *s++;
  case 5: *d++= *s++;
  case 4: *d++= *s++;
  case 3: *d++= *s++;
  case 2: *d++= *s++;
  case 1: *d++= *s++;
#else
  case 15: d[0]=s[0];
  case 14: d[1]=s[1];
  case 13: d[2]=s[2];
  case 12: d[3]=s[3];
  case 11: d[4]=s[4];
  case 10: d[5]=s[5];
  case 9: d[6]=s[6];
  case 8: d[7]=s[7];
  case 7: d[8]=s[8];
  case 6: d[9]=s[9];
  case 5: d[10]=s[10];
  case 4: d[11]=s[11];
  case 3: d[12]=s[12];
  case 2: d[13]=s[13];
  case 1: d[14]=s[14];
#endif
  case 0:;
  }
 return od;
 }
d304 1
a304 1
 */ 
d306 6
a311 6
char *mbkwd(d,s,sz)
register char *d, *s;
register int sz;
 {
 if(s==d) return d;
 s+=sz; d+=sz;
d313 1
a313 1
 if( sz>=16 )
d315 1
a315 1
 if( ((int)s&(ISIZ-1))==((int)d&(ISIZ-1)) && sz>=16)
d317 74
a390 115
  {
  int z=((int)s&(ISIZ-1));
#ifndef AUTOINC
  s-=z; d-=z;
#endif
  switch(z)
   {
#ifdef AUTOINC
   case 7: *--d= *--s;
   case 6: *--d= *--s;
   case 5: *--d= *--s;
   case 4: *--d= *--s;
   case 3: *--d= *--s;
   case 2: *--d= *--s;
   case 1: *--d= *--s;
#else
   case 7: d[6]=s[6];
   case 6: d[5]=s[5];
   case 5: d[4]=s[4];
   case 4: d[3]=s[3];
   case 3: d[2]=s[2];
   case 2: d[1]=s[1];
   case 1: d[0]=s[0];
#endif
   case 0:;
   }
  sz-=z;
  mbkwdI(d-(sz&~(ISIZ-1)),s-(sz&~(ISIZ-1)),sz>>SHFT);
#ifndef AUTOINC
  d-=sz; s-=sz;
#else
  d-=(sz&~(ISIZ-1)); s-=(sz&~(ISIZ-1));
#endif
  switch(sz&(ISIZ-1))
   {
#ifdef AUTOINC
   case 7: *--d= *--s;
   case 6: *--d= *--s;
   case 5: *--d= *--s;
   case 4: *--d= *--s;
   case 3: *--d= *--s;
   case 2: *--d= *--s;
   case 1: *--d= *--s;
#else
   case 7: d[6]=s[6];
   case 6: d[5]=s[5];
   case 5: d[4]=s[4];
   case 4: d[3]=s[3];
   case 3: d[2]=s[2];
   case 2: d[1]=s[1];
   case 1: d[0]=s[0];
#endif
   case 0:;
   }
  }
 else
  {
  while(sz>=16)
   {
#ifdef AUTOINC
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
  *--d= *--s; *--d= *--s; *--d= *--s; *--d= *--s;
#else
   d-=16; s-=16;
   d[15]=s[15]; d[14]=s[14]; d[13]=s[13]; d[12]=s[12]; d[11]=s[11]; d[10]=s[10];
   d[9]=s[9]; d[8]=s[8]; d[7]=s[7]; d[6]=s[6]; d[5]=s[5]; d[4]=s[4]; d[3]=s[3];
   d[2]=s[2]; d[1]=s[1]; d[0]=s[0];
#endif
   sz-=16;
   }
#ifndef AUTOINC
  d-=sz; s-=sz;
#endif
  switch(sz)
   {
#ifdef AUTOINC
   case 15: *--d= *--s;
   case 14: *--d= *--s;
   case 13: *--d= *--s;
   case 12: *--d= *--s;
   case 11: *--d= *--s;
   case 10: *--d= *--s;
   case 9: *--d= *--s;
   case 8: *--d= *--s;
   case 7: *--d= *--s;
   case 6: *--d= *--s;
   case 5: *--d= *--s;
   case 4: *--d= *--s;
   case 3: *--d= *--s;
   case 2: *--d= *--s;
   case 1: *--d= *--s;
#else
   case 15: d[14]=s[14];
   case 14: d[13]=s[13];
   case 13: d[12]=s[12];
   case 12: d[11]=s[11];
   case 11: d[10]=s[10];
   case 10: d[9]=s[9];
   case 9: d[8]=s[8];
   case 8: d[7]=s[7];
   case 7: d[6]=s[6];
   case 6: d[5]=s[5];
   case 5: d[4]=s[4];
   case 4: d[3]=s[3];
   case 3: d[2]=s[2];
   case 2: d[1]=s[1];
   case 1: d[0]=s[0];
#endif
   case 0:;
   }
  }
 return d;
 }
d395 1
a395 1
 */ 
d397 6
a402 6
char *mfwrd(d,s,sz)
register char *d, *s;
register int sz;
 {
 char *od=d;
 if(d==s) return d;
d404 1
a404 1
 if(sz>=16)
d406 1
a406 1
 if( ((int)d&(ISIZ-1))==((int)s&(ISIZ-1)) && sz>=16 )
d408 115
a522 160
  {
  int z=((int)s&(ISIZ-1));
  if(z)
   {
#ifndef AUTOINC
   s-=z; d-=z;
   switch(ISIZ-z)
    {
#if ISIZ==8
    case 7: d[1]=s[1];
    case 6: d[2]=s[2];
    case 5: d[3]=s[3];
    case 4: d[4]=s[4];
    case 3: d[5]=s[5];
    case 2: d[6]=s[6];
    case 1: d[7]=s[7];
    case 0:;
#else
#if ISIZ==4
    case 3: d[1]=s[1];
    case 2: d[2]=s[2];
    case 1: d[3]=s[3];
    case 0:;
#else
#if ISIZ==2
    case 1: d[1]=s[1];
    case 0:;
#endif
#endif
#endif
    }
   s+=ISIZ; d+=ISIZ;
#else
   switch(ISIZ-z)
    {
    case 7: *d++= *s++;
    case 6: *d++= *s++;
    case 5: *d++= *s++;
    case 4: *d++= *s++;
    case 3: *d++= *s++;
    case 2: *d++= *s++;
    case 1: *d++= *s++;
    case 0:;
    }
#endif
   sz-=ISIZ-z;
   }
  mfwrdI(d,s,sz>>SHFT);
#ifdef AUTOINC
  s+=(sz&~(ISIZ-1)); d+=(sz&~(ISIZ-1));
  switch(sz&(ISIZ-1))
   {
   case 7: *d++= *s++;
   case 6: *d++= *s++;
   case 5: *d++= *s++;
   case 4: *d++= *s++;
   case 3: *d++= *s++;
   case 2: *d++= *s++;
   case 1: *d++= *s++;
   case 0:;
   }
#else
  s+=sz-(ISIZ-1); d+=sz-(ISIZ-1);
  switch(sz&(ISIZ-1))
   {
#if ISIZ==8
  case 7: d[0]=s[0];
  case 6: d[1]=s[1];
  case 5: d[2]=s[2];
  case 4: d[3]=s[3];
  case 3: d[4]=s[4];
  case 2: d[5]=s[5];
  case 1: d[6]=s[6];
  case 0:;
#else
#if ISIZ==4
   case 3: d[0]=s[0];
   case 2: d[1]=s[1];
   case 1: d[2]=s[2];
   case 0:;
#else
#if ISIZ==2
   case 1: d[0]=s[0];
   case 0:;
#endif
#endif
#endif
   }
#endif
  }
 else
  {
  while(sz>=16)
   {
#ifdef AUTOINC
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
  *d++= *s++; *d++= *s++; *d++= *s++; *d++= *s++;
#else
   d[0]=s[0]; d[1]=s[1]; d[2]=s[2]; d[3]=s[3]; d[4]=s[4]; d[5]=s[5]; d[6]=s[6];
   d[7]=s[7]; d[8]=s[8]; d[9]=s[9]; d[10]=s[10]; d[11]=s[11]; d[12]=s[12];
   d[13]=s[13]; d[14]=s[14]; d[15]=s[15];
   s+=16; d+=16;
#endif
   sz-=16;
   }
#ifndef AUTOINC
  s-=15-sz; d-=15-sz;
#endif
  switch(sz)
   {
#ifdef AUTOINC
  case 15: *d++= *s++;
  case 14: *d++= *s++;
  case 13: *d++= *s++;
  case 12: *d++= *s++;
  case 11: *d++= *s++;
  case 10: *d++= *s++;
  case 9: *d++= *s++;
  case 8: *d++= *s++;
  case 7: *d++= *s++;
  case 6: *d++= *s++;
  case 5: *d++= *s++;
  case 4: *d++= *s++;
  case 3: *d++= *s++;
  case 2: *d++= *s++;
  case 1: *d++= *s++;
  case 0:;
#else
   case 15: d[0]=s[0];
   case 14: d[1]=s[1];
   case 13: d[2]=s[2];
   case 12: d[3]=s[3];
   case 11: d[4]=s[4];
   case 10: d[5]=s[5];
   case 9: d[6]=s[6];
   case 8: d[7]=s[7];
   case 7: d[8]=s[8];
   case 6: d[9]=s[9];
   case 5: d[10]=s[10];
   case 4: d[11]=s[11];
   case 3: d[12]=s[12];
   case 2: d[13]=s[13];
   case 1: d[14]=s[14];
   case 0:;
#endif
   }
  }
 return od;
 }

char *mmove(d,s,sz)
char *d, *s;
int sz;
 {
 if(d>s) mbkwd(d,s,sz);
 else mfwrd(d,s,sz);
 return d;
 }
d526 44
a569 46
int mcnt(blk,c,size)
register char *blk,c;
int size;
 {
 register int nlines=0;
 while(size>=16)
  {
  if(blk[0]==c) ++nlines;
  if(blk[1]==c) ++nlines;
  if(blk[2]==c) ++nlines;
  if(blk[3]==c) ++nlines;
  if(blk[4]==c) ++nlines;
  if(blk[5]==c) ++nlines;
  if(blk[6]==c) ++nlines;
  if(blk[7]==c) ++nlines;
  if(blk[8]==c) ++nlines;
  if(blk[9]==c) ++nlines;
  if(blk[10]==c) ++nlines;
  if(blk[11]==c) ++nlines;
  if(blk[12]==c) ++nlines;
  if(blk[13]==c) ++nlines;
  if(blk[14]==c) ++nlines;
  if(blk[15]==c) ++nlines;
  blk+=16; size-=16;
  }
 switch(size)
  {
  case 15: if(blk[14]==c) ++nlines;
  case 14: if(blk[13]==c) ++nlines;
  case 13: if(blk[12]==c) ++nlines;
  case 12: if(blk[11]==c) ++nlines;
  case 11: if(blk[10]==c) ++nlines;
  case 10: if(blk[9]==c) ++nlines;
  case 9: if(blk[8]==c) ++nlines;
  case 8: if(blk[7]==c) ++nlines;
  case 7: if(blk[6]==c) ++nlines;
  case 6: if(blk[5]==c) ++nlines;
  case 5: if(blk[4]==c) ++nlines;
  case 4: if(blk[3]==c) ++nlines;
  case 3: if(blk[2]==c) ++nlines;
  case 2: if(blk[1]==c) ++nlines;
  case 1: if(blk[0]==c) ++nlines;
  case 0:;
  }
 return nlines;
 }
d573 23
a595 22
char *mchr(blk,c)
register char *blk, c;
 {
 loop:
  if(blk[0]==c) return blk+0;
  if(blk[1]==c) return blk+1;
  if(blk[2]==c) return blk+2;
  if(blk[3]==c) return blk+3;
  if(blk[4]==c) return blk+4;
  if(blk[5]==c) return blk+5;
  if(blk[6]==c) return blk+6;
  if(blk[7]==c) return blk+7;
  if(blk[8]==c) return blk+8;
  if(blk[9]==c) return blk+9;
  if(blk[10]==c) return blk+10;
  if(blk[11]==c) return blk+11;
  if(blk[12]==c) return blk+12;
  if(blk[13]==c) return blk+13;
  if(blk[14]==c) return blk+14;
  if(blk[15]==c) return blk+15;
 blk+=15; goto loop;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
