head	1.14;
access;
symbols
	joe-3_1jupp38:1.14
	joe-3_1jupp37:1.14
	joe-3_1jupp36:1.14
	joe-3_1jupp35:1.14
	joe-3_1jupp34:1.14
	joe-3_1jupp33:1.14
	joe-3_1jupp32:1.9
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.3
	joe-3_1jupp30:1.3
	joe-3_1jupp29:1.3
	joe-3_1jupp28:1.3
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.14
date	2018.01.07.17.24.49;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A5257E37ACEAAEF;

1.13
date	2018.01.07.16.58.13;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A5251B95619CA29;

1.12
date	2018.01.06.17.07.06;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A51025239AC32D0;

1.11
date	2017.12.20.22.29.02;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A3AE4405E8147ED;

1.10
date	2017.12.20.22.23.57;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A3AE3165F64C32F;

1.9
date	2017.12.08.02.28.07;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A29F8C708B176AB;

1.8
date	2017.12.08.02.00.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A29F2506E789D2B;

1.7
date	2017.12.06.23.17.36;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A287AA407E73F9C;

1.6
date	2017.12.06.23.02.07;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A2876FC4FFE7EF5;

1.5
date	2017.12.06.21.17.02;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A285E5918D423C7;

1.4
date	2017.12.02.02.07.35;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005A220AD65C90E687;

1.3
date	2010.04.08.15.31.05;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004BBDF6C54CC9A0DB;

1.2
date	2008.05.13.13.08.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@reorient the screen from column 0 on format, fmtblk, retype

allows us to get rid of the fmtln macro hack for jupp
@
text
@/*
 *	User text formatting functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.11 2017/12/20 22:29:02 tg Exp $");

#include <stdlib.h>
#include <string.h>

#include "b.h"
#include "ublock.h"
#include "uformat.h"
#include "charmap.h"
#include "utils.h"

/* Center line cursor is on and move cursor to beginning of next line */

int
ucenter(BW *bw)
{
	P *p = bw->cursor, *q;
	long endcol, begcol, x;
	int c;

	p_goto_eol(p);
	while (joe_isblank(bw->b->o.charmap, (c = prgetc(p))))
		/* do nothing */;
	if (c == '\n') {
		pgetc(p);
		goto done;
	}
	if (c == NO_MORE_DATA)
		goto done;
	pgetc(p);
	endcol = piscol(p);

	p_goto_bol(p);
	while (joe_isblank(bw->b->o.charmap, (c = pgetc(p))))
		/* do nothing */;
	if (c == '\n') {
		prgetc(p);
		goto done;
	}
	if (c == NO_MORE_DATA)
		goto done;
	prgetc(p);
	begcol = piscol(p);

	if (endcol - begcol > bw->o.rmargin + bw->o.lmargin)
		goto done;

	q = pdup(p);
	p_goto_bol(q);
	bdel(q, p);
	prm(q);

	for (x = 0; x != (bw->o.lmargin + bw->o.rmargin) / 2 - (endcol - begcol) / 2; ++x)
		binsc(p, ' ');

 done:
	if (!pnextl(p)) {
		binsc(p, '\n');
		pgetc(p);
		return -1;
	} else
		return 0;
}

/* Return true if c is a character which can indent a paragraph */

static int
cpara(int c)
{
	if (c == '\t' ||
	    (c >= ' ' && c <= '&' && c != '"') ||
	    (c >= /*(*/ ')' && c <= '/') ||
	    (c >= ':' && c <= '@@' && c != '<') ||
	    (c >= '\\' && c <= '_') ||
	    (c >= '|' && c <= '~'))
		return 1;
	else
		return 0;
}

/* Return true if line is definitly not a paragraph line.
 * Lines which aren't paragraph lines:
 *  1) Blank lines
 *  2) Lines which begin with '.'
 */

static int
pisnpara(P *p)
{
	P *q;
	int c;

	q = pdup(p);
	p_goto_bol(q);
	while (cpara(c = pgetc(q)))
		/* do nothing */;
	prm(q);
	if (c == '.' || c == '\r' || c == '\n')
		return 1;
	else
		return 0;
}

/* Determine amount of indentation on current line */

static long
nindent(P *p)
{
	P *q = pdup(p);
	long col;

	p_goto_bol(q);
	do {
		col = q->col;
	} while (cpara(pgetc(q)));
	prm(q);
	return col;
}

/* Get indentation prefix column */

static long
prefix(P *p)
{
	long len;
	P *q = pdup(p);

	p_goto_bol(q);
	while (cpara(brch(q)))
		pgetc(q);
	while (!pisbol(q))
		if (!joe_isblank(p->b->o.charmap, prgetc(q))) {
			pgetc(q);
			break;
		}
	len = q->col;
	prm(q);
	return len;
}

/* Move pointer to beginning of paragraph
 *
 * This function simply moves backwards until it sees:
 *  0) The beginning of the file
 *  1) A blank line
 *  2) A line with a different indentation prefix
 *  3) A line with indentation greater than that of the line we started with
 *  4) A line with indentation less than that of the starting line, but with
 *     a blank line (or beginning of file) preceeding it.
 */

static char within = 0;

P *
pbop(P *p)
{
	long indent;
	long prelen;

	p_goto_bol(p);
	indent = nindent(p);
	prelen = prefix(p);
	while (!pisbof(p) && (!within || !markb || p->byte > markb->byte)) {
		long ind;
		long len;

		pprevl(p);
		p_goto_bol(p);
		ind = nindent(p);
		len = prefix(p);
		if (pisnpara(p) || len != prelen) {
			pnextl(p);
			break;
		}
		if (ind > indent)
			break;
		if (ind < indent) {
			if (pisbof(p))
				break;
			pprevl(p);
			p_goto_bol(p);
			if (pisnpara(p)) {
				pnextl(p);
				break;
			} else {
				pnextl(p);
				pnextl(p);
				break;
			}
		}
	}
	return p;
}

/* Move pointer to end of paragraph.  Pointer must already be on first
 * line of paragraph for this to work correctly.
 *
 * This function moves forwards until it sees:
 *  0) The end of the file.
 *  1) A blank line
 *  2) A line with indentation different from the second line of the paragraph
 *  3) A line with prefix column different from first line
 */

P *
peop(P *p)
{
	long indent;
	long prelen;

	if (!pnextl(p) || pisnpara(p) || (within && markk && p->byte >= markk->byte))
		return p;
	indent = nindent(p);
	prelen = prefix(p);
	while (pnextl(p) && (!within || !markk || p->byte < markk->byte)) {
		long ind = nindent(p);
		long len = prefix(p);

		if (ind != indent || len != prelen || pisnpara(p))
			break;
	}
	return p;
}

/* Motion commands */

int
ubop(BW *bw)
{
	P *q = pdup(bw->cursor);

 up:
	while (pisnpara(q) && !pisbof(q) && (!within || !markb || q->byte > markb->byte))
		pprevl(q);
	pbop(q);
	if (q->byte != bw->cursor->byte) {
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else if (!pisbof(q)) {
		prgetc(q);
		goto up;
	} else {
		prm(q);
		return -1;
	}
}

int
ueop(BW *bw)
{
	P *q = pdup(bw->cursor);

 up:
	while (pisnpara(q) && !piseof(q))
		pnextl(q);
	pbop(q);
	peop(q);
	if (q->byte != bw->cursor->byte) {
		pset(bw->cursor, q);
		prm(q);
		return 0;
	} else if (!piseof(q)) {
		pnextl(q);
		goto up;
	} else {
		prm(q);
		return -1;
	}
}

/* Wrap word.  If 'french' is set, only one space will be placed
 * after . ? or !
 */

void
wrapword(P *p, long int indent, int french, unsigned char *indents)
{
	P *q;
	int c;
	long to = p->byte;

	/* Get to beginning of word */
	while (!pisbol(p) && piscol(p) > indent && !joe_isblank(p->b->o.charmap, prgetc(p)))
		/* do nothing */;

	/* If we found the beginning of a word... */
	if (!pisbol(p) && piscol(p) > indent) {
		/* Move q to two (or one if 'french' is set) spaces after end of previous
		   word */
		q = pdup(p);
		while (!pisbol(q))
			if (!joe_isblank(p->b->o.charmap, (c = prgetc(q)))) {
				pgetc(q);
				if ((c == '.' || c == '?' || c == '!')
				    && q->byte != p->byte && !french)
					pgetc(q);
				break;
			}
		pgetc(p);

		/* Delete space between start of word and end of previous word */
		to -= p->byte - q->byte;
		bdel(q, p);
		prm(q);

		/* Move word to beginning of next line */
		binsc(p, '\n');
		++to;
		if (p->b->o.crlf)
			++to;
		pgetc(p);

		/* Indent to left margin */
		if (indents) {
			binss(p, indents);
			to += strlen((char *)indents);
		} else
			while (indent--) {
				binsc(p, ' ');
				++to;
			}
	}

	/* Move cursor back to original position */
	pfwrd(p, to - p->byte);
}

/* Reformat paragraph */

int
uformat(BW *bw)
{
	long indent;
	unsigned char *indents;
	B *buf;
	P *b;
	long curoff;
	int c;
	P *p, *q;

	p = pdup(bw->cursor);
	p_goto_bol(p);

	/* Do nothing if we're not on a paragraph line */
	if (pisnpara(p)) {
		prm(p);
		return 0;
	}

	/* Move p to beginning of paragraph, bw->cursor to end of paragraph and
	 * set curoff to original cursor offset within the paragraph */
	pbop(p);
	curoff = bw->cursor->byte - p->byte;
	pset(bw->cursor, p);
	peop(bw->cursor);

	/* Ensure that paragraph ends on a beginning of a line */
	if (!pisbol(bw->cursor))
		binsc(bw->cursor, '\n'), pgetc(bw->cursor);

	/* Record indentation of second line of paragraph, of first line if there
	 * is only one line */
	q = pdup(p);
	pnextl(q);
	if (q->line != bw->cursor->line) {
		P *r = pdup(q);

		indent = nindent(q);
		pcol(r, indent);
		indents = brs(q, r->byte - q->byte);
		prm(r);
	} else {
		P *r = pdup(p);

		indent = nindent(p);
		pcol(r, indent);
		indents = brs(p, r->byte - p->byte);
		prm(r);
	}
	prm(q);

	/* But if the left margin is greater, we use that instead */
	if (bw->o.lmargin > indent)
		indent = bw->o.lmargin;

	/* Cut paragraph into new buffer */

	/* New buffer needs to inherit UTF-8 and CR-LF options */
	buf = bcpy(p, bw->cursor);
	buf->o.crlf = p->b->o.crlf;
	buf->o.charmap = p->b->o.charmap;
	bdel(p, bw->cursor);

	/* text is in buffer.  insert it at cursor */

	/* Do first line */
	b = pdup(buf->bof);

	while (!piseof(b)) {
		/* Set cursor position if we're at original offset */
		if (b->byte == curoff)
			pset(bw->cursor, p);

		/* Get character from buffer */
		c = pgetc(b);

		/* Stop if we found end of line */
		if (c == '\n') {
			prgetc(b);
			break;
		}

		/* Stop if we found white-space followed by end of line */
		if (joe_isblank(b->b->o.charmap, c) && piseolblank(b))
			break;

		/* Insert character, advance pointer */
		binsc(p, c);
		pgetc(p);

		/* Do word wrap if we reach right margin */
		if (piscol(p) > bw->o.rmargin && !joe_isblank(p->b->o.charmap,c)) {
			wrapword(p, indent, bw->o.french, indents);
			break;
		}
	}

	/* Do rest */

	while (!piseof(b)) {
		c = brch(b);
		if (joe_isblank(b->b->o.charmap,c) || c == '\n') {
			int f = 0;
			P *d;
			int g;

			/* Set f if there are two spaces after . ? or ! instead of one */
			/* (What is c was '\n'?) */
			d=pdup(b);
			g=prgetc(d);
			if (g=='.' || g=='?' || g=='!') {
				pset(d,b);
				pgetc(d);
				if (joe_isspace(bw->b->o.charmap,brch(d)))
					f = 1;
			}
			prm(d);

			/* Skip past the whitespace.  Skip over indentations */
 loop:
			c = brch(b);
			if (c == '\n') {
				if (b->byte == curoff)
					pset(bw->cursor, p);

				pgetc(b);
				while (cpara(c=brch(b))) {
					if (b->byte == curoff)
						pset(bw->cursor, p);
					pgetc(b);
				}
			}

			if (joe_isblank(b->b->o.charmap,c)) {
				if(b->byte == curoff)
					pset(bw->cursor, p);
				pgetc(b);
				goto loop;
			}

			/* Insert proper amount of whitespace */
			if (!piseof(b)) {
				if (f && !bw->o.french)
					binsc(p, ' '), pgetc(p);
				binsc(p, ' ');
				pgetc(p);
			}
		} else {
			/* Insert characters of word and wrap if necessary */
			if (b->byte == curoff)
				pset(bw->cursor, p);

			binsc(p, pgetc(b));
			pgetc(p);
			if (piscol(p) > bw->o.rmargin)
				wrapword(p, indent, bw->o.french, indents);
		}
	}

	binsc(p, '\n');
	prm(p);
	brm(buf);
	free(indents);
	return 0;
}

/* Format entire block */

int
ufmtblk(BW *bw)
{
	P *p;
	long blkend;
	char hasp;

	/* within a selection? */
	if (!(markv(1) && bw->cursor->byte >= markb->byte && bw->cursor->byte <= markk->byte))
		/* no */
		return (uformat(bw));

	/* save current cursor position */
	p = pdup(bw->cursor);
	hasp = 0;
	/* reformat from bottom to top */
	markk->end = 1;
	utomarkk(bw);
	within = 1;
	do {
		/* span current paragraph between bw->cursor->byte and blkend */
		blkend = bw->cursor->byte;
		ubop(bw);
		/* original cursor in betwixt those? */
		if (p->byte > bw->cursor->byte && p->byte < blkend) {
			/* reformat while cursor is in original place */
			pset(bw->cursor, p);
			uformat(bw);
			/* save, to return to it later */
			pset(p, bw->cursor);
			hasp = 1;
			/* but jump back to beginning of paragraph */
			ubop(bw);
		} else
			uformat(bw);
	} while (bw->cursor->byte > markb->byte);
	within = 0;
	markk->end = 0;
	if (lightoff)
		unmark(bw);
	/* restore saved cursor position */
	if (hasp)
		pset(bw->cursor, p);
	prm(p);
	return (0);
}
@


1.13
log
@make ^KD retain the cursor position as well
@
text
@d513 4
d518 3
a520 4
	if (markv(1) && bw->cursor->byte >= markb->byte && bw->cursor->byte <= markk->byte) {
		P *p;
		long blkend;
		char hasp = 0;
d522 20
a541 9
		/* save current cursor position */
		p = pdup(bw->cursor);
		/* reformat from bottom to top */
		markk->end = 1;
		utomarkk(bw);
		within = 1;
		do {
			/* span current paragraph between bw->cursor->byte and blkend */
			blkend = bw->cursor->byte;
d543 11
a553 24
			/* original cursor in betwixt those? */
			if (p->byte > bw->cursor->byte && p->byte < blkend) {
				/* reformat while cursor is in original place */
				pset(bw->cursor, p);
				uformat(bw);
				/* save, to return to it later */
				pset(p, bw->cursor);
				hasp = 1;
				/* but jump back to beginning of paragraph */
				ubop(bw);
			} else
				uformat(bw);
		} while (bw->cursor->byte > markb->byte);
		within = 0;
		markk->end = 0;
		if (lightoff)
			unmark(bw);
		/* restore saved cursor position */
		if (hasp)
			pset(bw->cursor, p);
		prm(p);
	} else
		/* not within a selection */
		uformat(bw);
@


1.12
log
@small cleanups
@
text
@d24 2
a25 1
int ucenter(BW *bw)
d92 1
a92 1
 * Lines which arn't paragraph lines:
d97 2
a98 1
static int pisnpara(P *p)
d116 2
a117 1
static long nindent(P *p)
d132 2
a133 1
static long prefix(P *p)
d164 2
a165 1
P *pbop(P *p)
d215 2
a216 1
P *peop(P *p)
d237 2
a238 1
int ubop(BW *bw)
d259 2
a260 1
int ueop(BW *bw)
d286 2
a287 1
void wrapword(P *p, long int indent, int french, unsigned char *indents)
d341 2
a342 1
int uformat(BW *bw)
d510 2
a511 1
int ufmtblk(BW *bw)
d513 1
d515 7
d526 2
d529 12
a540 1
			uformat(bw);
d546 4
a549 1
		return 0;
d551 3
a553 1
		return uformat(bw);
@


1.11
log
@reduce amount of comparisons (could use a bitmap though)
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.9 2017/12/08 02:28:07 tg Exp $");
d158 1
a158 1
int within = 0;
d507 2
a508 1
			ubop(bw), uformat(bw);
@


1.10
log
@remove dead code
@
text
@d76 2
a77 1
static int cpara(int c)
d79 6
a84 6
	if (c == ' ' || c == '\t' || c == '\\' ||
	    c == '>' || c == '|' || c == ':' || c == '*' || c == '/' ||
	    c == ',' || c == '.' || c == '?' || c == ';' || c == ']' ||
	    c == '}' || c == '=' || c == '+' || c == '-' || c == '_' ||
	    c == ')' || c == '&' || c == '^' || c == '%' || c == '$' ||
	    c == '#' || c == '@@' || c == '!' || c == '~')
@


1.9
log
@label indent; small tweaks while here
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.8 2017/12/08 02:00:42 tg Exp $");
a279 1
	int rmf = 0;
a282 24
	/* Get indentation prefix from beginning of line */
/*
	if(!indents) {
		int f = 0;
		P *r = pdup(p);

		p_goto_bol(r);
		q = pdup(r);
		while(cpara(c = brc(q))) {
			if(!joe_isblank(c))
				f = 1;
			pgetc(q);
		}
		if(f) {
			indents = brs(r, q->byte-r->byte);
			rmf = 1;
			if(indents[0] == '/' && indents[1] == '*')
				indents[0] = ' ';
		}
		prm(r);
		prm(q);
	}
*/

a322 3

		if (rmf)
			free(indents);
@


1.8
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.7 2017/12/06 23:17:36 tg Exp $");
d65 1
a65 1
      done:
d234 1
a234 1
      up:
d255 1
a255 1
      up:
d478 1
a478 2
		      loop:

@


1.7
log
@whitespace at EOL annoys me
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.6 2017/12/06 23:02:07 tg Exp $");
d350 1
a350 1
			joe_free(indents);
d522 1
a522 1
	joe_free(indents);
@


1.6
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.5 2017/12/06 21:17:02 tg Exp $");
d415 1
a415 1
	
d476 1
a476 1
			
d479 1
a479 1
			
@


1.5
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uformat.c,v 1.4 2017/12/02 02:07:35 tg Exp $");
d18 1
@


1.4
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a12 1
#ifdef HAVE_STDLIB_H
a13 2
#endif
#ifdef HAVE_STRING_H
a14 1
#endif
@


1.3
log
@Add --disable-getpwnam and clean up warnings
@
text
@a0 1
/* $MirOS: contrib/code/jupp/uformat.c,v 1.2 2008/05/13 13:08:28 tg Exp $ */
d11 2
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
a529 2
extern int lightoff;

@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* User text formatting functions
   Copyright (C) 1992 Joseph H. Allen
d11 6
a16 1
This file is part of JOE (Joe's Own Editor)
a17 14
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include "config.h"
a18 2
#include "bw.h"
#include "zstr.h"
d20 2
a21 1
#include "uformat.h"
d25 49
a73 34
int ucenter(bw)
BW *bw;
 {
 P *p=bw->cursor, *q;
 long endcol, begcol, x;
 int c;
 
 peol(p);
 while(cwhite(c=prgetc(p)));
 if(c=='\n') { pgetc(p); goto done; }
 if(c==MAXINT) goto done;
 pgetc(p); endcol=piscol(p);
 
 pbol(p);
 while(cwhite(c=pgetc(p)));
 if(c=='\n') { prgetc(p); goto done; }
 if(c==MAXINT) goto done;
 prgetc(p); begcol=piscol(p);
 
 if(endcol-begcol>bw->o.rmargin+bw->o.lmargin) goto done;
 
 q=pdup(p); pbol(q); bdel(q,p); prm(q);
 
 for(x=0;x!=(bw->o.lmargin+bw->o.rmargin)/2-(endcol-begcol)/2;++x) binsc(p,' ');
 
 done:
 if(!pnextl(p))
  {
  binsc(p,'\n');
  pgetc(p);
  return -1;
  }
 else return 0;
 }
d77 12
a88 11
int cpara(c)
 {
 if(c==' ' || c=='\t' || c=='\\' ||
    c=='>' || c=='|' || c==':' || c=='*' || c=='/' || c==',' || c=='.' ||
    c=='?' || c==';' || c==']' || c=='}' || c=='=' || c=='+' || c=='-' ||
    c=='_' || c==')' || c=='&' || c=='^' || c=='%' || c=='$' || c=='#' ||
    c=='@@' || c=='!' || c=='~')
  return 1;
 else
  return 0;
 }
d96 15
a110 12
int pisnpara(p)
P *p;
 {
 P *q;
 int c;
 q=pdup(p);
 pbol(q);
 while(cpara(c=pgetc(q)));
 prm(q);
 if(c=='.' || c=='\r' || c=='\n') return 1;
 else return 0;
 }
d114 12
a125 10
long nindent(p)
P *p;
 {
 P *q=pdup(p);
 long col;
 pbol(q);
 do col=q->col; while(cpara(pgetc(q)));
 prm(q);
 return col;
 }
d129 17
a145 17
long prefix(p)
P *p;
 {
 long len;
 P *q=pdup(p);
 pbol(q);
 while(cpara(brc(q))) pgetc(q);
 while(!pisbol(q))
  if(!cwhite(prgetc(q)))
   {
   pgetc(q);
   break;
   }
 len=q->col;
 prm(q);
 return len;
 }
d158 1
a158 1
int within=0;
d160 39
a198 23
P *pbop(p)
P *p;
 {
 long indent;
 long prelen;
 pbol(p); indent=nindent(p); prelen=prefix(p);
 while(!pisbof(p) && (!within || !markb || p->byte>markb->byte))
  {
  long ind;
  long len;
  pprevl(p); pbol(p); ind=nindent(p); len=prefix(p);
  if(pisnpara(p) || len!=prelen) { pnextl(p); break; }
  if(ind>indent) break;
  if(ind<indent)
   {
   if(pisbof(p)) break;
   pprevl(p); pbol(p);
   if(pisnpara(p)) { pnextl(p); break; }
   else { pnextl(p); pnextl(p); break; }
   }
  }
 return p;
 }
d210 18
a227 17
P *peop(p)
P *p;
 {
 long indent;
 long prelen;
 if(!pnextl(p) || pisnpara(p) ||
    (within && markk && p->byte>=markk->byte)) return p;
 indent=nindent(p);
 prelen=prefix(p);
 while(pnextl(p) && (!within || !markk || p->byte<markk->byte))
  {
  long ind=nindent(p);
  long len=prefix(p);
  if(ind!=indent || len!=prelen || pisnpara(p)) break;
  }
 return p;
 }
d231 42
a272 48
int ubop(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 up: while(pisnpara(q) && !pisbof(q) &&
           (!within || !markb || q->byte>markb->byte)) pprevl(q);
 pbop(q);
 if(q->byte!=bw->cursor->byte)
  {
  pset(bw->cursor,q);
  prm(q);
  return 0;
  }
 else if(!pisbof(q))
  {
  prgetc(q);
  goto up;
  }
 else
  {
  prm(q);
  return -1;
  }
 }

int ueop(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 up: while(pisnpara(q) && !piseof(q)) pnextl(q);
 pbop(q); peop(q);
 if(q->byte!=bw->cursor->byte)
  {
  pset(bw->cursor,q);
  prm(q);
  return 0;
  }
 else if(!piseof(q))
  {
  pnextl(q);
  goto up;
  }
 else
  {
  prm(q);
  return -1;
  }
 }
d278 6
a283 9
void wrapword(p,indent,french,indents)
P *p;
long indent;
char *indents;
 {
 P *q;
 int rmf=0;
 int c;
 long to=p->byte;
d285 1
a285 1
 /* Get indentation prefix from beginning of line */
d287 20
a306 18
 if(!indents)
  {
  int f=0;
  P *r=pdup(p);
  pbol(r);
  q=pdup(r);
  while(cpara(c=brc(q)))
   {
   if(!cwhite(c)) f=1;
   pgetc(q);
   }
  if(f)
   {
   indents=brs(r,q->byte-r->byte); rmf=1;
   if(indents[0]=='/' && indents[1]=='*') indents[0]=' ';
   }
  prm(r); prm(q);
  }
d309 48
a356 38
 /* Get to beginning of word */
 while(!pisbol(p) && piscol(p)>indent && !cwhite(prgetc(p)));

 /* If we found the beginning of a word... */
 if(!pisbol(p) && piscol(p)>indent)
  {
  /* Move q to two (or one if 'french' is set) spaces after end of previous
     word */
  q=pdup(p);
  while(!pisbol(q))
   if(!cwhite(c=prgetc(q)))
    {
    pgetc(q);
    if((c=='.'||c=='?'||c=='!') && q->byte!=p->byte && !french) pgetc(q);
    break;
    }
  pgetc(p);

  /* Delete space between start of word and end of previous word */
  to-=p->byte-q->byte;
  bdel(q,p);
  prm(q);

  /* Move word to beginning of next line */
  binsc(p,'\n'), ++to;
  if(p->b->o.crlf) ++to;
  pgetc(p);

  /* Indent to left margin */
  if(indents) binss(p,indents), to+=zlen(indents);
  else while(indent--) binsc(p,' '), ++to;

  if(rmf) free(indents);
  }

 /* Move cursor back to original position */
 pfwrd(p,to-p->byte);
 }
d360 166
a525 158
int uformat(bw)
BW *bw;
 {
 long indent;
 char *indents;
 char *buf, *b;
 int len;
 long curoff;
 int c;
 P *p, *q;
 p=pdup(bw->cursor); pbol(p);
 
 /* Do nothing if we're not on a paragraph line */
 if(pisnpara(p))
  {
  prm(p);
  return 0;
  }
 
 /* Move p to beginning of paragraph, bw->cursor to end of paragraph and
  * set curoff to original cursor offset within the paragraph */
 pbop(p);
 curoff=bw->cursor->byte-p->byte;
 pset(bw->cursor,p); peop(bw->cursor);
 
 /* Insure that paragraph ends on a beginning of a line */
 if(!pisbol(bw->cursor)) binsc(bw->cursor,'\n'), pgetc(bw->cursor);
 
 /* Record indentation of second line of paragraph, of first line if there
  * is only one line */
 q=pdup(p); pnextl(q);
 if(q->line!=bw->cursor->line)
  {
  P *r=pdup(q);
  indent=nindent(q);
  pcol(r,indent);
  indents=brs(q,r->byte-q->byte);
  prm(r);
  }
 else
  {
  P *r=pdup(p);
  indent=nindent(p);
  pcol(r,indent);
  indents=brs(p,r->byte-p->byte);
  prm(r);
  }
 prm(q);

 /* But if the left margin is greater, we use that instead */
 if(bw->o.lmargin>indent) indent=bw->o.lmargin;
 
 /* Cut paragraph into memory buffer */
 buf=(char *)malloc(len=(bw->cursor->byte-p->byte));
 brmem(p,buf,len);
 bdel(p,bw->cursor);
 
 /* text is in buffer.  insert it at cursor */
 
 /* Do first line */
 b=buf;
 
 while(len--)
  {
  /* Set cursor position if we're at original offset */
  if(b-buf==curoff) pset(bw->cursor,p);

  /* Get character from buffer */
  c= *b++;

  /* Stop if we found end of line */
  if(c=='\n' ||
     c=='\r' && len && *b=='\n') { ++len; --b; break; }

  /* Stop if we found white-space followed by end of line */
  if(cwhite(c))
   {
   char *r=b;
   int rlen=len;
   int z;
   while(rlen--)
    {
    z= *r++;
    if(z=='\n') break;
    if(!cwhite(z)) goto ok;
    }
   ++len; --b; break;
   ok:;
   }

  /* Insert character, advance pointer */
  binsc(p,c); pgetc(p);

  /* Do word wrap if we reach right margin */
  if(piscol(p)>bw->o.rmargin && !cwhite(c))
   {
   wrapword(p,indent,bw->o.french,indents);
   break;
   }
  }
 
 /* Do rest */
 
 while(len>0)
  if(cwhitel(*b) || *b=='\r')
   {
   int f=0;
   /* Set f if there are two spaces after . ? or ! instead of one */
   if((b[-1]=='.' || b[-1]=='?' || b[-1]=='!') && cwhitel(b[1])) f=1;

   /* Skip past the whitespace.  Skip over indentations */
   loop:

   if(*b=='\r' && len)
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    }

   if(*b=='\n' && len)
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    while(cpara(*b) && len)
     {
     if(b-buf==curoff) pset(bw->cursor,p);
     ++b, --len;
     }
    }

   if(len && cwhite(*b))
    {
    if(b-buf==curoff) pset(bw->cursor,p);
    ++b, --len;
    goto loop;
    }

   /* Insert proper amount of whitespace */
   if(len)
    {
    if(f && !bw->o.french) binsc(p,' '), pgetc(p);
    binsc(p,' '); pgetc(p);
    }
   }
  else
   {
   /* Insert characters of word and wrap if necessary */
   if(b-buf==curoff) pset(bw->cursor,p);
   binsc(p,*b++); --len; pgetc(p);
   if(piscol(p)>bw->o.rmargin) wrapword(p,indent,bw->o.french,indents);
   }
 
 binsc(p,'\n');
 prm(p);
 free(buf);
 free(indents);
 return 0;
 }
d531 17
a547 18
int ufmtblk(bw)
BW *bw;
 {
 if(markv(1) && bw->cursor->byte>=markb->byte && bw->cursor->byte<=markk->byte)
  {
  markk->end=1;
  utomarkk(bw);
  within=1;
  do
   ubop(bw), uformat(bw);
   while(bw->cursor->byte>markb->byte);
  within=0;
  markk->end=0;
  if(lightoff) unmark(bw);
  return 0;
  }
 else return uformat(bw);
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
