head	1.11;
access;
symbols
	joe-3_1jupp38:1.11
	joe-3_1jupp37:1.11
	joe-3_1jupp36:1.11
	joe-3_1jupp35:1.11
	joe-3_1jupp34:1.11
	joe-3_1jupp33:1.11
	joe-3_1jupp32:1.9
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.6
	joe-3_1jupp30:1.6
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.5
	joe-3_1jupp27:1.4
	joe-3_1jupp26:1.4
	joe-3_1jupp25:1.4
	joe-3_1jupp24:1.4
	joe-3_1jupp23:1.4
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.11
date	2018.01.07.20.32.48;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A5284063C3E386D;

1.10
date	2018.01.06.00.28.35;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A50184621FA8455;

1.9
date	2017.12.06.21.17.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A285E5918D423C7;

1.8
date	2017.12.02.17.00.52;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A22DC570063953B;

1.7
date	2017.12.02.02.07.38;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A220AD65C90E687;

1.6
date	2016.10.30.00.19.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058153CC249071686;

1.5
date	2014.07.25.11.44.35;	author tg;	state Exp;
branches;
next	1.4;
commitid	10053D2432C3629C8A2;

1.4
date	2012.06.08.16.55.29;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004FD22E961A7F5A95;

1.3
date	2010.01.03.18.22.05;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004B40E05D33D0D68A;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.14;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.14;	author tg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@/*
 *	Dynamic string library
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_VS_H
#define _JOE_VS_H 1

#ifdef EXTERN
__IDSTRING(rcsid_vs_h, "$MirOS: contrib/code/jupp/vs.h,v 1.9 2017/12/06 21:17:05 tg Exp $");
#endif

#include <string.h>

/***
 *
 * This is a dynamic string library which supports strings which automatically
 * resize themselves when needed.  The strings know their own size, so getting
 * the length of a string is a fast operation and storing zeroes in the
 * strings is permissable.
 *
 * The strings are stored in malloc blocks and have the following format:
 *
 *   <bksize><length><string><zero>
 *
 * 'bksize' and 'length' are ints which give the size of the malloc block
 * and the length of the string.  A zero character always follows the string
 * for compatibility with normal C zero-terminated strings.  The zero is not
 * counted in the string length.
 *
 * To further the compatibility with C strings, the address of a dynamic string
 * is at <string> above, not at <bksize> (whose address is the start of the
 * malloc block).  Thus, dynamic strings can be passed as arguments to UNIX
 * operating system functions and C library function, but they can not be freed
 * with free()- a special function is provided in this library for freeing
 * dynamic strings.
 *
 * The primary dynamic string function is:
 *
 * char *vsncpy(char *d, int off, char *s, int len);
 *                              Copy a block of characters at address 's' of
 *				length 'len' onto the dynamic string 'd' at
 *				offset 'off'.  The dynamic string is expanded
 *				to handle any values of 'len' and 'off' which
 *				might be given.  If 'off' is greater than the
 *				length of the string, SPACEs are placed in the
 *				gap.  If 'd' is NULL, a string is created.  If
 *				'len' is 0, no copying or string expansion
 *				occurs.
 *
 * Three important macros are provided for helping with vsncpy():
 *
 * sc("Hello")   Gives -->  "Hello",sizeof("Hello")-1
 * sz(s)         Gives -->  s,strlen(s)
 * sv(d)         Gives -->  d,sLEN(d)
 *
 * These are used to build arguments for vsncpy().  Many functions
 * can be created with combinations of sc/sz/sv with vsncpy:
 *
 *    s=vsncpy(NULL,0,NULL,0);		Create an empty dynamic string
 *
 *    s=vsncpy(NULL,0,sc("Hello"));	Create a dynamic string initialized
 *					with "Hello"
 *
 *    d=vsncpy(NULL,0,sv(s));		Duplicate a dynamic string
 *
 *    d=vsncpy(NULL,0,sz(s));		Convert a C string into a dynamic
 *                                      string.
 *
 *    d=vsncpy(sv(d),sv(s));		Append dynamic string s onto d.
 *
 *    d=vsncpy(sv(d),sc(".c"));		Append a ".c" extension to d.
 *
 *
 * These lesser functions are also provided:
 *
 * void vsrm(char *s);		Free a string.  Do nothing if 's' is NULL.
 *
 * int sLEN(char *s);		Return the length of the string 's'.  If 's'
 *				is NULL, return 0.
 *
 * char *vstrunc(char *d,int len);
 *				Set the length of a string.  Expand the string
 *				with blanks if necessary.
 *
 * char *vsensure(char *d,int len);
 *				Expand the malloc block for the string if
 *				necessary so that a string of 'len' chars can
 *				fit in it.
 *
 * sLen(s)=10;			Set the length indicator of the string to 10.
 *
 * char *vsins(char *d,int off,int len);
 *				Insert a gap into a string.
 *
 * char *vsdel(char *d,int off,int len);
 *				Delete characters from a string.
 *
 * Other function are provided as well.  Look through the rest of the header
 * file.  The header file is kind of weird looking because it is intended to
 * handle dynamic arrays of any type with only a few changes.
 */

/* Functions and global variable you have to define.  Replace these with
 * macros or defines here if they are not to be actual functions
 */

/* An element with name 'a' */
typedef unsigned char sELEMENT;

/* Duplicate an element */
/* sELEMENT sdup(); */
#define sdup(a) (a)

/* Delete an element */
/* sELEMENT sdel(); */
#define sdel(a) do {} while(0)		/* effectively do nothing ;-) */

/* Compare a single element */
/* int scmp(); */
#define scmp(a, b) ((a) > (b) ? 1 : ((a) == (b) ? 0 : -1))

/* A blank element */
/* extern sELEMENT sblank; */
#define sblank ' '

/* A termination element */
/* extern sELEMENT sterm; */
#define sterm '\0'

/************************/
/* Creation/Destruction */
/************************/

/* sELEMENT *vsmk(int len);
 * Create a variable length array.  Space for 'len' elements is preallocated.
 */
sELEMENT *vsmk(int len);

/* void vsrm(sELEMENT *vary);
 * Free an array and everything which is in it.  Does nothing if 'vary' is
 * 0.
 */
void vsrm(sELEMENT *vary);

/********************/
/* Space management */
/********************/

/* int sSIZ(sELEMENT *vary);
 * int sSiz(sELEMENT *vary);
 * Access size part of array.  This int indicates the number of elements which
 * can fit in the array before realloc needs to be called.  It does not include
 * the extra space needed for the terminator and the header.
 *
 * sSIZ returns 0 if you pass it 0.  sSiz does not do this checking,
 * but can be used as an lvalue.
 */
#define sSiz(a) jalloc_siz(a)
#define sSIZ(a) ((a) ? sSiz(a) : 0)

/* int sLEN(sELEMENT *vary);
 * int sLen(sELEMENT *vary);
 * Access length part of array.  This int indicates the number of elements
 * currently in the array (not including the terminator).  This should be
 * used primarily for reading the size of the array.  It can be used for
 * setting the size of the array, but it must be used with care since it
 * does not eliminate elements (if the size decreases) or make sure there's
 * enough room (if the size increases).  See vensure and vtrunc.
 *
 * sLEN return a length of zero if 'vary' is 0.
 * sLen doesn't do this checking, but can be used as an lvalue
 */
#define sLen(a) jalloc_len(a)
#define sLEN(a) ((a) ? sLen(a) : 0)

/* int slen(const sELEMENT *ary);
 * Compute length of char or variable length array by searching for termination
 * element.  Returns 0 if 'vary' is 0.
 */
int slen(const sELEMENT *ary);

/* sELEMENT *vsensure(sELEMENT *vary, int len);
 * Make sure there's enough space in the array for 'len' elements.  Whenever
 * vsensure reallocs the array, it allocates 25% more than the necessary
 * minimum space in anticipation of future expansion.  If 'vary' is 0,
 * it creates a new array.
 */
sELEMENT *vsensure(sELEMENT *vary, int len);

/* sELEMENT *vstrunc(sELEMENT *vary, int len));
 * Truncate array to indicated size.  This zaps or expands with blank elements
 * and sets the LEN() of the array.  A new array is created if 'vary' is 0.
 */
sELEMENT *vstrunc(sELEMENT *vary, int len);

/************************************/
/* Function which write to an array */
/************************************/

/* sELEMENT *vsfill(sELEMENT *vary, int pos, sELEMENT el, int len);
 * Set 'len' element of 'vary' beginning at 'pos' to duplications of 'el'.
 * Ok, if pos/len are past end of array.  If 'vary' is 0, a new array is
 * created.
 *
 * This does not zap previous values.  If you need that to happen, call
 * vszap first.  It does move the terminator around properly though.
 */
sELEMENT *vsfill(sELEMENT *vary, int pos, sELEMENT el, int len);

/* sELEMENT *vsncpy(sELEMENT *vary, int pos, const sELEMENT *array, int len));
 * Copy 'len' elements from 'array' onto 'vary' beginning at position 'pos'.
 * 'array' can be a normal char array since the length is passed seperately.  The
 * elements are copied, not duplicated.  A new array is created if 'vary' is
 * 0.  This does not zap previous elements.
 */
sELEMENT *vsncpy(sELEMENT *vary, int pos, const sELEMENT *array, int len);

/* sELEMENT *vsndup(sELEMENT *vary, int pos, sELEMENT *array, int len));
 * Duplicate 'len' elements from 'array' onto 'vary' beginning at position
 * 'pos'.  'array' can be a char array since its length is passed seperately.  A
 * new array is created if 'vary' is 0.
 */
sELEMENT *vsndup(sELEMENT *vary, int pos, sELEMENT *array, int len);

/* sELEMENT *vsdup(sELEMENT *vary));
 * Duplicate array.  This is just a functionalized version of:
 *
 *   vsndup(NULL, 0, vary, sLEN(vary));
 *
 * but since you need to be able to refer to this particular function by
 * address often it's given here.
 *
 * (actually, there's bazillions of these simple combinations of the above
 * functions and the macros of the next section.  You'll probably want to make
 * functionalized instances of the ones you use most often - especially since
 * the macros aren't safe).
 */
sELEMENT *vsdup(sELEMENT *vary);

/* sELEMENT *vsset(sELEMENT *vary, int pos, sELEMENT element);
 * Set an element in an array.  Any value of 'pos' is valid.  A new array
 * is created if 'vary' is 0.  The previous contents of the position is
 * deleted.    This does not duplicate 'element'.  If you need 'element'
 * duplicated, call: vsset(vary,pos,sdup(element));
 */
sELEMENT *_vsset(sELEMENT *vary, int pos, sELEMENT el);

#define vsset(v, p, el)  \
 (!(v) || (p) > sLen(v) || (p) >= sSiz(v) ?  \
  _vsset((v), (p), (el)) \
 : \
  ((p) == sLen(v) ? \
   ((v)[(p) + 1] = 0, sLen(v) = (p) + 1, (v)[p] = (el), (v)) \
  : \
   ((v)[p] = (el), (v)) \
  ) \
 )

/* sELEMENT *vsadd(sELEMENT *vary, sELEMENT element);
 * Concatenate a single element to the end of 'vary'.  A new array is created
 * if 'vary' is 0.  This does not duplicate element: call
 * vsadd(vary,sdup(element));  If you need it duplicated.
 */
#define vsadd(v, el) \
 (!(v) || sLen(v) == sSiz(v) ? \
  _vsset((v), sLEN(v), (el)) \
 : \
  ((v)[sLen(v) + 1] = 0, (v)[sLen(v)] = (el), sLen(v) = sLen(v) + 1, (v)) \
 )

/**************************************/
/* Functions which read from an array */
/**************************************/

/* These macros are used to generate the address/size pairs which get
 * passed to the functions of the previous section.
 */

/* { sELEMENT *, int } sv(sELEMENT *array);
 * Return array, size pair.  Uses sLEN to get size.
 */
#define sv(a) (a), sLEN(a)

/* { sELEMENT *, int } sz(sELEMENT *array);
 * Return array, size pair.  Uses slen to get size.
 */
#define sz(a) (a), slen(a)

/* { sELEMENT *, int } sc(sELEMENT *array);
 * Return array, size pair.  Uses 'sizeof' to get size.
 */
#define sc(a) (const unsigned char *)(a), (sizeof(a) / sizeof(sELEMENT) - 1)

/* { sELEMENT *, int } srest(sELEMENT *vary, int pos);
 * Return array, size pair of rest of array beginning at pos.  If
 * pos is past end of array, gives size of 0.
 */
#define srest(a, p) ((a) + (p)), (((p) > sLEN(a)) ? 0 : sLen(a) - (p))

/* { sELEMENT *, int } spart(sELEMENT *vary, int pos, int len);
 * Return array,size pair of 'len' elements of array beginning with pos.  If
 * pos is past end of array, gives size of 0.  If pos+len is past end of array,
 * returns number of elements to end of array.
 */
#define spart(a, p, l) \
 ((a) + (p)), ((p) >= sLEN(a) ? 0 : ((p) + (l) > sLen(a) ? sLen(a) - (p) : (l)))

/* sELEMENT vsget(sELEMENT *vary, int pos);
 * Get an element from an array.  Any value of pos is valid; if it's past the
 * end of the array or if 'vary' is 0, the terminator is returned.  This
 * does not make a duplicate of the returned element.  If you want that, pass
 * the return value of this to sdup.
 */
#define vsget(a, p) ((p) >= sLEN(a) ? sterm : (a)[p])

/*************************/
/* Searching and Sorting */
/*************************/

/* int vsbsearch(const sELEMENT *ary, int len, sELEMENT element);
 * Do a binary search on a sorted variable length or char array.  Returns position
 * of matching element or the position where the element should be if it was
 * not found.  (You should test with scmp to find out which).
 *
 * Hmm... this should really indicate whether or not the element was found.
 */
int vsbsearch(const sELEMENT *ary, int len, sELEMENT el);

/* int vscmpn(sELEMENT *a, int alen, sELEMENT *b, int blen);
 *
 * Compare two arrays using scmp.  If 'a' > 'b', return 1.  If 'a' == 'b',
 * return 0.  If 'a' < 'b', return -1.  Longer strings are > shorter ones if
 * their beginning match.
 */
int vscmpn(sELEMENT *a, int alen, sELEMENT *b, int blen);

/* int vscmp(sELEMENT *a, sELEMENT *b);
 *
 * Functionalized version of: vscmpn(sv(a), sv(b));
 */
int vscmp(sELEMENT *a, sELEMENT *b);

/* int vsscan(const sELEMENT *a, int alen, const sELEMENT *b, int blen);
 * Find offset of first matching element in 'a' which matches any
 * of the elements passed in 'b'.  Array 'b' must be sorted.
 *
 * Hmm... this really needs to return what the found element is.
 */
int vsscan(const sELEMENT *a, int alen, const sELEMENT *b, int blen);

/* int vsspan(sELEMENT *a, int alen, sELEMENT *b, int blen);
 * Find offset of first matching element in 'a' which does not match any
 * of the elements passed in 'b'.  Array 'b' must be sorted.
 */
int vsspan(const sELEMENT *a, int alen, const sELEMENT *b, int blen);
#endif
@


1.10
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d161 2
a162 2
#define sSIZ(a) ((a) ? *((int *)(a) - 2) : 0)
#define sSiz(a) (*((int *)(a) - 2))
d176 2
a177 2
#define sLEN(a) ((a) ? *((int *)(a) - 1) : 0)
#define sLen(a) (*((int *)(a) - 1))
@


1.9
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__IDSTRING(rcsid_vs_h, "$MirOS: contrib/code/jupp/vs.h,v 1.8 2017/12/02 17:00:52 tg Exp $");
d295 1
a295 1
#define sc(a) (unsigned char *)(a), (sizeof(a) / sizeof(sELEMENT) - 1)
d358 1
a358 1
int vsspan(sELEMENT *a, int alen, sELEMENT *b, int blen);
@


1.8
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_vs_h, "$MirOS: contrib/code/jupp/vs.h,v 1.7 2017/12/02 02:07:38 tg Exp $");
d140 1
a140 1
sELEMENT *vsmk PARAMS((int len));
d146 1
a146 1
void vsrm PARAMS((sELEMENT *vary));
d183 1
a183 1
int slen PARAMS((const sELEMENT *ary));
d191 1
a191 1
sELEMENT *vsensure PARAMS((sELEMENT *vary, int len));
d197 1
a197 1
sELEMENT *vstrunc PARAMS((sELEMENT *vary, int len));
d211 1
a211 1
sELEMENT *vsfill PARAMS((sELEMENT *vary, int pos, sELEMENT el, int len));
d219 1
a219 1
sELEMENT *vsncpy PARAMS((sELEMENT *vary, int pos, const sELEMENT *array, int len));
d226 1
a226 1
sELEMENT *vsndup PARAMS((sELEMENT *vary, int pos, sELEMENT *array, int len));
d241 1
a241 1
sELEMENT *vsdup PARAMS((sELEMENT *vary));
d249 1
a249 1
sELEMENT *_vsset PARAMS((sELEMENT *vary, int pos, sELEMENT el));
d330 1
a330 1
int vsbsearch PARAMS((const sELEMENT *ary, int len, sELEMENT el));
d338 1
a338 1
int vscmpn PARAMS((sELEMENT *a, int alen, sELEMENT *b, int blen));
d344 1
a344 1
int vscmp PARAMS((sELEMENT *a, sELEMENT *b));
d352 1
a352 1
int vsscan PARAMS((const sELEMENT *a, int alen, const sELEMENT *b, int blen));
d358 1
a358 1
int vsspan PARAMS((sELEMENT *a, int alen, sELEMENT *b, int blen));
@


1.7
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.6
log
@sprinke some const-cleanliness
@
text
@a0 1
/* $MirOS: contrib/code/jupp/vs.h,v 1.4 2012/06/08 16:55:29 tg Exp $ */
d11 3
a13 1
#include "config.h"
@


1.5
log
@remove broken (LP#1348559) but also unused code; thanks dcb
@
text
@d322 1
a322 1
/* int vsbsearch(sELEMENT *ary, int len, sELEMENT element);
d329 1
a329 1
int vsbsearch PARAMS((sELEMENT *ary, int len, sELEMENT el));
d345 1
a345 1
/* int vsscan(sELEMENT *a, int alen, sELEMENT *b, int blen);
d351 1
a351 1
int vsscan PARAMS((sELEMENT *a, int alen, sELEMENT *b, int blen));
@


1.4
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.h,v 1.3 2010/01/03 18:22:05 tg Exp $ */
a123 3
/* Compare a single element- case insensitive */
int sicmp(unsigned char a, unsigned char b);

@


1.3
log
@begin const cleanup
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.h,v 1.2 2008/05/13 13:08:32 tg Exp $ */
d106 1
a106 1
 * macros or defines here if they are not to be actual functions 
a320 18
/**********************/
/* Insertion/Deletion */
/**********************/
#ifdef junk
/* sELEMENT *vsins(sELEMENT *vary, int pos, int n));
 * Insert n empty slots into the array.  If 'pos' >= the length of the array,
 * the array is simply extended.  The new slots are not set to anything.
 * This does not set the elements in the created hole to any particular
 * value: use vsfill if you need that to occur.
 */
sELEMENT *vsins PARAMS((sELEMENT *vary, int pos, int n));

/* sELEMENT *vsdel(sELEMENT *vary, int pos, int n));
 * Delete n slots from the array.  This does not zap the elements first; call
 * vszap first if you need this to happen.
 */
sELEMENT *vsdel PARAMS((SELEMENT *vary, int pos, int n));

a324 5
/* sELEMENT *vssort(sELEMENT *ary, int len))
 * Sort the elements of an array (char or variable length) using qsort().
 */
sELEMENT *vssort PARAMS((sELEMENT *ary, int len));
#endif
a333 17
#ifdef junk
/* int vsfirst(sELEMENT *ary, int len, sELEMENT element);
 * Find offset to first matching element in 'vary' or return ~0 if not found.
 */
int vsfirst PARAMS((sELEMENT *ary, int len, sELEMENT element));

/* int vslast(sELEMENT *ary, int len, sELEMENT element);
 * Find offset to last matching element in 'vary' or return ~0 if none found.
 */
int vslast PARAMS((sELEMENT *ary, int len, sELEMENT element));

/* int vss(sELEMENT *a, int alen, sELEMENT *b, int blen);
 * Do a substring search on 'a'.  Return offset from 'a' to first matching
 * occurance of 'b' in 'a' or return ~0 if none found.
 */
int vss PARAMS((sELEMENT *a, int alen, sELEMENT *b, int blen));
#endif
a347 17
#ifdef junk
/* int vsicmpn(sELEMENT *a, int alen, sELEMENT *b, int blen);
 *
 * Compare two arrays using sicmp.  If 'a' > 'b', return 1.  If 'a' == 'b',
 * return 0.  If 'a' < 'b', return -1.  Longer strings are > shorter ones if
 * their beginning match.
 *
 * This is same as vscmpn except that it is case insensitive.
 */
int vsicmpn PARAMS((sELEMENT *a, int alen, sELEMENT *b, int blen));

/* int vsicmp(sELEMENT *a, sELEMENT *b);
 *
 * Functionalized version of: vsicmpn(sv(a), sv(b));
 */
int vsicmp PARAMS((sELEMENT *a, sELEMENT *b));
#endif
a360 29

/***************/
/* Other stuff */
/***************/
#ifdef junk
/* char *vsread(char *d, int p, int (*getC)(void *ptr), void *ptr);
 * Replace 'd' with next line read from read-character function 'getC'.  If 
 * 'd' is 0, a new string is allocated.  If there is no more input, the string
 * is freed and 0 is returned.  The \n is deleted from the entered line.
 *
 * 'ptr' is passed as the first arg to 'getC'.  'getC' should return -1 if
 * there is no more input.
 */
unsigned char *vsread PARAMS(());

/* char *vwords(char *s, char **a, int len, char t);
 *
 * Generate a 't'-seperated word list from the words in the zero-terminated
 * array of zero-terminated strings 'a'.  For example a simple 'echo.c':
 *
 * main(argc, argv)
 * char *argv[];
 * {
 * printf("%s\n",vwords(NULL,argv,argc,' ')):
 * }
 *
 */
unsigned char *vwords PARAMS(());
#endif
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d181 1
a181 1
/* int slen(sELEMENT *ary);
d185 1
a185 1
int slen PARAMS((sELEMENT *ary));
d215 1
a215 1
/* sELEMENT *vsncpy(sELEMENT *vary, int pos, sELEMENT *array, int len));
d221 1
a221 1
sELEMENT *vsncpy PARAMS((sELEMENT *vary, int pos, sELEMENT *array, int len));
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Dynamic string library
   Copyright (C) 1992 Joseph H. Allen
d11 1
a11 1
This file is part of JOE (Joe's Own Editor)
d13 1
a13 17
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#ifndef _Ivs
#define _Ivs

#include "config.h"
d40 1
a40 1
 * char *vsncpy(char *d,int off,char *s,int len);
d54 1
a54 1
 * sz(s)         Gives -->  s,zlen(s)
d109 1
a109 4
#define sELEMENT(a) char a

/* Cast something to element type */
#define sCAST char
d112 1
a112 1
/* sELEMENT(sdup()); */
d116 2
a117 2
/* sELEMENT(sdel()); */
#define sdel(a) 0
d121 1
a121 1
#define scmp(a,b) ((a)>(b)?1:((a)==(b)?0:-1))
d124 1
a124 1
int sicmp();
d127 1
a127 1
/* extern sELEMENT(sblank); */
d131 1
a131 1
/* extern sELEMENT(sterm); */
d138 1
a138 1
/* sELEMENT(*vsmk(int len));
d141 1
a141 1
sELEMENT(*vsmk());
d143 1
a143 1
/* void vsrm(sELEMENT(*vary));
d147 1
a147 1
void vsrm();
d153 2
a154 2
/* int sSIZ(sELEMENT(*vary));
 * int sSiz(sELEMENT(*vary));
d162 2
a163 2
#define sSIZ(a) ((a)?*((int *)(a)-2):0)
#define sSiz(a) (*((int *)(a)-2))
d165 2
a166 2
/* int sLEN(sELEMENT(*vary));
 * int sLen(sELEMENT(*vary));
d177 2
a178 2
#define sLEN(a) ((a)?*((int *)(a)-1):0)
#define sLen(a) (*((int *)(a)-1))
d180 1
a180 1
/* int slen(sELEMENT(*ary));
d184 1
a184 1
int slen();
d186 1
a186 1
/* sELEMENT(*vsensure(sELEMENT(*vary),int len));
d192 1
a192 1
sELEMENT(*vsensure());
d194 1
a194 1
/* sELEMENT(*vstrunc(sELEMENT(*vary),int len));
d198 1
a198 1
sELEMENT(*vstrunc());
d204 1
a204 1
/* sELEMENT(*vsfill(sELEMENT(*vary),int pos,sELEMENT(el),int len));
d212 1
a212 1
sELEMENT(*vsfill());
d214 1
a214 1
/* sELEMENT(*vsncpy(sELEMENT(*vary),int pos,sELEMENT(*array),int len));
d220 1
a220 1
sELEMENT(*vsncpy());
d222 1
a222 1
/* sELEMENT(*vsndup(sELEMENT(*vary),int pos,sELEMENT(*array),int len));
d227 1
a227 1
sELEMENT(*vsndup());
d229 1
a229 1
/* sELEMENT(*vsdup(sELEMENT(*vary)));
d232 1
a232 1
 *   vsndup(NULL,0,vary,sLEN(vary));
d241 2
a242 2
 */ 
sELEMENT(*vsdup());
d244 1
a244 1
/* sELEMENT(*vsset(sELEMENT(*vary),int pos,sELEMENT(element)));
d250 1
a250 1
sELEMENT(*_vsset());
d252 3
a254 3
#define vsset(v,p,el)  \
 (!(v) || (p)>sLen(v) || (p)>=sSiz(v) ?  \
  _vsset((v),(p),(el)) \
d256 2
a257 2
  ((p)==sLen(v) ? \
   ((v)[(p)+1]=0, sLen(v)=(p)+1, (v)[p]=(el), (v)) \
d259 1
a259 1
   ((v)[p]=(el), (v)) \
d261 1
a261 1
 )   
d263 1
a263 1
/* sELEMENT(*vsadd(sELEMENT(*vary),sELEMENT(element)));
d268 3
a270 3
#define vsadd(v,el) \
 (!(v) || sLen(v)==sSiz(v) ? \
  _vsset((v),sLEN(v),(el)) \
d272 1
a272 1
  ((v)[sLen(v)+1]=0, (v)[sLen(v)]=(el), sLen(v)=sLen(v)+1, (v)) \
d283 2
a284 2
/* { sELEMENT(*),int } sv(sELEMENT(*array));
 * Return array,size pair.  Uses sLEN to get size.
d286 1
a286 1
#define sv(a) (a),sLEN(a)
d288 2
a289 2
/* { sELEMENT(*),int } sz(sELEMENT(*array));
 * Return array,size pair.  Uses slen to get size.
d291 1
a291 1
#define sz(a) (a),slen(a)
d293 2
a294 2
/* { sELEMENT(*),int } sc(sELEMENT(*array));
 * Return array,size pair.  Uses 'sizeof' to get size.
d296 1
a296 1
#define sc(a) (a),(sizeof(a)/sizeof(sCAST)-1)
d298 2
a299 2
/* { sELEMENT(*),int } srest(sELEMENT(*vary),int pos);
 * Return array,size pair of rest of array beginning at pos.  If
d302 1
a302 1
#define srest(a,p) ((a)+(p)),(((p)>sLEN(a))?0:sLen(a)-(p))
d304 1
a304 1
/* { sELEMENT(*),int } spart(sELEMENT(*vary),int pos,int len);
d309 2
a310 2
#define spart(a,p,l) \
 ((a)+(p)),((p)>=sLEN(a)?0:((p)+(l)>sLen(a)?sLen(a)-(p):(l)))
d312 1
a312 1
/* sELEMENT(vsget(sELEMENT(*vary),int pos));
d318 1
a318 1
#define vsget(a,p) ((p)>=sLEN(a)?sterm:(a)[p])
d324 1
a324 1
/* sELEMENT(*vsins(sELEMENT(*vary),int pos,int n));
d330 1
a330 1
sELEMENT(*vsins());
d332 1
a332 1
/* sELEMENT(*vsdel(sELEMENT(*vary),int pos,int n));
d336 1
a336 1
sELEMENT(*vsdel());
d342 1
a342 1
/* sELEMENT(*vssort(sELEMENT(*ary),int len))
d345 1
a345 1
sELEMENT(*vssort());
d347 1
a347 1
/* int vsbsearch(sELEMENT(*ary),int len,sELEMENT(element));
d354 2
a355 1
int vsbsearch();
d357 1
a357 1
/* int vsfirst(sELEMENT(*ary),int len,sELEMENT(element));
d360 1
a360 1
int vsfirst();
d362 1
a362 1
/* int vslast(sELEMENT(*ary),int len,sELEMENT(element));
d365 1
a365 1
int vslast();
d367 1
a367 1
/* int vss(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
d371 1
a371 1
int vss();
d373 1
a373 1
/* int vscmpn(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
d379 1
a379 1
int vscmpn();
d381 1
a381 1
/* int vscmp(sELEMENT(*a),sELEMENT(*b));
d383 1
a383 1
 * Functionalized version of: vscmpn(sv(a),sv(b));
d385 2
a386 1
int vscmp();
d388 1
a388 1
/* int vsicmpn(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
d396 1
a396 1
int vsicmpn();
d398 1
a398 1
/* int vsicmp(sELEMENT(*a),sELEMENT(*b));
d400 1
a400 1
 * Functionalized version of: vsicmpn(sv(a),sv(b));
d402 1
a402 1
int vsicmp();
d404 1
a404 1
/* int vsscan(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
d410 1
a410 1
int vsscan();
d412 1
a412 1
/* int vsspan(sELEMENT(*a),int alen,sELEMENT(*b),int blen);
d416 1
a416 1
int vsspan();
d422 1
a422 1
/* char *vsread(char *d,int p,int (*getC)(void *ptr),void *ptr);
d430 1
a430 1
char *vsread();
d432 1
a432 1
/* char *vwords(char *s,char **a,int len,char t);
d437 1
a437 1
 * main(argc,argv)
d444 1
a444 1
char *vwords();
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
