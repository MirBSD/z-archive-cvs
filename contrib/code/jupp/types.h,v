head	1.35;
access;
symbols
	joe-3_1jupp38:1.35
	joe-3_1jupp37:1.35
	joe-3_1jupp36:1.35
	joe-3_1jupp35:1.35
	joe-3_1jupp34:1.35
	joe-3_1jupp33:1.34
	joe-3_1jupp32:1.28
	joe-3_1jupp31:1.15
	joe-3_1jupp30:1.15
	joe-3_1jupp29:1.14
	joe-3_1jupp28:1.14
	joe-3_1jupp27:1.12
	joe-3_1jupp26:1.12
	joe-3_1jupp25:1.12
	joe-3_1jupp24:1.11
	joe-3_1jupp23:1.11
	joe-3_1jupp22:1.8
	joe-3_1jupp21:1.8
	joe-3_1jupp20:1.8
	joe-3_1jupp19:1.7
	joe-3_1jupp18:1.6
	joe-3_1jupp17:1.6
	joe-3_1jupp16:1.6
	joe-3_1jupp15:1.6
	joe-3_1jupp14:1.5
	joe-3_1jupp12:1.5
	joe-3_1jupp11:1.4
	joe-3_1jupp10:1.4
	joe-3_1jupp9:1.4
	joe-3_1jupp8:1.4
	joe-3_1jupp7:1.3
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.35
date	2018.02.14.17.51.49;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A8476F55C272529;

1.34
date	2018.01.08.00.33.16;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A52BC643CEE9268;

1.33
date	2018.01.07.23.51.35;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A52B281212EC267;

1.32
date	2018.01.07.20.32.47;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A5284063C3E386D;

1.31
date	2018.01.07.17.24.49;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A5257E37ACEAAEF;

1.30
date	2018.01.06.00.28.33;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A50184621FA8455;

1.29
date	2017.12.20.21.55.17;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A3ADC2126F7CA05;

1.28
date	2017.12.08.02.46.46;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A29FD2A06CBDCE5;

1.27
date	2017.12.08.02.00.42;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A29F2506E789D2B;

1.26
date	2017.12.07.02.13.05;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A28A3CC5DF696A2;

1.25
date	2017.12.07.02.10.18;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A28A3145E1FF911;

1.24
date	2017.12.07.01.00.32;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A2892BB042F2F1F;

1.23
date	2017.12.07.00.35.13;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A288CD6119BD663;

1.22
date	2017.12.06.23.17.35;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A287AA407E73F9C;

1.21
date	2017.12.06.23.02.06;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A2876FC4FFE7EF5;

1.20
date	2017.12.06.21.41.03;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A28640547F64250;

1.19
date	2017.12.04.22.15.39;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A25C91E16B3B365;

1.18
date	2017.12.02.18.33.25;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A22F1FF5B03A3AC;

1.17
date	2017.12.02.17.00.50;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A22DC570063953B;

1.16
date	2017.12.02.02.07.33;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A220AD65C90E687;

1.15
date	2017.01.11.22.56.49;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005876B84150F7CE16;

1.14
date	2014.10.23.15.30.52;	author tg;	state Exp;
branches;
next	1.13;
commitid	10054491F3F61079988;

1.13
date	2014.07.25.21.41.49;	author tg;	state Exp;
branches;
next	1.12;
commitid	10053D2CF304714B2CF;

1.12
date	2013.08.19.18.25.44;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005212631E445656D9;

1.11
date	2012.12.30.21.45.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050E0B5FE41C91584;

1.10
date	2012.12.30.17.10.58;	author tg;	state Exp;
branches;
next	1.9;
commitid	10050E075B939751F66;

1.9
date	2012.12.22.00.06.14;	author tg;	state Exp;
branches;
next	1.8;
commitid	10050D4F965570AEE79;

1.8
date	2012.06.08.16.55.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004FD22E961A7F5A95;

1.7
date	2012.06.07.23.38.17;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004FD13B7F5D8CFBBB;

1.6
date	2011.07.03.00.35.05;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E0FB941774BF3C1;

1.5
date	2009.10.18.14.52.57;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004ADB2BD317498872;

1.4
date	2006.12.11.23.54.50;	author tg;	state Exp;
branches;
next	1.3;
commitid	100457DEFC626A6A05C;

1.3
date	2006.11.11.01.51.20;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045552CAA523E95B9;

1.2
date	2006.11.10.23.23.31;	author tg;	state Exp;
branches;
next	1.1;
commitid	100455509573940FA03;

1.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.35
log
@fix failure to allocate enough memory by parenthesising macro parameters

… oops!
@
text
@#ifndef _JOE_TYPES_H
#define _JOE_TYPES_H

#ifdef EXTERN
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.32 2018/01/07 20:32:47 tg Exp $");
#endif

/*-
 * Copyright © 2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013,
 *	       2014, 2016, 2017, 2018
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un‐
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 */

/* Prefix to make string constants unsigned */
#define UC (const unsigned char *)
#define US (unsigned char *)

#define LINK(type) struct { type *next; type *prev; }

#ifdef SMALL
#define stdsiz		4096
#else
#define stdsiz		8192
#endif
#define FITHEIGHT	4		/* Minimum text window height */
#define LINCOLS		6
#define NPROC		8		/* Number of processes we keep track of */
#define UNDOKEEP	100
#define INC		16		/* Pages to allocate each time */

#define TYPETW		0x0100
#define TYPEPW		0x0200
#define TYPEMENU	0x0800
#define TYPEQW		0x1000

/* polymorph function pointers, which do not use compiler type checking */
#ifndef GCC_Wstrict_prototypes
typedef int jpoly_int();
typedef void jpoly_void();
#else
/* same content as above, but system header */
#include <jupp.tmp.h>
#endif

struct jalloc_common {
	/*XXX these must be size_t not int */
	/*
	 * size part: number of elements that can be fit,
	 * not counting the terminator or space needed for the header
	 */
	int esiz;
	/*
	 * length part: number of elements currently in the array,
	 * not counting the terminator
	 */
	int elen;
};

#ifdef MKSH_ALLOC_CATCH_UNDERRUNS
struct jalloc_item {
	struct jalloc_common enfo;
	size_t len;
	char dummy[8192 - sizeof(struct jalloc_common) - sizeof(size_t)];
};
#define ALLOC_INFO(f)	enfo.f
#define ALLOC_ITEM	struct jalloc_item
#else
#define ALLOC_INFO(f)	f
#define ALLOC_ITEM	struct jalloc_common
#endif

#define jalloc_krnl(i)	((ALLOC_ITEM *)((char *)(i) - sizeof(ALLOC_ITEM)))
#define jalloc_user(i)	((void *)((char *)(i) + sizeof(ALLOC_ITEM)))
#define jalloc_siz(i)	(jalloc_krnl(i)->ALLOC_INFO(esiz))
#define jalloc_len(i)	(jalloc_krnl(i)->ALLOC_INFO(elen))

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif

#ifndef SIZE_MAX
#ifdef SIZE_T_MAX
#define SIZE_MAX	SIZE_T_MAX
#else
#define SIZE_MAX	((size_t)-1)
#endif
#endif

#define notok2mul(max, val, c)	(((val) != 0) && ((c) != 0) && \
				    (((max) / (c)) < (val)))
#define notok2add(max, val, c)	((val) > ((max) - (c)))
#define notoktomul(val, cnst)	notok2mul(SIZE_MAX, (val), (cnst))
#define notoktoadd(val, cnst)	notok2add(SIZE_MAX, (val), (cnst))

void jalloc_init(void);
void *jalloc(void *, size_t, size_t);
void jfree(void *);

#define ralloc(nmemb, size)	(notoktomul(nmemb, size) ? NULL : \
				    malloc((nmemb) * (size)))

typedef struct header H;
typedef struct buffer B;
typedef struct point P;
typedef struct options OPTIONS;
typedef struct macro MACRO;
typedef struct cmd CMD;
typedef struct hentry HENTRY;
typedef struct hash HASH;
typedef struct kmap KMAP;
typedef struct kbd KBD;
typedef struct key KEY;
typedef struct watom WATOM;
typedef struct screen SCREEN;
typedef struct window W;
typedef struct base BASE;
typedef struct bw BW;
typedef struct menu MENU;
typedef struct scrn SCRN;
typedef struct cap CAP;
typedef struct pw PW;
typedef struct stditem STDITEM;
typedef struct query QW;
typedef struct tw TW;
typedef struct irec IREC;
typedef struct undo UNDO;
typedef struct undorec UNDOREC;
typedef struct search SRCH;
typedef struct srchrec SRCHREC;
typedef struct vpage VPAGE;
typedef struct vfile VFILE;

/* window.object* */
typedef union {
	BASE *base;
	MENU *menu;
	BW *bw;
	QW *qw;
} jobject;

struct header {
	LINK(H)	link;		/* LINK ??? */
	long	seg;		/* ??? */
	int	hole;		/* ??? */
	int	ehole;		/* ??? */
	int	nlines;		/* ??? */
};

struct point {
	LINK(P)	link;		/* ?LINK ??? */

	B	*b;		/* ?B ??? */
	int	ofst;		/* ??? */
	unsigned char	*ptr;	/* ??? */
	H	*hdr;		/* ?H ??? */

	long	byte;		/* ??? */
	long	line;		/* ??? */
	long	col;		/* current column */
	long	xcol;		/* ??? */
	int	valcol;		/* bool: is col valid? */
	int	end;		/* ??? */

	P	**owner;	/* ??? */
};

struct options {
	OPTIONS	*next;
	unsigned char	*name_regex;
	unsigned char	*contents_regex;
	int	overtype;
	int	lmargin;
	int	rmargin;
	int	autoindent;
	int	wordwrap;
	int	tab;
	int	indentc;
	int	istep;
	unsigned char *context;
	const unsigned char *lmsg;
	const unsigned char *rmsg;
	char	*hmsg;
	int	linums;
	int	readonly;
	int	french;
	int	spaces;
	int	crlf;
	int	highlight;	/* Set to enable highlighting */
	unsigned char *syntax_name;	/* Name of syntax to use */
	struct high_syntax *syntax;	/* Syntax for highlighting (load_dfa() from syntax_name happens in setopt()) */
	unsigned char *map_name;	/* Name of character set */
	struct charmap *charmap;	/* Character set */
	int	smarthome;	/* Set for smart home key */
	int	indentfirst;	/* Smart home goes to indentation point first */
	int	smartbacks;	/* Set for smart backspace key */
	int	purify;		/* Purify indentation */
	int	picture;	/* Picture mode */
	MACRO	*mnew;		/* Macro to execute for new files */
	MACRO	*mold;		/* Macro to execute for existing files */
	MACRO	*msnew;		/* Macro to execute before saving new files */
	MACRO	*msold;		/* Macro to execute before saving existing files */
	int	vispace;	/* Set to make spaces visible */
	int	hex;		/* Hex edit mode */
};

struct macro {
	int	k;		/* Keycode */
	int	arg;		/* Repeat argument */
	CMD	*cmd;		/* Command address */
	int	n;		/* Number of steps */
	int	size;		/* Malloc size of steps */
	MACRO	**steps;	/* Block */
};

struct recmac {
	struct recmac *next;
	int	n;
	MACRO	*m;
};


/* Command entry */

struct cmd {
	const unsigned char *name;	/* Command name */
	const unsigned char *negarg;	/* Command to use if arg was negative */
	jpoly_int *func;	/* Function bound to name */
	MACRO	*m;		/* Macro bound to name */
	unsigned int flag;	/* Execution flags */
	int	arg;		/* 0= arg is meaningless, 1= ok */
};



struct buffer {
	LINK(B)	link;
	P	*bof;
	P	*eof;
	unsigned char	*name;
	long    mod_time;	/* Last modification time for file */
	int	orphan;
	int	count;
	int	changed;
	int	backup;
	void	*undo;
	P	*marks[11];	/* Bookmarks */
	OPTIONS	o;		/* Options */
	P	*oldcur;	/* Last cursor position before orphaning */
	P	*oldtop;	/* Last top screen position before orphaning */
	int	rdonly;		/* Set for read-only */
	int	internal;	/* Set for internal buffers */
	int	scratch;	/* Set for scratch buffers */
	int	er;		/* Error code when file was loaded */
	pid_t	pid;		/* Process id */
	int	out;		/* fd to write to process */
};


struct hentry {
	const unsigned char *name;
	HENTRY	*next;
	void	*val;
};

struct hash {
	int	len;
	HENTRY	**tab;
};


struct help {
	struct help	*prev;		/* previous help screen */
	struct help	*next;		/* nex help screen */
	unsigned char	*name;		/* context name for context sensitive help */
	unsigned char	*text;		/* help text with attributes */
	unsigned int	lines;		/* number of lines */
};

/* A key binding */
struct key {
	int	k;			/* Flag: 0=binding, 1=submap */
	union {
		void	*bind;		/* What key is bound to */
		KMAP	*submap;	/* Sub KMAP address (for prefix keys) */
	} value;
};

/* A map of keycode (octet) to command/sub-map bindings */
struct kmap {
	KEY	keys[256];	/* KEYs */
};

/** A keyboard handler **/
struct kbd {
	KMAP	*curmap;	/* Current keymap */
	KMAP	*topmap;	/* Top-level keymap */
	int	seq[16];	/* Current sequence of keys */
	int	x;		/* What we're up to */
};


struct watom {
	const unsigned char *context;	/* Context name */
	void (*disp)(jobject, int);	/* Display window */
	void (*follow)(jobject);	/* Display window */
	int (*abort)(jobject);		/* Common user functions */
	int (*rtn)(jobject);
	int (*type)(jobject, int);
					/* Called when… */
	void (*resize)(jobject, int, int);	/* window changed size */
	void (*move)(jobject, int, int);	/* window moved */
	void (*ins)(BW *, B *, long, long, int);	/* on line insertions */
	void (*del)(BW *, B *, long, long, int);	/* on line deletions */
	int	what;		/* Type of this thing */
};

struct screen {
	SCRN	*t;		/* Screen data on this screen is output to */

	int	wind;		/* Number of help lines on this screen */

	W	*topwin;	/* Top-most window showing on screen */
	W	*curwin;	/* Window cursor is in */

	int	w, h;		/* Width and height of this screen */
};

struct window {
	LINK(W)	link;		/* Linked list of windows in order they
				   appear on the screen */

	SCREEN	*t;		/* Screen this thing is on */

	int	x, y, w, h;	/* Position and size of window */
				/* Currently, x = 0, w = width of screen. */
				/* y == -1 if window is not on screen */

	int	ny, nh;		/* Temporary values for wfit */

	int	reqh;		/* Requested new height or 0 for same */
				/* This is an argument for wfit */

	int	fixed;		/* If this is zero, use 'hh'.  If not, this
				   is a fixed size window and this variable
				   gives its height */

	int	hh;		/* Height window would be on a screen with
				   1000 lines.  When the screen size changes
				   this is used to calculate the window's
				   real height */

	W	*win;		/* Window this one operates on */
	W	*main;		/* Main window of this family */
	W	*orgwin;	/* Window where space from this window came */
	int	curx, cury;	/* Cursor position within window */
	KBD	*kbd;		/* Keyboard handler for this window */
	WATOM	*watom;		/* The type of this window */
	jobject	object;		/* Object which inherits this */

	const unsigned char *msgt;	/* Message at top of window */
	const unsigned char *msgb;	/* Message at bottom of window */
	const unsigned char *huh;	/* Name of window for context sensitive hlp */
	int	*notify;	/* Address of kill notification flag */
};

/* Anything which goes in window.object must start like this: */
struct base {
	W	*parent;
};

struct bw {
	W	*parent;
	B	*b;
	P	*top;
	P	*cursor;
	long	offset;
	SCREEN	*t;
	int	h, w, x, y;

	OPTIONS	o;
	void	*object;

	int	linums;
	int	top_changed;	/* Top changed */
};

struct menu {
	W	*parent;	/* Window we're in */
	unsigned char	**list;		/* List of items */
	int	top;		/* First item on screen */
	int	cursor;		/* Item cursor is on */
	int	width;		/* Width of widest item, up to 'w' max */
	int	perline;	/* Number of items on each line */
	int	nitems;		/* No. items in list */
	int	saved_co;	/* Saved #columns of screen */
	SCREEN	*t;		/* Screen we're on */
	int	h, w, x, y;
	jpoly_int *abrt;	/* Abort callback function */
	jpoly_int *func;	/* Return callback function */
	jpoly_int *backs;	/* Backspace callback function */
	void	*object;
};

struct s_hentry {
	int	next;
	int	loc;
};

/* Each terminal has one of these */
struct scrn {
	CAP	*cap;		/* Termcap/Terminfo data */

	int	li;		/* Screen height */
	int	co;		/* Screen width */

	const unsigned char *ti;	/* Initialisation string */
	const unsigned char *cl;	/* Home and clear screen... really an
					   init. string */
	const unsigned char *cd;	/* Clear to end of screen */
	const unsigned char *te;	/* Restoration string */

	int	haz;		/* Terminal can't print ~s */
	int	os;		/* Terminal overstrikes */
	int	eo;		/* Can use blank to erase even if os */
	int	ul;		/* _ overstrikes */
	int	am;		/* Terminal has autowrap, but not magicwrap */
	int	xn;		/* Terminal has magicwrap */

	const unsigned char *so;	/* Enter standout (inverse) mode */
	const unsigned char *se;	/* Exit standout mode */

	const unsigned char *us;	/* Enter underline mode */
	const unsigned char *ue;	/* Exit underline mode */
	const unsigned char *uc;	/* Single time underline character */

	int	ms;		/* Ok to move when in standout/underline mode */

	const unsigned char *mb;	/* Enter blinking mode */
	const unsigned char *md;	/* Enter bold mode */
	const unsigned char *mh;	/* Enter dim mode */
	const unsigned char *mr;	/* Enter inverse mode */
	const unsigned char *me;	/* Exit above modes */

	const unsigned char *Sb;	/* Set background color */
	const unsigned char *Sf;	/* Set foregrond color */
	int	ut;		/* Screen erases with background color */

	int	da, db;		/* Extra lines exist above, below */
	const unsigned char *al, *dl, *AL, *DL;	/* Insert/delete lines */
	const unsigned char *cs;		/* Set scrolling region */
	int	rr;		/* Set for scrolling region relative addressing */
	const unsigned char *sf, *SF, *sr, *SR;	/* Scroll */

	const unsigned char *dm, *dc, *DC, *ed;	/* Delete characters */
	const unsigned char *im, *ic, *IC, *ip, *ei;	/* Insert characters */
	int	mi;		/* Set if ok to move while in insert mode */

	const unsigned char *bs;	/* Move cursor left 1 */
	int	cbs;
	const unsigned char *lf;	/* Move cursor down 1 */
	int	clf;
	const unsigned char *up;	/* Move cursor up 1 */
	int	cup;
	const unsigned char *nd;	/* Move cursor right 1 */

	const unsigned char *ta;	/* Move cursor to next tab stop */
	int	cta;
	const unsigned char *bt;	/* Move cursor to previous tab stop */
	int	cbt;
	int	tw;			/* Tab width */

	const unsigned char *ho;	/* Home cursor to upper left */
	int	cho;
	const unsigned char *ll;	/* Home cursor to lower left */
	int	cll;
	const unsigned char *cr;	/* Move cursor to left edge */
	int	ccr;
	const unsigned char *RI;	/* Move cursor right n */
	int	cRI;
	const unsigned char *LE;	/* Move cursor left n */
	int	cLE;
	const unsigned char *UP;	/* Move cursor up n */
	int	cUP;
	const unsigned char *DO;	/* Move cursor down n */
	int	cDO;
	const unsigned char *ch;	/* Set cursor column */
	int	cch;
	const unsigned char *cv;	/* Set cursor row */
	int	ccv;
	const unsigned char *cV;	/* Goto beginning of specified line */
	int	ccV;
	const unsigned char *cm;	/* Set cursor row and column */
	int	ccm;

	const unsigned char *ce;	/* Clear to end of line */
	int	cce;

	/* Basic abilities */
	int	scroll;		/* Set to use scrolling */
	int	insdel;		/* Set to use insert/delete within line */

	/* Current state of terminal */
	int	*scrn;		/* Characters on screen */
	int	*attr;		/* Attributes on screen */
	int	x, y;		/* Current cursor position (-1 for unknown) */
	int	top, bot;	/* Current scrolling region */
	int	attrib;		/* Current character attributes */
	int	ins;		/* Set if we're in insert mode */

	int	*updtab;	/* Dirty lines table */
	int	*syntab;
	int	avattr;		/* Bits set for available attributes */
	int	*sary;		/* Scroll buffer array */

	int	*compose;	/* Line compose buffer */
	int	*ofst;		/* stuff for magic */
	struct s_hentry	*htab;
	struct s_hentry	*ary;
};


struct sortentry {
	unsigned char	*name;
	unsigned char	*value;
};

struct cap {
	unsigned char	*tbuf;		/* Termcap entry loaded here */

	struct sortentry *sort;	/* Pointers to each capability stored in here */
	int	sortlen;	/* Number of capabilities */

	unsigned char	*abuf;		/* For terminfo compatible version */
	unsigned char	*abufp;

	int	div;		/* tenths of MS per char */
	int	baud;		/* Baud rate */
	const unsigned char *pad;	/* Padding string or NULL to use NUL */
	void	(*out) (unsigned char *, unsigned char);		/* Character output routine */
	void	*outptr;	/* First arg passed to output routine.  Second
				   arg is character to write */
	int	dopadding;	/* Set if pad characters should be used */
	const char *paste_on;	/* Enable bracketed paste mode */
	const char *paste_off;	/* Disable bracketed paste mode */
};


struct pw {
	jpoly_int *pfunc;	/* Func which gets called when RTN is hit */
	jpoly_int *abrt;	/* Func which gets called when window is aborted */
	jpoly_int *tab;		/* Func which gets called when TAB is hit */
	unsigned char *prompt;	/* Prompt string */
	int	promptlen;	/* Width of prompt string */
	int	promptofst;	/* Prompt scroll offset */
	B	*hist;		/* History buffer */
	void	*object;	/* Object */
};

struct stditem {
	LINK(STDITEM)	link;
};

struct query {
	W	*parent;	/* Window we're in */
	jpoly_int *func;	/* Func. which gets called when key is hit */
	jpoly_int *abrt;
	void	*object;
	unsigned char	*prompt;	/* Prompt string */
	int	promptlen;	/* Width of prompt string */
	int	promptofst;	/* Prompt scroll offset */
};


typedef struct mpx MPX;
struct mpx {
	int	ackfd;		/* Packetizer response descriptor */
	int	kpid;		/* Packetizer process id */
	int	pid;		/* Client process id */
	jpoly_void *func;	/* Function to call when read occures */
	void	*object;	/* First arg to pass to function */
	jpoly_void *die;	/* Function: call when client dies or closes */
	void	*dieobj;
};


struct tw {
	unsigned char	*stalin;	/* Status line info */
	unsigned char	*staright;
	int	staon;		/* Set if status line was on */
	long	prevline;	/* Previous cursor line number */
	int	changed;	/* Previous changed value */
	B	*prev_b;	/* Previous buffer (we need to update status line on nbuf/pbuf) */
};

struct irec {
	LINK(IREC)	link;
	int	what;		/* 0 repeat, >0 append n chars */
	long	start;		/* Cursor search position */
	long	disp;		/* Original cursor position */
	int	wrap_flag;	/* Wrap flag */
};

struct isrch {
	IREC	irecs;		/* Linked list of positions */
	unsigned char *pattern;	/* Search pattern string */
	unsigned char *prompt;	/* Prompt (usually same as pattern unless utf-8/byte conversion) */
	int	ofst;		/* Offset in pattern past prompt */
	int	dir;		/* 0=fwrd, 1=bkwd */
	int	quote;		/* Set to quote next char */
};


struct undorec {
	LINK(UNDOREC)	link;
	UNDOREC	*unit;
	int	min;
	int	changed;	/* Status of modified flag before this record */
	long	where;		/* Buffer address of this record */
	long	len;		/* Length of insert or delete */
	int	del;		/* Set if this is a delete */
	B	*big;		/* Set to buffer containing a large amount of deleted data */
	unsigned char *small;	/* Set to malloc block containg a small amount of deleted data */
};

struct undo {
	LINK(UNDO)	link;
	B	*b;
	int	nrecs;
	UNDOREC	recs;
	UNDOREC	*ptr;
	UNDOREC	*first;
	UNDOREC	*last;
};

struct srchrec {
	LINK(SRCHREC)	link;	/* Linked list of search & replace locations */
	int	yn;		/* Did we replace? */
	int	wrap_flag;	/* Did we wrap? */
	long	addr;		/* Where we were */
};

struct search {
	unsigned char	*pattern;	/* Search pattern */
	unsigned char	*replacement;	/* Replacement string */
	int	backwards;	/* Set if search should go backwards */
	int	ignore;		/* Set if we should ignore case */
	int	repeat;		/* Set with repeat count (or -1 for no repeat count) */
	int	replace;	/* Set if this is search & replace */
	int	rest;		/* Set to do remainder of search & replace w/o query */
	unsigned char	*entire;	/* Entire matched string */
	unsigned char	*pieces[26];	/* Pieces of the matched string */
	int	flg;		/* Set after prompted for first replace */
	SRCHREC	recs;		/* Search & replace position history */
	P	*markb, *markk;	/* Original marks */
	P	*wrap_p;	/* Wrap point */
	int	wrap_flag;	/* Set if we've wrapped */
	int	valid;		/* Set if original marks are a valid block */
	long	addr;		/* Addr of last replacement or -1 for none */
	int	block_restrict;	/* Search restricted to marked block */
};



/* Page header */

struct vpage {
	VPAGE	*next;		/* Next page with same hash value */
	VFILE	*vfile;		/* Owner vfile */
	long	addr;		/* Address of this page */
	int	count;		/* Reference count */
	int	dirty;		/* Set if page changed */
	unsigned char	*data;		/* The data in the page */
};

/* File structure */

struct vfile {
	LINK(VFILE)	link;	/* Doubly linked list of vfiles */
	long	size;		/* Number of bytes in physical file */
	long	alloc;		/* Number of bytes allocated to file */
	int	fd;		/* Physical file */
	int	writeable;	/* Set if we can write */
	unsigned char	*name;		/* File name.  0 if unnamed */
	int	flags;		/* Set if this is only a temporary file */

	/* For array I/O */
	unsigned char	*vpage1;	/* Page address */
	long	addr;		/* File address of above page */

	/* For stream I/O */
	unsigned char	*bufp;		/* Buffer pointer */
	unsigned char	*vpage;		/* Buffer pointer points in here */
	int	left;		/* Space left in bufp */
	int	lv;		/* Amount of append space at end of buffer */
};

#endif
@


1.34
log
@optimise for LP64
@
text
@d8 21
d118 1
a118 1
				    malloc(nmemb * size))
@


1.33
log
@new ralloc(x,y) = malloc(x*y) with checks, but not, unlike calloc,
with implizit size_t casting nor memory cleansing
@
text
@a268 2
	unsigned char	*text;		/* help text with attributes */
	unsigned int	lines;		/* number of lines */
d272 2
@


1.32
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.29 2017/12/20 21:55:17 tg Exp $");
d96 3
@


1.31
log
@reorient the screen from column 0 on format, fmtblk, retype

allows us to get rid of the fmtln macro hack for jupp
@
text
@d39 57
@


1.30
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d166 1
a166 1
	int	flag;		/* Execution flags */
@


1.29
log
@mark kbd.c:keyval() as untainting function:
• it’s used only inside kbd.c (static function)
• it returns -1 or an unsigned char
• its return value is checked for -1 or applied to a 256-entry array

also, drop the KEYS define, it’s always 256 anyway
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.28 2017/12/08 02:46:46 tg Exp $");
d116 3
a118 3
	unsigned char	*context;
	unsigned char	*lmsg;
	unsigned char	*rmsg;
d240 1
a240 1
	unsigned char *context;		/* Context name */
@


1.28
log
@massive const offensive
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.26 2017/12/07 02:13:05 tg Exp $");
a13 1
#define KEYS		256
d225 1
a225 1
/* A map of keycode to command/sub-map bindings */
d227 1
a227 1
	KEY	keys[KEYS];	/* KEYs */
@


1.27
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d354 5
a358 5
	unsigned char	*ti;		/* Initialization string */
	unsigned char	*cl;		/* Home and clear screen... really an
				   init. string */
	unsigned char	*cd;		/* Clear to end of screen */
	unsigned char	*te;		/* Restoration string */
d367 2
a368 2
	unsigned char	*so;		/* Enter standout (inverse) mode */
	unsigned char	*se;		/* Exit standout mode */
d370 3
a372 3
	unsigned char	*us;		/* Enter underline mode */
	unsigned char	*ue;		/* Exit underline mode */
	unsigned char	*uc;		/* Single time underline character */
d376 5
a380 5
	unsigned char	*mb;		/* Enter blinking mode */
	unsigned char	*md;		/* Enter bold mode */
	unsigned char	*mh;		/* Enter dim mode */
	unsigned char	*mr;		/* Enter inverse mode */
	unsigned char	*me;		/* Exit above modes */
d382 2
a383 2
	unsigned char	*Sb;		/* Set background color */
	unsigned char	*Sf;		/* Set foregrond color */
d387 2
a388 2
	unsigned char	*al, *dl, *AL, *DL;	/* Insert/delete lines */
	unsigned char	*cs;		/* Set scrolling region */
d390 1
a390 1
	unsigned char	*sf, *SF, *sr, *SR;	/* Scroll */
d392 2
a393 2
	unsigned char	*dm, *dc, *DC, *ed;	/* Delete characters */
	unsigned char	*im, *ic, *IC, *ip, *ei;	/* Insert characters */
d396 1
a396 1
	unsigned char	*bs;		/* Move cursor left 1 */
d398 1
a398 1
	unsigned char	*lf;		/* Move cursor down 1 */
d400 1
a400 1
	unsigned char	*up;		/* Move cursor up 1 */
d402 1
a402 1
	unsigned char	*nd;		/* Move cursor right 1 */
d404 1
a404 1
	unsigned char	*ta;		/* Move cursor to next tab stop */
d406 1
a406 1
	unsigned char	*bt;		/* Move cursor to previous tab stop */
d408 1
a408 1
	int	tw;		/* Tab width */
d410 1
a410 1
	unsigned char	*ho;		/* Home cursor to upper left */
d412 1
a412 1
	unsigned char	*ll;		/* Home cursor to lower left */
d414 1
a414 1
	unsigned char	*cr;		/* Move cursor to left edge */
d416 1
a416 1
	unsigned char	*RI;		/* Move cursor right n */
d418 1
a418 1
	unsigned char	*LE;		/* Move cursor left n */
d420 1
a420 1
	unsigned char	*UP;		/* Move cursor up n */
d422 1
a422 1
	unsigned char	*DO;		/* Move cursor down n */
d424 1
a424 1
	unsigned char	*ch;		/* Set cursor column */
d426 1
a426 1
	unsigned char	*cv;		/* Set cursor row */
d428 1
a428 1
	unsigned char	*cV;		/* Goto beginning of specified line */
d430 1
a430 1
	unsigned char	*cm;		/* Set cursor row and column */
d433 1
a433 1
	unsigned char	*ce;		/* Clear to end of line */
d476 1
a476 1
	unsigned char	*pad;		/* Padding string or NULL to use NUL */
@


1.26
log
@fix typo
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.25 2017/12/07 02:10:18 tg Exp $");
d560 1
a560 1
	unsigned char	*small;		/* Set to malloc block containg a small amount of deleted data */
@


1.25
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.24 2017/12/07 01:00:32 tg Exp $");
d589 1
a589 1
	unsigned char	*pieces[26];	/* Peices of the matched string */
@


1.24
log
@unfortunately, the polymorphic problems are not yet solved
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.23 2017/12/07 00:35:13 tg Exp $");
d71 7
d241 11
a251 10
	unsigned char *context;	/* Context name */
	jpoly_void *disp;	/* Display window */
	jpoly_void *follow;	/* Called to have window follow cursor */
	jpoly_int *abort;	/* Common user functions */
	jpoly_int *rtn;
	jpoly_int *type;
	jpoly_void *resize;	/* Called when window changed size */
	jpoly_void *move;	/* Called when window moved */
	jpoly_void *ins;	/* Called on line insertions */
	jpoly_void *del;	/* Called on line deletions */
d296 1
a296 11
	void	*object;	/* Object which inherits this */
#if 0
	union {			/* FIXME: instead of void *object we should */
		BW	*bw;	/* use this union to get strict type checking */
		PW	*pw;	/* from C compiler (need to check and change */
		QW	*qw;	/* all of the occurrencies of ->object) */
		TW	*tw;
		MENU	*menu;
		BASE	*base;
	} object;
#endif
@


1.23
log
@#ifdef SMALL, use 8K less .bss
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.21 2017/12/06 23:02:06 tg Exp $");
d32 1
a32 1
#if 0
@


1.22
log
@whitespace at EOL annoys me
@
text
@d15 3
d19 1
@


1.21
log
@lots of fixes related to prototyping
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.20 2017/12/06 21:41:03 tg Exp $");
d234 2
a235 2
	jpoly_int *rtn;		
	jpoly_int *type;	
@


1.20
log
@const cleanup
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.18 2017/12/02 18:33:25 tg Exp $");
d27 8
d154 1
a154 1
	int	(*func) ();	/* Function bound to name */
d230 10
a239 10
	unsigned char	*context;	/* Context name */
	void	(*disp) ();	/* Display window */
	void	(*follow) ();	/* Called to have window follow cursor */
	int	(*abort) ();	/* Common user functions */
	int	(*rtn) ();
	int	(*type) ();
	void	(*resize) ();	/* Called when window changed size */
	void	(*move) ();	/* Called when window moved */
	void	(*ins) ();	/* Called on line insertions */
	void	(*del) ();	/* Called on line deletions */
d334 3
a336 3
	int	(*abrt) ();	/* Abort callback function */
	int	(*func) ();	/* Return callback function */
	int	(*backs) ();	/* Backspace callback function */
d485 4
a488 4
	int	(*pfunc) ();	/* Func which gets called when RTN is hit */
	int	(*abrt) ();	/* Func which gets called when window is aborted */
	int	(*tab) ();	/* Func which gets called when TAB is hit */
	unsigned char	*prompt;	/* Prompt string */
d501 2
a502 2
	int	(*func) ();	/* Func. which gets called when key is hit */
	int	(*abrt) ();
d515 1
a515 1
	void	(*func) ();	/* Function to call when read occures */
d517 1
a517 1
	void	(*die) ();	/* Function: call when client dies or closes */
@


1.19
log
@clean up some unused/MS-DOS® stuff
@
text
@d34 1
a34 1
typedef struct entry HENTRY;
d144 2
a145 2
	unsigned char	*name;		/* Command name */
	int	flag;		/* Execution flags */
d148 1
a149 1
	unsigned char	*negarg;	/* Command to use if arg was negative */
d178 2
a179 2
struct entry {
	unsigned char	*name;
d332 1
a332 1
struct hentry {
d445 2
a446 2
	struct hentry	*htab;
	struct hentry	*ary;
@


1.18
log
@fix strict aliasing problems \o/
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.17 2017/12/02 17:00:50 tg Exp $");
a337 17

#ifdef __MSDOS__

struct scrn {
	int	li;		/* Height of screen */
	int	co;		/* Width of screen */
	short	*scrn;		/* Buffer */
	int	scroll;
	int	insdel;
	int	*updtab;	/* Lines which need to be updated */
	/* HIGHLIGHT_STATE *syntab; */ /* Syntax highlight state at start of each line */
	int	*syntab;
	int	*compose;
	int	*sary;
};

#else
a447 1
#endif
@


1.17
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d5 1
a5 1
__IDSTRING(rcsid_types_h, "$MirOS: contrib/code/jupp/types.h,v 1.16 2017/12/02 02:07:33 tg Exp $");
d9 1
@


1.16
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
@


1.15
log
@constify “huh” (… huh‽)
@
text
@a0 2
/* $MirOS: contrib/code/jupp/types.h,v 1.13 2014/07/25 21:41:49 tg Exp $ */

d4 3
a6 1
#include "config.h"
a10 14
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>				/* we need pid_t */
#endif

/* from mksh */
#if defined(DEBUG) || defined(__COVERITY__)
#define mkssert(e)	do { if (!(e)) exit(255); } while (/* CONSTCOND */ 0)
#else
#define mkssert(e)	do { } while (/* CONSTCOND */ 0)
#endif

/* from mksh */
#define NELEM(a)	(sizeof(a) / sizeof((a)[0]))

@


1.14
log
@update mkssert() definition from MirBSD
@
text
@d303 1
a303 1
	unsigned char	*huh;		/* Name of window for context sensitive hlp */
@


1.13
log
@make NELEM more widely available
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.12 2013/08/19 18:25:44 tg Exp $ */
d15 1
d17 1
a17 1
#define mkssert(e)	((e) ? (void)0 : exit(255))
d19 1
a19 1
#define mkssert(e)	((void)0)
@


1.12
log
@On SIGWINCH, resize menu to avoid using stale columns information

This caused an invalid memory access because the number of entries
per line was not recalculated.

Reported by Natureshadow; found by Eike Tim Jesinghaus
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.11 2012/12/30 21:45:17 tg Exp $ */
d21 3
@


1.11
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.9 2012/12/22 00:06:14 tg Exp $ */
d332 1
@


1.10
log
@more const cleanliness (and merr is used in a signal handler so it should be volatile), and use NULL not 0 for pointers
@
text
@d497 2
@


1.9
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.8 2012/06/08 16:55:28 tg Exp $ */
d297 2
a298 2
	unsigned char	*msgt;		/* Message at top of window */
	unsigned char	*msgb;		/* Message at bottom of window */
@


1.8
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.7 2012/06/07 23:38:17 tg Exp $ */
d15 6
@


1.7
log
@use less (slightly different) copies of licences, and allow (even static) linking with an {,L}GPLv[23]{,+} libc/libtermcap/libselinux/…
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.6 2011/07/03 00:35:05 tg Exp $ */
a29 10
#ifdef junk					/* These are now defined in config.h */

/* Minimum page size for MS-DOS is 128 (for 32K vheaders table) or 256 (for
 * 64K vheaders table) */
#define PGSIZE 512		/* Page size in bytes (Must be power of 2) */
#define LPGSIZE 9		/* LOG base 2 of PGSIZE */
#define ILIMIT (PGSIZE*128L)	/* Max amount to buffer */
#define HTSIZE 128		/* Entries in hash table.  Must be pwr of 2 */
#endif

@


1.6
log
@dynamic help string needed, e.g. jpico has ^G for help…
@
text
@d1 1
a1 19
/* $MirOS: contrib/code/jupp/types.h,v 1.5 2009/10/18 14:52:57 tg Exp $ */

/*-
 * This file is part of JUPP, a variant of Joe's Own Editor.
 *
 * JUPP is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 1 (February 1989), as shown
 * in the file COPYING in the JUPP source distribution.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */
@


1.5
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.4 2006/12/11 23:54:50 tg Exp $ */
d132 1
@


1.4
log
@mostly administrative licence sync w/ current template
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.3 2006/11/11 01:51:20 tg Exp $ */
d152 1
@


1.3
log
@licencing info update
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/types.h,v 1.2 2006/11/10 23:23:31 tg Exp $ */
d11 8
a18 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
@


1.2
log
@* types.h, rc.c: extend per-file options by new "vispace" (visible spaces)
* rc.c: assign options menu entry for "vispace"
* bw.c: implement "vispace" by displaying a replacement character for any
  space or a tab's first column if enabled
* charmap.h: increment unicode-to-8bit mapping table size
* charmap.c: ensure the two replacement characters we use in bw.c for the
  visibled spaces and tabs are always mapped to something
* rc.c: make "noxon" an options menu entry and move it and "keepup" to top
* rc.c: fix out-of-bounds in options menu routines
@
text
@d1 19
a19 1
/* $MirOS$ */
@


1.1
log
@Initial revision
@
text
@d1 2
d133 1
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
