head	1.40;
access;
symbols
	joe-3_1jupp38:1.40
	joe-3_1jupp37:1.39
	joe-3_1jupp36:1.35
	joe-3_1jupp35:1.35
	joe-3_1jupp34:1.35
	joe-3_1jupp33:1.35
	joe-3_1jupp32:1.28
	joe-2_8jupp3:1.1.21.1.2.1
	joe-3_1jupp31:1.15
	joe-3_1jupp30:1.15
	joe-3_1jupp29:1.15
	joe-3_1jupp28:1.12
	joe-3_1jupp27:1.11
	joe-3_1jupp26:1.11
	joe-3_1jupp25:1.11
	joe-3_1jupp24:1.11
	joe-3_1jupp23:1.11
	joe-3_1jupp22:1.10
	joe-3_1jupp21:1.10
	joe-3_1jupp20:1.10
	joe-3_1jupp19:1.10
	joe-3_1jupp18:1.9
	joe-3_1jupp17:1.9
	joe-2_8jupp2:1.1.21.1.2.1
	joe-3_1jupp16:1.9
	joe-3_1jupp15:1.8
	joe-3_1jupp14:1.8
	joe-3_1jupp12:1.7
	joe-3_1jupp11:1.6
	joe-2_8jupp1:1.1.21.1.2.1
	joe-3_1jupp10:1.6
	joe-3_1jupp9:1.6
	joe-3_1jupp8:1.6
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.40
date	2018.11.11.18.15.37;	author tg;	state Exp;
branches;
next	1.39;
commitid	1005BE871D325833018;

1.39
date	2018.06.28.01.18.32;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005B34377445239827;

1.38
date	2018.06.27.23.53.24;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005B342383170DB0AC;

1.37
date	2018.06.27.23.49.11;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005B34228C09C12D52;

1.36
date	2018.06.26.20.23.34;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005B32A0D42EFE67E9;

1.35
date	2018.01.08.02.01.18;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A52D0FA22192115;

1.34
date	2018.01.07.21.31.36;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A5291D24C832BCA;

1.33
date	2018.01.07.20.32.45;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A5284063C3E386D;

1.32
date	2018.01.06.00.28.29;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A50184621FA8455;

1.31
date	2017.12.20.23.19.14;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A3AF00342723BA6;

1.30
date	2017.12.20.22.32.13;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A3AE4FA577E7E77;

1.29
date	2017.12.20.22.19.03;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A3AE093564BD5FE;

1.28
date	2017.12.08.02.28.04;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A29F8C708B176AB;

1.27
date	2017.12.08.02.17.20;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A29F64A06DEB239;

1.26
date	2017.12.08.02.00.38;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A29F2506E789D2B;

1.25
date	2017.12.06.23.17.32;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A287AA407E73F9C;

1.24
date	2017.12.06.21.16.54;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A285E5918D423C7;

1.23
date	2017.12.06.16.37.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A281CE76609B21C;

1.22
date	2017.12.04.22.15.37;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A25C91E16B3B365;

1.21
date	2017.12.04.21.53.33;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A25C3E151C5344D;

1.20
date	2017.12.03.02.36.00;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A2363204B0C4612;

1.19
date	2017.12.02.18.50.02;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A22F5E2328F5222;

1.18
date	2017.12.02.04.32.37;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A222CF2122034D9;

1.17
date	2017.12.02.02.07.22;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A220AD65C90E687;

1.16
date	2017.12.02.00.16.43;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A21F0FB306AFC87;

1.15
date	2016.10.08.17.42.12;	author tg;	state Exp;
branches;
next	1.14;
commitid	10057F930072AAB610A;

1.14
date	2016.10.07.19.37.45;	author tg;	state Exp;
branches;
next	1.12;
commitid	10057F7F99A58419A51;

1.12
date	2014.10.23.16.10.27;	author tg;	state Exp;
branches;
next	1.11;
commitid	100544928830E6B4DD2;

1.11
date	2012.12.22.00.06.09;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050D4F965570AEE79;

1.10
date	2012.06.07.22.16.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004FD12822341B4DF9;

1.9
date	2011.07.16.21.57.55;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004E2209506F4A1334;

1.8
date	2010.04.08.15.31.00;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004BBDF6C54CC9A0DB;

1.7
date	2009.10.18.16.00.32;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004ADB3BAE14008257;

1.6
date	2007.02.18.22.34.07;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045D8D46C7CE52506;

1.5
date	2007.02.18.22.23.54;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D8D1DC2DC9B867;

1.4
date	2007.02.18.21.53.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045D8CADE3C5AC949;

1.3
date	2007.02.18.21.35.01;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045D8C6900510B4E7;

1.2
date	2005.02.05.02.42.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.17;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.20;	author tg;	state Exp;
branches
	1.1.21.1.2.1;
next	;

1.1.21.1.2.1
date	2005.02.12.15.43.35;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.17;	author tg;	state Exp;
branches;
next	;


desc
@@


1.40
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Editor engine
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#define EXTERN_B_C
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.39 2018/06/28 01:18:32 tg Exp $");

#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pwd.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_TIME_H
#include <time.h>
#endif

#include "b.h"
#include "blocks.h"
#include "main.h"
#include "path.h"
#include "queue.h"
#include "rc.h"
#include "scrn.h"
#include "uerror.h"
#include "undo.h"
#include "utils.h"
#include "va.h"
#include "vfile.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"

#if !HAVE_DECL_CTIME
char *ctime(const time_t *);
#endif
#if !HAVE_DECL_POPEN
FILE *popen(const char *, const char *);
int pclose(FILE *);
#endif

unsigned char stdbuf[stdsiz];

int guesscrlf = 0;
int guessindent = 0;

int error;
int force = 0;
VFILE *vmem;

static int brch_u8(P *);

const unsigned char *msgs[] = {
	UC "No error",
	UC "New File",
	UC "Error reading file",
	UC "Error seeking file",
	UC "Error opening file",
	UC "Error writing file",
	UC "File on disk is newer"
};

/* Get size of gap (amount of free space) */
#define GGAPSZ(hdr) ((hdr)->ehole - (hdr)->hole)

/* Get number of characters in gap buffer */
#define GSIZE(hdr) (SEGSIZ - GGAPSZ(hdr))

/* Get char from buffer (with jumping around the gap) */
#define GCHAR(p) ((p)->ofst >= (p)->hdr->hole ? (p)->ptr[(p)->ofst + GGAPSZ((p)->hdr)] \
					      : (p)->ptr[(p)->ofst])

/* Set position of gap */
static void gstgap(H *hdr, unsigned char *ptr, int ofst)
{
	if (ofst > hdr->hole) {
		mmove(ptr + hdr->hole, ptr + hdr->ehole, ofst - hdr->hole);
		vchanged(ptr);
	} else if (ofst < hdr->hole) {
		mmove(ptr + hdr->ehole - (hdr->hole - ofst), ptr + ofst, hdr->hole - ofst);
		vchanged(ptr);
	}
	hdr->ehole = ofst + hdr->ehole - hdr->hole;
	hdr->hole = ofst;
}

/* Insert a block */
static void ginsm(H *hdr, unsigned char *ptr, int ofst, const unsigned char *blk, int size)
{
	if (ofst != hdr->hole)
		gstgap(hdr, ptr, ofst);
	mmove(ptr + hdr->hole, blk, size);
	hdr->hole += size;
	vchanged(ptr);
}

/* Read block */
static void grmem(H *hdr, unsigned char *ptr, int ofst, unsigned char *blk, int size)
{
	if (ofst < hdr->hole)
		if (size > hdr->hole - ofst) {
			mmove(blk, ptr + ofst, hdr->hole - ofst);
			mmove(blk + hdr->hole - ofst, ptr + hdr->ehole, size - (hdr->hole - ofst));
		} else
			mmove(blk, ptr + ofst, size);
	else
		mmove(blk, ptr + ofst + hdr->ehole - hdr->hole, size);
}


static H nhdrs = { {&nhdrs, &nhdrs}, 0, 0, 0, 0 };
static H ohdrs = { {&ohdrs, &ohdrs}, 0, 0, 0, 0 };

/* Header allocation */
static H *halloc(void)
{
	H *h;

	if (qempty(H, link, &ohdrs)) {
		h = (H *) alitem(&nhdrs, sizeof(H));
		h->seg = my_valloc(vmem, (long) SEGSIZ);
	} else
		h = deque_f(H, link, ohdrs.link.next);
	h->hole = 0;
	h->ehole = SEGSIZ;
	h->nlines = 0;
	izque(H, link, h);
	return h;
}

static void hfree(H *h)
{
	enquef(H, link, &ohdrs, h);
}

static void hfreechn(H *h)
{
	splicef(H, link, &ohdrs, h);
}


static P frptrs = { {&frptrs, &frptrs}, NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, NULL };

/* Pointer allocation */
static P *palloc(void)
{
	return alitem(&frptrs, sizeof(P));
}

static void pfree(P *p)
{
	enquef(P, link, &frptrs, p);
}

/* Doubly linked list of buffers and free buffer structures */
static B bufs = { {&bufs, &bufs}, NULL, NULL, NULL, 0, 0, 0, 0, 0, NULL, { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }, { NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0 }, NULL, NULL, 0, 0, 0, 0, 0, 0 };
static B frebufs = { {&frebufs, &frebufs}, NULL, NULL, NULL, 0, 0, 0, 0, 0, NULL, { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }, { NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, 0 }, NULL, NULL, 0, 0, 0, 0, 0, 0 };

B *bnext(void)
{
	B *b;

	do {
		b = bufs.link.prev;
		deque(B, link, &bufs);
		enqueb(B, link, b, &bufs);
	} while (b->internal);
	return b;
}

B *bprev(void)
{
	B *b;

	do {
		b = bufs.link.next;
		deque(B, link, &bufs);
		enquef(B, link, b, &bufs);
	} while (b->internal);
	return b;
}

/* Make a buffer out of a chain */
static B *bmkchn(H *chn, B *prop, long amnt, long nlines)
{
	B *b = alitem(&frebufs, sizeof(B));

	b->undo = undomk(b);
	if (prop)
		b->o = prop->o;
	else
		b->o = pdefault;
	mset(b->marks, 0, sizeof(b->marks));
	b->rdonly = 0;
	b->orphan = 0;
	b->oldcur = NULL;
	b->oldtop = NULL;
	b->backup = 1;
	b->internal = 1;
	b->scratch = 0;
	b->changed = 0;
	b->count = 1;
	b->name = NULL;
	b->er = -3;
	b->bof = palloc();
	izque(P, link, b->bof);
	b->bof->end = 0;
	b->bof->b = b;
	b->bof->owner = NULL;
	b->bof->hdr = chn;
	b->bof->ptr = vlock(vmem, b->bof->hdr->seg);
	b->bof->ofst = 0;
	b->bof->byte = 0;
	b->bof->line = 0;
	b->bof->col = 0;
	b->bof->xcol = 0;
	b->bof->valcol = 1;
	b->eof = pdup(b->bof);
	b->eof->end = 1;
	vunlock(b->eof->ptr);
	b->eof->hdr = chn->link.prev;
	b->eof->ptr = vlock(vmem, b->eof->hdr->seg);
	b->eof->ofst = GSIZE(b->eof->hdr);
	b->eof->byte = amnt;
	b->eof->line = nlines;
	b->eof->valcol = 0;
	b->pid = 0;
	b->out = -1;
	enquef(B, link, &bufs, b);
	pcoalesce(b->bof);
	pcoalesce(b->eof);
	return b;
}

/* Create an empty buffer */
B *bmk(B *prop)
{
	return bmkchn(halloc(), prop, 0L, 0L);
}


extern B *errbuf;

/* Eliminate a buffer */
void brm(B *b)
{
	if (b && !--b->count) {
		if (b->changed)
			abrerr(b->name);
		if (b == errbuf)
			errbuf = NULL;
		if (b->undo)
			undorm(b->undo);
		hfreechn(b->eof->hdr);
		while (!qempty(P, link, b->bof))
			prm(b->bof->link.next);
		prm(b->bof);
		if (b->name)
			free(b->name);
		demote(B, link, &frebufs, b);
	}
}

P *poffline(P *p)
{
	if (p->ptr) {
		vunlock(p->ptr);
		p->ptr = NULL;
	}
	return p;
}

P *ponline(P *p)
{
	if (!p->ptr)
		p->ptr = vlock(vmem, p->hdr->seg);
	return p;
}

B *boffline(B *b)
{
	P *p = b->bof;

	do {
		poffline(p);
	} while ((p = p->link.next) != b->bof);
	return b;
}

B *bonline(B *b)
{
	P *p = b->bof;

	do {
		ponline(p);
	} while ((p = p->link.next) != b->bof);
	return b;
}

P *pdup(P *p)
{
	P *n = palloc();

	n->end = 0;
	n->ptr = NULL;
	n->owner = NULL;
	enquef(P, link, p, n);
	return pset(n, p);
}

P *pdupown(P *p, P **o)
{
	P *n = palloc();

	n->end = 0;
	n->ptr = NULL;
	n->owner = o;
	enquef(P, link, p, n);
	pset(n, p);
	if (*o)
		prm(*o);
	*o = n;
	return n;
}

void prm(P *p)
{
	if (!p)
		return;
	if (p->owner)
		*p->owner = NULL;
	if (p->ptr)
		vunlock(p->ptr);
	pfree(deque_f(P, link, p));
}

P *pset(P *n, P *p)
{
	if (n != p) {
		n->b = p->b;
		n->ofst = p->ofst;
		n->hdr = p->hdr;
		if (n->ptr)
			vunlock(n->ptr);
		if (p->ptr) {
			n->ptr = p->ptr;
			vupcount(n->ptr);
		} else
			n->ptr = vlock(vmem, n->hdr->seg);
		n->byte = p->byte;
		n->line = p->line;
		n->col = p->col;
		n->valcol = p->valcol;
	}
	return n;
}

P *p_goto_bof(P *p)
{
	return pset(p, p->b->bof);
}

P *p_goto_eof(P *p)
{
	return pset(p, p->b->eof);
}

/* is p at the beginning of file? */
int pisbof(P *p)
{
	return p->hdr == p->b->bof->hdr && !p->ofst;
}

/* is p at the end of file? */
int piseof(P *p)
{
	return p->ofst == GSIZE(p->hdr);
}

/* is p at the end of line? */
int piseol(P *p)
{
	int c;

	if (piseof(p))
		return 1;
	c = brc(p);
	if (c == '\n')
		return 1;
	if (p->b->o.crlf)
		if (c == '\r') {
			P *q = pdup(p);

			pfwrd(q, 1L);
			if (pgetb(q) == '\n') {
				prm(q);
				return 1;
			} else
				prm(q);
		}
	return 0;
}

/* is p at the beginning of line? */
int pisbol(P *p)
{
	int c;

	if (pisbof(p))
		return 1;
	c = prgetb(p);
	pgetb(p);
	return c == '\n';
}

/* is p at the beginning of word? */
int pisbow(P *p)
{
	P *q = pdup(p);
	int c = brc(p);
	int d = prgetc(q);

	prm(q);
	if (joe_isalnux(p->b->o.charmap,c) && (!joe_isalnux(p->b->o.charmap,d) || pisbof(p)))
		return 1;
	else
		return 0;
}

/* is p at the end of word? */
int piseow(P *p)
{
	P *q = pdup(p);
	int d = brc(q);
	int c = prgetc(q);

	prm(q);
	if (joe_isalnux(p->b->o.charmap,c) && (!joe_isalnux(p->b->o.charmap,d) || piseof(p)))
		return 1;
	else
		return 0;
}

/* is p on the blank line (ie. full of spaces/tabs)? */
int pisblank(P *p)
{
	P *q = pdup(p);

	p_goto_bol(q);
	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetb(q);
	if (piseol(q)) {
		prm(q);
		return 1;
	} else {
		prm(q);
		return 0;
	}
}

/* is p at end of line or spaces followed by end of line? */
int piseolblank(P *p)
{
	P *q = pdup(p);

	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetb(q);
	if (piseol(q)) {
		prm(q);
		return 1;
	} else {
		prm(q);
		return 0;
	}
}

/* return column of first nonblank character */
long pisindent(P *p)
{
	P *q = pdup(p);
	long col;

	p_goto_bol(q);
	while (joe_isblank(p->b->o.charmap,brc(q)))
		pgetc(q);
	col = q->col;
	prm(q);
	return col;
}

/* return true if all characters to left of cursor match c */

int pispure(P *p,int c)
{
	P *q = pdup(p);
	p_goto_bol(q);
	while (q->byte!=p->byte)
		if (pgetc(q)!=c) {
			prm(q);
			return 0;
		}
	prm(q);
	return 1;
}

int pnext(P *p)
{
	if (p->hdr == p->b->eof->hdr) {
		p->ofst = GSIZE(p->hdr);
		return 0;
	}
	p->hdr = p->hdr->link.next;
	p->ofst = 0;
	vunlock(p->ptr);
	p->ptr = vlock(vmem, p->hdr->seg);
	return 1;
}

int pprev(P *p)
{
	if (p->hdr == p->b->bof->hdr) {
		p->ofst = 0;
		return 0;
	}
	p->hdr = p->hdr->link.prev;
	p->ofst = GSIZE(p->hdr);
	vunlock(p->ptr);
	p->ptr = vlock(vmem, p->hdr->seg);
	return 1;
}

/* return current byte and move p to the next byte.  column will be unchanged. */
int pgetb(P *p)
{
	unsigned char c;

	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	c = GCHAR(p);
	if (++p->ofst == GSIZE(p->hdr))
		pnext(p);
	++p->byte;
	if (c == '\n') {
		++(p->line);
		p->col = 0;
		p->valcol = 1;
	} else if (p->b->o.crlf && c == '\r') {
		if (brc(p) == '\n')
			return pgetb(p);
		else
			p->valcol = 0;
	} else {
		p->valcol = 0;
	}
	return (int)((unsigned int)c);
}

/*
 * return current character and move p to the next character.
 * column will be updated if it was valid.
 */
int
pgetc(P *p)
{
	int c, b, w, valcol;

	/* remember whether column number was valid */
	valcol = p->valcol;

	/* get first byte */
	if ((b = pgetb(p)) == NO_MORE_DATA)
		return (b);

	if (p->b->o.charmap->type) {
		struct utf8_sm utf8_sm;

		utf8_init(&utf8_sm);
 decode:
		switch ((c = utf8_decode(&utf8_sm, b))) {
		case -1:
			if ((b = brc(p)) != NO_MORE_DATA &&
			    /* due to pgetb() interpreting control chars */
			    (b & 0x80)) {
				pgetb(p);
				goto decode;
			}
			--utf8_sm.ptr;
			/* FALLTHROUGH */
		case -2:
			pbkwd(p, utf8_sm.ptr);
			c = 0x80000000 | (int)((unsigned int)utf8_sm.buf[0]);
			w = 1;
			break;
		case -3:
			c = 0x80000000 | b;
			w = 1;
			break;
		default:
			w = joe_wcwidth(c);
			break;
		}
	} else {
		c = b;
		w = 1;
	}

	/* update column number if it was valid to start with */
	if (valcol) {
		p->valcol = 1;
		switch (c) {
		case '\t':
			p->col += p->b->o.tab - p->col % p->b->o.tab;
			break;
		case '\n':
			p->col = 0;
			break;
		default:
			p->col += w;
			break;
		}
	}

	return (c);
}

/* move p n characters forward */
P *pfwrd(P *p, long n)
{
	if (!n)
		return p;
	p->valcol = 0;
	do {
		if (p->ofst == GSIZE(p->hdr))
			do {
				if (!p->ofst) {
					p->byte += GSIZE(p->hdr);
					n -= GSIZE(p->hdr);
					p->line += p->hdr->nlines;
				}
				if (!pnext(p))
					return NULL;
			} while (n > GSIZE(p->hdr));
		if (GCHAR(p) == '\n')
			++p->line;
		++p->byte;
		++p->ofst;
	} while (--n);
	if (p->ofst == GSIZE(p->hdr))
		pnext(p);
	return p;
}

/* move p to the previous byte: does not take into account -crlf mode */
static int prgetb1(P *p)
{
	unsigned char c;

	if (!p->ofst)
		if (!pprev(p))
			return NO_MORE_DATA;
	--p->ofst;
	c = GCHAR(p);
	--p->byte;
	p->valcol = 0;
	if (c == '\n')
		--p->line;
	return c;
}

/* move p to the previous byte */
int prgetb(P *p)
{
	int c = prgetb1(p);

	if (p->b->o.crlf && c == '\n') {
		c = prgetb1(p);
		if (c == '\r')
			return '\n';
		if (c != NO_MORE_DATA)
			pgetb(p);
		c = '\n';
	}
	return c;
}

/* move p to the previous character (try to keep col updated) */
int
prgetc(P *p)
{
	P *q, *r;

	if (!p->b->o.charmap->type || pisbol(p))
		return (prgetb(p));

	q = pdup(p);
	p_goto_bol(q);
	r = pdup(q);
	while (q->byte < p->byte) {
		pset(r, q);
		pgetc(q);
	}
	pset(p, r);
	prm(r);
	prm(q);
	return (brch_u8(p));
}

/* move p n characters backwards */
P *pbkwd(P *p, long n)
{
	if (!n)
		return p;
	p->valcol = 0;
	do {
		if (!p->ofst)
			do {
				if (p->ofst) {
					p->byte -= p->ofst;
					n -= p->ofst;
					p->line -= p->hdr->nlines;
				}
				if (!pprev(p))
					return NULL;
			} while (n > GSIZE(p->hdr));
		--p->ofst;
		--p->byte;
		if (GCHAR(p) == '\n')
			--p->line;
	} while (--n);
	return p;
}

/* move p n characters forwards/backwards according to loc */
P *pgoto(P *p, long loc)
{
	if (loc > p->byte)
		pfwrd(p, loc - p->byte);
	else if (loc < p->byte)
		pbkwd(p, p->byte - loc);
	return p;
}

/* make p->col valid */
P *pfcol(P *p)
{
	long pos = p->byte;

	p_goto_bol(p);
	while (p->byte < pos)
		pgetc(p);
	return p;
}

/* move p to the beginning of line */
P *p_goto_bol(P *p)
{
	if (pprevl(p))
		pgetb(p);
	p->col = 0;
	p->valcol = 1;
	return p;
}

/* move p to the indentation point */
P *p_goto_indent(P *p, int c)
{
	int d;
	p_goto_bol(p);
	while ((d=brc(p)), d==c || ((c==' ' || c=='\t') && (d==' ' || d=='\t')))
		pgetc(p);
	return p;
}

/* move p to the end of line */
P *p_goto_eol(P *p)
{
	if (p->b->o.crlf || p->b->o.charmap->type)
		while (!piseol(p))
			pgetc(p);
	else
		while (p->ofst != GSIZE(p->hdr)) {
			unsigned char c;

			c = GCHAR(p);
			if (c == '\n')
				break;
			else {
				++p->byte;
				++p->ofst;
				if (c == '\t')
					p->col += p->b->o.tab - p->col % p->b->o.tab;
				else
					++p->col;
				if (p->ofst == GSIZE(p->hdr))
					pnext(p);
			}
		}
	return p;
}

/* move p to the beginning of next line */
P *pnextl(P *p)
{
	int c;

	do {
		if (p->ofst == GSIZE(p->hdr))
			do {
				p->byte += GSIZE(p->hdr) - p->ofst;
				if (!pnext(p))
					return NULL;
			} while (!p->hdr->nlines);
		c = GCHAR(p);
		++p->byte;
		++p->ofst;
	} while (c != '\n');
	++p->line;
	p->col = 0;
	p->valcol = 1;
	if (p->ofst == GSIZE(p->hdr))
		pnext(p);
	return p;
}

/* move p to the end of previous line */
P *pprevl(P *p)
{
	int c;

	p->valcol = 0;
	do {
		if (!p->ofst)
			do {
				p->byte -= p->ofst;
				if (!pprev(p))
					return NULL;
			} while (!p->hdr->nlines);
		--p->ofst;
		--p->byte;
		c = GCHAR(p);
	} while (c != '\n');
	--p->line;
	if (p->b->o.crlf && c == '\n') {
		int k = prgetb1(p);

		if (k != '\r' && k != NO_MORE_DATA)
			pgetb(p);
	}
	return p;
}

/* move p to the given 'line' line */
P *pline(P *p, long line)
{
	if (line > p->b->eof->line) {
		pset(p, p->b->eof);
		return p;
	}
	if (line < labs(p->line - line))
		pset(p, p->b->bof);
	if (labs(p->b->eof->line - line) < labs(p->line - line))
		pset(p, p->b->eof);
	if (p->line == line) {
		p_goto_bol(p);
		return p;
	}
	while (line > p->line)
		pnextl(p);
	if (line < p->line) {
		while (line < p->line)
			pprevl(p);
		p_goto_bol(p);
	}
	return p;
}

/* move p to the given 'goalcol' column */
/* lands at exact column or on character which would cause us to go past goalcol */
P *pcol(P *p, long goalcol)
{
	p_goto_bol(p);
	if(p->b->o.charmap->type) {
		do {
			int c;
			int wid;

			c = brch_u8(p);

			if (c == NO_MORE_DATA)
				break;

			if (c == '\n')
				break;

			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;

			if (c == '\t')
				wid = p->b->o.tab - p->col % p->b->o.tab;
			else
				wid = joe_wcwidth(c);

			if (p->col + wid > goalcol)
				break;

			pgetc(p);
		} while (p->col != goalcol);
	} else {
		do {
			unsigned char c;
			int wid;

			if (p->ofst == GSIZE(p->hdr))
				break;
			c = GCHAR(p);
			if (c == '\n')
				break;
			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;
			if (c == '\t')
				wid = p->b->o.tab - p->col % p->b->o.tab;
			else
				wid = 1;
			if (p->col + wid > goalcol)
				break;
			if (++p->ofst == GSIZE(p->hdr))
				pnext(p);
			++p->byte;
			p->col += wid;
		} while (p->col != goalcol);
	}
	return p;
}

/* Move to goal column, then skip backwards to just after first non-whitespace character */
P *pcolwse(P *p, long goalcol)
{
	int c;

	pcol(p, goalcol);
	do {
		c = prgetc(p);
	} while (c == ' ' || c == '\t');
	if (c != NO_MORE_DATA)
		pgetc(p);
	return p;
}

/* Move p to goalcol: stops after first character which equals or exceeds goal col (unlike
   pcol() which will stops before character which would exceed goal col) */
P *pcoli(P *p, long goalcol)
{
	p_goto_bol(p);
	if (p->b->o.charmap->type) {
		while (p->col < goalcol) {
			int c;
			c = brc(p);

			if (c == NO_MORE_DATA)
				break;

			if (c == '\n')
				break;

			if (p->b->o.crlf && c=='\r' && piseol(p))
				break;

			pgetc(p);
		}
	} else {
		while (p->col < goalcol) {
			unsigned char c;

			if (p->ofst == GSIZE(p->hdr))
				break;
			c = GCHAR(p);
			if (c == '\n')
				break;

			if (p->b->o.crlf && c == '\r' && piseol(p))
				break;

			if (c == '\t')
				p->col += p->b->o.tab - p->col % p->b->o.tab;
			else
				++p->col;
			if (++p->ofst == GSIZE(p->hdr))
				pnext(p);
			++p->byte;
		}
	}
	return p;
}

/* fill space between curent column and 'to' column with tabs/spaces */
void pfill(P *p, long to, int usetabs)
{
	if (usetabs=='\t')
		while (piscol(p) < to)
			if (p->col + p->b->o.tab - p->col % p->b->o.tab <= to) {
				binsc(p, '\t');
				pgetc(p);
			} else {
				binsc(p, ' ');
				pgetc(p);
			}
	else
		while (piscol(p) < to) {
			binsc(p, usetabs);
			pgetc(p);
		}
}

/* delete sequence of whitespaces - backwards */
void pbackws(P *p)
{
	int c;
	P *q = pdup(p);

	do {
		c = prgetc(q);
	} while (c == ' ' || c == '\t');
	if (c != NO_MORE_DATA)
		pgetc(q);
	bdel(q, p);
	prm(q);
}

static int frgetc(P *p)
{
	if (!p->ofst)
		pprev(p);
	--p->ofst;
	return GCHAR(p);
}

static void ffwrd(P *p, int n)
{
	while (n > GSIZE(p->hdr) - p->ofst) {
		n -= GSIZE(p->hdr) - p->ofst;
		if (!pnext(p))
			return;
	}
	if ((p->ofst += n) == GSIZE(p->hdr))
		pnext(p);
}

/* forward find pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *ffind(P *p, unsigned char *s, int len)
{
	long amnt = p->b->eof->byte - p->byte;
	int x;
	unsigned char table[256], c;

	if (len > amnt)
		return NULL;
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = 0; x != len - 1; ++x)
		table[s[x]] = x;
	ffwrd(p, len);
	amnt -= len;
	x = len;
	do {
		if ((c = frgetc(p)) != s[--x]) {
			if (table[c] == 255) {
				ffwrd(p, len + 1);
				amnt -= x + 1;
			} else if (x <= table[c]) {
				ffwrd(p, len - x + 1);
				--amnt;
			} else {
				ffwrd(p, len - table[c]);
				amnt -= x - table[c];
			}
			if (amnt < 0)
				return NULL;
			else
				x = len;
		}
	} while (x);
	return p;
}

/* forward find (case insensitive) pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *fifind(P *p, unsigned char *s, int len)
{
	long amnt = p->b->eof->byte - p->byte;
	int x;
	struct charmap *map = p->b->o.charmap;
	unsigned char table[256], c;

	if (len > amnt)
		return NULL;
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = 0; x != len - 1; ++x)
		table[s[x]] = x;
	ffwrd(p, len);
	amnt -= len;
	x = len;
	do {
		if ((c = joe_tolower(map,frgetc(p))) != s[--x]) {
			if (table[c] == 255) {
				ffwrd(p, len + 1);
				amnt -= x + 1;
			} else if (x <= table[c]) {
				ffwrd(p, len - x + 1);
				--amnt;
			} else {
				ffwrd(p, len - table[c]);
				amnt -= x - table[c];
			}
			if (amnt < 0)
				return NULL;
			else
				x = len;
		}
	} while (x);
	return p;
}

/* move cursor p to q's position and set p's col, line, ofst, byte etc. accordingly */
/* same as rgetto() but p is before q */
static P *getto(P *p, P *q)
{
	while (p->hdr != q->hdr || p->ofst != q->ofst) {
		if (GCHAR(p) == '\n')
			++p->line;
		++p->byte;
		++p->ofst;
		if (p->ofst == GSIZE(p->hdr))
			pnext(p);
		while (!p->ofst && p->hdr != q->hdr) {
			p->byte += GSIZE(p->hdr);
			p->line += p->hdr->nlines;
			pnext(p);
		}
	}
	return p;
}

/* find forward substring s in text pointed by p and set p after found substring */
P *pfind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p);

	if (ffind(q, s, len)) {
		getto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* same as pfind() but case insensitive */
P *pifind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p);

	if (fifind(q, s, len)) {
		getto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

static void fbkwd(P *p, int n)
{
	while (n > p->ofst) {
		n -= p->ofst;
		if (!pprev(p))
			return;
	}
	if (p->ofst >= n)
		p->ofst -= n;
	else
		p->ofst = 0;
}

static int fpgetc(P *p)
{
	int c;

	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	c = GCHAR(p);
	if (++p->ofst == GSIZE(p->hdr))
		pnext(p);
	return c;
}

/* backward find pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *frfind(P *p, unsigned char *s, int len)
{
	long amnt = p->byte;
	int x;
	unsigned char table[256], c;

	if (len > p->b->eof->byte - p->byte) {
		x = len - (p->b->eof->byte - p->byte);
		if (amnt < x)
			return NULL;
		amnt -= x;
		fbkwd(p, x);
	}
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1) ;
	x = 0;
	do {
		if ((c = fpgetc(p)) != s[x++]) {
			if (table[c] == 255) {
				fbkwd(p, len + 1);
				amnt -= len - x + 1;
			} else if (len - table[c] <= x) {
				fbkwd(p, x + 1);
				--amnt;
			} else {
				fbkwd(p, len - table[c]);
				amnt -= len - table[c] - x;
			}
			if (amnt < 0)
				return NULL;
			else
				x = 0;
		}
	} while (x != len);
	fbkwd(p, len);
	return p;
}

/* backward find (case insensitive) pattern 's' in text pointed by 'p' (Boyer-Moore algorithm) */
static P *frifind(P *p, unsigned char *s, int len)
{
	long amnt = p->byte;
	int x;
	unsigned char table[256], c;
	struct charmap *map = p->b->o.charmap;

	if (len > p->b->eof->byte - p->byte) {
		x = len - (p->b->eof->byte - p->byte);
		if (amnt < x)
			return NULL;
		amnt -= x;
		fbkwd(p, x);
	}
	if (!len)
		return p;
	p->valcol = 0;
	mset(table, 255, 256);
	for (x = len; --x; table[s[x]] = len - x - 1) ;
	x = 0;
	do {
		if ((c = joe_tolower(map,fpgetc(p))) != s[x++]) {
			if (table[c] == 255) {
				fbkwd(p, len + 1);
				amnt -= len - x + 1;
			} else if (len - table[c] <= x) {
				fbkwd(p, x + 1);
				--amnt;
			} else {
				fbkwd(p, len - table[c]);
				amnt -= len - table[c] - x;
			}
			if (amnt < 0)
				return NULL;
			else
				x = 0;
		}
	} while (x != len);
	fbkwd(p, len);
	return p;
}

/* move cursor p to q's position and set p's col, line, ofst, byte etc. accordingly */
/* same as getto() but q is before p */
static P *rgetto(P *p, P *q)
{
	while (p->hdr != q->hdr || p->ofst != q->ofst) {
		if (!p->ofst)
			do {
				if (p->ofst) {
					p->byte -= p->ofst;
					p->line -= p->hdr->nlines;
				}
				pprev(p);
			} while (p->hdr != q->hdr);
		--p->ofst;
		--p->byte;
		if (GCHAR(p) == '\n')
			--p->line;
	}
	return p;
}

/* find backward substring s in text pointed by p and set p on the first of found substring */
P *prfind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p);

	if (frfind(q, s, len)) {
		rgetto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* same as prfind() but case insensitive */
P *prifind(P *p, unsigned char *s, int len)
{
	P *q = pdup(p);

	if (frifind(q, s, len)) {
		rgetto(p, q);
		prm(q);
		return p;
	} else {
		prm(q);
		return NULL;
	}
}

/* copy text between 'from' and 'to' into new buffer */
B *bcpy(P *from, P *to)
{
	H anchor, *l;
	unsigned char *ptr;
	P *q;

	if (from->byte >= to->byte)
		return bmk(from->b);

	q = pdup(from);
	izque(H, link, &anchor);

	if (q->hdr == to->hdr) {
		l = halloc();
		ptr = vlock(vmem, l->seg);
		if (q->ofst != q->hdr->hole)
			gstgap(q->hdr, q->ptr, q->ofst);
		l->nlines = mcnt(q->ptr + q->hdr->ehole, '\n', l->hole = to->ofst - q->ofst);
		mmove(ptr, q->ptr + q->hdr->ehole, l->hole);
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
	} else {
		l = halloc();
		ptr = vlock(vmem, l->seg);
		if (q->ofst != q->hdr->hole)
			gstgap(q->hdr, q->ptr, q->ofst);
		l->nlines = mcnt(q->ptr + q->hdr->ehole, '\n', l->hole = SEGSIZ - q->hdr->ehole);
		mmove(ptr, q->ptr + q->hdr->ehole, l->hole);
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
		pnext(q);
		while (q->hdr != to->hdr) {
			l = halloc();
			ptr = vlock(vmem, l->seg);
			l->nlines = q->hdr->nlines;
			mmove(ptr, q->ptr, q->hdr->hole);
			mmove(ptr + q->hdr->hole, q->ptr + q->hdr->ehole, SEGSIZ - q->hdr->ehole);
			l->hole = GSIZE(q->hdr);
			vchanged(ptr);
			vunlock(ptr);
			enqueb(H, link, &anchor, l);
			pnext(q);
		}
		if (to->ofst) {
			l = halloc();
			ptr = vlock(vmem, l->seg);
			if (to->ofst != to->hdr->hole)
				gstgap(to->hdr, to->ptr, to->ofst);
			l->nlines = mcnt(to->ptr, '\n', to->ofst);
			mmove(ptr, to->ptr, l->hole = to->ofst);
			vchanged(ptr);
			vunlock(ptr);
			enqueb(H, link, &anchor, l);
		}
	}

	l = anchor.link.next;
	deque(H, link, &anchor);
	prm(q);

	return bmkchn(l, from->b, to->byte - from->byte, to->line - from->line);
}

/* Coalesce small blocks into a single larger one */
void pcoalesce(P *p)
{
	if (p->hdr != p->b->eof->hdr && GSIZE(p->hdr) + GSIZE(p->hdr->link.next) <= SEGSIZ - SEGSIZ / 4) {
		H *hdr = p->hdr->link.next;
		unsigned char *ptr = vlock(vmem, hdr->seg);
		int osize = GSIZE(p->hdr);
		int size = GSIZE(hdr);
		P *q;

		gstgap(hdr, ptr, size);
		ginsm(p->hdr, p->ptr, GSIZE(p->hdr), ptr, size);
		p->hdr->nlines += hdr->nlines;
		vunlock(ptr);
		hfree(deque_f(H, link, hdr));
		for (q = p->link.next; q != p; q = q->link.next)
			if (q->hdr == hdr) {
				q->hdr = p->hdr;
				if (q->ptr) {
					vunlock(q->ptr);
					q->ptr = vlock(vmem, q->hdr->seg);
				}
				q->ofst += osize;
			}
	}
	if (p->hdr != p->b->bof->hdr && GSIZE(p->hdr) + GSIZE(p->hdr->link.prev) <= SEGSIZ - SEGSIZ / 4) {
		H *hdr = p->hdr->link.prev;
		unsigned char *ptr = vlock(vmem, hdr->seg);
		int size = GSIZE(hdr);
		P *q;

		gstgap(hdr, ptr, size);
		ginsm(p->hdr, p->ptr, 0, ptr, size);
		p->hdr->nlines += hdr->nlines;
		vunlock(ptr);
		hfree(deque_f(H, link, hdr));
		p->ofst += size;
		for (q = p->link.next; q != p; q = q->link.next)
			if (q->hdr == hdr) {
				q->hdr = p->hdr;
				if (q->ptr)
					vunlock(q->ptr);
				q->ptr = vlock(vmem, q->hdr->seg);
			} else if (q->hdr == p->hdr)
				q->ofst += size;
	}
}

/* Delete the text between two pointers from a buffer and return it in a new
 * buffer.
 *
 * This routine calls these functions:
 *  gstgap	- to position gaps
 *  halloc	- to allocate new header/segment pairs
 *  vlock	- virtual memory routines
 *  vunlock
 *  vchanged
 *  vupcount
 *  mcnt	- to count NLs
 *  snip	- queue routines
 *  enqueb
 *  splicef
 *  scrdel	- to tell screen update to scroll when NLs are deleted
 *  bmkchn	- to make a buffer out of a chain
 */

/* This is only to be used for bdel() */
static B *bcut(P *from, P *to)
{
	H *h,			/* The deleted text */
	*i;
	unsigned char *ptr;
	P *p;
	long nlines;		/* No. EOLs to delete */
	long amnt;		/* No. bytes to delete */
	int toamnt;		/* Amount to delete from segment in 'to' */
	int bofmove = 0;	/* Set if bof got deleted */

	if (!(amnt = to->byte - from->byte))
		return NULL;	/* ...nothing to delete */

	nlines = to->line - from->line;

	if (from->hdr == to->hdr) {	/* Delete is within a single segment */
		/* Move gap to deletion point */
		if (from->ofst != from->hdr->hole)
			gstgap(from->hdr, from->ptr, from->ofst);

		/* Store the deleted text */
		h = halloc();
		ptr = vlock(vmem, h->seg);
		mmove(ptr, from->ptr + from->hdr->ehole, (int) amnt);
		h->hole = amnt;
		h->nlines = nlines;
		vchanged(ptr);
		vunlock(ptr);

		/* Delete */
		from->hdr->ehole += amnt;
		from->hdr->nlines -= nlines;

		toamnt = amnt;
	} else {		/* Delete crosses segments */
		H *a;

		if ((toamnt = to->ofst) != 0) {
			/* Delete beginning of to */
			/* Move gap to deletion point */
			/* To could be deleted if it's at the end of the file */
			if (to->ofst != to->hdr->hole)
				gstgap(to->hdr, to->ptr, to->ofst);

			/* Save deleted text */
			i = halloc();
			ptr = vlock(vmem, i->seg);
			mmove(ptr, to->ptr, to->hdr->hole);
			i->hole = to->hdr->hole;
			i->nlines = mcnt(to->ptr, '\n', to->hdr->hole);
			vchanged(ptr);
			vunlock(ptr);

			/* Delete */
			to->hdr->nlines -= i->nlines;
			to->hdr->hole = 0;
		} else
			i = 0;

		/* Delete end of from */
		if (!from->ofst) {
			/* ... unless from needs to be deleted too */
			a = from->hdr->link.prev;
			h = NULL;
			if (a == from->b->eof->hdr)
				bofmove = 1;
		} else {
			a = from->hdr;
			/* Move gap to deletion point */
			if (from->ofst != from->hdr->hole)
				gstgap(from->hdr, from->ptr, from->ofst);

			/* Save deleted text */
			h = halloc();
			ptr = vlock(vmem, h->seg);
			mmove(ptr, from->ptr + from->hdr->ehole, SEGSIZ - from->hdr->ehole);
			h->hole = SEGSIZ - from->hdr->ehole;
			h->nlines = mcnt(ptr, '\n', h->hole);
			vchanged(ptr);
			vunlock(ptr);

			/* Delete */
			from->hdr->nlines -= h->nlines;
			from->hdr->ehole = SEGSIZ;
		}

		/* Make from point to header/segment of to */
		from->hdr = to->hdr;
		vunlock(from->ptr);
		from->ptr = to->ptr;
		vupcount(to->ptr);
		from->ofst = 0;

		/* Delete headers/segments between a and to->hdr (if there are any) */
		if (a->link.next != to->hdr)
			if (!h) {
				h = snip(H, link, a->link.next, to->hdr->link.prev);
				if (i)
					enqueb(H, link, h, i);
			} else {
				splicef(H, link, h, snip(H, link, a->link.next, to->hdr->link.prev));
				if (i)
					enqueb(H, link, h, i);
		} else if (!h)
			h = i;
		else if (i)
			enqueb(H, link, h, i);
	}

	/* If to is empty, then it must have been at the end of the file.  If
	   the file did not become empty, delete to */
	if (!GSIZE(to->hdr) && from->byte) {
		H *ph = from->hdr->link.prev;

		hfree(deque_f(H, link, from->hdr));
		vunlock(from->ptr);
		from->hdr = ph;
		from->ptr = vlock(vmem, from->hdr->seg);
		from->ofst = GSIZE(ph);
		vunlock(from->b->eof->ptr);
		from->b->eof->ptr = from->ptr;
		vupcount(from->ptr);
		from->b->eof->hdr = from->hdr;
		from->b->eof->ofst = from->ofst;
	}

	/* The deletion is now done */

	/* Scroll if necessary */

	if (bofmove)
		pset(from->b->bof, from);
	if (nlines && !pisbol(from)) {
		scrdel(from->b, from->line, nlines, 1);
		delerr(from->b->name, from->line, nlines);
	} else {
		scrdel(from->b, from->line, nlines, 0);
		delerr(from->b->name, from->line, nlines);
	}

	/* Fix pointers */

	for (p = from->link.next; p != from; p = p->link.next)
		if (p->line == from->line && p->byte > from->byte)
			p->valcol = 0;
	for (p = from->link.next; p != from; p = p->link.next) {
		if (p->byte >= from->byte) {
			if (p->byte <= from->byte + amnt) {
				if (p->ptr) {
					pset(p, from);
				} else {
					poffline(pset(p, from));
				}
			} else {
				if (p->hdr == to->hdr)
					p->ofst -= toamnt;
				p->byte -= amnt;
				p->line -= nlines;
			}
		}
	}

	pcoalesce(from);

	/* Make buffer out of deleted text and return it */
	return bmkchn(h, from->b, amnt, nlines);
}

void bdel(P *from, P *to)
{
	if (to->byte - from->byte) {
		B *b = bcut(from, to);

		if (from->b->undo)
			undodel(from->b->undo, from->byte, b);
		else
			brm(b);
		from->b->changed = 1;
	}
}

/* Split a block at p's ofst */
/* p is placed in the new block such that it points to the same text but with
 * p->ofst==0
 */
static void bsplit(P *p)
{
	if (p->ofst) {
		H *hdr;
		unsigned char *ptr;
		P *pp;

		hdr = halloc();
		ptr = vlock(vmem, hdr->seg);

		if (p->ofst != p->hdr->hole)
			gstgap(p->hdr, p->ptr, p->ofst);
		mmove(ptr, p->ptr + p->hdr->ehole, SEGSIZ - p->hdr->ehole);
		hdr->hole = SEGSIZ - p->hdr->ehole;
		hdr->nlines = mcnt(ptr, '\n', hdr->hole);
		p->hdr->nlines -= hdr->nlines;
		vchanged(ptr);
		p->hdr->ehole = SEGSIZ;

		enquef(H, link, p->hdr, hdr);

		vunlock(p->ptr);

		for (pp = p->link.next; pp != p; pp = pp->link.next)
			if (pp->hdr == p->hdr && pp->ofst >= p->ofst) {
				pp->hdr = hdr;
				if (pp->ptr) {
					vunlock(pp->ptr);
					pp->ptr = ptr;
					vupcount(ptr);
				}
				pp->ofst -= p->ofst;
			}

		p->ptr = ptr;
		p->hdr = hdr;
		p->ofst = 0;
	}
}

/* Make a chain out of a block of memory (the block must not be empty) */
static H *bldchn(const unsigned char *blk, int size, long *nlines)
{
	H anchor, *l;

	*nlines = 0;
	izque(H, link, &anchor);
	do {
		unsigned char *ptr;
		int amnt;

		ptr = vlock(vmem, (l = halloc())->seg);
		if (size > SEGSIZ)
			amnt = SEGSIZ;
		else
			amnt = size;
		mmove(ptr, blk, amnt);
		l->hole = amnt;
		l->ehole = SEGSIZ;
		(*nlines) += (l->nlines = mcnt(ptr, '\n', amnt));
		vchanged(ptr);
		vunlock(ptr);
		enqueb(H, link, &anchor, l);
		blk += amnt;
		size -= amnt;
	} while (size);
	l = anchor.link.next;
	deque(H, link, &anchor);
#ifdef CLANG_SCAN_BUILD
	/* this can only be fixed properly by using ({ â€¦ }) in queue.h */
	ITEM = NULL;
	QUEUE = NULL;
#endif
	return l;
}

/* Insert a chain into a buffer (this does not update pointers) */
static void inschn(P *p, H *a)
{
	if (!p->b->eof->byte) {	/* P's buffer is empty: replace the empty segment in p with a */
		hfree(p->hdr);
		p->hdr = a;
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
		pset(p->b->bof, p);

		p->b->eof->hdr = a->link.prev;
		vunlock(p->b->eof->ptr);
		p->b->eof->ptr = vlock(vmem, p->b->eof->hdr->seg);
		p->b->eof->ofst = GSIZE(p->b->eof->hdr);
	} else if (piseof(p)) {	/* We're at the end of the file: append a to the file */
		p->b->eof->hdr = a->link.prev;
		spliceb(H, link, p->b->bof->hdr, a);
		vunlock(p->b->eof->ptr);
		p->b->eof->ptr = vlock(vmem, p->b->eof->hdr->seg);
		p->b->eof->ofst = GSIZE(p->b->eof->hdr);
		p->hdr = a;
		vunlock(p->ptr);
		p->ptr = vlock(vmem, p->hdr->seg);
		p->ofst = 0;
	} else if (pisbof(p)) {	/* We're at the beginning of the file: insert chain and set bof pointer */
		p->hdr = spliceb_f(H, link, p->hdr, a);
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
		pset(p->b->bof, p);
	} else {		/* We're in the middle of the file: split and insert */
		bsplit(p);
		p->hdr = spliceb_f(H, link, p->hdr, a);
		vunlock(p->ptr);
		p->ptr = vlock(vmem, a->seg);
	}
}

static void fixupins(P *p, long amnt, long nlines, H *hdr, int hdramnt)
{
	P *pp;

	if (nlines && !pisbol(p))
		scrins(p->b, p->line, nlines, 1);
	else
		scrins(p->b, p->line, nlines, 0);
	inserr(p->b->name, p->line, nlines, pisbol(p));	/* FIXME: last arg ??? */

	for (pp = p->link.next; pp != p; pp = pp->link.next)
		if (pp->line == p->line && (pp->byte > p->byte || (pp->end && pp->byte == p->byte)))
			pp->valcol = 0;
	for (pp = p->link.next; pp != p; pp = pp->link.next)
		if (pp->byte == p->byte && !pp->end)
			if (pp->ptr)
				pset(pp, p);
			else
				poffline(pset(pp, p));
		else if (pp->byte > p->byte || (pp->end && pp->byte == p->byte)) {
			pp->byte += amnt;
			pp->line += nlines;
			if (pp->hdr == hdr)
				pp->ofst += hdramnt;
		}
	if (p->b->undo)
		undoins(p->b->undo, p, amnt);
	p->b->changed = 1;
}

/* Insert a buffer at pointer position (the buffer goes away) */
P *binsb(P *p, B *b)
{
	if (b->eof->byte) {
		P *q = pdup(p);

		inschn(q, b->bof->hdr);
		b->eof->hdr = halloc();
		fixupins(q, b->eof->byte, b->eof->line, NULL, 0);
		pcoalesce(q);
		prm(q);
	}
	brm(b);
	return p;
}

/* insert memory block 'blk' at 'p' */
P *binsm(P *p, const unsigned char *blk, int amnt)
{
	long nlines;
	H *h = NULL;
	int hdramnt = 0;
	P *q;

	if (!amnt)
		return p;
	q = pdup(p);
	if (amnt <= GGAPSZ(q->hdr)) {
		h = q->hdr;
		hdramnt = amnt;
		ginsm(q->hdr, q->ptr, q->ofst, blk, amnt);
		q->hdr->nlines += (nlines = mcnt(blk, '\n', amnt));
	} else if (!q->ofst && q->hdr != q->b->bof->hdr && amnt <= GGAPSZ(q->hdr->link.prev)) {
		pprev(q);
		ginsm(q->hdr, q->ptr, q->ofst, blk, amnt);
		q->hdr->nlines += (nlines = mcnt(blk, '\n', amnt));
	} else {
		H *a = bldchn(blk, amnt, &nlines);

		inschn(q, a);
	}
	fixupins(q, (long) amnt, nlines, h, hdramnt);
	pcoalesce(q);
	prm(q);
	return p;
}

/* insert byte 'c' at 'p' */
P *binsbyte(P *p, unsigned char c)
{
	if (p->b->o.crlf && c == '\n')
		return binsm(p, UC "\r\n", 2);
	else
		return binsm(p, &c, 1);
}

/* UTF-8 encode a character and insert it */
P *binsc(P *p, int c)
{
	if (c>127 && p->b->o.charmap->type) {
		unsigned char buf[8];
		int len = utf8_encode(buf,c);
		return binsm(p,buf,len);
	} else {
		unsigned char ch = c;
		if (p->b->o.crlf && c == '\n')
			return binsm(p, UC "\r\n", 2);
		else
			return binsm(p, &ch, 1);
	}
}

/* insert zero-terminated string 's' at 'p' */
P *binss(P *p, unsigned char *s)
{
	return binsm(p, s, strlen((char *)s));
}

/* Read 'size' bytes from file or stream.  Stops and returns amnt. read
 * when requested size has been read or when end of file condition occurs.
 * Returns with -2 in error for read error or 0 in error for success.
 */
static int bkread(int fi, unsigned char *buff, int size)
{
	int a, b;

	if (!size) {
		error = 0;
		return 0;
	}
	for (a = b = 0; (a < size) && ((b = joe_read(fi, buff + a, size - a)) > 0); a += b) ;
	if (b < 0)
		error = -2;
	else
		error = 0;
	return a;
}

/* Read up to 'max' bytes from a file into a buffer */
/* Returns with 0 in error or -2 in error for read error */
B *bread(int fi, long int max)
{
	H anchor, *l;
	long lines = 0, total = 0;
	int amnt;
	unsigned char *seg;

	izque(H, link, &anchor);
	error = 0;
	while (seg = vlock(vmem, (l = halloc())->seg), !error && (amnt = bkread(fi, seg, max >= SEGSIZ ? SEGSIZ : (int) max))) {
		total += amnt;
		max -= amnt;
		l->hole = amnt;
		lines += (l->nlines = mcnt(seg, '\n', amnt));
		vchanged(seg);
		vunlock(seg);
		enqueb(H, link, &anchor, l);
	}
	hfree(l);
	vunlock(seg);
	if (!total)
		return bmk(NULL);
	l = anchor.link.next;
	deque(H, link, &anchor);
	return bmkchn(l, NULL, total, lines);
}

/* Parse file name.
 *
 * Removes ',xxx,yyy' from end of name and puts their value into skip and amnt
 * Replaces ~user/ with directory of given user unless -DJOE_NOPWNAM
 * Replaces ~/ with $HOME
 *
 * Returns new variable length string.
 */
unsigned char *
parsens(const unsigned char *s, long int *skip, long int *amnt)
{
	unsigned char *n = vsncpy(NULL, 0, sz(s));
	size_t x;

	*skip = 0;
	*amnt = LONG_MAX;
	for (x = sLEN(n) - 1; x > 0 && ((n[x] >= '0' && n[x] <= '9') || (n[x] | 0x20) == 'x'); --x)
		/* nothing */;
	if (n[x] == ',') {
		void *vp;

		n[x] = 0;
		*skip = ustol(n + x + 1, &vp, USTOL_EOS);
		for (--x; x > 0 && ((n[x] >= '0' && n[x] <= '9') || (n[x] | 0x20) == 'x'); --x)
			/* nothing */;
		if (n[x] == ',') {
			n[x] = 0;
			if (vp != NULL)
				*amnt = *skip;
			*skip = ustol(n + x + 1, NULL, USTOL_EOS);
		}
	}
	if (n[0] == '~') {
		for (x = 1; n[x] && n[x] != '/'; ++x) ;
		if (n[x] == '/') {
			if (x == 1) {
				unsigned char *z;

				s = (unsigned char *)getenv("HOME");
				z = vsncpy(NULL, 0, sz(s));
				z = vsncpy(z, sLEN(z), sz(n + x));
				vsrm(n);
				n = z;
#ifndef JOE_NOPWNAM
			} else {
				struct passwd *passwd;

				n[x] = 0;
				passwd = getpwnam((char *)(n + 1));
				n[x] = '/';
				if (passwd) {
					unsigned char *z = vsncpy(NULL, 0,
					    sz((unsigned char *)(passwd->pw_dir)));

					z = vsncpy(z, sLEN(z), sz(n + x));
					vsrm(n);
					n = z;
				}
#endif
			}
		}
	}
	return n;
}

/* Load file into new buffer and return the new buffer */
/* Returns with error set to 0 for success,
 * -1 for new file (file doesn't exist)
 * -2 for read error
 * -3 for seek error
 * -4 for open error
 */
B *
bload(const unsigned char *s)
{
	unsigned char buffer[SEGSIZ];
	FILE *fi;
	B *b = NULL;
	long skip, amnt;
	unsigned char *n;
	int nowrite = 0;
	P *p;
	int x;
	long mod_time = 0;
	struct stat sbuf;

	if (!s || !s[0]) {
		error = -1;
		b = bmk(NULL);
		setopt(b, UC "");
		b->rdonly = b->o.readonly;
		b->er = error;
		return b;
	}

	n = parsens(s, &skip, &amnt);

	/* Open file or stream */
	if (s[0] == '!') {
		nescape(maint->t);
		ttclsn();
		fi = popen((char *)(n + 1), "r");
	} else
	if (!strcmp(n, "-"))
		fi = stdin;
	else {
		fi = fopen((char *)n, "r+");
		if (!fi)
			nowrite = 1;
		else
			fclose(fi);
		fi = fopen((char *)n, "r");
		if (!fi)
			nowrite = 0;
		else if (!fstat(fileno(fi), &sbuf))
			mod_time = sbuf.st_mtime;
	}
#if HAVE_BACKSLASH_PATHS
	joesep(n);
#endif

	/* Abort if couldn't open */
	if (!fi) {
		if (errno == ENOENT)
			error = -1;
		else
			error = -4;
		goto opnerr;
	}

	/* Skip data if we need to */
	if (skip && lseek(fileno(fi), skip, 0) < 0) {
		int r;

		while (skip > SEGSIZ) {
			r = bkread(fileno(fi), buffer, SEGSIZ);
			if (r != SEGSIZ || error) {
				error = -3;
				goto err;
			}
			skip -= SEGSIZ;
		}
		skip -= bkread(fileno(fi), buffer, (int) skip);
		if (skip || error) {
			error = -3;
			goto err;
		}
	}

	/* Read from stream into new buffer */
	b = bread(fileno(fi), amnt);
	b->mod_time = mod_time;
	setopt(b,n);
	b->rdonly = b->o.readonly;

	/* Close stream */
 err:
	if (s[0] == '!')
		pclose(fi);
	else if (strcmp(n, "-"))
		fclose(fi);

 opnerr:
	if (!b) {
		/* error case */
		b = bmk(NULL);
		setopt(b,n);
		b->rdonly = b->o.readonly;
	}

	if (s[0] == '!') {
		ttopnn();
		nreturn(maint->t);
	}

	/* Set name */
	b->name = joesep((unsigned char *)strdup(s));

	/* Set flags */
	if (error || s[0] == '!' || skip || amnt != LONG_MAX) {
		b->backup = 1;
		b->changed = 0;
	} else if (!strcmp(n, "-")) {
		b->backup = 1;
		b->changed = 1;
	} else {
		b->backup = 0;
		b->changed = 0;
	}
	if (nowrite)
		b->rdonly = b->o.readonly = 1;

	/* If first line has CR-LF, assume MS-DOS file */
	if (guesscrlf) {
		p=pdup(b->bof);
		b->o.crlf = 0;
		for(x=0;x!=1024;++x) {
			int c = pgetc(p);
			if(c == '\r') {
				b->o.crlf = 1;
				break;
				}
			if(c == '\n') {
				b->o.crlf = 0;
				break;
				}
			if(c == NO_MORE_DATA)
				break;
		}
		prm(p);
	}

	/* Search backwards through file: if first indented line
	   is indented with a tab, assume indentc is tab */
	if (guessindent) {
		p=pdup(b->eof);
		for (x=0; x!=20; ++x) {
			p_goto_bol(p);
			if (pisindent(p)) {
				if (brc(p)=='\t') {
					b->o.indentc = '\t';
					b->o.istep = 1;
				} else {
					b->o.indentc = ' ';
					b->o.istep = 2;
				}
				break;
			}
			if (prgetc(p)==NO_MORE_DATA)
				break;
		}
		prm(p);
	}

	/* Eliminate parsed name */
	vsrm(n);

	b->er = error;
	return b;
}

/* Find already loaded buffer or load file into new buffer */
B *
bfind(const unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		error = -1;
		b = bmk(NULL);
		setopt(b, UC "");
		b->rdonly = b->o.readonly;
		b->internal = 0;
		b->er = error;
		return b;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !strcmp(s, b->name)) {
			if (!b->orphan)
				++b->count;
			else
				b->orphan = 0;
			error = 0;
			b->internal = 0;
			return b;
		}
	b = bload(s);
	b->internal = 0;
	return b;
}

/* Find already loaded buffer or load file into new buffer */
B *
bfind_scratch(const unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		error = -1;
		b = bmk(NULL);
		setopt(b, UC "");
		b->rdonly = b->o.readonly;
		b->internal = 0;
		b->er = error;
		return b;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !strcmp(s, b->name)) {
			if (!b->orphan)
				++b->count;
			else
				b->orphan = 0;
			error = 0;
			b->internal = 0;
			return b;
		}
	b = bmk(NULL);
	error = -1;
	setopt(b,s);
	b->internal = 0;
	b->rdonly = b->o.readonly;
	b->er = error;
	b->name = (unsigned char *)strdup((char *)s);
	b->scratch = 1;
	return b;
}

B *
bfind_reload(const unsigned char *s)
{
	B *b;
	b = bload(s);
	b->internal = 0;
	return b;
}

B *
bcheck_loaded(const unsigned char *s)
{
	B *b;

	if (!s || !s[0]) {
		return NULL;
	}
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name && !strcmp(s, b->name)) {
			return b;
		}

	return NULL;
}

unsigned char **getbufs(void)
{
	unsigned char **s = vamk(16);
	B *b;

	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->name)
			s = vaadd(s, vsncpy(NULL, 0, sz(b->name)));
	return s;
}

/* Find an orphaned buffer */
B *borphan(void)
{
	B *b;

	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->orphan) {
			b->orphan = 0;
			return b;
		}
	return NULL;
}

/* Write 'size' bytes from file beginning at 'p' to open file 'fd'.
 * Returns error.
 * error is set to -5 for write error or 0 for success.
 * Don't attempt to write past the end of the file
 */
int bsavefd(P *p, int fd, long int size)
{
	P *np = pdup(p);
	int amnt;

	while (size > (amnt = GSIZE(np->hdr) - np->ofst)) {
		if (np->ofst < np->hdr->hole) {
			if (joe_write(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
				goto err;
			if (joe_write(fd, np->ptr + np->hdr->ehole, SEGSIZ - np->hdr->ehole) < 0)
				goto err;
		} else if (joe_write(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), amnt) < 0)
			goto err;
		size -= amnt;
		pnext(np);
	}
	if (size) {
		if (np->ofst < np->hdr->hole) {
			if (size > np->hdr->hole - np->ofst) {
				if (joe_write(fd, np->ptr + np->ofst, np->hdr->hole - np->ofst) < 0)
					goto err;
				if (joe_write(fd, np->ptr + np->hdr->ehole, (int) size - np->hdr->hole + np->ofst) < 0)
					goto err;
			} else {
				if (joe_write(fd, np->ptr + np->ofst, (int) size) < 0)
					goto err;
			}
		} else {
			if (joe_write(fd, np->ptr + np->ofst + GGAPSZ(np->hdr), (int) size) < 0)
				goto err;
		}
	}
	prm(np);
	return error = 0;
 err:
	prm(np);
	return error = 5;
}

/* Save 'size' bytes beginning at 'p' in file 's' */

/* If flag is set, update original time of file if it makes
 * sense to do so (it's a normal file, we're saving with
 * same name as buffer or is about to get this name).
 */

int
bsave(P *p, unsigned char *s, long int size, int flag)
{
	FILE *f;
	long skip, amnt;
	struct stat sbuf;
	int norm = 0;
	char closemethod;

	s = parsens(s, &skip, &amnt);

	if (amnt < size)
		size = amnt;

	if (s[0] == '!') {
		nescape(maint->t);
		ttclsn();
		f = popen((char *)(s + 1), "w");
		closemethod = 2;
	} else if (s[0] == '>' && s[1] == '>') {
		f = fopen((char *)(s + 2), "a");
		closemethod = 1;
	} else if (!strcmp(s, "-")) {
		nescape(maint->t);
		ttclsn();
		f = stdout;
		closemethod = 3;
	} else if (skip || amnt != LONG_MAX) {
		f = fopen((char *)s, "r+");
		closemethod = 1;
	} else {
		f = fopen((char *)s, "w");
		norm = 1;
		closemethod = 1;
	}
#if HAVE_BACKSLASH_PATHS
	joesep(s);
#endif

	if (!f) {
		error = -4;
		goto opnerr;
	}
	fflush(f);

	if (skip && lseek(fileno(f), skip, 0) < 0) {
		error = -3;
		goto err;
	}

	bsavefd(p, fileno(f), size);

	if (!error && force && size && !skip && amnt == LONG_MAX) {
		P *q = pdup(p);
		unsigned char nl = '\n';

		pfwrd(q, size - 1);
		if (brc(q) != '\n' && joe_write(fileno(f), &nl, 1) < 0)
			error = -5;
		prm(q);
	}

 err:
	switch (closemethod) {
	case 1:
		fclose(f);
		break;
	case 2:
		pclose(f);
		break;
	case 3:
		/* do not close stdout */
		fflush(f);
		break;
	}

	/* Update orignal date of file */
	/* If it's not named, it's about to be */
	if (!error && norm && flag && (!p->b->name || !strcmp((char *)s,p->b->name))) {
		if (!stat((char *)s,&sbuf))
			p->b->mod_time = sbuf.st_mtime;
	}

 opnerr:
	if (s[0] == '!' || !strcmp(s, "-")) {
		ttopnn();
		nreturn(maint->t);
	}
	return error;
}

/* Return byte at p */

int brc(P *p)
{
	if (p->ofst == GSIZE(p->hdr))
		return NO_MORE_DATA;
	return ((int)((unsigned int)(unsigned char)GCHAR(p)));
}

/* Return character at p */

int
brch(P *p)
{
	return (p->b->o.charmap->type ? brch_u8(p) : brc(p));
}

static int
brch_u8(P *p)
{
	P *q = pdup(p);
	int c = pgetc(q);
	prm(q);
	return (c);
}

unsigned char *brmem(P *p, unsigned char *blk, int size)
{
	unsigned char *bk = blk;
	P *np;
	int amnt;

	np = pdup(p);
	while (size > (amnt = GSIZE(np->hdr) - np->ofst)) {
		grmem(np->hdr, np->ptr, np->ofst, bk, amnt);
		bk += amnt;
		size -= amnt;
		pnext(np);
	}
	if (size)
		grmem(np->hdr, np->ptr, np->ofst, bk, size);
	prm(np);
	return blk;
}

unsigned char *brs(P *p, int size)
{
	unsigned char *s = malloc(size + 1);

	s[size] = 0;
	return brmem(p, s, size);
}

unsigned char *brvs(P *p, int size)
{
	unsigned char *s = vstrunc(NULL, size);

	return brmem(p, (unsigned char *)s, size);
}

unsigned char *brzs(P *p, unsigned char *buf, int size)
{
	P *q=pdup(p);
	p_goto_eol(q);

	if(q->byte-p->byte<size)
		size = q->byte - p->byte;

	prm(q);
	brmem(p,buf,size);
	buf[size]=0;
	return buf;
}

/* Save edit buffers when editor dies */

RETSIGTYPE
ttsig(int sig)
{
	ttabrt(sig, NULL);
	_exit(1);
}

void
ttabrt(int sig, const char *msg)
{
	time_t tim = time(NULL);
	B *b;
	FILE *f;
	int tmpfd;
	struct stat sbuf;

	if (msg) {
		fprintf(stderr, "\r\n*** Aborting JOE because: %s ***\r\n", msg);
		fflush(stderr);
	}

	if ((tmpfd = open("DEADJOE", O_RDWR | O_EXCL | O_CREAT, 0600)) < 0) {
		struct stat cbuf;

		if (lstat("DEADJOE", &sbuf) < 0)
			_exit(-1);
		if (!S_ISREG(sbuf.st_mode) || sbuf.st_uid != geteuid())
			_exit(-1);
		if ((tmpfd = open("DEADJOE", O_RDWR | O_APPEND)) < 0)
			_exit(-1);
		/* https://stackoverflow.com/a/2917482/2171120 */
		if (fstat(tmpfd, &cbuf) < 0 ||
		    cbuf.st_dev != sbuf.st_dev || cbuf.st_ino != sbuf.st_ino)
			_exit(-1);
		if (fchmod(tmpfd, S_IRUSR | S_IWUSR) < 0)
			_exit(-1);
	}
	if ((f = fdopen(tmpfd, "a")) == NULL)
		_exit(-1);

	fprintf(f, "\n*** Modified files in JOE when it aborted on %s", ctime(&tim));
	if (msg)
		fprintf(f, "*** JOE was aborted: %s\n", msg);
	else if (sig)
		fprintf(f, "*** JOE was aborted by signal %d\n", sig);
	else
		fprintf(f, "*** JOE was aborted because the terminal closed\n");
	fflush(f);
	for (b = bufs.link.next; b != &bufs; b = b->link.next)
		if (b->changed) {
			if (b->name)
				fprintf(f, "\n*** File \'%s\'\n", b->name);
			else
				fprintf(f, "\n*** File \'(Unnamed)\'\n");
			fflush(f);
			bsavefd(b->bof, fileno(f), b->eof->byte);
		}
	fclose(f);
	if (sig)
		ttclsn();
}
@


1.39
log
@fix (and harmonise!) some Unicode decoding issues during yak shaving
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.33 2018/01/07 20:32:45 tg Exp $");
d2048 1
a2048 2
		if (fi) {
			fstat(fileno(fi),&sbuf);
a2049 1
		}
d2341 2
a2342 1
int bsave(P *p, unsigned char *s, long int size, int flag)
d2348 1
d2359 2
a2360 1
	} else if (s[0] == '>' && s[1] == '>')
d2362 2
a2363 1
	else if (!strcmp(s, "-")) {
d2367 2
a2368 1
	} else if (skip || amnt != LONG_MAX)
d2370 2
a2371 1
	else {
d2374 1
d2404 5
a2408 1
	if (s[0] == '!')
d2410 3
a2412 3
	else if (strcmp(s, "-"))
		fclose(f);
	else
d2414 2
@


1.38
log
@refactor utf-8 specific stuff for possibly more speed
@
text
@d562 1
a562 1
	return c;
d565 6
a570 2
/* return current character and move p to the next character.  column will be updated if it was valid. */
int pgetc(P *p)
d572 1
a572 2
	if (p->b->o.charmap->type) {
		int c, n, oc, wid, val;
d574 2
a575 2
		val = p->valcol;	/* Remember if column number was valid */
		c = pgetb(p);		/* Get first byte */
d577 3
a579 2
		if (c==NO_MORE_DATA)
			return c;
d581 2
a582 24
		oc = c;			/* Save in case of invalid sequences */

		if ((c&0x80)==0x00) {        /* One byte */
			n = 0;
		} else if ((c&0xE0)==0xC0) { /* Two bytes */
			n = 1;
			c &= 0x1F;
		} else if ((c&0xF0)==0xE0) { /* Three bytes */
			n = 2;
			c &= 0x0F;
		} else if ((c&0xF8)==0xF0) { /* Four bytes */
			n = 3;
			c &= 0x07;
		} else if ((c&0xFC)==0xF8) { /* Five bytes */
			n = 4;
			c &= 0x03;
		} else if ((c&0xFE)==0xFC) { /* Six bytes */
			n = 5;
			c &= 0x01;
		} else { /* 128-191, 254, 255: Not a valid UTF-8 start character */
 eilseq:
			n = 0;
			c = 0x80000000 | (oc & 0xFF);
		}
d584 7
a590 7
		if (n) {
			int d, m = n;	/* Save in case of invalid sequences */

			do {
				d = brc(p);
				if (d == NO_MORE_DATA || (d&0xC0)!=0x80)
					break;
d592 16
a607 9
				c = ((c<<6)|(d&0x3F));
			} while (--n);
			if (n) { /* There was a bad UTF-8 sequence */
				pbkwd(p, m - n);
				goto eilseq;
			} else if (val)
				wid = joe_wcwidth(c);
		} else {
			wid = 1;
a608 12

		if (val) { /* Update column no. if it was valid to start with */
			p->valcol = 1;
			if (c=='\t')
				p->col += (p->b->o.tab) - (p->col) % (p->b->o.tab);
			else if (c=='\n')
				p->col = 0;
			else
				p->col += wid;
		}

		return c;
d610 3
a612 8
		unsigned char c;

		if (p->ofst == GSIZE(p->hdr))
			return NO_MORE_DATA;
		c = GCHAR(p);
		if (++p->ofst == GSIZE(p->hdr))
			pnext(p);
		++p->byte;
d614 8
a621 2
		if (c == '\n') {
			++(p->line);
d623 4
a626 11
			p->valcol = 1;
		} else if (p->b->o.crlf && c == '\r') {
			if (brc(p) == '\n')
				return pgetc(p);
			else
				++p->col;
		} else {
			if (c == '\t')
				p->col += (p->b->o.tab) - (p->col) % (p->b->o.tab);
			else
				++(p->col);
a627 1
		return c;
d629 2
d2427 1
a2427 1
	return GCHAR(p);
@


1.37
log
@remove dead code (and reformat the other)
@
text
@d58 2
d740 1
a740 1
	return (brch(p));
d922 1
a922 1
			c = brch(p);
d2460 2
a2461 1
int brch(P *p)
d2463 10
a2472 8
	if (p->b->o.charmap->type) {
		P *q = pdup(p);
		int c = pgetc(q);
		prm(q);
		return c;
	} else {
		return brc(p);
	}
@


1.36
log
@redo invalid-UTF8 char handling; fixes ^B in such
@
text
@d720 2
a721 1
int prgetc(P *p)
d723 1
a723 1
	if (p->b->o.charmap->type) {
d725 2
a726 16
		if (pisbol(p))
			return prgetb(p);
		else {
			P *q = pdup(p);
			P *r;
			p_goto_bol(q);
			r = pdup(q);
			while (q->byte<p->byte) {
				pset(r, q);
				pgetc(q);
			}
			pset(p,r);
			prm(r);
			prm(q);
			return brch(p);
		}
d728 6
a733 45
#if 0
		int d = 0;
		int c;
		int n = 0;
		int val = p->valcol;
		for(;;) {
			c = prgetb(p);
			if (c == NO_MORE_DATA)
				return NO_MORE_DATA;
			else if ((c&0xC0)==0x80) {
				d |= ((c&0x3F)<<n);
				n += 6;
			} else if ((c&0x80)==0x00) { /* One char */
				d = c;
				break;
			} else if ((c&0xE0)==0xC0) { /* Two chars */
				d |= ((c&0x1F)<<n);
				break;
			} else if ((c&0xF0)==0xE0) { /* Three chars */
				d |= ((c&0x0F)<<n);
				break;
			} else if ((c&0xF8)==0xF0) { /* Four chars */
				d |= ((c&0x07)<<n);
				break;
			} else if ((c&0xFC)==0xF8) { /* Five chars */
				d |= ((c&0x03)<<n);
				break;
			} else if ((c&0xFE)==0xFC) { /* Six chars */
				d |= ((c&0x01)<<n);
				break;
			} else { /* FIXME: Invalid (0xFE or 0xFF found) */
				break;
			}
		}

		if (val && c!='\t' && c!='\n') {
			p->valcol = 1;
			p->col -= joe_wcwidth(d);
		}

		return d;
#endif
	}
	else {
		return prgetb(p);
d735 4
@


1.35
log
@get rid of extra joe_wcwidth parameter by inlining its only remaining use
@
text
@d567 1
a567 2
		int val, c, n, wid;
		/* int m, oc; */
a570 1
		/* oc = c; */
d575 5
a579 1
		if ((c&0xE0)==0xC0) { /* Two bytes */
a593 2
		} else if ((c&0x80)==0x00) { /* One byte */
			n = 0;
d595 1
d597 1
a597 2
			c = 0x1000FFFE;
			/* c -= 384; */
a599 2
		/* m = n; */

d601 1
a601 1
			int d;
d610 3
a612 6
			if (n) { /* FIXME: there was a bad UTF-8 sequence */
				/* How to represent this? */
				/* pbkwd(p,m-n);
				c = oc - 384; */
				c = d == NO_MORE_DATA ? 0x1000FFFF : 0x1000FFFE;
				wid = 1;
@


1.34
log
@Coverity
@
text
@d619 1
a619 1
				wid = joe_wcwidth(1,c);
d783 1
a783 1
			p->col -= joe_wcwidth(1,d);
d987 1
a987 1
				wid = joe_wcwidth(1,c);
@


1.33
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.32 2018/01/06 00:28:29 tg Exp $");
d2630 1
@


1.32
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.31 2017/12/20 23:19:14 tg Exp $");
a16 1
#include <limits.h>
d2576 7
d2589 5
d2614 3
a2616 1
	if (sig)
a2631 1
	_exit(1);
@


1.31
log
@fix nil pointer deref in error path
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.30 2017/12/20 22:32:13 tg Exp $");
d60 7
a66 7
	US "No error",
	US "New File",
	US "Error reading file",
	US "Error seeking file",
	US "Error opening file",
	US "Error writing file",
	US "File on disk is newer"
d94 1
a94 1
static void ginsm(H *hdr, unsigned char *ptr, int ofst, unsigned char *blk, int size)
d1785 1
a1785 1
static H *bldchn(unsigned char *blk, int size, long *nlines)
d1904 1
a1904 1
P *binsm(P *p, unsigned char *blk, int amnt)
d1938 1
a1938 1
		return binsm(p, US "\r\n", 2);
d1953 1
a1953 1
			return binsm(p, US "\r\n", 2);
d2022 2
a2023 1
unsigned char *parsens(unsigned char *s, long int *skip, long int *amnt)
d2086 2
a2087 1
B *bload(unsigned char *s)
d2258 2
a2259 1
B *bfind(unsigned char *s)
d2288 2
a2289 1
B *bfind_scratch(unsigned char *s)
d2323 2
a2324 1
B *bfind_reload(unsigned char *s)
d2332 2
a2333 1
B *bcheck_loaded(unsigned char *s)
@


1.30
log
@change comparator to match, in the hope of convincing Coverity to DTRT
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.29 2017/12/20 22:19:03 tg Exp $");
d2101 1
a2101 1
		setopt(b,US "");
a2140 3
		b = bmk(NULL);
		setopt(b,n);
		b->rdonly = b->o.readonly;
d2177 7
d2263 1
a2263 1
		setopt(b,US "");
d2292 1
a2292 1
		setopt(b,US "");
@


1.29
log
@plug TOCTOU in DEADJOE writing, possible symlink-target DoS attack

thanks Coverity for spotting
thanks https://stackoverflow.com/users/134633/caf for a fix
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.28 2017/12/08 02:28:04 tg Exp $");
d2110 1
a2110 1
	if (n[0] == '!') {
@


1.28
log
@label indent; small tweaks while here
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.27 2017/12/08 02:17:20 tg Exp $");
d2564 2
a2565 1
RETSIGTYPE ttsig(int sig)
d2574 2
a2579 7
		/*
		   A race condition still exists between the lstat() and the open()
		   systemcall, which leads to a possible denial-of-service attack
		   by setting the file access mode to 600 for every file the
		   user executing joe has permissions to.
		   This can't be fixed w/o breacking the behavior of the orig. joe!
		 */
d2582 4
@


1.27
log
@more small tweaks
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.25 2017/12/06 23:17:32 tg Exp $");
d2173 1
a2173 1
err:
d2179 1
a2179 1
opnerr:
d2401 1
a2401 1
err:
d2468 1
a2468 1
err:
d2483 1
a2483 1
opnerr:
@


1.26
log
@donâ€™t box malloc/calloc/realloc/free; donâ€™t cast malloc result; order calloc args
@
text
@d507 1
a507 1
                }
d2065 1
a2065 1
							 sz((unsigned char *)(passwd->pw_dir)));
@


1.25
log
@whitespace at EOL annoys me
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.24 2017/12/06 21:16:54 tg Exp $");
d265 1
a265 1
			joe_free(b->name);
d2535 1
a2535 1
	unsigned char *s = (unsigned char *) joe_malloc(size + 1);
@


1.24
log
@begin overhaul for antique/header compat:
â€¢ PARAMS begone
â€¢ libc4 ustat definition: resolve inline
â€¢ ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.23 2017/12/06 16:37:40 tg Exp $");
d786 1
a786 1
		
@


1.23
log
@use ustoc_* functions
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.20 2017/12/03 02:36:00 tg Exp $");
a17 1
#ifdef HAVE_PWD_H
a18 1
#endif
@


1.22
log
@clean up some unused/MS-DOSÂ® stuff
@
text
@d2031 2
a2032 1
	for (x = sLEN(n) - 1; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
d2038 2
a2039 1
		for (--x; x > 0 && ((n[x] >= '0' && n[x] <= '9') || n[x] == 'x' || n[x] == 'X'); --x) ;
@


1.21
log
@rename alpha_ to alphx and alnum_ to alnux

â€¢ matches mksh
â€¢ stuff with trailing underscore may not be allowed in C99
@
text
@a2044 1
#ifndef __MSDOS__
a2074 1
#endif
a2109 1
#ifndef __MSDOS__
a2114 1
#endif
a2173 1
#ifndef __MSDOS__
d2176 1
a2176 3
	else
#endif
	if (strcmp(n, "-"))
a2424 1
#ifndef __MSDOS__
d2429 1
a2429 3
	} else
#endif
	if (s[0] == '>' && s[1] == '>')
a2468 1
#ifndef __MSDOS__
d2471 1
a2471 3
	else
#endif
	if (strcmp(s, "-"))
@


1.20
log
@first cut at getting rid of stdio: scanf half
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/b.c,v 1.17 2017/12/02 02:07:22 tg Exp $");
d432 1
a432 1
	if (joe_isalnum_(p->b->o.charmap,c) && (!joe_isalnum_(p->b->o.charmap,d) || pisbof(p)))
d446 1
a446 1
	if (joe_isalnum_(p->b->o.charmap,c) && (!joe_isalnum_(p->b->o.charmap,d) || piseof(p)))
@


1.19
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@d2027 1
a2027 1
	int x;
d2033 2
d2036 1
a2036 8
		if (n[x + 1] == 'x' || n[x + 1] == 'X')
			sscanf((char *)(n + x + 2), "%lx", skip);
		else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
			sscanf((char *)(n + x + 3), "%lx", skip);
		else if (n[x + 1] == '0')
			sscanf((char *)(n + x + 1), "%lo", skip);
		else
			sscanf((char *)(n + x + 1), "%ld", skip);
d2040 3
a2042 9
			*amnt = *skip;
			if (n[x + 1] == 'x' || n[x + 1] == 'X')
				sscanf((char *)(n + x + 2), "%lx", skip);
			else if (n[x + 1] == '0' && (n[x + 2] == 'x' || n[x + 2] == 'X'))
				sscanf((char *)(n + x + 3), "%lx", skip);
			else if (n[x + 1] == '0')
				sscanf((char *)(n + x + 1), "%lo", skip);
			else
				sscanf((char *)(n + x + 1), "%ld", skip);
@


1.18
log
@some fallout of the includes changes, some more reduction
@
text
@d119 2
a120 2
static H nhdrs = { {&nhdrs, &nhdrs} };
static H ohdrs = { {&ohdrs, &ohdrs} };
d150 1
a150 1
static P frptrs = { {&frptrs, &frptrs} };
d164 2
a165 2
static B bufs = { {&bufs, &bufs} };
static B frebufs = { {&frebufs, &frebufs} };
@


1.17
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
a40 1
#include "utf8.h"
@


1.16
log
@what a mess, indeed!

use LONG_MAX instead of homegrown MAXINT/MAXLONG
@
text
@a0 1
/* $MirOS: contrib/code/jupp/b.c,v 1.15 2016/10/08 17:42:12 tg Exp $ */
d8 1
d12 2
a14 2
#include <stdio.h>
#include <sys/types.h>
@


1.15
log
@fix for __CRAZY=Yes
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.11 2012/12/22 00:06:09 tg Exp $ */
d17 1
d2031 1
a2031 1
	*amnt = MAXLONG;
d2208 1
a2208 1
	if (error || s[0] == '!' || skip || amnt != MAXLONG) {
d2457 1
a2457 1
	} else if (skip || amnt != MAXLONG)
d2480 1
a2480 1
	if (!error && force && size && !skip && amnt == MAXLONG) {
@


1.14
log
@fix uninitialised warning by gcc in Debian sid
@
text
@d2146 1
d2148 1
d2462 1
d2464 1
@


1.12
log
@omit the â€œNew Fileâ€ in new scratch buffers
@
text
@d570 1
a570 1
		int val, c, d, n, wid;
d606 3
a608 1
			while (n) {
d614 1
a614 2
				--n;
			}
@


1.11
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.10 2012/06/07 22:16:08 tg Exp $ */
d61 1
a61 1
unsigned char *msgs[] = {
@


1.10
log
@â€¢ switch strlfun.c to symlinked strlfun.inc; add symlinked popen.inc
â€¢ new compat.c including the *.inc files if needed and providing ctime for klibc
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.9 2011/07/16 21:57:55 tg Exp $ */
d1813 5
@


1.9
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.8 2010/04/08 15:31:00 tg Exp $ */
d44 8
@


1.8
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.7 2009/10/18 16:00:32 tg Exp $ */
d562 2
a563 5
		int val;
		int c, oc;
		int d;
		int n, m;
		int wid;
d567 1
a567 1
		oc = c;
d595 1
a595 1
		m = n;
@


1.7
log
@slight width fix for raw octets in wtf-8 mode
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.6 2007/02/18 22:34:07 tg Exp $ */
a45 1
extern int errno;
d2008 1
a2008 1
 * Replaces ~user/ with directory of given user
d2057 1
d2072 1
@


1.6
log
@use different replacement characters - fixes cursor position (joe_wcwidthâ€¦)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/b.c,v 1.5 2007/02/18 22:23:54 tg Exp $ */
d604 1
a604 1
				if ((d&0xC0)!=0x80)
d614 2
a615 2
				wid = m - n + 1;
				c = wid == 1 ? 0x1000FFFE : 0x1000FFFF;
@


1.5
log
@display UCS-2 values for %A and "u" for %a in UTF-8 mode,
unless we have a single invalid octet, which is displayed
as if in non-UTF-8 mode, or an invalid sequence with more
than one octet, which is printed as "u" and "<-2>"
@
text
@d1 1
a1 1
/* $MirOS$ */
d595 1
a595 1
			c = 0xFFFE;
d615 1
a615 1
				c = wid == 1 ? 0xFFFE : 0xFFFF;
@


1.4
log
@display the U+FFFD in the correct width (more than once for validly
started but invalid multibyte sequences), underlined and reversed
@
text
@d1 2
a2 1
 /*
d595 1
a595 1
			c = 0xFFFD;
a613 1
				c = 0xFFFD;
d615 1
@


1.3
log
@instead of displaying invalid utf-8 as 'X' use U+FFFD - stage 1
@
text
@d614 1
a614 1
				wid = 1;
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d594 1
a594 1
			c = 'X';
d613 1
a613 1
				c = 'X';
@


1.1
log
@Initial revision
@
text
@d1899 1
a1899 1
	int hdramnt;
d2089 1
a2089 1
	B *b;
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* Editor engine
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d11 1
d13 4
a16 1
#ifndef __MSDOS__
d20 5
d26 1
a26 1
#include "config.h"
d28 6
d35 3
d39 2
a40 3
#include "va.h"
#include "zstr.h"
#include "path.h"
a41 7
#include "tty.h"
#include "scrn.h"
#include "main.h"
#include "bw.h"
#include "uerror.h"

#include "b.h"
d43 1
a43 1
char stdbuf[stdsiz];
d46 2
d50 1
a50 1
int force=0;
d53 9
a61 8
char *msgs[]=
 { 
 "Error writing file",
 "Error opening file",
 "Error seeking file",
 "Error reading file",
 "New File"
 };
d64 1
a64 2

#define GGAPSZ(hdr) ((hdr)->ehole-(hdr)->hole)
d67 1
d69 3
a71 1
#define GSIZE(hdr) (SEGSIZ-GGAPSZ(hdr))
d74 12
a85 13

static void gstgap(hdr,ptr,ofst)
H *hdr;
char *ptr;
int ofst;
 {
 if(ofst>hdr->hole)
  mfwrd(ptr+hdr->hole,ptr+hdr->ehole,ofst-hdr->hole), vchanged(ptr);
 else if(ofst<hdr->hole)
  mbkwd(ptr+hdr->ehole-(hdr->hole-ofst),ptr+ofst,hdr->hole-ofst), vchanged(ptr);
 hdr->ehole=ofst+hdr->ehole-hdr->hole;
 hdr->hole=ofst;
 }
d88 8
d97 12
a108 12
static void ginsm(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
 {
 if(ofst!=hdr->hole) gstgap(hdr,ptr,ofst);
 mcpy(ptr+hdr->hole,blk,size);
 hdr->hole+=size;
 vchanged(ptr);
 }
a109 1
/* Read block */
d111 2
a112 14
static void grmem(hdr,ptr,ofst,blk,size)
H *hdr;
char *ptr;
int ofst;
char *blk;
int size;
 {
 if(ofst<hdr->hole)
  if(size>hdr->hole-ofst)
   mcpy(blk,ptr+ofst,hdr->hole-ofst),
   mcpy(blk+hdr->hole-ofst,ptr+hdr->ehole,size-(hdr->hole-ofst));
  else mcpy(blk,ptr+ofst,size);
 else mcpy(blk,ptr+ofst+hdr->ehole-hdr->hole,size);
 }
d115 25
a140 2
static H nhdrs={{&nhdrs,&nhdrs}};
static H ohdrs={{&ohdrs,&ohdrs}};
d142 1
a142 27
static H *halloc()
 {
 H *h;
 if(qempty(H,link,&ohdrs))
  {
  h=(H *)alitem(&nhdrs,sizeof(H));
  h->seg=valloc(vmem,(long)SEGSIZ);
  }
 else h=deque(H,link,ohdrs.link.next);
 h->hole=0;
 h->ehole=SEGSIZ;
 h->nlines=0;
 izque(H,link,h);
 return h;
 }

static void hfree(h)
H *h;
 {
 enquef(H,link,&ohdrs,h);
 }

static void hfreechn(h)
H *h;
 {
 splicef(H,link,&ohdrs,h);
 }
d145 9
a153 13

static P frptrs={{&frptrs,&frptrs}};

static P *palloc()
 {
 return alitem(&frptrs,sizeof(P));
 }

static void pfree(p)
P *p;
 {
 enquef(P,link,&frptrs,p);
 }
d156 2
d159 23
a181 28
static B bufs={{&bufs,&bufs}};
static B frebufs={{&frebufs,&frebufs}};

B *bnext()
 {
 B *b;
 do
  {
  b=bufs.link.prev;
  deque(B,link,&bufs);
  enqueb(B,link,b,&bufs);
  }
  while(b->internal);
 return b;
 }

B *bprev()
 {
 B *b;
 do
  {
  b=bufs.link.next;
  deque(B,link,&bufs);
  enquef(B,link,b,&bufs);
  }
  while(b->internal);
 return b;
 }
d184 50
a233 47

static B *bmkchn(chn,prop,amnt,nlines)
H *chn;
B *prop;
long amnt, nlines;
 {
 B *b=alitem(&frebufs,sizeof(B));
 b->undo=undomk(b);
 if(prop) b->o=prop->o;
 else b->o=pdefault;
 mset(b->marks,0,sizeof(b->marks));
 b->rdonly=0;
 b->orphan=0;
 b->oldcur=0;
 b->oldtop=0;
 b->backup=1;
 b->internal=1;
 b->changed=0;
 b->count=1;
 b->name=0;
 b->er= -3;
 b->bof=palloc(); izque(P,link,b->bof);
 b->bof->end=0;
 b->bof->b=b;
 b->bof->owner=0;
 b->bof->hdr=chn;
 b->bof->ptr=vlock(vmem,b->bof->hdr->seg);
 b->bof->ofst=0;
 b->bof->byte=0;
 b->bof->line=0;
 b->bof->col=0;
 b->bof->xcol=0;
 b->bof->valcol=1;
 b->eof=pdup(b->bof);
 b->eof->end=1;
 vunlock(b->eof->ptr);
 b->eof->hdr=chn->link.prev;
 b->eof->ptr=vlock(vmem,b->eof->hdr->seg);
 b->eof->ofst=GSIZE(b->eof->hdr);
 b->eof->byte=amnt;
 b->eof->line=nlines;
 b->eof->valcol=0;
 enquef(B,link,&bufs,b);
 pcoalesce(b->bof);
 pcoalesce(b->eof);
 return b;
 }
d236 4
a240 7
B *bmk(prop)
B *prop;
 {
 return bmkchn(halloc(),prop,0L,0L);
 }

/* Eliminate a buffer */
d244 540
a783 512
void brm(b)
B *b;
 {
 if(b && !--b->count)
  {
  if(b->changed) abrerr(b->name);
  if(b==errbuf) errbuf=0;
  if(b->undo) undorm(b->undo);
  hfreechn(b->eof->hdr);
  while(!qempty(P,link,b->bof)) prm(b->bof->link.next);
  prm(b->bof);
  if(b->name) free(b->name);
  demote(B,link,&frebufs,b);
  }
 }

P *poffline(p)
P *p;
 {
 if(p->ptr)
  {
  vunlock(p->ptr);
  p->ptr=0;
  }
 return p;
 }

P *ponline(p)
P *p;
 {
 if(!p->ptr) p->ptr=vlock(vmem,p->hdr->seg);
 return p;
 }

B *boffline(b)
B *b;
 {
 P *p=b->bof;
 do poffline(p); while((p=p->link.next)!=b->bof);
 return b;
 }

B *bonline(b)
B *b;
 {
 P *p=b->bof;
 do ponline(p); while((p=p->link.next)!=b->bof);
 return b;
 }

P *pdup(p)
P *p;
 {
 P *n=palloc();
 n->end=0;
 n->ptr=0;
 n->owner=0;
 enquef(P,link,p,n);
 return pset(n,p);
 }

P *pdupown(p,o)
P *p;
P **o;
 {
 P *n=palloc();
 n->end=0;
 n->ptr=0;
 n->owner=o;
 enquef(P,link,p,n);
 pset(n,p);
 if(*o) prm(*o);
 *o=n;
 return n;
 }

void prm(p)
P *p;
 {
 if(!p) return;
 if(p->owner) *p->owner=0;
 if(p->ptr) vunlock(p->ptr);
 pfree(deque(P,link,p));
 }

P *pset(n,p)
P *n, *p;
 {
 if(n!=p)
  {
  n->b=p->b;
  n->ofst=p->ofst;
  n->hdr=p->hdr;
  if(n->ptr) vunlock(n->ptr);
  if(p->ptr) { n->ptr=p->ptr; vupcount(n->ptr); }
  else n->ptr=vlock(vmem,n->hdr->seg);
  n->byte=p->byte;
  n->line=p->line;
  n->col=p->col;
  n->valcol=p->valcol;
  }
 return n;
 }

P *pbof(p)
P *p;
 {
 return pset(p,p->b->bof);
 }

P *peof(p)
P *p;
 {
 return pset(p,p->b->eof);
 }

int pisbof(p)
P *p;
 {
 return p->hdr==p->b->bof->hdr && !p->ofst;
 }

int piseof(p)
P *p;
 {
 return p->ofst==GSIZE(p->hdr);
 }

int piseol(p)
P *p;
 {
 int c;
 if(piseof(p)) return 1;
 c=brc(p);
 if(c=='\n') return 1;
 if(p->b->o.crlf)
  if(c=='\r')
   {
   P *q=pdup(p);
   pfwrd(q,1L);
   if(pgetc(q)=='\n')
    {
    prm(q);
    return 1;
    }
   else prm(q);
   }
 return 0;
 }

int pisbol(p)
P *p;
 {
 char c;
 if(pisbof(p)) return 1;
 c=prgetc(p); pgetc(p);
 return c=='\n';
 }

int pisbow(p)
P *p;
 {
 P *q=pdup(p);
 int c=brc(p);
 int d=prgetc(q);
 prm(q);
 if(crest(c) && !crest(d)) return 1;
 else return 0;
 }

int piseow(p)
P *p;
 {
 P *q=pdup(p);
 int d=brc(q);
 int c=prgetc(q);
 prm(q);
 if(crest(c) && !crest(d)) return 1;
 else return 0;
 }

int pisblank(p)
P *p;
 {
 P *q=pdup(p);
 pbol(q);
 while(cwhite(brc(q))) pgetc(q);
 if(piseol(q))
  {
  prm(q);
  return 1;
  }
 else
  {
  prm(q);
  return 0;
  }
 }

long pisindent(p)
P *p;
 {
 P *q=pdup(p);
 long col;
 pbol(q);
 while(cwhite(brc(q))) pgetc(q);
 col=q->col;
 prm(q);
 return col;
 }

int pnext(p)
P *p;
 {
 if(p->hdr==p->b->eof->hdr)
  {
  p->ofst=GSIZE(p->hdr);
  return 0;
  }
 p->hdr=p->hdr->link.next; p->ofst=0;
 vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg);
 return 1;
 }

int pprev(p)
P *p;
 {
 if(p->hdr==p->b->bof->hdr)
  {
  p->ofst=0;
  return 0;
  }
 p->hdr=p->hdr->link.prev;
 p->ofst=GSIZE(p->hdr);
 vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg);
 return 1;
 }

int pgetc(p)
P *p;
 {
 char c;
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
 ++p->byte;
 if(c=='\n') ++p->line, p->col=0, p->valcol=1;
 else if(p->b->o.crlf && c=='\r')
  {
  if(brc(p)=='\n') return pgetc(p);
  else ++p->col;
  }
 else
  {
  if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
  else ++p->col;
  }
 return c;
 }

P *pfwrd(p,n)
P *p;
long n;
 {
 if(!n) return p;
 p->valcol=0;
 do
  {
  if(p->ofst==GSIZE(p->hdr))
   do
    {
    if(!p->ofst)
     p->byte+=GSIZE(p->hdr), n-=GSIZE(p->hdr), p->line+=p->hdr->nlines;
    if(!pnext(p)) return 0;
    }
    while(n>GSIZE(p->hdr));
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') ++p->line; }
  else if(p->ptr[p->ofst]=='\n') ++p->line;
  ++p->byte; ++p->ofst;
  }
  while(--n);
 if(p->ofst==GSIZE(p->hdr)) pnext(p);
 return p;
 }

int prgetc1(p)
P *p;
 {
 unsigned char c;
 if(!p->ofst) if(!pprev(p)) return MAXINT;
 --p->ofst;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 --p->byte;
 if(c=='\n') --p->line, p->valcol=0;
 else
  {
  if(c=='\t') p->valcol=0;
  --p->col;
  }
 return c;
 }

int prgetc(p)
P *p;
 {
 int c=prgetc1(p);
 if(p->b->o.crlf && c=='\n')
  {
  c=prgetc1(p);
  if(c=='\r') return '\n';
  if(c!=MAXINT) pgetc(p);
  c='\n';
  }
 return c;
 }

P *pbkwd(p,n)
P *p;
long n;
 {
 if(!n) return p;
 p->valcol=0;
 do
  {
  if(!p->ofst)
   do
    {
    if(p->ofst)
     p->byte-=p->ofst, n-=p->ofst, p->line-=p->hdr->nlines;
    if(!pprev(p)) return 0;
    }
    while(n>GSIZE(p->hdr));
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') --p->line; }
  else if(p->ptr[p->ofst]=='\n') --p->line;
  }
  while(--n);
 return p;
 }

P *pgoto(p,loc)
P *p;
long loc;
 {
 if(loc>p->byte) pfwrd(p,loc-p->byte);
 else if(loc<p->byte) pbkwd(p,p->byte-loc);
 return p;
 }

P *pfcol(p)
P *p;
 {
 H *hdr=p->hdr;
 int ofst=p->ofst;
 pbol(p);
 while(p->ofst!=ofst || p->hdr!=hdr) pgetc(p);
 return p;
 }

P *pbol(p)
P *p;
 {
 if(pprevl(p)) pgetc(p);
 p->col=0; p->valcol=1;
 return p;
 }

P *peol(p)
P *p;
 {
 if(p->b->o.crlf)
  while(!piseol(p)) pgetc(p);
 else
  while(p->ofst!=GSIZE(p->hdr))
   {
   unsigned char c;
   if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
   else c=p->ptr[p->ofst];
   if(c=='\n') break;
   else
    {
    ++p->byte;
    ++p->ofst;
    if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
    else ++p->col;
    if(p->ofst==GSIZE(p->hdr)) pnext(p); 
    }
   }
 return p;
 }

P *pnextl(p)
P *p;
 {
 char c;
 do
  {
  if(p->ofst==GSIZE(p->hdr))
   do
    {
    p->byte+=GSIZE(p->hdr)-p->ofst;
    if(!pnext(p)) return 0;
    }
    while(!p->hdr->nlines);
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  ++p->byte; ++p->ofst;
  }
  while(c!='\n');
 ++p->line;
 p->col=0; p->valcol=1;
 if(p->ofst==GSIZE(p->hdr)) pnext(p);
 return p;
 }

P *pprevl(p)
P *p;
 {
 char c;
 p->valcol=0;
 do
  {
  if(!p->ofst)
   do
    {
    p->byte-=p->ofst;
    if(!pprev(p)) return 0;
    }
    while(!p->hdr->nlines);
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  }
  while(c!='\n');
 --p->line;
 if(p->b->o.crlf && c=='\n')
  {
  int k=prgetc1(p);
  if(k!='\r' && k!=MAXINT) pgetc(p);
  }
 return p;
 }

P *pline(p,line)
P *p;
long line;
 {
 if(line>p->b->eof->line) { pset(p,p->b->eof); return p; }
 if(line<Labs(p->line-line)) pset(p,p->b->bof);
 if(Labs(p->b->eof->line-line)<Labs(p->line-line)) pset(p,p->b->eof);
 if(p->line==line) { pbol(p); return p; }
 while(line>p->line) pnextl(p);
 if(line<p->line)
  {
  while(line<p->line) pprevl(p);
  pbol(p);
  }
 return p;
 }

P *pcol(p,goalcol)
P *p;
long goalcol;
 {
 pbol(p);
 do
  {
  unsigned char c;
  int wid;
  if(p->ofst==GSIZE(p->hdr)) break;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  if(c=='\n') break;
  if(p->b->o.crlf && c=='\r' && piseol(p)) break;
  if(c=='\t') wid=p->b->o.tab-p->col%p->b->o.tab;
  else wid=1;
  if(p->col+wid>goalcol) break;
  if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
  ++p->byte; p->col+=wid;
  } while(p->col!=goalcol);
 return p;
 }

P *pcolwse(p,goalcol)
P *p;
long goalcol;
 {
 int c;
 pcol(p,goalcol);
 do c=prgetc(p); while(c==' ' || c=='\t');
 if(c!=MAXINT) pgetc(p);
 return p;
 }

P *pcoli(p,goalcol)
P *p;
long goalcol;
 {
 pbol(p);
 while(p->col<goalcol)
  {
  unsigned char c;
  if(p->ofst==GSIZE(p->hdr)) break;
  if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
  else c=p->ptr[p->ofst];
  if(c=='\n') break;
#ifdef __MSDOS
  if(c=='\r' && piseol(p)) break;
d785 698
a1482 315
  else if(c=='\t') p->col+=p->b->o.tab-p->col%p->b->o.tab;
  else ++p->col;
  if(++p->ofst==GSIZE(p->hdr)) pnext(p); 
  ++p->byte;
  }
 return p;
 }

void pfill(p,to,usetabs)
P *p;
long to;
 {
 piscol(p);
 if(usetabs)
  while(p->col<to)
   if(p->col+p->b->o.tab-p->col%p->b->o.tab<=to) binsc(p,'\t'), pgetc(p);
   else binsc(p,' '), pgetc(p);
 else while(p->col<to) binsc(p,' '), pgetc(p);
 }

void pbackws(p)
P *p;
 {
 int c;
 P *q=pdup(p);
 do c=prgetc(q); while(c==' ' || c=='\t');
 if(c!=MAXINT) pgetc(q);
 bdel(q,p);
 prm(q);
 }

static char frgetc(p)
P *p;
 {
 if(!p->ofst) pprev(p);
 --p->ofst;
 if(p->ofst>=p->hdr->hole) return p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else return p->ptr[p->ofst];
 }

static void ffwrd(p,n)
P *p;
 {
 while(n>GSIZE(p->hdr)-p->ofst)
  {
  n-=GSIZE(p->hdr)-p->ofst;
  if(!pnext(p)) return;
  }
 if((p->ofst+=n)==GSIZE(p->hdr)) pnext(p);
 }

static P *ffind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->b->eof->byte-p->byte;
 int x;
 unsigned char table[256], c;
 if(len>amnt) return 0;
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=0;x!=len-1;++x) table[s[x]]=x;
 ffwrd(p,len); amnt-=len; x=len; do
  if((c=frgetc(p))!=s[--x])
   {
   if(table[c]==255) ffwrd(p,len+1), amnt-=x+1;
   else if(x<=table[c]) ffwrd(p,len-x+1), --amnt;
   else ffwrd(p,len-table[c]), amnt-=x-table[c];
   if(amnt<0) return 0;
   else x=len;
   }
  while(x);
 return p;
 }

static P *fifind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->b->eof->byte-p->byte;
 int x;
 unsigned char table[256], c;
 if(len>amnt) return 0;
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=0;x!=len-1;++x) table[s[x]]=x;
 ffwrd(p,len); amnt-=len; x=len; do
  if((c=toup(frgetc(p)))!=s[--x])
   {
   if(table[c]==255) ffwrd(p,len+1), amnt-=x+1;
   else if(x<=table[c]) ffwrd(p,len-x+1), --amnt;
   else ffwrd(p,len-table[c]), amnt-=x-table[c];
   if(amnt<0) return 0;
   else x=len;
   }
  while(x);
 return p;
 }

static P *getto(p,q)
P *p, *q;
 {
 while(p->hdr!=q->hdr || p->ofst!=q->ofst)
  {
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') ++p->line; }
  else if(p->ptr[p->ofst]=='\n') ++p->line;
  ++p->byte; ++p->ofst;
  if(p->ofst==GSIZE(p->hdr)) pnext(p);
  while(!p->ofst && p->hdr!=q->hdr)
   {
   p->byte+=GSIZE(p->hdr), p->line+=p->hdr->nlines;
   pnext(p);
   }
  }
 return p;
 }

P *pfind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(ffind(q,s,len)) { getto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

P *pifind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(fifind(q,s,len)) { getto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

static void fbkwd(p,n)
P *p;
 {
 while(n>p->ofst)
  {
  n-=p->ofst;
  if(!pprev(p)) return;
  }
 if(p->ofst>=n) p->ofst-=n;
 else p->ofst=0;
 }

static int fpgetc(p)
P *p;
 {
 char c;
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) c=p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else c=p->ptr[p->ofst];
 if(++p->ofst==GSIZE(p->hdr)) pnext(p);
 return c;
 }

static P *frfind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->byte;
 int x;
 unsigned char table[256], c;
 if(len>p->b->eof->byte-p->byte)
  {
  x=len-(p->b->eof->byte-p->byte);
  if(amnt<x) return 0;
  amnt-=x;
  fbkwd(p,x);
  }
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=len;--x;table[s[x]]=len-x-1);
 x=0; do
  if((c=fpgetc(p))!=s[x++])
   {
   if(table[c]==255) fbkwd(p,len+1), amnt-=len-x+1;
   else if(len-table[c]<=x) fbkwd(p,x+1), --amnt;
   else fbkwd(p,len-table[c]), amnt-=len-table[c]-x;
   if(amnt<0) return 0;
   else x=0;
   }
  while(x!=len);
 fbkwd(p,len);
 return p;
 }

static P *frifind(p,s,len)
P *p;
unsigned char *s;
 {
 long amnt=p->byte;
 int x;
 unsigned char table[256], c;
 if(len>p->b->eof->byte-p->byte)
  {
  x=len-(p->b->eof->byte-p->byte);
  if(amnt<x) return 0;
  amnt-=x;
  fbkwd(p,x);
  }
 if(!len) return p;
 p->valcol=0;
 mset(table,255,256); for(x=len;--x;table[s[x]]=len-x-1);
 x=0; do
  if((c=toup(fpgetc(p)))!=s[x++])
   {
   if(table[c]==255) fbkwd(p,len+1), amnt-=len-x+1;
   else if(len-table[c]<=x) fbkwd(p,x+1), --amnt;
   else fbkwd(p,len-table[c]), amnt-=len-table[c]-x;
   if(amnt<0) return 0;
   else x=0;
   }
  while(x!=len);
 fbkwd(p,len);
 return p;
 }

static P *rgetto(p,q)
P *p, *q;
 {
 while(p->hdr!=q->hdr || p->ofst!=q->ofst)
  {
  if(!p->ofst)
   do
    {
    if(p->ofst)
     p->byte-=p->ofst, p->line-=p->hdr->nlines;
    pprev(p);
    }
    while(p->hdr!=q->hdr);
  --p->ofst; --p->byte;
  if(p->ofst>=p->hdr->hole)
   { if(p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole]=='\n') --p->line; }
  else if(p->ptr[p->ofst]=='\n') --p->line;
  }
 return p;
 }

P *prfind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(frfind(q,s,len)) { rgetto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

P *prifind(p,s,len)
P *p;
char *s;
 {
 P *q=pdup(p);
 if(frifind(q,s,len)) { rgetto(p,q); prm(q); return p; }
 else { prm(q); return 0; }
 }

B *bcpy(from,to)
P *from, *to;
 {
 H anchor, *l;
 char *ptr;
 P *q;

 if(from->byte>=to->byte) return bmk(from->b);

 q=pdup(from);
 izque(H,link,&anchor);

 if(q->hdr==to->hdr)
  {
  l=halloc(); ptr=vlock(vmem,l->seg);
  if(q->ofst!=q->hdr->hole) gstgap(q->hdr,q->ptr,q->ofst);
  l->nlines=mcnt(q->ptr+q->hdr->ehole,'\n',l->hole=to->ofst-q->ofst);
  mcpy(ptr,q->ptr+q->hdr->ehole,l->hole);
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  }
 else
  {
  l=halloc(); ptr=vlock(vmem,l->seg);
  if(q->ofst!=q->hdr->hole) gstgap(q->hdr,q->ptr,q->ofst);
  l->nlines=mcnt(q->ptr+q->hdr->ehole,'\n',l->hole=SEGSIZ-q->hdr->ehole);
  mcpy(ptr,q->ptr+q->hdr->ehole,l->hole);
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  pnext(q);
  while(q->hdr!=to->hdr)
   {
   l=halloc(); ptr=vlock(vmem,l->seg);
   l->nlines=q->hdr->nlines;
   mcpy(ptr,q->ptr,q->hdr->hole);
   mcpy(ptr+q->hdr->hole,q->ptr+q->hdr->ehole,SEGSIZ-q->hdr->ehole);
   l->hole=GSIZE(q->hdr);
   vchanged(ptr); vunlock(ptr);
   enqueb(H,link,&anchor,l);
   pnext(q);
   }
  if(to->ofst)
   {
   l=halloc(); ptr=vlock(vmem,l->seg);
   if(to->ofst!=to->hdr->hole) gstgap(to->hdr,to->ptr,to->ofst);
   l->nlines=mcnt(to->ptr,'\n',to->ofst);
   mcpy(ptr,to->ptr,l->hole=to->ofst);
   vchanged(ptr); vunlock(ptr);
   enqueb(H,link,&anchor,l);
   }
  }

 l=anchor.link.next;
 deque(H,link,&anchor);
 prm(q);
d1484 2
a1485 2
 return bmkchn(l,from->b,to->byte-from->byte,to->line-from->line);
 }
d1488 46
a1533 47

void pcoalesce(p)
P *p;
 {
 if(p->hdr!=p->b->eof->hdr &&
    GSIZE(p->hdr)+GSIZE(p->hdr->link.next)<=SEGSIZ-SEGSIZ/4)
  {
  H *hdr=p->hdr->link.next;
  char *ptr=vlock(vmem,hdr->seg);
  int osize=GSIZE(p->hdr);
  int size=GSIZE(hdr);
  P *q;
  gstgap(hdr,ptr,size);
  ginsm(p->hdr,p->ptr,GSIZE(p->hdr),ptr,size);
  p->hdr->nlines+=hdr->nlines;
  vunlock(ptr);
  hfree(deque(H,link,hdr));
  for(q=p->link.next;q!=p;q=q->link.next)
   if(q->hdr==hdr)
    {
    q->hdr=p->hdr;
    if(q->ptr) { vunlock(q->ptr); q->ptr=vlock(vmem,q->hdr->seg); }
    q->ofst+=osize;
    }
  }
 if(p->hdr!=p->b->bof->hdr &&
    GSIZE(p->hdr)+GSIZE(p->hdr->link.prev)<=SEGSIZ-SEGSIZ/4)
  {
  H *hdr=p->hdr->link.prev;
  char *ptr=vlock(vmem,hdr->seg);
  int size=GSIZE(hdr);
  P *q;
  gstgap(hdr,ptr,size);
  ginsm(p->hdr,p->ptr,0,ptr,size);
  p->hdr->nlines+=hdr->nlines;
  vunlock(ptr);
  hfree(deque(H,link,hdr));
  p->ofst+=size;
  for(q=p->link.next;q!=p;q=q->link.next)
   if(q->hdr==hdr)
    {
    q->hdr=p->hdr;
    if(q->ptr) vunlock(q->ptr); q->ptr=vlock(vmem,q->hdr->seg);
    }
   else if(q->hdr==p->hdr) q->ofst+=size;
  }
 }
a1544 1
 *  mcpy	- to copy deleted text
d1554 181
a1734 177
static B *bcut(from,to)
P *from, *to;
 {
 H *h,				/* The deleted text */
   *i;
 char *ptr;
 P *p;
 long nlines;			/* No. EOLs to delete */
 long amnt;			/* No. bytes to delete */
 int toamnt;			/* Amount to delete from segment in 'to' */
 int bofmove=0;		/* Set if bof got deleted */
 
 if(!(amnt=to->byte-from->byte))
  return 0;			/* ...nothing to delete */
 
 nlines=to->line-from->line;
 
 if(from->hdr==to->hdr)
  { /* Delete is within a single segment */
  /* Move gap to deletion point */
  if(from->ofst!=from->hdr->hole)
   gstgap(from->hdr,from->ptr,from->ofst);
 
  /* Store the deleted text */
  h=halloc();
  ptr=vlock(vmem,h->seg);
  mcpy(ptr,from->ptr+from->hdr->ehole,(int)amnt);
  h->hole=amnt;
  h->nlines=nlines;
  vchanged(ptr); vunlock(ptr);
 
  /* Delete */
  from->hdr->ehole+=amnt;
  from->hdr->nlines-=nlines;
 
  toamnt=amnt;
  }
 else
  { /* Delete crosses segments */
  H *a;
  if(toamnt=to->ofst)
   {
   /* Delete beginning of to */
   /* Move gap to deletion point */
   /* To could be deleted if it's at the end of the file */
   if(to->ofst!=to->hdr->hole)
    gstgap(to->hdr,to->ptr,to->ofst);
  
   /* Save deleted text */
   i=halloc();
   ptr=vlock(vmem,i->seg);
   mcpy(ptr,to->ptr,to->hdr->hole);
   i->hole=to->hdr->hole;
   i->nlines=mcnt(to->ptr,'\n',to->hdr->hole);
   vchanged(ptr); vunlock(ptr);
 
   /* Delete */
   to->hdr->nlines-=i->nlines;
   to->hdr->hole=0;
   }
  else i=0;
 
  /* Delete end of from */
  if(!from->ofst)
   {
   /* ..unless from needs to be deleted too */
   a=from->hdr->link.prev, h=0;
   if(a==from->b->eof->hdr) bofmove=1;
   }
  else
   {
   a=from->hdr;
   /* Move gap to deletion point */
   if(from->ofst!=from->hdr->hole)
    gstgap(from->hdr,from->ptr,from->ofst);
 
   /* Save deleted text */
   h=halloc();
   ptr=vlock(vmem,h->seg);
   mcpy(ptr,from->ptr+from->hdr->ehole,SEGSIZ-from->hdr->ehole);
   h->hole=SEGSIZ-from->hdr->ehole;
   h->nlines=mcnt(ptr,'\n',h->hole);
   vchanged(ptr); vunlock(ptr);
 
   /* Delete */
   from->hdr->nlines-=h->nlines;
   from->hdr->ehole=SEGSIZ;
   }
 
  /* Make from point to header/segment of to */
  from->hdr=to->hdr;
  vunlock(from->ptr); from->ptr=to->ptr; vupcount(to->ptr);
  from->ofst=0;
 
  /* Delete headers/segments between a and to->hdr (if there are any) */
  if(a->link.next!=to->hdr)
   if(!h)
    {
    h=snip(H,link,a->link.next,to->hdr->link.prev);
    if(i) enqueb(H,link,h,i);
    }
   else
    {
    splicef(H,link,h,snip(H,link,a->link.next,to->hdr->link.prev));
    if(i) enqueb(H,link,h,i);
    }
  else
   if(!h) h=i;
   else if(i) enqueb(H,link,h,i);
  }

  /* If to is empty, then it must have been at the end of the file.  If
     the file did not become empty, delete to */
  if(!GSIZE(to->hdr) && from->byte)
   {
   H *ph=from->hdr->link.prev;
   hfree(deque(H,link,from->hdr)); vunlock(from->ptr);
   from->hdr=ph;
   from->ptr=vlock(vmem,from->hdr->seg);
   from->ofst=GSIZE(ph);
   vunlock(from->b->eof->ptr);
   from->b->eof->ptr=from->ptr;
   vupcount(from->ptr);
   from->b->eof->hdr=from->hdr;
   from->b->eof->ofst=from->ofst;
   }
 
 /* The deletion is now done */
 
 /* Scroll if necessary */
 
 if(bofmove) pset(from->b->bof,from);
 if(nlines && !pisbol(from))
  {
  scrdel(from->b,from->line,nlines,1);
  delerr(from->b->name,from->line,nlines,0);
  }
 else
  {
  scrdel(from->b,from->line,nlines,0);
  delerr(from->b->name,from->line,nlines,1);
  }
 
 /* Fix pointers */

 for(p=from->link.next;p!=from;p=p->link.next)
  if(p->line==from->line && p->byte>from->byte) p->valcol=0; 
 for(p=from->link.next;p!=from;p=p->link.next)
  if(p->byte>=from->byte)
   if(p->byte<=from->byte+amnt)
    if(p->ptr) pset(p,from);
    else poffline(pset(p,from));
   else
    {
    if(p->hdr==to->hdr) p->ofst-=toamnt;
    p->byte-=amnt;
    p->line-=nlines;
    }

 pcoalesce(from);

 /* Make buffer out of deleted text and return it */
 
 return bmkchn(h,from->b,amnt,nlines);
 }

void bdel(from,to)
P *from, *to;
 {
 if(to->byte-from->byte)
  {
  B *b=bcut(from,to);
  if(from->b->undo) undodel(from->b->undo,from->byte,b);
  else brm(b);
  from->b->changed=1;
  }
 }
d1740 215
a1954 207

static void bsplit(p)
P *p;
 {
 if(p->ofst)
  {
  H *hdr;
  char *ptr;
  P *pp;

  hdr=halloc();
  ptr=vlock(vmem,hdr->seg);

  if(p->ofst!=p->hdr->hole) gstgap(p->hdr,p->ptr,p->ofst);
  mcpy(ptr,p->ptr+p->hdr->ehole,SEGSIZ-p->hdr->ehole);
  hdr->hole=SEGSIZ-p->hdr->ehole;
  hdr->nlines=mcnt(ptr,'\n',hdr->hole);
  p->hdr->nlines-=hdr->nlines;
  vchanged(ptr);
  p->hdr->ehole=SEGSIZ;

  enquef(H,link,p->hdr,hdr);

  vunlock(p->ptr);

  for(pp=p->link.next;pp!=p;pp=pp->link.next)
   if(pp->hdr==p->hdr && pp->ofst>=p->ofst)
    {
    pp->hdr=hdr;
    if(pp->ptr) { vunlock(pp->ptr); pp->ptr=ptr; vupcount(ptr); }
    pp->ofst-=p->ofst;
    }

  p->ptr=ptr;
  p->hdr=hdr;
  p->ofst=0;
  }
 }

/* Make a chain out of a block of memory */
/* The block must not be empty */

static H *bldchn(blk,size,nlines)
char *blk;
int size;
long *nlines;
 {
 H anchor, *l;
 *nlines=0;
 izque(H,link,&anchor);
 do
  {
  char *ptr;
  int amnt;
  ptr=vlock(vmem,(l=halloc())->seg);
  if(size>SEGSIZ) amnt=SEGSIZ;
  else amnt=size;
  mcpy(ptr,blk,amnt);
  l->hole=amnt; l->ehole=SEGSIZ; (*nlines)+=(l->nlines=mcnt(ptr,'\n',amnt));
  vchanged(ptr); vunlock(ptr);
  enqueb(H,link,&anchor,l);
  blk+=amnt; size-=amnt;
  }
  while(size);
 l=anchor.link.next;
 deque(H,link,&anchor);
 return l;
 }

/* Insert a chain into a buffer */
/* This does not update pointers */

static void inschn(p,a)
P *p;
H *a;
 {
 if(!p->b->eof->byte)
  { /* P's buffer is empty: replace the empty segment in p with a */
  hfree(p->hdr); p->hdr=a;
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  pset(p->b->bof,p);

  p->b->eof->hdr=a->link.prev;
  vunlock(p->b->eof->ptr); p->b->eof->ptr=vlock(vmem,p->b->eof->hdr->seg);
  p->b->eof->ofst=GSIZE(p->b->eof->hdr);
  }
 else if(piseof(p))
  { /* We're at the end of the file: append a to the file */
  p->b->eof->hdr=a->link.prev;
  spliceb(H,link,p->b->bof->hdr,a);
  vunlock(p->b->eof->ptr); p->b->eof->ptr=vlock(vmem,p->b->eof->hdr->seg);
  p->b->eof->ofst=GSIZE(p->b->eof->hdr);
  p->hdr=a;
  vunlock(p->ptr); p->ptr=vlock(vmem,p->hdr->seg); p->ofst=0;
  }
 else if(pisbof(p))
  { /* We're at the beginning of the file: insert chain and set bof pointer */
  p->hdr=spliceb(H,link,p->hdr,a);
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  pset(p->b->bof,p);
  }
 else
  { /* We're in the middle of the file: split and insert */
  bsplit(p);
  p->hdr=spliceb(H,link,p->hdr,a);
  vunlock(p->ptr); p->ptr=vlock(vmem,a->seg);
  }
 }

static void fixupins(p,amnt,nlines,hdr,hdramnt)
P *p;
long amnt;
long nlines;
H *hdr;
int hdramnt;
 {
 P *pp;
 if(nlines && !pisbol(p)) scrins(p->b,p->line,nlines,1);
 else scrins(p->b,p->line,nlines,0);
 inserr(p->b->name,p->line,nlines);

 for(pp=p->link.next;pp!=p;pp=pp->link.next)
  if(pp->line==p->line &&
     (pp->byte>p->byte || pp->end && pp->byte==p->byte)) pp->valcol=0;
 for(pp=p->link.next;pp!=p;pp=pp->link.next)
  if(pp->byte==p->byte && !pp->end)
   if(pp->ptr) pset(pp,p);
   else poffline(pset(pp,p));
  else if(pp->byte>p->byte || pp->end && pp->byte==p->byte)
   {
   pp->byte+=amnt;
   pp->line+=nlines;
   if(pp->hdr==hdr) pp->ofst+=hdramnt;
   }
 if(p->b->undo) undoins(p->b->undo,p,amnt);
 p->b->changed=1;
 }

/* Insert a buffer at pointer position */
/* The buffer goes away */

P *binsb(p,b)
P *p;
B *b;
 {
 if(b->eof->byte)
  {
  P *q=pdup(p);
  inschn(q,b->bof->hdr);
  b->eof->hdr=halloc();
  fixupins(q,b->eof->byte,b->eof->line,NULL,0);
  pcoalesce(q);
  prm(q);
  }
 brm(b);
 return p;
 }

P *binsm(p,blk,amnt)
P *p;
char *blk;
int amnt;
 {
 long nlines;
 H *h=0;
 int hdramnt;
 P *q;
 if(!amnt) return p;
 q=pdup(p);
 if(amnt<=GGAPSZ(q->hdr))
  {
  h=q->hdr;
  hdramnt=amnt;
  ginsm(q->hdr,q->ptr,q->ofst,blk,amnt);
  q->hdr->nlines+=(nlines=mcnt(blk,'\n',amnt));
  }
 else if(!q->ofst && q->hdr!=q->b->bof->hdr && amnt<=GGAPSZ(q->hdr->link.prev))
  {
  pprev(q); 
  ginsm(q->hdr,q->ptr,q->ofst,blk,amnt);
  q->hdr->nlines+=(nlines=mcnt(blk,'\n',amnt));
  }
 else
  {
  H *a=bldchn(blk,amnt,&nlines);
  inschn(q,a);
  }
 fixupins(q,(long)amnt,nlines,h,hdramnt);
 pcoalesce(q);
 prm(q);
 return p;
 }

P *binsc(p,c)
P *p;
char c;
 {
 if(p->b->o.crlf && c=='\n') return binsm(p,"\r\n",2);
 else return binsm(p,&c,1);
 }

P *binss(p,s)
P *p;
char *s;
 {
 return binsm(p,s,zlen(s));
 }
d1960 15
a1974 11

static int bkread(fi,buff,size)
char *buff;
 {
 int a,b;
 if(!size) { error=0; return 0; }
 for(a=b=0;(a<size) && ((b=jread(fi,buff+a,size-a))>0);a+=b);
 if(b<0) error= -2;
 else error=0;
 return a;
 }
d1978 26
a2003 26

B *bread(fi,max)
long max;
 {
 H anchor, *l;
 long lines=0, total=0;
 int amnt;
 char *seg;
 izque(H,link,&anchor);
 error=0;
 while(seg=vlock(vmem,(l=halloc())->seg),
       !error && (amnt=bkread(fi,seg,max>=SEGSIZ?SEGSIZ:(int)max)))
  {
  total+=amnt;
  max-=amnt;
  l->hole=amnt;
  lines+=(l->nlines=mcnt(seg,'\n',amnt));
  vchanged(seg); vunlock(seg);
  enqueb(H,link,&anchor,l);
  }
 hfree(l); vunlock(seg);
 if(!total) return bmk(NULL);
 l=anchor.link.next;
 deque(H,link,&anchor);
 return bmkchn(l,NULL,total,lines);
 }
d2013 32
a2044 28

char *parsens(s,skip,amnt)
char *s;
long *skip, *amnt;
 {
 char *n=vsncpy(NULL,0,sz(s));
 int x;
 *skip=0;
 *amnt= MAXLONG;
 for(x=sLEN(n)-1;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
 if(n[x]==',')
  {
  n[x]=0;
  if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
  else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
  else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
  else sscanf(n+x+1,"%ld",skip);
  for(--x;x>0 && (n[x]>='0' && n[x]<='9' || n[x]=='x' || n[x]=='X');--x);
  if(n[x]==',')
   {
   n[x]=0;
   *amnt= *skip;
   if(n[x+1]=='x' || n[x+1]=='X') sscanf(n+x+2,"%lx",skip);
   else if(n[x+1]=='0' && (n[x+2]=='x' || n[x+2]=='X')) sscanf(n+x+3,"%lx",skip);
   else if(n[x+1]=='0') sscanf(n+x+1,"%lo",skip);
   else sscanf(n+x+1,"%ld",skip);
   }
  }
d2046 28
a2073 28
 if(n[0]=='~')
  {
  for(x=1;n[x] && n[x]!='/';++x);
  if(n[x]=='/')
   if(x==1)
    {
    char *z;
    s=getenv("HOME");
    z=vsncpy(NULL,0,sz(s));
    z=vsncpy(z,sLEN(z),sz(n+x));
    vsrm(n);
    n=z;
    }
   else
    {
    struct passwd *passwd;
    n[x]=0;
    passwd=getpwnam(n+1);
    n[x]='/';
    if(passwd)
     {
     char *z=vsncpy(NULL,0,sz(passwd->pw_dir));
     z=vsncpy(z,sLEN(z),sz(n+x));
     vsrm(n);
     n=z;
     }
    }
  }
d2075 2
a2076 2
 return n;
 }
d2085 21
d2107 1
a2107 21
B *bload(s)
char *s;
 {
 char buffer[SEGSIZ];
 FILE *fi;
 B *b;
 long skip,amnt;
 char *n;
 int nowrite=0;

 if(!s || !s[0])
  {
  error= -1; 
  b=bmk(NULL);
  setopt(&b->o,"");
  b->rdonly=b->o.readonly;
  b->er=error;
  return b;
  }

 n=parsens(s,&skip,&amnt);
d2109 1
a2109 2
 /* Open file or stream */
 ossep(n);
d2111 5
a2115 7
 if(n[0]=='!')
  {
  nescape(maint->t);
  ttclsn();
  fi=popen(n+1,"r");
  }
 else
d2117 54
a2170 40
 if(!zcmp(n,"-")) fi=stdin;
 else
  {
  fi=fopen(n,"r+");
  if(!fi) nowrite=1;
  else fclose(fi);
  fi=fopen(n,"r");
  if(!fi) nowrite=0;
  }
 joesep(n);

 /* Abort if couldn't open */
 if(!fi)
  {
  if(errno==ENOENT) error= -1;
  else error= -4;
  b=bmk(NULL);
  setopt(&b->o,n);
  b->rdonly=b->o.readonly;
  goto opnerr;
  }

 /* Skip data if we need to */
 if(skip && lseek(fileno(fi),skip,0)<0)
  {
  int r;
  while(skip>SEGSIZ)
   {
   r=bkread(fileno(fi),buffer,SEGSIZ);
   if(r!=SEGSIZ || error) { error= -3; goto err; }
   skip-=SEGSIZ;
   }
  skip-=bkread(fileno(fi),buffer,(int)skip);
  if(skip || error) { error= -3; goto err; }
  }

 /* Read from stream into new buffer */
 b=bread(fileno(fi),amnt);
 setopt(&b->o,n);
 b->rdonly=b->o.readonly;
d2172 2
a2173 2
 /* Close stream */
 err:;
d2175 3
a2177 2
 if(s[0]=='!') pclose(fi);
 else
d2179 2
a2180 1
 if(zcmp(n,"-")) fclose(fi);
d2182 71
a2252 2
 opnerr:;
 if(s[0]=='!') ttopnn(), nreturn(maint->t);
d2254 28
a2281 15
 /* Set name */
 b->name=joesep(zdup(s));

 /* Set flags */
 if(error || s[0]=='!' || skip || amnt!=MAXLONG) b->backup=1, b->changed=0;
 else if(!zcmp(n,"-")) b->backup=1, b->changed=1;
 else b->backup=0, b->changed=0;
 if(nowrite) b->rdonly=b->o.readonly=1;

 /* Eliminate parsed name */
 vsrm(n);

 b->er=error;
 return b;
 }
d2284 67
a2350 37

B *bfind(s)
char *s;
 {
 B *b;
 if(!s || !s[0])
  {
  error= -1; 
  b=bmk(NULL);
  setopt(&b->o,"");
  b->rdonly=b->o.readonly;
  b->internal=0;
  b->er=error;
  return b;
  }
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->name && !zcmp(s,b->name))
   {
   if(!b->orphan) ++b->count;
   else b->orphan=0;
   error=0;
   b->internal=0;
   return b;
   }
 b=bload(s);
 b->internal=0;
 return b;
 }

char **getbufs()
 {
 char **s=vamk(16);
 B *b;
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->name) s=vaadd(s,vsncpy(NULL,0,sz(b->name)));
 return s;
 }
d2353 11
a2363 12

B *borphan()
 {
 B *b;
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->orphan)
   {
   b->orphan=0;
   return b;
   }
 return 0;
 }
d2370 38
d2409 1
a2409 43
int bsavefd(p,fd,size)
P *p;
long size;
 {
 P *np=pdup(p);
 int amnt;
 while(size>(amnt=GSIZE(np->hdr)-np->ofst))
  {
  if(np->ofst<np->hdr->hole)
   {
   if(jwrite(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0)
    goto err;
   if(jwrite(fd,np->ptr+np->hdr->ehole,SEGSIZ-np->hdr->ehole)<0)
    goto err;
   }
  else
   if(jwrite(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),amnt)<0)
    goto err;
  size-=amnt;
  pnext(np);
  }
 if(size)
  if(np->ofst<np->hdr->hole)
   if(size>np->hdr->hole-np->ofst)
    {
    if(jwrite(fd,np->ptr+np->ofst,np->hdr->hole-np->ofst)<0)
     goto err;
    if(jwrite(fd,np->ptr+np->hdr->ehole,(int)size-np->hdr->hole+np->ofst)<0)
     goto err;
    }
   else
    {
    if(jwrite(fd,np->ptr+np->ofst,(int)size)<0)
     goto err;
    }
  else if(jwrite(fd,np->ptr+np->ofst+GGAPSZ(np->hdr),(int)size)<0)
   goto err;
 prm(np);
 return error=0;
 err:;
 prm(np);
 return error=5;
 }
d2411 4
a2414 1
/* Save 'size' bytes beginning at 'p' in file 's' */
d2416 6
a2421 7
int bsave(p,s,size)
P *p;
char *s;
long size;
 {
 FILE *f;
 long skip,amnt;
d2423 1
a2423 1
 s=parsens(s,&skip,&amnt);
d2425 2
a2426 1
 if(amnt<size) size=amnt;
a2427 1
 ossep(s);
d2429 5
a2433 7
 if(s[0]=='!')
  {
  nescape(maint->t);
  ttclsn();
  f=popen(s+1,"w");
  }
 else
d2435 36
a2470 31
 if(s[0]=='>' && s[1]=='>') f=fopen(s+2,"a");
 else if(!zcmp(s,"-"))
  {
  nescape(maint->t);
  ttclsn();
  f=stdout;
  }
 else
  if(skip || amnt!=MAXLONG) f=fopen(s,"r+");
  else f=fopen(s,"w");
 joesep(s);

 if(!f)
  {
  error= -4;
  goto opnerr;
  }
 fflush(f);

 if(skip && lseek(fileno(f),skip,0)<0) { error= -3; goto err; }

 bsavefd(p,fileno(f),size);

 if(!error && force && size && !skip && amnt==MAXLONG)
  {
  P *q=pdup(p);
  char nl='\n';
  pfwrd(q,size-1);
  if(brc(q)!='\n' && jwrite(fileno(f),&nl,1)<0) error= -5;
  prm(q);
  }
d2472 1
a2472 1
 err:;
d2474 3
a2476 2
 if(s[0]=='!') pclose(f);
 else
d2478 90
a2567 53
 if(zcmp(s,"-")) fclose(f);
 else fflush(f);

 opnerr:;
 if(s[0]=='!' || !zcmp(s,"-")) ttopnn(), nreturn(maint->t);
 return error;
 }

int brc(p)
P *p;
 {
 if(p->ofst==GSIZE(p->hdr)) return MAXINT;
 if(p->ofst>=p->hdr->hole) return p->ptr[p->ofst+p->hdr->ehole-p->hdr->hole];
 else return p->ptr[p->ofst];
 }

char *brmem(p,blk,size)
P *p;
char *blk;
int size;
 {
 char *bk=blk;
 P *np;
 int amnt;
 np=pdup(p);
 while(size>(amnt=GSIZE(np->hdr)-np->ofst))
  {
  grmem(np->hdr,np->ptr,np->ofst,bk,amnt);
  bk+=amnt;
  size-=amnt;
  pnext(np);
  }
 if(size) grmem(np->hdr,np->ptr,np->ofst,bk,size);
 prm(np);
 return blk;
 }

char *brs(p,size)
P *p;
int size;
 {
 char *s=(char *)malloc(size+1);
 s[size]=0;
 return brmem(p,s,size);
 }

char *brvs(p,size)
P *p;
int size;
 {
 char *s=vstrunc(NULL,size);
 return brmem(p,s,size);
 }
d2571 47
a2617 22
extern char *ctime();

void ttsig(sig)
 {
 long tim=time(0);
 B *b;
 FILE *f=fopen("DEADJOE","a");
 fprintf(f,"\n*** Modified files in JOE when it aborted on %s",ctime(&tim));
 if(sig) fprintf(f,"*** JOE was aborted by signal %d\n",sig);
 else fprintf(f,"*** JOE was aborted because the terminal closed\n");
 fflush(f);
 for(b=bufs.link.next;b!=&bufs;b=b->link.next)
  if(b->changed)
   {
   if(b->name) fprintf(f,"\n*** File \'%s\'\n",b->name);
   else fprintf(f,"\n*** File \'(Unnamed)\'\n");
   fflush(f);
   bsavefd(b->bof,fileno(f),b->eof->byte);
   }
 if(sig) ttclsn();
 _exit(1);
 }
@


1.1.21.1.2.1
log
@Apply patches I used for the MS-DOS® version of jupp 2.8
@
text
@d1702 1
a1702 1
  fi=fopen(n,"rb+");
d1705 1
a1705 1
  fi=fopen(n,"rb");
d1894 1
a1894 1
 if(s[0]=='>' && s[1]=='>') f=fopen(s+2,"ab");
d1902 2
a1903 2
  if(skip || amnt!=MAXLONG) f=fopen(s,"rb+");
  else f=fopen(s,"wb");
d1993 1
a1993 1
 FILE *f=fopen("DEADJOE","ab");
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
