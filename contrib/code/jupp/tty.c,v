head	1.38;
access;
symbols
	joe-3_1jupp38:1.38
	joe-3_1jupp37:1.36
	joe-3_1jupp36:1.36
	joe-3_1jupp35:1.36
	joe-3_1jupp34:1.36
	joe-3_1jupp33:1.36
	joe-3_1jupp32:1.35
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.24
	joe-3_1jupp30:1.22
	joe-3_1jupp29:1.22
	joe-3_1jupp28:1.20
	joe-3_1jupp27:1.18
	joe-3_1jupp26:1.18
	joe-3_1jupp25:1.18
	joe-3_1jupp24:1.18
	joe-3_1jupp23:1.18
	joe-3_1jupp22:1.17
	joe-3_1jupp21:1.17
	joe-3_1jupp20:1.17
	joe-3_1jupp19:1.16
	joe-3_1jupp18:1.15
	joe-3_1jupp17:1.15
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.15
	joe-3_1jupp15:1.14
	joe-3_1jupp14:1.11
	joe-3_1jupp12:1.10
	joe-3_1jupp11:1.5
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.5
	joe-3_1jupp9:1.5
	joe-3_1jupp8:1.3
	joe-3_1jupp7:1.3
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.38
date	2018.11.11.18.20.51;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005BE872F324B3552E;

1.37
date	2018.11.11.18.15.38;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005BE871D325833018;

1.36
date	2018.01.06.00.28.33;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005A50184621FA8455;

1.35
date	2017.12.08.02.28.06;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A29F8C708B176AB;

1.34
date	2017.12.08.02.17.23;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A29F64A06DEB239;

1.33
date	2017.12.08.02.00.41;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A29F2506E789D2B;

1.32
date	2017.12.06.23.02.05;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A2876FC4FFE7EF5;

1.31
date	2017.12.06.21.17.01;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A285E5918D423C7;

1.30
date	2017.12.02.02.07.33;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A220AD65C90E687;

1.29
date	2017.12.01.22.31.05;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A21D83E25479F2D;

1.28
date	2017.11.18.17.08.44;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A10693316E81B5E;

1.27
date	2017.11.18.17.05.51;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A10687E421523D2;

1.26
date	2017.11.18.16.43.07;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A10633315FA19F2;

1.25
date	2017.11.18.16.02.05;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A1059874C70192A;

1.24
date	2017.08.08.16.12.04;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005989E2EA3534A8E9;

1.23
date	2017.03.19.19.19.51;	author tg;	state Exp;
branches;
next	1.22;
commitid	10058CED9DF339F2D5D;

1.22
date	2016.10.30.02.38.35;	author tg;	state Exp;
branches;
next	1.21;
commitid	10058155D3C0F05E9E0;

1.21
date	2016.10.07.19.38.22;	author tg;	state Exp;
branches;
next	1.20;
commitid	10057F7F9C57D72FA0D;

1.20
date	2014.07.25.22.10.23;	author tg;	state Exp;
branches;
next	1.19;
commitid	10053D2D5E32C86DE4C;

1.19
date	2014.07.25.21.46.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	10053D2D0377D63036C;

1.18
date	2012.12.30.18.18.06;	author tg;	state Exp;
branches;
next	1.17;
commitid	10050E085670C2F3A0B;

1.17
date	2012.06.08.16.55.28;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FD22E961A7F5A95;

1.16
date	2012.06.07.22.14.17;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004FD127D17185BC28;

1.15
date	2011.07.16.21.57.57;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004E2209506F4A1334;

1.14
date	2011.07.02.22.45.14;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004E0F9F8409E98500;

1.12
date	2011.07.02.22.44.46;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004E0F9F6B34E5C0C8;

1.11
date	2010.04.08.15.31.04;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004BBDF6C54CC9A0DB;

1.10
date	2009.10.18.17.38.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004ADB52943E222C86;

1.9
date	2009.10.18.17.27.54;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004ADB50276D298069;

1.8
date	2009.10.06.09.54.04;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004ACB13C97E8DE1DB;

1.7
date	2009.10.06.09.09.43;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004ACB09645E2E4F73;

1.6
date	2009.09.19.22.42.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004AB55E716077E8C2;

1.5
date	2008.05.13.13.08.26;	author tg;	state Exp;
branches;
next	1.4;
commitid	100482992BC01EE89A1;

1.4
date	2008.03.24.03.14.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	10047E71C896F9FA505;

1.3
date	2006.11.11.00.22.19;	author tg;	state Exp;
branches;
next	1.2;
commitid	100455517C302E9791B;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.38
log
@drop <sys/termios.h> as requested by musl libc;
no complaints from https://stackoverflow.com/q/53200928/2171120

also, don’t check for <termios.h> separately and streamline includes;
bump version while here
@
text
@/*
 *	UNIX Tty and Process interface
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.37 2018/11/11 18:15:38 tg Exp $");

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <fcntl.h>

#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#if HAVE_UTMP_H
#include <utmp.h>
#endif

int idleout = 1;

/* We use the defines in sys/ioctl to determine what type
 * tty interface the system uses and what type of system
 * we actually have.
 */
#if defined(HAVE_POSIX_TERMIOS)
#include <termios.h>
#elif defined(HAVE_SYSV_TERMIO)
#include <termio.h>
#include <sys/termio.h>
#elif defined(HAVE_SGTTY_H)
#include <sgtty.h>
#endif

#ifdef HAVE_OPENPTY
#ifdef HAVE_PTY_H
#include <pty.h>
#endif
#ifdef HAVE_UTIL_H
#include <util.h>
#endif
#endif

/* Straight from the GNU autoconf texinfo documentation */
#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

/* I'm not sure if SCO_UNIX and ISC have __svr4__ defined, but I think
   they might */
#ifdef M_SYS5
#ifndef M_XENIX
#include <sys/stream.h>
#include <sys/ptem.h>
#ifndef __svr4__
#define __svr4__ 1
#endif
#endif
#endif

#ifdef ISC
#ifndef __svr4__
#define __svr4__ 1
#endif
#endif

#ifdef __svr4__
#include <stropts.h>
#endif

/* JOE include files */

#include "main.h"
#include "path.h"
#include "scrn.h"
#include "tty.h"
#include "utils.h"
#include "ushell.h"

/** Aliased defines **/

/* O_NDELAY, O_NONBLOCK, and FNDELAY are all synonyms for placing a descriptor
 * in non-blocking mode; we make whichever one we have look like O_NDELAY
 */
#ifndef O_NDELAY
#ifdef O_NONBLOCK
#define O_NDELAY O_NONBLOCK
#endif
#ifdef FNDELAY
#define O_NDELAY FNDELAY
#endif
#endif

/* Some systems define this, some don't */
#ifndef sigmask
#define sigmask(x) (1<<((x)-1))
#endif

/* Some BSDs don't have TILDE */
#ifndef TILDE
#define TILDE 0
#endif

/* Global configuration variables */

int noxon = 0;			/* Set if ^S/^Q processing should be disabled */
int Baud = 0;			/* Baud rate from joerc, cmd line or environment */

/* The terminal */

FILE *termin = NULL;
FILE *termout = NULL;

/* Original state of tty */

#ifdef HAVE_POSIX_TERMIOS
struct termios oldterm;
#else /* HAVE_POSIX_TERMIOS */
#ifdef HAVE_SYSV_TERMIO
static struct termio oldterm;
#else /* HAVE_SYSV_TERMIO */
static struct sgttyb oarg;
static struct tchars otarg;
static struct ltchars oltarg;
#endif /* HAVE_SYSV_TERMIO */
#endif /* HAVE_POSIX_TERMIOS */

/* Output buffer, index and size */

unsigned char *obuf = NULL;
int obufp = 0;
int obufsiz;

/* The baud rate */

unsigned baud;			/* Bits per second */
unsigned long upc;		/* Microseconds per character */

/* TTY Speed code to baud-rate conversion table (this is dumb- is it really
 * too much to ask for them to just use an integer for the baud-rate?)
 */

static int speeds[] = {
	B50, 50, B75, 75, B110, 110, B134, 134, B150, 150, B200, 200,
	B300, 300, B600, 600,
	B1200, 1200, B1800, 1800, B2400, 2400, B4800, 4800, B9600, 9600
#ifdef EXTA
	    , EXTA, 19200
#endif
#ifdef EXTB
	    , EXTB, 38400
#endif
#ifdef B19200
	    , B19200, 19200
#endif
#ifdef B38400
	    , B38400, 38400
#endif
};

/* Input buffer */

int have = 0;			/* Set if we have pending input */
static unsigned char havec;	/* Character read in during pending input check */
int leave = 0;			/* When set, typeahead checking is disabled */

/* TTY mode flag.  1 for open, 0 for closed */
static int ttymode = 0;

/* Signal state flag.  1 for joe, 0 for normal */
static int ttysig = 0;

#if WANT_FORK
/* Stuff for shell windows */

static pid_t kbdpid;		/* PID of kbd client */
static int ackkbd = -1;		/* Editor acks keyboard client to this */

static int mpxfd;		/* Editor reads packets from this fd */
static int mpxsfd;		/* Clients send packets to this fd */

static int nmpx = 0;
static int tty_accept = NO_MORE_DATA;	/* =-1 if we have last packet */

struct packet {
	MPX *who;
	int size;
	int ch;
	unsigned char data[1024];
} pack;

MPX asyncs[NPROC];
#endif

/* Set signals for JOE */
void sigjoe(void)
{
	if (ttysig)
		return;
	ttysig = 1;
	joe_set_signal(SIGHUP, ttsig);
	joe_set_signal(SIGTERM, ttsig);
	joe_set_signal(SIGINT, SIG_IGN);
	joe_set_signal(SIGPIPE, SIG_IGN);
}

/* Restore signals for exiting */
void signrm(int inchild)
{
	if (!ttysig)
		return;
	if (!inchild)
		ttysig = 0;
	joe_set_signal(SIGHUP, SIG_DFL);
	joe_set_signal(SIGTERM, SIG_DFL);
	joe_set_signal(SIGINT, SIG_DFL);
	joe_set_signal(SIGPIPE, SIG_DFL);
}

/* Open terminal and set signals */

void ttopen(void)
{
	sigjoe();
	ttopnn();
}

/* Close terminal and restore signals */

void ttclose(void)
{
	ttclsn();
	signrm(0);
}

static volatile sig_atomic_t winched = 0;
#ifdef SIGWINCH
/* Window size interrupt handler */
static RETSIGTYPE winchd(int unused)
{
	winched = 1;
	REINSTALL_SIGHANDLER(SIGWINCH, winchd);
}
#endif

/* Second ticker */

static volatile sig_atomic_t ticked = 0;
extern int dostaupd;
static RETSIGTYPE dotick(int unused)
{
	ticked = 1;
}

void tickoff(void)
{
	alarm(0);
}

void tickon(void)
{
	ticked = 0;
	joe_set_signal(SIGALRM, dotick);
	alarm(1);
}

/* Open terminal */

static void baud_reset(int);

void ttopnn(void)
{
	int bbaud;

#ifdef HAVE_POSIX_TERMIOS
	struct termios newterm;
#else
#ifdef HAVE_SYSV_TERMIO
	struct termio newterm;
#else
	struct sgttyb arg;
	struct tchars targ;
	struct ltchars ltarg;
#endif
#endif

	if (!termin) {
		if (idleout ? (!(termin = stdin) || !(termout = stdout)) : (!(termin = fopen("/dev/tty", "r")) || !(termout = fopen("/dev/tty", "w")))) {
			fprintf(stderr, "Couldn\'t open /dev/tty\n");
			exit(1);
		} else {
#ifdef SIGWINCH
			joe_set_signal(SIGWINCH, winchd);
#endif
		}
	}

	if (ttymode)
		return;
	ttymode = 1;
	fflush(termout);

#ifdef HAVE_POSIX_TERMIOS
	tcgetattr(fileno(termin), &oldterm);
	newterm = oldterm;
	newterm.c_lflag = 0;
	if (noxon)
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR | IXON | IXOFF);
	else
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR);
	newterm.c_oflag = 0;
	newterm.c_cc[VMIN] = 1;
	newterm.c_cc[VTIME] = 0;
	tcsetattr(fileno(termin), TCSADRAIN, &newterm);
	bbaud = cfgetospeed(&newterm);
#else
#ifdef HAVE_SYSV_TERMIO
	ioctl(fileno(termin), TCGETA, &oldterm);
	newterm = oldterm;
	newterm.c_lflag = 0;
	if (noxon)
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR | IXON | IXOFF);
	else
		newterm.c_iflag &= ~(ICRNL | IGNCR | INLCR);
	newterm.c_oflag = 0;
	newterm.c_cc[VMIN] = 1;
	newterm.c_cc[VTIME] = 0;
	ioctl(fileno(termin), TCSETAW, &newterm);
	bbaud = (newterm.c_cflag & CBAUD);
#else
	ioctl(fileno(termin), TIOCGETP, &arg);
	ioctl(fileno(termin), TIOCGETC, &targ);
	ioctl(fileno(termin), TIOCGLTC, &ltarg);
	oarg = arg;
	otarg = targ;
	oltarg = ltarg;
	arg.sg_flags = ((arg.sg_flags & ~(ECHO | CRMOD | XTABS | ALLDELAY | TILDE)) | CBREAK);
	if (noxon) {
		targ.t_startc = -1;
		targ.t_stopc = -1;
	}
	targ.t_intrc = -1;
	targ.t_quitc = -1;
	targ.t_eofc = -1;
	targ.t_brkc = -1;
	ltarg.t_suspc = -1;
	ltarg.t_dsuspc = -1;
	ltarg.t_rprntc = -1;
	ltarg.t_flushc = -1;
	ltarg.t_werasc = -1;
	ltarg.t_lnextc = -1;
	ioctl(fileno(termin), TIOCSETN, &arg);
	ioctl(fileno(termin), TIOCSETC, &targ);
	ioctl(fileno(termin), TIOCSLTC, &ltarg);
	bbaud = arg.sg_ospeed;
#endif
#endif
	baud_reset(bbaud);
}

static void
baud_reset(int bbaud)
{
	size_t x = 0;

	baud = 9600;
	upc = 0;
	while (x < NELEM(speeds))
		if (bbaud == speeds[x]) {
			baud = speeds[x + 1];
			break;
		} else
			x += 2;
	if (Baud >= 50)
		baud = Baud;
	else
		Baud = baud;
	upc = DIVIDEND / baud;
	if (obuf)
		free(obuf);
	if ((TIMES * upc) == 0)
		obufsiz = 4096;
	else {
		obufsiz = 1000000 / (TIMES * upc);
		if (obufsiz > 4096)
			obufsiz = 4096;
	}
	if (!obufsiz)
		obufsiz = 1;
	obuf = malloc(obufsiz);
}

/* Close terminal */

void ttclsn(void)
{
	int oleave;

	if (ttymode)
		ttymode = 0;
	else
		return;

	oleave = leave;
	leave = 1;

	ttflsh();

#ifdef HAVE_POSIX_TERMIOS
	tcsetattr(fileno(termin), TCSADRAIN, &oldterm);
#else
#ifdef HAVE_SYSV_TERMIO
	ioctl(fileno(termin), TCSETAW, &oldterm);
#else
	ioctl(fileno(termin), TIOCSETN, &oarg);
	ioctl(fileno(termin), TIOCSETC, &otarg);
	ioctl(fileno(termin), TIOCSLTC, &oltarg);
#endif
#endif

	leave = oleave;
}

/* Timer interrupt handler */

static volatile sig_atomic_t yep;
static RETSIGTYPE dosig(int unused)
{
	yep = 1;
}

/* FLush output and check for typeahead */

#ifdef HAVE_SETITIMER
#ifdef SIG_SETMASK
static void maskit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigaddset(&set, SIGALRM);
	sigprocmask(SIG_SETMASK, &set, NULL);
}

static void unmaskit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigprocmask(SIG_SETMASK, &set, NULL);
}

static void pauseit(void)
{
	sigset_t set;

	sigemptyset(&set);
	sigsuspend(&set);
}

#else
static void maskit(void)
{
	sigsetmask(sigmask(SIGALRM));
}

static void unmaskit(void)
{
	sigsetmask(0);
}

static void pauseit(void)
{
	sigpause(0);
}

#endif
#endif

int ttflsh(void)
{
	/* Flush output */
	if (obufp) {
		unsigned long usec = obufp * upc;	/* No. usecs this write should take */

#ifdef HAVE_SETITIMER
		if (usec >= 50000 && baud < 9600) {
			struct itimerval a, b;

			a.it_value.tv_sec = usec / 1000000;
			a.it_value.tv_usec = usec % 1000000;
			a.it_interval.tv_usec = 0;
			a.it_interval.tv_sec = 0;
			alarm(0);
			joe_set_signal(SIGALRM, dosig);
			yep = 0;
			maskit();
			setitimer(ITIMER_REAL, &a, &b);
			joe_write(fileno(termout), obuf, obufp);
			while (!yep)
				pauseit();
			unmaskit();
		} else
			joe_write(fileno(termout), obuf, obufp);

#else

		joe_write(fileno(termout), obuf, obufp);

#ifdef FIORDCHK
		if (baud < 9600 && usec / 1000)
			nap(usec / 1000);
#endif

#endif

		obufp = 0;
	}

#if WANT_FORK
	/* Ack previous packet */
	if (ackkbd != -1 && tty_accept != NO_MORE_DATA && !have) {
		unsigned char c = 0;

		if (pack.who && pack.who->func)
			joe_write(pack.who->ackfd, &c, 1);
		else
			joe_write(ackkbd, &c, 1);
		tty_accept = NO_MORE_DATA;
	}
#endif

	/* Check for typeahead or next packet */

	if (!have && !leave) {
#if WANT_FORK
		if (ackkbd != -1) {
			ssize_t r;

			fcntl(mpxfd, F_SETFL, O_NDELAY);
			r = read(mpxfd, &pack, 1);
			fcntl(mpxfd, F_SETFL, 0);
			if (r == 1) {
				r = sizeof(struct packet) - 1024 - 1;
				if (joe_readex(mpxfd, (US &pack) + 1, r) == r &&
				    pack.size >= 0 && pack.size <= 1024 &&
				    joe_readex(mpxfd, pack.data,
				    pack.size) == pack.size) {
					have = 1;
					tty_accept = pack.ch;
				}
			}
		} else
#endif
		  {
			/* Set terminal input to non-blocking */
			fcntl(fileno(termin), F_SETFL, O_NDELAY);

			/* Try to read */
			if (read(fileno(termin), &havec, 1) == 1)
				have = 1;

			/* Set terminal back to blocking */
			fcntl(fileno(termin), F_SETFL, 0);
		}
	}
	return 0;
}

/* Read next character from input */

#if WANT_FORK
static void mpxdied(MPX *m);
#endif

static time_t last_time;

int ttgetc(void)
{
	time_t new_time;

	tickon();

 loop:
	new_time = time(NULL);
	if (new_time != last_time) {
		last_time = new_time;
		dostaupd = 1;
		ticked = 1;
	}
	ttflsh();
	while (winched) {
		winched = 0;
		edupd(1);
		ttflsh();
	}
	if (ticked) {
		edupd(0);
		ttflsh();
		tickon();
	}
#if WANT_FORK
	if (ackkbd != -1) {
		ssize_t r;
		if (!have) {
			/* wait for input */
			r = sizeof(struct packet) - 1024;

			if (joe_readex(mpxfd, &pack, r) != r ||
			    pack.size < 0 || pack.size > 1024 ||
			    joe_readex(mpxfd, pack.data,
			    pack.size) != pack.size) {
				if (winched || ticked)
					goto loop;
				ttsig(0);
			}
			tty_accept = pack.ch;
		}
		have = 0;
		if (pack.who) {
			/* got background input */
			if (tty_accept != NO_MORE_DATA) {
				if (pack.who->func) {
					pack.who->func(pack.who->object, pack.data, pack.size);
					edupd(1);
				}
			} else
				mpxdied(pack.who);
			goto loop;
		} else if (tty_accept != NO_MORE_DATA) {
			tickoff();
			return tty_accept;
		} else {
			tickoff();
			ttsig(0);
			return 0;
		}
	}
#endif
	if (have) {
		have = 0;
	} else if (read(fileno(termin), &havec, 1) < 1) {
		if (winched || ticked)
			goto loop;
		ttsig(0);
	}
	tickoff();
	return havec;
}

/* Write string to output */

void ttputs(unsigned char *s)
{
	while (*s) {
		obuf[obufp++] = *s++;
		if (obufp == obufsiz)
			ttflsh();
	}
}

/* Get window size */

void ttgtsz(int *x, int *y)
{
#ifdef TIOCGSIZE
	struct ttysize getit;
#else
#ifdef TIOCGWINSZ
	struct winsize getit;
#endif
#endif

	*x = 0;
	*y = 0;

#ifdef TIOCGSIZE
	if (ioctl(fileno(termout), TIOCGSIZE, &getit) != -1) {
		*x = getit.ts_cols;
		*y = getit.ts_lines;
	}
#else
#ifdef TIOCGWINSZ
	if (ioctl(fileno(termout), TIOCGWINSZ, &getit) != -1) {
		*x = getit.ws_col;
		*y = getit.ws_row;
	}
#endif
#endif
}

#ifndef SIGTSTP
/* void ttshell(char *s);  Run a shell command or if 's' is zero, run a
 * sub-shell
 */
static void ttshell(unsigned char *cmd);
static const char shmsg[] =
    "You are at the command shell.  Type 'exit' to return\n";

#if WANT_FORK
#define v_or_fork() fork()
#else
#define v_or_fork() vfork()
#endif

static void ttshell(unsigned char *cmd)
{
	int x, omode = ttymode;
	const char *sh;

	sh = getushell();
	ttclsn();
	if (!(x = v_or_fork())) {
		signrm(1);
		if (cmd)
			execl(sh, sh, "-c", cmd, NULL);
		else {
			write(2, shmsg, sizeof(shmsg) - 1);
			execl(sh, sh, NULL);
		}
		_exit(0);
	}
	if (x != -1)
		wait(NULL);
	if (omode)
		ttopnn();
}
#endif

#if WANT_FORK
/* Create keyboard task */

static int mpxresume(void)
{
	int fds[2];

	if (pipe(fds)) {
		ackkbd = -1;
		return (1);
	}
	tty_accept = NO_MORE_DATA;
	have = 0;
	if (!(kbdpid = fork())) {
		close(fds[1]);
		do {
			unsigned char c;
			int sta;

			pack.who = 0;
			sta = joe_read(fileno(termin), &c, 1);
			if (sta == 0)
				pack.ch = NO_MORE_DATA;
			else
				pack.ch = c;
			pack.size = 0;
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024);
		} while (joe_read(fds[0], &pack, 1) == 1);
		_exit(0);
	}
	close(fds[0]);
	ackkbd = fds[1];
	return (0);
}

/* Kill keyboard task */

static void mpxsusp(void)
{
	if (ackkbd!=-1) {
		kill(kbdpid, 9);
		while (wait(NULL) < 0 && errno == EINTR)
			/* do nothing */;
		close(ackkbd);
	}
}
#endif

/* We used to leave the keyboard copy task around during suspend, but
   Cygwin gets confused when two processes are waiting for input and you
   change the tty from raw to cooked (on the call to ttopnn()): the keyboard
   process was stuck in cooked until he got a carriage return- then he
   switched back to raw (he's supposed to switch to raw without waiting for
   the end of line). Probably this should be done for ttshell() as well. */

void ttsusp(void)
{
	int omode;

#ifdef SIGTSTP
	omode = ttymode;
#if WANT_FORK
	mpxsusp();
#endif
	ttclsn();
	fprintf(stderr, "You have suspended the program.  Type 'fg' to return\n");
	kill(0, SIGTSTP);
	if (omode)
		ttopnn();
#if WANT_FORK
	if (ackkbd!= -1)
		mpxresume();
#endif
#else
	ttshell(NULL);
#endif
}

#if WANT_FORK
/* Stuff for asynchronous I/O multiplexing.  We do not use streams or
   select() because joe needs to work on versions of UNIX which predate
   these calls.  Instead, when there is multiple async sources, we use
   helper processes which packetize data from the sources.  A header on each
   packet indicates the source.  There is no guarentee that packets getting
   written to the same pipe don't get interleaved, but you can reasonable
   rely on it with small packets. */

/* This code will explode if pipe, fork, etc. fail. --mirabilos */

static int mpxstart(void)
{
	int fds[2];

	if (pipe(fds)) {
		mpxfd = -1;
		mpxsfd = -1;
		return (1);
	}
	mpxfd = fds[0];
	mpxsfd = fds[1];
	return (mpxresume());
}

static void mpxend(void)
{
	mpxsusp();
	ackkbd = -1;
	close(mpxfd);
	close(mpxsfd);
	if (have)
		havec = pack.ch;
}

/* Get a pty/tty pair.  Returns open pty in 'ptyfd' and returns tty name
 * string in static buffer or NULL if couldn't get a pair.
 */

#ifdef __svr4__
#define USEPTMX 1
#else
#ifdef __CYGWIN__
#define USEPTMX 1
#endif
#endif

#ifdef sgi

/* Newer sgi machines can do it the __svr4__ way, but old ones can't */

extern char *_getpty(int *fildes, int oflag, mode_t mode, int nofork);

static unsigned char *getpty(int *ptyfd)
{
	return (unsigned char *)_getpty(ptyfd, O_RDWR, 0600, 0);
}

#else
#ifdef USEPTMX

/* Strange streams way */

extern char *ptsname(int);

static unsigned char *getpty(int *ptyfd)
{
	int fdm;

	*ptyfd = fdm = open("/dev/ptmx", O_RDWR);
	grantpt(fdm);
	unlockpt(fdm);
	return (unsigned char *)ptsname(fdm);
}

#else
#ifdef HAVE_OPENPTY

/* BSD function, present in libc5 and glibc2 and (duh) the BSDs */

static unsigned char *getpty(int *ptyfd)
{
	static unsigned char name[32];
	int ttyfd;

	if (openpty(ptyfd, &ttyfd, name, NULL, NULL) == 0)
	   return(name);
	else
	   return (NULL);
}

#else
/* The normal way: for each possible pty/tty pair, try to open the pty and
 * then the corresponding tty.  If both could be opened, close them both and
 * then re-open the pty.  If that succeeded, return with the opened pty and the
 * name of the tty.
 *
 * Logically you should only have to succeed in opening the pty- but the
 * permissions may be set wrong on the tty, so we have to try that too.
 * We close them both and re-open the pty because we want the forked process
 * to open the tty- that way it gets to be the controlling tty for that
 * process and the process gets to be the session leader.
 */

static unsigned char *getpty(int *ptyfd)
{
	int x, fd;
	unsigned char *orgpwd = pwd();
	static unsigned char **ptys = NULL;
	static const unsigned char *ttydir;
	static const unsigned char *ptydir;
	static unsigned char ttyname[32];

	if (!ptys) {
		/* HPUX systems */
		ttydir = UC "/dev/pty/";
		ptydir = UC "/dev/ptym/";
		if (chpwd(ptydir) || !(ptys = rexpnd(UC "pty*")))
			if (!ptys) {
				/* Everyone else */
				ttydir = ptydir = UC "/dev/";
				if (!chpwd(ptydir))
					ptys = rexpnd(UC "pty*");
			}
	}
	chpwd(orgpwd);

	if (ptys)
		for (fd = 0; ptys[fd]; ++fd) {
			strlcpy((char *)ttyname, (char *)ptydir, 32);
			strlcat((char *)ttyname, (char  *)(ptys[fd]), 32);
			if ((*ptyfd = open((char *)ttyname, O_RDWR)) >= 0) {
				ptys[fd][0] = 't';
				strlcpy((char *)ttyname, (char *)ttydir, 32);
				strlcat((char *)ttyname, (char *)(ptys[fd]), 32);
				ptys[fd][0] = 'p';
				x = open((char *)ttyname, O_RDWR);
				if (x >= 0) {
					close(x);
					close(*ptyfd);
					strlcpy((char *)ttyname, (char *)ptydir, 32);
					strlcat((char *)ttyname, (char *)(ptys[fd]), 32);
					*ptyfd = open((char *)ttyname, O_RDWR);
					ptys[fd][0] = 't';
					strlcpy((char *)ttyname, (char *)ttydir, 32);
					strlcat((char *)ttyname, (char *)(ptys[fd]), 32);
					ptys[fd][0] = 'p';
					return ttyname;
				} else
					close(*ptyfd);
			}
		}
	return NULL;
}

#endif
#endif
#endif

/* Shell dies signal handler.  Puts pty in non-block mode so
 * that read returns with <1 when all data from process has
 * been read. */
static volatile sig_atomic_t dead = 0;
int death_fd;
static RETSIGTYPE death(int unused)
{
	fcntl(death_fd,F_SETFL,O_NDELAY);
	wait(NULL);
	dead = 1;
}

#ifndef SIGCHLD
#define SIGCHLD SIGCLD
#endif

/* Build a new environment, but replace one variable */

extern unsigned char **mainenv;

static unsigned char **
newenv(unsigned char **old, const unsigned char *s)
{
	unsigned char **new;
	int x, y, z;

	for (x = 0; old[x]; ++x)
		/* nothing */;
	new = malloc((x + 2) * sizeof(unsigned char *));

	for (x = 0, y = 0; old[x]; ++x) {
		for (z = 0; s[z] != '='; ++z)
			if (s[z] != old[x][z])
				break;
		if (s[z] == '=') {
			if (s[z + 1])
				new[y++] = (void *)strdup((const char *)s);
		} else
			new[y++] = old[x];
	}
	if (x == y)
		new[y++] = (void *)strdup((const char *)s);
	new[y] = 0;
	return new;
}

/* Create a shell process */

MPX *
mpxmk(int *ptyfd, const unsigned char *cmd, unsigned char **args,
    void (*func)(B*, unsigned char *, int), void *object,
    void (*die)(B*), void *dieobj)
{
	unsigned char buf[80];
	int fds[2];
	int comm[2];
	pid_t pid;
	int x;
	MPX *m = NULL;
	unsigned char *name;

	/* Get pty/tty pair */
	if (!(name = getpty(ptyfd)))
		return NULL;

	/* Find free slot */
	for (x = 0; x != NPROC; ++x)
		if (!asyncs[x].func) {
			m = asyncs + x;
			break;
		}
	if (x==NPROC)
		return NULL;

	/* PID number pipe */
	if (pipe(comm))
		return (NULL);

	/* Acknowledgement pipe */
	if (pipe(fds)) {
		/* don't leak in error case */
 pipout:
		close(comm[0]);
		close(comm[1]);
		return (NULL);
	}
	m->ackfd = fds[1];

	/*
	 * Fixes cygwin console bug: if you fork() with inverse video
	 * it assumes you want ESC [ 0 m to keep it in inverse video
	 * from then on.
	 */
	set_attr(maint->t,0);

	/* Flush output */
	ttflsh();

	/* Bump no. current async inputs to joe */
	++nmpx;

	/* Start input multiplexer */
	if (ackkbd == -1)
		if (mpxstart()) {
			close(fds[0]);
			close(fds[1]);
			m->ackfd = -1;
			--nmpx;
			goto pipout;
		}

	/* Remember callback function */
	m->func = func;
	m->object = object;
	m->die = die;
	m->dieobj = dieobj;

	/* Create processes... */
	if (!(m->kpid = fork())) {
		/*
		 * This process copies data from shell to joe.
		 * After each packet it sends to joe it waits for
		 * an acknowledgement from joe so that it can not get
		 * too far ahead with buffering.
		 */

		/* Close joe side of pipes */
		close(fds[1]);
		close(comm[0]);

		/* Flag which indicates child died */
		dead = 0;
		death_fd = *ptyfd;
		joe_set_signal(SIGCHLD, death);

		if (!(pid = fork())) {
			/* This process becomes the shell */
			unsigned char **env;

			signrm(0);

			/* Close pty (we only need tty) */
			close(*ptyfd);

			/*
			 * All of this stuff is for dissociating ourself from
			 * the controlling tty (session leader) and starting a
			 * new session. This is the most non-portable part of
			 * UNIX — second only to pty/tty pair creation.
			 */
#ifndef HAVE_LOGIN_TTY

#ifdef TIOCNOTTY
			x = open("/dev/tty", O_RDWR);
			ioctl(x, TIOCNOTTY, 0);
#endif

			/* I think you do setprgp(0,0) on systems with no setsid() */
			setsid();
#ifndef _MINIX
/* http://mail-index.netbsd.org/pkgsrc-bugs/2011/06/13/msg043281.html */
#ifndef SETPGRP_VOID
			setpgrp(0, 0);
#else
			setpgrp();
#endif
#endif

#endif
			/* Close all fds */
			for (x = 0; x != 32; ++x) {
				/* Yes, this is quite a kludge... */
				/* All in the name of portability */
				close(x);
			}

			/* Open the TTY as standard input */
			if ((x = open((char *)name, O_RDWR)) != -1) {
				env = newenv(mainenv, UC "TERM=");

#ifdef HAVE_LOGIN_TTY
				login_tty(x);

#else
				/* This tells the fd that it's a tty (I think) */
#ifdef __svr4__
				ioctl(x, I_PUSH, "ptem");
				ioctl(x, I_PUSH, "ldterm");
#endif

				/* Open stdout, stderr */
				if (dup(x)) {}	/* standard output */
				if (dup(x)) {}	/* standard error */
				/*
				 * yes, stdin, stdout, and stderr must
				 * all be open for reading and writing.
				 * On some systems the shell assumes this.
				 */
#endif

				/*
				 * We could probably have a special TTY
				 * setup for JOE, but for now we'll just
				 * use the TTY setup for the TTY was was
				 * run on.
				 */
#ifdef HAVE_POSIX_TERMIOS
				tcsetattr(0, TCSADRAIN, &oldterm);
#else
#ifdef HAVE_SYSV_TERMIO
				ioctl(0, TCSETAW, &oldterm);
#else
				ioctl(0, TIOCSETN, &oarg);
				ioctl(0, TIOCSETC, &otarg);
				ioctl(0, TIOCSLTC, &oltarg);
#endif
#endif

				/* Execute the shell */
				execve((const char *)cmd, (char **)args, (char **)env);

				/* If shell didn't execute */
				joe_snprintf_1((char *)buf,sizeof(buf),"Couldn't execute shell '%s'\n",cmd);
				if (write(0,(char *)buf,strlen((char *)buf))) {}
				sleep(1);
			}

			_exit(0);
		}

		/* Tell JOE PID of shell */
		joe_write(comm[1], &pid, sizeof(pid));

		/* sigpipe should be ignored here. */

		/* This process copies data from shell to JOE until EOF.  It creates a packet
		   for each data */


		/* We don't really get EOF from a pty- it would just wait forever
		   until someone else writes to the tty.  So: when the shell
		   dies, the child died signal handler death() puts pty in non-block
		   mode.  This allows us to read any remaining data- then
		   read returns 0 and we know we're done. */

 loop:
		pack.who = m;
		pack.ch = 0;

		/* Read data from process */
		pack.size = joe_read(*ptyfd, pack.data, 1024);

		/* On SUNOS 5.8, the very first read from the pty returns 0 for some reason */
		if (!pack.size)
			pack.size = joe_read(*ptyfd, pack.data, 1024);

		if (pack.size > 0) {
			/* Send data to JOE, wait for ack */
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024 + pack.size);

			joe_read(fds[0], &pack, 1);
			goto loop;
		} else {
			/* Shell died: return */
			pack.ch = NO_MORE_DATA;
			pack.size = 0;
			joe_write(mpxsfd, &pack, sizeof(struct packet) - 1024);

			_exit(0);
		}
	}
	joe_read(comm[0], &m->pid, sizeof(m->pid));

	/* We only need comm once */
	close(comm[0]);
	close(comm[1]);

	/* Close other side of copy process pipe */
	close(fds[0]);
	return m;
}

static void mpxdied(MPX *m)
{
	if (!--nmpx)
		mpxend();
	while (wait(NULL) < 0 && errno == EINTR)
		/* do nothing */;
	if (m->die)
		m->die(m->dieobj);
	m->func = NULL;
	edupd(1);
}
#endif

void
tty_xonoffbaudrst(void)
{
#ifdef HAVE_POSIX_TERMIOS
	struct termios newterm;
#else
#ifdef HAVE_SYSV_TERMIO
	struct termio newterm;
#else
	struct sgttyb arg;
	struct tchars targ;
#endif
#endif

#ifdef HAVE_POSIX_TERMIOS
	tcgetattr(fileno(termin), &newterm);
	if (noxon)
		newterm.c_iflag &= ~(IXON | IXOFF);
	else
		newterm.c_iflag |= (IXON | IXOFF);
	tcsetattr(fileno(termin), TCSADRAIN, &newterm);
	baud_reset(cfgetospeed(&newterm));
#else
#ifdef HAVE_SYSV_TERMIO
	ioctl(fileno(termin), TCGETA, &newterm);
	if (noxon)
		newterm.c_iflag &= ~(IXON | IXOFF);
	else
		newterm.c_iflag |= (IXON | IXOFF);
	ioctl(fileno(termin), TCSETAW, &newterm);
	baud_reset(newterm.c_cflag & CBAUD);
#else
	ioctl(fileno(termin), TIOCGETP, &arg);
	ioctl(fileno(termin), TIOCGETC, &targ);
	if (noxon) {
		targ.t_startc = -1;
		targ.t_stopc = -1;
	} else {
		targ.t_startc = otarg.t_startc;
		targ.t_stopc = otarg.t_stopc;
	}
	ioctl(fileno(termin), TIOCSETC, &targ);
	baud_reset(arg.sg_ospeed);
#endif
#endif
}
@


1.37
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.36 2018/01/06 00:28:33 tg Exp $");
d36 7
a42 14
#ifdef HAVE_POSIX_TERMIOS
#  include <termios.h>
# ifdef HAVE_SYS_TERMIOS_H
#  include <sys/termios.h>
# endif
#else
#  ifdef HAVE_SYSV_TERMIO
#    include <termio.h>
#    include <sys/termio.h>
#  else
#   ifdef HAVE_SGTTY_H
#    include <sgtty.h>
#   endif
#  endif
@


1.36
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.35 2017/12/08 02:28:06 tg Exp $");
d562 2
d565 12
a576 7
			if (read(mpxfd, &pack, sizeof(struct packet) - 1024) > 0) {
				fcntl(mpxfd, F_SETFL, 0);
				joe_read(mpxfd, pack.data, pack.size);
				have = 1;
				tty_accept = pack.ch;
			} else
				fcntl(mpxfd, F_SETFL, 0);
a603 3
#if WANT_FORK
	int stat_;
#endif
d628 9
a636 6
		if (!have) {	/* Wait for input */
			stat_ = read(mpxfd, &pack, sizeof(struct packet) - 1024);

			if (pack.size && stat_ > 0) {
				joe_read(mpxfd, pack.data, pack.size);
			} else if (stat_ < 1) {
d639 1
a639 2
				else
					ttsig(0);
d644 2
a645 1
		if (pack.who) {	/* Got bknd input */
d654 3
d658 3
a660 9
			if (tty_accept != NO_MORE_DATA) {
				tickoff();
				return tty_accept;
			}
			else {
				tickoff();
				ttsig(0);
				return 0;
			}
d666 4
a669 7
	} else {
		if (read(fileno(termin), &havec, 1) < 1) {
			if (winched || ticked)
				goto loop;
			else
				ttsig(0);
		}
d1079 5
a1083 2
	/* Fixes cygwin console bug: if you fork() with inverse video he assumes you want
	 * ESC [ 0 m to keep it in inverse video from then on. */
d1110 6
a1115 4
		/* This process copies data from shell to joe */
		/* After each packet it sends to joe it waits for
		   an acknowledgement from joe so that it can not get
		   too far ahead with buffering */
d1128 2
d1135 6
a1140 4
			/* All of this stuff is for disassociating ourself from
			   controlling tty (session leader) and starting a new
			   session.  This is the most non-portable part of UNIX- second
			   only to pty/tty pair creation. */
d1148 2
a1149 1
			setsid();	/* I think you do setprgp(0,0) on systems with no setsid() */
d1161 9
a1169 7
			for (x = 0; x != 32; ++x)
				close(x);	/* Yes, this is quite a kludge... all in the
						   name of portability */

			/* Open the TTY */
			if ((x = open((char *)name, O_RDWR)) != -1) {	/* Standard input */
				unsigned char **env = newenv(mainenv, UC "TERM=");
d1191 6
a1196 2
				/* We could probably have a special TTY set-up for JOE, but for now
				 * we'll just use the TTY setup for the TTY was was run on */
@


1.35
log
@label indent; small tweaks while here
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.34 2017/12/08 02:17:23 tg Exp $");
d940 2
a941 2
	static unsigned char *ttydir;
	static unsigned char *ptydir;
d945 4
a948 3
		ttydir = US "/dev/pty/";
		ptydir = US "/dev/ptym/";	/* HPUX systems */
		if (chpwd(ptydir) || !(ptys = rexpnd(US "pty*")))
d950 2
a951 1
				ttydir = ptydir = US "/dev/";	/* Everyone else */
d953 1
a953 1
					ptys = rexpnd(US "pty*");
d1010 2
a1011 1
static unsigned char **newenv(unsigned char **old, unsigned char *s)
d1026 1
a1026 1
				new[y++] = s;
d1031 1
a1031 1
		new[y++] = s;
d1156 1
a1156 1
				unsigned char **env = newenv(mainenv, US "TERM=");
@


1.34
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.32 2017/12/06 23:02:05 tg Exp $");
d1216 1
a1216 1
	      loop:
@


1.33
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d916 3
a918 3
        if (openpty(ptyfd, &ttyfd, name, NULL, NULL) == 0)
           return(name);
        else
@


1.32
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.31 2017/12/06 21:17:01 tg Exp $");
d404 1
a404 1
		joe_free(obuf);
d414 1
a414 1
	obuf = (unsigned char *) joe_malloc(obufsiz);
d1013 3
a1015 2
	for (x = 0; old[x]; ++x) ;
	new = (unsigned char **) joe_malloc((x + 2) * sizeof(unsigned char *));
@


1.31
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tty.c,v 1.30 2017/12/02 02:07:33 tg Exp $");
d1034 4
a1037 1
MPX *mpxmk(int *ptyfd, const unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj)
@


1.30
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d13 3
a15 1
#ifdef HAVE_SYS_STAT_H
a16 2
#endif
#ifdef HAVE_SYS_IOCTL_H
d18 1
a18 2
#endif
#ifdef HAVE_FCNTL_H
a19 7
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
d719 1
a719 1
static void ttshell PARAMS((unsigned char *cmd));
@


1.29
log
@merge fixes developed on Debian
@
text
@a0 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.27 2017/11/18 17:05:51 tg Exp $ */
d11 2
a12 1
#include <sys/types.h>
a18 1
#include <stdio.h>
@


1.28
log
@fix static functions’ scope
@
text
@d606 1
d608 1
a873 1
#endif
a1042 1
#if WANT_FORK
@


1.27
log
@disable anything using fork on NOMMU systems
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.19 2014/07/25 21:46:16 tg Exp $ */
d599 1
a599 1
void mpxdied(MPX *m);
d722 1
d758 1
d1258 1
a1258 1
void mpxdied(MPX *m)
@


1.26
log
@make ttshell vfork-safe
@
text
@d206 1
d226 1
d553 1
d564 1
d569 1
d579 3
a581 1
		} else {
d598 1
d600 1
d629 1
d666 1
d758 1
d804 1
d819 1
d821 1
d827 1
d830 1
d836 1
d870 1
d1040 1
d1267 1
@


1.25
log
@prepare making ublock.c vfork-safe:
avoid overwriting a global variable in the child
@
text
@d711 14
a724 1
void ttshell(unsigned char *cmd)
d731 2
a732 7
	if ((x = fork()) != 0) {
		if (x != -1)
			wait(NULL);
		if (omode)
			ttopnn();
	} else {
		signrm(0);
d736 1
a736 1
			fprintf(stderr, "You are at the command shell.  Type 'exit' to return\n");
d741 4
@


1.24
log
@more GCC 7 weirdness
@
text
@d239 1
a239 1
void signrm(void)
d243 2
a244 1
	ttysig = 0;
d264 1
a264 1
	signrm();
d724 1
a724 1
		signrm();
d1090 1
a1090 1
			signrm();
@


1.23
log
@_some_ type cleanup (time_t, sig_atomic_t)

still unsafe signal handler crap abound :(
@
text
@d411 1
a411 1
	if (!(TIMES * upc))
@


1.22
log
@apply fixes from the Win32 build
@
text
@d266 1
a266 1
static int winched = 0;
d271 1
a271 1
	++winched;
d278 1
a278 1
int ticked = 0;
d456 1
a456 1
static int yep;
d592 1
a592 1
long last_time;
d597 1
a597 2
	long new_time;

d601 1
a601 1
      loop:
d965 1
a965 1
int dead = 0;
@


1.21
log
@silence gcc
@
text
@a873 1
	unsigned char *name;
@


1.20
log
@size_t, while here (warning: comparison between signed and unsigned)
@
text
@d1017 1
a1017 1
	MPX *m;
@


1.19
log
@fix speeds[] array access/sizing; from dcb (LP#1348614)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.18 2012/12/30 18:18:06 tg Exp $ */
d394 1
a394 1
	int x = 0;
@


1.18
log
@use SHELL and EXECSHELL in favour of /bin/sh (with stat and access checks)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.17 2012/06/08 16:55:28 tg Exp $ */
d177 2
a178 2
	B50, 50, B75, 75, B110, 110, B134, 134, B150, 150, B200, 200, B300,
	300, B600, 600,
d394 1
a394 1
	int x;
d398 1
a398 1
	for (x = 0; x != 30; x += 2)
d402 2
a403 1
		}
@


1.17
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.16 2012/06/07 22:14:17 tg Exp $ */
d111 1
d713 1
a713 1
	unsigned char *s = (unsigned char *)getenv("SHELL");
d715 1
a715 4
	if (!s) {
		s = US "/bin/sh";
		/* return; */
	}
d725 1
a725 1
			execl((char *)s, (char *)s, "-c", cmd, NULL);
d728 1
a728 1
			execl((char *)s, (char *)s, NULL);
d1009 1
a1009 1
MPX *mpxmk(int *ptyfd, unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj)
d1161 1
a1161 1
				execve((char *)cmd, (char **)args, (char **)env);
@


1.16
log
@_FORTIFY_MY_ARSE
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.15 2011/07/16 21:57:57 tg Exp $ */
a798 5
#ifdef junk
	/* Hmmm... this should not have been necessary */
	if (ackkbd != -1)
		kill(kbdpid, SIGCONT);
#endif
@


1.15
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.14 2011/07/02 22:45:14 tg Exp $ */
d1144 7
a1150 4
				dup(x);
				dup(x);	/* Standard output, standard error */
				/* (yes, stdin, stdout, and stderr must all be open for reading and
				 * writing.  On some systems the shell assumes this */
@


1.14
log
@some better extern declarations
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.11 2010/04/08 15:31:04 tg Exp $ */
d738 1
a738 1
static void mpxresume(void)
d741 5
a745 1
	pipe(fds);
d767 1
d821 3
a823 1
static void mpxstart(void)
d826 6
a831 1
	pipe(fds);
d834 1
a834 1
	mpxresume();
d1039 14
d1065 7
a1071 1
		mpxstart();
a1078 7
	/* Acknowledgement pipe */
	pipe(fds);
	m->ackfd = fds[1];

	/* PID number pipe */
	pipe(comm);

d1169 1
a1169 1
				write(0,(char *)buf,strlen((char *)buf));
@


1.12
log
@Minix 3 has no setpgrp(); the setsid() call above is enough there
@
text
@d851 1
a851 1
extern char *_getpty();
d863 1
a863 1
extern char *ptsname();
@


1.11
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.10 2009/10/18 17:38:08 tg Exp $ */
d1089 2
d1096 1
@


1.10
log
@improve header handling
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.9 2009/10/18 17:27:54 tg Exp $ */
d594 1
a594 1
	int stat;
d620 1
a620 1
			stat = read(mpxfd, &pack, sizeof(struct packet) - 1024);
d622 1
a622 1
			if (pack.size && stat > 0) {
d624 1
a624 1
			} else if (stat < 1) {
@


1.9
log
@AIX has no <sys/termios.h> but jupp works fine, I’d say
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.8 2009/10/06 09:54:04 tg Exp $ */
d55 1
d57 1
@


1.8
log
@<time.h> is always needed
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.7 2009/10/06 09:09:43 tg Exp $ */
d47 1
d49 1
@


1.7
log
@if !HAVE_SETITIMER need <time.h> for GNU/Linux time(2)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.6 2009/09/19 22:42:41 tg Exp $ */
d66 10
a75 8
#ifdef HAVE_SETITIMER
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#else
#ifdef HAVE_TIME_H
#include <time.h>
#endif
@


1.6
log
@scan for <utmp.h> for login_tty on glibc
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.c,v 1.5 2008/05/13 13:08:26 tg Exp $ */
d70 4
@


1.5
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d35 4
@


1.4
log
@the GNU complainer collection strikes again: accept is a function, not
a variable (namespace collision)

10x Adam “replaced” Hoka, who maintains a jupp pkgsrc® source package
I was not even aware of…
@
text
@d1 1
@


1.3
log
@fix noxon option; add baud option (doesn't immediately take effect tho)
@
text
@d199 1
a199 1
static int accept = NO_MORE_DATA;	/* =-1 if we have last packet */
d534 1
a534 1
	if (ackkbd != -1 && accept != NO_MORE_DATA && !have) {
d541 1
a541 1
		accept = NO_MORE_DATA;
d553 1
a553 1
				accept = pack.ch;
d615 1
a615 1
			accept = pack.ch;
d619 1
a619 1
			if (accept != NO_MORE_DATA) {
d628 1
a628 1
			if (accept != NO_MORE_DATA) {
d630 1
a630 1
				return accept;
d727 1
a727 1
	accept = NO_MORE_DATA;
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d283 2
d287 1
a287 1
	int x, bbaud;
d372 7
d387 1
a387 1
	if (Baud)
d389 2
d1196 47
@


1.1
log
@Initial revision
@
text
@a14 1
#ifdef GWINSZ_IN_SYS_IOCTL
a17 1
#endif
a28 6
#ifdef HAVE_OPENPTY
#ifdef HAVE_PTY_H
#include <pty.h>
#endif
#endif

a35 2
#include "config.h"

d52 9
d93 1
d853 1
a853 1
/* BSD function, present in libc5 and glibc2 */
a856 1
	int fdm;
d902 2
a903 2
			strcpy((char *)ttyname, (char *)ptydir);
			strcat((char *)ttyname, (char  *)(ptys[fd]));
d906 2
a907 2
				strcpy((char *)ttyname, (char *)ttydir);
				strcat((char *)ttyname, (char *)(ptys[fd]));
d913 2
a914 2
					strcpy((char *)ttyname, (char *)ptydir);
					strcat((char *)ttyname, (char *)(ptys[fd]));
d917 2
a918 2
					strcpy((char *)ttyname, (char *)ttydir);
					strcat((char *)ttyname, (char *)(ptys[fd]));
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* UNIX Tty and Process interface
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
a10 3
/** System include files **/

/* These should exist on every UNIX system */
d12 1
d14 6
d21 1
a21 1
#include <signal.h>
d23 14
d38 3
a40 1
extern int errno;
d42 1
a42 3
int idleout=1;

#include <sys/param.h>
d50 10
a59 20
#ifdef TTYPOSIX

#ifdef SYSPOSIX
#include <sys/termios.h>
#else
#include <termios.h>
#endif

#else
#ifdef TTYSV

#ifdef SYSSV
#include <sys/termio.h>
#else
#include <termio.h>
#endif

#else
#include <sgtty.h>
#endif
d62 2
a63 8
/* If the signal SIGVTALRM exists, assume we have the setitimer system call
 * and the include file necessary for it.  I'm not so sure that this method
 * of detecting 'setitimer' is foolproof, so this is the only place where
 * SIGVTALRM will be checked... after here the itimer code will look for
 * ITIMER_REAL (which is defined in sys/time.h).
 */
#ifndef _SEQUENT_
#ifdef SIGVTALRM
d92 1
a92 1
#include "config.h"
d95 1
a95 11

/* The pwd function */
#ifdef TTYPOSIX
char *getcwd(); char *pwd() { static char buf[1024]; return getcwd(buf,1024); }
#else
#ifdef TTYSV
char *getcwd(); char *pwd() { static char buf[1024]; return getcwd(buf,1024); }
#else
char *getwd(); char *pwd() { static char buf[1024]; return getwd(buf); }
#endif
#endif
d123 2
a124 2
int noxon=0;	/* Set if ^S/^Q processing should be disabled */
int Baud=0;	/* Baud rate from joerc, cmd line or environment */
d128 2
a129 2
FILE *termin=0;
FILE *termout=0;
d133 1
a133 1
#ifdef TTYPOSIX
d135 2
a136 2
#else
#ifdef TTYSV
d138 1
a138 1
#else
d142 2
a143 2
#endif
#endif
d147 2
a148 2
char *obuf=0;
int obufp=0;
d153 2
a154 2
unsigned baud;		/* Bits per second */
unsigned long upc;	/* Microseconds per character */
d160 4
a163 4
static int speeds[]=
 {
 B50,50,B75,75,B110,110,B134,134,B150,150,B200,200,B300,300,B600,600,
 B1200,1200,B1800,1800,B2400,2400,B4800,4800,B9600,9600
d165 1
a165 1
 ,EXTA,19200
d168 1
a168 1
 ,EXTB,38400
d171 1
a171 1
 ,B19200,19200
d174 1
a174 1
 ,B38400,38400
d176 1
a176 1
 };
d180 1
a180 1
int have=0;		/* Set if we have pending input */
d182 1
a182 1
int leave=0;		/* When set, typeahead checking is disabled */
d185 1
a185 2

static int ttymode=0;
d188 1
a188 2

static int ttysig=0;
d192 2
a193 2
static int kbdpid;		/* PID of kbd client */
static int ackkbd= -1;		/* Editor acks keyboard client to this */
d198 2
a199 2
static int nmpx=0;
static int accept=MAXINT;	/* =MAXINT if we have last packet */
d201 6
a206 7
struct packet
 {
 MPX *who;
 int size;
 int ch;
 char data[1024];
 } pack;
a209 23
/* Versions of 'read' and 'write' which automatically retry during signals
 * (yuck, yuck, yuck... we the #$%#$@@ did they have to do this?) */

int jread(fd,buf,siz)
char *buf;
 {
 int rt;
 do
  rt=read(fd,buf,siz);
  while(rt<0 && errno==EINTR);
 return rt;
 }

int jwrite(fd,buf,siz)
char *buf;
 {
 int rt;
 do
  rt=write(fd,buf,siz);
  while(rt<0 && errno==EINTR);
 return rt;
 }

d211 10
a220 10

void sigjoe()
 {
 if(ttysig) return;
 ttysig=1;
 signal(SIGHUP,ttsig);
 signal(SIGTERM,ttsig);
 signal(SIGINT,SIG_IGN);
 signal(SIGPIPE,SIG_IGN);
 }
d223 10
a232 10

void signrm()
 {
 if(!ttysig) return;
 ttysig=0;
 signal(SIGHUP,SIG_DFL);
 signal(SIGTERM,SIG_DFL);
 signal(SIGINT,SIG_DFL);
 signal(SIGPIPE,SIG_DFL);
 }
d236 5
a240 5
void ttopen()
 {
 sigjoe();
 ttopnn();
 }
d244 5
a248 5
void ttclose()
 {
 ttclsn();
 signrm();
 }
d250 2
d253 5
a257 8

static int winched=0;

static void winchd()
 {
 ++winched;
#ifdef SIGWINCH
 signal(SIGWINCH,winchd);
a258 1
 }
d262 1
a262 1
int ticked=0;
d264 16
a279 2
static void dotick() { ticked=1; dostaupd=1; }
void tickoff() { alarm(0); }
d281 5
a285 7
#ifdef SA_INTERRUPT
struct sigaction vnew={dotick,0,SA_INTERRUPT};
#else
#ifdef SV_INTERRUPT
struct sigvec vnew={dotick,0,SV_INTERRUPT};
#endif
#endif
d287 2
a288 5
void tickon()
 {
 ticked=0;
#ifdef SA_INTERRUPT
 sigaction(SIGALRM,&vnew,(struct sigaction *)0);
d290 2
a291 2
#ifdef SV_INTERRUPT
 sigvec(SIGALRM,&vnew,(struct sigvec *)0);
d293 3
a295 1
 signal(SIGALRM,dotick);
a297 4
 alarm(1);
 }

/* Open terminal */
d299 5
a303 26
void ttopnn()
 {
 int x, bbaud;
 
#ifdef TTYPOSIX
 struct termios newterm;
#else
#ifdef TTYSV
 struct termio newterm;
#else
 struct sgttyb arg;
 struct tchars targ;
 struct ltchars ltarg;
#endif
#endif
 
 if(!termin)
  if(idleout ? (!(termin=stdin) || !(termout=stdout)) :
               (!(termin=fopen("/dev/tty","r")) || 
               !(termout=fopen("/dev/tty","w"))))
   {
   fprintf(stderr,"Couldn\'t open /dev/tty\n");
   exit(1);
   }
  else
   {
d305 1
a305 1
   signal(SIGWINCH,winchd);
d307 87
a393 73
   tickon();
   }
 
 if(ttymode) return;
 ttymode=1;
 fflush(termout);
 
#ifdef TTYPOSIX
 tcgetattr(fileno(termin),&oldterm);
 newterm=oldterm;
 newterm.c_lflag=0;
 if(noxon)  newterm.c_iflag&=~(ICRNL|IGNCR|INLCR|IXON|IXOFF);
 else newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
 newterm.c_oflag=0;
 newterm.c_cc[VMIN]=1;
 newterm.c_cc[VTIME]=0;
 tcsetattr(fileno(termin),TCSADRAIN,&newterm);
 bbaud=cfgetospeed(&newterm);
#else
#ifdef TTYSV
 ioctl(fileno(termin),TCGETA,&oldterm);
 newterm=oldterm;
 newterm.c_lflag=0;
 if(noxon)  newterm.c_iflag&=~(ICRNL|IGNCR|INLCR|IXON|IXOFF);
 else newterm.c_iflag&=~(ICRNL|IGNCR|INLCR);
 newterm.c_oflag=0;
 newterm.c_cc[VMIN]=1;
 newterm.c_cc[VTIME]=0;
 ioctl(fileno(termin),TCSETAW,&newterm);
 bbaud=(newterm.c_cflag&CBAUD);
#else
 ioctl(fileno(termin),TIOCGETP,&arg);
 ioctl(fileno(termin),TIOCGETC,&targ);
 ioctl(fileno(termin),TIOCGLTC,&ltarg);
 oarg=arg; otarg=targ; oltarg=ltarg;
 arg.sg_flags=( (arg.sg_flags&~(ECHO|CRMOD|XTABS|ALLDELAY|TILDE) ) | CBREAK) ;
 if(noxon) targ.t_startc= -1, targ.t_stopc= -1;
 targ.t_intrc= -1;
 targ.t_quitc= -1;
 targ.t_eofc= -1;
 targ.t_brkc= -1;
 ltarg.t_suspc= -1;
 ltarg.t_dsuspc= -1;
 ltarg.t_rprntc= -1;
 ltarg.t_flushc= -1;
 ltarg.t_werasc= -1;
 ltarg.t_lnextc= -1;
 ioctl(fileno(termin),TIOCSETN,&arg);
 ioctl(fileno(termin),TIOCSETC,&targ);
 ioctl(fileno(termin),TIOCSLTC,&ltarg);
 bbaud=arg.sg_ospeed;
#endif
#endif
 
 baud=9600; upc=0;
 for(x=0;x!=30;x+=2)
  if(bbaud==speeds[x])
   {
   baud=speeds[x+1];
   break;
   }
 if(Baud) baud=Baud;
 upc=DIVIDEND/baud;
 if(obuf) free(obuf);
 if(!(TIMES*upc)) obufsiz=4096;
 else
  {
  obufsiz=1000000/(TIMES*upc);
  if(obufsiz>4096) obufsiz=4096;
  }
 if(!obufsiz) obufsiz=1;
 obuf=(char *)malloc(obufsiz);
 }
d397 28
a424 25
void ttclsn()
 {
 int oleave;
 
 if(ttymode) ttymode=0;
 else return;
 
 oleave=leave; leave=1;
 
 ttflsh();
 
#ifdef TTYPOSIX
 tcsetattr(fileno(termin),TCSADRAIN,&oldterm);
#else
#ifdef TTYSV
 ioctl(fileno(termin),TCSETAW,&oldterm);
#else
 ioctl(fileno(termin),TIOCSETN,&oarg);
 ioctl(fileno(termin),TIOCSETC,&otarg);
 ioctl(fileno(termin),TIOCSLTC,&oltarg);
#endif
#endif
 
 leave=oleave;
 }
d429 4
a432 1
static void dosig() { yep=1; } 
d436 1
a436 1
#ifdef ITIMER_REAL
d438 69
a506 25
maskit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigaddset(&set,SIGALRM);
 sigprocmask(SIG_SETMASK,&set,NULL);
 }
unmaskit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigprocmask(SIG_SETMASK,&set,NULL);
 }
pauseit()
 {
 sigset_t set;
 sigemptyset(&set);
 sigsuspend(&set);
 }
#else
maskit() { sigsetmask(sigmask(SIGALRM)); }
unmaskit() { sigsetmask(0); }
pauseit() { sigpause(0); }
#endif
#endif
a507 25
int ttflsh()
 {
 /* Flush output */
 if(obufp)
  {
  unsigned long usec=obufp*upc;		/* No. usecs this write should take */
#ifdef ITIMER_REAL
  if(usec>=500000/HZ && baud<9600)
   {
   struct itimerval a,b;
   a.it_value.tv_sec=usec/1000000;
   a.it_value.tv_usec=usec%1000000;
   a.it_interval.tv_usec=0;
   a.it_interval.tv_sec=0;
   alarm(0);
   signal(SIGALRM,dosig); yep=0;
   maskit();
   setitimer(ITIMER_REAL,&a,&b);
   jwrite(fileno(termout),obuf,obufp);
   while(!yep) pauseit(0);
   unmaskit();
   tickon();
   }
  else jwrite(fileno(termout),obuf,obufp);
 
d509 2
a510 2
 
  jwrite(fileno(termout),obuf,obufp);
d513 2
a514 1
  if(baud<9600 && usec/1000) nap(usec/1000);
d518 41
a558 40
 
  obufp=0;
  }
 
 /* Ack previous packet */
 if(ackkbd!= -1 && accept!=MAXINT && !have)
  {
  char c=0;
  if(pack.who && pack.who->func) jwrite(pack.who->ackfd,&c,1);
  else jwrite(ackkbd,&c,1);
  accept=MAXINT;
  }
 
 /* Check for typeahead or next packet */
 
 if(!have && !leave)
  if(ackkbd!= -1)
   {
   fcntl(mpxfd,F_SETFL,O_NDELAY);
   if(read(mpxfd,&pack,sizeof(struct packet)-1024)>0)
    {
    fcntl(mpxfd,F_SETFL,0);
    jread(mpxfd,pack.data,pack.size);
    have=1, accept=pack.ch;
    }
   else fcntl(mpxfd,F_SETFL,0);
   }
  else
   {
   /* Set terminal input to non-blocking */
   fcntl(fileno(termin),F_SETFL,O_NDELAY);
  
   /* Try to read */
   if(read(fileno(termin),&havec,1)==1) have=1;
  
   /* Set terminal back to blocking */
   fcntl(fileno(termin),F_SETFL,0);
   }
 return 0;
 }
d562 1
a562 1
void mpxdied();
d564 77
a640 45
int ttgetc()
 {
 int stat;
 loop:
 ttflsh();
 while(winched) winched=0, edupd(1), ttflsh();
 if(ticked) edupd(0), ttflsh(), tickon();
 if(ackkbd!= -1)
  {
  if(!have)					/* Wait for input */
   {
   stat=read(mpxfd,&pack,sizeof(struct packet)-1024);
   if(pack.size && stat>0) jread(mpxfd,pack.data,pack.size);
   else if(stat<1)
    if(winched || ticked) goto loop;
    else ttsig(0);
   accept=pack.ch;
   }
  have=0;
  if(pack.who)					/* Got bknd input */
   {
   if(accept!=MAXINT)
    {
    if(pack.who->func)
     pack.who->func(pack.who->object,pack.data,pack.size),
     edupd(1);
    }
   else mpxdied(pack.who);
   goto loop;
   }
  else
   {
   if(accept!=MAXINT) return accept;
   else { ttsig(0); return 0; }
   }
  }
 if(have) have=0;
 else
  {
  if(read(fileno(termin),&havec,1)<1)
   if(winched || ticked) goto loop;
   else ttsig(0);
  }
 return havec;
 }
d644 8
a651 9
void ttputs(s)
char *s;
 {
 while(*s)
  {
  obuf[obufp++]= *s++;
  if(obufp==obufsiz) ttflsh();
  }
 }
d655 2
a656 3
void ttgtsz(x,y)
int *x, *y;
 {
d658 1
a658 1
 struct ttysize getit;
d661 1
a661 1
 struct winsize getit;
d664 4
a667 3
 
 *x=0; *y=0;
 
d669 4
a672 5
 if(ioctl(fileno(termout),TIOCGSIZE,&getit)!= -1)
  {
  *x=getit.ts_cols;
  *y=getit.ts_lines;
  }
d675 87
a761 38
 if(ioctl(fileno(termout),TIOCGWINSZ,&getit)!= -1)
  {
  *x=getit.ws_col;
  *y=getit.ws_row;
  }
#endif
#endif
 }

void ttshell(cmd)
char *cmd;
 {
 int x,omode=ttymode;
 char *s=getenv("SHELL");
 if(!s) return;
 ttclsn();
 if(x=fork())
  {
  if(x!= -1) wait(NULL);
  if(omode) ttopnn();
  }
 else
  {
  signrm();
  if(cmd) execl(s,s,"-c",cmd,NULL);
  else
   {
   fprintf(stderr,"You are at the command shell.  Type 'exit' to return\n");
   execl(s,s,NULL);
   }
  _exit(0);
  }
 }

void ttsusp()
 {
 int omode;
 tickoff();
d763 45
a807 51
 omode=ttymode;
 ttclsn();
 fprintf(stderr,"You have suspended the program.  Type 'fg' to return\n");
 kill(0,SIGTSTP);
 if(ackkbd!= -1)
  kill(kbdpid,SIGCONT);
 if(omode) ttopnn();
#else
 ttshell(NULL);
#endif
 tickon();
 }

void mpxstart()
 {
 int fds[2];
 pipe(fds);
 mpxfd=fds[0];
 mpxsfd=fds[1];
 pipe(fds);
 accept=MAXINT; have=0;
 if(!(kbdpid=fork()))
  {
  close(fds[1]);
  do
   {
   unsigned char c;
   int sta;
   pack.who=0;
   sta=jread(fileno(termin),&c,1);
   if(sta==0) pack.ch=MAXINT;
   else pack.ch=c;
   pack.size=0;
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024);
   }
   while(jread(fds[0],&pack,1)==1);
  _exit(0);
  }
 close(fds[0]);
 ackkbd=fds[1];
 }

void mpxend()
 {
 kill(kbdpid,9);
 while(wait(NULL)<0 && errno==EINTR);
 close(ackkbd); ackkbd= -1;
 close(mpxfd);
 close(mpxsfd);
 if(have) havec=pack.ch;
 }
d813 8
d827 4
a830 5
char *getpty(ptyfd)
int *ptyfd;
 {
 return _getpty(ptyfd,O_RDWR,0600,0);
 }
d833 1
a833 1
#ifdef __svr4__
d839 27
a865 10
char *getpty(ptyfd)
int *ptyfd;
 {
 int fdm;
 char *name;
 *ptyfd=fdm=open("/dev/ptmx",O_RDWR);
 grantpt(fdm);
 unlockpt(fdm);
 return ptsname(fdm);
 }
a867 1

d880 48
a927 47
char *getpty(ptyfd)
int *ptyfd;
 {
 int x, fd;
 char *orgpwd=pwd();
 static char **ptys=0;
 static char *ttydir;
 static char *ptydir;
 static char ttyname[32];

 if(!ptys)
  {
  ttydir="/dev/pty/"; ptydir="/dev/ptym/";	/* HPUX systems */
  if(chpwd(ptydir) || !(ptys=rexpnd("pty*")))
  if(!ptys)
   {
   ttydir=ptydir="/dev/";			/* Everyone else */
   if(!chpwd(ptydir)) ptys=rexpnd("pty*");
   }
  }
 chpwd(orgpwd);

 if(ptys) for(fd=0;ptys[fd];++fd)
  {
  zcpy(ttyname,ptydir); zcat(ttyname,ptys[fd]);
  if((*ptyfd=open(ttyname,O_RDWR))>=0)
   {
   ptys[fd][0]='t';
   zcpy(ttyname,ttydir); zcat(ttyname,ptys[fd]);
   ptys[fd][0]='p';
   x=open(ttyname,O_RDWR);
   if(x>=0)
    {
    close(x);
    close(*ptyfd);
    zcpy(ttyname,ptydir); zcat(ttyname,ptys[fd]);
    *ptyfd=open(ttyname,O_RDWR);
    ptys[fd][0]='t';
    zcpy(ttyname,ttydir); zcat(ttyname,ptys[fd]);
    ptys[fd][0]='p';
    return ttyname;
    }
   else close(*ptyfd);
   }
  }
 return 0;
 }
d931 1
d933 11
a943 7
int dead=0;

void death()
 {
 wait(NULL);
 dead=1;
 }
d949 117
a1065 2
#ifdef SA_INTERRUPT
struct sigaction inew={death,0,SA_INTERRUPT};
d1067 1
a1067 2
#ifdef SV_INTERRUPT
struct sigvec inew={death,0,SV_INTERRUPT};
d1069 1
d1071 4
d1076 9
a1084 86
/* Build a new environment */

extern char **mainenv;

char **newenv(old,s)
char **old, *s;
 {
 char **new;
 int x,y,z;
 for(x=0;old[x];++x);
 new=(char **)malloc((x+2)*sizeof(char *));
 for(x=0,y=0;old[x];++x)
  {
  for(z=0;s[z]!='=';++z) if(s[z]!=old[x][z]) break;
  if(s[z]=='=')
   { if(s[z+1]) new[y++]=s; }
  else new[y++]=old[x];
  }
 if(x==y) new[y++]=s;
 new[y]=0;
 return new;
 }

MPX *mpxmk(ptyfd,cmd,args,func,object,die,dieobj)
int *ptyfd;
char *cmd;
char *args[];
void (*func)();
void *object;
void (*die)();
void *dieobj;
 {
 int fds[2];
 int comm[2];
 int pid;
 int x;
 MPX *m;
 char *name;
 if(!(name=getpty(ptyfd))) return 0;
 for(x=0;x!=NPROC;++x) 
  if(!asyncs[x].func) { m=asyncs+x; goto ok; }
 return 0;
 ok:
 ttflsh();
 ++nmpx;
 if(ackkbd== -1) mpxstart();
 m->func=func;
 m->object=object;
 m->die=die;
 m->dieobj=dieobj;
 pipe(fds);
 pipe(comm);
 m->ackfd=fds[1];
 if(!(m->kpid=fork()))
  {
  close(fds[1]);
  close(comm[0]);
  dead=0;
#ifdef SA_INTERRUPT
  sigaction(SIGCHLD,&inew,(struct sigaction *)0);
#else
#ifdef SV_INTERRUPT
  sigvec(SIGCHLD,&inew,(struct sigvec *)0);
#else
  signal(SIGCHLD,death);
#endif
#endif

  if(!(pid=fork()))
   {
   signrm();
   close(*ptyfd);
  
#ifdef TIOCNOTTY
   x=open("/dev/tty",O_RDWR);
   ioctl(x,TIOCNOTTY,0);
#endif
  
   setpgrp(0,0);
  
   for(x=0;x!=32;++x) close(x); /* Yes, this is quite a kludge... all in the
                                   name of portability */
  
   if((x=open(name,O_RDWR))!= -1)    /* Standard input */
    {
    char **env=newenv(mainenv,"TERM=");
d1086 2
a1087 2
    ioctl(x,I_PUSH,"ptem");
    ioctl(x,I_PUSH,"ldterm");
d1089 97
a1185 60
    dup(x); dup(x);		/* Standard output, standard error */
    /* (yes, stdin, stdout, and stderr must all be open for reading and
     * writing.  On some systems the shell assumes this */
  
    /* We could probably have a special TTY set-up for JOE, but for now
     * we'll just use the TTY setup for the TTY was was run on */
#ifdef TTYPOSIX
    tcsetattr(0,TCSADRAIN,&oldterm);
#else
#ifdef TTYSV
    ioctl(0,TCSETAW,&oldterm);
#else
    ioctl(0,TIOCSETN,&oarg);
    ioctl(0,TIOCSETC,&otarg);
    ioctl(0,TIOCSLTC,&oltarg);
#endif
#endif
  
    /* Execute the shell */
    execve(cmd,args,env);
    }

   _exit(0);
   }
  jwrite(comm[1],&pid,sizeof(int));

  loop:
  pack.who=m;
  pack.ch=0;
  if(dead) pack.size=0;
  else pack.size=read(*ptyfd,pack.data,1024);
  if(pack.size>0)
   {
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024+pack.size);
   jread(fds[0],&pack,1);
   goto loop;
   }
  else
   {
   pack.ch=MAXINT;
   pack.size=0;
   jwrite(mpxsfd,&pack,sizeof(struct packet)-1024);
   _exit(0);
   }
  }
 jread(comm[0],&m->pid,sizeof(int));
 close(comm[0]); close(comm[1]);
 close(fds[0]);
 return m;
 }

void mpxdied(m)
MPX *m;
 {
 if(!--nmpx) mpxend();
 while(wait(NULL)<0 && errno==EINTR);
 if(m->die) m->die(m->dieobj);
 m->func=0;
 edupd(1);
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
