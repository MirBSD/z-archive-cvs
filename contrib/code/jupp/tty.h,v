head	1.15;
access;
symbols
	joe-3_1jupp38:1.15
	joe-3_1jupp37:1.15
	joe-3_1jupp36:1.15
	joe-3_1jupp35:1.15
	joe-3_1jupp34:1.15
	joe-3_1jupp33:1.15
	joe-3_1jupp32:1.14
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.6
	joe-3_1jupp30:1.6
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.6
	joe-3_1jupp25:1.5
	joe-3_1jupp24:1.5
	joe-3_1jupp23:1.5
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.4
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.15
date	2018.01.07.20.32.47;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A5284063C3E386D;

1.14
date	2017.12.08.02.04.01;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A29F32A3D040BF8;

1.13
date	2017.12.06.23.02.05;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A2876FC4FFE7EF5;

1.12
date	2017.12.06.21.17.01;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A285E5918D423C7;

1.11
date	2017.12.04.22.15.39;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A25C91E16B3B365;

1.10
date	2017.12.02.17.00.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A22DC570063953B;

1.9
date	2017.12.02.02.07.33;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A220AD65C90E687;

1.8
date	2017.11.18.16.43.08;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A10633315FA19F2;

1.7
date	2017.11.18.16.02.05;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A1059874C70192A;

1.6
date	2013.10.31.20.05.43;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005272B7081B0E5655;

1.5
date	2012.12.30.18.18.07;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050E085670C2F3A0B;

1.4
date	2010.04.08.15.31.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBDF6C54CC9A0DB;

1.3
date	2008.05.13.13.08.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@/*
 *	TTY interface header file
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_TTY_H
#define _JOE_TTY_H 1

#ifdef EXTERN_CMD_C
__IDSTRING(rcsid_tty_h, "$MirOS: contrib/code/jupp/tty.h,v 1.14 2017/12/08 02:04:01 tg Exp $");
#endif

/* void ttopen(void);  Open the tty (attached to stdin) for use inside of JOE
 *
 * (0) Call sigjoe()
 *     There is also 'void ttopnn(void)' which does not do this step.
 *
 * (1) fflush(stdout)
 *
 * (2) Save the current state of the tty
 *
 * (3) Disable CR/LF/NL input translations,
 *     Disable all output processing,
 *     Disable echo and line editing, and
 *     Place tty in character at a time mode.
 *     (basically, disable all processing except for XON/XOFF if it's set)
 *
 * (4) Set this new tty state without loosing any typeahead (by using the
 *     proper ioctl).
 *
 * (5) Store the baud rate in the global variable 'baud'
 *
 * (6) Divide the baud rate into the constant DIVIDEND and store the result
 *     in the global variable 'upc'.  This should come out to the number
 *     of microseconds needed to send each character.  The constant 'DIVIDEND'
 *     should be chosen so that 'upc' reflects the real throughput of the
 *     tty, not the theoretical best throughput.
 *
 * (7) Create an output buffer of a size which depends on 'upc' and the
 *     constant 'TIMES'.  'TIMES' is the number of times per second JOE
 *     should check for typeahead.  Since we only check for typehead after
 *     the output buffer is flushed, 'upc' and the size of the output buffer
 *     determine how often this occurs.  So for example if 'upc'==1000 (~9600
 *     baud) and 'TIMES'==3, the output buffer size is set to 333 characters.
 *     Each time this buffer is completely flushed, 1/3 of a second will go by.
 */
void ttopen(void);
void ttopnn(void);
extern unsigned long upc;
extern unsigned baud;

#define TIMES 3
#define DIVIDEND 10000000

/* void ttclose(void);  Restore the tty back to its original mode.
 *
 * (1) ttyflsh()
 *
 * (2) Restore the original tty mode which aopen() had saved.  Do this without
 *     loosing any typeahead.
 *
 * (3) Call signrm().  There is also 'void ttyclsn(void)' which does not do
 *     the this step.
 */
void ttclose(void);
void ttclsn(void);

/* int ttgetc(void);  Flush the output and get the next character from the tty
 *
 * (1) ttflsh()
 *
 * (2) Read the next input character
 *     If the input closed, call 'ttsig' with 0 as its argument.
 *
 * (3) Clear 'have'
 */
int ttgetc(void);

/* void ttputc(char c);  Write a character to the output buffer.  If it becomes
 * full, call ttflsh()
 */
extern int obufp;
extern int obufsiz;
extern unsigned char *obuf;

#define ttputc(c) do {		\
	obuf[obufp++] = (c);	\
	if (obufp == obufsiz)	\
		ttflsh();	\
} while (/* CONSTCOND */ 0)

/* void ttputs(char *s);  Write a string to the output buffer.  Any time the
 * output buffer gets full, call ttflsh()
 */
void ttputs(unsigned char *s);

/* void ttsusp(void);  Suspend the process, or if the UNIX can't do it, call
 * ttshell(NULL)
 */
void ttsusp(void);

/* int ttflsh(void);  Flush the output buffer and check for typeahead.
 *
 * (1) write() any characters in the output buffer to the tty and then sleep
 *     for the amount of time it should take for the written characters to get
 *     to the tty.  This is so that any buffering between the editor and the
 *     tty is defeated.  If this is not done, the screen update will not be
 *     able to defer for typeahead.
 *
 *     The best way to do the sleep (possible only on systems with the
 *     setitimer call) is to set a timer for the necessary amount, write the
 *     characters to the tty, and then sleep until the timer expires.
 *
 *     If this can't be done, it's usually ok to 'write' and then to sleep for
 *     the necessary amount of time.  However, you will notice delays in the
 *     screen update if the 'write' actually takes any significant amount of
 *     time to execute (it usually takes none since all it usually does is
 *     write to an operating system output buffer).
 *
 * (2) The way we check for typeahead is to put the TTY in nonblocking mode
 *     and attempt to read a character.  If one could be read, the global
 *     variable 'have' is set to indicate that there is typeahead pending and
 *     the character is stored in a single character buffer until ttgetc
 *     is called.  If the global variable 'leave' is set, the check for
 *     typeahead is disabled.  This is so that once the program knows that it's
 *     about to exit, it doesn't eat the first character of your typeahead if
 *     ttflsh gets called.  'leave' should also be set before shell escapes and
 *     suspends.
 */
int ttflsh(void);

extern int have;
extern int leave;

/* void ttsig(int n);  Signal handler you provide.  This is called if the
 * editor gets a hangup signal, termination signal or if the input closes.
 * It is called with 'n' set to the number of the caught signal or 0 if the
 * input closed.
 */
RETSIGTYPE ttsig(int sig) __attribute__((__noreturn__));
void ttabrt(int, const char *);

/* void ttgtsz(int *x,int *y);  Get size of screen from ttsize/winsize
 * structure */
void ttgtsz(int *x, int *y);

/* You don't have to call these: ttopen/ttclose does it for you.  These
 * may be needed to make your own shell escape sequences.
 */

/* void sigjoe(void);  Set the signal handling for joe.  I.E., ignore all
 * signals the user can generate from the keyboard (SIGINT, SIGPIPE)
 * and trap the software terminate and hangup signals (SIGTERM, SIGHUP) so
 * that 'ttsig' gets called.
 */
void sigjoe(void);

/* void signrm(int inchild);  Set above signals back to their default values.
 */
void signrm(int);

/* MPX *mpxmk(int fd,int pid,
 *             void (*func)(),void *object,
 *             void (*die)(),void *dieobj,
 *            );
 *
 * Create an asynchronous input source handler for a process
 *   Child process id in 'pid'
 *   File descriptor to get input from in 'fd'
 *   Function to call with received characters in 'func'
 *   Function to call when process dies in 'die'
 *   The first arg passed to func and die is object and dieobj
 */
MPX *mpxmk(int *ptyfd, const unsigned char *cmd, unsigned char **args,
    void (*func)(B *, unsigned char *, int), void *object,
    void (*die)(B *), void *dieobj);


extern int noxon;
extern int Baud;

void tickoff(void);
void tickon(void);

#endif
@


1.14
log
@small fixes
@
text
@d12 1
a12 1
__IDSTRING(rcsid_tty_h, "$MirOS: contrib/code/jupp/tty.h,v 1.12 2017/12/06 21:17:01 tg Exp $");
d143 1
@


1.13
log
@lots of fixes related to prototyping
@
text
@d88 5
a92 1
#define ttputc(c) { obuf[obufp++] = (c); if(obufp == obufsiz) ttflsh(); }
d142 1
a142 1
RETSIGTYPE ttsig(int sig)__attribute__((__noreturn__));
d175 3
a177 1
MPX *mpxmk(int *ptyfd, const unsigned char *cmd, unsigned char **args, void (*func)(B*, unsigned char *, int), void *object, void (*die)(B*), void *dieobj);
@


1.12
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__IDSTRING(rcsid_tty_h, "$MirOS: contrib/code/jupp/tty.h,v 1.11 2017/12/04 22:15:39 tg Exp $");
d171 1
a171 1
MPX *mpxmk(int *ptyfd, const unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj);
a172 5
/* int subshell(int *ptyfd);
 * Execute a subshell.  Returns 'pid' of shell or zero if there was a
 * problem.  Returns file descriptor for the connected pty in 'ptyfd'.
 */
int subshell();
@


1.11
log
@clean up some unused/MS-DOS® stuff
@
text
@d12 1
a12 1
__IDSTRING(rcsid_tty_h, "$MirOS: contrib/code/jupp/tty.h,v 1.10 2017/12/02 17:00:50 tg Exp $");
d49 2
a50 2
void ttopen PARAMS((void));
void ttopnn PARAMS((void));
d67 2
a68 2
void ttclose PARAMS((void));
void ttclsn PARAMS((void));
d79 1
a79 1
int ttgetc PARAMS((void));
d93 1
a93 1
void ttputs PARAMS((unsigned char *s));
d98 1
a98 1
void ttsusp PARAMS((void));
d128 1
a128 1
int ttflsh PARAMS((void));
d138 1
a138 1
RETSIGTYPE ttsig PARAMS((int sig)) __attribute__((__noreturn__));
d142 1
a142 1
void ttgtsz PARAMS((int *x, int *y));
d153 1
a153 1
void sigjoe PARAMS((void));
d157 1
a157 1
void signrm PARAMS((int));
d171 1
a171 1
MPX *mpxmk PARAMS((int *ptyfd, const unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj));
d177 1
a177 1
int subshell PARAMS(());
d182 2
a183 2
void tickoff PARAMS((void));
void tickon PARAMS((void));
@


1.10
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_tty_h, "$MirOS: contrib/code/jupp/tty.h,v 1.9 2017/12/02 02:07:33 tg Exp $");
a132 6
#ifdef __MSDOS__
#define ifhave bioskey(1)
#else
#define ifhave have
#endif

d138 1
a138 5
RETSIGTYPE ttsig PARAMS((int sig))
#ifdef __GNUC__
    __attribute__((__noreturn__))
#endif
    ;
@


1.9
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.8
log
@make ttshell vfork-safe
@
text
@a0 1
/* $MirOS: contrib/code/jupp/tty.h,v 1.5 2012/12/30 18:18:07 tg Exp $ */
d11 3
a13 2
#include "config.h"
#include "types.h"
@


1.7
log
@prepare making ublock.c vfork-safe:
avoid overwriting a global variable in the child
@
text
@a94 5
/* void ttshell(char *s);  Run a shell command or if 's' is zero, run a
 * sub-shell
 */
void ttshell PARAMS((unsigned char *cmd));

@


1.6
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d170 1
a170 1
/* void signrm(void);  Set above signals back to their default values.
d172 1
a172 1
void signrm PARAMS((void));
@


1.5
log
@use SHELL and EXECSHELL in favour of /bin/sh (with stat and access checks)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.h,v 1.4 2010/04/08 15:31:04 tg Exp $ */
d151 1
a151 1
    __attribute__((noreturn))
@


1.4
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tty.h,v 1.3 2008/05/13 13:08:27 tg Exp $ */
d186 1
a186 1
MPX *mpxmk PARAMS((int *ptyfd, unsigned char *cmd, unsigned char **args, void (*func) (/* ??? */), void *object, void (*die) (/* ??? */), void *dieobj));
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d149 5
a153 1
RETSIGTYPE ttsig PARAMS((int sig));
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d148 1
a148 1
void ttsig PARAMS((int sig));
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 20
/* TTY interface header file
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#ifndef _Itty
#define _Itty 1
d12 1
a12 15
#include "queue.h"

#define NPROC 8			/* Number of processes we keep track of */

typedef struct mpx MPX;
struct mpx
 {
 int ackfd;			/* Packetizer response descriptor */
 int kpid;			/* Packetizer process id */
 int pid;			/* Client process id */
 void (*func)();		/* Function to call when read occures */
 void *object;			/* First arg to pass to function */
 void (*die)();			/* Function: call when client dies or closes */
 void *dieobj;
 };
d48 2
a49 2
void ttopen();
void ttopnn();
d66 2
a67 2
void ttclose();
void ttclsn();
d78 1
a78 1
int ttgetc();
d85 3
a87 2
extern char *obuf;
#define ttputc(c) (obuf[obufp++]=(c), obufp==obufsiz && ttflsh())
d92 1
a92 1
void ttputs();
d97 1
a97 1
void ttshell();
d102 1
a102 1
void ttsusp();
d132 1
a132 1
int ttflsh();
d148 1
a148 1
void ttsig();
d152 1
a152 1
void ttgtsz();
d163 1
a163 1
void sigjoe();
d167 1
a167 5
void signrm();

/* char *pwd();  Get current working directory into a static buffer.
 */
char *pwd();
d181 1
a181 1
MPX *mpxmk();
d187 1
a187 1
int subshell();
d192 2
a193 2
void tickoff();
void tickon();
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
