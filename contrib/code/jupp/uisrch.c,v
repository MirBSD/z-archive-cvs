head	1.15;
access;
symbols
	joe-3_1jupp38:1.15
	joe-3_1jupp37:1.15
	joe-3_1jupp36:1.15
	joe-3_1jupp35:1.15
	joe-3_1jupp34:1.15
	joe-3_1jupp33:1.15
	joe-3_1jupp32:1.15
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.7
	joe-3_1jupp30:1.7
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.6
	joe-3_1jupp25:1.6
	joe-3_1jupp24:1.6
	joe-3_1jupp23:1.6
	joe-3_1jupp22:1.6
	joe-3_1jupp21:1.6
	joe-3_1jupp20:1.6
	joe-3_1jupp19:1.6
	joe-3_1jupp18:1.6
	joe-3_1jupp17:1.6
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.6
	joe-3_1jupp15:1.6
	joe-3_1jupp14:1.6
	joe-3_1jupp12:1.5
	joe-3_1jupp11:1.5
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.5
	joe-3_1jupp9:1.4
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.15
date	2017.12.08.02.28.08;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A29F8C708B176AB;

1.14
date	2017.12.08.02.17.24;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A29F64A06DEB239;

1.13
date	2017.12.08.02.00.42;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A29F2506E789D2B;

1.12
date	2017.12.06.23.17.36;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A287AA407E73F9C;

1.11
date	2017.12.06.23.02.07;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A2876FC4FFE7EF5;

1.10
date	2017.12.02.18.50.03;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A22F5E2328F5222;

1.9
date	2017.12.02.04.32.42;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A222CF2122034D9;

1.8
date	2017.12.02.02.07.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A220AD65C90E687;

1.7
date	2017.01.10.19.16.28;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005875332028CA2A36;

1.6
date	2010.04.08.15.31.05;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004BBDF6C54CC9A0DB;

1.5
date	2008.07.28.00.12.07;	author tg;	state Exp;
branches;
next	1.4;
commitid	100488D0E7907247606;

1.4
date	2008.05.13.13.08.28;	author tg;	state Exp;
branches;
next	1.3;
commitid	100482992BC01EE89A1;

1.3
date	2007.07.22.11.51.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	10046A344E96AC991F1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@label indent; small tweaks while here
@
text
@/*
 *	Incremental search
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/uisrch.c,v 1.14 2017/12/08 02:17:24 tg Exp $");

#include <stdlib.h>

#include "b.h"
#include "bw.h"
#include "main.h"
#include "queue.h"
#include "qw.h"
#include "tty.h"
#include "uisrch.h"
#include "usearch.h"
#include "utils.h"
#include "charmap.h"
#include "vs.h"

extern int smode;
extern int dobeep;
extern int icase;
struct isrch *lastisrch = NULL;	/* Previous search */

unsigned char *lastpat = NULL;	/* Previous pattern */

extern SRCH *globalsrch;	/* Existing SRCH structure */

IREC fri = { {&fri, &fri}, 0, 0, 0, 0 };	/* Free-list of irecs */

static IREC *alirec(void)
{				/* Allocate an IREC */
	return alitem(&fri, sizeof(IREC));
}

static void frirec(IREC *i)
{				/* Free an IREC */
	enquef(IREC, link, &fri, i);
}

static void rmisrch(struct isrch *isrch)
{				/* Eliminate a struct isrch */
	if (isrch) {
		vsrm(isrch->pattern);
		vsrm(isrch->prompt);
		frchn(&fri, &isrch->irecs);
		free(isrch);
	}
}

static int iabrt(BW *bw, struct isrch *isrch)
{				/* User hit ^C */
	rmisrch(isrch);
	return -1;
}

static void iappend(BW *bw, struct isrch *isrch, unsigned char *s, int len)
{				/* Append text and search */
	/* Append char and search */
	IREC *i = alirec();
	SRCH *srch;

	i->what = len;
	i->disp = bw->cursor->byte;
	isrch->pattern = vsncpy(sv(isrch->pattern), s, len);
	if (!qempty(IREC, link, &isrch->irecs)) {
		pgoto(bw->cursor, isrch->irecs.link.prev->start);
	}
	i->start = bw->cursor->byte;

	if (!globalsrch)
		srch = mksrch(NULL,NULL,icase,isrch->dir,-1,0,0);
	else {
		srch = globalsrch;
		globalsrch = 0;
	}

	srch->addr = bw->cursor->byte;

	if (!srch->wrap_p || srch->wrap_p->b!=bw->b) {
		prm(srch->wrap_p);
		srch->wrap_p = pdup(bw->cursor);
		srch->wrap_p->owner = &srch->wrap_p;
		srch->wrap_flag = 0;
	}

	i->wrap_flag = srch->wrap_flag;

	vsrm(srch->pattern);
	srch->pattern = vsncpy(NULL, 0, isrch->pattern, sLen(isrch->pattern));
	srch->backwards = isrch->dir;

	if (dopfnext(bw, srch, NULL)) {
		if(dobeep)
			ttputc(7);
	}
	enqueb(IREC, link, &isrch->irecs, i);
}

/* Main user interface */
/* When called with c==-1, it just creates the prompt */
static int itype(BW *bw, int c, struct isrch *isrch, int *notify)
{
	IREC *i;
	int omid;
	int tc;

	if (isrch->quote) {
		goto in;
	}
	if (c == 8 || c == 127) {	/* Backup */
		if ((i = isrch->irecs.link.prev) != &isrch->irecs) {
			pgoto(bw->cursor, i->disp);
			if (globalsrch)
				globalsrch->wrap_flag = i->wrap_flag;
			omid = mid;
			mid = 1;
			dofollows();
			mid = omid;
			isrch->pattern = vstrunc(isrch->pattern, sLEN(isrch->pattern) - i->what);
			frirec(deque_f(IREC, link, i));
		} else {
			if(dobeep)
				ttputc(7);
		}
	} else if (c == 'Q' - '@@' || c == '`') {
		isrch->quote = 1;
	} else if (c == 'S' - '@@' || c == '\\' - '@@' || c == 'L' - '@@' || c == 'R' - '@@') {
		/* Repeat */
		if (c == 'R' - '@@') {
			isrch->dir = 1;
		} else {
			isrch->dir = 0;
		}
		if (qempty(IREC, link, &isrch->irecs)) {
			if (lastpat && lastpat[0]) {
				iappend(bw, isrch, sv(lastpat));
			}
		} else {
			SRCH *srch;
			i = alirec();
			i->disp = i->start = bw->cursor->byte;
			i->what = 0;

			if (!globalsrch)
				srch = mksrch(NULL,NULL,icase,isrch->dir,-1,0,0);
			else {
				srch = globalsrch;
				globalsrch = 0;
			}

			srch->addr = bw->cursor->byte;

			if (!srch->wrap_p || srch->wrap_p->b!=bw->b) {
				prm(srch->wrap_p);
				srch->wrap_p = pdup(bw->cursor);
				srch->wrap_p->owner = &srch->wrap_p;
				srch->wrap_flag = 0;
			}

			i->wrap_flag = srch->wrap_flag;

			vsrm(srch->pattern);
			srch->pattern = vsncpy(NULL, 0, isrch->pattern, sLen(isrch->pattern));
			srch->backwards = isrch->dir;

			if (dopfnext(bw, srch, NULL)) {
				if(dobeep)
					ttputc(7);
				frirec(i);
			} else {
				enqueb(IREC, link, &isrch->irecs, i);
			}
		}
	} else if (c >= 0 && c < 32) {
		/* Done when a control character is received */
		nungetc(c);
		if (notify) {
			*notify = 1;
		}
		smode = 2;
		if (lastisrch) {
			lastpat = vstrunc(lastpat, 0);
			lastpat = vsncpy(lastpat, 0, lastisrch->pattern, sLen(lastisrch->pattern));
			rmisrch(lastisrch);
		}
		lastisrch = isrch;
		return 0;
	} else if (c != -1) {
		unsigned char buf[16];
		int buf_len;
		/* Search */
 in:
		/* Convert to/from utf-8 */
		if (locale_map->type && !bw->b->o.charmap->type) {
			utf8_encode(buf,c);
			c = from_utf8(bw->b->o.charmap,buf);
		} else if(!locale_map->type && bw->b->o.charmap->type) {
			to_utf8(locale_map,buf,c);
			c = utf8_decode_string(buf);
		}

		if (bw->b->o.charmap->type) {
			buf_len = utf8_encode(buf,c);
		} else {
			buf[0] = c;
			buf_len = 1;
		}

		isrch->quote = 0;
		iappend(bw, isrch, buf, buf_len);
	}
	omid = mid;
	mid = 1;
	bw->cursor->xcol = piscol(bw->cursor);
	dofollows();
	mid = omid;

	isrch->prompt = vstrunc(isrch->prompt, isrch->ofst);

	if (locale_map->type && !bw->b->o.charmap->type) {
		/* Translate bytes to utf-8 */
		unsigned char buf[16];
		int x;

		for (x = 0; x != sLEN(isrch->pattern); ++x) {
			tc = to_uni(bw->b->o.charmap, isrch->pattern[x]);
			utf8_encode(buf, tc);
			isrch->prompt = vsncpy(sv(isrch->prompt), sz(buf));
		}
	} else if (!locale_map->type && bw->b->o.charmap->type) {
		/* Translate utf-8 to bytes */
		unsigned char *p = isrch->pattern;
		int len = sLEN(isrch->pattern);

		while (len) {
			if ((tc = utf8_decode_fwrd(&p, &len)) >= 0) {
				tc = from_uni(locale_map, tc);
				isrch->prompt = vsadd(isrch->prompt, tc);
			}
		}
	} else {
		/* FIXME: translate when charmaps do not match */
		isrch->prompt = vsncpy(sv(isrch->prompt),sv(isrch->pattern));
	}

	if (mkqwnsr(bw->parent, sv(isrch->prompt), itype, iabrt, isrch, notify)) {
		return 0;
	} else {
		rmisrch(isrch);
		return -1;
	}
}

/* Create a struct isrch */
static int
doisrch(BW *bw, int dir)
{
	struct isrch *isrch = malloc(sizeof(struct isrch));

	izque(IREC, link, &isrch->irecs);
	isrch->pattern = vsncpy(NULL, 0, NULL, 0);
	isrch->dir = dir;
	isrch->quote = 0;
	isrch->prompt = vsncpy(NULL, 0, sc("I-find: "));
	isrch->ofst = sLen(isrch->prompt);
	return itype(bw, -1, isrch, NULL);
}

int uisrch(BW *bw)
{
	if (smode && lastisrch) {
		struct isrch *isrch = lastisrch;

		lastisrch = 0;
		return itype(bw, 'S' - '@@', isrch, NULL);
	} else {
		if (globalsrch) {
			rmsrch(globalsrch);
			globalsrch = 0;
		}
		if (lastisrch) {
			lastpat = vstrunc(lastpat, 0);
			lastpat = vsncpy(lastpat, 0, lastisrch->pattern, sLen(lastisrch->pattern));
			rmisrch(lastisrch);
			lastisrch = 0;
		}
		return doisrch(bw, 0);
	}
}

int ursrch(BW *bw)
{
	if (smode && lastisrch) {
		struct isrch *isrch = lastisrch;

		lastisrch = 0;
		return itype(bw, 'R' - '@@', isrch, NULL);
	} else {
		if (globalsrch) {
			rmsrch(globalsrch);
			globalsrch = 0;
		}
		if (lastisrch) {
			lastpat = vstrunc(lastpat, 0);
			lastpat = vsncpy(lastpat, 0, lastisrch->pattern, sLen(lastisrch->pattern));
			rmisrch(lastisrch);
			lastisrch = 0;
		}
		return doisrch(bw, 1);
	}
}
@


1.14
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uisrch.c,v 1.12 2017/12/06 23:17:36 tg Exp $");
d200 1
a200 3

		in:

@


1.13
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d113 1
d234 5
a238 4
		for (x=0; x!=sLEN(isrch->pattern); ++x) {
			int c_ = to_uni(bw->b->o.charmap, isrch->pattern[x]);
			utf8_encode(buf,c_);
			isrch->prompt = vsncpy(sv(isrch->prompt),sz(buf));
d244 1
d246 3
a248 4
			int c_ = utf8_decode_fwrd(&p, &len);
			if (c_ >= 0) {
				c_ = from_uni(locale_map, c_);
				isrch->prompt = vsadd(isrch->prompt, c_);
@


1.12
log
@whitespace at EOL annoys me
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uisrch.c,v 1.11 2017/12/06 23:02:07 tg Exp $");
d54 1
a54 1
		joe_free(isrch);
d262 5
a266 3
static int doisrch(BW *bw, int dir)
{				/* Create a struct isrch */
	struct isrch *isrch = (struct isrch *) joe_malloc(sizeof(struct isrch));
@


1.11
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uisrch.c,v 1.10 2017/12/02 18:50:03 tg Exp $");
d216 1
a216 1
		}		
@


1.10
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uisrch.c,v 1.8 2017/12/02 02:07:35 tg Exp $");
d21 1
@


1.9
log
@some fallout of the includes changes, some more reduction
@
text
@d35 1
a35 1
IREC fri = { {&fri, &fri} };	/* Free-list of irecs */
@


1.8
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a23 1
#include "utf8.h"
@


1.7
log
@these now all need <stdlib.h>
@
text
@a0 1
/* $MirOS: contrib/code/jupp/uisrch.c,v 1.5 2008/07/28 00:12:07 tg Exp $ */
d11 2
@


1.6
log
@Add --disable-getpwnam and clean up warnings
@
text
@d12 2
@


1.5
log
@rename symbol to avoid clash:

/usr/bin/ld: warning multiple definitions of symbol _beep
cmd.o definition of _beep in section (__DATA,__data)
/private/var/tglaser/iSDK/lib/libncurses.dylib(single module) definition of _beep

found during native(!) compilation on iPhone 3G (Darwin 9.3.1
iPhoneOS 2.0 iPhone1,2 arm N82AP), with gcc from saurik iphone-gcc
and headers and libraries copied from the 2.0 SDK. (It works fine.)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uisrch.c,v 1.4 2008/05/13 13:08:28 tg Exp $ */
d231 2
a232 2
			int c = to_uni(bw->b->o.charmap, isrch->pattern[x]);
			utf8_encode(buf,c);
d240 4
a243 4
			int c = utf8_decode_fwrd(&p, &len);
			if (c>=0) {
				c = from_uni(locale_map, c);
				isrch->prompt = vsadd(isrch->prompt, c);
@


1.4
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d25 1
a25 1
extern int beep;
d98 1
a98 1
		if(beep)
d126 1
a126 1
			if(beep)
d171 1
a171 1
				if(beep)
@


1.3
log
@prevent AIX ld from complaining about duplicate symbols (commons?)
@
text
@d1 1
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d30 1
a30 1
SRCH *globalsrch;		/* Existing SRCH structure */
@


1.1
log
@Initial revision
@
text
@a237 1
		int c;
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 1
/* Incremental search */
d11 1
d13 2
d16 5
a21 3
#include "usearch.h"
#include "main.h"
#include "uisrch.h"
d24 291
a314 180
struct isrch *lastisrch=0;		/* Previous search */

char *lastpat=0;			/* Previous pattern */

IREC fri={{&fri,&fri}};			/* Free-list of irecs */

IREC *alirec()				/* Allocate an IREC */
 {
 return alitem(&fri,sizeof(IREC));
 }

void frirec(i)				/* Free an IREC */
IREC *i;
 {
 enquef(IREC,link,&fri,i);
 }

void rmisrch(isrch)			/* Eliminate a struct isrch */
struct isrch *isrch;
 {
 if(isrch)
  {
  vsrm(isrch->pattern);
  frchn(&fri,&isrch->irecs);
  free(isrch);
  }
 }

int iabrt(bw,isrch)			/* User hit ^C */
BW *bw;
struct isrch *isrch;
 {
 rmisrch(isrch);
 return -1;
 }

void iappend(bw,isrch,s,len)		/* Append text and search */
BW *bw;
struct isrch *isrch;
char *s;
 { /* Append char and search */
 IREC *i=alirec();
 i->what=len;
 i->disp=bw->cursor->byte;
 isrch->pattern=vsncpy(sv(isrch->pattern),s,len);
 if(!qempty(IREC,link,&isrch->irecs)) pgoto(bw->cursor,isrch->irecs.link.prev->start);
 i->start=bw->cursor->byte;
 if(dopfnext(bw,mksrch(vsncpy(NULL,0,isrch->pattern+isrch->ofst,sLen(isrch->pattern)-isrch->ofst),NULL,0,isrch->dir,-1,0,0),NULL))
  ttputc(7);
 enqueb(IREC,link,&isrch->irecs,i);
 }

int itype(bw,c,isrch,notify)		/* Main user interface */
BW *bw;
struct isrch *isrch;
int *notify;
 {
 IREC *i;
 int omid;
 if(isrch->quote) goto in;
 if(c==8 || c==127)
  { /* Backup */
  if((i=isrch->irecs.link.prev)!=&isrch->irecs)
   {
   pgoto(bw->cursor,i->disp);
   omid=mid; mid=1; dofollows(); mid=omid;
   isrch->pattern=vstrunc(isrch->pattern,sLEN(isrch->pattern)-i->what);
   frirec(deque(IREC,link,i));
   }
  else ttputc(7);
  }
 else if(c=='Q'-'@@' || c=='`') isrch->quote=1;
 else if(c=='S'-'@@' || c=='\\'-'@@' || c=='L'-'@@' || c=='R'-'@@')
  { /* Repeat */
  if(c=='R'-'@@') isrch->dir=1;
  else isrch->dir=0;
  if(qempty(IREC,link,&isrch->irecs))
   {
   if(lastpat && lastpat[0]) iappend(bw,isrch,sv(lastpat));
   }
  else
   {
   i=alirec();
   i->disp=i->start=bw->cursor->byte;
   i->what=0;
   if(dopfnext(bw,mksrch(vsncpy(NULL,0,isrch->pattern+isrch->ofst,sLen(isrch->pattern)-isrch->ofst),NULL,0,isrch->dir,-1,0,0),NULL))
    ttputc(7), frirec(i);
   else
    enqueb(IREC,link,&isrch->irecs,i);
   }
  }
 else if((c<32 || c>=256) && c!=MAXINT)
  { /* Done */
  nungetc(c);
  if(notify) *notify=1;
  smode=2;
  if(lastisrch)
   {
   lastpat=vstrunc(lastpat,0);
   lastpat=vsncpy(lastpat,0,lastisrch->pattern+lastisrch->ofst,sLen(lastisrch->pattern)-lastisrch->ofst);
   rmisrch(lastisrch);
   }
  lastisrch=isrch;
  return 0;
  }
 else if(c!=MAXINT)
  { /* Search */
  unsigned char k;
  in: k=c;
  isrch->quote=0;
  iappend(bw,isrch,&k,1);
  }
 omid=mid;
 mid=1;
 bw->cursor->xcol=piscol(bw->cursor);
 dofollows();
 mid=omid;
 if(mkqwnsr(bw,sv(isrch->pattern),itype,iabrt,isrch,notify)) return 0;
 else
  {
  rmisrch(isrch);
  return -1;
  }
 }

int doisrch(bw,dir)			/* Create a struct isrch */
BW *bw;
 {
 struct isrch *isrch=(struct isrch *)malloc(sizeof(struct isrch));
 izque(IREC,link,&isrch->irecs);
 isrch->pattern=vsncpy(NULL,0,sc("I-find: "));
 isrch->ofst=sLen(isrch->pattern);
 isrch->dir=dir;
 isrch->quote=0;
 return itype(bw,MAXINT,isrch,NULL);
 }

int uisrch(bw)
BW *bw;
 {
 if(smode && lastisrch)
  {
  struct isrch *isrch=lastisrch;
  lastisrch=0;
  return itype(bw,'S'-'@@',isrch,NULL);
  }
 else
  {
  if(lastisrch)
   {
   lastpat=vstrunc(lastpat,0);
   lastpat=vsncpy(lastpat,0,lastisrch->pattern+lastisrch->ofst,sLen(lastisrch->pattern)-lastisrch->ofst);
   rmisrch(lastisrch);
   lastisrch=0;
   }
  return doisrch(bw,0);
  }
 }

int ursrch(bw)
BW *bw;
 {
 if(smode && lastisrch)
  {
  struct isrch *isrch=lastisrch;
  lastisrch=0;
  return itype(bw,'R'-'@@',isrch,NULL);
  }
 else
  {
  if(lastisrch)
   {
   lastpat=vstrunc(lastpat,0);
   lastpat=vsncpy(lastpat,0,lastisrch->pattern+lastisrch->ofst,sLen(lastisrch->pattern)-lastisrch->ofst);
   rmisrch(lastisrch);
   lastisrch=0;
   }
  return doisrch(bw,1);
  }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
