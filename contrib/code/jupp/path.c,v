head	1.23;
access;
symbols
	joe-3_1jupp38:1.23
	joe-3_1jupp37:1.23
	joe-3_1jupp36:1.23
	joe-3_1jupp35:1.23
	joe-3_1jupp34:1.23
	joe-3_1jupp33:1.23
	joe-3_1jupp32:1.19
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.12
	joe-3_1jupp30:1.12
	joe-3_1jupp29:1.12
	joe-3_1jupp28:1.10
	joe-3_1jupp27:1.10
	joe-3_1jupp26:1.10
	joe-3_1jupp25:1.10
	joe-3_1jupp24:1.8
	joe-3_1jupp23:1.8
	joe-3_1jupp22:1.7
	joe-3_1jupp21:1.7
	joe-3_1jupp20:1.7
	joe-3_1jupp19:1.7
	joe-3_1jupp18:1.5
	joe-3_1jupp17:1.5
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.5
	joe-3_1jupp15:1.5
	joe-3_1jupp14:1.5
	joe-3_1jupp12:1.4
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.23
date	2018.01.07.20.32.46;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A5284063C3E386D;

1.22
date	2018.01.06.00.28.32;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A50184621FA8455;

1.21
date	2017.12.20.23.43.54;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A3AF5D160EAA4F2;

1.20
date	2017.12.20.23.19.15;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A3AF00342723BA6;

1.19
date	2017.12.16.22.10.54;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A359A0405479D56;

1.18
date	2017.12.08.02.28.05;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A29F8C708B176AB;

1.17
date	2017.12.08.02.17.21;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A29F64A06DEB239;

1.16
date	2017.12.06.23.17.34;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A287AA407E73F9C;

1.15
date	2017.12.06.21.16.58;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A285E5918D423C7;

1.14
date	2017.12.04.22.15.38;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A25C91E16B3B365;

1.13
date	2017.12.02.02.07.29;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A220AD65C90E687;

1.12
date	2016.10.29.23.44.45;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005815347F236258ED;

1.11
date	2016.10.08.16.25.59;	author tg;	state Exp;
branches;
next	1.10;
commitid	10057F91DF7456BBA11;

1.10
date	2013.08.19.22.48.32;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005212A0D860585CD4;

1.9
date	2013.08.19.22.03.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005212963A2ECD563E;

1.8
date	2012.12.19.21.14.53;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050D22E4E74F2CC78;

1.7
date	2012.06.07.22.18.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004FD128C7446C7467;

1.6
date	2012.06.07.19.01.29;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FD0FA4D602B1239;

1.5
date	2010.04.08.15.31.02;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004BBDF6C54CC9A0DB;

1.4
date	2009.10.06.09.07.30;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004ACB08E905F8F83E;

1.3
date	2008.05.13.13.08.23;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.22;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@/*
 *	Directory and path functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.21 2017/12/20 23:43:54 tg Exp $");

#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#ifdef HAVE_PATHS_H
#  include <paths.h>	/* for _PATH_TMP */
#endif
#include <stdlib.h>

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "path.h"
#include "vs.h"
#include "va.h"

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_DIRENT_H
#  include <dirent.h>
#  define NAMLEN(dirent) strlen((dirent)->d_name)
#else
#  ifdef HAVE_SYS_DIRENT_H
#    include <sys/dirent.h>
#    define NAMLEN(dirent) strlen((dirent)->d_name)
#  else
#    define direct dirent
#    define NAMLEN(dirent) (dirent)->d_namlen
#    ifdef HAVE_SYS_NDIR_H
#      include <sys/ndir.h>
#    else
#      ifdef HAVE_SYS_DIR_H
#        include <sys/dir.h>
#      else
#        ifdef HAVE_NDIR_H
#          include <ndir.h>
#        else
#          ifndef __MSDOS__
#            include "dir.c"
#          endif
#        endif
#      endif
#    endif
#  endif
#endif

#if HAVE_DRIVE_LETTERS
#define do_if_drive_letter(path, command) do {		\
	if ((path)[1] == ':') {				\
		drvltrhlprv = (path)[0] | 0x20;		\
		if (drvltrhlprv >= 'a' &&		\
		    drvltrhlprv <= 'z')			\
			command;			\
	}						\
} while (/* CONSTCOND */ 0)
#define drvltrhlpr unsigned char drvltrhlprv
#else
#define do_if_drive_letter(path, command) do { } while (/* CONSTCOND */ 0)
#define drvltrhlpr /* nothing */
#endif
#define skip_drive_letter(path)	do_if_drive_letter((path), (path) += 2)

#ifndef _PATH_TMP
#define _PATH_TMP	"/tmp/"
#endif

#if !defined(PATH_MAX) && !defined(HAVE_GET_CURRENT_DIR_NAME)
#warning What should we include to have PATH_MAX defined?
#define PATH_MAX	4096
#endif

/********************************************************************/
#if HAVE_BACKSLASH_PATHS
unsigned char *joesep(unsigned char *path)
{
	int x;

	for (x = 0; path[x]; ++x)
		if (path[x] == '\\')
			path[x] = '/';
	return path;
}
#endif
/********************************************************************/
unsigned char *namprt(unsigned char *path)
{
	unsigned char *z;
	drvltrhlpr;

	skip_drive_letter(path);
	z = path + slen(path);
	while ((z != path) && (z[-1] != '/'))
		--z;
	return vsncpy(NULL, 0, sz(z));
}
/********************************************************************/
unsigned char *namepart(unsigned char *tmp, unsigned char *path)
{
	unsigned char *z;
	drvltrhlpr;

	skip_drive_letter(path);
	z = path + strlen((char *)path);
	while ((z != path) && (z[-1] != '/'))
		--z;
	strlcpy((char *)tmp, (char *)z, 1024);
	return (tmp);
}
/********************************************************************/
unsigned char *dirprt_ptr(unsigned char *path)
{
	unsigned char *b = path;
	unsigned char *z = path + slen(path);
	drvltrhlpr;

	skip_drive_letter(b);
	while ((z != b) && (z[-1] != '/'))
		--z;
	return (z);
}
unsigned char *dirprt(unsigned char *path)
{
	return vsncpy(NULL, 0, path, dirprt_ptr(path) - path);
}
/********************************************************************/
unsigned char *begprt(unsigned char *path)
{
	unsigned char *z = path + slen(path);
	int drv = 0;
	drvltrhlpr;

	do_if_drive_letter(path, drv = 2);
	while ((z != path + drv) && (z[-1] == '/'))
		--z;
	if (z == path + drv)
		return vsncpy(NULL, 0, sz(path));
	else {
		while ((z != path + drv) && (z[-1] != '/'))
			--z;
		return vsncpy(NULL, 0, path, z - path);
	}
}
/********************************************************************/
unsigned char *endprt(unsigned char *path)
{
	unsigned char *z = path + slen(path);
	int drv = 0;
	drvltrhlpr;

	do_if_drive_letter(path, drv = 2);
	while ((z != path + drv) && (z[-1] == '/'))
		--z;
	if (z == path + drv)
		return vsncpy(NULL, 0, sc(""));
	else {
		while (z != path + drv && z[-1] != '/')
			--z;
		return vsncpy(NULL, 0, sz(z));
	}
}
/********************************************************************/
int mkpath(unsigned char *path)
{
	unsigned char *s;

	if (path[0] == '/') {
		if (chddir("/"))
			return 1;
		s = path;
		goto in;
	}

	while (path[0]) {
		int c;

		for (s = path; (*s) && (*s != '/'); s++) ;
		c = *s;
		*s = 0;
		if (chddir((char *)path)) {
			if (mkdir((char *)path, 0777))
				return 1;
			if (chddir((char *)path))
				return 1;
		}
		*s = c;
 in:
		while (*s == '/')
			++s;
		path = s;
	}
	return 0;
}
/********************************************************************/
/* Create a temporary file */
/********************************************************************/
unsigned char *mktmp(unsigned char *where, int *fdp)
{
#ifndef HAVE_MKSTEMP
	static unsigned seq = 0;
#endif
	unsigned char *name;
	int fd;
	unsigned namesize;

	if (!where)
		where = (unsigned char *)getenv("TMPDIR");
	if (!where)
		where = (unsigned char *)getenv("TEMP");
	if (!where)
		where = US _PATH_TMP;

	namesize = strlen((char *)where) + 20;
	name = vsmk(namesize);	/* [G.Ghibo'] we need to use vsmk() and not malloc() as
				   area returned by mktmp() is destroyed later with
				   vsrm(); */
#ifdef HAVE_MKSTEMP
	joe_snprintf_1((char *)name, namesize, "%s/joe.tmp.XXXXXXXXXX", where);
	if ((fd = mkstemp((char *)name)) == -1) {
		vsrm(name);
		/*
		 * FIXME: vflsh() and vflshf()
		 * expect mktmp() always succeed!
		 */
		return (NULL);
	}
	/*
	 * Linux glibc 2.0 mkstemp() creates it with 0666 mode, ergo we
	 * change it to 0600, so nobody else sees content of temporary file
	 */
	fchmod(fd, 0600);
#else
#warning "Waah, this is insane! Consider getting mkstemp!"
 loop:
	seq = (seq + 1) % 10000;
	joe_snprintf_3(name, namesize, "%s/joe.tmp.%04u%05u", where, seq,
	    (unsigned)(time(NULL) % 100000));
	if ((fd = open(name, O_RDONLY)) != -1) {
		close(fd);
		goto loop;	/* FIXME: possible endless loop --> DoS attack */
	}
	if ((fd = open(name, O_RDWR | O_CREAT | O_EXCL, 0600)) == -1) {
		vsrm(name);
		/* FIXME: see above */
		return (NULL);
	}
#endif
	if (fdp)
		*fdp = fd;
	else
		close(fd);
	return (name);
}
/********************************************************************/
int rmatch(const unsigned char *a, const unsigned char *b)
{
	int flag, inv, c;

	for (;;)
		switch (*a) {
		case '*':
			++a;
			do {
				if (rmatch(a, b))
					return 1;
			} while (*b++);
			return 0;
		case '[':
			++a;
			flag = 0;
			if (*a == '^') {
				++a;
				inv = 1;
			} else
				inv = 0;
			if (*a == ']')
				if (*b == *a++)
					flag = 1;
			while (*a && (c = *a++) != ']')
				if ((c == '-') && (a[-2] != '[') && (*a)) {
					if ((*b >= a[-2]) && (*b <= *a))
						flag = 1;
				} else if (*b == c)
					flag = 1;
			if ((!flag && !inv) || (flag && inv) || (!*b))
				return 0;
			++b;
			break;
		case '?':
			++a;
			if (!*b)
				return 0;
			++b;
			break;
		case 0:
			if (!*b)
				return 1;
			else
				return 0;
		default:
			if (*a++ != *b++)
				return 0;
		}
}
/********************************************************************/
int isreg(unsigned char *s)
{
	int x;

	for (x = 0; s[x]; ++x)
		if ((s[x] == '*') || (s[x] == '?') || (s[x] == '['))
			return 1;
	return 0;
}
/********************************************************************/
unsigned char **rexpnd(const unsigned char *word)
{
	void *dir;
	unsigned char **lst = NULL;

	struct dirent *de;
	dir = opendir(".");
	if (dir) {
		while ((de = readdir(dir)) != NULL)
			if (strcmp(".", de->d_name))
				if (rmatch(word, (unsigned char *)de->d_name))
					lst = vaadd(lst, vsncpy(NULL, 0, sz((unsigned char *)de->d_name)));
		closedir(dir);
	}
	return lst;
}
/********************************************************************/
int chJpwd(const unsigned char *path)
{
	unsigned char *fullpath;
	int rv;

	if (!has_JOERC)
		return (-1);
	fullpath = vsncpy(NULL, 0, sz(get_JOERC));
	fullpath = vsncpy(sv(fullpath), sz(path));
	rv = chpwd(fullpath);
	vsrm(fullpath);
	return (rv);
}

int chpwd(const unsigned char *path)
{
	if ((!path) || (!path[0]))
		return 0;
	return chdir((char *)path);
}

/* The pwd function */
unsigned char *pwd(void)
{
#if defined(PATH_MAX) || !defined(HAVE_GET_CURRENT_DIR_NAME)
	static unsigned char buf[PATH_MAX];
	unsigned char	*ret;

#ifdef HAVE_GETCWD
	ret = (unsigned char *)getcwd((char *)buf, PATH_MAX - 1);
#else
	ret = (unsigned char *)getwd((char *)buf);
#endif
	buf[PATH_MAX - 1] = '\0';

	return ret;
#else
	/* Hurd */
	static char *wd = NULL;

	free(wd);
	wd = get_current_dir_name();
	return ((void *)wd);
#endif
}

#if JUPP_WIN32RELOC
unsigned char has_JOERC = 0;
unsigned char *get_JOERC = NULL;

extern char *cygwin32_argv0(void);

void init_JOERC(void)
{
	struct stat sb;
	char *sep;

	if ((get_JOERC = (unsigned char *)cygwin32_argv0()) == NULL)
		return;
	joesep(get_JOERC);
	if ((sep = strrchr((char *)get_JOERC, '/')) == NULL)
		return;
	if (stat(get_JOERC, &sb))
		return;
	sep[1] = '\0';
	has_JOERC = 1;
}
#endif
@


1.22
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@a19 1
#include <limits.h>
@


1.21
log
@plug more memory leaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.20 2017/12/20 23:19:15 tg Exp $");
d338 1
a338 1
unsigned char **rexpnd(unsigned char *word)
@


1.20
log
@fix nil pointer deref in error path
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.19 2017/12/16 22:10:54 tg Exp $");
d241 13
a253 6
	if ((fd = mkstemp((char *)name)) == -1)
		return (NULL);	/* FIXME: vflsh() and vflshf() */
				/* expect mktmp() always succeed!!! */
	fchmod(fd, 0600);	/* Linux glibc 2.0 mkstemp() creates it with */
				/* 0666 mode --> change it to 0600, so nobody */
				/* else sees content of temporary file */
d264 5
a268 2
	if ((fd = open(name, O_RDWR | O_CREAT | O_EXCL, 0600)) == -1)
		return (NULL);	/* FIXME: see above */
@


1.19
log
@more casing tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.17 2017/12/08 02:17:21 tg Exp $");
d267 1
a267 1
int rmatch(unsigned char *a, unsigned char *b)
@


1.18
log
@label indent; small tweaks while here
@
text
@d72 5
a76 4
	if ((path)[1] == ':' && (			\
	    ((path)[0] >= 'a' && (path)[0] <= 'z') ||	\
	    ((path)[0] >= 'A' && (path)[0] <= 'Z'))) {	\
		command;				\
d79 1
d82 1
d111 1
d123 1
d137 1
d153 1
d171 1
@


1.17
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.15 2017/12/06 21:16:58 tg Exp $");
d201 1
a201 1
	      in:
@


1.16
log
@whitespace at EOL annoys me
@
text
@d83 2
a84 2
#ifndef		_PATH_TMP
#    define	_PATH_TMP	"/tmp/"
@


1.15
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d1 1
a1 1
/* 
d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.14 2017/12/04 22:15:38 tg Exp $");
@


1.14
log
@clean up some unused/MS-DOS® stuff
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/path.c,v 1.13 2017/12/02 02:07:29 tg Exp $");
a12 1
#ifdef HAVE_SYS_STAT_H
a13 1
#endif
a19 1
#ifdef HAVE_LIMITS_H
a20 2
#endif
#ifdef HAVE_STDLIB_H
a21 1
#endif
@


1.13
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a89 3
#  ifdef __MSDOS__
#    define	_PATH_TMP	""
#  else
a90 1
#  endif
a325 41
#ifdef __MSDOS__
#include <dos.h>
#include <dir.h>

struct direct {
	unsigned char d_name[16];
} direc;
int dirstate = 0;
struct ffblk ffblk;
unsigned char *dirpath = NULL;

void *opendir(unsigned char *path)
{
	dirstate = 0;
	return &direc;
}

void closedir()
{
}

struct direct *readdir()
{
	int x;

	if (dirstate) {
		if (findnext(&ffblk))
			return NULL;
	} else {
		if (findfirst("*.*", &ffblk, FA_DIREC))
			return NULL;
		dirstate = 1;
	}

	strcpy(direc.d_name, ffblk.ff_name);
	for (x = 0; direc.d_name[x]; ++x)
		direc.d_name[x] = tolower(direc.d_name[x]);
	return &direc;
}
#endif
/********************************************************************/
a358 24
#ifdef __MSDOS__
	unsigned char buf[256];
	int x;

	if (!path)
		return 0;
	if ((path[0]) && (path[1] == ':')) {
		if (_chdrive(path[0] & 0x1F))
			return -1;
		path += 2;
	}
	if (!path[0])
		return 0;
	strcpy(buf, path);
	x = strlen(buf);
	while (x > 1) {
		--x;
		if ((buf[x] == '/') || (buf[x] == '\\'))
			buf[x] = 0;
		else
			break;
	}
	return chdir(buf);
#else
a361 1
#endif
@


1.12
log
@first cut at win32 self-relocation
@
text
@a0 1
/* $MirOS: contrib/code/jupp/path.c,v 1.9 2013/08/19 22:03:19 tg Exp $ */
d11 2
a12 2
#include <stdio.h>
#include <sys/types.h>
@


1.11
log
@first path of overhauling PATH handling

'foo\bar' is still shown and saved as 'foo/bar' though loaded from 'foo\bar'
but if disabled, 'fooar' is shown and the title bar bolded; b->name must be
escaped while rendering but must keep the actual pathname (hard!)
@
text
@d389 15
a403 1
int chpwd(unsigned char *path)
d459 23
@


1.10
log
@for real: backups use tmp files
@
text
@d77 8
a84 6
#ifdef __MSDOS__	/* paths in MS-DOS can include a drive letter followed by semicolon */
#define	do_if_drive_letter(path, command) do { \
						if ((path)[0] && (path)[1] == ':') { \
							command; \
						} \
					} while(0)
d86 1
a86 1
#define do_if_drive_letter(path, command)	do { } while(0)
d104 1
d114 1
@


1.9
log
@somewhat sanitise tmpfile handling
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.8 2012/12/19 21:14:53 tg Exp $ */
d135 1
a135 1
unsigned char *dirprt(unsigned char *path)
d143 5
a147 1
	return vsncpy(NULL, 0, path, z - path);
@


1.8
log
@use ten Xes for mkstemp(3) as recommended by OpenBSD for a decade or so,
and add a #warning for when there is no mkstemp (we mean it!)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.7 2012/06/07 22:18:23 tg Exp $ */
d214 1
a214 1
unsigned char *mktmp(unsigned char *where)
d224 2
d236 2
a237 2
	if((fd = mkstemp((char *)name)) == -1)
		return NULL;	/* FIXME: vflsh() and vflshf() */
d239 1
a239 2

	fchmod(fd, 0600);       /* Linux glibc 2.0 mkstemp() creates it with */
a241 2
	close(fd);

d243 2
a244 1
      loop:
d246 2
a247 1
	joe_snprintf_3(name, namesize, "%s/joe.tmp.%04u%05u", where, seq, (unsigned) time(NULL) % 100000);
a251 1
#warning "Waah, this is insecure! Consider getting mkstemp!"
d253 4
a256 1
		return NULL;	/* FIXME: see above */
d259 1
a259 2
#endif
	return name;
@


1.7
log
@missing include, noticed in klibc
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.6 2012/06/07 19:01:29 tg Exp $ */
d228 1
a228 1
	namesize = strlen((char *)where) + 16;
d233 1
a233 1
	joe_snprintf_1((char *)name, namesize, "%s/joe.tmp.XXXXXX", where);
d245 2
a246 2
	seq = (seq + 1) % 1000;
	joe_snprintf_3(name, namesize, "%s/joe.tmp.%03u%03u", where, seq, (unsigned) time(NULL) % 1000);
d251 1
@


1.6
log
@• configure.ac: add -D_GNU_SOURCE on Hurd
• configure.ac: check for get_current_dir_name function
• path.c: if PATH_MAX is not defined, do not complain about that and do
  not define a fallback of 4096 if get_current_dir_name is available
• path.c: second codepath for !PATH_MAX but get_current_dir_name (GNU/Hurd)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.5 2010/04/08 15:31:02 tg Exp $ */
d38 11
@


1.5
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.4 2009/10/06 09:07:30 tg Exp $ */
d85 1
a85 1
#ifndef PATH_MAX
d402 1
d414 8
@


1.4
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/path.c,v 1.3 2008/05/13 13:08:23 tg Exp $ */
d120 2
a121 1
	return (unsigned char *)strlcpy((char *)tmp, (char *)z, 1024);
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d30 4
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
	return (unsigned char *)strcpy((char *)tmp, (char *)z);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* Directory and path functions
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d13 3
d17 13
a29 2
#include "config.h"
#include "zstr.h"
a31 2
#include "tty.h"
#include "path.h"
d33 3
a35 2
#ifdef DIRENT
#include <dirent.h>
d37 30
a66 2
#ifdef SYSDIRENT
#include <sys/dirent.h>
d68 1
a68 118
#ifdef SYSDIR
#include <sys/dir.h>
#else
#ifdef BSDSYSDIR
#include <bsd/sys/dir.h>
#else
#ifndef __MSDOS__
#include "dir.c"
#endif
#endif
#endif
#endif
#endif

#ifdef junk
char *abspth(path)
char *path;
 {
 char *s=0;
 int x=0;
 int y;
 if(path[0]=='/')
  {
  s=vsadd(s,'/');
  while(path[x]=='/') ++x;
  y=1;
  }
 else
  {
  if(!(s=pwd())) return 0;
  s=vsncpy(NULL,0,sz(s));
  if(s[1]) s=vsadd(s,'/');
  y=sLEN(s);
  }
 while(path[x])
  {
  if(path[x]=='.' && (path[x+1]==0 || path[x+1]=='/'))
   {
   x+=1;
   while(path[x]=='/') ++x;
   continue;
   }
  if(path[x]=='.' && path[x+1]=='.' && (path[x+2]==0 || path[x+2]=='/'))
   {
   x+=2;
   while(path[x]=='/') ++x;
   if(y!=1)
    {
    --y;
    while(s[y-1]!='/') --y;
    }
   continue;
   }
  do
   s=vsset(s,y,path[x]), ++y, ++x;
   while(path[x] && path[x]!='/');
  s=vsset(s,y,'/'), ++y;
  while(path[x]=='/') x++;
  }
 if(y!=1 && s[y-1]=='/') --y;
 s=vstrunc(s,y);
 return s;
 }
#endif

char *ossep(path)
char *path;
 {
 int x;
 for(x=0;path[x];++x)
#ifdef __MSDOS__
  if(path[x]=='/') path[x]='\\';
#else
  if(path[x]=='\\') path[x]='/';
#endif
 return path;
 }

char *joesep(path)
char *path;
 {
 int x;
 for(x=0;path[x];++x) if(path[x]=='\\') path[x]='/';
 return path;
 }

char *namprt(path)
char *path;
 {
 char *z;
#ifdef __MSDOS__
 if(path[0] && path[1]==':') path+=2;
#endif
 z=path+slen(path);
 while(z!=path && z[-1]!='/') --z;
 return vsncpy(NULL,0,sz(z));
 }

char *namepart(tmp,path)
char *tmp;
char *path;
 {
 char *z;
#ifdef __MSDOS__
 if(path[0] && path[1]==':') path+=2;
#endif
 z=path+zlen(path);
 while(z!=path && z[-1]!='/') --z;
 return zcpy(tmp,z);
 }

char *dirprt(path)
char *path;
 {
 char *b=path;
 char *z=path+slen(path);
#ifdef __MSDOS__
 if(b[0] && b[1]==':') b+=2;
d70 1
a70 65
 while(z!=b && z[-1]!='/') --z;
 return vsncpy(NULL,0,path,z-path);
 }

char *begprt(path)
char *path;
 {
 char *z=path+slen(path);
 int drv=0;
#ifdef __MSDOS__
 if(path[0] && path[1]==':') drv=2;
#endif
 while(z!=path+drv && z[-1]=='/') --z;
 if(z==path+drv) return vsncpy(NULL,0,sz(path));
 else
  {
  while(z!=path+drv && z[-1]!='/') --z;
  return vsncpy(NULL,0,path,z-path);
  }
 }

char *endprt(path)
char *path;
 {
 char *z=path+slen(path);
 int drv=0;
#ifdef __MSDOS__
 if(path[0] && path[1]==':') drv=2;
#endif
 while(z!=path+drv && z[-1]=='/') --z;
 if(z==path+drv) return vsncpy(NULL,0,sc(""));
 else
  {
  while(z!=path+drv && z[-1]!='/') --z;
  return vsncpy(NULL,0,sz(z));
  }
 }

int mkpath(path)
char *path;
 {
 char *s;
 if(path[0]=='/')
  {
  if(chddir("/")) return 1;
  s=path;
  goto in;
  }
 while(path[0])
  {
  int c;
  for(s=path;*s && *s!='/';s++);
  c= *s; *s=0;
  if(chddir(path))
   {
   if(mkdir(path,0777)) return 1;
   if(chddir(path)) return 1;
   }
  *s=c;
  in:
  while(*s=='/') ++s;
  path=s;
  }
 return 0;
 }
d72 123
d196 29
a225 9
char *mktmp(where)
char *where;
 {
 static int seq=0;
 char *name;
 int fd;
 if(!where) where=getenv("TEMP");
#ifdef __MSDOS__
 if(!where) where="";
d227 76
a302 59
 if(!where) where="/tmp";
#endif
 name=(char *)malloc(zlen(where)+16);
 loop:
 sprintf(name,"%s/J%d%d.tmp",where,seq= ++seq%1000,(unsigned)time(NULL)%1000);
 ossep(name);
 if((fd=open(name,O_RDONLY))!= -1)
  {
  close(fd);
  goto loop;
  }
 if((fd=creat(name,0666))== -1) return 0;
 else close(fd);
 return name;
 }

int rmatch(a,b)
char *a, *b;
 {
 int flag, inv, c;
 for(;;)
  switch(*a)
   {
  case '*': ++a;
            do if(rmatch(a,b)) return 1; while(*b++);
            return 0;

  case '[': ++a;
            flag=0;
            if(*a=='^') ++a, inv=1; else inv=0;
            if(*a==']') if(*b==*a++) flag=1;
            while(*a && (c= *a++)!=']')
             if(c=='-' && a[-2]!='[' && *a)
              { if(*b>=a[-2] && *b<=*a) flag=1; }
             else if(*b==c) flag=1;
            if((!flag && !inv) || (flag && inv) || !*b) return 0;
            ++b;
            break;

  case '?': ++a;
            if(!*b) return 0;
            ++b;
            break;

  case 0:   if(!*b) return 1;
            else return 0;

  default:  if(*a++!=*b++) return 0;
   }
 }

int isreg(s)
char *s;
 {
 int x;
 for(x=0;s[x];++x) if(s[x]=='*' || s[x]=='?' || s[x]=='[') return 1;
 return 0;
 }

a303 1

d307 4
a310 5
struct direct
 {
 char d_name[16];
 } direc;
int dirstate=0;
d312 1
a312 1
char *dirpath=0;
d314 5
a318 6
void *opendir(path)
char *path;
 {
 dirstate=0;
 return &direc;
 }
d321 2
a322 2
 {
 }
d325 2
a326 16
 {
 int x;
 if(dirstate)
  {
  if(findnext(&ffblk)) return 0;
  }
 else
  {
  if(findfirst("*.*",&ffblk,FA_DIREC))
   return 0;
  dirstate=1;
  }
 zcpy(direc.d_name,ffblk.ff_name);
 for(x=0;direc.d_name[x];++x) direc.d_name[x]=todn(direc.d_name[x]);
 return &direc;
 }
d328 38
a365 1
#endif
d367 19
a385 7
char **rexpnd(word)
char *word;
 {
 void *dir;
 char **lst=0;
#ifdef DIRENT
 struct dirent *de;
d387 14
a400 2
#ifdef SYSDIRENT
 struct dirent *de;
d402 1
a402 1
 struct direct *de;
d404 4
a407 40
#endif
 dir=opendir(".");
 if(dir)
  {
  while(de=readdir(dir))
   if(zcmp(".",de->d_name))
    if(rmatch(word,de->d_name))
     lst=vaadd(lst,vsncpy(NULL,0,sz(de->d_name)));
  closedir(dir);
  }
 return lst;
 }

int chpwd(path)
char *path;
 {
#ifdef __MSDOS__
 char buf[256];
 int x;
 if(!path) return 0;
 if(path[0] && path[1]==':')
  {
  if(_chdrive(path[0]&0x1F)) return -1;
  path+=2;
  }
 if(!path[0]) return 0;
 zcpy(buf,path);
 x=zlen(buf);
 while(x>1)
  {
  --x;
  if(buf[x]=='/' || buf[x]=='\\') buf[x]=0;
  else break;
  }
 return chdir(buf);
#else
 if(!path || !path[0]) return 0;
 return chdir(path);
#endif
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
