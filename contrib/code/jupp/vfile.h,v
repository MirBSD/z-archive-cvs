head	1.8;
access;
symbols
	joe-3_1jupp38:1.8
	joe-3_1jupp37:1.7
	joe-3_1jupp36:1.7
	joe-3_1jupp35:1.7
	joe-3_1jupp34:1.7
	joe-3_1jupp33:1.7
	joe-3_1jupp32:1.7
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.3
	joe-3_1jupp30:1.3
	joe-3_1jupp29:1.3
	joe-3_1jupp28:1.3
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.2
	joe-3_1jupp18:1.2
	joe-3_1jupp17:1.2
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.2
	joe-3_1jupp15:1.2
	joe-3_1jupp14:1.2
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.8
date	2018.11.11.18.15.39;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005BE871D325833018;

1.7
date	2017.12.06.21.17.05;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A285E5918D423C7;

1.6
date	2017.12.04.22.15.40;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A25C91E16B3B365;

1.5
date	2017.12.02.17.00.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A22DC570063953B;

1.4
date	2017.12.02.02.07.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005A220AD65C90E687;

1.3
date	2012.06.08.16.55.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004FD22E961A7F5A95;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Software virtual memory system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_VFILE_H
#define _JOE_VFILE_H 1

#ifdef EXTERN
__IDSTRING(rcsid_vfile_h, "$MirOS: contrib/code/jupp/vfile.h,v 1.7 2017/12/06 21:17:05 tg Exp $");
#endif

/* Additions:
 *
 * Should we remove size checking from rc()?  Would make it faster...
 *
 * Should be able to open more than one stream on a file so that vseek
 * doesn't have to get called so much when more than one user is involed
 *
 * Also should have dupopen call to make more streams for a file
 *
 * Make vputs faster
 *
 * Should have a version which will use memory mapped files, if they exist
 * in the os.
 *
 * Would be nice if we could transparantly open non-file streams and pipes.
 * Should there be an buffering option for that?  So we can seek on pipes to
 * get previously read data?
 */

extern unsigned char *vbase;		/* Data first entry in vheader refers to */
extern VPAGE **vheaders;	/* Array of headers */

/* VFILE *vtmp(V);
 *
 * Open a temporary virtual file.  File goes away when closed.  No actual
 * file is generated if everything fits in memory.
 */
VFILE *vtmp(void);

/* long vsize(VFILE *);
 *
 * Return size of file
 */

#define vsize(vfile) \
	( \
	  (vfile)->left<(vfile)->lv ? \
	    (vfile)->alloc+(vfile)->lv-(vfile)->left \
	  : \
	    (vfile)->alloc \
	)

/* void vclose(VFILE *vfile);
 *
 * Close a file.
 */
void vclose(VFILE *vfile);

/* void vflsh(void);
 *
 * Write all changed pages to the disk
 */

void vflsh(void);

/* char *vlock(VFILE *vfile,long addr);
 *
 * Translate virtual address to physical address.  'addr' does not have
 * to be on any particular alignment, but if you wish to access more than
 * a single byte, you have to be aware of where page boundaries are (virtual
 * address multiples of PGSIZE).
 *
 * The page containing the data is locked in memory (so that it won't be
 * freed or used for something else) until 'vunlock' is used.
 *
 * Warning:  If you allocate more than one page and use (change) them out of
 * order, vflsh will screw up if writing past the end of a file is illegal
 * in the host filesystem.
 *
 * Also:  This function does not allocate space to the file.  Use valloc()
 * for that.  You can vlock() pages past the allocated size of the file, but
 * be careful when you do this (you normally shouldn't- the only time you
 * ever might want to is to implement your own version of valloc()).
 */

unsigned char *vlock(VFILE *vfile, unsigned long addr);

/* VPAGE *vheader(char *);
 * Return address of page header for given page
 */

#define vheader(p) (vheaders[(((size_t)(unsigned char *)(p))-((size_t)vbase))>>LPGSIZE])

/* void vchanged(char *);
 *
 * Indicate that a vpage was changed so that it will be written back to the
 * file.  Any physical address which falls within the page may be given.
 */

#define vchanged(vpage) ( vheader(vpage)->dirty=1 )

/* void vunlock(char *);
 * Unreference a vpage (call one vunlock for every vlock)
 * Any physical address which falls within the page may be given.
 */

#define vunlock(vpage)  ( --vheader(vpage)->count )

/* void vupcount(char *);
 * Indicate that another reference is being made to a vpage
 */

#define vupcount(vpage) ( ++vheader(vpage)->count )

/* long valloc(VFILE *vfile,long size);
 *
 * Allocate space at end of file
 *
 * Returns file address of beginning of allocated space
 */

long my_valloc(VFILE *vfile, long int size);
#endif
@


1.7
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__IDSTRING(rcsid_vfile_h, "$MirOS: contrib/code/jupp/vfile.h,v 1.6 2017/12/04 22:15:40 tg Exp $");
a69 7
/* void vflshf(VFILE *vfile);
 *
 * Write changed pages for a specific file to the disk
 */

void vflshf(VFILE *vfile);

@


1.6
log
@clean up some unused/MS-DOS® stuff
@
text
@d12 1
a12 1
__IDSTRING(rcsid_vfile_h, "$MirOS: contrib/code/jupp/vfile.h,v 1.5 2017/12/02 17:00:52 tg Exp $");
d42 1
a42 1
VFILE *vtmp PARAMS((void));
d61 1
a61 1
void vclose PARAMS((VFILE *vfile));
d68 1
a68 1
void vflsh PARAMS((void));
d75 1
a75 1
void vflshf PARAMS((VFILE *vfile));
d97 1
a97 1
unsigned char *vlock PARAMS((VFILE *vfile, unsigned long addr));
d133 1
a133 1
long my_valloc PARAMS((VFILE *vfile, long int size));
@


1.5
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_vfile_h, "$MirOS: contrib/code/jupp/vfile.h,v 1.4 2017/12/02 02:07:38 tg Exp $");
d103 1
a103 1
#define vheader(p) (vheaders[(physical((unsigned char *)(p))-physical(vbase))>>LPGSIZE])
@


1.4
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.3
log
@nuke junk
@
text
@a0 1
/* $MirOS: contrib/code/jupp/vfile.h,v 1.2 2008/05/13 13:08:32 tg Exp $ */
d11 3
a13 2
#include "config.h"
#include "types.h"
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
a43 9
#ifdef junk
/* VFILE *vopen(char *name);
 *
 * Open a file for reading and if possible, writing.  If the file could not
 * be opened, NULL is returned.
 */
VFILE *vopen PARAMS(());
#endif

d63 1
a63 15
#ifdef junk
/* void vlimit(long amount);
 *
 * Set limit (in bytes) on amount of memory the virtual file system may
 * use.  This limit can be exceeded if all existing vpages are being referenced
 * and a new vpage is requested.
 *
 * When vlimit is called, the limit is immediatly enforced by elimiting
 * non-referenced vpages.
 */

void vlimit PARAMS(());
#endif

/* void vflsh(void); 
a133 197

#ifdef junk
/******************************************************************************
 * The folloing functions implement stream I/O on top of the above software   *
 * virtual memory system                                                      *
 ******************************************************************************/

/* void vseek(VFILE *vfile,long addr);
 *
 * Seek to a file address.  Allocates space to the file if you seek past the
 * end.
 */
void vseek PARAMS(());

/* int vrgetc(VFILE *);
 * int vgetc(VFILE *);
 *
 * Get next character / Get previous character functions.
 * They return NO_MORE_DATA for end of file / beginning of file.
 */

int _vgetc PARAMS(());
int _vrgetc PARAMS(());

#define vrgetc(v) \
        ( (v)->left!=PGSIZE ? ( ++(v)->left, (int)(unsigned)*(--(v)->bufp) ) : _vrgetc(v) )

#define vgetc(v) \
	( (v)->left>(v)->lv ? ( --(v)->left, (int)(unsigned)*((v)->bufp++) ) : _vgetc(v) )

/* int vputc(VFILE *,I);
 *
 * Put character.  Returns character which is written.
 */

int _vputc PARAMS(());

#define vputc(v,c) \
	( \
	  (v)->left ? \
	   ( \
	   --(v)->left, \
	   vchanged((v)->vpage), \
 	   (int)(unsigned)(*((v)->bufp++)=(c)) \
	   ) \
	  : \
	   _vputc((v),(c)) \
	)

/* long vtell(VFILE *);
 *
 * Return current file position
 */

#define vtell(v) \
	( \
	 (v)->vpage ? \
	  ( vheader((v)->vpage)->addr+(v)->bufp-(v)->vpage ) \
	 : \
	  0L \
	)

/* long vgetl(VFILE *);
 *
 * Get long.  No alignment requirements.  Returns -1 if goes past end of file.
 */

long vgetl PARAMS(());

/* short vgetw(VFILE *);
 *
 * Get short.  No alignment requirements.  Returns -1 if goes past end of file.
 */

short vgetw PARAMS(());

/* long vputl(VFILE *,long);
 *
 * Put long.  No alignment requirements.
 * Returns value written.
 */

long vputl PARAMS(());

/* short vputw(VFILE *,short);
 *
 * Put long.  No alignement requirements.
 * Returns value written.
 */

short vputw PARAMS(());

/* char *vgets(VFILE *v,char *s);
 *
 * Read up to next '\n' or end of file into a variable length string.  If 's'
 * is 0, a new string is created.  The \n is not copied into the string.
 *
 * Eliminates the variable length string and returns NULL if
 * vgets is called on the end of the file.
 *
 * This requires that you use the 'vs.h' / 'vs.c' library.
 */

unsigned char *vgets PARAMS(());

/* void vputs(VFILE *v,char *s);
 *
 * Write zero terminated string. \n is not appended */

void vputs PARAMS(());

/* void vread(VFILE *,char *,int size);
 *
 * Read bytes from a virtual file into a local data block
 */

void vread PARAMS(());

/* void vwrite(VFILE *,char *,int size);
 *
 * Write bytes from a local data block into a virtual file
 */

void vwrite PARAMS(());

/*************************************************************************** 
 * The following functions implement array I/O on top of the above virtual *
 * memory system (cheap memory mapped files)                               *
 ***************************************************************************/

/* int rc(VFILE *vfile,long addr);
 *
 * Read character.  Returns NO_MORE_DATA if past end of file.
 */

int _rc();

#define rc(v,a) \
	( \
	  (a)>=vsize(v) ? NO_MORE_DATA : \
	    ( \
	      (v)->addr==((a)&~(PGSIZE-1)) ? \
	       (v)->vpage1[(a)&(PGSIZE-1)] \
	      : \
	       _rc((v),(a)) \
	    ) \
	)

/* int wc(VFILE *vfile,long addr,char c);
 *
 * Write character.  Return character written.  This automatically allocates
 * space to the file.
 */

int _wc();

#define wc(v,a,c) \
	( \
	  (v)->addr==((a)&~(PGSIZE-1)) ? \
	   ( \
	   vheader((v)->vpage1)->dirty=1, \
	   ((a)+1>vsize(v) && my_valloc(v,(a)+1-vsize(v))), \
	   (v)->vpage1[(a)&(PGSIZE-1)]=(c) \
	   ) \
	  : \
	   _wc((v),(a),(c)) \
	)

/* long rl(VFILE *vfile,long addr);
 * Read big-endian long.  No alignment requirements.  Returns -1 if goes past
 * end of file.
 */

long rl PARAMS(());

/* long wl(VFILE *vfile,long addr,long c);
 * Write big-endian long.  No alignment requirements.  Automatically expands
 * file if necessary.
 */

long wl PARAMS(());

/* short rw(VFILE *vfile,long addr);
 * Read big-endian short.  No alignment requirements.  Returns -1 if goes past
 * end of file.
 */

short rw PARAMS(());

/* short ww(VFILE *vfile,long addr,short c);
 * Write big-endian short.  No alignment requirements.  Automatically expands
 * file if necessary.
 */

short ww PARAMS(());

#endif
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Software virtual memory system
   Copyright (C) 1992 Joseph H. Allen
d11 2
a12 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d33 1
a33 57
#ifndef _Ivfile
#define _Ivfile 1

#include "config.h"
#include "queue.h"

typedef struct vpage VPAGE;
typedef struct vfile VFILE;

/* These are now defined in config.h */
#ifdef junk
/* Minimum page size for MS-DOS is 128 (for 32K vheaders table) or 256 (for
 * 64K vheaders table) */
#define PGSIZE 512              /* Page size in bytes (Must be power of 2) */
#define LPGSIZE 9               /* LOG base 2 of PGSIZE */
#define ILIMIT (PGSIZE*128L)    /* Max amount to buffer */
#define HTSIZE 128              /* Entries in hash table.  Must be pwr of 2 */
#endif

#define INC 16                  /* Pages to allocate each time */

/* Page header */

struct vpage
 {
 VPAGE *next;			/* Next page with same hash value */
 VFILE *vfile;			/* Owner vfile */
 long addr;			/* Address of this page */
 int count;			/* Reference count */
 int dirty;			/* Set if page changed */
 char *data;			/* The data in the page */
 };

/* File structure */

struct vfile
 {
 LINK(VFILE) link;		/* Doubly linked list of vfiles */
 long size;			/* Number of bytes in physical file */
 long alloc;			/* Number of bytes allocated to file */
 int fd;			/* Physical file */
 int writeable;			/* Set if we can write */
 char *name;			/* File name.  0 if unnamed */
 int flags;			/* Set if this is only a temporary file */

 /* For array I/O */
 char *vpage1;			/* Page address */
 long addr;			/* File address of above page */

 /* For stream I/O */
 char *bufp;			/* Buffer pointer */
 char *vpage;			/* Buffer pointer points in here */
 int left;			/* Space left in bufp */
 int lv;			/* Amount of append space at end of buffer */
 };

extern char *vbase;		/* Data first entry in vheader refers to */
d41 1
a41 1
VFILE *vtmp();
d49 1
a49 1
VFILE *vopen();
d69 1
a69 1
void vclose();
d82 1
a82 1
void vlimit();
d90 1
a90 1
void vflsh();
d97 1
a97 1
void vflshf();
d119 1
a119 1
char *vlock();
d125 1
a125 1
#define vheader(p) (vheaders[(physical((char *)(p))-physical(vbase))>>LPGSIZE])
d155 1
a155 1
long valloc();
d168 1
a168 1
void vseek();
d174 1
a174 1
 * They return MAXINT for end of file / beginning of file.
d177 2
a178 2
int _vgetc();
int _vrgetc();
d191 1
a191 1
int _vputc();
d223 1
a223 1
long vgetl();
d230 1
a230 1
short vgetw();
d238 1
a238 1
long vputl();
d246 1
a246 1
short vputw();
d259 1
a259 1
char *vgets();
d265 1
a265 1
void vputs();
d272 1
a272 1
void vread();
d279 1
a279 1
void vwrite();
d288 1
a288 1
 * Read character.  Returns MAXINT if past end of file.
d295 1
a295 1
	  (a)>=vsize(v) ? MAXINT : \
d317 1
a317 1
	   ((a)+1>vsize(v) && valloc(v,(a)+1-vsize(v))), \
d329 1
a329 1
long rl();
d336 1
a336 1
long wl();
d343 1
a343 1
short rw();
d350 1
a350 1
short ww();
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
