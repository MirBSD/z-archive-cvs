head	1.36;
access;
symbols
	joe-3_1jupp38:1.36
	joe-3_1jupp37:1.36
	joe-3_1jupp36:1.35
	joe-3_1jupp35:1.34
	joe-3_1jupp34:1.33
	joe-3_1jupp33:1.33
	joe-3_1jupp32:1.31
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.17
	joe-3_1jupp30:1.15
	joe-3_1jupp29:1.14
	joe-3_1jupp28:1.11
	joe-3_1jupp27:1.11
	joe-3_1jupp26:1.11
	joe-3_1jupp25:1.10
	joe-3_1jupp24:1.9
	joe-3_1jupp23:1.9
	joe-3_1jupp22:1.9
	joe-3_1jupp21:1.9
	joe-3_1jupp20:1.9
	joe-3_1jupp19:1.9
	joe-3_1jupp18:1.9
	joe-3_1jupp17:1.9
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.9
	joe-3_1jupp15:1.9
	joe-3_1jupp14:1.9
	joe-3_1jupp12:1.9
	joe-3_1jupp11:1.5
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.5
	joe-3_1jupp9:1.4
	joe-3_1jupp8:1.3
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.36
date	2018.08.10.02.53.45;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005B6CFE0B5BDFE404;

1.35
date	2018.02.15.01.18.57;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A84E010523C14B2;

1.34
date	2018.02.14.22.28.12;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A84B80D6E0680C7;

1.33
date	2018.01.06.00.28.34;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A50184621FA8455;

1.32
date	2017.12.26.23.26.57;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A42DAC4081ACA30;

1.31
date	2017.12.16.22.10.55;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A359A0405479D56;

1.30
date	2017.12.08.03.24.16;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A2A05EB07C8D953;

1.29
date	2017.12.08.02.17.23;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A29F64A06DEB239;

1.28
date	2017.12.07.02.10.18;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A28A3145E1FF911;

1.27
date	2017.12.06.23.58.38;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A2884424C3F3AD8;

1.26
date	2017.12.06.23.41.15;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A287FFB193094A5;

1.25
date	2017.12.06.23.02.06;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A2876FC4FFE7EF5;

1.24
date	2017.12.06.21.41.03;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A28640547F64250;

1.23
date	2017.12.04.22.15.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A25C91E16B3B365;

1.22
date	2017.12.04.21.53.34;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A25C3E151C5344D;

1.21
date	2017.12.03.02.36.03;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A2363204B0C4612;

1.20
date	2017.12.02.04.32.42;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A222CF2122034D9;

1.19
date	2017.12.02.02.07.34;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A220AD65C90E687;

1.18
date	2017.12.01.23.26.24;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A21E4F06CA95502;

1.17
date	2017.03.19.19.19.51;	author tg;	state Exp;
branches;
next	1.16;
commitid	10058CED9DF339F2D5D;

1.16
date	2017.03.19.17.39.00;	author tg;	state Exp;
branches;
next	1.15;
commitid	10058CEC24420FBEA52;

1.15
date	2017.01.11.22.56.49;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005876B84150F7CE16;

1.14
date	2016.10.07.20.36.41;	author tg;	state Exp;
branches;
next	1.13;
commitid	10057F80770254DE843;

1.13
date	2016.10.07.20.07.50;	author tg;	state Exp;
branches;
next	1.12;
commitid	10057F800AE47CC7672;

1.12
date	2016.10.07.19.52.25;	author tg;	state Exp;
branches;
next	1.11;
commitid	10057F7FD0A2FB91192;

1.11
date	2013.11.07.21.50.36;	author tg;	state Exp;
branches;
next	1.10;
commitid	100527C0B43044C6E4A;

1.10
date	2013.08.19.19.19.31;	author tg;	state Exp;
branches;
next	1.9;
commitid	10052126FDA15E01220;

1.9
date	2009.10.18.16.02.02;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004ADB3C034B785311;

1.8
date	2009.10.18.14.52.58;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004ADB2BD317498872;

1.7
date	2009.10.18.13.20.55;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004ADB161315D8E0C9;

1.6
date	2009.10.06.09.07.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004ACB08E905F8F83E;

1.5
date	2008.08.21.12.45.33;	author tg;	state Exp;
branches;
next	1.4;
commitid	10048AD63706C5A273A;

1.4
date	2008.05.13.13.08.27;	author tg;	state Exp;
branches;
next	1.3;
commitid	100482992BC01EE89A1;

1.3
date	2007.02.18.22.45.00;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045D8D6F0046830D7;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.36
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@/*
 *	Basic user edit functions
 *	Copyright
 * 		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.35 2018/02/15 01:18:57 tg Exp $");

#include <string.h>

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "pw.h"
#include "qw.h"
#include "scrn.h"
#include "ublock.h"
#include "uedit.h"
#include "uformat.h"
#include "umath.h"
#include "utils.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"

/***************/
/* Global options */
int pgamnt = -1;		/* No. of PgUp/PgDn lines to keep */

/******** i don't like global var ******/

/*
 * Move cursor to beginning of line
 */
int u_goto_bol(BW *bw)
{
	if (bw->o.hex) {
		pbkwd(bw->cursor,bw->cursor->byte%16);
	} else {
		p_goto_bol(bw->cursor);
	}
	return 0;
}

/*
 * Move cursor to first non-whitespace character, unless it is
 * already there, in which case move it to beginning of line
 */
int uhome(BW *bw)
{
	P *p;

	if (bw->o.hex) {
		return u_goto_bol(bw);
	}

	p = pdup(bw->cursor);

	if (bw->o.indentfirst) {
		if ((bw->o.smarthome) && (piscol(p) > pisindent(p))) {
			p_goto_bol(p);
			while (joe_isblank(p->b->o.charmap,brc(p)))
				pgetc(p);
		} else
			p_goto_bol(p);
	} else {
		if (bw->o.smarthome && piscol(p)==0 && pisindent(p)) {
			while (joe_isblank(p->b->o.charmap,brc(p)))
				pgetc(p);
		} else
			p_goto_bol(p);
	}

	pset(bw->cursor, p);
	prm(p);
	return 0;
}

/*
 * Move cursor to end of line
 */
int u_goto_eol(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte + 15 - bw->cursor->byte%16 > bw->b->eof->byte)
			pset(bw->cursor,bw->b->eof);
		else
			pfwrd(bw->cursor, 15 - bw->cursor->byte%16);
	} else
		p_goto_eol(bw->cursor);
	return 0;
}

/*
 * Move cursor to beginning of file
 */
int u_goto_bof(BW *bw)
{
	p_goto_bof(bw->cursor);
	return 0;
}

/*
 * Move cursor to end of file
 */
int u_goto_eof(BW *bw)
{
	p_goto_eof(bw->cursor);
	return 0;
}

/*
 * Move cursor left
 */
int u_goto_left(BW *bw)
{
	if (bw->o.hex) {
		if (prgetb(bw->cursor) != NO_MORE_DATA) {
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->o.picture) {
		if (bw->cursor->xcol) {
			--bw->cursor->xcol;
			pcol(bw->cursor,bw->cursor->xcol);
			return 0;
		}
	} else {
		/* Have to do ECHKXCOL here because of picture mode */
		if (bw->cursor->xcol != piscol(bw->cursor)) {
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else if (prgetc(bw->cursor) != NO_MORE_DATA) {
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		}
	}
	return -1;
}

/*
 * Move cursor right
 */
int u_goto_right(BW *bw)
{
	if (bw->o.hex) {
		if (pgetb(bw->cursor) != NO_MORE_DATA) {
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->o.picture) {
		++bw->cursor->xcol;
		pcol(bw->cursor,bw->cursor->xcol);
		return 0;
	} else {
		int rtn;
		if (pgetc(bw->cursor) != NO_MORE_DATA) {
			bw->cursor->xcol = piscol(bw->cursor);
			rtn = 0;
		} else {
			rtn = -1;
		}
		/* Have to do EFIXXCOL here because of picture mode */
		if (bw->cursor->xcol != piscol(bw->cursor))
			bw->cursor->xcol = piscol(bw->cursor);
		return rtn;
	}
}

/*
 * Move cursor to beginning of previous word or if there isn't
 * previous word then go to beginning of the file
 *
 * WORD is a sequence non-white-space characters
 */
int u_goto_prev(BW *bw)
{
	P *p = pdup(bw->cursor);
	struct charmap *map=bw->b->o.charmap;
	int c = prgetc(p);

	if (joe_isalnux(map,c)) {
		while (joe_isalnux(map,(c=prgetc(p))))
			/* Do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(p);
	} else if (joe_isspace(map,c) || joe_ispunct(map,c)) {
		while ((c=prgetc(p)), (joe_isspace(map,c) || joe_ispunct(map,c)))
			/* Do nothing */;
		while(joe_isalnux(map,(c=prgetc(p))))
			/* Do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(p);
	}
/*
	if (p->byte == bw->cursor->byte) {
		prm(p);
		return -1;
	}
*/
	pset(bw->cursor, p);
	prm(p);
	return 0;
}

/*
 * Move cursor to end of next word or if there isn't
 * next word then go to end of the file
 *
 * WORD is a sequence non-white-space characters
 */
int u_goto_next(BW *bw)
{
	P *p = pdup(bw->cursor);
	struct charmap *map=bw->b->o.charmap;
	int c = brch(p);
	int rtn = -1;

	if (joe_isalnux(map,c)) {
		rtn = 0;
		while (joe_isalnux(map,(c = brch(p))))
			pgetc(p);
	} else if (joe_isspace(map,c) || joe_ispunct(map,c)) {
		while (joe_isspace(map, (c = brch(p))) || joe_ispunct(map,c))
			pgetc(p);
		while (joe_isalnux(map,(c = brch(p)))) {
			rtn = 0;
			pgetc(p);
		}
	} else
		pgetc(p);
	pset(bw->cursor, p);
	prm(p);
	return rtn;
}

static P *pboi(P *p)
{
	p_goto_bol(p);
	while (joe_isblank(p->b->o.charmap,brch(p)))
		pgetc(p);
	return p;
}

static int pisedge(P *p)
{
	P *q;
	int c;

	if (pisbol(p))
		return -1;
	if (piseol(p))
		return 1;
	q = pdup(p);
	pboi(q);
	if (q->byte == p->byte)
		goto left;
	if (joe_isblank(p->b->o.charmap,(c = brch(p)))) {
		pset(q, p);
		if (joe_isblank(p->b->o.charmap,prgetc(q)))
			goto no;
		if (c == '\t')
			goto right;
		pset(q, p);
		pgetc(q);
		if (pgetc(q) == ' ')
			goto right;
		goto no;
	} else {
		pset(q, p);
		c = prgetc(q);
		if (c == '\t')
			goto left;
		if (c != ' ')
			goto no;
		if (prgetc(q) == ' ')
			goto left;
		goto no;
	}

      right:prm(q);
	return 1;
      left:prm(q);
	return -1;
      no:prm(q);
	return 0;
}

int upedge(BW *bw)
{
	if (prgetc(bw->cursor) == NO_MORE_DATA)
		return -1;
	while (pisedge(bw->cursor) != -1)
		prgetc(bw->cursor);
	return 0;
}

int unedge(BW *bw)
{
	if (pgetc(bw->cursor) == NO_MORE_DATA)
		return -1;
	while (pisedge(bw->cursor) != 1)
		pgetc(bw->cursor);
	return 0;
}

/* Move cursor to matching delimiter */

static int
utomatch_i(BW *bw, int dir)
{
	int d;
	int c;			/* character under cursor */
	int f;			/* character to find */
	P *p;
	int cnt = 0;		/* delimiter depth */

	switch (f = c = brch(bw->cursor)) {
	case '(':
		f = ')';
		dir = 1;
		break;
	case '[':
		f = ']';
		dir = 1;
		break;
	case '{':
		f = '}';
		dir = 1;
		break;
	case '<':
		f = '>';
		dir = 1;
		break;
	case ')':
		f = '(';
		dir = -1;
		break;
	case ']':
		f = '[';
		dir = -1;
		break;
	case '}':
		f = '{';
		dir = -1;
		break;
	case '>':
		f = '<';
		dir = -1;
		break;
	}

	p = pdup(bw->cursor);
	if (dir == 1) {
		while ((d = pgetc(p)) != NO_MORE_DATA) {
			if (d == f && f != c && !--cnt) {
				prgetc(p);
				goto match_found;
			} else if (d == c) {
				++cnt;
				if (f == c)
					c = NO_MORE_DATA;
			}
		}
	} else {
		while ((d = prgetc(p)) != NO_MORE_DATA) {
			if (d == f && !cnt--)
				goto match_found;
			else if (d == c)
				++cnt;
		}
	}
	if (/* CONSTCOND */ 0) {
 match_found:
		pset(bw->cursor, p);
	}
	prm(p);
	return ((d == NO_MORE_DATA) ? -1 : 0);
}

int utomatch(BW *bw)
{
	return (utomatch_i(bw, 1));
}

int urvmatch(BW *bw)
{
	return (utomatch_i(bw, -1));
}

/* Move cursor up */

int uuparw(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte<16)
			return -1;
		else {
			pbkwd(bw->cursor, 16);
			return 0;
		}
	}
	if (bw->cursor->line) {
		pprevl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else
		return -1;
}

/* Move cursor down */

int udnarw(BW *bw)
{
	if (bw->o.hex) {
		if (bw->cursor->byte+16 <= bw->b->eof->byte) {
			pfwrd(bw->cursor, 16);
			return 0;
		} else if (bw->cursor->byte != bw->b->eof->byte) {
			pset(bw->cursor, bw->b->eof);
			return 0;
		} else {
			return -1;
		}
	}
	if (bw->cursor->line != bw->b->eof->line) {
		pnextl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else if(bw->o.picture) {
		p_goto_eol(bw->cursor);
		binsc(bw->cursor,'\n');
		pgetc(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);
		return 0;
	} else
		return -1;
}

/* Move cursor to top of window */

int utos(BW *bw)
{
	long col = bw->cursor->xcol;

	pset(bw->cursor, bw->top);
	pcol(bw->cursor, col);
	bw->cursor->xcol = col;
	return 0;
}

/* Move cursor to bottom of window */

int ubos(BW *bw)
{
	long col = bw->cursor->xcol;

	pline(bw->cursor, bw->top->line + bw->h - 1);
	pcol(bw->cursor, col);
	bw->cursor->xcol = col;
	return 0;
}

/* Scroll buffer window up n lines
 * If beginning of file is close, scrolls as much as it can
 * If beginning of file is on-screen, cursor jumps to beginning of file
 *
 * If flg is set: cursor stays fixed relative to screen edge
 * If flg is clr: cursor stays fixed on the buffer line
 */

void scrup(BW *bw, int n, int flg)
{
	int scrollamnt = 0;
	int cursoramnt = 0;
	int x;

	/* Decide number of lines we're really going to scroll */

	if (bw->o.hex) {
		if (bw->top->byte/16 >= n)
			scrollamnt = cursoramnt = n;
		else if (bw->top->byte/16)
			scrollamnt = cursoramnt = bw->top->byte/16;
		else if (flg)
			cursoramnt = bw->cursor->byte/16;
		else if (bw->cursor->byte/16 >= n)
			cursoramnt = n;
	} else {
		if (bw->top->line >= n)
			scrollamnt = cursoramnt = n;
		else if (bw->top->line)
			scrollamnt = cursoramnt = bw->top->line;
		else if (flg)
			cursoramnt = bw->cursor->line;
		else if (bw->cursor->line >= n)
			cursoramnt = n;
	}

	if (bw->o.hex) {
		/* Move top-of-window pointer */
		pbkwd(bw->top,scrollamnt*16);
		/* Move cursor */
		pbkwd(bw->cursor,cursoramnt*16);
		/* If window is on the screen, give (buffered) scrolling command */
		if (bw->parent->y != -1)
			nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	} else {
		/* Move top-of-window pointer */
		for (x = 0; x != scrollamnt; ++x)
			pprevl(bw->top);
		p_goto_bol(bw->top);

		/* Move cursor */
		for (x = 0; x != cursoramnt; ++x)
			pprevl(bw->cursor);
		p_goto_bol(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);

		/* If window is on the screen, give (buffered) scrolling command */
		if (bw->parent->y != -1)
			nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	}
}

/* Scroll buffer window down n lines
 * If end of file is close, scrolls as much as possible
 * If end of file is on-screen, cursor jumps to end of file
 *
 * If flg is set: cursor stays fixed relative to screen edge
 * If flg is clr: cursor stays fixed on the buffer line
 */

void scrdn(BW *bw, int n, int flg)
{
	int scrollamnt = 0;
	int cursoramnt = 0;
	int x;

	/* How much we're really going to scroll... */
	if (bw->o.hex) {
		if (bw->top->b->eof->byte/16 < bw->top->byte/16 + bw->h) {
			cursoramnt = bw->top->b->eof->byte/16 - bw->cursor->byte/16;
			if (!flg && cursoramnt > n)
				cursoramnt = n;
		} else if (bw->top->b->eof->byte/16 - (bw->top->byte/16 + bw->h) >= n)
			cursoramnt = scrollamnt = n;
		else
			cursoramnt = scrollamnt = bw->top->b->eof->byte/16 - (bw->top->byte/16 + bw->h) + 1;
	} else {
		if (bw->top->b->eof->line < bw->top->line + bw->h) {
			cursoramnt = bw->top->b->eof->line - bw->cursor->line;
			if (!flg && cursoramnt > n)
				cursoramnt = n;
		} else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
			cursoramnt = scrollamnt = n;
		else
			cursoramnt = scrollamnt = bw->top->b->eof->line - (bw->top->line + bw->h) + 1;
	}

	if (bw->o.hex) {
		/* Move top-of-window pointer */
		pfwrd(bw->top,16*scrollamnt);
		/* Move cursor */
		pfwrd(bw->cursor,16*cursoramnt);
		/* If window is on screen, give (buffered) scrolling command to terminal */
		if (bw->parent->y != -1)
			nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	} else {
		/* Move top-of-window pointer */
		for (x = 0; x != scrollamnt; ++x)
			pnextl(bw->top);

		/* Move cursor */
		for (x = 0; x != cursoramnt; ++x)
			pnextl(bw->cursor);
		pcol(bw->cursor, bw->cursor->xcol);

		/* If window is on screen, give (buffered) scrolling command to terminal */
		if (bw->parent->y != -1)
			nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
	}
}

/* Page up */

int upgup(BW *bw)
{
	bw = bw->parent->main->object.bw;
	if (bw->o.hex ? bw->cursor->byte < 16 : !bw->cursor->line)
		return -1;
	if (pgamnt < 0)
		scrup(bw, bw->h / 2 + bw->h % 2, 1);
	else if (pgamnt < bw->h)
		scrup(bw, bw->h - pgamnt, 1);
	else
		scrup(bw, 1, 1);
	return 0;
}

/* Page down */

int upgdn(BW *bw)
{
	bw = bw->parent->main->object.bw;
	if (bw->o.hex ? bw->cursor->byte/16 == bw->b->eof->byte/16 : bw->cursor->line == bw->b->eof->line)
		return -1;
	if (pgamnt < 0)
		scrdn(bw, bw->h / 2 + bw->h % 2, 1);
	else if (pgamnt < bw->h)
		scrdn(bw, bw->h - pgamnt, 1);
	else
		scrdn(bw, 1, 1);
	return 0;
}

/* Scroll by a single line.  The cursor moves with the scroll */

int uupslide(BW *bw)
{
	bw = bw->parent->main->object.bw;
	if (bw->o.hex ? bw->top->byte/16 : bw->top->line) {
		if (bw->o.hex ? bw->top->byte/16 + bw->h -1 != bw->cursor->byte/16 : bw->top->line + bw->h - 1 != bw->cursor->line)
			udnarw(bw);
		scrup(bw, 1, 0);
		return 0;
	} else
		return -1;
}

int udnslide(BW *bw)
{
	bw = bw->parent->main->object.bw;
	if (bw->o.hex ? bw->top->line/16 + bw->h <= bw->top->b->eof->byte/16 : bw->top->line + bw->h <= bw->top->b->eof->line) {
		if (bw->o.hex ? bw->top->byte/16 != bw->cursor->byte/16 : bw->top->line != bw->cursor->line)
			uuparw(bw);
		scrdn(bw, 1, 0);
		return 0;
	} else
		return -1;
}

/* Move cursor to specified line number */

static B *linehist = NULL;	/* History of previously entered line numbers */

static int doline(BW *bw, unsigned char *s, void *object, int *notify)
{
	long num = calcl(bw, s);

	if (notify)
		*notify = 1;
	vsrm(s);
	if (num >= 1 && !merrf) {
		int tmp = mid;

		if (num > bw->b->eof->line)
			num = bw->b->eof->line + 1;
		pline(bw->cursor, num - 1), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merrf)
			msgnw(bw->parent, merrt);
		else
			msgnw(bw->parent, UC "Invalid line number");
		return -1;
	}
}

int uline(BW *bw)
{
	if (wmkpw(bw->parent, UC "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL, locale_map))
		return 0;
	else
		return -1;
}

/* Move cursor to specified column number */

static B *colhist = NULL;	/* History of previously entered column numbers */

static int docol(BW *bw, unsigned char *s, void *object, int *notify)
{
	long num = calcl(bw, s);

	if (notify)
		*notify = 1;
	vsrm(s);
	if (num >= 1 && !merrf) {
		int tmp = mid;

		pcol(bw->cursor, num - 1), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merrf)
			msgnw(bw->parent, merrt);
		else
			msgnw(bw->parent, UC "Invalid column number");
		return -1;
	}
}

int ucol(BW *bw)
{
	if (wmkpw(bw->parent, UC "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL, locale_map))
		return 0;
	else
		return -1;
}

/* Move cursor to specified byte number */

static B *bytehist = NULL;	/* History of previously entered byte numbers */

static int dobyte(BW *bw, unsigned char *s, void *object, int *notify)
{
	long num = calcl(bw, s);

	if (notify)
		*notify = 1;
	vsrm(s);
	if (num >= 0 && !merrf) {
		int tmp = mid;

		pgoto(bw->cursor, num), bw->cursor->xcol = piscol(bw->cursor);
		mid = 1;
		dofollows();
		mid = tmp;
		return 0;
	} else {
		if (merrf)
			msgnw(bw->parent, merrt);
		else
			msgnw(bw->parent, UC "Invalid byte number");
		return -1;
	}
}

int ubyte(BW *bw)
{
	if (wmkpw(bw->parent, UC "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, locale_map))
		return 0;
	else
		return -1;
}

/* Delete character under cursor
 * or write ^D to process if we're at end of file in a shell window
 */

int udelch(BW *bw)
{
	P *p;

	if (piseof(bw->cursor))
		return -1;
	pgetc(p = pdup(bw->cursor));
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Backspace */

int ubacks(BW *bw, int k)
{
	/* Don't backspace when at beginning of line in prompt windows */
	if (bw->parent->watom->what == TYPETW || !pisbol(bw->cursor)) {
		int c;
		int indent;
		int col;
		int indwid;
		int wid;

		if (pisbof(bw->cursor))
			return -1;

		/* Indentation point of this line */
		indent = pisindent(bw->cursor);

		/* Column position of cursor */
		col = piscol(bw->cursor);

		/* Indentation step in columns */
		if (bw->o.indentc=='\t')
			wid = bw->o.tab;
		else
			wid = 1;

		indwid = (bw->o.istep*wid);

		/* Smart backspace when: cursor is at indentation point, indentation point
		   is a multiple of indentation width, we're not at beginning of line,
		   'smarthome' option is enabled, and indentation is purely made out of
		   indent characters (or purify indents is enabled). */

		/* Ignore purify for backspace */
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks) {
			P *p;

			/* Delete all indentation */
			p = pdup(bw->cursor);
			p_goto_bol(p);
			bdel(p,bw->cursor);
			prm(p);

			/* Indent to new position */
			pfill(bw->cursor,col-indwid,bw->o.indentc);
		} else if (col<indent && !pisbol(bw->cursor) && bw->o.smartbacks) {
			/* We're before indent point: delete indwid worth of space but do not
			   cross line boundary.  We could probably replace the above with this. */
			int cw=0;
			P *p = pdup(bw->cursor);
			do {
				c = prgetc(bw->cursor);
				if(c=='\t') cw += bw->o.tab;
				else cw += 1;
				bdel(bw->cursor, p);
			} while(!pisbol(bw->cursor) && cw<indwid);
			prm(p);
		} else {
			/* Regular backspace */
			P *p = pdup(bw->cursor);
			if ((c = prgetc(bw->cursor)) != NO_MORE_DATA)
				if (!bw->o.overtype || c == '\t' || pisbol(p) || piseol(p))
					bdel(bw->cursor, p);
			prm(p);
		}
		return 0;
	} else
		return -1;
}

/*
 * Delete sequence of characters (alphabetic, numeric) or (white-space)
 *	if cursor is on the white-space it will delete all white-spaces
 *		until alphanumeric character
 *      if cursor is on the alphanumeric it will delete all alphanumeric
 *		characters until character that is not alphanumeric
 */
int u_word_delete(BW *bw)
{
	P *p = pdup(bw->cursor);
	struct charmap *map=bw->b->o.charmap;
	int c = brch(p);

	if (joe_isalnux(map,c))
		while (joe_isalnux(map,(c = brch(p))))
			pgetc(p);
	else if (joe_isspace(map,c))
		while (joe_isspace(map,(c = brch(p))))
			pgetc(p);
	else
		pgetc(p);

	if (p->byte == bw->cursor->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete from cursor to beginning of word it's in or immediately after,
 * to start of whitespace, or a single character
 */

int ubackw(BW *bw)
{
	P *p = pdup(bw->cursor);
	int c = prgetc(bw->cursor);
	struct charmap *map=bw->b->o.charmap;

	if (joe_isalnux(map,c)) {
		while (joe_isalnux(map,(c = prgetc(bw->cursor))))
			/* do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(bw->cursor);
	} else if (joe_isspace(map,c)) {
		while (joe_isspace(map,(c = prgetc(bw->cursor))))
			/* do nothing */;
		if (c != NO_MORE_DATA)
			pgetc(bw->cursor);
	}
	if (bw->cursor->byte == p->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete from cursor to end of line, or if there's nothing to delete,
 * delete the line-break
 */

int udelel(BW *bw)
{
	P *p = p_goto_eol(pdup(bw->cursor));

	if (bw->cursor->byte == p->byte) {
		prm(p);
		return udelch(bw);
	} else
		bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Delete to beginning of line, or if there's nothing to delete,
 * delete the line-break
 */

int udelbl(BW *bw)
{
	P *p = p_goto_bol(pdup(bw->cursor));

	if (p->byte == bw->cursor->byte) {
		prm(p);
		return ubacks(bw, 8);	/* The 8 goes to the process if we're at EOF of shell window */
	} else
		bdel(p, bw->cursor);
	prm(p);
	return 0;
}

/* Delete entire line */

int udelln(BW *bw)
{
	P *p = pdup(bw->cursor);

	p_goto_bol(bw->cursor);
	pnextl(p);
	if (bw->cursor->byte == p->byte) {
		prm(p);
		return -1;
	}
	bdel(bw->cursor, p);
	prm(p);
	return 0;
}

/* Insert a space */

int uinsc(BW *bw)
{
	binsc(bw->cursor, ' ');
	return 0;
}

/* Move p backwards to first non-blank line and return its indentation */

static int
find_indent(P *p)
{
	int x;
	for (x=0; x != 10; ++x) {
		if (!pprevl(p)) return -1;
		p_goto_bol(p);
		if (!pisblank(p)) break;
	}
	if (x==10)
		return -1;
	else
		return pisindent(p);
}

/* Type a character into the buffer (deal with left margin, overtype mode and
 * word-wrap), if cursor is at end of shell window buffer, just send character
 * to process.
 */

struct utf8_sm utype_utf8_sm;

int utypebw_raw(BW *bw, int k, int no_decode)
{
	struct charmap *map=bw->b->o.charmap;

	/* Hex mode overtype is real simple */
	if (bw->o.hex && bw->o.overtype) {
		P *p;
		unsigned char c = k;
		binsm(bw->cursor, &c, 1);
		pgetb(bw->cursor);
		if (piseof(bw->cursor))
			return 0;
		pgetb(p = pdup(bw->cursor));
		bdel(bw->cursor, p);
		prm(p);
		return 0;
	}

	if (k == '\t' && bw->o.overtype && !piseol(bw->cursor)) { /* TAB in overtype mode is supposed to be just cursor motion */
		int col = bw->cursor->xcol;		/* Current cursor column */
		col = col + bw->o.tab - (col%bw->o.tab);/* Move to next tab stop */
		pcol(bw->cursor,col);			/* Try to position cursor there */
		if (!bw->o.picture && piseol(bw->cursor) && piscol(bw->cursor)<col) {	/* We moved past end of line, insert a tab (unless in picture mode) */
			if (bw->o.spaces)
				pfill(bw->cursor,col,' ');
			else
				pfill(bw->cursor,col,'\t');
		}
		bw->cursor->xcol = col;			/* Put cursor there even if we can't really go there */
	} else if (k == '\t' && bw->o.smartbacks && bw->o.autoindent && pisindent(bw->cursor)>=piscol(bw->cursor)) {
		P *p = pdup(bw->cursor);
		int n = find_indent(p);
		if (n != -1 && pisindent(bw->cursor)==piscol(bw->cursor) && n > pisindent(bw->cursor)) {
			if (!pisbol(bw->cursor))
				udelbl(bw);
			while (joe_isspace(map,(k = pgetc(p))) && k != '\n') {
				binsc(bw->cursor, k);
				pgetc(bw->cursor);
			}
		} else {
			int x;
			for (x=0;x<bw->o.istep;++x) {
				binsc(bw->cursor,bw->o.indentc);
				pgetc(bw->cursor);
			}
		}
		bw->cursor->xcol = piscol(bw->cursor);
		prm (p);
	} else if (k == '\t' && bw->o.spaces) {
		long n;

		if (bw->o.picture)
			n = bw->cursor->xcol;
		else
			n = piscol(bw->cursor);

		utype_utf8_sm.state = 0;
		utype_utf8_sm.ptr = 0;

		n = bw->o.tab - n % bw->o.tab;
		while (n--)
			utypebw_raw(bw, ' ', 0);
	} else {
		int simple;
		int x;

		/* Picture mode */
		if (bw->o.picture && bw->cursor->xcol!=piscol(bw->cursor))
			pfill(bw->cursor,bw->cursor->xcol,' '); /* Why no tabs? */

		/* UTF8 decoder */
		if(locale_map->type && !no_decode) {
			int utf8_char = utf8_decode(&utype_utf8_sm,k);

			if(utf8_char >= 0)
				k = utf8_char;
			else
				return 0;
		}

		simple = 1;

		if (pisblank(bw->cursor))
			while (piscol(bw->cursor) < bw->o.lmargin) {
				binsc(bw->cursor, ' ');
				pgetc(bw->cursor);
			}

		if (no_decode == 2) {
			unsigned char ch = k;

			binsm(bw->cursor, &ch, 1);
			if (!bw->b->o.charmap->type)
				no_decode = 1;
		} else {
			if (!no_decode) {
				if(locale_map->type && !bw->b->o.charmap->type) {
					unsigned char buf[10];
					utf8_encode(buf,k);
					k = from_utf8(bw->b->o.charmap,buf);
				} else if(!locale_map->type && bw->b->o.charmap->type) {
					unsigned char buf[10];
					to_utf8(locale_map,buf,k);
					k = utf8_decode_string(buf);
				}
			}

			binsc(bw->cursor, k);
		}

		/* We need x position before we move cursor */
		x = piscol(bw->cursor) - bw->offset;
		pgetc(bw->cursor);

		/* Tabs are weird here... */
		if (bw->o.overtype && !piseol(bw->cursor) && k != '\t')
			udelch(bw);

		/* Not sure if we're in right position for wordwrap when we're in overtype mode */
		if (bw->o.wordwrap && piscol(bw->cursor) > bw->o.rmargin && !joe_isblank(map,k)) {
			wrapword(bw->cursor, (long) bw->o.lmargin, bw->o.french, NULL);
			simple = 0;
		}

		bw->cursor->xcol = piscol(bw->cursor);
		if (x < 0 || x >= bw->w)
			simple = 0;
		if (bw->cursor->line < bw->top->line || bw->cursor->line >= bw->top->line + bw->h)
			simple = 0;
		if (simple && bw->parent->t->t->sary[bw->y + bw->cursor->line - bw->top->line])
			simple = 0;
		else if (simple)
			switch (k) {
			case ' ':
				if (bw->o.vispace)
					/* FALLTHROUGH */
			case '\t':
			case '\n':
				  simple = 0;
				break;
			}
		if (simple && !curmacro) {
			int atr = 0;
			SCRN *t = bw->parent->t->t;
			int y = bw->y + bw->cursor->line - bw->top->line;
			int *screen = t->scrn + y * t->co;
			int *attr = t->attr + y * t->co;
			x += bw->x;

			if (!bw->parent->t->t->updtab[bw->y + bw->cursor->line - bw->top->line] &&
			    piseol(bw->cursor) && !bw->o.highlight)
				t->updtab[y] = 0;
			if (markb &&
			    markk &&
			    markb->b == bw->b &&
			    markk->b == bw->b &&
			   ((!square && bw->cursor->byte >= markb->byte && bw->cursor->byte < markk->byte) ||
			    ( square && bw->cursor->line >= markb->line && bw->cursor->line <= markk->line && piscol(bw->cursor) >= markb->xcol && piscol(bw->cursor) < markk->xcol)))
				atr = INVERSE;
			outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, no_decode == 2 ? 0xFFFD : k, atr);
		}
	}
	return 0;
}

int utypebw(jobject jO, int k)
{
	return utypebw_raw(jO.bw, k, 0);
}

/* Quoting */

static B *unicodehist = NULL;	/* History of previously entered UCS characters */

static int dounicode(BW *bw, unsigned char *s, void *object, int *notify)
{
	int num;

	num = ustolb(s, NULL, 0, 0x10FFFF, USTOL_HEX | USTOL_TRIM | USTOL_EOS);
	if (notify)
		*notify = 1;
	vsrm(s);
	if (bw->b->o.charmap->type)
		utypebw_raw(bw, num, 1);
	else {
		unsigned char buf[8];
		int x;

		utf8_encode(buf,num);
		for(x=0;buf[x];++x)
			utypebw_raw(bw, buf[x], 1);
	}
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

static void
doquote0(BW *bw, int c, int meta)
{
	if (c == '?')
		c = 127;
	else if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
		c &= 0x1F;
	c |= meta;
	utypebw_raw(bw, c, 1);
	bw->cursor->xcol = piscol(bw->cursor);
}

int quotestate;
int quoteval;

static int
doquote(BW *bw, int c, void *object, int *notify)
{
	unsigned char buf[40];

	if (c < 0 || c >= 256) {
		nungetc(c);
		return -1;
	}
	switch (quotestate) {
	case 0:
		if (c >= '0' && c <= '9') {
			quoteval = c - '0';
			quotestate = 1;
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII %c--", c);
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		} else if ((c | 0x20) == 'u') {
			if (bw->b->o.charmap->type)
				goto unopoo;
 uhex_uni:
			if (!wmkpw(bw->parent, UC "UCS (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
				   NULL, NULL, NULL, NULL, NULL, locale_map))
				return 0;
			else
				return -1;
		} else if ((c | 0x20) == 'r') {
			if (!bw->b->o.charmap->type)
				goto unopoo;
 uhex_raw:
			quotestate = 3;
			if (!mkqwna(bw->parent, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		} else if ((c | 0x20) == 'x') {
			if (bw->b->o.charmap->type)
				goto uhex_uni;
			else
				goto uhex_raw;
		} else if ((c | 0x20) == 'o') {
			quotestate = 5;
			if (!mkqwna(bw->parent, sc("ASCII 0---"), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		} else {
 unopoo:
			doquote0(bw, c, 0);
		}
		break;
	case 1:
		if (c >= '0' && c <= '9') {
			joe_snprintf_2((char *)buf, sizeof(buf), "ASCII %c%c-", quoteval + '0', c);
			quoteval = quoteval * 10 + c - '0';
			quotestate = 2;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		}
		break;
	case 2:
		if (c >= '0' && c <= '9') {
			quoteval = quoteval * 10 + c - '0';
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	case 3:
		if (c >= '0' && c <= '9') {
			quoteval = c - '0';
 uhex_3:
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
			quotestate = 4;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		}
		c &= ~0x20;
		if (c >= 'A' && c <= 'F') {
			quoteval = c - 'A' + 10;
			goto uhex_3;
		}
		break;
	case 4:
		if (c >= '0' && c <= '9') {
			quoteval = quoteval * 16 + c - '0';
 u4out:
			utypebw_raw(bw, quoteval, 2);
			bw->cursor->xcol = piscol(bw->cursor);
		} else if (c >= 'a' && c <= 'f') {
			quoteval = quoteval * 16 + c - 'a' + 10;
			goto u4out;
		} else if (c >= 'A' && c <= 'F') {
			quoteval = quoteval * 16 + c - 'A' + 10;
			goto u4out;
		}
		break;
	case 5:
		if (c >= '0' && c <= '7') {
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0%c--", c);
			quoteval = c - '0';
			quotestate = 6;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		}
		break;
	case 6:
		if (c >= '0' && c <= '7') {
			joe_snprintf_2((char *)buf, sizeof(buf), "ASCII 0%c%c-", quoteval + '0', c);
			quoteval = quoteval * 8 + c - '0';
			quotestate = 7;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		}
		break;
	case 7:
		if (c >= '0' && c <= '7') {
			quoteval = quoteval * 8 + c - '0';
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
		}
		break;
	}
	if (notify)
		*notify = 1;
	return 0;
}

static char uquote_txt[] =
    "Ctrl- (or 0-9 for dec. o for octal, x hex, u UCS)";
int
uquote(BW *bw)
{
	quotestate = 0;
	if (bw->b->o.charmap->type) {
		uquote_txt[36] = 'r';
		uquote_txt[43] = 'x';
	} else {
		uquote_txt[36] = 'x';
		uquote_txt[43] = 'u';
	}
	return (mkqwna(bw->parent, sc(uquote_txt),
	    doquote, NULL, NULL, NULL) ? 0 : -1);
}

static int doquote9(BW *bw, int c, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	doquote0(bw, c, 128);
	return 0;
}

static int doquote8(BW *bw, int c, void *object, int *notify)
{
	if (c == '`') {
		if (mkqwna(bw->parent, sc("Meta-Ctrl-"), doquote9, NULL, NULL, notify))
			return 0;
		else
			return -1;
	}
	if (notify)
		*notify = 1;
	c |= 128;
	utypebw_raw(bw, c, 1);
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

int uquote8(BW *bw)
{
	if (mkqwna(bw->parent, sc("Meta-"), doquote8, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

extern const unsigned char srchstr[];

static int doctrl(BW *bw, int c, void *object, int *notify)
{
	int org = bw->o.overtype;

	if (notify)
		*notify = 1;
	bw->o.overtype = 0;
	if (bw->parent->huh == srchstr && c == '\n') {
		utypebw_raw(bw, '\\', 0);
		utypebw_raw(bw, 'n', 0);
	} else
		utypebw_raw(bw, c, 1);
	bw->o.overtype = org;
	bw->cursor->xcol = piscol(bw->cursor);
	return 0;
}

int uctrl(BW *bw)
{
	if (mkqwna(bw->parent, sc("Quote"), doctrl, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

/* User hit Return.  Deal with autoindent.
 */

int rtntw(jobject jO)
{
	BW *bw = jO.bw;

	if (bw->o.overtype) {
		p_goto_eol(bw->cursor);
		if (piseof(bw->cursor))
			binsc(bw->cursor, '\n');
		pgetc(bw->cursor);
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		P *p = pdup(bw->cursor);
		unsigned char c;

		binsc(bw->cursor, '\n'), pgetc(bw->cursor);
		/* Suppress autoindent if we're on a space or tab... */
		if (bw->o.autoindent && (brch(bw->cursor)!=' ' && brch(bw->cursor)!='\t')) {
			p_goto_bol(p);
			while (joe_isspace(bw->b->o.charmap,(c = pgetc(p))) && c != '\n') {
				binsc(bw->cursor, c);
				pgetc(bw->cursor);
			}
		}
		prm(p);
		bw->cursor->xcol = piscol(bw->cursor);
	}
	return 0;
}

/* Open a line */

int uopen(BW *bw)
{
	binsc(bw->cursor,'\n');
	return 0;
}

/* Set book-mark */

static int dosetmark(BW *bw, int c, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (c >= '0' && c <= ':') {
		pdupown(bw->cursor, bw->b->marks + c - '0');
		poffline(bw->b->marks[c - '0']);
		if (c!=':') {
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d set", c - '0');
			msgnw(bw->parent, msgbuf);
		}
		return 0;
	} else {
		nungetc(c);
		return -1;
	}
}

int usetmark(BW *bw, int c)
{
	if (c >= '0' && c <= ':')
		return dosetmark(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sc("Set mark (0-9):"), dosetmark, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

/* Goto book-mark */

static int dogomark(BW *bw, int c, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if (c >= '0' && c <= ':')
		if (bw->b->marks[c - '0']) {
			pset(bw->cursor, bw->b->marks[c - '0']);
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		} else {
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "Mark %d not set", c - '0');
			msgnw(bw->parent, msgbuf);
			return -1;
	} else {
		nungetc(c);
		return -1;
	}
}

int ugomark(BW *bw, int c)
{
	if (c >= '0' && c <= '9')
		return dogomark(bw, c, NULL, NULL);
	else if (mkqwna(bw->parent, sc("Goto bookmark (0-9):"), dogomark, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

/* Goto next instance of character */

static int dobkwdc;

static int dofwrdc(BW *bw, int k, void *object, int *notify)
{
	int c;
	P *q;

	if (notify)
		*notify = 1;
	if (k < 0 || k >= 256) {
		nungetc(k);
		return -1;
	}
	q = pdup(bw->cursor);
	if (dobkwdc) {
		while ((c = prgetc(q)) != NO_MORE_DATA)
			if (c == k)
				break;
	} else {
		while ((c = pgetc(q)) != NO_MORE_DATA)
			if (c == k)
				break;
	}
	if (c == NO_MORE_DATA) {
		msgnw(bw->parent, UC "Not found");
		prm(q);
		return -1;
	} else {
		pset(bw->cursor, q);
		bw->cursor->xcol = piscol(bw->cursor);
		prm(q);
		return 0;
	}
}

int ufwrdc(BW *bw, int k)
{
	dobkwdc = 0;
	if (k >= 0 && k < 256)
		return dofwrdc(bw, k, NULL, NULL);
	else if (mkqw(bw->parent, sc("Fwrd to char: "), dofwrdc, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

int ubkwdc(BW *bw, int k)
{
	dobkwdc = 1;
	if (k >= 0 && k < 256)
		return dofwrdc(bw, k, NULL, NULL);
	else if (mkqw(bw->parent, sc("Bkwd to char: "), dofwrdc, NULL, NULL, NULL))
		return 0;
	else
		return -1;
}

/* Display a message */

static int domsg(BASE *b, unsigned char *s, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	strlcpy((char *)msgbuf, (char *)s, JOE_MSGBUFSIZE);
	vsrm(s);
	msgnw(b->parent, *msgbuf ? msgbuf : NULL);
	return 0;
}

int umsg(BASE *b)
{
	if (wmkpw(b->parent, UC "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL, locale_map))
		return 0;
	else
		return -1;
}

/* Insert text */

static int dotxt(BW *bw, unsigned char *s, void *object, int *notify)
{
	int x;

	if (notify)
		*notify = 1;
	for (x = 0; x != sLEN(s); ++x)
		utypebw_raw(bw, s[x], 0);
	vsrm(s);
	return 0;
}

int utxt(BW *bw)
{
	if (wmkpw(bw->parent, UC "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.charmap))
		return 0;
	else
		return -1;
}
@


1.35
log
@shorten too long query prompt (target is <75% of window width)
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.34 2018/02/14 22:28:12 tg Exp $");
d1169 1
a1169 1
static B *unicodehist = NULL;	/* History of previously entered unicode characters */
d1231 1
a1231 1
			if (!wmkpw(bw->parent, UC "Unicode (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
d1346 1
a1346 1
    "Ctrl- (or 0-9 for dec. o for octal, x hex, u Unicode)";
@


1.34
log
@ok, let’s take the time to fix another bug that suddenly appeared
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.33 2018/01/06 00:28:34 tg Exp $");
d1346 1
a1346 1
    "Ctrl- (or 0-9 for dec. x for hex, o for octal ASCII, u for hex UTF-8)";
d1352 2
a1353 2
		uquote_txt[23] = 'r';
		uquote_txt[53] = 'x';
d1355 2
a1356 2
		uquote_txt[23] = 'x';
		uquote_txt[53] = 'u';
@


1.33
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.32 2017/12/26 23:26:57 tg Exp $");
d1345 1
a1345 3
static const char uquote_txt_uni[] =
    "Ctrl- (or 0-9 for dec. r for hex, o for octal ASCII, x for hex UTF-8)";
static const char uquote_txt_oct[] =
d1351 8
a1358 2
	return (mkqwna(bw->parent,
	    sc(bw->b->o.charmap->type ? uquote_txt_uni : uquote_txt_oct),
@


1.32
log
@{to,rv}match: allow *any* char to match (next of same in given dir)

only makes sense for jupp since we have rvmatch here, not for joe
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.31 2017/12/16 22:10:55 tg Exp $");
d1193 12
d1208 2
a1209 1
static int doquote(BW *bw, int c, void *object, int *notify)
d1258 1
a1258 6
			if ((c & ~0x20) >= 0x40 && (c & ~0x20) <= 0x5F)
				c &= 0x1F;
			if (c == '?')
				c = 127;
			utypebw_raw(bw, c, 1);
			bw->cursor->xcol = piscol(bw->cursor);
d1345 6
a1350 1
int uquote(BW *bw)
a1351 6
	const char *qs;

	if (bw->b->o.charmap->type)
		qs = "Ctrl- (or 0-9 for dec. r for hex, o for octal ASCII, x for hex UTF-8)";
	else
		qs = "Ctrl- (or 0-9 for dec. x for hex, o for octal ASCII, u for hex UTF-8)";
d1353 3
a1355 4
	if (mkqwna(bw->parent, US qs, strlen(qs), doquote, NULL, NULL, NULL))
		return 0;
	else
		return -1;
d1362 1
a1362 7
	if ((c & ~0x20) >= 0x40 && (c & ~0x20) <= 0x5F)
		c &= 0x1F;
	if (c == '?')
		c = 127;
	c |= 128;
	utypebw_raw(bw, c, 1);
	bw->cursor->xcol = piscol(bw->cursor);
@


1.31
log
@more casing tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.28 2017/12/07 02:10:18 tg Exp $");
d331 1
a331 1
	switch (c = brch(bw->cursor)) {
a363 7
	case '"':
	case '\'':
	case '`':
		f = c;
		break;
	default:
		return -1;
@


1.30
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@d1252 1
a1252 1
			if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
d1280 2
a1282 1
			quoteval = c - '0';
d1288 3
a1290 10
		} else if (c >= 'a' && c <= 'f') {
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c + 'A' - 'a');
			quoteval = c - 'a' + 10;
			quotestate = 4;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
		} else if (c >= 'A' && c <= 'F') {
			joe_snprintf_1((char *)buf, sizeof(buf), "ASCII 0x%c-", c);
d1292 1
a1292 5
			quotestate = 4;
			if (!mkqwna(bw->parent, sz(buf), doquote, NULL, NULL, notify))
				return -1;
			else
				return 0;
d1363 1
a1363 1
	if ((c >= 0x40 && c <= 0x5F) || (c >= 'a' && c <= 'z'))
@


1.29
log
@more small tweaks
@
text
@d1221 1
a1221 1
		} else if (c == 'u' || c == 'U') {
d1230 1
a1230 1
		} else if (c == 'r' || c == 'R') {
d1239 1
a1239 1
		} else if (c == 'x' || c == 'X') {
d1244 1
a1244 1
		} else if (c == 'o' || c == 'O') {
@


1.28
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.27 2017/12/06 23:58:38 tg Exp $");
d1226 1
a1226 1
			           NULL, NULL, NULL, NULL, NULL, locale_map))
@


1.27
log
@make wmkpw const again
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.24 2017/12/06 21:41:03 tg Exp $");
d609 1
a609 1
	bw = (BW *) bw->parent->main->object;
d625 1
a625 1
	bw = (BW *) bw->parent->main->object;
d641 1
a641 1
	bw = (BW *) bw->parent->main->object;
d653 1
a653 1
	bw = (BW *) bw->parent->main->object;
d1169 1
a1169 1
int utypebw(BW *bw, int k)
d1171 1
a1171 1
	return utypebw_raw(bw, k, 0);
d1417 2
a1418 2
		utypebw(bw, '\\');
		utypebw(bw, 'n');
d1437 1
a1437 1
int rtntw(BW *bw)
d1439 2
d1623 1
a1623 1
		utypebw(bw, s[x]);
@


1.26
log
@inline a variable dereference to not trigger during macro execution:
this prevents a segfault on “Esc - eof," " Return” on a file longer
than the screen, or on the new ^K] on it… and the value was only used
outside of macro execution in the first place already ANYWAY…
@
text
@d695 1
a695 1
	if (wmkpw(bw->parent, US "Go to line (^C to abort): ", &linehist, doline, NULL, NULL, NULL, NULL, NULL, locale_map))
d731 1
a731 1
	if (wmkpw(bw->parent, US "Go to column (^C to abort): ", &colhist, docol, NULL, NULL, NULL, NULL, NULL, locale_map))
d767 1
a767 1
	if (wmkpw(bw->parent, US "Go to byte (^C to abort): ", &bytehist, dobyte, NULL, NULL, NULL, NULL, NULL, locale_map))
d1225 1
a1225 1
			if (!wmkpw(bw->parent, US "Unicode (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
d1606 1
a1606 1
	if (wmkpw(b->parent, US "Msg (^C to abort): ", NULL, domsg, NULL, NULL, NULL, NULL, NULL, locale_map))
d1628 1
a1628 1
	if (wmkpw(bw->parent, US "Insert (^C to abort): ", NULL, dotxt, NULL, NULL, utypebw, NULL, NULL, bw->b->o.charmap))
@


1.25
log
@lots of fixes related to prototyping
@
text
@a1066 1
		int upd;
a1083 1
		upd = bw->parent->t->t->updtab[bw->y + bw->cursor->line - bw->top->line];
d1153 2
a1154 1
			if (!upd && piseol(bw->cursor) && !bw->o.highlight)
@


1.24
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.22 2017/12/04 21:53:34 tg Exp $");
d27 1
d982 2
a983 1
int find_indent(P *p)
@


1.23
log
@clean up some unused/MS-DOS® stuff
@
text
@d687 1
a687 1
			msgnw(bw->parent, US "Invalid line number");
d723 1
a723 1
			msgnw(bw->parent, US "Invalid column number");
d759 1
a759 1
			msgnw(bw->parent, US "Invalid byte number");
d1558 1
a1558 1
		msgnw(bw->parent, US "Not found");
@


1.22
log
@rename alpha_ to alphx and alnum_ to alnux

• matches mksh
• stuff with trailing underscore may not be allowed in C99
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/uedit.c,v 1.19 2017/12/02 02:07:34 tg Exp $");
a1128 1
#ifndef __MSDOS__
a1163 1
#endif
@


1.21
log
@first cut at getting rid of stdio: scanf half
@
text
@d194 2
a195 2
	if (joe_isalnum_(map,c)) {
		while (joe_isalnum_(map,(c=prgetc(p))))
d202 1
a202 1
		while(joe_isalnum_(map,(c=prgetc(p))))
d231 1
a231 1
	if (joe_isalnum_(map,c)) {
d233 1
a233 1
		while (joe_isalnum_(map,(c = brch(p))))
d238 1
a238 1
		while (joe_isalnum_(map,(c = brch(p)))) {
d872 2
a873 2
	if (joe_isalnum_(map,c))
		while (joe_isalnum_(map,(c = brch(p))))
d900 2
a901 2
	if (joe_isalnum_(map,c)) {
		while (joe_isalnum_(map,(c = prgetc(bw->cursor))))
@


1.20
log
@some fallout of the includes changes, some more reduction
@
text
@d1183 1
a1183 1
	sscanf((char *)s,"%x",&num);
@


1.19
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a30 1
#include "utf8.h"
@


1.18
log
@add a level of indirection: never use math’s calc() outside of umath

in the places where we used it, we now have calcl() which takes the
same arguments, evaluates its second parameter (in the context BW of
the first), but returns it as long; calcldec() subtracts 1.0 first

this confines all floating point operations into umath.?
@
text
@a0 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.17 2017/03/19 19:19:51 tg Exp $ */
d11 2
a12 1
#include <stdio.h>
@


1.17
log
@_some_ type cleanup (time_t, sig_atomic_t)

still unsafe signal handler crap abound :(
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.10 2013/08/19 19:19:31 tg Exp $ */
d669 1
a669 1
	long num = calc(bw, s);
d707 1
a707 1
	long num = calc(bw, s);
d743 1
a743 1
	long num = calc(bw, s);
@


1.16
log
@include <string.h> before <bsd/string.h> to avoid problems on Haiku
@
text
@d674 1
a674 1
	if (num >= 1 && !merr) {
d685 2
a686 2
		if (merr)
			msgnw(bw->parent, merr);
d712 1
a712 1
	if (num >= 1 && !merr) {
d721 2
a722 2
		if (merr)
			msgnw(bw->parent, merr);
d748 1
a748 1
	if (num >= 0 && !merr) {
d757 2
a758 2
		if (merr)
			msgnw(bw->parent, merr);
@


1.15
log
@constify “huh” (… huh‽)
@
text
@d13 1
@


1.14
log
@make this actually work
@
text
@d1408 1
a1408 1
extern unsigned char srchstr[];
@


1.13
log
@add rvmatch, same as tomatch but ambiguous go left
@
text
@d40 1
a40 1
/* 
d68 1
a68 1
		if ((bw->o.smarthome) && (piscol(p) > pisindent(p))) { 
d183 1
a183 1
 * Move cursor to beginning of previous word or if there isn't 
d219 1
a219 1
 * Move cursor to end of next word or if there isn't 
d327 2
a358 4
	case '\'':
		f = '`';
		dir = -1;
		break;
d372 1
a373 3
		P *p = pdup(bw->cursor);
		int cnt = 0;	/* No. levels of delimiters we're in */

d375 4
a378 1
			if (d == c)
d380 2
a381 4
			else if (d == f && !--cnt) {
				prgetc(p);
				pset(bw->cursor, p);
				break;
a383 1
		prm(p);
a384 3
		P *p = pdup(bw->cursor);
		int cnt = 0;	/* No. levels of delimiters we're in */

d386 3
a388 1
			if (d == c)
a389 5
			else if (d == f)
				if (!cnt--) {
					pset(bw->cursor, p);
					break;
				}
a390 1
		prm(p);
d392 6
a397 4
	if (d == NO_MORE_DATA)
		return -1;
	else
		return 0;
d821 1
a821 1
		
d859 1
a859 1
/* 
d1110 1
a1110 1
			
@


1.12
log
@fix ^Q] for ', " and, while here, `
@
text
@d321 2
a322 1
int utomatch(BW *bw)
d325 2
a326 3
	int c,			/* Character under cursor */
	 f,			/* Character to find */
	 dir;			/* 1 to search forward, -1 to search backward */
a368 1
		dir = 1;
d409 10
@


1.11
log
@Update “visible spaces” while typing and fix it for nōn-UTF8 files; also rid some of the assumptions that all charmaps have tab, space at same positions
@
text
@a340 4
	case '`':
		f = '\'';
		dir = 1;
		break;
d365 6
@


1.10
log
@• “msg” editoe command with empty argument clears message
• add “nop” editor command
• permit changing keymap for prompt windows
• fix CUA keymap paste mode
• handle bracketed pasting for prompt windows
• ^L is now “nop” (i.e. redraw) for prompt windows (paste and normal)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.9 2009/10/18 16:02:02 tg Exp $ */
d1134 11
a1144 1
		if (simple && k != '\t' && k != '\n' && !curmacro) {
@


1.9
log
@implement `r## (in utf-8 mode) and `u (in non-utf8 mode)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.8 2009/10/18 14:52:58 tg Exp $ */
d1589 1
a1589 1
	msgnw(b->parent, msgbuf);
@


1.8
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.7 2009/10/18 13:20:55 tg Exp $ */
d1090 17
a1106 9
		if (!no_decode) {
			if(locale_map->type && !bw->b->o.charmap->type) {
				unsigned char buf[10];
				utf8_encode(buf,k);
				k = from_utf8(bw->b->o.charmap,buf);
			} else if(!locale_map->type && bw->b->o.charmap->type) {
				unsigned char buf[10];
				to_utf8(locale_map,buf,k);
				k = utf8_decode_string(buf);
d1108 2
a1110 2
		
		binsc(bw->cursor, k);
d1151 1
a1151 1
			outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, k, atr);
d1175 10
a1184 1
	utypebw_raw(bw, num, 1);
d1210 18
d1229 4
a1232 13
			if (bw->b->o.charmap->type) {
				if (!wmkpw(bw->parent, US "Unicode (ISO-10646) character in hex (^C to abort): ", &unicodehist, dounicode,
				           NULL, NULL, NULL, NULL, NULL, locale_map))
					return 0;
				else
					return -1;
			} else {
				quotestate = 3;
				if (!mkqwna(bw->parent, sc("ASCII 0x--"), doquote, NULL, NULL, notify))
					return -1;
				else
					return 0;
			}
d1240 1
d1297 2
a1298 1
			utypebw_raw(bw, quoteval, 1);
d1302 1
a1302 2
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
d1305 1
a1305 2
			utypebw_raw(bw, quoteval, 1);
			bw->cursor->xcol = piscol(bw->cursor);
d1345 6
d1352 1
a1352 1
	if (mkqwna(bw->parent, sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"), doquote, NULL, NULL, NULL))
@


1.7
log
@fix (by backporting) insertion (`xFF) of hi-bit7 characters in c or latin1
mode when the current locale is UTF-8; discovered by waga, thanks!
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.6 2009/10/06 09:07:31 tg Exp $ */
d45 5
a49 1
	p_goto_bol(bw->cursor);
d59 7
a65 1
	P *p = pdup(bw->cursor);
d92 7
a98 1
	p_goto_eol(bw->cursor);
d125 7
d156 7
d412 8
d432 11
d497 19
a515 13
	if (bw->top->line >= n)
		scrollamnt = cursoramnt = n;
	else if (bw->top->line)
		scrollamnt = cursoramnt = bw->top->line;
	else if (flg)
		cursoramnt = bw->cursor->line;
	else if (bw->cursor->line >= n)
		cursoramnt = n;

	/* Move top-of-window pointer */
	for (x = 0; x != scrollamnt; ++x)
		pprevl(bw->top);
	p_goto_bol(bw->top);
d517 19
a535 5
	/* Move cursor */
	for (x = 0; x != cursoramnt; ++x)
		pprevl(bw->cursor);
	p_goto_bol(bw->cursor);
	pcol(bw->cursor, bw->cursor->xcol);
d537 4
a540 3
	/* If window is on the screen, give (buffered) scrolling command */
	if (bw->parent->y != -1)
		nscrldn(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d558 19
a576 8
	if (bw->top->b->eof->line < bw->top->line + bw->h) {
		cursoramnt = bw->top->b->eof->line - bw->cursor->line;
		if (!flg && cursoramnt > n)
			cursoramnt = n;
	} else if (bw->top->b->eof->line - (bw->top->line + bw->h) >= n)
		cursoramnt = scrollamnt = n;
	else
		cursoramnt = scrollamnt = bw->top->b->eof->line - (bw->top->line + bw->h) + 1;
d578 17
a594 3
	/* Move top-of-window pointer */
	for (x = 0; x != scrollamnt; ++x)
		pnextl(bw->top);
d596 4
a599 8
	/* Move cursor */
	for (x = 0; x != cursoramnt; ++x)
		pnextl(bw->cursor);
	pcol(bw->cursor, bw->cursor->xcol);

	/* If window is on screen, give (buffered) scrolling command to terminal */
	if (bw->parent->y != -1)
		nscrlup(bw->parent->t->t, bw->y, bw->y + bw->h, scrollamnt);
d607 1
a607 1
	if (!bw->cursor->line)
d623 1
a623 1
	if (bw->cursor->line == bw->b->eof->line)
d639 2
a640 2
	if (bw->top->line) {
		if (bw->top->line + bw->h - 1 != bw->cursor->line)
d651 2
a652 2
	if (bw->top->line + bw->h <= bw->top->b->eof->line) {
		if (bw->top->line != bw->cursor->line)
d1003 15
@


1.6
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.5 2008/08/21 12:45:33 tg Exp $ */
d909 1
a909 1
int utypebw(BW *bw, int k)
d955 1
a955 1
			utypebw(bw, ' ');
d966 1
a966 1
		if(locale_map->type) {
d984 10
a993 8
		if(locale_map->type && !bw->b->o.charmap->type) {
			unsigned char buf[10];
			utf8_encode(buf,k);
			k = from_utf8(bw->b->o.charmap,buf);
		} else if(!locale_map->type && bw->b->o.charmap->type) {
			unsigned char buf[10];
			to_utf8(locale_map,buf,k);
			k = utf8_decode_string(buf);
d1044 5
d1056 1
a1056 2
	unsigned char buf[8];
	int x;
d1061 1
a1061 3
	utf8_encode(buf,num);
	for(x=0;buf[x];++x)
		utypebw(bw, buf[x]);
d1112 1
a1112 1
			utypebw(bw, c);
d1130 1
a1130 1
			utypebw(bw, quoteval);
d1164 1
a1164 1
			utypebw(bw, quoteval);
d1168 1
a1168 1
			utypebw(bw, quoteval);
d1172 1
a1172 1
			utypebw(bw, quoteval);
d1201 1
a1201 1
			utypebw(bw, quoteval);
d1229 1
a1229 1
	utypebw(bw, c);
d1245 1
a1245 1
	utypebw(bw, c);
d1271 1
a1271 1
		utypebw(bw, c);
@


1.5
log
@-smartbacks does not depend on -autoindent (or should)

needed for python code with their snakey coding standards
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/uedit.c,v 1.4 2008/05/13 13:08:27 tg Exp $ */
d14 4
@


1.4
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d726 1
a726 1
		if (col == indent && (col%indwid)==0 && col!=0 && bw->o.smartbacks && bw->o.autoindent) {
d737 1
a737 1
		} else if (col<indent && !pisbol(bw->cursor) && bw->o.smartbacks && bw->o.autoindent) {
@


1.3
log
@maybe fix that "backspace deletes more if it should even if I have
autoindentation and smart backspace off" stuff (see diff for details)
@
text
@d1 1
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d736 1
a736 1
		} else if (col<indent && !pisbol(bw->cursor)) {
@


1.1
log
@Initial revision
@
text
@a117 2
		} else {
			return -1;
d120 1
a695 1
		P *p;
a700 1
		int pure = 1;
a726 1
			int x;
d911 1
a911 1
		if (!bw->o.picture && piseol(bw->cursor) && piscol(bw->cursor)<col)	/* We moved past end of line, insert a tab (unless in picture mode) */
d916 1
a1013 1
			int a;
a1014 1
			unsigned char c = k;
d1440 1
a1440 1
	strcpy((char *)msgbuf, (char *)s);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Basic user edit functions
   Copyright (C) 1992 Joseph H. Allen
d11 1
a11 1
This file is part of JOE (Joe's Own Editor)
a12 14
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include "config.h"
d15 2
a16 2
#include "scrn.h"
#include "w.h"
d19 2
a20 2
#include "zstr.h"
#include "vs.h"
d23 5
a27 5
#include "ublock.h"
#include "tw.h"
#include "macro.h"
#include "main.h"
#include "uedit.h"
d29 1
d31 1
d33 1
a33 1
int pgamnt= -1;				/* No. of PgUp/PgDn lines to keep */
d35 36
a70 1
/* Move cursor to beginning of line */
d72 212
a283 156
int ubol(bw)
BW *bw;
 {
 pbol(bw->cursor);
 return 0;
 }

/* Move cursor to end of line */

int ueol(bw)
BW *bw;
 {
 peol(bw->cursor);
 return 0;
 }

/* Move cursor to beginning of file */

int ubof(bw)
BW *bw;
 {
 pbof(bw->cursor);
 return 0;
 }

/* Move cursor to end of file */

int ueof(bw)
BW *bw;
 {
 peof(bw->cursor);
 return 0;
 }

/* Move cursor left */

int ultarw(bw)
BW *bw;
 {
 if(prgetc(bw->cursor)!=MAXINT) return 0;
 else return -1;
 }

/* Move cursor right */

int urtarw(bw)
BW *bw;
 {
 if(pgetc(bw->cursor)!=MAXINT) return 0;
 else return -1;
 }

/* Move cursor to beginning of previous word, previous edge, or beginning
   of line */

int uprvwrd(bw)
BW *bw;
 {
 int c, d;
 if(pisbof(bw->cursor)) return -1;
 /* Move to end of previous word or edge */
 lp:
 d=' ';
 while(c=prgetc(bw->cursor),
       c!= MAXINT && !crest(c) && (!cwhitel(c) || cwhitel(d)))
  d=c; 
 if(c==' ')
  {
  d=prgetc(bw->cursor); if(d!=MAXINT) pgetc(bw->cursor);
  if(!cwhitel(d)) { pgetc(bw->cursor); goto lp; }
  }
 if(c!= MAXINT) pgetc(bw->cursor);
 /* Move to beginning of current word */
 while(crest(c=prgetc(bw->cursor)));
 if(c!= MAXINT) pgetc(bw->cursor);
 return 0;
 }

/* Move cursor to end of next word, next edge, or end of line */

int unxtwrd(bw)
BW *bw;
 {
 int c, d;
 if(piseof(bw->cursor)) return -1;
 /* Move to start of next word or edge */
 lp:
 d=' ';
 while(c=brc(bw->cursor),
       c!= MAXINT && !crest(c) && (!cwhitel(c) || cwhitel(d)))
  d=pgetc(bw->cursor);
 if(c==' ')
  {
  pgetc(bw->cursor); d=brc(bw->cursor); prgetc(bw->cursor);
  if(!cwhitel(d)) goto lp;
  }
 /* Move to end of current word */
 while(c=brc(bw->cursor), crest(c)) pgetc(bw->cursor);
 return 0;
 }

P *pboi(p)
P *p;
 {
 pbol(p);
 while(cwhite(brc(p))) pgetc(p);
 return p;
 }

int pisedge(p)
P *p;
 {
 P *q;
 int c;
 if(pisbol(p)) return -1;
 if(piseol(p)) return  1;
 q=pdup(p);
 pboi(q);
 if(q->byte==p->byte) goto left;
 if(cwhite(c=brc(p)))
  {
  pset(q,p); if(cwhite(prgetc(q))) goto no;
  if(c=='\t') goto right;
  pset(q,p); pgetc(q);
  if(pgetc(q)==' ') goto right;
  goto no;
  }
 else
  {
  pset(q,p); c=prgetc(q);
  if(c=='\t') goto left;
  if(c!=' ') goto no;
  if(prgetc(q)==' ') goto left;
  goto no;
  }

 right: prm(q); return 1;
 left: prm(q); return -1;
 no: prm(q); return 0;
 }

int upedge(bw)
BW *bw;
 {
 if(prgetc(bw->cursor)==MAXINT) return -1;
 while(pisedge(bw->cursor)!= -1) prgetc(bw->cursor);
 return 0;
 }

int unedge(bw)
BW *bw;
 {
 if(pgetc(bw->cursor)==MAXINT) return -1;
 while(pisedge(bw->cursor)!= 1) pgetc(bw->cursor);
 return 0;
 }
d287 86
a372 44
int utomatch(bw)
BW *bw;
 {
 int d;
 int c,		/* Character under cursor */
     f,		/* Character to find */
     dir;	/* 1 to search forward, -1 to search backward */
 
 switch(c=brc(bw->cursor))
  {
 case '(':  f=')';  dir=1;   break;
 case '[':  f=']';  dir=1;   break;
 case '{':  f='}';  dir=1;   break;
 case '`':  f='\''; dir=1;   break;
 case '<':  f='>';  dir=1;   break;
 case ')':  f='(';  dir= -1; break;
 case ']':  f='[';  dir= -1; break;
 case '}':  f='{';  dir= -1; break;
 case '\'': f='`';  dir= -1; break;
 case '>':  f='<';  dir= -1; break;
 default:   return -1;
  }
 
 if(dir==1)
  {
  P *p=pdup(bw->cursor);
  int cnt=0;	/* No. levels of delimiters we're in */
  while(d=pgetc(p), d!= MAXINT)
   if(d==c) ++cnt;
   else if(d==f && !--cnt) { prgetc(p); pset(bw->cursor,p); break; }
  prm(p);
  }
 else
  {
  P *p=pdup(bw->cursor);
  int cnt=0;	/* No. levels of delimiters we're in */
  while(d=prgetc(p), d!= MAXINT)
   if(d==c) ++cnt;
   else if(d==f) if(!cnt--) { pset(bw->cursor,p); break; }
  prm(p);
  }
 if(d==MAXINT) return -1;
 else return 0;
 }
d376 9
a384 11
int uuparw(bw)
BW *bw;
 {
 if(bw->cursor->line)
  {
  pprevl(bw->cursor);
  pcol(bw->cursor,bw->cursor->xcol);
  return 0;
  }
 else return -1;
 }
d388 15
a402 11
int udnarw(bw)
BW *bw;
 {
 if(bw->cursor->line!=bw->b->eof->line)
  {
  pnextl(bw->cursor);
  pcol(bw->cursor,bw->cursor->xcol);
  return 0;
  }
 else return -1;
 }
d406 9
a414 9
int utos(bw)
BW *bw;
 {
 long col=bw->cursor->xcol;
 pset(bw->cursor,bw->top);
 pcol(bw->cursor,col);
 bw->cursor->xcol=col;
 return 0;
 }
d418 9
a426 9
int ubos(bw)
BW *bw;
 {
 long col=bw->cursor->xcol;
 pline(bw->cursor,bw->top->line+bw->h-1);
 pcol(bw->cursor,col);
 bw->cursor->xcol=col;
 return 0;
 }
d436 32
a467 28
void scrup(bw,n,flg)
BW *bw;
 {
 int scrollamnt=0;
 int cursoramnt=0;
 int x;
 
 /* Decide number of lines we're really going to scroll */
 
 if(bw->top->line>=n) scrollamnt=cursoramnt=n;
 else
  if(bw->top->line) scrollamnt=cursoramnt=bw->top->line;
  else
   if(flg) cursoramnt=bw->cursor->line;
   else if(bw->cursor->line>=n) cursoramnt=n;
 
 /* Move top-of-window pointer */
 for(x=0;x!=scrollamnt;++x) pprevl(bw->top);
 pbol(bw->top);
 
 /* Move cursor */
 for(x=0;x!=cursoramnt;++x) pprevl(bw->cursor);
 pbol(bw->cursor);
 pcol(bw->cursor,bw->cursor->xcol);
 
 /* If window is on the screen, give (buffered) scrolling command */
 if(bw->parent->y!= -1) nscrldn(bw->parent->t->t,bw->y,bw->y+bw->h,scrollamnt);
 }
d477 29
a505 28
void scrdn(bw,n,flg)
BW *bw;
 {
 int scrollamnt=0;
 int cursoramnt=0;
 int x;
 
 /* How much we're really going to scroll... */
 if(bw->top->b->eof->line<bw->top->line+bw->h)
  {
  cursoramnt=bw->top->b->eof->line-bw->cursor->line;
  if(!flg && cursoramnt>n) cursoramnt=n;
  }
 else if(bw->top->b->eof->line-(bw->top->line+bw->h)>=n)
  cursoramnt=scrollamnt=n;
 else
  cursoramnt=scrollamnt=bw->top->b->eof->line-(bw->top->line+bw->h)+1;

 /* Move top-of-window pointer */
 for(x=0;x!=scrollamnt;++x) pnextl(bw->top);
 
 /* Move cursor */
 for(x=0;x!=cursoramnt;++x) pnextl(bw->cursor);
 pcol(bw->cursor,bw->cursor->xcol);
 
 /* If window is on screen, give (buffered) scrolling command to terminal */
 if(bw->parent->y!= -1) nscrlup(bw->parent->t->t,bw->y,bw->y+bw->h,scrollamnt);
 }
d509 13
a521 10
int upgup(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(!bw->cursor->line) return -1;
 if(pgamnt<0) scrup(bw,bw->h/2+bw->h%2,1);
 else if(pgamnt<bw->h) scrup(bw,bw->h-pgamnt,1);
 else scrup(bw,1,1);
 return 0;
 }
d525 13
a537 10
int upgdn(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->cursor->line==bw->b->eof->line) return -1;
 if(pgamnt<0) scrdn(bw,bw->h/2+bw->h%2,1);
 else if(pgamnt<bw->h) scrdn(bw,bw->h-pgamnt,1);
 else scrdn(bw,1,1);
 return 0;
 }
d541 23
a563 25
int uupslide(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->top->line)
  {
  if(bw->top->line+bw->h-1!=bw->cursor->line) udnarw(bw);
  scrup(bw,1,0);
  return 0;
  }
 else return -1;
 }

int udnslide(bw)
BW *bw;
 {
 bw=(BW *)bw->parent->main->object;
 if(bw->top->line+bw->h<=bw->top->b->eof->line)
  {
  if(bw->top->line!=bw->cursor->line) uuparw(bw);
  scrdn(bw,1,0);
  return 0;
  }
 else return -1;
 }
d567 1
a567 1
static B *linehist=0;	/* History of previously entered line numbers */
d569 33
a601 31
static int doline(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=1 && !merr)
  {
  int tmp=mid;
  if(num>bw->b->eof->line) num=bw->b->eof->line+1;
  pline(bw->cursor,num-1), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid line number");
  return -1;
  }
 }

int uline(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to line (^C to abort): ",&linehist,doline,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d605 1
a605 1
static B *colhist=0;	/* History of previously entered column numbers */
d607 31
a637 30
static int docol(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=1 && !merr)
  {
  int tmp=mid;
  pcol(bw->cursor,num-1), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid column number");
  return -1;
  }
 }

int ucol(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to column (^C to abort): ",&colhist,docol,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d641 1
a641 1
static B *bytehist=0;	/* History of previously entered byte numbers */
d643 31
a673 30
static int dobyte(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 long num=calc(bw,s);
 if(notify) *notify=1;
 vsrm(s);
 if(num>=0 && !merr)
  {
  int tmp=mid;
  pgoto(bw->cursor,num), bw->cursor->xcol=piscol(bw->cursor);
  mid=1; dofollows(); mid=tmp;
  return 0;
  }
 else
  {
  if(merr) msgnw(bw,merr);
  else msgnw(bw,"Invalid byte number");
  return -1;
  }
 }

int ubyte(bw)
BW *bw;
 {
 if(wmkpw(bw,"Go to byte (^C to abort): ",&bytehist,dobyte,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d679 92
a770 48
int udelch(bw)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=4;
  write(bw->pid,&c,0);
  }
 else
  {
  P *p;
  if(piseof(bw->cursor)) return -1;
  pgetc(p=pdup(bw->cursor));
  bdel(bw->cursor,p);
  prm(p);
  }
 return 0;
 }

/* Backspace, or if cursor is at end of file in a shell window, send backspace
 * to shell */

int ubacks(bw,k)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=k;
  write(bw->out,&c,1);
  }
 else if(bw->parent->watom->what==TYPETW || !pisbol(bw->cursor))
  {
  P *p;
  int c;
  if(pisbof(bw->cursor)) return -1;
  p=pdup(bw->cursor);
  if((c=prgetc(bw->cursor))!= MAXINT)
   if(!bw->o.overtype || c=='\t' || pisbol(p) || piseol(p))
    bdel(bw->cursor,p);
  prm(p);
  }
 else return -1;
 return 0;
 }

/* Delete from cursor to end of word it's on, to beginning of next word if
 * it's on whitespace or a single character if it's on neither a word nor
 * on whitespace
d772 23
a794 16

int udelw(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 int c=brc(p);
 if(crest(c))
  while(c=brc(p), crest(c)) pgetc(p);
 else if(cwhitel(c) || c=='\r')
  while(c=brc(p), (cwhitel(c) || c=='\r')) pgetc(p);
 else pgetc(p);
 if(p->byte==bw->cursor->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d800 25
a824 20
int ubackw(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 int c=prgetc(bw->cursor);
 if(crest(c))
  {
  while(c=prgetc(bw->cursor), crest(c));
  if(c!= MAXINT) pgetc(bw->cursor);
  }
 else if(cwhitel(c))
  {
  while(c=prgetc(bw->cursor), cwhitel(c));
  if(c!= MAXINT) pgetc(bw->cursor);
  }
 if(bw->cursor->byte==p->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d830 12
a841 9
int udelel(bw)
BW *bw;
 {
 P *p=peol(pdup(bw->cursor));
 if(bw->cursor->byte==p->byte) { prm(p); return udelch(bw); }
 else bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d847 12
a858 9
int udelbl(bw)
BW *bw;
 {
 P *p=pbol(pdup(bw->cursor));
 if(p->byte==bw->cursor->byte) { prm(p); return ubacks(bw,MAXINT); }
 else bdel(p,bw->cursor);
 prm(p);
 return 0;
 }
d862 14
a875 11
int udelln(bw)
BW *bw;
 {
 P *p=pdup(bw->cursor);
 pbol(bw->cursor);
 pnextl(p);
 if(bw->cursor->byte==p->byte) { prm(p); return -1; }
 bdel(bw->cursor,p);
 prm(p);
 return 0;
 }
d879 21
a899 6
int uinsc(bw)
BW *bw;
 {
 binsc(bw->cursor,' ');
 return 0;
 }
d906 103
a1008 27
int utypebw(bw,k)
BW *bw;
int k;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  char c=k;
  write(bw->out,&c,1);
  }
 else if(k=='\t' && bw->o.spaces)
  {
  long n=piscol(bw->cursor);
  n=bw->o.tab-n%bw->o.tab;
  while(n--) utypebw(bw,' ');
  }
 else
  {
  int upd=bw->parent->t->t->updtab[bw->y+bw->cursor->line-bw->top->line];
  int simple=1;
  if(pisblank(bw->cursor))
   while(piscol(bw->cursor)<bw->o.lmargin)
    binsc(bw->cursor,' '), pgetc(bw->cursor);
  binsc(bw->cursor,k), pgetc(bw->cursor);
  if(bw->o.wordwrap && piscol(bw->cursor)>bw->o.rmargin && !cwhite(k))
   wrapword(bw->cursor,(long)bw->o.lmargin,bw->o.french,NULL), simple=0;
  else if(bw->o.overtype && !piseol(bw->cursor) && k!='\t') udelch(bw);
  bw->cursor->xcol=piscol(bw->cursor);
d1010 27
a1036 22
  if(bw->cursor->xcol-bw->offset-1<0 || bw->cursor->xcol-bw->offset-1>=bw->w)
   simple=0;
  if(bw->cursor->line<bw->top->line ||
     bw->cursor->line>=bw->top->line+bw->h) simple=0;
  if(simple &&
     bw->parent->t->t->sary[bw->y+bw->cursor->line-bw->top->line]) simple=0;
  if(simple && k!='\t' && k!='\n' && !curmacro)
   {
   int c=0;
   SCRN *t=bw->parent->t->t;
   int y=bw->y+bw->cursor->line-bw->top->line;
   int x=bw->cursor->xcol-bw->offset+bw->x-1;
   int *screen=t->scrn+y*t->co;
   if(!upd && piseol(bw->cursor)) t->updtab[y]=0;
   if(markb && markk && markb->b==bw->b && markk->b==bw->b &&
      (!square && bw->cursor->byte>=markb->byte && bw->cursor->byte<markk->byte ||
       square && bw->cursor->line>=markb->line && bw->cursor->line<=markk->line &&
       piscol(bw->cursor)>=markb->xcol && piscol(bw->cursor)<markk->xcol))
    c=INVERSE;
   xlat(c,k);
   outatr(t,screen+x,x,y,k,c);
   }
d1038 3
a1040 3
  }
 return 0;
 }
d1044 18
d1065 215
a1279 218
int doquote(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 char buf[40];
 if(c<0 || c>=256)
  {
  nungetc(c);
  return -1;
  }
 switch(quotestate)
  {
  case 0:
  if(c>='0' && c<='9')
   {
   quoteval=c-'0';
   quotestate=1;
   sprintf(buf,"ASCII %c--",c);
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c=='x' || c=='X')
   {
   quotestate=3;
   if(!mkqwna(bw,sc("ASCII 0x--"),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c=='o' || c=='O')
   {
   quotestate=5;
   if(!mkqwna(bw,sc("ASCII 0---"),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else
   {
   if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
   if(c=='?') c=127;
   utypebw(bw,c);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 1:
  if(c>='0' && c<='9')
   {
   sprintf(buf,"ASCII %c%c-",quoteval+'0',c);
   quoteval=quoteval*10+c-'0';
   quotestate=2;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 2:
  if(c>='0' && c<='9')
   {
   quoteval=quoteval*10+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 3:
  if(c>='0' && c<='9')
   {
   sprintf(buf,"ASCII 0x%c-",c);
   quoteval=c-'0';
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c>='a' && c<='f')
   {
   sprintf(buf,"ASCII 0x%c-",c+'A'-'a');
   quoteval=c-'a'+10;
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  else if(c>='A' && c<='F')
   {
   sprintf(buf,"ASCII 0x%c-",c);
   quoteval=c-'A'+10;
   quotestate=4;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 4:
  if(c>='0' && c<='9')
   {
   quoteval=quoteval*16+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else if(c>='a' && c<='f')
   {
   quoteval=quoteval*16+c-'a'+10;
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else if(c>='A' && c<='F')
   {
   quoteval=quoteval*16+c-'A'+10;
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;

  case 5:
  if(c>='0' && c<='7')
   {
   sprintf(buf,"ASCII 0%c--",c);
   quoteval=c-'0';
   quotestate=6;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 6:
  if(c>='0' && c<='7')
   {
   sprintf(buf,"ASCII 0%c%c-",quoteval+'0',c);
   quoteval=quoteval*8+c-'0';
   quotestate=7;
   if(!mkqwna(bw,sz(buf),doquote,NULL,NULL,notify)) return -1;
   else return 0;
   }
  break;

  case 7:
  if(c>='0' && c<='7')
   {
   quoteval=quoteval*8+c-'0';
   utypebw(bw,quoteval);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  break;
  }
 if(notify) *notify=1;
 return 0;
 }

int uquote(bw)
BW *bw;
 {
 quotestate=0;
 if(mkqwna(bw,
           sc("Ctrl- (or 0-9 for dec. ascii, x for hex, or o for octal)"),doquote,NULL,NULL,NULL)) return 0;
 else return -1;
 }

int doquote9(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if((c>=0x40 && c<=0x5F) || (c>='a' && c<='z')) c&=0x1F;
 if(c=='?') c=127;
 c|=128;
 utypebw(bw,c);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int doquote8(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='`')
  {
  if(mkqwna(bw,sc("Meta-Ctrl-"),doquote9,NULL,NULL,notify)) return 0;
  else return -1;
  }
 if(notify) *notify=1;
 c|=128;
 utypebw(bw,c);
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int uquote8(bw)
BW *bw;
 {
 if(mkqwna(bw,sc("Meta-"),doquote8,NULL,NULL,NULL)) return 0;
 else return -1;
 }

extern char srchstr[];

int doctrl(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 int org=bw->o.overtype;
 if(notify) *notify=1;
 bw->o.overtype=0;
 if(bw->parent->huh==srchstr && c=='\n')
   utypebw(bw,'\\'), utypebw(bw,'n');
 else
  utype(bw,c);
 bw->o.overtype=org;
 bw->cursor->xcol=piscol(bw->cursor);
 return 0;
 }

int uctrl(bw)
BW *bw;
 {
 if(mkqwna(bw,sc("Quote"),doctrl,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1281 1
a1281 2
/* User hit Return.  Deal with autoindent.  If cursor is at end of shell
 * window buffer, send the return to the shell
d1284 26
a1309 23
int rtntw(bw)
BW *bw;
 {
 if(bw->pid && bw->cursor->byte==bw->b->eof->byte)
  {
  write(bw->out,"\n",1);
  }
 else
  {
  P *p=pdup(bw->cursor);
  char c;
  binsc(bw->cursor,'\n'), pgetc(bw->cursor);
  if(bw->o.autoindent)
   {
   pbol(p);
   while(cwhite(c=pgetc(p)))
    binsc(bw->cursor,c), pgetc(bw->cursor);
   }
  prm(p);
  bw->cursor->xcol=piscol(bw->cursor);
  }
 return 0;
 }
d1313 5
a1317 9
int uopen(bw)
BW *bw;
 {
 P *q=pdup(bw->cursor);
 rtntw(bw);
 pset(bw->cursor,q);
 prm(q);
 return 0;
 }
d1321 27
a1347 29
int dosetmark(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c>='0' && c<='9')
  {
  pdupown(bw->cursor,bw->b->marks+c-'0');
  poffline(bw->b->marks[c-'0']);
  sprintf(msgbuf,"Mark %d set",c-'0');
  msgnw(bw,msgbuf);
  return 0;
  }
 else
  {
  nungetc(c);
  return -1;
  }
 }

int usetmark(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return dosetmark(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Set mark (0-9):"),dosetmark,NULL,NULL,NULL)) return 0;
  else return -1;
 }
d1351 28
a1378 34
int dogomark(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c>='0' && c<='9')
  if(bw->b->marks[c-'0'])
   {
   pset(bw->cursor,bw->b->marks[c-'0']);
   bw->cursor->xcol=piscol(bw->cursor);
   return 0;
   }
  else
   {
   sprintf(msgbuf,"Mark %d not set",c-'0');
   msgnw(bw,msgbuf);
   return -1;
   }
 else
  {
  nungetc(c);
  return -1;
  }
 }

int ugomark(bw,c)
BW *bw;
 {
 if(c>='0' && c<='9') return dogomark(bw,c,NULL,NULL);
 else
  if(mkqwna(bw,sc("Goto bookmark (0-9):"),dogomark,NULL,NULL,NULL)) return 0;
  else return -1;
 }
d1384 54
a1437 48
int dofwrdc(bw,k,object,notify)
BW *bw;
void *object;
int *notify;
 {
 int c;
 P *q;
 if(notify) *notify=1;
 if(k<0 || k>=256)
  {
  nungetc(k);
  return -1;
  }
 q=pdup(bw->cursor);
 if(dobkwdc) { while((c=prgetc(q))!=MAXINT) if(c==k) break; }
 else { while((c=pgetc(q))!=MAXINT) if(c==k) break; }
 if(c==MAXINT)
  {
  msgnw(bw,"Not found");
  prm(q);
  return -1;
  }
 else
  {
  pset(bw->cursor,q);
  bw->cursor->xcol=piscol(bw->cursor);
  prm(q);
  return 0;
  }
 }

int ufwrdc(bw,k)
BW *bw;
 {
 dobkwdc=0;
 if(k>=0 && k<256) return dofwrdc(bw,k,NULL,NULL);
 else if(mkqw(bw,sc("Fwrd to char: "),dofwrdc,NULL,NULL,NULL)) return 0;
 else return -1;
 }

int ubkwdc(bw,k)
BW *bw;
 {
 dobkwdc=1;
 if(k>=0 && k<256) return dofwrdc(bw,k,NULL,NULL);
 else if(mkqw(bw,sc("Bkwd to char: "),dofwrdc,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1441 17
a1457 19
int domsg(b,s,object,notify)
BASE *b;
char *s;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 zcpy(msgbuf,s);
 vsrm(s);
 msgnw(b,msgbuf);
 return 0;
 }

int umsg(b)
BASE *b;
 {
 if(wmkpw(b,"Msg (^C to abort): ",NULL,domsg,NULL,NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
d1461 19
a1479 19
int dotxt(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int x;
 if(notify) *notify=1;
 for(x=0;x!=sLEN(s);++x) utypebw(bw,s[x]);
 vsrm(s);
 return 0;
 }

int utxt(bw)
BASE *bw;
 {
 if(wmkpw(bw,"Insert (^C to abort): ",NULL,dotxt,NULL,NULL,utypebw,NULL,NULL)) return 0;
 else return -1;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
