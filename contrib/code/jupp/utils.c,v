head	1.11;
access;
symbols
	joe-3_1jupp38:1.11
	joe-3_1jupp37:1.10
	joe-3_1jupp36:1.10
	joe-3_1jupp35:1.10
	joe-3_1jupp34:1.10
	joe-3_1jupp33:1.10
	joe-3_1jupp32:1.9
	joe-3_1jupp31:1.4
	joe-3_1jupp30:1.4
	joe-3_1jupp29:1.3
	joe-3_1jupp28:1.3
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.11
date	2018.11.11.18.15.39;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005BE871D325833018;

1.10
date	2018.01.06.00.28.34;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A50184621FA8455;

1.9
date	2017.12.06.21.17.04;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A285E5918D423C7;

1.8
date	2017.12.04.21.53.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A25C3E151C5344D;

1.7
date	2017.12.02.04.32.43;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A222CF2122034D9;

1.6
date	2017.12.02.03.52.34;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A222399180EAD68;

1.5
date	2017.12.02.02.07.37;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A220AD65C90E687;

1.4
date	2017.01.10.19.05.17;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005875307B7068AA59;

1.3
date	2008.05.13.13.08.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Various utilities
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *		(C) 2001 Marek 'Marx' Grac
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"

__RCSID("$MirOS: contrib/code/jupp/utils.c,v 1.10 2018/01/06 00:28:34 tg Exp $");

#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#include "charmap.h"
#include "blocks.h"
#include "utils.h"

/*
 * return minimum/maximum of two numbers
 */
unsigned int uns_min(unsigned int a, unsigned int b)
{
	return a < b ? a : b;
}

signed int int_min(signed int a, signed int b)
{
	return a < b ? a : b;
}

signed long int long_max(signed long int a, signed long int b)
{
	return a > b ? a : b;
}

signed long int long_min(signed long int a, signed long int b)
{
	return a < b ? a : b;
}

/* Versions of 'read' and 'write' which automatically retry when interrupted */
ssize_t
joe_read(int fd, void *buf, size_t size)
{
	ssize_t rt;

	do {
		rt = read(fd, buf, size);
	} while (rt < 0 && errno == EINTR);
	return rt;
}

ssize_t
joe_write(int fd, const void *buf, size_t size)
{
	ssize_t rt;

	do {
		rt = write(fd, buf, size);
	} while (rt < 0 && errno == EINTR);
	return rt;
}

/* Similarily, read and write an exact amount (up to EOF) */
ssize_t
joe_readex(int fd, void *buf_, size_t size)
{
	unsigned char *buf = buf_;
	ssize_t rv = 0, z;

	while (size) {
		if ((z = read(fd, buf, size)) < 0) {
			if (errno == EINTR)
				continue;
			return (rv ? /* fucked up since we got some */ -2 : -1);
		}
		if (z == 0)
			break;
		rv += z;
		buf += z;
		size -= z;
	}
	return (rv);
}

#if 0 /* unused */
ssize_t
joe_writex(int fd, const void *buf_, size_t size)
{
	const unsigned char *buf = buf_;
	ssize_t rv = 0, z;

	while (size) {
		if ((z = write(fd, buf, size)) < 0) {
			if (errno == EINTR)
				continue;
			return (rv ? /* fucked up since we got some */ -2 : -1);
		}
		rv += z;
		buf += z;
		size -= z;
	}
	return (rv);
}
#endif

#ifndef SIG_ERR
#define SIG_ERR ((sighandler_t) -1)
#endif

/* wrapper to hide signal interface differrencies */
int joe_set_signal(int signum, sighandler_t handler)
{
	int retval;
#ifdef HAVE_SIGACTION
	struct sigaction sact;

	mset(&sact, 0, sizeof(sact));
	sact.sa_handler = handler;
#ifdef SA_INTERRUPT
	sact.sa_flags = SA_INTERRUPT;
#endif
	retval = sigaction(signum, &sact, NULL);
#elif defined(HAVE_SIGVEC)
	struct sigvec svec;

	mset(&svec, 0, sizeof(svec));
	svec.sv_handler = handler;
#ifdef HAVE_SV_INTERRUPT
	svec.sv_flags = SV_INTERRUPT;
#endif
	retval = sigvec(signum, &svec, NULL);
#else
	retval = (signal(signum, handler) != SIG_ERR) ? 0 : -1;
#ifdef HAVE_SIGINTERRUPT
	siginterrupt(signum, 1);
#endif
#endif
	return(retval);
}

/* Helpful little parsing utilities */

/* Skip whitespace and return first non-whitespace character */

int
parse_ws(unsigned char **pp, int cmt)
{
	unsigned char *p = *pp;
	while (*p==' ' || *p=='\t')
		++p;
	if (*p=='\r' || *p=='\n' || *p==cmt)
		*p = 0;
	*pp = p;
	return *p;
}

/* Parse an identifier into a buffer.  Identifier is truncated to a maximum of len chars. */

int
parse_ident(unsigned char **pp, unsigned char *buf, int len)
{
	unsigned char *p = *pp;
	if (joe_isalphx(locale_map,*p)) {
		while(len && joe_isalnux(locale_map,*p))
			*buf++= *p++, --len;
		*buf=0;
		while(joe_isalnux(locale_map,*p))
			++p;
		*pp = p;
		return 0;
	} else
		return -1;
}

/* Parse to next whitespace */

int
parse_tows(unsigned char **pp, unsigned char *buf)
{
	unsigned char *p = *pp;
	while (*p && *p!=' ' && *p!='\t' && *p!='\n' && *p!='\r' && *p!='#')
		*buf++ = *p++;

	*pp = p;
	*buf = 0;
	return 0;
}

/* Parse a keyword */

int
parse_kw(unsigned char **pp, const unsigned char *kw)
{
	unsigned char *p = *pp;
	while(*kw && *kw==*p)
		++kw, ++p;
	if(!*kw && !joe_isalnux(locale_map,*p)) {
		*pp = p;
		return 0;
	} else
		return -1;
}

/* Parse a field */

int
parse_field(unsigned char **pp, const unsigned char *kw)
{
	unsigned char *p = *pp;
	while(*kw && *kw==*p)
		++kw, ++p;
	if(!*kw && (!*p || *p==' ' || *p=='\t' || *p=='#' || *p=='\n' || *p=='\r')) {
		*pp = p;
		return 0;
	} else
		return -1;
}

/* Parse a character */

int
parse_char(unsigned char **pp, unsigned char c)
{
	unsigned char *p = *pp;
	if (*p == c) {
		*pp = p+1;
		return 0;
	} else
		return -1;
}

/*
 * Parse a string into a buffer.  Returns 0 for success.
 * Leaves escape sequences in string.
 */
int
parse_string(unsigned char **pp, unsigned char *buf, int len)
{
	unsigned char *p = *pp;
	if(*p=='\"') {
		++p;
		while(len && *p && *p!='\"')
			if(*p=='\\' && p[1] && len>2) {
				*buf++ = *p++;
				*buf++ = *p++;
				len-=2;
			} else {
				*buf++ = *p++;
				--len;
			}
		*buf = 0;
		while(*p && *p!='\"')
			if(*p=='\\' && p[1])
				p+=2;
			else
				p++;
		if(*p=='\"') {
			*pp= p+1;
			return 0;
		}
	}
	return -1;
}

/* Parse a character range: a-z */
int
parse_range(unsigned char **pp, int *first, int *second)
{
	unsigned char *p = *pp;
	int a, b;
	if(!*p)
		return -1;
	if(*p=='\\' && p[1]) {
		++p;
		if(*p=='n')
			a = '\n';
		else if(*p=='t')
			a = '\t';
		else
			a = *p;
		++p;
	} else
		a = *p++;
	if(*p=='-' && p[1]) {
		++p;
		if(*p=='\\' && p[1]) {
			++p;
			if(*p=='n')
				b = '\n';
			else if(*p=='t')
				b = '\t';
			else
				b = *p;
			++p;
		} else
			b = *p++;
	} else
		b = a;
	*first = a;
	*second = b;
	*pp = p;
	return 0;
}
@


1.10
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/utils.c,v 1.9 2017/12/06 21:17:04 tg Exp $");
d45 2
a46 1
ssize_t joe_read(int fd, void *buf, size_t size)
d56 2
a57 1
ssize_t joe_write(int fd, void *buf, size_t size)
d67 43
@


1.9
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/utils.c,v 1.8 2017/12/04 21:53:35 tg Exp $");
d104 2
a105 1
int parse_ws(unsigned char **pp,int cmt)
d118 2
a119 1
int parse_ident(unsigned char **pp, unsigned char *buf, int len)
d136 2
a137 1
int parse_tows(unsigned char **pp, unsigned char *buf)
d150 2
a151 1
int parse_kw(unsigned char **pp, unsigned char *kw)
d165 2
a166 1
int parse_field(unsigned char **pp, unsigned char *kw)
d180 2
a181 1
int parse_char(unsigned char **pp, unsigned char c)
d191 6
a196 4
/* Parse a string into a buffer.  Returns 0 for success.
   Leaves escape sequences in string. */

int parse_string(unsigned char **pp, unsigned char *buf, int len)
d198 1
a198 1
	unsigned char *p= *pp;
d225 2
a226 2

int parse_range(unsigned char **pp, int *first, int *second)
d228 1
a228 1
	unsigned char *p= *pp;
@


1.8
log
@rename alpha_ to alphx and alnum_ to alnux

• matches mksh
• stuff with trailing underscore may not be allowed in C99
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/utils.c,v 1.6 2017/12/02 03:52:34 tg Exp $");
d14 1
a14 1
#ifdef HAVE_UNISTD_H
a15 4
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
@


1.7
log
@some fallout of the includes changes, some more reduction
@
text
@d124 2
a125 2
	if (joe_isalpha_(locale_map,*p)) {
		while(len && joe_isalnum_(locale_map,*p))
d128 1
a128 1
		while(joe_isalnum_(locale_map,*p))
d156 1
a156 1
	if(!*kw && !joe_isalnum_(locale_map,*p)) {
@


1.6
log
@banish parse_int()
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/utils.c,v 1.5 2017/12/02 02:07:37 tg Exp $");
a20 2
#include "i18n.h"
#include "utf8.h"
@


1.5
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a190 17
/* Parse an integer.  Returns 0 for success. */

int parse_int(unsigned char **pp, int *buf)
{
	unsigned char *p = *pp;
	if ((*p>='0' && *p<='9') || *p=='-') {
		*buf = atoi((char *)p);
		if(*p=='-')
			++p;
		while(*p>='0' && *p<='9')
			++p;
		*pp = p;
		return 0;
	} else
		return -1;
}

@


1.4
log
@remove some dead (#if 0) code; drop the joe_malloc() &c. wrappers
@
text
@a0 1
/* $MirOS: contrib/code/jupp/utils.c,v 1.3 2008/05/13 13:08:31 tg Exp $ */
d11 2
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
a25 17

#if 0
int joe_ispunct(int wide,struct charmap *map,int c)
{
	if (joe_isspace(c))
		return 0;

	if (c=='_')
		return 1;

	if (isalnum_(wide,map,c))
		return 0;

	return joe_isprint(wide,map,c);
}
#endif

a48 42
#if 0
/* 
 * Characters which are considered as word characters 
 * 	_ is considered as word character because is often used 
 *	in the names of C/C++ functions
 */
int isalnum_(int wide,struct charmap *map,int c)
{
	/* Fast... */
	if (c>='0' && c<='9' ||
	    c>='a' && c<='z' ||
	    c>='A' && c<='Z' ||
	    c=='_')
	  return 1;
	else if(c<128)
	  return 0;

	/* Slow... */
	if (wide)
		return joe_iswalpha(c);
	else
		return joe_iswalpha(to_uni(map,c));
}

int isalpha_(int wide,struct charmap *map,int c)
{
	/* Fast... */
	if (c>='a' && c<='z' ||
	    c>='A' && c<='Z' ||
	    c=='_')
	  return 1;
	else if(c<128)
	  return 0;

	/* Slow... */
	if (wide)
		return joe_iswalpha(c);
	else
		return joe_iswalpha(to_uni(map,c));
}
#endif

a69 22
/* wrappers to *alloc routines */
void *joe_malloc(size_t size)
{
	return malloc(size);
}

void *joe_calloc(size_t nmemb, size_t size)
{
	return calloc(nmemb, size);
}

void *joe_realloc(void *ptr, size_t size)
{
	return realloc(ptr, size);
}

void joe_free(void *ptr)
{
	free(ptr);
}


@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d275 1
a275 1
	if (*p>='0' && *p<='9' || *p=='-') {
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
