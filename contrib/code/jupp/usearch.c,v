head	1.22;
access;
symbols
	joe-3_1jupp38:1.22
	joe-3_1jupp37:1.22
	joe-3_1jupp36:1.21
	joe-3_1jupp35:1.21
	joe-3_1jupp34:1.21
	joe-3_1jupp33:1.21
	joe-3_1jupp32:1.21
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.10
	joe-3_1jupp30:1.10
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.6
	joe-3_1jupp25:1.6
	joe-3_1jupp24:1.6
	joe-3_1jupp23:1.6
	joe-3_1jupp22:1.5
	joe-3_1jupp21:1.5
	joe-3_1jupp20:1.5
	joe-3_1jupp19:1.5
	joe-3_1jupp18:1.5
	joe-3_1jupp17:1.5
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.5
	joe-3_1jupp15:1.5
	joe-3_1jupp14:1.5
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.22
date	2018.10.20.16.34.40;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005BCB59387FAC2036;

1.21
date	2017.12.16.22.10.55;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A359A0405479D56;

1.20
date	2017.12.08.02.00.43;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A29F2506E789D2B;

1.19
date	2017.12.07.02.10.19;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A28A3145E1FF911;

1.18
date	2017.12.06.23.58.38;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A2884424C3F3AD8;

1.17
date	2017.12.06.23.02.08;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A2876FC4FFE7EF5;

1.16
date	2017.12.06.21.41.04;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A28640547F64250;

1.15
date	2017.12.04.22.00.43;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A25C5A61B1846F2;

1.14
date	2017.12.04.22.00.28;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A25C58F4160D0D5;

1.13
date	2017.12.04.21.53.34;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A25C3E151C5344D;

1.12
date	2017.12.02.18.50.04;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A22F5E2328F5222;

1.11
date	2017.12.02.02.07.36;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A220AD65C90E687;

1.10
date	2017.01.11.22.56.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005876B84150F7CE16;

1.9
date	2017.01.10.19.16.28;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005875332028CA2A36;

1.8
date	2017.01.10.02.21.00;	author tg;	state Exp;
branches;
next	1.7;
commitid	100587445156908DEBB;

1.7
date	2017.01.10.02.13.17;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005874435864A72345;

1.6
date	2012.12.22.00.06.15;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050D4F965570AEE79;

1.5
date	2010.04.08.15.31.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004BBDF6C54CC9A0DB;

1.4
date	2010.01.02.15.41.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004B3F68DD49220490;

1.3
date	2008.05.13.13.08.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.22
log
@something about buffer size
@
text
@/*
 *	Search & Replace system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/usearch.c,v 1.19 2017/12/07 02:10:19 tg Exp $");

#include <stdlib.h>

#include "b.h"
#include "bw.h"
#include "main.h"
#include "pw.h"
#include "queue.h"
#include "qw.h"
#include "regex.h"
#include "ublock.h"
#include "uedit.h"
#include "undo.h"
#include "usearch.h"
#include "utils.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"
#include "va.h"
#include "tty.h"
#include "menu.h"
#include "hash.h"

int wrap = 0;			/* Allow wrap */
int smode = 0;			/* Decremented to zero by execmd */
int csmode = 0;			/* Set for continued search mode */
int icase = 0;			/* Set to force case insensitive search */

B *findhist = NULL;		/* Search string history */
B *replhist = NULL;		/* Replacement string history */

SRCH *globalsrch = NULL;	/* Most recent completed search data */

SRCHREC fsr = { {&fsr, &fsr}, 0, 0, 0 };

/* Completion stuff: should go somewhere else */

unsigned char **word_list;

#define MAX_WORD_SIZE 64
static unsigned char **
get_word_list(B *b, int ignore)
{
	unsigned char buf[MAX_WORD_SIZE];
	unsigned char *s;
	unsigned char **list = 0;
	HASH *h;
	HENTRY *t;
	P *p;
	int c;
	int idx;
	int start = 0;

	h = htmk(1024);

	p = pdup(b->bof);
	idx = 0;
	while ((c=pgetc(p))!=NO_MORE_DATA)
		if (idx) {
			if (joe_isalnux(b->o.charmap, c)) {
				if (idx!=MAX_WORD_SIZE)
					buf[idx++] = c;
			} else {
				if (idx!=MAX_WORD_SIZE && start!=ignore) {
					buf[idx] = 0;
					if (!htfind(h,buf)) {
						s = vsncpy(NULL,0,buf,idx);
						htadd(h, s, s);
					}
				}
				idx = 0;
			}
		} else {
			start=p->byte-1;
			if (joe_isalphx(b->o.charmap, c))
				buf[idx++] = c;
		}
	prm(p);

	for (idx = 0;idx != h->len;++idx)
		for (t = h->tab[idx];t;t=t->next)
			list = vaadd(list, /* checked */ US t->name);
	if (list)
		vasort(list, sLEN(list));

	htrm(h);

	return list;
}

static void
fcmplt_ins(BW *bw, unsigned char *line)
{
	P *p;
	int c;

	if (!piseol(bw->cursor)) {
		c = brch(bw->cursor);
		if (joe_isalnux(bw->b->o.charmap,c))
			return;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor);
	do
		c = prgetc(p);
		while (joe_isalnux(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		/* Insert single match */
		bdel(p,bw->cursor);
		binsm(bw->cursor,sv(line));
		pfwrd(bw->cursor,sLEN(line));
		bw->cursor->xcol = piscol(bw->cursor);
		prm(p);
	} else {
		prm(p);
	}
}

static int
fcmplt_abrt(BW *bw, int x, unsigned char *line)
{
	if (line) {
		fcmplt_ins(bw, line);
		vsrm(line);
	}
	return -1;
}

static int
fcmplt_rtn(MENU *m, int x, unsigned char *line)
{
	fcmplt_ins(m->parent->win->object.bw, m->list[x]);
	vsrm(line);
	m->object = NULL;
	wabort(m->parent);
	return 0;
}

int ufinish(BW *bw)
{
	unsigned char *line;
	unsigned char *line1;
	unsigned char **lst;
	P *p;
	int c;
	MENU *m;

	/* Make sure we're not in a word */

	if (!piseol(bw->cursor)) {
		c = brch(bw->cursor);
		if (joe_isalnux(bw->b->o.charmap,c))
			return -1;
	}

	/* Move p to beginning of word */

	p = pdup(bw->cursor);
	do
		c = prgetc(p);
		while (joe_isalnux(bw->b->o.charmap,c));
	if (c!=NO_MORE_DATA)
		pgetc(p);

	if (bw->cursor->byte!=p->byte && bw->cursor->byte-p->byte<64) {
		line = brvs(p, bw->cursor->byte-p->byte);

		/* We have a word */

		/* Get word list */
		if (word_list)
			varm(word_list);

		word_list = get_word_list(bw->b, p->byte);

		if (!word_list) {
			vsrm(line);
			prm(p);
			return -1;
		}

		line1 = vsncpy(NULL,0,sv(line));
		line1 = vsadd(line1,'*');
		lst = regsub(word_list, aLEN(word_list), line1);
		vsrm(line1);

		if (!lst) {
			ttputc(7);
			vsrm(line);
			return -1;
		}

		m = mkmenu(bw->parent, lst, fcmplt_rtn, fcmplt_abrt, NULL, 0, line, NULL);
		if (!m) {
			varm(lst);
			vsrm(line);
			return -1;
		}

		/* Possible match list is now in lst */

		if (aLEN(lst) == 1)
			return fcmplt_rtn(m, 0, line);
		else if (smode)
			return 0;
		else {
			unsigned char *com = mcomplete(m);
			vsrm(m->object);
			m->object = com;
			wabort(m->parent);
			smode = 2;
			ttputc(7);
			return 0;
		}
	} else {
		prm(p);
		return -1;
	}
}

static int srch_cmplt(BW *bw)
{
	jobject jO;

	jO.bw = bw;
	utypebw(jO, 9);
	return 0;
}

/* Search forward.
   bw, pattern and ignore must be set

   The first possible string we can find is the one beginning under p

   Returns p if we found a string:
     The found string is placed in entire/pieces
     p is placed right after the found string

   Return 0 if we did not find the string:
     p is left in its orignal spot
*/

static P *searchf(BW *bw,SRCH *srch, P *p)
{
	unsigned char *pattern = srch->pattern;
	P *start;
	P *end;
	int x;

	start = pdup(p);
	end = pdup(p);

	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
		if (srch->ignore)
			pattern[x] = joe_tolower(p->b->o.charmap,pattern[x]);
 wrapped:
	while (srch->ignore ? pifind(start, pattern, x) : pfind(start, pattern, x)) {
		pset(end, start);
		pfwrd(end, (long) x);
		if (srch->wrap_flag && start->byte>=srch->wrap_p->byte)
			break;
		if (pmatch(srch->pieces, pattern + x, sLEN(pattern) - x, end, 0, srch->ignore)) {
			srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
			brmem(start, srch->entire, (int) (end->byte - start->byte));
			pset(p, end);
			prm(start);
			prm(end);
			return p;
		}
		if (pgetc(start) == NO_MORE_DATA)
			break;
	}
	if (wrap && !srch->wrap_flag && srch->wrap_p) {
		msgnw(bw->parent, UC "Wrapped");
		srch->wrap_flag = 1;
		p_goto_bof(start);
		goto wrapped;
	}

	prm(start);
	prm(end);
	return NULL;
}

/* Search backwards.
   bw, pattern and ignore must be set

   The first possible string we can find is the one beginning one position
   to the left of p.

   Returns 1 if we found a string:
     The found string is placed in entire
     p is placed at the beginning of the string

   Return 0 if we did not find the string:
     p is left in its orignal spot
*/

static P *searchb(BW *bw,SRCH *srch, P *p)
{
	unsigned char *pattern = srch->pattern;
	P *start;
	P *end;
	int x;

	start = pdup(p);
	end = pdup(p);

	for (x = 0; x != sLEN(pattern) && pattern[x] != '\\' && (pattern[x]<128 || !p->b->o.charmap->type); ++x)
		if (srch->ignore)
			pattern[x] = joe_tolower(p->b->o.charmap,pattern[x]);

 wrapped:
	while (pbkwd(start, 1L)
	       && (srch->ignore ? prifind(start, pattern, x) : prfind(start, pattern, x))) {
		pset(end, start);
		pfwrd(end, (long) x);
		if (srch->wrap_flag && start->byte<srch->wrap_p->byte)
			break;
		if (pmatch(srch->pieces, pattern + x, sLEN(pattern) - x, end, 0, srch->ignore)) {
			srch->entire = vstrunc(srch->entire, (int) (end->byte - start->byte));
			brmem(start, srch->entire, (int) (end->byte - start->byte));
			pset(p, start);
			prm(start);
			prm(end);
			return p;
		}
	}

	if (wrap && !srch->wrap_flag && srch->wrap_p) {
		msgnw(bw->parent, UC "Wrapped");
		srch->wrap_flag = 1;
		p_goto_eof(start);
		goto wrapped;
	}

	prm(start);
	prm(end);
	return NULL;
}

/* Make a search stucture */

static SRCH *setmark(SRCH *srch)
{
	if (markv(0))
		srch->valid = 1;

	srch->markb = markb;
	if (srch->markb)
		srch->markb->owner = &srch->markb;
	markb = NULL;

	srch->markk = markk;
	if (srch->markk)
		srch->markk->owner = &srch->markk;
	markk = NULL;

	return srch;
}

SRCH *mksrch(unsigned char *pattern, unsigned char *replacement, int ignore, int backwards, int repeat, int replace, int rest)
{
	SRCH *srch = malloc(sizeof(SRCH));
	int x;

	srch->pattern = pattern;
	srch->replacement = replacement;
	srch->ignore = ignore;
	srch->backwards = backwards;
	srch->repeat = repeat;
	srch->replace = replace;
	srch->rest = rest;
	srch->entire = NULL;
	srch->flg = 0;
	srch->addr = -1;
	srch->markb = NULL;
	srch->markk = NULL;
	srch->wrap_p = NULL;
	srch->wrap_flag = 0;
	srch->valid = 0;
	srch->block_restrict = 0;
	izque(SRCHREC, link, &srch->recs);
	for (x = 0; x != 26; ++x)
		srch->pieces[x] = NULL;
	return srch;
}

/* Eliminate a search structure */

void rmsrch(SRCH *srch)
{
	int x;

	prm(markb);
	prm(markk);
	prm(srch->wrap_p);
	if (srch->markb) {
		markb = srch->markb;
		markb->owner = &markb;
		markb->xcol = piscol(markb);
	}
	if (srch->markk) {
		markk = srch->markk;
		markk->owner = &markk;
		markk->xcol = piscol(markk);
	}
	for (x = 0; x != 26; ++x)
		vsrm(srch->pieces[x]);
	frchn(&fsr, &srch->recs);
	vsrm(srch->pattern);
	vsrm(srch->replacement);
	vsrm(srch->entire);
	free(srch);
	updall();
}

/* Insert a replacement string
 * p is advanced past the inserted text
 */

static P *insert(SRCH *srch, P *p, unsigned char *s, int len)
{
	int x;

	while (len) {
		for (x = 0; x != len && s[x] != '\\'; ++x) ;
		if (x) {
			binsm(p, s, x);
			pfwrd(p, (long) x);
			len -= x;
			s += x;
		} else if (len >= 2) {
			if (((s[1] | 0x20) >= 'a' && (s[1] | 0x20) <= 'z') &&
			    srch->pieces[(s[1] & 0x1f) - 1]) {
				binsm(p, sv(srch->pieces[(s[1] & 0x1f) - 1]));
				pfwrd(p, (long) sLEN(srch->pieces[(s[1] & 0x1f) - 1]));
				s += 2;
				len -= 2;
			} else if (s[1] >= '0' && s[1] <= '9' && srch->pieces[s[1] - '0']) {
				binsm(p, sv(srch->pieces[s[1] - '0']));
				pfwrd(p, (long) sLEN(srch->pieces[s[1] - '0']));
				s += 2;
				len -= 2;
			} else if (s[1] == '&' && srch->entire) {
				binsm(p, sv(srch->entire));
				pfwrd(p, (long) sLEN(srch->entire));
				s += 2;
				len -= 2;
			} else {
				unsigned char *a=(unsigned char *)s+x;
				int l=len-x;
				binsc(p,escape(p->b->o.charmap->type,&a,&l));
				pgetc(p);
				len -= a - (unsigned char *)s;
				s = a;
			}
		} else
			len = 0;
	}
	return p;
}

/* Search system user interface */

/* Query for search string, search options, possible replacement string,
 * and execute first search */

/* Context sensitive help identifier */
const unsigned char srchstr[] = "Search";

static int pfabort(BW *bw, SRCH *srch)
{
	if (srch)
		rmsrch(srch);
	return -1;
}

/* always returns -1 */
static int pfsave(BW *bw, SRCH *srch)
{
	if (srch) {
		if (globalsrch)
			rmsrch(globalsrch);
		globalsrch = srch;
		srch->rest = 0;
		srch->repeat = -1;
		srch->flg = 0;

		prm(markb);
		prm(markk);
		if (srch->markb) {
			markb = srch->markb;
			markb->owner = &markb;
			markb->xcol = piscol(markb);
		}
		if (srch->markk) {
			markk = srch->markk;
			markk->owner = &markk;
			markk->xcol = piscol(markk);
		}
		srch->markb = NULL;
		srch->markk = NULL;

		updall();
	}
	return -1;
}

static int set_replace(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	srch->replacement = s;
	return dopfnext(bw, srch, notify);
}

static int set_options(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	int x;

	srch->ignore = icase;

	for (x = 0; s[x]; ++x) {
		switch (s[x] | 0x20) {
		case 'r':
			srch->replace = 1;
			break;
		case 'b':
			srch->backwards = 1;
			break;
		case 'i':
			srch->ignore = 1;
			break;
		case 's':
			srch->ignore = 0;
			break;
		case 'k':
			srch->block_restrict = 1;
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			if (srch->repeat == -1)
				srch->repeat = 0;
			srch->repeat = srch->repeat * 10 + s[x] - '0';
			break;
		}
	}
	vsrm(s);
	if (srch->replace) {
		if (wmkpw(bw->parent, UC "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, srch_cmplt, srch, notify, bw->b->o.charmap))
			return 0;
		else
			return -1;
	} else
		return dopfnext(bw, srch, notify);
}

static int set_pattern(BW *bw, unsigned char *s, SRCH *srch, int *notify)
{
	BW *pbw;
	const unsigned char *p;

	if (icase)
		p = UC "case (S)ensitive (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";
	else
		p = UC "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";

	vsrm(srch->pattern);
	srch->pattern = s;
	if ((pbw = wmkpw(bw->parent, p, NULL, set_options, srchstr, pfabort, utypebw, srch, notify, bw->b->o.charmap)) != NULL) {
		unsigned char buf[12];

		if (srch->ignore)
			binsc(pbw->cursor, 'i');
		if (srch->replace)
			binsc(pbw->cursor, 'r');
		if (srch->backwards)
			binsc(pbw->cursor, 'b');
		if (srch->repeat >= 0) {
			joe_snprintf_1((char *)buf, sizeof(buf), "%d", srch->repeat);
			binss(pbw->cursor, buf);
		}
		pset(pbw->cursor, pbw->b->eof);
		pbw->cursor->xcol = piscol(pbw->cursor);
		srch->ignore = 0;
		srch->replace = 0;
		srch->backwards = 0;
		srch->repeat = -1;
		return 0;
	} else {
		rmsrch(srch);
		return -1;
	}
}

static int dofirst(BW *bw, int back, int repl)
{
	SRCH *srch;

	if (smode && globalsrch) {
		globalsrch->backwards = back;
		globalsrch->replace = repl;
		return pfnext(bw);
	}
	if (bw->parent->huh == srchstr) {
		long byte;
		jobject jO;

		p_goto_eol(bw->cursor);
		byte = bw->cursor->byte;
		p_goto_bol(bw->cursor);
		if (byte == bw->cursor->byte)
			prgetc(bw->cursor);
		jO.bw = bw;
		return urtn(jO, -1);
	}
	srch = setmark(mksrch(NULL, NULL, 0, back, -1, repl, 0));
	srch->addr = bw->cursor->byte;
	srch->wrap_p = pdup(bw->cursor);
	srch->wrap_p->owner = &srch->wrap_p;
	if (wmkpw(bw->parent, UC "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap))
		return 0;
	else {
		rmsrch(srch);
		return -1;
	}
}

int pffirst(BW *bw)
{
	return dofirst(bw, 0, 0);
}

int prfirst(BW *bw)
{
	return dofirst(bw, 1, 0);
}

int pqrepl(BW *bw)
{
	return dofirst(bw, 0, 1);
}

/* Execute next search */

static int doreplace(BW *bw, SRCH *srch)
{
	P *q;

	if (bw->b->rdonly) {
		msgnw(bw->parent, UC "Read only");
		return -1;
	}
	if (markk)
		markk->end = 1;
	if (srch->markk)
		srch->markk->end = 1;
	q = pdup(bw->cursor);
	if (srch->backwards) {
		q = pfwrd(q, (long) sLEN(srch->entire));
		bdel(bw->cursor, q);
		prm(q);
	} else {
		q = pbkwd(q, (long) sLEN(srch->entire));
		bdel(q, bw->cursor);
		prm(q);
	}
	insert(srch, bw->cursor, sv(srch->replacement));
	srch->addr = bw->cursor->byte;
	if (markk)
		markk->end = 0;
	if (srch->markk)
		srch->markk->end = 0;
	return 0;
}

static void visit(SRCH *srch, BW *bw, int yn)
{
	SRCHREC *r = (SRCHREC *) alitem(&fsr, sizeof(SRCHREC));

	r->addr = bw->cursor->byte;
	r->yn = yn;
	r->wrap_flag = srch->wrap_flag;
	enqueb(SRCHREC, link, &srch->recs, r);
}

static void goback(SRCH *srch, BW *bw)
{
	SRCHREC *r = srch->recs.link.prev;

	if (r != &srch->recs) {
		if (r->yn)
			uundo(bw);
		if (bw->cursor->byte != r->addr)
			pgoto(bw->cursor, r->addr);
		srch->wrap_flag = r->wrap_flag;
		demote(SRCHREC, link, &fsr, r);
	}
}

static int dopfrepl(BW *bw, int c, SRCH *srch, int *notify)
{
	srch->addr = bw->cursor->byte;
	if ((c | 0x20) == 'n')
		return dopfnext(bw, srch, notify);
	else if ((c | 0x20) == 'y' || (c | 0x20) == 'l' || c == ' ') {
		srch->recs.link.prev->yn = 1;
		/* why do I return -1 on 'L' here? */
		return ((doreplace(bw, srch) || (c | 0x20) == 'l') ?
		    pfsave(bw, srch) : dopfnext(bw, srch, notify));
	} else if ((c | 0x20) == 'r') {
		if (doreplace(bw, srch))
			return -1;
		srch->rest = 1;
		return dopfnext(bw, srch, notify);
	} else if (c == 8 || c == 127 || (c | 0x20) == 'b') {
		goback(srch, bw);
		goback(srch, bw);
		return dopfnext(bw, srch, notify);
	} else if (c != -1) {
		if (notify)
			*notify = 1;
		pfsave(bw, srch);
		nungetc(c);
		return 0;
	}
	if (mkqwnsr(bw->parent, sc("Replace (Y)es (N)o (L)ast (R)est (B)ackup (^C to abort)?"), dopfrepl, pfsave, srch, notify))
		return 0;
	else
		return pfsave(bw, srch);
}

/* Test if found text is within region
 * return 0 if it is,
 * -1 if we should keep searching
 * 1 if we're done
 */

static int restrict_to_block(BW *bw, SRCH *srch)
{
	if (!srch->block_restrict)
		return 0;
	bw->cursor->xcol = piscol(bw->cursor);
	if (srch->backwards)
		if (!square) {
			if (bw->cursor->byte < srch->markb->byte)
				return 1;
			else if (bw->cursor->byte + sLEN(srch->entire) > srch->markk->byte)
				return -1;
		} else {
			if (bw->cursor->line < srch->markb->line)
				return 1;
			else if (bw->cursor->line > srch->markk->line)
				return -1;
			else if (piscol(bw->cursor) + sLEN(srch->entire) > srch->markk->xcol || piscol(bw->cursor) < srch->markb->xcol)
				return -1;
	} else if (!square) {
		if (bw->cursor->byte > srch->markk->byte)
			return 1;
		else if (bw->cursor->byte - sLEN(srch->entire) < srch->markb->byte)
			return -1;
	} else {
		if (bw->cursor->line > srch->markk->line)
			return 1;
		if (bw->cursor->line < srch->markb->line)
			return -1;
		if (piscol(bw->cursor) > srch->markk->xcol || piscol(bw->cursor) - sLEN(srch->entire) < srch->markb->xcol)
			return -1;
	}
	return 0;
}

/* Possible results:
 *   0) Search or search & replace is finished.
 *   1) Search string was not found.
 *   2) Search string was found.
 */

static int fnext(BW *bw, SRCH *srch)
{
	P *sta;

 next:
	if (srch->repeat != -1) {
		if (!srch->repeat)
			return 0;
		else
			--srch->repeat;
	}
 again:
	if (srch->backwards)
		sta = searchb(bw, srch, bw->cursor);
	else
		sta = searchf(bw, srch, bw->cursor);
	if (!sta) {
		srch->repeat = -1;
		return 1;
	} else if (srch->rest || (srch->repeat != -1 && srch->replace)) {
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				return !srch->rest;
			}
		if (doreplace(bw, srch))
			return 0;
		goto next;
	} else if (srch->repeat != -1) {
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				return 1;
			}
		srch->addr = bw->cursor->byte;
		goto next;
	} else
		return 2;
}

int dopfnext(BW *bw, SRCH *srch, int *notify)
{
	int orgmid = mid;	/* Original mid status */
	int ret = 0;

	mid = 1;		/* Screen recenters mode during search */
	if (csmode)
		smode = 2;	/* We have started a search mode */
	if (srch->replace)
		visit(srch, bw, 0);
 again:
	switch (fnext(bw, srch)) {
	case 0:
		break;
	case 1:
 bye:
		if (!srch->flg && !srch->rest) {
			if (srch->valid && srch->block_restrict)
				msgnw(bw->parent, UC "Not found (search restricted to marked block)");
			else
				msgnw(bw->parent, UC "Not found");
			ret = -1;
		}
		break;
	case 2:
		if (srch->valid)
			switch (restrict_to_block(bw, srch)) {
			case -1:
				goto again;
			case 1:
				if (srch->addr >= 0)
					pgoto(bw->cursor, srch->addr);
				goto bye;
			}
		srch->addr = bw->cursor->byte;

		/* Make sure found text is fully on screen */
		if(srch->backwards) {
			bw->offset=0;
			pfwrd(bw->cursor,sLEN(srch->entire));
			bw->cursor->xcol = piscol(bw->cursor);
			dofollows();
			pbkwd(bw->cursor,sLEN(srch->entire));
		} else {
			bw->offset=0;
			pbkwd(bw->cursor,sLEN(srch->entire));
			bw->cursor->xcol = piscol(bw->cursor);
			dofollows();
			pfwrd(bw->cursor,sLEN(srch->entire));
		}

		if (srch->replace) {
			if (square)
				bw->cursor->xcol = piscol(bw->cursor);
			if (srch->backwards) {
				pdupown(bw->cursor, &markb);
				markb->xcol = piscol(markb);
				pdupown(markb, &markk);
				pfwrd(markk, (long) sLEN(srch->entire));
				markk->xcol = piscol(markk);
			} else {
				pdupown(bw->cursor, &markk);
				markk->xcol = piscol(markk);
				pdupown(bw->cursor, &markb);
				pbkwd(markb, (long) sLEN(srch->entire));
				markb->xcol = piscol(markb);
			}
			srch->flg = 1;
			if (dopfrepl(bw, -1, srch, notify))
				ret = -1;
			notify = 0;
			srch = 0;
		}
		break;
	}
	bw->cursor->xcol = piscol(bw->cursor);
	dofollows();
	mid = orgmid;
	if (notify)
		*notify = 1;
	if (srch)
		pfsave(bw, srch);
	else
		updall();
	return ret;
}

int pfnext(BW *bw)
{
	SRCH *srch;

	if (!globalsrch) {
		/* Query for search string if there isn't any */
		return pffirst(bw);
	}

	srch = globalsrch;
	globalsrch = NULL;
	srch->addr = bw->cursor->byte;
	if (!srch->wrap_p || srch->wrap_p->b!=bw->b) {
		prm(srch->wrap_p);
		srch->wrap_p = pdup(bw->cursor);
		srch->wrap_p->owner = &srch->wrap_p;
		srch->wrap_flag = 0;
	}
	srch->valid = 0;
	return dopfnext(bw, setmark(srch), NULL);
}
@


1.21
log
@more casing tweaks
@
text
@d594 1
a594 1
		unsigned char buf[10];
d602 4
a605 2
		if (srch->repeat >= 0)
			joe_snprintf_1((char *)buf, sizeof(buf), "%d", srch->repeat), binss(pbw->cursor, buf);
@


1.20
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d450 1
a450 1
			if (((s[1] >= 'a' && s[1] <= 'z') || (s[1] >= 'A' && s[1] <= 'Z')) &&
@


1.19
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/usearch.c,v 1.18 2017/12/06 23:58:38 tg Exp $");
d380 1
a380 1
	SRCH *srch = (SRCH *) joe_malloc(sizeof(SRCH));
d430 1
a430 1
	joe_free(srch);
@


1.18
log
@make wmkpw const again
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/usearch.c,v 1.16 2017/12/06 21:41:04 tg Exp $");
d148 1
a148 1
	fcmplt_ins(m->parent->win->object, m->list[x]);
d239 5
a243 2
	utypebw(bw, 9);
		return 0;
d628 1
d635 2
a636 1
		return urtn((BASE *)bw, -1);
@


1.17
log
@lots of fixes related to prototyping
@
text
@d570 1
a570 1
		if (wmkpw(bw->parent, US "Replace with (^C to abort): ", &replhist, set_replace, srchstr, pfabort, srch_cmplt, srch, notify, bw->b->o.charmap))
d581 1
a581 1
	unsigned char *p;
d584 1
a584 1
		p = US "case (S)ensitive (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";
d586 1
a586 1
		p = US "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ";
d637 1
a637 1
	if (wmkpw(bw->parent, US "Find (^C to abort): ", &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap))
@


1.16
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/usearch.c,v 1.14 2017/12/04 22:00:28 tg Exp $");
d52 2
a53 1
unsigned char **get_word_list(B *b,int ignore)
d102 2
a103 1
void fcmplt_ins(BW *bw, unsigned char *line)
d135 2
a136 1
int fcmplt_abrt(BW *bw, int x, unsigned char *line)
d145 2
a146 1
int fcmplt_rtn(MENU *m, int x, unsigned char *line)
@


1.15
log
@^K]
@
text
@d92 1
a92 1
			list = vaadd(list, t->name);
d94 1
a94 1
		vasort(list,sLEN(list));
d283 1
a283 1
		msgnw(bw->parent, US "Wrapped");
d340 1
a340 1
		msgnw(bw->parent, US "Wrapped");
d663 1
a663 1
		msgnw(bw->parent, US "Read only");
d857 1
a857 1
				msgnw(bw->parent, US "Not found (search restricted to marked block)");
d859 1
a859 1
				msgnw(bw->parent, US "Not found");
@


1.14
log
@tweak by reducing amount of comparisons
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/usearch.c,v 1.11 2017/12/02 02:07:36 tg Exp $");
d94 1
a94 1
		vasort(list,sLEN(list));	
@


1.13
log
@rename alpha_ to alphx and alnum_ to alnux

• matches mksh
• stuff with trailing underscore may not be allowed in C99
@
text
@d265 1
a265 1
	wrapped:
d322 1
a322 1
	wrapped:
d443 2
a444 2
			if (((s[1] >= 'a' && s[1] <= 'z') || (s[1] >= 'A' && s[1] <= 'Z'))
				 && srch->pieces[(s[1] & 0x1f) - 1]) {
d532 1
a532 1
		switch (s[x]) {
a533 1
		case 'R':
a536 1
		case 'B':
a539 1
		case 'I':
a542 1
		case 'S':
a545 1
		case 'K':
d716 1
a716 1
	if (c == 'N' || c == 'n')
d718 1
a718 1
	else if (c == 'Y' || c == 'y' || c == ' ' || c == 'L' || c == 'l') {
d721 1
a721 1
		return ((doreplace(bw, srch) || c == 'L' || c == 'l') ?
d723 1
a723 1
	} else if (c == 'R' || c == 'r') {
d728 1
a728 1
	} else if (c == 8 || c == 127 || c == 'b' || c == 'B') {
d795 1
a795 1
      next:
d802 2
a803 1
      again:if (srch->backwards)
d849 2
a850 1
again:	switch (fnext(bw, srch)) {
d854 2
a855 1
bye:		if (!srch->flg && !srch->rest) {
d928 4
a931 1
	if (!globalsrch)	/* Query for search string if there isn't any */
d933 1
a933 2
	else {
		SRCH *srch = globalsrch;
d935 8
a942 10
		globalsrch = NULL;
		srch->addr = bw->cursor->byte;
		if (!srch->wrap_p || srch->wrap_p->b!=bw->b) {
			prm(srch->wrap_p);
			srch->wrap_p = pdup(bw->cursor);
			srch->wrap_p->owner = &srch->wrap_p;
			srch->wrap_flag = 0;
		}
		srch->valid = 0;
		return dopfnext(bw, setmark(srch), NULL);
d944 2
@


1.12
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@d70 1
a70 1
			if (joe_isalnum_(b->o.charmap, c)) {
d85 1
a85 1
			if (joe_isalpha_(b->o.charmap, c))
d108 1
a108 1
		if (joe_isalnum_(bw->b->o.charmap,c))
d117 1
a117 1
		while (joe_isalnum_(bw->b->o.charmap,c));
d164 1
a164 1
		if (joe_isalnum_(bw->b->o.charmap,c))
d173 1
a173 1
		while (joe_isalnum_(bw->b->o.charmap,c));
@


1.11
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d45 1
a45 1
SRCHREC fsr = { {&fsr, &fsr} };
@


1.10
log
@constify “huh” (… huh‽)
@
text
@a0 1
/* $MirOS: contrib/code/jupp/usearch.c,v 1.5 2010/04/08 15:31:06 tg Exp $ */
d11 2
a12 1
#include <stdio.h>
@


1.9
log
@these now all need <stdlib.h>
@
text
@d478 2
a479 1
unsigned char srchstr[] = "Search";	/* Context sensitive help identifier */
@


1.8
log
@fix segfault trying to fnext a block-restricted search w/o any block
@
text
@d13 1
@


1.7
log
@all callers of restrict_to_block already check for srch->valid
@
text
@d933 1
a933 1
		globalsrch = 0;
d941 1
@


1.6
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d756 1
a756 1
	if (!srch->valid || !srch->block_restrict)
@


1.5
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/usearch.c,v 1.4 2010/01/02 15:41:04 tg Exp $ */
d102 1
a102 1
	P *p = pdup(bw->cursor);
@


1.4
log
@for search’n’replace, add (L)ast, which replaces the text in question
as if (Y)es had been selected, but quits the search afterwards instead
of continuing; the cursor is placed after the replacement (would before
be more appropriate? maybe, but this is consistent with the rest…)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/usearch.c,v 1.3 2008/05/13 13:08:29 tg Exp $ */
d106 1
a106 1
		int c = brch(bw->cursor);
d162 1
a162 1
		int c = brch(bw->cursor);
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d486 1
d721 1
a721 1
	else if (c == 'Y' || c == 'y' || c == ' ') {
d723 3
a725 5
		if (doreplace(bw, srch)) {
			pfsave(bw, srch);
			return -1;
		} else
			return dopfnext(bw, srch, notify);
d742 1
a742 1
	if (mkqwnsr(bw->parent, sc("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"), dopfrepl, pfsave, srch, notify))
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
	int start;
d233 1
a233 7
	if (word_list)
		varm(word_list);

	word_list = get_word_list(((BW *)bw->parent->win->object)->b, -1);

	if (!word_list) {
		ttputc(7);
a234 3
	}

	return simple_cmplt(bw,word_list);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 11
a11 1
/* Search & Replace system */
d13 3
d17 1
a18 1
#include "vs.h"
a21 1
#include "main.h"
d24 218
d243 2
a244 9
int smode=0;		/* Decremented to zero by execmd */
int csmode=0;		/* Set for continued search mode */

B *findhist=0;		/* Search string history */
B *replhist=0;		/* Replacement string history */

SRCH *globalsrch=0;	/* Most recent completed search data */

SRCHREC fsr={{&fsr,&fsr}};
d259 41
a299 27
P *searchf(srch,p)
SRCH *srch;
P *p;
 {
 char *pattern=srch->pattern;
 P *start=pdup(p);
 P *end=pdup(p);
 int x;
 for(x=0;x!=sLEN(pattern) && pattern[x]!='\\';++x)
  if(srch->ignore) pattern[x]=toup(pattern[x]);
 while(srch->ignore?pifind(start,pattern,x):pfind(start,pattern,x))
  {
  pset(end,start);
  pfwrd(end,(long)x);
  if(pmatch(srch->pieces,pattern+x,sLEN(pattern)-x,end,0,srch->ignore))
   {
   srch->entire=vstrunc(srch->entire,(int)(end->byte-start->byte));
   brmem(start,srch->entire,(int)(end->byte-start->byte));
   pset(p,end);
   prm(start); prm(end);
   return p;
   }
  if(pgetc(start)== MAXINT) break;
  }
 prm(start); prm(end);
 return 0;
 }
d315 42
a356 26
P *searchb(srch,p)
SRCH *srch;
P *p;
 {
 char *pattern=srch->pattern;
 P *start=pdup(p);
 P *end=pdup(p);
 int x;
 for(x=0;x!=sLEN(pattern) && pattern[x]!='\\';++x)
  if(srch->ignore) pattern[x]=toup(pattern[x]);
 while(pbkwd(start,1L) && (srch->ignore?prifind(start,pattern,x):prfind(start,pattern,x)))
  {
  pset(end,start);
  pfwrd(end,(long)x);
  if(pmatch(srch->pieces,pattern+x,sLEN(pattern)-x,end,0,srch->ignore))
   {
   srch->entire=vstrunc(srch->entire,(int)(end->byte-start->byte));
   brmem(start,srch->entire,(int)(end->byte-start->byte));
   pset(p,start);
   prm(start); prm(end);
   return p;
   }
  }
 prm(start); prm(end);
 return 0;
 }
d360 44
a403 39
SRCH *setmark(srch)
SRCH *srch;
 {
 if(markv(1)) srch->valid=1;

 srch->markb=markb;
 if(srch->markb) srch->markb->owner= &srch->markb;
 markb=0;

 srch->markk=markk;
 if(srch->markk) srch->markk->owner= &srch->markk;
 markk=0;

 return srch;
 }

SRCH *mksrch(pattern,replacement,ignore,backwards,repeat,replace,rest)
char *pattern, *replacement;
 {
 SRCH *srch=(SRCH *)malloc(sizeof(SRCH));
 int x;
 srch->pattern=pattern;
 srch->replacement=replacement;
 srch->ignore=ignore;
 srch->backwards=backwards;
 srch->repeat=repeat;
 srch->replace=replace;
 srch->rest=rest;
 srch->entire=0;
 srch->flg=0;
 srch->addr= -1;
 srch->markb=0;
 srch->markk=0;
 srch->valid=0;
 srch->restrict=0;
 izque(SRCHREC,link,&srch->recs);
 for(x=0;x!=26;++x) srch->pieces[x]=0;
 return srch;
 }
d407 26
a432 25
void rmsrch(srch)
SRCH *srch;
 {
 int x;
 prm(markb); prm(markk);
 if(srch->markb)
  {
  markb=srch->markb;
  markb->owner= &markb;
  markb->xcol=piscol(markb);
  }
 if(srch->markk)
  {
  markk=srch->markk;
  markk->owner= &markk;
  markk->xcol=piscol(markk);
  }
 for(x=0;x!=26;++x) vsrm(srch->pieces[x]);
 frchn(&fsr,&srch->recs);
 vsrm(srch->pattern);
 vsrm(srch->replacement);
 vsrm(srch->entire);
 free(srch);
 updall();
 }
d438 41
a478 42
P *insert(srch,p,s,len)
SRCH *srch;
P *p;
char *s;
 {
 int x;
 while(len)
  {
  for(x=0;x!=len && s[x]!='\\';++x);
  if(x)
   {
   binsm(p,s,x);
   pfwrd(p,(long)x);
   len-=x;
   s+=x;
   }
  else if(len>=2)
   {
   if(s[1]=='\\') binsc(p,'\\'), pgetc(p);
   else if(s[1]=='n') binsc(p,'\n'), pgetc(p);
   else if((s[1]>='a' && s[1]<='z' ||
           s[1]>='A' && s[1]<='Z') && srch->pieces[(s[1]&0x1f)-1])
    {
    binsm(p,sv(srch->pieces[(s[1]&0x1f)-1]));
    pfwrd(p,(long)sLEN(srch->pieces[(s[1]&0x1f)-1]));
    }
   else if(s[1]>='0' && s[1]<='9' && srch->pieces[s[1]-'0'])
    {
    binsm(p,sv(srch->pieces[s[1]-'0']));
    pfwrd(p,(long)sLEN(srch->pieces[s[1]-'0']));
    }
   else if(s[1]=='&' && srch->entire)
    {
    binsm(p,sv(srch->entire));
    pfwrd(p,(long)sLEN(srch->entire));
    }
   s+=2; len-=2;
   }
  else len=0;
  }
 return p;
 }
d485 1
a485 1
char srchstr[]="Search";	/* Context sensitive help identifier */
d487 178
a664 160
static int pfabort(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(srch) rmsrch(srch);
 return -1;
 }

static int pfsave(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(srch)
  {
  if(globalsrch) rmsrch(globalsrch);
  globalsrch=srch;
  srch->rest=0;
  srch->repeat= -1;
  srch->flg=0;

  prm(markb); prm(markk);
  if(srch->markb)
   {
   markb=srch->markb;
   markb->owner= &markb;
   markb->xcol=piscol(markb);
   }
  if(srch->markk)
   {
   markk=srch->markk;
   markk->owner= &markk;
   markk->xcol=piscol(markk);
   }
  srch->markb=0; srch->markk=0;

  updall();
  }
 return -1;
 }

static int set_replace(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 srch->replacement=s;
 return dopfnext(bw,srch,notify);
 }

static int set_options(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 int x;
 for(x=0;s[x];++x)
  switch(s[x])
   {
  case 'r': case 'R': srch->replace=1; break;
  case 'b': case 'B': srch->backwards=1; break;
  case 'i': case 'I': srch->ignore=1; break;
  case 'k': case 'K': srch->restrict=1; break;
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
   if(srch->repeat== -1) srch->repeat=0;
   srch->repeat=srch->repeat*10+s[x]-'0';
   break;
   }
 vsrm(s);
 if(srch->replace)
  {
  if(wmkpw(bw,
           "Replace with (^C to abort): ",&replhist,set_replace,srchstr,pfabort,utypebw,srch,notify))
   return 0;
  else return -1;
  }
 else return dopfnext(bw,srch,notify);
 }

static int set_pattern(bw,s,srch,notify)
BW *bw;
char *s;
SRCH *srch;
int *notify;
 {
 BW *pbw;
 vsrm(srch->pattern); srch->pattern=s;
 if(pbw=wmkpw(bw,
          "(I)gnore (R)eplace (B)ackwards Bloc(K) NNN (^C to abort): ",
          NULL,set_options,srchstr,pfabort,utypebw,srch,notify))
  {
  char buf[10];
  if(srch->ignore) binsc(pbw->cursor,'i');
  if(srch->replace) binsc(pbw->cursor,'r');
  if(srch->backwards) binsc(pbw->cursor,'b');
  if(srch->repeat>=0) sprintf(buf,"%d",srch->repeat), binss(pbw->cursor,buf);
  pset(pbw->cursor,pbw->b->eof);
  pbw->cursor->xcol=piscol(pbw->cursor);
  srch->ignore=0;
  srch->replace=0;
  srch->backwards=0;
  srch->repeat= -1;
  return 0;
  }
 else
  {
  rmsrch(srch);
  return -1;
  }
 }

static int dofirst(bw,back,repl)
BW *bw;
 {
 SRCH *srch;
 if(smode && globalsrch)
  {
  globalsrch->backwards=back;
  globalsrch->replace=repl;
  return pfnext(bw);
  }
 if(bw->parent->huh==srchstr)
  {
  long byte;
  peol(bw->cursor);
  byte=bw->cursor->byte;
  pbol(bw->cursor);
  if(byte==bw->cursor->byte) prgetc(bw->cursor);
  return urtn(bw,MAXINT);
  }
 srch=setmark(mksrch(NULL,NULL,0,back,-1,repl,0));
 srch->addr=bw->cursor->byte;
 if(wmkpw(bw,"Find (^C to abort): ",&findhist,set_pattern,srchstr,pfabort,utypebw,srch,NULL))
  return 0;
 else
  {
  rmsrch(srch);
  return -1;
  }
 }

int pffirst(bw)
BW *bw;
 {
 return dofirst(bw,0,0);
 }

int prfirst(bw)
BW *bw;
 {
 return dofirst(bw,1,0);
 }

int pqrepl(bw)
BW *bw;
 {
 return dofirst(bw,0,1);
 }
d668 88
a755 84
static int doreplace(bw,srch)
BW *bw;
SRCH *srch;
 {
 P *q;
 if(bw->b->rdonly) { msgnw(bw,"Read only"); return -1; }
 if(markk) markk->end=1;
 if(srch->markk) srch->markk->end=1;
 q=pdup(bw->cursor);
 if(srch->backwards)
  {
  q=pfwrd(q,(long)sLEN(srch->entire));
  bdel(bw->cursor,q);
  prm(q);
  }
 else
  {
  q=pbkwd(q,(long)sLEN(srch->entire));
  bdel(q,bw->cursor);
  prm(q);
  }
 insert(srch,bw->cursor,sv(srch->replacement));
 srch->addr=bw->cursor->byte;
 if(markk) markk->end=0;
 if(srch->markk) srch->markk->end=0;
 return 0;
 }

static void visit(srch,bw,yn)
SRCH *srch;
BW *bw;
 {
 SRCHREC *r=(SRCHREC *)alitem(&fsr,sizeof(SRCHREC));
 r->addr=bw->cursor->byte;
 r->yn=yn;
 enqueb(SRCHREC,link,&srch->recs,r);
 }

static void goback(srch,bw)
SRCH *srch;
BW *bw;
 {
 SRCHREC *r=srch->recs.link.prev;
 if(r!=&srch->recs)
  {
  if(r->yn) uundo(bw);
  if(bw->cursor->byte!=r->addr) pgoto(bw->cursor,r->addr);
  demote(SRCHREC,link,&fsr,r);
  }
 }

static int dopfrepl(bw,c,srch,notify)
BW *bw;
SRCH *srch;
int *notify;
 {
 srch->addr=bw->cursor->byte;
 if(c=='N' || c=='n')
  return dopfnext(bw,srch,notify);
 else if(c=='Y' || c=='y' || c==' ')
  {
  srch->recs.link.prev->yn=1;
  if(doreplace(bw,srch))
   {
   pfsave(bw,srch);
   return -1;
   }
  else return dopfnext(bw,srch,notify);
  }
 else if(c=='R' || c=='r')
  { if(doreplace(bw,srch)) return -1; srch->rest=1; return dopfnext(bw,srch,notify); }
 else if(c==8 || c==127 || c=='b' || c=='B')
  { goback(srch,bw); goback(srch,bw); return dopfnext(bw,srch,notify); }
 else if(c!=MAXINT)
  {
  if(notify) *notify=1;
  pfsave(bw,srch);
  nungetc(c);
  return 0;
  }
 if(mkqwnsr(bw,sc("Replace (Y)es (N)o (R)est (B)ackup (^C to abort)?"),dopfrepl,pfsave,srch,notify))
  return 0;
 else return pfsave(bw,srch);
 }
d763 33
a795 34
int restrict(bw,srch)
BW *bw;
SRCH *srch;
 {
 if(!srch->valid || !srch->restrict) return 0;
 bw->cursor->xcol=piscol(bw->cursor);
 if(srch->backwards)
  if(!square)
   {
   if(bw->cursor->byte<srch->markb->byte) return 1;
   else if(bw->cursor->byte+sLEN(srch->entire)>srch->markk->byte) return -1;
   }
  else
   {
   if(bw->cursor->line<srch->markb->line) return 1;
   else if(bw->cursor->line>srch->markk->line) return -1;
   else if(piscol(bw->cursor)+sLEN(srch->entire)>srch->markk->xcol ||
           piscol(bw->cursor)<srch->markb->xcol) return -1;
   }
 else
  if(!square)
   {
   if(bw->cursor->byte>srch->markk->byte) return 1;
   else if(bw->cursor->byte-sLEN(srch->entire)<srch->markb->byte) return -1;
   }
  else
   {
   if(bw->cursor->line>srch->markk->line) return 1;
   if(bw->cursor->line<srch->markb->line) return -1;
   if(piscol(bw->cursor)>srch->markk->xcol ||
      piscol(bw->cursor)-sLEN(srch->entire)<srch->markb->xcol) return -1;
   }
 return 0;
 }
d803 150
a952 121
static int fnext(bw,srch)
BW *bw;
SRCH *srch;
 {
 P *sta;
 next:
 if(srch->repeat!= -1)
  if(!srch->repeat) return 0;
  else --srch->repeat;
 again: if(srch->backwards) sta=searchb(srch,bw->cursor);
 else sta=searchf(srch,bw->cursor);
 if(!sta)
  {
  srch->repeat= -1;
  return 1;
  }
 else
  if(srch->rest || srch->repeat!= -1 && srch->replace)
   {
   if(srch->valid)
    switch(restrict(bw,srch))
     {
     case -1: goto again;
     case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); return !srch->rest;
     }
   if(doreplace(bw,srch)) return 0;
   goto next;
   }
  else if(srch->repeat!= -1)
   {
   if(srch->valid)
    switch(restrict(bw,srch))
     {
     case -1: goto again;
     case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); return 1;
     }
   srch->addr=bw->cursor->byte;
   goto next;
   }
  else return 2;
 }

int dopfnext(bw,srch,notify)
BW *bw;
SRCH *srch;
int *notify;
 {
 int orgmid=mid;	/* Original mid status */
 int ret=0;
 mid=1;			/* Screen recenters mode during search */
 if(csmode) smode=2;	/* We have started a search mode */
 if(srch->replace) visit(srch,bw,0);
 again: switch(fnext(bw,srch))
  {
  case 0:
  break;
  
  case 1:
  bye: if(!srch->flg && !srch->rest)
   {
   if(srch->valid && srch->restrict)
    msgnw(bw,"Not found (search restricted to marked block)");
   else msgnw(bw,"Not found");
   ret= -1;
   }
  break;

  case 2:
  if(srch->valid)
   switch(restrict(bw,srch))
    {
    case -1: goto again;
    case 1: if(srch->addr>=0) pgoto(bw->cursor,srch->addr); goto bye;
    }
  srch->addr=bw->cursor->byte;
  if(srch->replace)
   {
   if(square) bw->cursor->xcol=piscol(bw->cursor);
   if(srch->backwards)
    {
    pdupown(bw->cursor,&markb); markb->xcol=piscol(markb);
    pdupown(markb,&markk);
    pfwrd(markk,(long)sLEN(srch->entire));
    markk->xcol=piscol(markk);
    }
   else
    {
    pdupown(bw->cursor,&markk); markk->xcol=piscol(markk);
    pdupown(bw->cursor,&markb);
    pbkwd(markb,(long)sLEN(srch->entire));
    markb->xcol=piscol(markb);
    }
   srch->flg=1;
   if(dopfrepl(bw,MAXINT,srch,notify)) ret= -1;
   notify=0;
   srch=0;
   }
  break;
  }
 bw->cursor->xcol=piscol(bw->cursor);
 dofollows();
 mid=orgmid;
 if(notify) *notify=1;
 if(srch) pfsave(bw,srch);
 else updall();
 return ret;
 }

int pfnext(bw)
BW *bw;
 {
 if(!globalsrch)	/* Query for search string if there isn't any */
  return pffirst(bw);
 else
  {
  SRCH *srch=globalsrch;
  globalsrch=0;
  srch->addr=bw->cursor->byte;
  return dopfnext(bw,setmark(srch),NULL);
  }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
