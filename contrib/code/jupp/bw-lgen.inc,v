head	1.5;
access;
symbols
	joe-3_1jupp38:1.5
	joe-3_1jupp37:1.5;
locks; strict;
comment	@# @;


1.5
date	2018.06.28.03.11.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005B3451F152D05FB7;

1.4
date	2018.06.28.01.51.47;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005B343F433F058BCD;

1.3
date	2018.06.28.01.31.02;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005B343A6719F4E31D;

1.2
date	2018.06.27.22.46.53;	author tg;	state Exp;
branches;
next	1.1;
commitid	1005B3413E257F1945A;

1.1
date	2018.06.27.22.39.02;	author tg;	state Exp;
branches;
next	;
commitid	1005B3411E2160E1C42;


desc
@@


1.5
log
@missing optimisation
@
text
@/*
 *	Edit buffer single line update core loop (twice)
 *	Copyright © 1992 Joseph H. Allen
 *	Copyright © 2018 mirabilos
 *
 *	This file is part of jupp (Joe’s Own Editor fork)
 */

#ifdef LGEN_Q
__IDSTRING(rcsid_bw_lgen_inc, "$MirOS: contrib/code/jupp/bw-lgen.inc,v 1.3 2018/06/28 01:31:02 tg Exp $");
#define XCOL col
#else
#define XCOL (scr + x - ox)
#endif

 LGEN_LABEL(loop):
	/* Display next character */
	if (!amnt)
		goto LGEN_LABEL(noamnt);
	do {
		if (ungetit == -1)
			bc = *bp++;
		else {
			bc = ungetit;
			ungetit = -1;
		}
		if (st != -1)
			atr = syn[idx++];
		if (utf8_sm.state && !(bc & 0x80))
			goto LGEN_LABEL(ilseq);
		if (p->b->o.crlf && bc == '\r') {
			++byte;
			if (!--amnt) {
 LGEN_LABEL(pl):
				if (bp == p->ptr + SEGSIZ) {
					if (pnext(p)) {
						bp = p->ptr;
						amnt = p->hdr->hole;
					} else
						goto LGEN_LABEL(nl);
				} else {
					bp = p->ptr + p->hdr->ehole;
					amnt = SEGSIZ - p->hdr->ehole;
					if (!amnt)
						goto LGEN_LABEL(pl);
				}
			}
			if (*bp == '\n') {
				++bp;
				++byte;
				++amnt;
				goto eobl;
			}
 LGEN_LABEL(nl):
			--byte;
			++amnt;
		}
		if (square)
			if (bc == '\t') {
				long tcol = XCOL + p->b->o.tab -
				    (XCOL % p->b->o.tab);

				if (tcol > from && tcol <= to)
					c1 = INVERSE;
				else
					c1 = 0;
			} else if (XCOL >= from && XCOL < to)
				c1 = INVERSE;
			else
				c1 = 0;
		else if (byte >= from && byte < to)
			c1 = INVERSE;
		else
			c1 = 0;
		++byte;
		if (bc == '\t') {
			ta = p->b->o.tab - (XCOL % p->b->o.tab);
#ifdef LGEN_Q
			if (ta + col > scr) {
				ta -= scr - col;
				goto dota_tab;
			}
			if ((col += ta) == scr) {
				--amnt;
				goto v_loop;
			}
#else
 dota_tab:
			tach1 = tach = ' ';
			if (bw->o.vispace)
				tach = 0x2192;
			goto dota_gen;
 dota_loop:
			tach = tach1;
 dota_gen:
			outatr(utf8_map, t, screen + x, attr + x,
			    x, y, tach, c1 | atr);
			if (have)
				goto bye;
			if (++x == w)
				goto eosl;
			if (--ta)
				goto dota_loop;
#endif
		} else if (bc == '\n') {
			goto eobl;
		} else {
			int wid = -1;

			/*
			 * should be p->b->o.charmap->type logically
			 * but they are identical here, and it helps
			 * static analysers like Coverity
			 */
			if (bw->b->o.charmap->type) {
				/* UTF-8 */
				c = utf8_decode(&utf8_sm, bc);

				if (c >= 0) {
					/* Normal decoded character */
					wid = joe_wcwidth(c);
				} else if (c == -1) {
					/* Character taken */
					wid = -1;
				} else if (c == -2) {
					/* Incomplete sequence */
					--byte;
 LGEN_LABEL(ilseq):
					++amnt;
					ungetit = bc;
					c = 0x1000FFFE;
					wid = utf8_sm.ptr;
					utf8_init(&utf8_sm);
				} else if (c == -3) {
					/* Invalid byte */
					c = 0x1000FFFE;
					wid = 1;
				}
			} else {
				/* 8-bit charmap */
				c = bc;
				wid = 1;
			}

			if (wid >= 0) {
#ifdef LGEN_Q
				col += wid;
				if (col == scr) {
					--amnt;
					goto v_loop;
				} else if (col > scr) {
					ta = col - scr;
					tach1 = tach = '<';
					goto dota_gen;
				}
#else
				if (x + wid > w) {
					/* Character hits rightmost column */
					while (x < w) {
						/* Display offscreen marker */
						outatr(bw->b->o.charmap,
						    t, screen + x, attr + x,
						    x, y, '>', c1 | atr);
						x++;
					}
				} else if (c == 0x1000FFFE) while (wid--) {
					outatr(bw->b->o.charmap, t,
					    screen + x, attr + x,
					    x, y, 0xFFFD,
					    (c1 | atr | UNDERLINE) ^ INVERSE);
					x++;
				} else if (c == 0x20 && bw->o.vispace) {
					outatr(utf8_map, t,
					    screen + x, attr + x,
					    x, y, 0xB7, c1 | atr);
					x++;
				} else {
					outatr(bw->b->o.charmap, t,
					    screen + x, attr + x,
					    x, y, c, c1 | atr);
					x += wid;
				}
#endif
			} else
				/* Get highlighting character again */
				--idx;
#ifndef LGEN_Q
			if (have)
				goto bye;
			if (x >= w)
				goto eosl;
#endif
		}
	} while (--amnt);
 LGEN_LABEL(noamnt):
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto LGEN_LABEL(loop);
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto LGEN_LABEL(loop);
	}
	if (utf8_sm.state)
		goto LGEN_LABEL(ilseq);
	goto eof;

#undef XCOL
@


1.4
log
@fix another corner case; fix incomplete multibyte sequence at EOF
@
text
@d176 1
a176 1
					x += wid;
@


1.3
log
@harmonise fixes to interrupted sequences
@
text
@d10 1
a10 1
__IDSTRING(rcsid_bw_lgen_inc, "$MirOS$");
a126 1
					++amnt;
d129 1
d207 2
@


1.2
log
@reindent, shaving off a level
@
text
@d29 2
a76 4
#ifndef LGEN_Q /*XXX*/
			if (utf8_sm.state)
				goto LGEN_LABEL(ilseq);
#endif
a105 4
#ifndef LGEN_Q /*XXX*/
			if (utf8_sm.state)
				goto LGEN_LABEL(ilseq);
#endif
d117 1
a117 1
				c = utf8_decode(&utf8_sm,bc);
d127 2
a128 1
#ifndef LGEN_Q /*XXX*/
a129 1
#endif
a130 2
					++amnt;
					--byte;
@


1.1
log
@factor out lgen core code, which exists twice, almost identcally
(a “quiet” and a “verbose” mode); also, extend verbose mode UTF-8
early abort for tab after incomplete multibyte sequence

still bogus: not in quiet mode, only ungets previous octet
@
text
@d18 27
a44 7
	if (amnt)
		do {
			if (ungetit == -1)
				bc = *bp++;
			else {
				bc = ungetit;
				ungetit = -1;
d46 2
a47 3
			if (st != -1)
				atr = syn[idx++];
			if (p->b->o.crlf && bc == '\r') {
a48 23
				if (!--amnt) {
 LGEN_LABEL(pl):
					if (bp == p->ptr + SEGSIZ) {
						if (pnext(p)) {
							bp = p->ptr;
							amnt = p->hdr->hole;
						} else
							goto LGEN_LABEL(nl);
					} else {
						bp = p->ptr + p->hdr->ehole;
						amnt = SEGSIZ - p->hdr->ehole;
						if (!amnt)
							goto LGEN_LABEL(pl);
					}
				}
				if (*bp == '\n') {
					++bp;
					++byte;
					++amnt;
					goto eobl;
				}
 LGEN_LABEL(nl):
				--byte;
d50 1
d52 8
a59 4
			if (square)
				if (bc == '\t') {
					long tcol = XCOL + p->b->o.tab -
					    (XCOL % p->b->o.tab);
d61 1
a61 5
					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (XCOL >= from && XCOL < to)
d65 1
a65 1
			else if (byte >= from && byte < to)
d69 6
a74 2
			++byte;
			if (bc == '\t') {
d76 2
a77 2
				if (utf8_sm.state)
					goto LGEN_LABEL(ilseq);
d79 1
a79 1
				ta = p->b->o.tab - (XCOL % p->b->o.tab);
d81 8
a88 8
				if (ta + col > scr) {
					ta -= scr - col;
					goto dota_tab;
				}
				if ((col += ta) == scr) {
					--amnt;
					goto v_loop;
				}
d91 4
a94 4
				tach1 = tach = ' ';
				if (bw->o.vispace)
					tach = 0x2192;
				goto dota_gen;
d96 1
a96 1
				tach = tach1;
d98 8
a105 8
				outatr(utf8_map, t, screen + x, attr + x,
				    x, y, tach, c1 | atr);
				if (have)
					goto bye;
				if (++x == w)
					goto eosl;
				if (--ta)
					goto dota_loop;
d107 1
a107 1
			} else if (bc == '\n') {
d109 2
a110 2
				if (utf8_sm.state)
					goto LGEN_LABEL(ilseq);
d112 3
a114 3
				goto eobl;
			} else {
				int wid = -1;
d116 8
a123 8
				/*
				 * should be p->b->o.charmap->type logically
				 * but they are identical here, and it helps
				 * static analysers like Coverity
				 */
				if (bw->b->o.charmap->type) {
					/* UTF-8 */
					c = utf8_decode(&utf8_sm,bc);
d125 8
a132 8
					if (c >= 0) {
						/* Normal decoded character */
						wid = joe_wcwidth(c);
					} else if (c == -1) {
						/* Character taken */
						wid = -1;
					} else if (c == -2) {
						/* Incomplete sequence */
d136 9
a144 14
						ungetit = bc;
						++amnt;
						--byte;
						c = 0x1000FFFE;
						wid = utf8_sm.ptr;
						utf8_init(&utf8_sm);
					} else if (c == -3) {
						/* Invalid byte */
						c = 0x1000FFFE;
						wid = 1;
					}
				} else {
					/* 8-bit charmap */
					c = bc;
d147 5
d153 1
a153 1
				if (wid >= 0) {
d155 9
a163 9
					col += wid;
					if (col == scr) {
						--amnt;
						goto v_loop;
					} else if (col > scr) {
						ta = col - scr;
						tach1 = tach = '<';
						goto dota_gen;
					}
d165 7
a171 13
					if (x + wid > w) {
						/* If character hits right most column, don't display it */
						while (x < w) {
							outatr(bw->b->o.charmap,
							    t, screen + x, attr + x,
							    x, y, '>', c1 | atr);
							x++;
						}
					} else if (c == 0x1000FFFE) while (wid--) {
						outatr(bw->b->o.charmap, t,
						    screen + x, attr + x,
						    x, y, 0xFFFD,
						    (c1 | atr | UNDERLINE) ^ INVERSE);
a172 10
					} else if (c == 0x20 && bw->o.vispace) {
						outatr(utf8_map, t,
						    screen + x, attr + x,
						    x, y, 0xB7, c1 | atr);
						x += wid;
					} else {
						outatr(bw->b->o.charmap, t,
						    screen + x, attr + x,
						    x, y, c, c1 | atr);
						x += wid;
d174 17
d192 3
a194 3
				} else
					/* Get highlighting character again */
					--idx;
d196 4
a199 4
				if (have)
					goto bye;
				if (x >= w)
					goto eosl;
d201 3
a203 2
			}
		} while (--amnt);
@

