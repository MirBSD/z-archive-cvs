head	1.14;
access;
symbols
	joe-3_1jupp38:1.14
	joe-3_1jupp37:1.14
	joe-3_1jupp36:1.14
	joe-3_1jupp35:1.14
	joe-3_1jupp34:1.14
	joe-3_1jupp33:1.14
	joe-3_1jupp32:1.11
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.9
	joe-3_1jupp30:1.9
	joe-3_1jupp29:1.8
	joe-3_1jupp28:1.7
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.5
	joe-3_1jupp25:1.5
	joe-3_1jupp24:1.5
	joe-3_1jupp23:1.5
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.14
date	2018.01.07.20.39.33;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A5285A07BFFE686;

1.13
date	2018.01.07.20.32.48;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A5284063C3E386D;

1.12
date	2018.01.06.00.28.35;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A50184621FA8455;

1.11
date	2017.12.08.02.00.43;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A29F2506E789D2B;

1.10
date	2017.12.02.02.07.38;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A220AD65C90E687;

1.9
date	2017.01.10.19.16.28;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005875332028CA2A36;

1.8
date	2016.10.30.00.19.57;	author tg;	state Exp;
branches;
next	1.7;
commitid	10058153CC249071686;

1.7
date	2014.07.25.11.44.34;	author tg;	state Exp;
branches;
next	1.6;
commitid	10053D2432C3629C8A2;

1.6
date	2014.06.26.18.15.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	10053AC63477EECD548;

1.5
date	2012.12.22.00.06.16;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050D4F965570AEE79;

1.4
date	2012.06.08.16.55.29;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004FD22E961A7F5A95;

1.3
date	2010.01.03.18.22.04;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004B40E05D33D0D68A;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@tiny optimisations
@
text
@/*
 *	Variable length strings
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/vs.c,v 1.11 2017/12/08 02:00:43 tg Exp $");

#include <stdlib.h>

#include "blocks.h"
#include "utils.h"
#include "vs.h"

sELEMENT *
vsmk(int len)
{
	sELEMENT *rv;

	rv = jalloc(NULL, len, sizeof(sELEMENT));
	rv[0] = sterm;
	return (rv);
}

void
vsrm(sELEMENT *vary)
{
	jfree(vary);
}

int slen(const sELEMENT *ary)
{
	const sELEMENT *beg = ary;

	if (!ary)
		return (0);
	while (scmp(*ary, sterm))
		++ary;
	return (ary - beg);
}

sELEMENT *
vsensure(sELEMENT *vary, int len)
{
	sELEMENT *rv;

	if (vary && len > sSiz(vary))
		len += (len >> 2);
	rv = jalloc(vary, len, sizeof(sELEMENT));
	if (!vary)
		rv[0] = sterm;
	return (rv);
}

sELEMENT *vstrunc(sELEMENT *vary, int len)
{
	if (!vary || len > sLEN(vary))
		vary = vsensure(vary, len + 16);
	if (len < sLen(vary)) {
		vary[len] = vary[sLen(vary)];
		sLen(vary) = len;
	} else if (len > sLen(vary)) {
		vary = vsfill(vary, sLen(vary), sblank, len - sLen(vary));
	}
	return vary;
}

sELEMENT *vsfill(sELEMENT *vary, int pos, sELEMENT el, int len)
{
	int olen = sLEN(vary), x;

	if (!vary || pos + len > sSIZ(vary))
		vary = vsensure(vary, pos + len);
	if (pos + len > olen) {
		vary[pos + len] = vary[olen];
		sLen(vary) = pos + len;
	}
	for (x = pos; x != pos + len; ++x)
		vary[x] = sdup(el);
	if (pos > olen)
		vary = vsfill(vary, pos, sblank, pos - olen);
	return vary;
}

sELEMENT *vsncpy(sELEMENT *vary, int pos, const sELEMENT *array, int len)
{
	int olen = sLEN(vary);

	if (!vary || pos + len > sSIZ(vary))
		vary = vsensure(vary, pos + len);
	if (pos + len > olen) {
		vary[pos + len] = vary[olen];
		sLen(vary) = pos + len;
	}
	if (pos > olen)
		vary = vsfill(vary, olen, sblank, pos - olen);
#ifdef TEST
	memmove(vary + pos, array, len * sizeof(sELEMENT));
#else
	mmove(vary + pos, array, len * sizeof(sELEMENT));
#endif
	return vary;
}

sELEMENT *vsndup(sELEMENT *vary, int pos, sELEMENT *array, int len)
{
	int olen = sLEN(vary), x;

	if (!vary || pos + len > sSIZ(vary))
		vary = vsensure(vary, pos + len);
	if (pos + len > olen) {
		vary[pos + len] = vary[olen];
		sLen(vary) = pos + len;
	}
	if (pos > olen)
		vary = vsfill(vary, olen, sblank, pos - olen);
	for (x = pos; x != len; ++x)
		vary[x] = sdup(array[x]);
	return vary;
}

sELEMENT *vsdup(sELEMENT *vary)
{
	return vsndup(NULL, 0, vary, sLEN(vary));
}

sELEMENT *_vsset(sELEMENT *vary, int pos, sELEMENT el)
{
	if (!vary || pos + 1 > sSIZ(vary))
		vary = vsensure(vary, pos + 1);
	if (pos > sLen(vary)) {
		vary = vsfill(vary, sLen(vary), sblank, pos - sLen(vary));
		vary[pos + 1] = vary[pos];
		vary[pos] = el;
		sLen(vary) = pos + 1;
	} else if (pos == sLen(vary)) {
		vary[pos + 1] = vary[pos];
		vary[pos] = el;
		sLen(vary) = pos + 1;
	} else {
		sdel(vary[pos]);
		vary[pos] = el;
	}
	return vary;
}

int vsbsearch(const sELEMENT *ary, int len, sELEMENT el)
{
	int x, y, z;

	if (!ary || !len)
		return 0;
	y = len;
	x = 0;
	z = ~0;
	while (z != (x + y) / 2) {
		z = (x + y) / 2;
		switch (scmp(el, ary[z])) {
		case 1:
			x = z;
			break;
		case -1:
			y = z;
			break;
		case 0:
			return z;
		}
	}
	return y;
}

int vscmpn(sELEMENT *a, int alen, sELEMENT *b, int blen)
{
	int x, l;
	int t;

	if (!a && !b)
		return 0;
	if (!a)
		return -1;
	if (!b)
		return 1;
	if (alen > blen)
		l = sLen(a);
	else
		l = blen;
	for (x = 0; x != l; ++x)
		if ((t = scmp(a[x], b[x])) != 0)
			return t;
	if (alen > blen)
		return 1;
	if (alen < blen)
		return -1;
	return 0;
}

int vscmp(sELEMENT *a, sELEMENT *b)
{
	return vscmpn(sv(a), sv(b));
}

int vsscan(const sELEMENT *a, int alen, const sELEMENT *b, int blen)
{
	int x;

	for (x = 0; x != alen; ++x) {
		int z = vsbsearch(b, blen, a[x]);

		if (z < blen && !scmp(b[z], a[x]))
			return x;
	}
	return ~0;
}

int
vsspan(const sELEMENT *a, int alen, const sELEMENT *b, int blen)
{
	int x;

	/* should not happen */
	if (!b)
		return (0);

	for (x = 0; x != alen; ++x) {
		int z = vsbsearch(b, blen, a[x]);

		if (z == blen || scmp(b[z], a[x]))
			break;
	}
	return x;
}
@


1.13
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d37 7
a43 7
	if (ary) {
		const sELEMENT *beg = ary;
		while (scmp(*ary, sterm))
			++ary;
		return ary - beg;
	} else
		return 0;
@


1.12
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d19 2
a20 1
sELEMENT *vsmk(int len)
d22 1
a22 1
	int *new = malloc((1 + len) * sizeof(sELEMENT) + 2 * sizeof(int));
d24 3
a26 4
	new[0] = len;
	new[1] = 0;
	((sELEMENT *)(new + 2))[0] = sdup(sterm);
	return (sELEMENT *)(new + 2);
d29 2
a30 1
void vsrm(sELEMENT *vary)
d32 1
a32 2
	if (vary)
		free((int *)vary - 2);
d46 2
a47 1
sELEMENT *vsensure(sELEMENT *vary, int len)
d49 5
d55 2
a56 8
		vary = vsmk(len);
	else if (len > sSiz(vary)) {
		len += (len >> 2);
		vary = (sELEMENT *)(2 + (int *)realloc((int *)vary - 2, (len + 1) * sizeof(sELEMENT) + 2 * sizeof(int)));

		sSiz(vary) = len;
	}
	return vary;
@


1.11
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/vs.c,v 1.10 2017/12/02 02:07:38 tg Exp $");
d219 2
a220 1
int vsspan(sELEMENT *a, int alen, sELEMENT *b, int blen)
@


1.10
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d21 1
a21 1
	int *new = (int *) joe_malloc((1 + len) * sizeof(sELEMENT) + 2 * sizeof(int));
d32 1
a32 1
		joe_free((int *) vary - 2);
d52 1
a52 1
		vary = (sELEMENT *)(2 + (int *) joe_realloc((int *) vary - 2, (len + 1) * sizeof(sELEMENT) + 2 * sizeof(int)));
@


1.9
log
@these now all need <stdlib.h>
@
text
@a0 1
/* $MirOS: contrib/code/jupp/vs.c,v 1.6 2014/06/26 18:15:17 tg Exp $ */
d11 2
a94 1
	mkssert(vary != NULL);
@


1.8
log
@sprinke some const-cleanliness
@
text
@d12 2
@


1.7
log
@remove broken (LP#1348559) but also unused code; thanks dcb
@
text
@d149 1
a149 1
int vsbsearch(sELEMENT *ary, int len, sELEMENT el)
d204 1
a204 1
int vsscan(sELEMENT *a, int alen, sELEMENT *b, int blen)
@


1.6
log
@make everything with a main() compile, too
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.c,v 1.5 2012/12/22 00:06:16 tg Exp $ */
a15 9
int sicmp(unsigned char a, unsigned char b)
{
	if (a >= 'A' || a <= 'Z')
		a += 'a' - 'A';
	if (b >= 'A' || b <= 'Z')
		b += 'a' - 'A';
	return scmp(a, b);
}

@


1.5
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.c,v 1.4 2012/06/08 16:55:29 tg Exp $ */
d108 3
d112 1
@


1.4
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.c,v 1.3 2010/01/03 18:22:04 tg Exp $ */
d101 1
d226 4
@


1.3
log
@begin const cleanup
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vs.c,v 1.2 2008/05/13 13:08:32 tg Exp $ */
a152 41
#ifdef junk

sELEMENT *vsins(sELEMENT *vary, int pos, int n)
{
	if (!vary || sLEN(vary) + n > sSIZ(vary))
		vary = vsensure(vary, sLEN(vary) + n);
	if (pos >= sLen(vary))
		vary = vstrunc(vary, pos + n);
	else {
		mmove(vary + pos + n, vary + pos, sLen(vary) - (pos + n) + 1);
		sLen(vary) += n;
	}
	return vary;
}

sELEMENT *vsdel(sELEMENT *vary, int pos, int n)
{
	if (pos >= sLEN(vary))
		return vary;
	if (pos + n >= sLen(vary))
		return vstrunc(vary, pos);
	mmove(vary + pos, vary + pos + n, sLen(vary) - (pos + n) + 1);
	sLen(vary) -= n;
	return vary;
}

int _scmp(sELEMENT a, sELEMENT b)
{
	return scmp(a, b);
}

sELEMENT *vssort(sELEMENT *ary, int len)
{
	if (!ary || !len)
		return ary;
	qsort(ary, len, sizeof(sELEMENT), _scmp);
	return ary;
}

#endif

a177 30
#ifdef junk

int vsfirst(sELEMENT *ary, int len, sELEMENT el)
{
	int x;

	if (!ary || !len)
		return ~0;
	for (x = 0; x != len; ++x)
		if (!scmp(ary[x], el))
			return x;
	return ~0;
}

int vslast(sELEMENT *ary, int len, sELEMENT el)
{
	int x = len;

	if (!ary || !len)
		return ~0;
	do {
		--x;
		if (!scmp(ary[x], el))
			return x;
	} while (x);
	return ~0;
}

#endif

a206 45
#ifdef junk
int vsicmpn(sELEMENT *a, int alen, sELEMENT *b, int blen)
{
	int x, l;
	int t;

	if (!a && !b)
		return 0;
	if (!a)
		return -1;
	if (!b)
		return 1;
	if (alen > blen)
		l = sLen(a);
	else
		l = blen;
	for (x = 0; x != l; ++x)
		if (t = sicmp(a[x], b[x]))
			return t;
	if (alen > blen)
		return 1;
	if (alen < blen)
		return -1;
	return 0;
}

int vss(sELEMENT *a, int alen, sELEMENT *b, int blen)
{
	int x;

	if (!a && !b)
		return 0;
	if (!a || !b)
		return ~0;
	if (alen < blen)
		return ~0;
	if (!blen)
		return 0;
	for (x = 0; x != alen - blen; ++x)
		if (!vscmpn(a, blen, b, blen))
			return x;
	return ~0;
}

#endif
a232 43

#ifdef junk

sELEMENT *vsread(sELEMENT d, int p, int (*getC)(), void *ptr)
{
	int c;

	if (!d)
		d = vsmk(10);
	c = getC(ptr);
	if (c == NO_MORE_DATA) {
		vsrm(d);
		return NULL;
	} else if (c == '\n')
		return d;
	else {
		d = vsset(d, p, c);
		p++;
	}
	while (c = getC(ptr), c != NO_MORE_DATA && c != '\n') {
		d = vsset(d, p, c);
		p++;
	}
	return d;
}

sELEMENT *vwords(sELEMENT *s, sELEMENT **a, int len, sELEMENT t)
{
	int x;

	if (!s)
		s = vsmk(32);
	else
		s = vstrunc(s, 0);
	for (x = 0; x != len; ++x) {
		s = vsncpy(s, sLEN(s), sz(a[x]));
		if (a[1])
			s = vsadd(s, t);
	}
	return s;
}

#endif
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d41 1
a41 1
int slen(sELEMENT *ary)
d44 1
a44 1
		sELEMENT *beg = ary;
d95 1
a95 1
sELEMENT *vsncpy(sELEMENT *vary, int pos, sELEMENT *array, int len)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 13
a13 2
/* Variable length strings
   Copyright (C) 1992 Joseph H. Allen
d15 8
a22 1
This file is part of JOE (Joe's Own Editor)
d24 3
a26 3
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  
d28 5
a32 4
JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  
d34 24
a57 3
You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d59 72
a130 5
#include <varargs.h>
#include "config.h"
#include "zstr.h"
#include "blocks.h"
#include "vs.h"
d132 1
a132 2
int sicmp(a,b)
char a,b;
d134 16
a149 148
if(a>='A' || a<='Z') a+='a'-'A';
if(b>='A' || b<='Z') b+='a'-'A';
return scmp(a,b);
}

sELEMENT(*vsmk(len))
int len;
{
int *new=(int *)malloc((1+len)*sizeof(sCAST)+2*sizeof(int));
new[0]=len;
new[1]=0;
((sELEMENT(*))(new+2))[0]=sdup(sterm);
return (sELEMENT(*))(new+2);
}

void vsrm(vary)
sELEMENT(*vary);
{
if(vary) free((int *)vary-2);
}

int slen(ary)
sELEMENT(*ary);
{
if(ary)
 {
 sELEMENT(*beg)=ary;
 while(scmp(*ary,sterm)) ++ary;
 return ary-beg;
 }
else return 0;
}

sELEMENT(*vsensure(vary,len))
sELEMENT(*vary);
int len;
{
if(!vary) vary=vsmk(len);
else if(len>sSiz(vary))
 {
 len+=(len>>2);
 vary=(sELEMENT(*))(2+(int *)realloc(
       (int *)vary-2,(len+1)*sizeof(sCAST)+2*sizeof(int) ));
 sSiz(vary)=len;
 }
return vary;
}

sELEMENT(*vstrunc(vary,len))
sELEMENT(*vary);
int len;
{
if(!vary || len>sLEN(vary)) vary=vsensure(vary,len+16);
if(len<sLen(vary))
 {
 vary[len]=vary[sLen(vary)];
 sLen(vary)=len;
 }
else if(len>sLen(vary))
 {
 vary=vsfill(vary,sLen(vary),sblank,len-sLen(vary));
 }
return vary;
}

sELEMENT(*vsfill(vary,pos,el,len))
sELEMENT(*vary);
sELEMENT(el);
int pos,len;
{
int olen=sLEN(vary), x;
if(!vary || pos+len>sSIZ(vary))
 vary=vsensure(vary,pos+len);
if(pos+len>olen)
 {
 vary[pos+len]=vary[olen];
 sLen(vary)=pos+len;
 }
for(x=pos;x!=pos+len;++x) vary[x]=sdup(el);
if(pos>olen) vary=vsfill(vary,pos,sblank,pos-olen);
return vary;
}

sELEMENT(*vsncpy(vary,pos,array,len))
sELEMENT(*vary);
sELEMENT(*array);
int pos, len;
{
int olen=sLEN(vary);
if(!vary || pos+len>sSIZ(vary)) vary=vsensure(vary,pos+len);
if(pos+len>olen)
 {
 vary[pos+len]=vary[olen];
 sLen(vary)=pos+len;
 }
if(pos>olen) vary=vsfill(vary,olen,sblank,pos-olen);
mfwrd(vary+pos,array,len*sizeof(sCAST));
return vary;
}

sELEMENT(*vsndup(vary,pos,array,len))
sELEMENT(*vary);
sELEMENT(*array);
int pos, len;
{
int olen=sLEN(vary), x;
if(!vary || pos+len>sSIZ(vary)) vary=vsensure(vary,pos+len);
if(pos+len>olen)
 {
 vary[pos+len]=vary[olen];
 sLen(vary)=pos+len;
 }
if(pos>olen) vary=vsfill(vary,olen,sblank,pos-olen);
for(x=pos;x!=len;++x) vary[x]=sdup(array[x]);
return vary;
}

sELEMENT(*vsdup(vary))
sELEMENT(*vary);
{
return vsndup(NULL,0,vary,sLEN(vary));
}

sELEMENT(*_vsset(vary,pos,el))
sELEMENT(*vary);
sELEMENT(el);
int pos;
{
if(!vary || pos+1>sSIZ(vary)) vary=vsensure(vary,pos+1);
if(pos>sLen(vary))
 {
 vary=vsfill(vary,sLen(vary),sblank,pos-sLen(vary));
 vary[pos+1]=vary[pos];
 vary[pos]=el;
 sLen(vary)=pos+1;
 }
else if(pos==sLen(vary))
 {
 vary[pos+1]=vary[pos];
 vary[pos]=el;
 sLen(vary)=pos+1;
 }
else
 {
 sdel(vary[pos]);
 vary[pos]=el;
 }
return vary;
d154 1
a154 3
sELEMENT(*vsins(vary,pos,n))
sELEMENT(*vary);
int pos,n;
d156 9
a164 8
if(!vary || sLEN(vary)+n>sSIZ(vary)) vary=vsensure(vary,sLEN(vary)+n);
if(pos>=sLen(vary)) vary=vstrunc(vary,pos+n);
else
 {
 mbkwd(vary+pos+n,vary+pos,sLen(vary)-(pos+n)+1);
 sLen(vary)+=n;
 }
return vary;
d167 1
a167 3
sELEMENT(*vsdel(vary,pos,n))
sELEMENT(*vary);
int pos,n;
d169 7
a175 5
if(pos>=sLEN(vary)) return vary;
if(pos+n>=sLen(vary)) return vstrunc(vary,pos);
mfwrd(vary+pos,vary+pos+n,sLen(vary)-(pos+n)+1);
sLen(vary)-=n;
return vary;
d178 1
a178 3
int _scmp(a,b)
sELEMENT(a);
sELEMENT(b);
d180 1
a180 1
return scmp(a,b);
d183 1
a183 3
sELEMENT(*vssort(ary,len))
sELEMENT(*ary);
int len;
d185 4
a188 3
if(!ary || !len) return ary;
qsort(ary,len,sizeof(sCAST),_scmp);
return ary;
d193 23
a215 21
int vsbsearch(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x,y,z;
if(!ary || !len) return 0;
y=len;
x=0;
z=~0;
while(z!=(x+y)/2)
 {
 z=(x+y)/2;
 switch(scmp(el,ary[z]))
  {
 case  1: x=z; break;
 case -1: y=z; break;
 case  0: return z;
  }
 }
return y;
d220 24
a243 25
int vsfirst(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x;
if(!ary || !len) return ~0;
for(x=0;x!=len;++x) if(!scmp(ary[x],el)) return x;
return ~0;
}

int vslast(ary,len,el)
sELEMENT(*ary);
sELEMENT(el);
int len;
{
int x=len;
if(!ary || !len) return ~0;
do
 {
 --x;
 if(!scmp(ary[x],el)) return x;
 }
 while(x);
return ~0;
d248 26
a273 21
int vscmpn(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x,l;
int t;
if(!a && !b) return 0;
if(!a) return -1;
if(!b) return 1;
if(alen>blen) l=sLen(a);
else l=blen;
for(x=0;x!=l;++x) if(t=scmp(a[x],b[x])) return t;
if(alen>blen) return  1;
if(alen<blen) return -1;
return 0;
}

int vscmp(a,b)
sELEMENT(*a);
sELEMENT(*b);
d275 1
a275 1
return vscmpn(sv(a),sv(b));
d278 41
a318 30
int vsicmpn(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x,l;
int t;
if(!a && !b) return 0;
if(!a) return -1;
if(!b) return 1;
if(alen>blen) l=sLen(a);
else l=blen;
for(x=0;x!=l;++x) if(t=sicmp(a[x],b[x])) return t;
if(alen>blen) return  1;
if(alen<blen) return -1;
return 0;
}

int vss(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
if(!a && !b) return 0;
if(!a || !b) return ~0;
if(alen<blen) return ~0;
if(!blen) return 0;
for(x=0;x!=alen-blen;++x) if(!vscmpn(a,blen,b,blen)) return x;
return ~0;
d323 24
a346 26
int vsscan(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
 {
 int z=vsbsearch(b,blen,a[x]);
 if(z<blen && !scmp(b[z],a[x])) return x;
 }
return ~0;
}

int vsspan(a,alen,b,blen)
sELEMENT(*a);
sELEMENT(*b);
int alen, blen;
{
int x;
for(x=0;x!=alen;++x)
 {
 int z=vsbsearch(b,blen,a[x]);
 if(z==blen || scmp(b[z],a[x])) break;
 }
return x;
d351 37
a387 29
sELEMENT(*vsread(d,p,getC,ptr))
sELEMENT(*d);
int (*getC)();
int p;
void *ptr;
{
int c;
if(!d) d=vsmk(10);
c=getC(ptr);
if(c== MAXINT) { vsrm(d); return 0; }
else if(c== '\n') return d;
else d=vsset(d,p,c), p++; 
while(c=getC(ptr), c!= MAXINT && c!= '\n') d=vsset(d,p,c), p++;
return d;
}

sELEMENT(*vwords(s,a,len,t))
char **a, *s, t;
int len;
{
int x;
if(!s) s=vsmk(32);
else s=vstrunc(s,0);
for(x=0;x!=len;++x)
 {
 s=vsncpy(s,sLEN(s),sz(a[x]));
 if(a[1]) s=vsadd(s,t);
 }
return s;
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
