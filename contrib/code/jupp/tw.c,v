head	1.23;
access;
symbols
	joe-3_1jupp38:1.23
	joe-3_1jupp37:1.22
	joe-3_1jupp36:1.21
	joe-3_1jupp35:1.21
	joe-3_1jupp34:1.21
	joe-3_1jupp33:1.21
	joe-3_1jupp32:1.20
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.12
	joe-3_1jupp30:1.10
	joe-3_1jupp29:1.9
	joe-3_1jupp28:1.8
	joe-3_1jupp27:1.8
	joe-3_1jupp26:1.8
	joe-3_1jupp25:1.8
	joe-3_1jupp24:1.8
	joe-3_1jupp23:1.8
	joe-3_1jupp22:1.8
	joe-3_1jupp21:1.8
	joe-3_1jupp20:1.8
	joe-3_1jupp19:1.8
	joe-3_1jupp18:1.7
	joe-3_1jupp17:1.7
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.7
	joe-3_1jupp15:1.7
	joe-3_1jupp14:1.7
	joe-3_1jupp12:1.6
	joe-3_1jupp11:1.4
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.4
	joe-3_1jupp9:1.4
	joe-3_1jupp8:1.4
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.23
date	2018.11.11.18.15.38;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005BE871D325833018;

1.22
date	2018.06.26.20.23.35;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005B32A0D42EFE67E9;

1.21
date	2018.01.06.00.28.33;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A50184621FA8455;

1.20
date	2017.12.08.03.24.15;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A2A05EB07C8D953;

1.19
date	2017.12.08.02.28.07;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A29F8C708B176AB;

1.18
date	2017.12.08.02.17.23;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A29F64A06DEB239;

1.17
date	2017.12.08.02.00.41;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A29F2506E789D2B;

1.16
date	2017.12.07.02.10.17;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A28A3145E1FF911;

1.15
date	2017.12.06.23.17.35;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A287AA407E73F9C;

1.14
date	2017.12.06.23.02.05;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A2876FC4FFE7EF5;

1.13
date	2017.12.02.02.07.33;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A220AD65C90E687;

1.12
date	2017.03.19.18.53.02;	author tg;	state Exp;
branches;
next	1.11;
commitid	10058CED3A126D01360;

1.11
date	2017.03.19.17.38.59;	author tg;	state Exp;
branches;
next	1.10;
commitid	10058CEC24420FBEA52;

1.10
date	2017.01.10.19.16.28;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005875332028CA2A36;

1.9
date	2016.10.08.16.42.00;	author tg;	state Exp;
branches;
next	1.8;
commitid	10057F921EB68DE163A;

1.8
date	2012.06.07.22.16.09;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004FD12822341B4DF9;

1.7
date	2010.04.08.15.31.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004BBDF6C54CC9A0DB;

1.6
date	2009.10.18.14.52.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004ADB2BD317498872;

1.5
date	2009.10.06.09.07.30;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004ACB08E905F8F83E;

1.4
date	2007.02.18.22.34.08;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045D8D46C7CE52506;

1.3
date	2007.02.18.22.23.55;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045D8D1DC2DC9B867;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Text editing windows
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.22 2018/06/26 20:23:35 tg Exp $");

#include <stdlib.h>
#include <string.h>
#ifdef HAVE_TIME_H
#include <time.h>
#endif

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "qw.h"
#include "scrn.h"
#include "uedit.h"
#include "ufile.h"
#include "ushell.h"
#include "utils.h"
#include "vs.h"
#include "syntax.h"
#include "charmap.h"
#include "tw.h"
#include "w.h"

#if !HAVE_DECL_CTIME
char *ctime(const time_t *);
#endif

extern int square;
int staen = 0;
int staupd = 0;
int keepup = 0;

/* Move text window */

static void movetw(jobject jO, int x, int y)
{
	BW *bw = jO.bw;
	TW *tw = (TW *) bw->object;

	if (y || !staen) {
		if (!tw->staon) {	/* Scroll down and shrink */
			nscrldn(bw->parent->t->t, y, bw->parent->nh + y, 1);
		}
		bwmove(bw, x + (bw->o.linums ? LINCOLS : 0), y + 1);
		tw->staon = 1;
	} else {
		if (tw->staon) {	/* Scroll up and grow */
			nscrlup(bw->parent->t->t, y, bw->parent->nh + y, 1);
		}
		bwmove(bw, x + (bw->o.linums ? LINCOLS : 0), y);
		tw->staon = 0;
	}
}

/* Resize text window */

static void resizetw(jobject jO, int wi, int he)
{
	BW *bw = jO.bw;

	if (bw->parent->ny || !staen)
		bwresz(bw, wi - (bw->o.linums ? LINCOLS : 0), he - 1);
	else
		bwresz(bw, wi - (bw->o.linums ? LINCOLS : 0), he);
}

/* Get current context */

/* Find first line (going backwards) which has 0 indentation level
 * and is not a comment, blank, or block structuring line.  This is
 * likely to be the line with the function name.
 *
 * There are actually two possibilities:
 *
 * We want the first line-
 *
 * int
 * foo(int x,int y) {
 *
 *   }
 *
 * We want the last line-
 *
 * program foo(input,output);
 * var a, b, c : real;
 * begin
 *
 */

static unsigned char *
get_context(BW *bw)
{
	P *p = pdup(bw->cursor);
	static unsigned char buf1[stdsiz];


	buf1[0] = 0;
	/* Find first line with 0 indentation which is not a comment line */
	do {
		p_goto_bol(p);
		if (!pisindent(p) && !pisblank(p)) {
			/* Uncomment to get the last line instead of the first line (see above)
 next:
			*/
			brzs(p,stdbuf,stdsiz-1);
			/* Ignore comment and block structuring lines */
			if (!(stdbuf[0]=='{' ||
			    (stdbuf[0]=='/' && stdbuf[1]=='*') ||
			    (stdbuf[0]=='\f') ||
			    (stdbuf[0]=='/' && stdbuf[1]=='/') ||
			    (stdbuf[0]=='#') ||
			    ((stdbuf[0] | 0x20) == 'b' && (stdbuf[1] | 0x20) == 'e' && (stdbuf[2] | 0x20) == 'g' && (stdbuf[3] | 0x20) == 'i' && (stdbuf[4] | 0x20) == 'n') ||
			    (stdbuf[0]=='-' && stdbuf[1]=='-') ||
			    stdbuf[0]==';')) {
				strlcpy(buf1,stdbuf,stdsiz);
				/* Uncomment to get the last line instead of the first line (see above)
				if (pprevl(p)) {
					p_goto_bol(p);
					if (!pisindent(p) && !pisblank(p))
						goto next;
				}
				*/
				break;
			}

		}
	} while (!buf1[0] && pprevl(p));

	prm(p);

	return buf1;
}

static unsigned char *
stagen(unsigned char *stalin, BW *bw, const unsigned char *s, int fill)
{
	const unsigned char *ccp;
	unsigned char *cp, uc;
	unsigned char buf[80];
	int x;
	W *w = bw->parent;
	time_t tt;
	int special_aA = 0;

	ccp = s;
	while ((cp = strstr(ccp, "%a")) != NULL) {
		cp += /* %a */ 2;
		if (cp[1] == '%')
			++cp;
		if (cp[0] == '%' && cp[1] == 'A') {
			special_aA = 1;
			break;
		}
	}
	if (!special_aA) while ((cp = strstr(ccp, "%A")) != NULL) {
		cp += /* %A */ 2;
		if (cp[1] == '%')
			++cp;
		if (cp[0] == '%' && cp[1] == 'a') {
			special_aA = 1;
			break;
		}
	}

	stalin = vstrunc(stalin, 0);
	while (*s) {
		if (*s == '%' && s[1]) {
			switch (*++s) {
			case 'x':
				/* Context (but only if autoindent is enabled) */
				if (bw->o.autoindent) {
					ccp = get_context(bw);
					stalin = vsncpy(sv(stalin), sz(ccp));
				}
				break;

			case 'y':
				if (bw->o.syntax) {
					joe_snprintf_1((char *)buf, sizeof(buf), "(%s)", bw->o.syntax->name);
					stalin = vsncpy(sv(stalin), sz(buf));
				}
				break;
			case 't':
				tt = time(NULL);
				ccp = (unsigned char *)ctime(&tt);

				x = (ccp[11] - '0') * 10 + ccp[12] - '0';
				if (x > 12)
					x -= 12;
				joe_snprintf_1((char *)buf, sizeof(buf), "%2.2d", x);
				if (buf[0] == '0')
					buf[0] = fill;
				stalin = vsncpy(sv(stalin), buf, 2);
				stalin = vsncpy(sv(stalin), ccp + 13, 3);
				break;
			case 'u':
				tt = time(NULL);
				ccp = (unsigned char *)ctime(&tt);
				stalin = vsncpy(sv(stalin), ccp + 11, 5);
				break;
			case 'T':
				if (bw->o.overtype)
					stalin = vsadd(stalin, 'O');
				else
					stalin = vsadd(stalin, 'I');
				break;
			case 'W':
				if (bw->o.wordwrap)
					stalin = vsadd(stalin, 'W');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'I':
				if (bw->o.autoindent)
					stalin = vsadd(stalin, 'A');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'X':
				if (square)
					stalin = vsadd(stalin, 'X');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'n':
				if (!bw->b->name) {
					stalin = vsncpy(sv(stalin), sc("Unnamed"));
					break;
				}
				ccp = bw->b->name;
 escape_loop:
				switch ((uc = *ccp++)) {
				case '\\':
					stalin = vsadd(stalin, uc);
					/* FALLTHROUGH */
				default:
					stalin = vsadd(stalin, uc);
					goto escape_loop;
				case '\0':
					break;
				}
				break;
			case 'm':
				if (bw->b->changed)
					stalin = vsncpy(sv(stalin), sc("(Modified)"));
				break;
			case 'R':
				if (bw->b->rdonly)
					stalin = vsncpy(sv(stalin), sc("(Read only)"));
				break;
			case '*':
				if (bw->b->changed)
					stalin = vsadd(stalin, '*');
				else
					stalin = vsadd(stalin, fill);
				break;
			case 'r':
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->cursor->line + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'o':
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->cursor->byte);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'O':
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4lX", bw->cursor->byte);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'a':
				if (bw->b->o.charmap->type && !(special_aA && (brch(bw->cursor) & 0x80000000))) {
					/* UTF-8: don't display decimal value */
					buf[0] = 'u';
					buf[1] = 0;
				} else {
					if (!piseof(bw->cursor))
						joe_snprintf_1((char *)buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
					else
						joe_snprintf_0((char *)buf, sizeof(buf), "   ");
					for (x = 0; buf[x]; ++x)
						if (buf[x] == ' ')
							buf[x] = fill;
				}
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'A':
				if (bw->b->o.charmap->type) {
					/* UTF-8, display UCS-2 value */
					if (!piseof(bw->cursor)) {
						int uch = brch(bw->cursor);
						if (uch & 0x80000000)
							joe_snprintf_1((char *)buf, sizeof(buf), special_aA ? "%02X" : "  %02X", uch & 0xFF);
						else
							joe_snprintf_1((char *)buf, sizeof(buf), "%04X", uch);
					} else
						joe_snprintf_0((char *)buf, sizeof(buf), "    ");
				} else {
					if (!piseof(bw->cursor))
						joe_snprintf_1((char *)buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
					else
						joe_snprintf_0((char *)buf, sizeof(buf), "  ");
				}
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'c':
				joe_snprintf_1((char *)buf, sizeof(buf), "%-3ld", piscol(bw->cursor) + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'p':
				if (bw->b->eof->byte)
					joe_snprintf_1((char *)buf, sizeof(buf), "%3ld", bw->cursor->byte * 100 / bw->b->eof->byte);
				else
					joe_snprintf_0((char *)buf, sizeof(buf), "100");
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'l':
				joe_snprintf_1((char *)buf, sizeof(buf), "%-4ld", bw->b->eof->line + 1);
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
				stalin = vsncpy(sv(stalin), sz(buf));
				break;
			case 'k':
				cp = buf;
				buf[0] = 0;
				if (w->kbd->x && w->kbd->seq[0])
					for (x = 0; x != w->kbd->x; ++x) {
						uc = w->kbd->seq[x] & 127;

						if (uc < 32) {
							cp[0] = '^';
							cp[1] = uc + '@@';
							cp += 2;
						} else if (uc == 127) {
							cp[0] = '^';
							cp[1] = '?';
							cp += 2;
						} else {
							cp[0] = uc;
							cp += 1;
						}
					}
				*cp++ = fill;
				while (cp - buf < 4)
					*cp++ = fill;
				stalin = vsncpy(sv(stalin), buf, cp - buf);
				break;
			case 'S':
				if (bw->b->pid)
					stalin = vsncpy(sv(stalin), sc("*SHELL*"));
				break;
			case 'M':
				if (recmac) {
					joe_snprintf_1((char *)buf, sizeof(buf), "(Macro %d recording...)", recmac->n);
					stalin = vsncpy(sv(stalin), sz(buf));
				}
				break;
			default:
				stalin = vsadd(stalin, *s);
			}
		} else
			stalin = vsadd(stalin, *s);
		++s;
	}
	return stalin;
}

static void disptw(jobject jO, int flg)
{
	BW *bw = jO.bw;
	W *w = bw->parent;
	TW *tw = (TW *) bw->object;

	if (bw->o.linums != bw->linums) {
		bw->linums = bw->o.linums;
		resizetw(jO, w->w, w->h);
		movetw(jO, w->x, w->y);
		bwfllw(jO);
	}

	if (bw->o.hex) {
		w->cury = (bw->cursor->byte-bw->top->byte)/16 + bw->y - w->y;
		w->curx = (bw->cursor->byte-bw->top->byte)%16 + 60 - bw->offset;
	} else {
		w->cury = bw->cursor->line - bw->top->line + bw->y - w->y;
		w->curx = bw->cursor->xcol - bw->offset + (bw->o.linums ? LINCOLS : 0);
	}

	if ((staupd || keepup || bw->cursor->line != tw->prevline || bw->b->changed != tw->changed || bw->b != tw->prev_b) && (w->y || !staen)) {
		int fill;

		tw->prevline = bw->cursor->line;
		tw->changed = bw->b->changed;
		tw->prev_b = bw->b;
		if (bw->o.rmsg[0])
			fill = bw->o.rmsg[0];
		else
			fill = ' ';
		tw->stalin = stagen(tw->stalin, bw, bw->o.lmsg, fill);
		tw->staright = stagen(tw->staright, bw, bw->o.rmsg, fill);
		if (fmtlen(tw->staright) < w->w) {
			int x = fmtpos(tw->stalin, w->w - fmtlen(tw->staright));

			if (x > sLEN(tw->stalin))
				tw->stalin = vsfill(sv(tw->stalin), fill, x - sLEN(tw->stalin));
			tw->stalin = vsncpy(tw->stalin, fmtpos(tw->stalin, w->w - fmtlen(tw->staright)), sv(tw->staright));
		}
		tw->stalin = vstrunc(tw->stalin, fmtpos(tw->stalin, w->w));
		genfmt(w->t->t, w->x, w->y, 0, tw->stalin, 0);
		w->t->t->updtab[w->y] = 0;
	}

	if (flg) {
		if (bw->o.hex)
			bwgenh(bw);
		else
			bwgen(bw, bw->o.linums);
	}
}

/* Split current window */

static void iztw(TW *tw, int y)
{
	tw->stalin = NULL;
	tw->staright = NULL;
	tw->changed = -1;
	tw->prevline = -1;
	tw->staon = (!staen || y);
	tw->prev_b = 0;
}

extern int dostaupd;

int usplitw(BW *bw)
{
	W *w = bw->parent;
	int newh = getgrouph(w);
	W *new;
	TW *newtw;
	BW *newbw;

	dostaupd = 1;
	if (newh / 2 < FITHEIGHT)
		return -1;
	new = wcreate(w->t, w->watom, findbotw(w), NULL, w, newh / 2 + (newh & 1), NULL, NULL);
	if (!new)
		return -1;
	wfit(new->t);
	new->object.bw = newbw = bwmk(new, bw->b, 0);
	++bw->b->count;
	newbw->offset = bw->offset;
	newbw->object = newtw = malloc(sizeof(TW));
	iztw(newtw, new->y);
	pset(newbw->top, bw->top);
	pset(newbw->cursor, bw->cursor);
	newbw->cursor->xcol = bw->cursor->xcol;
	new->t->curwin = new;
	return 0;
}

int uduptw(BW *bw)
{
	W *w = bw->parent;
	int newh = getgrouph(w);
	W *new;
	TW *newtw;
	BW *newbw;

	dostaupd = 1;
	new = wcreate(w->t, w->watom, findbotw(w), NULL, NULL, newh, NULL, NULL);
	if (!new)
		return -1;
	if (demotegroup(w))
		new->t->topwin = new;
	new->object.bw = newbw = bwmk(new, bw->b, 0);
	++bw->b->count;
	newbw->offset = bw->offset;
	newbw->object = newtw = malloc(sizeof(TW));
	iztw(newtw, new->y);
	pset(newbw->top, bw->top);
	pset(newbw->cursor, bw->cursor);
	newbw->cursor->xcol = bw->cursor->xcol;
	new->t->curwin = new;
	wfit(w->t);
	return 0;
}

static void instw(BW *bw, B *b, long int l, long int n, int flg)
{
	if (b == bw->b)
		bwins(bw, l, n, flg);
}

static void deltw(BW *bw, B *b, long int l, long int n, int flg)
{
	if (b == bw->b)
		bwdel(bw, l, n, flg);
}

WATOM watomtw = {
	UC "main",
	disptw,
	bwfllw,
	NULL,
	rtntw,
	utypebw,
	resizetw,
	movetw,
	instw,
	deltw,
	TYPETW
};

int abortit(BW *bw)
{
	W *w;
	TW *tw;
	B *b;
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	w = bw->parent;
	tw = (TW *) bw->object;
	/* If only one main window on the screen... */
	if (countmain(w->t) == 1)
		/* Replace it with an orphaned buffer if there are any */
		if ((b = borphan()) != NULL) {
			void *object = bw->object;
			/* FIXME: Shouldn't we wabort() and wcreate here to kill
			   any prompt windows? */

			bwrm(bw);
			w->object.bw = bw = bwmk(w, b, 0);
			wredraw(bw->parent);
			bw->object = object;
			return 0;
		}
	bwrm(bw);
	vsrm(tw->stalin);
	free(tw);
	w->object.base = NULL;
	wabort(w);	/* Eliminate this window and it's children */
	return 0;
}

/* User routine for aborting a text window */

static int naborttw(BW *bw, int k, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if ((k | 0x20) != 'y')
		return -1;

	genexmsg(bw, 0, NULL);
	return abortit(bw);
}

static int naborttw1(BW *bw, int k, void *object, int *notify)
{
	if (notify)
		*notify = 1;
	if ((k | 0x20) != 'y')
		return -1;

	if (!exmsg) genexmsg(bw, 0, NULL);
	return abortit(bw);
}

/* k is last character types which lead to uabort.  If k is -1, it means uabort
   was called internally, and not by the user: which means uabort will not send
   Ctrl-C to process */
int uabort(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch)
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), naborttw, NULL, NULL, NULL))
			return 0;
		else
			return -1;
	else
		return naborttw(bw, 'y', NULL, NULL);
}

int ucancel(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw) {
		wabort(bw->parent);
		return 0;
	} else
		return uabort(bw,k);
}

/* Same as above, but only calls genexmsg if nobody else has */

int uabort1(BW *bw, int k)
{
	if (bw->parent->watom != &watomtw)
		return wabort(bw->parent);
	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);
	if (bw->b->changed && bw->b->count == 1 && !bw->b->scratch)
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), naborttw1, NULL, NULL, NULL))
			return 0;
		else
			return -1;
	else
		return naborttw1(bw, 'y', NULL, NULL);
}

/* Abort buffer without prompting: just fail if this is last window on buffer */

int uabortbuf(BW *bw)
{
	W *w = bw->parent;
	B *b;

	if (bw->b->pid && bw->b->count==1)
		return ukillpid(bw);

	if (okrepl(bw))
		return -1;

	if ((b = borphan()) != NULL) {
		void *object = bw->object;

		bwrm(bw);
		w->object.bw = bw = bwmk(w, b, 0);
		wredraw(bw->parent);
		bw->object = object;
		return 0;
	}

	return naborttw(bw, 'y', NULL, NULL);
}

/* Kill current window (orphans buffer) */

int utw0(BASE *b)
{
	BW *bw = b->parent->main->object.bw;

	if (countmain(b->parent->t) == 1)
		return -1;
	if (bw->b->count == 1)
		orphit(bw);
	return uabort(bw, -1);
}

/* Kill all other windows (orphans buffers) */

int utw1(BASE *b)
{
	W *starting = b->parent;
	W *mainw = starting->main;
	SCREEN *t = mainw->t;
	int yn;

	do {
		yn = 0;
 loop:
		do {
			wnext(t);
		} while (t->curwin->main == mainw && t->curwin != starting);
		if (t->curwin->main != mainw) {
			BW *bw = t->curwin->main->object.bw;
			utw0((BASE *)bw);
			yn = 1;
			goto loop;
		}
	} while (yn);
	return 0;
}

void setline(B *b, long int line)
{
	W *w = maint->curwin;

	do {
		if (w->watom->what == TYPETW) {
			BW *bw = w->object.bw;

			if (bw->b == b) {
				long oline = bw->top->line;

				pline(bw->top, line);
				pline(bw->cursor, line);
				if (w->y >= 0 && bw->top->line > oline && bw->top->line - oline < bw->h)
					nscrlup(w->t->t, bw->y, bw->y + bw->h, (int) (bw->top->line - oline));
				else if (w->y >= 0 && bw->top->line < oline && oline - bw->top->line < bw->h)
					nscrldn(w->t->t, bw->y, bw->y + bw->h, (int) (oline - bw->top->line));
			}
		}
	} while ((w = w->link.next) != maint->curwin);
}

/* Create a text window.  It becomes the last window on the screen */

BW *wmktw(SCREEN *t, B *b)
{
	W *w;
	BW *bw;
	TW *tw;

	w = wcreate(t, &watomtw, NULL, NULL, NULL, t->h, NULL, NULL);
	if (!w)
		return (NULL);
	wfit(w->t);
	w->object.bw = bw = bwmk(w, b, 0);
	bw->object = tw = malloc(sizeof(TW));
	iztw(tw, w->y);
	return bw;
}
@


1.22
log
@redo invalid-UTF8 char handling; fixes ^B in such
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.21 2018/01/06 00:28:33 tg Exp $");
d743 2
@


1.21
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.20 2017/12/08 03:24:15 tg Exp $");
d294 1
a294 1
				if (bw->b->o.charmap->type && !(special_aA && brch(bw->cursor) == 0x1000FFFE)) {
d314 2
a315 4
						if (uch == 0x1000FFFE)
							joe_snprintf_1((char *)buf, sizeof(buf), special_aA ? "%02X" : "  %02X", 255 & brc(bw->cursor));
						else if (uch == 0x1000FFFF)
							joe_snprintf_0((char *)buf, sizeof(buf), "<-2>");
@


1.20
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.18 2017/12/08 02:17:23 tg Exp $");
d149 2
a150 1
static unsigned char *stagen(unsigned char *stalin, BW *bw, unsigned char *s, int fill)
d152 2
a153 1
	unsigned char *cp, *cp2, uc;
d160 6
a165 6
	cp = s;
	while ((cp2 = strstr(cp, "%a")) != NULL) {
		cp2 += /* %a */ 2;
		if (cp2[1] == '%')
			++cp2;
		if (cp2[0] == '%' && cp2[1] == 'A') {
d170 5
a174 5
	if (!special_aA) while ((cp2 = strstr(cp, "%A")) != NULL) {
		cp2 += /* %A */ 2;
		if (cp2[1] == '%')
			++cp2;
		if (cp2[0] == '%' && cp2[1] == 'a') {
d187 2
a188 2
					cp = get_context(bw);
					stalin = vsncpy(sv(stalin), sz(cp));
d200 1
a200 1
				cp = (unsigned char *)ctime(&tt);
d202 1
a202 1
				x = (cp[11] - '0') * 10 + cp[12] - '0';
d209 1
a209 1
				stalin = vsncpy(sv(stalin), cp + 13, 3);
d213 2
a214 2
				cp = (unsigned char *)ctime(&tt);
				stalin = vsncpy(sv(stalin), cp + 11, 5);
d245 1
a245 1
				cp = bw->b->name;
d247 1
a247 1
				switch ((uc = *cp++)) {
d536 1
a536 1
	US "main",
@


1.19
log
@label indent; small tweaks while here
@
text
@d127 1
a127 2
			    (stdbuf[0]=='b' && stdbuf[1]=='e' && stdbuf[2]=='g' && stdbuf[3]=='i' && stdbuf[4]=='n') ||
			    (stdbuf[0]=='B' && stdbuf[1]=='E' && stdbuf[2]=='G' && stdbuf[3]=='I' && stdbuf[4]=='N') ||
d586 1
a586 1
	if (k != 'y' && k != 'Y')
d597 1
a597 1
	if (k != 'y' && k != 'Y')
@


1.18
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.16 2017/12/07 02:10:17 tg Exp $");
d118 1
a118 1
			next:
d699 1
a699 1
	      loop:
@


1.17
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d131 1
a131 1
			    	strlcpy(buf1,stdbuf,stdsiz);
d133 7
a139 7
			    	if (pprevl(p)) {
			    		p_goto_bol(p);
			    		if (!pisindent(p) && !pisblank(p))
			    			goto next;
			    	}
			    	*/
			    	break;
@


1.16
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.15 2017/12/06 23:17:35 tg Exp $");
d486 1
a486 1
	newbw->object = (void *) (newtw = (TW *) joe_malloc(sizeof(TW)));
d512 1
a512 1
	newbw->object = (void *) (newtw = (TW *) joe_malloc(sizeof(TW)));
d575 1
a575 1
	joe_free(tw);
d746 1
a746 1
	bw->object = (void *)(tw = (TW *)joe_malloc(sizeof(TW)));
@


1.15
log
@whitespace at EOL annoys me
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.14 2017/12/06 23:02:05 tg Exp $");
d50 1
a50 1
static void movetw(BW *bw, int x, int y)
d52 1
d72 1
a72 1
static void resizetw(BW *bw, int wi, int he)
d74 2
d401 1
a401 1
static void disptw(BW *bw, int flg)
d403 1
d409 3
a411 3
		resizetw(bw, w->w, w->h);
		movetw(bw, w->x, w->y);
		bwfllw(bw);
d483 1
a483 1
	new->object = (void *) (newbw = bwmk(new, bw->b, 0));
d509 1
a509 1
	new->object = (void *) (newbw = bwmk(new, bw->b, 0));
d568 1
a568 1
			w->object = (void *) (bw = bwmk(w, b, 0));
d576 1
a576 1
	w->object = NULL;
d666 1
a666 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d679 1
a679 1
	BW *bw = b->parent->main->object;
d704 1
a704 1
			BW *bw = t->curwin->main->object;
d719 1
a719 1
			BW *bw = w->object;
d745 2
a746 2
	w->object = (void *) (bw = bwmk(w, b, 0));
	bw->object = (void *) (tw = (TW *) joe_malloc(sizeof(TW)));
@


1.14
log
@lots of fixes related to prototyping
@
text
@d1 1
a1 1
/* 
d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/tw.c,v 1.13 2017/12/02 02:07:33 tg Exp $");
d87 1
a87 1
 * We want the first line- 
d138 1
a138 1
			
@


1.13
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d36 1
d102 2
a103 1
unsigned char *get_context(BW *bw)
@


1.12
log
@fix some indenting, scoping, etc. catastrophes
@
text
@a0 1
/* $MirOS: contrib/code/jupp/tw.c,v 1.7 2010/04/08 15:31:04 tg Exp $ */
d11 2
a12 1
#include <stdio.h>
@


1.11
log
@include <string.h> before <bsd/string.h> to avoid problems on Haiku
@
text
@d147 1
d151 1
d154 8
a161 11
	{
		unsigned char *cp = s, *cp2;

		while ((cp2 = strstr(cp, "%a")) != NULL) {
			cp2 += /* %a */ 2;
			if (cp2[1] == '%')
				++cp2;
			if (cp2[0] == '%' && cp2[1] == 'A') {
				special_aA = 1;
				break;
			}
d163 8
a170 8
		if (!special_aA) while ((cp2 = strstr(cp, "%A")) != NULL) {
			cp2 += /* %A */ 2;
			if (cp2[1] == '%')
				++cp2;
			if (cp2[0] == '%' && cp2[1] == 'a') {
				special_aA = 1;
				break;
			}
d178 5
a182 6
			case 'x': /* Context (but only if autoindent is enabled) */
				{
					if ( bw->o.autoindent) {
						unsigned char *s_ = get_context(bw);
						stalin = vsncpy(sv(stalin), sz(s_));
					}
d187 3
a189 5
				{
					if (bw->o.syntax) {
						joe_snprintf_1((char *)buf, sizeof(buf), "(%s)", bw->o.syntax->name);
						stalin = vsncpy(sv(stalin), sz(buf));
					}
d193 11
a203 14
				{
					time_t n = time(NULL);
					int l;
					unsigned char *d = (unsigned char *)ctime(&n);

					l = (d[11] - '0') * 10 + d[12] - '0';
					if (l > 12)
						l -= 12;
					joe_snprintf_1((char *)buf, sizeof(buf), "%2.2d", l);
					if (buf[0] == '0')
						buf[0] = fill;
					stalin = vsncpy(sv(stalin), buf, 2);
					stalin = vsncpy(sv(stalin), d + 13, 3);
				}
d206 3
a208 6
				{
					time_t n = time(NULL);
					unsigned char *d = (unsigned char *)ctime(&n);

					stalin = vsncpy(sv(stalin), d + 11, 5);
				}
d234 6
a239 5
			case 'n': {
				unsigned char fnc;
				const unsigned char *fn = bw->b->name ? bw->b->name :
				    (const unsigned char *)"Unnamed";

d241 1
a241 1
				switch ((fnc = *fn++)) {
d243 1
a243 1
					stalin = vsadd(stalin, fnc);
d246 1
a246 1
					stalin = vsadd(stalin, fnc);
a251 1
			    }
d352 17
a368 21
				{
					int i;
					unsigned char *cpos_ = buf;

					buf[0] = 0;
					if (w->kbd->x && w->kbd->seq[0])
						for (i = 0; i != w->kbd->x; ++i) {
							int c = w->kbd->seq[i] & 127;

							if (c < 32) {
								cpos_[0] = '^';
								cpos_[1] = c + '@@';
								cpos_ += 2;
							} else if (c == 127) {
								cpos_[0] = '^';
								cpos_[1] = '?';
								cpos_ += 2;
							} else {
								cpos_[0] = c;
								cpos_ += 1;
							}
d370 5
a374 5
					*cpos_++ = fill;
					while (cpos_ - buf < 4)
						*cpos_++ = fill;
					stalin = vsncpy(sv(stalin), buf, cpos_ - buf);
				}
@


1.10
log
@these now all need <stdlib.h>
@
text
@d14 1
@


1.9
log
@fix filenames with backslashes (data corruption)
@
text
@d13 1
@


1.8
log
@• switch strlfun.c to symlinked strlfun.inc; add symlinked popen.inc
• new compat.c including the *.inc files if needed and providing ctime for klibc
@
text
@d242 16
a257 2
			case 'n':
				stalin = vsncpy(sv(stalin), sz(bw->b->name ? bw->b->name : (unsigned char *)"Unnamed"));
d259 1
@


1.7
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tw.c,v 1.6 2009/10/18 14:52:57 tg Exp $ */
d36 4
@


1.6
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tw.c,v 1.5 2009/10/06 09:07:30 tg Exp $ */
a35 1
extern unsigned char *exmsg;
d176 2
a177 2
						unsigned char *s = get_context(bw);
						stalin = vsncpy(sv(stalin), sz(s));
d343 1
a343 1
					unsigned char *cpos = buf;
d351 3
a353 3
								cpos[0] = '^';
								cpos[1] = c + '@@';
								cpos += 2;
d355 3
a357 3
								cpos[0] = '^';
								cpos[1] = '?';
								cpos += 2;
d359 2
a360 2
								cpos[0] = c;
								cpos += 1;
d363 4
a366 4
					*cpos++ = fill;
					while (cpos - buf < 4)
						*cpos++ = fill;
					stalin = vsncpy(sv(stalin), buf, cpos - buf);
@


1.5
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tw.c,v 1.4 2007/02/18 22:34:08 tg Exp $ */
d402 7
a408 2
	w->cury = bw->cursor->line - bw->top->line + bw->y - w->y;
	w->curx = bw->cursor->xcol - bw->offset + (bw->o.linums ? LINCOLS : 0);
d434 6
a439 2
	if (flg)
		bwgen(bw, bw->o.linums);
d522 1
a522 1
static WATOM watomtw = {
@


1.4
log
@use different replacement characters - fixes cursor position (joe_wcwidth…)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/tw.c,v 1.3 2007/02/18 22:23:55 tg Exp $ */
d17 4
@


1.3
log
@display UCS-2 values for %A and "u" for %a in UTF-8 mode,
unless we have a single invalid octet, which is displayed
as if in non-UTF-8 mode, or an invalid sequence with more
than one octet, which is printed as "u" and "<-2>"
@
text
@d1 1
a1 1
/* $MirOS$ */
d274 1
a274 1
				if (bw->b->o.charmap->type && !(special_aA && brch(bw->cursor) == 0xFFFE)) {
d294 1
a294 1
						if (uch == 0xFFFE)
d296 1
a296 1
						else if (uch == 0xFFFF)
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
d29 1
d141 24
d274 13
a286 7
				if (!piseof(bw->cursor))
					joe_snprintf_1((char *)buf, sizeof(buf), "%3d", 255 & brc(bw->cursor));
				else
					joe_snprintf_0((char *)buf, sizeof(buf), "   ");
				for (x = 0; buf[x]; ++x)
					if (buf[x] == ' ')
						buf[x] = fill;
d290 18
a307 4
				if (!piseof(bw->cursor))
					joe_snprintf_1((char *)buf, sizeof(buf), "%2.2X", 255 & brc(bw->cursor));
				else
					joe_snprintf_0((char *)buf, sizeof(buf), "  ");
@


1.1
log
@Initial revision
@
text
@d101 1
d103 1
d107 7
a113 7
			    stdbuf[0]=='/' && stdbuf[1]=='*' ||
			    stdbuf[0]=='\f' ||
			    stdbuf[0]=='/' && stdbuf[1]=='/' ||
			    stdbuf[0]=='#' ||
			    stdbuf[0]=='b' && stdbuf[1]=='e' && stdbuf[2]=='g' && stdbuf[3]=='i' && stdbuf[4]=='n' ||
			    stdbuf[0]=='B' && stdbuf[1]=='E' && stdbuf[2]=='G' && stdbuf[3]=='I' && stdbuf[4]=='N' ||
			    stdbuf[0]=='-' && stdbuf[1]=='-' ||
d115 1
a115 1
			    	strcpy(buf1,stdbuf);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 4
 /* Text editing windows
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)
d11 4
a14 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
a15 4
#include "config.h"
#include "w.h"
#include "termcap.h"
#include "vfile.h"
a16 2
#include "tty.h"
#include "scrn.h"
d18 1
a18 4
#include "zstr.h"
#include "vs.h"
#include "help.h"
#include "undo.h"
d20 2
a21 1
#include "macro.h"
d25 4
a28 2
#include "qw.h"
#include "tw.h"
d30 1
a30 2
char *ctime();
extern char *exmsg;
d32 3
a34 3
int staen=0;
int staupd=0;
int keepup=0;
d38 18
a55 24
static void movetw(bw,x,y)
BW *bw;
int x,y;
 {
 TW *tw=(TW *)bw->object;
 if(y || !staen)
  {
  if(!tw->staon)
   { /* Scroll down and shrink */
   nscrldn(bw->parent->t->t,y,bw->parent->nh+y,1);
   }
  bwmove(bw,x+(bw->o.linums?LINCOLS:0),y+1);
  tw->staon=1;
  }
 else
  {
  if(tw->staon)
   { /* Scroll up and grow */
   nscrlup(bw->parent->t->t,y,bw->parent->nh+y,1);
   }
  bwmove(bw,x+(bw->o.linums?LINCOLS:0),y);
  tw->staon=0;
  }
 }
d59 36
a94 216
static void resizetw(bw,wi,he)
BW *bw;
int wi,he;
 {
 if(bw->parent->ny || !staen)
  bwresz(bw,wi-(bw->o.linums?LINCOLS:0),he-1);
 else
  bwresz(bw,wi-(bw->o.linums?LINCOLS:0),he);
 }

char *stagen(stalin,bw,s,fill)
char *stalin;
BW *bw;
char *s;
 {
 char buf[80];
 int x;
 W *w=bw->parent;
 stalin=vstrunc(stalin,0);
 while(*s)
  {
  if(*s=='%' && s[1])
   switch(*++s)
    {
    case 't':
     {
     long n=time(NULL);
     int l;
     char *d=ctime(&n);
     l=(d[11]-'0')*10+d[12]-'0';
     if(l>12) l-=12;
     sprintf(buf,"%2.2d",l);
     if(buf[0]=='0') buf[0]=fill;
     stalin=vsncpy(sv(stalin),buf,2);
     stalin=vsncpy(sv(stalin),d+13,3);
     }
    break;

    case 'u':
     {
     long n=time(NULL);
     char *d=ctime(&n);
     stalin=vsncpy(sv(stalin),d+11,5);
     }
    break;

    case 'T':
    if(bw->o.overtype) stalin=vsadd(stalin,'O');
    else stalin=vsadd(stalin,'I');
    break;
    
    case 'W':
    if(bw->o.wordwrap) stalin=vsadd(stalin,'W');
    else stalin=vsadd(stalin,fill);
    break;

    case 'I':
    if(bw->o.autoindent) stalin=vsadd(stalin,'A');
    else stalin=vsadd(stalin,fill);
    break;

    case 'X':
    if(square) stalin=vsadd(stalin,'X');
    else stalin=vsadd(stalin,fill);
    break;

    case 'n':
    stalin=vsncpy(sv(stalin),sz(bw->b->name?bw->b->name:"Unnamed"));
    break;

    case 'm':
    if(bw->b->changed)
     stalin=vsncpy(sv(stalin),sc("(Modified)"));
    break;

    case 'R':
    if(bw->b->rdonly)
     stalin=vsncpy(sv(stalin),sc("(Read only)"));
    break;

    case '*':
    if(bw->b->changed)
     stalin=vsadd(stalin,'*');
    else
     stalin=vsadd(stalin,fill);
    break;

    case 'r':
    sprintf(buf,"%-4ld",bw->cursor->line+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'o':
    sprintf(buf,"%-4ld",bw->cursor->byte);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'O':
    sprintf(buf,"%-4lX",bw->cursor->byte);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'a':
    if(!piseof(bw->cursor)) sprintf(buf,"%3d",255&brc(bw->cursor));
    else sprintf(buf,"   ");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'A':
    if(!piseof(bw->cursor)) sprintf(buf,"%2.2X",255&brc(bw->cursor));
    else sprintf(buf,"  ");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'c':
    sprintf(buf,"%-3ld",piscol(bw->cursor)+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'p':
    if(bw->b->eof->byte)
     sprintf(buf,"%3ld",bw->cursor->byte*100/bw->b->eof->byte);
    else
     sprintf(buf,"100");
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'l':
    sprintf(buf,"%-4ld",bw->b->eof->line+1);
    for(x=0;buf[x];++x) if(buf[x]==' ') buf[x]=fill;
    stalin=vsncpy(sv(stalin),sz(buf));
    break;

    case 'k':
     {
     int i;
     char *cpos=buf;
     buf[0]=0;
     if(w->kbd->x && w->kbd->seq[0])
      for(i=0;i!=w->kbd->x;++i)
       {
       int c=w->kbd->seq[i]&127;
       if(c<32) cpos[0]='^', cpos[1]=c+'@@', cpos+=2;
       else if(c==127) cpos[0]='^', cpos[1]='?', cpos+=2;
       else cpos[0]=c, cpos+=1;
       }
     *cpos++=fill;
     while(cpos-buf<4) *cpos++=fill;
     stalin=vsncpy(sv(stalin),buf,cpos-buf);
     }
    break;

    case 'S':
    if(bw->pid) stalin=vsncpy(sv(stalin),sc("*SHELL*"));
    break;

    case 'M':
    if(recmac)
     {
     sprintf(buf,"(Macro %d recording...)",recmac->n);
     stalin=vsncpy(sv(stalin),sz(buf));
     }
    break;

    default: stalin=vsadd(stalin,*s);
    }
  else stalin=vsadd(stalin,*s);
  ++s;
  }
 return stalin;
 }

static void disptw(bw,flg)
BW *bw;
 {
 W *w=bw->parent;
 TW *tw=(TW *)bw->object;

 if(bw->o.linums!=bw->linums)
  {
  bw->linums=bw->o.linums;
  resizetw(bw,w->w,w->h);
  movetw(bw,w->x,w->y);
  bwfllw(bw);
  }

 w->cury=bw->cursor->line-bw->top->line+bw->y-w->y;
 w->curx=bw->cursor->xcol-bw->offset+(bw->o.linums?LINCOLS:0);

 if((staupd || keepup || bw->cursor->line!=tw->prevline ||
     bw->b->changed!=tw->changed) && (w->y || !staen))
  {
  int fill;
  tw->prevline=bw->cursor->line;
  tw->changed=bw->b->changed;
  if(bw->o.rmsg[0]) fill=bw->o.rmsg[0];
  else fill=' ';
  tw->stalin=stagen(tw->stalin,bw,bw->o.lmsg,fill);
  tw->staright=stagen(tw->staright,bw,bw->o.rmsg,fill);
  if(fmtlen(tw->staright)<w->w)
   {
   int x=fmtpos(tw->stalin,w->w-fmtlen(tw->staright));
   if(x>sLEN(tw->stalin)) tw->stalin=vsfill(sv(tw->stalin),fill,x-sLEN(tw->stalin));
   tw->stalin=vsncpy(tw->stalin,fmtpos(tw->stalin,w->w-fmtlen(tw->staright)),sv(tw->staright));
   }
  tw->stalin=vstrunc(tw->stalin,fmtpos(tw->stalin,w->w));
  genfmt(w->t->t,w->x,w->y,0,tw->stalin,0);
  w->t->t->updtab[w->y]=0;
  }
d96 284
a379 2
 if(flg) bwgen(bw,bw->o.linums);
 }
d383 9
a391 9
void iztw(tw,y)
TW *tw;
 {
 tw->stalin=0;
 tw->staright=0;
 tw->changed= -1;
 tw->prevline= -1;
 tw->staon=(!staen || y);
 }
d395 112
a506 49
int usplitw(bw)
BW *bw;
 {
 W *w=bw->parent;
 int newh=getgrouph(w);
 W *new;
 TW *newtw;
 BW *newbw;
 dostaupd=1;
 if(newh/2<FITHEIGHT) return -1;
 new=wcreate(w->t,w->watom,findbotw(w),NULL,w,newh/2+(newh&1),NULL,NULL);
 if(!new) return -1;
 wfit(new->t);
 new->object=(void *)(newbw=bwmk(new,bw->b,0));
 ++bw->b->count;
 newbw->offset=bw->offset;
 newbw->object=(void *)(newtw=(TW *)malloc(sizeof(TW)));
 iztw(newtw,new->y);
 pset(newbw->top,bw->top);
 pset(newbw->cursor,bw->cursor);
 newbw->cursor->xcol=bw->cursor->xcol;
 new->t->curwin=new;
 return 0;
 }

int uduptw(bw)
BW *bw;
 {
 W *w=bw->parent;
 int newh=getgrouph(w);
 W *new;
 TW *newtw;
 BW *newbw;
 dostaupd=1;
 new=wcreate(w->t,w->watom,findbotw(w),NULL,NULL,newh,NULL,NULL);
 if(!new) return -1;
 if(demotegroup(w)) new->t->topwin=new;
 new->object=(void *)(newbw=bwmk(new,bw->b,0));
 ++bw->b->count;
 newbw->offset=bw->offset;
 newbw->object=(void *)(newtw=(TW *)malloc(sizeof(TW)));
 iztw(newtw,new->y);
 pset(newbw->top,bw->top);
 pset(newbw->cursor,bw->cursor);
 newbw->cursor->xcol=bw->cursor->xcol;
 new->t->curwin=new;
 wfit(w->t);
 return 0;
 }
d510 129
a638 65
int naborttw(bw,k,object,notify)
BW *bw;
void *object;
int *notify;
{
W *w=bw->parent;
B *b;
TW *tw=(TW *)bw->object;
if(notify) *notify=1;
if(k!='y' && k!='Y') return -1;

genexmsg(bw,0,NULL);

if(countmain(w->t)==1)
 if(b=borphan())
  {
  void *object=bw->object;
  bwrm(bw);
  w->object=(void *)(bw=bwmk(w,b,0));
  wredraw(bw->parent);
  bw->object=object;
  return 0;
  }
bwrm(bw);
vsrm(tw->stalin);
free(tw);
w->object=0;
wabort(w);		/* Eliminate this window and it's children */
return 0;
}

static void instw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwins(bw,l,n,flg);
 }

static void deltw(bw,b,l,n,flg)
BW *bw;
B *b;
long l,n;
int flg;
 {
 if(b==bw->b) bwdel(bw,l,n,flg);
 }

int uabort();

static WATOM watomtw=
{
"main",
disptw,
bwfllw,
0,
rtntw,
utypebw,
resizetw,
movetw,
instw,
deltw,
TYPETW
};
d640 1
a640 2
int uabort(bw,k)
BW *bw;
d642 19
a660 102
if(bw->parent->watom!=&watomtw)
 return wabort(bw->parent);
if(bw->pid && bw->cursor->byte==bw->b->eof->byte && k!= MAXINT)
 {
 char c=k;
 write(bw->out,&c,1);
 return 0;
 }
if(bw->pid) return ukillpid(bw);
if(bw->b->changed && bw->b->count==1)
 if(mkqw(bw,sc("Lose changes to this file (y,n,^C)? "),naborttw,NULL,NULL,NULL)) return 0;
 else return -1;
else return naborttw(bw,'y',NULL,NULL);
}

/* Abort buffer */

int uabortbuf(bw)
BW *bw;
 {
 W *w=bw->parent;
 B *b;
 if(bw->pid) return ukillpid(bw);

 if(okrepl(bw)) return -1;

 if(b=borphan())
  {
  void *object=bw->object;
  bwrm(bw);
  w->object=(void *)(bw=bwmk(w,b,0));
  wredraw(bw->parent);
  bw->object=object;
  return 0;
  }

 return naborttw(bw,'y',NULL,NULL);
 }

/* Kill this window */

int utw0(b)
BASE *b;
 {
 BW *bw=b->parent->main->object;
 if(countmain(b->parent->t)==1) return -1;
 if(bw->pid) { return ukillpid(bw); }
 if(bw->b->count==1) orphit(bw);
 return uabort(bw,MAXINT);
 }

/* Only one window */

int utw1(b)
BASE *b;
 {
 W *starting=b->parent;
 W *main=starting->main;
 SCREEN *t=main->t;
 int yn;

 do
  {
  yn=0;
  loop:
  do wnext(t); while(t->curwin->main==main && t->curwin!=starting);
  if(t->curwin->main!=main)
   {
   if(((BW *)t->curwin->main->object)->pid)
    {
    msgnw(t->curwin->main->object,"Process running in this window");
    return -1;
    }
   utw0(t->curwin->main->object), yn=1;
   goto loop;
   }
  } while(yn);
 return 0;
 }

void setline(b,line)
B *b;
long line;
 {
 W *w=maint->curwin;
 do
  if(w->watom->what==TYPETW)
   {
   BW *bw=w->object;
   if(bw->b==b)
    {
    long oline=bw->top->line;
    pline(bw->top,line);
    pline(bw->cursor,line);
    if(w->y>=0 && bw->top->line>oline && bw->top->line-oline<bw->h)
     nscrlup(w->t->t,bw->y,bw->y+bw->h,(int)(bw->top->line-oline));
    else if(w->y>=0 && bw->top->line<oline && oline-bw->top->line<bw->h)
     nscrldn(w->t->t,bw->y,bw->y+bw->h,(int)(oline-bw->top->line));
    }
   }
  while((w=w->link.next)!=maint->curwin);
 }
d664 13
a676 14
BW *wmktw(t,b)
SCREEN *t;
B *b;
 {
 W *w;
 BW *bw;
 TW *tw;
 w=wcreate(t,&watomtw,NULL,NULL,NULL,t->h,NULL,NULL);
 wfit(w->t);
 w->object=(void *)(bw=bwmk(w,b,0));
 bw->object=(void *)(tw=(TW *)malloc(sizeof(TW)));
 iztw(tw,w->y);
 return bw;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
