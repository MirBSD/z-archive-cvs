head	1.17;
access;
symbols
	joe-3_1jupp38:1.17
	joe-3_1jupp37:1.16
	joe-3_1jupp36:1.16
	joe-3_1jupp35:1.16
	joe-3_1jupp34:1.16
	joe-3_1jupp33:1.16
	joe-3_1jupp32:1.15
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.8
	joe-3_1jupp30:1.8
	joe-3_1jupp29:1.8
	joe-3_1jupp28:1.8
	joe-3_1jupp27:1.8
	joe-3_1jupp26:1.8
	joe-3_1jupp25:1.8
	joe-3_1jupp24:1.6
	joe-3_1jupp23:1.6
	joe-3_1jupp22:1.6
	joe-3_1jupp21:1.6
	joe-3_1jupp20:1.6
	joe-3_1jupp19:1.6
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.17
date	2018.11.11.18.15.39;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005BE871D325833018;

1.16
date	2018.01.07.20.32.48;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A5284063C3E386D;

1.15
date	2017.12.08.02.28.08;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A29F8C708B176AB;

1.14
date	2017.12.08.02.00.43;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A29F2506E789D2B;

1.13
date	2017.12.06.21.17.04;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A285E5918D423C7;

1.12
date	2017.12.04.22.15.40;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A25C91E16B3B365;

1.11
date	2017.12.02.18.50.04;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A22F5E2328F5222;

1.10
date	2017.12.02.02.07.38;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A220AD65C90E687;

1.9
date	2017.12.02.00.16.44;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A21F0FB306AFC87;

1.8
date	2013.08.19.22.03.20;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005212963A2ECD563E;

1.7
date	2013.08.19.21.11.45;	author tg;	state Exp;
branches;
next	1.6;
commitid	10052128A24535B37FD;

1.6
date	2012.06.07.22.30.49;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FD12B97055748BB;

1.5
date	2012.06.07.22.19.51;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FD1291E265988B9;

1.4
date	2011.07.16.21.57.58;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004E2209506F4A1334;

1.3
date	2010.04.08.15.31.06;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004BBDF6C54CC9A0DB;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.17
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Software virtual memory system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/vfile.c,v 1.16 2018/01/07 20:32:48 tg Exp $");

#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#include "blocks.h"
#include "queue.h"
#include "path.h"
#include "tty.h"
#include "utils.h"
#include "vfile.h"
#include "vs.h"

				/* Known vfiles */
static VFILE vfiles = { {&vfiles, &vfiles}, 0, 0, 0, 0, NULL, 0, NULL, 0, NULL, NULL, 0, 0 };
static VPAGE *freepages = NULL;	/* Linked list of free pages */
static VPAGE *htab[HTSIZE];	/* Hash table of page headers */
static long curvalloc = 0;	/* Amount of memory in use */
static long maxvalloc = ILIMIT;	/* Maximum allowed */
unsigned char *vbase;			/* Data first entry in vheader refers to */
VPAGE **vheaders = NULL;	/* Array of header addresses */
static int vheadsz = 0;		/* No. entries allocated to vheaders */

static unsigned int joe_random(void);

void vflsh(void)
{
	VPAGE *vp;
	VPAGE *vlowest;
	long addr;
	long last;
	VFILE *vfile;
	int x;
	const char *wtf;

	for (vfile = vfiles.link.next; vfile != &vfiles; vfile = vfile->link.next) {
		last = -1;
 loop:
		addr = LONG_MAX;
		vlowest = NULL;
		for (x = 0; x != HTSIZE; x++)
			for (vp = htab[x]; vp; vp = vp->next)
				if (vp->addr < addr && vp->addr > last && vp->vfile == vfile && (vp->addr >= vfile->size || (vp->dirty && !vp->count))) {
					addr = vp->addr;
					vlowest = vp;
				}
		if (vlowest) {
			if (!vfile->name)
				vfile->name = mktmp(NULL,
				    vfile->fd ? NULL : &vfile->fd);
			if (!vfile->fd)
				vfile->fd = open((char *)(vfile->name), O_RDWR);
			if (vfile->fd < 0) {
				wtf = "open";
				goto eek;
			}
			if (lseek(vfile->fd, addr, 0) < 0) {
				/* should not happen, what now? */
				wtf = "lseek";
				close(vfile->fd);
 eek:
				vfile->fd = 0;
				fprintf(stderr, "\nvfile %s failed! \n", wtf);
				continue;
			}
			if (addr + PGSIZE > vsize(vfile)) {
				joe_write(vfile->fd, vlowest->data, vsize(vfile) - addr);
				vfile->size = vsize(vfile);
			} else {
				joe_write(vfile->fd, vlowest->data, PGSIZE);
				if (addr + PGSIZE > vfile->size)
					vfile->size = addr + PGSIZE;
			}
			vlowest->dirty = 0;
			last = addr;
			goto loop;
		}
	}
}

/* write changed pages for a specific file to the disk */
static void vflshf(VFILE *vfile);

static void
vflshf(VFILE *vfile)
{
	VPAGE *vp;
	VPAGE *vlowest;
	long addr;
	int x;
	const char *wtf;

 loop:
	addr = LONG_MAX;
	vlowest = NULL;
	for (x = 0; x != HTSIZE; x++)
		for (vp = htab[x]; vp; vp = vp->next)
			if (vp->addr < addr && vp->dirty && vp->vfile == vfile && !vp->count) {
				addr = vp->addr;
				vlowest = vp;
			}
	if (vlowest) {
		if (!vfile->name)
			vfile->name = mktmp(NULL,
			    vfile->fd ? NULL : &vfile->fd);
		if (!vfile->fd)
			vfile->fd = open((char *)(vfile->name), O_RDWR);
		if (vfile->fd < 0) {
			wtf = "open";
			goto eek;
		}
		if (lseek(vfile->fd, addr, 0) < 0) {
			/* should not happen, what now? */
			wtf = "lseek";
			close(vfile->fd);
 eek:
			vfile->fd = 0;
			fprintf(stderr, "\nvfile %s failed! \n", wtf);
			/* only called from vclose via main, maybe harmless? */
			return;
		}
		if (addr + PGSIZE > vsize(vfile)) {
			joe_write(vfile->fd, vlowest->data, vsize(vfile) - addr);
			vfile->size = vsize(vfile);
		} else {
			joe_write(vfile->fd, vlowest->data, PGSIZE);
			if (addr + PGSIZE > vfile->size)
				vfile->size = addr + PGSIZE;
		}
		vlowest->dirty = 0;
		goto loop;
	}
}

static unsigned char *mema(int align, int size)
{
	unsigned char *z = malloc(align + size);

	return z + (align - ((size_t)z % align));
}

unsigned char *vlock(VFILE *vfile, unsigned long addr)
{
	VPAGE *vp, *pp;
	int x, y;
	long ofst = (addr & (PGSIZE - 1));

	addr -= ofst;

	for (vp = htab[((addr >> LPGSIZE) + (unsigned long) vfile) & (HTSIZE - 1)]; vp; vp = vp->next)
		if (vp->vfile == vfile && (unsigned long)vp->addr == addr) {
			++vp->count;
			return vp->data + ofst;
		}

	if (freepages) {
		vp = freepages;
		freepages = vp->next;
		goto gotit;
	}

	if (curvalloc + PGSIZE <= maxvalloc) {
		vp = malloc(sizeof(VPAGE) * INC);
		if (vp) {
			vp->data = (unsigned char *) mema(PGSIZE, PGSIZE * INC);
			if (vp->data) {
				int q;

				curvalloc += PGSIZE * INC;
				if (!vheaders) {
					vheaders = malloc((vheadsz = INC) * sizeof(VPAGE *));
					vbase = vp->data;
				} else if ((size_t)vp->data < (size_t)vbase) {
					VPAGE **t = vheaders;
					int amnt = (((size_t)vbase) - ((size_t)vp->data)) >> LPGSIZE;

					vheaders = malloc((amnt + vheadsz) * sizeof(VPAGE *));
					mmove(vheaders + amnt, t, vheadsz * sizeof(VPAGE *));
					vheadsz += amnt;
					vbase = vp->data;
					free(t);
				} else if (((((size_t)vp->data + PGSIZE * INC) - ((size_t)vbase)) >> LPGSIZE) > (unsigned long)vheadsz) {
					vheaders = realloc(vheaders,
					    (vheadsz = (((((size_t)vp->data + PGSIZE * INC) - ((size_t)vbase)) >> LPGSIZE))) * sizeof(VPAGE *));
				}
				for (q = 1; q != INC; ++q) {
					vp[q].next = freepages;
					freepages = vp + q;
					vp[q].data = vp->data + q * PGSIZE;
					vheader(vp->data + q * PGSIZE) = vp + q;
				}
				vheader(vp->data) = vp;
				goto gotit;
			}
			free(vp);
			vp = NULL;
		}
	}

	for (y = HTSIZE, x = (joe_random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
		for (pp = (VPAGE *) (htab + x), vp = pp->next; vp; pp = vp, vp = vp->next)
			if (!vp->count && !vp->dirty) {
				pp->next = vp->next;
				goto gotit;
			}
	vflsh();
	for (y = HTSIZE, x = (joe_random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
		for (pp = (VPAGE *) (htab + x), vp = pp->next; vp; pp = vp, vp = vp->next)
			if (!vp->count && !vp->dirty) {
				pp->next = vp->next;
				goto gotit;
			}
	if (write(2, "vfile: out of memory\n", 21)) {}
	exit(1);

 gotit:
	vp->addr = addr;
	vp->vfile = vfile;
	vp->dirty = 0;
	vp->count = 1;
	vp->next = htab[((addr >> LPGSIZE) + (unsigned long)vfile) & (HTSIZE - 1)];
	htab[((addr >> LPGSIZE) + (unsigned long)vfile) & (HTSIZE - 1)] = vp;

	if (addr < (unsigned long)vfile->size) {
		if (!vfile->fd && (vfile->fd = open((char *)(vfile->name),
		    O_RDWR)) < 0)
			vfile->fd = 0;
		if (!vfile->fd || lseek(vfile->fd, addr, 0) < 0) {
			static char washere = 0;

			if (!washere++)
				ttabrt(0, "vlock: open or lseek failed");
			if (write(2, "vlock: open or lseek failed twice\n", 26)) {}
			exit(1);
		}
		if (addr + PGSIZE > (unsigned long)vfile->size) {
			joe_read(vfile->fd, vp->data, vfile->size - addr);
			mset(vp->data + vfile->size - addr, 0, PGSIZE - (int) (vfile->size - addr));
		} else
			joe_read(vfile->fd, vp->data, PGSIZE);
	} else
		mset(vp->data, 0, PGSIZE);

	return vp->data + ofst;
}

VFILE *vtmp(void)
{
	VFILE *new = malloc(sizeof(VFILE));

	new->fd = 0;
	new->name = NULL;
	new->alloc = 0;
	new->size = 0;
	new->left = 0;
	new->lv = 0;
	new->vpage = NULL;
	new->flags = 1;
	new->vpage1 = NULL;
	new->addr = -1;
	return enqueb_f(VFILE, link, &vfiles, new);
}

void vclose(VFILE *vfile)
{
	VPAGE *vp, *pp;
	int x;

	if (vfile->vpage)
		vunlock(vfile->vpage);
	if (vfile->vpage1)
		vunlock(vfile->vpage1);
	if (vfile->name) {
		if (vfile->flags)
			unlink((char *)vfile->name);
		else
			vflshf(vfile);
		vsrm(vfile->name);
	}
	if (vfile->fd)
		close(vfile->fd);
	free(deque_f(VFILE, link, vfile));
	for (x = 0; x != HTSIZE; x++)
		for (pp = (VPAGE *) (htab + x), vp = pp->next; vp;)
			if (vp->vfile == vfile) {
				pp->next = vp->next;
				vp->next = freepages;
				freepages = vp;
				vp = pp->next;
			} else {
				pp = vp;
				vp = vp->next;
			}
}

long my_valloc(VFILE *vfile, long int size)
{
	long start = vsize(vfile);

	vfile->alloc = start + size;
	if (vfile->lv) {
		if (vheader(vfile->vpage)->addr + PGSIZE > vfile->alloc)
			vfile->lv = PGSIZE - (vfile->alloc - vheader(vfile->vpage)->addr);
		else
			vfile->lv = 0;
	}
	return start;
}

#if ((HTSIZE) <= 0x8000)
/* Borland LCG */
static unsigned int
joe_random(void)
{
	static unsigned int lcg_state = 5381;

	return (((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF);
}
#endif
@


1.16
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/vfile.c,v 1.14 2017/12/08 02:00:43 tg Exp $");
d21 1
d46 1
d65 13
a77 1
			lseek(vfile->fd, addr, 0);
d93 5
a97 1
void vflshf(VFILE *vfile)
d103 1
d118 1
a118 1
		if (!vfile->fd) {
d120 13
a133 1
		lseek(vfile->fd, addr, 0);
d237 10
a246 2
		if (!vfile->fd) {
			vfile->fd = open((char *)(vfile->name), O_RDWR);
a247 1
		lseek(vfile->fd, addr, 0);
@


1.15
log
@label indent; small tweaks while here
@
text
@a14 1
#include <limits.h>
@


1.14
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/vfile.c,v 1.13 2017/12/06 21:17:04 tg Exp $");
d49 1
a49 1
	      loop:
d87 1
a87 1
      loop:
d198 1
a198 1
      gotit:
@


1.13
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/vfile.c,v 1.12 2017/12/04 22:15:40 tg Exp $");
d119 1
a119 1
	unsigned char *z = (unsigned char *) joe_malloc(align + size);
d145 1
a145 1
		vp = (VPAGE *) joe_malloc(sizeof(VPAGE) * INC);
d153 1
a153 1
					vheaders = (VPAGE **) joe_malloc((vheadsz = INC) * sizeof(VPAGE *));
d159 1
a159 1
					vheaders = (VPAGE **) joe_malloc((amnt + vheadsz) * sizeof(VPAGE *));
d163 1
a163 1
					joe_free(t);
d165 2
a166 2
					vheaders = (VPAGE **)
					    joe_realloc(vheaders, (vheadsz = (((((size_t)vp->data + PGSIZE * INC) - ((size_t)vbase)) >> LPGSIZE))) * sizeof(VPAGE *));
d177 1
a177 1
			joe_free(vp);
d224 1
a224 1
	VFILE *new = (VFILE *) joe_malloc(sizeof(VFILE));
d257 1
a257 1
	joe_free(deque_f(VFILE, link, vfile));
@


1.12
log
@clean up some unused/MS-DOS® stuff
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/vfile.c,v 1.10 2017/12/02 02:07:38 tg Exp $");
a12 1
#ifdef HAVE_SYS_STAT_H
a13 1
#endif
a15 1
#ifdef HAVE_STDLIB_H
a16 1
#endif
@


1.11
log
@get rid of -Wmissing-field-initialisers, as Cygwin GCC forces my hand
@
text
@d125 1
a125 1
	return z + align - physical(z) % align;
d159 1
a159 1
				} else if (physical(vp->data) < physical(vbase)) {
d161 1
a161 1
					int amnt = (physical(vbase) - physical(vp->data)) >> LPGSIZE;
d168 1
a168 1
				} else if (((physical(vp->data + PGSIZE * INC) - physical(vbase)) >> LPGSIZE) > (unsigned long)vheadsz) {
d170 1
a170 1
					    joe_realloc(vheaders, (vheadsz = (((physical(vp->data + PGSIZE * INC) - physical(vbase)) >> LPGSIZE))) * sizeof(VPAGE *));
@


1.10
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d30 2
a31 1
static VFILE vfiles = { {&vfiles, &vfiles} };	/* Known vfiles */
@


1.9
log
@what a mess, indeed!

use LONG_MAX instead of homegrown MAXINT/MAXLONG
@
text
@a0 1
/* $MirOS: contrib/code/jupp/vfile.c,v 1.7 2013/08/19 21:11:45 tg Exp $ */
d11 2
a12 3
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.8
log
@somewhat sanitise tmpfile handling
@
text
@d19 1
d55 1
a55 1
		addr = MAXLONG;
d93 1
a93 1
	addr = MAXLONG;
@


1.7
log
@use at least somewhat more correct data types
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vfile.c,v 1.6 2012/06/07 22:30:49 tg Exp $ */
d64 2
a65 1
				vfile->name = mktmp(NULL);
d102 2
a103 1
			vfile->name = mktmp(NULL);
@


1.6
log
@dietlibc noted use of random() which is deprecated
but since we just need some sort of LCG, not even really seeded, here…
just add Borland’s LCG, as implemented in mksh
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vfile.c,v 1.4 2011/07/16 21:57:58 tg Exp $ */
d69 1
a69 1
				joe_write(vfile->fd, vlowest->data, (int) (vsize(vfile) - addr));
d107 1
a107 1
			joe_write(vfile->fd, vlowest->data, (int) (vsize(vfile) - addr));
d130 1
a130 1
	int ofst = (addr & (PGSIZE - 1));
d214 1
a214 1
			joe_read(vfile->fd, vp->data, (int) (vfile->size - addr));
@


1.5
log
@nuke junk
@
text
@d40 2
d184 1
a184 1
	for (y = HTSIZE, x = (random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
d191 1
a191 1
	for (y = HTSIZE, x = (random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
d286 11
@


1.4
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vfile.c,v 1.3 2010/04/08 15:31:06 tg Exp $ */
a238 29
#ifdef junk

VFILE *vopen(name)
unsigned char *name;
{
	struct stat buf;
	VFILE *new = (VFILE *) joe_malloc(sizeof(VFILE));

	new->name = vsncpy(NULL, 0, sz(name));
	new->fd = open(name, O_RDWR);
	if (!new->fd) {
		fprintf(stderr, "Couldn\'t open file \'%s\'\n", name);
		joe_free(new);
		return NULL;
	}
	fstat(new->fd, &buf);
	new->size = buf.st_size;
	new->alloc = new->size;
	new->left = 0;
	new->lv = 0;
	new->vpage = NULL;
	new->flags = 0;
	new->vpage1 = NULL;
	new->addr = -1;
	return enqueb_f(VFILE, link, &vfiles, new);
}

#endif

a270 47
#ifdef junk
/* this is now broken */
void vlimit(amount)
long amount;
{
	VPAGE *vp, *pp;
	int x, y;

	maxvalloc = amount;
	while (curvalloc > maxvalloc)
		if (freepages) {
			vp = freepages;
			freepages = vp->next;
			joe_free(vp->data);
			joe_free(vp);
			curvalloc -= PGSIZE;
		} else {
		      again:
			for (y = HTSIZE, x = (random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
				for (pp = (VPAGE *) (htab + x), vp = pp->next; vp; pp = vp, vp = vp->next)
					if (!vp->count && !vp->dirty) {
						pp->next = vp->next;
						joe_free(vp->data);
						joe_free(vp);
						if ((curvalloc -= PGSIZE)
						    <= maxvalloc)
							return;
						goto again;
					}
			vflsh();
		      again1:
			for (y = HTSIZE, x = (random() & (HTSIZE - 1)); y; x = ((x + 1) & (HTSIZE - 1)), --y)
				for (pp = (VPAGE *) (htab + x), vp = pp->next; vp; pp = vp, vp = vp->next)
					if (!vp->count && !vp->dirty) {
						pp->next = vp->next;
						joe_free(vp->data);
						joe_free(vp);
						if ((curvalloc -= PGSIZE)
						    <= maxvalloc)
							return;
						goto again1;
					}
			return;
		}
}
#endif

a283 439

#ifdef junk

void vseek(vfile, addr)
VFILE *vfile;
long addr;
{
	vfile->alloc = vsize(vfile);
	if (addr > vfile->alloc)
		vfile->alloc = addr;
	if (!vfile->vpage)
		vfile->vpage = vlock(vfile, addr & ~(long) (PGSIZE - 1));
	else if (vheader(vfile->vpage)->addr != (addr & ~(long) (PGSIZE - 1))) {
		vunlock(vfile->vpage);
		vfile->vpage = vlock(vfile, addr & ~(long) (PGSIZE - 1));
	}
	vfile->bufp = vfile->vpage + (addr & (PGSIZE - 1));
	vfile->left = vfile->vpage + PGSIZE - vfile->bufp;
	if (vheader(vfile->vpage)->addr + PGSIZE > vfile->alloc)
		vfile->lv = PGSIZE - (vfile->alloc - vheader(vfile->vpage)->addr);
	else
		vfile->lv = 0;
}

int _vrgetc(vfile)
VFILE *vfile;
{
	if (vtell(vfile) == 0)
		return NO_MORE_DATA;
	vseek(vfile, vtell(vfile) - 1);
	++vfile->bufp;
	--vfile->left;
	return vrgetc(vfile);
}

int _vgetc(vfile)
VFILE *vfile;
{
	if (vtell(vfile) == vsize(vfile))
		return NO_MORE_DATA;
	vseek(vfile, vtell(vfile));
	return vgetc(vfile);
}

int nmvgetc(v)
VFILE *v;
{
	return vgetc(v);
}

int _vputc(vfile, c)
VFILE *vfile;
unsigned char c;
{
	vseek(vfile, vtell(vfile));
	return vputc(vfile, c);
}

short vgetw(vfile)
VFILE *vfile;
{
	short w;

	if (vtell(vfile) + 2 > vsize(vfile))
		return -1;
	w = vgetc(vfile);
	w += ((short) vgetc(vfile) << 8);
	return w;
}

short vputw(vfile, w)
VFILE *vfile;
short w;
{
	vputc(vfile, w);
	vputc(vfile, w >> 8);
	return w;
}

long vgetl(vfile)
VFILE *vfile;
{
	long w;

	if (vtell(vfile) + 4 > vsize(vfile))
		return -1;
	w = vgetc(vfile);
	w += ((long) vgetc(vfile) << 8);
	w += ((long) vgetc(vfile) << 16);
	w += ((long) vgetc(vfile) << 24);
	return w;
}

long vputl(vfile, w)
VFILE *vfile;
long w;
{
	vputc(vfile, w);
	vputc(vfile, w >> 8);
	vputc(vfile, w >> 16);
	vputc(vfile, w >> 24);
	return w;
}

int _rc(vfile, addr)
VFILE *vfile;
long addr;
{
	if (vfile->vpage1)
		vunlock(vfile->vpage1);
	vfile->vpage1 = vlock(vfile, vfile->addr = (addr & ~(long) (PGSIZE - 1)));
	return rc(vfile, addr);
}

int _wc(vfile, addr, c)
VFILE *vfile;
long addr;
unsigned char c;
{
	if (addr + 1 > vsize(vfile))
		my_valloc(vfile, addr + 1 - vsize(vfile));
	if (vfile->vpage1)
		vunlock(vfile->vpage1);
	vfile->vpage1 = vlock(vfile, vfile->addr = (addr & ~(long) (PGSIZE - 1)));
	return wc(vfile, addr, c);
}

short rw(vfile, addr)
VFILE *vfile;
long addr;
{
	short c;

	if (addr + 2 > vsize(vfile))
		return -1;
	c = rc(vfile, addr);
	c += ((short) rc(vfile, addr + 1) << 8);
	return c;
}

short ww(vfile, addr, c)
VFILE *vfile;
long addr;
short c;
{
	if (addr + 2 > vsize(vfile))
		my_valloc(vfile, addr + 2 - vsize(vfile));
	wc(vfile, addr, c);
	wc(vfile, addr + 1, c >> 8);
	return c;
}

long rl(vfile, addr)
VFILE *vfile;
long addr;
{
	long c;

	if (addr + 4 > vsize(vfile))
		return -1;
	c = rc(vfile, addr);
	c += ((long) rc(vfile, addr + 1) << 8);
	c += ((long) rc(vfile, addr + 2) << 16);
	c += ((long) rc(vfile, addr + 3) << 24);
	return c;
}

long wl(vfile, addr, c)
VFILE *vfile;
long addr;
long c;
{
	if (addr + 4 > vsize(vfile))
		my_valloc(vfile, addr + 4 - vsize(vfile));
	wc(vfile, addr, c);
	wc(vfile, addr + 1, c >> 8);
	wc(vfile, addr + 2, c >> 16);
	wc(vfile, addr + 3, c >> 24);
	return c;
}

void vread(v, blk, size)
VFILE *v;
unsigned char *blk;
int size;
{
	long addr = vtell(v);
	unsigned char *src;
	int x;

	while (size) {
		src = vlock(v, addr);
		x = PGSIZE - (addr & (PGSIZE - 1));
		if (x >= size) {
			vseek(v, addr + size);
			mcpy(blk, src, size);
			vunlock(src);
			return;
		}
		size -= x;
		addr += x;
		mcpy(blk, src, x);
		blk += x;
		vunlock(src);
	}
	vseek(v, addr);
}

void vwrite(v, blk, size)
VFILE *v;
unsigned char *blk;
int size;
{
	long addr = vtell(v);
	unsigned char *src;
	int x;

	if (addr + size > vsize(v))
		my_valloc(v, addr + size - vsize(v));
	while (size) {
		src = vlock(v, addr);
		x = PGSIZE - (addr & (PGSIZE - 1));
		if (x >= size) {
			vseek(v, addr + size);
			mcpy(src, blk, size);
			vchanged(src);
			vunlock(src);
			return;
		}
		size -= x;
		addr += x;
		mcpy(src, blk, x);
		blk += x;
		vchanged(src);
		vunlock(src);
	}
	vseek(v, addr);
}

/* Write zstring to vfile */

void vputs(v, s)
VFILE *v;
unsigned char *s;
{
	while (*s) {
		vputc(v, *s);
		++s;
	}
}

/* Read a line from a file.  Remove '\n' if there was any */

unsigned char *vgets(v, s)
VFILE *v;
unsigned char *s;
{
	unsigned char *b, *a, *x, *y;
	int cnt;

	/* Return with NULL if at end of file */
	if (vtell(v) == vsize(v)) {
		vsrm(s);
		return NULL;
	}

	/* Create string if it doesn't exist */
	if (!s)
		s = vsmk(80);

	/* Zero string length */
	sLen(s) = 0;

      loop:

	/* Set b to end of string, a to page pointer, and cnt to min which ever
	 * (string or page) has the least space left
	 */
	b = s + sLen(s);
	a = v->bufp;
	cnt = Imin(sSIZ(s) - sLen(s), v->left - v->lv);

	/* Copy until \n is found or until page or buffer out of space */
	if (cnt >= 16)
		do {
			if ((b[0] = a[0]) == '\n') {
				a += 1;
				b += 1;
				goto ovr;
			}
			if ((b[1] = a[1]) == '\n') {
				a += 2;
				b += 2;
				cnt -= 1;
				goto ovr;
			}
			if ((b[2] = a[2]) == '\n') {
				a += 3;
				b += 3;
				cnt -= 2;
				goto ovr;
			}
			if ((b[3] = a[3]) == '\n') {
				a += 4;
				b += 4;
				cnt -= 3;
				goto ovr;
			}
			if ((b[4] = a[4]) == '\n') {
				a += 5;
				b += 5;
				cnt -= 4;
				goto ovr;
			}
			if ((b[5] = a[5]) == '\n') {
				a += 6;
				b += 6;
				cnt -= 5;
				goto ovr;
			}
			if ((b[6] = a[6]) == '\n') {
				a += 7;
				b += 7;
				cnt -= 6;
				goto ovr;
			}
			if ((b[7] = a[7]) == '\n') {
				a += 8;
				b += 8;
				cnt -= 7;
				goto ovr;
			}
			if ((b[8] = a[8]) == '\n') {
				a += 9;
				b += 9;
				cnt -= 8;
				goto ovr;
			}
			if ((b[9] = a[9]) == '\n') {
				a += 10;
				b += 10;
				cnt -= 9;
				goto ovr;
			}
			if ((b[10] = a[10]) == '\n') {
				a += 11;
				b += 11;
				cnt -= 10;
				goto ovr;
			}
			if ((b[11] = a[11]) == '\n') {
				a += 12;
				b += 12;
				cnt -= 11;
				goto ovr;
			}
			if ((b[12] = a[12]) == '\n') {
				a += 13;
				b += 13;
				cnt -= 12;
				goto ovr;
			}
			if ((b[13] = a[13]) == '\n') {
				a += 14;
				b += 14;
				cnt -= 13;
				goto ovr;
			}
			if ((b[14] = a[14]) == '\n') {
				a += 15;
				b += 15;
				cnt -= 14;
				goto ovr;
			}
			if ((b[15] = a[15]) == '\n') {
				a += 16;
				b += 16;
				cnt -= 15;
				goto ovr;
			}
		} while (a += 16, b += 16, (cnt -= 16) >= 16);

/*
	x = a;
	y = b;
	a += cnt - 15;
	b += cnt - 15;
	switch(cnt) {
	case 15:	if((b[0]=a[0])=='\n') { a+=1; b+=1; goto zif; }
	case 14:	if((b[1]=a[1])=='\n') { a+=2; b+=2; goto zif; }
	case 13:	if((b[2]=a[2])=='\n') { a+=3; b+=3; goto zif; }
	case 12:	if((b[3]=a[3])=='\n') { a+=4; b+=4; goto zif; }
	case 11:	if((b[4]=a[4])=='\n') { a+=5; b+=5; goto zif; }
	case 10:	if((b[5]=a[5])=='\n') { a+=6; b+=6; goto zif; }
	case 9:		if((b[6]=a[6])=='\n')  { a+=7; b+=7; goto zif; }
	case 8:		if((b[7]=a[7])=='\n')  { a+=8; b+=8; goto zif; }
	case 7:		if((b[8]=a[8])=='\n')  { a+=9; b+=9; goto zif; }
	case 6:		if((b[9]=a[9])=='\n')  { a+=10; b+=10; goto zif; }
	case 5:		if((b[10]=a[10])=='\n'){ a+=11; b+=11; goto zif; }
	case 4:		if((b[11]=a[11])=='\n'){ a+=12; b+=12; goto zif; }
	case 3:		if((b[12]=a[12])=='\n'){ a+=13; b+=13; goto zif; }
	case 2:		if((b[13]=a[13])=='\n'){ a+=14; b+=14; goto zif; }
	case 1:		if((b[14]=a[14])=='\n'){ a+=15; b+=15; goto zif; }
	}
	a = x + cnt;
	b = y + cnt;
	cnt=0;
	goto ovr;
zif:	cnt -= a - x - 1;
*/

	if (cnt)
		do {
			if ((*b++ = *a++) == '\n')
				break;
		} while (--cnt);

      ovr:

	/* Update string and page data */
	sLen(s) = b - s;
	v->left -= a - v->bufp;
	v->bufp = a;

	if (!cnt)
		if (vtell(v) == vsize(v))
			b[0] = 0;
		else {
			if (sLen(s) == sSiz(s))
				s = vsensure(s, sLen(s) + (sLen(s) >> 1) + 16);
			if (!v->left)
				vseek(v, vtell(v));
			goto loop;
	} else
		b[-1] = 0;

	return s;
}
#endif
@


1.3
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/vfile.c,v 1.2 2008/05/13 13:08:32 tg Exp $ */
d195 1
a195 1
	write(2, "vfile: out of memory\n", 21);
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d133 1
a133 1
		if (vp->vfile == vfile && vp->addr == addr) {
d164 1
a164 1
				} else if (((physical(vp->data + PGSIZE * INC) - physical(vbase)) >> LPGSIZE) > vheadsz) {
d206 1
a206 1
	if (addr < vfile->size) {
d211 1
a211 1
		if (addr + PGSIZE > vfile->size) {
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* Software virtual memory system
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d11 1
a11 1
#include <stdio.h>
d13 2
d16 1
d18 5
a22 3
#include "config.h"
#include "vs.h"
#include "zstr.h"
d26 1
a26 1
#include "random.h"
d28 1
d30 2
a31 2
static VFILE vfiles={{&vfiles,&vfiles}};	/* Known vfiles */
static VPAGE *freepages=0;	/* Linked list of free pages */
d33 203
a235 214
static long curvalloc=0;	/* Amount of memory in use */
static long maxvalloc= ILIMIT;	/* Maximum allowed */
char *vbase;			/* Data first entry in vheader refers to */
VPAGE **vheaders=0;		/* Array of header addresses */
static int vheadsz=0;		/* No. entries allocated to vheaders */

void vflsh()
{
VPAGE *vp;
VPAGE *vlowest;
long addr;
long last;
VFILE *vfile;
int x;
for(vfile=vfiles.link.next;
    vfile!=&vfiles;
    vfile=vfile->link.next)
 {
 last= -1;
 loop:
 addr= MAXLONG;
 vlowest=0;
 for(x=0;x!=HTSIZE;x++)
  for(vp=htab[x];vp;vp=vp->next)
   if(vp->addr<addr && vp->addr>last && vp->vfile==vfile &&
      (vp->addr>=vfile->size || (vp->dirty && !vp->count)))
    addr=vp->addr, vlowest=vp;
 if(vlowest)
  {
  if(!vfile->name) vfile->name=mktmp(NULL);
  if(!vfile->fd) vfile->fd=open(vfile->name,O_RDWR);
  lseek(vfile->fd,addr,0);
  if(addr+PGSIZE>vsize(vfile))
   {
   jwrite(vfile->fd,vlowest->data,(int)(vsize(vfile)-addr));
   vfile->size=vsize(vfile);
   }
  else
   {
   jwrite(vfile->fd,vlowest->data,PGSIZE);
   if(addr+PGSIZE>vfile->size) vfile->size=addr+PGSIZE;
   }
  vlowest->dirty=0;
  last=addr;
  goto loop;
  }
 }
}

void vflshf(vfile)
VFILE *vfile;
{
VPAGE *vp;
VPAGE *vlowest;
long addr;
int x;
loop:
addr= MAXLONG;
vlowest=0;
for(x=0;x!=HTSIZE;x++)
 for(vp=htab[x];vp;vp=vp->next)
  if(vp->addr<addr && vp->dirty && vp->vfile==vfile && !vp->count)
   addr=vp->addr, vlowest=vp;
if(vlowest)
 {
 if(!vfile->name) vfile->name=mktmp(NULL);
 if(!vfile->fd)
  {
  vfile->fd=open(vfile->name,O_RDWR);
  }
 lseek(vfile->fd,addr,0);
 if(addr+PGSIZE>vsize(vfile))
  {
  jwrite(vfile->fd,vlowest->data,(int)(vsize(vfile)-addr));
  vfile->size=vsize(vfile);
  }
 else
  {
  jwrite(vfile->fd,vlowest->data,PGSIZE);
  if(addr+PGSIZE>vfile->size) vfile->size=addr+PGSIZE;
  }
 vlowest->dirty=0;
 goto loop;
 }
}

char *mema(align,size)
 {
 char *z=(char *)malloc(align+size);
 return z+align-physical(z)%align;
 }

char *vlock(vfile,addr)
VFILE *vfile;
long addr;
{
VPAGE *vp, *pp;
int x,y;
int ofst=(addr&(PGSIZE-1));
addr-=ofst;

for(vp=htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)];vp;vp=vp->next)
 if(vp->vfile==vfile && vp->addr==addr) return ++vp->count, vp->data+ofst;

if(freepages)
 {
 vp=freepages;
 freepages=vp->next;
 goto gotit;
 }

if(curvalloc+PGSIZE<=maxvalloc)
 {
 vp=(VPAGE *)malloc(sizeof(VPAGE)*INC);
 if(vp)
  {
  vp->data=(char *)mema(PGSIZE,PGSIZE*INC);
  if(vp->data)
   {
   int q;
   curvalloc+=PGSIZE*INC;
   if(!vheaders)
    vheaders=(VPAGE **)malloc((vheadsz=INC)*sizeof(VPAGE *)),
    vbase=vp->data;
   else
    if(physical(vp->data)<physical(vbase))
     {
     VPAGE **t=vheaders;
     int amnt=(physical(vbase)-physical(vp->data))>>LPGSIZE;
     vheaders=(VPAGE **)malloc((amnt+vheadsz)*sizeof(VPAGE *));
     mcpy(vheaders+amnt,t,vheadsz*sizeof(VPAGE *));
     vheadsz+=amnt;
     vbase=vp->data;
     free(t);
     }
    else if(((physical(vp->data+PGSIZE*INC)-physical(vbase))>>LPGSIZE)>vheadsz)
     {
     vheaders=(VPAGE **)realloc(vheaders,
      (vheadsz=(((physical(vp->data+PGSIZE*INC)-physical(vbase))>>LPGSIZE)))*sizeof(VPAGE *));
     }
   for(q=1;q!=INC;++q)
    {
    vp[q].next=freepages;
    freepages=vp+q;
    vp[q].data=vp->data+q*PGSIZE;
    vheader(vp->data+q*PGSIZE)=vp+q;
    }
   vheader(vp->data)=vp;
   goto gotit;
   }
  free(vp);
  vp=0;
  }
 }

for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
 for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
  if(!vp->count && !vp->dirty)
   {
   pp->next=vp->next;
   goto gotit;
   }
vflsh();
for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
 for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
  if(!vp->count && !vp->dirty)
   {
   pp->next=vp->next;
   goto gotit;
   }
write(2,"vfile: out of memory\n",21);
exit(1);

gotit:
vp->addr=addr;
vp->vfile=vfile;
vp->dirty=0;
vp->count=1;
vp->next=htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)];
htab[((addr>>LPGSIZE)+(int)vfile)&(HTSIZE-1)]=vp;

if(addr<vfile->size)
 {
 if(!vfile->fd)
  {
  vfile->fd=open(vfile->name,O_RDWR);
  }
 lseek(vfile->fd,addr,0);
 if(addr+PGSIZE>vfile->size)
  {
  jread(vfile->fd,vp->data,(int)(vfile->size-addr));
  mset(vp->data+vfile->size-addr,0,PGSIZE-(int)(vfile->size-addr));
  }
 else jread(vfile->fd,vp->data,PGSIZE);
 }
else mset(vp->data,0,PGSIZE);

return vp->data+ofst;
}

VFILE *vtmp()
{
VFILE *new=(VFILE *)malloc(sizeof(VFILE));
new->fd= 0;
new->name=0;
new->alloc=0;
new->size=0;
new->left=0;
new->lv=0;
new->vpage=0;
new->flags=1;
new->vpage1=0;
new->addr= -1;
return enqueb(VFILE,link,&vfiles,new);
d241 1
a241 1
char *name;
d243 20
a262 20
struct stat buf;
VFILE *new=(VFILE *)malloc(sizeof(VFILE));
new->name=vsncpy(NULL,0,sz(name));
new->fd=open(name,O_RDWR);
if(!new->fd)
 {
 fprintf(stderr,"Couldn\'t open file \'%s\'\n",name);
 free(new);
 return 0;
 }
fstat(new->fd,&buf);
new->size=buf.st_size;
new->alloc=new->size;
new->left=0;
new->lv=0;
new->vpage=0;
new->flags=0;
new->vpage1=0;
new->addr= -1;
return enqueb(VFILE,link,&vfiles,new);
d267 1
a267 2
void vclose(vfile)
VFILE *vfile;
d269 28
a296 22
VPAGE *vp, *pp;
int x;
if(vfile->vpage) vunlock(vfile->vpage);
if(vfile->vpage1) vunlock(vfile->vpage1);
if(vfile->name)
 {
 if(vfile->flags) unlink(vfile->name);
 else vflshf(vfile);
 vsrm(vfile->name);
 }
if(vfile->fd) close(vfile->fd);
free(deque(VFILE,link,vfile));
for(x=0;x!=HTSIZE;x++)
 for(pp=(VPAGE *)(htab+x), vp=pp->next;vp;)
  if(vp->vfile==vfile)
   {
   pp->next=vp->next;
   vp->next=freepages;
   freepages=vp;
   vp=pp->next;
   }
  else pp=vp, vp=vp->next;
d304 39
a342 39
VPAGE *vp, *pp;
int x,y;
maxvalloc=amount;
while(curvalloc>maxvalloc)
 if(freepages)
  {
  vp=freepages;
  freepages=vp->next;
  free(vp->data);
  free(vp);
  curvalloc-=PGSIZE;
  }
 else
  {
  again:
  for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
   for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
    if(!vp->count && !vp->dirty)
     {
     pp->next=vp->next;
     free(vp->data);
     free(vp);
     if((curvalloc-=PGSIZE)<=maxvalloc) return;
     goto again;
     }
  vflsh();
  again1:
  for(y=HTSIZE, x=(random()&(HTSIZE-1));y;x=((x+1)&(HTSIZE-1)), --y)
   for(pp=(VPAGE *)(htab+x),vp=pp->next;vp;pp=vp, vp=vp->next)
    if(!vp->count && !vp->dirty)
     {
     pp->next=vp->next;
     free(vp->data);
     free(vp);
     if((curvalloc-=PGSIZE)<=maxvalloc) return;
     goto again1;
     }
  return;
  }
d346 1
a346 3
long valloc(vfile,size)
VFILE *vfile;
long size;
d348 10
a357 9
long start=vsize(vfile);
vfile->alloc=start+size;
if(vfile->lv)
 {
 if(vheader(vfile->vpage)->addr+PGSIZE>vfile->alloc)
  vfile->lv=PGSIZE-(vfile->alloc-vheader(vfile->vpage)->addr);
 else vfile->lv=0;
 }
return start;
d362 1
a362 1
void vseek(vfile,addr)
d366 15
a380 13
vfile->alloc=vsize(vfile);
if(addr>vfile->alloc) vfile->alloc=addr;
if(!vfile->vpage) vfile->vpage=vlock(vfile,addr&~(long)(PGSIZE-1));
else if(vheader(vfile->vpage)->addr!=(addr&~(long)(PGSIZE-1)))
 {
 vunlock(vfile->vpage);
 vfile->vpage=vlock(vfile,addr&~(long)(PGSIZE-1));
 }
vfile->bufp=vfile->vpage+(addr&(PGSIZE-1));
vfile->left=vfile->vpage+PGSIZE-vfile->bufp;
if(vheader(vfile->vpage)->addr+PGSIZE>vfile->alloc)
 vfile->lv=PGSIZE-(vfile->alloc-vheader(vfile->vpage)->addr);
else vfile->lv=0;
d386 6
a391 5
if(vtell(vfile)==0) return MAXINT;
vseek(vfile,vtell(vfile)-1);
++vfile->bufp;
--vfile->left;
return vrgetc(vfile);
d397 4
a400 3
if(vtell(vfile)==vsize(vfile)) return MAXINT;
vseek(vfile,vtell(vfile));
return vgetc(vfile);
d403 5
a407 1
int nmvgetc(v) VFILE *v; { return vgetc(v); } 
d409 1
a409 1
int _vputc(vfile,c)
d411 1
a411 1
char c;
d413 2
a414 2
vseek(vfile,vtell(vfile));
return vputc(vfile,c);
d420 7
a426 5
short w;
if(vtell(vfile)+2>vsize(vfile)) return -1;
w=vgetc(vfile);
w+=((short)vgetc(vfile)<<8);
return w;
d429 1
a429 1
short vputw(vfile,w)
d433 3
a435 3
vputc(vfile,w);
vputc(vfile,w>>8);
return w;
d441 9
a449 7
long w;
if(vtell(vfile)+4>vsize(vfile)) return -1;
w=vgetc(vfile);
w+=((long)vgetc(vfile)<<8);
w+=((long)vgetc(vfile)<<16);
w+=((long)vgetc(vfile)<<24);
return w;
d452 1
a452 1
long vputl(vfile,w)
d456 5
a460 5
vputc(vfile,w);
vputc(vfile,w>>8);
vputc(vfile,w>>16);
vputc(vfile,w>>24);
return w;
d463 1
a463 1
int _rc(vfile,addr)
d467 4
a470 3
if(vfile->vpage1) vunlock(vfile->vpage1);
vfile->vpage1=vlock(vfile,vfile->addr=(addr&~(long)(PGSIZE-1)));
return rc(vfile,addr);
d473 1
a473 1
int _wc(vfile,addr,c)
d476 1
a476 1
char c;
d478 6
a483 4
if(addr+1>vsize(vfile)) valloc(vfile,addr+1-vsize(vfile));
if(vfile->vpage1) vunlock(vfile->vpage1);
vfile->vpage1=vlock(vfile,vfile->addr=(addr&~(long)(PGSIZE-1)));
return wc(vfile,addr,c);
d486 1
a486 1
short rw(vfile,addr)
d490 7
a496 5
short c;
if(addr+2>vsize(vfile)) return -1;
c=rc(vfile,addr);
c+=((short)rc(vfile,addr+1)<<8);
return c;
d499 1
a499 1
short ww(vfile,addr,c)
d504 5
a508 4
if(addr+2>vsize(vfile)) valloc(vfile,addr+2-vsize(vfile));
wc(vfile,addr,c);
wc(vfile,addr+1,c>>8);
return c;
d511 1
a511 1
long rl(vfile,addr)
d515 9
a523 7
long c;
if(addr+4>vsize(vfile)) return -1;
c=rc(vfile,addr);
c+=((long)rc(vfile,addr+1)<<8);
c+=((long)rc(vfile,addr+2)<<16);
c+=((long)rc(vfile,addr+3)<<24);
return c;
d526 1
a526 1
long wl(vfile,addr,c)
d531 7
a537 6
if(addr+4>vsize(vfile)) valloc(vfile,addr+4-vsize(vfile));
wc(vfile,addr,c);
wc(vfile,addr+1,c>>8);
wc(vfile,addr+2,c>>16);
wc(vfile,addr+3,c>>24);
return c;
d540 1
a540 1
void vread(v,blk,size)
d542 1
a542 1
char *blk;
d545 20
a564 21
long addr=vtell(v);
char *src;
int x;
while(size)
 {
 src=vlock(v,addr);
 x=PGSIZE-(addr&(PGSIZE-1));
 if(x>=size)
  {
  vseek(v,addr+size);
  mcpy(blk,src,size);
  vunlock(src);
  return;
  }
 size-=x;
 addr+=x;
 mcpy(blk,src,x);
 blk+=x;
 vunlock(src);
 }
vseek(v,addr);
d567 1
a567 1
void vwrite(v,blk,size)
d569 1
a569 1
char *blk;
d572 24
a595 24
long addr=vtell(v);
char *src;
int x;
if(addr+size>vsize(v)) valloc(v,addr+size-vsize(v));
while(size)
 {
 src=vlock(v,addr);
 x=PGSIZE-(addr&(PGSIZE-1));
 if(x>=size)
  {
  vseek(v,addr+size);
  mcpy(src,blk,size);
  vchanged(src);
  vunlock(src);
  return;
  }
 size-=x;
 addr+=x;
 mcpy(src,blk,x);
 blk+=x;
 vchanged(src);
 vunlock(src);
 }
vseek(v,addr);
d600 1
a600 1
void vputs(v,s)
d602 1
a602 1
char *s;
d604 4
a607 1
while(*s) vputc(v,*s), ++s;
d612 1
a612 1
char *vgets(v,s)
d614 126
a739 48
char *s;
 {
 char *b, *a, *x, *y;
 int cnt;

 /* Return with NULL if at end of file */
 if(vtell(v)==vsize(v))
  {
  vsrm(s);
  return 0;
  }

 /* Create string if it doesn't exist */
 if(!s) s=vsmk(80);

 /* Zero string length */
 sLen(s)=0;

 loop:

 /* Set b to end of string, a to page pointer, and cnt to min which ever
  * (string or page) has the least space left
  */
 b=s+sLen(s);
 a=v->bufp;
 cnt=Imin(sSIZ(s)-sLen(s),v->left-v->lv);

 /* Copy until \n is found or until page or buffer out of space */
 if(cnt>=16) do
  {
  if((b[0]=a[0])=='\n') { a+=1; b+=1; goto ovr; }
  if((b[1]=a[1])=='\n') { a+=2; b+=2; cnt-=1; goto ovr; }
  if((b[2]=a[2])=='\n') { a+=3; b+=3; cnt-=2; goto ovr; }
  if((b[3]=a[3])=='\n') { a+=4; b+=4; cnt-=3; goto ovr; }
  if((b[4]=a[4])=='\n') { a+=5; b+=5; cnt-=4; goto ovr; }
  if((b[5]=a[5])=='\n') { a+=6; b+=6; cnt-=5; goto ovr; }
  if((b[6]=a[6])=='\n') { a+=7; b+=7; cnt-=6; goto ovr; }
  if((b[7]=a[7])=='\n') { a+=8; b+=8; cnt-=7; goto ovr; }
  if((b[8]=a[8])=='\n') { a+=9; b+=9; cnt-=8; goto ovr; }
  if((b[9]=a[9])=='\n') { a+=10; b+=10; cnt-=9; goto ovr; }
  if((b[10]=a[10])=='\n') { a+=11; b+=11; cnt-=10; goto ovr; }
  if((b[11]=a[11])=='\n') { a+=12; b+=12; cnt-=11; goto ovr; }
  if((b[12]=a[12])=='\n') { a+=13; b+=13; cnt-=12; goto ovr; }
  if((b[13]=a[13])=='\n') { a+=14; b+=14; cnt-=13; goto ovr; }
  if((b[14]=a[14])=='\n') { a+=15; b+=15; cnt-=14; goto ovr; }
  if((b[15]=a[15])=='\n') { a+=16; b+=16; cnt-=15; goto ovr; }
  }
  while(a+=16, b+=16, (cnt-=16)>=16);
d742 26
a767 21
 x=a, y=b; a+=cnt-15; b+=cnt-15;
 switch(cnt)
  {
  case 15: if((b[0]=a[0])=='\n') { a+=1; b+=1; goto zif; }
  case 14: if((b[1]=a[1])=='\n') { a+=2; b+=2; goto zif; }
  case 13: if((b[2]=a[2])=='\n') { a+=3; b+=3; goto zif; }
  case 12: if((b[3]=a[3])=='\n') { a+=4; b+=4; goto zif; }
  case 11: if((b[4]=a[4])=='\n') { a+=5; b+=5; goto zif; }
  case 10: if((b[5]=a[5])=='\n') { a+=6; b+=6; goto zif; }
  case 9: if((b[6]=a[6])=='\n')  { a+=7; b+=7; goto zif; }
  case 8: if((b[7]=a[7])=='\n')  { a+=8; b+=8; goto zif; }
  case 7: if((b[8]=a[8])=='\n')  { a+=9; b+=9; goto zif; }
  case 6: if((b[9]=a[9])=='\n')  { a+=10; b+=10; goto zif; }
  case 5: if((b[10]=a[10])=='\n'){ a+=11; b+=11; goto zif; }
  case 4: if((b[11]=a[11])=='\n'){ a+=12; b+=12; goto zif; }
  case 3: if((b[12]=a[12])=='\n'){ a+=13; b+=13; goto zif; }
  case 2: if((b[13]=a[13])=='\n'){ a+=14; b+=14; goto zif; }
  case 1: if((b[14]=a[14])=='\n'){ a+=15; b+=15; goto zif; }
  }
 a=x+cnt, b=y+cnt; cnt=0; goto ovr;
 zif: cnt-=a-x-1;
d770 24
a793 20
 if(cnt) do
  if((*b++=*a++)=='\n') break;
  while(--cnt);

 ovr:
 
 /* Update string and page data */
 sLen(s)=b-s;
 v->left-=a-v->bufp;
 v->bufp=a;

 if(!cnt)
  if(vtell(v)==vsize(v)) b[0]=0;
  else
   {
   if(sLen(s)==sSiz(s)) s=vsensure(s,sLen(s)+(sLen(s)>>1)+16);
   if(!v->left) vseek(v,vtell(v));
   goto loop;
   }
 else b[-1]=0;
d795 2
a796 2
 return s;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
