head	1.26;
access;
symbols
	joe-3_1jupp38:1.26
	joe-3_1jupp37:1.26
	joe-3_1jupp36:1.26
	joe-3_1jupp35:1.26
	joe-3_1jupp34:1.26
	joe-3_1jupp33:1.26
	joe-3_1jupp32:1.25
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.7
	joe-3_1jupp30:1.6
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.6
	joe-3_1jupp25:1.6
	joe-3_1jupp24:1.6
	joe-3_1jupp23:1.6
	joe-3_1jupp22:1.2
	joe-3_1jupp21:1.2
	joe-3_1jupp20:1.2
	joe-3_1jupp19:1.2
	joe-3_1jupp18:1.2
	joe-3_1jupp17:1.2
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.2
	joe-3_1jupp15:1.2
	joe-3_1jupp14:1.2
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.26
date	2018.01.06.00.28.34;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A50184621FA8455;

1.25
date	2017.12.16.22.10.55;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A359A0405479D56;

1.24
date	2017.12.08.02.28.08;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A29F8C708B176AB;

1.23
date	2017.12.08.02.00.43;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A29F2506E789D2B;

1.22
date	2017.12.08.01.30.00;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A29EB2C65E8B9EA;

1.21
date	2017.12.07.02.10.19;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A28A3145E1FF911;

1.20
date	2017.12.06.23.58.38;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A2884424C3F3AD8;

1.19
date	2017.12.06.23.02.07;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A2876FC4FFE7EF5;

1.18
date	2017.12.06.21.41.04;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A28640547F64250;

1.17
date	2017.12.06.21.17.02;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A285E5918D423C7;

1.16
date	2017.12.03.02.36.03;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A2363204B0C4612;

1.15
date	2017.12.02.18.33.25;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A22F1FF5B03A3AC;

1.14
date	2017.12.02.05.07.18;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A22351A7A641BBE;

1.13
date	2017.12.02.05.04.28;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A22346E09CBC4DE;

1.12
date	2017.12.02.04.55.19;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A22324E226A84E7;

1.11
date	2017.12.02.04.32.42;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A222CF2122034D9;

1.10
date	2017.12.02.04.15.29;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A2228EC3463D689;

1.9
date	2017.12.02.02.11.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A220BC8186BF1AB;

1.8
date	2017.12.02.02.07.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A220AD65C90E687;

1.7
date	2017.03.19.19.19.51;	author tg;	state Exp;
branches;
next	1.6;
commitid	10058CED9DF339F2D5D;

1.6
date	2012.12.30.17.12.37;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050E0761C0C6C216C;

1.5
date	2012.12.30.17.10.58;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050E075B939751F66;

1.4
date	2012.12.20.20.11.54;	author tg;	state Exp;
branches;
next	1.3;
commitid	10050D3712219A6BBB5;

1.3
date	2012.12.20.19.56.13;	author tg;	state Exp;
branches;
next	1.2;
commitid	10050D36D767517C29D;

1.2
date	2008.05.13.13.08.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@/*
 *	Math
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.25 2017/12/16 22:10:55 tg Exp $");

#include <stdlib.h>
#include <string.h>

#include "b.h"
#include "pw.h"
#include "umath.h"
#include "utils.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"

volatile sig_atomic_t merrf;
const unsigned char *merrt;

#if WANT_MATH
static char math_res[JOE_MSGBUFSIZE];
static char *math_exp;

static double calc(BW *bw, unsigned char *s);

static RETSIGTYPE fperr(int unused)
{
	if (!merrf)
		merrf = 2;
	REINSTALL_SIGHANDLER(SIGFPE, fperr);
}

struct var {
	struct var *next;
	unsigned char *name;
	double val;
	int set;
} *vars = NULL;

static struct var *
get(const unsigned char *str)
{
	struct var *v;

	for (v = vars; v; v = v->next) {
		if (!strcmp(v->name, str)) {
			return v;
		}
	}
	v = malloc(sizeof(struct var));
	v->set = 0;
	v->next = vars;
	vars = v;
	v->name = (unsigned char *)strdup((char *)str);
	return v;
}

unsigned char *ptr;
struct var *dumb;

static double expr(int prec, struct var **rtv)
{
	unsigned char c;
	double x = 0.0;
	struct var *v = NULL;

	while (*ptr == ' ' || *ptr == '\t') {
		++ptr;
	}
	c = *ptr | 0x20;
	if ((c >= 'a' && c <= 'z') || *ptr == '_') {
		unsigned char *s = ptr;

		while (((c = *ptr | 0x20) >= 'a' && c <= 'z') ||
		    *ptr == '_' || (*ptr >= '0' && *ptr <= '9'))
			++ptr;
		c = *ptr;
		*ptr = 0;
		v = get(s);
		x = v->val;
		*ptr = c;
	} else if (ptr[0] == '0' && (ptr[1] | 0x20) == 'x') {
		unsigned long xi;
		void *dp;

		xi = ustol(ptr, &dp, USTOL_AUTO);
		x = (double)xi;
		ptr = dp;
	} else if ((*ptr >= '0' && *ptr <= '9') || *ptr == '.') {
		char *eptr;

		x = strtod(ptr, &eptr);
		ptr = (unsigned char *)eptr;
	} else if (*ptr == '(') {
		++ptr;
		x = expr(0, &v);
		if (*ptr == ')')
			++ptr;
		else if (!merrf) {
			merrf = 1;
			merrt = UC "Missing )";
		}
	} else if (*ptr == '-') {
		++ptr;
		x = -expr(10, &dumb);
	}
 loop:
	while (*ptr == ' ' || *ptr == '\t')
		++ptr;
	if (*ptr == '*' && 5 > prec) {
		++ptr;
		x *= expr(5, &dumb);
		goto loop;
	} else if (*ptr == '/' && 5 > prec) {
		++ptr;
		x /= expr(5, &dumb);
		goto loop;
	} else if (*ptr == '+' && 4 > prec) {
		++ptr;
		x += expr(4, &dumb);
		goto loop;
	} else if (*ptr == '-' && 4 > prec) {
		++ptr;
		x -= expr(4, &dumb);
		goto loop;
	} else if (*ptr == '=' && 2 >= prec) {
		++ptr;
		x = expr(2, &dumb);
		if (v) {
			v->val = x;
			v->set = 1;
		} else if (!merrf) {
			merrf = 1;
			merrt = UC "Left side of = is not an l-value";
		}
		goto loop;
	}
	*rtv = v;
	return x;
}

#if defined(SIZEOF_LONG_LONG) && (SIZEOF_LONG_LONG > 0)
typedef long long joe_imaxt;
#define JOE_IMAXT "ll"
#else
typedef long joe_imaxt;
#define JOE_IMAXT "l"
#endif

static double
calc(BW *bw, unsigned char *s)
{
	double result;
	struct var *v;
	BW *tbw = bw->parent->main->object.bw;

	if (math_exp) {
		free(math_exp);
	}
	math_exp = strdup((void *)s);

	v = get(UC "top");
	v->val = tbw->top->line + 1;
	v->set = 1;
	v = get(UC "lines");
	v->val = tbw->b->eof->line + 1;
	v->set = 1;
	v = get(UC "line");
	v->val = tbw->cursor->line + 1;
	v->set = 1;
	v = get(UC "col");
	v->val = tbw->cursor->col + 1;
	v->set = 1;
	v = get(UC "byte");
	v->val = tbw->cursor->byte + 1;
	v->set = 1;
	v = get(UC "height");
	v->val = tbw->h;
	v->set = 1;
	v = get(UC "width");
	v->val = tbw->w;
	v->set = 1;
	ptr = s;
	merrf = 0;
 up:
	result = expr(0, &dumb);
	if (!merrf) {
		while (*ptr == ' ' || *ptr == '\t') {
			++ptr;
		}
		if (*ptr == ';') {
			++ptr;
			while (*ptr == ' ' || *ptr == '\t') {
				++ptr;
			}
			if (*ptr) {
				goto up;
			}
		} else if (*ptr && !merrf) {
			merrf = 1;
			merrt = UC "Extra junk after end of expr";
		}
	}

	if (merrf) {
		if (merrf == 2)
			merrt = UC "Float point exception";
		joe_snprintf_1(math_res, JOE_MSGBUFSIZE,
		    "math_error{%s}", merrt);
	} else {
		joe_imaxt ires = (joe_imaxt)result;

		if ((double)ires == result) {
			/* representable as integer value */
			joe_snprintf_1(math_res, JOE_MSGBUFSIZE,
			    "%" JOE_IMAXT "d", ires);
		} else {
			/* use float with large precision */
			joe_snprintf_1(math_res, JOE_MSGBUFSIZE,
			    "%.60G", result);
		}
	}

	return result;
}

/* Main user interface */
static int domath(BW *bw, unsigned char *s, void *object, int *notify)
{
	calc(bw, s);
	vsrm(s);

	if (notify) {
		*notify = 1;
	}
	if (merrf) {
		msgnw(bw->parent, merrt);
		return -1;
	}
	memcpy(msgbuf, math_res, JOE_MSGBUFSIZE);
	if (bw->parent->watom->what != TYPETW) {
		binsm(bw->cursor, sz(msgbuf));
		pfwrd(bw->cursor, strlen((char *)msgbuf));
		bw->cursor->xcol = piscol(bw->cursor);
	} else {
		msgnw(bw->parent, msgbuf);
	}
	return 0;
}

B *mathhist = NULL;

int umath(BW *bw)
{
	joe_set_signal(SIGFPE, fperr);
	if (wmkpw(bw->parent, UC "=", &mathhist, domath, UC "Math", NULL, NULL, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

int umathins(BW *bw)
{
	if (math_exp) {
		binss(bw->cursor, (void *)math_exp);
	}
	return 0;
}

int umathres(BW *bw)
{
	binss(bw->cursor, (void *)math_res);
	return 0;
}

long
calcl(BW *bw, unsigned char *s)
{
	double rv;

	rv = calc(bw, s);
	return ((long)rv);
}
#else
long
calcl(BW *bw, unsigned char *s)
{
	long rv;
	void *cp = NULL;

	rv = ustol(s, &cp, USTOL_TRIM | USTOL_EOS);
	if (!cp) {
		rv = 0;
		merrt = UC "Invalid or out-of-range number";
		merrf = 1;
	}
	return (rv);
}

int
unomath(BW *bw)
{
	msgnw(bw->parent, UC "Sorry, compiled without Math");
	return (-1);
}
#endif
@


1.25
log
@more casing tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.23 2017/12/08 02:00:43 tg Exp $");
d41 1
d43 1
a44 2
	double val;
	struct var *next;
d47 2
a48 1
static struct var *get(unsigned char *str)
d108 1
a108 1
			merrt = US "Missing )";
d141 1
a141 1
			merrt = US "Left side of = is not an l-value";
d169 1
a169 1
	v = get(US "top");
d172 1
a172 1
	v = get(US "lines");
d175 1
a175 1
	v = get(US "line");
d178 1
a178 1
	v = get(US "col");
d181 1
a181 1
	v = get(US "byte");
d184 1
a184 1
	v = get(US "height");
d187 1
a187 1
	v = get(US "width");
d208 1
a208 1
			merrt = US "Extra junk after end of expr";
d214 1
a214 1
			merrt = US "Float point exception";
d302 1
a302 1
		merrt = US "Invalid or out-of-range number";
@


1.24
log
@label indent; small tweaks while here
@
text
@d69 1
d76 6
a81 7
	if ((*ptr >= 'a' && *ptr <= 'z') || (*ptr >= 'A' && *ptr <= 'Z')
	    || *ptr == '_') {
		unsigned char *s = ptr, c;

		while ((*ptr >= 'a' && *ptr <= 'z')
		       || (*ptr >= 'A' && *ptr <= 'Z')
		       || *ptr == '_' || (*ptr >= '0' && *ptr <= '9')) {
a82 1
		}
@


1.23
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.22 2017/12/08 01:30:00 tg Exp $");
d114 1
a114 1
      loop:
d192 1
a192 1
      up:
@


1.22
log
@more memory leak plugs
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.20 2017/12/06 23:58:38 tg Exp $");
d56 1
a56 2
	v = (struct var *) joe_malloc(sizeof(struct var));

@


1.21
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d239 1
a247 1
	vsrm(s);
@


1.20
log
@make wmkpw const again
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.19 2017/12/06 23:02:07 tg Exp $");
d163 1
a163 1
	BW *tbw = bw->parent->main->object;
@


1.19
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.18 2017/12/06 21:41:04 tg Exp $");
d264 1
a264 1
	if (wmkpw(bw->parent, US "=", &mathhist, domath, US "math", NULL, NULL, NULL, NULL, locale_map)) {
@


1.18
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.16 2017/12/03 02:36:03 tg Exp $");
d18 1
@


1.17
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d311 1
a311 1
	msgnw(bw->parent, US "Sorry, compiled without Math");
@


1.16
log
@first cut at getting rid of stdio: scanf half
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.13 2017/12/02 05:04:28 tg Exp $");
a12 1
#ifdef HAVE_STDLIB_H
a13 1
#endif
@


1.15
log
@fix strict aliasing problems \o/
@
text
@d93 1
d95 1
a95 1
		sscanf((char *)ptr, "%li", &xi);
d97 1
a97 3
		ptr += 2;
		while ((*ptr >= '0' && *ptr <= '9') || ((*ptr | 0x20) >= 'a' && (*ptr | 0x20) <= 'f'))
			++ptr;
@


1.14
log
@*shrug* mgcc seems to require a local variable…
@
text
@d100 4
a103 1
		x = strtod(ptr, (char **)&ptr);
@


1.13
log
@idfk why mgcc(1) wants to verarsch me here…
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.10 2017/12/02 04:15:29 tg Exp $");
d287 4
a290 1
	return ((long)calc(bw, s));
@


1.12
log
@Debian warning fix
@
text
@d32 2
d157 2
a158 1
double calc(BW *bw, unsigned char *s)
d283 6
@


1.11
log
@some fallout of the includes changes, some more reduction
@
text
@d98 1
a98 1
		x = strtod(ptr, &ptr);
@


1.10
log
@first cut at fixing the klibc builds

cf. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=852327
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/umath.c,v 1.8 2017/12/02 02:07:35 tg Exp $");
a21 1
#include "utf8.h"
@


1.9
log
@use strtod(3) (C89) instead of sscanf(3) for parsing floating point numbers

first step away from stdio (well the *scanf part at least)
@
text
@d29 1
d281 23
@


1.8
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
d98 1
a98 3
		sscanf((char *)ptr, "%lf", &x);
		while ((*ptr >= '0' && *ptr <= '9') || *ptr == '.' || *ptr == 'e' || *ptr == 'E')
			++ptr;
@


1.7
log
@_some_ type cleanup (time_t, sig_atomic_t)

still unsafe signal handler crap abound :(
@
text
@a0 1
/* $MirOS: contrib/code/jupp/umath.c,v 1.4 2012/12/20 20:11:54 tg Exp $ */
d11 2
a12 1
#include <stdio.h>
@


1.6
log
@new bindings for math result insertion
@
text
@d26 2
a27 1
const unsigned char * volatile merr;
d34 2
a35 3
	if (!merr) {
		merr = US "Float point exception";
	}
d106 3
a108 3
		else {
			if (!merr)
				merr = US "Missing )";
d139 3
a141 3
		} else {
			if (!merr)
				merr = US "Left side of = is not an l-value";
d190 1
a190 1
	merr = 0;
d193 1
a193 1
	if (!merr) {
d205 3
a207 2
		} else if (*ptr) {
			merr = US "Extra junk after end of expr";
d211 3
a213 1
	if (merr) {
d215 1
a215 1
		    "math_error{%s}", merr);
d241 2
a242 2
	if (merr) {
		msgnw(bw->parent, merr);
@


1.5
log
@more const cleanliness (and merr is used in a signal handler so it should be volatile), and use NULL not 0 for pointers
@
text
@d13 3
d28 3
d149 8
d163 5
d209 18
a229 8
#if defined(SIZEOF_LONG_LONG) && (SIZEOF_LONG_LONG > 0)
typedef long long joe_imaxt;
#define JOE_IMAXT "ll"
#else
typedef long joe_imaxt;
#define JOE_IMAXT "l"
#endif

d233 1
a233 2
	double result = calc(bw, s);
	joe_imaxt ires;
d243 1
a243 10
	ires = (joe_imaxt)result;
	if ((double)ires == result) {
		/* representable as integer value */
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE,
		    "%" JOE_IMAXT "d", ires);
	} else {
		/* use float with large precision */
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE,
		    "%.60G", result);
	}
d265 14
@


1.4
log
@allow 0xCAFE in math (and with that, prompts like goto-line)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/umath.c,v 1.2 2008/05/13 13:08:28 tg Exp $ */
d23 1
a23 1
unsigned char *merr;
@


1.3
log
@check if math results paß into an integer; if so, do that; otherwise, use %.60G instead of just %G to have more digits
@
text
@d83 8
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d185 8
d197 1
d207 10
a216 1
	joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%G", result);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 1
/* Math */
d11 4
a14 3
#include <signal.h>
#include "w.h"
#include "bw.h"
d16 1
a16 1
#include "tw.h"
d18 3
a20 2
#include "zstr.h"
#include "umath.h"
d22 1
a22 1
char *merr;
d24 32
a55 26
void fperr()
 {
 if(!merr) merr="Float point exception";
 signal(SIGFPE,fperr);
 }

struct var
 {
 char *name;
 int set;
 double val;
 struct var *next;
 } *vars=0;

struct var *get(str)
char *str;
 {
 struct var *v;
 for(v=vars;v;v=v->next) if(!zcmp(v->name,str)) return v;
 v=(struct var *)malloc(sizeof(struct var));
 v->set=0;
 v->next=vars;
 vars=v;
 v->name=zdup(str);
 return v;
 }
d57 1
a57 1
char *ptr;
d60 159
a218 132
double expr(prec,rtv)
struct var **rtv;
 {
 double x=0.0;
 struct var *v=0;
 while(*ptr==' ' || *ptr=='\t') ++ptr;
 if(*ptr>='a' && *ptr<='z' || *ptr>='A' && *ptr<='Z' || *ptr=='_')
  {
  char *s=ptr, c;
  while(*ptr>='a' && *ptr<='z' || *ptr>='A' && *ptr<='Z' || *ptr=='_' ||
        *ptr>='0' && *ptr<='9') ++ptr;
  c= *ptr; *ptr=0;
  v=get(s);
  x=v->val;
  *ptr=c;
  }
 else if(*ptr>='0' && *ptr<='9' || *ptr=='.')
  {
  sscanf(ptr,"%lf",&x);
  while(*ptr>='0' && *ptr<='9' || *ptr=='.' || *ptr=='e' || *ptr=='E') ++ptr;
  }
 else if(*ptr=='(')
  {
  ++ptr;
  x=expr(0,&v);
  if(*ptr==')') ++ptr;
  else { if(!merr) merr="Missing )"; }
  }
 else if(*ptr=='-')
  {
  ++ptr;
  x= -expr(10,&dumb);
  }
 loop:
 while(*ptr==' ' || *ptr=='\t') ++ptr;
 if(*ptr=='*' && 5>prec)
  {
  ++ptr;
  x*=expr(5,&dumb);
  goto loop;
  }
 else if(*ptr=='/' && 5>prec)
  {
  ++ptr;
  x/=expr(5,&dumb);
  goto loop;
  }
 else if(*ptr=='+' && 4>prec)
  {
  ++ptr;
  x+=expr(4,&dumb);
  goto loop;
  }
 else if(*ptr=='-' && 4>prec)
  {
  ++ptr;
  x-=expr(4,&dumb);
  goto loop;
  }
 else if(*ptr=='=' && 2>=prec)
  {
  ++ptr;
  x=expr(2,&dumb);
  if(v) v->val=x, v->set=1;
  else { if(!merr) merr="Left side of = is not an l-value"; }
  goto loop;
  }
 *rtv=v;
 return x;
 }

double calc(bw,s)
BW *bw;
char *s;
 {
 double result;
 struct var *v;
 BW *tbw=bw->parent->main->object;
 v=get("top"); v->val=tbw->top->line+1; v->set=1;
 v=get("lines"); v->val=tbw->b->eof->line+1; v->set=1;
 v=get("line"); v->val=tbw->cursor->line+1; v->set=1;
 v=get("col"); v->val=tbw->cursor->col+1; v->set=1;
 v=get("byte"); v->val=tbw->cursor->byte+1; v->set=1;
 v=get("height"); v->val=tbw->h; v->set=1;
 v=get("width"); v->val=tbw->w; v->set=1;
 ptr=s;
 merr=0;
 up: result=expr(0,&dumb);
 if(!merr)
  {
  while(*ptr==' ' || *ptr=='\t') ++ptr;
  if(*ptr==';')
   {
   ++ptr;
   while(*ptr==' ' || *ptr=='\t') ++ptr;
   if(*ptr) goto up;
   }
  else if(*ptr) merr="Extra junk after end of expr";
  }
 return result;
 }

int domath(bw,s,object,notify)		/* Main user interface */
BW *bw;
char *s;
void *object;
int *notify;
 {
 double result=calc(bw,s);
 if(notify) *notify=1;
 if(merr) { msgnw(bw,merr); return -1; }
 vsrm(s);
 sprintf(msgbuf,"%lg",result);
 if(bw->parent->watom->what!=TYPETW)
  {
  binsm(bw->cursor,sz(msgbuf));
  pfwrd(bw->cursor,zlen(msgbuf));
  bw->cursor->xcol=piscol(bw->cursor);
  }
 else msgnw(bw,msgbuf);
 return 0;
 }

B *mathhist=0;

int umath(bw)
BW *bw;
 {
 signal(SIGFPE,fperr);
 if(wmkpw(bw,"=",&mathhist,domath,"math",NULL,NULL,NULL,NULL)) return 0;
 else return -1;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
