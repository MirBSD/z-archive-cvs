head	1.18;
access;
symbols
	joe-3_1jupp38:1.18
	joe-3_1jupp37:1.18
	joe-3_1jupp36:1.18
	joe-3_1jupp35:1.18
	joe-3_1jupp34:1.18
	joe-3_1jupp33:1.18
	joe-3_1jupp32:1.15
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.10
	joe-3_1jupp30:1.10
	joe-3_1jupp29:1.7
	joe-3_1jupp28:1.7
	joe-3_1jupp27:1.7
	joe-3_1jupp26:1.7
	joe-3_1jupp25:1.7
	joe-3_1jupp24:1.7
	joe-3_1jupp23:1.7
	joe-3_1jupp22:1.6
	joe-3_1jupp21:1.6
	joe-3_1jupp20:1.6
	joe-3_1jupp19:1.6
	joe-3_1jupp18:1.6
	joe-3_1jupp17:1.6
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.6
	joe-3_1jupp15:1.5
	joe-3_1jupp14:1.5
	joe-3_1jupp12:1.5
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.18
date	2018.01.08.00.40.44;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A52BE1C64DEBF85;

1.17
date	2017.12.21.00.00.11;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A3AF9A210E941B8;

1.16
date	2017.12.20.22.22.45;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A3AE2C61352365A;

1.15
date	2017.12.08.03.24.15;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A2A05EB07C8D953;

1.14
date	2017.12.08.02.00.39;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A29F2506E789D2B;

1.13
date	2017.12.06.23.17.33;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A287AA407E73F9C;

1.12
date	2017.12.06.23.02.02;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A2876FC4FFE7EF5;

1.11
date	2017.12.02.02.07.26;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A220AD65C90E687;

1.10
date	2017.01.10.23.59.32;	author tg;	state Exp;
branches;
next	1.9;
commitid	100587575750EFBF44B;

1.9
date	2017.01.10.23.50.43;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005875736B64E3DF51;

1.8
date	2017.01.10.19.16.27;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005875332028CA2A36;

1.7
date	2012.12.30.19.27.13;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050E095A825B7B989;

1.6
date	2011.07.16.21.57.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E2209506F4A1334;

1.5
date	2009.10.18.14.17.34;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004ADB237E67C2F65E;

1.4
date	2009.10.06.09.07.30;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004ACB08E905F8F83E;

1.3
date	2008.05.13.13.08.22;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.21;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.18
log
@redo, this is ugly enough and triggers Coverity
@
text
@/*
 *	Help system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *		(C) 2001 Marek 'Marx' Grac
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.16 2017/12/20 22:22:45 tg Exp $");

#include <stdlib.h>
#include <string.h>

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "blocks.h"
#include "builtin.h"
#include "help.h"
#include "scrn.h"
#include "utils.h"
#include "vs.h"
#include "utf8.h"
#include "w.h"

struct help *help_actual = NULL;			/* actual help screen */

/*
 * Process help file
 */
void
help_init(const unsigned char *filename)
{
	JFILE *fd;					/* help file */
	unsigned char buf[1024];			/* input buffer */
	struct help *tmp;
	char *cp;

	/* open the help file */
	if (!(fd = jfopen(filename, "r")))
		return;

	fprintf(stderr, "Processing '%s'...", filename);
	fflush(stderr);

	while (jfgets(buf, sizeof(buf), fd)) {
		if (buf[0] == '{'/*}*/) {
			/* start of help screen */
			tmp = calloc(1, sizeof(struct help));
			/* drop newline */
			buf[strlen(buf) - 1] = '\0';
			tmp->name = (unsigned char *)strdup((char *)buf + 1);
			/* read text */
			while (jfgets(buf, sizeof(buf), fd) && buf[0] != /*{*/'}') {
				tmp->text = vsncpy(sv(tmp->text), sz(buf));
				++tmp->lines;
			}
			/* end of help screen */
			if (buf[0] != /*{*/'}') {
				fprintf(stderr, /*{*/ "\nHelp file '%s' is not properly ended with } on new line.\nDo you want to accept incomplete help screen (y/n)?", filename);
				fflush(stderr);
				if (!fgets((char *)buf, sizeof(buf), stdin) ||
				    (buf[0] | 0x20) != 'y') {
					vsrm(tmp->text);
					free(tmp->name);
					free(tmp);
					goto out;
				}
			}
			/* intern string to save memory */
			if ((cp = strdup((char *)tmp->text))) {
				vsrm(tmp->text);
				tmp->text = (unsigned char *)cp;
			}
			/* set new help screen as actual one */
			tmp->prev = help_actual;
			if (help_actual)
				help_actual->next = tmp;
			help_actual = tmp;
		}
	}
	fprintf(stderr, "done\n");
 out:
	/* close help file */
	jfclose(fd);

	/* move to first help screen */
	while (help_actual && help_actual->prev)
		help_actual = help_actual->prev;
}

/*
 * Find context help - find help entry with the same name
 */

struct help *
find_context_help(const unsigned char *name)
{
	struct help *tmp = help_actual;

	while (tmp->prev != NULL)	/* find the first help entry */
		tmp = tmp->prev;

	while (tmp != NULL && strcmp(tmp->name, name) != 0)
		tmp = tmp->next;

	return tmp;
}

/*
 * Display help text
 */
void
help_display(SCREEN *t)
{
	const unsigned char *str;
	int y, x, z;
	int atr = 0;

	if (help_actual) {
		str = help_actual->text;
	} else {
		str = UC "";
	}

	for (y = skiptop; y != t->wind; ++y) {
		if (t->t->updtab[y]) {
			const unsigned char *start = str;
			int width=0;
			int nspans=0;
			int spanwidth;
			int spancount=0;
			int spanextra;
			/* First pass: count no. springs \| and determine minimum width */
			while(*str && *str!='\n')
				if (*str++ == '\\')
					switch(*str) {
						case 'i':
						case 'I':
						case 'u':
						case 'U':
						case 'd':
						case 'D':
						case 'b':
						case 'B':
						case 'f':
						case 'F':
							++str;
							break;
						case '|':
							++str;
							++nspans;
							break;
						case 0:
							break;
						default:
							++str;
							++width;
					}
				else
					++width;
			str = start;
			/* Now calculate span width */
			if (width >= t->w - 1 || nspans==0) {
				spanwidth = 0;
				spanextra = nspans;
			} else {
				spanwidth = ((t->w - 1) - width)/nspans;
				spanextra = nspans - ((t->w - 1) - width - nspans*spanwidth);
			}
			/* Second pass: display text */
			for (x = 0; x != t->w - 1; ++x) {
				if (*str == '\n' || !*str) {
					if (eraeol(t->t, x, y)) {
						return;
					} else {
						break;
					}
				} else {
					if (*str == '\\') {
						switch (*++str) {
						case '|':
							++str;
							for (z=0;z!=spanwidth;++z)
								outatr(locale_map,t->t,t->t->scrn+x+y*t->w+z,t->t->attr+x+y*t->w+z,x+z,y,' ',atr);
							if (spancount++ >= spanextra) {
								outatr(locale_map,t->t,t->t->scrn+x+y*t->w+z,t->t->attr+x+y*t->w+z,x+z,y,' ',atr);
								++z;
							}
							x += z-1;
							continue;
						case 'i':
						case 'I':
							atr ^= INVERSE;
							++str;
							--x;
							continue;
						case 'u':
						case 'U':
							atr ^= UNDERLINE;
							++str;
							--x;
							continue;
						case 'd':
						case 'D':
							atr ^= DIM;
							++str;
							--x;
							continue;
						case 'b':
						case 'B':
							atr ^= BOLD;
							++str;
							--x;
							continue;
						case 'f':
						case 'F':
							atr ^= BLINK;
							++str;
							--x;
							continue;
						case 0:
							--x;
							continue;
						}
					}
					outatr_help(t->t,
					    t->t->scrn + x + y * t->w,
					    t->t->attr + x + y * t->w,
					    x, y, *str++, atr);
				}
			}
			atr = 0;
			t->t->updtab[y] = 0;
		}

		while (*str && *str != '\n')
			++str;
		if (*str == '\n')
			++str;
	}
}

/*
 * Show help screen
 */
int
help_on(SCREEN *t)
{
	if (help_actual) {
		t->wind = help_actual->lines + skiptop;
		if ((t->h - t->wind) < FITHEIGHT) {
			t->wind = t->h - FITHEIGHT;
		}
		if (t->wind < 0) {
			t->wind = skiptop;
			return -1;
		}
		wfit(t);
		msetI(t->t->updtab + skiptop, 1, t->wind);
		return 0;
	} else {
		return -1;
	}
}

/*
 * Hide help screen
 */
void
help_off(SCREEN *t)
{
	t->wind = skiptop;
	wfit(t);
}

/*
 * Show/hide current help screen
 */
int
u_help(BASE *base)
{
	W *w = base->parent;
	struct help *new_help;

	if (w->huh && (new_help = find_context_help(w->huh)) != NULL) {
		if (help_actual != new_help) {
			if (w->t->wind != skiptop)
				help_off(w->t);
			help_actual = new_help;		/* prepare context help */
		}
	}
	if (w->t->wind == skiptop) {
		return help_on(w->t);			/* help screen is hidden, so show the actual one */
	} else {
		help_off(w->t);				/* hide actual help screen */
		return 0;
	}
}

/*
 * Show next help screen (if it is possible)
 */
int
u_help_next(BASE *base)
{
	W *w = base->parent;

	if (help_actual && help_actual->next) {		/* is there any next help screen? */
		if (w->t->wind != skiptop) {
			help_off(w->t);			/* if help screen was visible, then hide it */
		}
		help_actual = help_actual->next;	/* change to next help screen */
		return help_on(w->t);			/* show actual help screen */
	} else {
		return -1;
	}
}

/*
 * Show previous help screen (if it is possible)
 */
int
u_help_prev(BASE *base)
{
	W *w = base->parent;

	if (help_actual && help_actual->prev) {		/* is there any previous help screen? */
		if (w->t->wind != skiptop)
			help_off(w->t);			/* if help screen was visible, then hide it */
		help_actual = help_actual->prev;	/* change to previous help screen */
		return help_on(w->t);			/* show actual help screen */
	} else {
		return -1;
	}
}
@


1.17
log
@plug another leak
@
text
@a29 2
#define NOT_ENOUGH_MEMORY -11

a33 3
 * Returns 0 if the help file was succefully processed
 *        -1 if the help file couldn't be opened
 *        NOT_ENOUGH_MEMORY if there is not enough memory
d35 1
a35 1
int
a39 1

d41 1
a41 3
	unsigned int bfl;				/* buffer length */
	unsigned int hlpsiz, hlpbsz;			/* number of used/allocated bytes for tmp->text */
	unsigned char *tempbuf;
d43 3
a45 2
	if (!(fd = jfopen((const char *)filename, "r")))/* open the help file */
		return (-1);				/* return if we couldn't open the file */
d50 10
a59 40
	while (jfgets((char *)buf, sizeof(buf), fd)) {
		if (buf[0] == '{'/*}*/) {		/* start of help screen */
			if (!(tmp = malloc(sizeof(struct help)))) {
 out:
				jfclose(fd);
				return (NOT_ENOUGH_MEMORY);
			}

			tmp->text = NULL;
			tmp->lines = 0;
			hlpsiz = 0;
			hlpbsz = 0;
			tmp->name = vsncpy(NULL, 0, sz(buf + 1) - 1);

			while ((jfgets((char *)buf, sizeof(buf), fd)) &&
			    (buf[0] != /*{*/'}')) {
				bfl = strlen((char *)buf);
				if (hlpsiz + bfl > hlpbsz) {
					if (tmp->text) {
						tempbuf = realloc(tmp->text, hlpbsz + bfl + 1024);
						if (!tempbuf) {
							free(tmp->text);
							free(tmp);
							goto out;
						} else {
							tmp->text = tempbuf;
						}
					} else {
						tmp->text = malloc(bfl + 1024);
						if (!tmp->text) {
							free(tmp);
							goto out;
						} else {
							tmp->text[0] = 0;
						}
					}
					hlpbsz += bfl + 1024;
				}
				strlcpy((char *)(tmp->text + hlpsiz), (char *)buf, 1024);
				hlpsiz += bfl;
d62 3
a64 10
			if (buf[0] == /*{*/'}') {	/* set new help screen as actual one */
				tmp->prev = help_actual;
				tmp->next = NULL;
				if (help_actual) {
					help_actual->next = tmp;
				}
				help_actual = tmp;
			} else {
				fprintf(stderr, /*{*/ "\nHelp file '%s' is not properly ended with } on new line.\n", filename);
				fprintf(stderr, "Do you want to accept incomplete help screen (y/n)?");
d66 1
a66 1
				if (fgets((char *)buf, 8, stdin) == NULL ||
d68 2
a69 1
					free(tmp->text);
d71 1
a71 8
					goto succ;
				} else {
					tmp->prev = help_actual;
					tmp->next = NULL;
					if (help_actual) {
						help_actual->next = tmp;
					}
					help_actual = tmp;
d74 10
d87 1
a87 1
succ:
d92 1
a92 1
	while (help_actual && help_actual->prev) {
a93 3
	}

	return (0);
@


1.16
log
@fix (almost) impossible nil pointer deref plus constify
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.15 2017/12/08 03:24:15 tg Exp $");
d52 1
a52 1
		return -1;				/* return if we couldn't open the file */
d58 1
a58 1
		if (buf[0] == '{') {			/* start of help screen */
d60 3
a62 1
				return NOT_ENOUGH_MEMORY;
d71 2
a72 1
			while ((jfgets((char *)buf, sizeof(buf), fd)) && (buf[0] != '}')) {
d80 1
a80 1
							return NOT_ENOUGH_MEMORY;
d88 1
a88 1
							return NOT_ENOUGH_MEMORY;
d99 1
a99 1
			if (buf[0] == '}') {		/* set new help screen as actual one */
d107 1
a107 1
				fprintf(stderr, "\nHelp file '%s' is not properly ended with } on new line.\n", filename);
d114 1
a114 1
					return 0;
a125 2
	jfclose(fd);					/* close help file */

d127 3
d131 2
a132 1
	while (help_actual && help_actual->prev) {	/* move to first help screen */
d136 1
a136 1
	return 0;
@


1.15
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.14 2017/12/08 02:00:39 tg Exp $");
d158 1
a158 1
	unsigned char *str;
d165 1
a165 1
		str = NULL;
d170 1
a170 1
			unsigned char *start = str;
@


1.14
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.13 2017/12/06 23:17:33 tg Exp $");
d108 1
a108 1
				    (!((buf[0] == 'y') || (buf[0] == 'Y')))) {
@


1.13
log
@whitespace at EOL annoys me
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.12 2017/12/06 23:02:02 tg Exp $");
d59 1
a59 1
			if (!(tmp = (struct help *) joe_malloc(sizeof(struct help)))) {
d73 1
a73 1
						tempbuf = (unsigned char *) joe_realloc(tmp->text, hlpbsz + bfl + 1024);
d75 2
a76 2
							joe_free(tmp->text);
							joe_free(tmp);
d82 1
a82 1
						tmp->text = (unsigned char *) joe_malloc(bfl + 1024);
d84 1
a84 1
							joe_free(tmp);
d109 2
a110 2
					joe_free(tmp->text);
					joe_free(tmp);
@


1.12
log
@lots of fixes related to prototyping
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/help.c,v 1.11 2017/12/02 02:07:26 tg Exp $");
d34 1
a34 1
/* 
d37 1
a37 1
 *        -1 if the help file couldn't be opened 
d126 1
a126 1
	
d264 1
a264 1
						case 0:	
d287 1
a287 1
 * Show help screen 
@


1.11
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
d23 1
a29 2
extern void outatr_help(SCRN *,int *,int *,int,int,int,int);

d40 2
a41 2

int help_init(unsigned char *filename)
d51 1
a51 1
	if (!(fd = jfopen((char *)filename, "r")))		/* open the help file */
d138 2
a139 1
struct help *find_context_help(const unsigned char *name)
d155 2
a156 1
void help_display(SCREEN *t)
d289 2
a290 1
int help_on(SCREEN *t)
d312 2
a313 1
void help_off(SCREEN *t)
d322 2
a323 1
int u_help(BASE *base)
d346 2
a347 1
int u_help_next(BASE *base)
d365 2
a366 1
int u_help_prev(BASE *base)
@


1.10
log
@fixup C1 display in help screen char table
@
text
@a0 1
/* $MirOS: contrib/code/jupp/help.c,v 1.6 2011/07/16 21:57:57 tg Exp $ */
d12 2
a13 1
#include <stdio.h>
@


1.9
log
@simplify
@
text
@d29 2
d158 1
a158 1
	int y, x, c, z;
d268 4
a271 3
					c = *str++;
					outatr(locale_map, t->t, t->t->scrn + x + y * t->w, 
					             t->t->attr + x + y * t->w, x, y, c, atr);
@


1.8
log
@these now all need <stdlib.h>
@
text
@a263 2
						default:
							c = *str++;
a264 2
					} else {
						c = *str++;
d266 1
@


1.7
log
@new command: helpcard
@
text
@d14 1
@


1.6
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/help.c,v 1.5 2009/10/18 14:17:34 tg Exp $ */
d136 1
a136 1
struct help *find_context_help(unsigned char *name)
d309 1
a309 1
static void help_off(SCREEN *t)
@


1.5
log
@add built-in (minimal) jupprc, for stand-alone things
backported from joe 3.7 (Debian)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/help.c,v 1.4 2009/10/06 09:07:30 tg Exp $ */
d105 2
a106 2
				fgets((char *)buf, 8, stdin);
				if (!((buf[0] == 'y') || (buf[0] == 'Y'))) {
@


1.4
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/help.c,v 1.3 2008/05/13 13:08:22 tg Exp $ */
d21 1
d41 1
a41 1
	FILE *fd;					/* help file */
d49 1
a49 1
	if (!(fd = fopen((char *)filename, "r")))		/* open the help file */
d55 1
a55 1
	while (fgets((char *)buf, sizeof(buf), fd)) {
d67 1
a67 1
			while ((fgets((char *)buf, sizeof(buf), fd)) && (buf[0] != '}')) {
d121 1
a121 1
	fclose(fd);					/* close help file */
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d16 4
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d84 1
a84 1
				strcpy((char *)(tmp->text + hlpsiz), (char *)buf);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 10
a10 2
/* Help system
   Copyright (C) 1992 Joseph H. Allen
d12 2
a13 1
This file is part of JOE (Joe's Own Editor)
d15 1
a15 18
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include "config.h"
#include "tty.h"
#include "b.h"
#include "termcap.h"
#include "kbd.h"
d17 3
a20 6
#include "vs.h"
#include "menu.h"
#include "zstr.h"
#include "tw.h"
#include "blocks.h"
#include "help.h"
d22 3
a24 1
/* The loaded help screen */
d26 340
a365 142
char *hlptxt=0;
int hlpsiz=0;
int hlpbsz=0;
int hlplns=0;

char **help_names;
struct help **help_structs;
struct help *first_help;

int helpcursor=0;

int get_help(name)
char *name;
 {
 int x;
 for(x=0;help_structs[x];++x) if(!zcmp(help_structs[x]->name,name)) break;
 if(help_structs[x]) return x;
 else return -1;
 }

/* Display help text */

void dsphlp(t)
SCREEN *t;
 {
 char *str=hlptxt;
 int y,x,c;
 int atr=0;
 for(y=skiptop;y!=t->wind;++y)
  {
  if(t->t->updtab[y])
   {
   for(x=0;x!=t->w-1;++x)
    if(*str=='\n' || !*str)
     if(eraeol(t->t,x,y)) return;
     else break;
    else
     {
     if(*str=='\\')
      switch(*++str)
       {
       case 'i': case 'I': atr^=INVERSE; ++str; --x; goto cont;
       case 'u': case 'U': atr^=UNDERLINE; ++str; --x; goto cont;
       case 'd': case 'D': atr^=DIM; ++str; --x; goto cont;
       case 'b': case 'B': atr^=BOLD; ++str; --x; goto cont;
       case 'f': case 'F': atr^=BLINK; ++str; --x; goto cont;
       case 0: --x; goto cont;
       default: c=(unsigned char)*str++;
       }
     else c= (unsigned char)*str++;
     outatr(t->t,t->t->scrn+x+y*t->w,x,y,c,atr);
     cont:;
     }
   atr=0; t->t->updtab[y]=0;
   }
  while(*str && *str!='\n') ++str;
  if(*str=='\n') ++str;
  }
 }

/* Create the help window */

int helpon(t)
SCREEN *t;
 {
 struct help *h=help_structs[helpcursor];
 hlptxt=h->hlptxt;
 hlpsiz=h->hlpsiz;
 hlpbsz=h->hlpbsz;
 hlplns=h->hlplns;
 if(!hlptxt) return -1;
 t->wind=hlplns+skiptop;
 if(t->h-t->wind<FITHEIGHT) t->wind=t->h-FITHEIGHT;
 if(t->wind<0)
  {
  t->wind=skiptop;
  return -1;
  }
 wfit(t);
 msetI(t->t->updtab+skiptop,1,t->wind);
 return 0;
 }

/* Eliminate the help window */

void helpoff(t)
SCREEN *t;
 {
 int z=t->wind;
 t->wind=skiptop;
 wfit(t);
 }

/* Toggle help on/off */

int uhelp(base)
BASE *base;
 {
 W *w=base->parent;
 int h;
 if(w->huh && (h=get_help(w->huh))>-1)
  {
  if(w->t->wind!=skiptop) helpoff(w->t);
  helpcursor=h;
  return helpon(w->t);
  }
 else if(w->t->wind==skiptop)
  return helpon(w->t);
 else
  {
  helpoff(w->t);
  return 0;
  }
 }

/* Goto next/prev help screen */

int uhnext(base)
BASE *base;
 {
 W *w=base->parent;
 if(help_structs[helpcursor+1])
  {
  if(w->t->wind!=skiptop) helpoff(w->t);
  ++helpcursor;
  return helpon(w->t);
  }
 else return -1;
 }

int uhprev(base)
BASE *base;
 {
 W *w=base->parent;
 if(helpcursor)
  {
  if(w->t->wind!=skiptop) helpoff(w->t);
  --helpcursor;
  return helpon(w->t);
  }
 else return -1;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
