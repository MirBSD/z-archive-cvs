head	1.14;
access;
symbols
	joe-3_1jupp38:1.14
	joe-3_1jupp37:1.13
	joe-3_1jupp36:1.13
	joe-3_1jupp35:1.13
	joe-3_1jupp34:1.13
	joe-3_1jupp33:1.13
	joe-3_1jupp32:1.12
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.7
	joe-3_1jupp30:1.7
	joe-3_1jupp29:1.6
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.5
	joe-3_1jupp26:1.5
	joe-3_1jupp25:1.5
	joe-3_1jupp24:1.5
	joe-3_1jupp23:1.5
	joe-3_1jupp22:1.2
	joe-3_1jupp21:1.2
	joe-3_1jupp20:1.2
	joe-3_1jupp19:1.2
	joe-3_1jupp18:1.2
	joe-3_1jupp17:1.2
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.2
	joe-3_1jupp15:1.2
	joe-3_1jupp14:1.2
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.14
date	2018.11.11.18.15.39;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005BE871D325833018;

1.13
date	2017.12.20.22.52.11;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A3AE99F623CA5FA;

1.12
date	2017.12.08.02.28.08;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A29F8C708B176AB;

1.11
date	2017.12.08.02.00.44;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A29F2506E789D2B;

1.10
date	2017.12.07.02.10.19;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A28A3145E1FF911;

1.9
date	2017.12.06.21.17.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A285E5918D423C7;

1.8
date	2017.12.02.02.07.38;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A220AD65C90E687;

1.7
date	2017.01.11.22.56.50;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005876B84150F7CE16;

1.6
date	2014.07.25.21.26.45;	author tg;	state Exp;
branches;
next	1.5;
commitid	10053D2CB6A37E9E339;

1.5
date	2012.12.30.21.45.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050E0B5FE41C91584;

1.4
date	2012.12.30.17.10.58;	author tg;	state Exp;
branches;
next	1.3;
commitid	10050E075B939751F66;

1.3
date	2012.12.22.00.06.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10050D4F965570AEE79;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.26;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	Window system
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/w.c,v 1.12 2017/12/08 02:28:08 tg Exp $");

#include <stdlib.h>

#include "blocks.h"
#include "kbd.h"
#include "poshist.h"
#include "queue.h"
#include "rc.h"
#include "scrn.h"
#include "utils.h"
#include "utf8.h"
#include "w.h"

extern int dspasis;		/* Set to display chars above 127 as-is */
extern int staen;		/* 0 if top-most status line not displayed */

/* Count no. of main windows */

int countmain(SCREEN *t)
{
	int nmain = 1;
	W *m = t->curwin->main;
	W *q;

	for (q = t->curwin->link.next; q != t->curwin; q = q->link.next)
		if (q->main != m) {
			++nmain;
			m = q->main;
		}
	return nmain;
}

/* Redraw a window */

void wredraw(W *w)
{
	msetI(w->t->t->updtab + w->y, 1, w->h);
	msetI(w->t->t->syntab + w->y, -1, w->h);
}

/* Find first window in a group */

W *findtopw(W *w)
{
	W *x;

	for (x = w; x->link.prev->main == w->main && x->link.prev != w; x = x->link.prev) ;
	return x;
}

/* Determine height of a window.  Returns reqh if it is set, otherwise
 * used fixed or hh scaled to the current screen size */

static int geth(W *w)
{
	if (w->reqh)
		return w->reqh;
	else if (w->fixed)
		return w->fixed;
	else
		return (((long) w->t->h - w->t->wind) * w->hh) / 1000;
}

/* Set the height of a window */

static void seth(W *w, int h)
{
	long tmp;
	int tmpb;

	w->reqh = h;
	tmp = 1000L * h;
	tmpb = w->t->h - w->t->wind;
	w->hh = (tmp + (tmpb - 1)) / tmpb;
}

/* Determine height of a family of windows.  Uses 'reqh' if it's set */

int getgrouph(W *w)
{
	W *x;
	int h;

	/* Find first window in family */
	x = findtopw(w);

	/* Add heights of all windows in family */
	for (w = x, h = geth(w); w->link.next != x && w->link.next->main == x->main; w = w->link.next, h += geth(w)) ;

	return h;
}

/* Determine minimum height of a family */

static int getminh(W *w)
{
	W *x;
	int h;

	x = findtopw(w);
	for (w = x, h = (w->fixed ? w->fixed : 2); w->link.next != x && w->link.next->main == x->main; w = w->link.next, h += (w->fixed ? w->fixed : 2)) ;

	return h;
}

/* Find last window in a group */

W *findbotw(W *w)
{
	W *x;

	for (x = w; x->link.next->main == w->main && x->link.next != w; x = x->link.next) ;
	return x;
}

/* Demote group of window to end of window list.  Returns true if top window
   was demoted */

int demotegroup(W *w)
{
	W *top = findtopw(w);
	W *bot = findbotw(w);
	W *next;
	int flg = 0;

	for (w = top; w != bot; w = next) {
		next = w->link.next;
		if (w == w->t->topwin) {
			flg = 1;
			w->t->topwin = next;
		} else
			demote(W, link, w->t->topwin, w);
		w->y = -1;
	}
	if (w == w->t->topwin)
		flg = 1;
	else
		demote(W, link, w->t->topwin, w);
	w->y = -1;
	return flg;
}

/* Find last window on the screen */

W *lastw(SCREEN *t)
{
	W *x;

	for (x = t->topwin; x->link.next != t->topwin && x->link.next->y >= 0; x = x->link.next) ;
	return x;
}

/* Create a screen object */

SCREEN *scr;

SCREEN *screate(SCRN *scrn)
{
	SCREEN *t = malloc(sizeof(SCREEN));

	t->t = scrn;
	t->w = scrn->co;
	t->h = scrn->li;
	t->topwin = NULL;
	t->curwin = NULL;
	t->wind = skiptop;
	scr = t;
	return t;
}

void sresize(SCREEN *t)
{
	SCRN *scrn = t->t;
	W *w;

	t->w = scrn->co;
	t->h = scrn->li;
	if (t->h - t->wind < FITHEIGHT)
		t->wind = t->h - FITHEIGHT;
	if (t->wind < 0)
		t->wind = 0;
	w = t->topwin;
	do {
		w->y = -1;
		w->w = t->w - 1;
		w = w->link.next;
	} while (w != t->topwin);
	wfit(t);
	updall();
}

void updall(void)
{
	int y;

	for (y = 0; y != scr->h; ++y) {
		scr->t->updtab[y] = 1;
		scr->t->syntab[y] = -1;
		}
}

void scrins(B *b, long l, long n, int flg)
{
	W *w;

	if ((w = scr->topwin) != NULL) {
		do {
			if (w->y >= 0) {
				if (w->object.base && w->watom->ins)
					w->watom->ins(w->object.bw, b, l, n, flg);
			}
		w = w->link.next;
		} while (w != scr->topwin);
	}
}

void scrdel(B *b, long l, long n, int flg)
{
	W *w;

	if ((w = scr->topwin) != NULL) {
		do {
			if (w->y >= 0) {
				if (w->object.base && w->watom->del)
					w->watom->del(w->object.bw, b, l, n, flg);
			}
		w = w->link.next;
		} while (w != scr->topwin);
	}
}

/* Fit as many windows on the screen as is possible beginning with the window
 * at topwin.  Give any extra space which couldn't be used to fit in another
 * window to the last text window on the screen.  This function guarentees
 * to fit on the window with the cursor in it (moves topwin to next group
 * of windows until window with cursor fits on screen).
 */

static int doabort(W *w, int *ret);
extern volatile int dostaupd;

void wfit(SCREEN *t)
{
	int y;			/* Where next window goes */
	int left;		/* Lines left on screen */
	W *w;			/* Current window we're fitting */
	W *pw;			/* Main window of previous family */
	int req;		/* Amount this family needs */
	int adj;		/* Amount family needs to be adjusted */
	int flg = 0;		/* Set if cursor window was placed on screen */
	int ret;

	dostaupd = 1;

 tryagain:
	y = t->wind;
	left = t->h - y;
	pw = NULL;

	w = t->topwin;
	do {
		w->ny = -1;
		w->nh = geth(w);
		w = w->link.next;
	} while (w != t->topwin);

	/* Fit a group of windows on the screen */
	w = t->topwin;
	do {
		req = getgrouph(w);
		if (req > left)	/* If group is taller than lines left */
			adj = req - left;	/* then family gets shorter */
		else
			adj = 0;

		/* Fit a family of windows on the screen */
		do {
			w->ny = y;	/* Set window's y position */
			if (!w->win) {
				pw = w;
				w->nh -= adj;	/* Adjust main window of the group */
			}
			if (!w->win && w->nh < 2)
				while (w->nh < 2)
					w->nh += doabort(w->link.next, &ret);
			if (w == t->curwin)
				flg = 1;	/* Set if we got window with cursor */
			y += w->nh;
			left -= w->nh;	/* Increment y value by height of window */
			w = w->link.next;	/* Next window */
		} while (w != t->topwin && w->main == w->link.prev->main);
	} while (w != t->topwin && left >= FITHEIGHT);

	if (!pw)
		return;

	/* We can't use extra space to fit a new family on, so give space to parent of
	 * previous family */
	pw->nh += left;

	/* Adjust that family's children which are below the parent */
	while ((pw = pw->link.next) != w)
		pw->ny += left;

	/* Make sure the cursor window got on the screen */
	if (!flg) {
		t->topwin = findbotw(t->topwin)->link.next;
		goto tryagain;
	}

	/* All of the windows are now on the screen.  Scroll the screen to reflect what
	 * happened
	 */
	w = t->topwin;
	do {
		if (w->y >= 0 && w->ny >= 0)
			if (w->ny > w->y) {
				W *l = pw = w;

				while (pw->link.next != t->topwin && (pw->link.next->y < 0 || pw->link.next->ny < 0 || pw->link.next->ny > pw->link.next->y)) {
					pw = pw->link.next;
					if (pw->ny >= 0 && pw->y >= 0)
						l = pw;
				}
				/* Scroll windows between l and w */
 loop1:
				if (l->ny >= 0 && l->y >= 0)
					nscrldn(t->t, l->y, l->ny + uns_min(l->h, l->nh), l->ny - l->y);
				if (w != l) {
					l = l->link.prev;
					goto loop1;
				}
				w = pw->link.next;
			} else if (w->ny < w->y) {
				W *l = pw = w;

				while (pw->link.next != t->topwin && (pw->link.next->y < 0 || pw->link.next->ny < 0 || pw->link.next->ny < pw->link.next->y)) {
					pw = pw->link.next;
					if (pw->ny >= 0 && pw->y >= 0)
						l = pw;
				}
				/* Scroll windows between l and w */
 loop0:
				if (w->ny >= 0 && w->y >= 0)
					nscrlup(t->t, w->ny, w->y + uns_min(w->h, w->nh), w->y - w->ny);
				if (w != l) {
					w = w->link.next;
					goto loop0;
				}
				w = pw->link.next;
			} else
				w = w->link.next;
		else
			w = w->link.next;
	} while (w != t->topwin);

	/* Update current height and position values */
	w = t->topwin;
	do {
		if (w->ny >= 0) {
			if (w->object.base) {
				if (w->watom->move)
					w->watom->move(w->object, w->x, w->ny);
				if (w->watom->resize)
					w->watom->resize(w->object, w->w, w->nh);
			}
			if (w->y == -1) {
				msetI(t->t->updtab + w->ny, 1, w->nh);
				msetI(t->t->syntab + w->ny, -1, w->nh);
				}
			w->y = w->ny;
		} else
			w->y = -1;
		w->h = w->nh;
		w->reqh = 0;
		w = w->link.next;
	} while (w != t->topwin);
}

/* Goto next window */

int wnext(SCREEN *t)
{
	if (t->curwin->link.next != t->curwin) {
		t->curwin = t->curwin->link.next;
		if (t->curwin->y == -1)
			wfit(t);
		return 0;
	} else
		return -1;
}

/* Goto previous window */

int wprev(SCREEN *t)
{
	if (t->curwin->link.prev != t->curwin) {
		t->curwin = t->curwin->link.prev;
		if (t->curwin->y == -1) {
			t->topwin = findtopw(t->curwin);
			wfit(t);
		}
		return 0;
	} else
		return -1;
}

/* Grow window */

int wgrow(W *w)
{
	W *nextw;

	/* If we're the last window on the screen, shrink the previous window */
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) && w != w->t->topwin)
		return wshrink(w->link.prev->main);

	/* Get to next variable size window */
	for (nextw = w->link.next; nextw->fixed && nextw != w->t->topwin; nextw = nextw->link.next) ;

	/* Is it below us, on screen and big enough to take space from? */
	if (nextw == w->t->topwin || nextw->y == -1 || nextw->h <= FITHEIGHT)
		return -1;

	/* Increase this window's height */
	seth(w, w->h + 1);

	/* Decrease next window's height */
	seth(nextw, nextw->h - 1);

	/* Do it */
	wfit(w->t);

	return 0;
}

/* Shrink window */

int wshrink(W *w)
{
	W *nextw;

	/* If we're the last window on the screen, grow the previous window */
	if ((w->link.next == w->t->topwin || w->link.next->y == -1) && w != w->t->topwin)
		return wgrow(w->link.prev->main);

	/* Is this window too small already? */
	if (w->h <= FITHEIGHT)
		return -1;

	/* Get to window below us */
	for (nextw = w->link.next; nextw != w->t->topwin && nextw->fixed; nextw = nextw->link.next) ;
	if (nextw == w->t->topwin)
		return -1;

	/* Decrease the size of this window */
	seth(w, w->h - 1);

	/* Increase the size of next window */
	seth(nextw, nextw->h + 1);

	/* Do it */
	wfit(w->t);

	return 0;
}

/* Show all windows */

void wshowall(SCREEN *t)
{
	int n = 0;
	int set;
	W *w;

	/* Count no. of main windows */
	w = t->topwin;
	do {
		if (!w->win)
			++n;
		w = w->link.next;
	} while (w != t->topwin);

	/* Compute size to set each window */
	if ((set = (t->h - t->wind) / (n ? n : 1)) < FITHEIGHT)
		set = FITHEIGHT;

	/* Set size of each variable size window */
	w = t->topwin;
	do {
		if (!w->win) {
			int h = getminh(w);

			if (h >= set)
				seth(w, 2);
			else
				seth(w, set - (h - 2));
			w->orgwin = NULL;
		}
		w = w->link.next;
	} while (w != t->topwin);

	/* Do it */
	wfit(t);
}

static void wspread(SCREEN *t)
{
	int n = 0;
	W *w = t->topwin;

	do {
		if (w->y >= 0 && !w->win)
			++n;
		w = w->link.next;
	} while (w != t->topwin);
	if (!n) {
		wfit(t);
		return;
	}
	if ((t->h - t->wind) / n >= FITHEIGHT)
		n = (t->h - t->wind) / n;
	else
		n = FITHEIGHT;
	w = t->topwin;
	do {
		if (!w->win) {
			int h = getminh(w);

			if (h >= n)
				seth(w, 2);
			else
				seth(w, n - (h - 2));
			w->orgwin = NULL;
		}
		w = w->link.next;
	} while (w != t->topwin);
	wfit(t);
}

/* Show just one family of windows */

void wshowone(W *w)
{
	W *q = w->t->topwin;

	do {
		if (!q->win) {
			seth(q, w->t->h - w->t->wind - (getminh(q) - 2));
			q->orgwin = NULL;
		}
		q = q->link.next;
	} while (q != w->t->topwin);
	wfit(w->t);
}

/* Create a window */

W *wcreate(SCREEN *t, WATOM *watom, W *where, W *target, W *original, int height, const unsigned char *huh, int *notify)
{
	W *new;

	if (height < 1)
		return NULL;

	/* Create the window */
	new = malloc(sizeof(W));
	new->notify = notify;
	new->t = t;
	new->w = t->w - 1;
	seth(new, height);
	new->h = new->reqh;
	new->y = -1;
	new->ny = 0;
	new->nh = 0;
	new->x = 0;
	new->huh = huh;
	new->orgwin = original;
	new->watom = watom;
	new->object.base = NULL;
	new->msgb = NULL;
	new->msgt = NULL;
	/* Set window's target and family */
	if ((new->win = target) != NULL) {
		/* a subwindow */
		new->main = target->main;
		new->fixed = height;
	} else {
		/* a parent window */
		new->main = new;
		new->fixed = 0;
	}

	/* Get space for window */
	if (original) {
		if (original->h - height <= 2) {
			/* Not enough space for window */
			free(new);
			return NULL;
		} else
			seth(original, original->h - height);
	}

	/* Create new keyboard handler for window */
	if (watom->context)
		new->kbd = mkkbd(kmap_getcontext(watom->context, 1));
	else
		new->kbd = NULL;

	/* Put window on the screen */
	if (where)
		enquef(W, link, where, new);
	else {
		if (t->topwin)
			enqueb(W, link, t->topwin, new);
		else {
			izque(W, link, new);
			t->curwin = t->topwin = new;
		}
	}

	return new;
}

/* Abort group of windows */

static int doabort(W *w, int *ret)
{
	int amnt = geth(w);
	W *z;

	w->y = -2;
	if (w->t->topwin == w)
		w->t->topwin = w->link.next;
 loop:
	z = w->t->topwin;
	do {
		if (z->orgwin == w)
			z->orgwin = NULL;
		if ((z->win == w || z->main == w) && z->y != -2) {
			amnt += doabort(z, ret);
			goto loop;
		}
	} while (z = z->link.next, z != w->t->topwin);
	if (w->orgwin)
		seth(w->orgwin, geth(w->orgwin) + geth(w));
	if (w->t->curwin == w) {
		if (w->t->curwin->win)
			w->t->curwin = w->t->curwin->win;
		else if (w->orgwin)
			w->t->curwin = w->orgwin;
		else
			w->t->curwin = w->link.next;
	}
	if (qempty(W, link, w)) {
		leave = 1;
		amnt = 0;
	}
	deque(W, link, w);
	if (w->watom->abort && w->object.base) {
		*ret = w->watom->abort(w->object);
		if (w->notify)
			*w->notify = -1;
	} else {
		*ret = -1;
		if (w->notify)
			*w->notify = 1;
	}
	rmkbd(w->kbd);
	windie(w);
	free(w);
	return amnt;
}

/* Abort a window and its children */

int wabort(W *w)
{
	SCREEN *t = w->t;
	int ret;

	if (w != w->main) {
		doabort(w, &ret);
		if (!leave)
			wfit(t);
	} else {
		doabort(w, &ret);
		if (!leave) {
			if (lastw(t)->link.next != t->topwin)
				wfit(t);
			else
				wspread(t);
		}
	}
	return ret;
}

/* Display a message and skip the next key */

static void mdisp(SCRN *t, int y, const unsigned char *s)
{
	int ofst;
	int len;

	len = fmtlen(s);
	if (len <= (t->co - 1))
		ofst = 0;
	else
		ofst = len - (t->co - 1);
	genfmt(t, 0, y, ofst, s, 1);
	t->updtab[y] = 1;
}

void msgout(W *w)
{
	SCRN *t = w->t->t;

	if (w->msgb) {
		mdisp(t, w->y + w->h - 1, w->msgb);
		w->msgb = NULL;
	}
	if (w->msgt) {
		mdisp(t, w->y + ((w->h > 1 && (w->y || !staen)) ? 1 : 0), w->msgt);
		w->msgt = NULL;
	}
}

/* Set temporary message */

unsigned char msgbuf[JOE_MSGBUFSIZE];

/* display message on bottom line of window */
void msgnw(W *w, const unsigned char *s)
{
	w->msgb = s;
}

void msgnwt(W *w, const unsigned char *s)
{
	w->msgt = s;
}

int urtn(jobject jO, int k)
{
	BASE *b = jO.base;

	if (b->parent->watom->rtn)
		return b->parent->watom->rtn(jO);
	else
		return -1;
}

int utype(jobject jO, int k)
{
	BASE *b = jO.base;

	if (b->parent->watom->type)
		return b->parent->watom->type(jO, k);
	else
		return -1;
}

/* Window user commands */

int uprevw(BASE *bw)
{
	return wprev(bw->parent->t);
}

int unextw(BASE *bw)
{
	return wnext(bw->parent->t);
}

int ugroww(BASE *bw)
{
	return wgrow(bw->parent);
}

int ushrnk(BASE *bw)
{
	return wshrink(bw->parent);
}

int uexpld(BASE *bw)
{
	if (bw->parent->t->h - bw->parent->t->wind == getgrouph(bw->parent))
		wshowall(bw->parent->t);
	else
		wshowone(bw->parent);
	return 0;
}

int uretyp(BASE *bw)
{
	nredraw(bw->parent->t->t);
	return 0;
}
@


1.13
log
@fix something flagged as use-after-free…

… except windie() never dereferences it, merely garbage-collects,
but reordering is still wise
@
text
@d595 2
a596 2
/* was:	if (new->win = target) {	which may be mistyped == */
	if ((new->win = target) != NULL) {	/* A subwindow */
d599 2
a600 1
	} else {		/* A parent window */
@


1.12
log
@label indent; small tweaks while here
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/w.c,v 1.11 2017/12/08 02:00:44 tg Exp $");
d680 1
a681 1
	windie(w);
@


1.11
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/w.c,v 1.10 2017/12/07 02:10:19 tg Exp $");
d266 1
a266 1
      tryagain:
d337 1
a337 1
			      loop1:
d354 1
a354 1
			      loop0:
d645 1
a645 1
      loop:
@


1.10
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/w.c,v 1.9 2017/12/06 21:17:05 tg Exp $");
d170 1
a170 1
	SCREEN *t = (SCREEN *) joe_malloc(sizeof(SCREEN));
d578 1
a578 1
	new = (W *) joe_malloc(sizeof(W));
d608 1
a608 1
			joe_free(new);
d680 1
a680 1
	joe_free(w);
@


1.9
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/w.c,v 1.8 2017/12/02 02:07:38 tg Exp $");
d220 2
a221 2
				if (w->object && w->watom->ins)
					w->watom->ins(w->object, b, l, n, flg);
d235 2
a236 2
				if (w->object && w->watom->del)
					w->watom->del(w->object, b, l, n, flg);
d372 1
a372 1
			if (w->object) {
d591 1
a591 1
	new->object = NULL;
d670 1
a670 1
	if (w->watom->abort && w->object) {
d753 1
a753 1
int urtn(BASE *b, int k)
d755 2
d758 1
a758 1
		return b->parent->watom->rtn(b, k);
d763 1
a763 1
int utype(BASE *b, int k)
d765 2
d768 1
a768 1
		return b->parent->watom->type(b, k);
@


1.8
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a12 1
#ifdef HAVE_STDLIB_H
a13 1
#endif
@


1.7
log
@constify “huh” (… huh‽)
@
text
@a0 1
/* $MirOS: contrib/code/jupp/w.c,v 1.5 2012/12/30 21:45:18 tg Exp $ */
d11 2
@


1.6
log
@replace weird division plus modulo by commonly used
idiom for division with rounding up; style nitpick
in LP#1348614 by dcb (although I personally disagree,
the ternary operator was 100% clear here); arithmetic
confirmed by Natureshadow
@
text
@d571 1
a571 1
W *wcreate(SCREEN *t, WATOM *watom, W *where, W *target, W *original, int height, unsigned char *huh, int *notify)
@


1.5
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/w.c,v 1.3 2012/12/22 00:06:16 tg Exp $ */
d81 1
d85 2
a86 1
	w->hh = tmp / (w->t->h - w->t->wind) + (tmp % (w->t->h - w->t->wind) ? 1 : 0);
@


1.4
log
@more const cleanliness (and merr is used in a signal handler so it should be volatile), and use NULL not 0 for pointers
@
text
@d615 1
a615 1
		new->kbd = mkkbd(kmap_getcontext(watom->context));
@


1.3
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/w.c,v 1.2 2008/05/13 13:08:32 tg Exp $ */
d709 1
a709 1
static void mdisp(SCRN *t, int y, unsigned char *s)
d729 1
a729 1
		w->msgb = 0;
d733 1
a733 1
		w->msgt = 0;
d742 1
a742 1
void msgnw(W *w, unsigned char *s)
d747 1
a747 1
void msgnwt(W *w, unsigned char *s)
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d304 3
d495 1
a495 1
	if ((set = (t->h - t->wind) / n) < FITHEIGHT)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Window system
   Copyright (C) 1992 Joseph H. Allen
d11 3
a13 1
This file is part of JOE (Joe's Own Editor)
d15 5
a19 15
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#include "config.h"
#include "b.h"
d21 2
a22 5
#include "queue.h"
#include "main.h"
#include "poshist.h"
#include "blocks.h"
#include "zstr.h"
d25 2
a26 2
extern int dspasis;	/* Set to display chars above 127 as-is */
extern int staen;	/* 0 if top-most status line not displayed */
d30 13
a42 14
int countmain(t)
SCREEN *t;
 {
 int nmain=1;
 W *m=t->curwin->main;
 W *q;
 for(q=t->curwin->link.next;q!=t->curwin;q=q->link.next)
  if(q->main!=m)
   {
   ++nmain;
   m=q->main;
   }
 return nmain;
 }
d46 5
a50 5
void wredraw(w)
W *w;
 {
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
d54 7
a60 7
W *findtopw(w)
W *w;
 {
 W *x;
 for(x=w;x->link.prev->main==w->main && x->link.prev!=w;x=x->link.prev);
 return x;
 }
d65 9
a73 8
int geth(w)
W *w;
 {
 if(w->reqh) return w->reqh;
 else
  if(w->fixed) return w->fixed;
  else return (((long)w->t->h-w->t->wind)*w->hh)/1000;
 }
d77 8
a84 8
void seth(w,h)
W *w;
 {
 long tmp;
 w->reqh=h;
 tmp=1000L*h;
 w->hh=tmp/(w->t->h-w->t->wind)+(tmp%(w->t->h-w->t->wind)?1:0);
 }
d88 7
a94 13
int getgrouph(w)
W *w;
 {
 W *x;
 int h;

 /* Find first window in family */
 x=findtopw(w);

 /* Add heights of all windows in family */
 for(w=x, h=geth(w);
     w->link.next!=x && w->link.next->main==x->main;
     w=w->link.next, h+=geth(w));
d96 5
a100 2
 return h;
 }
d104 7
a110 9
int getminh(w)
W *w;
 {
 W *x;
 int h;
 x=findtopw(w);
 for(w=x, h=(w->fixed?w->fixed:2);
     w->link.next!=x && w->link.next->main==x->main;
     w=w->link.next, h+=(w->fixed?w->fixed:2));
d112 2
a113 2
 return h;
 }
d117 7
a123 7
W *findbotw(w)
W *w;
 {
 W *x;
 for(x=w;x->link.next->main==w->main && x->link.next!=w;x=x->link.next);
 return x;
 }
d128 23
a150 19
int demotegroup(w)
W *w;
 {
 W *top=findtopw(w);
 W *bot=findbotw(w);
 W *next;
 int flg=0;
 for(w=top;w!=bot;w=next)
  {
  next=w->link.next;
  if(w==w->t->topwin) flg=1, w->t->topwin=next;
  else demote(W,link,w->t->topwin,w);
  w->y= -1;
  }
 if(w==w->t->topwin) flg=1;
 else demote(W,link,w->t->topwin,w);
 w->y= -1;
 return flg;
 }
d154 7
a160 7
W *lastw(t)
SCREEN *t;
 {
 W *x;
 for(x=t->topwin;x->link.next!=t->topwin && x->link.next->y>=0;x=x->link.next);
 return x;
 }
d166 74
a239 63
SCREEN *screate(scrn)
SCRN *scrn;
 {
 SCREEN *t=(SCREEN *)malloc(sizeof(SCREEN));
 t->t=scrn;
 t->w=scrn->co;
 t->h=scrn->li;
 t->topwin=0;
 t->curwin=0;
 t->wind=skiptop;
 scr=t;
 return t;
 }

void sresize(t)
SCREEN *t;
 {
 SCRN *scrn=t->t;
 W *w;
 t->w=scrn->co;
 t->h=scrn->li;
 if(t->h-t->wind<FITHEIGHT) t->wind=t->h-FITHEIGHT;
 if(t->wind<0) t->wind=0;
 w=t->topwin; do
  w->y= -1, w->w=t->w-1;
  while(w=w->link.next, w!=t->topwin);
 wfit(t);
 updall();
 }

void updall()
 {
 int y;
 for(y=0;y!=scr->h;++y) scr->t->updtab[y]=1;
 }

void scrins(b,l,n,flg)
B *b;
long l,n;
int flg;
 {
 W *w;
 if(w=scr->topwin) do
  if(w->y>=0)
   {
   if(w->object && w->watom->ins) w->watom->ins(w->object,b,l,n,flg);
   }
  while(w=w->link.next, w!=scr->topwin);
 }

void scrdel(b,l,n,flg)
B *b;
long l,n;
int flg;
 {
 W *w;
 if(w=scr->topwin) do
  if(w->y>=0)
   {
   if(w->object && w->watom->del) w->watom->del(w->object,b,l,n,flg);
   }
  while(w=w->link.next, w!=scr->topwin);
 }
d248 2
a249 2
static int doabort();
extern int dostaupd;
d251 134
a384 128
void wfit(t)
SCREEN *t;
 {
 int y;		/* Where next window goes */
 int left;	/* Lines left on screen */
 W *w;		/* Current window we're fitting */
 W *pw;		/* Main window of previous family */
 int req;	/* Amount this family needs */
 int adj;	/* Amount family needs to be adjusted */
 int flg=0;	/* Set if cursor window was placed on screen */
 int ret;
 dostaupd=1;

 tryagain:
 y=t->wind; left=t->h-y; pw=0;

 w=t->topwin; do
  {
  w->ny= -1;
  w->nh=geth(w);
  }
  while((w=w->link.next)!=t->topwin);

 /* Fit a group of windows on the screen */
 w=t->topwin; do
  {
  req=getgrouph(w);
  if(req>left)		/* If group is taller than lines left */
   adj=req-left;		/* then family gets shorter */
  else adj=0;
  
  /* Fit a family of windows on the screen */
  do
   {
   w->ny=y;			/* Set window's y position */
   if(!w->win) pw=w, w->nh-=adj;	/* Adjust main window of the group */
   if(!w->win && w->nh<2) while(w->nh<2) w->nh+=doabort(w->link.next,&ret);
   if(w==t->curwin) flg=1;	/* Set if we got window with cursor */
   y+=w->nh; left-=w->nh;	/* Increment y value by height of window */
   w=w->link.next;		/* Next window */
   } while(w!=t->topwin && w->main==w->link.prev->main);
  } while(w!=t->topwin && left>=FITHEIGHT);

 /* We can't use extra space to fit a new family on, so give space to parent of
  * previous family */
 pw->nh+=left;

 /* Adjust that family's children which are below the parent */
 while((pw=pw->link.next)!=w) pw->ny+=left;

 /* Make sure the cursor window got on the screen */
 if(!flg)
  {
  t->topwin=findbotw(t->topwin)->link.next;
  goto tryagain;
  }

 /* All of the windows are now on the screen.  Scroll the screen to reflect what
  * happened
  */
 w=t->topwin; do
  if(w->y>=0 && w->ny>=0)
   if(w->ny>w->y)
    {
    W *l=pw=w;
    while(pw->link.next!=t->topwin &&
          (pw->link.next->y<0 || pw->link.next->ny<0 ||
          pw->link.next->ny>pw->link.next->y))
     {
     pw=pw->link.next;
     if(pw->ny>=0 && pw->y>=0) l=pw;
     }
    /* Scroll windows between l and w */
    loop1:
    if(l->ny>=0 && l->y>=0)
     nscrldn(t->t,l->y,l->ny+Umin(l->h,l->nh),l->ny-l->y);
    if(w!=l)
     {
     l=l->link.prev;
     goto loop1;
     }
    w=pw->link.next;
    }
   else if(w->ny<w->y)
    {
    W *l=pw=w;
    while(pw->link.next!=t->topwin &&
          (pw->link.next->y<0 || 
          pw->link.next->ny<0 || 
          pw->link.next->ny<pw->link.next->y))
     {
     pw=pw->link.next;
     if(pw->ny>=0 && pw->y>=0) l=pw;
     }
    /* Scroll windows between l and w */
    loop0:
    if(w->ny>=0 && w->y>=0)
     nscrlup(t->t,w->ny,w->y+Umin(w->h,w->nh),w->y-w->ny);
    if(w!=l)
     {
     w=w->link.next;
     goto loop0;
     }
    w=pw->link.next;
    }
   else w=w->link.next;
  else w=w->link.next;
  while(w!=t->topwin);

 /* Update current height and position values */
 w=t->topwin; do
  {
  if(w->ny>=0)
   {
   if(w->object)
    {
    if(w->watom->move) w->watom->move(w->object,w->x,w->ny);
    if(w->watom->resize) w->watom->resize(w->object,w->w,w->nh);
    }
   if(w->y== -1) msetI(t->t->updtab+w->ny,1,w->nh);
   w->y=w->ny;
   }
  else w->y= -1;
  w->h=w->nh;
  w->reqh=0;
  }
  while(w=w->link.next, w!=t->topwin);
 }
d388 10
a397 11
int wnext(t)
SCREEN *t;
 {
 if(t->curwin->link.next!=t->curwin)
  {
  t->curwin=t->curwin->link.next;
  if(t->curwin->y== -1) wfit(t);
  return 0;
  }
 else return -1;
 }
d401 12
a412 15
int wprev(t)
SCREEN *t;
 {
 if(t->curwin->link.prev!=t->curwin)
  {
  t->curwin=t->curwin->link.prev;
  if(t->curwin->y== -1)
   {
   t->topwin=findtopw(t->curwin);
   wfit(t);
   }
  return 0;
  }
 else return -1;
 }
d416 17
a432 20
int wgrow(w)
W *w;
 {
 W *nextw;

 /* If we're the last window on the screen, shrink the previous window */
 if((w->link.next==w->t->topwin || w->link.next->y== -1) &&
    w!=w->t->topwin)
  return wshrink(w->link.prev->main);

 /* Get to next variable size window */
 for(nextw=w->link.next;nextw->fixed && nextw!=w->t->topwin;nextw=nextw->link.next);

 /* Is it below us, on screen and big enough to take space from? */
 if(nextw==w->t->topwin ||
    nextw->y== -1 ||
    nextw->h<=FITHEIGHT) return -1;

 /* Increase this window's height */
 seth(w,w->h+1);
d434 2
a435 2
 /* Decrease next window's height */
 seth(nextw,nextw->h-1);
d437 2
a438 2
 /* Do it */
 wfit(w->t);
d440 2
a441 2
 return 0;
 }
d445 19
a463 21
int wshrink(w)
W *w;
 {
 W *nextw;

 /* If we're the last window on the screen, grow the previous window */
 if((w->link.next==w->t->topwin || w->link.next->y== -1) &&
    w!=w->t->topwin)
  return wgrow(w->link.prev->main);

 /* Is this window too small already? */
 if(w->h<=FITHEIGHT) return -1;

 /* Get to window below us */
 for(nextw=w->link.next;
     nextw!=w->t->topwin && nextw->fixed;
     nextw=nextw->link.next);
 if(nextw==w->t->topwin) return -1;

 /* Decrease the size of this window */
 seth(w,w->h-1);
d465 2
a466 2
 /* Increase the size of next window */
 seth(nextw,nextw->h+1);
d468 2
a469 2
 /* Do it */
 wfit(w->t);
d471 2
a472 2
 return 0;
 }
d476 70
a545 55
void wshowall(t)
SCREEN *t;
 {
 int n=0;
 int set;
 W *w;

 /* Count no. of main windows */
 w=t->topwin; do
  if(!w->win) ++n;
  while(w=w->link.next, w!=t->topwin);

 /* Compute size to set each window */
 if((set=(t->h-t->wind)/n)<FITHEIGHT) set=FITHEIGHT;

 /* Set size of each variable size window */
 w=t->topwin; do
  if(!w->win)
   {
   int h=getminh(w);
   if(h>=set) seth(w,2);
   else seth(w,set-(h-2));
   w->orgwin=0;
   }
  while(w=w->link.next, w!=t->topwin);

 /* Do it */
 wfit(t);
 }

void wspread(t)
SCREEN *t;
 {
 int n=0;
 W *w=t->topwin; do
  if(w->y>=0 && !w->win) ++n;
  while(w=w->link.next, w!=t->topwin);
 if(!n)
  {
  wfit(t);
  return;
  }
 if((t->h-t->wind)/n>=FITHEIGHT) n=(t->h-t->wind)/n;
 else n=FITHEIGHT;
 w=t->topwin; do
  if(!w->win)
   {
   int h=getminh(w);
   if(h>=n) seth(w,2);
   else seth(w,n-(h-2));
   w->orgwin=0;
   }
  while(w=w->link.next, w!=t->topwin);
 wfit(t);
 }
d549 13
a561 12
void wshowone(w)
W *w;
 {
 W *q=w->t->topwin; do
  if(!q->win)
   {
   seth(q,w->t->h-w->t->wind-(getminh(q)-2));
   q->orgwin=0;
   }
  while(q=q->link.next, q!=w->t->topwin);
 wfit(w->t);
 }
d565 61
a625 61
W *wcreate(t,watom,where,target,original,height,huh,notify)
SCREEN *t;
WATOM *watom;
W *where, *target, *original;
int height;
char *huh;
int *notify;
 {
 W *new;

 if(height<1) return 0;

 /* Create the window */
 new=(W *)malloc(sizeof(W));
 new->notify=notify;
 new->t=t;
 new->w=t->w-1;
 seth(new,height);
 new->h=new->reqh;
 new->y= -1;
 new->ny=0; new->nh=0;
 new->x=0;
 new->huh=huh;
 new->orgwin=original;
 new->watom=watom;
 new->object=0;
 new->msgb=0;
 new->msgt=0;
 /* Set window's target and family */
 if(new->win=target)
  { /* A subwindow */
  new->main=target->main;
  new->fixed=height;
  }
 else
  { /* A parent window */
  new->main=new;
  new->fixed=0;
  }

 /* Get space for window */
 if(original)
  if(original->h-height<=2)
   {
   /* Not enough space for window */
   free(new);
   return 0;
   }
  else seth(original,original->h-height);

 /* Create new keyboard handler for window */
 if(watom->context) new->kbd=mkkbd(getcontext(watom->context));
 else new->kbd=0;

 /* Put window on the screen */
 if(where) enquef(W,link,where,new);
 else
  {
  if(t->topwin) enqueb(W,link,t->topwin,new);
  else izque(W,link,new), t->curwin=t->topwin=new;
  }
d627 2
a628 2
 return new;
 }
d632 47
a678 46
static int doabort(w,ret)
W *w;
int *ret;
 {
 int amnt=geth(w);
 W *z;
 w->y= -2;
 if(w->t->topwin==w) w->t->topwin=w->link.next;
 loop:
 z=w->t->topwin; do
  {
  if(z->orgwin==w) z->orgwin=0;
  if((z->win==w || z->main==w) && z->y!= -2)
   {
   amnt+=doabort(z,ret);
   goto loop;
   }
  }
  while(z=z->link.next, z!=w->t->topwin);
 if(w->orgwin) seth(w->orgwin,geth(w->orgwin)+geth(w));
 if(w->t->curwin==w)
  if(w->t->curwin->win) w->t->curwin=w->t->curwin->win;
  else
   if(w->orgwin) w->t->curwin=w->orgwin;
   else w->t->curwin=w->link.next;
 if(qempty(W,link,w))
  {
  leave=1;
  amnt=0;
  }
 deque(W,link,w);
 if(w->watom->abort && w->object)
  {
  *ret=w->watom->abort(w->object,MAXINT);
  if(w->notify) *w->notify= -1;
  }
 else
  {
  *ret= -1;
  if(w->notify) *w->notify= 1;
  }
 rmkbd(w->kbd);
 free(w);
 windie(w);
 return amnt;
 }
d682 20
a701 149
int wabort(w)
W *w;
 {
 SCREEN *t=w->t;
 int ret;
 if(w!=w->main)
  {
  doabort(w,&ret);
  if(!leave) wfit(t);
  }
 else
  {
  doabort(w,&ret);
  if(!leave)
   {
   if(lastw(t)->link.next!=t->topwin) wfit(t);
   else wspread(t);
   }
  }
 return ret;
 }

/* Generate text with formatting escape sequences */

void genfmt(t,x,y,ofst,s,flg)
SCRN *t;
char *s;
 {
 int *scrn=t->scrn+y*t->co+x;
 int atr=0;
 int col=0;
 int c;
 while(c= *s++)
  if(c=='\\')
   switch(c= *s++)
    {
    case 'u': case 'U':
    atr^=UNDERLINE;
    break;
    
    case 'i': case 'I':
    atr^=INVERSE;
    break;
    
    case 'b': case 'B':
    atr^=BOLD;
    break;
    
    case 'd': case 'D':
    atr^=DIM;
    break;
    
    case 'f': case 'F':
    atr^=BLINK;
    break;
    
    case 0: --s;
    break;

    default:
    if(col++>=ofst)
     {
     outatr(t,scrn,x,y,c,atr);
     ++scrn;
     ++x;
     }
    break;
    }
  else if(col++>=ofst)
   {
   if(c=='\t') c=' ';
   outatr(t,scrn,x,y,c,atr);
   ++scrn;
   ++x;
   }
 if(flg) eraeol(t,x,y);
 }

/* Generate text: no formatting */

void gentxt(t,x,y,ofst,s,len,flg)
SCRN *t;
char *s;
 {
 int *scrn=t->scrn+y*t->co+x;
 int col;
 int c;
 int a;
 for(col=0;col!=len;++col)
  if(col>=ofst)
   {
   c= (unsigned)s[col];
   if(c=='\t') c=' ';
   xlat(a,c);
   outatr(t,scrn,x,y,c,a);
   ++scrn; ++x;
   }
 if(flg) eraeol(t,x,y);
 }

/* Determine column width of string with format codes */

int fmtlen(s)
char *s;
 {
 int col=0;
 while(*s)
  {
  if(*s=='\\')
   switch(*++s)
    {
    case 'u': case 'i': case 'd': case 'f': case 'b':
    case 'U': case 'I': case 'D': case 'F': case 'B':
    ++s; goto cont;

    case 0:
    --s;
    }
  ++col; ++s;
  cont:;
  }
 return col;
 }

/* Return offset within format string which corresponds to a particular
   column */

int fmtpos(s,goal)
char *s;
 {
 char *org=s;
 int col=0;
 while(*s && col!=goal)
  {
  if(*s=='\\')
   switch(*++s)
    {
    case 'u': case 'i': case 'd': case 'f': case 'b':
    case 'U': case 'I': case 'D': case 'F': case 'B':
    ++s; goto cont;

    case 0:
    --s;
    }
  ++col; ++s;
  cont:;
  }
 return s-org+goal-col;
 }
d705 27
a731 28
static void mdisp(t,y,s)
SCRN *t;
char *s;
 {
 int ofst;
 int len;
 len=fmtlen(s);
 if(len<=(t->co-1)) ofst=0;
 else ofst=len-(t->co-1);
 genfmt(t,0,y,ofst,s,1);
 t->updtab[y]=1;
 }

void msgout(w)
W *w;
 {
 SCRN *t=w->t->t;
 if(w->msgb)
  {
  mdisp(t,w->y+w->h-1,w->msgb);
  w->msgb=0;
  }
 if(w->msgt)
  {
  mdisp(t,w->y+( (w->h>1 && (w->y || !staen)) ? 1 : 0 ),w->msgt);
  w->msgt=0;
  }
 }
d735 1
a735 1
char msgbuf[80];
d737 26
a762 27
void msgnw(w,s)
BASE *w;
char *s;
 {
 w->parent->msgb=s;
 }

void msgnwt(w,s)
BASE *w;
char *s;
 {
 w->parent->msgt=s;
 }

int urtn(b,k)
BASE *b;
 {
 if(b->parent->watom->rtn) return b->parent->watom->rtn(b,k);
 else return -1;
 }

int utype(b,k)
BASE *b;
 {
 if(b->parent->watom->type) return b->parent->watom->type(b,k);
 else return -1;
 }
d766 34
a799 39
int uprevw(bw)
BASE *bw;
 {
 return wprev(bw->parent->t);
 }

int unextw(bw)
BASE *bw;
 {
 return wnext(bw->parent->t);
 }

int ugroww(bw)
BASE *bw;
 {
 return wgrow(bw->parent);
 }

int ushrnk(bw)
BASE *bw;
 {
 return wshrink(bw->parent);
 }

int uexpld(bw)
BASE *bw;
 {
 if(bw->parent->t->h-bw->parent->t->wind==getgrouph(bw->parent))
  wshowall(bw->parent->t);
 else wshowone(bw->parent);
 return 0;
 }

int uretyp(bw)
BASE *bw;
 {
 nredraw(bw->parent->t->t);
 return 0;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
