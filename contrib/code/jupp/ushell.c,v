head	1.15;
access;
symbols
	joe-3_1jupp38:1.15
	joe-3_1jupp37:1.15
	joe-3_1jupp36:1.15
	joe-3_1jupp35:1.15
	joe-3_1jupp34:1.15
	joe-3_1jupp33:1.15
	joe-3_1jupp32:1.15
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.4
	joe-3_1jupp30:1.4
	joe-3_1jupp29:1.4
	joe-3_1jupp28:1.4
	joe-3_1jupp27:1.4
	joe-3_1jupp26:1.4
	joe-3_1jupp25:1.4
	joe-3_1jupp24:1.4
	joe-3_1jupp23:1.4
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.3
	joe-3_1jupp17:1.3
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.3
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.15
date	2017.12.08.03.24.16;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A2A05EB07C8D953;

1.14
date	2017.12.08.02.17.24;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A29F64A06DEB239;

1.13
date	2017.12.08.01.16.37;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A29E8063D55F339;

1.12
date	2017.12.07.02.10.19;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005A28A3145E1FF911;

1.11
date	2017.12.06.23.58.39;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005A2884424C3F3AD8;

1.10
date	2017.12.06.21.41.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A28640547F64250;

1.9
date	2017.12.06.21.17.03;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A285E5918D423C7;

1.8
date	2017.12.02.02.07.36;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A220AD65C90E687;

1.7
date	2017.12.01.22.31.05;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A21D83E25479F2D;

1.6
date	2017.11.18.17.05.51;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A10687E421523D2;

1.5
date	2017.11.18.17.04.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A1068266540CCE4;

1.4
date	2012.12.30.18.18.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	10050E085670C2F3A0B;

1.3
date	2008.05.13.13.08.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@/*
 *	Shell-window functions
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/ushell.c,v 1.14 2017/12/08 02:17:24 tg Exp $");

#include <sys/stat.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#include "b.h"
#include "main.h"
#include "pw.h"
#include "qw.h"
#include "tty.h"
#include "uedit.h"
#include "uerror.h"
#include "ufile.h"
#include "va.h"
#include "vs.h"
#include "ushell.h"
#include "utf8.h"
#include "w.h"

extern int orphan;

#if WANT_FORK
/* Executed when shell process terminates */

static void cdone(B *b)
{
	b->pid = 0;
	close(b->out);
	b->out = -1;
}

static void cdone_parse(B *b)
{
	b->pid = 0;
	close(b->out);
	b->out = -1;
	parserrb(b);
}

/* Executed for each chunk of data we get from the shell */

static void cfollow(B *b,long byte)
{
	W *w;
	if ((w = maint->topwin) != NULL) {
		do {
			if ((w->watom->what & TYPETW) &&
			    w->object.bw->b == b &&
			    w->object.bw->cursor->byte == byte) {
				BW *bw = w->object.bw;
				p_goto_eof(bw->cursor);
				bw->cursor->xcol = piscol(bw->cursor);
			}
			w = w->link.next;
		} while (w != maint->topwin);
	}
}

static void cdata(B *b, unsigned char *dat, int siz)
{
	P *q = pdup(b->eof);
	P *r = pdup(b->eof);
	long byte = q->byte;
	unsigned char bf[1024];
	int x, y;

	for (x = y = 0; x != siz; ++x) {
		if (dat[x] == 13 || dat[x] == 0) {
			;
		} else if (dat[x] == 8 || dat[x] == 127) {
			if (y) {
				--y;
			} else {
				pset(q, r);
				prgetc(q);
				bdel(q, r);
				--byte;
			}
		} else if (dat[x] == 7) {
			ttputc(7);
		} else {
			bf[y++] = dat[x];
		}
	}
	if (y) {
		binsm(r, bf, y);
	}
	prm(r);
	prm(q);

	cfollow(b,byte);
}

static int doushell(BW *bw, unsigned char *cmd, int *notify, int build)
{
	MPX *m;
	unsigned char **s;
	unsigned char *u;
	const unsigned char *name;

	name = getushell();
	s = vamk(10);
	u = vsncpy(NULL, 0, sz(name));
	s = vaadd(s, u);
	if (cmd) {
		u = vsncpy(NULL, 0, sc("-c"));
		s = vaadd(s, u);
		s = vaadd(s, cmd);
	} else {
		u = vsncpy(NULL, 0, sc("-i"));
		s = vaadd(s, u);
	}

	if (notify) {
		*notify = 1;
	}
	if (bw->b->pid) {
		msgnw(bw->parent, UC "Program already running in this window");
		varm(s);
		vsrm(cmd);
		return -1;
	}
	p_goto_eof(bw->cursor);

	if (!(m = mpxmk(&bw->b->out, name, s, cdata, bw->b, build ? cdone_parse : cdone, bw->b))) {
		varm(s);
		vsrm(cmd);
		msgnw(bw->parent, UC "No ptys available");
		return -1;
	} else {
		bw->b->pid = m->pid;
	}
	varm(s);
	vsrm(cmd);
	return 0;
}

int ubknd(BW *bw)
{
	if (!getenv("SHELL")) {
		msgnw(bw->parent, UC "\"SHELL\" environment variable not defined or exported");
	}
	return doushell(bw, NULL, NULL, 0);
}

/* Run a program in a window */

static int dorun(BW *bw, unsigned char *s, void *object, int *notify)
{
	return doushell(bw, s, notify, 0);
}

B *runhist = NULL;

int urun(BW *bw)
{
	if (wmkpw(bw->parent, UC "Program to run: ", &runhist, dorun, UC "Run", NULL, NULL, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

static int dobuild(BW *bw, unsigned char *s, void *object, int *notify)
{
	return doushell(bw, s, notify, 1);
}

B *buildhist = NULL;

int ubuild(BW *bw)
{
	if (buildhist) {
		if ((bw=wmkpw(bw->parent, UC "Build command: ", &buildhist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map))) {
			uuparw(bw);
			u_goto_eol(bw);
			bw->cursor->xcol = piscol(bw->cursor);
			return 0;
		}
	} else if (wmkpw(bw->parent, UC "Enter build command (for example, 'make'): ", &buildhist, dobuild, UC "Run", NULL, NULL, NULL, NULL, locale_map))
			return 0;
		return -1;
}
#endif

/* Kill program */

static int pidabort(BW *bw, int c, void *object, int *notify)
{
	if (notify) {
		*notify = 1;
	}
	if ((c | 0x20) != 'y') {
		return -1;
	}
	if (bw->b->pid) {
		kill(bw->b->pid, 1);
		return -1;
	} else {
		return -1;
	}
}

int ukillpid(BW *bw)
{
	if (bw->b->pid) {
		if (mkqw(bw->parent, sc("Kill program (y,n,^C)?"), pidabort, NULL, NULL, NULL)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		return 0;
	}
}

static const char * const getushell_envs[] = {
	"SHELL",
	"EXECSHELL",
};
const void *getushell(void)
{
	static char *rshell;

	if (!rshell) {
		char *eshell;
		struct stat sbuf;
		int i = 0;

		while (i < 2) {
			eshell = getenv(getushell_envs[i++]);
			if (eshell && *eshell &&
			    !stat(eshell, &sbuf) &&
			    S_ISREG(sbuf.st_mode) &&
			    (sbuf.st_mode & 0111) &&
			    /* LINTED use of access */
			    !access(eshell, X_OK)) {
				rshell = eshell;
				break;
			}
		}
	}
	return (rshell ? rshell : "/bin/sh");
}
@


1.14
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ushell.c,v 1.11 2017/12/06 23:58:39 tg Exp $");
d205 1
a205 1
	if (c != 'y' && c != 'Y') {
@


1.13
log
@fix a couple of prompt window result string memory leaks
@
text
@d58 2
a59 2
	 	do {
	 		if ((w->watom->what & TYPETW) &&
d62 2
a63 2
	 			BW *bw = w->object.bw;
	 			p_goto_eof(bw->cursor);
d65 4
a68 4
	 		}
		w = w->link.next;
	 	} while (w != maint->topwin);
	 }
d153 2
a154 2
        	msgnw(bw->parent, UC "\"SHELL\" environment variable not defined or exported");
        }
@


1.12
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d132 1
d139 1
d145 2
@


1.11
log
@make wmkpw const again
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ushell.c,v 1.10 2017/12/06 21:41:04 tg Exp $");
d57 1
a57 1
	 if ((w = maint->topwin) != NULL) {
d59 4
a62 2
	 		if ((w->watom->what&TYPETW) && ((BW *)w->object)->b==b && ((BW *)w->object)->cursor->byte==byte) {
	 			BW *bw = (BW *)w->object;
@


1.10
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/ushell.c,v 1.8 2017/12/02 02:07:36 tg Exp $");
d163 1
a163 1
	if (wmkpw(bw->parent, US "Program to run: ", &runhist, dorun, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
d180 1
a180 1
		if ((bw=wmkpw(bw->parent, US "Build command: ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map))) {
d186 1
a186 1
	} else if (wmkpw(bw->parent, US "Enter build command (for example, 'make'): ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map))
@


1.9
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d128 1
a128 1
		msgnw(bw->parent, US "Program already running in this window");
d136 1
a136 1
		msgnw(bw->parent, US "No ptys available");
d147 1
a147 1
        	msgnw(bw->parent, US "\"SHELL\" environment variable not defined or exported");
@


1.8
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a12 2
#include <unistd.h>
#ifdef HAVE_SYS_STAT_H
a13 2
#endif
#ifdef HAVE_SIGNAL_H
a14 2
#endif
#ifdef HAVE_STDLIB_H
d16 1
a16 1
#endif
@


1.7
log
@merge fixes developed on Debian
@
text
@a0 1
/* $MirOS: contrib/code/jupp/ushell.c,v 1.5 2017/11/18 17:04:19 tg Exp $ */
d11 2
a13 3
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.6
log
@disable anything using fork on NOMMU systems
@
text
@d42 1
a111 1
#if WANT_FORK
@


1.5
log
@nuke dead MSDOS code that doesn’t even compile any more
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ushell.c,v 1.3 2008/05/13 13:08:29 tg Exp $ */
d111 1
d198 1
@


1.4
log
@use SHELL and EXECSHELL in favour of /bin/sh (with stat and access checks)
@
text
@a112 8
#ifdef __MSDOS__
	if (notify) {
		*notify = 1;
	}
	varm(s);
	msgnw(bw->parent, "Sorry, no sub-processes in DOS (yet)");
	return -1;
#else
a148 1
#endif
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d16 3
d36 1
d111 1
a111 1
static int cstart(BW *bw, unsigned char *name, unsigned char **s, void *obj, int *notify, int build)
d122 16
d162 1
a162 4
	unsigned char **a;
	unsigned char *s;
        unsigned char *sh=(unsigned char *)getenv("SHELL");
        if (!sh) {
a163 2
        	/* return -1; */
        	sh = US "/bin/sh";
d165 1
a165 7

	a = vamk(3);
	s = vsncpy(NULL, 0, sz(sh));
	a = vaadd(a, s);
	s = vsncpy(NULL, 0, sc("-i"));
	a = vaadd(a, s);
	return cstart(bw, sh, a, NULL, NULL, 0);
d172 1
a172 8
	unsigned char **a = vamk(10);
	unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));

	a = vaadd(a, cmd);
	cmd = vsncpy(NULL, 0, sc("-c"));
	a = vaadd(a, cmd);
	a = vaadd(a, s);
	return cstart(bw, US "/bin/sh", a, NULL, notify, 0);
d188 1
a188 8
	unsigned char **a = vamk(10);
	unsigned char *cmd = vsncpy(NULL, 0, sc("/bin/sh"));

	a = vaadd(a, cmd);
	cmd = vsncpy(NULL, 0, sc("-c"));
	a = vaadd(a, cmd);
	a = vaadd(a, s);
	return cstart(bw, US "/bin/sh", a, NULL, notify, 1);
d237 29
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d27 2
d200 1
a200 1
		if (bw=wmkpw(bw->parent, US "Build command: ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
a204 2
		} else {
		return -1;
d206 1
a206 2
	} else {
		if (wmkpw(bw->parent, US "Enter build command (for example, 'make'): ", &buildhist, dobuild, US "Run", NULL, NULL, NULL, NULL, locale_map)) {
a207 1
		} else {
a208 2
		}
	}
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Shell-window functions
   Copyright (C) 1992 Joseph H. Allen
d11 10
a20 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
a21 1
#include "config.h"
d23 1
a23 2
#include "bw.h"
#include "w.h"
d26 3
d30 2
a31 4
#include "va.h"
#include "ufile.h"
#include "main.h"
#include "ushell.h"
d37 14
a50 18
static void cdone(bw)
BW *bw;
 {
 bw->pid=0;
 close(bw->out); bw->out= -1;
 if(piseof(bw->cursor))
  {
  binss(bw->cursor,"** Program finished **\n");
  peof(bw->cursor);
  bw->cursor->xcol=piscol(bw->cursor);
  }
 else
  {
  P *q=pdup(bw->b->eof);
  binss(q,"** Program finished **\n");
  prm(q);
  }
 }
d54 52
a105 39
static void cdata(bw,dat,siz)
BW *bw;
char *dat;
 {
 P *q=pdup(bw->cursor);
 P *r=pdup(bw->b->eof);
 char bf[1024];
 int x, y;
 for(x=y=0;x!=siz;++x)
  if(dat[x]==13 || dat[x]==0);
  else if(dat[x]==8 || dat[x]==127)
   if(y) --y;
   else
    if(piseof(bw->cursor))
     {
     pset(q,bw->cursor), prgetc(q), bdel(q,bw->cursor);
     bw->cursor->xcol=piscol(bw->cursor);
     }
    else pset(q,r), prgetc(q), bdel(q,r);
  else bf[y++]=dat[x];
 if(y)
  if(piseof(bw->cursor))
   {
   binsm(bw->cursor,bf,y);
   peof(bw->cursor);
   bw->cursor->xcol=piscol(bw->cursor);
   }
  else binsm(r,bf,y);
 prm(r);
 prm(q);
 }

static int cstart(bw,name,s,obj,notify)
BW *bw;
char *name;
char **s;
void *obj;
int *notify;
 {
d107 6
a112 4
 if(notify) *notify=1;
 varm(s);
 msgnw(bw,"Sorry, no sub-processes in DOS (yet)");
 return -1;
d114 20
a133 22
 MPX *m;
 if(notify) *notify=1;
 if(bw->pid && orphan)
  {
  msgnw(bw,"Program already running in this window");
  varm(s);
  return -1;
  }
 if(doedit(bw,vsncpy(NULL,0,sc("")),NULL,NULL))
  {
  varm(s);
  return -1;
  }
 bw=(BW *)maint->curwin->object;
 if(!(m=mpxmk(&bw->out,name,s,cdata,bw,cdone,bw)))
  {
  varm(s);
  msgnw(bw,"No ptys available");
  return -1;
  }
 else bw->pid= m->pid;
 return 0;
d135 1
a135 1
 }
d137 18
a154 10
int ubknd(bw)
BW *bw;
 {
 char **a;
 char *s;
 a=vamk(3);
 s=vsncpy(NULL,0,sz(getenv("SHELL"))); a=vaadd(a,s);
 s=vsncpy(NULL,0,sc("-i")); a=vaadd(a,s);
 return cstart(bw,getenv("SHELL"),a,NULL,NULL);
 }
d158 56
a213 24
static int dorun(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 char **a=vamk(10);
 char *cmd=vsncpy(NULL,0,sc("/bin/sh"));
 a=vaadd(a,cmd);
 cmd=vsncpy(NULL,0,sc("-c"));
 a=vaadd(a,cmd);
 a=vaadd(a,s);
 return cstart(bw,"/bin/sh",a,NULL,notify);
 }

B *runhist=0;

int urun(bw)
BW *bw;
 {
 if(wmkpw(bw,"Program to run: ",&runhist,dorun,"Run",NULL,NULL,NULL,NULL))
  return 0;
 else return -1;
 }
d217 28
a244 21
int pidabort(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(notify) *notify=1;
 if(c!='y' && c!='Y') return -1;
 if(bw->pid) { kill(bw->pid,1); return -1; }
 else return -1;
 }

int ukillpid(bw)
BW *bw;
 {
 if(bw->pid)
  {
  if(mkqw(bw,sc("Kill program (y,n,^C)?"),pidabort,NULL,NULL,NULL)) return 0;
  else return -1;
  }
 else return 0;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
