head	1.9;
access;
symbols
	joe-3_1jupp38:1.9
	joe-3_1jupp37:1.9
	joe-3_1jupp36:1.9
	joe-3_1jupp35:1.9
	joe-3_1jupp34:1.9
	joe-3_1jupp33:1.9
	joe-3_1jupp32:1.9
	joe-3_1jupp31:1.7
	joe-3_1jupp30:1.7
	joe-3_1jupp29:1.7
	joe-3_1jupp28:1.6
	joe-3_1jupp27:1.6
	joe-3_1jupp26:1.5
	joe-3_1jupp25:1.5
	joe-3_1jupp24:1.5
	joe-3_1jupp23:1.5
	joe-3_1jupp22:1.5
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.3
	joe-3_1jupp18:1.2
	joe-3_1jupp17:1.2
	joe-3_1jupp16:1.2
	joe-3_1jupp15:1.2
	joe-3_1jupp14:1.2
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@# @;


1.9
date	2017.12.02.22.24.07;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A23281B7851D74F;

1.8
date	2017.12.02.05.38.05;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A223C482CF20D1C;

1.7
date	2016.10.07.19.43.56;	author tg;	state Exp;
branches;
next	1.6;
commitid	10057F7FB0D4D3E4027;

1.6
date	2013.12.24.22.50.07;	author tg;	state Exp;
branches;
next	1.5;
commitid	10052BA0FA32C763758;

1.5
date	2012.09.02.14.46.51;	author tg;	state Exp;
branches;
next	1.4;
commitid	100504371717CC33E24;

1.4
date	2012.08.04.16.00.13;	author tg;	state Exp;
branches;
next	1.3;
commitid	100501D470426334C26;

1.3
date	2012.06.07.22.34.53;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004FD12CA36C733748;

1.2
date	2008.05.13.16.17.44;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004829BF321E5AE4B0;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@more præprocessor improvements
@
text
@# $MirOS: contrib/code/jupp/syntax/c.jsf.in,v 1.5 2012/09/02 14:46:51 tg Exp $
#-
# JOE syntax highlight file for C and C++

# A (deterministic) state machine which performs lexical analysis of C.
# (This is the "assembly language" of syntax highlighting.  A separate
# program could be used to convert a regular expression NFA syntax into this
# format).

# Each state begins with ':<name> <color-name>'
# <color-name> is the color used for characters eaten by the state
# (really a symbol for a user definable color).

# The first state defined is the initial state.

# Within a state, define transitions (jumps) to other states.  Each
# jump has the form: <character-list> <target-state> [<option>s]

# There are two ways to specify <character-list>s, either * for any
# character not otherwise specified, or a literal list of characters within
# quotes (ranges and escape sequences allows).  When the next character
# matches any in the list, a jump to the target-state is taken and the
# character is eaten (we advance to the next character of the file to be
# colored).
#
# The * transition should be the first transition specified in the state.
#
# There are several options:
#   noeat     	do not eat the character, instead feed it to the next state
#             	(this tends to make the states smaller, but be careful: you
#		can make infinite loops).  'noeat' implies 'recolor=-1'.
#
#   recolor=-N	Recolor the past N characters with the color of the
#		target-state.  For example once /* is recognized as the
#		start of C comment, you want to color the /* with the C
#		comment color.
#
#   buffer    	start copying characters to a buffer, beginning with this
#		one (it's ok to not terminate buffering with a matching
#		'strings' option- the buffer is limited to leading 19
#		characters).
#
#   strings	A list of strings follows.  If the buffer matches any of the
#		given strings, a jump to the target-state in the string list
#		is taken instead of the normal jump.
#
#   istrings	Same as strings, but case is ignored.
#
#   hold        Stop buffering string- a future 'strings' or 'istrings' will
#               look at contents of buffer at this point.  Useful for distinguishing
#               commands and function calls in some languages 'write 7' is a command
#               'write (' is a function call- hold lets us stop at the space and delay
#               the string lookup until the ( or 7.
#
#   The format of the string list is:
#
#      "string"   <target-state> [<options>s]
#      "string"   <target-state> [<options>s]
#      done
#
#   (all of the options above are allowed except "strings", "istrings" and "noeat".  noeat is
#    always implied after a matched string).
#
# Weirdness: only states have colors, not transitions.  This means that you
# sometimes have to make dummy states with '* next-state noeat' just to get
# a color specification.
#
# Encoding: everything is handled as UTF-8 by octets, that is, you can have
# individual octets change states (the colour of the last octet applies).
# The JSF files themselves must accordingly be encoded in UTF-8. When a raw
# octet or an invalid UTF-8 sequence is read, a number of \xFF octets are
# matched on.


# Define no. sync lines
# You can say:
# -200     means 200 lines
# -        means always start parsing from beginning of file when we lose sync
#          if nothing is specified, the default is -120

# Always reparse from beginning
-


# Define colors
#
# bold inverse blink dim underline
# white cyan magenta blue yellow green red black
# bg_white bg_cyan bg_magenta bg_blue bg_yellow bg_green bg_red bg_black

=Idle
=Bad		bold red
=Preproc 	yellow
=PpCond		red
=Define		bold blue
=Comment 	green
=IncLocal	cyan
=IncSystem	bold cyan
=Constant 	cyan
=Escape 	bold cyan
=Type 		bold
=Keyword 	bold
=CppKeyword	bold
=Brace		magenta
=Control

:reset Idle
	*		first		noeat
	" \t"		reset

:first Idle
	*		idle		noeat
	"#"		pre		recolor=-1

:pre Preproc
	*		preproc		noeat
	" \t"		pre
	"a-z"		preident	recolor=-1 buffer

:preident Preproc
	*		preproc		noeat strings
	"define"	predef
	"elif"		preif
	"if"		preif
	"ifdef"		predef
	"ifndef"	predef
	"include"	preinc
	"undef"		predef
done
	"a-z"		preident

:preinc Preproc
	*		preinc
	" \t"		preinc_ws
	"\n"		reset

:preinc_ws Preproc
	*		prebad		recolor=-1
	" \t"		preinc_ws
	"\""		preinc_local	recolor=-1
	"<"		preinc_system	recolor=-1

:preinc_local IncLocal
	*		preinc_local
	"\"\n"		reset

:preinc_system IncSystem
	*		preinc_system
	">\n"		reset

:prebad	Bad
	*		prebad
	"\n"		reset

:predef Preproc
	*		predef
	" \t"		predef_ws
	"\n"		reset

:predef_ws Preproc
	*		prebad		recolor=-1
	" \t"		predef_ws
	"a-zA-Z0-9_"	predef_ident	recolor=-1

:predef_ident Define
	*		idle		noeat
	"a-zA-Z0-9_"	predef_ident

:preif Preproc
	*		preif
	" \t"		preif_ws
	"\n"		reset

:preif_ws Preproc
	*		preif_cond	recolor=-1
	" \t"		preif_ws

:preif_cond PpCond
	*		preif_cond
	"\\"		preif_cont
	"/"		preif_slash
	"\n"		reset

:preif_slash Preproc
	*		preif_cond	noeat
	"*"		comment		recolor=-2
	"/"		line_comment	recolor=-2

:preif_cont PpCond
	*		preif_cond

:preproc Preproc
	*		preproc
	"\n"		reset
	"\\"		preproc_cont
	"/"		preproc_slash

:preproc_slash Preproc
	*		preproc		noeat
	"*"		comment		recolor=-2
	"/"		line_comment	recolor=-2

:preproc_cont Preproc
	*		preproc_cont
	"\n"		preproc

# All following states are for when we're not in a preprocessor line

:idle Idle
	*		idle
	"\n"		reset
	"/"		slash
	"0"		first_digit	recolor=-1
	"1-9"		decimal	recolor=-1
	"."		maybe_float
	"\""		string		recolor=-1
	"'"		char		recolor=-1
	"a-zA-Z_"	ident		buffer
	"{}"		brace		recolor=-1
	",:;=()><[]*&|!~+\-%^"	control		recolor=-1

:brace Brace
	*	idle	noeat

:control Control
	*	idle	noeat

:slash Idle
	*		idle		noeat recolor=-2	# Not sure about this
	"*"		comment		recolor=-2
	"/"		line_comment	recolor=-2

:comment Comment
	*		comment
	"*"		maybe_end_comment

:maybe_end_comment Comment
	*		comment
	"/"		idle
	"*"		maybe_end_comment

:line_comment Comment
	*		line_comment
	"\n"		reset

:first_digit Constant
	*		idle	noeat
	"xX"		hex
	"."		float
	"eE"		epart
	"0-7"		octal
	"89"		bad_number	recolor=-1

:bad_number Bad
	*		idle	noeat
	"0-9"		bad_number

:octal Constant
	*		idle	noeat
	"0-7"		octal
	"89"		bad_number	recolor=-1

:hex Constant
	*		idle	noeat
	"0-9A-Fa-f"	hex

:decimal Constant
	*		idle	noeat
	"0-9"		decimal
	"eE"		epart
	"."		float

:maybe_float Constant
	*		idle	recolor=-2	noeat
	"0-9"		float		recolor=-2

:float Constant
	*		idle	noeat
	"eE"		epart
	"0-9"		float

:epart Constant
	*		idle	noeat
	"0-9+\-"	enum

:enum Constant
	*		idle	noeat
	"0-9"		enum

:string	Constant
	*		string
	"\""		idle
	"\\"		string_escape	recolor=-1
	"%"		string_control	recolor=-1

:string_escape Escape
	*		string
	"x"		string_hex1
	"0-7"		string_octal2
	"\n"		string		recolor=-2

:string_hex1 Escape
	*		string		noeat
	"0-9a-fA-F"	string_hex2

:string_hex2 Escape
	*		string		noeat
	"0-9a-fA-F"	string

:string_octal2 Escape
	*		string		noeat
	"0-7"		string_octal3

:string_octal3 Escape
	*		string		noeat
	"0-7"		string

:string_control Escape
	*		string_control
	"\""		reset
	"diouxXeEfFgGaAcspn%SC\n"	string
	"\\"		string_escape	recolor=-1

:char Constant
	*		char
	"\n"		reset
	"'"		idle
	"\\"		char_escape	recolor=-1

:char_escape	Escape
	*		char
	"x"		char_hex1
	"0-7"		char_octal2
	"\n"		char		recolor=-2

:char_hex1 Escape
	*		char		noeat
	"0-9a-fA-F"	char_hex2

:char_hex2 Escape
	*		char		noeat
	"0-9a-fA-F"	char

:char_octal2 Escape
	*		char		noeat
	"0-7"		char_octal3

:char_octal3 Escape
	*		char		noeat
	"0-7"		char

:ident Idle
	*		idle		noeat strings
	"int"		type
	"float"		type
	"long"		type
	"short"		type
	"char"		type
	"double"	type
	"signed"	type
	"unsigned"	type
	"void"		type
	"static"	type
	"register"	type
	"extern"	type
	"inline"	type
	"auto"		type
	"const"		type
	"volatile"	type
	"if"		kw
	"else"		kw
	"while"		kw
	"for"		kw
	"break"		kw
	"continue"	kw
	"do"		kw
	"case"		kw
	"default"	kw
	"switch"	kw
	"goto"		kw
	"struct"	kw
	"enum"		kw
	"return"	kw
	"sizeof"	kw
	"typedef"	kw
	"union"		kw
	"asm"		kw
# C++ keywords
	"class"		cppkw
	"public"	cppkw
	"private"	cppkw
	"protected"	cppkw
	"friend"	cppkw
	"new"		cppkw
	"delete"	cppkw
	"bool"		cppkw
	"namespace"	cppkw
	"operator"	cppkw
	"template"	cppkw
	"catch"		cppkw
	"throw"		cppkw
	"try"		cppkw
	"typeof"	cppkw
done
	"a-zA-Z0-9_"	ident

:type Type
	*	idle	noeat

:kw Keyword
	*	idle	noeat

:cppkw CppKeyword
	*	idle	noeat
@


1.8
log
@try making highlighting a bit more legible: use dark yellow ipv dark blue
@
text
@d94 1
d123 4
d128 1
a154 1

d169 22
@


1.7
log
@UTF-8 syntax highlighting
@
text
@d93 1
a93 1
=Preproc 	blue
@


1.6
log
@terminate string constants at a backslash properly (cf. gettext "\"%1\"")
@
text
@d67 6
d130 1
a130 1
	
d140 1
a140 1
	
d145 1
a145 1
:prebad	Bad	
d154 1
a154 1
	
d170 1
a170 1
	
d175 1
a175 1
	
@


1.5
log
@improve syntax highlighting further and release
@
text
@d1 1
a1 1
# $MirOS: contrib/code/jupp/syntax/c.jsf.in,v 1.4 2012/08/04 16:00:13 tg Exp $
d289 1
@


1.4
log
@a newline does not terminate a string, not even a %1$s-like sequence,
it sure terminates the sequence though; double quotes terminate the string
@
text
@d1 1
a1 1
# $MirOS: contrib/code/jupp/syntax/c.jsf.in,v 1.3 2012/06/07 22:34:53 tg Exp $
d68 1
d75 4
@


1.3
log
@use 120 sync lines by default; should fix natureshadow’s problem
@
text
@d1 1
a1 1
# $MirOS: contrib/code/jupp/syntax/c.jsf.in,v 1.2 2008/05/13 16:17:44 tg Exp $
d282 2
a283 2
	"\n"		reset
	"diouxXeEfFgGaAcspn%SC"	string
@


1.2
log
@RCS IDs to the remaining few (non-autogen'd) files
@
text
@d1 1
a1 1
# $MirOS$
d72 1
a72 1
#          if nothing is specified, the default is -50
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
