head	1.39;
access;
symbols
	joe-3_1jupp38:1.39
	joe-3_1jupp37:1.39
	joe-3_1jupp36:1.37
	joe-3_1jupp35:1.37
	joe-3_1jupp34:1.37
	joe-3_1jupp33:1.37
	joe-3_1jupp32:1.33
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.22
	joe-3_1jupp30:1.21
	joe-3_1jupp29:1.21
	joe-3_1jupp28:1.20
	joe-3_1jupp27:1.20
	joe-3_1jupp26:1.19
	joe-3_1jupp25:1.18
	joe-3_1jupp24:1.18
	joe-3_1jupp23:1.18
	joe-3_1jupp22:1.16
	joe-3_1jupp21:1.16
	joe-3_1jupp20:1.15
	joe-3_1jupp19:1.15
	joe-3_1jupp18:1.15
	joe-3_1jupp17:1.15
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.15
	joe-3_1jupp15:1.15
	joe-3_1jupp14:1.15
	joe-3_1jupp12:1.14
	joe-3_1jupp11:1.8
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.8
	joe-3_1jupp9:1.8
	joe-3_1jupp8:1.8
	joe-3_1jupp7:1.5
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.39
date	2018.10.20.16.32.24;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005BCB58AD3A7E4E8A;

1.38
date	2018.06.27.22.39.02;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005B3411E2160E1C42;

1.37
date	2018.01.08.02.01.19;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005A52D0FA22192115;

1.36
date	2018.01.07.20.32.46;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005A5284063C3E386D;

1.35
date	2018.01.07.17.30.52;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A52595F20AAF8D7;

1.34
date	2017.12.20.22.50.32;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A3AE9331EF5C01F;

1.33
date	2017.12.08.02.28.04;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A29F8C708B176AB;

1.32
date	2017.12.08.02.17.21;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A29F64A06DEB239;

1.31
date	2017.12.08.02.00.38;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A29F2506E789D2B;

1.30
date	2017.12.07.02.10.15;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A28A3145E1FF911;

1.29
date	2017.12.06.23.17.33;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A287AA407E73F9C;

1.28
date	2017.12.06.23.02.01;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A2876FC4FFE7EF5;

1.27
date	2017.12.06.21.16.54;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A285E5918D423C7;

1.26
date	2017.12.04.22.15.38;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A25C91E16B3B365;

1.25
date	2017.12.02.04.32.38;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A222CF2122034D9;

1.24
date	2017.12.02.02.07.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A220AD65C90E687;

1.23
date	2017.12.02.00.16.43;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A21F0FB306AFC87;

1.22
date	2017.07.09.01.15.51;	author tg;	state Exp;
branches;
next	1.21;
commitid	100596183D53C63D865;

1.21
date	2016.10.08.19.28.53;	author tg;	state Exp;
branches;
next	1.20;
commitid	10057F9490F0ED5540C;

1.20
date	2014.03.04.23.04.11;	author tg;	state Exp;
branches;
next	1.19;
commitid	10053165C030FE8B28B;

1.19
date	2013.11.07.21.50.35;	author tg;	state Exp;
branches;
next	1.18;
commitid	100527C0B43044C6E4A;

1.18
date	2012.12.30.21.45.12;	author tg;	state Exp;
branches;
next	1.17;
commitid	10050E0B5FE41C91584;

1.17
date	2012.12.22.00.06.11;	author tg;	state Exp;
branches;
next	1.16;
commitid	10050D4F965570AEE79;

1.16
date	2012.07.18.16.46.03;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005006E855220C99D2;

1.15
date	2010.04.08.15.31.01;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004BBDF6C54CC9A0DB;

1.14
date	2009.10.18.16.08.56;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004ADB3DAD31E1C7BB;

1.13
date	2009.10.18.16.07.39;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004ADB3D5F5F696CD7;

1.12
date	2009.10.18.16.06.28;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004ADB3D195604AD30;

1.11
date	2009.10.18.16.01.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004ADB3BED3C5AAD23;

1.10
date	2009.10.18.14.52.55;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004ADB2BD317498872;

1.9
date	2009.10.06.09.07.29;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004ACB08E905F8F83E;

1.8
date	2007.02.18.22.34.08;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045D8D46C7CE52506;

1.7
date	2007.02.18.21.53.39;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D8CADE3C5AC949;

1.6
date	2007.02.18.21.35.02;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045D8C6900510B4E7;

1.5
date	2006.11.10.23.46.44;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045550F687FCE82CC;

1.4
date	2006.11.10.23.23.30;	author tg;	state Exp;
branches;
next	1.3;
commitid	100455509573940FA03;

1.3
date	2006.11.10.21.11.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004554EB0546B4C7B6;

1.2
date	2005.02.05.02.42.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.21;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.39
log
@overzealous “might be uninitialised”
@
text
@/*
 *	Edit buffer window generation
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.38 2018/06/27 22:39:02 tg Exp $");

#include <string.h>
#include <stdlib.h>

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "b.h"
#include "bw.h"
#include "blocks.h"
#include "kbd.h"
#include "rc.h"
#include "scrn.h"
#include "ublock.h"
#include "utils.h"
#include "syntax.h"
#include "charmap.h"
#include "w.h"

/* Display modes */
int dspasis = 0;
int marking = 0;
extern int staen;
extern SCREEN *maint;

static P *getto(P *p, P *cur, P *top, long int line)
{

	if (p == NULL) {
		P *best = cur;
		long dist = LONG_MAX;
		long d;

		d = (line >= cur->line ? line - cur->line : cur->line - line);
		if (d < dist) {
			dist = d;
			best = cur;
		}
		d = (line >= top->line ? line - top->line : top->line - line);
		if (d < dist) {
			/* dead store: dist = d; */
			best = top;
		}
		p = pdup(best);
		p_goto_bol(p);
	}
	while (line > p->line)
		if (!pnextl(p))
			break;
	if (line < p->line) {
		while (line < p->line)
			pprevl(p);
		p_goto_bol(p);
	}
	return p;
}

/* Scroll window to follow cursor */

int mid = 0;

/* For hex */

static void
bwfllwh(BW *w)
{
	long dofs = 0;

	/* Top must be a muliple of 16 bytes */
	if (w->top->byte%16) {
		pbkwd(w->top,w->top->byte%16);
	}

	/* Move backward */
	if (w->cursor->byte < w->top->byte) {
		long new_top = w->cursor->byte/16;
		if (mid) {
			if (new_top >= w->h / 2)
				new_top -= w->h / 2;
			else
				new_top = 0;
		}
		if (w->top->byte/16 - new_top < w->h)
			nscrldn(w->t->t, w->y, w->y + w->h, (int) (w->top->byte/16 - new_top));
		else
			msetI(w->t->t->updtab + w->y, 1, w->h);
		pgoto(w->top,new_top*16);
	}

	/* Move forward */
	if (w->cursor->byte >= w->top->byte+(w->h*16)) {
		long new_top;
		if (mid) {
			new_top = w->cursor->byte/16 - w->h / 2;
		} else {
			new_top = w->cursor->byte/16 - (w->h - 1);
		}
		if (new_top - w->top->byte/16 < w->h)
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (new_top - w->top->byte/16));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
		}
		pgoto(w->top, new_top*16);
	}

	/* Adjust scroll offset */
	if (w->cursor->byte % 16 + 60 >= w->w)
		dofs = w->cursor->byte % 16 + 60 - (w->w - 1);
	if (w->offset != dofs) {
		w->offset = dofs;
		msetI(w->t->t->updtab + w->y, 1, w->h);
	}
}

/* For text */

static void bwfllwt(BW *w)
{
	P *newtop;

	if (w->cursor->line < w->top->line) {
		newtop = pdup(w->cursor);
		p_goto_bol(newtop);
		if (mid) {
			if (newtop->line >= w->h / 2)
				pline(newtop, newtop->line - w->h / 2);
			else
				pset(newtop, newtop->b->bof);
		}
		if (w->top->line - newtop->line < w->h)
			nscrldn(w->t->t, w->y, w->y + w->h, (int) (w->top->line - newtop->line));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
			msetI(w->t->t->syntab + w->y, -1, w->h);
		}
		pset(w->top, newtop);
		prm(newtop);
	} else if (w->cursor->line >= w->top->line + w->h) {
		pdup(w->top);
		newtop = getto(NULL, w->cursor, w->top, w->cursor->line -
		    (mid ? (w->h / 2) : (w->h - 1)));
		if (newtop->line - w->top->line < w->h)
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (newtop->line - w->top->line));
		else {
			msetI(w->t->t->updtab + w->y, 1, w->h);
			msetI(w->t->t->syntab + w->y, -1, w->h);
		}
		pset(w->top, newtop);
		prm(newtop);
	}

	/* Adjust column */
	if (w->cursor->xcol < w->offset) {
		w->offset = w->cursor->xcol;
		msetI(w->t->t->updtab + w->y, 1, w->h);
	} else if (w->cursor->xcol >= w->offset + w->w) {
		w->offset = w->cursor->xcol - (w->w - 1);
		msetI(w->t->t->updtab + w->y, 1, w->h);
	}
}

/* For either */

void bwfllw(jobject jO)
{
	BW *w = jO.bw;
	if (w->o.hex)
		bwfllwh(w);
	else
		bwfllwt(w);
}

/* Determine highlighting state of a particular line on the window.
   If the state is not known, it is computed and the state for all
   of the remaining lines of the window are also recalculated. */

static int
get_highlight_state(BW *w, int line)
{
	P *tmp = 0;
	int state;

	/* Screen y position of requested line */
	int y = line-w->top->line+w->y;

	if(!w->o.highlight || !w->o.syntax)
		return -1;

	/* If we know the state, just return it */
	if (w->parent->t->t->syntab[y]>=0)
		return w->parent->t->t->syntab[y];

	/* Scan upwards until we have a line with known state or
	   we're on the first line */
	while (y > w->y && w->parent->t->t->syntab[y] < 0) --y;

	/* If we don't have state for this line, calculate by going 100 lines back */
	if (w->parent->t->t->syntab[y]<0) {
		/* We must be on the top line */
		state = 0;
		tmp = pdup(w->top);
		if(w->o.syntax->sync_lines >= 0 && tmp->line > w->o.syntax->sync_lines)
			pline(tmp, tmp->line-w->o.syntax->sync_lines);
		else
			p_goto_bof(tmp);
		while(tmp->line!=y-w->y+w->top->line)
			state = parse(w->o.syntax,tmp,state);
		w->parent->t->t->syntab[y] = state;
		w->parent->t->t->updtab[y] = 1;
		prm(tmp);
	}

	/* Color to end of screen */
	tmp = pdup(w->top);
	pline(tmp, y-w->y+w->top->line);
	state = w->parent->t->t->syntab[y];
	while(tmp->line!=w->top->line+w->h-1 && !piseof(tmp)) {
		state = parse(w->o.syntax,tmp,state);
		w->parent->t->t->syntab[++y] = state;
		w->parent->t->t->updtab[y] = 1; /* This could be smarter: update only if we changed what was there before */
		}
	prm(tmp);
	while(y<w->y+w->h-1) {
		w->parent->t->t->syntab[++y] = state;
		}

	/* Line after window */
	/* state = parse_c(state,syn,tmp); */

	/* If we changed, fix other windows */
	/* w->state = state; */

	/* Return state of requested line */
	y = line - w->top->line + w->y;
	return w->parent->t->t->syntab[y];
}

/* Scroll a buffer window after an insert occurred.  'flg' is set to 1 if
 * the first line was split
 */

void bwins(BW *w, long int l, long int n, int flg)
{
	if (l + flg + n < w->top->line + w->h && l + flg >= w->top->line && l + flg <= w->b->eof->line) {
		if (flg)
			w->t->t->sary[w->y + l - w->top->line] = w->t->t->li;
		nscrldn(w->t->t, (int) (w->y + l + flg - w->top->line), w->y + w->h, (int) n);
	}
	if (l < w->top->line + w->h && l >= w->top->line) {
		if (n >= w->h - (l - w->top->line)) {
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
			msetI(w->t->t->syntab + w->y + l - w->top->line, -1, w->h - (int) (l - w->top->line));
		} else {
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, (int) n + 1);
			msetI(w->t->t->syntab + w->y + l - w->top->line, -1, (int) n + 1);
		}
	}
}

/* Scroll current windows after a delete */

void bwdel(BW *w, long int l, long int n, int flg)
{
/* Update the line where the delete began */
	if (l < w->top->line + w->h && l >= w->top->line)
		w->t->t->updtab[w->y + l - w->top->line] = 1;

/* Update highlight for line after first one which changed */
	if ((l+1) < w->top->line + w->h && (l+1) >= w->top->line) {
		w->t->t->syntab[w->y + (l+1) - w->top->line] = -1;
		w->t->t->updtab[w->y + (l+1) - w->top->line] = 1;
		}

/* Update the line where the delete ended */
	if (l + n < w->top->line + w->h && l + n >= w->top->line)
		w->t->t->updtab[w->y + l + n - w->top->line] = 1;

	if (l < w->top->line + w->h && (l + n >= w->top->line + w->h || (l + n == w->b->eof->line && w->b->eof->line >= w->top->line + w->h))) {
		if (l >= w->top->line)
			/* Update window from l to end */
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, w->h - (int) (l - w->top->line));
		else
			/* Update entire window */
			msetI(w->t->t->updtab + w->y, 1, w->h);
	} else if (l < w->top->line + w->h && l + n == w->b->eof->line && w->b->eof->line < w->top->line + w->h) {
		if (l >= w->top->line)
			/* Update window from l to end of file */
			msetI(w->t->t->updtab + w->y + l - w->top->line, 1, (int) n);
		else
			/* Update from beginning of window to end of file */
			msetI(w->t->t->updtab + w->y, 1, (int) (w->b->eof->line - w->top->line));
	} else if (l + n < w->top->line + w->h && l + n > w->top->line && l + n < w->b->eof->line) {
		if (l + flg >= w->top->line)
			nscrlup(w->t->t, (int) (w->y + l + flg - w->top->line), w->y + w->h, (int) n);
		else
			nscrlup(w->t->t, w->y, w->y + w->h, (int) (l + n - w->top->line));
	}
}

/* Update a single line */

static int
lgen(SCRN *t, int y,
    /* screen line address */
    int *screen,
    int *attr, int x,
    /* window */
    int w,
    /* buffer pointer */
    P *p,
    /* starting column to display */
    long int scr,
    /* range for marked block */
    long int from, long int to,
    int st, BW *bw)
{
	int ox = x;
	int tach, tach1;
	int done = 1;
	long col = 0;
	long byte = p->byte;
	unsigned char *bp;	/* Buffer pointer, 0 if not set */
	int amnt;		/* Amount left in this segment of the buffer */
	int c, ta, c1 = 0;
	unsigned char bc = 0;
	int ungetit = -1;

	struct utf8_sm utf8_sm;

	int *syn = NULL;
	P *tmp;
	int idx=0;
	int atr = 0;

	utf8_init(&utf8_sm);

	if(st!=-1) {
		tmp=pdup(p);
		p_goto_bol(tmp);
		parse(bw->o.syntax,tmp,st);
		syn = attr_buf;
		prm(tmp);
	}

	/* Initialise bp and amnt from p */
	if (p->ofst >= p->hdr->hole) {
		bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	} else {
		bp = p->ptr + p->ofst;
		amnt = p->hdr->hole - p->ofst;
	}

	if (col == scr)
		goto v_loop;

#define LGEN_Q
#define LGEN_LABEL(x) q_ ## x
#include "bw-lgen.inc"
#undef LGEN_LABEL

#undef LGEN_Q
#define LGEN_LABEL(x) v_ ## x
#include "bw-lgen.inc"
#undef LGEN_LABEL

 eobl:
	/* End of buffer line found.  Erase to end of screen line */
	++p->line;
 eof:
	done = x == w ? 0 : eraeol(t, x, y);
 bye:
	c = 1;
	if (0)
		/* FALLTHROUGH */
 eosl:
	  done = c = 0; /* End of screen line */

	/* Set p to bp/amnt */
	if ((p->ofst = bp - p->ptr) > p->hdr->hole)
		p->ofst -= p->hdr->ehole - p->hdr->hole;
	p->byte = byte;
	if (!c)
		pnextl(p);
	return (done);
}

static void gennum(BW *w, int *screen, int *attr, SCRN *t, int y, int *comp)
{
	unsigned char buf[12];
	int z;
	int lin = w->top->line + y - w->y;

	if (lin <= w->b->eof->line)
		joe_snprintf_1((char *)buf, sizeof(buf), "%5ld ", w->top->line + y - w->y + 1);
	else
		strlcpy((char *)buf, "      ",12);
	for (z = 0; buf[z]; ++z) {
		outatr(w->b->o.charmap, t, screen + z, attr + z, z, y, buf[z], 0);
		if (have)
			return;
		comp[z] = buf[z];
	}
}

void bwgenh(BW *w)
{
	int *screen;
	int *attr;
	P *q = pdup(w->top);
	int bot = w->h + w->y;
	int y;
	SCRN *t = w->t->t;
	int flg = 0;
	long from;
	long to;
	int dosquare = 0;

	from = to = 0;

	if (markv(0) && markk->b == w->b)
		if (square) {
			from = markb->xcol;
			to = markk->xcol;
			dosquare = 1;
		} else {
			from = markb->byte;
			to = markk->byte;
		}
	else if (marking && w == maint->curwin->object.bw && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
		if (square) {
			from = long_min(w->cursor->xcol, markb->xcol);
			to = long_max(w->cursor->xcol, markb->xcol);
			dosquare = 1;
		} else {
			from = long_min(w->cursor->byte, markb->byte);
			to = long_max(w->cursor->byte, markb->byte);
		}
	}

	if (marking && w == maint->curwin->object.bw)
		msetI(t->updtab + w->y, 1, w->h);

	if (dosquare) {
		from = 0;
		to = 0;
	}

	y=w->y;
	attr = t->attr + y*w->t->w;
	for (screen = t->scrn + y * w->t->w; y != bot; ++y, (screen += w->t->w), (attr += w->t->w)) {
		unsigned char txt[80];
		int fmt[80];
		unsigned char bf[16];
		int x;
		memset(txt,' ',76);
		msetI(fmt, /* BG_COLOR(bg_text) */ 0,76);
		txt[76]=0;
		if (!flg) {
#if SIZEOF_LONG_LONG && SIZEOF_LONG_LONG == SIZEOF_OFF_T
			joe_snprintf_1((char *)bf,sizeof(bf),"%8llX ",(unsigned long long)q->byte);
#else
			joe_snprintf_1((char *)bf,sizeof(bf),"%8lX ",(unsigned long)q->byte);
#endif
			memcpy(txt,bf,9);
			for (x=0; x!=8; ++x) {
				int c;
				if (q->byte==w->cursor->byte && !flg) {
					fmt[10+x*3] |= INVERSE;
					fmt[10+x*3+1] |= INVERSE;
				}
				if (q->byte>=from && q->byte<to && !flg) {
					fmt[10+x*3] |= UNDERLINE;
					fmt[10+x*3+1] |= UNDERLINE;
					fmt[60+x] |= INVERSE;
				}
				c = pgetb(q);
				if (c >= 0) {
					joe_snprintf_1((char *)bf,sizeof(bf),"%2.2X",c);
					txt[10+x*3] = bf[0];
					txt[10+x*3+1] = bf[1];
					if (c >= 0x20 && c <= 0x7E)
						txt[60+x] = c;
					else
						txt[60+x] = '.';
				} else
					flg = 1;
			}
			for (x=8; x!=16; ++x) {
				int c;
				if (q->byte==w->cursor->byte && !flg) {
					fmt[11+x*3] |= INVERSE;
					fmt[11+x*3+1] |= INVERSE;
				}
				if (q->byte>=from && q->byte<to && !flg) {
					fmt[11+x*3] |= UNDERLINE;
					fmt[11+x*3+1] |= UNDERLINE;
					fmt[60+x] |= INVERSE;
				}
				c = pgetb(q);
				if (c >= 0) {
					joe_snprintf_1((char *)bf,sizeof(bf),"%2.2X",c);
					txt[11+x*3] = bf[0];
					txt[11+x*3+1] = bf[1];
					if (c >= 0x20 && c <= 0x7E)
						txt[60+x] = c;
					else
						txt[60+x] = '.';
				} else
					flg = 1;
			}
		}
		genfield(t, screen, attr, 0, y, w->offset, txt, 76, 0, w->w, 1, fmt);
	}
	prm(q);
}

void bwgen(BW *w, int linums)
{
	int *screen;
	int *attr;
	P *p = NULL;
	P *q = pdup(w->cursor);
	int bot = w->h + w->y;
	int y;
	int dosquare = 0;
	long from, to;
	long fromline, toline;
	SCRN *t = w->t->t;

	fromline = toline = from = to = 0;

	if (markv(0) && markk->b == w->b)
		if (square) {
			from = markb->xcol;
			to = markk->xcol;
			dosquare = 1;
			fromline = markb->line;
			toline = markk->line;
		} else {
			from = markb->byte;
			to = markk->byte;
		}
	else if (marking && w == maint->curwin->object.bw && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
		if (square) {
			from = long_min(w->cursor->xcol, markb->xcol);
			to = long_max(w->cursor->xcol, markb->xcol);
			fromline = long_min(w->cursor->line, markb->line);
			toline = long_max(w->cursor->line, markb->line);
			dosquare = 1;
		} else {
			from = long_min(w->cursor->byte, markb->byte);
			to = long_max(w->cursor->byte, markb->byte);
		}
	}

	if (marking && w == maint->curwin->object.bw)
		msetI(t->updtab + w->y, 1, w->h);

	y = w->cursor->line - w->top->line + w->y;
	attr = t->attr + y*w->t->w;
	for (screen = t->scrn + y * w->t->w; y != bot; ++y, (screen += w->t->w), (attr += w->t->w)) {
		if (have && !linums)
			break;
		if (linums)
			gennum(w, screen, attr, t, y, t->compose);
		if (t->updtab[y]) {
			p = getto(p, w->cursor, w->top, w->top->line + y - w->y);
/*			if (t->insdel && !w->x) {
				pset(q, p);
				if (dosquare)
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					else
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
				else
					lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				magic(t, y, screen, attr, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
			} */
			if (dosquare)
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
				else
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
			else
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
		}
	}

	y = w->y;
	attr = t->attr + w->y * w->t->w;
	for (screen = t->scrn + w->y * w->t->w; y != w->y + w->cursor->line - w->top->line; ++y, (screen += w->t->w), (attr += w->t->w)) {
		if (have && !linums)
			break;
		if (linums)
			gennum(w, screen, attr, t, y, t->compose);
		if (t->updtab[y]) {
			p = getto(p, w->cursor, w->top, w->top->line + y - w->y);
/*			if (t->insdel && !w->x) {
				pset(q, p);
				if (dosquare)
					if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
					else
						lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, 0L, 0L);
				else
					lgena(t, y, t->compose, w->x, w->x + w->w, q, w->offset, from, to);
				magic(t, y, screen, attr, t->compose, (int) (w->cursor->xcol - w->offset + w->x));
			} */
			if (dosquare)
				if (w->top->line + y - w->y >= fromline && w->top->line + y - w->y <= toline)
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
				else
					t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, 0L, 0L, get_highlight_state(w,w->top->line+y-w->y),w);
			else
				t->updtab[y] = lgen(t, y, screen, attr, w->x, w->x + w->w, p, w->offset, from, to, get_highlight_state(w,w->top->line+y-w->y),w);
		}
	}
	prm(q);
	if (p)
		prm(p);
}

void bwmove(BW *w, int x, int y)
{
	w->x = x;
	w->y = y;
}

void bwresz(BW *w, int wi, int he)
{
	if (he > w->h && w->y != -1) {
		msetI(w->t->t->updtab + w->y + w->h, 1, he - w->h);
		msetI(w->t->t->syntab + w->y + w->h, -1, he - w->h);
		}
	w->w = wi;
	w->h = he;
}

BW *bwmk(W *window, B *b, int prompt)
{
	BW *w = malloc(sizeof(BW));

	w->parent = window;
	w->b = b;
	if (prompt || (!window->y && staen)) {
		w->y = window->y;
		w->h = window->h;
	} else {
		w->y = window->y + 1;
		w->h = window->h - 1;
	}
	if (b->oldcur) {
		w->top = b->oldtop;
		b->oldtop = NULL;
		w->top->owner = NULL;
		w->cursor = b->oldcur;
		b->oldcur = NULL;
		w->cursor->owner = NULL;
	} else {
		w->top = pdup(b->bof);
		w->cursor = pdup(b->bof);
	}
	w->t = window->t;
	w->object = NULL;
	w->offset = 0;
	w->o = w->b->o;
	if ((w->linums = w->o.linums)) {
		w->x = window->x + LINCOLS;
		w->w = window->w - LINCOLS;
	} else {
		w->x = window->x;
		w->w = window->w;
	}
	if (window == window->main) {
		rmkbd(window->kbd);
		window->kbd = mkkbd(kmap_getcontext(w->o.context, 1));
	}
	w->top->xcol = 0;
	w->cursor->xcol = 0;
	w->top_changed = 1;
	return w;
}

void bwrm(BW *w)
{
	prm(w->top);
	prm(w->cursor);
	brm(w->b);
	free(w);
}

int ustat_j(BW *bw)
{
	static unsigned char buf[80];
	int c = brch(bw->cursor);

	if (c == NO_MORE_DATA)
		joe_snprintf_4((char *)buf, sizeof(buf),
		    "** Line %ld  Col %ld  Offset %ld(0x%lX) **",
		    bw->cursor->line + 1, piscol(bw->cursor) + 1,
		    bw->cursor->byte, bw->cursor->byte);
	else
		joe_snprintf_9((char *)buf, sizeof(buf),
		    "** Line %ld  Col %ld  Offset %ld(0x%lX)  %s %d(0%o/0x%X) Width %d **",
		    bw->cursor->line + 1, piscol(bw->cursor) + 1,
		    bw->cursor->byte, bw->cursor->byte,
		    bw->b->o.charmap->name, c, c, c,
		    bw->o.charmap->type ? joe_wcwidth(c) : 1);
	msgnw(bw->parent, buf);
	return 0;
}

int ucrawlr(BW *bw)
{
	int amnt = bw->w / 2;

	pcol(bw->cursor, bw->cursor->xcol + amnt);
	bw->cursor->xcol += amnt;
	bw->offset += amnt;
	updall();
	return 0;
}

int ucrawll(BW *bw)
{
	int amnt = bw->w / 2;
	int curamnt = bw->w / 2;

	if (amnt > bw->offset) {
		amnt = bw->offset;
		curamnt = bw->offset;
	}
	if (!bw->offset)
		curamnt = bw->cursor->xcol;
	if (!curamnt)
		return -1;
	pcol(bw->cursor, bw->cursor->xcol - curamnt);
	bw->cursor->xcol -= curamnt;
	bw->offset -= amnt;
	updall();
	return 0;
}

void orphit(BW *bw)
{
	++bw->b->count;
	bw->b->orphan = 1;
	pdupown(bw->cursor, &bw->b->oldcur);
	pdupown(bw->top, &bw->b->oldtop);
}
@


1.38
log
@factor out lgen core code, which exists twice, almost identcally
(a “quiet” and a “verbose” mode); also, extend verbose mode UTF-8
early abort for tab after incomplete multibyte sequence

still bogus: not in quiet mode, only ungets previous octet
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.36 2018/01/07 20:32:46 tg Exp $");
d336 2
a337 2
	int c, ta, c1;
	unsigned char bc;
@


1.37
log
@get rid of extra joe_wcwidth parameter by inlining its only remaining use
@
text
@d357 1
a357 1
/* Initialize bp and amnt from p */
d367 1
a367 225
		goto loop;
 lp:
	/* Display next character */
	if (amnt)
		do {
			if (ungetit== -1)
				bc = *bp++;
			else {
				bc = ungetit;
				ungetit = -1;
			}
			if(st!=-1)
				atr = syn[idx++];
			if (p->b->o.crlf && bc == '\r') {
				++byte;
				if (!--amnt) {
 pppl:
					if (bp == p->ptr + SEGSIZ) {
						if (pnext(p)) {
							bp = p->ptr;
							amnt = p->hdr->hole;
						} else
							goto nnnl;
					} else {
						bp = p->ptr + p->hdr->ehole;
						amnt = SEGSIZ - p->hdr->ehole;
						if (!amnt)
							goto pppl;
					}
				}
				if (*bp == '\n') {
					++bp;
					++byte;
					++amnt;
					goto eobl;
				}
 nnnl:
				--byte;
				++amnt;
			}
			if (square)
				if (bc == '\t') {
					long tcol = col + p->b->o.tab - col % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (col >= from && col < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - col % p->b->o.tab;
				if (ta + col > scr) {
					ta -= scr - col;
					goto dota_tab;
				}
				if ((col += ta) == scr) {
					--amnt;
					goto loop;
				}
			} else if (bc == '\n')
				goto eobl;
			else {
				int wid = 1;

				/* should be p->b->o.charmap->type but for Coverity; they are identical here */
				if (bw->b->o.charmap->type) {
					c = utf8_decode(&utf8_sm,bc);

					if (c>=0) /* Normal decoded character */
						wid = joe_wcwidth(c);
					else if(c== -1) /* Character taken */
						wid = -1;
					else if(c== -2) { /* Incomplete sequence */
						wid = 1;
						ungetit = c;
						++amnt;
						--byte;
					}
					else if(c== -3) /* Control character 128-191, 254, 255 */
						wid = 1;
				}

				if (wid >= 0) {
					col += wid;
					if (col == scr) {
						--amnt;
						goto loop;
					} else if (col > scr) {
						ta = col - scr;
						tach1 = tach = '<';
						goto dota_gen;
					}
				} else
					--idx;	/* Get highlighting character again.. */
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto lp;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto lp;
	}
	goto eof;
 loop:
	/* Display next character */
	if (amnt)
		do {
			if (ungetit== -1)
				bc = *bp++;
			else {
				bc = ungetit;
				ungetit = -1;
			}
			if(st!=-1)
				atr=syn[idx++];
			if (p->b->o.crlf && bc == '\r') {
				++byte;
				if (!--amnt) {
 ppl:
					if (bp == p->ptr + SEGSIZ) {
						if (pnext(p)) {
							bp = p->ptr;
							amnt = p->hdr->hole;
						} else
							goto nnl;
					} else {
						bp = p->ptr + p->hdr->ehole;
						amnt = SEGSIZ - p->hdr->ehole;
						if (!amnt)
							goto ppl;
					}
				}
				if (*bp == '\n') {
					++bp;
					++byte;
					++amnt;
					goto eobl;
				}
 nnl:
				--byte;
				++amnt;
			}
			if (square)
				if (bc == '\t') {
					long tcol = scr + x - ox + p->b->o.tab - (scr + x - ox) % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (scr + x - ox >= from && scr + x - ox < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - ((x - ox + scr) % p->b->o.tab);
 dota_tab:
				tach1 = tach = ' ';
				if (bw->o.vispace)
					tach = 0x2192;
 dota_gen:
				do {
					outatr(utf8_map, t, screen + x, attr + x, x, y, tach, c1|atr);
					tach = tach1;
					if (have)
						goto bye;
					if (++x == w)
						goto eosl;
				} while (--ta);
			} else if (bc == '\n') {
				if (utf8_sm.state)
					goto unget_cch;
				goto eobl;
			} else {
				int wid = -1;
				int utf8_char;

				/* should be p->b->o.charmap but it’s identical */
				if (bw->b->o.charmap->type) {
					/* UTF-8 */
					utf8_char = utf8_decode(&utf8_sm,bc);

					if (utf8_char >= 0) {
						/* Normal decoded character */
						wid = joe_wcwidth(utf8_char);
					} else if (utf8_char == -1) {
						/* Character taken */
						wid = -1;
					} else if (utf8_char == -2) {
						/* Incomplete sequence (FIXME: do something better here) */
 unget_cch:
						ungetit = bc;
						++amnt;
						--byte;
						utf8_char = 0x1000FFFE;
						wid = utf8_sm.ptr;
						utf8_init(&utf8_sm);
					} else if (utf8_char == -3) {
						/* Invalid UTF-8 start character 128-191, 254, 255 */
						/* Show as control character */
						wid = 1;
						utf8_char = 0x1000FFFE;
					}
				} else { /* Regular */
					utf8_char = bc;
					wid = 1;
				}
d369 9
a377 19
				if(wid>=0) {
					if (x+wid > w) {
						/* If character hits right most column, don't display it */
						while (x < w) {
							outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, '>', c1|atr);
							x++;
						}
					} else if (utf8_char == 0x1000FFFE) while (wid--) {
						outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, 0xFFFD, (c1|atr|UNDERLINE)^INVERSE);
						x++;
					} else if (bw->o.vispace && (utf8_char == 0x20)) {
						outatr(utf8_map, t, screen + x, attr + x, x, y, 0xB7, c1|atr);
						x += wid;
					} else {
						outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, utf8_char, c1|atr);
						x += wid;
					}
				} else
					--idx;
a378 18
				if (have)
					goto bye;
				if (x >= w)
					goto eosl;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto loop;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto loop;
	}
	goto eof;
d383 1
a383 6
	if (x != w)
		done = eraeol(t, x, y);
	else
		done = 0;

/* Set p to bp/amnt */
d385 5
a389 6
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	return done;
d391 3
a393 5
 eosl:
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
d395 3
a397 2
	pnextl(p);
	return 0;
@


1.36
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.34 2017/12/20 22:50:32 tg Exp $");
d444 1
a444 1
						wid = joe_wcwidth(1,c);
d569 1
a569 1
						wid = joe_wcwidth(1,utf8_char);
d970 4
a973 1
		joe_snprintf_4((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lX) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d975 6
a980 1
		joe_snprintf_9((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lX)  %s %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.35
log
@also reposition screen leftmost during hex edit mode
@
text
@a14 1
#include <limits.h>
@


1.34
log
@use bw->b->o.charmap consistently: in some places, p->b->o.charmap would
be fachlich more correct, but to instruct Coverity that they are identical…
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.33 2017/12/08 02:28:04 tg Exp $");
d77 2
a78 1
static void bwfllwh(BW *w)
d80 2
d120 4
a123 5
	if (w->cursor->byte%16+60 < w->offset) {
		w->offset = w->cursor->byte%16+60;
		msetI(w->t->t->updtab + w->y, 1, w->h);
	} else if (w->cursor->byte%16+60 >= w->offset + w->w) {
		w->offset = w->cursor->byte%16+60 - (w->w - 1);
d165 1
a165 1
/* Adjust column */
@


1.33
log
@label indent; small tweaks while here
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.32 2017/12/08 02:17:21 tg Exp $");
d313 14
a326 8
static int lgen(SCRN *t, int y, int *screen, int *attr, int x, int w, P *p, long int scr, long int from, long int to,int st,BW *bw)


				/* Screen line address */
				/* Window */
				/* Buffer pointer */
				/* Starting column to display */
				/* Range for marked block */
d437 3
a439 1
				if (p->b->o.charmap->type) {
a559 1
				if (p->b->o.charmap->type) { /* UTF-8 */
d561 3
d566 2
a567 1
					if (utf8_char >= 0) { /* Normal decoded character */
d569 2
a570 1
					} else if(utf8_char== -1) { /* Character taken */
d572 2
a573 1
					} else if(utf8_char== -2) { /* Incomplete sequence (FIXME: do something better here) */
d581 2
a582 1
					} else if(utf8_char== -3) { /* Invalid UTF-8 start character 128-191, 254, 255 */
@


1.32
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.30 2017/12/07 02:10:15 tg Exp $");
d361 2
a362 1
      lp:			/* Display next character */
d376 1
a376 1
				      pppl:
d396 1
a396 1
			      nnnl:
d474 2
a475 2

      loop:			/* Display next character */
d489 1
a489 1
				      ppl:
d509 1
a509 1
			      nnl:
d616 2
a617 2

      eobl:			/* End of buffer line found.  Erase to end of screen line */
d619 1
a619 1
      eof:
d626 1
a626 1
      bye:
d634 1
a634 1
      eosl:
@


1.31
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d316 5
a320 5
            			/* Screen line address */
      				/* Window */
     				/* Buffer pointer */
         			/* Starting column to display */
              			/* Range for marked block */
d335 4
a338 4
        int *syn = NULL;
        P *tmp;
        int idx=0;
        int atr = 0;
@


1.30
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.29 2017/12/06 23:17:33 tg Exp $");
d897 1
a897 1
	BW *w = (BW *) joe_malloc(sizeof(BW));
d945 1
a945 1
	joe_free(w);
@


1.29
log
@whitespace at EOL annoys me
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.28 2017/12/06 23:02:01 tg Exp $");
d175 1
a175 1
void bwfllw(BW *w)
d177 1
d685 1
a685 1
	else if (marking && w == (BW *)maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d696 1
a696 1
	if (marking && w == (BW *)maint->curwin->object)
d799 1
a799 1
	else if (marking && w==maint->curwin->object && markb && markb->b == w->b && w->cursor->byte != markb->byte && !from) {
d812 1
a812 1
	if (marking && w==maint->curwin->object)
@


1.28
log
@lots of fixes related to prototyping
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.27 2017/12/06 21:16:54 tg Exp $");
d313 2
a314 2
        
      
@


1.27
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.26 2017/12/04 22:15:38 tg Exp $");
d187 2
a188 1
int get_highlight_state(BW *w,int line)
@


1.26
log
@clean up some unused/MS-DOS® stuff
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/bw.c,v 1.24 2017/12/02 02:07:24 tg Exp $");
a13 1
#ifdef HAVE_STDLIB_H
a14 1
#endif
d946 1
a946 1
int ustat(BW *bw)
@


1.25
log
@some fallout of the includes changes, some more reduction
@
text
@d539 1
a539 1
					if (ifhave)
d597 1
a597 1
				if (ifhave)
d655 1
a655 1
		if (ifhave)
d818 1
a818 1
		if (ifhave && !linums)
d848 1
a848 1
		if (ifhave && !linums)
@


1.24
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a31 1
#include "utf8.h"
@


1.23
log
@what a mess, indeed!

use LONG_MAX instead of homegrown MAXINT/MAXLONG
@
text
@a0 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.22 2017/07/09 01:15:51 tg Exp $ */
d11 2
a13 1
#include <stdio.h>
@


1.22
log
@more treating of combined characters like normals

sadly, still not enough
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.19 2013/11/07 21:50:35 tg Exp $ */
d17 1
d47 1
a47 1
		long dist = MAXLONG;
@


1.21
log
@lintian fixes
@
text
@d447 1
a447 1
				if(wid>0) {
@


1.20
log
@fix compilation on SuSE Linux 1.0
@
text
@d249 1
a249 1
/* Scroll a buffer window after an insert occured.  'flg' is set to 1 if
@


1.19
log
@Update “visible spaces” while typing and fix it for nōn-UTF8 files; also rid some of the assumptions that all charmaps have tab, space at same positions
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.18 2012/12/30 21:45:12 tg Exp $ */
d23 1
d716 1
a716 1
			snprintf((char *)bf,sizeof(bf),"%8llX ",(unsigned long long)q->byte);
d718 1
a718 1
			snprintf((char *)bf,sizeof(bf),"%8lX ",(unsigned long)q->byte);
d734 1
a734 1
					snprintf((char *)bf,sizeof(bf),"%2.2X",c);
d757 1
a757 1
					snprintf((char *)bf,sizeof(bf),"%2.2X",c);
@


1.18
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.16 2012/07/18 16:46:03 tg Exp $ */
a311 2
#define maybe_from_uni(map,ch) ((bw->b->o.charmap->type) ? (ch) : from_uni(map, ch))

d419 1
a419 4
					tach1 = tach = ' ';
					if (bw->o.vispace)
						tach = maybe_from_uni(locale_map, 0x2192);
					goto dota;
d454 1
a454 1
						goto dota;
d530 1
d533 2
a534 2
					tach = maybe_from_uni(locale_map, 0x2192);
			      dota:
d536 1
a536 1
					outatr(bw->b->o.charmap, t, screen + x, attr + x, x, y, tach, c1|atr);
d586 3
a589 2
						if (bw->o.vispace && (utf8_char == 0x20))
							utf8_char = maybe_from_uni(locale_map, 0xB7);
@


1.17
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d934 1
a934 1
		window->kbd = mkkbd(kmap_getcontext(w->o.context));
@


1.16
log
@fix missing memory initialisation that made eglibc/i386 ctime(3) hiccup
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.15 2010/04/08 15:31:01 tg Exp $ */
d55 1
a55 1
			dist = d;
d151 3
a153 5
		newtop = pdup(w->top);
		if (mid)
			newtop = getto(NULL, w->cursor, w->top, w->cursor->line - w->h / 2);
		else
			newtop = getto(NULL, w->cursor, w->top, w->cursor->line - (w->h - 1));
@


1.15
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.14 2009/10/18 16:08:56 tg Exp $ */
d927 1
a927 1
	if (w->o.linums) {
@


1.14
log
@fixme is fulfilled ;)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.13 2009/10/18 16:07:39 tg Exp $ */
a36 1
extern int square;
d720 1
a720 1
			snprintf((char *)bf,sizeof(bf),"%8llX ",q->byte);
d722 1
a722 1
			snprintf((char *)bf,sizeof(bf),"%8lX ",q->byte);
@


1.13
log
@no snprintf for me please
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.12 2009/10/18 16:06:28 tg Exp $ */
d444 1
a444 1
					else if(c== -2) { /* Incomplete sequence (FIXME: do something better here) */
@


1.12
log
@hex is uppercase!
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.11 2009/10/18 16:01:28 tg Exp $ */
d721 1
a721 1
			sprintf((char *)bf,"%8llX ",q->byte);
d723 1
a723 1
			sprintf((char *)bf,"%8lX ",q->byte);
d739 1
a739 1
					sprintf((char *)bf,"%2.2X",c);
d762 1
a762 1
					sprintf((char *)bf,"%2.2X",c);
@


1.11
log
@fix for raw octet at EOL
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.10 2009/10/18 14:52:55 tg Exp $ */
d721 1
a721 1
			sprintf((char *)bf,"%8llx ",q->byte);
d723 1
a723 1
			sprintf((char *)bf,"%8lx ",q->byte);
d739 1
a739 1
					sprintf((char *)bf,"%2.2x",c);
d762 1
a762 1
					sprintf((char *)bf,"%2.2x",c);
d959 1
a959 1
		joe_snprintf_4((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx) **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);
d961 1
a961 1
		joe_snprintf_9((char *)buf, sizeof(buf), "** Line %ld  Col %ld  Offset %ld(0x%lx)  %s %d(0%o/0x%X) Width %d **", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));
@


1.10
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.9 2009/10/06 09:07:29 tg Exp $ */
d550 3
a552 1
			} else if (bc == '\n')
d554 1
a554 1
			else {
d566 1
d572 1
@


1.9
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.8 2007/02/18 22:34:08 tg Exp $ */
d77 54
a130 1
void bwfllw(BW *w)
d177 10
d662 112
@


1.8
log
@use different replacement characters - fixes cursor position (joe_wcwidth…)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.7 2007/02/18 21:53:39 tg Exp $ */
d18 3
@


1.7
log
@display the U+FFFD in the correct width (more than once for validly
started but invalid multibyte sequences), underlined and reversed
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.6 2007/02/18 21:35:02 tg Exp $ */
d501 1
a501 1
						utf8_char = 0xFFFE;
d506 1
a506 1
						utf8_char = 0xFFFE;
d520 1
a520 1
					} else if (utf8_char == 0xFFFE) while (wid--) {
@


1.6
log
@instead of displaying invalid utf-8 as 'X' use U+FFFD - stage 1
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.5 2006/11/10 23:46:44 tg Exp $ */
d501 2
a502 2
						utf8_char = 0xFFFD;
						wid = 1;
d506 1
a506 1
						utf8_char = 0xFFFD;
d520 3
@


1.5
log
@use from_uni only if needed (logic from outatr(), adapted accordingly)
XXX this stinks
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/bw.c,v 1.4 2006/11/10 23:23:30 tg Exp $ */
d501 1
a501 1
						utf8_char = 'X';
d506 1
a506 1
						utf8_char = 'X';
@


1.4
log
@* types.h, rc.c: extend per-file options by new "vispace" (visible spaces)
* rc.c: assign options menu entry for "vispace"
* bw.c: implement "vispace" by displaying a replacement character for any
  space or a tab's first column if enabled
* charmap.h: increment unicode-to-8bit mapping table size
* charmap.c: ensure the two replacement characters we use in bw.c for the
  visibled spaces and tabs are always mapped to something
* rc.c: make "noxon" an options menu entry and move it and "keepup" to top
* rc.c: fix out-of-bounds in options menu routines
@
text
@d1 1
a1 1
/* $MirOS$ */
d249 2
d360 1
a360 1
						tach = from_uni(locale_map, 0x2192);
d474 1
a474 1
					tach = from_uni(locale_map, 0x2192);
d522 1
a522 1
							utf8_char = from_uni(locale_map, 0xB7);
@


1.3
log
@remove dead code
@
text
@d1 1
d259 1
a259 1
	int tach;
d356 3
a358 1
					tach = ' ';
d393 1
a393 1
						tach = '<';
d470 3
a472 1
				tach = ' ';
d476 1
d519 2
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@a564 160
/* Generate line into an array */

#if 0
static int lgena(SCRN *t, int y, int *screen, int x, int w, P *p, long int scr, long int from, long int to)
        
      
            			/* Screen line address */
      				/* Window */
     				/* Buffer pointer */
         			/* Starting column to display */
              			/* Range for marked block */
{
	int ox = x;
	int done = 1;
	long col = 0;
	long byte = p->byte;
	unsigned char *bp;	/* Buffer pointer, 0 if not set */
	int amnt;		/* Amount left in this segment of the buffer */
	int c, ta, c1;
	unsigned char bc;

/* Initialize bp and amnt from p */
	if (p->ofst >= p->hdr->hole) {
		bp = p->ptr + p->hdr->ehole + p->ofst - p->hdr->hole;
		amnt = SEGSIZ - p->hdr->ehole - (p->ofst - p->hdr->hole);
	} else {
		bp = p->ptr + p->ofst;
		amnt = p->hdr->hole - p->ofst;
	}

	if (col == scr)
		goto loop;
      lp:			/* Display next character */
	if (amnt)
		do {
			bc = *bp++;
			if (square)
				if (bc == '\t') {
					long tcol = col + p->b->o.tab - col % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (col >= from && col < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - col % p->b->o.tab;
				if (ta + col > scr) {
					ta -= scr - col;
					goto dota;
				}
				if ((col += ta) == scr) {
					--amnt;
					goto loop;
				}
			} else if (bc == '\n')
				goto eobl;
			else if (++col == scr) {
				--amnt;
				goto loop;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto lp;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto lp;
	}
	goto eobl;

      loop:			/* Display next character */
	if (amnt)
		do {
			bc = *bp++;
			if (square)
				if (bc == '\t') {
					long tcol = scr + x - ox + p->b->o.tab - (scr + x - ox) % p->b->o.tab;

					if (tcol > from && tcol <= to)
						c1 = INVERSE;
					else
						c1 = 0;
				} else if (scr + x - ox >= from && scr + x - ox < to)
					c1 = INVERSE;
				else
					c1 = 0;
			else if (byte >= from && byte < to)
				c1 = INVERSE;
			else
				c1 = 0;
			++byte;
			if (bc == '\t') {
				ta = p->b->o.tab - ((x - ox + scr) % p->b->o.tab);
			      dota:
				do {
					screen[x] = ' ' + c1;
					if (++x == w)
						goto eosl;
				} while (--ta);
			} else if (bc == '\n')
				goto eobl;
			else {
				/* xlat(&c, &bc);*/
				c ^= c1;
				screen[x] = c + bc;
				if (++x == w)
					goto eosl;
			}
		} while (--amnt);
	if (bp == p->ptr + SEGSIZ) {
		if (pnext(p)) {
			bp = p->ptr;
			amnt = p->hdr->hole;
			goto loop;
		}
	} else {
		bp = p->ptr + p->hdr->ehole;
		amnt = SEGSIZ - p->hdr->ehole;
		goto loop;
	}
	goto eof;
      eobl:			/* End of buffer line found.  Erase to end of screen line */
	++p->line;
      eof:
	while (x != w)
		screen[x++] = ' ';
	done = 0;

/* Set p to bp/amnt */
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	return done;

      eosl:
	if (bp - p->ptr <= p->hdr->hole)
		p->ofst = bp - p->ptr;
	else
		p->ofst = bp - p->ptr - (p->hdr->ehole - p->hdr->hole);
	p->byte = byte;
	pnextl(p);
	return 0;
}
#endif	/* 0 */

@


1.1
log
@Initial revision
@
text
@d270 1
a270 1
        int *syn;
d365 1
a365 1
				int wid;
a380 2
				} else {
					wid = 1;
d567 1
d723 1
d734 1
a734 1
		strcpy((char *)buf, "      ");
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Edit buffer window generation
   Copyright (C) 1992 Joseph H. Allen
d11 5
a15 1
This file is part of JOE (Joe's Own Editor)
a16 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d18 2
a19 4
#include "config.h"
#include "tty.h"
#include "vfile.h"
#include "termcap.h"
d21 1
a21 1
#include "b.h"
d23 5
a28 4
#include "ublock.h"
#include "zstr.h"
#include "blocks.h"
#include "bw.h"
d31 2
a32 2
int dspasis=0;
int marking=0;
d35 4
d40 27
a66 23
P *getto(p,cur,top,line)
P *p,*cur,*top;
long line;
{
long dist=MAXLONG;
long d;
P *best;
if(!p)
 {
 if(d=(line-cur->line>=0?line-cur->line:cur->line-line), d<dist)
  dist=d, best=cur;
 if(d=(line-top->line>=0?line-top->line:top->line-line), d<dist)
  dist=d, best=top;
 p=pdup(best);
 pbol(p);
 }
while(line>p->line) if(!pnextl(p)) break;
if(line<p->line)
 {
 while(line<p->line) pprevl(p);
 pbol(p);
 }
return p;
d71 1
a71 1
int mid=0;
d73 1
a73 2
void bwfllw(w)
BW *w;
d75 34
a108 28
P *newtop;
if(w->cursor->line<w->top->line)
 {
 newtop=pdup(w->cursor);
 pbol(newtop);
 if(mid)
  if(newtop->line>=w->h/2) pline(newtop,newtop->line-w->h/2);
  else pset(newtop,newtop->b->bof);
 if(w->top->line-newtop->line<w->h)
  nscrldn(w->t->t,w->y,w->y+w->h,(int)(w->top->line-newtop->line));
 else msetI(w->t->t->updtab+w->y,1,w->h);
 pset(w->top,newtop);
 prm(newtop);
 }
else if(w->cursor->line>=w->top->line+w->h)
 {
 newtop=pdup(w->top);
 if(mid) newtop=getto(NULL,w->cursor,w->top,w->cursor->line-w->h/2);
 else newtop=getto(NULL,w->cursor,w->top,w->cursor->line-(w->h-1));
 if(newtop->line-w->top->line<w->h)
  nscrlup(w->t->t,
            w->y,
            w->y+w->h,
            (int)(newtop->line-w->top->line));
 else msetI(w->t->t->updtab+w->y,1,w->h);
 pset(w->top,newtop);
 prm(newtop);
 }
d111 71
a181 10
if(w->cursor->xcol<w->offset)
 {
 w->offset=w->cursor->xcol;
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
else if(w->cursor->xcol>=w->offset+w->w)
 {
 w->offset=w->cursor->xcol-(w->w-1);
 msetI(w->t->t->updtab+w->y,1,w->h);
 }
d188 16
a203 15
void bwins(w,l,n,flg)
BW *w;
long l,n;
int flg;
{
if(l+flg+n<w->top->line+w->h && l+flg>=w->top->line && l+flg<=w->b->eof->line)
 {
 if(flg) w->t->t->sary[w->y+l-w->top->line]=w->t->t->li;
 nscrldn(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
 }
if(l<w->top->line+w->h && l>=w->top->line)
 if(n>=w->h-(l-w->top->line))
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,w->h-(int)(l-w->top->line));
 else
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,(int)n+1);
d208 1
a208 4
void bwdel(w,l,n,flg)
BW *w;
long l,n;
int flg;
d211 8
a218 2
if(l<w->top->line+w->h && l>=w->top->line)
 w->t->t->updtab[w->y+l-w->top->line]=1;
d221 2
a222 2
if(l+n<w->top->line+w->h && l+n>=w->top->line)
 w->t->t->updtab[w->y+l+n-w->top->line]=1;
d224 20
a243 24
if(l<w->top->line+w->h &&
   (l+n>=w->top->line+w->h ||
    l+n==w->b->eof->line && w->b->eof->line>=w->top->line+w->h))
 if(l>=w->top->line)
  /* Update window from l to end */
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,w->h-(int)(l-w->top->line));
 else
  /* Update entire window */
  msetI(w->t->t->updtab+w->y,1,w->h);
else if(l<w->top->line+w->h && l+n==w->b->eof->line &&
        w->b->eof->line<w->top->line+w->h)
 if(l>=w->top->line)
  /* Update window from l to end of file */
  msetI(w->t->t->updtab+w->y+l-w->top->line,1,(int)n);
 else
  /* Update from beginning of window to end of file */
  msetI(w->t->t->updtab+w->y,1,(int)(w->b->eof->line-w->top->line));
else if(l+n<w->top->line+w->h &&
        l+n>w->top->line &&
        l+n<w->b->eof->line)
 if(l+flg>=w->top->line)
  nscrlup(w->t->t,(int)(w->y+l+flg-w->top->line),w->y+w->h,(int)n);
 else
  nscrlup(w->t->t,w->y,w->y+w->h,(int)(l+n-w->top->line));
d248 36
a283 17
static int lgen(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int ox=x;
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta, c1;
unsigned char bc;
d286 261
a546 186
if(p->ofst>=p->hdr->hole)
 {
 bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
 amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
 }
else
 {
 bp=p->ptr+p->ofst;
 amnt=p->hdr->hole-p->ofst;
 }

if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(p->b->o.crlf && bc=='\r')
  {
  ++byte;
  if(!--amnt)
   {
   pppl:
   if(bp==p->ptr+SEGSIZ)
    {
    if(pnext(p))
     {
     bp=p->ptr;
     amnt=p->hdr->hole;
     }
    else goto nnnl;
    }
   else
    {
    bp=p->ptr+p->hdr->ehole;
    amnt=SEGSIZ-p->hdr->ehole;
    if(!amnt) goto pppl;
    }
   }
  if(*bp=='\n')
   {
   ++bp;
   ++byte;
   ++amnt;
   goto eobl;
   }
  nnnl: --byte; ++amnt;
  }
 if(square)
  if(bc=='\t')
   {
   long tcol=col+p->b->o.tab-col%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(col>=from && col<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-col%p->b->o.tab;
  if(ta+col>scr)
   {
   ta-=scr-col;
   goto dota;
   }
  if((col+=ta)==scr) { --amnt; goto loop; }
  }
 else if(bc=='\n') goto eobl;
 else if(++col==scr) { --amnt; goto loop; }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto lp;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto lp;
 }
goto eof;

loop:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(p->b->o.crlf && bc=='\r')
  {
  ++byte;
  if(!--amnt)
   {
   ppl:
   if(bp==p->ptr+SEGSIZ)
    {
    if(pnext(p))
     {
     bp=p->ptr;
     amnt=p->hdr->hole;
     }
    else goto nnl;
    }
   else
    {
    bp=p->ptr+p->hdr->ehole;
    amnt=SEGSIZ-p->hdr->ehole;
    if(!amnt) goto ppl;
    }
   }
  if(*bp=='\n')
   {
   ++bp;
   ++byte;
   ++amnt;
   goto eobl;
   }
  nnl: --byte; ++amnt;
  }
 if(square)
  if(bc=='\t')
   {
   long tcol=scr+x-ox+p->b->o.tab-(scr+x-ox)%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(scr+x-ox>=from && scr+x-ox<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-((x-ox+scr)%p->b->o.tab);
  dota:
  do
   {
   outatr(t,screen+x,x,y,' ',c1);
   if(ifhave) goto bye;
   if(++x==w) goto eosl;
   }
   while(--ta);
  }
 else if(bc=='\n') goto eobl;
 else
  {
  xlat(c,bc);
  c^=c1;
  outatr(t,screen+x,x,y,bc,c);
  if(ifhave) goto bye;
  if(++x==w) goto eosl;
  }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto loop;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto loop;
 }
goto eof;

eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
if(x!=w) done=eraeol(t,x,y);
else done=0;
d549 16
a564 12
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;

eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
d569 17
a585 17
static int lgena(t,y,screen,x,w,p,scr,from,to)
SCRN *t;
int y;
int *screen;	/* Screen line address */
int w;		/* Window */
P *p;		/* Buffer pointer */
long scr;	/* Starting column to display */
long from,to;	/* Range for marked block */
{
int ox=x;
int done=1;
long col=0;
long byte=p->byte;
char *bp;		/* Buffer pointer, 0 if not set */
int amnt;		/* Amount left in this segment of the buffer */
int c, ta, c1;
unsigned char bc;
d588 118
a705 121
if(p->ofst>=p->hdr->hole)
 {
 bp=p->ptr+p->hdr->ehole+p->ofst-p->hdr->hole;
 amnt=SEGSIZ-p->hdr->ehole-(p->ofst-p->hdr->hole);
 }
else
 {
 bp=p->ptr+p->ofst;
 amnt=p->hdr->hole-p->ofst;
 }

if(col==scr) goto loop;
lp:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(square)
  if(bc=='\t')
   {
   long tcol=col+p->b->o.tab-col%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(col>=from && col<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-col%p->b->o.tab;
  if(ta+col>scr)
   {
   ta-=scr-col;
   goto dota;
   }
  if((col+=ta)==scr) { --amnt; goto loop; }
  }
 else if(bc=='\n') goto eobl;
 else if(++col==scr) { --amnt; goto loop; }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto lp;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto lp;
 }
goto eobl;

loop:		/* Display next character */
if(amnt) do
 {
 bc= *bp++;
 if(square)
  if(bc=='\t')
   {
   long tcol=scr+x-ox+p->b->o.tab-(scr+x-ox)%p->b->o.tab;
   if(tcol>from && tcol<=to) c1=INVERSE;
   else c1=0;
   }
  else
   if(scr+x-ox>=from && scr+x-ox<to) c1=INVERSE;
   else c1=0;
 else
  if(byte>=from && byte<to) c1=INVERSE;
  else c1=0;
 ++byte;
 if(bc=='\t')
  {
  ta=p->b->o.tab-((x-ox+scr)%p->b->o.tab);
  dota:
  do
   {
   screen[x]=' '+c1;
   if(++x==w) goto eosl;
   }
   while(--ta);
  }
 else if(bc=='\n') goto eobl;
 else
  {
  xlat(c,bc);
  c^=c1;
  screen[x]=c+bc;
  if(++x==w) goto eosl;
  }
 }
 while(--amnt);
if(bp==p->ptr+SEGSIZ)
 {
 if(pnext(p))
  {
  bp=p->ptr;
  amnt=p->hdr->hole;
  goto loop;
  }
 }
else
 {
 bp=p->ptr+p->hdr->ehole;
 amnt=SEGSIZ-p->hdr->ehole;
 goto loop;
 }
goto eof;
eobl:		/* End of buffer line found.  Erase to end of screen line */
++p->line;
eof:
while(x!=w) screen[x++]=' ';
done=0;
d708 261
a968 262
bye:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
return done;

eosl:
if(bp-p->ptr<=p->hdr->hole) p->ofst=bp-p->ptr;
else p->ofst=bp-p->ptr-(p->hdr->ehole-p->hdr->hole);
p->byte=byte;
pnextl(p);
return 0;
}

void gennum(w,screen,t,y,comp)
BW *w;
int *screen;
SCRN *t;
int *comp;
 {
 char buf[12];
 int z;
 int lin=w->top->line+y-w->y;
 if(lin<=w->b->eof->line) sprintf(buf,"%5ld ",w->top->line+y-w->y+1);
 else zcpy(buf,"      ");
 for(z=0;buf[z];++z)
  {
  outatr(t,screen+z,z,y,buf[z],0);
  if(ifhave) return;
  comp[z]=buf[z];
  }
 }

void bwgen(w,linums)
BW *w;
{
int *screen;
P *p=0;
P *q=pdup(w->cursor);
int bot=w->h+w->y;
int y;
int dosquare=0;
long from,to;
long fromline,toline;
SCRN *t=w->t->t;
fromline=toline=from=to=0;

if(markv(0) && markk->b==w->b)
 if(square)
  {
  from=markb->xcol, to=markk->xcol, dosquare=1;
  fromline=markb->line;
  toline=markk->line;
  }
 else from=markb->byte, to=markk->byte;
else if(marking && markb && markb->b==w->b &&
        w->cursor->byte!= markb->byte && !from)
 if(square)
  {
  from=Lmin(w->cursor->xcol,markb->xcol),
    to=Lmax(w->cursor->xcol,markb->xcol);
  fromline=Lmin(w->cursor->line,markb->line);
  toline=Lmax(w->cursor->line,markb->line);
  dosquare=1;
  }
 else from=Lmin(w->cursor->byte,markb->byte),
        to=Lmax(w->cursor->byte,markb->byte);

if(marking) msetI(t->updtab+w->y,1,w->h);

y=w->cursor->line-w->top->line+w->y;
for(screen=t->scrn+y*w->t->w;y!=bot; ++y, screen+=w->t->w)
 {
 if(ifhave && !linums) break;
 if(linums) gennum(w,screen,t,y,t->compose);
 if(t->updtab[y])
  {
  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
  if(t->insdel && !w->x)
   {
   pset(q,p);
   if(dosquare)
    if(w->top->line+y-w->y>=fromline &&
       w->top->line+y-w->y<=toline)
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
    else
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
   else
    lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
   magic(t,y,screen,t->compose,
         (int)(w->cursor->xcol-w->offset+w->x));
   }
  if(dosquare)
   if(w->top->line+y-w->y>=fromline &&
      w->top->line+y-w->y<=toline)
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            from,to);
   else
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            0L,0L);
  else
   t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                           from,to);
  }
 }
 
y=w->y;
for(screen=t->scrn+w->y*w->t->w; y!=w->y+w->cursor->line-w->top->line;
    ++y, screen+=w->t->w)
 {
 if(ifhave && !linums) break;
 if(linums) gennum(w,screen,t,y,t->compose);
 if(t->updtab[y])
  {
  p=getto(p,w->cursor,w->top,w->top->line+y-w->y);
  if(t->insdel && !w->x)
   {
   pset(q,p);
   if(dosquare)
    if(w->top->line+y-w->y>=fromline &&
       w->top->line+y-w->y<=toline)
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
    else
     lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,0L,0L);
   else
    lgena(t,y,t->compose,w->x,w->x+w->w,q,w->offset,from,to);
   magic(t,y,screen,t->compose,
         (int)(w->cursor->xcol-w->offset+w->x));
   }
  if(dosquare)
   if(w->top->line+y-w->y>=fromline &&
      w->top->line+y-w->y<=toline)
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            from,to);
   else
    t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                            0L,0L);
  else
   t->updtab[y]=lgen(t,y,screen,w->x,w->x+w->w,p,w->offset,
                           from,to);
  }
 }
prm(q);
if(p) prm(p);
}

void bwmove(w,x,y)
BW *w;
int x,y;
{
w->x=x;
w->y=y;
}

void bwresz(w,wi,he)
BW *w;
int wi, he;
{
if(he>w->h && w->y!= -1) msetI(w->t->t->updtab+w->y+w->h,1,he-w->h);
w->w=wi;
w->h=he;
}

BW *bwmk(window,b,prompt)
W *window;
B *b;
int prompt;
{
BW *w=(BW *)malloc(sizeof(BW));
w->parent=window;
w->pid=0;
w->out= -1;
w->b=b;
if(prompt || !window->y && staen)
 w->y=window->y, w->h=window->h;
else
 w->y=window->y+1, w->h=window->h-1;
if(b->oldcur)
 {
 w->top=b->oldtop, b->oldtop=0, w->top->owner=0;
 w->cursor=b->oldcur, b->oldcur=0, w->cursor->owner=0;
 }
else
 {
 w->top=pdup(b->bof);
 w->cursor=pdup(b->bof);
 }
w->t=window->t;
w->object=NULL;
w->offset=0;
w->o=w->b->o;
if(w->o.linums) w->x=window->x+LINCOLS, w->w=window->w-LINCOLS;
else w->x=window->x, w->w=window->w;
if(window==window->main)
 {
 rmkbd(window->kbd);
 window->kbd=mkkbd(getcontext(w->o.context));
 } 
w->top->xcol=0; w->cursor->xcol=0;
return w;
}

void bwrm(w)
BW *w;
{
prm(w->top);
prm(w->cursor);
brm(w->b);
free(w);
}

int ustat(bw)
BW *bw;
{
static char buf[80];
unsigned c=brc(bw->cursor);
if(c==MAXINT)
 sprintf(buf,"** Line %ld  Col %ld  Offset %ld(0x%lx) **",
         bw->cursor->line+1,piscol(bw->cursor)+1,bw->cursor->byte,
         bw->cursor->byte);
else
 sprintf(buf,"** Line %ld  Col %ld  Offset %ld(0x%lx)  Ascii %d(0%o/0x%X) **",
         bw->cursor->line+1,piscol(bw->cursor)+1,bw->cursor->byte,
         bw->cursor->byte,255&c,255&c,255&c);
msgnw(bw,buf);
return 0;
}

int ucrawlr(bw)
BW *bw;
 {
 int amnt=bw->w/2;
 pcol(bw->cursor,bw->cursor->xcol+amnt);
 bw->cursor->xcol+=amnt;
 bw->offset+=amnt;
 updall();
 return 0;
 }

int ucrawll(bw)
BW *bw;
 {
 int amnt=bw->w/2;
 int curamnt=bw->w/2;
 if(amnt>bw->offset) amnt=bw->offset, curamnt=bw->offset;
 if(!bw->offset) curamnt=bw->cursor->xcol;
 if(!curamnt) return -1;
 pcol(bw->cursor,bw->cursor->xcol-curamnt);
 bw->cursor->xcol-=curamnt;
 bw->offset-=amnt;
 updall();
 return 0;
 }

void orphit(bw)
BW *bw;
 {
 ++bw->b->count;
 bw->b->orphan=1;
 pdupown(bw->cursor,&bw->b->oldcur);
 pdupown(bw->top,&bw->b->oldtop);
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
