head	1.25;
access;
symbols
	joe-3_1jupp38:1.25
	joe-3_1jupp37:1.25
	joe-3_1jupp36:1.23
	joe-3_1jupp35:1.23
	joe-3_1jupp34:1.23
	joe-3_1jupp33:1.23
	joe-3_1jupp32:1.22
	joe-3_1jupp31:1.19
	joe-3_1jupp30:1.19
	joe-3_1jupp29:1.12
	joe-3_1jupp28:1.12
	joe-3_1jupp27:1.11
	joe-3_1jupp26:1.10
	joe-3_1jupp25:1.9
	joe-3_1jupp24:1.9
	joe-3_1jupp23:1.9
	joe-3_1jupp22:1.9
	joe-3_1jupp21:1.9
	joe-3_1jupp20:1.9
	joe-3_1jupp19:1.8
	joe-3_1jupp18:1.8
	joe-3_1jupp17:1.8
	joe-3_1jupp16:1.8
	joe-3_1jupp15:1.8
	joe-3_1jupp14:1.7
	joe-3_1jupp12:1.6
	joe-3_1jupp11:1.6
	joe-3_1jupp10:1.6
	joe-3_1jupp9:1.6
	joe-3_1jupp8:1.5
	joe-3_1jupp7:1.4
	joe-3_1jupp6:1.3
	joe-3_1jupp5:1.3
	joe-3_1jupp4:1.3
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.25
date	2018.08.10.02.53.45;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005B6CFE0B5BDFE404;

1.24
date	2018.06.28.01.18.34;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005B34377445239827;

1.23
date	2017.12.20.23.53.29;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A3AF80C0779F0C5;

1.22
date	2017.12.06.21.17.04;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A285E5918D423C7;

1.21
date	2017.12.02.04.32.43;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A222CF2122034D9;

1.20
date	2017.12.02.02.07.37;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A220AD65C90E687;

1.19
date	2017.01.11.21.48.58;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005876A846752BE184;

1.18
date	2017.01.10.23.21.56;	author tg;	state Exp;
branches;
next	1.17;
commitid	10058756CA66A05EFC8;

1.17
date	2017.01.10.23.20.48;	author tg;	state Exp;
branches;
next	1.16;
commitid	10058756C691D0ECC14;

1.16
date	2017.01.10.23.07.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	100587569476EEF4F12;

1.15
date	2017.01.10.22.38.34;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005875626F15DCCDF1;

1.14
date	2017.01.10.21.22.31;	author tg;	state Exp;
branches;
next	1.13;
commitid	100587550AA57D36DCA;

1.13
date	2017.01.10.21.04.31;	author tg;	state Exp;
branches;
next	1.12;
commitid	10058754C72588965C9;

1.12
date	2014.10.23.17.10.45;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005449369348370C87;

1.11
date	2014.06.26.18.15.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	10053AC63477EECD548;

1.10
date	2013.11.07.21.50.36;	author tg;	state Exp;
branches;
next	1.9;
commitid	100527C0B43044C6E4A;

1.9
date	2012.06.08.16.55.29;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004FD22E961A7F5A95;

1.8
date	2011.07.02.22.50.52;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E0FA0C8102DBFF8;

1.7
date	2010.04.08.17.54.19;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004BBE184A709C3F5C;

1.6
date	2008.05.13.13.08.30;	author tg;	state Exp;
branches;
next	1.5;
commitid	100482992BC01EE89A1;

1.5
date	2006.11.17.03.05.15;	author tg;	state Exp;
branches;
next	1.4;
commitid	100455D26C30F732046;

1.4
date	2006.11.11.01.43.43;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045552AD72554A383;

1.3
date	2005.08.26.23.10.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	12bc430fa1790090;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.00.37.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.25
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@/*
 *	UTF-8 Utilities
 *	Copyright
 *		(C) 2004 Joseph H. Allen
 *		(c) 2004, 2006, 2011, 2013, 2014, 2017, 2018 mirabilos
 *
 *	This file is part of JOE (Joe's Own Editor)
 */

#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/utf8.c,v 1.24 2018/06/28 01:18:34 tg Exp $");

#include <stdlib.h>
#include <string.h>

#ifdef __CYGWIN__
#include <cygwin/version.h>
#endif

#ifdef __MirBSD__
#include <sys/param.h>
#endif

#undef USE_CODEPAGE
#undef USE_LOCALE
#if defined(HAVE_SETLOCALE) && defined(HAVE_NL_LANGINFO)
#define USE_LOCALE
#endif

/* Cygwin before 1.7.2 did not have locale support */
#if defined(CYGWIN_VERSION_API_MAJOR) && (CYGWIN_VERSION_API_MAJOR < 1) && \
    defined(CYGWIN_VERSION_API_MINOR) && (CYGWIN_VERSION_API_MINOR < 222)
#define USE_CODEPAGE
#undef USE_LOCALE
#endif

/* OpenBSD, ekkoBSD and old MirOS do not have real locale support */
#if defined(__OpenBSD__) && (!defined(MirBSD) || (MirBSD < 0x09A0))
#undef USE_LOCALE
#endif

#ifdef USE_LOCALE
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif
#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#endif

#ifndef CODESET
#undef USE_LOCALE
#endif

#ifdef USE_LOCALE
#undef USE_CODEPAGE
#endif

#include "rc.h"
#include "charmap.h"

/* UTF-8 Encoder
 *
 * c is a UCS character.
 * buf is 7 byte buffer: UTF-8 encoded character is written to this followed by a NUL terminator
 * returns length (not including terminator).
 */

int utf8_encode(unsigned char *buf,int c)
{
	if (c < 0x80) {
		buf[0] = c;
		buf[1] = 0;
		return 1;
	} else if(c < 0x800) {
		buf[0] = (0xc0|(c>>6));
		buf[1] = (0x80|(c&0x3F));
		buf[2] = 0;
		return 2;
	} else if(c < 0x10000) {
		buf[0] = (0xe0|(c>>12));
		buf[1] = (0x80|((c>>6)&0x3f));
		buf[2] = (0x80|((c)&0x3f));
		buf[3] = 0;
		return 3;
	} else if(c < 0x200000) {
		buf[0] = (0xf0|(c>>18));
		buf[1] = (0x80|((c>>12)&0x3f));
		buf[2] = (0x80|((c>>6)&0x3f));
		buf[3] = (0x80|((c)&0x3f));
		buf[4] = 0;
		return 4;
	} else if(c < 0x4000000) {
		buf[0] = (0xf8|(c>>24));
		buf[1] = (0x80|((c>>18)&0x3f));
		buf[2] = (0x80|((c>>12)&0x3f));
		buf[3] = (0x80|((c>>6)&0x3f));
		buf[4] = (0x80|((c)&0x3f));
		buf[5] = 0;
		return 5;
	} else {
		buf[0] = (0xfC|(c>>30));
		buf[1] = (0x80|((c>>24)&0x3f));
		buf[2] = (0x80|((c>>18)&0x3f));
		buf[3] = (0x80|((c>>12)&0x3f));
		buf[4] = (0x80|((c>>6)&0x3f));
		buf[5] = (0x80|((c)&0x3f));
		buf[6] = 0;
		return 6;
	}
}

/* UTF-8 Decoder
 *
 * Returns 0 - 7FFFFFFF: decoded character
 *                   -1: byte accepted, nothing decoded yet
 *                   -2: illegal continuation byte or sequence
 *                   -3: illegal start byte
 */

int
utf8_decode(struct utf8_sm *utf8_sm, unsigned char c)
{
	if (utf8_sm->state) {
		utf8_sm->buf[utf8_sm->ptr] = c;
		if ((c ^= 0x80) < 0x40) {
			/* trail byte */
			++utf8_sm->ptr;
			utf8_sm->accu = (utf8_sm->accu << 6) | c;
			if (--utf8_sm->state)
				return (-1);
			if (utf8_sm->accu >= utf8_sm->minv)
				return (utf8_sm->accu);
			/* reject non-minimal-encoded sequence */
			--utf8_sm->ptr;
		}
		utf8_sm->state = 0;
		return (-2);
	} else if (c < 0x80) {
		utf8_sm->accu = c; /* known to be in [0; 127] */
		utf8_sm->state = 0;
	} else if (c < 0xC2) {
 ilchar:
		utf8_init(utf8_sm);
		return (-3);
	} else if (c < 0xE0) {
		utf8_sm->accu = c & 0x1F;
		utf8_sm->state = 1;
	} else if (c < 0xF0) {
		utf8_sm->accu = c & 0x0F;
		utf8_sm->state = 2;
	} else if (c < 0xF8) {
		utf8_sm->accu = c & 0x07;
		utf8_sm->state = 3;
	} else if (c < 0xFC) {
		utf8_sm->accu = c & 0x03;
		utf8_sm->state = 4;
	} else if (c < 0xFE) {
		utf8_sm->accu = c & 0x01;
		utf8_sm->state = 5;
	} else
		goto ilchar;

	utf8_sm->minv = 1 << (5 * utf8_sm->state + 1);
	utf8_sm->buf[0] = c;
	utf8_sm->ptr = 1;

	if (!utf8_sm->state)
		/* ASCII */
		return (utf8_sm->accu);

	/* lead byte */
	utf8_sm->minv = 1 << (5 * utf8_sm->state + 1);
	return (-1);
}

/* Initialise state machine */

void utf8_init(struct utf8_sm *utf8_sm)
{
	utf8_sm->ptr = 0;
	utf8_sm->state = 0;
}

/* Decode an entire string */

int utf8_decode_string(unsigned char *s)
{
	struct utf8_sm sm;
	int x;
	int c = 0;
	utf8_init(&sm);
	for(x=0;s[x];++x)
		c = utf8_decode(&sm,s[x]);
	return c;
}

/* Decode and advance */

int utf8_decode_fwrd(unsigned char **p,int *plen)
{
	struct utf8_sm sm;
	unsigned char *s = *p;
	int len = *plen;
	int c = -2;

	utf8_init(&sm);

	while (len) {
		--len;
		c = utf8_decode(&sm,*s++);
		if (c >= 0)
			break;
	}

	*plen = len;
	*p = s;

	return c;
}

/* Initialize locale for JOE */

#ifdef USE_CODEPAGE
extern unsigned int cygwin32_get_cp(void);
#endif

struct charmap *locale_map;
			/* Character map of terminal */
struct charmap *utf8_map;
			/* Handy character map for UTF-8 */

void
joe_locale(void)
{
	unsigned char *s;

	s=(unsigned char *)getenv("JOECHARMAP");
	locale_map = find_charmap(s);
#if !defined(USE_LOCALE)
	if (!locale_map) {
		s=(unsigned char *)getenv("LC_ALL");
		if (!s) {
			s=(unsigned char *)getenv("LC_CTYPE");
			if (!s) {
				s=(unsigned char *)getenv("LANG");
			}
		}
#ifdef USE_CODEPAGE
		/* if LC_* are unset, use codepage */
		if (!s) {
			char buf[16];

			joe_snprintf_1(buf, sizeof(buf), "cp%u", cygwin32_get_cp());
			locale_map = find_charmap(buf);
		}
#endif
	}
#endif

#ifdef USE_LOCALE
	if (!locale_map) {
		setlocale(LC_ALL,"");
		locale_map = find_charmap((const void *)nl_langinfo(CODESET));
	}
#else
	if (!locale_map && s) {
		unsigned char *t, *tt;

		if ((t = strrchr(s, '.')) != NULL) {
			if ((tt = strchr(++t, '@@')) != NULL)
				*tt = '\0';
			locale_map = find_charmap(t);
		}
		if (!locale_map)
			locale_map = find_charmap(s);
	}
#endif
	if (!locale_map)
		locale_map = find_charmap(UC "ascii");
	utf8_map = find_charmap(UC "utf-8");

#ifndef TEST
#ifdef defutf8
	fdefault.charmap = utf8_map;
#else
	fdefault.charmap = locale_map;
#endif
	pdefault.charmap = locale_map;
#endif
}

void to_utf8(struct charmap *map,unsigned char *s,int c)
{
	int d = to_uni(map,c);

	if (d==-1)
		utf8_encode(s,'?');
	else
		utf8_encode(s,d);
}

int from_utf8(struct charmap *map,unsigned char *s)
{
	int d = utf8_decode_string(s);
	int c = from_uni(map,d);
	if (c==-1)
		return '?';
	else
		return c;
}
@


1.24
log
@fix (and harmonise!) some Unicode decoding issues during yak shaving
@
text
@d13 1
a13 1
__RCSID("$MirOS: contrib/code/jupp/utf8.c,v 1.22 2017/12/06 21:17:04 tg Exp $");
d66 1
a66 1
 * c is unicode character.
@


1.23
log
@another leaked string
@
text
@d5 1
a5 1
 *		(c) 2004, 2006, 2011, 2013, 2014, 2017 Thorsten Glaser
d67 1
a67 1
 * buf is 7 byte buffer- utf-8 coded character is written to this followed by a 0 termination.
d118 3
a120 3
 *                   -1: character accepted, nothing decoded yet.
 *                   -2: incomplete sequence
 *                   -3: no sequence started, but character is between 128 - 191, 254 or 255
d123 2
a124 1
int utf8_decode(struct utf8_sm *utf8_sm,unsigned char c)
d127 11
a137 9
		if ((c&0xC0)==0x80) {
			utf8_sm->buf[utf8_sm->ptr++] = c;
			--utf8_sm->state;
			utf8_sm->accu = ((utf8_sm->accu<<6)|(c&0x3F));
			if(!utf8_sm->state)
				return utf8_sm->accu;
		} else {
			utf8_sm->state = 0;
			return -2;
d139 11
a149 4
	} else if ((c&0xE0)==0xC0) {
		/* 192 - 223 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
d151 2
a152 5
		utf8_sm->accu = (c&0x1F);
	} else if ((c&0xF0)==0xE0) {
		/* 224 - 239 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
d154 2
a155 5
		utf8_sm->accu = (c&0x0F);
	} else if ((c&0xF8)==0xF0) {
		/* 240 - 247 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
d157 2
a158 5
		utf8_sm->accu = (c&0x07);
	} else if ((c&0xFC)==0xF8) {
		/* 248 - 251 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
d160 2
a161 5
		utf8_sm->accu = (c&0x03);
	} else if ((c&0xFE)==0xFC) {
		/* 252 - 253 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
d163 14
a176 14
		utf8_sm->accu = (c&0x01);
	} else if ((c&0x80)==0x00) {
		/* 0 - 127 */
		utf8_sm->buf[0] = c;
		utf8_sm->ptr = 1;
		utf8_sm->state = 0;
		return c;
	} else {
		/* 128 - 191, 254, 255 */
		utf8_sm->ptr = 0;
		utf8_sm->state = 0;
		return -3;
	}
	return -1;
d179 1
a179 1
/* Initialize state machine */
@


1.22
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d13 1
a13 1
__RCSID("$MirOS: contrib/code/jupp/utf8.c,v 1.21 2017/12/02 04:32:43 tg Exp $");
d268 1
a268 3
		s = (unsigned char *)strdup(nl_langinfo(CODESET));

		locale_map = find_charmap(s);
d284 2
a285 2
		locale_map = find_charmap(US "ascii");
	utf8_map = find_charmap(US "utf-8");
@


1.21
log
@some fallout of the includes changes, some more reduction
@
text
@d13 1
a13 1
__RCSID("$MirOS: contrib/code/jupp/utf8.c,v 1.20 2017/12/02 02:07:37 tg Exp $");
d15 1
a17 4
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

@


1.20
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d13 1
a13 1
__RCSID("$MirOS$");
a64 1
#include "utf8.h"
@


1.19
log
@consolidate anything using <windows.h> into one .c file existing precisely for that purpose
@
text
@a0 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.17 2017/01/10 23:20:48 tg Exp $ */
d13 2
a14 1
#include <stdio.h>
@


1.18
log
@fix compile (oops)
@
text
@d233 1
a233 1
static unsigned int cygwin32_get_cp(void);
a321 14

#ifdef USE_CODEPAGE
#include <windows.h>

/*
 * Mirror get_cp() in winsup/cygwin/miscfuncs.cc as used by
 * dev_console::str_to_con() in winsup/cygwin/fhandler_console.cc
 */
static unsigned int
cygwin32_get_cp(void)
{
	return (AreFileApisANSI() ? GetACP() : GetOEMCP());
}
#endif
@


1.17
log
@update (c) years
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.11 2014/06/26 18:15:17 tg Exp $ */
d266 1
@


1.16
log
@add JOECHARMAP override; drop the cygwin32 "C" codepage override; document
@
text
@d6 1
a6 1
 *		(c) 2004, 2006 Thorsten Glaser
@


1.15
log
@on old cygwin32, use the (cygwin32-internal) codepage as charmap
@
text
@a235 2
unsigned char *codeset;	/* Codeset of terminal */

a240 7
/*
 * XXX this is stupid, the console encoding should be a
 * XXX parameter, not forcibly determined by the current
 * XXX locale, since we use JOE locales ipv POSIX locales
 * XXX and charmaps anyway so the sets of supported ones
 * XXX do not completely match
 */
d244 4
d249 2
a250 5
	unsigned char *s, *t;

	s=(unsigned char *)getenv("LC_ALL");
	if (!s) {
		s=(unsigned char *)getenv("LC_CTYPE");
d252 4
a255 1
			s=(unsigned char *)getenv("LANG");
a256 2
	}
	locale_map = NULL;
d258 3
a260 3
	/* if LC_* are unset or just "C" allow for codepage, XXX see above */
	if (!s || (joe_map_up(s[0]) == 'C' && !s[1])) {
		char buf[16];
d262 3
a264 3
		joe_snprintf_1(buf, sizeof(buf), "cp%u", cygwin32_get_cp());
		locale_map = find_charmap(buf);
	}
d269 3
a271 2
	setlocale(LC_ALL,"");
	codeset = (unsigned char *)strdup(nl_langinfo(CODESET));
d273 2
a274 1
	locale_map = find_charmap(codeset);
d276 3
a278 1
	if (locale_map == NULL && s != NULL) {
a279 2
			unsigned char *tt;

d284 1
a284 1
		if (locale_map == NULL)
@


1.14
log
@disable locale support for old cygwin32
@
text
@d29 1
d38 1
d60 4
d232 4
d243 7
a255 1

d263 10
d281 1
a281 3
	if (s == NULL) {
		locale_map = NULL;
	} else {
d326 14
@


1.13
log
@remove the trailing @@modifier from the locale before testing it
@
text
@d21 4
d34 6
@


1.12
log
@move a few includes so that _FILE_OFFSET_BITS is always correctly defined,
so we actually do build with LFS on ILP32 GNU/Linux; discovered by lintian
@
text
@d248 7
a254 2
		if ((t = strrchr(s, '.')) != NULL)
			locale_map = find_charmap(++t);
@


1.11
log
@make everything with a main() compile, too
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.10 2013/11/07 21:50:36 tg Exp $ */
a9 1
#include <stdio.h>
d14 1
@


1.10
log
@Update “visible spaces” while typing and fix it for nōn-UTF8 files; also rid some of the assumptions that all charmaps have tab, space at same positions
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.9 2012/06/08 16:55:29 tg Exp $ */
d258 1
d265 1
@


1.9
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.8 2011/07/02 22:50:52 tg Exp $ */
d220 2
d256 1
d259 1
a259 1
	fdefault.charmap = find_charmap(US "utf-8");
@


1.8
log
@autoconf for <langinfo.h>, nl_langinfo() and ifdef for CODESET
to determine whether we are doing posux locales
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.7 2010/04/08 17:54:19 tg Exp $ */
a217 5
#ifdef junk
unsigned char *non_utf8_codeset;
			/* Codeset of local language non-UTF-8 */
#endif

d224 1
a224 1
#if !defined(USE_LOCALE) || defined(junk)
a237 13
#ifdef junk
	if (s)
		s=(unsigned char *)strdup((char *)s);
	else
		s=US "ascii";

	if (t=(unsigned char *)strrchr((char *)s,'.'))
		*t = 0;

	setlocale(LC_ALL,(char *)s);
	non_utf8_codeset = (unsigned char *)strdup(nl_langinfo(CODESET));
#endif

a260 14

/*
	printf("Character set is %s\n",locale_map->name);

	for(int x=0;x!=128;++x)
		printf("%x	space=%d blank=%d alpha=%d alnum=%d punct=%d print=%d\n",
		       x,joe_isspace(locale_map,x), joe_isblank(locale_map,x), joe_isalpha_(locale_map,x),
		       joe_isalnum_(locale_map,x), joe_ispunct(locale_map,x), joe_isprint(locale_map,x));
*/

#ifdef junk
	to_utf = iconv_open("UTF-8", (char *)non_utf8_codeset);
	from_utf = iconv_open((char *)non_utf8_codeset, "UTF-8");
#endif
a270 18
#ifdef junk
	/* Iconv() way */
	unsigned char buf[10];
	unsigned char *ibufp = buf;
	unsigned char *obufp = s;
	int ibuf_sz=1;
	int obuf_sz= 10;
	buf[0]=c;
	buf[1]=0;

	if (to_utf==(iconv_t)-1 ||
	    iconv(to_utf,(char **)&ibufp,&ibuf_sz,(char **)&obufp,&obuf_sz)==(size_t)-1) {
		s[0]='?';
		s[1]=0;
	} else {
		*obufp = 0;
	}
#endif
a280 16

#ifdef junk
	/* Iconv() way */
	int ibuf_sz=strlen((char *)s);
	unsigned char *ibufp=s;
	int obuf_sz=10;
	unsigned char obuf[10];
	unsigned char *obufp = obuf;


	if (from_utf==(iconv_t)-1 ||
	    iconv(from_utf,(char **)&ibufp,&ibuf_sz,(char **)&obufp,&obuf_sz)==((size_t)-1))
		return '?';
	else
		return obuf[0];
#endif
@


1.7
log
@pass __CRAZY=Yes except -Wno-missing-field-initializers -Wno-cast-qual
 -Wno-strict-prototypes -Wno-missing-prototypes -Wno-missing-declarations
 -Wno-unused
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/utf8.c,v 1.6 2008/05/13 13:08:30 tg Exp $ */
d25 5
d32 10
a41 1
#undef HAVE_SETLOCALE
d44 2
a45 3
#if defined(HAVE_LOCALE_H) && defined(HAVE_SETLOCALE)
#	include <locale.h>
#       include <langinfo.h>
d229 1
a229 1
#if !defined(HAVE_SETLOCALE) || defined(junk)
d242 1
a242 1
#ifdef HAVE_SETLOCALE
@


1.6
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d213 2
a214 1
void joe_locale()
@


1.5
log
@experimental: in jupp, too, set the default charset for files to utf-8,
regardless of current locale (MirOS live CD only, not the port)

ed and vi use a simple pass-through, but all you get on MirOS anyway
are ascii ("C") and utf-8; other encodings may not work well any more
@
text
@d1 1
@


1.4
log
@use our I18N framework if present; add ISO_646.* = ascii alias
@
text
@d258 3
d262 1
@


1.3
log
@* bump version
* add comment about locale support in recent obsd
@
text
@d5 1
a5 1
 *		(c) 2004 Thorsten Glaser
d20 6
a25 5
#ifdef __OpenBSD__
/*
 * OpenBSD, MirOS and ekkoBSD do not have real locale support
 * in older versions; even for recent versions, this is enough.
 */
d204 2
a205 1
unsigned char *non_utf8_codeset = US "ascii";
d207 1
d214 1
d225 1
d228 1
d239 1
a257 16
	/* For files, the default map should be:
	 * > the result of nl_langinfo
	 *   -> on systems which have it only
	 * > ascii
	 *   -> for technical reasons
	 * > iso-8859-1
	 *   -> to unify. Well, cp437. Well, windows-1252. You see?
	 * > utf-8
	 *   -> because that is what the user expects.
	 *
	 * We are going with the dumb way and are setting the
	 * default file encoding to utf-8 as well if we are run
	 * in an uxterm on a non-locale-aware operating system
	 * such as MirOS; users should be careful as to avoid
	 * sending utf-8 in accident instead of iso-8859-1.
	 */
d264 1
a264 1
	for(x=0;x!=128;++x)
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d21 4
a24 1
/* OpenBSD, MirOS and ekkoBSD do not have real locale support */
@


1.1
log
@Initial revision
@
text
@d5 1
d20 5
d165 1
a165 1
	int c;
d200 1
a200 1
unsigned char *non_utf8_codeset;
a207 1
#ifdef HAVE_SETLOCALE
a209 1
	int x;
d219 1
d235 10
d248 16
a279 6

#else
	locale_map = find_charmap("ascii");
	fdefault.charmap = locale_map;
	pdefault.charmap = locale_map;
#endif
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
