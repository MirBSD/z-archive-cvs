head	1.31;
access;
symbols
	joe-3_1jupp38:1.31
	joe-3_1jupp37:1.31
	joe-3_1jupp36:1.31
	joe-3_1jupp35:1.31
	joe-3_1jupp34:1.31
	joe-3_1jupp33:1.31
	joe-3_1jupp32:1.25
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.12
	joe-3_1jupp30:1.11
	joe-3_1jupp29:1.11
	joe-3_1jupp28:1.11
	joe-3_1jupp27:1.10
	joe-3_1jupp26:1.10
	joe-3_1jupp25:1.10
	joe-3_1jupp24:1.8
	joe-3_1jupp23:1.8
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.4
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.31
date	2018.01.18.22.00.31;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A611907553EFC2B;

1.30
date	2018.01.18.21.59.12;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A6118BD6F94E8BD;

1.29
date	2018.01.06.00.28.34;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A50184621FA8455;

1.28
date	2017.12.20.23.40.35;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A3AF50817509B07;

1.27
date	2017.12.20.23.35.52;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A3AF3EB3795F6B5;

1.26
date	2017.12.20.21.32.34;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A3AD7065A54CFBC;

1.25
date	2017.12.08.03.24.16;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A2A05EB07C8D953;

1.24
date	2017.12.08.02.28.07;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A29F8C708B176AB;

1.23
date	2017.12.08.02.00.42;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A29F2506E789D2B;

1.22
date	2017.12.08.01.43.17;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A29EE466EF937A6;

1.21
date	2017.12.08.01.42.03;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A29EE00599384E3;

1.20
date	2017.12.08.01.29.59;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A29EB2C65E8B9EA;

1.19
date	2017.12.07.02.10.18;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A28A3145E1FF911;

1.18
date	2017.12.06.23.58.38;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A2884424C3F3AD8;

1.17
date	2017.12.06.23.02.07;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A2876FC4FFE7EF5;

1.16
date	2017.12.06.21.41.04;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A28640547F64250;

1.15
date	2017.12.06.21.17.02;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A285E5918D423C7;

1.14
date	2017.12.02.04.32.42;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005A222CF2122034D9;

1.13
date	2017.12.02.02.07.35;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005A220AD65C90E687;

1.12
date	2017.08.08.21.39.28;	author tg;	state Exp;
branches;
next	1.11;
commitid	100598A2FA50A3266A7;

1.11
date	2014.10.23.16.10.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	100544928830E6B4DD2;

1.10
date	2013.08.19.22.48.33;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005212A0D860585CD4;

1.9
date	2013.08.19.22.14.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	100521298EC789BDEA7;

1.8
date	2012.12.20.21.39.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050D385A71C0FBD17;

1.7
date	2012.12.19.22.06.29;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050D23A61232ADE06;

1.6
date	2012.12.19.21.30.13;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050D231F51BF4E377;

1.5
date	2012.12.19.21.15.54;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050D22EA21F752A4C;

1.4
date	2010.04.08.15.31.05;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBDF6C54CC9A0DB;

1.3
date	2008.05.13.13.08.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.24;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@clean up part of this disgusting code, it looks like French FusionForge!
@
text
@/*
 * 	User file operations
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#define EXTERN_UFILE_C
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.30 2018/01/18 21:59:12 tg Exp $");

#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#ifdef UTIME
#include <utime.h>
#define HAVEUTIME 1
#else
#ifdef SYSUTIME
#include <sys/utime.h>
#define HAVEUTIME 1
#endif
#endif

#include "b.h"
#include "bw.h"
#include "macro.h"
#include "main.h"
#include "menu.h"
#include "path.h"
#include "pw.h"
#include "qw.h"
#include "scrn.h"
#include "tab.h"
#include "tty.h"
#include "tw.h"
#include "ublock.h"
#include "uerror.h"
#include "ufile.h"
#include "ushell.h"
#include "utils.h"
#include "va.h"
#include "vs.h"
#include "charmap.h"
#include "w.h"

extern int orphan;
unsigned char *backpath = NULL;	/* Place to store backup files */
static B *filehist = NULL;	/* History of file names */
int nobackups = 0;
int exask = 0;

/* Ending message generator */
/**** message which is shown after closing joe (CTRL+x; CTRL+k) *****/
void genexmsg(BW *bw, int saved, unsigned char *name)
{
	const unsigned char *s;

	if (bw->b->name && bw->b->name[0]) {
		s = bw->b->name;
	} else {
		s = UC "(Unnamed)";
	}

	if (name) {
		if (saved) {
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", name);
		} else {
			joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", name);
		}
	} else if (bw->b->changed && bw->b->count == 1) {
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not saved", s);
	} else if (saved) {
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s saved", s);
	} else {
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "File %s not changed so no update needed", s);
	}
	msgnw(bw->parent, msgbuf);

	if (exmsg)
		vsrm(exmsg);

	if (bw->b->changed && bw->b->count == 1) {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" not saved."));
	} else if (saved) {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" saved."));
	} else {
		exmsg = vsncpy(NULL, 0, sc("File "));
		exmsg = vsncpy(sv(exmsg), sz(s));
		exmsg = vsncpy(sv(exmsg), sc(" not changed so no update needed."));
	}
}

/* For ^X ^C */
static void
genexmsgmulti(BW *bw, int saved, int skipped)
{
	if (saved)
		if (skipped)
			joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "Some files have not been saved.");
		else
			joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "All modified files have been saved.");
	else
		joe_snprintf_0((char *)msgbuf, JOE_MSGBUFSIZE, "No modified files, so no updates needed.");

	msgnw(bw->parent, msgbuf);

	exmsg = vsncpy(NULL,0,sz(msgbuf));
}

/* Write highlighted block to a file */

int ublksave(BW *bw)
{
	if (markb && markk && markb->b == markk->b && (markk->byte - markb->byte) > 0 && (!square || piscol(markk) > piscol(markb))) {
		if (wmkpw(bw->parent, UC "Name of file to write (^C to abort): ", &filehist, dowrite, UC "Names", NULL, cmplt, NULL, NULL, locale_map)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		return usave(bw);
	}
}

/* Shell escape */

int ushell(BW *bw)
{
	nescape(bw->parent->t->t);
	ttsusp();
	nreturn(bw->parent->t->t);
	return 0;
}

/* Copy a file */

static int
cp(const unsigned char *from, int g, const unsigned char *tmpfn, const unsigned char *to)
{
	int f, amnt;
	struct stat sbuf;

#ifdef HAVEUTIME
#ifdef NeXT
	time_t utbuf[2];
#else
	struct utimbuf utbuf;
#endif
#endif

	f = open((const char *)from, O_RDONLY);
	if (f < 0) {
		return -1;
	}
	if (fstat(f, &sbuf) < 0) {
		close(f);
		return -1;
	}
	if (fchmod(g, sbuf.st_mode & 0777)) {
		close(f);
		return (-1);
	}
	while ((amnt = read(f, stdbuf, stdsiz)) > 0) {
		if (amnt != joe_write(g, stdbuf, amnt)) {
			break;
		}
	}
	close(f);
	if (amnt) {
		return -1;
	}

#ifdef HAVE_FSYNC
	if (fsync(g))
		return (-1);
#endif

	if (close(g))
		return (-1);

	if (tmpfn && rename(tmpfn, to)) {
		return (-1);
	}
	/*
	 * Do not return !0 from here on.
	 * Below are only operations that run when the copy
	 * process finished successfully.
	 */

#ifdef HAVEUTIME
#ifdef NeXT
	utbuf[0] = (time_t) sbuf.st_atime;
	utbuf[1] = (time_t) sbuf.st_mtime;
#else
	utbuf.actime = sbuf.st_atime;
	utbuf.modtime = sbuf.st_mtime;
#endif
	utime(to, &utbuf);
#endif

	copy_security_context(from, to);

	return 0;
}

/* Make backup file if it needs to be made
 * Returns 0 if backup file was made or didn't need to be made
 * Returns 1 for error
 */

static int
backup(BW *bw)
{
	unsigned char tmp[1024 + 12];
	unsigned char name[1024];
	const unsigned char *simple_backup_suffix;
	unsigned char *tmpfn;
	int fd;
	int rv;

	if (bw->b->backup || nobackups || !(bw->b->name) || !(bw->b->name[0]))
		return (0);

	/* Create backup file name */
	simple_backup_suffix = (unsigned char *)getenv("SIMPLE_BACKUP_SUFFIX");

	if (simple_backup_suffix == NULL) {
		simple_backup_suffix = UC "~";
	}
	if (backpath) {
		joe_snprintf_3((char *)name, sizeof(name), "%s/%s%s", backpath, namepart(tmp, bw->b->name), simple_backup_suffix);
	} else {
		joe_snprintf_2((char *)name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
	}

	/* Securely generate a backup file temporary file */
	*tmp = '\0';
	if (*name != '/') {
		/* relative pathname */
		if (!getcwd((char *)tmp, sizeof(tmp)) ||
		    strlcat((char *)tmp, "/", sizeof(tmp)) >= sizeof(tmp))
			return (1);
	}
	if (strlcat((char *)tmp, (char *)name, sizeof(tmp)) >= sizeof(tmp))
		return (1);
	*(dirprt_ptr(tmp)) = '\0';
	if ((tmpfn = mktmp(tmp, &fd)) == NULL)
		return (1);

	/* Attempt to delete backup file first */
	unlink((char *)name);

	/* Copy original file to backup file securely */
	if (cp(bw->b->name, fd, tmpfn, name)) {
		close(fd);
		unlink((char *)tmpfn);
		rv = 1;
	} else {
		bw->b->backup = 1;
		rv = 0;
	}

	vsrm(tmpfn);
	return (rv);
}

/* Write file */

/* Continuation structure */

struct savereq {
	int (*callback)(BW *, struct savereq *, int, int *);
	unsigned char *name;
	B *first;
	int not_saved;	/* Set if a modified file was not saved */
	int rename;	/* Set if we're renaming the file during save */
};

static struct savereq *
mksavereq(int (*callback)(BW *, struct savereq *, int, int *),
    unsigned char *name, B *first, int dorename)
{
	struct savereq *req = malloc(sizeof(struct savereq));

	req->callback = callback;
	req->name = name;
	req->first = first;
	req->not_saved = 0;
	req->rename = dorename;
	return req;
}

static void rmsavereq(struct savereq *req)
{
	vsrm(req->name);
	free(req);
}

static int saver(BW *bw, int c, struct savereq *req, int *notify)
{
	int fl;
	if ((c | 0x20) == 'n') {
		msgnw(bw->parent, UC "Couldn't make backup file... file not saved");
		if (req->callback) {
			return req->callback(bw, req, -1, notify);
		} else {
			if (notify) {
				*notify = 1;
			}
			rmsavereq(req);
			return -1;
		}
	}
	if ((c | 0x20) != 'y') {
		if (mkqw(bw->parent, sc("Could not make backup file.  Save anyway (y,n,^C)? "), saver, NULL, req, notify)) {
			return 0;
		} else {
			rmsavereq(req);
			if (notify)
				*notify = 1;
			return -1;
		}
	}
	if (bw->b->er == -1 && bw->o.msnew) {
		exemac(bw->o.msnew);
		bw->b->er = -3;
	}
	if (bw->b->er == 0 && bw->o.msold) {
		exemac(bw->o.msold);
	}
	if ((fl = bsave(bw->b->bof, req->name, bw->b->eof->byte, 1)) != 0) {
		msgnw(bw->parent, msgs[-fl]);
		if (req->callback) {
			return req->callback(bw, req, -1, notify);
		} else {
			rmsavereq(req);
			if (notify) {
				*notify = 1;
			}
			return -1;
		}
	} else {
		if (req->rename) {
			free(bw->b->name);
			bw->b->name = 0;
		}
		if (!bw->b->name)
			bw->b->name = joesep((unsigned char *)strdup((char *)req->name));
		if (!strcmp(bw->b->name, req->name)) {
			bw->b->changed = 0;
			saverr(bw->b->name);
		}
		{
			/* Last UNDOREC which wasn't modified will be changed
			 * to modified. And because this block is
			 * executed after each 'save', there can't be more
			 * than one record which is not modified
			 *		24 Apr 2001, Marx
			 */
			UNDO *u = bw->b->undo;
			UNDOREC *rec, *rec_start;

			rec = rec_start = &u->recs;

			do {
				rec = rec->link.prev;
			} while (rec != rec_start && rec->changed);
			if(rec->changed == 0)
				rec->changed = 1;

		}
		genexmsg(bw, 1, req->name);
		if (req->callback) {
			return req->callback(bw, req, 0, notify);
		} else {
			rmsavereq(req);
			return 0;
		}
	}
}

static int
dosave(BW *bw, struct savereq *req, int *notify)
{
	return (saver(bw, backup(bw) ? 0 : 'y', req, notify));
}

static int dosave2(BW *bw, int c, struct savereq *req, int *notify)
{
	if ((c | 0x20) == 'y') {
		return dosave(bw, req, notify);
	} else if ((c | 0x20) == 'n') {
		if (notify) {
			*notify = 1;
		}
		genexmsg(bw, 0, req->name);
		rmsavereq(req);
		return -1;
	} else if (mkqw(bw->parent, sc("File exists.  Overwrite (y,n,^C)? "), dosave2, NULL, req, notify)) {
		return 0;
	} else {
		/* Should be in abort function */
		rmsavereq(req);
		return -1;
	}
}

static int dosave2a(BW *bw, int c, struct savereq *req, int *notify)
{
	if ((c | 0x20) == 'y') {
		return dosave(bw, req, notify);
	} else if ((c | 0x20) == 'n') {
		if (notify) {
			*notify = 1;
		}
		genexmsg(bw, 0, req->name);
		rmsavereq(req);
		return -1;
	} else if (mkqw(bw->parent, sc("File on disk is newer.  Overwrite (y,n,^C)? "), dosave2a, NULL, req, notify)) {
		return 0;
	} else {
		rmsavereq(req);
		return -1;
	}
}

/* Checks if file exists. */

static int dosave1(BW *bw, unsigned char *s, struct savereq *req, int *notify)
{
	int f;

	if (req->name)
		vsrm(req->name);
	req->name = s;

	if (s[0] != '!' && !(s[0] == '>' && s[1] == '>')) {
		/* It's a normal file: not a pipe or append */
		if (!bw->b->name || strcmp(s, bw->b->name)) {
			/* Newly named file or name is different than buffer */
			f = open((char *)s, O_RDONLY);
			if (f != -1) {
				close(f);
				return dosave2(bw, 0, req, notify);
			}
		}
		else {
			/* We're saving a newer version of the same file */
			struct stat sbuf;
			if (!stat((char *)s,&sbuf)) {
				if (sbuf.st_mtime>bw->b->mod_time) {
					return dosave2a(bw, 0, req, notify);
				}
			}
		}
	}

	return dosave(bw, req, notify);
}

/* User command: ^K D */

int usave(BW *bw)
{
	BW *pbw;

	pbw = wmkpw(bw->parent, UC "Name of file to save (^C to abort): ", &filehist, dosave1, UC "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL,0), NULL, locale_map);

	if (pbw && bw->b->name) {
		binss(pbw->cursor, bw->b->name);
		pset(pbw->cursor, pbw->b->eof);
		pbw->cursor->xcol = piscol(pbw->cursor);
	}
	if (pbw) {
		return 0;
	} else {
		return -1;
	}
}

/* Load file to edit */

static int
doedit1(BW *bw, int c, unsigned char *s, int *notify)
{
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;

	switch (c | 0x20) {
	case 'y':
		/* Reload from file */
		c = 1;
		break;
	case 'n':
		/* Edit already loaded buffer */
		c = 0;
		break;
	default:
		/* Ask what todo */
		/* FIXME: need abort handler to prevent leak */
		if (mkqw(bw->parent, sc("Load original file from disk (y,n,^C)? "), doedit1, NULL, s, notify))
			return (0);
		vsrm(s);
		return (-1);
	}

	if (notify)
		*notify = 1;

	b = c ? bfind_reload(s) : bfind(s);
	er = error;
	c = c ? (bw->b->count >= 1) : (bw->b->count == 1);

	if (c && (bw->b->changed || bw->b->name)) {
		if (orphan) {
			orphit(bw);
		} else {
			if (uduptw(bw)) {
				brm(b);
				vsrm(s);
				return (-1);
			}
			bw = maint->curwin->object.bw;
		}
	}
	if (er) {
		msgnwt(bw->parent, msgs[-er]);
		if (er != -1)
			ret = -1;
	}
	object = bw->object;
	w = bw->parent;
	bwrm(bw);
	w->object.bw = bw = bwmk(w, b, 0);
	wredraw(bw->parent);
	bw->object = object;
	vsrm(s);
	if (er == -1 && bw->o.mnew)
		exemac(bw->o.mnew);
	if (er == 0 && bw->o.mold)
		exemac(bw->o.mold);
	return (ret);
}

static int
doedit(BW *bw, unsigned char *s, void *obj, int *notify)
{
	B *b;

	b = bcheck_loaded(s);

	if (b) {
		if (b->changed)
			/* Modified buffer exists, so ask */
			return doedit1(bw, 0, s, notify);
		else
			/* Buffer not modified- just use it as is */
			return doedit1(bw, 'n', s, notify);
	} else
		/* File not in buffer: don't ask */
		return doedit1(bw, 'y', s, notify);
}

int okrepl(BW *bw)
{
	if (bw->b->count == 1 && bw->b->changed) {
		msgnw(bw->parent, UC "Can't replace modified file");
		return -1;
	} else {
		return 0;
	}
}

int uedit(BW *bw)
{
	if (wmkpw(bw->parent, UC "Name of file to edit (^C to abort): ", &filehist, doedit, UC "Names", NULL, cmplt, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

int doswitch(BW *bw, unsigned char *s, void *obj, int *notify)
{
	/* Try buffer, then file */
	return doedit1(bw, 'n', s, notify);
}

int uswitch(BW *bw)
{
	if (wmkpw(bw->parent, UC "Name of buffer to edit (^C to abort): ", &filehist, doswitch, UC "Names", NULL, cmplt, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

static int
doscratch(BW *bw, unsigned char *s, void *obj, int *notify)
{
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;

	if (notify) {
		*notify = 1;
	}

	b = bfind_scratch(s);
	er = error;
	vsrm(s);
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
		if (orphan) {
			orphit(bw);
		} else {
			if (uduptw(bw)) {
				brm(b);
				return -1;
			}
			bw = maint->curwin->object.bw;
		}
	}
	if (er && er != -1) {
		msgnwt(bw->parent, msgs[-er]);
		ret = -1;
	}
	object = bw->object;
	w = bw->parent;
	bwrm(bw);
	w->object.bw = bw = bwmk(w, b, 0);
	wredraw(bw->parent);
	bw->object = object;
	if (er == -1 && bw->o.mnew) {
		exemac(bw->o.mnew);
	}
	if (er == 0 && bw->o.mold) {
		exemac(bw->o.mold);
	}
	return ret;
}

int uscratch(BW *bw)
{
	if (wmkpw(bw->parent, UC "Name of scratch buffer to edit (^C to abort): ", &filehist, doscratch, UC "Names", NULL, cmplt, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

/* Load file into buffer: can result in an orphaned buffer */

static int dorepl(BW *bw, unsigned char *s, void *obj, int *notify)
{
	void *object = bw->object;
	int ret = 0;
	int er;
	W *w = bw->parent;
	B *b;

	if (notify) {
		*notify = 1;
	}
	b = bfind(s);
	er = error;
	if (error) {
		msgnwt(bw->parent, msgs[-error]);
		if (error != -1) {
			ret = -1;
		}
	}
	if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
		orphit(bw);
	}
	bwrm(bw);
	w->object.bw = bw = bwmk(w, b, 0);
	wredraw(bw->parent);
	bw->object = object;
	vsrm(s);
	if (er == -1 && bw->o.mnew) {
		exemac(bw->o.mnew);
	}
	if (er == 0 && bw->o.mold) {
		exemac(bw->o.mold);
	}
	return ret;
}

/* Switch to next buffer in window */

int unbuf(BW *bw)
{
	void *object = bw->object;
	W *w = bw->parent;
	B *b;
	b = bnext();
	if (b == bw->b) {
		b = bnext();
	}
	if (b == bw->b) {
		return 0;
		/* return -1; this helps with querysave (no error when only one buffer) */
	}
	if (!b->orphan) {
		++b->count;
	} else {
		b->orphan = 0;
	}
	if (bw->b->count == 1) {
		orphit(bw);
	}
	bwrm(bw);
	w->object.bw = bw = bwmk(w, b, 0);
	wredraw(bw->parent);
	bw->object = object;
	return 0;
}

int upbuf(BW *bw)
{
	void *object = bw->object;
	W *w = bw->parent;
	B *b;
	b = bprev();
	if (b == bw->b) {
		b = bprev();
	}
	if (b == bw->b) {
		return 0;
		/* return -1; */
	}
	if (!b->orphan) {
		++b->count;
	} else {
		b->orphan = 0;
	}
	if (bw->b->count == 1) {
		orphit(bw);
	}
	bwrm(bw);
	w->object.bw = bw = bwmk(w, b, 0);
	wredraw(bw->parent);
	bw->object = object;
	return 0;
}

int uinsf(BW *bw)
{
	if (wmkpw(bw->parent, UC "Name of file to insert (^C to abort): ", &filehist, doinsf, UC "Names", NULL, cmplt, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

/* Save and exit */

static int exdone(BW *bw, struct savereq *req,int flg,int *notify)
{
	if (notify)
		*notify = 1;
	rmsavereq(req);
	if (flg) {
		return -1;
	} else {
		bw->b->changed = 0;
		saverr(bw->b->name);
		return uabort1(bw, -1);
	}
}

int uexsve(BW *bw)
{
	if (!bw->b->changed || bw->b->scratch) {
		/* It didn't change or it's just a scratch buffer: don't save */
		uabort(bw, -1);
		return 0;
	} else if (bw->b->name && !exask) {
		/* It changed, it's not a scratch buffer and it's named */
		return dosave1(bw, vsncpy(NULL, 0, sz(bw->b->name)), mksavereq(exdone,NULL,NULL,0), NULL);
	} else {
		BW *pbw = wmkpw(bw->parent, UC "Name of file to save (^C to abort): ", &filehist, dosave1, UC "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL,1), NULL, locale_map);

		if (pbw && bw->b->name) {
			binss(pbw->cursor, bw->b->name);
			pset(pbw->cursor, pbw->b->eof);
			pbw->cursor->xcol = piscol(pbw->cursor);
		}
		if (pbw) {
			return 0;
		} else {
			return -1;
		}
	}
}

/* If buffer is modified, prompt for saving: if user types 'n', uabort(), otherwise just return. */
/* If buffer is not modified, just return. */

static int nask(BW *bw, int c, void *object, int *notify)
{
	if ((c | 0x20) == 'y') {
		/* uexsve macro should be here... */
		if(notify)
			*notify = 1;
		return 0;
	} else if ((c | 0x20) == 'n') {
		if(notify)
			*notify = -1;
		genexmsg(bw, 0, NULL);
		abortit(bw);
		return -1;
	} else if (bw->b->count == 1 && bw->b->changed && !bw->b->scratch) {
		if (mkqw(bw->parent, sc("Save changes to this file (y,n,^C)? "), nask, NULL, object, notify)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		if (notify) {
			*notify = 1;
		}
		return 0;
	}
}

int uask(BW *bw)
{
	return nask(bw, 0, NULL, NULL);
}

/* Kill a buffer: any windows which have it get their buffer replaced with a
 * a scratch buffer */

static int dolose(BW *bw, int c, void *object, int *notify)
{
	W *w;
	B *b, *new_b;
	int cnt;

	if (notify) {
		*notify = 1;
	}
	if ((c | 0x20) != 'y') {
		return -1;
	}

	b=bw->b;
	cnt = b->count;
	b->count = 1;
	genexmsg(bw, 0, NULL);
	b->count = cnt;

	if ((w = maint->topwin) != NULL) {
		do {
			if ((w->watom->what & TYPETW) && w->object.bw->b == b) {
				if ((new_b = borphan()) != NULL) {
					BW *bw2 = w->object.bw;
					void *object_ = bw2->object;
					/* FIXME: Shouldn't we wabort() and wcreate here to kill
					   any prompt windows? */

					bwrm(bw2);
					w->object.bw = bw2 = bwmk(w, new_b, 0);
					wredraw(w);
					bw2->object = object_;
				} else {
					BW *bw2 = w->object.bw;
					object = bw2->object;
					bwrm(bw2);
					w->object.bw = bw2 = bwmk(w, bfind(UC ""), 0);
					wredraw(w);
					bw2->object = object;
					if (bw2->o.mnew)
						exemac(bw2->o.mnew);
				}
			}
		w = w->link.next;
		} while (w != maint->topwin);
	}
	return 0;
}

int ulose(BW *bw)
{
	msgnw(bw->parent, NULL);
	if (bw->b->count==1 && bw->b->pid) {
		return ukillpid(bw);
	}
	if (bw->b->changed && !bw->b->scratch) {
		if (mkqw(bw->parent, sc("Lose changes to this file (y,n,^C)? "), dolose, NULL, NULL, NULL)) {
			return 0;
		} else {
			return -1;
		}
	} else {
		return dolose(bw, 'y', NULL, NULL);
	}
}

/* Buffer list */

static int dobuf(MENU *m, int x, unsigned char **s)
{
	unsigned char *name;
	BW *bw = m->parent->win->object.bw;
	int *notify = m->parent->notify;

	m->parent->notify = 0;
	name = vsdup(s[x]);
	wabort(m->parent);
	return dorepl(bw, name, NULL, notify);
}

static int abrtb(MENU *m, int x, unsigned char **s)
{
	varm(s);
	return -1;
}

int ubufed(BW *bw)
{
	unsigned char **s = getbufs();

	vasort(av(s));
	if (mkmenu(bw->parent, s, dobuf, abrtb, NULL, 0, s, NULL))
		return 0;
	else {
		varm(s);
		return -1;
	}
}

/* Query save loop */

static int doquerysave(BW *bw,int c,struct savereq *req,int *notify)
{
	W *w = bw->parent;

	if ((c | 0x20) == 'y') {
		if (bw->b->name && bw->b->name[0])
			return dosave1(bw, vsncpy(NULL,0,sz(bw->b->name)), req, notify);
		else {
			BW *pbw;
			pbw = wmkpw(bw->parent, UC "Name of file to save (^C to abort): ", &filehist, dosave1, UC "Names", NULL, cmplt, req, notify, locale_map);

			if (pbw) {
				return 0;
			} else {
				free(req);
				return -1;
			}
		}
	} else if ((c | 0x20) == 'n') {
		/* Find next buffer to save */
		if (bw->b->changed)
			req->not_saved = 1;
 next:
		if (unbuf(bw)) {
			if (notify)
				*notify = 1;
			rmsavereq(req);
			return -1;
		}
		bw = w->object.bw;
		if (bw->b==req->first) {
			int cached_not_saved = req->not_saved;

			if (notify)
				*notify = 1;
			rmsavereq(req);
			genexmsgmulti(bw,1,cached_not_saved);
			return 0;
		}
		if (!bw->b->changed || bw->b->scratch)
			goto next;

		return doquerysave(bw,0,req,notify);
	} else {
		unsigned char buf[1024];
		joe_snprintf_1(buf,1024,"File %s has been modified.  Save it (y,n,^C)? ",bw->b->name ? bw->b->name : UC "(Unnamed)" );
		if (mkqw(bw->parent, sz(buf), doquerysave, NULL, req, notify)) {
			return 0;
		} else {
			/* Should be in abort function */
			rmsavereq(req);
			return -1;
		}
	}
}

static int query_next(BW *bw, struct savereq *req,int flg,int *notify)
{
	if (flg) {
		if (notify)
			*notify = 1;
		rmsavereq(req);
		return -1;
	} else
		return doquerysave(bw,'N',req,notify);
}

int uquerysave(BW *bw)
{
	W *w = bw->parent;
	B *first = bw->b;

	/* Find a modified buffer */
	do {
		if (bw->b->changed && !bw->b->scratch)
			return doquerysave(bw,0,mksavereq(query_next,NULL,first,0),NULL);
		else if (unbuf(bw))
			return -1;
		bw = w->object.bw;
	} while(bw->b!=first);

	genexmsgmulti(bw,0,0);

	return 0;
}

int ukilljoe(BW *bw)
{
	leave = 1;
	return 0;
}

extern int main_rv;

int
uabendjoe(BW *bw)
{
	main_rv = 1;
	return (ukilljoe(bw));
}

int
usync(BW *bw)
{
#ifdef HAVE_SYNC
	msgnwt(bw->parent, UC "\\i>\\i \\fSynchronising, please wait...\\f \\i<\\i");
	msgout(bw->parent);
	edupd(1);
	sync();
	sleep(1);
	sync();
	msgnwt(bw->parent, UC "\\i>\\i \\bSynchronised buffers to disc.\\b \\i<\\i");
	return (0);
#else
	msgnw(bw->parent, UC "Sorry, compiled without sync(2)");
	return (-1);
#endif
}
@


1.30
log
@make jupp save a bit more safely
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.28 2017/12/20 23:40:35 tg Exp $");
d391 2
a392 1
static int dosave(BW *bw, struct savereq *req, int *notify)
d394 1
a394 5
	if (backup(bw)) {
		return saver(bw, 0, req, notify);
	} else {
		return saver(bw, 'y', req, notify);
	}
@


1.29
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d52 1
a52 1
unsigned char *backpath = NULL;		/* Place to store backup files */
d182 8
a197 1
	close(g);
d1053 18
@


1.28
log
@plug two more memory leaks
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.27 2017/12/20 23:35:52 tg Exp $");
d61 1
a61 1
	unsigned char *s;
d66 1
a66 1
		s = US "(Unnamed)";
d218 2
a219 1
	unsigned char *simple_backup_suffix;
d230 1
a230 1
		simple_backup_suffix = US "~";
d249 1
a249 1
	if ((simple_backup_suffix = mktmp(tmp, &fd)) == NULL)
d256 1
a256 1
	if (cp(bw->b->name, fd, simple_backup_suffix, name)) {
d258 1
a258 1
		unlink((char *)simple_backup_suffix);
d265 1
a265 1
	vsrm(simple_backup_suffix);
d881 1
a881 1
					w->object.bw = bw2 = bwmk(w, bfind(US ""), 0);
d991 1
a991 1
		joe_snprintf_1(buf,1024,"File %s has been modified.  Save it (y,n,^C)? ",bw->b->name ? bw->b->name : US "(Unnamed)" );
@


1.27
log
@fix fd leak (Coverity); constify while here
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.26 2017/12/20 21:32:34 tg Exp $");
d220 1
d258 4
a261 1
		return (1);
d264 2
a265 2
	bw->b->backup = 1;
	return (0);
@


1.26
log
@fix use-after-free, from Coverity Scan
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.25 2017/12/08 03:24:16 tg Exp $");
d147 1
a147 1
cp(unsigned char *from, int g, unsigned char *tmpfn, unsigned char *to)
d160 1
a160 1
	f = open((char *)from, O_RDONLY);
d165 1
@


1.25
log
@more upper/lower tweak (single ones, ranges yet to follow)
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.23 2017/12/08 02:00:42 tg Exp $");
d971 2
d976 1
a976 1
			genexmsgmulti(bw,1,req->not_saved);
@


1.24
log
@label indent; small tweaks while here
@
text
@d298 1
a298 1
	if (c == 'n' || c == 'N') {
d310 1
a310 1
	if (c != 'y' && c != 'Y') {
d389 1
a389 1
	if (c == 'y' || c == 'Y') {
d391 1
a391 1
	} else if (c == 'n' || c == 'N') {
d409 1
a409 1
	if (c == 'y' || c == 'Y') {
d411 1
a411 1
	} else if (c == 'n' || c == 'N') {
d806 1
a806 1
	if (c == 'y' || c == 'Y') {
d811 1
a811 1
	} else if (c == 'n' || c == 'N') {
d848 1
a848 1
	if (c != 'y' && c != 'Y') {
@


1.23
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.22 2017/12/08 01:43:17 tg Exp $");
d943 2
a944 1
	if (c == 'y' || c == 'Y') {
d958 1
a958 1
	} else if (c == 'n' || c == 'N') {
d962 1
a962 1
		next:
d986 1
a986 1
			} else {
@


1.22
log
@last of the prompt window (error case) memory leak plugs for tonight
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.21 2017/12/08 01:42:03 tg Exp $");
d279 2
a280 1
	struct savereq *req = (struct savereq *) joe_malloc(sizeof(struct savereq));
d292 1
a292 1
	joe_free(req);
d340 1
a340 1
			joe_free(bw->b->name);
d953 1
a953 1
				joe_free(req);
@


1.21
log
@refactor to save lots of .text
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.18 2017/12/06 23:58:38 tg Exp $");
d521 1
@


1.20
log
@more memory leak plugs
@
text
@d482 1
a482 1
doedit1(BW *bw,int c,unsigned char *s,int *notify)
d489 3
a491 1
	if (c=='y' || c=='Y') {
d493 14
d508 2
a509 3
		if (notify) {
			*notify = 1;
		}
d511 3
a513 35
		b = bfind_reload(s);
		er = error;
		if (bw->b->count >= 1 && (bw->b->changed || bw->b->name)) {
			if (orphan) {
				orphit(bw);
			} else {
				if (uduptw(bw)) {
					brm(b);
					return -1;
				}
				bw = maint->curwin->object.bw;
			}
		}
		if (er) {
			msgnwt(bw->parent, msgs[-er]);
			if (er != -1) {
				ret = -1;
			}
		}
		object = bw->object;
		w = bw->parent;
		bwrm(bw);
		w->object.bw = bw = bwmk(w, b, 0);
		wredraw(bw->parent);
		bw->object = object;
		vsrm(s);
		if (er == -1 && bw->o.mnew) {
			exemac(bw->o.mnew);
		}
		if (er == 0 && bw->o.mold) {
			exemac(bw->o.mold);
		}
		return ret;
	} else if(c=='n' || c=='N') {
		/* Edit already loaded buffer */
d515 7
a521 15
		if (notify) {
			*notify = 1;
		}

		b = bfind(s);
		er = error;
		if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
			if (orphan) {
				orphit(bw);
			} else {
				if (uduptw(bw)) {
					brm(b);
					return -1;
				}
				bw = maint->curwin->object.bw;
d523 1
a523 28
		}
		if (er) {
			msgnwt(bw->parent, msgs[-er]);
			if (er != -1) {
				ret = -1;
			}
		}
		object = bw->object;
		w = bw->parent;
		bwrm(bw);
		w->object.bw = bw = bwmk(w, b, 0);
		wredraw(bw->parent);
		bw->object = object;
		vsrm(s);
		if (er == -1 && bw->o.mnew) {
			exemac(bw->o.mnew);
		}
		if (er == 0 && bw->o.mold) {
			exemac(bw->o.mold);
		}
		return ret;
	} else {
		/* FIXME: need abort handler to prevent leak */
		if (mkqw(bw->parent, sc("Load original file from disk (y,n,^C)? "), doedit1, NULL, s, notify))
			return 0;
		else {
			vsrm(s);
			return -1;
d526 17
@


1.19
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d648 1
a669 1
	vsrm(s);
@


1.18
log
@make wmkpw const again
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.16 2017/12/06 21:41:04 tg Exp $");
d506 1
a506 1
				bw = (BW *) maint->curwin->object;
d518 1
a518 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d546 1
a546 1
				bw = (BW *) maint->curwin->object;
d558 1
a558 1
		w->object = (void *) (bw = bwmk(w, b, 0));
d656 1
a656 1
			bw = (BW *) maint->curwin->object;
d666 1
a666 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d713 1
a713 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d750 1
a750 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d778 1
a778 1
	w->object = (void *) (bw = bwmk(w, b, 0));
d893 1
a893 1
			if ((w->watom->what&TYPETW) && ((BW *)w->object)->b==b) {
d895 2
a896 2
					BW *bw_ = (BW *)w->object;
					void *object_ = bw_->object;
d900 2
a901 2
					bwrm(bw_);
					w->object = (void *) (bw_ = bwmk(w, new_b, 0));
d903 1
a903 1
					bw_->object = object_;
d905 4
a908 4
					BW *bw_ = (BW *)w->object;
					object = bw_->object;
					bwrm(bw_);
					w->object = (void *) (bw_ = bwmk(w, bfind(US ""), 0));
d910 3
a912 3
					bw_->object = object;
					if (bw_->o.mnew)
						exemac(bw_->o.mnew);
d943 1
a943 1
	BW *bw = m->parent->win->object;
d1001 1
a1001 1
		bw = w->object;
d1048 1
a1048 1
		bw = w->object;
@


1.17
log
@lots of fixes related to prototyping
@
text
@d124 1
a124 1
		if (wmkpw(bw->parent, US "Name of file to write (^C to abort): ", &filehist, dowrite, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d465 1
a465 1
	pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(NULL,NULL,NULL,0), NULL, locale_map);
d611 1
a611 1
	if (wmkpw(bw->parent, US "Name of file to edit (^C to abort): ", &filehist, doedit, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d626 1
a626 1
	if (wmkpw(bw->parent, US "Name of buffer to edit (^C to abort): ", &filehist, doswitch, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d681 1
a681 1
	if (wmkpw(bw->parent, US "Name of scratch buffer to edit (^C to abort): ", &filehist, doscratch, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d786 1
a786 1
	if (wmkpw(bw->parent, US "Name of file to insert (^C to abort): ", &filehist, doinsf, US "Names", NULL, cmplt, NULL, NULL, locale_map)) {
d819 1
a819 1
		BW *pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, mksavereq(exdone,NULL,NULL,1), NULL, locale_map);
d981 1
a981 1
			pbw = wmkpw(bw->parent, US "Name of file to save (^C to abort): ", &filehist, dosave1, US "Names", NULL, cmplt, req, notify, locale_map);
@


1.16
log
@const cleanup
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.14 2017/12/02 04:32:42 tg Exp $");
a28 4
#ifdef WITH_SELINUX
int copy_security_context(const char *from_file, const char *to_file);
#endif

d103 2
a104 1
void genexmsgmulti(BW *bw, int saved, int skipped)
a201 1
#ifdef WITH_SELINUX
a202 1
#endif
d268 1
a268 1
	int (*callback) ();
d275 3
a277 1
struct savereq *mksavereq(int (*callback)(), unsigned char *name, B *first,int rename_)
d284 1
a284 1
	req->rename = rename_;
d481 2
a482 1
int doedit1(BW *bw,int c,unsigned char *s,int *notify)
d580 2
a581 1
int doedit(BW *bw, unsigned char *s, void *obj, int *notify)
d633 2
a634 1
int doscratch(BW *bw, unsigned char *s, void *obj, int *notify)
@


1.15
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d301 1
a301 1
		msgnw(bw->parent, US "Couldn't make backup file... file not saved");
d603 1
a603 1
		msgnw(bw->parent, US "Can't replace modified file");
@


1.14
log
@some fallout of the includes changes, some more reduction
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/ufile.c,v 1.13 2017/12/02 02:07:35 tg Exp $");
a13 2
#include <unistd.h>
#ifdef HAVE_SYS_STAT_H
a14 2
#endif
#ifdef HAVE_FCNTL_H
a15 2
#endif
#ifdef HAVE_STDLIB_H
d17 1
a17 1
#endif
@


1.13
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
a57 1
#include "utf8.h"
@


1.12
log
@new command abendjoe to exit 1
@
text
@a0 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.10 2013/08/19 22:48:33 tg Exp $ */
d8 1
d12 2
a13 1
#include <stdio.h>
a14 3
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.11
log
@omit the “New File” in new scratch buffers
@
text
@d1070 9
@


1.10
log
@for real: backups use tmp files
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.9 2013/08/19 22:14:51 tg Exp $ */
d668 1
a668 1
	if (er) {
d670 1
a670 3
		if (er != -1) {
			ret = -1;
		}
@


1.9
log
@attempt to sanitise tmpfile handling even more
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.8 2012/12/20 21:39:28 tg Exp $ */
d250 11
a260 2
	simple_backup_suffix = dirprt(name);
	if ((simple_backup_suffix = mktmp(simple_backup_suffix, &fd)) == NULL)
@


1.8
log
@FINALLY let ^KE not trash the current window if it was from ^KO (adjust ^K; to no longer split) and hook up scratch as ^K-
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.7 2012/12/19 22:06:29 tg Exp $ */
a248 1
#ifdef HAVE_MKSTEMP
d250 2
a251 2
	joe_snprintf_1((char *)tmp, sizeof(tmp), "%s.XXXXXXXXXX", name);
	if ((fd = mkstemp((char *)tmp)) < 0) {
a252 2
	}
#endif
a256 1
#ifdef HAVE_MKSTEMP
d258 1
a258 1
	if (cp(bw->b->name, fd, tmp, name)) {
d260 1
a260 6
		unlink((char *)tmp);
		return (1);
	}
#else
	/* Yeowch! */
	if ((fd = creat((char *)name, 0600)) < 0) {
a262 1
#warning "TOCTOU temp file race here! Consider getting mkstemp!"
a263 7
	/* Copy original file to backup file */
	if (cp(bw->b->name, fd, NULL, name)) {
		close(fd);
		unlink((char *)name);
		return (1);
	}
#endif
@


1.7
log
@securely make backup files using mkstemp(3) and later rename
issue reported by Han Boetes, reproduced using crontab -e and systrace -Ap
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.4 2010/04/08 15:31:05 tg Exp $ */
d517 1
a517 1
		if (bw->b->count == 1 && (bw->b->changed || bw->b->name)) {
@


1.6
log
@outdent, I’m a firm believer of return()ing early
@
text
@d158 2
a159 1
static int cp(unsigned char *from, unsigned char *to)
d161 1
a161 1
	int f, g, amnt;
d179 1
a179 2
	g = creat((char *)to, sbuf.st_mode & ~(S_ISUID | S_ISGID));
	if (g < 0) {
d181 1
a181 1
		return -1;
a188 1
	close(g);
d193 10
d215 1
a215 1
	copy_security_context(from,to);
d229 1
a229 1
	unsigned char tmp[1024];
d232 1
d249 8
d260 14
d275 3
a277 1
	if (cp(bw->b->name, name)) {
d280 1
@


1.5
log
@remove MS-DOS dust
@
text
@d217 2
a218 1
static int backup(BW *bw)
d220 15
a234 26
	if (!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0]) {
		unsigned char tmp[1024];
		unsigned char name[1024];

		/* Create backup file name */
		unsigned char *simple_backup_suffix = (unsigned char *)getenv("SIMPLE_BACKUP_SUFFIX");
		
		if (simple_backup_suffix == NULL) {
			simple_backup_suffix = US "~";
		}
		if (backpath) {
			joe_snprintf_3((char *)name, sizeof(name), "%s/%s%s", backpath, namepart(tmp, bw->b->name), simple_backup_suffix);
		} else {
			joe_snprintf_2((char *)name, sizeof(name), "%s%s", bw->b->name, simple_backup_suffix);
		}
		
		/* Attempt to delete backup file first */
		unlink((char *)name);

		/* Copy original file to backup file */
		if (cp(bw->b->name, name)) {
			return 1;
		} else {
			bw->b->backup = 1;
			return 0;
		}
d236 9
a244 1
		return 0;
d246 2
d449 1
a449 1
	
@


1.4
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/ufile.c,v 1.3 2008/05/13 13:08:28 tg Exp $ */
a222 20
#ifdef __MSDOS__
		int x;

		if (backpath) {
			joe_snprintf_2(name, sizeof(name), "%s/%s", backpath, namepart(tmp, bw->b->name));
		} else {
			joe_snprintf_1(name, sizeof(name), "%s", bw->b->name);
		}

		for (x = strlen(name); name[--x] != '.';) {
			if (name[x] == '\\' || (name[x] == ':' && x == 1) || x == 0) {
				x = strlen(name);
				break;
			}
		}

		strcpy(name + x, ".bak");

#else

a237 2
#endif

@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d284 1
a284 1
struct savereq *mksavereq(int (*callback)(), unsigned char *name, B *first,int rename)
d291 1
a291 1
	req->rename = rename;
d901 2
a902 2
					BW *bw = (BW *)w->object;
					void *object = bw->object;
d906 2
a907 2
					bwrm(bw);
					w->object = (void *) (bw = bwmk(w, new_b, 0));
d909 1
a909 1
					bw->object = object;
d911 4
a914 4
					BW *bw = (BW *)w->object;
					object = bw->object;
					bwrm(bw);
					w->object = (void *) (bw = bwmk(w, bfind(US ""), 0));
d916 3
a918 3
					bw->object = object;
					if (bw->o.mnew)
						exemac(bw->o.mnew);
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@a586 4
	int ret = 0;
	int er;
	void *object;
	W *w;
a623 6
	int ret = 0;
	int er;
	void *object;
	W *w;
	B *b;

@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* User file operations
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d12 8
d21 4
a24 2
#include <sys/stat.h>
#include "config.h"
d36 4
d42 1
a42 6
#include "scrn.h"
#include "tw.h"
#include "w.h"
#include "pw.h"
#include "qw.h"
#include "ublock.h"
a43 3
#include "zstr.h"
#include "vs.h"
#include "va.h"
d46 6
a52 2
#include "tty.h"
#include "tab.h"
a53 1
#include "macro.h"
d55 7
d64 4
a67 4
char *backpath=0;			/* Place to store backup files */
static B *filehist=0;			/* History of file names */
int nobackups=0;
int exask=0;
d70 54
d125 4
a128 42
void genexmsg(bw,saved,name)
BW *bw;
char *name;
 {
 char *s;
 if(bw->b->name && bw->b->name[0]) s=bw->b->name;
 else s="(Unnamed)";

 if(name)
  if(saved)
   sprintf(msgbuf,"File %s saved",name);
  else
   sprintf(msgbuf,"File %s not saved",name);
 else
  if(bw->b->changed && bw->b->count==1)
   sprintf(msgbuf,"File %s not saved",s);
  else if(saved)
   sprintf(msgbuf,"File %s saved",s);
  else
   sprintf(msgbuf,"File %s not changed so no update needed",s);
 msgnw(bw,msgbuf);

 if(!exmsg)
  if(bw->b->changed && bw->b->count==1)
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" not saved."));
   }
  else if(saved)
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" saved."));
   }
  else
   {
   exmsg=vsncpy(NULL,0,sc("File "));
   exmsg=vsncpy(sv(exmsg),sz(s));
   exmsg=vsncpy(sv(exmsg),sc(" not changed so no update needed."));
   }
 }
d132 12
a143 13
int ublksave(bw)
BW *bw;
 {
 if(markb && markk && markb->b==markk->b &&
    (markk->byte-markb->byte)>0 &&
    (!square || piscol(markk)>piscol(markb)))
  {
  if(wmkpw(bw,
           "Name of file to write (^C to abort): ",&filehist,dowrite,"Names",NULL,cmplt,NULL,NULL)) return 0;
  else return -1;
  }
 else return usave(bw);
 }
d147 7
a153 8
int ushell(bw)
BW *bw;
 {
 nescape(bw->parent->t->t);
 ttsusp();
 nreturn(bw->parent->t->t);
 return 0;
 }
d157 4
a160 5
int cp(from,to)
char *from, *to;
 {
 int f, g, amnt;
 struct stat sbuf;
d164 1
a164 1
 time_t utbuf[2];
d166 1
a166 1
 struct utimbuf utbuf;
d170 22
a191 13
 f=open(from,O_RDONLY);
 if(f<0) return -1;
 if(fstat(f,&sbuf)<0) return -1;
 g=creat(to,sbuf.st_mode);
 if(g<0)
  {
  close(f);
  return -1;
  }
 while((amnt=read(f,stdbuf,stdsiz))>0)
  if(amnt!=write(g,stdbuf,amnt)) break;
 close(f); close(g);
 if(amnt) return -1;
d195 2
a196 2
 utbuf[0]=(time_t)sbuf.st_atime;
 utbuf[1]=(time_t)sbuf.st_mtime;
d198 4
a201 2
 utbuf.actime=sbuf.st_atime;
 utbuf.modtime=sbuf.st_mtime;
d203 3
a205 1
 utime(to,&utbuf);
d208 2
a209 2
 return 0;
 }
d216 5
a220 8
static int backup(bw)
BW *bw;
 {
 if(!bw->b->backup && !nobackups && bw->b->name && bw->b->name[0])
  {
  char tmp[1024];
  char name[1024];
  int x;
d223 1
d225 12
a236 13
  if(backpath)
   sprintf(name,"%s/%s",backpath,namepart(tmp,bw->b->name));
  else
   sprintf(name,"%s",bw->b->name);
  
  ossep(name);

  for(x=zlen(name);name[--x]!='.';)
   if(name[x]=='\\' || (name[x]==':' && x==1) || x==0)
    {
    x=zlen(name);
    break;
    }
d238 1
a238 1
  zcpy(name+x,".bak");
d242 14
a255 8
  /* Create backup file name */
  if(backpath)
   sprintf(name,"%s/%s~",backpath,namepart(tmp,bw->b->name));
  else
   sprintf(name,"%s~",bw->b->name);

  /* Attempt to delete backup file first */
  unlink(name);
d259 11
a269 13
  /* Copy original file to backup file */
  if(cp(bw->b->name,name))
   {
   return 1;
   }
  else
   {
   bw->b->backup=1;
   return 0;
   }
  }
 else return 0;
 }
d273 211
a483 123
struct savereq
 {
 int (*callback)();
 char *name;
 };

static int saver(bw,c,req,notify)
BW *bw;
int c;
struct savereq *req;
int *notify;
 {
 int (*callback)();
 int fl;
 callback=req->callback;
 if(c=='n' || c=='N')
  {
  vsrm(req->name);
  free(req);
  if(notify) *notify=1;
  msgnw(bw,"Couldn't make backup file... file not saved");
  if(callback) return callback(bw,-1);
  else return -1;
  }
 if(c!='y' && c!='Y')
  if(mkqw(bw,sc("Could not make backup file.  Save anyway (y,n,^C)? "),saver,NULL,req,notify))
   return 0;
  else
   {
   if(notify) *notify=1;
   return -1;
   }
 if(notify) *notify=1;
 if(bw->b->er== -1 && bw->o.msnew) exemac(bw->o.msnew), bw->b->er= -3;
 if(bw->b->er== 0 && bw->o.msold) exemac(bw->o.msold);
 if(fl=bsave(bw->b->bof,req->name,bw->b->eof->byte))
  {
  msgnw(bw,msgs[fl+5]);
  vsrm(req->name);
  free(req);
  if(callback) return callback(bw,-1);
  else return -1;
  }
 else
  {
  if(!bw->b->name) bw->b->name=joesep(zdup(req->name));
  if(!zcmp(bw->b->name,req->name))
   {
   bw->b->changed=0;
   saverr(bw->b->name);
   }
  genexmsg(bw,1,req->name);
  vsrm(req->name);
  free(req);
  if(callback) return callback(bw,0);
  else return 0;
  }
 }

static int dosave(bw,s,callback,notify)
BW *bw;
char *s;
int (*callback)();
int *notify;
 {
 struct savereq *req=(struct savereq *)malloc(sizeof(struct savereq));
 req->name=s;
 req->callback=callback;
 if(backup(bw)) saver(bw,0,req,notify);
 else saver(bw,'y',req,notify);
 }

static int dosave2(bw,c,s,notify)
BW *bw;
char *s;
int *notify;
 {
 if(c=='y' || c=='Y') return dosave(bw,s,NULL,notify);
 else if(c=='n' || c=='N')
  {
  if(notify) *notify=1;
  genexmsg(bw,0,s);
  vsrm(s);
  return -1;
  }
 else
  if(mkqw(bw,sc("File exists.  Overwrite (y,n,^C)? "),dosave2,NULL,s,notify)) return 0;
  else return -1;
 }

static int dosave1(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 int f;
 if(s[0]!='!' && !(s[0]=='>' && s[1]=='>') && (!bw->b->name || zcmp(s,bw->b->name)))
  {
  f=open(s,O_RDONLY);
  if(f!= -1)
   {
   close(f);
   return dosave2(bw,0,s,notify);
   }
  }
 return dosave(bw,s,object,notify);
 }

int usave(bw)
BW *bw;
 {
 BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,NULL,NULL);
 if(pbw && bw->b->name)
  {
  binss(pbw->cursor,bw->b->name);
  pset(pbw->cursor,pbw->b->eof);
  pbw->cursor->xcol=piscol(pbw->cursor);
  }
 if(pbw) return 0;
 else return -1;
 }
d487 215
a701 66
int doedit(bw,s,obj,notify)
BW *bw;
char *s;
void *obj;
int *notify;
 {
 int ret=0;
 int er;
 void *object;
 W *w;
 B *b;
 if(notify) *notify=1;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bfind(s);
 er=error;
 if(bw->b->count==1 && (bw->b->changed || bw->b->name))
  if(orphan) orphit(bw);
  else
   {
   if(uduptw(bw))
    {
    brm(b);
    return -1;
    }
   bw=(BW *)maint->curwin->object;
   }
 if(er)
  {
  msgnwt(bw,msgs[er+5]);
  if(er!= -1) ret= -1;
  }
 object=bw->object;
 w=bw->parent;
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 vsrm(s);
 if(er== -1 && bw->o.mnew)
  exemac(bw->o.mnew);
 if(er==0 && bw->o.mold)
  exemac(bw->o.mold);
 return ret;
 }

int okrepl(bw)
BW *bw;
 {
 if(bw->b->count==1 && bw->b->changed)
  {
  msgnw(bw,"Can't replace modified file");
  return -1;
  }
 else return 0;
 }

int uedit(bw)
BW *bw;
 {
 if(wmkpw(bw,"Name of file to edit (^C to abort): ",&filehist,doedit,"Names",NULL,cmplt,NULL,NULL)) return 0;
 else return -1;
 }
d705 35
a739 37
int dorepl(bw,s,obj,notify)
BW *bw;
char *s;
void *obj;
int *notify;
 {
 void *object=bw->object;
 int ret=0;
 int er;
 W *w=bw->parent;
 B *b;
 if(notify) *notify=1;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bfind(s);
 er=error;
 if(error)
  {
  msgnwt(bw,msgs[error+5]);
  if(error!= -1) ret= -1;
  }
 if(bw->b->count==1 && (bw->b->changed || bw->b->name))
  orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 vsrm(s);
 if(er== -1 && bw->o.mnew)
  exemac(bw->o.mnew);
 if(er==0 && bw->o.mold)
  exemac(bw->o.mold);
 return ret;
 }
d743 64
a806 55
int unbuf(bw)
BW *bw;
 {
 void *object=bw->object;
 W *w=bw->parent;
 B *b;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bnext();
 if(b==bw->b) b=bnext();
 if(b==bw->b) return -1;
 if(!b->orphan) ++b->count;
 else b->orphan=0;
 if(bw->b->count==1) orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 return 0;
 }

int upbuf(bw)
BW *bw;
 {
 void *object=bw->object;
 W *w=bw->parent;
 B *b;
 if(bw->pid)
  {
  msgnw(bw,"Process running in this window");
  return -1;
  }
 b=bprev();
 if(b==bw->b) b=bprev();
 if(b==bw->b) return -1;
 if(!b->orphan) ++b->count;
 else b->orphan=0;
 if(bw->b->count==1) orphit(bw);
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,b,0));
 wredraw(bw->parent);
 bw->object=object;
 return 0;
 }

int uinsf(bw)
BW *bw;
 {
 if(wmkpw(bw,
           "Name of file to insert (^C to abort): ",&filehist,doinsf,"Names",NULL,cmplt,NULL,NULL)) return 0;
 else return -1;
 }
d810 142
a951 176
static int exdone(bw,flg)
BW *bw;
 {
 if(flg)
  {
  if(bw->b->name) free(bw->b->name);
  bw->b->name=0;
  return -1;
  }
 else
  {
  bw->b->changed=0;
  saverr(bw->b->name);
  return uabort(bw,MAXINT);
  }
 }

static int exdone1(bw,flg)
BW *bw;
 {
 if(flg)
  {
  return -1;
  }
 else
  {
  bw->b->changed=0;
  saverr(bw->b->name);
  return uabort(bw,MAXINT);
  }
 }

static int doex(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 bw->b->name=joesep(zdup(s)); 
 return dosave(bw,s,exdone,notify);
 }

int uexsve(bw)
BW *bw;
 {
 if(!bw->b->changed) { uabort(bw,MAXINT); return 0; }
 else if(bw->b->name && !exask)
  {
  return dosave(bw,vsncpy(NULL,0,sz(bw->b->name)),exdone1,NULL);
  } 
 else
  {
  BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,doex,"Names",NULL,cmplt,NULL,NULL);
  if(pbw && bw->b->name)
   {
   binss(pbw->cursor,bw->b->name);
   pset(pbw->cursor,pbw->b->eof);
   pbw->cursor->xcol=piscol(pbw->cursor);
   }
  if(pbw) return 0;
  else return -1;
  }
 }

/* If buffer is modified, prompt for saving */

static int nask(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='y' || c=='Y')
  if(bw->b->name) return dosave1(bw,vsncpy(NULL,0,sz(bw->b->name)),object,notify);
  else
   {
   BW *pbw=wmkpw(bw,
                 "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,object,notify);
   if(pbw) return 0;
   else return -1;
   }
 else if(c=='n' || c=='N')
  {
  genexmsg(bw,0,NULL);
  if(notify) *notify=1;
  return 0;
  }
 else
  if(bw->b->count==1 && bw->b->changed)
   {
   if(mkqw(bw,sc("Save changes to this file (y,n,^C)? "),nask,NULL,object,notify)) return 0;
   else return -1;
   }
  else
   {
   if(notify) *notify=1;
   return 0;
   }
 }

int uask(bw)
BW *bw;
 {
 return nask(bw,0,NULL,NULL);
 }

/* Ask to save file if it is modified.  If user answers yes, run save */

static int nask2(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 if(c=='y' || c=='Y')
  {
  BW *pbw=wmkpw(bw,
                "Name of file to save (^C to abort): ",&filehist,dosave1,"Names",NULL,cmplt,object,notify);
  if(pbw) return 0;
  else return -1;
  }
 else if(c=='n' || c=='N')
  {
  genexmsg(bw,0,NULL);
  if(notify) *notify=1;
  return 0;
  }
 else
  if(bw->b->count==1 && bw->b->changed)
   {
   if(mkqw(bw,sc("Save changes to this file (y,n,^C)? "),nask,NULL,object,notify)) return 0;
   else return -1;
   }
  else
   {
   if(notify) *notify=1;
   return 0;
   }
 }

int uask2(bw)
BW *bw;
 {
 return nask2(bw,0,NULL,NULL);
 }

/* If buffer is modified, ask if it's ok to lose changes */

int dolose(bw,c,object,notify)
BW *bw;
void *object;
int *notify;
 {
 W *w;
 if(notify) *notify=1;
 if(c!='y' && c!='Y') return -1;
 genexmsg(bw,0,NULL);
 if(bw->b->count==1) bw->b->changed=0;
 object=bw->object; w=bw->parent;
 bwrm(bw);
 w->object=(void *)(bw=bwmk(w,bfind(""),0));
 wredraw(bw->parent);
 bw->object=object;
 if(bw->o.mnew) exemac(bw->o.mnew);
 return 0;
 }

int ulose(bw)
BW *bw;
 {
 msgnw(bw,NULL);
 if(bw->pid) return ukillpid(bw);
 if(bw->b->count==1 && bw->b->changed)
  if(mkqw(bw,sc("Lose changes to this file (y,n,^C)? "),dolose,NULL,NULL,NULL)) return 0;
  else return -1;
 else return dolose(bw,'y',NULL,NULL);
 }
d955 121
a1075 33
int dobuf(m,x,s)
MENU *m;
char **s;
 {
 char *name;
 BW *bw=m->parent->win->object;
 int *notify=m->parent->notify;
 m->parent->notify=0;
 name=vsdup(s[x]);
 uabort(m,MAXINT);
 return dorepl(bw,name,NULL,notify);
 }

int abrtb(m,x,s)
MENU *m;
char **s;
 {
 varm(s);
 return -1;
 }

int ubufed(bw)
BW *bw;
 {
 char **s=getbufs();
 vasort(av(s));
 if(mkmenu(bw,s,dobuf,abrtb,NULL,0,s,NULL)) return 0;
 else
  {
  varm(s);
  return -1;
  }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
