head	1.9;
access;
symbols
	joe-3_1jupp38:1.9
	joe-3_1jupp37:1.9
	joe-3_1jupp36:1.9
	joe-3_1jupp35:1.9
	joe-3_1jupp34:1.9
	joe-3_1jupp33:1.9
	joe-3_1jupp32:1.9
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.4
	joe-3_1jupp30:1.4
	joe-3_1jupp29:1.4
	joe-3_1jupp28:1.4
	joe-3_1jupp27:1.4
	joe-3_1jupp26:1.4
	joe-3_1jupp25:1.4
	joe-3_1jupp24:1.4
	joe-3_1jupp23:1.4
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.4
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.9
date	2017.12.08.02.46.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A29FD2A06CBDCE5;

1.8
date	2017.12.06.23.17.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A287AA407E73F9C;

1.7
date	2017.12.06.21.17.00;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A285E5918D423C7;

1.6
date	2017.12.02.17.00.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A22DC570063953B;

1.5
date	2017.12.02.02.07.33;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A220AD65C90E687;

1.4
date	2010.04.08.15.31.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBDF6C54CC9A0DB;

1.3
date	2008.05.13.13.08.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@massive const offensive
@
text
@/*
 * 	TERMCAP/TERMINFO header file
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_TERMCAP_H
#define _JOE_TERMCAP_H 1

#ifdef EXTERN
__IDSTRING(rcsid_termcap_h, "$MirOS: contrib/code/jupp/termcap.h,v 1.8 2017/12/06 23:17:35 tg Exp $");
#endif

/* CAP *getcap(char *s,int baud,void (*out)(void *outptr,char c),void *outptr);
 *
 * Get CAP entry for terminal named in 's'.  If 's' is zero, the name in
 * the environment variable 'TERM' is used instead.  Space for the returned
 * CAP is allocated from the heap using malloc.
 *
 * 'baud'   is the baud rate used for 'texec' to calculate number of pad chars
 * 'out'    is the function 'texec' uses to output characters
 * 'outptr' is the passed as the first arg to 'out'
 *          the second arg contains the char to output
 *
 * This is how 'getcap' finds the entry:  First a list of file names is
 * built.  If the environment variable 'TERMCAP' begins with a '/', it
 * is used as the list of file names.  Otherwise, if the environment
 * variable 'TERMPATH' is set, it is used as the list of file names.  If
 * that isn't set, then the string TERMPATH defined above is appended
 * to value of the 'HOME' environment variable, and that is used as the
 * list of names (a '/' is placed between the value of the environment
 * variable and the string).  If HOME isn't set, then TERMPATH alone is
 * used as the list of file names (without prepending a '/').
 *
 * Now the contents of the environment variable 'TERMCAP' (if it's defined and
 * if it doesn't begin with a '/') and the files from the above list are
 * scanned for the terminal name.  The contents of the environment variable
 * are scanned first, then the files are scanned in the order they appear in
 * the named list.
 *
 * If the last part of a matching termcap entry is a 'tc=filename', then
 * the current file is rewound and rescanned for the matching entry (and if
 * it's not found, the next entry in the file name list is searched).  If
 * a matching termcap entry in the TERMCAP environment variable ends with
 * a 'tc=filename', then all of the files in the name list are searched.
 *
 * There is no limit on the size of the termcap entries.  No checking is
 * done for self-refering 'tc=filename' links (so all of core will be
 * allocated if there are any).
 */
CAP *getcap(unsigned char *name, unsigned int baudrate, void (*out) (unsigned char *, unsigned char), void *outptr);

/* CAP *setcap(CAP *cap,int baud,void (*out)(void *outptr,char c),void *outptr);
 *
 * Reset baud, out and outptr for a CAP
 */
CAP *setcap(CAP *cap, unsigned int baudrate, void (*out) (unsigned char *, unsigned char), void *outptr);

/* char *jgetstr(CAP *cap,char *name);
 *
 * Get value of string capability or return NULL if it's not found.  A fast
 * binary search is used to find the capability.  The char * returned points into
 * the buffer used to load the termcap entry.  It should not be modified or
 * freed.
 */
const unsigned char *jgetstr(CAP *cap, const unsigned char *name);

/* int getflag(CAP *cap,char *name);
 *
 * Return true if the named capability is found in 'cap'.  A fast binary
 * search is used to lookup the capability.
 */
int getflag(CAP *cap, const unsigned char *name);

/* int getnum(CAP *cap,char *name);
 *
 * Return value of numeric capability or return -1 if it's not found.  A fast
 * binary search is used to lookup the capability.
 */
int getnum(CAP *cap, const unsigned char *name);

/* void rmcap(CAP *cap);
 *
 * Eliminate a CAP entry.
 */
void rmcap(CAP *cap);

/* void texec(CAP *cap,char *str,int l,int a0,int a1,int a2,int a3);

   Execute and output a termcap string capability.

   'cap' is the CAP returned by getcap which contains the baud rate and output
   function.

   'str' is the string to execute.  If 'str'==NULL, nothing happens.

   'l' is the number of lines effected by this string.  For example, if you
   use the clear to end of screen capability, the number of lines between
   the current cursor position and the end of the screen should be
   given here.

   'a0' - 'a1' are the arguments for the string
*/
void texec(CAP *cap, const unsigned char *s, int l,
    int a0, int a1, int a2, int a3);

/* int tcost(CAP *cap,char *str, int l, int a0, int a1, int a2, int a3);
   Return cost in number of characters which need to be sent
   to execute a termcap string capability.

   'cap' is the CAP returned by getcap which contains the baud rate and output
   functions.

   'str' is the string to execute.  If 'str'==NULL, tcost return 10000.

   'l' is the number of lines effected by this string.  Ex: if you
   use the clear to end of screen capability, the number of lines between
   the current cursor position and the end of the screen should be
   given here.

   'a0' - 'a3' are arguements passed to the string
*/
int tcost(CAP *cap, const unsigned char *s, int l,
    int a0, int a1, int a2, int a3);

/* char *tcompile(CAP *cap,char *str,int a0,int a1,int a2,int a3);

   Compile a string capability.  Returns a pointer to a variable length
   string (see vs.h) containing the compiled string capability.
   Pad characters are not placed in the string.
*/
unsigned char *tcompile(CAP *cap, const unsigned char *s,
    int a0, int a1, int a2, int a3);

int tgetent(char *, const char *);
int tgetflag(char *);
int tgetnum(char *);
int tputs(const char *, int, int (*)(int));
char *tgetstr(char *, char **);
char *tgoto(const char *, int, int);

#endif
@


1.8
log
@whitespace at EOL annoys me
@
text
@d12 1
a12 1
__IDSTRING(rcsid_termcap_h, "$MirOS: contrib/code/jupp/termcap.h,v 1.7 2017/12/06 21:17:00 tg Exp $");
d67 1
a67 1
unsigned char *jgetstr(CAP *cap, unsigned char *name);
d74 1
a74 1
int getflag(CAP *cap, unsigned char *name);
d81 1
a81 1
int getnum(CAP *cap, unsigned char *name);
d105 2
a106 1
void texec(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3);
d124 2
a125 1
int tcost(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3);
d133 2
a134 1
unsigned char *tcompile(CAP *cap, unsigned char *s, int a0, int a1, int a2, int a3);
@


1.7
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d7 1
a7 1
 */ 
d10 1
a10 1
 
d12 1
a12 1
__IDSTRING(rcsid_termcap_h, "$MirOS: contrib/code/jupp/termcap.h,v 1.6 2017/12/02 17:00:50 tg Exp $");
d95 1
a95 1
   
d97 1
a97 1
   
d113 1
a113 1
   
d115 1
a115 1
   
@


1.6
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_termcap_h, "$MirOS: contrib/code/jupp/termcap.h,v 1.5 2017/12/02 02:07:33 tg Exp $");
d52 1
a52 1
CAP *getcap PARAMS((unsigned char *name, unsigned int baudrate, void (*out) (unsigned char *, unsigned char), void *outptr));
d58 1
a58 1
CAP *setcap PARAMS((CAP *cap, unsigned int baudrate, void (*out) (unsigned char *, unsigned char), void *outptr));
d67 1
a67 1
unsigned char *jgetstr PARAMS((CAP *cap, unsigned char *name));
d74 1
a74 1
int getflag PARAMS((CAP *cap, unsigned char *name));
d81 1
a81 1
int getnum PARAMS((CAP *cap, unsigned char *name));
d87 1
a87 1
void rmcap PARAMS((CAP *cap));
d105 1
a105 1
void texec PARAMS((CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3));
d123 1
a123 1
int tcost PARAMS((CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3));
d131 1
a131 1
unsigned char *tcompile PARAMS((CAP *cap, unsigned char *s, int a0, int a1, int a2, int a3));
d133 6
a138 6
int tgetent PARAMS((char *, const char *));
int tgetflag PARAMS((char *));
int tgetnum PARAMS((char *));
int tputs PARAMS((const char *, int, int (*)(int)));
char *tgetstr PARAMS((char *, char **));
char *tgoto PARAMS((const char *, int, int));
@


1.5
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.4
log
@Add --disable-getpwnam and clean up warnings
@
text
@a0 1
/* $MirOS: contrib/code/jupp/termcap.h,v 1.3 2008/05/13 13:08:26 tg Exp $ */
d11 3
a13 2
#include "config.h"
#include "types.h"
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d52 1
a52 1
CAP *getcap PARAMS((unsigned char *name, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr));
d58 1
a58 1
CAP *setcap PARAMS((CAP *cap, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr));
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d132 7
a138 11
/* Old termcap support */
#ifdef junk
int tgetent();
unsigned char *tgetstr();
int tgetflag();
int tgetnum();
unsigned char *tgoto();
void tputs();
extern short ospeed;
extern unsigned char PC, *UP, *BC;
#endif
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 10
a10 21
/* TERMCAP/TERMINFO header file
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#ifndef _Itermcap
#define _Itermcap 1

d12 1
a12 27

typedef struct cap CAP;

struct sortentry
 {
 char *name;
 char *value;
 };

struct cap
 {
 char *tbuf;			/* Termcap entry loaded here */

 struct sortentry *sort;	/* Pointers to each capability stored in here */
 int sortlen;			/* Number of capabilities */

 char *abuf;			/* For terminfo compatible version */
 char *abufp;
 
 int div;			/* tenths of MS per char */
 int baud;			/* Baud rate */
 char *pad;			/* Padding string or NULL to use NUL */
 void (*out)();			/* Character output routine */
 void *outptr;			/* First arg passed to output routine.  Second
 				   arg is character to write */
 int dopadding;			/* Set if pad characters should be used */
 };
d51 1
a51 1
CAP *getcap();
d56 2
a57 2
 */ 
CAP *setcap();
d66 1
a66 1
char *jgetstr();
d73 1
a73 1
int getflag();
d80 1
a80 1
int getnum();
d86 1
a86 1
void rmcap();
d104 1
a104 1
void texec();
d122 1
a122 1
int tcost();
d130 1
a130 1
char *tcompile();
d135 1
a135 1
char *tgetstr();
d138 1
a138 1
char *tgoto();
d141 1
a141 1
extern char PC, *UP, *BC;
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
