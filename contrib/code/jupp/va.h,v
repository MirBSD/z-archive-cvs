head	1.8;
access;
symbols
	joe-3_1jupp38:1.8
	joe-3_1jupp37:1.8
	joe-3_1jupp36:1.8
	joe-3_1jupp35:1.8
	joe-3_1jupp34:1.8
	joe-3_1jupp33:1.8
	joe-3_1jupp32:1.6
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.3
	joe-3_1jupp30:1.3
	joe-3_1jupp29:1.3
	joe-3_1jupp28:1.3
	joe-3_1jupp27:1.3
	joe-3_1jupp26:1.3
	joe-3_1jupp25:1.3
	joe-3_1jupp24:1.3
	joe-3_1jupp23:1.3
	joe-3_1jupp22:1.3
	joe-3_1jupp21:1.3
	joe-3_1jupp20:1.3
	joe-3_1jupp19:1.2
	joe-3_1jupp18:1.2
	joe-3_1jupp17:1.2
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.2
	joe-3_1jupp15:1.2
	joe-3_1jupp14:1.2
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.8
date	2018.01.07.20.32.47;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A5284063C3E386D;

1.7
date	2018.01.06.00.28.35;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A50184621FA8455;

1.6
date	2017.12.06.21.17.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A285E5918D423C7;

1.5
date	2017.12.02.17.00.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005A22DC570063953B;

1.4
date	2017.12.02.02.07.37;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005A220AD65C90E687;

1.3
date	2012.06.08.16.55.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004FD22E961A7F5A95;

1.2
date	2008.05.13.13.08.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.25;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.13;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@redo dynamic string memory foo to get rid of those ugly casts
@
text
@/*
 *	Variable length arrays of strings
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#ifndef _JOE_VA_H
#define _JOE_VA_H 1

#ifdef EXTERN_B_C
__IDSTRING(rcsid_va_h, "$MirOS: contrib/code/jupp/va.h,v 1.6 2017/12/06 21:17:04 tg Exp $");
#endif

#include "vs.h"

/* Functions and global variable you have to define.  Replace these with
 * macros or defines here if they are not to be actual functions
 */

typedef unsigned char *aELEMENT;

/* aELEMENT adup(); */
#define adup(s) vsdup(s)
/* aELEMENT adel(); */
#define adel(s) vsrm(s)
/* int acmp(); */
#define acmp(a,b) vscmp((a),(b))
/* extern aELEMENT ablank; */
#define ablank NULL
/* extern aELEMENT aterm; */
#define aterm NULL

/************************/
/* Creation/Destruction */
/************************/

/* aELEMENT *vamk(int len);
 * Create a variable length array.  Space for 'len' elements is preallocated.
 */
aELEMENT *vamk(int len);

/* void varm(aELEMENT *vary);
 * Free an array and everything which is in it.  Does nothing if 'vary' is
 * 0.
 */
void varm(aELEMENT *vary);

/********************/
/* Space management */
/********************/

/* int aSIZ(aELEMENT *vary);
 * int aSiz(aELEMENT *vary);
 * Access size part of array.  This int indicates the number of elements which
 * can fit in the array before realloc needs to be called.  It does not include
 * the extra space needed for the terminator and the header.
 *
 * aSIZ returns 0 if you pass it 0.  aSiz does not do this checking,
 * but can be used as an lvalue.
 */
#define aSiz(a) jalloc_siz(a)
#define aSIZ(a) ((a) ? aSiz(a) : 0)

/* int aLEN(aELEMENT *vary);
 * int aLen(aELEMENT *vary);
 * Access length part of array.  This int indicates the number of elements
 * currently in the array (not including the terminator).  This should be
 * used primarily for reading the size of the array.  It can be used for
 * setting the size of the array, but it must be used with care since it
 * does not eliminate elements (if the size decreases) or make sure there's
 * enough room (if the size increases).  See vensure and vtrunc.
 *
 * aLEN return a length of zero if 'vary' is 0.
 * aLen doesn't do this checking, but can be used as an lvalue
 */
#define aLen(a) jalloc_len(a)
#define aLEN(a) ((a) ? aLen(a) : 0)

/* int alen(aELEMENT *ary);
 * Compute length of char or variable length array by searching for termination
 * element.  Returns 0 if 'vary' is 0.
 */
int alen(aELEMENT *ary);

/* aELEMENT *vaensure(aELEMENT *vary, int len);
 * Make sure there's enough space in the array for 'len' elements.  Whenever
 * vaensure reallocs the array, it allocates 25% more than the necessary
 * minimum space in anticipation of future expansion.  If 'vary' is 0,
 * it creates a new array.
 */
aELEMENT *vaensure(aELEMENT *vary, int len);

/* aELEMENT *vazap(aELEMENT *vary, int pos, int n);
 * Destroy n elements from an array beginning at pos.  Is ok if pos/n go
 * past end of array.  This does not change the aLEN() value of the array.
 * This does nothing and returns 0 if 'vary' is 0.  Note that this
 * function does not actually write to the array.  This does not stop if
 * a aterm is encountered.
 */
aELEMENT *vazap(aELEMENT *vary, int pos, int n);

/* aELEMENT *vatrunc(aELEMENT *vary, int len);
 * Truncate array to indicated size.  This zaps or expands with blank elements
 * and sets the LEN() of the array.  A new array is created if 'vary' is 0.
 */
aELEMENT *vatrunc(aELEMENT *vary, int len);

/************************************/
/* Function which write to an array */
/************************************/

/* aELEMENT *vafill(aELEMENT *vary, int pos, aELEMENT el, int len);
 * Set 'len' element of 'vary' beginning at 'pos' to duplications of 'el'.
 * Ok, if pos/len are past end of array.  If 'vary' is 0, a new array is
 * created.
 *
 * This does not zap previous values.  If you need that to happen, call
 * vazap first.  It does move the terminator around properly though.
 */
aELEMENT *vafill(aELEMENT *vary, int pos, aELEMENT el, int len);

/* aELEMENT *vandup(aELEMENT *vary, int pos, aELEMENT *array, int len);
 * Duplicate 'len' elements from 'array' onto 'vary' beginning at position
 * 'pos'.  'array' can be a char array since its length is passed seperately.  A
 * new array is created if 'vary' is 0.
 */
aELEMENT *vandup(aELEMENT *vary, int pos, aELEMENT *array, int len);

/* aELEMENT *vadup(aELEMENT *vary);
 * Duplicate array.  This is just a functionalized version of:
 *
 *   vandup(NULL,0,vary,aLEN(vary));
 *
 * but since you need to be able to refer to this particular function by
 * address often it's given here.
 *
 * (actually, there's bazillions of these simple combinations of the above
 * functions and the macros of the next section.  You'll probably want to make
 * functionalized instances of the ones you use most often - especially since
 * the macros aren't safe).
 */
aELEMENT *vadup(aELEMENT *vary);

/* aELEMENT *vaset(aELEMENT *vary, int pos, aELEMENT element);
 * Set an element in an array.  Any value of 'pos' is valid.  A new array
 * is created if 'vary' is 0.  The previous contents of the position is
 * deleted.    This does not duplicate 'element'.  If you need 'element'
 * duplicated, call: vaset(vary,pos,adup(element));
 */
aELEMENT *_vaset(aELEMENT *vary, int pos, aELEMENT el);

#define vaset(v,p,el)  \
 (!(v) || (p) > aLen(v) || ((p) == aLen(v) && (p) == aSiz(v)) ?  \
  _vaset((v),(p),(el)) \
 : \
  ((p) == aLen(v) ? \
   ((v)[(p)+1] = (v)[p], (v)[p] = (el), aLen(v) = (p)+1, (v)) \
  : \
   (adel((v)[p]), (v)[p] = (el), (v)) \
  ) \
 )

/* aELEMENT *vaadd(aELEMENT *vary, aELEMENT element);
 * Concatenate a single element to the end of 'vary'.  A new array is created
 * if 'vary' is 0.  This does not duplicate element: call
 * vaadd(vary,adup(element));  If you need it duplicated.
 */
#define vaadd(v,el) \
 (!(v) || aLen(v) == aSiz(v) ? \
  _vaset((v), aLEN(v), (el)) \
 : \
  ((v)[aLen(v) + 1] = (v)[aLen(v)], (v)[aLen(v)] = (el), \
   aLen(v) = aLen(v) + 1, (v)) \
 )

/**************************************/
/* Functions which read from an array */
/**************************************/

/* These macros are used to generate the address/size pairs which get
 * passed to the functions of the previous section.
 */

/* { aELEMENT *, int } av(aELEMENT *array);
 * Return array,size pair.  Uses aLEN to get size.
 */
#define av(a) (a), aLEN(a)

/* { aELEMENT *, int } az(aELEMENT *array);
 * Return array,size pair.  Uses alen to get size.
 */
#define az(a) (a), alen(a)

/* { aELEMENT *, int } ac(aELEMENT *array);
 * Return array,size pair.  Uses 'sizeof' to get size.
 */
#define ac(a) (a), (sizeof(a) / sizeof(aELEMENT))

/* { aELEMENT *, int } arest(aELEMENT *vary, int pos);
 * Return array,size pair of rest of array beginning at pos.  If
 * pos is past end of array, gives size of 0.
 */
#define arest(a, p) ((a) + (p)), (((p) > aLEN(a)) ? 0 : aLen(a) - (p))

/* { aELEMENT *, int } apart(aELEMENT *vary, int pos, int len);
 * Return array,size pair of 'len' elements of array beginning with pos.  If
 * pos is past end of array, gives size of 0.  If pos+len is past end of array,
 * returns number of elements to end of array.
 */
#define apart(a, p, l) \
 ((a) + (p)), ((p) >= aLEN(a) ? 0 : ((p) + (l) > aLen(a) ? aLen(a) - (p) : (l)))

/* aELEMENT vaget(aELEMENT *vary, int pos);
 * Get an element from an array.  Any value of pos is valid; if it's past the
 * end of the array or if 'vary' is 0, the terminator is returned.  This
 * does not make a duplicate of the returned element.  If you want that, pass
 * the return value of this to adup.
 */
#define vaget(a, p) ((p) >= aLEN(a) ? aterm : (a)[p])

/*************************/
/* Searching and Sorting */
/*************************/

/* aELEMENT *vasort(aELEMENT *ary, int len)
 * Sort the elements of an array (char or variable length) using qsort().
 */
aELEMENT *vasort(aELEMENT *ary, int len);

/* aELEMENT *vawords(aELEMENT *a, char *s, int len, char *sep, int seplen);
 * Generate list of strings out of words in 's' seperated with the characters
 * in 'sep'.  The characters in 'sep' must be sorted.
 */
aELEMENT *vawords(aELEMENT *a, unsigned char *s, int len, const unsigned char *sep, int seplen);

#endif
@


1.7
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d62 2
a63 2
#define aSIZ(a) ((a) ? *((int *)(a) - 2) : 0)
#define aSiz(a) (*((int *)(a) - 2))
d77 2
a78 2
#define aLEN(a) ((a) ? *((int *)(a) - 1) : 0)
#define aLen(a) (*((int *)(a) - 1))
@


1.6
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d12 1
a12 1
__IDSTRING(rcsid_va_h, "$MirOS: contrib/code/jupp/va.h,v 1.5 2017/12/02 17:00:52 tg Exp $");
d235 1
a235 1
aELEMENT *vawords(aELEMENT *a, unsigned char *s, int len, unsigned char *sep, int seplen);
@


1.5
log
@fix string name collision by prefixing the idstrings in not-.c files
@
text
@d12 1
a12 1
__IDSTRING(rcsid_va_h, "$MirOS: contrib/code/jupp/va.h,v 1.4 2017/12/02 02:07:37 tg Exp $");
d41 1
a41 1
aELEMENT *vamk PARAMS((int len));
d47 1
a47 1
void varm PARAMS((aELEMENT *vary));
d84 1
a84 1
int alen PARAMS((aELEMENT *ary));
d92 1
a92 1
aELEMENT *vaensure PARAMS((aELEMENT *vary, int len));
d101 1
a101 1
aELEMENT *vazap PARAMS((aELEMENT *vary, int pos, int n));
d107 1
a107 1
aELEMENT *vatrunc PARAMS((aELEMENT *vary, int len));
d121 1
a121 1
aELEMENT *vafill PARAMS((aELEMENT *vary, int pos, aELEMENT el, int len));
d128 1
a128 1
aELEMENT *vandup PARAMS((aELEMENT *vary, int pos, aELEMENT *array, int len));
d143 1
a143 1
aELEMENT *vadup PARAMS((aELEMENT *vary));
d151 1
a151 1
aELEMENT *_vaset PARAMS((aELEMENT *vary, int pos, aELEMENT el));
d229 1
a229 1
aELEMENT *vasort PARAMS((aELEMENT *ary, int len));
d235 1
a235 1
aELEMENT *vawords PARAMS((aELEMENT *a, unsigned char *s, int len, unsigned char *sep, int seplen));
@


1.4
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
@


1.3
log
@nuke junk
@
text
@a0 1
/* $MirOS: contrib/code/jupp/va.h,v 1.2 2008/05/13 13:08:32 tg Exp $ */
d11 3
a13 1
#include "config.h"
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d17 1
a17 1
 * macros or defines here if they are not to be actual functions 
a121 10
#ifdef junk
/* aELEMENT *vancpy(aELEMENT *vary, int pos, aELEMENT *array, int len);
 * Copy 'len' elements from 'array' onto 'vary' beginning at position 'pos'.
 * 'array' can be a normal char array since the length is passed seperately.  The
 * elements are copied, not duplicated.  A new array is created if 'vary' is
 * 0.  This does not zap previous elements.
 */
aELEMENT *vancpy PARAMS((aELEMENT *vary, int pos, aELEMENT *array, int len));
#endif

@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Variable length arrays of strings
   Copyright (C) 1992 Joseph H. Allen
d11 1
a11 1
This file is part of JOE (Joe's Own Editor)
a12 17
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 

#ifndef _Iva
#define _Iva

#include "config.h"
d19 3
a21 3
#define aELEMENT(a) char *a
#define aCAST char *
/* aELEMENT(adup()); */
d23 1
a23 1
/* aELEMENT(adel()); */
d27 1
a27 1
/* extern aELEMENT(ablank); */
d29 1
a29 1
/* extern aELEMENT(aterm); */
d36 1
a36 1
/* aELEMENT(*vamk(int len));
d39 1
a39 1
aELEMENT(*vamk());
d41 1
a41 1
/* void varm(aELEMENT(*vary));
d45 1
a45 1
void varm();
d51 2
a52 2
/* int aSIZ(aELEMENT(*vary));
 * int aSiz(aELEMENT(*vary));
d60 2
a61 2
#define aSIZ(a) ((a)?*((int *)(a)-2):0)
#define aSiz(a) (*((int *)(a)-2))
d63 2
a64 2
/* int aLEN(aELEMENT(*vary));
 * int aLen(aELEMENT(*vary));
d75 2
a76 2
#define aLEN(a) ((a)?*((int *)(a)-1):0)
#define aLen(a) (*((int *)(a)-1))
d78 1
a78 1
/* int alen(aELEMENT(*ary));
d82 1
a82 1
int alen();
d84 1
a84 1
/* aELEMENT(*vaensure(aELEMENT(*vary),int len));
d90 1
a90 1
aELEMENT(*vaensure());
d92 1
a92 1
/* aELEMENT(*vazap(aELEMENT(*vary),int pos,int n));
d99 1
a99 1
aELEMENT(*vazap());
d101 1
a101 1
/* aELEMENT(*vatrunc(aELEMENT(*vary),int len));
d105 1
a105 1
aELEMENT(*vatrunc());
d111 1
a111 1
/* aELEMENT(*vafill(aELEMENT(*vary),int pos,aELEMENT(el),int len));
d119 2
a120 1
aELEMENT(*vafill());
d122 1
a122 1
/* aELEMENT(*vancpy(aELEMENT(*vary),int pos,aELEMENT(*array),int len));
d128 1
a128 1
aELEMENT(*vancpy());
d130 2
a131 1
/* aELEMENT(*vandup(aELEMENT(*vary),int pos,aELEMENT(*array),int len));
d136 1
a136 1
aELEMENT(*vandup());
d138 1
a138 1
/* aELEMENT(*vadup(aELEMENT(*vary)));
d150 2
a151 2
 */ 
aELEMENT(*vadup());
d153 1
a153 1
/* aELEMENT(*vaset(aELEMENT(*vary),int pos,aELEMENT(element)));
d159 1
a159 1
aELEMENT(*_vaset());
d162 1
a162 1
 (!(v) || (p)>aLen(v) || (p)==aLen(v) && (p)==aSiz(v) ?  \
d165 2
a166 2
  ((p)==aLen(v) ? \
   ((v)[(p)+1]=(v)[p], (v)[p]=(el), aLen(v)=(p)+1, (v)) \
d168 1
a168 1
   (adel((v)[p]), (v)[p]=(el), (v)) \
d170 1
a170 1
 )   
d172 1
a172 1
/* aELEMENT(*vaadd(aELEMENT(*vary),aELEMENT(element)));
d178 2
a179 2
 (!(v) || aLen(v)==aSiz(v) ? \
  _vaset((v),aLEN(v),(el)) \
d181 2
a182 2
  ((v)[aLen(v)+1]=(v)[aLen(v)], (v)[aLen(v)]=(el), \
   aLen(v)=aLen(v)+1, (v)) \
d193 1
a193 1
/* { aELEMENT(*),int } av(aELEMENT(*array));
d196 1
a196 1
#define av(a) (a),aLEN(a)
d198 1
a198 1
/* { aELEMENT(*),int } az(aELEMENT(*array));
d201 1
a201 1
#define az(a) (a),alen(a)
d203 1
a203 1
/* { aELEMENT(*),int } ac(aELEMENT(*array));
d206 1
a206 1
#define ac(a) (a),(sizeof(a)/sizeof(aCAST))
d208 1
a208 1
/* { aELEMENT(*),int } arest(aELEMENT(*vary),int pos);
d212 1
a212 1
#define arest(a,p) ((a)+(p)),(((p)>aLEN(a))?0:aLen(a)-(p))
d214 1
a214 1
/* { aELEMENT(*),int } apart(aELEMENT(*vary),int pos,int len);
d219 2
a220 2
#define apart(a,p,l) \
 ((a)+(p)),((p)>=aLEN(a)?0:((p)+(l)>aLen(a)?aLen(a)-(p):(l)))
d222 1
a222 1
/* aELEMENT(vaget(aELEMENT(*vary),int pos));
d228 1
a228 1
#define vaget(a,p) ((p)>=aLEN(a)?aterm:(a)[p])
d234 1
a234 1
/* aELEMENT(*vasort(aELEMENT(*ary),int len))
d237 1
a237 1
aELEMENT(*vasort());
d239 1
a239 1
/* aELEMENT(*vawords(aELEMENT(*a),char *s,int len,char *sep,int seplen));
d243 1
a243 1
aELEMENT(*vawords());
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
