head	1.10;
access;
symbols
	joe-3_1jupp38:1.10
	joe-3_1jupp37:1.10
	joe-3_1jupp36:1.10
	joe-3_1jupp35:1.10
	joe-3_1jupp34:1.10
	joe-3_1jupp33:1.10
	joe-3_1jupp32:1.10
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.5
	joe-3_1jupp30:1.5
	joe-3_1jupp29:1.5
	joe-3_1jupp28:1.5
	joe-3_1jupp27:1.5
	joe-3_1jupp26:1.5
	joe-3_1jupp25:1.5
	joe-3_1jupp24:1.5
	joe-3_1jupp23:1.5
	joe-3_1jupp22:1.4
	joe-3_1jupp21:1.4
	joe-3_1jupp20:1.4
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.4
	joe-3_1jupp14:1.4
	joe-3_1jupp12:1.3
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.10
date	2017.12.06.23.02.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005A2876FC4FFE7EF5;

1.9
date	2017.12.06.16.38.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005A281D293676CDD2;

1.8
date	2017.12.06.16.37.40;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005A281CE76609B21C;

1.7
date	2017.12.02.04.32.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005A222CF2122034D9;

1.6
date	2017.12.02.02.07.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005A220AD65C90E687;

1.5
date	2012.12.22.00.06.13;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050D4F965570AEE79;

1.4
date	2010.04.08.15.31.03;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004BBDF6C54CC9A0DB;

1.3
date	2008.05.13.13.08.24;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.22;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@lots of fixes related to prototyping
@
text
@/*
 *	Regular expression subroutines
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/regex.c,v 1.9 2017/12/06 16:38:46 tg Exp $");

#include "b.h"
#include "charmap.h"
#include "regex.h"
#include "utils.h"
#include "vs.h"

int
escape(int isutf8, unsigned char **a, int *b)
{
	int c;
	unsigned char *s = *a;
	int l = *b, z;

	if (*s == '\\' && l >= 2) {
		++s; --l;
		switch (*s) {
		case 'n':
			c = 10;
			++s; --l;
			break;
		case 't':
			c = 9;
			++s; --l;
			break;
		case 'a':
			c = 7;
			++s; --l;
			break;
		case 'b':
			c = 8;
			++s; --l;
			break;
		case 'f':
			c = 12;
			++s; --l;
			break;
		case 'e':
			c = 27;
			++s; --l;
			break;
		case 'r':
			c = 13;
			++s; --l;
			break;
		case '8':
			c = 8;
			++s; --l;
			break;
		case '9':
			c = 9;
			++s; --l;
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			z = ustoc_oct(s, &c, l);
			s += z;
			l -= z;
			break;
		case 'x':
		case 'X':
			z = ustoc_hex(s, &c, l);
			s += z;
			l -= z;
			break;
		default:
			if (isutf8)
				c = utf8_decode_fwrd(&s, &l);
			else {
				c = *s++;
				--l;
			}
			break;
		}
	} else if (isutf8) {
		c = utf8_decode_fwrd(&s,&l);
	} else {
		c = *s++;
		--l;
	}
	*a = s;
	*b = l;
	return c;
}

static int brack(int isutf8,unsigned char **a, int *la, int c)
{
	int inverse = 0;
	int flag = 0;
	unsigned char *s = *a;
	int l = *la;

	if (!l)
		return 0;
	if (*s == '^' || *s == '*') {
		inverse = 1;
		++s;
		--l;
	}
	if (l && *s == ']') {
		++s;
		--l;
		if (c == ']')
			flag = 1;
	}
	while (l)
		if (*s == ']') {
			++s;
			--l;
			break;
		} else {
			int cl, cr;

			cl = escape(isutf8, &s, &l);

			if (l >= 2 && s[0] == '-' && s[1] != ']') {
				--l;
				++s;
				cr = escape(isutf8, &s, &l);
				if (c >= cl && c <= cr)
					flag = 1;
			} else if (c == cl)
				flag = 1;
		}
	*a = s;
	*la = l;
	if (inverse)
		return !flag;
	else
		return flag;
}

static void savec(int isutf8,unsigned char **pieces, int n, int c)
{
	unsigned char buf[16];
	int len;
	unsigned char *s = NULL;

	if (isutf8)
		len = utf8_encode(buf,c);
	else {
		buf[0] = c;
		len = 1;
	}

	if (pieces[n])
		vsrm(pieces[n]);
	s = vsncpy(s, 0, buf, len);
	pieces[n] = s;
}

#define MAX_REGEX_SAVED 16384 /* Largest regex string we will save */

static void saves(unsigned char **pieces, int n, P *p, long int szz)
{
	if (szz > MAX_REGEX_SAVED)
		pieces[n] = vstrunc(pieces[n], 0);
	else {
		pieces[n] = vstrunc(pieces[n], (int) szz);
		brmem(p, pieces[n], (int) szz);
	}
}

/* Returns -1 (NO_MORE_DATA) for end of file.
 * Returns -2 if we skipped a special sequence and didn't take the character
 * after it (this happens for "strings").
 * Otherwise returns character after sequence (character will be >=0).
 */

static int skip_special(P *p)
{
	int to, s;

	switch (s = pgetc(p)) {
	case '"':
		do {
			if ((s = pgetc(p)) == '\\') {
				pgetc(p);
				s = pgetc(p);
			}
		} while (s != NO_MORE_DATA && s != '"');
		if (s == '"')
			return -2;
		break;
	case '\'':
		if ((s = pgetc(p)) == '\\') {
			pgetc(p);
			s = pgetc(p);
		}
		if (s == '\'')
			return -2;
		if ((s = pgetc(p)) == '\'')
			return -2;
		if ((s = pgetc(p)) == '\'')
			return -2;
		break;
	case '[':
		to = ']';
		goto skip;
	case '(':
		to = ')';
		goto skip;
	case '{':
		to = '}';
 skip:
		do {
			s = skip_special(p);
		} while (s != to && s != NO_MORE_DATA);
		if (s == to)
			return -2;
		break;
	case '/':
		s = pgetc(p);
		if (s == '*')
			do {
				s = pgetc(p);
				while (s == '*')
					if ((s = pgetc(p)) == '/')
						return -2;
			} while (s != NO_MORE_DATA);
		else if (s != NO_MORE_DATA)
			s = prgetc(p);
		else
			s = '/';
		break;
	}
	return s;
}

int pmatch(unsigned char **pieces, unsigned char *regex, int len, P *p, int n, int icase)
{
	int c, d;
	P *q = pdup(p);
	P *o = NULL;
	int isutf8 = p->b->o.charmap->type;
	struct charmap *map = p->b->o.charmap;
	struct utf8_sm sm;

	utf8_init(&sm);

	while (len) {
		if (isutf8) {
			do {
				c = utf8_decode(&sm,*regex++);
				--len;
			} while (len && c<0);
			if (c<0)
				return 0;
		} else {
			c = *regex++;
			--len;
		}

		switch (c) {
		case '\\':
			if (!len--)
				goto fail;
			switch (c = *regex++) {
			case '?':
				d = pgetc(p);
				if (d == NO_MORE_DATA)
					goto fail;
				savec(isutf8, pieces, n++, d);
				break;
			case 'n':
			case 'r':
			case 'a':
			case 'f':
			case 'b':
			case 't':
			case 'e':
			case 'x':
			case 'X':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				regex -= 2;
				len += 2;
				if (pgetc(p) != escape(isutf8, &regex, &len))
					goto fail;
				break;
			case '*':
				/* Find shortest matching sequence */
				o = pdup(p);
				do {
					long pb = p->byte;

					if (pmatch(pieces, regex, len, p, n + 1, icase)) {
						saves(pieces, n, o, pb - o->byte);
						goto succeed;
					}
					c = pgetc(p);
				} while (c != NO_MORE_DATA && c != '\n');
				goto fail;
			case 'c':
				o = pdup(p);
				do {
					long pb = p->byte;

					if (pmatch(pieces, regex, len, p, n + 1, icase)) {
						saves(pieces, n, o, pb - o->byte);
						goto succeed;
					}
				} while (skip_special(p) != NO_MORE_DATA);
				goto fail;
			case '[':
				d = pgetc(p);
				if (d == NO_MORE_DATA)
					goto fail;
				if (!brack(isutf8, &regex, &len, d))
					goto fail;
				savec(isutf8, pieces, n++, d);
				break;
			case '+':
				{
					unsigned char *oregex = regex;	/* Point to character to skip */
					int olen = len;

					unsigned char *tregex;
					int tlen;

					int match;

					P *r = NULL;

					d = 0;

					o = pdup(p);

					/* Advance over character to skip.  Save character in d unless
					   we're skipping over a \[..] */
					if (len >= 2 && regex[0] == '\\') {
						if (regex[1] == '[') {
							regex += 2;
							len -= 2;
							brack(isutf8, &regex, &len, 0);
						} else {
							d = escape(isutf8, &regex, &len);
							if (icase)
								d = joe_tolower(map,d);
						}
					} else if (isutf8) {
						if ((d = utf8_decode_fwrd(&regex, &len)) < 0)
							goto done;
						else if (icase)
							d = joe_tolower(map,d);
					} else {
						if (len >= 1) {
							--len;
							d = *regex++;
							if (icase)
								d = joe_tolower(map,d);
						} else
							goto done;
					}

					/* Now oregex/olen point to character to skip over and
					   regex/len point to sequence which follows */

					do {
						P *z = pdup(p);

						if (pmatch(pieces, regex, len, p, n + 1, icase)) {
							saves(pieces, n, o, z->byte - o->byte);
							if (r)
								prm(r);
							r = pdup(p);
						}
						pset(p, z);
						prm(z);
						c = pgetc(p);
						tregex = oregex;
						tlen = olen;
						if (*oregex == '\\') {
							if (oregex[1] == '[') {
								tregex += 2;
								tlen -= 2;
								match = brack(isutf8, &tregex, &tlen, c);
							} else
								match = (d == c);
						} else {
							if(icase)
								match = (joe_tolower(map,c) == d);
							else
								match = (c == d);
						}
					} while (c != NO_MORE_DATA && match);
 done:
					if (r) {
						pset(p, r);
						prm(r);
					}
					if (r)
						goto succeed;
					else
						goto fail;
				}
			case '^':
				if (!pisbol(p))
					goto fail;
				break;
			case '$':
				if (!piseol(p))
					goto fail;
				break;
			case '<':
				if (!pisbow(p))
					goto fail;
				break;
			case '>':
				if (!piseow(p))
					goto fail;
				break;
			case '\\':
				d = pgetc(p);
				if (d != c)
					goto fail;
				break;
			default:
				goto fail;
			}
			break;
		default:
			d = pgetc(p);
			if (icase) {
				if (joe_tolower(map,d) != joe_tolower(map,c))
					goto fail;
			} else {
				if (d != c)
					goto fail;
			}
		}
	}
 succeed:
	if (o)
		prm(o);
	prm(q);
	return 1;

 fail:
	if (o)
		prm(o);
	pset(p, q);
	prm(q);
	return 0;
}
@


1.9
log
@don’t use identifiers with trailing underscores
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/regex.c,v 1.6 2017/12/02 02:07:31 tg Exp $");
d15 1
d19 2
a20 1
int escape(int isutf8,unsigned char **a, int *b)
@


1.8
log
@use ustoc_* functions
@
text
@d18 1
a18 1
int escape(int utf8_,unsigned char **a, int *b)
d82 1
a82 1
			if (utf8_)
d90 1
a90 1
	} else if (utf8_) {
d101 1
a101 1
static int brack(int utf8_,unsigned char **a, int *la, int c)
d129 1
a129 1
			cl = escape(utf8_, &s, &l);
d134 1
a134 1
				cr = escape(utf8_, &s, &l);
d148 1
a148 1
static void savec(int utf8_,unsigned char **pieces, int n, int c)
d154 1
a154 1
	if (utf8_)
d220 1
a220 1
skip:
d250 1
a250 1
	int utf8_ = p->b->o.charmap->type;
d257 1
a257 1
		if (utf8_) {
d278 1
a278 1
				savec(utf8_, pieces, n++, d);
d301 1
a301 1
				if (pgetc(p) != escape(utf8_, &regex, &len))
d332 1
a332 1
				if (!brack(utf8_, &regex, &len, d))
d334 1
a334 1
				savec(utf8_, pieces, n++, d);
d358 1
a358 1
							brack(utf8_, &regex, &len, 0);
d360 1
a360 1
							d = escape(utf8_, &regex, &len);
d364 1
a364 1
					} else if (utf8_) {
d400 1
a400 1
								match = brack(utf8_, &tregex, &tlen, c);
d410 1
a410 2

				      done:
d456 1
a456 1
succeed:
d462 1
a462 1
fail:
@


1.7
log
@some fallout of the includes changes, some more reduction
@
text
@d15 1
d22 1
a22 1
	int l = *b;
d71 3
a73 10
			c = *s - '0';
			++s; --l;
			if (l > 0 && *s >= '0' && *s <= '7') {
				c = c * 8 + s[1] - '0';
				++s; --l;
			}
			if (l > 0 && *s >= '0' && *s <= '7') {
				c = c * 8 + s[1] - '0';
				++s; --l;
			}
d77 3
a79 23
			c = 0;
			++s; --l;
			if (l > 0 && *s >= '0' && *s <= '9') {
				c = c * 16 + *s - '0';
				++s; --l;
			} else if (l > 0 && *s >= 'A' && *s <= 'F') {
				c = c * 16 + *s - 'A' + 10;
				++s; --l;
			} else if (l > 0 && *s >= 'a' && *s <= 'f') {
				c = c * 16 + *s - 'a' + 10;
				++s; --l;
			}

			if (l > 0 && *s >= '0' && *s <= '9') {
				c = c * 16 + *s - '0';
				++s; --l;
			} else if (l > 0 && *s >= 'A' && *s <= 'F') {
				c = c * 16 + *s - 'A' + 10;
				++s; --l;
			} else if (l > 0 && *s >= 'a' && *s <= 'f') {
				c = c * 16 + *s - 'a' + 10;
				++s; --l;
			}
@


1.6
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a13 1
#include "utf8.h"
@


1.5
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@a0 1
/* $MirOS: contrib/code/jupp/regex.c,v 1.4 2010/04/08 15:31:03 tg Exp $ */
d11 1
a11 1
#include <stdio.h> 
@


1.4
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/regex.c,v 1.3 2008/05/13 13:08:24 tg Exp $ */
d230 1
a230 1
			s = pgetc(p);
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d19 1
a19 1
int escape(int utf8,unsigned char **a, int *b)
d110 1
a110 1
			if (utf8)
d118 1
a118 1
	} else if (utf8) {
d129 1
a129 1
static int brack(int utf8,unsigned char **a, int *la, int c)
d157 1
a157 1
			cl = escape(utf8, &s, &l);
d162 1
a162 1
				cr = escape(utf8, &s, &l);
d176 1
a176 1
static void savec(int utf8,unsigned char **pieces, int n, int c)
d182 1
a182 1
	if (utf8)
d278 1
a278 1
	int utf8 = p->b->o.charmap->type;
d285 1
a285 1
		if (utf8) {
d306 1
a306 1
				savec(utf8, pieces, n++, d);
d329 1
a329 1
				if (pgetc(p) != escape(utf8, &regex, &len))
d360 1
a360 1
				if (!brack(utf8, &regex, &len, d))
d362 1
a362 1
				savec(utf8, pieces, n++, d);
d376 1
a376 1
					int d = 0;
d386 1
a386 1
							brack(utf8, &regex, &len, 0);
d388 1
a388 1
							d = escape(utf8, &regex, &len);
d392 1
a392 1
					} else if (utf8) {
d428 1
a428 1
								match = brack(utf8, &tregex, &tlen, c);
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@a273 1
        unsigned char buf[20];
d375 1
a375 1
					int d;
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Regular expression subroutines
   Copyright (C) 1992 Joseph H. Allen
d11 1
a11 1
This file is part of JOE (Joe's Own Editor)
d13 4
a16 12
JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d18 156
a173 5
#include "config.h"
#include "zstr.h"
#include "vs.h"
#include "b.h"
#include "regex.h"
d175 1
a175 52
int escape(a,b)
unsigned char **a;
int *b;
 {
 int c;
 unsigned char *s= *a;
 int l= *b;
 if(*s=='\\' && l>=2)
  {
  ++s; --l;
  switch(*s)
   {
  case 'n': c= 10; break; 
  case 't': c= 9; break;
  case 'a': c= 7; break;
  case 'b': c= 8; break;
  case 'f': c= 12; break;
  case 'e': c= 27; break;
  case 'r': c= 13; break;
  case '8': c= 8; break;
  case '9': c= 9; break;

  case '0': case '1': case '2': case '3':
  case '4': case '5': case '6': case '7':
   c= *s-'0';
   if(l>1 && s[1]>='0' && s[1]<='7') c=c*8+s[1]-'0', ++s, --l;
   if(l>1 && s[1]>='0' && s[1]<='7') c=c*8+s[1]-'0', ++s, --l;
  break;

  case 'x': case 'X':
   c=0;
   if(l>1 && s[1]>='0' && s[1]<='9') c=c*16+s[1]-'0', ++s, --l;
   else if(l>1 && s[1]>='A' && s[1]<='F') c=c*16+s[1]-'A'+10, ++s, --l;
   else if(l>1 && s[1]>='a' && s[1]<='f') c=c*16+s[1]-'a'+10, ++s, --l;
   if(l>1 && s[1]>='0' && s[1]<='9') c=c*16+s[1]-'0', ++s, --l;
   else if(l>1 && s[1]>='A' && s[1]<='F') c=c*16+s[1]-'A'+10, ++s, --l;
   else if(l>1 && s[1]>='a' && s[1]<='f') c=c*16+s[1]-'a'+10, ++s, --l;
  break;

  default: c= *s; break;
   }
  ++s; --l;
  }
 else (c= *s++), --l;
 *a= s; *b= l;
 return c;
 }

static int brack(a,la,c)
unsigned char **a;
int *la;
unsigned char c;
d177 15
a191 28
int inverse=0;
int flag=0;
unsigned char *s= *a;
int l= *la;
if(!l) return 0;
if(*s=='^' || *s=='*') inverse=1, ++s, --l;
if(l && *s==']')
 {
 ++s; --l;
 if(c==']') flag=1;
 }
while(l)
 if(*s==']') { ++s; --l; break; }
 else
  {
  int cl, cr;
  cl=escape(&s,&l);
  if(l>=2 && s[0]=='-' && s[1]!=']')
   {
   --l; ++s;
   cr=escape(&s,&l);
   if(c>=cl && c<=cr) flag=1;
   }
  else if(c==cl) flag=1;
  }
*a=s; *la=l;
if(inverse) return !flag;
else return flag;
d194 3
a196 3
static void savec(pieces,n,c)
char *pieces[];
char c;
d198 6
a203 4
char *s=0;
if(pieces[n]) vsrm(pieces[n]);
s=vsncpy(s,0,&c,1);
pieces[n]=s;
d206 7
a212 4
static void saves(pieces,n,p,szz)
char *pieces[];
P *p;
long szz;
d214 56
a269 6
if(szz>=MAXINT-31) pieces[n]=vstrunc(pieces[n],0);
else
 {
 pieces[n]=vstrunc(pieces[n],(int)szz);
 brmem(p,pieces[n],(int)szz);
 }
d272 1
a272 50
static int skip_special(p)
 P *p;
 {
  int to, s;
  switch(s=pgetc(p))
   {
    case '"':
    do
     if((s=pgetc(p))=='\\') pgetc(p), s=pgetc(p);
     while(s!=MAXINT && s!='\"');
    if(s=='\"') return MAXINT-1;
    break;

    case '\'':
    if((s=pgetc(p))=='\\') s=pgetc(p), s=pgetc(p);
    if(s=='\'') return MAXINT-1;
    if((s=pgetc(p))=='\'') return MAXINT-1;
    if((s=pgetc(p))=='\'') return MAXINT-1;
    break;

    case '[': to=']'; goto skip;
    case '(': to=')'; goto skip;
    case '{': to='}';
    skip: do
     s=skip_special(p);
     while(s!=to && s!=MAXINT);
    if(s==to) return MAXINT-1;
    break;

    case '/':
    s=pgetc(p);
    if(s=='*')
     do
      {
      s=pgetc(p);
      while(s=='*') if((s=pgetc(p))=='/') return MAXINT-1;
      } while(s!=MAXINT);
    else
     if(s!=MAXINT) s=prgetc(p);
     else s='/';
    break;

   }
  return s;
 }

int pmatch(pieces,regex,len,p,n,icase)
char *pieces[];
char *regex;
P *p;
d274 211
a484 145
int c,d;
P *q=pdup(p);
P *o=0;
while(len--)
 switch(c= *regex++)
  {
 case '\\':
  if(!len--) goto fail;
  switch(c= *regex++)
   {
  case '?':
   d=pgetc(p);
   if(d== MAXINT) goto fail;
   savec(pieces,n++,(char)d);
   break;

  case 'n': case 'r': case 'a': case 'f': case 'b': case 't': case 'e':
  case 'x': case 'X': case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
   regex-=2; len+=2;
   if(pgetc(p)!= escape(&regex,&len)) goto fail;
   break;

  case '*':
   /* Find shortest matching sequence */
   o=pdup(p);
   do
    {
    long pb=p->byte;
    if(pmatch(pieces,regex,len,p,n+1,icase))
     { saves(pieces,n,o,pb-o->byte); goto succeed; }
    c=pgetc(p);
    }
    while(c!=MAXINT && c!='\n');
   goto fail;
	
  case 'c':
   o=pdup(p);
   do
    {
    long pb=p->byte;
    if(pmatch(pieces,regex,len,p,n+1,icase))
     { saves(pieces,n,o,pb-o->byte); goto succeed; }
    }
    while(skip_special(p)!= MAXINT);
   goto fail;

  case '[':
   d=pgetc(p);
   if(d== MAXINT) goto fail;
   if(!brack(&regex,&len,d)) goto fail;
   savec(pieces,n++,(char)d);
   break;

  case '+':
   {
   char *oregex=regex;	/* Point to character to skip */
   int olen=len;

   char *tregex;
   int tlen;

   P *r=0;
   o=pdup(p);

   /* Advance over character to skip */
   if(len>=2 && regex[0]=='\\' && regex[1]=='[')
    {
    regex+=2;
    len-=2;
    brack(&regex,&len,0);
    }
   else if(len>=1) --len, ++regex;
   else goto done;

   /* Now oregex/olen point to character to skip over and
      regex/len point to sequence which follows */

   do
    {
    P *z=pdup(p);
    if(pmatch(pieces,regex,len,p,n+1,icase))
     {
     saves(pieces,n,o,z->byte-o->byte);
     if(r) prm(r);
     r=pdup(p);
     }
    pset(p,z);
    prm(z);
    c=pgetc(p);
    }
   while(c!=MAXINT &&
          (*oregex=='\\' ?
           (tregex=oregex+2, tlen=olen-2, brack(&tregex,&tlen,c))
          :
           (icase?toup(c)==toup(*oregex):c==*oregex)
          )
        );

   done:
   if(r) pset(p,r), prm(r);
   if(r) goto succeed;
   else goto fail;
   }

  case '^':
   if(!pisbol(p)) goto fail;
   break;

  case '$':
   if(!piseol(p)) goto fail;
   break;

  case '<':
   if(!pisbow(p)) goto fail;
   break;
  
  case '>':
   if(!piseow(p)) goto fail;
   break;
  
  default:
   d=pgetc(p);
   if(icase)
    {
    if(toup(d)!=toup(c)) goto fail;
    }
   else
    {
    if(d!=c) goto fail;
    }
   }
  break;

 default:
  d=pgetc(p);
  if(icase)
   {
   if(toup(d)!=toup(c)) goto fail;
   }
  else
   {
   if(d!=c) goto fail;
   }
  }
d486 4
a489 3
if(o) prm(o);
prm(q);
return 1;
d492 5
a496 4
if(o) prm(o);
pset(p,q);
prm(q);
return 0;
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
