head	1.26;
access;
symbols
	joe-3_1jupp38:1.26
	joe-3_1jupp37:1.25
	joe-3_1jupp36:1.25
	joe-3_1jupp35:1.25
	joe-3_1jupp34:1.25
	joe-3_1jupp33:1.25
	joe-3_1jupp32:1.23
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.14
	joe-3_1jupp30:1.12
	joe-3_1jupp29:1.11
	joe-3_1jupp28:1.9
	joe-3_1jupp27:1.9
	joe-3_1jupp26:1.8
	joe-3_1jupp25:1.8
	joe-3_1jupp24:1.8
	joe-3_1jupp23:1.8
	joe-3_1jupp22:1.6
	joe-3_1jupp21:1.6
	joe-3_1jupp20:1.6
	joe-3_1jupp19:1.4
	joe-3_1jupp18:1.4
	joe-3_1jupp17:1.4
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.4
	joe-3_1jupp15:1.3
	joe-3_1jupp14:1.3
	joe-3_1jupp12:1.2
	joe-3_1jupp11:1.2
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.2
	joe-3_1jupp9:1.2
	joe-3_1jupp8:1.1.201.1
	joe-3_1jupp7:1.1.201.1
	joe-3_1jupp6:1.1.201.1
	joe-3_1jupp5:1.1.201.1
	joe-3_1jupp4:1.1.201.1
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.26
date	2018.11.11.18.15.38;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005BE871D325833018;

1.25
date	2017.12.20.22.22.45;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A3AE2C61352365A;

1.24
date	2017.12.20.22.02.39;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A3ADDE90DC2C759;

1.23
date	2017.12.08.02.57.18;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A29FFA5545539A0;

1.22
date	2017.12.08.02.46.46;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A29FD2A06CBDCE5;

1.21
date	2017.12.08.02.28.06;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A29F8C708B176AB;

1.20
date	2017.12.08.02.00.41;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A29F2506E789D2B;

1.19
date	2017.12.06.21.17.00;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A285E5918D423C7;

1.18
date	2017.12.06.16.37.40;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A281CE76609B21C;

1.17
date	2017.12.03.02.36.02;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A2363204B0C4612;

1.16
date	2017.12.02.04.46.10;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005A22302B04EDF835;

1.15
date	2017.12.02.02.07.32;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005A220AD65C90E687;

1.14
date	2017.08.08.16.12.04;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005989E2EA3534A8E9;

1.13
date	2017.08.08.16.09.43;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005989E25A6D58D2BB;

1.12
date	2017.01.11.22.41.19;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005876B4A80DDE113C;

1.11
date	2016.10.29.23.44.46;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005815347F236258ED;

1.10
date	2016.10.29.21.08.23;	author tg;	state Exp;
branches;
next	1.9;
commitid	10058150FD65CCDA649;

1.9
date	2014.03.04.23.04.12;	author tg;	state Exp;
branches;
next	1.8;
commitid	10053165C030FE8B28B;

1.8
date	2012.12.30.21.45.17;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050E0B5FE41C91584;

1.7
date	2012.12.22.00.06.14;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050D4F965570AEE79;

1.6
date	2012.06.08.17.05.12;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FD230DF587015A2;

1.5
date	2012.06.08.16.55.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FD22E961A7F5A95;

1.4
date	2011.07.16.21.57.57;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004E2209506F4A1334;

1.3
date	2010.04.08.15.31.03;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004BBDF6C54CC9A0DB;

1.2
date	2008.05.13.13.08.26;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482992BC01EE89A1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.23;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@introduce bunch of Coverity fixes

tested/developed up to https://github.com/mirabilos/jupp/commit/19cfaae48e3d9862833eb4e89f05c1083401bccf
@
text
@/*
 *	TERMCAP/TERMINFO database interface
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.24 2017/12/20 22:02:39 tg Exp $");

#include <sys/stat.h>
#include <stdlib.h>

#include "blocks.h"
#include "path.h"
#include "termcap.h"
#include "utils.h"
#include "va.h"
#include "vs.h"

int dopadding = 0;
unsigned char *joeterm = NULL;

/* Default termcap entry */

static const unsigned char defentry[] = "\
:co#80:li#25:am:\
:ho=\\E[H:cm=\\E[%i%d;%dH:cV=\\E[%i%dH:\
:up=\\E[A:UP=\\E[%dA:DO=\\E[%dB:nd=\\E[C:RI=\\E[%dC:LE=\\E[%dD:\
:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:\
:so=\\E[7m:se=\\E[m:us=\\E[4m:ue=\\E[m:\
:mb=\\E[5m:md=\\E[1m:mh=\\E[2m:me=\\E[m:\
:ku=\\E[A:kd=\\E[B:kl=\\E[D:kr=\\E[C:\
:al=\\E[L:AL=\\E[%dL:dl=\\E[M:DL=\\E[%dM:\
:ic=\\E[@@:IC=\\E[%d@@:dc=\\E[P:DC=\\E[%dP:\
";

/* Return true if termcap line matches name */

static int
match(const unsigned char *s, const unsigned char *name)
{
	if (s[0] == 0 || s[0] == '#')
		return 0;
	do {
		int x;

		for (x = 0; s[x] == name[x] && name[x] && s[x]; ++x) ;
		if (name[x] == 0 && (s[x] == ':' || s[x] == '|'))
			return 1;
		while (s[x] != ':' && s[x] != '|' && s[x])
			++x;
		s += x + 1;
	} while (s[-1] == '|');
	return 0;
}

/* Find termcap entry in a file */

static unsigned char *
lfind(unsigned char *s, int pos, FILE *fd, const unsigned char *name)
{
	int c, x;

	if (!s)
		s = vsmk(1024);
 loop:
	while (c = getc(fd), c == ' ' || c == '\t' || c == '#')
		do {
			c = getc(fd);
		} while (c != -1 && c != '\n');
	if (c == -1)
		return s = vstrunc(s, pos);
	ungetc(c, fd);
	s = vstrunc(s, x = pos);
	while (1) {
		c = getc(fd);
		if (c == -1 || c == '\n')
			if (x != pos && s[x - 1] == '\\') {
				--x;
				if (!match(s + pos, name))
					goto loop;
				else
					break;
			} else if (!match(s + pos, name))
				goto loop;
			else
				return vstrunc(s, x);
		else if (c == '\r')
			/* nothing */;
		else {
			s = vsset(s, x, c);
			++x;
		}
	}
	while (c = getc(fd), c != -1)
		if (c == '\n')
			if (s[x - 1] == '\\')
				--x;
			else
				break;
		else if (c == '\r')
			/* nothing */;
		else {
			s = vsset(s, x, c);
			++x;
		}
	s = vstrunc(s, x);
	return s;
}

/* Lookup termcap entry in index */

static off_t
findidx(FILE *file, const unsigned char *name)
{
	unsigned char buf[80];
	off_t addr = 0;

	while (fgets((char *)buf, 80, file)) {
		int x = 0, flg = 0, c, y;

		do {
			for (y = x; buf[y] && buf[y] != ' ' && buf[y] != '\n'; ++y) ;
			c = buf[y];
			buf[y] = 0;
			if (c == '\n' || !c)
				addr += ustol(buf + x, NULL, USTOL_HEX);
			else if (!strcmp(buf + x, name))
				flg = 1;
			x = y + 1;
		} while (c && c != '\n');
		if (flg)
			return addr;
	}
	return 0;
}

/* Load termcap entry */

CAP *getcap(unsigned char *name, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
{
	CAP *cap;
	FILE *f, *f1;
	off_t idx;
	int x, y, c, z, ti;
	unsigned char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
	int sortsiz;

	if (!name && !(name = joeterm) && !(name = (unsigned char *)getenv("TERM")))
		return NULL;
	cap = malloc(sizeof(CAP));
	cap->tbuf = vsmk(4096);
	cap->abuf = NULL;
	cap->sort = NULL;
	cap->paste_on = NULL;
	cap->paste_off = NULL;

	if (!strcmp(name, "xterm-xfree86")) {
		cap->paste_on = "\033[?2004h";
		cap->paste_off = "\033[?2004l";
	}

#ifdef TERMINFO
	cap->abuf = malloc(4096);
	cap->abufp = cap->abuf;
	if (tgetent((char *)cap->tbuf, (char *)name) == 1)
		return setcap(cap, baud, out, outptr);
	else {
		free(cap->abuf);
		cap->abuf = NULL;
	}
#endif

	name = vsncpy(NULL, 0, sz(name));
	cap->sort = malloc(sizeof(struct sortentry) * (sortsiz = 64));

	cap->sortlen = 0;

	tp = (unsigned char *)getenv("TERMCAP");

	if (tp && tp[0] == '/')
		namebuf = vsncpy(NULL, 0, sz(tp));
	else {
		if (tp)
			cap->tbuf = vsncpy(sv(cap->tbuf), sz(tp));
		if ((tp = (unsigned char *)getenv("TERMPATH")))
			namebuf = vsncpy(NULL, 0, sz(tp));
		else {
			if ((tp = (unsigned char *)getenv("HOME"))) {
				namebuf = vsncpy(NULL, 0, sz(tp));
				namebuf = vsadd(namebuf, '/');
			} else
				namebuf = NULL;
			namebuf = vsncpy(sv(namebuf), sc(".termcap "));
			if (has_JOERC &&
			    vsscan(sz(get_JOERC), sc("\t :")) == ~0) {
				namebuf = vsncpy(sv(namebuf), sz(get_JOERC));
				namebuf = vsncpy(sv(namebuf), sc("termcap "));
			}
			namebuf = vsncpy(sv(namebuf), sc("/etc/termcap"));
		}
	}

	npbuf = vawords(NULL, sv(namebuf), sc("\t :"));
	vsrm(namebuf);

	y = 0;
	ti = 0;

	if (match(cap->tbuf, name))
		goto checktc;

	cap->tbuf = vstrunc(cap->tbuf, 0);

 nextfile:
	if (!npbuf[y]) {
		fprintf(stderr, "Couldn't load termcap entry.  Using ansi default\n");
		ti = 0;
		cap->tbuf = vsncpy(cap->tbuf, 0, sc(defentry));
		goto checktc;
	}
	idx = 0;
	idxname = vsncpy(NULL, 0, sz(npbuf[y]));
	idxname = vsncpy(idxname, sLEN(idxname), sc(".idx"));
	f1 = fopen((char *)(npbuf[y]), "r");
	++y;
	if (!f1)
		goto nextfile;
	f = fopen((char *)idxname, "r");
	if (f) {
		struct stat buf, buf1;

		if (fstat(fileno(f), &buf) || fstat(fileno(f1), &buf1))
			fprintf(stderr, "cannot stat termcap index\n");
		else if (buf.st_mtime > buf1.st_mtime)
			idx = findidx(f, name);
		else
			fprintf(stderr, "%s is out of date\n", idxname);
		fclose(f);
	}
	vsrm(idxname);
#ifdef HAVE_FSEEKO
	fseeko(f1, idx, 0);
#else
	/* ugh. SOL! */
	fseek(f1, (long)idx, 0);
#endif
	cap->tbuf = lfind(cap->tbuf, ti, f1, name);
	fclose(f1);
	if (sLEN(cap->tbuf) == ti)
		goto nextfile;

 checktc:
	x = sLEN(cap->tbuf);
	do {
		cap->tbuf[x] = 0;
		while (x && cap->tbuf[--x] != ':')
			/* nothing */;
	} while (x && (!cap->tbuf[x + 1] || cap->tbuf[x + 1] == ':'));

	if (cap->tbuf[x + 1] == 't' && cap->tbuf[x + 2] == 'c' && cap->tbuf[x + 3] == '=') {
		name = vsncpy(NULL, 0, sz(cap->tbuf + x + 4));
		cap->tbuf[x] = 0;
		cap->tbuf[x + 1] = 0;
		ti = x + 1;
		sLen(cap->tbuf) = x + 1;
		if (y)
			--y;
		goto nextfile;
	}

 doline:
	pp = cap->tbuf + ti;

	/* Process line at pp */

 loop:
	while (*pp && *pp != ':')
		++pp;
	if (*pp) {
		int q;

		*pp++ = 0;
 loop1:
		if (pp[0] == ' ' || pp[0] == '\t')
			goto loop;
		for (q = 0; pp[q] && pp[q] != '#' && pp[q] != '=' && pp[q] != '@@' && pp[q] != ':'; ++q) ;
		qq = pp;
		c = pp[q];
		pp[q] = 0;
		if (c)
			pp += q + 1;
		else
			pp += q;

		x = 0;
		y = cap->sortlen;
		z = -1;
		if (!y)
			goto in;
		while (z != (x + y) / 2) {
			int found;

			z = (x + y) / 2;
			found = strcmp(qq, cap->sort[z].name);
			if(found > 0) {
				x = z;
			} else if(found < 0) {
				y = z;
			} else {
				if (c == '@@')
					mmove(cap->sort + z, cap->sort + z + 1, (cap->sortlen-- - (z + 1)) * sizeof(struct sortentry));

				else if (c && c != ':')
					cap->sort[z].value = qq + q + 1;
				else
					cap->sort[z].value = NULL;
				if (c == ':')
					goto loop1;
				else
					goto loop;
			}
		}
 in:
		if (cap->sortlen == sortsiz)
			cap->sort = realloc(cap->sort, (sortsiz += 32) * sizeof(struct sortentry));
		mmove(cap->sort + y + 1, cap->sort + y, (cap->sortlen++ - y) * sizeof(struct sortentry));

		cap->sort[y].name = qq;
		if (c && c != ':')
			cap->sort[y].value = qq + q + 1;
		else
			cap->sort[y].value = NULL;
		if (c == ':')
			goto loop1;
		else
			goto loop;
	}

	if (ti) {
		for (--ti; ti; --ti)
			if (!cap->tbuf[ti - 1])
				break;
		goto doline;
	}

	varm(npbuf);
	vsrm(name);

	cap->pad = jgetstr(cap, UC "pc");
	if (dopadding)
		cap->dopadding = 1;
	else
		cap->dopadding = 0;

/* show sorted entries
	for(x=0;x!=cap->sortlen;++x)
		printf("%s = %s\n",cap->sort[x].name,cap->sort[x].value);
*/
	return setcap(cap, baud, out, outptr);
}

static struct sortentry *
findcap(CAP *cap, const unsigned char *name)
{
	int x, y, z;
	int found;

	x = 0;
	y = cap->sortlen;
	z = -1;
	while (z != (x + y) / 2) {
		z = (x + y) / 2;
		found = strcmp(name, cap->sort[z].name);
		if (found > 0)
			x = z;
		else if (found < 0)
			y = z;
		else
			return cap->sort + z;
	}
	return NULL;
}

CAP *setcap(CAP *cap, unsigned int baud, void (*out) (unsigned char *, unsigned char), void *outptr)
{
	cap->baud = baud;
	cap->div = 100000 / baud;
	cap->out = out;
	cap->outptr = outptr;
	return cap;
}

int
getflag(CAP *cap, const unsigned char *name)
{
#ifdef TERMINFO
	if (cap->abuf)
		return tgetflag((char *)name);
#endif
	return findcap(cap, name) != NULL;
}

const unsigned char *
jgetstr(CAP *cap, const unsigned char *name)
{
	struct sortentry *s;

#ifdef TERMINFO
	if (cap->abuf)
		return (const unsigned char *)tgetstr((char *)name,
		    (char **)&cap->abufp);
#endif
	s = findcap(cap, name);
	if (s)
		return s->value;
	else
		return NULL;
}

int
getnum(CAP *cap, const unsigned char *name)
{
	struct sortentry *s;

#ifdef TERMINFO
	if (cap->abuf)
		return tgetnum((char *)name);
#endif
	s = findcap(cap, name);
	if (s && s->value)
		return atoi((const char *)(s->value));
	return -1;
}

void rmcap(CAP *cap)
{
	vsrm(cap->tbuf);
	if (cap->abuf)
		free(cap->abuf);
	if (cap->sort)
		free(cap->sort);
	free(cap);
}

static unsigned char
escape(const unsigned char **s)
{
	unsigned char c = *(*s)++;
	int i;

	if (c == '^' && **s)
		if (**s != '?')
			return 037 & *(*s)++;
		else {
			(*s)++;
			return 127;
		}
	else if (c == '\\' && **s)
		switch (c = *((*s)++)) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			(*s)--;
			*s += ustoc_oct(*s, &i, USTOC_MAX);
			return i;
		case 'e':
		case 'E':
			return 27;
		case 'n':
		case 'l':
			return 10;
		case 'r':
			return 13;
		case 't':
			return 9;
		case 'b':
			return 8;
		case 'f':
			return 12;
		case 's':
			return 32;
		default:
			return c;
	} else
		return c;
}

#ifdef TERMINFO
static CAP *outcap;
static int outout(int c)
{
	outcap->out(outcap->outptr, c);
	return(c);	/* act like putchar() - return written char */
}
#endif

void
texec(CAP *cap, const unsigned char *s, int l, int a0, int a1, int a2, int a3)
{
	int c, tenth = 0, x;
	int args[4];
	int *a = args;
	int *vars = NULL;

	/* Do nothing if there is no string */
	if (!s)
		return;

#ifdef TERMINFO
	if (cap->abuf) {
		unsigned char *aa;

		outcap = cap;
		aa = (unsigned char *)tgoto((const char *)s, a1, a0);
		tputs((char *)aa, l, outout);
		return;
	}
#endif

	/* Copy args into array (yuk) */
	args[0] = a0;
	args[1] = a1;
	args[2] = a2;
	args[3] = a3;

	/* Get tenths of MS of padding needed */
	while (*s >= '0' && *s <= '9')
		tenth = tenth * 10 + *s++ - '0';
	tenth *= 10;
	if (*s == '.') {
		++s;
		tenth += *s++ - '0';
	}

	/* Check if we have to multiply by number of lines */
	if (*s == '*') {
		++s;
		tenth *= l;
	}

	/* Output string */
	while ((c = *s++) != '\0')
		if (c == '%' && *s) {
			switch (x = a[0], c = escape(&s)) {
			case 'C':
				if (x >= 96) {
					cap->out(cap->outptr, x / 96);
					x %= 96;
				}
				/* FALLTHROUGH */
			case '+':
				if (*s)
					x += escape(&s);
				/* FALLTHROUGH */
			case '.':
				cap->out(cap->outptr, x);
				++a;
				break;
			case 'd':
				if (x < 10)
					goto one;
				/* FALLTHROUGH */
			case '2':
				if (x < 100)
					goto two;
				/* FALLTHROUGH */
			case '3':
				c = '0';
				while (x >= 100) {
					++c;
					x -= 100;
				}
				cap->out(cap->outptr, c);
 two:
				c = '0';
				while (x >= 10) {
					++c;
					x -= 10;
				}
				cap->out(cap->outptr, c);
			      one:cap->out(cap->outptr, '0' + x);
				++a;
				break;
			case 'r':
				a[0] = a[1];
				a[1] = x;
				break;
			case 'i':
				++a[0];
				++a[1];
				break;
			case 'n':
				a[0] ^= 0140;
				a[1] ^= 0140;
				break;
			case 'm':
				a[0] ^= 0177;
				a[1] ^= 0177;
				break;
			case 'f':
				++a;
				break;
			case 'b':
				--a;
				break;
			case 'a':
				x = s[2];
				if (s[1] == 'p')
					x = a[x - 0100];
				switch (*s) {
				case '+':
					a[0] += x;
					break;
				case '-':
					a[0] -= x;
					break;
				case '*':
					a[0] *= x;
					break;
				case '/':
					a[0] /= x;
					break;
				case '%':
					a[0] %= x;
					break;
				case 'l':
					if (vars)
						a[0] = vars[x];
					break;
				case 's':
					if (!vars)
						vars = calloc(256, sizeof(int));
					if (vars)
						vars[x] = a[0];
					break;
				default:
					a[0] = x;
				}
				s += 3;
				break;
			case 'D':
				a[0] = a[0] - 2 * (a[0] & 15);
				break;
			case 'B':
				a[0] = 16 * (a[0] / 10) + a[0] % 10;
				break;
			case '>':
				if (a[0] > escape(&s))
					a[0] += escape(&s);
				else
					escape(&s);
				/* FALLTHROUGH */
			default:
				cap->out(cap->outptr, '%');
				cap->out(cap->outptr, c);
			}
		} else {
			--s;
			cap->out(cap->outptr, escape(&s));
		}

/* Output padding characters */
	if (cap->dopadding) {
		if (cap->pad)
			while (tenth >= cap->div)
				for (s = cap->pad; *s; ++s) {
					cap->out(cap->outptr, *s);
					tenth -= cap->div;
				}
		else
			while (tenth >= cap->div) {
				cap->out(cap->outptr, 0);
				tenth -= cap->div;
			}
	}

	free(vars);
}

static int total;

static void cst(unsigned char *ptr, unsigned char c)
{
	++total;
}

int tcost(CAP *cap, const unsigned char *s, int l, int a0, int a1, int a2, int a3)
{
	void (*out)(unsigned char *, unsigned char) = cap->out;

	if (!s)
		return 10000;
	total = 0;
	cap->out = cst;
	texec(cap, s, l, a0, a1, a2, a3);
	cap->out = out;
	return total;
}

static unsigned char *ssp;
static void cpl(unsigned char *ptr, unsigned char c)
{
	ssp = vsadd(ssp, c);
}

unsigned char *
tcompile(CAP *cap, const unsigned char *s, int a0, int a1, int a2, int a3)
{
	void (*out) (unsigned char *, unsigned char) = cap->out;
	int divider = cap->div;

	if (!s)
		return NULL;
	cap->out = cpl;
	cap->div = 10000;
	ssp = vsmk(10);
	texec(cap, s, 0, a0, a1, a2, a3);
	cap->out = out;
	cap->div = divider;
	return ssp;
}
@


1.25
log
@fix (almost) impossible nil pointer deref plus constify
@
text
@d236 3
a238 3
		fstat(fileno(f), &buf);
		fstat(fileno(f1), &buf1);
		if (buf.st_mtime > buf1.st_mtime)
@


1.24
log
@handle uninitialised vars case in termcap’s arithmetics

also allocate it dynamically (1K heap) instead of upon
function entry (512B stack, ouch!), with the correct
size, and if needed only
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.23 2017/12/08 02:57:18 tg Exp $");
a510 1
	int vars[128];
@


1.23
log
@further cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.22 2017/12/08 02:46:46 tg Exp $");
d513 1
d637 2
a638 1
					a[0] = vars[x];
d641 4
a644 1
					vars[x] = a[0];
d686 2
@


1.22
log
@massive const offensive
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.20 2017/12/08 02:00:41 tg Exp $");
d42 2
a43 1
static int match(unsigned char *s, unsigned char *name)
d62 2
a63 1
static unsigned char *lfind(unsigned char *s, int pos, FILE *fd, unsigned char *name)
d92 1
a92 1
			/* do nothing */;
d105 1
a105 1
			/* do nothing */;
d116 2
a117 1
static off_t findidx(FILE *file, unsigned char *name)
d261 1
a261 1
			/* do nothing */;
d278 1
a278 1
/* Process line at pp */
d302 1
a302 2
		if (!y) {
			/* dead store: z = 0; */
a303 1
		}
d514 1
a514 1
/* Do nothing if there is no string */
d529 1
a529 1
/* Copy args into array (yuk) */
d535 1
a535 1
/* Get tenths of MS of padding needed */
d544 1
a544 1
/* Check if we have to multiply by number of lines */
d550 1
a550 1
/* Output string */
@


1.21
log
@label indent; small tweaks while here
@
text
@d352 1
a352 1
	cap->pad = jgetstr(cap, US "pc");
d365 2
a366 1
static struct sortentry *findcap(CAP *cap, unsigned char *name)
d396 2
a397 1
int getflag(CAP *cap, unsigned char *name)
d406 2
a407 1
unsigned char *jgetstr(CAP *cap, unsigned char *name)
d413 2
a414 1
		return (unsigned char *)tgetstr((char *)name, (char **)&cap->abufp);
d423 2
a424 1
int getnum(CAP *cap, unsigned char *name)
d434 1
a434 1
		return atoi((char *)(s->value));
d448 2
a449 1
static unsigned char escape(unsigned char **s)
d505 2
a506 1
void texec(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3)
d522 1
a522 1
		aa = (unsigned char *)tgoto((char *)s, a1, a0);
d689 1
a689 1
int tcost(CAP *cap, unsigned char *s, int l, int a0, int a1, int a2, int a3)
d691 1
a691 1
	void (*out) (unsigned char *, unsigned char) = cap->out;
d708 2
a709 1
unsigned char *tcompile(CAP *cap, unsigned char *s, int a0, int a1, int a2, int a3)
@


1.20
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.19 2017/12/06 21:17:00 tg Exp $");
d67 1
a67 1
      loop:
d215 1
a215 1
      nextfile:
d253 1
a253 1
      checktc:
d272 1
a272 1
      doline:
d277 1
a277 1
      loop:
d284 1
a284 1
	      loop1:
d326 1
a326 1
	      in:
@


1.19
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.18 2017/12/06 16:37:40 tg Exp $");
d151 1
a151 1
	cap = (CAP *) joe_malloc(sizeof(CAP));
d164 1
a164 1
	cap->abuf = (unsigned char *) joe_malloc(4096);
d169 1
a169 1
		joe_free(cap->abuf);
d175 1
a175 1
	cap->sort = (struct sortentry *) joe_malloc(sizeof(struct sortentry) * (sortsiz = 64));
a216 8
/*
 varm(npbuf);
 vsrm(name);
 vsrm(cap->tbuf);
 joe_free(cap->sort);
 joe_free(cap);
 return 0;
*/
d328 1
a328 1
			cap->sort = (struct sortentry *) joe_realloc(cap->sort, (sortsiz += 32) * sizeof(struct sortentry));
d437 1
a437 1
		joe_free(cap->abuf);
d439 2
a440 2
		joe_free(cap->sort);
	joe_free(cap);
@


1.18
log
@use ustoc_* functions
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/termcap.c,v 1.15 2017/12/02 02:07:32 tg Exp $");
a12 1
#ifdef HAVE_SYS_STAT_H
a13 2
#endif
#ifdef HAVE_STDLIB_H
a14 1
#endif
@


1.17
log
@first cut at getting rid of stdio: scanf half
@
text
@d458 1
d477 3
a479 6
			c -= '0';
			if (**s >= '0' && **s <= '7')
				c = (c << 3) + *((*s)++) - '0';
			if (**s >= '0' && **s <= '7')
				c = (c << 3) + *((*s)++) - '0';
			return c;
@


1.16
log
@WTF‽
@
text
@d124 1
a124 1
		int x = 0, flg = 0, c, y, z;
d130 3
a132 5
			if (c == '\n' || !c) {
				z = 0;
				sscanf((char *)(buf + x), "%x", &z);
				addr += z;
			} else if (!strcmp(buf + x, name))
@


1.15
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a18 4
#ifdef TERMINFO
#ifdef HAVE_TERM_H
#endif
#endif
@


1.14
log
@more GCC 7 weirdness
@
text
@a0 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.8 2012/12/30 21:45:17 tg Exp $ */
d11 2
a12 4
#include <stdio.h>
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
@


1.13
log
@GCC 7 has stricter /* FALLTHROUGH */ rules
@
text
@d82 1
a82 1
		} while (!(c == -1 || c == '\n'));
@


1.12
log
@constify
@
text
@d574 1
d578 1
d586 1
d590 1
d598 2
a599 1
			      two:c = '0';
d672 1
@


1.11
log
@first cut at win32 self-relocation
@
text
@d39 1
a39 1
unsigned char defentry[] = "\
@


1.10
log
@add JOERCtermcap to search path only if it doesn’t contain any delimiters
@
text
@d28 1
d208 3
a210 2
			if (vsscan(sc(JOERC), sc("\t :")) == ~0) {
				namebuf = vsncpy(sv(namebuf), sc(JOERC));
@


1.9
log
@fix compilation on SuSE Linux 1.0
@
text
@d207 5
a211 2
			namebuf = vsncpy(sv(namebuf), sc(JOERC));
			namebuf = vsncpy(sv(namebuf), sc("termcap /etc/termcap"));
@


1.8
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.6 2012/06/08 17:05:12 tg Exp $ */
d258 1
d260 4
@


1.7
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d167 7
@


1.6
log
@enable Large File Support
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.5 2012/06/08 16:55:27 tg Exp $ */
d304 1
a304 1
			z = 0;
@


1.5
log
@nuke junk
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.4 2011/07/16 21:57:57 tg Exp $ */
d124 1
a124 1
static long findidx(FILE *file, unsigned char *name)
d127 1
a127 1
	long addr = 0;
d156 1
a156 1
	long idx;
d251 1
a251 1
	fseek(f1, idx, 0);
@


1.4
log
@fixes from packages.debian.org/joe are merged; now do a warning cleanup
(although some are only a workaround, and the joe code gives the creeps)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.3 2010/04/08 15:31:03 tg Exp $ */
a715 66

/* Old termcap compatibility (not to be used when TERMINFO is set) */
#ifdef junk
short ospeed;			/* Output speed */
unsigned char PC, *UP, *BC;		/* Unused */
static CAP *latest;		/* CAP entry to use */

static void stupid(ptr, c)
void (*ptr) ();
unsigned char c;
{
	ptr(c);
}

int tgetent(buf, name)
unsigned char *buf, *name;
{
	latest = getcap(name, 9600, stupid, NULL);
	if (latest)
		return 1;
	else
		return -1;
}

int tgetflag(name)
unsigned char *name;
{
	return getflag(latest, name);
}

int tgetnum(name)
unsigned char *name;
{
	return getnum(latest, name);
}

unsigned char *tgetstr(name)
unsigned char *name;
{
	return jgetstr(latest, name);
}

static int latestx, latesty;

unsigned char *tgoto(str, x, y)
unsigned char *str;
int x, y;
{
	latestx = x;
	latesty = y;
	return str;
}

void tputs(str, l, out)
unsigned char *str;
int l;
void (*out) ();
{
	latest->outptr = (void *) out;
	if (latest->baud != ospeed) {
		latest->baud = ospeed;
		latest->div = 100000 / ospeed;
	}
	texec(latest, str, l, latesty, latestx);
}
#endif
@


1.3
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/termcap.c,v 1.2 2008/05/13 13:08:26 tg Exp $ */
d496 1
d503 1
@


1.2
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d516 1
a516 1
		unsigned char *a;
d519 2
a520 2
		a = (unsigned char *)tgoto((char *)s, a1, a0);
		tputs((char *)a, l, outout);
d702 1
a702 1
	int div = cap->div;
d711 1
a711 1
	cap->div = div;
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 17
/* TERMCAP/TERMINFO database interface
   Copyright (C) 1992 Joseph H. Allen

This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d12 1
d14 2
d17 9
a25 1
#include "config.h"
d27 3
a30 7
#include "va.h"
#include "zstr.h"
#include "queue.h"
#include "termcap.h"

int dopadding=0;
char *joeterm=0;
d32 2
a33 4
#ifdef TERMINFO
extern char *tgoto();
extern char *tgetstr();
#endif
d37 1
a37 2
char defentry[]=
"\
d51 1
a51 2
static int match(s,name)
char *s, *name;
d53 13
a65 11
if(s[0]==0 || s[0]=='#') return 0;
do
 {
 int x;
 for(x=0;s[x]==name[x] && name[x] && s[x];++x);
 if(name[x]==0 && (s[x]==':' || s[x]=='|')) return 1;
 while(s[x]!=':' && s[x]!='|' && s[x]) ++x;
 s+=x+1;
 }
 while(s[-1]=='|');
return 0;
d70 49
a118 37
static char *lfind(s,pos,fd,name)
char *s, *name;
FILE *fd;
int pos;
{
int c,x;
if(!s) s=vsmk(1024);
loop:
while(c=getc(fd), c==' ' || c=='\t' || c=='#')
 do c=getc(fd); while(!(c== -1 || c=='\n'));
if(c== -1) return s=vstrunc(s,pos);
ungetc(c,fd);
s=vstrunc(s,x=pos);
while(1)
 {
 c=getc(fd);
 if(c== -1 || c=='\n')
  if(x!=pos && s[x-1]=='\\')
   {
   --x;
   if(!match(s+pos,name)) goto loop;
   else break;
   }
  else
   if(!match(s+pos,name)) goto loop;
   else return vstrunc(s,x);
 else if(c=='\r') ;
 else s=vsset(s,x,c), ++x;
 }
while(c=getc(fd), c!= -1)
 if(c=='\n')
  if(s[x-1]=='\\') --x;
  else break;
 else if(c=='\r') ;
 else s=vsset(s,x,c), ++x;
s=vstrunc(s,x);
return s;
d123 24
a146 25
static long findidx(file,name)
FILE *file;
char *name;
{
char buf[80];
long addr=0;
while(fgets(buf,80,file))
 {
 int x=0, flg=0, c, y, z;
 do
  {
  for(y=x;buf[y] && buf[y]!=' ' && buf[y]!='\n';++y);
  c=buf[y]; buf[y]=0;
  if(c=='\n' || !c)
   {
   z=0; sscanf(buf+x,"%x",&z);
   addr+=z;
   }
  else if(!zcmp(buf+x,name)) flg=1;
  x=y+1;
  }
  while(c && c!='\n');
 if(flg) return addr;
 }
return 0;
d151 15
a165 18
CAP *getcap(name,baud,out,outptr)
char *name;
unsigned baud;
void (*out)();
void *outptr;
{
CAP *cap;
FILE *f, *f1;
long idx;
int x,y,c,z,ti;
char *tp, *pp, *qq, *namebuf, **npbuf, *idxname;
int sortsiz;

if(!name && !(name=joeterm) && !(name=getenv("TERM"))) return 0;
cap=(CAP *)malloc(sizeof(CAP));
cap->tbuf=vsmk(4096);
cap->abuf=0;
cap->sort=0;
d168 49
a216 47
cap->abuf=(char *)malloc(4096);
cap->abufp=cap->abuf;
if(tgetent(cap->tbuf,name)==1)
 return setcap(cap,baud,out,outptr);
else
 {
 free(cap->abuf);
 cap->abuf=0;
 }
#endif

name=vsncpy(NULL,0,sz(name));
cap->sort=(struct sortentry *)malloc(sizeof(struct sortentry)*(sortsiz=64));
cap->sortlen=0;

tp=getenv("TERMCAP");

if(tp && tp[0]=='/') namebuf=vsncpy(NULL,0,sz(tp));
else
 {
 if(tp) cap->tbuf=vsncpy(sv(cap->tbuf),sz(tp));
 if((tp=getenv("TERMPATH"))) namebuf=vsncpy(NULL,0,sz(tp));
 else
  {
  if((tp=getenv("HOME")))
   namebuf=vsncpy(NULL,0,sz(tp)),
   namebuf=vsadd(namebuf,'/');
  else
   namebuf=0;
  namebuf=vsncpy(sv(namebuf),sc(".termcap "));
  namebuf=vsncpy(sv(namebuf),sc(JOERC));
  namebuf=vsncpy(sv(namebuf),sc("termcap /etc/termcap"));
  }
 }

npbuf=vawords(NULL,sv(namebuf),sc("\t :"));
vsrm(namebuf);

y=0; ti=0;

if(match(cap->tbuf,name)) goto checktc;

cap->tbuf=vstrunc(cap->tbuf,0);

nextfile:
if(!npbuf[y])
 {
d221 2
a222 2
 free(cap->sort);
 free(cap);
d225 49
a273 46
 fprintf(stderr,"Couldn't load termcap entry.  Using ansi default\n");
 ti=0;
 cap->tbuf=vsncpy(cap->tbuf,0,sc(defentry));
 goto checktc;
 }
idx=0;
idxname=vsncpy(NULL,0,sz(npbuf[y]));
idxname=vsncpy(idxname,sLEN(idxname),sc(".idx"));
f1=fopen(npbuf[y],"r");
++y;
if(!f1) goto nextfile;
f=fopen(idxname,"r");
if(f)
 {
 struct stat buf, buf1;
 fstat(fileno(f),&buf);
 fstat(fileno(f1),&buf1);
 if(buf.st_mtime>buf1.st_mtime) idx=findidx(f,name);
 else fprintf(stderr,"%s is out of date\n",idxname);
 fclose(f);
 }
vsrm(idxname);
fseek(f1,idx,0);
cap->tbuf=lfind(cap->tbuf,ti,f1,name);
fclose(f1);
if(sLEN(cap->tbuf)==ti) goto nextfile;

checktc:
x=sLEN(cap->tbuf);
do
 {
 cap->tbuf[x]=0;
 while(x && cap->tbuf[--x]!=':');
 }
 while(x && (!cap->tbuf[x+1] || cap->tbuf[x+1]==':'));

if(cap->tbuf[x+1]=='t' && cap->tbuf[x+2]=='c' && cap->tbuf[x+3]=='=')
 {
 name=vsncpy(NULL,0,sz(cap->tbuf+x+4));
 cap->tbuf[x]=0;
 cap->tbuf[x+1]=0;
 ti=x+1;
 sLen(cap->tbuf)=x+1;
 if(y) --y;
 goto nextfile;
 }
d275 2
a276 2
doline:
pp=cap->tbuf+ti;
d280 119
a398 97
loop:
while(*pp && *pp!=':') ++pp;
if(*pp)
 {
 int q;
 *pp++=0;
 loop1:
 if(pp[0]==' ' || pp[0]=='\t') goto loop;
 for(q=0;pp[q] && pp[q]!='#' && pp[q]!='=' && pp[q]!='@@' && pp[q]!=':';++q);
 qq=pp;
 c=pp[q]; pp[q]=0;
 if(c) pp+=q+1;
 else pp+=q;

 x=0; y=cap->sortlen; z= -1;
 if(!y) { z=0; goto in; }
 while(z!=(x+y)/2)
  {
  z=(x+y)/2;
  switch(zcmp(qq,cap->sort[z].name))
   {
  case  1: x=z; break;
  case -1: y=z; break;
  case  0:
   if(c=='@@')
    mfwrd(cap->sort+z,cap->sort+z+1,
          (cap->sortlen---(z+1))*sizeof(struct sortentry));
   else
    if(c && c!=':') cap->sort[z].value=qq+q+1;
    else cap->sort[z].value=0;
   if(c==':') goto loop1;
   else goto loop;
   }
  }
 in:
 if(cap->sortlen==sortsiz)
  cap->sort=(struct sortentry *)realloc(cap->sort,
                                        (sortsiz+=32)*sizeof(struct sortentry));
 mbkwd(cap->sort+y+1,cap->sort+y,
       (cap->sortlen++-y)*sizeof(struct sortentry));
 cap->sort[y].name=qq;
 if(c && c!=':') cap->sort[y].value=qq+q+1;
 else cap->sort[y].value=0;
 if(c==':') goto loop1;
 else goto loop;
 }

if(ti)
 {
 for(--ti;ti;--ti) if(!cap->tbuf[ti-1]) break;
 goto doline;
 }

varm(npbuf);
vsrm(name);

cap->pad=jgetstr(cap,"pc");
if(dopadding) cap->dopadding=1;
else cap->dopadding=0;
return setcap(cap,baud,out,outptr);
}

struct sortentry *findcap(cap,name)
CAP *cap;
char *name;
{
int x,y,z;
x=0; y=cap->sortlen; z= -1;
while(z!=(x+y)/2)
 {
 z=(x+y)/2;
 switch(zcmp(name,cap->sort[z].name))
  {
 case  1: x=z; break;
 case -1: y=z; break;
 case  0: return cap->sort+z;
  }
 }
return 0;
}

CAP *setcap(cap,baud,out,outptr)
CAP *cap;
unsigned baud;
void (*out)();
void *outptr;
{
cap->baud=baud;
cap->div=100000/baud;
cap->out=out;
cap->outptr=outptr;
return cap;
}

int getflag(cap,name)
CAP *cap;
char *name;
d401 2
a402 1
if(cap->abuf) return tgetflag(name);
d404 1
a404 1
return findcap(cap,name)!=0;
d407 1
a407 3
char *jgetstr(cap,name)
CAP *cap;
char *name;
d409 2
a410 1
struct sortentry *s;
d412 2
a413 1
if(cap->abuf) return tgetstr(name,&cap->abufp);
d415 5
a419 3
s=findcap(cap,name);
if(s) return s->value;
else return 0;
d422 1
a422 3
int getnum(cap,name)
CAP *cap;
char *name;
d424 2
a425 1
struct sortentry *s;
d427 2
a428 1
if(cap->abuf) return tgetnum(name);
d430 63
a492 41
s=findcap(cap,name);
if(s && s->value) return atoi(s->value);
return -1;
}

void rmcap(cap)
CAP *cap;
{
vsrm(cap->tbuf);
if(cap->abuf) free(cap->abuf);
if(cap->sort) free(cap->sort);
free(cap);
}

static char escape(s)
char **s;
{
char c= *(*s)++;
if(c=='^' && **s)
 if(**s!='?') return 037&*(*s)++;
 else return (*s)++, 127;
else if(c=='\\' && **s)
 switch(c= *((*s)++))
  {
 case '0': case '1': case '2': case'3': case '4': case '5': case '6': case '7':
           c-='0';
           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
           if(**s>='0' && **s<='7') c=(c<<3)+*((*s)++)-'0';
           return c;
 case 'e':
 case 'E': return 27;
 case 'n':
 case 'l': return 10;
 case 'r': return 13;
 case 't': return 9;
 case 'b': return 8;
 case 'f': return 12;
 case 's': return 32;
 default: return c;
  }
else return c;
d496 12
a507 14
static int outout(c)
 {
 outcap->out(outcap->outptr,c);
 }

void texec(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
int c, tenth=0, x;
int args[4];
int vars[128];
int *a=args;
d510 2
a511 1
if(!s) return;
d514 8
a521 8
if(cap->abuf)
 {
 char *a;
 outcap=cap;
 a=tgoto(s,a1,a0);
 tputs(a,l,outout);
 return;
 }
d525 4
a528 1
args[0]=a0; args[1]=a1; args[2]=a2; args[3]=a3;
d531 7
a537 3
while(*s>='0' && *s<='9') tenth=tenth*10+*s++-'0';
tenth*=10;
if(*s=='.') ++s, tenth+= *s++-'0';
d540 4
a543 1
if(*s=='*') ++s, tenth*=l;
d546 109
a654 39
while(c= *s++)
 if(c=='%' && *s)
  switch(x=a[0], c= escape(&s))
   {
  case 'C': if(x>=96) cap->out(cap->outptr,x/96), x%=96;
  case '+': if(*s) x+= escape(&s);
  case '.': cap->out(cap->outptr,x); ++a; break;
  case 'd': if(x<10) goto one;
  case '2': if(x<100) goto two;
  case '3': c='0'; while(x>=100) ++c, x-=100; cap->out(cap->outptr,c);
       two: c='0'; while(x>=10) ++c, x-=10; cap->out(cap->outptr,c);
       one: cap->out(cap->outptr,'0'+x); ++a; break;
  case 'r': a[0]=a[1]; a[1]=x; break;
  case 'i': ++a[0]; ++a[1]; break;
  case 'n': a[0]^=0140; a[1]^=0140; break;
  case 'm': a[0]^=0177; a[1]^=0177; break;
  case 'f': ++a; break;
  case 'b': --a; break;
  case 'a': x=s[2];
            if(s[1]=='p') x=a[x-0100];
            switch(*s)
             {
             case '+': a[0]+=x; break;
             case '-': a[0]-=x; break;
             case '*': a[0]*=x; break;
             case '/': a[0]/=x; break;
             case '%': a[0]%=x; break;
             case 'l': a[0]=vars[x]; break;
             case 's': vars[x]=a[0]; break;
             default:  a[0]=x;
             }
            s+=3;
            break;
  case 'D': a[0]=a[0]-2*(a[0]&15); break;
  case 'B': a[0]=16*(a[0]/10)+a[0]%10; break;
  case '>': if(a[0]>escape(&s)) a[0]+=escape(&s); else escape(&s);
   default: cap->out(cap->outptr,'%'); cap->out(cap->outptr,c);
   }
 else --s, cap->out(cap->outptr,escape(&s));
d657 13
a669 6
if(cap->dopadding)
 if(cap->pad)
  while(tenth>=cap->div)
   for(s=cap->pad;*s;++s) cap->out(cap->outptr,*s), tenth-=cap->div;
 else
  while(tenth>=cap->div) cap->out(cap->outptr,0), tenth-=cap->div;
d674 6
a679 1
static void cst()
d681 9
a689 1
++total;
d692 20
a711 35
int tcost(cap,s,l,a0,a1,a2,a3)
CAP *cap;
char *s;
int l,a0,a1,a2,a3;
{
void (*out)()=cap->out;
if(!s) return 10000;
total=0;
cap->out=cst;
texec(cap,s,l,a0,a1,a2,a3);
cap->out=out;
return total;
}

static char *ssp;
static void cpl(ptr,c)
char *ptr;
char c;
{
ssp=vsadd(ssp,c);
}

char *tcompile(cap,s,a0,a1,a2,a3)
CAP *cap;
char *s;
int a0,a1,a2,a3;
{
void (*out)()=cap->out;
int div=cap->div;
if(!s) return 0;
cap->out=cpl; cap->div=10000;
ssp=vsmk(10);
texec(cap,s,0,a0,a1,a2,a3);
cap->out=out; cap->div=div;
return ssp;
d716 3
a718 3
short ospeed;		/* Output speed */
char PC, *UP, *BC;		/* Unused */
static CAP *latest;	/* CAP entry to use */
d720 3
a722 3
static void stupid(ptr,c)
void (*ptr)();
char c;
d724 1
a724 1
ptr(c);
d727 2
a728 2
int tgetent(buf,name)
char *buf, *name;
d730 5
a734 3
latest=getcap(name,9600,stupid,NULL);
if(latest) return 1;
else return -1;
d738 1
a738 1
char *name;
d740 1
a740 1
return getflag(latest,name);
d744 1
a744 1
char *name;
d746 1
a746 1
return getnum(latest,name);
d749 2
a750 2
char *tgetstr(name)
char *name;
d752 1
a752 1
return jgetstr(latest,name);
d757 3
a759 3
char *tgoto(str,x,y)
char *str;
int x,y;
d761 3
a763 2
latestx=x; latesty=y;
return str;
d766 2
a767 2
void tputs(str,l,out)
char *str;
d769 1
a769 1
void (*out)();
d771 6
a776 3
latest->outptr=(void *)out;
if(latest->baud!=ospeed) latest->baud=ospeed, latest->div=100000/ospeed;
texec(latest,str,l,latesty,latestx);
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
