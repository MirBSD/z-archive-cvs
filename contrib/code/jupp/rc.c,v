head	1.47;
access;
symbols
	joe-3_1jupp38:1.47
	joe-3_1jupp37:1.47
	joe-3_1jupp36:1.47
	joe-3_1jupp35:1.47
	joe-3_1jupp34:1.47
	joe-3_1jupp33:1.46
	joe-3_1jupp32:1.39
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.23
	joe-3_1jupp30:1.22
	joe-3_1jupp29:1.21
	joe-3_1jupp28:1.19
	joe-3_1jupp27:1.19
	joe-3_1jupp26:1.19
	joe-3_1jupp25:1.19
	joe-3_1jupp24:1.19
	joe-3_1jupp23:1.19
	joe-3_1jupp22:1.18
	joe-3_1jupp21:1.18
	joe-3_1jupp20:1.18
	joe-3_1jupp19:1.16
	joe-3_1jupp18:1.15
	joe-3_1jupp17:1.14
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.14
	joe-3_1jupp15:1.14
	joe-3_1jupp14:1.12
	joe-3_1jupp12:1.11
	joe-3_1jupp11:1.7
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.7
	joe-3_1jupp9:1.6
	joe-3_1jupp8:1.6
	joe-3_1jupp7:1.5
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.47
date	2018.02.14.17.45.30;	author tg;	state Exp;
branches;
next	1.46;
commitid	1005A8475D55BA55774;

1.46
date	2018.01.08.00.53.50;	author tg;	state Exp;
branches;
next	1.45;
commitid	1005A52C0FC77D35975;

1.45
date	2018.01.08.00.48.06;	author tg;	state Exp;
branches;
next	1.44;
commitid	1005A52BFDF22C35AF8;

1.44
date	2018.01.07.23.51.34;	author tg;	state Exp;
branches;
next	1.43;
commitid	1005A52B281212EC267;

1.43
date	2018.01.07.17.45.28;	author tg;	state Exp;
branches;
next	1.42;
commitid	1005A525CC03E929F05;

1.42
date	2018.01.06.00.28.32;	author tg;	state Exp;
branches;
next	1.41;
commitid	1005A50184621FA8455;

1.41
date	2017.12.20.23.53.29;	author tg;	state Exp;
branches;
next	1.40;
commitid	1005A3AF80C0779F0C5;

1.40
date	2017.12.20.23.19.15;	author tg;	state Exp;
branches;
next	1.39;
commitid	1005A3AF00342723BA6;

1.39
date	2017.12.08.02.28.05;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005A29F8C708B176AB;

1.38
date	2017.12.08.02.17.22;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005A29F64A06DEB239;

1.37
date	2017.12.08.02.00.40;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005A29F2506E789D2B;

1.36
date	2017.12.08.01.16.37;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005A29E8063D55F339;

1.35
date	2017.12.07.02.10.17;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A28A3145E1FF911;

1.34
date	2017.12.06.23.58.37;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A2884424C3F3AD8;

1.33
date	2017.12.06.23.02.04;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A2876FC4FFE7EF5;

1.32
date	2017.12.06.21.41.02;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A28640547F64250;

1.31
date	2017.12.06.21.16.59;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A285E5918D423C7;

1.30
date	2017.12.04.22.15.38;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A25C91E16B3B365;

1.29
date	2017.12.03.02.36.02;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A2363204B0C4612;

1.28
date	2017.12.02.18.33.24;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A22F1FF5B03A3AC;

1.27
date	2017.12.02.05.04.28;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A22346E09CBC4DE;

1.26
date	2017.12.02.04.32.41;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A222CF2122034D9;

1.25
date	2017.12.02.02.07.30;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A220AD65C90E687;

1.24
date	2017.12.01.23.26.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A21E4F06CA95502;

1.23
date	2017.03.19.19.19.50;	author tg;	state Exp;
branches;
next	1.22;
commitid	10058CED9DF339F2D5D;

1.22
date	2017.01.11.22.04.32;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005876ABFE790F0CC3;

1.21
date	2016.10.29.23.44.45;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005815347F236258ED;

1.20
date	2016.10.08.19.28.54;	author tg;	state Exp;
branches;
next	1.19;
commitid	10057F9490F0ED5540C;

1.19
date	2012.12.30.21.45.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	10050E0B5FE41C91584;

1.18
date	2012.06.08.16.45.00;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004FD22C1A18D0F381;

1.17
date	2012.06.08.16.07.42;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FD223667343C0EE;

1.16
date	2012.06.07.23.38.17;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004FD13B7F5D8CFBBB;

1.15
date	2011.10.04.22.25.52;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004E8B8807642C8708;

1.14
date	2011.07.03.00.35.04;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004E0FB941774BF3C1;

1.13
date	2011.07.02.16.17.06;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004E0F449746AE3E2F;

1.12
date	2010.04.08.15.31.02;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004BBDF6C54CC9A0DB;

1.11
date	2009.10.18.14.52.56;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004ADB2BD317498872;

1.10
date	2009.10.18.14.17.34;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004ADB237E67C2F65E;

1.9
date	2009.10.06.09.07.30;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004ACB08E905F8F83E;

1.8
date	2009.09.16.13.29.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004AB0E84B7173C992;

1.7
date	2008.07.28.00.12.06;	author tg;	state Exp;
branches;
next	1.6;
commitid	100488D0E7907247606;

1.6
date	2006.12.11.23.54.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	100457DEFC626A6A05C;

1.5
date	2006.11.11.01.20.35;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004555256E46D3F998;

1.4
date	2006.11.11.00.22.18;	author tg;	state Exp;
branches;
next	1.3;
commitid	100455517C302E9791B;

1.3
date	2006.11.10.23.23.30;	author tg;	state Exp;
branches;
next	1.2;
commitid	100455509573940FA03;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.22;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.47
log
@minor nit
@
text
@/*
 *	*rc file parser
 *	Copyright
 *		(C) 1992 Joseph H. Allen;
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#define EXTERN_RC_C
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.45 2018/01/08 00:48:06 tg Exp $");

#include <string.h>
#include <stdlib.h>

#ifdef HAVE_BSD_STRING_H
#include <bsd/string.h>
#endif

#include "builtin.h"
#include "cmd.h"
#include "kbd.h"
#include "macro.h"
#include "menu.h"
#include "path.h"
#include "pw.h"
#include "rc.h"
#include "regex.h"
#include "tw.h"
#include "uedit.h"
#include "umath.h"
#include "utils.h"
#include "vs.h"
#include "b.h"
#include "syntax.h"
#include "va.h"
#include "charmap.h"
#include "w.h"

#define OPT_BUF_SIZE	60

/* List of named contexts */
static struct context {
	struct context *next;
	unsigned char *name;
	KMAP *kmap;
} *contexts = NULL;

/*
 * Find a context of a given name; if not found,
 * one with an empty kmap is created.
 */
KMAP *
kmap_getcontext(const unsigned char *name, int docreate)
{
	struct context *c;

	for (c = contexts; c; c = c->next)
		if (!strcmp(c->name, name))
			return c->kmap;

	if (!docreate)
		return (NULL);

	c = malloc(sizeof(struct context));

	c->next = contexts;
	c->name = (unsigned char *)strdup((char *)name);
	contexts = c;
	return c->kmap = mkkmap();
}

OPTIONS *options = NULL;

/* Global variable options */
extern int mid, dspasis, dspctrl, help, square, csmode, nobackups, lightoff, exask, skiptop;
extern int noxon, lines, columns, Baud, dopadding, orphan, marking, keepup, nonotice;
extern int notite, pastetite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer, icase, wrap, autoswap;
extern unsigned char *backpath;

/* Default options for prompt windows */
OPTIONS pdefault = {
	NULL,		/* *next */
	NULL,		/* *name_regex */
	NULL,		/* *contents_regex */
	0,		/* overtype */
	0,		/* lmargin */
	76,		/* rmargin */
	0,		/* autoindent */
	0,		/* wordwrap */
	8,		/* tab */
	' ',		/* indent char */
	1,		/* indent step */
	NULL,		/* *context */
	NULL,		/* *lmsg */
	NULL,		/* *rmsg */
	NULL,		/* *hmsg */
	0,		/* line numbers */
	0,		/* read only */
	0,		/* french spacing */
	0,		/* spaces */
	0,		/* crlf */
	0,		/* Highlight */
	NULL,		/* Syntax name */
	NULL,		/* Syntax */
	NULL,		/* Name of character set */
	NULL,		/* Character set */
	0,		/* Smart home key */
	0,		/* Goto indent first */
	0,		/* Smart backspace key */
	0,		/* Purify indentation */
	0,		/* Picture mode */
	NULL,		/* macro to execute for new files */
	NULL,		/* macro to execute for existing files */
	NULL,		/* macro to execute before saving new files */
	NULL,		/* macro to execute before saving existing files */
	0,		/* visible spaces */
	0		/* hex */
};

/* Default options for file windows */
char main_context[] = "main";
OPTIONS fdefault = {
	NULL,		/* *next */
	NULL,		/* *name_regex */
	NULL,		/* *contents_regex */
	0,		/* overtype */
	0,		/* lmargin */
	76,		/* rmargin */
	0,		/* autoindent */
	0,		/* wordwrap */
	8,		/* tab */
	' ',		/* indent char */
	1,		/* indent step */
	US main_context,		/* *context */
	UC "\\i%n %m %M",		/* *lmsg */
	UC " %S Ctrl-K H for help",	/* *rmsg */
	NULL,		/* *hmsg */
	0,		/* line numbers */
	0,		/* read only */
	0,		/* french spacing */
	0,		/* spaces */
	0,		/* crlf */
	0,		/* Highlight */
	NULL,		/* Syntax name */
	NULL,		/* Syntax */
	NULL,		/* Name of character set */
	NULL,		/* Character set */
	0,		/* Smart home key */
	0,		/* Goto indent first */
	0,		/* Smart backspace key */
	0,		/* Purity indentation */
	0,		/* Picture mode */
	NULL, NULL, NULL, NULL,	/* macros (see above) */
	0,		/* visible spaces */
	0		/* hex */
};

/* Update options */
void
lazy_opts(OPTIONS *o)
{
	o->syntax = load_dfa(o->syntax_name);
	o->charmap = find_charmap(o->map_name);
	if (!o->charmap)
		o->charmap = fdefault.charmap;
	/* Hex not allowed with UTF-8 */
	if (o->hex && o->charmap->type) {
		o->charmap = find_charmap(UC "c");
	}
}

/* Set local options depending on file name and contents */
void
setopt(B *b, const unsigned char *parsed_name)
{
	OPTIONS *o;
	int x;
	unsigned char *pieces[26];
	P *p;

	for (x = 0; x != 26; ++x)
		pieces[x] = NULL;

	for (o = options; o; o = o->next)
		if (rmatch(o->name_regex, parsed_name)) {
			if (!o->contents_regex)
				goto done;
			p = pdup(b->bof);
			x = pmatch(pieces, o->contents_regex,
			    strlen((char *)o->contents_regex), p, 0, 0);
			prm(p);
			if (x)
				goto done;
		}

	b->o = fdefault;
	if (0) {
 done:
		b->o = *o;
	}
	lazy_opts(&b->o);

	for (x = 0; x != 26; ++x)
		vsrm(pieces[x]);
}

/* Table of options and how to set them */

/*
 * local means it's in an OPTION structure,
 * global means it's in a global variable
 */
#define F(x) NULL, &fdefault.x
#define G(type,name,setiaddr,yes,no,menu,low,high) \
	X(type,name,setiaddr,yes,no,menu,low,high)
#define X(type,name,seti,addr,yes,no,menu,low,high) \
	{ UC name, { seti }, US addr, UC yes, UC no, UC menu, 0, type, low, high }
#define L(x) &x, NULL
static struct glopts {
	const unsigned char *name;	/* Option name */
	union {
		int *i;
		unsigned char **us;
	} set;				/* Address of global option */
	unsigned char *addr;		/* Local options structure member address */
	const unsigned char *yes;	/* Message if option was turned on, or prompt string */
	const unsigned char *no;	/* Message if option was turned off */
	const unsigned char *menu;	/* Menu string */
	size_t ofst;			/* Local options structure member offset */
	int type;		/* 0 for global option flag
				   1 for global option numeric
				   2 for global option string
				   4 for local option flag
				   5 for local option numeric
				   6 for local option string
				   7 for local option numeric+1, with range checking
				   8 for ...?
				   9 for syntax
				  13 for encoding
				 */
	int low;		/* Low limit for numeric options */
	int high;		/* High limit for numeric options */
} glopts[] = {
G( 0, "noxon",		L(noxon),	  "XON/XOFF processing disabled", "XON/XOFF processing enabled", "  XON/XOFF usable ", 0, 0),
G( 0, "keepup",		L(keepup),	  "Status line updated constantly", "Status line updated once/sec", "  Fast status line ", 0, 0),
G( 1, "baud",		L(Baud),	  "Terminal baud rate (%d): ", NULL, "  Baud rate ", 0, 38400),
G( 4, "overwrite",	F(overtype),	  "Overtype mode", "Insert mode", "T Overtype ", 0, 0),
G( 4, "autoindent",	F(autoindent),	  "Autoindent enabled", "Autoindent disabled", "I Autoindent ", 0, 0),
G( 4, "wordwrap",	F(wordwrap),	  "Wordwrap enabled", "Wordwrap disabled", "Word wrap ", 0, 0),
G( 5, "tab",		F(tab),		  "Tab width (%d): ", NULL, "D Tab width ", 1, 64),
G( 7, "lmargin",	F(lmargin),	  "Left margin (%d): ", NULL, "Left margin ", 0, 63),
G( 7, "rmargin",	F(rmargin),	  "Right margin (%d): ", NULL, "Right margin ", 7, 255),
G( 0, "square",		L(square),	  "Rectangle mode", "Text-stream mode", "X Rectangle mode ", 0, 0),
G( 0, "icase",		L(icase),	  "Ignore case by default", "Case sensitive by default", "  Case insensitive ", 0, 0),
G( 0, "wrap",		L(wrap),	  "Search wraps", "Search doesn't wrap", "  Search wraps ", 0, 0),
G( 0, "menu_explorer",	L(menu_explorer), "Menu explorer mode", "  Simple completion", "  Menu explorer ", 0, 0),
G( 0, "autoswap",	L(autoswap),	  "Autoswap ^KB and ^KK", "  Autoswap off ", "  Autoswap mode ", 0, 0),
G( 5, "indentc",	F(indentc),	  "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", NULL, "  Indent char ", 0, 255),
G( 5, "istep",		F(istep),	  "Indent step %d (^C to abort): ", NULL, "  Indent step ", 1, 64),
G( 4, "french",		F(french),	  "One space after periods for paragraph reformat", "Two spaces after periods for paragraph reformat", "  French spacing ", 0, 0),
G( 4, "highlight",	F(highlight),	  "Highlighting enabled", "Highlighting disabled", "Highlighting ", 0, 0),
G( 4, "spaces",		F(spaces),	  "Inserting spaces when tab key is hit", "Inserting tabs when tab key is hit", "  Disable tabs ", 0, 0),
G( 0, "mid",		L(mid),		  "Cursor will be recentered on scrolls", "Cursor will not be recentered on scroll", "Center on scroll ", 0, 0),
G( 0, "guess_crlf",	L(guesscrlf),	  "Automatically detect MS-DOS files", "Do not automatically detect MS-DOS files", "  Auto detect CR-LF ", 0, 0),
G( 0, "guess_indent",	L(guessindent),	  "Automatically detect indentation", "Do not automatically detect indentation", "  Guess indent ", 0, 0),
G( 4, "crlf",		F(crlf),	  "CR-LF is line terminator", "LF is line terminator", "Z CR-LF (MS-DOS) ", 0, 0),
G( 4, "linums",		F(linums),	  "Line numbers enabled", "Line numbers disabled", "N Line numbers ", 0, 0),
G( 0, "marking",	L(marking),	  "Anchored block marking on", "Anchored block marking off", "Marking ", 0, 0),
G( 0, "asis",		L(dspasis),	  "Characters above 127 shown as-is", "Characters above 127 shown in inverse", "  Meta chars as-is ", 0, 0),
G( 0, "force",		L(force),	  "Last line forced to have NL when file saved", "Last line not forced to have NL", "Force last NL ", 0, 0),
G( 0, "nobackups",	L(nobackups),	  "Backup files will not be made", "Backup files will be made", "  Disable backups ", 0, 0),
G( 0, "lightoff",	L(lightoff),	  "Highlighting turned off after block operations", "Highlighting not turned off after block operations", "Auto unmark ", 0, 0),
G( 0, "exask",		L(exask),	  "Prompt for filename in save & exit command", "Don't prompt for filename in save & exit command", "  Exit ask ", 0, 0),
G( 0, "beep",		L(dobeep),	  "Warning bell enabled", "Warning bell disabled", "Beeps ", 0, 0),
G( 0, "nosta",		L(staen),	  "Top-most status line disabled", "Top-most status line enabled", "  Disable status ", 0, 0),
G( 1, "pg",		L(pgamnt),	  "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", NULL, "  # PgUp/PgDn lines ", -1, 64),
G( 0, "csmode",		L(csmode),	  "Start search after a search repeats previous search", "Start search always starts a new search", "Continued search ", 0, 0),
G( 4, "rdonly",		F(readonly),	  "Read only", "Full editing", "O Read only ", 0, 0),
G( 4, "smarthome",	F(smarthome),	  "Smart home key enabled", "Smart home key disabled", "  Smart home key ", 0, 0),
G( 4, "indentfirst",	F(indentfirst),	  "Smart home goes to indent first", "Smart home goes home first", "  To indent first ", 0, 0),
G( 4, "smartbacks",	F(smartbacks),	  "Smart backspace key enabled", "Smart backspace key disabled", "  Smart backspace ", 0, 0),
G( 4, "purify",		F(purify),	  "Indentation clean up enabled", "Indentation clean up disabled", "  Clean up indents ", 0, 0),
G( 4, "picture",	F(picture),	  "Picture drawing mode enabled", "Picture drawing mode disabled", "Picture mode ", 0, 0),
X( 2, "backpath",	NULL, NULL,	  "Backup files stored in (%s): ", NULL, "  Backup file path ", 0, 0),
G( 4, "vispace",	F(vispace),	  "Spaces visible", "Spaces invisible", "Visible spaces ", 0, 0),
G( 4, "hex",		F(hex),		  "Hex edit mode", "Text edit mode", "G Hexedit mode ", 0, 0),
X( 9, "syntax",		NULL, NULL,	  "Select syntax (%s; ^C to abort): ", NULL, "Y Syntax", 0, 0),
X(13, "encoding",	NULL, NULL,	  "Select file character set (%s; ^C to abort): ", NULL, "Encoding ", 0, 0),
G( 0, "nonotice",	L(nonotice),	  NULL, NULL, NULL, 0, 0),
G( 0, "orphan",		L(orphan),	  NULL, NULL, NULL, 0, 0),
G( 0, "help",		L(help),	  NULL, NULL, NULL, 0, 0),
G( 0, "dopadding",	L(dopadding),	  NULL, NULL, NULL, 0, 0),
G( 1, "lines",		L(lines),	  NULL, NULL, NULL, 2, 1024),
G( 1, "columns",	L(columns),	  NULL, NULL, NULL, 2, 1024),
G( 1, "skiptop",	L(skiptop),	  NULL, NULL, NULL, 0, 64),
G( 0, "notite",		L(notite),	  NULL, NULL, NULL, 0, 0),
G( 0, "pastetite",	L(pastetite),	  NULL, NULL, NULL, 0, 0),
G( 0, "usetabs",	L(usetabs),	  NULL, NULL, NULL, 0, 0),
G( 0, "assume_color",	L(assume_color),  NULL, NULL, NULL, 0, 0),
X( 0, NULL,		NULL, NULL,	  NULL, NULL, NULL, 0, 0)
};
#undef F
#undef G
#undef L
#undef X

/* Initialize .ofsts above.  Is this really necessary? */

int isiz = 0;

static void izopts(void)
{
	int x;

	for (x = 0; glopts[x].name; ++x)
		switch (glopts[x].type) {
		case 2:
			if (!strcmp((const char *)glopts[x].name, "backpath"))
				glopts[x].set.us = &backpath;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			glopts[x].ofst = glopts[x].addr - (unsigned char *) &fdefault;
		}
	isiz = 1;
}
#define RELOPT(lopts, opt) (*((int *)(((unsigned char *)(lopts)) + glopts[opt].ofst)))

/*-
 * Set a global or local option:
 * 's' is option name
 * 'arg' is a possible argument string (taken only if option has an arg)
 * 'options' points to options structure to modify (can be NULL).
 * 'set'==0: set only in 'options' if it's given.
 * 'set'!=0: set global variable option.
 * return value: no. of fields taken (1 or 2), or 0 if option not found.
 *
 * So this function is used both to set options, and to parse over options
 * without setting them.
 *
 * These combinations are used:
 *
 * glopt(name,arg,NULL,1): set global variable option
 * glopt(name,arg,NULL,0): parse over option
 * glopt(name,arg,options,0): set file local option
 * glopt(name,arg,&fdefault,1): set default file options
 * glopt(name,arg,options,1): set file local option
 */
int
glopt(unsigned char *s, unsigned char *arg, OPTIONS *opts, int set)
{
	int val;
	int ret = 0;
	int st = 1;	/* 1 to set option, 0 to clear it */
	int x;
	void *vp;

	/* Initialize offsets */
	if (!isiz)
		izopts();

	/* Clear instead of set? */
	if (s[0] == '-') {
		st = 0;
		++s;
	}

	for (x = 0; glopts[x].name; ++x)
		if (!strcmp(glopts[x].name, s)) {
			switch (glopts[x].type) {
			case 0:
				/* Global variable flag option */
				if (set)
					*glopts[x].set.i = st;
				break;
			case 1:
				/* Global variable integer option */
				if (set && arg) {
					val = ustolb(arg, &vp, glopts[x].low, glopts[x].high, USTOL_TRIM | USTOL_EOS);
					if (vp)
						*glopts[x].set.i = val;
				}
				break;
			case 2:
				/* Global variable string option */
				if (set)
					*glopts[x].set.us = arg ? (unsigned char *)strdup((char *)arg) : NULL;
				break;
			case 4:
				/* Local option flag */
				if (opts)
					RELOPT(opts, x) = st;
				break;
			case 5:
				/* Local option integer */
				if (arg && opts) {
					val = ustolb(arg, &vp, glopts[x].low, glopts[x].high, USTOL_TRIM | USTOL_EOS);
					if (vp)
						RELOPT(opts, x) = val;
				}
				break;
			case 7:
				/* Local option numeric + 1, with range checking */
				if (arg) {
					val = ustolb(arg, &vp, glopts[x].low, glopts[x].high, USTOL_TRIM | USTOL_EOS);
					if (vp && opts)
						RELOPT(opts, x) = val - 1;
				}
				break;

			case 9:
				/* Set syntax */
				if (arg && opts)
					opts->syntax_name = (unsigned char *)strdup((char *)arg);
				break;

			case 13:
				/* Set byte mode encoding */
				if (arg && opts)
					opts->map_name = (unsigned char *)strdup((char *)arg);
				break;
			}
			/* This is a stupid hack... */
			if ((glopts[x].type & 3) == 0 || !arg)
				return 1;
			else
				return 2;
		}
	/* Why no case 6, string option? */
	/* Keymap, mold, mnew, etc. are not strings */
	/* These options do not show up in ^T */
	if (!strcmp(s, "lmsg")) {
		if (arg) {
			if (opts)
				opts->lmsg = (unsigned char *)strdup((char *)arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "rmsg")) {
		if (arg) {
			if (opts)
				opts->rmsg = (unsigned char *)strdup((char *)arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "hmsg")) {
		if (arg) {
			if (opts)
				opts->hmsg = strdup((char *)arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "keymap")) {
		if (arg) {
			if (opts)
				opts->context = (unsigned char *)strdup((char *)arg);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "mnew")) {
		if (arg) {
			int sta;

			if (opts)
				opts->mnew = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "mold")) {
		if (arg) {
			int sta;

			if (opts)
				opts->mold = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "msnew")) {
		if (arg) {
			int sta;

			if (opts)
				opts->msnew = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	} else if (!strcmp(s, "msold")) {
		if (arg) {
			int sta;

			if (opts)
				opts->msold = mparse(NULL, arg, &sta);
			ret = 2;
		} else
			ret = 1;
	}

	return ret;
}

/* Option setting user interface (^T command) */

/* Menu cursor position: remember it for next time */
static int optx = 0;

static int
doabrt1(BW *bw, int *xx)
{
	free(xx);
	return -1;
}

static int
doopt1(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	int x = *xx;
	long v;

	free(xx);
	switch (glopts[x].type) {
	case 1:
		if (!*s) {
			ret = -1;
			break;
		}
		v = calcl(bw, s);
		if (merrf) {
			msgnw(bw->parent, merrt);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			*glopts[x].set.i = v;
		else {
			msgnw(bw->parent, UC "Value out of range");
			ret = -1;
		}
		break;
	case 2:
		if (s[0])
			*glopts[x].set.us = (unsigned char *)strdup((char *)s);
		break;
	case 5:
		if (!*s) {
			ret = -1;
			break;
		}
		v = calcl(bw, s);
		if (merrf) {
			msgnw(bw->parent, merrt);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			RELOPT(&bw->o, x) = v;
		else {
			msgnw(bw->parent, UC "Value out of range");
			ret = -1;
		}
		break;
	case 7:
		if (!*s) {
			ret = -1;
			break;
		}
		v = calcl(bw, s) - 1L;
		if (merrf) {
			msgnw(bw->parent, merrt);
			ret = -1;
		} else if (v >= glopts[x].low && v <= glopts[x].high)
			RELOPT(&bw->o, x) = v;
		else {
			msgnw(bw->parent, UC "Value out of range");
			ret = -1;
		}
		break;
	}
	vsrm(s);
	bw->b->o = bw->o;
	wfit(bw->parent->t);
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

static int
dosyntax(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	struct high_syntax *syn;

	if (*s) {
		if ((syn = load_dfa(s)))
			bw->o.syntax = syn;
		else
			msgnw(bw->parent, UC "Syntax definition file not found");
	} else
		bw->o.syntax = NULL;

	vsrm(s);
	bw->b->o = bw->o;
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

/* Array of available syntacēs */
unsigned char **syntaxes = NULL;

static int
syntaxcmplt(BW *bw)
{
	if (!syntaxes) {
		unsigned char *oldpwd = pwd();
		unsigned char **t;
		unsigned char *p;
		int x, y;

		if (chJpwd(UC "syntax"))
			return -1;
		t = rexpnd(UC "*.jsf");
		if (!t) {
			chpwd(oldpwd);
			return -1;
		}
		if (!aLEN(t)) {
			varm(t);
			chpwd(oldpwd);
			return -1;
		}

		for (x = 0; x != aLEN(t); ++x) {
			unsigned char *r = vsncpy(NULL,0,t[x],(unsigned char *)strrchr((char *)(t[x]),'.')-t[x]);
			syntaxes = vaadd(syntaxes,r);
		}
		varm(t);

		p = (unsigned char *)getenv("HOME");
		if (p) {
			unsigned char buf[1024];
			joe_snprintf_1((char *)buf,sizeof(buf),"%s/.jupp/syntax",p);
			if (!chpwd(buf) && (t = rexpnd(UC "*.jsf"))) {
				for (x = 0; x != aLEN(t); ++x)
					*strrchr((char *)t[x],'.') = 0;
				for (x = 0; x != aLEN(t); ++x) {
					for (y = 0; y != aLEN(syntaxes); ++y)
						if (!strcmp(t[x],syntaxes[y]))
							break;
					if (y == aLEN(syntaxes)) {
						unsigned char *r = vsncpy(NULL,0,sv(t[x]));
						syntaxes = vaadd(syntaxes,r);
					}
				}
				varm(t);
			}
		}

		vasort(av(syntaxes));
		chpwd(oldpwd);
	}
	return simple_cmplt(bw,syntaxes);
}

static int
check_for_hex(BW *bw)
{
	W *w;
	if (bw->o.hex)
		return 1;
	for (w = bw->parent->link.next; w != bw->parent; w = w->link.next)
		if ((w->watom == &watomtw || w->watom == &watompw) &&
		    w->object.bw->b == bw->b && w->object.bw->o.hex)
			return 1;
	return 0;
}

static int
doencoding(BW *bw, unsigned char *s, int *xx, int *notify)
{
	int ret = 0;
	struct charmap *map;

	if (*s)
		map = find_charmap(s);
	else
		map = fdefault.charmap;

	if (map && map->type && check_for_hex(bw)) {
		vsrm(s);
		msgnw(bw->parent, UC "UTF-8 encoding not allowed with hex-edit windows");
		if (notify)
			*notify = 1;
		return -1;
	}

	if (map) {
		bw->o.charmap = map;
		joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "%s encoding assumed for this file", map->name);
		msgnw(bw->parent, msgbuf);
	} else
		msgnw(bw->parent, UC "Character set not found");

	vsrm(s);
	bw->b->o = bw->o;
	updall();
	if (notify)
		*notify = 1;
	return ret;
}

/* Array of available encodinges */
unsigned char **encodings = NULL;

static int
encodingcmplt(BW *bw)
{
	if (!encodings) {
		encodings = get_encodings();
		vasort(av(encodings));
	}
	return simple_cmplt(bw,encodings);
}

static int
doopt(MENU *m, int x, void *object, int flg)
{
	BW *bw = m->parent->win->object.bw;
	int *xx;
	unsigned char buf[OPT_BUF_SIZE];
	int *notify = m->parent->notify;

	switch (glopts[x].type) {
	case 0:
		if (!flg)
			*glopts[x].set.i = !*glopts[x].set.i;
		else if (flg == 1)
			*glopts[x].set.i = 1;
		else
			*glopts[x].set.i = 0;
		wabort(m->parent);
		msgnw(bw->parent, *glopts[x].set.i ? glopts[x].yes : glopts[x].no);
		if (glopts[x].set.i == &noxon)
			tty_xonoffbaudrst();
		break;
	case 4:
		if (!flg)
			RELOPT(&bw->o, x) = !RELOPT(&bw->o, x);
		else if (flg == 1)
			RELOPT(&bw->o, x) = 1;
		else
			RELOPT(&bw->o, x) = 0;
		wabort(m->parent);
		msgnw(bw->parent, RELOPT(&bw->o, x) ? glopts[x].yes : glopts[x].no);
		/*XXX use offsetof, also in izopts or better statically */
		if (glopts[x].ofst == (unsigned char *) &fdefault.readonly - (unsigned char *) &fdefault)
			bw->b->rdonly = bw->o.readonly;
		/* Kill UTF-8 and CR-LF mode if we switch to hex display */
		if (glopts[x].ofst == (unsigned char *)&fdefault.hex - (unsigned char *)&fdefault &&
		    bw->o.hex) {
			if (bw->b->o.charmap->type) {
				doencoding(bw, vsncpy(NULL, 0, sc("c")),
				    NULL, NULL);
			}
			bw->o.crlf = 0;
		}
		break;
	case 1:
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *glopts[x].set.i);
		xx = malloc(sizeof(int));

		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map)) {
			if (glopts[x].set.i == &Baud)
				tty_xonoffbaudrst();
			return 0;
		} else
			return -1;
	case 2:
		if (*glopts[x].set.us)
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *glopts[x].set.us);
		else
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
		xx = malloc(sizeof(int));

		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
			return 0;
		else
			return -1;
	case 5:
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE,
		    (const char *)glopts[x].yes, RELOPT(&bw->o, x));
		goto in;
	case 7:
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE,
		    (const char *)glopts[x].yes, RELOPT(&bw->o, x) + 1);
 in:
		xx = malloc(sizeof(int));

		*xx = x;
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
			return 0;
		else
			return -1;

	case 9:
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes,
		    bw->b->o.syntax ? bw->b->o.syntax->name : UC "(unset)");
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, dosyntax, NULL, NULL, syntaxcmplt, NULL, notify, locale_map))
			return 0;
		else
			return -1;

	case 13:
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes,
		    bw->b->o.charmap ? bw->b->o.charmap->name : UC "(unset)");
		m->parent->notify = 0;
		wabort(m->parent);
		if (wmkpw(bw->parent, buf, NULL, doencoding, NULL, NULL, encodingcmplt, NULL, notify, locale_map))
			return 0;
		else
			return -1;
	}
	if (notify)
		*notify = 1;
	bw->b->o = bw->o;
	wfit(bw->parent->t);
	updall();
	return 0;
}

static int
doabrt(MENU *m, int x, unsigned char **s)
{
	optx = x;
	for (x = 0; s[x]; ++x)
		free(s[x]);
	free(s);
	return -1;
}

int
umode(BW *bw)
{
	size_t size = 0, x, len;
	unsigned char **s;

	bw->b->o.readonly = bw->o.readonly = bw->b->rdonly;
	while (glopts[size].menu)
		++size;
	s = ralloc(size + 1, sizeof(unsigned char *));
	len = 0;
	for (x = 0; x < size; ++x) {
		s[x] = malloc(OPT_BUF_SIZE);
		if (glopts[x].menu[0] == ' ' || glopts[x].menu[1] == ' ')
			strlcpy(s[x], glopts[x].menu, OPT_BUF_SIZE);
		else {
			strlcpy(s[x] + 2, glopts[x].menu, OPT_BUF_SIZE);
			s[x][0] = s[x][2];
			s[x][1] = ' ';
		}
		if (strlen(s[x]) > len)
			len = strlen(s[x]);
	}
	for (x = 0; x < size; ++x) {
		size_t n = strlen(s[x]);

		while (len - n)
			s[x][n++] = ' ';
		switch (glopts[x].type) {
		case 0:
			joe_snprintf_1(s[x] + n, OPT_BUF_SIZE - n,
			    "%s", *glopts[x].set.i ? "ON" : "OFF");
			break;
		case 1:
			joe_snprintf_1(s[x] + n, OPT_BUF_SIZE - n,
			    "%d", *glopts[x].set.i);
			break;
		case 2:
			strlcpy(s[x] + n, "...", OPT_BUF_SIZE - n);
			break;
		case 4:
			joe_snprintf_1(s[x] + n, OPT_BUF_SIZE - n,
			    "%s", RELOPT(&bw->o, x) ? "ON" : "OFF");
			break;
		case 5:
			joe_snprintf_1(s[x] + n, OPT_BUF_SIZE - n,
			    "%d", RELOPT(&bw->o, x));
			break;
		case 7:
			joe_snprintf_1(s[x] + n, OPT_BUF_SIZE - n,
			    "%d", RELOPT(&bw->o, x) + 1);
			break;
		case 9:
			/* XXX aligns differently so it doesn't get too large */
			joe_snprintf_2(s[x] + 12, OPT_BUF_SIZE - 12, "%*s", (int)n - 9,
			    bw->b->o.syntax ? bw->b->o.syntax->name : UC "(unset)");
			break;
		case 13:
			/* XXX aligns differently so it doesn't get too large */
			joe_snprintf_2(s[x] + 12, OPT_BUF_SIZE - 12, "%*s", (int)n - 9,
			    bw->b->o.charmap ? bw->b->o.charmap->name : UC "(unset)");
			break;
		default:
			s[x][n] = '\0';
		}
	}
	s[x] = NULL;
	if (mkmenu(bw->parent, s, doopt, doabrt, NULL, optx, s, NULL))
		return 0;
	else
		return -1;
}

/*-
 * Process rc file
 * Returns 0 if the rc file was succefully processed
 *        -1 if the rc file couldn't be opened
 *         1 if there was a syntax error in the file
 */
int
procrc(CAP *cap, const unsigned char *name)
{
	OPTIONS *o = &fdefault;	/* Current options */
	KMAP *context = NULL;	/* Current context */
	unsigned char buf[1024];/* Input buffer */
	JFILE *fd;		/* rc file */
	int line = 0;		/* Line number */
	int err = 0;		/* Set to 1 if there was a syntax error */
	int x, c, y, sta;
	unsigned char *opt, *arg;
	MACRO *m;

	if (!(fd = jfopen(name, "r")))
		/* return if we couldn't open the rc file */
		return (-1);

	fprintf(stderr, "Processing '%s'...", name);
	fflush(stderr);

	while (jfgets(buf, sizeof(buf), fd)) {
		line++;
		switch (buf[0]) {
		case ' ':
		case '\t':
		case '\n':
		case '\f':
		case 0:
			/* skip comment lines */
			break;
		case '*':
			/* select file types for file type-dependent options */
			o = malloc(sizeof(OPTIONS));
			*o = fdefault;
			x = 0;
			while (buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t')
				++x;
			buf[x] = 0;
			o->next = options;
			options = o;
			o->name_regex = (unsigned char *)strdup((char *)buf);
			break;
		case '+':
			/* Set file contents match regex */
			x = 0;
			while (buf[x] && buf[x] != '\n' && buf[x] != '\r')
				++x;
			buf[x] = 0;
			if (o)
				o->contents_regex = (unsigned char *)strdup((char *)(buf+1));
			break;
		case '-':
			/* Set an option */
			opt = buf + 1;
			arg = NULL;
			x = 0;
			while (buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t')
				++x;
			if (buf[x] && buf[x] != '\n') {
				buf[x] = 0;
				arg = buf + ++x;
				while (buf[x] && buf[x] != '\n')
					++x;
			}
			buf[x] = 0;
			if (!glopt(opt, arg, o, 2)) {
				err = 1;
				fprintf(stderr, "\n%s:%d: Unknown option '%s'", name, line, opt);
			}
			break;
		case '{':
			/* Ignore help text */
			while (jfgets(buf, sizeof(buf), fd) && buf[0] != /*{*/'}')
				/* do nothing */;
			if (buf[0] != '}') {
				err = 1;
				fprintf(stderr, "\n%s:%d: End of rc file occurred before end of help text\n", name, line);
				break;
			}
			break;
		case ':':
			/* Select context */
			x = 1;
			while (!joe_isspace_eof(locale_map,buf[x]))
				++x;
			c = buf[x];
			buf[x] = 0;
			if (x != 1)
				if (!strcmp(buf + 1, "def")) {
					for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
					for (y = x; !joe_isspace_eof(locale_map,buf[y]); ++y) ;
					c = buf[y];
					buf[y] = 0;
					if (y == x) {
						err = 1;
						fprintf(stderr, "\n%s:%d: command name missing from :def", name, line);
					} else if (joe_isblank(locale_map, c) &&
					    (m = mparse(NULL, buf + y + 1, &sta)))
						addcmd(buf + x, m);
					else {
						err = 1;
						fprintf(stderr, "\n%s:%d: macro missing from :def", name, line);
					}
				} else if (!strcmp(buf + 1, "inherit"))
					if (context) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
						buf[c] = 0;
						if (c != x)
							kcpy(context, kmap_getcontext(buf + x, 1));
						else {
							err = 1;
							fprintf(stderr, "\n%s:%d: context name missing from :inherit", name, line);
						}
					} else {
						err = 1;
						fprintf(stderr, "\n%s:%d: No context selected for :inherit", name, line);
				} else if (!strcmp(buf + 1, "include")) {
					for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
					for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
					buf[c] = 0;
					if (c != x) {
						switch (procrc(cap, buf + x)) {
						case 1:
							err = 1;
							break;
						case -1:
							fprintf(stderr, "\n%s:%d: Couldn't open %s", name, line, buf + x);
							err = 1;
							break;
						}
						context = 0;
						o = &fdefault;
					} else {
						err = 1;
						fprintf(stderr, "\n%s:%d: :include missing file name", name, line);
					}
				} else if (!strcmp(buf + 1, "delete"))
					if (context) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1]
														!= ' '); ++y) ;
						buf[y] = 0;
						kdel(context, buf + x);
					} else {
						err = 1;
						fprintf(stderr, "\n%s:%d: No context selected for :delete", name, line);
				} else
					context = kmap_getcontext(buf + 1, 1);
			else {
				err = 1;
				fprintf(stderr, "\n%s:%d: Invalid context name", name, line);
			}
			break;
		default:
			/* Get key-sequence to macro binding */
			if (!context) {
				err = 1;
				fprintf(stderr, "\n%s:%d: No context selected for macro to key-sequence binding", name, line);
				break;
			}

			m = NULL;
 macroloop:
			m = mparse(m, buf, &x);
			if (x == -1) {
				err = 1;
				fprintf(stderr, "\n%s:%d: Unknown command in macro", name, line);
				break;
			} else if (x == -2) {
				jfgets(buf, sizeof(buf), fd);
				goto macroloop;
			}
			if (!m)
				break;

			/* Skip to end of key sequence */
			for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1] != ' '); ++y) ;
			buf[y] = 0;

			/* Add binding to context */
			if (kadd(cap, context, buf + x, m) == -1) {
				fprintf(stderr, "\n%s:%d: Bad key sequence '%s'", name, line, buf + x);
				err = 1;
			}
			break;
		}
	}
	/* close rc file */
	jfclose(fd);

	/* Print proper ending string */
	fprintf(stderr, "%cdone\n", err ? '\n' : ' ');

	/* 0 for success, 1 for syntax error */
	return (err);
}
@


1.46
log
@fix spelling:

while “dependant” is correct British English for someone depending
on their liege, “something-dependent” was meant here
@
text
@d920 1
a920 1
	s[x] = 0;
@


1.45
log
@this is ugly enough, and jfgets mirrors fgets which gets an int ipv size_t,
but clean it up at least a little
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.43 2018/01/07 17:45:28 tg Exp $");
d964 1
a964 1
			/* Select file types for file-type dependant options */
@


1.44
log
@new ralloc(x,y) = malloc(x*y) with checks, but not, unlike calloc,
with implizit size_t casting nor memory cleansing
@
text
@d934 1
a934 1
procrc(CAP *cap, unsigned char *name)
d946 3
a948 5
	strlcpy((char *)buf, (char *)name, 1024);
	fd = jfopen((char *)buf, "r");

	if (!fd)
		return -1;	/* Return if we couldn't open the rc file */
d953 1
a953 1
	while (jfgets((char *)buf, sizeof(buf), fd)) {
d1005 1
a1005 1
			while ((jfgets((char *)buf, 256, fd)) && (buf[0] != /*{*/ '}'))
d1009 1
a1009 1
				fprintf(stderr, "\n%s:%d: End of joerc file occurred before end of help text\n", name, line);
d1103 1
a1103 1
				jfgets((char *)buf, 1024, fd);
@


1.43
log
@*** empty log message ***
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.42 2018/01/06 00:28:32 tg Exp $");
d863 1
a863 1
	s = calloc(size + 1, sizeof(unsigned char *));
@


1.42
log
@merge fixes from gitlab branch; highlights:

Date:   Fri Dec 22 20:02:27 2017 +0100
    string sharing

Date:   Fri Dec 22 20:07:43 2017 +0100
    glopts can be static

Date:   Fri Dec 22 20:34:12 2017 +0100
    largish code cleanup

Date:   Fri Dec 22 20:58:59 2017 +0100
    major const cleanup

Date:   Sat Dec 23 01:41:49 2017 +0100
    fix refactoro: this code is run in a loop, reinitialise each time

Date:   Sat Jan 6 00:54:10 2018 +0100
    fix regression: `` did no longer insert a sole ` (etc.)
    also, factor out common code and optimise it

Date:   Sat Jan 6 01:05:42 2018 +0100
    2018

Date:   Sat Jan 6 01:05:47 2018 +0100
    more const cleanup while here

also, update NEWS
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.41 2017/12/20 23:53:29 tg Exp $");
d332 1
d397 1
a397 1
					*(int *) ((unsigned char *) opts + glopts[x].ofst) = st;
d404 1
a404 2
						*(int *) ((unsigned char *)
							  opts + glopts[x].ofst) = val;
d412 1
a412 2
						*(int *) ((unsigned char *)
							  opts + glopts[x].ofst) = val - 1;
d557 1
a557 1
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
d573 1
a573 1
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = v;
d751 1
a751 1
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = !*(int *) ((unsigned char *) &bw->o + glopts[x].ofst);
d753 1
a753 1
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 1;
d755 1
a755 1
			*(int *) ((unsigned char *) &bw->o + glopts[x].ofst) = 0;
d757 2
a758 1
		msgnw(bw->parent, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? glopts[x].yes : glopts[x].no);
d799 2
a800 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d803 2
a804 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d896 1
a896 1
			    "%s", *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d900 1
a900 1
			    "%d", *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d904 1
a904 1
			    "%d", *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
@


1.41
log
@another leaked string
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.40 2017/12/20 23:19:15 tg Exp $");
d43 1
d48 1
a48 1
} *contexts = NULL;		/* List of named contexts */
d50 3
a52 2
/* Find a context of a given name- if not found, one with an empty kmap
 * is created.
d54 2
a55 2

KMAP *kmap_getcontext(unsigned char *name, int docreate)
a82 1

a122 1

d136 3
a138 3
	US main_context,	/* *context */
	US "\\i%n %m %M",	/* *lmsg */
	US " %S Ctrl-K H for help",	/* *rmsg */
d161 2
a162 2

void lazy_opts(OPTIONS *o)
d175 2
a176 2

void setopt(B *b, const unsigned char *parsed_name)
d181 3
a183 1
	for (x = 0; x!=26; ++x)
d188 7
a194 13
			if(o->contents_regex) {
				P *p = pdup(b->bof);
				if (pmatch(pieces,o->contents_regex,strlen((char *)o->contents_regex),p,0,0)) {
					prm(p);
					b->o = *o;
					lazy_opts(&b->o);
					goto done;
				} else {
					prm(p);
				}
			} else {
				b->o = *o;
				lazy_opts(&b->o);
a195 1
			}
d199 4
d205 1
a205 2
 done:
	for (x = 0; x!=26; ++x)
d211 4
a214 3
/* local means it's in an OPTION structure, global means it's in a global
 * variable */

d221 1
a221 1
struct glopts {
d333 2
a334 1
/* Set a global or local option:
d353 2
a354 2

int glopt(unsigned char *s, unsigned char *arg, OPTIONS *options_, int set)
d375 2
a376 1
			case 0: /* Global variable flag option */
d380 2
a381 1
			case 1: /* Global variable integer option */
d388 4
a391 7
			case 2: /* Global variable string option */
				if (set) {
					if (arg)
						*glopts[x].set.us = (unsigned char *)strdup((char *)arg);
					else
						*glopts[x].set.us = NULL;
				}
d393 4
a396 3
			case 4: /* Local option flag */
				if (options_)
					*(int *) ((unsigned char *) options_ + glopts[x].ofst) = st;
d398 3
a400 2
			case 5: /* Local option integer */
				if (arg && options_) {
d404 1
a404 1
							  options_ + glopts[x].ofst) = val;
d407 2
a408 1
			case 7: /* Local option numeric + 1, with range checking */
d411 1
a411 1
					if (vp && options_)
d413 1
a413 1
							  options_ + glopts[x].ofst) = val - 1;
d417 4
a420 6
			case 9: /* Set syntax */
				if (arg && options_)
					options_->syntax_name = (unsigned char *)strdup((char *)arg);
				/* this was causing all syntax files to be loaded...
				if (arg && options_)
					options_->syntax = load_dfa(arg); */
d423 4
a426 3
			case 13: /* Set byte mode encoding */
				if (arg && options_)
					options_->map_name = (unsigned char *)strdup((char *)arg);
d440 2
a441 2
			if (options_)
				options_->lmsg = (unsigned char *)strdup((char *)arg);
d447 2
a448 2
			if (options_)
				options_->rmsg = (unsigned char *)strdup((char *)arg);
d454 2
a455 2
			if (options_)
				options_->hmsg = strdup((char *)arg);
d461 2
a462 2
			if (options_)
				options_->context = (unsigned char *)strdup((char *)arg);
d470 2
a471 2
			if (options_)
				options_->mnew = mparse(NULL, arg, &sta);
d479 2
a480 2
			if (options_)
				options_->mold = mparse(NULL, arg, &sta);
d488 2
a489 2
			if (options_)
				options_->msnew = mparse(NULL, arg, &sta);
d497 2
a498 2
			if (options_)
				options_->msold = mparse(NULL, arg, &sta);
d509 2
a510 1
static int optx = 0; /* Menu cursor position: remember it for next time */
d512 2
a513 1
static int doabrt1(BW *bw, int *xx)
d519 2
a520 1
static int doopt1(BW *bw, unsigned char *s, int *xx, int *notify)
d590 2
a591 1
static int dosyntax(BW *bw, unsigned char *s, int *xx, int *notify)
d612 2
a613 1
unsigned char **syntaxes = NULL; /* Array of available syntaxes */
d615 2
a616 1
static int syntaxcmplt(BW *bw)
d624 1
a624 1
		if (chJpwd(US ("syntax")))
d626 1
a626 1
		t = rexpnd(US "*.jsf");
d647 1
a647 1
			if (!chpwd(buf) && (t = rexpnd(US "*.jsf"))) {
d682 2
a683 1
static int doencoding(BW *bw, unsigned char *s, int *xx, int *notify)
d716 2
a717 1
unsigned char **encodings = NULL; /* Array of available encodinges */
d719 2
a720 1
static int encodingcmplt(BW *bw)
d729 2
a730 1
static int doopt(MENU *m, int x, void *object, int flg)
d765 1
a765 1
				doencoding(bw, vsncpy(NULL, 0, sc("C")),
d826 1
a826 1
		    bw->b->o.charmap ? bw->b->o.charmap->name : US "(unset)");
d842 2
a843 1
static int doabrt(MENU *m, int x, unsigned char **s)
d852 2
a853 1
int umode(BW *bw)
d855 1
a855 1
	size_t size, x, len;
d859 2
a860 1
	for (size = 0; glopts[size].menu; ++size) ;
d907 1
a907 1
			    bw->b->o.syntax ? bw->b->o.syntax->name : US "(unset)");
d912 1
a912 1
			    bw->b->o.charmap ? bw->b->o.charmap->name : US "(unset)");
d925 2
a926 1
/* Process rc file
d931 2
a932 2

int procrc(CAP *cap, unsigned char *name)
d936 1
a936 1
	unsigned char buf[1024];	/* Input buffer */
d940 3
d961 22
a982 13
			break;	/* Skip comment lines */
		case '*':	/* Select file types for file-type dependant options */
			{
				int x;

				o = malloc(sizeof(OPTIONS));
				*o = fdefault;
				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t'; ++x) ;
				buf[x] = 0;
				o->next = options;
				options = o;
				o->name_regex = (unsigned char *)strdup((char *)buf);
			}
d984 8
a991 5
		case '+':	/* Set file contents match regex */
			{
				int x;

				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != '\r'; ++x) ;
d993 3
a995 2
				if (o)
					o->contents_regex = (unsigned char *)strdup((char *)(buf+1));
d997 4
a1000 17
			break;
		case '-':	/* Set an option */
			{
				unsigned char *opt = buf + 1;
				int x;
				unsigned char *arg = NULL;

				for (x = 0; buf[x] && buf[x] != '\n' && buf[x] != ' ' && buf[x] != '\t'; ++x) ;
				if (buf[x] && buf[x] != '\n') {
					buf[x] = 0;
					for (arg = buf + ++x; buf[x] && buf[x] != '\n'; ++x) ;
				}
				buf[x] = 0;
				if (!glopt(opt, arg, o, 2)) {
					err = 1;
					fprintf(stderr, "\n%s:%d: Unknown option '%s'", name, line, opt);
				}
d1003 8
a1010 9
		case '{':	/* Ignore help text */
			{
				while ((jfgets((char *)buf, 256, fd)) && (buf[0] != /*{*/ '}'))
					/* do nothing */;
				if (buf[0] != '}') {
					err = 1;
					fprintf(stderr, "\n%s:%d: End of joerc file occurred before end of help text\n", name, line);
					break;
				}
d1013 25
a1037 11
		case ':':	/* Select context */
			{
				int x, c;

				for (x = 1; !joe_isspace_eof(locale_map,buf[x]); ++x) ;
				c = buf[x];
				buf[x] = 0;
				if (x != 1)
					if (!strcmp(buf + 1, "def")) {
						int y;

d1039 5
a1043 15
						for (y = x; !joe_isspace_eof(locale_map,buf[y]); ++y) ;
						c = buf[y];
						buf[y] = 0;
						if (y != x) {
							int sta;
							MACRO *m;

							if (joe_isblank(locale_map,c)
							    && (m = mparse(NULL, buf + y + 1, &sta)))
								addcmd(buf + x, m);
							else {
								err = 1;
								fprintf(stderr, "\n%s:%d: macro missing from :def", name, line);
							}
						} else {
d1045 1
a1045 1
							fprintf(stderr, "\n%s:%d: command name missing from :def", name, line);
d1047 10
a1056 12
					} else if (!strcmp(buf + 1, "inherit"))
						if (context) {
							for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
							for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
							buf[c] = 0;
							if (c != x)
								kcpy(context, kmap_getcontext(buf + x, 1));
							else {
								err = 1;
								fprintf(stderr, "\n%s:%d: context name missing from :inherit", name, line);
							}
						} else {
d1058 3
a1060 18
							fprintf(stderr, "\n%s:%d: No context selected for :inherit", name, line);
					} else if (!strcmp(buf + 1, "include")) {
						for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
						for (c = x; !joe_isspace_eof(locale_map,buf[c]); ++c) ;
						buf[c] = 0;
						if (c != x) {
							switch (procrc(cap, buf + x)) {
							case 1:
								err = 1;
								break;
							case -1:
								fprintf(stderr, "\n%s:%d: Couldn't open %s", name, line, buf + x);
								err = 1;
								break;
							}
							context = 0;
							o = &fdefault;
						} else {
d1062 1
a1062 1
							fprintf(stderr, "\n%s:%d: :include missing file name", name, line);
d1064 21
a1084 18
					} else if (!strcmp(buf + 1, "delete"))
						if (context) {
							int y;

							for (buf[x] = c; joe_isblank(locale_map,buf[x]); ++x) ;
							for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1]
															!= ' '); ++y) ;
							buf[y] = 0;
							kdel(context, buf + x);
						} else {
							err = 1;
							fprintf(stderr, "\n%s:%d: No context selected for :delete", name, line);
					} else
						context = kmap_getcontext(buf + 1, 1);
				else {
					err = 1;
					fprintf(stderr, "\n%s:%d: Invalid context name", name, line);
				}
d1087 7
a1093 10
		default:	/* Get key-sequence to macro binding */
			{
				int x, y;
				MACRO *m;

				if (!context) {
					err = 1;
					fprintf(stderr, "\n%s:%d: No context selected for macro to key-sequence binding", name, line);
					break;
				}
d1095 1
a1095 1
				m = 0;
d1097 11
a1107 11
				m = mparse(m, buf, &x);
				if (x == -1) {
					err = 1;
					fprintf(stderr, "\n%s:%d: Unknown command in macro", name, line);
					break;
				} else if (x == -2) {
					jfgets((char *)buf, 1024, fd);
					goto macroloop;
				}
				if (!m)
					break;
d1109 8
a1116 9
				/* Skip to end of key sequence */
				for (y = x; buf[y] != 0 && buf[y] != '\t' && buf[y] != '\n' && (buf[y] != ' ' || buf[y + 1] != ' '); ++y) ;
				buf[y] = 0;

				/* Add binding to context */
				if (kadd(cap, context, buf + x, m) == -1) {
					fprintf(stderr, "\n%s:%d: Bad key sequence '%s'", name, line, buf + x);
					err = 1;
				}
d1121 2
a1122 1
	jfclose(fd);		/* Close rc file */
d1125 1
a1125 4
	if (err)
		fprintf(stderr, "\ndone\n");
	else
		fprintf(stderr, "done\n");
d1127 2
a1128 1
	return err;		/* 0 for success, 1 for syntax error */
@


1.40
log
@fix nil pointer deref in error path
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.39 2017/12/08 02:28:05 tg Exp $");
d170 1
a170 1
		o->charmap = find_charmap(US "c");
@


1.39
log
@label indent; small tweaks while here
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.38 2017/12/08 02:17:22 tg Exp $");
d176 1
a176 1
void setopt(B *b, unsigned char *parsed_name)
@


1.38
log
@more small tweaks
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.36 2017/12/08 01:16:37 tg Exp $");
d206 1
a206 1
	done:
d1092 1
a1092 1
			      macroloop:
@


1.37
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d671 1
a671 1
		    	return 1;
@


1.36
log
@fix a couple of prompt window result string memory leaks
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.34 2017/12/06 23:58:37 tg Exp $");
d64 1
a64 1
	c = (struct context *) joe_malloc(sizeof(struct context));
d512 1
a512 1
	joe_free(xx);
d522 1
a522 1
	joe_free(xx);
d762 1
a762 1
		xx = (int *) joe_malloc(sizeof(int));
d778 1
a778 1
		xx = (int *) joe_malloc(sizeof(int));
d792 2
a793 1
	      in:xx = (int *) joe_malloc(sizeof(int));
d835 2
a836 2
		joe_free(s[x]);
	joe_free(s);
d847 1
a847 1
	s = (unsigned char **) joe_malloc(sizeof(unsigned char *) * (size + 1));
d850 1
a850 1
		s[x] = (unsigned char *) joe_malloc(OPT_BUF_SIZE);
d948 1
a948 1
				o = (OPTIONS *) joe_malloc(sizeof(OPTIONS));
@


1.35
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d686 1
@


1.34
log
@make wmkpw const again
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.32 2017/12/06 21:41:02 tg Exp $");
d669 2
a670 2
		if ((w->watom == &watomtw || w->watom == &watompw) && ((BW *)w->object)->b == bw->b &&
		    ((BW *)w->object)->o.hex)
d720 1
a720 1
	BW *bw = m->parent->win->object;
@


1.33
log
@lots of fixes related to prototyping
@
text
@d803 1
a803 1
		    bw->b->o.syntax ? bw->b->o.syntax->name : US "(unset)");
@


1.32
log
@const cleanup
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.30 2017/12/04 22:15:38 tg Exp $");
d28 1
d662 2
a663 1
int check_for_hex(BW *bw)
@


1.31
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d535 1
a535 1
			msgnw(bw->parent, US "Value out of range");
d555 1
a555 1
			msgnw(bw->parent, US "Value out of range");
d571 1
a571 1
			msgnw(bw->parent, US "Value out of range");
d594 1
a594 1
			msgnw(bw->parent, US "Syntax definition file not found");
d684 1
a684 1
		msgnw(bw->parent, US "UTF-8 encoding not allowed with hex-edit windows");
d695 1
a695 1
		msgnw(bw->parent, US "Character set not found");
@


1.30
log
@clean up some unused/MS-DOS® stuff
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.29 2017/12/03 02:36:02 tg Exp $");
a14 1
#ifdef HAVE_STDLIB_H
a15 1
#endif
@


1.29
log
@first cut at getting rid of stdio: scanf half
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.28 2017/12/02 18:33:24 tg Exp $");
a102 3
#ifdef __MSDOS__
	1,		/* crlf */
#else
a103 1
#endif
a144 3
#ifdef __MSDOS__
	1,		/* crlf */
#else
a145 1
#endif
a924 3
#ifdef __MSDOS__
	fd = jfopen((char *)buf, "rt");
#else
a925 1
#endif
@


1.28
log
@fix strict aliasing problems \o/
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/rc.c,v 1.25 2017/12/02 02:07:30 tg Exp $");
d229 1
a229 1
	{ UC name, { seti }, US addr, UC yes, UC no, UC menu, type, 0, low, high }
d241 1
a252 1
	int ofst;		/* Local options structure member offset */
d369 1
d390 2
a391 2
					sscanf((char *)arg, "%d", &val);
					if (val >= glopts[x].low && val <= glopts[x].high)
d408 5
a412 7
				if (arg) {
					if (options_) {
						sscanf((char *)arg, "%d", &val);
						if (val >= glopts[x].low && val <= glopts[x].high)
							*(int *) ((unsigned char *)
								  options_ + glopts[x].ofst) = val;
					}
d417 4
a420 9
					int zz = 0;

					sscanf((char *)arg, "%d", &zz);
					if (zz >= glopts[x].low && zz <= glopts[x].high) {
						--zz;
						if (options_)
							*(int *) ((unsigned char *)
								  options_ + glopts[x].ofst) = zz;
					}
@


1.27
log
@idfk why mgcc(1) wants to verarsch me here…
@
text
@d4 1
a4 1
 *		(C) 1992 Joseph H. Allen; 
d225 6
d232 10
a241 2
	unsigned char *name;		/* Option name */
	int type;		/*      0 for global option flag
d248 3
a251 5
	int *set;		/* Address of global option */
	unsigned char *addr;		/* Local options structure member address */
	unsigned char *yes;		/* Message if option was turned on, or prompt string */
	unsigned char *no;		/* Message if option was turned off */
	unsigned char *menu;		/* Menu string */
d256 57
a312 57
	{US "noxon",	0, &noxon, NULL, US "XON/XOFF processing disabled", US "XON/XOFF processing enabled", US "  XON/XOFF usable " },
	{US "keepup",	0, &keepup, NULL, US "Status line updated constantly", US "Status line updated once/sec", US "  Fast status line " },
	{US "baud",	1, &Baud, NULL, US "Terminal baud rate (%d): ", 0, US "  Baud rate ", 0, 0, 38400 },
	{US "overwrite",4, NULL, (unsigned char *) &fdefault.overtype, US "Overtype mode", US "Insert mode", US "T Overtype " },
	{US "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, US "Autoindent enabled", US "Autoindent disabled", US "I Autoindent " },
	{US "wordwrap",	4, NULL, (unsigned char *) &fdefault.wordwrap, US "Wordwrap enabled", US "Wordwrap disabled", US "Word wrap " },
	{US "tab",	5, NULL, (unsigned char *) &fdefault.tab, US "Tab width (%d): ", 0, US "D Tab width ", 0, 1, 64 },
	{US "lmargin",	7, NULL, (unsigned char *) &fdefault.lmargin, US "Left margin (%d): ", 0, US "Left margin ", 0, 0, 63 },
	{US "rmargin",	7, NULL, (unsigned char *) &fdefault.rmargin, US "Right margin (%d): ", 0, US "Right margin ", 0, 7, 255 },
	{US "square",	0, &square, NULL, US "Rectangle mode", US "Text-stream mode", US "X Rectangle mode " },
	{US "icase",	0, &icase, NULL, US "Ignore case by default", US "Case sensitive by default", US "  Case insensitive " },
	{US "wrap",	0, &wrap, NULL, US "Search wraps", US "Search doesn't wrap", US "  Search wraps " },
	{US "menu_explorer",	0, &menu_explorer, NULL, US "Menu explorer mode", US "  Simple completion", US "  Menu explorer " },
	{US "autoswap",	0, &autoswap, NULL, US "Autoswap ^KB and ^KK", US "  Autoswap off ", US "  Autoswap mode " },
	{US "indentc",	5, NULL, (unsigned char *) &fdefault.indentc, US "Indent char %d (SPACE=32, TAB=9, ^C to abort): ", 0, US "  Indent char ", 0, 0, 255 },
	{US "istep",	5, NULL, (unsigned char *) &fdefault.istep, US "Indent step %d (^C to abort): ", 0, US "  Indent step ", 0, 1, 64 },
	{US "french",	4, NULL, (unsigned char *) &fdefault.french, US "One space after periods for paragraph reformat", US "Two spaces after periods for paragraph reformat", US "  French spacing " },
	{US "highlight",	4, NULL, (unsigned char *) &fdefault.highlight, US "Highlighting enabled", US "Highlighting disabled", US "Highlighting " },
	{US "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, US "Inserting spaces when tab key is hit", US "Inserting tabs when tab key is hit", US "  Disable tabs " },
	{US "mid",	0, &mid, NULL, US "Cursor will be recentered on scrolls", US "Cursor will not be recentered on scroll", US "Center on scroll " },
	{US "guess_crlf",0, &guesscrlf, NULL, US "Automatically detect MS-DOS files", US "Do not automatically detect MS-DOS files", US "  Auto detect CR-LF " },
	{US "guess_indent",0, &guessindent, NULL, US "Automatically detect indentation", US "Do not automatically detect indentation", US "  Guess indent " },
	{US "crlf",	4, NULL, (unsigned char *) &fdefault.crlf, US "CR-LF is line terminator", US "LF is line terminator", US "Z CR-LF (MS-DOS) " },
	{US "linums",	4, NULL, (unsigned char *) &fdefault.linums, US "Line numbers enabled", US "Line numbers disabled", US "N Line numbers " },
	{US "marking",	0, &marking, NULL, US "Anchored block marking on", US "Anchored block marking off", US "Marking " },
	{US "asis",	0, &dspasis, NULL, US "Characters above 127 shown as-is", US "Characters above 127 shown in inverse", US "  Meta chars as-is " },
	{US "force",	0, &force, NULL, US "Last line forced to have NL when file saved", US "Last line not forced to have NL", US "Force last NL " },
	{US "nobackups",	0, &nobackups, NULL, US "Backup files will not be made", US "Backup files will be made", US "  Disable backups " },
	{US "lightoff",	0, &lightoff, NULL, US "Highlighting turned off after block operations", US "Highlighting not turned off after block operations", US "Auto unmark " },
	{US "exask",	0, &exask, NULL, US "Prompt for filename in save & exit command", US "Don't prompt for filename in save & exit command", US "  Exit ask " },
	{US "beep",	0, &dobeep, NULL, US "Warning bell enabled", US "Warning bell disabled", US "Beeps " },
	{US "nosta",	0, &staen, NULL, US "Top-most status line disabled", US "Top-most status line enabled", US "  Disable status " },
	{US "pg",		1, &pgamnt, NULL, US "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, US "  # PgUp/PgDn lines ", 0, -1, 64 },
	{US "csmode",	0, &csmode, NULL, US "Start search after a search repeats previous search", US "Start search always starts a new search", US "Continued search " },
	{US "rdonly",	4, NULL, (unsigned char *) &fdefault.readonly, US "Read only", US "Full editing", US "O Read only " },
	{US "smarthome",	4, NULL, (unsigned char *) &fdefault.smarthome, US "Smart home key enabled", US "Smart home key disabled", US "  Smart home key " },
	{US "indentfirst",	4, NULL, (unsigned char *) &fdefault.indentfirst, US "Smart home goes to indent first", US "Smart home goes home first", US "  To indent first " },
	{US "smartbacks",	4, NULL, (unsigned char *) &fdefault.smartbacks, US "Smart backspace key enabled", US "Smart backspace key disabled", US "  Smart backspace " },
	{US "purify",	4, NULL, (unsigned char *) &fdefault.purify, US "Indentation clean up enabled", US "Indentation clean up disabled", US "  Clean up indents " },
	{US "picture",	4, NULL, (unsigned char *) &fdefault.picture, US "Picture drawing mode enabled", US "Picture drawing mode disabled", US "Picture mode " },
	{US "backpath",	2, (int *) &backpath, NULL, US "Backup files stored in (%s): ", 0, US "  Backup file path " },
	{US "vispace",	4, NULL, (unsigned char *) &fdefault.vispace, US "Spaces visible", US "Spaces invisible", US "Visible spaces " },
	{US "hex",	4, NULL, (unsigned char *) &fdefault.hex, US "Hex edit mode", US "Text edit mode", US "G Hexedit mode "},
	{US "syntax",	9, NULL, NULL, US "Select syntax (%s; ^C to abort): ", 0, US "Y Syntax" },
	{US "encoding",13, NULL, NULL, US "Select file character set (%s; ^C to abort): ", 0, US "Encoding " },
	{US "nonotice",	0, &nonotice, NULL, 0, 0, 0 },
	{US "orphan",	0, &orphan, NULL, 0, 0, 0 },
	{US "help",	0, &help, NULL, 0, 0, 0 },
	{US "dopadding",	0, &dopadding, NULL, 0, 0, 0 },
	{US "lines",	1, &lines, NULL, 0, 0, 0, 0, 2, 1024 },
	{US "columns",	1, &columns, NULL, 0, 0, 0, 0, 2, 1024 },
	{US "skiptop",	1, &skiptop, NULL, 0, 0, 0, 0, 0, 64 },
	{US "notite",	0, &notite, NULL, 0, 0, 0 },
	{US "pastetite", 0, &pastetite, NULL, 0, 0, 0 },
	{US "usetabs",	0, &usetabs, NULL, 0, 0, 0 },
	{US "assume_color", 0, &assume_color, NULL, 0, 0, 0 },
	{ NULL,		0, NULL, NULL, NULL, NULL, NULL, 0, 0, 0 }
d314 4
d329 4
d385 1
a385 1
					*glopts[x].set = st;
d391 1
a391 1
						*glopts[x].set = val;
d397 1
a397 1
						*(unsigned char **) glopts[x].set = (unsigned char *)strdup((char *)arg);
d399 1
a399 1
						*(unsigned char **) glopts[x].set = 0;
d413 1
a413 1
					} 
d549 1
a549 1
			*glopts[x].set = v;
d557 1
a557 1
			*(unsigned char **) glopts[x].set = (unsigned char *)strdup((char *)s);
d742 1
a742 1
			*glopts[x].set = !*glopts[x].set;
d744 1
a744 1
			*glopts[x].set = 1;
d746 1
a746 1
			*glopts[x].set = 0;
d748 2
a749 2
		msgnw(bw->parent, *glopts[x].set ? glopts[x].yes : glopts[x].no);
		if (glopts[x].set == &noxon)
d774 1
a774 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *glopts[x].set);
d781 1
a781 1
			if (glopts[x].set == &Baud)
d787 2
a788 2
		if (*(unsigned char **) glopts[x].set)
			joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, *(unsigned char **) glopts[x].set);
d881 1
a881 1
			    "%s", *glopts[x].set ? "ON" : "OFF");
d885 1
a885 1
			    "%d", *glopts[x].set);
@


1.26
log
@some fallout of the includes changes, some more reduction
@
text
@d560 1
a560 1
		v = calcldec(bw, s);
@


1.25
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
a38 1
#include "utf8.h"
@


1.24
log
@add a level of indirection: never use math’s calc() outside of umath

in the places where we used it, we now have calcl() which takes the
same arguments, evaluates its second parameter (in the context BW of
the first), but returns it as long; calcldec() subtracts 1.0 first

this confines all floating point operations into umath.?
@
text
@a0 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.23 2017/03/19 19:19:50 tg Exp $ */
d8 1
d12 2
a13 1
#include <stdio.h>
@


1.23
log
@_some_ type cleanup (time_t, sig_atomic_t)

still unsafe signal handler crap abound :(
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.16 2012/06/07 23:38:17 tg Exp $ */
d515 1
a515 1
	int v;
d524 1
a524 1
		v = calc(bw, s);
d544 1
a544 1
		v = calc(bw, s);
d560 1
a560 1
		v = calc(bw, s) - 1.0;
@


1.22
log
@use ~/.jupp/ (for now) not ~/.joe/ to not conflict with joe 4.x
@
text
@d525 2
a526 2
		if (merr) {
			msgnw(bw->parent, merr);
d545 2
a546 2
		if (merr) {
			msgnw(bw->parent, merr);
d561 2
a562 2
		if (merr) {
			msgnw(bw->parent, merr);
@


1.21
log
@first cut at win32 self-relocation
@
text
@d634 1
a634 1
			joe_snprintf_1((char *)buf,sizeof(buf),"%s/.joe/syntax",p);
@


1.20
log
@lintian fixes
@
text
@d612 1
a612 1
		if (chpwd(US (JOERC "syntax")))
@


1.19
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d987 1
a987 1
					fprintf(stderr, "\n%s:%d: End of joerc file occured before end of help text\n", name, line);
@


1.18
log
@disable CR-LF when enabling hex mode – this time, for real
@
text
@d54 1
a54 1
KMAP *kmap_getcontext(unsigned char *name)
d61 4
d78 1
a78 1
extern int notite, usetabs, assume_color, guesscrlf, guessindent, menu_explorer, icase, wrap, autoswap;
d128 1
d141 1
a141 1
	US "main",		/* *context */
d297 1
d1028 1
a1028 1
								kcpy(context, kmap_getcontext(buf + x));
d1069 1
a1069 1
						context = kmap_getcontext(buf + 1);
@


1.17
log
@enabling hex mode disables crlf mode (a must)
@
text
@d172 3
a174 7
	if (o->hex) {
		/* UTF-8 not allowed with hex mode */
		if (o->charmap->type) {
			o->charmap = find_charmap(US "c");
		}
		/* CR-LF and hex mode do not mix */
		o->crlf = 0;
d737 8
a744 5
		/* Kill UTF-8 mode if we switch to hex display */
		if (glopts[x].ofst == (unsigned char *) &fdefault.hex - (unsigned char *) &fdefault &&
		    bw->o.hex &&
		    bw->b->o.charmap->type) {
			doencoding(bw, vsncpy(NULL, 0, sc("C")), NULL, NULL);
@


1.16
log
@use less (slightly different) copies of licences, and allow (even static) linking with an {,L}GPLv[23]{,+} libc/libtermcap/libselinux/…
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.15 2011/10/04 22:25:52 tg Exp $ */
d172 7
a178 3
	/* Hex not allowed with UTF-8 */
	if (o->hex && o->charmap->type) {
		o->charmap = find_charmap(US "c");
@


1.15
log
@Unbreak passing -keymap on the command line
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.14 2011/07/03 00:35:04 tg Exp $ */
a7 9
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
@


1.14
log
@dynamic help string needed, e.g. jpico has ^G for help…
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.13 2011/07/02 16:17:06 tg Exp $ */
d458 1
a458 6
			int y;

			for (y = 0; !joe_isspace(locale_map,arg[y]); ++y) ;
			if (!arg[y])
				arg[y] = 0;
			if (options_ && y)
@


1.13
log
@Better error messages when parsing syntax and rc files
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.12 2010/04/08 15:31:02 tg Exp $ */
d103 1
d148 1
d449 7
@


1.12
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.11 2009/10/18 14:52:56 tg Exp $ */
d973 1
a973 1
					fprintf(stderr, "\n%s %d: Unknown option %s", name, line, opt);
d983 1
a983 1
					fprintf(stderr, "\n%s %d: End of joerc file occured before end of help text\n", name, line);
d1012 1
a1012 1
								fprintf(stderr, "\n%s %d: macro missing from :def", name, line);
d1016 1
a1016 1
							fprintf(stderr, "\n%s %d: command name missing from :def", name, line);
d1027 1
a1027 1
								fprintf(stderr, "\n%s %d: context name missing from :inherit", name, line);
d1031 1
a1031 1
							fprintf(stderr, "\n%s %d: No context selected for :inherit", name, line);
d1042 1
a1042 1
								fprintf(stderr, "\n%s %d: Couldn't open %s", name, line, buf + x);
d1050 1
a1050 1
							fprintf(stderr, "\n%s %d: :include missing file name", name, line);
d1063 1
a1063 1
							fprintf(stderr, "\n%s %d: No context selected for :delete", name, line);
d1068 1
a1068 1
					fprintf(stderr, "\n%s %d: Invalid context name", name, line);
d1079 1
a1079 1
					fprintf(stderr, "\n%s %d: No context selected for macro to key-sequence binding", name, line);
d1088 1
a1088 1
					fprintf(stderr, "\n%s %d: Unknown command in macro", name, line);
d1103 1
a1103 1
					fprintf(stderr, "\n%s %d: Bad key sequence '%s'", name, line, buf + x);
@


1.11
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.10 2009/10/18 14:17:34 tg Exp $ */
d81 2
a82 2
extern int mid, dspasis, dspctrl, force, help, pgamnt, square, csmode, nobackups, lightoff, exask, skiptop;
extern int noxon, lines, staen, columns, Baud, dopadding, orphan, marking, dobeep, keepup, nonotice;
d344 1
a344 1
int glopt(unsigned char *s, unsigned char *arg, OPTIONS *options, int set)
d384 2
a385 2
				if (options)
					*(int *) ((unsigned char *) options + glopts[x].ofst) = st;
d389 1
a389 1
					if (options) {
d393 1
a393 1
								  options + glopts[x].ofst) = val;
d404 1
a404 1
						if (options)
d406 1
a406 1
								  options + glopts[x].ofst) = zz;
d412 2
a413 2
				if (arg && options)
					options->syntax_name = (unsigned char *)strdup((char *)arg);
d415 2
a416 2
				if (arg && options)
					options->syntax = load_dfa(arg); */
d420 2
a421 2
				if (arg && options)
					options->map_name = (unsigned char *)strdup((char *)arg);
d435 2
a436 2
			if (options)
				options->lmsg = (unsigned char *)strdup((char *)arg);
d442 2
a443 2
			if (options)
				options->rmsg = (unsigned char *)strdup((char *)arg);
d454 2
a455 2
			if (options && y)
				options->context = (unsigned char *)strdup((char *)arg);
d463 2
a464 2
			if (options)
				options->mnew = mparse(NULL, arg, &sta);
d472 2
a473 2
			if (options)
				options->mold = mparse(NULL, arg, &sta);
d481 2
a482 2
			if (options)
				options->msnew = mparse(NULL, arg, &sta);
d490 2
a491 2
			if (options)
				options->msold = mparse(NULL, arg, &sta);
d830 1
a830 1
	int size;
a831 1
	size_t x, len;
@


1.10
log
@add built-in (minimal) jupprc, for stand-alone things
backported from joe 3.7 (Debian)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.9 2009/10/06 09:07:30 tg Exp $ */
d126 2
a127 1
	0		/* visible spaces */
d167 2
a168 1
	0		/* visible spaces */
d179 4
d288 1
d656 12
d678 7
d742 6
@


1.9
log
@provide hooks for Debian libbsd via autoconf headers
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.8 2009/09/16 13:29:28 tg Exp $ */
d31 1
d879 1
a879 1
	FILE *fd;		/* rc file */
d885 1
a885 1
	fd = fopen((char *)buf, "rt");
d887 1
a887 1
	fd = fopen((char *)buf, "r");
d896 1
a896 1
	while (fgets((char *)buf, sizeof(buf), fd)) {
d948 1
a948 1
				while ((fgets((char *)buf, 256, fd)) && (buf[0] != /*{*/ '}'))
d1060 1
a1060 1
					fgets((char *)buf, 1024, fd);
d1079 1
a1079 1
	fclose(fd);		/* Close rc file */
@


1.8
log
@debian porting compiler warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.7 2008/07/28 00:12:06 tg Exp $ */
d27 4
@


1.7
log
@rename symbol to avoid clash:

/usr/bin/ld: warning multiple definitions of symbol _beep
cmd.o definition of _beep in section (__DATA,__data)
/private/var/tglaser/iSDK/lib/libncurses.dylib(single module) definition of _beep

found during native(!) compilation on iPhone 3G (Darwin 9.3.1
iPhoneOS 2.0 iPhone1,2 arm N82AP), with gcc from saurik iphone-gcc
and headers and libraries copied from the 2.0 SDK. (It works fine.)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.6 2006/12/11 23:54:50 tg Exp $ */
d574 1
a574 1
		if (syn = load_dfa(s))
@


1.6
log
@mostly administrative licence sync w/ current template
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.5 2006/11/11 01:20:35 tg Exp $ */
d77 1
a77 1
extern int noxon, lines, staen, columns, Baud, dopadding, orphan, marking, beep, keepup, nonotice;
d265 1
a265 1
	{US "beep",	0, &beep, NULL, US "Warning bell enabled", US "Warning bell disabled", US "Beeps " },
@


1.5
log
@align option menu nicely and print sub-menu item values
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.4 2006/11/11 00:22:18 tg Exp $ */
d9 8
a16 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
@


1.4
log
@fix noxon option; add baud option (doesn't immediately take effect tho)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/rc.c,v 1.3 2006/11/10 23:23:30 tg Exp $ */
d8 9
d46 1
a46 1
#define OPT_BUF_SIZE 300
d239 1
a239 1
	{US "autoindent",	4, NULL, (unsigned char *) &fdefault.autoindent, US "Autoindent enabled", US "Autindent disabled", US "I Autoindent " },
d245 1
a245 1
	{US "icase",	0, &icase, NULL, US "Ignore case by default", US "Case sensitive by default", US "  Case insensitivity " },
d251 1
a251 1
	{US "french",	4, NULL, (unsigned char *) &fdefault.french, US "One space after periods for paragraph reformat", US "Two spaces after periods for paragraph reformat", US "  french spacing " },
d253 1
a253 1
	{US "spaces",	4, NULL, (unsigned char *) &fdefault.spaces, US "Inserting spaces when tab key is hit", US "Inserting tabs when tab key is hit", US "  no tabs " },
d266 2
a267 2
	{US "nosta",	0, &staen, NULL, US "Top-most status line disabled", US "Top-most status line enabled", US "  Disable status line " },
	{US "pg",		1, &pgamnt, NULL, US "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ", 0, US "  No. PgUp/PgDn lines ", 0, -1, 64 },
d275 1
a275 1
	{US "backpath",	2, (int *) &backpath, NULL, US "Backup files stored in (%s): ", 0, US "  Path to backup files " },
d507 4
d527 4
d543 4
d573 7
a579 6
	syn = load_dfa(s);

	if (syn)
		bw->o.syntax = syn;
	else
		msgnw(bw->parent, US "Syntax definition file not found");
d649 4
a652 2

	map = find_charmap(s);
d719 3
a721 3
		if (glopts[x].set == &Baud)
			tty_xonoffbaudrst();
		if (wmkpw(bw->parent, buf, NULL, doopt1, NULL, doabrt1, utypebw, xx, notify, locale_map))
d723 1
a723 1
		else
d795 1
a795 1
	int x;
d800 15
d816 2
a817 2
	for (x = 0; x != size; ++x) {
		s[x] = (unsigned char *) joe_malloc(OPT_BUF_SIZE);
d820 2
a821 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *glopts[x].set ? "ON" : "OFF");
d824 2
a825 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *glopts[x].set);
d828 1
a828 3
		case 9:
		case 13:
			strlcpy((char *)(s[x]), (char *)glopts[x].menu, OPT_BUF_SIZE);
d831 2
a832 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%s", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) ? "ON" : "OFF");
d835 2
a836 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst));
d839 12
a850 1
			joe_snprintf_2((char *)(s[x]), OPT_BUF_SIZE, "%s%d", glopts[x].menu, *(int *) ((unsigned char *) &bw->o + glopts[x].ofst) + 1);
d852 2
@


1.3
log
@* types.h, rc.c: extend per-file options by new "vispace" (visible spaces)
* rc.c: assign options menu entry for "vispace"
* bw.c: implement "vispace" by displaying a replacement character for any
  space or a tab's first column if enabled
* charmap.h: increment unicode-to-8bit mapping table size
* charmap.c: ensure the two replacement characters we use in bw.c for the
  visibled spaces and tabs are always mapped to something
* rc.c: make "noxon" an options menu entry and move it and "keepup" to top
* rc.c: fix out-of-bounds in options menu routines
@
text
@d1 1
a1 1
/* $MirOS$ */
d226 1
a226 1
	{US "noxon",	0, &noxon, NULL, US "XON/XOFF processing disabled", US "XON/XOFF processing enabled", US "  XON/XOFF mode " },
d228 1
a274 1
	{US "baud",	1, &Baud, NULL, 0, 0, 0, 0, 50, 32767 },
d673 2
d695 2
d889 1
a889 1
				while ((fgets((char *)buf, 256, fd)) && (buf[0] != '}'))
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
d112 1
d151 2
a152 1
	NULL, NULL, NULL, NULL	/* macros (see above) */
d226 2
a256 1
	{US "keepup",	0, &keepup, NULL, US "Status line updated constantly", US "Status line updated once/sec", US "  Fast status line " },
d266 1
a269 1
	{US "noxon",	0, &noxon, NULL, 0, 0, 0 },
d774 1
a774 1
		s[x] = (unsigned char *) joe_malloc(80);		/* FIXME: why 40 ??? */
d785 1
a785 1
			strlcpy((char *)(s[x]), (char *)glopts[x].menu, 80);
@


1.1
log
@Initial revision
@
text
@d23 1
d159 1
a159 1
		o->charmap = locale_map;
d262 2
a263 2
	{US "syntax",	9, NULL, NULL, US "Select syntax (^C to abort): ", 0, US "Y Syntax" },
	{US "encoding",13, NULL, NULL, US "Select file character set (^C to abort): ", 0, US "Encoding " },
d723 2
a724 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d733 2
a734 1
		joe_snprintf_1((char *)buf, OPT_BUF_SIZE, (char *)glopts[x].yes, "");
d781 1
a781 1
			strcpy((char *)(s[x]), (char *)glopts[x].menu);
d816 1
a816 1
	strcpy((char *)buf, (char *)name);
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 1
/* rc file parser */
d12 7
a18 1
#include "zstr.h"
d20 7
a26 3
#include "cmd.h"
#include "bw.h"
#include "help.h"
d28 2
d31 2
a32 5
#include "menu.h"
#include "umath.h"
#include "uedit.h"
#include "pw.h"
#include "path.h"
a33 3
#include "tw.h"
#include "termcap.h"
#include "rc.h"
d35 7
a41 6
static struct context
 {
 struct context *next;
 char *name;
 KMAP *kmap;
 } *contexts=0;		/* List of named contexts */
d47 86
a132 19
KMAP *getcontext(name)
char *name;
 {
 struct context *c;
 for(c=contexts;c;c=c->next) if(!zcmp(c->name,name)) return c->kmap;
 c=(struct context *)malloc(sizeof(struct context));
 c->next=contexts;
 c->name=zdup(name);
 contexts=c;
 return c->kmap=mkkmap();
 }

OPTIONS *options=0;
extern int mid, dspasis, dspctrl, force, help, pgamnt, square, csmode,
           nobackups, lightoff, exask, skiptop, noxon, lines, staen,
           columns, Baud, dopadding, orphan, marking, beep, keepup,
           nonotice;
extern char *backpath;

d134 1
a134 6
OPTIONS pdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };

OPTIONS fdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
   " %S Ctrl-K H for help", 0, 0, 0, 0, 1, 0, 0, 0, 0 };
d136 1
a136 6
OPTIONS pdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

OPTIONS fdefault=
 { 0, 0, 0, 0, 76, 0, 0, 8, ' ', 1, "main", "\\i%n %m %M",
   " %S Ctrl-K H for help", 0, 0, 0, 0, 0, 0, 0, 0, 0 };
d138 178
a315 19

void setopt(n,name)
OPTIONS *n;
char *name;
 {
 OPTIONS *o;
 for(o=options;o;o=o->next)
  if(rmatch(o->name,name))
   {
   *n= *o;
   return;
   }
 *n=fdefault;
 }

/* Set a global or local option 
 * returns 0 for no such option,
 *         1 for option accepted
 *         2 for option + argument accepted
d318 479
a796 507
struct glopts
 {
 char *name;	/* Option name */
 int type;	/* 0 for global option flag
                   1 for global option numeric
                   2 for global option string
                   4 for local option flag
                   5 for local option numeric
                   6 for local option string
                   7 for local option numeric+1
                */
 int *set;	/* Address of global option */
 char *addr;	/* Local options structure member address */
 char *yes;	/* Message if option was turned on, or prompt string */
 char *no;	/* Message if option was turned off */
 char *menu;	/* Menu string */
 int ofst;	/* Local options structure member offset */
 int low;	/* Low limit for numeric options */
 int high;	/* High limit for numeric options */
 } glopts[]=
 {
  {"overwrite", 4, 0, (char *)&fdefault.overtype,
   "Overtype mode",
   "Insert mode",
   "T Overtype "},

  {"autoindent", 4, 0, (char *)&fdefault.autoindent,
   "Autoindent enabled",
   "Autindent disabled",
   "I Autoindent "},

  {"wordwrap", 4, 0, (char *)&fdefault.wordwrap,
   "Wordwrap enabled",
   "Wordwrap disabled",
   "Word wrap "},

  {"tab", 5, 0, (char *)&fdefault.tab,
   "Tab width (%d): ",
   0,
   "D Tab width ",0,1,64},

  {"lmargin", 7, 0, (char *)&fdefault.lmargin,
   "Left margin (%d): ",
   0,
   "Left margin ",0,0,63},

  {"rmargin", 7, 0, (char *)&fdefault.rmargin,
   "Right margin (%d): ",
   0,
   "Right margin ",0,7,255},

  {"square", 0, &square, 0,
   "Rectangle mode",
   "Text-stream mode",
   "X Rectangle mode " },

  {"indentc", 5, 0, (char *)&fdefault.indentc,
   "Indent char %d (SPACE=32, TAB=9, ^C to abort): ",
   0,
   " Indent char ",0,0,255},

  {"istep", 5, 0, (char *)&fdefault.istep,
   "Indent step %d (^C to abort): ",
   0,
   " Indent step ",0,1,64},

  {"french", 4, 0, (char *)&fdefault.french,
   "One space after periods for paragraph reformat",
   "Two spaces after periods for paragraph reformat",
   " french spacing "},

  {"spaces", 4, 0, (char *)&fdefault.spaces,
   "Inserting spaces when tab key is hit",
   "Inserting tabs when tab key is hit",
   " no tabs "},

  {"mid", 0, &mid, 0,
   "Cursor will be recentered on scrolls",
   "Cursor will not be recentered on scroll",
   "Center on scroll " },

  {"crlf", 4, 0, (char *)&fdefault.crlf,
   "CR-LF is line terminator",
   "LF is line terminator",
   "Z CR-LF (MS-DOS) "},

  {"linums", 4, 0, (char *)&fdefault.linums,
   "Line numbers enabled",
   "Line numbers disabled",
   "N Line numbers "},

  {"marking", 0, &marking, 0,
   "Anchored block marking on",
   "Anchored block marking off",
   "Marking " },

  {"asis", 0, &dspasis, 0,
   "Characters above 127 shown as-is",
   "Characters above 127 shown in inverse",
   "Meta chars as-is "
    },

  {"force", 0, &force, 0,
   "Last line forced to have NL when file saved",
   "Last line not forces to have NL",
   "Force last NL " },

  {"nobackups", 0, &nobackups, 0,
   "Backup files will not be made",
   "Backup files will be made",
   " Disable backups " },

  {"lightoff", 0, &lightoff, 0,
   "Highlighting turned off after block operations",
   "Highlighting not turned off after block operations",
   "Auto unmark " },

  {"exask", 0, &exask, 0,
   "Prompt for filename in save & exit command",
   "Don't prompt for filename in save & exit command",
   "Exit ask "},

  {"beep", 0, &beep, 0,
   "Warning bell enabled", 
   "Warning bell disabled",
   "Beeps " },

  {"nosta", 0, &staen, 0,
   "Top-most status line disabled",
   "Top-most status line enabled",
   " Disable status line " },

  {"keepup", 0, &keepup, 0,
   "Status line updated constantly",
   "Status line updated once/sec",
   " Fast status line " },

  {"pg", 1, &pgamnt, 0,
   "Lines to keep for PgUp/PgDn or -1 for 1/2 window (%d): ",
   0,
   " No. PgUp/PgDn lines ", 0, -1, 64 },

  {"csmode", 0, &csmode, 0,
   "Start search after a search repeats previous search",
   "Start search always starts a new search",
   "Continued search " },

  {"rdonly", 4, 0, (char *)&fdefault.readonly,
   "Read only",
   "Full editing",
   "O Read only "},

  {"backpath", 2, (int *)&backpath, 0,
   "Backup files stored in (%s): ",
   0,
   "Path to backup files " },

  {"nonotice", 0, &nonotice, 0,
   0, 0, 0 },

  {"noxon", 0, &noxon, 0,
   0, 0, 0 },

  {"orphan", 0, &orphan, 0,
   0, 0, 0 },

  {"help", 0, &help, 0,
   0, 0, 0 },

  {"dopadding", 0, &dopadding, 0,
   0, 0, 0 },

  {"lines", 1, &lines, 0,
   0, 0, 0, 0, 2, 1024 },

  {"baud", 1, &Baud, 0,
   0, 0, 0, 0, 50, 32767 }, 

  {"columns", 1, &columns, 0,
   0, 0, 0, 0, 2, 1024 },

  {"skiptop", 1, &skiptop, 0,
   0, 0, 0, 0, 0, 64 }, 

  { 0, 0, 0 }
 };

int isiz=0;

void izopts()
 {
 int x;
 for(x=0;glopts[x].name;++x)
  switch(glopts[x].type)
   {
   case 4: case 5: case 6: case 7: case 8:
   glopts[x].ofst=glopts[x].addr-(char *)&fdefault;
   }
 isiz=1;
 }

int glopt(s,arg,options,set)
char *s, *arg;
OPTIONS *options;
 {
 int val;
 int ret=0;
 int st=1;
 int x;
 if(!isiz) izopts();
 if(s[0]=='-') st=0, ++s;
 for(x=0;glopts[x].name;++x)
  if(!zcmp(glopts[x].name,s))
   {
   switch(glopts[x].type)
    {
    case 0: if(set) *glopts[x].set=st;
    break;
    
    case 1: if(set && arg)
             {
             sscanf(arg,"%d",&val);
             if(val>=glopts[x].low && val<=glopts[x].high) *glopts[x].set=val;
             }
    break;

    case 2: if(set)
             if(arg) *(char **)glopts[x].set=zdup(arg);
             else *(char **)glopts[x].set=0;
    break;

    case 4: if(options) *(int *)((char *)options+glopts[x].ofst)=st;
            else if(set==2) *(int *)((char *)&fdefault+glopts[x].ofst)=st;
    break;
    
    case 5: if(arg)
             if(options)
              {
              sscanf(arg,"%d",&val);
              if(val>=glopts[x].low && val<=glopts[x].high)
               *(int *)((char *)options+glopts[x].ofst)=val;
              }
             else if(set==2)
              {
              sscanf(arg,"%d",&val);
              if(val>=glopts[x].low && val<=glopts[x].high)
               *(int *)((char *)&fdefault+glopts[x].ofst)=val;
              }
    break;

    case 7: if(arg)
             {
             int zz=0;
             sscanf(arg,"%d",&zz);
             if(zz>=glopts[x].low && zz <=glopts[x].high)
              {
              --zz;
              if(options) *(int *)((char *)options+glopts[x].ofst)=zz;
              else if(set==2) *(int *)((char *)&fdefault+glopts[x].ofst)=zz;
              }
             }
    break;
    }
   if((glopts[x].type&3)==0 || !arg) return 1;
   else return 2;
   }
 if(!zcmp(s,"lmsg"))
  {
  if(arg)
   {
   if(options) options->lmsg=zdup(arg);
   else if(set==2) fdefault.lmsg=zdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"rmsg"))
  {
  if(arg)
   {
   if(options) options->rmsg=zdup(arg);
   else if(set==2) fdefault.rmsg=zdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"keymap"))
  {
  if(arg)
   {
   int y;
   for(y=0;!cwhitel(arg[y]);++y);
   if(!arg[y]) arg[y]=0;
   if(options && y) options->context=zdup(arg);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"mnew"))
  {
  if(arg)
   {
   int sta;
   if(options) options->mnew=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.mnew=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"mold"))
  {
  if(arg)
   {
   int sta;
   if(options) options->mold=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.mold=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"msnew"))
  {
  if(arg)
   {
   int sta;
   if(options) options->msnew=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.msnew=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 else if(!zcmp(s,"msold"))
  {
  if(arg)
   {
   int sta;
   if(options) options->msold=mparse(NULL,arg,&sta);
   else if(set==2) fdefault.msold=mparse(NULL,arg,&sta);
   ret=2;
   }
  else ret=1;
  }
 done: return ret;
 }

static int optx=0;

int doabrt1(bw,xx)
BW *bw;
int *xx;
 {
 free(xx);
 return -1;
 }

int doopt1(bw,s,xx,notify)
BW *bw;
char *s;
int *xx;
int *notify;
 {
 int ret=0;
 int x= *xx;
 int v;
 free(xx);
 switch(glopts[x].type)
  {
  case 1:
   v=calc(bw,s);
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *glopts[x].set=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  case 2: if(s[0]) *(char **)glopts[x].set=zdup(s); break;
  case 5:
   v=calc(bw,s);
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *(int *)((char *)&bw->o+glopts[x].ofst)=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  case 7:
   v=calc(bw,s)-1.0;
   if(merr) msgnw(bw,merr), ret= -1;
   else if(v>=glopts[x].low && v<=glopts[x].high) *(int *)((char *)&bw->o+glopts[x].ofst)=v;
   else msgnw(bw,"Value out of range"), ret= -1;
   break;
  }
 vsrm(s);
 bw->b->o=bw->o;
 wfit(bw->parent->t);
 updall();
 if(notify) *notify=1;
 return ret;
 }

int doopt(m,x,object,flg)
MENU *m;
void *object;
 {
 BW *bw=m->parent->win->object;
 int *xx;
 char buf[80];
 int *notify=m->parent->notify;
 switch(glopts[x].type)
  {
  case 0:
  if(!flg) *glopts[x].set= !*glopts[x].set;
  else if(flg==1) *glopts[x].set= 1;
  else *glopts[x].set=0;
  uabort(m,MAXINT);
  msgnw(bw,*glopts[x].set?glopts[x].yes:glopts[x].no);
  break;

  case 4:
  if(!flg) *(int *)((char *)&bw->o+glopts[x].ofst)= !*(int *)((char *)&bw->o+glopts[x].ofst);
  else if(flg==1) *(int *)((char *)&bw->o+glopts[x].ofst)=1;
  else *(int *)((char *)&bw->o+glopts[x].ofst)=0;
  uabort(m,MAXINT);
  msgnw(bw,*(int *)((char *)&bw->o+glopts[x].ofst)?glopts[x].yes:glopts[x].no);
  if(glopts[x].ofst==(char *)&fdefault.readonly-(char *)&fdefault)
   bw->b->rdonly=bw->o.readonly;
  break;

  case 1:
  sprintf(buf,glopts[x].yes,*glopts[x].set);
  xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;

  case 2:
  if(*(char **)glopts[x].set) sprintf(buf,glopts[x].yes,*(char **)glopts[x].set);
  else sprintf(buf,glopts[x].yes,"");
  xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;

  case 5:
  sprintf(buf,glopts[x].yes,*(int *)((char *)&bw->o+glopts[x].ofst));
  goto in;
  
  case 7:
  sprintf(buf,glopts[x].yes,*(int *)((char *)&bw->o+glopts[x].ofst)+1);
  in: xx=(int *)malloc(sizeof(int)); *xx=x;
  m->parent->notify=0;
  uabort(m,MAXINT);
  if(wmkpw(bw,buf,NULL,doopt1,NULL,doabrt1,utypebw,xx,notify)) return 0;
  else return -1;
  }
 if(notify) *notify=1;
 bw->b->o=bw->o;
 wfit(bw->parent->t);
 updall();
 return 0;
 }

int doabrt(m,x,s)
MENU *m;
char **s;
 {
 optx=x;
 for(x=0;s[x];++x) free(s[x]);
 free(s);
 return -1;
 }

int umode(bw)
BW *bw;
 {
 int size;
 char **s;
 int x;
 bw->b->o.readonly=bw->o.readonly=bw->b->rdonly;
 for(size=0;glopts[size].menu;++size);
 s=(char **)malloc(sizeof(char *)*(size+1));
 for(x=0;x!=size;++x)
  {
  s[x]=(char *)malloc(40);
  switch(glopts[x].type)
   {
   case 0: sprintf(s[x],"%s%s",glopts[x].menu,*glopts[x].set?"ON":"OFF");
   break;
   
   case 1: sprintf(s[x],"%s%d",glopts[x].menu,*glopts[x].set);
   break;

   case 2: zcpy(s[x],glopts[x].menu);
   break;

   case 4: sprintf(s[x],"%s%s",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst)?"ON":"OFF");
   break;
   
   case 5: sprintf(s[x],"%s%d",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst));
   break;

   case 7: sprintf(s[x],"%s%d",glopts[x].menu,*(int *)((char *)&bw->o+glopts[x].ofst)+1);
   break;
   }
  }
 s[x]=0;
 if(mkmenu(bw,s,doopt,doabrt,NULL,optx,s,NULL)) return 0;
 else return -1;
 }

d804 8
a811 1
int nhelp=0;			/* No. help screens so far */
d813 1
a813 11
int procrc(cap,name)
CAP *cap;
char *name;
 {
 OPTIONS *o=0;			/* Current options */
 KMAP *context=0;		/* Current context */
 unsigned char buf[1024];	/* Input buffer */
 FILE *fd;			/* rc file */
 int line=0;			/* Line number */
 int err=0;			/* Set to 1 if there was a syntax error */
 ossep(zcpy(buf,name));
d815 1
a815 1
 fd=fopen(buf,"rt");
d817 1
a817 1
 fd=fopen(buf,"r");
d819 200
a1018 247
 
 if(!fd) return -1;		/* Return if we couldn't open the rc file */
 
 fprintf(stderr,"Processing '%s'...",name); fflush(stderr);
 
 while(++line, fgets(buf,1024,fd))
  switch(buf[0])
   {
   case ' ': case '\t': case '\n': case '\f': case 0:
   break;	/* Skip comment lines */

   case '*':	/* Select file types for file-type dependant options */
    {
    int x;
    o=(OPTIONS *)malloc(sizeof(OPTIONS));
    *o=fdefault;
    for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
    buf[x]=0;
    o->next=options;
    options=o;
    o->name=zdup(buf);
    }
   break;
   
   case '-':	/* Set an option */
    {
    unsigned char *opt=buf+1;
    int x;
    unsigned char *arg=0;
    for(x=0;buf[x] && buf[x]!='\n' && buf[x]!=' ' && buf[x]!='\t';++x);
    if(buf[x] && buf[x]!='\n')
     {
     buf[x]=0;
     for(arg=buf+ ++x;buf[x] && buf[x]!='\n';++x);
     }
    buf[x]=0;
    if(!glopt(opt,arg,o,2))
     {
     err=1;
     fprintf(stderr,"\n%s %d: Unknown option %s",name,line,opt);
     }
    }
   break;
   
   case '{':	/* Enter help text */
    {
    int bfl;
    struct help *tmp=(struct help *)malloc(sizeof(struct help));
    nhelp++;
    tmp->next=first_help;
    first_help=tmp;
    tmp->name=vsncpy(NULL,0,sz(buf+1)-1);
    help_names=vaadd(help_names,tmp->name);
    tmp->hlptxt=0;
    tmp->hlpsiz=0;
    tmp->hlpbsz=0;
    tmp->hlplns=0;
    up:
    if(++line, !fgets(buf,256,fd))
     {
     err=1;
     fprintf(stderr,"\n%s %d: End of joerc file occured before end of help text",name,line);
     break;
     }
    if(buf[0]=='}')
     {
     if(!hlptxt)
      hlptxt=tmp->hlptxt,
      hlpsiz=tmp->hlpsiz,
      hlpbsz=tmp->hlpbsz,
      hlplns=tmp->hlplns;
     continue;
     }
    bfl=zlen(buf);
    if(tmp->hlpsiz+bfl>tmp->hlpbsz)
     {
     if(tmp->hlptxt) tmp->hlptxt=(char *)realloc(tmp->hlptxt,tmp->hlpbsz+bfl+1024);
     else tmp->hlptxt=(char *)malloc(bfl+1024), tmp->hlptxt[0]=0;
     tmp->hlpbsz+=bfl+1024;
     }
    zcpy(tmp->hlptxt+tmp->hlpsiz,buf);
    tmp->hlpsiz+=bfl;
    ++tmp->hlplns;
    goto up;
    }
   break;

   case ':':	/* Select context */
    {
    int x, c;
    for(x=1;!cwhitef(buf[x]);++x);
    c=buf[x]; buf[x]=0;
    if(x!=1)
     if(!zcmp(buf+1,"def"))
      {
      int y;
      for(buf[x]=c;cwhite(buf[x]);++x);
      for(y=x;!cwhitef(buf[y]);++y);
      c=buf[y]; buf[y]=0;
      if(y!=x)
       {
       int sta;
       MACRO *m;
       if(cwhite(c) && (m=mparse(NULL,buf+y+1,&sta)))
        addcmd(buf+x,m);
       else
        {
        err=1;
        fprintf(stderr,"\n%s %d: macro missing from :def",name,line);
        }
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: command name missing from :def",name,line);
       }
      }
     else if(!zcmp(buf+1,"inherit"))
      if(context)
       {
       for(buf[x]=c;cwhite(buf[x]);++x);
       for(c=x;!cwhitef(buf[c]);++c);
       buf[c]=0;
       if(c!=x) kcpy(context,getcontext(buf+x));
       else
        {
        err=1;
        fprintf(stderr,"\n%s %d: context name missing from :inherit",name,line);
        }
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: No context selected for :inherit",name,line);
       }
     else if(!zcmp(buf+1,"include"))
      {
      for(buf[x]=c;cwhite(buf[x]);++x);
      for(c=x;!cwhitef(buf[c]);++c);
      buf[c]=0;
      if(c!=x)
       {
       switch(procrc(buf+x))
        {
        case 1: err=1; break;
        case -1: fprintf(stderr,"\n%s %d: Couldn't open %s",name,line,buf+x);
                 err=1; break;
        }
       context=0;
       o=0;
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: :include missing file name",name,line);
       }
      }
     else if(!zcmp(buf+1,"delete"))
      if(context)
       {
       int y;
       for(buf[x]=c;cwhite(buf[x]);++x);
       for(y=x;buf[y]!=0 && buf[y]!='\t' && buf[y]!='\n' &&
               (buf[y]!=' ' || buf[y+1]!=' ');++y);
       buf[y]=0;
       kdel(context,buf+x);
       }
      else
       {
       err=1;
       fprintf(stderr,"\n%s %d: No context selected for :delete",name,line);
       }
     else context=getcontext(buf+1);
    else
     {
     err=1;
     fprintf(stderr,"\n%s %d: Invalid context name",name,line);
     }
    }
   break;

   default:	/* Get key-sequence to macro binding */
    {
    int x, y, c;
    MACRO *m;
    if(!context)
     {
     err=1;
     fprintf(stderr,"\n%s %d: No context selected for macro to key-sequence binding",name,line);
     break;
     }

    m=0;
    macroloop:
    m=mparse(m,buf,&x);
    if(x== -1)
     {
     err=1;
     fprintf(stderr,"\n%s %d: Unknown command in macro",name,line);
     break;
     }
    else if(x== -2)
     {
     fgets(buf,1024,fd);
     goto macroloop;
     }
    if(!m) break;

    /* Skip to end of key sequence */
    for(y=x;buf[y]!=0 && buf[y]!='\t' && buf[y]!='\n' && 
            (buf[y]!=' ' || buf[y+1]!=' ');++y);
    buf[y]=0;

    /* Add binding to context */
    if(kadd(cap,context,buf+x,m)== -1)
     {
     fprintf(stderr,"\n%s %d: Bad key sequence '%s'",name,line,buf+x);
     err=1;
     }
    }
   break;
   }
 fclose(fd);			/* Close rc file */

 /* Print proper ending string */
 if(err) fprintf(stderr,"\ndone\n");
 else fprintf(stderr,"done\n");

 return err;			/* 0 for success, 1 for syntax error */
 }

void izhelp()
 {
 struct help *tmp;
 /* Convert list of help screens into an array */
 if(nhelp)
  {
  help_structs=(struct help **) malloc(sizeof(struct help *)*(nhelp+1));
  help_structs[nhelp]=0;
  tmp=first_help;
  while(nhelp--)
   {
   help_structs[nhelp]=tmp;
   tmp=tmp->next;
   }
  }
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
