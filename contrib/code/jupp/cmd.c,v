head	1.30;
access;
symbols
	joe-3_1jupp38:1.30
	joe-3_1jupp37:1.30
	joe-3_1jupp36:1.30
	joe-3_1jupp35:1.30
	joe-3_1jupp34:1.30
	joe-3_1jupp33:1.30
	joe-3_1jupp32:1.26
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.17
	joe-3_1jupp30:1.15
	joe-3_1jupp29:1.15
	joe-3_1jupp28:1.12
	joe-3_1jupp27:1.12
	joe-3_1jupp26:1.12
	joe-3_1jupp25:1.12
	joe-3_1jupp24:1.11
	joe-3_1jupp23:1.11
	joe-3_1jupp22:1.7
	joe-3_1jupp21:1.7
	joe-3_1jupp20:1.7
	joe-3_1jupp19:1.7
	joe-3_1jupp18:1.7
	joe-3_1jupp17:1.7
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.7
	joe-3_1jupp15:1.7
	joe-3_1jupp14:1.7
	joe-3_1jupp12:1.5
	joe-3_1jupp11:1.4
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.4
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.30
date	2018.01.18.21.59.11;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A6118BD6F94E8BD;

1.29
date	2018.01.07.17.24.48;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A5257E37ACEAAEF;

1.28
date	2018.01.07.16.58.13;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A5251B95619CA29;

1.27
date	2018.01.06.17.07.05;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A51025239AC32D0;

1.26
date	2017.12.08.02.00.38;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005A29F2506E789D2B;

1.25
date	2017.12.08.01.16.36;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005A29E8063D55F339;

1.24
date	2017.12.07.02.10.16;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005A28A3145E1FF911;

1.23
date	2017.12.06.23.58.36;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005A2884424C3F3AD8;

1.22
date	2017.12.06.23.02.02;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005A2876FC4FFE7EF5;

1.21
date	2017.12.06.21.41.01;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005A28640547F64250;

1.20
date	2017.12.06.21.16.55;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A285E5918D423C7;

1.19
date	2017.12.02.02.07.25;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005A220AD65C90E687;

1.18
date	2017.11.18.17.05.50;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005A10687E421523D2;

1.17
date	2017.08.08.21.39.28;	author tg;	state Exp;
branches;
next	1.16;
commitid	100598A2FA50A3266A7;

1.16
date	2017.08.08.21.36.11;	author tg;	state Exp;
branches;
next	1.15;
commitid	100598A2EE40C9C08B3;

1.15
date	2016.10.08.14.58.45;	author tg;	state Exp;
branches;
next	1.14;
commitid	10057F909BA47132811;

1.14
date	2016.10.07.20.09.55;	author tg;	state Exp;
branches;
next	1.13;
commitid	10057F8012D3102E599;

1.13
date	2016.10.07.20.07.49;	author tg;	state Exp;
branches;
next	1.12;
commitid	10057F800AE47CC7672;

1.12
date	2013.08.19.19.19.30;	author tg;	state Exp;
branches;
next	1.11;
commitid	10052126FDA15E01220;

1.11
date	2012.12.30.21.45.13;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050E0B5FE41C91584;

1.10
date	2012.12.30.19.27.12;	author tg;	state Exp;
branches;
next	1.9;
commitid	10050E095A825B7B989;

1.9
date	2012.12.30.17.12.36;	author tg;	state Exp;
branches;
next	1.8;
commitid	10050E0761C0C6C216C;

1.8
date	2012.12.20.21.15.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050D3800B1473D017;

1.7
date	2010.01.03.17.54.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004B40D9C9542E4913;

1.6
date	2010.01.03.17.45.55;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004B40D7E0690ED35F;

1.5
date	2009.10.18.14.52.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004ADB2BD317498872;

1.4
date	2008.07.28.00.12.06;	author tg;	state Exp;
branches;
next	1.3;
commitid	100488D0E7907247606;

1.3
date	2008.05.13.13.08.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.21;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.30
log
@make jupp save a bit more safely
@
text
@/*
 *	Command execution
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#define EXTERN_CMD_C
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/cmd.c,v 1.29 2018/01/07 17:24:48 tg Exp $");

#include <stdlib.h>
#include <string.h>

#include "b.h"
#include "bw.h"
#include "cmd.h"
#include "hash.h"
#include "help.h"
#include "kbd.h"
#include "macro.h"
#include "main.h"
#include "menu.h"
#include "path.h"
#include "poshist.h"
#include "pw.h"
#include "rc.h"
#include "tty.h"
#include "tw.h"
#include "ublock.h"
#include "uedit.h"
#include "uerror.h"
#include "ufile.h"
#include "uformat.h"
#include "uisrch.h"
#include "umath.h"
#include "undo.h"
#include "usearch.h"
#include "ushell.h"
#include "utag.h"
#include "utils.h"
#include "va.h"
#include "vs.h"
#include "utf8.h"
#include "w.h"

extern int marking;
extern int smode;
int dobeep = 0;
int uexecmd(BW *bw);

/* Command table */

static int
ubeep(void)
{
	ttputc(7);
	return 0;
}

extern char main_context[];
static int do_keymap(BW *bw, unsigned char *s, void *object, int *notify)
{
	KMAP *new_kmap;

	if (notify)
		*notify = 1;
	if (!*s || !(new_kmap = kmap_getcontext(s, 0))) {
		vsrm(s);
		return (-1);
	}
	if (bw->o.context != (unsigned char *)main_context)
		free(bw->o.context);
	bw->o.context = strcmp((char *)s, main_context) ?
	    (unsigned char *)strdup((char *)s) : (unsigned char *)main_context;
	rmkbd(bw->parent->kbd);
	bw->parent->kbd = mkkbd(new_kmap);
	joe_snprintf_1((char *)msgbuf, JOE_MSGBUFSIZE, "New keymap: %s", s);
	vsrm(s);
	msgnw(bw->parent, msgbuf);
	return (0);
}
static int ukeymap(BW *bw)
{
	if (wmkpw(bw->parent, UC "Name of keymap to switch to: ", NULL,
	    do_keymap, NULL, NULL, utypebw, NULL, NULL, locale_map)) {
		return (0);
	}
	return (-1);
}

static int unop(void)
{
	return (0);
}

#if !WANT_FORK
static int
unommu(BW *bw) {
	msgnw(bw->parent, UC "Sorry, not supported without MMU");
	return (-1);
}
#define ubknd	unommu
#define ubuild	unommu
#define urun	unommu
#endif

#define C(name,flag,func,m,arg,negarg) { UC name, UC negarg, func, m, flag, arg }
CMD cmds[] = {
C("abendjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabendjoe, NULL, 0, NULL),
C("abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL),
C("abortbuf", TYPETW, uabortbuf, NULL, 0, NULL),
C("arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL),
C("ask", TYPETW + TYPEPW, uask, NULL, 0, NULL),
C("backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, "delch"),
C("backsmenu", TYPEMENU, umbacks, NULL, 1, NULL),
C("backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, "delw"),
C("beep", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ubeep, NULL, 0, NULL),
C("begin_marking", TYPETW + TYPEPW, ubegin_marking, NULL, 0, NULL),
C("bknd", TYPETW + TYPEPW, ubknd, NULL, 0, NULL),
C("bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, "fwrdc"),
C("blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkcpy, NULL, 1, NULL),
C("blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD + EBLOCK, ublkdel, NULL, 0, NULL),
C("blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkmove, NULL, 0, NULL),
C("blksave", TYPETW + TYPEPW + EBLOCK, ublksave, NULL, 0, NULL),
C("bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL),
C("bofmenu", TYPEMENU, umbof, NULL, 0, NULL),
C("bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL),
C("bolmenu", TYPEMENU, umbol, NULL, 0, NULL),
C("bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, "eop"),
C("bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL),
C("bufed", TYPETW, ubufed, NULL, 0, NULL),
C("build", TYPETW + TYPEPW, ubuild, NULL, 0, NULL),
C("byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL),
C("cancel", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ucancel, NULL, 0, NULL),
C("center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL),
C("col", TYPETW + TYPEPW, ucol, NULL, 0, NULL),
C("complete", TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL),
C("copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL),
C("crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, "crawlr"),
C("crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, "crawll"),
C("ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL),
C("delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, "deleol"),
C("delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, "backs"),
C("deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, "delbol"),
C("dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL),
C("delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, "backw"),
C("dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, "uparw"),
C("dnarwmenu", TYPEMENU, umdnarw, NULL, 1, "uparwmenu"),
C("dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, "upslide"),
C("drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL),
C("dupw", TYPETW, uduptw, NULL, 0, NULL),
C("edit", TYPETW, uedit, NULL, 0, NULL),
C("eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL),
C("eofmenu", TYPEMENU, umeof, NULL, 0, NULL),
C("eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL),
C("eolmenu", TYPEMENU, umeol, NULL, 0, NULL),
C("eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, "bop"),
C("execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL),
C("explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL),
C("exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL),
C("ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL),
C("filt", TYPETW + TYPEPW + EMOD + EBLOCK, ufilt, NULL, 0, NULL),
C("finish", TYPETW + TYPEPW + EMOD, ufinish, NULL, 1, NULL),
C("fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK + ECHK0COL, ufmtblk, NULL, 1, NULL),
C("fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL),
C("format", TYPETW + TYPEPW + EFIXXCOL + EMOD + ECHK0COL, uformat, NULL, 1, NULL),
C("fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, "bkwdc"),
C("gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL),
C("groww", TYPETW, ugroww, NULL, 1, "shrinkw"),
C("help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL),
C("helpcard", TYPETW + TYPEPW + TYPEQW, u_helpcard, NULL, 0, NULL),
C("hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL),
C("home", TYPETW + TYPEPW + EFIXXCOL, uhome, NULL, 0, NULL),
C("hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL),
C("insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, "delch"),
C("insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL),
C("isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL),
C("keymap", TYPETW + TYPEPW, ukeymap, NULL, 0, NULL),
C("killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL),
C("killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL),
C("lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ulindent, NULL, 1, "rindent"),
C("line", TYPETW + TYPEPW, uline, NULL, 0, NULL),
C("lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL),
C("lower", TYPETW + TYPEPW + EMOD + EBLOCK, ulower, NULL, 0, NULL),
C("ltarw", TYPETW + TYPEPW /* + EFIXXCOL + ECHKXCOL */, u_goto_left, NULL, 1, "rtarw"),
C("ltarwmenu", TYPEMENU, umltarw, NULL, 1, "rtarwmenu"),
C("macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL),
C("markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL),
C("markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL),
C("markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL),
C("math", TYPETW + TYPEPW, umath, NULL, 0, NULL),
C("mathins", TYPETW + TYPEPW, umathins, NULL, 0, NULL),
C("mathres", TYPETW + TYPEPW, umathres, NULL, 0, NULL),
C("mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL),
C("msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL),
C("nbuf", TYPETW, unbuf, NULL, 1, "pbuf"),
C("nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, "pedge"),
C("nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, "prevpos"),
C("nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, "prevw"),
C("nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, "prevword"),
C("nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL),
C("nop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unop, NULL, 0, NULL),
C("notmod", TYPETW, unotmod, NULL, 0, NULL),
C("nxterr", TYPETW, unxterr, NULL, 1, "prverr"),
C("open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, "deleol"),
C("parserr", TYPETW, uparserr, NULL, 0, NULL),
C("pbuf", TYPETW, upbuf, NULL, 1, "nbuf"),
C("pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, "nedge"),
C("pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, "pgup"),
C("pgdnmenu", TYPEMENU, umpgdn, NULL, 1, "pgupmenu"),
C("pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, "pgdn"),
C("pgupmenu", TYPEMENU, umpgup, NULL, 1, "pgdnmenu"),
C("picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL),
C("play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL),	/* EFIXX? */
C("pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL),
C("prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, "nextpos"),
C("prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, "nextw"),
C("prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, "nextword"),
C("prverr", TYPETW, uprverr, NULL, 1, "nxterr"),
C("psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL),
C("qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL),
C("query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL),
C("querysave", TYPETW, uquerysave, NULL, 0, NULL),
C("quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL),
C("quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL),
C("record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL),
C("redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, "undo"),
C("retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW + ECHK0COL, uretyp, NULL, 0, NULL),
C("rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL),
C("rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, urindent, NULL, 1, "lindent"),
C("rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL),
C("rtarw", TYPETW + TYPEPW /* + EFIXXCOL */, u_goto_right, NULL, 1, "ltarw"), /* EFIX removed for picture mode */
C("rtarwmenu", TYPEMENU, umrtarw, NULL, 1, "ltarwmenu"),
C("rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL),
C("run", TYPETW + TYPEPW, urun, NULL, 0, NULL),
C("rvmatch", TYPETW + TYPEPW + EFIXXCOL, urvmatch, NULL, 0, NULL),
C("save", TYPETW, usave, NULL, 0, NULL),
C("scratch", TYPETW + TYPEPW, uscratch, NULL, 0, NULL),
C("select", TYPETW + TYPEPW, uselect, NULL, 0, NULL),
C("setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL),
C("shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL),
C("shrinkw", TYPETW, ushrnk, NULL, 1, "groww"),
C("splitw", TYPETW, usplitw, NULL, 0, NULL),
C("stat", TYPETW + TYPEPW, ustat_j, NULL, 0, NULL),
C("stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL),
C("sync", TYPETW + TYPEPW + TYPEMENU + TYPEQW, usync, NULL, 0, NULL),
C("swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL),
C("switch", TYPETW + TYPEPW, uswitch, NULL, 0, NULL),
C("tabmenu", TYPEMENU, umtab, NULL, 1, "ltarwmenu"),
C("tag", TYPETW + TYPEPW, utag, NULL, 0, NULL),
C("toggle_marking", TYPETW + TYPEPW, utoggle_marking, NULL, 0, NULL),
C("tomarkb", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkb, NULL, 0, NULL),
C("tomarkbk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkbk, NULL, 0, NULL),
C("tomarkk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkk, NULL, 0, NULL),
C("tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL),
C("tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL),
C("tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL),
C("tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL),
C("txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL),
C("type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, "backs"),
C("uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL),
C("undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, "redo"),
C("uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, "dnarw"),
C("uparwmenu", TYPEMENU, umuparw, NULL, 1, "dnarwmenu"),
C("upper", TYPETW + TYPEPW + EMOD + EBLOCK, uupper, NULL, 0, NULL),
C("upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, "dnslide"),
C("yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL),
C("yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL),
C("yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL)
};

/* Execute a command n with key k */

int execmd(CMD *cmd, int k)
{
	BW *bw = maint->curwin->object.bw;
	int ret = -1;

	/* Send data to shell window: this is broken ^K ^H (help) sends its ^H to shell */
	if ((maint->curwin->watom->what & TYPETW) && bw->b->pid && piseof(bw->cursor) &&
	(k==3 || k==13 || k==8 || k==127 || k==4 || ((cmd->func==utype) && (k>=32) && (k<256)))) {
		unsigned char c = k;
		joe_write(bw->b->out, &c, 1);
		return 0;
	}

	if (cmd->m)
		return exmacro(cmd->m, 0);

	/* We don't execute if we have to fix the column position first
	 * (i.e., left arrow when cursor is in middle of nowhere) */
	if (cmd->flag & ECHKXCOL) {
		if (bw->o.hex)
			bw->cursor->xcol = piscol(bw->cursor);
		else if (bw->cursor->xcol != piscol(bw->cursor))
			goto skip;
	}

	/* Don't execute command if we're in wrong type of window */
	if (!(cmd->flag & maint->curwin->watom->what))
		goto skip;

	/* Complete selection for block commands */
	if ((cmd->flag & EBLOCK) && marking)
		utoggle_marking(maint->curwin->object.bw);

	if ((maint->curwin->watom->what & TYPETW) && bw->b->rdonly && (cmd->flag & EMOD)) {
		msgnw(bw->parent, UC "Read only");
		if (dobeep)
			ttputc(7);
		goto skip;
	}

	/* Execute command */
	ret = cmd->func(maint->curwin->object, k);

	if (smode)
		--smode;

	/* Don't update anything if we're going to leave */
	if (leave)
		return 0;

	/* cmd->func could have changed bw on us */
	bw = maint->curwin->object.bw;

	/* Maintain position history */
	/* If command was not a positioning command */
	if (!(cmd->flag & EPOS)
	    && (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		afterpos();

	/* If command was not a movement */
	if (!(cmd->flag & (EMOVE | EPOS)) && (maint->curwin->watom->what & (TYPETW | TYPEPW)))
		aftermove(maint->curwin, bw->cursor);

	if (cmd->flag & EKILL)
		justkilled = 1;
	else
		justkilled = 0;

 skip:

	/* scroll screen to the left */
	if ((cmd->flag & ECHK0COL) && bw->offset != 0) {
		bw->offset = 0;
		updall();
	}

	/*
	 * Make displayed cursor column equal the actual cursor column
	 * for commands which aren't simple vertical movements
	 */
	if (cmd->flag & EFIXXCOL)
		bw->cursor->xcol = piscol(bw->cursor);

	/* Recenter cursor to middle of screen */
	if (cmd->flag & EMID) {
		int omid = mid;

		mid = 1;
		dofollows();
		mid = omid;
	}

	if (dobeep && ret)
		ttputc(7);
	return ret;
}

/* Return command table index for given command name */

HASH *cmdhash = NULL;

static void izcmds(void)
{
	int x;

	cmdhash = htmk(256);
	for (x = 0; x != sizeof(cmds) / sizeof(CMD); ++x)
		htadd(cmdhash, cmds[x].name, cmds + x);
}

CMD *findcmd(const unsigned char *s)
{
	if (!cmdhash)
		izcmds();
	return (CMD *) htfind(cmdhash, s);
}

void addcmd(const unsigned char *s, MACRO *m)
{
	CMD *cmd = malloc(sizeof(CMD));

	if (!cmdhash)
		izcmds();
	cmd->name = (unsigned char *)strdup((const char *)s);
	cmd->flag = 0;
	cmd->func = NULL;
	cmd->m = m;
	cmd->arg = 1;
	cmd->negarg = NULL;
	htadd(cmdhash, cmd->name, cmd);
}

static unsigned char **getcmds(void)
{
	unsigned char **s = vaensure(NULL, sizeof(cmds) / sizeof(CMD));
	int x;
	HENTRY *e;

	for (x = 0; x != cmdhash->len; ++x)
		for (e = cmdhash->tab[x]; e; e = e->next)
			s = vaadd(s, vsncpy(NULL, 0, sz(e->name)));
	vasort(s, aLen(s));
	return s;
}

/* Command line */

unsigned char **scmds = NULL;	/* Array of command names */

static int cmdcmplt(BW *bw)
{
	if (!scmds)
		scmds = getcmds();
	/*XXX simple_cmplt does p_goto_bol, better only to last comma */
	return simple_cmplt(bw, scmds);
}

static int docmd(BW *bw, unsigned char *s, void *object, int *notify)
{
	MACRO *mac;
	int ret = -1;

	if (s) {
		mac = mparse(NULL, s, &ret);
		if (ret < 0 || !mac)
			msgnw(bw->parent, UC "No such command");
		else {
			ret = exmacro(mac, 1);
			rmmacro(mac);
		}
	}
	vsrm(s);	/* allocated in pw.c::rtnpw() */
	if (notify)
		*notify = 1;
	return ret;
}

B *cmdhist = NULL;

int uexecmd(BW *bw)
{
	if (wmkpw(bw->parent, UC "cmd: ", &cmdhist, docmd, UC "cmd", NULL, cmdcmplt, NULL, NULL, locale_map)) {
		return 0;
	} else {
		return -1;
	}
}

/*
 * Show help screen at a specific card
 */
static int do_helpcard(BASE *base, unsigned char *s, void *object, int *notify)
{
	struct help *new_help;

	if (notify)
		*notify = 1;
	if (!*s) {
		vsrm(s);
		while (help_actual->prev != NULL)
			/* find the first help entry */
			help_actual = help_actual->prev;
		help_off(base->parent->t);
		return (0);
	}
	if ((new_help = find_context_help(s)) != NULL) {
		vsrm(s);
		help_actual = new_help;
		return (help_on(base->parent->t));
	}
	vsrm(s);
	return (-1);
}
int u_helpcard(BASE *base)
{
	if (wmkpw(base->parent, UC "Name of help card to show: ", NULL,
	    do_helpcard, NULL, NULL, utypebw, NULL, NULL, locale_map)) {
		return (0);
	}
	return (-1);
}
@


1.29
log
@reorient the screen from column 0 on format, fmtblk, retype

allows us to get rid of the fmtln macro hack for jupp
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/cmd.c,v 1.25 2017/12/08 01:16:36 tg Exp $");
d249 1
@


1.28
log
@make ^KD retain the cursor position as well
@
text
@d167 1
a167 1
C("fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL),
d169 1
a169 1
C("format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL),
d231 1
a231 1
C("retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL),
d346 10
a355 2
	/* Make displayed cursor column equal the actual cursor column
	 * for commands which aren't simple vertical movements */
@


1.27
log
@small cleanups
@
text
@d346 1
a346 1
	/* Make dislayed cursor column equal the actual cursor column
@


1.26
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d347 1
a347 1
	 * for commands which arn't simple vertical movements */
@


1.25
log
@fix a couple of prompt window result string memory leaks
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/cmd.c,v 1.23 2017/12/06 23:58:36 tg Exp $");
d387 1
a387 1
	CMD *cmd = (CMD *) joe_malloc(sizeof(CMD));
@


1.24
log
@feeble first attempt at using a union to break up the UB in the polymorphism
@
text
@d70 2
a71 1
	if (!s || !*s || !(new_kmap = kmap_getcontext(s, 0)))
d73 1
d81 1
d465 2
a466 1
	if (!s || !*s) {
d474 1
d478 1
@


1.23
log
@make wmkpw const again
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/cmd.c,v 1.21 2017/12/06 21:41:01 tg Exp $");
d275 1
a275 1
	BW *bw = (BW *) maint->curwin->object;
d304 1
a304 1
		utoggle_marking(maint->curwin->object);
d324 1
a324 1
	bw = (BW *) maint->curwin->object;
@


1.22
log
@lots of fixes related to prototyping
@
text
@d84 1
a84 1
	if (wmkpw(bw->parent, US "Name of keymap to switch to: ", NULL,
d446 1
a446 1
	if (wmkpw(bw->parent, US "cmd: ", &cmdhist, docmd, US "cmd", NULL, cmdcmplt, NULL, NULL, locale_map)) {
d477 1
a477 1
	if (wmkpw(base->parent, US "Name of help card to show: ", NULL,
@


1.21
log
@const cleanup
@
text
@d12 1
a12 1
__RCSID("$MirOS: contrib/code/jupp/cmd.c,v 1.19 2017/12/02 02:07:25 tg Exp $");
d56 2
a57 1
int ubeep(BW *bw, int k)
@


1.20
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d98 1
a98 1
	msgnw(bw->parent, US "Sorry, not supported without MMU");
d106 1
d108 160
a267 160
	{US "abendjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabendjoe, NULL, 0, NULL},
	{US "abort", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uabort, NULL, 0, NULL},
	{US "abortbuf", TYPETW, uabortbuf, NULL, 0, NULL},
	{US "arg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uarg, NULL, 0, NULL},
	{US "ask", TYPETW + TYPEPW, uask, NULL, 0, NULL},
	{US "backs", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, ubacks, NULL, 1, US "delch"},
	{US "backsmenu", TYPEMENU, umbacks, NULL, 1, NULL},
	{US "backw", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EKILL + EMOD, ubackw, NULL, 1, US "delw"},
	{US "beep", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ubeep, NULL, 0, NULL},
	{US "begin_marking", TYPETW + TYPEPW, ubegin_marking, NULL, 0, NULL},
	{US "bknd", TYPETW + TYPEPW, ubknd, NULL, 0, NULL},
	{US "bkwdc", TYPETW + TYPEPW, ubkwdc, NULL, 1, US "fwrdc"},
	{US "blkcpy", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkcpy, NULL, 1, NULL},
	{US "blkdel", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD + EBLOCK, ublkdel, NULL, 0, NULL},
	{US "blkmove", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ublkmove, NULL, 0, NULL},
	{US "blksave", TYPETW + TYPEPW + EBLOCK, ublksave, NULL, 0, NULL},
	{US "bof", TYPETW + TYPEPW + EMOVE + EFIXXCOL, u_goto_bof, NULL, 0, NULL},
	{US "bofmenu", TYPEMENU, umbof, NULL, 0, NULL},
	{US "bol", TYPETW + TYPEPW + EFIXXCOL, u_goto_bol, NULL, 0, NULL},
	{US "bolmenu", TYPEMENU, umbol, NULL, 0, NULL},
	{US "bop", TYPETW + TYPEPW + EFIXXCOL, ubop, NULL, 1, US "eop"},
	{US "bos", TYPETW + TYPEPW + EMOVE, ubos, NULL, 0, NULL},
	{US "bufed", TYPETW, ubufed, NULL, 0, NULL},
	{US "build", TYPETW + TYPEPW, ubuild, NULL, 0, NULL},
	{US "byte", TYPETW + TYPEPW, ubyte, NULL, 0, NULL},
	{US "cancel", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ucancel, NULL, 0, NULL},
	{US "center", TYPETW + TYPEPW + EFIXXCOL + EMOD, ucenter, NULL, 1, NULL},
	{US "col", TYPETW + TYPEPW, ucol, NULL, 0, NULL},
	{US "complete", TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
	{US "copy", TYPETW + TYPEPW, ucopy, NULL, 0, NULL},
	{US "crawll", TYPETW + TYPEPW, ucrawll, NULL, 1, US "crawlr"},
	{US "crawlr", TYPETW + TYPEPW, ucrawlr, NULL, 1, US "crawll"},
	{US "ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
	{US "delbol", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelbl, NULL, 1, US "deleol"},
	{US "delch", TYPETW + TYPEPW + ECHKXCOL + EFIXXCOL + EMINOR + EKILL + EMOD, udelch, NULL, 1, US "backs"},
	{US "deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, US "delbol"},
	{US "dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL},
	{US "delw", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL + EKILL + EMOD, u_word_delete, NULL, 1, US "backw"},
	{US "dnarw", TYPETW + TYPEPW + EMOVE, udnarw, NULL, 1, US "uparw"},
	{US "dnarwmenu", TYPEMENU, umdnarw, NULL, 1, US "uparwmenu"},
	{US "dnslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, udnslide, NULL, 1, US "upslide"},
	{US "drop", TYPETW + TYPEPW, udrop, NULL, 0, NULL},
	{US "dupw", TYPETW, uduptw, NULL, 0, NULL},
	{US "edit", TYPETW, uedit, NULL, 0, NULL},
	{US "eof", TYPETW + TYPEPW + EFIXXCOL + EMOVE, u_goto_eof, NULL, 0, NULL},
	{US "eofmenu", TYPEMENU, umeof, NULL, 0, NULL},
	{US "eol", TYPETW + TYPEPW + EFIXXCOL, u_goto_eol, NULL, 0, NULL},
	{US "eolmenu", TYPEMENU, umeol, NULL, 0, NULL},
	{US "eop", TYPETW + TYPEPW + EFIXXCOL, ueop, NULL, 1, US "bop"},
	{US "execmd", TYPETW + TYPEPW, uexecmd, NULL, 0, NULL},
	{US "explode", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uexpld, NULL, 0, NULL},
	{US "exsave", TYPETW + TYPEPW, uexsve, NULL, 0, NULL},
	{US "ffirst", TYPETW + TYPEPW, pffirst, NULL, 0, NULL},
	{US "filt", TYPETW + TYPEPW + EMOD + EBLOCK, ufilt, NULL, 0, NULL},
	{US "finish", TYPETW + TYPEPW + EMOD, ufinish, NULL, 1, NULL},
	{US "fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL},
	{US "fnext", TYPETW + TYPEPW, pfnext, NULL, 1, NULL},
	{US "format", TYPETW + TYPEPW + EFIXXCOL + EMOD, uformat, NULL, 1, NULL},
	{US "fwrdc", TYPETW + TYPEPW, ufwrdc, NULL, 1, US "bkwdc"},
	{US "gomark", TYPETW + TYPEPW + EMOVE, ugomark, NULL, 0, NULL},
	{US "groww", TYPETW, ugroww, NULL, 1, US "shrinkw"},
	{US "help", TYPETW + TYPEPW + TYPEQW, u_help, NULL, 0, NULL},
	{US "helpcard", TYPETW + TYPEPW + TYPEQW, u_helpcard, NULL, 0, NULL},
	{US "hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
	{US "home", TYPETW + TYPEPW + EFIXXCOL, uhome, NULL, 0, NULL},
	{US "hprev", TYPETW + TYPEPW + TYPEQW, u_help_prev, NULL, 0, NULL},
	{US "insc", TYPETW + TYPEPW + EFIXXCOL + EMOD, uinsc, NULL, 1, US "delch"},
	{US "insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL},
	{US "isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{US "keymap", TYPETW + TYPEPW, ukeymap, NULL, 0, NULL},
	{US "killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL},
	{US "killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
	{US "lindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, ulindent, NULL, 1, US "rindent"},
	{US "line", TYPETW + TYPEPW, uline, NULL, 0, NULL},
	{US "lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL},
	{US "lower", TYPETW + TYPEPW + EMOD + EBLOCK, ulower, NULL, 0, NULL},
	{US "ltarw", TYPETW + TYPEPW /* + EFIXXCOL + ECHKXCOL */, u_goto_left, NULL, 1, US "rtarw"},
	{US "ltarwmenu", TYPEMENU, umltarw, NULL, 1, US "rtarwmenu"},
	{US "macros", TYPETW + EFIXXCOL, umacros, NULL, 0, NULL},
	{US "markb", TYPETW + TYPEPW, umarkb, NULL, 0, NULL},
	{US "markk", TYPETW + TYPEPW, umarkk, NULL, 0, NULL},
	{US "markl", TYPETW + TYPEPW, umarkl, NULL, 0, NULL},
	{US "math", TYPETW + TYPEPW, umath, NULL, 0, NULL},
	{US "mathins", TYPETW + TYPEPW, umathins, NULL, 0, NULL},
	{US "mathres", TYPETW + TYPEPW, umathres, NULL, 0, NULL},
	{US "mode", TYPETW + TYPEPW + TYPEQW, umode, NULL, 0, NULL},
	{US "msg", TYPETW + TYPEPW + TYPEQW + TYPEMENU, umsg, NULL, 0, NULL},
	{US "nbuf", TYPETW, unbuf, NULL, 1, US "pbuf"},
	{US "nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, US "pedge"},
	{US "nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, US "prevpos"},
	{US "nextw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unextw, NULL, 1, US "prevw"},
	{US "nextword", TYPETW + TYPEPW + EFIXXCOL, u_goto_next, NULL, 1, US "prevword"},
	{US "nmark", TYPETW + TYPEPW, unmark, NULL, 0, NULL},
	{US "nop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, unop, NULL, 0, NULL},
	{US "notmod", TYPETW, unotmod, NULL, 0, NULL},
	{US "nxterr", TYPETW, unxterr, NULL, 1, US "prverr"},
	{US "open", TYPETW + TYPEPW + EFIXXCOL + EMOD, uopen, NULL, 1, US "deleol"},
	{US "parserr", TYPETW, uparserr, NULL, 0, NULL},
	{US "pbuf", TYPETW, upbuf, NULL, 1, US "nbuf"},
	{US "pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, US "nedge"},
	{US "pgdn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgdn, NULL, 1, US "pgup"},
	{US "pgdnmenu", TYPEMENU, umpgdn, NULL, 1, US "pgupmenu"},
	{US "pgup", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, upgup, NULL, 1, US "pgdn"},
	{US "pgupmenu", TYPEMENU, umpgup, NULL, 1, US "pgdnmenu"},
	{US "picokill", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, upicokill, NULL, 1, NULL},
	{US "play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */
	{US "pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
	{US "prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, US "nextpos"},
	{US "prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, US "nextw"},
	{US "prevword", TYPETW + TYPEPW + EFIXXCOL + ECHKXCOL, u_goto_prev, NULL, 1, US "nextword"},
	{US "prverr", TYPETW, uprverr, NULL, 1, US "nxterr"},
	{US "psh", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upsh, NULL, 0, NULL},
	{US "qrepl", TYPETW + TYPEPW + EMOD, pqrepl, NULL, 0, NULL},
	{US "query", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uquery, NULL, 0, NULL},
	{US "querysave", TYPETW, uquerysave, NULL, 0, NULL},
	{US "quote", TYPETW + TYPEPW + EMOD, uquote, NULL, 0, NULL},
	{US "quote8", TYPETW + TYPEPW + EMOD, uquote8, NULL, 0, NULL},
	{US "record", TYPETW + TYPEPW + TYPEMENU + TYPEQW, urecord, NULL, 0, NULL},
	{US "redo", TYPETW + TYPEPW + EFIXXCOL, uredo, NULL, 1, US "undo"},
	{US "retype", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uretyp, NULL, 0, NULL},
	{US "rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL},
	{US "rindent", TYPETW + TYPEPW + EFIXXCOL + EMOD + EBLOCK, urindent, NULL, 1, US "lindent"},
	{US "rsrch", TYPETW + TYPEPW, ursrch, NULL, 0, NULL},
	{US "rtarw", TYPETW + TYPEPW /* + EFIXXCOL */, u_goto_right, NULL, 1, US "ltarw"}, /* EFIX removed for picture mode */
	{US "rtarwmenu", TYPEMENU, umrtarw, NULL, 1, US "ltarwmenu"},
	{US "rtn", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOD, urtn, NULL, 1, NULL},
	{US "run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
	{US "rvmatch", TYPETW + TYPEPW + EFIXXCOL, urvmatch, NULL, 0, NULL},
	{US "save", TYPETW, usave, NULL, 0, NULL},
	{US "scratch", TYPETW + TYPEPW, uscratch, NULL, 0, NULL},
	{US "select", TYPETW + TYPEPW, uselect, NULL, 0, NULL},
	{US "setmark", TYPETW + TYPEPW, usetmark, NULL, 0, NULL},
	{US "shell", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ushell, NULL, 0, NULL},
	{US "shrinkw", TYPETW, ushrnk, NULL, 1, US "groww"},
	{US "splitw", TYPETW, usplitw, NULL, 0, NULL},
	{US "stat", TYPETW + TYPEPW, ustat_j, NULL, 0, NULL},
	{US "stop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ustop, NULL, 0, NULL},
	{US "swap", TYPETW + TYPEPW + EFIXXCOL, uswap, NULL, 0, NULL},
	{US "switch", TYPETW + TYPEPW, uswitch, NULL, 0, NULL},
	{US "tabmenu", TYPEMENU, umtab, NULL, 1, US "ltarwmenu"},
	{US "tag", TYPETW + TYPEPW, utag, NULL, 0, NULL},
	{US "toggle_marking", TYPETW + TYPEPW, utoggle_marking, NULL, 0, NULL},
	{US "tomarkb", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkb, NULL, 0, NULL},
	{US "tomarkbk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkbk, NULL, 0, NULL},
	{US "tomarkk", TYPETW + TYPEPW + EFIXXCOL + EBLOCK, utomarkk, NULL, 0, NULL},
	{US "tomatch", TYPETW + TYPEPW + EFIXXCOL, utomatch, NULL, 0, NULL},
	{US "tos", TYPETW + TYPEPW + EMOVE, utos, NULL, 0, NULL},
	{US "tw0", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw0, NULL, 0, NULL},
	{US "tw1", TYPETW + TYPEPW + TYPEQW + TYPEMENU, utw1, NULL, 0, NULL},
	{US "txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL},
	{US "type", TYPETW + TYPEPW + TYPEQW + TYPEMENU + EMINOR + EMOD, utype, NULL, 1, US "backs"},
	{US "uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
	{US "undo", TYPETW + TYPEPW + EFIXXCOL, uundo, NULL, 1, US "redo"},
	{US "uparw", TYPETW + TYPEPW + EMOVE, uuparw, NULL, 1, US "dnarw"},
	{US "uparwmenu", TYPEMENU, umuparw, NULL, 1, US "dnarwmenu"},
	{US "upper", TYPETW + TYPEPW + EMOD + EBLOCK, uupper, NULL, 0, NULL},
	{US "upslide", TYPETW + TYPEPW + TYPEMENU + TYPEQW + EMOVE, uupslide, NULL, 1, US "dnslide"},
	{US "yank", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyank, NULL, 1, NULL},
	{US "yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL},
	{US "yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL}
d306 1
a306 1
		msgnw(bw->parent, US "Read only");
d374 1
a374 1
CMD *findcmd(unsigned char *s)
d381 1
a381 1
void addcmd(unsigned char *s, MACRO *m)
d387 1
a387 1
	cmd->name = (unsigned char *)strdup((char *)s);
d429 1
a429 1
			msgnw(bw->parent, US "No such command");
@


1.19
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d12 1
a12 1
__RCSID("$MirOS$");
a13 1
#ifdef HAVE_STDLIB_H
a14 1
#endif
d242 1
a242 1
	{US "stat", TYPETW + TYPEPW, ustat, NULL, 0, NULL},
@


1.18
log
@disable anything using fork on NOMMU systems
@
text
@a0 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.16 2017/08/08 21:36:11 tg Exp $ */
d8 1
d12 2
@


1.17
log
@new command abendjoe to exit 1
@
text
@d95 11
@


1.16
log
@sort
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.11 2012/12/30 21:45:13 tg Exp $ */
d96 1
@


1.15
log
@fixup some tab completion madness
@
text
@a99 1
	{US "uarg", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uuarg, NULL, 0, NULL},
a121 1
	{US "ctrl", TYPETW + TYPEPW + EMOD, uctrl, NULL, 0, NULL},
d127 1
d150 1
a152 1
	{US "fmtblk", TYPETW + EMOD + EFIXXCOL + EBLOCK, ufmtblk, NULL, 1, NULL},
a155 3
	{US "isrch", TYPETW + TYPEPW, uisrch, NULL, 0, NULL},
	{US "killjoe", TYPETW + TYPEPW + TYPEMENU + TYPEQW, ukilljoe, NULL, 0, NULL},
	{US "killproc", TYPETW + TYPEPW, ukillpid, NULL, 0, NULL},
d158 1
a159 1
	{US "hnext", TYPETW + TYPEPW + TYPEQW, u_help_next, NULL, 0, NULL},
d163 1
d165 2
d201 1
a206 1
	{US "pop", TYPETW + TYPEPW + TYPEMENU + TYPEQW, upop, NULL, 0, NULL},
a216 1
	{US "run", TYPETW + TYPEPW, urun, NULL, 0, NULL},
d221 1
d246 1
d253 2
a254 2
	{US "yapp", TYPETW + TYPEPW + EKILL, uyapp, NULL, 0, NULL},
	{US "yankpop", TYPETW + TYPEPW + EFIXXCOL + EMOD, uyankpop, NULL, 1, NULL}
@


1.14
log
@mop up a bit
@
text
@d404 2
a405 1
	return simple_cmplt(bw,scmds);
@


1.13
log
@add rvmatch, same as tomatch but ambiguous go left
@
text
@d131 2
a132 2
	{US "deleol", TYPETW + TYPEPW + EKILL + EMOD, udelel, NULL, 1, US "delbol"}, 
	{US "dellin", TYPETW + TYPEPW + EFIXXCOL + EKILL + EMOD, udelln, NULL, 1, NULL}, 
d135 1
a135 1
	{US "dnarwmenu", TYPEMENU, umdnarw, NULL, 1, US "uparwmenu"}, 
d166 1
a166 1
	{US "insf", TYPETW + TYPEPW + EMOD, uinsf, NULL, 0, NULL}, 
d170 1
a170 1
	{US "lose", TYPETW + TYPEPW, ulose, NULL, 0, NULL}, 
d184 2
a185 2
	{US "nedge", TYPETW + TYPEPW + EFIXXCOL, unedge, NULL, 1, US "pedge"}, 
	{US "nextpos", TYPETW + TYPEPW + EFIXXCOL + EMID + EPOS, unextpos, NULL, 1, US "prevpos"}, 
d195 1
a195 1
	{US "pedge", TYPETW + TYPEPW + EFIXXCOL, upedge, NULL, 1, US "nedge"}, 
d197 1
a197 1
	{US "pgdnmenu", TYPEMENU, umpgdn, NULL, 1, US "pgupmenu"}, 
d199 1
a199 1
	{US "pgupmenu", TYPEMENU, umpgup, NULL, 1, US "pgdnmenu"}, 
d201 3
a203 3
	{US "play", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uplay, NULL, 1, NULL},	/* EFIXX? */ 
	{US "prevpos", TYPETW + TYPEPW + EPOS + EMID + EFIXXCOL, uprevpos, NULL, 1, US "nextpos"}, 
	{US "prevw", TYPETW + TYPEPW + TYPEMENU + TYPEQW, uprevw, NULL, 1, US "nextw"}, 
d216 1
a216 1
	{US "rfirst", TYPETW + TYPEPW, prfirst, NULL, 0, NULL}, 
d245 1
a245 1
	{US "txt", TYPETW + TYPEPW, utxt, NULL, 0, NULL}, 
d249 1
a249 1
	{US "uparwmenu", TYPEMENU, umuparw, NULL, 1, US "dnarwmenu"}, 
d327 1
a327 1
      skip:
@


1.12
log
@• “msg” editoe command with empty argument clears message
• add “nop” editor command
• permit changing keymap for prompt windows
• fix CUA keymap paste mode
• handle bracketed pasting for prompt windows
• ^L is now “nop” (i.e. redraw) for prompt windows (paste and normal)
@
text
@d223 1
@


1.11
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.8 2012/12/20 21:15:30 tg Exp $ */
d90 5
d167 1
a167 1
	{US "keymap", TYPETW, ukeymap, NULL, 0, NULL},
d189 1
@


1.10
log
@new command: helpcard
@
text
@d12 3
d22 1
d62 28
d162 1
@


1.9
log
@new bindings for math result insertion
@
text
@d124 1
d397 31
@


1.8
log
@^KE and ^KS do not work well in Prompt Windows
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.7 2010/01/03 17:54:07 tg Exp $ */
d140 2
@


1.7
log
@backport from joe-current: allow macros in Esc+- not just commands
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.6 2010/01/03 17:45:55 tg Exp $ */
d102 1
a102 1
	{US "edit", TYPETW + TYPEPW, uedit, NULL, 0, NULL},
d181 1
a181 1
	{US "save", TYPETW + TYPEPW, usave, NULL, 0, NULL},
@


1.6
log
@revision 1.68
date: 2006/02/28 23:51:28;  author: jhallen;  state: Exp;  lines: +1 -1
Fix bug where ESC x complete command core dumps.
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.5 2009/10/18 14:52:56 tg Exp $ */
a367 1
	CMD *cmd = findcmd(s);
d369 9
a378 7
	if (!cmd)
		msgnw(bw->parent, US "No such command");
	else {
		mac = mkmacro(-1, 0, 0, cmd);
		ret = exmacro(mac, 1);
		rmmacro(mac);
	}
@


1.5
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.4 2008/07/28 00:12:06 tg Exp $ */
d88 1
a88 1
	{US "complete", TYPETW + TYPEPW + EMINOR + EMOD, ucmplt, NULL, 0, NULL},
@


1.4
log
@rename symbol to avoid clash:

/usr/bin/ld: warning multiple definitions of symbol _beep
cmd.o definition of _beep in section (__DATA,__data)
/private/var/tglaser/iSDK/lib/libncurses.dylib(single module) definition of _beep

found during native(!) compilation on iPhone 3G (Darwin 9.3.1
iPhoneOS 2.0 iPhone1,2 arm N82AP), with gcc from saurik iphone-gcc
and headers and libraries copied from the 2.0 SDK. (It works fine.)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/cmd.c,v 1.3 2008/05/13 13:08:21 tg Exp $ */
d234 6
a239 3
	if ((cmd->flag & ECHKXCOL)
	    && bw->cursor->xcol != piscol(bw->cursor))
		goto skip;
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d47 1
a47 1
int beep = 0;
d248 1
a248 1
		if (beep)
d297 1
a297 1
	if (beep && ret)
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d222 1
a222 1
	(k==3 || k==13 || k==8 || k==127 || k==4 || cmd->func==utype && k>=32 && k<256)) {
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 11
a11 1
/* Command execution */
d13 1
a13 5
#include "config.h"
#include "vs.h"
#include "va.h"
#include "w.h"
#include "tw.h"
d15 8
d24 3
a26 4
#include "tab.h"
#include "qw.h"
#include "menu.h"
#include "help.h"
d29 1
d32 2
a35 1
#include "uisrch.h"
d38 5
a42 9
#include "poshist.h"
#include "macro.h"
#include "hash.h"
#include "rc.h"
#include "umath.h"
#include "uerror.h"
#include "path.h"
#include "zstr.h"
#include "cmd.h"
d44 1
d46 2
a47 2
int beep=0;
int uexecmd();
d51 1
a51 1
CMD cmds[]=
d53 158
a210 136
  { "abort", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uabort, 0, 0, 0 },
  { "abortbuf", TYPETW, uabortbuf, 0, 0, 0 },
  { "arg", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uarg, 0, 0, 0 },
  { "ask", TYPETW+TYPEPW, uask, 0, 0, 0 },
  { "uarg", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uuarg, 0, 0, 0 },
  { "backs", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR+EKILL+EMOD, ubacks, 0, 1, "delch" },
  { "backsmenu", TYPEMENU, umbacks, 0, 1, 0 },
  { "backw", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EKILL+EMOD, ubackw, 0, 1, "delw" },
  { "bknd", TYPETW+TYPEPW, ubknd, 0, 0, 0 },
  { "bkwdc", TYPETW+TYPEPW, ubkwdc, 0, 1, "fwrdc" },
  { "blkcpy", TYPETW+TYPEPW+EFIXXCOL+EMOD, ublkcpy, 0, 1, 0 },
  { "blkdel", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, ublkdel, 0, 0, 0 },
  { "blkmove", TYPETW+TYPEPW+EFIXXCOL+EMOD, ublkmove, 0, 0, 0 },
  { "blksave", TYPETW+TYPEPW+0, ublksave, 0, 0, 0 },
  { "bof", TYPETW+TYPEPW+EMOVE+EFIXXCOL, ubof, 0, 0, 0 },
  { "bofmenu", TYPEMENU, umbof, 0, 0, 0 },
  { "bol", TYPETW+TYPEPW+EFIXXCOL, ubol, 0, 0, 0 },
  { "bolmenu", TYPEMENU, umbol, 0, 0, 0 },
  { "bop", TYPETW+TYPEPW+EFIXXCOL, ubop, 0, 1, "eop" },
  { "bos", TYPETW+TYPEPW+EMOVE, ubos, 0, 0, 0 },
  { "bufed", TYPETW, ubufed, 0, 0, 0 },
  { "byte", TYPETW+TYPEPW, ubyte, 0, 0, 0 },
  { "center", TYPETW+TYPEPW+EFIXXCOL+EMOD, ucenter, 0, 1, 0 },
  { "ctrl", TYPETW+TYPEPW+EMOD, uctrl, 0, 0, 0 },
  { "col", TYPETW+TYPEPW, ucol, 0, 0, 0 },
  { "complete", TYPETW+TYPEPW+EMINOR+EMOD, ucmplt, 0, 0, 0 },
  { "copy", TYPETW+TYPEPW, ucopy, 0, 0, 0 },
  { "crawll", TYPETW+TYPEPW, ucrawll, 0, 1, "crawlr" },
  { "crawlr", TYPETW+TYPEPW, ucrawlr, 0, 1, "crawll" },
  { "delbol", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, udelbl, 0, 1, "deleol" },
  { "delch", TYPETW+TYPEPW+ECHKXCOL+EFIXXCOL+EMINOR+EKILL+EMOD, udelch, 0, 1, "backs" },
  { "deleol", TYPETW+TYPEPW+EKILL+EMOD, udelel, 0, 1, "delbol" },
  { "dellin", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, udelln, 0, 1, 0 },
  { "delw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL+EKILL+EMOD, udelw, 0, 1, "backw" },
  { "dnarw", TYPETW+TYPEPW+EMOVE, udnarw, 0, 1, "uparw" },
  { "dnarwmenu", TYPEMENU, umdnarw, 0, 1, "uparwmenu" },
  { "dnslide", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, udnslide, 0, 1, "upslide" },
  { "drop", TYPETW+TYPEPW, udrop, 0, 0, 0 },
  { "dupw", TYPETW, uduptw, 0, 0, 0 },
  { "edit", TYPETW+TYPEPW, uedit, 0, 0, 0 },
  { "eof", TYPETW+TYPEPW+EFIXXCOL+EMOVE, ueof, 0, 0, 0 },
  { "eofmenu", TYPEMENU, umeof, 0, 0, 0 },
  { "eol", TYPETW+TYPEPW+EFIXXCOL, ueol, 0, 0, 0 },
  { "eolmenu", TYPEMENU, umeol, 0, 0, 0 },
  { "eop", TYPETW+TYPEPW+EFIXXCOL, ueop, 0, 1, "bop" },
  { "execmd", TYPETW+TYPEPW, uexecmd, 0, 0, 0 },
  { "explode", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uexpld, 0, 0, 0 },
  { "exsave", TYPETW+TYPEPW, uexsve, 0, 0, 0 },
  { "ffirst", TYPETW+TYPEPW, pffirst, 0, 0, 0 },
  { "filt", TYPETW+TYPEPW+EMOD, ufilt, 0, 0, 0 },
  { "fnext", TYPETW+TYPEPW, pfnext, 0, 1, 0 },
  { "format", TYPETW+TYPEPW+EFIXXCOL+EMOD, uformat, 0, 1, 0 },
  { "fmtblk", TYPETW+EMOD+EFIXXCOL, ufmtblk, 0, 1, 0 },
  { "fwrdc", TYPETW+TYPEPW, ufwrdc, 0, 1, "bkwdc" },
  { "gomark", TYPETW+TYPEPW+EMOVE, ugomark, 0, 0, 0 },
  { "groww", TYPETW, ugroww, 0, 1, "shrinkw" },
  { "isrch", TYPETW+TYPEPW, uisrch, 0, 0, 0 },
  { "killproc", TYPETW+TYPEPW, ukillpid, 0, 0, 0 },
  { "help", TYPETW+TYPEPW+TYPEQW, uhelp, 0, 0, 0 },
  { "hnext", TYPETW+TYPEPW+TYPEQW, uhnext, 0, 0, 0 },
  { "hprev", TYPETW+TYPEPW+TYPEQW, uhprev, 0, 0, 0 },
  { "insc", TYPETW+TYPEPW+EFIXXCOL+EMOD, uinsc, 0, 1, "delch" },
  { "insf", TYPETW+TYPEPW+EMOD, uinsf, 0, 0, 0 },
  { "lindent", TYPETW+TYPEPW+EFIXXCOL+EMOD, ulindent, 0, 1, "rindent" },
  { "line", TYPETW+TYPEPW, uline, 0, 0, 0 },
  { "lose", TYPETW+TYPEPW, ulose, 0, 0, 0 },
  { "ltarw", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, ultarw, 0, 1, "rtarw" },
  { "ltarwmenu", TYPEMENU, umltarw, 0, 1, "rtarwmenu" },
  { "macros", TYPETW+EFIXXCOL, umacros, 0, 0, 0 },
  { "markb", TYPETW+TYPEPW+0, umarkb, 0, 0, 0 },
  { "markk", TYPETW+TYPEPW+0, umarkk, 0, 0, 0 },
  { "markl", TYPETW+TYPEPW, umarkl, 0, 0, 0 },
  { "math", TYPETW+TYPEPW, umath, 0, 0, 0 },
  { "mode", TYPETW+TYPEPW+TYPEQW, umode, 0, 0, 0 },
  { "msg", TYPETW+TYPEPW+TYPEQW+TYPEMENU, umsg, 0, 0, 0 },
  { "nbuf", TYPETW, unbuf, 0, 1, "upbuf" },
  { "nedge", TYPETW+TYPEPW+EFIXXCOL, unedge, 0, 1, "pedge" },
  { "nextpos", TYPETW+TYPEPW+EFIXXCOL+EMID+EPOS, unextpos, 0, 1, "prevpos" },
  { "nextw", TYPETW+TYPEPW+TYPEMENU+TYPEQW, unextw, 0, 1, "prevw" },
  { "nextword", TYPETW+TYPEPW+EFIXXCOL, unxtwrd, 0, 1, "prevword" },
  { "nmark", TYPETW+TYPEPW, unmark, 0, 0, 0 },
  { "notmod", TYPETW, unotmod, 0, 0, 0 },
  { "nxterr", TYPETW, unxterr, 0, 1, "prverr" },
  { "open", TYPETW+TYPEPW+EFIXXCOL+EMOD, uopen, 0, 1, "deleol" },
  { "parserr", TYPETW, uparserr, 0, 0, 0 },
  { "pbuf", TYPETW, upbuf, 0, 1, "unbuf" },
  { "pedge", TYPETW+TYPEPW+EFIXXCOL, upedge, 0, 1, "nedge" },
  { "pgdn", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgdn, 0, 1, "pgup" },
  { "pgup", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, upgup, 0, 1, "pgdn" },
  { "picokill", TYPETW+TYPEPW+EFIXXCOL+EKILL+EMOD, upicokill, 0, 1, 0 },
  { "play", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uplay, 0, 1, 0 }, /* EFIXX? */
  { "prevpos", TYPETW+TYPEPW+EPOS+EMID+EFIXXCOL, uprevpos, 0, 1, "nextpos" },
  { "prevw", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uprevw, 0, 1, "nextw" },
  { "prevword", TYPETW+TYPEPW+EFIXXCOL+ECHKXCOL, uprvwrd, 0, 1, "nextword" },
  { "prverr", TYPETW, uprverr, 0, 1, "nxterr" },
  { "psh", TYPETW+TYPEPW+TYPEMENU+TYPEQW, upsh, 0, 0, 0 },
  { "pop", TYPETW+TYPEPW+TYPEMENU+TYPEQW, upop, 0, 0, 0 },
  { "qrepl", TYPETW+TYPEPW+EMOD, pqrepl, 0, 0, 0 },
  { "query", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uquery, 0, 0, 0 },
  { "quote", TYPETW+TYPEPW+EMOD, uquote, 0, 0, 0 },
  { "quote8", TYPETW+TYPEPW+EMOD, uquote8, 0, 0, 0 },
  { "record", TYPETW+TYPEPW+TYPEMENU+TYPEQW, urecord, 0, 0, 0 },
  { "redo", TYPETW+TYPEPW+EFIXXCOL, uredo, 0, 1, "undo" },
  { "retype", TYPETW+TYPEPW+TYPEMENU+TYPEQW, uretyp, 0, 0, 0 },
  { "rfirst", TYPETW+TYPEPW, prfirst, 0, 0, 0 },
  { "rindent", TYPETW+TYPEPW+EFIXXCOL+EMOD, urindent, 0, 1, "lindent" },
  { "run", TYPETW+TYPEPW, urun, 0, 0, 0 },
  { "rsrch", TYPETW+TYPEPW, ursrch, 0, 0, 0 },
  { "rtarw", TYPETW+TYPEPW+EFIXXCOL, urtarw, 0, 1, "ltarw" },
  { "rtarwmenu", TYPEMENU, umrtarw, 0, 1, "ltarwmenu" },
  { "rtn", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOD, urtn, 0, 1, 0 },
  { "save", TYPETW+TYPEPW, usave, 0, 0, 0 },
  { "setmark", TYPETW+TYPEPW, usetmark, 0, 0, 0 },
  { "shell", TYPETW+TYPEPW+TYPEMENU+TYPEQW, ushell, 0, 0, 0 },
  { "shrinkw", TYPETW, ushrnk, 0, 1, "groww" },
  { "splitw", TYPETW, usplitw, 0, 0, 0 },
  { "stat", TYPETW+TYPEPW, ustat, 0, 0, 0 },
  { "stop", TYPETW+TYPEPW+TYPEMENU+TYPEQW, ustop, 0, 0, 0 },
  { "swap", TYPETW+TYPEPW+EFIXXCOL, uswap, 0, 0, 0 },
  { "tag", TYPETW+TYPEPW, utag, 0, 0, 0 },
  { "tomarkb", TYPETW+TYPEPW+EFIXXCOL, utomarkb, 0, 0, 0 },
  { "tomarkbk", TYPETW+TYPEPW+EFIXXCOL, utomarkbk, 0, 0, 0 },
  { "tomarkk", TYPETW+TYPEPW+EFIXXCOL, utomarkk, 0, 0, 0 },
  { "tomatch", TYPETW+TYPEPW+EFIXXCOL, utomatch, 0, 0, 0 },
  { "tos", TYPETW+TYPEPW+EMOVE, utos, 0, 0, 0 },
  { "tw0", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utw0, 0, 0, 0 },
  { "tw1", TYPETW+TYPEPW+TYPEQW+TYPEMENU, utw1, 0, 0, 0 },
  { "txt", TYPETW+TYPEPW, utxt, 0, 0, 0 },
  { "type", TYPETW+TYPEPW+TYPEQW+TYPEMENU+EMINOR+EMOD, utype, 0, 1, "backs" },
  { "undo", TYPETW+TYPEPW+EFIXXCOL, uundo, 0, 1, "redo" },
  { "uparw", TYPETW+TYPEPW+EMOVE, uuparw, 0, 1, "dnarw" },
  { "uparwmenu", TYPEMENU, umuparw, 0, 1, "dnarwmenu" },
  { "upslide", TYPETW+TYPEPW+TYPEMENU+TYPEQW+EMOVE, uupslide, 0, 1, "dnslide" },
  { "yank", TYPETW+TYPEPW+EFIXXCOL+EMOD, uyank, 0, 1, 0 },
  { "yapp", TYPETW+TYPEPW+EKILL, uyapp, 0, 0, 0 },
  { "yankpop", TYPETW+TYPEPW+EFIXXCOL+EMOD, uyankpop, 0, 1, 0 }
d215 85
a299 65
int execmd(cmd,k)
CMD *cmd;
 {
 BW *bw=(BW *)maint->curwin->object;
 int ret= -1;

 if(cmd->m) return exmacro(cmd->m,0);

 /* We don't execute if we have to fix the column position first
  * (i.e., left arrow when cursor is in middle of nowhere) */
 if((cmd->flag&ECHKXCOL) && bw->cursor->xcol!=piscol(bw->cursor))
  goto skip;

 /* Don't execute command if we're in wrong type of window */
 if(!(cmd->flag&maint->curwin->watom->what)) goto skip;

 if((maint->curwin->watom->what&TYPETW) && bw->b->rdonly &&
    (cmd->flag&EMOD))
  {
  msgnw(bw,"Read only");
  if(beep) ttputc(7);
  goto skip;
  }

 /* Execute command */
 ret=cmd->func(maint->curwin->object,k);

 if(smode) --smode;

 /* Don't update anything if we're going to leave */
 if(leave) return 0;

 bw=(BW *)maint->curwin->object;

 /* Maintain position history */
 /* If command was not a positioning command */
 if(!(cmd->flag&EPOS) &&
    (maint->curwin->watom->what&(TYPETW|TYPEPW)))
  afterpos();

 /* If command was not a movement */
 if(!(cmd->flag&(EMOVE|EPOS)) &&
    (maint->curwin->watom->what&(TYPETW|TYPEPW)))
  aftermove(maint->curwin,bw->cursor);

 if(cmd->flag&EKILL) justkilled=1;
 else justkilled=0;

 skip:

 /* Make dislayed cursor column equal the actual cursor column
  * for commands which arn't simple vertical movements */
 if(cmd->flag&EFIXXCOL) bw->cursor->xcol=piscol(bw->cursor);

 /* Recenter cursor to middle of screen */
 if(cmd->flag&EMID)
  {
  int omid=mid; mid=1;
  dofollows();
  mid=omid;
  }

 if(beep && ret) ttputc(7);
 return ret;
 }
d303 1
a303 1
HASH *cmdhash=0;
d305 43
a347 40
void izcmds()
 {
 int x;
 cmdhash=htmk(256);
 for(x=0;x!=sizeof(cmds)/sizeof(CMD);++x) htadd(cmdhash,cmds[x].name,cmds+x);
 }

CMD *findcmd(s)
char *s;
 {
 if(!cmdhash) izcmds();
 return (CMD *)htfind(cmdhash,s);
 }

void addcmd(s,m)
char *s;
MACRO *m;
 {
 CMD *cmd=(CMD *)malloc(sizeof(CMD));
 if(!cmdhash) izcmds();
 cmd->name=zdup(s);
 cmd->flag=0;
 cmd->func=0;
 cmd->m=m;
 cmd->arg=1;
 cmd->negarg=0;
 htadd(cmdhash,cmd->name,cmd);
 }

char **getcmds()
 {
 char **s=vaensure(NULL,sizeof(cmds)/sizeof(CMD));
 int x;
 HENTRY *e;
 for(x=0;x!=cmdhash->len;++x)
  for(e=cmdhash->tab[x];e;e=e->next)
   s=vaadd(s,vsncpy(NULL,0,sz(e->name)));
 vasort(s,aLen(s));
 return s;
 }
d351 1
a351 1
char **scmds=0;
d353 36
a388 113
char **regsub(z,len,s)
char **z;
char *s;
 {
 char **lst=0;
 int x;
 for(x=0;x!=len;++x) if(rmatch(s,z[x])) lst=vaadd(lst,vsncpy(NULL,0,sz(z[x])));
 return lst;
 }

void inscmd(bw,line)
BW *bw;
char *line;
 {
 P *p=pdup(bw->cursor); pbol(p);
 peol(bw->cursor);
 bdel(p,bw->cursor);
 binsm(bw->cursor,sv(line)); peol(bw->cursor);
 prm(p);
 bw->cursor->xcol=piscol(bw->cursor);
 }

int cmdabrt(bw,x,line)
BW *bw;
char *line;
 {
 if(line) inscmd(bw,line), vsrm(line);
 return -1;
 }

int cmdrtn(m,x,line)
MENU *m;
char *line;
 {
 inscmd(m->parent->win->object,m->list[x]);
 vsrm(line);
 m->object=0;
 wabort(m->parent);
 return 0;
 }

int cmdcmplt(bw)
BW *bw;
 {
 MENU *m;
 P *p, *q; 
 char *line;
 char *line1;
 char **lst;
 if(!scmds) scmds=getcmds();
 p=pdup(bw->cursor); pbol(p);
 q=pdup(bw->cursor); peol(q);
 line=brvs(p,(int)(q->byte-p->byte)); /* Assumes short lines :-) */
 prm(p); prm(q);
 m=mkmenu(bw,NULL,cmdrtn,cmdabrt,NULL,0,line,NULL);
 if(!m) return -1;
 line1=vsncpy(NULL,0,sv(line));
 line1=vsadd(line1,'*');
 lst=regsub(scmds,aLEN(scmds),line1);
 vsrm(line1);
 ldmenu(m,lst,0);
 if(!lst)
  {
  wabort(m->parent);
  ttputc(7);
  return -1;
  }
 else
  {
  if(aLEN(lst)==1) return cmdrtn(m,0,line);
  else if(smode || isreg(line)) return 0;
  else
   {
   char *com=mcomplete(m);
   vsrm(m->object);
   m->object=com;
   wabort(m->parent);
   smode=2;
   ttputc(7);
   return 0;
   }
  }
 }

int docmd(bw,s,object,notify)
BW *bw;
char *s;
void *object;
int *notify;
 {
 MACRO *mac;
 int ret= -1;
 CMD *cmd=findcmd(s);
 if(!cmd)
  msgnw(bw,"No such command");
 else
  {
  mac=mkmacro(MAXINT,0,0,cmd);
  ret=exmacro(mac,1);
  rmmacro(mac);
  }
 if(notify) *notify=1;
 return ret;
 }

B *cmdhist=0;

int uexecmd(bw)
BW *bw;
 {
 if(wmkpw(bw,"cmd: ",&cmdhist,docmd,"cmd",NULL,cmdcmplt,NULL,NULL)) return 0;
 else return -1;
 }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
