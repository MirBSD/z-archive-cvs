head	1.45;
access;
symbols
	joe-3_1jupp38:1.45
	joe-3_1jupp37:1.45
	joe-3_1jupp36:1.44
	joe-3_1jupp35:1.44
	joe-3_1jupp34:1.44
	joe-3_1jupp33:1.44
	joe-3_1jupp32:1.38
	joe-2_8jupp3:1.1.21.1
	joe-3_1jupp31:1.26
	joe-3_1jupp30:1.19
	joe-3_1jupp29:1.13
	joe-3_1jupp28:1.13
	joe-3_1jupp27:1.12
	joe-3_1jupp26:1.12
	joe-3_1jupp25:1.11
	joe-3_1jupp24:1.11
	joe-3_1jupp23:1.11
	joe-3_1jupp22:1.8
	joe-3_1jupp21:1.8
	joe-3_1jupp20:1.8
	joe-3_1jupp19:1.8
	joe-3_1jupp18:1.8
	joe-3_1jupp17:1.7
	joe-2_8jupp2:1.1.21.1
	joe-3_1jupp16:1.7
	joe-3_1jupp15:1.7
	joe-3_1jupp14:1.7
	joe-3_1jupp12:1.6
	joe-3_1jupp11:1.3
	joe-2_8jupp1:1.1.21.1
	joe-3_1jupp10:1.3
	joe-3_1jupp9:1.3
	joe-3_1jupp8:1.2
	joe-3_1jupp7:1.2
	joe-3_1jupp6:1.2
	joe-3_1jupp5:1.2
	joe-3_1jupp4:1.2
	joe-2_8-msdos:1.1.21.1.0.2
	joe-2_8:1.1.21.1
	joe28:1.1.21
	joe-3_1:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.45
date	2018.06.28.03.11.13;	author tg;	state Exp;
branches;
next	1.44;
commitid	1005B3451EB7AFBC7B2;

1.44
date	2018.01.08.04.07.56;	author tg;	state Exp;
branches;
next	1.43;
commitid	1005A52EEB35BB2EBDA;

1.43
date	2018.01.08.02.01.20;	author tg;	state Exp;
branches;
next	1.42;
commitid	1005A52D0FA22192115;

1.42
date	2018.01.08.01.56.22;	author tg;	state Exp;
branches;
next	1.41;
commitid	1005A52CFDB5F3E75CE;

1.41
date	2018.01.08.00.53.51;	author tg;	state Exp;
branches;
next	1.40;
commitid	1005A52C0FC77D35975;

1.40
date	2018.01.07.23.51.34;	author tg;	state Exp;
branches;
next	1.39;
commitid	1005A52B281212EC267;

1.39
date	2017.12.20.23.40.35;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005A3AF50817509B07;

1.38
date	2017.12.08.02.57.17;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005A29FFA5545539A0;

1.37
date	2017.12.08.02.46.45;	author tg;	state Exp;
branches;
next	1.36;
commitid	1005A29FD2A06CBDCE5;

1.36
date	2017.12.08.02.28.06;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005A29F8C708B176AB;

1.35
date	2017.12.08.02.17.22;	author tg;	state Exp;
branches;
next	1.34;
commitid	1005A29F64A06DEB239;

1.34
date	2017.12.08.02.00.40;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005A29F2506E789D2B;

1.33
date	2017.12.06.21.41.02;	author tg;	state Exp;
branches;
next	1.32;
commitid	1005A28640547F64250;

1.32
date	2017.12.06.21.16.59;	author tg;	state Exp;
branches;
next	1.31;
commitid	1005A285E5918D423C7;

1.31
date	2017.12.04.22.15.39;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005A25C91E16B3B365;

1.30
date	2017.12.02.04.49.46;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005A2230F819A57B5F;

1.29
date	2017.12.02.04.32.41;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005A222CF2122034D9;

1.28
date	2017.12.02.02.07.31;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005A220AD65C90E687;

1.27
date	2017.11.18.16.02.04;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005A1059874C70192A;

1.26
date	2017.08.08.16.09.43;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005989E25A6D58D2BB;

1.25
date	2017.07.09.01.19.54;	author tg;	state Exp;
branches;
next	1.24;
commitid	100596184CB6D8805CB;

1.24
date	2017.07.09.01.15.51;	author tg;	state Exp;
branches;
next	1.23;
commitid	100596183D53C63D865;

1.23
date	2017.07.09.01.03.53;	author tg;	state Exp;
branches;
next	1.22;
commitid	100596180C5008CC96E;

1.22
date	2017.07.08.16.23.26;	author tg;	state Exp;
branches;
next	1.21;
commitid	10059610714037A3711;

1.21
date	2017.07.08.16.19.23;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005961061A2DE59FDC;

1.20
date	2017.07.08.15.38.53;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005960FCA741D1B24A;

1.19
date	2017.01.10.23.59.33;	author tg;	state Exp;
branches;
next	1.18;
commitid	100587575750EFBF44B;

1.18
date	2017.01.10.20.14.37;	author tg;	state Exp;
branches;
next	1.17;
commitid	100587540BF73644DCC;

1.17
date	2017.01.10.19.27.35;	author tg;	state Exp;
branches;
next	1.16;
commitid	100587535BD5C0B4624;

1.16
date	2017.01.10.19.19.55;	author tg;	state Exp;
branches;
next	1.15;
commitid	100587533F1537F32FB;

1.15
date	2017.01.10.18.47.28;	author tg;	state Exp;
branches;
next	1.14;
commitid	10058752C5604AE9D9D;

1.14
date	2017.01.10.17.59.17;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005875210229B2EFAA;

1.13
date	2014.07.25.20.43.01;	author tg;	state Exp;
branches;
next	1.12;
commitid	10053D2C15C736C09AA;

1.12
date	2013.11.07.21.50.35;	author tg;	state Exp;
branches;
next	1.11;
commitid	100527C0B43044C6E4A;

1.11
date	2012.12.30.21.45.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050E0B5FE41C91584;

1.10
date	2012.12.30.17.10.57;	author tg;	state Exp;
branches;
next	1.9;
commitid	10050E075B939751F66;

1.9
date	2012.12.22.00.06.13;	author tg;	state Exp;
branches;
next	1.8;
commitid	10050D4F965570AEE79;

1.8
date	2011.10.04.20.05.29;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E8B6720059E78E7;

1.7
date	2010.04.08.15.31.03;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004BBDF6C54CC9A0DB;

1.6
date	2009.10.18.14.52.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004ADB2BD317498872;

1.5
date	2009.10.18.13.51.26;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004ADB1D69643DAE72;

1.4
date	2009.10.18.13.50.11;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004ADB1D0D1EF65E3D;

1.3
date	2008.05.13.13.08.25;	author tg;	state Exp;
branches;
next	1.2;
commitid	100482992BC01EE89A1;

1.2
date	2005.02.05.02.42.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches
	1.1.21.1
	1.1.201.1;
next	;

1.1.21.1
date	2005.02.12.15.40.22;	author tg;	state Exp;
branches;
next	;

1.1.201.1
date	2005.02.05.00.37.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.45
log
@remove another occurrence of 0x1000FFFE as we directly assign the to be displayed replacement character to c (XXX the SBCS<->Unicode mappings are questionable anyway)
@
text
@/*
 *	device-independent TTY interface for JOE
 *	Copyright
 *		(C) 1992 Joseph H. Allen
 *
 *	This file is part of JOE (Joe's Own Editor)
 */
#include "config.h"
#include "types.h"

__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.43 2018/01/08 02:01:20 tg Exp $");

#include <stdlib.h>
#include <string.h>

#include "bw.h"
#include "blocks.h"
#include "scrn.h"
#include "termcap.h"
#include "charmap.h"
#include "utils.h"

int skiptop = 0;
int lines = 0;
int columns = 0;
int notite = 0;
int pastetite = 0;
int usetabs = 0;
int assume_color = 0;

static int
xlat(int chkasis, int c, int *ap, struct charmap *map)
{
	if (joe_isprint(map, c))
		return (c);
	if (chkasis && dspasis && c >= 128)
		return (c);

	if (c & 0x80) {
		c &= 0x7F;
		*ap ^= INVERSE;
	}
	if (c < 0x20 || c == 0x7F) {
		c ^= 0x40;
		*ap ^= UNDERLINE;
	}
	return (c);
}

/* Set attributes */

int set_attr(SCRN *t, int c)
{
	int e;

	c &= ~255;

	/* Attributes which have gone off */
	e = ((AT_MASK|FG_NOT_DEFAULT|BG_NOT_DEFAULT)&t->attrib & ~c);

	if (e) {	/* If any attribute go off, switch them all off: fixes bug on PCs */
		if (t->me)
			texec(t->cap, t->me, 1, 0, 0, 0, 0);
		else {
			if (t->ue)
				texec(t->cap, t->ue, 1, 0, 0, 0, 0);
			if (t->se)
				texec(t->cap, t->se, 1, 0, 0, 0, 0);
		}
		t->attrib = 0;
	}

	/* Attributes which have turned on */
	e = (c & ~t->attrib);

	if (e & INVERSE) {
		if (t->mr)
			texec(t->cap, t->mr, 1, 0, 0, 0, 0);
		else if (t->so)
			texec(t->cap, t->so, 1, 0, 0, 0, 0);
	}

	if (e & UNDERLINE)
		if (t->us)
			texec(t->cap, t->us, 1, 0, 0, 0, 0);
	if (e & BLINK)
		if (t->mb)
			texec(t->cap, t->mb, 1, 0, 0, 0, 0);
	if (e & BOLD)
		if (t->md)
			texec(t->cap, t->md, 1, 0, 0, 0, 0);
	if (e & DIM)
		if (t->mh)
			texec(t->cap, t->mh, 1, 0, 0, 0, 0);

	if ((t->attrib&FG_MASK)!=(c&FG_MASK))
		if (t->Sf) texec(t->cap,t->Sf,1,7-(((c&FG_VALUE)>>FG_SHIFT)),0,0,0);

	if ((t->attrib&BG_MASK)!=(c&BG_MASK))
		if (t->Sb) texec(t->cap,t->Sb,1,((c&BG_VALUE)>>BG_SHIFT),0,0,0);

	t->attrib = c;

	return 0;
}

/* Output character with attributes */

void
outatr_help(SCRN *t, int *scrn, int *attrf, int xx, int yy, int c, int a)
{
	/* kludge for help_display() only */
	if (locale_map->type)
		c = xlat(0, c, &a, locale_map);
	outatr(locale_map, t, scrn, attrf, xx, yy, c, a);
}

void
outatr(struct charmap *map, SCRN *t, int *scrn, int *attrf, int xx, int yy, int c, int a)
{
	int wid = 1;

	if (locale_map->type) {
		/* to UTF-8 terminal */
		if (map->type) {
			/* from UTF-8 file */
			switch ((wid = unictrl(c))) {
			case 0:
				/* not a control character */
				wid = joe_wcwidth(c);
				break;
			case 1:
				c ^= 0x40;
				/* FALLTHROUGH */
			default:
				a ^= UNDERLINE;
				break;
			}
		} else {
			/* from SBCS file */
			c = to_uni(map, xlat(1, c, &a, map));
			if (c < 32 || (c >= 0x7F && c < 0xA0)) {
				c = 0xFFFD;
				a = (a | UNDERLINE) ^ INVERSE;
			}
		}
	} else {
		/* to SBCS terminal */
		if (map->type) {
			/* from UTF-8 file */

			/* don't convert control chars below 256 */
			if ((c >= 0x20 && c < 0x7F) || c >= 0xA0) {
				if (unictrl(c))
					a ^= UNDERLINE;
				if ((c = from_uni(locale_map, c)) == -1) {
					c = '!';
					a |= UNDERLINE;
				}
			}
		}
		c = xlat(1, c, &a, locale_map);
	}

	if (*scrn == c && *attrf == a)
		return;

	*scrn = c;
	*attrf = a;
	if (t->ins)
		clrins(t);
	if (t->x != xx || t->y != yy)
		cpos(t, xx, yy);
	if (t->attrib != a)
		set_attr(t, a);
	if (!locale_map->type) {
		/* SBCS terminal */
		ttputc(c);
	} else if (map->type && *unictrlbuf) {
		/* UTF-8 control char, masked */
		ttputs(unictrlbuf);
	} else {
		unsigned char buf[7];

		utf8_encode(buf, c);
		ttputs(buf);
		if (wid == 0 && xx > 0)
			attrf[-1] |= HAS_COMBINING;
	}
	t->x += wid;
	while (wid-- > 1) {
		*++scrn = -1;
		*++attrf = 0;
	}
}

/* Set scrolling region */

static void setregn(SCRN *t, int top, int bot)
{
	if (!t->cs) {
		t->top = top;
		t->bot = bot;
		return;
	}
	if (t->top != top || t->bot != bot) {
		t->top = top;
		t->bot = bot;
		texec(t->cap, t->cs, 1, top, bot - 1, 0, 0);
		t->x = -1;
		t->y = -1;
	}
}

/* Enter insert mode */

static void setins(SCRN *t, int x)
{
	if (t->ins != 1 && t->im) {
		t->ins = 1;
		texec(t->cap, t->im, 1, x, 0, 0, 0);
	}
}

/* Exit insert mode */

int clrins(SCRN *t)
{
	if (t->ins != 0) {
		texec(t->cap, t->ei, 1, 0, 0, 0, 0);
		t->ins = 0;
	}
	return 0;
}

/* Erase from given screen coordinate to end of line */

int eraeol(SCRN *t, int x, int y)
{
	int *s, *ss, *a, *aa;
	int w = t->co - x - 1;	/* Don't worry about last column */

	if (w <= 0)
		return 0;
	s = t->scrn + y * t->co + x;
	a = t->attr + y * t->co + x;
	ss = s + w;
	aa = a + w;
	do {
		if (*--ss != ' ') {
			++ss;
			break;
		} else if (*--aa != 0) {
			++ss;
			++aa;
			break;
		}
	} while (ss != s);
	if ((ss - s > 3 || s[w] != ' ' || a[w] != 0) && t->ce) {
		cpos(t, x, y);
		set_attr(t, 0);
		texec(t->cap, t->ce, 1, 0, 0, 0, 0);
		msetI(s, ' ', w);
		msetI(a, 0, w);
	} else if (s != ss) {
		if (t->ins)
			clrins(t);
		if (t->x != x || t->y != y)
			cpos(t, x, y);
		if (t->attrib)
			set_attr(t, 0);
		while (s != ss) {
			*s = ' ';
			*a = 0;
			ttputc(' ');
			++t->x;
			++s;
			++a;
		}
	}
	return 0;
}

static void out(unsigned char *t, unsigned char c)
{
	ttputc(c);
}

SCRN *nopen(CAP *cap)
{
	SCRN *t = calloc(1, sizeof(SCRN));
	int x, y;

	ttopen();

	t->cap = cap;
	setcap(cap, baud, out, NULL);

	t->li = getnum(t->cap, UC "li");
	if (t->li < 1)
		t->li = 24;
	t->co = getnum(t->cap, UC "co");
	if (t->co < 2)
		t->co = 80;
	x = y = 0;
	ttgtsz(&x, &y);
	if (x > 7 && y > 3) {
		t->li = y;
		t->co = x;
	}

	t->haz = getflag(t->cap, UC "hz");
	t->os = getflag(t->cap, UC "os");
	t->eo = getflag(t->cap, UC "eo");
	if (getflag(t->cap, UC "hc"))
		t->os = 1;
	if (t->os || getflag(t->cap, UC "ul"))
		t->ul = 1;

	t->xn = getflag(t->cap, UC "xn");
	t->am = getflag(t->cap, UC "am");

	t->cl = jgetstr(t->cap, UC "cl");
	t->cd = jgetstr(t->cap, UC "cd");

	if (!notite) {
		t->ti = jgetstr(t->cap, UC "ti");
		t->te = jgetstr(t->cap, UC "te");
	}
	if (pastetite && t->cap->paste_on && t->cap->paste_off) {
		if (notite) {
			t->ti = t->cap->paste_on;
			t->te = t->cap->paste_off;
		} else {
			size_t n1, n2;
			char *cp;

			n1 = t->ti ? strlen(t->ti) : 0;
			n2 = strlen(t->cap->paste_on);
			cp = malloc(n1 + n2 + 1);
			if (t->ti)
				memcpy(cp, t->ti, n1);
			memcpy(cp + n1, t->cap->paste_on, n2 + 1);
			t->ti = cp;

			n1 = t->te ? strlen(t->te) : 0;
			n2 = strlen(t->cap->paste_off);
			cp = malloc(n1 + n2 + 1);
			memcpy(cp, t->cap->paste_off, n2 + 1);
			if (t->te)
				memcpy(cp + n2, t->te, n1 + 1);
			t->te = cp;
		}
	}

	t->ut = getflag(t->cap, UC "ut");
	t->Sb = jgetstr(t->cap, UC "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap, UC "Sb");
	t->Sf = jgetstr(t->cap, UC "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap, UC "Sf");

	if (!(t->me = jgetstr(t->cap, UC "me")))
		goto oops;
	if ((t->mb = jgetstr(t->cap, UC "mb")))
		t->avattr |= BLINK;
	if ((t->md = jgetstr(t->cap, UC "md")))
		t->avattr |= BOLD;
	if ((t->mh = jgetstr(t->cap, UC "mh")))
		t->avattr |= DIM;
	if ((t->mr = jgetstr(t->cap, UC "mr")))
		t->avattr |= INVERSE;
 oops:

	if (assume_color && !t->Sf && t->md) {
		/*
		 * Install colour support if this looks like an ANSI
		 * terminal — that is, it’s got bold with ESC ‘[’…
		 */
		if (t->md[0] == '\\' && t->md[1] == 'E' && t->md[2] == '[') {
			t->ut = 1;
			t->Sf = UC "\\E[3%dm";
			t->Sb = UC "\\E[4%dm";
		} else if (t->md[0] == '\033' && t->md[1] == '[') {
			t->ut = 1;
			t->Sf = UC "\033[3%p1%dm";
			t->Sb = UC "\033[4%p1%dm";
		}
	}

	if (getnum(t->cap, UC "sg") <= 0 && !t->mr && jgetstr(t->cap, UC "se")) {
		if ((t->so = jgetstr(t->cap, UC "so")) != NULL)
			t->avattr |= INVERSE;
		t->se = jgetstr(t->cap, UC "se");
	}
	if (getflag(t->cap, UC "xs") || getflag(t->cap, UC "xt"))
		t->so = NULL;

	if (getnum(t->cap, UC "ug") <= 0 && jgetstr(t->cap, UC "ue")) {
		if ((t->us = jgetstr(t->cap, UC "us")) != NULL)
			t->avattr |= UNDERLINE;
		t->ue = jgetstr(t->cap, UC "ue");
	}

	if (!(t->uc = jgetstr(t->cap, UC "uc")))
		if (t->ul)
			t->uc = UC "_";
	if (t->uc)
		t->avattr |= UNDERLINE;

	t->ms = getflag(t->cap, UC "ms");

	t->da = getflag(t->cap, UC "da");
	t->db = getflag(t->cap, UC "db");
	t->cs = jgetstr(t->cap, UC "cs");
	t->rr = getflag(t->cap, UC "rr");
	t->sf = jgetstr(t->cap, UC "sf");
	t->sr = jgetstr(t->cap, UC "sr");
	t->SF = jgetstr(t->cap, UC "SF");
	t->SR = jgetstr(t->cap, UC "SR");
	t->al = jgetstr(t->cap, UC "al");
	t->dl = jgetstr(t->cap, UC "dl");
	t->AL = jgetstr(t->cap, UC "AL");
	t->DL = jgetstr(t->cap, UC "DL");
	if (!getflag(t->cap, UC "ns") && !t->sf)
		t->sf = UC "\12";

	if (!getflag(t->cap, UC "in") && baud < 38400) {
		t->dc = jgetstr(t->cap, UC "dc");
		t->DC = jgetstr(t->cap, UC "DC");
		t->dm = jgetstr(t->cap, UC "dm");
		t->ed = jgetstr(t->cap, UC "ed");

		t->im = jgetstr(t->cap, UC "im");
		t->ei = jgetstr(t->cap, UC "ei");
		t->ic = jgetstr(t->cap, UC "ic");
		t->IC = jgetstr(t->cap, UC "IC");
		t->ip = jgetstr(t->cap, UC "ip");
		t->mi = getflag(t->cap, UC "mi");
	}

	if (jgetstr(t->cap, UC "bc"))
		t->bs = jgetstr(t->cap, UC "bc");
	else if (jgetstr(t->cap, UC "le"))
		t->bs = jgetstr(t->cap, UC "le");
	if (getflag(t->cap, UC "bs"))
		t->bs = UC "\10";

	t->cbs = tcost(t->cap, t->bs, 1, 2, 2, 0, 0);

	t->lf = UC "\12";
	if (jgetstr(t->cap, UC "do"))
		t->lf = jgetstr(t->cap, UC "do");
	t->clf = tcost(t->cap, t->lf, 1, 2, 2, 0, 0);

	t->up = jgetstr(t->cap, UC "up");
	t->cup = tcost(t->cap, t->up, 1, 2, 2, 0, 0);

	t->nd = jgetstr(t->cap, UC "nd");

	t->tw = 8;
	if (getnum(t->cap, UC "it") > 0)
		t->tw = getnum(t->cap, UC "it");
	else if (getnum(t->cap, UC "tw") > 0)
		t->tw = getnum(t->cap, UC "tw");

	if (!(t->ta = jgetstr(t->cap, UC "ta")))
		if (getflag(t->cap, UC "pt"))
			t->ta = UC "\11";
	t->bt = jgetstr(t->cap, UC "bt");
	if (getflag(t->cap, UC "xt") || !usetabs) {
		t->ta = NULL;
		t->bt = NULL;
	}

	t->cta = tcost(t->cap, t->ta, 1, 2, 2, 0, 0);
	t->cbt = tcost(t->cap, t->bt, 1, 2, 2, 0, 0);

	t->ho = jgetstr(t->cap, UC "ho");
	t->cho = tcost(t->cap, t->ho, 1, 2, 2, 0, 0);
	t->ll = jgetstr(t->cap, UC "ll");
	t->cll = tcost(t->cap, t->ll, 1, 2, 2, 0, 0);

	t->cr = UC "\15";
	if (jgetstr(t->cap, UC "cr"))
		t->cr = jgetstr(t->cap, UC "cr");
	if (getflag(t->cap, UC "nc") || getflag(t->cap, UC "xr"))
		t->cr = NULL;
	t->ccr = tcost(t->cap, t->cr, 1, 2, 2, 0, 0);

	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap, UC "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap, UC "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap, UC "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap, UC "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap, UC "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap, UC "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap, UC "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap, UC "cm"), 1, 2, 2, 0, 0);

	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap, UC "ce"), 1, 2, 2, 0, 0);

	/* Make sure terminal can do absolute positioning */
	if (t->cm)
		goto ok;
	if (t->ch && t->cv)
		goto ok;
	if (t->ho && (t->lf || t->DO || t->cv))
		goto ok;
	if (t->ll && (t->up || t->UP || t->cv))
		goto ok;
	if (t->cr && t->cv)
		goto ok;
	leave = 1;
	ttclose();
	signrm(0);
	free(t);
	fprintf(stderr,"Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
	return NULL;
 ok:

	/* Determine if we can scroll */
	if (((t->sr || t->SR) && (t->sf || t->SF) && t->cs) || ((t->al || t->AL) && (t->dl || t->DL)))
		t->scroll = 1;
	else if (baud < 38400)
		mid = 1;

	/* Determine if we can ins/del within lines */
	if ((t->im || t->ic || t->IC) && (t->dc || t->DC))
		t->insdel = 1;

	/* Adjust for high baud rates */
	if (baud >= 38400) {
		t->scroll = 0;
		t->insdel = 0;
	}

	/* Send out terminal initialisation string */
	if (t->ti)
		texec(t->cap, t->ti, 1, 0, 0, 0, 0);
	if (!skiptop && t->cl)
		texec(t->cap, t->cl, 1, 0, 0, 0, 0);

	/* Initialise variable screen size-dependent vars */
	t->htab = ralloc(256, sizeof(struct s_hentry));

	nresize(t, t->co, t->li);

	return t;
}

/* Change size of screen */

void nresize(SCRN *t, int w, int h)
{
	if (h < 4)
		h = 4;
	if (w < 8)
		w = 8;
	t->li = h;
	t->co = w;
	if (notoktomul((size_t)t->li, (size_t)t->co)) {
		/* who has THAT large screens? */
		ttabrt(0, "screen too large");
		exit(255);
	}
	if (t->sary)
		free(t->sary);
	if (t->updtab)
		free(t->updtab);
	if (t->syntab)
		free(t->syntab);
	if (t->scrn)
		free(t->scrn);
	if (t->attr)
		free(t->attr);
	if (t->compose)
		free(t->compose);
	if (t->ofst)
		free(t->ofst);
	if (t->ary)
		free(t->ary);
	t->scrn = ralloc((size_t)t->li * (size_t)t->co, sizeof(int));
	t->attr = ralloc((size_t)t->li * (size_t)t->co, sizeof(int));
	t->sary = calloc(t->li, sizeof(int));
	t->updtab = ralloc((size_t)t->li, sizeof(int));
	t->syntab = ralloc((size_t)t->li, sizeof(int));
	t->compose = ralloc((size_t)t->co, sizeof(int));
	t->ofst = ralloc((size_t)t->co, sizeof(int));
	t->ary = ralloc((size_t)t->co, sizeof(struct s_hentry));

	if (!t->htab || !t->scrn || !t->attr || !t->sary || !t->updtab ||
	    !t->syntab || !t->compose || !t->ofst || !t->ary) {
		ttabrt(0, "screen allocation failed");
		exit(255);
	}

	nredraw(t);
}

/*
 * Calculate cost of positioning the cursor using only relative cursor
 * positioning functions: t->(lf, DO, up, UP, bs, LE, RI, ta, bt) and
 * rewriting characters (to move right)
 *
 * This doesn't use the am and bw capabilities although it probably could.
 */

static int relcost(register SCRN *t, register int x, register int y, register int ox, register int oy)
{
	int cost = 0;

	/* If we don't know the cursor position, force use of absolute positioning */
	if (oy == -1 || ox == -1)
		return 10000;

	/* First adjust row */
	if (y > oy) {
		int dist = y - oy;

		/* Have to go down */
		if (t->lf) {
			int mult = dist * t->clf;

			if (dist < 10 && t->cDO < mult)
				cost += t->cDO;
			else if (dist >= 10 && t->cDO + 1 < mult)
				cost += t->cDO + 1;
			else
				cost += mult;
		} else if (t->DO)
			if (dist < 10)
				cost += t->cDO;
			else
				cost += t->cDO + 1;
		else
			return 10000;
	} else if (y < oy) {
		int dist = oy - y;

		/* Have to go up */
		if (t->up) {
			int mult = dist * t->cup;

			if (dist < 10 && t->cUP < mult)
				cost += t->cUP;
			else if (dist >= 10 && t->cUP < mult)
				cost += t->cUP + 1;
			else
				cost += mult;
		} else if (t->UP)
			if (dist < 10)
				cost += t->cUP;
			else
				cost += t->cUP + 1;
		else
			return 10000;
	}

	/* Now adjust column */

	/* Use tabs */
	if (x > ox && t->ta) {
		int dist = x - ox;
		int ntabs = (dist + ox % t->tw) / t->tw;
		int cstunder = x % t->tw + t->cta * ntabs;
		int cstover;

		if (x + t->tw < t->co && t->bs)
			cstover = t->cbs * (t->tw - x % t->tw) + t->cta * (ntabs + 1);
		else
			cstover = 10000;
		if (dist < 10 && cstunder < t->cRI && cstunder < x - ox && cstover > cstunder)
			return cost + cstunder;
		else if (cstunder < t->cRI + 1 && cstunder < x - ox && cstover > cstunder)
			return cost + cstunder;
		else if (dist < 10 && cstover < t->cRI && cstover < x - ox)
			return cost + cstover;
		else if (cstover < t->cRI + 1 && cstover < x - ox)
			return cost + cstover;
	} else if (x < ox && t->bt) {
		int dist = ox - x;
		int ntabs = (dist + t->tw - ox % t->tw) / t->tw;
		int cstunder, cstover;

		if (t->bs)
			cstunder = t->cbt * ntabs + t->cbs * (t->tw - x % t->tw);
		else
			cstunder = 10000;
		if (x - t->tw >= 0)
			cstover = t->cbt * (ntabs + 1) + x % t->tw;
		else
			cstover = 10000;
		if (dist < 10 && cstunder < t->cLE && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		    && cstover > cstunder)
			return cost + cstunder;
		if (cstunder < t->cLE + 1 && (t->bs ? cstunder < (ox - x) * t->cbs : 1)
		    && cstover > cstunder)
			return cost + cstunder;
		else if (dist < 10 && cstover < t->cRI && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			return cost + cstover;
		else if (cstover < t->cRI + 1 && (t->bs ? cstover < (ox - x) * t->cbs : 1))
			return cost + cstover;
	}

	/* Use simple motions */
	if (x < ox) {
		int dist = ox - x;

		/* Have to go left */
		if (t->bs) {
			int mult = dist * t->cbs;

			if (t->cLE < mult && dist < 10)
				cost += t->cLE;
			else if (t->cLE + 1 < mult)
				cost += t->cLE + 1;
			else
				cost += mult;
		} else if (t->LE)
			cost += t->cLE;
		else
			return 10000;
	} else if (x > ox) {
		int dist = x - ox;

		/* Have to go right */
		/* Hmm.. this should take into account possible attribute changes */
		if (t->cRI < dist && dist < 10)
			cost += t->cRI;
		else if (t->cRI + 1 < dist)
			cost += t->cRI + 1;
		else
			cost += dist;
	}

	return cost;
}

/* Find optimal set of cursor positioning commands to move from the current
 * cursor row and column (either or both of which might be unknown) to the
 * given new row and column and execute them.
 */

static void cposs(register SCRN *t, register int x, register int y)
{
	register int bestcost, cost;
	int bestway;
	int hy;
	int hl;

	/*
	 * Home y position is usually 0, but it is 'top' if we have
	 * scrolling region relative addressing
	 */
	if (t->rr) {
		hy = t->top;
		hl = t->bot - 1;
	} else {
		hy = 0;
		hl = t->li - 1;
	}

	/* Assume best way is with only using relative cursor positioning */

	bestcost = relcost(t, x, y, t->x, t->y);
	bestway = 0;

	/*
	 * Now check if combinations of absolute cursor positioning
	 * functions are better (or necessary in case one or both cursor
	 * positions are unknown)
	 */

	if (t->ccm < bestcost) {
		cost = tcost(t->cap, t->cm, 1, y, x, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 6;
		}
	}
	if (t->ccr < bestcost) {
		cost = relcost(t, x, y, 0, t->y) + t->ccr;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 1;
		}
	}
	if (t->cho < bestcost) {
		cost = relcost(t, x, y, 0, hy) + t->cho;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 2;
		}
	}
	if (t->cll < bestcost) {
		cost = relcost(t, x, y, 0, hl) + t->cll;
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 3;
		}
	}
	if (t->cch < bestcost && x != t->x) {
		cost = relcost(t, x, y, x, t->y) + tcost(t->cap, t->ch, 1, x, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 4;
		}
	}
	if (t->ccv < bestcost && y != t->y) {
		cost = relcost(t, x, y, t->x, y) + tcost(t->cap, t->cv, 1, y, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 5;
		}
	}
	if (t->ccV < bestcost) {
		cost = relcost(t, x, y, 0, y) + tcost(t->cap, t->cV, 1, y, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 13;
		}
	}
	if (t->cch + t->ccv < bestcost && x != t->x && y != t->y) {
		cost = tcost(t->cap, t->cv, 1, y - hy, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 7;
		}
	}
	if (t->ccv + t->ccr < bestcost && y != t->y) {
		cost = tcost(t->cap, t->cv, 1, y, 0, 0, 0) + tcost(t->cap, t->cr, 1, 0, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 8;
		}
	}
	if (t->cll + t->cch < bestcost) {
		cost = tcost(t->cap, t->ll, 1, 0, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0) + relcost(t, x, y, x, hl);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 9;
		}
	}
	if (t->cll + t->ccv < bestcost) {
		cost = tcost(t->cap, t->ll, 1, 0, 0, 0, 0) + tcost(t->cap, t->cv, 1, y, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 10;
		}
	}
	if (t->cho + t->cch < bestcost) {
		cost = tcost(t->cap, t->ho, 1, 0, 0, 0, 0) + tcost(t->cap, t->ch, 1, x, 0, 0, 0) + relcost(t, x, y, x, hy);
		if (cost < bestcost) {
			bestcost = cost;
			bestway = 11;
		}
	}
	if (t->cho + t->ccv < bestcost) {
		cost = tcost(t->cap, t->ho, 1, 0, 0, 0, 0) + tcost(t->cap, t->cv, 1, y, 0, 0, 0) + relcost(t, x, y, 0, y);
		if (cost < bestcost) {
			/* dead store: bestcost = cost; */
			bestway = 12;
		}
	}

	/*
	 * Do absolute cursor positioning if we don't know the cursor
	 * position or if it is faster than doing only relative cursor
	 * positioning
	 */

	switch (bestway) {
	case 1:
		texec(t->cap, t->cr, 1, 0, 0, 0, 0);
		t->x = 0;
		break;
	case 2:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
		break;
	case 3:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		break;
	case 9:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		goto doch;
	case 11:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
		/* FALLTHROUGH */
 doch:
		/* FALLTHROUGH */
	case 4:
		texec(t->cap, t->ch, 1, x, 0, 0, 0);
		t->x = x;
		break;
	case 10:
		texec(t->cap, t->ll, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hl;
		goto docv;
	case 12:
		texec(t->cap, t->ho, 1, 0, 0, 0, 0);
		t->x = 0;
		t->y = hy;
		goto docv;
	case 8:
		texec(t->cap, t->cr, 1, 0, 0, 0, 0);
		t->x = 0;
		/* FALLTHROUGH */
 docv:
		/* FALLTHROUGH */
	case 5:
		texec(t->cap, t->cv, 1, y, 0, 0, 0);
		t->y = y;
		break;
	case 6:
		texec(t->cap, t->cm, 1, y, x, 0, 0);
		t->y = y;
		t->x = x;
		break;
	case 7:
		texec(t->cap, t->cv, 1, y, 0, 0, 0);
		t->y = y;
		texec(t->cap, t->ch, 1, x, 0, 0, 0);
		t->x = x;
		break;
	case 13:
		texec(t->cap, t->cV, 1, y, 0, 0, 0);
		t->y = y;
		t->x = 0;
		break;
	}

	/* Use relative cursor position functions if we're not there yet */

	/* First adjust row */
	if (y > t->y) {
		/* Have to go down */
		if (!t->lf || t->cDO < (y - t->y) * t->clf) {
			texec(t->cap, t->DO, 1, y - t->y, 0, 0, 0);
			t->y = y;
		} else
			while (y > t->y) {
				texec(t->cap, t->lf, 1, 0, 0, 0, 0);
				++t->y;
			}
	} else if (y < t->y) {
		/* Have to go up */
		if (!t->up || t->cUP < (t->y - y) * t->cup) {
			texec(t->cap, t->UP, 1, t->y - y, 0, 0, 0);
			t->y = y;
		} else
			while (y < t->y) {
				texec(t->cap, t->up, 1, 0, 0, 0, 0);
				--t->y;
			}
	}

	/* Use tabs */
	if (x > t->x && t->ta) {
		int ntabs = (x - t->x + t->x % t->tw) / t->tw;
		int cstunder = x % t->tw + t->cta * ntabs;
		int cstover;

		if (x + t->tw < t->co && t->bs)
			cstover = t->cbs * (t->tw - x % t->tw) + t->cta * (ntabs + 1);
		else
			cstover = 10000;
		if (cstunder < t->cRI && cstunder < x - t->x && cstover > cstunder) {
			if (ntabs) {
				t->x = x - x % t->tw;
				do {
					texec(t->cap, t->ta, 1, 0, 0, 0, 0);
				} while (--ntabs);
			}
		} else if (cstover < t->cRI && cstover < x - t->x) {
			t->x = t->tw + x - x % t->tw;
			++ntabs;
			do {
				texec(t->cap, t->ta, 1, 0, 0, 0, 0);
			} while (--ntabs);
		}
	} else if (x < t->x && t->bt) {
		int ntabs = ((t->x + t->tw - 1) - (t->x + t->tw - 1) % t->tw - ((x + t->tw - 1) - (x + t->tw - 1) % t->tw)) / t->tw;
		int cstunder, cstover;

		if (t->bs)
			cstunder = t->cbt * ntabs + t->cbs * (t->tw - x % t->tw);
		else
			cstunder = 10000;
		if (x - t->tw >= 0)
			cstover = t->cbt * (ntabs + 1) + x % t->tw;
		else
			cstover = 10000;
		if (cstunder < t->cLE && (t->bs ? cstunder < (t->x - x) * t->cbs : 1)
		    && cstover > cstunder) {
			if (ntabs) {
				do {
					texec(t->cap, t->bt, 1, 0, 0, 0, 0);
				} while (--ntabs);
				t->x = x + t->tw - x % t->tw;
			}
		} else if (cstover < t->cRI && (t->bs ? cstover < (t->x - x) * t->cbs : 1)) {
			t->x = x - x % t->tw;
			++ntabs;
			do {
				texec(t->cap, t->bt, 1, 0, 0, 0, 0);
			} while (--ntabs);
		}
	}

	/* Now adjust column */
	if (x < t->x) {
		/* Have to go left */
		if (!t->bs || t->cLE < (t->x - x) * t->cbs) {
			texec(t->cap, t->LE, 1, t->x - x, 0, 0, 0);
			t->x = x;
		} else
			while (x < t->x) {
				texec(t->cap, t->bs, 1, 0, 0, 0, 0);
				--t->x;
			}
	} else if (x > t->x) {
		/* Have to go right */
		/* Hmm.. this should take into account possible attribute changes */
		if (x-t->x>1 && t->RI) {
			texec(t->cap, t->RI, 1, x - t->x, 0, 0, 0);
			t->x = x;
		} else {
			while(x>t->x) {
				texec(t->cap, t->nd, 1, 0, 0, 0, 0);
				++t->x;
			}
		}
	}
}

int cpos(register SCRN *t, register int x, register int y)
{
	/* Move cursor quickly if we can */
	if (y == t->y) {
		if (x > t->x && x - t->x < 4 && !t->ins) {
			int *cs = t->scrn + t->x + t->co * t->y;
			int *as = t->attr + t->x + t->co * t->y;
			do {
				/* We used to space over unknown chars, but they now could be
				   the right half of a UTF-8 two column character, so we can't.
				   Also do not try to emit utf-8 sequences here. */
				if(*cs<32 || *cs>=127)
					break;

				/* has a combining character attached? */
				if (*as & HAS_COMBINING)
					break;

				if (*as != t->attrib)
					set_attr(t, *as);

				ttputc(*cs);

				++cs;
				++as;
				++t->x;

			} while (x != t->x);
		}
		if (x == t->x)
			return 0;
	}
	if ((!t->ms && t->attrib & (INVERSE | UNDERLINE | BG_NOT_DEFAULT)) ||
	    (t->ut && (t->attrib & BG_NOT_DEFAULT)))
		set_attr(t, t->attrib & ~(INVERSE | UNDERLINE | BG_MASK));

	/* Should be in cposs */
	if (y < t->top || y >= t->bot)
		setregn(t, 0, t->li);

	cposs(t, x, y);
	return 0;
}

static void doinschr(SCRN *t, int x, int y, int *s, int *as, int n)
{
	int a;

	if (x < 0) {
		s -= x;
		as -= x;
		x = 0;
	}
	if (x >= t->co - 1 || n <= 0)
		return;
	if (t->im || t->ic || t->IC) {
		cpos(t, x, y);
		if ((n == 1 && t->ic) || !t->IC) {
			if (!t->ic)
				setins(t, x);
			for (a = 0; a != n; ++a) {
				texec(t->cap, t->ic, 1, x, 0, 0, 0);
				texec(t->cap, t->ip, 1, x, 0, 0, 0);
			}
			if (!t->mi)
				clrins(t);
		} else {
			texec(t->cap, t->IC, 1, n, 0, 0, 0);
		}
	}
	mmove(t->scrn + x + t->co * y + n, t->scrn + x + t->co * y, (t->co - (x + n)) * sizeof(int));
	mmove(t->attr + x + t->co * y + n, t->attr + x + t->co * y, (t->co - (x + n)) * sizeof(int));
	mmove(t->scrn + x + t->co * y, s, n * sizeof(int));
	mmove(t->attr + x + t->co * y, s, n * sizeof(int));
}

static void dodelchr(SCRN *t, int x, int y, int n)
{
	int a;

	if (x < 0)
		x = 0;
	if (!n || x >= t->co - 1)
		return;
	if (t->dc || t->DC) {
		cpos(t, x, y);
		texec(t->cap, t->dm, 1, x, 0, 0, 0);	/* Enter delete mode */
		if ((n == 1 && t->dc) || !t->DC)
			for (a = n; a; --a)
				texec(t->cap, t->dc, 1, x, 0, 0, 0);
		else
			texec(t->cap, t->DC, 1, n, 0, 0, 0);
		texec(t->cap, t->ed, 1, x, 0, 0, 0);	/* Exit delete mode */
	}
	mmove(t->scrn + t->co * y + x, t->scrn + t->co * y + x + n, (t->co - (x + n)) * sizeof(int));
	mmove(t->attr + t->co * y + x, t->attr + t->co * y + x + n, (t->co - (x + n)) * sizeof(int));
	msetI(t->scrn + t->co * y + t->co - n, ' ', n);
	msetI(t->attr + t->co * y + t->co - n, 0, n);
}

/* Insert/Delete within line */
/* FIXME: doesn't know about attr */

void magic(SCRN *t, int y, int *cs, int *ca,int *s, int *a, int placex)
{
	struct s_hentry *htab = t->htab;
	int *ofst = t->ofst;
	int aryx = 1;
	int x;

	if (!(t->im || t->ic || t->IC) || !(t->dc || t->DC))
		return;
	mset(htab, 0, 256 * sizeof(struct s_hentry));

	msetI(ofst, 0, t->co);

	/* Build hash table */
	for (x = 0; x != t->co - 1; ++x) {
		t->ary[aryx].next = htab[cs[x] & 255].next;
		t->ary[aryx].loc = x;
		++htab[cs[x] & 255].loc;
		htab[cs[x] & 255].next = aryx++;
	}

	/* Build offset table */
	for (x = 0; x < t->co - 1;)
		if (htab[s[x] & 255].loc >= 15)
			ofst[x++] = t->co - 1;
		else {
			int aryy;
			int maxaryy = 0;
			int maxlen = 0;
			int best = 0;
			int bestback = 0;
			int z;

			for (aryy = htab[s[x] & 255].next; aryy; aryy = t->ary[aryy].next) {
				int amnt, back;
				int tsfo = t->ary[aryy].loc - x;
				int cst = -abs(tsfo);
				int pre = 32;

				for (amnt = 0; x + amnt < t->co - 1 && x + tsfo + amnt < t->co - 1; ++amnt) {
					if (cs[x + tsfo + amnt] != s[x + amnt])
						break;
					else if ((s[x + amnt] & 255) != 32 || pre != 32)
						++cst;
					pre = s[x + amnt] & 255;
				}
				pre = 32;
				for (back = 0; back + x > 0 && back + tsfo + x > 0; --back) {
					if (cs[x + tsfo + back - 1] != s[x + back - 1])
						break;
					else if ((s[x + back - 1] & 255) != 32 || pre != 32)
						++cst;
					pre = s[x + back - 1] & 255;
				}
				if (cst > best) {
					maxaryy = aryy;
					maxlen = amnt;
					best = cst;
					bestback = back;
				}
			}
			if (!maxlen) {
				ofst[x] = t->co - 1;
				maxlen = 1;
			} else if (best < 2)
				for (z = 0; z != maxlen; ++z)
					ofst[x + z] = t->co - 1;
			else
				for (z = 0; z != maxlen - bestback; ++z)
					ofst[x + z + bestback] = t->ary[maxaryy].loc - x;
			x += maxlen;
		}

	/* Apply scrolling commands */

	for (x = 0; x != t->co - 1; ++x) {
		int q = ofst[x];

		if (q && q != t->co - 1) {
			if (q > 0) {
				int z, fu;

				for (z = x; z != t->co - 1 && ofst[z] == q; ++z)
					;
				while (s[x] == cs[x] && x < placex)
					++x;
				dodelchr(t, x, y, q);
				for (fu = x; fu != t->co - 1; ++fu)
					if (ofst[fu] != t->co - 1)
						ofst[fu] -= q;
				x = z - 1;
			} else {
				int z, fu;

				for (z = x; z != t->co - 1 && ofst[z] == q; ++z)
					;
				while (s[x + q] == cs[x + q] && x - q < placex)
					++x;
				doinschr(t, x + q, y, s + x + q, a + x + q, -q);
				for (fu = x; fu != t->co - 1; ++fu)
					if (ofst[fu] != t->co - 1)
						ofst[fu] -= q;
				x = z - 1;
			}
		}
	}
}

static void doupscrl(SCRN *t, int top, int bot, int amnt)
{
	int a = amnt;

	if (!amnt)
		return;
	set_attr(t, 0);
	if (top == 0 && bot == t->li && (t->sf || t->SF)) {
		setregn(t, 0, t->li);
		cpos(t, 0, t->li - 1);
		if ((amnt == 1 && t->sf) || !t->SF)
			while (a--)
				texec(t->cap, t->sf, 1, t->li - 1, 0, 0, 0);
		else
			texec(t->cap, t->SF, a, a, 0, 0, 0);
		goto done;
	}
	if (bot == t->li && (t->dl || t->DL)) {
		setregn(t, 0, t->li);
		cpos(t, 0, top);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		goto done;
	}
	if (t->cs && (t->sf || t->SF)) {
		setregn(t, top, bot);
		cpos(t, 0, bot - 1);
		if ((amnt == 1 && t->sf) || !t->SF)
			while (a--)
				texec(t->cap, t->sf, 1, bot - 1, 0, 0, 0);
		else
			texec(t->cap, t->SF, a, a, 0, 0, 0);
		goto done;
	}
	if ((t->dl || t->DL) && (t->al || t->AL)) {
		cpos(t, 0, top);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		a = amnt;
		cpos(t, 0, bot - amnt);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, bot - amnt, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	msetI(t->updtab + top, 1, bot - top);
	msetI(t->syntab + top, -1, bot - top);
	return;

 done:
	mmove(t->scrn + top * t->co, t->scrn + (top + amnt) * t->co, (bot - top - amnt) * t->co * sizeof(int));
	mmove(t->attr + top * t->co, t->attr + (top + amnt) * t->co, (bot - top - amnt) * t->co * sizeof(int));

	if (bot == t->li && t->db) {
		msetI(t->scrn + (t->li - amnt) * t->co, -1, amnt * t->co);
		msetI(t->attr + (t->li - amnt) * t->co, 0, amnt * t->co);
		msetI(t->updtab + t->li - amnt, 1, amnt);
		msetI(t->syntab + t->li - amnt, -1, amnt);
	} else {
		msetI(t->scrn + (bot - amnt) * t->co, ' ', amnt * t->co);
		msetI(t->attr + (bot - amnt) * t->co, 0, amnt * t->co);
	}
}

static void dodnscrl(SCRN *t, int top, int bot, int amnt)
{
	int a = amnt;

	if (!amnt)
		return;
	set_attr(t, 0);
	if (top == 0 && bot == t->li && (t->sr || t->SR)) {
		setregn(t, 0, t->li);
		cpos(t, 0, 0);
		if ((amnt == 1 && t->sr) || !t->SR)
			while (a--)
				texec(t->cap, t->sr, 1, 0, 0, 0, 0);
		else
			texec(t->cap, t->SR, a, a, 0, 0, 0);
		goto done;
	}
	if (bot == t->li && (t->al || t->AL)) {
		setregn(t, 0, t->li);
		cpos(t, 0, top);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	if (t->cs && (t->sr || t->SR)) {
		setregn(t, top, bot);
		cpos(t, 0, top);
		if ((amnt == 1 && t->sr) || !t->SR)
			while (a--)
				texec(t->cap, t->sr, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->SR, a, a, 0, 0, 0);
		goto done;
	}
	if ((t->dl || t->DL) && (t->al || t->AL)) {
		cpos(t, 0, bot - amnt);
		if ((amnt == 1 && t->dl) || !t->DL)
			while (a--)
				texec(t->cap, t->dl, 1, bot - amnt, 0, 0, 0);
		else
			texec(t->cap, t->DL, a, a, 0, 0, 0);
		a = amnt;
		cpos(t, 0, top);
		if ((amnt == 1 && t->al) || !t->AL)
			while (a--)
				texec(t->cap, t->al, 1, top, 0, 0, 0);
		else
			texec(t->cap, t->AL, a, a, 0, 0, 0);
		goto done;
	}
	msetI(t->updtab + top, 1, bot - top);
	msetI(t->syntab + top, -1, bot - top);
	return;
 done:
	mmove(t->scrn + (top + amnt) * t->co, t->scrn + top * t->co, (bot - top - amnt) * t->co * sizeof(int));
	mmove(t->attr + (top + amnt) * t->co, t->attr + top * t->co, (bot - top - amnt) * t->co * sizeof(int));

	if (!top && t->da) {
		msetI(t->scrn, -1, amnt * t->co);
		msetI(t->attr, 0, amnt * t->co);
		msetI(t->updtab, 1, amnt);
		msetI(t->syntab, -1, amnt);
	} else {
		msetI(t->scrn + t->co * top, ' ', amnt * t->co);
		msetI(t->attr + t->co * top, 0, amnt * t->co);
	}
}

void nscroll(SCRN *t)
{
	int y, z, q, r, p;

	for (y = 0; y != t->li; ++y) {
		q = t->sary[y];
		if (have)
			return;
		if (q && q != t->li) {
			if (q > 0) {
				for (z = y; z != t->li && t->sary[z] == q; ++z)
					t->sary[z] = 0;
				doupscrl(t, y, z + q, q);
				y = z - 1;
			} else {
				for (r = y; r != t->li && (t->sary[r] < 0 || t->sary[r] == t->li); ++r)
					;
				p = r - 1;
				do {
					q = t->sary[p];
					if (q && q != t->li) {
						for (z = p; t->sary[z] = 0, (z && t->sary[z - 1] == q); --z)
							;
						dodnscrl(t, z + q, p + 1, -q);
						p = z + 1;
					}
				} while (p-- != y);
				y = r - 1;
			}
		}
	}
	msetI(t->sary, 0, t->li);
}

void npartial(SCRN *t)
{
	set_attr(t, 0);
	clrins(t);
	setregn(t, 0, t->li);
}

void nescape(SCRN *t)
{
	npartial(t);
	cpos(t, 0, t->li - 1);
	eraeol(t, 0, t->li - 1);
	if (t->te)
		texec(t->cap, t->te, 1, 0, 0, 0, 0);
}

void nreturn(SCRN *t)
{
	if (t->ti)
		texec(t->cap, t->ti, 1, 0, 0, 0, 0);
	if (!skiptop && t->cl)
		texec(t->cap, t->cl, 1, 0, 0, 0, 0);
	nredraw(t);
}

void nclose(SCRN *t)
{
	leave = 1;
	set_attr(t, 0);
	clrins(t);
	setregn(t, 0, t->li);
	cpos(t, 0, t->li - 1);
	if (t->te)
		texec(t->cap, t->te, 1, 0, 0, 0, 0);
	ttclose();
	rmcap(t->cap);
	free(t->scrn);
	free(t->attr);
	free(t->sary);
	free(t->ofst);
	free(t->htab);
	free(t->ary);
	free(t);
}

void nscrldn(SCRN *t, int top, int bot, int amnt)
{
	int x;

	if (!amnt || top >= bot || bot > t->li)
		return;
	if ((amnt < bot - top && bot - top - amnt < amnt / 2) || !t->scroll)
		amnt = bot - top;
	if (amnt < bot - top) {
		for (x = bot; x != top + amnt; --x) {
			t->sary[x - 1] = (t->sary[x - amnt - 1] == t->li ? t->li : t->sary[x - amnt - 1] - amnt);
			t->updtab[x - 1] = t->updtab[x - amnt - 1];
			t->syntab[x - 1] = t->syntab[x - amnt - 1];
		}
		for (x = top; x != top + amnt; ++x) {
			t->updtab[x] = 1;
			t->syntab[x] = -1;
		}
	}
	if (amnt > bot - top)
		amnt = bot - top;
	msetI(t->sary + top, t->li, amnt);
	if (amnt == bot - top) {
		msetI(t->updtab + top, 1, amnt);
		msetI(t->syntab + top, -1, amnt);
	}
}

void nscrlup(SCRN *t, int top, int bot, int amnt)
{
	int x;

	if (!amnt || top >= bot || bot > t->li)
		return;
	if ((amnt < bot - top && bot - top - amnt < amnt / 2) || !t->scroll)
		amnt = bot - top;
	if (amnt < bot - top) {
		for (x = top + amnt; x != bot; ++x) {
			t->sary[x - amnt] = (t->sary[x] == t->li ? t->li : t->sary[x] + amnt);
			t->updtab[x - amnt] = t->updtab[x];
			t->syntab[x - amnt] = t->syntab[x];
		}
		for (x = bot - amnt; x != bot; ++x) {
			t->updtab[x] = 1;
			t->syntab[x] = -1;
		}
	}
	if (amnt > bot - top)
		amnt = bot - top;
	msetI(t->sary + bot - amnt, t->li, amnt);
	if (amnt == bot - top) {
		msetI(t->updtab + bot - amnt, 1, amnt);
		msetI(t->syntab + bot - amnt, -1, amnt);
	}
}

extern volatile int dostaupd;

void nredraw(SCRN *t)
{
	dostaupd = 1;
	msetI(t->scrn, ' ', t->co * skiptop);
	msetI(t->attr, 0, t->co * skiptop);
	msetI(t->scrn + skiptop * t->co, -1, (t->li - skiptop) * t->co);
	msetI(t->attr + skiptop * t->co, 0, (t->li - skiptop) * t->co);
	msetI(t->sary, 0, t->li);
	msetI(t->updtab + skiptop, -1, t->li - skiptop);
	msetI(t->syntab + skiptop, -1, t->li - skiptop);
	t->x = -1;
	t->y = -1;
	t->top = t->li;
	t->bot = 0;
	t->attrib = -1;
	t->ins = -1;
	set_attr(t, 0);
	clrins(t);
	setregn(t, 0, t->li);

	if (!skiptop) {
		if (t->cl) {
			texec(t->cap, t->cl, 1, 0, 0, 0, 0);
			t->x = 0;
			t->y = 0;
			msetI(t->scrn, ' ', t->li * t->co);
			msetI(t->attr, 0, t->li * t->co);
		} else if (t->cd) {
			cpos(t, 0, 0);
			texec(t->cap, t->cd, 1, 0, 0, 0, 0);
			msetI(t->scrn, ' ', t->li * t->co);
			msetI(t->attr, 0, t->li * t->co);
		}
	}
}

/* Convert color/attribute name into internal code */

int meta_color(unsigned char *s)
{
	if(!strcmp((char *)s,"inverse"))
		return INVERSE;
	else if(!strcmp((char *)s,"underline"))
		return UNDERLINE;
	else if(!strcmp((char *)s,"bold"))
		return BOLD;
	else if(!strcmp((char *)s,"blink"))
		return BLINK;
	else if(!strcmp((char *)s,"dim"))
		return DIM;
	else if(!strcmp((char *)s,"white"))
		return FG_WHITE;
	else if(!strcmp((char *)s,"cyan"))
		return FG_CYAN;
	else if(!strcmp((char *)s,"magenta"))
		return FG_MAGENTA;
	else if(!strcmp((char *)s,"blue"))
		return FG_BLUE;
	else if(!strcmp((char *)s,"yellow"))
		return FG_YELLOW;
	else if(!strcmp((char *)s,"green"))
		return FG_GREEN;
	else if(!strcmp((char *)s,"red"))
		return FG_RED;
	else if(!strcmp((char *)s,"black"))
		return FG_BLACK;
	else if(!strcmp((char *)s,"bg_white"))
		return BG_WHITE;
	else if(!strcmp((char *)s,"bg_cyan"))
		return BG_CYAN;
	else if(!strcmp((char *)s,"bg_magenta"))
		return BG_MAGENTA;
	else if(!strcmp((char *)s,"bg_blue"))
		return BG_BLUE;
	else if(!strcmp((char *)s,"bg_yellow"))
		return BG_YELLOW;
	else if(!strcmp((char *)s,"bg_green"))
		return BG_GREEN;
	else if(!strcmp((char *)s,"bg_red"))
		return BG_RED;
	else if(!strcmp((char *)s,"bg_black"))
		return BG_BLACK;
	else
		return 0;
}

/* Generate a field
 *
 * 't' is SCRN to write to.
 * 'scrn' is address of field in character buffer
 * 'attr' is address of field in attribute buffer
 * 'x', 'y' are starting column and line numbers of field
 * 'ofst' is first column within string to display
 * 's', 'len' is string to generate in field
 * 'atr' is screeen attributes (and color) which should be used
 * 'width' is column width of field
 * 'flg' if set, erases to end of line
 */

void genfield(SCRN *t,int *scrn,int *attr,int x,int y,int ofst,unsigned char *s,int len,int atr,int width,int flg,int *fmt)
{
	int col;
	struct utf8_sm sm;
	int last_col = x + width;

	utf8_init(&sm);

	for (col = 0;len != 0 && x < last_col; len--) {
		int c = *s++;
		int wid = -1;
		int my_atr = atr;
		if (fmt) my_atr |= *fmt++;
		if (locale_map->type) {
			/* UTF-8 mode: decode character and determine its width */
			c = utf8_decode(&sm,c);
			if (c >= 0)
				wid = joe_wcwidth(c);
		} else {
			/* Byte mode: character is one column wide */
			wid = 1;
		}
		if (wid >= 0) {
			if (col >= ofst) {
				if (x + wid > last_col) {
					/* Character crosses end of field, so fill balance of field with '>' characters instead */
					while (x < last_col) {
						outatr(utf8_map, t, scrn, attr, x, y, '>', my_atr);
						++scrn;
						++attr;
						++x;
					}
				} else /* if (wid >(=) 0) */ {
					/* Emit character */
					outatr(locale_map, t, scrn, attr, x, y, c, my_atr);
					x += wid;
					scrn += wid;
					attr += wid;
				}
			} else if ((col + wid) > ofst) {
				/* Wide character crosses left side of field */
				wid -= ofst - col;
				col = ofst;
				while (wid) {
					outatr(utf8_map, t, scrn, attr, x, y, '<', my_atr);
					++scrn;
					++attr;
					++x;
					++col;
					--wid;
				}
			} else
				col += wid;
		}
	}
	/* Fill balance of field with spaces */
	while (x < last_col) {
		outatr(utf8_map, t, scrn, attr, x, y, ' ', 0);
		++x;
		++scrn;
		++attr;
	}
	/* Erase to end of line */
	if (flg)
		eraeol(t, x, y);
}

/* Width function for above */

int txtwidth(unsigned char *s,int len)
{
	if (locale_map->type) {
		int col=0;
		struct utf8_sm sm;
		utf8_init(&sm);

		while(len--) {
			int d = utf8_decode(&sm,*s++);
			if (d >= 0)
				col += joe_wcwidth(d);
		}

		return col;
	} else
		return len;
}

/* Generate text with formatting escape sequences */

void genfmt(SCRN *t, int x, int y, int ofst, const unsigned char *s, int flg)
{
	int *scrn = t->scrn + y * t->co + x;
	int *attr = t->attr + y * t->co + x;
	int atr = 0;
	int col = 0;
	int c;
	struct utf8_sm sm;

	utf8_init(&sm);

	while ((c = *s++) != '\0')
		if (c == '\\') {
			switch ((c = *s++) | 0x20) {
			case 'u':
				atr ^= UNDERLINE;
				break;
			case 'i':
				atr ^= INVERSE;
				break;
			case 'b':
				atr ^= BOLD;
				break;
			case 'd':
				atr ^= DIM;
				break;
			case 'f':
				atr ^= BLINK;
				break;
			default: {
				if (!c)
					--s;
				else if (col++ >= ofst) {
					outatr(locale_map, t, scrn, attr, x, y, (c&0x7F), atr);
					++scrn;
					++attr;
					++x;
					}
				break;
				}
			}
		} else {
			int wid = -1;
			if (locale_map->type) {
				/* UTF-8 mode: decode character and determine its width */
				c = utf8_decode(&sm,c);
				if (c >= 0) {
					wid = joe_wcwidth(c);
				}
			} else {
				/* Byte mode: character is one column wide */
				wid = 1;
			}

			if (wid >= 0) {
				if (col >= ofst) {
					outatr(locale_map, t, scrn, attr, x, y, c, atr);
					scrn += wid;
					attr += wid;
					x += wid;
					col += wid;
				} else if (col+wid>ofst) {
					while (col<ofst) {
						++col;
						--wid;
					}
					while (wid) {
						outatr(utf8_map, t, scrn, attr, x, y, '<', atr);
						++scrn;
						++attr;
						++x;
						++col;
						--wid;
					}
				} else
					col += wid;
		}
		}
	if (flg)
		eraeol(t, x, y);
}

/* Determine column width of string with format codes */

int fmtlen(const unsigned char *s)
{
	int col = 0;
	struct utf8_sm sm;
	int c;

	utf8_init(&sm);

	while ((c = (*s++))) {
		if (c == '\\') {
			switch (*s++) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				continue;
			case 0:
				return col;
			default:
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(locale_map->type) {
				c = utf8_decode(&sm,c);
				if (c>=0)
					wid = joe_wcwidth(c);
			} else {
				wid = 1;
			}
			col += wid;
		}
	}
	return col;
}

/* Return offset within format string which corresponds to a particular
   column */

/* FIXME: this is not valid if we land in the middle of a double-wide character */

int fmtpos(unsigned char *s, int goal)
{
	unsigned char *org = s;
	int col = 0;
	int c;
	struct utf8_sm sm;

	utf8_init(&sm);

	while ((c= *s) && col<goal) {
		s++;
		if (c == '\\') {
			switch (*s++) {
			case 'u':
			case 'i':
			case 'd':
			case 'f':
			case 'b':
			case 'U':
			case 'I':
			case 'D':
			case 'F':
			case 'B':
				continue;
			case 0:
				--s;
				break;
			default:
				++col;
				continue;
			}
		} else {
			int wid = 0;
			if(locale_map->type) {
				c = utf8_decode(&sm,c);
				if (c>=0)
					wid = joe_wcwidth(c);
			} else {
				wid = 1;
			}
			col += wid;
		}
	}

	return s - org + goal - col;
}
@


1.44
log
@oh, oops
@
text
@d143 1
a143 1
				c = 0x1000FFFE;
@


1.43
log
@get rid of extra joe_wcwidth parameter by inlining its only remaining use
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.42 2018/01/08 01:56:22 tg Exp $");
d560 1
a560 1
	if (notoktomul((size_t)t->li, (size_t)t->co))
d563 2
d591 1
a591 1
	    !t->syntab || !t->compose || !t->ofst || !t->ary)
d593 2
@


1.42
log
@major xlat overhaul
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.40 2018/01/07 23:51:34 tg Exp $");
d130 1
a130 1
				wid = joe_wcwidth(1, c);
d1647 1
a1647 1
				wid = joe_wcwidth(1,c);
d1709 1
a1709 1
				col += joe_wcwidth(1,d);
d1766 1
a1766 1
					wid = joe_wcwidth(1, c);
d1836 1
a1836 1
					wid = joe_wcwidth(1,c);
d1887 1
a1887 1
					wid = joe_wcwidth(1,c);
@


1.41
log
@fix spelling:

while “dependant” is correct British English for someone depending
on their liege, “something-dependent” was meant here
@
text
@d31 18
a48 98
/* How to display characters (especially the control ones) */
/* here are characters ... */
static const unsigned char xlatc[256] = {
	 64,  65,  66,  67,  68,  69,  70,  71,			/*   8 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/*  16 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/*  24 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/*  32 */
	 32,  33,  34,  35,  36,  37,  38,  39,			/*  40 */
	 40,  41,  42,  43,  44,  45,  46,  47,			/*  48 */
	 48,  49,  50,  51,  52,  53,  54,  55,			/*  56 */
	 56,  57,  58,  59,  60,  61,  62,  63,			/*  64 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/*  72 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/*  80 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/*  88 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/*  96 */
	 96,  97,  98,  99, 100, 101, 102, 103,			/* 104 */
	104, 105, 106, 107, 108, 109, 110, 111,			/* 112 */
	112, 113, 114, 115, 116, 117, 118, 119,			/* 120 */
	120, 121, 122, 123, 124, 125, 126,  63,			/* 128 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/* 136 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/* 144 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/* 152 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/* 160 */
	 32,  33,  34,  35,  36,  37,  38,  39,			/* 168 */
	 40,  41,  42,  43,  44,  45,  46,  47,			/* 176 */
	 48,  49,  50,  51,  52,  53,  54,  55,			/* 184 */
	 56,  57,  58,  59,  60,  61,  62,  63,			/* 192 */

	 64,  65,  66,  67,  68,  69,  70,  71,			/* 200 */
	 72,  73,  74,  75,  76,  77,  78,  79,			/* 208 */
	 80,  81,  82,  83,  84,  85,  86,  87,			/* 216 */
	 88,  89,  90,  91,  92,  93,  94,  95,			/* 224 */
	 96,  97,  98,  99, 100, 101, 102, 103,			/* 232 */
	104, 105, 106, 107, 108, 109, 110, 111,			/* 240 */
	112, 113, 114, 115, 116, 117, 118, 119,			/* 248 */
	120, 121, 122, 123, 124, 125, 126,  63			/* 256 */
};
/* ... and here their attributes */
static const unsigned short xlata[256] = {
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*   4 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*   8 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  12 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  16 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  20 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  24 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  28 */
	UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,		/*  32 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  48 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  64 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  80 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/*  96 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		/* 112 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNDERLINE,	/* 128 */

	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 130 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 132 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 134 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 136 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 138 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 140 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 142 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 144 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 146 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 148 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 150 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 152 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 154 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 156 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 158 */
	INVERSE + UNDERLINE, INVERSE + UNDERLINE,		/* 160 */

	INVERSE, INVERSE, INVERSE, INVERSE,			/* 164 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 168 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 172 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 176 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 180 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 184 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 188 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 192 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 196 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 200 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 204 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 208 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 212 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 216 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 220 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 224 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 228 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 232 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 236 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 240 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 244 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 248 */
	INVERSE, INVERSE, INVERSE, INVERSE,			/* 252 */
	INVERSE, INVERSE, INVERSE, INVERSE + UNDERLINE		/* 256 */
};
d109 2
a110 1
void outatr_help(SCRN *t,int *scrn,int *attrf,int xx,int yy,int c,int a)
d113 2
a114 4
	if (locale_map->type && !joe_isprint(locale_map,c)) {
		a ^= xlata[c];
		c = xlatc[c];
	}
d118 2
a119 1
void outatr(struct charmap *map,SCRN *t,int *scrn,int *attrf,int xx,int yy,int c,int a)
d121 1
a121 4
	if(map->type)
		if(locale_map->type) {
			/* UTF-8 char to UTF-8 terminal */
			int wid;
d123 4
d139 12
d152 2
a153 31
			if(*scrn==c && *attrf==a)
				return;

			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t, xx, yy);
			if(t->attrib != a)
				set_attr(t, a);
			if (*unictrlbuf) {
				ttputs(unictrlbuf);
			} else {
				unsigned char buf[7];

				utf8_encode(buf,c);
				ttputs(buf);
				if (wid == 0 && xx > 0)
					attrf[-1] |= HAS_COMBINING;
			}
			t->x+=wid;
			while (wid>1) {
				*++scrn= -1;
				*++attrf= 0;
				--wid;
			}
		} else {
			/* UTF-8 char to non-UTF-8 terminal */
			/* Don't convert control chars below 256 */
			if ((c>=32 && c<=126) || c>=160) {
d156 4
a159 9
				c = from_uni(locale_map,c);
				if (c==-1)
					c = '?';
			}

			/* Deal with control characters */
			if (!joe_isprint(locale_map,c) && !(dspasis && c>=128)) {
				a ^= xlata[c];
				c = xlatc[c];
a160 14

			if(*scrn==c && *attrf==a)
				return;

			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t,xx,yy);
			if(t->attrib != a)
				set_attr(t,a);
			ttputc(c);
			t->x++;
d162 2
a163 10
	else
		if (!locale_map->type) {
			/* Non UTF-8 char to non UTF-8 terminal */
			/* Byte-byte Translate? */

			/* Deal with control characters */
			if (!joe_isprint(locale_map,c) && !(dspasis && c>=128)) {
				a ^= xlata[c];
				c = xlatc[c];
			}
d165 2
a166 2
			if (*scrn==c && *attrf==a)
				return;
d168 16
a183 2
			*scrn = c;
			*attrf = a;
d185 10
a194 46
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t,xx,yy);
			if(t->attrib != a)
				set_attr(t,a);
			ttputc(c);
			t->x++;
		} else {
			/* Non UTF-8 char to UTF-8 terminal */
			unsigned char buf[7];
			int wid;

			/* Deal with control characters */
			if (!(dspasis && c>=128) && !joe_isprint(map,c)) {
				a ^= xlata[c];
				c = xlatc[c];
			}

			c = to_uni(map,c);
			if (c < 32 || (c >= 0x7F && c < 0xA0)) {
				c = 0x1000FFFE;
				a = (a | UNDERLINE) ^ INVERSE;
			}
			utf8_encode(buf,c);

			if (*scrn == c && *attrf == a)
				return;

			wid = joe_wcwidth(0,c);
			*scrn = c;
			*attrf = a;
			if(t->ins)
				clrins(t);
			if(t->x != xx || t->y != yy)
				cpos(t, xx, yy);
			if(t->attrib != a)
				set_attr(t, a);
			ttputs(buf);
			t->x+=wid;
			while(wid>1) {
				*++scrn= -1;
				*++attrf= 0;
				--wid;
			}
		}
@


1.40
log
@new ralloc(x,y) = malloc(x*y) with checks, but not, unlike calloc,
with implizit size_t casting nor memory cleansing
@
text
@d2 1
a2 1
 *	Device independant TTY interface for JOE
d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.38 2017/12/08 02:57:17 tg Exp $");
@


1.39
log
@plug two more memory leaks
@
text
@d688 1
a688 1
	t->htab = calloc(256, sizeof(struct s_hentry));
d705 3
d724 2
a725 2
	t->scrn = calloc(t->li * t->co, sizeof(int));
	t->attr = calloc(t->li * t->co, sizeof(int));
d727 9
a735 5
	t->updtab = calloc(t->li, sizeof(int));
	t->syntab = calloc(t->li, sizeof(int));
	t->compose = calloc(t->co, sizeof(int));
	t->ofst = calloc(t->co, sizeof(int));
	t->ary = calloc(t->co, sizeof(struct s_hentry));
@


1.38
log
@further cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.37 2017/12/08 02:46:45 tg Exp $");
d660 1
@


1.37
log
@massive const offensive
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.35 2017/12/08 02:17:22 tg Exp $");
d477 2
a478 2
			t->ti = (void *)strdup(t->cap->paste_on);
			t->te = (void *)strdup(t->cap->paste_off);
d646 1
a646 1
/* Make sure terminal can do absolute positioning */
a659 5
#ifdef DEBUG
	/* these are strings, but I do not know if %s is appropriate -mirabilos */
	fprintf(stderr,"cm=%d ch=%d cv=%d ho=%d lf=%d DO=%d ll=%d up=%d UP=%d cr=%d\n",
		       t->cm, t->ch, t->cv, t->ho, t->lf, t->DO, t->ll, t->up, t->UP, t->cr);
#endif
d664 1
a664 1
/* Determine if we can scroll */
d670 1
a670 1
/* Determine if we can ins/del within lines */
d674 1
a674 1
/* Adjust for high baud rates */
d680 1
a680 1
/* Send out terminal initialization string */
d686 1
a686 1
/* Initialize variable screen size dependant vars */
d732 4
a735 3
/* Calculate cost of positioning the cursor using only relative cursor
 * positioning functions: t->(lf, DO, up, UP, bs, LE, RI, ta, bt) and rewriting
 * characters (to move right)
d744 1
a744 1
/* If we don't know the cursor position, force use of absolute positioning */
d748 1
a748 1
/* First adjust row */
d791 1
a791 1
/* Now adjust column */
d793 1
a793 1
/* Use tabs */
d837 1
a837 1
/* Use simple motions */
d883 4
a886 3
/* Home y position is usually 0, but it is 'top' if we have scrolling region
 * relative addressing
 */
d895 1
a895 1
/* Assume best way is with only using relative cursor positioning */
d900 5
a904 3
/* Now check if combinations of absolute cursor positioning functions are
 * better (or necessary in case one or both cursor positions are unknown)
 */
d998 5
a1002 3
/* Do absolute cursor positioning if we don't know the cursor position or
 * if it is faster than doing only relative cursor positioning
 */
d1073 1
a1073 1
/* Use relative cursor position functions if we're not there yet */
d1075 1
a1075 1
/* First adjust row */
d1098 1
a1098 1
/* Use tabs */
d1151 1
a1151 1
/* Now adjust column */
a1173 22

		/* if (t->cRI < x - t->x) { */
/*		} else {
			int *s = t->scrn + t->x + t->y * t->co;
			int *a = t->attr + t->x + t->y * t->co;

			if (t->ins)
				clrins(t);
			while (x > t->x) {
				int atr, c;
				if(*s==-1) c=' ', atr=0;
				else c= *s, atr= *a;

				if (atr != t->attrib)
					set_attr(t, atr);
				utf8_putc(c);
				++s;
				++a;
				++t->x;
			}
		}
*/
d1293 1
a1293 1
/* Build hash table */
d1301 1
a1301 1
/* Build offset table */
d1353 1
a1353 1
/* Apply scrolling commands */
@


1.36
log
@label indent; small tweaks while here
@
text
@d444 1
a444 1
	t->li = getnum(t->cap,US "li");
d447 1
a447 1
	t->co = getnum(t->cap,US "co");
d457 4
a460 4
	t->haz = getflag(t->cap,US "hz");
	t->os = getflag(t->cap,US "os");
	t->eo = getflag(t->cap,US "eo");
	if (getflag(t->cap,US "hc"))
d462 1
a462 1
	if (t->os || getflag(t->cap,US "ul"))
d465 2
a466 2
	t->xn = getflag(t->cap,US "xn");
	t->am = getflag(t->cap,US "am");
d468 2
a469 2
	t->cl = jgetstr(t->cap,US "cl");
	t->cd = jgetstr(t->cap,US "cd");
d472 2
a473 2
		t->ti = jgetstr(t->cap,US "ti");
		t->te = jgetstr(t->cap,US "te");
d501 5
a505 5
	t->ut = getflag(t->cap,US "ut");
	t->Sb = jgetstr(t->cap,US "AB");
	if (!t->Sb) t->Sb = jgetstr(t->cap,US "Sb");
	t->Sf = jgetstr(t->cap,US "AF");
	if (!t->Sf) t->Sf = jgetstr(t->cap,US "Sf");
d507 1
a507 1
	if (!(t->me = jgetstr(t->cap,US "me")))
d509 1
a509 1
	if ((t->mb = jgetstr(t->cap,US "mb")))
d511 1
a511 1
	if ((t->md = jgetstr(t->cap,US "md")))
d513 1
a513 1
	if ((t->mh = jgetstr(t->cap,US "mh")))
d515 1
a515 1
	if ((t->mr = jgetstr(t->cap,US "mr")))
d526 2
a527 2
			t->Sf =US "\\E[3%dm";
			t->Sb =US "\\E[4%dm";
d530 2
a531 2
			t->Sf =US "\033[3%p1%dm";
			t->Sb =US "\033[4%p1%dm";
d535 2
a536 2
	if (getnum(t->cap,US "sg") <= 0 && !t->mr && jgetstr(t->cap,US "se")) {
		if ((t->so = jgetstr(t->cap,US "so")) != NULL)
d538 1
a538 1
		t->se = jgetstr(t->cap,US "se");
d540 1
a540 1
	if (getflag(t->cap,US "xs") || getflag(t->cap,US "xt"))
d543 2
a544 2
	if (getnum(t->cap,US "ug") <= 0 && jgetstr(t->cap,US "ue")) {
		if ((t->us = jgetstr(t->cap,US "us")) != NULL)
d546 1
a546 1
		t->ue = jgetstr(t->cap,US "ue");
d549 1
a549 1
	if (!(t->uc = jgetstr(t->cap,US "uc")))
d551 1
a551 1
			t->uc =US "_";
d555 1
a555 1
	t->ms = getflag(t->cap,US "ms");
d557 35
a591 35
	t->da = getflag(t->cap,US "da");
	t->db = getflag(t->cap,US "db");
	t->cs = jgetstr(t->cap,US "cs");
	t->rr = getflag(t->cap,US "rr");
	t->sf = jgetstr(t->cap,US "sf");
	t->sr = jgetstr(t->cap,US "sr");
	t->SF = jgetstr(t->cap,US "SF");
	t->SR = jgetstr(t->cap,US "SR");
	t->al = jgetstr(t->cap,US "al");
	t->dl = jgetstr(t->cap,US "dl");
	t->AL = jgetstr(t->cap,US "AL");
	t->DL = jgetstr(t->cap,US "DL");
	if (!getflag(t->cap,US "ns") && !t->sf)
		t->sf =US "\12";

	if (!getflag(t->cap,US "in") && baud < 38400) {
		t->dc = jgetstr(t->cap,US "dc");
		t->DC = jgetstr(t->cap,US "DC");
		t->dm = jgetstr(t->cap,US "dm");
		t->ed = jgetstr(t->cap,US "ed");

		t->im = jgetstr(t->cap,US "im");
		t->ei = jgetstr(t->cap,US "ei");
		t->ic = jgetstr(t->cap,US "ic");
		t->IC = jgetstr(t->cap,US "IC");
		t->ip = jgetstr(t->cap,US "ip");
		t->mi = getflag(t->cap,US "mi");
	}

	if (jgetstr(t->cap,US "bc"))
		t->bs = jgetstr(t->cap,US "bc");
	else if (jgetstr(t->cap,US "le"))
		t->bs = jgetstr(t->cap,US "le");
	if (getflag(t->cap,US "bs"))
		t->bs =US "\10";
d595 3
a597 3
	t->lf =US "\12";
	if (jgetstr(t->cap,US "do"))
		t->lf = jgetstr(t->cap,US "do");
d600 1
a600 1
	t->up = jgetstr(t->cap,US "up");
d603 1
a603 1
	t->nd = jgetstr(t->cap,US "nd");
d606 10
a615 10
	if (getnum(t->cap,US "it") > 0)
		t->tw = getnum(t->cap,US "it");
	else if (getnum(t->cap,US "tw") > 0)
		t->tw = getnum(t->cap,US "tw");

	if (!(t->ta = jgetstr(t->cap,US "ta")))
		if (getflag(t->cap,US "pt"))
			t->ta =US "\11";
	t->bt = jgetstr(t->cap,US "bt");
	if (getflag(t->cap,US "xt") || !usetabs) {
d623 1
a623 1
	t->ho = jgetstr(t->cap,US "ho");
d625 1
a625 1
	t->ll = jgetstr(t->cap,US "ll");
d628 4
a631 4
	t->cr =US "\15";
	if (jgetstr(t->cap,US "cr"))
		t->cr = jgetstr(t->cap,US "cr");
	if (getflag(t->cap,US "nc") || getflag(t->cap,US "xr"))
d635 8
a642 8
	t->cRI = tcost(t->cap, t->RI = jgetstr(t->cap,US "RI"), 1, 2, 2, 0, 0);
	t->cLE = tcost(t->cap, t->LE = jgetstr(t->cap,US "LE"), 1, 2, 2, 0, 0);
	t->cUP = tcost(t->cap, t->UP = jgetstr(t->cap,US "UP"), 1, 2, 2, 0, 0);
	t->cDO = tcost(t->cap, t->DO = jgetstr(t->cap,US "DO"), 1, 2, 2, 0, 0);
	t->cch = tcost(t->cap, t->ch = jgetstr(t->cap,US "ch"), 1, 2, 2, 0, 0);
	t->ccv = tcost(t->cap, t->cv = jgetstr(t->cap,US "cv"), 1, 2, 2, 0, 0);
	t->ccV = tcost(t->cap, t->cV = jgetstr(t->cap,US "cV"), 1, 2, 2, 0, 0);
	t->ccm = tcost(t->cap, t->cm = jgetstr(t->cap,US "cm"), 1, 2, 2, 0, 0);
d644 1
a644 1
	t->cce = tcost(t->cap, t->ce = jgetstr(t->cap,US "ce"), 1, 2, 2, 0, 0);
@


1.35
log
@more small tweaks
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.33 2017/12/06 21:41:02 tg Exp $");
d1890 1
a1890 1
			switch (c = *s++) {
a1891 1
			case 'U':
a1894 1
			case 'I':
a1897 1
			case 'B':
a1900 1
			case 'D':
a1903 1
			case 'F':
a1905 3
			case 0:
				--s;
				break;
d1907 3
a1909 1
				if (col++ >= ofst) {
@


1.34
log
@don’t box malloc/calloc/realloc/free; don’t cast malloc result; order calloc args
@
text
@d660 1
a660 1
#ifdef	DEBUG
d662 2
a663 2
        fprintf(stderr,"cm=%d ch=%d cv=%d ho=%d lf=%d DO=%d ll=%d up=%d UP=%d cr=%d\n",
                       t->cm, t->ch, t->cv, t->ho, t->lf, t->DO, t->ll, t->up, t->UP, t->cr);
@


1.33
log
@const cleanup
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.31 2017/12/04 22:15:39 tg Exp $");
d485 1
a485 1
			cp = joe_malloc(n1 + n2 + 1);
d493 1
a493 1
			cp = joe_malloc(n1 + n2 + 1);
d710 1
a710 1
		joe_free(t->sary);
d712 1
a712 1
		joe_free(t->updtab);
d714 1
a714 1
		joe_free(t->syntab);
d716 1
a716 1
		joe_free(t->scrn);
d718 1
a718 1
		joe_free(t->attr);
d720 1
a720 1
		joe_free(t->compose);
d722 1
a722 1
		joe_free(t->ofst);
d724 1
a724 1
		joe_free(t->ary);
d1622 7
a1628 7
	joe_free(t->scrn);
	joe_free(t->attr);
	joe_free(t->sary);
	joe_free(t->ofst);
	joe_free(t->htab);
	joe_free(t->ary);
	joe_free(t);
@


1.32
log
@begin overhaul for antique/header compat:
• PARAMS begone
• libc4 ustat definition: resolve inline
• ignore HAVE_*_H for headers mksh includes unconditionally
@
text
@d692 1
a692 1
	t->htab = calloc(256, sizeof(struct hentry));
d732 1
a732 1
	t->ary = calloc(t->co, sizeof(struct hentry));
d1303 1
a1303 1
	struct hentry *htab = t->htab;
d1310 1
a1310 1
	mset(htab, 0, 256 * sizeof(struct hentry));
@


1.31
log
@clean up some unused/MS-DOS® stuff
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.30 2017/12/02 04:49:46 tg Exp $");
a12 1
#ifdef HAVE_STDLIB_H
a13 1
#endif
@


1.30
log
@fix assume_colour not working with the default “ansi” TERM
@
text
@d11 1
a11 1
__RCSID("$MirOS: contrib/code/jupp/scrn.c,v 1.28 2017/12/02 02:07:31 tg Exp $");
d1560 1
a1560 1
		if (ifhave)
@


1.29
log
@some fallout of the includes changes, some more reduction
@
text
@d521 6
a526 5

	if (assume_color) {
		/* Install color support if it looks like an ansi terminal (it has bold which begins with ESC [) */
#ifndef TERMINFO
		if (!t->Sf && t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') {
d530 1
a530 3
		}
#else
		if (!t->Sf && t->md && t->md[0]=='\033' && t->md[1]=='[') {
a534 1
#endif
@


1.28
log
@overhaul the way includes work; give jupp proper RCS IDs

(after all, empty source files are UB; win32.c is likely)
@
text
@d11 1
a11 1
__RCSID("$MirOS$");
a22 1
#include "utf8.h"
@


1.27
log
@prepare making ublock.c vfork-safe:
avoid overwriting a global variable in the child
@
text
@a0 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.26 2017/08/08 16:09:43 tg Exp $ */
d11 2
a12 1
#include <stdio.h>
@


1.26
log
@GCC 7 has stricter /* FALLTHROUGH */ rules
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.12 2013/11/07 21:50:35 tg Exp $ */
d664 1
a664 1
	signrm();
@


1.25
log
@movement replay, also wasn’t it…
@
text
@d216 1
d1032 1
d1052 1
@


1.24
log
@more treating of combined characters like normals

sadly, still not enough
@
text
@d1214 4
@


1.23
log
@partially fix redrawing for lines with combining characters

woes stem from the fact that their appearance in scrn is overwritten
by the next char on the line, which I could not fix as-is, only the
case where they were the last characters on the line… needs much more
research and restructuring the very concepts behind jupp ☹
@
text
@d1808 1
a1808 1
		if (wid>=0) {
d1818 1
a1818 1
				} else if(wid) {
d1935 1
a1935 1
			if (wid>=0) {
@


1.22
log
@convert only once
@
text
@d239 2
d1646 1
a1646 1
			}
d1654 1
a1654 1
		}
d1674 1
a1674 1
			}
d1682 1
a1682 1
		}
@


1.21
log
@cleanup; use correct buffer size for utf8_encode (lower, this time)
@
text
@a207 2
			int uni_ctrl = 0;
			unsigned char buf[16];
a215 2
				if (/* CONSTCOND */ 0)
					/* FALLTHROUGH */
a216 1
				  uni_ctrl = 1;
d232 2
a233 3
			if (uni_ctrl) {
				joe_snprintf_1((char *)buf,16,"<%X>",c);
				ttputs(buf);
d235 2
@


1.20
log
@use unictrl() more intelligently
@
text
@d308 1
a308 1
			unsigned char buf[16];
d1383 2
a1384 1
				for (z = x; z != t->co - 1 && ofst[z] == q; ++z) ;
d1395 2
a1396 1
				for (z = x; z != t->co - 1 && ofst[z] == q; ++z) ;
d1567 2
a1568 1
				for (r = y; r != t->li && (t->sary[r] < 0 || t->sary[r] == t->li); ++r) ;
d1573 2
a1574 1
						for (z = p; t->sary[z] = 0, (z && t->sary[z - 1] == q); --z) ;
d1808 1
a1808 1
			wid = 1 ;
d1841 1
a1841 1
	}
d1930 1
a1930 1
						wid = joe_wcwidth(1,c);
d1934 1
a1934 1
				wid = 1 ;
@


1.19
log
@fixup C1 display in help screen char table
@
text
@d211 11
a221 3
			/* Deal with control characters */
			if (c<32) {
				c = c + '@@';
d223 1
a223 6
			} else if (c==127) {
				c = '?';
				a ^= UNDERLINE;
			} else if (unictrl(c)) {
				a ^= UNDERLINE;
				uni_ctrl = 1;
a228 2
			wid = joe_wcwidth(1,c);

@


1.18
log
@the amount of dead code/function calls left here is staggering
@
text
@d192 10
@


1.17
log
@few more malloc → calloc
@
text
@a421 18
/* As above but useable in insert mode */
/* The cursor position must already be correct */

static void outatri(SCRN *t, int x, int y, int c, int a)
{
/*
	if (c == -1)
		c = ' ';
	if (a != t->attrib)
		set_attr(t, a);
	if (t->haz && c == '~')
		c = '\\';
	utf8_putc(c);
	t->x+=joe_wcwidth(1,c);
*/
	/* ++t->x; */
}

a1248 1
				outatri(t, x + a, y, s[a], as[a]);
a1254 2
			for (a = 0; a != n; ++a)
				outatri(t, x + a, y, s[a], as[a]);
@


1.16
log
@make use of calloc() zero-initialising
@
text
@d738 8
a745 8
	t->scrn = (int *) joe_malloc(t->li * t->co * sizeof(int));
	t->attr = (int *) joe_malloc(t->li * t->co * sizeof(int));
	t->sary = (int *) joe_calloc(t->li, sizeof(int));
	t->updtab = (int *) joe_malloc(t->li * sizeof(int));
	t->syntab = (int *) joe_malloc(t->li * sizeof(int));
	t->compose = (int *) joe_malloc(t->co * sizeof(int));
	t->ofst = (int *) joe_malloc(t->co * sizeof(int));
	t->ary = (struct hentry *) joe_malloc(t->co * sizeof(struct hentry));
@


1.15
log
@zero out the initial SCRN…
@
text
@d73 1
a73 1
/* ... and here their attributes */ 
d447 1
a447 1
	SCRN *t = (SCRN *) joe_calloc(1, sizeof(SCRN));
a474 2
	else
		t->ul = 0;
d482 1
a482 4
	if (notite) {
		t->ti = NULL;
		t->te = NULL;
	} else {
a517 5
	t->mb = NULL;
	t->md = NULL;
	t->mh = NULL;
	t->mr = NULL;
	t->avattr = 0;
d528 1
a528 1
      oops:
d534 1
a534 1
		if (!t->Sf && t->md && t->md[0]=='\\' && t->md[1]=='E' && t->md[2]=='[') { 
d540 1
a540 1
		if (!t->Sf && t->md && t->md[0]=='\033' && t->md[1]=='[') { 
a547 2
	t->so = NULL;
	t->se = NULL;
a555 2
	t->us = NULL;
	t->ue = NULL;
a596 11
	} else {
		t->dm = NULL;
		t->dc = NULL;
		t->DC = NULL;
		t->ed = NULL;
		t->im = NULL;
		t->ic = NULL;
		t->IC = NULL;
		t->ip = NULL;
		t->ei = NULL;
		t->mi = 1;
a598 1
	t->bs = NULL;
d628 1
a628 6
	if (getflag(t->cap,US "xt")) {
		t->ta = NULL;
		t->bt = NULL;
	}

	if (!usetabs) {
d680 1
a680 1
      ok:
d685 2
a686 5
	else {
		t->scroll = 0;
		if (baud < 38400)
			mid = 1;
	}
a690 2
	else
		t->insdel = 0;
d705 1
a705 9
	t->scrn = NULL;
	t->attr = NULL;
	t->sary = NULL;
	t->updtab = NULL;
	t->syntab = NULL;
	t->compose = NULL;
	t->ofst = NULL;
	t->ary = NULL;
	t->htab = (struct hentry *) joe_malloc(256 * sizeof(struct hentry));
d1040 2
a1041 1
doch:
d1059 2
a1060 1
docv:
d1474 1
a1474 1
      done:
d1545 1
a1545 1
      done:
@


1.14
log
@constify two arrays, halve the size of one…
@
text
@d447 1
a447 1
	SCRN *t = (SCRN *) joe_malloc(sizeof(SCRN));
@


1.13
log
@remove redundant check; from dcb (LP#1348614)
@
text
@d36 1
a36 1
unsigned char xlatc[256] = {
d74 1
a74 1
unsigned xlata[256] = {
@


1.12
log
@Update “visible spaces” while typing and fix it for nōn-UTF8 files; also rid some of the assumptions that all charmaps have tab, space at same positions
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.11 2012/12/30 21:45:17 tg Exp $ */
d307 1
a307 1
			if (c == -1 || c < 32 || (c >= 0x7F && c < 0xA0)) {
@


1.11
log
@the long-awaited bracketed paste mode, auto-enabled for TERM=xterm-xfree86 even (but not within GNU screen, see TODO for explanation)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.9 2012/12/22 00:06:13 tg Exp $ */
d1863 1
a1863 1
						outatr(locale_map, t, scrn, attr, x, y, '>', my_atr);
d1880 1
a1880 1
					outatr(locale_map, t, scrn, attr, x, y, '<', my_atr);
d1893 1
a1893 1
		outatr(locale_map, t, scrn, attr, x, y, ' ', 0);
d1998 1
a1998 1
						outatr(locale_map, t, scrn, attr, x, y, '<', atr);
@


1.10
log
@more const cleanliness (and merr is used in a signal handler so it should be volatile), and use NULL not 0 for pointers
@
text
@d30 1
a480 4
	if (notite)
		t->ti = 0;
	else
		t->ti = jgetstr(t->cap,US "ti");
d484 5
a488 3
	if (notite)
		t->te = 0;
	else
d490 26
@


1.9
log
@some clang-3.2/scan-build work; also checked against gcc-4.7, gcc-4.8 and
gcc version 4.8.0 20121120 (experimental) [trunk revision 193662] (Debian 20121120-1)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.8 2011/10/04 20:05:29 tg Exp $ */
d1900 1
a1900 1
void genfmt(SCRN *t, int x, int y, int ofst, unsigned char *s, int flg)
d1990 1
a1990 1
int fmtlen(unsigned char *s)
@


1.8
log
@ASCII 0x7E (tilde) was broken in non-UTF-8 encodings (off-by-one, mea culpa)
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.7 2010/04/08 15:31:03 tg Exp $ */
d1026 1
a1026 1
			bestcost = cost;
@


1.7
log
@Add --disable-getpwnam and clean up warnings
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.6 2009/10/18 14:52:57 tg Exp $ */
d306 1
a306 1
			if (c == -1 || c < 32 || (c >= 0x7E && c < 0xA0)) {
@


1.6
log
@backport hex editing mode from joe 3.7 for waga as late birthday present
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.5 2009/10/18 13:51:26 tg Exp $ */
a32 2
extern int mid;

@


1.5
log
@never, ever, display UTF-8 C0/C1 control characters directly
for non-UTF8 documents
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/jupp/scrn.c,v 1.3 2008/05/13 13:08:25 tg Exp $ */
d1813 1
a1813 1
void genfield(SCRN *t,int *scrn,int *attr,int x,int y,int ofst,unsigned char *s,int len,int atr,int width,int flg)
d1824 2
d1840 1
a1840 1
						outatr(locale_map, t, scrn, attr, x, y, '>', atr);
d1847 1
a1847 1
					outatr(locale_map, t, scrn, attr, x, y, c, atr);
d1857 1
a1857 1
					outatr(locale_map, t, scrn, attr, x, y, '<', atr);
@


1.4
log
@display undecodable chars in non-UTF8-mode to UTF8-terminal the same
as in UTF8-mode (inverse underlined U+FFFD)
@
text
@d308 1
a308 1
			if (c == -1) {
@


1.3
log
@prepare for joe-3.1jupp9:
* sync NEWS
* bump vsn in configure.ac
* tag all files with RCS ID
* sync licence template
@
text
@d1 1
a1 1
/* $MirOS$ */
d308 4
a311 2
			if (c == -1)
				c = '?';
@


1.2
log
@Update the non-generated files to joe-3.1jupp2
@
text
@d1 1
d680 1
a680 1
	/* these are strings, but I do not know if %s is appropriate -mirabile */
@


1.1
log
@Initial revision
@
text
@d15 1
d227 1
a227 1
				sprintf((char *)buf,"<%X>",c);
d242 1
a242 1
			if (c>=32 && c<=126 || c>=160) {
d678 2
d682 1
d1354 1
a1354 1
			int maxaryy;
d1830 1
a1830 1
		if (wid>=0)
d1862 1
d1957 1
a1957 1
			if (wid>=0)
d1980 1
d1995 1
a1995 1
	while (c= *s++) {
@


1.1.21.1
log
@Import joe-2.8 sources into vendor branch so it doesn't get lost
@
text
@d1 9
a9 2
/* Device independant TTY interface for JOE
   Copyright (C) 1992 Joseph H. Allen
d11 4
a14 14
This file is part of JOE (Joe's Own Editor)

JOE is free software; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 1, or (at your option) any later version.  

JOE is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
details.  

You should have received a copy of the GNU General Public License along with 
JOE; see the file COPYING.  If not, write to the Free Software Foundation, 
675 Mass Ave, Cambridge, MA 02139, USA.  */ 
d16 1
a16 2
#include <stdio.h>
#include <signal.h>
d18 1
a18 1
#include "vs.h"
d20 122
a141 3
#include "tty.h"
#include "zstr.h"
#include "scrn.h"
d143 37
a179 3
int skiptop=0;
int lines=0;
int columns=0;
d181 2
a182 1
extern int mid;
d184 1
a184 1
/* How to display characters */
d186 2
a187 62
unsigned xlata[256]=
 {
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 UNDERLINE, UNDERLINE, UNDERLINE, UNDERLINE,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 UNDERLINE,

 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 
 INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, INVERSE+UNDERLINE, 

 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, 
 INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE, INVERSE,
 
 INVERSE+UNDERLINE, 
 };

unsigned char xlatc[256]=
 {
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,63
 }; 
d189 1
a189 1
/* Set attributes */
d191 139
a329 31
int attr(t,c)
SCRN *t;
int c;
{
int e;
c&=~255;
e=(t->attrib&~c);
if(e) /* If any attribute go off, switch them all off: fixes bug on PCs */
 {
 if(t->me) texec(t->cap,t->me,1);
 else
  {
  if(t->ue) texec(t->cap,t->ue,1);
  if(t->se) texec(t->cap,t->se,1);
  }
 t->attrib=0;
 }
e=(c&~t->attrib);
if(e&INVERSE)
 if(t->mr) texec(t->cap,t->mr,1);
 else if(t->so) texec(t->cap,t->so,1);
if(e&UNDERLINE)
 if(t->us) texec(t->cap,t->us,1);
if(e&BLINK)
 if(t->mb) texec(t->cap,t->mb,1);
if(e&BOLD)
 if(t->md) texec(t->cap,t->md,1);
if(e&DIM)
 if(t->mh) texec(t->cap,t->mh,1);
t->attrib=c;
return 0;
d334 14
a347 17
void setregn(t,top,bot)
SCRN *t;
int top,bot;
{
if(!t->cs)
 {
 t->top=top;
 t->bot=bot;
 return;
 }
if(t->top!=top || t->bot!=bot)
 {
 t->top=top;
 t->bot=bot;
 texec(t->cap,t->cs,1,top,bot-1);
 t->x= -1; t->y= -1;
 }
d352 1
a352 2
void setins(t,x)
SCRN *t;
d354 4
a357 5
if(t->ins!=1 && t->im)
 {
 t->ins=1;
 texec(t->cap,t->im,1,x);
 }
d362 1
a362 2
int clrins(t)
SCRN *t;
d364 5
a368 6
if(t->ins!=0)
 {
 texec(t->cap,t->ei,1);
 t->ins=0;
 }
return 0;
d373 1
a373 2
int eraeol(t,x,y)
SCRN *t;
d375 42
a416 24
int *s, *ss;
int w=t->co-x-1;			/* Don't worry about last column */
if(w<=0) return 0;
s=t->scrn+y*t->co+x;
ss=s+w;
do if(*--ss!=' ') { ++ss; break; } while(ss!=s);
if((ss-s>3 || s[w]!=' ') && t->ce)
 {
 cpos(t,x,y);
 attr(t,0);
 texec(t->cap,t->ce,1);
 msetI(s,' ',w);
 }
else if(s!=ss)
 {
 if(t->ins) clrins(t);
 if(t->x!=x || t->y!=y) cpos(t,x,y);
 if(t->attrib) attr(t,0);
 while(s!=ss)
  {
  *s=' '; ttputc(' '); ++t->x; ++s;
  }
 }
return 0;
d422 1
a422 2
void outatri(t,x,y,c)
SCRN *t;
d424 236
a659 156
unsigned char ch;
if(c== -1) c=' ';
ch=c; c-=ch;
if(c!=t->attrib) attr(t,c);
if(t->haz && ch=='~') ch='\\';
ttputc(ch);
++t->x;
}

void out(t,c)
char *t;
char c;
 {
 ttputc(c);
 }

SCRN *nopen(cap)
CAP *cap;
{
SCRN *t=(SCRN *)malloc(sizeof(SCRN));
int x,y;
ttopen();

t->cap=cap;
setcap(cap,baud,out,NULL);

t->li=getnum(t->cap,"li"); if(t->li<1) t->li=24;
t->co=getnum(t->cap,"co"); if(t->co<2) t->co=80;
x=y=0;
ttgtsz(&x,&y);
if(x>7 && y>3) t->li=y, t->co=x;

t->haz=getflag(t->cap,"hz");
t->os=getflag(t->cap,"os");
t->eo=getflag(t->cap,"eo");
if(getflag(t->cap,"hc")) t->os=1;
if(t->os || getflag(t->cap,"ul")) t->ul=1;
else t->ul=0;

t->xn=getflag(t->cap,"xn");
t->am=getflag(t->cap,"am");

t->ti=jgetstr(t->cap,"ti");
t->cl=jgetstr(t->cap,"cl");
t->cd=jgetstr(t->cap,"cd");

t->te=jgetstr(t->cap,"te");

t->mb=0; t->md=0; t->mh=0; t->mr=0; t->avattr=0;
if(!(t->me=jgetstr(t->cap,"me"))) goto oops;
if((t->mb=jgetstr(t->cap,"mb"))) t->avattr|=BLINK;
if((t->md=jgetstr(t->cap,"md"))) t->avattr|=BOLD;
if((t->mh=jgetstr(t->cap,"mh"))) t->avattr|=DIM;
if((t->mr=jgetstr(t->cap,"mr"))) t->avattr|=INVERSE;
oops:

t->so=0; t->se=0;
if(getnum(t->cap,"sg")<=0 && !t->mr && jgetstr(t->cap,"se"))
 {
 if(t->so=jgetstr(t->cap,"so")) t->avattr|=INVERSE;
 t->se=jgetstr(t->cap,"se");
 }
if(getflag(t->cap,"xs") || getflag(t->cap,"xt")) t->so=0;

t->us=0; t->ue=0;
if(getnum(t->cap,"ug")<=0 && jgetstr(t->cap,"ue"))
 {
 if(t->us=jgetstr(t->cap,"us")) t->avattr|=UNDERLINE;
 t->ue=jgetstr(t->cap,"ue");
 }

if(!(t->uc=jgetstr(t->cap,"uc"))) if(t->ul) t->uc="_";
if(t->uc) t->avattr|=UNDERLINE;

t->ms=getflag(t->cap,"ms");

t->da=getflag(t->cap,"da");
t->db=getflag(t->cap,"db");
t->cs=jgetstr(t->cap,"cs");
t->rr=getflag(t->cap,"rr");
t->sf=jgetstr(t->cap,"sf");
t->sr=jgetstr(t->cap,"sr");
t->SF=jgetstr(t->cap,"SF");
t->SR=jgetstr(t->cap,"SR");
t->al=jgetstr(t->cap,"al");
t->dl=jgetstr(t->cap,"dl");
t->AL=jgetstr(t->cap,"AL");
t->DL=jgetstr(t->cap,"DL");
if(!getflag(t->cap,"ns") && !t->sf) t->sf="\12";

if(!getflag(t->cap,"in") && baud<38400 )
 {
 t->dc=jgetstr(t->cap,"dc");
 t->DC=jgetstr(t->cap,"DC");
 t->dm=jgetstr(t->cap,"dm");
 t->ed=jgetstr(t->cap,"ed");

 t->im=jgetstr(t->cap,"im");
 t->ei=jgetstr(t->cap,"ei");
 t->ic=jgetstr(t->cap,"ic");
 t->IC=jgetstr(t->cap,"IC");
 t->ip=jgetstr(t->cap,"ip");
 t->mi=getflag(t->cap,"mi");
 }
else
 {
 t->dm=0; t->dc=0; t->DC=0; t->ed=0;
 t->im=0; t->ic=0; t->IC=0; t->ip=0; t->ei=0;
 t->mi=1;
 }

t->bs=0;
if(jgetstr(t->cap,"bc")) t->bs=jgetstr(t->cap,"bc");
else if(jgetstr(t->cap,"le")) t->bs=jgetstr(t->cap,"le");
if(getflag(t->cap,"bs")) t->bs="\10";

t->cbs=tcost(t->cap,t->bs,1,2,2);

t->lf="\12";
if(jgetstr(t->cap,"do")) t->lf=jgetstr(t->cap,"do");
t->clf=tcost(t->cap,t->lf,1,2,2);

t->up=jgetstr(t->cap,"up");
t->cup=tcost(t->cap,t->up,1,2,2);

t->nd=jgetstr(t->cap,"nd");

t->tw=8;
if(getnum(t->cap,"it")>0) t->tw=getnum(t->cap,"it");
else if(getnum(t->cap,"tw")>0) t->tw=getnum(t->cap,"tw");

if(!(t->ta=jgetstr(t->cap,"ta"))) if(getflag(t->cap,"pt")) t->ta="\11";
t->bt=jgetstr(t->cap,"bt");
if(getflag(t->cap,"xt")) t->ta=0, t->bt=0;

t->cta=tcost(t->cap,t->ta,1,2,2);
t->cbt=tcost(t->cap,t->bt,1,2,2);

t->ho=jgetstr(t->cap,"ho");
t->cho=tcost(t->cap,t->ho,1,2,2);
t->ll=jgetstr(t->cap,"ll");
t->cll=tcost(t->cap,t->ll,1,2,2);

t->cr="\15";
if(jgetstr(t->cap,"cr")) t->cr=jgetstr(t->cap,"cr");
if(getflag(t->cap,"nc") || getflag(t->cap,"xr")) t->cr=0;
t->ccr=tcost(t->cap,t->cr,1,2,2);

t->cRI=tcost(t->cap,t->RI=jgetstr(t->cap,"RI"),1,2,2);
t->cLE=tcost(t->cap,t->LE=jgetstr(t->cap,"LE"),1,2,2);
t->cUP=tcost(t->cap,t->UP=jgetstr(t->cap,"UP"),1,2,2);
t->cDO=tcost(t->cap,t->DO=jgetstr(t->cap,"DO"),1,2,2);
t->cch=tcost(t->cap,t->ch=jgetstr(t->cap,"ch"),1,2,2);
t->ccv=tcost(t->cap,t->cv=jgetstr(t->cap,"cv"),1,2,2);
t->ccV=tcost(t->cap,t->cV=jgetstr(t->cap,"cV"),1,2,2);
t->ccm=tcost(t->cap,t->cm=jgetstr(t->cap,"cm"),1,2,2);
d661 1
a661 1
t->cce=tcost(t->cap,t->ce=jgetstr(t->cap,"ce"),1,2,2);
d664 18
a681 11
if(t->cm) goto ok;
if(t->ch && t->cv) goto ok;
if(t->ho && (t->lf || t->DO || t->cv)) goto ok;
if(t->ll && (t->up || t->UP || t->cv)) goto ok;
if(t->cr && t->cv) goto ok;
leave=1;
ttclose();
signrm();
fprintf(stderr,"Sorry, your terminal can't do absolute cursor positioning.\nIt's broken\n");
return 0;
ok:
d684 7
a690 7
if((t->sr || t->SR) && (t->sf || t->SF) && t->cs ||
   (t->al || t->AL) && (t->dl || t->DL)) t->scroll=1;
else
 {
 t->scroll=0;
 if(baud<38400) mid=1;
 }
d693 4
a696 2
if((t->im || t->ic || t->IC) && (t->dc || t->DC)) t->insdel=1;
else t->insdel=0;
d699 10
a708 1
if(baud>=38400) t->scroll=0, t->insdel=0;
d711 9
a719 4
t->scrn=0; t->sary=0; t->updtab=0; t->compose=0;
t->ofst=0; t->ary=0;
t->htab=(struct hentry *)malloc(256*sizeof(struct hentry));
nresize(t,t->co,t->li);
d721 1
a721 2
/* Send out terminal initialization string */
if(t->ti) texec(t->cap,t->ti,1);
d723 2
a724 2
return t;
} 
d728 1
a728 2
void nresize(t,w,h)
SCRN *t;
d730 32
a761 17
if(h<4) h=4;
if(w<8) w=8;
t->li=h;
t->co=w;
if(t->sary) free(t->sary);
if(t->updtab) free(t->updtab);
if(t->scrn) free(t->scrn);
if(t->compose) free(t->compose);
if(t->ofst) free(t->ofst);
if(t->ary) free(t->ary);
t->scrn=(int *)malloc(t->li*t->co*sizeof(int));
t->sary=(int *)calloc(t->li,sizeof(int));
t->updtab=(int *)malloc(t->li*sizeof(int));
t->compose=(int *)malloc(t->co*sizeof(int));
t->ofst=(int *)malloc(t->co*sizeof(int));
t->ary=(struct hentry *)malloc(t->co*sizeof(struct hentry));
nredraw(t);
d771 1
a771 3
static int relcost(t,x,y,ox,oy)
register SCRN *t;
register int x,y,ox,oy;
d773 1
a773 1
int cost=0;
d776 2
a777 1
if(oy== -1 || ox== -1) return 10000;
d780 41
a820 32
if(y>oy)
 {
 int dist=y-oy;
 /* Have to go down */
 if(t->lf)
  {
  int mult=dist*t->clf;
  if(dist<10 && t->cDO<mult) cost+=t->cDO;
  else if(dist>=10 && t->cDO+1<mult) cost+=t->cDO+1;
  else cost+=mult;
  }
 else if(t->DO)
  if(dist<10) cost+=t->cDO;
  else cost+=t->cDO+1;
 else return 10000;
 }
else if(y<oy)
 {
 int dist=oy-y;
 /* Have to go up */
 if(t->up)
  {
  int mult=dist*t->cup;
  if(dist<10 && t->cUP<mult) cost+=t->cUP;
  else if(dist>=10 && t->cUP<mult) cost+=t->cUP+1;
  else cost+=mult;
  }
 else if(t->UP)
  if(dist<10) cost+=t->cUP;
  else cost+=t->cUP+1;
 else return 10000;
 }
d825 42
a866 28
if(x>ox && t->ta)
 {
 int dist=x-ox;
 int ntabs=(dist+ox%t->tw)/t->tw;
 int cstunder=x%t->tw+t->cta*ntabs, cstover;
 if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
 else cstover=10000;
 if(dist<10 && cstunder<t->cRI && cstunder<x-ox && cstover>cstunder)
  return cost+cstunder;
 else if(cstunder<t->cRI+1 && cstunder<x-ox && cstover>cstunder)
  return cost+cstunder;
 else if(dist<10 && cstover<t->cRI && cstover<x-ox) return cost+cstover;
 else if(cstover<t->cRI+1 && cstover<x-ox) return cost+cstover;
 }
else if(x<ox && t->bt)
 {
 int dist=ox-x; 
 int ntabs=(dist+t->tw-ox%t->tw)/t->tw;
 int cstunder,cstover;
 if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
 if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
 if(dist<10 && cstunder<t->cLE && (t->bs?cstunder<(ox-x)*t->cbs:1) && cstover>cstunder)
  return cost+cstunder;
 if(cstunder<t->cLE+1 && (t->bs?cstunder<(ox-x)*t->cbs:1) && cstover>cstunder)
  return cost+cstunder;
 else if(dist<10 && cstover<t->cRI && (t->bs?cstover<(ox-x)*t->cbs:1)) return cost+cstover;
 else if(cstover<t->cRI+1 && (t->bs?cstover<(ox-x)*t->cbs:1)) return cost+cstover;
 }
d869 2
a870 23
if(x<ox)
 {
 int dist=ox-x;
 /* Have to go left */
 if(t->bs)
  {
  int mult=dist*t->cbs;
  if(t->cLE<mult && dist<10) cost+=t->cLE;
  else if(t->cLE+1<mult) cost+=t->cLE+1;
  else cost+=mult;
  }
 else if(t->LE) cost+=t->cLE;
 else return 10000;
 }
else if(x>ox)
 {
 int dist=x-ox;
 /* Have to go right */
 /* Hmm.. this should take into account possible attribute changes */
 if(t->cRI<dist && dist<10) cost+=t->cRI;
 else if(t->cRI+1<dist) cost+=t->cRI+1;
 else cost+=dist;
 }
d872 28
a899 1
return cost;
d907 6
a912 8
static void cposs(t,x,y)
register SCRN *t;
register int x,y;
{
register int bestcost,cost;
int bestway;
int hy;
int hl;
d917 7
a923 2
if(t->rr) hy=t->top, hl=t->bot-1;
else hy=0, hl=t->li-1;
d927 2
a928 1
bestcost=relcost(t,x,y,t->x,t->y); bestway=0;
d934 91
a1024 70
if(t->ccm<bestcost)
 {
 cost=tcost(t->cap,t->cm,1,y,x);
 if(cost<bestcost) bestcost=cost, bestway=6;
 }
if(t->ccr<bestcost)
 {
 cost=relcost(t,x,y,0,t->y)+t->ccr;
 if(cost<bestcost) bestcost=cost, bestway=1;
 }
if(t->cho<bestcost)
 {
 cost=relcost(t,x,y,0,hy)+t->cho;
 if(cost<bestcost) bestcost=cost, bestway=2;
 }
if(t->cll<bestcost)
 {
 cost=relcost(t,x,y,0,hl)+t->cll;
 if(cost<bestcost) bestcost=cost, bestway=3;
 }
if(t->cch<bestcost && x!=t->x)
 {
 cost=relcost(t,x,y,x,t->y)+tcost(t->cap,t->ch,1,x);
 if(cost<bestcost) bestcost=cost, bestway=4;
 }
if(t->ccv<bestcost && y!=t->y)
 {
 cost=relcost(t,x,y,t->x,y)+tcost(t->cap,t->cv,1,y);
 if(cost<bestcost) bestcost=cost, bestway=5;
 }
if(t->ccV<bestcost)
 {
 cost=relcost(t,x,y,0,y)+tcost(t->cap,t->cV,1,y);
 if(cost<bestcost) bestcost=cost, bestway=13;
 }
if(t->cch+t->ccv<bestcost && x!=t->x && y!=t->y)
 {
 cost=tcost(t->cap,t->cv,1,y-hy)+tcost(t->cap,t->ch,1,x);
 if(cost<bestcost) bestcost=cost, bestway=7;
 }
if(t->ccv+t->ccr<bestcost && y!=t->y)
 {
 cost=tcost(t->cap,t->cv,1,y)+tcost(t->cap,t->cr,1)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=8;
 }
if(t->cll+t->cch<bestcost)
 {
 cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->ch,1,x)+
      relcost(t,x,y,x,hl);
 if(cost<bestcost) bestcost=cost, bestway=9;
 }
if(t->cll+t->ccv<bestcost)
 {
 cost=tcost(t->cap,t->ll,1)+tcost(t->cap,t->cv,1,y)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=10;
 }
if(t->cho+t->cch<bestcost)
 {
 cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->ch,1,x)+
      relcost(t,x,y,x,hy);
 if(cost<bestcost) bestcost=cost, bestway=11;
 }
if(t->cho+t->ccv<bestcost)
 {
 cost=tcost(t->cap,t->ho,1)+tcost(t->cap,t->cv,1,y)+
      relcost(t,x,y,0,y);
 if(cost<bestcost) bestcost=cost, bestway=12;
 }
d1030 64
a1093 20
switch(bestway)
 {
case 1: texec(t->cap,t->cr,1); t->x=0; break;
case 2: texec(t->cap,t->ho,1); t->x=0; t->y=hy; break;
case 3: texec(t->cap,t->ll,1); t->x=0; t->y=hl; break;
case 9: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto doch;
case 11: texec(t->cap,t->ho,1); t->x=0; t->y=hy;
  doch:
case 4: texec(t->cap,t->ch,1,x); t->x=x; break;
case 10: texec(t->cap,t->ll,1); t->x=0; t->y=hl; goto docv;
case 12: texec(t->cap,t->ho,1); t->x=0; t->y=hy; goto docv;
case 8: texec(t->cap,t->cr,1); t->x=0;
  docv:
case 5: texec(t->cap,t->cv,1,y); t->y=y; break;
case 6: texec(t->cap,t->cm,1,y,x); t->y=y, t->x=x; break;
case 7: texec(t->cap,t->cv,1,y); t->y=y;
        texec(t->cap,t->ch,1,x); t->x=x;
        break;
case 13: texec(t->cap,t->cV,1,y); t->y=y; t->x=0; break;
 }
d1098 21
a1118 10
if(y>t->y)
 /* Have to go down */
 if(!t->lf || t->cDO<(y-t->y)*t->clf)
  texec(t->cap,t->DO,1,y-t->y), t->y=y;
 else while(y>t->y) texec(t->cap,t->lf,1), ++t->y;
else if(y<t->y)
 /* Have to go up */
 if(!t->up || t->cUP<(t->y-y)*t->cup)
  texec(t->cap,t->UP,1,t->y-y), t->y=y;
 else while(y<t->y) texec(t->cap,t->up,1), --t->y;
d1121 51
a1171 42
if(x>t->x && t->ta)
 {
 int ntabs=(x-t->x+t->x%t->tw)/t->tw;
 int cstunder=x%t->tw+t->cta*ntabs, cstover;
 if(x+t->tw<t->co && t->bs) cstover=t->cbs*(t->tw-x%t->tw)+t->cta*(ntabs+1);
 else cstover=10000;
 if(cstunder<t->cRI && cstunder<x-t->x && cstover>cstunder)
  {
  if(ntabs)
   {
   t->x=x-x%t->tw;
   do texec(t->cap,t->ta,1); while(--ntabs);
   }
  }
 else if(cstover<t->cRI && cstover<x-t->x)
  {
  t->x=t->tw+x-x%t->tw;
  ++ntabs;
  do texec(t->cap,t->ta,1); while(--ntabs);
  }
 }
else if(x<t->x && t->bt)
 {
 int ntabs=((t->x+t->tw-1)-(t->x+t->tw-1)%t->tw-
            ((x+t->tw-1)-(x+t->tw-1)%t->tw))/t->tw;
 int cstunder,cstover;
 if(t->bs) cstunder=t->cbt*ntabs+t->cbs*(t->tw-x%t->tw); else cstunder=10000;
 if(x-t->tw>=0) cstover=t->cbt*(ntabs+1)+x%t->tw; else cstover=10000;
 if(cstunder<t->cLE && (t->bs?cstunder<(t->x-x)*t->cbs:1) && cstover>cstunder)
  {
  if(ntabs)
   {
   do texec(t->cap,t->bt,1); while(--ntabs);
   t->x=x+t->tw-x%t->tw;
   }
  }
 else if(cstover<t->cRI && (t->bs?cstover<(t->x-x)*t->cbs:1))
  {
  t->x=x-x%t->tw; ++ntabs;
  do texec(t->cap,t->bt,1); while(--ntabs);
  }
 }
d1174 144
a1317 102
if(x<t->x)
 /* Have to go left */
 if(!t->bs || t->cLE<(t->x-x)*t->cbs)
  texec(t->cap,t->LE,1,t->x-x), t->x=x;
 else while(x<t->x) texec(t->cap,t->bs,1), --t->x;
else if(x>t->x)
 /* Have to go right */
 /* Hmm.. this should take into account possible attribute changes */
 if(t->cRI<x-t->x) texec(t->cap,t->RI,1,x-t->x), t->x=x;
 else
  {
  int *s=t->scrn+t->x+t->y*t->co;
  if(t->ins) clrins(t);
  while(x>t->x)
   {
   int c= (0xFF&*s);
   int a= (0xFF00&*s);
   if(a!=t->attrib) attr(t,a);
   ttputc(c);
   ++s; ++t->x;
   }
  }
}

int cpos(t,x,y)
register SCRN *t;
register int x,y;
{
if(y==t->y)
 {
 if(x==t->x) return 0;
 if(x>t->x && x-t->x<4 && !t->ins)
  {
  int *cs=t->scrn+t->x+t->co*t->y;
  if(t->ins) clrins(t);
  do
   {
   int c= (0xFF& *cs);
   int a= (0xFF00& *cs);
   if(a!=t->attrib) attr(t,a);
   ttputc(c);
   ++cs; ++t->x;
   } while(x!=t->x);
  return 0;
  }
 }
if(!t->ms && t->attrib&(INVERSE|UNDERLINE))
 attr(t,t->attrib&~(INVERSE|UNDERLINE));
if(y<t->top || y>=t->bot) setregn(t,0,t->li);
cposs(t,x,y);
return 0;
}

static void doinschr(t,x,y,s,n)
SCRN *t;
int x,y,*s,n;
{
int a;
if(x<0) s-=x, x=0;
if(x>=t->co-1 || n<=0) return;
if(t->im || t->ic || t->IC)
 {
 cpos(t,x,y);
 if(n==1 && t->ic || !t->IC)
  {
  if(!t->ic) setins(t,x);
  for(a=0;a!=n;++a)
   {
   texec(t->cap,t->ic,1,x);
   outatri(t,x+a,y,s[a]);
   texec(t->cap,t->ip,1,x);
   }
  if(!t->mi) clrins(t);
  }
 else
  {
  texec(t->cap,t->IC,1,n);
  for(a=0;a!=n;++a) outatri(t,x+a,y,s[a]);
  }
 }
mmove(t->scrn+x+t->co*y+n,t->scrn+x+t->co*y,(t->co-(x+n))*sizeof(int));
mcpy(t->scrn+x+t->co*y,s,n*sizeof(int));
}

static void dodelchr(t,x,y,n)
SCRN *t;
int x,y,n;
{
int a;
if(x<0) x=0;
if(!n || x>=t->co-1) return;
if(t->dc || t->DC)
 {
 cpos(t,x,y);
 texec(t->cap,t->dm,1,x);		/* Enter delete mode */
 if(n==1 && t->dc || !t->DC)
  for(a=n;a;--a) texec(t->cap,t->dc,1,x);
 else texec(t->cap,t->DC,1,n);
 texec(t->cap,t->ed,1,x);		/* Exit delete mode */
 }
mmove(t->scrn+t->co*y+x,t->scrn+t->co*y+x+n,(t->co-(x+n))*sizeof(int));
msetI(t->scrn+t->co*y+t->co-n,' ',n);
d1321 8
d1330 5
a1334 12
void magic(t,y,cs,s,placex)
SCRN *t;
int y,*cs,*s;
{
struct hentry *htab=t->htab;
int *ofst=t->ofst;
int aryx=1;
int x;
if(!(t->im || t->ic || t->IC) ||
   !(t->dc || t->DC)) return;
mset(htab,0,256*sizeof(struct hentry));
msetI(ofst,0,t->co);
d1337 6
a1342 5
for(x=0;x!=t->co-1;++x)
 t->ary[aryx].next=htab[cs[x]&255].next,
 t->ary[aryx].loc=x,
 ++htab[cs[x]&255].loc,
 htab[cs[x]&255].next=aryx++;
d1345 50
a1394 37
for(x=0;x<t->co-1;)
 if(htab[s[x]&255].loc>=15) ofst[x++]= t->co-1;
 else
  {
  int aryy;
  int maxaryy;
  int maxlen=0;
  int best=0;
  int bestback=0;
  int z;
  for(aryy=htab[s[x]&255].next;aryy;aryy=t->ary[aryy].next)
   {
   int amnt,back;
   int tsfo=t->ary[aryy].loc-x;
   int cst= -Iabs(tsfo);
   int pre=32;
   for(amnt=0;x+amnt<t->co-1 && x+tsfo+amnt<t->co-1;++amnt)
    {
    if(cs[x+tsfo+amnt]!=s[x+amnt]) break;
    else if(s[x+amnt]&255!=32 || pre!=32) ++cst;
    pre=s[x+amnt]&255;
    }
   pre=32;
   for(back=0;back+x>0 && back+tsfo+x>0;--back)
    {
    if(cs[x+tsfo+back-1]!=s[x+back-1]) break;
    else if(s[x+back-1]&255!=32 || pre!=32) ++cst;
    pre=s[x+back-1]&255;
    }
   if(cst>best) maxaryy=aryy, maxlen=amnt, best=cst, bestback=back;
   }
  if(!maxlen) ofst[x]=t->co-1, maxlen=1;
  else if(best<2) for(z=0;z!=maxlen;++z) ofst[x+z]=t->co-1;
  else for(z=0;z!=maxlen-bestback;++z)
   ofst[x+z+bestback]=t->ary[maxaryy].loc-x;
  x+=maxlen;
  }
d1398 676
a2073 290
for(x=0;x!=t->co-1;++x)
 {
 int q=ofst[x];
 if(q && q!=t->co-1)
  if(q>0)
   {
   int z,fu;
   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
   while(s[x]==cs[x] && x<placex) ++x;
   dodelchr(t,x,y,q);
   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
   x=z-1;
   }
  else
   {
   int z,fu;
   for(z=x;z!=t->co-1 && ofst[z]==q;++z);
   while(s[x+q]==cs[x+q] && x-q<placex) ++x;
   doinschr(t,x+q,y,s+x+q,-q);
   for(fu=x;fu!=t->co-1;++fu) if(ofst[fu]!=t->co-1) ofst[fu]-=q;
   x=z-1;
   }
 }
}

static void doupscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sf || t->SF))
 {
 setregn(t,0,t->li);
 cpos(t,0,t->li-1);
 if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,t->li-1);
 else texec(t->cap,t->SF,a,a);
 goto done;
 }
if(bot==t->li && (t->dl || t->DL))
 {
 setregn(t,0,t->li);
 cpos(t,0,top);
 if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
 else texec(t->cap,t->DL,a,a);
 goto done;
 }
if(t->cs && ( t->sf || t->SF ))
 {
 setregn(t,top,bot);
 cpos(t,0,bot-1);
 if(amnt==1 && t->sf || !t->SF) while(a--) texec(t->cap,t->sf,1,bot-1);
 else texec(t->cap,t->SF,a,a);
 goto done;
 }
if((t->dl || t->DL) && (t->al || t->AL))
 {
 cpos(t,0,top);
 if(amnt==1 && t->dl || !t->DL) while(a--) texec(t->cap,t->dl,1,top);
 else texec(t->cap,t->DL,a,a);
 a=amnt;
 cpos(t,0,bot-amnt);
 if(amnt==1 && t->al || !t->AL) while(a--) texec(t->cap,t->al,1,bot-amnt);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
msetI(t->updtab+top,1,bot-top);
return;

done:
mfwrd(t->scrn+top*t->co,t->scrn+(top+amnt)*t->co,
      (bot-top-amnt)*t->co*sizeof(int));
if(bot==t->li && t->db)
 {
 msetI(t->scrn+(t->li-amnt)*t->co,-1,amnt*t->co);
 msetI(t->updtab+t->li-amnt,1,amnt);
 }
else msetI(t->scrn+(bot-amnt)*t->co,' ',amnt*t->co);
}

static void dodnscrl(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int a=amnt;
if(!amnt) return;
attr(t,0);
if(top==0 && bot==t->li && (t->sr || t->SR))
 {
 setregn(t,0,t->li);
 cpos(t,0,0);
 if(amnt==1 && t->sr || !t->SR)
  while(a--) texec(t->cap,t->sr,1,0);
 else texec(t->cap,t->SR,a,a);
 goto done;
 }
if(bot==t->li && (t->al || t->AL))
 {
 setregn(t,0,t->li);
 cpos(t,0,top);
 if(amnt==1 && t->al || !t->AL)
  while(a--) texec(t->cap,t->al,1,top);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
if(t->cs && (t->sr || t->SR))
 {
 setregn(t,top,bot);
 cpos(t,0,top);
 if(amnt==1 && t->sr || !t->SR)
  while(a--) texec(t->cap,t->sr,1,top);
 else texec(t->cap,t->SR,a,a);
 goto done;
 }
if((t->dl || t->DL) && (t->al || t->AL))
 {
 cpos(t,0,bot-amnt);
 if(amnt==1 && t->dl || !t->DL)
  while(a--) texec(t->cap,t->dl,1,bot-amnt);
 else texec(t->cap,t->DL,a,a);
 a=amnt;
 cpos(t,0,top);
 if(amnt==1 && t->al || !t->AL)
  while(a--) texec(t->cap,t->al,1,top);
 else texec(t->cap,t->AL,a,a);
 goto done;
 }
msetI(t->updtab+top,1,bot-top);
return;
done:
mbkwd(t->scrn+(top+amnt)*t->co,t->scrn+top*t->co,
      (bot-top-amnt)*t->co*sizeof(int));
if(!top && t->da)
 {
 msetI(t->scrn,-1,amnt*t->co);
 msetI(t->updtab,1,amnt);
 }
else msetI(t->scrn+t->co*top,' ',amnt*t->co);
}

void nscroll(t)
SCRN *t;
{
int y,z,q,r,p;
for(y=0;y!=t->li;++y)
 {
 q=t->sary[y];
 if(have) return;
 if(q && q!=t->li)
  if(q>0)
   {
   for(z=y;z!=t->li && t->sary[z]==q;++z) t->sary[z]=0;
   doupscrl(t,y,z+q,q), y=z-1;
   }
  else
   {
   for(r=y;r!=t->li && (t->sary[r]<0 || t->sary[r]==t->li);++r);
   p=r-1; do
    {
    q=t->sary[p];
    if(q && q!=t->li)
     {
     for(z=p;t->sary[z]=0, (z && t->sary[z-1]==q);--z);
     dodnscrl(t,z+q,p+1,-q);
     p=z+1;
     }
    }
    while(p--!=y);
   y=r-1;
   }
 }
msetI(t->sary,0,t->li);
}

void npartial(t)
SCRN *t;
 {
 attr(t,0);
 clrins(t);
 setregn(t,0,t->li);
 }

void nescape(t)
SCRN *t;
 {
 npartial(t);
 cpos(t,0,t->li-1);
 eraeol(t,0,t->li-1);
 if(t->te) texec(t->cap,t->te,1);
 }

void nreturn(t)
SCRN *t;
 {
 if(t->ti) texec(t->cap,t->ti,1);
 nredraw(t);
 }

void nclose(t)
SCRN *t;
{
int x;
leave=1;
attr(t,0);
clrins(t);
setregn(t,0,t->li);
cpos(t,0,t->li-1);
if(t->te) texec(t->cap,t->te,1);
ttclose();
rmcap(t->cap);
free(t->scrn);
free(t->sary);
free(t->ofst);
free(t->htab);
free(t->ary);
free(t);
}

void nscrldn(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
 {
 for(x=bot;x!=top+amnt;--x)
  t->sary[x-1]=(t->sary[x-amnt-1]==t->li?t->li:t->sary[x-amnt-1]-amnt),
  t->updtab[x-1]=t->updtab[x-amnt-1];
 for(x=top;x!=top+amnt;++x) t->updtab[x]=1;
 }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+top,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+top,1,amnt);
}

void nscrlup(t,top,bot,amnt)
SCRN *t;
int top,bot,amnt;
{
int x;
if(!amnt || top>=bot || bot>t->li) return;
if(amnt<bot-top && bot-top-amnt<amnt/2 || !t->scroll) amnt=bot-top;
if(amnt<bot-top)
 {
 for(x=top+amnt;x!=bot;++x)
  t->sary[x-amnt]=(t->sary[x]==t->li?t->li:t->sary[x]+amnt),
  t->updtab[x-amnt]=t->updtab[x];
 for(x=bot-amnt;x!=bot;++x) t->updtab[x]=1;
 }
if(amnt>bot-top) amnt=bot-top;
msetI(t->sary+bot-amnt,t->li,amnt);
if(amnt==bot-top) msetI(t->updtab+bot-amnt,1,amnt);
}

extern int dostaupd;

void nredraw(t)
SCRN *t;
{
dostaupd=1;
msetI(t->scrn,' ',t->co*skiptop);
msetI(t->scrn+skiptop*t->co,-1,(t->li-skiptop)*t->co);
msetI(t->sary,0,t->li);
msetI(t->updtab+skiptop,-1,t->li-skiptop);
t->x= -1;
t->y= -1;
t->top=t->li;
t->bot=0;
t->attrib= -1;
t->ins= -1;
attr(t,0);
clrins(t);
setregn(t,0,t->li);

if(!skiptop)
 if(t->cl)
  {
  texec(t->cap,t->cl,1,0);
  t->x=0; t->y=0;
  msetI(t->scrn,' ',t->li*t->co);
  }
 else if(t->cd)
  {
  cpos(t,0,0);
  texec(t->cap,t->cd,1,0);
  msetI(t->scrn,' ',t->li*t->co);
  }
@


1.1.201.1
log
@JOE's Own Editor 3.1
@
text
@@
