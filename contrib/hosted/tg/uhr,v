head	1.21;
access;
symbols
	mksh-50-1:1.14
	mksh-49-1:1.14
	mksh-46-2:1.14
	mksh-46-1:1.14
	mksh-45-1:1.14
	mksh-44-1:1.14
	mksh-43-1:1.14
	mksh-42b-1wtf70_1:1.11
	mksh-wtf-wheezy:1.11.0.2
	mksh-42b-1:1.11
	mksh-41_9_20130210-:1.11
	mksh-41_1-6:1.11
	mksh-41_1-5:1.11;
locks; strict;
comment	@# @;


1.21
date	2017.03.31.02.49.41;	author tg;	state Exp;
branches;
next	1.20;
commitid	10058DDC3D82C97E38B;

1.20
date	2017.03.31.00.04.18;	author tg;	state Exp;
branches;
next	1.19;
commitid	10058DD9D1757F7759A;

1.19
date	2017.03.27.12.33.14;	author tg;	state Exp;
branches;
next	1.18;
commitid	10058D9069F7A567CF5;

1.18
date	2017.03.17.22.53.07;	author tg;	state Exp;
branches;
next	1.17;
commitid	10058CC68E67F567440;

1.17
date	2015.11.29.21.34.06;	author tg;	state Exp;
branches;
next	1.16;
commitid	100565B6F5D35793AB2;

1.16
date	2015.11.29.21.27.25;	author tg;	state Exp;
branches;
next	1.15;
commitid	100565B6DCB09B850D6;

1.15
date	2014.08.21.20.08.21;	author tg;	state Exp;
branches;
next	1.14;
commitid	10053F651C761F983BF;

1.14
date	2013.02.19.18.07.46;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005123BF690EACE559;

1.13
date	2013.02.19.16.41.53;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005123AB69512D9D51;

1.12
date	2013.02.19.16.39.10;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005123AAC751C64563;

1.11
date	2012.11.30.21.22.52;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050B923C4079924A1;

1.10
date	2012.11.30.19.25.00;	author tg;	state Exp;
branches;
next	1.9;
commitid	10050B907135D4B5928;

1.9
date	2012.11.30.18.50.26;	author tg;	state Exp;
branches;
next	1.8;
commitid	10050B90002300893A2;

1.8
date	2012.11.26.23.09.20;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050B3F64C53033FF9;

1.7
date	2012.11.26.22.49.47;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050B3F2237B099269;

1.6
date	2012.11.26.19.19.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050B3C0B62B5428CD;

1.5
date	2012.05.28.00.30.00;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FC2C72035CA117D;

1.4
date	2012.05.28.00.24.01;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004FC2C55C664F53B5;

1.3
date	2012.05.28.00.12.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004FC2C31A3B35549B;

1.2
date	2012.05.28.00.08.34;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004FC2C21A7704DE0B;

1.1
date	2012.05.28.00.02.47;	author tg;	state Exp;
branches;
next	;
commitid	1004FC2C0BE7E53BD94;


desc
@@


1.21
log
@refactor to speed up and reduce visual flicker
@
text
@#!/bin/mksh
# $MirOS: contrib/hosted/tg/uhr,v 1.18 2017/03/17 22:53:07 tg Exp $
#-
# Copyright © 2012, 2013, 2015, 2017
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Analoguhr mit Digitalanzeige. Grundlegende Annahme: schnelles Ter‐
# minal, d.h. keine Voroptimierung der Darstellung durch das Skript;
# Font im Seitenverhältnis 1:2 (z.B. 9x18 aus XFree86® fixed-misc).

if [[ $KSH_VERSION != @@(\@@\(#\)MIRBSD KSH R)@@(4[1-9]|[5-9][0-9]|[1-9][0-9]+([0-9]))\ +([0-9])/+([0-9])/+([0-9])?(\ *) ]]; then
	print -u2 Uhr requires mksh R41 or newer.
	exit 1
fi
set -U
print '\r\e[K\rLoading…'

function graceful {
	print -n '\033[;H\033[J'
	exit 0
}
trap graceful INT TERM HUP

# Shell library for easy display of a progress bar, modified for Uhr
#
# Usage:
# – before:	init_progress_bar $n
# – $n times:	draw_progress_bar
# – after:	done_progress_bar
#
# init_progress_bar trashes the EXIT trap, done_progress_bar clears it.

# global variables used by this library
_cnt_progress_bar=0
_cur_progress_bar=0
isin_progress_bar=0
nlin_progress_bar=0

if [[ $KSH_VERSION = @@(\@@\(#\)MIRBSD KSH R)@@(5[5-9]|[6-9][0-9]|[1-9][0-9][0-9])\ * ]]; then
	alias global='typeset -g'
else
	alias global=global
fi

# args: $1 = number of draw_progress_bar calls to make up 100%
function init_progress_bar {
	global -i _cnt_progress_bar=$1 _cur_progress_bar=0
	global -i nlin_progress_bar=$LINES isin_progress_bar=1

	trap 'done_progress_bar 1' EXIT
	# set up scrolling region, draw initial empty bar
	sigwinch_uhr
	got_sigwinch=0
}

unalias global

function sigwinch_uhr {
	got_sigwinch=1
	(( isin_progress_bar )) || return 0

	# get new terminal size
	nlin_progress_bar=$LINES

	# save position; clear scrolling region; restore position; newline;
	# up one line (to ensure we are not in the last line); save position;
	# clear rest of screen; set new scrolling region; restore position
	print -nu2 "\\e7\\e[0;0r\\e8\\n\\e[A\\e7\\e[J\\e[1;$((# nlin_progress_bar - 1))r\\e8"

	# redraw progress bar
	draw_progress_bar_internal
}

function done_progress_bar {
	(( isin_progress_bar )) || return 0
	isin_progress_bar=0
	# save position; clear scrolling region; restore position;
	# save position; clear rest of screen; restore position
	print -nu2 "\\e7\\e[0;0r\\e8\\e7\\e[J\\e8"
	trap - EXIT
	[[ -n $1 ]] || (( _cur_progress_bar == _cnt_progress_bar )) || \
	    print -ru2 W: expected $_cnt_progress_bar draw_progress_bar calls, \
	    got only $_cur_progress_bar
}

function draw_progress_bar {
	# increment current progress
	if (( ++_cur_progress_bar > _cnt_progress_bar )); then
		print -ru2 "W: too many draw_progress_bar calls"
		_cur_progress_bar=$_cnt_progress_bar
	fi
	# remaining drawing code
	draw_progress_bar_internal
}

function draw_progress_bar_internal {
	local bar num w=$COLUMNS

	((# num = (_cur_progress_bar * w * 8) / _cnt_progress_bar ))
	while ((# num >= 8 )); do
		bar+=█
		((# num -= 8 ))
	done
	case $num {
	(7) bar+=▉ ;;
	(6) bar+=▊ ;;
	(5) bar+=▋ ;;
	(4) bar+=▌ ;;
	(3) bar+=▍ ;;
	(2) bar+=▎ ;;
	(1) bar+=▏ ;;
	}
	# fill complete line, right-align completion percentage display
	local -R$w spc="$((# _cur_progress_bar * 100 / _cnt_progress_bar))%"
	# elide percentage when it stops fitting
	((# (_cur_progress_bar * w / _cnt_progress_bar) > (w - 4) )) && spc=
	# save position; go to last line; set colours;
	# output a line full of spaces (and completion percentage);
	# jump to first column; output bar (line præfix); restore position
	print -nu2 -- "\\e7\\e[$nlin_progress_bar;1H\\e[0;1;33;44m$spc\\r$bar\\e8"
}

trap sigwinch_uhr WINCH

# stupid GNU idiots breaking everything by default… grml…
bcopt=
bc --help >/dev/null 2>&1 && bcopt=-q

integer F_NO=0x00 M_NO=0x1F
integer F_BG=0x01 M_BG=0x1E
integer F_CC=0x02 M_CC=0x1D
integer F_HP=0x04 M_HP=0x1B
integer F_MP=0x08 M_MP=0x17
integer F_SP=0x10 M_SP=0x0F
integer B_BG=0x01 B_BLK=0x02 B_NB=0x0C B_DOT=0x10

#	-	BLK	BG	NB	DOT	NB|DOT
set -A m2c \
	' '	'▀'	'*'	'▀'	'·'	'░'	\
	'▄'	'█'	'█'	'█'	'▆'	'█'	\
	'*'	'█'	'#'	'◘'	'⁂'	'◙'	\
	'▄'	'█'	'▆'	'█'	'▒'	'▓'	\
	'.'	'▛'	'☿'	'▛'	':'	'▒'	\
	'▄'	'█'	'◙'	'█'	'▆'	'▓'

set -A m2m
integer m2m

integer i=-1 j
while (( ++i <= 0x1F )); do
	(( m2m[i] = !i ? 0 : (i & B_BLK) ? 1 :
	    (i & B_NB) ? ((i & B_DOT) ? 5 : 3) : (i & B_DOT) ? 4 : 2 ))
done

function refresh {
	local -i10 i j k l=-2 q=0
	local t

	unset changed[$(((r / 2) * n + r))]
	for k in "${!changed[@@]}"; do
		(( i = m2m[fb[phys_v[k]]] ))
		(( j = m2m[fb[phys_v[k] + n]] ))
		(( phys_l[k] == l )) || t+=${phys_p[k]}
		(( l = k ))
		t+=${m2c[j * 6 + i]}
		(( ++q & 7 )) && continue
		print -nr -- "$t"
		t=
	done
	set -A changed
	print -n "$t\e[$((r / 2 + 1));$((r + 1))H\e[7mⓄ\e[0m\e[1;9H"
}

# put arrayname x y
function put {
	local _x=$(($2)) _y=$(($3)) _i
	nameref _px=$1

	(( _i = (r - _y) * n + _x + r ))
	_px+=($_i)
}

# retrace arrayname maskname colourname
function retrace {
	nameref _px=$1 _m=$2 _c=$3
	local _i _k _z _s

	for _i in "${_px[@@]}"; do
		(( fb[_i] = (fb[_i] & _m) | _c ))
		# map to physical coordinates
		if [[ -z ${phys_z[_i]} ]]; then
			(( phys_z[_i] = _z = (_i / n) / 2 ))
			(( phys_s[_i] = _s = _i % n ))
			(( phys_i[_i] = _z * n + _s ))
		fi
		_k=${phys_i[_i]}
		if [[ -z ${phys_v[_k]} ]]; then
			_z=${phys_z[_i]}
			_s=${phys_s[_i]}
			(( phys_v[_k] = _z * n * 2 + _s ))
			(( phys_l[_k] = (_s && _z) ? _k - 1 : -3 ))
			phys_p[_k]=$'\e['$((_z + 1))\;$((_s + 1))H
		fi
		changed[_k]= #set
	done
}

function draw_hour_marker {
	draw_progress_bar
	f=$1 e=$2 S=$3
	(( i = mkx[f] ))
	(( j = mky[f] & ~1 ))
	Y='0 1 2'
	if (( L > 26 )); then
		d='###########'
		S="${d::e+2} ${S::e}  ${S: e:e}  ${S:2*e} ${d::e+2}"
		(( e += 2 ))
		Y+=' 3 4'
		(( j += 2 ))
	fi
	(( i -= e / 2 ))
	k=0
	for y in $Y; do
		(( y = j - y * 2 + 1 + (r & 1) ))
		(( dy = y + 1 ))
		(( x = i - 1 ))
		while (( ++x < (i + e) )); do
			[[ ${S: k++:1} = ' ' ]] && continue
			put lb x y
			put lb x dy
		done
	done
}

function draw_hour_markers {
	set -A lb
	draw_hour_marker  0 7 '# # # # #  # ## # # #'
	draw_hour_marker  1 1 '###'
	draw_hour_marker  2 3 '# ## ## #'
	draw_hour_marker  3 5 '# # ## # ## # #'
	draw_hour_marker  4 5 '# # ## # ##  # '
	draw_hour_marker  5 3 '# ## # # '
	draw_hour_marker  6 5 '# # ## # # #  #'
	draw_hour_marker  7 7 '# # # ## # # # #  # #'
	draw_hour_marker  8 9 '# # # # ## # # # # #  # # #'
	draw_hour_marker  9 5 '# # ##  # # # #'
	draw_hour_marker 10 3 '# # # # #'
	draw_hour_marker 11 5 '# # # #  ## # #'
	retrace lb M_BG F_BG
}

# draw outer circle with Bresenham
function draw_outer_circle {
	draw_progress_bar
	set -A lc
	integer x=r y=-1 f=r dx dy
	while (( y < x )); do
		(( dy = y++ * 2 + 1 ))
		if (( y )); then
			(( f -= dy ))
			if (( f < 0 )); then
				(( dx = 1 - x-- * 2 ))
				(( f -= dx ))
			fi
		fi
		put lc x y
		put lc -x y
		put lc -x -y
		put lc x -y
		put lc y x
		put lc -y x
		put lc -y -x
		put lc y -x
	done
	retrace lc M_CC F_CC
}

function main_loop {
	typeset -Z6 tosleep

	set -A do -- -1 -1 -1
	dodate_get
	(( got_sigwinch )) && return
	dodate_draw
	while (( !got_sigwinch )); do
		(( tosleep = 1000000 - ${EPOCHREALTIME#*.} ))
		if (( tosleep > 999999 )); then
			sleep 0.2
			(( tosleep = 1000000 - ${EPOCHREALTIME#*.} ))
		fi
		if (( tosleep > 999999 )); then
			# huh… maybe no gettimeofday(2) here
			while :; do
				d=$(date +'%H %M %S,%d %b %Y')
				set -A dt $d
				(( dt[2] == do[2] )) || break
				sleep 0.1
			done
		else
			sleep 0.$tosleep
		fi
		dodate_get
		retrace lms$((do[2])) M_SP F_NO
		(( do[1] == dt[1] )) || retrace lms$((do[1])) M_MP F_NO
		(( do[0] == dt[0] )) || retrace lh$((do[0])) M_HP F_NO
		(( got_sigwinch )) || dodate_draw
	done
}

function dodate_get {
	d=$(date +'%H %M %S,%d %b %Y')
	S=${d#*,}
	d=${d%,*}
	print -n "\e[1;$((n - ${%S} + 1))H$S\e[1;1H${d// /:}"
	set -A dt $d
	(( dt[0] = (dt[0] % 12) * 5 + (dt[1] / 12) ))
}

function dodate_draw {
	(( do[0] == dt[0] )) || retrace lh$((dt[0])) M_HP F_HP
	(( do[1] == dt[1] )) || retrace lms$((dt[1])) M_MP F_MP
	retrace lms$((dt[2])) M_SP F_SP
	refresh
	set -A do -- "${dt[@@]}"
}

while :; do
	(( L = LINES >= (COLUMNS / 2) ? (COLUMNS / 2) : LINES ))
	init_progress_bar $((60 + 60 + (L > 21 ? (12 + 1 + 12) : 0) + 1 ))
	S='Pregenerating arrays, please wait...'
	if (( (r = (COLUMNS - ${%S}) / 2 - 2) > 0 )); then
		d=
		(( n = ${%S} + 2 ))
		while (( n-- )); do
			d+=─
		done
		S="\\e[$((LINES / 2 - 1));${r}H┌$d┐\\e[$((LINES / 2));${r}H│ $S │\\e[$((LINES / 2 + 1));${r}H└$d┘"
	fi
	print "\\e7\\e[0m$S\\e8"

	(( r = LINES * 2 ))
	(( r = (r > COLUMNS ? COLUMNS : r) / 2 - 1))
	(( n = 2 * r + 1 ))
	set -A fb
	integer fb
	set -A changed
	set -A phys_z
	set -A phys_s
	set -A phys_i
	set -A phys_v
	set -A phys_p
	# doch eine (minimale) Voroptimierung der Bildschirmausgabe
	set -A phys_l

	# precalculate all lines’ endpoints with bc and paths with Bresenham
	integer x y dx sx dy sy e f
	bc -l $bcopt |&
	print -p scale=8
	print -p r=$r
	print -p o=r
	print -p 'define p(t) {
		auto d
		d = 90 - t
		if (d < 0) d = 360 + d
		return (d * 3.1415926535897932 / 180)
	}'
	# minutes and seconds – full length, 60 items
	i=-1
	while (( ++i < 60 )); do
		draw_progress_bar
		eval set -A lms$i
		print -p "r * c(p($i * 6))"
		read -p S; [[ $S = ?(-).* ]] && S=0
		x=${S%%.*}
		print -p "r * s(p($i * 6))"
		read -p S; [[ $S = ?(-).* ]] && S=0
		y=${S%%.*}
		(( dx = x < 0 ? -x : x ))
		(( sx = x < 0 ? 1 : -1 ))
		(( dy = y < 0 ? y : -y ))
		(( sy = y < 0 ? 1 : -1 ))
		(( e = dx + dy ))
		while :; do
			put lms$i x y
			(( !x && !y )) && break
			(( f = 2 * e ))
			if (( f > dy )); then
				(( e += dy ))
				(( x += sx ))
			fi
			if (( f < dx )); then
				(( e += dx ))
				(( y += sy ))
			fi
		done
	done
	# hours – 2/3 length, 60 items (5 per hour)
	print -p 'r = o * 2 / 3'
	i=-1
	while (( ++i < 60 )); do
		draw_progress_bar
		eval set -A lh$i
		print -p "r * c(p($i * 6))"
		read -p S; [[ $S = ?(-).* ]] && S=0
		x=${S%%.*}
		print -p "r * s(p($i * 6))"
		read -p S; [[ $S = ?(-).* ]] && S=0
		y=${S%%.*}
		(( dx = x < 0 ? -x : x ))
		(( sx = x < 0 ? 1 : -1 ))
		(( dy = y < 0 ? y : -y ))
		(( sy = y < 0 ? 1 : -1 ))
		(( e = dx + dy ))
		while :; do
			put lh$i x y
			(( !x && !y )) && break
			(( f = 2 * e ))
			if (( f > dy )); then
				(( e += dy ))
				(( x += sx ))
			fi
			if (( f < dx )); then
				(( e += dx ))
				(( y += sy ))
			fi
		done
	done
	# hour markers – 80% length, 12 items
	if (( L > 21 )); then
		print -p 'r = o * 8 / 10'
		i=-1
		set -A mkx
		set -A mky
		while (( ++i < 12 )); do
			draw_progress_bar
			print -p "r * c(p($i * 30))"
			read -p S; [[ $S = ?(-).* ]] && S=0
			mkx[i]=${S%%.*}
			print -p "r * s(p($i * 30))"
			read -p S; [[ $S = ?(-).* ]] && S=0
			mky[i]=${S%%.*}
		done
		draw_progress_bar
		# fine-tuning of roman numeral position via screen size
		(( ++mkx[7] ))
		(( ++mkx[8] ))
		case $L {
		(22|23)	(( ++mkx[6] )) ;|
		(23)
			(( mky[1] += 2 ))
			(( mky[2] += 2 ))
			(( mky[10] += 2 ))
			(( mky[11] += 2 ))
			;;
		(24|25|29|30|31|34)
			(( mky[4] += 2 ))
			(( mky[8] += 2 ))
			;|
		(27|28|29)
			(( ++mkx[10] ))
			(( mky[8] += 2 ))
			(( mky[9] += 2 ))
			(( mky[10] += 2 ))
			;|
		(27|29|31)
			(( mky[0] -= 2 ))
			;|
		(27)
			(( --mkx[4] ))
			(( --mkx[5] ))
			(( ++mkx[6] ))
			(( mkx[7] += 2 ))
			(( ++mkx[8] ))
			(( ++mkx[10] ))
			;;
		(29)
			(( mky[5] += 2 ))
			(( mky[7] += 2 ))
			;;
		(30)
			(( mky[11] -= 2 ))
			;;
		}
		(( mky[0] += 2 * (L & 1) ))
	fi
	exec 3>&p; exec 3>&-

	draw_outer_circle
	(( L > 21 )) && draw_hour_markers
	done_progress_bar
	print -n -- '\e[H\e[J'
	refresh

	main_loop
done
@


1.20
log
@update from progress bar library
@
text
@d30 2
a31 1
typeset -Z6 tosleep
d33 5
a37 3
# stupid GNU idiots breaking everything by default… grml…
bcopt=
bc --help >/dev/null 2>&1 && bcopt=-q
d65 1
a65 1
	trap 'done_progress_bar' EXIT
d68 1
a94 1
	trap - WINCH
d96 3
d103 4
a106 1
	let ++_cur_progress_bar
a137 6
function graceful {
	print -n '\033[;H\033[J'
	exit 0
}
trap graceful INT TERM HUP

a138 1
while :; do
d140 3
a142 21
init_progress_bar 135
got_sigwinch=0
draw_progress_bar
S='Pregenerating arrays, please wait...'
if (( (r = (COLUMNS - ${%S}) / 2 - 2) < 1 )); then
	d="\\e[0m\\n$S"
else
	d=
	(( n = ${%S} + 2 ))
	while (( n-- )); do
		d+=─
	done
	d="\\e[0m\\e[$((LINES / 2 - 1));${r}H\\e7┌$d┐\\e8\\e[B│ $S │\\e8\\e[2B└$d┘"
fi
print "$d"

(( r = LINES * 2 ))
(( r = (r > COLUMNS ? COLUMNS : r) / 2 - 1))
(( n = 2 * r + 1 ))
set -A fb
integer fb
a151 1
set -U
d154 6
a159 7
	0x20	1#▀	1#*	1#▀	1#·	1#░	\
	1#▄	1#█	1#█	1#█	1#▆	1#█	\
	1#*	1#█	1##	1#◘	1#⁂	1#◙	\
	1#▄	1#█	1#▆	1#█	1#▒	1#▓	\
	1#.	1#▛	1#☿	1#▛	1#:	1#▒	\
	1#▄	1#█	1#◙	1#█	1#▆	1#▓
typeset -i1 m2c[*]
d171 1
a171 1
	local -i10 i j z s c
d174 10
a183 6
	for i in "$@@"; do
		(( z = (i / n) & 0xFFFE ))
		(( s = i % n ))
		(( i = m2m[fb[z * n + s]] ))
		(( j = m2m[fb[(z + 1) * n + s]] ))
		print -n "\e[$((z / 2 + 1));$((s + 1))H${m2c[j * 6 + i]#1#}"
d185 2
a186 1
	print -n "\e[$((r / 2 + 1));$((r + 1))H\e[7mⓄ\e[0m"
a198 1
set -A px
d201 1
a201 1
	local _i
d205 15
a220 1
	px+=("${_px[@@]}")
d223 1
a223 81
draw_progress_bar

# precalculate all lines’ endpoints with bc and paths with Bresenham
integer x y dx sx dy sy e f
bc -l $bcopt |&
print -p scale=20
print -p r=$r
print -p o=r
print -p 'define p(t) {
	auto d
	d = 90 - t
	if (d < 0) d = 360 + d
	return (d * 3.1415926535897932 / 180)
}'
# minutes and seconds – full length, 60 items
i=-1
while (( ++i < 60 )); do
	draw_progress_bar
	eval set -A lms$i
	print -p "r * c(p($i * 6))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	x=${S%%.*}
	print -p "r * s(p($i * 6))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	y=${S%%.*}
	(( dx = x < 0 ? -x : x ))
	(( sx = x < 0 ? 1 : -1 ))
	(( dy = y < 0 ? y : -y ))
	(( sy = y < 0 ? 1 : -1 ))
	(( e = dx + dy ))
	while :; do
		put lms$i x y
		(( !x && !y )) && break
		(( f = 2 * e ))
		if (( f > dy )); then
			(( e += dy ))
			(( x += sx ))
		fi
		if (( f < dx )); then
			(( e += dx ))
			(( y += sy ))
		fi
	done
done
# hours – 2/3 length, 60 items (5 per hour)
print -p 'r = o * 2 / 3'
i=-1
while (( ++i < 60 )); do
	draw_progress_bar
	eval set -A lh$i
	print -p "r * c(p($i * 6))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	x=${S%%.*}
	print -p "r * s(p($i * 6))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	y=${S%%.*}
	(( dx = x < 0 ? -x : x ))
	(( sx = x < 0 ? 1 : -1 ))
	(( dy = y < 0 ? y : -y ))
	(( sy = y < 0 ? 1 : -1 ))
	(( e = dx + dy ))
	while :; do
		put lh$i x y
		(( !x && !y )) && break
		(( f = 2 * e ))
		if (( f > dy )); then
			(( e += dy ))
			(( x += sx ))
		fi
		if (( f < dx )); then
			(( e += dx ))
			(( y += sy ))
		fi
	done
done
# hour markers – 80% length, 12 items
print -p 'r = o * 8 / 10'
i=-1
set -A mkx
set -A mky
while (( ++i < 12 )); do
d225 2
a226 64
	print -p "r * c(p($i * 30))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	mkx[i]=${S%%.*}
	print -p "r * s(p($i * 30))"
	read -p S; [[ $S = ?(-).* ]] && S=0
	mky[i]=${S%%.*}
done
exec 3>&p; exec 3>&-

draw_progress_bar
(( L = LINES >= (COLUMNS / 2) ? (COLUMNS / 2) : LINES ))
# fine-tuning of roman numeral position via screen size
(( ++mkx[7] ))
(( ++mkx[8] ))
case $L {
(22|23)	(( ++mkx[6] )) ;|
(23)
	(( mky[1] += 2 ))
	(( mky[2] += 2 ))
	(( mky[10] += 2 ))
	(( mky[11] += 2 ))
	;;
(24|25|29|30|31|34)
	(( mky[4] += 2 ))
	(( mky[8] += 2 ))
	;|
(27|28|29)
	(( ++mkx[10] ))
	(( mky[8] += 2 ))
	(( mky[9] += 2 ))
	(( mky[10] += 2 ))
	;|
(27|29|31)
	(( mky[0] -= 2 ))
	;|
(27)
	(( --mkx[4] ))
	(( --mkx[5] ))
	(( ++mkx[6] ))
	(( mkx[7] += 2 ))
	(( ++mkx[8] ))
	(( ++mkx[10] ))
	;;
(29)
	(( mky[5] += 2 ))
	(( mky[7] += 2 ))
	;;
(30)
	(( mky[11] -= 2 ))
	;;
}
(( mky[0] += 2 * (L & 1) ))
done_progress_bar

# clear framebuffer and screen
set -A fb
integer fb
print -n -- '\e[H\e[J'

# draw hour markers
set -A lb
integer e f=-1 k
(( L > 21 )) && while (( ++f < 12 )); do
	(( i=mkx[f] ))
a227 14
	case $f {
	(0) e=7 S='# # # # #  # ## # # #' ;;
	(1) e=1 S='###' ;;
	(2) e=3 S='# ## ## #' ;;
	(3) e=5 S='# # ## # ## # #' ;;
	(4) e=5 S='# # ## # ##  # ' ;;
	(5) e=3 S='# ## # # ' ;;
	(6) e=5 S='# # ## # # #  #' ;;
	(7) e=7 S='# # # ## # # # #  # #' ;;
	(8) e=9 S='# # # # ## # # # # #  # # #' ;;
	(9) e=5 S='# # ##  # # # #' ;;
	(10) e=3 S='# # # # #' ;;
	(11) e=5 S='# # # #  ## # #' ;;
	}
d248 18
a265 2
done
retrace lb M_BG F_BG
d268 12
a279 9
set -A lc
integer x=r y=-1 f=r dx dy
while (( y < x )); do
	(( dy = y++ * 2 + 1 ))
	if (( y )); then
		(( f -= dy ))
		if (( f < 0 )); then
			(( dx = 1 - x-- * 2 ))
			(( f -= dx ))
d281 14
a294 12
	fi
	put lc x y
	put lc -x y
	put lc -x -y
	put lc x -y
	put lc y x
	put lc -y x
	put lc -y -x
	put lc y -x
done
retrace lc M_CC F_CC
refresh "${px[@@]}"; set -A px
d296 5
a300 6
set -A do -- -1 -1 -1
isfirst=1
while (( !got_sigwinch )); do
	if (( isfirst )); then
		isfirst=0
	else
d317 7
a323 1
	fi
d325 1
d329 1
d331 2
d334 1
a334 6
	(( dt[0] = (dt[0] % 12) * 5 + (dt[1] / 12) ))
	if (( do[2] != -1 )); then
		retrace lms$((do[2])) M_SP F_NO
		(( do[1] == dt[1] )) || retrace lms$((do[1])) M_MP F_NO
		(( do[0] == dt[0] )) || retrace lh$((do[0])) M_HP F_NO
	fi
d338 1
a338 1
	refresh "${px[@@]}"; set -A px
d340 15
d356 154
a509 2
	print -n "\e[1;$((n - ${%S} + 1))H$S\e[1;1H${d// /:}"
done
@


1.19
log
@done_progress_bar shan’t output a newline; fix from ⮡ tarent
@
text
@d36 10
a45 1
# global variables used by progress bar
d51 6
d59 2
a60 2
	typeset -gi _cnt_progress_bar=$1 _cur_progress_bar=0
	typeset -gi nlin_progress_bar=$LINES isin_progress_bar=1
d63 2
a64 3
	# newline; up one line (to ensure we are not in the last line);
	# save position; set scrolling region; restore position
	print -n "\\n\\e[A\\e7\\e[1;$((# nlin_progress_bar - 1))r\\e8"
d67 2
d75 8
a82 3
	# newline; up one line (to ensure we are not in the last line);
	# save position; set scrolling region; restore position
	print -n "\\n\\e[A\\e7\\e[1;$((# nlin_progress_bar - 1))r\\e8"
a86 3
	# save position; clear scrolling region;
	# go to last line; delete line; restore position
	print -n "\\e7\\e[0;0r\\e[$nlin_progress_bar;0H\\e[M\\e8"
d88 4
d96 7
d105 1
a105 1
	((# num = (++_cur_progress_bar * w * 8) / _cnt_progress_bar ))
d126 1
a126 1
	print -n -- "\\e7\\e[$nlin_progress_bar;0H\\e[0;1;33;44m$spc\\r$bar\\e8"
a136 1
got_sigwinch=0
d139 1
@


1.18
log
@switch to “typeset -g”, requires mksh CVS HEAD
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.16 2015/11/29 21:27:25 tg Exp $
d68 1
a68 1
	print "\\e7\\e[0;0r\\e[$nlin_progress_bar;0H\\e[M\\e8"
@


1.17
log
@now with progress bar, just to fuck with XTaran’s mind ;-)
@
text
@d4 1
a4 1
# Copyright © 2012, 2013, 2015
d44 2
a45 2
	global -i _cnt_progress_bar=$1 _cur_progress_bar=0
	global -i nlin_progress_bar=$LINES isin_progress_bar=1
@


1.16
log
@beautification (part 1 of n): box the please-wait message
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.14 2013/02/19 18:07:46 tg Exp $
d36 64
d106 1
a106 1
trap got_sigwinch=1 WINCH
d110 2
d194 2
d211 1
d242 1
d275 1
d285 1
d328 1
@


1.15
log
@I have no idea where this came from, but it breaks the script
@
text
@d4 2
a5 2
# Copyright © 2012, 2013
#	Thorsten Glaser <tg@@mirbsd.org>
d46 13
a58 1
print "\e[0m\nPregenerating arrays, please wait..."
@


1.14
log
@bring back the bars above and below the roman numerals if the terminal is
big enough; position the numerals with some slight tweaking
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.11 2012/11/30 21:22:52 tg Exp $
d98 1
a98 1
	nameref _c=$4 _px=$1
@


1.13
log
@only close stdin, otherwise it gives different trouble…
@
text
@d23 2
a24 1
# minal, d.h. keine Voroptimierung der Darstellung durch Shellcode.
d202 43
d253 2
a254 2
(( LINES > 21 )) && while (( ++f < 12 )); do
	i=mkx[f]
d270 8
d280 1
a280 1
	for y in 0 1 2; do
@


1.12
log
@close bc(1) more properly to avoid errors on rapid-fire SIGWINCH
@
text
@a198 1
print -p quit
@


1.11
log
@be more flexible: mksh R12345 will come, eventually…
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.10 2012/11/30 19:25:00 tg Exp $
d4 1
a4 1
# Copyright © 2012
d200 1
@


1.10
log
@implement tty tracking and bump to R41 for feature completeness

• tty_fd is now never closed
• new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
• as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
• otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
• SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
• change the Uhr to match – it no longer calls stty(1) ☺
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.8 2012/11/26 23:09:20 tg Exp $
d25 1
a25 1
if [[ $KSH_VERSION != @@(\@@\(#\)MIRBSD KSH R)@@(4[1-9]|[5-9][0-9]|[1-9][0-9][0-9])\ +([0-9])/+([0-9])/+([0-9])?(\ *) ]]; then
@


1.9
log
@get rid of the immediate-pause, draw the first thing ASAP
@
text
@d25 2
a26 2
if [[ $EPOCHREALTIME != [1-9]+([0-9]).[0-9][0-9][0-9][0-9][0-9][0-9] ]]; then
	print -u2 Your mksh is too old.
a45 2
set -A dt -- $(stty size)
LINES=${dt[0]} COLUMNS=${dt[1]}
@


1.8
log
@• fix fixed-point calculating bug (0.123 ≠ 0.000123)
• install an interrupt handler for ^C, SIGHUP, SIGTERM to exit cleanly

XXX how about dealing with keyboard input?
XXX q, Q, ESC ⇒ exit; ^L ⇒ redraw
XXX though, how to distinguish timeout from error on read?
XXX also, read -t 0 doesn’t seem to DWIM
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.7 2012/11/26 22:49:47 tg Exp $
d268 1
d270 3
a272 3
	(( tosleep = 1000000 - ${EPOCHREALTIME#*.} ))
	if (( tosleep > 999999 )); then
		sleep 0.2
d274 15
a288 11
	fi
	if (( tosleep > 999999 )); then
		# huh… maybe no gettimeofday(2) here
		while :; do
			d=$(date +'%H %M %S,%d %b %Y')
			set -A dt $d
			(( dt[2] == do[2] )) || break
			sleep 0.1
		done
	else
		sleep 0.$tosleep
@


1.7
log
@use EPOCHREALTIME as variable, somewhat compatible with “zmodload zsh/datetime”, as ormaaj belatedly found out
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.6 2012/11/26 19:19:16 tg Exp $
d29 1
d35 6
@


1.6
log
@use MKSH_UNIXTIME to determine the exact amount of time to sleep,
instead of relying on spawning date(1) every 0.1 seconds…
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.5 2012/05/28 00:30:00 tg Exp $
d25 1
a25 1
if [[ $MKSH_UNIXTIME != [1-9]+([0-9]).[0-9][0-9][0-9][0-9][0-9][0-9] ]]; then
d262 1
a262 1
	(( tosleep = 1000000 - ${MKSH_UNIXTIME#*.} ))
d265 1
a265 1
		(( tosleep = 1000000 - ${MKSH_UNIXTIME#*.} ))
@


1.5
log
@add workaround allowing this to work with broken GNU bc(1)
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.4 2012/05/28 00:24:01 tg Exp $
d25 5
d262 17
a283 4
	if (( dt[2] == do[2] )); then
		sleep 0.1
		continue
	fi
@


1.4
log
@• restart upon receiving SIGWINCH
• switch to using $(stty size) since $COLUMNS and $LINES apparently
  aren’t updated by SIGWINCH for nōn-interactive shells (but keep
  assigning there, to get them minimum-bounded)
• display the background numbers only if the tty is large enough
  for them to be legible, sort of at least…
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.3 2012/05/28 00:12:51 tg Exp $
d25 4
d107 1
a107 1
bc -l |&
@


1.3
log
@fix for rendering background on odd-sized terminals (alignment of framebuffer with mathematical coordinate system on screen with low-right quadrant coordinate system was out of sync)
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.2 2012/05/28 00:08:34 tg Exp $
d25 4
d30 2
a31 1

d195 1
a195 1
while (( ++f < 12 )); do
d252 1
a252 1
while :; do
d276 1
@


1.2
log
@shrink background font, works better with 113x34 tty
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/uhr,v 1.1 2012/05/28 00:02:47 tg Exp $
d210 1
a210 1
		(( y = j - y * 2 + 2 ))
@


1.1
log
@Analoguhr, erste gut laufende Version
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $
d194 12
a205 12
	(0) e=9 S='######### # # # #   #  # #  # # # # #########' ;;
	(1) e=3 S='### #  #  # ###' ;;
	(2) e=5 S='##### # #  # #  # # #####' ;;
	(3) e=7 S='####### # # #  # # #  # # # #######' ;;
	(4) e=7 S='####### # # #  # # #  #  #  #######' ;;
	(5) e=5 S='##### # #  # #   #  #####' ;;
	(6) e=7 S='####### # # #  # # #   #  # #######' ;;
	(7) e=9 S='######### # # # #  # # # #   #  # # #########' ;;
	(8) e=11 S='########### # # # # #  # # # # #   #  # # # ###########' ;;
	(9) e=7 S='####### # # #  #  #   # # # #######' ;;
	(10) e=5 S='##### # #   #   # # #####' ;;
	(11) e=7 S='####### # # #   #  #  # # # #######' ;;
d209 2
a210 2
	for y in 0 1 2 3 4; do
		(( y = j - y * 2 + 4 ))
@

