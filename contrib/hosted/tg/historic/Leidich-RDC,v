head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2013.08.11.21.47.24;	author tg;	state Exp;
branches;
next	1.1;
commitid	1005208065D22390FA2;

1.1
date	2013.08.11.21.39.29;	author tg;	state Exp;
branches;
next	;
commitid	1005208045E443BF94B;


desc
@@


1.2
log
@MUCH more slow-running N=4096 version (N=65536 busy-spins blau@@450MHz)
a bit unideal because it throws away bits, but MUCH closer to 1-1/e ☺
@
text
@#!/bin/mksh
# ideal: 1-1/e ~= 0.6321205588
set +U
bc |&
print -p scale=10
print -p cum=0
print -p nrs=0
while :; do
	set -A bitfield
	read -a -N 8192 </dev/arandom
	integer i=-1
	while (( ++i < 4096 )); do
		(( bitfield[((REPLY[i*2] << 8) | REPLY[i*2+1]) & 4095]=1 ))
	done
	print -p "cur=${#bitfield[*]}/4096"
	print -p cur
	read -p cur
	print -p "cum+=cur"
	print -p "nrs+=1"
	print -p "cum/nrs"
	read -p tot
	print "${#bitfield[*]}	$cur	$tot"
	sleep 0.01
done
@


1.1
log
@reflexive density constant test for /dev/arandom, with fixed N=256
since that makes it easy to test here (though the result isn’t that
nice as we need N to approach ∞ really)
via http://jytter.blogspot.sg/2012/08/theory.html
@
text
@d2 1
d10 1
a10 1
	read -a -N 256 </dev/arandom
d12 2
a13 2
	while (( ++i < 256 )); do
		bitfield[${REPLY[i]}]=1
d15 1
a15 1
	print -p "cur=${#bitfield[*]}/256"
@

