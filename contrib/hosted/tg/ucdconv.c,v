head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2018.08.10.02.53.48;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005B6CFE0B5BDFE404;

1.16
date	2013.11.30.20.52.16;	author tg;	state Exp;
branches;
next	1.15;
commitid	100529A50137DD3D29E;

1.15
date	2010.12.11.21.05.48;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004D03E7BF4E815643;

1.14
date	2010.12.11.20.55.03;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004D03E5391E5FE18A;

1.13
date	2010.12.11.20.38.26;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004D03E1526CAA3745;

1.12
date	2008.11.30.13.34.15;	author tg;	state Exp;
branches;
next	1.11;
commitid	10049329667017978AF;

1.11
date	2008.11.30.13.08.48;	author tg;	state Exp;
branches;
next	1.10;
commitid	100493290663125FF1F;

1.10
date	2008.11.30.12.57.52;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049328DE562CCB545;

1.9
date	2008.11.30.12.35.59;	author tg;	state Exp;
branches;
next	1.8;
commitid	100493288BF3CCE126C;

1.8
date	2008.11.30.12.33.27;	author tg;	state Exp;
branches;
next	1.7;
commitid	100493288227112FF2B;

1.7
date	2008.11.30.12.23.47;	author tg;	state Exp;
branches;
next	1.6;
commitid	100493285E33F906864;

1.6
date	2008.11.30.12.17.44;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004932847B5F729271;

1.5
date	2008.11.30.12.14.11;	author tg;	state Exp;
branches;
next	1.4;
commitid	100493283900426FD70;

1.4
date	2008.11.30.12.11.35;	author tg;	state Exp;
branches;
next	1.3;
commitid	100493283035A7120CE;

1.3
date	2008.11.30.11.54.23;	author tg;	state Exp;
branches;
next	1.2;
commitid	10049327F0076A0A68F;

1.2
date	2008.11.30.11.52.45;	author tg;	state Exp;
branches;
next	1.1;
commitid	10049327E9E09D4F044;

1.1
date	2008.11.30.11.46.44;	author tg;	state Exp;
branches;
next	;
commitid	10049327D281F447D13;


desc
@@


1.17
log
@same as in commitid 1005B6CF36E3932B560, plus assorted cleanup
@
text
@#if 0

PROG=		ucdconv
NOMAN=		Yes

.include <bsd.prog.mk>

.if "0" == "1"
#endif

/* Copyright (C) 1999-2001 Free Software Foundation, Inc.
   Copyright (c) 2006-2010 The MirOS Project

   The GNU UTF-8 Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; version 2 of the Licence.

   The GNU UTF-8 Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU UTF-8 Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Generate tables for towlower, towupper, and the isw* functions. */

#define _ALL_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

static const char rcsid_generator[] =
  "$MirOS: contrib/hosted/tg/ucdconv.c,v 1.16 2013/11/30 20:52:16 tg Exp $";

static const char *ucdvsn;

struct unicode_attribute {
  const char* name;           /* Character name */
  const char* category;       /* General category */
  const char* combining;      /* Canonical combining classes */
  const char* bidi;           /* Bidirectional category */
  const char* decomposition;  /* Character decomposition */
  const char* decdigit;       /* Decimal digit value */
  const char* digit;          /* Digit value */
  const char* numeric;        /* Numeric value */
  int mirrored;               /* mirrored */
  const char* oldname;        /* Old Unicode 1.0 name */
  const char* comment;        /* Comment */
  unsigned int upper;         /* Upper case equivalent mapping */
  unsigned int lower;         /* Lower case equivalent mapping */
  unsigned int title;         /* Title case equivalent mapping */
};

#define NONE (~(unsigned int)0)

struct unicode_attribute unicode_attributes [0x10000];

static void fill_attribute (unsigned int i,
                            const char* field1, const char* field2,
                            const char* field3, const char* field4,
                            const char* field5, const char* field6,
                            const char* field7, const char* field8,
                            const char* field9, const char* field10,
                            const char* field11, const char* field12,
                            const char* field13, const char* field14)
{
  struct unicode_attribute * uni;

  if (i >= 0x10000) {
    fprintf(stderr, "index too large\n");
    exit(1);
  }
  if (strcmp(field2,"Cs") == 0)
    return;
  uni = &unicode_attributes[i];
  uni->name = strdup(field1);
  uni->category = (field2[0]=='\0' ? "" : strdup(field2));
  uni->combining = (field3[0]=='\0' ? "" : strdup(field3));
  uni->bidi = (field4[0]=='\0' ? "" : strdup(field4));
  uni->decomposition = (field5[0]=='\0' ? "" : strdup(field5));
  uni->decdigit = (field6[0]=='\0' ? "" : strdup(field6));
  uni->digit = (field7[0]=='\0' ? "" : strdup(field7));
  uni->numeric = (field8[0]=='\0' ? "" : strdup(field8));
  uni->mirrored = (field9[0]=='Y');
  uni->oldname = (field10[0]=='\0' ? "" : strdup(field10));
  uni->comment = (field11[0]=='\0' ? "" : strdup(field11));
  uni->upper = (field12[0]=='\0' ? NONE : strtoul(field12,NULL,16));
  uni->lower = (field13[0]=='\0' ? NONE : strtoul(field13,NULL,16));
  uni->title = (field14[0]=='\0' ? NONE : strtoul(field14,NULL,16));
}

static int getfield (FILE* f, char* buffer, int delim)
{
  int c;
  for (; (c = getc(f)), (c != EOF && c != delim); )
    *buffer++ = c;
  if (c == EOF) return 0;
  *buffer = '\0';
  return 1;
}

static void fill_attributes(void)
{
  unsigned int i, j;
  FILE* f;
  char field0 [100];
  char field1 [100];
  char field2 [100];
  char field3 [100];
  char field4 [100];
  char field5 [100];
  char field6 [100];
  char field7 [100];
  char field8 [100];
  char field9 [100];
  char field10 [100];
  char field11 [100];
  char field12 [100];
  char field13 [100];
  char field14 [100];
  int lineno = 0;
  size_t vsnlen;
  char vsn[30];

  vsn[0] = '\0';
  f = popen("sed -ne '2,$d' -e '1s/^# Blocks-\\([0-9]*\\.[0-9]*\\.[0-9]*\\)\\.txt$/\\1/p' <Blocks.txt", "r");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", "Blocks.txt");
    exit(1);
  }
  (void)fgets(vsn, sizeof(vsn), f);
  if (ferror(f)) {
    fprintf(stderr, "error during pipe I/O on Blocks.txt\n");
    exit(1);
  }
  vsnlen = strlen(vsn);
  if (vsnlen > 0 && vsn[vsnlen - 1] == '\n')
    vsn[--vsnlen] = '\0';
  pclose(f);

  if (!(ucdvsn = strdup(vsn))) {
    fprintf(stderr, "OOM\n");
    exit(1);
  }

  for (i = 0; i < 0x10000; i++)
    unicode_attributes[i].name = NULL;

#define unicodedata_filename "UnicodeData.txt"
  f = fopen(unicodedata_filename, "r");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", unicodedata_filename);
    exit(1);
  }
  for (;;) {
    int n;
    lineno++;
    n = getfield(f, field0, ';') + getfield(f, field1, ';')
        + getfield(f, field2, ';') + getfield(f, field3, ';')
        + getfield(f, field4, ';') + getfield(f, field5, ';')
        + getfield(f, field6, ';') + getfield(f, field7, ';')
        + getfield(f, field8, ';') + getfield(f, field9, ';')
        + getfield(f, field10, ';') + getfield(f, field11, ';')
        + getfield(f, field12, ';') + getfield(f, field13, ';')
        + getfield(f, field14, '\n');
    if (n == 0)
      break;
    if (n != 15) {
      fprintf(stderr, "short line in `%s':%d\n", unicodedata_filename, lineno);
      exit(1);
    }
    i = strtoul(field0,NULL,16);
    if (field1[0] == '<'
        && strlen(field1) >= 9
        && !strcmp(field1+strlen(field1)-8, ", First>")) {
      /* Deal with a range. */
      lineno++;
      n = getfield(f, field0, ';') + getfield(f, field1, ';')
          + getfield(f, field2, ';') + getfield(f, field3, ';')
          + getfield(f, field4, ';') + getfield(f, field5, ';')
          + getfield(f, field6, ';') + getfield(f, field7, ';')
          + getfield(f, field8, ';') + getfield(f, field9, ';')
          + getfield(f, field10, ';') + getfield(f, field11, ';')
          + getfield(f, field12, ';') + getfield(f, field13, ';')
          + getfield(f, field14, '\n');
      if (n != 15) {
        fprintf(stderr, "missing end range in `%s':%d\n", unicodedata_filename, lineno);
        exit(1);
      }
      if (!(field1[0] == '<'
            && strlen(field1) >= 8
            && !strcmp(field1+strlen(field1)-7, ", Last>"))) {
        fprintf(stderr, "missing end range in `%s':%d\n", unicodedata_filename, lineno);
        exit(1);
      }
      field1[strlen(field1)-7] = '\0';
      j = strtoul(field0,NULL,16);
      for (; i <= j; i++)
        fill_attribute(i, field1+1, field2, field3, field4, field5, field6,
                          field7, field8, field9, field10, field11, field12,
                          field13, field14);
    } else {
      /* Single character line */
      fill_attribute(i, field1, field2, field3, field4, field5, field6,
                        field7, field8, field9, field10, field11, field12,
                        field13, field14);
    }
  }
  if (ferror(f)) {
    fprintf(stderr, "error from ferror of `%s'\n", unicodedata_filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error during fclose of `%s'\n", unicodedata_filename);
    exit(1);
  }
}

static unsigned int uppercase (unsigned int ch)
{
  if (unicode_attributes[ch].name != NULL && unicode_attributes[ch].upper != NONE)
    return unicode_attributes[ch].upper;
  else
    return ch;
}

static unsigned int lowercase (unsigned int ch)
{
  if (unicode_attributes[ch].name != NULL && unicode_attributes[ch].lower != NONE)
    return unicode_attributes[ch].lower;
  else
    return ch;
}

static unsigned int titlecase (unsigned int ch)
{
  if (unicode_attributes[ch].name != NULL && unicode_attributes[ch].title != NONE)
    return unicode_attributes[ch].title;
  else
    return ch;
}

/* Create toupper.h, used by libutf8. */
static void output_toupper_table (void)
{
  int pages[0x100];
  int p, p1, p2, i1, i2;
  const char* filename = "tbl_towu.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  fprintf(f, "#include <wchar.h>\n\n#define mir18n_caseconv\n");
  fprintf(f, "#include \"mir18n.h\"\n\n__RCSID(\"$""MirOS""$\");\n");
  fprintf(f, "__RCSID(\"$""miros%s\");\n", rcsid_generator + 6);
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP)\");\n\n", ucdvsn);
  for (p = 0; p < 0x100; p++)
    pages[p] = 0;
  for (p = 0; p < 0x100; p++)
    for (i1 = 0; i1 < 0x100; i1++) {
      unsigned int ch = 0x100*p + i1;
      if (iswoctet(ch))
	continue;
      if (uppercase(ch) != ch) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x100; p++)
    if (pages[p]) {
      fprintf(f, "static const uint16_t toupper_table_page%02X[256] = {\n", p);
      for (i1 = 0; i1 < 32; i1++) {
        for (i2 = 0; i2 < 8; i2++) {
          unsigned int ch = 256*p + 8*i1 + i2;
          unsigned int ch2 = uppercase(ch);
          int j = ((int)ch2 - (int)ch) & 0xffff;
          fprintf(f, "%c0x%04X%s", i2==0?'\t':' ', j, (8*i1+i2<255?",":""));
        }
        fprintf(f, "\n");
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "const uint16_t * const toupper_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x80; p1++) {
    for (p2 = 0; p2 < 2; p2++) {
      p = 2*p1 + p2;
      if (pages[p])
        fprintf(f, "%ctoupper_table_page%02X%s", p2?' ':'\t', p, (p<0x100-1?",":""));
      else
        fprintf(f, "%cnop_page%s", p2?' ':'\t', (p<0x100-1?",":""));
    }
    fprintf(f, "\n");
  }
  fprintf(f, "};\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

static void output_totitle_table (void)
{
  int pages[0x100];
  int p, p1, p2, i1, i2;
  const char* filename = "tbl_towt.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  fprintf(f, "#include <wchar.h>\n\n#define mir18n_caseconv\n");
  fprintf(f, "#include \"mir18n.h\"\n\n__RCSID(\"$""MirOS""$\");\n");
  fprintf(f, "__RCSID(\"$""miros%s\");\n", rcsid_generator + 6);
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP)\");\n\n", ucdvsn);
  for (p = 0; p < 0x100; p++)
    pages[p] = 0;
  for (p = 0; p < 0x100; p++)
    for (i1 = 0; i1 < 0x100; i1++) {
      unsigned int ch = 0x100*p + i1;
      if (iswoctet(ch))
	continue;
      if (uppercase(ch) == ch && titlecase(ch) != ch) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x100; p++)
    if (pages[p]) {
      fprintf(f, "static const uint16_t totitle_table_page%02X[256] = {\n", p);
      for (i1 = 0; i1 < 32; i1++) {
        for (i2 = 0; i2 < 8; i2++) {
          unsigned int ch = 256*p + 8*i1 + i2;
          int j = 0;
	  if (uppercase(ch) == ch && titlecase(ch) != ch)
	    j = ((int)titlecase(ch) - (int)ch) & 0xFFFF;
          fprintf(f, "%c0x%04X%s", i2==0?'\t':' ', j, (8*i1+i2<255?",":""));
        }
        fprintf(f, "\n");
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "const uint16_t * const totitle_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x80; p1++) {
    for (p2 = 0; p2 < 2; p2++) {
      p = 2*p1 + p2;
      if (pages[p])
        fprintf(f, "%ctotitle_table_page%02X%s", p2?' ':'\t', p, (p<0x100-1?",":""));
      else
        fprintf(f, "%cnop_page%s", p2?' ':'\t', (p<0x100-1?",":""));
    }
    fprintf(f, "\n");
  }
  fprintf(f, "};\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

/* Create tolower.h, used by libutf8. */
static void output_tolower_table (void)
{
  int pages[0x100];
  int p, p1, p2, i1, i2;
  const char* filename = "tbl_towl.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  fprintf(f, "#include <wchar.h>\n\n#define mir18n_caseconv\n");
  fprintf(f, "#include \"mir18n.h\"\n\n__RCSID(\"$""MirOS""$\");\n");
  fprintf(f, "__RCSID(\"$""miros%s\");\n", rcsid_generator + 6);
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP)\");\n\n", ucdvsn);
  for (p = 0; p < 0x100; p++)
    pages[p] = 0;
  for (p = 0; p < 0x100; p++)
    for (i1 = 0; i1 < 0x100; i1++) {
      unsigned int ch = 0x100*p + i1;
      if (iswoctet(ch))
	continue;
      if (lowercase(ch) != ch) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x100; p++)
    if (pages[p]) {
      fprintf(f, "static const uint16_t tolower_table_page%02X[256] = {\n", p);
      for (i1 = 0; i1 < 32; i1++) {
        for (i2 = 0; i2 < 8; i2++) {
          unsigned int ch = 256*p + 8*i1 + i2;
          unsigned int ch2 = lowercase(ch);
          int j = ((int)ch2 - (int)ch) & 0xffff;
          fprintf(f, "%c0x%04X%s", i2?' ':'\t', j, (8*i1+i2<255?",":""));
        }
        fprintf(f, "\n");
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "const uint16_t * const tolower_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x80; p1++) {
    for (p2 = 0; p2 < 2; p2++) {
      p = 2*p1 + p2;
      if (pages[p])
        fprintf(f, "%ctolower_table_page%02X%s", p2?' ':'\t', p, (p<0x100-1?",":""));
      else
        fprintf(f, "%cnop_page%s", p2?' ':'\t', (p<0x100-1?",":""));
    }
    fprintf(f, "\n");
  }
  fprintf(f, "};\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

#define upper    1
#define lower    2
#define alpha    4
#define digit    8
#define xdigit  16
#define space   32
#define print   64
#define graph  128
#define blank  256
#define cntrl  512
#define punct 1024
#define alnum 2048

/* Create attribute.h, used by libutf8. */
static void output_attribute_table (void)
{
  int table[0x10000];
  int pages[0x100];
  int p, q, p1, p2, i;
  unsigned int ch;
  const char *filename = "tbl_att0.c";
  FILE* f = NULL;
  for (ch = 0; ch < 0x10000; ch++) {
    int attributes = 0;
    if (unicode_attributes[ch].category &&
     !strcmp(unicode_attributes[ch].category, "Lt"))
      attributes |= upper | lower;	/* title case */
    else if (lowercase(ch) != ch && uppercase(ch) == ch)
      attributes |= upper;
    else if (lowercase(ch) == ch && uppercase(ch) != ch)
      attributes |= lower;
    /* The OpenGroups's susv2/xbd/locale.html says only characters satisfying
       isupper() or islower() can have a nontrivial toupper() or tolower()
       mapping. */
    if ((attributes & (upper | lower)) == 0) {
      if (uppercase(ch) != ch)
        fprintf(stderr, "U%04x is not upper|lower but toupper(U%04x) = U%04x\n", ch, ch, uppercase(ch));
      if (lowercase(ch) != ch)
        fprintf(stderr, "U%04x is not upper|lower but tolower(U%04x) = U%04x\n", ch, ch, lowercase(ch));
    }
    if (unicode_attributes[ch].name != NULL
        && (unicode_attributes[ch].category[0] == 'L'
            || (attributes & (upper | lower)) != 0))
      attributes |= alpha;
    if ((((attributes & upper) != 0) || ((attributes & lower) != 0)) && ((attributes & alpha) == 0))
      fprintf(stderr, "U%04x is upper or lower but not alpha\n", ch);
#if 0
    if (unicode_attributes[ch].name != NULL
        && unicode_attributes[ch].category[0] == 'N'
        && unicode_attributes[ch].category[1] == 'd')
#else
    /* The OpenGroups's susv2/xbd/locale.html and Dinkumware's C lib reference
       say isdigit() may not return true for additional characters. */
    if (ch >= '0' && ch <= '9')
#endif
      attributes |= digit;
    if (((attributes & digit) != 0) && ((attributes & alpha) != 0))
      fprintf(stderr, "U%04x is both digit and alpha\n", ch);
    if (((attributes & digit) != 0) || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f'))
      attributes |= xdigit;
    if (ch == ' ' || ch == '\f' || ch == '\n' || ch == '\r' || ch == '\t' || ch == '\v')
      attributes |= space;
    /* Don't make U00A0 a space. Non-breaking space means that all programs
       should treat it like a punctuation character, not like a space. */
    if (unicode_attributes[ch].name != NULL
        && strcmp(unicode_attributes[ch].name, "<control>"))
      attributes |= print;
    if (((attributes & print) != 0) && ((attributes & space) == 0))
      attributes |= graph;
    if (ch == ' ' || ch == '\t')
      attributes |= blank;
    if (unicode_attributes[ch].name != NULL
        && !strcmp(unicode_attributes[ch].name, "<control>"))
      attributes |= cntrl;
    if (((attributes & graph) != 0)
        && ((attributes & alpha) == 0) && ((attributes & digit) == 0))
      /* This includes punctuation and symbols. */
      attributes |= punct;
    if (((attributes & alpha) != 0) || ((attributes & digit) != 0))
      attributes |= alnum;
    if (iswoctet(ch))
      attributes = 0;
    table[ch] = attributes;
  }
  for (p = 0; p < 0x100; p++) {
    pages[p] = -1;
    for (q = 0; q < p; q++)
      if (pages[q] < 0) {
        int same = 1;
        for (i = 0; i < 0x100; i++)
          if (table[0x100*p+i] != table[0x100*q+i]) {
            same = 0;
            break;
          }
        if (same) {
          pages[p] = q;
          break;
        }
      }
  }
  for (p = 0; p < 0x100; p++)
    if (pages[p] < 0) {
      if (p < 2) {
        if (f)
          fclose(f);
        if (!(f = fopen(filename, "w"))) {
          fprintf(stderr, "error during fopen of `%s'\n", filename);
          exit(1);
        }
        fprintf(f, "#include <wchar.h>\n\n#define mir18n_attributes\n");
        fprintf(f, "#include \"mir18n.h\"\n\n__RCSID(\"$""MirOS""$\");\n");
        fprintf(f, "__RCSID(\"$""miros%s\");\n", rcsid_generator + 6);
        fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP)\");\n\n", ucdvsn);
        filename = "tbl_attr.c";
      }
      if (p)
	fprintf(f, "static const unsigned char attribute_table_page%02X[256] = {\n", p);
      else
	fprintf(f, "const unsigned char __C_attribute_table_pg[256] = {\n");
      for (i = 0; i < 0x100; i++) {
        unsigned int ch_ = 256*p + i;
        int attributes = table[ch_];
        int next = 0;
        fprintf(f, "\t/* 0x%04X */ ", ch_);
        if (attributes & upper) {
          if (next) fprintf(f, " | ");
          fprintf(f, "upper");
          next = 1;
        }
        if (attributes & lower) {
          if (next) fprintf(f, " | ");
          fprintf(f, "lower");
          next = 1;
        }
        if (attributes & alpha) {
          if (next) fprintf(f, " | ");
          fprintf(f, "alpha");
          next = 1;
        }
        if (attributes & digit) {
          if (next) fprintf(f, " | ");
          fprintf(f, "digit");
          next = 1;
        }
        if (attributes & xdigit) {
          if (next) fprintf(f, " | ");
          fprintf(f, "xdigit");
          next = 1;
        }
        if (attributes & space) {
          if (next) fprintf(f, " | ");
          fprintf(f, "space");
          next = 1;
        }
        if (attributes & print) {
          if (next) fprintf(f, " | ");
          fprintf(f, "print");
          next = 1;
        }
        if (attributes & graph) {
          if (next) fprintf(f, " | ");
          fprintf(f, "graph");
          next = 1;
        }
        if (attributes & blank) {
          if (next) fprintf(f, " | ");
          fprintf(f, "blank");
          next = 1;
        }
        if (attributes & cntrl) {
          if (next) fprintf(f, " | ");
          fprintf(f, "cntrl");
          next = 1;
        }
        if (attributes & punct) {
          if (next) fprintf(f, " | ");
          fprintf(f, "punct");
          next = 1;
        }
        if (attributes & alnum) {
          if (next) fprintf(f, " | ");
          fprintf(f, "alnum");
          next = 1;
        }
        if (!next)
          fprintf(f, "0");
        if (i < 0xff)
          fprintf(f, ",");
        fprintf(f, "\n");
      }
      fprintf(f, "};\n");
      if (p)
        fprintf(f, "\n");
    }
  fprintf(f, "const unsigned char * const attribute_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x80; p1++) {
    for (p2 = 0; p2 < 2; p2++) {
      p = 2*p1 + p2;
      if (p)
	fprintf(f, "%cattribute_table_page%02X%s", p2 == 0 ? '\t' : ' ', (pages[p] >= 0 ? pages[p] : p),
                 (p<0x100-1?",":""));
      else
	fprintf(f, "\t__C_attribute_table_pg,");
    }
    fprintf(f, "\n");
  }
  fprintf(f, "};\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

int main (void)
{
  fill_attributes();

  output_toupper_table();
  output_totitle_table();
  output_tolower_table();
  output_attribute_table();

  return 0;
}

#if 0
.endif
#endif
@


1.16
log
@improve this tool’s output
@
text
@d37 1
a37 1
  "$MirOS: contrib/hosted/tg/ucdconv.c,v 1.15 2010/12/11 21:05:48 tg Exp $";
d261 1
a261 1
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP) %s\");\n\n", unicodedata_filename, ucdvsn);
d324 1
a324 1
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP) %s\");\n\n", unicodedata_filename, ucdvsn);
d389 1
a389 1
  fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP) %s\");\n\n", unicodedata_filename, ucdvsn);
d551 1
a551 1
        fprintf(f, "__IDSTRING(UCD_version, \"%s (BMP) %s\");\n\n", unicodedata_filename, ucdvsn);
@


1.15
log
@spacing
@
text
@d36 4
a39 1
__RCSID("$MirOS: contrib/hosted/tg/ucdconv.c,v 1.14 2010/12/11 20:55:03 tg Exp $");
d106 1
a106 1
static void fill_attributes (const char* unicodedata_filename)
d126 23
d153 1
d258 4
d321 4
d386 4
d548 4
d656 1
a656 1
int main (int argc, char* argv[])
d658 1
a658 4
  if (argc != 2)
    exit(1);

  fill_attributes(argv[1]);
@


1.14
log
@split att0 and attr tables
@
text
@d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/tg/ucdconv.c,v 1.13 2010/12/11 20:38:26 tg Exp $");
d587 2
a588 1
      fprintf(f, "\n");
@


1.13
log
@make __CRAZY=Yes clean and a Makefile
@
text
@d36 1
a36 1
__RCSID("$MirOS$");
d420 2
a421 6
  const char* filename = "tbl_attr.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
d502 9
@


1.12
log
@generate the titlecase conversion table
@
text
@d1 10
d12 1
a12 1
   Copyright (c) 2006-2008 The MirOS Project
d36 2
d221 1
a221 1
void output_toupper_table (void)
d280 1
a280 1
void output_totitle_table (void)
d341 1
a341 1
void output_tolower_table (void)
d414 1
a414 1
void output_attribute_table (void)
d511 2
a512 2
        unsigned int ch = 256*p + i;
        int attributes = table[ch];
d514 1
a514 1
        fprintf(f, "\t/* 0x%04X */ ", ch);
d621 4
@


1.11
log
@if upper|lower, then title

still waiting for answer from Bruno Haible, though...
@
text
@d268 60
d416 2
a417 1
    if (!strcmp(unicode_attributes[ch].category, "Lt"))
d603 1
@


1.10
log
@remove junk
@
text
@d356 3
a358 2
    if ((uppercase(ch) == ch || titlecase(uppercase(ch)) == ch)
        && lowercase(ch) != ch)
d360 1
a360 1
    if (lowercase(ch) == ch && uppercase(ch) != ch)
@


1.9
log
@beautify the caseconv tables as well
@
text
@a207 13
static int isCLbothcase (unsigned int ch)
{
  unsigned int ch1 = uppercase(ch);
  unsigned int ch2 = lowercase(ch);
  return ((ch1 == ch || ch2 == ch)
          && (ch1 != ch2)
          && uppercase(ch1) == ch1
          && uppercase(ch2) == ch1
          && lowercase(ch1) == ch2
          && lowercase(ch2) == ch2
         );
}

@


1.8
log
@create matching towu and towl (except the 1E9E mapping hack of course)
@
text
@d2 1
a2 1
   This file is part of the GNU UTF-8 Library.
d246 1
a246 1
      fprintf(f, "static const uint16_t toupper_table_page%02x[256] = {\n", p);
d252 1
a252 1
          fprintf(f, "%c0x%04x%s", i2==0?'\t':' ', j, (8*i1+i2<255?",":""));
d260 3
a262 3
  for (p1 = 0; p1 < 0x40; p1++) {
    for (p2 = 0; p2 < 4; p2++) {
      p = 4*p1 + p2;
d264 1
a264 1
        fprintf(f, "%ctoupper_table_page%02x%s", p2?' ':'\t', p, (p<0x100-1?",":""));
d306 1
a306 1
      fprintf(f, "static const uint16_t tolower_table_page%02x[256] = {\n", p);
d312 1
a312 1
          fprintf(f, "%c0x%04x%s", i2?' ':'\t', j, (8*i1+i2<255?",":""));
d320 3
a322 3
  for (p1 = 0; p1 < 0x40; p1++) {
    for (p2 = 0; p2 < 4; p2++) {
      p = 4*p1 + p2;
d324 1
a324 1
        fprintf(f, "%ctolower_table_page%02x%s", p2?' ':'\t', p, (p<0x100-1?",":""));
@


1.7
log
@use uppercase: tbl_att?.c
@
text
@d226 1
a226 1
  const char* filename = "toupper.h";
a231 4
  fprintf(f, "\n");
  fprintf(f, "/* toupper table */\n");
  fprintf(f, "/* Generated automatically by the gentables utility. */\n");
  fprintf(f, "\n");
d237 2
d246 1
a246 1
      fprintf(f, "static const short toupper_table_page%02x[256] = {\n", p);
a247 1
        fprintf(f, "  ");
d252 1
a252 1
          fprintf(f, "0x%04x%s ", j, (8*i1+i2<255?",":" "));
d254 1
a254 1
        fprintf(f, "/* 0x%02x-0x%02x */\n", 8*i1, 8*i1+7);
d259 1
a259 1
  fprintf(f, "const short * const toupper_table[0x100] = {\n");
a260 1
    fprintf(f, "  ");
d264 1
a264 1
        fprintf(f, "toupper_table_page%02x%s ", p, (p<0x100-1?",":" "));
d266 1
a266 1
        fprintf(f, "nop_page%s ", (p<0x100-1?",":" "));
d268 1
a268 1
    fprintf(f, "/* 0x%02x-0x%02x */\n", 4*p1, 4*p1+3);
a270 1
  fprintf(f, "\n");
d286 1
a286 1
  const char* filename = "tolower.h";
a291 4
  fprintf(f, "\n");
  fprintf(f, "/* tolower table */\n");
  fprintf(f, "/* Generated automatically by the gentables utility. */\n");
  fprintf(f, "\n");
d297 2
d306 1
a306 1
      fprintf(f, "static const short tolower_table_page%02x[256] = {\n", p);
a307 1
        fprintf(f, "  ");
d312 1
a312 1
          fprintf(f, "0x%04x%s ", j, (8*i1+i2<255?",":" "));
d314 1
a314 1
        fprintf(f, "/* 0x%02x-0x%02x */\n", 8*i1, 8*i1+7);
d319 1
a319 1
  fprintf(f, "const short * const tolower_table[0x100] = {\n");
a320 1
    fprintf(f, "  ");
d324 1
a324 1
        fprintf(f, "tolower_table_page%02x%s ", p, (p<0x100-1?",":" "));
d326 1
a326 1
        fprintf(f, "nop_page%s ", (p<0x100-1?",":" "));
d328 1
a328 1
    fprintf(f, "/* 0x%02x-0x%02x */\n", 4*p1, 4*p1+3);
a330 1
  fprintf(f, "\n");
@


1.6
log
@fix segfaults
@
text
@d456 1
a456 1
	fprintf(f, "static const unsigned char attribute_table_page%02x[256] = {\n", p);
d463 1
a463 1
        fprintf(f, "\t/* 0x%04x */ ", ch);
d538 1
a538 1
	fprintf(f, "%cattribute_table_page%02x%s", p2 == 0 ? '\t' : ' ', (pages[p] >= 0 ? pages[p] : p),
@


1.5
log
@match current tbl_att?.c from libc exactly, sans 00DF/1E9E (eszett):
handle OPTU-16 woctet range specially
@
text
@d263 1
a263 1
  for (p1 = 0; p1 < 0x440; p1++) {
d328 1
a328 1
  for (p1 = 0; p1 < 0x440; p1++) {
@


1.4
log
@create tbl_attr.c in a format I somewhat like
@
text
@d20 1
d24 1
d433 2
@


1.3
log
@limit this to generation of what we need
@
text
@a252 4
          if (ch2 != ch + (short)j) {
            fprintf(stderr, "toupper maps 0x%04x to different plane\n", ch);
            exit(1);
          }
a317 4
          if (ch2 != ch + (short)j) {
            fprintf(stderr, "tolower maps 0x%04x to different plane\n", ch);
            exit(1);
          }
d369 1
a369 1
  const char* filename = "attribute.h";
a374 4
  fprintf(f, "\n");
  fprintf(f, "/* attribute table */\n");
  fprintf(f, "/* Generated automatically by the gentables utility. */\n");
  fprintf(f, "\n");
d451 4
a454 1
      fprintf(f, "static const unsigned char attribute_table_page%02x[256] = {\n", p);
d459 1
a459 1
        fprintf(f, "  /* 0x%04x */ ", ch);
a530 1
    fprintf(f, "  ");
d533 5
a537 2
      fprintf(f, "attribute_table_page%02x%s ", (pages[p] >= 0 ? pages[p] : p),
                 (p<0x100-1?",":" "));
d539 1
a539 1
    fprintf(f, "/* 0x%02x-0x%02x */\n", 2*p1, 2*p1+1);
a541 1
  fprintf(f, "\n");
@


1.2
log
@limit to the BMP
@
text
@a218 165
/* Create uni_upcase.c, used by clisp. */
void output_clisp_upcase_table (void)
{
  int pages[0x100];
  int p, p1, p2, i1, i2;
  const char* filename = "uni_upcase.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  fprintf(f, "/*\n");
  fprintf(f, " * %s\n", filename);
  fprintf(f, " *\n");
  fprintf(f, " * Common Lisp upcase table.\n");
  fprintf(f, " * Generated automatically by the gentables utility.\n");
  fprintf(f, " */\n");
  fprintf(f, "\n");
  for (p = 0; p < 0x100; p++)
    pages[p] = 0;
  for (p = 0; p < 0x100; p++)
    for (i1 = 0; i1 < 0x100; i1++) {
      unsigned int ch = 0x100*p + i1;
      if (isCLbothcase(ch) && (uppercase(ch) != ch)) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x100; p++)
    if (pages[p]) {
      fprintf(f, "static const cint up_case_table_page%02x[256] = {\n", p);
      for (i1 = 0; i1 < 32; i1++) {
        fprintf(f, "  ");
        for (i2 = 0; i2 < 8; i2++) {
          unsigned int ch = 256*p + 8*i1 + i2;
          unsigned int ch2 = (isCLbothcase(ch) ? uppercase(ch) : ch);
          int j = ((int)ch2 - (int)ch) & 0xffff;
          if (ch2 != ch + (short)j) {
            fprintf(stderr, "upper case maps 0x%04x to different plane\n", ch);
            exit(1);
          }
          fprintf(f, "0x%04x%s ", j, (8*i1+i2<255?",":" "));
        }
        fprintf(f, "/* 0x%02x-0x%02x */\n", 8*i1, 8*i1+7);
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "static const cint * const up_case_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x440; p1++) {
    fprintf(f, "  ");
    for (p2 = 0; p2 < 4; p2++) {
      p = 4*p1 + p2;
      if (pages[p])
        fprintf(f, "up_case_table_page%02x%s ", p, (p<0x100-1?",":" "));
      else
        fprintf(f, "nop_page%s ", (p<0x100-1?",":" "));
    }
    fprintf(f, "/* 0x%02x-0x%02x */\n", 4*p1, 4*p1+3);
  }
  fprintf(f, "};\n");
  fprintf(f, "\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

/* Create uni_downcase.c, used by clisp. */
void output_clisp_downcase_table (void)
{
  int pages[0x100];
  int p, p1, p2, i1, i2;
  const char* filename = "uni_downcase.c";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  fprintf(f, "/*\n");
  fprintf(f, " * %s\n", filename);
  fprintf(f, " *\n");
  fprintf(f, " * Common Lisp downcase table.\n");
  fprintf(f, " * Generated automatically by the gentables utility.\n");
  fprintf(f, " */\n");
  fprintf(f, "\n");
  for (p = 0; p < 0x100; p++)
    pages[p] = 0;
  for (p = 0; p < 0x100; p++)
    for (i1 = 0; i1 < 0x100; i1++) {
      unsigned int ch = 0x100*p + i1;
      if (isCLbothcase(ch) && (lowercase(ch) != ch)) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x100; p++)
    if (pages[p]) {
      fprintf(f, "static const cint down_case_table_page%02x[256] = {\n", p);
      for (i1 = 0; i1 < 32; i1++) {
        fprintf(f, "  ");
        for (i2 = 0; i2 < 8; i2++) {
          unsigned int ch = 256*p + 8*i1 + i2;
          unsigned int ch2 = (isCLbothcase(ch) ? lowercase(ch) : ch);
          int j = ((int)ch2 - (int)ch) & 0xffff;
          if (ch2 != ch + (short)j) {
            fprintf(stderr, "lower case maps 0x%04x to different plane\n", ch);
            exit(1);
          }
          fprintf(f, "0x%04x%s ", j, (8*i1+i2<255?",":" "));
        }
        fprintf(f, "/* 0x%02x-0x%02x */\n", 8*i1, 8*i1+7);
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "static const cint * const down_case_table[0x100] = {\n");
  for (p1 = 0; p1 < 0x440; p1++) {
    fprintf(f, "  ");
    for (p2 = 0; p2 < 4; p2++) {
      p = 4*p1 + p2;
      if (pages[p])
        fprintf(f, "down_case_table_page%02x%s ", p, (p<0x100-1?",":" "));
      else
        fprintf(f, "nop_page%s ", (p<0x100-1?",":" "));
    }
    fprintf(f, "/* 0x%02x-0x%02x */\n", 4*p1, 4*p1+3);
  }
  fprintf(f, "};\n");
  fprintf(f, "\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

static void output_copyright (FILE* f)
{
  fprintf(f, "/* Copyright (C) 1999-2001 Free Software Foundation, Inc.\n");
  fprintf(f, "   This file is part of the GNU UTF-8 Library.\n");
  fprintf(f, "\n");
  fprintf(f, "   The GNU UTF-8 Library is free software; you can redistribute it and/or\n");
  fprintf(f, "   modify it under the terms of the GNU Library General Public License as\n");
  fprintf(f, "   published by the Free Software Foundation; either version 2 of the\n");
  fprintf(f, "   License, or (at your option) any later version.\n");
  fprintf(f, "\n");
  fprintf(f, "   The GNU UTF-8 Library is distributed in the hope that it will be useful,\n");
  fprintf(f, "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n");
  fprintf(f, "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n");
  fprintf(f, "   Library General Public License for more details.\n");
  fprintf(f, "\n");
  fprintf(f, "   You should have received a copy of the GNU Library General Public\n");
  fprintf(f, "   License along with the GNU UTF-8 Library; see the file COPYING.LIB.  If not,\n");
  fprintf(f, "   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n");
  fprintf(f, "   Boston, MA 02111-1307, USA.  */\n");
}

a229 1
  output_copyright(f);
a298 1
  output_copyright(f);
a382 1
  output_copyright(f);
a559 91
static int nonspacing (unsigned int ch)
{
  /* We use the "Non-spacing" property in PropList.txt here, because the
     SUSV2 spec (curses section) talks about "non-spacing wide characters". */
#if 0
  /* This code catches only a subset of the combining characters! */
  const char* combining = unicode_attributes[ch].combining;
  if (combining != NULL && strcmp(combining,"") && strcmp(combining,"0"))
    return 1;
#else
  if (unicode_attributes[ch].bidi != NULL && !strcmp(unicode_attributes[ch].bidi,"NSM"))
    return 1;
#endif
  /* Format control characters have width 0 as well. */
  if (unicode_attributes[ch].bidi != NULL && !strcmp(unicode_attributes[ch].category,"Cf"))
    return 1;
  /* Zero width characters have width 0 as well. */
  if (unicode_attributes[ch].name != NULL && !strncmp(unicode_attributes[ch].name,"ZERO WIDTH ",11))
    return 1;
  return 0;
}

/* Create nonspacing.h, used by libutf8. */
void output_nonspacing_table (void)
{
  int pages[0x440];
  int p, p1, p2, i1, i2, i3;
  const char* filename = "nonspacing.h";
  FILE* f = fopen(filename, "w");
  if (!f) {
    fprintf(stderr, "error during fopen of `%s'\n", filename);
    exit(1);
  }
  output_copyright(f);
  fprintf(f, "\n");
  fprintf(f, "/* Non-spacing attribute table */\n");
  fprintf(f, "/* Generated automatically by the gentables utility. */\n");
  fprintf(f, "\n");
  for (p = 0; p < 0x440; p++)
    pages[p] = 0;
  for (p = 0; p < 0x440; p++)
    for (i1 = 0; i1 < 0x400; i1++) {
      unsigned int ch = 0x400*p + i1;
      if (nonspacing(ch)) {
        pages[p] = 1;
        break;
      }
    }
  for (p = 0; p < 0x440; p++)
    if (pages[p]) {
      fprintf(f, "static const unsigned char nonspacing_table_page%02x[128] = {\n", 4*p);
      for (i1 = 0; i1 < 16; i1++) {
        fprintf(f, "  ");
        for (i2 = 0; i2 < 8; i2++) {
          unsigned char w = 0;
          for (i3 = 0; i3 < 8; i3++) {
            unsigned int ch = 0x400*p + 64*i1 + 8*i2 + i3;
            if (nonspacing(ch))
              w |= (1 << i3);
          }
          fprintf(f, "0x%02x%s ", w, (8*i1+i2<127?",":" "));
        }
        fprintf(f, "/* 0x%04x-0x%04x */\n", 0x400*p+64*i1, 0x400*p+64*i1+63);
      }
      fprintf(f, "};\n");
      fprintf(f, "\n");
    }
  fprintf(f, "static const unsigned char * const nonspacing_table[0x440] = {\n");
  for (p1 = 0; p1 < 0x10; p1++) {
    fprintf(f, "  ");
    for (p2 = 0; p2 < 4; p2++) {
      p = 4*p1 + p2;
      if (pages[p])
        fprintf(f, "nonspacing_table_page%02x%s ", 4*p, (p<0x440-1?",":" "));
      else
        fprintf(f, "NULL%s ", (p<0x440-1?",":" "));
    }
    fprintf(f, "/* 0x%04x-0x%04x */\n", 0x1000*p1, 0x1000*p1+0xfff);
  }
  fprintf(f, "};\n");
  fprintf(f, "\n");
  if (ferror(f)) {
    fprintf(stderr, "error writing on `%s'\n", filename);
    exit(1);
  }
  if (fclose(f)) {
    fprintf(stderr, "error closing `%s'\n", filename);
    exit(1);
  }
}

a566 4
#if 0
  output_clisp_upcase_table();
  output_clisp_downcase_table();
#endif
a569 1
  output_nonspacing_table();
@


1.1
log
@gentables.c from Bruno Haible's libutf8 0.8 (GPL)
@
text
@d6 1
a6 2
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.
d43 1
a43 1
struct unicode_attribute unicode_attributes [0x110000];
d56 1
a56 1
  if (i >= 0x110000) {
d110 1
a110 1
  for (i = 0; i < 0x110000; i++)
d222 1
a222 1
  int pages[0x1100];
d237 1
a237 1
  for (p = 0; p < 0x1100; p++)
d239 1
a239 1
  for (p = 0; p < 0x1100; p++)
d247 1
a247 1
  for (p = 0; p < 0x1100; p++)
d267 1
a267 1
  fprintf(f, "static const cint * const up_case_table[0x1100] = {\n");
d273 1
a273 1
        fprintf(f, "up_case_table_page%02x%s ", p, (p<0x1100-1?",":" "));
d275 1
a275 1
        fprintf(f, "nop_page%s ", (p<0x1100-1?",":" "));
d294 1
a294 1
  int pages[0x1100];
d309 1
a309 1
  for (p = 0; p < 0x1100; p++)
d311 1
a311 1
  for (p = 0; p < 0x1100; p++)
d319 1
a319 1
  for (p = 0; p < 0x1100; p++)
d339 1
a339 1
  fprintf(f, "static const cint * const down_case_table[0x1100] = {\n");
d345 1
a345 1
        fprintf(f, "down_case_table_page%02x%s ", p, (p<0x1100-1?",":" "));
d347 1
a347 1
        fprintf(f, "nop_page%s ", (p<0x1100-1?",":" "));
d387 1
a387 1
  int pages[0x1100];
d400 1
a400 1
  for (p = 0; p < 0x1100; p++)
d402 1
a402 1
  for (p = 0; p < 0x1100; p++)
d410 1
a410 1
  for (p = 0; p < 0x1100; p++)
d430 1
a430 1
  fprintf(f, "const short * const toupper_table[0x1100] = {\n");
d436 1
a436 1
        fprintf(f, "toupper_table_page%02x%s ", p, (p<0x1100-1?",":" "));
d438 1
a438 1
        fprintf(f, "nop_page%s ", (p<0x1100-1?",":" "));
d457 1
a457 1
  int pages[0x1100];
d470 1
a470 1
  for (p = 0; p < 0x1100; p++)
d472 1
a472 1
  for (p = 0; p < 0x1100; p++)
d480 1
a480 1
  for (p = 0; p < 0x1100; p++)
d500 1
a500 1
  fprintf(f, "const short * const tolower_table[0x1100] = {\n");
d506 1
a506 1
        fprintf(f, "tolower_table_page%02x%s ", p, (p<0x1100-1?",":" "));
d508 1
a508 1
        fprintf(f, "nop_page%s ", (p<0x1100-1?",":" "));
d540 2
a541 2
  int table[0x110000];
  int pages[0x1100];
d555 1
a555 1
  for (ch = 0; ch < 0x110000; ch++) {
d613 1
a613 1
  for (p = 0; p < 0x1100; p++) {
d629 1
a629 1
  for (p = 0; p < 0x1100; p++)
d706 2
a707 2
  fprintf(f, "const unsigned char * const attribute_table[0x1100] = {\n");
  for (p1 = 0; p1 < 0x880; p1++) {
d712 1
a712 1
                 (p<0x1100-1?",":" "));
d796 1
a796 1
  for (p1 = 0; p1 < 0x110; p1++) {
@

