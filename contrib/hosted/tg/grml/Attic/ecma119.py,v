head	1.6;
access;
symbols;
locks; strict;
comment	@# @;


1.6
date	2017.04.20.03.46.31;	author tg;	state dead;
branches;
next	1.5;
commitid	10058F82F2A63AB9E8E;

1.5
date	2010.10.17.20.48.08;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004CBB6064768FD217;

1.4
date	2010.10.16.22.39.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004CBA29BF7C5D6F7B;

1.3
date	2010.10.16.22.35.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004CBA28B0403E4BF6;

1.2
date	2010.10.16.22.30.50;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004CBA27AA556095EE;

1.1
date	2010.10.16.22.28.22;	author tg;	state Exp;
branches;
next	;
commitid	1004CBA270F3016160B;


desc
@@


1.6
log
@nuke Python junk nobody uses
@
text
@#!/usr/bin/env python
# coding: utf-8
# $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.5 2010/10/17 20:48:08 tg Exp $
#-
# Copyright © 2010
#	Thorsten Glaser <tg@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.

__version__ = """
    $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.5 2010/10/17 20:48:08 tg Exp $
"""

from structid import *

__all__ = [
    "ECMA119_Date",         # §8.4.26.1 Date types
    "ECMA119_Integral",     # Integral single-endian types
    "ECMA119_BB_Integral",  # Integral both-endian types
    "ECMA119_StructId",     # Abstract base class as StructId
]


class ECMA119_Date_Container(StructId_Container):
    def __str__(self):
        u"""Stringify an ECMA119_Date.

        Return value formatted as ISO 8601 combined date/time/zone string.

        """
        return '%04u-%02u-%02uT%02u:%02u:%02u.%02u%s%02u:%02u' % ( \
          self.year, self.month, self.day, self.hour, self.minute, \
          self.second, self.centi, self.offset < 0 and '-' or '+', \
          abs(self.offset) // 4, (abs(self.offset) % 4) * 15)


class ECMA119_Date(StructId_Type):
    u"""Type class for ECMA 119 §8.4.25.1 Date types.

    Maps into an attribute dictionary with the following slots:
    • year      [1; 9999]
    • month     [1; 12]
    • day       [1; 31]
    • hour      [0; 23]
    • minute    [0; 59]
    • second    [0; 59]
    • centi     [0; 99]     Hundredths of a second
    • offset    [-48; 52]   Offset from GMT by 15 minutes

    If all slots are zero, “the time and date are not specified.”

    """

    def get_fmt(self):
        u"""Return struct.unpack format specification."""
        return '4s2s2s2s2s2s2sb'

    def num_items(self):
        u"""Return how many items in the tuple this type uses."""
        return 8

    def do_import(self, t):
        u"""Convert from unpack tuple to internal representation."""
        rv = ECMA119_Date_Container()
        rv.year = 0
        rv.month = 0
        rv.day = 0
        rv.hour = 0
        rv.minute = 0
        rv.second = 0
        rv.centi = 0
        rv.offset = 0
        if t is not None:
            if t[0] != '\0\0\0\0':
                rv.year = int(t[0])
            if t[1] != '\0\0':
                rv.month = int(t[1])
            if t[2] != '\0\0':
                rv.day = int(t[2])
            if t[3] != '\0\0':
                rv.hour = int(t[3])
            if t[4] != '\0\0':
                rv.minute = int(t[4])
            if t[5] != '\0\0':
                rv.second = int(t[5])
            if t[6] != '\0\0':
                rv.centi = int(t[6])
            rv.offset = t[7]
        return rv

    def do_export(self, v):
        u"""Convert from internal representation to pack tuple."""
        if v.year == 0 and v.month == 0 and v.day == 0 and \
          v.hour == 0 and v.minute == 0 and v.second == 0 and \
          v.centi == 0 and v.offset == 0:
            # the time and date are not specified.
            pass
        elif v.year < 1 or v.year > 9999:
            raise ValueError('year %d out of range [1; 9999]' % v.year)
        elif v.month < 1 or v.month > 12:
            raise ValueError('month %d out of range [1; 12]' % v.month)
        elif v.day < 1 or v.day > 31:
            raise ValueError('day %d out of range [1; 31]' % v.day)
        elif v.hour < 0 or v.hour > 23:
            raise ValueError('hour %d out of range [0; 23]' % v.hour)
        elif v.minute < 0 or v.minute > 59:
            raise ValueError('minute %d out of range [0; 59]' % v.minute)
        elif v.second < 0 or v.second > 59:
            raise ValueError('second %d out of range [0; 59]' % v.second)
        elif v.centi < 0 or v.centi > 99:
            raise ValueError('centi %d out of range [0; 99]' % v.centi)
        elif v.offset < -48 or v.offset > 52:
            raise ValueError('offset %d out of range [-48; 52]' % v.offset)
        return tuple(('%04u' % v.year, '%02u' % v.month, '%02u' % v.day, \
          '%02u' % v.hour, '%02u' % v.minute, '%02u' % v.second, \
          '%02u' % v.centi, v.offset))


class ECMA119_Integral(StructId_Integral):
    u"""Type class for ECMA 119 integral types."""

    def __init__(self, toplev, arg, vararg=None):
        u"""Initialise an ECMA 119 integral type instance.

        • arg: tuple(format, default value, is big endian?)

        """
        StructId_Type.__init__(self, toplev, arg, vararg)
        (self._fmt, self._defval, self._isbig) = arg
        if self._isbig == toplev._is_bigendian():
            self._swab = False
        else:
            self._swab = True

    def do_import(self, t):
        u"""Convert from unpack tuple to internal representation."""
        v = StructId_Integral.do_import(self, t)
        if self._swab:
            return StructId_bswap(self._fmt, v)
        return v

    def do_export(self, v):
        u"""Convert from internal representation to pack tuple."""
        if self._swab:
            v = StructId_bswap(self._fmt, v)
        return StructId_Integral.do_export(self, v)


class ECMA119_BB_Integral(StructId_Integral):
    u"""Type class for ECMA 119 both-byte order integral types."""

    def __init__(self, toplev, arg, vararg=None):
        u"""Initialise an ECMA 119 both-byte order integral type instance.

        • arg: tuple(format, default value)

        """
        StructId_Integral.__init__(self, toplev, arg, vararg)
        if toplev._is_bigendian():
            self._idx = 1
        else:
            self._idx = 0
        self._ofmt = self._fmt
        self._fmt = self._ofmt + self._ofmt

    def num_items(self):
        u"""Return how many items in the tuple this type uses."""
        return 2

    def do_import(self, t):
        u"""Convert from unpack tuple to internal representation."""
        if t is None:
            # set to default/uninitialised value
            return self._defval
        return t[self._idx]

    def do_export(self, v):
        u"""Convert from internal representation to pack tuple."""
        rv = [0, 0]
        rv[self._idx] = v
        rv[1 - self._idx] = StructId_bswap(self._ofmt, v)
        return tuple(rv)


class ECMA119_StructId(StructId):
    u"""Ordered dictionary of typed attributes with structure mapping.

    See StructId.__doc__ for more details. Additional types provided:
    • ecma711, ecma712              (unsigned, signed 8-bit)
    • ecma721, ecma722, ecma723     (unsigned 16-bit LE/BE/BiEndian)
    • ecma731, ecma732, ecma733     (unsigned 32-bit LE/BE/BiEndian)
    • ecma84261                     (8.4.26.1 date)

    § 7.{2,3}.{1,2,3} do not specify signedness, thus defaulting
    to unsigned for greater range of operation.

    """

    def _get_types(self):
        types = StructId._get_types(self)
        types['ecma711'] = tuple((StructId_Integral, ('B', 0x90)))
        types['ecma712'] = tuple((StructId_Integral, ('b', 0x3F)))
        types['ecma721'] = tuple((ECMA119_Integral, ('H', 0xFF0D, False)))
        types['ecma722'] = tuple((ECMA119_Integral, ('H', 0xD0FE, True)))
        types['ecma723'] = tuple((ECMA119_BB_Integral, ('H', 0xF00D)))
        types['ecma731'] = tuple((ECMA119_Integral, ('I', 0xFECAADDE, False)))
        types['ecma732'] = tuple((ECMA119_Integral, ('I', 0xDEADBEEF, True)))
        types['ecma733'] = tuple((ECMA119_BB_Integral, ('I', 0xBEBAADDE)))
        types['ecma84261'] = tuple((ECMA119_Date, None))
        return types
@


1.5
log
@• add ECMA119_Date_Container to give nice formatted dates
• abstract errors more
• make vararg mandatory, to ease things
• improve documentation
• add __str__ and __repr__ to StructId_Container
• use ‣ for methods in docstrings
• switch _is_bigendian from method to attribute, calculated
  during initialisation
• add dump optional argument to StructId.__init__

• pass pathnames everywhere
• use late initialisation of structs
does not yet work for arrays of structs (only first element is handled),
but it’s too late to continue hacking
@
text
@d3 1
a3 1
# $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.4 2010/10/16 22:39:39 tg Exp $
d24 1
a24 1
    $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.4 2010/10/16 22:39:39 tg Exp $
@


1.4
log
@capitalise ECMA
@
text
@d3 1
a3 1
# $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.3 2010/10/16 22:35:14 tg Exp $
d24 1
a24 1
    $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.3 2010/10/16 22:35:14 tg Exp $
d37 13
d77 1
a77 1
        rv = StructId_Container()
@


1.3
log
@endianness checks are also of more general usefulness
@
text
@d3 1
a3 1
# $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.2 2010/10/16 22:30:50 tg Exp $
d24 1
a24 1
    $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.2 2010/10/16 22:30:50 tg Exp $
d30 4
a33 4
    "Ecma119_Date",         # §8.4.26.1 Date types
    "Ecma119_Integral",     # Integral single-endian types
    "Ecma119_BB_Integral",  # Integral both-endian types
    "Ecma119_StructId",     # Abstract base class as StructId
d37 1
a37 1
class Ecma119_Date(StructId_Type):
d119 1
a119 1
class Ecma119_Integral(StructId_Integral):
d149 1
a149 1
class Ecma119_BB_Integral(StructId_Integral):
d185 1
a185 1
class Ecma119_StructId(StructId):
d203 7
a209 7
        types['ecma721'] = tuple((Ecma119_Integral, ('H', 0xFF0D, False)))
        types['ecma722'] = tuple((Ecma119_Integral, ('H', 0xD0FE, True)))
        types['ecma723'] = tuple((Ecma119_BB_Integral, ('H', 0xF00D)))
        types['ecma731'] = tuple((Ecma119_Integral, ('I', 0xFECAADDE, False)))
        types['ecma732'] = tuple((Ecma119_Integral, ('I', 0xDEADBEEF, True)))
        types['ecma733'] = tuple((Ecma119_BB_Integral, ('I', 0xBEBAADDE)))
        types['ecma84261'] = tuple((Ecma119_Date, None))
@


1.2
log
@bswap may be needed more often
@
text
@d3 1
a3 1
# $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.1 2010/10/16 22:28:22 tg Exp $
d24 1
a24 1
    $MirOS: contrib/hosted/tg/grml/ecma119.py,v 1.1 2010/10/16 22:28:22 tg Exp $
a26 1
import sys
d130 1
a130 2
        fmtbig = isbigendian(toplev._endian, toplev.__class__.__name__)
        if self._isbig == fmtbig:
d159 1
a159 1
        if isbigendian(toplev._endian, toplev.__class__.__name__):
a210 14


def isbigendian(ev, cn):
    if ev == '<':
        return False
    if ev == '>':
        return True
    if ev != '=':
        raise ValueError('%s does not specify endianness as LE/BE/HE' % cn)
    if sys.byteorder == 'big':
        return True
    if sys.byteorder == 'little':
        return False
    raise ValueError('what byteorder is "%s"?' % sys.byteorder)
@


1.1
log
@mapping of basic ECMA 119 types (equivs ISO 9660, we think), untested
@
text
@d3 1
a3 1
# $MirOS: contrib/hosted/tg/grml/structid.py,v 1.5 2010/10/16 21:01:15 tg Exp $
d24 1
a24 1
    $MirOS: contrib/hosted/tg/grml/structid.py,v 1.5 2010/10/16 21:01:15 tg Exp $
a26 1
import struct
d141 1
a141 1
            return bswap(self._fmt, v)
d147 1
a147 1
            v = bswap(self._fmt, v)
d183 1
a183 1
        rv[1 - self._idx] = bswap(self._ofmt, v)
a214 5
def bswap(fmt, value):
    u"""Reverse bytes in value according to struct.pack fmt."""
    return struct.unpack('<%s' % fmt, struct.pack('>%s' % fmt, value))[0]


@

