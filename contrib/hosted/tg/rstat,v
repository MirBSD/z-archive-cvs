head	1.6;
access;
symbols;
locks; strict;
comment	@# @;


1.6
date	2010.09.25.14.32.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004C9E07F47A97099A;

1.5
date	2010.09.25.12.11.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004C9DE6FA30054C84;

1.4
date	2010.09.25.11.50.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004C9DE20054E72D17;

1.3
date	2010.09.24.19.59.04;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004C9D02C32F9ABA6D;

1.2
date	2010.09.24.18.50.11;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004C9CF2F057351296;

1.1
date	2010.09.24.18.47.12;	author tg;	state Exp;
branches;
next	;
commitid	1004C9CF235327869B7;


desc
@@


1.6
log
@another de-whatevering: statistics vs. arc4 stirs
@
text
@#!/bin/mksh
# $MirOS: contrib/hosted/tg/rstat,v 1.5 2010/09/25 12:11:23 tg Exp $
#-
# Copyright © 2010
#	Thorsten Glaser <tg@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Display entropy statistics, human-readable

saveIFS=$IFS
function tabularise {
	typeset maxlens aline aligns spaces
	set -A maxlens 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	typeset i=-1 nlins=${#lines[*]} ncols=$1

	if [[ $2 = RL ]]; then
		set -A aligns R L R L R L R L R L R L R L R L
		set -A spaces 0 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4
	else
		set -A aligns L L L L L L L L L L L L L L L L
		set -A spaces 0 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3
	fi

	IFS=!
	while (( ++i < nlins )); do
		typeset j=-1
		set -A aline -- ${lines[i]}
		while (( ++j < ncols )); do
			typeset k=${%aline[j]}
			(( k < 0 )) && k=${#aline[j]}
			(( maxlens[j] = maxlens[j] < k ? k : maxlens[j] ))
		done
	done
	typeset i=-1
	while (( ++i < nlins )); do
		typeset j=-1 oline=
		set -A aline -- ${lines[i]}
		while (( ++j < ncols )); do
			eval typeset -${aligns[j]}'${maxlens[j]}' \
			    'k=${aline[j]}'
			eval typeset -L${spaces[j]} 'sp=" "'
			oline=$oline${oline:+$sp}$k
		done
		print -r -- "$oline"
	done
	IFS=$saveIFS
}

if whence -p bc >/dev/null; then
	bc |&
	function calculate {
		typeset _i

		print -pr -- "$@@"
		read -p _i
		print -r -- "$_i"
	}
else
	print 'Warning: cannot do 64-bit arithmetics, bc(1) not found!' \
	    Numbers may be wrong.
	function calculate {
		eval print -r -- '$(('"$*"'))'
	}
fi

while :; do
	print -n 'Hit Enter to continue: '
	read dummy
	[[ $dummy = q* ]] && exit 0
	count=$(rcnt)
	set -A stats -- $(sysctl -n kern.random)
	print
	#print D: $count ${stats[*]}

	# these numbers are "inclusive", detrend them
	stats[16]=$(calculate ${stats[16]} - ${stats[49]})
	stats[40]=$(calculate ${stats[40]} - ${stats[4]})
	stats[48]=$(calculate ${stats[48]} - ${stats[4]})
	stats[56]=$(calculate ${stats[56]} - \( 24 \* ${stats[4]} \))

	# convert bits to bytes
	count=$(calculate $count / 8)
	stats[0]=$(calculate ${stats[0]} / 8)
	stats[1]=$(calculate ${stats[1]} / 8)
	stats[56]=$(calculate ${stats[56]} / 8)
	stats[58]=$(calculate ${stats[58]} / 8)
	stats[59]=$(calculate ${stats[59]} / 8)
	stats[60]=$(calculate ${stats[60]} / 8)
	stats[61]=$(calculate ${stats[61]} / 8)
	stats[62]=$(calculate ${stats[62]} / 8)
	stats[63]=$(calculate ${stats[63]} / 8)

	set -A lines
	lines[0]="entropy $count bytes!total ${stats[0]} bytes ${stats[11]} sleeping waits"
	lines[1]="used/read ${stats[1]} bytes!srandom read ${stats[2]} times"
	lines[2]="arc4 read ${stats[3]} bytes!stirred ${stats[4]} times, using ${stats[5]} bytes"
	lines[3]="${stats[12]} tytso pool enqueue calls!${stats[13]} tytso pool dequeue calls"
	lines[4]="${stats[14]} queue-full drops!${stats[15]} low watermark low entropy"
	lines[5]="${stats[6]} lopool dequeue calls @@ 128by!${stats[7]} enqueue calls, ${stats[8]} bytes"
	tabularise 2 - 5

	i=-1
	set -A lines
	while (( ++i < 4 )); do
		j=-1
		l=
		while (( ++j < 8 )); do
			l=$l${l:+!}"$((i*8+j))b!${stats[i*8+j+16]}"
		done
		lines[i]=$l
	done
	tabularise 16 RL 2 1

	set -A lines
	l=
	i=0 t=TRUE
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	i=3 t=TTY
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	i=2 t=MOUSE
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	i=7 t=IMACS
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	lines[0]=$l
	l=
	i=1 t=TIMER
	l=$l${l:+!}"$t!${stats[48+i]}"
	i=5 t=NET
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	i=6 t=A/V
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	i=4 t=DISK
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}"
	lines[1]=$l
	tabularise 8 RL 3 1
done
@


1.5
log
@since the stats are quad_t, use bc(1) when possible
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/rstat,v 1.3 2010/09/24 19:59:04 tg Exp $
d92 2
@


1.4
log
@• correct stats for distribution 0bit (timer) and 24bit (arc4random_stir)
• change order fields are displayed for greater screen efficiency
@
text
@d63 17
d90 14
a103 2
	(( stats[16] -= stats[49] ))
	(( stats[40] -= stats[4] ))
d106 2
a107 2
	lines[0]="entropy $((count/8)) bytes!total $((stats[0]/8)) bytes ${stats[11]} sleeping waits"
	lines[1]="used/read $((stats[1]/8)) bytes!srandom read ${stats[2]} times"
d129 1
a129 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d131 1
a131 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d133 1
a133 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d135 1
a135 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d141 1
a141 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d143 1
a143 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d145 1
a145 1
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
@


1.3
log
@• move rstat from bits to bytes (except distribution, of course)
• re-use RND_SRC_AUDIO for video and rename it RND_SRC_AUVIS
• switch to using add_auvis_entropy() in MirBSD code
• let RND_SRC_IMACS take up former RND_SRC_VIDEO’s place in statistics
• keep statistics for lopool en- and dequeues as well
• let rstat look ok also on 80x24 terminal
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/rstat,v 1.2 2010/09/24 18:50:11 tg Exp $
d72 4
d101 1
a101 1
	i=1 t=TIMER
d105 1
a105 1
	i=3 t=TTY
d109 2
a110 2
	i=4 t=DISK
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
d115 1
a115 1
	i=7 t=IMACS
@


1.2
log
@ah, nvm, got it, this is only srandom reads
@
text
@d2 1
a2 1
# $MirOS: contrib/hosted/tg/rstat,v 1.1 2010/09/24 18:47:12 tg Exp $
d73 2
a74 2
	lines[0]="entropy $count bits!total ${stats[0]} bits ${stats[11]} sleeping waits"
	lines[1]="used/read ${stats[1]} bits!srandom read ${stats[2]} times"
d76 1
a76 1
	lines[3]="${stats[12]} enqueue calls!${stats[13]} dequeue calls"
d78 1
d96 1
a96 1
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
d98 1
a98 1
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
d100 1
a100 1
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
d102 1
a102 1
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
d106 1
a106 1
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
d108 5
a112 5
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
	i=6 t=AUDIO
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
	i=7 t=VIDEO
	l=$l${l:+!}"$t(${stats[48+i]})!${stats[56+i]}b"
@


1.1
log
@add statistics displayer
interesting: no net entropy, no reads counted
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $
d73 2
a74 2
	lines[0]="entropy $count bits!total ${stats[0]} bits ${stats[11]} sleeps"
	lines[1]="used/read ${stats[1]} bits!reads ${stats[2]} times"
@

