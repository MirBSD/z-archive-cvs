head	1.19;
access;
symbols
	xchat-randex-1_20:1.16
	xchat-randex-1_11:1.10
	xchat-randex-1_10:1.8;
locks; strict;
comment	@ * @;


1.19
date	2014.02.19.17.43.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005304ED413F0CF25C;

1.18
date	2013.06.13.21.27.13;	author tg;	state Exp;
branches;
next	1.17;
commitid	10051BA3928732F9982;

1.17
date	2013.06.13.21.03.56;	author tg;	state Exp;
branches;
next	1.16;
commitid	10051BA33BD7E58F26D;

1.16
date	2011.12.16.21.30.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004EEBB8865F799E88;

1.15
date	2011.12.16.21.22.53;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004EEBB6B74D7F5438;

1.14
date	2011.12.16.20.49.29;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004EEBAEEA7806D791;

1.12
date	2011.12.16.20.23.29;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004EEBA8BD474BB4A1;

1.11
date	2010.09.21.21.24.05;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004C992261692DCA0F;

1.10
date	2009.11.22.20.39.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004B09A17C45494ECA;

1.9
date	2009.10.24.18.28.24;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004AE3475F480A96A5;

1.8
date	2009.08.02.15.15.14;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004A75AD9652A50676;

1.7
date	2009.08.02.15.10.16;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004A75AC640FEC54E1;

1.6
date	2009.08.02.14.48.38;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004A75A7263D1A5EFF;

1.5
date	2009.08.02.14.35.00;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004A75A41A5D07D5B1;

1.4
date	2009.06.06.13.43.04;	author tg;	state Stab;
branches;
next	1.3;
commitid	1004A2A72455018116D;

1.3
date	2009.06.06.12.24.15;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004A2A6001241DF7AC;

1.2
date	2009.06.06.11.36.39;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004A2A54DE55DCA7B7;

1.1
date	2009.06.05.23.42.20;	author tg;	state Exp;
branches;
next	;
commitid	1004A29AD625E1845F4;


desc
@@


1.19
log
@replace OAAT, NZAT, NZAAT with BAFH in virtually all places; bump libc major
@
text
@/*-
 * Copyright © 2009, 2010, 2011, 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright © 2013
 *	Vutral <vutral@@quantentunnel.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un‐
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 *-
 * MirOS RANDEX protocol plugin for XChat/HexChat (Win32, BSD, *nix).
 *
 * Protocol implementation status:
 *	- violation: CTCP CLIENTINFO does not list support for the protocol
 *	- violation: CTCP VERSION will not be amended by " (RANDOM=%d)"
 *	^ these stem from limitation of the XChat Plugin API 2.0
 *	- other than that, the protocol is fully supported
 *	- additional CTCP RANDOM returns plugin status and version
 *
 * On MirBSD (arc4random_pushb_fast) and Win32, the entropy received will be
 * fed back to the operating system; on other OSes, this plugin acts mostly
 * as a pool which can be accessed by the protocol and the /RANDOM command.
 *
 * Additional features over other implementations:
 *	- /RANDOM (output a random number, like /eval print $RANDOM in sirc)
 *	- /RANDEX * (send to the current channel/query, like in sirc)
 *	- /RANDFILE fn (read content from "fn", add to pool, save some to it)
 *
 * Missing features over other implementations:
 *	- no persistent seed file, no periodic stir (unlike irssi/randex.pl)
 *	- no support for EGD or other methods other than /RANDFILE
 *	- no support for accessing the pool in an automated fashion
 *
 * This implementation is shared between XChat and HexChat and thus
 * cannot use the plugin preferences feature available in the latter.
 */

static const char __rcsid[] =
    "@@(#)HEXCHAT "
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.18 2013/06/13 21:27:13 tg Exp $";

#define RANDEX_PLUGIN_VERSION	"1.28"

#include <sys/types.h>
#if defined(HAVE_STDINT_H) && HAVE_STDINT_H
#include <stdint.h>
#elif defined(USE_INTTYPES)
#include <inttypes.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "PLUGIN_HEADER"

#ifdef WIN32
#define u_int32_t	uint32_t
#endif

#ifndef MIN
#define MIN(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#if defined(arc4random_pushb_fast)
#define dopush		arc4random_pushb_fast
#define slowpush	arc4random_pushb_fast
#define RELEASE_PAPI	"pfast"
#elif !defined(arc4random_pushk)
extern u_int32_t arc4random(void);
extern void arc4random_stir(void);
#if defined(__CYGWIN__) || defined(WIN32)
extern uint32_t arc4random_pushb(const void *, size_t);
#define dopush		arc4random_pushb
#define slowpush	arc4random_addrandom
#define RELEASE_PAPI	"Win32"
#elif defined(OPPORTUNISTIC_ROOT_PUSHB)
extern uint32_t arc4random_pushb(const void *, size_t);
#define dopush		arc4random_pushb
#define slowpush	arc4random_addrandom
#define RELEASE_PAPI	"opportunistic"
#else
#define dopush(b,n)	arc4random_addrandom((void *)(b), (int)(n))
#define slowpush	arc4random_addrandom
#define RELEASE_PAPI	"none"
#endif
#else
#define dopush		arc4random_pushk
#define slowpush	arc4random_addrandom
#define RELEASE_PAPI	"pushk"
#endif

#if !defined(__OpenBSD__)
extern void arc4random_addrandom(unsigned char *, int);
#endif

static hexchat_plugin *ph;
static char buf[128];
static struct {
	time_t t;
	uint32_t u;
} g;

/* The XChat Plugin API 2.0 is not const clean */
static char randex_name[] = "randex";
static char randex_desc[] = "MirOS RANDomness EXchange protocol support";
static char randex_vers[] = RANDEX_PLUGIN_VERSION;
static char null[] = "";

int hexchat_plugin_init(hexchat_plugin *, char **, char **, char **, char *);
int hexchat_plugin_deinit(void);
void hexchat_plugin_get_info(char **, char **, char **, void **);

static int hookfn_rawirc(char *[], char *[], void *);
static int cmdfn_randex(char *[], char *[], void *);
static int cmdfn_randfile(char *[], char *[], void *);
static int cmdfn_randstir(char *[], char *[], void *);
static int cmdfn_random(char *[], char *[], void *);

static int do_randex(int, char *, char *, char *);
static void entropyio(void *, size_t);
static void gstring(const void *);
static void msg_condestruct(int);

/* in lieu of -Bsymbolic */
static void hexchat_plugin_get_info_(char **, char **, char **);


#define BAFHInit(h) do {					\
	(h) = 0;						\
} while (/* CONSTCOND */ 0)

#define BAFHUpdateOctet_reg(h,b) do {				\
	(h) += (uint8_t)(b);					\
	++(h);							\
	(h) += (h) << 10;					\
	(h) ^= (h) >> 6;					\
} while (/* CONSTCOND */ 0)

#define BAFHUpdateMem_reg(h,p,z) do {				\
	register const uint8_t *BAFHUpdate_p;			\
	register size_t BAFHUpdate_z = (z);			\
								\
	BAFHUpdate_p = (const void *)(p);			\
	while (BAFHUpdate_z--)					\
		BAFHUpdateOctet_reg((h), *BAFHUpdate_p++);	\
} while (/* CONSTCOND */ 0)

#define BAFHUpdateStr_reg(h,s) do {				\
	register const uint8_t *BAFHUpdate_s;			\
	register uint8_t BAFHUpdate_c;				\
								\
	BAFHUpdate_s = (const void *)(s);			\
	while ((BAFHUpdate_c = *BAFHUpdate_s++) != 0)		\
		BAFHUpdateOctet_reg((h), BAFHUpdate_c);		\
} while (/* CONSTCOND */ 0)

#define BAFHror(eax,cl) (((eax) >> (cl)) | ((eax) << (32 - (cl))))

#define BAFHFinish_reg(h) do {					\
	register uint32_t BAFHFinish_v;				\
								\
	BAFHFinish_v = ((h) >> 7) & 0x01010101U;		\
	BAFHFinish_v += BAFHFinish_v << 1;			\
	BAFHFinish_v += BAFHFinish_v << 3;			\
	BAFHFinish_v ^= ((h) << 1) & 0xFEFEFEFEU;		\
								\
	BAFHFinish_v ^= BAFHror(BAFHFinish_v, 8);		\
	BAFHFinish_v ^= ((h) = BAFHror((h), 8));		\
	BAFHFinish_v ^= ((h) = BAFHror((h), 8));		\
	(h) = BAFHror((h), 8) ^ BAFHFinish_v;			\
} while (/* CONSTCOND */ 0)


static void
hexchat_plugin_get_info_(char **name, char **desc, char **vers)
{
	*name = randex_name;
	*desc = randex_desc;
	*vers = randex_vers;
}

void
hexchat_plugin_get_info(char **name, char **desc, char **vers, void **resv)
{
	hexchat_plugin_get_info_(name, desc, vers);
	if (resv)
		*resv = NULL;
}

static void
gstring(const void *s)
{
	register uint32_t h;

	g.t = time(NULL);
	g.u = arc4random();
	BAFHInit(h);
	BAFHUpdateMem_reg(h, &g.u, sizeof(g.u));
	BAFHUpdateStr_reg(h, s);
	BAFHFinish_reg(h);
	g.u = h;
}

static void
msg_condestruct(int con)
{
	/* goes to the current tab */
	hexchat_printf(ph, "%sstructed RANDEX plugin v%s\n",
	    con ? "Con" : "De", randex_vers);
}

int
hexchat_plugin_init(hexchat_plugin *handle, char **name, char **desc,
    char **version, char *arg)
{
	ph = handle;
	hexchat_plugin_get_info_(name, desc, version);

	gstring(__rcsid);
	dopush((void *)&g, sizeof(g));

	hexchat_hook_server(ph, "RAW LINE", HEXCHAT_PRI_HIGHEST,
	    hookfn_rawirc, NULL);
	hexchat_hook_command(ph, "RANDEX", HEXCHAT_PRI_NORM,
	    cmdfn_randex, "Initiate RANDEX protocol with argument", NULL);
	hexchat_hook_command(ph, "RANDFILE", HEXCHAT_PRI_NORM,
	    cmdfn_randfile, "Exchange between pool and file", NULL);
	hexchat_hook_command(ph, "RANDSTIR", HEXCHAT_PRI_NORM,
	    cmdfn_randstir, "Stir the entropy pool", NULL);
	hexchat_hook_command(ph, "RANDOM", HEXCHAT_PRI_NORM,
	    cmdfn_random, "Show a random number", NULL);

	msg_condestruct(1);
	return (1);
}

int
hexchat_plugin_deinit(void)
{
	arc4random_stir();
	arc4random();

	msg_condestruct(0);
	return (1);
}

static int
hookfn_rawirc(char *word[], char *word_eol[], void *user_data)
{
	char *src, *dst, *cmd, *rest;

	if (!word[1] || !word[1][0])
		return (HEXCHAT_EAT_NONE);
	if (word[1][0] == ':') {
		src = word[1];
		cmd = word[2];
		dst = word[3];
		rest = word_eol[4];
	} else {
		src = null;
		cmd = word[1];
		if (word_eol[2][0] == ':') {
			dst = null;
			rest = word_eol[2];
		} else {
			dst = word[2];
			rest = word_eol[3];
		}
	}

	if (*src == ':')
		++src;
	if (*dst == ':')
		++dst;
	if (*rest == ':')
		++rest;

	if ((*rest == '+' || *rest == '-') && rest[1] == 1)
		/* CAPAB IDENTIFY-MSG or similar */
		++rest;
	if (*rest == 1) {
		++rest;
		if (!strcasecmp(cmd, "privmsg") &&
		    !strncasecmp(rest, "entropy", 7))
			return (do_randex(1, src, dst, word_eol[1]));
		else if (!strcasecmp(cmd, "privmsg") &&
		    !strncasecmp(rest, "random", 6))
			return (do_randex(2, src, dst, word_eol[1]));
		else if (!strcasecmp(cmd, "notice") &&
		    !strncasecmp(rest, "random", 6))
			return (do_randex(0, src, dst, word_eol[1]));
	}

	gstring(word_eol[1]);
	slowpush((void *)&g, sizeof(g));
	return (HEXCHAT_EAT_NONE);
}

static void
entropyio(void *p, size_t len)
{
	char *cp = buf;
	uint32_t v;
	int i;

	dopush(p, len);
	for (i = 0; i < 7; ++i) {
		v = arc4random();
		*cp++ = '!' + (v & 0x3F);
		v >>= 6;
		*cp++ = '!' + (v & 0x3F);
		v >>= 6;
		*cp++ = '!' + (v & 0x3F);
		v >>= 6;
		*cp++ = '!' + (v & 0x3F);
		v >>= 6;
		*cp++ = '!' + (v & 0x3F);
	}
	*cp = 0;
}

static int
cmdfn_randex(char *word[], char *word_eol[], void *user_data)
{
	const char *ichan, *inetw;

	if (hexchat_get_info(ph, "server") == NULL) {
		/* goes to the current tab */
		hexchat_print(ph, "You are not connected to the server.\n");
		return (HEXCHAT_EAT_ALL);
	}

	ichan = word[2];
	/* make "/randex *" address the current tab */
	if (ichan && ichan[0] == '*' && (!ichan[1] || ichan[1] == ' ' ||
	    ichan[1] == '\t' || ichan[1] == '\r')) {
		ichan = hexchat_get_info(ph, "channel");
		inetw = hexchat_get_info(ph, "network");
		if (!ichan || !*ichan || (inetw && !strcmp(ichan, inetw)))
			/* no current talk channel, or server tab active */
			ichan = NULL;
	}

	if (!ichan || !ichan[0]) {
		/* goes to the current tab */
		hexchat_print(ph, "You must specify a nick or channel!\n");
		return (HEXCHAT_EAT_ALL);
	}

	snprintf(buf, sizeof(buf), "to %s for %s", ichan, word_eol[3] ?
	    word_eol[3] : "\001(null)");
	/* goes to the current tab */
	hexchat_printf(ph, "Initiating the RANDEX protocol with %s\n", ichan);
	entropyio(buf, sizeof(buf));
	hexchat_commandf(ph, "quote PRIVMSG %s :\001ENTROPY %s\001", ichan, buf);

	memset(buf, 0, sizeof(buf));
	return (HEXCHAT_EAT_HEXCHAT);
}

static int
cmdfn_randstir(char *word[], char *word_eol[], void *user_data)
{
	unsigned long v;

	arc4random_stir();
	v = arc4random();
	/* goes to the current tab */
	hexchat_printf(ph, "Entropy pool stirred. RANDOM: 0x%08X (%lu)\n", v, v);
	return (HEXCHAT_EAT_HEXCHAT);
}

static int
cmdfn_random(char *word[], char *word_eol[], void *user_data)
{
	unsigned long v;

	v = arc4random();
	/* goes to the current tab */
	hexchat_printf(ph, "Random number: 0x%08X (%lu)\n", v, v);
	return (HEXCHAT_EAT_HEXCHAT);
}

static int
do_randex(int is_req, char *rsrc, char *dst, char *line)
{
	int i;
	char *cp, *src;

	if ((cp = strchr(rsrc, '!')))
		*cp = 0;
	src = strdup(rsrc);
	if (cp)
		*cp = '!';
	if (!src)
		src = rsrc;
#ifndef BE_QUIET
	/*
	 * should go to the server tab, but there is no way
	 * to do so even with hexchat_find_context => doesn't
	 */
	hexchat_printf(ph,
	    is_req == 2 ? "%s queried RANDEX protocol information from %s\n" :
	    is_req ? "%s initiated the RANDEX protocol with %s\n" :
	    "RANDEX protocol reply from %s to %s, processing\n", src, dst);
#endif
	entropyio(line, strlen(line));
	if (is_req == 2)
		hexchat_commandf(ph, "quote PRIVMSG %s :\001ACTION uses the"
		    " RANDEX plugin v%s for HexChat, push API: %s\001",
		    src, randex_vers, RELEASE_PAPI);
	else if (is_req)
		hexchat_commandf(ph, "quote NOTICE %s :\001RANDOM %s\001",
		    src, buf);
	if (src != rsrc)
		free(src);

	memset(buf, 0, sizeof(buf));
	return (HEXCHAT_EAT_ALL);
}

static int
cmdfn_randfile(char *word[], char *word_eol[], void *user_data)
{
	register uint32_t h;
	const char *fn;
	FILE *f;
	size_t n;
	uint32_t tv;
	char pb[600];

	fn = word[2];
	if (!fn || !fn[0]) {
		/* goes to the current tab */
		hexchat_print(ph, "You must specify a filename!\n");
		return (HEXCHAT_EAT_HEXCHAT);
	}

	g.t = time(NULL);
	g.u = arc4random();
	BAFHInit(h);
	BAFHUpdateMem_reg(h, &g.u, sizeof(g.u));
	BAFHUpdateStr_reg(h, fn);

	if ((f = fopen(fn, "rb")) != NULL) {
		do {
			if ((n = fread(pb, 1, sizeof(pb), f))) {
				slowpush((void *)pb, n);
				tv = arc4random();
				BAFHUpdateMem_reg(h, &tv, sizeof(tv));
			}
		} while (n);
		fclose(f);
		BAFHUpdateMem_reg(h, pb, 16);
		(void)arc4random();
	}

	if ((f = fopen(fn, "wb")) != NULL) {
		for (n = 0; n < sizeof(pb); n += sizeof(tv)) {
			tv = arc4random();
			memcpy(pb + n, &tv, sizeof(tv));
		}
		if ((n = fwrite(pb, 1, sizeof(pb), f)) != sizeof(pb))
			hexchat_printf(ph, "Write error: %u/%u to %s\n",
			    (unsigned)n, (unsigned)sizeof(pb), fn);
		fclose(f);
		(void)arc4random();
	} else
		hexchat_printf(ph, "Could not open %s for writing!\n", fn);

	tv = arc4random();
	BAFHUpdateMem_reg(h, &tv, sizeof(tv));
	BAFHFinish_reg(h);
	g.u = h;
	dopush((void *)&g, sizeof(g));

	memset(pb, 0, sizeof(pb));
	return (HEXCHAT_EAT_HEXCHAT);
}
@


1.18
log
@permit opportunistic pushb by writing to /dev/urandom
• it i̲s̲ 0666 on Linux nowadays, and apparently user-writable
• gecko2@@ says similar thing about the Macintosh
@
text
@d51 1
a51 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.17 2013/06/13 21:03:56 tg Exp $";
d53 1
a53 1
#define RANDEX_PLUGIN_VERSION	"1.27"
d139 1
a139 2

#define NZATInit(h) do {					\
d143 2
a144 2
#define NZATUpdateByte(h,b) do {				\
	(h) += (unsigned char)(b);				\
d150 3
a152 3
#define NZATUpdateMem(h,p,z) do {				\
	register const unsigned char *NZATUpdateMem_p;		\
	register size_t NZATUpdateMem_z = (z);			\
d154 3
a156 3
	NZATUpdateMem_p = (const void *)(p);			\
	while (NZATUpdateMem_z--)				\
		NZATUpdateByte((h), *NZATUpdateMem_p++);	\
d159 3
a161 3
#define NZATUpdateString(h,s) do {				\
	register const char *NZATUpdateString_s;		\
	register unsigned char NZATUpdateString_c;		\
d163 3
a165 3
	NZATUpdateString_s = (const void *)(s);			\
	while ((NZATUpdateString_c = *NZATUpdateString_s++))	\
		NZATUpdateByte((h), NZATUpdateString_c);	\
d168 14
a181 6
#define NZAATFinish(h) do {					\
	(h) += (h) << 10;					\
	(h) ^= (h) >> 6;					\
	(h) += (h) << 3;					\
	(h) ^= (h) >> 11;					\
	(h) += (h) << 15;					\
d208 4
a211 4
	NZATInit(h);
	NZATUpdateMem(h, &g.u, sizeof(g.u));
	NZATUpdateString(h, s);
	NZAATFinish(h);
d452 3
a454 3
	NZATInit(h);
	NZATUpdateMem(h, &g.u, sizeof(g.u));
	NZATUpdateString(h, fn);
d461 1
a461 1
				NZATUpdateMem(h, &tv, sizeof(tv));
d465 1
a465 1
		NZATUpdateMem(h, pb, 16);
d483 2
a484 2
	NZATUpdateMem(h, &tv, sizeof(tv));
	NZAATFinish(h);
@


1.17
log
@attempt to build both a HexChat plugin and an XChat plugin

HexChat support by Vutral, although I chose to not use hexchat_plugin.h
@
text
@d51 1
a51 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.16 2011/12/16 21:30:58 tg Exp $";
d53 1
a53 1
#define RANDEX_PLUGIN_VERSION	"1.26"
d87 5
@


1.16
log
@let’s call it 1.20:
add support in hookfn_rawirc for CAPAB IDENTIFY-MSG (since xchat 2.8.8
apparently gained support for freenode7’s CAP REQ :identify-msg…)
@
text
@d2 4
a5 2
 * Copyright (c) 2009, 2010, 2011
 *	Thorsten Glaser <tg@@mirbsd.org>
d9 1
a9 1
 * is granted to deal in this work without restriction, including un-
d13 1
a13 1
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
d20 1
a20 1
 * of said person's immediate fault when using the work as intended.
d22 1
a22 1
 * MirOS RANDEX protocol plugin for XChat (Win32, BSD, *nix).
d44 3
d50 2
a51 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.15 2011/12/16 21:22:53 tg Exp $";
d53 1
a53 1
#define RANDEX_PLUGIN_VERSION	"1.20"
d65 1
a65 1
#include "xchat-plugin.h"
d102 1
a102 1
static xchat_plugin *ph;
d115 3
a117 3
int xchat_plugin_init(xchat_plugin *, char **, char **, char **, char *);
int xchat_plugin_deinit(void);
void xchat_plugin_get_info(char **, char **, char **, void **);
d131 1
a131 1
static void xchat_plugin_get_info_(char **, char **, char **);
d174 1
a174 1
xchat_plugin_get_info_(char **name, char **desc, char **vers)
d182 1
a182 1
xchat_plugin_get_info(char **name, char **desc, char **vers, void **resv)
d184 1
a184 1
	xchat_plugin_get_info_(name, desc, vers);
d207 1
a207 1
	xchat_printf(ph, "%sstructed RANDEX plugin v%s\n",
d212 1
a212 1
xchat_plugin_init(xchat_plugin *handle, char **name, char **desc,
d216 1
a216 1
	xchat_plugin_get_info_(name, desc, version);
d221 1
a221 1
	xchat_hook_server(ph, "RAW LINE", XCHAT_PRI_HIGHEST,
d223 1
a223 1
	xchat_hook_command(ph, "RANDEX", XCHAT_PRI_NORM,
d225 1
a225 1
	xchat_hook_command(ph, "RANDFILE", XCHAT_PRI_NORM,
d227 1
a227 1
	xchat_hook_command(ph, "RANDSTIR", XCHAT_PRI_NORM,
d229 1
a229 1
	xchat_hook_command(ph, "RANDOM", XCHAT_PRI_NORM,
d237 1
a237 1
xchat_plugin_deinit(void)
d252 1
a252 1
		return (XCHAT_EAT_NONE);
d295 1
a295 1
	return (XCHAT_EAT_NONE);
d326 1
a326 1
	if (xchat_get_info(ph, "server") == NULL) {
d328 2
a329 2
		xchat_print(ph, "You are not connected to the server.\n");
		return (XCHAT_EAT_ALL);
d336 2
a337 2
		ichan = xchat_get_info(ph, "channel");
		inetw = xchat_get_info(ph, "network");
d345 2
a346 2
		xchat_print(ph, "You must specify a nick or channel!\n");
		return (XCHAT_EAT_ALL);
d352 1
a352 1
	xchat_printf(ph, "Initiating the RANDEX protocol with %s\n", ichan);
d354 1
a354 1
	xchat_commandf(ph, "quote PRIVMSG %s :\001ENTROPY %s\001", ichan, buf);
d357 1
a357 1
	return (XCHAT_EAT_XCHAT);
d368 2
a369 2
	xchat_printf(ph, "Entropy pool stirred. RANDOM: 0x%08X (%lu)\n", v, v);
	return (XCHAT_EAT_XCHAT);
d379 2
a380 2
	xchat_printf(ph, "Random number: 0x%08X (%lu)\n", v, v);
	return (XCHAT_EAT_XCHAT);
d399 1
a399 1
	 * to do so even with xchat_find_context => doesn't
d401 1
a401 1
	xchat_printf(ph,
d408 2
a409 2
		xchat_commandf(ph, "quote PRIVMSG %s :\001ACTION uses the"
		    " RANDEX plugin v%s for XChat, push API: %s\001",
d412 1
a412 1
		xchat_commandf(ph, "quote NOTICE %s :\001RANDOM %s\001",
d418 1
a418 1
	return (XCHAT_EAT_ALL);
d434 2
a435 2
		xchat_print(ph, "You must specify a filename!\n");
		return (XCHAT_EAT_XCHAT);
d463 1
a463 1
			xchat_printf(ph, "Write error: %u/%u to %s\n",
d468 1
a468 1
		xchat_printf(ph, "Could not open %s for writing!\n", fn);
d477 1
a477 1
	return (XCHAT_EAT_XCHAT);
@


1.15
log
@apparently, due to lack of -Bsymbolic, name info was bound incorrectly
@
text
@d45 3
a47 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.14 2011/12/16 20:49:29 tg Exp $";
d106 1
a106 1
static char randex_vers[] = "1.12+CVS";
d271 3
@


1.14
log
@switch to using NZAAT hash
@
text
@d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.12 2011/12/16 20:23:29 tg Exp $";
d119 6
d165 2
a166 2
void
xchat_plugin_get_info(char **name, char **desc, char **vers, void **resv)
d171 6
d208 1
a208 1
	xchat_plugin_get_info(name, desc, version, NULL);
@


1.12
log
@optimise the displaying of remote-triggered protocol information
(apparently plugins cannot use the preferences API of xchat, gah,
so make it a compile-time define)
@
text
@d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.11 2010/09/21 21:24:05 tg Exp $";
d90 1
a90 1
static unsigned long adler32(unsigned long, const unsigned char *, unsigned);
d92 1
d96 4
d104 1
a104 1
static char randex_vers[] = "1.11+CVS";
d120 39
d170 14
a194 2
	unsigned long i;

d198 2
a199 3
	/* XXX use oaat ipv adler32 */
	i = adler32(arc4random() | 1, (const void *)__rcsid, sizeof(__rcsid));
	dopush(&i, sizeof(i));
d220 1
a228 2
	unsigned long i;
	time_t v;
d270 2
a271 5
	v = arc4random();
	i = adler32(adler32(1, (const void *)&v, sizeof(v)),
	    (const void *)word_eol[1], strlen(word_eol[1]));
	v = time(NULL) ^ (time_t)i;
	slowpush((void *)&v, sizeof(v));
d340 2
d343 1
d345 1
a345 1
	xchat_print(ph, "Entropy pool stirred.\n");
a359 28
#define BASE	65521	/* largest prime smaller than 65536 */
#define NMAX	5552	/* largest n: 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

static unsigned long
adler32(unsigned long s1, const unsigned char *bp, unsigned len)
{
	unsigned long s2;
	unsigned n;

	if (bp == NULL)
		return (1UL);

	s2 = (s1 >> 16) & 0xFFFFUL;
	s1 &= 0xFFFFUL;

	while (len) {
		len -= (n = MIN(len, NMAX));
		while (n--) {
			s1 += *bp++;
			s2 += s1;
		}
		s1 %= BASE;
		s2 %= BASE;
	}

	return (s1 | (s2 << 16));
}

d401 1
d405 1
d415 5
a419 1
	(void)arc4random();
d423 1
a423 1
			if ((n = fread(pb, 1, sizeof(pb), f)))
d425 3
d430 1
a434 2
		uint32_t tv;

d447 6
@


1.11
log
@use arc4random() a bit more efficiently
@
text
@d2 1
a2 1
 * Copyright (c) 2009, 2010
d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.10 2009/11/22 20:39:04 tg Exp $";
d125 8
d157 1
a157 2
	/* goes to the current tab */
	xchat_printf(ph, "%sstructed RANDEX plugin v%s\n", "Con", randex_vers);
d166 1
a166 2
	/* goes to the current tab */
	xchat_printf(ph, "%sstructed RANDEX plugin v%s\n", "De", randex_vers);
d337 1
a337 1
	int i, j;
d347 10
a356 14
	if ((i = xchat_get_prefs(ph, "rand_quiet", NULL, &j)) != 1 &&
	    i != 2)
		j = 0;
	if (!j)
		/*
		 * should go to the server tab, but there is no way
		 * to do so even with xchat_find_context => doesn't
		 */
		xchat_printf(ph, is_req == 2 ?
		    "%s queried RANDEX protocol information from %s\n" :
		    is_req ?
		    "%s initiated the RANDEX protocol with %s\n" :
		    "RANDEX protocol reply from %s to %s, processing\n",
		    src, dst);
@


1.10
log
@fix vsn no
@
text
@d2 1
a2 1
 * Copyright (c) 2009
d29 3
a31 3
 * On MirBSD (arc4random_pushk) and Win32, the entropy received will be fed
 * back to the operating system; on other OSes, this plugin acts mostly as
 * a pool which can be accessed by the protocol and the /RANDOM command.
d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.9 2009/10/24 18:28:24 tg Exp $";
d67 5
a71 1
#ifndef arc4random_pushk
d76 2
a77 1
#define arc4random_pushk arc4random_pushb
d80 2
a81 1
#define arc4random_pushk(b,n) arc4random_addrandom((void *)(b), (int)(n))
d85 2
d99 1
a99 1
static char randex_vers[] = "1.11";
d134 1
d136 1
a136 1
	arc4random_pushk(&i, sizeof(i));
d214 1
a214 1
	arc4random_addrandom((void *)&v, sizeof(v));
d225 1
a225 1
	arc4random_pushk(p, len);
d390 1
a390 1
				arc4random_addrandom((void *)pb, n);
@


1.9
log
@let /randfile write 600 byte files, safe to use as ~/.gnupg/random_seed

XXX todo XXX
• actually default to that file (irssi)
• use oaathash ipv adler32 (irssi, xchat, tinyirc, sirc)
• link to homepage, which should be written first though…
@
text
@d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.8 2009/08/02 15:15:14 tg Exp $";
d91 1
a91 1
static char randex_vers[] = "1.10";
@


1.8
log
@prepare for release
@
text
@d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.7 2009/08/02 15:10:16 tg Exp $";
d367 1
a367 1
	char pb[256];
@


1.7
log
@new command /randfile

usage example: /randfile C:\RANDSEED.BIN
@
text
@d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.4 2009/06/06 13:43:04 tg Stab $";
d376 2
d384 1
d398 1
@


1.6
log
@• better init/deinit msgs; save space
• do *NOT* pushb every line’s sum, merely addrandom it;
  this makes the system responsible again oO (win32)
• warning cleanup (but we need -Wno-unused due to the API)
@
text
@d36 1
d40 2
a41 2
 *	- no support for contributing to the pool directly, getting entropy
 *	  from the pool other than /RANDOM, or using EGD or similar methods
d45 1
a45 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.5 2009/08/02 14:35:00 tg Exp $";
d91 1
a91 1
static char randex_vers[] = "1.07";
d100 1
d133 2
d360 41
@


1.5
log
@CTCP RANDOM is now part of the new RANDEX protocol as well
@
text
@d44 1
a44 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.4 2009/06/06 13:43:04 tg Stab $";
d74 1
a74 2
extern void arc4random_addrandom(u_char *, int);
#define arc4random_pushk(b,n) arc4random_addrandom((u_char *)(b), (int)(n))
d82 1
d90 1
a90 1
static char randex_vers[] = "1.06";
d137 1
a137 1
	xchat_printf(ph, "Constructed RANDEX plugin v%s\n", randex_vers);
d147 1
a147 1
	xchat_print(ph, "Destructed RANDEX plugin\n");
d201 1
a201 1
	arc4random_pushk(&v, sizeof(v));
@


1.4
log
@make a stable version; tested on Win32 (Cygwin compiled for MinGW) and
GNU/Linux (Lenny) by myself; compiles on BSD; tested on Mac (GTK+2) by
gecko2@@ (compiled by myself); builds with -Wall -Wextra -Wno-unused or
(MirBSD) __CRAZY=Yes just fine
@
text
@d27 1
d44 1
a44 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.3 2009/06/06 12:24:15 tg Exp $";
d69 1
a69 1
#ifdef WIN32
d72 1
d76 1
d78 2
d90 1
a90 1
static char randex_vers[] = "1.05";
d189 3
d336 3
a338 1
		xchat_printf(ph, is_req ?
d343 5
a347 1
	if (is_req)
@


1.3
log
@add comments and make __CRAZY clean
@
text
@d19 21
d43 1
a43 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.2 2009/06/06 11:36:39 tg Exp $";
d82 1
a82 1
/* The X-Chat API is not const clean */
d84 2
a85 2
static char randex_desc[] = "MirOS RANDomness EXchange plugin";
static char randex_vers[] = "1.04";
d101 1
a101 1
xchat_plugin_get_info(char **name, char **desc, char **vers, void **reserved)
d106 2
a107 2
	if (reserved)
		*reserved = NULL;
@


1.2
log
@add support for "/randex *" too
@
text
@d22 1
a22 1
    "$MirOS: contrib/hosted/tg/code/xchat-randex/main.c,v 1.1 2009/06/05 23:42:20 tg Exp $";
d64 1
a64 1
static char randex_vers[] = "1.02";
d110 1
d120 1
d205 1
d222 1
d229 1
d242 1
d253 1
d262 1
a262 1
adler32(unsigned long s1, const unsigned char *buf, unsigned len)
d267 1
a267 1
	if (buf == NULL)
d276 1
a276 1
			s1 += *buf++;
d303 4
@


1.1
log
@first cut at randex plugin for X-Chat (tested on Lenny and Win2k)
@
text
@d22 1
a22 1
    "$MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $";
d64 1
a64 1
static char randex_vers[] = "1.00";
d200 19
a218 1
	if (!word[2] || !word[2][0]) {
d223 1
a223 1
	snprintf(buf, sizeof(buf), "to %s for %s", word[2], word_eol[3] ?
d225 1
a225 1
	xchat_printf(ph, "Initiating the RANDEX protocol with %s\n", word[2]);
d227 1
a227 2
	xchat_commandf(ph, "quote PRIVMSG %s :\001ENTROPY %s\001", word[2],
	    buf);
@

