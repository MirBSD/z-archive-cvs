head	1.17;
access;
symbols;
locks; strict;
comment	@# @;


1.17
date	2017.12.19.00.54.52;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005A38636B714CDF30;

1.16
date	2017.10.09.19.07.43;	author tg;	state Exp;
branches;
next	1.15;
commitid	10059DBC91224DC944A;

1.15
date	2017.04.24.21.29.42;	author tg;	state Exp;
branches;
next	1.14;
commitid	10058FE6E5F10E3F456;

1.14
date	2015.01.11.22.44.42;	author tg;	state Exp;
branches;
next	1.12;
commitid	10054B2FCDB720B9D1E;

1.12
date	2015.01.06.12.29.29;	author tg;	state Exp;
branches;
next	1.11;
commitid	10054ABD53E5837E6C4;

1.11
date	2015.01.05.22.10.22;	author tg;	state Exp;
branches;
next	1.10;
commitid	10054AB0BE71B1788FC;

1.10
date	2015.01.05.21.39.17;	author tg;	state Exp;
branches;
next	1.9;
commitid	10054AB048656FAF01D;

1.9
date	2015.01.05.21.16.18;	author tg;	state Exp;
branches;
next	1.8;
commitid	10054AAFF3B0715E1BA;

1.8
date	2015.01.05.20.50.59;	author tg;	state Exp;
branches;
next	1.7;
commitid	10054AAF94C627564D2;

1.7
date	2015.01.05.20.45.13;	author tg;	state Exp;
branches;
next	1.6;
commitid	10054AAF7F211C3174D;

1.6
date	2014.11.26.12.01.47;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005475C1437CEAF4FD;

1.5
date	2013.02.26.21.20.55;	author tg;	state Exp;
branches;
next	1.4;
commitid	100512D2719085E7447;

1.4
date	2012.12.02.17.32.36;	author tg;	state Exp;
branches;
next	1.3;
commitid	10050BB90CA1468B90C;

1.3
date	2012.12.01.19.59.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	10050BA5FF2771B5B3C;

1.2
date	2012.04.08.17.37.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004F81CC5F3D84F6D5;

1.1
date	2012.04.08.17.12.54;	author tg;	state Exp;
branches;
next	;
commitid	1004F81C72D0F93F61F;


desc
@@


1.17
log
@https → http, nowadays (unwillingly) considered proper
@
text
@My notes on JSON
================

Compiled from both ECMA 262 (normative) and RFC 4627 (Informational)
for tarent Gesellschaft fuer Softwareentwicklung und IT-Beratung mbH
with subsequent independent development in private. Updated via both
RFC 7159 and ECMA 404.

An implementation (no guarantees for completeness / correctness) is at:
https://evolvis.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=shellsnippets/hello-php-world.git;a=blob;f=common/minijson.php;hb=HEAD
That implementation ("minijson") was created for tarent solutions GmbH.
Everything else in here was independently made. Still credits to ⮡ tarent
for sponsoring the initial development and giving it a reason.

More thoughts: http://www.mirbsd.org/permalinks/wlog-10_e20121201-tg.htm


Any JSON (JavaScript Object Notation) text shall be encoded in Unicode.

MIME: application/json
File extension: .json
Macintosh code: TEXT
default encoding and content-transfer-encoding: UTF-8, binary

former default: UTF-8, 8bit (no change)
deprecated alternative: UTF-16 and UTF-32, binary (deprecated)
+ note that the MIME type has no charset parameter, so signalling
  a non-UTF8 encoding is not possible

A JSON text, following a deprecated, optional, Unicode BOM U+FEFF,
consists of optional whitespace, exactly one expansion of the syn-
tactic goal Value, followed by optional whitespace. Compliant code
MUST NOT emit an Unicode BOM (using U+FEFF in the JSON text is, of
course, perfectly valid). RFC4627 limited interoperable JSON texts
to an Array or Object top-level element; RFC7159 lifts that.


primitive types that can be represented in JSON:
- string (Unicode; not binary-safe)
  + usually UTF-16, but no surrogate integrity guaranteed
- number (can emit integral, fractional, exponential number or null literal)
- boolean (literal: true, false)
- null (literal: null) -- also: NaN, -Inf, +Inf (infinite numbers)
structured types:
- object (associative array)
- array (indexed array, 0-based, no gaps)

JSON basic data types:
- literal null (also representing a non-number)
- boolean (literal true, literal false)
- integral Number
  + IEEE 754 makes [-2^53+1; 2^53-1] interoperable
- floating-point Number (decimal fractional with decimal exponent)
  + RFC7159 says IEEE 754 "double" are interoperable
- String
- Object (associative array)
- Array (zero-based non-sparse indexed array)

Rules for associative arrays:
- keys SHOULD be unique (RFC7159 says duplicates are not interoperable)
- order of keys is unsorted (rarely preserving; usually not visible)
Strict rules for associative arrays:
- the last element wins in case of duplicates
- keys are sorted ASCIIbetically (read: in numerically ascending order
  of their Unicode BMP codepoints (UTF-16 encoded)) before emitting
- this implies that keys are unique when emitted
- and that a round-trip is not order-preserving but the order is stable
- rationale for this: CVE-2011-4815 (in short: we MUST NOT leak the
  internal order if the internal representation of an associative array
  is a hash table that does not preserve order of addition)


/* lexical grammar (case-sensitive) */

whitespace ::= <0x09> | <0x0A> | <0x0D> | <0x20>

string ::= '"' *( stringcharacter ) '"'
stringcharacter ::= literalcharacter | escapesequence
literalcharacter ::= <0x20..D7FF except '"', '\'> | <E000..FFFD>
					// : RFC7159 permits ..10FFFF
escapesequence ::= '\'			// ''		: no production
	( '"'				// '"'		: unescape
	| '/'				// '/'		: unescape
	| '\'				// '\'		: unescape
	| 'b'				// <0x08>	: as in C
	| 'f'				// <0x0C>	: as in C
	| 'n'				// <0x0A>	: as in C
	| 'r'				// <0x0D>	: as in C
	| 't'				// <0x09>	: as in C
	| 'u' 4( hexdigit )		// : Unicode BMP codepoint
	)
hexdigit ::= '0'..'9' | 'a'..'f' | 'A'..'F'	// : case-insensitive

number ::= ?( '-' ) decimalnumber ?( '.' decimaldigits ) ?( exponent )
decimaldigits ::= +( '0'..'9' )
decimalnumber ::= '0' | ( '1'..'9' ?( decimaldigits ) )
exponent ::= 'e' | 'E' ?( '+' | '-' ) decimaldigits

literalnull ::= "null"
literalbool ::= "true" | "false"

/* syntactical grammar */

JSON ::= *( whitespace ) Value *( whitespace )		// : goal element

/*
 * insignificant *( whitespace ) permitted explicitly between structural
 * tokens ('[', ',', ']', '{', '}', and ':') and literal tokens
 * (literalnull, literalbool), and implicitly (by the grammar) around
 * any Value (Object, Array, string, Number) or Member
 */

Value ::= literalnull | literalbool | Object | Array | string | Number
Array ::= '[' ?( Value *( ',' Value ) ) ']'
Object ::= '{' ?( Member *( ',' Member ) ) '}'
Member ::= string /* key */ ':' Value
/* for parsing, Number=number; this is for emitting */
Number ::= literalnull /* not a finite number */ | number

/* token separation considerations */
literalnull, literalbool, number are always separated by the grammar
so neither next element lookup nor mandatory whitespace are required.

Both lexems/tokens and the content (keys and values) are case-sensitive,
although some decoders read e.g. literalnull or \n case-insensitively.
RFC7159 allows parsers to accept such extensions, but we urge to fail
parsing the document in such cases instead (ECMA-262 explicitly forbids
them; ECMA-404 is silent on this but forbids them for conformant texts).

To add insult to injury, RFC4627 listed ECMA-262 as normative reference;
RFC7159 lists ECMA-262 and ECMA-404 as informative only.

Testsuites:
- http://www.json.org/JSON_checker/test.zip (RFC 4627, apparently,
  as it does not allow a top-level Value, only Array and Object)
- https://github.com/nst/JSONTestSuite (RFC 7159, although it still
  requires support for files encoded in UTF-16)
+ deliberate deviations carefully (NUL disallowing, Unicode/UTF-16
  validity requirement for content, UTF-8 encoding requirement for
  JSON text, disallowing unencoded chars from astral planes like
  in ECMA, etc.)

/* security considerations */
- ensure no invalid things (e.g. unencoded SMP characters) show up
  + see below about codepoints from astral planes and RFC7159 badness
- according to ECMA-262, RFC4627 allows a parser to accept extensions
  (possibly, but not limited to, different numerical formats, writing
  Object keys with apostrophes or unescaped, allowing trailing commata
  in Object and Array definitions, allowing comments, etc.); this MUST
  NOT be done; be strict and anal as per the standard. (See above.)
- a String is a sequence of arbitrary 16-bit Unicode codepoints, that
  is, \u0000 \uFFFE \uFFFF and loose UTF-16 surrogates are valid, since
  the base language uses (UCS-2) Unicode
  + RFC7159 warns that codes that are not valid Unicode characters,
    such as loose surrogares, are not interoperable and may cause faults
    (they are allowed since earlier versions of Unicode, BMP-only,
    did not yet have surrogates, did not reserve the range thus)
  + we wish to forbid \u0000 (NUL) as some environments use C strings
    (but the RFC doesn't recognise this as interoperability problem)
  + we request to forbid \uFFFE and \uFFFF, as they are > WCHAR_MAX
  + see below about 21-bit Unicode codepoints and RFC7159 badness
- impose a nesting depth limit when reading


/* when emitting a Number */
- ECMA: NaN and both positive and negative infinity emit a literalnull
- RFC: NaN and infinities are disallowed (yield undefined value?)
  (most common implementations seem to use the RFC and interpret it as
  literally raising an error if they are encountered; support for them
  as literal values is a common extension, but *we* stick to ECMA!)
- negative 0 emits a "0" even though "-0" is valid by the grammar
- values other than -0 have the identity mapping

/* when emitting a string */
- escape '"' and '\' with \
- escape BS/FF/NL/CR/HT with \+letter
- escape <0x00..0x1F> with \uNNNN
  (except <0x00> should never happen)
- pass <0x7F> and <0080..009F> literally!
  + you may wish to escape them though
- for codepoints outside the BMP, emit the UTF-16 surrogate pair as
  escapes \uNNNN\uNNNN (do not pass them literally)
  + RFC7159 permits and suggests JSON generators to not encode them
    but keep them as literal 4-octet UTF-8 forms; an attempt to tell
    them about the wrongness and interop problem as erratum was rejected
- pass everything else (up to <FFFD>) literally
  (<FFFE> and <FFFF> should never happen either)
  + U+2028 and U+2029 SHOULD be escaped, they are not valid in
    literal strings in ECMAscript (but in JSON)
- any character MAY be escaped (as unicode, not octet)
  + string comparison and other operations must operate on the unencoded form,
    i.e. operate on each UCS-2 codepoint sequentially, for interoperability

/* when emitting an Object or Array */
- if the object/array is cyclical, throw an error
- acyclical nesting depth is unlimited (implementations SHOULD impose a limit)
- (ECMA says: Objects are in for-in enumeration order, if any, otherwise unsorted)
- Objects are ASCIIbetically sorted by their keys
  (to avoid CVE-2011-4815 and because JSON is an interchange format)
- Arrays are in numerical order, from 0 to nelems-1, with no gaps
- (ECMAscript only: 'undefined', functions, etc. produce an undefined value)
- Objects do not emit slots whose value is undefined at all! (but slots with null)
- Arrays emit undefined values as literalnull

___________________________________________________________________________________
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.16 2017/10/09 19:07:43 tg Exp $
@


1.16
log
@link to testsuites I used against miniJSON
@
text
@d15 1
a15 1
More thoughts: https://www.mirbsd.org/permalinks/wlog-10_e20121201-tg.htm
d206 1
a206 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.15 2017/04/24 21:29:42 tg Exp $
@


1.15
log
@update
@
text
@d133 10
d206 1
a206 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.6 2014/11/26 12:01:47 tg Exp $
@


1.14
log
@more note on RFC actively breaking JSON compat by allowing non-BMP chars
(codepoints in the SMP, or “astral planes”)
@
text
@d10 1
a10 1
https://evolvis.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=evolvis-platfrm/evolvisforge.git;a=blob;f=src/common/include/minijson.php;hb=HEAD
d12 1
a12 1
Everything else in here was independently made. Still credits to tarent
@


1.12
log
@RFC is bad
@
text
@d135 1
@


1.11
log
@considerations on format extensions and the RFC vs ECMA fights, next round
@
text
@d80 1
d150 1
d172 3
@


1.10
log
@update from ECMA-404 and the Errata for RFC7159

XXX this has grown wild; orderly rewrite recommended
@
text
@d54 1
a54 1
  + RFC 7159 says IEEE 754 "double" are interoperable
d60 1
a60 1
- keys SHOULD be unique (RFC 7159 says duplicates are not interoperable)
d126 5
a130 1
parsing the document in such cases instead.
d138 1
a138 1
  NOT be done; be strict and anal as per the standard
@


1.9
log
@add more restrictions/updates from RFC7159
@
text
@d6 2
a7 1
with subsequent independent development in private.
d30 2
a31 2
A JSON text consists of a deprecated, optional, Unicode BOM U+FEFF
followed by optional whitespace, exactly one expansion of the syn-
d34 2
a35 2
course, perfectly valid). RFC 4627 (obsoleted by RFC 7159) limited
interoperable JSON texts to an Array or Object top-level element.
d39 2
a40 2
- string (Unicode; not binary-safe; not NUL-safe in many implementations;
  usually UTF-16 but no surrogate integrity guaranteed)
d65 1
a65 1
  of their Unicode BMP (UTF-16) codepoints) before emitting
d101 1
a101 1
/* syntactical grammar, separate tokens by *( whitespace ) */
d103 8
a110 1
JSON<ECMA> ::= Value			// : goal element, ECMA 262
d140 4
a143 1
  + we wish to forbid \u0000 (NUL) as many environments use C strings
d163 1
a167 1
- any character MAY be escaped (as unicode)
d170 1
d185 1
a185 1
__________________________________________________________________________________
@


1.8
log
@RFC7159 makes Value the goal element, surrounded by optional whitespace, deprecates nōn-UTF-8 and forbids emitting an initial BOM
@
text
@d22 6
a27 2
default encoding and content-transfer-encoding: UTF-8, 8bit
alternative: UTF-16 and UTF-32, binary (deprecated)
d31 4
a34 1
tactic goal Value, followed by optional whitespace.
d51 1
d53 1
d59 2
a60 2
- keys SHOULD be unique
- order of keys is unsorted but usually preserving
d117 2
d121 1
a121 1
- ensure no invalid things (e.g. unencoded UTF-16) show up
d128 6
a133 6
  is, \u0000 \uFFFE \uFFFF and loose UTF-16 surrogates are valid; for
  an information interchange format we'd like to forbid at least the
  first three (NUL for its use in many programming environments in C
  strings, and \uFFFE and \uFFFF as they're invalid Unicode as JSON
  is not binary-safe anyway); the base language uses Unicode, so we
  don't check for UTF-16 as that's something different
d159 2
@


1.7
log
@escaping U+2028 and U+2029 makes JSON a true subset of ECMAscript, or so people say
@
text
@d23 1
a23 1
alternative: UTF-16 and UTF-32, binary (the IETF will drop them)
d25 3
a27 7
A JSON text consists of an optional Unicode BOM <U+FEFF> in either
UTF-16 variant (or UTF-8) and exactly one expansion of the syntac-
tical goal either JSON<RFC> or JSON<ECMA>. Its first (after a BOM,
if any) two octets are always 7-bit ASCII; the encoding can be de-
tected using the pattern of NUL octets thus.

The IETF will require UTF-8 encoding without a BOM.
a92 1
JSON<RFC> ::= Object | Array		// : goal element, RFC 4627
@


1.6
log
@update URIs
@
text
@d151 2
d166 1
a166 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.5 2013/02/26 21:20:55 tg Exp $
@


1.5
log
@the IETF will drop !UTF-8 and the BOM; mark accordingly and remove the
section about encoding detection (good for MirJSON anyway)

XXX consider erroring for \u0000 \uFFFE \uFFFF just like we do for
XXX other errors (unencoded surrogates etc.)
@
text
@d9 1
a9 1
https://evolvis.org/scm/viewvc.php/evolvis/trunk/gforge_base/evolvisforge/gforge/common/include/minijson.php?view=log
d14 2
d164 1
a164 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.4 2012/12/02 17:32:36 tg Exp $
@


1.4
log
@fix charset detection postulation; write down correct algorithm (loosely ordered, now)
@
text
@d21 1
a21 1
alternative: UTF-16 and UTF-32, binary
d29 2
a160 17

### Encoding detection ###

Peek at the octet stream received. The checks are ordered.

EF BB BF	-> skip 3; return UTF-8
00 00 FE FF	-> skip 4; return UCS-4BE
00 00 00 ??	-> skip 0; return UCS-4BE
?? 00 00 00	-> skip 0; return UCS-4LE
FF FE 00 00	-> skip 4; return UCS-4LE
FF FE		-> skip 2; return UCS-2LE
FE FF		-> skip 2; return UCS-2BE
00 ??		-> skip 0; return UCS-2BE
?? 00		-> skip 0; return UCS-2LE
otherwise	-> skip 0; return UTF-8


d162 1
a162 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.3 2012/12/01 19:59:44 tg Exp $
@


1.3
log
@• mention explicitly that JSON is not binary-safe
• add thoughts on disallowing \u0000 \uFFFE \uFFFF (they were never
  permitted unescaped already) but ignoring lone surrogate halves
• note how the encoding (UTF-8/16/32, Endianness) can be detected
• explain why Object keys are to be ASCIIbetically sorted
@
text
@d159 17
d177 1
a177 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.2 2012/04/08 17:37:59 tg Exp $
@


1.2
log
@• explain beyond the work sponsored by tarent solutions GmbH
• add JSON type overview
• add security considerations
  ⇒ impose more restrictions on the encoder
    ‣ prevent it from leaking information making CVE-2011-4815 possible
    ‣ suggest a nesting depth
  ⇒ add warnings and guidelines for the parser
    ‣ including nesting depth
    ‣ warn people to stay off the RFC 4627 and follow ECMA 262 more closely
• document what’s in a String
@
text
@d25 3
a27 1
tical goal either JSON<RFC> or JSON<ECMA>.
d31 2
a32 1
- string
d117 7
a123 2
- the content of a String consists of arbitrary 16-bit codepoints, that
  is, \uFFFF is valid in a String as are loose UTF-16 surrogates
d140 1
a141 1
- pass everything else literally
d144 2
d153 1
d160 1
a160 1
$MirOS: contrib/hosted/tg/code/MirJSON/json.txt,v 1.1 2012/04/08 17:12:54 tg Exp $
@


1.1
log
@mv mircvs://contrib/hosted/tg/json.txt mircvs://contrib/hosted/tg/code/MirJSON/json.txt
@
text
@d5 2
a6 1
for tarent Gesellschaft fuer Softwareentwicklung und IT-Beratung mbH.
d10 3
d24 2
a25 2
UTF-16 variant (or UTF-8) and one expansion of the syntactical goal
either JSON<RFC> or JSON<ECMA> (or, probably, their subset).
d28 1
a28 1
primitive types:
d37 9
d47 1
a47 1
- keys SHOULD be unique (recommend: overwrite dups with last one)
d49 9
d107 11
d129 1
a129 1
- escape '"\' with \
d140 3
a142 2
- acyclical nesting depth is unlimited
- Objects are in for-in enumeration order, if any, otherwise unsorted
d144 2
a145 2
- 'undefined', functions, etc. produce an undefined value
- Objects do not emit slots whose value is undefined at all!
d148 2
a149 2
_____________________________________________________________________
$MirOS: contrib/hosted/tg/json.txt,v 1.4 2011/11/19 00:13:49 tg Exp $
@

