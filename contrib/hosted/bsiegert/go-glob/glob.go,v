head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2010.10.05.17.54.13;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	1004CAB65FA3BEE3ADA;

1.3
date	2010.09.26.11.37.55;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	1004C9F309461F7584B;

1.2
date	2010.09.21.19.33.43;	author bsiegert;	state Exp;
branches;
next	1.1;
commitid	1004C9908AE6294BEC4;

1.1
date	2010.09.21.19.17.32;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004C99018E29024107;


desc
@@


1.4
log
@Implement a half-working GLOB_TILDE expansion routine.
Improve GLOB_ERR handling.
@
text
@//	$MirOS: contrib/hosted/bsiegert/go-glob/glob.go,v 1.3 2010/09/26 11:37:55 bsiegert Exp $

package glob

import (
	"container/vector"
	"path"
	"os"
	"sort"
	"strings"
)

const (
	GLOB_ERR = 4 >> iota	// abort when a directory cannot be opened
	GLOB_MARK		// append a slash to matching pathnames
	GLOB_NOCHECK		// if no match, return the string unchanged
	GLOB_NOSORT		// do not sort the results alphabetically
	GLOB_BRACE		// expand {foo,bar} brace expansions
	GLOB_TILDE		// expand a '~' to the home directory
	GLOB_NOESCAPE = 0x2000
)

// expandTilde expands the tilde at the begining of path with the value
// of the $HOME environment variable. We cannot expand '~user' because
// getpwnam(3) is not available in Go.
func expandTilde(path string) string {
	if path[0] != '~' {
		return path
	}
	h := os.Getenv("HOME")
	if h == "" {
		return path
	}
	return h + path[1:]
}

func expandBraces(path string) []string {
	var (
		open, close int // index of the opening and the closing brace
		result, x vector.StringVector
	)

	open = strings.LastIndex(path, "{")
	close = strings.Index(path[open+1:], "}")
	if open == -1 || close == -1 {
		return []string{path}
	}
	substs := strings.Split(path[open+1:open+close-2], ",", -1)
	for _, s := range substs {
		exp := path[0:open] + s + path[open+close:]
		if strings.Index(exp, "{") != -1 {
			x = expandBraces(exp)
			result.AppendVector(&x)
		} else {
			result.Push(exp)
		}
	}
	return result
}
			

func GlobAll(patterns []string, flags int, errfunc func(string, os.Error) bool) ([]string, bool) {
	var (
		m, matches  vector.StringVector
		ok, sorting bool
	)
	matches = make([]string, 0)
	// For GlobAll, only sort the results at the end
	sorting = (flags&GLOB_NOSORT == 0)

	for _, p := range patterns {
		m, ok = Glob(p, flags|GLOB_NOSORT, errfunc)
		if !ok && flags&GLOB_ERR != 0 {
			if sorting {
				sort.Sort(&matches)
			}
			return matches, false
		}
		matches.AppendVector(&m)
	}
	if sorting {
		sort.Sort(&matches)
	}
	return matches, true
}


func Glob(pattern string, flags int, errfunc func(string, os.Error) bool) ([]string, bool) {
	if flags&GLOB_TILDE != 0 {
		pattern = expandTilde(pattern)
	}
	if !ContainsMagic(pattern) {
		if flags&GLOB_NOCHECK == 0 {
			if _, err := os.Stat(pattern); err != nil {
				ok := !errfunc(pattern, err)
				return []string{}, ok
			}
		}
		return []string{pattern}, true
	}
	dir, file := path.Split(pattern)
	if dir == "" {
		dir = "."
	}
	if ContainsMagic(dir) {
		dirs, ok := Glob(dir[0:len(dir)-1], flags, errfunc)
		if !ok {
			return []string{}, flags&GLOB_ERR == 0
		}
		newpatterns := make([]string, len(dirs))
		for i, d := range dirs {
			newpatterns[i] = path.Join(d, file)
		}
		return GlobAll(newpatterns, flags, errfunc)
	}

	return globInDir(dir[0:len(dir)-1], file, flags, errfunc)
}

// ContainsMagic returns true if path contains any of the magic characters
// recognized by path.Match.
func ContainsMagic(path string) bool {
	return strings.IndexAny(path, "*?[") != -1
}

func globInDir(dir, pattern string, flags int, errfunc func(string, os.Error) bool) ([]string, bool) {
	var matches vector.StringVector
	var didmatch bool

	print("globInDir ", dir, " ", pattern, "\n") //DEBUG

	_, err := os.Stat(dir)
	if err != nil {
		goto error
	}
	print("globInDir going to open ", dir, "\n") //DEBUG
	d, err := os.Open(dir, os.O_RDONLY, 0666)
	if err != nil {
		goto error
	}
	defer d.Close()

	print("globInDir going to readdirnames ", dir, "\n") //DEBUG
	names, err := d.Readdirnames(-1)
	if err != nil {
		goto error
	}

	for _, n := range names {
		didmatch, err = path.Match(pattern, n)
		if err != nil {
			goto error
		}
		if !didmatch {
			continue
		}
		fullname := path.Join(dir, n)
		if flags&GLOB_MARK > 0 {
			fi, err := os.Stat(fullname)
			if err != nil {
				goto error
			}
			if fi.IsDirectory() {
				fullname = fullname + "/"
			}
		}
		matches.Push(fullname)
	}

	if flags&GLOB_NOSORT == 0 {
		sort.Sort(&matches)
	}
	return matches, true

error:
	if errfunc != nil {
		return nil, !errfunc(dir, err)
	}
	return nil, flags&GLOB_ERR == 0
}
@


1.3
log
@Implement sorting of results and GLOB_NOSORT handling.
@
text
@d1 1
a1 1
//	$MirOS: contrib/hosted/bsiegert/go-glob/glob.go,v 1.2 2010/09/21 19:33:43 bsiegert Exp $
d14 6
a19 6
	GLOB_ERR = 4 >> iota
	GLOB_MARK
	GLOB_NOCHECK
	GLOB_NOSORT
	GLOB_BRACE
	GLOB_TILDE
d23 39
d64 1
a64 1
		m, matches vector.StringVector
d69 1
a69 1
	sorting = (flags & GLOB_NOSORT == 0)
d72 2
a73 2
		m, ok = Glob(p, flags | GLOB_NOSORT, errfunc)
		if !ok {
d89 3
d108 1
a108 1
			return []string{}, false
d179 1
a179 1
	return nil, true
@


1.2
log
@gofmt
@
text
@d1 1
a1 1
//	$MirOS$
d9 1
d24 4
a27 2
	var m, matches vector.StringVector
	var ok bool
d29 2
d33 1
a33 1
		m, ok = Glob(p, flags, errfunc)
d35 3
d42 3
d53 2
a54 1
				return []string{}, true
d75 1
a75 1
	return globInDir(dir, file, flags, errfunc)
d88 7
d101 1
d128 3
@


1.1
log
@Very rough first prototype of an implementation of glob(3) in Go. Does not
yet respect all the options, or work on Win32.
@
text
@d1 2
a35 3
		


d40 1
a40 1
		if flags & GLOB_NOCHECK == 0 {
d48 3
a50 1
	if dir == "" { dir = "." }
d53 3
a55 1
		if !ok { return []string{}, false }
d77 3
a79 1
	if err != nil { goto error }
d81 1
a81 1
	
d83 3
a85 1
	if err != nil { goto error }
d89 6
a94 2
		if err != nil { goto error }
		if !didmatch { continue }
d96 1
a96 1
		if flags & GLOB_MARK > 0 {
d98 3
a100 1
			if err != nil { goto error }
@

