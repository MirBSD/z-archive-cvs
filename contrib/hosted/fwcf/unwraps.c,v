head	1.10;
access;
symbols
	FWCF_1_06:1.10
	FWCF_1_05:1.10
	FWCF_1_04:1.10
	FWCF_1_03:1.10
	FWCF_1_01:1.10
	FWCF_1_00:1.10;
locks; strict;
comment	@ * @;


1.10
date	2006.09.26.10.25.03;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004518FFF55AB578D0;

1.9
date	2006.09.24.21.46.16;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004516FCB12AEB461A;

1.8
date	2006.09.24.20.34.59;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004516EBC4399F582B;

1.7
date	2006.09.24.19.13.53;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004516D901510D0588;

1.6
date	2006.09.24.17.27.36;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004516C00C53104476;

1.5
date	2006.09.24.03.49.08;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004516003733397ECC;

1.4
date	2006.09.23.20.20.01;	author tg;	state Exp;
branches;
next	1.3;
commitid	100451596B33F0C3FA0;

1.3
date	2006.09.23.16.49.22;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004515659665BE1091;

1.2
date	2006.09.19.11.30.25;	author tg;	state Exp;
branches;
next	1.1;
commitid	100450FD4D30EBE772E;

1.1
date	2006.09.16.07.35.37;	author tg;	state Exp;
branches;
next	;
commitid	100450BA94D3353BC7D;


desc
@@


1.10
log
@* fix missing includes
* cast a little more, for systems other than MirOS #9-current
* spelling
* build fwcf.helper correctly without libz
@
text
@/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.9 2006/09/24 21:46:16 tg Exp $ */

/*-
 * Copyright (c) 2006
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
 */

#include <sys/param.h>
#include <err.h>
#ifdef DEBUG
#include <stdio.h>
#endif
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "defs.h"
#include "adler.h"
#include "compress.h"
#include "pack.h"
#include "sysdeps.h"

__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.9 2006/09/24 21:46:16 tg Exp $");

char *
fwcf_unpack(int fd, size_t *inner)
{
	uint8_t c, hdrbuf[12];
	size_t outer, x_inner, x, len, maxln;
	char *cdata, *udata;
	ADLER_DECL;

	if (inner == NULL)
		inner = &x_inner;

	if (read(fd, hdrbuf, 12) != 12)
		err(1, "read");

	if (strncmp((const char *)hdrbuf, "FWCF", 4))
		errx(1, "file format error");

	outer = LOADT(hdrbuf + 4);
	/* we don't need to support older versions, but specification
	   major 0 and 1 are compatible */
	if (hdrbuf[7] > FWCF_VER)
		errx(1, "wrong file version %02Xh", hdrbuf[7]);
	*inner = LOADT(hdrbuf + 8);
	c = hdrbuf[11];
	maxln = ((outer + (DEF_FLASHBLOCK - 1)) / DEF_FLASHBLOCK)
	    * DEF_FLASHBLOCK;

	if (((cdata = malloc(maxln)) == NULL) ||
	    ((udata = malloc(*inner)) == NULL))
		err(1, "malloc");
	memcpy(cdata, hdrbuf, 12);
	if (read(fd, cdata + 12, maxln - 12) < (ssize_t)(outer - 12))
		err(1, "read");

	len = outer - 4;
	ADLER_CALC(cdata);
	if ((s1 != LOADW(cdata + outer - 4)) ||
	    (s2 != LOADW(cdata + outer - 2)))
		errx(1, "crc mismatch: %02X%02X%02X%02X != %04X%04X",
		    (uint8_t)cdata[outer - 1], (uint8_t)cdata[outer - 2],
		    (uint8_t)cdata[outer - 3], (uint8_t)cdata[outer - 4],
		    s2, s1);

	if ((x = compressor_get(c)->decompress(udata, *inner, cdata + 12,
	    outer - 16)) != *inner)
		errx(1, "size mismatch: decompressed %lu, want %lu", (u_long)x,
		    (u_long)*inner);
	push_rndata((uint8_t *)cdata + outer, maxln - outer);
	free(cdata);
#ifdef DEBUG
	fprintf(stderr, "fwcf_unpack: decompressed outer %lu inner %lu\n",
	    (u_long)outer, (u_long)*inner);
#endif
	return (udata);
}
@


1.9
log
@implement LZO1X-1 compression via MiniLZO (GPL'd)
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.8 2006/09/24 20:34:59 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.8 2006/09/24 20:34:59 tg Exp $");
d92 1
a92 1
	    outer, *inner);
@


1.8
log
@* join mkfwcf.c, unfwcf.c, fwcf.helper.c into a single file tool.c
  which builds a combinded mkfwcf+unfwcf for the host normally, and
  a stripped-down tool for the target #ifdef SMALL (code sharing ;)
* enhance the tool by recompress functionality

Note: mkfwcf and unfwcf are kept for now
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.7 2006/09/24 19:13:53 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.7 2006/09/24 19:13:53 tg Exp $");
d85 1
a85 1
	    outer - 12)) != *inner)
@


1.7
log
@oops, cast correctly
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.6 2006/09/24 17:27:36 tg Exp $ */
d26 3
d39 1
a39 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.6 2006/09/24 17:27:36 tg Exp $");
d42 1
a42 1
fwcf_unpack(int fd)
d45 1
a45 1
	size_t outer, inner, x, len, maxln;
d49 3
d63 1
a63 1
	inner = LOADT(hdrbuf + 8);
d69 1
a69 1
	    ((udata = malloc(inner)) == NULL))
d84 2
a85 2
	if ((x = compressor_get(c)->decompress(udata, inner, cdata + 12,
	    outer - 12)) != inner)
d87 1
a87 1
		    (u_long)inner);
d90 4
@


1.6
log
@uh... headaches after a wine'n'sushi hacking night with wbx@@...
we actually can unpack version 0 archives
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.5 2006/09/24 03:49:08 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.5 2006/09/24 03:49:08 tg Exp $");
d74 2
a75 2
		    (uint8_t *)cdata[outer - 1], (uint8_t *)cdata[outer - 2],
		    (uint8_t *)cdata[outer - 3], (uint8_t *)cdata[outer - 4],
@


1.5
log
@unfwcf: crc mismatch: 15FFFFFFD444FFFFFFC0 != 1C6144C1

uh, yeah. probably not.
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.4 2006/09/23 20:20:01 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.4 2006/09/23 20:20:01 tg Exp $");
d53 3
a55 1
	if (hdrbuf[7] != FWCF_VER)
@


1.4
log
@* wraps.c: properly calculate size of the flash block from the outer
  size, not from the inner size
* all: handle entropy
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.3 2006/09/23 16:49:22 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.3 2006/09/23 16:49:22 tg Exp $");
d72 3
a74 2
		    cdata[outer - 1], cdata[outer - 2], cdata[outer - 3],
		    cdata[outer - 4], s2, s1);
@


1.3
log
@add to the size_t confusion... different OSes have different
definitions for it
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.2 2006/09/19 11:30:25 tg Exp $ */
d34 1
d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.2 2006/09/19 11:30:25 tg Exp $");
d42 1
a42 1
	size_t outer, inner, x, len;
d57 2
d60 1
a60 1
	if (((cdata = malloc(outer)) == NULL) ||
d64 1
a64 1
	if ((size_t)read(fd, cdata + 12, outer - 12) != (outer - 12))
d79 1
@


1.2
log
@make the adler32 macros easier to use and document them
keep the speed hack of using the 'len' global though
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unwraps.c,v 1.1 2006/09/16 07:35:37 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/unwraps.c,v 1.1 2006/09/16 07:35:37 tg Exp $");
d74 2
a75 1
		errx(1, "size mismatch: decompressed %d, want %d", x, inner);
@


1.1
log
@split the code into smaller units to reduce final executables' sizes
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/wraps.c,v 1.1 2006/09/16 07:09:49 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/wraps.c,v 1.1 2006/09/16 07:09:49 tg Exp $");
d41 1
a41 1
	size_t outer, inner, x;
d43 1
d64 2
a65 3
	ADLER_START(cdata)
	unsigned len = outer - 4;
	ADLER_RUN
a70 1
	ADLER_END
@

