head	1.7;
access;
symbols
	FWCF_1_06:1.7
	FWCF_1_05:1.7
	FWCF_1_04:1.7
	FWCF_1_03:1.7
	FWCF_1_01:1.7
	FWCF_1_00:1.7;
locks; strict;
comment	@ * @;


1.7
date	2006.09.23.23.21.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004515C15D179DC563;

1.6
date	2006.09.23.18.41.15;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045157FCE33E13363;

1.5
date	2006.09.16.03.51.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	100450B74B35ACD016A;

1.4
date	2006.09.16.03.50.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	100450B748F4FA4FB0E;

1.3
date	2006.09.16.03.32.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	100450B7064734B2B5B;

1.2
date	2006.09.16.02.46.34;	author tg;	state Exp;
branches;
next	1.1;
commitid	100450B65865C735468;

1.1
date	2006.09.16.01.55.23;	author tg;	state Exp;
branches;
next	;
commitid	100450B598527EA0606;


desc
@@


1.7
log
@* work with GNU make
* work on target w/o __RCSID()
* work without c_null
@
text
@/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.6 2006/09/23 18:41:15 tg Exp $ */

/*-
 * Copyright (c) 2006
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "defs.h"
#include "fts_subs.h"
#include "pack.h"

__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.6 2006/09/23 18:41:15 tg Exp $");

char *
ft_pack(ftsf_entry *e)
{
	char f_header[4096], *hdrptr = f_header;
	size_t hdrleft = sizeof (f_header), k;
	char *f_data = NULL, *rv;
	off_t e_size;

	if (e == NULL)
		return (NULL);
	if ((e->etype != FTSF_FILE) && (e->etype != FTSF_SYMLINK) &&
	    (e->etype != FTSF_DIR))
		return (NULL);

	e_size = e->statp->st_size;

	if ((k = strlcpy(hdrptr, e->pathname, hdrleft)) >= hdrleft)
		return (NULL);
	hdrptr += ++k;
	hdrleft -= k;

	if (e->etype == FTSF_SYMLINK) {
		STOREB(0x03);
		e->statp->st_mtime = 0;
		e->statp->st_mode = 0;
	} else if (e->etype == FTSF_DIR) {
		STOREB(0x05);
		e_size = 0;
	}

	if (e->statp->st_mtime) {
		STOREB(0x10);
		STORED(e->statp->st_mtime);
	}

	if (e->statp->st_gid > 0xFF) {
		STOREB('G');
		STORED(e->statp->st_gid);
	} else if (e->statp->st_gid) {
		STOREB('g');
		STOREB(e->statp->st_gid);
	}

	if (e->statp->st_mode > 0xFFFF) {
		STOREB('M');
		STORED(e->statp->st_mode);
	} else if (e->statp->st_mode) {
		STOREB('m');
		STOREW(e->statp->st_mode);
	}

	if (e->statp->st_uid > 0xFF) {
		STOREB('U');
		STORED(e->statp->st_uid);
	} else if (e->statp->st_uid) {
		STOREB('u');
		STOREB(e->statp->st_uid);
	}

	/* e_size is zero for everything except files and symlinks */
	if (e_size > 0xFF) {
		STOREB('S');
		STORET(e_size);
	} else if (e_size) {
		STOREB('s');
		STOREB(e_size);
	}

	STOREB(0);

	if (e_size) {
		if ((f_data = malloc(e_size)) == NULL)
			return (NULL);
		if (asprintf(&rv, "%s/%s", ftsf_prefix, e->pathname) == -1)
			return (NULL);
		if (e->etype == FTSF_SYMLINK) {
			if (readlink(rv, f_data, e_size) != e_size)
				return (NULL);
		} else {
			int fd;

			if ((fd = open(rv, O_RDONLY, 0)) < 0)
				return (NULL);
			if (read(fd, f_data, e_size) != e_size)
				return (NULL);
			close(fd);
		}
		free(rv);
	}
	k = sizeof (size_t) + (hdrptr - f_header) + e_size;
	if ((rv = malloc(k)) == NULL)
		return (NULL);
	*(size_t *)rv = k;
	memcpy(rv + sizeof (size_t), f_header, hdrptr - f_header);
	memcpy(rv + sizeof (size_t) + (hdrptr - f_header), f_data, e_size);
	return (rv);
}
@


1.6
log
@don't store information about symlinks that we cannot restore anyway
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.5 2006/09/16 03:51:06 tg Exp $ */
d32 1
d36 1
a36 1
__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.5 2006/09/16 03:51:06 tg Exp $");
@


1.5
log
@put the STORE* macros into pack.h
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.4 2006/09/16 03:50:24 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.4 2006/09/16 03:50:24 tg Exp $");
d58 1
a58 1
	if (e->etype == FTSF_SYMLINK)
d60 3
a62 1
	else if (e->etype == FTSF_DIR) {
@


1.4
log
@rename ft_pack.h to pack.h
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.3 2006/09/16 03:32:44 tg Exp $ */
d35 1
a35 35
__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.3 2006/09/16 03:32:44 tg Exp $");

#define STOREB(x) do {				\
		if (hdrleft < 1)		\
			return (NULL);		\
		*hdrptr++ = (x) & 0xFF;		\
		--hdrleft;			\
	} while (0)

#define STOREW(x) do {				\
		if (hdrleft < 2)		\
			return (NULL);		\
		*hdrptr++ = (x) & 0xFF;		\
		*hdrptr++ = ((x) >> 8) & 0xFF;	\
		hdrleft -= 2;			\
	} while (0)

#define STORET(x) do {				\
		if (hdrleft < 3)		\
			return (NULL);		\
		*hdrptr++ = (x) & 0xFF;		\
		*hdrptr++ = ((x) >> 8) & 0xFF;	\
		*hdrptr++ = ((x) >> 16) & 0xFF;	\
		hdrleft -= 3;			\
	} while (0)

#define STORED(x) do {				\
		if (hdrleft < 4)		\
			return (NULL);		\
		*hdrptr++ = (x) & 0xFF;		\
		*hdrptr++ = ((x) >> 8) & 0xFF;	\
		*hdrptr++ = ((x) >> 16) & 0xFF;	\
		*hdrptr++ = ((x) >> 24) & 0xFF;	\
		hdrleft -= 4;			\
	} while (0)
@


1.3
log
@properly enclose directories, too, as per spec 0.91
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.2 2006/09/16 02:46:34 tg Exp $ */
d33 1
a33 1
#include "ft_pack.h"
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.2 2006/09/16 02:46:34 tg Exp $");
@


1.2
log
@separate the fts prefix from the pathname within
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.1 2006/09/16 01:55:23 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/ft_pack.c,v 1.1 2006/09/16 01:55:23 tg Exp $");
d77 1
d81 2
a82 1
	if ((e->etype != FTSF_FILE) && (e->etype != FTSF_SYMLINK))
d85 2
d94 4
d128 2
a129 2
	/* XXX only for files and symlinks */
	if (e->statp->st_size > 0xFF) {
d131 2
a132 2
		STORET(e->statp->st_size);
	} else if (e->statp->st_size) {
d134 1
a134 1
		STOREB(e->statp->st_size);
d139 2
a140 2
	if (e->statp->st_size) {
		if ((f_data = malloc(e->statp->st_size)) == NULL)
d145 1
a145 2
			if (readlink(rv, f_data, e->statp->st_size)
			    != e->statp->st_size)
d152 1
a152 2
			if (read(fd, f_data, e->statp->st_size) !=
			    e->statp->st_size)
d158 1
a158 1
	k = sizeof (size_t) + (hdrptr - f_header) + e->statp->st_size;
d163 1
a163 2
	memcpy(rv + sizeof (size_t) + (hdrptr - f_header), f_data,
	    e->statp->st_size);
@


1.1
log
@* implement packing of single files into the fwcf filesystem inner format
* spec: implementing hardlinks is of course optional for the WRITER
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/fts_subs.c,v 1.1 2006/09/15 21:11:23 tg Exp $ */
d27 1
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/fts_subs.c,v 1.1 2006/09/15 21:11:23 tg Exp $");
d134 2
d137 1
a137 1
			if (readlink(e->pathname, f_data, e->statp->st_size)
d143 1
a143 1
			if ((fd = open(e->pathname, O_RDONLY, 0)) < 0)
d150 1
@

