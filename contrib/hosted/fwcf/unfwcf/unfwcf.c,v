head	1.8;
access;
symbols
	FWCF_1_06:1.8
	FWCF_1_05:1.8
	FWCF_1_04:1.8
	FWCF_1_03:1.8
	FWCF_1_01:1.8
	FWCF_1_00:1.8;
locks; strict;
comment	@ * @;


1.8
date	2006.09.24.20.35.01;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004516EBC4399F582B;

1.7
date	2006.09.24.19.11.57;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004516D8645DBACA09;

1.6
date	2006.09.23.19.47.40;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045158F5D2C01880F;

1.5
date	2006.09.23.18.44.10;	author tg;	state Exp;
branches;
next	1.4;
commitid	100451580874E171604;

1.4
date	2006.09.16.07.09.50;	author tg;	state Exp;
branches;
next	1.3;
commitid	100450BA34B6AE3B0F3;

1.3
date	2006.09.16.06.44.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	100450B9D56301DA2D4;

1.2
date	2006.09.16.06.18.58;	author tg;	state Exp;
branches;
next	1.1;
commitid	100450B975E603852FA;

1.1
date	2006.09.16.05.52.09;	author tg;	state Exp;
branches;
next	;
commitid	100450B910B6234B8E8;


desc
@@


1.8
log
@* join mkfwcf.c, unfwcf.c, fwcf.helper.c into a single file tool.c
  which builds a combinded mkfwcf+unfwcf for the host normally, and
  a stripped-down tool for the target #ifdef SMALL (code sharing ;)
* enhance the tool by recompress functionality

Note: mkfwcf and unfwcf are kept for now
@
text
@/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.7 2006/09/24 19:11:57 tg Exp $ */

/*-
 * Copyright (c) 2006
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
 */

#include <sys/param.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "defs.h"
#include "compress.h"
#include "pack.h"

__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.7 2006/09/24 19:11:57 tg Exp $");

static int unfwcf(int, const char *);
static __dead void usage(void);

static int do_dump = 0;

int
main(int argc, char *argv[])
{
	int c;
	int fd = STDIN_FILENO;
	const char *file_root = NULL, *infile = NULL;

	while ((c = getopt(argc, argv, "di:l")) != -1)
		switch (c) {
		case 'd':
			do_dump = 1;
			break;
		case 'i':
			infile = optarg;
			break;
		case 'l':
			return (list_compressors());
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc != (1 - do_dump))
		usage();

	file_root = *argv;

	if (infile != NULL)
		if ((fd = open(infile, O_RDONLY, 0)) < 0)
			err(1, "open %s", infile);

	return (unfwcf(fd, file_root));
}

static __dead void
usage(void)
{
	extern const char *__progname;

	fprintf(stderr, "Usage:\t%s [-i <infile>] <directory>"
	    "\n\t%s -d [-i <infile>]"
	    "\n\t%s -l\n", __progname, __progname, __progname);
	exit(1);
}

static int
unfwcf(int fd, const char *dir)
{
	char *udata;

	if ((udata = fwcf_unpack(fd, NULL))) {
		if (do_dump)
			ft_dump(udata);
		else
			ft_creatm(udata, dir);
	}
	return (udata != NULL ? 0 : 1);
}
@


1.7
log
@* compress.h: describe stable plug-in API for use by compression
  plugins (whose licence can be proprietary, e.g. GPL, as well)
* mkfwcf.c, unfwcf.c: include defs.h to increase chances they'll work on GNU
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.6 2006/09/23 19:47:40 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.6 2006/09/23 19:47:40 tg Exp $");
d93 1
a93 1
	if ((udata = fwcf_unpack(fd))) {
@


1.6
log
@extraction function for unfwcf, whose development
is about finished with that
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.5 2006/09/23 18:44:10 tg Exp $ */
d31 1
d35 1
a35 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.5 2006/09/23 18:44:10 tg Exp $");
@


1.5
log
@prepare for ft_creat addition
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.4 2006/09/16 07:09:50 tg Exp $ */
d34 1
a34 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.4 2006/09/16 07:09:50 tg Exp $");
d82 2
a83 1
	    "\n\t%s -l\n", __progname, __progname);
d88 1
a88 1
unfwcf(int fd, const char *dir __attribute__((unused)))
d96 1
a96 1
			/* ft_creatm(udata) */ udata++;
@


1.4
log
@more code-sharing
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.3 2006/09/16 06:44:26 tg Exp $ */
d34 1
a34 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.3 2006/09/16 06:44:26 tg Exp $");
d39 2
d48 1
a48 1
	while ((c = getopt(argc, argv, "i:l")) != -1)
d50 3
d64 1
a64 1
	if (argc != 1)
d91 6
a96 2
	if ((udata = fwcf_unpack(fd)))
		ft_dump(udata);
@


1.3
log
@parse the fwcf inner filesystem structure
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.2 2006/09/16 06:18:58 tg Exp $ */
a24 1
#include <sys/stat.h>
a28 1
#include <string.h>
a30 2
#include "defs.h"
#include "adler.h"
a31 1
#include "fts_subs.h"
d34 1
a34 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.2 2006/09/16 06:18:58 tg Exp $");
a36 1
static int list_compressors(void);
d84 1
a84 37
	uint8_t c, hdrbuf[12];
	size_t outer, inner, x;
	char *cdata, *udata;

	if (read(fd, hdrbuf, 12) != 12)
		err(1, "read");

	if (strncmp((const char *)hdrbuf, "FWCF", 4))
		errx(1, "file format error");

	outer = LOADT(hdrbuf + 4);
	if (hdrbuf[7] != FWCF_VER)
		errx(1, "wrong file version %02Xh", hdrbuf[7]);
	inner = LOADT(hdrbuf + 8);
	c = hdrbuf[11];

	if (((cdata = malloc(outer)) == NULL) ||
	    ((udata = malloc(inner)) == NULL))
		err(1, "malloc");
	memcpy(cdata, hdrbuf, 12);
	if ((size_t)read(fd, cdata + 12, outer - 12) != (outer - 12))
		err(1, "read");

	ADLER_START(cdata)
	unsigned len = outer - 4;
	ADLER_RUN
	if ((s1 != LOADW(cdata + outer - 4)) ||
	    (s2 != LOADW(cdata + outer - 2)))
		errx(1, "crc mismatch: %02X%02X%02X%02X != %04X%04X",
		    cdata[outer - 1], cdata[outer - 2], cdata[outer - 3],
		    cdata[outer - 4], s2, s1);
	ADLER_END

	if ((x = compressor_get(c)->decompress(udata, inner, cdata + 12,
	    outer - 12)) != inner)
		errx(1, "size mismatch: decompressed %d, want %d", x, inner);
	free(cdata);
d86 3
a88 13
	ft_dump(udata);
	return (0);
}

static int
list_compressors(void)
{
	int rv;

	printf("List of registered compressors:\n");
	if ((rv = compress_list()))
		printf("No compressor registered!\n");
	return (rv);
@


1.2
log
@code sharing and cleanup
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.1 2006/09/16 05:52:09 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: contrib/hosted/fwcf/unfwcf/unfwcf.c,v 1.1 2006/09/16 05:52:09 tg Exp $");
d128 2
a129 1
	return ((size_t)write(1, udata, inner) == inner ? 0 : 1);
@


1.1
log
@already unpacking (incl. decompressing with both algos) the inner filesystem
@
text
@d1 1
a1 1
/* $MirOS: contrib/hosted/fwcf/mkfwcf/mkfwcf.c,v 1.7 2006/09/16 04:40:25 tg Exp $ */
d34 1
d39 1
a39 1
__RCSID("$MirOS: contrib/hosted/fwcf/mkfwcf/mkfwcf.c,v 1.7 2006/09/16 04:40:25 tg Exp $");
d91 1
a91 2
	size_t outer, inner;
	fwcf_compressor *complist;
a92 1
	uint32_t x;
d100 1
a100 1
	outer = hdrbuf[4] | (hdrbuf[5] << 8) | (hdrbuf[6] << 16);
d103 1
a103 1
	inner = hdrbuf[8] | (hdrbuf[9] << 8) | (hdrbuf[10] << 16);
a105 8
	if ((complist = compress_enumerate()) == NULL)
		errx(1, "compress_enumerate");
	if (complist[c].name == NULL)
		errx(1, "compression algorithm %02Xh not found", c);
	if (complist[c].init())
		errx(1, "cannot initialise %s compression",
		     complist[c].name);

a111 23
	memcpy(hdrbuf, cdata + outer - 4, 4);
	{
		uint8_t *buf = (uint8_t *)cdata;
		unsigned s1 = 1, s2 = 0, n, len = outer - 4;

#define BASE	65521	/* largest prime smaller than 65536 */
#define NMAX	5552	/* largest n: 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
		while (len) {
			len -= (n = MIN(len, NMAX));
			while (n--) {
				s1 += *buf++;
				s2 += s1;
			}
			s1 %= BASE;
			s2 %= BASE;
		}
#undef BASE
#undef NMAX
		if (((hdrbuf[0] | ((unsigned)hdrbuf[1] << 8)) != s1) ||
		    ((hdrbuf[2] | ((unsigned)hdrbuf[3] << 8)) != s2))
			errx(1, "crc mismatch: %02X%02X%02X%02X != %04X%04X",
			    hdrbuf[3], hdrbuf[2], hdrbuf[1], hdrbuf[0], s2, s1);
	}
d113 11
a123 1
	if ((x = complist[c].decompress(udata, inner, cdata + 12,
@

