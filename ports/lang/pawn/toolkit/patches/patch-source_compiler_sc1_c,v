head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 tg:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2008.08.08.15.53.57;  author tg;  state Exp;
branches 1.1.1.1;
next     ;
commitid        100489C6BDF38E32927;

1.1.1.1
date     2008.08.08.15.53.57;  author tg;  state Exp;
branches ;
next     ;
commitid        100489C6BDF38E32927;


desc
@@



1.1
log
@Initial revision
@
text
@$MirOS$
--- source/compiler/sc1.c.orig	Thu Mar  6 13:17:51 2008
+++ source/compiler/sc1.c	Fri Aug  8 14:05:02 2008
@@@@ -62,10 +62,12 @@@@
 
 #include "lstring.h"
 #include "sc.h"
-#if defined __LINUX__ || defined __FreeBSD__ || defined __OpenBSD__
+#if defined __LINUX__ || defined BSD
   #include <sclinux.h>
+#ifndef MP_PREFIX
   #include <binreloc.h> /* from BinReloc, see www.autopackage.org */
 #endif
+#endif
 
 #include "svnrev.h"
 #define VERSION_STR "3.3." SVN_REVSTR
@@@@ -1359,6 +1361,8 @@@@ static void setconfig(char *root)
     /* add the default "include" directory */
     #if defined __WIN32__ || defined _WIN32
       GetModuleFileName(NULL,path,_MAX_PATH);
+    #elif defined(MP_PREFIX)
+      strlcpy(path, MP_PREFIX "/share/pawn/.", sizeof (path));
     #elif defined __LINUX__ || defined __FreeBSD__ || defined __OpenBSD__
       /* see www.autopackage.org for the BinReloc module */
       br_init_lib(NULL);
@@@@ -4263,7 +4267,7 @@@@ static void make_report(symbol *root,FIL
       continue;
     if ((sym->usage & uREAD)==0)
       continue;
-    fprintf(log,"\t\t<member name=\"T:%s\" value=\"%ld\">\n",funcdisplayname(symname,sym->name),sym->addr);
+    fprintf(log,"\t\t<member name=\"T:%s\" value=\"%ld\">\n",funcdisplayname(symname,sym->name),(unsigned long)sym->addr);
     if (sym->tag!=0) {
       tagsym=find_tag_byval(sym->tag);
       assert(tagsym!=NULL);
@@@@ -4273,7 +4277,7 @@@@ static void make_report(symbol *root,FIL
     if ((enumroot=sym->dim.enumlist)!=NULL) {
       enumroot=enumroot->next;  /* skip root */
       while (enumroot!=NULL) {
-        fprintf(log,"\t\t\t<member name=\"C:%s\" value=\"%ld\">\n",funcdisplayname(symname,enumroot->name),enumroot->value);
+        fprintf(log,"\t\t\t<member name=\"C:%s\" value=\"%ld\">\n",funcdisplayname(symname,enumroot->name),(unsigned long)enumroot->value);
         /* find the constant with this name and get the tag */
         ref=findglb(enumroot->name,sGLOBAL);
         if (ref!=NULL) {
@@@@ -4309,7 +4313,7 @@@@ static void make_report(symbol *root,FIL
       continue;
     if ((sym->usage & uREAD)==0 || (sym->usage & (uENUMFIELD | uENUMROOT))!=0)
       continue;
-    fprintf(log,"\t\t<member name=\"C:%s\" value=\"%ld\">\n",funcdisplayname(symname,sym->name),sym->addr);
+    fprintf(log,"\t\t<member name=\"C:%s\" value=\"%ld\">\n",funcdisplayname(symname,sym->name),(unsigned long)sym->addr);
     if (sym->tag!=0) {
       tagsym=find_tag_byval(sym->tag);
       assert(tagsym!=NULL);
@@@@ -4342,7 +4346,7 @@@@ static void make_report(symbol *root,FIL
           fprintf(log,"[%ld]",(long)ref->dim.array.length);
       } /* for */
     } /* if */
-    fprintf(log,"\">\n",funcdisplayname(symname,sym->name));
+    fprintf(log,"\">\n");
     if (sym->tag!=0) {
       tagsym=find_tag_byval(sym->tag);
       assert(tagsym!=NULL);
@


1.1.1.1
log
@Add a couple of ports required for the customer whose job I'll now be
handling: the Pawn scripting language (of which E17's Embryo is a fork),
a gtk-server binary port (for quick testing; we'll probably want a na-
tive one in both GTK+1.2 and GTK+2 flavours), and libffi from base-gcj.
@
text
@@
