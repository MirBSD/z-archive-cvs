head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2014.01.07.13.05.47;	author tg;	state dead;
branches;
next	1.3;
commitid	10052CBFBBB38A00412;

1.3
date	2008.12.21.02.37.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	100494DABC9167B3B82;

1.2
date	2008.11.11.05.30.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	100491918A84F0245BD;

1.1
date	2008.11.10.20.30.55;	author tg;	state Exp;
branches;
next	;
commitid	10049189A1037809661;


desc
@@


1.4
log
@kill LLVM+Clang and llvm-gcc ports; see transcript of #MirBSD on Freenode of today for details
if any, these may be resurrected build-depending on gcc… probably 4.8+, at least 4.7

note: gcc 4.4 “bootstrap-only” port is almost finished, as preliminary stage
(though we could choose 4.7 for that, too…)
@
text
@$MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.3 2008/12/21 02:37:31 tg Exp $

	Available back to the FSF under copyright assignment;
	Apple and LLVM are of course also invited to take it.

--- gcc/config/mirbsd.h.orig	Sat Dec 20 22:55:01 2008
+++ gcc/config/mirbsd.h	Sun Dec 21 01:39:16 2008
@@@@ -0,0 +1,355 @@@@
+/* $MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.3 2008/12/21 02:37:31 tg Exp $ */
+
+/* Base configuration file for all MirOS BSD targets on llvm-gcc.
+   Copyright (c) 2008 Free Software Foundation, Inc.
+   Contributed by Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
+
+This file is part of LLVM-GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+/* TARGET_OS_CPP_BUILTINS() common to all MirOS BSD targets.  */
+#define MIRBSD_OS_CPP_BUILTINS()			\
+  do							\
+    {							\
+      builtin_define ("__MirBSD__");			\
+      builtin_define ("__OpenBSD__");			\
+      builtin_define ("__unix__");			\
+      builtin_define ("__STDC_ISO_10646__=200009L");	\
+      builtin_assert ("system=unix");			\
+      builtin_assert ("system=bsd");			\
+      builtin_assert ("system=MirBSD");			\
+    }							\
+  while (0)
+
+
+/* CPP_SPEC parts common to all MirOS BSD targets.  */
+#ifdef CPP_CPU_SPEC
+#define MIRBSD_CPP_SPEC			\
+  "%(cpp_cpu) 				\
+   %{posix:-D_POSIX_SOURCE}		\
+   %{pthread:-D_POSIX_THREADS}"
+#else
+#define MIRBSD_CPP_SPEC			\
+  "%{posix:-D_POSIX_SOURCE}		\
+   %{pthread:-D_POSIX_THREADS}"
+#endif
+
+#undef CPP_SPEC
+#define CPP_SPEC			MIRBSD_CPP_SPEC
+
+
+/* Since we use gas, stdin -> - is a good idea.  */
+#define AS_NEEDS_DASH_FOR_PIPED_INPUT
+
+
+/* Look for the include files in the system-defined places.  */
+#undef INCLUDE_DEFAULTS
+#define INCLUDE_DEFAULTS				\
+  {							\
+    { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1 },		\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1 },	\
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1 },	\
+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 }, \
+    { 0, 0, 0, 0 }					\
+  }
+
+
+/* Provide a LIB_SPEC appropriate for MirOS BSD.  */
+
+#define MIRBSD_LIB_SPEC		\
+  "%{pthread:-lpthread}		\
+   %{!shared:			\
+     %{!symbolic:-lc}}"
+
+#undef LIB_SPEC
+#define LIB_SPEC		MIRBSD_LIB_SPEC
+
+
+/* Otherwise, since we support weak, gthr.h erroneously tries to use
+   #pragma weak.  */
+#define GTHREAD_USE_WEAK 0
+
+/* Handle #pragma weak and #pragma pack.  */
+
+#define HANDLE_SYSV_PRAGMA 1
+
+/* Define this so we can compile MS code for use with WINE.  */
+#define HANDLE_PRAGMA_PACK_PUSH_POP 1
+
+
+/* Define some types that are the same on all MirOS BSD platforms,
+   making them agree with <machine/ansi.h>.  */
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 16
+
+#undef WINT_TYPE
+#define WINT_TYPE "unsigned int"
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "long unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "long int"
+
+
+/* This defines which switch letters take arguments.  On MirOS, most
+   of the normal cases (defined by gcc.c) apply.  */
+
+#undef SWITCH_TAKES_ARG
+#define SWITCH_TAKES_ARG(CHAR)			\
+  (DEFAULT_SWITCH_TAKES_ARG (CHAR)		\
+   || (CHAR) == 'R')
+
+
+/* Provide a STARTFILE_SPEC appropriate for MirOS BSD.  Here we
+   provide support for the special GCC option -static.  On ELF
+   targets, we also add the crtbegin.o file, which provides part
+   of the support for getting C++ file-scope static objects
+   constructed before entering "main".  */
+
+#define MIRBSD_STARTFILE_SPEC	\
+  "%:if-exists(crti%O%s)	\
+   %{!shared:crt0%O%s}		\
+   %{static:			\
+     %:if-exists-else(crtbeginT%O%s crtbegin%O%s)} \
+   %{!static:			\
+     %{!shared:crtbegin%O%s}	\
+     %{shared:crtbeginS%O%s}}"
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC MIRBSD_STARTFILE_SPEC
+
+
+/* Provide an ENDFILE_SPEC appropriate for MirOS BSD.  Here we
+   add crtend.o, which provides part of the support for getting
+   C++ file-scope static objects deconstructed after exiting "main".  */
+
+#define MIRBSD_ENDFILE_SPEC	\
+  "%{!shared:crtend%O%s}	\
+   %{shared:crtendS%O%s}	\
+   %:if-exists(crtn%O%s)"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC MIRBSD_ENDFILE_SPEC
+
+
+/*
+ * Work around gcc version-specific library vs rpath problem.
+ * Components are:
+ *	%R = sysroot præfix (usually empty)
+ *	STANDARD_EXEC_PREFIX = “${PREFIX}/lib/gcc/”
+ *	DEFAULT_TARGET_MACHINE = “${OStriplet}”
+ *	DEFAULT_TARGET_VERSION = “4.2.1”
+ */
+#undef MIRPORTS_RPATH
+#define MIRPORTS_RPATH	"-rpath %R" STANDARD_EXEC_PREFIX \
+			    DEFAULT_TARGET_MACHINE "/" DEFAULT_TARGET_VERSION
+
+/* Provide a LINK_SPEC appropriate for MirOS BSD.  Here we provide
+   support for the special GCC options -assert, -R, -rpath, -shared,
+   -nostdlib, -static, -rdynamic, and -dynamic-linker.
+
+   Target-specific code can use this in conjunction with any other
+   target-specific LINK_SPEC options.  */
+
+#define MIRBSD_LINK_SPEC			\
+  "%{assert*}					\
+   %{R*} %{rpath*} " MIRPORTS_RPATH "		\
+   %{!shared:					\
+     -dc -dp					\
+     %{!nostdlib:%{!r*:%{!e*:-e __start}}}	\
+     %{!static:					\
+       %{rdynamic:-export-dynamic}		\
+       %{!dynamic-linker:			\
+	 -dynamic-linker /usr/libexec/ld.so}}	\
+     %{static:-Bstatic}}			\
+   %{!static:-Bdynamic}				\
+   %{shared:-shared}"
+
+#undef LINK_SPEC
+#define LINK_SPEC MIRBSD_LINK_SPEC
+
+
+/* This is to address issues with libgcc: some of the functions are
+   also provided by libc, and we prefer these due to them being less
+   buggy.  Since we always use GNU ld, we can use the libs grouping
+   feature to prevent listing the libraries two or three times each.  */
+#undef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC "--start-group %L %G --end-group"
+
+
+/* MirOS BSD targets need to make the stack executable.  */
+
+#undef ENABLE_EXECUTE_STACK
+#define ENABLE_EXECUTE_STACK						\
+extern void __enable_execute_stack (void *);				\
+void									\
+__enable_execute_stack (void *addr)					\
+{									\
+  static intptr_t size = 0;						\
+  static intptr_t mask;							\
+  intptr_t page = (intptr_t)addr;					\
+  size_t end = (intptr_t)addr + TRAMPOLINE_SIZE;			\
+									\
+  if (size == 0)							\
+    {									\
+      size = sysconf(_SC_PAGESIZE);					\
+      mask = ~(size - 1);						\
+    }									\
+									\
+  page &= mask;								\
+  end = (end & mask) + size - page;					\
+									\
+  if (mprotect ((char *)page, end,					\
+   PROT_READ | PROT_WRITE | PROT_EXEC) < 0)				\
+    perror ("mprotect of trampoline code");				\
+}
+
+
+/* Support of shared libraries, mostly imported from svr4.h through netbsd.  */
+/* Two differences from svr4.h:
+   - we use . - _func instead of a local label,
+   - we put extra spaces in expressions such as
+     .type _func , @@function
+     This is more readable for a human being and confuses cxxfilt less.  */
+
+/* Assembler format: output and generation of labels.  */
+
+/* Define the strings used for the .type and .size directives.
+   These strings generally do not vary from one system running BSD
+   to another, but if a given system needs to use different pseudo-op
+   names for these, they may be overridden in the arch specific file.  */
+
+#undef TYPE_ASM_OP
+#undef SIZE_ASM_OP
+#undef SET_ASM_OP
+#undef GLOBAL_ASM_OP
+
+#define TYPE_ASM_OP	"\t.type\t"
+#define SIZE_ASM_OP	"\t.size\t"
+#define SET_ASM_OP	"\t.set\t"
+#define GLOBAL_ASM_OP	"\t.globl\t"
+
+/* The following macro defines the format used to output the second
+   operand of the .type assembler directive.  */
+#undef TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT	"@@%s"
+
+/* Provision if extra assembler code is needed to declare a function's result
+   (taken from svr4, not needed yet actually).  */
+#ifndef ASM_DECLARE_RESULT
+#define ASM_DECLARE_RESULT(FILE, RESULT)
+#endif
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries under MirOS.  These macros also have to output the starting
+   labels for the relevant functions/objects.  */
+
+/* Extra assembler code needed to declare a function properly.
+   Some assemblers may also need to also have something extra said
+   about the function's return value.  We allow for that here.  */
+#undef ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+  do {									\
+	fprintf (FILE, "%s", TYPE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	fputs (" , ", FILE);						\
+	fprintf (FILE, TYPE_OPERAND_FMT, "function");			\
+	putc ('\n', FILE);						\
+	ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));			\
+	ASM_OUTPUT_LABEL(FILE, NAME);					\
+  } while (0)
+
+/* Declare the size of a function.  */
+#undef ASM_DECLARE_FUNCTION_SIZE
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do {									\
+	if (!flag_inhibit_size_directive) {				\
+		fprintf (FILE, "%s", SIZE_ASM_OP);			\
+		assemble_name (FILE, (FNAME));				\
+		fputs (" , . - ", FILE);				\
+		assemble_name (FILE, (FNAME));				\
+		putc ('\n', FILE);					\
+	}								\
+  } while (0)
+
+/* Extra assembler code needed to declare an object properly.  */
+#undef ASM_DECLARE_OBJECT_NAME
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
+  do {									\
+	fprintf (FILE, "%s", TYPE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	fputs (" , ", FILE);						\
+	fprintf (FILE, TYPE_OPERAND_FMT, "object");			\
+	putc ('\n', FILE);						\
+	size_directive_output = 0;					\
+	if (!flag_inhibit_size_directive && (DECL) &&			\
+	    DECL_SIZE (DECL)) {						\
+		size_directive_output = 1;				\
+		fprintf (FILE, "%s", SIZE_ASM_OP);			\
+		assemble_name (FILE, NAME);				\
+		fprintf (FILE, " , %ld\n",				\
+		    int_size_in_bytes (TREE_TYPE (DECL)));		\
+	}								\
+	ASM_OUTPUT_LABEL (FILE, NAME);					\
+  } while (0)
+
+/* Output the size directive for a decl in rest_of_decl_compilation
+   in the case where we did not do so before the initializer.
+   Once we find the error_mark_node, we know that the value of
+   size_directive_output was set by ASM_DECLARE_OBJECT_NAME
+   when it was run for the same decl.  */
+#undef ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	\
+do {									\
+	const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);		\
+	if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		\
+	    && ! AT_END && TOP_LEVEL					\
+	    && DECL_INITIAL (DECL) == error_mark_node			\
+	    && !size_directive_output) {				\
+		size_directive_output = 1;				\
+		fprintf (FILE, "%s", SIZE_ASM_OP);			\
+		assemble_name (FILE, name);				\
+		fprintf (FILE, " , %ld\n",				\
+		    int_size_in_bytes (TREE_TYPE (DECL)));		\
+	}								\
+   } while (0)
+
+/* Those are 'generic' ways to weaken/globalize a label. We shouldn't need
+   to override a processor specific definition. Hence, #ifndef ASM_*
+   In case overriding turns out to be needed, one can always #undef ASM_*
+   before including this file.  */
+
+/* Tell the assembler that a symbol is weak.  */
+/* Note: netbsd arm32 assembler needs a .globl here. An override may
+   be needed when/if we go for arm32 support.  */
+#ifndef ASM_WEAKEN_LABEL
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
+#endif
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>
@


1.3
log
@fix rpath problem for version specific libs in the compiler configuration;
I believe this is the only way feasible

this will probably be applied to the base compiler sometime as well, and
its libraries be moved and major-bumped (intermixing is an issue anyway)
@
text
@d1 1
a1 1
$MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.2 2008/11/11 05:30:59 tg Exp $
d9 1
a9 1
+/* $MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.2 2008/11/11 05:30:59 tg Exp $ */
@


1.2
log
@Clean up the port a little
• cut down un unneeded dependencies
• enable threads, workaround enough to make them build
• include some more basic mnbsd configuration
• overhaul mbsd configuration to more match mgcc from base
  (it’s unknown if this one were suitable for native code
  generation, but quite possible)
• enable DWARF2 unwinding (sjlj exceptions didn’t quite work)
• compile fixes for building this with llvm-gcc4.2 gnu99 itself (inlining…)

This compiler has produced a working lang/llvm package.
@
text
@d1 9
a9 5
$MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.1 2008/11/10 20:30:55 tg Exp $
--- gcc/config/mirbsd.h.orig	Tue Nov 11 01:56:31 2008
+++ gcc/config/mirbsd.h	Tue Nov 11 01:56:31 2008
@@@@ -0,0 +1,343 @@@@
+/* $MirOS: ports/lang/llvm-gcc/patches/patch-gcc_config_mirbsd_h,v 1.1 2008/11/10 20:30:55 tg Exp $ */
d19 1
a19 2
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
d162 12
d182 2
a183 1
+  "%{assert*} %{R*} %{rpath*}			\
@


1.1
log
@say hello to llvm-gcc
@
text
@d1 41
a41 8
$MirOS$

	hacky, not recommended to feed upstream

--- gcc/config/mirbsd.h.orig	Thu Jan  1 00:00:00 1970
+++ gcc/config/mirbsd.h	Sun Nov  9 22:37:21 2008
@@@@ -0,0 +1,258 @@@@
+/* $MirOS$ */
a42 26
+/* The compiler is configured with ONLY the gcc/g++ standard headers.  */
+#undef INCLUDE_DEFAULTS
+#define INCLUDE_DEFAULTS			\
+  {						\
+    { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1 },	\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1 }, \
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1 }, \
+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 }, \
+    { 0, 0, 0, 0 }				\
+  }
+
+/* Controlling the compilation driver.  */
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD targets.  */
+#define MIRBSD_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__MirBSD__");		\
+      builtin_define ("__OpenBSD__");		\
+      builtin_define ("__unix__");		\
+      builtin_define ("__STDC_ISO_10646__=200009L");		\
+      builtin_define ("__ANSI_COMPAT");		\
+      builtin_assert ("system=unix");		\
+      builtin_assert ("system=bsd");		\
+      builtin_assert ("system=MirBSD");		\
+    }						\
+  while (0)
d44 1
d59 19
d86 35
d122 2
a123 2
+#define SWITCH_TAKES_ARG(CHAR) \
+  (DEFAULT_SWITCH_TAKES_ARG (CHAR) \
a125 2
+/* Since we use gas, stdin -> - is a good idea.  */
+#define AS_NEEDS_DASH_FOR_PIPED_INPUT
d158 8
d182 51
d256 1
a256 1
+   entries under OpenBSD.  These macros also have to output the starting 
a258 1
+#ifndef OBSD_HAS_DECLARE_FUNCTION_NAME
d260 1
a260 1
+   Some assemblers may also need to also have something extra said 
d265 7
a271 3
+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "function");			\
+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));			\
+    ASM_OUTPUT_LABEL(FILE, NAME);					\
a272 1
+#endif
a273 1
+#ifndef OBSD_HAS_DECLARE_FUNCTION_SIZE
d276 9
a284 4
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)		\
+  do {								\
+    if (!flag_inhibit_size_directive)				\
+      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);			\
a285 1
+#endif
a286 1
+#ifndef OBSD_HAS_DECLARE_OBJECT
d289 17
a305 13
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)		\
+  do {								\
+      HOST_WIDE_INT size;					\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");		\
+      size_directive_output = 0;				\
+      if (!flag_inhibit_size_directive				\
+	  && (DECL) && DECL_SIZE (DECL))			\
+	{							\
+	  size_directive_output = 1;				\
+	  size = int_size_in_bytes (TREE_TYPE (DECL));		\
+	  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, size);		\
+	}							\
+      ASM_OUTPUT_LABEL (FILE, NAME);				\
d311 1
a311 1
+   size_directive_output was set by ASM_DECLARE_OBJECT_NAME 
d314 13
a326 13
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	 \
+do {									 \
+     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);		 \
+     HOST_WIDE_INT size;						 \
+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		 \
+         && ! AT_END && TOP_LEVEL					 \
+	 && DECL_INITIAL (DECL) == error_mark_node			 \
+	 && !size_directive_output)					 \
+       {								 \
+	 size_directive_output = 1;					 \
+	 size = int_size_in_bytes (TREE_TYPE (DECL));			 \
+	 ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);			 \
+       }								 \
a327 1
+#endif
d329 1
a329 2
+
+/* Those are `generic' ways to weaken/globalize a label. We shouldn't need
d331 1
a331 1
+   In case overriding turns out to be needed, one can always #undef ASM_* 
d335 1
a335 1
+/* Note: netbsd arm32 assembler needs a .globl here. An override may 
a341 46
+
+/* Storage layout.  */
+
+
+/* Otherwise, since we support weak, gthr.h erroneously tries to use
+   #pragma weak.  */
+#define GTHREAD_USE_WEAK 0
+
+/* bug work around: we don't want to support #pragma weak, but the current
+   code layout needs HANDLE_PRAGMA_WEAK asserted for __attribute((weak)) to
+   work.  On the other hand, we don't define HANDLE_PRAGMA_WEAK directly,
+   as this depends on a few other details as well...  */
+#define HANDLE_SYSV_PRAGMA 1
+
+/* Stack is explicitly denied execution rights on OpenBSD platforms.  */
+#define ENABLE_EXECUTE_STACK						\
+extern void __enable_execute_stack (void *);				\
+void									\
+__enable_execute_stack (void *addr)					\
+{									\
+  long size = getpagesize ();						\
+  long mask = ~(size-1);						\
+  char *page = (char *) (((long) addr) & mask); 			\
+  char *end  = (char *) ((((long) (addr + TRAMPOLINE_SIZE)) & mask) + size); \
+								      \
+  if (mprotect (page, end - page, PROT_READ | PROT_WRITE | PROT_EXEC) < 0) \
+    perror ("mprotect of trampoline code");				\
+}
+
+/* Define some types that are the same on all MirOS BSD platforms,
+   making them agree with <machine/ansi.h>.  */
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 16
+
+#undef WINT_TYPE
+#define WINT_TYPE "unsigned int"
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "long unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "long int"
d345 3
@

