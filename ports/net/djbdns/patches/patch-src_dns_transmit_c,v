head	1.7;
access;
symbols;
locks; strict;
comment	@# @;


1.7
date	2017.03.15.22.33.32;	author tg;	state Exp;
branches;
next	1.6;
commitid	10058C9C1502E84F0A3;

1.6
date	2017.03.15.22.32.27;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058C9C1092C8FA5EA;

1.5
date	2017.03.15.22.14.08;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058C9BCAF663F20CC;

1.4
date	2016.03.26.17.29.20;	author tg;	state Exp;
branches;
next	1.3;
commitid	10056F6C535787D61F0;

1.3
date	2006.07.27.00.58.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044C80EE124197593;

1.2
date	2005.12.14.23.28.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043A0AA0E5A220A51;

1.1
date	2005.05.14.23.21.02;	author tg;	state Exp;
branches
	1.1.201.1;
next	;
commitid	1e94428687d39445;

1.1.201.1
date	2005.05.14.23.21.02;	author tg;	state Exp;
branches;
next	;
commitid	1e94428687d39445;


desc
@@


1.7
log
@next attempt at fixing the build…
@
text
@$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.6 2017/03/15 22:32:27 tg Exp $
--- src/dns_transmit.c.orig	Sun Feb 11 21:11:23 2001
+++ src/dns_transmit.c	Wed Mar 15 22:23:55 2017
@@@@ -7,6 +7,8 @@@@
 #include "byte.h"
 #include "uint16.h"
 #include "dns.h"
+#include "log.h"
+#include "ip6.h"
 
 static int serverwantstcp(const char *buf,unsigned int len)
 {
@@@@ -80,14 +82,32 @@@@ void dns_transmit_free(struct dns_transm
   packetfree(d);
 }
 
-static int randombind(struct dns_transmit *d)
+static int randombind(struct dns_transmit *d, int callv4)
 {
   int j;
+  char localip[16];
 
+  byte_copy(localip,16,d->localip);
+
+  if (/* v4 nameserver */ callv4) {
+    if (!ip6_isv4mapped(localip) /* and it's not :: but that's ok */) {
+      /* v6 IPSEND (but not IN6ADDR_ANY) is ignored in favour of 0.0.0.0 */
+      /*XXX consider having two IPSENDs */
+      byte_zero(localip+12,4);
+    }
+
+    for (j = 0;j < 10;++j)
+      if (socket_bind4(d->s1 - 1,localip + 12,1025 + dns_random(64510)) == 0)
+        return 0;
+    if (socket_bind4(d->s1 - 1,localip + 12,0) == 0)
+      return 0;
+    return -1;
+  }
+
   for (j = 0;j < 10;++j)
-    if (socket_bind4(d->s1 - 1,d->localip,1025 + dns_random(64510)) == 0)
+    if (socket_bind6(d->s1 - 1,localip,1025 + dns_random(64510),d->scope_id) == 0)
       return 0;
-  if (socket_bind4(d->s1 - 1,d->localip,0) == 0)
+  if (socket_bind6(d->s1 - 1,localip,0,d->scope_id) == 0)
     return 0;
   return -1;
 }
@@@@ -102,16 +122,25 @@@@ static int thisudp(struct dns_transmit *
 
   while (d->udploop < 4) {
     for (;d->curserver < 16;++d->curserver) {
-      ip = d->servers + 4 * d->curserver;
-      if (byte_diff(ip,4,"\0\0\0\0")) {
+      ip = d->servers + 16 * d->curserver;
+      if (byte_diff(ip,16,V6any) && byte_diff(ip,16,V4any)) {
+	int callv4 = ip6_isv4mapped(ip);
+
+	if (!callv4 && ip6_isv4mapped(d->localip)) {
+	  /* v6 nameserver but v4 IPSEND */
+	  log_dropns(d->localip, ip);
+	  continue;
+	}
+
 	d->query[2] = dns_random(256);
 	d->query[3] = dns_random(256);
   
-        d->s1 = 1 + socket_udp();
+        d->s1 = 1 + (callv4 ? socket_udp() : socket_udp6());
         if (!d->s1) { dns_transmit_free(d); return -1; }
-	if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
+	if (randombind(d,callv4) == -1) { dns_transmit_free(d); return -1; }
 
-        if (socket_connect4(d->s1 - 1,ip,53) == 0)
+	if ((callv4 ? socket_connect4(d->s1 - 1,ip + 12,53)
+	 : socket_connect6(d->s1 - 1,ip,53,d->scope_id)) == 0)
           if (send(d->s1 - 1,d->query + 2,d->querylen - 2,0) == d->querylen - 2) {
             struct taia now;
             taia_now(&now);
@@@@ -153,19 +182,21 @@@@ static int thistcp(struct dns_transmit *
   packetfree(d);
 
   for (;d->curserver < 16;++d->curserver) {
-    ip = d->servers + 4 * d->curserver;
-    if (byte_diff(ip,4,"\0\0\0\0")) {
+    ip = d->servers + 16 * d->curserver;
+    if (byte_diff(ip,16,V6any) && byte_diff(ip,16,V4any)) {
+      int callv4 = byte_equal(ip,12,V4mappedprefix);
       d->query[2] = dns_random(256);
       d->query[3] = dns_random(256);
 
-      d->s1 = 1 + socket_tcp();
+      d->s1 = 1 + (callv4 ? socket_tcp() : socket_tcp6());
       if (!d->s1) { dns_transmit_free(d); return -1; }
-      if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
+      if (randombind(d,callv4) == -1) { dns_transmit_free(d); return -1; }
   
       taia_now(&now);
       taia_uint(&d->deadline,10);
       taia_add(&d->deadline,&d->deadline,&now);
-      if (socket_connect4(d->s1 - 1,ip,53) == 0) {
+      if ((callv4 ? socket_connect4(d->s1 - 1,ip + 12,53)
+       : socket_connect6(d->s1 - 1,ip,53,d->scope_id)) == 0) {
         d->tcpstate = 2;
         return 0;
       }
@@@@ -193,7 +224,7 @@@@ static int nexttcp(struct dns_transmit *
   return thistcp(d);
 }
 
-int dns_transmit_start(struct dns_transmit *d,const char servers[64],int flagrecursive,const char *q,const char qtype[2],const char localip[4])
+int dns_transmit_start(struct dns_transmit *d,const char servers[256],int flagrecursive,const char *q,const char qtype[2],const char localip[16])
 {
   unsigned int len;
 
@@@@ -213,7 +244,7 @@@@ int dns_transmit_start(struct dns_transm
 
   byte_copy(d->qtype,2,qtype);
   d->servers = servers;
-  byte_copy(d->localip,4,localip);
+  byte_copy(d->localip,16,localip);
 
   d->udploop = flagrecursive ? 1 : 0;
 
@


1.6
log
@fix ignoring 0.0.0.0 (broken by Fefe ignoring only ::)
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.5 2017/03/15 22:14:08 tg Exp $
d3 2
a4 2
+++ src/dns_transmit.c	Wed Mar 15 22:21:06 2017
@@@@ -7,6 +7,7 @@@@
d8 1
@


1.5
log
@handle calling v6 servers with a v4 IPSEND (by dropping the server loudly)

discovered thanks to multiplexd from IRC
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.4 2016/03/26 17:29:20 tg Exp $
d3 1
a3 1
+++ src/dns_transmit.c	Wed Mar 15 22:12:16 2017
d12 1
a12 1
@@@@ -80,14 +81,32 @@@@ void dns_transmit_free(struct dns_transm
d48 1
a48 1
@@@@ -102,16 +121,25 @@@@ static int thisudp(struct dns_transmit *
d55 1
a55 1
+      if (byte_diff(ip,16,V6any)) {
d79 1
a79 1
@@@@ -153,19 +181,21 @@@@ static int thistcp(struct dns_transmit *
d86 1
a86 1
+    if (byte_diff(ip,16,V6any)) {
d106 1
a106 1
@@@@ -193,7 +223,7 @@@@ static int nexttcp(struct dns_transmit *
d115 1
a115 1
@@@@ -213,7 +243,7 @@@@ int dns_transmit_start(struct dns_transm
@


1.4
log
@complete overhaul of djbdns port:

• merge t4/t6 flavours back into one binary
  ‣ greatly simplify IPv6 handling, too; drop code for v6-less OSes
• merge v4/v6 dnsroots back into one, update all of them
• improve documentation a bit
• apply two patches from http://www.your.org/dnscache/ (SECURITY):
  ‣ merge identical outgoing requests
  ‣ allow caching SOA responses
• update to Fefe’s djbdns-1.05-test27.diff.bz2
  ‣ fixes recursively resolving hosts behind IPv6-only nameservers;
    spotted by Natureshadow (for Teckids’ Lunatics network) and via
    http://serverfault.com/q/627912/189656 (which I’ll answer RSN)
  ⚠ fix with “one second” CDB validity patch
  ⚠ adapt for OpenBSD-style IPv6
• drop ip6.int. reverse v6 DNS for good
• improve dealing with mixing v4/v6 transport
  ⇒ TODO add IP4SEND/IP6SEND support; currently; if IPSEND is v6
    but we send to a v4 server, we use INADDR_ANY for outgoing,
    as automatic fallback address
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.3 2006/07/27 00:58:16 tg Exp $
d3 1
a3 1
+++ src/dns_transmit.c	Sat Mar 26 15:26:29 2016
d12 1
a12 1
@@@@ -80,14 +81,31 @@@@ void dns_transmit_free(struct dns_transm
d24 4
a27 4
+  if (callv4 || ip6_isv4mapped(localip)) {
+    /* Calling an IPv4 server with an IPv6 localip? If so, use any. */
+    /*XXX consider having two IPSENDs */
+    if (!ip6_isv4mapped(localip))
d29 1
d48 1
a48 1
@@@@ -102,16 +120,18 @@@@ static int thisudp(struct dns_transmit *
d56 8
a63 1
+	int callv4 = byte_equal(ip,12,V4mappedprefix);
d79 1
a79 1
@@@@ -153,19 +173,21 @@@@ static int thistcp(struct dns_transmit *
d106 1
a106 1
@@@@ -193,7 +215,7 @@@@ static int nexttcp(struct dns_transmit *
d115 1
a115 1
@@@@ -213,7 +235,7 @@@@ int dns_transmit_start(struct dns_transm
@


1.3
log
@* make zonenotify connect to IPv6 (DNS or numeric) too
* make zonenotify connect to all IPs of the hostname given
* make axfrdns log IPv6 addresses (have to move it though)
  XXX pending making DJB_V6ONLY the default and only case
* put fromhex into common file while here
* centralise licence info for my diffs while here
* bump patchlevel

new zonenotify loosely tested, new axfrdns log format seems okay
thanks gecko2 for providing bind9 backup NS on ipv6
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.2 2005/12/14 23:28:32 tg Exp $
d3 2
a4 2
+++ src/dns_transmit.c	Wed Jul 26 23:42:44 2006
@@@@ -7,7 +7,18 @@@@
a7 1
+#ifdef DJB_V6ONLY
a8 1
+#endif /* DJB_V6ONLY */
a9 8
+#ifdef DJB_V6ONLY
+static int callv4 = 0;
+static int callv4ofs = 12;
+#else
+static int callv4 = 1;
+static int callv4ofs = 0;
+#endif /* DJB_V6ONLY */
+
d12 6
a17 3
   char out[12];
@@@@ -83,11 +94,26 @@@@ void dns_transmit_free(struct dns_transm
 static int randombind(struct dns_transmit *d)
d24 13
a36 9
+#ifdef DJB_V6ONLY
+  /*
+   * If we are calling an IPv4 server from an IPv6-transport tool,
+   * we probably bind ourselves to an IPv6 socket (d'uh), so, in
+   * the IPv4 case use INADDR_ANY as local bind address instead.
+   */
+  if (callv4)
+    byte_zero(localip,4);
+#endif /* DJB_V6ONLY */
d40 1
a40 2
+    if ((callv4 ? socket_bind4(d->s1 - 1,localip,1025 + dns_random(64510))
+     : socket_bind6(d->s1 - 1,localip,1025 + dns_random(64510),d->scope_id)) == 0)
d43 1
a43 2
+  if ((callv4 ? socket_bind4(d->s1 - 1,localip,0)
+   : socket_bind6(d->s1 - 1,localip,0,d->scope_id)) == 0)
d47 1
a47 1
@@@@ -102,16 +128,26 @@@@ static int thisudp(struct dns_transmit *
d51 2
a52 4
+#ifndef DJB_V6ONLY
       ip = d->servers + 4 * d->curserver;
       if (byte_diff(ip,4,"\0\0\0\0")) {
+#else
d55 1
a55 5
+	if (byte_equal(ip,12,V4mappedprefix))
+	  callv4 = 1;
+	else
+	  callv4 = 0;
+#endif /* DJB_V6ONLY */
d62 2
a63 1
 	if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
d66 1
a66 1
+	if ((callv4 ? socket_connect4(d->s1 - 1,ip + callv4ofs,53)
d71 1
a71 1
@@@@ -153,19 +189,29 @@@@ static int thistcp(struct dns_transmit *
d75 2
a76 4
+#ifndef DJB_V6ONLY
     ip = d->servers + 4 * d->curserver;
     if (byte_diff(ip,4,"\0\0\0\0")) {
+#else
d79 1
a79 5
+      if (byte_equal(ip,12,V4mappedprefix))
+	callv4 = 1;
+      else
+	callv4 = 0;
+#endif /* DJB_V6ONLY */
d86 2
a87 1
       if (randombind(d) == -1) { dns_transmit_free(d); return -1; }
d93 1
a93 1
+      if ((callv4 ? socket_connect4(d->s1 - 1,ip + callv4ofs,53)
d98 1
a98 1
@@@@ -193,7 +239,11 @@@@ static int nexttcp(struct dns_transmit *
d102 1
a102 3
+#ifndef DJB_V6ONLY
 int dns_transmit_start(struct dns_transmit *d,const char servers[64],int flagrecursive,const char *q,const char qtype[2],const char localip[4])
+#else
a103 1
+#endif /* DJB_V6ONLY */
d107 1
a107 1
@@@@ -213,7 +263,11 @@@@ int dns_transmit_start(struct dns_transm
d111 1
a111 3
+#ifndef DJB_V6ONLY
   byte_copy(d->localip,4,localip);
+#else
a112 1
+#endif /* DJB_V6ONLY */
@


1.2
log
@* update to fefe's djbdns-1.05-test23.diff
  with djbdns-1.05-ixfr.diff
* slightly change naming of v6-transport binaries
* consolidate all added source files in a central directory
  so it can be reused by the v6-transport stuff
* integrate the v6 transport binaries
* fix spacing
* sync descriptive texts with reality
* sync European ORSN (v4 and v6) to their root.hint
* sync OpenNIC too
* Open-RSC seeminly ceased to exist recently
* Apply compiler-temporary-filename.patch
  from http://homepages.tesco.net/~J.deBoynePollard/FGA/djbdns-problems.html
* apply dnscache-cname-handling.patch
* apply dnscache-strict-forwardonly.patch w/ IPv6 tweak
* apply dnscacheip-space-separator.patch
* apply tinydns-alias-chain-truncation.patch
* apply tinydns-data-semantic-error.patch
  appropriately for 6 and 3, too
* fix shell code and path to includes
* fix relative paths
* fix names of library and programmes; NOMAN=yes here (t6)
* Add support for the IPv6 transport module to communicate,
  as a client, with IPv4 transport name servers as well.

  WFM
* build it with -Wall -Werror
* honour ${SYSCONFDIR} throughout the port
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_dns_transmit_c,v 1.1.201.1 2005/05/14 23:21:02 tg Exp $
d3 2
a4 31
+++ src/dns_transmit.c	Wed Dec 14 01:59:28 2005
@@@@ -1,3 +1,28 @@@@
+/*-
+ * Some changes Copyright (c) 2005
+ *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
+ *
+ * Licensee is hereby permitted to deal in this work without restric-
+ * tion, including unlimited rights to use, publicly perform, modify,
+ * merge, distribute, sell, give away or sublicence, provided all co-
+ * pyright notices above, these terms and the disclaimer are retained
+ * in all redistributions or reproduced in accompanying documentation
+ * or other materials provided with binary redistributions.
+ *
+ * All advertising materials mentioning features or use of this soft-
+ * ware must display the following acknowledgement:
+ *	This product includes material provided by Thorsten Glaser.
+ *
+ * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
+ * express, or implied, to the maximum extent permitted by applicable
+ * law, without malicious intent or gross negligence; in no event may
+ * licensor, an author or contributor be held liable for any indirect
+ * or other damage, or direct damage except proven a consequence of a
+ * direct error of said person and intended use of this work, loss or
+ * other issues arising in any way out of its use, even if advised of
+ * the possibility of such damage or existence of a nontrivial bug.
+ */
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <unistd.h>
@@@@ -7,7 +32,18 @@@@
d23 1
a23 1
@@@@ -83,11 +119,26 @@@@ void dns_transmit_free(struct dns_transm
d52 1
a52 1
@@@@ -102,16 +153,26 @@@@ static int thisudp(struct dns_transmit *
d81 1
a81 1
@@@@ -153,19 +214,29 @@@@ static int thistcp(struct dns_transmit *
d113 1
a113 1
@@@@ -193,7 +264,11 @@@@ static int nexttcp(struct dns_transmit *
d125 1
a125 1
@@@@ -213,7 +288,11 @@@@ int dns_transmit_start(struct dns_transm
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$MirOS$
d3 31
a33 2
+++ src/dns_transmit.c	Sat May 14 22:27:17 2005
@@@@ -7,6 +7,9 @@@@
d41 8
d51 4
a54 1
@@@@ -85,9 +88,17 @@@@ static int randombind(struct dns_transmi
d56 1
d58 12
d71 3
a73 5
+#ifndef DJB_V6ONLY
     if (socket_bind4(d->s1 - 1,d->localip,1025 + dns_random(64510)) == 0)
+#else
+    if (socket_bind6(d->s1 - 1,d->localip,1025 + dns_random(64510),d->scope_id) == 0)
+#endif /* DJB_V6ONLY */
d75 3
a77 5
+#ifndef DJB_V6ONLY
   if (socket_bind4(d->s1 - 1,d->localip,0) == 0)
+#else
+  if (socket_bind6(d->s1 - 1,d->localip,0,d->scope_id) == 0)
+#endif /* DJB_V6ONLY */
d81 1
a81 1
@@@@ -102,16 +113,29 @@@@ static int thisudp(struct dns_transmit *
d91 4
d99 2
a100 5
+#ifndef DJB_V6ONLY
         d->s1 = 1 + socket_udp();
+#else
+        d->s1 = 1 + socket_udp6();
+#endif /* DJB_V6ONLY */
d104 3
a106 5
+#ifndef DJB_V6ONLY
         if (socket_connect4(d->s1 - 1,ip,53) == 0)
+#else
+        if (socket_connect6(d->s1 - 1,ip,53,d->scope_id) == 0)
+#endif /* DJB_V6ONLY */
d110 1
a110 1
@@@@ -153,19 +177,32 @@@@ static int thistcp(struct dns_transmit *
d120 4
d128 2
a129 5
+#ifndef DJB_V6ONLY
       d->s1 = 1 + socket_tcp();
+#else
+      d->s1 = 1 + socket_tcp6();
+#endif /* DJB_V6ONLY */
d136 3
a138 5
+#ifndef DJB_V6ONLY
       if (socket_connect4(d->s1 - 1,ip,53) == 0) {
+#else
+      if (socket_connect6(d->s1 - 1,ip,53,d->scope_id) == 0) {
+#endif /* DJB_V6ONLY */
d142 1
a142 1
@@@@ -193,7 +230,11 @@@@ static int nexttcp(struct dns_transmit *
d154 1
a154 1
@@@@ -213,7 +254,11 @@@@ int dns_transmit_start(struct dns_transm
@


1.1.201.1
log
@New djbdns port, #ifdef'd, "original" and "no_ipv6" flavours removed
"no_ipv4" non-functional at the moment, will follow later after
redesign using crunchgen(1) and crunchide(1)
@
text
@@
