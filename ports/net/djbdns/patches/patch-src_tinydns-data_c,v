head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2016.03.26.17.29.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	10056F6C535787D61F0;

1.4
date	2006.01.17.22.40.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043CD71AE7CE50D89;

1.3
date	2006.01.17.20.45.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043CD575B2AADC8AB;

1.2
date	2005.12.14.23.28.40;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043A0AA0E5A220A51;

1.1
date	2005.05.14.23.21.06;	author tg;	state Exp;
branches
	1.1.201.1;
next	;
commitid	1e94428687d39445;

1.1.201.1
date	2005.05.14.23.21.06;	author tg;	state Exp;
branches;
next	;
commitid	1e94428687d39445;


desc
@@


1.5
log
@complete overhaul of djbdns port:

â€¢ merge t4/t6 flavours back into one binary
  â€£ greatly simplify IPv6 handling, too; drop code for v6-less OSes
â€¢ merge v4/v6 dnsroots back into one, update all of them
â€¢ improve documentation a bit
â€¢ apply two patches from http://www.your.org/dnscache/ (SECURITY):
  â€£ merge identical outgoing requests
  â€£ allow caching SOA responses
â€¢ update to Fefeâ€™s djbdns-1.05-test27.diff.bz2
  â€£ fixes recursively resolving hosts behind IPv6-only nameservers;
    spotted by Natureshadow (for Teckidsâ€™ Lunatics network) and via
    http://serverfault.com/q/627912/189656 (which Iâ€™ll answer RSN)
  âš  fix with â€œone secondâ€ CDB validity patch
  âš  adapt for OpenBSD-style IPv6
â€¢ drop ip6.int. reverse v6 DNS for good
â€¢ improve dealing with mixing v4/v6 transport
  â‡’ TODO add IP4SEND/IP6SEND support; currently; if IPSEND is v6
    but we send to a v4 server, we use INADDR_ANY for outgoing,
    as automatic fallback address
@
text
@$MirOS: ports/net/djbdns/patches/patch-src_tinydns-data_c,v 1.4 2006/01/17 22:40:39 tg Exp $
--- src/tinydns-data.c.orig	Sun Feb 11 21:11:23 2001
+++ src/tinydns-data.c	Sat Mar 26 17:03:10 2016
@@@@ -8,6 +8,7 @@@@
 #include "byte.h"
 #include "fmt.h"
 #include "ip4.h"
+#include "ip6.h"
 #include "exit.h"
 #include "case.h"
 #include "scan.h"
@@@@ -25,29 +26,56 @@@@
 
 #define FATAL "tinydns-data: fatal: "
 
+void die_semantic2(const char * s1, const char * s2)
+{
+  strerr_die3x(111,FATAL,s1,s2);
+}
+void die_semantic4(const char * s1, const char * s2,const char * s3, const char * s4)
+{
+  strerr_die5x(111,FATAL,s1,s2,s3,s4);
+}
 void die_datatmp(void)
 {
-  strerr_die2sys(111,FATAL,"unable to create data.tmp: ");
+  strerr_die2sys(111,FATAL,"unable to create data.cdb.tmp: ");
 }
 void nomem(void)
 {
   strerr_die1sys(111,FATAL);
 }
 
+void ttlparse(stralloc *sa,unsigned long * ttl, unsigned long defttl, const char * ltype)
+{
+    int ttllen;
+
+    if (sa->len > 0) {
+	if (!stralloc_0(sa)) nomem();
+	ttllen = scan_ulong(sa->s,ttl);
+	if (ttllen + 1 != sa->len)
+	    die_semantic4("unparseable TTL in ",ltype," line: ", sa->s);
+    } else
+	*ttl = defttl;
+}
+
 void ttdparse(stralloc *sa,char ttd[8])
 {
   unsigned int i;
   char ch;
 
   byte_zero(ttd,8);
-  for (i = 0;(i < 16) && (i < sa->len);++i) {
+  for (i = 0;i < sa->len;++i) {
+    if (i >= 16) {
+      if (!stralloc_0(sa)) nomem();
+      die_semantic2("timestamp is too long: ", sa->s);
+    }
     ch = sa->s[i];
     if ((ch >= '0') && (ch <= '9'))
       ch -= '0';
     else if ((ch >= 'a') && (ch <= 'f'))
       ch -= 'a' - 10;
-    else
-      ch = 0;
+    else {
+      if (!stralloc_0(sa)) nomem();
+      die_semantic2("timestamp contains an invalid character: ", sa->s);
+    }
     if (!(i & 1)) ch <<= 4;
     ttd[i >> 1] |= ch;
   }
@@@@ -55,6 +83,10 @@@@ void ttdparse(stralloc *sa,char ttd[8])
 
 void locparse(stralloc *sa,char loc[2])
 {
+  if (sa->len > 2) {
+    if (!stralloc_0(sa)) nomem();
+    die_semantic2("location code longer than two characters: ", sa->s);
+  }
   loc[0] = (sa->len > 0) ? sa->s[0] : 0;
   loc[1] = (sa->len > 1) ? sa->s[1] : 0;
 }
@@@@ -65,16 +97,23 @@@@ void ipprefix_cat(stralloc *out,char *s)
   char ch;
   unsigned int j;
 
-  for (;;)
-    if (*s == '.')
-      ++s;
-    else {
-      j = scan_ulong(s,&u);
-      if (!j) return;
-      s += j;
-      ch = u;
-      if (!stralloc_catb(out,&ch,1)) nomem();
-    }
+  if (*s=='s') {
+    ++s;
+    if (!stralloc_catb(out,"s",1) || !stralloc_cats(out,s)) nomem();
+  } else {
+    if (*s=='f') ++s;
+    if (!stralloc_catb(out,"f",1)) nomem();
+    for (;;)
+      if (*s == '.')
+	++s;
+      else {
+	j = scan_ulong(s,&u);
+	if (!j) return;
+	s += j;
+	ch = u;
+	if (!stralloc_catb(out,&ch,1)) nomem();
+      }
+  }
 }
 
 void txtparse(stralloc *sa)
@@@@ -172,6 +211,7 @@@@ static stralloc f[NUMFIELDS];
 static char *d1;
 static char *d2;
 char dptr[DNS_NAME4_DOMAIN];
+char d6ptr[DNS_NAME6_DOMAIN];
 
 char strnum[FMT_ULONG];
 
@@@@ -187,15 +227,18 @@@@ int main()
   int i;
   int j;
   int k;
+  int iplen;
   char ch;
   unsigned long ttl;
   char ttd[8];
   char loc[2];
-  unsigned long u;
+  uint32 u;
   char ip[4];
+  char ip6[16];
   char type[2];
   char soa[20];
   char buf[4];
+  char srv[6];
 
   umask(022);
 
@@@@ -206,7 +249,7 @@@@ int main()
 
   buffer_init(&b,buffer_unixread,fddata,bspace,sizeof bspace);
 
-  fdcdb = open_trunc("data.tmp");
+  fdcdb = open_trunc("data.cdb.tmp");
   if (fdcdb == -1) die_datatmp();
   if (cdb_make_start(&cdb,fdcdb) == -1) die_datatmp();
 
@@@@ -251,23 +294,22 @@@@ int main()
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 
 	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&u)) uint32_unpack_big(defaultsoa,&u);
+	if (!scan_uint32(f[3].s,&u)) uint32_unpack_big(defaultsoa,&u);
 	uint32_pack_big(soa,u);
 	if (!stralloc_0(&f[4])) nomem();
-	if (!scan_ulong(f[4].s,&u)) uint32_unpack_big(defaultsoa + 4,&u);
+	if (!scan_uint32(f[4].s,&u)) uint32_unpack_big(defaultsoa + 4,&u);
 	uint32_pack_big(soa + 4,u);
 	if (!stralloc_0(&f[5])) nomem();
-	if (!scan_ulong(f[5].s,&u)) uint32_unpack_big(defaultsoa + 8,&u);
+	if (!scan_uint32(f[5].s,&u)) uint32_unpack_big(defaultsoa + 8,&u);
 	uint32_pack_big(soa + 8,u);
 	if (!stralloc_0(&f[6])) nomem();
-	if (!scan_ulong(f[6].s,&u)) uint32_unpack_big(defaultsoa + 12,&u);
+	if (!scan_uint32(f[6].s,&u)) uint32_unpack_big(defaultsoa + 12,&u);
 	uint32_pack_big(soa + 12,u);
 	if (!stralloc_0(&f[7])) nomem();
-	if (!scan_ulong(f[7].s,&u)) uint32_unpack_big(defaultsoa + 16,&u);
+	if (!scan_uint32(f[7].s,&u)) uint32_unpack_big(defaultsoa + 16,&u);
 	uint32_pack_big(soa + 16,u);
 
-	if (!stralloc_0(&f[8])) nomem();
-	if (!scan_ulong(f[8].s,&ttl)) ttl = TTL_NEGATIVE;
+	ttlparse(&f[8],&ttl,TTL_NEGATIVE,"Z");
 	ttdparse(&f[9],ttd);
 	locparse(&f[10],loc);
 
@@@@ -282,8 +324,7 @@@@ int main()
 
       case '.': case '&':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&ttl)) ttl = TTL_NS;
+	ttlparse(&f[3],&ttl,TTL_NS,". or &");
 	ttdparse(&f[4],ttd);
 	locparse(&f[5],loc);
 
@@@@ -308,24 +349,26 @@@@ int main()
 	rr_addname(d2);
 	rr_finish(d1);
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d2);
-	}
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","& or ."," line: ", f[1].s);
 
 	break;
 
       case '+': case '=':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"+ or =");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
 	if (!stralloc_0(&f[1])) nomem();
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d1);
@@@@ -336,13 +379,40 @@@@ int main()
 	    rr_addname(d1);
 	    rr_finish(dptr);
 	  }
-	}
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","+ or ="," line: ", f[1].s);
+	else
+	  die_semantic4("missing IP address in ","+ or ="," line: ", f[1].s);
 	break;
 
+      case '6': case '3':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"6 or 3");
+	ttdparse(&f[3],ttd);
+	locparse(&f[4],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+	iplen = ip6_scan_flat(f[1].s,ip6);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
+	  rr_start(DNS_T_AAAA,ttl,ttd,loc);
+	  rr_add(ip6,16);
+	  rr_finish(d1);
+
+	  if (line.s[0] == '6') {	/* emit .ip6.arpa */
+	    dns_name6_domain(d6ptr,ip6);
+	    rr_start(DNS_T_PTR,ttl,ttd,loc);
+	    rr_addname(d1);
+	    rr_finish(d6ptr);
+	  }
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","6 or 3"," line: ", f[1].s);
+	else
+	  die_semantic4("missing IP address in ","6 or 3"," line: ", f[1].s);
+	break;
+
       case '@@':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[4])) nomem();
-	if (!scan_ulong(f[4].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[4],&ttl,TTL_POSITIVE,"@@");
 	ttdparse(&f[5],ttd);
 	locparse(&f[6],loc);
 
@@@@ -355,7 +425,7 @@@@ int main()
 	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
 
 	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&u)) u = 0;
+	if (!scan_uint32(f[3].s,&u)) u = 0;
 
 	rr_start(DNS_T_MX,ttl,ttd,loc);
 	uint16_pack_big(buf,u);
@@@@ -363,18 +433,58 @@@@ int main()
 	rr_addname(d2);
 	rr_finish(d1);
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d2);
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","@@"," line: ", f[1].s);
+	break;
+	
+      case 'S':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	if (!stralloc_0(&f[6])) nomem();
+	if (!scan_ulong(f[6].s,&ttl)) ttl = TTL_POSITIVE;
+	ttdparse(&f[7],ttd);
+	locparse(&f[8],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+
+	if (byte_chr(f[2].s,f[2].len,'.') >= f[2].len) {
+	  if (!stralloc_cats(&f[2],".srv.")) nomem();
+	  if (!stralloc_catb(&f[2],f[0].s,f[0].len)) nomem();
 	}
+	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
+
+	if (!stralloc_0(&f[4])) nomem();
+	if (!scan_uint32(f[4].s,&u)) u = 0;
+	uint16_pack_big(srv,u);
+	if (!stralloc_0(&f[5])) nomem();
+	if (!scan_uint32(f[5].s,&u)) u = 0;
+	uint16_pack_big(srv + 2,u);
+	if (!stralloc_0(&f[3])) nomem();
+	if (!scan_uint32(f[3].s,&u)) nomem();
+	uint16_pack_big(srv + 4,u);
+
+	rr_start(DNS_T_SRV,ttl,ttd,loc);
+	rr_add(srv,6);
+	rr_addname(d2);
+	rr_finish(d1);
+
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
+	  rr_start(DNS_T_A,ttl,ttd,loc);
+	  rr_add(ip,4);
+	  rr_finish(d2);
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","S"," line: ", f[1].s);
 	break;
 
       case '^': case 'C':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 	if (!dns_domain_fromdot(&d2,f[1].s,f[1].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"^ or C");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
@@@@ -388,8 +498,7 @@@@ int main()
 
       case '\'':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"\'");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
@@@@ -411,13 +520,12 @@@@ int main()
 
       case ':':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[3],&ttl,TTL_POSITIVE,":");
 	ttdparse(&f[4],ttd);
 	locparse(&f[5],loc);
 
 	if (!stralloc_0(&f[1])) nomem();
-	scan_ulong(f[1].s,&u);
+	scan_uint32(f[1].s,&u);
 	uint16_pack_big(type,u);
 	if (byte_equal(type,2,DNS_T_AXFR))
 	  syntaxerror(": type AXFR prohibited");
@@@@ -449,8 +557,8 @@@@ int main()
   if (cdb_make_finish(&cdb) == -1) die_datatmp();
   if (fsync(fdcdb) == -1) die_datatmp();
   if (close(fdcdb) == -1) die_datatmp(); /* NFS stupidity */
-  if (rename("data.tmp","data.cdb") == -1)
-    strerr_die2sys(111,FATAL,"unable to move data.tmp to data.cdb: ");
+  if (rename("data.cdb.tmp","data.cdb") == -1)
+    strerr_die2sys(111,FATAL,"unable to move data.cdb.tmp to data.cdb: ");
 
   _exit(0);
 }
@


1.4
log
@* there is no axfrdns with IPv6 transport¹²
* add inetd wrapper for axfrdns²
* write out the wrapper correctly automatically in axfrdns-conf(8)
* document that
* mark as for MirOS BSD and OpenBSD only due to arc4random(3) usage
* add port version (for zonenotify) and mksh path (for the
  inetd wrapper in axfrdns-conf) to CPPFLAGS
* build zonenotify
* tinydns-data: fix warnings (conversion)
* sync PLIST
* bump package version

¹) unless you tweak UCSPI-TCP
²) or inetd.conf (tcp4, tcp6)

tested against a 'dig @@1.2.3.4 axfr my.domain' on an openbsd box,
so I suppose it works ok
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_tinydns-data_c,v 1.3 2006/01/17 20:45:42 tg Exp $
d3 1
a3 1
+++ src/tinydns-data.c	Tue Jan 17 22:34:26 2006
d84 35
a118 1
@@@@ -172,6 +204,7 @@@@ static stralloc f[NUMFIELDS];
d126 1
a126 1
@@@@ -187,15 +220,18 @@@@ int main()
d146 1
a146 1
@@@@ -206,7 +242,7 @@@@ int main()
d155 1
a155 1
@@@@ -251,23 +287,22 @@@@ int main()
d185 1
a185 1
@@@@ -282,8 +317,7 @@@@ int main()
d195 1
a195 1
@@@@ -308,24 +342,26 @@@@ int main()
d227 1
a227 1
@@@@ -336,13 +372,45 @@@@ int main()
d251 2
a252 7
+	  if (line.s[0] == '6') {	/* emit both .ip6.arpa and .ip6.int */
+	    dns_name6_domain(d6ptr,ip6,DNS_IP6_ARPA);
+	    rr_start(DNS_T_PTR,ttl,ttd,loc);
+	    rr_addname(d1);
+	    rr_finish(d6ptr);
+
+	    dns_name6_domain(d6ptr,ip6,DNS_IP6_INT);
d271 1
a271 1
@@@@ -355,7 +423,7 @@@@ int main()
d280 1
a280 1
@@@@ -363,18 +431,58 @@@@ int main()
d342 1
a342 1
@@@@ -388,8 +496,7 @@@@ int main()
d352 1
a352 1
@@@@ -411,13 +518,12 @@@@ int main()
d368 1
a368 1
@@@@ -449,8 +555,8 @@@@ int main()
@


1.3
log
@Apply http://tinydns.org/srv-patch, bump patchlevel:

| From: Michael Handler <handler@@sub-rosa.com>
| To: dns@@list.cr.yp.to
| Subject: tinydns-data SRV & axfr-get SRV/PTR patches
| Date: Thu, 14 Sep 2000 20:37:50 -0400
|
| Here's a combined patch that:
|
| a) adds a native SRV type to tinydns-data
|
| Sfqdn:ip:x:port:weight:priority:ttl:timestamp
|
| Standard rules for ip, x, ttl, and timestamp apply. Port, weight, and
| priority all range from 0-65535. Weight and priority are optional; they
| default to zero if not provided.
|
| Sconsole.zoinks.example.com:1.2.3.4:rack102-con1:2001:69:7:300:
|
| b) makes axfr-get decompose SRV and PTR records and write them out in
| native format, rather than opaque. Again, this is necessary because if the
| DNAME fields in the records reference the same zone as fqdn, they can have
| compression pointers that are bogus outside the context of that specific
| packet, and which can't be correctly loaded into data.cdb by tinydns-data.
|
| --michael
|
| Laurent G. Bercot <ska-djbdns@@skarnet.org> updated it for djbdns-1.05:
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_tinydns-data_c,v 1.2 2005/12/14 23:28:40 tg Exp $
d3 1
a3 1
+++ src/tinydns-data.c	Tue Jan 17 20:44:19 2006
d281 1
a281 1
+	if (!scan_ulong(f[4].s,&u)) u = 0;
d284 1
a284 1
+	if (!scan_ulong(f[5].s,&u)) u = 0;
d287 1
a287 1
+	if (!scan_ulong(f[3].s,&u)) nomem();
@


1.2
log
@* update to fefe's djbdns-1.05-test23.diff
  with djbdns-1.05-ixfr.diff
* slightly change naming of v6-transport binaries
* consolidate all added source files in a central directory
  so it can be reused by the v6-transport stuff
* integrate the v6 transport binaries
* fix spacing
* sync descriptive texts with reality
* sync European ORSN (v4 and v6) to their root.hint
* sync OpenNIC too
* Open-RSC seeminly ceased to exist recently
* Apply compiler-temporary-filename.patch
  from http://homepages.tesco.net/~J.deBoynePollard/FGA/djbdns-problems.html
* apply dnscache-cname-handling.patch
* apply dnscache-strict-forwardonly.patch w/ IPv6 tweak
* apply dnscacheip-space-separator.patch
* apply tinydns-alias-chain-truncation.patch
* apply tinydns-data-semantic-error.patch
  appropriately for 6 and 3, too
* fix shell code and path to includes
* fix relative paths
* fix names of library and programmes; NOMAN=yes here (t6)
* Add support for the IPv6 transport module to communicate,
  as a client, with IPv4 transport name servers as well.

  WFM
* build it with -Wall -Werror
* honour ${SYSCONFDIR} throughout the port
@
text
@d1 1
a1 1
$MirOS: ports/net/djbdns/patches/patch-src_tinydns-data_c,v 1.1.201.1 2005/05/14 23:21:06 tg Exp $
d3 1
a3 1
+++ src/tinydns-data.c	Tue Dec 13 23:56:44 2005
d92 1
a92 1
@@@@ -187,12 +220,14 @@@@ int main()
d108 5
a112 1
@@@@ -206,7 +241,7 @@@@ int main()
d121 1
a121 1
@@@@ -251,23 +286,22 @@@@ int main()
d151 1
a151 1
@@@@ -282,8 +316,7 @@@@ int main()
d161 1
a161 1
@@@@ -308,24 +341,26 @@@@ int main()
d193 1
a193 1
@@@@ -336,13 +371,45 @@@@ int main()
d242 1
a242 1
@@@@ -355,7 +422,7 @@@@ int main()
d251 1
a251 1
@@@@ -363,18 +430,19 @@@@ int main()
a260 1
-	}
d263 39
d313 1
a313 1
@@@@ -388,8 +456,7 @@@@ int main()
d323 1
a323 1
@@@@ -411,13 +478,12 @@@@ int main()
d339 1
a339 1
@@@@ -449,8 +515,8 @@@@ int main()
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$MirOS$
d3 1
a3 1
+++ src/tinydns-data.c	Sat May 14 22:27:18 2005
d12 73
a84 1
@@@@ -172,6 +173,7 @@@@ static stralloc f[NUMFIELDS];
d92 8
a99 1
@@@@ -193,6 +195,7 @@@@ int main()
d101 2
a102 1
   unsigned long u;
d108 82
a189 2
@@@@ -335,6 +338,28 @@@@ int main()
 	    rr_start(DNS_T_PTR,ttl,ttd,loc);
d192 8
a199 4
+	  }
+	}
+	break;
+
d202 1
a202 2
+	if (!stralloc_0(&f[2])) nomem();
+	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
d207 2
a208 1
+	if (ip6_scan_flat(f[1].s,ip6)) {
d213 7
a219 2
+	  if (line.s[0] == '6') {
+	    dns_name6_domain(d6ptr,ip6);
d223 37
a259 2
 	  }
 	}
d261 47
@


1.1.201.1
log
@New djbdns port, #ifdef'd, "original" and "no_ipv6" flavours removed
"no_ipv4" non-functional at the moment, will follow later after
redesign using crunchgen(1) and crunchide(1)
@
text
@@
