head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2016.08.11.20.19.07;	author tg;	state Exp;
branches;
next	1.1;
commitid	10057ACDDC90C549100;

1.1
date	2016.03.26.17.29.14;	author tg;	state Exp;
branches;
next	;
commitid	10056F6C535787D61F0;


desc
@@


1.2
log
@completely re-do Fefe’s find_client_loc refactoring, but do it right instead
@
text
@#include <sys/cdefs.h>
#include "open.h"
#include "byte.h"
#include "cdb.h"
#include "ip6.h"

__RCSID("$MirOS$");

char clientloc[2];

static int
try_find_client_loc(struct cdb *cp, const char key[], int len)
{
	int r;

	do {
		r = cdb_find(cp, key, len);
	} while (!r && --len >= 3);

	if (r == -1)
		/* read error */
		return (-1);
	if (r && (cdb_datalen(cp) == 2)) {
		if (cdb_read(cp, clientloc, 2, cdb_datapos(cp)) == -1)
			/* read error */
			return (-1);
		/* found */
		return (0);
	}
	/* not found */
	return (1);
}

int
find_client_loc(const char ip[16], struct cdb *cp)
{
	char key[3 + 32];

	byte_zero(clientloc, 2);
	key[0] = 0;
	key[1] = '%';
	if (byte_equal(ip, 12, V4mappedprefix)) {
		key[2] = 'f';
		byte_copy(key + 3, 4, ip + 12);
		switch (try_find_client_loc(cp, key, 3 + 4)) {
		case -1:
			/* read error */
			return (-1);
		case 0:
			/* found */
			return (0);
		}
		/* retry as v4-mapped */
	}
	key[2] = 's';
	ip6_fmt_flat(key + 3, ip);
	switch (try_find_client_loc(cp, key, 3 + 32)) {
	case -1:
		/* read error */
		return (-1);
	default:
		/* no match */
		byte_zero(clientloc, 2);
		/* FALLTHROUGH */
	case 0:
		/* found */
		return (0);
	}
}
@


1.1
log
@complete overhaul of djbdns port:

• merge t4/t6 flavours back into one binary
  ‣ greatly simplify IPv6 handling, too; drop code for v6-less OSes
• merge v4/v6 dnsroots back into one, update all of them
• improve documentation a bit
• apply two patches from http://www.your.org/dnscache/ (SECURITY):
  ‣ merge identical outgoing requests
  ‣ allow caching SOA responses
• update to Fefe’s djbdns-1.05-test27.diff.bz2
  ‣ fixes recursively resolving hosts behind IPv6-only nameservers;
    spotted by Natureshadow (for Teckids’ Lunatics network) and via
    http://serverfault.com/q/627912/189656 (which I’ll answer RSN)
  ⚠ fix with “one second” CDB validity patch
  ⚠ adapt for OpenBSD-style IPv6
• drop ip6.int. reverse v6 DNS for good
• improve dealing with mixing v4/v6 transport
  ⇒ TODO add IP4SEND/IP6SEND support; currently; if IPSEND is v6
    but we send to a v4 server, we use INADDR_ANY for outgoing,
    as automatic fallback address
@
text
@d1 1
d7 6
a12 1
int find_client_loc(char loc[2],const char ip[16],struct cdb *cp)
d14 5
a18 2
  int r, fd;
  char key[32+3];
d20 18
a37 26
  byte_zero(loc,2);
  key[0] = 0;
  key[1] = '%';
  if (byte_equal(ip,12,V4mappedprefix)) {
    key[2] = 'f';
    byte_copy(key + 3,4,ip+12);
    r = cdb_find(cp,key,7);
    if (!r) r = cdb_find(cp,key,6);
    if (!r) r = cdb_find(cp,key,5);
    if (!r) r = cdb_find(cp,key,4);
    if (!r) r = cdb_find(cp,key,3);
    if (r == -1) return 0;
    if (r && (cdb_datalen(cp) == 2))
      if (cdb_read(cp,loc,2,cdb_datapos(cp)) == -1) return 0;
  } else {
    unsigned int n;
    key[2] = 's';
    ip6_fmt_flat(key+3,ip);
    for (n=19; n>3; --n) {
      r = cdb_find(cp,key,n);
      if (r) break;
    }
    if (r == -1) return 0;
    if (r && (cdb_datalen(cp) == 2))
      if (cdb_read(cp,loc,2,cdb_datapos(cp)) == -1) return 0;
  }
d39 30
a68 1
  return r;
@

