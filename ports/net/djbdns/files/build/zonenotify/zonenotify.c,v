head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2016.03.26.17.29.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	10056F6C535787D61F0;

1.5
date	2006.08.10.15.31.57;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044DB51566C83CF2A;

1.4
date	2006.07.27.01.15.35;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044C813CC55B921AF;

1.3
date	2006.07.27.00.58.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044C80EE124197593;

1.2
date	2006.01.17.21.27.43;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043CD615D1726544A;

1.1
date	2006.01.17.21.17.52;	author tg;	state Exp;
branches;
next	;
commitid	10043CD5F051CED6AE0;


desc
@@


1.6
log
@complete overhaul of djbdns port:

• merge t4/t6 flavours back into one binary
  ‣ greatly simplify IPv6 handling, too; drop code for v6-less OSes
• merge v4/v6 dnsroots back into one, update all of them
• improve documentation a bit
• apply two patches from http://www.your.org/dnscache/ (SECURITY):
  ‣ merge identical outgoing requests
  ‣ allow caching SOA responses
• update to Fefe’s djbdns-1.05-test27.diff.bz2
  ‣ fixes recursively resolving hosts behind IPv6-only nameservers;
    spotted by Natureshadow (for Teckids’ Lunatics network) and via
    http://serverfault.com/q/627912/189656 (which I’ll answer RSN)
  ⚠ fix with “one second” CDB validity patch
  ⚠ adapt for OpenBSD-style IPv6
• drop ip6.int. reverse v6 DNS for good
• improve dealing with mixing v4/v6 transport
  ⇒ TODO add IP4SEND/IP6SEND support; currently; if IPSEND is v6
    but we send to a v4 server, we use INADDR_ANY for outgoing,
    as automatic fallback address
@
text
@/*
 * Copyright (c) 2006  mirabilos <m@@mirbsd.org>
 * Copyright (c) 2004  Morettoni Luca <luca@@morettoni.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.5 2006/08/10 15:31:57 tg Exp $
 * $Id: zonenotify.c,v 1.4 2004/07/19 12:37:04 luca Exp $
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#ifdef _BSD
#include <arpa/nameser_compat.h>
#endif
#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include "zonenotify.h"

__RCSID("$MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.5 2006/08/10 15:31:57 tg Exp $");

int
main(int argc, char *argv[])
{
	int i = 2;
	int ret = 0;

	if (argc < 3)
		usage ();

	while (i < argc) {
		if (init_connection (argv[i], argv[1]) == -1)
			ret = 1;
		i++;
	}

	return (ret);
}

__dead void
usage(void)
{
	printf ("%s, %s\n\nusage: zonenotify zone slave [slave 2 ... [slave n]] \n", VERSION, AUTHOR);
	printf ("where zone is the domain name to update on slave server ``slave''\n");
	printf ("this send a \"NOTIFY\" packet to slave1 (slave2...slaveN) about zone\n"
	    "\"zone\", if there are some problem zonenofity display the error message\n"
	    "and exit 1, otherwise exit 0.\n");
	exit (1);
}

/* connect to the nameserver */
int
init_connection(const char *server, const char *domain)
{
	struct addrinfo hints, *res, *res0;
	struct sockaddr_storage ss;
	struct sockaddr *ssp = (struct sockaddr *)&ss;
	socklen_t sssz;
	const char *cause = NULL;
	int i;
	int rv = 0;

	memset(&hints, 0, sizeof (hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
	if ((i = getaddrinfo(server, "domain", &hints, &res0))) {
		warnx("%s", gai_strerror(i));
		goto cant_connect;
	}
	s = -1;
	for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol);
		if (s < 0) {
			cause = "socket";
			continue;
		}
		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
			cause = "connect";
			continue;
		}
		sssz = sizeof (ss);
		if (getpeername(s, ssp, &sssz) == 0) {
			char n[256];
			if (!getnameinfo(ssp, SA_LEN(ssp), n, 256, NULL,
			    0, NI_NUMERICHOST))
				printf("connecting to %s\n", n);
			else
				printf("getnameinfo failed\n");
		} else
			printf("getpeername failed\n");
		if (slave_notify(domain, server) == -1)
			rv = 1;
		else
			cause = NULL;
		close(s);
	}
	if (cause) {
		warn("couldn't %s", cause);
 cant_connect:
		fprintf(stderr, "%s: couldn't connect\n", server);
	}
	freeaddrinfo(res0);

	return (rv);
}

/* encode name string in ns query format */
int
ns_encode(const char *str, char *buff)
{
	const char *pos;
	int size;
	int len = 0;

	while (1) {
		pos = (const char *) strchr (str, '.');

		if (!pos) break;

		size = pos-str;
		*buff++ = size;

		strncpy (buff, str, size);
		buff += size;

		len += size+1;
		str = pos+1;
	}

	size = strlen (str);
	if (size) {
		*buff++ = size;
		strncpy (buff, str, size);
		buff += size;
		len += size+1;
	}

	*buff = 0;

	return len;
}

/* send sequest to our DNS-cache server */
int
slave_notify(const char *domain, const char *server)
{
	static int	unique = 0;
	char		buffer[PACKETSZ];
	char		name[MAXDNAME];
	HEADER		*hdr;
	int		len, reqlen;
	u_int16_t	val;
	fd_set		active_fd_set;
	struct timeval	tv_timeout;

	hdr = (HEADER*) buffer;
        hdr->qr = 0;
        hdr->opcode = NS_NOTIFY_OP;
        hdr->aa = 1;
        hdr->tc = 0;
        hdr->rd = 0;
        hdr->ra = 0;
        hdr->unused = 0;
        hdr->rcode = 0;
        hdr->qdcount = htons (1);
        hdr->ancount = 0;
        hdr->nscount = 0;
        hdr->arcount = 0;
        hdr->id = htons (unique++);

	/* the 0x00 at the end must be copied! */
	reqlen = ns_encode (domain, name)+1;
	memcpy (buffer+sizeof (HEADER), name, reqlen);

	/* query type */
	val = htons (T_SOA);
	memcpy (buffer+sizeof (HEADER)+reqlen, &val, 2);
	reqlen += 2;

	/* query class */
	val = htons(C_IN);
	memcpy (buffer+sizeof (HEADER)+reqlen, &val, 2);
	reqlen += 2;

	/* we wait max TIMEOUT seconds */
	tv_timeout.tv_sec = TIMEOUT;
	tv_timeout.tv_usec = 0;

	FD_ZERO (&active_fd_set);
	FD_SET (s, &active_fd_set);

	/* send the request to the nameserver */
	if (send (s, buffer, sizeof (HEADER)+reqlen, 0) == -1)
		return -1;

	/* we wait the answere */
	if (select (FD_SETSIZE, &active_fd_set, NULL, NULL, &tv_timeout) < 1)
	{
		fprintf (stderr, "%s: timeout\n", server);
		return -1;
	}

	/* and get back the answere */
	len = recv (s, buffer, PACKETSZ, 0);
	if (len != -1) {
		hdr = (HEADER*) buffer;

		if (hdr->qr && hdr->rcode) {
			fprintf (stderr, "%s: %s\n",
					server,
					hdr->rcode < 23 ? dns_errors[hdr->rcode] : "unknown error");
			return -1;
		}
	}

	return 0;
}
@


1.5
log
@zonenotify cleanup:
* move includes to .c file
* fixup .h (multiple inclusion protection, __BEGIN/END_DECLS)
* cause was used uninitialisedly, causing core dumps

now __CRAZY clean
@
text
@d2 1
a2 1
 * Copyright (c) 2006  Thorsten Glaser <tg@@mirbsd.de>
d27 1
a27 1
 * $MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.4 2006/07/27 01:15:35 tg Exp $
d51 1
a51 1
__RCSID("$MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.4 2006/07/27 01:15:35 tg Exp $");
@


1.4
log
@oeps, possible bug
@
text
@d27 1
a27 1
 * $MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.3 2006/07/27 00:58:16 tg Exp $
d31 18
d51 1
a51 1
__RCSID("$MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.3 2006/07/27 00:58:16 tg Exp $");
d90 1
a90 1
	const char *cause;
@


1.3
log
@* make zonenotify connect to IPv6 (DNS or numeric) too
* make zonenotify connect to all IPs of the hostname given
* make axfrdns log IPv6 addresses (have to move it though)
  XXX pending making DJB_V6ONLY the default and only case
* put fromhex into common file while here
* centralise licence info for my diffs while here
* bump patchlevel

new zonenotify loosely tested, new axfrdns log format seems okay
thanks gecko2 for providing bind9 backup NS on ipv6
@
text
@d27 1
a27 1
 * $MirOS: ports/net/djbdns/files/build/zonenotify/zonenotify.c,v 1.2 2006/01/17 21:27:43 tg Exp $
d33 1
a33 1
__RCSID("$MirOS$");
d71 1
a71 1
	socklen_t sssz = sizeof (ss);
d95 1
@


1.2
log
@MirOSify (works with __CRAZY=Yes now, even)
@
text
@d2 1
d27 1
a27 1
 * $MirOS$
d33 2
d45 2
a46 5
		if (init_connection (argv[i]) != -1) {
			if (slave_notify (argv[1], argv[i]) == -1) ret = 1;
			stop_connection ();
		} else
			fprintf (stderr, "Can't connect to %s\n", argv[i]);
d66 1
a66 1
init_connection(const char *server)
d68 38
a105 28
	struct	sockaddr_in sa, sl;
	struct	hostent *he;
	int	isbind = 0;
	int	i;

	s = socket (AF_INET, SOCK_DGRAM, 0);
	if (s < 0) return -1;

	memset (&sl, 0, sizeof (sl));
	sl.sin_family = AF_INET;
	sl.sin_addr.s_addr = htonl (INADDR_ANY);

	for (i = 0; i < 12 && !isbind; i++) {
		/* local port: random */
		sl.sin_port = htons(1025+(arc4random() % 15000));
		isbind = (bind(s, (struct sockaddr *) &sl, sizeof (sl)) == 0);
	}

	if (!isbind)
		return (-1);

	/* destination port: nameserver (53) */
	memset (&sa, 0, sizeof (sa));
	if (inet_aton (server, &sa.sin_addr) == 0) {
		he = gethostbyname (server);

		if (he)
			memcpy (&sa.sin_addr, he->h_addr_list[0], sizeof (sa.sin_addr));
d107 7
a113 1
			return -1;
d115 1
d117 1
a117 13
	sa.sin_family = AF_INET;
	sa.sin_port = htons (NAMESERVER_PORT);
	if (connect (s, (struct sockaddr *) &sa, sizeof (sa)) != 0)
		return -1;

	return 0;
}

/* close local socket */
void
stop_connection(void)
{
	shutdown (s, SHUT_RDWR);
d122 1
a122 1
ns_encode(char *str, char *buff)
d124 1
a124 1
	char *pos;
d129 1
a129 1
		pos = (char *) strchr (str, '.');
d158 1
a158 1
slave_notify(char *domain, const char *server)
@


1.1
log
@Add the gist of http://morettoni.net/bsd/zonenotify-0.1.tar.gz
from tinydns.org too
@
text
@d26 1
d32 2
a33 1
int main(int argc, char *argv[])
d38 2
a39 1
	if (argc < 3) usage ();
d50 1
a50 1
	exit (ret);
d53 2
a54 1
void usage ()
d58 3
d65 2
a66 1
int init_connection (const char *server)
a71 5
	long	rand;
	time_t	now;

	time (&now);
	srandom ((long) now);
a75 1
	/* local port: random */
d81 3
a83 3
		rand = 1025+(random () % 15000);
		sl.sin_port = htons (rand);
		isbind = (bind (s, (struct sockaddr *) &sl, sizeof (sl)) == 0);
d86 2
a87 1
	if (!isbind) return -1;
d109 2
a110 1
void stop_connection (void)
d116 2
a117 1
int ns_encode (char *str, char *buff)
d152 2
a153 1
int slave_notify (char *domain, const char *server)
d199 1
a199 1
	
d217 3
a219 3
			fprintf (stderr, "%s: %s\n", 
					server, 
					hdr->rcode < 23 ? dns_errors[hdr->rcode] : "unknow error");
@

