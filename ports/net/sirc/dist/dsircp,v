head	1.58;
access;
symbols
	tg-test:1.12.0.2
	tg-ssl:1.9.0.2;
locks; strict;
comment	@# @;


1.58
date	2018.11.24.16.20.21;	author tg;	state Exp;
branches;
next	1.57;
commitid	1005BF97A530F5CD040;

1.57
date	2018.09.26.15.02.02;	author tg;	state Exp;
branches;
next	1.56;
commitid	1005BAB9F84194A29CF;

1.56
date	2018.09.26.15.01.18;	author tg;	state Exp;
branches;
next	1.55;
commitid	1005BAB9F5847EDA3DF;

1.55
date	2018.07.15.13.41.22;	author tg;	state Exp;
branches;
next	1.54;
commitid	1005B4B4F0B4ECDB6D4;

1.54
date	2017.11.17.00.12.24;	author tg;	state Exp;
branches;
next	1.53;
commitid	1005A0E297849017779;

1.53
date	2017.11.17.00.08.33;	author tg;	state Exp;
branches;
next	1.52;
commitid	1005A0E28904F6224E0;

1.52
date	2017.11.16.23.40.30;	author tg;	state Exp;
branches;
next	1.51;
commitid	1005A0E21FF02DB4BD1;

1.51
date	2017.11.16.23.39.05;	author tg;	state Exp;
branches;
next	1.50;
commitid	1005A0E21AD1A4C79B1;

1.50
date	2017.11.16.23.35.41;	author tg;	state Exp;
branches;
next	1.49;
commitid	1005A0E20CF59D59B49;

1.49
date	2017.07.18.21.57.26;	author tg;	state Exp;
branches;
next	1.48;
commitid	100596E845167006DA1;

1.48
date	2017.06.26.13.45.50;	author tg;	state Exp;
branches;
next	1.47;
commitid	100595110245D169B38;

1.47
date	2017.06.26.13.43.22;	author tg;	state Exp;
branches;
next	1.46;
commitid	10059510F8E42F6D117;

1.46
date	2017.06.26.13.42.35;	author tg;	state Exp;
branches;
next	1.45;
commitid	10059510F584F7BC41A;

1.45
date	2017.06.26.13.39.01;	author tg;	state Exp;
branches;
next	1.44;
commitid	10059510E894B7365E2;

1.44
date	2017.06.26.13.36.22;	author tg;	state Exp;
branches;
next	1.43;
commitid	10059510DED0EABAD8E;

1.43
date	2017.06.26.13.35.12;	author tg;	state Exp;
branches;
next	1.42;
commitid	10059510DA66C1F70DF;

1.42
date	2017.06.26.13.18.35;	author tg;	state Exp;
branches;
next	1.41;
commitid	100595109BC448D2C13;

1.41
date	2017.06.26.13.12.51;	author tg;	state Exp;
branches;
next	1.40;
commitid	1005951086535392E5B;

1.40
date	2017.06.26.13.10.42;	author tg;	state Exp;
branches;
next	1.39;
commitid	100595107E00B7D8B2A;

1.39
date	2017.06.26.00.14.33;	author tg;	state Exp;
branches;
next	1.38;
commitid	100595051F74A9A9A62;

1.38
date	2017.06.26.00.08.30;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005950509256035F6A;

1.37
date	2017.06.25.23.56.40;	author tg;	state Exp;
branches;
next	1.36;
commitid	10059504DC15E652015;

1.36
date	2017.06.25.23.48.02;	author tg;	state Exp;
branches;
next	1.35;
commitid	10059504BC4409C270B;

1.35
date	2017.06.25.23.39.21;	author tg;	state Exp;
branches;
next	1.34;
commitid	100595049B51BF3320A;

1.34
date	2014.06.09.13.50.59;	author tg;	state Exp;
branches;
next	1.33;
commitid	1005395BBAC5589D004;

1.33
date	2012.06.24.13.53.58;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004FE71C004CBBEB7F;

1.32
date	2011.12.16.19.21.48;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004EEB9A582D7F3749;

1.31
date	2011.12.16.18.15.36;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004EEB8ACD6AFC46FD;

1.30
date	2011.12.16.17.29.02;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004EEB7FF01A08D87E;

1.29
date	2011.12.16.17.12.05;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004EEB7BED3992724E;

1.28
date	2011.12.16.15.50.24;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004EEB68C92849490D;

1.27
date	2010.05.14.20.35.49;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004BEDB431734549E7;

1.26
date	2010.03.30.21.03.06;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004BB267200A1C1B73;

1.25
date	2009.08.02.14.34.59;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004A75A41A5D07D5B1;

1.24
date	2009.01.08.20.23.30;	author tg;	state Exp;
branches;
next	1.23;
commitid	100496660B46A83B0A4;

1.23
date	2009.01.08.19.53.37;	author tg;	state Exp;
branches;
next	1.22;
commitid	100496659CF0DE69980;

1.22
date	2008.12.20.17.57.28;	author tg;	state Exp;
branches;
next	1.21;
commitid	100494D3213395F1436;

1.21
date	2008.12.13.14.02.04;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004943C0687D10F30F;

1.20
date	2008.12.08.16.01.33;	author tg;	state Exp;
branches;
next	1.19;
commitid	100493D44E2495740EA;

1.19
date	2008.10.13.22.09.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	10048F3C71843E3CF4F;

1.18
date	2008.07.18.22.41.23;	author tg;	state Exp;
branches;
next	1.17;
commitid	10048811C187AA64644;

1.17
date	2008.07.15.13.25.25;	author tg;	state Exp;
branches;
next	1.16;
commitid	100487CA55235B9CFCE;

1.16
date	2008.07.15.13.15.29;	author tg;	state Exp;
branches;
next	1.15;
commitid	100487CA2F17828F85C;

1.15
date	2008.07.15.12.49.46;	author tg;	state Exp;
branches;
next	1.14;
commitid	100487C9CCC61BE6775;

1.14
date	2008.07.15.12.40.11;	author tg;	state Exp;
branches;
next	1.13;
commitid	100487C9ABC792A983A;

1.13
date	2008.07.15.12.25.19;	author tg;	state Exp;
branches;
next	1.12;
commitid	100487C974048905A80;

1.12
date	2007.05.20.23.01.27;	author tg;	state Exp;
branches
	1.12.2.1;
next	1.11;
commitid	1004650D35658FC10DB;

1.11
date	2007.03.01.21.34.15;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045E7469240DA3FD8;

1.10
date	2007.01.09.00.51.17;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045A2E70161DFC596;

1.9
date	2006.02.05.14.37.58;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10043E60DCC0A565ED4;

1.8
date	2006.01.23.22.48.21;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043D55D396CE761DC;

1.7
date	2006.01.01.05.36.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043B76A7311FEAF1F;

1.6
date	2006.01.01.04.55.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043B760B72374886C;

1.5
date	2006.01.01.04.50.43;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043B75FAA3093AA18;

1.4
date	2005.12.18.16.36.44;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043A58BE830AFB807;

1.3
date	2005.12.15.13.10.24;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A16B450A49F0B1;

1.2
date	2005.09.01.20.38.50;	author tg;	state Exp;
branches;
next	1.1;
commitid	4846431766e1c1ef;

1.1
date	2005.09.01.20.18.41;	author tg;	state Exp;
branches;
next	;
commitid	101643176215256c;

1.12.2.1
date	2008.07.08.02.11.46;	author tg;	state Exp;
branches;
next	1.12.2.2;
commitid	1004872CCE45647AE78;

1.12.2.2
date	2008.07.08.18.10.42;	author tg;	state Exp;
branches;
next	;
commitid	1004873AD725BE92BAE;

1.9.2.1
date	2007.01.08.22.49.06;	author tg;	state Exp;
branches;
next	1.9.2.2;
commitid	10045A2CA5F5C21E0AB;

1.9.2.2
date	2007.01.08.23.03.31;	author tg;	state Exp;
branches;
next	1.9.2.3;
commitid	10045A2CDD64D2AB4E0;

1.9.2.3
date	2007.01.08.23.51.28;	author tg;	state Exp;
branches;
next	1.9.2.4;
commitid	10045A2D9166274DEE6;

1.9.2.4
date	2007.01.09.00.05.23;	author tg;	state Exp;
branches;
next	1.9.2.5;
commitid	10045A2DC4F112A23E9;

1.9.2.5
date	2007.01.09.00.16.28;	author tg;	state Exp;
branches;
next	1.9.2.6;
commitid	10045A2DEF24E453AC3;

1.9.2.6
date	2007.01.09.00.19.59;	author tg;	state Exp;
branches;
next	1.9.2.7;
commitid	10045A2DFC605B883D1;

1.9.2.7
date	2007.01.09.00.23.30;	author tg;	state Exp;
branches;
next	1.9.2.8;
commitid	10045A2E0986D9765F4;

1.9.2.8
date	2007.01.09.00.38.31;	author tg;	state Exp;
branches;
next	;
commitid	10045A2E41D79C678EE;


desc
@@


1.58
log
@apply patch from multiplexd to prefer the own nick over highlight substrings
@
text
@#!/usr/bin/env perl
# $MirOS: ports/net/sirc/dist/dsircp,v 1.56 2018/09/26 15:01:18 tg Exp $
#-
# dsircp: dumb-mode small irc client in perl
# by orabidoo <roger.espel.llima@@pobox.com>
#
# Copyright (C) 1995-1997 Roger Espel Llima
# Copyright (c) 2002-2003 Hubert Feyrer
# Copyright (c) Phil Stracchino
# Copyright (c) 2001-2018 mirabilos
# Copyright (c) 2017 multiplexd
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# for a full-screen termcap interface, use this with ssfe
#
# use: dsircp [options] [nick [server[:port[:password]]]]
# options are:
#	-p = specify port number (start with s for SSL)
#	-i = specify IRCNAME
#	-u = specify username (quite useless as an option)
#	-n = specify nickname (quite useless as an option)
#	-s = specify server (quite useless as an option)
#	-l = specify file to be loaded instead of ~/.etc/sircrc.pl
#	-L = specify file to be loaded instead of ~/.etc/sircrc
#	-H = specify virtual host to bind to
#	-q = don't load ~/.etc/sircrc or ~/.etc/sircrc.pl
#	-Q = don't load system sircrc or sircrc.pl
#	-R = run in restricted (secure) mode
#	-r = raw mode (no control-char filtering)
#	-8 = 8-bit mode (enabled by default, use -7 to disable)
#	-7 = 7-bit (ISO_646.irv:1991) mode
#	-U = non-UTF-8 (Unicode) mode
#	-C = set local charset to optarg
#	-X = set local charset to UTF-8
#	-T = do not show timestamps on messages by default

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 2, as
# published by the Free Software Foundation.
#
# If you make improvements to sirc, please send me the modifications
# (unified diffs appreciated) and they might make it to the next release.
#
# For bug reports, comments, questions, email the miros-discuss mailing
# list, see http://www.mirbsd.org/rss.htm#lists for details, but not the
# original author roger.espel.llima@@pobox.com any more.
#
# You can always find the latest version of sirc at the following URL:
# http://www.eleves.ens.fr:8080/home/espel/sirc/sirc.html
# This fork of sirc is maintained in the MirPorts Framework, though.

$version='2.211-MirPorts-@@DIST_DATE@@';
$date='01 Sep 2005';
$add_ons='';
$msgchannel = '';
$interactive = 1;
$has_capab = 0; $capab_cmd = ''; $capab_response = ''; $opportunistic_cmd = '';
$has_identifymsg = 0; $unverified = 1; $unverified_m = 0;

$libdir=$ENV{"SIRCLIB"} || "@@PREFIX@@/share/sirc/";
push(@@INC, $libdir, $ENV{"HOME"}."/.etc/sirc");
@@loadpath=($ENV{"HOME"}."/.etc/sirc", $libdir, ".");

$|=1;

if (!eval "require 'getopts.pl';") {
  print "\n\n\
Your perl interpreter is *really* screwed up: the getopts.pl library is not
even there! Have you even bothered to run 'install'?\n";
  exit;
}

BEGIN {
  $have_socket = 0;
  if ($] >= 5 && (eval "use Socket;", $@@ eq '')) {
    $have_socket = 4;
    eval "use Socket6;";
    $have_socket = 6 if $@@ eq '';
  }
}

if ($have_socket != 0) {
  ;
} elsif (-f "$libdir/sircsock.ph") {
  do "$libdir/sircsock.ph";
} elsif (-f $ENV{'HOME'}."/sircsock.ph") {
  do $ENV{'HOME'}."/sircsock.ph";
} elsif (!eval "require 'sys/socket.ph';") {
    print "\n\n\
Your perl installation is wrong somewhere, the sys/socket.ph include file
couldn't be found. Have you even bothered to run 'install'?\n";
    exit;
}
use Encode;
use POSIX ":sys_wait_h";
use BSD::arc4random;

sub NZATUpdate($$) {
	my ($h, $s) = @@_;

	foreach my $c (unpack("C*", $s)) {
		$h = ($h + $c + 1) * 1025;
		$h %= 2**32;
		$h ^= $h >> 6;
	}
	return ($h);
}

sub NZAATFinish($) {
	my $h = shift;

	$h += $h << 10;
	$h %= 2**32;
	$h ^= $h >> 6;
	$h %= 2**32;
	$h += $h << 3;
	$h %= 2**32;
	$h ^= $h >> 11;
	$h %= 2**32;
	$h += $h << 15;
	$h %= 2**32;

	return ($h);
}

my $lrhash_v = 0;
sub lrhash_timer {
	my $v;

	$v = NZAATFinish($lrhash_v);
	$lrhash_v = NZATUpdate(0,
	    pack("w", BSD::arc4random::arc4random_pushb($v)));
	&timer(600, "&lrhash_timer;");
}
&lrhash_timer;

sub lrhash_add($$) {
	my ($direction, $s) = @@_;

	$s = pack("w", time) . pack("w", BSD::arc4random::arc4random()) . $s;
	$lrhash_v = NZATUpdate($lrhash_v,
	    $direction . pack("w", length($s)) . $s);
}
sub arandom_add($) {
	my $s = shift;
	my $v;

	$v = NZAATFinish($lrhash_v);
	$lrhash_v = NZATUpdate($lrhash_v,
	    pack("w", BSD::arc4random::arc4random_pushb(pack("w", $v) . $s)));
}

# for debugging
sub hdump($) {
  my $arg = shift;
  my $fmt = utf8::is_utf8($arg) ? "U0" : "";
  my $ofs = 0;
  foreach my $data (unpack($fmt . "a16"x(length($arg)/16) . "a*", $arg)) {
    my @@arr = unpack('C*', $data);
    $_ = sprintf "%02X", $_ for @@arr;
    push(@@arr, '  ') while scalar(@@arr) < 16;
    $data =~ tr/\0-\37\177-\377/./;
    printf "%08X  %s %s %s %s %s %s %s %s  %s %s %s %s %s %s %s %s  |%s|\n",
     $ofs, @@arr, $data;
    $ofs += 16;
  }
}

sub parseserver {
  local $args = $_[0];
  if ($args =~ m/^\[([^\]]+)\](.*)$/) {
    ($server, $port, $pass) = split(/[\s:]+/, $2);
    $server = $1;
  } else {
    ($server, $port, $pass) = split(/[\s:]+/, $args);
  }
}

$AB = ''; $AC = ''; $BB = ''; $VB = '';
sub update_charset {
  $AB = Encode::encode($set{"CHARSET"}, "\x{AB}", 0);
  $AC = Encode::encode($set{"CHARSET"}, "\x{AC}", 0);
  $BB = Encode::encode($set{"CHARSET"}, "\x{BB}", 0);
  $VB = Encode::encode($set{"CHARSET"}, "\x{239C}", 0);
  if ($VB eq '?') {
    $VB = Encode::encode($set{"CHARSET"}, "\x{2502}", 0);
  }
  if ($VB eq '?') {
    $VB = '|';
  }
}

&Getopts('n:s:p:u:i:l:L:H:rqQR78UC:XT');

%set=("LOGFILE", "", "LOG", "off", "PRINTUH", "none", "PRINTCHAN", "off",
	"LOCALHOST", "", "CTCP", "no",
	"USERINFO", "", "FINGER", "", "IRCNAME", "", "EIGHT_BIT", "on",
	"LOADPATH", join(":", @@loadpath), "CTRL_T", "/next", "UTF", "on",
	"CHARSET", "iso-8859-1", "SHOWTIME", "on", "HIGHLIGHT_NICK", "off",
	"HIGHLIGHT_STYLE", "u");
$highlight_style = "\c_";

$raw_mode=$opt_r || (!-t STDOUT);
$ansi=!$raw_mode && $ENV{"TERM"} =~ /^vt|^xterm|^ansi/i;
$ssl_args = $ENV{'SIRCSSL'} || '-CApath /etc/ssl/certs';
$server=$opt_s || $ARGV[1] || $ENV{"SIRCSERVER"} || $ENV{"IRCSERVER"} ||
		"chat.freenode.net";
$port0=$opt_p || $ENV{"SIRCPORT"} || $ENV{"IRCPORT"} || 6667;
$username=$opt_u || $ENV{"SIRCUSER"} || $ENV{"IRCUSER"} || (getpwuid($<))[0] ||
		$ENV{"USER"} || "blah";
$set{"IRCNAME"}=$opt_i || $ENV{"SIRCNAME"} || $ENV{"IRCNAME"} || "/whois your father?";
$nick=$opt_n || $ARGV[0] || $ENV{"SIRCNICK"} || $ENV{"IRCNICK"} || $username;
$set{"FINGER"}=$ENV{"IRCFINGER"} || "keep your fingers to yourself";
$set{"USERINFO"}=$ENV{"USERINFO"} || "yep, I'm a happy MirBSD user";
&parseserver($server);
$port || ($port=$port0);
$port0=$port;
$server0=$server1=$server;
$pass0=$pass;
$initfile=$opt_l || $ENV{"SIRCRCPL"} || $ENV{'HOME'}."/.etc/sircrc.pl"
  if $opt_l || !$opt_q;
$sysinit=$libdir."/sircrc.pl" if $libdir ne '.' && !$opt_Q;
$rcfile=$opt_L || $ENV{"SIRCRC"} || $ENV{'HOME'}."/.etc/sircrc"
  if $opt_L || !$opt_q;
$sysrc=$libdir."/sircrc" if $libdir ne '.' && !$opt_Q;
$set{"LOGFILE"}=$logfile=$ENV{'HOME'}."/sirc.log";
$opt_7 && ($set{"EIGHT_BIT"}="off");
$restrict=$opt_R;
$set{"LOCALHOST"}=$opt_H || $ENV{"SIRCHOST"} || $ENV{"IRCHOST"} ||
		$ENV{"LOCALHOST"} || "";
$opt_U && ($set{"UTF"}="off");
$opt_C && ($set{"CHARSET"}=$opt_C);
$opt_X && ($set{"CHARSET"}="utf8");
$opt_T && ($set{"SHOWTIME"}="off");
&update_charset();

if ($set{"LOCALHOST"}) {
  $bindaddr=&resolve($set{"LOCALHOST"}, 0);
}

@@ARGV=();  # ignore any more arguments

if (open(H, "$libdir/sirc.help") || ((-f "$libdir/sirc.help.gz") &&
     open(H, "gzip -cd $libdir/sirc.help.gz |"))) {
  @@help=<H>;
  close(H);
  foreach (@@help) {
    chop;
    s/\$version/$version/g;
    s/\$date/$date/g;
  }
} else {
  print "*** Warning: help file ($libdir/sirc.help) not found!\n";
}

sub exit {
  arandom_add("exit");
  $logging && print LOG "*\cbL\cb* " . sprintf("Final entropy [%08X]",
    NZAATFinish($lrhash_v)) . ", terminating on " . &date(time) . "\n";
  close(LOG) if $logging;
  &ssl_cleanup;
  exit 0;
}

$SIG{'PIPE'}='IGNORE';
$SIG{'QUIT'}='IGNORE';
$SIG{'INT'}='exit';

sub eq {
  local($a, $b)=@@_;
  $a =~ tr/A-Z[]\\~/a-z{}|^/;
  $b =~ tr/A-Z[]\\~/a-z{}|^/;
  return ($a eq $b);
}

sub tilde {
  $_[0] =~ s|^\~(\w+)|(getpwnam($1))[7]|e;
  $_[0] =~ s/^\~/$ENV{'HOME'}/;
  $_[0]="." if $_[0] eq '';
}

sub sigquit {
  # really ugly hack, but it works...
  close($trysock);
}

sub resolve {
  $use_ipv6 = 0;
  if ($_[0] =~ /^\d+$/) {
    return pack("N", $_[0]+0);
  } elsif ($_[0] =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {
    return pack("c4", $1, $2, $3, $4);
  } elsif (($have_socket == 6) && ($_[1] == 1)) {
    local $rc;

    $rc = (gethostbyname2($_[0], AF_INET6))[4];

    if ($rc) {
      $use_ipv6 = 1;
      return $rc;
    }
  }
  return (gethostbyname($_[0]))[4];
}

$nextfh="sircblah000";
sub newfh {
  return ++$nextfh;
}

sub REAPER {
  my $child;
  while (($child = waitpid(-1,WNOHANG)) > 0) {
    &tell("*\cb?\cb* Child $child exited with status $?");
  }
  # loathe sysV: it makes us not only reinstate
  # the handler, but place it after the wait
  $SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;
$ssl_pid = 0;
$ssl_efd = '';

sub ssl_cleanup {
  if ($ssl_efd ne '') {
    while (&gl($ssl_efd)) {
      last if $_ eq '';
      chop;
      s/\x00//g;
      &tell("*\cbS\cb* TLS: $_");
    }
    close($ssl_efd);
    delete $buffer{$ssl_efd};
    $ssl_efd = '';
  }
  if ($ssl_pid) {
    kill TERM => $ssl_pid;
  }
  $ssl_pid = 0;
}

sub connect {
  $_[0]=&newfh;
  local($fh, $host, $port, $use_ssl)=@@_;
  &ssl_cleanup;
  if ($use_ssl) {
    my $spfh = $fh;
    my $scfh = &newfh;
    my $spe = &newfh;
    my $sce = &newfh;
    my $pid;

    if (!socketpair($scfh, $spfh, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
      &tell("*\cbE\cb* Cannot create a socket pair: $!");
      return 0;
    }
    if (!socketpair($sce, $spe, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
      &tell("*\cbE\cb* Cannot create a second socket pair: $!");
      close($scfh);
      close($spfh);
      return 0;
    }
    if ($pid = fork) {
      my $cmd = "openssl s_client -quiet -connect ${host}:${port} $ssl_args";
      &tell("*\cbS\cb* Spawning: $cmd");
      close($spfh);
      close($spe);
      shutdown($sce, 0);
      open(STDIN, "<&$scfh");
      open(STDOUT, ">&$scfh");
      open(STDERR, ">&$sce");
      select(STDERR); $| = 1;
      select(STDOUT); $| = 1;
      exec $cmd;
    }
    if (!defined $pid) {
      &tell("*\cbE\cb* Cannot fork: $!");
      close($scfh);
      close($spfh);
      close($sce);
      close($spe);
      return 0;
    }
    close($scfh);
    close($sce);
    select($spe); $|=1; select(STDOUT);
    shutdown($spe, 1);
    $ssl_pid = $pid;
    $ssl_efd = $spe;
  } else {
    local $try_ipv6_if_available = 2;
 retry_resolve:
    local($adr, $otherend)=&resolve($host, --$try_ipv6_if_available);
    &tell("*\cbE\cb* Hostname '$host' not found"), return 0 unless $adr;
    if ($use_ipv6) {
      $otherend=pack_sockaddr_in6($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
    } else {
      $otherend=pack_sockaddr_in($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
    }
    if (!$use_ipv6) {
      if ($set{"LOCALHOST"}) {
        bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
         &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
      }
    }
    $trysock=$fh;
    $SIG{'QUIT'}='sigquit';
    unless (connect($fh, $otherend)) {
      &print("*\cbE\cb* Can't connect to host: $!");
      $SIG{'QUIT'}='IGNORE', &print("*** Retrying with Legacy IP"),
        goto retry_resolve if ($use_ipv6);
      close($fh);
      $SIG{'QUIT'}='IGNORE';
      return 0;
    }
    $SIG{'QUIT'}='IGNORE';
    if ($use_ipv6) {
        $bindaddr=(unpack_sockaddr_in6(getsockname($fh)))[2] if !$bindaddr;
    } else {
        $bindaddr=(unpack_sockaddr_in(getsockname($fh)))[2] if !$bindaddr;
    }
  }
  select($fh); $|=1; select(STDOUT);
  return 1;
}

sub listen {
  $_[0]=&newfh;
  local($fh, $port)=@@_;
  local($thisend);
  if ($use_ipv6) {
      $bindaddr=pack_sockaddr_in6(0, 0) unless $bindaddr;
      $thisend=pack_sockaddr_in6($port+0, $bindaddr);
      &tell("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
  } else {
      $bindaddr=pack_sockaddr_in(0, 0) unless $bindaddr;
      $thisend=pack_sockaddr_in($port+0, $bindaddr);
      &tell("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
  }
  &tell("*\cbE\cb* Can't bind local socket!"), close($fh), return 0
    unless bind($fh, $thisend);
  &tell("*\cbE\cb* Can't listen to socket!"), close($fh), return
    unless listen($fh, 5);
  if ($use_ipv6) {
      return (unpack_sockaddr_in6(getsockname($fh)))[1];
  } else {
      return (unpack_sockaddr_in(getsockname($fh)))[1];
  }
}

sub accept {
  $_[0]=&newfh;
  return (accept($_[0], $_[1]), close($_[1]))[0];
}

sub bindtoserver {
  my $xport = $port;
  my $xssl = 0;

  @@channels=(); $talkchannel=''; $talkserver = ''; $use_ipv6=0;
  %mode=(); $umode=''; %limit=(); %haveops=(); %chankey=(); $away='';
  $listmin=0; $listmax=100000; $listpat='';
  @@waituh=(); @@douh=(); @@erruh=(); $invited='';
  &dostatus;
  if ($xport =~ s/^(s|S)//) {
    $xssl = 1;
  }
  &tell("*** Connecting to $server, port $xport" .
    ($xssl ? " (using OpenSSL)" : "") . "...");
  &connect($S, $server, $xport, $xssl) || return;
  $connected=1;
  $talkserver=$server1=$server;
  &sl("PASS $pass") if $pass;
  &sl("USER $username blah blah :".$set{'IRCNAME'});
  &sl("NICK $nick");
  @@channels=(); $talkchannel=''; %mode=(); $umode=''; %limit=();
  %haveops=(); %chankey=();
  %awaymsgs=(); %awaytimes=();
}

sub gl {
  if ((defined $buffer{$_[0]}) &&
   ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/)) {
    $buffer{$_[0]}=$';
    $_=$1."\n";
    return 1;
  }
  local($buf)='';
  local($buf2)='';
  if (sysread($_[0], $buf, 4096)) {
    if ($_[0] eq $S) {
      lrhash_add("I", $buf);
      $buf =~ s/\ca([<>])\ca/\cb$1\cb/g;
      $buf =~ s/\cc((99|1[0-5]|0?[0-9])(,(99|1[0-5]|0?[0-9]))?)?//g;
      $buf2 .= Encode::decode("utf8", $buf, Encode::FB_QUIET);
      $buf2 .= Encode::decode("windows-1252", $buf, 0);
      $buffer{$_[0]} .= Encode::encode($set{"CHARSET"}, $buf2, 0);
    } else {
      my $ioport = "U";
      $ioport = "S" if (($ssl_efd ne '') && ($_[0] eq $ssl_efd));
      $ioport = "K" if ($_[0] eq 'STDIN');
      lrhash_add($ioport, $buf);
      $buffer{$_[0]} .= $buf;
    }
    if ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/) {
      $buffer{$_[0]}=$';
      $_=$1."\n";
      return 1;
    }
    return '';
  }
  $_='';
  return 1;
}

sub sl {
  local($buf)=$_[0];
  local($buf2)='';
  local($buf3)='';
  $buf2 .= Encode::decode($set{"CHARSET"}, $buf, Encode::FB_QUIET);
  $buf2 .= Encode::decode("utf8", $buf, Encode::FB_QUIET);
  $buf2 .= Encode::decode("windows-1252", $buf, 0);
  if ($set{"UTF"} ne 'off') {
    $buf3 = Encode::encode("utf8", $buf2, 0);
  } else {
    $buf3 = Encode::encode("windows-1252", $buf2, 0);
  }
  lrhash_add("O", $buf3);
  &print("*\cbE\cb* Error writing to server: $!") unless print $S $buf3."\n";
# &print("*\cbD\cb* SERVER < $buf3");
}

sub dostatus {
  return unless $ssfe;
  local($t, $s)=($talkchannel, " [sirc]  ");
  $t =~ tr/A-Z[]\\~/a-z{}|^/;
  $s.="*" if $umode =~ /o/;
  if ($t) {
    $s .= $haveops{$t} if $haveops{$t};
  }
  $s.=$nick;
  $s.=" (+$umode)" if $umode;
  $s.=" [query: ${query}]" if $query;
  $s.=" (away)" if $away;
  if ($talkchannel ne '') {
    $s.=" on $talkchannel (+$mode{$t})";
    $s.=" <key: $chankey{$t}>" if $chankey{$t};
    $s.=" <limit: $limit{$t}>" if $limit{$t};
  }
  &dohooks("status", $s);
  $laststatus=$s, print "`#ssfe#s$s\n" if $laststatus ne $s;
}

$bold="\c[[1m";
$underline="\c[[4m";
$reverse="\c[[7m";
$normal="\c[[m";
$cls="\c[[H\c[[2J";

sub enhance {
  local($what)=@@_;
  $what =~ tr/\c@@-\c_\x7F/@@-_?/;
  return "\cv${what}\cv";
}

sub print {
  local($skip, $what)=(0, @@_);
  &dohooks("print", $what);
  return if $skip;
  $what =~ s/\s+$//;
  if ($unverified_m) {
    if ($what =~ /^\*/) {
      $what =~ s/</$AB/;
      $what =~ s/>/$BB/;
    } elsif ($what =~ /^(\<|\[|\-)(\S+)(\>|\]|\-)\s/) {
      $what =~ s/^<(\S+)> /$AB$1$BB /;
      $what =~ s/^\[(\S+)\] /[[$1]] /;
      $what =~ s/^-(\S+)- /$AC$1$AC /;
    }
    $unverified_m = 0;
  }
  # thanks to Toy (wacren@@obspm.fr) for this translation
  $what =~ tr/\x80-\xff/e ,f,.tT\^*S<o Z  ''"".\-\-\~Ts>o zy !cLxY|$_ca<\-\-R_o+23\'mp.,1o>123?AAAAAAACEEEEIIIIDNOOOOO*0UUUUYPBaaaaaaaceeeeiiiidnooooo:0uuuuypy/
    if $set{"EIGHT_BIT"} ne 'on';
  $what = &sortnames($what) if ($what =~ /Users on [&#+!][^\x00\x07\x0A\x0D ,]+:/);
  $tstamp = sprintf("%02d:%02d:%02d", (localtime)[2], (localtime)[1], (localtime)[0]);
  if ($logging) {
    my $logstring = "[" . $tstamp . "] " . $what . "\n";
    $logstring =~ s/\x00.//g;
    print LOG $logstring;
  }
  $what =~ s/\x00//g;
  $tstamp =~ s/:[^:]*$//;
  $what =~ tr/\x1D/\cv/ unless $what =~ /\cv/;
  if ($raw_mode) {
    $tstamp .= $VB;
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    print($tstamp . $what, "\n") || &exit;
  } elsif ($ansi) {
    $tstamp = "\cv" . $tstamp . "\cv ";
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    $what =~ s/([\ca\cc-\ch\cj-\cu\cw-\c^\x7F])/&enhance($1)/eg;
    # this should be better
    my ($is_bold,$is_ul,$is_rev) = (0,0,0);
    my $ansi_code = [[["\c[[m","\c[[7m"],
		      ["\c[[4m","\c[[4;7m"]],
		     [["\c[[1m","\c[[1;7m"],
		      ["\c[[1;4m","\c[[1;4;7m"]]];

    while ($what =~ /(\c[bv_])/) {
      if ($1 == "\cb") {
	$is_bold = $is_bold ? 0 : 1;
      } elsif ($1 == "\c_") {
	$is_ul = $is_ul ? 0 : 1;
      } elsif ($1 == "\cv") {
	$is_rev = $is_rev ? 0 : 1;
       }
      my $code = $ansi_code->[$is_bold][$is_ul][$is_rev];
      $what =~ s/\c[bv_]/$code/;
    }
    print($tstamp . $what, $normal, "\n") || &exit;
  } else {
    $tstamp .= "| ";
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    $what =~ tr/\ca-\ch\cj-\c_\x7F//d;
    print($tstamp . $what, "\n") || &exit;
  }
}

sub nocase {
  uc($a) cmp uc($b);
}

sub sortnames {
  my ($what) = @@_;
  my ($head,$tail) = split(/:\s+/,$what,2);
  $what = join(': ', $head, join(' ',sort nocase (split(/\s+/,$tail))));
  return ($what);
}

sub tell {
  $silent || &print;
}

sub tell_i {
  if (!$has_identifymsg) {
    $unverified_m = 0;
  } elsif ($unverified) {
    $unverified_m = 0;
  } else {
    $unverified_m = 1;
  }
  $silent || &print;
}

sub tell_hi {
  local($pfx, $msg) = @@_;

  local($pat) = join('|', @@highlight);
  if ($set{"HIGHLIGHT_NICK"} eq 'on') {
    $pat = '|' . $pat if $pat ne '';
    $pat = "\Q$nick\E" . $pat;
  }

  $msg =~ s/$pat/\x00$highlight_style$&\x00$highlight_style/ig if $pat ne '';

  &tell_i("$pfx$msg");
}

sub strip_idmsg {
  $unverified = 1;
  if ($args =~ /^([-+])/) {
    $unverified = 0 if ($1 ne '-');
    $vwho = "(" . $1 . "id) " . $who;
    $args =~ s/^[-+]//;
  }
  $args =~ s/\s+$//;
}

sub dohooks {
  $hooktype=shift;
  local(@@hl);
  eval "\@@hl=\@@${hooktype}_hooks;";
  foreach $h (@@hl) {
    eval { &$h(@@_); };
    $@@ =~ s/\n$//, &tell("*\cbE\cb* error in $hooktype hook &$h: $@@")
	if $@@ ne '';
  }
}

sub msg {
  local($towho, $what)=@@_;
  $what =~ s/\s+$//;
  if ($ssfe) {
    local($x)=0;
    if ($query) {
      $x=1;
    } elsif (!&eq($towho, $talkchannel)) {
      $x=1;
    }
    if ($x) {
      print "`#ssfe#t/m $towho \n";
    }
  }
  if ($connected>1) {
    &dohooks("send_text", $towho, $what);
    foreach my $output (&splitoutl($what)) {
      if (&eq($towho, $talkchannel) && !$printchan) {
	&tell("<\c_${nick}\c_> $output");
      } elsif ($towho =~ /^[\&\#\+]/) {
	&tell("<\c_$nick\c_:$towho> $output");
      } else {
	&tell(">\cb${towho}\cb< $output");
      }
      &sl("PRIVMSG $towho :$output");
    }
  } else {
    &tell("*** You're not connected to a server");
  }
}

sub splitoutl {
  my ($line) = @@_;
  my $width = 448;
  my ($p, @@split);

  while (length($line) > $width) {
    $p = rindex($line, ' ', $width);
    if ($p == $width) {
      push (@@split, substr($line, 0, $p));
      $line = substr($line, $p+1);
    } elsif ($p > 0) {
      push (@@split, substr($line, 0, $p));
      $line = substr($line, $p+1);
    } else {
      push (@@split, substr($line, 0, $width-2) . '-');
      $line = substr($line, $width-1);
    }
  }
  push (@@split, $line) if (length($line));

  return (@@split);
}

sub say {
  if ($talkchannel) {
    &msg($talkchannel, @@_);
  } else {
    &tell("*\cbE\cb* Not on a channel");
  }
}

sub notice {
  local($towho, $what)=@@_;
  $what=substr($what, 0, 485);
  &dohooks("send_notice", $towho, $what);
  &tell("-> -\cb${towho}\cb- $what");
  &sl("NOTICE $towho :$what");
}

sub describe {
  local($towho, $what)=@@_;
  $msgchannel = $towho;
  $what=substr($what, 0, 480);
  &dohooks("send_action", $towho, $what);
  if (&eq($towho, $talkchannel) && !$printchan) {
    &tell("* $nick $what");
  } elsif ($towho =~ /^[\#\&\+]/) {
    &tell("* ${nick}:${towho} $what");
  } else {
    &tell("*-> \cb${towho}\cb: $nick $what");
  }
  &sl("PRIVMSG $towho :\caACTION $what\ca");
}

sub me {
  if ($talkchannel) {
    &describe($talkchannel, @@_);
  } else {
    &tell("*\cbE\cb* Not on a channel");
  }
}

sub yetonearg {
  ($newarg, $args)=split(/ +/, $args, 2);
  $args =~ s/^://;
}

sub getarg {
  ($newarg, $args)=split(/ +/, $args, 2);
}

@@weekdays=("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
@@months=("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
  "Nov", "Dec");

sub date {
  local($sec, $min, $hour, $mday, $mon, $year, $wday)=localtime($_[0]);
  return sprintf("$weekdays[$wday] $months[$mon] $mday %.2d:%.2d:%.2d %d",
		 $hour, $min, $sec, $year+1900);
}

sub reply {
  return if $set{"CTCP"} eq 'noreply';
  if ($lastrep<time-10) {
    $lastrep=time;
    $nreps=1;
  } else {
    return if $nreps++>=2 && $set{"CTCP"} eq 'noflood';
  }
  &sl("NOTICE $who :\ca$_[0]\ca");
}

sub ctcp {
  local($towho, $to, $what)=$_[0];
  $msgchannel = $towho;
  ($what, $args)=split(/ +/, $_[1], 2);
  $what =~ tr/a-z/A-Z/;
  &dohooks("ctcp", $towho, $what, $args);
  return if $skip;
  local($a)=$args;
  $a && ($a=' '.$a);
  $to = (&eq($towho, $nick) ? "you" : $towho);
  &tell("*** $vwho$puh1 did a CTCP $what$a to $to")
    unless $what =~ /^(ACTION|ENTROPY|PING|RANDOM)$/;
  if ($what eq 'ACTION') {
    &dohooks("action", $towho, $args);
    if (&eq($towho, $nick)) {
      &tell_i("[*] \cb${who}\cb$puh1 $args");
    } elsif (&eq($towho, $talkchannel) && !$printchan) {
      &tell($unverified
	? "* $who $args"
	: "# $who $args"
      );
    } else {
      &tell($unverified
	? "* $who$puh2:$towho $args"
	: "# $who$puh2:$towho $args"
      );
    }
  } elsif ($what eq 'TIME') {
    &reply("TIME ".&date(time));
  } elsif ($what eq 'CLIENTINFO') {
    &reply("CLIENTINFO ACTION, CLIENTINFO, ECHO, ENTROPY, ERRMSG, FINGER, PING, RANDOM, TIME, USERINFO, VERSION");
  } elsif ($what eq 'FINGER') {
    &reply("FINGER ".$set{"FINGER"});
  } elsif ($what eq 'USERINFO') {
    &reply("USERINFO ".$set{"USERINFO"});
  } elsif ($what eq 'VERSION') {
    local($u)=$add_ons;
    $u =~ s/^\+//;
    $u =~ s/\+/ + /g;
    $u=" -- using $u" if $u;
    &reply("VERSION sirc $version (RANDOM=${BSD::arc4random::RANDOM}), a \cbperl\cb client$u");
  } elsif ($what eq 'PING') {
    &reply("PING $args");
    &tell("*** $vwho$puh1 did a CTCP PING to $to");
  } elsif ($what eq 'ECHO' || $what eq 'ERRMSG') {
    &reply("$what $args");
  } elsif ($what eq 'ENTROPY') {
    arandom_add("init $vwho,$puh1;$towho,$args");
    my $evalue = pack("u", BSD::arc4random::arc4random_bytes(32));
    chop($evalue);
    &tell("*** $vwho$puh1 initiated the RANDEX protocol with $to");
    &reply("RANDOM $evalue");
  } elsif ($what eq 'RANDOM') {
    arandom_add("info $vwho,$puh1;$towho,$args");
    &tell("*** $vwho$puh1 queried RANDEX protocol information from $to");
    if ($set{"CTCP"} ne 'noreply') {
      my $papi = (BSD::arc4random::have_kintf() ? "Perl" : "none");
      my $skip_r = 0;
      if ($lastrep<time-10) {
        $lastrep=time;
        $nreps=1;
      } elsif ($nreps++>=2 && $set{"CTCP"} eq 'noflood') {
        $skip_r = 1;
      }
      &sl("PRIVMSG $who :\caACTION uses MirSirc $version$add_ons with built-in support for the RANDEX protocol, push API: ${papi}\ca") unless $skip_r;
    }
  }
}

sub doset {
  local($var, $val)=@@_;
  $var =~ tr/a-z/A-Z/;
  $val="" unless defined($val);
  if ($var eq 'PRINTUH') {
    $set{$var}="all" if $val =~ /^(on|all)$/i;
    $set{$var}="some" if $val =~ /^some$/i;
    $set{$var}="none" if $val =~ /^(off|none)$/i;
  } elsif ($var eq 'PRINTCHAN') {
    $set{$var}="on", $printchan=1 if $val =~ /^on$/i;
    $set{$var}="off", $printchan=0 if $val =~ /^off$/i;
  } elsif ($var eq 'UTF' || $var eq 'SHOWTIME') {
    $set{$var}="on" if $val =~ /^on/i;
    $set{$var}="off" if $val =~ /^of/i;
  } elsif ($var eq 'CHARSET') {
    $set{$var}=$val;
    &update_charset();
  } elsif ($var eq 'CTCP') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(none|all)$/;
    $set{$var}="noreply" if $val =~ /^(noreply|off)$/;
    $set{$var}="noflood" if $val =~ /^(noflood|on)$/;
  } elsif ($var eq 'USERINFO') {
    $set{$var}=$val;
  } elsif ($var eq 'FINGER') {
    $set{$var}=$val;
  } elsif ($var eq 'IRCNAME') {
    $set{$var}=$val;
  } elsif ($var eq 'EIGHT_BIT') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(on|off)$/;
  } elsif ($var eq 'LOCALHOST') {
    &restrict || return;
    local($ad)=&resolve($val, 0);
    $set{$var}=$val, $bindaddr=$ad if $ad;
  } elsif ($var eq 'LOADPATH') {
    @@loadpath=split(/:/, $val);
    foreach (@@loadpath) {
      &tilde($_);
    }
    $set{$var}=join(":", @@loadpath);
  } elsif ($var eq 'CTRL_T') {
    $set{$var}=$val;
    print "`#ssfe#T$val\n" if $ssfe;
  } elsif ($var eq 'LOGFILE') {
    &restrict || return;
    &tilde($val);
    $logfile=$set{$var}=$val;
  } elsif ($var eq 'LOG') {
    &restrict || return;
    if ($val =~ /^(off|restart)$/i) {
      if ($logging) {
        print LOG "*\cbL\cb* Log ended on ".&date(time)."\n";
        close(LOG);
      }
      $logging='';
      $set{$var}="off";
    }
    if ($val =~ /^(on|restart)$/i) {
      $logging && close(LOG);
      if (open(LOG,
	  ($logfile =~ /\.gz$/ ? "| gzip >> $logfile" : ">> $logfile"))) {
	$logging=1;
	$set{$var}="on";
	select(LOG); $|=1; select(STDOUT);
	print LOG "*\cbL\cb* IRC log started on ".&date(time)."\n";
      } else {
	$logging='';
	$set{$var}="off";
	&tell("*\cbE\cb* Can't write to logfile $logfile");
      }
    }
  } elsif ($var eq 'HIGHLIGHT_NICK') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(on|off)$/;
  } elsif ($var eq 'HIGHLIGHT_STYLE') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var} = $1 if $val =~ /^(b|i|u)/;
    $highlight_style = "\cb" if $set{$var} eq "b";
    $highlight_style = "\cv" if $set{$var} eq "i";
    $highlight_style = "\c_" if $set{$var} eq "u";
  } elsif (defined($sets{$var})) {
    local($f)=$sets{$var};
    eval { &$f($val); };
    $@@ =~ s/\n$//, &tell("*\cbE\cb* error in SET $var hook: $@@") if $@@ ne '';
  }
}

sub ctcpreply {
  local($ctcp, $rest)=split(/ +/, $_[1], 2);
  local $vis = 1;
  local $towho = $_[0];
  $ctcp =~ tr/a-z/A-Z/;
  &dohooks("ctcp_reply", $towho, $ctcp, $rest);
  if ($ctcp eq 'PING') {
    $rest = (time-$rest);
    $rest .= ($rest == 1) ? " second" : " seconds";
  } elsif ($ctcp eq 'RANDOM') {
    my $t = (BSD::arc4random::have_kintf() ? "" : "not ") . "pushing to kernel";
    arandom_add("recv $vwho,$puh1;$towho,$rest");
    &tell("*** RANDEX protocol reply from $vwho$puh1 to $towho, ${t}");
    $vis = 0;
  }
  return unless $vis;
  if (&eq($towho, $nick)) {
    &tell("*** CTCP $ctcp reply from $vwho$puh1: $rest");
  } else {
    &tell("*** CTCP $ctcp reply to $towho from $vwho$puh2: $rest");
  }
}

sub load {
  local($f)=@@_;
  &tilde($f);
  if ($f !~ /\//) {
    foreach (@@loadpath) {
      $f="$_/$f", last if -f "$_/$f";
      $f="$_/${f}.pl", last if $f !~ /\.pl$/ && -f "$_/${f}.pl";
    }
  } else {
    $f.=".pl" if -f "${f}.pl" && !-f $f;
  }
  if ($f =~ /\// && -f $f) {
    do $f;
    $@@ =~ s/\n$//, &tell("*\cbE\cb* Load error in $f: $@@") if $@@ ne '';
  } else {
    &tell("*\cbE\cb* $f: File not found");
  }
}

sub restrict {
  &tell("*\cbE\cb* Command not available"), return 0 if $restrict;
  1;
}

sub dosplat {
  #XXX commands like PART can take multiple, comma-separated
  $args =~ s/^\s*\*($|\s)/${talkchannel}${1}/ if $talkchannel;
}

sub expand {
  if ($_[0] eq '$') {
    return '$';
  } elsif ($_[0] =~ /^(\d+)$/) {
    return (split(/ +/, $args))[$1];
  } elsif ($_[0] =~ /^(\d+)-$/) {
    return (split(/ +/, $args, 1+$1))[$1];
  } else {
    return eval "\$$_[0]";
  }
}

$recdepth=0;
$maxrecursion=20;

sub docommand {
  local($line)=@@_;
  local($recdepth)=$recdepth+1;
  &print("*\cbE\cb* Max recursion exceeded!"), return
    if $recdepth > $maxrecursion;
  local($noalias)=($line =~ s/^\///);
  local($silent)=1 if $line =~ s/^\^//;
  local($cmd, $args)=split(/ +/, $line, 2);
  $cmd =~ tr/a-z/A-Z/;
  if (!$noalias && defined($aliases{$cmd})) {
    $line=$aliases{$cmd};
    $line.=($args ne '' ? " ".$args : "")
      unless ($line =~ s/\$(\$|\d+-?|\w+)/&expand($1)/eg);
    $line =~ s/^\///;
    $noalias=1 if $line =~ s/^\///;
    $silent=1 if $line =~ s/^\^//;
    ($cmd, $args)=split(/ +/, $line, 2);
    $cmd =~ tr/a-z/A-Z/;
  }
  if (!$noalias && defined($cmds{$cmd})) {
    eval $cmds{$cmd};
    $@@ =~ s/\n$//, &tell("*\cbE\cb* error in command $cmd: $@@") if $@@ ne '';
  } elsif ($cmd eq 'ALIAS') {
    &getarg;
    if ($newarg =~ /^-/) {
      local($a)=$';
      if ($a eq '') {
	%aliases=();
	&tell("*** All aliases removed");
      } else {
	$a =~ tr/a-z/A-Z/;
	delete $aliases{$a};
	&tell("*** Alias $a removed");
      }
    } elsif ($newarg ne '') {
      $newarg =~ tr/a-z/A-Z/;
      if ($args ne '') {
	$aliases{$newarg}=$args;
	&tell("*** $newarg aliased to $args");
      } else {
	if (defined($aliases{$newarg})) {
	  &tell("*** $newarg is aliased to: $aliases{$newarg}");
	} else {
	  &tell("*** $newarg: no such alias");
	}
      }
    } else {
      foreach $a (sort(keys(%aliases))) {
	&tell("*** $a is aliased to $aliases{$a}");
      }
    }
  } elsif ($cmd eq 'SET') {
    &getarg;
    local($s)=$newarg;
    $s =~ tr/a-z/A-Z/;
    if ($s =~ s/^-//) {
      &tell("*** No such variable $s"), return unless defined($set{$s});
      &doset($s, "");
      &tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
    } elsif ($s ne '') {
      &tell("*** No such variable $s"), return unless defined($set{$s});
      &doset($s, $args) if $args ne '';
      &tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
    } else {
      foreach $s (sort(keys (%set))) {
	&tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
      }
    }
  } elsif ($cmd eq 'NOTIFY' || $cmd eq 'NO') {
    if ($args eq '-') {
      &tell("*** Notify list cleared");
      %notify=();
    } elsif ($args eq '') {
      local($l)='';
      foreach (grep($notify{$_}, keys %notify)) {
	&tell("*** Currently present: $l"), $l='' if length($l)>450;
	$l.=$_." ";
      }
      $l && &tell("*** Currently present: $l");
      $l='';
      foreach (grep(!$notify{$_}, keys %notify)) {
	&tell("*** Currently absent: $l"), $l='' if length($l)>450;
	$l.=$_." ";
      }
      $l && &tell("*** Currently absent: $l");
    } else {
      local($w, $n);
      foreach $w (split(/ +/, $args)) {
	if ($w =~ s/^-//) {
	  ($n)=(grep(&eq($_, $w), keys(%notify)), '');
	  $n ne '' && delete $notify{$n};
	  &tell("*** $w removed from notify list");
	} else {
	  $notify{$w}='0';
	  &tell("*** $w added to notify list");
	  $newisons=1;
	}
      }
    }
  } elsif ($cmd eq 'IGNORE' || $cmd eq 'IG') {
    &getarg;
    if ($newarg eq '-') {
      @@ignore=();
      &tell("*** Ignore list cleared");
    } elsif ($newarg eq '') {
      local($p);
      &tell("*** You're ignoring:");
      foreach (@@ignore) {
	$p=$_;
	$p =~ s/\\//g;
	$p =~ s/\.\*/*/g;
	&tell("***  $p");
      }
    } else {
      local($d, $p)=('');
      $d=1 if $newarg =~ s/^-//;
      if ($newarg =~ /\!.*\@@/) {
      } elsif ($newarg !~ /[\@@\!]/) {
	$newarg.="!*";
      } elsif ($newarg =~ /\@@/) {
	$newarg="*!".$newarg;
      } else {
	$newarg.="\@@*";
      }
      $p=$newarg;
      $newarg =~ s/([^\\])\./$1\\./g;
      $newarg =~ s/\*/\.\*/g;
      $newarg =~ s/([^\.\*\\\w])/\\$1/g;
      if ($d) {
	&tell("*** Removing $p from the ignore list");
	@@ignore=grep(!&eq($_, $newarg), @@ignore);
      } else {
	&tell("*** Ignoring $p ... what a relief!");
	push(@@ignore, $newarg);
      }
    }
  } elsif ($cmd eq 'HIGHLIGHT') {
    if ($args eq '-') {
      @@highlight=();
      &tell("*** Highlight list cleared");
    } elsif ($args eq '') {
      &tell("*** Current highlighting patterns:");
      foreach (@@highlight) {
	&tell("***  $_");
      }
    } elsif ($args =~ s/^-//) {
      &tell("*** Removing $args from highlight list");
      @@highlight = grep(($_ ne $args), @@highlight);
    } else {
      &tell("*** Adding $args to highlight list");
      push(@@highlight, $args);
    }
  } elsif ($cmd eq 'ECHO') {
    &print($args);
  } elsif ($cmd eq 'CLEAR' || $cmd eq 'CL') {
    print $cls if $ansi;
    print "`#ssfe#l\n" if $ssfe;
  } elsif ($cmd eq 'EVAL') {
    &restrict || return;
    eval ($args);
    $@@ =~ s/\n$//, &tell("*\cbE\cb* eval error: $@@") if $@@ ne '';
  } elsif ($cmd eq 'HELP') {
    &tell("*\cbH\cb* Help not available"), return unless @@help;
    $args='main' if $args =~ /^\s*$/;
    $args =~ s/ *$//;
    local($found)='';
    foreach (@@help) {
      if (/^\@@/) {
	last if $found;
	if (&eq($_, "\@@$args")) {
	  $found=1;
	  &tell("*\cbH\cb* Help on $args") if $args ne 'main';
	}
      } else {
	&tell("*\cbH\cb* $_") if $found;
      }
    }
    &tell("*\cbH\cb* Unknown help topic; try /help") unless $found;
  } elsif ($cmd eq 'LOAD') {
    &restrict || return;
    &getarg;
    &tell("*\cbE\cb* Yeah, but what?"), return if $newarg eq '';
    &load($newarg);
  } elsif ($cmd eq 'VERSION') {
    &tell("*** \cbsirc\cb version $version (RANDOM=${BSD::arc4random::RANDOM}), written in \cbperl\cb by \cborabidoo\cb");
    $_=$add_ons;
    s/^\+//;
    s/\+/, /g;
    &tell("*** add-ons: $_") if $_;
    $connected==2 && &sl("VERSION $args");
  } elsif ($cmd eq 'CD') {
    &restrict || return;
    &getarg;
    if ($newarg ne '') {
      &tilde($newarg);
      chdir($newarg) || &tell("*\cbE\cb* Can't chdir to $newarg");
    }
    local($cwd); chop($cwd=qx/pwd/);
    &tell("*** Current directory is $cwd");
  } elsif ($cmd eq 'SYSTEM') {
    &restrict || return;
    system($args);
  } elsif ($cmd eq 'BYE' || $cmd eq 'QUIT' || $cmd eq 'EXIT' ||
		$cmd eq 'SIGNOFF') {
    $args || ($args="using \cbsirc\cb version $version$add_ons (RANDOM=${BSD::arc4random::RANDOM})");
    &sl("QUIT :$args") if $connected;
    &exit;
  } elsif ($cmd eq 'SERVER') {
    $args=$1 if $args =~ /^\s*(.*)\s*$/;
    $args=$server0 if $args eq '0';
    $args=$server1 if $args eq '1';
    if ($args eq '') {
      &tell($connected ? "*** Your current server is $server" :
			 "*** You're not connected to a server");
    } else {
      &parseserver($args);
      $server=$', $nick=$1 if $server =~ /^([^\@@]+)\@@/;
      $port || ($port=$port0);
      $pass || ($pass=$pass0);
      if ($connected) {
	&sl("QUIT :changing servers");
	&ssl_cleanup;
	close($S);
	delete $buffer{$S};
      }
      $connected=0;
      &bindtoserver;
    }
  } elsif ($cmd eq 'MSG' || $cmd eq 'M') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &msg($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'QUERY') {
    if ($args) {
      $args =~ s/\s+$//;
      $query=$args;
      &tell("*** Starting conversation with $query");
      &dostatus;
    } elsif ($query) {
      &tell("*** Ending conversation with $query");
      $query='';
      &dostatus;
    } else {
      &tell("*** You aren't querying anyone :p");
    }
  } elsif ($connected<2) {
    &tell("*** You're not connected to a server");
  } elsif ($cmd eq 'AWAY') {
      &sl($args ? "AWAY :$args" : "AWAY");
  } elsif ($cmd eq 'NEXT') {
    if ($#channels>0) {
      $talkchannel=shift(@@channels);
      push(@@channels, $talkchannel);
      !$ssfe && &tell("*** Talking to $talkchannel now");
      &dostatus;
    }
  } elsif ($cmd eq 'SAY' || $cmd eq '') {
    &say($args);
  } elsif ($cmd eq 'NOTICE' || $cmd eq 'N') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &notice($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'DESCRIBE' || $cmd eq 'DE') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &describe($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'KICK' || $cmd eq 'K') {
    &dosplat;
    &getarg;
    local($c)=$talkchannel;
    if ($newarg =~ /^[\#\&\+]/) {
      $c=$newarg;
      &getarg;
    }
    if ($newarg) {
      $args || ($args=$nick);
      &sl("KICK $c $newarg :$args");
    } else {
      &tell("*\cbE\cb* You must specify a nick!");
    }
  } elsif ($cmd eq 'DISCONNECT' || $cmd eq 'DIS') {
    &ssl_cleanup;
    &tell("*** Disconnecting from $server");
    close($S);
    delete $buffer{$S};
    $connected=0;
    &dohooks("disconnect");
  } elsif ($cmd eq 'INVITE' || $cmd eq 'INV' || $cmd eq 'I') {
    local(@@ns)=split(/ +/, $args);
    local($l, $c)=(pop(@@ns), $talkchannel);
    if ($l =~ /^[\#\&\+]/) {
      $c=$l;
    } else {
      $l && push(@@ns, $l);
    }
    foreach (@@ns) {
      &sl("INVITE $_ $c");
    }
  } elsif ($cmd eq 'CTCP') {
    &dosplat;
    if ($args) {
      &getarg;
      local($towho)=$newarg;
      &getarg;
      $newarg =~ tr/a-z/A-Z/;
      $args=" ".$args if $args ne '';
      &sl("PRIVMSG $towho :\ca$newarg$args\ca");
      &dohooks("send_ctcp", $towho, $newarg.$args);
      &tell("*** Sending a CTCP $newarg$args to $towho");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'PING') {
    &dosplat;
    if ($args) {
      &getarg;
      local($t)=time;
      &sl("PRIVMSG $newarg :\caPING $t\ca");
      &dohooks("send_ctcp", $newarg, "PING $t");
      &tell("*** Sending a CTCP PING to $newarg");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'RANDEX') {
    &dosplat;
    if ($args) {
      arandom_add("send $args");
      local($t) = pack("u", BSD::arc4random::arc4random_bytes(32));
      chop($t);
      &getarg;
      &sl("PRIVMSG $newarg :\caENTROPY $t\ca");
      &tell("*** Initiating the RANDEX protocol with $newarg");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'ME' || $cmd eq 'D') {
    if ($talkchannel) {
      &describe($talkchannel, $args);
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'TOPIC' || $cmd eq 'T') {
    &dosplat;
    local($c)=$talkchannel;
    if ($args =~ /^[\#\&\+]/) {
      &getarg;
      $c=$newarg;
    }
    if ($args) {
      &sl("TOPIC $c :$args");
    } else {
      &sl("TOPIC $c");
    }
  } elsif ($cmd eq 'PART' || $cmd eq 'P') {
    &dosplat;
    local($c)=$talkchannel;
    if ($args =~ /^[\#\&\+]/) {
      &getarg;
      $c=$newarg;
    }
    if ($args) {
      &sl("PART $c :$args");
    } else {
      &sl("PART $c");
    }
  } elsif ($cmd eq 'LL') {
    if ($talkchannel) {
      &sl("WHO $talkchannel");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'OP') {
    local($c, $n, $l)=($talkchannel, 0, '');
    &getarg, $c=$newarg if ($args =~ /^[\#\&\+]/);
    local(@@ppl)=split(/ +/, $args);
    foreach (@@ppl) {
      if ($n<4) {
	$l .= " ".$_;
	$n++;
      } else {
	&sl("MODE $c +oooo $l");
	$l=$_;
	$n=1;
      }
    }
    $l && &sl("MODE $c +oooo $l");
  } elsif ($cmd eq 'DEOP') {
    local($c, $n, $l)=($talkchannel, 0, '');
    &getarg, $c=$newarg if ($args =~ /^[\#\&\+]/);
    local(@@ppl)=split(/ +/, $args);
    foreach (@@ppl) {
      if ($n<4) {
	$l .= " ".$_;
	$n++;
      } else {
	&sl("MODE $c -oooo $l");
	$l=$_;
	$n=1;
      }
    }
    $l && &sl("MODE $c -oooo $l");
  } elsif ($cmd eq 'WI' || $cmd eq 'WHOIS') {
    &sl($args eq '' ? "WHOIS $nick" : "WHOIS $args");
  } elsif ($cmd eq 'W') {
    &getarg;
    $newarg=$nick if $newarg eq '';
    &sl("WHOIS $newarg $newarg");
  } elsif ($cmd eq 'WHO') {
    &dosplat;
    if ($args =~ /^[\s\*]*$/) {
      &tell("*** Uhm, better not");
    } else {
      &sl("WHO $args");
    }
  } elsif ($cmd eq 'JOIN' || $cmd eq 'J') {
    $args=$invited if $args eq '';
    unless ($args =~ /^[\#\&\+]/) {
      $args='#'.$args;
    }
    if (grep(&eq($_, $args), @@channels)) {
      &tell("*** Talking to $args now");
      $talkchannel=$args;
      &dostatus;
    } else {
      &sl("JOIN $args");
    }
  } elsif ($cmd eq 'QUOTE' || $cmd eq 'Q') {
    $args ne '' && &sl($args);
  } elsif ($cmd eq 'UMODE') {
    &sl("MODE $nick $args");
  } elsif ($cmd eq 'NS') {
    if ($args =~ /%s/) {
      &getuserpass("NickServ Password? ", "Passwd: ");
      $args =~ s/%s/$_/g;
    }
    &sl("NS $args");
  } elsif ($cmd eq 'MO' || $cmd eq 'MODE') {
    &dosplat;
    $args=$talkchannel if $args eq '';
    if ($args) {
      &sl("MODE $args");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'NA' || $cmd eq 'NAMES') {
    &dosplat;
    $args=$talkchannel if $args eq '';
    if ($args) {
      &sl("NAMES $args");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'LIST') {
    &dosplat;
    $listmin=0;
    $listmax=100000;
    $listpat='';
    if ($args =~ /\*/ || $args =~ /-m[ia][nx]\s/i) {
      while (&getarg, $newarg ne '') {
	if ($newarg =~ /^-min$/i) {
	  &getarg;
	  $listmin=$newarg if $newarg>0;
	} elsif ($newarg =~ /^-max$/i) {
	  &getarg;
	  $listmax=$newarg if $newarg>0;
	} else {
	  $newarg =~ s/([^\\])\./$1\\./g;
	  $newarg =~ s/\*/\.\*/g;
	  $newarg =~ s/([^\.\*\\\w])/\\$1/g;
	  $listpat=$newarg;
	}
      }
      &sl("LIST");
    } else {
      &sl($line);
    }
  } elsif ($cmd eq 'RPING') {
    &getarg;
    &sl("RPING $newarg ".time);
  } elsif ($cmd eq 'KILL') {
    &getarg;
    if ($newarg) {
      $args || ($args=$nick);
      &sl("KILL $newarg :$args");
    } else {
      &tell("*\cbE\cb* You must specify a nick!");
    }
  } elsif ($cmd eq 'OPER') {
    &getarg;
    $newarg=$nick unless $newarg;
    &getuserpass("Oper password? ", "Passwd: "), $args=$_ unless $args;
    &sl("OPER $newarg $args");
  } elsif ($cmd eq 'CONNECT') {
    &getarg;
    local($srv)=$newarg;
    &getarg;
    if ($args) {
      &sl("CONNECT $srv $newarg $args");
    } else {
      &sl("CONNECT $srv 6667 $newarg");
    }
  } elsif ($cmd eq 'SQUIT') {
    &getarg;
    &sl("SQUIT $newarg :$args");
  } elsif ($cmd eq 'WHOWAS' || $cmd eq 'ADMIN' || $cmd eq 'STATS' ||
	   $cmd eq 'INFO' || $cmd eq 'LUSERS' || $cmd eq 'SQUIT' ||
	   $cmd eq 'REHASH' || $cmd eq 'DIE' || $cmd eq 'LINKS' ||
	   $cmd eq 'NOTE' || $cmd eq 'WALLOPS' || $cmd eq 'NICK' ||
	   $cmd eq 'MOTD' || $cmd eq 'TIME' || $cmd eq 'TRACE' ||
	   $cmd eq 'USERS' || $cmd eq 'SILENCE' || $cmd eq 'MAP' ||
	   $cmd eq 'UPING') {
    &sl($line);
  } elsif ($cmd eq 'ACCEPT') {
    if ($args eq '') {
      $args = '*';
    }
    $args =~ s/ /,/g;
    &sl("ACCEPT $args");
  } else {
    &tell("*\cbE\cb* Unknown command: $cmd");
  }
}

sub douserline {
  local($skip, $line)=(0, @@_);
  if ($line =~ /^\@@ssfe\@@/) {
    $ssfe=$raw_mode=1;
    $add_ons.="+ssfe";
    &dostatus;
  } else {
    &dohooks("command", $line);
    return if $skip;
    if ($line =~ s/^\///) {
      &docommand($line);
    } elsif ($query ne '') {
      &msg($query, $line);
    } else {
      &say($line);
    }
  }
}

$ssfe_getline="`#ssfe#p";
sub getuserline {
  local($skip)='';
  &dohooks("input", $_[0], $_[1]);
  return if $skip;
  print $_[0];
  print "\n" if $raw_mode;
  print $ssfe_getline.$_[1]."\n" if $ssfe;
  while (($_=<STDIN>) ne '') {
    if (/^\@@ssfe\@@/) {
      $ssfe || ($add_ons.="+ssfe");
      $ssfe=$raw_mode=1;
      &dostatus;
    } else {
      &exit if $_ eq '';
      chop;
      return;
    }
  }
  &exit;
}

sub getuserpass {
  local($ssfe_getline)="`#ssfe#P";
  &getuserline;
}

%cmds=();
sub addcmd {
  local($cmd)=$_[0];
  $cmd =~ tr/a-z/A-Z/;
  $cmds{$cmd}="&cmd_".$_[0].";";
}

sub addhelp {
  local($cmd, $txt)=@@_;
  $cmd =~ tr/A-Z/a-z/;
  push(@@help, "\@@".$cmd);
  foreach (split(/\n/, $txt)) {
    s/\$v/$version/g;
    s/\$d/$date/g;
    push (@@help, $_);
  }
}

sub addset {
  local($var)=$_[0];
  $var =~ tr/a-z/A-Z/;
  $sets{$var}="set_".$_[0];
}

sub addsel {
  $buf_fds{$_[0]}="sel_".$_[1] if $_[2];
  $sel_fds{$_[0]}="sel_".$_[1] unless $_[2];
}

sub remsel {
  delete $buf_fds{$_[0]};
  delete $sel_fds{$_[0]};
}

@@hooks=("action", "ctcp", "ctcp_reply", "input", "invite", "join", "kick",
	"leave", "mode", "msg", "nick", "notice", "server_notice",
	"notify_signoff", "notify_signon", "public", "raw_irc",
	"send_action", "send_text", "send_notice", "signoff", "topic",
	"disconnect", "status", "print", "command", "send_ctcp", "capab");

sub addhook {
  local($type, $name)=@@_;
  $type =~ tr/A-Z/a-z/;
  $name="hook_".$name;
  if ($type =~ /^\d\d\d$/ || grep(($_ eq $type), @@hooks)) {
    ($type =~ /^\d\d\d$/) && ($type="num_".$type);
    eval "*ugly_hack_hooks=*${type}_hooks;";
    unless (grep(($_ eq $name), @@ugly_hack_hooks)) {
      push(@@ugly_hack_hooks, $name);
    }
  } else {
    &tell("*\cbE\cb* $type: no such hook");
  }
}

sub remhook {
  local($type, $name)=@@_;
  $type =~ tr/A-Z/a-z/;
  $name="hook_".$name;
  if ($type =~ /^\d\d\d$/ || grep(($_ eq $type), @@hooks)) {
    ($type =~ /^\d\d\d$/) && ($type="num_".$type);
    eval "*ugly_hack_hooks=*${type}_hooks;";
    @@ugly_hack_hooks=grep(($_ ne $name), @@ugly_hack_hooks);
  } else {
    &tell("*\cbE\cb* $type: no such hook");
  }
}

sub userhost {
  push (@@waituh, $_[0]);
  push (@@douh, $_[1]);
  push (@@erruh, $_[2]);
  &sl("USERHOST $_[0]");
}

sub deltimer {
  local($ref)=$_[0];
  local($i);
  if ($#trefs>=0 && $ref!=0) {
    # delete the timer if it exists
    for ($i=0; $i<=$#trefs; $i++) {
      if ($trefs[$i]==$ref) {
	splice(@@trefs,$i,1);
	splice(@@timers,$i,1);
	splice(@@timeactions,$i,1);
	last;
      }
    }
  }
}

sub timer {
  local(@@r, @@t, @@a)=();
  local($t)=$_[0]+time;
  local($ref)=$_[2] || 0;
  &deltimer($ref) if $ref;
  while ($#timers>=0 && $timers[0]<=$t) {
    push (@@r, shift(@@trefs));
    push (@@t, shift(@@timers));
    push (@@a, shift(@@timeactions));
  }
  @@trefs=(@@r, $ref, @@trefs);
  @@timers=(@@t, $t, @@timers);
  @@timeactions=(@@a, $_[1], @@timeactions);
}

sub disappeared {
  local($n)=(grep(&eq($_, $_[0]), keys(%notify)));
  if ($n ne '' && $notify{$n}>0) {
    local($silent)=0;
    &dohooks("notify_signoff", $_[0]);
    &tell("*\cb(\cb* Signoff by $_[0] detected");
    $notify{$n}=0;
  }
}

sub appeared {
  local($t, $n)=(time, grep(&eq($_, $_[0]), keys(%notify)));
  if ($n ne '') {
    if ($notify{$n}==0) {
      local($silent)=0;
      &dohooks("notify_signon", $_[0]);
      &tell("*\cb)\cb* Signon by $_[0] detected!");
    }
    $notify{$n}=$t;
  }
}

$lastsendison=0;
sub send_isons {
  local($l)='';
  foreach (keys %notify) {
    &sl("ISON : $l"), $l='' if (length($l)>500);
    $l.=$_." ";
  }
  &sl("ISON :$l") if $l;
  $lastsendison=time;
  $newisons='';
  $checkisons=1;
}

sub signoffs {
  foreach (keys %notify) {
    if ($notify{$_}>0 && $notify{$_}<$lastsendison) {
      $notify{$_}=0;
      local($silent)=0;
      &dohooks("notify_signoff", $_);
      &tell("*\cb(\cb* Signoff by $_ detected");
    }
  }
  $checkisons='';
}

sub modestripper {
  local($chnl, $what)=@@_;
  $chnl =~ tr/A-Z[]\\~/a-z{}|^/;
  local($how, $modes, @@args)=('+', split(/ +/, $what));
  foreach $m (split(//, $modes)) {
    if ($m =~ /[\-\+]/) {
      $how=$m;
    } elsif ($m =~ /[vb]/) {
      shift(@@args);
    } elsif ($m eq 'k') {
      $how eq '+' ? ($chankey{$chnl}=$args[0]) : delete $chankey{$chnl};
      shift(@@args);
    } elsif ($m eq 'l') {
      $how eq '+' ? ($limit{$chnl}=shift(@@args)) : delete $limit{$chnl};
    } elsif ($m eq 'o') {
      $haveops{$chnl}=($how eq '+') ? "@@" : "" if (&eq(shift(@@args), $nick));
    } elsif ($m eq 'h') {
      $haveops{$chnl}=($how eq '+') ? "%" : "" if (&eq(shift(@@args), $nick));
    } else {
      $mode{$chnl} =~ s/$m//g;
      $mode{$chnl}.=$m if $how eq '+';
    }
  }
}

sub umodechange {
  local($what)=@@_;
  local($how)='+';
  foreach $m (split(//, $what)) {
    if ($m =~ /[\-\+]/) {
      $how=$m;
    } else {
      $umode =~ s/$m//g;
      $umode.=$m if ($how eq '+' && $m !~ /\s/);
    }
  }
}

sub ignored {
  foreach (@@ignore) {
    return 1 if $_[0] =~ /^${_}$/;
  }
  return '';
}

sub dorcfile {
  return if !open(RCFILE, "<$_[0]");
  while (<RCFILE>) {
    chop;
    s/^\///;
    next if /^\#/;
    &docommand($_) if $_;
    $silent=$skip='';
  }
  close(RCFILE);
}

sub loadrc {
  $rcloaded=1;
  $sysrc && &dorcfile($sysrc);
  $rcfile && &dorcfile($rcfile);
}

sub selline {
  $leftover=0;
  $rin=$rout="\0" x 32;
  foreach ($S, 'STDIN', keys(%buf_fds)) {
    next unless defined $buffer{$_};
    $leftover=1, return $_ if $buffer{$_} =~ /\n/;
  }
  if (($ssl_efd ne '') && (defined $buffer{$ssl_efd})) {
    $leftover=1, return $ssl_efd if $buffer{$ssl_efd} =~ /\n/;
  }
  foreach (keys(%sel_fds), keys(%buf_fds)) {
    vec($rin, fileno($_), 1)=1;
  }
  vec($rin, fileno('STDIN'), 1)=1 if $interactive;
  vec($rin, fileno($S), 1)=1 if $connected;
  vec($rin, fileno($ssl_efd), 1)=1 if ($ssl_efd ne '');
  if ($#timers<0 || $timers[0]>time+30) {
    select($rout=$rin, undef, undef, 30);
  } elsif ($timers[0]<=time) {
    select($rout=$rin, undef, undef, 0);
  } else {
    select($rout=$rin, undef, undef, $timers[0]-time);
  }
}

sub getnick {
  &getuserline("Pick a nick: ", "Nick: ");
  $nick=$_;
  &sl("NICK $_");
  &dostatus;
}

sub parse_capab {
  local $skip=0;
  &dohooks("capab", $capab_cmd, $capab_response);
  if (!$skip) {
    if ($capab_response eq '') {
      &tell("*\cbE\cb* Unknown capability $capab_cmd");
    } elsif ($capab_response ne $capab_cmd) {
      &tell("*\cbE\cb* Expected reply for capability $capab_cmd");
      &tell("*\cbE\cb* Processing capability $capab_response instead");
    }
    if ($capab_response eq 'IDENTIFY-MSG') {
      $has_identifymsg = 1;
      &tell("*** Messages by identified users will be marked specially");
    }
  }
}

sub send_capab {
  $capab_cmd = $_[0];
  &sl("CAPAB $capab_cmd");
}

sub login_cmds {
  if ($has_capab) {
    &send_capab('IDENTIFY-MSG');
  } else {
    $opportunistic_cmd = "CAP";
    &sl("CAP REQ :identify-msg");
  }
  &timer(30, '$opportunistic_cmd = "";');
}

sub parse_cap {
  local $skip=0;
  &dohooks("cap", $args);
  return if $skip;
  &yetonearg;
  &yetonearg;
  if ($newarg eq 'ACK') {
    if ($args =~ /\bidentify-msg\b/) {
      $has_identifymsg = 1;
      &tell("*** Messages by identified users will be marked specially");
    }
  }
}

sub donumeric {
  local($from)=($who eq $myserver ? '' : " (from ${who})");
  if ($cmd eq '401') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* Cannot find $newarg on irc$from");
  } elsif ($cmd eq '402') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: no such server$from");
  } elsif ($cmd eq '403') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: no such channel$from");
  } elsif ($cmd eq '406') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: there was no such nickname$from");
  } elsif ($cmd eq '421') {
    &yetonearg;
    &yetonearg;
    if ($opportunistic_cmd eq $newarg) {
      $opportunistic_cmd = '';
    } else {
      &tell("*\cb?\cb* $newarg: unknown command$from");
    }
  } elsif ($cmd =~ /^4[012]/) {
    $args =~ s/^[^:]*://;
    &tell("*** $args$from");
  } elsif ($cmd eq '431') {
    &tell("*** Was expecting a nickname somewhere...");
    &getnick if $connected<2;
  } elsif ($cmd eq '432') {
    if ($connected==2) {
      &tell("*\cbN\cb* Invalid nickname, you're still \"$nick\"");
    } else {
      &tell("*\cbN\cb* Invalid nickname!");
      &getnick;
    }
  } elsif ($cmd eq '433') {
    if ($connected==2) {
      &tell("*\cbN\cb* Nick already taken, you're still \"$nick\"");
    } else {
      &tell("*\cbN\cb* Nick already taken!");
      &getnick;
    }
  } elsif ($cmd eq '441') {
    local($g, $w, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* $w is not on channel $c$from");
  } elsif ($cmd eq '442') {
    local($w, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* You're not on channel $c$from");
  } elsif ($cmd eq '443') {
    local($w, $o, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* $o is already on channel $c$from");
  } elsif ($cmd eq '465') {
    &tell("*\cbE\cb* You are banned from this server$from");
  } elsif ($cmd eq '461') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbE\cb* The command $newarg needs more arguments than that$from");
  } elsif ($cmd =~ /^47[1345]$/) {
    &yetonearg;
    &yetonearg;
    local($r);
    if ($cmd eq '471') {
      $r="channel is full";
    } elsif ($cmd eq '473') {
      $r="channel is invite-only";
    } elsif ($cmd eq '474') {
      $r="banned from channel";
    } else {
      $r="bad channel key";
    }
    &tell("*\cbE\cb* Can't join $newarg: ${r}$from");
  } elsif ($cmd eq '301') {
    &yetonearg;
    &yetonearg;
    my $skipawaytell = 0;
    my $awaytime = time;
    if (($awaytimes{$newarg}) &&
	(($awaytime - $awaytimes{$newarg}) < 300) &&
	($awaymsgs{$newarg} eq $args)) {
      $skipawaytell = 1;
    }
    $awaytimes{$newarg} = $awaytime;
    $awaymsgs{$newarg} = $args;
    &tell("*** $newarg is away: $args") unless $skipawaytell;
  } elsif ($cmd eq '302') {
    &yetonearg;
    &yetonearg;
    local($n, $do, $err)=(shift(@@waituh), shift(@@douh), shift(@@erruh));
    if ($newarg =~ /^([^\s\*=]+)[\*]?=([\-+])/) {
      $who=$1;
      local($adr)=$';
      if ($adr =~ /\@@/) {
	$user=$`;
	$host=$';
      } else {
	$user=$host='';
      }
      if (&eq($who, $n)) {
	eval $do;
	$@@ =~ s/\n$//, &tell("*\cbE\cb* error in userhost: $@@") if $@@ ne '';
      } else {
	&tell("*\cbE\cb* userhost returned for unexpected nick $who");
      }
    } else {
      if (defined($err)) {
	eval $err;
	$@@ =~ s/\n$//, &tell("*\cbE\cb* error in userhost: $@@") if $@@ ne '';
      } else {
	&tell("*\cb?\cb* Cannot find $n on irc");
      }
    }
  } elsif ($cmd eq '303') {
    &yetonearg;
    local($n);
    foreach $n (split(/ +/, $args)) {
      &appeared($n);
    }
  } elsif ($cmd eq '305') {
    &tell("*** You are no longer marked as away");
    $away='';
    &dostatus;
  } elsif ($cmd eq '306') {
    &tell("*** You are marked as being away");
    $away=1;
    &dostatus;
  } elsif ($cmd eq '311') {
    local($g, $n, $u, $m, $g, $r)=split(/ +/, $args, 6);
    $r =~ s/^://;
    &tell("*** $n is $u\@@$m ($r)");
  } elsif ($cmd eq '312') {
    &yetonearg;
    &yetonearg;
    &yetonearg;
    local($s)=$newarg;
    &tell("*** on IRC via server $s ($args)");
  } elsif ($cmd eq '313') {
    &yetonearg;
    &yetonearg;
    &tell("*** $newarg is an IRC Operator");
  } elsif ($cmd eq '314') {
    local($g, $n, $u, $m, $g, $r)=split(/ +/, $args, 6);
    $r =~ s/^://;
    &tell("*** $n was $u\@@$m ($r)");
  } elsif ($cmd eq '317') {
    &yetonearg;
    &yetonearg;
    local($n)=$newarg;
    &yetonearg;
    if ($newarg>=3600) {
      &tell("*** $n has been ".int($newarg/3600)." hours, ".
	  int(($newarg%3600)/60)." minutes and ".
	  ($newarg%60)." seconds idle");
    } elsif ($newarg>=60) {
      &tell("*** $n has been ".int($newarg/60)." minutes and ".
	    ($newarg%60)." seconds idle");
    } elsif ($newarg==1) {
      &tell("*** $n has been $newarg second idle");
    } else {
      &tell("*** $n has been $newarg seconds idle");
    }
    delete $awaytimes{$n};
    delete $awaymsgs{$n};
  } elsif ($cmd eq '319') {
    local($g, $g, $c)=split(/ +/, $args, 3);
    $c =~ s/^://;
    &tell("*** on channels: $c");
  } elsif ($cmd eq '322') {
    local($g, $c, $n, $r)=split(/ +/, $args, 4);
    $r =~ s/^://;
    $n>=$listmin && $n <=$listmax && (!$listpat || $c =~ /^${listpat}$/i)
      && &tell(sprintf("*** %-10s %-5s %s", $c, $n, $r));
  } elsif ($cmd eq '323') {
    $listmin=0;
    $listmax=100000;
    $listpat='';
  } elsif ($cmd eq '324') {
    local($g, $c, $m)=split(/ +/, $args, 3);
    $m =~ s/^://;
    $m =~ s/ $//;
    $c =~ tr/A-Z[]\\~/a-z{}|^/;
    if (grep(&eq($_, $c), @@channels)) {
      if (defined($mode{$c})) {
	&tell("*\cb+\cb* Mode for channel $c is \"$m\"");
      } else {
	$mode{$c}='';
      }
      &modestripper($c, $m);
      &dostatus;
    } else {
      &tell("*\cb+\cb* Mode for channel $c is \"$m\"");
    }
  } elsif ($cmd eq '329') {
    &yetonearg;
    &yetonearg;
    local($c)=$newarg;
    &yetonearg;
    local($t)=($newarg ? ("created " . &date($newarg)) : "0 TS");
    &tell("*** $c : $t");
  } elsif ($cmd eq '331') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbT\cb* No topic is set on channel $newarg");
  } elsif ($cmd eq '332') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbT\cb* Topic for $newarg: $args");
  } elsif ($cmd eq '333') {
    local($g, $c, $n, $t)=split(/ +/, $args, 4);
    local($d)=&date($t);
    &tell("*\cbT\cb* Topic for $c set by $n on $d");
  } elsif ($cmd eq '318' || $cmd eq '315' || $cmd eq '369' ||
	   $cmd eq '321' || $cmd eq '366' ||
	   $cmd eq '365' || $cmd eq '368' || $cmd eq '374' ||
	   $cmd eq '219' || $cmd eq '007') {
    #nothing!
  } elsif ($cmd eq '341') {
    local($g, $n, $c)=split(/ +/, $args, 3);
    &tell("*\cbI\cb* Inviting $n to channel $c");
  } elsif ($cmd eq '352') {
    local($g, $c, $u, $m, $s, $n, $st, $g, $i)=split(/ +/, $args, 9);
    &tell(sprintf("%-10s %-9s %4s %s\@@%s (%s)", $c, $n, $st, $u, $m, $i));
  } elsif ($cmd eq '353') {
    local($g, $m, $c, $r)=split(/ +/, $args, 4);
    local($n)=$nick;
    $n =~ s/(\W)/\\$1/g;
    $r =~ s/^://;
    &tell("*\cb#\cb* Users on $c: $r");
    $c =~ tr/A-Z[]\\~/a-z{}|^/;
    $haveops{$c}="@@" if ($r =~ /\@@${n}( |$)/i);
    &dostatus if &eq($c, $talkchannel);
  } elsif ($cmd eq '221') {
    &yetonearg;
    &tell("*\cb+\cb* Your user mode is \"$args\"");
  } elsif ($cmd eq '200') {
    local($b, $l, $v, $n, $s)=split(/ +/, $args);
    $s =~ s/^://;
    &tell("*** $l $who ($v) ==> $n $s");
  } elsif ($cmd eq '205') {
    local($b, $u, $h, $n)=split(/ +/, $args);
    $n =~ s/^://;
    &tell("*** $u [$h] ==> $n");
  } elsif ($cmd =~ /^20/) {
    local($b, $t, $n, $r)=split(/ +/, $args, 4);
    &tell("*** $t [$n] ==> $r");
  } elsif ($cmd eq '375' || $cmd eq '372' || $cmd =~ /^25/) {
    &yetonearg;
    &tell("*** $args");
  } elsif ($cmd eq '005') {
    &yetonearg;
    if ($args =~ /\bCAPAB\b/) {
      $has_capab = 1;
    }
    &tell("*** $args");
  } elsif ($cmd eq '290') {
    &yetonearg;
    $capab_response = $args;
    &parse_capab;
  } elsif ($cmd eq '376') {
    &login_cmds;
  } elsif ($cmd eq '281') {
    &yetonearg;
    &tell("*** Accept list is: $args");
  } else {
    &yetonearg;
    #$args =~ s/ :/ /;
    &tell("*** $args$from");
  }
}

# main prog

print "`#ssfe#i\n" unless (-t STDOUT);
&tell("*** Welcome to \cbsirc\cb version $version (RANDOM=${BSD::arc4random::RANDOM}); type /help for help");

&load($sysinit) if $sysinit ne '' && -f $sysinit;
&load($initfile) if !$restrict && $initfile ne '' && -f $initfile;

&bindtoserver;
while (1) {
  $silent=$skip='';
  if ($connected==2) {
    $time=time;
    &loadrc unless $rcloaded;
    &send_isons
      if $time>=$lastsendison+90 || ($newisons && $time>=$lastsendison+10);
    &signoffs if $checkisons && ($time>=$lastsendison+30);
  }
  $fh=&selline;
  foreach $rfh (keys (%buf_fds)) {
    if (vec($rout, fileno($rfh), 1) || ($leftover && $fh eq $rfh)) {
      &gl($rfh) || next;
      local($line, $h)=($_, $buf_fds{$rfh});
      delete $buf_fds{$rfh}, delete $buffer{$rfh}, close($rfh) if $_ eq '';
      eval { &$h($line); };
      $@@ =~ s/\n$//, &tell("*\cbE\cb* error in buffered fd hook &$h: $@@")
	if $@@ ne '';
    }
  }
  foreach $rfh (keys (%sel_fds)) {
    if (vec($rout, fileno($rfh), 1)) {
      local($h)=$sel_fds{$rfh};
      eval { &$h(); };
      $@@ =~ s/\n$//, &tell("*\cbE\cb* error in unbuffered fd hook &$h: $@@")
	if $@@ ne '';
    }
  }
  while ($#timers>=0 && $timers[0]<=time) {
    shift (@@timers);
    shift (@@trefs);
    eval shift (@@timeactions);
    $@@ =~ s/\n$//, &tell("*\cbE\cb* error in timer: $@@") if $@@ ne '';
  }
  if (($ssl_efd ne '') &&
   (($leftover && $fh eq $ssl_efd) || vec($rout, fileno($ssl_efd), 1))) {
    &gl($ssl_efd) || next;
    if ($_ eq '') {
      &ssl_cleanup;
      &tell("*\cbS\cb* Connection to TLS stderr lost");
      next;
    }
    chop;
    s/\x00//g;
    &tell("*\cbS\cb* TLS: $_");
  }
  if (vec($rout, fileno(STDIN), 1) || ($leftover && $fh eq 'STDIN')) {
    &gl('STDIN') || next;
    &exit if $_ eq '';
    chop;
    s/\x00//g;
    &douserline($_) if $_ ne '';
  }
  if ($connected && (($leftover && $fh eq $S) || vec($rout, fileno($S), 1))) {
    &gl($S) || next;
    if ($_ eq '') {
      &ssl_cleanup;
      &tell("*\cbE\cb* Connection to server lost");
      close($S);
      delete $buffer{$S};
      $connected=0;
      &dohooks("disconnect");
      next;
    }
    chop;
    s/\x00//g;
    $serverline=$_;
    $_=$server." ".$_ unless /^:/;
    ($who, $cmd, $args)=split(/ /, $_, 3);
    $cmd =~ tr/a-z/A-Z/;
    $who =~ s/^://;
    $args =~ s/^:// if defined $args;
    $user=$host=$puh1=$puh2='';
    if ($who =~ /^([^!@@ ]+)!([^@@ ]+)@@([^ ]+)$/) {
      ($who, $user, $host) = ($1, $2, $3);
      $puh1="!$user\@@$host" if $set{"PRINTUH"} ne 'none';
      $puh2=$puh1 if $set{"PRINTUH"} eq 'all';
    }
    $vwho = $who;
    &dohooks("raw_irc", $cmd, $args);
    next if $skip;
    if (($cmd eq 'PRIVMSG' || $cmd eq 'NOTICE') &&
     &ignored("$who!$user\@@$host")) {
      $logging && print LOG "[" . sprintf("%02d:%02d:%02d", (localtime)[2],
       (localtime)[1], (localtime)[0]) . "] ignored: " . $serverline . "\n";
      next;
    }
    if ($cmd eq '001') {
      $connected=2;
      $myserver=$who;
      ($nick)=split(/ /, $args, 2);
    }
    if ($cmd =~ /^\d\d\d$/) {
      &dohooks("num_".$cmd, $args);
      next if $skip;
      &donumeric;
    } elsif ($cmd eq 'CAP') {
      &parse_cap;
    } elsif ($cmd eq 'PING') {
      &sl("PONG $args");
    } elsif ($cmd eq 'PRIVMSG') {
      &yetonearg;
      $msgchannel = $newarg;
      &strip_idmsg if $has_identifymsg;
      if ($args =~ /^\001([^\001]*)\001$/ && $set{'CTCP'} ne 'none') {
	&ctcp($newarg, $1);
      } elsif (!$printchan && &eq($newarg, $talkchannel)) {
	&dohooks("public", $newarg, $args);
	&tell_hi("<${who}> ", $args);
      } elsif ($newarg =~ /^[\#\&\+]/) {
	&dohooks("public", $newarg, $args);
	&tell_hi("<${who}:${newarg}> ", $args);
      } elsif (&eq ($newarg, $nick)) {
	print "`#ssfe#t/m $who \n" if $ssfe;
	print "`#ssfe#o[$who$puh1] $args\n" if $ssfe;
	&dohooks("msg", $args);
	&tell_hi("[\cb${who}\cb${puh1}] ", $args);
      } else {
	&tell_hi("[\cb${who}\cb${puh1}:${newarg}\cb] ", $args);
      }
    } elsif ($cmd eq 'NOTICE') {
      &yetonearg;
      &strip_idmsg if $has_identifymsg;
      if ($args =~ /^\001([^\001]*)\001$/) {
	&ctcpreply($newarg, $1);
      } elsif ($newarg =~ /^[\#\&\+]/) {
	&dohooks("notice", $newarg, $args);
	$msgchannel = $newarg;
	&tell_hi("-${who}/${newarg}- ", $args);
      } elsif ($who =~ /\./) {
	&dohooks("server_notice", $args);
	$args="*** ".$args unless ($args =~ /^\*/);
	&tell($args);
      } elsif (&eq($newarg, $nick)) {
	&dohooks("notice", $newarg, $args);
	&tell_hi("-\cb${who}\cb${puh1}- ", $args);
      } else {
	&dohooks("notice", $newarg, $args);
	&tell_hi("-\cb$who$puh1:${newarg}\cb- ", $args);
      }
    } elsif ($cmd eq 'KICK') {
      &yetonearg;
      local($channel)=$newarg;
      &yetonearg;
      $args=$who unless $args;
      if (&eq($nick, $newarg)) {
	&tell("*\cb<\cb* You have been kicked off channel $channel by $who$puh2 ($args)");
	@@channels=grep(!&eq($_, $channel), @@channels);
	if (@@channels) {
	  $talkchannel=$channels[$#channels];
	} else {
	  $talkchannel='';
	}
	$channel =~ tr/A-Z[]\\~/a-z{}|^/;
	&dohooks("kick", $newarg, $channel, $args);
	delete $mode{$channel};
	delete $limit{$channel};
	delete $haveops{$channel};
	delete $chankey{$channel};
	$talkchannel && !$ssfe && &tell("*** Talking to $talkchannel now");
	&dostatus;
      } else {
	&dohooks("kick", $newarg, $channel, $args);
	&tell("*\cb<\cb* $newarg has been kicked off channel $channel by $who$puh2 ($args)");
      }
    } elsif ($cmd eq 'PART') {
      &yetonearg;
      if (&eq($who, $nick)) {
	&tell("*\cb<\cb* You have left channel $newarg");
	@@channels=grep(!&eq($_, $newarg), @@channels);
	if (@@channels) {
	  $talkchannel=$channels[$#channels];
	} else {
	  $talkchannel='';
	}
	$newarg =~ tr/A-Z[]\\~/a-z{}|^/;
	delete $mode{$newarg};
	delete $limit{$newarg};
	delete $haveops{$newarg};
	delete $chankey{$newarg};
	&dohooks("leave", $newarg);
	$talkchannel && !$ssfe && &tell("*** Talking to $talkchannel now");
	&dostatus;
      } else {
	&dohooks("leave", $newarg, $args);
	&tell("*\cb<\cb* $who$puh2 has left channel $newarg ($args)");
      }
    } elsif ($cmd eq 'JOIN') {
      &yetonearg;
      $newarg =~ s/\cg.*//;	# ircnet kludge
      if (&eq($nick, $who)) {
	push(@@channels, $newarg);
	$talkchannel=$newarg;
	&dohooks("join", $newarg);
	&dostatus;
	&tell("*\cb>\cb* You have joined channel $newarg");
	&sl("MODE $newarg");
      } else {
	&dohooks("join", $newarg);
	&tell("*\cb>\cb* $who ($user\@@$host) has joined channel $newarg");
      }
      &appeared($who);
    } elsif ($cmd eq 'NICK') {
      &yetonearg;
      if (&eq($nick, $who)) {
	$nick=$newarg;
	&dohooks("nick", $newarg);
	$who=$newarg;
	&dostatus;
	&tell("*\cbN\cb* You are now known as $newarg");
      } else {
	&dohooks("nick", $newarg);
	&tell("*\cbN\cb* $who$puh2 is now known as $newarg");
	delete $awaytimes{$who};
	delete $awaymsgs{$who};
      }
    } elsif ($cmd eq 'MODE') {
      &yetonearg;
      $args =~ s/ $//;
      if ($newarg =~ /^[\#\&\+]/) {
	&modestripper($newarg, $args);
	&dohooks("mode", $newarg, $args);
	&dostatus;
	&tell("*\cb+\cb* Mode change \"$args\" on channel $newarg by $who$puh2");
      } else {
	local($towho)=$newarg;
	&yetonearg;
	&umodechange($newarg), &dostatus if &eq($towho, $nick);
	&dohooks("mode", $towho, $newarg);
	&tell("*\cb+\cb* Mode change \"$newarg\" for user $towho by $who");
      }
    } elsif ($cmd eq 'KILL') {
      &yetonearg;
      local($n)=$newarg;
      $args || ($args=$who);
      &tell("*\cb<\cb* $n got killed by $who$puh1 ($args)");
      delete $awaytimes{$n};
      delete $awaymsgs{$n};
    } elsif ($cmd eq 'INVITE') {
      &yetonearg;
      &yetonearg;
      &dohooks("invite", $newarg);
      $invited=$newarg;
      &tell("*\cbI\cb* $who$puh1 invites you to channel $newarg");
    } elsif ($cmd eq 'TOPIC') {
      &yetonearg;
      &dohooks("topic", $newarg, $args);
      &tell("*\cbT\cb* $who$puh2 has changed the topic on channel $newarg to \"$args\"");
    } elsif ($cmd eq 'SILENCE') {
      &tell("*** Silence $args");
    } elsif ($cmd eq 'PONG') {
    } elsif ($cmd eq 'QUIT') {
      &dohooks("signoff", $args);
      &tell("*\cb<\cb* Signoff: $who$puh2 ($args)");
      &disappeared($who);
      delete $awaytimes{$who};
      delete $awaymsgs{$who};
    } elsif ($cmd eq 'WALLOPS') {
      &tell("!$who$puh2! ".$args);
    } elsif ($cmd eq 'RPONG') {
      local($n, $t, $ms, $ts)=split(/ +/, $args);
      $ts =~ s/^://;
      &tell("*** RPONG: $who - $t: $ms ms, ".time-$ts." sec");
    } else {
      &tell("*** The server says: $serverline");
    }
  }
}
@


1.57
log
@the last decode must not have Encode::FB_QUIET
@
text
@d681 2
a682 2
    $pat .= '|' if $pat ne '';
    $pat .= "\Q$nick\E";
@


1.56
log
@add hexdumper for debugging
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.54 2017/11/17 00:12:24 tg Exp $
d510 1
a510 1
      $buf2 .= Encode::decode("windows-1252", $buf, Encode::FB_QUIET);
@


1.55
log
@further limit the amount of mailto links were giving out
@
text
@d10 1
a10 1
# Copyright (c) 2001-2017 mirabilos
d161 16
@


1.54
log
@apply patch from multiplexd retaining server password upon reconnect
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.53 2017/11/17 00:08:33 tg Exp $
d52 3
a54 2
# For bug reports, comments, questions, email roger.espel.llima@@pobox.com
# and miros-discuss@@mirbsd.org but not junk@@mirbsd.org ;)
@


1.53
log
@add /highlight, from multiplexd, but let it operate exactly like /ignore
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.48 2017/06/26 13:45:50 tg Exp $
d210 1
d1259 1
@


1.52
log
@expand highlighting to notices (from multiplexd) except server notices
@
text
@d661 7
a667 1
  $msg =~ s/\Q$nick\E/\x00$highlight_style$&\x00$highlight_style/ig if $set{"HIGHLIGHT_NICK"} eq 'on';
d1151 1
a1151 1
	&tell("*** $p");
d1176 16
@


1.51
log
@split off highlighting code
@
text
@d2302 1
a2302 1
	&tell_i("-${who}/${newarg}- $args");
d2309 1
a2309 1
	&tell_i("-\cb${who}\cb${puh1}- $args");
d2312 1
a2312 1
	&tell_i("-\cb$who$puh1:${newarg}\cb- $args");
@


1.50
log
@ rename /set highlight to /set highlight_nick (from multiplexd)
 add /set highlight_style (inspired by patch from multiplexd)
@
text
@d658 8
d2282 1
a2282 2
	$args =~ s/\Q$nick\E/\x00$highlight_style$&\x00$highlight_style/ig if $set{"HIGHLIGHT_NICK"} eq 'on';
	&tell_i("<${who}> $args");
d2285 1
a2285 2
	$args =~ s/\Q$nick\E/\x00$highlight_style$&\x00$highlight_style/ig if $set{"HIGHLIGHT_NICK"} eq 'on';
	&tell_i("<${who}:${newarg}> $args");
d2290 1
a2290 2
	$args =~ s/\Q$nick\E/\x00$highlight_style$&\x00$highlight_style/ig if $set{"HIGHLIGHT_NICK"} eq 'on';
	&tell_i("[\cb${who}\cb${puh1}] $args");
d2292 1
a2292 2
	$args =~ s/\Q$nick\E/\x00$highlight_style$&\x00$highlight_style/ig if $set{"HIGHLIGHT_NICK"} eq 'on';
	&tell_i("[\cb${who}\cb${puh1}:${newarg}\cb] $args");
@


1.49
log
@fix bug in parting messages spotted and pointed out by multiplexd
@
text
@d190 3
a192 1
	"CHARSET", "iso-8859-1", "SHOWTIME", "on", "HIGHLIGHT", "off");
d943 1
a943 1
  } elsif ($var eq 'HIGHLIGHT') {
d946 6
d2274 1
a2274 1
	$args =~ s/\Q$nick\E/\x00\cv$&\x00\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2278 1
a2278 1
	$args =~ s/\Q$nick\E/\x00\cv$&\x00\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2284 1
a2284 1
	$args =~ s/\Q$nick\E/\x00\cv$&\x00\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2287 1
a2287 1
	$args =~ s/\Q$nick\E/\x00\cv$&\x00\cv/ig if $set{"HIGHLIGHT"} eq 'on';
@


1.48
log
@work around an irssi bug
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.33 2012/06/24 13:53:58 tg Exp $
d524 1
d999 1
d1368 10
a1377 2
    $args=$talkchannel if $args eq '';
    &sl("PART $args");
@


1.47
log
@omit highlight-based ^V from the log
@
text
@d758 1
a758 1
  &sl("PRIVMSG $towho :\caACTION".($what eq "" ? "" : " ").$what."\ca");
@


1.46
log
@introduce in &print dropping the char after a NUL just from the log
@
text
@d2256 1
a2256 1
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2260 1
a2260 1
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2266 1
a2266 1
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
d2269 1
a2269 1
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
@


1.45
log
@https://modern.ircdocs.horse/formatting.html demands support for 0x1D
@
text
@d580 6
a585 1
  $logging && print LOG "[" . $tstamp . "] " . $what . "\n";
@


1.44
log
@fixup the enhance caller
@
text
@d582 1
@


1.43
log
@fix sub enhance for all ctrl chars
@
text
@d593 1
a593 1
    $what =~ s/([\ca\cc-\ch\cj-\cu\cw-\c^])/&enhance($1)/eg;
d618 1
a618 1
    $what =~ tr/\ca-\ch\cj-\c_//d;
@


1.42
log
@strip raw NULs from server and user input (just in case)
@
text
@d555 1
a555 1
  $what =~ tr/\c@@-\c^/@@-^/;
@


1.41
log
@explicitly exclude NUL, it can be contained in Perl strings
@
text
@d317 1
d2185 1
d2192 1
d2207 1
@


1.40
log
@fix !8bit miscreation of C0 control characters
@
text
@d577 1
a577 1
  $what = &sortnames($what) if ($what =~ /Users on [&#+!][^\x07\x0A\x0D ,]+:/);
@


1.39
log
@when reconnecting, use the original port from the original server, too
@
text
@a573 2
  # windows-1252 and broken (not converted) utf-8 => latin-1
# $what =~ tr/\x80-\x9F/e ,f,.tT\^S< Z  ''""\-\-\~Ts> z/;
d575 1
a575 1
  $what =~ tr/\x80-\xff/\x00-\x1f !cLxY|$_ca<\-\-R_o+23\'mp.,1o>123?AAAAAAACEEEEIIIIDNOOOOO*0UUUUYPBaaaaaaaceeeeiiiidnooooo:0uuuuypy/
@


1.38
log
@add /set log restart; fix missing end log text
@
text
@d206 1
@


1.37
log
@apply (modulo RFC) multiplexds nicksort diff
@
text
@d912 9
a920 1
    if ($val =~ /^on$/i) {
a932 5
    } elsif ($val =~ /^off$/i) {
      print LOG "*\cbL\cb* Log ended on ".&date(time)."\n", close(LOG)
	if $logging;
      $logging='';
      $set{$var}="off";
@


1.36
log
@scandinavian lowercase correctly (ISO-IR-x)
@
text
@d578 1
a578 1
  $what = &sortnames($what) if ($what =~ /Users on #\w+:/);
@


1.35
log
@apply multiplexds highlight patch, slightly fixed
@
text
@d258 2
a259 2
  $a =~ tr/A-Z/a-z/;
  $b =~ tr/A-Z/a-z/;
d527 1
a527 1
  $t =~ tr/A-Z/a-z/;
d880 1
a880 1
    $val =~ tr/A-Z/a-z/;
d891 1
a891 1
    $val =~ tr/A-Z/a-z/;
d932 1
a932 1
    $val =~ tr/A-Z/a-z/;
d1718 1
a1718 1
  $chnl =~ tr/A-Z/a-z/;
d2040 1
a2040 1
    $c =~ tr/A-Z/a-z/;
d2088 1
a2088 1
    $c =~ tr/A-Z/a-z/;
d2293 1
a2293 1
	$channel =~ tr/A-Z/a-z/;
d2315 1
a2315 1
	$newarg =~ tr/A-Z/a-z/;
@


1.34
log
@ better OpenSSL subprocess cleanup
 reset /away ignoring on /whois
 dump /ignored serverlines into the log
@
text
@d10 2
a11 1
# Copyright (c) 2001-2014 Thorsten Glaser
d190 1
a190 1
	"CHARSET", "iso-8859-1", "SHOWTIME", "on");
d931 3
d2244 1
d2248 1
d2254 1
d2257 1
@


1.33
log
@write code to fallback to Legacy IP if IP resolves but cant be connected
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.32 2011/12/16 19:21:48 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2012 Thorsten Glaser
d247 1
d321 4
a330 4
  if ($ssl_pid) {
    kill TERM => $ssl_pid;
  }
  $ssl_pid = 0;
d485 1
a485 1
      $buf =~ s/\cc((1[0-5]|0?[0-9])(,(1[0-5]|0?[0-9]))?)?//g;
d2017 2
d2213 6
a2218 2
    next if (($cmd eq 'PRIVMSG' || $cmd eq 'NOTICE') &&
		&ignored("$who!$user\@@$host"));
@


1.32
log
@second-precision timestamps in the log, by request of RichiH
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.31 2011/12/16 18:15:36 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2011 Thorsten Glaser
d224 1
a224 1
  $bindaddr=&resolve($set{"LOCALHOST"});
d278 1
a278 1
  } elsif ($have_socket == 6) {
d375 3
a377 1
    local($adr, $otherend)=&resolve($host);
d396 8
a403 2
    &print("*\cbE\cb* Can't connect to host: $!"), close($fh),
      $SIG{'QUIT'}='IGNORE', return 0 unless connect($fh, $otherend);
d893 1
a893 1
    local($ad)=&resolve($val);
@


1.31
log
@ CAP identify-msg (opportunistic) support, somewhat
 identification in CTCP displays
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.30 2011/12/16 17:29:02 tg Exp $
d569 1
a569 1
  $tstamp = sprintf("%02d:%02d", (localtime)[2], (localtime)[1]);
d571 1
@


1.30
log
@and finally, /away tracking (long awaited)
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.29 2011/12/16 17:12:05 tg Exp $
d63 1
a63 1
$has_capab = 0; $capab_cmd = ''; $capab_response = '';
d642 1
d792 1
a792 1
  &tell("*** $who$puh1 did a CTCP $what$a to $to")
d825 1
a825 1
    &tell("*** $who$puh1 did a CTCP PING to $to");
d829 1
a829 1
    arandom_add("init $who,$puh1;$towho,$args");
d832 1
a832 1
    &tell("*** $who$puh1 initiated the RANDEX protocol with $to");
d835 2
a836 2
    arandom_add("info $who,$puh1;$towho,$args");
    &tell("*** $who$puh1 queried RANDEX protocol information from $to");
d938 2
a939 2
    arandom_add("recv $who,$puh1;$towho,$rest");
    &tell("*** RANDEX protocol reply from $who$puh1 to $towho, ${t}");
d944 1
a944 1
    &tell("*** CTCP $ctcp reply from $who$puh1: $rest");
d946 1
a946 1
    &tell("*** CTCP $ctcp reply to $towho from $who$puh2: $rest");
d1822 18
d1864 5
a1868 1
    &tell("*\cb?\cb* $newarg: unknown command$from");
d2198 1
d2212 2
@


1.29
log
@switch to NZAAT hash implementation; add timer and atexit to ensure pushing
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.28 2011/12/16 15:50:24 tg Exp $
d460 1
d1898 10
a1907 1
    &tell("*** $newarg is away: $args");
d2303 2
d2326 2
d2345 2
@


1.28
log
@bugfix: only strip an initial plus/minus if CAPAB IDENTIFYMSG is actually on
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.27 2010/05/14 20:35:49 tg Exp $
d102 1
a102 1
use BSD::arc4random qw(arc4random arc4random_pushb arc4random_bytes);
d104 2
a105 1
my $running_sum = arc4random();
d107 4
a110 18
sub
adler32
{
	my ($n, $buf) = @@_;
	my ($s1, $s2);

	$s1 = $n & 0xFFFF;
	$s2 = ($n >> 16) & 0xFFFF;

	$n = 0;
	foreach my $ch (unpack("C*", $buf)) {
		$s1 += $ch;
		$s2 += $s1;
		if ($n == 5552) {
			$s1 %= 65521;
			$s2 %= 65521;
			$n = 0;
		}
d112 23
d136 4
a139 2
	$n = ($s1 % 65521) | (($s2 % 65521) << 16);
	return ($n);
d141 1
d143 10
a152 2
sub arc4adlerpush {
  my $s = $_;
d154 3
a156 3
  $running_sum = adler32($running_sum, pack("w", arc4random()) . $s);
  $s = pack("w", time) . pack("L", $running_sum);
  BSD::arc4random::arc4random_addrandom($s);
d243 3
a471 1
    arc4adlerpush($buf);
d473 1
d480 4
d509 1
a509 1
  arc4adlerpush($buf3);
d827 2
a828 1
    my $evalue = pack("u", arc4random_bytes(32, "$who$puh1$towho$args"));
d833 1
a833 1
    arc4random_pushb("$who$puh1$towho$args");
d936 1
a936 1
    $running_sum = arc4random_pushb("$who$puh1$towho$rest") | 1;
d1312 2
a1313 1
      local($t) = pack("u", arc4random_bytes(32, "send to $args"));
@


1.27
log
@cosmetic: nuke double space

XXX use strftime or something, if Perl has it
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.26 2010/03/30 21:03:06 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2010 Thorsten Glaser
d2153 1
a2153 1
      &strip_idmsg;
d2172 1
a2172 1
      &strip_idmsg;
@


1.26
log
@Debian #15503
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.25 2009/08/02 14:34:59 tg Exp $
d737 1
a737 1
  return sprintf("$weekdays[$wday] $months[$mon]  $mday %.2d:%.2d:%.2d %d",
@


1.25
log
@CTCP RANDOM is now part of the new RANDEX protocol as well
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.24 2009/01/08 20:23:30 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2009 Thorsten Glaser
d547 1
a547 1
    print $tstamp . $what, "\n" || &exit;
d572 1
a572 1
    print $tstamp . $what, $normal, "\n" || &exit;
d579 1
a579 1
    print $tstamp . $what, "\n" || &exit;
@


1.24
log
@do unto these my favourites the same, in a slightly more standardised
and hooked way as the plugin one, with some quirks for tinyirc
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.23 2009/01/08 19:53:37 tg Exp $
d52 1
a52 1
# and miros-discuss@@mirbsd.de
d763 1
a763 1
    unless $what =~ /^(ACTION|ENTROPY|PING)$/;
d782 1
a782 1
    &reply("CLIENTINFO ACTION, CLIENTINFO, ECHO, ENTROPY, ERRMSG, FINGER, PING, TIME, USERINFO, VERSION");
d803 14
@


1.23
log
@get rid of redundant latin1 (cp1252 is a superset)
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.22 2008/12/20 17:57:28 tg Exp $
d102 35
a136 1
use BSD::arc4random qw(arc4random_pushb arc4random_bytes);
d448 1
d481 1
d893 1
a893 1
    arc4random_pushb("$who$puh1$towho$rest");
@


1.22
log
@add tinyirc-like /ns command; fix some Apo'Strophitis while here
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.21 2008/12/13 14:02:04 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2008 Thorsten Glaser
d418 1
a418 1
      $buf2 .= Encode::decode("iso-8859-1", $buf, Encode::FB_QUIET);
a439 1
  $buf2 .= Encode::decode("iso-8859-1", $buf, Encode::FB_QUIET);
d444 1
a444 1
    $buf3 = Encode::encode("iso-8859-1", $buf2, 0);
@


1.21
log
@fix a smallish problem with IPv6
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.20 2008/12/08 16:01:33 tg Exp $
d1329 6
@


1.20
log
@* run without p5-Socket6 if not found
* be more GNU/Cygwin32 friendly
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.19 2008/10/13 22:09:16 tg Exp $
d79 6
a84 4
$use_sock6 = 0;
if ($] >= 5 && (eval "use Socket;", $@@ eq '')) {
  if (eval "use Socket6;") {
    $use_sock6 = 1;
d86 4
d215 1
d220 1
a220 3
  } elsif (!$use_sock6) {
    return (gethostbyname($_[0]))[4];
  } else {
a227 2
    } else {
      return (gethostbyname($_[0]))[4];
d230 1
d328 1
a328 1
    if (! $use_ipv6) {
@


1.19
log
@support for literal IPv6 addresses
@
text
@d1 2
a2 2
#!/usr/bin/perl
# $MirOS: ports/net/sirc/dist/dsircp,v 1.18 2008/07/18 22:41:23 tg Exp $
d79 1
d81 3
a83 1
  use Socket6;
d108 14
d160 1
d213 2
a484 3
    local $AB = Encode::encode($set{"CHARSET"}, "\x{AB}", 0);
    local $AC = Encode::encode($set{"CHARSET"}, "\x{AC}", 0);
    local $BB = Encode::encode($set{"CHARSET"}, "\x{BB}", 0);
d504 1
a504 2
    $tstamp .= Encode::encode($set{"CHARSET"}, "\x{239C}", 0);
    $tstamp =~ s/\?$/|/;
d783 1
@


1.18
log
@new $interactive, set to 0 in perl scripts to avoid reading from STDIN
for use with bot scripts
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.17 2008/07/15 13:25:25 tg Exp $
d95 10
d125 1
a125 1
($server, $port, $pass)=split(/[\s:]+/, $server);
d1091 1
a1091 1
      ($server, $port, $pass)=split(/[\s:]+/, $args);
@


1.17
log
@tell the user if we have kernel interface
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.16 2008/07/15 13:15:29 tg Exp $
d62 1
d1657 1
a1657 1
  foreach ('STDIN', keys(%sel_fds), keys(%buf_fds)) {
d1660 1
@


1.16
log
@sync help, remove more DCC crap, sync various descriptions, add
dependencies, bump version
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.15 2008/07/15 12:49:46 tg Exp $
d825 1
d827 1
a827 1
    &tell("*** RANDEX protocol reply from $who$puh1 to $towho");
@


1.15
log
@ more sensible /names implementation: use current channel if no argument,
  refuse to run without argument (use /q names instead), since freenode,
  in contrast to OFTC, dont rate-limit and output everything then kill you
 use /na as /names alias
 more sensible /mo == /mode implementation, too
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.14 2008/07/15 12:40:11 tg Exp $
d97 1
a97 1
	"LOCALHOST", "", "CTCP", "no", "SENDAHEAD", 4096,
a760 2
  } elsif ($var eq 'SENDAHEAD') {
    $set{$var}=$val if $val =~ /^\d+$/ && $val<=65536;
d1298 1
a1298 1
    $args=$talkchannel if $args eq ''
d1306 1
a1306 1
    $args=$talkchannel if $args eq ''
d1463 5
a1467 6
@@hooks=("action", "ctcp", "ctcp_reply", "input",
	"invite", "join", "kick", "leave", "mode", "msg", "nick", "notice",
	"server_notice", "notify_signoff", "notify_signon", "public",
	"raw_irc", "send_action", "send_text", "send_notice",
	"signoff", "topic", "disconnect", "status", "print", "command",
	"chat_disconnect", "send_ctcp", "capab");
@


1.14
log
@merge the /randex patch, sans debugging
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.13 2008/07/15 12:25:19 tg Exp $
d1298 13
a1310 3
  } elsif ($cmd eq 'MO') {
    if ($talkchannel) {
      &sl("MODE $talkchannel $args");
d1312 1
a1312 1
      &tell("*\cbE\cb* You're not on any channel anyway");
a1348 3
  } elsif ($cmd eq 'MODE' || $cmd eq 'NAMES') {
    &dosplat;
    &sl("$cmd $args");
@


1.13
log
@remove all of DCC's remnants
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.12 2007/05/20 23:01:27 tg Exp $
d92 1
d697 1
a697 1
    unless $what =~ /^(ACTION|PING)$/;
d716 1
a716 1
    &reply("CLIENTINFO ACTION, CLIENTINFO, ECHO, ERRMSG, FINGER, PING, TIME, USERINFO, VERSION");
d726 1
a726 1
    &reply("VERSION sirc $version, a \cbperl\cb client$u");
d732 5
d819 2
d822 1
a822 1
  &dohooks("ctcp_reply", $_[0], $ctcp, $rest);
d826 4
d831 2
a832 1
  if (&eq($_[0], $nick)) {
d835 1
a835 1
    &tell("*** CTCP $ctcp reply to $_[0] from $who$puh2: $rest");
d1050 1
a1050 1
    &tell("*** \cbsirc\cb version $version, written in \cbperl\cb by \cborabidoo\cb");
d1070 1
a1070 1
    $args || ($args="using \cbsirc\cb version $version$add_ons");
d1200 11
d1961 1
a1961 1
&tell("*** Welcome to \cbsirc\cb version $version; type /help for help");
@


1.12
log
@make people use freenode again
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.11 2007/03/01 21:34:15 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2007 Thorsten Glaser
a561 27
sub dcerror {
  local($fh, $n)=($_[0], $dcnick{$_[0]});
  &dohooks("chat_disconnect", $n);
  &tell("*\cbE\cb* DCC chat with $n lost");
  close($fh);
  $n =~ tr/A-Z/a-z/;
  delete $dcnick{$fh};
  delete $dcvol{$n};
  delete $dcfh{$n};
  delete $buffer{$fh};
}

sub dgsclose {
  local($sfh, $rfh)=@@_;
  &dohooks("dcc_disconnect", $dnick{$sfh}, $dfile{$rfh}, $dtransferred{$sfh},
	   time-$dstarttime{$rfh});
  &tell("*\cbD\cb* DCC transfer with $dnick{$sfh} terminated; $dtransferred{$sfh} bytes transferred in ".(time-$dstarttime{$rfh}). " seconds");
  close($sfh);
  close($rfh);
  delete $dgrfh{$sfh};
  delete $dsrfh{$sfh};
  delete $dfile{$rfh};
  delete $dstarttime{$rfh};
  delete $dtransferred{$sfh};
  delete $dnick{$sfh};
}

d576 1
a576 13
  if ($towho =~ s/^=//) {
    local($n, $fh)=($towho);
    $n =~ tr/A-Z/a-z/;
    $fh=$dcfh{$n};
    if ($fh) {
      (print $fh $what."\n") || &dcerror($fh);
      $dcvol{$n}+=length($what);
      &dohooks("send_dcc_chat", $towho, $what);
      &tell("|\cb$towho\cb| $what");
    } else {
      &tell("*\cbE\cb* No active DCC chat with $towho");
    }
  } elsif ($connected>1) {
a695 1
#   unless $what =~ /^(ACTION|PING|DCC)$/;
a714 1
#   &reply("CLIENTINFO ACTION, CLIENTINFO, DCC, ECHO, ERRMSG, FINGER, PING, TIME, USERINFO, VERSION");
a730 39
  } elsif (0) { #$what eq 'DCC') {
    &getarg;
    if ($newarg eq 'CHAT' || $newarg eq 'SEND' && !$restrict) {
      local($dfile, $dhost, $dport, $dsize)=split(/ +/, $args, 4);
      $dfile=$1 if $dfile =~ m|/([^/]*)$|;
      $dfile =~ s/^\./_/;
      if ($dhost==2130706433 || !$dport>1024 || $dhost !~ /^\d+$/ ||
	  $dport !~ /^\d+$/) {
	&tell_i("*\cbE\cb* DCC $newarg ($dfile) from <$who$puh1> rejected");
      } elsif ($newarg eq 'CHAT' && grep (&eq($who, $dcwait{$_}),
		keys(%dcwait))) {
	&tell_i("*\cbD\cb* DCC chat already requested from <$who>, connecting...");
	local ($wfh)=(grep(&eq($dcwait{$_}, $who), keys(%dcwait)));
	local ($n, $fh)=$who;
	delete $dcwait{$wfh};
	close($wfh);
	&connect($fh, $dhost, $dport, 0) || return;
	$dcnick{$fh}=$who;
	&tell_i("*\cbD\cb* DCC CHAT with <$who> established");
	$n =~ tr/A-Z/a-z/;
	$dcvol{$n}=0;
	$dcfh{$n}=$fh;
	print "`#ssfe#t/m =$who \n" if $ssfe;
      } elsif ($newarg eq 'CHAT' && grep(&eq($who, $_), keys(%dcfh))) {
	&tell_i("*\cbD\cb* DCC chat from <$who$puh1> ignored (already established)");
      } else {
	&tell_i("*\cbD\cb* DCC $newarg ($dfile) from <$who$puh1> ".
	 ($dsize ? "(size: $dsize) " : "")."[$dhost, $dport]");
	if ($newarg eq 'CHAT') {
	  $dcoffered{$who}="$dhost $dport";
	  &dohooks("dcc_request", "CHAT", $dhost, $dport);
	} else {
	  $dgoffered{"$dhost $dport $dfile"}=$who;
	  &dohooks("dcc_request", "SEND", $dhost, $dport, $dfile, $dsize);
	}
      }
    } else {
      &tell("*** $who$puh1 did a CTCP ${what}$a to $to");
    }
a1100 231
  } elsif ($cmd eq 'DCC') {
    &getarg;
    if (1) {
      &tell("*\cbE\cb* Uh, better not...");
    } elsif ($newarg =~ /^chat$/i) {
      &getarg;
      local($n)=grep(&eq($newarg, $_), keys(%dcoffered));
      if ($n) {
	local($dcadr, $dcport)=split(/ +/, $dcoffered{$n});
	local($fh);
	delete $dcoffered{$n};
	&connect($fh, $dcadr, $dcport, 0) || return;
	$dcnick{$fh}=$n;
	&tell("*\cbD\cb* DCC CHAT with $n established");
	print "`#ssfe#t/m =$n \n" if $ssfe;
	$n =~ tr/A-Z/a-z/;
	$dcvol{$n}=0;
	$dcfh{$n}=$fh;
      } elsif (grep (&eq($newarg, $dcwait{$_}), keys(%dcwait))) {
	&tell("*\cbE\cb* DCC CHAT request to $newarg already sent");
      } elsif (grep(&eq($newarg, $dcnick{$_}), keys(%dcnick))) {
	&tell("*\cbE\cb* DCC CHAT with $newarg already established");
      } elsif ($newarg) {
	&tell("*** You're not connected to a server"), return if $connected<2;
	&tell("*** Don't be antisocial!"), return if &eq($newarg, $nick);
	local($mynumber, $myport, $fh)=unpack("N", $bindaddr);
	$myport=&listen($fh) || return;
	$dcwait{$fh}=$newarg;
	&sl("PRIVMSG $newarg :\caDCC CHAT chat $mynumber $myport\ca");
	&dohooks("send_ctcp", $newarg, "DCC CHAT chat $mynumber $myport");
	&tell("*\cbD\cb* Sent DCC CHAT request to $newarg");
      } else {
	&tell("*** I need a nick");
      }
    } elsif ($newarg =~ /^rchat$/i) {
      &getarg;
      local($n)=$newarg;
      &getarg;
      if ($newarg) {
	local($fh)=grep(&eq($dcnick{$_}, $n), keys(%dcnick));
	&tell("*\cbE\cb* No DCC CHAT established with $n"), return
	  unless $fh;
	&tell("*\cbE\cb* DCC CHAT already established with $newarg"), return
	  if grep(&eq($dcnick{$_}, $newarg), keys(%dcnick));
	&tell("*\cbD\cb* DCC CHAT with $n renamed to $newarg");
	$dcnick{$fh}=$newarg;
	$n =~ tr/A-Z/a-z/;
	$newarg =~ tr/A-Z/a-z/;
	$dcfh{$newarg}=$dcfh{$n};
	$dcvol{$newarg}=$dcvol{$n};
	delete $dcfh{$n};
	delete $dcvol{$n};
      } else {
	&tell("*** I need *two* nicks");
      }
    } elsif ($newarg =~ /^close$/i) {
      &getarg;
      if ($newarg =~ /^chat$/i) {
	&getarg;
	local($n)=$newarg;
	$newarg =~ tr/A-Z/a-z/;
	local($fh)=$dcfh{$newarg};
	local($nn)=(grep(&eq($_, $newarg), keys(%dcoffered)));
	if ($nn) {
	  &tell("*\cbD\cb* Forgetting offered DCC CHAT from $nn");
	  delete $dcoffered{$nn};
	} elsif ($fh) {
	  &dohooks("chat_disconnect", $n);
	  &tell("*\cbD\cb* Closing DCC CHAT connection with $n");
	  close($fh);
	  delete $dcnick{$fh};
	  delete $dcvol{$newarg};
	  delete $dcfh{$newarg};
	  delete $buffer{$fh};
	} elsif (($fh)=grep(&eq($dcwait{$_}, $n), keys (%dcwait)), $fh) {
	  close($fh);
	  delete $dcwait{$fh};
	  &tell("*\cbD\cb* Closing listening DCC CHAT with $n");
	} else {
	  $n && &tell("*\cbE\cb* No DCC CHAT connection with $n");
	}
      } elsif ($newarg =~ /^get$/i) {
	&getarg;
	local($found)='';
	foreach $i (keys(%dgoffered)) {
	  if (&eq($dgoffered{$i}, $newarg) && (!$args ||
	      &eq($args, (split(/ +/, $i))[2]))) {
	    &tell("*\cbE\cb* Forgetting pending DCC GET from $newarg");
	    delete $dgoffered{$i};
	    $found=1;
	  }
	}
	foreach $sfh (grep(&eq($newarg, $dnick{$_}), keys(%dnick))) {
	  if (!$found && $dgrfh{$sfh}) {
	    local($fh)=$dgrfh{$sfh};
	    next if $args && ($args ne $dfile{$fh});
	    &dohooks("dcc_disconnect", $dnick{$sfh}, $dfile{$fh},
		$dtransferred{$sfh}, time-$dstarttime{$fh});
	    &tell("*\cbE\cb* Closing DCC GET connection with $newarg");
	    $found=1;
	    close($sfh);
	    close($fh);
	    delete $dgrfh{$sfh};
	    delete $dfile{$fh};
	    delete $dstarttime{$fh};
	    delete $dtransferred{$sfh};
	    delete $dnick{$sfh};
	  }
	}
	&tell("*\cbE\cb* No DCC GET connection with $newarg") unless $found;
      } elsif ($newarg =~ /^send$/i) {
	&getarg;
	local($n, $found, $fh)=($newarg, '');
	&getarg;
	$newarg =~ s/(\W)/\\$1/g;
	foreach $sfh (keys(%dswait), keys(%dsrfh)) {
	  next unless &eq($dnick{$sfh}, $n);
	  $fh=$dswait{$sfh} || $dsrfh{$sfh} || next;
	  if ($newarg eq '' || $dfile{$fh} =~ /^${newarg}$/ ||
	      $dfile{$fh} =~ /\/${newarg}$/) {
	    &tell("*\cbD\cb* DCC SEND connection with $n closed");
	    &dohooks("dcc_disconnect", $dnick{$sfh}, $dfile{$fh},
		$dtransferred{$sfh}, time-$dstarttime{$fh});
	    close($sfh);
	    close($fh);
	    delete $dswait{$sfh};
	    delete $dsrfh{$sfh};
	    delete $dfile{$fh};
	    delete $dstarttime{$fh};
	    delete $dtransferred{$sfh};
	    delete $dnick{$sfh};
	    $found=1;
	  }
	}
	&tell("*\cbE\cb* No DCC SEND connection with $n") unless $found;
      } else {
	&tell("*\cbE\cb* Unknown DCC type");
      }
    } elsif ($newarg =~ /^rename$/i) {
      local($found, $n);
      &getarg;
      $n=$newarg;
      &getarg;
      $args=$newarg, $newarg='' if $args eq '';
      &tell("*\cbE\cb* I need a filename :p"), return if $args eq '';
      &tilde($args);
      foreach $i (keys(%dgoffered)) {
	if (&eq($dgoffered{$i}, $n) && (!$newarg ||
	    &eq($newarg, (split(/ +/, $i))[2]))) {
	  local($m, $p, $f)=split(/ +/, $i);
	  delete $dgoffered{$i};
	  $dgoffered{"$m $p $args"}=$n;
	  &tell("*\cbD\cb* Renaming \"$f\" (offered by $n) to \"$args\"");
	  $found=1;
	  last;
	}
      }
      &tell("*\cbE\cb* No such file offered by $n") unless $found;
    } elsif ($newarg =~ /^get$/i) {
      &getarg;
      local($n)=grep((&eq($newarg, $dgoffered{$_}) && (!$args ||
		      &eq($args, (split(/ +/, $_))[2]))),
		     keys(%dgoffered));
      if ($n) {
	local($dgadr, $dgport, $file)=split(/ +/, $n);
	local($fh, $sfh);
	$n=(delete $dgoffered{$n});
	$fh=&newfh;
	&print("*\cbE\cb* Can't write to file $file"), return
	  unless open($fh, "> $file");
	&connect($sfh, $dgadr, $dgport, 0) || return;
	$dgrfh{$sfh}=$fh;
	$dnick{$sfh}=$n;
	$dfile{$fh}=$file;
	$dstarttime{$fh}=time;
	$dtransferred{$sfh}=0;
	&tell("*\cbD\cb* DCC GET connection with $n established");
      } else {
	if ($newarg) {
	  &tell("*\cbE\cb* No pending DCC GET from $newarg");
	} else {
	  &tell("*\cbE\cb* Uhm, who from?");
	}
      }
    } elsif ($newarg =~ /^list$/i || $newarg eq '') {
      &tell("*\cbD\cb* List of DCC connections:");
      foreach $n (keys(%dcfh)) {
	&tell("*\cbD\cb* Established DCC CHAT with $n ($dcvol{$n} bytes)");
      }
      foreach $n (keys(%dcoffered)) {
	&tell("*\cbD\cb* DCC CHAT offered by $n");
      }
      foreach $f (keys(%dcwait)) {
	&tell("*\cbD\cb* DCC CHAT offered to $dcwait{$f}");
      }
      foreach $i (keys(%dgoffered)) {
	&tell("*\cbD\cb* DCC GET $i offered by $dgoffered{$i}");
      }
      foreach $s (keys(%dgrfh)) {
	local($f)=$dgrfh{$s};
	&tell("*\cbD\cb* DCC GET \"$dfile{$f}\" established with $dnick{$s}, $dtransferred{$s} bytes read in ".(time-$dstarttime{$f})." seconds.");
      }
      foreach $s (keys(%dswait)) {
	local($f)=$dswait{$s};
	&tell("*\cbD\cb* DCC SEND \"$dfile{$f}\" offered to $dnick{$s}");
      }
      foreach $s (keys(%dsrfh)) {
	local($f)=$dsrfh{$s};
	&tell("*\cbD\cb* DCC SEND \"$dfile{$f}\" established with $dnick{$s}, $dtransferred{$s} bytes sent in ".(time-$dstarttime{$f})." seconds.");
      }
    } elsif ($newarg =~ /^send$/i) {
      &tell("*** You're not connected to a server"), return if $connected<2;
      &restrict || return;
      local($n, $f)=split(/ +/, $args);
      local($tf, $mynumber, $sz, $fh, $myport, $lfh)=($f, unpack("N", $bindaddr));
      $fh=&newfh;
      &tilde($f);
      &tell("*\cbE\cb* Can't open file $f"), return unless open($fh, "<$f");
      $myport=&listen($lfh) || (close($fh), return);
      $dswait{$lfh}=$fh;
      $tf=$1 if $f =~ m|/([^/]*)$|;
      $sz=(-s $f);
      &sl("PRIVMSG $n :\caDCC SEND $tf $mynumber $myport $sz\ca");
      &dohooks("send_ctcp", $n, "DCC SEND $tf $mynumber $myport $sz");
      &tell("*\cbD\cb* Sent DCC SEND request to $n");
      $dfile{$fh}=$f;
      $dswait{$lfh}=$fh;
      $dnick{$lfh}=$n;
    } else {
      &tell("*** I can \"only\" do DCC CHAT, RCHAT, GET, SEND, CLOSE, RENAME and LIST, *sheesh*");
    }
d1434 1
a1434 1
@@hooks=("action", "ctcp", "ctcp_reply", "dcc_chat", "dcc_request", "input",
d1437 1
a1437 1
	"raw_irc", "send_action", "send_dcc_chat", "send_text", "send_notice",
d1439 1
a1439 1
	"chat_disconnect", "dcc_disconnect", "send_ctcp", "capab");
d1620 1
a1620 1
  foreach ($S, 'STDIN', keys(%dcnick), keys(%buf_fds)) {
d1627 1
a1627 2
  foreach ('STDIN', keys(%dcnick), keys(%dcwait), keys(%dgrfh), keys(%dswait),
		keys(%dsrfh), keys(%sel_fds), keys(%buf_fds)) {
a1970 76
  foreach $rfh (keys (%dcnick)) {
    if (vec($rout, fileno($rfh), 1) || ($leftover && $fh eq $rfh)) {
      &gl($rfh) || next;
      &dcerror($rfh), next if $_ eq '';
      chop;
      local($who, $what)=($dcnick{$rfh}, $_);
      $dcvol{$dcnick{$rfh}}+=length($what);
      print "`#ssfe#t/m =$who \n" if $ssfe;
      print "`#ssfe#o=${who}= $what\n" if $ssfe;
      &dohooks("dcc_chat", $who, $what);
      &tell("=\cb${who}\cb= $what");
      $silent='';
    }
  }
  foreach $rfh (keys (%dcwait)) {
    if (vec($rout, fileno($rfh), 1)) {
      local($n, $fh);
      if (&accept($fh, $rfh)) {
	select($fh); $|=1; select(STDOUT);
	$n=$dcwait{$rfh};
	$dcnick{$fh}=$n;
	$n =~ tr/A-Z/a-z/;
	$dcvol{$n}=0;
	$dcfh{$n}=$fh;
	&tell("*\cbD\cb* DCC CHAT connection with $n established");
	print "`#ssfe#t/m =$n \n" if $ssfe;
      }
      delete $dcwait{$rfh};
    }
  }
  foreach $sfh (keys (%dswait)) {
    local($rfh, $fh)=$dswait{$sfh};
    if (vec($rout, fileno($sfh), 1)) {
      if (&accept($fh, $sfh)) {
	select($fh); $|=1; select(STDOUT);
	$dsrfh{$fh}=$rfh;
	$dstarttime{$rfh}=time;
	$dtransferred{$fh}=0;
	$dnick{$fh}=$dnick{$sfh};
	&tell("*\cbD\cb* DCC SEND connection with $dnick{$sfh} established");
      }
      delete $dnick{$sfh};
      delete $dswait{$sfh};
    }
  }
  foreach $sfh (keys (%dgrfh)) {
    local($rfh)=$dgrfh{$sfh};
    if (vec($rout, fileno($sfh), 1)) {
      local($a, $buf)=(0, '');
      $a=sysread($sfh, $buf, 4096);
      if ($a) {
	$dtransferred{$sfh}+=$a;
	print $rfh $buf;
	print $sfh pack("N", $dtransferred{$sfh});
      } else {
	&dgsclose($sfh, $rfh);
      }
    }
  }
  foreach $sfh (keys (%dsrfh)) {
    local($rfh)=$dsrfh{$sfh};
    if (vec($rout, fileno($sfh), 1) || !$dtransferred{$sfh}) {
      local($ack, $csa, $buf, $b, $l, $w)=(0, '', '');
      if ($dtransferred{$sfh}) {
	&dgsclose($sfh, $rfh), next if sysread($sfh, $b, 4)!=4;
	$ack=unpack("N", $b);
      }
      $csa=$set{"SENDAHEAD"}-$dtransferred{$sfh}+$ack;
      next if $csa<0;
      $l=read($rfh, $buf, 512+$csa);
      $w=syswrite($sfh, $buf, $l) if $l;
      next if $l==0 && $ack<$dtransferred{$sfh};
      $dtransferred{$sfh}+=$w;
      &dgsclose($sfh, $rfh), next if ($w<$l || $l==0);
    }
  }
@


1.12.2.1
log
@use of BSD::arc4random, idea by Vutral and myself, protocol by me
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.12 2007/05/20 23:01:27 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2008 Thorsten Glaser
a91 1
use BSD::arc4random qw(arc4random_pushk arc4random_bytes);
d735 2
a736 1
    unless $what =~ /^(ACTION|ENTROPY|PING)$/;
d755 2
a756 1
    &reply("CLIENTINFO ACTION, CLIENTINFO, ECHO, ENTROPY, ERRMSG, FINGER, PING, TIME, USERINFO, VERSION");
a771 5
  } elsif ($what eq 'ENTROPY') {
    my $evalue = pack("u", arc4random_bytes(32, "$who$puh1$towho$args"));
    chop($evalue);
    &tell("*D* $who$puh1 did a CTCP $what$a to $to");
    &reply("RANDOM $evalue");
a892 2
  local $vis = 1;
  local $towho = $_[0];
d894 1
a894 1
  &dohooks("ctcp_reply", $towho, $ctcp, $rest);
a897 4
  } elsif ($ctcp eq 'RANDOM') {
    arc4random_pushk("$who$puh1$puh2$towho$rest");
    &tell("*D* $who did a CTSP $ctcp $rest to $towho");
    $vis = 0;
d899 1
a899 2
  return unless $vis;
  if (&eq($towho, $nick)) {
d902 1
a902 1
    &tell("*** CTCP $ctcp reply to $towho from $who$puh2: $rest");
@


1.12.2.2
log
@add /randex command to automatically start the protocol
e.g. like this:
type: /randex #channel
sends: /ctcp #channel entropy 32

other instance receives that
sends: /notice yournick <ctcp>random 32</ctcp>
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.12.2.1 2008/07/08 02:11:46 tg Exp $
a1508 11
  } elsif ($cmd eq 'RANDEX') {
    &dosplat;
    if ($args) {
      local($t) = pack("u", arc4random_bytes(32, "send to $args"));
      chop($t);
      &getarg;
      &sl("PRIVMSG $newarg :\caENTROPY $t\ca");
      &tell("*D* Sending a CTCP ENTROPY to $newarg");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
@


1.11
log
@support half-ops:
 convert $haveops{$channel} from true/undef to string/undef
 set $haveops{$channel} to "@@" / "%" / "" (equivalent to undef) depending
  on what's needed
 catch h as umode not chanmode
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.10 2007/01/09 00:51:17 tg Exp $
d105 1
a105 1
		"irc.66h.42h.de";
@


1.10
log
@* add TLS support via openssltool(1)
* fix some "perl -w" stuff
* spelling, licence
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.9 2006/02/05 14:37:58 tg Exp $
d419 3
a421 1
  $s.="\@@" if $t && $haveops{$t};
d1880 3
a1882 1
      $haveops{$chnl}=($how eq '+') if (&eq(shift(@@args), $nick));
d2205 1
a2205 1
    $haveops{$c}=1 if ($r =~ /\@@${n}( |$)/i);
@


1.9
log
@evil Soryu hack #2: strip mIRC colour codes inserted maliciously by Colloquy
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.8 2006/01/23 22:48:21 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2006 Thorsten Glaser
d12 8
a19 8
# Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
# express, or implied, to the maximum extent permitted by applicable
# law, without malicious intent or gross negligence; in no event may
# licensor, an author or contributor be held liable for any indirect
# or other damage, or direct damage except proven a consequence of a
# direct error of said person and intended use of this work, loss or
# other issues arising in any way out of its use, even if advised of
# the possibility of such damage or existence of a nontrivial bug.
d25 1
a25 1
#	-p = specify port number
d49 1
a49 1
# (context diffs appreciated) and they might make it to the next release.
d52 1
d56 1
d58 1
a58 1
$version='2.211-MirPorts';
d60 1
a60 1
$add_ons='+[mirabile-@@DIST_DATE@@]';
d91 1
d103 1
d141 1
a141 1
  close H;
d152 1
a152 1
  close LOG if $logging;
d202 26
d230 78
a307 27
  local($fh, $host, $port)=@@_;
  local($adr, $otherend)=&resolve($host);
  &tell("*\cbE\cb* Hostname '$host' not found"), return 0 unless $adr;
  if ($use_ipv6) {
    $otherend=pack_sockaddr_in6($port, $adr);
    &print("*\cbE\cb* Out of file descriptors"), return 0
     unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
  } else {
    $otherend=pack_sockaddr_in($port, $adr);
    &print("*\cbE\cb* Out of file descriptors"), return 0
     unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
  }
  if (! $use_ipv6) {
    if ($set{"LOCALHOST"}) {
      bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
       &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
    }
  }
  $trysock=$fh;
  $SIG{'QUIT'}='sigquit';
  &print("*\cbE\cb* Can't connect to host: $!"), close $fh,
    $SIG{'QUIT'}='IGNORE', return 0 unless connect($fh, $otherend);
  $SIG{'QUIT'}='IGNORE';
  if ($use_ipv6) {
      $bindaddr=(unpack_sockaddr_in6(getsockname($fh)))[2] if !$bindaddr;
  } else {
      $bindaddr=(unpack_sockaddr_in(getsockname($fh)))[2] if !$bindaddr;
d328 1
a328 1
  &tell("*\cbE\cb* Can't bind local socket!"), close $fh, return 0
d330 1
a330 1
  &tell("*\cbE\cb* Can't listen to socket!"), close $fh, return
d345 3
d353 6
a358 2
  &tell("*** Connecting to $server, port $port...");
  &connect($S, $server, $port) || return;
d369 2
a370 1
  if ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/) {
d379 1
a379 1
      $buf =~ s/\ca([<>])\ca/\cb\1\cb/g;
d493 1
a493 1
      if ($1 = "\cb") {
d495 1
a495 1
      } elsif ($1 = "\c_") {
d497 1
a497 1
      } elsif ($1 = "\cv") {
d786 1
a786 1
	&connect($fh, $dhost, $dport) || return;
d864 1
a864 1
      $logging && close LOG;
d877 1
a877 1
      print LOG "*\cbL\cb* Log ended on ".&date(time)."\n", close LOG
d1149 6
a1154 1
      &sl("QUIT :changing servers"), close $S, delete $buffer{$S} if $connected;
d1190 1
a1190 1
	&connect($fh, $dcadr, $dcport) || return;
d1279 2
a1280 2
	    close $sfh;
	    close $fh;
d1349 1
a1349 1
	&connect($sfh, $dgadr, $dgport) || return;
d1397 1
a1397 1
      $myport=&listen($lfh) || (close $fh, return);
d1454 1
d1915 1
a1915 1
  close RCFILE;
d1928 1
d1931 3
d1939 1
d2361 11
d2381 1
d2395 1
a2395 1
    $args =~ s/^://;
@


1.9.2.1
log
@22:47| *E* Cannot create a socket pair: Protocol not supported
is all I get for now I urgently need a Perl guru to help out
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.9 2006/02/05 14:37:58 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2007 Thorsten Glaser
d12 8
a19 8
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
d25 1
a25 1
#	-p = specify port number (start with s for SSL)
d56 1
a56 1
$version='2.211-MirPorts-@@DIST_DATE@@';
d58 1
a58 1
$add_ons='';
a88 1
use POSIX ":sys_wait_h";
a197 12
sub REAPER {
  my $child;
  while (($child = waitpid(-1,WNOHANG)) > 0) {
    $?;		# do something sensitive with it
  }
  # loathe sysV: it makes us not only reinstate
  # the handler, but place it after the wait
  $SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;
$ssl_pid = 0;

d200 27
a226 57
  local($fh, $host, $port, $use_ssl)=@@_;
  if ($ssl_pid) {
    kill TERM => $ssl_pid;
  }
  $ssl_pid = 0;
  if ($use_ssl) {
    my $spfh, $scfh, $pid;

    if (!socketpair($scfh, $spfh, AF_UNIX, SOCK_STREAM, PF_LOCAL)) {
      &tell("*\cbE\cb* Cannot create a socket pair: $!");
      return 0;
    }
    if ($pid = fork) {
      close($spfh);
      open(STDIN, ">&", fileno($scfh));
      open(STDOUT, ">&", fileno($scfh));
      open(STDERR, ">/dev/null");
      select(STDOUT); $| = 1;
      exec "openssl s_client -quiet -connect ${host}:${port}";
    }
    if (!defined $pid) {
      close($scfh);
      close($spfh);
      &tell("*\cbE\cb* Cannot fork: $!");
      return 0;
    }
    close($scfh);
    $fh = $spfh;
    $ssl_pid = $pid;
  } else {
    local($adr, $otherend)=&resolve($host);
    &tell("*\cbE\cb* Hostname '$host' not found"), return 0 unless $adr;
    if ($use_ipv6) {
      $otherend=pack_sockaddr_in6($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
    } else {
      $otherend=pack_sockaddr_in($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
    }
    if (! $use_ipv6) {
      if ($set{"LOCALHOST"}) {
        bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
         &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
      }
    }
    $trysock=$fh;
    $SIG{'QUIT'}='sigquit';
    &print("*\cbE\cb* Can't connect to host: $!"), close $fh,
      $SIG{'QUIT'}='IGNORE', return 0 unless connect($fh, $otherend);
    $SIG{'QUIT'}='IGNORE';
    if ($use_ipv6) {
        $bindaddr=(unpack_sockaddr_in6(getsockname($fh)))[2] if !$bindaddr;
    } else {
        $bindaddr=(unpack_sockaddr_in(getsockname($fh)))[2] if !$bindaddr;
    }
a263 2
  my $xport = $port, $xssl = 0;

d269 2
a270 6
  if ($xport =~ s/^(s|S)//) {
    $xssl = 1;
  }
  &tell("*** Connecting to $server, port $xport" .
    ($xssl ? " (TLS secured)" : "") . "...");
  &connect($S, $server, $xport, $xssl) || return;
d697 1
a697 1
	&connect($fh, $dhost, $dport, 0) || return;
d1096 1
a1096 1
	&connect($fh, $dcadr, $dcport, 0) || return;
d1255 1
a1255 1
	&connect($sfh, $dgadr, $dgport, 0) || return;
@


1.9.2.2
log
@better working so far almost
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.9.2.1 2007/01/08 22:49:06 tg Exp $
d219 1
a219 1
    my $spfh = $fh, $scfh = &newfh, $pid;
d221 1
a221 1
    if (!socketpair($scfh, $spfh, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
d227 1
a227 1
      open(STDIN, "<&", fileno($scfh));
d229 1
d231 1
a231 1
      exec "openssl s_client  -connect ${host}:${port} 2>/dev/null";
d240 1
@


1.9.2.3
log
@further debugging, to no avail
@
text
@a88 1
use Fcntl;
d138 1
a138 1
  close(H);
d149 1
a149 1
  close(LOG) if $logging;
a156 3
sub dummy {
}

a209 1
$ssl_efd = 0;
a213 8
  if ($ssl_efd != 0) {
    while (my $x = <$ssl_efd>) {
      &tell("*\cbE\cb* TLS: $x");
    }
    close($ssl_efd);
    delete $buffer{$ssl_efd};
    $ssl_efd = 0;
  }
d219 1
a219 1
    my $spfh = $fh, $scfh = &newfh, $spe = &newfh, $sce = &newfh, $pid;
a224 6
    if (!socketpair($sce, $spe, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
      close($scfh);
      close($spfh);
      &tell("*\cbE\cb* Cannot create a second socket pair: $!");
      return 0;
    }
d227 2
a228 6
      close($spe);
      #shutdown($sce, 0);
      open(STDIN, "<&$scfh");#, fileno($scfh));
      open(STDOUT, ">&$scfh");#, fileno($scfh));
      open(STDERR, ">&$sce");#, fileno($sce));
      select(STDERR); $| = 1;
d230 1
a230 2
      exec "openssl s_client -";
      exec "openssl s_client  -connect ${host}:${port}";
a234 2
      close($sce);
      close($spe);
a238 13
    close($sce);
    #shutdown($spe, 1);
    select($spe); $|=1; select(STDOUT);
    my $flags = fcntl($spe, F_GETFL, 0);
    fcntl($spe, F_SETFL, $flags | O_NONBLOCK);
    for (;;) {
      undef $!;
      my $line = <$spe>;
      &tell("*\cbI\cb* TLS: $line") if defined $line;
      &tell("*\cbE\cb* TLS Error: $!") if $!;
      last if $!;
    }
    fcntl($spe, F_SETFL, $flags);
a239 1
    $ssl_efd = $spe;
d260 1
a260 1
    &print("*\cbE\cb* Can't connect to host: $!"), close($fh),
d288 1
a288 1
  &tell("*\cbE\cb* Can't bind local socket!"), close($fh), return 0
d290 1
a290 1
  &tell("*\cbE\cb* Can't listen to socket!"), close($fh), return
d822 1
a822 1
      $logging && close(LOG);
d835 1
a835 1
      print LOG "*\cbL\cb* Log ended on ".&date(time)."\n", close(LOG)
d1107 1
a1107 13
      if ($connected) {
	&sl("QUIT :changing servers");
	if ($ssl_efd != 0) {
	  while (my $x = <$ssl_efd>) {
	    &tell("*\cbE\cb* TLS: $x");
	  }
	  close($ssl_efd);
	  delete $buffer{$ssl_efd};
	}
	$ssl_efd = 0;
	close($S);
	delete $buffer{$S};
      }
d1232 2
a1233 2
	    close($sfh);
	    close($fh);
d1350 1
a1350 1
      $myport=&listen($lfh) || (close($fh), return);
a1407 8
    if ($ssl_efd != 0) {
      while (my $x = <$ssl_efd>) {
	&tell("*\cbE\cb* TLS: $x");
      }
      close($ssl_efd);
      delete $buffer{$ssl_efd};
    }
    $ssl_efd = 0;
d1867 1
a1867 1
  close(RCFILE);
a1881 3
  if ($ssl_efd != 0) {
    $leftover=1, return $ssl_efd if $buffer{$ssl_efd} =~ /\n/;
  }
a1886 1
  vec($rin, fileno($ssl_efd), 1)=1 if ($ssl_efd != 0);
a2307 13
  if (($ssl_efd != 0) &&
   (($leftover && $fh eq $ssl_efd) || vec($rout, fileno($ssl_efd), 1))) {
    &gl($ssl_efd) || next;
    if ($_ eq '') {
      &tell("*\cbE\cb* Connection to TLS stderr lost");
      close($ssl_efd);
      delete $buffer{$ssl_efd};
      $ssl_efd = 0;
      next;
    }
    chop;
    &tell("*\cbE\cb* TLS: $_");
  }
a2317 8
      if ($ssl_efd != 0) {
	while (my $x = <$ssl_efd>) {
	  &tell("*\cbE\cb* TLS: $x");
	}
	close($ssl_efd);
	delete $buffer{$ssl_efd};
      }
      $ssl_efd = 0;
@


1.9.2.4
log
@(some) "perl -w" cleanup really helps, dude
@
text
@d63 1
a63 1
$libdir=$ENV{"SIRCLIB"} || "/usr/mpkg/share/sirc/";
d89 1
d206 1
a206 1
    #XXX $?;		# do something sensitive with it
d214 1
a214 1
$ssl_efd = '';
d219 1
a219 1
  if ($ssl_efd ne '') {
d225 1
a225 1
    $ssl_efd = '';
d232 1
a232 5
    my $spfh = $fh;
    my $scfh = &newfh;
    my $spe = &newfh;
    my $sce = &newfh;
    my $pid;
d247 4
a250 4
      shutdown($sce, 0);
      open(STDIN, "<&$scfh");
      open(STDOUT, ">&$scfh");
      open(STDERR, ">&$sce");
d253 2
a254 1
      exec "openssl s_client -quiet -connect ${host}:${port}";
d266 1
d268 10
a277 1
    shutdown($spe, 1);
d345 1
a345 2
  my $xport = $port;
  my $xssl = 0;
d368 1
a368 2
  if ((defined $buffer{$_[0]}) &&
   ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/)) {
d377 1
a377 1
      $buf =~ s/\ca([<>])\ca/\cb$1\cb/g;
d491 1
a491 1
      if ($1 == "\cb") {
d493 1
a493 1
      } elsif ($1 == "\c_") {
d495 1
a495 1
      } elsif ($1 == "\cv") {
d1149 1
a1149 1
	if ($ssl_efd ne '') {
d1156 1
a1156 1
	$ssl_efd = '';
d1460 1
a1460 1
    if ($ssl_efd ne '') {
d1467 1
a1467 1
    $ssl_efd = '';
a1939 1
    next unless defined $buffer{$_};
d1942 1
a1942 1
  if (($ssl_efd ne '') && (defined $buffer{$ssl_efd})) {
d1950 1
a1950 1
  vec($rin, fileno($ssl_efd), 1)=1 if ($ssl_efd ne '');
d2372 1
a2372 1
  if (($ssl_efd ne '') &&
d2379 1
a2379 1
      $ssl_efd = '';
d2395 1
a2395 1
      if ($ssl_efd ne '') {
d2402 1
a2402 1
      $ssl_efd = '';
d2415 1
a2415 1
    $args =~ s/^:// if defined $args;
@


1.9.2.5
log
@further code cleanup
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.9.2.4 2007/01/09 00:05:23 tg Exp $
d205 1
a205 1
    &tell("*\cbI\cb* Child $child exited with status $?");
d215 3
a217 1
sub ssl_cleanup {
a225 6
}

sub connect {
  $_[0]=&newfh;
  local($fh, $host, $port, $use_ssl)=@@_;
  &ssl_cleanup;
a241 1
      &tell("*\cbE\cb* Cannot create a second socket pair: $!");
d244 1
a258 1
      &tell("*\cbE\cb* Cannot fork: $!");
d263 1
d1143 8
a1150 1
	&ssl_cleanup;
a1452 1
    &ssl_cleanup;
d1454 8
a2370 1
      &ssl_cleanup;
d2372 3
a2388 1
      &ssl_cleanup;
d2390 8
@


1.9.2.6
log
@further attempt of cleanup
@
text
@a216 5
    while ((defined $buffer{$ssl_efd}) &&
     ($buffer{$ssl_efd} =~ /^([^\n\r]*)\r?\n\r?/)) {
      $buffer{$ssl_efd} = $';
      &tell("*\cbE\cb* TLS: $1");
    }
@


1.9.2.7
log
@use &gl for ssl ctx cleanup
@
text
@d217 7
a223 4
    while (&gl($ssl_efd)) {
      last if $_ eq '';
      chop;
      &tell("*\cbE\cb* TLS: $_");
@


1.9.2.8
log
@polish
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.9.2.7 2007/01/09 00:23:30 tg Exp $
d63 1
a63 1
$libdir=$ENV{"SIRCLIB"} || "@@PREFIX@@/share/sirc/";
a100 1
$ssl_args = $ENV{'SIRCSSL'} || '-CApath /etc/ssl/certs';
a253 2
      my $cmd = "openssl s_client -quiet -connect ${host}:${port} $ssl_args";
      &tell("*\cbI\cb* Spawning: $cmd");
d262 1
a262 1
      exec $cmd;
@


1.8
log
@evil soryu-mac-fanboy hack #1
filter ^A<^Anick^A>^A mirc(?) colour code
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.7 2006/01/01 05:36:41 tg Exp $
d291 1
@


1.7
log
@log timestamps into the log file, too (and unconditionally)
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.6 2006/01/01 04:55:04 tg Exp $
d290 1
@


1.6
log
@better: use snprintf, %02d for filling
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.5 2006/01/01 04:50:43 tg Exp $
a377 1
  $logging && print LOG $what."\n";
d380 1
@


1.5
log
@add timestamps to messages; idea by Hawkeye (#holarse on Freeforge); code by me
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.4 2005/12/18 16:36:44 tg Exp $
d380 1
a380 1
  $tstamp = (localtime)[2] . ":" . (localtime)[1];
@


1.4
log
@Part 2 of the big commit:
* www/vbegin.php: don't output the UTF-8 BOM for now
* ports/Setup.sh: change order in which path is divined [1]
* ports/books/mirex: convert to CVS_DISTF
* ports/comms/ssfe: increase line length limit and history buffer size
* ports/infrastructure/install/setup.sh: sync path order with Setup.sh [1]
* ports/infrastructure/mk/bsd.port.mk: (_PORTPATH) sync default PATH [1]
* ports/infrastructure/mk/bsd.port.mk: (_UPGRADE_FLAGS) new, default to -a
* ports/infrastructure/mk/bsd.port.mk: (_upgrade) use it
* ports/infrastructure/mk/bsd.port.mk: (reupgrade) new target, set to -a -f
* ports/infrastructure/scripts/mkmcz: don't use $LOCALBASE, trust in PATH
* ports/infrastructure/mk/bsd.port.mk: (_CVS_FETCH) use _PORTPATH
* ports/infrastructure/pkgtools/create: treat /usr/info same as /usr/man
* ports/infrastructure/pkgtools/upgrade: fix path to temp +REQUIRED_BY
* ports/www/firesomething: break, suggest Opera-Linux/K-Meleon/Safari
* src/Makefile, src/gcc/Makefile.lang: if build GCJ, check if X11 installed
* src/Makefile, src/gnu/usr.bin/perl/Makefile.bsd-wrapper: defer h2ph
  execution to end of build
* src/distrib/lists: sync with pre-h2ph change
* src/etc/services: add openvpn, from IANA
* src/gcc/Makefile.inc, Makefile.lang: fragment out NO_*= stuff
* src/gcc/libjava/Makefile.bsd-wrapper: DEBUGPROGS is gone
* src/gnu/usr.bin/perl/Makefile.bsd-wrapper: flesh out h2ph, fix perms
* src/lib/libc/time/localtime.c: fix undefined extern
* ports/net/sirc/Makefile: automatically insert version into CTCP VERSION
* ports/net/sirc/dist/PROGRAMMING: document capab hooks
* ports/net/sirc/dist/dsircp: several hours of perl hacking with Club-Mate
  - publish $msgchannel, $talkserver [2]
  - support for CAPAB: publish $has_capab, $capab_cmd, $capab_response;
    add "capab" hook in reply
  - support for CAPAB IDENTIFY-MSG: publish $has_identifymsg; new
    $unverified, $unverified_m; enable automatically if present;
    change <...> [...] -...- to ... [[...]] ...
  - /describe nick now looks [*] (or [[*]]) instead of *, /me now looks
    # instead of * if identified, to facilitate this conversion
  - fix abuse of U+0060
  - sort /names [2]
  - fix ^B ^_ ^V [2]
  - remove trailing whitespace on outgoing msgs [2]
  - remove trailing whitespace on incoming msgs
  - fix indentation
  - auto-split overlong lines (partially [2])
  - in NOTICE make nick bold too [2]
  - disable DCC since it crashes
  - beautify CTCP TIME replies
  - add ACCEPT command (for ratbox-ircd, e.g. Freeforge)
* ports/net/sirc/pkg/DESCR: summarise new features

[1] all for the sake of bsiegert@@ wanting to not have to souce a
    SetEnv.sh or SetEnv.csh before building in "default MirPorts"
    (i.e. LOCALBASE=/usr/mpkg SYSCONFDIR=/etc BINOWN=root SUDO=sudo)
[2] adapted from http://co.ordinate.org/sirc/
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.3 2005/12/15 13:10:24 tg Exp $
d10 1
a10 1
# Copyright (c) 2001-2005 Thorsten Glaser
d42 1
d90 1
a90 1
&Getopts('n:s:p:u:i:l:L:H:rqQR78UC:X');
d96 1
a96 1
	"CHARSET", "iso-8859-1");
d126 1
d380 1
d382 6
a387 1
    print $what, "\n" || &exit;
d389 4
d412 1
a412 1
    print $what, $normal, "\n" || &exit;
d414 4
d419 1
a419 1
    print $what, "\n" || &exit;
d732 3
a734 3
  } elsif ($var eq 'UTF') {
    $set{$var}="on" if $val =~ /^on$/i;
    $set{$var}="off" if $val =~ /^off$/i;
@


1.3
log
@change default server to irc.66h.42h.de (Freeforge, IPv4 and IPv6 ready)
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/dist/dsircp,v 1.2 2005/09/01 20:38:50 tg Exp $
d9 2
a10 1
# Copyright (c) 2001-2004 Thorsten Glaser
d12 9
d57 4
a60 1
$add_ons='+[mirabile-20050901]';
d92 1
a92 1
 	"LOCALHOST", "", "CTCP", "no", "SENDAHEAD", 4096,
d103 1
a103 1
                $ENV{"USER"} || "blah";
d178 1
a178 1
      local $rc;
d180 1
a180 1
      $rc = (gethostbyname2($_[0], AF_INET6))[4];
d182 6
a187 6
      if ($rc) {
	  $use_ipv6 = 1;
	  return $rc;
      } else {
	  return (gethostbyname($_[0]))[4];
      }
d200 1
a200 1
  &tell("*\cbE\cb* Hostname `$host' not found"), return 0 unless $adr;
d202 7
a208 7
      $otherend=pack_sockaddr_in6($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
	  unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
  } else {
      $otherend=pack_sockaddr_in($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
	  unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
d211 4
a214 4
      if ($set{"LOCALHOST"}) {
	  bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
	      &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
      }
d238 1
a238 1
	  unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
d243 1
a243 1
	  unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
d262 1
a262 1
  @@channels=(); $talkchannel=''; $use_ipv6=0;
d270 1
a270 1
  $server1=$server;
d357 14
d372 1
a372 1
#  $what =~ tr/\x80-\x9F/e ,f,.tT\^S< Z  ''""\-\-\~Ts> z/;
d377 1
a380 1
    # this is buggy if you combine effects
d382 17
a398 11
    while ($what =~ /\cb/) {
      ($what =~ s/\cb([^\cb]*)\cb/$bold$1$normal/) ||
      $what =~ s/\cb/$bold/g;
    }
    while ($what =~ /\c_/) {
      ($what =~ s/\c_([^\c_]*)\c_/$underline$1$normal/) ||
      $what =~ s/\c_/$underline/g;
    }
    while ($what =~ /\cv/) {
      ($what =~ s/\cv([^\cv]*)\cv/$reverse$1$normal/) ||
      $what =~ s/\cv/$reverse/g;
d407 11
d422 20
d482 1
a506 1
    $what=substr($what, 0, 485);
d508 9
a516 6
    if (&eq($towho, $talkchannel) && !$printchan) {
      &tell("<\c_${nick}\c_> $what");
    } elsif ($towho =~ /^[\&\#\+]/) {
      &tell("<\c_$nick\c_:$towho> $what");
    } else {
      &tell(">\cb${towho}\cb< $what");
a517 1
    &sl("PRIVMSG $towho :$what");
d523 23
d558 1
a558 1
  &tell("-> -${towho}- $what");
d564 1
d617 1
d626 2
a627 1
    unless $what =~ /^(ACTION|PING|DCC)$/;
d631 1
a631 1
      &tell("*> \cb${who}\cb$puh1 $args");
d633 9
a641 3
      &tell("* $who $args");
    } else {
      &tell("* $who$puh2:$towho $args");
d646 2
a647 1
    &reply("CLIENTINFO ACTION, CLIENTINFO, DCC, ECHO, ERRMSG, FINGER, PING, TIME, USERINFO, VERSION");
d663 1
a663 1
  } elsif ($what eq 'DCC') {
d671 1
a671 1
	&tell("*\cbE\cb* DCC $newarg ($dfile) from $who$puh1 rejected");
d674 1
a674 1
	&tell("*\cbD\cb* DCC chat already requested from $who, connecting...");
d681 1
a681 1
	&tell("*\cbD\cb* DCC CHAT with $who established");
d687 1
a687 1
	&tell("*\cbD\cb* DCC chat from $who$puh1 ignored (already established)");
d689 2
a690 2
	&tell("*\cbD\cb* DCC $newarg ($dfile) from $who$puh1 ".
	      ($dsize ? "(size: $dsize) " : "")."[$dhost, $dport]");
d786 4
a789 1
  $rest=(time-$rest)." seconds" if $ctcp eq 'PING';
d969 1
a969 1
        &tell("*** Removing $p from the ignore list");
d972 1
a972 1
        &tell("*** Ignoring $p ... what a relief!");
d1021 1
a1021 1
    local($cwd); chop($cwd=`pwd`);
d1069 3
a1071 1
    if ($newarg =~ /^chat$/i) {
d1178 1
a1178 1
        &getarg;
d1266 1
a1266 1
        local($f)=$dgrfh{$s};
d1270 1
a1270 1
        local($f)=$dswait{$s};
d1274 1
a1274 1
        local($f)=$dsrfh{$s};
d1532 1
a1532 1
           $cmd eq 'INFO' || $cmd eq 'LUSERS' || $cmd eq 'SQUIT' ||
d1539 6
d1635 1
a1635 1
	"chat_disconnect", "dcc_disconnect", "send_ctcp");
d1679 4
a1682 4
        splice(@@trefs,$i,1);
        splice(@@timers,$i,1);
        splice(@@timeactions,$i,1);
        last;
d1838 28
d2012 2
d2066 1
a2066 1
	   $cmd eq '321' || $cmd eq '366' || $cmd eq '376' ||
d2102 15
d2287 1
a2287 1
    } elsif  ($cmd eq 'PRIVMSG') {
d2289 2
d2295 1
a2295 1
	&tell("<${who}> $args");
d2298 1
a2298 1
	&tell("<${who}:${newarg}> $args");
d2303 1
a2303 1
	&tell("[\cb${who}\cb${puh1}] $args");
d2305 1
a2305 1
	&tell("[\cb${who}\cb${puh1}:${newarg}\cb] $args");
d2309 1
d2314 2
a2315 1
	&tell("-${who}/${newarg}- $args");
d2318 1
a2318 1
        $args="*** ".$args unless ($args =~ /^\*/);
d2322 1
a2322 1
	&tell("-\cb${who}\cb${puh1}- $args");
d2325 1
a2325 1
	&tell("-\cb$who$puh1:${newarg}\cb- $args");
@


1.2
log
@switch sirc port to forked development model, too
@
text
@d2 1
a2 1
# $MirOS: ports/net/sirc/patches/patch-dsirc,v 1.1.7.1 2005/03/18 15:49:06 tg Exp $
d87 1
a87 1
		"irc.eu.freenode.net";
@


1.1
log
@add sirc-2.211 (except unneeded files and ssfe; some files renamed,
gunzip'd and permissions fixed)
@
text
@d1 4
a4 3
#!/usr/local/bin/perl

# dsirc: dumb-mode small irc client in perl
d8 2
d13 1
a13 1
# use: dsirc [options] [nick [server[:port[:password]]]]
d17 1
d20 2
a21 2
#	-l = specify file to be loaded instead of ~/.sircrc.pl
#	-L = specify file to be loaded instead of ~/.sircrc
d23 1
a23 1
#	-q = don't load ~/.sircrc or ~/.sircrc.pl
d27 5
a31 1
#	-8 = 8-bit mode
d34 2
a35 2
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation. See the file LICENSE for more details.
d45 7
a51 7
$version='2.211';
$date='10 Mar 1998';
$add_ons='';

$libdir=$ENV{"SIRCLIB"} || ".";
push(@@INC, $libdir, $ENV{"HOME"});
@@loadpath=($ENV{"HOME"}."/.sirc", $libdir, ".");
d63 1
d74 1
d76 1
a76 1
&Getopts('n:s:p:u:i:l:L:H:rqQR78');
d79 1
a79 1
 	"LOCALHOST", "", "CTCP", "noflood", "SENDAHEAD", 4096,
d81 2
a82 1
	"LOADPATH", join(":", @@loadpath), "CTRL_T", "/next");
d87 1
a87 1
                  "irc.primenet.com";
d91 1
a91 1
$set{"IRCNAME"}=$opt_i || $ENV{"SIRCNAME"} || $ENV{"IRCNAME"} || "sirc user";
d94 1
a94 1
$set{"USERINFO"}=$ENV{"USERINFO"} || "yep, I'm a user";
d98 1
a98 1
$initfile=$opt_l || $ENV{"SIRCRCPL"} || $ENV{'HOME'}."/.sircrc.pl" 
d101 1
a101 1
$rcfile=$opt_L || $ENV{"SIRCRC"} || $ENV{'HOME'}."/.sircrc" 
d105 1
a105 1
$opt_8 || ($set{"EIGHT_BIT"}="off");
d109 3
d165 10
a174 1
    return (gethostbyname($_[0]))[4];
d188 14
a201 6
  $otherend=pack("S n a4 x8", &AF_INET, $port, $adr);
  &print("*\cbE\cb* Out of file descriptors"), return 0
    unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
  if ($set{"LOCALHOST"}) {
    bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
      &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
d208 5
a212 1
  $bindaddr=(unpack("S n a4", getsockname($fh)))[2] if !$bindaddr;
d221 11
a231 4
  $bindaddr=pack("x4", 0) unless $bindaddr;
  $thisend=pack("S n a4 x8", &AF_INET, $port+0, $bindaddr);
  &tell("*\cbE\cb* Out of file descriptors"), return 0
    unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
d236 5
a240 1
  return (unpack("S n", getsockname($fh)))[1];
d249 1
a249 1
  @@channels=(); $talkchannel='';
d272 1
d274 7
a280 1
    $buffer{$_[0]}.=$buf;
d293 13
a305 1
  &print("*\cbE\cb* Error writing to server: $!") unless print $S $_[0]."\n";
d344 2
d418 11
a428 1
  print "`#ssfe#t/m $towho \n" if $ssfe && !&eq($towho, $talkchannel);
d617 5
d659 1
a659 1
      if (open(LOG, 
d806 1
a806 1
  } elsif ($cmd eq 'NOTIFY' || $cmd eq 'N') {
d952 1
a952 1
  } elsif ($cmd eq 'QUERY' || $cmd eq 'Q') {
d1003 1
a1003 1
	&tell("*\cbE\cb* No DCC CHAT established with $n"), return 
d1005 1
a1005 1
	&tell("*\cbE\cb* DCC CHAT already established with $newarg"), return 
d1059 1
a1059 1
	    &dohooks("dcc_disconnect", $dnick{$sfh}, $dfile{$fh}, 
d1084 1
a1084 1
	    &dohooks("dcc_disconnect", $dnick{$sfh}, $dfile{$fh}, 
d1207 1
a1207 1
  } elsif ($cmd eq 'NOTICE' || $cmd eq 'NO') {
d1268 1
a1268 1
  } elsif ($cmd eq 'PING' || $cmd eq 'P') {
d1279 1
a1279 1
  } elsif ($cmd eq 'ME') {
d1297 1
a1297 1
  } elsif ($cmd eq 'LEAVE' || $cmd eq 'PART' || $cmd eq 'HOP') {
d1307 1
a1307 1
  } elsif ($cmd eq 'O' || $cmd eq 'OP') {
d1322 1
a1322 1
  } elsif ($cmd eq 'D' || $cmd eq 'DEOP') {
d1337 1
a1337 1
  } elsif ($cmd eq 'W' || $cmd eq 'WHOIS') {
d1339 1
a1339 1
  } elsif ($cmd eq 'WI') {
d1362 1
a1362 1
  } elsif ($cmd eq 'QUOTE') {
d1696 1
a1696 1
  $rcloaded=1; 
d2212 2
a2213 2
	&dohooks("leave", $newarg);
	&tell("*\cb<\cb* $who$puh2 has left channel $newarg");
a2289 1

@

