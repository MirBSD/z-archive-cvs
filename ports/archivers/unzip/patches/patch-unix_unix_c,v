head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2007.04.29.19.40.42;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004634F4A966962FAB;

1.3
date	2006.06.23.14.34.36;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	100449BFBAB48FB10C5;

1.2
date	2005.04.01.17.31.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.18.15.42.45;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.1.7.1
date	2005.03.18.15.42.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@• convert to BSD make (much more sane)
• use libz instead of rolling our own inflate, crc32, etc. functions
• don't install non-appropriate docs
@
text
@$MirOS: ports/archivers/unzip/patches/patch-unix_unix_c,v 1.3 2006/06/23 14:34:36 bsiegert Exp $
$NetBSD: patch-ac,v 1.1.2.1 2005/08/04 15:22:02 salo Exp $

	• fixes CAN-2005-2475, among others

--- unix/unix.c.orig	Sat Feb 26 19:43:20 2005
+++ unix/unix.c	Sun Apr 29 19:06:59 2007
@@@@ -1042,8 +1042,6 @@@@ void close_outfile(__G)    /* GRR: chang
     ush z_uidgid[2];
     int have_uidgid_flg;
 
-    fclose(G.outfile);
-
 /*---------------------------------------------------------------------------
     If symbolic links are supported, allocate storage for a symlink control
     structure, put the uncompressed "data" and other required info in it, and
@@@@ -1059,6 +1057,8 @@@@ void close_outfile(__G)    /* GRR: chang
                                 strlen(G.filename);
         slinkentry *slnk_entry;
 
+        fclose(G.outfile);
+
         if ((unsigned)slnk_entrysize < ucsize) {
             Info(slide, 0x201, ((char *)slide,
               "warning:  symbolic link (%s) failed: mem alloc overflow\n",
@@@@ -1107,6 +1107,11 @@@@ void close_outfile(__G)    /* GRR: chang
     }
 #endif /* SYMLINKS */
 
+#ifndef NO_CHMOD
+    if (fchmod(fileno(G.outfile), filtattr(__G__ G.pInfo->file_attr)))
+        perror("chmod (file attributes) error");
+#endif
+
 #ifdef QLZIP
     if (G.extra_field) {
         static void qlfix OF((__GPRO__ uch *ef_ptr, unsigned ef_len));
@@@@ -1120,7 +1125,7 @@@@ void close_outfile(__G)    /* GRR: chang
     /* if -X option was specified and we have UID/GID info, restore it */
     if (have_uidgid_flg) {
         TTrace((stderr, "close_outfile:  restoring Unix UID/GID info\n"));
-        if (chown(G.filename, (uid_t)z_uidgid[0], (gid_t)z_uidgid[1]))
+        if (fchown(fileno(G.outfile), (uid_t)z_uidgid[0], (gid_t)z_uidgid[1]))
         {
             if (uO.qflag)
                 Info(slide, 0x201, ((char *)slide,
@@@@ -1133,6 +1138,8 @@@@ void close_outfile(__G)    /* GRR: chang
         }
     }
 
+    fclose(G.outfile);
+
     /* set the file's access and modification times */
     if (utime(G.filename, &(zt.t2))) {
 #ifdef AOS_VS
@@@@ -1155,11 +1162,6 @@@@ void close_outfile(__G)    /* GRR: chang
     Change the file permissions from default ones to those stored in the
     zipfile.
   ---------------------------------------------------------------------------*/
-
-#ifndef NO_CHMOD
-    if (chmod(G.filename, filtattr(__G__ G.pInfo->file_attr)))
-        perror("chmod (file attributes) error");
-#endif
 
 } /* end function close_outfile() */
 
@


1.3
log
@SECURITY: Update unzip to 5.52-0, with a patch.

Fixes: CVE-2005-2475 and several older ones.
@
text
@d1 1
a1 1
$MirOS$
d3 5
a7 2
--- unix/unix.c.orig	2005-02-26 20:43:42.000000000 +0100
+++ unix/unix.c	2006-06-23 16:26:03.000000000 +0200
d56 2
a57 1
@@@@ -1156,11 +1163,6 @@@@ void close_outfile(__G)    /* GRR: chang
d60 1
a60 1
 
d65 1
a65 1
-
a67 1
 #endif /* !MTS */
@


1.2
log
@unbreak unzip
-DBSD4_4 now manually, it's not in <sys/param.h> any more
@
text
@d2 17
a18 58
$OpenBSD: patch-unix_unix_c,v 1.2 2003/08/17 23:48:40 brad Exp $
--- unix/unix.c.orig	Mon Jan 21 22:54:20 2002
+++ unix/unix.c	Fri Apr  1 17:27:12 2005
@@@@ -421,7 +421,8 @@@@ int mapname(__G__ renamed)
  */
 {
     char pathcomp[FILNAMSIZ];      /* path-component buffer */
-    char *pp, *cp=(char *)NULL;    /* character pointers */
+    char *pp, *cp=(char *)NULL,    /* character pointers */
+         *dp=(char *)NULL;
     char *lastsemi=(char *)NULL;   /* pointer to last semi-colon in pathcomp */
 #ifdef ACORN_FTYPE_NFS
     char *lastcomma=(char *)NULL;  /* pointer to last comma in pathcomp */
@@@@ -429,6 +430,8 @@@@ int mapname(__G__ renamed)
 #endif
     int quote = FALSE;             /* flags */
     int killed_ddot = FALSE;       /* is set when skipping "../" pathcomp */
+    int killed_qslash = FALSE;     /* is set when skipping "^V/" pathcomp */
+    int snarf_ddot = FALSE;	   /* Is set while scanning for "../" */
     int error = MPN_OK;
     register unsigned workch;      /* hold the character being tested */
 
@@@@ -467,6 +470,18 @@@@ int mapname(__G__ renamed)
     while ((workch = (uch)*cp++) != 0) {
 
         if (quote) {                 /* if character quoted, */
+	    if (pp == pathcomp) {
+		quote = FALSE;
+		if (workch == '.')
+		    /* Oh no you don't... */
+	   	    goto ddot_hack;
+	        if (workch == '/') {
+		    /* We *never* allow quote-slash at the beginning */
+		    killed_qslash = TRUE;
+		    continue;
+		}
+	    }
+		
             *pp++ = (char)workch;    /*  include it literally */
             quote = FALSE;
         } else
@@@@ -481,15 +496,45 @@@@ int mapname(__G__ renamed)
                 break;
 
             case '.':
-                if (pp == pathcomp) {   /* nothing appended yet... */
+                if (pp == pathcomp) {
+ddot_hack:
+		    /* nothing appended yet... */
                     if (*cp == '/') {   /* don't bother appending "./" to */
                         ++cp;           /*  the path: skip behind the '/' */
                         break;
-                    } else if (!uO.ddotflag && *cp == '.' && cp[1] == '/') {
-                        /* "../" dir traversal detected */
-                        cp += 2;        /*  skip over behind the '/' */
-                        killed_ddot = TRUE; /*  set "show message" flag */
-                        break;
+                    } else if (!uO.ddotflag) {
d20 11
a30 25
+			/*
+			 * SECURITY: Skip past control characters if the user
+			 * didn't OK use of absolute pathnames. lhh - this is
+			 * a very quick, ugly, inefficient fix; it traverses
+			 * the WHOLE path, eating up these as it comes to it.
+			 */
+			dp = cp;
+			do {
+			    workch = (uch)(*dp);
+			    if (workch == '/' && snarf_ddot) {
+                                /* "../" dir traversal detected */
+                                cp = dp + 1;      /* skip past the '/' */
+                                killed_ddot = TRUE; /* set "show msg" flag */
+                                break;
+                            } else if (workch == '.' && !snarf_ddot) {
+				snarf_ddot = TRUE;
+                	    } else if (isprint(workch) ||
+				       ((workch > 127) && (workch <= 254))) {
+				/*
+				 * Since we found a printable, non-ctrl char,
+				 * we can stop looking for '../', the amount
+				 * in ../!
+				 */
+			        break;
+			    }
d32 17
a48 2
+			    dp++;
+                        } while (*dp != 0);
d50 15
a64 22
+			if (killed_ddot)
+			    break;
                     }
                 }
                 *pp++ = '.';
@@@@ -529,6 +574,16 @@@@ int mapname(__G__ renamed)
     if (killed_ddot && QCOND2) {
         Info(slide, 0, ((char *)slide,
           "warning:  skipped \"../\" path component(s) in %s\n",
+          FnFilter1(G.filename)));
+        if (!(error & ~MPN_MASK))
+            error = (error & MPN_MASK) | PK_WARN;
+    }
+
+    /* Show warning when stripping insecure quoted-slash at beginning of
+       path components */
+    if (killed_qslash && QCOND2) {
+        Info(slide, 0, ((char *)slide,
+          "warning:  skipped root directory component(s) in %s\n",
           FnFilter1(G.filename)));
         if (!(error & ~MPN_MASK))
             error = (error & MPN_MASK) | PK_WARN;
@


1.1
log
@Initial revision
@
text
@d1 1
d3 2
a4 2
--- unix/unix.c.orig	2002-01-21 17:54:42.000000000 -0500
+++ unix/unix.c	2003-08-17 19:25:19.000000000 -0400
d95 9
a103 4
@@@@ -534,6 +579,16 @@@@ int mapname(__G__ renamed)
             error = (error & MPN_MASK) | PK_WARN;
     }
 
d109 3
a111 8
+          FnFilter1(G.filename)));
+        if (!(error & ~MPN_MASK))
+            error = (error & MPN_MASK) | PK_WARN;
+    }
+
 /*---------------------------------------------------------------------------
     Report if directory was created (and no file to create:  filename ended
     in '/'), check name to be sure it exists, and combine path and name be-
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@
