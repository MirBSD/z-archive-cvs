head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2007.05.10.13.02.22;	author tg;	state Exp;
branches;
next	1.10;
commitid	100464317A6439F08F1;

1.10
date	2007.04.17.23.41.01;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046255A1913F69329;

1.9
date	2007.03.04.22.56.56;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045EB4ECF03E8F0F6;

1.8
date	2007.03.04.20.00.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045EB2500777EEDFA;

1.7
date	2007.02.11.00.58.58;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045CE69591B8446BA;

1.6
date	2007.02.11.00.49.44;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.11.00.48.22;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045CE679A4A3CDB4E;

1.4
date	2007.01.10.00.03.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045A42D631573520C;

1.3
date	2007.01.10.00.02.36;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045A42D33365657AB;

1.2
date	2007.01.08.17.20.55;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045A27D4B0E90DE7F;

1.1
date	2006.12.28.04.38.23;	author tg;	state Exp;
branches;
next	;
commitid	10045934A3963A08EF4;


desc
@@


1.11
log
@• wait 75 ms between flushing all tty I/O and writing the enquiry string
• wait 75 ms between writing the enquiry string and waiting for an answer
• bump date of chkuterm, patchlev^Wdash_ver of screen
• screen: mention chkuterm functionality in the description
@
text
@/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.10 2007/04/17 23:41:01 tg Exp $ */

/*-
 * Copyright (c) 2006, 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#ifdef __RCSID
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.16 2007/05/10 13:02:21 tg Exp $");
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.11 2007/05/10 13:02:22 tg Exp $");
__RCSID("$miros: ports/misc/screen/patches/patch-screen_c,v 1.12 2007/05/10 13:02:23 tg Exp $");
#endif

/* query string sent to the terminal for LC_CTYPE detection */
/* XXX is U+20AC U+002E ok or some other char better? Think EUC, SJIS, etc. */
const char ctype_qstr[] = "\030\032\r\xE2\x82\xAC.\033[6n";

/*
 * -U			return true and print (unless -q) if VT is UTF-8
 */

int
main(int argc, char **argv)
{
	const char *wsdev, *est;
	char ch;
	int wsfd, c, rv = 0;
	int nr = 0, q = 0;
	struct termios tio, otio;
	fd_set fds;
	struct timeval tv;
	FILE *wsf;

	while ((c = getopt(argc, argv, "qU")) != -1)
		switch (c) {
		case 'q':
			q = 1;
			break;
		}
	argc -= optind;
	argv += optind;

	wsdev = "/dev/tty";

	/* apparently O_RDONLY wouldn't matter but we stay safe */
	if ((est = ttyname(STDIN_FILENO)) != NULL && !strcmp(wsdev, est))
		wsfd = STDIN_FILENO;
	else if ((est = ttyname(STDOUT_FILENO)) != NULL && !strcmp(wsdev, est))
		wsfd = STDOUT_FILENO;
	else
		if ((wsfd = open(wsdev, O_RDWR, 0)) < 0)
			err(2, "open %s", wsdev);
	wsf = fdopen(wsfd, "rb+");

	if (tcgetattr(wsfd, &otio))
		err(3, "tcgetattr");
	tio = otio;
	cfmakeraw(&tio);
	if (tcflush(wsfd, TCIOFLUSH))
		warn("tcflush");
	rv = /* error */ 3;
	if (tcsetattr(wsfd, TCSANOW, &tio)) {
		warn("tcsetattr\r");
		goto tios_err;
	}
	tv.tv_sec = 0;
	tv.tv_usec = 75;
	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
	if ((size_t)write(wsfd, ctype_qstr, strlen(ctype_qstr)) !=
	    strlen(ctype_qstr)) {
		warn("write\r");
		goto noin;
	}
	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
	FD_ZERO(&fds);
	FD_SET(wsfd, &fds);
	tv.tv_sec = 2;
	tv.tv_usec = 0;
	if (select(wsfd + 1, &fds, NULL, NULL, &tv) <= 0)
		goto noin;
	nr = read(wsfd, &ch, 1);
	rv = /* unknown */ 1;
	if (wsf != NULL && nr == 1 && ch == 033) {
		unsigned zeile, spalte;

		if (fscanf(wsf, "[%u;%u", &zeile, &spalte) == 2)
			switch (spalte) {
			case 1:	/* EUC-JP, EUC-KR kterm */
			case 5:	/* Shift-JIS kterm */
				break;
			case 3:	/* UTF-8 xterm, screen */
				rv = 0;
				break;
			case 4:	/* ISO-8859-1 xterm, screen */
				rv = 2;
				break;
			default:
				rv = 0x1000 | spalte;
				break;
			}
	}
 noin:
	write(wsfd, "\r      \r", 8);
 tios_err:
	if (tcflush(wsfd, TCIOFLUSH))
		warn("tcflush");
	if (tcsetattr(wsfd, TCSANOW, &otio))
		err(3, "tcsetattr");
	if (rv & 0x1000) {
		/* unknown charset */
		if (!q)
			printf("# unknown column %d\n", rv & 0xFFF);
		rv = 1;
	}
	if (!q)
		printf("LC_CTYPE=%s; export LC_CTYPE\n",
		    rv == 0 ? "en_US.UTF-8" : "C");
	if (!q && rv > 2)
		puts("# warning: problems occured!\n");

	if (wsf == NULL)
		close(wsfd);
	else
		fclose(wsf);
	return (rv);
}
@


1.10
log
@When select(2) tells us that we've got something on wsfd, we maybe only got
one char (the first one of the response would be ESC); read it and if it is
it indeed, switch to blocking stdio and get row and column with fscanf(3) –
the response code is luckily being trailed by an ‘R’ that, upon being read,
terminates fscanf gracefully (other stuff is done using TCIOFLUSH).

This change should both make the detection e̲v̲e̲n̲ more reliable on (slow) in-
ternet links as well as reduce the number of flush'd keys if we type during
login already (and not get us the response messed up as programme input). I
only tested this a little bit, though, yet…
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d35 3
a37 3
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.14 2007/04/17 23:41:01 tg Exp $");
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.10 2007/04/17 23:41:01 tg Exp $");
__RCSID("$miros: ports/misc/screen/patches/patch-screen_c,v 1.11 2007/04/17 23:41:02 tg Exp $");
d92 3
d100 1
@


1.9
log
@sync with ports/misc/screen/patches/patch-screen_c,v 1.10
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.8 2007/03/04 20:00:51 tg Exp $ */
d36 2
a37 1
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.8 2007/03/04 20:00:51 tg Exp $");
d52 1
a52 1
	char buf[64];
d58 1
d79 1
d103 1
a103 1
	nr = read(wsfd, buf, sizeof (buf));
d105 13
a117 4
	if (nr > 5 && buf[0] == 033 && buf[1] == '[') {
		c = 2;
		while (c < (nr - 2))
			if (buf[c++] == ';')
d119 4
a122 4
		if (buf[c - 1] == ';' &&
		    (buf[c] == '3' || buf[c] == '4') &&
		    !isdigit(buf[c + 1]))
			rv = buf[c] == '4' ? /* latin1 */ 2 : /* utf-8 */ 0;
d131 6
d143 4
a146 1
	close(wsfd);
@


1.8
log
@• use TCIOFLUSH + TCSANOW instead of TCSAFLUSH
• sleep 50 ms between writing the “get cursor position” request to the
  terminal and reading the answer

appears to¹ help screen's problems when reattaching from an utf-8 tty
to utf-8 screen backend introduced in screen-4.0.3-4 ― please upgrade

¹) if someone has got a better idea², please tell me
²) no we don't fscanf(3) like linux vt-is-UTF8, since the tty may not
   even support the “get cursor position” request at all
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.7 2007/02/11 00:58:58 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.7 2007/02/11 00:58:58 tg Exp $");
d55 2
d92 1
a92 9
		goto tios_err;
	}
	/* delay for 50 ms */
	{
		struct timeval t;

		t.tv_sec = 0;
		t.tv_usec = 50 * 1000;
		select(0, NULL, NULL, NULL, &t);
d94 6
d112 1
@


1.7
log
@because the code yields sometimes quite large values:
* 1 in kterm/EUC-JP (the '.' is required here to end a shift sequence!)
* 3 in screen/UTF-8 and uxterm
* 4 in screen/ISO-8859-1
* 5 in kterm/Shift-JIS (2=竄 (double-width kanji) + 1=ｬ (half-width
  katakana 'ya') + 1=.)
we need to extend our erase space in order to clean up
the temporary output line to prevent display artefacts
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.6 2007/02/11 00:49:44 tg Exp $ */
d35 2
a36 2
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.10 2007/02/11 00:59:00 tg Exp $");
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.6 2007/02/11 00:49:44 tg Exp $");
d92 8
d114 3
a116 1
	if (tcsetattr(wsfd, TCSAFLUSH, &otio))
@


1.6
log
@sync rcsid
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.4 2007/01/10 00:03:24 tg Exp $ */
d35 2
a36 2
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.9 2007/02/11 00:48:24 tg Exp $");
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.4 2007/01/10 00:03:24 tg Exp $");
d104 1
a104 1
	write(wsfd, "\r   \r", 5);
@


1.5
log
@* prevent false positives with Shift-JIS or EUC-JP in ports/japanese/kterm
* new return values:
  0 = UTF-8 (as previously)
  >0 = not utf-8 (as previously)
  1 = unknown charset (as previously, but new meaning)
  2 = positively ISO-8859-1 (new retval)
  3 = error occured (as previously)
@
text
@d35 1
a35 1
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.8 2007/01/10 00:01:06 tg Exp $");
@


1.4
log
@reindent
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.3 2007/01/10 00:02:36 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.3 2007/01/10 00:02:36 tg Exp $");
d40 2
a41 2
/* XXX is U+00A0 ok or some other char better? Think EUC, SJIS, etc. */
const char ctype_qstr[] = "\030\032\r\xC2\xA0\033[6n";
d82 1
a82 1
	rv = 3;
d93 1
a93 1
	rv = 1;
d99 2
a100 1
		if (buf[c - 1] == ';' && buf[c] == '2' &&
d102 1
a102 1
			rv = 0;
d111 1
a111 1
	if (!q && rv > 1)
@


1.3
log
@sync
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.2 2007/01/08 17:20:55 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.2 2007/01/08 17:20:55 tg Exp $");
d76 28
a103 28
		if (tcgetattr(wsfd, &otio))
			err(3, "tcgetattr");
		tio = otio;
		cfmakeraw(&tio);
		if (tcflush(wsfd, TCIOFLUSH))
			warn("tcflush");
		rv = 3;
		if (tcsetattr(wsfd, TCSANOW, &tio)) {
			warn("tcsetattr\r");
			goto tios_err;
		}
		if ((size_t)write(wsfd, ctype_qstr, strlen(ctype_qstr)) !=
		    strlen(ctype_qstr)) {
			warn("write\r");
			goto tios_err;
		}
		nr = read(wsfd, buf, sizeof (buf));
		rv = 1;
		if (nr > 5 && buf[0] == 033 && buf[1] == '[') {
			c = 2;
			while (c < (nr - 2))
				if (buf[c++] == ';')
					break;
			if (buf[c - 1] == ';' && buf[c] == '2' &&
			    !isdigit(buf[c + 1]))
				rv = 0;
		}
		write(wsfd, "\r   \r", 5);
d105 7
a111 7
		if (tcsetattr(wsfd, TCSAFLUSH, &otio))
			err(3, "tcsetattr");
		if (!q)
			printf("LC_CTYPE=%s; export LC_CTYPE\n",
			    rv == 0 ? "en_US.UTF-8" : "C");
		if (!q && rv > 1)
			puts("# warning: problems occured!\n");
@


1.2
log
@* this is not only used by the port, but I also regularily compile
  it stand-alone on e.g. GNU/Linux boxen I ssh to, so
  - #ifdef __RCSID
  - change away from use of strlcpy (even simplifies)
* use $miros: ...$ instead of $From: ...$ or $FromMirOS: ...$
@
text
@d1 1
a1 1
/* $MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.1 2006/12/28 04:38:23 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2006
d35 2
a36 2
__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.7 2006/11/16 21:34:37 tg Exp $");
__RCSID("$MirOS: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.1 2006/12/28 04:38:23 tg Exp $");
d39 4
a55 2
	const char qstr[] = "\030\032\r\xC2\xA0\033[6n";

d87 2
a88 1
		if ((size_t)write(wsfd, qstr, strlen(qstr)) != strlen(qstr)) {
@


1.1
log
@add a stripped-down version of wsconfig(8) -U
because e.g. linux vt-is-UTF8 only works on their VTs (why?)
and other OSes don't even have it...
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d34 4
a37 2
__RCSID("$FromMirOS: src/usr.sbin/wsconfig/wsconfig.c,v 1.7 2006/11/16 21:34:37 tg Exp $");
__RCSID("$MirOS: src/usr.sbin/wsconfig/wsconfig.c,v 1.7 2006/11/16 21:34:37 tg Exp $");
d52 2
d85 1
a85 2
		strlcpy(buf, "\030\032\r\xC2\xA0\033[6n", sizeof (buf));
		if ((size_t)write(wsfd, buf, strlen(buf)) != strlen(buf)) {
@

