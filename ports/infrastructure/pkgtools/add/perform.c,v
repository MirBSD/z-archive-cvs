head	1.30;
access;
symbols
	bsiegert-cfgfile_BASE:1.29
	bsiegert-cfgfile:1.29.0.2
	MIRBSD_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2010.09.02.09.42.47;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004C7F71891FEBACB6;

1.29
date	2009.12.18.22.27.08;	author bsiegert;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	1004B2C01BD309C6FEA;

1.28
date	2009.12.14.19.20.02;	author bsiegert;	state Exp;
branches;
next	1.27;
commitid	1004B268FB977E25639;

1.27
date	2009.11.29.16.56.44;	author bsiegert;	state Exp;
branches;
next	1.26;
commitid	1004B12A4FC0864F791;

1.26
date	2009.11.22.15.34.13;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004B0959E8012B753D;

1.25
date	2009.08.19.18.30.10;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004A8C44C94C0217DA;

1.24
date	2008.11.02.18.56.28;	author tg;	state Exp;
branches;
next	1.23;
commitid	100490DF7B930A3A3BD;

1.23
date	2008.11.02.18.19.51;	author tg;	state Exp;
branches;
next	1.22;
commitid	100490DEF535C71F010;

1.22
date	2008.10.12.15.35.20;	author tg;	state Exp;
branches;
next	1.21;
commitid	10048F218B2228D17F9;

1.21
date	2007.03.30.23.35.34;	author tg;	state Exp;
branches;
next	1.20;
commitid	100460D9ED3219148EC;

1.20
date	2007.03.30.23.20.10;	author bsiegert;	state Exp;
branches;
next	1.19;
commitid	100460D99284E3410CC;

1.19
date	2007.01.19.23.11.18;	author bsiegert;	state Exp;
branches;
next	1.18;
commitid	10045B14FCB796AA24B;

1.18
date	2006.12.28.17.40.35;	author bsiegert;	state Exp;
branches;
next	1.17;
commitid	100459401562EF7D29F;

1.17
date	2006.12.26.15.37.26;	author bsiegert;	state Exp;
branches;
next	1.16;
commitid	100459141775D48ADD4;

1.16
date	2006.12.26.15.20.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	10045913DE96077E8F6;

1.15
date	2006.12.23.03.18.10;	author tg;	state Exp;
branches;
next	1.14;
commitid	100458C9F8F5FB75EB8;

1.14
date	2006.12.23.02.36.15;	author tg;	state Exp;
branches;
next	1.13;
commitid	100458C962D078D7957;

1.13
date	2006.11.19.22.34.06;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004560DBF46435018A;

1.12
date	2006.11.19.22.16.35;	author bsiegert;	state Exp;
branches;
next	1.11;
commitid	1004560D7992BF407CE;

1.11
date	2006.11.19.13.14.29;	author tg;	state Exp;
branches;
next	1.10;
commitid	100456058C918F25219;

1.10
date	2006.11.19.13.06.53;	author bsiegert;	state Exp;
branches;
next	1.9;
commitid	100456056A6630CC851;

1.9
date	2006.11.13.21.49.53;	author bsiegert;	state Exp;
branches;
next	1.8;
commitid	1004558E865044D0FA8;

1.8
date	2006.02.26.00.23.57;	author bsiegert;	state Exp;
branches;
next	1.7;
commitid	1004400F444185869DA;

1.7
date	2005.11.15.19.33.56;	author tg;	state Exp;
branches;
next	1.6;
commitid	7927437a38332782;

1.6
date	2005.09.19.17.42.03;	author tg;	state Exp;
branches;
next	1.5;
commitid	8b7432ef87acf59;

1.5
date	2005.09.12.22.53.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	6e6c432606e897b6;

1.4
date	2005.06.29.17.20.17;	author bsiegert;	state Exp;
branches
	1.4.2.1;
next	1.3;
commitid	1b2442c2d7478718;

1.3
date	2005.06.26.17.13.43;	author tg;	state Exp;
branches;
next	1.2;
commitid	224442bee24581eb;

1.2
date	2005.05.21.01.58.41;	author tg;	state Exp;
branches;
next	1.1;
commitid	1650428e95d3b2fd;

1.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.29.2.1
date	2009.12.23.15.41.46;	author bsiegert;	state Exp;
branches;
next	1.29.2.2;
commitid	1004B323A2376E23055;

1.29.2.2
date	2010.06.09.04.37.55;	author bsiegert;	state Exp;
branches;
next	1.29.2.3;
commitid	1004C0F1A2217CA635E;

1.29.2.3
date	2010.06.12.20.27.10;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004C13ED937750A323;

1.4.2.1
date	2005.09.11.02.04.03;	author tg;	state Exp;
branches;
next	;
commitid	1604323908f2ff4;

1.1.7.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.30
log
@replace all remaining calls to system(…) with sxsystem(false, …)
and switch piperead() to use mksh, to fulfil our guarantees
@
text
@/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29 2009/12/18 22:27:08 bsiegert Exp $ */
/* $OpenBSD: perform.c,v 1.32 2003/08/21 20:24:56 espie Exp $	*/

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * This is the main body of the add module.
 */

#include <err.h>
#include "lib.h"
#include "add.h"

#include <sys/wait.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>

__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29 2009/12/18 22:27:08 bsiegert Exp $");

static int pkg_do(char *);
static int sanity_check(char *);
static int install_dep_local(char *, char *);
static int install_dep_ftp(char *, char *);
#if 1
#define register_dep_ register_dep
#else
#define register_dep(a,b) do { 						\
		fprintf(stderr, "\n\tregistering dependency <%s> for"	\
		    " <%s> on %d\n", (b), (a), __LINE__);		\
		register_dep_((a), (b));				\
	} while (0)
#endif
static void register_dep_(char *, char *);
static void write_deps(void);

static char LogDir[FILENAME_MAX];
static int zapLogDir;          /* Should we delete LogDir? */
static char *PkgDeps = NULL;
static const char *dbdir = NULL;

int
pkg_perform(char **pkgs)
{
    int i, err_cnt = 0;

    signal(SIGINT, cleanup);
    signal(SIGHUP, cleanup);

    if (AddMode == SLAVE)
	err_cnt = pkg_do(NULL);
    else {
	for (i = 0; pkgs[i]; i++)
	    err_cnt += pkg_do(pkgs[i]);
    }
    return err_cnt;
}

static package_t Plist;
static char *Home;

/* called to see if pkg is already installed as some other version */
/* note found version in "note" */
static int
check_if_installed(const char *found, char *note, int len)
{
    strlcpy(note, found, len);
    return 0;
}

/*
 * This is seriously ugly code following.  Written very fast!
 * [And subsequently made even worse..  Sigh!  This code was just born
 * to be hacked, I guess.. :) -jkh]
 */
static int
pkg_do(char *pkg)
{
    char pkg_fullname[FILENAME_MAX];
    char playpen[FILENAME_MAX];
    char extract_contents[FILENAME_MAX];
    char solve_deps[FILENAME_MAX+50];
    char installed[FILENAME_MAX];
    char *where_to, *tmp, *extract;
    FILE *cfile;
    int code;
    plist_t *p;
    struct stat sb;

    set_pkg(pkg);
    code = 0;
    zapLogDir = 0;
    LogDir[0] = '\0';
    strlcpy(playpen, FirstPen, sizeof(playpen));
    dbdir = (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR;

    snprintf(solve_deps, sizeof solve_deps, "pkg%s dependencies solve %s",
	Verbose ? " -v": "", CONTENTS_FNAME);
    if (Prefix)
    	setenv("PKG_PREFIX", Prefix, 1);
    else
    	unsetenv("PKG_PREFIX");
    /* Are we coming in for a second pass, everything already extracted? */
    /* (Slave mode) */
    if (!pkg) {
	fgets(playpen, FILENAME_MAX, stdin);
	playpen[strlen(playpen) - 1] = '\0'; /* pesky newline! */
	if (chdir(playpen) == -1) {
	    pwarnx("add in SLAVE mode can't chdir to '%s'", playpen);
	    return 1;
	}
	read_plist(&Plist, stdin);
	where_to = playpen;
    }
    /* Nope - do it now */
    else {
	/* Is it an ftp://foo.bar.baz/file.tgz specification? */
	if (isURL(pkg)) {
	    if (ispkgpattern(pkg)) {
		pwarnx("patterns not allowed in URLs, "
		     "please install manually!");
		/* ... until we come up with a better solution :-/  - HF */
		goto bomb;
	    }

	    if (!(Home = fileGetURL(NULL, pkg))) {
		pwarnx("unable to fetch '%s' by URL", pkg);
		return 1;
	    }
	    where_to = Home;
	    strlcpy(pkg_fullname, pkg, sizeof(pkg_fullname));
	    sxsystem(false, solve_deps);
	    cfile = fopen(CONTENTS_FNAME, "r");
	    if (!cfile) {
		pwarnx(
		"unable to open table of contents file '%s' - not a package?",
		CONTENTS_FNAME);
		goto bomb;
	    }
	    read_plist(&Plist, cfile);
	    fclose(cfile);
	} else {
	    strlcpy(pkg_fullname, ensure_tgz(pkg), sizeof(pkg_fullname));
	    if (strcmp(pkg, "-")) {
		if (ispkgpattern(pkg_fullname))
		    sb.st_size = 100000;
		else if (stat(pkg_fullname, &sb) == -1) {
		    pwarnx("can't stat package file '%s'", pkg_fullname);
		    goto bomb;
		}
		strlcpy(extract_contents, CONTENTS_FNAME,
			sizeof(extract_contents));
		extract = extract_contents;
	    } else {
		extract = NULL;
		sb.st_size = 100000;	/* Make up a plausible average size */
	    }
	    Home = make_playpen(playpen, sizeof(playpen), sb.st_size * 4);
	    if (!Home)
		pwarnx("unable to make playpen for %ld bytes",
		    (long)(sb.st_size * 4));
	    where_to = Home;
	    if (unpack(pkg_fullname, extract)) {
		pwarnx(
	"unable to extract table of contents from '%s'\n"
	"Is this a Package, or a simple .tgz archive ?  See tar(1).",
		pkg_fullname);
		goto bomb;
	    }
	    sxsystem(false, solve_deps);
	    cfile = fopen(CONTENTS_FNAME, "r");
	    if (!cfile) {
		pwarnx(
	"unable to open table of contents file '%s'\n"
	"Is this a Package, or a simple .tgz archive ?  See tar(1).",
		CONTENTS_FNAME);
		goto bomb;
	    }
	    read_plist(&Plist, cfile);
	    fclose(cfile);

	    /*
	     * Apply a crude heuristic to see how much space the package will
	     * take up once it's unpacked.  I've noticed that most packages
	     * compress an average of 75%, so multiply by 4 for good
	     * measure.  Ignore if extract is null as we've already
	     * extracted the full file, anyway.
	     */

	    if (!extract && min_free(playpen) < (size_t)sb.st_size * 4) {
		pwarnx("projected size of %ld exceeds available free space\n"
		       "Please set your PKG_TMPDIR variable to point to a"
		       "location with more\n"
		       "free space and try again", (long)(sb.st_size * 4));
		pwarnx("not extracting '%s'\ninto '%s', sorry!", pkg_fullname,
		       where_to);
		goto bomb;
	    }

	    /* Finally unpack the whole mess.  If extract is null we already
	       did so so don't bother doing it again. */
	    if (extract && unpack(pkg_fullname, NULL)) {
		pwarnx("unable to extract '%s'!", pkg_fullname);
		goto bomb;
	    }
	} /* isURL(pkg) */

	/* Check for sanity and dependencies */
	if (sanity_check(pkg))
	    goto bomb;

	/* If we're running in MASTER mode, just output the plist and return */
	if (AddMode == MASTER) {
	    printf("%s\n", where_playpen());
	    write_plist(&Plist, stdout);
	    return 0;
	}
    }

    /*
     * If we have a prefix, delete the first one we see and add this
     * one in place of it.
     */
    if (Prefix) {
	delete_plist(&Plist, false, PLIST_CWD, NULL);
	add_plist_top(&Plist, PLIST_CWD, Prefix);
    }

    setenv(PKG_PREFIX_VNAME, (p = find_plist(&Plist, PLIST_CWD, NULL)) ? p->name : ".", 1);
    /* Protect against old packages with bogus @@name fields */
    PkgName = (p = find_plist(&Plist, PLIST_NAME, NULL)) ? p->name : NULL;
    if (PkgName == NULL) {
	pwarnx("package name not set in package file");
	goto bomb;
    }

    /* See if we're already registered */
    (void) snprintf(LogDir, sizeof(LogDir), "%s/%s", dbdir, PkgName);
    if ((isdir(LogDir) || islinktodir(LogDir)) && !Force) {
	pwarnx("package already recorded as installed");
	code = 1;
	goto success;	/* close enough for government work */
    }

    /* See if some other version of us is already installed */
    tmp = nuke_version(PkgName, true);


    if (findmatchingname(dbdir, tmp, check_if_installed, installed, sizeof(installed))) {
	pwarnx("other version '%s' already installed", installed);
	if (find_plist_option(&Plist, "no-default-conflict") != NULL) {
	    pwarnx("proceeding with installation anyway");
	} else {
	    if (tmp)
		free(tmp);
	    code = 1;
	    goto success;	/* close enough for government work */
	}
    }
    if (tmp)
	free(tmp);

    /* Do we have the right binary emulation? */
    for (p = Plist.head; p ; p = p->next) {
	if (p->type != PLIST_EMUL)
	    continue;
	if (Verbose)
	    printf("Package '%s' needs %s binary emulation\n", PkgName, p->name);

	if (!have_emulation(p->name)) {
	    pwarnx("Package requires %s binary emulation layer, which is not"
		   " enabled or not available! See the compat_%s(8) manpage"
		   " for details.%s",
		    p->name, p->name, Force ? " (continuing anyway)" : "");
	    if (!Force)
		goto bomb;
	}
    }
    
    /* See if there are conflicting packages installed */
    for (p = Plist.head; p ; p = p->next) {
	char insttst[FILENAME_MAX];

	if (p->type != PLIST_PKGCFL)
	    continue;
	if (Verbose)
	    printf("Package '%s' conflicts with '%s'\n", PkgName, p->name);

	if(findmatchingname(dbdir, p->name, check_if_installed, insttst, sizeof(insttst))){
	    pwarnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!",  insttst);
	    ++code;
	}
    }

    /* Now check the packing list for dependencies */
    for (p = Plist.head; p ; p = p->next) {
	char insttst[FILENAME_MAX];

	if (p->type != PLIST_PKGDEP)
	    continue;
	if (Verbose)
	    printf("Package '%s' depends on '%s'\n", PkgName, p->name);
	if (!findmatchingname(dbdir, p->name, check_if_installed, insttst, sizeof(insttst))) {
	    if (!Fake) {
		if (!isURL(pkg) && !getenv("PKG_ADD_BASE"))
		    code += install_dep_local(pkg, p->name);
		else
		    code += install_dep_ftp(pkg, p->name);
	    } else {
		if (Verbose)
		    printf("and was not found%s\n", Force ? " (proceeding anyway)" : "");
		else
		    printf("Package dependency '%s' for '%s' not found%s\n", p->name, pkg,
			   Force ? " (proceeding anyway)" : "!");
		if (!Force)
		    ++code;
	    }
	} else {
	    if (Verbose)
		printf(" - '%s' already installed\n", insttst);
	    register_dep(pkg, insttst);
	}
    }

    if (code != 0)
	goto bomb;

    /* Look for the requirements file */
    if (fexists(REQUIRE_FNAME)) {
	xsystem(false, "chmod +x %s", REQUIRE_FNAME);	/* be sure */
	if (Verbose)
	    printf("Running requirements file first for '%s'\n", PkgName);
	if (!Fake && xsystem(false, "./%s %s INSTALL", REQUIRE_FNAME, PkgName)) {
	    pwarnx("package '%s' fails requirements %s", pkg_fullname,
		   Force ? "installing anyway" : "- not installed");
	    if (!Force) {
		code = 1;
		goto success;	/* close enough for government work */
	    }
	}
    }

    /* If we're really installing, and have an installation file, run it */
    if (!NoInstall && fexists(INSTALL_FNAME)) {
	xsystem(false, "chmod +x %s", INSTALL_FNAME);	/* make sure */
	if (Verbose)
	    printf("Running install with PRE-INSTALL for '%s'\n", PkgName);
	if (!Fake && xsystem(false, "./%s %s PRE-INSTALL", INSTALL_FNAME, PkgName)) {
	    pwarnx("install script returned error status");
	    unlink(INSTALL_FNAME);
	    code = 1;
	    goto success;		/* nothing to uninstall yet */
	}
    }

    extract_plist(".", &Plist);

    if (!Fake && fexists(MTREE_FNAME)) {
	if (Verbose)
	    printf("Running mtree for '%s'\n", PkgName);
	p = find_plist(&Plist, PLIST_CWD, NULL);
	if (Verbose)
	    printf("mtree -q -U -f %s -d -e -p %s\n", MTREE_FNAME,
		   p ? p->name : "/");
	if (!Fake) {

	    if (xsystem(false, "mtree -q -U -f %s -d -e -p %s", MTREE_FNAME,
			p ? p->name : "/"))
		pwarnx("mtree returned a non-zero status - continuing");
	}
	unlink(MTREE_FNAME);
    }

    /* Run the installation script one last time? */
    if (!NoInstall && fexists(INSTALL_FNAME)) {
	if (Verbose)
	    printf("Running install with POST-INSTALL for '%s'\n", PkgName);
	if (!Fake && xsystem(false, "./%s %s POST-INSTALL", INSTALL_FNAME, PkgName)) {
	    pwarnx("install script returned error status");
	    unlink(INSTALL_FNAME);
	    code = 1;
	    goto fail;
	}
	unlink(INSTALL_FNAME);
    }

    /* Time to record the deed? */
    if (!NoRecord && !Fake) {
	char contents[FILENAME_MAX];

	umask(022);
#ifndef AS_USER
	if (getuid() != 0)
	    pwarnx("not running as root - trying to record install anyway");
#endif
	if (!PkgName) {
	    pwarnx("no package name! can't record package, sorry");
	    code = 1;
	    goto success;	/* well, partial anyway */
	}
	(void) snprintf(LogDir, sizeof(LogDir), "%s/%s", dbdir, PkgName);
	zapLogDir = 1;
	if (Verbose)
	    printf("Attempting to record package into '%s'\n", LogDir);
	drop_privs();
	if (make_hierarchy(LogDir)) {
	    pwarnx("can't record package into '%s', you're on your own!",
		   LogDir);
	    memset(LogDir, 0, FILENAME_MAX);
	    raise_privs();
	    code = 1;
	    goto success;	/* close enough for government work */
	}
	raise_privs();
	/* Make sure pkg_info can read the entry */
	xsystem(false, "chmod a+rx %s", LogDir);
	if (fexists(DEINSTALL_FNAME))
	    move_file(".", DEINSTALL_FNAME, LogDir);
	if (fexists(REQUIRE_FNAME))
	    move_file(".", REQUIRE_FNAME, LogDir);
	(void) snprintf(contents, sizeof(contents), "%s/%s", LogDir, CONTENTS_FNAME);
	drop_privs();
	cfile = fopen(contents, "w");
	if (!cfile) {
	    raise_privs();
	    pwarnx("can't open new contents file '%s'! can't register pkg",
		contents);
	    goto success; /* can't log, but still keep pkg */
	}
	write_plist(&Plist, cfile);
	fclose(cfile);
	raise_privs();
	move_file(".", DESC_FNAME, LogDir);
	move_file(".", COMMENT_FNAME, LogDir);
	if (fexists(DISPLAY_FNAME))
	    move_file(".", DISPLAY_FNAME, LogDir);
	write_deps();

	if (Verbose)
	    printf("Package '%s' registered in '%s'\n", PkgName, LogDir);
    }

    if ((p = find_plist(&Plist, PLIST_DISPLAY, NULL)) != NULL) {
	const char *Pager;
	char buf[BUFSIZ];
	struct stat sbuf;

	switch(DisplayMode) {
	    case CAT:
		Pager = "/bin/cat";
		break;
	    case LESS:
		Pager = "less";
		break;
	    case MORE:
		Pager = NULL;
		break;
	    case ENV:
		Pager = getenv("PAGER");
		break;
	    default:
		Pager = "more";
	}

	snprintf(buf, sizeof buf, "%s/%s", LogDir, p->name);
	if (stat(buf,&sbuf) == -1 || xsystem(false, "%s %s", Pager, buf)) {
	    pwarnx("cannot open '%s' as display file", buf);
	    DisplayMode = CAT;	/* in case the pager is just missing */
	}
    }

    goto success;

 bomb:
    code = 1;
    goto success;

 fail:
    /* Nuke the whole (installed) show, XXX but don't clean directories */
    if (!Fake)
	delete_package(false, false, RMCFG_NONE, false, &Plist);

 success:
    /* delete the packing list contents */
    free_plist(&Plist);
    leave_playpen(Home);
    return code;
}

/* install depending pkg from local disk */
static int
install_dep_local(char *base, char *pattern)
{
    char *cp;
    char path[FILENAME_MAX];

    snprintf(path, sizeof(path), "%s/%s", Home, ensure_tgz(pattern));
    if (fexists(path))
	cp = path;
    else
	cp = fileFindByPath(base, pattern);
    if (cp) {
	if (Verbose)
	    printf("Loading it from '%s'\n", cp);
	if (xsystem(false, "pkg_add %s%s %s%s",
		     Prefix ? "-p " : "",
		     Prefix ? Prefix : "",
		     Verbose ? "-v " : "", cp)) {
	    pwarnx("autoload of dependency '%s' failed%s",
		cp, Force ? " (proceeding anyway)" : "!");
	    if (!Force)
		return 1;
	}
	register_dep(base, cp);
    } else {
	pwarnx("add of dependency '%s' failed%s",
		pattern, Force ? " (proceeding anyway)" : "!");
	     if (!Force)
		 return 1;
    }
    return 0;
}

/* install depending pkg via FTP */
static int
install_dep_ftp(char *base, char *pattern)
{
    char *cp;

    if (ispkgpattern(pattern)){
	pwarnx("can't install dependent pkg '%s' via FTP, "
	     "please install manually!", pattern);
	/* ... until we come up with a better solution - HF */
	return 1;
    } else {
	char *saved_Current;   /* allocated/set by save_dirs(), */
	char *saved_Previous;  /* freed by restore_dirs() */

	save_dirs(&saved_Current, &saved_Previous);

	if ((cp = fileGetURL(base, pattern)) != NULL) {
	    if (Verbose)
		printf("Finished loading '%s' over FTP\n", pattern);
	    /*sxsystem(false, solve_deps); * XXX */
	    if (!fexists(CONTENTS_FNAME)) {
		pwarnx("autoloaded package '%s' has no %s file?",
		      pattern, CONTENTS_FNAME);
		if (!Force)
		    return 1;
	    } else if (xsystem(false, "(pwd; cat %s) | pkg_add %s%s %s-S",
			     CONTENTS_FNAME,
			     Prefix ? "-p " : "",
			     Prefix ? Prefix : "",
			     Verbose ? "-v " : "")) {
		pwarnx("add of dependency '%s' failed%s",
		      pattern, Force ? " (proceeding anyway)" : "!");
		if (!Force)
		    return 1;
	    } else if (Verbose)
		printf("\t'%s' loaded successfully\n", pattern);
	    /* Nuke the temporary playpen */
	    leave_playpen(cp);
	    free(cp);

	    restore_dirs(saved_Current, saved_Previous);
	    register_dep(base, pattern);
	}
    }
    return 0;
}

/* add a dependent package to the internal depends list */
static void
register_dep_(char *pkg, char *dep)
{
    char *dep2, *bdep, *new_pkgdeps;

    if (!pkg || !dep)
	return;

    if ((dep2 = strdup(dep)) == NULL) {
	pwarn("dependency registration on %s is incomplete", dep);
	return;
    }
    if ((bdep = basename(dep2)) == NULL) {
	free(dep2);
	pwarn("dependency registration on %s is incomplete", dep);
	return;
    }

    trim_end(bdep);
    if (asprintf(&new_pkgdeps, "%s%s\n", PkgDeps ? PkgDeps : "", bdep) < 0)
	pwarn("dependency registration on %s is incomplete", dep);
    else {
	free(PkgDeps);
	PkgDeps = new_pkgdeps;
    }
    free(dep2);
}

/* write the dependencies of a package into its dbdir and register them */
static void
write_deps(void)
{
    char filename[FILENAME_MAX];
    char *cp, *token;

    if (!PkgDeps || !LogDir)
	return;

    (void) snprintf(filename, sizeof(filename), "%s/%s", LogDir, DEPENDS_FNAME);
    drop_privs();
    (void)write_file(filename, "w", "%s", PkgDeps);
    raise_privs();

    token = PkgDeps;
    while ((cp = strsep(&token, "\n")) != NULL) {
	if (*cp == '\0')
	    continue;
	if (Verbose)
	    printf("Attempting to record dependency on package '%s'\n", cp);
	snprintf(filename, sizeof(filename), "%s/%s/%s", dbdir, cp,
	    REQUIRED_BY_FNAME);
	drop_privs();
	if (write_file(filename, "a", "%s\n", PkgName))
	    pwarnx("dependency registration is incomplete");
	raise_privs();
    }
    free(PkgDeps);
    PkgDeps = NULL;
}

static int
sanity_check(char *pkg)
{
    int code = 0;

    if (!fexists(CONTENTS_FNAME)) {
	pwarnx("package '%s' has no CONTENTS file!", pkg);
	code = 1;
    }
    else if (!fexists(COMMENT_FNAME)) {
	pwarnx("package '%s' has no COMMENT file!", pkg);
	code = 1;
    }
    else if (!fexists(DESC_FNAME)) {
	pwarnx("package '%s' has no DESC file!", pkg);
	code = 1;
    }
    return code;
}

void
cleanup(int signo)
{
    int save_errno = errno;
    static int	alreadyCleaning;
    void (*oldint)(int);
    void (*oldhup)(int);
    char buf[1024];
    oldint = signal(SIGINT, SIG_IGN);
    oldhup = signal(SIGHUP, SIG_IGN);

    /* XXX big signal race, nearly all of it! */
    if (!alreadyCleaning) {
    	alreadyCleaning = 1;
	if (signo) {
	    snprintf(buf, sizeof buf,
		"Signal %d received, cleaning up\n", signo);
	    write(STDOUT_FILENO, buf, strlen(buf));
	}
	if (!Fake && zapLogDir && LogDir[0])
	    xsystem(false, "%s -rf %s", REMOVE_CMD, LogDir);	/* XXX */
	leave_playpen(Home);				/* XXX */
	if (signo)
	    _exit(1);
    }
    signal(SIGINT, oldint);
    signal(SIGHUP, oldhup);
    errno = save_errno;
}
@


1.29
log
@Fix a wrong use of trim_end(), thanks tg@@ for noticing
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.28 2009/12/14 19:20:02 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.28 2009/12/14 19:20:02 bsiegert Exp $");
d145 1
a145 1
	    system(solve_deps);
d183 1
a183 1
	    system(solve_deps);
d557 1
a557 1
	    /*system(solve_deps); * XXX */
@


1.29.2.1
log
@Implement the first useful configuration directive:

	Pager /path/to/pager

for specifying the pager to use in pkg_add.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29 2009/12/18 22:27:08 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29 2009/12/18 22:27:08 bsiegert Exp $");
d457 1
d459 18
d479 1
a479 1
	if (!fexists(buf) || xsystem(false, "%s %s", Pager, buf)) {
d481 1
a481 1
	    Pager = "/bin/cat";	/* in case the pager is just missing */
@


1.29.2.2
log
@Eliminate the need for calling "pkg dependencies solve" in pkg_add.

Parse @@newdep and @@libdep lines and use the pattern given to find the dependency.
The libspec is checked with the new routines. The default package is ignored.

Example output:
bsiegert% sudo ./add/obj/pkg_add -v tiff-cxx
Requested space: 29292 bytes, free space: 1924124672 bytes in /var/tmp/instmp.tJKm5jzk3c
Package 'tiff-3.7.4-1' depends on 'jpeg-*'
 searching for shared library jpeg (at least 62.0) in lib - found /usr/mpkg/lib/libjpeg.62.0.0.dylib
 - 'jpeg-6b-5' already installed
Package 'tiff-cxx-3.7.4-1' depends on 'tiff-*'
 searching for libtool library tiff.la in lib - not found
Got package source '/usr/ports/Packages', priority 1
Loading dependency from '/usr/ports/Packages/tiff-3.7.4-1.cgz'
Requested space: 3183052 bytes, free space: 1924063232 bytes in /var/tmp/instmp.U5fVD0PcQo
Package 'tiff-3.7.4-1' depends on 'jpeg-*'
 searching for shared library jpeg (at least 62.0) in lib - found /usr/mpkg/lib/libjpeg.62.0.0.dylib
 - 'jpeg-6b-5' already installed
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29.2.1 2009/12/23 15:41:46 bsiegert Exp $ */
a27 1
#include <assert.h>
d32 1
a32 8
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.29.2.1 2009/12/23 15:41:46 bsiegert Exp $");

struct dependency {
	char *pkgname;
	char *libspec;
	char *pattern;
	char *defaultpkg;
};
a37 1
static void parse_dependency(struct dependency *, pl_ent_t, char *);
a74 20
/* parse a string parameter str for a @@newdep or @@libdep command and return
 * its fields in dep.
 */
static void
parse_dependency(struct dependency *dep, pl_ent_t type, char *str)
{
	assert(dep != NULL);
	assert(str != NULL);
	
	/* @@newdep pkgname:pattern:defaultpkg */
	/* @@libdep pkgame:libspec:pattern:defaultpkg */
	
	dep->pkgname = strsep(&str, ":");
	if (type == PLIST_LIBDEP)
		dep->libspec = strsep(&str, ":");
	dep->pattern = strsep(&str, ":");
	dep->defaultpkg = str;
}


d145 1
a145 1
	    /*system(solve_deps);*/
d183 1
a183 1
	    /*system(solve_deps);*/
a310 1
	struct dependency dep;
d312 1
a312 11
	memset(&dep, 0, sizeof (dep));
	switch (p->type) {
	case PLIST_PKGDEP:
	    dep.pkgname = PkgName;
	    dep.pattern = p->name;
	    break;
	case PLIST_NEWDEP:
	case PLIST_LIBDEP:
	    parse_dependency(&dep, p->type, p->name);
	    break;
	default:
d314 3
a316 7
	}
	diag("Package '%s' depends on '%s'\n", dep.pkgname, dep.pattern);
	if (match_libspec(dep.libspec, getenv(PKG_PREFIX_VNAME), LD_DYLD)
		&& findmatchingname(dbdir, dep.pattern, check_if_installed, insttst, sizeof(insttst))) {
	    diag(" - '%s' already installed\n", insttst);
	    register_dep(pkg, insttst);
	} else {
d319 1
a319 1
		    code += install_dep_local(pkg, dep.pattern);
d321 1
a321 1
		    code += install_dep_ftp(pkg, dep.pattern);
d323 5
a327 3
		printf("Package dependency '%s' for '%s' not found%s\n",
			dep.pattern, dep.pkgname,
			Force ? " (proceeding anyway)" : "!");
d331 4
d488 1
a488 1
    char *pkg_filename;
d493 7
a499 13
	pkg_filename = path;
    else {
	strlcpy(path, pattern, sizeof (path));
	/* tiff-*, for example, also matches tiff-cxx. If the -* suffix
	 * is cut off here, fileFindByPath will add ->=0.
         */	 
	if (path && !strcmp(path + strlen(path) - 2, "-*"))
	    path[strlen(path) - 2] = '\0';
	pkg_filename = fileFindByPath(dirname(base), path);
    }
    if (pkg_filename) {
	diag("Loading dependency from '%s'\n", pkg_filename);
	if (xsystem(false, "pkg_add %s%s %s'%s'",
d502 1
a502 1
		     Verbose ? "-v " : "", pkg_filename)) {
d504 1
a504 1
		pkg_filename, Force ? " (proceeding anyway)" : "!");
d508 1
a508 1
	register_dep(base, pkg_filename);
d512 2
a513 2
	if (!Force)
	    return 1;
@


1.29.2.3
log
@Add a new function get_ld_type() to examine the plist for the ld type and use it for
checking library dependencies.
@
text
@d356 1
a356 1
	if (match_libspec(dep.libspec, getenv(PKG_PREFIX_VNAME), get_ld_type(&Plist))
a566 2
    char *saved_Current;   /* allocated/set by save_dirs(), */
    char *saved_Previous;  /* freed by restore_dirs() */
d568 1
a568 1
    if (ispkgpattern(pattern)) {
d573 3
a575 1
    }
d577 1
a577 1
    save_dirs(&saved_Current, &saved_Previous);
d579 23
a601 23
    if ((cp = fileGetURL(base, pattern)) != NULL) {
	if (Verbose)
	    printf("Finished loading '%s' over FTP\n", pattern);
	/*system(solve_deps); * XXX */
	if (!fexists(CONTENTS_FNAME)) {
	    pwarnx("autoloaded package '%s' has no %s file?",
		  pattern, CONTENTS_FNAME);
	    if (!Force)
		return 1;
	} else if (xsystem(false, "(pwd; cat %s) | pkg_add %s%s %s-S",
			 CONTENTS_FNAME,
			 Prefix ? "-p " : "",
			 Prefix ? Prefix : "",
			 Verbose ? "-v " : "")) {
	    pwarnx("add of dependency '%s' failed%s",
		  pattern, Force ? " (proceeding anyway)" : "!");
	    if (!Force)
		return 1;
	} else if (Verbose)
	    printf("\t'%s' loaded successfully\n", pattern);
	/* Nuke the temporary playpen */
	leave_playpen(cp);
	free(cp);
d603 3
a605 2
	restore_dirs(saved_Current, saved_Previous);
	register_dep(base, pattern);
@


1.28
log
@- use trim_end(), it exists for a reason
- if you say you cannot modify "dep", then just strdup() it at the start
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.27 2009/11/29 16:56:44 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.27 2009/11/29 16:56:44 bsiegert Exp $");
d604 2
a605 2
    if (asprintf(&new_pkgdeps, "%s%s\n", PkgDeps ? PkgDeps : "",
		trim_end(bdep)) < 0)
@


1.27
log
@One more snprintf -> strlcpy, one more off_t -> size_t. There was one
code path where an uninitialized value for sb.st_size was used.

Found by, you guessed it.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.26 2009/11/22 15:34:13 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.26 2009/11/22 15:34:13 tg Exp $");
d589 1
a589 1
    char *cp;
d594 7
a600 3
    if ((cp = basename(dep)) == NULL) {
	pwarnx("dependency name too long: %s\n"
	    "dependency registration is incomplete", dep);
a602 1
    dep = cp;
d604 8
a611 25
    /* cut off .cgz extension... we can't modify original "dep"
     * tho, because if we're called from install_dep_ftp it might
     * be in use otherwise, and I didn't bother to check... -TG */
    if ((cp = strrchr(dep, '.')) != NULL) {
	/* cf. ensure_tgz() in lib/file.c */
	if (!strcmp(cp, ".cgz") ||
	    !strcmp(cp, ".cxz") ||
	    !strcmp(cp, ".clz") ||
	    !strcmp(cp, ".cpio") ||
	    !strcmp(cp, ".tgz") ||
	    !strcmp(cp, ".tar")) {
		*cp = '\0';
	} else if (!strcmp(cp, ".gz"))
		if ((cp = strrchr(cp, '.')) != NULL)
			if (!strcmp(cp, ".tar.gz"))
				*cp = '\0';
    }

    if (asprintf(&cp, "%s%s\n", PkgDeps ? PkgDeps : "", dep) < 0)
	    pwarnx("cannot allocate memory for PkgDeps list!\n"
		    "dependency registration is incomplete");
	else {
	    free(PkgDeps);
	    PkgDeps = cp;
	}
@


1.26
log
@support for the upcoming XZ Utils compression
planned for long, prodded by bsiegert@@
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.25 2009/08/19 18:30:10 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.25 2009/08/19 18:30:10 tg Exp $");
d158 3
a160 2
		if (!ispkgpattern(pkg_fullname)
		    && stat(pkg_fullname, &sb) == -1) {
d164 2
a165 2
		snprintf(extract_contents, sizeof( extract_contents ),
			 "%s", CONTENTS_FNAME);
d167 1
a167 2
	    }
	    else {
d203 1
a203 1
	    if (!extract && min_free(playpen) < sb.st_size * 4) {
@


1.25
log
@make this able to handle .cpio and .tar (interestingly enough, some
parts of the code also know .tar.Z but not all) for use on e.g. the
slow platforms (sparc etc) when re-compressing packages on a faster
machine afterwards
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.24 2008/11/02 18:56:28 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.24 2008/11/02 18:56:28 tg Exp $");
d607 1
@


1.24
log
@• add new memory management functions (xcalloc, xrealloc, xfree, xstrdup,
  xasprintf, xvasprintf)
• add new process calling functions which can optionally unlimit datasize
• add safe formatting functions (untested)
• retire asystem for xsystem
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.23 2008/11/02 18:19:51 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.23 2008/11/02 18:19:51 tg Exp $");
d608 1
@


1.23
log
@rename vsystem into asystem, because v* are these who take a va_list
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.22 2008/10/12 15:35:20 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.22 2008/10/12 15:35:20 tg Exp $");
d343 1
a343 1
	asystem("chmod +x %s", REQUIRE_FNAME);	/* be sure */
d346 1
a346 1
	if (!Fake && asystem("./%s %s INSTALL", REQUIRE_FNAME, PkgName)) {
d358 1
a358 1
	asystem("chmod +x %s", INSTALL_FNAME);	/* make sure */
d361 1
a361 1
	if (!Fake && asystem("./%s %s PRE-INSTALL", INSTALL_FNAME, PkgName)) {
d380 1
a380 1
	    if (asystem("mtree -q -U -f %s -d -e -p %s", MTREE_FNAME,
d391 1
a391 1
	if (!Fake && asystem("./%s %s POST-INSTALL", INSTALL_FNAME, PkgName)) {
d429 1
a429 1
	asystem("chmod a+rx %s", LogDir);
d479 1
a479 1
	if (stat(buf,&sbuf) == -1 || asystem("%s %s", Pager, buf)) {
d518 1
a518 1
	if (asystem("pkg_add %s%s %s%s",
d563 1
a563 1
	    } else if (asystem("(pwd; cat %s) | pkg_add %s%s %s-S",
d698 1
a698 1
	    asystem("%s -rf %s", REMOVE_CMD, LogDir);	/* XXX */
@


1.22
log
@Support for LZMA compressed binary packages (experimental!)

Tested:
• tg@@bleu:/usr/ports/archivers/mpczar $ mmake PKG_SUFX=.clz install clean
• tg@@bleu:~ $ sudo pkg_upgrade -fva /usr/ports/Packages/ssfe-20070109-1.clz

Dependencies on LZMA are *not* handled automatically, also you must use
PKG_SUFX=.clz to enable and ensure lzma is installed prior. This is some-
what hacky, but our package tools suck anyway. The infrastructure allows
for other compressors such as bzip2 too (but that one is not much of a
saving compared to lzma (ratio) and gzip (resource usage) so I did *not*
add it), but in a *lot* of places… should unify that or better, rewrite
all of the package tools in mksh… anyway, please test.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.21 2007/03/30 23:35:34 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.21 2007/03/30 23:35:34 tg Exp $");
d343 1
a343 1
	vsystem("chmod +x %s", REQUIRE_FNAME);	/* be sure */
d346 1
a346 1
	if (!Fake && vsystem("./%s %s INSTALL", REQUIRE_FNAME, PkgName)) {
d358 1
a358 1
	vsystem("chmod +x %s", INSTALL_FNAME);	/* make sure */
d361 1
a361 1
	if (!Fake && vsystem("./%s %s PRE-INSTALL", INSTALL_FNAME, PkgName)) {
d380 1
a380 1
	    if (vsystem("mtree -q -U -f %s -d -e -p %s", MTREE_FNAME,
d391 1
a391 1
	if (!Fake && vsystem("./%s %s POST-INSTALL", INSTALL_FNAME, PkgName)) {
d429 1
a429 1
	vsystem("chmod a+rx %s", LogDir);
d479 1
a479 1
	if (stat(buf,&sbuf) == -1 || vsystem("%s %s", Pager, buf)) {
d518 1
a518 1
	if (vsystem("pkg_add %s%s %s%s",
d563 1
a563 1
	    } else if (vsystem("(pwd; cat %s) | pkg_add %s%s %s-S",
d698 1
a698 1
	    vsystem("%s -rf %s", REMOVE_CMD, LogDir);	/* XXX */
@


1.21
log
@even if this isn't KNF'd we still honour 80c
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.20 2007/03/30 23:20:10 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.20 2007/03/30 23:20:10 bsiegert Exp $");
d607 1
@


1.20
log
@Implement one of the points from my todo list: @@emul directives for
plists. If EMUL is set in a port's Makefile (e.g. EMUL=linux for a port
which needs linux emulation), this fact is entered into the package.
pkg_add checks for the relevant emulation.

- introduce new piperead() function, which executes a command and reads
  one line of output. Carefully crafted to avoid errors.
- new option for pkg_create: -e gives an initial value for @@emul
- bsd.port.mk: add -e to PKG_ARGS if EMUL given
- new function have_emulation(): Is the emulation enabled (via sysctl
  -n) or, alternatively, are we already running the "right" OS?
- pkg_info: show @@emul directive
- documentation: document EMUL and @@emul
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.19 2007/01/19 23:11:18 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.19 2007/01/19 23:11:18 bsiegert Exp $");
d284 3
a286 1
	    pwarnx("Package requires %s binary emulation layer, which is not enabled or not available! See the compat_%s(8) manpage for details.%s",
@


1.19
log
@Implement a new parameter: pkg_delete -C, will be used for pkg_upgrade IDC.

From the manpage:
     -C      Only delete configuration files that have the same checksum as
             the original file, i.e. those that have not been changed by the
             user.

agreed tg@@
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.18 2006/12/28 17:40:35 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.18 2006/12/28 17:40:35 bsiegert Exp $");
d276 15
@


1.18
log
@int install_dep_ftp() should always return an int, ideally 0 if there was
no error ...

Fixes installation of packages via network.

Bug found by tg@@ and Kabelaffe, thanks!
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.17 2006/12/26 15:37:26 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.17 2006/12/26 15:37:26 bsiegert Exp $");
d477 1
a477 1
	delete_package(false, false, false, false, &Plist);
@


1.17
log
@free() PkgDeps at the end of write_deps(). Actually, I had completely
forgotten the case where multiple package are installed in the same pkg_add
invocation. State must be restored, of course.

Bug found by tg@@, thanks!

This is the first commit from 23c3, Berlin! Yay!
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.16 2006/12/26 15:20:58 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.16 2006/12/26 15:20:58 tg Exp $");
d565 1
@


1.16
log
@prevent a memory leak, oops, my bad
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.15 2006/12/23 03:18:10 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.15 2006/12/23 03:18:10 tg Exp $");
d635 2
a636 1

@


1.15
log
@* add more (#if 0'd) debugging code
* within register_dep(), cut off .cgz (et al.) extension
  XXX can't modify second argument, only copy of it
  XXX what is first argument good for?
* within register_dep() also handle the "basename" stuff,
  otherwise +REQUIRED_BY is correct but +DEPENDS isn't;
  move basename() off write_deps();
  make the cutoff routine work on the return value
  of basename() which is a static buffer, so it's okay

fixes the issues described in
Message-ID: <Pine.BSM.4.64L.0612230205030.7882@@herc.mirbsd.org>
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.14 2006/12/23 02:36:15 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.14 2006/12/23 02:36:15 tg Exp $");
d601 2
a602 1
	else
d604 1
@


1.14
log
@simplify... I just couldn't let this code stand... sorry
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.13 2006/11/19 22:34:06 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.13 2006/11/19 22:34:06 tg Exp $");
d38 10
a47 1
static void register_dep(char *, char *);
d569 1
a569 1
register_dep(char *pkg, char *dep)
d576 22
d626 2
a627 2
	(void) snprintf(filename, sizeof(filename), "%s/%s/%s", dbdir,
			basename(cp), REQUIRED_BY_FNAME);
@


1.13
log
@whitespace at EOL sweep
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.12 2006/11/19 22:16:35 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.12 2006/11/19 22:16:35 bsiegert Exp $");
a562 2
    char buf[FILENAME_MAX];
    int len;
d567 1
a567 2
    if (!PkgDeps) {
	if (asprintf(&PkgDeps, "%s\n", dep) < 0) {
d570 1
a570 9
	}
    } else {
	(void) snprintf(buf, sizeof(buf), "%s\n", basename(dep));
	len = strlen(PkgDeps) + strlen(buf) + 1;
	if ((cp = (char *) realloc(PkgDeps, len)) == NULL) {
	    pwarnx("cannot allocate more memory for PkgDeps list!\n"
		    "dependency registration is incomplete");
	} else {
	    (void) strlcat(cp, buf, len);
a571 2
	}
    }
@


1.12
log
@Refactor write_deps() to use write_file(). Rewrite write_file() to accept
a mode argument and a format string, change other invocations accordingly.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.11 2006/11/19 13:14:29 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.11 2006/11/19 13:14:29 tg Exp $");
d251 1
a251 1
    
@


1.11
log
@const-cleanliness
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.10 2006/11/19 13:06:53 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.10 2006/11/19 13:06:53 bsiegert Exp $");
a592 1
    FILE *cfile;
d599 1
a599 9
    cfile = fopen(filename, "w");
    if (!cfile) {
	raise_privs();
	pwarn("cannot open dependency file '%s' for writing", filename);
	return;
    }
    fprintf(cfile, "%s", PkgDeps);
    if (fclose(cfile) == EOF)
	pwarn("cannot properly close file '%s'", filename);
d611 3
a613 11
	cfile = fopen(filename, "a");
	if (!cfile) {
	    raise_privs();
	    pwarn("can't open dependency file '%s'\n"
		   "dependency registration is incomplete", filename);
	} else {
	    fprintf(cfile, "%s\n", PkgName);
	    if (fclose(cfile) == EOF)
		pwarn("cannot properly close file '%s'", filename);
	    raise_privs();
	}
@


1.10
log
@Defer dependency registration until the end, i.e. write_deps(). If we stop with
an error before, we won't leave any stray dependencies.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.9 2006/11/13 21:49:53 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.9 2006/11/13 21:49:53 bsiegert Exp $");
d44 1
a44 1
static char *dbdir = NULL;
@


1.9
log
@Refactor the package installation code w.r.t. dependency handling, no
functional changes.

See wlog for more.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.8 2006/02/26 00:23:57 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.8 2006/02/26 00:23:57 bsiegert Exp $");
d558 1
a558 1
/* register a dependent package and add it to the internal depends list */
a564 1
    FILE *cfile;
d566 1
a566 1
    if (!pkg || !dep || !dbdir)
a568 3
    if (Verbose)
	printf("Attempting to record dependency on package '%s'\n", dep);

a584 15

    (void) snprintf(buf, sizeof(buf), "%s/%s/%s", dbdir, basename(dep),
		    REQUIRED_BY_FNAME);
    drop_privs();
    cfile = fopen(buf, "a");
    if (!cfile) {
	raise_privs();
	pwarnx("can't open dependency file '%s'!\n"
	       "dependency registration is incomplete", buf);
    } else {
	fprintf(cfile, "%s\n", PkgName);
	if (fclose(cfile) == EOF)
	    pwarnx("cannot properly close file '%s'", buf);
	raise_privs();
    }
d587 1
a587 1
/* write the dependencies of a package into its dbdir */
d592 1
d603 1
a603 1
	pwarnx("cannot open dependency file '%s' for writing", filename);
d608 1
a608 1
	pwarnx("cannot properly close file '%s'", filename);
d610 23
@


1.8
log
@Add support for dropping privileges in pkg_add.

Here is how it works: You have installed a MirPorts instance as user
(for example with Setup.sh -ule /path/to/prefix). Now if you install a
package under sudo, writes into the package database are done with the
privileges of the user, not with root rights. This means that there won't
be any problems with file permissions inside the package db.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.7 2005/11/15 19:33:56 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.7 2005/11/15 19:33:56 tg Exp $");
d36 5
d43 2
a88 1
    const char *dbdir;
a290 2
	    char path[FILENAME_MAX], *cp = NULL;

d292 4
a295 71
		if (!isURL(pkg) && !getenv("PKG_ADD_BASE")) {
		    /* install depending pkg from local disk */

		    snprintf(path, sizeof(path), "%s/%s", Home, ensure_tgz(p->name));
		    if (fexists(path))
			cp = path;
		    else
			cp = fileFindByPath(pkg, p->name);
		    if (cp) {
			if (Verbose)
			    printf("Loading it from '%s'\n", cp);
		        if (vsystem("pkg_add %s%s %s%s",
                                     Prefix ? "-p " : "",
                                     Prefix ? Prefix : "",
				     Verbose ? "-v " : "", cp)) {
			    pwarnx("autoload of dependency '%s' failed%s",
				cp, Force ? " (proceeding anyway)" : "!");
			    if (!Force)
				++code;
			}
		    }
		    else {
			pwarnx("add of dependency '%s' failed%s",
				p->name, Force ? " (proceeding anyway)" : "!");
			     if (!Force)
				++code;
		    }
		} else {
		    /* install depending pkg via FTP */

		    if (ispkgpattern(p->name)){
			pwarnx("can't install dependent pkg '%s' via FTP, "
			     "please install manually!", p->name);
			/* ... until we come up with a better solution - HF */
			goto bomb;
		    }else{
		    char *saved_Current;   /* allocated/set by save_dirs(), */
		    char *saved_Previous;  /* freed by restore_dirs() */

		    save_dirs(&saved_Current, &saved_Previous);

		    if ((cp = fileGetURL(pkg, p->name)) != NULL) {
			if (Verbose)
			    printf("Finished loading '%s' over FTP\n", p->name);
			system(solve_deps);
			if (!fexists(CONTENTS_FNAME)) {
			    pwarnx("autoloaded package '%s' has no %s file?",
				  p->name, CONTENTS_FNAME);
			    if (!Force)
				++code;
			}
			else if (vsystem("(pwd; cat %s) | pkg_add %s%s %s-S",
					 CONTENTS_FNAME,
					 Prefix ? "-p " : "",
					 Prefix ? Prefix : "",
					 Verbose ? "-v " : "")) {
			    pwarnx("add of dependency '%s' failed%s",
				  p->name, Force ? " (proceeding anyway)" : "!");
			    if (!Force)
				++code;
			}
			else if (Verbose)
			    printf("\t'%s' loaded successfully\n", p->name);
			/* Nuke the temporary playpen */
			leave_playpen(cp);
			free(cp);

			restore_dirs(saved_Current, saved_Previous);
		    }
		}
	    }
d305 4
a309 2
	else if (Verbose)
	    printf(" - '%s' already installed\n", insttst);
d424 1
a425 41
	/* register dependencies */
	/* we could save some cycles here if we remembered what we installed
	 * above (in case we got a wildcard dependency) */
	/* XXX remembering in p->name would NOT be good! */
	for (p = Plist.head; p ; p = p->next) {
	    if (p->type != PLIST_PKGDEP)
		continue;
	    if (Verbose)
		printf("Attempting to record dependency on package '%s'\n", p->name);
	    (void) snprintf(contents, sizeof(contents), "%s/%s", dbdir,
	    	    basename(p->name));
	    if (ispkgpattern(p->name)) {
		char *s;
		s=findbestmatchingname(dirname(contents),
				       basename(contents));
		if (s != NULL) {
		    char *t;
		    t=strrchr(contents, '/');
		    strlcpy(t+1, s, contents + sizeof(contents) - (t+1));
		    free(s);
		}else{
		    errx(1,"Where did our dependency go?!");
		    /* this shouldn't happen... X-) */
		}
	    }
	    strlcat(contents, "/", sizeof(contents));
	    strlcat(contents, REQUIRED_BY_FNAME, sizeof(contents));

	    drop_privs();
	    cfile = fopen(contents, "a");
	    if (!cfile) {
		raise_privs();
		pwarnx("can't open dependency file '%s'!\n"
		       "dependency registration is incomplete", contents);
	    } else {
		fprintf(cfile, "%s\n", PkgName);
		if (fclose(cfile) == EOF)
		    pwarnx("cannot properly close file '%s'", contents);
		raise_privs();
	    }
	}
d477 153
@


1.7
log
@crude U+0060 removal
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.6 2005/09/19 17:42:03 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.6 2005/09/19 17:42:03 tg Exp $");
d453 1
d458 1
d462 1
d470 1
d473 1
d480 1
d514 1
d516 2
a517 1
	    if (!cfile)
d520 1
a520 1
	    else {
d524 1
@


1.6
log
@remove absolute pathnames from mtree, less, more
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.5 2005/09/12 22:53:20 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.5 2005/09/12 22:53:20 tg Exp $");
d107 1
a107 1
	    pwarnx("add in SLAVE mode can't chdir to `%s'", playpen);
d125 1
a125 1
		pwarnx("unable to fetch `%s' by URL", pkg);
d134 1
a134 1
		"unable to open table of contents file `%s' - not a package?",
d163 1
a163 1
	"unable to extract table of contents from `%s'\n"
d172 1
a172 1
	"unable to open table of contents file `%s'\n"
d193 1
a193 1
		pwarnx("not extracting `%s'\ninto `%s', sorry!", pkg_fullname,
d201 1
a201 1
		pwarnx("unable to extract `%s'!", pkg_fullname);
d268 1
a268 1
	    printf("Package `%s' conflicts with `%s'\n", PkgName, p->name);
d283 1
a283 1
	    printf("Package `%s' depends on `%s'\n", PkgName, p->name);
d298 1
a298 1
			    printf("Loading it from `%s'\n", cp);
d303 1
a303 1
			    pwarnx("autoload of dependency `%s' failed%s",
d310 1
a310 1
			pwarnx("add of dependency `%s' failed%s",
d331 1
a331 1
			    printf("Finished loading `%s' over FTP\n", p->name);
d334 1
a334 1
			    pwarnx("autoloaded package `%s' has no %s file?",
d344 1
a344 1
			    pwarnx("add of dependency `%s' failed%s",
d350 1
a350 1
			    printf("\t`%s' loaded successfully\n", p->name);
d363 1
a363 1
		    printf("Package dependency `%s' for `%s' not found%s\n", p->name, pkg,
d370 1
a370 1
	    printf(" - `%s' already installed\n", insttst);
d380 1
a380 1
	    printf("Running requirements file first for `%s'\n", PkgName);
d382 1
a382 1
	    pwarnx("package `%s' fails requirements %s", pkg_fullname,
d395 1
a395 1
	    printf("Running install with PRE-INSTALL for `%s'\n", PkgName);
d408 1
a408 1
	    printf("Running mtree for `%s'\n", PkgName);
d425 1
a425 1
	    printf("Running install with POST-INSTALL for `%s'\n", PkgName);
d452 1
a452 1
	    printf("Attempting to record package into `%s'\n", LogDir);
d488 1
a488 1
		printf("Attempting to record dependency on package `%s'\n", p->name);
d515 1
a515 1
		    pwarnx("cannot properly close file `%s'", contents);
d519 1
a519 1
	    printf("Package `%s' registered in `%s'\n", PkgName, LogDir);
d575 1
a575 1
	pwarnx("package `%s' has no CONTENTS file!", pkg);
d579 1
a579 1
	pwarnx("package `%s' has no COMMENT file!", pkg);
d583 1
a583 1
	pwarnx("package `%s' has no DESC file!", pkg);
@


1.5
log
@join tg-ports-devel branch into HEAD
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.4.2.1 2005/09/11 02:04:03 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.4.2.1 2005/09/11 02:04:03 tg Exp $");
d415 1
a415 1
	    if (vsystem("/usr/sbin/mtree -q -U -f %s -d -e -p %s", MTREE_FNAME,
d532 1
a532 1
		Pager = "/usr/bin/less";
d541 1
a541 1
		Pager = "/usr/bin/more";
@


1.4
log
@IMPORTANT BUGFIX: Overhaul version number handling to take into account the
fact that version numbers might have hyphens in them. Before, a package
"gs-fonts-std-8.11-0" conflicted only with "gs-fonts-std-8.11-*", which is
not what you want. Not it is "gs-fonts-std-*".

Thus, the policy is: version numbers always begin with a digit, i.e. the
first occurrence of "-[0-9]" in the pkgname is the version.

bug report by and agreed tg@@
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.3 2005/06/26 17:13:43 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.3 2005/06/26 17:13:43 tg Exp $");
d263 1
a263 1
	char installed[FILENAME_MAX];
d270 2
a271 2
	if(findmatchingname(dbdir, p->name, check_if_installed, installed, sizeof(installed))){
	    pwarnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!",  installed);
d278 1
a278 1
	char installed [FILENAME_MAX];
d284 1
a284 1
	if (!findmatchingname(dbdir, p->name, check_if_installed, installed, sizeof(installed))) {
d370 1
a370 1
	    printf(" - `%s' already installed\n", installed);
d440 1
a440 1
#ifndef __INTERIX
@


1.4.2.1
log
@* -#ifndef __INTERIX
  +#ifndef AS_USER
       if (!Fake && getuid() != 0)
          errx(1, "you must be root to delete packages");
   #endif
  and similar
* make compile with __CRAZY=Yes

bsiegert@@ please look at this diff closely
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.4 2005/06/29 17:20:17 bsiegert Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.4 2005/06/29 17:20:17 bsiegert Exp $");
d263 1
a263 1
	char insttst[FILENAME_MAX];
d270 2
a271 2
	if(findmatchingname(dbdir, p->name, check_if_installed, insttst, sizeof(insttst))){
	    pwarnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!",  insttst);
d278 1
a278 1
	char insttst[FILENAME_MAX];
d284 1
a284 1
	if (!findmatchingname(dbdir, p->name, check_if_installed, insttst, sizeof(insttst))) {
d370 1
a370 1
	    printf(" - `%s' already installed\n", insttst);
d440 1
a440 1
#ifndef AS_USER
@


1.3
log
@overhaul pager logic, make cat(1) default since we display them
after each package, not one at the end
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.2 2005/05/21 01:58:41 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.2 2005/05/21 01:58:41 tg Exp $");
d80 1
d244 2
a245 4
    {
	char buf[FILENAME_MAX];
	char installed[FILENAME_MAX];
	char *s;
d247 9
a255 22
	if ((s=strrchr(PkgName, '-')) != NULL){
	    strlcpy(buf, PkgName, sizeof(buf));
	    /* try to find a better version number */
	    if (!isdigit(s[1])) {
	    	char *t;
		for (t = s-1; t >= PkgName; t--)
			if (*t == '-' && isdigit(t[1])) {
				s = t;
				break;
			}
	    }
	    strlcpy(buf+(s-PkgName+1), isdigit(s[1]) ? "[0-9]*" : "*", sizeof(buf)-(s-PkgName+1));

            if (findmatchingname(dbdir, buf, check_if_installed, installed, sizeof(installed))) {
		pwarnx("other version '%s' already installed", installed);
	    	if (find_plist_option(&Plist, "no-default-conflict") != NULL) {
		    pwarnx("proceeding with installation anyway");
		} else {
		    code = 1;
		    goto success;	/* close enough for government work */
		}
	    }
d258 2
d540 2
a542 2
	if (Pager == NULL)
	    Pager = "/usr/bin/more";
@


1.2
log
@don't warn (about root) on Interix
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/add/perform.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $");
a549 1
	    default:
d558 1
a558 1
	    pwarnx("cannot open `%s' as display file", buf);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS$ */
d32 1
a32 1
__RCSID("$MirOS$");
d452 1
d455 1
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@
