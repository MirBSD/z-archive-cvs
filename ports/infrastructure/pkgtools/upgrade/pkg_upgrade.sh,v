head	1.41;
access;
symbols
	bsiegert-cfgfile_BASE:1.40
	bsiegert-cfgfile:1.40.0.2
	MIRBSD_8_BASE:1.10;
locks; strict;
comment	@# @;


1.41
date	2017.07.20.21.15.55;	author tg;	state Exp;
branches;
next	1.40;
commitid	10059711D89780CE021;

1.40
date	2009.11.22.15.34.16;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004B0959E8012B753D;

1.39
date	2009.03.29.13.04.06;	author tg;	state Exp;
branches;
next	1.38;
commitid	10049CF71B654F9EF54;

1.38
date	2008.11.11.02.50.09;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004918F2E56B329425;

1.37
date	2008.11.08.23.03.43;	author tg;	state Exp;
branches;
next	1.36;
commitid	10049161AC72620EAF0;

1.36
date	2008.10.12.15.35.23;	author tg;	state Exp;
branches;
next	1.35;
commitid	10048F218B2228D17F9;

1.35
date	2008.10.12.15.29.18;	author tg;	state Exp;
branches;
next	1.34;
commitid	10048F217E23405BB68;

1.34
date	2008.10.12.15.28.49;	author tg;	state Exp;
branches;
next	1.33;
commitid	10048F217AF04EEDFFE;

1.33
date	2008.10.05.16.10.06;	author tg;	state Exp;
branches;
next	1.32;
commitid	10048E8E6E26536FCB9;

1.32
date	2008.10.05.01.17.54;	author tg;	state Exp;
branches;
next	1.31;
commitid	10048E815CC6D73DA24;

1.31
date	2008.03.24.22.10.58;	author tg;	state Exp;
branches;
next	1.30;
commitid	10047E826F31482F9D3;

1.30
date	2007.08.16.12.28.39;	author tg;	state Exp;
branches;
next	1.29;
commitid	10046C4423B68CEF0CA;

1.29
date	2007.07.22.19.48.01;	author bsiegert;	state Exp;
branches;
next	1.28;
commitid	10046A3B4774E64DB09;

1.28
date	2007.05.14.03.58.22;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004647DE0A0CA58022;

1.27
date	2007.05.09.17.25.03;	author tg;	state Exp;
branches;
next	1.26;
commitid	100464203EB5EFBB32F;

1.26
date	2007.04.01.00.30.10;	author tg;	state Exp;
branches;
next	1.25;
commitid	100460EFD1439F374BB;

1.25
date	2007.04.01.00.05.22;	author tg;	state Exp;
branches;
next	1.24;
commitid	100460EF7595E566F40;

1.24
date	2007.03.31.20.45.08;	author tg;	state Exp;
branches;
next	1.23;
commitid	100460EC82323031E80;

1.23
date	2007.03.08.10.55.15;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045EFEBA7793E13E8;

1.22
date	2007.01.22.18.39.15;	author bsiegert;	state Exp;
branches;
next	1.21;
commitid	10045B504BD11C06B2C;

1.21
date	2006.12.11.21.26.17;	author tg;	state Exp;
branches;
next	1.20;
commitid	100457DCCF63BA9B71C;

1.20
date	2006.09.20.22.24.49;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004511BFAD3427E1F6;

1.19
date	2006.08.22.20.50.49;	author bsiegert;	state Exp;
branches;
next	1.18;
commitid	10044EB69D9519BD195;

1.18
date	2006.08.11.22.24.20;	author bsiegert;	state Exp;
branches;
next	1.17;
commitid	10044DD03662D054C80;

1.17
date	2006.02.20.21.10.12;	author tg;	state Exp;
branches;
next	1.16;
commitid	10043FA303D186D08EF;

1.16
date	2006.02.20.21.08.56;	author tg;	state Exp;
branches;
next	1.15;
commitid	10043FA2FD912809687;

1.15
date	2006.02.20.21.06.43;	author tg;	state Exp;
branches;
next	1.14;
commitid	10043FA2EDC0FE0FCE6;

1.14
date	2006.02.20.20.56.08;	author tg;	state Exp;
branches;
next	1.13;
commitid	10043FA2CE602773EE3;

1.13
date	2006.01.17.22.57.00;	author tg;	state Exp;
branches;
next	1.12;
commitid	10043CD764F03D4A1A6;

1.12
date	2006.01.17.22.54.17;	author tg;	state Exp;
branches;
next	1.11;
commitid	10043CD75AB1651C652;

1.11
date	2006.01.17.22.52.29;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043CD753A6A35A1B8;

1.10
date	2005.12.18.16.36.43;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043A58BE830AFB807;

1.9
date	2005.12.18.05.40.16;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043A4F61A25509D86;

1.8
date	2005.12.16.16.41.04;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A2EE162412A5B6;

1.7
date	2005.12.16.16.34.35;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A2ECAC49B71056;

1.6
date	2005.12.16.15.14.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043A2D9D1169FB804;

1.5
date	2005.11.19.02.05.30;	author bsiegert;	state Exp;
branches;
next	1.4;
commitid	6633437e87d6af88;

1.4
date	2005.09.13.10.58.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	77d4326b0de5995;

1.3
date	2005.09.12.22.59.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	515c4326087549fe;

1.2
date	2005.09.12.22.53.28;	author tg;	state Exp;
branches;
next	1.1;
commitid	6e6c432606e897b6;

1.1
date	2005.08.21.13.02.59;	author bsiegert;	state Exp;
branches
	1.1.2.1;
next	;
commitid	2da143087ac3e9dd;

1.1.2.1
date	2005.08.21.13.02.59;	author tg;	state dead;
branches;
next	1.1.2.2;
commitid	2f08432382e315cf;

1.1.2.2
date	2005.09.11.01.05.45;	author tg;	state Exp;
branches;
next	;
commitid	2f08432382e315cf;


desc
@@


1.41
log
@.lz and .tlz are claimed by lzip, drop most LZMA-Alone support
(one thing in which Lasse and Antonio agree)
@
text
@#!/bin/mksh
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.39 2009/03/29 13:04:06 tg Exp $
#-
# Copyright (c) 2006, 2007, 2008, 2009
#	Thorsten Glaser <tg@@mirbsd.de>
# Copyright (c) 2005, 2007
#	Benny Siegert <bsiegert@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# wrapper for pkg_add to upgrade packages

me=${0##*/}
cwd=$(realpath .)

function usage {
	print -u2 Usage:
	print -u2 "\t$me [-afqsv] pkgname.cgz"
	exit 1
}

function twiddle_plists {
	export oldcontents newcontents stubfiles
	awk '
	BEGIN {
		oldcontents = ENVIRON["oldcontents"]
		newcontents = ENVIRON["newcontents"]
		stubfiles = ENVIRON["stubfiles"]
		lib_seen = 0
	}

	function handle_lib(name) {
		if (FILENAME==newcontents) {
			# first mode: collect libraries
			shlibs[name] = "new"
		} else {
			# second mode: distribute them
			if (shlibs[name]=="new") {
				print
			} else {
				print >> stubfiles
				lib_seen = 1
			}
		}
	}

	$1=="@@lib"		{ handle_lib($2) ; next }
	/^[^@@].*\.dylib$/	{ handle_lib($0) ; next }

	{
		if (FILENAME==oldcontents) {
			if (lib_seen==1 && $1=="@@comment" && $2~/^MD5:/)
				print >> stubfiles
			else
				print
		}
		lib_seen = 0
	}' $newcontents $oldcontents > $oldcontents_new
}

function build_stub {
	print -u2 "$me: building stub package shlibs-$OLDPKGS"
	stubpkgdir=$TMPDIR/shlibs-$OLDPKGS
	oldpkgdir=$PKG_DBDIR/$OLDPKGS
	stubcontents=$stubpkgdir/+CONTENTS
	newcontents=$TMPDIR/+CONTENTS

	mkdir $stubpkgdir
	echo -n "shared libraries stub: " > $stubpkgdir/+COMMENT
	cat $oldpkgdir/+COMMENT >> $stubpkgdir/+COMMENT
	cp $oldpkgdir/+DESC $stubpkgdir
	[[ -f $TMPDIR/+REQUIRED_BY ]] && cp $TMPDIR/+REQUIRED_BY $stubpkgdir
	[[ -f $TMPDIR/+DEPENDS ]] && cp $TMPDIR/+DEPENDS $stubpkgdir

	echo "@@name shlibs-$OLDPKGS" > $stubcontents
	echo "@@pkgdep $PKGNAME" >> $stubcontents
	# only the first @@cwd
	awk '$1=="@@cwd" { print ; exit }' $oldcontents >> $stubcontents
	grep '^@@option ' $oldcontents >> $stubcontents
	cat $stubfiles >> $stubcontents
	# ldconfig invocations too
	fgrep exec $oldcontents | fgrep ldconfig >> $stubcontents
	echo >> $stubcontents << EOF
@@cwd .
@@ignore
+COMMENT
@@ignore
+DESC
EOF

	# Register dependencies of the stub
	[[ -f $stubpkgdir/+DEPENDS ]] && while read package; do
		if [[ -d $PKG_DBDIR/$package ]]; then
			print -r -- "shlibs-$OLDPKGS" >> $PKG_DBDIR/$package/+REQUIRED_BY
#			print -u2 -r "Debug: Dependency of shlibs-$OLDPKGS on $package successully registered"
		else
			print -u2 -r "Warning: Dependency $package missing!"
		fi
	done < $stubpkgdir/+DEPENDS

	# Register the package
	mv -f $stubpkgdir $PKG_DBDIR
	mv -f $oldcontents_new $oldcontents
}


######################################################################

auto=0
force=0
quiet=0
stubs=0
fv=
while getopts "afhqsv" option; do
	case $option {
	(a)	auto=1 ;;
	(f)	force=1 ;;
	(h)	usage ;;
	(q)	quiet=1 ;;
	(s)	stubs=1 ;;
	(v)	fv=-v ;;
	(*)	usage ;;
	}
done
shift $((OPTIND - 1))
[[ -n $1 ]] || usage
npkg=$(realpath "$1")

PKG_DBDIR=@@@@dbdir@@@@/pkg
if [[ ! -d $PKG_DBDIR ]]; then
	print -u2 "$me: package database directory does not exist"
	exit 1
fi

if [[ ! -s $npkg ]]; then
	print -u2 "$me: package file '$1' does not exist"
	exit 1
fi

TMPDIR=$(mktemp -d /tmp/pkg_upgrade.XXXXXXXXXX) || exit 1
trap 'rm -rf $TMPDIR; exit 0' 0
trap 'rm -rf $TMPDIR; exit 1' 1 2 3 5 13 15

cd $TMPDIR
case $npkg {
(*.cxz)
	xzdec <"$npkg" ;;
(*.*([!.])z*([!.]))
	gzip -fdc "$npkg" ;;
(*)
	cat "$npkg" ;;
} | tar xf - +CONTENTS
cd $PKG_DBDIR
PKGNAME=$(awk '$1=="@@name" { print $2 }' $TMPDIR/+CONTENTS)
OLDPKGS=$(echo ${PKGNAME%%-[0-9]*}-[0-9]*)
[[ $OLDPKGS = ?(${PKGNAME%%-[0-9]*})@@(-\[0-9\]\*) ]] && OLDPKGS=
if [[ $auto = 1 && -z "$OLDPKGS" ]]; then
	[[ $quiet = 1 ]] || print -u2 "$me: ignoring uninstalled package '${1##*/}'"
	exit 0
fi
cd $cwd

grep -q '^@@option no-default-conflict' $TMPDIR/+CONTENTS
if [[ $? -eq 0 || ( -z $OLDPKGS && $force = 1) ]]; then
	OLDPKGS=
	while read cmd arg rest; do
		[[ $cmd = @@pkgcfl ]] || continue
		OLDPKGS=$(pkg_info -e "$arg")
		[[ -z $OLDPKGS ]] || break
	done <$TMPDIR/+CONTENTS
fi

if [[ -z "$OLDPKGS" ]]; then
	# we can safely go on
	[[ $quiet = 1 ]] || print -u2 "$me: adding previously uninstalled '${1##*/}'"
	rm -rf $TMPDIR
	exec pkg_add $fv "$npkg"
fi

if [[ $OLDPKGS = *[$IFS]* ]]; then
	print -u2 "$me: More than one package would have to be deleted in order"
	print -u2 "to install ${1##*/}. This is not supported in this version."
	print -u2 "The packages in question are:"
	print -u2 "$OLDPKGS"
	exit 1
fi

# Check if we try to re-install same-version packages
NEWPKG=${1##*/}
if [[ $OLDPKGS = ${NEWPKG%.+([a-zA-Z])} && $force = 0 ]]; then
	[[ $quiet = 1 ]] || print -u2 "$me: package $OLDPKGS is already installed, ignoring"
	exit 0
fi

print -u2 "$me: will remove $OLDPKGS in favour of ${1##*/}"

# save forward and reverse dependency information
for f in +DEPENDS +REQUIRED_BY; do
	[[ -f $PKG_DBDIR/$OLDPKGS/$f ]] && \
	    mv -f $PKG_DBDIR/$OLDPKGS/$f $TMPDIR/
done

fd=
fa=
if grep -qi '^@@comment upgrade-no-scripts' $TMPDIR/+CONTENTS; then
	fd=-D
	fa=-I
fi
if grep -qi '^@@comment upgrade-no-install-script' $TMPDIR/+CONTENTS; then
	fa=-I
fi
if grep -qi '^@@comment upgrade-no-deinstall-script' $TMPDIR/+CONTENTS; then
	fd=-D
fi

# Check for shared libraries
newcontents=$TMPDIR/+CONTENTS			# package to be installed
oldcontents=$PKG_DBDIR/$OLDPKGS/+CONTENTS	# older, installed version
oldcontents_new=$TMPDIR/+CONTENTS-$OLDPKGS	# new version of oldcontents
stubfiles=$TMPDIR/+STUB				# files to put into shlibs stub

[[ $stubs = 1 ]] && twiddle_plists

if grep -qi '^@@option base-package' $TMPDIR/+CONTENTS; then
	print -u2 "$me: '$OLDPKGS' is a base package, unregistering only"
	pkg_delete $fv $fd -C -U $OLDPKGS && pkg_add $fv $fa -Nq "$npkg"
else
	[[ $stubs = 1 && -s $stubfiles ]] && build_stub
	pkg_delete $fv -C $fd $OLDPKGS && pkg_add $fv $fa "$npkg"
fi

# forward dependency information of backward dependencies of old package
[[ -f $TMPDIR/+DEPENDS ]] && while read package; do
	if [[ -e $PKG_DBDIR/$package/+REQUIRED_BY ]]; then
		print "%g/^$OLDPKGS\$/d\nwq" | \
		    ed -s $PKG_DBDIR/$package/+REQUIRED_BY
		# and add new version if we deleted the one from pkg_add
		if ! grep "^$PKGNAME\$" $PKG_DBDIR/$package/+REQUIRED_BY \
		    >/dev/null 2>&1; then
			print -r -- "$PKGNAME" \
			    >>$PKG_DBDIR/$package/+REQUIRED_BY
#			print -u2 "Debug: dependency on $package of" \
#			    "$PKGNAME successfully added"
		fi
	else
		print -u2 "Notice: Dependency $package of $OLDPKGS" \
		    "was not found there (backward)"
	fi
done <$TMPDIR/+DEPENDS

# backward dependency information of forward dependencies of old package
[[ -f $TMPDIR/+REQUIRED_BY ]] && while read package; do
	if [[ -e $PKG_DBDIR/$package/+DEPENDS ]]; then
		# remove old version of this package from there
		if grep "^$OLDPKGS\$" $PKG_DBDIR/$package/+DEPENDS \
		    >/dev/null 2>&1; then
			print "%g/^$OLDPKGS\$/d\nwq" | ed -s \
			    $PKG_DBDIR/$package/+DEPENDS
#			print -u2 "Debug: dependency of $package on" \
#			    "$OLDPKGS successfully removed"
		else
			print -u2 "Notice: $package was not registered" \
			    "as forward dependency of $OLDPKGS"
		fi
		# and add new version (at the bottom, but that's irrelevant)
		print -r -- "$PKGNAME" >>$PKG_DBDIR/$package/+DEPENDS
#		print -u2 "Debug: dependency of $package on" \
#		    "$PKGNAME successfully added"
	else
		print -u2 "Notice: Dependency of $package on $OLDPKGS" \
		    "was not found there (forward)"
	fi
done <$TMPDIR/+REQUIRED_BY

# forward dependency information: +DEPENDS created by pkg_add

# backward dependency information: same for old and new package
if [[ -f $TMPDIR/+REQUIRED_BY ]]; then
	mkdir -p $PKG_DBDIR/$PKGNAME
	mv $TMPDIR/+REQUIRED_BY $PKG_DBDIR/$PKGNAME/
fi
@


1.40
log
@support for the upcoming XZ Utils compression
planned for long, prodded by bsiegert@@
@
text
@a160 2
(*.clz)
	lzmadec <"$npkg" ;;
@


1.39
log
@â€¢ take care of dbins
â€¢ #!/bin/mksh shebang, in most places
â€¢ rcsid while here
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.38 2008/11/11 02:50:09 tg Exp $
d4 1
a4 1
# Copyright (c) 2006, 2007, 2008
d159 2
@


1.38
log
@use lzmadec not lzma to decompress; mention PKG_SUFX while here
@
text
@d1 2
a2 2
#!/usr/bin/env mksh
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.37 2008/11/08 23:03:43 tg Exp $
@


1.37
log
@more mass conversions, including ancient eMail addresses
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.36 2008/10/12 15:35:23 tg Exp $
d160 1
a160 1
	lzma -dc "$npkg" ;;
d162 1
a162 1
	gzip -dc "$npkg" ;;
@


1.36
log
@Support for LZMA compressed binary packages (experimental!)

Tested:
â€¢ tg@@bleu:/usr/ports/archivers/mpczar $ mmake PKG_SUFX=.clz install clean
â€¢ tg@@bleu:~ $ sudo pkg_upgrade -fva /usr/ports/Packages/ssfe-20070109-1.clz

Dependencies on LZMA are *not* handled automatically, also you must use
PKG_SUFX=.clz to enable and ensure lzma is installed prior. This is some-
what hacky, but our package tools suck anyway. The infrastructure allows
for other compressors such as bzip2 too (but that one is not much of a
saving compared to lzma (ratio) and gzip (resource usage) so I did *not*
add it), but in a *lot* of placesâ€¦ should unify that or better, rewrite
all of the package tools in mkshâ€¦ anyway, please test.
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.35 2008/10/12 15:29:18 tg Exp $
d7 1
a7 1
#	Benny Siegert <bsiegert@@66h.42h.de>
@


1.35
log
@oops, forgot one change
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.34 2008/10/12 15:28:49 tg Exp $
d158 8
a165 1
tar xfz "$npkg" +CONTENTS
@


1.34
log
@â€¢ pkg_upgrade.1: switch to portmdoc and $Mdocdate
â€¢ pkg_upgrade.1: document -s
â€¢ all: add -v option
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.33 2008/10/05 16:10:06 tg Exp $
d127 1
a127 1
while getopts "afhqs" option; do
@


1.33
log
@we have required a pretty up-to-date mksh for a while,
so make use of the â€œrealpathâ€ builtin
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.32 2008/10/05 01:17:54 tg Exp $
d29 1
a29 2
function usage
{
d31 1
a31 1
	print -u2 "\t$me [-afqs] pkgname.cgz"
d35 1
a35 2
function twiddle_plists
{
d74 1
a74 2
function build_stub
{
d126 1
d134 1
d183 1
a183 1
	exec pkg_add "$npkg"
d232 1
a232 1
	pkg_delete $fd -C -U $OLDPKGS && pkg_add $fa -Nq "$npkg"
d235 1
a235 1
	pkg_delete -C $fd $OLDPKGS && pkg_add $fa "$npkg"
@


1.32
log
@always record dependency information, for if pkg_add part of pkg_upgrade
fails
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.31 2008/03/24 22:10:58 tg Exp $
d27 1
a27 1
cwd=$(readlink -nf .)
d141 1
a141 1
npkg="$(readlink -nf "$1")"
@


1.31
log
@replace awk(1) call by something
â€¢ entirely written in mksh(1), i.e. UNDERSTANDABLE
â€¢ which actually works

more to followâ€¦
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.30 2007/08/16 12:28:39 tg Exp $
d4 1
a4 1
# Copyright (c) 2006, 2007
d285 3
a287 2
if [[ -f $TMPDIR/+REQUIRED_BY && -d $PKG_DBDIR/$PKGNAME ]]; then
	mv $TMPDIR/+REQUIRED_BY $PKG_DBDIR/$PKGNAME
@


1.30
log
@change upgrade semantics by request of bsiegert@@
â€¢ â€œmmake upgradeâ€: if not installed, install, else upgrade if not same version
â€¢ â€œmmake reupgradeâ€: if installed, upgrade even if same version

also make clear that an already installed package is not an error
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.29 2007/07/22 19:48:01 bsiegert Exp $
d172 6
a177 1
	OLDPKGS=$(awk '$1=="@@pkgcfl" { system("pkg_info -e " $2) }' $TMPDIR/+CONTENTS)
@


1.29
log
@Implement handling of @@pkgcfl for packages with @@option
no-default-conflict. Fixes for example the case of "pkg_upgrade
autoconf-2.61-0.cgz".

If -f is given, also remove _other_ conflicting packages. Example: if
foo conflicts with bar and bar is installed, "pkg_upgrade -f foo" will
remove bar first.
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.28 2007/05/14 03:58:22 tg Exp $
d193 1
a193 1
	[[ $quiet = 1 ]] || print -u2 "$me: package $OLDPKGS is already installed"
@


1.28
log
@â€¢ don't complain if some information isn't in a file which is only there
  if the old and new package version are the same, after the recent re-
  shuffling of package db mangling the pkgtools do it for us in all other
  cases
â€¢ don't do a 'grep foo bar && print "%g/foo/d\nwq" | ed -s bar' here,
  just do the print|ed part, since grep probably isn't faster anyway
  (XXX do this for the other cases inside the file too)
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.27 2007/05/09 17:25:03 tg Exp $
d164 1
a164 1
if [[ $auto = 1 && -z $OLDPKGS ]]; then
d171 5
a175 1
if [[ $? -eq 0 || -z "$OLDPKGS" ]]; then
d182 3
a184 3
if [[ $OLDPKGS = *\ * ]]; then
	print -u2 "$me: multiple previous versions of this package are"
	print -u2 "installed. This is not supported in this version."
d192 4
a195 1
[[ $OLDPKGS = ${NEWPKG%.+([a-zA-Z])} && $force = 0 ]] && exit 0
@


1.27
log
@rename $OLDPWD to $cwd

$OLDPWD seems to be automatically set by the shell, WTF? (it's even in TFM)
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.26 2007/04/01 00:30:10 tg Exp $
d230 2
a231 10
		if grep "^$OLDPKGS\$" $PKG_DBDIR/$package/+REQUIRED_BY \
		    >/dev/null 2>&1; then
			print "%g/^$OLDPKGS\$/d\nwq" | ed -s \
			    $PKG_DBDIR/$package/+REQUIRED_BY
#			print -u2 "Debug: dependency of $OLDPKGS on" \
#			    "$package successfully removed"
		else
			print -u2 "Notice: $OLDPKGS was not registered" \
			    "as backward dependency of $package"
		fi
@


1.26
log
@of $OLDPKGS == $PKGNAME, <all dependencies>/+REQUIRED_BY was missing $PKGNAME
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.25 2007/04/01 00:05:22 tg Exp $
d27 1
a157 1
OLDPWD=$PWD
d168 1
a168 1
cd $OLDPWD
@


1.25
log
@add distinguishors
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.24 2007/03/31 20:45:08 tg Exp $
d108 1
a108 1
		if [[ -d $PKG_DBDIR/$package ]] ; then
d143 1
a143 1
if [[ ! -d $PKG_DBDIR ]] ; then
d154 2
a155 2
trap 'rm -rf $TMPDIR ; exit 0' 0
trap 'rm -rf $TMPDIR ; exit 1' 1 2 3 5 13 15
d227 1
a227 3
# forward dependency information of old package
# only remove old information here; new information was
# already entered into */+REQUIRED_BY by the pkg_add above
d232 1
a232 1
			print "/^$OLDPKGS\$/d\nwq" | ed -s \
d240 8
d260 1
a260 1
			print "/^$OLDPKGS\$/d\nwq" | ed -s \
d278 2
d281 1
a281 1
if [[ -f $TMPDIR/+REQUIRED_BY && -d $PKG_DBDIR/$PKGNAME ]] ; then
@


1.24
log
@â€¢ I'm convinced this works good enough
  â€• remove the comment that this is a rapid prototype, I don't think we'll
    be reÃ¯mplementing this in C any time soon, even if that would be better
  â€• remove (comment out) debugging stuff
â€¢ whitespace cleanup (!)
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.23 2007/03/08 10:55:15 tg Exp $
d240 1
a240 1
			    "as dependency of $package"
d260 1
a260 1
			    "as dependency of $OLDPKGS"
@


1.23
log
@sync licence years
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.22 2007/01/22 18:39:15 bsiegert Exp $
d4 1
a4 1
# Copyright (c) 2006
a24 2
# This is only a "rapid prototype", the final implementation might
# be as a part of pkg_add.
d110 1
a110 1
			print -u2 -r "Debug: Dependency of shlibs-$OLDPKGS on $package successully registered"
d115 1
a115 1
	
d236 2
a237 4
			# this line will die once this code is tested
			# in production for a while...
			print -u2 "Debug: dependency of $OLDPKGS on" \
			    "$package successfully removed"
d256 2
a257 4
			# this line will die once this code is tested
			# in production for a while...
			print -u2 "Debug: dependency of $package on" \
			    "$OLDPKGS successfully removed"
d264 2
a265 2
		print -u2 "Debug: dependency of $package on" \
		    "$PKGNAME successfully added"
@


1.22
log
@Use pkg_delete -C for pkg_upgrade, untested (but -C itself is tested,
obviously).

prodded by tg@@
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.21 2006/12/11 21:26:17 tg Exp $
d6 1
a6 1
# Copyright (c) 2005
@


1.21
log
@* handle +DEPENDS forward and backward on upgrades
* sync licence to latest plate

asked for and ok to commit (both) bsiegert@@
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.20 2006/09/20 22:24:49 tg Exp $
d90 1
d108 10
d223 1
a223 1
	pkg_delete $fd -U $OLDPKGS && pkg_add $fa -Nq "$npkg"
d226 1
a226 1
	pkg_delete $fd $OLDPKGS && pkg_add $fa "$npkg"
@


1.20
log
@catch signal 5 too, idea from original lynx "oldlynx" sample script, thanks TD
while here, update licences where I can
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.19 2006/08/22 20:50:49 bsiegert Exp $
d9 5
a13 6
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publicly perform, modify,
# merge, distribute, sell, give away or sublicence, provided all co-
# pyright notices above, these terms and the disclaimer are retained
# in all redistributions or reproduced in accompanying documentation
# or other materials provided with binary redistributions.
d15 8
a22 7
# Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
# any kind, expressed or implied, to the maximum extent permitted by
# applicable law, but with the warranty of being written without ma-
# licious intent or gross negligence; in no event shall licensor, an
# author or contributor be held liable for any damage, direct, indi-
# rect or other, however caused, arising in any way out of the usage
# of this work, even if advised of the possibility of such damage.
d183 5
a187 3
if [[ -f $PKG_DBDIR/$OLDPKGS/+REQUIRED_BY ]] ; then
	mv -f $PKG_DBDIR/$OLDPKGS/+REQUIRED_BY $TMPDIR
fi
d218 50
@


1.19
log
@Tentatively add Mac OS X support for shared library stubs, using a similar
regexp to the libtoolise_plist stuff
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.16 2006/02/20 21:08:56 tg Exp $
d146 1
a146 1
trap 'rm -rf $TMPDIR ; exit 1' 1 2 3 13 15
@


1.18
log
@Add shared library support from the last patch. Usual caveats apply.
Note that this is only enabled if you use pkg_upgrade -s, not by default.
@
text
@d48 1
a48 1
	$1=="@@lib" {
d51 1
a51 1
			shlibs[$2] = "new"
d54 1
a54 1
			if (shlibs[$2]=="new") {
a60 1
		next
d63 3
@


1.17
log
@add @@comment upgrade-no-install-script/upgrade-no-deinstall-script support
@
text
@d33 1
a33 1
	print -u2 "\t$me [-afq] pkgname.cgz"
d37 76
d116 2
a117 1
while getopts "afhq" option; do
d123 1
a158 3
#XXX what does this do?
#if grep -q '^@@option no-default-conflict' $TMPDIR/+CONTENTS || [[ -z "$OLDPKGS" ]] ; then
#XXX for now:
d198 8
d210 1
@


1.16
log
@check for '@@comment upgrade-no-scripts' in base packages too,
execute both sort of scripts if not set

previously, base packages would only execute the install scripts
but not the deinstall scripts. now you can count with the behaviour.
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.15 2006/02/20 21:06:43 tg Exp $
d110 2
d115 6
a120 3
else
	fd=
	fa=
@


1.15
log
@* pkg_upgrade: if an option is set in the PLIST of the new package,
  do not execute the (de|un)install or install scripts
* linux-common: use it, bump patchlevel
* pkg_upgrade: check for @@option base-package as well in the PLIST
  of the _new_ package instead of the old package
* pkg_upgrade: if "upgrading" a previously uninstalled package,
  clean up the tmpdir appropriately
* pkg_upgrade: don't execute scripts for base packages either
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.14 2006/02/20 20:56:08 tg Exp $
d110 8
d120 1
a120 3
	pkg_delete -DU $OLDPKGS && pkg_add -INq "$npkg"
elif grep -qi '^@@comment upgrade-no-scripts' $TMPDIR/+CONTENTS; then
	pkg_delete -D $OLDPKGS && pkg_add -I "$npkg"
d122 1
a122 1
	pkg_delete $OLDPKGS && pkg_add "$npkg"
@


1.14
log
@realpath(2)ise the file argument
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.13 2006/01/17 22:57:00 tg Exp $
d88 1
d110 1
a110 1
if grep -q '^@@option base-package' $PKG_DBDIR/$OLDPKGS/+CONTENTS ; then
d112 3
a114 1
	pkg_delete -DU $OLDPKGS && pkg_add -Nq "$npkg"
@


1.13
log
@use basename of $1
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.12 2006/01/17 22:54:17 tg Exp $
d51 1
d59 1
a59 1
if [[ ! -s $1 ]]; then
d70 1
a70 1
tar xfz $1 +CONTENTS
d88 1
a88 1
	exec pkg_add $1
d111 1
a111 1
	pkg_delete -DU $OLDPKGS && pkg_add -Nq $1
d113 1
a113 1
	pkg_delete $OLDPKGS && pkg_add $1
@


1.12
log
@fix insane abuse of echo
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.11 2006/01/17 22:52:29 tg Exp $
d75 1
a75 1
	[[ $quiet = 1 ]] || print -u2 "$me: ignoring uninstalled package '$1'"
d86 1
a86 1
	[[ $quiet = 1 ]] || print -u2 "$me: adding previously uninstalled '$1'"
d102 1
a102 1
print -u2 "$me: will remove $OLDPKGS in favour of $1"
@


1.11
log
@add a 'quiet' option and some more output
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.10 2005/12/18 16:36:43 tg Exp $
d54 1
a54 1
	echo "$me: package database directory does not exist" >&2
d90 5
a94 5
if echo $OLDPKGS | grep -q ' ' ; then
	echo "$me: Multiple previous versions of this package are installed."
	echo "This is not supported in this version."
	echo "The packages in question are:"
	echo "$OLDPKGS"
d102 1
a102 1
echo "pkg_upgrade: will remove $OLDPKGS in favour of $1"
@


1.10
log
@Part 2 of the big commit:
* www/vbegin.php: don't output the UTF-8 BOM for now
* ports/Setup.sh: change order in which path is divined [1]
* ports/books/mirex: convert to CVS_DISTF
* ports/comms/ssfe: increase line length limit and history buffer size
* ports/infrastructure/install/setup.sh: sync path order with Setup.sh [1]
* ports/infrastructure/mk/bsd.port.mk: (_PORTPATH) sync default PATH [1]
* ports/infrastructure/mk/bsd.port.mk: (_UPGRADE_FLAGS) new, default to -a
* ports/infrastructure/mk/bsd.port.mk: (_upgrade) use it
* ports/infrastructure/mk/bsd.port.mk: (reupgrade) new target, set to -a -f
* ports/infrastructure/scripts/mkmcz: don't use $LOCALBASE, trust in PATH
* ports/infrastructure/mk/bsd.port.mk: (_CVS_FETCH) use _PORTPATH
* ports/infrastructure/pkgtools/create: treat /usr/info same as /usr/man
* ports/infrastructure/pkgtools/upgrade: fix path to temp +REQUIRED_BY
* ports/www/firesomething: break, suggest Opera-Linux/K-Meleon/Safari
* src/Makefile, src/gcc/Makefile.lang: if build GCJ, check if X11 installed
* src/Makefile, src/gnu/usr.bin/perl/Makefile.bsd-wrapper: defer h2ph
  execution to end of build
* src/distrib/lists: sync with pre-h2ph change
* src/etc/services: add openvpn, from IANA
* src/gcc/Makefile.inc, Makefile.lang: fragment out NO_*= stuff
* src/gcc/libjava/Makefile.bsd-wrapper: DEBUGPROGS is gone
* src/gnu/usr.bin/perl/Makefile.bsd-wrapper: flesh out h2ph, fix perms
* src/lib/libc/time/localtime.c: fix undefined extern
* ports/net/sirc/Makefile: automatically insert version into CTCP VERSION
* ports/net/sirc/dist/PROGRAMMING: document capab hooks
* ports/net/sirc/dist/dsircp: several hours of perl hacking with Club-Mate
  - publish $msgchannel, $talkserver [2]
  - support for CAPAB: publish $has_capab, $capab_cmd, $capab_response;
    add "capab" hook in reply
  - support for CAPAB IDENTIFY-MSG: publish $has_identifymsg; new
    $unverified, $unverified_m; enable automatically if present;
    change <...> [...] -...- to «...» [[...]] ¬...¬
  - /describe nick now looks [*] (or [[*]]) instead of *, /me now looks
    # instead of * if identified, to facilitate this conversion
  - fix abuse of U+0060
  - sort /names [2]
  - fix ^B ^_ ^V [2]
  - remove trailing whitespace on outgoing msgs [2]
  - remove trailing whitespace on incoming msgs
  - fix indentation
  - auto-split overlong lines (partially [2])
  - in NOTICE make nick bold too [2]
  - disable DCC since it crashes
  - beautify CTCP TIME replies
  - add ACCEPT command (for ratbox-ircd, e.g. Freeforge)
* ports/net/sirc/pkg/DESCR: summarise new features

[1] all for the sake of bsiegert@@ wanting to not have to souce a
    SetEnv.sh or SetEnv.csh before building in "default MirPorts"
    (i.e. LOCALBASE=/usr/mpkg SYSCONFDIR=/etc BINOWN=root SUDO=sudo)
[2] adapted from http://co.ordinate.org/sirc/
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.9 2005/12/18 05:40:16 tg Exp $
d4 2
d33 1
a33 1
	print -u2 "\t$me [-af] pkgname.cgz"
d39 2
a40 1
while getopts "afh" option; do
d45 1
d74 4
a77 1
[[ $auto = 1 && -z $OLDPKGS ]] && exit 0
d86 1
d109 1
a109 1
	echo "This is a base package, unregistering only"
@


1.9
log
@* pkg_upgrade: fail pkg_add if pkg_delete fails
* bsd.port.mk: d'oh, sudo pkg_upgrade...

With this, with an already installed openvpn-2.0.5-1
I could do a FLAVOR=static make upgrade clean and got
an automatic, seamless upgrade to openvpn-2.0.5-1-static.
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.8 2005/12/16 16:41:04 tg Exp $
d107 2
a108 2
if [[ -f $TMPDIR/$OLDPKGS/+REQUIRED_BY && -d $PKG_DBDIR/$PKGNAME ]] ; then
	mv $TMPDIR/$OLDPKGS/+REQUIRED_BY $PKG_DBDIR/$PKGNAME
@


1.8
log
@* implement package updates
* an optional -f forces re-installation (i.e. we could realise
  the existing "reinstall" target in <bsd.port.mk> with it)
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.7 2005/12/16 16:34:35 tg Exp $
d79 1
a79 2
	pkg_add $1
	exit
d102 1
a102 2
	pkg_delete -DU $OLDPKGS
	pkg_add -Nq $1
d104 1
a104 2
	pkg_delete $OLDPKGS
	pkg_add $1
a106 1

@


1.7
log
@first round of unbreaking
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.6 2005/12/16 15:14:16 tg Exp $
d27 5
a31 3
if [[ -z $1 || $1 = -h ]]; then
	echo "Usage:"
	echo " $me [pkgname]"
d33 1
a33 1
fi
d36 11
a46 4
if [[ $1 = -a ]]; then	# XXX convert to getopt
	auto=1
	shift
fi
d91 4
@


1.6
log
@* don't show full path on errors
* abort if package can't be found
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.5 2005/11/19 02:05:30 bsiegert Exp $
d33 6
d59 3
a61 1
OLDPKGS=$(eval echo ${PKGNAME%%-[0-9]*}-[0-9]*)
d64 5
a68 1
if grep -q '^@@option no-default-conflict' $TMPDIR/+CONTENTS || [[ -z "$OLDPKGS" ]] ; then
@


1.5
log
@Implement base package upgrades that actually work:

- add a -U option for pkg_delete to leave the files but unregister the
  package. Update manpage; while here, sort options alphabetically.
- add base package detection code into pkg_upgrade

Please test this, as I haven't done so :).

some help by tg@@
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.4 2005/09/13 10:58:24 tg Exp $
d26 1
d29 1
a29 1
	echo " $0 [pkgname]"
d35 6
a40 1
	echo "$0: package database directory does not exist" >&2
d63 1
a63 1
	echo "$0: Multiple previous versions of this package are installed."
@


1.4
log
@use #!/usr/bin/env mksh here, for now
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.3 2005/09/12 22:59:56 tg Exp $
d70 9
a78 2
pkg_delete $OLDPKGS
pkg_add $1
@


1.3
log
@mirports_tar -> tar (and hope $PATH is right)
@
text
@d1 2
a2 2
#!/bin/mksh
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.2 2005/09/12 22:53:28 tg Exp $
@


1.2
log
@join tg-ports-devel branch into HEAD
@
text
@d2 1
a2 1
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.1.2.2 2005/09/11 01:05:45 tg Exp $
d44 1
a44 1
mirports_tar xfz $1 +CONTENTS
@


1.1
log
@Add a "rapid prototype" of an upgrade utility.

WARNING: This thing is very experimental. It does not have security checks.
It might break your system when used with library packages. You have been
warned.

typical usage goes something like this:

% pkg_info | grep libpixman
libpixman-0.1.5-0  pixel manipulation library
% sudo pkg_upgrade /usr/mirports/Packages/libpixman-0.1.6-0.cgz
pkg_upgrade: will remove libpixman-0.1.5-0 in favour of
/usr/mirports/Packages/libpixman-0.1.6-0.cgz
% pkg_info | grep libpixman
libpixman-0.1.6-0  pixel manipulation library

It can upgrade packages which are depended upon by others.
@
text
@d2 1
a2 1
# $MirOS$
@


1.1.2.1
log
@file pkg_upgrade.sh was added on branch tg-ports-devel on 2005-09-11 01:05:45 +0000
@
text
@d1 75
@


1.1.2.2
log
@merge -rHEAD into development branch

Note for bsiegert@@ please don't use csh prompts in man pages any more
@
text
@a0 75
#!/bin/mksh
# $MirOS: ports/infrastructure/pkgtools/upgrade/pkg_upgrade.sh,v 1.1 2005/08/21 13:02:59 bsiegert Exp $
#-
# Copyright (c) 2005
#	Benny Siegert <bsiegert@@66h.42h.de>
#
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publicly perform, modify,
# merge, distribute, sell, give away or sublicence, provided all co-
# pyright notices above, these terms and the disclaimer are retained
# in all redistributions or reproduced in accompanying documentation
# or other materials provided with binary redistributions.
#
# Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
# any kind, expressed or implied, to the maximum extent permitted by
# applicable law, but with the warranty of being written without ma-
# licious intent or gross negligence; in no event shall licensor, an
# author or contributor be held liable for any damage, direct, indi-
# rect or other, however caused, arising in any way out of the usage
# of this work, even if advised of the possibility of such damage.
#-
# wrapper for pkg_add to upgrade packages
# This is only a "rapid prototype", the final implementation might
# be as a part of pkg_add.

if [[ -z $1 || $1 = -h ]]; then
	echo "Usage:"
	echo " $0 [pkgname]"
	exit 1
fi

PKG_DBDIR=@@@@dbdir@@@@/pkg
if [[ ! -d $PKG_DBDIR ]] ; then
	echo "$0: package database directory does not exist" >&2
	exit 1
fi

TMPDIR=$(mktemp -d /tmp/pkg_upgrade.XXXXXXXXXX) || exit 1
trap 'rm -rf $TMPDIR ; exit 0' 0
trap 'rm -rf $TMPDIR ; exit 1' 1 2 3 13 15

OLDPWD=$PWD
cd $TMPDIR
mirports_tar xfz $1 +CONTENTS
cd $PKG_DBDIR
PKGNAME=$(awk '$1=="@@name" { print $2 }' $TMPDIR/+CONTENTS)
OLDPKGS=$(eval echo ${PKGNAME%%-[0-9]*}-[0-9]*)
cd $OLDPWD

if grep -q '^@@option no-default-conflict' $TMPDIR/+CONTENTS || [[ -z "$OLDPKGS" ]] ; then
	# we can safely go on
	pkg_add $1
	exit
fi

if echo $OLDPKGS | grep -q ' ' ; then
	echo "$0: Multiple previous versions of this package are installed."
	echo "This is not supported in this version."
	echo "The packages in question are:"
	echo "$OLDPKGS"
	exit 1
fi

echo "pkg_upgrade: will remove $OLDPKGS in favour of $1"

if [[ -f $PKG_DBDIR/$OLDPKGS/+REQUIRED_BY ]] ; then
	mv -f $PKG_DBDIR/$OLDPKGS/+REQUIRED_BY $TMPDIR
fi

pkg_delete $OLDPKGS
pkg_add $1

if [[ -f $TMPDIR/$OLDPKGS/+REQUIRED_BY && -d $PKG_DBDIR/$PKGNAME ]] ; then
	mv $TMPDIR/$OLDPKGS/+REQUIRED_BY $PKG_DBDIR/$PKGNAME
fi
@


