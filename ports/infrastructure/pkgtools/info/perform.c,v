head	1.7;
access;
symbols
	bsiegert-cfgfile_BASE:1.6
	bsiegert-cfgfile:1.6.0.2
	MIRBSD_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.7
date	2013.10.31.20.05.25;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005272B7081B0E5655;

1.6
date	2009.11.29.17.39.43;	author bsiegert;	state Exp;
branches
	1.6.2.1;
next	1.5;
commitid	1004B12B1DD6B06C313;

1.5
date	2006.12.09.17.34.38;	author bsiegert;	state Exp;
branches;
next	1.4;
commitid	100457AF361062FCEC7;

1.4
date	2005.11.15.19.33.58;	author tg;	state Exp;
branches;
next	1.3;
commitid	7927437a38332782;

1.3
date	2005.09.12.22.53.23;	author tg;	state Exp;
branches;
next	1.2;
commitid	6e6c432606e897b6;

1.2
date	2005.08.21.20.15.47;	author bsiegert;	state Exp;
branches;
next	1.1;
commitid	4cd74308e0708a68;

1.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.6.2.1
date	2010.03.07.15.56.02;	author bsiegert;	state Exp;
branches;
next	1.6.2.2;
commitid	1004B93CC9F4FA9DC45;

1.6.2.2
date	2010.05.13.16.28.55;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004BEC21492BE6507B;

1.1.7.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1.2.1;
next	;

1.1.7.1.2.1
date	2005.09.11.01.05.44;	author tg;	state Exp;
branches;
next	;
commitid	2f08432382e315cf;


desc
@@


1.7
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6 2009/11/29 17:39:43 bsiegert Exp $ */
/*	$OpenBSD: perform.c,v 1.16 2003/08/23 09:14:43 tedu Exp $	*/

/*-
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 *
 * This is MirPorts pkg_install, based on:
 */

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 23 Aug 1993
 *
 * This is the main body of the info module.
 */

#include "lib.h"
#include "info.h"

#include <sys/types.h>
#include <sys/stat.h>

#include <err.h>
#include <signal.h>
#include <dirent.h>
#include <ctype.h>
#include <libgen.h>

__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6 2009/11/29 17:39:43 bsiegert Exp $");

static char    *Home;

__dead void cleanup_and_exit(int);

static int
pkg_do(char *pkg)
{
	bool		isTMP = false;
	char            log_dir[FILENAME_MAX];
	char            fname[FILENAME_MAX];
	package_t       plist;
	FILE           *fp;
	struct stat     sb;
	char           *cp = NULL;
	int             code = 0;
	int             len;
	int		isurl = 0;

	set_pkg(pkg);

	if (AllInstalled)
		goto installed;

	if (isURL(pkg)) {
		if ((cp = fileGetURL(NULL, pkg)) != NULL) {
			strlcpy(fname, cp, sizeof(fname));
			isTMP = true;
		}
		isurl = 1;
	} else if (fexists(pkg) && isfile(pkg)) {

		if (*pkg != '/') {
			if (!getcwd(fname, sizeof(fname))) {
			    cleanup(0);
			    err(1, "fatal error during execution: getcwd");
			}
			len = strlen(fname);
			snprintf(&fname[len], sizeof(fname) - len, "/%s", pkg);
		} else
			strlcpy(fname, pkg, sizeof(fname));
		cp = fname;
	} else {
		if ((cp = fileFindByPath(NULL, pkg)) != NULL) {
			strlcpy(fname, cp, sizeof(fname));
			if (isURL(fname) && (cp = fileGetURL(NULL, fname))
			    != NULL) {
				strlcpy(fname, cp, sizeof(fname));
				isTMP = true;
				isurl = 1;
			} else if (cp && *cp != '/') {
				if (!getcwd(fname, sizeof(fname))) {
				    	cleanup(0);
					err(1, "fatal error during execution: "
					    "getcwd");
				}
				len = strlen(fname);
				snprintf(&fname[len], sizeof(fname) - len,
				    "/%s", cp);
			}
		}
	}
	if (cp) {
		if (isurl) {
			/* file is already unpacked by fileGetURL() */
			strlcpy(PlayPen, cp, PlayPenSize);
		} else {
			/*
			 * Apply a crude heuristic to see how much space the package will
			 * take up once it's unpacked.  I've noticed that most packages
			 * compress an average of 75%, but we're only unpacking the + files so
			 * be very optimistic.
			 */
			if (stat(fname, &sb) == -1) {
				pwarnx("can't stat package file '%s'", fname);
				code = 1;
				goto bail;
			}
			Home = make_playpen(PlayPen, PlayPenSize, sb.st_size / 2);
			if (unpack(fname, "+*")) {
				pwarnx("error during unpacking, no info for '%s' available", pkg);
				code = 1;
				goto bail;
			}
		}
	}
	/*
	 * It's not an uninstalled package, try and find it among the
	 * installed
	 */
	else
installed:
	{
		if (glob_package(log_dir, sizeof(log_dir), pkg) < 1) {
			pwarnx("can't find package '%s' installed or in a file!", pkg);
			return 1;
		}
		if (chdir(log_dir) == -1) {
			pwarnx("can't change directory to '%s'!", log_dir);
			return 1;
		}
		pkg = strdup(basename(log_dir));
	}

	/*
         * Index is special info type that has to override all others to make
         * any sense.
         */
	if (Flags & SHOW_INDEX) {
		show_index(pkg, COMMENT_FNAME);
	} else {
		/* Suck in the contents list */
		plist.head = plist.tail = NULL;
		fp = fopen(CONTENTS_FNAME, "r");
		if (!fp) {
			pwarnx("unable to open %s file", CONTENTS_FNAME);
			if (isurl) /* file not on server, check installed */
				goto installed;
			code = 1;
			goto bail;
		}
		/* If we have a prefix, add it now */
		read_plist(&plist, fp);
		fclose(fp);

		/* Start showing the package contents */
		if (!Quiet)
			printf("%sInformation for %s:\n\n", InfoPrefix, pkg);
		if (Flags & SHOW_COMMENT)
			show_file("Comment:\n", COMMENT_FNAME);
		if ((Flags & SHOW_REQBY) && !isemptyfile(REQUIRED_BY_FNAME))
			show_file("Required by:\n", REQUIRED_BY_FNAME);
		if (Flags & SHOW_DESC)
			show_file("Description:\n", DESC_FNAME);
		if ((Flags & SHOW_DISPLAY) && fexists(DISPLAY_FNAME))
			show_file("Install notice:\n", DISPLAY_FNAME);
		if ((Flags & SHOW_DEPENDS) && fexists(DEPENDS_FNAME))
			show_file("Dependencies:\n", DEPENDS_FNAME);
		if (Flags & SHOW_PLIST)
			show_plist("Packing list:\n", &plist, PLIST_SHOW_ALL);
		if ((Flags & SHOW_INSTALL) && fexists(INSTALL_FNAME))
			show_file("Install script:\n", INSTALL_FNAME);
		if ((Flags & SHOW_DEINSTALL) && fexists(DEINSTALL_FNAME))
			show_file("De-Install script:\n", DEINSTALL_FNAME);
		if ((Flags & SHOW_MTREE) && fexists(MTREE_FNAME))
			show_file("mtree file:\n", MTREE_FNAME);
		if (Flags & SHOW_PREFIX)
			show_plist("Prefix(s):\n", &plist, PLIST_CWD);
		if (Flags & SHOW_FILES)
			show_files("Files:\n", &plist);
		if (Flags & SHOW_SAMPLE)
			show_plist("Configuration file(s):\n", &plist, PLIST_SAMPLE);
		if (!Quiet)
			puts(InfoPrefix);
		free_plist(&plist);
	}
bail:
	leave_playpen(Home);
	if (isTMP)
		unlink(fname);
	return code;
}

/* fn to be called for pkgs found */
static int
foundpkg(const char *found, char *data __attribute__((__unused__)),
    int unused __attribute__((__unused__)))
{
    if(!Quiet)
	printf("%s\n", found);
    return 0;
}

/* check if a package "pkgspec" (which can be a pattern) is installed */
/* return 0 if found, 1 otherwise (indicating an error). */
static int
check4pkg(char *pkgspec, const char *dbdir)
{
	if (strpbrk(pkgspec, "<>[]?*{")) {
	    /* expensive (pattern) match */
	    int found;

	    found=findmatchingname(dbdir, pkgspec, foundpkg, NULL, 0);
	    return !found;
	} else {
		/* simple match */
	char            buf[FILENAME_MAX];
	int             error;
		struct stat     st;

		snprintf(buf, sizeof(buf), "%s/%s", dbdir, pkgspec);
		error = (stat(buf, &st) < 0);
		if (!error && !Quiet)
		printf("%s\n", pkgspec);

	return error;
	}
}

void
cleanup(int sig __attribute__((__unused__)))
{
	leave_playpen(Home);		/* XXX signal race */
	/* _do_ return, so errx(3) works */
}

__dead void
cleanup_and_exit(int sig)
{
	cleanup(sig);			/* XXX signal race */
	_exit(1);
}

int
pkg_perform(char **pkgs)
{
	int             i, err_cnt = 0;
	const char	*tmp;

	signal(SIGINT, cleanup_and_exit);

	tmp = getenv(PKG_DBDIR);
	if (!tmp)
		tmp = DEF_LOG_DIR;
	/* Overriding action? */
	if (CheckPkg) {
		err_cnt += check4pkg(CheckPkg, tmp);
	} else if (AllInstalled) {
		struct dirent  *dp;
		DIR            *dirp;

		if (!(isdir(tmp) || islinktodir(tmp)))
			return 1;
		if (chdir(tmp) != 0)
			return 1;
		if ((dirp = opendir(".")) != NULL) {
			while ((dp = readdir(dirp)) != NULL) {
				if (strcmp(dp->d_name, ".") && strcmp(dp->d_name, "..")) {
					err_cnt += pkg_do(dp->d_name);
				}
			}
			(void) closedir(dirp);
		}
	} else {
		for (i = 0; pkgs[i]; i++) {
			err_cnt += pkg_do(pkgs[i]);
		}
	}
	return err_cnt;
}
@


1.6
log
@Fix a null pointer dereference in case fileGetURL() fails; remove an
unused variable.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.5 2006/12/09 17:34:38 bsiegert Exp $ */
d4 3
a6 1
/* This is MirPorts pkg_install, based on:
d8 4
d42 1
a42 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.5 2006/12/09 17:34:38 bsiegert Exp $");
d208 2
a209 2
foundpkg(const char *found, char *data __attribute__((unused)),
    int unused __attribute__((unused)))
d243 1
a243 1
cleanup(int sig __attribute__((unused)))
@


1.6.2.1
log
@Finally, the first real use for the srclist code I implemented the other day:
"pkg_info -E pkgspec" looks for packages matching the spec in the installed
ones and the source list, and prints a list.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6 2009/11/29 17:39:43 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6 2009/11/29 17:39:43 bsiegert Exp $");
d202 2
a203 1
foundpkg(const char *found, char *data, int len)
d206 1
a206 1
	printf(len ? "%-30s%s\n" : "%s%s", found, data);
a209 25
static int
findpkg_srcs(char *pkgspec, const char *dbdir)
{
	struct matchlist *matches;
	struct match *mp;
	int found;
	char *msg;

	/* look for an installed package first */
	if (!(msg = strdup(" (installed)")))
		err(1, NULL);
	found = findmatchingname(dbdir, pkgspec, foundpkg, msg, strlen(msg));

	matches = findmatchingname_srcs(cfg_get_sourcelist(), pkgspec);
	TAILQ_FOREACH(mp, matches, entries) {
		found++;
		if (!Quiet)
			printf("%-30s at %s\n", mp->pkgname, mp->source);
	}
	
	matchlist_destroy(matches);
	free(matches);
	return found;
}

a217 4
	    char *empty;

	    if (!(empty = strdup("")))
		    err(1, NULL);
d219 1
a219 1
	    found=findmatchingname(dbdir, pkgspec, foundpkg, empty, 0);
d262 1
a262 1
	if (CheckPkg)
d264 1
a264 3
	else if (FindPkg)
		err_cnt += findpkg_srcs(FindPkg, tmp);
	else if (AllInstalled) {
@


1.6.2.2
log
@- file.c: also look for pkgname.cgz and pkgname->=0 if lookup fails
- perform.c: turn logic around, much better now

Read more about this commit in my upcoming wlog entry.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6.2.1 2010/03/07 15:56:02 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.6.2.1 2010/03/07 15:56:02 bsiegert Exp $");
a54 1
	bool		isInstalled = false;
d58 4
a61 8
	if (glob_package(log_dir, sizeof(log_dir), pkg) >= 1) {
		if (chdir(log_dir) == -1) {
			pwarnx("can't change directory to '%s'!", log_dir);
			return 1;
		}
		pkg = strdup(basename(log_dir));
		isInstalled = true;
	} else if (isURL(pkg)) {
d68 1
d79 2
a80 4
	} else if ((cp = fileFindByPath(NULL, pkg)) != NULL) {
		strlcpy(fname, cp, sizeof(fname));
		if (isURL(fname) && (cp = fileGetURL(NULL, fname))
		    != NULL) {
d82 14
a95 7
			isTMP = true;
			isurl = 1;
		} else if (cp && *cp != '/') {
			if (!getcwd(fname, sizeof(fname))) {
				cleanup(0);
				err(1, "fatal error during execution: "
				    "getcwd");
a96 3
			len = strlen(fname);
			snprintf(&fname[len], sizeof(fname) - len,
			    "/%s", cp);
a97 4
		pkg = fname;
	} else {
		pwarnx("cannot find package '%s' installed or in a file!", pkg);
		return 1;
a98 1

d123 17
d153 2
d164 1
a164 2
			printf("%sInformation for %s%s:\n\n", InfoPrefix, pkg,
					isInstalled ? " (installed)" : "");
@


1.5
log
@Implement a new "-P" option for pkg_info to show the +DEPENDS file if it
exists. Enabled by default in "pkg_info -v".

If you have upgraded your pkgtools in the last few weeks, you might have
noticed that forward dependencies are now saved in +DEPENDS files _and_ in
the plist. In the future, +DEPENDS will take precedence.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.4 2005/11/15 19:33:58 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.4 2005/11/15 19:33:58 tg Exp $");
d45 1
a45 1
	bool		installed = false, isTMP = false;
d87 1
a87 1
			} else if (*cp != '/') {
a138 1
		installed = true;
@


1.4
log
@crude U+0060 removal
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.3 2005/09/12 22:53:23 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.3 2005/09/12 22:53:23 tg Exp $");
d174 2
@


1.3
log
@join tg-ports-devel branch into HEAD
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.1.7.1.2.1 2005/09/11 01:05:44 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.1.7.1.2.1 2005/09/11 01:05:44 tg Exp $");
d131 1
a131 1
			pwarnx("can't find package `%s' installed or in a file!", pkg);
@


1.2
log
@Add extended package name globbing for pkg_info and pkg_delete.
This means that you can do stuff like

% pkg_delete libpixman

without knowing the version. If more than one version is installed (for
example with autoconf), pkg_info will just show you the first match while
pkg_delete refuses to work.
@
text
@d1 1
a1 1
/**	$MirOS$ */
d36 1
a36 1
__RCSID("$MirOS$");
@


1.1
log
@Initial revision
@
text
@d34 1
a41 28
/* retrieve info on installed packages from the base name:
 * find a full name of the form pkg-xxx.
 */
static char *
find_prefix(char *buffer, int bufsize, const char *base, char *pkg)
{
	DIR 		*dirp;
	struct dirent 	*dp;
	char 		*res;
	int 		 pkg_length = strlen(pkg);


	if (! (dirp = opendir(base)) )
		return 0;
	while ( (dp = readdir(dirp)) ) {
		if (strncmp(dp->d_name, pkg, pkg_length) == 0
		    && dp->d_name[pkg_length] == '-') {
			snprintf(buffer, bufsize, "%s/%s", base, dp->d_name);
			  /* pedantic: need to dup res before closedir() */
			res = strdup(dp->d_name);
			(void)closedir(dirp);
			return res;
		}
	}
	(void)closedir(dirp);
	return 0;
}

a52 1
	char           *pkg2 = 0; /* hold full name of package, storage to free */
d130 1
a130 9
		const char *tmp;

		if (!(tmp = getenv(PKG_DBDIR)))
			tmp = DEF_LOG_DIR;

		(void) snprintf(log_dir, sizeof(log_dir), "%s/%s", tmp,
			pkg);
		if (!fexists(log_dir) &&
			! (pkg2 = find_prefix(log_dir, sizeof(log_dir), tmp, pkg))) {
a133 2
		if (pkg2)
			pkg = pkg2;
a135 1
			free(pkg2);
d138 1
a192 1
	free(pkg2);
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@


1.1.7.1.2.1
log
@merge -rHEAD into development branch

Note for bsiegert@@ please don't use csh prompts in man pages any more
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.2 2005/08/21 20:15:47 bsiegert Exp $ */
a33 1
#include <libgen.h>
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/info/perform.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $");
d41 28
d80 1
d158 9
a166 1
		if (glob_package(log_dir, sizeof(log_dir), pkg) < 1) {
d170 2
d174 1
a176 1
		pkg = strdup(basename(log_dir));
d231 1
@

