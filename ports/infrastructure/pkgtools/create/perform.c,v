head	1.22;
access;
symbols
	bsiegert-cfgfile_BASE:1.20
	bsiegert-cfgfile:1.20.0.2
	MIRBSD_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.22
date	2017.07.20.21.15.53;	author tg;	state Exp;
branches;
next	1.21;
commitid	10059711D89780CE021;

1.21
date	2010.12.27.01.58.34;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004D17F2B42D6AD158;

1.20
date	2009.12.08.20.51.04;	author bsiegert;	state Exp;
branches;
next	1.19;
commitid	1004B1EBBF04E744B63;

1.19
date	2009.11.29.17.26.04;	author bsiegert;	state Exp;
branches;
next	1.18;
commitid	1004B12AE7B03C7F7A7;

1.18
date	2009.11.22.15.34.14;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004B0959E8012B753D;

1.17
date	2009.10.20.19.32.49;	author bsiegert;	state Exp;
branches;
next	1.16;
commitid	1004ADE102745DDB74A;

1.16
date	2009.08.19.18.30.11;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004A8C44C94C0217DA;

1.15
date	2008.11.02.19.23.58;	author tg;	state Exp;
branches;
next	1.14;
commitid	100490DFE652F3E615E;

1.14
date	2008.11.02.19.19.11;	author tg;	state Exp;
branches;
next	1.13;
commitid	100490DFD38420CA1B2;

1.13
date	2008.11.02.19.08.42;	author tg;	state Exp;
branches;
next	1.12;
commitid	100490DFAC9179A5865;

1.12
date	2008.11.02.19.05.48;	author tg;	state Exp;
branches;
next	1.11;
commitid	100490DFA1E4C107742;

1.11
date	2008.10.12.15.35.21;	author tg;	state Exp;
branches;
next	1.10;
commitid	10048F218B2228D17F9;

1.10
date	2008.10.12.14.35.16;	author tg;	state Exp;
branches;
next	1.9;
commitid	10048F20B342E297907;

1.9
date	2008.03.27.20.58.46;	author bsiegert;	state Exp;
branches;
next	1.8;
commitid	10047EC0A760867599A;

1.8
date	2007.03.30.23.20.10;	author bsiegert;	state Exp;
branches;
next	1.7;
commitid	100460D99284E3410CC;

1.7
date	2006.11.19.22.16.36;	author bsiegert;	state Exp;
branches;
next	1.6;
commitid	1004560D7992BF407CE;

1.6
date	2005.12.18.16.36.42;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043A58BE830AFB807;

1.5
date	2005.12.17.02.36.26;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043A378A344C47E91;

1.4
date	2005.09.12.22.59.54;	author tg;	state Exp;
branches;
next	1.3;
commitid	515c4326087549fe;

1.3
date	2005.05.22.03.52.46;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	5d43428ffdbc7a19;

1.2
date	2005.05.21.00.16.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	2ef4428e7c341292;

1.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.1.7.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.22
log
@.lz and .tlz are claimed by lzip, drop most LZMA-Alone support
(one thing in which Lasse and Antonio agree)
@
text
@/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.20 2009/12/08 20:51:04 bsiegert Exp $ */
/* $OpenBSD: perform.c,v 1.17 2003/08/27 06:51:26 jolan Exp $	*/

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * This is the main body of the create module.
 */

#include "lib.h"
#include "create.h"

#ifndef __INTERIX
#include <sys/syslimits.h>
#endif

#include <err.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>

__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.20 2009/12/08 20:51:04 bsiegert Exp $");

static void sanity_check(void);
static void make_dist(char *, char *, const char *, package_t *);

static char *home;

int
pkg_perform(char **pkgs)
{
    char *pkg = *pkgs;		/* Only one arg to create */
    char *cp;
    FILE *pkg_in, *fp;
    package_t plist;
    /* What we tack on to the end of the finished package */
    const char *fsuffix;
    bool hackmandir = false;

    /* Preliminary setup */
    sanity_check();
    if (Verbose && !PlistOnly)
	printf("Creating package %s\n", pkg);
    get_dash_string(&Comment);
    if (strlen(Comment) > MAXINDEXSIZE && !PlistOnly) {
	errx(2,"Comment string is over %d characters long:\n%s",
	   MAXINDEXSIZE, Comment);
    }
    get_dash_string(&Desc);
    if (!strcmp(Contents, "-"))
	pkg_in = stdin;
    else {
	pkg_in = fopen(Contents, "r");
	if (!pkg_in) {
	    cleanup(0);
	    errx(2, "unable to open contents file '%s' for input", Contents);
	}
    }
    plist.head = plist.tail = NULL;

    /* Break the package name into base and desired suffix (if any) */
    if ((cp = strrchr(pkg, '.')) != NULL) {
	fsuffix = cp + 1;
	*cp = '\0';
    }
    else
	fsuffix = "tgz";

    if (Prefix)
	add_plist(&plist, PLIST_CWD, Prefix);
    /* If a SrcDir override is set, add it now */
    if (SrcDir) {
	if (Verbose && !PlistOnly)
	    printf("Using SrcDir value of %s\n", SrcDir);
	add_plist(&plist, PLIST_SRC, SrcDir);
    }

    /* Binary emulations */
    if (Emulations) {
	if (Verbose && !PlistOnly)
	    printf("Binary emulation:");
	while (Emulations) {
	    cp = strsep(&Emulations, " \t\n");
	    if (*cp) {
		add_plist(&plist, PLIST_EMUL, cp);
		if (Verbose && !PlistOnly)
		    printf(" %s", cp);
	    }
	}
	if (Verbose && !PlistOnly)
	    printf(".\n");
    }

    /* Stick the dependencies, if any, at the top */
    if (Pkgdeps) {
	if (Verbose && !PlistOnly)
	    printf("Registering depends:");
	while (Pkgdeps) {
	    cp = strsep(&Pkgdeps, " \t\n");
	    if (*cp) {
		add_plist(&plist, PLIST_PKGDEP, cp);
		if (Verbose && !PlistOnly)
		    printf(" %s", cp);
	    }
	}
	if (Verbose && !PlistOnly)
	    printf(".\n");
    }

    /* Put the conflicts directly after the dependencies, if any */
    if (Pkgcfl) {
	if (Verbose && !PlistOnly)
	    printf("Registering conflicts:");
	while (Pkgcfl) {
	   cp = strsep(&Pkgcfl, " \t\n");
	   if (*cp) {
		add_plist(&plist, PLIST_PKGCFL, cp);
		if (Verbose && !PlistOnly)
		    printf(" %s", cp);
	   }
	}
	if (Verbose && !PlistOnly)
	    printf(".\n");
    }

    /* Slurp in the packing list */
    read_plist(&plist, pkg_in);

    /*
     * Run down the list and see if we've named it, if not stick in a name
     * at the top.
     */
    if (find_plist(&plist, PLIST_NAME, NULL) == NULL)
	add_plist_top(&plist, PLIST_NAME, basename(pkg));

    /*
     * We're just here for to dump out a revised plist for the FreeBSD ports
     * hack.  It's not a real create in progress.
     */
    if (PlistOnly) {
	check_list(home, &plist, false);
	write_plist(&plist, stdout);
	exit(0);
    }

    /* Check if we're dressing for the operating system */
    if (Prefix && !strcmp(Prefix, "/usr")) {
	hackmandir = true;
	if (BaseDir) {
	    char *pf = copy_string(strconcat(BaseDir, Prefix));
	    char *s = copy_string(strconcat(pf, "/man"));
	    char *s2 = copy_string(strconcat(pf, "/info"));
	    if (!pf || !s || !s2)
		err(1, "cannot copy_string");
	    if (!isdir(s) && !isdir(s2))
		hackmandir = false;
	    else {
		if (rename(s, strconcat(pf, "/share/man")))
		    err(1, "cannot rename %s to ...%s", s, "/share/man");
		if (rename(s2, strconcat(pf, "/share/info")))
		    err(1, "cannot rename %s to ...%s", s2, "/share/info");
	    }
	    free(s2);
	    free(s);
	    free(pf);
	}
    }

    /* Make a directory to stomp around in */
    home = make_playpen(PlayPen, PlayPenSize, 0);
    signal(SIGINT, cleanup);
    signal(SIGHUP, cleanup);

    /* Make first "real contents" pass over it */
    check_list(home, &plist, hackmandir);
    (void) umask(022);	/* make sure gen'ed directories, files don't have
			   group or other write bits. */
    /* copy_plist(home, &plist); */
    /* mark_plist(&plist); */

    /* Now put the release specific items in */
    add_plist(&plist, PLIST_CWD, ".");
    if (write_file(COMMENT_FNAME, "w", "%s", Comment))
	errx(2, "error writing comment file");
    add_plist(&plist, PLIST_IGNORE, NULL);
    add_plist(&plist, PLIST_FILE, COMMENT_FNAME);
    if (write_file(DESC_FNAME, "w", "%s", Desc))
	errx(2, "error writing description file");
    add_plist(&plist, PLIST_IGNORE, NULL);
    add_plist(&plist, PLIST_FILE, DESC_FNAME);

    if (Install) {
	copy_file(home, Install, INSTALL_FNAME);
	add_plist(&plist, PLIST_IGNORE, NULL);
	add_plist(&plist, PLIST_FILE, INSTALL_FNAME);
    }
    if (DeInstall) {
	copy_file(home, DeInstall, DEINSTALL_FNAME);
	add_plist(&plist, PLIST_IGNORE, NULL);
	add_plist(&plist, PLIST_FILE, DEINSTALL_FNAME);
    }
    if (Require) {
	copy_file(home, Require, REQUIRE_FNAME);
	add_plist(&plist, PLIST_IGNORE, NULL);
	add_plist(&plist, PLIST_FILE, REQUIRE_FNAME);
    }
    if (Display) {
	copy_file(home, Display, DISPLAY_FNAME);
	add_plist(&plist, PLIST_IGNORE, NULL);
	add_plist(&plist, PLIST_FILE, DISPLAY_FNAME);
	add_plist(&plist, PLIST_DISPLAY, DISPLAY_FNAME);
    }
    if (Mtree) {
	copy_file(home, Mtree, MTREE_FNAME);
	add_plist(&plist, PLIST_IGNORE, NULL);
	add_plist(&plist, PLIST_FILE, MTREE_FNAME);
	add_plist(&plist, PLIST_MTREE, MTREE_FNAME);
    }

    /* Finally, write out the packing list */
    fp = fopen(CONTENTS_FNAME, "w");
    if (!fp) {
	cleanup(0);
	errx(2, "can't open file %s for writing", CONTENTS_FNAME);
    }
    write_plist(&plist, fp);
    if (fclose(fp)) {
	cleanup(0);
	errx(2, "error while closing %s", CONTENTS_FNAME);
    }

    /* And stick it into a tar ball */
    make_dist(home, pkg, fsuffix, &plist);

    /* Cleanup */
    free(Comment);
    free(Desc);
    free_plist(&plist);
    leave_playpen(home);
    return true;	/* Success */
}

static void
make_dist(char *homepath, char *pkg, const char *fsuffix, package_t *plist)
{
    char tball[FILENAME_MAX];
    plist_t *p;
    int ret;
#define DIST_MAX_ARGS 4096
    char *args[DIST_MAX_ARGS];
    const char **cargs = (const char **)args;
    char *tempfile[DIST_MAX_ARGS/2];
    int current = 0;
    FILE *flist = 0;
    int nargs = 0;
    int i;
    pkg_cmp_t compression;
    char *cp, *cp2;

    bzero(args, sizeof(args));
    args[nargs++] = xstrdup("tar");	/* argv[0] */

    if (*pkg == '/')
	snprintf(tball, FILENAME_MAX, "%s.%s", pkg, fsuffix);
    else
	snprintf(tball, FILENAME_MAX, "%s/%s.%s", homepath, pkg, fsuffix);

    if (!strcmp(fsuffix + strlen(fsuffix) - 4, "lzma"))
	compression = COMP_LZMA;
    else if (!strcmp(fsuffix + strlen(fsuffix) - 2, "xz"))
	compression = COMP_XZ;
    else if (strchr(fsuffix, 'z'))
	compression = COMP_GZIP;
    else
	compression = COMP_NONE;

    args[nargs++] = xstrdup("-c");
    if (!WantUSTAR)
	args[nargs++] = xstrdup("-S");
    args[nargs++] = xstrdup("-f");
    args[nargs++] = compression ? xstrdup("-") : tball;
    if (Dereference)
	args[nargs++] = xstrdup("-h");
    if (ExcludeFrom) {
      /* XXX this won't work until someone adds the gtar -X option
	 (--exclude-from-file) to paxtar - so long it is disabled
	 here and a warning is printed in main.c
	args[nargs++] = xstrdup("-X");
	args[nargs++] = ExcludeFrom;
	*/
    }

    if (Verbose)
	printf("Creating %star ball in '%s'\n",
	    compression == COMP_XZ	? "LZMA2 compressed " :
	    compression == COMP_LZMA	? "LZMA1 compressed " :
	    compression == COMP_GZIP	? "gzip'd " : "", tball);
    args[nargs++] = xstrdup(CONTENTS_FNAME);
    args[nargs++] = xstrdup(COMMENT_FNAME);
    args[nargs++] = xstrdup(DESC_FNAME);
    if (Install)
        args[nargs++] = xstrdup(INSTALL_FNAME);
    if (DeInstall)
	args[nargs++] = xstrdup(DEINSTALL_FNAME);
    if (Require)
	args[nargs++] = xstrdup(REQUIRE_FNAME);
    if (Display)
	args[nargs++] = xstrdup(DISPLAY_FNAME);
    if (Mtree)
	args[nargs++] = xstrdup(MTREE_FNAME);

    for (p = plist->head; p; p = p->next) {
	if (nargs > (DIST_MAX_ARGS - 2))
	    errx(2, "too many args for tar command");
	switch (p->type) {
	case PLIST_LIB:
	case PLIST_NOLIB:
	case PLIST_FILE:
	    if (!flist) {
	    	int fd;
		if ((tempfile[current] = xstrdup("/tmp/tpkg.XXXXXXXXXX")) == NULL)
		    err(2, NULL);
		if ((fd = mkstemp(tempfile[current])) == -1)
		    errx(2, "can't make temp file");
		if (! (flist = fdopen(fd, "w")))
		    errx(2, "can't write to temp file");
		if (args[nargs] && strcmp(args[nargs], "-C") == 0)
		    nargs+= 2;
		args[nargs++] = xstrdup("-I");
		args[nargs++] = tempfile[current++];
	    }
	    fprintf(flist, "%s\n", p->name);
	    break;
	case PLIST_CWD:
	case PLIST_SRC:
	    /* XXX let PLIST_SRC override PLIST_CWD */
	    if (p->type == PLIST_CWD && p->next != NULL &&
	    	p->next->type == PLIST_SRC)
		    break;
	    if (flist)
		fclose(flist);
	    flist = 0;
	    args[nargs] = xstrdup("-C");
	    if (BaseDir)
		xasprintf(&args[nargs+1], "%s/%s", BaseDir, p->name);
	    else
		args[nargs+1] = p->name;
	    break;
	case PLIST_IGNORE:
	    p = p->next;
	    break;
	default:
	    /* nothing */
	    break;
	}
    }
    if (flist)
    	fclose(flist);
    args[nargs] = NULL;

    /* fork/exec tar to create the package */

    cp = format_comm(cargs);
    if (compression) {
	char *tf;

	xasprintf(&cp2, "%s | %s >%s", cp,
		compression == COMP_GZIP ? "gzip -n9fc" :
		compression == COMP_LZMA ? "lzma -z7fc" :
		"xz -zfc7e -F xz -C crc32", (tf = format_arg(tball)));
	xfree(tf);
	xfree(cp);
    } else
	cp2 = cp;

    if ((ret = sxsystem(compression == COMP_LZMA ||
		    compression == COMP_XZ, cp2)) == -1) {
	for (i = 0; i < current; i++)
	    unlink(tempfile[i]);
	exit(2);
    }
    xfree(cp2);
    for (i = 0; i < current; i++)
	unlink(tempfile[i]);
    if (BaseDir) {
    	for (i = 0; i < nargs-1; i++) {
	    if (!strcmp(args[i], "-C"))
		free(args[++i]);
	}
    }
    /* assume either signal or bad exit is enough for us */
    if (ret) {
	cleanup(0);
	errx(2, "tar command failed with code %d", ret);
    }
}

static void
sanity_check(void)
{
    if (!Comment) {
	cleanup(0);
	errx(2, "required package comment string is missing (-c comment)");
    }
    if (!Desc) {
	cleanup(0);
	errx(2, "required package description string is missing (-d desc)");
    }
    if (!Contents) {
	cleanup(0);
	errx(2, "required package contents list is missing (-f [-]file)");
    }
}


/* Clean up those things that would otherwise hang around */
void
cleanup(int sig)
{
    int save_errno = errno;
    static int	alreadyCleaning;
    void (*oldint)(int);
    void (*oldhup)(int);
    char buf[1024];
    oldint = signal(SIGINT, SIG_IGN);
    oldhup = signal(SIGHUP, SIG_IGN);

    if (!alreadyCleaning) {
    	alreadyCleaning = 1;
	if (sig) {
	    snprintf(buf, sizeof buf, "Signal %d received, cleaning up.\n", sig);
	    write(STDOUT_FILENO, buf, strlen(buf));
	}
	leave_playpen(home);
	if (sig)
	    _exit(1);
    }
    signal(SIGINT, oldint);
    signal(SIGHUP, oldhup);
    errno = save_errno;
}
@


1.21
log
@lower default xz compression from -9e (doesnâ€™t work on MirBSD anyway)
to -7e after experience with xz at work
@
text
@d281 1
a281 1
    if (!strcmp(fsuffix + strlen(fsuffix) - 2, "lz"))
d382 1
a382 1
		compression == COMP_LZMA ? "lzma -z9fc" :
@


1.20
log
@Introduce an enum for the compression type instead of using 0, 1, 2, 3
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.19 2009/11/29 17:26:04 bsiegert Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.19 2009/11/29 17:26:04 bsiegert Exp $");
d383 1
a383 1
		"xz -zfc9e -F xz -C crc32", (tf = format_arg(tball)));
@


1.19
log
@This one was not quite easy: in some cases, strcmp is called with an
uninitialized pointer value. Initialize the array to zero first and check
whether we have a null pointer to be sure.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.18 2009/11/22 15:34:14 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.18 2009/11/22 15:34:14 tg Exp $");
d269 2
a270 1
    int i, compression;
d282 1
a282 2
	/* LZMA-Alone compression */
	compression = 2;
d284 1
a284 2
	/* LZMA2 compression */
	compression = 3;
d286 1
a286 2
	/* gzip compression */
	compression = 1;
d288 1
a288 1
	compression = 0;
d308 3
a310 3
	    compression == 3 ? "LZMA2 compressed " :
	    compression == 2 ? "LZMA1 compressed " :
	    compression == 1 ? "gzip'd " : "", tball);
d380 4
a383 3
	xasprintf(&cp2, "%s | %s >%s", cp, compression == 1 ?
	  "gzip -n9fc" : compression == 2 ? "lzma -z9fc" :
	  "xz -zfc9e -F xz -C crc32", (tf = format_arg(tball)));
d389 2
a390 1
    if ((ret = sxsystem(compression == 2 || compression == 3, cp2)) == -1) {
@


1.18
log
@support for the upcoming XZ Utils compression
planned for long, prodded by bsiegert@@
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.17 2009/10/20 19:32:49 bsiegert Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.17 2009/10/20 19:32:49 bsiegert Exp $");
d272 1
d342 1
a342 1
		if (strcmp(args[nargs], "-C") == 0)
@


1.17
log
@New plist entry type "@@nolib", for use with .la files, which will NOT be passed
through libtoolise/unlibtoolise. Needed for GNU Smalltalk
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.16 2009/08/19 18:30:11 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.16 2009/08/19 18:30:11 tg Exp $");
d280 1
a280 1
	/* LZMA compression */
d282 3
d309 2
a310 1
	    compression == 2 ? "LZMA compressed " :
d382 2
a383 1
	  "gzip -n9fc" : "lzma -z9fc", (tf = format_arg(tball)));
d389 1
a389 1
    if ((ret = sxsystem(compression == 2, cp2)) == -1) {
@


1.16
log
@make this able to handle .cpio and .tar (interestingly enough, some
parts of the code also know .tar.Z but not all) for use on e.g. the
slow platforms (sparc etc) when re-compressing packages on a faster
machine afterwards
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.15 2008/11/02 19:23:58 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.15 2008/11/02 19:23:58 tg Exp $");
d327 1
@


1.15
log
@thinko
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.14 2008/11/02 19:19:11 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.14 2008/11/02 19:19:11 tg Exp $");
d279 1
a279 2
    if (((cp = strrchr(tball, '.')) != NULL) &&
      (!strcmp(cp, ".clz")))
@


1.14
log
@use a pipeline for both gzip and lzma compression, raising ratio to â€˜-9â€™
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.13 2008/11/02 19:08:42 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.13 2008/11/02 19:08:42 tg Exp $");
d293 1
a293 1
    args[nargs++] = compression == 2 ? xstrdup("-") : tball;
@


1.13
log
@we unlimit now, so we can use lzma -9
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.12 2008/11/02 19:05:48 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.12 2008/11/02 19:05:48 tg Exp $");
d270 1
a270 1
    char *lztmp, *cp;
d272 1
a272 1
    args[nargs++] = strdup("tar");	/* argv[0] */
d279 2
a280 2
    if (((lztmp = strrchr(tball, '.')) != NULL) &&
      (!strcmp(lztmp, ".clz"))) {
d283 1
a283 3
	lztmp = strdup(tball);
	lztmp[strlen(lztmp) - 1] = '~';
    } else if (strchr(fsuffix, 'z'))
d289 1
a289 1
    args[nargs++] = strdup("-c");
d291 3
a293 5
	args[nargs++] = strdup("-S");
    args[nargs++] = strdup("-f");
    args[nargs++] = compression == 2 ? lztmp : tball;
    if (compression == 1)
	args[nargs++] = strdup("-z");
d295 1
a295 1
	args[nargs++] = strdup("-h");
d300 1
a300 1
	args[nargs++] = strdup("-X");
d309 3
a311 3
    args[nargs++] = strdup(CONTENTS_FNAME);
    args[nargs++] = strdup(COMMENT_FNAME);
    args[nargs++] = strdup(DESC_FNAME);
d313 1
a313 1
        args[nargs++] = strdup(INSTALL_FNAME);
d315 1
a315 1
	args[nargs++] = strdup(DEINSTALL_FNAME);
d317 1
a317 1
	args[nargs++] = strdup(REQUIRE_FNAME);
d319 1
a319 1
	args[nargs++] = strdup(DISPLAY_FNAME);
d321 1
a321 1
	args[nargs++] = strdup(MTREE_FNAME);
d331 1
a331 1
		if ((tempfile[current] = strdup("/tmp/tpkg.XXXXXXXXXX")) == NULL)
d339 1
a339 1
		args[nargs++] = strdup("-I");
d353 4
a356 10
	    args[nargs] = strdup("-C");
	    if (BaseDir) {
		size_t size = strlen(BaseDir)+2+strlen(p->name);
		args[nargs+1] = malloc(size);
		if (args[nargs+1] == NULL) {
		    cleanup(0);
		    errx(2, "can't get Cwd space");
		}
		snprintf(args[nargs+1], size, "%s/%s", BaseDir, p->name);
	    } else
d373 12
a384 2
    cp = format_comm(args);
    if ((ret = sxsystem(false, cp)) == -1) {
a386 2
	if (compression == 2)
	    unlink(lztmp);
d389 1
a389 1
    xfree(cp);
a399 19
	if (compression == 2)
	    unlink(lztmp);
	cleanup(0);
	errx(2, "%s command failed with code %d", "tar", ret);
    }

    if (compression != 2)
	return;
    /* apply LZMA compression */

    nargs = 0;
    cargs[nargs++] = "lzma";
    cargs[nargs++] = "-z9fc";
    cargs[nargs++] = lztmp;
    cargs[nargs] = NULL;
    cp = format_comm(cargs);
    if ((ret = sxsystem(true, cp))) {
	unlink(lztmp);
	unlink(tball);
d401 1
a401 1
	errx(2, "%s command failed with code %d", "lzma", ret);
a402 3
    unlink(lztmp);
    free(lztmp);
    xfree(cp);
@


1.12
log
@runcomm is no longer needed now, either
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.11 2008/10/12 15:35:21 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.11 2008/10/12 15:35:21 tg Exp $");
d414 1
a414 2
    /* oO -9 will not fit into default datasize ulimit */
    cargs[nargs++] = "-z7fc";
d418 1
a418 1
    if ((ret = sxsystem(false, cp))) {
@


1.11
log
@Support for LZMA compressed binary packages (experimental!)

Tested:
â€¢ tg@@bleu:/usr/ports/archivers/mpczar $ mmake PKG_SUFX=.clz install clean
â€¢ tg@@bleu:~ $ sudo pkg_upgrade -fva /usr/ports/Packages/ssfe-20070109-1.clz

Dependencies on LZMA are *not* handled automatically, also you must use
PKG_SUFX=.clz to enable and ensure lzma is installed prior. This is some-
what hacky, but our package tools suck anyway. The infrastructure allows
for other compressors such as bzip2 too (but that one is not much of a
saving compared to lzma (ratio) and gzip (resource usage) so I did *not*
add it), but in a *lot* of placesâ€¦ should unify that or better, rewrite
all of the package tools in mkshâ€¦ anyway, please test.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.10 2008/10/12 14:35:16 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.10 2008/10/12 14:35:16 tg Exp $");
d270 1
a270 1
    char *lztmp;
d383 2
a384 1
    if ((ret = runcomm("tar", nargs, args, NULL)) == -1) {
d391 1
d418 2
a419 1
    if ((ret = runcomm("lzma", nargs, cargs, tball))) {
d427 1
@


1.10
log
@generalise running of subcommand
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.9 2008/03/27 20:58:46 bsiegert Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.9 2008/03/27 20:58:46 bsiegert Exp $");
d264 1
d269 2
a270 1
    int i;
d279 12
d295 2
a296 2
    args[nargs++] = tball;
    if (strchr(fsuffix, 'z'))	/* Compress/gzip? */
d309 4
a312 6
    if (Verbose) {
        if (strchr(fsuffix, 'z'))
	    printf("Creating gzip'd tar ball in '%s'\n", tball);
        else
	    printf("Creating tar ball in '%s'\n", tball);
    }
d383 1
a383 1
    if ((ret = runcomm("tar", nargs, args)) == -1) {
d386 2
d400 19
d420 1
a420 1
	errx(2, "tar command failed with code %d", ret);
d422 2
@


1.9
log
@Reliability: Don't segfault when the pkgname is null. Found while preparing
(!) regression tests.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.8 2007/03/30 23:20:10 bsiegert Exp $ */
a28 1
#include <sys/wait.h>
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.8 2007/03/30 23:20:10 bsiegert Exp $");
a268 1
    pid_t pid;
d371 1
a371 12
    if (Verbose) {
    	printf("Running \"");
    	for (i = 0; i < nargs; i++) {
		printf("%s ", args[i]);
	}
	printf("\"\n");
    }
    pid = fork();
    if ( pid < 0 )
	err(2, "failed to fork");
    else if ( pid == 0 ) {
	execvp("tar", args);
d374 1
a374 1
	err(2, "failed to execute tar command");
a375 1
    wait(&ret);
@


1.8
log
@Implement one of the points from my todo list: @@emul directives for
plists. If EMUL is set in a port's Makefile (e.g. EMUL=linux for a port
which needs linux emulation), this fact is entered into the package.
pkg_add checks for the relevant emulation.

- introduce new piperead() function, which executes a command and reads
  one line of output. Carefully crafted to avoid errors.
- new option for pkg_create: -e gives an initial value for @@emul
- bsd.port.mk: add -e to PKG_ARGS if EMUL given
- new function have_emulation(): Is the emulation enabled (via sysctl
  -n) or, alternatively, are we already running the "right" OS?
- pkg_info: show @@emul directive
- documentation: document EMUL and @@emul
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.7 2006/11/19 22:16:36 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.7 2006/11/19 22:16:36 bsiegert Exp $");
d161 1
a161 1
    if (!strcmp(Prefix, "/usr")) {
@


1.7
log
@Refactor write_deps() to use write_file(). Rewrite write_file() to accept
a mode argument and a format string, change other invocations accordingly.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.6 2005/12/18 16:36:42 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.6 2005/12/18 16:36:42 tg Exp $");
d92 16
@


1.6
log
@Part 2 of the big commit:
* www/vbegin.php: don't output the UTF-8 BOM for now
* ports/Setup.sh: change order in which path is divined [1]
* ports/books/mirex: convert to CVS_DISTF
* ports/comms/ssfe: increase line length limit and history buffer size
* ports/infrastructure/install/setup.sh: sync path order with Setup.sh [1]
* ports/infrastructure/mk/bsd.port.mk: (_PORTPATH) sync default PATH [1]
* ports/infrastructure/mk/bsd.port.mk: (_UPGRADE_FLAGS) new, default to -a
* ports/infrastructure/mk/bsd.port.mk: (_upgrade) use it
* ports/infrastructure/mk/bsd.port.mk: (reupgrade) new target, set to -a -f
* ports/infrastructure/scripts/mkmcz: don't use $LOCALBASE, trust in PATH
* ports/infrastructure/mk/bsd.port.mk: (_CVS_FETCH) use _PORTPATH
* ports/infrastructure/pkgtools/create: treat /usr/info same as /usr/man
* ports/infrastructure/pkgtools/upgrade: fix path to temp +REQUIRED_BY
* ports/www/firesomething: break, suggest Opera-Linux/K-Meleon/Safari
* src/Makefile, src/gcc/Makefile.lang: if build GCJ, check if X11 installed
* src/Makefile, src/gnu/usr.bin/perl/Makefile.bsd-wrapper: defer h2ph
  execution to end of build
* src/distrib/lists: sync with pre-h2ph change
* src/etc/services: add openvpn, from IANA
* src/gcc/Makefile.inc, Makefile.lang: fragment out NO_*= stuff
* src/gcc/libjava/Makefile.bsd-wrapper: DEBUGPROGS is gone
* src/gnu/usr.bin/perl/Makefile.bsd-wrapper: flesh out h2ph, fix perms
* src/lib/libc/time/localtime.c: fix undefined extern
* ports/net/sirc/Makefile: automatically insert version into CTCP VERSION
* ports/net/sirc/dist/PROGRAMMING: document capab hooks
* ports/net/sirc/dist/dsircp: several hours of perl hacking with Club-Mate
  - publish $msgchannel, $talkserver [2]
  - support for CAPAB: publish $has_capab, $capab_cmd, $capab_response;
    add "capab" hook in reply
  - support for CAPAB IDENTIFY-MSG: publish $has_identifymsg; new
    $unverified, $unverified_m; enable automatically if present;
    change <...> [...] -...- to «...» [[...]] ¬...¬
  - /describe nick now looks [*] (or [[*]]) instead of *, /me now looks
    # instead of * if identified, to facilitate this conversion
  - fix abuse of U+0060
  - sort /names [2]
  - fix ^B ^_ ^V [2]
  - remove trailing whitespace on outgoing msgs [2]
  - remove trailing whitespace on incoming msgs
  - fix indentation
  - auto-split overlong lines (partially [2])
  - in NOTICE make nick bold too [2]
  - disable DCC since it crashes
  - beautify CTCP TIME replies
  - add ACCEPT command (for ratbox-ircd, e.g. Freeforge)
* ports/net/sirc/pkg/DESCR: summarise new features

[1] all for the sake of bsiegert@@ wanting to not have to souce a
    SetEnv.sh or SetEnv.csh before building in "default MirPorts"
    (i.e. LOCALBASE=/usr/mpkg SYSCONFDIR=/etc BINOWN=root SUDO=sudo)
[2] adapted from http://co.ordinate.org/sirc/
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.5 2005/12/17 02:36:26 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.5 2005/12/17 02:36:26 tg Exp $");
d181 2
a182 1
    write_file(COMMENT_FNAME, Comment);
d185 2
a186 1
    write_file(DESC_FNAME, Desc);
@


1.5
log
@* 4.4BSD.dist: var/spool/ftp and var/cron are permission trouble, nuke
* 4.4BSD.dist: we need one uname and gname for mtree to work
* create/create.h, create/pl.c: (check_list) add syshack flag to change
  man/ into share/man/
* create/perform.c: (pkg_perform) if the Prefix is /usr enable the new
  syshack flag if not just normalising the packaging list; be careful
  to not totally break for FAKE=no operation
* bsd.port.mk: (${WRKPKG}/mtree.spec) replace @@BINOWN@@ and @@BINGRP@@
* bsd.port.mk: (${PORTSDIR}/infrastructure/db/fake.mtree) use it
* bsd.port.mk: (MTREE_FILE+=) add 4.4BSD.dist if PREFIX=/usr
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.4 2005/09/12 22:59:54 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.4 2005/09/12 22:59:54 tg Exp $");
d150 2
a151 1
	    if (!pf || !s)
d153 1
a153 1
	    if (!isdir(s))
d155 7
a161 2
	    else if (rename(s, strconcat(pf, "/share/man")))
		err(1, "cannot rename %s to share/man", s);
@


1.4
log
@mirports_tar -> tar (and hope $PATH is right)
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.3 2005/05/22 03:52:46 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.3 2005/05/22 03:52:46 bsiegert Exp $");
d52 1
d139 1
a139 1
	check_list(home, &plist);
d144 17
d167 1
a167 1
    check_list(home, &plist);
@


1.3
log
@Add new PLIST commands: @@option ldcache, @@option gnu-ld, and @@option static.
@@ldcache is now DEPRECATED.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.2 2005/05/21 00:16:03 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.2 2005/05/21 00:16:03 tg Exp $");
d342 1
a342 1
	execvp("mirports_tar", args);
@


1.2
log
@* db/Makefile [SHOW_ONLY]
	new ifdef; includes <bsd.own.mk> instead of <mirports.sys.mk>
	  (for make with ___DISPLAY_MAKEVARS)
* install/Setup-Interix.sh
	fix PATH
	new MirMake version
* install/Setup.sh
	preliminary support for Interix:
	use BINOWN/BINGRP (via db/Makefile)
	adjust mtree; paths
* install/mirports.osdep.mk-darwin
	_PORTPATH like this is now default
* pkgtools:
	add/extract.c, delete/perform.c, lib/pen.c:
	  no chflags/chattr/chown/statfs on Interix
	create/perform.c: uncomment header not on Interix
	lib/Makefile: use mbcompat (only on Interix)
	lib/rcdb.c: don't acquire lock on Interix (XXX)
	mbcompat/bsd-arc4random.c:
	  fix includes etc.
	  add protos
	  whitespace cleanup
	mbcompat/mktemp.c:
	  conditionalise __warn_references
* pkgtools/pkg/Makefile: don't strip on install
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/create/perform.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $");
a279 2
		if (IsDylib)
			errx(2, "ask bsiegert@@ to add special @@lib support for dylibs");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS$ */
d26 1
d28 1
d36 1
a36 1
__RCSID("$MirOS$");
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@
