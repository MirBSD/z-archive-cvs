head	1.26;
access;
symbols
	bsiegert-cfgfile_BASE:1.25
	bsiegert-cfgfile:1.25.0.2
	MIRBSD_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.26
date	2017.07.20.21.15.53;	author tg;	state Exp;
branches;
next	1.25;
commitid	10059711D89780CE021;

1.25
date	2009.12.11.22.16.13;	author bsiegert;	state Exp;
branches
	1.25.2.1;
next	1.24;
commitid	1004B22BFA76EA101EC;

1.24
date	2009.11.29.13.36.53;	author bsiegert;	state Exp;
branches;
next	1.23;
commitid	1004B1278FD2117E874;

1.23
date	2009.11.22.15.34.14;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004B0959E8012B753D;

1.22
date	2009.08.19.18.30.11;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004A8C44C94C0217DA;

1.21
date	2008.11.16.23.07.18;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004920A79C120FCC26;

1.20
date	2008.11.11.02.50.08;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004918F2E56B329425;

1.19
date	2008.11.02.19.57.31;	author tg;	state Exp;
branches;
next	1.18;
commitid	100490E06234C7ACE08;

1.18
date	2008.11.02.18.56.29;	author tg;	state Exp;
branches;
next	1.17;
commitid	100490DF7B930A3A3BD;

1.17
date	2008.11.02.18.19.52;	author tg;	state Exp;
branches;
next	1.16;
commitid	100490DEF535C71F010;

1.16
date	2008.11.02.17.39.05;	author tg;	state Exp;
branches;
next	1.15;
commitid	100490DE5CE4F1F7AA6;

1.15
date	2008.10.12.15.35.22;	author tg;	state Exp;
branches;
next	1.14;
commitid	10048F218B2228D17F9;

1.14
date	2007.03.01.23.03.50;	author tg;	state Exp;
branches;
next	1.13;
commitid	10045E75BE7718525D8;

1.13
date	2006.11.19.22.34.07;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004560DBF46435018A;

1.12
date	2006.11.19.22.16.36;	author bsiegert;	state Exp;
branches;
next	1.11;
commitid	1004560D7992BF407CE;

1.11
date	2006.09.24.20.40.48;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004516ED663E6E662E;

1.10
date	2006.09.24.20.24.54;	author bsiegert;	state Exp;
branches;
next	1.9;
commitid	1004516E94673638815;

1.9
date	2006.02.26.00.23.58;	author bsiegert;	state Exp;
branches;
next	1.8;
commitid	1004400F444185869DA;

1.8
date	2006.02.25.15.49.55;	author bsiegert;	state Exp;
branches;
next	1.7;
commitid	10044007C2C1AC43BDA;

1.7
date	2006.02.09.09.08.08;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043EB067E1C5E7338;

1.6
date	2005.11.15.19.33.59;	author tg;	state Exp;
branches;
next	1.5;
commitid	7927437a38332782;

1.5
date	2005.09.12.22.59.55;	author tg;	state Exp;
branches;
next	1.4;
commitid	515c4326087549fe;

1.4
date	2005.09.12.22.53.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	6e6c432606e897b6;

1.3
date	2005.08.21.20.15.45;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	4cd74308e0708a68;

1.2
date	2005.06.24.15.18.57;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	be442bc243d5ecc;

1.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.25.2.1
date	2009.12.29.17.09.32;	author bsiegert;	state Exp;
branches;
next	1.25.2.2;
commitid	1004B3A36D83259360D;

1.25.2.2
date	2010.02.27.16.20.18;	author bsiegert;	state Exp;
branches;
next	1.25.2.3;
commitid	1004B8945DC0802C02F;

1.25.2.3
date	2010.03.04.18.03.38;	author bsiegert;	state Exp;
branches;
next	1.25.2.4;
commitid	1004B8FF5740BB7941D;

1.25.2.4
date	2010.05.11.19.08.07;	author bsiegert;	state Exp;
branches;
next	1.25.2.5;
commitid	1004BE9AAFA11BE7160;

1.25.2.5
date	2010.05.13.16.28.56;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004BEC21492BE6507B;

1.2.2.1
date	2005.09.11.01.05.44;	author tg;	state Exp;
branches;
next	;
commitid	2f08432382e315cf;

1.1.7.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@.lz and .tlz are claimed by lzip, drop most LZMA-Alone support
(one thing in which Lasse and Antonio agree)
@
text
@/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.24 2009/11/29 13:36:53 bsiegert Exp $ */
/* $OpenBSD: file.c,v 1.26 2003/08/21 20:24:57 espie Exp $	*/

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * Miscellaneous file access utilities.
 */

#include "lib.h"

#include <sys/wait.h>

#include <assert.h>
#include <err.h>
#include <netdb.h>
#include <pwd.h>
#include <time.h>
#include <glob.h>
#include <libgen.h>
#include <unistd.h>

__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.24 2009/11/29 13:36:53 bsiegert Exp $");

/* valid file extensions for packages, in order of priority
   (highest to lowest)
 */
static const char *pkgexts[] = {
    	".cgz",
	".cxz",
	".tgz",
	".tar",
	".cpio",
	".tar.gz",
	NULL
};

/* Try to find the log dir for an incomplete package specification.
 * Used in pkg_info and pkg_delete. Returns the number of matches,
 * or -1 on error.
 */
int
glob_package(char *log_dir, size_t len, const char *pkg)
{
	const char *tmp;
	glob_t pglob;
	int matches;

	if (!(tmp = getenv(PKG_DBDIR)))
		tmp = DEF_LOG_DIR;

	if (strchr(pkg, '/')) {
		if (strncmp(pkg, tmp, strlen(tmp))) {
			pwarnx("package name contains a / and is not under the '%s' directory!", tmp);
			return -1;
		}
		(void) snprintf(log_dir, len, "%s", pkg);
	} else
		(void) snprintf(log_dir, len, "%s/%s", tmp, pkg);

	if (fexists(log_dir))
		return 1;
	if (trim_end(log_dir) && fexists(log_dir))
		return 1;

	/* if all else fails, do the glob */
	memset(&pglob, 0, sizeof(pglob));
	(void) snprintf(log_dir, len, "%s/%s-[0-9]*", tmp, pkg);
	glob(log_dir, 0, NULL, &pglob);
	matches = pglob.gl_pathc;
	if (matches > 0)
		(void) snprintf(log_dir, len, "%s",
				pglob.gl_pathv[0]);
	else
		*log_dir = '\0';
	if (matches > 1) {
		int i;
		printf("Hint: The following versions of this package are installed:\n");
		for (i = 0; i < matches; i++)
			printf(" %s\n", basename(pglob.gl_pathv[i]));
	}

	globfree(&pglob);
	return matches;
}

/* Try to remove the extension from a package name */
int
trim_end(char *name)
{
	size_t n, m;
	const char **suff;

	n = strlen(name);
	for (suff = pkgexts; *suff; suff++) {
		if (n > (m = strlen(*suff)) && !strcmp(name + n - m, *suff)) {
			name[n - m] = '\0';
			return 1;
		}
	}
	return 0;
}

/* Try to find a package with the name "fname" in directory "dir",
   returning the match (full pathname) in "buffer", if any. The return value
   indicates whether something was found. "buffer" is overwritten in any case.
 */
bool
pkg_existing(const char *dir, char *fname, char *buffer, size_t bufsiz)
{
	size_t len;
	const char **suff;
	char *cp;

	if (!strcmp(fname, "-")) {
		strlcpy(buffer, fname, bufsiz);
		return true;
	}

	if (ispkgpattern(fname) &&
			(cp = findbestmatchingname(dir, fname)) != NULL) {
		if (dir && strcmp(dir, "."))
			snprintf(buffer, bufsiz, "%s/%s", dir, cp);
		else
			strlcpy(buffer, cp, bufsiz);
		free(cp);
		return true;
	}

	/* If it already has a suffix from the allowed ones, try it */
	snprintf(buffer, bufsiz, "%s/%s", dir, fname);
	len = strlen(buffer);
	for (suff = pkgexts; *suff; suff++) {
		if ((len >= strlen(*suff)) &&
				!strcmp(buffer + len - strlen(*suff), *suff)
				&& fexists(buffer) && isfile(buffer))
			return true;
	}

	/* if not, try with a suffix */
	for (suff = pkgexts; *suff; suff++) {
		snprintf(buffer, bufsiz, "%s/%s%s", dir, fname, *suff);
		if (fexists(buffer) && isfile(buffer))
			return true;
	}

	return false;
}

/* This fixes errant package names so they end up in .tgz/.cgz.
   XXX returns static storage, so beware! Consume the result
	before reusing the function.
 */
char *
ensure_tgz(char *name)
{
	static char buffer[FILENAME_MAX];
	size_t len;
	const char **suff;

	len = strlen(name);
	if (!strcmp(name, "-"))
		return name;
	
	for (suff = pkgexts; *suff; suff++) {
		if ((len >= strlen(*suff)) &&
				!strcmp(name + len - strlen(*suff), *suff))
			return name;
	}

	snprintf(buffer, sizeof(buffer), "%s.cgz", name);
	return (buffer);
}

/* This is as ftpGetURL from FreeBSDs ftpio.c, except that it uses
 * OpenBSDs ftp command to do all FTP.
 */
static FILE *
ftpGetURL(char *url, int *retcode)
{
	FILE *ftp;
	pid_t pid_ftp;
	int p[2];

	*retcode=0;

	if (pipe(p) < 0) {
		*retcode = 1;
		return NULL;
	}

	pid_ftp = fork();
	if (pid_ftp < 0) {
		*retcode = 1;
		return NULL;
	}
	if (pid_ftp == 0) {
		/* child */
		dup2(p[1],1);
		close(p[1]);

		fprintf(stderr, ">>> ftp -o - %s\n",url);
		execlp("ftp", "ftp", "-V", "-o", "-", url, NULL);
		exit(1);
	} else {
		/* parent */
		ftp = fdopen(p[0],"r");

		close(p[1]);

		if (ftp == NULL) {
			*retcode = 1;
			return NULL;
		}
	}
	return ftp;
}

/* Quick check to see if a file exists */
bool
fexists(const char *fname)
{
    struct stat dummy;
    if (!lstat(fname, &dummy))
	return true;
    return false;
}

/* Quick check to see if something is a directory */
bool
isdir(const char *fname)
{
    struct stat sb;

    if (lstat(fname, &sb) != -1 && S_ISDIR(sb.st_mode))
	return true;
    else
	return false;
}

/* Check if something is a symbolic link */
bool
islink(const char *fname)
{
    struct stat sb;

    return (lstat(fname, &sb) != -1 && S_ISLNK(sb.st_mode));
}

/* Check if something is a link to a directory */
bool
islinktodir(const char *fname)
{
    struct stat sb;

    if (islink(fname))
        if (stat(fname, &sb) != -1 && S_ISDIR(sb.st_mode))
	    return true; /* link to dir! */
        else
	    return false; /* link to non-dir */
    else
        return false;  /* non-link */
}

/* Check to see if file is a dir, and is empty */
bool
isemptydir(const char *fname)
{
    if (isdir(fname) || islinktodir(fname)) {
	DIR *dirp;
	struct dirent *dp;

	dirp = opendir(fname);
	if (!dirp)
	    return false;	/* no perms, leave it alone */
	while ((dp = readdir(dirp)) != NULL) {
	    if (strcmp(dp->d_name, ".") && strcmp(dp->d_name, "..")) {
		closedir(dirp);
		return false;
	    }
	}
	(void)closedir(dirp);
	return true;
    }
    return false;
}

bool
isfile(const char *fname)
{
    struct stat sb;
    if (stat(fname, &sb) != -1 && S_ISREG(sb.st_mode))
	return true;
    return false;
}

/* Check to see if file is a file and is empty. If nonexistent or not
   a file, say "it's empty", otherwise return true if zero sized. */
bool
isemptyfile(const char *fname)
{
    struct stat sb;
    if (stat(fname, &sb) != -1 && S_ISREG(sb.st_mode)) {
	if (sb.st_size != 0)
	    return false;
    }
    return true;
}

/* Returns true if file is a URL specification */
bool
isURL(const char *fname)
{
    /*
     * Hardcode url types... not perfect, but working.
     */
    if (!fname)
	return false;
    while (isspace(*fname))
	++fname;
    if (!strncmp(fname, "ftp://", 6))
	return true;
    if (!strncmp(fname, "http://", 7))
	return true;
    if (!strncmp(fname, "https://", 8))
	return true;
    return false;
}

/* Returns the host part of a URL */
char *
fileURLHost(char *fname, char *where, int max)
{
    char *ret;

    while (isspace(*fname))
	++fname;
    /* Don't ever call this on a bad URL! */
    if ((fname = strchr(fname, ':')) == NULL)
	return NULL;
    fname += 3;
    /* Do we have a place to stick our work? */
    if ((ret = where) != NULL) {
	while (*fname && *fname != '/' && max--)
	    *where++ = *fname++;
	*where = '\0';
	return ret;
    }
    /* If not, they must really want us to stomp the original string */
    ret = fname;
    while (*fname && *fname != '/')
	++fname;
    *fname = '\0';
    return ret;
}

/* Returns the filename part of a URL */
char *
fileURLFilename(char *fname, char *where, int max)
{
    char *ret;

    while (isspace(*fname))
	++fname;
    /* Don't ever call this on a bad URL! */
    if ((fname = strchr(fname, ':')) == NULL)
	return NULL;
    fname += 3;
    /* Do we have a place to stick our work? */
    if ((ret = where) != NULL) {
	while (*fname && *fname != '/')
	    ++fname;
	if (*fname == '/') {
	    while (*fname && max--)
		*where++ = *fname++;
	}
	*where = '\0';
	return ret;
    }
    /* If not, they must really want us to stomp the original string */
    while (*fname && *fname != '/')
	++fname;
    return fname;
}

/*
 * Try and fetch a file by URL, returning the directory name for where
 * it's unpacked, if successful.
 */
char *
fileGetURL(char *base, char *spec)
{
    char host[MAXHOSTNAMELEN], file[FILENAME_MAX];
    char *cp, *rp;
    char fname[FILENAME_MAX];
    char pen[FILENAME_MAX];
    FILE *ftp;
    pid_t tpid;
    int status;
    char *hint;

    rp = NULL;
    /* Special tip that sysinstall left for us */
    hint = getenv("PKG_ADD_BASE");
    if (!isURL(spec)) {
	if (!base && !hint)
	    return NULL;
	/* We've been given an existing URL (that's known-good) and now we need
	   to construct a composite one out of that and the basename we were
	   handed as a dependency. */
	if (base) {
	    strlcpy(fname, base, sizeof(fname));
	    /* OpenBSD packages are currently stored in a flat space, so
	       we don't yet need to backup the category and switch to all.
	     */
	    cp = strrchr(fname, '/');
	    if (cp) {
		*(cp + 1) = '\0';
		strlcat(fname, ensure_tgz(spec), sizeof(fname));
	    }
	    else
		return NULL;
	}
	else {
	    /* Otherwise, we've been given an environment variable hinting at the right location from sysinstall */
	    snprintf(fname, sizeof(fname), "%s%s", hint, spec);
	}
    }
    else
	strlcpy(fname, spec, sizeof(fname));
    cp = fileURLHost(fname, host, sizeof(host));
    if (!*cp) {
	pwarnx("URL '%s' has bad host part!", fname);
	return NULL;
    }

    cp = fileURLFilename(fname, file, sizeof(fname));
    if (!*cp) {
	pwarnx("URL '%s' has bad filename part!", fname);
	return NULL;
    }

    if (Verbose)
	printf("Trying to fetch %s.\n", fname);
    ftp = ftpGetURL(fname, &status);
    if (ftp) {
	pen[0] = '\0';
	if ((rp = make_playpen(pen, sizeof(pen), 0)) != NULL) {
            rp=strdup(pen); /* be safe for nested calls */
	    if (Verbose)
		printf("Extracting from FTP connection into %s\n", pen);
	    tpid = fork();
	    if (!tpid) {
		const char *decompressor = "cat";

		if ((cp = strrchr(fname, '.'))) {
			if (!strcmp(cp, ".cxz"))
			    decompressor = "xzdec";
			else if (strchr(cp, 'z') || strchr(cp, 'Z'))
			    decompressor = "gzip -fdc";
		}
		dup2(fileno(ftp), 0);
		exit(xsystem(false, "%s | tar -x%spf -", decompressor,
		    Verbose ? "v" : ""));
	    }
	    else {
		int pstat;

		fclose(ftp);
		waitpid(tpid, &pstat, 0);
		if (Verbose)
		    printf("tar command returns %d status\n", WEXITSTATUS(pstat));
	    }
	}
	else
	    printf("Error: Unable to construct a new playpen for FTP!\n");
	fclose(ftp);
    }
    else
	printf("Error: FTP Unable to get %s: %s\n",
	       fname,
	       status ? "Error while performing FTP" :
	       hstrerror(h_errno));
    return rp;
}

char *
fileFindByPath(char *base, char *fname)
{
	static char tmp[FILENAME_MAX];
	char *pkg_path;

	if (pkg_existing(".", fname, tmp, sizeof (tmp)))
		return tmp;
	if (base && pkg_existing(dirname(base), fname, tmp, sizeof (tmp)))
		return tmp;

	pkg_path = getenv("PKG_PATH");
	/* Check for ftp://... paths */
	if (isURL(pkg_path)) {
		/* FIXME need to probe all extensions here, too */
		snprintf(tmp, sizeof(tmp), "%s/%s", pkg_path,
				ensure_tgz(fname));
		return tmp;
	}
	while (pkg_path) {
		char *cp = strsep(&pkg_path, ":");

		if (pkg_existing(cp, fname, tmp, sizeof (tmp)))
			return tmp;
	}

	return NULL;
}

char *
fileGetContents(char *fname)
{
    char *contents;
    struct stat sb;
    int fd;

    if (stat(fname, &sb) == -1) {
	cleanup(0);
	errx(2, "can't stat '%s'", fname);
    }

    contents = (char *)malloc((size_t)(sb.st_size) + 1);
    if ((fd = open(fname, O_RDONLY, 0)) == -1) {
	cleanup(0);
	errx(2, "unable to open '%s' for reading", fname);
    }
    if (read(fd, contents, (size_t) sb.st_size) != (ssize_t) sb.st_size) {
	cleanup(0);
	errx(2, "short read on '%s' - did not get %lld bytes",
			fname, (int64_t)sb.st_size);
    }
    close(fd);
    contents[(size_t)sb.st_size] = '\0';
    return contents;
}

/* Takes a filename and package name, returning (in "try") the canonical "preserve"
 * name for it.
 */
bool
make_preserve_name(char *try, size_t max, char *name, char *file)
{
    char *p;
    size_t i;

    i = strlcpy(try, file, max);
    if (i == 0 || i >= max)
	return false;

    /* Catch trailing slash early */
    i--;
    if (try[i] == '/')
	try[i] = '\0';

    p = strrchr(try, '/');
    if (p == NULL)
	p = try;
    else
	p++;

    i = p - try;
    if (snprintf(p, max - i, ".%s.%s.backup", file + i, name) >= (int)(max - i))
	return false;

    return true;
}

/* Write the contents of "str" to a file. mode is "a" or "w". */
/* Returns 1 on failure, 0 on success */
int
write_file(const char *filename, const char *mode, const char *fmt, ...)
{
    va_list ap;
    FILE *cfile;

    va_start(ap, fmt);

    cfile = fopen(filename, mode);
    if (!cfile) {
	pwarn("cannot open file '%s' for writing", filename);
	return 1;
    }
    vfprintf(cfile, fmt, ap);
    if (fclose(cfile) == EOF) {
	pwarn("cannot properly close file '%s'", filename);
	return 1;
    }
    return 0;
}

void
copy_file(const char *dir, const char *fname, const char *to)
{
	char *cmd, *a1, *a2, *a3;

	a1 = format_arg(fname);
	a2 = format_arg(to);
	if (fname[0] == '/')
		xasprintf(&cmd, "cp -p -r %s %s", a1, a2);
	else {
		xasprintf(&cmd, "cp -p -r %s/%s %s",
		    (a3 = format_arg(dir)), a1, a2);
		xfree(a3);
	}
	xfree(a2);
	xfree(a1);
	if (sxsystem(false, cmd)) {
		cleanup(0);
		errx(2, "could not perform %s", cmd);
	}
	xfree(cmd);
}

void
move_file(const char *dir, const char *fname, char *to)
{
	char *cmd, *a1, *a2, *a3;

	a1 = format_arg(fname);
	a2 = format_arg(to);
	if (fname[0] == '/')
		xasprintf(&cmd, "mv -f %s %s", a1, a2);
	else {
		xasprintf(&cmd, "mv -f %s/%s %s",
		    (a3 = format_arg(dir)), a1, a2);
		xfree(a3);
	}
	xfree(a1);
	if (sxsystem(false, cmd)) {
		cleanup(0);
		errx(2, "could not perform %s", cmd);
	}
	xfree(cmd);
#ifdef AS_USER
	if (!geteuid()) {
		/* no error handling, we don't care if chown fails */
		xsystem(false, "chown -f %s %s",
		    a1 = format_arg(getlogin()), to);
		xfree(a1);
	}
	xfree(a2);
#endif
}

/*
 * Copy a hierarchy (possibly from dir) to the current directory, or
 * if "to" is true, from the current directory to a location someplace
 * else.
 *
 * Though slower, using tar to copy preserves symlinks and everything
 * without me having to write some big hairy routine to do it.
 */
void
copy_hierarchy(const char *dir, char *fname, bool to)
{
	char *cmd, *a1, *a2;

	a2 = format_arg(fname);
	if (!to) {
		/* If absolute path, use it */
		if (*fname == '/')
			dir = "/";
		xasprintf(&cmd, "tar cf - -C %s %s | tar xpf -",
		    (a1 = format_arg(dir)), a2);
	} else
		xasprintf(&cmd, "tar cf - %s | tar xpf - -C %s",
		    a2, (a1 = format_arg(dir)));
#ifdef DEBUG
	printf("Using '%s' to copy trees.\n", cmd);
#endif
	xfree(a1);
	xfree(a2);
	if (sxsystem(false, cmd)) {
		cleanup(0);
		errx(2, "copy_file: could not perform %s", cmd);
	}
	xfree(cmd);
}

/* Unpack a tar file */
int
unpack(char *pkg, const char *flist)
{
	char *a1, *a2;
	const char *decompressor = NULL;
	int rv = 0;

	a1 = format_arg(pkg);
	a2 = format_arg(flist ? flist : "");

	/* figure out by a crude heuristic whether it's probably compressed */
	if (strcmp(pkg, "-")) {
		char *cp;
		if ((cp = strrchr(pkg, '.'))) {
			if (!strcmp(cp, ".cxz"))
				decompressor = "xzdec";
			else if (strchr(cp, 'z') || strchr(cp, 'Z'))
				decompressor = "gzip -fdc";
		} else
			decompressor = "gzip -fdc";
	}

	if (decompressor)
		rv = xsystem(false, "%s <%s | tar -xpf - %s",
		    decompressor, a1, a2);
	else
		rv = xsystem(false, "tar -xpf %s %s", a1, a2);
	if (rv)
		pwarnx("tar extract of %s failed!", a1);
	xfree(a2);
	xfree(a1);
	return (rv ? 1 : 0);
}

/*
 * Using fmt, replace all instances of:
 *
 * %F	With the parameter "name"
 * %D	With the parameter "dir"
 * %B	Return the directory part ("base") of %D/%F
 * %f	Return the filename part of %D/%F
 *
 */
int
format_cmd(char *buf, size_t size, const char *fmt,
	const char *dir, const char *name)
{
	char *pos;
	size_t len;

	while (*fmt != 0 && size != 0) {
		if (*fmt == '%') {
			switch(fmt[1]) {
			case 'f':
				if (name == NULL)
					return 0;
				pos = strrchr(name, '/');
				if (pos != NULL) {
					pos++;
					len = strlen(name) - (pos-name);
					if (len >= size)
						return 0;
					memcpy(buf, pos, len);
					buf += len;
					size -= len;
					fmt += 2;
					continue;
				}
				/* FALLTHRU */
			case 'F':
				if (name == NULL)
					return 0;
				len = strlen(name);
				if (len >= size)
					return 0;
				memcpy(buf, name, len);
				buf += len;
				size -= len;
				fmt += 2;
				continue;
			case 'D':
				if (dir == NULL)
					return 0;
				len = strlen(dir);
				if (len >= size)
					return 0;
				memcpy(buf, dir, len);
				buf += len;
				size -= len;
				fmt += 2;
				continue;
			case 'B':
				if (dir == NULL || name == NULL)
					return 0;
				len = strlen(dir);
				if (len >= size)
					return 0;
				memcpy(buf, dir, len);
				buf += len;
				size -= len;
				if ((pos = strrchr(name, '/')) != NULL) {
					*buf++ = '/';
					size--;
					if ((size_t)(pos - name) >= size)
						return 0;
					memcpy(buf, name, (size_t)(pos - name));
					buf += pos-name;
					size -= pos-name;
				}
				fmt += 2;
				continue;
			case '%':
				fmt++;
			default:
				break;

			}
		}
		*buf++ = *fmt++;
		size--;
	}
	if (size == 0)
		return 0;
	else
	    *buf = '\0';
	return 1;
}
@


1.25
log
@Implement (most of) the feature requested by tg@@: automatically loaded
dependencies (and pkg_info for good measure, which uses the same function)
can find packages using any supported file extension, not just .cgz. For ftp
URLs, .cgz is the only extension tested by default for now, this will come
later.

While here, also clean up a lot of functions like ensure_tgz(): use _one_
static list of supported extensions, in order of priority, highest first. ALL
functions that check extensions now traverse the list. Saves several gotos
and auxiliary macros. In fileFindByPath(), throw out redundant code, introduce
a new function pkg_existing() which does the actual work.
@
text
@a43 1
	".clz",
a471 2
			else if (!strcmp(cp, ".clz"))
			    decompressor = "lzmadec";
a715 2
			else if (!strcmp(cp, ".clz"))
				decompressor = "lzmadec";
@


1.25.2.1
log
@Experimental support for the config file in pkg_info and pkg_add. Packages
given as command-line arguments are found in the paths specified in "Source"
lines. Tested in pkg_info:

% pkg_info tiff-cxx-3.7.4-1

finds the uninstalled package in /usr/ports/Packages.

Oh, and PKG_PATH support is dropped for now.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25 2009/12/11 22:16:13 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25 2009/12/11 22:16:13 bsiegert Exp $");
d507 20
a526 28
	bool found = false;
	const struct cfg_sourcelist *srcs;
	struct cfg_source *sp;

	srcs = cfg_get_sourcelist();

	if (base)
		cfg_add_source(1L, isURL(base), base);

	/* there used to be a hard-coded check for the "." directory here.
	 * This is now controlled by the sourcelist from the config file.
	 * If you did not put "." there, then there is nothing we can do
	 * for you.
	 */ 

	LIST_FOREACH(sp, srcs, entries) {
		if (sp->remote) {
			snprintf(tmp, sizeof(tmp), "%s/%s", sp->source,
					ensure_tgz(fname));
			/* FIXME needs to be implemented */
			found = true;
			break;
		} else {
			if (pkg_existing(sp->source, fname, tmp, sizeof(tmp))) {
				found = true;
				break;
			}
		}
d528 2
a529 4
	
	if (base)
		cfg_remove_source(base);
	return found ? tmp : NULL;
@


1.25.2.2
log
@Implement a function to cache the "index.txt" file for remote sources. Also
move some defines to lib.h.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.1 2009/12/29 17:09:32 bsiegert Exp $ */
d36 1
a36 4
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.1 2009/12/29 17:09:32 bsiegert Exp $");

/* block size for file copying */
#define BLOCKSIZE 1024
a841 49

void
update_src_index(void)
{
	const struct cfg_sourcelist *srcs;
	const struct cfg_source *sp;
	char remotename[FILENAME_MAX];
	char buf[BLOCKSIZE];
	FILE *ftpconn, *local;
	int ftpstatus;
	size_t nbytes;

	if (!isdir(CACHEDIR) && mkdir(CACHEDIR, 0755) == -1)
		err(1, "Could not create source cache directory");

	srcs = cfg_get_sourcelist();

	LIST_FOREACH(sp, srcs, entries) {
		if (!sp->remote)
			continue;
		snprintf(remotename, sizeof(remotename), "%s%sindex.txt",
				sp->source,
				sp->source[strlen(sp->source)-1] == '/' ?
				"" : "/");
		if (Verbose)
			fprintf(stderr, "Fetching index file %s\n", remotename);

		if (!(local = fopen(src_index_name(sp->source), "w")))
			err(1, "Could not open local cache file for writing");

		ftpconn = ftpGetURL(remotename, &ftpstatus);
		if (!ftpstatus) {
			fclose(local);
			err(1, "Could not open FTP connection");
		}

		/* copy from file to file */
		do {
			nbytes = fread(buf, sizeof (char), BLOCKSIZE, ftpconn);
			fwrite(buf, sizeof (char), nbytes, local);
		} while (nbytes == BLOCKSIZE);

		if (ferror(ftpconn) || ferror(local))
			err(1, "Error fetching the index file");

		fclose(local);
		fclose(ftpconn);
	}
}
@


1.25.2.3
log
@Continue on the cfgfile branch:
Introduce a new function findmatchingname_file(), which searches in the cached
index files for a package.
Introduce a function findmatchingname_srcs(), which iterates over all the
sources and returns a list of _all_ matches, minus those sorted out by a
helper function.

Builds fine, but the code is still untested.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.2 2010/02/27 16:20:18 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.2 2010/02/27 16:20:18 bsiegert Exp $");
d876 1
a876 1
		if (ftpstatus) {
@


1.25.2.4
log
@Implement a "selection menu" if fileFindByPath() finds more than one package
matching the pattern. I do not yet know if this is the right way to handle
this, consider it experimental.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.3 2010/03/04 18:03:38 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.3 2010/03/04 18:03:38 bsiegert Exp $");
d512 1
a512 4
	/*struct cfg_source *sp;*/
	struct matchlist *matches;
	struct match *mp = NULL;
	int choice;
d525 7
a531 6

	matches = findmatchingname_srcs(srcs, fname);
	if (!TAILQ_EMPTY(matches)) {
		if (TAILQ_FIRST(matches) == TAILQ_LAST(matches, matchlist)) {
			/* one match */
			mp = TAILQ_FIRST(matches);
d533 4
a536 10
			print_matchlist_menu(matches);
			if ((scanf("%d", &choice)) == 1)
				mp = match_by_number(matches, choice);
		}
		if (mp) {
			assert(mp->pkgname != NULL);
			assert(mp->source != NULL);
			snprintf(tmp, sizeof(tmp), "%s/%s",
					mp->source, mp->pkgname);
			found = true;
a538 2
	matchlist_destroy(matches);
	free(matches);
@


1.25.2.5
log
@- file.c: also look for pkgname.cgz and pkgname->=0 if lookup fails
- perform.c: turn logic around, much better now

Read more about this commit in my upcoming wlog entry.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.4 2010/05/11 19:08:07 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.25.2.4 2010/05/11 19:08:07 bsiegert Exp $");
a529 10
	if (TAILQ_EMPTY(matches)) {
		matchlist_destroy(matches);
		/* XXX need to check all extensions in order */
		matches = findmatchingname_srcs(srcs, ensure_tgz(fname));
	}
	if (TAILQ_EMPTY(matches)) {
		matchlist_destroy(matches);
		snprintf(tmp, sizeof(tmp), "%s->=0", fname);
		matches = findmatchingname_srcs(srcs, tmp);
	}
@


1.24
log
@/usr/ports/infrastructure/pkgtools/lib/file.c:433:3: warning: Value stored to 'tpid' is never read
                tpid = waitpid(tpid, &pstat, 0);
                ^      ~~~~~~~~~~~~~~~~~~~~~~~~
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.23 2009/11/22 15:34:14 tg Exp $ */
d36 15
a50 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.23 2009/11/22 15:34:14 tg Exp $");
d106 2
d109 6
a114 14

#define check(suff) do {			\
	if (n > (m = strlen(suff)) &&		\
	    !strcmp(name + n - m, (suff)))	\
		goto found;			\
} while (/* CONSTCOND */ 0)
	check(".cgz");
	check(".cxz");
	check(".clz");
	check(".tgz");
	check(".tar");
	check(".cpio");
	check(".tar.gz");
#undef check
a115 3
 found:
	name[n - m] = 0;
	return 1;
d118 45
a167 2
#define	CHK_NAME(name,len,ext)	((len >= strlen(ext)) && \
				 !strcmp(name + len - strlen(ext), ext))
d173 1
d176 9
a184 9
	if ((strcmp(name, "-") == 0) ||
	    CHK_NAME(name,len,".cgz") ||
	    CHK_NAME(name,len,".cxz") ||
	    CHK_NAME(name,len,".clz") ||
	    CHK_NAME(name,len,".tgz") ||
	    CHK_NAME(name,len,".tar") ||
	    CHK_NAME(name,len,".cpio") ||
	    CHK_NAME(name,len,".tar.gz"))
		return (name);
d507 1
a507 1
	char *cp;
d509 4
a512 15
	if (ispkgpattern(fname)) {
		if ((cp=findbestmatchingname(".",fname)) != NULL) {
			strlcpy(tmp, cp, sizeof(tmp));
			free(cp);
			return tmp;
		}
	} else {
		strlcpy(tmp, ensure_tgz(fname), sizeof(tmp));
		if (fexists(tmp) && isfile(tmp)) {
			return tmp;
		}
	}

	if (base) {
		strlcpy(tmp, base, sizeof(tmp));
d514 1
a514 25
		cp = strrchr(tmp, '/');
		if (cp) {
			*(cp + 1) = '\0';
			strlcat(tmp, ensure_tgz(fname), sizeof(tmp));
			if (ispkgpattern(tmp)) {
				cp=findbestmatchingname(dirname(tmp),
							basename(tmp));
				if (cp) {
					char *s;
					s=strrchr(tmp,'/');
					assert(s != NULL);
					strlcpy(s+1, cp,
					    (size_t)(tmp + sizeof(tmp) - (s+1)));
					free(cp);
					return tmp;
				}
			} else {
				if (fexists(tmp)) {
					return tmp;
				}
			}
		}
	}

	cp = getenv("PKG_PATH");
d516 4
a519 2
	if (isURL(cp)) {
		snprintf(tmp, sizeof(tmp), "%s/%s", cp, ensure_tgz(fname));
d522 2
a523 2
	while (cp) {
		char *cp2 = strsep(&cp, ":");
d525 2
a526 17
		snprintf(tmp, sizeof(tmp), "%s/%s", cp2, ensure_tgz(fname));
		if (ispkgpattern(tmp)) {
			char *s;
			s = findbestmatchingname(dirname(tmp),
						 basename(tmp));
			if (s){
				char *t;
				t=strrchr(tmp, '/');
				strlcpy(t+1, s, (size_t)(tmp + sizeof(tmp) - (t+1)));
				free(s);
				return tmp;
			}
		} else {
			if (fexists(tmp) && isfile(tmp)) {
				return tmp;
			}
		}
@


1.23
log
@support for the upcoming XZ Utils compression
planned for long, prodded by bsiegert@@
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.22 2009/08/19 18:30:11 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.22 2009/08/19 18:30:11 tg Exp $");
d437 1
a437 1
		tpid = waitpid(tpid, &pstat, 0);
@


1.22
log
@make this able to handle .cpio and .tar (interestingly enough, some
parts of the code also know .tar.Z but not all) for use on e.g. the
slow platforms (sparc etc) when re-compressing packages on a faster
machine afterwards
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.21 2008/11/16 23:07:18 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.21 2008/11/16 23:07:18 tg Exp $");
d100 1
d129 1
d422 3
a424 1
			if (!strcmp(cp, ".clz"))
d716 3
a718 1
			if (!strcmp(cp, ".clz"))
@


1.21
log
@correct gzip decompressor, spotted when actually trying to install
a binary package from ftp^Whttps… and cross-link in the manpage
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.20 2008/11/11 02:50:08 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.20 2008/11/11 02:50:08 tg Exp $");
d93 13
a105 25
	m = strlen(".tar.gz");
	if (n > m && strcmp(name+n-m, ".tar.gz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	m = strlen(".tgz");
	if (n > m && strcmp(name+n-m, ".tgz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	/* m = strlen(".cgz"); */
	if (n > m && strcmp(name+n-m, ".cgz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	/* m = strlen(".clz"); */
	if (n > m && strcmp(name+n-m, ".clz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	/* m = strlen(".tar"); */
	if (n > m && strcmp(name+n-m, ".tar") == 0) {
		name[n-m] = 0;
		return 1;
	}
d107 3
d126 10
a135 11
	if ( (strcmp (name, "-") == 0 )
	     || CHK_NAME(name,len,".cgz")
	     || CHK_NAME(name,len,".clz")
	     || CHK_NAME(name,len,".tgz")
	     || CHK_NAME(name,len,".tar.gz")
	     || CHK_NAME(name,len,".tar"))
		return name;
	  else {
		snprintf(buffer, sizeof(buffer), "%s.cgz", name);
		return buffer;
	}
@


1.20
log
@use lzmadec not lzma to decompress; mention PKG_SUFX while here
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.19 2008/11/02 19:57:31 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.19 2008/11/02 19:57:31 tg Exp $");
d433 1
a433 1
			    decompressor = "gzip";
d723 1
a723 1
				decompressor = "lzmadec <";
d725 1
a725 1
				decompressor = "gzip -fdc ";
d727 1
a727 1
			decompressor = "gzip -fdc ";
d731 1
a731 1
		rv = xsystem(false, "%s%s | tar -xpf - %s",
@


1.19
log
@sprinke a few format_arg for good measure

XXX need to look at format_cmd() as it operates on PLIST strings;
XXX we might want to escape %D %F etc. as well
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.18 2008/11/02 18:56:29 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.18 2008/11/02 18:56:29 tg Exp $");
d431 1
a431 1
			    decompressor = "lzma";
d723 1
a723 1
				decompressor = "lzma";
d725 1
a725 1
				decompressor = "gzip";
d727 1
a727 1
			decompressor = "gzip";
d731 1
a731 1
		rv = xsystem(false, "%s -fdc %s | tar -xpf - %s",
@


1.18
log
@• add new memory management functions (xcalloc, xrealloc, xfree, xstrdup,
  xasprintf, xvasprintf)
• add new process calling functions which can optionally unlimit datasize
• add safe formatting functions (untested)
• retire asystem for xsystem
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.17 2008/11/02 18:19:52 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.17 2008/11/02 18:19:52 tg Exp $");
d621 1
a621 1
    char cmd[FILENAME_MAX];
d623 16
a638 8
    if (fname[0] == '/')
	snprintf(cmd, sizeof(cmd), "cp -p -r %s %s", fname, to);
    else
	snprintf(cmd, sizeof(cmd), "cp -p -r %s/%s %s", dir, fname, to);
    if (xsystem(false, "%s", cmd)) {
	cleanup(0);
	errx(2, "could not perform '%s'", cmd);
    }
d644 1
a644 1
    char cmd[FILENAME_MAX];
d646 15
a660 8
    if (fname[0] == '/')
	snprintf(cmd, sizeof(cmd), "mv -f %s %s", fname, to);
    else
	snprintf(cmd, sizeof(cmd), "mv -f %s/%s %s", dir, fname, to);
    if (xsystem(false, "%s", cmd)) {
	cleanup(0);
	errx(2, "could not perform '%s'", cmd);
    }
d662 7
a668 3
    if (!geteuid())
	xsystem(false, "chown -f %s %s", getlogin(), to);
    /* no error handling, we don't care if chown fails */
d683 1
a683 1
    char cmd[FILENAME_MAX * 3];
d685 10
a694 10
    if (!to) {
	/* If absolute path, use it */
	if (*fname == '/')
	    dir = "/";
	snprintf(cmd, sizeof(cmd), "tar cf - -C %s %s | tar xpf -",
 		 dir, fname);
    }
    else
	snprintf(cmd, sizeof(cmd), "tar cf - %s | tar xpf - -C %s",
 		 fname, dir);
d696 1
a696 1
    printf("Using '%s' to copy trees.\n", cmd);
d698 7
a704 4
    if (system(cmd)) {
	cleanup(0);
	errx(2, "copy_file: could not perform '%s'", cmd);
    }
d711 18
a728 2
    char args[10], *cp;
    const char *decompressor = NULL;
d730 10
a739 24
    args[0] = '\0';
    /*
     * Figure out by a crude heuristic whether this or not this is probably
     * compressed.
     */
    if (strcmp(pkg, "-")) {
	if ((cp = strrchr(pkg, '.'))) {
	    if (!strcmp(cp, ".clz"))
		decompressor = "lzma";
	    else if (strchr(cp, 'z') || strchr(cp, 'Z'))
		decompressor = "gzip";
	}
    } else
	strlcpy(args, "z", sizeof(args));
    strlcat(args, "xpf", sizeof(args));
    if (!flist)
	flist = "";
    if (decompressor ?
      xsystem(false, "%s -dc %s | tar %s - %s", decompressor, pkg, args, flist) :
      xsystem(false, "tar %s %s %s", args, pkg, flist)) {
	pwarnx("tar extract of %s failed!", pkg);
	return 1;
    }
    return 0;
@


1.17
log
@rename vsystem into asystem, because v* are these who take a va_list
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.16 2008/11/02 17:39:05 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.16 2008/11/02 17:39:05 tg Exp $");
d436 1
a436 1
		exit(asystem("%s | tar -x%spf -", decompressor,
d627 1
a627 1
    if (asystem("%s", cmd)) {
d642 1
a642 1
    if (asystem("%s", cmd)) {
d648 1
a648 1
	asystem("chown -f %s %s", getlogin(), to);
d710 2
a711 2
      asystem("%s -dc %s | tar %s - %s", decompressor, pkg, args, flist) :
      asystem("tar %s %s %s", args, pkg, flist)) {
@


1.16
log
@fix pasto
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.15 2008/10/12 15:35:22 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.15 2008/10/12 15:35:22 tg Exp $");
d436 1
a436 1
		exit(vsystem("%s | tar -x%spf -", decompressor,
d627 1
a627 1
    if (vsystem("%s", cmd)) {
d642 1
a642 1
    if (vsystem("%s", cmd)) {
d648 1
a648 1
	vsystem("chown -f %s %s", getlogin(), to);
d710 2
a711 2
      vsystem("%s -dc %s | tar %s - %s", decompressor, pkg, args, flist) :
      vsystem("tar %s %s %s", args, pkg, flist)) {
@


1.15
log
@Support for LZMA compressed binary packages (experimental!)

Tested:
• tg@@bleu:/usr/ports/archivers/mpczar $ mmake PKG_SUFX=.clz install clean
• tg@@bleu:~ $ sudo pkg_upgrade -fva /usr/ports/Packages/ssfe-20070109-1.clz

Dependencies on LZMA are *not* handled automatically, also you must use
PKG_SUFX=.clz to enable and ensure lzma is installed prior. This is some-
what hacky, but our package tools suck anyway. The infrastructure allows
for other compressors such as bzip2 too (but that one is not much of a
saving compared to lzma (ratio) and gzip (resource usage) so I did *not*
add it), but in a *lot* of places… should unify that or better, rewrite
all of the package tools in mksh… anyway, please test.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.14 2007/03/01 23:03:50 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.14 2007/03/01 23:03:50 tg Exp $");
d298 1
a298 1
    if (!strncmp(fname, "https://", 7))
@


1.14
log
@our ftp(1) can do https, d'oh…
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.13 2006/11/19 22:34:07 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.13 2006/11/19 22:34:07 tg Exp $");
d93 5
d103 2
a104 2
	m = strlen(".tar.gz");
	if (n > m && strcmp(name+n-m, ".tar.gz") == 0) {
d108 2
a109 2
	m = strlen(".cgz");
	if (n > m && strcmp(name+n-m, ".cgz") == 0) {
d113 1
a113 1
	m = strlen(".tar");
d137 1
d372 1
a372 1
    int i, status;
d427 8
d436 2
a437 3
		i = execlp("tar",
		    "tar", Verbose ? "-xpzvf" : "-xpzf", "-", NULL);
		exit(i);
d689 2
a690 1
    char args[10], suff[80], *cp;
d698 5
a702 5
	cp = strrchr(pkg, '.');
	if (cp) {
	    strlcpy(suff, cp + 1, sizeof(suff));
	    if (strchr(suff, 'z') || strchr(suff, 'Z'))
		strlcpy(args, "-z", sizeof(args));
d704 1
a704 2
    }
    else
d707 5
a711 1
    if (vsystem("tar %s %s %s", args, pkg, flist ? flist : "")) {
@


1.13
log
@whitespace at EOL sweep
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.12 2006/11/19 22:16:36 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.12 2006/11/19 22:16:36 bsiegert Exp $");
d292 2
@


1.12
log
@Refactor write_deps() to use write_file(). Rewrite write_file() to accept
a mode argument and a format string, change other invocations accordingly.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.11 2006/09/24 20:40:48 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.11 2006/09/24 20:40:48 tg Exp $");
d79 1
a79 1
		for (i = 0; i < matches; i++) 
@


1.11
log
@size_t and ptrdiff_t
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.10 2006/09/24 20:24:54 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.10 2006/09/24 20:24:54 bsiegert Exp $");
d580 4
a583 3
/* Write the contents of "str" to a file */
void
write_file(const char *name, const char *str)
d585 4
a588 2
	FILE	*fp;
	size_t	len;
d590 11
a600 14
	if ((fp = fopen(name, "w")) == NULL) {
		cleanup(0);
		errx(2, "cannot fopen '%s' for writing", name);
	}
	len = strlen(str);
	if (fwrite(str, 1, len, fp) != len) {
		cleanup(0);
		errx(2, "short fwrite on '%s', tried to write %lu bytes",
			name, (u_long)len);
	}
	if (fclose(fp)) {
		cleanup(0);
		errx(2, "failure to fclose '%s'", name);
	}
@


1.10
log
@Finally fix that AS_USER bug tg@@ found: If you are using MirPorts as a user
and install a package with sudo (for example because it contains a suid
executable) that contains install/deinstall scripts, the installation fails.

Refactor move_file() so that it does not drop privileges when writing to the
package db but does a chmod afterwards. Rationale: the temp directory is mode
700 and owned by root, so reads (and deletes as for mv) fail as user.

tg: please test, it worked for me in a test case (which does not contain suid
files though).
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.9 2006/02/26 00:23:58 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.9 2006/02/26 00:23:58 bsiegert Exp $");
d594 2
a595 2
		errx(2, "short fwrite on '%s', tried to write %d bytes",
			name, len);
@


1.9
log
@Add support for dropping privileges in pkg_add.

Here is how it works: You have installed a MirPorts instance as user
(for example with Setup.sh -ule /path/to/prefix). Now if you install a
package under sudo, writes into the package database are done with the
privileges of the user, not with root rights. This means that there won't
be any problems with file permissions inside the package db.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.8 2006/02/25 15:49:55 bsiegert Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.8 2006/02/25 15:49:55 bsiegert Exp $");
a622 1
    drop_privs();
a627 1
	raise_privs();
d631 5
a635 1
    raise_privs();
@


1.8
log
@Add two new routines, drop_privs and raise_privs, to be used in pkg_add.
These don't do anything useful yet.

(wohoo, a commit!)
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.6 2005/11/15 19:33:59 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.6 2005/11/15 19:33:59 tg Exp $");
d623 1
a623 1

d629 1
d633 1
@


1.7
log
@add -f to mv(1) to quell warning about chown (I hope)

WTF, three space indentation?
@
text
@d34 1
d623 1
@


1.6
log
@crude U+0060 removal
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.5 2005/09/12 22:59:55 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.5 2005/09/12 22:59:55 tg Exp $");
d623 1
a623 1
	snprintf(cmd, sizeof(cmd), "mv %s %s", fname, to);
d625 1
a625 1
	snprintf(cmd, sizeof(cmd), "mv %s/%s %s", dir, fname, to);
@


1.5
log
@mirports_tar -> tar (and hope $PATH is right)
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.4 2005/09/12 22:53:24 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.4 2005/09/12 22:53:24 tg Exp $");
d397 1
a397 1
	pwarnx("URL `%s' has bad host part!", fname);
d403 1
a403 1
	pwarnx("URL `%s' has bad filename part!", fname);
@


1.4
log
@join tg-ports-devel branch into HEAD
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.2.2.1 2005/09/11 01:05:44 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.2.2.1 2005/09/11 01:05:44 tg Exp $");
d419 1
a419 1
		i = execlp("mirports_tar",
d649 1
a649 1
	snprintf(cmd, sizeof(cmd), "mirports_tar cf - -C %s %s | tar xpf -",
d653 1
a653 1
	snprintf(cmd, sizeof(cmd), "mirports_tar cf - %s | tar xpf - -C %s",
d686 1
a686 1
    if (vsystem("mirports_tar %s %s %s", args, pkg, flist ? flist : "")) {
@


1.3
log
@Add extended package name globbing for pkg_info and pkg_delete.
This means that you can do stuff like

% pkg_delete libpixman

without knowing the version. If more than one version is installed (for
example with autoconf), pkg_info will just show you the first match while
pkg_delete refuses to work.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $ */
d35 1
a35 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.1.7.1 2005/03/18 15:47:16 tg Exp $");
@


1.2
log
@cosmetics: don't do MD5 checksums (why MD5, by the way?!)
for symbolic links - symlinks to dirs have NULLMD5 and
warn on deinstallation

untested

agreed and implementation hints bsiegert@@
@
text
@d32 2
d37 79
@


1.2.2.1
log
@merge -rHEAD into development branch

Note for bsiegert@@ please don't use csh prompts in man pages any more
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.3 2005/08/21 20:15:45 bsiegert Exp $ */
a31 82
#include <glob.h>
#include <libgen.h>

__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/file.c,v 1.3 2005/08/21 20:15:45 bsiegert Exp $");

/* Try to find the log dir for an incomplete package specification.
 * Used in pkg_info and pkg_delete. Returns the number of matches,
 * or -1 on error.
 */
int
glob_package(char *log_dir, size_t len, const char *pkg)
{
	const char *tmp;
	glob_t pglob;
	int matches;

	if (!(tmp = getenv(PKG_DBDIR)))
		tmp = DEF_LOG_DIR;

	if (strchr(pkg, '/')) {
		if (strncmp(pkg, tmp, strlen(tmp))) {
			pwarnx("package name contains a / and is not under the '%s' directory!", tmp);
			return -1;
		}
		(void) snprintf(log_dir, len, "%s", pkg);
	} else
		(void) snprintf(log_dir, len, "%s/%s", tmp, pkg);

	if (fexists(log_dir))
		return 1;
	if (trim_end(log_dir) && fexists(log_dir))
		return 1;

	/* if all else fails, do the glob */
	memset(&pglob, 0, sizeof(pglob));
	(void) snprintf(log_dir, len, "%s/%s-[0-9]*", tmp, pkg);
	glob(log_dir, 0, NULL, &pglob);
	matches = pglob.gl_pathc;
	if (matches > 0)
		(void) snprintf(log_dir, len, "%s",
				pglob.gl_pathv[0]);
	else
		*log_dir = '\0';
	if (matches > 1) {
		int i;
		printf("Hint: The following versions of this package are installed:\n");
		for (i = 0; i < matches; i++) 
			printf(" %s\n", basename(pglob.gl_pathv[i]));
	}

	globfree(&pglob);
	return matches;
}

/* Try to remove the extension from a package name */
int
trim_end(char *name)
{
	size_t n, m;
	n = strlen(name);
	m = strlen(".tgz");
	if (n > m && strcmp(name+n-m, ".tgz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	m = strlen(".tar.gz");
	if (n > m && strcmp(name+n-m, ".tar.gz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	m = strlen(".cgz");
	if (n > m && strcmp(name+n-m, ".cgz") == 0) {
		name[n-m] = 0;
		return 1;
	}
	m = strlen(".tar");
	if (n > m && strcmp(name+n-m, ".tar") == 0) {
		name[n-m] = 0;
		return 1;
	}
	return 0;
}
d33 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS$ */
d33 1
a33 1
__RCSID("$MirOS$");
d126 9
d141 1
a141 1
    if (lstat(fname, &sb) != -1 && S_ISLNK(sb.st_mode))
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@
