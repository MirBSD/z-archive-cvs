head	1.1;
access;
symbols
	bsiegert-cfgfile:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2010.03.04.18.03.39;	author bsiegert;	state dead;
branches
	1.1.2.1;
next	;
commitid	1004B8FF5740BB7941D;

1.1.2.1
date	2010.03.04.18.03.39;	author bsiegert;	state Exp;
branches;
next	1.1.2.2;
commitid	1004B8FF5740BB7941D;

1.1.2.2
date	2010.03.06.15.25.23;	author bsiegert;	state Exp;
branches;
next	1.1.2.3;
commitid	1004B9273E14421FD2F;

1.1.2.3
date	2010.03.07.15.56.03;	author bsiegert;	state Exp;
branches;
next	1.1.2.4;
commitid	1004B93CC9F4FA9DC45;

1.1.2.4
date	2010.05.11.19.08.08;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004BE9AAFA11BE7160;


desc
@@


1.1
log
@file srclist.c was initially added on branch bsiegert-cfgfile.
@
text
@@


1.1.2.1
log
@Continue on the cfgfile branch:
Introduce a new function findmatchingname_file(), which searches in the cached
index files for a package.
Introduce a function findmatchingname_srcs(), which iterates over all the
sources and returns a list of _all_ matches, minus those sorted out by a
helper function.

Builds fine, but the code is still untested.
@
text
@a0 136
/* $MirOS$ */

/*-
 * Copyright (c) 2010
 *	Benny Siegert <bsiegert@@gmx.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Configuration file routines
 */

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include "lib.h"

__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/cfgfile.c,v 1.1.2.11 2010/02/27 16:20:18 bsiegert Exp $");

/* A word on memory management:
 * The strings to be entered into "source" above are just the pointers
 * in the srclist -- which is safe as long as the latter is not destroyed
 * before the results are consumed, e.g. by calling cfg_read_config() in
 * the meantime. Don't do that.
 */

/* state for our matchfn */
typedef struct {
	const char *current_src;
	struct matchlist *matches;
} srciter_state;

/* Determine whether a package name has already been seen. Sources are
 * traversed from highest to lowest priority, so when the same pkgname
 * is seen again, it should be ignored, so that the highest-priority
 * entry prevails.
 * Additional checks could be implemented here: for example, you could
 * also remove packages that have a lower version than others already
 * seen. Might also act on "matches" in the future.
 */
static bool
found_in_matches(const char *pkgname, struct matchlist *matches)
{
	struct match *mp;

	TAILQ_FOREACH(mp, matches, entries) {
		if (!strcmp(pkgname, mp->pkgname))
			return true;
	}
	
	return false;
}

/* Our matchfn, which has to conform to the standard prototype. "data" is
 * really a srciter_state*. Evil hack?
 */
static int
srciter_matchfn(const char *found, char *data, int len)
{
	srciter_state *state;
	struct match *mp;

	assert(len == sizeof (srciter_state));
	state = (srciter_state *)data;

	if (!found_in_matches(found, state->matches)) {
		if (!(mp = malloc(sizeof (struct match))))
			err(1, NULL);
		memset(mp, 0, sizeof (struct match));
		
		mp->source = state->current_src;
		if (!(mp->pkgname = strdup(found)))
			err(1, NULL);
		TAILQ_INSERT_TAIL(state->matches, mp, entries);
	}

	return 0;
}

/* Find all the packages in the list of sources matching the given pattern.
 * Calls findmatchingname and findmatchingname_file internally.
 * The returned list must be destroyed after use.
 */
struct matchlist *
findmatchingname_srcs(const struct cfg_sourcelist *sources, const char *pattern)
{
	srciter_state state;
	struct cfg_source *sp;

	state.current_src = NULL;
	if (!(state.matches = malloc(sizeof (struct matchlist))))
		err(1, NULL);
	TAILQ_INIT(state.matches);

	LIST_FOREACH(sp, sources, entries) {
		if (sp->remote)
			findmatchingname_file(src_index_name(sp->source),
					pattern, srciter_matchfn,
					(char *)&state, sizeof (srciter_state));
		else
			findmatchingname(sp->source, pattern, srciter_matchfn,
					(char *)&state, sizeof (srciter_state));
	}

	return state.matches;
}

/* Free all entries of a matchlist, but not the list itself.
 */
void
matchlist_destroy(struct matchlist *matches)
{
	struct match *mp, *mp_temp;

	TAILQ_FOREACH_SAFE(mp, matches, entries, mp_temp) {
		free(mp->pkgname);
		TAILQ_REMOVE(matches, mp, entries);
		free(mp);
	}
}
@


1.1.2.2
log
@MirOS does not have reallocf(3) and the *_FOREACH_SAFE macros in queue.h.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.1 2010/03/04 18:03:39 bsiegert Exp $ */
d34 1
a34 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.1 2010/03/04 18:03:39 bsiegert Exp $");
d129 1
a129 1
	struct match *mp;
d131 1
a131 1
	while ((mp = TAILQ_FIRST(matches))) {
@


1.1.2.3
log
@Finally, the first real use for the srclist code I implemented the other day:
"pkg_info -E pkgspec" looks for packages matching the spec in the installed
ones and the source list, and prints a list.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.2 2010/03/06 15:25:23 bsiegert Exp $ */
d34 1
a34 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.2 2010/03/06 15:25:23 bsiegert Exp $");
a111 1
		state.current_src = sp->source;
@


1.1.2.4
log
@Implement a "selection menu" if fileFindByPath() finds more than one package
matching the pattern. I do not yet know if this is the right way to handle
this, consider it experimental.
@
text
@d1 1
a1 1
/* $MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.3 2010/03/07 15:56:03 bsiegert Exp $ */
d34 1
a34 1
__RCSID("$MirOS: ports/infrastructure/pkgtools/lib/srclist.c,v 1.1.2.3 2010/03/07 15:56:03 bsiegert Exp $");
a137 33

/* Print the list of matches prefixed with a number, as a menu
 * to let the user choose one.
 */
void
print_matchlist_menu(struct matchlist *matches)
{
	struct match *mp;
	int i = 1;

	if (!matches)
		return;

	TAILQ_FOREACH(mp, matches, entries)
		printf("%2d. %-26s at %s\n", i++, mp->pkgname, mp->source);
}

/* Given a number from the menu, return the corresponding entry from
 * the list, or NULL if it was not found.
 */
struct match *
match_by_number(struct matchlist *matches, int num)
{
	struct match *mp;
	int i = 1;

	TAILQ_FOREACH(mp, matches, entries) {
		if (i == num)
			return mp;
		i++;
	}
	return NULL;
}
@


