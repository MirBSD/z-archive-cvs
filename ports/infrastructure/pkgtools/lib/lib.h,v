head	1.30;
access;
symbols
	bsiegert-cfgfile_BASE:1.28
	bsiegert-cfgfile:1.28.0.2
	MIRBSD_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2013.10.31.20.05.27;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005272B7081B0E5655;

1.29
date	2010.03.09.19.37.49;	author bsiegert;	state Exp;
branches;
next	1.28;
commitid	1004B96A38112487EA9;

1.28
date	2009.12.11.22.16.14;	author bsiegert;	state Exp;
branches
	1.28.2.1;
next	1.27;
commitid	1004B22BFA76EA101EC;

1.27
date	2009.12.08.20.51.05;	author bsiegert;	state Exp;
branches;
next	1.26;
commitid	1004B1EBBF04E744B63;

1.26
date	2009.11.29.13.26.17;	author bsiegert;	state Exp;
branches;
next	1.25;
commitid	1004B12763243A81455;

1.25
date	2009.10.20.19.32.50;	author bsiegert;	state Exp;
branches;
next	1.24;
commitid	1004ADE102745DDB74A;

1.24
date	2008.12.06.13.18.07;	author tg;	state Exp;
branches;
next	1.23;
commitid	100493A7B846A183288;

1.23
date	2008.11.02.19.08.01;	author tg;	state Exp;
branches;
next	1.22;
commitid	100490DFAA3314F9494;

1.22
date	2008.11.02.19.05.49;	author tg;	state Exp;
branches;
next	1.21;
commitid	100490DFA1E4C107742;

1.21
date	2008.11.02.19.02.00;	author tg;	state Exp;
branches;
next	1.20;
commitid	100490DF9162032A210;

1.20
date	2008.11.02.18.56.30;	author tg;	state Exp;
branches;
next	1.19;
commitid	100490DF7B930A3A3BD;

1.19
date	2008.11.02.18.19.53;	author tg;	state Exp;
branches;
next	1.18;
commitid	100490DEF535C71F010;

1.18
date	2008.10.12.15.35.22;	author tg;	state Exp;
branches;
next	1.17;
commitid	10048F218B2228D17F9;

1.17
date	2008.10.12.14.35.17;	author tg;	state Exp;
branches;
next	1.16;
commitid	10048F20B342E297907;

1.16
date	2008.03.09.17.22.57;	author tg;	state Exp;
branches;
next	1.15;
commitid	10047D41CAA7E715397;

1.15
date	2007.05.02.21.24.14;	author bsiegert;	state Exp;
branches;
next	1.14;
commitid	1004639017279101038;

1.14
date	2007.03.30.23.20.11;	author bsiegert;	state Exp;
branches;
next	1.13;
commitid	100460D99284E3410CC;

1.13
date	2007.01.19.23.11.20;	author bsiegert;	state Exp;
branches;
next	1.12;
commitid	10045B14FCB796AA24B;

1.12
date	2006.11.19.22.16.36;	author bsiegert;	state Exp;
branches;
next	1.11;
commitid	1004560D7992BF407CE;

1.11
date	2006.11.19.12.33.53;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045604F4700CFEC7B;

1.10
date	2006.11.13.21.49.54;	author bsiegert;	state Exp;
branches;
next	1.9;
commitid	1004558E865044D0FA8;

1.9
date	2006.10.05.15.11.41;	author bsiegert;	state Exp;
branches;
next	1.8;
commitid	10045251FCC2071AF61;

1.8
date	2006.02.25.15.49.55;	author bsiegert;	state Exp;
branches;
next	1.7;
commitid	10044007C2C1AC43BDA;

1.7
date	2005.09.12.22.53.24;	author tg;	state Exp;
branches;
next	1.6;
commitid	6e6c432606e897b6;

1.6
date	2005.08.21.20.15.45;	author bsiegert;	state Exp;
branches;
next	1.5;
commitid	4cd74308e0708a68;

1.5
date	2005.07.18.20.02.00;	author bsiegert;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	73a742dc0aa2783a;

1.4
date	2005.06.29.17.20.17;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	1b2442c2d7478718;

1.3
date	2005.06.24.15.18.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	be442bc243d5ecc;

1.2
date	2005.05.22.03.52.48;	author bsiegert;	state Exp;
branches;
next	1.1;
commitid	5d43428ffdbc7a19;

1.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.28.2.1
date	2009.12.22.22.26.51;	author bsiegert;	state Exp;
branches;
next	1.28.2.2;
commitid	1004B31479401069986;

1.28.2.2
date	2009.12.23.15.41.47;	author bsiegert;	state Exp;
branches;
next	1.28.2.3;
commitid	1004B323A2376E23055;

1.28.2.3
date	2009.12.26.22.21.16;	author bsiegert;	state Exp;
branches;
next	1.28.2.4;
commitid	1004B368BBD567705D5;

1.28.2.4
date	2009.12.28.14.33.10;	author bsiegert;	state Exp;
branches;
next	1.28.2.5;
commitid	1004B38C1680F10A8DC;

1.28.2.5
date	2009.12.29.17.09.33;	author bsiegert;	state Exp;
branches;
next	1.28.2.6;
commitid	1004B3A36D83259360D;

1.28.2.6
date	2010.02.27.11.11.20;	author bsiegert;	state Exp;
branches;
next	1.28.2.7;
commitid	1004B88FDC72173C0CB;

1.28.2.7
date	2010.02.27.16.20.19;	author bsiegert;	state Exp;
branches;
next	1.28.2.8;
commitid	1004B8945DC0802C02F;

1.28.2.8
date	2010.03.04.18.03.38;	author bsiegert;	state Exp;
branches;
next	1.28.2.9;
commitid	1004B8FF5740BB7941D;

1.28.2.9
date	2010.05.11.19.08.08;	author bsiegert;	state Exp;
branches;
next	1.28.2.10;
commitid	1004BE9AAFA11BE7160;

1.28.2.10
date	2010.05.31.20.25.19;	author bsiegert;	state Exp;
branches;
next	1.28.2.11;
commitid	1004C041AC66F098A17;

1.28.2.11
date	2010.06.12.20.27.11;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004C13ED937750A323;

1.5.2.1
date	2005.09.11.01.05.44;	author tg;	state Exp;
branches;
next	;
commitid	2f08432382e315cf;

1.1.7.1
date	2005.03.18.15.47.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.30
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.29 2010/03/09 19:37:49 bsiegert Exp $ */
/*	$OpenBSD: lib.h,v 1.14 2003/08/21 20:24:57 espie Exp $	*/

/*-
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 */

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * Include and define various things wanted by the library routines.
 */

#ifndef _INST_LIB_LIB_H_
#define _INST_LIB_LIB_H_

/* Includes */
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>

#include <ctype.h>
#include <dirent.h>
#include <libgen.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcdb.h"

/* Usually "rm", but often "echo" during debugging! */
#define REMOVE_CMD		"rm"

/* Usually "rm", but often "echo" during debugging! */
#define RMDIR_CMD		"rmdir"

/* just in case we change the environment variable name */
#define PKG_DBDIR		"PKG_DBDIR"

/* The names of our "special" files */
#define CONTENTS_FNAME		"+CONTENTS"
#define COMMENT_FNAME		"+COMMENT"
#define DESC_FNAME		"+DESC"
#define INSTALL_FNAME		"+INSTALL"
#define DEINSTALL_FNAME		"+DEINSTALL"
#define REQUIRE_FNAME		"+REQUIRE"
#define REQUIRED_BY_FNAME	"+REQUIRED_BY"
#define DISPLAY_FNAME		"+DISPLAY"
#define MTREE_FNAME		"+MTREE_DIRS"
#define DEPENDS_FNAME		"+DEPENDS"

#define CMD_CHAR		'@@'	/* prefix for extended PLIST cmd */

/* The name of the "prefix" environment variable given to scripts */
#define PKG_PREFIX_VNAME	"PKG_PREFIX"

/* maximum size of comment that will fit on one line */
#ifndef MAXINDEXSIZE
#define MAXINDEXSIZE 72
#endif

/* Types */

/* enumerated constants for plist entry types */
typedef enum pl_ent_t {
	PLIST_SHOW_ALL = -1,
	PLIST_FILE,
	PLIST_CWD,
	PLIST_CMD,
	PLIST_CHMOD,
	PLIST_CHOWN,
	PLIST_CHGRP,
	PLIST_COMMENT,
	PLIST_ARCH,
	PLIST_IGNORE,
	PLIST_NAME,
	PLIST_UNEXEC,
	PLIST_SRC,
	PLIST_DISPLAY,
	PLIST_PKGDEP,
	PLIST_MTREE,
	PLIST_DIR_RM,
	PLIST_OPTION,
	PLIST_PKGCFL,
	PLIST_EXTRA,
	PLIST_EXTRAUNEXEC,
	PLIST_NEWDEP,
	PLIST_LIBDEP,
	PLIST_INFO,
	PLIST_MAN,
	PLIST_SAMPLE,
	PLIST_LIB,
	PLIST_SHELL,
	PLIST_ENDFAKE,
	PLIST_LDCACHE,
	PLIST_EMUL,
	PLIST_NOLIB
} pl_ent_t;

/* type of dynamic linker */
typedef enum ld_type_t {
	LD_STATIC,
	LD_BSD,
	LD_GNU,
	LD_DYLD
} ld_type_t;

/* remove configuration on pkg_delete? */
typedef enum rm_cfg_t {
	RMCFG_NONE = 0,
	RMCFG_ALL,
	RMCFG_UNCHANGED
} rm_cfg_t;

/* type of compression of binary packages */
typedef enum pkg_cmp_t {
	COMP_NONE = 0,
	COMP_GZIP,
	COMP_LZMA,
	COMP_XZ
} pkg_cmp_t;

/* operators for deweycmp */
enum deweycmp_ops {
	GT,
	GE,
	LT,
	LE,
	NONE
};

/* this structure describes a packing list entry */
typedef struct plist_t {
	struct plist_t	*prev;		/* previous entry */
	struct plist_t	*next;		/* next entry */
	char		*name;		/* name of entry */
	bool		marked;		/* whether entry has been marked */
	pl_ent_t	type;		/* type of entry */
} plist_t;

/* this structure describes a package's complete packing list */
typedef struct package_t {
	plist_t		*head;		/* head of list */
	plist_t		*tail;		/* tail of list */
} package_t;

enum {
	ChecksumLen = 16,
	LegibleChecksumLen = 33
};

/* type of function to be handed to findmatchingname; return value of this
 * is currently ignored */
typedef int (*matchfn)(const char *found, char *data, int len);

/* Prototypes */
/* Misc */
char		*piperead(const char *);
void		cleanup(int);
char		*make_playpen(char *, size_t, size_t);
char		*where_playpen(void);
void		leave_playpen(char *);
size_t		min_free(const char *);
void            save_dirs(char **c, char **p);
void            restore_dirs(char *c, char *p);
void		drop_privs(void);
void		raise_privs(void);
bool		have_emulation(char *);

/* String */
char 		*get_dash_string(char **);
char		*copy_string(const char *);
bool		suffix(char *, char *);
void		nuke_suffix(char *);
char		*find_version(const char *);
char		*nuke_version(char *, bool);
char		*find_flavour(const char *);
void		str_lowercase(char *);
char		*toabs(const char *, const char *);
char		*strconcat(const char *, const char *);
int		pmatch(const char *, const char *);
int		findmatchingname(const char *, const char *, matchfn, char *, int); /* doesn't really belong here */
char		*findbestmatchingname(const char *, const char *); /* neither */
int		ispkgpattern(const char *);
int		deweycmp(char *, enum deweycmp_ops, char *);

/* File */
bool		fexists(const char *);
bool		isdir(const char *);
bool		islink(const char *);
bool		islinktodir(const char *);
bool		isemptydir(const char *);
bool		isemptyfile(const char *);
bool		isfile(const char *);
bool		isURL(const char *);
char		*ensure_tgz(char *);
bool		pkg_existing(const char *, char *, char *, size_t);
char		*fileGetURL(char *, char *);
char		*fileURLFilename(char *, char *, int);
char		*fileURLHost(char *, char *, int);
char		*fileFindByPath(char *, char *);
char		*fileGetContents(char *);
bool		make_preserve_name(char *, size_t, char *, char *);
int		write_file(const char *, const char *, const char *, ...)
		    __attribute__((__format__(__printf__, 3, 4)));
void		copy_file(const char *, const char *, const char *);
void		move_file(const char *, const char *, char *);
void		copy_hierarchy(const char *, char *, bool);
int		delete_hierarchy(char *, bool, bool);
int		unpack(char *, const char *);
int		format_cmd(char *, size_t , const char *, const char *,
		    const char *);
int		trim_end(char *);
int		glob_package(char *, size_t, const char *);

/* Packing list */
plist_t		*new_plist_entry(void);
plist_t		*last_plist(package_t *);
plist_t		*find_plist(package_t *, pl_ent_t, const char *);
char		*find_plist_option(package_t *, const char *);
void		plist_delete(package_t *, bool, pl_ent_t, char *);
void		free_plist(package_t *);
void		mark_plist(package_t *);
void		csum_plist_entry(char *, plist_t *);
void		add_plist(package_t *, pl_ent_t, const char *);
void		add_plist_top(package_t *, pl_ent_t, const char *);
void		add_plist_at(package_t *, plist_t *, pl_ent_t, const char *);
void		add_plist_glob(package_t *, plist_t *, const char *, const char *, bool);
void		delete_plist(package_t *pkg, bool all, pl_ent_t type, char *name);
void		write_plist(package_t *, FILE *);
void		read_plist(package_t *, FILE *);
int		plist_cmd(char *, char **);
int		delete_package(bool, bool, rm_cfg_t, bool, package_t *);
int		process_dirrm(plist_t *, bool, int *, RCDB *, const char *);
void		delete_extra(plist_t *, const char *, const rm_cfg_t, bool);

/* For all */
int		pkg_perform(char **);

void		set_pkg(char *);
void 		pwarnx(const char *, ...)
		    __attribute__((__format__(__printf__, 1, 2)));
void 		pwarn(const char *, ...)
		    __attribute__((__format__(__printf__, 1, 2)));

/* Externs */
extern bool	Verbose;
extern bool	Fake;
extern bool	Force;

/* mem.c */
void *xcalloc(size_t, size_t);
void *xrealloc(void *, size_t, size_t);
#define xfree(p) xfree_((void **)&(p))
void xfree_(void **);
int xasprintf(char **, const char *, ...)
    __attribute__((__nonnull__(1)))
    __attribute__((__format__(__printf__, 2, 3)));
int xvasprintf(char **, const char *, va_list)
    __attribute__((__nonnull__(1)))
    __attribute__((__format__(__printf__, 2, 0)));
void *xstrdup(const void *);

/* proc.c */
char *format_arg(const char *)
    __attribute__((__nonnull__(1)));
#define format_comm(args) format_comm_((const char * const *)(args))
char *format_comm_(const char * const *)
    __attribute__((__nonnull__(1)));
void unlimit(void);
int mirsystem(const char *, bool)
    __attribute__((__nonnull__(1)));
int xsystem(bool, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int vxsystem(bool, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int sxsystem(bool, const char *)
    __attribute__((__nonnull__(2)));

#endif /* _INST_LIB_LIB_H_ */
@


1.29
log
@Make deweycmp() public by removing "static", export the corresponding enum
in lib.h
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28 2009/12/11 22:16:14 bsiegert Exp $ */
d4 5
d223 1
a223 1
		    __attribute__((__format__ (printf, 3, 4)));
d260 1
a260 1
		    __attribute__((__format__ (printf, 1, 2)));
d262 1
a262 1
		    __attribute__((__format__ (printf, 1, 2)));
d275 2
a276 2
    __attribute__((nonnull (1)))
    __attribute__((format (printf, 2, 3)));
d278 2
a279 2
    __attribute__((nonnull (1)))
    __attribute__((format (printf, 2, 0)));
d284 1
a284 1
    __attribute__((nonnull (1)));
d287 1
a287 1
    __attribute__((nonnull (1)));
d290 1
a290 1
    __attribute__((nonnull (1)));
d292 1
a292 1
    __attribute__((format (printf, 2, 3)));
d294 1
a294 1
    __attribute__((format (printf, 2, 0)));
d296 1
a296 1
    __attribute__((nonnull (2)));
@


1.28
log
@Implement (most of) the feature requested by tg@@: automatically loaded
dependencies (and pkg_info for good measure, which uses the same function)
can find packages using any supported file extension, not just .cgz. For ftp
URLs, .cgz is the only extension tested by default for now, this will come
later.

While here, also clean up a lot of functions like ensure_tgz(): use _one_
static list of supported extensions, in order of priority, highest first. ALL
functions that check extensions now traverse the list. Saves several gotos
and auxiliary macros. In fileFindByPath(), throw out redundant code, introduce
a new function pkg_existing() which does the actual work.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.27 2009/12/08 20:51:05 bsiegert Exp $ */
d136 9
d198 1
@


1.28.2.1
log
@First (alpha quality) incarnation of configuration file routines.
You can set and expand variables. Contains some debugging code still.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28 2009/12/11 22:16:14 bsiegert Exp $ */
a282 6
/* configuration file */
bool	cfg_read_config(void);
FILE	*cfg_open(void);
void	cfg_dump_vars(void);
char	*cfg_expand_vars(char*, size_t);

@


1.28.2.2
log
@Implement the first useful configuration directive:

	Pager /path/to/pager

for specifying the pager to use in pkg_add.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.1 2009/12/22 22:26:51 bsiegert Exp $ */
d284 4
a287 5
bool		cfg_read_config(void);
FILE		*cfg_open(void);
void		cfg_dump_vars(void);
char		*cfg_expand_vars(char*, size_t);
const char	*cfg_get_pager(void);
@


1.28.2.3
log
@- remove cfg_open() function, folded into cfg_read_config()
- cfg_read_config now accepts a file name for a config file for use instead
  of the default /etc/pkgtools/pkgtools.conf
- fix a lot of memory leaks in case of error (out-of-memory)
- simplify logic in variable handling; allow variables to be overwritten
- introduce
	Source 1 ${PORTSDIR}/Packages
  source lines (not used yet)

hacked on the train to 26C3, yay!
This commit sponsored by the 26C3 hackcenter, I still haven't got a ticket …
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.2 2009/12/23 15:41:47 bsiegert Exp $ */
d284 2
a285 1
bool		cfg_read_config(const char*);
@


1.28.2.4
log
@Implement cfg_dump_sources() for debugging, and cfg_add_source() as the two
first functions that do something sensible with the sources list. Add a
missing codepath (insertion at the end) to cfg_add_source(), oops … Greatly
simplify the logic in parse_source() while here, the function is now separated
in two.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.3 2009/12/26 22:21:16 bsiegert Exp $ */
a26 1
#include <sys/queue.h>
a155 9
/* list of package sources */
LIST_HEAD(cfg_sourcelist, cfg_source);
struct cfg_source {
	unsigned long priority;
	bool remote;
	char *source;
	LIST_ENTRY(cfg_source) entries;
};

d286 2
a287 3
char*		cfg_expand_vars(char*, size_t);
const char*	cfg_get_pager(void);
void		cfg_add_source(unsigned long, bool, const char*);
@


1.28.2.5
log
@Experimental support for the config file in pkg_info and pkg_add. Packages
given as command-line arguments are found in the paths specified in "Source"
lines. Tested in pkg_info:

% pkg_info tiff-cxx-3.7.4-1

finds the uninstalled package in /usr/ports/Packages.

Oh, and PKG_PATH support is dropped for now.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.4 2009/12/28 14:33:10 bsiegert Exp $ */
a298 2
bool		cfg_remove_source(const char*);
const struct cfg_sourcelist* cfg_get_sourcelist(void);
@


1.28.2.6
log
@Introduce a normalize_name() function to replace all the "non-nice" characters
typically found in URLs by _.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.5 2009/12/29 17:09:33 bsiegert Exp $ */
a198 1
void		normalize_name(char *);
a295 1
void		cfg_dump_var(const char *);
a299 1
void		cfg_dump_sources(void);
@


1.28.2.7
log
@Implement a function to cache the "index.txt" file for remote sources. Also
move some defines to lib.h.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.6 2010/02/27 11:11:20 bsiegert Exp $ */
a75 8
/* configuration file and directories */
#ifndef SYSCONFDIR
# define SYSCONFDIR "/etc"
#endif
#define CFGDIR SYSCONFDIR "/pkgtools/"
#define DEFAULT_CFGFILE CFGDIR "pkgtools.conf"
#define CACHEDIR CFGDIR "sources/"

a199 1
char *		src_index_name(const char *);
a228 1
void		update_src_index(void);
@


1.28.2.8
log
@Continue on the cfgfile branch:
Introduce a new function findmatchingname_file(), which searches in the cached
index files for a package.
Introduce a function findmatchingname_srcs(), which iterates over all the
sources and returns a list of _all_ matches, minus those sorted out by a
helper function.

Builds fine, but the code is still untested.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.7 2010/02/27 16:20:19 bsiegert Exp $ */
a173 8
/* list of matching packages */
TAILQ_HEAD(matchlist, match);
struct match {
	char *pkgname;
	const char *source;
	TAILQ_ENTRY(match) entries;
};

a204 1
int		findmatchingname_file(const char *, const char *, matchfn, char *, int); /* doesn't really belong here */
a314 5
/* source list */
struct matchlist* findmatchingname_srcs(const struct cfg_sourcelist*, const char*);
void		matchlist_destroy(struct matchlist*);
 

@


1.28.2.9
log
@Implement a "selection menu" if fileFindByPath() finds more than one package
matching the pattern. I do not yet know if this is the right way to handle
this, consider it experimental.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.8 2010/03/04 18:03:38 bsiegert Exp $ */
a326 2
void		print_matchlist_menu(struct matchlist*);
struct match*	match_by_number(struct matchlist*, int);
@


1.28.2.10
log
@add a new function diag(), which is like
	if (Verbose) printf(fmt, ...)
Also add a new module, libspec.c, that is able to parse libspecs like
jpeg.62.0 or tiff.la, etc., and check whether the corresponding library is
present. Not connected to anything yet.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.9 2010/05/11 19:08:08 bsiegert Exp $ */
a277 2
int		diag(const char*, ...)
		    __attribute__((__format__ (printf, 1, 2)));
a329 3
/* library specifier */
bool		match_libspec(char*, const char *, ld_type_t);

@


1.28.2.11
log
@Add a new function get_ld_type() to examine the plist for the ld type and use it for
checking library dependencies.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.28.2.10 2010/05/31 20:25:19 bsiegert Exp $ */
a253 1
ld_type_t	get_ld_type(package_t *pkg);
@


1.27
log
@Introduce an enum for the compression type instead of using 0, 1, 2, 3
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.26 2009/11/29 13:26:17 bsiegert Exp $ */
a188 1
char		*strnncpy(char *to, size_t tosize, char *from, size_t cc);
d195 2
a196 2
bool		isemptydir(const char *fname);
bool		isemptyfile(const char *fname);
d200 1
@


1.26
log
@More diagnostics from the static analyzer: min_free() is a size, not
an offset, thus a size_t. The values in struct statfs are long, though,
so return a size of 0 when negative (which can happen if the disc is very
full, I guess).
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.25 2009/10/20 19:32:50 bsiegert Exp $ */
d128 8
@


1.25
log
@New plist entry type "@@nolib", for use with .la files, which will NOT be passed
through libtoolise/unlibtoolise. Needed for GNU Smalltalk
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.24 2008/12/06 13:18:07 tg Exp $ */
d159 1
a159 1
off_t		min_free(const char *);
@


1.24
log
@fix MirPorts Framework package tools on MidnightBSD:
at least mem.c needs <stdint.h> for SIZE_MAX, how standard
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.23 2008/11/02 19:08:01 tg Exp $ */
d109 2
a110 1
	PLIST_EMUL
@


1.23
log
@set pointers to NULL in xfree
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.22 2008/11/02 19:05:49 tg Exp $ */
d34 3
a38 2
#include <stdarg.h>
#include <stdbool.h>
@


1.22
log
@runcomm is no longer needed now, either
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.21 2008/11/02 19:02:00 tg Exp $ */
d247 2
a248 1
void xfree(void *);
@


1.21
log
@sxsystem for constant arguments, to prevent having to use
xsystem(false, "%s", cmd) for sxsystem(false, cmd), which
also quells the need for printf calls
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.20 2008/11/02 18:56:30 tg Exp $ */
a151 4
#define runcomm(cmd, nargs, args, outf) runcomm_((const char *)(cmd), \
	    (nargs), (const char * const *)(args), (outf))
int		runcomm_(const char *, int, const char * const *,
		    const char *);
@


1.20
log
@• add new memory management functions (xcalloc, xrealloc, xfree, xstrdup,
  xasprintf, xvasprintf)
• add new process calling functions which can optionally unlimit datasize
• add safe formatting functions (untested)
• retire asystem for xsystem
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.18 2008/10/12 15:35:22 tg Exp $ */
d273 2
@


1.19
log
@rename vsystem into asystem, because v* are these who take a va_list
@
text
@a151 2
int		asystem(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
d248 26
@


1.18
log
@Support for LZMA compressed binary packages (experimental!)

Tested:
• tg@@bleu:/usr/ports/archivers/mpczar $ mmake PKG_SUFX=.clz install clean
• tg@@bleu:~ $ sudo pkg_upgrade -fva /usr/ports/Packages/ssfe-20070109-1.clz

Dependencies on LZMA are *not* handled automatically, also you must use
PKG_SUFX=.clz to enable and ensure lzma is installed prior. This is some-
what hacky, but our package tools suck anyway. The infrastructure allows
for other compressors such as bzip2 too (but that one is not much of a
saving compared to lzma (ratio) and gzip (resource usage) so I did *not*
add it), but in a *lot* of places… should unify that or better, rewrite
all of the package tools in mksh… anyway, please test.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.17 2008/10/12 14:35:17 tg Exp $ */
d152 1
a152 1
int		vsystem(const char *, ...)
@


1.17
log
@generalise running of subcommand
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.16 2008/03/09 17:22:57 tg Exp $ */
d154 4
a157 3
#define runcomm(cmd, nargs, args) runcomm_((const char *)(cmd), (nargs), \
	    (const char * const *)(args))
int		runcomm_(const char *, int, const char * const *);
@


1.16
log
@bulk convert FLAVOR to FLAVOUR; nuke unused file; convert to $Mdocdate
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.15 2007/05/02 21:24:14 bsiegert Exp $ */
d154 3
@


1.15
log
@Finally add correct flavor handling to the package matching code in pkgtools,
handled by multiversion_match() and the new flavorcmp() function. This code was
HARD to write because it has two nested strsep() loops. However, I think that I
have fixed all the edge cases.

You can (and you ought to) test the matching code using pkg_info -e, for
example:

pkg_info -e 'SDL-*-!no_x11'
pkg_info -e 'pango->=1.14,<2.0-!foo,!bar'
pkg_info -e 'ghostscript-*-esp'
pkg_info -e 'ghostscript->=7.0-esp,!no_x11'

I think you get the idea (also of the syntax).
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.14 2007/03/30 23:20:11 bsiegert Exp $ */
d173 1
a173 1
char		*find_flavor(const char *);
@


1.14
log
@Implement one of the points from my todo list: @@emul directives for
plists. If EMUL is set in a port's Makefile (e.g. EMUL=linux for a port
which needs linux emulation), this fact is entered into the package.
pkg_add checks for the relevant emulation.

- introduce new piperead() function, which executes a command and reads
  one line of output. Carefully crafted to avoid errors.
- new option for pkg_create: -e gives an initial value for @@emul
- bsd.port.mk: add -e to PKG_ARGS if EMUL given
- new function have_emulation(): Is the emulation enabled (via sysctl
  -n) or, alternatively, are we already running the "right" OS?
- pkg_info: show @@emul directive
- documentation: document EMUL and @@emul
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.13 2007/01/19 23:11:20 bsiegert Exp $ */
d173 1
@


1.13
log
@Implement a new parameter: pkg_delete -C, will be used for pkg_upgrade IDC.

From the manpage:
     -C      Only delete configuration files that have the same checksum as
             the original file, i.e. those that have not been changed by the
             user.

agreed tg@@
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.12 2006/11/19 22:16:36 bsiegert Exp $ */
d107 2
a108 1
	PLIST_LDCACHE
d154 1
d164 1
@


1.12
log
@Refactor write_deps() to use write_file(). Rewrite write_file() to accept
a mode argument and a format string, change other invocations accordingly.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.11 2006/11/19 12:33:53 tg Exp $ */
d118 7
d224 1
a224 1
int		delete_package(bool, bool, bool, bool, package_t *);
d226 1
a226 1
void		delete_extra(const char *, bool);
@


1.11
log
@pkgtools are built by mirmake, so we always have __RCSID() defined
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.10 2006/11/13 21:49:54 bsiegert Exp $ */
d188 2
a189 1
void		write_file(const char *, const char *);
@


1.10
log
@Refactor the package installation code w.r.t. dependency handling, no
functional changes.

See wlog for more.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.9 2006/10/05 15:11:41 bsiegert Exp $ */
a233 8
#ifndef	__SCCSID
#define	__SCCSID(x)	static const char sccsid[] = x
#endif

#ifndef	__RCSID
#define	__RCSID(x)	static const char rcsid[] = x
#endif

@


1.9
log
@Fix some long-standing bugs w.r.t. package patchlevels:

- introduce find_version() to locate the hyphen the version begins with.
- use it for dewey matches and findbestmatchingname().
- add support for patchlevels to deweycmp().
- update documentation on how to use dewey ops in @@pkgcfl.
- allow same syntax as in dependencies for @@pkgcfl.

The result is that you can do something like
@@pkgcfl subversion-<1.4.0
in your plists. And hey, it works :).
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.8 2006/02/25 15:49:55 bsiegert Exp $ */
d62 1
@


1.8
log
@Add two new routines, drop_privs and raise_privs, to be used in pkg_add.
These don't do anything useful yet.

(wohoo, a commit!)
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.7 2005/09/12 22:53:24 tg Exp $ */
d160 1
@


1.7
log
@join tg-ports-devel branch into HEAD
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.5.2.1 2005/09/11 01:05:44 tg Exp $ */
d152 2
@


1.6
log
@Add extended package name globbing for pkg_info and pkg_delete.
This means that you can do stuff like

% pkg_delete libpixman

without knowing the version. If more than one version is installed (for
example with autoconf), pkg_info will just show you the first match while
pkg_delete refuses to work.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.5 2005/07/18 20:02:00 bsiegert Exp $ */
@


1.5
log
@Update dylib handling to ignore files which are already in the plist, thus
avoiding duplicate entries if libtoolise_plist is used.
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.3 2005/06/24 15:18:57 tg Exp $ */
d192 2
@


1.5.2.1
log
@merge -rHEAD into development branch

Note for bsiegert@@ please don't use csh prompts in man pages any more
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.6 2005/08/21 20:15:45 bsiegert Exp $ */
a191 2
int		trim_end(char *);
int		glob_package(char *, size_t, const char *);
@


1.4
log
@IMPORTANT BUGFIX: Overhaul version number handling to take into account the
fact that version numbers might have hyphens in them. Before, a package
"gs-fonts-std-8.11-0" conflicted only with "gs-fonts-std-8.11-*", which is
not what you want. Not it is "gs-fonts-std-*".

Thus, the policy is: version numbers always begin with a digit, i.e. the
first occurrence of "-[0-9]" in the pkgname is the version.

bug report by and agreed tg@@
@
text
@d205 1
a205 1
void		add_plist_glob(package_t *, plist_t *, const char *, const char *);
@


1.3
log
@cosmetics: don't do MD5 checksums (why MD5, by the way?!)
for symbolic links - symlinks to dirs have NULLMD5 and
warn on deinstallation

untested

agreed and implementation hints bsiegert@@
@
text
@d1 1
a1 1
/**	$MirOS: ports/infrastructure/pkgtools/lib/lib.h,v 1.2 2005/05/22 03:52:48 bsiegert Exp $ */
d158 1
@


1.2
log
@Add new PLIST commands: @@option ldcache, @@option gnu-ld, and @@option static.
@@ldcache is now DEPRECATED.
@
text
@d1 1
a1 1
/**	$MirOS$ */
d170 1
@


1.1
log
@Initial revision
@
text
@d73 2
d109 7
a115 1
/* Types */
@


1.1.7.1
log
@Import the MirPorts Framework, many files moved or renamed though, no KDE/QT
@
text
@@
