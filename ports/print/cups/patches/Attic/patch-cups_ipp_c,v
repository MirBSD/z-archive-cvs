head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2008.10.28.20.31.09;	author bsiegert;	state dead;
branches;
next	1.1;
commitid	1004907762122C91584;

1.1
date	2007.11.26.20.05.40;	author bsiegert;	state Exp;
branches;
next	;
commitid	100474B272B00021692;


desc
@@


1.2
log
@SECURITY: Update cups to 1.3.9-0. This release fixes several security
bugs.

As this updates cups from 1.2 to 1.3, read the release notes when updating,
please.
@
text
@$MirOS: ports/print/cups/patches/patch-cups_ipp_c,v 1.1 2007/11/26 20:05:40 bsiegert Exp $
--- cups/ipp.c.orig	Mon Feb  5 21:25:27 2007
+++ cups/ipp.c	Mon Nov 26 20:39:57 2007
@@@@ -1315,6 +1315,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 	  {
 	    case IPP_TAG_INTEGER :
 	    case IPP_TAG_ENUM :
+		if (n != 4)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 4) < 4)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read integer value!");
@@@@ -1327,6 +1333,12 @@@@ ippReadIO(void       *src,		/* I - Data 
                 value->integer = n;
 	        break;
 	    case IPP_TAG_BOOLEAN :
+		if (n != 1)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 1) < 1)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read boolean value!");
@@@@ -1344,6 +1356,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 	    case IPP_TAG_CHARSET :
 	    case IPP_TAG_LANGUAGE :
 	    case IPP_TAG_MIMETYPE :
+		if (n >= sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 		if ((*cb)(src, buffer, n) < n)
 		{
 		  DEBUG_puts("ippReadIO: unable to read name!");
@@@@ -1356,6 +1374,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 		              value->string.text));
 	        break;
 	    case IPP_TAG_DATE :
+		if (n != 11)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, value->date, 11) < 11)
 		{
 	          DEBUG_puts("ippReadIO: Unable to date integer value!");
@@@@ -1363,6 +1387,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 		}
 	        break;
 	    case IPP_TAG_RESOLUTION :
+		if (n != 9)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 9) < 9)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read resolution value!");
@@@@ -1379,6 +1409,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 		    (ipp_res_t)buffer[8];
 	        break;
 	    case IPP_TAG_RANGE :
+		if (n != 8)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 8) < 8)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read range value!");
@@@@ -1394,7 +1430,7 @@@@ ippReadIO(void       *src,		/* I - Data 
 	        break;
 	    case IPP_TAG_TEXTLANG :
 	    case IPP_TAG_NAMELANG :
-	        if (n > sizeof(buffer) || n < 4)
+	        if (n >= sizeof(buffer) || n < 4)
 		{
 		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
 		  return (IPP_ERROR);
@@@@ -1420,22 +1456,27 @@@@ ippReadIO(void       *src,		/* I - Data 
 
 		n = (bufptr[0] << 8) | bufptr[1];
 
-                if (n >= sizeof(string))
+		if ((bufptr + 2 + n) >= (buffer + sizeof(buffer)) ||
+		    n >= sizeof(string))
 		{
-		  memcpy(string, bufptr + 2, sizeof(string) - 1);
-		  string[sizeof(string) - 1] = '\0';
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
 		}
-		else
-		{
-		  memcpy(string, bufptr + 2, n);
-		  string[n] = '\0';
-                }
 
+		memcpy(string, bufptr + 2, n);
+		string[n] = '\0';
+
 		value->string.charset = _cupsStrAlloc((char *)string);
 
                 bufptr += 2 + n;
 		n = (bufptr[0] << 8) | bufptr[1];
 
+		if ((bufptr + 2 + n) >= (buffer + sizeof(buffer)))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 		bufptr[2 + n] = '\0';
                 value->string.text = _cupsStrAlloc((char *)bufptr + 2);
 	        break;
@@@@ -1477,6 +1518,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 		* we need to carry over...
 		*/
 
+		if (n >= sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, n) < n)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read member name value!");
@@@@ -1498,6 +1545,12 @@@@ ippReadIO(void       *src,		/* I - Data 
 		break;
 
             default : /* Other unsupported values */
+		if (n > sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
                 value->unknown.length = n;
 	        if (n > 0)
 		{
@


1.1
log
@SECURITY: Apply patch from cups STR #2561, fixes CVE-2007-4351.

The vulnerability is caused due to a boundary error within the
"ippReadIO()" function in cups/ipp.c when processing IPP (Internet
Printing Protocol) tags. This can be exploited to overwrite one byte on
the stack with a zero by sending an IPP request containing specially
crafted "textWithLanguage" or "nameWithLanguage" tags.

Successful exploitation allows execution of arbitrary code.
@
text
@d1 1
a1 1
$MirOS$
@

