head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2009.10.17.21.43.58;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004ADA3A7B39AC3403;

1.1
date	2008.05.07.15.53.13;	author tg;	state Exp;
branches;
next	;
commitid	1004821D01929BE53C2;


desc
@@


1.2
log
@new qemu, slight help from pkgsrc® here (website only shows RC…)

• sparc: regression against 0.10.1/linux – fdc probing results
  in a timeout and then an unexpected interrupt or something
  (probably skippable via UKC)
• i386: findcpuspeed division by zero, should be fixable
@
text
@$MirOS: ports/emulators/qemu/snapshot/patches/patch-vl_c,v 1.1 2008/05/07 15:53:13 tg Exp $
$OpenBSD: patch-vl_c,v 1.17 2008/04/28 22:52:38 todd Exp $
$NetBSD: patch-dk,v 1.4 2009/10/11 16:04:13 asau Exp $
--- vl.c.orig	Wed Sep 23 19:01:08 2009
+++ vl.c	Sat Oct 17 17:01:52 2009
@@@@ -567,7 +567,7 @@@@ static void init_get_clock(void)
 {
     use_rt_clock = 0;
 #if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 500000) \
-    || defined(__DragonFly__)
+    || defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)
     {
         struct timespec ts;
         if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
@@@@ -580,7 +580,7 @@@@ static void init_get_clock(void)
 static int64_t get_clock(void)
 {
 #if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 500000) \
-	|| defined(__DragonFly__)
+	|| defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)
     if (use_rt_clock) {
         struct timespec ts;
         clock_gettime(CLOCK_MONOTONIC, &ts);
@@@@ -5555,8 +5555,10 @@@@ int main(int argc, char **argv, char **e
                     if (!strcmp(optarg, "now")) {
                         rtc_date_offset = -1;
                     } else {
+			int notm_year;
+
                         if (sscanf(optarg, "%d-%d-%dT%d:%d:%d",
-                               &tm.tm_year,
+                               &notm_year,
                                &tm.tm_mon,
                                &tm.tm_mday,
                                &tm.tm_hour,
@@@@ -5564,7 +5566,7 @@@@ int main(int argc, char **argv, char **e
                                &tm.tm_sec) == 6) {
                             /* OK */
                         } else if (sscanf(optarg, "%d-%d-%d",
-                                          &tm.tm_year,
+                                          &notm_year,
                                           &tm.tm_mon,
                                           &tm.tm_mday) == 3) {
                             tm.tm_hour = 0;
@@@@ -5573,7 +5575,7 @@@@ int main(int argc, char **argv, char **e
                         } else {
                             goto date_fail;
                         }
-                        tm.tm_year -= 1900;
+                        tm.tm_year = notm_year - 1900;
                         tm.tm_mon--;
                         rtc_start_date = mktimegm(&tm);
                         if (rtc_start_date == -1) {
@


1.1
log
@add qemu-0.9.1 port snitched from openbsd, with most of our old patches
applied, and fixed to build with -Werror as well

pro:
• can netboot openbsd 3.9-current/amd64
• can _almost_ boot mirbsd #10/sparc (bsd.rd has issues with esp, bsd.net
  has none, except I have no rootfs handy ATM)
• can still boot MS-DOS
• said to be able to use kqemu – untested

con:
• regression: can *NOT* boot mirbsd #10/i386 any more
@
text
@d1 1
a1 1
$MirOS$
d3 4
a6 27
--- vl.c.orig	Sun Jan  6 19:38:19 2008
+++ vl.c	Wed May  7 14:26:04 2008
@@@@ -61,7 +61,8 @@@@
 #include <arpa/inet.h>
 #ifdef _BSD
 #include <sys/stat.h>
-#ifndef __APPLE__
+#include <net/if.h>
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
 #include <libutil.h>
 #endif
 #elif defined (__GLIBC__) && defined (__FreeBSD_kernel__)
@@@@ -136,7 +137,7 @@@@ int inet_aton(const char *cp, struct in_
 #ifdef __sun__
 #define SMBD_COMMAND "/usr/sfw/sbin/smbd"
 #else
-#define SMBD_COMMAND "/usr/sbin/smbd"
+#define SMBD_COMMAND MPPREFIX "/libexec/smbd"
 #endif
 
 //#define DEBUG_UNUSED_IOPORT
@@@@ -1206,6 +1207,7 @@@@ static void host_alarm_handler(int host_
     }
 }
 
+#if defined(_WIN32) || defined(__linux__)
 static uint64_t qemu_next_deadline(void)
d8 9
a16 15
     int64_t nearest_delta_us = INT64_MAX;
@@@@ -1229,6 +1231,7 @@@@ static uint64_t qemu_next_deadline(void)
 
     return nearest_delta_us;
 }
+#endif
 
 #ifndef _WIN32
 
@@@@ -3491,7 +3494,7 @@@@ static int parse_macaddr(uint8_t *macadd
     return -1;
 }
 
-static int get_str_sep(char *buf, int buf_size, const char **pp, int sep)
+static int get_str_sep(char *buf, size_t buf_size, const char **pp, int sep)
d18 7
a24 174
     const char *p, *p1;
     int len;
@@@@ -3922,11 +3925,85 @@@@ static int tap_open(char *ifname, int if
     char *dev;
     struct stat s;
 
+    /* If the device was specified on the command line, use it */
+    if (ifname[0]) {
+       TFR(fd = open(ifname, O_RDWR));
+       if (fd < 0) {
+          fprintf(stderr, "warning: could not open %s: no virtual network emulation\n", ifname);
+            return -1;
+       }
+    } else {
+#ifdef __OpenBSD__
+    struct ifreq ifr;
+    int i = 0, enoentcount = 0, err = 0, sock;
+    char dname[100];
+
+    bzero(&ifr, sizeof(ifr));
+    if (ifname != NULL && ifname[0] != '\0') {
+        snprintf(dname, sizeof(dname), "/dev/%s", ifname);
+        strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+        fd = open(dname, O_RDWR);
+    } else {
+        for (; i != -1; i++) {
+           snprintf(dname, sizeof dname, "/dev/tun%d", i);
+           bzero(&ifr.ifr_name, sizeof(ifr.ifr_name));
+           snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", i);
+           TFR(fd = open(dname, O_RDWR));
+           if (fd >= 0)
+               break;
+           else if (errno != ENOENT || ++enoentcount > 3) {
+                if (errno != EBUSY) {
+                    err = errno;
+                    break;
+                } 
+            } else  
+                err = errno;
+        }
+    }
+    if (fd < 0) {
+       fprintf(stderr, "warning: could not open %s (%s): no virtual "
+           "network emulation\n", dname, strerror(err));
+       return -1;
+    }
+
+    /* Set the tunnel device operation mode */
+    if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {
+        close(fd);
+        return -1;
+    }
+
+    /* Get interface flags */
+    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Set interface mode */
+    ifr.ifr_flags &= ~IFF_UP;
+    ifr.ifr_flags |= IFF_LINK0;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Bring interface up */
+    ifr.ifr_flags |= IFF_UP;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+#else
     TFR(fd = open("/dev/tap", O_RDWR));
     if (fd < 0) {
         fprintf(stderr, "warning: could not open /dev/tap: no virtual network emulation\n");
         return -1;
     }
+#endif
+    }
 
     fstat(fd, &s);
     dev = devname(s.st_rdev, S_IFCHR);
@@@@ -4141,6 +4218,7 @@@@ static int net_tap_init(VLANState *vlan,
     TAPState *s;
     int fd;
     char ifname[128];
+    bzero(&ifname,sizeof(ifname));
 
     if (ifname1 != NULL)
         pstrcpy(ifname, sizeof(ifname), ifname1);
@@@@ -4320,7 +4398,7 @@@@ static int net_socket_mcast_create(struc
     /* Force mcast msgs to loopback (eg. several QEMUs in same host */
     val = 1;
     ret=setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
-                   (const char *)&val, sizeof(val));
+                   (const char *)&val, sizeof(char));
     if (ret < 0) {
 	perror("setsockopt(SOL_IP, IP_MULTICAST_LOOP)");
 	goto fail;
@@@@ -4609,7 +4687,8 @@@@ static const char *get_word(char *buf, i
     return p;
 }
 
-static int get_param_value(char *buf, int buf_size,
+static int get_param_value(char *, size_t, const char *, const char *);
+static int get_param_value(char *buf, size_t buf_size,
                            const char *tag, const char *str)
 {
     const char *p;
@@@@ -4748,6 +4827,9 @@@@ static int net_client_init(const char *s
         char ifname[64];
         char setup_script[1024], down_script[1024];
         int fd;
+        bzero(&ifname, sizeof(ifname));
+        bzero(&setup_script, sizeof(setup_script));
+        bzero(&down_script, sizeof(down_script));
         vlan->nb_host_devs++;
         if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {
             fd = strtol(buf, NULL, 0);
@@@@ -4755,16 +4837,16 @@@@ static int net_client_init(const char *s
             if (net_tap_fd_init(vlan, fd))
                 ret = 0;
         } else {
-            if (get_param_value(ifname, sizeof(ifname), "ifname", p) <= 0) {
-                ifname[0] = '\0';
-            }
             if (get_param_value(setup_script, sizeof(setup_script), "script", p) == 0) {
                 pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);
             }
             if (get_param_value(down_script, sizeof(down_script), "downscript", p) == 0) {
                 pstrcpy(down_script, sizeof(down_script), DEFAULT_NETWORK_DOWN_SCRIPT);
             }
-            ret = net_tap_init(vlan, ifname, setup_script, down_script);
+            if (get_param_value(ifname, sizeof(ifname), "ifname", p) == 0)
+               ret = net_tap_init(vlan, NULL, setup_script, down_script);
+            else
+               ret = net_tap_init(vlan, NULL, setup_script, down_script);
         }
     } else
 #endif
@@@@ -8130,19 +8212,23 @@@@ int main(int argc, char **argv)
     gdbstub_port = DEFAULT_GDBSTUB_PORT;
 #endif
     snapshot = 0;
+#if defined(CONFIG_SDL) || defined(CONFIG_COCOA)
     nographic = 0;
+#else
+    nographic = 1;
+#endif
     kernel_filename = NULL;
     kernel_cmdline = "";
     cyls = heads = secs = 0;
     translation = BIOS_ATA_TRANSLATION_AUTO;
-    pstrcpy(monitor_device, sizeof(monitor_device), "vc");
+    pstrcpy(monitor_device, sizeof(monitor_device), nographic ? "stdio" : "vc");
 
-    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), "vc");
+    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), nographic ? "stdio" : "vc");
     for(i = 1; i < MAX_SERIAL_PORTS; i++)
         serial_devices[i][0] = '\0';
     serial_device_index = 0;
 
-    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "vc");
+    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "null");
     for(i = 1; i < MAX_PARALLEL_PORTS; i++)
         parallel_devices[i][0] = '\0';
     parallel_device_index = 0;
@@@@ -8631,8 +8717,10 @@@@ int main(int argc, char **argv)
d26 1
a26 1
                         rtc_start_date = -1;
d36 1
a36 1
@@@@ -8640,7 +8728,7 @@@@ int main(int argc, char **argv)
d45 1
a45 1
@@@@ -8649,7 +8737,7 @@@@ int main(int argc, char **argv)
@

