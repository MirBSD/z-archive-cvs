head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2009.11.22.19.32.33;	author tg;	state dead;
branches;
next	1.2;
commitid	1004B0991C1317436F4;

1.2
date	2009.11.14.22.22.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004AFF2DBF68BB7737;

1.1
date	2009.11.14.21.45.30;	author tg;	state Exp;
branches;
next	;
commitid	1004AFF25061DF717E6;


desc
@@


1.3
log
@update (most of our patches have been accepted, but ekey-rekey is
really FUBAR’d now in upstream, couldn’t work, and the rest are to
fix some really bad programming practice leading to a strcpy
@
text
@$MirOS: ports/security/ekeyd/patches/patch-daemon_ekey-setkey_c,v 1.2 2009/11/14 22:22:59 tg Exp $
--- daemon/ekey-setkey.c.orig	Fri Nov  6 12:33:09 2009
+++ daemon/ekey-setkey.c	Sat Nov 14 23:20:48 2009
@@@@ -40,6 +40,12 @@@@
 /** Exit code returned when utility is unable to write updated keyring */
 #define EXIT_CODE_WRITEKEYRING 6
 
+#define DEVEKEY "/dev/entropykey/"
+
+#if defined(EKEY_OS_OPENBSD) || defined(EKEY_OS_MIRBSD)
+#define ARC4RANDOM_NONCE
+#endif
+
 /** Conenction state. */
 struct econ_state_s {
     uint8_t *mkey; /**< Master key. */
@@@@ -194,7 +200,9 @@@@ main(int argc, char **argv)
     int res;
     uint8_t data[128];
     uint8_t nonce[12];
+#ifndef ARC4RANDOM_NONCE
     int randfd;
+#endif
     uint8_t *mac;
     EKeySkein rekeying_state;
     uint8_t session_key[32];
@@@@ -247,8 +255,8 @@@@ main(int argc, char **argv)
             fprintf(stderr, usage, argv[0]);
             return EXIT_CODE_CMDLINE;
         } else {
-            key_path = calloc(1, 17 + strlen("/dev/entropykey/"));
-            sprintf(key_path, "/dev/entropykey/");
+            key_path = calloc(1, 17 + strlen(DEVEKEY));
+            memcpy(key_path, DEVEKEY, 1 + strlen(DEVEKEY));
             pem64_encode_bytes(snum, 12, key_path + 16);
         }
     } else {
@@@@ -351,6 +359,10 @@@@ main(int argc, char **argv)
     epkt_setsessionkey(epkt, snum, default_session_key);
 
     /* Prepare a nonce */
+#ifdef ARC4RANDOM_NONCE
+    /* XXX we can use MUCH more than 12 here, it's VERY cheap */
+    arc4random_buf(nonce, 12);
+#else
     randfd = open("/dev/urandom", O_RDONLY);
     if (randfd == -1) {
         perror("open(/dev/urandom)");
@@@@ -359,6 +371,7 @@@@ main(int argc, char **argv)
     if (read(randfd, nonce, 12) != 12)
         perror("read");
     close(randfd);
+#endif
 
     /* send nonce MAC */
     mac = calc_mac(snum, mkey, nonce, 12);
@


1.2
log
@use arc4random(3) for nonces, it's MUCH cheaper and saves us one fd
(and, in the future (after checking with Simtec), we can raise nonce size)
@
text
@d1 1
a1 1
$MirOS: ports/security/ekeyd/patches/patch-daemon_ekey-setkey_c,v 1.1 2009/11/14 21:45:30 tg Exp $
@


1.1
log
@experimental port for the Simtec eKey control software
@
text
@d1 1
a1 1
$MirOS$
d3 2
a4 2
+++ daemon/ekey-setkey.c	Sat Nov 14 21:48:09 2009
@@@@ -40,6 +40,8 @@@@
d10 4
d17 11
a27 1
@@@@ -247,8 +249,8 @@@@ main(int argc, char **argv)
d38 19
@

