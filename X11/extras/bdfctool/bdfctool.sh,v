head	1.21;
access;
symbols;
locks; strict;
comment	@# @;


1.21
date	2019.06.10.00.44.25;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005CFDA7FE674C6E0F;

1.20
date	2019.06.09.23.19.58;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005CFD941724C1191E;

1.19
date	2019.06.09.23.16.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005CFD934F77C15201;

1.18
date	2019.06.09.23.00.40;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005CFD8F3A43EDE15D;

1.17
date	2015.02.26.03.05.33;	author tg;	state Exp;
branches;
next	1.16;
commitid	10054EE8D2C63B0FF90;

1.16
date	2015.02.26.02.02.16;	author tg;	state Exp;
branches;
next	1.15;
commitid	10054EE7EBA63199D9D;

1.15
date	2015.02.26.01.17.30;	author tg;	state Exp;
branches;
next	1.14;
commitid	10054EE74311B255113;

1.14
date	2015.02.26.01.05.48;	author tg;	state Exp;
branches;
next	1.13;
commitid	10054EE717A56DE64E6;

1.13
date	2015.02.25.23.27.32;	author tg;	state Exp;
branches;
next	1.12;
commitid	10054EE5A73302F4CCE;

1.12
date	2013.05.17.21.51.40;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005196A67E6412229B;

1.11
date	2012.09.01.19.00.01;	author tg;	state Exp;
branches;
next	1.10;
commitid	10050425B35572A869F;

1.10
date	2012.09.01.18.42.58;	author tg;	state Exp;
branches;
next	1.9;
commitid	100504257280B9EC31A;

1.9
date	2012.08.23.20.26.15;	author tg;	state Exp;
branches;
next	1.8;
commitid	100503691D671F9AC18;

1.8
date	2012.08.23.19.36.21;	author tg;	state Exp;
branches;
next	1.7;
commitid	100503685A765D8F036;

1.7
date	2012.08.23.18.58.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	10050367D55644F4CEB;

1.6
date	2012.08.23.18.54.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050367C9B13323749;

1.5
date	2012.08.23.17.30.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	100503668856FAB9450;

1.4
date	2012.08.23.17.13.56;	author tg;	state Exp;
branches;
next	1.3;
commitid	100503664E13FFF8CEB;

1.3
date	2012.08.23.16.26.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	100503659B661428596;

1.2
date	2012.08.18.16.44.30;	author tg;	state Exp;
branches;
next	1.1;
commitid	100502FC6824FA642BD;

1.1
date	2012.08.18.15.16.16;	author tg;	state Exp;
branches;
next	;
commitid	100502FB1697B79D35E;


desc
@@


1.21
log
@life could be so nice… found in the wild
@
text
@#!/bin/mksh
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.20 2019/06/09 23:19:58 tg Exp $
#-
# Copyright © 2007, 2008, 2009, 2010, 2012, 2013, 2015, 2019
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.

set -o noglob

uascii=-1
ufast=0
oform=0
while getopts "acdeFGgh" ch; do
	case $ch {
	(a) uascii=1 ;;
	(+a) uascii=0 ;;
	(c|d|e|+e) mode=$ch oform=0 ;;
	(F) ufast=1 oform=0 ;;
	(G) oform=4 ;;
	(g) oform=3 ;;
	(h) mode=$ch ;;
	(*) mode= ;;
	}
done
shift $((OPTIND - 1))
(( $# )) && mode=

if [[ $mode = ?(h) ]] || [[ $mode != e && $uascii != -1 ]] || \
    [[ $mode != d && $ufast$oform != 00 ]]; then
	print -ru2 "Usage: ${0##*/} -c | -d [-FGg] | -e [-a] | +e"
	[[ $mode = h ]]; exit $?
fi

# check padding on input, currently
(( chkpad = (oform == 3 || oform == 4) ))

# disable -F if -g
(( ufast = (oform == 3 || oform == 4) ? 0 : ufast ))

rln=0
function rdln {
	local e
	nameref rdln_ln=$1

	IFS= read -r rdln_ln
	e=$?
	(( e )) && return $e
	let ++rln
	rdln_ln=${rdln_ln%%*( )?()}
	[[ $rdln_ln = *([ -~]) ]] && return 0
	print -ru2 "E: non-ASCII line $rln: ${rdln_ln@@Q}"
	exit 5
}

function chknameline {
	local uc=$1 nf=${#f[*]}

	if (( nf < 4 || nf > 5 )); then
		local cp=U+$uc ln=$2 es
		[[ -n $uc ]] || cp="U<${f[1]@@Q}>"
		[[ -n $ln ]] || ln="${f[*]}"

		if (( nf < 4 )); then
			es='not enough'
		else
			es='too many'
		fi
		print -ru2 "E: $es fields $nf in name line $lno at $cp: ${ln@@Q}"
		exit 2
	fi

	if [[ -z ${f[4]} || ( -n $uc && ${f[4]} = "uni$uc" ) ]]; then
		unset f[4]
	else
		[[ ${f[4]} = "${f[4]::14}" ]] || print -ru2 \
		    "W: overlong glyph name ${f[4]@@Q} at line $lno"
		#f[4]=${f[4]::14}
	fi

	if [[ ${f[2]} != [1-9]*([0-9]) ]] || \
	    (( (w = f[2]) > 32 || w < 1 )); then
		print -ru2 "E: width ${f[2]@@Q} not in 1‥32 at line $lno"
		exit 2
	fi
}

lno=0
if [[ $mode = e ]]; then
	if (( uascii == 1 )); then
		set -A BITv -- '.' '#' '|'
	else
		set -A BITv -- '　' '䷀' '▌'
	fi
	while rdln line; do
		(( ++lno ))
		if [[ $line = 'e '* ]]; then
			set -A f -- $line
			chknameline
			print -r -- "${f[*]}"
			i=${f[3]}
			while (( i-- )); do
				if rdln line; then
					print -r -- "$line"
					continue
				fi
				print -ru2 "E: Unexpected end of 'e' command" \
				    "at line $lno"
				exit 2
			done
			(( lno += f[3] ))
			continue
		fi
		if [[ $line != 'c '* ]]; then
			print -r -- "$line"
			continue
		fi
		set -A f -- $line
		chknameline
		if (( w <= 8 )); then
			adds=000000
		elif (( w <= 16 )); then
			adds=0000
		elif (( w <= 24 )); then
			adds=00
		else
			adds=
		fi
		(( shiftbits = 32 - w ))
		(( uw = 2 + w ))
		IFS=:
		set -A bmp -- ${f[3]}
		IFS=$' \t\n'
		f[0]=e
		f[3]=${#bmp[*]}
		print -r -- "${f[*]}"
		chl=0
		for ch in "${bmp[@@]}"; do
			(( ++chl ))
			if [[ $ch != +([0-9A-F]) ]]; then
				print -ru2 "E: char '$ch' at #$chl in line $lno not hex"
				exit 2
			fi
			ch=$ch$adds
			if (( ${#ch} != 8 )); then
				print -ru2 "E: char '$ch' at #$chl in line $lno not valid"
				exit 2
			fi
			typeset -Uui2 -Z$uw bbin=16#$ch
			(( bbin >>= shiftbits ))
			b=${bbin#2#}
			b=${b//0/${BITv[0]}}
			b=${b//1/${BITv[1]}}
			print -r -- $b${BITv[2]}
		done
	done
	exit 0
fi

Fdef=		# currently valid 'd' line
set -A Fhead	# lines of file header, including comments intersparsed
set -A Fprop	# lines of file properties, same
set -A Gprop	# glyph property line (from Fdef), per glyph
set -A Gdata	# glyph data line, per glyph
set -A Gcomm	# glyph comments (if any) as string, per glyph
set -A Fcomm	# lines of comments at end of file

state=0

function parse_bdfc_file {
	local last

	set -A last
	while rdln line; do
		(( ++lno ))
		if [[ $line = C ]]; then
			Fprop+=("${last[@@]}")
			state=1
			return
		elif [[ $line = '=bdfc 1' ]]; then
			set -A hFBB
			continue
		fi
		last+=("$line")
		case $line {
		(\'|\'\ *)
			continue
			;;
		(hFONTBOUNDINGBOX\ +([0-9])\ +([0-9])\ +([0-9-])\ +([0-9-]))
			set -A hFBB -- $line
			Fhead+=("${last[@@]}")
			;;
		(h*)
			Fhead+=("${last[@@]}")
			;;
		(p*)
			Fprop+=("${last[@@]}")
			;;
		(*)
			print -ru2 "E: invalid line $lno: '$line'"
			exit 2
			;;
		}
		set -A last
	done
	Fprop+=("${last[@@]}")
	(( chkpad )) && if [[ -z $hFBB ]]; then
		print -ru2 "E: missing FONTBOUNDINGBOX header"
		exit 2
	fi
	state=2
}

function parse_bdfc_edit {
	local shiftbits uw line r i

	if (( w <= 8 )); then
		(( shiftbits = 8 - w ))
		(( uw = 5 ))
	elif (( w <= 16 )); then
		(( shiftbits = 16 - w ))
		(( uw = 7 ))
	elif (( w <= 24 )); then
		(( shiftbits = 24 - w ))
		(( uw = 9 ))
	else
		(( shiftbits = 32 - w ))
		(( uw = 11 ))
	fi

	if [[ ${f[3]} != [1-9]*([0-9]) ]] || \
	    (( (i = f[3]) < 1 || i > 999 )); then
		print -ru2 "E: nonsensical number of lines ${f[3]@@Q} in" \
		    "line $lno, U+${ch#16#}"
		exit 2
	fi

	while (( i-- )); do
		if ! rdln line; then
			print -ru2 "E: Unexpected end of 'e' command" \
			    "at line $lno, U+${ch#16#}"
			exit 2
		fi
		(( ++lno ))
		linx=${line//　/.}
		linx=${linx//䷀/#}
		linx=${linx//▌/|}
		linx=${linx//[ .]/0}
		linx=${linx//[#*]/1}
		if [[ $linx != +([01])'|' || ${#linx} != $((w + 1)) ]]; then
			print -ru2 "E: U+${ch#16#} (line $lno) bitmap line" \
			    $((f[3] - i)) "invalid: '$line'"
			exit 2
		fi
		linx=${linx%'|'}
		typeset -Uui16 -Z$uw bhex=2#$linx
		(( bhex <<= shiftbits ))
		r+=${bhex#16#}:
	done
	f[3]=${r%:}
	f[0]=c
}

function parse_bdfc_glyph {
	local last

	set -A last
	while rdln line; do
		(( ++lno ))
		if [[ $line = . ]]; then
			Fcomm+=("${last[@@]}")
			state=0
			return
		fi
		if [[ $line = \' || $line = "' "* ]]; then
			last+=("$line")
			continue
		fi
		set -A f -- $line
		if [[ ${f[0]} = d ]]; then
			Fdef="${f[*]}"
			(( chkpad )) && if [[ ${f[5]},${f[6]} != ${hFBB[3]},${hFBB[4]} ]]; then
				print -ru2 "E: d line $lno does not match FONTBOUNDINGBOX … ${hFBB[3]} ${hFBB[4]}"
				exit 2
			fi
			continue
		fi
		if [[ ${f[0]} != [ce] ]]; then
			print -ru2 "E: invalid line $lno: '$line'"
			exit 2
		fi
		if [[ $Fdef != 'd '* ]]; then
			print -ru2 "E: char at line $lno without defaults set"
			exit 2
		fi
		if [[ ${f[1]} != [0-9A-F][0-9A-F][0-9A-F][0-9A-F] ]]; then
			print -ru2 "E: invalid encoding '${f[1]}' at line $lno"
			exit 2
		fi
		typeset -Uui16 -Z7 ch=16#${f[1]}
		chknameline "${ch#16#}" "$line"
		(( chkpad )) && if [[ $w != "${hFBB[1]}" ]]; then
			print -ru2 "E: c line $lno width $w does not match FONTBOUNDINGBOX ${hFBB[1]}"
			exit 2
		fi
		if [[ ${f[0]} = e ]]; then
			parse_bdfc_edit
		else
			if (( w <= 8 )); then
				x='+([0-9A-F][0-9A-F]:)'
			elif (( w <= 16 )); then
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			elif (( w <= 24 )); then
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			else
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			fi
			if eval [[ '${f[3]}:' != "$x" ]]; then
				print -ru2 "E: invalid hex encoding for" \
				    "U+${ch#16#}, line $lno: '${f[3]}'"
				exit 2
			fi
		fi
		if (( chkpad )); then
			x=${f[3]//[!:]}
			if (( (${#x} + 1) != hFBB[2] )); then
				print -ru2 "E: c line $lno height $((${#x} + 1)) does not match FONTBOUNDINGBOX ${hFBB[2]}"
				exit 2
			fi
		fi
		Gdata[ch]="${f[*]}"
		for line in "${last[@@]}"; do
			Gcomm[ch]+=$line$'\n'
		done
		set -A last
		Gprop[ch]=$Fdef
	done
	Fcomm+=("${last[@@]}")
	state=2
}

function parse_bdfc {
	while :; do
		case $state {
		(0) parse_bdfc_file ;;
		(1) parse_bdfc_glyph ;;
		(2) return 0 ;;
		}
	done
	print -ru2 "E: internal error (at line $lno), shouldn't happen"
	exit 255
}

function parse_bdf {
	set -A hFBB
	while rdln line; do
		(( ++lno ))
		case $line {
		(COMMENT)
			Fhead+=("'")
			;;
		(COMMENT@@([	 ])*)
			Fhead+=("' ${line#COMMENT[	 ]}")
			;;
		(STARTPROPERTIES\ +([0-9]))
			break
			;;
		(FONTBOUNDINGBOX\ +([0-9])\ +([0-9])\ +([0-9-])\ +([0-9-]))
			set -A hFBB -- $line
			Fhead+=("h$line")
			;;
		(*)
			Fhead+=("h$line")
			;;
		}
	done
	(( chkpad )) && if [[ -z $hFBB ]]; then
		print -ru2 "E: missing FONTBOUNDINGBOX header"
		exit 2
	fi
	set -A f -- $line
	numprop=${f[1]}
	while rdln line; do
		(( ++lno ))
		case $line {
		(COMMENT)
			Fprop+=("'")
			;;
		(COMMENT@@([	 ])*)
			Fprop+=("' ${line#COMMENT[	 ]}")
			;;
		(ENDPROPERTIES)
			break
			;;
		(*)
			Fprop+=("p$line")
			let --numprop
			;;
		}
	done
	if (( numprop )); then
		print -ru2 "E: expected ${f[1]} properties, got" \
		    "$((f[1] - numprop)) in line $lno"
		exit 2
	fi
	while rdln line; do
		(( ++lno ))
		case $line {
		(COMMENT)
			Fprop+=("'")
			;;
		(COMMENT@@([	 ])*)
			Fprop+=("' ${line#COMMENT[	 ]}")
			;;
		(CHARS\ +([0-9]))
			break
			;;
		(*)
			print -ru2 "E: expected CHARS not '$line' in line $lno"
			exit 2
			;;
		}
	done
	set -A f -- $line
	numchar=${f[1]}
	set -A cc
	set -A cn
	set -A ce
	set -A cs
	set -A cd
	set -A cb
	while rdln line; do
		(( ++lno ))
		case $line {
		(COMMENT)
			cc+=("'")
			;;
		(COMMENT@@([	 ])*)
			cc+=("' ${line#COMMENT[	 ]}")
			;;
		(STARTCHAR\ *)
			set -A cn -- $line
			;;
		(ENCODING\ +([0-9]))
			set -A ce -- $line
			;;
		(SWIDTH\ +([0-9-])\ +([0-9-]))
			set -A cs -- $line
			;;
		(DWIDTH\ +([0-9-])\ +([0-9-]))
			set -A cd -- $line
			;;
		(BBX\ +([0-9])\ +([0-9])\ +([0-9-])\ +([0-9-]))
			set -A cb -- $line
			(( chkpad )) && if [[ ${cb[1]},${cb[2]},${cb[3]},${cb[4]} != ${hFBB[1]},${hFBB[2]},${hFBB[3]},${hFBB[4]} ]]; then
				print -ru2 "E: BBX in line $lno does not match FONTBOUNDINGBOX ${hFBB[1]} ${hFBB[2]} ${hFBB[3]} ${hFBB[4]}"
				exit 2
			fi
			;;
		(BITMAP)
			if [[ -z $cn ]]; then
				print -ru2 "E: missing STARTCHAR in line $lno"
				exit 2
			fi
			if [[ -z $ce ]]; then
				print -ru2 "E: missing ENCODING in line $lno"
				exit 2
			fi
			if [[ -z $cs ]]; then
				print -ru2 "E: missing SWIDTH in line $lno"
				exit 2
			fi
			if [[ -z $cd ]]; then
				print -ru2 "E: missing DWIDTH in line $lno"
				exit 2
			fi
			if [[ -z $cb ]]; then
				print -ru2 "E: missing BBX in line $lno"
				exit 2
			fi
			typeset -Uui16 -Z7 ch=10#${ce[1]}
			if (( ch < 0 || ch > 0xFFFF )); then
				print -ru2 "E: encoding ${ce[1]} out of" \
				    "bounds in line $lno"
				exit 2
			fi
			Gprop[ch]="d ${cs[1]} ${cs[2]} ${cd[1]} ${cd[2]} ${cb[3]} ${cb[4]}"
			set -A f c ${ch#16#} ${cb[1]} - ${cn[1]}
			chknameline "${ch#16#}"
			if (( w <= 8 )); then
				ck='[0-9A-F][0-9A-F]'
			elif (( w <= 16 )); then
				ck='[0-9A-F][0-9A-F][0-9A-F][0-9A-F]'
			elif (( w <= 24 )); then
				ck='[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]'
			else
				ck='[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]'
			fi
			if (( (numlines = cb[2]) )); then
				bmps=
				typeset -u linu
				while rdln linx; do
					(( ++lno ))
					linu=$linx
					while eval [[ '$linu' != "$ck" ]]; do
						if [[ $linu = *00 ]]; then
							linu=${linu%00}
							continue
						fi
						print -ru2 "E: invalid hex encoding" \
						    "for U+${ch#16#} (dec. $((ch)))" \
						    "on line $lno: '$linx'"
						exit 2
					done
					bmps+=$linu:
					(( --numlines )) || break
				done
				f[3]=${bmps%:}
			else
				f[2]=1
				f[3]=00
			fi
			if ! rdln line || [[ $line != ENDCHAR ]]; then
				print -ru2 "E: expected ENDCHAR after line $lno"
				exit 2
			fi
			(( ++lno ))
			Gdata[ch]="${f[*]}"
			[[ -n $cc ]] && for line in "${cc[@@]}"; do
				Gcomm[ch]+=$line$'\n'
			done
			set -A cc
			set -A cn
			set -A ce
			set -A cs
			set -A cd
			set -A cb
			;;
		(ENDFONT)
			break
			;;
		(*)
			print -ru2 "E: unexpected '$line' in line $lno"
			exit 2
			;;
		}
	done
	Fcomm+=("${cc[@@]}")
	for line in "${cn[*]}" "${ce[*]}" "${cs[*]}" "${cd[*]}" "${cb[*]}"; do
		[[ -n $line ]] || continue
		print -ru2 "E: unexpected '$line' between last char and ENDFONT"
		exit 2
	done
	if (( numchar != ${#Gdata[*]} )); then
		print -ru2 "E: expected $numchar glyphs, got ${#Gdata[*]}"
		exit 2
	fi
	while rdln line; do
		(( ++lno ))
		case $line {
		(COMMENT)
			Fcomm+=("'")
			;;
		(COMMENT@@([	 ])*)
			Fcomm+=("' ${line#COMMENT[	 ]}")
			;;
		(*)
			print -ru2 "E: unexpected '$line' past ENDFONT" \
			    "in line $lno"
			exit 2
			;;
		}
	done
}

if [[ $mode = c ]]; then
	if ! rdln line; then
		print -ru2 "E: read error at BOF"
		exit 2
	fi
	lno=1
	if [[ $line = 'STARTFONT 2.1' ]]; then
		parse_bdf
	elif [[ $line = '=bdfc 1' ]]; then
		parse_bdfc
	else
		print -ru2 "E: not BDF or bdfc at BOF: '$line'"
		exit 2
	fi

	# write .bdfc stream

	for line in '=bdfc 1' "${Fhead[@@]}" "${Fprop[@@]}"; do
		print -r -- "$line"
	done
	print C
	Fdef=
	for x in ${!Gdata[*]}; do
		if [[ ${Gprop[x]} != "$Fdef" ]]; then
			Fdef=${Gprop[x]}
			print -r -- $Fdef
		fi
		print -r -- "${Gcomm[x]}${Gdata[x]}"
	done
	for line in "${Fcomm[@@]}"; do
		print -r -- "$line"
	done
	print .
	exit 0
fi

if [[ $mode = +e ]]; then
	while rdln line; do
		(( ++lno ))
		if [[ $line = \' || $line = "' "* ]]; then
			print -r -- "$line"
			continue
		fi
		set -A f -- $line
		if [[ ${f[0]} != [ce] ]]; then
			print -ru2 "E: invalid line $lno: '$line'"
			exit 2
		fi
		if [[ ${f[1]} != [0-9A-F][0-9A-F][0-9A-F][0-9A-F] ]]; then
			print -ru2 "E: invalid encoding '${f[1]}' at line $lno"
			exit 2
		fi
		typeset -Uui16 -Z7 ch=16#${f[1]}
		chknameline "${ch#16#}" "$line"
		if [[ ${f[0]} = e ]]; then
			parse_bdfc_edit
		else
			if (( w <= 8 )); then
				x='+([0-9A-F][0-9A-F]:)'
			elif (( w <= 16 )); then
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			elif (( w <= 24 )); then
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			else
				x='+([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]:)'
			fi
			if eval [[ '${f[3]}:' != "$x" ]]; then
				print -ru2 "E: invalid hex encoding for" \
				    "U+${ch#16#}, line $lno: '${f[3]}'"
				exit 2
			fi
		fi
		print -r -- "${f[@@]}"
	done
	exit 0
fi

if [[ $mode != d ]]; then
	print -ru2 "E: cannot happen (control flow issue in ${0##*/}:$LINENO)"
	exit 255
fi

if ! rdln line; then
	print -ru2 "E: read error at BOF"
	exit 2
fi
lno=1

if (( ufast )); then
	if [[ $line != '=bdfc 1' ]]; then
		print -ru2 "E: not bdfc at BOF: '$line'"
		exit 2
	fi
	if ! T=$(mktemp /tmp/bdfctool.XXXXXXXXXX); then
		print -u2 E: cannot make temporary file
		exit 4
	fi
	# quickly parse bdfc header
	set -A last
	while rdln line; do
		[[ $line = C ]] && break
		last+=("$line")
		[[ $line = \' || $line = "' "* ]] && continue
		if [[ $line = h* ]]; then
			Fhead+=("${last[@@]}")
		else
			Fprop+=("${last[@@]}")
		fi
		set -A last
	done
	Fprop+=("${last[@@]}")
elif [[ $line = 'STARTFONT 2.1' ]]; then
	# parse entire BDF file into memory
	parse_bdf
elif [[ $line = '=bdfc 1' ]]; then
	# parse entire bdfc file into memory
	parse_bdfc
else
	print -ru2 "E: not BDF or bdfc at BOF: '$line'"
	exit 2
fi

# analyse data for BDF
numprop=0
for line in "${Fprop[@@]}"; do
	[[ $line = p* ]] && let ++numprop
done
(( ufast )) || numchar=${#Gdata[*]}

# handle diverging and non-ufast output formats
case $oform {
(3)
	# little-endian .gdf
	function out_int32 {
		typeset -Uui16 value=$1
		typeset -Uui8 ba bb bc bd

		(( bd = (value >> 24) & 0xFF ))
		(( bc = (value >> 16) & 0xFF ))
		(( bb = (value >> 8) & 0xFF ))
		(( ba = value & 0xFF ))
		print -n "\\0${ba#8#}\\0${bb#8#}\\0${bc#8#}\\0${bd#8#}"
	}
	;|
(4)
	# big-endian .gdf
	function out_int32 {
		typeset -Uui16 value=$1
		typeset -Uui8 ba bb bc bd

		(( ba = (value >> 24) & 0xFF ))
		(( bb = (value >> 16) & 0xFF ))
		(( bc = (value >> 8) & 0xFF ))
		(( bd = value & 0xFF ))
		print -n "\\0${ba#8#}\\0${bb#8#}\\0${bc#8#}\\0${bd#8#}"
	}
	;|
(3|4)
	# do some input analysis for .gdf output
	if [[ -z $hFBB ]]; then
		print -ru2 "E: missing FONTBOUNDINGBOX header"
		exit 2
	fi
	set -A f -- ${!Gdata[*]}
	typeset -i firstch=${f[0]} lastch=${f[${#f[*]} - 1]}
	nullch=
	x=$((hFBB[1] * hFBB[2]))
	while (( x-- )); do
		nullch+=\\0
	done
	if (( hFBB[1] <= 8 )); then
		adds=000000
	elif (( hFBB[1] <= 16 )); then
		adds=0000
	elif (( hFBB[1] <= 24 )); then
		adds=00
	else
		adds=
	fi
	# write .gdf stream
	out_int32 $((# lastch - firstch + 1))
	out_int32 $((# firstch))
	out_int32 $((# hFBB[1]))
	out_int32 $((# hFBB[2]))
	typeset -i curch
	((# curch = firstch - 1 ))
	while ((# ++curch <= lastch )); do
		set -A f -- ${Gdata[curch]}
		if [[ -z $f ]]; then
			print -n "$nullch"
			continue
		fi
		IFS=:
		set -A bmp -- ${f[3]}
		IFS=$' \t\n'
		s=
		for line in "${bmp[@@]}"; do
			typeset -Uui2 bbin=16#$line$adds
			x=${hFBB[1]}
			while (( x-- )); do
				s+=\\0$(( (bbin & 0x80000000) ? 377 : 0 ))
				(( bbin <<= 1 ))
			done
		done
		print -n "$s"
	done
	exit 0
	;;
}

# write BDF stream
print 'STARTFONT 2.1'
for line in "${Fhead[@@]}"; do
	if [[ $line = h* ]]; then
		print -r -- "${line#h}"
	else
		print -r -- "COMMENT${line#\'}"
	fi
done
set -A last
print STARTPROPERTIES $((numprop))
for line in "${Fprop[@@]}"; do
	if [[ $line = p* ]]; then
		last+=("${line#p}")
	else
		last+=("COMMENT${line#\'}")
		continue
	fi
	for line in "${last[@@]}"; do
		print -r -- "$line"
	done
	set -A last
done
print ENDPROPERTIES
for line in "${last[@@]}"; do
	print -r -- "$line"
done
if (( ufast )); then
	numchar=0
	# directly transform font data
	set -A last
	while rdln line; do
		[[ $line = . ]] && break
		if [[ $line = \' || $line = "' "* ]]; then
			last+=("$line")
			continue
		fi
		set -A f -- $line
		if [[ ${f[0]} = d ]]; then
			set -A xprop -- $line
			continue
		fi
		typeset -Uui16 -Z7 ch=16#${f[1]}
		for line in "${last[@@]}"; do
			print -r -- "COMMENT${line#\'}"
		done
		set -A last
		IFS=:
		set -A bmp -- ${f[3]}
		IFS=$' \t\n'
		cat <<-EOF
			STARTCHAR ${f[4]:-uni${ch#16#}}
			ENCODING $((ch))
			SWIDTH ${xprop[1]} ${xprop[2]}
			DWIDTH ${xprop[3]} ${xprop[4]}
			BBX ${f[2]} ${#bmp[*]} ${xprop[5]} ${xprop[6]}
			BITMAP
		EOF
		for line in "${bmp[@@]}"; do
			print $line
		done
		print ENDCHAR
		let ++numchar
	done >"$T"
	Fcomm+=("${last[@@]}")
	print CHARS $((numchar))
	cat "$T"
	rm -f "$T"
else
	print CHARS $((numchar))
	for x in ${!Gdata[*]}; do
		IFS=$'\n'
		set -A xcomm -- ${Gcomm[x]}
		IFS=$' \t\n'
		for line in "${xcomm[@@]}"; do
			print -r -- "COMMENT${line#\'}"
		done
		set -A xprop -- ${Gprop[x]}
		set -A f -- ${Gdata[x]}
		IFS=:
		set -A bmp -- ${f[3]}
		IFS=$' \t\n'
		typeset -Uui16 -Z7 ch=16#${f[1]}
		cat <<-EOF
			STARTCHAR ${f[4]:-uni${ch#16#}}
			ENCODING $((ch))
			SWIDTH ${xprop[1]} ${xprop[2]}
			DWIDTH ${xprop[3]} ${xprop[4]}
			BBX ${f[2]} ${#bmp[*]} ${xprop[5]} ${xprop[6]}
			BITMAP
		EOF
		for line in "${bmp[@@]}"; do
			print $line
		done
		print ENDCHAR
	done
fi
for line in "${Fcomm[@@]}"; do
	print -r -- "COMMENT${line#\'}"
done
print ENDFONT
exit 0
@


1.20
log
@strip trailing space on input (found in some BDF files in the wild);
document that more input validation should be added
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.19 2019/06/09 23:16:23 tg Exp $
d89 3
a91 1
		f[4]=${f[4]::14}
@


1.19
log
@handle CR-LF line endings; ensure printable ASCII only is used
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.12 2013/05/17 21:51:40 tg Exp $
d63 1
a63 1
	rdln_ln=${rdln_ln%}
@


1.18
log
@BDF glyph names are actually up to 14 characters, no blanks

• bdfctool: better enforce this
• pwrline.ed: use better name for branch symbol

also tweak pwrline lock symbol y offset while here
@
text
@d54 15
d106 1
a106 1
	while IFS= read -r line; do
d114 1
a114 1
				if IFS= read -r line; then
d185 1
a185 1
	while IFS= read -r line; do
d250 1
a250 1
		if ! IFS= read -r line; then
d279 1
a279 1
	while IFS= read -r line; do
d367 1
a367 1
	while IFS= read -r line; do
d394 1
a394 1
	while IFS= read -r line; do
d417 1
a417 1
	while IFS= read -r line; do
d443 1
a443 1
	while IFS= read -r line; do
d513 1
a513 1
				while IFS= read -r linx; do
d534 1
a534 1
			if ! IFS= read -r line || [[ $line != ENDCHAR ]]; then
d569 1
a569 1
	while IFS= read -r line; do
d588 1
a588 1
	if ! IFS= read -r line; then
d624 1
a624 1
	while IFS= read -r line; do
d669 1
a669 1
if ! IFS= read -r line; then
d686 1
a686 1
	while IFS= read -r line; do
d828 1
a828 1
	while IFS= read -r line; do
@


1.17
log
@so people won’t rely on it, make -cde reset -Gg; also, kill +F

future will bring -F as special case, -e as special codepath
(for handling partial bdfc(c/eU/eA) to bdfc(eU/eA) conversion)
and everything else (-BbcdeGg) output format selectors with
arbitrary (BDF/bdfc(c/e)) input; -F will no longer require -d
@
text
@d4 2
a5 2
# Copyright © 2007, 2008, 2009, 2010, 2012, 2013, 2015
#	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
d54 30
d95 2
a97 1
			print -r -- "$line"
d115 1
a115 4
		if (( (w = f[2]) > 32 || w < 1 )); then
			print -ru2 "E: width ${f[2]} not in 1‥32 at line $lno"
			exit 2
		fi
d211 1
a211 1
	local w shiftbits uw line r i
d213 1
a213 1
	if (( (w = f[2]) <= 8 )); then
d227 3
a229 2
	if (( (i = f[3]) < 1 || i > 999 )); then
		print -ru2 "E: nonsensical number of lines '${f[3]}' in" \
d297 3
a299 7
		if (( ${#f[*]} < 4 || ${#f[*]} > 5 )); then
			print -ru2 "E: invalid number of fields on line $lno" \
			    "at U+${ch#16#}: ${#f[*]}: '$line'"
			exit 2
		fi
		if (( f[2] < 1 || f[2] > 32 )); then
			print -ru2 "E: width ${f[2]} not in 1‥32 at line $lno"
a301 5
		(( chkpad )) && if [[ ${f[2]} != ${hFBB[1]} ]]; then
			print -ru2 "E: c line $lno width ${f[2]} does not match FONTBOUNDINGBOX ${hFBB[1]}"
			exit 2
		fi
		[[ ${f[4]} = "uni${ch#16#}" ]] && unset f[4]
d305 1
a305 1
			if (( f[2] <= 8 )); then
d307 1
a307 1
			elif (( f[2] <= 16 )); then
d309 1
a309 1
			elif (( f[2] <= 24 )); then
d485 2
a486 2
			[[ ${f[4]} = "uni${ch#16#}" ]] && unset f[4]
			if (( f[2] <= 8 )); then
d488 1
a488 1
			elif (( f[2] <= 16 )); then
d490 1
a490 1
			elif (( f[2] <= 24 )); then
d625 1
a625 10
		if (( ${#f[*]} < 4 || ${#f[*]} > 5 )); then
			print -ru2 "E: invalid number of fields on line $lno" \
			    "at U+${ch#16#}: ${#f[*]}: '$line'"
			exit 2
		fi
		if (( f[2] < 1 || f[2] > 32 )); then
			print -ru2 "E: width ${f[2]} not in 1‥32 at line $lno"
			exit 2
		fi
		[[ ${f[4]} = "uni${ch#16#}" ]] && unset f[4]
d629 1
a629 1
			if (( f[2] <= 8 )); then
d631 1
a631 1
			elif (( f[2] <= 16 )); then
d633 1
a633 1
			elif (( f[2] <= 24 )); then
@


1.16
log
@rudimentary .gdf output support
@
text
@d31 2
a32 3
	(c|d|e|+e) mode=$ch ;;
	(F) ufast=1 ;;
	(+F) ufast=0 ;;
@


1.15
log
@permit -d (not -Fd though) to read .bdf (gives sense to some of the
checks added in the previous commit)
@
text
@d4 1
a4 1
# Copyright © 2012, 2013, 2015
d27 1
a27 1
while getopts "acdeFgh" ch; do
d34 1
d45 1
a45 1
	print -ru2 "Usage: ${0##*/} -c | -d [-Fg] | -e [-a] | +e"
d50 1
a50 1
(( chkpad = (oform == 3) ))
d53 1
a53 1
(( ufast = (oform == 3) ? 0 : ufast ))
d691 81
@


1.14
log
@check padding on input, for use with .gdf output format
@
text
@a647 4
if [[ $line != '=bdfc 1' ]]; then
	print -ru2 "E: not bdfc at BOF: '$line'"
	exit 2
fi
d650 4
d672 4
a675 1
else
d678 3
@


1.13
log
@ignore an arbitrary amount of trailing NUL bytes when parsing .bdf
@
text
@d26 2
a27 1
while getopts "acdeFh" ch; do
d34 1
d43 2
a44 2
    [[ $mode != d && $ufast != 0 ]]; then
	print -ru2 "Usage: ${0##*/} -c | -d [-F] | -e [-a] | +e"
d48 6
d149 1
d153 9
a161 2
		[[ $line = \' || $line = "' "* ]] && continue
		if [[ $line = h* ]]; then
d163 2
a164 1
		elif [[ $line = p* ]]; then
d166 3
a168 2
		else
			print -ru2 "E: invalid line #$lno: '$line'"
d170 2
a171 1
		fi
d175 4
d218 1
a218 1
			print -ru2 "E: U+${ch#16#} (line #$lno) bitmap line" \
d249 4
d256 1
a256 1
			print -ru2 "E: invalid line #$lno: '$line'"
d277 4
d300 7
d331 1
d344 4
d353 4
d431 4
d597 1
a597 1
			print -ru2 "E: invalid line #$lno: '$line'"
@


1.12
log
@add un-edit mode
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.11 2012/09/01 19:00:01 tg Exp $
d4 2
a5 2
# Copyright © 2012, 2013
#	Thorsten Glaser <tg@@mirbsd.org>
d427 1
a427 1
				while IFS= read -r linu; do
d429 6
a434 1
					if eval [[ '$linu' != "$ck" ]]; then
d437 1
a437 1
						    "on line $lno: '$linu'"
d439 1
a439 1
					fi
@


1.11
log
@accept lowercase hex in BDF; fix 'STARTCHAR *' by set -o noglob
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.10 2012/09/01 18:42:58 tg Exp $
d4 1
a4 1
# Copyright © 2012
d30 1
a30 1
	(c|d|e) mode=$ch ;;
d42 1
a42 1
	print -ru2 "Usage: ${0##*/} -c | -d [-F] | -e [-a]"
d532 50
@


1.10
log
@add fast-export (-Fd) – reduces time by more than half on the
not-unifont-amended 9x18.bdfc already; this improves O(n²) on
larger fontsets
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.9 2012/08/23 20:26:15 tg Exp $
d22 2
d426 2
a427 1
				while IFS= read -r line; do
d429 1
a429 1
					if eval [[ '$line' != "$ck" ]]; then
d432 1
a432 1
						    "on line $lno: '$line'"
d435 1
a435 1
					bmps+=$line:
@


1.9
log
@disable strict mode, simplifies the parser and saves about one CPU second
on on 9x15.bdf (4877 four-nibble glyphs), that’s 6.4% (i.e. noticeable)
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.8 2012/08/23 19:36:21 tg Exp $
d23 2
a24 1
while getopts "acdeh" ch; do
d28 4
a31 1
	(c|d|e|h) mode=$ch ;;
d38 3
a40 2
if [[ $mode = ?(h) ]]; then
	print -ru2 "Usage: ${0##*/} -c | -d | -e [-a]"
a117 5
if (( uascii != -1 )); then
	print -ru2 "E: ±a not allowed for -$mode mode"
	exit 1
fi

d544 23
a566 1
parse_bdfc
d573 1
a573 1
numchar=${#Gdata[*]}
d602 68
a669 7
print CHARS $((numchar))
for x in ${!Gdata[*]}; do
	IFS=$'\n'
	set -A xcomm -- ${Gcomm[x]}
	IFS=$' \t\n'
	for line in "${xcomm[@@]}"; do
		print -r -- "COMMENT${line#\'}"
d671 1
a671 19
	set -A xprop -- ${Gprop[x]}
	set -A f -- ${Gdata[x]}
	IFS=:
	set -A bmp -- ${f[3]}
	IFS=$' \t\n'
	typeset -Uui16 -Z7 ch=16#${f[1]}
	cat <<-EOF
		STARTCHAR ${f[4]:-uni${ch#16#}}
		ENCODING $((ch))
		SWIDTH ${xprop[1]} ${xprop[2]}
		DWIDTH ${xprop[3]} ${xprop[4]}
		BBX ${f[2]} ${#bmp[*]} ${xprop[5]} ${xprop[6]}
		BITMAP
	EOF
	for line in "${bmp[@@]}"; do
		print $line
	done
	print ENDCHAR
done
@


1.8
log
@make this more useful with actual fonts

note that this will probably still need to wait for hashtable-backed arrays
in mksh… it took over ten CPU minutes to compress the 18x18ko.bdf (the one
amended by GNU Unifont, with 43795 glyphs) and about nine to decompress it,
and I don’t believe it’s me writing x+=("$y") ipv set -A x+ -- "$y" or the
strict check upon decompression… still, decent results, everything works in
the cases it should (ENCODING -1 is not supported), and the savings in file
lines (important for CVS) are factor ten to twenty-five(!) as imagined…
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.5 2012/08/23 17:30:06 tg Exp $
a138 5
			if (( strict )); then
				print -ru2 "E: another begin of file" \
				    "on line $lno"
				exit 3
			fi
d214 1
a214 6
			if (( strict )) && read x; then
				print -ru2 "E: data '$x' past end of file" \
				    "on line $lno"
				exit 3
			fi
			state=3
a249 5
			if (( strict )); then
				print -ru2 "E: edit not allowed in strict" \
				    "mode at U+${ch#16#}, line $lno: '$line'"
				exit 3
			fi
d283 1
a283 11
		(2)
			if (( strict )); then
				print -ru2 "E: Unexpected EOF at line $lno"
				exit 3
			fi
			return 0
			;;
		(3)
			(( strict )) && return 0
			state=0
			;;
a501 1
		strict=0
a543 1
strict=1
@


1.7
log
@fix counting glyphs
@
text
@d255 1
a255 1
			print -ru2 "E: width ${f[2]} not in 1#32 at line $lno"
d447 18
a464 14
			bmps=
			numlines=${cb[2]}
			while IFS= read -r line; do
				(( ++lno ))
				if eval [[ '$line' != "$ck" ]]; then
					print -ru2 "E: invalid hex encoding" \
					    "for U+${ch#16#} (dec. $((ch)))" \
					    "on line $lno: '$line'"
					exit 2
				fi
				bmps+=$line:
				(( --numlines )) || break
			done
			f[3]=${bmps%:}
@


1.6
log
@ensure $lno balance for good error messages
@
text
@d376 1
@


1.5
log
@• bdfctool: add BDF parser for -c (compress) operation
• bdfctool: fix regression tests
  • bdf2jupp, jupp2bdf: remove, now obsolete by bdfctool -c | -e
• hook bdfctool to the build
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.2 2012/08/18 16:44:30 tg Exp $
d191 1
d461 1
a461 1
				print -ru2 "E: expected ENDCHAR in line $lno"
d464 1
@


1.4
log
@• fix typos
• handle only-empty-comment lines
@
text
@d87 1
d314 197
@


1.3
log
@• better comment handling
• decompression into BDF
@
text
@d146 1
a146 1
		[[ $line = "' "* ]] && continue
d214 1
a214 1
		(( +lno ))
d225 1
a225 1
		if [[ $line = "' "* ]]; then
d351 1
a351 1
	print -u2 "E: cannot happen (control flow issue in ${0##*/}:$LINENO)"
d381 1
a381 1
		print -r -- "COMMENT ${line#\' }"
d390 1
a390 1
		last+=("COMMENT ${line#\' }")
d408 1
a408 1
		print -r -- "COMMENT ${line#\' }"
d430 1
a430 1
	print -r -- "COMMENT ${line#\' }"
@


1.2
log
@bdfc file parsing and emitting
@
text
@d2 1
a2 1
# $MirOS: X11/extras/bdfctool/bdfctool.sh,v 1.1 2012/08/18 15:16:16 tg Exp $
d134 1
a134 1
			(( ${#last[@@]} )) && Fprop+=("${last[@@]}")
d138 5
d157 1
a157 1
	(( ${#last[@@]} )) && Fprop+=("${last[@@]}")
d216 1
a216 1
			(( ${#last[@@]} )) && Fcomm+=("${last[@@]}")
d281 4
a284 6
		if (( ${#last[@@]} )); then
			for line in "${last[@@]}"; do
				Gcomm[ch]+=$line$'\n'
			done
			set -A last
		fi
d287 1
a287 1
	(( ${#last[@@]} )) && Fcomm+=("${last[@@]}")
d349 85
@


1.1
log
@get -e working and decorate it with -a (and +a to revert to default)
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $
d35 1
a35 1
	print -u2 "Usage: ${0##*/} -c | -d | -e [-a]"
d57 1
a57 1
				print -u2 "E: Unexpected end of 'e' command" \
d113 1
a113 1
	print -u2 "E: ±a not allowed for -$mode mode"
d116 230
@

