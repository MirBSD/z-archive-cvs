head	1.9;
access;
symbols
	MIRBSD_10_BASE:1.9
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	evilwm-0_99_18:1.1.201.2
	evilwm-0_99_17:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.9
date	2006.10.16.20.43.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004533EED23F5C770C;

1.8
date	2006.08.14.19.05.19;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044E0C9850E7540C9;

1.7
date	2006.08.14.18.59.47;	author tg;	state Exp;
branches;
next	1.6;
commitid	10044E0C82D7E3DEA2E;

1.6
date	2006.08.14.18.57.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044E0C7C657C8A08A;

1.5
date	2005.12.17.05.46.04;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043A3A3E65E20A413;

1.4
date	2005.11.22.22.35.34;	author tg;	state Exp;
branches;
next	1.3;
commitid	778a43839d3b41f6;

1.3
date	2005.07.07.18.27.13;	author tg;	state Exp;
branches;
next	1.2;
commitid	27f942cd73fd1fbe;

1.2
date	2005.03.19.13.30.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.04.40;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.01.04.40;	author tg;	state Exp;
branches;
next	1.1.201.2;

1.1.201.2
date	2005.07.07.18.07.02;	author tg;	state Exp;
branches;
next	;
commitid	5f4742cd6f554c49;


desc
@@


1.9
log
@add a function to evilwm to spawn a "normal" xterm,
"C" even if evilwm was started in a utf-8 locale, and
not inheriting parent environment etc., running /bin/sh
@
text
@/* $MirOS: X11/extras/evilwm/events.c,v 1.8 2006/08/14 19:05:19 tg Exp $ */

/*-
 * Copyright (c) 2004, 2005, 2006
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
 */

/* evilwm - Minimalist Window Manager for X
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
 * see README for license and other details. */

#include <stdlib.h>
#include <X11/Xatom.h>
#include "evilwm.h"
#include "log.h"

__RCSID("$MirOS: X11/extras/evilwm/events.c,v 1.8 2006/08/14 19:05:19 tg Exp $");

static void handle_key_event(XKeyEvent *e) {
	Client *c = find_client(e->window);
	KeySym key = XKeycodeToKeysym(dpy,e->keycode,0);

	if (!c)
		c = current;
	if (c) {
		switch (key) {
		/* Sorry about all these if (0)s, but they actually
		 * *do* do something useful... */
		case KEY_LEFT:
			c->x -= 16; if (0)
		case KEY_DOWN:
			c->y += 16; if (0)
		case KEY_UP:
			c->y -= 16; if (0)
		case KEY_RIGHT:
			c->x += 16; if (0)
		case KEY_TOPLEFT:
			{ c->x = c->border; c->y = c->border; } if (0)
		case KEY_TOPRIGHT:
			{ c->x = DisplayWidth(dpy, c->screen->screen)-c->width-c->border; c->y = c->border; } if (0)
		case KEY_BOTTOMLEFT:
			{ c->x = c->border; c->y = DisplayHeight(dpy, c->screen->screen)-c->height-c->border; } if (0)
		case KEY_BOTTOMRIGHT:
			{ c->x = DisplayWidth(dpy, c->screen->screen)-c->width-c->border; c->y = DisplayHeight(dpy, c->screen->screen)-c->height-c->border; }
			moveresize(c);
			setmouse(c->window, c->width + c->border - 1,
					c->height + c->border - 1);
			/* Need to think about this - see note about shaped
			 * windows in TODO */
			break;
		case KEY_SLEFT:
			c->width -= c->width_inc; if (0)
		case KEY_SDOWN:
			c->height += c->height_inc; if (0)
		case KEY_SUP:
			c->height -= c->height_inc; if (0)
		case KEY_SRIGHT:
			c->width += c->width_inc;
			if (c->width < 1)
				c->width = 1;
			if (c->height < 1)
				c->height = 1;
			moveresize(c);
			setmouse(c->window, c->width + c->border - 1,
					c->height + c->border - 1);
			/* Need to think about this - see note about shaped
			 * windows in TODO */
			break;
		case KEY_KILL:
			send_wm_delete(c); break;
		case KEY_LOWER: case KEY_ALTLOWER:
			XLowerWindow(dpy, c->parent);
			break;
		case KEY_INFO:
			show_info(c, key);
			break;
		case KEY_MAX:
			maximise_horiz(c);
		case KEY_MAXVERT:
			maximise_vert(c);
			moveresize(c);
			setmouse(c->window, c->width + c->border - 1,
					c->height + c->border - 1);
			break;
#ifdef VWM
		case KEY_FIX:
			c->vdesk = c->vdesk == STICKY ? vdesk : STICKY;
			client_update_current(c, current);
			break;
#endif
		}
	}
	switch(key) {
		case KEY_NEW:
			spawn(opt_term); break;
		case KEY_NEXT:
			next();
			break;
#ifdef VWM
		case XK_1: case XK_2: case XK_3: case XK_4:
		case XK_5: case XK_6: case XK_7: case XK_8:
			switch_vdesk(KEY_TO_VDESK(key));
			break;
		case KEY_PREVDESK:
			if (vdesk > KEY_TO_VDESK(XK_1))
				switch_vdesk(vdesk - 1);
			break;
		case KEY_NEXTDESK:
			if (vdesk < KEY_TO_VDESK(XK_8))
				switch_vdesk(vdesk + 1);
			break;
#endif
		case KEY_EXTERMF:
			spawn(sane_term); break;
			break;
	}
}

#ifdef MOUSE
static void handle_button_event(XButtonEvent *e) {
	Client *c = find_client(e->window);

	if (c && e->window != c->screen->root) {
		switch (e->button) {
			case Button1:
				drag(c); break;
			case Button2:
				sweep(c); break;
			case Button3:
				XLowerWindow(dpy, c->parent); break;
		}
	}
}
#endif

static void handle_configure_request(XConfigureRequestEvent *e) {
	Client *c = find_client(e->window);
	XWindowChanges wc;

	wc.sibling = e->above;
	wc.stack_mode = e->detail;
	if (c) {
		ungravitate(c);
		if (e->value_mask & CWWidth) c->width = e->width;
		if (e->value_mask & CWHeight) c->height = e->height;
		if (e->value_mask & CWX) c->x = e->x;
		if (e->value_mask & CWY) c->y = e->y;
		if (c->x == 0 && c->width >= DisplayWidth(dpy, c->screen->screen)) {
			c->x -= c->border;
		}
		if (c->y == 0 && c->height >= DisplayHeight(dpy, c->screen->screen)) {
			c->y -= c->border;
		}
		gravitate(c);

		wc.x = c->x - c->border;
		wc.y = c->y - c->border;
		wc.width = c->width + (c->border*2);
		wc.height = c->height + (c->border*2);
		wc.border_width = 0;
		XConfigureWindow(dpy, c->parent, e->value_mask, &wc);
		send_config(c);
		LOG_DEBUG("handle_configure_request() : window configured to %dx%d+%d+%d\n", c->width, c->height, c->x, c->y);
	}

	wc.x = c ? c->border : e->x;
	wc.y = c ? c->border : e->y;
	wc.width = e->width;
	wc.height = e->height;
	XConfigureWindow(dpy, e->window, e->value_mask, &wc);
}

static void handle_map_request(XMapRequestEvent *e) {
	Client *c = find_client(e->window);

	if (c) {
#ifdef VWM
		if (c->vdesk != vdesk)
			switch_vdesk(c->vdesk);
#endif
		unhide(c, RAISE);
	} else {
		XWindowAttributes attr;
		LOG_DEBUG("handle_map_request() : don't know this window, calling make_new_client();\n");
		XGetWindowAttributes(dpy, e->window, &attr);
		make_new_client(e->window, find_screen(attr.root));
	}
}

static void handle_unmap_event(XUnmapEvent *e) {
	Client *c = find_client(e->window);

	if (c) {
		if (c->ignore_unmap) c->ignore_unmap--;
		else remove_client(c);
	}
}

static void handle_reparent_event(XReparentEvent *e) {
	Client *c = find_client(e->window);
	/* If an unmanaged window is reparented such that its new parent is
	 * a root window and it is not in WithdrawnState, manage it */
	if (!c) {
		ScreenInfo *s = find_screen(e->parent);
		if (s) {
			XWindowAttributes attr;
			XGetWindowAttributes(dpy, e->window, &attr);
			if (attr.map_state != WithdrawnState) {
				LOG_DEBUG("handle_reparent_event(): window reparented to root - making client\n");
				make_new_client(e->window, s);
			}
		}
	}
}

#ifdef COLOURMAP
static void handle_colormap_change(XColormapEvent *e) {
	Client *c = find_client(e->window);

	if (c && e->new) {
		c->cmap = e->colormap;
		XInstallColormap(dpy, c->cmap);
	}
}
#endif

static void handle_property_change(XPropertyEvent *e) {
	Client *c = find_client(e->window);

	if (c) {
		if (e->atom == XA_WM_NORMAL_HINTS) {
			get_wm_normal_hints(c);
		}
	}
}

static void handle_enter_event(XCrossingEvent *e) {
	Client *c;

	current_screen = find_screen(e->root);
	if ((c = find_client(e->window))) {
#ifdef VWM
		if (c->vdesk != vdesk && c->vdesk != STICKY)
			return;
#endif
		select_client(c);
#ifdef MOUSE
		grab_button(c->parent, grabmask2, AnyButton);
#endif
	}
}

#ifdef SHAPE
static void handle_shape_event(XShapeEvent *e) {
	Client *c = find_client(e->window);
	if (c)
		set_shape(c);
}
#endif

void event_main_loop(void) {
	XEvent ev;
	/* main event loop here */
	for (;;) {
		XNextEvent(dpy, &ev);
		switch (ev.type) {
			case KeyPress:
				handle_key_event(&ev.xkey); break;
#ifdef MOUSE
			case ButtonPress:
				handle_button_event(&ev.xbutton); break;
#endif
			case ConfigureRequest:
				handle_configure_request(&ev.xconfigurerequest); break;
			case MapRequest:
				handle_map_request(&ev.xmaprequest); break;
#ifdef COLOURMAP
			case ColormapNotify:
				handle_colormap_change(&ev.xcolormap); break;
#endif
			case EnterNotify:
				handle_enter_event(&ev.xcrossing); break;
			case PropertyNotify:
				handle_property_change(&ev.xproperty); break;
			case UnmapNotify:
				handle_unmap_event(&ev.xunmap); break;
			case ReparentNotify:
				handle_reparent_event(&ev.xreparent); break;
#ifdef SHAPE
			default:
				if (have_shape && ev.type == shape_event) {
					handle_shape_event((XShapeEvent *)&ev);
				}
#endif
		}
	}
}
@


1.8
log
@RCS IDs
@
text
@d1 1
a1 1
/* $MirOS: X11/extras/evilwm/events.c,v 1.7 2006/08/14 18:59:47 tg Exp $ */
d5 1
a5 1
 *	Thorsten Glaser <tg@@mirbsd.de>
d33 1
a33 1
__RCSID("$MirOS$");
d129 3
@


1.7
log
@also move the mouse cursor appropriately on keyboard resizing
same caveats apply
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.14 2006/08/09 19:35:23 tg Rel $ */
d33 2
@


1.6
log
@sync licence, make __CRAZY clean
@
text
@d78 4
@


1.5
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d1 1
a1 1
/* $MirOS: X11/extras/evilwm/events.c,v 1.4 2005/11/22 22:35:34 tg Exp $ */
d4 2
a5 2
 * Copyright (c) 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d21 1
a21 1
 * the possibility of such damage or existence of a nontrivial bug.
@


1.4
log
@remove that `=exit functionality... shoot myself into foot right now... again
@
text
@d1 1
a1 1
/* $MirOS: X11/extras/evilwm/events.c,v 1.3 2005/07/07 18:27:13 tg Exp $ */
d14 8
a21 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
@


1.3
log
@Finish the update of evilwm, taking care of local changes, strlcpy
cleanup, fixes for resize/move etc.
@
text
@d1 1
a1 1
/* $MirOS: X11/extras/evilwm/events.c,v 1.2 2005/03/19 13:30:08 tg Exp $ */
a121 3
		case KEY_EXITF:
			handle_signal(0);
			break; /* can't happen */
@


1.2
log
@merge over X11/extras

XXX rewrite evilwm man page in -mdoc
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.2 2005/03/03 19:43:30 tg Rel $ */
d4 1
a4 1
 * Copyright (c) 2004
d24 1
a24 1
 * Copyright (C) 1999-2002 Ciaran Anscomb <evilwm@@6809.org.uk>
a26 1
#include "evilwm.h"
d29 2
a30 4
#include <stdio.h>
#ifdef SHAPE
#include <X11/extensions/shape.h>
#endif
d32 1
a32 1
void handle_key_event(XKeyEvent *e) {
d58 1
a58 1
			move(c, 1);
d61 2
d65 1
a65 1
			c->width -= c->size->width_inc; if (0)
d67 1
a67 1
			c->height += c->size->height_inc; if (0)
d69 1
a69 1
			c->height -= c->size->height_inc; if (0)
d71 1
a71 1
			c->width += c->size->width_inc;
d76 1
a76 1
			resize(c, 1);
d90 1
a90 1
			resize(c, 1);
a96 3
#ifdef VDESK_BOTH
			spawn_vdesk(c->vdesk, c);
#endif
d129 1
a129 1
void handle_button_event(XButtonEvent *e) {
d135 1
a135 1
				move(c, 0); break;
d137 1
a137 1
				resize(c, 0); break;
d145 1
a145 1
void handle_configure_request(XConfigureRequestEvent *e) {
d172 1
a172 3
#ifdef DEBUG
		fprintf(stderr, "handle_configure_request() : window configured to %dx%d+%d+%d\n", wc.width, wc.height, wc.x, wc.y);
#endif
d182 1
a182 1
void handle_map_request(XMapRequestEvent *e) {
d193 1
a193 3
#ifdef DEBUG
		fprintf(stderr, "handle_map_request() : don't know this window, calling make_new_client();\n");
#endif
d199 1
a199 1
void handle_unmap_event(XUnmapEvent *e) {
a202 4
#ifdef DEBUG
		/* fprintf(stderr, "handle_unmap_event() : ignore_unmap = %d\n", c->ignore_unmap);
		 * */
#endif
d208 1
a208 2
#ifdef VDESK
void handle_client_message(XClientMessageEvent *e) {
d210 13
a222 3

	if (c && e->message_type == xa_wm_change_state &&
		e->format == 32 && e->data.l[0] == IconicState) hide(c);
a223 1
#endif
d226 1
a226 1
void handle_colormap_change(XColormapEvent *e) {
d236 1
a236 1
void handle_property_change(XPropertyEvent *e) {
a237 1
	long dummy;
d240 3
a242 2
		if (e->atom == XA_WM_NORMAL_HINTS)
				XGetWMNormalHints(dpy, c->window, c->size, &dummy);
d246 1
a246 1
void handle_enter_event(XCrossingEvent *e) {
a247 3
#ifdef VWM
	int wdesk;
#endif
a249 4
	/* if (e->window == root && !current) {
		XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
		return;
	} */
d252 1
a252 2
		wdesk = c->vdesk;
		if (wdesk != vdesk && wdesk != STICKY)
d255 1
a255 6
#ifdef COLOURMAP
		XInstallColormap(dpy, c->cmap);
#endif
		client_update_current(current, c);
		client_update_current(c, current);
		XSetInputFocus(dpy, c->window, RevertToPointerRoot, CurrentTime);
d257 1
a257 1
		grab_button(c->parent, Mod1Mask, AnyButton);
a261 6
void handle_leave_event(XCrossingEvent *e) {
	/* if (e->window == root && !e->same_screen) {
		client_update_current(current, NULL);
	} */
}

d263 1
a263 1
void handle_shape_event(XShapeEvent *e) {
d269 38
@


1.1
log
@Initial revision
@
text
@d1 22
d65 14
d126 3
@


1.1.201.1
log
@evilwm 0.99.17
@
text
@@


1.1.201.2
log
@There is a new evilwm out there!
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
d5 1
d8 4
a11 2
#include "evilwm.h"
#include "log.h"
d13 1
a13 1
static void handle_key_event(XKeyEvent *e) {
d39 1
a39 1
			moveresize(c);
a41 2
			/* Need to think about this - see note about shaped
			 * windows in TODO */
d55 1
a55 1
			moveresize(c);
d62 3
d94 1
a94 1
static void handle_button_event(XButtonEvent *e) {
d100 1
a100 1
				drag(c); break;
d102 1
a102 1
				sweep(c); break;
d110 1
a110 1
static void handle_configure_request(XConfigureRequestEvent *e) {
d137 3
a139 1
		LOG_DEBUG("handle_configure_request() : window configured to %dx%d+%d+%d\n", c->width, c->height, c->x, c->y);
d149 1
a149 1
static void handle_map_request(XMapRequestEvent *e) {
d160 3
a162 1
		LOG_DEBUG("handle_map_request() : don't know this window, calling make_new_client();\n");
d168 1
a168 1
static void handle_unmap_event(XUnmapEvent *e) {
d172 4
d181 2
a182 1
static void handle_reparent_event(XReparentEvent *e) {
d184 3
a186 13
	/* If an unmanaged window is reparented such that its new parent is
	 * a root window and it is not in WithdrawnState, manage it */
	if (!c) {
		ScreenInfo *s = find_screen(e->parent);
		if (s) {
			XWindowAttributes attr;
			XGetWindowAttributes(dpy, e->window, &attr);
			if (attr.map_state != WithdrawnState) {
				LOG_DEBUG("handle_reparent_event(): window reparented to root - making client\n");
				make_new_client(e->window, s);
			}
		}
	}
d188 1
d191 1
a191 1
static void handle_colormap_change(XColormapEvent *e) {
d201 1
a201 1
static void handle_property_change(XPropertyEvent *e) {
d203 1
d206 2
a207 3
		if (e->atom == XA_WM_NORMAL_HINTS) {
			get_wm_normal_hints(c);
		}
d211 1
a211 1
static void handle_enter_event(XCrossingEvent *e) {
d213 3
d218 4
d224 2
a225 1
		if (c->vdesk != vdesk && c->vdesk != STICKY)
d228 6
a233 1
		select_client(c);
d235 1
a235 1
		grab_button(c->parent, grabmask2, AnyButton);
d240 6
d247 1
a247 1
static void handle_shape_event(XShapeEvent *e) {
a252 38

void event_main_loop(void) {
	XEvent ev;
	/* main event loop here */
	for (;;) {
		XNextEvent(dpy, &ev);
		switch (ev.type) {
			case KeyPress:
				handle_key_event(&ev.xkey); break;
#ifdef MOUSE
			case ButtonPress:
				handle_button_event(&ev.xbutton); break;
#endif
			case ConfigureRequest:
				handle_configure_request(&ev.xconfigurerequest); break;
			case MapRequest:
				handle_map_request(&ev.xmaprequest); break;
#ifdef COLOURMAP
			case ColormapNotify:
				handle_colormap_change(&ev.xcolormap); break;
#endif
			case EnterNotify:
				handle_enter_event(&ev.xcrossing); break;
			case PropertyNotify:
				handle_property_change(&ev.xproperty); break;
			case UnmapNotify:
				handle_unmap_event(&ev.xunmap); break;
			case ReparentNotify:
				handle_reparent_event(&ev.xreparent); break;
#ifdef SHAPE
			default:
				if (have_shape && ev.type == shape_event) {
					handle_shape_event((XShapeEvent *)&ev);
				}
#endif
		}
	}
}
@

