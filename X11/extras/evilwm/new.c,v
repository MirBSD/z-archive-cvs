head	1.6;
access;
symbols
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	evilwm-0_99_18:1.1.201.2
	evilwm-0_99_17:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.6
date	2006.08.14.19.05.19;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044E0C9850E7540C9;

1.5
date	2006.06.15.19.18.44;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004491B2706C2443B2;

1.4
date	2005.07.14.18.42.17;	author tg;	state Exp;
branches;
next	1.3;
commitid	413742d6b1f702fb;

1.3
date	2005.07.07.18.27.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	27f942cd73fd1fbe;

1.2
date	2005.03.19.13.30.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches;
next	1.1.201.2;

1.1.201.2
date	2005.07.07.18.07.02;	author tg;	state Exp;
branches;
next	;
commitid	5f4742cd6f554c49;


desc
@@


1.6
log
@RCS IDs
@
text
@/* evilwm - Minimalist Window Manager for X
 * Copyright (c) 2004-2005 Thorsten Glaser <tg@@MirBSD.de>
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
 * see README for license and other details. */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "evilwm.h"
#include "log.h"

__RCSID("$MirOS$");

#ifdef MWM_HINTS
static PropMwmHints *get_mwm_hints(Window);
#endif
#ifdef XDEBUG
static const char *map_state_string(int map_state);
static const char *gravity_string(int gravity);
static void debug_wm_normal_hints(XSizeHints *size);
#else
# define debug_wm_normal_hints(s)
#endif
static void init_geometry(Client *c);
static void reparent(Client *c);

void make_new_client(Window w, ScreenInfo *s) {
	Client *c;
	char *name;
	XClassHint *class;
#ifdef MWM_HINTS
	PropMwmHints *mhints;
#endif

	XGrabServer(dpy);

	/* First a bit of interaction with the error handler due to X's
	 * tendancy to batch event notifications.  We set a global variable to
	 * the id of the window we're initialising then do simple X call on
	 * that window.  If an error is raised by this (and nothing else should
	 * do so as we've grabbed the server), the error handler resets the
	 * variable indicating the window has already disappeared, so we stop
	 * trying to manage it. */
	initialising = w;
	XFetchName(dpy, w, &name);
	/* If 'initialising' is now set to None, that means doing the
	 * XFetchName raised BadWindow - the window has been removed before
	 * we got a chance to grab the server. */
	if (initialising == None) {
		LOG_DEBUG("make_new_client() : XError occurred for initialising window - aborting...\n");
		XSync(dpy, False);
		XUngrabServer(dpy);
		return;
	}
	initialising = None;
	LOG_DEBUG("make_new_client(): %s\n", name ? name : "Untitled");

	c = malloc(sizeof(Client));
	/* Don't crash the window manager, just fail the operation. */
	if (!c) {
		LOG_ERROR("out of memory in new_client; limping onward\n");
		return;
	}
	c->next = head_client;
	head_client = c;

	c->screen = s;
	c->window = w;
	c->ignore_unmap = 0;

	c->border = opt_bw;
#ifdef MWM_HINTS
	if ((mhints = get_mwm_hints(c->window))) {
		if (mhints->flags & MWM_HINTS_DECORATIONS
				&& !(mhints->decorations & MWM_DECOR_ALL)) {
			if (!(mhints->decorations & MWM_DECOR_BORDER)) {
				c->border = 0;
			}
		}
		XFree(mhints);
	}
#endif
	/* If we don't have MWM_HINTS (i.e., lesstif) for a client to tell us
	 * it has no border, I include this *really blatant hack* to remove
	 * the border from XMMS. */
	if (name) {
#ifndef MWM_HINTS
		if (!strncmp("XMMS", name, 4))
			c->border = 0;
#endif
		XFree(name);  /* But we want to free this anyway... */
	}

	init_geometry(c);
	c->x -= c->border;
	c->y -= c->border;

#ifdef VWM
	c->vdesk = vdesk;
#endif

#ifdef DEBUG
	{
		Client *p;
		int i = 0;
		for (p = head_client; p; p = p->next)
			i++;
		LOG_DEBUG("make_new_client() : new window %dx%d+%d+%d, wincount=%d\n", c->width, c->height, c->x, c->y, i);
	}
#endif

#ifdef COLOURMAP
	XSelectInput(dpy, c->window, ColormapChangeMask | EnterWindowMask | PropertyChangeMask);
#else
	XSelectInput(dpy, c->window, EnterWindowMask | PropertyChangeMask);
#endif

	reparent(c);

	XMapWindow(dpy, c->window);
	XMapRaised(dpy, c->parent);
	set_wm_state(c, NormalState);

	XSync(dpy, False);
	XUngrabServer(dpy);

#ifdef SHAPE
	if (have_shape) {
	    XShapeSelectInput(dpy, c->window, ShapeNotifyMask);
	    set_shape(c);
	}
#endif

	/* Read instance/class information for client and check against list
	 * built with -app options */
	class = XAllocClassHint();
	if (class) {
		Application *a = head_app;
		XGetClassHint(dpy, w, class);
		while (a) {
			if ((!a->res_name || (class->res_name && !strcmp(class->res_name, a->res_name)))
					&& (!a->res_class || (class->res_class && !strcmp(class->res_class, a->res_class)))) {
				if (a->geometry_mask & WidthValue)
					c->width = a->width * c->width_inc;
				if (a->geometry_mask & HeightValue)
					c->height = a->height * c->height_inc;
				if (a->geometry_mask & XValue) {
					if (a->geometry_mask & XNegative)
						c->x = a->x + DisplayWidth(dpy, s->screen)-c->width-c->border;
					else
						c->x = a->x + c->border;
				}
				if (a->geometry_mask & YValue) {
					if (a->geometry_mask & YNegative)
						c->y = a->y + DisplayHeight(dpy, s->screen)-c->height-c->border;
					else
						c->y = a->y + c->border;
				}
				moveresize(c);
#ifdef VWM
				if (a->vdesk != -1) c->vdesk = a->vdesk;
				if (vdesk != c->vdesk && c->vdesk != STICKY) {
					hide(c);
				}
#endif
			}
			a = a->next;
		}
		XFree(class->res_name);
		XFree(class->res_class);
		XFree(class);
	}

	//send_config(c);
#ifndef MOUSE
	setmouse(c->window, c->width + c->border - 1,
			c->height + c->border - 1);
#endif
}

/* Calls XGetWindowAttributes, XGetWMHints and XGetWMNormalHints to determine
 * window's initial geometry.
 *
 * XGetWindowAttributes 
 */
static void init_geometry(Client *c) {
	CARD32 size_flags;
	XWindowAttributes attr;
	XWMHints *wm;
	int reconfigure = 0;

	/* Get current window attributes */
	LOG_XDEBUG("XGetWindowAttributes()\n");
	XGetWindowAttributes(dpy, c->window, &attr);
	LOG_XDEBUG("\t(%s) %dx%d+%d+%d, bw = %d\n", map_state_string(attr.map_state), attr.width, attr.height, attr.x, attr.y, attr.border_width);
	c->old_border = attr.border_width;
	c->oldw = c->oldh = 0;
#ifdef COLOURMAP
	c->cmap = attr.colormap;
#endif

	size_flags = get_wm_normal_hints(c);

	if ((attr.width >= c->min_width) && (attr.height >= c->min_height)) {
	//if (attr.map_state == IsViewable || (size_flags & (PSize | USSize))) {
		c->width = attr.width;
		c->height = attr.height;
	} else {
		c->width = c->min_width;
		c->height = c->min_height;
		reconfigure = 1;
	}
	if ((attr.map_state == IsViewable)
			|| (size_flags & (/*PPosition |*/ USPosition))) {
		c->x = attr.x;
		c->y = attr.y;
	} else {
#ifdef MOUSE
		int xmax = DisplayWidth(dpy, c->screen->screen);
		int ymax = DisplayHeight(dpy, c->screen->screen);
		int x, y;
		get_mouse_position(&x, &y, c->screen->root);
		c->x = (x * (xmax - c->border - c->width)) / xmax;
		c->y = (y * (ymax - c->border - c->height)) / ymax;
#else
		c->x = c->y = c->border;
#endif
		reconfigure = 1;
	}

	LOG_DEBUG("\twindow started as %dx%d +%d+%d\n", c->width, c->height, c->x, c->y);
	if (attr.map_state == IsViewable) {
		c->ignore_unmap++;
	} else {
		/* Initialise position if needed */
		if (reconfigure) {
			send_config(c);
		}
		if ((wm = XGetWMHints(dpy, c->window))) {
			if (wm->flags & StateHint)
				set_wm_state(c, wm->initial_state);
			XFree(wm);
		}
	}
	gravitate(c);
}

static void reparent(Client *c) {
	XSetWindowAttributes p_attr;

	p_attr.override_redirect = True;
	p_attr.background_pixel = c->screen->bg.pixel;
	p_attr.event_mask = ChildMask | ButtonPressMask | ExposureMask | EnterWindowMask;
	c->parent = XCreateWindow(dpy, c->screen->root, c->x-c->border, c->y-c->border,
		c->width+(c->border*2), c->height + (c->border*2), 0,
		DefaultDepth(dpy, c->screen->screen), CopyFromParent,
		DefaultVisual(dpy, c->screen->screen),
		CWOverrideRedirect | CWBackPixel | CWEventMask, &p_attr);

	XAddToSaveSet(dpy, c->window);
	XSetWindowBorderWidth(dpy, c->window, 0);
	XReparentWindow(dpy, c->window, c->parent, c->border, c->border);
}

/* Get WM_NORMAL_HINTS property */
CARD32 get_wm_normal_hints(Client *c) {
	XSizeHints *size;
	CARD32 flags;
	long dummy;
	size = XAllocSizeHints();
	LOG_XDEBUG("XGetWMNormalHints()\n");
	XGetWMNormalHints(dpy, c->window, size, &dummy);
	debug_wm_normal_hints(size);
	flags = size->flags;
	if (flags & PMinSize) {
		c->min_width = size->min_width;
		c->min_height = size->min_height;
	} else {
		c->min_width = c->min_height = 0;
	}
	if (flags & PMaxSize) {
		c->max_width = size->max_width;
		c->max_height = size->max_height;
	} else {
		c->max_width = c->max_height = 0;
	}
	if (flags & PBaseSize) {
		c->base_width = size->base_width;
		c->base_height = size->base_height;
	} else {
		c->base_width = c->min_width;
		c->base_height = c->min_height;
	}
	c->width_inc = c->height_inc = 1;
	if (flags & PResizeInc) {
		c->width_inc = size->width_inc ? size->width_inc : 1;
		c->height_inc = size->height_inc ? size->height_inc : 1;
	}
	if (!(flags & PMinSize)) {
		c->min_width = c->base_width + c->width_inc;
		c->min_height = c->base_height + c->height_inc;
	}
	if (flags & PWinGravity) {
		c->win_gravity = size->win_gravity;
	} else {
		c->win_gravity = NorthWestGravity;
	}
	XFree(size);
	return flags;
}

#ifdef MWM_HINTS
static PropMwmHints *get_mwm_hints(Window w) {
	Atom actual_type;
	int actual_format;
	unsigned long nitems, bytes_after;
	PropMwmHints *data;
	if (XGetWindowProperty(dpy, w, mwm_hints, 0L,
				(long)PROP_MWM_HINTS_ELEMENTS, False,
				mwm_hints, &actual_type, &actual_format,
				&nitems, &bytes_after,
				(unsigned char **)&data)
			== Success && nitems >= PROP_MWM_HINTS_ELEMENTS) {
		return data;
	}
	return NULL;
}
#endif

#ifdef XDEBUG
static const char *map_state_string(int map_state) {
	const char *map_states[4] = {
		"IsUnmapped",
		"IsUnviewable",
		"IsViewable",
		"Unknown"
	};
	return ((unsigned int)map_state < 3)
		? map_states[map_state]
		: map_states[3];
}

static const char *gravity_string(int gravity) {
	const char *gravities[12] = {
		"ForgetGravity",
		"NorthWestGravity",
		"NorthGravity",
		"NorthEastGravity",
		"WestGravity",
		"CenterGravity",
		"EastGravity",
		"SouthWestGravity",
		"SouthGravity",
		"SouthEastGravity",
		"StaticGravity",
		"Unknown"
	};
	return ((unsigned int)gravity < 11) ? gravities[gravity] : gravities[11];
}

static void debug_wm_normal_hints(XSizeHints *size) {
	if (size->flags & 15) {
		LOG_XDEBUG("\t");
		if (size->flags & USPosition) {
			LOG_XDEBUG("USPosition ");
		}
		if (size->flags & USSize) {
			LOG_XDEBUG("USSize ");
		}
		if (size->flags & PPosition) {
			LOG_XDEBUG("PPosition ");
		}
		if (size->flags & PSize) {
			LOG_XDEBUG("PSize");
		}
		LOG_XDEBUG("\n");
	}
	if (size->flags & PMinSize) {
		LOG_XDEBUG("\tPMinSize: min_width = %d, min_height = %d\n", size->min_width, size->min_height);
	}
	if (size->flags & PMaxSize) {
		LOG_XDEBUG("\tPMaxSize: max_width = %d, max_height = %d\n", size->max_width, size->max_height);
	}
	if (size->flags & PResizeInc) {
		LOG_XDEBUG("\tPResizeInc: width_inc = %d, height_inc = %d\n",
				size->width_inc, size->height_inc);
	}
	if (size->flags & PAspect) {
		LOG_XDEBUG("\tPAspect: min_aspect = %d/%d, max_aspect = %d/%d\n",
				size->min_aspect.x, size->min_aspect.y,
				size->max_aspect.x, size->max_aspect.y);
	}
	if (size->flags & PBaseSize) {
		LOG_XDEBUG("\tPBaseSize: base_width = %d, base_height = %d\n",
				size->base_width, size->base_height);
	}
	if (size->flags & PWinGravity) {
		LOG_XDEBUG("\tPWinGravity: %s\n", gravity_string(size->win_gravity));
	}
}
#endif
@


1.5
log
@mirbsd.org, 66h.42h.de, bsdadvocacy.org, and whatnot
we changed that too often, try to clean up the mess
mostly outside the www/ module which is dead anyway.
@
text
@d12 2
@


1.4
log
@fix the off-by-one bug originally noticed by Jonathan "ciruZ" Schleifer
XXX I'm not sure if this fix is correct but an xloadimage -geom 2x2+1+1
XXX does what I want, so I assume it is.
@
text
@d2 1
a2 1
 * Copyright (c) 2004-2005 Thorsten Glaser <tg@@MirBSD.org>
@


1.3
log
@Finish the update of evilwm, taking care of local changes, strlcpy
cleanup, fixes for resize/move etc.
@
text
@d2 1
d93 2
@


1.2
log
@merge over X11/extras

XXX rewrite evilwm man page in -mdoc
@
text
@a0 22
/* $MirOS: src/share/misc/licence.template,v 1.2 2005/03/03 19:43:30 tg Rel $ */

/*-
 * Copyright (c) 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
 */

d2 1
a2 1
 * Copyright (C) 1999-2002 Ciaran Anscomb <evilwm@@6809.org.uk>
a4 1
#include "evilwm.h"
d8 2
a9 3
#ifdef SHAPE
#include <X11/extensions/shape.h>
#endif
d14 9
a25 3
	XWindowAttributes attr;
	long dummy;
	XWMHints *hints;
a26 1
	/*
a27 1
	*/
d34 7
a40 12
	c = (Client *)malloc(sizeof(Client));
	/* Don't crash the window manager, just fail the operation. */
	if (!c) {
#ifdef STDIO
		fprintf(stderr, "out of memory in new_client; limping onward\n");
#endif
		return;
	}
	/* We do this first of all as a test to see if the window actually
	 * still exists by the time we've got to create a client structure
	 * for it (sometimes they vanish too quickly or something, and lots
	 * of pain ensues). */
d47 1
a47 4
#ifdef DEBUG
		fprintf(stderr, "make_new_client() : XError occurred for initialising window - aborting...\n");
#endif
		free(c);
d53 8
a63 12
	/*
	class = XAllocClassHint();
	if (class) {
		XGetClassHint(dpy, w, class);
		fprintf(stderr, "res_name = %s, res_class = %s\n", class->res_name, class->res_class);
		XFree(class->res_name);
		XFree(class->res_class);
		XFree(class);
	}
	*/

	/* initialise(c, w); */
a67 12
	c->size = XAllocSizeHints();
#ifdef XDEBUG
	fprintf(stderr, "XGetWMNormalHints(); ");
#endif
	XGetWMNormalHints(dpy, c->window, c->size, &dummy);

	XGetWindowAttributes(dpy, c->window, &attr);

	c->x = attr.x;
	c->y = attr.y;
	c->width = attr.width;
	c->height = attr.height;
a68 2
	c->oldw = c->oldh = 0;

d80 1
a80 1
	/* If we don't have MWM_HINTS (ie, lesstif) for a client to tell us
d91 2
a92 3
#ifdef COLOURMAP
	c->cmap = attr.colormap;
#endif
d96 1
d103 1
a103 1
		fprintf(stderr, "make_new_client() : new window %dx%d+%d+%d, wincount=%d\n", c->width, c->height, c->x, c->y, i);
d107 5
a111 2
	/* c->size = XAllocSizeHints();
	XGetWMNormalHints(dpy, c->window, c->size, &dummy); */
d113 1
a113 10
	if (attr.map_state == IsViewable) {
		c->ignore_unmap++;
	} else {
		init_position(c);
		if ((hints = XGetWMHints(dpy, w))) {
			if (hints->flags & StateHint)
				set_wm_state(c, hints->initial_state);
			XFree(hints);
		}
	}
d115 3
a117 10
	/* Jon Perkin reported a crash wish an app called 'sunpci' which we
	 * traced to getting divide-by-zeros because it sets PResizeInc
	 * but then has increments as 0.  So we check for 0s here and set them
	 * to sensible defaults. */
	/* moved sanity checking to after receiving all hints from the
	 * server and application, because they override it in some cases */
	if (c->size->width_inc == 0)
		c->size->width_inc = 1;
	if (c->size->height_inc == 0)
		c->size->height_inc = 1;
d119 2
a120 1
	/* client is initialised */
d122 6
a127 2
	gravitate(c);
	reparent(c);
d129 32
a160 11
#ifdef DEBUG
	if (wm_state(c) == IconicState) {
		fprintf(stderr, "make_new_client() : client thinks it's iconised\n");
	} else {
		if (wm_state(c) == NormalState) {
			fprintf(stderr, "make_new_client() : client is in NormalState - good\n");
		} else {
			if (wm_state(c) == WithdrawnState) {
				fprintf(stderr, "make_new_client() : silly client!  it's in WithdrawnState\n");
			} else {
				fprintf(stderr, "make_new_client() : don't know what state client is in\n");
d162 1
d164 3
a167 4
#endif
	XMapWindow(dpy, c->window);
	XMapRaised(dpy, c->parent);
	set_wm_state(c, NormalState);
d169 1
a169 2
	XSync(dpy, False);
	XUngrabServer(dpy);
d176 19
a194 3
void init_position(Client *c) {
#ifdef MOUSE
	int x, y;
a195 2
	int xmax = DisplayWidth(dpy, c->screen->screen);
	int ymax = DisplayHeight(dpy, c->screen->screen);
d197 15
a211 17
	/*
	if (c->size->flags & (/+PSize | +/USSize)) {
		c->width = c->size->width;
		c->height = c->size->height;
	}
	*/

	if (c->width < MINSIZE) c->width = MINSIZE;
	if (c->height < MINSIZE) c->height = MINSIZE;
	if (c->width > xmax) c->width = xmax;
	if (c->height > ymax) c->height = ymax;

	if (c->size->flags & (/*PPosition | */USPosition)) {
		c->x = c->size->x;
		c->y = c->size->y;
		if (c->x < 0 || c->y < 0 || c->x > xmax || c->y > ymax)
			c->x = c->y = c->border;
d214 3
d221 1
a221 1
		c->x = c->y = 0;
d223 16
d240 1
a240 5
	/* reposition if maximised horizontally or vertically */
	if (c->x == 0 && c->width == xmax)
		c->x = -c->border;
	if (c->y == 0 && c->height == ymax)
		c->y = -c->border;
d243 1
a243 1
void reparent(Client *c) {
a245 6
#ifdef COLOURMAP
	XSelectInput(dpy, c->window, ColormapChangeMask | EnterWindowMask | PropertyChangeMask);
#else
	XSelectInput(dpy, c->window, EnterWindowMask | PropertyChangeMask);
#endif

a253 6
#ifdef SHAPE
	if (have_shape) {
	    XShapeSelectInput(dpy, c->window, ShapeNotifyMask);
	    set_shape(c);
	}
#endif
d258 1
d260 45
a304 1
	send_config(c);
a306 2
/* Taken from aewm-1.2.0 */

d309 85
a393 10
	Atom real_type; int real_format;
	unsigned long items_read, bytes_left;
	unsigned char *data;
	if (XGetWindowProperty(dpy, w, mwm_hints, 0L, 20L, False,
		mwm_hints, &real_type, &real_format, &items_read, &bytes_left,
		&data) == Success
		&& items_read >= PROP_MOTIF_WM_HINTS_ELEMENTS) {
		return (PropMwmHints *)data;
	} else {
		return NULL;
@


1.1
log
@Initial revision
@
text
@d1 22
a99 4
	/* Jon Perkin reported a crash wish an app called 'sunpci' which we
	 * traced to getting divide-by-zeros because it sets PResizeInc
	 * but then has increments as 0.  So we check for 0s here and set them
	 * to sensible defaults. */
a100 4
	if (c->size->width_inc == 0)
		c->size->width_inc = 1;
	if (c->size->height_inc == 0)
		c->size->height_inc = 1;
d167 11
@


1.1.201.1
log
@evilwm 0.99.17
@
text
@@


1.1.201.2
log
@There is a new evilwm out there!
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
d5 1
d9 3
a11 2
#include "evilwm.h"
#include "log.h"
a15 9
#ifdef XDEBUG
static const char *map_state_string(int map_state);
static const char *gravity_string(int gravity);
static void debug_wm_normal_hints(XSizeHints *size);
#else
# define debug_wm_normal_hints(s)
#endif
static void init_geometry(Client *c);
static void reparent(Client *c);
d19 3
d23 1
d25 1
d32 12
a43 7
	/* First a bit of interaction with the error handler due to X's
	 * tendancy to batch event notifications.  We set a global variable to
	 * the id of the window we're initialising then do simple X call on
	 * that window.  If an error is raised by this (and nothing else should
	 * do so as we've grabbed the server), the error handler resets the
	 * variable indicating the window has already disappeared, so we stop
	 * trying to manage it. */
d50 4
a53 1
		LOG_DEBUG("make_new_client() : XError occurred for initialising window - aborting...\n");
d59 2
a60 1
	LOG_DEBUG("make_new_client(): %s\n", name ? name : "Untitled");
d62 8
a69 5
	c = malloc(sizeof(Client));
	/* Don't crash the window manager, just fail the operation. */
	if (!c) {
		LOG_ERROR("out of memory in new_client; limping onward\n");
		return;
d71 1
a71 2
	c->next = head_client;
	head_client = c;
d73 1
d78 20
d99 2
d112 1
a112 1
	/* If we don't have MWM_HINTS (i.e., lesstif) for a client to tell us
d123 3
a125 2
	init_geometry(c);

a128 1

d135 1
a135 1
		LOG_DEBUG("make_new_client() : new window %dx%d+%d+%d, wincount=%d\n", c->width, c->height, c->x, c->y, i);
d139 15
a153 5
#ifdef COLOURMAP
	XSelectInput(dpy, c->window, ColormapChangeMask | EnterWindowMask | PropertyChangeMask);
#else
	XSelectInput(dpy, c->window, EnterWindowMask | PropertyChangeMask);
#endif
d155 1
d158 15
a178 49

#ifdef SHAPE
	if (have_shape) {
	    XShapeSelectInput(dpy, c->window, ShapeNotifyMask);
	    set_shape(c);
	}
#endif

	/* Read instance/class information for client and check against list
	 * built with -app options */
	class = XAllocClassHint();
	if (class) {
		Application *a = head_app;
		XGetClassHint(dpy, w, class);
		while (a) {
			if ((!a->res_name || (class->res_name && !strcmp(class->res_name, a->res_name)))
					&& (!a->res_class || (class->res_class && !strcmp(class->res_class, a->res_class)))) {
				if (a->geometry_mask & WidthValue)
					c->width = a->width * c->width_inc;
				if (a->geometry_mask & HeightValue)
					c->height = a->height * c->height_inc;
				if (a->geometry_mask & XValue) {
					if (a->geometry_mask & XNegative)
						c->x = a->x + DisplayWidth(dpy, s->screen)-c->width-c->border;
					else
						c->x = a->x + c->border;
				}
				if (a->geometry_mask & YValue) {
					if (a->geometry_mask & YNegative)
						c->y = a->y + DisplayHeight(dpy, s->screen)-c->height-c->border;
					else
						c->y = a->y + c->border;
				}
				moveresize(c);
#ifdef VWM
				if (a->vdesk != -1) c->vdesk = a->vdesk;
				if (vdesk != c->vdesk && c->vdesk != STICKY) {
					hide(c);
				}
#endif
			}
			a = a->next;
		}
		XFree(class->res_name);
		XFree(class->res_class);
		XFree(class);
	}

	//send_config(c);
d185 3
a187 19
/* Calls XGetWindowAttributes, XGetWMHints and XGetWMNormalHints to determine
 * window's initial geometry.
 *
 * XGetWindowAttributes 
 */
static void init_geometry(Client *c) {
	CARD32 size_flags;
	XWindowAttributes attr;
	XWMHints *wm;
	int reconfigure = 0;

	/* Get current window attributes */
	LOG_XDEBUG("XGetWindowAttributes()\n");
	XGetWindowAttributes(dpy, c->window, &attr);
	LOG_XDEBUG("\t(%s) %dx%d+%d+%d, bw = %d\n", map_state_string(attr.map_state), attr.width, attr.height, attr.x, attr.y, attr.border_width);
	c->old_border = attr.border_width;
	c->oldw = c->oldh = 0;
#ifdef COLOURMAP
	c->cmap = attr.colormap;
d189 2
d192 17
a208 15
	size_flags = get_wm_normal_hints(c);

	if ((attr.width >= c->min_width) && (attr.height >= c->min_height)) {
	//if (attr.map_state == IsViewable || (size_flags & (PSize | USSize))) {
		c->width = attr.width;
		c->height = attr.height;
	} else {
		c->width = c->min_width;
		c->height = c->min_height;
		reconfigure = 1;
	}
	if ((attr.map_state == IsViewable)
			|| (size_flags & (/*PPosition |*/ USPosition))) {
		c->x = attr.x;
		c->y = attr.y;
a210 3
		int xmax = DisplayWidth(dpy, c->screen->screen);
		int ymax = DisplayHeight(dpy, c->screen->screen);
		int x, y;
d215 1
a215 1
		c->x = c->y = c->border;
a216 1
		reconfigure = 1;
d218 5
a222 16

	LOG_DEBUG("\twindow started as %dx%d +%d+%d\n", c->width, c->height, c->x, c->y);
	if (attr.map_state == IsViewable) {
		c->ignore_unmap++;
	} else {
		/* Initialise position if needed */
		if (reconfigure) {
			send_config(c);
		}
		if ((wm = XGetWMHints(dpy, c->window))) {
			if (wm->flags & StateHint)
				set_wm_state(c, wm->initial_state);
			XFree(wm);
		}
	}
	gravitate(c);
d225 1
a225 1
static void reparent(Client *c) {
d228 6
d242 6
d252 2
d256 1
a256 46
/* Get WM_NORMAL_HINTS property */
CARD32 get_wm_normal_hints(Client *c) {
	XSizeHints *size;
	CARD32 flags;
	long dummy;
	size = XAllocSizeHints();
	LOG_XDEBUG("XGetWMNormalHints()\n");
	XGetWMNormalHints(dpy, c->window, size, &dummy);
	debug_wm_normal_hints(size);
	flags = size->flags;
	if (flags & PMinSize) {
		c->min_width = size->min_width;
		c->min_height = size->min_height;
	} else {
		c->min_width = c->min_height = 0;
	}
	if (flags & PMaxSize) {
		c->max_width = size->max_width;
		c->max_height = size->max_height;
	} else {
		c->max_width = c->max_height = 0;
	}
	if (flags & PBaseSize) {
		c->base_width = size->base_width;
		c->base_height = size->base_height;
	} else {
		c->base_width = c->min_width;
		c->base_height = c->min_height;
	}
	c->width_inc = c->height_inc = 1;
	if (flags & PResizeInc) {
		c->width_inc = size->width_inc ? size->width_inc : 1;
		c->height_inc = size->height_inc ? size->height_inc : 1;
	}
	if (!(flags & PMinSize)) {
		c->min_width = c->base_width + c->width_inc;
		c->min_height = c->base_height + c->height_inc;
	}
	if (flags & PWinGravity) {
		c->win_gravity = size->win_gravity;
	} else {
		c->win_gravity = NorthWestGravity;
	}
	XFree(size);
	return flags;
}
d260 10
a269 85
	Atom actual_type;
	int actual_format;
	unsigned long nitems, bytes_after;
	PropMwmHints *data;
	if (XGetWindowProperty(dpy, w, mwm_hints, 0L,
				(long)PROP_MWM_HINTS_ELEMENTS, False,
				mwm_hints, &actual_type, &actual_format,
				&nitems, &bytes_after,
				(unsigned char **)&data)
			== Success && nitems >= PROP_MWM_HINTS_ELEMENTS) {
		return data;
	}
	return NULL;
}
#endif

#ifdef XDEBUG
static const char *map_state_string(int map_state) {
	const char *map_states[4] = {
		"IsUnmapped",
		"IsUnviewable",
		"IsViewable",
		"Unknown"
	};
	return ((unsigned int)map_state < 3)
		? map_states[map_state]
		: map_states[3];
}

static const char *gravity_string(int gravity) {
	const char *gravities[12] = {
		"ForgetGravity",
		"NorthWestGravity",
		"NorthGravity",
		"NorthEastGravity",
		"WestGravity",
		"CenterGravity",
		"EastGravity",
		"SouthWestGravity",
		"SouthGravity",
		"SouthEastGravity",
		"StaticGravity",
		"Unknown"
	};
	return ((unsigned int)gravity < 11) ? gravities[gravity] : gravities[11];
}

static void debug_wm_normal_hints(XSizeHints *size) {
	if (size->flags & 15) {
		LOG_XDEBUG("\t");
		if (size->flags & USPosition) {
			LOG_XDEBUG("USPosition ");
		}
		if (size->flags & USSize) {
			LOG_XDEBUG("USSize ");
		}
		if (size->flags & PPosition) {
			LOG_XDEBUG("PPosition ");
		}
		if (size->flags & PSize) {
			LOG_XDEBUG("PSize");
		}
		LOG_XDEBUG("\n");
	}
	if (size->flags & PMinSize) {
		LOG_XDEBUG("\tPMinSize: min_width = %d, min_height = %d\n", size->min_width, size->min_height);
	}
	if (size->flags & PMaxSize) {
		LOG_XDEBUG("\tPMaxSize: max_width = %d, max_height = %d\n", size->max_width, size->max_height);
	}
	if (size->flags & PResizeInc) {
		LOG_XDEBUG("\tPResizeInc: width_inc = %d, height_inc = %d\n",
				size->width_inc, size->height_inc);
	}
	if (size->flags & PAspect) {
		LOG_XDEBUG("\tPAspect: min_aspect = %d/%d, max_aspect = %d/%d\n",
				size->min_aspect.x, size->min_aspect.y,
				size->max_aspect.x, size->max_aspect.y);
	}
	if (size->flags & PBaseSize) {
		LOG_XDEBUG("\tPBaseSize: base_width = %d, base_height = %d\n",
				size->base_width, size->base_height);
	}
	if (size->flags & PWinGravity) {
		LOG_XDEBUG("\tPWinGravity: %s\n", gravity_string(size->win_gravity));
@

