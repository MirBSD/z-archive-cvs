head	1.5;
access;
symbols
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	evilwm-0_99_18:1.1.201.2
	evilwm-0_99_17:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.5
date	2013.10.31.20.05.36;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005272B7081B0E5655;

1.4
date	2006.08.14.19.05.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044E0C9850E7540C9;

1.3
date	2006.08.14.18.57.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044E0C7C657C8A08A;

1.2
date	2005.07.07.18.27.14;	author tg;	state Exp;
branches;
next	1.1;
commitid	27f942cd73fd1fbe;

1.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches;
next	1.1.201.2;

1.1.201.2
date	2005.07.07.18.07.02;	author tg;	state Exp;
branches;
next	;
commitid	5f4742cd6f554c49;


desc
@@


1.5
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* evilwm - Minimalist Window Manager for X
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
 * see README for license and other details. */

#include <X11/Xproto.h>
#include <stdlib.h>
#include <stdarg.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include "evilwm.h"
#include "log.h"

__RCSID("$MirOS: X11/extras/evilwm/misc.c,v 1.4 2006/08/14 19:05:19 tg Exp $");

/* Now do this by fork()ing twice so we don't have to worry about SIGCHLDs */
void spawn(const char *const cmd[]) {
	pid_t pid;

	if (current_screen && current_screen->display)
		putenv(current_screen->display);
	if (!(pid = fork())) {
		setsid();
		switch (fork()) {
			case 0: execvp(cmd[0], (char *const *)cmd+1);
			default: _exit(0);
		}
	}
	if (pid > 0)
		wait(NULL);
}

void handle_signal(int signo __attribute__((__unused__))) {
	int i;
	/* SIGCHLD check no longer necessary */
	/* Quit Nicely */
	quitting = 1;
	while(head_client) remove_client(head_client);
	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
	if (font) XFreeFont(dpy, font);
	for (i = 0; i < num_screens; i++) {
		XFreeGC(dpy, screens[i].invert_gc);
		XInstallColormap(dpy, DefaultColormap(dpy, screens[i].screen));
	}
	free(screens);
	XCloseDisplay(dpy);
	exit(0);
}

int handle_xerror(Display *dsply __attribute__((__unused__)), XErrorEvent *e) {
	Client *c = find_client(e->resourceid);

	/* If this error actually occurred while setting up the new
	 * window, best let make_new_client() know not to bother */
	if (initialising != None && e->resourceid == initialising) {
		LOG_DEBUG("\t **SAVED?** handle_xerror() caught error %d while initialising\n", e->error_code);
		initialising = None;
		return 0;
	}
	LOG_DEBUG("**ERK** handle_xerror() caught an XErrorEvent: error_code=%d request_code=%d minor_code=%d\n",
			e->error_code, e->request_code, e->minor_code);
	/* if (e->error_code == BadAccess && e->resourceid == root) { */
	if (e->error_code == BadAccess && e->request_code == X_ChangeWindowAttributes) {
		LOG_ERROR("root window unavailable (maybe another wm is running?)\n");
		exit(1);
	}

	/* Kludge around IE misbehaviour */
	if (e->error_code == 0x8 && e->request_code == 0x0c && e->minor_code == 0x00) {
		LOG_DEBUG("\thandle_xerror() : IE kludge - ignoring XError\n");
		return 0;
	}

	if (c) {
		LOG_DEBUG("\thandle_xerror() : calling remove_client()\n");
		remove_client(c);
	}
	return 0;
}

int ignore_xerror(Display *dsply __attribute__((__unused__)), XErrorEvent *e __attribute__((__unused__))) {
	LOG_DEBUG("ignore_xerror() caught an XErrorEvent: %d\n", e->error_code);
	return 0;
}

#ifdef DEBUG
void dump_clients() {
	Client *c;
	XWindowAttributes attr;

	for (c = head_client; c; c = c->next) {
		XGetWindowAttributes(dpy, c->window, &attr);
		LOG_DEBUG("MISC: (%d, %d) @@ %d,%d\n", attr.map_state,
			c->ignore_unmap, c->x, c->y);
	}
}
#endif /* DEBUG */
@


1.4
log
@RCS IDs
@
text
@d2 2
d16 1
a16 1
__RCSID("$MirOS$");
d35 1
a35 1
void handle_signal(int signo __attribute__((unused))) {
d52 1
a52 1
int handle_xerror(Display *dsply __attribute__((unused)), XErrorEvent *e) {
d83 1
a83 1
int ignore_xerror(Display *dsply __attribute__((unused)), XErrorEvent *e __attribute__((unused))) {
@


1.3
log
@sync licence, make __CRAZY clean
@
text
@d14 2
@


1.2
log
@Finish the update of evilwm, taking care of local changes, strlcpy
cleanup, fixes for resize/move etc.
@
text
@d31 1
a31 2
void handle_signal(int signo) {
	(void)signo;  /* unused */
d48 1
a48 2
int handle_xerror(Display *dsply, XErrorEvent *e) {
	(void)dsply;  /* unused */
d79 1
a79 3
int ignore_xerror(Display *dsply, XErrorEvent *e) {
	(void)dsply;  /* unused */
	(void)e;  /* unused unless debugging */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002 Ciaran Anscomb <evilwm@@6809.org.uk>
a4 1
#include "evilwm.h"
d11 2
a12 1
#include <stdio.h>
d23 1
a23 2
			/* explicitly hack around broken SUS execvp prototype */
			case 0: execvp(cmd[0], (char *const *)&cmd[1]);
a30 21
#ifdef VDESK_BOTH
void spawn_vdesk(int todesk, Client *c) {
	char *vdesk_cmd[5];
	char vdesk_num[2];
	char vdesk_window[11];

	vdesk_cmd[3] = vdesk_cmd[4] = NULL;
	vdesk_cmd[0] = "vdesk";
	vdesk_cmd[1] = "vdesk";
	vdesk_num[0] = todesk + '0';
	vdesk_num[1] = 0;
	vdesk_cmd[2] = vdesk_num;
	if (c) {
		snprintf(vdesk_window, sizeof(vdesk_window), "%ld", c->window);
		vdesk_cmd[3] = vdesk_window;
	}
	fprintf(stderr, "%s %s %s %s\n", vdesk_cmd[0], vdesk_cmd[1], vdesk_cmd[2], vdesk_cmd[3]);
	spawn(vdesk_cmd);
}
#endif

d32 1
d50 1
d56 1
a56 3
#ifdef DEBUG
		fprintf(stderr, "\t **SAVED?** handle_xerror() caught error %d while initialising\n", e->error_code);
#endif
d60 2
a61 3
#ifdef DEBUG
	fprintf(stderr, "**ERK** handle_xerror() caught an XErrorEvent: %d\n", e->error_code);
#endif
d64 1
a64 3
#ifdef STDIO
		fprintf(stderr, "root window unavailable (maybe another wm is running?)\n");
#endif
d67 1
a67 3
#ifdef XDEBUG
	fprintf(stderr, "XError %x ", e->error_code);
#endif
d70 1
a70 3
#ifdef DEBUG
		fprintf(stderr, "\thandle_xerror() : IE kludge - ignoring XError\n");
#endif
d75 1
a75 3
#ifdef DEBUG
		fprintf(stderr, "\thandle_xerror() : calling remove_client()\n");
#endif
d82 3
a84 3
#ifdef DEBUG
	fprintf(stderr, "ignore_xerror() caught an XErrorEvent: %d\n", e->error_code);
#endif
d91 1
d93 3
a95 2
	for (c = head_client; c; c = c->next)
		fprintf(stderr, "MISC: (%d, %d) @@ %d,%d\n", wm_state(c),
d97 1
@


1.1.201.1
log
@evilwm 0.99.17
@
text
@@


1.1.201.2
log
@There is a new evilwm out there!
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
d5 1
d12 1
a12 2
#include "evilwm.h"
#include "log.h"
d23 2
a24 6
			/* Expect compiler warnings because of half-broken SUS
			 * execvp prototype:  "char *const argv[]" should have
			 * been "const char *const argv[]", but the committee
			 * favored legacy code over modern code, and modern
			 * compilers bark at our extra const. (LD) */
			case 0: execvp(cmd[0], cmd+1);
d32 21
a53 1
	(void)signo;  /* unused */
a70 1
	(void)dsply;  /* unused */
d76 3
a78 1
		LOG_DEBUG("\t **SAVED?** handle_xerror() caught error %d while initialising\n", e->error_code);
d82 3
a84 2
	LOG_DEBUG("**ERK** handle_xerror() caught an XErrorEvent: error_code=%d request_code=%d minor_code=%d\n",
			e->error_code, e->request_code, e->minor_code);
d87 3
a89 1
		LOG_ERROR("root window unavailable (maybe another wm is running?)\n");
d92 3
a94 1

d97 3
a99 1
		LOG_DEBUG("\thandle_xerror() : IE kludge - ignoring XError\n");
d104 3
a106 1
		LOG_DEBUG("\thandle_xerror() : calling remove_client()\n");
d113 3
a115 3
	(void)dsply;  /* unused */
	(void)e;  /* unused unless debugging */
	LOG_DEBUG("ignore_xerror() caught an XErrorEvent: %d\n", e->error_code);
a121 1
	XWindowAttributes attr;
d123 2
a124 3
	for (c = head_client; c; c = c->next) {
		XGetWindowAttributes(dpy, c->window, &attr);
		LOG_DEBUG("MISC: (%d, %d) @@ %d,%d\n", attr.map_state,
a125 1
	}
@

