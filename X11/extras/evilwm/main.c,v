head	1.8;
access;
symbols
	MIRBSD_10_BASE:1.8
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	evilwm-0_99_18:1.1.201.2
	evilwm-0_99_17:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.8
date	2006.10.16.20.43.19;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004533EED23F5C770C;

1.7
date	2006.08.14.19.05.19;	author tg;	state Exp;
branches;
next	1.6;
commitid	10044E0C9850E7540C9;

1.6
date	2006.08.14.18.57.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044E0C7C657C8A08A;

1.5
date	2005.11.22.22.35.35;	author tg;	state Exp;
branches;
next	1.4;
commitid	778a43839d3b41f6;

1.4
date	2005.07.14.18.42.17;	author tg;	state Exp;
branches;
next	1.3;
commitid	413742d6b1f702fb;

1.3
date	2005.07.07.18.27.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	27f942cd73fd1fbe;

1.2
date	2005.03.19.13.30.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches;
next	1.1.201.2;

1.1.201.2
date	2005.07.07.18.07.02;	author tg;	state Exp;
branches;
next	;
commitid	5f4742cd6f554c49;


desc
@@


1.8
log
@add a function to evilwm to spawn a "normal" xterm,
"C" even if evilwm was started in a utf-8 locale, and
not inheriting parent environment etc., running /bin/sh
@
text
@/* evilwm - Minimalist Window Manager for X
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
 * see README for license and other details. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <X11/cursorfont.h>
#include "evilwm.h"
#include "log.h"

__RCSID("$MirOS: X11/extras/evilwm/main.c,v 1.7 2006/08/14 19:05:19 tg Exp $");
__RCSID(EVILWM_H);
__RCSID(KEYMAP_H);
__RCSID(LOG_H);

Display		*dpy;
int 		num_screens;
ScreenInfo	*screens;
ScreenInfo	*current_screen;
Client		*current = NULL;
volatile Window	initialising = None;
XFontStruct	*font;
Client		*head_client = NULL;
Application	*head_app = NULL;
Atom		xa_wm_state;
Atom		xa_wm_change_state;
Atom		xa_wm_protos;
Atom		xa_wm_delete;
Atom		xa_wm_cmapwins;
Cursor		move_curs;
Cursor		resize_curs;
const char	*opt_display = "";
const char	*opt_font = DEF_FONT;
const char	*opt_fg = DEF_FG;
const char	*opt_bg = DEF_BG;
const char	*opt_term[3] = { DEF_TERM, DEF_TERM, NULL };
#define sane_term_DISPLAY	3
#define sane_term_XAUTHORITY	5	/* below: EDITOR=ed (placeholder) */
const char	*sane_term[23] = { "/usr/bin/env", "env", "-i", "DISPLAY=:0",
		    "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin",
		    "EDITOR=ed", "LC_ALL=C", "/usr/X11R6/bin/xterm", "-fn",
		    "-misc-fixed-medium-r-normal--13-120-75-75-c-80-iso8859-1",
		    "-fg", "#000000", "-bg", "#EEEECC", "-class", "saneXTerm",
		    "-ls", "-mesg", "-tn", "xterm-r6", "-e", "/bin/sh", NULL };
int		opt_bw = DEF_BW;
#ifdef VWM
const char	*opt_fc = DEF_FC;
int		vdesk = KEY_TO_VDESK(XK_1);
#endif
#ifdef SNAP
int		opt_snap = 0;
#endif
#ifdef SHAPE
int		have_shape, shape_event;
#endif
int		quitting = 0;
#ifdef MWM_HINTS
Atom		mwm_hints;
#endif
unsigned int numlockmask = 0;
static unsigned int grabmask1 = ControlMask|Mod1Mask;
/* This one is used for per-client mousebutton grabs, so global: */
unsigned int grabmask2 = Mod1Mask;

static void setup_display(void);
static void *xmalloc(size_t size);
static unsigned int parse_modifiers(char *s);

int main(int argc, char *argv[]) {
	struct sigaction act;
	int i;
	char *envstr;

	if ((envstr = getenv("DISPLAY")) != NULL)
		if (asprintf(&envstr, "DISPLAY=%s", envstr) > 0)
			sane_term[sane_term_DISPLAY] = envstr;
	if ((envstr = getenv("XAUTHORITY")) != NULL)
		if (asprintf(&envstr, "XAUTHORITY=%s", envstr) > 0)
			sane_term[sane_term_XAUTHORITY] = envstr;

	for (i = 1; i < argc; i++) {
		if (!strcmp(argv[i], "-fn") && i+1<argc)
			opt_font = argv[++i];
		else if (!strcmp(argv[i], "-display") && i+1<argc) {
			opt_display = argv[++i];
		}
		else if (!strcmp(argv[i], "-fg") && i+1<argc)
			opt_fg = argv[++i];
		else if (!strcmp(argv[i], "-bg") && i+1<argc)
			opt_bg = argv[++i];
#ifdef VWM
		else if (!strcmp(argv[i], "-fc") && i+1<argc)
			opt_fc = argv[++i];
#endif
		else if (!strcmp(argv[i], "-bw") && i+1<argc)
			opt_bw = atoi(argv[++i]);
		else if (!strcmp(argv[i], "-term") && i+1<argc) {
			opt_term[0] = argv[++i];
			opt_term[1] = opt_term[0];
#ifdef SNAP
		} else if (!strcmp(argv[i], "-snap") && i+1<argc) {
			opt_snap = atoi(argv[++i]);
#endif
		} else if (!strcmp(argv[i], "-app") && i+1<argc) {
			Application *new = xmalloc(sizeof(Application));
			char *tmp;
			i++;
			new->res_name = new->res_class = NULL;
			new->geometry_mask = 0;
#ifdef VWM
			new->vdesk = -1;
#endif
			if ((tmp = strchr(argv[i], '/'))) {
				*(tmp++) = 0;
			}
			if (strlen(argv[i]) > 0) {
				int len = strlen(argv[i]) + 1;

				new->res_name = xmalloc(len);
				strlcpy(new->res_name, argv[i], len);
			}
			if (tmp && strlen(tmp) > 0) {
				int len = strlen(tmp) + 1;

				new->res_class = xmalloc(len);
				strlcpy(new->res_class, tmp, len);
			}
			new->next = head_app;
			head_app = new;
		} else if (!strcmp(argv[i], "-g") && i+1<argc) {
			i++;
			if (!head_app)
				continue;
			head_app->geometry_mask = XParseGeometry(argv[i],
					&head_app->x, &head_app->y,
					&head_app->width, &head_app->height);
#ifdef VWM
		} else if (!strcmp(argv[i], "-v") && i+1<argc) {
			i++;
			if (head_app)
				head_app->vdesk = atoi(argv[i]);
#endif
		} else if (!strcmp(argv[i], "-mask1") && i+1<argc) {
			i++;
			grabmask1 = parse_modifiers(argv[i]);
		} else if (!strcmp(argv[i], "-mask2") && i+1<argc) {
			i++;
			grabmask2 = parse_modifiers(argv[i]);
#ifdef STDIO
		} else if (!strcmp(argv[i], "-V")) {
			LOG_INFO("evilwm version " VERSION "-MirOS\n");
			exit(0);
#endif
		} else {
			LOG_INFO("usage: evilwm [-display display] [-term termprog] [-fg foreground]\n");
			LOG_INFO("\t[-bg background] [-bw borderwidth] [-snap num] [-V]\n");
			exit(2);
		}
	}

	act.sa_handler = handle_signal;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	sigaction(SIGTERM, &act, NULL);
	sigaction(SIGINT, &act, NULL);
	sigaction(SIGHUP, &act, NULL);

	setup_display();

	event_main_loop();

	return 1;
}

static void *xmalloc(size_t size) {
	void *ptr = malloc(size);
	if (!ptr) {
		/* C99 defines the 'z' printf modifier for variables of
		 * type size_t.  Fall back to casting to unsigned long. */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
		LOG_ERROR("out of memory, looking for %zu bytes\n", size);
#else
		LOG_ERROR("out of memory, looking for %lu bytes\n",
				(unsigned long)size);
#endif
		exit(1);
	}
	return ptr;
}

static void setup_display(void) {
	XGCValues gv;
	XSetWindowAttributes attr;
	XColor dummy;
	XModifierKeymap *modmap;
	KeySym *keysym;
	KeySym keys_to_grab[] = {
		KEY_NEW, KEY_KILL,
		KEY_TOPLEFT, KEY_TOPRIGHT, KEY_BOTTOMLEFT, KEY_BOTTOMRIGHT,
		KEY_LEFT, KEY_RIGHT, KEY_DOWN, KEY_UP,
		KEY_SLEFT, KEY_SRIGHT, KEY_SDOWN, KEY_SUP,
		KEY_LOWER, KEY_ALTLOWER, KEY_INFO, KEY_MAXVERT, KEY_MAX,
#ifdef VWM
		KEY_FIX, KEY_PREVDESK, KEY_NEXTDESK,
		XK_1, XK_2, XK_3, XK_4, XK_5, XK_6, XK_7, XK_8,
#endif
		KEY_EXTERMF, KEY_ALTEXTERMF,
		0
	};
	/* used in scanning windows (XQueryTree) */
	unsigned int i, j, nwins;
	int k;
	Window dw1, dw2, *wins;
	XWindowAttributes winattr;

	dpy = XOpenDisplay(opt_display);
	if (!dpy) { 
		LOG_ERROR("can't open display %s\n", opt_display);
		exit(1);
	}
	XSetErrorHandler(handle_xerror);

	xa_wm_state = XInternAtom(dpy, "WM_STATE", False);
	xa_wm_change_state = XInternAtom(dpy, "WM_CHANGE_STATE", False);
	xa_wm_protos = XInternAtom(dpy, "WM_PROTOCOLS", False);
	xa_wm_delete = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
#ifdef COLOURMAP
	xa_wm_cmapwins = XInternAtom(dpy, "WM_COLORMAP_WINDOWS", False);
#endif
#ifdef MWM_HINTS
	mwm_hints = XInternAtom(dpy, _XA_MWM_HINTS, False);
#endif

	font = XLoadQueryFont(dpy, opt_font);
	if (!font) font = XLoadQueryFont(dpy, DEF_FONT);

	move_curs = XCreateFontCursor(dpy, XC_fleur);
	resize_curs = XCreateFontCursor(dpy, XC_plus);

	/* find out which modifier is NumLock - we'll use this when grabbing
	 * every combination of modifiers we can think of */
	modmap = XGetModifierMapping(dpy);
	for (i = 0; i < 8; i++) {
		for (j = 0; j < (unsigned int)modmap->max_keypermod; j++) {
			if (modmap->modifiermap[i*modmap->max_keypermod+j] == XKeysymToKeycode(dpy, XK_Num_Lock)) {
				numlockmask = (1<<i);
				LOG_DEBUG("setup_display() : XK_Num_Lock is (1<<0x%02x)\n", i);
			}
		}
	}
	XFreeModifiermap(modmap);

	/* set up GC parameters - same for each screen */
	gv.function = GXinvert;
	gv.subwindow_mode = IncludeInferiors;
	gv.line_width = 1;  /* opt_bw */
	gv.font = font->fid;

	/* set up root window attributes - same for each screen */
	attr.event_mask = ChildMask | PropertyChangeMask | EnterWindowMask
#ifdef COLOURMAP
		| ColormapChangeMask
#endif
#ifdef MOUSE
		| ButtonMask
#endif
		;

	/* SHAPE extension? */
#ifdef SHAPE
	have_shape = XShapeQueryExtension(dpy, &shape_event, &k);
#endif

	/* now set up each screen in turn */
	num_screens = ScreenCount(dpy);
	if (num_screens < 0) {
		LOG_ERROR("Can't count screens\n");
		exit(1);
	}
	screens = xmalloc(num_screens * sizeof(ScreenInfo));
	for (i = 0; i < (unsigned int)num_screens; i++) {
		char *ds, *colon, *dot;
		ds = DisplayString(dpy);
		/* set up DISPLAY environment variable to use */
		colon = strrchr(ds, ':');
		if (colon && num_screens > 1) {
			int xlen = 14 + strlen(ds);

			screens[i].display = xmalloc(xlen);
			strlcpy(screens[i].display, "DISPLAY=", xlen);
			strlcat(screens[i].display, ds, xlen);
			colon = strrchr(screens[i].display, ':');
			dot = strchr(colon, '.');
			if (!dot)
				dot = colon + strlen(colon);
			snprintf(dot, 5, ".%d", i);
		} else
			screens[i].display = NULL;

		screens[i].screen = i;
		screens[i].root = RootWindow(dpy, i);

		XAllocNamedColor(dpy, DefaultColormap(dpy, i), opt_fg, &screens[i].fg, &dummy);
		XAllocNamedColor(dpy, DefaultColormap(dpy, i), opt_bg, &screens[i].bg, &dummy);
#ifdef VWM
		XAllocNamedColor(dpy, DefaultColormap(dpy, i), opt_fc, &screens[i].fc, &dummy);
#endif

		screens[i].invert_gc = XCreateGC(dpy, screens[i].root, GCFunction | GCSubwindowMode | GCLineWidth | GCFont, &gv);

		XChangeWindowAttributes(dpy, screens[i].root, CWEventMask, &attr);
		/* Unfortunately grabbing AnyKey under Solaris seems not to work */
		/* XGrabKey(dpy, AnyKey, ControlMask|Mod1Mask, root, True, GrabModeAsync, GrabModeAsync); */
		/* So now I grab each and every one. */

		for (keysym = keys_to_grab; *keysym; keysym++) {
			grab_keysym(screens[i].root, grabmask1, *keysym);
		}
		grab_keysym(screens[i].root, grabmask2, KEY_NEXT);

		/* scan all the windows on this screen */
		LOG_XDEBUG("main:XQueryTree(); ");
		XQueryTree(dpy, screens[i].root, &dw1, &dw2, &wins, &nwins);
		LOG_XDEBUG("%d windows\n", nwins);
		for (j = 0; j < nwins; j++) {
			XGetWindowAttributes(dpy, wins[j], &winattr);
			if (!winattr.override_redirect && winattr.map_state == IsViewable)
				make_new_client(wins[j], &screens[i]);
		}
		XFree(wins);
	}
	current_screen = find_screen(DefaultScreen(dpy));
}

/* Used for overriding the default WM modifiers */
static unsigned int parse_modifiers(char *s) {
	static struct {
		const char *name;
		unsigned int mask;
	} modifiers[9] = {
		{ "shift", ShiftMask },
		{ "lock", LockMask },
		{ "control", ControlMask },
		{ "alt", Mod1Mask },
		{ "mod1", Mod1Mask },
		{ "mod2", Mod2Mask },
		{ "mod3", Mod3Mask },
		{ "mod4", Mod4Mask },
		{ "mod5", Mod5Mask }
	};
	char *tmp = strtok(s, ",+");
	unsigned int ret = 0;
	int i;
	if (!tmp)
		return 0;
	do {
		for (i = 0; i < 9; i++) {
			if (!strcmp(modifiers[i].name, tmp))
				ret |= modifiers[i].mask;
		}
		tmp = strtok(NULL, ",+");
	} while (tmp);
	return ret;
}
@


1.7
log
@RCS IDs
@
text
@d13 4
a16 4
__RCSID("$MirOS$");
__IDSTRING(rcsid_evilwm_h, EVILWM_H);
__IDSTRING(rcsid_keymap_h, KEYMAP_H);
__IDSTRING(rcsid_log_h, LOG_H);
d39 8
d74 8
d153 1
a153 1
			LOG_INFO("evilwm version " VERSION " $MirOS: X11/extras/evilwm/main.c,v 1.6 2006/08/14 18:57:57 tg Exp $\n");
d209 1
@


1.6
log
@sync licence, make __CRAZY clean
@
text
@d13 5
d137 1
a137 1
			LOG_INFO("evilwm version " VERSION " $MirOS: X11/extras/evilwm/main.c,v 1.5 2005/11/22 22:35:35 tg Exp $\n");
@


1.5
log
@remove that `=exit functionality... shoot myself into foot right now... again
@
text
@d132 1
a132 1
			LOG_INFO("evilwm version " VERSION " $MirOS: X11/extras/evilwm/main.c,v 1.4 2005/07/14 18:42:17 tg Exp $\n");
d192 1
d251 1
a251 1
	have_shape = XShapeQueryExtension(dpy, &shape_event, &i);
@


1.4
log
@fix the off-by-one bug originally noticed by Jonathan "ciruZ" Schleifer
XXX I'm not sure if this fix is correct but an xloadimage -geom 2x2+1+1
XXX does what I want, so I assume it is.
@
text
@d132 1
a132 1
			LOG_INFO("evilwm version " VERSION " $MirOS: X11/extras/evilwm/main.c,v 1.3 2005/07/07 18:27:14 tg Exp $\n");
a187 1
		KEY_EXITF, KEY_ALTEXITF,
@


1.3
log
@Finish the update of evilwm, taking care of local changes, strlcpy
cleanup, fixes for resize/move etc.
@
text
@d132 1
a132 1
			LOG_INFO("evilwm version " VERSION " $MirOS$\n");
@


1.2
log
@merge over X11/extras

XXX rewrite evilwm man page in -mdoc
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002 Ciaran Anscomb <evilwm@@6809.org.uk>
a4 1
#include "evilwm.h"
d6 1
d10 2
a11 4
#include <stdio.h>
#ifdef SHAPE
#include <X11/extensions/shape.h>
#endif
d18 1
a18 1
Window		initialising = None;
d20 2
a21 1
Client		*head_client;
d33 1
a33 1
const char	**opt_term = NULL;
d50 3
d54 1
d56 1
a56 11

static void *xmalloc(size_t size) {
	void *ptr = malloc(size);
	if (!ptr) {
#ifdef STDIO
		fprintf(stderr,"out of memory, looking for %d bytes\n",size);
#endif
		exit(1);
	}
	return ptr;
}
a60 1
	XEvent ev;
a78 1
			opt_term = (const char **)xmalloc(3 * sizeof(const char *));
d81 1
a81 1
			opt_term[2] = NULL;
d84 46
d132 1
a132 1
			printf("evilwm version " VERSION " $MirOS$\n");
d136 2
a137 4
#ifdef STDIO
			printf("usage: evilwm [-display display] [-term termprog] [-fg foreground]\n");
			printf("\t[-bg background] [-bw borderwidth] [-snap num] [-V]\n");
#endif
a140 6
	if (!opt_term) {
		opt_term = (const char **)xmalloc(3 * sizeof(const char *));
		opt_term[0] = DEF_TERM;
		opt_term[1] = opt_term[0];
		opt_term[2] = NULL;
	}
d151 4
a154 3
#ifdef SHAPE
	have_shape = XShapeQueryExtension(dpy, &shape_event, &i);
#endif
d156 10
a165 9
	/* main event loop here */
	for (;;) {
		XNextEvent(dpy, &ev);
		switch (ev.type) {
			case KeyPress:
				handle_key_event(&ev.xkey); break;
#ifdef MOUSE
			case ButtonPress:
				handle_button_event(&ev.xbutton); break;
d167 1
a167 27
			case ConfigureRequest:
				handle_configure_request(&ev.xconfigurerequest); break;
			case MapRequest:
				handle_map_request(&ev.xmaprequest); break;
#ifdef VDESK
			case ClientMessage:
				handle_client_message(&ev.xclient); break;
#endif
#ifdef COLOURMAP
			case ColormapNotify:
				handle_colormap_change(&ev.xcolormap); break;
#endif
			case EnterNotify:
				handle_enter_event(&ev.xcrossing); break;
			case LeaveNotify:
				handle_leave_event(&ev.xcrossing); break;
			case PropertyNotify:
				handle_property_change(&ev.xproperty); break;
			case UnmapNotify:
				handle_unmap_event(&ev.xunmap); break;
			default:
#ifdef SHAPE
				if (have_shape && ev.type == shape_event) {
					handle_shape_event((XShapeEvent *)&ev);
				}
#endif
		}
d169 1
a169 1
	return 1;
d172 1
a172 1
void setup_display() {
d198 1
a198 3
#ifdef STDIO
		fprintf(stderr, "can't open display %s\n", opt_display);
#endif
d224 1
a224 1
		for (j = 0; j < modmap->max_keypermod; j++) {
d227 1
a227 3
#ifdef DEBUG
				fprintf(stderr, "setup_display() : XK_Num_Lock is (1<<0x%02x)\n", i);
#endif
d240 1
a240 1
	attr.event_mask = ChildMask | PropertyChangeMask | EnterWindowMask | LeaveWindowMask
d249 5
d256 6
a261 2
	screens = (ScreenInfo *)xmalloc(num_screens * sizeof(ScreenInfo));
	for (i = 0; i < num_screens; i++) {
d265 1
a265 1
		colon = rindex(ds, ':');
d269 1
a269 1
			screens[i].display = (char *)xmalloc(xlen);
d272 2
a273 2
			colon = rindex(screens[i].display, ':');
			dot = index(colon, '.');
d297 1
a297 1
			grab_keysym(screens[i].root, ControlMask|Mod1Mask, *keysym);
d299 1
a299 1
		grab_keysym(screens[i].root, Mod1Mask, XK_Tab);
d302 1
a302 3
#ifdef XDEBUG
		fprintf(stderr, "main:XQueryTree(); ");
#endif
d304 1
a304 3
#ifdef XDEBUG
		fprintf(stderr, "%d windows\n", nwins);
#endif
d314 31
@


1.1
log
@Initial revision
@
text
@d95 1
a95 1
			printf("evilwm version " VERSION "\n");
d177 1
d183 1
d257 5
a261 3
			screens[i].display = (char *)xmalloc(14 + strlen(ds));
			strcpy(screens[i].display, "DISPLAY=");
			strcat(screens[i].display, ds);
@


1.1.201.1
log
@evilwm 0.99.17
@
text
@@


1.1.201.2
log
@There is a new evilwm out there!
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
d5 1
a6 1
#include <stdio.h>
d10 4
a13 2
#include "evilwm.h"
#include "log.h"
d20 1
a20 1
volatile Window	initialising = None;
d22 1
a22 2
Client		*head_client = NULL;
Application	*head_app = NULL;
d34 1
a34 1
const char	*opt_term[3] = { DEF_TERM, DEF_TERM, NULL };
a50 3
static unsigned int grabmask1 = ControlMask|Mod1Mask;
/* This one is used for per-client mousebutton grabs, so global: */
unsigned int grabmask2 = Mod1Mask;
a51 1
static void setup_display(void);
d53 11
a63 1
static unsigned int parse_modifiers(char *s);
d68 1
d87 1
d90 1
a90 1
#ifdef SNAP
a92 42
#endif
		} else if (!strcmp(argv[i], "-app") && i+1<argc) {
			Application *new = xmalloc(sizeof(Application));
			char *tmp;
			i++;
			new->res_name = new->res_class = NULL;
			new->geometry_mask = 0;
#ifdef VWM
			new->vdesk = -1;
#endif
			if ((tmp = strchr(argv[i], '/'))) {
				*(tmp++) = 0;
			}
			if (strlen(argv[i]) > 0) {
				new->res_name = xmalloc(strlen(argv[i])+1);
				strcpy(new->res_name, argv[i]);
			}
			if (tmp && strlen(tmp) > 0) {
				new->res_class = xmalloc(strlen(tmp)+1);
				strcpy(new->res_class, tmp);
			}
			new->next = head_app;
			head_app = new;
		} else if (!strcmp(argv[i], "-g") && i+1<argc) {
			i++;
			if (!head_app)
				continue;
			head_app->geometry_mask = XParseGeometry(argv[i],
					&head_app->x, &head_app->y,
					&head_app->width, &head_app->height);
#ifdef VWM
		} else if (!strcmp(argv[i], "-v") && i+1<argc) {
			i++;
			if (head_app)
				head_app->vdesk = atoi(argv[i]);
#endif
		} else if (!strcmp(argv[i], "-mask1") && i+1<argc) {
			i++;
			grabmask1 = parse_modifiers(argv[i]);
		} else if (!strcmp(argv[i], "-mask2") && i+1<argc) {
			i++;
			grabmask2 = parse_modifiers(argv[i]);
d95 1
a95 1
			LOG_INFO("evilwm version " VERSION "\n");
d99 4
a102 2
			LOG_INFO("usage: evilwm [-display display] [-term termprog] [-fg foreground]\n");
			LOG_INFO("\t[-bg background] [-bw borderwidth] [-snap num] [-V]\n");
d106 6
d122 3
a124 1
	event_main_loop();
d126 35
a160 13
	return 1;
}

static void *xmalloc(size_t size) {
	void *ptr = malloc(size);
	if (!ptr) {
		/* C99 defines the 'z' printf modifier for variables of
		 * type size_t.  Fall back to casting to unsigned long. */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
		LOG_ERROR("out of memory, looking for %zu bytes\n", size);
#else
		LOG_ERROR("out of memory, looking for %lu bytes\n",
				(unsigned long)size);
d162 1
a162 1
		exit(1);
d164 1
a164 1
	return ptr;
d167 1
a167 1
static void setup_display(void) {
d191 3
a193 1
		LOG_ERROR("can't open display %s\n", opt_display);
d219 1
a219 1
		for (j = 0; j < (unsigned int)modmap->max_keypermod; j++) {
d222 3
a224 1
				LOG_DEBUG("setup_display() : XK_Num_Lock is (1<<0x%02x)\n", i);
d237 1
a237 1
	attr.event_mask = ChildMask | PropertyChangeMask | EnterWindowMask
a245 5
	/* SHAPE extension? */
#ifdef SHAPE
	have_shape = XShapeQueryExtension(dpy, &shape_event, &i);
#endif

d248 2
a249 6
	if (num_screens < 0) {
		LOG_ERROR("Can't count screens\n");
		exit(1);
	}
	screens = xmalloc(num_screens * sizeof(ScreenInfo));
	for (i = 0; i < (unsigned int)num_screens; i++) {
d253 1
a253 1
		colon = strrchr(ds, ':');
d255 1
a255 1
			screens[i].display = xmalloc(14 + strlen(ds));
d258 2
a259 2
			colon = strrchr(screens[i].display, ':');
			dot = strchr(colon, '.');
d283 1
a283 1
			grab_keysym(screens[i].root, grabmask1, *keysym);
d285 1
a285 1
		grab_keysym(screens[i].root, grabmask2, KEY_NEXT);
d288 3
a290 1
		LOG_XDEBUG("main:XQueryTree(); ");
d292 3
a294 1
		LOG_XDEBUG("%d windows\n", nwins);
a303 31

/* Used for overriding the default WM modifiers */
static unsigned int parse_modifiers(char *s) {
	static struct {
		const char *name;
		unsigned int mask;
	} modifiers[9] = {
		{ "shift", ShiftMask },
		{ "lock", LockMask },
		{ "control", ControlMask },
		{ "alt", Mod1Mask },
		{ "mod1", Mod1Mask },
		{ "mod2", Mod2Mask },
		{ "mod3", Mod3Mask },
		{ "mod4", Mod4Mask },
		{ "mod5", Mod5Mask }
	};
	char *tmp = strtok(s, ",+");
	unsigned int ret = 0;
	int i;
	if (!tmp)
		return 0;
	do {
		for (i = 0; i < 9; i++) {
			if (!strcmp(modifiers[i].name, tmp))
				ret |= modifiers[i].mask;
		}
		tmp = strtok(NULL, ",+");
	} while (tmp);
	return ret;
}
@

