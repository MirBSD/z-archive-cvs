head	1.5;
access;
symbols
	MIRBSD_10_BASE:1.5
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	evilwm-0_99_18:1.1.201.2
	evilwm-0_99_17:1.1.201.1
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.5
date	2006.08.14.19.05.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044E0C9850E7540C9;

1.4
date	2005.07.14.18.26.12;	author tg;	state Exp;
branches;
next	1.3;
commitid	4e4a42d6ae541f0d;

1.3
date	2005.07.07.18.27.14;	author tg;	state Exp;
branches;
next	1.2;
commitid	27f942cd73fd1fbe;

1.2
date	2005.03.19.13.30.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches
	1.1.201.1;
next	;

1.1.201.1
date	2005.02.05.01.04.41;	author tg;	state Exp;
branches;
next	1.1.201.2;

1.1.201.2
date	2005.07.07.18.07.02;	author tg;	state Exp;
branches;
next	;
commitid	5f4742cd6f554c49;


desc
@@


1.5
log
@RCS IDs
@
text
@/* evilwm - Minimalist Window Manager for X
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
 * see README for license and other details. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "evilwm.h"
#include "log.h"

__RCSID("$MirOS$");

#ifdef INFOBANNER
Window info_window = None;

static void create_info_window(Client *c) {
	char *name;
	char buf[24];
	int namew, iwinx, iwiny, iwinw, iwinh;

	LOG_DEBUG("create_info_window() : Creating...\n");
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d",
	    (c->width-c->base_width)/c->width_inc,
	    (c->height-c->base_height)/c->height_inc, c->x, c->y);
	iwinw = XTextWidth(font, buf, strlen(buf)) + 2;
	iwinh = font->max_bounds.ascent + font->max_bounds.descent;
	XFetchName(dpy, c->window, &name);
	if (name) {
		namew = XTextWidth(font, name, strlen(name));
		if (namew > iwinw)
			iwinw = namew + 2;
		iwinh = iwinh * 2;
	}
	iwinx = c->x + c->border + c->width - iwinw;
	iwiny = c->y - c->border;
	if (iwinx + iwinw > DisplayWidth(dpy, c->screen->screen))
		iwinx = DisplayWidth(dpy, c->screen->screen) - iwinw;
	if (iwinx < 0)
		iwinx = 0;
	if (iwiny + iwinh > DisplayHeight(dpy, c->screen->screen))
		iwiny = DisplayHeight(dpy, c->screen->screen) - iwinh;
	if (iwiny < 0)
		iwiny = 0;
	if (info_window)
		XDestroyWindow(dpy, info_window);
	info_window = XCreateSimpleWindow(dpy, c->screen->root, iwinx, iwiny, iwinw, iwinh,
			0, c->screen->fg.pixel, c->screen->fg.pixel);
	XMapRaised(dpy, info_window);
	if (name) {
		XDrawString(dpy, info_window, c->screen->invert_gc,
			1, iwinh / 2 - 1,
			name, strlen(name));
		XFree(name);
	}
	XDrawString(dpy, info_window, c->screen->invert_gc,
		1, iwinh - 1,
		buf, strlen(buf));
}

static void remove_info_window(void) {
	LOG_DEBUG("remove_info_window() : Removing...\n");
	if (info_window)
		XDestroyWindow(dpy, info_window);
	info_window = None;
}
#endif  /* INFOBANNER */

static void draw_outline(Client *c) {
#ifndef INFOBANNER_MOVERESIZE
	char buf[24];
#endif  /* ndef INFOBANNER */

	XDrawRectangle(dpy, c->screen->root, c->screen->invert_gc,
		c->x - c->border, c->y - c->border,
		c->width + c->border, c->height + c->border);

#ifndef INFOBANNER_MOVERESIZE
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d",
	    (c->width-c->base_width)/c->width_inc,
	    (c->height-c->base_height)/c->height_inc, c->x, c->y);
	XDrawString(dpy, c->screen->root, c->screen->invert_gc,
		c->x + c->width - XTextWidth(font, buf, strlen(buf)) - SPACE,
		c->y + c->height - SPACE,
		buf, strlen(buf));
#endif  /* ndef INFOBANNER */
}

#ifdef MOUSE
void get_mouse_position(int *x, int *y, Window root) {
	Window dw1, dw2;
	int t1, t2;
	unsigned int t3;

	XQueryPointer(dpy, root, &dw1, &dw2, x, y, &t1, &t2, &t3);
}
#endif

void recalculate_sweep(Client *c, int x1, int y1, int x2, int y2) {
	c->width = abs(x1 - x2);
	c->height = abs(y1 - y2);
	c->width -= (c->width - c->base_width) % c->width_inc;
	c->height -= (c->height - c->base_height) % c->height_inc;
	if (c->min_width && c->width < c->min_width) c->width = c->min_width;
	if (c->min_height && c->height < c->min_height) c->height = c->min_height;
	if (c->max_width && c->width > c->max_width) c->width = c->max_width;
	if (c->max_height && c->height > c->max_height) c->height = c->max_height;
	c->x = (x1 <= x2) ? x1 : x1 - c->width;
	c->y = (y1 <= y2) ? y1 : y1 - c->height;
}

#ifdef MOUSE
void sweep(Client *c) {
	XEvent ev;
	int old_cx = c->x;
	int old_cy = c->y;

	if (!grab_pointer(c->screen->root, MouseMask, resize_curs)) return;

	XRaiseWindow(dpy, c->parent);
#ifdef INFOBANNER_MOVERESIZE
	create_info_window(c);
#endif
	XGrabServer(dpy);
	draw_outline(c);

	setmouse(c->window, c->width, c->height);
	for (;;) {
		XMaskEvent(dpy, MouseMask, &ev);
		switch (ev.type) {
			case MotionNotify:
				draw_outline(c); /* clear */
				XUngrabServer(dpy);
#ifdef INFOBANNER_MOVERESIZE
				remove_info_window();
#endif
				recalculate_sweep(c, old_cx, old_cy, ev.xmotion.x, ev.xmotion.y);
				XSync(dpy, False);
#ifdef INFOBANNER_MOVERESIZE
				create_info_window(c);
#endif
				XGrabServer(dpy);
				draw_outline(c);
				break;
			case ButtonRelease:
				draw_outline(c); /* clear */
				XUngrabServer(dpy);
#ifdef INFOBANNER_MOVERESIZE
				remove_info_window();
#endif
				XUngrabPointer(dpy, CurrentTime);
				moveresize(c);
				return;
		}
	}
}
#endif

void show_info(Client *c, KeySym key) {
	XEvent ev;
	XKeyboardState keyboard;

	XGetKeyboardControl(dpy, &keyboard);
	XAutoRepeatOff(dpy);
#ifdef INFOBANNER
	create_info_window(c);
#else
	XGrabServer(dpy);
	draw_outline(c);
#endif
	do {
		XMaskEvent(dpy, KeyReleaseMask, &ev);
	} while (XKeycodeToKeysym(dpy,ev.xkey.keycode,0) != key);
#ifdef INFOBANNER
	remove_info_window();
#else
	draw_outline(c);
	XUngrabServer(dpy);
#endif
	if (keyboard.global_auto_repeat == AutoRepeatModeOn)
		XAutoRepeatOn(dpy);
}

#ifdef MOUSE
#ifdef SNAP
static int absmin(int a, int b) {
	if (abs(a) < abs(b))
		return a;
	return b;
}

static void snap_client(Client *c) {
	int dx, dy;
	Client *ci;

	/* snap to screen border */
	if (abs(c->x - c->border) < opt_snap) c->x = c->border;
	if (abs(c->y - c->border) < opt_snap) c->y = c->border;
	if (abs(c->x + c->width + c->border - DisplayWidth(dpy, c->screen->screen)) < opt_snap)
		c->x = DisplayWidth(dpy, c->screen->screen) - c->width - c->border;
	if (abs(c->y + c->height + c->border - DisplayHeight(dpy, c->screen->screen)) < opt_snap)
		c->y = DisplayHeight(dpy, c->screen->screen) - c->height - c->border;

	/* snap to other windows */
	dx = dy = opt_snap;
	for (ci = head_client; ci; ci = ci->next) {
		if (ci != c
#ifdef VWM
				&& (ci->vdesk == vdesk || ci->vdesk == STICKY)
#endif
				) {
			if (ci->y - ci->border - c->border - c->height - c->y <= opt_snap && c->y - c->border - ci->border - ci->height - ci->y <= opt_snap) {
				dx = absmin(dx, ci->x + ci->width - c->x + c->border + ci->border);
				dx = absmin(dx, ci->x + ci->width - c->x - c->width);
				dx = absmin(dx, ci->x - c->x - c->width - c->border - ci->border);
				dx = absmin(dx, ci->x - c->x);
			}
			if (ci->x - ci->border - c->border - c->width - c->x <= opt_snap && c->x - c->border - ci->border - ci->width - ci->x <= opt_snap) {
				dy = absmin(dy, ci->y + ci->height - c->y + c->border + ci->border);
				dy = absmin(dy, ci->y + ci->height - c->y - c->height);
				dy = absmin(dy, ci->y - c->y - c->height - c->border - ci->border);
				dy = absmin(dy, ci->y - c->y);
			}
		}
	}
	if (abs(dx) < opt_snap)
		c->x += dx;
	if (abs(dy) < opt_snap)
		c->y += dy;
}
#endif /* def SNAP */

void drag(Client *c) {
	XEvent ev;
	int x1, y1;
	int old_cx = c->x;
	int old_cy = c->y;
	int reallymove = 0;

	if (!grab_pointer(c->screen->root, MouseMask, move_curs)) return;
	XRaiseWindow(dpy, c->parent);
	get_mouse_position(&x1, &y1, c->screen->root);
#ifdef INFOBANNER_MOVERESIZE
	create_info_window(c);
#endif
#ifndef SOLIDDRAG
	XGrabServer(dpy);
	draw_outline(c);
#endif 
	for (;;) {
		XMaskEvent(dpy, MouseMask, &ev);
		switch (ev.type) {
			case MotionNotify:
#ifndef SOLIDDRAG
				draw_outline(c); /* clear */
				XUngrabServer(dpy);
#endif
#ifdef INFOBANNER_MOVERESIZE
				remove_info_window();
#endif
				c->x = old_cx + (ev.xmotion.x - x1);
				c->y = old_cy + (ev.xmotion.y - y1);
#ifdef SNAP
				if (opt_snap)
					snap_client(c);
#endif
#ifndef OLD_MOVE_BEHAVIOUR
				if ((abs(c->x - old_cx)>5) || (abs(c->y - old_cy)>5))
#endif
					reallymove = 1;
#ifdef INFOBANNER_MOVERESIZE
				create_info_window(c);
#endif
#ifndef SOLIDDRAG
				XSync(dpy, False);
				XGrabServer(dpy);
				draw_outline(c);
#else
				if (reallymove) {
					XMoveWindow(dpy, c->parent, c->x - c->border,
						c->y - c->border);
					send_config(c);
				}
#endif 
				break;
			case ButtonRelease:
#ifndef SOLIDDRAG
				draw_outline(c); /* clear */
				XUngrabServer(dpy);
#endif
#ifdef INFOBANNER_MOVERESIZE
				remove_info_window();
#endif
				XUngrabPointer(dpy, CurrentTime);
#ifndef SOLIDDRAG
				if (!reallymove) {
					c->x = old_cx;
					c->y = old_cy;
				}
				moveresize(c);
#endif
				return;
			default:
				break;
		}
	}
}
#endif /* def MOUSE */

void moveresize(Client *c) {
	XRaiseWindow(dpy, c->parent);
	XMoveResizeWindow(dpy, c->parent, c->x - c->border,
			c->y - c->border, c->width + (c->border*2),
			c->height + (c->border*2));
	XMoveResizeWindow(dpy, c->window, c->border, c->border,
			c->width, c->height);
}

void maximise_horiz(Client *c) {
	LOG_DEBUG("SCREEN: maximise_horiz()\n");
	if (c->oldw) {
		c->x = c->oldx;
		c->width = c->oldw;
		c->oldw = 0;
	} else {
		c->oldx = c->x;
		c->oldw = c->width;
		recalculate_sweep(c, 0, c->y, DisplayWidth(dpy, c->screen->screen),
				c->y + c->height);
	}
}

void maximise_vert(Client *c) {
	LOG_DEBUG("SCREEN: maximise_vert()\n");
	if (c->oldh) {
		c->y = c->oldy;
		c->height = c->oldh;
		c->oldh = 0;
	} else {
		c->oldy = c->y;
		c->oldh = c->height;
		recalculate_sweep(c, c->x, 0, c->x + c->width,
				DisplayHeight(dpy, c->screen->screen));
	}
}

#ifdef VWM
void hide(Client *c) {
	if (c) {
		c->ignore_unmap++;
		LOG_XDEBUG("screen:XUnmapWindow(parent); ");
		XUnmapWindow(dpy, c->parent);
		set_wm_state(c, IconicState);
	}
}
#endif

void unhide(Client *c, int raise_win) {
	XMapWindow(dpy, c->window);
	raise_win ? XMapRaised(dpy, c->parent) : XMapWindow(dpy, c->parent);
	set_wm_state(c, NormalState);
}

void next(void) {
	Client *newc = current;
	do {
		if (newc) {
			newc = newc->next;
			if (!newc && !current)
				return;
		}
		if (!newc)
			newc = head_client;
		if (!newc)
			return;
		if (newc == current)
			return;
	}
#ifdef VWM
	while (newc->vdesk != vdesk && newc->vdesk != STICKY);
#else
	while (0);
#endif
	if (!newc)
		return;
	unhide(newc, RAISE);
	select_client(newc);
	setmouse(newc->window, 0, 0);
	setmouse(newc->window, newc->width + newc->border - 1,
		newc->height + newc->border - 1);
	/* Need to think about this - see note about shaped
	 * windows in TODO */
}

#ifdef VWM
void switch_vdesk(int v) {
	Client *c;
	int wdesk;
#ifdef VWM_WARP
	int warped = 0;
#endif
#ifdef DEBUG
	int hidden = 0, raised = 0;
#endif

	if (v == vdesk)
		return;
	if (current && current->vdesk != STICKY) {
		client_update_current(current, NULL);
	}
	LOG_DEBUG("switch_vdesk() : Switching to desk %d\n", v);
	for (c = head_client; c; c = c->next) {
		wdesk = c->vdesk;
		if (wdesk == vdesk) {
			hide(c);
#ifdef DEBUG
			hidden++;
#endif
		} else if (wdesk == v) {
			unhide(c, NO_RAISE);
#ifdef DEBUG
			raised++;
#endif
#ifdef VWM_WARP
			if (!warped) {
				setmouse(c->window, c->width, c->height);
				warped = 1;
			}
#endif
		}
	}
	vdesk = v;
	LOG_DEBUG("\tswitch_vdesk() : %d hidden, %d raised\n", hidden, raised);
}
#endif /* def VWM */

ScreenInfo *find_screen(Window root) {
	int i;
	for (i = 0; i < num_screens; i++) {
		if (screens[i].root == root)
			return &screens[i];
	}
	return NULL;
}
@


1.4
log
@remove some superfluous variables
@
text
@d11 2
@


1.3
log
@Finish the update of evilwm, taking care of local changes, strlcpy
cleanup, fixes for resize/move etc.
@
text
@a17 1
	int width_inc = c->width_inc, height_inc = c->height_inc;
d20 3
a22 2
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", (c->width-c->base_width)/width_inc,
		(c->height-c->base_height)/height_inc, c->x, c->y);
a68 1
	int width_inc = c->width_inc, height_inc = c->height_inc;
d76 3
a78 2
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", (c->width-c->base_width)/width_inc,
			(c->height-c->base_height)/height_inc, c->x, c->y);
@


1.2
log
@merge over X11/extras

XXX rewrite evilwm man page in -mdoc
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002 Ciaran Anscomb <evilwm@@6809.org.uk>
d9 1
a9 7

#ifdef VWM
# define HAS_HIDE 1
#endif
#ifdef VDESK
# define HAS_HIDE 1
#endif
d14 1
a14 1
void create_info_window(Client *c) {
d18 1
a18 1
	int width_inc = 1, height_inc = 1;
d20 3
a22 9
#ifdef DEBUG
	fprintf(stderr, "create_info_window() : Creating...\n");
#endif
	if (c->size->flags & PResizeInc) {
		width_inc = c->size->width_inc;
		height_inc = c->size->height_inc;
	}
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", c->width/width_inc,
		c->height/height_inc, c->x, c->y);
d58 2
a59 4
void remove_info_window(void) {
#ifdef DEBUG
	fprintf(stderr, "remove_info_window() : Removing...\n");
#endif
d66 1
a66 1
void draw_outline(Client *c) {
d69 1
a69 1
	int width_inc = 1, height_inc = 1;
d77 2
a78 6
	if (c->size->flags & PResizeInc) {
		width_inc = c->size->width_inc;
		height_inc = c->size->height_inc;
	}
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", c->width/width_inc,
			c->height/height_inc, c->x, c->y);
a96 2
	int basex, basey;

d99 6
a104 20

	if (c->size->flags & PResizeInc) {
		basex = (c->size->flags & PBaseSize) ? c->size->base_width :
			(c->size->flags & PMinSize) ? c->size->min_width : 0;
		basey = (c->size->flags & PBaseSize) ? c->size->base_height :
			(c->size->flags & PMinSize) ? c->size->min_height : 0;
		c->width -= (c->width - basex) % c->size->width_inc;
		c->height -= (c->height - basey) % c->size->height_inc;
	}

	if (c->size->flags & PMinSize) {
		if (c->width < c->size->min_width) c->width = c->size->min_width;
		if (c->height < c->size->min_height) c->height = c->size->min_height;
	}

	if (c->size->flags & PMaxSize) {
		if (c->width > c->size->max_width) c->width = c->size->max_width;
		if (c->height > c->size->max_height) c->height = c->size->max_height;
	}

d117 1
d149 1
d204 5
a208 1
		if (ci != c && (ci->vdesk == vdesk || ci->vdesk == STICKY)) {
d238 1
d292 1
d297 2
d307 7
a313 26
void move(Client *c, int set) {
	if (c) {
		XRaiseWindow(dpy, c->parent);
#ifdef MOUSE
		if (!set)
			drag(c);
#endif
		XMoveWindow(dpy, c->parent, c->x - c->border, c->y - c->border);
		send_config(c);
	}
}

void resize(Client *c, int set) {
	if (c) {
		XRaiseWindow(dpy, c->parent);
#ifdef MOUSE
		if (!set)
			sweep(c);
#endif
		XMoveResizeWindow(dpy, c->parent, c->x - c->border,
				c->y - c->border, c->width + (c->border*2),
				c->height + (c->border*2));
		XMoveResizeWindow(dpy, c->window, c->border, c->border,
				c->width, c->height);
		send_config(c);
	}
d317 1
a317 3
#ifdef DEBUG
	fprintf(stderr, "SCREEN: maximise_horiz()\n");
#endif
d331 1
a331 3
#ifdef DEBUG
	fprintf(stderr, "SCREEN: maximise_vert()\n");
#endif
d344 1
a344 1
#ifdef HAS_HIDE
d347 2
a348 4
		c->ignore_unmap += 2;
#ifdef XDEBUG
		fprintf(stderr, "screen:XUnmapWindow(parent); ");
#endif
a349 4
#ifdef XDEBUG
		fprintf(stderr, "screen:XUnmapWindow(window); ");
#endif
		XUnmapWindow(dpy, c->window);
d355 1
a355 1
void unhide(Client *c, int raise) {
d357 1
a357 1
	raise ? XMapRaised(dpy, c->parent) : XMapWindow(dpy, c->parent);
d363 5
a367 11

	if (!newc) {
#ifdef DEBUG
		fprintf(stderr,"NEXT: no current window, looking on this desktop\n");
#endif
		newc = head_client;
#ifdef VWM
		if(newc->vdesk != vdesk && newc->vdesk != STICKY) {
			do {
				newc = newc->next;
			} while (newc && newc->vdesk != vdesk && newc->vdesk != STICKY);
d369 6
a374 11
#endif
	} else {
#ifdef VWM
		do {
#endif
			newc = newc->next;
			if (current && !newc)
				newc = head_client;
#ifdef VWM
		} while (newc && newc->vdesk != vdesk && newc->vdesk != STICKY);
#endif
a375 1
	if (newc) {
d377 3
a379 1
		if (newc->vdesk == vdesk || newc->vdesk == STICKY) {
d381 9
a389 14
			unhide(newc, RAISE);
			setmouse(newc->window, 0, 0);
			setmouse(newc->window, newc->width + newc->border - 1,
				newc->height + newc->border - 1);
#ifdef VWM
		}
#endif
	}
#ifdef DEBUG
       else {
               fprintf(stderr,"NEXT: hmm, no next window\n");
       }
#endif

a392 6
#ifdef VDESK_BOTH
void switch_vdesk(int v) {
	spawn_vdesk(v, NULL);
	vdesk = v;
}
#else
d408 1
a408 3
#ifdef DEBUG
	fprintf(stderr, "switch_vdesk() : Switching to desk %d\n", v);
#endif
d430 1
a430 3
#ifdef DEBUG
	fprintf(stderr, "\tswitch_vdesk() : %d hidden, %d raised\n", hidden, raised);
#endif
a431 1
#endif /* def VDESK_BOTH */
@


1.1
log
@Initial revision
@
text
@d291 1
a291 1

d293 1
@


1.1.201.1
log
@evilwm 0.99.17
@
text
@@


1.1.201.2
log
@There is a new evilwm out there!
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2005 Ciaran Anscomb <evilwm@@6809.org.uk>
d9 7
a15 1
#include "log.h"
d20 1
a20 1
static void create_info_window(Client *c) {
d24 1
a24 1
	int width_inc = c->width_inc, height_inc = c->height_inc;
d26 9
a34 3
	LOG_DEBUG("create_info_window() : Creating...\n");
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", (c->width-c->base_width)/width_inc,
		(c->height-c->base_height)/height_inc, c->x, c->y);
d70 4
a73 2
static void remove_info_window(void) {
	LOG_DEBUG("remove_info_window() : Removing...\n");
d80 1
a80 1
static void draw_outline(Client *c) {
d83 1
a83 1
	int width_inc = c->width_inc, height_inc = c->height_inc;
d91 6
a96 2
	snprintf(buf, sizeof(buf), "%dx%d+%d+%d", (c->width-c->base_width)/width_inc,
			(c->height-c->base_height)/height_inc, c->x, c->y);
d115 2
d119 20
a138 6
	c->width -= (c->width - c->base_width) % c->width_inc;
	c->height -= (c->height - c->base_height) % c->height_inc;
	if (c->min_width && c->width < c->min_width) c->width = c->min_width;
	if (c->min_height && c->height < c->min_height) c->height = c->min_height;
	if (c->max_width && c->width > c->max_width) c->width = c->max_width;
	if (c->max_height && c->height > c->max_height) c->height = c->max_height;
a150 1
	XRaiseWindow(dpy, c->parent);
a181 1
				moveresize(c);
d236 1
a236 5
		if (ci != c
#ifdef VWM
				&& (ci->vdesk == vdesk || ci->vdesk == STICKY)
#endif
				) {
a265 1
	XRaiseWindow(dpy, c->parent);
a317 1
#ifndef SOLIDDRAG
a321 2
				moveresize(c);
#endif
d330 26
a355 7
void moveresize(Client *c) {
	XRaiseWindow(dpy, c->parent);
	XMoveResizeWindow(dpy, c->parent, c->x - c->border,
			c->y - c->border, c->width + (c->border*2),
			c->height + (c->border*2));
	XMoveResizeWindow(dpy, c->window, c->border, c->border,
			c->width, c->height);
d359 3
a361 1
	LOG_DEBUG("SCREEN: maximise_horiz()\n");
d375 3
a377 1
	LOG_DEBUG("SCREEN: maximise_vert()\n");
d390 1
a390 1
#ifdef VWM
d393 4
a396 2
		c->ignore_unmap++;
		LOG_XDEBUG("screen:XUnmapWindow(parent); ");
d398 4
d407 1
a407 1
void unhide(Client *c, int raise_win) {
d409 1
a409 1
	raise_win ? XMapRaised(dpy, c->parent) : XMapWindow(dpy, c->parent);
d415 17
a431 2
	do {
		if (newc) {
d433 15
a447 2
			if (!newc && !current)
				return;
d449 1
a449 6
		if (!newc)
			newc = head_client;
		if (!newc)
			return;
		if (newc == current)
			return;
d451 4
a454 4
#ifdef VWM
	while (newc->vdesk != vdesk && newc->vdesk != STICKY);
#else
	while (0);
d456 1
a456 9
	if (!newc)
		return;
	unhide(newc, RAISE);
	select_client(newc);
	setmouse(newc->window, 0, 0);
	setmouse(newc->window, newc->width + newc->border - 1,
		newc->height + newc->border - 1);
	/* Need to think about this - see note about shaped
	 * windows in TODO */
d460 6
d481 3
a483 1
	LOG_DEBUG("switch_vdesk() : Switching to desk %d\n", v);
d505 3
a507 1
	LOG_DEBUG("\tswitch_vdesk() : %d hidden, %d raised\n", hidden, raised);
d509 1
@

