head	1.9;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.4
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.9
date	2017.04.15.21.59.17;	author tg;	state Exp;
branches;
next	1.8;
commitid	10058F297C733B7495A;

1.8
date	2017.04.15.19.20.23;	author tg;	state Exp;
branches;
next	1.7;
commitid	10058F2723111C7BEE2;

1.7
date	2013.08.06.20.16.12;	author tg;	state Exp;
branches;
next	1.6;
commitid	100520159A36461EFAD;

1.6
date	2013.08.06.19.46.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	100520152445E05B912;

1.5
date	2008.08.02.20.00.41;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004894BCFA46ADF2BC;

1.4
date	2008.02.26.20.04.30;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10047C470A72A1E13CE;

1.3
date	2006.06.29.20.57.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044A43EA43D270785;

1.2
date	2006.06.29.20.24.19;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.42.59;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.54.09;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.42.59;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.22;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.38.07;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.14;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.41.48;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.9
log
@fix double definition, just use our config file
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftsystem.c                                                             */
/*                                                                         */
/*    Unix-specific FreeType low-level system interface (body).            */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#ifdef MBSD_BUILD
#include <sys/cdefs.h>
__RCSID("$MirOS: X11/xc/extras/freetype2/builds/unix/ftsystem.c,v 1.6 2013/08/06 19:46:41 tg Exp $");
#include FT_CONFIG_CONFIG_H
#else
  /* we use our special ftconfig.h file, not the standard one */
#include <ftconfig.h>
#endif
#include FT_INTERNAL_DEBUG_H
#include FT_SYSTEM_H
#include FT_ERRORS_H
#include FT_TYPES_H
#include FT_INTERNAL_STREAM_H

  /* memory-mapping includes and definitions */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <sys/mman.h>
#ifndef MAP_FILE
#define MAP_FILE  0x00
#endif

#ifdef MUNMAP_USES_VOIDP
#define MUNMAP_ARG_CAST  void *
#else
#define MUNMAP_ARG_CAST  char *
#endif

#ifdef NEED_MUNMAP_DECL

#ifdef __cplusplus
  extern "C"
#else
  extern
#endif
  int
  munmap( char*  addr,
          int    len );

#define MUNMAP_ARG_CAST  char *

#endif /* NEED_DECLARATION_MUNMAP */


#include <sys/types.h>
#include <sys/stat.h>

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>


  /*************************************************************************/
  /*                                                                       */
  /*                       MEMORY MANAGEMENT INTERFACE                     */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ft_alloc                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The memory allocation function.                                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory :: A pointer to the memory object.                          */
  /*                                                                       */
  /*    size   :: The requested size in bytes.                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The address of newly allocated block.                              */
  /*                                                                       */
  FT_CALLBACK_DEF( void* )
  ft_alloc( FT_Memory  memory,
            long       size )
  {
    FT_UNUSED( memory );

    return malloc( size );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ft_realloc                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The memory reallocation function.                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory   :: A pointer to the memory object.                        */
  /*                                                                       */
  /*    cur_size :: The current size of the allocated memory block.        */
  /*                                                                       */
  /*    new_size :: The newly requested size in bytes.                     */
  /*                                                                       */
  /*    block    :: The current address of the block in memory.            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The address of the reallocated memory block.                       */
  /*                                                                       */
  FT_CALLBACK_DEF( void* )
  ft_realloc( FT_Memory  memory,
              long       cur_size,
              long       new_size,
              void*      block )
  {
    FT_UNUSED( memory );
    FT_UNUSED( cur_size );

    return realloc( block, new_size );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ft_free                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The memory release function.                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory :: A pointer to the memory object.                          */
  /*                                                                       */
  /*    block  :: The address of block in memory to be freed.              */
  /*                                                                       */
  FT_CALLBACK_DEF( void )
  ft_free( FT_Memory  memory,
           void*      block )
  {
    FT_UNUSED( memory );

    free( block );
  }


  /*************************************************************************/
  /*                                                                       */
  /*                     RESOURCE MANAGEMENT INTERFACE                     */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_io

  /* We use the macro STREAM_FILE for convenience to extract the       */
  /* system-specific stream handle from a given FreeType stream object */
#define STREAM_FILE( stream )  ( (FILE*)stream->descriptor.pointer )


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ft_close_stream_by_munmap                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The function to close a stream which is opened by mmap.            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream :: A pointer to the stream object.                          */
  /*                                                                       */
  FT_CALLBACK_DEF( void )
  ft_close_stream_by_munmap( FT_Stream  stream )
  {
    munmap( (MUNMAP_ARG_CAST)stream->descriptor.pointer, stream->size );

    stream->descriptor.pointer = NULL;
    stream->size               = 0;
    stream->base               = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ft_close_stream_by_free                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The function to close a stream which is created by ft_alloc.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream :: A pointer to the stream object.                          */
  /*                                                                       */
  FT_CALLBACK_DEF( void )
  ft_close_stream_by_free( FT_Stream  stream )
  {
    ft_free( NULL, stream->descriptor.pointer );

    stream->descriptor.pointer = NULL;
    stream->size               = 0;
    stream->base               = 0;
  }


  /* documentation is in ftobjs.h */

  FT_BASE_DEF( FT_Error )
  FT_Stream_Open( FT_Stream    stream,
                  const char*  filepathname )
  {
    int          file;
    struct stat  stat_buf;


    if ( !stream )
      return FT_THROW( Invalid_Stream_Handle );

    /* open the file */
    file = open( filepathname, O_RDONLY );
    if ( file < 0 )
    {
      FT_ERROR(( "FT_Stream_Open:" ));
      FT_ERROR(( " could not open `%s'\n", filepathname ));
      return FT_THROW( Cannot_Open_Resource );
    }

    /* Here we ensure that a "fork" will _not_ duplicate   */
    /* our opened input streams on Unix.  This is critical */
    /* since it avoids some (possible) access control      */
    /* issues and cleans up the kernel file table a bit.   */
    /*                                                     */
#ifdef F_SETFD
#ifdef FD_CLOEXEC
    (void)fcntl( file, F_SETFD, FD_CLOEXEC );
#else
    (void)fcntl( file, F_SETFD, 1 );
#endif /* FD_CLOEXEC */
#endif /* F_SETFD */

    if ( fstat( file, &stat_buf ) < 0 )
    {
      FT_ERROR(( "FT_Stream_Open:" ));
      FT_ERROR(( " could not `fstat' file `%s'\n", filepathname ));
      goto Fail_Map;
    }

    /* XXX: TODO -- real 64bit platform support                        */
    /*                                                                 */
    /* `stream->size' is typedef'd to unsigned long (in `ftsystem.h'); */
    /* `stat_buf.st_size', however, is usually typedef'd to off_t      */
    /* (in sys/stat.h).                                                */
    /* On some platforms, the former is 32bit and the latter is 64bit. */
    /* To avoid overflow caused by fonts in huge files larger than     */
    /* 2GB, do a test.  Temporary fix proposed by Sean McBride.        */
    /*                                                                 */
    if ( stat_buf.st_size > LONG_MAX )
    {
      FT_ERROR(( "FT_Stream_Open: file is too big\n" ));
      goto Fail_Map;
    }
    else if ( stat_buf.st_size == 0 )
    {
      FT_ERROR(( "FT_Stream_Open: zero-length file\n" ));
      goto Fail_Map;
    }

    /* This cast potentially truncates a 64bit to 32bit! */
    stream->size = (unsigned long)stat_buf.st_size;
    stream->pos  = 0;
    stream->base = (unsigned char *)mmap( NULL,
                                          stream->size,
                                          PROT_READ,
                                          MAP_FILE | MAP_PRIVATE,
                                          file,
                                          0 );

    /* on some RTOS, mmap might return 0 */
    if ( (long)stream->base != -1 && stream->base != NULL )
      stream->close = ft_close_stream_by_munmap;
    else
    {
      ssize_t  total_read_count;


      FT_ERROR(( "FT_Stream_Open:" ));
      FT_ERROR(( " could not `mmap' file `%s'\n", filepathname ));

      stream->base = (unsigned char*)ft_alloc( NULL, stream->size );

      if ( !stream->base )
      {
        FT_ERROR(( "FT_Stream_Open:" ));
        FT_ERROR(( " could not `alloc' memory\n" ));
        goto Fail_Map;
      }

      total_read_count = 0;
      do
      {
        ssize_t  read_count;


        read_count = read( file,
                           stream->base + total_read_count,
                           stream->size - total_read_count );

        if ( read_count <= 0 )
        {
          if ( read_count == -1 && errno == EINTR )
            continue;

          FT_ERROR(( "FT_Stream_Open:" ));
          FT_ERROR(( " error while `read'ing file `%s'\n", filepathname ));
          goto Fail_Read;
        }

        total_read_count += read_count;

      } while ( (unsigned long)total_read_count != stream->size );

      stream->close = ft_close_stream_by_free;
    }

    close( file );

    stream->descriptor.pointer = stream->base;
    stream->pathname.pointer   = (char*)filepathname;

    stream->read = 0;

    FT_TRACE1(( "FT_Stream_Open:" ));
    FT_TRACE1(( " opened `%s' (%d bytes) successfully\n",
                filepathname, stream->size ));

    return FT_Err_Ok;

  Fail_Read:
    ft_free( NULL, stream->base );

  Fail_Map:
    close( file );

    stream->base = NULL;
    stream->size = 0;
    stream->pos  = 0;

    return FT_THROW( Cannot_Open_Stream );
  }


#ifdef FT_DEBUG_MEMORY

  extern FT_Int
  ft_mem_debug_init( FT_Memory  memory );

  extern void
  ft_mem_debug_done( FT_Memory  memory );

#endif


  /* documentation is in ftobjs.h */

  FT_BASE_DEF( FT_Memory )
  FT_New_Memory( void )
  {
    FT_Memory  memory;


    memory = (FT_Memory)malloc( sizeof ( *memory ) );
    if ( memory )
    {
      memory->user    = 0;
      memory->alloc   = ft_alloc;
      memory->realloc = ft_realloc;
      memory->free    = ft_free;
#ifdef FT_DEBUG_MEMORY
      ft_mem_debug_init( memory );
#endif
    }

    return memory;
  }


  /* documentation is in ftobjs.h */

  FT_BASE_DEF( void )
  FT_Done_Memory( FT_Memory  memory )
  {
#ifdef FT_DEBUG_MEMORY
    ft_mem_debug_done( memory );
#endif
    memory->free( memory, memory );
  }


/* END */
@


1.8
log
@first cut at a quickmerge
@
text
@d22 2
a23 3
__RCSID("$MirOS: X11/xc/extras/freetype2/builds/unix/ftsystem.c,v 1.7 2013/08/06 20:16:12 tg Exp $");
#define HAVE_UNISTD_H
#define HAVE_FCNTL_H
@


1.7
log
@fix build
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007, 2008 by             */
d22 1
a22 1
__RCSID("$MirOS: X11/xc/extras/freetype2/builds/unix/ftsystem.c,v 1.6 2013/08/06 19:46:41 tg Exp $");
d245 1
a245 1
      return FT_Err_Invalid_Stream_Handle;
d253 1
a253 1
      return FT_Err_Cannot_Open_Resource;
d278 3
a280 3
    /* `stream->size' is typedef'd to unsigned long (in                */
    /* freetype/ftsystem.h); `stat_buf.st_size', however, is usually   */
    /* typedef'd to off_t (in sys/stat.h).                             */
d327 2
a328 1
      do {
d376 1
a376 1
    return FT_Err_Cannot_Open_Stream;
@


1.6
log
@fastmerge
@
text
@d21 2
a22 1
__RCSID("$MirOS$");
@


1.5
log
@missing include
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007 by                   */
d20 5
a25 1
#ifndef MBSD_BUILD
a33 2
#include <fcntl.h>

d35 1
a35 1
#if defined(HAVE_UNISTD_H) || defined(MBSD_BUILD)
d286 6
a291 1
      FT_ERROR(( "FT_Stream_Open: file is too big" ));
@


1.4
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d33 1
a33 1
#ifdef HAVE_UNISTD_H
@


1.3
log
@* finish building
* bump major after nm'ing (although not strictly required)

note: we now have a pkgconfig file ;)

xterm -fa Gentium and xterm -fa Unifont both now work
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006 by                         */
d273 17
a289 1
    stream->size = stat_buf.st_size;
d298 2
a299 1
    if ( (long)stream->base != -1 )
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d21 1
d23 1
d30 2
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004 by                                     */
d26 1
a26 1
#include FT_INTERNAL_OBJECTS_H
d229 1
a229 1
  FT_EXPORT_DEF( FT_Error )
d283 1
a283 1
    
d287 3
a289 3
      
      stream->base = ft_alloc( NULL, stream->size );
      
d296 1
a296 1
      
d302 2
a303 2
        read_count = read( file, 
                           stream->base + total_read_count, 
d306 1
a306 1
        if ( ( read_count == -1 ) )
d308 1
a308 1
          if ( errno == EINTR )
d318 1
a318 1
      } while ( total_read_count != stream->size );
d363 1
a363 1
  FT_EXPORT_DEF( FT_Memory )
d387 1
a387 1
  FT_EXPORT_DEF( void )
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007 by                   */
d26 1
a26 1
#include FT_INTERNAL_STREAM_H
d229 1
a229 1
  FT_BASE_DEF( FT_Error )
d269 1
a269 17
    /* XXX: TODO -- real 64bit platform support                        */
    /*                                                                 */
    /* `stream->size' is typedef'd to unsigned long (in                */
    /* freetype/ftsystem.h); `stat_buf.st_size', however, is usually   */
    /* typedef'd to off_t (in sys/stat.h).                             */
    /* On some platforms, the former is 32bit and the latter is 64bit. */
    /* To avoid overflow caused by fonts in huge files larger than     */
    /* 2GB, do a test.  Temporary fix proposed by Sean McBride.        */
    /*                                                                 */
    if ( stat_buf.st_size > LONG_MAX )
    {
      FT_ERROR(( "FT_Stream_Open: file is too big" ));
      goto Fail_Map;
    }

    /* This cast potentially truncates a 64bit to 32bit! */
    stream->size = (unsigned long)stat_buf.st_size;
d278 1
a278 2
    /* on some RTOS, mmap might return 0 */
    if ( (long)stream->base != -1 && stream->base != NULL )
d283 1
a283 1

d287 3
a289 3

      stream->base = (unsigned char*)ft_alloc( NULL, stream->size );

d296 1
a296 1

d302 2
a303 2
        read_count = read( file,
                           stream->base + total_read_count,
d306 1
a306 1
        if ( read_count <= 0 )
d308 1
a308 1
          if ( read_count == -1 && errno == EINTR )
d318 1
a318 1
      } while ( (unsigned long)total_read_count != stream->size );
d363 1
a363 1
  FT_BASE_DEF( FT_Memory )
d387 1
a387 1
  FT_BASE_DEF( void )
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006 by                         */
d26 1
a26 1
#include FT_INTERNAL_STREAM_H
d229 1
a229 1
  FT_BASE_DEF( FT_Error )
d283 1
a283 1

d287 3
a289 3

      stream->base = (unsigned char*)ft_alloc( NULL, stream->size );

d296 1
a296 1

d302 2
a303 2
        read_count = read( file,
                           stream->base + total_read_count,
d306 1
a306 1
        if ( read_count <= 0 )
d308 1
a308 1
          if ( read_count == -1 && errno == EINTR )
d318 1
a318 1
      } while ( (unsigned long)total_read_count != stream->size );
d363 1
a363 1
  FT_BASE_DEF( FT_Memory )
d387 1
a387 1
  FT_BASE_DEF( void )
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007, 2008 by             */
d269 1
a269 22
    /* XXX: TODO -- real 64bit platform support                        */
    /*                                                                 */
    /* `stream->size' is typedef'd to unsigned long (in                */
    /* freetype/ftsystem.h); `stat_buf.st_size', however, is usually   */
    /* typedef'd to off_t (in sys/stat.h).                             */
    /* On some platforms, the former is 32bit and the latter is 64bit. */
    /* To avoid overflow caused by fonts in huge files larger than     */
    /* 2GB, do a test.  Temporary fix proposed by Sean McBride.        */
    /*                                                                 */
    if ( stat_buf.st_size > LONG_MAX )
    {
      FT_ERROR(( "FT_Stream_Open: file is too big\n" ));
      goto Fail_Map;
    }
    else if ( stat_buf.st_size == 0 )
    {
      FT_ERROR(( "FT_Stream_Open: zero-length file\n" ));
      goto Fail_Map;
    }

    /* This cast potentially truncates a 64bit to 32bit! */
    stream->size = (unsigned long)stat_buf.st_size;
d278 1
a278 2
    /* on some RTOS, mmap might return 0 */
    if ( (long)stream->base != -1 && stream->base != NULL )
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d238 1
a238 1
      return FT_THROW( Invalid_Stream_Handle );
d246 1
a246 1
      return FT_THROW( Cannot_Open_Resource );
d271 3
a273 3
    /* `stream->size' is typedef'd to unsigned long (in `ftsystem.h'); */
    /* `stat_buf.st_size', however, is usually typedef'd to off_t      */
    /* (in sys/stat.h).                                                */
d320 1
a320 2
      do
      {
d368 1
a368 1
    return FT_THROW( Cannot_Open_Stream );
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
