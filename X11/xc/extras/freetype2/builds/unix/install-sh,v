head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@# @;


1.5
date	2017.04.15.19.20.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.46.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.04.30;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.19;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.00;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.54.06;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.00;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.22;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.38.20;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.15;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.41.49;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@#!/bin/sh
# install - install a program, script, or datafile

scriptversion=2013-12-25.23; # UTC

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# 'make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.

tab='	'
nl='
'
IFS=" $tab$nl"

# Set DOITPROG to "echo" to test this script.

doit=${DOITPROG-}
doit_exec=${doit:-exec}

# Put in absolute file names if you don't have them in your path;
# or use environment vars.

chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_mkdir=

# Desired mode of installed file.
mode=0755

chgrpcmd=
chmodcmd=$chmodprog
chowncmd=
mvcmd=$mvprog
rmcmd="$rmprog -f"
stripcmd=

src=
dst=
dir_arg=
dst_arg=

copy_on_change=false
is_target_a_directory=possibly

usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
"

while test $# -ne 0; do
  case $1 in
    -c) ;;

    -C) copy_on_change=true;;

    -d) dir_arg=true;;

    -g) chgrpcmd="$chgrpprog $2"
        shift;;

    --help) echo "$usage"; exit $?;;

    -m) mode=$2
        case $mode in
          *' '* | *"$tab"* | *"$nl"* | *'*'* | *'?'* | *'['*)
            echo "$0: invalid mode: $mode" >&2
            exit 1;;
        esac
        shift;;

    -o) chowncmd="$chownprog $2"
        shift;;

    -s) stripcmd=$stripprog;;

    -t)
        is_target_a_directory=always
        dst_arg=$2
        # Protect names problematic for 'test' and other utilities.
        case $dst_arg in
          -* | [=\(\)!]) dst_arg=./$dst_arg;;
        esac
        shift;;

    -T) is_target_a_directory=never;;

    --version) echo "$0 $scriptversion"; exit $?;;

    --) shift
        break;;

    -*) echo "$0: invalid option: $1" >&2
        exit 1;;

    *)  break;;
  esac
  shift
done

# We allow the use of options -d and -T together, by making -d
# take the precedence; this is for compatibility with GNU install.

if test -n "$dir_arg"; then
  if test -n "$dst_arg"; then
    echo "$0: target directory not allowed when installing a directory." >&2
    exit 1
  fi
fi

if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@@.
  for arg
  do
    if test -n "$dst_arg"; then
      # $@@ is not empty: it contains at least $arg.
      set fnord "$@@" "$dst_arg"
      shift # fnord
    fi
    shift # arg
    dst_arg=$arg
    # Protect names problematic for 'test' and other utilities.
    case $dst_arg in
      -* | [=\(\)!]) dst_arg=./$dst_arg;;
    esac
  done
fi

if test $# -eq 0; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call 'install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi

if test -z "$dir_arg"; then
  if test $# -gt 1 || test "$is_target_a_directory" = always; then
    if test ! -d "$dst_arg"; then
      echo "$0: $dst_arg: Is not a directory." >&2
      exit 1
    fi
  fi
fi

if test -z "$dir_arg"; then
  do_exit='(exit $ret); exit $ret'
  trap "ret=129; $do_exit" 1
  trap "ret=130; $do_exit" 2
  trap "ret=141; $do_exit" 13
  trap "ret=143; $do_exit" 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi

for src
do
  # Protect names problematic for 'test' and other utilities.
  case $src in
    -* | [=\(\)!]) src=./$src;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
  else

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dst_arg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi
    dst=$dst_arg

    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test "$is_target_a_directory" = never; then
        echo "$0: $dst_arg: Is a directory" >&2
        exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      dstdir=`dirname "$dst"`
      test -d "$dstdir"
      dstdir_status=$?
    fi
  fi

  obsolete_mkdir_used=false

  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
        # Create intermediate dirs using mode 755 as modified by the umask.
        # This is like FreeBSD 'install' as of 1997-10-28.
        umask=`umask`
        case $stripcmd.$umask in
          # Optimize common cases.
          *[2367][2367]) mkdir_umask=$umask;;
          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

          *[0-7])
            mkdir_umask=`expr $umask + 22 \
              - $umask % 100 % 40 + $umask % 20 \
              - $umask % 10 % 4 + $umask % 2
            `;;
          *) mkdir_umask=$umask,go-w;;
        esac

        # With -d, create the new directory with the user-specified mode.
        # Otherwise, rely on $mkdir_umask.
        if test -n "$dir_arg"; then
          mkdir_mode=-m$mode
        else
          mkdir_mode=
        fi

        posix_mkdir=false
        case $umask in
          *[123567][0-7][0-7])
            # POSIX mkdir -p sets u+wx bits regardless of umask, which
            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
            ;;
          *)
            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
            trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

            if (umask $mkdir_umask &&
                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
            then
              if test -z "$dir_arg" || {
                   # Check for POSIX incompatibilities with -m.
                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
                   # other-writable bit of parent directory when it shouldn't.
                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
                   ls_ld_tmpdir=`ls -ld "$tmpdir"`
                   case $ls_ld_tmpdir in
                     d????-?r-*) different_mode=700;;
                     d????-?--*) different_mode=755;;
                     *) false;;
                   esac &&
                   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
                     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
                     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
                   }
                 }
              then posix_mkdir=:
              fi
              rmdir "$tmpdir/d" "$tmpdir"
            else
              # Remove any dirs left behind by ancient mkdir implementations.
              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
            fi
            trap '' 0;;
        esac;;
    esac

    if
      $posix_mkdir && (
        umask $mkdir_umask &&
        $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
    then :
    else

      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.

      case $dstdir in
        /*) prefix='/';;
        [-=\(\)!]*) prefix='./';;
        *)  prefix='';;
      esac

      oIFS=$IFS
      IFS=/
      set -f
      set fnord $dstdir
      shift
      set +f
      IFS=$oIFS

      prefixes=

      for d
      do
        test X"$d" = X && continue

        prefix=$prefix$d
        if test -d "$prefix"; then
          prefixes=
        else
          if $posix_mkdir; then
            (umask=$mkdir_umask &&
             $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
            # Don't fail if two instances are running concurrently.
            test -d "$prefix" || exit 1
          else
            case $prefix in
              *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
              *) qprefix=$prefix;;
            esac
            prefixes="$prefixes '$qprefix'"
          fi
        fi
        prefix=$prefix/
      done

      if test -n "$prefixes"; then
        # Don't fail if two instances are running concurrently.
        (umask $mkdir_umask &&
         eval "\$doit_exec \$mkdirprog $prefixes") ||
          test -d "$dstdir" || exit 1
        obsolete_mkdir_used=true
      fi
    fi
  fi

  if test -n "$dir_arg"; then
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
  else

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0

    # Copy the file name to the temp name.
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"     2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"  2>/dev/null` &&
       set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       set +f &&
       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||

      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
        # Now remove or move aside any old file at destination location.
        # We try this two ways since rm can't unlink itself on some
        # systems and the destination file might be busy for other
        # reasons.  In this case, the final cleanup might fail but the new
        # file should still install successfully.
        {
          test ! -f "$dst" ||
          $doit $rmcmd -f "$dst" 2>/dev/null ||
          { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
            { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
          } ||
          { echo "$0: cannot unlink or rename $dst" >&2
            (exit 1); exit 1
          }
        } &&

        # Now rename the file to the real destination.
        $doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1

    trap '' 0
  fi
done

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:
@


1.4
log
@fastmerge
@
text
@d4 1
a4 1
scriptversion=2009-04-28.21; # UTC
d38 1
a38 1
# `make' implicit rules from creating a file called install from it
d44 1
d47 1
a47 1
IFS=" ""	$nl"
d49 1
a49 1
# set DOITPROG to echo to test this script
a50 1
# Don't use :- since 4.3BSD and earlier shells don't like it.
d52 1
a52 5
if test -z "$doit"; then
  doit_exec=exec
else
  doit_exec=$doit
fi
a66 11
posix_glob='?'
initialize_posix_glob='
  test "$posix_glob" != "?" || {
    if (set -f) 2>/dev/null; then
      posix_glob=
    else
      posix_glob=:
    fi
  }
'

d85 1
a85 1
no_target_directory=
d125 1
a125 1
	shift;;
d130 6
a135 7
	case $mode in
	  *' '* | *'	'* | *'
'*	  | *'*'* | *'?'* | *'['*)
	    echo "$0: invalid mode: $mode" >&2
	    exit 1;;
	esac
	shift;;
d138 1
a138 1
	shift;;
d142 8
a149 2
    -t) dst_arg=$2
	shift;;
d151 1
a151 1
    -T) no_target_directory=true;;
d155 2
a156 2
    --)	shift
	break;;
d158 2
a159 2
    -*)	echo "$0: invalid option: $1" >&2
	exit 1;;
d166 10
d189 4
d201 1
a201 1
  # It's OK to call `install-sh -d' without argument.
d207 14
a220 1
  trap '(exit $?); exit' 1 2 13 15
d231 1
a231 1
	u_plus_rw=
d233 1
a233 1
	u_plus_rw='% 200'
d238 1
a238 1
	u_plus_rw=
d240 1
a240 1
	u_plus_rw=,u+rw
d248 1
a248 1
  # Protect names starting with `-'.
d250 1
a250 1
    -*) src=./$src;;
a271 1

a272 4
    # Protect names starting with `-'.
    case $dst in
      -*) dst=./$dst;;
    esac
d277 3
a279 3
      if test -n "$no_target_directory"; then
	echo "$0: $dst_arg: Is a directory" >&2
	exit 1
d285 1
a285 27
      # Prefer dirname, but fall back on a substitute if dirname fails.
      dstdir=`
	(dirname "$dst") 2>/dev/null ||
	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	     X"$dst" : 'X\(//\)[^/]' \| \
	     X"$dst" : 'X\(//\)$' \| \
	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
	echo X"$dst" |
	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)[^/].*/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\).*/{
		   s//\1/
		   q
		 }
		 s/.*/./; q'
      `

d296 62
a357 62
	# Create intermediate dirs using mode 755 as modified by the umask.
	# This is like FreeBSD 'install' as of 1997-10-28.
	umask=`umask`
	case $stripcmd.$umask in
	  # Optimize common cases.
	  *[2367][2367]) mkdir_umask=$umask;;
	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

	  *[0-7])
	    mkdir_umask=`expr $umask + 22 \
	      - $umask % 100 % 40 + $umask % 20 \
	      - $umask % 10 % 4 + $umask % 2
	    `;;
	  *) mkdir_umask=$umask,go-w;;
	esac

	# With -d, create the new directory with the user-specified mode.
	# Otherwise, rely on $mkdir_umask.
	if test -n "$dir_arg"; then
	  mkdir_mode=-m$mode
	else
	  mkdir_mode=
	fi

	posix_mkdir=false
	case $umask in
	  *[123567][0-7][0-7])
	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
	    ;;
	  *)
	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

	    if (umask $mkdir_umask &&
		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
	    then
	      if test -z "$dir_arg" || {
		   # Check for POSIX incompatibilities with -m.
		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
		   # other-writeable bit of parent directory when it shouldn't.
		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
		   case $ls_ld_tmpdir in
		     d????-?r-*) different_mode=700;;
		     d????-?--*) different_mode=755;;
		     *) false;;
		   esac &&
		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
		   }
		 }
	      then posix_mkdir=:
	      fi
	      rmdir "$tmpdir/d" "$tmpdir"
	    else
	      # Remove any dirs left behind by ancient mkdir implementations.
	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
	    fi
	    trap '' 0;;
	esac;;
d362 2
a363 2
	umask $mkdir_umask &&
	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
d373 3
a375 3
	/*) prefix='/';;
	-*) prefix='./';;
	*)  prefix='';;
a377 2
      eval "$initialize_posix_glob"

d380 1
a380 1
      $posix_glob set -f
d383 1
a383 1
      $posix_glob set +f
d390 1
a390 1
	test -z "$d" && continue
d392 18
a409 18
	prefix=$prefix$d
	if test -d "$prefix"; then
	  prefixes=
	else
	  if $posix_mkdir; then
	    (umask=$mkdir_umask &&
	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
	    # Don't fail if two instances are running concurrently.
	    test -d "$prefix" || exit 1
	  else
	    case $prefix in
	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
	      *) qprefix=$prefix;;
	    esac
	    prefixes="$prefixes '$qprefix'"
	  fi
	fi
	prefix=$prefix/
d413 5
a417 5
	# Don't fail if two instances are running concurrently.
	(umask $mkdir_umask &&
	 eval "\$doit_exec \$mkdirprog $prefixes") ||
	  test -d "$dstdir" || exit 1
	obsolete_mkdir_used=true
d452 3
a454 5
       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&

       eval "$initialize_posix_glob" &&
       $posix_glob set -f &&
d457 1
a457 2
       $posix_glob set +f &&

d470 15
a484 15
	# Now remove or move aside any old file at destination location.
	# We try this two ways since rm can't unlink itself on some
	# systems and the destination file might be busy for other
	# reasons.  In this case, the final cleanup might fail but the new
	# file should still install successfully.
	{
	  test ! -f "$dst" ||
	  $doit $rmcmd -f "$dst" 2>/dev/null ||
	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
	  } ||
	  { echo "$0: cannot unlink or rename $dst" >&2
	    (exit 1); exit 1
	  }
	} &&
d486 2
a487 2
	# Now rename the file to the real destination.
	$doit $mvcmd "$dsttmp" "$dst"
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d4 1
a4 1
scriptversion=2006-12-25.00
d518 2
a519 1
# time-stamp-end: "$"
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d4 1
a4 1
scriptversion=2006-04-25.22
d42 5
a46 2
# from scratch.  It can only install one file at a time, a restriction
# shared with many OS's install programs.
d51 6
a56 1
doit="${DOITPROG-}"
d58 2
a59 1
# put in absolute paths if you don't have them in your path; or use env. vars.
d61 20
a80 8
mvprog="${MVPROG-mv}"
cpprog="${CPPROG-cp}"
chmodprog="${CHMODPROG-chmod}"
chownprog="${CHOWNPROG-chown}"
chgrpprog="${CHGRPPROG-chgrp}"
stripprog="${STRIPPROG-strip}"
rmprog="${RMPROG-rm}"
mkdirprog="${MKDIRPROG-mkdir}"
a81 1
posix_glob=
a83 4
# Symbolic mode for testing mkdir with directories.
# It is the same as 755, but also tests that "u+" works.
test_mode=u=rwx,g=rx,o=rx,u+wx

d87 1
a87 4
# Desired mode of newly created intermediate directories.
# It is empty if not known yet.
intermediate_mode=

d90 2
a91 1
chgrpcmd=
d93 1
a93 2
rmcmd="$rmprog -f"
mvcmd="$mvprog"
d97 3
a99 1
dstarg=
d102 2
a103 1
usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
d113 12
a124 10
-c         (ignored)
-d         create directories instead of installing files.
-g GROUP   $chgrpprog installed files to GROUP.
-m MODE    $chmodprog installed files to MODE.
-o USER    $chownprog installed files to USER.
-s         $stripprog installed files.
-t DIRECTORY  install into DIRECTORY.
-T         report an error if DSTFILE is a directory.
--help     display this help and exit.
--version  display version info and exit.
d127 2
a128 1
  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
d133 3
a135 2
    -c) shift
        continue;;
d137 1
a137 3
    -d) dir_arg=true
        shift
        continue;;
d140 1
a140 3
        shift
        shift
        continue;;
d145 7
a151 3
        shift
        shift
        continue;;
d154 8
a161 16
        shift
        shift
        continue;;

    -s) stripcmd=$stripprog
        shift
        continue;;

    -t) dstarg=$2
	shift
	shift
	continue;;

    -T) no_target_directory=true
	shift
	continue;;
d173 1
d176 1
a176 1
if test $# -ne 0 && test -z "$dir_arg$dstarg"; then
d182 1
a182 1
    if test -n "$dstarg"; then
d184 1
a184 1
      set fnord "$@@" "$dstarg"
d188 1
a188 1
    dstarg=$arg
d202 26
a227 1
test -n "$dir_arg" || trap '(exit $?); exit' 1 2 13 15
d233 1
a233 1
    -*) src=./$src ;;
d251 1
a251 1
    if test -z "$dstarg"; then
d256 1
a256 1
    dst=$dstarg
d259 1
a259 1
      -*) dst=./$dst ;;
d266 1
a266 1
	echo "$0: $dstarg: Is a directory" >&2
d310 15
a324 11
	posix_mkdir=false
	if $mkdirprog -m $test_mode -p -- / >/dev/null 2>&1; then
	  posix_mkdir=true
	else
	  # Remove any dirs left behind by ancient mkdir implementations.
	  rmdir ./-m "$test_mode" ./-p ./-- 2>/dev/null
	fi ;;
    esac

    if
      $posix_mkdir && {
d327 1
a327 5
	# Otherwise, create it using the same intermediate mode that
	# mkdir -p would use when creating intermediate directories.
	# POSIX says that this mode is "$(umask -S),u+wx", so use that
	# if umask -S works.

d329 1
a329 1
	  mkdir_mode=$mode
d331 1
a331 9
	  case $intermediate_mode in
	    '')
	      if umask_S=`(umask -S) 2>/dev/null`; then
		intermediate_mode=$umask_S,u+wx
	      else
		intermediate_mode=$test_mode
	      fi ;;
	  esac
	  mkdir_mode=$intermediate_mode
d334 45
a378 2
	$mkdirprog -m "$mkdir_mode" -p -- "$dstdir"
      }
d382 3
a384 3
      # mkdir does not conform to POSIX, or it failed possibly due to
      # a race condition.  Create the directory the slow way, step by
      # step, checking for races as we go.
d387 3
a389 3
	/*) pathcomp=/ ;;
	-*) pathcomp=./ ;;
	*)  pathcomp= ;;
d392 1
a392 8
      case $posix_glob in
        '')
	  if (set -f) 2>/dev/null; then
	    posix_glob=true
	  else
	    posix_glob=false
	  fi ;;
      esac
d396 1
a396 1
      $posix_glob && set -f
d399 1
a399 1
      $posix_glob && set +f
d402 2
d406 1
a406 1
	test "x$d" = x && continue
d408 16
a423 5
	pathcomp=$pathcomp$d
	if test ! -d "$pathcomp"; then
	  $mkdirprog "$pathcomp"
	  # Don't fail if two instances are running concurrently.
	  test -d "$pathcomp" || exit 1
d425 1
a425 1
	pathcomp=$pathcomp/
d427 8
a434 1
      obsolete_mkdir_used=true
d442 1
a442 1
      test -z "$chmodcmd" || $doit $chmodcmd "$mode" "$dst"; } || exit 1
d453 1
a453 1
    $doit $cpprog "$src" "$dsttmp" &&
d461 48
a508 35
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$mode" "$dsttmp"; } &&

    # Now rename the file to the real destination.
    { $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null \
      || {
	   # The rename failed, perhaps because mv can't rename something else
	   # to itself, or perhaps because mv is so ancient that it does not
	   # support -f.

	   # Now remove or move aside any old file at destination location.
	   # We try this two ways since rm can't unlink itself on some
	   # systems and the destination file might be busy for other
	   # reasons.  In this case, the final cleanup might fail but the new
	   # file should still install successfully.
	   {
	     if test -f "$dst"; then
	       $doit $rmcmd -f "$dst" 2>/dev/null \
	       || { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null \
		     && { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }; }\
	       || {
		 echo "$0: cannot unlink or rename $dst" >&2
		 (exit 1); exit 1
	       }
	     else
	       :
	     fi
	   } &&

	   # Now rename the file to the real destination.
	   $doit $mvcmd "$dsttmp" "$dst"
	 }
    } || exit 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
scriptversion=2004-02-15.20
d61 15
a75 4
transformbasename=
transform_arg=
instcmd="$mvprog"
chmodcmd="$chmodprog 0755"
d84 2
d87 1
a87 1
usage="Usage: $0 [OPTION]... SRCFILE DSTFILE
d89 2
a90 1
   or: $0 -d DIRECTORIES...
d92 3
a94 2
In the first form, install SRCFILE to DSTFILE, removing SRCFILE by default.
In the second, create the directory path DIR.
d97 1
a97 2
-b=TRANSFORMBASENAME
-c         copy source (using $cpprog) instead of moving (using $mvprog).
d99 6
a104 5
-g GROUP   $chgrp installed files to GROUP.
-m MODE    $chmod installed files to MODE.
-o USER    $chown installed files to USER.
-s         strip installed files (using $stripprog).
-t=TRANSFORM
d112 1
a112 1
while test -n "$1"; do
d114 1
a114 6
    -b=*) transformbasename=`echo $1 | sed 's/-b=//'`
        shift
        continue;;

    -c) instcmd=$cpprog
        shift
d126 1
a126 1
    --help) echo "$usage"; exit 0;;
d128 1
a128 1
    -m) chmodcmd="$chmodprog $2"
d142 8
a149 3
    -t=*) transformarg=`echo $1 | sed 's/-t=//'`
        shift
        continue;;
d151 1
a151 1
    --version) echo "$0 $scriptversion"; exit 0;;
d153 1
a153 13
    *)  # When -d is used, all remaining arguments are directories to create.
	test -n "$dir_arg" && break
        # Otherwise, the last argument is the destination.  Remove it from $@@.
	for arg
	do
          if test -n "$dstarg"; then
	    # $@@ is not empty: it contains at least $arg.
	    set fnord "$@@" "$dstarg"
	    shift # fnord
	  fi
	  shift # arg
	  dstarg=$arg
	done
d155 5
d163 17
a179 1
if test -z "$1"; then
d189 2
d200 4
a203 1
    src=
d205 1
a205 8
    if test -d "$dst"; then
      instcmd=:
      chmodcmd=
    else
      instcmd=$mkdirprog
    fi
  else
    # Waiting for this to be detected by the "$instcmd $src $dsttmp" command
d227 37
a263 1
      dst=$dst/`basename "$src"`
d267 1
a267 2
  # This sed command emulates the dirname command.
  dstdir=`echo "$dst" | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
d269 11
a279 1
  # Make sure that the destination directory exists.
d281 2
a282 11
  # Skip lots of stat calls in the usual case.
  if test ! -d "$dstdir"; then
    defaultIFS='
	 '
    IFS="${IFS-$defaultIFS}"

    oIFS=$IFS
    # Some sh's can't handle IFS=/ for some reason.
    IFS='%'
    set - `echo "$dstdir" | sed -e 's@@/@@%@@g' -e 's@@^%@@/@@'`
    IFS=$oIFS
d284 24
a307 1
    pathcomp=
d309 23
a331 2
    while test $# -ne 0 ; do
      pathcomp=$pathcomp$1
d333 17
a349 9
      if test ! -d "$pathcomp"; then
        $mkdirprog "$pathcomp" || lasterr=$?
	# mkdir can fail with a `File exist' error in case several
	# install-sh are creating the directory concurrently.  This
	# is OK.
	test ! -d "$pathcomp" && { (exit ${lasterr-1}); exit; }
      fi
      pathcomp=$pathcomp/
    done
d353 4
a356 6
    $doit $instcmd "$dst" \
      && { test -z "$chowncmd" || $doit $chowncmd "$dst"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dst"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dst"; }

a357 10
    # If we're going to rename the final executable, determine the name now.
    if test -z "$transformarg"; then
      dstfile=`basename "$dst"`
    else
      dstfile=`basename "$dst" $transformbasename \
               | sed $transformarg`$transformbasename
    fi

    # don't allow the sed command to completely eliminate the filename.
    test -z "$dstfile" && dstfile=`basename "$dst"`
d364 1
a364 2
    trap 'status=$?; rm -f "$dsttmp" "$rmtmp" && exit $status' 0
    trap '(exit $?); exit' 1 2 13 15
d366 2
a367 2
    # Move or copy the file name to the temp name
    $doit $instcmd "$src" "$dsttmp" &&
d373 1
a373 1
    # errors from the above "$doit $instcmd $src $dsttmp" command.
d378 1
a378 1
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dsttmp"; } &&
d380 30
a409 17
    # Now remove or move aside any old file at destination location.  We
    # try this two ways since rm can't unlink itself on some systems and
    # the destination file might be busy for other reasons.  In this case,
    # the final cleanup might fail but the new file should still install
    # successfully.
    {
      if test -f "$dstdir/$dstfile"; then
        $doit $rmcmd -f "$dstdir/$dstfile" 2>/dev/null \
        || $doit $mvcmd -f "$dstdir/$dstfile" "$rmtmp" 2>/dev/null \
        || {
	  echo "$0: cannot unlink or rename $dstdir/$dstfile" >&2
	  (exit 1); exit
        }
      else
        :
      fi
    } &&
d411 2
a412 3
    # Now rename the file to the real destination.
    $doit $mvcmd "$dsttmp" "$dstdir/$dstfile"
  fi || { (exit 1); exit; }
a414 5
# The final little trick to "correctly" pass the exit status to the exit trap.
{
  (exit 0); exit
}

@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d4 1
a4 1
scriptversion=2006-12-25.00
d42 2
a43 5
# from scratch.

nl='
'
IFS=" ""	$nl"
d48 1
a48 6
doit=${DOITPROG-}
if test -z "$doit"; then
  doit_exec=exec
else
  doit_exec=$doit
fi
d50 1
a50 28
# Put in absolute file names if you don't have them in your path;
# or use environment vars.

chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_glob='?'
initialize_posix_glob='
  test "$posix_glob" != "?" || {
    if (set -f) 2>/dev/null; then
      posix_glob=
    else
      posix_glob=:
    fi
  }
'

posix_mkdir=

# Desired mode of installed file.
mode=0755
d52 14
d67 1
a67 3
chmodcmd=$chmodprog
chowncmd=
mvcmd=$mvprog
d69 1
a69 2
stripcmd=

a72 1
dst_arg=
d74 1
a74 5
copy_on_change=false
no_target_directory=

usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
d76 1
a76 2
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...
d78 2
a79 3
In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.
d82 10
a91 12
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.
d94 1
a94 2
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
d97 1
a97 1
while test $# -ne 0; do
d99 11
a109 5
    -c) ;;

    -C) copy_on_change=true;;

    -d) dir_arg=true;;
d112 10
a121 12
	shift;;

    --help) echo "$usage"; exit $?;;

    -m) mode=$2
	case $mode in
	  *' '* | *'	'* | *'
'*	  | *'*'* | *'?'* | *'['*)
	    echo "$0: invalid mode: $mode" >&2
	    exit 1;;
	esac
	shift;;
d124 27
a150 12
	shift;;

    -s) stripcmd=$stripprog;;

    -t) dst_arg=$2
	shift;;

    -T) no_target_directory=true;;

    --version) echo "$0 $scriptversion"; exit $?;;

    --)	shift
a151 5

    -*)	echo "$0: invalid option: $1" >&2
	exit 1;;

    *)  break;;
a152 1
  shift
d155 1
a155 17
if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@@.
  for arg
  do
    if test -n "$dst_arg"; then
      # $@@ is not empty: it contains at least $arg.
      set fnord "$@@" "$dst_arg"
      shift # fnord
    fi
    shift # arg
    dst_arg=$arg
  done
fi

if test $# -eq 0; then
a164 27
if test -z "$dir_arg"; then
  trap '(exit $?); exit' 1 2 13 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi

d169 1
a169 1
    -*) src=./$src;;
d174 8
a181 3
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
d183 1
a183 2

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
d191 1
a191 1
    if test -z "$dst_arg"; then
d196 1
a196 1
    dst=$dst_arg
d199 1
a199 1
      -*) dst=./$dst;;
d205 1
a205 37
      if test -n "$no_target_directory"; then
	echo "$0: $dst_arg: Is a directory" >&2
	exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      # Prefer dirname, but fall back on a substitute if dirname fails.
      dstdir=`
	(dirname "$dst") 2>/dev/null ||
	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	     X"$dst" : 'X\(//\)[^/]' \| \
	     X"$dst" : 'X\(//\)$' \| \
	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
	echo X"$dst" |
	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)[^/].*/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\).*/{
		   s//\1/
		   q
		 }
		 s/.*/./; q'
      `

      test -d "$dstdir"
      dstdir_status=$?
d209 2
a210 1
  obsolete_mkdir_used=false
d212 13
a224 66
  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
	# Create intermediate dirs using mode 755 as modified by the umask.
	# This is like FreeBSD 'install' as of 1997-10-28.
	umask=`umask`
	case $stripcmd.$umask in
	  # Optimize common cases.
	  *[2367][2367]) mkdir_umask=$umask;;
	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

	  *[0-7])
	    mkdir_umask=`expr $umask + 22 \
	      - $umask % 100 % 40 + $umask % 20 \
	      - $umask % 10 % 4 + $umask % 2
	    `;;
	  *) mkdir_umask=$umask,go-w;;
	esac

	# With -d, create the new directory with the user-specified mode.
	# Otherwise, rely on $mkdir_umask.
	if test -n "$dir_arg"; then
	  mkdir_mode=-m$mode
	else
	  mkdir_mode=
	fi

	posix_mkdir=false
	case $umask in
	  *[123567][0-7][0-7])
	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
	    ;;
	  *)
	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

	    if (umask $mkdir_umask &&
		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
	    then
	      if test -z "$dir_arg" || {
		   # Check for POSIX incompatibilities with -m.
		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
		   # other-writeable bit of parent directory when it shouldn't.
		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
		   case $ls_ld_tmpdir in
		     d????-?r-*) different_mode=700;;
		     d????-?--*) different_mode=755;;
		     *) false;;
		   esac &&
		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
		   }
		 }
	      then posix_mkdir=:
	      fi
	      rmdir "$tmpdir/d" "$tmpdir"
	    else
	      # Remove any dirs left behind by ancient mkdir implementations.
	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
	    fi
	    trap '' 0;;
	esac;;
    esac
d226 1
a226 7
    if
      $posix_mkdir && (
	umask $mkdir_umask &&
	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
    then :
    else
d228 2
a229 16
      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.

      case $dstdir in
	/*) prefix='/';;
	-*) prefix='./';;
	*)  prefix='';;
      esac

      eval "$initialize_posix_glob"

      oIFS=$IFS
      IFS=/
      $posix_glob set -f
      set fnord $dstdir
d231 6
a236 35
      $posix_glob set +f
      IFS=$oIFS

      prefixes=

      for d
      do
	test -z "$d" && continue

	prefix=$prefix$d
	if test -d "$prefix"; then
	  prefixes=
	else
	  if $posix_mkdir; then
	    (umask=$mkdir_umask &&
	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
	    # Don't fail if two instances are running concurrently.
	    test -d "$prefix" || exit 1
	  else
	    case $prefix in
	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
	      *) qprefix=$prefix;;
	    esac
	    prefixes="$prefixes '$qprefix'"
	  fi
	fi
	prefix=$prefix/
      done

      if test -n "$prefixes"; then
	# Don't fail if two instances are running concurrently.
	(umask $mkdir_umask &&
	 eval "\$doit_exec \$mkdirprog $prefixes") ||
	  test -d "$dstdir" || exit 1
	obsolete_mkdir_used=true
d238 2
a239 1
    fi
d243 6
a248 4
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
d250 10
d266 2
a267 1
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
d269 2
a270 2
    # Copy the file name to the temp name.
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
d276 1
a276 1
    # errors from the above "$doit $cpprog $src $dsttmp" command.
d278 22
a299 23
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&

       eval "$initialize_posix_glob" &&
       $posix_glob set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       $posix_glob set +f &&

       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
d301 4
a304 24
      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
	# Now remove or move aside any old file at destination location.
	# We try this two ways since rm can't unlink itself on some
	# systems and the destination file might be busy for other
	# reasons.  In this case, the final cleanup might fail but the new
	# file should still install successfully.
	{
	  test ! -f "$dst" ||
	  $doit $rmcmd -f "$dst" 2>/dev/null ||
	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
	  } ||
	  { echo "$0: cannot unlink or rename $dst" >&2
	    (exit 1); exit 1
	  }
	} &&

	# Now rename the file to the real destination.
	$doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1
d306 4
a309 3
    trap '' 0
  fi
done
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d4 1
a4 1
scriptversion=2006-04-25.22
d61 4
a64 15
posix_glob=
posix_mkdir=

# Symbolic mode for testing mkdir with directories.
# It is the same as 755, but also tests that "u+" works.
test_mode=u=rwx,g=rx,o=rx,u+wx

# Desired mode of installed file.
mode=0755

# Desired mode of newly created intermediate directories.
# It is empty if not known yet.
intermediate_mode=

chmodcmd=$chmodprog
a72 2
dstarg=
no_target_directory=
d74 1
a74 1
usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
d76 1
a76 2
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...
d78 2
a79 3
In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.
d82 2
a83 1
-c         (ignored)
d85 5
a89 6
-g GROUP   $chgrpprog installed files to GROUP.
-m MODE    $chmodprog installed files to MODE.
-o USER    $chownprog installed files to USER.
-s         $stripprog installed files.
-t DIRECTORY  install into DIRECTORY.
-T         report an error if DSTFILE is a directory.
d97 1
a97 1
while test $# -ne 0; do
d99 6
a104 1
    -c) shift
d116 1
a116 1
    --help) echo "$usage"; exit $?;;
d118 1
a118 1
    -m) mode=$2
d132 3
a134 8
    -t) dstarg=$2
	shift
	shift
	continue;;

    -T) no_target_directory=true
	shift
	continue;;
d136 1
a136 1
    --version) echo "$0 $scriptversion"; exit $?;;
d138 13
a150 1
    --)	shift
a151 5

    -*)	echo "$0: invalid option: $1" >&2
	exit 1;;

    *)  break;;
d155 1
a155 17
if test $# -ne 0 && test -z "$dir_arg$dstarg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@@.
  for arg
  do
    if test -n "$dstarg"; then
      # $@@ is not empty: it contains at least $arg.
      set fnord "$@@" "$dstarg"
      shift # fnord
    fi
    shift # arg
    dstarg=$arg
  done
fi

if test $# -eq 0; then
a164 2
test -n "$dir_arg" || trap '(exit $?); exit' 1 2 13 15

d174 8
a181 3
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
d183 1
a183 2

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
d205 1
a205 37
      if test -n "$no_target_directory"; then
	echo "$0: $dstarg: Is a directory" >&2
	exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      # Prefer dirname, but fall back on a substitute if dirname fails.
      dstdir=`
	(dirname "$dst") 2>/dev/null ||
	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	     X"$dst" : 'X\(//\)[^/]' \| \
	     X"$dst" : 'X\(//\)$' \| \
	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
	echo X"$dst" |
	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)[^/].*/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\).*/{
		   s//\1/
		   q
		 }
		 s/.*/./; q'
      `

      test -d "$dstdir"
      dstdir_status=$?
d209 2
a210 1
  obsolete_mkdir_used=false
d212 1
a212 11
  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
	posix_mkdir=false
	if $mkdirprog -m $test_mode -p -- / >/dev/null 2>&1; then
	  posix_mkdir=true
	else
	  # Remove any dirs left behind by ancient mkdir implementations.
	  rmdir ./-m "$test_mode" ./-p ./-- 2>/dev/null
	fi ;;
    esac
d214 11
a224 2
    if
      $posix_mkdir && {
d226 1
a226 24
	# With -d, create the new directory with the user-specified mode.
	# Otherwise, create it using the same intermediate mode that
	# mkdir -p would use when creating intermediate directories.
	# POSIX says that this mode is "$(umask -S),u+wx", so use that
	# if umask -S works.

	if test -n "$dir_arg"; then
	  mkdir_mode=$mode
	else
	  case $intermediate_mode in
	    '')
	      if umask_S=`(umask -S) 2>/dev/null`; then
		intermediate_mode=$umask_S,u+wx
	      else
		intermediate_mode=$test_mode
	      fi ;;
	  esac
	  mkdir_mode=$intermediate_mode
	fi

	$mkdirprog -m "$mkdir_mode" -p -- "$dstdir"
      }
    then :
    else
d228 2
a229 23
      # mkdir does not conform to POSIX, or it failed possibly due to
      # a race condition.  Create the directory the slow way, step by
      # step, checking for races as we go.

      case $dstdir in
	/*) pathcomp=/ ;;
	-*) pathcomp=./ ;;
	*)  pathcomp= ;;
      esac

      case $posix_glob in
        '')
	  if (set -f) 2>/dev/null; then
	    posix_glob=true
	  else
	    posix_glob=false
	  fi ;;
      esac

      oIFS=$IFS
      IFS=/
      $posix_glob && set -f
      set fnord $dstdir
d231 9
a239 17
      $posix_glob && set +f
      IFS=$oIFS

      for d
      do
	test "x$d" = x && continue

	pathcomp=$pathcomp$d
	if test ! -d "$pathcomp"; then
	  $mkdirprog "$pathcomp"
	  # Don't fail if two instances are running concurrently.
	  test -d "$pathcomp" || exit 1
	fi
	pathcomp=$pathcomp/
      done
      obsolete_mkdir_used=true
    fi
d243 6
a248 4
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd "$mode" "$dst"; } || exit 1
d250 10
d266 2
a267 1
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
d269 2
a270 2
    # Copy the file name to the temp name.
    $doit $cpprog "$src" "$dsttmp" &&
d276 1
a276 1
    # errors from the above "$doit $cpprog $src $dsttmp" command.
d281 19
a299 1
      && { test -z "$chmodcmd" || $doit $chmodcmd "$mode" "$dsttmp"; } &&
d302 3
a304 29
    { $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null \
      || {
	   # The rename failed, perhaps because mv can't rename something else
	   # to itself, or perhaps because mv is so ancient that it does not
	   # support -f.

	   # Now remove or move aside any old file at destination location.
	   # We try this two ways since rm can't unlink itself on some
	   # systems and the destination file might be busy for other
	   # reasons.  In this case, the final cleanup might fail but the new
	   # file should still install successfully.
	   {
	     if test -f "$dst"; then
	       $doit $rmcmd -f "$dst" 2>/dev/null \
	       || { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null \
		     && { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }; }\
	       || {
		 echo "$0: cannot unlink or rename $dst" >&2
		 (exit 1); exit 1
	       }
	     else
	       :
	     fi
	   } &&

	   # Now rename the file to the real destination.
	   $doit $mvcmd "$dsttmp" "$dst"
	 }
    } || exit 1
d306 4
a309 3
    trap '' 0
  fi
done
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d4 1
a4 1
scriptversion=2009-04-28.21; # UTC
d42 2
a43 5
# from scratch.

nl='
'
IFS=" ""	$nl"
d48 1
a48 6
doit=${DOITPROG-}
if test -z "$doit"; then
  doit_exec=exec
else
  doit_exec=$doit
fi
d50 1
a50 2
# Put in absolute file names if you don't have them in your path;
# or use environment vars.
d52 8
a59 20
chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_glob='?'
initialize_posix_glob='
  test "$posix_glob" != "?" || {
    if (set -f) 2>/dev/null; then
      posix_glob=
    else
      posix_glob=:
    fi
  }
'
d61 1
d64 4
d71 4
a74 1
chgrpcmd=
d77 2
a78 1
mvcmd=$mvprog
d80 1
a80 2
stripcmd=

d84 1
a84 3
dst_arg=

copy_on_change=false
d87 1
a87 2
usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
d97 10
a106 12
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.
d109 1
a109 2
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
d114 2
a115 3
    -c) ;;

    -C) copy_on_change=true;;
d117 3
a119 1
    -d) dir_arg=true;;
d122 3
a124 1
	shift;;
d129 3
a131 7
	case $mode in
	  *' '* | *'	'* | *'
'*	  | *'*'* | *'?'* | *'['*)
	    echo "$0: invalid mode: $mode" >&2
	    exit 1;;
	esac
	shift;;
d134 16
a149 8
	shift;;

    -s) stripcmd=$stripprog;;

    -t) dst_arg=$2
	shift;;

    -T) no_target_directory=true;;
a160 1
  shift
d163 1
a163 1
if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
d169 1
a169 1
    if test -n "$dst_arg"; then
d171 1
a171 1
      set fnord "$@@" "$dst_arg"
d175 1
a175 1
    dst_arg=$arg
d189 1
a189 26
if test -z "$dir_arg"; then
  trap '(exit $?); exit' 1 2 13 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi
d195 1
a195 1
    -*) src=./$src;;
d213 1
a213 1
    if test -z "$dst_arg"; then
d218 1
a218 1
    dst=$dst_arg
d221 1
a221 1
      -*) dst=./$dst;;
d228 1
a228 1
	echo "$0: $dst_arg: Is a directory" >&2
d272 11
a282 15
	# Create intermediate dirs using mode 755 as modified by the umask.
	# This is like FreeBSD 'install' as of 1997-10-28.
	umask=`umask`
	case $stripcmd.$umask in
	  # Optimize common cases.
	  *[2367][2367]) mkdir_umask=$umask;;
	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

	  *[0-7])
	    mkdir_umask=`expr $umask + 22 \
	      - $umask % 100 % 40 + $umask % 20 \
	      - $umask % 10 % 4 + $umask % 2
	    `;;
	  *) mkdir_umask=$umask,go-w;;
	esac
d285 5
a289 1
	# Otherwise, rely on $mkdir_umask.
d291 1
a291 1
	  mkdir_mode=-m$mode
d293 9
a301 1
	  mkdir_mode=
d304 2
a305 45
	posix_mkdir=false
	case $umask in
	  *[123567][0-7][0-7])
	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
	    ;;
	  *)
	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

	    if (umask $mkdir_umask &&
		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
	    then
	      if test -z "$dir_arg" || {
		   # Check for POSIX incompatibilities with -m.
		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
		   # other-writeable bit of parent directory when it shouldn't.
		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
		   case $ls_ld_tmpdir in
		     d????-?r-*) different_mode=700;;
		     d????-?--*) different_mode=755;;
		     *) false;;
		   esac &&
		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
		   }
		 }
	      then posix_mkdir=:
	      fi
	      rmdir "$tmpdir/d" "$tmpdir"
	    else
	      # Remove any dirs left behind by ancient mkdir implementations.
	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
	    fi
	    trap '' 0;;
	esac;;
    esac

    if
      $posix_mkdir && (
	umask $mkdir_umask &&
	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
d309 3
a311 3
      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.
d314 3
a316 3
	/*) prefix='/';;
	-*) prefix='./';;
	*)  prefix='';;
d319 8
a326 1
      eval "$initialize_posix_glob"
d330 1
a330 1
      $posix_glob set -f
d333 1
a333 1
      $posix_glob set +f
a335 2
      prefixes=

d338 1
a338 1
	test -z "$d" && continue
d340 5
a344 16
	prefix=$prefix$d
	if test -d "$prefix"; then
	  prefixes=
	else
	  if $posix_mkdir; then
	    (umask=$mkdir_umask &&
	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
	    # Don't fail if two instances are running concurrently.
	    test -d "$prefix" || exit 1
	  else
	    case $prefix in
	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
	      *) qprefix=$prefix;;
	    esac
	    prefixes="$prefixes '$qprefix'"
	  fi
d346 1
a346 1
	prefix=$prefix/
d348 1
a348 8

      if test -n "$prefixes"; then
	# Don't fail if two instances are running concurrently.
	(umask $mkdir_umask &&
	 eval "\$doit_exec \$mkdirprog $prefixes") ||
	  test -d "$dstdir" || exit 1
	obsolete_mkdir_used=true
      fi
d356 1
a356 1
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
d367 1
a367 1
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
d375 35
a409 48
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&

       eval "$initialize_posix_glob" &&
       $posix_glob set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       $posix_glob set +f &&

       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||

      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
	# Now remove or move aside any old file at destination location.
	# We try this two ways since rm can't unlink itself on some
	# systems and the destination file might be busy for other
	# reasons.  In this case, the final cleanup might fail but the new
	# file should still install successfully.
	{
	  test ! -f "$dst" ||
	  $doit $rmcmd -f "$dst" 2>/dev/null ||
	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
	  } ||
	  { echo "$0: cannot unlink or rename $dst" >&2
	    (exit 1); exit 1
	  }
	} &&

	# Now rename the file to the real destination.
	$doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1
d419 1
a419 2
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
@


1.1.115.4
log
@lets see whether we cant update freetype2 as well
@
text
@d4 1
a4 1
scriptversion=2013-12-25.23; # UTC
d38 1
a38 1
# 'make' implicit rules from creating a file called install from it
a43 1
tab='	'
d46 1
a46 1
IFS=" $tab$nl"
d48 1
a48 1
# Set DOITPROG to "echo" to test this script.
d50 1
d52 5
a56 1
doit_exec=${doit:-exec}
d71 11
d100 1
a100 1
is_target_a_directory=possibly
d140 1
a140 1
        shift;;
d145 7
a151 6
        case $mode in
          *' '* | *"$tab"* | *"$nl"* | *'*'* | *'?'* | *'['*)
            echo "$0: invalid mode: $mode" >&2
            exit 1;;
        esac
        shift;;
d154 1
a154 1
        shift;;
d158 2
a159 8
    -t)
        is_target_a_directory=always
        dst_arg=$2
        # Protect names problematic for 'test' and other utilities.
        case $dst_arg in
          -* | [=\(\)!]) dst_arg=./$dst_arg;;
        esac
        shift;;
d161 1
a161 1
    -T) is_target_a_directory=never;;
d165 2
a166 2
    --) shift
        break;;
d168 2
a169 2
    -*) echo "$0: invalid option: $1" >&2
        exit 1;;
a175 10
# We allow the use of options -d and -T together, by making -d
# take the precedence; this is for compatibility with GNU install.

if test -n "$dir_arg"; then
  if test -n "$dst_arg"; then
    echo "$0: target directory not allowed when installing a directory." >&2
    exit 1
  fi
fi

a188 4
    # Protect names problematic for 'test' and other utilities.
    case $dst_arg in
      -* | [=\(\)!]) dst_arg=./$dst_arg;;
    esac
d197 1
a197 1
  # It's OK to call 'install-sh -d' without argument.
d203 1
a203 14
  if test $# -gt 1 || test "$is_target_a_directory" = always; then
    if test ! -d "$dst_arg"; then
      echo "$0: $dst_arg: Is not a directory." >&2
      exit 1
    fi
  fi
fi

if test -z "$dir_arg"; then
  do_exit='(exit $ret); exit $ret'
  trap "ret=129; $do_exit" 1
  trap "ret=130; $do_exit" 2
  trap "ret=141; $do_exit" 13
  trap "ret=143; $do_exit" 15
d214 1
a214 1
        u_plus_rw=
d216 1
a216 1
        u_plus_rw='% 200'
d221 1
a221 1
        u_plus_rw=
d223 1
a223 1
        u_plus_rw=,u+rw
d231 1
a231 1
  # Protect names problematic for 'test' and other utilities.
d233 1
a233 1
    -* | [=\(\)!]) src=./$src;;
d255 1
d257 4
d265 3
a267 3
      if test "$is_target_a_directory" = never; then
        echo "$0: $dst_arg: Is a directory" >&2
        exit 1
d273 27
a299 1
      dstdir=`dirname "$dst"`
d310 62
a371 62
        # Create intermediate dirs using mode 755 as modified by the umask.
        # This is like FreeBSD 'install' as of 1997-10-28.
        umask=`umask`
        case $stripcmd.$umask in
          # Optimize common cases.
          *[2367][2367]) mkdir_umask=$umask;;
          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

          *[0-7])
            mkdir_umask=`expr $umask + 22 \
              - $umask % 100 % 40 + $umask % 20 \
              - $umask % 10 % 4 + $umask % 2
            `;;
          *) mkdir_umask=$umask,go-w;;
        esac

        # With -d, create the new directory with the user-specified mode.
        # Otherwise, rely on $mkdir_umask.
        if test -n "$dir_arg"; then
          mkdir_mode=-m$mode
        else
          mkdir_mode=
        fi

        posix_mkdir=false
        case $umask in
          *[123567][0-7][0-7])
            # POSIX mkdir -p sets u+wx bits regardless of umask, which
            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
            ;;
          *)
            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
            trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

            if (umask $mkdir_umask &&
                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
            then
              if test -z "$dir_arg" || {
                   # Check for POSIX incompatibilities with -m.
                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
                   # other-writable bit of parent directory when it shouldn't.
                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
                   ls_ld_tmpdir=`ls -ld "$tmpdir"`
                   case $ls_ld_tmpdir in
                     d????-?r-*) different_mode=700;;
                     d????-?--*) different_mode=755;;
                     *) false;;
                   esac &&
                   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
                     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
                     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
                   }
                 }
              then posix_mkdir=:
              fi
              rmdir "$tmpdir/d" "$tmpdir"
            else
              # Remove any dirs left behind by ancient mkdir implementations.
              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
            fi
            trap '' 0;;
        esac;;
d376 2
a377 2
        umask $mkdir_umask &&
        $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
d387 3
a389 3
        /*) prefix='/';;
        [-=\(\)!]*) prefix='./';;
        *)  prefix='';;
d392 2
d396 1
a396 1
      set -f
d399 1
a399 1
      set +f
d406 1
a406 1
        test X"$d" = X && continue
d408 18
a425 18
        prefix=$prefix$d
        if test -d "$prefix"; then
          prefixes=
        else
          if $posix_mkdir; then
            (umask=$mkdir_umask &&
             $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
            # Don't fail if two instances are running concurrently.
            test -d "$prefix" || exit 1
          else
            case $prefix in
              *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
              *) qprefix=$prefix;;
            esac
            prefixes="$prefixes '$qprefix'"
          fi
        fi
        prefix=$prefix/
d429 5
a433 5
        # Don't fail if two instances are running concurrently.
        (umask $mkdir_umask &&
         eval "\$doit_exec \$mkdirprog $prefixes") ||
          test -d "$dstdir" || exit 1
        obsolete_mkdir_used=true
d468 5
a472 3
       old=`LC_ALL=C ls -dlL "$dst"     2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"  2>/dev/null` &&
       set -f &&
d475 2
a476 1
       set +f &&
d489 15
a503 15
        # Now remove or move aside any old file at destination location.
        # We try this two ways since rm can't unlink itself on some
        # systems and the destination file might be busy for other
        # reasons.  In this case, the final cleanup might fail but the new
        # file should still install successfully.
        {
          test ! -f "$dst" ||
          $doit $rmcmd -f "$dst" 2>/dev/null ||
          { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
            { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
          } ||
          { echo "$0: cannot unlink or rename $dst" >&2
            (exit 1); exit 1
          }
        } &&
d505 2
a506 2
        # Now rename the file to the real destination.
        $doit $mvcmd "$dsttmp" "$dst"
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
