head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.21.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2008.06.12.20.54.41;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.02;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.58;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.13;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.38;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.37.51;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.13;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.31;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.36.54;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.25;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.12;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  pfrgload.c                                                             */
/*                                                                         */
/*    FreeType PFR glyph loader (body).                                    */
/*                                                                         */
/*  Copyright 2002-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include "pfrgload.h"
#include "pfrsbit.h"
#include "pfrload.h"            /* for macro definitions */
#include FT_INTERNAL_DEBUG_H

#include "pfrerror.h"

#undef  FT_COMPONENT
#define FT_COMPONENT  trace_pfr


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                      PFR GLYPH BUILDER                        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  FT_LOCAL_DEF( void )
  pfr_glyph_init( PFR_Glyph       glyph,
                  FT_GlyphLoader  loader )
  {
    FT_ZERO( glyph );

    glyph->loader     = loader;
    glyph->path_begun = 0;

    FT_GlyphLoader_Rewind( loader );
  }


  FT_LOCAL_DEF( void )
  pfr_glyph_done( PFR_Glyph  glyph )
  {
    FT_Memory  memory = glyph->loader->memory;


    FT_FREE( glyph->x_control );
    glyph->y_control = NULL;

    glyph->max_xy_control = 0;
#if 0
    glyph->num_x_control  = 0;
    glyph->num_y_control  = 0;
#endif

    FT_FREE( glyph->subs );

    glyph->max_subs = 0;
    glyph->num_subs = 0;

    glyph->loader     = NULL;
    glyph->path_begun = 0;
  }


  /* close current contour, if any */
  static void
  pfr_glyph_close_contour( PFR_Glyph  glyph )
  {
    FT_GlyphLoader  loader  = glyph->loader;
    FT_Outline*     outline = &loader->current.outline;
    FT_Int          last, first;


    if ( !glyph->path_begun )
      return;

    /* compute first and last point indices in current glyph outline */
    last  = outline->n_points - 1;
    first = 0;
    if ( outline->n_contours > 0 )
      first = outline->contours[outline->n_contours - 1];

    /* if the last point falls on the same location as the first one */
    /* we need to delete it                                          */
    if ( last > first )
    {
      FT_Vector*  p1 = outline->points + first;
      FT_Vector*  p2 = outline->points + last;


      if ( p1->x == p2->x && p1->y == p2->y )
      {
        outline->n_points--;
        last--;
      }
    }

    /* don't add empty contours */
    if ( last >= first )
      outline->contours[outline->n_contours++] = (short)last;

    glyph->path_begun = 0;
  }


  /* reset glyph to start the loading of a new glyph */
  static void
  pfr_glyph_start( PFR_Glyph  glyph )
  {
    glyph->path_begun = 0;
  }


  static FT_Error
  pfr_glyph_line_to( PFR_Glyph   glyph,
                     FT_Vector*  to )
  {
    FT_GlyphLoader  loader  = glyph->loader;
    FT_Outline*     outline = &loader->current.outline;
    FT_Error        error;


    /* check that we have begun a new path */
    if ( !glyph->path_begun )
    {
      error = FT_THROW( Invalid_Table );
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }

    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 0 );
    if ( !error )
    {
      FT_Int  n = outline->n_points;


      outline->points[n] = *to;
      outline->tags  [n] = FT_CURVE_TAG_ON;

      outline->n_points++;
    }

  Exit:
    return error;
  }


  static FT_Error
  pfr_glyph_curve_to( PFR_Glyph   glyph,
                      FT_Vector*  control1,
                      FT_Vector*  control2,
                      FT_Vector*  to )
  {
    FT_GlyphLoader  loader  = glyph->loader;
    FT_Outline*     outline = &loader->current.outline;
    FT_Error        error;


    /* check that we have begun a new path */
    if ( !glyph->path_begun )
    {
      error = FT_THROW( Invalid_Table );
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }

    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 3, 0 );
    if ( !error )
    {
      FT_Vector*  vec = outline->points         + outline->n_points;
      FT_Byte*    tag = (FT_Byte*)outline->tags + outline->n_points;


      vec[0] = *control1;
      vec[1] = *control2;
      vec[2] = *to;
      tag[0] = FT_CURVE_TAG_CUBIC;
      tag[1] = FT_CURVE_TAG_CUBIC;
      tag[2] = FT_CURVE_TAG_ON;

      outline->n_points = (FT_Short)( outline->n_points + 3 );
    }

  Exit:
    return error;
  }


  static FT_Error
  pfr_glyph_move_to( PFR_Glyph   glyph,
                     FT_Vector*  to )
  {
    FT_GlyphLoader  loader  = glyph->loader;
    FT_Error        error;


    /* close current contour if any */
    pfr_glyph_close_contour( glyph );

    /* indicate that a new contour has started */
    glyph->path_begun = 1;

    /* check that there is space for a new contour and a new point */
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 1 );
    if ( !error )
    {
      /* add new start point */
      error = pfr_glyph_line_to( glyph, to );
    }

    return error;
  }


  static void
  pfr_glyph_end( PFR_Glyph  glyph )
  {
    /* close current contour if any */
    pfr_glyph_close_contour( glyph );

    /* merge the current glyph into the stack */
    FT_GlyphLoader_Add( glyph->loader );
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                      PFR GLYPH LOADER                         *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* load a simple glyph */
  static FT_Error
  pfr_glyph_load_simple( PFR_Glyph  glyph,
                         FT_Byte*   p,
                         FT_Byte*   limit )
  {
    FT_Error   error  = FT_Err_Ok;
    FT_Memory  memory = glyph->loader->memory;
    FT_UInt    flags, x_count, y_count, i, count, mask;
    FT_Int     x;


    PFR_CHECK( 1 );
    flags = PFR_NEXT_BYTE( p );

    /* test for composite glyphs */
    if ( flags & PFR_GLYPH_IS_COMPOUND )
      goto Failure;

    x_count = 0;
    y_count = 0;

    if ( flags & PFR_GLYPH_1BYTE_XYCOUNT )
    {
      PFR_CHECK( 1 );
      count   = PFR_NEXT_BYTE( p );
      x_count = count & 15;
      y_count = count >> 4;
    }
    else
    {
      if ( flags & PFR_GLYPH_XCOUNT )
      {
        PFR_CHECK( 1 );
        x_count = PFR_NEXT_BYTE( p );
      }

      if ( flags & PFR_GLYPH_YCOUNT )
      {
        PFR_CHECK( 1 );
        y_count = PFR_NEXT_BYTE( p );
      }
    }

    count = x_count + y_count;

    /* re-allocate array when necessary */
    if ( count > glyph->max_xy_control )
    {
      FT_UInt  new_max = FT_PAD_CEIL( count, 8 );


      if ( FT_RENEW_ARRAY( glyph->x_control,
                           glyph->max_xy_control,
                           new_max ) )
        goto Exit;

      glyph->max_xy_control = new_max;
    }

    glyph->y_control = glyph->x_control + x_count;

    mask = 0;
    x    = 0;

    for ( i = 0; i < count; i++ )
    {
      if ( ( i & 7 ) == 0 )
      {
        PFR_CHECK( 1 );
        mask = PFR_NEXT_BYTE( p );
      }

      if ( mask & 1 )
      {
        PFR_CHECK( 2 );
        x = PFR_NEXT_SHORT( p );
      }
      else
      {
        PFR_CHECK( 1 );
        x += PFR_NEXT_BYTE( p );
      }

      glyph->x_control[i] = x;

      mask >>= 1;
    }

    /* XXX: we ignore the secondary stroke and edge definitions */
    /*      since we don't support native PFR hinting           */
    /*                                                          */
    if ( flags & PFR_GLYPH_SINGLE_EXTRA_ITEMS )
    {
      error = pfr_extra_items_skip( &p, limit );
      if ( error )
        goto Exit;
    }

    pfr_glyph_start( glyph );

    /* now load a simple glyph */
    {
      FT_Vector   pos[4];
      FT_Vector*  cur;


      pos[0].x = pos[0].y = 0;
      pos[3]   = pos[0];

      for (;;)
      {
        FT_UInt  format, format_low, args_format = 0, args_count, n;


        /***************************************************************/
        /*  read instruction                                           */
        /*                                                             */
        PFR_CHECK( 1 );
        format     = PFR_NEXT_BYTE( p );
        format_low = format & 15;

        switch ( format >> 4 )
        {
        case 0:                                               /* end glyph */
          FT_TRACE6(( "- end glyph" ));
          args_count = 0;
          break;

        case 1:                                  /* general line operation */
          FT_TRACE6(( "- general line" ));
          goto Line1;

        case 4:                                 /* move to inside contour  */
          FT_TRACE6(( "- move to inside" ));
          goto Line1;

        case 5:                                 /* move to outside contour */
          FT_TRACE6(( "- move to outside" ));
        Line1:
          args_format = format_low;
          args_count  = 1;
          break;

        case 2:                                      /* horizontal line to */
          FT_TRACE6(( "- horizontal line to cx.%d", format_low ));
          if ( format_low >= x_count )
            goto Failure;
          pos[0].x   = glyph->x_control[format_low];
          pos[0].y   = pos[3].y;
          pos[3]     = pos[0];
          args_count = 0;
          break;

        case 3:                                        /* vertical line to */
          FT_TRACE6(( "- vertical line to cy.%d", format_low ));
          if ( format_low >= y_count )
            goto Failure;
          pos[0].x   = pos[3].x;
          pos[0].y   = glyph->y_control[format_low];
          pos[3]     = pos[0];
          args_count = 0;
          break;

        case 6:                            /* horizontal to vertical curve */
          FT_TRACE6(( "- hv curve " ));
          args_format = 0xB8E;
          args_count  = 3;
          break;

        case 7:                            /* vertical to horizontal curve */
          FT_TRACE6(( "- vh curve" ));
          args_format = 0xE2B;
          args_count  = 3;
          break;

        default:                                       /* general curve to */
          FT_TRACE6(( "- general curve" ));
          args_count  = 4;
          args_format = format_low;
        }

        /***********************************************************/
        /*  now read arguments                                     */
        /*                                                         */
        cur = pos;
        for ( n = 0; n < args_count; n++ )
        {
          FT_UInt  idx;
          FT_Int   delta;


          /* read the X argument */
          switch ( args_format & 3 )
          {
          case 0:                           /* 8-bit index */
            PFR_CHECK( 1 );
            idx = PFR_NEXT_BYTE( p );
            if ( idx >= x_count )
              goto Failure;
            cur->x = glyph->x_control[idx];
            FT_TRACE7(( " cx#%d", idx ));
            break;

          case 1:                           /* 16-bit absolute value */
            PFR_CHECK( 2 );
            cur->x = PFR_NEXT_SHORT( p );
            FT_TRACE7(( " x.%d", cur->x ));
            break;

          case 2:                           /* 8-bit delta */
            PFR_CHECK( 1 );
            delta  = PFR_NEXT_INT8( p );
            cur->x = pos[3].x + delta;
            FT_TRACE7(( " dx.%d", delta ));
            break;

          default:
            FT_TRACE7(( " |" ));
            cur->x = pos[3].x;
          }

          /* read the Y argument */
          switch ( ( args_format >> 2 ) & 3 )
          {
          case 0:                           /* 8-bit index */
            PFR_CHECK( 1 );
            idx  = PFR_NEXT_BYTE( p );
            if ( idx >= y_count )
              goto Failure;
            cur->y = glyph->y_control[idx];
            FT_TRACE7(( " cy#%d", idx ));
            break;

          case 1:                           /* 16-bit absolute value */
            PFR_CHECK( 2 );
            cur->y = PFR_NEXT_SHORT( p );
            FT_TRACE7(( " y.%d", cur->y ));
            break;

          case 2:                           /* 8-bit delta */
            PFR_CHECK( 1 );
            delta  = PFR_NEXT_INT8( p );
            cur->y = pos[3].y + delta;
            FT_TRACE7(( " dy.%d", delta ));
            break;

          default:
            FT_TRACE7(( " -" ));
            cur->y = pos[3].y;
          }

          /* read the additional format flag for the general curve */
          if ( n == 0 && args_count == 4 )
          {
            PFR_CHECK( 1 );
            args_format = PFR_NEXT_BYTE( p );
            args_count--;
          }
          else
            args_format >>= 4;

          /* save the previous point */
          pos[3] = cur[0];
          cur++;
        }

        FT_TRACE7(( "\n" ));

        /***********************************************************/
        /*  finally, execute instruction                           */
        /*                                                         */
        switch ( format >> 4 )
        {
        case 0:                                       /* end glyph => EXIT */
          pfr_glyph_end( glyph );
          goto Exit;

        case 1:                                         /* line operations */
        case 2:
        case 3:
          error = pfr_glyph_line_to( glyph, pos );
          goto Test_Error;

        case 4:                                 /* move to inside contour  */
        case 5:                                 /* move to outside contour */
          error = pfr_glyph_move_to( glyph, pos );
          goto Test_Error;

        default:                                       /* curve operations */
          error = pfr_glyph_curve_to( glyph, pos, pos + 1, pos + 2 );

        Test_Error:  /* test error condition */
          if ( error )
            goto Exit;
        }
      } /* for (;;) */
    }

  Exit:
    return error;

  Failure:
  Too_Short:
    error = FT_THROW( Invalid_Table );
    FT_ERROR(( "pfr_glyph_load_simple: invalid glyph data\n" ));
    goto Exit;
  }


  /* load a composite/compound glyph */
  static FT_Error
  pfr_glyph_load_compound( PFR_Glyph  glyph,
                           FT_Byte*   p,
                           FT_Byte*   limit )
  {
    FT_Error        error  = FT_Err_Ok;
    FT_GlyphLoader  loader = glyph->loader;
    FT_Memory       memory = loader->memory;
    PFR_SubGlyph    subglyph;
    FT_UInt         flags, i, count, org_count;
    FT_Int          x_pos, y_pos;


    PFR_CHECK( 1 );
    flags = PFR_NEXT_BYTE( p );

    /* test for composite glyphs */
    if ( !( flags & PFR_GLYPH_IS_COMPOUND ) )
      goto Failure;

    count = flags & 0x3F;

    /* ignore extra items when present */
    /*                                 */
    if ( flags & PFR_GLYPH_COMPOUND_EXTRA_ITEMS )
    {
      error = pfr_extra_items_skip( &p, limit );
      if ( error )
        goto Exit;
    }

    /* we can't rely on the FT_GlyphLoader to load sub-glyphs, because   */
    /* the PFR format is dumb, using direct file offsets to point to the */
    /* sub-glyphs (instead of glyph indices).  Sigh.                     */
    /*                                                                   */
    /* For now, we load the list of sub-glyphs into a different array    */
    /* but this will prevent us from using the auto-hinter at its best   */
    /* quality.                                                          */
    /*                                                                   */
    org_count = glyph->num_subs;

    if ( org_count + count > glyph->max_subs )
    {
      FT_UInt  new_max = ( org_count + count + 3 ) & (FT_UInt)-4;


      /* we arbitrarily limit the number of subglyphs */
      /* to avoid endless recursion                   */
      if ( new_max > 64 )
      {
        error = FT_THROW( Invalid_Table );
        FT_ERROR(( "pfr_glyph_load_compound:"
                   " too many compound glyphs components\n" ));
        goto Exit;
      }

      if ( FT_RENEW_ARRAY( glyph->subs, glyph->max_subs, new_max ) )
        goto Exit;

      glyph->max_subs = new_max;
    }

    subglyph = glyph->subs + org_count;

    for ( i = 0; i < count; i++, subglyph++ )
    {
      FT_UInt  format;


      x_pos = 0;
      y_pos = 0;

      PFR_CHECK( 1 );
      format = PFR_NEXT_BYTE( p );

      /* read scale when available */
      subglyph->x_scale = 0x10000L;
      if ( format & PFR_SUBGLYPH_XSCALE )
      {
        PFR_CHECK( 2 );
        subglyph->x_scale = PFR_NEXT_SHORT( p ) * 16;
      }

      subglyph->y_scale = 0x10000L;
      if ( format & PFR_SUBGLYPH_YSCALE )
      {
        PFR_CHECK( 2 );
        subglyph->y_scale = PFR_NEXT_SHORT( p ) * 16;
      }

      /* read offset */
      switch ( format & 3 )
      {
      case 1:
        PFR_CHECK( 2 );
        x_pos = PFR_NEXT_SHORT( p );
        break;

      case 2:
        PFR_CHECK( 1 );
        x_pos += PFR_NEXT_INT8( p );
        break;

      default:
        ;
      }

      switch ( ( format >> 2 ) & 3 )
      {
      case 1:
        PFR_CHECK( 2 );
        y_pos = PFR_NEXT_SHORT( p );
        break;

      case 2:
        PFR_CHECK( 1 );
        y_pos += PFR_NEXT_INT8( p );
        break;

      default:
        ;
      }

      subglyph->x_delta = x_pos;
      subglyph->y_delta = y_pos;

      /* read glyph position and size now */
      if ( format & PFR_SUBGLYPH_2BYTE_SIZE )
      {
        PFR_CHECK( 2 );
        subglyph->gps_size = PFR_NEXT_USHORT( p );
      }
      else
      {
        PFR_CHECK( 1 );
        subglyph->gps_size = PFR_NEXT_BYTE( p );
      }

      if ( format & PFR_SUBGLYPH_3BYTE_OFFSET )
      {
        PFR_CHECK( 3 );
        subglyph->gps_offset = PFR_NEXT_ULONG( p );
      }
      else
      {
        PFR_CHECK( 2 );
        subglyph->gps_offset = PFR_NEXT_USHORT( p );
      }

      glyph->num_subs++;
    }

  Exit:
    return error;

  Failure:
  Too_Short:
    error = FT_THROW( Invalid_Table );
    FT_ERROR(( "pfr_glyph_load_compound: invalid glyph data\n" ));
    goto Exit;
  }


  static FT_Error
  pfr_glyph_load_rec( PFR_Glyph  glyph,
                      FT_Stream  stream,
                      FT_ULong   gps_offset,
                      FT_ULong   offset,
                      FT_ULong   size )
  {
    FT_Error  error;
    FT_Byte*  p;
    FT_Byte*  limit;


    if ( FT_STREAM_SEEK( gps_offset + offset ) ||
         FT_FRAME_ENTER( size )                )
      goto Exit;

    p     = (FT_Byte*)stream->cursor;
    limit = p + size;

    if ( size > 0 && *p & PFR_GLYPH_IS_COMPOUND )
    {
      FT_UInt         n, old_count, count;
      FT_GlyphLoader  loader = glyph->loader;
      FT_Outline*     base   = &loader->base.outline;


      old_count = glyph->num_subs;

      /* this is a compound glyph - load it */
      error = pfr_glyph_load_compound( glyph, p, limit );

      FT_FRAME_EXIT();

      if ( error )
        goto Exit;

      count = glyph->num_subs - old_count;

      FT_TRACE4(( "compound glyph with %d elements (offset %lu):\n",
                  count, offset ));

      /* now, load each individual glyph */
      for ( n = 0; n < count; n++ )
      {
        FT_Int        i, old_points, num_points;
        PFR_SubGlyph  subglyph;


        FT_TRACE4(( "  subglyph %d:\n", n ));

        subglyph   = glyph->subs + old_count + n;
        old_points = base->n_points;

        error = pfr_glyph_load_rec( glyph, stream, gps_offset,
                                    subglyph->gps_offset,
                                    subglyph->gps_size );
        if ( error )
          break;

        /* note that `glyph->subs' might have been re-allocated */
        subglyph   = glyph->subs + old_count + n;
        num_points = base->n_points - old_points;

        /* translate and eventually scale the new glyph points */
        if ( subglyph->x_scale != 0x10000L || subglyph->y_scale != 0x10000L )
        {
          FT_Vector*  vec = base->points + old_points;


          for ( i = 0; i < num_points; i++, vec++ )
          {
            vec->x = FT_MulFix( vec->x, subglyph->x_scale ) +
                       subglyph->x_delta;
            vec->y = FT_MulFix( vec->y, subglyph->y_scale ) +
                       subglyph->y_delta;
          }
        }
        else
        {
          FT_Vector*  vec = loader->base.outline.points + old_points;


          for ( i = 0; i < num_points; i++, vec++ )
          {
            vec->x += subglyph->x_delta;
            vec->y += subglyph->y_delta;
          }
        }

        /* proceed to next sub-glyph */
      }

      FT_TRACE4(( "end compound glyph with %d elements\n", count ));
    }
    else
    {
      FT_TRACE4(( "simple glyph (offset %lu)\n", offset ));

      /* load a simple glyph */
      error = pfr_glyph_load_simple( glyph, p, limit );

      FT_FRAME_EXIT();
    }

  Exit:
    return error;
  }


  FT_LOCAL_DEF( FT_Error )
  pfr_glyph_load( PFR_Glyph  glyph,
                  FT_Stream  stream,
                  FT_ULong   gps_offset,
                  FT_ULong   offset,
                  FT_ULong   size )
  {
    /* initialize glyph loader */
    FT_GlyphLoader_Rewind( glyph->loader );

    glyph->num_subs = 0;

    /* load the glyph, recursively when needed */
    return pfr_glyph_load_rec( glyph, stream, gps_offset, offset, size );
  }


/* END */
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2005, 2007 by                                    */
d95 2
a96 2
    /* if the last point falls on the same location than the first one */
    /* we need to delete it                                            */
d138 1
a138 1
      error = PFR_Err_Invalid_Table;
d146 1
a146 1
      FT_UInt  n = outline->n_points;
d174 1
a174 1
      error = PFR_Err_Invalid_Table;
d218 1
d221 1
d253 1
a253 1
    FT_Error   error  = 0;
d273 2
a274 2
      x_count = ( count & 15 );
      y_count = ( count >> 4 );
d309 2
a310 2
    mask  = 0;
    x     = 0;
d336 4
a339 4
    /* XXX: for now we ignore the secondary stroke and edge definitions */
    /*      since we don't want to support native PFR hinting           */
    /*                                                                  */
    if ( flags & PFR_GLYPH_EXTRA_ITEMS )
d371 1
a371 1
        case 0:                             /* end glyph */
d376 1
a376 1
        case 1:                             /* general line operation */
d380 1
a380 1
        case 4:                             /* move to inside contour  */
d384 1
a384 1
        case 5:                             /* move to outside contour */
d391 1
a391 1
        case 2:                             /* horizontal line to */
d393 1
a393 1
          if ( format_low > x_count )
d401 1
a401 1
        case 3:                             /* vertical line to */
d403 1
a403 1
          if ( format_low > y_count )
d411 1
a411 1
        case 6:                             /* horizontal to vertical curve */
d417 1
a417 1
        case 7:                             /* vertical to horizontal curve */
d423 1
a423 1
        default:                            /* general curve to */
d444 2
a445 2
            idx  = PFR_NEXT_BYTE( p );
            if ( idx > x_count )
d451 1
a451 1
          case 1:                           /* 16-bit value */
d475 1
a475 1
            if ( idx > y_count )
d521 1
a521 1
        case 0:                             /* end glyph => EXIT */
d525 1
a525 1
        case 1:                             /* line operations */
d531 2
a532 2
        case 4:                             /* move to inside contour  */
        case 5:                             /* move to outside contour */
d536 1
a536 1
        default:                            /* curve operations */
d551 1
a551 1
    error = PFR_Err_Invalid_Table;
d563 1
a563 1
    FT_Error        error  = 0;
d582 1
a582 1
    if ( flags & PFR_GLYPH_EXTRA_ITEMS )
d585 2
a586 1
      if (error) goto Exit;
d604 10
d638 1
a638 1
        subglyph->x_scale = PFR_NEXT_SHORT( p ) << 4;
d645 1
a645 1
        subglyph->y_scale = PFR_NEXT_SHORT( p ) << 4;
d699 1
a699 1
        subglyph->gps_offset = PFR_NEXT_LONG( p );
d715 1
a715 1
    error = PFR_Err_Invalid_Table;
d742 1
a742 1
      FT_Int          n, old_count, count;
d759 3
d769 2
d778 1
a778 1
          goto Exit;
d812 2
d817 2
a829 3



@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d598 1
a598 1
      FT_UInt  new_max = ( org_count + count + 3 ) & -4;
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2005 by                                          */
d62 1
d65 1
d136 6
a141 1
    FT_ASSERT( glyph->path_begun != 0 );
d155 1
d172 6
a177 1
    FT_ASSERT( glyph->path_begun != 0 );
d196 1
d261 2
a262 1
    FT_ASSERT( ( flags & PFR_GLYPH_IS_COMPOUND ) == 0 );
d357 1
a357 1
        FT_Int  format, args_format = 0, args_count, n;
d364 2
a365 1
        format = PFR_NEXT_BYTE( p );
d385 1
a385 1
          args_format = format & 15;
d390 4
a393 1
          FT_TRACE6(( "- horizontal line to cx.%d", format & 15 ));
a394 1
          pos[0].x   = glyph->x_control[format & 15];
d400 3
a402 1
          FT_TRACE6(( "- vertical line to cy.%d", format & 15 ));
d404 2
a405 2
          pos[0].y   = glyph->y_control[format & 15];
          pos[3] = pos[0];
d411 2
a412 2
          args_format  = 0xB8E;
          args_count   = 3;
d424 1
a424 1
          args_format = format & 15;
d433 2
a434 1
          FT_Int  idx, delta;
d443 2
d473 2
d547 1
d573 2
a574 1
    FT_ASSERT( ( flags & PFR_GLYPH_IS_COMPOUND ) != 0 );
d700 1
a707 3



@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003 by                                                */
d136 1
a136 1
    error = FT_GlyphLoader_CheckPoints( loader, 1, 0 );
d166 1
a166 1
    error = FT_GlyphLoader_CheckPoints( loader, 3, 0 );
d202 1
a202 1
    error = FT_GlyphLoader_CheckPoints( loader, 1, 1 );
d796 2
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2005, 2007 by                                    */
a61 1
#if 0
a63 1
#endif
d134 1
a134 6
    if ( !glyph->path_begun )
    {
      error = PFR_Err_Invalid_Table;
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }
d136 1
a136 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 0 );
a147 1
  Exit:
d164 1
a164 6
    if ( !glyph->path_begun )
    {
      error = PFR_Err_Invalid_Table;
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }
d166 1
a166 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 3, 0 );
a182 1
  Exit:
d202 1
a202 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 1 );
d247 1
a247 2
    if ( flags & PFR_GLYPH_IS_COMPOUND )
      goto Failure;
d342 1
a342 1
        FT_UInt  format, format_low, args_format = 0, args_count, n;
d349 1
a349 2
        format     = PFR_NEXT_BYTE( p );
        format_low = format & 15;
d369 1
a369 1
          args_format = format_low;
d374 1
a374 4
          FT_TRACE6(( "- horizontal line to cx.%d", format_low ));
          if ( format_low > x_count )
            goto Failure;
          pos[0].x   = glyph->x_control[format_low];
d376 1
d382 1
a382 3
          FT_TRACE6(( "- vertical line to cy.%d", format_low ));
          if ( format_low > y_count )
            goto Failure;
d384 2
a385 2
          pos[0].y   = glyph->y_control[format_low];
          pos[3]     = pos[0];
d391 2
a392 2
          args_format = 0xB8E;
          args_count  = 3;
d404 1
a404 1
          args_format = format_low;
d413 1
a413 2
          FT_UInt  idx;
          FT_Int   delta;
a421 2
            if ( idx > x_count )
              goto Failure;
a449 2
            if ( idx > y_count )
              goto Failure;
a521 1
  Failure:
d547 1
a547 2
    if ( !( flags & PFR_GLYPH_IS_COMPOUND ) )
      goto Failure;
a672 1
  Failure:
d680 3
a795 2
    glyph->num_subs = 0;

@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d598 1
a598 1
      FT_UInt  new_max = ( org_count + count + 3 ) & (FT_UInt)-4;
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2005 by                                          */
d136 1
a136 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 0 );
d166 1
a166 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 3, 0 );
d202 1
a202 1
    error = FT_GLYPHLOADER_CHECK_POINTS( loader, 1, 1 );
a795 2
    glyph->num_subs = 0;

@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2002, 2003, 2005, 2007 by                                    */
a61 1
#if 0
a63 1
#endif
d134 1
a134 6
    if ( !glyph->path_begun )
    {
      error = PFR_Err_Invalid_Table;
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }
a147 1
  Exit:
d164 1
a164 6
    if ( !glyph->path_begun )
    {
      error = PFR_Err_Invalid_Table;
      FT_ERROR(( "pfr_glyph_line_to: invalid glyph data\n" ));
      goto Exit;
    }
a182 1
  Exit:
d247 1
a247 2
    if ( flags & PFR_GLYPH_IS_COMPOUND )
      goto Failure;
d342 1
a342 1
        FT_UInt  format, format_low, args_format = 0, args_count, n;
d349 1
a349 2
        format     = PFR_NEXT_BYTE( p );
        format_low = format & 15;
d369 1
a369 1
          args_format = format_low;
d374 1
a374 4
          FT_TRACE6(( "- horizontal line to cx.%d", format_low ));
          if ( format_low > x_count )
            goto Failure;
          pos[0].x   = glyph->x_control[format_low];
d376 1
d382 1
a382 3
          FT_TRACE6(( "- vertical line to cy.%d", format_low ));
          if ( format_low > y_count )
            goto Failure;
d384 2
a385 2
          pos[0].y   = glyph->y_control[format_low];
          pos[3]     = pos[0];
d391 2
a392 2
          args_format = 0xB8E;
          args_count  = 3;
d404 1
a404 1
          args_format = format_low;
d413 1
a413 2
          FT_UInt  idx;
          FT_Int   delta;
a421 2
            if ( idx > x_count )
              goto Failure;
a449 2
            if ( idx > y_count )
              goto Failure;
a521 1
  Failure:
d547 1
a547 2
    if ( !( flags & PFR_GLYPH_IS_COMPOUND ) )
      goto Failure;
d571 1
a571 1
      FT_UInt  new_max = ( org_count + count + 3 ) & (FT_UInt)-4;
a672 1
  Failure:
d680 3
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2002-2016 by                                                 */
d95 2
a96 2
    /* if the last point falls on the same location as the first one */
    /* we need to delete it                                          */
d138 1
a138 1
      error = FT_THROW( Invalid_Table );
d146 1
a146 1
      FT_Int  n = outline->n_points;
d174 1
a174 1
      error = FT_THROW( Invalid_Table );
a217 1
    {
a219 1
    }
d251 1
a251 1
    FT_Error   error  = FT_Err_Ok;
d271 2
a272 2
      x_count = count & 15;
      y_count = count >> 4;
d307 2
a308 2
    mask = 0;
    x    = 0;
d334 4
a337 4
    /* XXX: we ignore the secondary stroke and edge definitions */
    /*      since we don't support native PFR hinting           */
    /*                                                          */
    if ( flags & PFR_GLYPH_SINGLE_EXTRA_ITEMS )
d369 1
a369 1
        case 0:                                               /* end glyph */
d374 1
a374 1
        case 1:                                  /* general line operation */
d378 1
a378 1
        case 4:                                 /* move to inside contour  */
d382 1
a382 1
        case 5:                                 /* move to outside contour */
d389 1
a389 1
        case 2:                                      /* horizontal line to */
d391 1
a391 1
          if ( format_low >= x_count )
d399 1
a399 1
        case 3:                                        /* vertical line to */
d401 1
a401 1
          if ( format_low >= y_count )
d409 1
a409 1
        case 6:                            /* horizontal to vertical curve */
d415 1
a415 1
        case 7:                            /* vertical to horizontal curve */
d421 1
a421 1
        default:                                       /* general curve to */
d442 2
a443 2
            idx = PFR_NEXT_BYTE( p );
            if ( idx >= x_count )
d449 1
a449 1
          case 1:                           /* 16-bit absolute value */
d473 1
a473 1
            if ( idx >= y_count )
d519 1
a519 1
        case 0:                                       /* end glyph => EXIT */
d523 1
a523 1
        case 1:                                         /* line operations */
d529 2
a530 2
        case 4:                                 /* move to inside contour  */
        case 5:                                 /* move to outside contour */
d534 1
a534 1
        default:                                       /* curve operations */
d549 1
a549 1
    error = FT_THROW( Invalid_Table );
d561 1
a561 1
    FT_Error        error  = FT_Err_Ok;
d580 1
a580 1
    if ( flags & PFR_GLYPH_COMPOUND_EXTRA_ITEMS )
d583 1
a583 2
      if ( error )
        goto Exit;
a600 10
      /* we arbitrarily limit the number of subglyphs */
      /* to avoid endless recursion                   */
      if ( new_max > 64 )
      {
        error = FT_THROW( Invalid_Table );
        FT_ERROR(( "pfr_glyph_load_compound:"
                   " too many compound glyphs components\n" ));
        goto Exit;
      }

d625 1
a625 1
        subglyph->x_scale = PFR_NEXT_SHORT( p ) * 16;
d632 1
a632 1
        subglyph->y_scale = PFR_NEXT_SHORT( p ) * 16;
d686 1
a686 1
        subglyph->gps_offset = PFR_NEXT_ULONG( p );
d702 1
a702 1
    error = FT_THROW( Invalid_Table );
d729 1
a729 1
      FT_UInt         n, old_count, count;
a745 3
      FT_TRACE4(( "compound glyph with %d elements (offset %lu):\n",
                  count, offset ));

a752 2
        FT_TRACE4(( "  subglyph %d:\n", n ));

d760 1
a760 1
          break;
a793 2

      FT_TRACE4(( "end compound glyph with %d elements\n", count ));
a796 2
      FT_TRACE4(( "simple glyph (offset %lu)\n", offset ));

d808 3
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
