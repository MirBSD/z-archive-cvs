head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.22.09;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.48.26;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.05.08;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.07;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.17;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.17;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.17;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.49;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.37;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.27;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.03;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftsmooth.c                                                             */
/*                                                                         */
/*    Anti-aliasing renderer interface (body).                             */
/*                                                                         */
/*  Copyright 2000-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H
#include FT_OUTLINE_H
#include "ftsmooth.h"
#include "ftgrays.h"
#include "ftspic.h"

#include "ftsmerrs.h"


  /* initialize renderer -- init its raster */
  static FT_Error
  ft_smooth_init( FT_Renderer  render )
  {
    FT_Library  library = FT_MODULE_LIBRARY( render );


    render->clazz->raster_class->raster_reset( render->raster,
                                               library->raster_pool,
                                               library->raster_pool_size );

    return 0;
  }


  /* sets render-specific mode */
  static FT_Error
  ft_smooth_set_mode( FT_Renderer  render,
                      FT_ULong     mode_tag,
                      FT_Pointer   data )
  {
    /* we simply pass it to the raster */
    return render->clazz->raster_class->raster_set_mode( render->raster,
                                                         mode_tag,
                                                         data );
  }

  /* transform a given glyph image */
  static FT_Error
  ft_smooth_transform( FT_Renderer       render,
                       FT_GlyphSlot      slot,
                       const FT_Matrix*  matrix,
                       const FT_Vector*  delta )
  {
    FT_Error  error = FT_Err_Ok;


    if ( slot->format != render->glyph_format )
    {
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    if ( matrix )
      FT_Outline_Transform( &slot->outline, matrix );

    if ( delta )
      FT_Outline_Translate( &slot->outline, delta->x, delta->y );

  Exit:
    return error;
  }


  /* return the glyph's control box */
  static void
  ft_smooth_get_cbox( FT_Renderer   render,
                      FT_GlyphSlot  slot,
                      FT_BBox*      cbox )
  {
    FT_ZERO( cbox );

    if ( slot->format == render->glyph_format )
      FT_Outline_Get_CBox( &slot->outline, cbox );
  }


  /* convert a slot's glyph image into a bitmap */
  static FT_Error
  ft_smooth_render_generic( FT_Renderer       render,
                            FT_GlyphSlot      slot,
                            FT_Render_Mode    mode,
                            const FT_Vector*  origin,
                            FT_Render_Mode    required_mode )
  {
    FT_Error     error;
    FT_Outline*  outline = &slot->outline;
    FT_Bitmap*   bitmap  = &slot->bitmap;
    FT_Memory    memory  = render->root.memory;
    FT_BBox      cbox;
    FT_Pos       x_shift = 0;
    FT_Pos       y_shift = 0;
    FT_Pos       x_left, y_top;
    FT_Pos       width, height, pitch;
#ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
    FT_Pos       height_org, width_org;
#endif
    FT_Int       hmul    = ( mode == FT_RENDER_MODE_LCD );
    FT_Int       vmul    = ( mode == FT_RENDER_MODE_LCD_V );

    FT_Raster_Params  params;

    FT_Bool  have_outline_shifted = FALSE;
    FT_Bool  have_buffer          = FALSE;


    /* check glyph image format */
    if ( slot->format != render->glyph_format )
    {
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    /* check mode */
    if ( mode != required_mode )
    {
      error = FT_THROW( Cannot_Render_Glyph );
      goto Exit;
    }

    if ( origin )
    {
      x_shift = origin->x;
      y_shift = origin->y;
    }

    /* compute the control box, and grid fit it */
    /* taking into account the origin shift     */
    FT_Outline_Get_CBox( outline, &cbox );

    cbox.xMin = FT_PIX_FLOOR( cbox.xMin + x_shift );
    cbox.yMin = FT_PIX_FLOOR( cbox.yMin + y_shift );
    cbox.xMax = FT_PIX_CEIL( cbox.xMax + x_shift );
    cbox.yMax = FT_PIX_CEIL( cbox.yMax + y_shift );

    x_shift -= cbox.xMin;
    y_shift -= cbox.yMin;

    x_left  = cbox.xMin >> 6;
    y_top   = cbox.yMax >> 6;

    width  = (FT_ULong)( cbox.xMax - cbox.xMin ) >> 6;
    height = (FT_ULong)( cbox.yMax - cbox.yMin ) >> 6;

#ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
    width_org  = width;
    height_org = height;
#endif

    pitch = width;
    if ( hmul )
    {
      width *= 3;
      pitch  = FT_PAD_CEIL( width, 4 );
    }

    if ( vmul )
      height *= 3;

#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

    if ( slot->library->lcd_filter_func )
    {
      FT_Int  extra = slot->library->lcd_extra;


      if ( hmul )
      {
        x_shift += 64 * ( extra >> 1 );
        x_left  -= extra >> 1;
        width   += 3 * extra;
        pitch    = FT_PAD_CEIL( width, 4 );
      }

      if ( vmul )
      {
        y_shift += 64 * ( extra >> 1 );
        y_top   += extra >> 1;
        height  += 3 * extra;
      }
    }

#endif

    /*
     * XXX: on 16bit system, we return an error for huge bitmap
     * to prevent an overflow.
     */
    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX ||
         x_left < FT_INT_MIN || y_top < FT_INT_MIN )
    {
      error = FT_THROW( Invalid_Pixel_Size );
      goto Exit;
    }

    /* Required check is (pitch * height < FT_ULONG_MAX),        */
    /* but we care realistic cases only.  Always pitch <= width. */
    if ( width > 0x7FFF || height > 0x7FFF )
    {
      FT_ERROR(( "ft_smooth_render_generic: glyph too large: %u x %u\n",
                 width, height ));
      error = FT_THROW( Raster_Overflow );
      goto Exit;
    }

    /* release old bitmap buffer */
    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
    {
      FT_FREE( bitmap->buffer );
      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
    }

    /* allocate new one */
    if ( FT_ALLOC( bitmap->buffer, (FT_ULong)( pitch * height ) ) )
      goto Exit;
    else
      have_buffer = TRUE;

    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;

    slot->format      = FT_GLYPH_FORMAT_BITMAP;
    slot->bitmap_left = (FT_Int)x_left;
    slot->bitmap_top  = (FT_Int)y_top;

    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
    bitmap->num_grays  = 256;
    bitmap->width      = (unsigned int)width;
    bitmap->rows       = (unsigned int)height;
    bitmap->pitch      = pitch;

    /* translate outline to render it into the bitmap */
    if ( x_shift || y_shift )
    {
      FT_Outline_Translate( outline, x_shift, y_shift );
      have_outline_shifted = TRUE;
    }

    /* set up parameters */
    params.target = bitmap;
    params.source = outline;
    params.flags  = FT_RASTER_FLAG_AA;

#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

    /* implode outline if needed */
    {
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
      FT_Vector*  vec;


      if ( hmul )
        for ( vec = points; vec < points_end; vec++ )
          vec->x *= 3;

      if ( vmul )
        for ( vec = points; vec < points_end; vec++ )
          vec->y *= 3;
    }

    /* render outline into the bitmap */
    error = render->raster_render( render->raster, &params );

    /* deflate outline if needed */
    {
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
      FT_Vector*  vec;


      if ( hmul )
        for ( vec = points; vec < points_end; vec++ )
          vec->x /= 3;

      if ( vmul )
        for ( vec = points; vec < points_end; vec++ )
          vec->y /= 3;
    }

    if ( error )
      goto Exit;

    if ( slot->library->lcd_filter_func )
      slot->library->lcd_filter_func( bitmap, mode, slot->library );

#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    /* render outline into bitmap */
    error = render->raster_render( render->raster, &params );
    if ( error )
      goto Exit;

    /* expand it horizontally */
    if ( hmul )
    {
      FT_Byte*  line = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh--, line += pitch )
      {
        FT_UInt   xx;
        FT_Byte*  end = line + width;


        for ( xx = width_org; xx > 0; xx-- )
        {
          FT_UInt  pixel = line[xx-1];


          end[-3] = (FT_Byte)pixel;
          end[-2] = (FT_Byte)pixel;
          end[-1] = (FT_Byte)pixel;
          end    -= 3;
        }
      }
    }

    /* expand it vertically */
    if ( vmul )
    {
      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;
      FT_Byte*  write = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh-- )
      {
        ft_memcpy( write, read, pitch );
        write += pitch;

        ft_memcpy( write, read, pitch );
        write += pitch;

        ft_memcpy( write, read, pitch );
        write += pitch;
        read  += pitch;
      }
    }

#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    /* everything is fine; don't deallocate buffer */
    have_buffer = FALSE;

    error = FT_Err_Ok;

  Exit:
    if ( have_outline_shifted )
      FT_Outline_Translate( outline, -x_shift, -y_shift );
    if ( have_buffer )
    {
      FT_FREE( bitmap->buffer );
      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
    }

    return error;
  }


  /* convert a slot's glyph image into a bitmap */
  static FT_Error
  ft_smooth_render( FT_Renderer       render,
                    FT_GlyphSlot      slot,
                    FT_Render_Mode    mode,
                    const FT_Vector*  origin )
  {
    if ( mode == FT_RENDER_MODE_LIGHT )
      mode = FT_RENDER_MODE_NORMAL;

    return ft_smooth_render_generic( render, slot, mode, origin,
                                     FT_RENDER_MODE_NORMAL );
  }


  /* convert a slot's glyph image into a horizontal LCD bitmap */
  static FT_Error
  ft_smooth_render_lcd( FT_Renderer       render,
                        FT_GlyphSlot      slot,
                        FT_Render_Mode    mode,
                        const FT_Vector*  origin )
  {
    FT_Error  error;

    error = ft_smooth_render_generic( render, slot, mode, origin,
                                      FT_RENDER_MODE_LCD );
    if ( !error )
      slot->bitmap.pixel_mode = FT_PIXEL_MODE_LCD;

    return error;
  }


  /* convert a slot's glyph image into a vertical LCD bitmap */
  static FT_Error
  ft_smooth_render_lcd_v( FT_Renderer       render,
                          FT_GlyphSlot      slot,
                          FT_Render_Mode    mode,
                          const FT_Vector*  origin )
  {
    FT_Error  error;

    error = ft_smooth_render_generic( render, slot, mode, origin,
                                      FT_RENDER_MODE_LCD_V );
    if ( !error )
      slot->bitmap.pixel_mode = FT_PIXEL_MODE_LCD_V;

    return error;
  }


  FT_DEFINE_RENDERER(
    ft_smooth_renderer_class,

      FT_MODULE_RENDERER,
      sizeof ( FT_RendererRec ),

      "smooth",
      0x10000L,
      0x20000L,

      NULL,    /* module specific interface */

      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */

    FT_GLYPH_FORMAT_OUTLINE,

    (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */

    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET           /* raster_class    */
  )


  FT_DEFINE_RENDERER(
    ft_smooth_lcd_renderer_class,

      FT_MODULE_RENDERER,
      sizeof ( FT_RendererRec ),

      "smooth-lcd",
      0x10000L,
      0x20000L,

      NULL,    /* module specific interface */

      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */

    FT_GLYPH_FORMAT_OUTLINE,

    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */

    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET            /* raster_class    */
  )


  FT_DEFINE_RENDERER(
    ft_smooth_lcdv_renderer_class,

      FT_MODULE_RENDERER,
      sizeof ( FT_RendererRec ),

      "smooth-lcdv",
      0x10000L,
      0x20000L,

      NULL,    /* module specific interface */

      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */

    FT_GLYPH_FORMAT_OUTLINE,

    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */

    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET              /* raster_class    */
  )


/* END */
@


1.4
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             */
d64 1
a64 1
    FT_Error  error = Smooth_Err_Ok;
d69 1
a69 1
      error = Smooth_Err_Invalid_Argument;
d90 1
a90 1
    FT_MEM_ZERO( cbox, sizeof ( *cbox ) );
d106 3
a108 1
    FT_Outline*  outline = NULL;
d110 9
a118 6
    FT_UInt      width, height, height_org, width_org, pitch;
    FT_Bitmap*   bitmap;
    FT_Memory    memory;
    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;
    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;
    FT_Pos       x_shift, y_shift, x_left, y_top;
d122 3
d129 1
a129 1
      error = Smooth_Err_Invalid_Argument;
d135 4
a138 1
      return Smooth_Err_Cannot_Render_Glyph;
a139 3
    outline = &slot->outline;

    /* translate the outline to the new origin if needed */
d141 4
a144 1
      FT_Outline_Translate( outline, origin->x, origin->y );
d147 1
d150 10
a159 9
    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );
    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
    cbox.xMax = FT_PIX_CEIL( cbox.xMax );
    cbox.yMax = FT_PIX_CEIL( cbox.yMax );

    width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );
    height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );
    bitmap = &slot->bitmap;
    memory = render->root.memory;
d161 4
d167 1
a168 8
    /* release old bitmap buffer */
    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
    {
      FT_FREE( bitmap->buffer );
      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
    }

    /* allocate new one */
d172 2
a173 2
      width = width * 3;
      pitch = FT_PAD_CEIL( width, 4 );
a178 5
    x_shift = (FT_Int) cbox.xMin;
    y_shift = (FT_Int) cbox.yMin;
    x_left  = (FT_Int)( cbox.xMin >> 6 );
    y_top   = (FT_Int)( cbox.yMax >> 6 );

d188 2
a189 1
        x_shift -= 64 * ( extra >> 1 );
a191 1
        x_left  -= extra >> 1;
d196 2
a197 1
        y_shift -= 64 * ( extra >> 1 );
a198 1
        y_top   += extra >> 1;
d204 10
a213 1
#if FT_UINT_MAX > 0xFFFFU
d215 3
a217 3
    /* Required check is ( pitch * height < FT_ULONG_MAX ),     */
    /* but we care realistic cases only. Always pitch <= width. */
    if ( width > 0xFFFFU || height > 0xFFFFU )
d219 1
a219 1
      FT_ERROR(( "ft_smooth_render_generic: glyph too large: %d x %d\n",
d221 2
a222 1
      return Smooth_Err_Raster_Overflow;
d225 18
a242 1
#endif
d246 2
a247 2
    bitmap->width      = width;
    bitmap->rows       = height;
d251 5
a255 6
    FT_Outline_Translate( outline, -x_shift, -y_shift );

    if ( FT_ALLOC( bitmap->buffer, (FT_ULong)pitch * height ) )
      goto Exit;

    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
d299 3
d309 2
d362 2
a363 8
    FT_Outline_Translate( outline, x_shift, y_shift );

    /*
     * XXX: on 16bit system, we return an error for huge bitmap
     * to prevent an overflow.
     */
    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )
      return Smooth_Err_Invalid_Pixel_Size;
d365 1
a365 6
    if ( error )
      goto Exit;

    slot->format      = FT_GLYPH_FORMAT_BITMAP;
    slot->bitmap_left = (FT_Int)x_left;
    slot->bitmap_top  = (FT_Int)y_top;
d368 7
a374 2
    if ( outline && origin )
      FT_Outline_Translate( outline, -origin->x, -origin->y );
d431 2
a432 1
  FT_DEFINE_RENDERER(ft_smooth_renderer_class,
d435 1
a435 1
      sizeof( FT_RendererRec ),
d441 1
a441 1
      0,    /* module specific interface */
d443 3
a445 4
      (FT_Module_Constructor)ft_smooth_init,
      (FT_Module_Destructor) 0,
      (FT_Module_Requester)  0
    ,
d449 4
a452 4
    (FT_Renderer_RenderFunc)   ft_smooth_render,
    (FT_Renderer_TransformFunc)ft_smooth_transform,
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,
d454 1
a454 1
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
d458 3
a460 2
  FT_DEFINE_RENDERER(ft_smooth_lcd_renderer_class,
  
d462 1
a462 1
      sizeof( FT_RendererRec ),
d468 1
a468 1
      0,    /* module specific interface */
d470 3
a472 4
      (FT_Module_Constructor)ft_smooth_init,
      (FT_Module_Destructor) 0,
      (FT_Module_Requester)  0
    ,
d476 4
a479 4
    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,
    (FT_Renderer_TransformFunc)ft_smooth_transform,
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,
d481 1
a481 1
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
d484 3
a486 1
  FT_DEFINE_RENDERER(ft_smooth_lcdv_renderer_class,
d489 1
a489 1
      sizeof( FT_RendererRec ),
d495 1
a495 1
      0,    /* module specific interface */
d497 3
a499 4
      (FT_Module_Constructor)ft_smooth_init,
      (FT_Module_Destructor) 0,
      (FT_Module_Requester)  0
    ,
d503 4
a506 4
    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,
    (FT_Renderer_TransformFunc)ft_smooth_transform,
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,
d508 1
a508 1
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d20 1
d25 1
d158 1
a158 1
    /* allocate new one, depends on pixel format */
d199 13
d312 1
a312 1
        memcpy( write, read, pitch );
d315 1
a315 1
        memcpy( write, read, pitch );
d318 1
a318 1
        memcpy( write, read, pitch );
d328 7
d339 2
a340 2
    slot->bitmap_left = x_left;
    slot->bitmap_top  = y_top;
d401 2
a402 4
  FT_CALLBACK_TABLE_DEF
  const FT_Renderer_Class  ft_smooth_renderer_class =
  {
    {
d415 1
a415 1
    },
d424 2
a425 2
    (FT_Raster_Funcs*)    &ft_grays_raster
  };
d428 2
a429 4
  FT_CALLBACK_TABLE_DEF
  const FT_Renderer_Class  ft_smooth_lcd_renderer_class =
  {
    {
d442 1
a442 1
    },
d451 2
a452 2
    (FT_Raster_Funcs*)    &ft_grays_raster
  };
d454 1
a455 5

  FT_CALLBACK_TABLE_DEF
  const FT_Renderer_Class  ft_smooth_lcdv_renderer_class =
  {
    {
d468 1
a468 1
    },
d477 2
a478 2
    (FT_Raster_Funcs*)    &ft_grays_raster
  };
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005 by                         */
d101 1
a101 3
                            FT_Render_Mode    required_mode,
                            FT_Int            hmul,
                            FT_Int            vmul )
d106 1
a106 1
    FT_UInt      width, height, pitch;
d109 3
d146 3
d160 1
a160 1
      width = width * hmul;
d165 31
a195 1
      height *= vmul;
d203 3
a210 3
    /* translate outline to render it into the bitmap */
    FT_Outline_Translate( outline, -cbox.xMin, -cbox.yMin );

d216 2
d220 2
a221 1
      FT_Int      n;
d226 2
a227 2
        for ( vec = outline->points, n = 0; n < outline->n_points; n++, vec++ )
          vec->x *= hmul;
d230 2
a231 2
        for ( vec = outline->points, n = 0; n < outline->n_points; n++, vec++ )
          vec->y *= vmul;
d239 2
a240 1
      FT_Int      n;
d245 2
a246 2
        for ( vec = outline->points, n = 0; n < outline->n_points; n++, vec++ )
          vec->x /= hmul;
d249 36
a284 2
        for ( vec = outline->points, n = 0; n < outline->n_points; n++, vec++ )
          vec->y /= vmul;
d287 25
a311 1
    FT_Outline_Translate( outline, cbox.xMin, cbox.yMin );
d317 2
a318 2
    slot->bitmap_left = (FT_Int)( cbox.xMin >> 6 );
    slot->bitmap_top  = (FT_Int)( cbox.yMax >> 6 );
d339 1
a339 2
                                     FT_RENDER_MODE_NORMAL,
                                     0, 0 );
d353 1
a353 2
                                      FT_RENDER_MODE_LCD,
                                      3, 0 );
d371 1
a371 2
                                      FT_RENDER_MODE_LCD_V,
                                      0, 3 );
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004 by                               */
d57 4
a60 4
  ft_smooth_transform( FT_Renderer   render,
                       FT_GlyphSlot  slot,
                       FT_Matrix*    matrix,
                       FT_Vector*    delta )
d97 7
a103 7
  ft_smooth_render_generic( FT_Renderer     render,
                            FT_GlyphSlot    slot,
                            FT_Render_Mode  mode,
                            FT_Vector*      origin,
                            FT_Render_Mode  required_mode,
                            FT_Int          hmul,
                            FT_Int          vmul )
d234 4
a237 4
  ft_smooth_render( FT_Renderer     render,
                    FT_GlyphSlot    slot,
                    FT_Render_Mode  mode,
                    FT_Vector*      origin )
d250 4
a253 4
  ft_smooth_render_lcd( FT_Renderer     render,
                        FT_GlyphSlot    slot,
                        FT_Render_Mode  mode,
                        FT_Vector*      origin )
d269 4
a272 4
  ft_smooth_render_lcd_v( FT_Renderer     render,
                          FT_GlyphSlot    slot,
                          FT_Render_Mode  mode,
                          FT_Vector*      origin )
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d57 4
a60 4
  ft_smooth_transform( FT_Renderer       render,
                       FT_GlyphSlot      slot,
                       const FT_Matrix*  matrix,
                       const FT_Vector*  delta )
d97 7
a103 5
  ft_smooth_render_generic( FT_Renderer       render,
                            FT_GlyphSlot      slot,
                            FT_Render_Mode    mode,
                            const FT_Vector*  origin,
                            FT_Render_Mode    required_mode )
d108 1
a108 1
    FT_UInt      width, height, height_org, width_org, pitch;
a110 3
    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;
    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;
    FT_Pos       x_shift, y_shift, x_left, y_top;
a144 3
    width_org  = width;
    height_org = height;

d156 1
a156 1
      width = width * 3;
d161 1
a161 31
      height *= 3;

    x_shift = (FT_Int) cbox.xMin;
    y_shift = (FT_Int) cbox.yMin;
    x_left  = (FT_Int)( cbox.xMin >> 6 );
    y_top   = (FT_Int)( cbox.yMax >> 6 );

#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

    if ( slot->library->lcd_filter_func )
    {
      FT_Int  extra = slot->library->lcd_extra;


      if ( hmul )
      {
        x_shift -= 64 * ( extra >> 1 );
        width   += 3 * extra;
        pitch    = FT_PAD_CEIL( width, 4 );
        x_left  -= extra >> 1;
      }

      if ( vmul )
      {
        y_shift -= 64 * ( extra >> 1 );
        height  += 3 * extra;
        y_top   += extra >> 1;
      }
    }

#endif
a168 3
    /* translate outline to render it into the bitmap */
    FT_Outline_Translate( outline, -x_shift, -y_shift );

d174 3
a181 2
#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

d184 1
a184 2
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
d189 2
a190 2
        for ( vec = points; vec < points_end; vec++ )
          vec->x *= 3;
d193 2
a194 2
        for ( vec = points; vec < points_end; vec++ )
          vec->y *= 3;
d202 1
a202 2
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
d207 2
a208 2
        for ( vec = points; vec < points_end; vec++ )
          vec->x /= 3;
d211 2
a212 36
        for ( vec = points; vec < points_end; vec++ )
          vec->y /= 3;
    }

    if ( slot->library->lcd_filter_func )
      slot->library->lcd_filter_func( bitmap, mode, slot->library );

#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    /* render outline into bitmap */
    error = render->raster_render( render->raster, &params );

    /* expand it horizontally */
    if ( hmul )
    {
      FT_Byte*  line = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh--, line += pitch )
      {
        FT_UInt   xx;
        FT_Byte*  end = line + width;


        for ( xx = width_org; xx > 0; xx-- )
        {
          FT_UInt  pixel = line[xx-1];


          end[-3] = (FT_Byte)pixel;
          end[-2] = (FT_Byte)pixel;
          end[-1] = (FT_Byte)pixel;
          end    -= 3;
        }
      }
d215 1
a215 25
    /* expand it vertically */
    if ( vmul )
    {
      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;
      FT_Byte*  write = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh-- )
      {
        memcpy( write, read, pitch );
        write += pitch;

        memcpy( write, read, pitch );
        write += pitch;

        memcpy( write, read, pitch );
        write += pitch;
        read  += pitch;
      }
    }

#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    FT_Outline_Translate( outline, x_shift, y_shift );
d221 2
a222 2
    slot->bitmap_left = x_left;
    slot->bitmap_top  = y_top;
d234 4
a237 4
  ft_smooth_render( FT_Renderer       render,
                    FT_GlyphSlot      slot,
                    FT_Render_Mode    mode,
                    const FT_Vector*  origin )
d243 2
a244 1
                                     FT_RENDER_MODE_NORMAL );
d250 4
a253 4
  ft_smooth_render_lcd( FT_Renderer       render,
                        FT_GlyphSlot      slot,
                        FT_Render_Mode    mode,
                        const FT_Vector*  origin )
d258 2
a259 1
                                      FT_RENDER_MODE_LCD );
d269 4
a272 4
  ft_smooth_render_lcd_v( FT_Renderer       render,
                          FT_GlyphSlot      slot,
                          FT_Render_Mode    mode,
                          const FT_Vector*  origin )
d277 2
a278 1
                                      FT_RENDER_MODE_LCD_V );
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005 by                         */
d57 4
a60 4
  ft_smooth_transform( FT_Renderer       render,
                       FT_GlyphSlot      slot,
                       const FT_Matrix*  matrix,
                       const FT_Vector*  delta )
d97 7
a103 7
  ft_smooth_render_generic( FT_Renderer       render,
                            FT_GlyphSlot      slot,
                            FT_Render_Mode    mode,
                            const FT_Vector*  origin,
                            FT_Render_Mode    required_mode,
                            FT_Int            hmul,
                            FT_Int            vmul )
d234 4
a237 4
  ft_smooth_render( FT_Renderer       render,
                    FT_GlyphSlot      slot,
                    FT_Render_Mode    mode,
                    const FT_Vector*  origin )
d250 4
a253 4
  ft_smooth_render_lcd( FT_Renderer       render,
                        FT_GlyphSlot      slot,
                        FT_Render_Mode    mode,
                        const FT_Vector*  origin )
d269 4
a272 4
  ft_smooth_render_lcd_v( FT_Renderer       render,
                          FT_GlyphSlot      slot,
                          FT_Render_Mode    mode,
                          const FT_Vector*  origin )
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             */
a19 1
#include FT_INTERNAL_DEBUG_H
a23 1
#include "ftspic.h"
d101 3
a103 1
                            FT_Render_Mode    required_mode )
d108 1
a108 1
    FT_UInt      width, height, height_org, width_org, pitch;
a110 3
    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;
    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;
    FT_Pos       x_shift, y_shift, x_left, y_top;
a144 3
    width_org  = width;
    height_org = height;

d152 1
a152 1
    /* allocate new one */
d156 1
a156 1
      width = width * 3;
d161 1
a161 44
      height *= 3;

    x_shift = (FT_Int) cbox.xMin;
    y_shift = (FT_Int) cbox.yMin;
    x_left  = (FT_Int)( cbox.xMin >> 6 );
    y_top   = (FT_Int)( cbox.yMax >> 6 );

#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

    if ( slot->library->lcd_filter_func )
    {
      FT_Int  extra = slot->library->lcd_extra;


      if ( hmul )
      {
        x_shift -= 64 * ( extra >> 1 );
        width   += 3 * extra;
        pitch    = FT_PAD_CEIL( width, 4 );
        x_left  -= extra >> 1;
      }

      if ( vmul )
      {
        y_shift -= 64 * ( extra >> 1 );
        height  += 3 * extra;
        y_top   += extra >> 1;
      }
    }

#endif

#if FT_UINT_MAX > 0xFFFFU

    /* Required check is ( pitch * height < FT_ULONG_MAX ),     */
    /* but we care realistic cases only. Always pitch <= width. */
    if ( width > 0xFFFFU || height > 0xFFFFU )
    {
      FT_ERROR(( "ft_smooth_render_generic: glyph too large: %d x %d\n",
                 width, height ));
      return Smooth_Err_Raster_Overflow;
    }

#endif
a168 3
    /* translate outline to render it into the bitmap */
    FT_Outline_Translate( outline, -x_shift, -y_shift );

d174 3
a181 2
#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING

d184 1
a184 2
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
d189 2
a190 2
        for ( vec = points; vec < points_end; vec++ )
          vec->x *= 3;
d193 2
a194 2
        for ( vec = points; vec < points_end; vec++ )
          vec->y *= 3;
d202 1
a202 2
      FT_Vector*  points     = outline->points;
      FT_Vector*  points_end = points + outline->n_points;
d207 2
a208 2
        for ( vec = points; vec < points_end; vec++ )
          vec->x /= 3;
d211 2
a212 36
        for ( vec = points; vec < points_end; vec++ )
          vec->y /= 3;
    }

    if ( slot->library->lcd_filter_func )
      slot->library->lcd_filter_func( bitmap, mode, slot->library );

#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    /* render outline into bitmap */
    error = render->raster_render( render->raster, &params );

    /* expand it horizontally */
    if ( hmul )
    {
      FT_Byte*  line = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh--, line += pitch )
      {
        FT_UInt   xx;
        FT_Byte*  end = line + width;


        for ( xx = width_org; xx > 0; xx-- )
        {
          FT_UInt  pixel = line[xx-1];


          end[-3] = (FT_Byte)pixel;
          end[-2] = (FT_Byte)pixel;
          end[-1] = (FT_Byte)pixel;
          end    -= 3;
        }
      }
d215 1
a215 32
    /* expand it vertically */
    if ( vmul )
    {
      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;
      FT_Byte*  write = bitmap->buffer;
      FT_UInt   hh;


      for ( hh = height_org; hh > 0; hh-- )
      {
        ft_memcpy( write, read, pitch );
        write += pitch;

        ft_memcpy( write, read, pitch );
        write += pitch;

        ft_memcpy( write, read, pitch );
        write += pitch;
        read  += pitch;
      }
    }

#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */

    FT_Outline_Translate( outline, x_shift, y_shift );

    /*
     * XXX: on 16bit system, we return an error for huge bitmap
     * to prevent an overflow.
     */
    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )
      return Smooth_Err_Invalid_Pixel_Size;
d221 2
a222 2
    slot->bitmap_left = (FT_Int)x_left;
    slot->bitmap_top  = (FT_Int)y_top;
d243 2
a244 1
                                     FT_RENDER_MODE_NORMAL );
d258 2
a259 1
                                      FT_RENDER_MODE_LCD );
d277 2
a278 1
                                      FT_RENDER_MODE_LCD_V );
d286 4
a289 2
  FT_DEFINE_RENDERER(ft_smooth_renderer_class,

d302 1
a302 1
    ,
d311 2
a312 2
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
  )
d315 4
a318 2
  FT_DEFINE_RENDERER(ft_smooth_lcd_renderer_class,
  
d331 1
a331 1
    ,
d340 2
a341 2
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
  )
a342 1
  FT_DEFINE_RENDERER(ft_smooth_lcdv_renderer_class,
d344 5
d361 1
a361 1
    ,
d370 2
a371 2
    (FT_Raster_Funcs*)    &FT_GRAYS_RASTER_GET
  )
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2000-2016 by                                                 */
d64 1
a64 1
    FT_Error  error = FT_Err_Ok;
d69 1
a69 1
      error = FT_THROW( Invalid_Argument );
d90 1
a90 1
    FT_ZERO( cbox );
d106 1
a106 3
    FT_Outline*  outline = &slot->outline;
    FT_Bitmap*   bitmap  = &slot->bitmap;
    FT_Memory    memory  = render->root.memory;
d108 6
a113 9
    FT_Pos       x_shift = 0;
    FT_Pos       y_shift = 0;
    FT_Pos       x_left, y_top;
    FT_Pos       width, height, pitch;
#ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
    FT_Pos       height_org, width_org;
#endif
    FT_Int       hmul    = ( mode == FT_RENDER_MODE_LCD );
    FT_Int       vmul    = ( mode == FT_RENDER_MODE_LCD_V );
a116 3
    FT_Bool  have_outline_shifted = FALSE;
    FT_Bool  have_buffer          = FALSE;

d121 1
a121 1
      error = FT_THROW( Invalid_Argument );
d127 3
a129 4
    {
      error = FT_THROW( Cannot_Render_Glyph );
      goto Exit;
    }
d131 1
d133 1
a133 4
    {
      x_shift = origin->x;
      y_shift = origin->y;
    }
a135 1
    /* taking into account the origin shift     */
d138 9
a146 10
    cbox.xMin = FT_PIX_FLOOR( cbox.xMin + x_shift );
    cbox.yMin = FT_PIX_FLOOR( cbox.yMin + y_shift );
    cbox.xMax = FT_PIX_CEIL( cbox.xMax + x_shift );
    cbox.yMax = FT_PIX_CEIL( cbox.yMax + y_shift );

    x_shift -= cbox.xMin;
    y_shift -= cbox.yMin;

    x_left  = cbox.xMin >> 6;
    y_top   = cbox.yMax >> 6;
a147 4
    width  = (FT_ULong)( cbox.xMax - cbox.xMin ) >> 6;
    height = (FT_ULong)( cbox.yMax - cbox.yMin ) >> 6;

#ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
a149 1
#endif
d151 8
d162 2
a163 2
      width *= 3;
      pitch  = FT_PAD_CEIL( width, 4 );
d169 5
d183 1
a183 2
        x_shift += 64 * ( extra >> 1 );
        x_left  -= extra >> 1;
d186 1
d191 2
a192 1
        y_shift += 64 * ( extra >> 1 );
a193 1
        height  += 3 * extra;
d199 1
a199 10
    /*
     * XXX: on 16bit system, we return an error for huge bitmap
     * to prevent an overflow.
     */
    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX ||
         x_left < FT_INT_MIN || y_top < FT_INT_MIN )
    {
      error = FT_THROW( Invalid_Pixel_Size );
      goto Exit;
    }
d201 3
a203 3
    /* Required check is (pitch * height < FT_ULONG_MAX),        */
    /* but we care realistic cases only.  Always pitch <= width. */
    if ( width > 0x7FFF || height > 0x7FFF )
d205 1
a205 1
      FT_ERROR(( "ft_smooth_render_generic: glyph too large: %u x %u\n",
d207 1
a207 2
      error = FT_THROW( Raster_Overflow );
      goto Exit;
d210 1
a210 18
    /* release old bitmap buffer */
    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
    {
      FT_FREE( bitmap->buffer );
      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
    }

    /* allocate new one */
    if ( FT_ALLOC( bitmap->buffer, (FT_ULong)( pitch * height ) ) )
      goto Exit;
    else
      have_buffer = TRUE;

    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;

    slot->format      = FT_GLYPH_FORMAT_BITMAP;
    slot->bitmap_left = (FT_Int)x_left;
    slot->bitmap_top  = (FT_Int)y_top;
d214 2
a215 2
    bitmap->width      = (unsigned int)width;
    bitmap->rows       = (unsigned int)height;
d219 6
a224 5
    if ( x_shift || y_shift )
    {
      FT_Outline_Translate( outline, x_shift, y_shift );
      have_outline_shifted = TRUE;
    }
a267 3
    if ( error )
      goto Exit;

a274 2
    if ( error )
      goto Exit;
d326 8
a333 2
    /* everything is fine; don't deallocate buffer */
    have_buffer = FALSE;
d335 6
a340 1
    error = FT_Err_Ok;
d343 2
a344 7
    if ( have_outline_shifted )
      FT_Outline_Translate( outline, -x_shift, -y_shift );
    if ( have_buffer )
    {
      FT_FREE( bitmap->buffer );
      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
    }
d401 1
a401 2
  FT_DEFINE_RENDERER(
    ft_smooth_renderer_class,
d404 1
a404 1
      sizeof ( FT_RendererRec ),
d410 1
a410 1
      NULL,    /* module specific interface */
d412 4
a415 3
      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */
d419 4
a422 4
    (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */
d424 1
a424 1
    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET           /* raster_class    */
d428 2
a429 3
  FT_DEFINE_RENDERER(
    ft_smooth_lcd_renderer_class,

d431 1
a431 1
      sizeof ( FT_RendererRec ),
d437 1
a437 1
      NULL,    /* module specific interface */
d439 4
a442 3
      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */
d446 4
a449 4
    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */
d451 1
a451 1
    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET            /* raster_class    */
d454 1
a454 3

  FT_DEFINE_RENDERER(
    ft_smooth_lcdv_renderer_class,
d457 1
a457 1
      sizeof ( FT_RendererRec ),
d463 1
a463 1
      NULL,    /* module specific interface */
d465 4
a468 3
      (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
      (FT_Module_Destructor) NULL,            /* module_done   */
      (FT_Module_Requester)  NULL,            /* get_interface */
d472 4
a475 4
    (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
    (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
    (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
    (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */
d477 1
a477 1
    (FT_Raster_Funcs*)&FT_GRAYS_RASTER_GET              /* raster_class    */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
