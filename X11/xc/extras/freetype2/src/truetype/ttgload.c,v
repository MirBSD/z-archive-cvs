head	1.7;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.4
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.7
date	2017.04.15.19.22.16;	author tg;	state Exp;
branches;
next	1.6;
commitid	10058F2723111C7BEE2;

1.6
date	2013.08.06.19.48.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	100520152445E05B912;

1.5
date	2008.06.12.20.54.51;	author bsiegert;	state Exp;
branches;
next	1.4;
commitid	10048518C1E44F62885;

1.4
date	2008.02.26.20.05.10;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10047C470A72A1E13CE;

1.3
date	2007.05.22.13.20.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004652EE2C5A0B27EB;

1.2
date	2006.06.29.20.25.10;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.27;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.37.31;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.53;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.24;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.22;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.10;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.7
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttgload.c                                                              */
/*                                                                         */
/*    TrueType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_SFNT_H
#include FT_TRUETYPE_TAGS_H
#include FT_OUTLINE_H
#include FT_TRUETYPE_DRIVER_H
#include FT_LIST_H

#include "ttgload.h"
#include "ttpload.h"

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif

#include "tterrors.h"
#include "ttsubpix.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttgload


  /*************************************************************************/
  /*                                                                       */
  /* Composite glyph flags.                                                */
  /*                                                                       */
#define ARGS_ARE_WORDS             0x0001
#define ARGS_ARE_XY_VALUES         0x0002
#define ROUND_XY_TO_GRID           0x0004
#define WE_HAVE_A_SCALE            0x0008
/* reserved                        0x0010 */
#define MORE_COMPONENTS            0x0020
#define WE_HAVE_AN_XY_SCALE        0x0040
#define WE_HAVE_A_2X2              0x0080
#define WE_HAVE_INSTR              0x0100
#define USE_MY_METRICS             0x0200
#define OVERLAP_COMPOUND           0x0400
#define SCALED_COMPONENT_OFFSET    0x0800
#define UNSCALED_COMPONENT_OFFSET  0x1000


  /*************************************************************************/
  /*                                                                       */
  /* Return the horizontal metrics in font units for a given glyph.        */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Get_HMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Short*   lsb,
                   FT_UShort*  aw )
  {
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );

    FT_TRACE5(( "  advance width (font units): %d\n", *aw ));
    FT_TRACE5(( "  left side bearing (font units): %d\n", *lsb ));
  }


  /*************************************************************************/
  /*                                                                       */
  /* Return the vertical metrics in font units for a given glyph.          */
  /* See macro `TT_LOADER_SET_PP' below for explanations.                  */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Get_VMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Pos      yMax,
                   FT_Short*   tsb,
                   FT_UShort*  ah )
  {
    if ( face->vertical_info )
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );

    else if ( face->os2.version != 0xFFFFU )
    {
      *tsb = (FT_Short)( face->os2.sTypoAscender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->os2.sTypoAscender -
                                face->os2.sTypoDescender );
    }

    else
    {
      *tsb = (FT_Short)( face->horizontal.Ascender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->horizontal.Ascender -
                                face->horizontal.Descender );
    }

    FT_TRACE5(( "  advance height (font units): %d\n", *ah ));
    FT_TRACE5(( "  top side bearing (font units): %d\n", *tsb ));
  }


  static FT_Error
  tt_get_metrics( TT_Loader  loader,
                  FT_UInt    glyph_index )
  {
    TT_Face    face   = loader->face;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    FT_Error   error;
    FT_Stream  stream = loader->stream;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;

    /* we must preserve the stream position          */
    /* (which gets altered by the metrics functions) */
    FT_ULong  pos = FT_STREAM_POS();


    TT_Get_HMetrics( face, glyph_index,
                     &left_bearing,
                     &advance_width );
    TT_Get_VMetrics( face, glyph_index,
                     loader->bbox.yMax,
                     &top_bearing,
                     &advance_height );

    if ( FT_STREAM_SEEK( pos ) )
      return error;

    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
         loader->exec                                             )
    {
      loader->exec->sph_tweak_flags = 0;

      /* This may not be the right place for this, but it works...  */
      /* Note that we have to unconditionally load the tweaks since */
      /* it is possible that glyphs individually switch ClearType's */
      /* backwards compatibility mode on and off.                   */
      sph_set_tweaks( loader, glyph_index );
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }

    return FT_Err_Ok;
  }


#ifdef FT_CONFIG_OPTION_INCREMENTAL

  static void
  tt_get_metrics_incr_overrides( TT_Loader  loader,
                                 FT_UInt    glyph_index )
  {
    TT_Face  face = loader->face;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;


    /* If this is an incrementally loaded font check whether there are */
    /* overriding metrics for this glyph.                              */
    if ( face->root.internal->incremental_interface                           &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec  metrics;
      FT_Error                   error;


      metrics.bearing_x = loader->left_bearing;
      metrics.bearing_y = 0;
      metrics.advance   = loader->advance;
      metrics.advance_v = 0;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, FALSE, &metrics );
      if ( error )
        goto Exit;

      left_bearing  = (FT_Short)metrics.bearing_x;
      advance_width = (FT_UShort)metrics.advance;

#if 0

      /* GWW: Do I do the same for vertical metrics? */
      metrics.bearing_x = 0;
      metrics.bearing_y = loader->top_bearing;
      metrics.advance   = loader->vadvance;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, TRUE, &metrics );
      if ( error )
        goto Exit;

      top_bearing    = (FT_Short)metrics.bearing_y;
      advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
      loader->top_bearing  = top_bearing;
      loader->vadvance     = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear     = advance_width;
      }
    }

  Exit:
    return;
  }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */


  /*************************************************************************/
  /*                                                                       */
  /* The following functions are used by default with TrueType fonts.      */
  /* However, they can be replaced by alternatives if we need to support   */
  /* TrueType-compressed formats (like MicroType) in the future.           */
  /*                                                                       */
  /*************************************************************************/

  FT_CALLBACK_DEF( FT_Error )
  TT_Access_Glyph_Frame( TT_Loader  loader,
                         FT_UInt    glyph_index,
                         FT_ULong   offset,
                         FT_UInt    byte_count )
  {
    FT_Error   error;
    FT_Stream  stream = loader->stream;

    /* for non-debug mode */
    FT_UNUSED( glyph_index );


    FT_TRACE4(( "Glyph %ld\n", glyph_index ));

    /* the following line sets the `error' variable through macros! */
    if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
      return error;

    loader->cursor = stream->cursor;
    loader->limit  = stream->limit;

    return FT_Err_Ok;
  }


  FT_CALLBACK_DEF( void )
  TT_Forget_Glyph_Frame( TT_Loader  loader )
  {
    FT_Stream  stream = loader->stream;


    FT_FRAME_EXIT();
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Glyph_Header( TT_Loader  loader )
  {
    FT_Byte*  p     = loader->cursor;
    FT_Byte*  limit = loader->limit;


    if ( p + 10 > limit )
      return FT_THROW( Invalid_Outline );

    loader->n_contours = FT_NEXT_SHORT( p );

    loader->bbox.xMin = FT_NEXT_SHORT( p );
    loader->bbox.yMin = FT_NEXT_SHORT( p );
    loader->bbox.xMax = FT_NEXT_SHORT( p );
    loader->bbox.yMax = FT_NEXT_SHORT( p );

    FT_TRACE5(( "  # of contours: %d\n", loader->n_contours ));
    FT_TRACE5(( "  xMin: %4d  xMax: %4d\n", loader->bbox.xMin,
                                            loader->bbox.xMax ));
    FT_TRACE5(( "  yMin: %4d  yMax: %4d\n", loader->bbox.yMin,
                                            loader->bbox.yMax ));
    loader->cursor = p;

    return FT_Err_Ok;
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Simple_Glyph( TT_Loader  load )
  {
    FT_Error        error;
    FT_Byte*        p          = load->cursor;
    FT_Byte*        limit      = load->limit;
    FT_GlyphLoader  gloader    = load->gloader;
    FT_Int          n_contours = load->n_contours;
    FT_Outline*     outline;
    FT_UShort       n_ins;
    FT_Int          n_points;
    FT_ULong        tmp;

    FT_Byte         *flag, *flag_limit;
    FT_Byte         c, count;
    FT_Vector       *vec, *vec_limit;
    FT_Pos          x;
    FT_Short        *cont, *cont_limit, prev_cont;
    FT_Int          xy_size = 0;


    /* check that we can add the contours to the glyph */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
    if ( error )
      goto Fail;

    /* reading the contours' endpoints & number of points */
    cont       = gloader->current.outline.contours;
    cont_limit = cont + n_contours;

    /* check space for contours array + instructions count */
    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
      goto Invalid_Outline;

    prev_cont = FT_NEXT_SHORT( p );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

    if ( prev_cont < 0 )
      goto Invalid_Outline;

    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = FT_NEXT_SHORT( p );
      if ( cont[0] <= prev_cont )
      {
        /* unordered contours: this is invalid */
        goto Invalid_Outline;
      }
      prev_cont = cont[0];
    }

    n_points = 0;
    if ( n_contours > 0 )
    {
      n_points = cont[-1] + 1;
      if ( n_points < 0 )
        goto Invalid_Outline;
    }

    /* note that we will add four phantom points later */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
    if ( error )
      goto Fail;

    /* reading the bytecode instructions */
    load->glyph->control_len  = 0;
    load->glyph->control_data = NULL;

    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = FT_NEXT_USHORT( p );

    FT_TRACE5(( "  Instructions size: %u\n", n_ins ));

    /* check it */
    if ( ( limit - p ) < n_ins )
    {
      FT_TRACE0(( "TT_Load_Simple_Glyph: instruction count mismatch\n" ));
      error = FT_THROW( Too_Many_Hints );
      goto Fail;
    }

#ifdef TT_USE_BYTECODE_INTERPRETER

    if ( IS_HINTED( load->load_flags ) )
    {
      /* we don't trust `maxSizeOfInstructions' in the `maxp' table */
      /* and thus update the bytecode array size by ourselves       */

      tmp   = load->exec->glyphSize;
      error = Update_Max( load->exec->memory,
                          &tmp,
                          sizeof ( FT_Byte ),
                          (void*)&load->exec->glyphIns,
                          n_ins );

      load->exec->glyphSize = (FT_UShort)tmp;
      if ( error )
        return error;

      load->glyph->control_len  = n_ins;
      load->glyph->control_data = load->exec->glyphIns;

      if ( n_ins )
        FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
    }

#endif /* TT_USE_BYTECODE_INTERPRETER */

    p += n_ins;

    outline = &gloader->current.outline;

    /* reading the point tags */
    flag       = (FT_Byte*)outline->tags;
    flag_limit = flag + n_points;

    FT_ASSERT( flag );

    while ( flag < flag_limit )
    {
      if ( p + 1 > limit )
        goto Invalid_Outline;

      *flag++ = c = FT_NEXT_BYTE( p );
      if ( c & 8 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        count = FT_NEXT_BYTE( p );
        if ( flag + (FT_Int)count > flag_limit )
          goto Invalid_Outline;

        for ( ; count > 0; count-- )
          *flag++ = c;
      }
    }

    /* reading the X coordinates */

    vec       = outline->points;
    vec_limit = vec + n_points;
    flag      = (FT_Byte*)outline->tags;
    x         = 0;

    if ( p + xy_size > limit )
      goto Invalid_Outline;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos   y = 0;
      FT_Byte  f = *flag;


      if ( f & 2 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 16 ) == 0 )
          y = -y;
      }
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }

      x     += y;
      vec->x = x;
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & ~( 2 | 16 ) );
    }

    /* reading the Y coordinates */

    vec       = gloader->current.outline.points;
    vec_limit = vec + n_points;
    flag      = (FT_Byte*)outline->tags;
    x         = 0;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos   y = 0;
      FT_Byte  f = *flag;


      if ( f & 4 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 32 ) == 0 )
          y = -y;
      }
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }

      x     += y;
      vec->y = x;
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & FT_CURVE_TAG_ON );
    }

    outline->n_points   = (FT_Short)n_points;
    outline->n_contours = (FT_Short)n_contours;

    load->cursor = p;

  Fail:
    return error;

  Invalid_Outline:
    error = FT_THROW( Invalid_Outline );
    goto Fail;
  }


  FT_CALLBACK_DEF( FT_Error )
  TT_Load_Composite_Glyph( TT_Loader  loader )
  {
    FT_Error        error;
    FT_Byte*        p       = loader->cursor;
    FT_Byte*        limit   = loader->limit;
    FT_GlyphLoader  gloader = loader->gloader;
    FT_SubGlyph     subglyph;
    FT_UInt         num_subglyphs;


    num_subglyphs = 0;

    do
    {
      FT_Fixed  xx, xy, yy, yx;
      FT_UInt   count;


      /* check that we can load a new subglyph */
      error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
      if ( error )
        goto Fail;

      /* check space */
      if ( p + 4 > limit )
        goto Invalid_Composite;

      subglyph = gloader->current.subglyphs + num_subglyphs;

      subglyph->arg1 = subglyph->arg2 = 0;

      subglyph->flags = FT_NEXT_USHORT( p );
      subglyph->index = FT_NEXT_USHORT( p );

      /* check space */
      count = 2;
      if ( subglyph->flags & ARGS_ARE_WORDS )
        count += 2;
      if ( subglyph->flags & WE_HAVE_A_SCALE )
        count += 2;
      else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
        count += 4;
      else if ( subglyph->flags & WE_HAVE_A_2X2 )
        count += 8;

      if ( p + count > limit )
        goto Invalid_Composite;

      /* read arguments */
      if ( subglyph->flags & ARGS_ARE_XY_VALUES )
      {
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = FT_NEXT_SHORT( p );
          subglyph->arg2 = FT_NEXT_SHORT( p );
        }
        else
        {
          subglyph->arg1 = FT_NEXT_CHAR( p );
          subglyph->arg2 = FT_NEXT_CHAR( p );
        }
      }
      else
      {
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_USHORT( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_USHORT( p );
        }
        else
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_BYTE( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_BYTE( p );
        }
      }

      /* read transform */
      xx = yy = 0x10000L;
      xy = yx = 0;

      if ( subglyph->flags & WE_HAVE_A_SCALE )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = xx;
      }
      else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
      }
      else if ( subglyph->flags & WE_HAVE_A_2X2 )
      {
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
      }

      subglyph->transform.xx = xx;
      subglyph->transform.xy = xy;
      subglyph->transform.yx = yx;
      subglyph->transform.yy = yy;

      num_subglyphs++;

    } while ( subglyph->flags & MORE_COMPONENTS );

    gloader->current.num_subglyphs = num_subglyphs;
    FT_TRACE5(( "  %d components\n", num_subglyphs ));

#ifdef TT_USE_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;


      /* we must undo the FT_FRAME_ENTER in order to point */
      /* to the composite instructions, if we find some.   */
      /* We will process them later.                       */
      /*                                                   */
      loader->ins_pos = (FT_ULong)( FT_STREAM_POS() +
                                    p - limit );
    }

#endif

    loader->cursor = p;

  Fail:
    return error;

  Invalid_Composite:
    error = FT_THROW( Invalid_Composite );
    goto Fail;
  }


  FT_LOCAL_DEF( void )
  TT_Init_Glyph_Loading( TT_Face  face )
  {
    face->access_glyph_frame   = TT_Access_Glyph_Frame;
    face->read_glyph_header    = TT_Load_Glyph_Header;
    face->read_simple_glyph    = TT_Load_Simple_Glyph;
    face->read_composite_glyph = TT_Load_Composite_Glyph;
    face->forget_glyph_frame   = TT_Forget_Glyph_Frame;
  }


  static void
  tt_prepare_zone( TT_GlyphZone  zone,
                   FT_GlyphLoad  load,
                   FT_UInt       start_point,
                   FT_UInt       start_contour )
  {
    zone->n_points    = (FT_UShort)load->outline.n_points -
                          (FT_UShort)start_point;
    zone->n_contours  = load->outline.n_contours -
                          (FT_Short)start_contour;
    zone->org         = load->extra_points + start_point;
    zone->cur         = load->outline.points + start_point;
    zone->orus        = load->extra_points2 + start_point;
    zone->tags        = (FT_Byte*)load->outline.tags + start_point;
    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Hint_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Hint the glyph using the zone prepared by the caller.  Note that   */
  /*    the zone is supposed to include four phantom points.               */
  /*                                                                       */
  static FT_Error
  TT_Hint_Glyph( TT_Loader  loader,
                 FT_Bool    is_composite )
  {
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Face    face   = loader->face;
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    TT_GlyphZone  zone = &loader->zone;

#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_Long       n_ins;
#else
    FT_UNUSED( is_composite );
#endif


#ifdef TT_USE_BYTECODE_INTERPRETER
    if ( loader->glyph->control_len > 0xFFFFL )
    {
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions" ));
      FT_TRACE1(( " (0x%lx byte) is truncated\n",
                 loader->glyph->control_len ));
    }
    n_ins = loader->glyph->control_len;

    /* save original point position in org */
    if ( n_ins > 0 )
      FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );

    /* Reset graphics state. */
    loader->exec->GS = loader->size->GS;

    /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
    /*      completely refer to the (already) hinted subglyphs.     */
    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      FT_ARRAY_COPY( zone->orus, zone->cur, zone->n_points );
    }
    else
    {
      loader->exec->metrics.x_scale = loader->size->metrics.x_scale;
      loader->exec->metrics.y_scale = loader->size->metrics.y_scale;
    }
#endif

    /* round phantom points */
    zone->cur[zone->n_points - 4].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 4].x );
    zone->cur[zone->n_points - 3].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 3].x );
    zone->cur[zone->n_points - 2].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 2].y );
    zone->cur[zone->n_points - 1].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 1].y );

#ifdef TT_USE_BYTECODE_INTERPRETER

    if ( n_ins > 0 )
    {
      FT_Error  error;

      FT_GlyphLoader  gloader         = loader->gloader;
      FT_Outline      current_outline = gloader->current.outline;


      TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                        loader->exec->glyphIns, n_ins );

      loader->exec->is_composite = is_composite;
      loader->exec->pts          = *zone;

      error = TT_Run_Context( loader->exec );
      if ( error && loader->exec->pedantic_hinting )
        return error;

      /* store drop-out mode in bits 5-7; set bit 2 also as a marker */
      current_outline.tags[0] |=
        ( loader->exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;
    }

#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* Save possibly modified glyph phantom points unless in v40 backwards */
    /* compatibility mode, where no movement on the x axis means no reason */
    /* to change bearings or advance widths.                               */
    if ( !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            !loader->exec->backwards_compatibility ) )
    {
#endif
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );

      else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Simple_Glyph                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a simple glyph has been loaded, it needs to be processed.     */
  /*    Usually, this means scaling and hinting through bytecode           */
  /*    interpretation.                                                    */
  /*                                                                       */
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader  loader )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Error        error   = FT_Err_Ok;
    FT_Outline*     outline;
    FT_Int          n_points;


    outline  = &gloader->current.outline;
    n_points = outline->n_points;

    /* set phantom points */

    outline->points[n_points    ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;

    outline->tags[n_points    ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;

    n_points += 4;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

    if ( loader->face->doblend && !loader->face->is_default_instance )
    {
      /* Deltas apply to the unscaled data. */
      error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                          loader->glyph_index,
                                          outline,
                                          (FT_UInt)n_points );

      /* recalculate linear horizontal and vertical advances */
      /* if we don't have HVAR and VVAR, respectively        */
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
        loader->linear = outline->points[n_points - 3].x -
                         outline->points[n_points - 4].x;
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
        loader->vadvance = outline->points[n_points - 1].x -
                           outline->points[n_points - 2].x;

      if ( error )
        return error;
    }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

    if ( IS_HINTED( loader->load_flags ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
                     loader->zone.n_points + 4 );
    }

    {
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      TT_Face    face   = loader->face;
      TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );

      FT_String*  family         = face->root.family_name;
      FT_UInt     ppem           = loader->size->metrics.x_ppem;
      FT_String*  style          = face->root.style_name;
      FT_UInt     x_scale_factor = 1000;
#endif

      FT_Vector*  vec   = outline->points;
      FT_Vector*  limit = outline->points + n_points;

      FT_Fixed  x_scale = 0; /* pacify compiler */
      FT_Fixed  y_scale = 0;

      FT_Bool  do_scale = FALSE;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* scale, but only if enabled and only if TT hinting is being used */
        if ( IS_HINTED( loader->load_flags ) )
          x_scale_factor = sph_test_tweak_x_scaling( face,
                                                     family,
                                                     ppem,
                                                     style,
                                                     loader->glyph_index );
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||
             x_scale_factor != 1000                         )
        {
          x_scale = FT_MulDiv( loader->size->metrics.x_scale,
                               (FT_Long)x_scale_factor, 1000 );
          y_scale = loader->size->metrics.y_scale;

          /* compensate for any scaling by de/emboldening; */
          /* the amount was determined via experimentation */
          if ( x_scale_factor != 1000 && ppem > 11 )
            FT_Outline_EmboldenXY( outline,
                                   FT_MulFix( 1280 * ppem,
                                              1000 - x_scale_factor ),
                                   0 );
          do_scale = TRUE;
        }
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
        {
          x_scale = loader->size->metrics.x_scale;
          y_scale = loader->size->metrics.y_scale;

          do_scale = TRUE;
        }
      }

      if ( do_scale )
      {
        for ( ; vec < limit; vec++ )
        {
          vec->x = FT_MulFix( vec->x, x_scale );
          vec->y = FT_MulFix( vec->y, y_scale );
        }

        loader->pp1 = outline->points[n_points - 4];
        loader->pp2 = outline->points[n_points - 3];
        loader->pp3 = outline->points[n_points - 2];
        loader->pp4 = outline->points[n_points - 1];
      }
    }

    if ( IS_HINTED( loader->load_flags ) )
    {
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
    }

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Component                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a composite component has been loaded, it needs to be         */
  /*    processed.  Usually, this means transforming and translating.      */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Component( TT_Loader    loader,
                                  FT_SubGlyph  subglyph,
                                  FT_UInt      start_point,
                                  FT_UInt      num_base_points )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Outline      current;
    FT_Bool         have_scale;
    FT_Pos          x, y;


    current.points   = gloader->base.outline.points +
                         num_base_points;
    current.n_points = gloader->base.outline.n_points -
                         (short)num_base_points;

    have_scale = FT_BOOL( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                              WE_HAVE_AN_XY_SCALE |
                                              WE_HAVE_A_2X2       ) );

    /* perform the transform required for this subglyph */
    if ( have_scale )
      FT_Outline_Transform( &current, &subglyph->transform );

    /* get offset */
    if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
    {
      FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;
      FT_UInt     k = (FT_UInt)subglyph->arg1;
      FT_UInt     l = (FT_UInt)subglyph->arg2;
      FT_Vector*  p1;
      FT_Vector*  p2;


      /* match l-th point of the newly loaded component to the k-th point */
      /* of the previously loaded components.                             */

      /* change to the point numbers used by our outline */
      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points      )
        return FT_THROW( Invalid_Composite );

      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;

      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;

      if ( !x && !y )
        return FT_Err_Ok;

      /* Use a default value dependent on                                  */
      /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
      /* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */

      if ( have_scale &&
#ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
           !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) )
#else
            ( subglyph->flags & SCALED_COMPONENT_OFFSET ) )
#endif
      {

#if 0

        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is what Apple documents.  But it doesn't work.   */
        /*                                                                 */
        int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                            : -subglyph->transform.xx;
        int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                            : -subglyph->transform.yx;
        int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                            : -subglyph->transform.xy;
        int  d = subglyph->transform.yy > 0 ?  subglyph->transform.yy
                                            : -subglyph->transform.yy;
        int  m = a > b ? a : b;
        int  n = c > d ? c : d;


        if ( a - b <= 33 && a - b >= -33 )
          m *= 2;
        if ( c - d <= 33 && c - d >= -33 )
          n *= 2;
        x = FT_MulFix( x, m );
        y = FT_MulFix( y, n );

#else /* 1 */

        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is a guess and works much better than the above. */
        /*                                                                 */
        FT_Fixed  mac_xscale = FT_Hypot( subglyph->transform.xx,
                                         subglyph->transform.xy );
        FT_Fixed  mac_yscale = FT_Hypot( subglyph->transform.yy,
                                         subglyph->transform.yx );


        x = FT_MulFix( x, mac_xscale );
        y = FT_MulFix( y, mac_yscale );

#endif /* 1 */

      }

      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        FT_Fixed  x_scale = loader->size->metrics.x_scale;
        FT_Fixed  y_scale = loader->size->metrics.y_scale;


        x = FT_MulFix( x, x_scale );
        y = FT_MulFix( y, y_scale );

        if ( subglyph->flags & ROUND_XY_TO_GRID )
        {
          x = FT_PIX_ROUND( x );
          y = FT_PIX_ROUND( y );
        }
      }
    }

    if ( x || y )
      FT_Outline_Translate( &current, x, y );

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Glyph                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is slightly different from TT_Process_Simple_Glyph, in that   */
  /*    its sole purpose is to hint the glyph.  Thus this function is      */
  /*    only available when bytecode interpreter is enabled.               */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader  loader,
                              FT_UInt    start_point,
                              FT_UInt    start_contour )
  {
    FT_Error     error;
    FT_Outline*  outline;
    FT_UInt      i;


    outline = &loader->gloader->base.outline;

    /* make room for phantom points */
    error = FT_GLYPHLOADER_CHECK_POINTS( loader->gloader,
                                         outline->n_points + 4,
                                         0 );
    if ( error )
      return error;

    outline->points[outline->n_points    ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points    ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;

#ifdef TT_USE_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;
      FT_UShort  n_ins, max_ins;
      FT_ULong   tmp;


      /* TT_Load_Composite_Glyph only gives us the offset of instructions */
      /* so we read them here                                             */
      if ( FT_STREAM_SEEK( loader->ins_pos ) ||
           FT_READ_USHORT( n_ins )           )
        return error;

      FT_TRACE5(( "  Instructions size = %d\n", n_ins ));

      /* check it */
      max_ins = loader->face->max_profile.maxSizeOfInstructions;
      if ( n_ins > max_ins )
      {
        /* don't trust `maxSizeOfInstructions'; */
        /* only do a rough safety check         */
        if ( (FT_Int)n_ins > loader->byte_len )
        {
          FT_TRACE1(( "TT_Process_Composite_Glyph:"
                      " too many instructions (%d) for glyph with length %d\n",
                      n_ins, loader->byte_len ));
          return FT_THROW( Too_Many_Hints );
        }

        tmp   = loader->exec->glyphSize;
        error = Update_Max( loader->exec->memory,
                            &tmp,
                            sizeof ( FT_Byte ),
                            (void*)&loader->exec->glyphIns,
                            n_ins );

        loader->exec->glyphSize = (FT_UShort)tmp;
        if ( error )
          return error;
      }
      else if ( n_ins == 0 )
        return FT_Err_Ok;

      if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len  = n_ins;
    }

#endif

    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );

    /* Some points are likely touched during execution of  */
    /* instructions on components.  So let's untouch them. */
    for ( i = 0; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~FT_CURVE_TAG_TOUCH_BOTH;

    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }


  /*
   * Calculate the phantom points
   *
   * Defining the right side bearing (rsb) as
   *
   *   rsb = aw - (lsb + xmax - xmin)
   *
   * (with `aw' the advance width, `lsb' the left side bearing, and `xmin'
   * and `xmax' the glyph's minimum and maximum x value), the OpenType
   * specification defines the initial position of horizontal phantom points
   * as
   *
   *   pp1 = (round(xmin - lsb), 0)      ,
   *   pp2 = (round(pp1 + aw), 0)        .
   *
   * Note that the rounding to the grid (in the device space) is not
   * documented currently in the specification.
   *
   * However, the specification lacks the precise definition of vertical
   * phantom points.  Greg Hitchcock provided the following explanation.
   *
   * - a `vmtx' table is present
   *
   *   For any glyph, the minimum and maximum y values (`ymin' and `ymax')
   *   are given in the `glyf' table, the top side bearing (tsb) and advance
   *   height (ah) are given in the `vmtx' table.  The bottom side bearing
   *   (bsb) is then calculated as
   *
   *     bsb = ah - (tsb + ymax - ymin)       ,
   *
   *   and the initial position of vertical phantom points is
   *
   *     pp3 = (x, round(ymax + tsb))       ,
   *     pp4 = (x, round(pp3 - ah))         .
   *
   *   See below for value `x'.
   *
   * - no `vmtx' table in the font
   *
   *   If there is an `OS/2' table, we set
   *
   *     DefaultAscender = sTypoAscender       ,
   *     DefaultDescender = sTypoDescender     ,
   *
   *   otherwise we use data from the `hhea' table:
   *
   *     DefaultAscender = Ascender         ,
   *     DefaultDescender = Descender       .
   *
   *   With these two variables we can now set
   *
   *     ah = DefaultAscender - sDefaultDescender    ,
   *     tsb = DefaultAscender - yMax                ,
   *
   *   and proceed as if a `vmtx' table was present.
   *
   * Usually we have
   *
   *   x = aw / 2      ,                                                (1)
   *
   * but there is one compatibility case where it can be set to
   *
   *   x = -DefaultDescender -
   *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)
   *
   * and another one with
   *
   *   x = 0     .                                                      (3)
   *
   * In Windows, the history of those values is quite complicated,
   * depending on the hinting engine (that is, the graphics framework).
   *
   *   framework        from                 to       formula
   *  ----------------------------------------------------------
   *    GDI       Windows 98               current      (1)
   *              (Windows 2000 for NT)
   *    GDI+      Windows XP               Windows 7    (2)
   *    GDI+      Windows 8                current      (3)
   *    DWrite    Windows 7                current      (3)
   *
   * For simplicity, FreeType uses (1) for grayscale subpixel hinting and
   * (3) for everything else.
   *
   */
  static void
  tt_loader_set_pp( TT_Loader  loader )
  {
    FT_Bool  subpixel_hinting = 0;
    FT_Bool  grayscale        = 0;
    FT_Bool  use_aw_2         = 0;

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale
                                      : 0;
    }
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting_lean
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale_cleartype
                                      : 0;
    }
#endif

    use_aw_2 = (FT_Bool)( subpixel_hinting && grayscale );

    loader->pp1.x = loader->bbox.xMin - loader->left_bearing;
    loader->pp1.y = 0;
    loader->pp2.x = loader->pp1.x + loader->advance;
    loader->pp2.y = 0;

    loader->pp3.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp3.y = loader->bbox.yMax + loader->top_bearing;
    loader->pp4.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp4.y = loader->pp3.y - loader->vadvance;
  }


  /* a utility function to retrieve i-th node from given FT_List */
  static FT_ListNode
  ft_list_get_node_at( FT_List  list,
                       FT_UInt  index )
  {
    FT_ListNode  cur;


    if ( !list )
      return NULL;

    for ( cur = list->head; cur; cur = cur->next )
    {
      if ( !index )
        return cur;

      index--;
    }

    return NULL;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    load_truetype_glyph                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads a given truetype glyph.  Handles composites and uses a       */
  /*    TT_Loader object.                                                  */
  /*                                                                       */
  static FT_Error
  load_truetype_glyph( TT_Loader  loader,
                       FT_UInt    glyph_index,
                       FT_UInt    recurse_count,
                       FT_Bool    header_only )
  {
    FT_Error        error        = FT_Err_Ok;
    FT_Fixed        x_scale, y_scale;
    FT_ULong        offset;
    TT_Face         face         = loader->face;
    FT_GlyphLoader  gloader      = loader->gloader;
    FT_Bool         opened_frame = 0;

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    FT_StreamRec    inc_stream;
    FT_Data         glyph_data;
    FT_Bool         glyph_data_loaded = 0;
#endif


#ifdef FT_DEBUG_LEVEL_TRACE
    if ( recurse_count )
      FT_TRACE5(( "  nesting level: %d\n", recurse_count ));
#endif

    /* some fonts have an incorrect value of `maxComponentDepth' */
    if ( recurse_count > face->max_profile.maxComponentDepth )
    {
      FT_TRACE1(( "load_truetype_glyph: maxComponentDepth set to %d\n",
                  recurse_count ));
      face->max_profile.maxComponentDepth = (FT_UShort)recurse_count;
    }

#ifndef FT_CONFIG_OPTION_INCREMENTAL
    /* check glyph index */
    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
    {
      error = FT_THROW( Invalid_Glyph_Index );
      goto Exit;
    }
#endif

    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      x_scale = loader->size->metrics.x_scale;
      y_scale = loader->size->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }

    /* Set `offset' to the start of the glyph relative to the start of */
    /* the `glyf' table, and `byte_len' to the length of the glyph in  */
    /* bytes.                                                          */

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    /* If we are loading glyph data via the incremental interface, set */
    /* the loader stream to a memory stream reading the data returned  */
    /* by the interface.                                               */
    if ( face->root.internal->incremental_interface )
    {
      error = face->root.internal->incremental_interface->funcs->get_glyph_data(
                face->root.internal->incremental_interface->object,
                glyph_index, &glyph_data );
      if ( error )
        goto Exit;

      glyph_data_loaded = 1;
      offset            = 0;
      loader->byte_len  = glyph_data.length;

      FT_ZERO( &inc_stream );
      FT_Stream_OpenMemory( &inc_stream,
                            glyph_data.pointer,
                            (FT_ULong)glyph_data.length );

      loader->stream = &inc_stream;
    }
    else

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );

    if ( loader->byte_len > 0 )
    {
#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* for the incremental interface, `glyf_offset' is always zero */
      if ( !face->glyf_offset                          &&
           !face->root.internal->incremental_interface )
#else
      if ( !face->glyf_offset )
#endif /* FT_CONFIG_OPTION_INCREMENTAL */
      {
        FT_TRACE2(( "no `glyf' table but non-zero `loca' entry\n" ));
        error = FT_THROW( Invalid_Table );
        goto Exit;
      }

      error = face->access_glyph_frame( loader, glyph_index,
                                        face->glyf_offset + offset,
                                        (FT_UInt)loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;

      /* read glyph header first */
      error = face->read_glyph_header( loader );
      if ( error )
        goto Exit;

      /* the metrics must be computed after loading the glyph header */
      /* since we need the glyph's `yMax' value in case the vertical */
      /* metrics must be emulated                                    */
      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
    {
      loader->bbox.xMin = 0;
      loader->bbox.xMax = 0;
      loader->bbox.yMin = 0;
      loader->bbox.yMax = 0;

      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;

      /* must initialize points before (possibly) overriding */
      /* glyph metrics from the incremental interface        */
      tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      tt_get_metrics_incr_overrides( loader, glyph_index );
#endif

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( loader->face->doblend && !loader->face->is_default_instance )
      {
        /* a small outline structure with four elements for */
        /* communication with `TT_Vary_Apply_Glyph_Deltas'  */
        FT_Vector   points[4];
        char        tags[4]     = { 1, 1, 1, 1 };
        short       contours[4] = { 0, 1, 2, 3 };
        FT_Outline  outline;


        points[0].x = loader->pp1.x;
        points[0].y = loader->pp1.y;
        points[1].x = loader->pp2.x;
        points[1].y = loader->pp2.y;

        points[2].x = loader->pp3.x;
        points[2].y = loader->pp3.y;
        points[3].x = loader->pp4.x;
        points[3].y = loader->pp4.y;

        outline.n_points   = 4;
        outline.n_contours = 4;
        outline.points     = points;
        outline.tags       = tags;
        outline.contours   = contours;

        /* this must be done before scaling */
        error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                            glyph_index,
                                            &outline,
                                            (FT_UInt)outline.n_points );
        if ( error )
          goto Exit;

        loader->pp1.x = points[0].x;
        loader->pp1.y = points[0].y;
        loader->pp2.x = points[1].x;
        loader->pp2.y = points[1].y;

        loader->pp3.x = points[2].x;
        loader->pp3.y = points[2].y;
        loader->pp4.x = points[3].x;
        loader->pp4.y = points[3].y;


        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;
      }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

      error = FT_Err_Ok;
      goto Exit;
    }

    /* must initialize phantom points before (possibly) overriding */
    /* glyph metrics from the incremental interface                */
    tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    tt_get_metrics_incr_overrides( loader, glyph_index );
#endif

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

    /* if it is a simple glyph, load it */

    if ( loader->n_contours > 0 )
    {
      error = face->read_simple_glyph( loader );
      if ( error )
        goto Exit;

      /* all data have been read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;

      error = TT_Process_Simple_Glyph( loader );
      if ( error )
        goto Exit;

      FT_GlyphLoader_Add( gloader );
    }

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

    /* otherwise, load a composite! */
    else if ( loader->n_contours == -1 )
    {
      FT_Memory  memory = face->root.memory;

      FT_UInt   start_point;
      FT_UInt   start_contour;
      FT_ULong  ins_pos;  /* position of composite instructions, if any */

      FT_ListNode  node, node2;


      /*
       * We store the glyph index directly in the `node->data' pointer,
       * following the glib solution (cf. macro `GUINT_TO_POINTER') with a
       * double cast to make this portable.  Note, however, that this needs
       * pointers with a width of at least 32 bits.
       */


      /* clear the nodes filled by sibling chains */
      node = ft_list_get_node_at( &loader->composites, recurse_count );
      for ( node2 = node; node2; node2 = node2->next )
        node2->data = (void*)ULONG_MAX;

      /* check whether we already have a composite glyph with this index */
      if ( FT_List_Find( &loader->composites,
                         (void*)(unsigned long)glyph_index ) )
      {
        FT_TRACE1(( "TT_Load_Composite_Glyph:"
                    " infinite recursion detected\n" ));
        error = FT_THROW( Invalid_Composite );
        goto Exit;
      }

      else if ( node )
        node->data = (void*)(unsigned long)glyph_index;

      else
      {
        if ( FT_NEW( node ) )
          goto Exit;
        node->data = (void*)(unsigned long)glyph_index;
        FT_List_Add( &loader->composites, node );
      }

      start_point   = (FT_UInt)gloader->base.outline.n_points;
      start_contour = (FT_UInt)gloader->base.outline.n_contours;

      /* for each subglyph, read composite header */
      error = face->read_composite_glyph( loader );
      if ( error )
        goto Exit;

      /* store the offset of instructions */
      ins_pos = loader->ins_pos;

      /* all data we need are read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( face->doblend && !face->is_default_instance )
      {
        short        i, limit;
        FT_SubGlyph  subglyph;

        FT_Outline  outline;
        FT_Vector*  points   = NULL;
        char*       tags     = NULL;
        short*      contours = NULL;


        limit = (short)gloader->current.num_subglyphs;

        /* construct an outline structure for              */
        /* communication with `TT_Vary_Apply_Glyph_Deltas' */
        outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );
        outline.n_contours = outline.n_points;

        outline.points   = NULL;
        outline.tags     = NULL;
        outline.contours = NULL;

        if ( FT_NEW_ARRAY( points, outline.n_points )   ||
             FT_NEW_ARRAY( tags, outline.n_points )     ||
             FT_NEW_ARRAY( contours, outline.n_points ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {
          /* applying deltas for anchor points doesn't make sense, */
          /* but we don't have to specially check this since       */
          /* unused delta values are zero anyways                  */
          points[i].x = subglyph->arg1;
          points[i].y = subglyph->arg2;
          tags[i]     = 1;
          contours[i] = i;
        }

        points[i].x = loader->pp1.x;
        points[i].y = loader->pp1.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp2.x;
        points[i].y = loader->pp2.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp3.x;
        points[i].y = loader->pp3.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp4.x;
        points[i].y = loader->pp4.y;
        tags[i]     = 1;
        contours[i] = i;

        outline.points   = points;
        outline.tags     = tags;
        outline.contours = contours;

        /* this call provides additional offsets */
        /* for each component's translation      */
        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
                             face,
                             glyph_index,
                             &outline,
                             (FT_UInt)outline.n_points ) ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {
          if ( subglyph->flags & ARGS_ARE_XY_VALUES )
          {
            subglyph->arg1 = (FT_Int16)points[i].x;
            subglyph->arg2 = (FT_Int16)points[i].y;
          }
        }

        loader->pp1.x = points[i + 0].x;
        loader->pp1.y = points[i + 0].y;
        loader->pp2.x = points[i + 1].x;
        loader->pp2.y = points[i + 1].y;

        loader->pp3.x = points[i + 2].x;
        loader->pp3.y = points[i + 2].y;
        loader->pp4.x = points[i + 3].x;
        loader->pp4.y = points[i + 3].y;

        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;

      Exit1:
        FT_FREE( outline.points );
        FT_FREE( outline.tags );
        FT_FREE( outline.contours );

        if ( error )
          goto Exit;
      }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

      /* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
      /* `as is' in the glyph slot (the client application will be     */
      /* responsible for interpreting these data)...                   */
      if ( loader->load_flags & FT_LOAD_NO_RECURSE )
      {
        FT_GlyphLoader_Add( gloader );
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;

        goto Exit;
      }

      /*********************************************************************/
      /*********************************************************************/
      /*********************************************************************/

      {
        FT_UInt      n, num_base_points;
        FT_SubGlyph  subglyph       = NULL;

        FT_UInt      num_points     = start_point;
        FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt      num_base_subgs = gloader->base.num_subglyphs;

        FT_Stream    old_stream     = loader->stream;
        FT_Int       old_byte_len   = loader->byte_len;


        FT_GlyphLoader_Add( gloader );

        /* read each subglyph independently */
        for ( n = 0; n < num_subglyphs; n++ )
        {
          FT_Vector  pp[4];

          FT_Int  linear_hadvance;
          FT_Int  linear_vadvance;


          /* Each time we call load_truetype_glyph in this loop, the   */
          /* value of `gloader.base.subglyphs' can change due to table */
          /* reallocations.  We thus need to recompute the subglyph    */
          /* pointer on each iteration.                                */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;

          linear_hadvance = loader->linear;
          linear_vadvance = loader->vadvance;

          num_base_points = (FT_UInt)gloader->base.outline.n_points;

          error = load_truetype_glyph( loader,
                                       (FT_UInt)subglyph->index,
                                       recurse_count + 1,
                                       FALSE );
          if ( error )
            goto Exit;

          /* restore subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          /* restore phantom points if necessary */
          if ( !( subglyph->flags & USE_MY_METRICS ) )
          {
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];

            loader->linear   = linear_hadvance;
            loader->vadvance = linear_vadvance;
          }

          num_points = (FT_UInt)gloader->base.outline.n_points;

          if ( num_points == num_base_points )
            continue;

          /* gloader->base.outline consists of three parts:               */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
          /*                                                              */
          /* (1): exists from the beginning                               */
          /* (2): components that have been loaded so far                 */
          /* (3): the newly loaded component                              */
          error = TT_Process_Composite_Component( loader,
                                                  subglyph,
                                                  start_point,
                                                  num_base_points );
          if ( error )
            goto Exit;
        }

        loader->stream   = old_stream;
        loader->byte_len = old_byte_len;

        /* process the glyph */
        loader->ins_pos = ins_pos;
        if ( IS_HINTED( loader->load_flags ) &&
#ifdef TT_USE_BYTECODE_INTERPRETER
             subglyph->flags & WE_HAVE_INSTR &&
#endif
             num_points > start_point )
        {
          error = TT_Process_Composite_Glyph( loader,
                                              start_point,
                                              start_contour );
          if ( error )
            goto Exit;
        }
      }
    }
    else
    {
      /* invalid composite count (negative but not -1) */
      error = FT_THROW( Invalid_Outline );
      goto Exit;
    }

    /***********************************************************************/
    /***********************************************************************/
    /***********************************************************************/

  Exit:

    if ( opened_frame )
      face->forget_glyph_frame( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( glyph_data_loaded )
      face->root.internal->incremental_interface->funcs->free_glyph_data(
        face->root.internal->incremental_interface->object,
        &glyph_data );

#endif

    return error;
  }


  static FT_Error
  compute_glyph_metrics( TT_Loader  loader,
                         FT_UInt    glyph_index )
  {
    TT_Face    face   = loader->face;
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    FT_BBox       bbox;
    FT_Fixed      y_scale;
    TT_GlyphSlot  glyph = loader->glyph;
    TT_Size       size  = loader->size;


    y_scale = 0x10000L;
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      y_scale = size->root.metrics.y_scale;

    if ( glyph->format != FT_GLYPH_FORMAT_COMPOSITE )
      FT_Outline_Get_CBox( &glyph->outline, &bbox );
    else
      bbox = loader->bbox;

    /* get the device-independent horizontal advance; it is scaled later */
    /* by the base layer.                                                */
    glyph->linearHoriAdvance = loader->linear;

    glyph->metrics.horiBearingX = bbox.xMin;
    glyph->metrics.horiBearingY = bbox.yMax;
    glyph->metrics.horiAdvance  = loader->pp2.x - loader->pp1.x;

    /* Adjust advance width to the value contained in the hdmx table    */
    /* unless FT_LOAD_COMPUTE_METRICS is set or backwards compatibility */
    /* mode of the v40 interpreter is active.  See `ttinterp.h' for     */
    /* details on backwards compatibility mode.                         */
    if (
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
         !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            ( loader->exec && loader->exec->backwards_compatibility  ) ) &&
#endif
         !face->postscript.isFixedPitch                                  &&
         IS_HINTED( loader->load_flags )                                 &&
         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )               )
    {
      FT_Byte*  widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        FT_Bool  ignore_x_mode;


        ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
                                 FT_RENDER_MODE_MONO );

        if ( widthp                                                   &&
             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
                !ignore_x_mode                                      ||
                SPH_OPTION_BITMAP_WIDTHS                            ) )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        if ( widthp )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
    }

    /* set glyph dimensions */
    glyph->metrics.width  = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

    /* Now take care of vertical metrics.  In the case where there is */
    /* no vertical information within the font (relatively common),   */
    /* create some metrics manually                                   */
    {
      FT_Pos  top;      /* scaled vertical top side bearing  */
      FT_Pos  advance;  /* scaled vertical advance height    */


      /* Get the unscaled top bearing and advance height. */
      if ( face->vertical_info                   &&
           face->vertical.number_Of_VMetrics > 0 )
      {
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );

        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
      }
      else
      {
        FT_Pos  height;


        /* XXX Compute top side bearing and advance height in  */
        /*     Get_VMetrics instead of here.                   */

        /* NOTE: The OS/2 values are the only `portable' ones, */
        /*       which is why we use them, if there is an OS/2 */
        /*       table in the font.  Otherwise, we use the     */
        /*       values defined in the horizontal header.      */

        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
        if ( face->os2.version != 0xFFFFU )
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
        else
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
      }

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      {
        FT_Incremental_InterfaceRec*  incr;
        FT_Incremental_MetricsRec     metrics;
        FT_Error                      error;


        incr = face->root.internal->incremental_interface;

        /* If this is an incrementally loaded font see if there are */
        /* overriding metrics for this glyph.                       */
        if ( incr && incr->funcs->get_glyph_metrics )
        {
          metrics.bearing_x = 0;
          metrics.bearing_y = top;
          metrics.advance   = advance;

          error = incr->funcs->get_glyph_metrics( incr->object,
                                                  glyph_index,
                                                  TRUE,
                                                  &metrics );
          if ( error )
            return error;

          top     = metrics.bearing_y;
          advance = metrics.advance;
        }
      }

      /* GWW: Do vertical metrics get loaded incrementally too? */

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      glyph->linearVertAdvance = advance;

      /* scale the metrics */
      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        top     = FT_MulFix( top,     y_scale );
        advance = FT_MulFix( advance, y_scale );
      }

      /* XXX: for now, we have no better algorithm for the lsb, but it */
      /*      should work fine.                                        */
      /*                                                               */
      glyph->metrics.vertBearingX = glyph->metrics.horiBearingX -
                                      glyph->metrics.horiAdvance / 2;
      glyph->metrics.vertBearingY = top;
      glyph->metrics.vertAdvance  = advance;
    }

    return 0;
  }


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  static FT_Error
  load_sbit_image( TT_Size       size,
                   TT_GlyphSlot  glyph,
                   FT_UInt       glyph_index,
                   FT_Int32      load_flags )
  {
    TT_Face             face;
    SFNT_Service        sfnt;
    FT_Stream           stream;
    FT_Error            error;
    TT_SBit_MetricsRec  metrics;


    face   = (TT_Face)glyph->face;
    sfnt   = (SFNT_Service)face->sfnt;
    stream = face->root.stream;

    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_UInt)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
    {
      glyph->outline.n_points   = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width  = (FT_Pos)metrics.width  * 64;
      glyph->metrics.height = (FT_Pos)metrics.height * 64;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX * 64;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY * 64;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  * 64;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX * 64;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY * 64;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  * 64;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;

      if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top  = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top  = metrics.horiBearingY;
      }
    }

    return error;
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  static FT_Error
  tt_loader_init( TT_Loader     loader,
                  TT_Size       size,
                  TT_GlyphSlot  glyph,
                  FT_Int32      load_flags,
                  FT_Bool       glyf_table_only )
  {
    FT_Error  error;

    TT_Face    face;
    FT_Stream  stream;
#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_Bool    pedantic = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
#endif
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );
#endif


    face   = (TT_Face)glyph->face;
    stream = face->root.stream;

    FT_ZERO( loader );

#ifdef TT_USE_BYTECODE_INTERPRETER

    /* load execution context */
    if ( IS_HINTED( load_flags ) && !glyf_table_only )
    {
      TT_ExecContext  exec;
      FT_Bool         grayscale = TRUE;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      FT_Bool         subpixel_hinting_lean;
      FT_Bool         grayscale_cleartype;
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      FT_Bool  subpixel_hinting = FALSE;

#if 0
      /* not used yet */
      FT_Bool  compatible_widths;
      FT_Bool  symmetrical_smoothing;
      FT_Bool  bgr;
      FT_Bool  vertical_lcd;
      FT_Bool  subpixel_positioned;
      FT_Bool  gray_cleartype;
#endif
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      FT_Bool  reexecute = FALSE;


      if ( size->bytecode_ready < 0 || size->cvt_ready < 0 )
      {
        error = tt_size_ready_bytecode( size, pedantic );
        if ( error )
          return error;
      }
      else if ( size->bytecode_ready )
        return size->bytecode_ready;
      else if ( size->cvt_ready )
        return size->cvt_ready;

      /* query new execution context */
      exec = size->context;
      if ( !exec )
        return FT_THROW( Could_Not_Find_Context );

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
      {
        subpixel_hinting_lean   = TRUE;
        grayscale_cleartype     = !FT_BOOL( load_flags         &
                                            FT_LOAD_TARGET_LCD     ||
                                            load_flags           &
                                            FT_LOAD_TARGET_LCD_V   );
        exec->vertical_lcd_lean = FT_BOOL( load_flags           &
                                           FT_LOAD_TARGET_LCD_V );
      }
      else
      {
        subpixel_hinting_lean   = FALSE;
        grayscale_cleartype     = FALSE;
        exec->vertical_lcd_lean = FALSE;
      }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
                                      FT_RENDER_MODE_MONO               )  &&
                                    SPH_OPTION_SET_SUBPIXEL                );

        if ( subpixel_hinting )
          grayscale = FALSE;
        else if ( SPH_OPTION_SET_GRAYSCALE )
        {
          grayscale        = TRUE;
          subpixel_hinting = FALSE;
        }
        else
          grayscale = FALSE;

        if ( FT_IS_TRICKY( glyph->face ) )
          subpixel_hinting = FALSE;

        exec->ignore_x_mode      = subpixel_hinting || grayscale;
        exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
        if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
          exec->rasterizer_version = TT_INTERPRETER_VERSION_35;

#if 1
        exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
        exec->symmetrical_smoothing = TRUE;
        exec->bgr                   = FALSE;
        exec->vertical_lcd          = FALSE;
        exec->subpixel_positioned   = TRUE;
        exec->gray_cleartype        = FALSE;
#else /* 0 */
        exec->compatible_widths =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_COMPATIBLE_WIDTHS );
        exec->symmetrical_smoothing =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SYMMETRICAL_SMOOTHING );
        exec->bgr =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_BGR );
        exec->vertical_lcd =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_VERTICAL_LCD );
        exec->subpixel_positioned =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SUBPIXEL_POSITIONED );
        exec->gray_cleartype =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_GRAY_CLEARTYPE );
#endif /* 0 */

      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        grayscale = FT_BOOL( !subpixel_hinting_lean               &&
                             FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO                );
      else
#endif
        grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO             );

      error = TT_Load_Context( exec, face, size );
      if ( error )
        return error;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* a change from mono to subpixel rendering (and vice versa) */
        /* requires a re-execution of the CVT program                */
        if ( subpixel_hinting != exec->subpixel_hinting )
        {
          FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                      " re-executing `prep' table\n" ));

          exec->subpixel_hinting = subpixel_hinting;
          reexecute              = TRUE;
        }

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
        if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        {
          /* a change from mono to subpixel rendering (and vice versa) */
          /* requires a re-execution of the CVT program                */
          if ( subpixel_hinting_lean != exec->subpixel_hinting_lean )
          {
            FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                        " re-executing `prep' table\n" ));

            exec->subpixel_hinting_lean = subpixel_hinting_lean;
            reexecute                   = TRUE;
          }

          /* a change from colored to grayscale subpixel rendering (and */
          /* vice versa) requires a re-execution of the CVT program     */
          if ( grayscale_cleartype != exec->grayscale_cleartype )
          {
            FT_TRACE4(( "tt_loader_init: grayscale subpixel hinting change,"
                        " re-executing `prep' table\n" ));

            exec->grayscale_cleartype = grayscale_cleartype;
            reexecute                 = TRUE;
          }
        }
#endif

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }

      if ( reexecute )
      {
        FT_UInt  i;


        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        error = tt_size_run_prep( size, pedantic );
        if ( error )
          return error;
      }

      /* check whether the cvt program has disabled hinting */
      if ( exec->GS.instruct_control & 1 )
        load_flags |= FT_LOAD_NO_HINTING;

      /* load default graphics state -- if needed */
      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* check whether we have a font hinted for ClearType --           */
      /* note that this flag can also be modified in a glyph's bytecode */
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
           exec->GS.instruct_control & 4                            )
        exec->ignore_x_mode = 0;
#endif

      exec->pedantic_hinting = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }

#endif /* TT_USE_BYTECODE_INTERPRETER */

    /* get face's glyph loader */
    if ( !glyf_table_only )
    {
      FT_GlyphLoader  gloader = glyph->internal->loader;


      FT_GlyphLoader_Rewind( gloader );
      loader->gloader = gloader;
    }

    loader->load_flags = (FT_ULong)load_flags;

    loader->face   = face;
    loader->size   = size;
    loader->glyph  = (FT_GlyphSlot)glyph;
    loader->stream = stream;

    loader->composites.head = NULL;
    loader->composites.tail = NULL;

    return FT_Err_Ok;
  }


  static void
  tt_loader_done( TT_Loader  loader )
  {
    FT_List_Finalize( &loader->composites,
                      NULL,
                      loader->face->root.memory,
                      NULL );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to load a single glyph within a given glyph slot,  */
  /*    for a given size.                                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    glyph       :: A handle to a target slot object where the glyph    */
  /*                   will be loaded.                                     */
  /*                                                                       */
  /*    size        :: A handle to the source face size at which the glyph */
  /*                   must be scaled/loaded.                              */
  /*                                                                       */
  /*    glyph_index :: The index of the glyph in the font file.            */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   FT_LOAD_XXX constants can be used to control the    */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  TT_Load_Glyph( TT_Size       size,
                 TT_GlyphSlot  glyph,
                 FT_UInt       glyph_index,
                 FT_Int32      load_flags )
  {
    FT_Error      error;
    TT_LoaderRec  loader;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#define IS_DEFAULT_INSTANCE  ( ( (TT_Face)glyph->face )->is_default_instance )
#else
#define IS_DEFAULT_INSTANCE  1
#endif


    FT_TRACE1(( "TT_Load_Glyph: glyph index %d\n", glyph_index ));

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    /* try to load embedded bitmap (if any) */
    if ( size->strike_index != 0xFFFFFFFFUL      &&
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&
         IS_DEFAULT_INSTANCE                     )
    {
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
      if ( !error )
      {
        if ( FT_IS_SCALABLE( glyph->face ) )
        {
          /* for the bbox we need the header only */
          (void)tt_loader_init( &loader, size, glyph, load_flags, TRUE );
          (void)load_truetype_glyph( &loader, glyph_index, 0, TRUE );
          tt_loader_done( &loader );
          glyph->linearHoriAdvance = loader.linear;
          glyph->linearVertAdvance = loader.vadvance;

          /* sanity checks: if `xxxAdvance' in the sbit metric */
          /* structure isn't set, use `linearXXXAdvance'      */
          if ( !glyph->metrics.horiAdvance && glyph->linearHoriAdvance )
            glyph->metrics.horiAdvance =
              FT_MulFix( glyph->linearHoriAdvance,
                         size->root.metrics.x_scale );
          if ( !glyph->metrics.vertAdvance && glyph->linearVertAdvance )
            glyph->metrics.vertAdvance =
              FT_MulFix( glyph->linearVertAdvance,
                         size->root.metrics.y_scale );
        }

        return FT_Err_Ok;
      }
    }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    /* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) && !size->ttmetrics.valid )
      return FT_THROW( Invalid_Size_Handle );

    if ( load_flags & FT_LOAD_SBITS_ONLY )
      return FT_THROW( Invalid_Argument );

    error = tt_loader_init( &loader, size, glyph, load_flags, FALSE );
    if ( error )
      return error;

    glyph->format        = FT_GLYPH_FORMAT_OUTLINE;
    glyph->num_subglyphs = 0;
    glyph->outline.flags = 0;

    /* main loading loop */
    error = load_truetype_glyph( &loader, glyph_index, 0, FALSE );
    if ( !error )
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs     = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline        = loader.gloader->base.outline;
        glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;

        /* Translate array so that (0,0) is the glyph's origin.  Note  */
        /* that this behaviour is independent on the value of bit 1 of */
        /* the `flags' field in the `head' table -- at least major     */
        /* applications like Acroread indicate that.                   */
        if ( loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }

#ifdef TT_USE_BYTECODE_INTERPRETER

      if ( IS_HINTED( load_flags ) )
      {
        if ( loader.exec->GS.scan_control )
        {
          /* convert scan conversion mode to FT_OUTLINE_XXX flags */
          switch ( loader.exec->GS.scan_type )
          {
          case 0: /* simple drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 1: /* simple drop-outs excluding stubs */
            /* nothing; it's the default rendering mode */
            break;
          case 4: /* smart drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS |
                                    FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 5: /* smart drop-outs excluding stubs  */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS;
            break;

          default: /* no drop-out control */
            glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
            break;
          }
        }
        else
          glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
      }

#endif /* TT_USE_BYTECODE_INTERPRETER */

      error = compute_glyph_metrics( &loader, glyph_index );
    }

    tt_loader_done( &loader );

    /* Set the `high precision' bit flag.                           */
    /* This is _critical_ to get correct output for monochrome      */
    /* TrueType glyphs at all sizes using the bytecode interpreter. */
    /*                                                              */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) &&
         size->root.metrics.y_ppem < 24     )
      glyph->outline.flags |= FT_OUTLINE_HIGH_PRECISION;

    return error;
  }


/* END */
@


1.6
log
@fastmerge
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d26 2
d37 1
d52 1
a52 1
  /* Composite font flags.                                                 */
d71 1
a71 3
  /* Returns the horizontal metrics in font units for a given glyph.  If   */
  /* `check' is true, take care of monospaced fonts by returning the       */
  /* advance width maximum.                                                */
a75 1
                   FT_Bool     check,
a80 3
    if ( check && face->postscript.isFixedPitch )
      *aw = face->horizontal.advance_Width_Max;

d88 2
a89 10
  /* Returns the vertical metrics in font units for a given glyph.         */
  /* Greg Hitchcock from Microsoft told us that if there were no `vmtx'    */
  /* table, typoAscender/Descender from the `OS/2' table would be used     */
  /* instead, and if there were no `OS/2' table, use ascender/descender    */
  /* from the `hhea' table.  But that is not what Microsoft's rasterizer   */
  /* apparently does: It uses the ppem value as the advance height, and    */
  /* sets the top side bearing to be zero.                                 */
  /*                                                                       */
  /* The monospace `check' is probably not meaningful here, but we leave   */
  /* it in for a consistent interface.                                     */
d94 1
a94 1
                   FT_Bool     check,
a97 2
    FT_UNUSED( check );

d101 1
a101 3
#if 1             /* Empirically determined, at variance with what MS said */

    else
d103 3
a105 2
      *tsb = 0;
      *ah  = face->root.units_per_EM;
a107 7
#else      /* This is what MS said to do.  It isn't what they do, however. */

    else if ( face->os2.version != 0xFFFFU )
    {
      *tsb = face->os2.sTypoAscender;
      *ah  = face->os2.sTypoAscender - face->os2.sTypoDescender;
    }
d110 3
a112 2
      *tsb = face->horizontal.Ascender;
      *ah  = face->horizontal.Ascender - face->horizontal.Descender;
a114 2
#endif

d120 1
a120 1
  static void
d124 7
a130 1
    TT_Face  face = (TT_Face)loader->face;
d135 4
a140 2
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
d144 1
a144 2
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
d148 32
d182 10
d201 1
a201 1
      metrics.bearing_x = left_bearing;
d203 1
a203 1
      metrics.advance   = advance_width;
d219 2
a220 2
      metrics.bearing_y = top_bearing;
      metrics.advance   = advance_height;
d233 10
d246 2
a250 39
    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* Translates an array of coordinates.                                   */
  /*                                                                       */
  static void
  translate_array( FT_UInt     n,
                   FT_Vector*  coords,
                   FT_Pos      delta_x,
                   FT_Pos      delta_y )
  {
    FT_UInt  k;


    if ( delta_x )
      for ( k = 0; k < n; k++ )
        coords[k].x += delta_x;

    if ( delta_y )
      for ( k = 0; k < n; k++ )
        coords[k].y += delta_y;
  }


#undef  IS_HINTED
#define IS_HINTED( flags )  ( ( flags & FT_LOAD_NO_HINTING ) == 0 )

d273 1
a273 1
    FT_TRACE5(( "Glyph %ld\n", glyph_index ));
d282 1
a282 1
    return TT_Err_Ok;
d304 1
a304 1
      return TT_Err_Invalid_Outline;
d320 1
a320 1
    return TT_Err_Ok;
a332 1
    TT_Face         face       = (TT_Face)load->face;
d335 1
d358 1
a358 1
    prev_cont = FT_NEXT_USHORT( p );
d363 3
d368 1
a368 1
      cont[0] = FT_NEXT_USHORT( p );
d372 1
a372 2
        error = FT_Err_Invalid_Table;
        goto Fail;
a389 7
    /* we'd better check the contours table right now */
    outline = &gloader->current.outline;

    for ( cont = outline->contours + 1; cont < cont_limit; cont++ )
      if ( cont[-1] >= cont[0] )
        goto Invalid_Outline;

d392 1
a392 1
    load->glyph->control_data = 0;
d401 1
a401 8
    if ( n_ins > face->max_profile.maxSizeOfInstructions )
    {
      FT_TRACE0(( "TT_Load_Simple_Glyph: too many instructions (%d)\n",
                  n_ins ));
      error = TT_Err_Too_Many_Hints;
      goto Fail;
    }

d405 1
a405 1
      error = TT_Err_Too_Many_Hints;
d413 14
d430 2
a431 1
      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
d438 2
d444 1
a444 1
    FT_ASSERT( flag != NULL );
d541 2
a542 2
    outline->n_points   = (FT_UShort)n_points;
    outline->n_contours = (FT_Short) n_contours;
d550 1
a550 1
    error = TT_Err_Invalid_Outline;
d605 1
a605 1
      if ( subglyph->flags & ARGS_ARE_WORDS )
d607 10
a616 2
        subglyph->arg1 = FT_NEXT_SHORT( p );
        subglyph->arg2 = FT_NEXT_SHORT( p );
d620 10
a629 2
        subglyph->arg1 = FT_NEXT_CHAR( p );
        subglyph->arg2 = FT_NEXT_CHAR( p );
d638 1
a638 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d643 2
a644 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d648 4
a651 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d664 1
d688 1
a688 1
    error = TT_Err_Invalid_Composite;
d710 4
a713 3
    zone->n_points    = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours  = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
d736 6
a742 1
    FT_Pos        origin;
d745 1
a745 1
    FT_UInt       n_ins;
d754 2
a755 2
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions " ));
      FT_TRACE1(( "(0x%lx byte) is truncated\n",
d758 1
a758 7
    n_ins = (FT_UInt)( loader->glyph->control_len );
#endif

    origin = zone->cur[zone->n_points - 4].x;
    origin = FT_PIX_ROUND( origin ) - origin;
    if ( origin )
      translate_array( zone->n_points, zone->cur, origin, 0 );
a759 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d765 1
a765 1
    loader->exec->GS = ((TT_Size)loader->size)->GS;
d778 2
a779 4
      loader->exec->metrics.x_scale =
        ((TT_Size)loader->size)->metrics.x_scale;
      loader->exec->metrics.y_scale =
        ((TT_Size)loader->size)->metrics.y_scale;
d783 3
a785 1
    /* round pp2 and pp4 */
d788 2
a796 1
      FT_Bool   debug;
d803 2
a804 4
      error = TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                                loader->exec->glyphIns, n_ins );
      if ( error )
        return error;
d809 1
a809 4
      debug = FT_BOOL( !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
                       ((TT_Size)loader->size)->debug             );

      error = TT_Run_Context( loader->exec, debug );
d820 6
a825 2
    /* save glyph phantom points */
    if ( !loader->preserve_pps )
d827 1
d832 12
d845 1
d847 1
a847 1
    return TT_Err_Ok;
d865 1
a865 1
    FT_Error        error   = TT_Err_Ok;
d889 1
a889 1
    if ( ((TT_Face)loader->face)->doblend )
d892 13
a904 3
      FT_Vector*  deltas;
      FT_Memory   memory = loader->face->memory;
      FT_Int      i;
a905 5

      error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                        loader->glyph_index,
                                        &deltas,
                                        n_points );
a907 8

      for ( i = 0; i < n_points; ++i )
      {
        outline->points[i].x += deltas[i].x;
        outline->points[i].y += deltas[i].y;
      }

      FT_FREE( deltas );
a919 2
    /* scale the glyph */
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
d921 49
a969 4
      FT_Vector*  vec     = outline->points;
      FT_Vector*  limit   = outline->points + n_points;
      FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d971 1
a972 1
      for ( ; vec < limit; vec++ )
d974 8
a981 2
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
d984 13
a996 4
      loader->pp1 = outline->points[n_points - 4];
      loader->pp2 = outline->points[n_points - 3];
      loader->pp3 = outline->points[n_points - 2];
      loader->pp4 = outline->points[n_points - 1];
d1025 2
a1026 3
    FT_GlyphLoader  gloader    = loader->gloader;
    FT_Vector*      base_vec   = gloader->base.outline.points;
    FT_UInt         num_points = gloader->base.outline.n_points;
d1031 5
d1042 1
a1042 7
    {
      FT_UInt  i;


      for ( i = num_base_points; i < num_points; i++ )
        FT_Vector_Transform( base_vec + i, &subglyph->transform );
    }
d1047 3
a1049 2
      FT_UInt     k = subglyph->arg1;
      FT_UInt     l = subglyph->arg2;
d1062 1
a1062 1
        return TT_Err_Invalid_Composite;
d1076 1
a1076 1
        return TT_Err_Ok;
d1078 3
a1080 3
  /* Use a default value dependent on                                     */
  /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
  /* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */
d1092 4
a1095 4
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is what Apple documents.  But it doesn't work.         */
  /*                                                                       */
d1102 1
a1102 1
        int  d = subglyph->transform.yy > 0 ? subglyph->transform.yy
d1115 1
a1115 1
#else /* 0 */
d1117 8
a1124 14
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is a guess and works much better than the above.       */
  /*                                                                       */
        FT_Fixed  mac_xscale = FT_SqrtFixed(
                                 (FT_Int32)FT_MulFix( subglyph->transform.xx,
                                                      subglyph->transform.xx ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.xy,
                                                      subglyph->transform.xy ) );
        FT_Fixed  mac_yscale = FT_SqrtFixed(
                                 (FT_Int32)FT_MulFix( subglyph->transform.yy,
                                                      subglyph->transform.yy ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.yx,
                                                      subglyph->transform.yx ) );
d1130 1
a1130 1
#endif /* 0 */
d1136 2
a1137 2
        FT_Fixed  x_scale = ((TT_Size)loader->size)->metrics.x_scale;
        FT_Fixed  y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d1152 1
a1152 3
      translate_array( num_points - num_base_points,
                       base_vec + num_base_points,
                       x, y );
d1154 1
a1154 1
    return TT_Err_Ok;
d1201 2
a1202 1
      FT_UShort  n_ins;
d1214 2
a1215 1
      if ( n_ins > ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions )
d1217 9
a1225 2
        FT_TRACE0(( "TT_Process_Composite_Glyph: too many instructions (%d)\n",
                    n_ins ));
d1227 10
a1236 1
        return TT_Err_Too_Many_Hints;
d1239 1
a1239 1
        return TT_Err_Ok;
d1255 1
a1255 1
    for ( i = start_point; i < loader->zone.n_points; i++ )
d1264 149
a1412 14
  /* Calculate the four phantom points.                     */
  /* The first two stand for horizontal origin and advance. */
  /* The last two stand for vertical origin and advance.    */
#define TT_LOADER_SET_PP( loader )                                          \
          do {                                                              \
            (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \
            (loader)->pp1.y = 0;                                            \
            (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \
            (loader)->pp2.y = 0;                                            \
            (loader)->pp3.x = 0;                                            \
            (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax;  \
            (loader)->pp4.x = 0;                                            \
            (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \
          } while ( 0 )
d1430 1
a1430 1
    FT_Error        error        = TT_Err_Ok;
d1433 1
a1433 1
    TT_Face         face         = (TT_Face)loader->face;
a1436 4
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    FT_Vector*      deltas       = NULL;
#endif

d1444 7
a1450 4
    /* some fonts have an incorrect value of `maxComponentDepth', */
    /* thus we allow depth 1 to catch the majority of them        */
    if ( recurse_count > 1                                   &&
         recurse_count > face->max_profile.maxComponentDepth )
d1452 3
a1454 2
      error = TT_Err_Invalid_Composite;
      goto Exit;
d1457 1
d1461 1
a1461 1
      error = TT_Err_Invalid_Glyph_Index;
d1464 1
d1470 2
a1471 2
      x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      y_scale = ((TT_Size)loader->size)->metrics.y_scale;
a1478 2
    tt_get_metrics( loader, glyph_index );

d1500 1
a1500 1
      FT_MEM_ZERO( &inc_stream, sizeof ( inc_stream ) );
d1502 2
a1503 1
                            glyph_data.pointer, glyph_data.length );
d1518 1
a1518 1
      if ( !loader->glyf_offset                        &&
d1521 1
a1521 1
      if ( !loader->glyf_offset )
d1525 1
a1525 1
        error = TT_Err_Invalid_Table;
d1530 2
a1531 2
                                        loader->glyf_offset + offset,
                                        loader->byte_len );
d1539 11
a1549 1
      if ( error || header_only )
d1560 4
d1567 7
a1573 1
      TT_LOADER_SET_PP( loader );
d1577 1
a1577 1
      if ( ((TT_Face)(loader->face))->doblend )
d1579 24
d1604 4
a1607 5
        FT_Memory  memory = loader->face->memory;


        error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                          glyph_index, &deltas, 4 );
d1611 17
a1627 6
        loader->pp1.x += deltas[0].x; loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x; loader->pp2.y += deltas[1].y;
        loader->pp3.x += deltas[2].x; loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x; loader->pp4.y += deltas[3].y;

        FT_FREE( deltas );
d1630 1
a1630 1
#endif
d1632 2
d1638 3
d1642 1
d1646 1
a1646 1
      error = TT_Err_Ok;
d1650 7
a1656 1
    TT_LOADER_SET_PP( loader );
d1688 2
d1694 36
d1731 2
a1732 2
      start_point   = gloader->base.outline.n_points;
      start_contour = gloader->base.outline.n_contours;
d1748 1
a1748 1
      if ( face->doblend )
d1750 1
a1750 1
        FT_Int       i, limit;
a1751 1
        FT_Memory    memory = face->root.memory;
d1753 4
a1757 2
        /* this provides additional offsets */
        /* for each component's translation */
d1759 64
a1822 6
        if ( ( error = TT_Vary_Get_Glyph_Deltas(
                         face,
                         glyph_index,
                         &deltas,
                         gloader->current.num_subglyphs + 4 )) != 0 )
          goto Exit;
d1824 1
a1824 2
        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
        limit    = gloader->current.num_subglyphs;
d1826 1
a1826 1
        for ( i = 0; i < limit; ++i, ++subglyph )
d1830 2
a1831 5
            /* XXX: overflow check for subglyph->{arg1,arg2}.   */
            /* deltas[i].{x,y} must be within signed 16-bit,    */
            /* but the restriction of summed delta is not clear */
            subglyph->arg1 += (FT_Int16)deltas[i].x;
            subglyph->arg2 += (FT_Int16)deltas[i].y;
d1835 21
a1855 4
        loader->pp1.x += deltas[i + 0].x; loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x; loader->pp2.y += deltas[i + 1].y;
        loader->pp3.x += deltas[i + 2].x; loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x; loader->pp4.y += deltas[i + 3].y;
d1857 2
a1858 1
        FT_FREE( deltas );
d1863 2
d1869 3
d1873 1
d1894 1
a1894 1
        FT_SubGlyph  subglyph       = 0;
d1901 1
d1911 3
d1926 4
a1929 1
          num_base_points = gloader->base.outline.n_points;
d1931 4
a1934 2
          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1, FALSE );
d1941 1
d1948 3
d1953 1
a1953 1
          num_points = gloader->base.outline.n_points;
d1964 6
a1969 2
          TT_Process_Composite_Component( loader, subglyph, start_point,
                                          num_base_points );
d1972 2
a1973 1
        loader->stream = old_stream;
a1977 1

a1978 1

a1979 1

a1980 1

d1982 7
a1988 2
          TT_Process_Composite_Glyph( loader, start_point, start_contour );

d1994 1
a1994 1
      error = TT_Err_Invalid_Outline;
d2024 6
a2030 1
    TT_Face       face = (TT_Face)loader->face;
d2033 1
a2033 1
    TT_Size       size = (TT_Size)loader->size;
d2047 1
a2047 17
    {
      FT_Pos  advance = loader->linear;


      /* the flag FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH was introduced to */
      /* correctly support DynaLab fonts, which have an incorrect       */
      /* `advance_Width_Max' field!  It is used, to my knowledge,       */
      /* exclusively in the X-TrueType font server.                     */
      /*                                                                */
      if ( face->postscript.isFixedPitch                                     &&
           ( loader->load_flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) == 0 )
        advance = face->horizontal.advance_Width_Max;

      /* we need to return the advance in font units in linearHoriAdvance, */
      /* it will be scaled later by the base layer.                        */
      glyph->linearHoriAdvance = advance;
    }
d2053 12
a2064 3
    /* adjust advance width to the value contained in the hdmx table */
    if ( !face->postscript.isFixedPitch  &&
         IS_HINTED( loader->load_flags ) )
d2073 24
a2096 2
      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
d2226 1
a2226 1
                                   (FT_Int)load_flags,
d2235 2
a2236 2
      glyph->metrics.width  = (FT_Pos)metrics.width  << 6;
      glyph->metrics.height = (FT_Pos)metrics.height << 6;
d2238 7
a2244 7
      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;
d2273 2
d2277 7
d2289 1
a2289 1
    FT_MEM_ZERO( loader, sizeof ( TT_LoaderRec ) );
d2297 19
a2315 1
      FT_Bool         grayscale;
d2317 1
d2319 2
a2320 1
      if ( !size->cvt_ready )
d2322 1
a2322 1
        FT_Error  error = tt_size_ready_bytecode( size );
d2326 4
d2332 1
a2332 2
      exec = size->debug ? size->context
                         : ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;
d2334 115
a2448 1
        return TT_Err_Could_Not_Find_Context;
d2450 5
a2454 2
      grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );
d2456 1
a2456 1
      TT_Load_Context( exec, face, size );
d2458 42
a2499 3
      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale )
a2503 2
        exec->grayscale = grayscale;

d2506 3
a2508 1
        tt_size_run_prep( size );
d2511 1
a2511 1
      /* see whether the cvt program has disabled hinting */
d2519 8
a2533 27
    /* seek to the beginning of the glyph table -- for Type 42 fonts     */
    /* the table might be accessed from a Postscript stream or something */
    /* else...                                                           */

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( face->root.internal->incremental_interface )
      loader->glyf_offset = 0;
    else

#endif

    {
      FT_Error  error = face->goto_table( face, TTAG_glyf, stream, 0 );


      if ( error == TT_Err_Table_Missing )
        loader->glyf_offset = 0;
      else if ( error )
      {
        FT_ERROR(( "tt_loader_init: could not access glyph table\n" ));
        return error;
      }
      else
        loader->glyf_offset = FT_STREAM_POS();
    }

d2544 1
a2544 1
    loader->load_flags = load_flags;
d2546 2
a2547 2
    loader->face   = (FT_Face)face;
    loader->size   = (FT_Size)size;
d2551 14
a2564 1
    return TT_Err_Ok;
a2600 1
    TT_Face       face;
d2604 6
d2611 1
a2611 2
    face   = (TT_Face)glyph->face;
    error  = TT_Err_Ok;
d2615 1
a2615 4
    /* try to load embedded bitmap if any              */
    /*                                                 */
    /* XXX: The convention should be emphasized in     */
    /*      the documents because it can be confusing. */
d2617 2
a2618 1
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )
d2623 1
a2623 4
        FT_Face  root = &face->root;


        if ( FT_IS_SCALABLE( root ) )
d2628 1
d2630 12
a2641 5
          glyph->linearVertAdvance = loader.top_bearing + loader.bbox.yMax -
                                       loader.vadvance;
          if ( face->postscript.isFixedPitch                             &&
               ( load_flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) == 0 )
            glyph->linearHoriAdvance = face->horizontal.advance_Width_Max;
d2644 1
a2644 1
        return TT_Err_Ok;
d2652 1
a2652 1
      return TT_Err_Invalid_Size_Handle;
d2655 1
a2655 1
      return TT_Err_Invalid_Argument;
d2679 5
a2683 3
        /* In case bit 1 of the `flags' field in the `head' table isn't */
        /* set, translate array so that (0,0) is the glyph's origin.    */
        if ( ( face->header.Flags & 2 ) == 0 && loader.pp1.x )
d2721 1
a2721 1
      compute_glyph_metrics( &loader, glyph_index );
d2724 2
@


1.5
log
@Merge freetype 2.3.6
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d73 6
a78 6
  static void
  Get_HMetrics( TT_Face     face,
                FT_UInt     idx,
                FT_Bool     check,
                FT_Short*   lsb,
                FT_UShort*  aw )
d84 3
d103 6
a108 6
  static void
  Get_VMetrics( TT_Face     face,
                FT_UInt     idx,
                FT_Bool     check,
                FT_Short*   tsb,
                FT_UShort*  ah )
d138 85
d409 1
a409 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions (%d)\n",
d417 1
a417 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Instruction count mismatch!\n" ));
d474 2
a475 2
      FT_Pos  y = 0;
      FT_Byte f = *flag;
d497 2
a498 1
      *flag  = f & ~( 2 | 16 );
d510 2
a511 2
      FT_Pos  y = 0;
      FT_Byte f = *flag;
d533 2
a534 1
      *flag  = f & FT_CURVE_TAG_ON;
d651 4
a654 4
      /* we must undo the FT_FRAME_ENTER in order to point to the */
      /* composite instructions, if we find some.               */
      /* we will process them later...                          */
      /*                                                        */
d725 7
a731 1
    n_ins = loader->glyph->control_len;
d778 3
d796 4
d1034 4
a1037 4
                                 FT_MulFix( subglyph->transform.xx,
                                            subglyph->transform.xx ) +
                                 FT_MulFix( subglyph->transform.xy,
                                            subglyph->transform.xy ) );
d1039 4
a1042 4
                                 FT_MulFix( subglyph->transform.yy,
                                            subglyph->transform.yy ) +
                                 FT_MulFix( subglyph->transform.yx,
                                            subglyph->transform.yx ) );
d1135 1
a1135 1
        FT_TRACE0(( "TT_Process_Composite_Glyph: Too many instructions (%d)\n",
d1158 1
a1158 2
      loader->zone.tags[i] &= ~( FT_CURVE_TAG_TOUCH_X |
                                 FT_CURVE_TAG_TOUCH_Y );
d1194 2
a1195 1
                       FT_UInt    recurse_count )
d1197 1
a1197 1
    FT_Error        error;
d1244 1
a1244 69
    /* get metrics, horizontal and vertical */
    {
      FT_Short   left_bearing = 0, top_bearing = 0;
      FT_UShort  advance_width = 0, advance_height = 0;


      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &top_bearing,
                    &advance_height );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
      {
        FT_Incremental_MetricsRec  metrics;


        metrics.bearing_x = left_bearing;
        metrics.bearing_y = 0;
        metrics.advance = advance_width;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, FALSE, &metrics );
        if ( error )
          goto Exit;
        left_bearing  = (FT_Short)metrics.bearing_x;
        advance_width = (FT_UShort)metrics.advance;

#if 0

        /* GWW: Do I do the same for vertical metrics? */
        metrics.bearing_x = 0;
        metrics.bearing_y = top_bearing;
        metrics.advance = advance_height;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, TRUE, &metrics );
        if ( error )
          goto Exit;
        top_bearing  = (FT_Short)metrics.bearing_y;
        advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

      }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
      loader->top_bearing  = top_bearing;
      loader->vadvance     = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear     = advance_width;
      }
    }
d1282 13
d1303 1
a1303 1
      /* read first glyph header */
d1305 1
a1305 1
      if ( error )
d1316 3
d1434 5
a1438 2
            subglyph->arg1 += deltas[i].x;
            subglyph->arg2 += deltas[i].y;
d1508 1
a1508 1
                                       recurse_count + 1 );
d1628 5
a1632 3
    /* Now take care of vertical metrics.  In the case where there is    */
    /* no vertical information within the font (relatively common), make */
    /* up some metrics by `hand'...                                      */
d1634 16
d1656 1
a1656 1
      if ( face->vertical_info &&
d1731 1
a1731 1
        top     = FT_MulFix( top, y_scale );
d1738 2
a1739 1
      glyph->metrics.vertBearingX = ( bbox.xMin - bbox.xMax ) / 2;
a1743 19
    /* adjust advance width to the value contained in the hdmx table */
    if ( !face->postscript.isFixedPitch &&
         IS_HINTED( loader->load_flags )        )
    {
      FT_Byte*  widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
    }

    /* set glyph dimensions */
    glyph->metrics.width  = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

d1791 1
d1814 2
a1815 1
                  FT_Int32      load_flags )
d1829 1
a1829 1
    if ( IS_HINTED( load_flags ) )
d1898 3
a1900 1
      if ( error )
d1902 1
a1902 1
        FT_ERROR(( "TT_Load_Glyph: could not access glyph table\n" ));
d1905 2
a1906 1
      loader->glyf_offset = FT_STREAM_POS();
d1910 1
d1919 1
a1919 1
    loader->load_flags    = load_flags;
d1982 17
d2000 1
d2012 1
a2012 1
    error = tt_loader_init( &loader, size, glyph, load_flags );
d2021 1
a2021 1
    error = load_truetype_glyph( &loader, glyph_index, 0 );
d2040 34
@


1.4
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d270 5
a274 1
    cont[0] = prev_cont = FT_NEXT_USHORT( p );
d646 20
d1111 4
a1114 1
    if ( recurse_count > face->max_profile.maxComponentDepth )
d1244 17
a1260 1
    if ( loader->byte_len == 0 )
a1261 2
      /* as described by Frederic Loyer, these are spaces or */
      /* the unknown glyph.                                  */
a1303 13
    error = face->access_glyph_frame( loader, glyph_index,
                                      loader->glyf_offset + offset,
                                      loader->byte_len );
    if ( error )
      goto Exit;

    opened_frame = 1;

    /* read first glyph header */
    error = face->read_glyph_header( loader );
    if ( error )
      goto Exit;

d1312 1
a1312 1
    if ( loader->n_contours >= 0 )
d1421 2
a1422 2
        FT_UInt           n, num_base_points;
        FT_SubGlyph       subglyph       = 0;
d1424 3
a1426 3
        FT_UInt           num_points     = start_point;
        FT_UInt           num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt           num_base_subgs = gloader->base.num_subglyphs;
d1428 1
a1428 1
        FT_Stream         old_stream     = loader->stream;
a1429 5
        TT_GraphicsState  saved_GS;


        if ( loader->exec )
          saved_GS = loader->exec->GS;
a1438 4
          /* reinitialize graphics state */
          if ( loader->exec )
            loader->exec->GS = saved_GS;

@


1.3
log
@apply fix for SECURITY bug from http://www.heise.de/newsticker/meldung/90017
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d111 1
a111 1
#if 1             /* Emperically determined, at variance with what MS said */
d191 3
d211 2
a212 2
    FT_Stream  stream   = loader->stream;
    FT_Int     byte_len = loader->byte_len - 10;
d215 1
a215 1
    if ( byte_len < 0 )
d218 1
a218 1
    loader->n_contours = FT_GET_SHORT();
d220 4
a223 4
    loader->bbox.xMin = FT_GET_SHORT();
    loader->bbox.yMin = FT_GET_SHORT();
    loader->bbox.xMax = FT_GET_SHORT();
    loader->bbox.yMax = FT_GET_SHORT();
d230 1
a230 1
    loader->byte_len = byte_len;
d240 2
a241 1
    FT_Stream       stream     = load->stream;
d247 1
a247 2
    FT_Int          n, n_points;
    FT_Int          byte_len   = load->byte_len;
d253 2
a254 1
    FT_Short        *cont, *cont_limit;
d267 1
a267 2
    byte_len -= 2 * ( n_contours + 1 );
    if ( byte_len < 0 )
d270 12
a281 2
    for ( ; cont < cont_limit; cont++ )
      cont[0] = FT_GET_USHORT();
d307 4
a310 1
    n_ins = FT_GET_USHORT();
d316 2
a317 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions!\n" ));
d322 1
a322 2
    byte_len -= (FT_Int)n_ins;
    if ( byte_len < 0 )
d329 1
a329 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d336 1
a336 1
      FT_MEM_COPY( load->exec->glyphIns, stream->cursor, (FT_Long)n_ins );
d339 1
a339 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d341 1
a341 1
    stream->cursor += (FT_Int)n_ins;
d351 1
a351 1
      if ( --byte_len < 0 )
d354 1
a354 1
      *flag++ = c = FT_GET_BYTE();
d357 1
a357 1
        if ( --byte_len < 0 )
d360 1
a360 1
        count = FT_GET_BYTE();
a368 17
    /* check that there is enough room to load the coordinates */
    for ( flag = (FT_Byte*)outline->tags; flag < flag_limit; flag++ )
    {
      if ( *flag & 2 )
        byte_len -= 1;
      else if ( ( *flag & 16 ) == 0 )
        byte_len -= 2;

      if ( *flag & 4 )
        byte_len -= 1;
      else if ( ( *flag & 32 ) == 0 )
        byte_len -= 2;
    }

    if ( byte_len < 0 )
      goto Invalid_Outline;

d376 3
d382 1
d385 1
a385 1
      if ( *flag & 2 )
d387 5
a391 2
        y = (FT_Pos)FT_GET_BYTE();
        if ( ( *flag & 16 ) == 0 )
d394 7
a400 2
      else if ( ( *flag & 16 ) == 0 )
        y = (FT_Pos)FT_GET_SHORT();
d404 1
d417 1
d420 1
a420 1
      if ( *flag & 4 )
d422 5
a426 2
        y = (FT_Pos)FT_GET_BYTE();
        if ( ( *flag & 32 ) == 0 )
d429 7
a435 2
      else if ( ( *flag & 32 ) == 0 )
        y = (FT_Pos)FT_GET_SHORT();
d439 1
a441 4
    /* clear the touch tags */
    for ( n = 0; n < n_points; n++ )
      outline->tags[n] &= FT_CURVE_TAG_ON;

d445 1
a445 1
    load->byte_len = byte_len;
d460 2
a461 1
    FT_Stream       stream  = loader->stream;
a464 1
    FT_Int          byte_len = loader->byte_len;
d472 1
d481 1
a481 2
      byte_len -= 4;
      if ( byte_len < 0 )
d488 2
a489 2
      subglyph->flags = FT_GET_USHORT();
      subglyph->index = FT_GET_USHORT();
d492 1
a492 1
      byte_len -= 2;
d494 1
a494 1
        byte_len -= 2;
d496 1
a496 1
        byte_len -= 2;
d498 1
a498 1
        byte_len -= 4;
d500 1
a500 1
        byte_len -= 8;
d502 1
a502 1
      if ( byte_len < 0 )
d508 2
a509 2
        subglyph->arg1 = FT_GET_SHORT();
        subglyph->arg2 = FT_GET_SHORT();
d513 2
a514 2
        subglyph->arg1 = FT_GET_CHAR();
        subglyph->arg2 = FT_GET_CHAR();
d523 1
a523 1
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
d528 2
a529 2
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
        yy = (FT_Fixed)FT_GET_SHORT() << 2;
d533 4
a536 4
        xx = (FT_Fixed)FT_GET_SHORT() << 2;
        yx = (FT_Fixed)FT_GET_SHORT() << 2;
        xy = (FT_Fixed)FT_GET_SHORT() << 2;
        yy = (FT_Fixed)FT_GET_SHORT() << 2;
d550 1
a550 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d553 3
d561 1
a561 1
                                    stream->cursor - stream->limit );
d566 1
a566 1
    loader->byte_len = byte_len;
d594 9
a602 6
    zone->n_points   = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours = (FT_Short) ( load->outline.n_contours - start_contour );
    zone->org        = load->extra_points + start_point;
    zone->cur        = load->outline.points + start_point;
    zone->tags       = (FT_Byte*)load->outline.tags + start_point;
    zone->contours   = (FT_UShort*)load->outline.contours + start_contour;
a614 3
#define cur_to_org( n, zone ) \
          FT_ARRAY_COPY( (zone)->org, (zone)->cur, (n) )

d622 1
a622 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d629 1
a629 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d638 2
a639 2
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
    /* save original point positioin in org */
d641 1
a641 1
      cur_to_org( zone->n_points, zone );
d650 1
a650 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d666 2
a667 2
      debug = !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
              ( (TT_Size)loader->size )->debug;
d753 8
a783 1
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
d957 1
a957 1
  /*    it's sole purpose is to hint the glyph.  Thus this function is     */
d967 1
d989 1
a989 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1007 2
a1008 1
        FT_TRACE0(( "Too many instructions (%d)\n", n_ins ));
d1026 7
d1308 3
a1310 3
      FT_UInt       start_point;
      FT_UInt       start_contour;
      FT_ULong      ins_pos;  /* position of composite instructions, if any */
d1340 5
a1344 5
        if ( (error = TT_Vary_Get_Glyph_Deltas(
                        face,
                        glyph_index,
                        &deltas,
                        gloader->current.num_subglyphs + 4 )) != 0 )
a1379 1
      /*                                                               */
d1393 8
a1400 2
        FT_UInt      n, num_base_points;
        FT_SubGlyph  subglyph       = 0;
d1402 1
a1402 3
        FT_UInt      num_points     = start_point;
        FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt      num_base_subgs = gloader->base.num_subglyphs;
d1405 3
d1416 4
d1454 6
a1459 6
          /* gloader->base.outline consists of three part:                  */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points.   */
          /*                                                                */
          /* (1): exist from the beginning                                  */
          /* (2): components that have been loaded so far                   */
          /* (3): the newly loaded component                                */
d1464 1
d1470 1
a1470 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1483 1
a1483 1
      /* invalid composite count ( negative but not -1 ) */
d1511 2
a1512 2
  compute_glyph_metrics( TT_Loader   loader,
                         FT_UInt     glyph_index )
d1530 2
a1531 2
    /* get the device-independent horizontal advance.  It is scaled later */
    /* by the base layer.                                                 */
d1750 1
a1750 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1753 1
d1756 1
d1759 7
d1772 3
d1777 15
a1791 1
      /* see if the cvt program has disabled hinting */
d1795 1
a1795 1
      /* load default graphics state - if needed */
a1799 3
      exec->grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_LOAD_TARGET_MONO );

d1804 1
a1804 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d1806 1
a1806 1
    /* seek to the beginning of the glyph table.  For Type 42 fonts      */
a1883 1
    FT_Stream     stream;
a1888 1
    stream = face->root.stream;
d1922 1
a1922 1
    /* Main loading loop */
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d272 1
d274 3
d684 1
a684 1
    FT_UInt         n_points;
d711 1
a711 1
      FT_UInt     i;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d28 5
a65 64
/* Maximum recursion depth we allow for composite glyphs.
 * The TrueType spec doesn't say anything about recursion,
 * so it isn't clear that recursion is allowed at all. But
 * we'll be generous.
 */
#define TT_MAX_COMPOSITE_RECURSE 5



  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Get_Metrics                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Returns the horizontal or vertical metrics in font units for a     */
  /*    given glyph.  The metrics are the left side bearing (resp. top     */
  /*    side bearing) and advance width (resp. advance height).            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    header  :: A pointer to either the horizontal or vertical metrics  */
  /*               structure.                                              */
  /*                                                                       */
  /*    idx     :: The glyph index.                                        */
  /*                                                                       */
  /* <Output>                                                              */
  /*    bearing :: The bearing, either left side or top side.              */
  /*                                                                       */
  /*    advance :: The advance width resp. advance height.                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function will much probably move to another component in the  */
  /*    near future, but I haven't decided which yet.                      */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  TT_Get_Metrics( TT_HoriHeader*  header,
                  FT_UInt         idx,
                  FT_Short*       bearing,
                  FT_UShort*      advance )
  {
    TT_LongMetrics  longs_m;
    FT_UShort       k = header->number_Of_HMetrics;


    if ( k == 0 )
    {
      *bearing = *advance = 0;
      return;
    }

    if ( idx < (FT_UInt)k )
    {
      longs_m  = (TT_LongMetrics )header->long_metrics + idx;
      *bearing = longs_m->bearing;
      *advance = longs_m->advance;
    }
    else
    {
      *bearing = ((TT_ShortMetrics*)header->short_metrics)[idx - k];
      *advance = ((TT_LongMetrics )header->long_metrics)[k - 1].advance;
    }
  }


d79 1
a79 1
    TT_Get_Metrics( &face->horizontal, idx, lsb, aw );
a87 20
  /* Returns the advance width table for a given pixel size if it is found */
  /* in the font's `hdmx' table (if any).                                  */
  /*                                                                       */
  static FT_Byte*
  Get_Advance_Widths( TT_Face    face,
                      FT_UShort  ppem )
  {
    FT_UShort  n;


    for ( n = 0; n < face->hdmx.num_records; n++ )
      if ( face->hdmx.records[n].ppem == ppem )
        return face->hdmx.records[n].widths;

    return NULL;
  }


  /*************************************************************************/
  /*                                                                       */
d109 1
a109 1
      TT_Get_Metrics( (TT_HoriHeader *)&face->vertical, idx, tsb, ah );
d126 1
a126 1
    else 
a136 7
#define cur_to_org( n, zone ) \
          FT_ARRAY_COPY( (zone)->org, (zone)->cur, (n) )

#define org_to_cur( n, zone ) \
          FT_ARRAY_COPY( (zone)->cur, (zone)->org, (n) )


a159 15
  static void
  tt_prepare_zone( TT_GlyphZone  zone,
                   FT_GlyphLoad  load,
                   FT_UInt       start_point,
                   FT_UInt       start_contour )
  {
    zone->n_points   = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours = (FT_Short) ( load->outline.n_contours - start_contour );
    zone->org        = load->extra_points + start_point;
    zone->cur        = load->outline.points + start_point;
    zone->tags       = (FT_Byte*)load->outline.tags + start_point;
    zone->contours   = (FT_UShort*)load->outline.contours + start_contour;
  }


a241 1
    TT_GlyphSlot    slot       = (TT_GlyphSlot)load->glyph;
d253 6
a258 1
    /* reading the contours endpoints & number of points */
d274 2
a275 1
    error = FT_GlyphLoader_CheckPoints( gloader, n_points + 4, 0 );
d287 2
a288 2
    slot->control_len  = 0;
    slot->control_data = 0;
d311 1
a311 3
    if ( ( load->load_flags                        &
         ( FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING ) ) == 0 &&
           load->instructions )
d313 2
a314 2
      slot->control_len  = n_ins;
      slot->control_data = load->instructions;
d316 1
a316 1
      FT_MEM_COPY( load->instructions, stream->cursor, (FT_Long)n_ins );
d327 2
d529 1
d538 1
d563 15
d581 1
a581 1
  /*    TT_Process_Simple_Glyph                                            */
d584 2
a585 3
  /*    Once a simple glyph has been loaded, it needs to be processed.     */
  /*    Usually, this means scaling and hinting through bytecode           */
  /*    interpretation.                                                    */
d587 3
d591 2
a592 2
  TT_Process_Simple_Glyph( TT_Loader  load,
                           FT_Bool    debug )
d594 3
a596 3
    FT_GlyphLoader  gloader  = load->gloader;
    FT_Outline*     outline  = &gloader->current.outline;
    FT_UInt         n_points = outline->n_points;
d598 3
a600 1
    FT_UInt         n_ins;
a601 2
    TT_GlyphZone    zone     = &load->zone;
    FT_Error        error    = TT_Err_Ok;
a602 1
    FT_UNUSED( debug );  /* used by truetype interpreter only */
d604 8
d614 3
a616 1
    n_ins = load->glyph->control_len;
d619 5
a623 1
    /* add shadow points */
d625 1
a625 4
    /* Add two horizontal shadow points at n and n+1.   */
    /* We need the left side bearing and advance width. */
    /* Add two vertical shadow points at n+2 and n+3.   */
    /* We need the top side bearing and advance height. */
d627 1
d629 2
a630 4
      FT_Vector*  pp1;
      FT_Vector*  pp2;
      FT_Vector*  pp3;
      FT_Vector*  pp4;
d633 7
a639 4
      /* pp1 = xMin - lsb */
      pp1    = outline->points + n_points;
      pp1->x = load->bbox.xMin - load->left_bearing;
      pp1->y = 0;
d641 2
a642 4
      /* pp2 = pp1 + aw */
      pp2    = pp1 + 1;
      pp2->x = pp1->x + load->advance;
      pp2->y = 0;
d644 4
a647 4
      /* pp3 = top side bearing */
      pp3    = pp1 + 2;
      pp3->x = 0;
      pp3->y = load->top_bearing + load->bbox.yMax;
d649 1
a649 4
      /* pp4 = pp3 - ah */
      pp4    = pp1 + 3;
      pp4->x = 0;
      pp4->y = pp3->y - load->vadvance;
d651 7
a657 4
      outline->tags[n_points    ] = 0;
      outline->tags[n_points + 1] = 0;
      outline->tags[n_points + 2] = 0;
      outline->tags[n_points + 3] = 0;
d660 2
a661 2
    /* Note that we return two more points that are not */
    /* part of the glyph outline.                       */
a662 1
    n_points += 4;
d664 17
a680 2
    /* set up zone for hinting */
    tt_prepare_zone( zone, &gloader->current, 0, 0 );
a681 7
    /* eventually scale the glyph */
    if ( !( load->load_flags & FT_LOAD_NO_SCALE ) )
    {
      FT_Vector*  vec     = zone->cur;
      FT_Vector*  limit   = vec + n_points;
      FT_Fixed    x_scale = load->size->metrics.x_scale;
      FT_Fixed    y_scale = load->size->metrics.y_scale;
d683 2
d686 1
a686 7
      /* first scale the glyph points */
      for ( ; vec < limit; vec++ )
      {
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
      }
    }
d688 4
a691 1
    cur_to_org( n_points, zone );
d693 4
a696 5
    /* eventually hint the glyph */
    if ( IS_HINTED( load->load_flags ) )
    {
      FT_Pos  x = zone->org[n_points-4].x;
      FT_Pos  y = zone->org[n_points-2].y;
d698 1
d700 1
a700 3
      x = FT_PIX_ROUND( x ) - x;
      y = FT_PIX_ROUND( y ) - y;
      translate_array( n_points, zone->org, x, y );
d702 6
a707 1
      org_to_cur( n_points, zone );
a708 2
      zone->cur[n_points - 3].x = FT_PIX_ROUND( zone->cur[n_points - 3].x );
      zone->cur[n_points - 1].y = FT_PIX_ROUND( zone->cur[n_points - 1].y );
d710 6
a715 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d717 1
a717 2
      /* now consider hinting */
      if ( n_ins > 0 )
d719 8
a726 4
        error = TT_Set_CodeRange( load->exec, tt_coderange_glyph,
                                  load->exec->glyphIns, n_ins );
        if ( error )
          goto Exit;
d728 7
a734 5
        load->exec->is_composite     = FALSE;
        load->exec->pedantic_hinting = (FT_Bool)( load->load_flags &
                                                  FT_LOAD_PEDANTIC );
        load->exec->pts              = *zone;
        load->exec->pts.n_points    += 4;
a735 3
        error = TT_Run_Context( load->exec, debug );
        if ( error && load->exec->pedantic_hinting )
          goto Exit;
d737 4
a740 1
        error = TT_Err_Ok;  /* ignore bytecode errors in non-pedantic mode */
d743 4
a746 2
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */

d749 1
a749 2
    /* save glyph phantom points */
    if ( !load->preserve_pps )
d751 4
a754 4
      load->pp1 = zone->cur[n_points - 4];
      load->pp2 = zone->cur[n_points - 3];
      load->pp3 = zone->cur[n_points - 2];
      load->pp4 = zone->cur[n_points - 1];
a756 3
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
  Exit:
#endif
d764 1
a764 1
  /*    load_truetype_glyph                                                */
d767 2
a768 2
  /*    Loads a given truetype glyph.  Handles composites and uses a       */
  /*    TT_Loader object.                                                  */
d771 4
a774 3
  load_truetype_glyph( TT_Loader  loader,
                       FT_UInt    glyph_index,
                       FT_UInt    recurse_count )
d776 5
a781 3
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
    FT_Stream       stream = loader->stream;
#endif
d783 3
a785 8
    FT_Error        error;
    TT_Face         face   = (TT_Face)loader->face;
    FT_ULong        offset;
    FT_Int          contours_count;
    FT_UInt         num_points, count;
    FT_Fixed        x_scale, y_scale;
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Bool         opened_frame = 0;
d787 4
a790 5
#ifdef FT_CONFIG_OPTION_INCREMENTAL
    struct FT_StreamRec_  inc_stream;
    FT_Data               glyph_data;
    FT_Bool               glyph_data_loaded = 0;
#endif
d793 2
a794 4
    if ( recurse_count >= TT_MAX_COMPOSITE_RECURSE )
    {
      error = TT_Err_Invalid_Composite;
      goto Exit;
d797 2
a798 2
    /* check glyph index */
    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
d800 21
a820 2
      error = TT_Err_Invalid_Glyph_Index;
      goto Exit;
d822 11
d834 7
a840 2
    loader->glyph_index = glyph_index;
    num_points          = 0;
d842 1
a842 7
    x_scale = 0x10000L;
    y_scale = 0x10000L;
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      x_scale = loader->size->metrics.x_scale;
      y_scale = loader->size->metrics.y_scale;
    }
d844 22
a865 4
    /* get metrics, horizontal and vertical */
    {
      FT_Short   left_bearing = 0, top_bearing = 0;
      FT_UShort  advance_width = 0, advance_height = 0;
d867 1
d869 14
a882 10
      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &top_bearing,
                    &advance_height );
a883 1
#ifdef FT_CONFIG_OPTION_INCREMENTAL
d885 2
a886 6
      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
      {
        FT_Incremental_MetricsRec  metrics;
d888 1
a889 10
        metrics.bearing_x = left_bearing;
        metrics.bearing_y = 0;
        metrics.advance = advance_width;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, FALSE, &metrics );
        if ( error )
          goto Exit;
        left_bearing  = (FT_Short)metrics.bearing_x;
        advance_width = (FT_UShort)metrics.advance;
d892 1
a892 4
# if 0
      /* GWW: Do I do the same for vertical metrics ??? */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
d894 14
a907 1
        FT_Incremental_MetricsRec  metrics;
d909 4
d914 199
d1123 3
a1126 1
# endif
d1142 4
a1147 4
    /* Set `offset' to the start of the glyph program relative to the  */
    /* start of the 'glyf' table, and `count' to the length of the     */
    /* glyph program in bytes.                                         */
    /*                                                                 */
a1150 1

d1161 1
a1161 1
      count             = glyph_data.length;
d1173 2
a1174 7
    {
      offset = face->glyph_locations[glyph_index];
      count  = 0;

      if ( glyph_index < (FT_UInt)face->num_locations - 1 )
        count = (FT_UInt)( face->glyph_locations[glyph_index + 1] - offset );
    }
d1176 1
a1176 1
    if ( count == 0 )
d1178 2
a1179 2
      /* as described by Frederic Loyer, these are spaces, and */
      /* not the unknown glyph.                                */
d1185 24
a1208 4
      loader->pp1.x = 0;
      loader->pp2.x = loader->advance;
      loader->pp3.y = 0;
      loader->pp4.y = loader->pp3.y-loader->vadvance;
d1212 1
d1214 1
a1217 7
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

      if ( loader->exec )
        loader->exec->glyphSize = 0;

#endif

d1222 3
a1224 6
    loader->byte_len = (FT_Int)count;

    offset = loader->glyf_offset + offset;

    /* access glyph frame */
    error = face->access_glyph_frame( loader, glyph_index, offset, count );
d1233 1
a1233 5
      goto Fail;

    contours_count = loader->n_contours;

    count -= 10;
d1235 1
a1235 17
    loader->pp1.x = loader->bbox.xMin - loader->left_bearing;
    loader->pp1.y = 0;
    loader->pp2.x = loader->pp1.x + loader->advance;
    loader->pp2.y = 0;

    loader->pp3.x = 0;
    loader->pp3.y = loader->top_bearing + loader->bbox.yMax;
    loader->pp4.x = 0;
    loader->pp4.y = loader->pp3.y - loader->vadvance;

    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
      loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
      loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
      loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
    }
d1243 1
a1243 1
    if ( contours_count >= 0 )
a1244 5
      /* check that we can add the contours to the glyph */
      error = FT_GlyphLoader_CheckPoints( gloader, 0, contours_count );
      if ( error )
        goto Fail;

d1247 1
a1247 1
        goto Fail;
d1249 3
a1251 15
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

      {
        TT_Size  size = (TT_Size)loader->size;


        error = TT_Process_Simple_Glyph( loader,
                                         (FT_Bool)( size && size->debug ) );
      }

#else

      error = TT_Process_Simple_Glyph( loader, 0 );

#endif
d1253 1
d1255 1
a1255 1
        goto Fail;
a1257 3

      /* Note: We could have put the simple loader source there */
      /*       but the code is fat enough already :-)           */
d1265 1
a1265 1
    else if ( contours_count == -1 )
a1266 1
      TT_GlyphSlot  glyph = (TT_GlyphSlot)loader->glyph;
a1267 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
a1269 1
#endif
a1271 1
      /* for each subglyph, read composite header */
a1272 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
a1273 1
#endif
d1275 1
d1278 1
a1278 1
        goto Fail;
d1280 1
a1280 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1282 2
a1283 1
#endif
d1287 49
a1341 1
        /* set up remaining glyph fields */
d1343 1
a1343 4

        glyph->num_subglyphs = gloader->base.num_subglyphs;
        glyph->format        = FT_GLYPH_FORMAT_COMPOSITE;
        glyph->subglyphs     = gloader->base.subglyphs;
a1351 1
      /* Now, read each subglyph independently. */
d1353 1
a1353 1
        FT_Int       n, num_base_points, num_new_points;
d1356 1
d1363 2
a1364 1
        for ( n = 0; n < (FT_Int)num_subglyphs; n++ )
d1366 1
a1366 2
          FT_Vector  pp1, pp2, pp3, pp4;
          FT_Pos     x, y;
d1375 4
a1378 174
          pp1 = loader->pp1;
          pp2 = loader->pp2;
          pp3 = loader->pp3;
          pp4 = loader->pp4;

          num_base_points = gloader->base.outline.n_points;

          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1 );
          if ( error )
            goto Fail;

          /* restore subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          if ( subglyph->flags & USE_MY_METRICS )
          {
            pp1 = loader->pp1;
            pp2 = loader->pp2;
            pp3 = loader->pp3;
            pp4 = loader->pp4;
          }
          else
          {
            loader->pp1 = pp1;
            loader->pp2 = pp2;
            loader->pp3 = pp3;
            loader->pp4 = pp4;
          }

          num_points = gloader->base.outline.n_points;

          num_new_points = num_points - num_base_points;

          /* now perform the transform required for this subglyph */

          if ( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                   WE_HAVE_AN_XY_SCALE |
                                   WE_HAVE_A_2X2       ) )
          {
            FT_Vector*  cur   = gloader->base.outline.points +
                                  num_base_points;
            FT_Vector*  org   = gloader->base.extra_points +
                                  num_base_points;
            FT_Vector*  limit = cur + num_new_points;


            for ( ; cur < limit; cur++, org++ )
            {
              FT_Vector_Transform( cur, &subglyph->transform );
              FT_Vector_Transform( org, &subglyph->transform );
            }
          }

          /* apply offset */

          if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
          {
            FT_UInt     k = subglyph->arg1;
            FT_UInt     l = subglyph->arg2;
            FT_Vector*  p1;
            FT_Vector*  p2;


            if ( start_point + k >= (FT_UInt)num_base_points ||
                               l >= (FT_UInt)num_new_points  )
            {
              error = TT_Err_Invalid_Composite;
              goto Fail;
            }

            l += num_base_points;

            p1 = gloader->base.outline.points + start_point + k;
            p2 = gloader->base.outline.points + start_point + l;

            x = p1->x - p2->x;
            y = p1->y - p2->y;
          }
          else
          {
            x = subglyph->arg1;
            y = subglyph->arg2;

  /* Use a default value dependent on                                     */
  /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
  /* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */

#ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
            if ( !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) &&
#else
            if (  ( subglyph->flags & SCALED_COMPONENT_OFFSET ) &&
#endif
                  ( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                        WE_HAVE_AN_XY_SCALE |
                                        WE_HAVE_A_2X2       )) )
            {
#if 0

  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is what Apple documents.  But it doesn't work.         */
  /*                                                                       */
              int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                                  : -subglyph->transform.xx;
              int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                                  : -subglyph->transform.yx;
              int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                                  : -subglyph->transform.xy;
              int  d = subglyph->transform.yy > 0 ? subglyph->transform.yy
                                                  : -subglyph->transform.yy;
              int  m = a > b ? a : b;
              int  n = c > d ? c : d;


              if ( a - b <= 33 && a - b >= -33 )
                m *= 2;
              if ( c - d <= 33 && c - d >= -33 )
                n *= 2;
              x = FT_MulFix( x, m );
              y = FT_MulFix( y, n );

#else /* 0 */

  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is a guess and works much better than the above.       */
  /*                                                                       */
              FT_Fixed  mac_xscale = FT_SqrtFixed(
                                       FT_MulFix( subglyph->transform.xx,
                                                  subglyph->transform.xx ) +
                                       FT_MulFix( subglyph->transform.xy,
                                                  subglyph->transform.xy) );
              FT_Fixed  mac_yscale = FT_SqrtFixed(
                                       FT_MulFix( subglyph->transform.yy,
                                                  subglyph->transform.yy ) +
                                       FT_MulFix( subglyph->transform.yx,
                                                  subglyph->transform.yx ) );


              x = FT_MulFix( x, mac_xscale );
              y = FT_MulFix( y, mac_yscale );
#endif /* 0 */

            }

            if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
            {
              x = FT_MulFix( x, x_scale );
              y = FT_MulFix( y, y_scale );

              if ( subglyph->flags & ROUND_XY_TO_GRID )
              {
                x = FT_PIX_ROUND( x );
                y = FT_PIX_ROUND( y );
              }
            }
          }

          if ( x || y )
          {
            translate_array( num_new_points,
                             gloader->base.outline.points + num_base_points,
                             x, y );

            translate_array( num_new_points,
                             gloader->base.extra_points + num_base_points,
                             x, y );
          }
        }

        /*******************************************************************/
        /*******************************************************************/
        /*******************************************************************/
d1380 1
a1380 2
        /* we have finished loading all sub-glyphs; now, look for */
        /* instructions for this composite!                       */
d1382 4
a1385 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1387 2
a1388 20
        if ( num_subglyphs > 0               &&
             loader->exec                    &&
             ins_pos > 0                     &&
             subglyph->flags & WE_HAVE_INSTR )
        {
          FT_UShort       n_ins;
          TT_ExecContext  exec = loader->exec;
          TT_GlyphZone    pts;
          FT_Vector*      pp1;


          /* read size of instructions */
          if ( FT_STREAM_SEEK( ins_pos ) ||
               FT_READ_USHORT( n_ins ) )
            goto Fail;
          FT_TRACE5(( "  Instructions size = %d\n", n_ins ));

          /* in some fonts? */
          if ( n_ins == 0xFFFFU )
            n_ins = 0;
d1390 1
a1390 2
          /* check it */
          if ( n_ins > face->max_profile.maxSizeOfInstructions )
d1392 4
a1395 4
            FT_TRACE0(( "Too many instructions (%d) in composite glyph %ld\n",
                        n_ins, subglyph->index ));
            error = TT_Err_Too_Many_Hints;
            goto Fail;
d1398 1
a1398 13
          /* read the instructions */
          if ( FT_STREAM_READ( exec->glyphIns, n_ins ) )
            goto Fail;

          glyph->control_data = exec->glyphIns;
          glyph->control_len  = n_ins;

          error = TT_Set_CodeRange( exec,
                                    tt_coderange_glyph,
                                    exec->glyphIns,
                                    n_ins );
          if ( error )
            goto Fail;
d1400 2
a1401 3
          error = FT_GlyphLoader_CheckPoints( gloader, num_points + 4, 0 );
          if ( error )
            goto Fail;
d1403 9
a1411 19
          /* prepare the execution context */
          tt_prepare_zone( &exec->pts, &gloader->base,
                           start_point, start_contour );
          pts = &exec->pts;

          pts->n_points   = (short)( num_points + 4 );
          pts->n_contours = gloader->base.outline.n_contours;

          /* add phantom points */
          pp1    = pts->cur + num_points;
          pp1[0] = loader->pp1;
          pp1[1] = loader->pp2;
          pp1[2] = loader->pp3;
          pp1[3] = loader->pp4;

          pts->tags[num_points    ] = 0;
          pts->tags[num_points + 1] = 0;
          pts->tags[num_points + 2] = 0;
          pts->tags[num_points + 3] = 0;
a1412 8
          /* if hinting, round the phantom points */
          if ( IS_HINTED( loader->load_flags ) )
          {
            pp1[0].x = FT_PIX_ROUND( loader->pp1.x );
            pp1[1].x = FT_PIX_ROUND( loader->pp2.x );
            pp1[2].y = FT_PIX_ROUND( loader->pp3.y );
            pp1[3].y = FT_PIX_ROUND( loader->pp4.y );
          }
d1414 3
a1416 2
          {
            FT_UInt  k;
d1418 1
d1420 1
a1420 3
            for ( k = 0; k < num_points; k++ )
              pts->tags[k] &= FT_CURVE_TAG_ON;
          }
d1422 1
a1422 19
          cur_to_org( num_points + 4, pts );

          /* now consider hinting */
          if ( IS_HINTED( loader->load_flags ) && n_ins > 0 )
          {
            exec->is_composite     = TRUE;
            exec->pedantic_hinting =
              (FT_Bool)( loader->load_flags & FT_LOAD_PEDANTIC );
            error = TT_Run_Context( exec, ((TT_Size)loader->size)->debug );
            if ( error && exec->pedantic_hinting )
              goto Fail;
          }

          /* save glyph origin and advance points */
          loader->pp1 = pp1[0];
          loader->pp2 = pp1[1];
          loader->pp3 = pp1[2];
          loader->pp4 = pp1[3];
        }
d1424 2
a1425 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
a1427 1
      /* end of composite loading */
d1433 1
a1433 1
      goto Fail;
d1440 2
a1441 1
  Fail:
d1445 1
a1445 1
  Exit:
a1446 1
#ifdef FT_CONFIG_OPTION_INCREMENTAL
d1451 1
a1473 10
    {
      glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;

      /* copy outline to our glyph slot */
      FT_GlyphLoader_CopyPoints( glyph->internal->loader, loader->gloader );
      glyph->outline = glyph->internal->loader->base.outline;

      /* translate array so that (0,0) is the glyph's origin */
      FT_Outline_Translate( &glyph->outline, -loader->pp1.x, 0 );

a1474 10

      if ( IS_HINTED( loader->load_flags ) )
      {
        /* grid-fit the bounding box */
        bbox.xMin = FT_PIX_FLOOR( bbox.xMin );
        bbox.yMin = FT_PIX_FLOOR( bbox.yMin );
        bbox.xMax = FT_PIX_CEIL( bbox.xMax );
        bbox.yMax = FT_PIX_CEIL( bbox.yMax );
      }
    }
a1501 4
    /* don't forget to hint the advance when we need to */
    if ( IS_HINTED( loader->load_flags ) )
      glyph->metrics.horiAdvance = FT_PIX_ROUND( glyph->metrics.horiAdvance );

d1507 2
a1508 2
      FT_Short   top_bearing;    /* vertical top side bearing (EM units) */
      FT_UShort  advance_height; /* vertical advance height   (EM units) */
a1509 3
      FT_Pos     left;     /* scaled vertical left side bearing */
      FT_Pos     top;      /* scaled vertical top side bearing  */
      FT_Pos     advance;  /* scaled vertical advance height    */
d1515 2
a1516 2
        advance_height = loader->pp4.y - loader->pp3.y;
        top_bearing    = loader->pp3.y - bbox.yMax;
d1518 5
d1526 5
a1530 1
        /* Make up the distances from the horizontal header.   */
d1536 3
a1538 12
        /*                                                     */
        /* NOTE2: The sTypoDescender is negative, which is why */
        /*        we compute the baseline-to-baseline distance */
        /*        here with:                                   */
        /*             ascender - descender + linegap          */
        /*                                                     */
        /* NOTE3: This is different from what MS's rasterizer  */
        /*        appears to do when getting default values    */
        /*        for the vertical phantom points.  We leave   */
        /*        the old code untouched, but relying on       */
        /*        phantom points alone might be reasonable     */
        /*        (i.e., removing the `if' above).             */
d1540 2
a1541 6
        {
          top_bearing    = (FT_Short)( face->os2.sTypoLineGap / 2 );
          advance_height = (FT_UShort)( face->os2.sTypoAscender -
                                        face->os2.sTypoDescender +
                                        face->os2.sTypoLineGap );
        }
d1543 4
a1546 6
        {
          top_bearing    = (FT_Short)( face->horizontal.Line_Gap / 2 );
          advance_height = (FT_UShort)( face->horizontal.Ascender  +
                                        face->horizontal.Descender +
                                        face->horizontal.Line_Gap );
        }
a1549 5

      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
d1551 3
a1553 2
        FT_Incremental_MetricsRec  metrics;
        FT_Error                   error = 0;
d1556 1
a1556 7
        metrics.bearing_x = 0;
        metrics.bearing_y = top_bearing;
        metrics.advance = advance_height;
        error =
          face->root.internal->incremental_interface->funcs->get_glyph_metrics(
            face->root.internal->incremental_interface->object,
            glyph_index, TRUE, &metrics );
d1558 14
a1571 2
        if ( error )
          return error;
d1573 3
a1575 2
        top_bearing    = (FT_Short)metrics.bearing_y;
        advance_height = (FT_UShort)metrics.advance;
d1582 1
a1582 3
      /* We must adjust the top_bearing value from the bounding box given */
      /* in the glyph header to the bounding box calculated with          */
      /* FT_Get_Outline_CBox().                                           */
d1587 2
a1588 8
        top     = FT_MulFix( top_bearing + loader->bbox.yMax, y_scale )
                    - bbox.yMax;
        advance = FT_MulFix( advance_height, y_scale );
      }
      else
      {
        top     = top_bearing + loader->bbox.yMax - bbox.yMax;
        advance = advance_height;
a1590 4
      /* set the advance height in design units.  It is scaled later by */
      /* the base layer.                                                */
      glyph->linearVertAdvance = advance_height;

d1594 1
a1594 11
      left = ( bbox.xMin - bbox.xMax ) / 2;

      /* grid-fit them if necessary */
      if ( IS_HINTED( loader->load_flags ) )
      {
        left    = FT_PIX_FLOOR( left );
        top     = FT_PIX_CEIL( top );
        advance = FT_PIX_ROUND( advance );
      }

      glyph->metrics.vertBearingX = left;
d1600 1
a1600 1
    if ( !face->postscript.isFixedPitch && size &&
d1603 1
a1603 2
      FT_Byte*  widths = Get_Advance_Widths( face,
                                             size->root.metrics.x_ppem );
d1606 6
a1611 2
      if ( widths )
        glyph->metrics.horiAdvance = widths[glyph_index] << 6;
d1622 153
a1807 1
    SFNT_Service  sfnt;
a1814 1
    sfnt   = (SFNT_Service)face->sfnt;
d1816 1
a1816 12
    error  = 0;

    if ( !size || ( load_flags & FT_LOAD_NO_SCALE )   ||
                  ( load_flags & FT_LOAD_NO_RECURSE ) )
    {
      size        = NULL;
      load_flags |= FT_LOAD_NO_SCALE   |
                    FT_LOAD_NO_HINTING |
                    FT_LOAD_NO_BITMAP;
    }

    glyph->num_subglyphs = 0;
d1824 1
a1824 3
    if ( size                                    &&
         size->strike_index != 0xFFFFU           &&
         sfnt->load_sbits                        &&
a1825 1

d1827 1
a1827 10
      TT_SBit_MetricsRec  metrics;


      error = sfnt->load_sbit_image( face,
                                     (FT_ULong)size->strike_index,
                                     glyph_index,
                                     (FT_Int)load_flags,
                                     stream,
                                     &glyph->bitmap,
                                     &metrics );
d1829 1
a1829 28
      {
        glyph->outline.n_points   = 0;
        glyph->outline.n_contours = 0;

        glyph->metrics.width  = (FT_Pos)metrics.width  << 6;
        glyph->metrics.height = (FT_Pos)metrics.height << 6;

        glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
        glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
        glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

        glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
        glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
        glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;

        glyph->format = FT_GLYPH_FORMAT_BITMAP;
        if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
        {
          glyph->bitmap_left = metrics.vertBearingX;
          glyph->bitmap_top  = metrics.vertBearingY;
        }
        else
        {
          glyph->bitmap_left = metrics.horiBearingX;
          glyph->bitmap_top  = metrics.horiBearingY;
        }
        return error;
      }
d1834 4
a1837 1
    /* return immediately if we only want the embedded bitmaps */
d1841 3
a1843 3
    /* seek to the beginning of the glyph table.  For Type 42 fonts      */
    /* the table might be accessed from a Postscript stream or something */
    /* else...                                                           */
d1845 3
a1847 6
#ifdef FT_CONFIG_OPTION_INCREMENTAL

    /* Don't look for the glyph table if this is an incremental font. */
    if ( !face->root.internal->incremental_interface )

#endif
d1849 3
d1853 1
a1853 2
      error = face->goto_table( face, TTAG_glyf, stream, 0 );
      if ( error )
d1855 2
a1856 2
        FT_ERROR(( "TT_Load_Glyph: could not access glyph table\n" ));
        goto Exit;
d1858 4
a1861 1
    }
d1863 5
a1867 1
    FT_MEM_ZERO( &loader, sizeof ( loader ) );
d1869 1
a1869 28
    /* update the glyph zone bounds */
    {
      FT_GlyphLoader  gloader = FT_FACE_DRIVER(face)->glyph_loader;


      loader.gloader = gloader;

      FT_GlyphLoader_Rewind( gloader );

      tt_prepare_zone( &loader.zone, &gloader->base, 0, 0 );
      tt_prepare_zone( &loader.base, &gloader->base, 0, 0 );
    }

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    if ( size )
    {
      /* query new execution context */
      loader.exec = size->debug ? size->context : TT_New_Context( face );
      if ( !loader.exec )
        return TT_Err_Could_Not_Find_Context;

      TT_Load_Context( loader.exec, face, size );
      loader.instructions = loader.exec->glyphIns;

      /* load default graphics state - if needed */
      if ( size->GS.instruct_control & 2 )
        loader.exec->GS = tt_default_graphics_state;
a1871 48
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */

    /* clear all outline flags, except the `owner' one */
    glyph->outline.flags = 0;

    /* let's initialize the rest of our loader now */

    loader.load_flags    = load_flags;

    loader.face   = (FT_Face)face;
    loader.size   = (FT_Size)size;
    loader.glyph  = (FT_GlyphSlot)glyph;
    loader.stream = stream;

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( face->root.internal->incremental_interface )
      loader.glyf_offset = 0;
    else

#endif

      loader.glyf_offset = FT_STREAM_POS();

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    /* if the cvt program has disabled hinting, the argument */
    /* is ignored.                                           */
    if ( size && ( size->GS.instruct_control & 1 ) )
      loader.load_flags |= FT_LOAD_NO_HINTING;

#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */

    /* Main loading loop */
    glyph->format        = FT_GLYPH_FORMAT_OUTLINE;
    glyph->num_subglyphs = 0;

    error = load_truetype_glyph( &loader, glyph_index, 0 );
    if ( !error )
      compute_glyph_metrics( &loader, glyph_index );

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    if ( !size || !size->debug )
      TT_Done_Context( loader.exec );

#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */

d1876 2
a1877 1
    if ( size && size->root.metrics.y_ppem < 24 )
a1879 1
  Exit:
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a27 5
#include "ttpload.h"

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif
d61 64
d138 1
a138 1
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );
d147 20
d188 1
a188 1
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );
d190 1
a190 1
#if 1             /* Empirically determined, at variance with what MS said */
d205 1
a205 1
    else
d216 7
d246 15
a291 3
    loader->cursor = stream->cursor;
    loader->limit  = stream->limit;

d309 2
a310 2
    FT_Byte*  p     = loader->cursor;
    FT_Byte*  limit = loader->limit;
d313 1
a313 1
    if ( p + 10 > limit )
d316 1
a316 1
    loader->n_contours = FT_NEXT_SHORT( p );
d318 4
a321 4
    loader->bbox.xMin = FT_NEXT_SHORT( p );
    loader->bbox.yMin = FT_NEXT_SHORT( p );
    loader->bbox.xMax = FT_NEXT_SHORT( p );
    loader->bbox.yMax = FT_NEXT_SHORT( p );
d328 1
a328 1
    loader->cursor = p;
d338 1
a338 2
    FT_Byte*        p          = load->cursor;
    FT_Byte*        limit      = load->limit;
d343 1
d345 2
a346 1
    FT_Int          n_points;
d352 1
a352 2
    FT_Short        *cont, *cont_limit, prev_cont;
    FT_Int          xy_size = 0;
d355 1
a355 6
    /* check that we can add the contours to the glyph */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
    if ( error )
      goto Fail;

    /* reading the contours' endpoints & number of points */
d360 2
a361 1
    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
d364 2
a365 12
    cont[0] = prev_cont = FT_NEXT_USHORT( p );
    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = FT_NEXT_USHORT( p );
      if ( cont[0] <= prev_cont )
      {
        /* unordered contours: this is invalid */
        error = FT_Err_Invalid_Table;
        goto Fail;
      }
      prev_cont = cont[0];
    }
a368 1
    {
a369 3
      if ( n_points < 0 )
        goto Invalid_Outline;
    }
d371 1
a371 2
    /* note that we will add four phantom points later */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
d383 2
a384 5
    load->glyph->control_len  = 0;
    load->glyph->control_data = 0;

    if ( p + 2 > limit )
      goto Invalid_Outline;
d386 1
a386 1
    n_ins = FT_NEXT_USHORT( p );
d392 1
a392 2
      FT_TRACE0(( "TT_Load_Simple_Glyph: Too many instructions (%d)\n",
                  n_ins ));
d397 2
a398 1
    if ( ( limit - p ) < n_ins )
d405 1
a405 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d407 3
a409 1
    if ( IS_HINTED( load->load_flags ) )
d411 2
a412 2
      load->glyph->control_len  = n_ins;
      load->glyph->control_data = load->exec->glyphIns;
d414 1
a414 1
      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
d417 1
a417 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d419 1
a419 1
    p += n_ins;
a424 2
    FT_ASSERT( flag != NULL );

d427 1
a427 1
      if ( p + 1 > limit )
d430 1
a430 1
      *flag++ = c = FT_NEXT_BYTE( p );
d433 1
a433 1
        if ( p + 1 > limit )
d436 1
a436 1
        count = FT_NEXT_BYTE( p );
d445 17
a468 3
    if ( p + xy_size > limit )
      goto Invalid_Outline;

a471 1
      FT_Byte f = *flag;
d474 1
a474 1
      if ( f & 2 )
d476 2
a477 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 16 ) == 0 )
d480 2
a481 7
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a484 1
      *flag  = f & ~( 2 | 16 );
a496 1
      FT_Byte f = *flag;
d499 1
a499 1
      if ( f & 4 )
d501 2
a502 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 32 ) == 0 )
d505 2
a506 7
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a509 1
      *flag  = f & FT_CURVE_TAG_ON;
d512 4
d519 1
a519 1
    load->cursor = p;
d534 1
a534 2
    FT_Byte*        p       = loader->cursor;
    FT_Byte*        limit   = loader->limit;
d538 1
a545 1
      FT_UInt   count;
d554 2
a555 1
      if ( p + 4 > limit )
d562 2
a563 2
      subglyph->flags = FT_NEXT_USHORT( p );
      subglyph->index = FT_NEXT_USHORT( p );
d566 1
a566 1
      count = 2;
d568 1
a568 1
        count += 2;
d570 1
a570 1
        count += 2;
d572 1
a572 1
        count += 4;
d574 1
a574 1
        count += 8;
d576 1
a576 1
      if ( p + count > limit )
d582 2
a583 2
        subglyph->arg1 = FT_NEXT_SHORT( p );
        subglyph->arg2 = FT_NEXT_SHORT( p );
d587 2
a588 2
        subglyph->arg1 = FT_NEXT_CHAR( p );
        subglyph->arg2 = FT_NEXT_CHAR( p );
d597 1
a597 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d602 2
a603 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d607 4
a610 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d624 1
a624 2
#ifdef TT_USE_BYTECODE_INTERPRETER

a625 3
      FT_Stream  stream = loader->stream;


d631 1
a631 1
                                    p - limit );
a632 1

d635 1
a635 1
    loader->cursor = p;
a656 18
  static void
  tt_prepare_zone( TT_GlyphZone  zone,
                   FT_GlyphLoad  load,
                   FT_UInt       start_point,
                   FT_UInt       start_contour )
  {
    zone->n_points    = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours  = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
    zone->org         = load->extra_points + start_point;
    zone->cur         = load->outline.points + start_point;
    zone->orus        = load->extra_points2 + start_point;
    zone->tags        = (FT_Byte*)load->outline.tags + start_point;
    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
  }


d660 1
a660 1
  /*    TT_Hint_Glyph                                                      */
d663 3
a665 2
  /*    Hint the glyph using the zone prepared by the caller.  Note that   */
  /*    the zone is supposed to include four phantom points.               */
d668 2
a669 2
  TT_Hint_Glyph( TT_Loader  loader,
                 FT_Bool    is_composite )
d671 5
a675 7
    TT_GlyphZone  zone = &loader->zone;
    FT_Pos        origin;

#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_UInt       n_ins;
#else
    FT_UNUSED( is_composite );
d677 2
d680 1
a681 3
#ifdef TT_USE_BYTECODE_INTERPRETER
    n_ins = loader->glyph->control_len;
#endif
d683 2
a684 9
    origin = zone->cur[zone->n_points - 4].x;
    origin = FT_PIX_ROUND( origin ) - origin;
    if ( origin )
      translate_array( zone->n_points, zone->cur, origin, 0 );

#ifdef TT_USE_BYTECODE_INTERPRETER
    /* save original point position in org */
    if ( n_ins > 0 )
      FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );
d687 1
a687 5
    /* round pp2 and pp4 */
    zone->cur[zone->n_points - 3].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 3].x );
    zone->cur[zone->n_points - 1].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 1].y );
d689 4
a692 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a693 1
    if ( n_ins > 0 )
d695 4
a698 2
      FT_Bool   debug;
      FT_Error  error;
d701 4
a704 4
      error = TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                                loader->exec->glyphIns, n_ins );
      if ( error )
        return error;
d706 4
a709 2
      loader->exec->is_composite = is_composite;
      loader->exec->pts          = *zone;
d711 4
a714 7
      debug = FT_BOOL( !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
                       ((TT_Size)loader->size)->debug             );

      error = TT_Run_Context( loader->exec, debug );
      if ( error && loader->exec->pedantic_hinting )
        return error;
    }
d716 4
a719 1
#endif
d721 4
a724 7
    /* save glyph phantom points */
    if ( !loader->preserve_pps )
    {
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
d727 2
a728 37
    return TT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Simple_Glyph                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a simple glyph has been loaded, it needs to be processed.     */
  /*    Usually, this means scaling and hinting through bytecode           */
  /*    interpretation.                                                    */
  /*                                                                       */
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader  loader )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Error        error   = TT_Err_Ok;
    FT_Outline*     outline;
    FT_UInt         n_points;


    outline  = &gloader->current.outline;
    n_points = outline->n_points;

    /* set phantom points */

    outline->points[n_points    ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;

    outline->tags[n_points    ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;
d732 2
a733 1
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
d735 2
a736 1
    if ( ((TT_Face)loader->face)->doblend )
d738 4
a741 4
      /* Deltas apply to the unscaled data. */
      FT_Vector*  deltas;
      FT_Memory   memory = loader->face->memory;
      FT_UInt     i;
d744 2
a745 8
      error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                        loader->glyph_index,
                                        &deltas,
                                        n_points );
      if ( error )
        return error;

      for ( i = 0; i < n_points; ++i )
d747 2
a748 2
        outline->points[i].x += deltas[i].x;
        outline->points[i].y += deltas[i].y;
a749 2

      FT_FREE( deltas );
d752 1
a752 1
#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
d754 2
a755 1
    if ( IS_HINTED( loader->load_flags ) )
d757 2
a758 1
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
a759 3
      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
                     loader->zone.n_points + 4 );
    }
d761 8
a768 7
    /* scale the glyph */
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      FT_Vector*  vec     = outline->points;
      FT_Vector*  limit   = outline->points + n_points;
      FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d770 1
d772 2
a773 1
      for ( ; vec < limit; vec++ )
d775 16
a790 2
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
d793 2
a794 4
      loader->pp1 = outline->points[n_points - 4];
      loader->pp2 = outline->points[n_points - 3];
      loader->pp3 = outline->points[n_points - 2];
      loader->pp4 = outline->points[n_points - 1];
d797 2
a798 1
    if ( IS_HINTED( loader->load_flags ) )
d800 4
a803 3
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
d806 3
d816 1
a816 1
  /*    TT_Process_Composite_Component                                     */
d819 2
a820 2
  /*    Once a composite component has been loaded, it needs to be         */
  /*    processed.  Usually, this means transforming and translating.      */
d823 3
a825 4
  TT_Process_Composite_Component( TT_Loader    loader,
                                  FT_SubGlyph  subglyph,
                                  FT_UInt      start_point,
                                  FT_UInt      num_base_points )
a826 5
    FT_GlyphLoader  gloader    = loader->gloader;
    FT_Vector*      base_vec   = gloader->base.outline.points;
    FT_UInt         num_points = gloader->base.outline.n_points;
    FT_Bool         have_scale;
    FT_Pos          x, y;
d828 3
d832 8
a839 3
    have_scale = FT_BOOL( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                              WE_HAVE_AN_XY_SCALE |
                                              WE_HAVE_A_2X2       ) );
d841 5
a845 4
    /* perform the transform required for this subglyph */
    if ( have_scale )
    {
      FT_UInt  i;
d848 4
a851 2
      for ( i = num_base_points; i < num_points; i++ )
        FT_Vector_Transform( base_vec + i, &subglyph->transform );
d854 2
a855 2
    /* get offset */
    if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
d857 3
a859 4
      FT_UInt     k = subglyph->arg1;
      FT_UInt     l = subglyph->arg2;
      FT_Vector*  p1;
      FT_Vector*  p2;
d861 2
d864 7
a870 2
      /* match l-th point of the newly loaded component to the k-th point */
      /* of the previously loaded components.                             */
d872 4
a875 6
      /* change to the point numbers used by our outline */
      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points      )
        return TT_Err_Invalid_Composite;
a876 2
      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;
d878 10
a887 7
      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;
d889 1
a889 2
      if ( !x && !y )
        return TT_Err_Ok;
d891 4
a894 10
  /* Use a default value dependent on                                     */
  /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
  /* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */

      if ( have_scale &&
#ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
           !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) )
#else
            ( subglyph->flags & SCALED_COMPONENT_OFFSET ) )
#endif
d896 1
a897 1
#if 0
d899 11
a909 22
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is what Apple documents.  But it doesn't work.         */
  /*                                                                       */
        int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                            : -subglyph->transform.xx;
        int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                            : -subglyph->transform.yx;
        int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                            : -subglyph->transform.xy;
        int  d = subglyph->transform.yy > 0 ? subglyph->transform.yy
                                            : -subglyph->transform.yy;
        int  m = a > b ? a : b;
        int  n = c > d ? c : d;


        if ( a - b <= 33 && a - b >= -33 )
          m *= 2;
        if ( c - d <= 33 && c - d >= -33 )
          n *= 2;
        x = FT_MulFix( x, m );
        y = FT_MulFix( y, n );
d911 6
a916 1
#else /* 0 */
a917 14
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is a guess and works much better than the above.       */
  /*                                                                       */
        FT_Fixed  mac_xscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.xx,
                                            subglyph->transform.xx ) +
                                 FT_MulFix( subglyph->transform.xy,
                                            subglyph->transform.xy ) );
        FT_Fixed  mac_yscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.yy,
                                            subglyph->transform.yy ) +
                                 FT_MulFix( subglyph->transform.yx,
                                            subglyph->transform.yx ) );
d919 1
a919 239

        x = FT_MulFix( x, mac_xscale );
        y = FT_MulFix( y, mac_yscale );

#endif /* 0 */

      }

      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        FT_Fixed  x_scale = ((TT_Size)loader->size)->metrics.x_scale;
        FT_Fixed  y_scale = ((TT_Size)loader->size)->metrics.y_scale;


        x = FT_MulFix( x, x_scale );
        y = FT_MulFix( y, y_scale );

        if ( subglyph->flags & ROUND_XY_TO_GRID )
        {
          x = FT_PIX_ROUND( x );
          y = FT_PIX_ROUND( y );
        }
      }
    }

    if ( x || y )
      translate_array( num_points - num_base_points,
                       base_vec + num_base_points,
                       x, y );

    return TT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Glyph                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is slightly different from TT_Process_Simple_Glyph, in that   */
  /*    its sole purpose is to hint the glyph.  Thus this function is      */
  /*    only available when bytecode interpreter is enabled.               */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader  loader,
                              FT_UInt    start_point,
                              FT_UInt    start_contour )
  {
    FT_Error     error;
    FT_Outline*  outline;
    FT_UInt      i;


    outline = &loader->gloader->base.outline;

    /* make room for phantom points */
    error = FT_GLYPHLOADER_CHECK_POINTS( loader->gloader,
                                         outline->n_points + 4,
                                         0 );
    if ( error )
      return error;

    outline->points[outline->n_points    ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points    ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;

#ifdef TT_USE_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;
      FT_UShort  n_ins;


      /* TT_Load_Composite_Glyph only gives us the offset of instructions */
      /* so we read them here                                             */
      if ( FT_STREAM_SEEK( loader->ins_pos ) ||
           FT_READ_USHORT( n_ins )           )
        return error;

      FT_TRACE5(( "  Instructions size = %d\n", n_ins ));

      /* check it */
      if ( n_ins > ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions )
      {
        FT_TRACE0(( "TT_Process_Composite_Glyph: Too many instructions (%d)\n",
                    n_ins ));

        return TT_Err_Too_Many_Hints;
      }
      else if ( n_ins == 0 )
        return TT_Err_Ok;

      if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len  = n_ins;
    }

#endif

    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );

    /* Some points are likely touched during execution of  */
    /* instructions on components.  So let's untouch them. */
    for ( i = start_point; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~( FT_CURVE_TAG_TOUCH_X |
                                 FT_CURVE_TAG_TOUCH_Y );

    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }


  /* Calculate the four phantom points.                     */
  /* The first two stand for horizontal origin and advance. */
  /* The last two stand for vertical origin and advance.    */
#define TT_LOADER_SET_PP( loader )                                          \
          do {                                                              \
            (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \
            (loader)->pp1.y = 0;                                            \
            (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \
            (loader)->pp2.y = 0;                                            \
            (loader)->pp3.x = 0;                                            \
            (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax;  \
            (loader)->pp4.x = 0;                                            \
            (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \
          } while ( 0 )


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    load_truetype_glyph                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads a given truetype glyph.  Handles composites and uses a       */
  /*    TT_Loader object.                                                  */
  /*                                                                       */
  static FT_Error
  load_truetype_glyph( TT_Loader  loader,
                       FT_UInt    glyph_index,
                       FT_UInt    recurse_count )
  {
    FT_Error        error;
    FT_Fixed        x_scale, y_scale;
    FT_ULong        offset;
    TT_Face         face         = (TT_Face)loader->face;
    FT_GlyphLoader  gloader      = loader->gloader;
    FT_Bool         opened_frame = 0;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    FT_Vector*      deltas       = NULL;
#endif

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    FT_StreamRec    inc_stream;
    FT_Data         glyph_data;
    FT_Bool         glyph_data_loaded = 0;
#endif


    if ( recurse_count > face->max_profile.maxComponentDepth )
    {
      error = TT_Err_Invalid_Composite;
      goto Exit;
    }

    /* check glyph index */
    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
    {
      error = TT_Err_Invalid_Glyph_Index;
      goto Exit;
    }

    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      y_scale = ((TT_Size)loader->size)->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }

    /* get metrics, horizontal and vertical */
    {
      FT_Short   left_bearing = 0, top_bearing = 0;
      FT_UShort  advance_width = 0, advance_height = 0;


      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &top_bearing,
                    &advance_height );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
      {
        FT_Incremental_MetricsRec  metrics;


        metrics.bearing_x = left_bearing;
        metrics.bearing_y = 0;
        metrics.advance = advance_width;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, FALSE, &metrics );
        if ( error )
          goto Exit;
        left_bearing  = (FT_Short)metrics.bearing_x;
        advance_width = (FT_UShort)metrics.advance;

#if 0

        /* GWW: Do I do the same for vertical metrics? */
        metrics.bearing_x = 0;
a928 3

#endif /* 0 */

d930 1
a945 4
    /* Set `offset' to the start of the glyph relative to the start of */
    /* the `glyf' table, and `byte_len' to the length of the glyph in  */
    /* bytes.                                                          */

d948 4
d955 1
d966 1
a966 1
      loader->byte_len  = glyph_data.length;
d978 7
a984 2
      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );
d986 1
a986 1
    if ( loader->byte_len == 0 )
d988 2
a989 2
      /* as described by Frederic Loyer, these are spaces or */
      /* the unknown glyph.                                  */
d995 4
a998 1
      TT_LOADER_SET_PP( loader );
d1000 1
a1000 3
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( ((TT_Face)(loader->face))->doblend )
d1002 3
a1004 2
        /* this must be done before scaling */
        FT_Memory  memory = loader->face->memory;
d1006 1
d1008 2
a1009 12
        error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                          glyph_index, &deltas, 4 );
        if ( error )
          goto Exit;

        loader->pp1.x += deltas[0].x; loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x; loader->pp2.y += deltas[1].y;
        loader->pp3.x += deltas[2].x; loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x; loader->pp4.y += deltas[3].y;

        FT_FREE( deltas );
      }
a1012 8
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

d1017 6
a1022 3
    error = face->access_glyph_frame( loader, glyph_index,
                                      loader->glyf_offset + offset,
                                      loader->byte_len );
d1031 5
a1035 1
      goto Exit;
d1037 17
a1053 1
    TT_LOADER_SET_PP( loader );
d1061 1
a1061 1
    if ( loader->n_contours >= 0 )
d1063 5
d1070 15
a1084 1
        goto Exit;
d1086 1
a1086 3
      /* all data have been read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;
a1087 1
      error = TT_Process_Simple_Glyph( loader );
d1089 1
a1089 1
        goto Exit;
d1092 3
d1102 1
a1102 1
    else if ( loader->n_contours == -1 )
d1104 6
a1109 3
      FT_UInt   start_point;
      FT_UInt   start_contour;
      FT_ULong  ins_pos;  /* position of composite instructions, if any */
d1112 1
d1114 1
d1116 1
a1117 1
      /* for each subglyph, read composite header */
d1120 1
a1120 1
        goto Exit;
d1122 1
a1122 1
      /* store the offset of instructions */
d1124 1
a1124 2

      /* all data we need are read */
d1128 8
a1135 1
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
d1137 12
a1148 1
      if ( face->doblend )
d1150 2
a1151 3
        FT_Int       i, limit;
        FT_SubGlyph  subglyph;
        FT_Memory    memory = face->root.memory;
d1153 2
a1155 2
        /* this provides additional offsets */
        /* for each component's translation */
d1157 47
a1203 6
        if ( ( error = TT_Vary_Get_Glyph_Deltas(
                         face,
                         glyph_index,
                         &deltas,
                         gloader->current.num_subglyphs + 4 )) != 0 )
          goto Exit;
d1205 1
a1205 2
        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
        limit    = gloader->current.num_subglyphs;
d1207 3
a1209 3
        for ( i = 0; i < limit; ++i, ++subglyph )
        {
          if ( subglyph->flags & ARGS_ARE_XY_VALUES )
d1211 12
a1222 2
            subglyph->arg1 += deltas[i].x;
            subglyph->arg2 += deltas[i].y;
a1223 1
        }
d1225 16
a1240 4
        loader->pp1.x += deltas[i + 0].x; loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x; loader->pp2.y += deltas[i + 1].y;
        loader->pp3.x += deltas[i + 2].x; loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x; loader->pp4.y += deltas[i + 3].y;
d1242 1
a1242 2
        FT_FREE( deltas );
      }
d1244 2
a1245 1
#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
d1247 7
a1253 7
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }
d1255 3
a1257 7
      /* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
      /* `as is' in the glyph slot (the client application will be     */
      /* responsible for interpreting these data)...                   */
      if ( loader->load_flags & FT_LOAD_NO_RECURSE )
      {
        FT_GlyphLoader_Add( gloader );
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;
d1259 10
a1268 2
        goto Exit;
      }
d1270 22
a1291 3
      /*********************************************************************/
      /*********************************************************************/
      /*********************************************************************/
d1293 1
a1293 3
      {
        FT_UInt           n, num_base_points;
        FT_SubGlyph       subglyph       = 0;
d1295 14
a1308 3
        FT_UInt           num_points     = start_point;
        FT_UInt           num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt           num_base_subgs = gloader->base.num_subglyphs;
a1309 1
        FT_Stream         old_stream     = loader->stream;
d1311 3
a1313 1
        TT_GraphicsState  saved_GS;
d1315 1
d1317 12
a1328 2
        if ( loader->exec )
          saved_GS = loader->exec->GS;
d1330 11
a1340 1
        FT_GlyphLoader_Add( gloader );
d1342 13
a1354 2
        /* read each subglyph independently */
        for ( n = 0; n < num_subglyphs; n++ )
d1356 15
a1370 1
          FT_Vector  pp[4];
d1372 8
d1381 13
a1393 16
          /* reinitialize graphics state */
          if ( loader->exec )
            loader->exec->GS = saved_GS;

          /* Each time we call load_truetype_glyph in this loop, the   */
          /* value of `gloader.base.subglyphs' can change due to table */
          /* reallocations.  We thus need to recompute the subglyph    */
          /* pointer on each iteration.                                */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;

          num_base_points = gloader->base.outline.n_points;
d1395 1
a1395 2
          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1 );
d1397 1
a1397 1
            goto Exit;
d1399 19
a1417 2
          /* restore subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;
d1419 2
a1420 1
          if ( !( subglyph->flags & USE_MY_METRICS ) )
d1422 4
a1425 4
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];
d1428 2
a1429 1
          num_points = gloader->base.outline.n_points;
a1430 2
          if ( num_points == num_base_points )
            continue;
d1432 3
a1434 9
          /* gloader->base.outline consists of three parts:               */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
          /*                                                              */
          /* (1): exists from the beginning                               */
          /* (2): components that have been loaded so far                 */
          /* (3): the newly loaded component                              */
          TT_Process_Composite_Component( loader, subglyph, start_point,
                                          num_base_points );
        }
d1436 1
a1436 1
        loader->stream = old_stream;
d1438 10
a1447 3
        /* process the glyph */
        loader->ins_pos = ins_pos;
        if ( IS_HINTED( loader->load_flags ) &&
d1449 6
a1454 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d1456 1
a1456 6
             subglyph->flags & WE_HAVE_INSTR &&

#endif

             num_points > start_point )
          TT_Process_Composite_Glyph( loader, start_point, start_contour );
d1459 1
d1463 1
a1463 1
      /* invalid composite count (negative but not -1) */
d1465 1
a1465 1
      goto Exit;
d1472 1
a1472 2
  Exit:

d1476 2
a1478 1

a1482 1

d1490 2
a1491 2
  compute_glyph_metrics( TT_Loader  loader,
                         FT_UInt    glyph_index )
d1505 10
d1516 10
d1529 2
a1530 2
    /* get the device-independent horizontal advance; it is scaled later */
    /* by the base layer.                                                */
d1553 4
d1562 2
a1563 2
      FT_Pos  top;      /* scaled vertical top side bearing  */
      FT_Pos  advance;  /* scaled vertical advance height    */
d1565 3
d1573 2
a1574 2
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );
a1575 5
        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
d1579 1
a1579 5
        FT_Pos  height;


        /* XXX Compute top side bearing and advance height in  */
        /*     Get_VMetrics instead of here.                   */
d1585 12
a1596 3

        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
d1598 6
a1603 2
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
d1605 6
a1610 4
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
d1614 5
d1620 2
a1621 3
        FT_Incremental_InterfaceRec*  incr;
        FT_Incremental_MetricsRec     metrics;
        FT_Error                      error;
d1624 7
a1630 1
        incr = face->root.internal->incremental_interface;
d1632 2
a1633 14
        /* If this is an incrementally loaded font see if there are */
        /* overriding metrics for this glyph.                       */
        if ( incr && incr->funcs->get_glyph_metrics )
        {
          metrics.bearing_x = 0;
          metrics.bearing_y = top;
          metrics.advance   = advance;

          error = incr->funcs->get_glyph_metrics( incr->object,
                                                  glyph_index,
                                                  TRUE,
                                                  &metrics );
          if ( error )
            return error;
d1635 2
a1636 3
          top     = metrics.bearing_y;
          advance = metrics.advance;
        }
d1643 3
a1645 1
      glyph->linearVertAdvance = advance;
d1650 8
a1657 2
        top     = FT_MulFix( top, y_scale );
        advance = FT_MulFix( advance, y_scale );
d1660 4
d1667 11
a1677 1
      glyph->metrics.vertBearingX = ( bbox.xMin - bbox.xMax ) / 2;
d1683 1
a1683 1
    if ( !face->postscript.isFixedPitch &&
d1686 2
a1687 1
      FT_Byte*  widthp;
d1690 2
a1691 6
      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
d1702 32
a1733 7
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  static FT_Error
  load_sbit_image( TT_Size       size,
                   TT_GlyphSlot  glyph,
                   FT_UInt       glyph_index,
                   FT_Int32      load_flags )
d1735 5
a1739 5
    TT_Face             face;
    SFNT_Service        sfnt;
    FT_Stream           stream;
    FT_Error            error;
    TT_SBit_MetricsRec  metrics;
d1745 1
d1747 2
a1748 8
    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_Int)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
d1750 4
a1753 25
      glyph->outline.n_points   = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width  = (FT_Pos)metrics.width  << 6;
      glyph->metrics.height = (FT_Pos)metrics.height << 6;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;
      if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top  = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top  = metrics.horiBearingY;
      }
d1756 1
a1756 2
    return error;
  }
d1758 1
a1758 1
#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
d1760 8
a1768 19
  static FT_Error
  tt_loader_init( TT_Loader     loader,
                  TT_Size       size,
                  TT_GlyphSlot  glyph,
                  FT_Int32      load_flags )
  {
    TT_Face    face;
    FT_Stream  stream;


    face   = (TT_Face)glyph->face;
    stream = face->root.stream;

    FT_MEM_ZERO( loader, sizeof ( TT_LoaderRec ) );

#ifdef TT_USE_BYTECODE_INTERPRETER

    /* load execution context */
    if ( IS_HINTED( load_flags ) )
d1770 1
a1770 2
      TT_ExecContext  exec;
      FT_Bool         grayscale;
d1773 8
a1780 1
      if ( !size->cvt_ready )
d1782 2
a1783 10
        FT_Error  error = tt_size_ready_bytecode( size );
        if ( error )
          return error;
      }

      /* query new execution context */
      exec = size->debug ? size->context
                         : ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;
      if ( !exec )
        return TT_Err_Could_Not_Find_Context;
d1785 2
a1786 2
      grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );
d1788 7
a1794 1
      TT_Load_Context( exec, face, size );
d1796 12
a1807 12
      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale )
      {
        FT_UInt  i;


        exec->grayscale = grayscale;

        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size );
d1809 1
d1811 1
a1811 3
      /* see whether the cvt program has disabled hinting */
      if ( exec->GS.instruct_control & 1 )
        load_flags |= FT_LOAD_NO_HINTING;
d1813 3
a1815 10
      /* load default graphics state -- if needed */
      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;

      exec->pedantic_hinting = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }

#endif /* TT_USE_BYTECODE_INTERPRETER */
d1817 1
a1817 1
    /* seek to the beginning of the glyph table -- for Type 42 fonts     */
d1823 2
a1824 3
    if ( face->root.internal->incremental_interface )
      loader->glyf_offset = 0;
    else
d1829 1
a1829 3
      FT_Error  error = face->goto_table( face, TTAG_glyf, stream, 0 );


d1833 1
a1833 1
        return error;
a1834 1
      loader->glyf_offset = FT_STREAM_POS();
d1837 3
a1839 1
    /* get face's glyph loader */
d1841 2
a1842 1
      FT_GlyphLoader  gloader = glyph->internal->loader;
d1844 1
d1847 3
a1849 1
      loader->gloader = gloader;
d1852 11
a1862 1
    loader->load_flags    = load_flags;
d1864 6
a1869 4
    loader->face   = (FT_Face)face;
    loader->size   = (FT_Size)size;
    loader->glyph  = (FT_GlyphSlot)glyph;
    loader->stream = stream;
d1871 2
a1872 2
    return TT_Err_Ok;
  }
d1874 1
d1876 1
a1876 36
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to load a single glyph within a given glyph slot,  */
  /*    for a given size.                                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    glyph       :: A handle to a target slot object where the glyph    */
  /*                   will be loaded.                                     */
  /*                                                                       */
  /*    size        :: A handle to the source face size at which the glyph */
  /*                   must be scaled/loaded.                              */
  /*                                                                       */
  /*    glyph_index :: The index of the glyph in the font file.            */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   FT_LOAD_XXX constants can be used to control the    */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  TT_Load_Glyph( TT_Size       size,
                 TT_GlyphSlot  glyph,
                 FT_UInt       glyph_index,
                 FT_Int32      load_flags )
  {
    TT_Face       face;
    FT_Error      error;
    TT_LoaderRec  loader;
d1878 4
d1883 1
a1883 2
    face   = (TT_Face)glyph->face;
    error  = TT_Err_Ok;
d1885 3
a1887 1
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
d1889 1
a1889 11
    /* try to load embedded bitmap if any              */
    /*                                                 */
    /* XXX: The convention should be emphasized in     */
    /*      the documents because it can be confusing. */
    if ( size->strike_index != 0xFFFFFFFFUL      &&
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )
    {
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
      if ( !error )
        return TT_Err_Ok;
    }
d1891 1
a1891 1
#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
d1893 1
a1893 3
    /* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) && !size->ttmetrics.valid )
      return TT_Err_Invalid_Size_Handle;
d1895 4
a1898 2
    if ( load_flags & FT_LOAD_SBITS_ONLY )
      return TT_Err_Invalid_Argument;
d1900 1
a1900 3
    error = tt_loader_init( &loader, size, glyph, load_flags );
    if ( error )
      return error;
d1902 1
a1904 1
    glyph->outline.flags = 0;
a1905 1
    /* main loading loop */
d1908 3
a1910 10
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs     = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline        = loader.gloader->base.outline;
        glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;
d1912 2
a1913 5
        /* In case bit 1 of the `flags' field in the `head' table isn't */
        /* set, translate array so that (0,0) is the glyph's origin.    */
        if ( ( face->header.Flags & 2 ) == 0 && loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }
d1915 1
a1915 2
      compute_glyph_metrics( &loader, glyph_index );
    }
d1921 1
a1921 2
    if ( !( load_flags & FT_LOAD_NO_SCALE ) &&
         size->root.metrics.y_ppem < 24     )
d1924 1
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d270 1
a270 5
    prev_cont = FT_NEXT_USHORT( p );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

a641 20

    /* Reset graphics state. */
    loader->exec->GS = ((TT_Size)loader->size)->GS;

    /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
    /*      completely refer to the (already) hinted subglyphs.     */
    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      FT_ARRAY_COPY( zone->orus, zone->cur, zone->n_points );
    }
    else
    {
      loader->exec->metrics.x_scale =
        ((TT_Size)loader->size)->metrics.x_scale;
      loader->exec->metrics.y_scale =
        ((TT_Size)loader->size)->metrics.y_scale;
    }
d705 1
a705 1
    FT_Int          n_points;
d732 1
a732 1
      FT_Int      i;
d1087 1
a1087 4
    /* some fonts have an incorrect value of `maxComponentDepth', */
    /* thus we allow depth 1 to catch the majority of them        */
    if ( recurse_count > 1                                   &&
         recurse_count > face->max_profile.maxComponentDepth )
d1217 1
a1217 17
    if ( loader->byte_len > 0 )
    {
      error = face->access_glyph_frame( loader, glyph_index,
                                        loader->glyf_offset + offset,
                                        loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;

      /* read first glyph header */
      error = face->read_glyph_header( loader );
      if ( error )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
d1219 2
d1263 13
d1284 1
a1284 1
    if ( loader->n_contours > 0 )
d1393 2
a1394 2
        FT_UInt      n, num_base_points;
        FT_SubGlyph  subglyph       = 0;
d1396 3
a1398 3
        FT_UInt      num_points     = start_point;
        FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
        FT_UInt      num_base_subgs = gloader->base.num_subglyphs;
d1400 1
a1400 1
        FT_Stream    old_stream     = loader->stream;
d1402 5
d1416 4
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a27 5
#include "ttpload.h"

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#include "ttgxvar.h"
#endif
d61 64
d138 1
a138 1
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );
d147 20
d188 1
a188 1
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );
d205 1
a205 1
    else
d216 7
d246 15
d343 1
d355 1
a355 6
    /* check that we can add the contours to the glyph */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
    if ( error )
      goto Fail;

    /* reading the contours' endpoints & number of points */
d371 1
a371 2
    /* note that we will add four phantom points later */
    error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
d383 2
a384 2
    load->glyph->control_len  = 0;
    load->glyph->control_data = 0;
d407 3
a409 1
    if ( IS_HINTED( load->load_flags ) )
d411 2
a412 2
      load->glyph->control_len  = n_ins;
      load->glyph->control_data = load->exec->glyphIns;
d414 1
a414 1
      FT_MEM_COPY( load->exec->glyphIns, stream->cursor, (FT_Long)n_ins );
a424 2
    FT_ASSERT( flag != NULL );

a624 1

a632 1

a656 15
  static void
  tt_prepare_zone( TT_GlyphZone  zone,
                   FT_GlyphLoad  load,
                   FT_UInt       start_point,
                   FT_UInt       start_contour )
  {
    zone->n_points   = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours = (FT_Short) ( load->outline.n_contours - start_contour );
    zone->org        = load->extra_points + start_point;
    zone->cur        = load->outline.points + start_point;
    zone->tags       = (FT_Byte*)load->outline.tags + start_point;
    zone->contours   = (FT_UShort*)load->outline.contours + start_contour;
  }


d660 1
a660 1
  /*    TT_Hint_Glyph                                                      */
d663 3
a665 2
  /*    Hint the glyph using the zone prepared by the caller.  Note that   */
  /*    the zone is supposed to include four phantom points.               */
a666 3
#define cur_to_org( n, zone ) \
          FT_ARRAY_COPY( (zone)->org, (zone)->cur, (n) )

d668 2
a669 2
  TT_Hint_Glyph( TT_Loader  loader,
                 FT_Bool    is_composite )
d671 3
a673 3
    TT_GlyphZone  zone = &loader->zone;
    FT_Pos        origin;

d675 1
a675 3
    FT_UInt       n_ins;
#else
    FT_UNUSED( is_composite );
d677 2
d680 1
a681 8
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
    n_ins = loader->glyph->control_len;
#endif

    origin = zone->cur[zone->n_points - 4].x;
    origin = FT_PIX_ROUND( origin ) - origin;
    if ( origin )
      translate_array( zone->n_points, zone->cur, origin, 0 );
d684 1
a684 3
    /* save original point positioin in org */
    if ( n_ins > 0 )
      cur_to_org( zone->n_points, zone );
d687 1
a687 5
    /* round pp2 and pp4 */
    zone->cur[zone->n_points - 3].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 3].x );
    zone->cur[zone->n_points - 1].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 1].y );
d689 4
a692 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
a693 1
    if ( n_ins > 0 )
d695 4
a698 2
      FT_Bool   debug;
      FT_Error  error;
d701 4
a704 7
      error = TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                                loader->exec->glyphIns, n_ins );
      if ( error )
        return error;

      loader->exec->is_composite = is_composite;
      loader->exec->pts          = *zone;
d706 4
a709 2
      debug = !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
              ( (TT_Size)loader->size )->debug;
d711 4
a714 4
      error = TT_Run_Context( loader->exec, debug );
      if ( error && loader->exec->pedantic_hinting )
        return error;
    }
d716 4
a719 1
#endif
d721 4
a724 7
    /* save glyph phantom points */
    if ( !loader->preserve_pps )
    {
      loader->pp1 = zone->cur[zone->n_points - 4];
      loader->pp2 = zone->cur[zone->n_points - 3];
      loader->pp3 = zone->cur[zone->n_points - 2];
      loader->pp4 = zone->cur[zone->n_points - 1];
d727 2
a728 2
    return TT_Err_Ok;
  }
d730 1
d732 2
a733 17
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Simple_Glyph                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Once a simple glyph has been loaded, it needs to be processed.     */
  /*    Usually, this means scaling and hinting through bytecode           */
  /*    interpretation.                                                    */
  /*                                                                       */
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader  loader )
  {
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Error        error   = TT_Err_Ok;
    FT_Outline*     outline;
    FT_UInt         n_points;
d735 7
a742 2
    outline  = &gloader->current.outline;
    n_points = outline->n_points;
d744 7
a750 1
    /* set phantom points */
d752 1
a752 4
    outline->points[n_points    ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;
d754 5
a758 4
    outline->tags[n_points    ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;
a759 1
    n_points += 4;
d761 3
a763 1
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
d765 1
a765 6
    if ( ((TT_Face)loader->face)->doblend )
    {
      /* Deltas apply to the unscaled data. */
      FT_Vector*  deltas;
      FT_Memory   memory = loader->face->memory;
      FT_UInt     i;
d767 2
d770 1
a770 6
      error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                        loader->glyph_index,
                                        &deltas,
                                        n_points );
      if ( error )
        return error;
d772 2
a773 1
      for ( i = 0; i < n_points; ++i )
d775 4
a778 3
        outline->points[i].x += deltas[i].x;
        outline->points[i].y += deltas[i].y;
      }
d780 5
a784 2
      FT_FREE( deltas );
    }
d786 3
a788 1
#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
d790 2
a791 7
    /* scale the glyph */
    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      FT_Vector*  vec     = outline->points;
      FT_Vector*  limit   = outline->points + n_points;
      FT_Fixed    x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      FT_Fixed    y_scale = ((TT_Size)loader->size)->metrics.y_scale;
d793 1
a794 10
      for ( ; vec < limit; vec++ )
      {
        vec->x = FT_MulFix( vec->x, x_scale );
        vec->y = FT_MulFix( vec->y, y_scale );
      }

      loader->pp1 = outline->points[n_points - 4];
      loader->pp2 = outline->points[n_points - 3];
      loader->pp3 = outline->points[n_points - 2];
      loader->pp4 = outline->points[n_points - 1];
d797 2
a798 1
    if ( IS_HINTED( loader->load_flags ) )
d800 4
a803 4
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
d806 3
d816 1
a816 1
  /*    TT_Process_Composite_Component                                     */
d819 2
a820 2
  /*    Once a composite component has been loaded, it needs to be         */
  /*    processed.  Usually, this means transforming and translating.      */
d823 3
a825 4
  TT_Process_Composite_Component( TT_Loader    loader,
                                  FT_SubGlyph  subglyph,
                                  FT_UInt      start_point,
                                  FT_UInt      num_base_points )
a826 5
    FT_GlyphLoader  gloader    = loader->gloader;
    FT_Vector*      base_vec   = gloader->base.outline.points;
    FT_UInt         num_points = gloader->base.outline.n_points;
    FT_Bool         have_scale;
    FT_Pos          x, y;
d828 3
d832 8
a839 3
    have_scale = FT_BOOL( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                              WE_HAVE_AN_XY_SCALE |
                                              WE_HAVE_A_2X2       ) );
d841 5
a845 4
    /* perform the transform required for this subglyph */
    if ( have_scale )
    {
      FT_UInt  i;
d848 4
a851 2
      for ( i = num_base_points; i < num_points; i++ )
        FT_Vector_Transform( base_vec + i, &subglyph->transform );
d854 2
a855 2
    /* get offset */
    if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
d857 3
a859 4
      FT_UInt     k = subglyph->arg1;
      FT_UInt     l = subglyph->arg2;
      FT_Vector*  p1;
      FT_Vector*  p2;
d861 2
d864 7
a870 2
      /* match l-th point of the newly loaded component to the k-th point */
      /* of the previously loaded components.                             */
d872 4
a875 6
      /* change to the point numbers used by our outline */
      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points      )
        return TT_Err_Invalid_Composite;
a876 2
      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;
d878 10
a887 7
      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;
d889 1
a889 2
      if ( !x && !y )
        return TT_Err_Ok;
d891 4
a894 10
  /* Use a default value dependent on                                     */
  /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
  /* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */

      if ( have_scale &&
#ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
           !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) )
#else
            ( subglyph->flags & SCALED_COMPONENT_OFFSET ) )
#endif
d896 1
a897 1
#if 0
d899 11
a909 22
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is what Apple documents.  But it doesn't work.         */
  /*                                                                       */
        int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                            : -subglyph->transform.xx;
        int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                            : -subglyph->transform.yx;
        int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                            : -subglyph->transform.xy;
        int  d = subglyph->transform.yy > 0 ? subglyph->transform.yy
                                            : -subglyph->transform.yy;
        int  m = a > b ? a : b;
        int  n = c > d ? c : d;


        if ( a - b <= 33 && a - b >= -33 )
          m *= 2;
        if ( c - d <= 33 && c - d >= -33 )
          n *= 2;
        x = FT_MulFix( x, m );
        y = FT_MulFix( y, n );
d911 6
a916 1
#else /* 0 */
a917 14
  /*************************************************************************/
  /*                                                                       */
  /* This algorithm is a guess and works much better than the above.       */
  /*                                                                       */
        FT_Fixed  mac_xscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.xx,
                                            subglyph->transform.xx ) +
                                 FT_MulFix( subglyph->transform.xy,
                                            subglyph->transform.xy ) );
        FT_Fixed  mac_yscale = FT_SqrtFixed(
                                 FT_MulFix( subglyph->transform.yy,
                                            subglyph->transform.yy ) +
                                 FT_MulFix( subglyph->transform.yx,
                                            subglyph->transform.yx ) );
d919 12
d932 1
a932 2
        x = FT_MulFix( x, mac_xscale );
        y = FT_MulFix( y, mac_yscale );
d934 2
a935 244
#endif /* 0 */

      }

      if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
      {
        FT_Fixed  x_scale = ((TT_Size)loader->size)->metrics.x_scale;
        FT_Fixed  y_scale = ((TT_Size)loader->size)->metrics.y_scale;


        x = FT_MulFix( x, x_scale );
        y = FT_MulFix( y, y_scale );

        if ( subglyph->flags & ROUND_XY_TO_GRID )
        {
          x = FT_PIX_ROUND( x );
          y = FT_PIX_ROUND( y );
        }
      }
    }

    if ( x || y )
      translate_array( num_points - num_base_points,
                       base_vec + num_base_points,
                       x, y );

    return TT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Process_Composite_Glyph                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is slightly different from TT_Process_Simple_Glyph, in that   */
  /*    it's sole purpose is to hint the glyph.  Thus this function is     */
  /*    only available when bytecode interpreter is enabled.               */
  /*                                                                       */
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader  loader,
                              FT_UInt    start_point,
                              FT_UInt    start_contour )
  {
    FT_Error     error;
    FT_Outline*  outline;


    outline = &loader->gloader->base.outline;

    /* make room for phantom points */
    error = FT_GLYPHLOADER_CHECK_POINTS( loader->gloader,
                                         outline->n_points + 4,
                                         0 );
    if ( error )
      return error;

    outline->points[outline->n_points    ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points    ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    {
      FT_Stream  stream = loader->stream;
      FT_UShort  n_ins;


      /* TT_Load_Composite_Glyph only gives us the offset of instructions */
      /* so we read them here                                             */
      if ( FT_STREAM_SEEK( loader->ins_pos ) ||
           FT_READ_USHORT( n_ins )           )
        return error;

      FT_TRACE5(( "  Instructions size = %d\n", n_ins ));

      /* check it */
      if ( n_ins > ((TT_Face)loader->face)->max_profile.maxSizeOfInstructions )
      {
        FT_TRACE0(( "Too many instructions (%d)\n", n_ins ));

        return TT_Err_Too_Many_Hints;
      }
      else if ( n_ins == 0 )
        return TT_Err_Ok;

      if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len  = n_ins;
    }

#endif

    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );
    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }


  /* Calculate the four phantom points.                     */
  /* The first two stand for horizontal origin and advance. */
  /* The last two stand for vertical origin and advance.    */
#define TT_LOADER_SET_PP( loader )                                          \
          do {                                                              \
            (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \
            (loader)->pp1.y = 0;                                            \
            (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \
            (loader)->pp2.y = 0;                                            \
            (loader)->pp3.x = 0;                                            \
            (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax;  \
            (loader)->pp4.x = 0;                                            \
            (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \
          } while ( 0 )


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    load_truetype_glyph                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads a given truetype glyph.  Handles composites and uses a       */
  /*    TT_Loader object.                                                  */
  /*                                                                       */
  static FT_Error
  load_truetype_glyph( TT_Loader  loader,
                       FT_UInt    glyph_index,
                       FT_UInt    recurse_count )
  {
    FT_Error        error;
    FT_Fixed        x_scale, y_scale;
    FT_ULong        offset;
    TT_Face         face         = (TT_Face)loader->face;
    FT_GlyphLoader  gloader      = loader->gloader;
    FT_Bool         opened_frame = 0;

#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
    FT_Vector*      deltas       = NULL;
#endif

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    FT_StreamRec    inc_stream;
    FT_Data         glyph_data;
    FT_Bool         glyph_data_loaded = 0;
#endif


    if ( recurse_count > face->max_profile.maxComponentDepth )
    {
      error = TT_Err_Invalid_Composite;
      goto Exit;
    }

    /* check glyph index */
    if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
    {
      error = TT_Err_Invalid_Glyph_Index;
      goto Exit;
    }

    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
    {
      x_scale = ((TT_Size)loader->size)->metrics.x_scale;
      y_scale = ((TT_Size)loader->size)->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }

    /* get metrics, horizontal and vertical */
    {
      FT_Short   left_bearing = 0, top_bearing = 0;
      FT_UShort  advance_width = 0, advance_height = 0;


      Get_HMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &left_bearing,
                    &advance_width );
      Get_VMetrics( face, glyph_index,
                    (FT_Bool)!( loader->load_flags &
                                FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                    &top_bearing,
                    &advance_height );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

      /* If this is an incrementally loaded font see if there are */
      /* overriding metrics for this glyph.                       */
      if ( face->root.internal->incremental_interface &&
           face->root.internal->incremental_interface->funcs->get_glyph_metrics )
      {
        FT_Incremental_MetricsRec  metrics;


        metrics.bearing_x = left_bearing;
        metrics.bearing_y = 0;
        metrics.advance = advance_width;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, FALSE, &metrics );
        if ( error )
          goto Exit;
        left_bearing  = (FT_Short)metrics.bearing_x;
        advance_width = (FT_UShort)metrics.advance;

#if 0

        /* GWW: Do I do the same for vertical metrics? */
        metrics.bearing_x = 0;
        metrics.bearing_y = top_bearing;
        metrics.advance = advance_height;
        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                  face->root.internal->incremental_interface->object,
                  glyph_index, TRUE, &metrics );
        if ( error )
          goto Exit;
        top_bearing  = (FT_Short)metrics.bearing_y;
        advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

      }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
a945 4
    /* Set `offset' to the start of the glyph relative to the start of */
    /* the `glyf' table, and `byte_len' to the length of the glyph in  */
    /* bytes.                                                          */

d948 4
d955 1
d966 1
a966 1
      loader->byte_len  = glyph_data.length;
d978 7
a984 2
      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );
d986 1
a986 1
    if ( loader->byte_len == 0 )
d988 2
a989 2
      /* as described by Frederic Loyer, these are spaces or */
      /* the unknown glyph.                                  */
d995 4
a998 1
      TT_LOADER_SET_PP( loader );
d1000 1
a1000 3
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( ((TT_Face)(loader->face))->doblend )
d1002 3
a1004 2
        /* this must be done before scaling */
        FT_Memory  memory = loader->face->memory;
d1006 1
d1008 2
a1009 12
        error = TT_Vary_Get_Glyph_Deltas( (TT_Face)(loader->face),
                                          glyph_index, &deltas, 4 );
        if ( error )
          goto Exit;

        loader->pp1.x += deltas[0].x; loader->pp1.y += deltas[0].y;
        loader->pp2.x += deltas[1].x; loader->pp2.y += deltas[1].y;
        loader->pp3.x += deltas[2].x; loader->pp3.y += deltas[2].y;
        loader->pp4.x += deltas[3].x; loader->pp4.y += deltas[3].y;

        FT_FREE( deltas );
      }
a1012 8
      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

d1017 6
a1022 3
    error = face->access_glyph_frame( loader, glyph_index,
                                      loader->glyf_offset + offset,
                                      loader->byte_len );
d1031 15
a1045 1
      goto Exit;
d1047 7
a1053 1
    TT_LOADER_SET_PP( loader );
d1061 1
a1061 1
    if ( loader->n_contours >= 0 )
d1063 5
d1070 15
a1084 1
        goto Exit;
d1086 1
a1086 3
      /* all data have been read */
      face->forget_glyph_frame( loader );
      opened_frame = 0;
a1087 1
      error = TT_Process_Simple_Glyph( loader );
d1089 1
a1089 1
        goto Exit;
d1092 3
d1102 1
a1102 1
    else if ( loader->n_contours == -1 )
d1104 1
d1106 1
d1109 1
d1112 1
d1114 1
d1116 1
a1117 1
      /* for each subglyph, read composite header */
d1120 1
a1120 1
        goto Exit;
d1122 1
a1122 1
      /* store the offset of instructions */
d1124 1
a1124 2

      /* all data we need are read */
a1127 49
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT

      if ( face->doblend )
      {
        FT_Int       i, limit;
        FT_SubGlyph  subglyph;
        FT_Memory    memory = face->root.memory;


        /* this provides additional offsets */
        /* for each component's translation */

        if ( (error = TT_Vary_Get_Glyph_Deltas(
                        face,
                        glyph_index,
                        &deltas,
                        gloader->current.num_subglyphs + 4 )) != 0 )
          goto Exit;

        subglyph = gloader->current.subglyphs + gloader->base.num_subglyphs;
        limit    = gloader->current.num_subglyphs;

        for ( i = 0; i < limit; ++i, ++subglyph )
        {
          if ( subglyph->flags & ARGS_ARE_XY_VALUES )
          {
            subglyph->arg1 += deltas[i].x;
            subglyph->arg2 += deltas[i].y;
          }
        }

        loader->pp1.x += deltas[i + 0].x; loader->pp1.y += deltas[i + 0].y;
        loader->pp2.x += deltas[i + 1].x; loader->pp2.y += deltas[i + 1].y;
        loader->pp3.x += deltas[i + 2].x; loader->pp3.y += deltas[i + 2].y;
        loader->pp4.x += deltas[i + 3].x; loader->pp4.y += deltas[i + 3].y;

        FT_FREE( deltas );
      }

#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */

      if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
      {
        loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
        loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
        loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
        loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
      }

d1134 1
d1136 4
a1139 1
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;
d1148 1
d1150 1
a1150 1
        FT_UInt      n, num_base_points;
a1152 1
        FT_UInt      num_points     = start_point;
d1159 1
a1159 2
        /* read each subglyph independently */
        for ( n = 0; n < num_subglyphs; n++ )
d1161 2
a1162 1
          FT_Vector  pp[4];
d1171 174
a1344 4
          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;
d1346 2
a1347 1
          num_base_points = gloader->base.outline.n_points;
d1349 1
a1349 4
          error = load_truetype_glyph( loader, subglyph->index,
                                       recurse_count + 1 );
          if ( error )
            goto Exit;
d1351 20
a1370 2
          /* restore subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + n;
d1372 2
a1373 1
          if ( !( subglyph->flags & USE_MY_METRICS ) )
d1375 4
a1378 4
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];
d1381 37
a1417 1
          num_points = gloader->base.outline.n_points;
d1419 8
a1426 2
          if ( num_points == num_base_points )
            continue;
d1428 2
a1429 9
          /* gloader->base.outline consists of three part:                  */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points.   */
          /*                                                                */
          /* (1): exist from the beginning                                  */
          /* (2): components that have been loaded so far                   */
          /* (3): the newly loaded component                                */
          TT_Process_Composite_Component( loader, subglyph, start_point,
                                          num_base_points );
        }
d1432 3
a1434 3
        /* process the glyph */
        loader->ins_pos = ins_pos;
        if ( IS_HINTED( loader->load_flags ) &&
d1436 1
a1436 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d1438 10
a1447 1
             subglyph->flags & WE_HAVE_INSTR &&
d1449 6
a1454 1
#endif
d1456 1
a1456 2
             num_points > start_point )
          TT_Process_Composite_Glyph( loader, start_point, start_contour );
d1459 1
d1465 1
a1465 1
      goto Exit;
d1472 1
a1472 2
  Exit:

d1476 2
a1478 1

a1482 1

d1505 10
d1516 10
d1553 4
d1562 2
a1563 2
      FT_Pos  top;      /* scaled vertical top side bearing  */
      FT_Pos  advance;  /* scaled vertical advance height    */
d1565 3
d1573 2
a1574 2
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );
a1575 5
        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
d1579 1
a1579 5
        FT_Pos  height;


        /* XXX Compute top side bearing and advance height in  */
        /*     Get_VMetrics instead of here.                   */
d1585 12
a1596 3

        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
d1598 6
a1603 2
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
d1605 6
a1610 4
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
d1614 5
d1620 2
a1621 3
        FT_Incremental_InterfaceRec*  incr;
        FT_Incremental_MetricsRec     metrics;
        FT_Error                      error;
d1624 7
a1630 1
        incr = face->root.internal->incremental_interface;
d1632 2
a1633 14
        /* If this is an incrementally loaded font see if there are */
        /* overriding metrics for this glyph.                       */
        if ( incr && incr->funcs->get_glyph_metrics )
        {
          metrics.bearing_x = 0;
          metrics.bearing_y = top;
          metrics.advance   = advance;

          error = incr->funcs->get_glyph_metrics( incr->object,
                                                  glyph_index,
                                                  TRUE,
                                                  &metrics );
          if ( error )
            return error;
d1635 2
a1636 3
          top     = metrics.bearing_y;
          advance = metrics.advance;
        }
d1643 3
a1645 1
      glyph->linearVertAdvance = advance;
d1650 8
a1657 2
        top     = FT_MulFix( top, y_scale );
        advance = FT_MulFix( advance, y_scale );
d1660 4
d1667 11
a1677 1
      glyph->metrics.vertBearingX = ( bbox.xMin - bbox.xMax ) / 2;
d1683 1
a1683 1
    if ( !face->postscript.isFixedPitch &&
d1686 2
a1687 1
      FT_Byte*  widthp;
d1690 2
a1691 6
      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
a1701 153
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  static FT_Error
  load_sbit_image( TT_Size       size,
                   TT_GlyphSlot  glyph,
                   FT_UInt       glyph_index,
                   FT_Int32      load_flags )
  {
    TT_Face             face;
    SFNT_Service        sfnt;
    FT_Stream           stream;
    FT_Error            error;
    TT_SBit_MetricsRec  metrics;


    face   = (TT_Face)glyph->face;
    sfnt   = (SFNT_Service)face->sfnt;
    stream = face->root.stream;

    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_Int)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
    {
      glyph->outline.n_points   = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width  = (FT_Pos)metrics.width  << 6;
      glyph->metrics.height = (FT_Pos)metrics.height << 6;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;
      if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top  = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top  = metrics.horiBearingY;
      }
    }

    return error;
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  static FT_Error
  tt_loader_init( TT_Loader     loader,
                  TT_Size       size,
                  TT_GlyphSlot  glyph,
                  FT_Int32      load_flags )
  {
    TT_Face    face;
    FT_Stream  stream;


    face   = (TT_Face)glyph->face;
    stream = face->root.stream;

    FT_MEM_ZERO( loader, sizeof ( TT_LoaderRec ) );

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

    /* load execution context */
    {
      TT_ExecContext  exec;


      /* query new execution context */
      exec = size->debug ? size->context
                         : ( (TT_Driver)FT_FACE_DRIVER( face ) )->context;
      if ( !exec )
        return TT_Err_Could_Not_Find_Context;

      TT_Load_Context( exec, face, size );

      /* see if the cvt program has disabled hinting */
      if ( exec->GS.instruct_control & 1 )
        load_flags |= FT_LOAD_NO_HINTING;

      /* load default graphics state - if needed */
      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;

      exec->pedantic_hinting = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
      exec->grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_LOAD_TARGET_MONO );

      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }

#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */

    /* seek to the beginning of the glyph table.  For Type 42 fonts      */
    /* the table might be accessed from a Postscript stream or something */
    /* else...                                                           */

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    if ( face->root.internal->incremental_interface )
      loader->glyf_offset = 0;
    else

#endif

    {
      FT_Error  error = face->goto_table( face, TTAG_glyf, stream, 0 );


      if ( error )
      {
        FT_ERROR(( "TT_Load_Glyph: could not access glyph table\n" ));
        return error;
      }
      loader->glyf_offset = FT_STREAM_POS();
    }

    /* get face's glyph loader */
    {
      FT_GlyphLoader  gloader = glyph->internal->loader;


      FT_GlyphLoader_Rewind( gloader );
      loader->gloader = gloader;
    }

    loader->load_flags    = load_flags;

    loader->face   = (FT_Face)face;
    loader->size   = (FT_Size)size;
    loader->glyph  = (FT_GlyphSlot)glyph;
    loader->stream = stream;

    return TT_Err_Ok;
  }


d1735 1
d1743 1
d1745 12
a1756 1
    error  = TT_Err_Ok;
d1764 3
a1766 1
    if ( size->strike_index != 0xFFFFFFFFUL      &&
d1768 1
d1770 10
a1779 1
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
d1781 28
a1808 1
        return TT_Err_Ok;
d1813 1
a1813 4
    /* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
    if ( !( load_flags & FT_LOAD_NO_SCALE ) && !size->ttmetrics.valid )
      return TT_Err_Invalid_Size_Handle;

d1817 84
a1900 3
    error = tt_loader_init( &loader, size, glyph, load_flags );
    if ( error )
      return error;
d1902 1
a1904 1
    glyph->outline.flags = 0;
a1905 1
    /* Main loading loop */
d1908 3
a1910 10
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs     = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline        = loader.gloader->base.outline;
        glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;
d1912 2
a1913 5
        /* In case bit 1 of the `flags' field in the `head' table isn't */
        /* set, translate array so that (0,0) is the glyph's origin.    */
        if ( ( face->header.Flags & 2 ) == 0 && loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }
d1915 1
a1915 2
      compute_glyph_metrics( &loader, glyph_index );
    }
d1921 1
a1921 2
    if ( !( load_flags & FT_LOAD_NO_SCALE ) &&
         size->root.metrics.y_ppem < 24     )
d1924 1
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d72 6
a77 6
  FT_LOCAL_DEF( void )
  TT_Get_HMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Bool     check,
                   FT_Short*   lsb,
                   FT_UShort*  aw )
a82 3

    FT_TRACE5(( "  advance width (font units): %d\n", *aw ));
    FT_TRACE5(( "  left side bearing (font units): %d\n", *lsb ));
d99 6
a104 6
  FT_LOCAL_DEF( void )
  TT_Get_VMetrics( TT_Face     face,
                   FT_UInt     idx,
                   FT_Bool     check,
                   FT_Short*   tsb,
                   FT_UShort*  ah )
d111 1
a111 1
#if 1             /* Empirically determined, at variance with what MS said */
a133 85
    FT_TRACE5(( "  advance height (font units): %d\n", *ah ));
    FT_TRACE5(( "  top side bearing (font units): %d\n", *tsb ));
  }


  static void
  tt_get_metrics( TT_Loader  loader,
                  FT_UInt    glyph_index )
  {
    TT_Face  face = (TT_Face)loader->face;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;


    TT_Get_HMetrics( face, glyph_index,
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                     &left_bearing,
                     &advance_width );
    TT_Get_VMetrics( face, glyph_index,
                     (FT_Bool)!( loader->load_flags &
                                 FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ),
                     &top_bearing,
                     &advance_height );

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    /* If this is an incrementally loaded font check whether there are */
    /* overriding metrics for this glyph.                              */
    if ( face->root.internal->incremental_interface                           &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec  metrics;
      FT_Error                   error;


      metrics.bearing_x = left_bearing;
      metrics.bearing_y = 0;
      metrics.advance   = advance_width;
      metrics.advance_v = 0;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, FALSE, &metrics );
      if ( error )
        goto Exit;

      left_bearing  = (FT_Short)metrics.bearing_x;
      advance_width = (FT_UShort)metrics.advance;

#if 0

      /* GWW: Do I do the same for vertical metrics? */
      metrics.bearing_x = 0;
      metrics.bearing_y = top_bearing;
      metrics.advance   = advance_height;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, TRUE, &metrics );
      if ( error )
        goto Exit;

      top_bearing    = (FT_Short)metrics.bearing_y;
      advance_height = (FT_UShort)metrics.advance;

#endif /* 0 */

    }

  Exit:

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }
a190 3
    loader->cursor = stream->cursor;
    loader->limit  = stream->limit;

d208 2
a209 2
    FT_Byte*  p     = loader->cursor;
    FT_Byte*  limit = loader->limit;
d212 1
a212 1
    if ( p + 10 > limit )
d215 1
a215 1
    loader->n_contours = FT_NEXT_SHORT( p );
d217 4
a220 4
    loader->bbox.xMin = FT_NEXT_SHORT( p );
    loader->bbox.yMin = FT_NEXT_SHORT( p );
    loader->bbox.xMax = FT_NEXT_SHORT( p );
    loader->bbox.yMax = FT_NEXT_SHORT( p );
d227 1
a227 1
    loader->cursor = p;
d237 1
a237 2
    FT_Byte*        p          = load->cursor;
    FT_Byte*        limit      = load->limit;
d243 2
a244 1
    FT_Int          n_points;
d250 1
a250 2
    FT_Short        *cont, *cont_limit, prev_cont;
    FT_Int          xy_size = 0;
d263 2
a264 1
    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
d267 2
a268 16
    prev_cont = FT_NEXT_USHORT( p );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = FT_NEXT_USHORT( p );
      if ( cont[0] <= prev_cont )
      {
        /* unordered contours: this is invalid */
        error = FT_Err_Invalid_Table;
        goto Fail;
      }
      prev_cont = cont[0];
    }
a271 1
    {
a272 3
      if ( n_points < 0 )
        goto Invalid_Outline;
    }
d290 1
a290 4
    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = FT_NEXT_USHORT( p );
d296 1
a296 2
      FT_TRACE0(( "TT_Load_Simple_Glyph: too many instructions (%d)\n",
                  n_ins ));
d301 2
a302 1
    if ( ( limit - p ) < n_ins )
d304 1
a304 1
      FT_TRACE0(( "TT_Load_Simple_Glyph: instruction count mismatch\n" ));
d309 1
a309 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d316 1
a316 1
      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
d319 1
a319 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d321 1
a321 1
    p += n_ins;
d331 1
a331 1
      if ( p + 1 > limit )
d334 1
a334 1
      *flag++ = c = FT_NEXT_BYTE( p );
d337 1
a337 1
        if ( p + 1 > limit )
d340 1
a340 1
        count = FT_NEXT_BYTE( p );
d349 17
a372 3
    if ( p + xy_size > limit )
      goto Invalid_Outline;

d375 1
a375 2
      FT_Pos   y = 0;
      FT_Byte  f = *flag;
d378 1
a378 1
      if ( f & 2 )
d380 2
a381 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 16 ) == 0 )
d384 2
a385 7
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a388 2
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & ~( 2 | 16 ) );
d400 1
a400 2
      FT_Pos   y = 0;
      FT_Byte  f = *flag;
d403 1
a403 1
      if ( f & 4 )
d405 2
a406 5
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_BYTE( p );
        if ( ( f & 32 ) == 0 )
d409 2
a410 7
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)FT_NEXT_SHORT( p );
      }
a413 2
      /* the cast is for stupid compilers */
      *flag  = (FT_Byte)( f & FT_CURVE_TAG_ON );
d416 4
d423 1
a423 1
    load->cursor = p;
d438 1
a438 2
    FT_Byte*        p       = loader->cursor;
    FT_Byte*        limit   = loader->limit;
d442 1
a449 1
      FT_UInt   count;
d458 2
a459 1
      if ( p + 4 > limit )
d466 2
a467 2
      subglyph->flags = FT_NEXT_USHORT( p );
      subglyph->index = FT_NEXT_USHORT( p );
d470 1
a470 1
      count = 2;
d472 1
a472 1
        count += 2;
d474 1
a474 1
        count += 2;
d476 1
a476 1
        count += 4;
d478 1
a478 1
        count += 8;
d480 1
a480 1
      if ( p + count > limit )
d486 2
a487 2
        subglyph->arg1 = FT_NEXT_SHORT( p );
        subglyph->arg2 = FT_NEXT_SHORT( p );
d491 2
a492 2
        subglyph->arg1 = FT_NEXT_CHAR( p );
        subglyph->arg2 = FT_NEXT_CHAR( p );
d501 1
a501 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d506 2
a507 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d511 4
a514 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) << 2;
d528 1
a528 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d531 4
a534 7
      FT_Stream  stream = loader->stream;


      /* we must undo the FT_FRAME_ENTER in order to point */
      /* to the composite instructions, if we find some.   */
      /* We will process them later.                       */
      /*                                                   */
d536 1
a536 1
                                    p - limit );
d541 1
a541 1
    loader->cursor = p;
d569 6
a574 9
    zone->n_points    = (FT_UShort)( load->outline.n_points - start_point );
    zone->n_contours  = (FT_Short) ( load->outline.n_contours -
                                       start_contour );
    zone->org         = load->extra_points + start_point;
    zone->cur         = load->outline.points + start_point;
    zone->orus        = load->extra_points2 + start_point;
    zone->tags        = (FT_Byte*)load->outline.tags + start_point;
    zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
d587 3
d597 1
a597 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d604 2
a605 8
#ifdef TT_USE_BYTECODE_INTERPRETER
    if ( loader->glyph->control_len > 0xFFFFL )
    {
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions " ));
      FT_TRACE1(( "(0x%lx byte) is truncated\n",
                 loader->glyph->control_len ));
    }
    n_ins = (FT_UInt)( loader->glyph->control_len );
d613 2
a614 2
#ifdef TT_USE_BYTECODE_INTERPRETER
    /* save original point position in org */
d616 1
a616 21
      FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );

    /* Reset graphics state. */
    loader->exec->GS = ((TT_Size)loader->size)->GS;

    /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
    /*      completely refer to the (already) hinted subglyphs.     */
    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      FT_ARRAY_COPY( zone->orus, zone->cur, zone->n_points );
    }
    else
    {
      loader->exec->metrics.x_scale =
        ((TT_Size)loader->size)->metrics.x_scale;
      loader->exec->metrics.y_scale =
        ((TT_Size)loader->size)->metrics.y_scale;
    }
d625 1
a625 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a631 3
      FT_GlyphLoader  gloader         = loader->gloader;
      FT_Outline      current_outline = gloader->current.outline;

d641 2
a642 2
      debug = FT_BOOL( !( loader->load_flags & FT_LOAD_NO_SCALE ) &&
                       ((TT_Size)loader->size)->debug             );
a646 4

      /* store drop-out mode in bits 5-7; set bit 2 also as a marker */
      current_outline.tags[0] |=
        ( loader->exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;
d680 1
a680 1
    FT_Int          n_points;
d707 1
a707 1
      FT_Int      i;
a727 8
    if ( IS_HINTED( loader->load_flags ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
                     loader->zone.n_points + 4 );
    }

d751 1
d874 4
a877 4
                                 (FT_Int32)FT_MulFix( subglyph->transform.xx,
                                                      subglyph->transform.xx ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.xy,
                                                      subglyph->transform.xy ) );
d879 4
a882 4
                                 (FT_Int32)FT_MulFix( subglyph->transform.yy,
                                                      subglyph->transform.yy ) +
                                 (FT_Int32)FT_MulFix( subglyph->transform.yx,
                                                      subglyph->transform.yx ) );
d925 1
a925 1
  /*    its sole purpose is to hint the glyph.  Thus this function is      */
a934 1
    FT_UInt      i;
d956 1
a956 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d974 1
a974 2
        FT_TRACE0(( "TT_Process_Composite_Glyph: too many instructions (%d)\n",
                    n_ins ));
a991 6

    /* Some points are likely touched during execution of  */
    /* instructions on components.  So let's untouch them. */
    for ( i = start_point; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~FT_CURVE_TAG_TOUCH_BOTH;

d1026 1
a1026 2
                       FT_UInt    recurse_count,
                       FT_Bool    header_only )
d1028 1
a1028 1
    FT_Error        error        = TT_Err_Ok;
d1046 1
a1046 4
    /* some fonts have an incorrect value of `maxComponentDepth', */
    /* thus we allow depth 1 to catch the majority of them        */
    if ( recurse_count > 1                                   &&
         recurse_count > face->max_profile.maxComponentDepth )
d1072 69
a1140 1
    tt_get_metrics( loader, glyph_index );
d1176 1
a1176 30
    if ( loader->byte_len > 0 )
    {
#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* for the incremental interface, `glyf_offset' is always zero */
      if ( !loader->glyf_offset                        &&
           !face->root.internal->incremental_interface )
#else
      if ( !loader->glyf_offset )
#endif /* FT_CONFIG_OPTION_INCREMENTAL */
      {
        FT_TRACE2(( "no `glyf' table but non-zero `loca' entry\n" ));
        error = TT_Err_Invalid_Table;
        goto Exit;
      }

      error = face->access_glyph_frame( loader, glyph_index,
                                        loader->glyf_offset + offset,
                                        loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;

      /* read glyph header first */
      error = face->read_glyph_header( loader );
      if ( error || header_only )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
d1178 2
a1184 3
      if ( header_only )
        goto Exit;

d1222 13
d1243 1
a1243 1
    if ( loader->n_contours > 0 )
d1267 3
a1269 3
      FT_UInt   start_point;
      FT_UInt   start_contour;
      FT_ULong  ins_pos;  /* position of composite instructions, if any */
d1299 5
a1303 5
        if ( ( error = TT_Vary_Get_Glyph_Deltas(
                         face,
                         glyph_index,
                         &deltas,
                         gloader->current.num_subglyphs + 4 )) != 0 )
d1313 2
a1314 5
            /* XXX: overflow check for subglyph->{arg1,arg2}.   */
            /* deltas[i].{x,y} must be within signed 16-bit,    */
            /* but the restriction of summed delta is not clear */
            subglyph->arg1 += (FT_Int16)deltas[i].x;
            subglyph->arg2 += (FT_Int16)deltas[i].y;
d1339 1
a1359 2
        FT_Stream    old_stream     = loader->stream;

d1383 1
a1383 1
                                       recurse_count + 1, FALSE );
d1403 6
a1408 6
          /* gloader->base.outline consists of three parts:               */
          /* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
          /*                                                              */
          /* (1): exists from the beginning                               */
          /* (2): components that have been loaded so far                 */
          /* (3): the newly loaded component                              */
a1412 1
        loader->stream = old_stream;
d1418 1
a1418 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d1431 1
a1431 1
      /* invalid composite count (negative but not -1) */
d1459 2
a1460 2
  compute_glyph_metrics( TT_Loader  loader,
                         FT_UInt    glyph_index )
d1478 2
a1479 2
    /* get the device-independent horizontal advance; it is scaled later */
    /* by the base layer.                                                */
d1502 3
a1504 6
    /* adjust advance width to the value contained in the hdmx table */
    if ( !face->postscript.isFixedPitch  &&
         IS_HINTED( loader->load_flags ) )
    {
      FT_Byte*  widthp;

a1505 15
      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );

      if ( widthp )
        glyph->metrics.horiAdvance = *widthp << 6;
    }

    /* set glyph dimensions */
    glyph->metrics.width  = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;

    /* Now take care of vertical metrics.  In the case where there is */
    /* no vertical information within the font (relatively common),   */
    /* create some metrics manually                                   */
d1512 1
a1512 1
      if ( face->vertical_info                   &&
d1587 1
a1587 1
        top     = FT_MulFix( top,     y_scale );
d1594 1
a1594 2
      glyph->metrics.vertBearingX = glyph->metrics.horiBearingX -
                                      glyph->metrics.horiAdvance / 2;
d1599 19
a1664 1

d1687 1
a1687 2
                  FT_Int32      load_flags,
                  FT_Bool       glyf_table_only )
d1698 1
a1698 1
#ifdef TT_USE_BYTECODE_INTERPRETER
a1700 1
    if ( IS_HINTED( load_flags ) && !glyf_table_only )
a1702 1
      FT_Bool         grayscale;
a1704 7
      if ( !size->cvt_ready )
      {
        FT_Error  error = tt_size_ready_bytecode( size );
        if ( error )
          return error;
      }

a1710 3
      grayscale =
        FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) != FT_RENDER_MODE_MONO );

d1713 1
a1713 15
      /* a change from mono to grayscale rendering (and vice versa) */
      /* requires a re-execution of the CVT program                 */
      if ( grayscale != exec->grayscale )
      {
        FT_UInt  i;


        exec->grayscale = grayscale;

        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
        tt_size_run_prep( size );
      }

      /* see whether the cvt program has disabled hinting */
d1717 1
a1717 1
      /* load default graphics state -- if needed */
d1722 3
d1729 1
a1729 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d1731 1
a1731 1
    /* seek to the beginning of the glyph table -- for Type 42 fonts     */
d1747 1
a1747 3
      if ( error == TT_Err_Table_Missing )
        loader->glyf_offset = 0;
      else if ( error )
d1749 1
a1749 1
        FT_ERROR(( "tt_loader_init: could not access glyph table\n" ));
d1752 1
a1752 2
      else
        loader->glyf_offset = FT_STREAM_POS();
a1755 1
    if ( !glyf_table_only )
d1764 1
a1764 1
    loader->load_flags = load_flags;
d1809 1
d1815 1
a1828 17
      {
        FT_Face  root = &face->root;


        if ( FT_IS_SCALABLE( root ) )
        {
          /* for the bbox we need the header only */
          (void)tt_loader_init( &loader, size, glyph, load_flags, TRUE );
          (void)load_truetype_glyph( &loader, glyph_index, 0, TRUE );
          glyph->linearHoriAdvance = loader.linear;
          glyph->linearVertAdvance = loader.top_bearing + loader.bbox.yMax -
                                       loader.vadvance;
          if ( face->postscript.isFixedPitch                             &&
               ( load_flags & FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) == 0 )
            glyph->linearHoriAdvance = face->horizontal.advance_Width_Max;
        }

a1829 1
      }
d1841 1
a1841 1
    error = tt_loader_init( &loader, size, glyph, load_flags, FALSE );
d1849 2
a1850 2
    /* main loading loop */
    error = load_truetype_glyph( &loader, glyph_index, 0, FALSE );
a1868 34
#ifdef TT_USE_BYTECODE_INTERPRETER

      if ( IS_HINTED( load_flags ) )
      {
        if ( loader.exec->GS.scan_control )
        {
          /* convert scan conversion mode to FT_OUTLINE_XXX flags */
          switch ( loader.exec->GS.scan_type )
          {
          case 0: /* simple drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 1: /* simple drop-outs excluding stubs */
            /* nothing; it's the default rendering mode */
            break;
          case 4: /* smart drop-outs including stubs */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS |
                                    FT_OUTLINE_INCLUDE_STUBS;
            break;
          case 5: /* smart drop-outs excluding stubs  */
            glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS;
            break;

          default: /* no drop-out control */
            glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
            break;
          }
        }
        else
          glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
      }

#endif /* TT_USE_BYTECODE_INTERPRETER */

@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 2
a8 1
/*  Copyright 1996-2016 by                                                 */
a26 2
#include FT_TRUETYPE_DRIVER_H
#include FT_LIST_H
a35 1
#include "ttsubpix.h"
d50 1
a50 1
  /* Composite glyph flags.                                                */
d69 3
a71 1
  /* Return the horizontal metrics in font units for a given glyph.        */
d76 1
d82 3
d92 10
a101 2
  /* Return the vertical metrics in font units for a given glyph.          */
  /* See macro `TT_LOADER_SET_PP' below for explanations.                  */
d106 1
a106 1
                   FT_Pos      yMax,
d110 2
d115 10
d127 2
a128 3
      *tsb = (FT_Short)( face->os2.sTypoAscender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->os2.sTypoAscender -
                                face->os2.sTypoDescender );
a129 1

d132 2
a133 3
      *tsb = (FT_Short)( face->horizontal.Ascender - yMax );
      *ah  = (FT_UShort)FT_ABS( face->horizontal.Ascender -
                                face->horizontal.Descender );
d136 2
d143 1
a143 1
  static FT_Error
d147 1
a147 7
    TT_Face    face   = loader->face;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

    FT_Error   error;
    FT_Stream  stream = loader->stream;
a151 4
    /* we must preserve the stream position          */
    /* (which gets altered by the metrics functions) */
    FT_ULong  pos = FT_STREAM_POS();

d154 2
d159 2
a160 1
                     loader->bbox.yMax,
a163 32
    if ( FT_STREAM_SEEK( pos ) )
      return error;

    loader->left_bearing = left_bearing;
    loader->advance      = advance_width;
    loader->top_bearing  = top_bearing;
    loader->vadvance     = advance_height;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
         loader->exec                                             )
    {
      loader->exec->sph_tweak_flags = 0;

      /* This may not be the right place for this, but it works...  */
      /* Note that we have to unconditionally load the tweaks since */
      /* it is possible that glyphs individually switch ClearType's */
      /* backwards compatibility mode on and off.                   */
      sph_set_tweaks( loader, glyph_index );
    }
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear     = advance_width;
    }

    return FT_Err_Ok;
  }


a165 10
  static void
  tt_get_metrics_incr_overrides( TT_Loader  loader,
                                 FT_UInt    glyph_index )
  {
    TT_Face  face = loader->face;

    FT_Short   left_bearing = 0, top_bearing = 0;
    FT_UShort  advance_width = 0, advance_height = 0;


d175 1
a175 1
      metrics.bearing_x = loader->left_bearing;
d177 1
a177 1
      metrics.advance   = loader->advance;
d193 2
a194 2
      metrics.bearing_y = loader->top_bearing;
      metrics.advance   = loader->vadvance;
d207 10
a216 4
      loader->left_bearing = left_bearing;
      loader->advance      = advance_width;
      loader->top_bearing  = top_bearing;
      loader->vadvance     = advance_height;
d218 4
a221 5
      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear     = advance_width;
      }
d223 15
d239 7
a245 2
  Exit:
    return;
d248 3
a250 1
#endif /* FT_CONFIG_OPTION_INCREMENTAL */
d274 1
a274 1
    FT_TRACE4(( "Glyph %ld\n", glyph_index ));
d283 1
a283 1
    return FT_Err_Ok;
d305 1
a305 1
      return FT_THROW( Invalid_Outline );
d321 1
a321 1
    return FT_Err_Ok;
d334 1
a336 1
    FT_ULong        tmp;
d359 1
a359 1
    prev_cont = FT_NEXT_SHORT( p );
a363 3
    if ( prev_cont < 0 )
      goto Invalid_Outline;

d366 1
a366 1
      cont[0] = FT_NEXT_SHORT( p );
d370 2
a371 1
        goto Invalid_Outline;
d389 7
d398 1
a398 1
    load->glyph->control_data = NULL;
d407 8
a414 1
    /* check it */
d418 1
a418 1
      error = FT_THROW( Too_Many_Hints );
a425 14
      /* we don't trust `maxSizeOfInstructions' in the `maxp' table */
      /* and thus update the bytecode array size by ourselves       */

      tmp   = load->exec->glyphSize;
      error = Update_Max( load->exec->memory,
                          &tmp,
                          sizeof ( FT_Byte ),
                          (void*)&load->exec->glyphIns,
                          n_ins );

      load->exec->glyphSize = (FT_UShort)tmp;
      if ( error )
        return error;

d429 1
a429 2
      if ( n_ins )
        FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
a435 2
    outline = &gloader->current.outline;

d440 1
a440 1
    FT_ASSERT( flag );
d537 2
a538 2
    outline->n_points   = (FT_Short)n_points;
    outline->n_contours = (FT_Short)n_contours;
d546 1
a546 1
    error = FT_THROW( Invalid_Outline );
d601 1
a601 1
      if ( subglyph->flags & ARGS_ARE_XY_VALUES )
d603 2
a604 10
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = FT_NEXT_SHORT( p );
          subglyph->arg2 = FT_NEXT_SHORT( p );
        }
        else
        {
          subglyph->arg1 = FT_NEXT_CHAR( p );
          subglyph->arg2 = FT_NEXT_CHAR( p );
        }
d608 2
a609 10
        if ( subglyph->flags & ARGS_ARE_WORDS )
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_USHORT( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_USHORT( p );
        }
        else
        {
          subglyph->arg1 = (FT_Int)FT_NEXT_BYTE( p );
          subglyph->arg2 = (FT_Int)FT_NEXT_BYTE( p );
        }
d618 1
a618 1
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
d623 2
a624 2
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
d628 4
a631 4
        xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        xy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
        yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
a643 1
    FT_TRACE5(( "  %d components\n", num_subglyphs ));
d667 1
a667 1
    error = FT_THROW( Invalid_Composite );
d689 3
a691 4
    zone->n_points    = (FT_UShort)load->outline.n_points -
                          (FT_UShort)start_point;
    zone->n_contours  = load->outline.n_contours -
                          (FT_Short)start_contour;
a713 6
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Face    face   = loader->face;
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

d715 1
d718 1
a718 1
    FT_Long       n_ins;
d727 2
a728 2
      FT_TRACE1(( "TT_Hint_Glyph: too long instructions" ));
      FT_TRACE1(( " (0x%lx byte) is truncated\n",
d731 7
a737 1
    n_ins = loader->glyph->control_len;
d739 1
d745 1
a745 1
    loader->exec->GS = loader->size->GS;
d758 4
a761 2
      loader->exec->metrics.x_scale = loader->size->metrics.x_scale;
      loader->exec->metrics.y_scale = loader->size->metrics.y_scale;
d765 1
a765 3
    /* round phantom points */
    zone->cur[zone->n_points - 4].x =
      FT_PIX_ROUND( zone->cur[zone->n_points - 4].x );
a767 2
    zone->cur[zone->n_points - 2].y =
      FT_PIX_ROUND( zone->cur[zone->n_points - 2].y );
d775 1
d782 4
a785 2
      TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                        loader->exec->glyphIns, n_ins );
d790 4
a793 1
      error = TT_Run_Context( loader->exec );
d804 2
a805 6
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    /* Save possibly modified glyph phantom points unless in v40 backwards */
    /* compatibility mode, where no movement on the x axis means no reason */
    /* to change bearings or advance widths.                               */
    if ( !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            !loader->exec->backwards_compatibility ) )
a806 1
#endif
a810 12
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    }
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );

      else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
a811 1
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
d813 1
a813 1
    return FT_Err_Ok;
d831 1
a831 1
    FT_Error        error   = FT_Err_Ok;
d855 1
a855 1
    if ( loader->face->doblend && !loader->face->is_default_instance )
d858 3
a860 13
      error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                          loader->glyph_index,
                                          outline,
                                          (FT_UInt)n_points );

      /* recalculate linear horizontal and vertical advances */
      /* if we don't have HVAR and VVAR, respectively        */
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
        loader->linear = outline->points[n_points - 3].x -
                         outline->points[n_points - 4].x;
      if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
        loader->vadvance = outline->points[n_points - 1].x -
                           outline->points[n_points - 2].x;
d862 5
d869 8
d889 2
d892 4
a895 49
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      TT_Face    face   = loader->face;
      TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );

      FT_String*  family         = face->root.family_name;
      FT_UInt     ppem           = loader->size->metrics.x_ppem;
      FT_String*  style          = face->root.style_name;
      FT_UInt     x_scale_factor = 1000;
#endif

      FT_Vector*  vec   = outline->points;
      FT_Vector*  limit = outline->points + n_points;

      FT_Fixed  x_scale = 0; /* pacify compiler */
      FT_Fixed  y_scale = 0;

      FT_Bool  do_scale = FALSE;


#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* scale, but only if enabled and only if TT hinting is being used */
        if ( IS_HINTED( loader->load_flags ) )
          x_scale_factor = sph_test_tweak_x_scaling( face,
                                                     family,
                                                     ppem,
                                                     style,
                                                     loader->glyph_index );
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||
             x_scale_factor != 1000                         )
        {
          x_scale = FT_MulDiv( loader->size->metrics.x_scale,
                               (FT_Long)x_scale_factor, 1000 );
          y_scale = loader->size->metrics.y_scale;

          /* compensate for any scaling by de/emboldening; */
          /* the amount was determined via experimentation */
          if ( x_scale_factor != 1000 && ppem > 11 )
            FT_Outline_EmboldenXY( outline,
                                   FT_MulFix( 1280 * ppem,
                                              1000 - x_scale_factor ),
                                   0 );
          do_scale = TRUE;
        }
      }
      else
a896 1
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
d898 1
d900 2
a901 8
        /* scale the glyph */
        if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
        {
          x_scale = loader->size->metrics.x_scale;
          y_scale = loader->size->metrics.y_scale;

          do_scale = TRUE;
        }
d904 4
a907 13
      if ( do_scale )
      {
        for ( ; vec < limit; vec++ )
        {
          vec->x = FT_MulFix( vec->x, x_scale );
          vec->y = FT_MulFix( vec->y, y_scale );
        }

        loader->pp1 = outline->points[n_points - 4];
        loader->pp2 = outline->points[n_points - 3];
        loader->pp3 = outline->points[n_points - 2];
        loader->pp4 = outline->points[n_points - 1];
      }
d936 3
a938 2
    FT_GlyphLoader  gloader = loader->gloader;
    FT_Outline      current;
a942 5
    current.points   = gloader->base.outline.points +
                         num_base_points;
    current.n_points = gloader->base.outline.n_points -
                         (short)num_base_points;

d949 7
a955 1
      FT_Outline_Transform( &current, &subglyph->transform );
d960 2
a961 3
      FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;
      FT_UInt     k = (FT_UInt)subglyph->arg1;
      FT_UInt     l = (FT_UInt)subglyph->arg2;
d974 1
a974 1
        return FT_THROW( Invalid_Composite );
d988 1
a988 1
        return FT_Err_Ok;
d990 3
a992 3
      /* Use a default value dependent on                                  */
      /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
      /* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */
d1004 4
a1007 4
        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is what Apple documents.  But it doesn't work.   */
        /*                                                                 */
d1014 1
a1014 1
        int  d = subglyph->transform.yy > 0 ?  subglyph->transform.yy
d1027 1
a1027 1
#else /* 1 */
d1029 14
a1042 8
        /*******************************************************************/
        /*                                                                 */
        /* This algorithm is a guess and works much better than the above. */
        /*                                                                 */
        FT_Fixed  mac_xscale = FT_Hypot( subglyph->transform.xx,
                                         subglyph->transform.xy );
        FT_Fixed  mac_yscale = FT_Hypot( subglyph->transform.yy,
                                         subglyph->transform.yx );
d1048 1
a1048 1
#endif /* 1 */
d1054 2
a1055 2
        FT_Fixed  x_scale = loader->size->metrics.x_scale;
        FT_Fixed  y_scale = loader->size->metrics.y_scale;
d1070 3
a1072 1
      FT_Outline_Translate( &current, x, y );
d1074 1
a1074 1
    return FT_Err_Ok;
d1121 1
a1121 2
      FT_UShort  n_ins, max_ins;
      FT_ULong   tmp;
d1133 1
a1133 2
      max_ins = loader->face->max_profile.maxSizeOfInstructions;
      if ( n_ins > max_ins )
d1135 2
a1136 9
        /* don't trust `maxSizeOfInstructions'; */
        /* only do a rough safety check         */
        if ( (FT_Int)n_ins > loader->byte_len )
        {
          FT_TRACE1(( "TT_Process_Composite_Glyph:"
                      " too many instructions (%d) for glyph with length %d\n",
                      n_ins, loader->byte_len ));
          return FT_THROW( Too_Many_Hints );
        }
d1138 1
a1138 10
        tmp   = loader->exec->glyphSize;
        error = Update_Max( loader->exec->memory,
                            &tmp,
                            sizeof ( FT_Byte ),
                            (void*)&loader->exec->glyphIns,
                            n_ins );

        loader->exec->glyphSize = (FT_UShort)tmp;
        if ( error )
          return error;
d1141 1
a1141 1
        return FT_Err_Ok;
d1157 1
a1157 1
    for ( i = 0; i < loader->zone.n_points; i++ )
d1166 14
a1179 149
  /*
   * Calculate the phantom points
   *
   * Defining the right side bearing (rsb) as
   *
   *   rsb = aw - (lsb + xmax - xmin)
   *
   * (with `aw' the advance width, `lsb' the left side bearing, and `xmin'
   * and `xmax' the glyph's minimum and maximum x value), the OpenType
   * specification defines the initial position of horizontal phantom points
   * as
   *
   *   pp1 = (round(xmin - lsb), 0)      ,
   *   pp2 = (round(pp1 + aw), 0)        .
   *
   * Note that the rounding to the grid (in the device space) is not
   * documented currently in the specification.
   *
   * However, the specification lacks the precise definition of vertical
   * phantom points.  Greg Hitchcock provided the following explanation.
   *
   * - a `vmtx' table is present
   *
   *   For any glyph, the minimum and maximum y values (`ymin' and `ymax')
   *   are given in the `glyf' table, the top side bearing (tsb) and advance
   *   height (ah) are given in the `vmtx' table.  The bottom side bearing
   *   (bsb) is then calculated as
   *
   *     bsb = ah - (tsb + ymax - ymin)       ,
   *
   *   and the initial position of vertical phantom points is
   *
   *     pp3 = (x, round(ymax + tsb))       ,
   *     pp4 = (x, round(pp3 - ah))         .
   *
   *   See below for value `x'.
   *
   * - no `vmtx' table in the font
   *
   *   If there is an `OS/2' table, we set
   *
   *     DefaultAscender = sTypoAscender       ,
   *     DefaultDescender = sTypoDescender     ,
   *
   *   otherwise we use data from the `hhea' table:
   *
   *     DefaultAscender = Ascender         ,
   *     DefaultDescender = Descender       .
   *
   *   With these two variables we can now set
   *
   *     ah = DefaultAscender - sDefaultDescender    ,
   *     tsb = DefaultAscender - yMax                ,
   *
   *   and proceed as if a `vmtx' table was present.
   *
   * Usually we have
   *
   *   x = aw / 2      ,                                                (1)
   *
   * but there is one compatibility case where it can be set to
   *
   *   x = -DefaultDescender -
   *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)
   *
   * and another one with
   *
   *   x = 0     .                                                      (3)
   *
   * In Windows, the history of those values is quite complicated,
   * depending on the hinting engine (that is, the graphics framework).
   *
   *   framework        from                 to       formula
   *  ----------------------------------------------------------
   *    GDI       Windows 98               current      (1)
   *              (Windows 2000 for NT)
   *    GDI+      Windows XP               Windows 7    (2)
   *    GDI+      Windows 8                current      (3)
   *    DWrite    Windows 7                current      (3)
   *
   * For simplicity, FreeType uses (1) for grayscale subpixel hinting and
   * (3) for everything else.
   *
   */
  static void
  tt_loader_set_pp( TT_Loader  loader )
  {
    FT_Bool  subpixel_hinting = 0;
    FT_Bool  grayscale        = 0;
    FT_Bool  use_aw_2         = 0;

#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
    TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale
                                      : 0;
    }
#endif
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
    {
      subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting_lean
                                      : 0;
      grayscale        = loader->exec ? loader->exec->grayscale_cleartype
                                      : 0;
    }
#endif

    use_aw_2 = (FT_Bool)( subpixel_hinting && grayscale );

    loader->pp1.x = loader->bbox.xMin - loader->left_bearing;
    loader->pp1.y = 0;
    loader->pp2.x = loader->pp1.x + loader->advance;
    loader->pp2.y = 0;

    loader->pp3.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp3.y = loader->bbox.yMax + loader->top_bearing;
    loader->pp4.x = use_aw_2 ? loader->advance / 2 : 0;
    loader->pp4.y = loader->pp3.y - loader->vadvance;
  }


  /* a utility function to retrieve i-th node from given FT_List */
  static FT_ListNode
  ft_list_get_node_at( FT_List  list,
                       FT_UInt  index )
  {
    FT_ListNode  cur;


    if ( !list )
      return NULL;

    for ( cur = list->head; cur; cur = cur->next )
    {
      if ( !index )
        return cur;

      index--;
    }

    return NULL;
  }
d1197 1
a1197 1
    FT_Error        error        = FT_Err_Ok;
d1200 1
a1200 1
    TT_Face         face         = loader->face;
d1204 4
d1215 4
a1218 7
#ifdef FT_DEBUG_LEVEL_TRACE
    if ( recurse_count )
      FT_TRACE5(( "  nesting level: %d\n", recurse_count ));
#endif

    /* some fonts have an incorrect value of `maxComponentDepth' */
    if ( recurse_count > face->max_profile.maxComponentDepth )
d1220 2
a1221 3
      FT_TRACE1(( "load_truetype_glyph: maxComponentDepth set to %d\n",
                  recurse_count ));
      face->max_profile.maxComponentDepth = (FT_UShort)recurse_count;
a1223 1
#ifndef FT_CONFIG_OPTION_INCREMENTAL
d1227 1
a1227 1
      error = FT_THROW( Invalid_Glyph_Index );
a1229 1
#endif
d1235 2
a1236 2
      x_scale = loader->size->metrics.x_scale;
      y_scale = loader->size->metrics.y_scale;
d1244 2
d1267 1
a1267 1
      FT_ZERO( &inc_stream );
d1269 1
a1269 2
                            glyph_data.pointer,
                            (FT_ULong)glyph_data.length );
d1284 1
a1284 1
      if ( !face->glyf_offset                          &&
d1287 1
a1287 1
      if ( !face->glyf_offset )
d1291 1
a1291 1
        error = FT_THROW( Invalid_Table );
d1296 2
a1297 2
                                        face->glyf_offset + offset,
                                        (FT_UInt)loader->byte_len );
d1305 1
a1305 11
      if ( error )
        goto Exit;

      /* the metrics must be computed after loading the glyph header */
      /* since we need the glyph's `yMax' value in case the vertical */
      /* metrics must be emulated                                    */
      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
a1315 4
      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

d1319 1
a1319 7
      /* must initialize points before (possibly) overriding */
      /* glyph metrics from the incremental interface        */
      tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      tt_get_metrics_incr_overrides( loader, glyph_index );
#endif
d1323 1
a1323 1
      if ( loader->face->doblend && !loader->face->is_default_instance )
d1325 2
a1326 23
        /* a small outline structure with four elements for */
        /* communication with `TT_Vary_Apply_Glyph_Deltas'  */
        FT_Vector   points[4];
        char        tags[4]     = { 1, 1, 1, 1 };
        short       contours[4] = { 0, 1, 2, 3 };
        FT_Outline  outline;


        points[0].x = loader->pp1.x;
        points[0].y = loader->pp1.y;
        points[1].x = loader->pp2.x;
        points[1].y = loader->pp2.y;

        points[2].x = loader->pp3.x;
        points[2].y = loader->pp3.y;
        points[3].x = loader->pp4.x;
        points[3].y = loader->pp4.y;

        outline.n_points   = 4;
        outline.n_contours = 4;
        outline.points     = points;
        outline.tags       = tags;
        outline.contours   = contours;
d1328 3
a1330 5
        /* this must be done before scaling */
        error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                            glyph_index,
                                            &outline,
                                            (FT_UInt)outline.n_points );
d1334 6
a1339 17
        loader->pp1.x = points[0].x;
        loader->pp1.y = points[0].y;
        loader->pp2.x = points[1].x;
        loader->pp2.y = points[1].y;

        loader->pp3.x = points[2].x;
        loader->pp3.y = points[2].y;
        loader->pp4.x = points[3].x;
        loader->pp4.y = points[3].y;


        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;
d1342 1
a1342 1
#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
a1343 2
      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
a1347 3
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
a1348 1
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
d1352 1
a1352 1
      error = FT_Err_Ok;
d1356 1
a1356 7
    /* must initialize phantom points before (possibly) overriding */
    /* glyph metrics from the incremental interface                */
    tt_loader_set_pp( loader );

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    tt_get_metrics_incr_overrides( loader, glyph_index );
#endif
a1387 2
      FT_Memory  memory = face->root.memory;

a1391 36
      FT_ListNode  node, node2;


      /*
       * We store the glyph index directly in the `node->data' pointer,
       * following the glib solution (cf. macro `GUINT_TO_POINTER') with a
       * double cast to make this portable.  Note, however, that this needs
       * pointers with a width of at least 32 bits.
       */


      /* clear the nodes filled by sibling chains */
      node = ft_list_get_node_at( &loader->composites, recurse_count );
      for ( node2 = node; node2; node2 = node2->next )
        node2->data = (void*)ULONG_MAX;

      /* check whether we already have a composite glyph with this index */
      if ( FT_List_Find( &loader->composites,
                         (void*)(unsigned long)glyph_index ) )
      {
        FT_TRACE1(( "TT_Load_Composite_Glyph:"
                    " infinite recursion detected\n" ));
        error = FT_THROW( Invalid_Composite );
        goto Exit;
      }

      else if ( node )
        node->data = (void*)(unsigned long)glyph_index;

      else
      {
        if ( FT_NEW( node ) )
          goto Exit;
        node->data = (void*)(unsigned long)glyph_index;
        FT_List_Add( &loader->composites, node );
      }
d1393 2
a1394 2
      start_point   = (FT_UInt)gloader->base.outline.n_points;
      start_contour = (FT_UInt)gloader->base.outline.n_contours;
d1410 1
a1410 1
      if ( face->doblend && !face->is_default_instance )
d1412 1
a1412 1
        short        i, limit;
d1414 1
a1415 4
        FT_Outline  outline;
        FT_Vector*  points   = NULL;
        char*       tags     = NULL;
        short*      contours = NULL;
d1417 2
d1420 6
a1425 10
        limit = (short)gloader->current.num_subglyphs;

        /* construct an outline structure for              */
        /* communication with `TT_Vary_Apply_Glyph_Deltas' */
        outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );
        outline.n_contours = outline.n_points;

        outline.points   = NULL;
        outline.tags     = NULL;
        outline.contours = NULL;
d1427 2
a1428 4
        if ( FT_NEW_ARRAY( points, outline.n_points )   ||
             FT_NEW_ARRAY( tags, outline.n_points )     ||
             FT_NEW_ARRAY( contours, outline.n_points ) )
          goto Exit1;
d1430 1
a1430 52
        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {
          /* applying deltas for anchor points doesn't make sense, */
          /* but we don't have to specially check this since       */
          /* unused delta values are zero anyways                  */
          points[i].x = subglyph->arg1;
          points[i].y = subglyph->arg2;
          tags[i]     = 1;
          contours[i] = i;
        }

        points[i].x = loader->pp1.x;
        points[i].y = loader->pp1.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp2.x;
        points[i].y = loader->pp2.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp3.x;
        points[i].y = loader->pp3.y;
        tags[i]     = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp4.x;
        points[i].y = loader->pp4.y;
        tags[i]     = 1;
        contours[i] = i;

        outline.points   = points;
        outline.tags     = tags;
        outline.contours = contours;

        /* this call provides additional offsets */
        /* for each component's translation      */
        if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
                             face,
                             glyph_index,
                             &outline,
                             (FT_UInt)outline.n_points ) ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
d1434 5
a1438 2
            subglyph->arg1 = (FT_Int16)points[i].x;
            subglyph->arg2 = (FT_Int16)points[i].y;
d1442 4
a1445 21
        loader->pp1.x = points[i + 0].x;
        loader->pp1.y = points[i + 0].y;
        loader->pp2.x = points[i + 1].x;
        loader->pp2.y = points[i + 1].y;

        loader->pp3.x = points[i + 2].x;
        loader->pp3.y = points[i + 2].y;
        loader->pp4.x = points[i + 3].x;
        loader->pp4.y = points[i + 3].y;

        /* recalculate linear horizontal and vertical advances */
        /* if we don't have HVAR and VVAR, respectively        */
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
          loader->linear = loader->pp2.x - loader->pp1.x;
        if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
          loader->vadvance = loader->pp4.x - loader->pp3.x;

      Exit1:
        FT_FREE( outline.points );
        FT_FREE( outline.tags );
        FT_FREE( outline.contours );
d1447 1
a1447 2
        if ( error )
          goto Exit;
a1451 2
      /* scale phantom points, if necessary; */
      /* they get rounded in `TT_Hint_Glyph' */
a1455 3
        /* pp1.y and pp2.y are always zero */

        loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
a1456 1
        loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
d1477 1
a1477 1
        FT_SubGlyph  subglyph       = NULL;
a1483 1
        FT_Int       old_byte_len   = loader->byte_len;
a1492 3
          FT_Int  linear_hadvance;
          FT_Int  linear_vadvance;

d1505 1
a1505 4
          linear_hadvance = loader->linear;
          linear_vadvance = loader->vadvance;

          num_base_points = (FT_UInt)gloader->base.outline.n_points;
d1507 2
a1508 4
          error = load_truetype_glyph( loader,
                                       (FT_UInt)subglyph->index,
                                       recurse_count + 1,
                                       FALSE );
a1514 1
          /* restore phantom points if necessary */
a1520 3

            loader->linear   = linear_hadvance;
            loader->vadvance = linear_vadvance;
d1523 1
a1523 1
          num_points = (FT_UInt)gloader->base.outline.n_points;
d1534 2
a1535 6
          error = TT_Process_Composite_Component( loader,
                                                  subglyph,
                                                  start_point,
                                                  num_base_points );
          if ( error )
            goto Exit;
d1538 1
a1538 2
        loader->stream   = old_stream;
        loader->byte_len = old_byte_len;
d1543 1
d1545 1
d1547 1
d1549 1
d1551 2
a1552 7
        {
          error = TT_Process_Composite_Glyph( loader,
                                              start_point,
                                              start_contour );
          if ( error )
            goto Exit;
        }
d1558 1
a1558 1
      error = FT_THROW( Invalid_Outline );
a1587 6
    TT_Face    face   = loader->face;
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
#endif

d1589 1
d1592 1
a1592 1
    TT_Size       size  = loader->size;
d1606 17
a1622 1
    glyph->linearHoriAdvance = loader->linear;
d1628 3
a1630 12
    /* Adjust advance width to the value contained in the hdmx table    */
    /* unless FT_LOAD_COMPUTE_METRICS is set or backwards compatibility */
    /* mode of the v40 interpreter is active.  See `ttinterp.h' for     */
    /* details on backwards compatibility mode.                         */
    if (
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
         !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
            ( loader->exec && loader->exec->backwards_compatibility  ) ) &&
#endif
         !face->postscript.isFixedPitch                                  &&
         IS_HINTED( loader->load_flags )                                 &&
         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )               )
d1639 2
a1640 24
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        FT_Bool  ignore_x_mode;


        ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
                                 FT_RENDER_MODE_MONO );

        if ( widthp                                                   &&
             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
                !ignore_x_mode                                      ||
                SPH_OPTION_BITMAP_WIDTHS                            ) )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {
        if ( widthp )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
d1770 1
a1770 1
                                   (FT_UInt)load_flags,
d1779 2
a1780 2
      glyph->metrics.width  = (FT_Pos)metrics.width  * 64;
      glyph->metrics.height = (FT_Pos)metrics.height * 64;
d1782 7
a1788 7
      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX * 64;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY * 64;
      glyph->metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  * 64;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX * 64;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY * 64;
      glyph->metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  * 64;
a1816 2
    FT_Error  error;

a1818 7
#ifdef TT_USE_BYTECODE_INTERPRETER
    FT_Bool    pedantic = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
#endif
#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );
#endif
d1824 1
a1824 1
    FT_ZERO( loader );
d1832 1
a1832 19
      FT_Bool         grayscale = TRUE;
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      FT_Bool         subpixel_hinting_lean;
      FT_Bool         grayscale_cleartype;
#endif

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      FT_Bool  subpixel_hinting = FALSE;

#if 0
      /* not used yet */
      FT_Bool  compatible_widths;
      FT_Bool  symmetrical_smoothing;
      FT_Bool  bgr;
      FT_Bool  vertical_lcd;
      FT_Bool  subpixel_positioned;
      FT_Bool  gray_cleartype;
#endif
#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
a1833 1
      FT_Bool  reexecute = FALSE;
d1835 1
a1835 2

      if ( size->bytecode_ready < 0 || size->cvt_ready < 0 )
d1837 1
a1837 1
        error = tt_size_ready_bytecode( size, pedantic );
a1840 4
      else if ( size->bytecode_ready )
        return size->bytecode_ready;
      else if ( size->cvt_ready )
        return size->cvt_ready;
d1843 2
a1844 1
      exec = size->context;
d1846 1
a1846 1
        return FT_THROW( Could_Not_Find_Context );
d1848 2
a1849 18
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
      {
        subpixel_hinting_lean   = TRUE;
        grayscale_cleartype     = !FT_BOOL( load_flags         &
                                            FT_LOAD_TARGET_LCD     ||
                                            load_flags           &
                                            FT_LOAD_TARGET_LCD_V   );
        exec->vertical_lcd_lean = FT_BOOL( load_flags           &
                                           FT_LOAD_TARGET_LCD_V );
      }
      else
      {
        subpixel_hinting_lean   = FALSE;
        grayscale_cleartype     = FALSE;
        exec->vertical_lcd_lean = FALSE;
      }
#endif
d1851 1
a1851 1
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
d1853 3
a1855 1
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
d1857 1
a1857 110
        subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
                                      FT_RENDER_MODE_MONO               )  &&
                                    SPH_OPTION_SET_SUBPIXEL                );

        if ( subpixel_hinting )
          grayscale = FALSE;
        else if ( SPH_OPTION_SET_GRAYSCALE )
        {
          grayscale        = TRUE;
          subpixel_hinting = FALSE;
        }
        else
          grayscale = FALSE;

        if ( FT_IS_TRICKY( glyph->face ) )
          subpixel_hinting = FALSE;

        exec->ignore_x_mode      = subpixel_hinting || grayscale;
        exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
        if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
          exec->rasterizer_version = TT_INTERPRETER_VERSION_35;

#if 1
        exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
        exec->symmetrical_smoothing = TRUE;
        exec->bgr                   = FALSE;
        exec->vertical_lcd          = FALSE;
        exec->subpixel_positioned   = TRUE;
        exec->gray_cleartype        = FALSE;
#else /* 0 */
        exec->compatible_widths =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_COMPATIBLE_WIDTHS );
        exec->symmetrical_smoothing =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SYMMETRICAL_SMOOTHING );
        exec->bgr =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_BGR );
        exec->vertical_lcd =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_VERTICAL_LCD );
        exec->subpixel_positioned =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_SUBPIXEL_POSITIONED );
        exec->gray_cleartype =
          FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                   TT_LOAD_GRAY_CLEARTYPE );
#endif /* 0 */

      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        grayscale = FT_BOOL( !subpixel_hinting_lean               &&
                             FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO                );
      else
#endif
        grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                               FT_RENDER_MODE_MONO             );

      error = TT_Load_Context( exec, face, size );
      if ( error )
        return error;

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY

      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
      {
        /* a change from mono to subpixel rendering (and vice versa) */
        /* requires a re-execution of the CVT program                */
        if ( subpixel_hinting != exec->subpixel_hinting )
        {
          FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                      " re-executing `prep' table\n" ));

          exec->subpixel_hinting = subpixel_hinting;
          reexecute              = TRUE;
        }

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }
      else

#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */

      {

#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
        if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
        {
          /* a change from mono to subpixel rendering (and vice versa) */
          /* requires a re-execution of the CVT program                */
          if ( subpixel_hinting_lean != exec->subpixel_hinting_lean )
          {
            FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                        " re-executing `prep' table\n" ));
a1858 32
            exec->subpixel_hinting_lean = subpixel_hinting_lean;
            reexecute                   = TRUE;
          }

          /* a change from colored to grayscale subpixel rendering (and */
          /* vice versa) requires a re-execution of the CVT program     */
          if ( grayscale_cleartype != exec->grayscale_cleartype )
          {
            FT_TRACE4(( "tt_loader_init: grayscale subpixel hinting change,"
                        " re-executing `prep' table\n" ));

            exec->grayscale_cleartype = grayscale_cleartype;
            reexecute                 = TRUE;
          }
        }
#endif

        /* a change from mono to grayscale rendering (and vice versa) */
        /* requires a re-execution of the CVT program                 */
        if ( grayscale != exec->grayscale )
        {
          FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                      " re-executing `prep' table\n" ));

          exec->grayscale = grayscale;
          reexecute       = TRUE;
        }
      }

      if ( reexecute )
      {
        FT_UInt  i;
d1860 1
d1864 1
a1864 3
        error = tt_size_run_prep( size, pedantic );
        if ( error )
          return error;
d1867 1
a1867 1
      /* check whether the cvt program has disabled hinting */
a1874 8
#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
      /* check whether we have a font hinted for ClearType --           */
      /* note that this flag can also be modified in a glyph's bytecode */
      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
           exec->GS.instruct_control & 4                            )
        exec->ignore_x_mode = 0;
#endif

d1882 27
d1919 1
a1919 1
    loader->load_flags = (FT_ULong)load_flags;
d1921 2
a1922 2
    loader->face   = face;
    loader->size   = size;
d1926 1
a1926 14
    loader->composites.head = NULL;
    loader->composites.tail = NULL;

    return FT_Err_Ok;
  }


  static void
  tt_loader_done( TT_Loader  loader )
  {
    FT_List_Finalize( &loader->composites,
                      NULL,
                      loader->face->root.memory,
                      NULL );
d1963 1
a1966 5
#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
#define IS_DEFAULT_INSTANCE  ( ( (TT_Face)glyph->face )->is_default_instance )
#else
#define IS_DEFAULT_INSTANCE  1
#endif
d1968 2
a1969 2

    FT_TRACE1(( "TT_Load_Glyph: glyph index %d\n", glyph_index ));
d1973 4
a1976 1
    /* try to load embedded bitmap (if any) */
d1978 1
a1978 2
         ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&
         IS_DEFAULT_INSTANCE                     )
d1983 4
a1986 1
        if ( FT_IS_SCALABLE( glyph->face ) )
a1990 1
          tt_loader_done( &loader );
d1992 5
a1996 12
          glyph->linearVertAdvance = loader.vadvance;

          /* sanity checks: if `xxxAdvance' in the sbit metric */
          /* structure isn't set, use `linearXXXAdvance'      */
          if ( !glyph->metrics.horiAdvance && glyph->linearHoriAdvance )
            glyph->metrics.horiAdvance =
              FT_MulFix( glyph->linearHoriAdvance,
                         size->root.metrics.x_scale );
          if ( !glyph->metrics.vertAdvance && glyph->linearVertAdvance )
            glyph->metrics.vertAdvance =
              FT_MulFix( glyph->linearVertAdvance,
                         size->root.metrics.y_scale );
d1999 1
a1999 1
        return FT_Err_Ok;
d2007 1
a2007 1
      return FT_THROW( Invalid_Size_Handle );
d2010 1
a2010 1
      return FT_THROW( Invalid_Argument );
d2034 3
a2036 5
        /* Translate array so that (0,0) is the glyph's origin.  Note  */
        /* that this behaviour is independent on the value of bit 1 of */
        /* the `flags' field in the `head' table -- at least major     */
        /* applications like Acroread indicate that.                   */
        if ( loader.pp1.x )
d2074 1
a2074 1
      error = compute_glyph_metrics( &loader, glyph_index );
a2076 2
    tt_loader_done( &loader );

@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
