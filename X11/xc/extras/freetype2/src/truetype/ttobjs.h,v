head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.22.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.48.34;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.05.12;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.11;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.29;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.56;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.27;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.22;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.09;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttobjs.h                                                               */
/*                                                                         */
/*    Objects manager (specification).                                     */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef TTOBJS_H_
#define TTOBJS_H_


#include <ft2build.h>
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_TRUETYPE_TYPES_H


FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    TT_Driver                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a TrueType driver object.                              */
  /*                                                                       */
  typedef struct TT_DriverRec_*  TT_Driver;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    TT_GlyphSlot                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a TrueType glyph slot object.                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This is a direct typedef of FT_GlyphSlot, as there is nothing      */
  /*    specific about the TrueType glyph slot.                            */
  /*                                                                       */
  typedef FT_GlyphSlot  TT_GlyphSlot;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    TT_GraphicsState                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The TrueType graphics state used during bytecode interpretation.   */
  /*                                                                       */
  typedef struct  TT_GraphicsState_
  {
    FT_UShort      rp0;
    FT_UShort      rp1;
    FT_UShort      rp2;

    FT_UnitVector  dualVector;
    FT_UnitVector  projVector;
    FT_UnitVector  freeVector;

    FT_Long        loop;
    FT_F26Dot6     minimum_distance;
    FT_Int         round_state;

    FT_Bool        auto_flip;
    FT_F26Dot6     control_value_cutin;
    FT_F26Dot6     single_width_cutin;
    FT_F26Dot6     single_width_value;
    FT_UShort      delta_base;
    FT_UShort      delta_shift;

    FT_Byte        instruct_control;
    /* According to Greg Hitchcock from Microsoft, the `scan_control'     */
    /* variable as documented in the TrueType specification is a 32-bit   */
    /* integer; the high-word part holds the SCANTYPE value, the low-word */
    /* part the SCANCTRL value.  We separate it into two fields.          */
    FT_Bool        scan_control;
    FT_Int         scan_type;

    FT_UShort      gep0;
    FT_UShort      gep1;
    FT_UShort      gep2;

  } TT_GraphicsState;


#ifdef TT_USE_BYTECODE_INTERPRETER

  FT_LOCAL( void )
  tt_glyphzone_done( TT_GlyphZone  zone );

  FT_LOCAL( FT_Error )
  tt_glyphzone_new( FT_Memory     memory,
                    FT_UShort     maxPoints,
                    FT_Short      maxContours,
                    TT_GlyphZone  zone );

#endif /* TT_USE_BYTECODE_INTERPRETER */



  /*************************************************************************/
  /*                                                                       */
  /*  EXECUTION SUBTABLES                                                  */
  /*                                                                       */
  /*  These sub-tables relate to instruction execution.                    */
  /*                                                                       */
  /*************************************************************************/


#define TT_MAX_CODE_RANGES  3


  /*************************************************************************/
  /*                                                                       */
  /* There can only be 3 active code ranges at once:                       */
  /*   - the Font Program                                                  */
  /*   - the CVT Program                                                   */
  /*   - a glyph's instructions set                                        */
  /*                                                                       */
  typedef enum  TT_CodeRange_Tag_
  {
    tt_coderange_none = 0,
    tt_coderange_font,
    tt_coderange_cvt,
    tt_coderange_glyph

  } TT_CodeRange_Tag;


  typedef struct  TT_CodeRange_
  {
    FT_Byte*  base;
    FT_Long   size;

  } TT_CodeRange;

  typedef TT_CodeRange  TT_CodeRangeTable[TT_MAX_CODE_RANGES];


  /*************************************************************************/
  /*                                                                       */
  /* Defines a function/instruction definition record.                     */
  /*                                                                       */
  typedef struct  TT_DefRecord_
  {
    FT_Int    range;          /* in which code range is it located?     */
    FT_Long   start;          /* where does it start?                   */
    FT_Long   end;            /* where does it end?                     */
    FT_UInt   opc;            /* function #, or instruction code        */
    FT_Bool   active;         /* is it active?                          */
    FT_Bool   inline_delta;   /* is function that defines inline delta? */
    FT_ULong  sph_fdef_flags; /* flags to identify special functions    */

  } TT_DefRecord, *TT_DefArray;


  /*************************************************************************/
  /*                                                                       */
  /* Subglyph transformation record.                                       */
  /*                                                                       */
  typedef struct  TT_Transform_
  {
    FT_Fixed    xx, xy;     /* transformation matrix coefficients */
    FT_Fixed    yx, yy;
    FT_F26Dot6  ox, oy;     /* offsets                            */

  } TT_Transform;


  /*************************************************************************/
  /*                                                                       */
  /* A note regarding non-squared pixels:                                  */
  /*                                                                       */
  /* (This text will probably go into some docs at some time; for now, it  */
  /* is kept here to explain some definitions in the TT_Size_Metrics       */
  /* record).                                                              */
  /*                                                                       */
  /* The CVT is a one-dimensional array containing values that control     */
  /* certain important characteristics in a font, like the height of all   */
  /* capitals, all lowercase letter, default spacing or stem width/height. */
  /*                                                                       */
  /* These values are found in FUnits in the font file, and must be scaled */
  /* to pixel coordinates before being used by the CVT and glyph programs. */
  /* Unfortunately, when using distinct x and y resolutions (or distinct x */
  /* and y pointsizes), there are two possible scalings.                   */
  /*                                                                       */
  /* A first try was to implement a `lazy' scheme where all values were    */
  /* scaled when first used.  However, while some values are always used   */
  /* in the same direction, some others are used under many different      */
  /* circumstances and orientations.                                       */
  /*                                                                       */
  /* I have found a simpler way to do the same, and it even seems to work  */
  /* in most of the cases:                                                 */
  /*                                                                       */
  /* - All CVT values are scaled to the maximum ppem size.                 */
  /*                                                                       */
  /* - When performing a read or write in the CVT, a ratio factor is used  */
  /*   to perform adequate scaling.  Example:                              */
  /*                                                                       */
  /*     x_ppem = 14                                                       */
  /*     y_ppem = 10                                                       */
  /*                                                                       */
  /*   We choose ppem = x_ppem = 14 as the CVT scaling size.  All cvt      */
  /*   entries are scaled to it.                                           */
  /*                                                                       */
  /*     x_ratio = 1.0                                                     */
  /*     y_ratio = y_ppem/ppem (< 1.0)                                     */
  /*                                                                       */
  /*   We compute the current ratio like:                                  */
  /*                                                                       */
  /*   - If projVector is horizontal,                                      */
  /*       ratio = x_ratio = 1.0                                           */
  /*                                                                       */
  /*   - if projVector is vertical,                                        */
  /*       ratio = y_ratio                                                 */
  /*                                                                       */
  /*   - else,                                                             */
  /*       ratio = sqrt( (proj.x * x_ratio) ^ 2 + (proj.y * y_ratio) ^ 2 ) */
  /*                                                                       */
  /*   Reading a cvt value returns                                         */
  /*     ratio * cvt[index]                                                */
  /*                                                                       */
  /*   Writing a cvt value in pixels:                                      */
  /*     cvt[index] / ratio                                                */
  /*                                                                       */
  /*   The current ppem is simply                                          */
  /*     ratio * ppem                                                      */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* Metrics used by the TrueType size and context objects.                */
  /*                                                                       */
  typedef struct  TT_Size_Metrics_
  {
    /* for non-square pixels */
    FT_Long     x_ratio;
    FT_Long     y_ratio;

    FT_UShort   ppem;               /* maximum ppem size              */
    FT_Long     ratio;              /* current ratio                  */
    FT_Fixed    scale;

    FT_F26Dot6  compensations[4];   /* device-specific compensations  */

    FT_Bool     valid;

    FT_Bool     rotated;            /* `is the glyph rotated?'-flag   */
    FT_Bool     stretched;          /* `is the glyph stretched?'-flag */

  } TT_Size_Metrics;


  /*************************************************************************/
  /*                                                                       */
  /* TrueType size class.                                                  */
  /*                                                                       */
  typedef struct  TT_SizeRec_
  {
    FT_SizeRec         root;

    /* we have our own copy of metrics so that we can modify */
    /* it without affecting auto-hinting (when used)         */
    FT_Size_Metrics    metrics;

    TT_Size_Metrics    ttmetrics;

    FT_ULong           strike_index;      /* 0xFFFFFFFF to indicate invalid */

#ifdef TT_USE_BYTECODE_INTERPRETER

    FT_Long            point_size;    /* for the `MPS' bytecode instruction */

    FT_UInt            num_function_defs; /* number of function definitions */
    FT_UInt            max_function_defs;
    TT_DefArray        function_defs;     /* table of function definitions  */

    FT_UInt            num_instruction_defs;  /* number of ins. definitions */
    FT_UInt            max_instruction_defs;
    TT_DefArray        instruction_defs;      /* table of ins. definitions  */

    FT_UInt            max_func;
    FT_UInt            max_ins;

    TT_CodeRangeTable  codeRangeTable;

    TT_GraphicsState   GS;

    FT_ULong           cvt_size;      /* the scaled control value table */
    FT_Long*           cvt;

    FT_UShort          storage_size; /* The storage area is now part of */
    FT_Long*           storage;      /* the instance                    */

    TT_GlyphZoneRec    twilight;     /* The instance's twilight zone    */

    TT_ExecContext     context;

    /* if negative, `fpgm' (resp. `prep'), wasn't executed yet; */
    /* otherwise it is the returned error code                  */
    FT_Error           bytecode_ready;
    FT_Error           cvt_ready;

#endif /* TT_USE_BYTECODE_INTERPRETER */

  } TT_SizeRec;


  /*************************************************************************/
  /*                                                                       */
  /* TrueType driver class.                                                */
  /*                                                                       */
  typedef struct  TT_DriverRec_
  {
    FT_DriverRec  root;

    TT_GlyphZoneRec  zone;     /* glyph loader points zone */

    FT_UInt  interpreter_version;

  } TT_DriverRec;


  /* Note: All of the functions below (except tt_size_reset()) are used    */
  /* as function pointers in a FT_Driver_ClassRec.  Therefore their        */
  /* parameters are of types FT_Face, FT_Size, etc., rather than TT_Face,  */
  /* TT_Size, etc., so that the compiler can confirm that the types and    */
  /* number of parameters are correct.  In all cases the FT_xxx types are  */
  /* cast to their TT_xxx counterparts inside the functions since FreeType */
  /* will always use the TT driver to create them.                         */


  /*************************************************************************/
  /*                                                                       */
  /* Face functions                                                        */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_face_init( FT_Stream      stream,
                FT_Face        ttface,      /* TT_Face */
                FT_Int         face_index,
                FT_Int         num_params,
                FT_Parameter*  params );

  FT_LOCAL( void )
  tt_face_done( FT_Face  ttface );          /* TT_Face */


  /*************************************************************************/
  /*                                                                       */
  /* Size functions                                                        */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_size_init( FT_Size  ttsize );          /* TT_Size */

  FT_LOCAL( void )
  tt_size_done( FT_Size  ttsize );          /* TT_Size */

#ifdef TT_USE_BYTECODE_INTERPRETER

  FT_LOCAL( FT_Error )
  tt_size_run_fpgm( TT_Size  size,
                    FT_Bool  pedantic );

  FT_LOCAL( FT_Error )
  tt_size_run_prep( TT_Size  size,
                    FT_Bool  pedantic );

  FT_LOCAL( FT_Error )
  tt_size_ready_bytecode( TT_Size  size,
                          FT_Bool  pedantic );

#endif /* TT_USE_BYTECODE_INTERPRETER */

  FT_LOCAL( FT_Error )
  tt_size_reset( TT_Size  size );


  /*************************************************************************/
  /*                                                                       */
  /* Driver functions                                                      */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_driver_init( FT_Module  ttdriver );    /* TT_Driver */

  FT_LOCAL( void )
  tt_driver_done( FT_Module  ttdriver );    /* TT_Driver */


  /*************************************************************************/
  /*                                                                       */
  /* Slot functions                                                        */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_slot_init( FT_GlyphSlot  slot );


  /* auxiliary */
#define IS_HINTED( flags )  ( ( flags & FT_LOAD_NO_HINTING ) == 0 )


FT_END_HEADER

#endif /* TTOBJS_H_ */


/* END */
@


1.4
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
d19 2
a20 2
#ifndef __TTOBJS_H__
#define __TTOBJS_H__
a44 11
  /*    TT_Instance                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a TrueType size object.                                */
  /*                                                                       */
  typedef struct TT_SizeRec_*  TT_Size;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
a74 4
#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
    FT_Bool        both_x_axis;
#endif

d83 2
a84 2
    FT_Short       delta_base;
    FT_Short       delta_shift;
d148 1
a148 1
    FT_ULong  size;
d161 7
a167 4
    FT_Int   range;      /* in which code range is it located? */
    FT_Long  start;      /* where does it start?               */
    FT_UInt  opc;        /* function #, or instruction code    */
    FT_Bool  active;     /* is it active?                      */
d180 1
a180 1
    FT_F26Dot6  ox, oy;     /* offsets        */
d289 2
a313 7
    /* debugging variables */

    /* When using the debugger, we must keep the */
    /* execution context tied to the instance    */
    /* object rather than asking it on demand.   */

    FT_Bool            debug;
d316 4
a319 2
    FT_Bool            bytecode_ready;
    FT_Bool            cvt_ready;
d332 2
a333 2
    FT_DriverRec     root;
    TT_ExecContext   context;  /* execution context        */
d336 1
a336 1
    void*            extension_component;
d378 2
a379 1
  tt_size_run_fpgm( TT_Size  size );
d382 2
a383 1
  tt_size_run_prep( TT_Size  size );
d386 2
a387 1
  tt_size_ready_bytecode( TT_Size  size );
d414 4
d420 1
a420 1
#endif /* __TTOBJS_H__ */
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d102 4
a198 32
  /* Subglyph loading record.  Used to load composite components.          */
  /*                                                                       */
  typedef struct  TT_SubglyphRec_
  {
    FT_Long          index;        /* subglyph index; initialized with -1 */
    FT_Bool          is_scaled;    /* is the subglyph scaled?             */
    FT_Bool          is_hinted;    /* should it be hinted?                */
    FT_Bool          preserve_pps; /* preserve phantom points?            */

    FT_Long          file_offset;

    FT_BBox          bbox;
    FT_Pos           left_bearing;
    FT_Pos           advance;

    TT_GlyphZoneRec  zone;

    FT_Long          arg1;         /* first argument                      */
    FT_Long          arg2;         /* second argument                     */

    FT_UShort        element_flag; /* current load element flag           */

    TT_Transform     transform;    /* transformation matrix               */

    FT_Vector        pp1, pp2;     /* phantom points (horizontal)         */
    FT_Vector        pp3, pp4;     /* phantom points (vertical)           */

  } TT_SubGlyphRec, *TT_SubGlyph_Stack;


  /*************************************************************************/
  /*                                                                       */
d202 2
a203 2
  /*  is kept here to explain some definitions in the TIns_Metrics         */
  /*  record).                                                             */
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d112 1
a112 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d123 1
a123 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d327 1
a327 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d361 4
a364 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d418 1
a418 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d426 4
a429 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d319 4
a322 1
    FT_Size_Metrics    metrics; /* slightly different from the root metrics */
d325 1
a325 6
#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    FT_UInt            strike_index;    /* 0xFFFF to indicate invalid */
    FT_Size_Metrics    strike_metrics;  /* current strike's metrics   */

#endif
d381 9
d396 1
a396 1
                TT_Face        face,
d402 1
a402 1
  tt_face_done( TT_Face  face );
d410 1
a410 1
  tt_size_init( TT_Size  size );
d413 11
a423 1
  tt_size_done( TT_Size  size );
d434 1
a434 1
  tt_driver_init( TT_Driver  driver );
d437 9
a445 1
  tt_driver_done( TT_Driver  driver );
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d112 1
a112 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d123 1
a123 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d319 4
a322 3
    /* we have our own copy of metrics so that we can modify */
    /* it without affecting auto-hinting (when used)         */
    FT_Size_Metrics    metrics;
d324 2
a325 1
    TT_Size_Metrics    ttmetrics;
d327 1
a327 1
    FT_ULong           strike_index;      /* 0xFFFFFFFF to indicate invalid */
d329 1
a329 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d363 1
a363 4
    FT_Bool            bytecode_ready;
    FT_Bool            cvt_ready;

#endif /* TT_USE_BYTECODE_INTERPRETER */
a382 9
  /* Note: All of the functions below (except tt_size_reset()) are used    */
  /* as function pointers in a FT_Driver_ClassRec.  Therefore their        */
  /* parameters are of types FT_Face, FT_Size, etc., rather than TT_Face,  */
  /* TT_Size, etc., so that the compiler can confirm that the types and    */
  /* number of parameters are correct.  In all cases the FT_xxx types are  */
  /* cast to their TT_xxx counterparts inside the functions since FreeType */
  /* will always use the TT driver to create them.                         */


d389 1
a389 1
                FT_Face        ttface,      /* TT_Face */
d395 1
a395 1
  tt_face_done( FT_Face  ttface );          /* TT_Face */
d403 1
a403 1
  tt_size_init( FT_Size  ttsize );          /* TT_Size */
d406 1
a406 14
  tt_size_done( FT_Size  ttsize );          /* TT_Size */

#ifdef TT_USE_BYTECODE_INTERPRETER

  FT_LOCAL( FT_Error )
  tt_size_run_fpgm( TT_Size  size );

  FT_LOCAL( FT_Error )
  tt_size_run_prep( TT_Size  size );

  FT_LOCAL( FT_Error )
  tt_size_ready_bytecode( TT_Size  size );

#endif /* TT_USE_BYTECODE_INTERPRETER */
d417 1
a417 1
  tt_driver_init( FT_Module  ttdriver );    /* TT_Driver */
d420 1
a420 9
  tt_driver_done( FT_Module  ttdriver );    /* TT_Driver */


  /*************************************************************************/
  /*                                                                       */
  /* Slot functions                                                        */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_slot_init( FT_GlyphSlot  slot );
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d319 2
a320 3
    /* we have our own copy of metrics so that we can modify */
    /* it without affecting auto-hinting (when used)         */
    FT_Size_Metrics    metrics;
d322 1
a322 1
    TT_Size_Metrics    ttmetrics;
d324 4
a327 1
    FT_ULong           strike_index;      /* 0xFFFFFFFF to indicate invalid */
a382 9
  /* Note: All of the functions below (except tt_size_reset()) are used    */
  /* as function pointers in a FT_Driver_ClassRec.  Therefore their        */
  /* parameters are of types FT_Face, FT_Size, etc., rather than TT_Face,  */
  /* TT_Size, etc., so that the compiler can confirm that the types and    */
  /* number of parameters are correct.  In all cases the FT_xxx types are  */
  /* cast to their TT_xxx counterparts inside the functions since FreeType */
  /* will always use the TT driver to create them.                         */


d389 1
a389 1
                FT_Face        ttface,      /* TT_Face */
d395 1
a395 1
  tt_face_done( FT_Face  ttface );          /* TT_Face */
d403 1
a403 1
  tt_size_init( FT_Size  ttsize );          /* TT_Size */
d406 1
a406 11
  tt_size_done( FT_Size  ttsize );          /* TT_Size */

#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER

  FT_LOCAL( FT_Error )
  tt_size_run_fpgm( TT_Size  size );

  FT_LOCAL( FT_Error )
  tt_size_run_prep( TT_Size  size );

#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d417 1
a417 1
  tt_driver_init( FT_Module  ttdriver );    /* TT_Driver */
d420 1
a420 9
  tt_driver_done( FT_Module  ttdriver );    /* TT_Driver */


  /*************************************************************************/
  /*                                                                       */
  /* Slot functions                                                        */
  /*                                                                       */
  FT_LOCAL( FT_Error )
  tt_slot_init( FT_GlyphSlot  slot );
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
a101 4
    /* According to Greg Hitchcock from Microsoft, the `scan_control'     */
    /* variable as documented in the TrueType specification is a 32-bit   */
    /* integer; the high-word part holds the SCANTYPE value, the low-word */
    /* part the SCANCTRL value.  We separate it into two fields.          */
d112 1
a112 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d123 1
a123 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d195 32
d230 2
a231 2
  /* is kept here to explain some definitions in the TT_Size_Metrics       */
  /* record).                                                              */
d327 1
a327 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d361 1
a361 4
    FT_Bool            bytecode_ready;
    FT_Bool            cvt_ready;

#endif /* TT_USE_BYTECODE_INTERPRETER */
d415 1
a415 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d423 1
a423 4
  FT_LOCAL( FT_Error )
  tt_size_ready_bytecode( TT_Size  size );

#endif /* TT_USE_BYTECODE_INTERPRETER */
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d19 2
a20 2
#ifndef TTOBJS_H_
#define TTOBJS_H_
d45 11
d86 4
d98 2
a99 2
    FT_UShort      delta_base;
    FT_UShort      delta_shift;
d163 1
a163 1
    FT_Long   size;
d176 4
a179 7
    FT_Int    range;          /* in which code range is it located?     */
    FT_Long   start;          /* where does it start?                   */
    FT_Long   end;            /* where does it end?                     */
    FT_UInt   opc;            /* function #, or instruction code        */
    FT_Bool   active;         /* is it active?                          */
    FT_Bool   inline_delta;   /* is function that defines inline delta? */
    FT_ULong  sph_fdef_flags; /* flags to identify special functions    */
d192 1
a192 1
    FT_F26Dot6  ox, oy;     /* offsets                            */
a300 2
    FT_Long            point_size;    /* for the `MPS' bytecode instruction */

d324 7
d333 2
a334 4
    /* if negative, `fpgm' (resp. `prep'), wasn't executed yet; */
    /* otherwise it is the returned error code                  */
    FT_Error           bytecode_ready;
    FT_Error           cvt_ready;
d347 2
a348 2
    FT_DriverRec  root;

d351 1
a351 1
    FT_UInt  interpreter_version;
d393 1
a393 2
  tt_size_run_fpgm( TT_Size  size,
                    FT_Bool  pedantic );
d396 1
a396 2
  tt_size_run_prep( TT_Size  size,
                    FT_Bool  pedantic );
d399 1
a399 2
  tt_size_ready_bytecode( TT_Size  size,
                          FT_Bool  pedantic );
a425 4
  /* auxiliary */
#define IS_HINTED( flags )  ( ( flags & FT_LOAD_NO_HINTING ) == 0 )


d428 1
a428 1
#endif /* TTOBJS_H_ */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
