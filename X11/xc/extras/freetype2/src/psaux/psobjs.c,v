head	1.7;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.7
date	2017.05.02.10.42.58;	author tg;	state Exp;
branches;
next	1.6;
commitid	100590862CC6AA03AFA;

1.6
date	2017.04.15.19.21.53;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.10;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.42;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.02;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.58;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.38.21;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.34;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.16;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.25;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.05;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.7
log
@CVE-2017-8287
@
text
@/***************************************************************************/
/*                                                                         */
/*  psobjs.c                                                               */
/*                                                                         */
/*    Auxiliary functions for PostScript fonts (body).                     */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_POSTSCRIPT_AUX_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H

#include "psobjs.h"
#include "psconv.h"

#include "psauxerr.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_psobjs


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                             PS_TABLE                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ps_table_new                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a PS_Table.                                            */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    table  :: The address of the target table.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    count  :: The table size = the maximum number of elements.         */
  /*                                                                       */
  /*    memory :: The memory object to use for all subsequent              */
  /*              reallocations.                                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  ps_table_new( PS_Table   table,
                FT_Int     count,
                FT_Memory  memory )
  {
    FT_Error  error;


    table->memory = memory;
    if ( FT_NEW_ARRAY( table->elements, count ) ||
         FT_NEW_ARRAY( table->lengths,  count ) )
      goto Exit;

    table->max_elems = count;
    table->init      = 0xDEADBEEFUL;
    table->num_elems = 0;
    table->block     = NULL;
    table->capacity  = 0;
    table->cursor    = 0;

    *(PS_Table_FuncsRec*)&table->funcs = ps_table_funcs;

  Exit:
    if ( error )
      FT_FREE( table->elements );

    return error;
  }


  static void
  shift_elements( PS_Table  table,
                  FT_Byte*  old_base )
  {
    FT_PtrDist  delta  = table->block - old_base;
    FT_Byte**   offset = table->elements;
    FT_Byte**   limit  = offset + table->max_elems;


    for ( ; offset < limit; offset++ )
    {
      if ( offset[0] )
        offset[0] += delta;
    }
  }


  static FT_Error
  reallocate_t1_table( PS_Table   table,
                       FT_Offset  new_size )
  {
    FT_Memory  memory   = table->memory;
    FT_Byte*   old_base = table->block;
    FT_Error   error;


    /* allocate new base block */
    if ( FT_ALLOC( table->block, new_size ) )
    {
      table->block = old_base;
      return error;
    }

    /* copy elements and shift offsets */
    if ( old_base )
    {
      FT_MEM_COPY( table->block, old_base, table->capacity );
      shift_elements( table, old_base );
      FT_FREE( old_base );
    }

    table->capacity = new_size;

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ps_table_add                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Adds an object to a PS_Table, possibly growing its memory block.   */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    table  :: The target table.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    idx    :: The index of the object in the table.                    */
  /*                                                                       */
  /*    object :: The address of the object to copy in memory.             */
  /*                                                                       */
  /*    length :: The length in bytes of the source object.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.  An error is returned if a  */
  /*    reallocation fails.                                                */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  ps_table_add( PS_Table  table,
                FT_Int    idx,
                void*     object,
                FT_UInt   length )
  {
    if ( idx < 0 || idx >= table->max_elems )
    {
      FT_ERROR(( "ps_table_add: invalid index\n" ));
      return FT_THROW( Invalid_Argument );
    }

    /* grow the base block if needed */
    if ( table->cursor + length > table->capacity )
    {
      FT_Error    error;
      FT_Offset   new_size = table->capacity;
      FT_PtrDist  in_offset;


      in_offset = (FT_Byte*)object - table->block;
      if ( in_offset < 0 || (FT_Offset)in_offset >= table->capacity )
        in_offset = -1;

      while ( new_size < table->cursor + length )
      {
        /* increase size by 25% and round up to the nearest multiple
           of 1024 */
        new_size += ( new_size >> 2 ) + 1;
        new_size  = FT_PAD_CEIL( new_size, 1024 );
      }

      error = reallocate_t1_table( table, new_size );
      if ( error )
        return error;

      if ( in_offset >= 0 )
        object = table->block + in_offset;
    }

    /* add the object to the base block and adjust offset */
    table->elements[idx] = table->block + table->cursor;
    table->lengths [idx] = length;
    FT_MEM_COPY( table->block + table->cursor, object, length );

    table->cursor += length;
    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    ps_table_done                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a PS_TableRec (i.e., reallocate it to its current        */
  /*    cursor).                                                           */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    table :: The target table.                                         */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function does NOT release the heap's memory block.  It is up  */
  /*    to the caller to clean it, or reference it in its own structures.  */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  ps_table_done( PS_Table  table )
  {
    FT_Memory  memory = table->memory;
    FT_Error   error;
    FT_Byte*   old_base = table->block;


    /* should never fail, because rec.cursor <= rec.size */
    if ( !old_base )
      return;

    if ( FT_ALLOC( table->block, table->cursor ) )
      return;
    FT_MEM_COPY( table->block, old_base, table->cursor );
    shift_elements( table, old_base );

    table->capacity = table->cursor;
    FT_FREE( old_base );

    FT_UNUSED( error );
  }


  FT_LOCAL_DEF( void )
  ps_table_release( PS_Table  table )
  {
    FT_Memory  memory = table->memory;


    if ( (FT_ULong)table->init == 0xDEADBEEFUL )
    {
      FT_FREE( table->block );
      FT_FREE( table->elements );
      FT_FREE( table->lengths );
      table->init = 0;
    }
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                            T1 PARSER                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* first character must be already part of the comment */

  static void
  skip_comment( FT_Byte*  *acur,
                FT_Byte*   limit )
  {
    FT_Byte*  cur = *acur;


    while ( cur < limit )
    {
      if ( IS_PS_NEWLINE( *cur ) )
        break;
      cur++;
    }

    *acur = cur;
  }


  static void
  skip_spaces( FT_Byte*  *acur,
               FT_Byte*   limit )
  {
    FT_Byte*  cur = *acur;


    while ( cur < limit )
    {
      if ( !IS_PS_SPACE( *cur ) )
      {
        if ( *cur == '%' )
          /* According to the PLRM, a comment is equal to a space. */
          skip_comment( &cur, limit );
        else
          break;
      }
      cur++;
    }

    *acur = cur;
  }


#define IS_OCTAL_DIGIT( c ) ( '0' <= (c) && (c) <= '7' )


  /* first character must be `(';                               */
  /* *acur is positioned at the character after the closing `)' */

  static FT_Error
  skip_literal_string( FT_Byte*  *acur,
                       FT_Byte*   limit )
  {
    FT_Byte*      cur   = *acur;
    FT_Int        embed = 0;
    FT_Error      error = FT_ERR( Invalid_File_Format );
    unsigned int  i;


    while ( cur < limit )
    {
      FT_Byte  c = *cur;


      cur++;

      if ( c == '\\' )
      {
        /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
        /* A backslash can introduce three different types              */
        /* of escape sequences:                                         */
        /*   - a special escaped char like \r, \n, etc.                 */
        /*   - a one-, two-, or three-digit octal number                */
        /*   - none of the above in which case the backslash is ignored */

        if ( cur == limit )
          /* error (or to be ignored?) */
          break;

        switch ( *cur )
        {
          /* skip `special' escape */
        case 'n':
        case 'r':
        case 't':
        case 'b':
        case 'f':
        case '\\':
        case '(':
        case ')':
          cur++;
          break;

        default:
          /* skip octal escape or ignore backslash */
          for ( i = 0; i < 3 && cur < limit; i++ )
          {
            if ( !IS_OCTAL_DIGIT( *cur ) )
              break;

            cur++;
          }
        }
      }
      else if ( c == '(' )
        embed++;
      else if ( c == ')' )
      {
        embed--;
        if ( embed == 0 )
        {
          error = FT_Err_Ok;
          break;
        }
      }
    }

    *acur = cur;

    return error;
  }


  /* first character must be `<' */

  static FT_Error
  skip_string( FT_Byte*  *acur,
               FT_Byte*   limit )
  {
    FT_Byte*  cur = *acur;
    FT_Error  err =  FT_Err_Ok;


    while ( ++cur < limit )
    {
      /* All whitespace characters are ignored. */
      skip_spaces( &cur, limit );
      if ( cur >= limit )
        break;

      if ( !IS_PS_XDIGIT( *cur ) )
        break;
    }

    if ( cur < limit && *cur != '>' )
    {
      FT_ERROR(( "skip_string: missing closing delimiter `>'\n" ));
      err = FT_THROW( Invalid_File_Format );
    }
    else
      cur++;

    *acur = cur;
    return err;
  }


  /* first character must be the opening brace that */
  /* starts the procedure                           */

  /* NB: [ and ] need not match:                    */
  /* `/foo {[} def' is a valid PostScript fragment, */
  /* even within a Type1 font                       */

  static FT_Error
  skip_procedure( FT_Byte*  *acur,
                  FT_Byte*   limit )
  {
    FT_Byte*  cur;
    FT_Int    embed = 0;
    FT_Error  error = FT_Err_Ok;


    FT_ASSERT( **acur == '{' );

    for ( cur = *acur; cur < limit && error == FT_Err_Ok; cur++ )
    {
      switch ( *cur )
      {
      case '{':
        embed++;
        break;

      case '}':
        embed--;
        if ( embed == 0 )
        {
          cur++;
          goto end;
        }
        break;

      case '(':
        error = skip_literal_string( &cur, limit );
        break;

      case '<':
        error = skip_string( &cur, limit );
        break;

      case '%':
        skip_comment( &cur, limit );
        break;
      }
    }

  end:
    if ( embed != 0 )
      error = FT_THROW( Invalid_File_Format );

    *acur = cur;

    return error;
  }


  /***********************************************************************/
  /*                                                                     */
  /* All exported parsing routines handle leading whitespace and stop at */
  /* the first character which isn't part of the just handled token.     */
  /*                                                                     */
  /***********************************************************************/


  FT_LOCAL_DEF( void )
  ps_parser_skip_PS_token( PS_Parser  parser )
  {
    /* Note: PostScript allows any non-delimiting, non-whitespace        */
    /*       character in a name (PS Ref Manual, 3rd ed, p31).           */
    /*       PostScript delimiters are (, ), <, >, [, ], {, }, /, and %. */

    FT_Byte*  cur   = parser->cursor;
    FT_Byte*  limit = parser->limit;
    FT_Error  error = FT_Err_Ok;


    skip_spaces( &cur, limit );             /* this also skips comments */
    if ( cur >= limit )
      goto Exit;

    /* self-delimiting, single-character tokens */
    if ( *cur == '[' || *cur == ']' )
    {
      cur++;
      goto Exit;
    }

    /* skip balanced expressions (procedures and strings) */

    if ( *cur == '{' )                              /* {...} */
    {
      error = skip_procedure( &cur, limit );
      goto Exit;
    }

    if ( *cur == '(' )                              /* (...) */
    {
      error = skip_literal_string( &cur, limit );
      goto Exit;
    }

    if ( *cur == '<' )                              /* <...> */
    {
      if ( cur + 1 < limit && *(cur + 1) == '<' )   /* << */
      {
        cur++;
        cur++;
      }
      else
        error = skip_string( &cur, limit );

      goto Exit;
    }

    if ( *cur == '>' )
    {
      cur++;
      if ( cur >= limit || *cur != '>' )             /* >> */
      {
        FT_ERROR(( "ps_parser_skip_PS_token:"
                   " unexpected closing delimiter `>'\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }
      cur++;
      goto Exit;
    }

    if ( *cur == '/' )
      cur++;

    /* anything else */
    while ( cur < limit )
    {
      /* *cur might be invalid (e.g., ')' or '}'), but this   */
      /* is handled by the test `cur == parser->cursor' below */
      if ( IS_PS_DELIM( *cur ) )
        break;

      cur++;
    }

  Exit:
    if ( cur < limit && cur == parser->cursor )
    {
      FT_ERROR(( "ps_parser_skip_PS_token:"
                 " current token is `%c' which is self-delimiting\n"
                 "                        "
                 " but invalid at this point\n",
                 *cur ));

      error = FT_THROW( Invalid_File_Format );
    }

    if ( cur > limit )
      cur = limit;

    parser->error  = error;
    parser->cursor = cur;
  }


  FT_LOCAL_DEF( void )
  ps_parser_skip_spaces( PS_Parser  parser )
  {
    skip_spaces( &parser->cursor, parser->limit );
  }


  /* `token' here means either something between balanced delimiters */
  /* or the next token; the delimiters are not removed.              */

  FT_LOCAL_DEF( void )
  ps_parser_to_token( PS_Parser  parser,
                      T1_Token   token )
  {
    FT_Byte*  cur;
    FT_Byte*  limit;
    FT_Int    embed;


    token->type  = T1_TOKEN_TYPE_NONE;
    token->start = NULL;
    token->limit = NULL;

    /* first of all, skip leading whitespace */
    ps_parser_skip_spaces( parser );

    cur   = parser->cursor;
    limit = parser->limit;

    if ( cur >= limit )
      return;

    switch ( *cur )
    {
      /************* check for literal string *****************/
    case '(':
      token->type  = T1_TOKEN_TYPE_STRING;
      token->start = cur;

      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )
        token->limit = cur;
      break;

      /************* check for programs/array *****************/
    case '{':
      token->type  = T1_TOKEN_TYPE_ARRAY;
      token->start = cur;

      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )
        token->limit = cur;
      break;

      /************* check for table/array ********************/
      /* XXX: in theory we should also look for "<<"          */
      /*      since this is semantically equivalent to "[";   */
      /*      in practice it doesn't matter (?)               */
    case '[':
      token->type  = T1_TOKEN_TYPE_ARRAY;
      embed        = 1;
      token->start = cur++;

      /* we need this to catch `[ ]' */
      parser->cursor = cur;
      ps_parser_skip_spaces( parser );
      cur = parser->cursor;

      while ( cur < limit && !parser->error )
      {
        /* XXX: this is wrong because it does not      */
        /*      skip comments, procedures, and strings */
        if ( *cur == '[' )
          embed++;
        else if ( *cur == ']' )
        {
          embed--;
          if ( embed <= 0 )
          {
            token->limit = ++cur;
            break;
          }
        }

        parser->cursor = cur;
        ps_parser_skip_PS_token( parser );
        /* we need this to catch `[XXX ]' */
        ps_parser_skip_spaces  ( parser );
        cur = parser->cursor;
      }
      break;

      /* ************ otherwise, it is any token **************/
    default:
      token->start = cur;
      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;
      ps_parser_skip_PS_token( parser );
      cur = parser->cursor;
      if ( !parser->error )
        token->limit = cur;
    }

    if ( !token->limit )
    {
      token->start = NULL;
      token->type  = T1_TOKEN_TYPE_NONE;
    }

    parser->cursor = cur;
  }


  /* NB: `tokens' can be NULL if we only want to count */
  /* the number of array elements                      */

  FT_LOCAL_DEF( void )
  ps_parser_to_token_array( PS_Parser  parser,
                            T1_Token   tokens,
                            FT_UInt    max_tokens,
                            FT_Int*    pnum_tokens )
  {
    T1_TokenRec  master;


    *pnum_tokens = -1;

    /* this also handles leading whitespace */
    ps_parser_to_token( parser, &master );

    if ( master.type == T1_TOKEN_TYPE_ARRAY )
    {
      FT_Byte*  old_cursor = parser->cursor;
      FT_Byte*  old_limit  = parser->limit;
      T1_Token  cur        = tokens;
      T1_Token  limit      = cur + max_tokens;


      /* don't include outermost delimiters */
      parser->cursor = master.start + 1;
      parser->limit  = master.limit - 1;

      while ( parser->cursor < parser->limit )
      {
        T1_TokenRec  token;


        ps_parser_to_token( parser, &token );
        if ( !token.type )
          break;

        if ( tokens && cur < limit )
          *cur = token;

        cur++;
      }

      *pnum_tokens = (FT_Int)( cur - tokens );

      parser->cursor = old_cursor;
      parser->limit  = old_limit;
    }
  }


  /* first character must be a delimiter or a part of a number */
  /* NB: `coords' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_coords'            */

  static FT_Int
  ps_tocoordarray( FT_Byte*  *acur,
                   FT_Byte*   limit,
                   FT_Int     max_coords,
                   FT_Short*  coords )
  {
    FT_Byte*  cur   = *acur;
    FT_Int    count = 0;
    FT_Byte   c, ender;


    if ( cur >= limit )
      goto Exit;

    /* check for the beginning of an array; otherwise, only one number */
    /* will be read                                                    */
    c     = *cur;
    ender = 0;

    if ( c == '[' )
      ender = ']';
    else if ( c == '{' )
      ender = '}';

    if ( ender )
      cur++;

    /* now, read the coordinates */
    while ( cur < limit )
    {
      FT_Short  dummy;
      FT_Byte*  old_cur;


      /* skip whitespace in front of data */
      skip_spaces( &cur, limit );
      if ( cur >= limit )
        goto Exit;

      if ( *cur == ender )
      {
        cur++;
        break;
      }

      old_cur = cur;

      if ( coords && count >= max_coords )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( coords ? &coords[count] : &dummy ) =
        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;

      if ( !ender )
        break;
    }

  Exit:
    *acur = cur;
    return count;
  }


  /* first character must be a delimiter or a part of a number */
  /* NB: `values' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_values'            */
  /*                                                           */
  /* return number of successfully parsed values               */

  static FT_Int
  ps_tofixedarray( FT_Byte*  *acur,
                   FT_Byte*   limit,
                   FT_Int     max_values,
                   FT_Fixed*  values,
                   FT_Int     power_ten )
  {
    FT_Byte*  cur   = *acur;
    FT_Int    count = 0;
    FT_Byte   c, ender;


    if ( cur >= limit )
      goto Exit;

    /* Check for the beginning of an array.  Otherwise, only one number */
    /* will be read.                                                    */
    c     = *cur;
    ender = 0;

    if ( c == '[' )
      ender = ']';
    else if ( c == '{' )
      ender = '}';

    if ( ender )
      cur++;

    /* now, read the values */
    while ( cur < limit )
    {
      FT_Fixed  dummy;
      FT_Byte*  old_cur;


      /* skip whitespace in front of data */
      skip_spaces( &cur, limit );
      if ( cur >= limit )
        goto Exit;

      if ( *cur == ender )
      {
        cur++;
        break;
      }

      old_cur = cur;

      if ( values && count >= max_values )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( values ? &values[count] : &dummy ) =
        PS_Conv_ToFixed( &cur, limit, power_ten );

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;

      if ( !ender )
        break;
    }

  Exit:
    *acur = cur;
    return count;
  }


#if 0

  static FT_String*
  ps_tostring( FT_Byte**  cursor,
               FT_Byte*   limit,
               FT_Memory  memory )
  {
    FT_Byte*    cur = *cursor;
    FT_UInt     len = 0;
    FT_Int      count;
    FT_String*  result;
    FT_Error    error;


    /* XXX: some stupid fonts have a `Notice' or `Copyright' string     */
    /*      that simply doesn't begin with an opening parenthesis, even */
    /*      though they have a closing one!  E.g. "amuncial.pfb"        */
    /*                                                                  */
    /*      We must deal with these ill-fated cases there.  Note that   */
    /*      these fonts didn't work with the old Type 1 driver as the   */
    /*      notice/copyright was not recognized as a valid string token */
    /*      and made the old token parser commit errors.                */

    while ( cur < limit && ( *cur == ' ' || *cur == '\t' ) )
      cur++;
    if ( cur + 1 >= limit )
      return 0;

    if ( *cur == '(' )
      cur++;  /* skip the opening parenthesis, if there is one */

    *cursor = cur;
    count   = 0;

    /* then, count its length */
    for ( ; cur < limit; cur++ )
    {
      if ( *cur == '(' )
        count++;

      else if ( *cur == ')' )
      {
        count--;
        if ( count < 0 )
          break;
      }
    }

    len = (FT_UInt)( cur - *cursor );
    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )
      return 0;

    /* now copy the string */
    FT_MEM_COPY( result, *cursor, len );
    result[len] = '\0';
    *cursor = cur;
    return result;
  }

#endif /* 0 */


  static int
  ps_tobool( FT_Byte*  *acur,
             FT_Byte*   limit )
  {
    FT_Byte*  cur    = *acur;
    FT_Bool   result = 0;


    /* return 1 if we find `true', 0 otherwise */
    if ( cur + 3 < limit &&
         cur[0] == 't'   &&
         cur[1] == 'r'   &&
         cur[2] == 'u'   &&
         cur[3] == 'e'   )
    {
      result = 1;
      cur   += 5;
    }
    else if ( cur + 4 < limit &&
              cur[0] == 'f'   &&
              cur[1] == 'a'   &&
              cur[2] == 'l'   &&
              cur[3] == 's'   &&
              cur[4] == 'e'   )
    {
      result = 0;
      cur   += 6;
    }

    *acur = cur;
    return result;
  }


  /* load a simple field (i.e. non-table) into the current list of objects */

  FT_LOCAL_DEF( FT_Error )
  ps_parser_load_field( PS_Parser       parser,
                        const T1_Field  field,
                        void**          objects,
                        FT_UInt         max_objects,
                        FT_ULong*       pflags )
  {
    T1_TokenRec   token;
    FT_Byte*      cur;
    FT_Byte*      limit;
    FT_UInt       count;
    FT_UInt       idx;
    FT_Error      error;
    T1_FieldType  type;


    /* this also skips leading whitespace */
    ps_parser_to_token( parser, &token );
    if ( !token.type )
      goto Fail;

    count = 1;
    idx   = 0;
    cur   = token.start;
    limit = token.limit;

    type = field->type;

    /* we must detect arrays in /FontBBox */
    if ( type == T1_FIELD_TYPE_BBOX )
    {
      T1_TokenRec  token2;
      FT_Byte*     old_cur   = parser->cursor;
      FT_Byte*     old_limit = parser->limit;


      /* don't include delimiters */
      parser->cursor = token.start + 1;
      parser->limit  = token.limit - 1;

      ps_parser_to_token( parser, &token2 );
      parser->cursor = old_cur;
      parser->limit  = old_limit;

      if ( token2.type == T1_TOKEN_TYPE_ARRAY )
      {
        type = T1_FIELD_TYPE_MM_BBOX;
        goto FieldArray;
      }
    }
    else if ( token.type == T1_TOKEN_TYPE_ARRAY )
    {
      count = max_objects;

    FieldArray:
      /* if this is an array and we have no blend, an error occurs */
      if ( max_objects == 0 )
        goto Fail;

      idx = 1;

      /* don't include delimiters */
      cur++;
      limit--;
    }

    for ( ; count > 0; count--, idx++ )
    {
      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;
      FT_Long     val;
      FT_String*  string = NULL;


      skip_spaces( &cur, limit );

      switch ( type )
      {
      case T1_FIELD_TYPE_BOOL:
        val = ps_tobool( &cur, limit );
        goto Store_Integer;

      case T1_FIELD_TYPE_FIXED:
        val = PS_Conv_ToFixed( &cur, limit, 0 );
        goto Store_Integer;

      case T1_FIELD_TYPE_FIXED_1000:
        val = PS_Conv_ToFixed( &cur, limit, 3 );
        goto Store_Integer;

      case T1_FIELD_TYPE_INTEGER:
        val = PS_Conv_ToInt( &cur, limit );
        /* fall through */

      Store_Integer:
        switch ( field->size )
        {
        case (8 / FT_CHAR_BIT):
          *(FT_Byte*)q = (FT_Byte)val;
          break;

        case (16 / FT_CHAR_BIT):
          *(FT_UShort*)q = (FT_UShort)val;
          break;

        case (32 / FT_CHAR_BIT):
          *(FT_UInt32*)q = (FT_UInt32)val;
          break;

        default:                /* for 64-bit systems */
          *(FT_Long*)q = val;
        }
        break;

      case T1_FIELD_TYPE_STRING:
      case T1_FIELD_TYPE_KEY:
        {
          FT_Memory  memory = parser->memory;
          FT_UInt    len    = (FT_UInt)( limit - cur );


          if ( cur >= limit )
            break;

          /* we allow both a string or a name   */
          /* for cases like /FontName (foo) def */
          if ( token.type == T1_TOKEN_TYPE_KEY )
          {
            /* don't include leading `/' */
            len--;
            cur++;
          }
          else if ( token.type == T1_TOKEN_TYPE_STRING )
          {
            /* don't include delimiting parentheses    */
            /* XXX we don't handle <<...>> here        */
            /* XXX should we convert octal escapes?    */
            /*     if so, what encoding should we use? */
            cur++;
            len -= 2;
          }
          else
          {
            FT_ERROR(( "ps_parser_load_field:"
                       " expected a name or string\n"
                       "                     "
                       " but found token of type %d instead\n",
                       token.type ));
            error = FT_THROW( Invalid_File_Format );
            goto Exit;
          }

          /* for this to work (FT_String**)q must have been */
          /* initialized to NULL                            */
          if ( *(FT_String**)q )
          {
            FT_TRACE0(( "ps_parser_load_field: overwriting field %s\n",
                        field->ident ));
            FT_FREE( *(FT_String**)q );
            *(FT_String**)q = NULL;
          }

          if ( FT_ALLOC( string, len + 1 ) )
            goto Exit;

          FT_MEM_COPY( string, cur, len );
          string[len] = 0;

          *(FT_String**)q = string;
        }
        break;

      case T1_FIELD_TYPE_BBOX:
        {
          FT_Fixed  temp[4];
          FT_BBox*  bbox = (FT_BBox*)q;
          FT_Int    result;


          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );

          if ( result < 4 )
          {
            FT_ERROR(( "ps_parser_load_field:"
                       " expected four integers in bounding box\n" ));
            error = FT_THROW( Invalid_File_Format );
            goto Exit;
          }

          bbox->xMin = FT_RoundFix( temp[0] );
          bbox->yMin = FT_RoundFix( temp[1] );
          bbox->xMax = FT_RoundFix( temp[2] );
          bbox->yMax = FT_RoundFix( temp[3] );
        }
        break;

      case T1_FIELD_TYPE_MM_BBOX:
        {
          FT_Memory  memory = parser->memory;
          FT_Fixed*  temp   = NULL;
          FT_Int     result;
          FT_UInt    i;


          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )
            goto Exit;

          for ( i = 0; i < 4; i++ )
          {
            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,
                                      temp + i * max_objects, 0 );
            if ( result < 0 || (FT_UInt)result < max_objects )
            {
              FT_ERROR(( "ps_parser_load_field:"
                         " expected %d integer%s in the %s subarray\n"
                         "                     "
                         " of /FontBBox in the /Blend dictionary\n",
                         max_objects, max_objects > 1 ? "s" : "",
                         i == 0 ? "first"
                                : ( i == 1 ? "second"
                                           : ( i == 2 ? "third"
                                                      : "fourth" ) ) ));
              error = FT_THROW( Invalid_File_Format );

              FT_FREE( temp );
              goto Exit;
            }

            skip_spaces( &cur, limit );
          }

          for ( i = 0; i < max_objects; i++ )
          {
            FT_BBox*  bbox = (FT_BBox*)objects[i];


            bbox->xMin = FT_RoundFix( temp[i                  ] );
            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );
            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );
            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );
          }

          FT_FREE( temp );
        }
        break;

      default:
        /* an error occurred */
        goto Fail;
      }
    }

#if 0  /* obsolete -- keep for reference */
    if ( pflags )
      *pflags |= 1L << field->flag_bit;
#else
    FT_UNUSED( pflags );
#endif

    error = FT_Err_Ok;

  Exit:
    return error;

  Fail:
    error = FT_THROW( Invalid_File_Format );
    goto Exit;
  }


#define T1_MAX_TABLE_ELEMENTS  32


  FT_LOCAL_DEF( FT_Error )
  ps_parser_load_field_table( PS_Parser       parser,
                              const T1_Field  field,
                              void**          objects,
                              FT_UInt         max_objects,
                              FT_ULong*       pflags )
  {
    T1_TokenRec  elements[T1_MAX_TABLE_ELEMENTS];
    T1_Token     token;
    FT_Int       num_elements;
    FT_Error     error = FT_Err_Ok;
    FT_Byte*     old_cursor;
    FT_Byte*     old_limit;
    T1_FieldRec  fieldrec = *(T1_Field)field;


    fieldrec.type = T1_FIELD_TYPE_INTEGER;
    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||
         field->type == T1_FIELD_TYPE_BBOX        )
      fieldrec.type = T1_FIELD_TYPE_FIXED;

    ps_parser_to_token_array( parser, elements,
                              T1_MAX_TABLE_ELEMENTS, &num_elements );
    if ( num_elements < 0 )
    {
      error = FT_ERR( Ignore );
      goto Exit;
    }
    if ( (FT_UInt)num_elements > field->array_max )
      num_elements = (FT_Int)field->array_max;

    old_cursor = parser->cursor;
    old_limit  = parser->limit;

    /* we store the elements count if necessary;           */
    /* we further assume that `count_offset' can't be zero */
    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )
      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =
        (FT_Byte)num_elements;

    /* we now load each element, adjusting the field.offset on each one */
    token = elements;
    for ( ; num_elements > 0; num_elements--, token++ )
    {
      parser->cursor = token->start;
      parser->limit  = token->limit;

      error = ps_parser_load_field( parser,
                                    &fieldrec,
                                    objects,
                                    max_objects,
                                    0 );
      if ( error )
        break;

      fieldrec.offset += fieldrec.size;
    }

#if 0  /* obsolete -- keep for reference */
    if ( pflags )
      *pflags |= 1L << field->flag_bit;
#else
    FT_UNUSED( pflags );
#endif

    parser->cursor = old_cursor;
    parser->limit  = old_limit;

  Exit:
    return error;
  }


  FT_LOCAL_DEF( FT_Long )
  ps_parser_to_int( PS_Parser  parser )
  {
    ps_parser_skip_spaces( parser );
    return PS_Conv_ToInt( &parser->cursor, parser->limit );
  }


  /* first character must be `<' if `delimiters' is non-zero */

  FT_LOCAL_DEF( FT_Error )
  ps_parser_to_bytes( PS_Parser  parser,
                      FT_Byte*   bytes,
                      FT_Offset  max_bytes,
                      FT_ULong*  pnum_bytes,
                      FT_Bool    delimiters )
  {
    FT_Error  error = FT_Err_Ok;
    FT_Byte*  cur;


    ps_parser_skip_spaces( parser );
    cur = parser->cursor;

    if ( cur >= parser->limit )
      goto Exit;

    if ( delimiters )
    {
      if ( *cur != '<' )
      {
        FT_ERROR(( "ps_parser_to_bytes: Missing starting delimiter `<'\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      cur++;
    }

    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,
                                          parser->limit,
                                          bytes,
                                          max_bytes );

    if ( delimiters )
    {
      if ( cur < parser->limit && *cur != '>' )
      {
        FT_ERROR(( "ps_parser_to_bytes: Missing closing delimiter `>'\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      cur++;
    }

    parser->cursor = cur;

  Exit:
    return error;
  }


  FT_LOCAL_DEF( FT_Fixed )
  ps_parser_to_fixed( PS_Parser  parser,
                      FT_Int     power_ten )
  {
    ps_parser_skip_spaces( parser );
    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );
  }


  FT_LOCAL_DEF( FT_Int )
  ps_parser_to_coord_array( PS_Parser  parser,
                            FT_Int     max_coords,
                            FT_Short*  coords )
  {
    ps_parser_skip_spaces( parser );
    return ps_tocoordarray( &parser->cursor, parser->limit,
                            max_coords, coords );
  }


  FT_LOCAL_DEF( FT_Int )
  ps_parser_to_fixed_array( PS_Parser  parser,
                            FT_Int     max_values,
                            FT_Fixed*  values,
                            FT_Int     power_ten )
  {
    ps_parser_skip_spaces( parser );
    return ps_tofixedarray( &parser->cursor, parser->limit,
                            max_values, values, power_ten );
  }


#if 0

  FT_LOCAL_DEF( FT_String* )
  T1_ToString( PS_Parser  parser )
  {
    return ps_tostring( &parser->cursor, parser->limit, parser->memory );
  }


  FT_LOCAL_DEF( FT_Bool )
  T1_ToBool( PS_Parser  parser )
  {
    return ps_tobool( &parser->cursor, parser->limit );
  }

#endif /* 0 */


  FT_LOCAL_DEF( void )
  ps_parser_init( PS_Parser  parser,
                  FT_Byte*   base,
                  FT_Byte*   limit,
                  FT_Memory  memory )
  {
    parser->error  = FT_Err_Ok;
    parser->base   = base;
    parser->limit  = limit;
    parser->cursor = base;
    parser->memory = memory;
    parser->funcs  = ps_parser_funcs;
  }


  FT_LOCAL_DEF( void )
  ps_parser_done( PS_Parser  parser )
  {
    FT_UNUSED( parser );
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                            T1 BUILDER                         *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    t1_builder_init                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given glyph builder.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    builder :: A pointer to the glyph builder to initialize.           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face    :: The current face object.                                */
  /*                                                                       */
  /*    size    :: The current size object.                                */
  /*                                                                       */
  /*    glyph   :: The current glyph object.                               */
  /*                                                                       */
  /*    hinting :: Whether hinting should be applied.                      */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  t1_builder_init( T1_Builder    builder,
                   FT_Face       face,
                   FT_Size       size,
                   FT_GlyphSlot  glyph,
                   FT_Bool       hinting )
  {
    builder->parse_state = T1_Parse_Start;
    builder->load_points = 1;

    builder->face   = face;
    builder->glyph  = glyph;
    builder->memory = face->memory;

    if ( glyph )
    {
      FT_GlyphLoader  loader = glyph->internal->loader;


      builder->loader  = loader;
      builder->base    = &loader->base.outline;
      builder->current = &loader->current.outline;
      FT_GlyphLoader_Rewind( loader );

      builder->hints_globals = size->internal;
      builder->hints_funcs   = NULL;

      if ( hinting )
        builder->hints_funcs = glyph->internal->glyph_hints;
    }

    builder->pos_x = 0;
    builder->pos_y = 0;

    builder->left_bearing.x = 0;
    builder->left_bearing.y = 0;
    builder->advance.x      = 0;
    builder->advance.y      = 0;

    builder->funcs = t1_builder_funcs;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    t1_builder_done                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a given glyph builder.  Its contents can still be used   */
  /*    after the call, but the function saves important information       */
  /*    within the corresponding glyph slot.                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    builder :: A pointer to the glyph builder to finalize.             */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  t1_builder_done( T1_Builder  builder )
  {
    FT_GlyphSlot  glyph = builder->glyph;


    if ( glyph )
      glyph->outline = *builder->base;
  }


  /* check that there is enough space for `count' more points */
  FT_LOCAL_DEF( FT_Error )
  t1_builder_check_points( T1_Builder  builder,
                           FT_Int      count )
  {
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
  }


  /* add a new point, do not check space */
  FT_LOCAL_DEF( void )
  t1_builder_add_point( T1_Builder  builder,
                        FT_Pos      x,
                        FT_Pos      y,
                        FT_Byte     flag )
  {
    FT_Outline*  outline = builder->current;


    if ( builder->load_points )
    {
      FT_Vector*  point   = outline->points + outline->n_points;
      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;


      point->x = FIXED_TO_INT( x );
      point->y = FIXED_TO_INT( y );
      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );
    }
    outline->n_points++;
  }


  /* check space for a new on-curve point, then add it */
  FT_LOCAL_DEF( FT_Error )
  t1_builder_add_point1( T1_Builder  builder,
                         FT_Pos      x,
                         FT_Pos      y )
  {
    FT_Error  error;


    error = t1_builder_check_points( builder, 1 );
    if ( !error )
      t1_builder_add_point( builder, x, y, 1 );

    return error;
  }


  /* check space for a new contour, then add it */
  FT_LOCAL_DEF( FT_Error )
  t1_builder_add_contour( T1_Builder  builder )
  {
    FT_Outline*  outline = builder->current;
    FT_Error     error;


    /* this might happen in invalid fonts */
    if ( !outline )
    {
      FT_ERROR(( "t1_builder_add_contour: no outline to add points to\n" ));
      return FT_THROW( Invalid_File_Format );
    }

    if ( !builder->load_points )
    {
      outline->n_contours++;
      return FT_Err_Ok;
    }

    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
    if ( !error )
    {
      if ( outline->n_contours > 0 )
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );

      outline->n_contours++;
    }

    return error;
  }


  /* if a path was begun, add its first on-curve point */
  FT_LOCAL_DEF( FT_Error )
  t1_builder_start_point( T1_Builder  builder,
                          FT_Pos      x,
                          FT_Pos      y )
  {
    FT_Error  error = FT_ERR( Invalid_File_Format );


    /* test whether we are building a new contour */

    if ( builder->parse_state == T1_Parse_Have_Path )
      error = FT_Err_Ok;
    else
    {
      builder->parse_state = T1_Parse_Have_Path;
      error = t1_builder_add_contour( builder );
      if ( !error )
        error = t1_builder_add_point1( builder, x, y );
    }

    return error;
  }


  /* close the current contour */
  FT_LOCAL_DEF( void )
  t1_builder_close_contour( T1_Builder  builder )
  {
    FT_Outline*  outline = builder->current;
    FT_Int       first;


    if ( !outline )
      return;

    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;

    /* in malformed fonts it can happen that a contour was started */
    /* but no points were added                                    */
    if ( outline->n_contours && first == outline->n_points )
    {
      outline->n_contours--;
      return;
    }

    /* We must not include the last point in the path if it */
    /* is located on the first point.                       */
    if ( outline->n_points > 1 )
    {
      FT_Vector*  p1      = outline->points + first;
      FT_Vector*  p2      = outline->points + outline->n_points - 1;
      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;


      /* `delete' last point only if it coincides with the first */
      /* point and it is not a control point (which can happen). */
      if ( p1->x == p2->x && p1->y == p2->y )
        if ( *control == FT_CURVE_TAG_ON )
          outline->n_points--;
    }

    if ( outline->n_contours > 0 )
    {
      /* Don't add contours only consisting of one point, i.e.,  */
      /* check whether the first and the last point is the same. */
      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                            OTHER                              *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL_DEF( void )
  t1_decrypt( FT_Byte*   buffer,
              FT_Offset  length,
              FT_UShort  seed )
  {
    PS_Conv_EexecDecode( &buffer,
                         buffer + length,
                         buffer,
                         length,
                         &seed );
  }


/* END */
@


1.6
log
@first cut at a quickmerge
@
text
@d1721 8
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
d84 1
a84 1
    table->block     = 0;
d116 2
a117 2
  reallocate_t1_table( PS_Table  table,
                       FT_Long   new_size )
d141 1
a141 1
    return PSaux_Err_Ok;
d168 4
a171 4
  ps_table_add( PS_Table    table,
                FT_Int      idx,
                void*       object,
                FT_PtrDist  length )
d176 1
a176 7
      return PSaux_Err_Invalid_Argument;
    }

    if ( length < 0 )
    {
      FT_ERROR(( "ps_table_add: invalid length\n" ));
      return PSaux_Err_Invalid_Argument;
d182 3
a184 3
      FT_Error   error;
      FT_Offset  new_size = table->capacity;
      FT_Long    in_offset;
d187 2
a188 2
      in_offset = (FT_Long)((FT_Byte*)object - table->block);
      if ( (FT_ULong)in_offset >= table->capacity )
d213 1
a213 1
    return PSaux_Err_Ok;
d338 1
a338 1
    FT_Error      error = PSaux_Err_Invalid_File_Format;
d347 1
a347 1
      ++cur;
d373 1
a373 1
          ++cur;
d378 1
a378 1
          for ( i = 0; i < 3 && cur < limit; ++i )
d383 1
a383 1
            ++cur;
d394 1
a394 1
          error = PSaux_Err_Ok;
d413 1
a413 1
    FT_Error  err =  PSaux_Err_Ok;
d430 1
a430 1
      err = PSaux_Err_Invalid_File_Format;
d453 1
a453 1
    FT_Error  error = PSaux_Err_Ok;
d458 1
a458 1
    for ( cur = *acur; cur < limit && error == PSaux_Err_Ok; ++cur )
d463 1
a463 1
        ++embed;
d467 1
a467 1
        --embed;
d470 1
a470 1
          ++cur;
d491 1
a491 1
      error = PSaux_Err_Invalid_File_Format;
d516 1
a516 1
    FT_Error  error = PSaux_Err_Ok;
d564 1
a564 1
        error = PSaux_Err_Invalid_File_Format;
d586 1
a586 1
    if ( cur == parser->cursor )
d594 1
a594 1
      error = PSaux_Err_Invalid_File_Format;
d597 3
d625 2
a626 2
    token->start = 0;
    token->limit = 0;
d644 1
a644 1
      if ( skip_literal_string( &cur, limit ) == PSaux_Err_Ok )
d653 1
a653 1
      if ( skip_procedure( &cur, limit ) == PSaux_Err_Ok )
d698 1
a698 1
      token->type  = ( *cur == '/' ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY );
d707 1
a707 1
      token->start = 0;
d753 1
a753 1
        if ( tokens != NULL && cur < limit )
d818 1
a818 1
      if ( coords != NULL && count >= max_coords )
d823 1
a823 1
      *( coords != NULL ? &coords[count] : &dummy ) =
d847 2
d898 1
a898 1
      if ( values != NULL && count >= max_values )
d903 1
a903 1
      *( values != NULL ? &values[count] : &dummy ) =
d932 1
a932 1
    FT_PtrDist  len = 0;
d972 1
a972 1
    len = cur - *cursor;
d1029 7
a1035 6
    T1_TokenRec  token;
    FT_Byte*     cur;
    FT_Byte*     limit;
    FT_UInt      count;
    FT_UInt      idx;
    FT_Error     error;
d1048 2
d1051 1
a1051 1
    if ( field->type == T1_FIELD_TYPE_BBOX )
d1067 2
d1070 1
d1074 2
d1081 1
a1081 2
      count = max_objects;
      idx   = 1;
d1090 1
a1090 1
      FT_Byte*    q = (FT_Byte*)objects[idx] + field->offset;
d1092 1
a1092 1
      FT_String*  string;
d1097 1
a1097 1
      switch ( field->type )
d1169 1
a1169 1
            error = PSaux_Err_Invalid_File_Format;
d1175 1
a1175 1
          if ( *(FT_String**)q != NULL )
d1202 1
a1202 1
          if ( result < 0 )
d1206 1
a1206 1
            error = PSaux_Err_Invalid_File_Format;
d1217 50
d1280 1
a1280 1
    error = PSaux_Err_Ok;
d1286 1
a1286 1
    error = PSaux_Err_Invalid_File_Format;
d1304 1
a1304 1
    FT_Error     error = PSaux_Err_Ok;
d1319 1
a1319 1
      error = PSaux_Err_Ignore;
d1323 1
a1323 1
      num_elements = field->array_max;
d1340 9
a1348 1
      ps_parser_load_field( parser, &fieldrec, objects, max_objects, 0 );
d1381 1
a1381 1
                      FT_Long*   pnum_bytes,
d1384 1
a1384 1
    FT_Error  error = PSaux_Err_Ok;
d1399 1
a1399 1
        error = PSaux_Err_Invalid_File_Format;
d1416 1
a1416 1
        error = PSaux_Err_Invalid_File_Format;
d1486 1
a1486 1
    parser->error  = PSaux_Err_Ok;
d1555 1
a1555 1
      builder->hints_funcs   = 0;
d1655 7
d1665 1
a1665 1
      return PSaux_Err_Ok;
d1688 1
a1688 1
    FT_Error  error = PSaux_Err_Invalid_File_Format;
d1694 2
a1695 2
      error = PSaux_Err_Ok;
    else if ( builder->parse_state == T1_Parse_Have_Moveto )
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d22 1
d179 6
d189 1
a189 1
      FT_Offset  new_size  = table->capacity;
d386 1
a386 1
            if ( ! IS_OCTAL_DIGIT( *cur ) )
d568 2
a569 2
        FT_ERROR(( "ps_parser_skip_PS_token: "
                   "unexpected closing delimiter `>'\n" ));
d594 4
a597 3
      FT_ERROR(( "ps_parser_skip_PS_token: "
                 "current token is `%c', which is self-delimiting "
                 "but invalid at this point\n",
d1158 4
a1161 2
            FT_ERROR(( "ps_parser_load_field: expected a name or string "
                       "but found token of type %d instead\n",
d1198 2
a1199 2
            FT_ERROR(( "ps_parser_load_field: "
                       "expected four integers in bounding box\n" ));
d1272 3
a1274 2
    /* we store the elements count if necessary */
    if ( field->type != T1_FIELD_TYPE_BBOX )
d1316 1
a1316 1
                      FT_Long    max_bytes,
d1558 2
a1559 7
      if ( builder->shift )
      {
        x >>= 16;
        y >>= 16;
      }
      point->x = x;
      point->y = y;
a1560 2

      builder->last = *point;
d1641 1
d1647 5
a1651 2
    /* XXXX: We must not include the last point in the path if it */
    /*       is located on the first point.                       */
a1653 1
      FT_Int      first   = 0;
a1658 6
      if ( outline->n_contours > 1 )
      {
        first = outline->contours[outline->n_contours - 2] + 1;
        p1    = outline->points + first;
      }

d1667 12
a1678 2
      outline->contours[outline->n_contours - 1] =
        (short)( outline->n_points - 1 );
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d172 1
a172 1
    if ( idx < 0 || idx > table->max_elems )
a1485 6
    if ( size )
    {
      builder->scale_x = size->metrics.x_scale;
      builder->scale_y = size->metrics.y_scale;
    }

@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d30 10
d131 1
a131 1
    if (old_base )
d325 1
a325 1
  /* first character must be `(' */
d327 5
a331 1
  static void
d335 4
a338 2
    FT_Byte*  cur   = *acur;
    FT_Int    embed = 0;
d343 44
a386 3
      if ( *cur == '\\' )
        cur++;
      else if ( *cur == '(' )
d388 1
a388 1
      else if ( *cur == ')' )
d393 1
a393 1
          cur++;
a396 1
      cur++;
d400 2
d407 3
a409 2
  static void
  skip_string( PS_Parser  parser )
d411 2
a412 2
    FT_Byte*  cur   = parser->cursor;
    FT_Byte*  limit = parser->limit;
d429 1
a429 1
      parser->error = PSaux_Err_Invalid_File_Format;
d434 61
a494 1
    parser->cursor = cur;
d515 1
d523 1
a523 2
    if ( *cur == '[' || *cur == ']' ||
         *cur == '{' || *cur == '}' )
d529 8
d539 1
a539 1
      skip_literal_string( &cur, limit );
a548 1
        goto Exit;
d550 4
a553 3
      parser->cursor = cur;
      skip_string( parser );
      return;
d563 1
a563 1
        parser->error = PSaux_Err_Invalid_File_Format;
d576 3
a578 8
      if ( *cur == ')' )
      {
        FT_ERROR(( "ps_parser_skip_PS_token: "
                   "unexpected closing delimiter `)'\n" ));
        parser->error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }
      else if ( IS_PS_DELIM( *cur ) )
d585 11
a615 1
    FT_Byte   starter, ender;
d638 2
a639 2
      skip_literal_string( &cur, limit );
      if ( cur < limit )
d645 6
a650 3
      token->type = T1_TOKEN_TYPE_ARRAY;
      ender = '}';
      goto Lookup_Ender;
d653 3
d657 1
a657 5
      token->type = T1_TOKEN_TYPE_ARRAY;
      ender = ']';
      /* fall through */

    Lookup_Ender:
a658 1
      starter      = *cur;
d668 3
a670 1
        if ( *cur == starter )
d672 1
a672 1
        else if ( *cur == ender )
d693 1
a693 1
      token->type  = T1_TOKEN_TYPE_ANY;
d710 3
d748 1
a748 1
        if ( cur < limit )
d763 2
d787 1
a787 2

    if ( c == '{' )
d796 4
d805 1
a805 4
      if ( count >= max_coords )
        break;

      if ( c == ender )
d811 8
a818 1
      coords[count] =
d820 8
a827 1
      count++;
d840 2
d865 1
a865 2

    if ( c == '{' )
d874 4
d883 1
a883 4
      if ( count >= max_values )
        break;

      if ( c == ender )
d889 17
a905 2
      values[count] = PS_Conv_ToFixed( &cur, limit, power_ten );
      count++;
d1131 3
a1133 1
          if ( field->type == T1_FIELD_TYPE_KEY )
d1139 1
a1139 1
          else
d1141 4
a1144 1
            /* don't include delimiting parentheses */
d1148 18
d1181 2
d1184 1
d1186 7
a1192 1
          (void)ps_tofixedarray( &token.start, token.limit, 4, temp, 0 );
d1202 1
a1202 1
        /* an error occured */
a1243 1
#if 1
d1245 2
a1246 1
    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY )
a1247 1
#endif
d1256 2
a1257 2
    if ( num_elements > T1_MAX_TABLE_ELEMENTS )
      num_elements = T1_MAX_TABLE_ELEMENTS;
d1262 4
a1265 3
    /* we store the elements count */
    *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =
      (FT_Byte)num_elements;
d1311 2
a1312 2
    
    
d1340 1
a1340 1
        FT_ERROR(( "ps_tobytes: Missing closing delimiter `>'\n" ));
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d24 1
d91 3
a93 3
    FT_Long    delta  = (FT_Long)( table->block - old_base );
    FT_Byte**  offset = table->elements;
    FT_Byte**  limit  = offset + table->max_elems;
a269 58
  /* In the PostScript Language Reference Manual (PLRM) the following */
  /* characters are called `whitespace characters'.                   */
#define IS_T1_WHITESPACE( c )  ( (c) == ' '  || (c) == '\t' )
#define IS_T1_LINESPACE( c )   ( (c) == '\r' || (c) == '\n' || (c) == '\f' )
#define IS_T1_NULLSPACE( c )   ( (c) == '\0' )

  /* According to the PLRM all whitespace characters are equivalent, */
  /* except in comments and strings.                                 */
#define IS_T1_SPACE( c )  ( IS_T1_WHITESPACE( c ) || \
                            IS_T1_LINESPACE( c )  || \
                            IS_T1_NULLSPACE( c )  )


  /* The following array is used by various functions to quickly convert */
  /* digits (both decimal and non-decimal) into numbers.                 */

#if 'A' == 65
  /* ASCII */

  static const char ft_char_table[128] =
  {
    /* 0x00 */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
  };

  /* no character >= 0x80 can represent a valid number */
#define OP  >=

#endif /* 'A' == 65 */

#if 'A' == 193
  /* EBCDIC */

  static const char ft_char_table[128] =
  {
    /* 0x80 */
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, -1, -1, -1, -1, -1, -1,
    -1, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1,
    -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, -1, -1, -1, -1, -1, -1,
    -1, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1,
    -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  }

  /* no character < 0x80 can represent a valid number */
#define OP  <

#endif /* 'A' == 193 */

d282 1
a282 1
      if ( IS_T1_LINESPACE( *cur ) )
d300 1
a300 1
      if ( !IS_T1_SPACE( *cur ) )
a357 3
      int  d;


d363 1
a363 5
      if ( *cur OP 0x80 )
        break;

      d = ft_char_table[*cur & 0x7F];
      if ( d < 0 || d >= 16 )
d368 2
d371 1
d434 2
a448 9
      if ( IS_T1_SPACE( *cur )        ||
           *cur == '('                ||
           *cur == '/'                ||
           *cur == '%'                ||
           *cur == '[' || *cur == ']' ||
           *cur == '{' || *cur == '}' ||
           *cur == '<' || *cur == '>' )
        break;

d451 2
d456 2
a623 262
  /* first character must be already part of the number */

  static FT_Long
  ps_radix( FT_Long    radixBase,
            FT_Byte*  *acur,
            FT_Byte*   limit )
  {
    FT_Long   result = 0;
    FT_Byte*  cur    = *acur;


    if ( radixBase < 2 || radixBase > 36 )
      return 0;

    while ( cur < limit )
    {
      int  d;


      if ( *cur OP 0x80 )
        break;

      d = ft_char_table[*cur & 0x7F];
      if ( d < 0 || d >= radixBase )
        break;

      result = result * radixBase + d;

      cur++;
    }

    *acur = cur;

    return result;
  }


  /* first character must be already part of the number */

  static FT_Long
  ps_toint( FT_Byte*  *acur,
            FT_Byte*   limit )
  {
    FT_Long   result = 0;
    FT_Byte*  cur    = *acur;
    FT_Byte   c;


    if ( cur >= limit )
      goto Exit;

    c = *cur;
    if ( c == '-' )
      cur++;

    while ( cur < limit )
    {
      int  d;


      if ( *cur == '#' )
      {
        cur++;
        result = ps_radix( result, &cur, limit );
        break;
      }

      if ( *cur OP 0x80 )
        break;

      d = ft_char_table[*cur & 0x7F];
      if ( d < 0 || d >= 10 )
        break;
      result = result * 10 + d;

      cur++;
    };

    if ( c == '-' )
      result = -result;

  Exit:
    *acur = cur;
    return result;
  }


  /* first character must be `<' if `delimiters' is non-zero */

  static FT_Error
  ps_tobytes( FT_Byte*  *acur,
              FT_Byte*   limit,
              FT_Long    max_bytes,
              FT_Byte*   bytes,
              FT_Long*   pnum_bytes,
              FT_Bool    delimiters )
  {
    FT_Error  error = PSaux_Err_Ok;

    FT_Byte*  cur = *acur;
    FT_Long   n   = 0;


    if ( cur >= limit )
      goto Exit;

    if ( delimiters )
    {
      if ( *cur != '<' )
      {
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    max_bytes = max_bytes * 2;

    for ( n = 0; cur < limit; n++, cur++ )
    {
      int  d;


      if ( n >= max_bytes )
        /* buffer is full */
        goto Exit;

      /* All whitespace characters are ignored. */
      skip_spaces( &cur, limit );
      if ( cur >= limit )
        break;

      if ( *cur OP 0x80 )
        break;

      d = ft_char_table[*cur & 0x7F];
      if ( d < 0 || d >= 16 )
        break;

      /* <f> == <f0> != <0f> */
      bytes[n / 2] = (FT_Byte)( ( n % 2 ) ? bytes[n / 2] + d
                                          : d * 16 );
    }

    if ( delimiters )
    {
      if ( cur < limit && *cur != '>' )
      {
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    *acur = cur;

  Exit:
    *pnum_bytes = ( n + 1 ) / 2;

    return error;
  }


  /* first character must be already part of the number */

  static FT_Long
  ps_tofixed( FT_Byte*  *acur,
              FT_Byte*   limit,
              FT_Long    power_ten )
  {
    FT_Byte*  cur  = *acur;
    FT_Long   num, divider, result;
    FT_Int    sign = 0;


    if ( cur >= limit )
      return 0;

    /* first of all, check the sign */
    if ( *cur == '-' && cur + 1 < limit )
    {
      sign = 1;
      cur++;
    }

    /* then, read the integer part, if any */
    if ( *cur != '.' )
      result = ps_toint( &cur, limit ) << 16;
    else
      result = 0;

    num     = 0;
    divider = 1;

    if ( cur >= limit )
      goto Exit;

    /* read decimal part, if any */
    if ( *cur == '.' && cur + 1 < limit )
    {
      cur++;

      for (;;)
      {
        int  d;


        if ( *cur OP 0x80 )
          break;

        d = ft_char_table[*cur & 0x7F];
        if ( d < 0 || d >= 10 )
          break;

        if ( divider < 10000000L )
        {
          num      = num * 10 + d;
          divider *= 10;
        }

        cur++;
        if ( cur >= limit )
          break;
      }
    }

    /* read exponent, if any */
    if ( cur + 1 < limit && ( *cur == 'e' || *cur == 'E' ) )
    {
      cur++;
      power_ten += ps_toint( &cur, limit );
    }

  Exit:
    /* raise to power of ten if needed */
    while ( power_ten > 0 )
    {
      result = result * 10;
      num    = num * 10;
      power_ten--;
    }

    while ( power_ten < 0 )
    {
      result  = result / 10;
      divider = divider * 10;
      power_ten++;
    }

    if ( num )
      result += FT_DivFix( num, divider );

    if ( sign )
      result = -result;

    *acur = cur;
    return result;
  }


d671 2
a672 1
      coords[count] = (FT_Short)( ps_tofixed( &cur, limit, 0 ) >> 16 );
d733 1
a733 1
      values[count] = ps_tofixed( &cur, limit, power_ten );
d919 1
a919 1
        val = ps_tofixed( &cur, limit, 0 );
d923 1
a923 1
        val = ps_tofixed( &cur, limit, 3 );
d927 1
a927 1
        val = ps_toint( &cur, limit );
d933 1
a933 1
        case 1:
d937 1
a937 1
        case 2:
d941 1
a941 1
        case 4:
d1093 1
a1093 1
    return ps_toint( &parser->cursor, parser->limit );
d1097 2
d1106 4
d1111 38
a1148 6
    return ps_tobytes( &parser->cursor,
                       parser->limit,
                       max_bytes,
                       bytes,
                       pnum_bytes,
                       delimiters );
d1157 1
a1157 1
    return ps_tofixed( &parser->cursor, parser->limit, power_ten );
d1259 1
a1259 1
    builder->path_begun  = 0;
d1330 1
a1330 1
    return FT_GlyphLoader_CheckPoints( builder->loader, count, 0 );
d1396 1
a1396 1
    error = FT_GlyphLoader_CheckPoints( builder->loader, 0, 1 );
d1416 1
a1416 1
    FT_Error  error = 0;
d1420 4
a1423 1
    if ( !builder->path_begun )
d1425 1
a1425 1
      builder->path_begun = 1;
d1430 1
d1442 3
d1487 5
a1491 10
    while ( length > 0 )
    {
      FT_Byte  plain;


      plain     = (FT_Byte)( *buffer ^ ( seed >> 8 ) );
      seed      = (FT_UShort)( ( *buffer + seed ) * 52845U + 22719 );
      *buffer++ = plain;
      length--;
    }
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a23 1
#include "psconv.h"
a28 10
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_psobjs


  /*************************************************************************/
d90 3
a92 3
    FT_PtrDist  delta  = table->block - old_base;
    FT_Byte**   offset = table->elements;
    FT_Byte**   limit  = offset + table->max_elems;
d120 1
a120 1
    if ( old_base )
d269 58
d339 1
a339 1
      if ( IS_PS_NEWLINE( *cur ) )
d357 1
a357 1
      if ( !IS_PS_SPACE( *cur ) )
d372 1
a372 1
#define IS_OCTAL_DIGIT( c ) ( '0' <= (c) && (c) <= '7' )
d374 1
a374 5

  /* first character must be `(';                               */
  /* *acur is positioned at the character after the closing `)' */

  static FT_Error
d378 2
a379 4
    FT_Byte*      cur   = *acur;
    FT_Int        embed = 0;
    FT_Error      error = PSaux_Err_Invalid_File_Format;
    unsigned int  i;
d384 3
a386 44
      FT_Byte  c = *cur;


      ++cur;

      if ( c == '\\' )
      {
        /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
        /* A backslash can introduce three different types              */
        /* of escape sequences:                                         */
        /*   - a special escaped char like \r, \n, etc.                 */
        /*   - a one-, two-, or three-digit octal number                */
        /*   - none of the above in which case the backslash is ignored */

        if ( cur == limit )
          /* error (or to be ignored?) */
          break;

        switch ( *cur )
        {
          /* skip `special' escape */
        case 'n':
        case 'r':
        case 't':
        case 'b':
        case 'f':
        case '\\':
        case '(':
        case ')':
          ++cur;
          break;

        default:
          /* skip octal escape or ignore backslash */
          for ( i = 0; i < 3 && cur < limit; ++i )
          {
            if ( ! IS_OCTAL_DIGIT( *cur ) )
              break;

            ++cur;
          }
        }
      }
      else if ( c == '(' )
d388 1
a388 1
      else if ( c == ')' )
d393 1
a393 1
          error = PSaux_Err_Ok;
d397 1
a400 2

    return error;
d406 2
a407 3
  static FT_Error
  skip_string( FT_Byte*  *acur,
               FT_Byte*   limit )
d409 2
a410 2
    FT_Byte*  cur = *acur;
    FT_Error  err =  PSaux_Err_Ok;
d415 3
d423 5
a427 1
      if ( !IS_PS_XDIGIT( *cur ) )
d432 1
a432 4
    {
      FT_ERROR(( "skip_string: missing closing delimiter `>'\n" ));
      err = PSaux_Err_Invalid_File_Format;
    }
d436 1
a436 61
    *acur = cur;
    return err;
  }


  /* first character must be the opening brace that */
  /* starts the procedure                           */

  /* NB: [ and ] need not match:                    */
  /* `/foo {[} def' is a valid PostScript fragment, */
  /* even within a Type1 font                       */

  static FT_Error
  skip_procedure( FT_Byte*  *acur,
                  FT_Byte*   limit )
  {
    FT_Byte*  cur;
    FT_Int    embed = 0;
    FT_Error  error = PSaux_Err_Ok;


    FT_ASSERT( **acur == '{' );

    for ( cur = *acur; cur < limit && error == PSaux_Err_Ok; ++cur )
    {
      switch ( *cur )
      {
      case '{':
        ++embed;
        break;

      case '}':
        --embed;
        if ( embed == 0 )
        {
          ++cur;
          goto end;
        }
        break;

      case '(':
        error = skip_literal_string( &cur, limit );
        break;

      case '<':
        error = skip_string( &cur, limit );
        break;

      case '%':
        skip_comment( &cur, limit );
        break;
      }
    }

  end:
    if ( embed != 0 )
      error = PSaux_Err_Invalid_File_Format;

    *acur = cur;

    return error;
a456 1
    FT_Error  error = PSaux_Err_Ok;
d464 2
a465 1
    if ( *cur == '[' || *cur == ']' )
a470 8
    /* skip balanced expressions (procedures and strings) */

    if ( *cur == '{' )                              /* {...} */
    {
      error = skip_procedure( &cur, limit );
      goto Exit;
    }

d473 1
a473 1
      error = skip_literal_string( &cur, limit );
d483 1
d485 3
a487 4
      else
        error = skip_string( &cur, limit );

      goto Exit;
d495 1
a495 3
        FT_ERROR(( "ps_parser_skip_PS_token: "
                   "unexpected closing delimiter `>'\n" ));
        error = PSaux_Err_Invalid_File_Format;
d508 7
a514 3
      /* *cur might be invalid (e.g., ')' or '}'), but this   */
      /* is handled by the test `cur == parser->cursor' below */
      if ( IS_PS_DELIM( *cur ) )
d517 6
a526 11
    if ( cur == parser->cursor )
    {
      FT_ERROR(( "ps_parser_skip_PS_token: "
                 "current token is `%c', which is self-delimiting "
                 "but invalid at this point\n",
                 *cur ));

      error = PSaux_Err_Invalid_File_Format;
    }

    parser->error  = error;
d547 1
d570 2
a571 2

      if ( skip_literal_string( &cur, limit ) == PSaux_Err_Ok )
d577 3
a579 6
      token->type  = T1_TOKEN_TYPE_ARRAY;
      token->start = cur;

      if ( skip_procedure( &cur, limit ) == PSaux_Err_Ok )
        token->limit = cur;
      break;
a581 3
      /* XXX: in theory we should also look for "<<"          */
      /*      since this is semantically equivalent to "[";   */
      /*      in practice it doesn't matter (?)               */
d583 5
a587 1
      token->type  = T1_TOKEN_TYPE_ARRAY;
d589 1
d599 1
a599 3
        /* XXX: this is wrong because it does not      */
        /*      skip comments, procedures, and strings */
        if ( *cur == '[' )
d601 1
a601 1
        else if ( *cur == ']' )
d622 1
a622 1
      token->type  = ( *cur == '/' ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY );
a638 3
  /* NB: `tokens' can be NULL if we only want to count */
  /* the number of array elements                      */

d674 1
a674 1
        if ( tokens != NULL && cur < limit )
d688 262
a950 2
  /* NB: `coords' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_coords'            */
d973 2
a974 1
    else if ( c == '{' )
a982 4
      FT_Short  dummy;
      FT_Byte*  old_cur;


d988 4
a991 1
      if ( *cur == ender )
d997 2
a998 17
      old_cur = cur;

      if ( coords != NULL && count >= max_coords )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( coords != NULL ? &coords[count] : &dummy ) =
        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;
a1010 2
  /* NB: `values' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_values'            */
d1034 2
a1035 1
    else if ( c == '{' )
a1043 4
      FT_Fixed  dummy;
      FT_Byte*  old_cur;


d1049 4
a1052 1
      if ( *cur == ender )
d1058 2
a1059 17
      old_cur = cur;

      if ( values != NULL && count >= max_values )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( values != NULL ? &values[count] : &dummy ) =
        PS_Conv_ToFixed( &cur, limit, power_ten );

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;
d1244 1
a1244 1
        val = PS_Conv_ToFixed( &cur, limit, 0 );
d1248 1
a1248 1
        val = PS_Conv_ToFixed( &cur, limit, 3 );
d1252 1
a1252 1
        val = PS_Conv_ToInt( &cur, limit );
d1258 1
a1258 1
        case (8 / FT_CHAR_BIT):
d1262 1
a1262 1
        case (16 / FT_CHAR_BIT):
d1266 1
a1266 1
        case (32 / FT_CHAR_BIT):
d1285 1
a1285 3
          /* we allow both a string or a name   */
          /* for cases like /FontName (foo) def */
          if ( token.type == T1_TOKEN_TYPE_KEY )
d1291 1
a1291 1
          else if ( token.type == T1_TOKEN_TYPE_STRING )
d1293 1
a1293 4
            /* don't include delimiting parentheses    */
            /* XXX we don't handle <<...>> here        */
            /* XXX should we convert octal escapes?    */
            /*     if so, what encoding should we use? */
a1296 18
          else
          {
            FT_ERROR(( "ps_parser_load_field: expected a name or string "
                       "but found token of type %d instead\n",
                       token.type ));
            error = PSaux_Err_Invalid_File_Format;
            goto Exit;
          }

          /* for this to work (FT_String**)q must have been */
          /* initialized to NULL                            */
          if ( *(FT_String**)q != NULL )
          {
            FT_TRACE0(( "ps_parser_load_field: overwriting field %s\n",
                        field->ident ));
            FT_FREE( *(FT_String**)q );
            *(FT_String**)q = NULL;
          }
a1311 2
          FT_Int    result;

a1312 1
          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );
d1314 1
a1314 7
          if ( result < 0 )
          {
            FT_ERROR(( "ps_parser_load_field: "
                       "expected four integers in bounding box\n" ));
            error = PSaux_Err_Invalid_File_Format;
            goto Exit;
          }
d1324 1
a1324 1
        /* an error occurred */
d1366 1
d1368 1
a1368 2
    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||
         field->type == T1_FIELD_TYPE_BBOX        )
d1370 1
d1379 2
a1380 2
    if ( (FT_UInt)num_elements > field->array_max )
      num_elements = field->array_max;
d1385 3
a1387 4
    /* we store the elements count if necessary */
    if ( field->type != T1_FIELD_TYPE_BBOX )
      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =
        (FT_Byte)num_elements;
d1418 1
a1418 1
    return PS_Conv_ToInt( &parser->cursor, parser->limit );
a1421 2
  /* first character must be `<' if `delimiters' is non-zero */

a1428 4
    FT_Error  error = PSaux_Err_Ok;
    FT_Byte*  cur;


d1430 6
a1435 38
    cur = parser->cursor;

    if ( cur >= parser->limit )
      goto Exit;

    if ( delimiters )
    {
      if ( *cur != '<' )
      {
        FT_ERROR(( "ps_parser_to_bytes: Missing starting delimiter `<'\n" ));
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,
                                          parser->limit,
                                          bytes,
                                          max_bytes );

    if ( delimiters )
    {
      if ( cur < parser->limit && *cur != '>' )
      {
        FT_ERROR(( "ps_parser_to_bytes: Missing closing delimiter `>'\n" ));
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    parser->cursor = cur;

  Exit:
    return error;
d1444 1
a1444 1
    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );
d1546 1
a1546 1
    builder->parse_state = T1_Parse_Start;
d1617 1
a1617 1
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
d1683 1
a1683 1
    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
d1703 1
a1703 1
    FT_Error  error = PSaux_Err_Invalid_File_Format;
d1707 1
a1707 4

    if ( builder->parse_state == T1_Parse_Have_Path )
      error = PSaux_Err_Ok;
    else if ( builder->parse_state == T1_Parse_Have_Moveto )
d1709 1
a1709 1
      builder->parse_state = T1_Parse_Have_Path;
a1713 1

a1724 3
    if ( !outline )
      return;

d1767 10
a1776 5
    PS_Conv_EexecDecode( &buffer,
                         buffer + length,
                         buffer,
                         length,
                         &seed );
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d172 1
a172 1
    if ( idx < 0 || idx >= table->max_elems )
d1486 6
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a23 1
#include "psconv.h"
d90 3
a92 3
    FT_PtrDist  delta  = table->block - old_base;
    FT_Byte**   offset = table->elements;
    FT_Byte**   limit  = offset + table->max_elems;
d269 58
d339 1
a339 1
      if ( IS_PS_NEWLINE( *cur ) )
d357 1
a357 1
      if ( !IS_PS_SPACE( *cur ) )
d415 3
d423 5
a427 1
      if ( !IS_PS_XDIGIT( *cur ) )
a431 2
    {
      FT_ERROR(( "skip_string: missing closing delimiter `>'\n" ));
a432 1
    }
a494 2
        FT_ERROR(( "ps_parser_skip_PS_token: "
                   "unexpected closing delimiter `>'\n" ));
d508 9
a518 2
        FT_ERROR(( "ps_parser_skip_PS_token: "
                   "unexpected closing delimiter `)'\n" ));
a521 2
      else if ( IS_PS_DELIM( *cur ) )
        break;
d688 262
d997 1
a997 2
      coords[count] =
        (FT_Short)( PS_Conv_ToFixed( &cur, limit, 0 ) >> 16 );
d1058 1
a1058 1
      values[count] = PS_Conv_ToFixed( &cur, limit, power_ten );
d1244 1
a1244 1
        val = PS_Conv_ToFixed( &cur, limit, 0 );
d1248 1
a1248 1
        val = PS_Conv_ToFixed( &cur, limit, 3 );
d1252 1
a1252 1
        val = PS_Conv_ToInt( &cur, limit );
d1258 1
a1258 1
        case (8 / FT_CHAR_BIT):
d1262 1
a1262 1
        case (16 / FT_CHAR_BIT):
d1266 1
a1266 1
        case (32 / FT_CHAR_BIT):
d1418 1
a1418 1
    return PS_Conv_ToInt( &parser->cursor, parser->limit );
a1421 2
  /* first character must be `<' if `delimiters' is non-zero */

a1428 4
    FT_Error  error = PSaux_Err_Ok;
    FT_Byte*  cur;
    
    
d1430 6
a1435 38
    cur = parser->cursor;

    if ( cur >= parser->limit )
      goto Exit;

    if ( delimiters )
    {
      if ( *cur != '<' )
      {
        FT_ERROR(( "ps_parser_to_bytes: Missing starting delimiter `<'\n" ));
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    *pnum_bytes = PS_Conv_ASCIIHexDecode( &cur,
                                          parser->limit,
                                          bytes,
                                          max_bytes );

    if ( delimiters )
    {
      if ( cur < parser->limit && *cur != '>' )
      {
        FT_ERROR(( "ps_tobytes: Missing closing delimiter `>'\n" ));
        error = PSaux_Err_Invalid_File_Format;
        goto Exit;
      }

      cur++;
    }

    parser->cursor = cur;

  Exit:
    return error;
d1444 1
a1444 1
    return PS_Conv_ToFixed( &parser->cursor, parser->limit, power_ten );
d1546 1
a1546 1
    builder->parse_state = T1_Parse_Start;
d1617 1
a1617 1
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
d1683 1
a1683 1
    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
d1703 1
a1703 1
    FT_Error  error = PSaux_Err_Invalid_File_Format;
d1707 1
a1707 4

    if ( builder->parse_state == T1_Parse_Have_Path )
      error = PSaux_Err_Ok;
    else if ( builder->parse_state == T1_Parse_Have_Moveto )
d1709 1
a1709 1
      builder->parse_state = T1_Parse_Have_Path;
a1713 1

a1724 3
    if ( !outline )
      return;

d1767 10
a1776 5
    PS_Conv_EexecDecode( &buffer,
                         buffer + length,
                         buffer,
                         length,
                         &seed );
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
a21 1
#include FT_INTERNAL_CALC_H
a29 10
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_psobjs


  /*************************************************************************/
d121 1
a121 1
    if ( old_base )
d162 1
a162 1
    if ( idx < 0 || idx >= table->max_elems )
a167 6
    if ( length < 0 )
    {
      FT_ERROR(( "ps_table_add: invalid length\n" ));
      return PSaux_Err_Invalid_Argument;
    }

d172 1
a172 1
      FT_Offset  new_size = table->capacity;
d315 1
a315 1
#define IS_OCTAL_DIGIT( c ) ( '0' <= (c) && (c) <= '7' )
d317 1
a317 5

  /* first character must be `(';                               */
  /* *acur is positioned at the character after the closing `)' */

  static FT_Error
d321 2
a322 4
    FT_Byte*      cur   = *acur;
    FT_Int        embed = 0;
    FT_Error      error = PSaux_Err_Invalid_File_Format;
    unsigned int  i;
d327 3
a329 44
      FT_Byte  c = *cur;


      ++cur;

      if ( c == '\\' )
      {
        /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
        /* A backslash can introduce three different types              */
        /* of escape sequences:                                         */
        /*   - a special escaped char like \r, \n, etc.                 */
        /*   - a one-, two-, or three-digit octal number                */
        /*   - none of the above in which case the backslash is ignored */

        if ( cur == limit )
          /* error (or to be ignored?) */
          break;

        switch ( *cur )
        {
          /* skip `special' escape */
        case 'n':
        case 'r':
        case 't':
        case 'b':
        case 'f':
        case '\\':
        case '(':
        case ')':
          ++cur;
          break;

        default:
          /* skip octal escape or ignore backslash */
          for ( i = 0; i < 3 && cur < limit; ++i )
          {
            if ( !IS_OCTAL_DIGIT( *cur ) )
              break;

            ++cur;
          }
        }
      }
      else if ( c == '(' )
d331 1
a331 1
      else if ( c == ')' )
d336 1
a336 1
          error = PSaux_Err_Ok;
d340 1
a343 2

    return error;
d349 2
a350 3
  static FT_Error
  skip_string( FT_Byte*  *acur,
               FT_Byte*   limit )
d352 2
a353 2
    FT_Byte*  cur = *acur;
    FT_Error  err =  PSaux_Err_Ok;
d370 1
a370 1
      err = PSaux_Err_Invalid_File_Format;
d375 1
a375 61
    *acur = cur;
    return err;
  }


  /* first character must be the opening brace that */
  /* starts the procedure                           */

  /* NB: [ and ] need not match:                    */
  /* `/foo {[} def' is a valid PostScript fragment, */
  /* even within a Type1 font                       */

  static FT_Error
  skip_procedure( FT_Byte*  *acur,
                  FT_Byte*   limit )
  {
    FT_Byte*  cur;
    FT_Int    embed = 0;
    FT_Error  error = PSaux_Err_Ok;


    FT_ASSERT( **acur == '{' );

    for ( cur = *acur; cur < limit && error == PSaux_Err_Ok; ++cur )
    {
      switch ( *cur )
      {
      case '{':
        ++embed;
        break;

      case '}':
        --embed;
        if ( embed == 0 )
        {
          ++cur;
          goto end;
        }
        break;

      case '(':
        error = skip_literal_string( &cur, limit );
        break;

      case '<':
        error = skip_string( &cur, limit );
        break;

      case '%':
        skip_comment( &cur, limit );
        break;
      }
    }

  end:
    if ( embed != 0 )
      error = PSaux_Err_Invalid_File_Format;

    *acur = cur;

    return error;
a395 1
    FT_Error  error = PSaux_Err_Ok;
d403 2
a404 1
    if ( *cur == '[' || *cur == ']' )
a409 8
    /* skip balanced expressions (procedures and strings) */

    if ( *cur == '{' )                              /* {...} */
    {
      error = skip_procedure( &cur, limit );
      goto Exit;
    }

d412 1
a412 1
      error = skip_literal_string( &cur, limit );
d422 1
d424 3
a426 4
      else
        error = skip_string( &cur, limit );

      goto Exit;
d434 3
a436 3
        FT_ERROR(( "ps_parser_skip_PS_token:"
                   " unexpected closing delimiter `>'\n" ));
        error = PSaux_Err_Invalid_File_Format;
d449 8
a456 3
      /* *cur might be invalid (e.g., ')' or '}'), but this   */
      /* is handled by the test `cur == parser->cursor' below */
      if ( IS_PS_DELIM( *cur ) )
a462 12
    if ( cur == parser->cursor )
    {
      FT_ERROR(( "ps_parser_skip_PS_token:"
                 " current token is `%c' which is self-delimiting\n"
                 "                        "
                 " but invalid at this point\n",
                 *cur ));

      error = PSaux_Err_Invalid_File_Format;
    }

    parser->error  = error;
d483 1
d506 2
a507 2

      if ( skip_literal_string( &cur, limit ) == PSaux_Err_Ok )
d513 3
a515 6
      token->type  = T1_TOKEN_TYPE_ARRAY;
      token->start = cur;

      if ( skip_procedure( &cur, limit ) == PSaux_Err_Ok )
        token->limit = cur;
      break;
a517 3
      /* XXX: in theory we should also look for "<<"          */
      /*      since this is semantically equivalent to "[";   */
      /*      in practice it doesn't matter (?)               */
d519 5
a523 1
      token->type  = T1_TOKEN_TYPE_ARRAY;
d525 1
d535 1
a535 3
        /* XXX: this is wrong because it does not      */
        /*      skip comments, procedures, and strings */
        if ( *cur == '[' )
d537 1
a537 1
        else if ( *cur == ']' )
d558 1
a558 1
      token->type  = ( *cur == '/' ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY );
a574 3
  /* NB: `tokens' can be NULL if we only want to count */
  /* the number of array elements                      */

d610 1
a610 1
        if ( tokens != NULL && cur < limit )
a624 2
  /* NB: `coords' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_coords'            */
d647 2
a648 1
    else if ( c == '{' )
a656 4
      FT_Short  dummy;
      FT_Byte*  old_cur;


d662 4
a665 1
      if ( *cur == ender )
d671 1
a671 8
      old_cur = cur;

      if ( coords != NULL && count >= max_coords )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( coords != NULL ? &coords[count] : &dummy ) =
d673 1
a673 8

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;
a685 2
  /* NB: `values' can be NULL if we just want to skip the      */
  /*     array; in this case we ignore `max_values'            */
d709 2
a710 1
    else if ( c == '{' )
a718 4
      FT_Fixed  dummy;
      FT_Byte*  old_cur;


d724 4
a727 1
      if ( *cur == ender )
d733 2
a734 17
      old_cur = cur;

      if ( values != NULL && count >= max_values )
        break;

      /* call PS_Conv_ToFixed() even if coords == NULL */
      /* to properly parse number at `cur'             */
      *( values != NULL ? &values[count] : &dummy ) =
        PS_Conv_ToFixed( &cur, limit, power_ten );

      if ( old_cur == cur )
      {
        count = -1;
        goto Exit;
      }
      else
        count++;
d960 1
a960 3
          /* we allow both a string or a name   */
          /* for cases like /FontName (foo) def */
          if ( token.type == T1_TOKEN_TYPE_KEY )
d966 1
a966 1
          else if ( token.type == T1_TOKEN_TYPE_STRING )
d968 1
a968 4
            /* don't include delimiting parentheses    */
            /* XXX we don't handle <<...>> here        */
            /* XXX should we convert octal escapes?    */
            /*     if so, what encoding should we use? */
a971 20
          else
          {
            FT_ERROR(( "ps_parser_load_field:"
                       " expected a name or string\n"
                       "                     "
                       " but found token of type %d instead\n",
                       token.type ));
            error = PSaux_Err_Invalid_File_Format;
            goto Exit;
          }

          /* for this to work (FT_String**)q must have been */
          /* initialized to NULL                            */
          if ( *(FT_String**)q != NULL )
          {
            FT_TRACE0(( "ps_parser_load_field: overwriting field %s\n",
                        field->ident ));
            FT_FREE( *(FT_String**)q );
            *(FT_String**)q = NULL;
          }
a986 2
          FT_Int    result;

a987 1
          result = ps_tofixedarray( &cur, limit, 4, temp, 0 );
d989 1
a989 7
          if ( result < 0 )
          {
            FT_ERROR(( "ps_parser_load_field:"
                       " expected four integers in bounding box\n" ));
            error = PSaux_Err_Invalid_File_Format;
            goto Exit;
          }
d999 1
a999 1
        /* an error occurred */
d1041 1
d1043 1
a1043 2
    if ( field->type == T1_FIELD_TYPE_FIXED_ARRAY ||
         field->type == T1_FIELD_TYPE_BBOX        )
d1045 1
d1054 2
a1055 2
    if ( (FT_UInt)num_elements > field->array_max )
      num_elements = field->array_max;
d1060 3
a1062 5
    /* we store the elements count if necessary;           */
    /* we further assume that `count_offset' can't be zero */
    if ( field->type != T1_FIELD_TYPE_BBOX && field->count_offset != 0 )
      *(FT_Byte*)( (FT_Byte*)objects[0] + field->count_offset ) =
        (FT_Byte)num_elements;
d1102 1
a1102 1
                      FT_Offset  max_bytes,
d1108 2
a1109 2


d1137 1
a1137 1
        FT_ERROR(( "ps_parser_to_bytes: Missing closing delimiter `>'\n" ));
d1283 6
d1350 7
a1356 2
      point->x = FIXED_TO_INT( x );
      point->y = FIXED_TO_INT( y );
d1358 2
a1439 1
    FT_Int       first;
d1445 2
a1446 5
    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;

    /* We must not include the last point in the path if it */
    /* is located on the first point.                       */
d1449 1
d1455 6
d1469 2
a1470 12
    {
      /* Don't add contours only consisting of one point, i.e.,  */
      /* check whether the first and the last point is the same. */
      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
@


1.1.115.4
log
@lets see whether we cant update freetype2 as well
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d84 1
a84 1
    table->block     = NULL;
d116 2
a117 2
  reallocate_t1_table( PS_Table   table,
                       FT_Offset  new_size )
d141 1
a141 1
    return FT_Err_Ok;
d168 4
a171 4
  ps_table_add( PS_Table  table,
                FT_Int    idx,
                void*     object,
                FT_UInt   length )
d176 7
a182 1
      return FT_THROW( Invalid_Argument );
d188 3
a190 3
      FT_Error    error;
      FT_Offset   new_size = table->capacity;
      FT_PtrDist  in_offset;
d193 2
a194 2
      in_offset = (FT_Byte*)object - table->block;
      if ( in_offset < 0 || (FT_Offset)in_offset >= table->capacity )
d219 1
a219 1
    return FT_Err_Ok;
d344 1
a344 1
    FT_Error      error = FT_ERR( Invalid_File_Format );
d353 1
a353 1
      cur++;
d379 1
a379 1
          cur++;
d384 1
a384 1
          for ( i = 0; i < 3 && cur < limit; i++ )
d389 1
a389 1
            cur++;
d400 1
a400 1
          error = FT_Err_Ok;
d419 1
a419 1
    FT_Error  err =  FT_Err_Ok;
d436 1
a436 1
      err = FT_THROW( Invalid_File_Format );
d459 1
a459 1
    FT_Error  error = FT_Err_Ok;
d464 1
a464 1
    for ( cur = *acur; cur < limit && error == FT_Err_Ok; cur++ )
d469 1
a469 1
        embed++;
d473 1
a473 1
        embed--;
d476 1
a476 1
          cur++;
d497 1
a497 1
      error = FT_THROW( Invalid_File_Format );
d522 1
a522 1
    FT_Error  error = FT_Err_Ok;
d570 1
a570 1
        error = FT_THROW( Invalid_File_Format );
d592 1
a592 1
    if ( cur < limit && cur == parser->cursor )
d600 1
a600 1
      error = FT_THROW( Invalid_File_Format );
a602 3
    if ( cur > limit )
      cur = limit;

d628 2
a629 2
    token->start = NULL;
    token->limit = NULL;
d647 1
a647 1
      if ( skip_literal_string( &cur, limit ) == FT_Err_Ok )
d656 1
a656 1
      if ( skip_procedure( &cur, limit ) == FT_Err_Ok )
d701 1
a701 1
      token->type  = ( *cur == '/' ) ? T1_TOKEN_TYPE_KEY : T1_TOKEN_TYPE_ANY;
d710 1
a710 1
      token->start = NULL;
d756 1
a756 1
        if ( tokens && cur < limit )
d821 1
a821 1
      if ( coords && count >= max_coords )
d826 1
a826 1
      *( coords ? &coords[count] : &dummy ) =
a849 2
  /*                                                           */
  /* return number of successfully parsed values               */
d899 1
a899 1
      if ( values && count >= max_values )
d904 1
a904 1
      *( values ? &values[count] : &dummy ) =
d933 1
a933 1
    FT_UInt     len = 0;
d973 1
a973 1
    len = (FT_UInt)( cur - *cursor );
d1030 6
a1035 7
    T1_TokenRec   token;
    FT_Byte*      cur;
    FT_Byte*      limit;
    FT_UInt       count;
    FT_UInt       idx;
    FT_Error      error;
    T1_FieldType  type;
a1047 2
    type = field->type;

d1049 1
a1049 1
    if ( type == T1_FIELD_TYPE_BBOX )
a1064 2
      {
        type = T1_FIELD_TYPE_MM_BBOX;
a1065 1
      }
a1068 2
      count = max_objects;

d1074 2
a1075 1
      idx = 1;
d1084 1
a1084 1
      FT_Byte*    q      = (FT_Byte*)objects[idx] + field->offset;
d1086 1
a1086 1
      FT_String*  string = NULL;
d1091 1
a1091 1
      switch ( type )
d1163 1
a1163 1
            error = FT_THROW( Invalid_File_Format );
d1169 1
a1169 1
          if ( *(FT_String**)q )
d1196 1
a1196 1
          if ( result < 4 )
d1200 1
a1200 1
            error = FT_THROW( Invalid_File_Format );
a1210 50
      case T1_FIELD_TYPE_MM_BBOX:
        {
          FT_Memory  memory = parser->memory;
          FT_Fixed*  temp   = NULL;
          FT_Int     result;
          FT_UInt    i;


          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )
            goto Exit;

          for ( i = 0; i < 4; i++ )
          {
            result = ps_tofixedarray( &cur, limit, (FT_Int)max_objects,
                                      temp + i * max_objects, 0 );
            if ( result < 0 || (FT_UInt)result < max_objects )
            {
              FT_ERROR(( "ps_parser_load_field:"
                         " expected %d integer%s in the %s subarray\n"
                         "                     "
                         " of /FontBBox in the /Blend dictionary\n",
                         max_objects, max_objects > 1 ? "s" : "",
                         i == 0 ? "first"
                                : ( i == 1 ? "second"
                                           : ( i == 2 ? "third"
                                                      : "fourth" ) ) ));
              error = FT_THROW( Invalid_File_Format );

              FT_FREE( temp );
              goto Exit;
            }

            skip_spaces( &cur, limit );
          }

          for ( i = 0; i < max_objects; i++ )
          {
            FT_BBox*  bbox = (FT_BBox*)objects[i];


            bbox->xMin = FT_RoundFix( temp[i                  ] );
            bbox->yMin = FT_RoundFix( temp[i +     max_objects] );
            bbox->xMax = FT_RoundFix( temp[i + 2 * max_objects] );
            bbox->yMax = FT_RoundFix( temp[i + 3 * max_objects] );
          }

          FT_FREE( temp );
        }
        break;

d1224 1
a1224 1
    error = FT_Err_Ok;
d1230 1
a1230 1
    error = FT_THROW( Invalid_File_Format );
d1248 1
a1248 1
    FT_Error     error = FT_Err_Ok;
d1263 1
a1263 1
      error = FT_ERR( Ignore );
d1267 1
a1267 1
      num_elements = (FT_Int)field->array_max;
d1284 1
a1284 9

      error = ps_parser_load_field( parser,
                                    &fieldrec,
                                    objects,
                                    max_objects,
                                    0 );
      if ( error )
        break;

d1317 1
a1317 1
                      FT_ULong*  pnum_bytes,
d1320 1
a1320 1
    FT_Error  error = FT_Err_Ok;
d1335 1
a1335 1
        error = FT_THROW( Invalid_File_Format );
d1352 1
a1352 1
        error = FT_THROW( Invalid_File_Format );
d1422 1
a1422 1
    parser->error  = FT_Err_Ok;
d1491 1
a1491 1
      builder->hints_funcs   = NULL;
a1590 7
    /* this might happen in invalid fonts */
    if ( !outline )
    {
      FT_ERROR(( "t1_builder_add_contour: no outline to add points to\n" ));
      return FT_THROW( Invalid_File_Format );
    }

d1594 1
a1594 1
      return FT_Err_Ok;
d1617 1
a1617 1
    FT_Error  error = FT_ERR( Invalid_File_Format );
d1623 2
a1624 2
      error = FT_Err_Ok;
    else
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
