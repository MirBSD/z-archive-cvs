head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@# @;


1.6
date	2017.04.15.19.22.13;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.28;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.49;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.09;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.08;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.41;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.39.27;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.51;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.19;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.22;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.13;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@#
#  content.py
#
#    Parse comment blocks to build content blocks (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This file contains routines to parse documentation comment blocks,
# building more structured objects out of them.
#


from sources import *
from utils   import *

import string, re


#
# Regular expressions to detect code sequences.  `Code sequences' are simply
# code fragments embedded in '{' and '}', as demonstrated in the following
# example.
#
#   {
#     x = y + z;
#     if ( zookoo == 2 )
#     {
#       foobar();
#     }
#   }
#
# Note that the indentation of the first opening brace and the last closing
# brace must be exactly the same.  The code sequence itself should have a
# larger indentation than the surrounding braces.
#
re_code_start = re.compile( r"(\s*){\s*$" )
re_code_end   = re.compile( r"(\s*)}\s*$" )


#
# A regular expression to isolate identifiers from other text.  Two syntax
# forms are supported:
#
#   <name>
#   <name>[<id>]
#
# where both `<name>' and `<id>' consist of alphanumeric characters, `_',
# and `-'.  Use `<id>' if there are multiple, valid `<name>' entries; in the
# index, `<id>' will be appended in parentheses.
#
# For example,
#
#   stem_darkening[autofit]
#
# becomes `stem_darkening (autofit)' in the index.
#
re_identifier = re.compile( r"""
                              ((?:\w|-)+
                               (?:\[(?:\w|-)+\])?)
                            """, re.VERBOSE )


#
# We collect macro names ending in `_H' (group 1), as defined in
# `freetype/config/ftheader.h'.  While outputting the object data, we use
# this info together with the object's file location (group 2) to emit the
# appropriate header file macro and its associated file name before the
# object itself.
#
# Example:
#
#   #define FT_FREETYPE_H <freetype.h>
#
re_header_macro = re.compile( r'^#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )


################################################################
##
##  DOC CODE CLASS
##
##  The `DocCode' class is used to store source code lines.
##
##  `self.lines' contains a set of source code lines that will be dumped as
##  HTML in a <PRE> tag.
##
##  The object is filled line by line by the parser; it strips the leading
##  `margin' space from each input line before storing it in `self.lines'.
##
class  DocCode:

    def  __init__( self, margin, lines ):
        self.lines = []
        self.words = None

        # remove margin spaces
        for l in lines:
            if string.strip( l[:margin] ) == "":
                l = l[margin:]
            self.lines.append( l )

    def  dump( self, prefix = "", width = 60 ):
        lines = self.dump_lines( 0, width )
        for l in lines:
            print prefix + l

    def  dump_lines( self, margin = 0, width = 60 ):
        result = []
        for l in self.lines:
            result.append( " " * margin + l )
        return result



################################################################
##
##  DOC PARA CLASS
##
##  `Normal' text paragraphs are stored in the `DocPara' class.
##
##  `self.words' contains the list of words that make up the paragraph.
##
class  DocPara:

    def  __init__( self, lines ):
        self.lines = None
        self.words = []
        for l in lines:
            l = string.strip( l )
            self.words.extend( string.split( l ) )

    def  dump( self, prefix = "", width = 60 ):
        lines = self.dump_lines( 0, width )
        for l in lines:
            print prefix + l

    def  dump_lines( self, margin = 0, width = 60 ):
        cur    = ""  # current line
        col    = 0   # current width
        result = []

        for word in self.words:
            ln = len( word )
            if col > 0:
                ln = ln + 1

            if col + ln > width:
                result.append( " " * margin + cur )
                cur = word
                col = len( word )
            else:
                if col > 0:
                    cur = cur + " "
                cur = cur + word
                col = col + ln

        if col > 0:
            result.append( " " * margin + cur )

        return result


################################################################
##
##  DOC FIELD CLASS
##
##  The `DocField' class stores a list containing either `DocPara' or
##  `DocCode' objects.  Each DocField object also has an optional `name'
##  that is used when the object corresponds to a field or value definition.
##
class  DocField:

    def  __init__( self, name, lines ):
        self.name  = name  # can be `None' for normal paragraphs/sources
        self.items = []    # list of items

        mode_none  = 0     # start parsing mode
        mode_code  = 1     # parsing code sequences
        mode_para  = 3     # parsing normal paragraph

        margin     = -1    # current code sequence indentation
        cur_lines  = []

        # analyze the markup lines to check whether they contain paragraphs,
        # code sequences, or fields definitions
        #
        start = 0
        mode  = mode_none

        for l in lines:
            # are we parsing a code sequence?
            if mode == mode_code:
                m = re_code_end.match( l )
                if m and len( m.group( 1 ) ) <= margin:
                    # that's it, we finished the code sequence
                    code = DocCode( 0, cur_lines )
                    self.items.append( code )
                    margin    = -1
                    cur_lines = []
                    mode      = mode_none
                else:
                    # otherwise continue the code sequence
                    cur_lines.append( l[margin:] )
            else:
                # start of code sequence?
                m = re_code_start.match( l )
                if m:
                    # save current lines
                    if cur_lines:
                        para = DocPara( cur_lines )
                        self.items.append( para )
                        cur_lines = []

                    # switch to code extraction mode
                    margin = len( m.group( 1 ) )
                    mode   = mode_code
                else:
                    if not string.split( l ) and cur_lines:
                        # if the line is empty, we end the current paragraph,
                        # if any
                        para = DocPara( cur_lines )
                        self.items.append( para )
                        cur_lines = []
                    else:
                        # otherwise, simply add the line to the current
                        # paragraph
                        cur_lines.append( l )

        if mode == mode_code:
            # unexpected end of code sequence
            code = DocCode( margin, cur_lines )
            self.items.append( code )
        elif cur_lines:
            para = DocPara( cur_lines )
            self.items.append( para )

    def  dump( self, prefix = "" ):
        if self.field:
            print prefix + self.field + " ::"
            prefix = prefix + "----"

        first = 1
        for p in self.items:
            if not first:
                print ""
            p.dump( prefix )
            first = 0

    def  dump_lines( self, margin = 0, width = 60 ):
        result = []
        nl     = None

        for p in self.items:
            if nl:
                result.append( "" )

            result.extend( p.dump_lines( margin, width ) )
            nl = 1

        return result


#
# A regular expression to detect field definitions.
#
# Examples:
#
#   foo     ::
#   foo.bar ::
#
re_field = re.compile( r"""
                         \s*
                           (
                             \w*
                           |
                             \w (\w | \.)* \w
                           )
                         \s* ::
                       """, re.VERBOSE )


################################################################
##
##  DOC MARKUP CLASS
##
class  DocMarkup:

    def  __init__( self, tag, lines ):
        self.tag    = string.lower( tag )
        self.fields = []

        cur_lines = []
        field     = None
        mode      = 0

        for l in lines:
            m = re_field.match( l )
            if m:
                # We detected the start of a new field definition.

                # first, save the current one
                if cur_lines:
                    f = DocField( field, cur_lines )
                    self.fields.append( f )
                    cur_lines = []
                    field     = None

                field     = m.group( 1 )   # record field name
                ln        = len( m.group( 0 ) )
                l         = " " * ln + l[ln:]
                cur_lines = [l]
            else:
                cur_lines.append( l )

        if field or cur_lines:
            f = DocField( field, cur_lines )
            self.fields.append( f )

    def  get_name( self ):
        try:
            return self.fields[0].items[0].words[0]
        except:
            return None

    def  dump( self, margin ):
        print " " * margin + "<" + self.tag + ">"
        for f in self.fields:
            f.dump( "  " )
        print " " * margin + "</" + self.tag + ">"


################################################################
##
##  DOC CHAPTER CLASS
##
class  DocChapter:

    def  __init__( self, block ):
        self.block    = block
        self.sections = []
        if block:
            self.name  = block.name
            self.title = block.get_markup_words( "title" )
            self.order = block.get_markup_words( "sections" )
        else:
            self.name  = "Other"
            self.title = string.split( "Miscellaneous" )
            self.order = []


################################################################
##
##  DOC SECTION CLASS
##
class  DocSection:

    def  __init__( self, name = "Other" ):
        self.name        = name
        self.blocks      = {}
        self.block_names = []  # ordered block names in section
        self.defs        = []
        self.abstract    = ""
        self.description = ""
        self.order       = []
        self.title       = "ERROR"
        self.chapter     = None

    def  add_def( self, block ):
        self.defs.append( block )

    def  add_block( self, block ):
        self.block_names.append( block.name )
        self.blocks[block.name] = block

    def  process( self ):
        # look up one block that contains a valid section description
        for block in self.defs:
            title = block.get_markup_text( "title" )
            if title:
                self.title       = title
                self.abstract    = block.get_markup_words( "abstract" )
                self.description = block.get_markup_items( "description" )
                self.order       = block.get_markup_words_all( "order" )
                return

    def  reorder( self ):
        self.block_names = sort_order_list( self.block_names, self.order )


################################################################
##
##  CONTENT PROCESSOR CLASS
##
class  ContentProcessor:

    def  __init__( self ):
        """Initialize a block content processor."""
        self.reset()

        self.sections = {}    # dictionary of documentation sections
        self.section  = None  # current documentation section

        self.chapters = []    # list of chapters

        self.headers  = {}    # dictionary of header macros

    def  set_section( self, section_name ):
        """Set current section during parsing."""
        if not section_name in self.sections:
            section = DocSection( section_name )
            self.sections[section_name] = section
            self.section                = section
        else:
            self.section = self.sections[section_name]

    def  add_chapter( self, block ):
        chapter = DocChapter( block )
        self.chapters.append( chapter )

    def  reset( self ):
        """Reset the content processor for a new block."""
        self.markups      = []
        self.markup       = None
        self.markup_lines = []

    def  add_markup( self ):
        """Add a new markup section."""
        if self.markup and self.markup_lines:

            # get rid of last line of markup if it's empty
            marks = self.markup_lines
            if len( marks ) > 0 and not string.strip( marks[-1] ):
                self.markup_lines = marks[:-1]

            m = DocMarkup( self.markup, self.markup_lines )

            self.markups.append( m )

            self.markup       = None
            self.markup_lines = []

    def  process_content( self, content ):
        """Process a block content and return a list of DocMarkup objects
           corresponding to it."""
        markup       = None
        markup_lines = []
        first        = 1

        for line in content:
            found = None
            for t in re_markup_tags:
                m = t.match( line )
                if m:
                    found  = string.lower( m.group( 1 ) )
                    prefix = len( m.group( 0 ) )
                    line   = " " * prefix + line[prefix:]   # remove markup from line
                    break

            # is it the start of a new markup section ?
            if found:
                first = 0
                self.add_markup()  # add current markup content
                self.markup = found
                if len( string.strip( line ) ) > 0:
                    self.markup_lines.append( line )
            elif first == 0:
                self.markup_lines.append( line )

        self.add_markup()

        return self.markups

    def  parse_sources( self, source_processor ):
        blocks = source_processor.blocks
        count  = len( blocks )

        for n in range( count ):
            source = blocks[n]
            if source.content:
                # this is a documentation comment, we need to catch
                # all following normal blocks in the "follow" list
                #
                follow = []
                m = n + 1
                while m < count and not blocks[m].content:
                    follow.append( blocks[m] )
                    m = m + 1

                doc_block = DocBlock( source, follow, self )

    def  finish( self ):
        # process all sections to extract their abstract, description
        # and ordered list of items
        #
        for sec in self.sections.values():
            sec.process()

        # process chapters to check that all sections are correctly
        # listed there
        for chap in self.chapters:
            for sec in chap.order:
                if sec in self.sections:
                    section = self.sections[sec]
                    section.chapter = chap
                    section.reorder()
                    chap.sections.append( section )
                else:
                    sys.stderr.write( "WARNING: chapter '" +          \
                        chap.name + "' in " + chap.block.location() + \
                        " lists unknown section '" + sec + "'\n" )

        # check that all sections are in a chapter
        #
        others = []
        for sec in self.sections.values():
            if not sec.chapter:
                sec.reorder()
                others.append( sec )

        # create a new special chapter for all remaining sections
        # when necessary
        #
        if others:
            chap = DocChapter( None )
            chap.sections = others
            self.chapters.append( chap )


################################################################
##
##  DOC BLOCK CLASS
##
class  DocBlock:

    def  __init__( self, source, follow, processor ):
        processor.reset()

        self.source  = source
        self.code    = []
        self.type    = "ERRTYPE"
        self.name    = "ERRNAME"
        self.section = processor.section
        self.markups = processor.process_content( source.content )

        # compute block type from first markup tag
        try:
            self.type = self.markups[0].tag
        except:
            pass

        # compute block name from first markup paragraph
        try:
            markup = self.markups[0]
            para   = markup.fields[0].items[0]
            name   = para.words[0]
            m = re_identifier.match( name )
            if m:
                name = m.group( 1 )
            self.name = name
        except:
            pass

        if self.type == "section":
            # detect new section starts
            processor.set_section( self.name )
            processor.section.add_def( self )
        elif self.type == "chapter":
            # detect new chapter
            processor.add_chapter( self )
        else:
            processor.section.add_block( self )

        # now, compute the source lines relevant to this documentation
        # block. We keep normal comments in for obvious reasons (??)
        source = []
        for b in follow:
            if b.format:
                break
            for l in b.lines:
                # collect header macro definitions
                m = re_header_macro.match( l )
                if m:
                    processor.headers[m.group( 2 )] = m.group( 1 );

                # we use "/* */" as a separator
                if re_source_sep.match( l ):
                    break
                source.append( l )

        # now strip the leading and trailing empty lines from the sources
        start = 0
        end   = len( source ) - 1

        while start < end and not string.strip( source[start] ):
            start = start + 1

        while start < end and not string.strip( source[end] ):
            end = end - 1

        if start == end and not string.strip( source[start] ):
            self.code = []
        else:
            self.code = source[start:end + 1]

    def  location( self ):
        return self.source.location()

    def  get_markup( self, tag_name ):
        """Return the DocMarkup corresponding to a given tag in a block."""
        for m in self.markups:
            if m.tag == string.lower( tag_name ):
                return m
        return None

    def  get_markup_words( self, tag_name ):
        try:
            m = self.get_markup( tag_name )
            return m.fields[0].items[0].words
        except:
            return []

    def  get_markup_words_all( self, tag_name ):
        try:
            m = self.get_markup( tag_name )
            words = []
            for item in m.fields[0].items:
                # We honour empty lines in an `<Order>' section element by
                # adding the sentinel `/empty/'.  The formatter should then
                # convert it to an appropriate representation in the
                # `section_enter' function.
                words += item.words
                words.append( "/empty/" )
            return words
        except:
            return []

    def  get_markup_text( self, tag_name ):
        result = self.get_markup_words( tag_name )
        return string.join( result )

    def  get_markup_items( self, tag_name ):
        try:
            m = self.get_markup( tag_name )
            return m.fields[0].items
        except:
            return None

# eof
@


1.5
log
@fastmerge
@
text
@a0 2
#  Content (c) 2002, 2004, 2006, 2007, 2008, 2009
#    David Turner <david@@freetype.org>
d2 1
a2 2
#  This file contains routines used to parse the content of documentation
#  comment blocks and build more structured objects out of them.
d4 16
d22 2
a23 1
from utils import *
a26 2
# this regular expression is used to detect code sequences. these
# are simply code fragments embedded in '{' and '}' like in:
d28 15
a42 11
#  {
#    x = y + z;
#    if ( zookoo == 2 )
#    {
#      foobar();
#    }
#  }
#
# note that indentation of the starting and ending accolades must be
# exactly the same. the code sequence can contain accolades at greater
# indentation
a47 2
# this regular expression is used to isolate identifiers from
# other text
d49 15
a63 6
re_identifier = re.compile( r'(\w*)' )


# we collect macros ending in `_H'; while outputting the object data, we use
# this info together with the object's file location to emit the appropriate
# header file macro and name before the object itself
d65 4
a68 1
re_header_macro = re.compile( r'^#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )
a70 1
#############################################################################
d72 5
a76 1
# The DocCode class is used to store source code lines.
d78 1
a78 2
#   'self.lines' contains a set of source code lines that will be dumped as
#   HTML in a <PRE> tag.
d80 1
a80 2
#   The object is filled line by line by the parser; it strips the leading
#   "margin" space from each input line before storing it in 'self.lines'.
d82 15
d122 8
a129 6
#############################################################################
#
# The DocPara class is used to store "normal" text paragraph.
#
#   'self.words' contains the list of words that make up the paragraph
#
d170 8
a177 7

#############################################################################
#
#  The DocField class is used to store a list containing either DocPara or
#  DocCode objects. Each DocField also has an optional "name" which is used
#  when the object corresponds to a field or value definition
#
d181 1
a181 1
        self.name  = name  # can be None for normal paragraphs/sources
d191 2
a192 2
        # now analyze the markup lines to see if they contain paragraphs,
        # code sequences or fields definitions
d198 1
a198 1
            # are we parsing a code sequence ?
d209 1
a209 1
                    # nope, continue the code sequence
d212 1
a212 1
                # start of code sequence ?
a269 2

# this regular expression is used to detect field definitions
d271 22
a292 4
re_field = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )



d306 1
a306 1
                # we detected the start of a new field definition
a331 9
    def  get_start( self ):
        try:
            result = ""
            for word in self.fields[0].items[0].words:
                result = result + " " + word
            return result[1:]
        except:
            return "ERROR"

d339 4
a342 1

d358 4
a361 1

d390 1
a390 1
                self.order       = block.get_markup_words( "order" )
d397 4
a400 1

d404 1
a404 1
        """initialize a block content processor"""
d415 2
a416 2
        """set current section during parsing"""
        if not self.sections.has_key( section_name ):
a426 1

d428 1
a428 1
        """reset the content processor for a new block"""
d434 1
a434 1
        """add a new markup section"""
d450 2
a451 2
        """process a block content and return a list of DocMarkup objects
           corresponding to it"""
d509 1
a509 1
                if self.sections.has_key( sec ):
d524 1
d536 4
a539 1

d616 1
a616 1
        """return the DocMarkup corresponding to a given tag in a block"""
d622 1
a622 2
    def  get_markup_name( self, tag_name ):
        """return the name of a given primary markup in a block"""
d625 1
a625 1
            return m.get_name()
d627 1
a627 1
            return None
d629 1
a629 1
    def  get_markup_words( self, tag_name ):
d632 9
a640 1
            return m.fields[0].items[0].words
@


1.4
log
@Merge freetype 2.3.6
@
text
@d1 2
a2 1
#  Content (c) 2002, 2004, 2006, 2007, 2008 David Turner <david@@freetype.org>
d157 1
a157 1
                    # that's it, we finised the code sequence
d325 1
a325 1
        # lookup one block that contains a valid section description
d543 4
a546 3
        source = source[start:end + 1]

        self.code = source
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d1 1
a1 1
#  Content (c) 2002, 2004, 2006, 2007 David Turner <david@@freetype.org>
d37 7
d54 1
a54 1
class DocCode:
d56 3
a58 3
    def __init__( self, margin, lines ):
        self.lines  = []
        self.words  = None
d66 1
a66 1
    def dump( self, prefix = "", width=60 ):
d71 1
a71 1
    def dump_lines( self, margin=0, width=60 ):
d74 1
a74 1
            result.append( " "*margin + l )
d85 1
a85 1
class DocPara:
d87 1
a87 1
    def __init__( self, lines ):
d91 1
a91 1
            l = string.strip(l)
d94 1
a94 1
    def dump( self, prefix = "", width = 60 ):
d99 1
a99 1
    def dump_lines( self, margin=0, width = 60 ):
d105 1
a105 1
            ln = len(word)
d107 1
a107 1
                ln = ln+1
d110 1
a110 1
                result.append( " "*margin + cur )
d112 1
a112 1
                col = len(word)
d120 1
a120 1
            result.append( " "*margin + cur )
a125 1

d132 1
a132 3
class DocField:

    def __init__( self, name, lines ):
d134 1
d136 1
a136 1
        self.items = []     # list of items
d138 3
a140 3
        mode_none  = 0   # start parsing mode
        mode_code  = 1   # parsing code sequences
        mode_para  = 3   # parsing normal paragraph
d142 1
a142 1
        margin     = -1  # current code sequence indentation
d150 1
a151 1

a153 1

d155 1
a155 1
                if m and len(m.group(1)) <= margin:
d176 1
a176 1
                    margin = len(m.group(1))
a177 1

a193 1

d198 1
a198 1
    def dump( self, prefix = "" ):
d210 1
a210 1
    def dump_lines( self, margin=0, width=60 ):
d213 1
d223 2
d227 1
a227 1
re_field  = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )
d231 1
a231 1
class DocMarkup:
d233 3
a235 3
    def __init__( self, tag, lines ):
        self.tag       = string.lower(tag)
        self.fields    = []
d253 4
a256 4
                field     = m.group(1)   # record field name
                ln        = len(m.group(0))
                l         = " "*ln + l[ln:]
                cur_lines = [ l ]
d264 1
a264 1
    def get_name( self ):
a266 1

d270 1
a270 1
    def get_start( self ):
a275 1

d279 2
a280 2
    def dump( self, margin ):
        print " "*margin + "<" + self.tag + ">"
d283 1
a283 2
        print " "*margin + "</" + self.tag + ">"

d287 1
a287 1
class DocChapter:
d289 1
a289 1
    def __init__( self, block ):
d293 3
a295 3
            self.name     = block.name
            self.title    = block.get_markup_words( "title" )
            self.order    = block.get_markup_words( "sections" )
d297 3
a299 3
            self.name     = "Other"
            self.title    = string.split( "Miscellaneous" )
            self.order    = []
d303 1
a303 1
class DocSection:
d305 1
a305 1
    def __init__( self, name = "Other" ):
d316 1
a316 1
    def add_def( self, block ):
d319 1
a319 1
    def add_block( self, block ):
d321 1
a321 1
        self.blocks[ block.name ] = block
d323 1
a323 1
    def process( self ):
d334 2
a335 1
    def reorder( self ):
a336 1
        self.block_names = sort_order_list( self.block_names, self.order )
d339 1
a339 1
class ContentProcessor:
d341 1
a341 1
    def __init__( self ):
d348 1
a348 1
        self.chapters = []        # list of chapters
d350 3
a352 1
    def set_section( self, section_name ):
d356 2
a357 2
            self.sections[ section_name ] = section
            self.section                  = section
d359 1
a359 1
            self.section = self.sections[ section_name ]
d361 1
a361 1
    def add_chapter( self, block ):
d366 1
a366 1
    def reset( self ):
d372 1
a372 1
    def add_markup( self ):
d378 1
a378 1
            if len(marks) > 0 and not string.strip(marks[-1]):
d388 1
a388 2

    def process_content( self, content ):
d400 3
a402 3
                    found  = string.lower(m.group(1))
                    prefix = len(m.group(0))
                    line   = " "*prefix + line[prefix:]   # remove markup from line
d410 1
a410 1
                if len(string.strip( line )) > 0:
a418 1

d421 1
a421 2
        count  = len(blocks)
        for n in range(count):
d423 1
d430 1
a430 1
                m = n+1
d433 1
a433 1
                    m = m+1
a436 1

a437 1

d448 2
a449 2
                if self.sections.has_key(sec):
                    section = self.sections[ sec ]
d454 1
a454 1
                    sys.stderr.write( "WARNING: chapter '" +
d463 1
a463 1
                others.append(sec)
d475 1
a475 3
class DocBlock:

    def __init__( self, source, follow, processor ):
d477 1
d480 6
a485 6
        self.source    = source
        self.code      = []
        self.type      = "ERRTYPE"
        self.name      = "ERRNAME"
        self.section   = processor.section
        self.markups   = processor.process_content( source.content )
a492 1

d500 1
a500 1
                name = m.group(1)
a504 1
        # detect new section starts
d506 1
a508 2

        # detect new chapter
d510 1
a511 1

d522 5
d534 1
a534 1
        end   = len( source )-1
d542 1
a542 1
        source = source[start:end+1]
d546 1
a546 2

    def location( self ):
d549 1
a549 3


    def get_markup( self, tag_name ):
d552 1
a552 1
            if m.tag == string.lower(tag_name):
d556 1
a556 2

    def get_markup_name( self, tag_name ):
d564 1
a564 2

    def get_markup_words( self, tag_name ):
d571 1
a571 2

    def get_markup_text( self, tag_name ):
d575 1
a575 2

    def get_markup_items( self, tag_name ):
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d1 1
d3 2
a4 2
#  this file contains routines used to parse the content of documentation
#  comment block and build a more structured objects out of them
d12 1
a12 1
# this regular expresion is used to detect code sequences. these
d23 1
a23 1
# note that identation of the starting and ending accolades must be
d587 2
@


1.1
log
@Initial revision
@
text
@d62 1
a62 1
    
d68 1
a68 1
    
d90 1
a90 1
    
d113 1
a113 1
            
d116 1
a116 1
    
d123 1
a123 1
#  when the object corresponds to a field of value definition
d213 1
a213 1
                
d216 1
a216 1
            
d221 1
a221 1
re_field  = re.compile( r"\s*(\w*)\s*::" )
d264 1
a264 1
        
d271 1
a271 1
        
d323 1
a323 1
            title = block.get_markup_text( "Title" )
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@a0 1
#  Content (c) 2002, 2004, 2006, 2007 David Turner <david@@freetype.org>
d2 2
a3 2
#  This file contains routines used to parse the content of documentation
#  comment blocks and build more structured objects out of them.
d11 1
a11 1
# this regular expression is used to detect code sequences. these
d22 1
a22 1
# note that indentation of the starting and ending accolades must be
d62 1
a62 1

d68 1
a68 1

d90 1
a90 1

d113 1
a113 1

d116 1
a116 1

d123 1
a123 1
#  when the object corresponds to a field or value definition
d213 1
a213 1

d216 1
a216 1

d221 1
a221 1
re_field  = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )
d264 1
a264 1

d271 1
a271 1

d323 1
a323 1
            title = block.get_markup_text( "title" )
a585 2

# eof
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d1 1
a1 1
#  Content (c) 2002, 2004, 2006, 2007, 2008 David Turner <david@@freetype.org>
a36 7
# we collect macros ending in `_H'; while outputting the object data, we use
# this info together with the object's file location to emit the appropriate
# header file macro and name before the object itself
#
re_header_macro = re.compile( r'^#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )


d47 1
a47 1
class  DocCode:
d49 3
a51 3
    def  __init__( self, margin, lines ):
        self.lines = []
        self.words = None
d59 1
a59 1
    def  dump( self, prefix = "", width = 60 ):
d64 1
a64 1
    def  dump_lines( self, margin = 0, width = 60 ):
d67 1
a67 1
            result.append( " " * margin + l )
d78 1
a78 1
class  DocPara:
d80 1
a80 1
    def  __init__( self, lines ):
d84 1
a84 1
            l = string.strip( l )
d87 1
a87 1
    def  dump( self, prefix = "", width = 60 ):
d92 1
a92 1
    def  dump_lines( self, margin = 0, width = 60 ):
d98 1
a98 1
            ln = len( word )
d100 1
a100 1
                ln = ln + 1
d103 1
a103 1
                result.append( " " * margin + cur )
d105 1
a105 1
                col = len( word )
d113 1
a113 1
            result.append( " " * margin + cur )
d119 1
d126 3
a128 1
class  DocField:
a129 1
    def  __init__( self, name, lines ):
d131 1
a131 1
        self.items = []    # list of items
d133 3
a135 3
        mode_none  = 0     # start parsing mode
        mode_code  = 1     # parsing code sequences
        mode_para  = 3     # parsing normal paragraph
d137 1
a137 1
        margin     = -1    # current code sequence indentation
d145 1
a146 1
        for l in lines:
d149 1
d151 1
a151 1
                if m and len( m.group( 1 ) ) <= margin:
d172 1
a172 1
                    margin = len( m.group( 1 ) )
d174 1
d191 1
d196 1
a196 1
    def  dump( self, prefix = "" ):
d208 1
a208 1
    def  dump_lines( self, margin = 0, width = 60 ):
a210 1

a219 2


d222 1
a222 1
re_field = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )
d226 1
a226 1
class  DocMarkup:
d228 3
a230 3
    def  __init__( self, tag, lines ):
        self.tag    = string.lower( tag )
        self.fields = []
d248 4
a251 4
                field     = m.group( 1 )   # record field name
                ln        = len( m.group( 0 ) )
                l         = " " * ln + l[ln:]
                cur_lines = [l]
d259 1
a259 1
    def  get_name( self ):
d262 1
d266 1
a266 1
    def  get_start( self ):
d272 1
d276 2
a277 2
    def  dump( self, margin ):
        print " " * margin + "<" + self.tag + ">"
d280 2
a281 1
        print " " * margin + "</" + self.tag + ">"
d285 1
a285 1
class  DocChapter:
d287 1
a287 1
    def  __init__( self, block ):
d291 3
a293 3
            self.name  = block.name
            self.title = block.get_markup_words( "title" )
            self.order = block.get_markup_words( "sections" )
d295 3
a297 3
            self.name  = "Other"
            self.title = string.split( "Miscellaneous" )
            self.order = []
d301 1
a301 1
class  DocSection:
d303 1
a303 1
    def  __init__( self, name = "Other" ):
d314 1
a314 1
    def  add_def( self, block ):
d317 1
a317 1
    def  add_block( self, block ):
d319 1
a319 1
        self.blocks[block.name] = block
d321 1
a321 1
    def  process( self ):
d332 2
a333 1
    def  reorder( self ):
d337 1
d339 1
a339 3
class  ContentProcessor:

    def  __init__( self ):
d346 1
a346 1
        self.chapters = []    # list of chapters
d348 1
a348 3
        self.headers  = {}    # dictionary of header macros

    def  set_section( self, section_name ):
d352 2
a353 2
            self.sections[section_name] = section
            self.section                = section
d355 1
a355 1
            self.section = self.sections[section_name]
d357 1
a357 1
    def  add_chapter( self, block ):
d362 1
a362 1
    def  reset( self ):
d368 1
a368 1
    def  add_markup( self ):
d374 1
a374 1
            if len( marks ) > 0 and not string.strip( marks[-1] ):
d384 2
a385 1
    def  process_content( self, content ):
d397 3
a399 3
                    found  = string.lower( m.group( 1 ) )
                    prefix = len( m.group( 0 ) )
                    line   = " " * prefix + line[prefix:]   # remove markup from line
d407 1
a407 1
                if len( string.strip( line ) ) > 0:
d416 1
d419 2
a420 1
        count  = len( blocks )
a421 1
        for n in range( count ):
d428 1
a428 1
                m = n + 1
d431 1
a431 1
                    m = m + 1
d435 1
d437 1
d448 2
a449 2
                if self.sections.has_key( sec ):
                    section = self.sections[sec]
d454 1
a454 1
                    sys.stderr.write( "WARNING: chapter '" +          \
d463 1
a463 1
                others.append( sec )
d475 3
a477 1
class  DocBlock:
a478 1
    def  __init__( self, source, follow, processor ):
d481 6
a486 6
        self.source  = source
        self.code    = []
        self.type    = "ERRTYPE"
        self.name    = "ERRNAME"
        self.section = processor.section
        self.markups = processor.process_content( source.content )
d494 1
d502 1
a502 1
                name = m.group( 1 )
d507 1
a508 1
            # detect new section starts
d511 2
a513 1
            # detect new chapter
d515 1
a525 5
                # collect header macro definitions
                m = re_header_macro.match( l )
                if m:
                    processor.headers[m.group( 2 )] = m.group( 1 );

d533 1
a533 1
        end   = len( source ) - 1
d541 1
a541 1
        source = source[start:end + 1]
d545 2
a546 1
    def  location( self ):
d549 3
a551 1
    def  get_markup( self, tag_name ):
d554 1
a554 1
            if m.tag == string.lower( tag_name ):
d558 2
a559 1
    def  get_markup_name( self, tag_name ):
d567 2
a568 1
    def  get_markup_words( self, tag_name ):
d575 2
a576 1
    def  get_markup_text( self, tag_name ):
d580 2
a581 1
    def  get_markup_items( self, tag_name ):
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d62 1
a62 1

d68 1
a68 1

d90 1
a90 1

d113 1
a113 1

d116 1
a116 1

d123 1
a123 1
#  when the object corresponds to a field or value definition
d213 1
a213 1

d216 1
a216 1

d221 1
a221 1
re_field  = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )
d264 1
a264 1

d271 1
a271 1

d323 1
a323 1
            title = block.get_markup_text( "title" )
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@a0 2
#  Content (c) 2002, 2004, 2006, 2007, 2008, 2009
#    David Turner <david@@freetype.org>
d2 2
a3 2
#  This file contains routines used to parse the content of documentation
#  comment blocks and build more structured objects out of them.
d11 1
a11 1
# this regular expression is used to detect code sequences. these
d22 1
a22 1
# note that indentation of the starting and ending accolades must be
a35 7
# we collect macros ending in `_H'; while outputting the object data, we use
# this info together with the object's file location to emit the appropriate
# header file macro and name before the object itself
#
re_header_macro = re.compile( r'^#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )


d46 1
a46 1
class  DocCode:
d48 3
a50 3
    def  __init__( self, margin, lines ):
        self.lines = []
        self.words = None
d58 1
a58 1
    def  dump( self, prefix = "", width = 60 ):
d63 1
a63 1
    def  dump_lines( self, margin = 0, width = 60 ):
d66 1
a66 1
            result.append( " " * margin + l )
d77 1
a77 1
class  DocPara:
d79 1
a79 1
    def  __init__( self, lines ):
d83 1
a83 1
            l = string.strip( l )
d86 1
a86 1
    def  dump( self, prefix = "", width = 60 ):
d91 1
a91 1
    def  dump_lines( self, margin = 0, width = 60 ):
d97 1
a97 1
            ln = len( word )
d99 1
a99 1
                ln = ln + 1
d102 1
a102 1
                result.append( " " * margin + cur )
d104 1
a104 1
                col = len( word )
d112 1
a112 1
            result.append( " " * margin + cur )
d118 1
d125 3
a127 1
class  DocField:
a128 1
    def  __init__( self, name, lines ):
d130 1
a130 1
        self.items = []    # list of items
d132 3
a134 3
        mode_none  = 0     # start parsing mode
        mode_code  = 1     # parsing code sequences
        mode_para  = 3     # parsing normal paragraph
d136 1
a136 1
        margin     = -1    # current code sequence indentation
d144 1
a145 1
        for l in lines:
d148 1
d150 2
a151 2
                if m and len( m.group( 1 ) ) <= margin:
                    # that's it, we finished the code sequence
d171 1
a171 1
                    margin = len( m.group( 1 ) )
d173 1
d190 1
d195 1
a195 1
    def  dump( self, prefix = "" ):
d207 1
a207 1
    def  dump_lines( self, margin = 0, width = 60 ):
a209 1

a218 2


d221 1
a221 1
re_field = re.compile( r"\s*(\w*|\w(\w|\.)*\w)\s*::" )
d225 1
a225 1
class  DocMarkup:
d227 3
a229 3
    def  __init__( self, tag, lines ):
        self.tag    = string.lower( tag )
        self.fields = []
d247 4
a250 4
                field     = m.group( 1 )   # record field name
                ln        = len( m.group( 0 ) )
                l         = " " * ln + l[ln:]
                cur_lines = [l]
d258 1
a258 1
    def  get_name( self ):
d261 1
d265 1
a265 1
    def  get_start( self ):
d271 1
d275 2
a276 2
    def  dump( self, margin ):
        print " " * margin + "<" + self.tag + ">"
d279 1
a279 1
        print " " * margin + "</" + self.tag + ">"
a282 1
class  DocChapter:
d284 3
a286 1
    def  __init__( self, block ):
d290 3
a292 3
            self.name  = block.name
            self.title = block.get_markup_words( "title" )
            self.order = block.get_markup_words( "sections" )
d294 3
a296 3
            self.name  = "Other"
            self.title = string.split( "Miscellaneous" )
            self.order = []
d300 1
a300 1
class  DocSection:
d302 1
a302 1
    def  __init__( self, name = "Other" ):
d313 1
a313 1
    def  add_def( self, block ):
d316 1
a316 1
    def  add_block( self, block ):
d318 1
a318 1
        self.blocks[block.name] = block
d320 2
a321 2
    def  process( self ):
        # look up one block that contains a valid section description
d331 2
a332 1
    def  reorder( self ):
d336 1
d338 1
a338 3
class  ContentProcessor:

    def  __init__( self ):
d345 1
a345 1
        self.chapters = []    # list of chapters
d347 1
a347 3
        self.headers  = {}    # dictionary of header macros

    def  set_section( self, section_name ):
d351 2
a352 2
            self.sections[section_name] = section
            self.section                = section
d354 1
a354 1
            self.section = self.sections[section_name]
d356 1
a356 1
    def  add_chapter( self, block ):
d361 1
a361 1
    def  reset( self ):
d367 1
a367 1
    def  add_markup( self ):
d373 1
a373 1
            if len( marks ) > 0 and not string.strip( marks[-1] ):
d383 2
a384 1
    def  process_content( self, content ):
d396 3
a398 3
                    found  = string.lower( m.group( 1 ) )
                    prefix = len( m.group( 0 ) )
                    line   = " " * prefix + line[prefix:]   # remove markup from line
d406 1
a406 1
                if len( string.strip( line ) ) > 0:
d415 1
d418 2
a419 1
        count  = len( blocks )
a420 1
        for n in range( count ):
d427 1
a427 1
                m = n + 1
d430 1
a430 1
                    m = m + 1
d434 1
d436 1
d447 2
a448 2
                if self.sections.has_key( sec ):
                    section = self.sections[sec]
d453 1
a453 1
                    sys.stderr.write( "WARNING: chapter '" +          \
d462 1
a462 1
                others.append( sec )
d474 3
a476 1
class  DocBlock:
a477 1
    def  __init__( self, source, follow, processor ):
d480 6
a485 6
        self.source  = source
        self.code    = []
        self.type    = "ERRTYPE"
        self.name    = "ERRNAME"
        self.section = processor.section
        self.markups = processor.process_content( source.content )
d493 1
d501 1
a501 1
                name = m.group( 1 )
d506 1
a507 1
            # detect new section starts
d510 2
a512 1
            # detect new chapter
d514 1
a524 5
                # collect header macro definitions
                m = re_header_macro.match( l )
                if m:
                    processor.headers[m.group( 2 )] = m.group( 1 );

d532 1
a532 1
        end   = len( source ) - 1
d540 4
a543 4
        if start == end and not string.strip( source[start] ):
            self.code = []
        else:
            self.code = source[start:end + 1]
d545 1
a545 1
    def  location( self ):
d548 3
a550 1
    def  get_markup( self, tag_name ):
d553 1
a553 1
            if m.tag == string.lower( tag_name ):
d557 2
a558 1
    def  get_markup_name( self, tag_name ):
d566 2
a567 1
    def  get_markup_words( self, tag_name ):
d574 2
a575 1
    def  get_markup_text( self, tag_name ):
d579 2
a580 1
    def  get_markup_items( self, tag_name ):
a585 2

# eof
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d1 2
d4 2
a5 1
#  content.py
a6 16
#    Parse comment blocks to build content blocks (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This file contains routines to parse documentation comment blocks,
# building more structured objects out of them.
#

d9 1
a9 2
from utils   import *

d13 2
d16 11
a26 15
# Regular expressions to detect code sequences.  `Code sequences' are simply
# code fragments embedded in '{' and '}', as demonstrated in the following
# example.
#
#   {
#     x = y + z;
#     if ( zookoo == 2 )
#     {
#       foobar();
#     }
#   }
#
# Note that the indentation of the first opening brace and the last closing
# brace must be exactly the same.  The code sequence itself should have a
# larger indentation than the surrounding braces.
d32 2
d35 6
a40 2
# A regular expression to isolate identifiers from other text.  Two syntax
# forms are supported:
d42 1
a42 17
#   <name>
#   <name>[<id>]
#
# where both `<name>' and `<id>' consist of alphanumeric characters, `_',
# and `-'.  Use `<id>' if there are multiple, valid `<name>' entries; in the
# index, `<id>' will be appended in parentheses.
#
# For example,
#
#   stem_darkening[autofit]
#
# becomes `stem_darkening (autofit)' in the index.
#
re_identifier = re.compile( r"""
                              ((?:\w|-)+
                               (?:\[(?:\w|-)+\])?)
                            """, re.VERBOSE )
d45 1
d47 1
a47 5
# We collect macro names ending in `_H' (group 1), as defined in
# `freetype/config/ftheader.h'.  While outputting the object data, we use
# this info together with the object's file location (group 2) to emit the
# appropriate header file macro and its associated file name before the
# object itself.
d49 2
a50 1
# Example:
d52 2
a53 1
#   #define FT_FREETYPE_H <freetype.h>
a54 15
re_header_macro = re.compile( r'^#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )


################################################################
##
##  DOC CODE CLASS
##
##  The `DocCode' class is used to store source code lines.
##
##  `self.lines' contains a set of source code lines that will be dumped as
##  HTML in a <PRE> tag.
##
##  The object is filled line by line by the parser; it strips the leading
##  `margin' space from each input line before storing it in `self.lines'.
##
d80 6
a85 8
################################################################
##
##  DOC PARA CLASS
##
##  `Normal' text paragraphs are stored in the `DocPara' class.
##
##  `self.words' contains the list of words that make up the paragraph.
##
d126 7
a132 8
################################################################
##
##  DOC FIELD CLASS
##
##  The `DocField' class stores a list containing either `DocPara' or
##  `DocCode' objects.  Each DocField object also has an optional `name'
##  that is used when the object corresponds to a field or value definition.
##
d136 1
a136 1
        self.name  = name  # can be `None' for normal paragraphs/sources
d146 2
a147 2
        # analyze the markup lines to check whether they contain paragraphs,
        # code sequences, or fields definitions
d153 1
a153 1
            # are we parsing a code sequence?
d164 1
a164 1
                    # otherwise continue the code sequence
d167 1
a167 1
                # start of code sequence?
d225 2
d228 4
a231 22
# A regular expression to detect field definitions.
#
# Examples:
#
#   foo     ::
#   foo.bar ::
#
re_field = re.compile( r"""
                         \s*
                           (
                             \w*
                           |
                             \w (\w | \.)* \w
                           )
                         \s* ::
                       """, re.VERBOSE )


################################################################
##
##  DOC MARKUP CLASS
##
d245 1
a245 1
                # We detected the start of a new field definition.
d271 9
d287 1
a287 4
################################################################
##
##  DOC CHAPTER CLASS
##
d303 1
a303 4
################################################################
##
##  DOC SECTION CLASS
##
d332 1
a332 1
                self.order       = block.get_markup_words_all( "order" )
d339 1
a339 4
################################################################
##
##  CONTENT PROCESSOR CLASS
##
d343 1
a343 1
        """Initialize a block content processor."""
d354 2
a355 2
        """Set current section during parsing."""
        if not section_name in self.sections:
d366 1
d368 1
a368 1
        """Reset the content processor for a new block."""
d374 1
a374 1
        """Add a new markup section."""
d390 2
a391 2
        """Process a block content and return a list of DocMarkup objects
           corresponding to it."""
d449 1
a449 1
                if sec in self.sections:
a463 1
                sec.reorder()
d475 1
a475 4
################################################################
##
##  DOC BLOCK CLASS
##
d552 1
a552 1
        """Return the DocMarkup corresponding to a given tag in a block."""
d558 2
a559 1
    def  get_markup_words( self, tag_name ):
d562 1
a562 1
            return m.fields[0].items[0].words
d564 1
a564 1
            return []
d566 1
a566 1
    def  get_markup_words_all( self, tag_name ):
d569 1
a569 9
            words = []
            for item in m.fields[0].items:
                # We honour empty lines in an `<Order>' section element by
                # adding the sentinel `/empty/'.  The formatter should then
                # convert it to an appropriate representation in the
                # `section_enter' function.
                words += item.words
                words.append( "/empty/" )
            return words
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
