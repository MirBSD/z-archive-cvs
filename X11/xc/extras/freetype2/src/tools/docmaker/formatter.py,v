head	1.4;
access;
symbols
	freetype-2_7_1:1.1.115.3
	freetype-2_3_12:1.1.115.2
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.2
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.1
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@# @;


1.4
date	2017.04.15.19.22.13;	author tg;	state Exp;
branches;
next	1.3;
commitid	10058F2723111C7BEE2;

1.3
date	2008.06.12.20.54.50;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10048518C1E44F62885;

1.2
date	2008.02.26.20.05.09;	author bsiegert;	state Exp;
branches;
next	1.1;
commitid	10047C470A72A1E13CE;

1.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.40;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.39.25;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.18;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.52;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2013.08.06.19.12.22;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10052014A9975CEFD1D;

1.1.115.3
date	2017.04.15.15.42.13;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.4
log
@first cut at a quickmerge
@
text
@#
#  formatter.py
#
#    Convert parsed content blocks to a structured document (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This is the base Formatter class.  Its purpose is to convert a content
# processor's data into specific documents (i.e., table of contents, global
# index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example, the
# file `tohtml.py' contains the definition of the `HtmlFormatter' sub-class
# to output HTML.
#


from sources import *
from content import *
from utils   import *


################################################################
##
##  FORMATTER CLASS
##
class  Formatter:

    def  __init__( self, processor ):
        self.processor   = processor
        self.identifiers = {}
        self.chapters    = processor.chapters
        self.sections    = processor.sections.values()
        self.block_index = []

        # store all blocks in a dictionary
        self.blocks = []
        for section in self.sections:
            for block in section.blocks.values():
                self.add_identifier( block.name, block )

                # add enumeration values to the index, since this is useful
                for markup in block.markups:
                    if markup.tag == 'values':
                        for field in markup.fields:
                            self.add_identifier( field.name, block )

        self.block_index = self.identifiers.keys()
        self.block_index.sort( key = index_key )

        # also add section names to dictionary (without making them appear
        # in the index)
        for section in self.sections:
            self.add_identifier( section.name, section )

    def  add_identifier( self, name, block ):
        if name in self.identifiers:
            # duplicate name!
            sys.stderr.write( "WARNING: duplicate definition for"
                              + " '" + name + "' "
                              + "in " + block.location() + ", "
                              + "previous definition in "
                              + self.identifiers[name].location()
                              + "\n" )
        else:
            self.identifiers[name] = block

    #
    # formatting the table of contents
    #
    def  toc_enter( self ):
        pass

    def  toc_chapter_enter( self, chapter ):
        pass

    def  toc_section_enter( self, section ):
        pass

    def  toc_section_exit( self, section ):
        pass

    def  toc_chapter_exit( self, chapter ):
        pass

    def  toc_index( self, index_filename ):
        pass

    def  toc_exit( self ):
        pass

    def  toc_dump( self, toc_filename = None, index_filename = None ):
        output = None
        if toc_filename:
            output = open_output( toc_filename )

        self.toc_enter()

        for chap in self.processor.chapters:

            self.toc_chapter_enter( chap )

            for section in chap.sections:
                self.toc_section_enter( section )
                self.toc_section_exit( section )

            self.toc_chapter_exit( chap )

        self.toc_index( index_filename )

        self.toc_exit()

        if output:
            close_output( output )

    #
    # formatting the index
    #
    def  index_enter( self ):
        pass

    def  index_name_enter( self, name ):
        pass

    def  index_name_exit( self, name ):
        pass

    def  index_exit( self ):
        pass

    def  index_dump( self, index_filename = None ):
        output = None
        if index_filename:
            output = open_output( index_filename )

        self.index_enter()

        for name in self.block_index:
            self.index_name_enter( name )
            self.index_name_exit( name )

        self.index_exit()

        if output:
            close_output( output )

    #
    # formatting a section
    #
    def  section_enter( self, section ):
        pass

    def  block_enter( self, block ):
        pass

    def  markup_enter( self, markup, block = None ):
        pass

    def  field_enter( self, field, markup = None, block = None ):
        pass

    def  field_exit( self, field, markup = None, block = None ):
        pass

    def  markup_exit( self, markup, block = None ):
        pass

    def  block_exit( self, block ):
        pass

    def  section_exit( self, section ):
        pass

    def  section_dump( self, section, section_filename = None ):
        output = None
        if section_filename:
            output = open_output( section_filename )

        self.section_enter( section )

        for name in section.block_names:
            skip_entry = 0
            try:
                block = self.identifiers[name]
                # `block_names' can contain field names also,
                # which we filter out
                for markup in block.markups:
                    if markup.tag == 'values':
                        for field in markup.fields:
                            if field.name == name:
                                skip_entry = 1
            except:
                skip_entry = 1   # this happens e.g. for `/empty/' entries

            if skip_entry:
              continue

            self.block_enter( block )

            for markup in block.markups[1:]:   # always ignore first markup!
                self.markup_enter( markup, block )

                for field in markup.fields:
                    self.field_enter( field, markup, block )
                    self.field_exit( field, markup, block )

                self.markup_exit( markup, block )

            self.block_exit( block )

        self.section_exit( section )

        if output:
            close_output( output )

    def  section_dump_all( self ):
        for section in self.sections:
            self.section_dump( section )

# eof
@


1.3
log
@Merge freetype 2.3.6
@
text
@a0 1
#  Formatter (c) 2002, 2004, 2007, 2008 David Turner <david@@freetype.org>
d2 23
a29 8
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
# contents, global index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example,
# the file tohtml.py contains the definition of the HtmlFormatter sub-class
# used to output -- you guessed it -- HTML.
#
d31 4
d57 6
a62 1
        self.block_index.sort( index_sort )
d65 1
a65 1
        if self.identifiers.has_key( name ):
d67 6
a72 4
            sys.stderr.write(                                           \
               "WARNING: duplicate definition for '" + name + "' in " + \
               block.location() + ", previous definition in " +         \
               self.identifiers[name].location() + "\n" )
d77 1
a77 1
    #  Formatting the table of contents
d125 1
a125 1
    #  Formatting the index
d156 1
a156 1
    #  Formatting a section
d190 16
a205 1
            block = self.identifiers[name]
@


1.2
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d1 1
a1 1
#  Formatter (c) 2002, 2004, 2007 David Turner <david@@freetype.org>
d17 1
a17 3
class Formatter:

    def __init__( self, processor ):
d19 1
d27 1
a27 1
        self.blocks      = []
a37 1

d41 1
a41 2

    def add_identifier( self, name, block ):
d43 2
a44 2
            # duplicate name !!
            sys.stderr.write( \
d47 1
a47 1
               self.identifiers[ name ].location() + "\n" )
a50 1

a53 1

a75 1

d90 1
a90 1
            self.toc_chapter_exit ( chap )
a101 1

a114 1

d123 1
a123 1
            self.index_name_exit ( name )
a156 1

a157 1

d165 1
a165 1
            block = self.identifiers[ name ]
d168 1
a168 1
            for markup in block.markups[1:]:   # always ignore first markup !!
d173 1
a173 2

                    self.field_exit ( field, markup, block )
d179 1
a179 1
        self.section_exit ( section )
d184 1
a184 2

    def section_dump_all( self ):
a187 4
    #
    #  Formatting a block
    #

@


1.1
log
@Initial revision
@
text
@d1 3
d8 2
a9 2
# This is the base Formatter class. its purpose is to convert
# a content processor's data into specific documents (i.e. table of
d12 1
a12 1
# You'll need to sub-class it to output anything sensible.  For example,
d14 1
a14 1
# used to output, you guessed it, HTML.
d32 1
a32 1
                    
d53 1
a53 1
              
d61 1
a61 1
    
d64 1
a64 1
    
d67 1
a67 1
        
d70 1
a70 1
        
d76 1
a76 1
    
d81 1
a81 1
        
d85 1
a85 1
        
d87 1
a87 1
    
d89 1
a89 1
    
d91 1
a91 1
    
d95 1
a95 1
    
d97 1
a97 1
    
d99 1
a99 1
    
d104 1
a104 1
    
d122 1
a122 1
        
d134 1
a134 1
     
d137 1
a137 1
     
d143 1
a143 1
    
d146 1
a146 1
    
d149 1
a149 1
    
d152 1
a152 1
        
d155 1
a155 1
    
d158 1
a158 1
        
d167 1
a167 1
        
d171 1
a171 1
        
d204 1
a204 3



@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@a0 3
#  Formatter (c) 2002, 2004, 2007 David Turner <david@@freetype.org>
#

d5 2
a6 2
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
d9 1
a9 1
# You need to sub-class it to output anything sensible.  For example,
d11 1
a11 1
# used to output -- you guessed it -- HTML.
d29 1
a29 1

d50 1
a50 1

d58 1
a58 1

d61 1
a61 1

d64 1
a64 1

d67 1
a67 1

d73 1
a73 1

d78 1
a78 1

d82 1
a82 1

d84 1
a84 1

d86 1
a86 1

d88 1
a88 1

d92 1
a92 1

d94 1
a94 1

d96 1
a96 1

d101 1
a101 1

d119 1
a119 1

d131 1
a131 1

d134 1
a134 1

d140 1
a140 1

d143 1
a143 1

d146 1
a146 1

d149 1
a149 1

d152 1
a152 1

d155 1
a155 1

d164 1
a164 1

d168 1
a168 1

d201 3
a203 1
# eof
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d1 1
a1 1
#  Formatter (c) 2002, 2004, 2007, 2008 David Turner <david@@freetype.org>
d17 3
a19 1
class  Formatter:
a20 1
    def  __init__( self, processor ):
d28 1
a28 1
        self.blocks = []
d39 1
d43 2
a44 1
    def  add_identifier( self, name, block ):
d46 2
a47 2
            # duplicate name!
            sys.stderr.write(                                           \
d50 1
a50 1
               self.identifiers[name].location() + "\n" )
d54 1
d58 1
d81 1
d96 1
a96 1
            self.toc_chapter_exit( chap )
d108 1
d122 1
d131 1
a131 1
            self.index_name_exit( name )
d165 1
d167 1
d175 1
a175 1
            block = self.identifiers[name]
d178 1
a178 1
            for markup in block.markups[1:]:   # always ignore first markup!
d183 2
a184 1
                    self.field_exit( field, markup, block )
d190 1
a190 1
        self.section_exit( section )
d195 2
a196 1
    def  section_dump_all( self ):
d200 4
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@we need newer freetype for advance calculation
@
text
@a0 3
#  Formatter (c) 2002, 2004, 2007, 2008 David Turner <david@@freetype.org>
#

d5 2
a6 2
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
d9 1
a9 1
# You need to sub-class it to output anything sensible.  For example,
d11 1
a11 1
# used to output -- you guessed it -- HTML.
d14 3
a16 1
class  Formatter:
a17 1
    def  __init__( self, processor ):
d25 1
a25 1
        self.blocks = []
d29 1
a29 1

d36 1
d40 2
a41 1
    def  add_identifier( self, name, block ):
d43 2
a44 2
            # duplicate name!
            sys.stderr.write(                                           \
d47 1
a47 1
               self.identifiers[name].location() + "\n" )
d50 1
d55 1
d58 1
a58 1

d61 1
a61 1

d64 1
a64 1

d67 1
a67 1

d73 1
a73 1

d78 1
d82 1
a82 1

d84 1
a84 1

d86 1
a86 1

d88 1
a88 1

d92 3
a94 3

            self.toc_chapter_exit( chap )

d96 1
a96 1

d101 1
a101 1

d105 1
d119 1
d128 1
a128 1
            self.index_name_exit( name )
d131 1
a131 1

d134 1
a134 1

d140 1
a140 1

d143 1
a143 1

d146 1
a146 1

d149 1
a149 1

d152 1
a152 1

d155 1
a155 1

d162 1
d164 1
d168 1
a168 1

d172 1
a172 1
            block = self.identifiers[name]
d175 1
a175 1
            for markup in block.markups[1:]:   # always ignore first markup!
d180 2
a181 1
                    self.field_exit( field, markup, block )
d187 1
a187 1
        self.section_exit( section )
d192 2
a193 1
    def  section_dump_all( self ):
d197 7
a203 1
# eof
@


1.1.115.3
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d1 1
a2 23
#  formatter.py
#
#    Convert parsed content blocks to a structured document (library file).
#
#  Copyright 2002-2016 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.

#
# This is the base Formatter class.  Its purpose is to convert a content
# processor's data into specific documents (i.e., table of contents, global
# index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example, the
# file `tohtml.py' contains the definition of the `HtmlFormatter' sub-class
# to output HTML.
#

d8 8
a16 4
################################################################
##
##  FORMATTER CLASS
##
d39 1
a39 6
        self.block_index.sort( key = index_key )

        # also add section names to dictionary (without making them appear
        # in the index)
        for section in self.sections:
            self.add_identifier( section.name, section )
d42 1
a42 1
        if name in self.identifiers:
d44 4
a47 6
            sys.stderr.write( "WARNING: duplicate definition for"
                              + " '" + name + "' "
                              + "in " + block.location() + ", "
                              + "previous definition in "
                              + self.identifiers[name].location()
                              + "\n" )
d52 1
a52 1
    # formatting the table of contents
d100 1
a100 1
    # formatting the index
d131 1
a131 1
    # formatting a section
d165 1
a165 16
            skip_entry = 0
            try:
                block = self.identifiers[name]
                # `block_names' can contain field names also,
                # which we filter out
                for markup in block.markups:
                    if markup.tag == 'values':
                        for field in markup.fields:
                            if field.name == name:
                                skip_entry = 1
            except:
                skip_entry = 1   # this happens e.g. for `/empty/' entries

            if skip_entry:
              continue

@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
