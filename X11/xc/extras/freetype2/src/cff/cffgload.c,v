head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.51;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.35;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.04.57;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.48;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.33;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.37.42;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.10;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.14;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.36.43;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.25;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.04;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  cffgload.c                                                             */
/*                                                                         */
/*    OpenType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_SFNT_H
#include FT_OUTLINE_H
#include FT_CFF_DRIVER_H

#include "cffobjs.h"
#include "cffload.h"
#include "cffgload.h"
#include "cf2ft.h"      /* for cf2_decoder_parse_charstrings */

#include "cfferrs.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cffgload


#ifdef CFF_CONFIG_OPTION_OLD_ENGINE

  typedef enum  CFF_Operator_
  {
    cff_op_unknown = 0,

    cff_op_rmoveto,
    cff_op_hmoveto,
    cff_op_vmoveto,

    cff_op_rlineto,
    cff_op_hlineto,
    cff_op_vlineto,

    cff_op_rrcurveto,
    cff_op_hhcurveto,
    cff_op_hvcurveto,
    cff_op_rcurveline,
    cff_op_rlinecurve,
    cff_op_vhcurveto,
    cff_op_vvcurveto,

    cff_op_flex,
    cff_op_hflex,
    cff_op_hflex1,
    cff_op_flex1,

    cff_op_endchar,

    cff_op_hstem,
    cff_op_vstem,
    cff_op_hstemhm,
    cff_op_vstemhm,

    cff_op_hintmask,
    cff_op_cntrmask,
    cff_op_dotsection,  /* deprecated, acts as no-op */

    cff_op_abs,
    cff_op_add,
    cff_op_sub,
    cff_op_div,
    cff_op_neg,
    cff_op_random,
    cff_op_mul,
    cff_op_sqrt,

    cff_op_blend,

    cff_op_drop,
    cff_op_exch,
    cff_op_index,
    cff_op_roll,
    cff_op_dup,

    cff_op_put,
    cff_op_get,
    cff_op_store,
    cff_op_load,

    cff_op_and,
    cff_op_or,
    cff_op_not,
    cff_op_eq,
    cff_op_ifelse,

    cff_op_callsubr,
    cff_op_callgsubr,
    cff_op_return,

    /* Type 1 opcodes: invalid but seen in real life */
    cff_op_hsbw,
    cff_op_closepath,
    cff_op_callothersubr,
    cff_op_pop,
    cff_op_seac,
    cff_op_sbw,
    cff_op_setcurrentpoint,

    /* do not remove */
    cff_op_max

  } CFF_Operator;


#define CFF_COUNT_CHECK_WIDTH  0x80
#define CFF_COUNT_EXACT        0x40
#define CFF_COUNT_CLEAR_STACK  0x20

  /* count values which have the `CFF_COUNT_CHECK_WIDTH' flag set are  */
  /* used for checking the width and requested numbers of arguments    */
  /* only; they are set to zero afterwards                             */

  /* the other two flags are informative only and unused currently     */

  static const FT_Byte  cff_argument_counts[] =
  {
    0,  /* unknown */

    2 | CFF_COUNT_CHECK_WIDTH | CFF_COUNT_EXACT, /* rmoveto */
    1 | CFF_COUNT_CHECK_WIDTH | CFF_COUNT_EXACT,
    1 | CFF_COUNT_CHECK_WIDTH | CFF_COUNT_EXACT,

    0 | CFF_COUNT_CLEAR_STACK, /* rlineto */
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,

    0 | CFF_COUNT_CLEAR_STACK, /* rrcurveto */
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,
    0 | CFF_COUNT_CLEAR_STACK,

    13, /* flex */
    7,
    9,
    11,

    0 | CFF_COUNT_CHECK_WIDTH, /* endchar */

    2 | CFF_COUNT_CHECK_WIDTH, /* hstem */
    2 | CFF_COUNT_CHECK_WIDTH,
    2 | CFF_COUNT_CHECK_WIDTH,
    2 | CFF_COUNT_CHECK_WIDTH,

    0 | CFF_COUNT_CHECK_WIDTH, /* hintmask */
    0 | CFF_COUNT_CHECK_WIDTH, /* cntrmask */
    0, /* dotsection */

    1, /* abs */
    2,
    2,
    2,
    1,
    0,
    2,
    1,

    1, /* blend */

    1, /* drop */
    2,
    1,
    2,
    1,

    2, /* put */
    1,
    4,
    3,

    2, /* and */
    2,
    1,
    2,
    4,

    1, /* callsubr */
    1,
    0,

    2, /* hsbw */
    0,
    0,
    0,
    5, /* seac */
    4, /* sbw */
    2  /* setcurrentpoint */
  };

#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /**********                                                      *********/
  /**********                                                      *********/
  /**********             GENERIC CHARSTRING PARSING               *********/
  /**********                                                      *********/
  /**********                                                      *********/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    cff_builder_init                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given glyph builder.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    builder :: A pointer to the glyph builder to initialize.           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face    :: The current face object.                                */
  /*                                                                       */
  /*    size    :: The current size object.                                */
  /*                                                                       */
  /*    glyph   :: The current glyph object.                               */
  /*                                                                       */
  /*    hinting :: Whether hinting is active.                              */
  /*                                                                       */
  static void
  cff_builder_init( CFF_Builder*   builder,
                    TT_Face        face,
                    CFF_Size       size,
                    CFF_GlyphSlot  glyph,
                    FT_Bool        hinting )
  {
    builder->path_begun  = 0;
    builder->load_points = 1;

    builder->face   = face;
    builder->glyph  = glyph;
    builder->memory = face->root.memory;

    if ( glyph )
    {
      FT_GlyphLoader  loader = glyph->root.internal->loader;


      builder->loader  = loader;
      builder->base    = &loader->base.outline;
      builder->current = &loader->current.outline;
      FT_GlyphLoader_Rewind( loader );

      builder->hints_globals = NULL;
      builder->hints_funcs   = NULL;

      if ( hinting && size )
      {
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        builder->hints_globals = (void *)internal->topfont;
        builder->hints_funcs   = glyph->root.internal->glyph_hints;
      }
    }

    builder->pos_x = 0;
    builder->pos_y = 0;

    builder->left_bearing.x = 0;
    builder->left_bearing.y = 0;
    builder->advance.x      = 0;
    builder->advance.y      = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    cff_builder_done                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a given glyph builder.  Its contents can still be used   */
  /*    after the call, but the function saves important information       */
  /*    within the corresponding glyph slot.                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    builder :: A pointer to the glyph builder to finalize.             */
  /*                                                                       */
  static void
  cff_builder_done( CFF_Builder*  builder )
  {
    CFF_GlyphSlot  glyph = builder->glyph;


    if ( glyph )
      glyph->root.outline = *builder->base;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    cff_compute_bias                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Computes the bias value in dependence of the number of glyph       */
  /*    subroutines.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    in_charstring_type :: The `CharstringType' value of the top DICT   */
  /*                          dictionary.                                  */
  /*                                                                       */
  /*    num_subrs          :: The number of glyph subroutines.             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The bias value.                                                    */
  static FT_Int
  cff_compute_bias( FT_Int   in_charstring_type,
                    FT_UInt  num_subrs )
  {
    FT_Int  result;


    if ( in_charstring_type == 1 )
      result = 0;
    else if ( num_subrs < 1240 )
      result = 107;
    else if ( num_subrs < 33900U )
      result = 1131;
    else
      result = 32768U;

    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    cff_decoder_init                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given glyph decoder.                                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    decoder :: A pointer to the glyph builder to initialize.           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face      :: The current face object.                              */
  /*                                                                       */
  /*    size      :: The current size object.                              */
  /*                                                                       */
  /*    slot      :: The current glyph object.                             */
  /*                                                                       */
  /*    hinting   :: Whether hinting is active.                            */
  /*                                                                       */
  /*    hint_mode :: The hinting mode.                                     */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;


    /* clear everything */
    FT_ZERO( decoder );

    /* initialize builder */
    cff_builder_init( &decoder->builder, face, size, slot, hinting );

    /* initialize Type2 decoder */
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );

    decoder->hint_mode    = hint_mode;
  }


  /* this function is used to select the subfont */
  /* and the locals subrs array                  */
  FT_LOCAL_DEF( FT_Error )
  cff_decoder_prepare( CFF_Decoder*  decoder,
                       CFF_Size      size,
                       FT_UInt       glyph_index )
  {
    CFF_Builder  *builder = &decoder->builder;
    CFF_Font      cff     = (CFF_Font)builder->face->extra.data;
    CFF_SubFont   sub     = &cff->top_font;
    FT_Error      error   = FT_Err_Ok;


    /* manage CID fonts */
    if ( cff->num_subfonts )
    {
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select, glyph_index );


      if ( fd_index >= cff->num_subfonts )
      {
        FT_TRACE4(( "cff_decoder_prepare: invalid CID subfont index\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      FT_TRACE3(( "  in subfont %d:\n", fd_index ));

      sub = cff->subfonts[fd_index];

      if ( builder->hints_funcs && size )
      {
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        /* for CFFs without subfonts, this value has already been set */
        builder->hints_globals = (void *)internal->subfonts[fd_index];
      }
    }

    decoder->num_locals    = sub->local_subrs_index.count;
    decoder->locals        = sub->local_subrs;
    decoder->locals_bias   = cff_compute_bias(
                               decoder->cff->top_font.font_dict.charstring_type,
                               decoder->num_locals );

    decoder->glyph_width   = sub->private_dict.default_width;
    decoder->nominal_width = sub->private_dict.nominal_width;

    decoder->current_subfont = sub;     /* for Adobe's CFF handler */

  Exit:
    return error;
  }


  /* check that there is enough space for `count' more points */
  FT_LOCAL_DEF( FT_Error )
  cff_check_points( CFF_Builder*  builder,
                    FT_Int        count )
  {
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
  }


  /* add a new point, do not check space */
  FT_LOCAL_DEF( void )
  cff_builder_add_point( CFF_Builder*  builder,
                         FT_Pos        x,
                         FT_Pos        y,
                         FT_Byte       flag )
  {
    FT_Outline*  outline = builder->current;


    if ( builder->load_points )
    {
      FT_Vector*  point   = outline->points + outline->n_points;
      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points;

#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      CFF_Driver  driver  = (CFF_Driver)FT_FACE_DRIVER( builder->face );


      if ( driver->hinting_engine == FT_CFF_HINTING_FREETYPE )
      {
        point->x = x >> 16;
        point->y = y >> 16;
      }
      else
#endif
      {
        /* cf2_decoder_parse_charstrings uses 16.16 coordinates */
        point->x = x >> 10;
        point->y = y >> 10;
      }
      *control = (FT_Byte)( flag ? FT_CURVE_TAG_ON : FT_CURVE_TAG_CUBIC );
    }

    outline->n_points++;
  }


  /* check space for a new on-curve point, then add it */
  FT_LOCAL_DEF( FT_Error )
  cff_builder_add_point1( CFF_Builder*  builder,
                          FT_Pos        x,
                          FT_Pos        y )
  {
    FT_Error  error;


    error = cff_check_points( builder, 1 );
    if ( !error )
      cff_builder_add_point( builder, x, y, 1 );

    return error;
  }


  /* check space for a new contour, then add it */
  static FT_Error
  cff_builder_add_contour( CFF_Builder*  builder )
  {
    FT_Outline*  outline = builder->current;
    FT_Error     error;


    if ( !builder->load_points )
    {
      outline->n_contours++;
      return FT_Err_Ok;
    }

    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
    if ( !error )
    {
      if ( outline->n_contours > 0 )
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );

      outline->n_contours++;
    }

    return error;
  }


  /* if a path was begun, add its first on-curve point */
  FT_LOCAL_DEF( FT_Error )
  cff_builder_start_point( CFF_Builder*  builder,
                           FT_Pos        x,
                           FT_Pos        y )
  {
    FT_Error  error = FT_Err_Ok;


    /* test whether we are building a new contour */
    if ( !builder->path_begun )
    {
      builder->path_begun = 1;
      error = cff_builder_add_contour( builder );
      if ( !error )
        error = cff_builder_add_point1( builder, x, y );
    }

    return error;
  }


  /* close the current contour */
  FT_LOCAL_DEF( void )
  cff_builder_close_contour( CFF_Builder*  builder )
  {
    FT_Outline*  outline = builder->current;
    FT_Int       first;


    if ( !outline )
      return;

    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;

    /* We must not include the last point in the path if it */
    /* is located on the first point.                       */
    if ( outline->n_points > 1 )
    {
      FT_Vector*  p1      = outline->points + first;
      FT_Vector*  p2      = outline->points + outline->n_points - 1;
      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;


      /* `delete' last point only if it coincides with the first    */
      /* point and if it is not a control point (which can happen). */
      if ( p1->x == p2->x && p1->y == p2->y )
        if ( *control == FT_CURVE_TAG_ON )
          outline->n_points--;
    }

    if ( outline->n_contours > 0 )
    {
      /* Don't add contours only consisting of one point, i.e., */
      /* check whether begin point and last point are the same. */
      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
  }


  FT_LOCAL_DEF( FT_Int )
  cff_lookup_glyph_by_stdcharcode( CFF_Font  cff,
                                   FT_Int    charcode )
  {
    FT_UInt    n;
    FT_UShort  glyph_sid;


    /* CID-keyed fonts don't have glyph names */
    if ( !cff->charset.sids )
      return -1;

    /* check range of standard char code */
    if ( charcode < 0 || charcode > 255 )
      return -1;

    /* Get code to SID mapping from `cff_standard_encoding'. */
    glyph_sid = cff_get_standard_encoding( (FT_UInt)charcode );

    for ( n = 0; n < cff->num_glyphs; n++ )
    {
      if ( cff->charset.sids[n] == glyph_sid )
        return (FT_Int)n;
    }

    return -1;
  }


  FT_LOCAL_DEF( FT_Error )
  cff_get_glyph_data( TT_Face    face,
                      FT_UInt    glyph_index,
                      FT_Byte**  pointer,
                      FT_ULong*  length )
  {
#ifdef FT_CONFIG_OPTION_INCREMENTAL
    /* For incremental fonts get the character data using the */
    /* callback function.                                     */
    if ( face->root.internal->incremental_interface )
    {
      FT_Data   data;
      FT_Error  error =
                  face->root.internal->incremental_interface->funcs->get_glyph_data(
                    face->root.internal->incremental_interface->object,
                    glyph_index, &data );


      *pointer = (FT_Byte*)data.pointer;
      *length  = (FT_ULong)data.length;

      return error;
    }
    else
#endif /* FT_CONFIG_OPTION_INCREMENTAL */

    {
      CFF_Font  cff = (CFF_Font)(face->extra.data);


      return cff_index_access_element( &cff->charstrings_index, glyph_index,
                                       pointer, length );
    }
  }


  FT_LOCAL_DEF( void )
  cff_free_glyph_data( TT_Face    face,
                       FT_Byte**  pointer,
                       FT_ULong   length )
  {
#ifndef FT_CONFIG_OPTION_INCREMENTAL
    FT_UNUSED( length );
#endif

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    /* For incremental fonts get the character data using the */
    /* callback function.                                     */
    if ( face->root.internal->incremental_interface )
    {
      FT_Data  data;


      data.pointer = *pointer;
      data.length  = (FT_Int)length;

      face->root.internal->incremental_interface->funcs->free_glyph_data(
        face->root.internal->incremental_interface->object, &data );
    }
    else
#endif /* FT_CONFIG_OPTION_INCREMENTAL */

    {
      CFF_Font  cff = (CFF_Font)(face->extra.data);


      cff_index_forget_element( &cff->charstrings_index, pointer );
    }
  }


#ifdef CFF_CONFIG_OPTION_OLD_ENGINE

  static FT_Error
  cff_operator_seac( CFF_Decoder*  decoder,
                     FT_Pos        asb,
                     FT_Pos        adx,
                     FT_Pos        ady,
                     FT_Int        bchar,
                     FT_Int        achar )
  {
    FT_Error      error;
    CFF_Builder*  builder = &decoder->builder;
    FT_Int        bchar_index, achar_index;
    TT_Face       face = decoder->builder.face;
    FT_Vector     left_bearing, advance;
    FT_Byte*      charstring;
    FT_ULong      charstring_len;
    FT_Pos        glyph_width;


    if ( decoder->seac )
    {
      FT_ERROR(( "cff_operator_seac: invalid nested seac\n" ));
      return FT_THROW( Syntax_Error );
    }

    adx += decoder->builder.left_bearing.x;
    ady += decoder->builder.left_bearing.y;

#ifdef FT_CONFIG_OPTION_INCREMENTAL
    /* Incremental fonts don't necessarily have valid charsets.        */
    /* They use the character code, not the glyph index, in this case. */
    if ( face->root.internal->incremental_interface )
    {
      bchar_index = bchar;
      achar_index = achar;
    }
    else
#endif /* FT_CONFIG_OPTION_INCREMENTAL */
    {
      CFF_Font cff = (CFF_Font)(face->extra.data);


      bchar_index = cff_lookup_glyph_by_stdcharcode( cff, bchar );
      achar_index = cff_lookup_glyph_by_stdcharcode( cff, achar );
    }

    if ( bchar_index < 0 || achar_index < 0 )
    {
      FT_ERROR(( "cff_operator_seac:"
                 " invalid seac character code arguments\n" ));
      return FT_THROW( Syntax_Error );
    }

    /* If we are trying to load a composite glyph, do not load the */
    /* accent character and return the array of subglyphs.         */
    if ( builder->no_recurse )
    {
      FT_GlyphSlot    glyph  = (FT_GlyphSlot)builder->glyph;
      FT_GlyphLoader  loader = glyph->internal->loader;
      FT_SubGlyph     subg;


      /* reallocate subglyph array if necessary */
      error = FT_GlyphLoader_CheckSubGlyphs( loader, 2 );
      if ( error )
        goto Exit;

      subg = loader->current.subglyphs;

      /* subglyph 0 = base character */
      subg->index = bchar_index;
      subg->flags = FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES |
                    FT_SUBGLYPH_FLAG_USE_MY_METRICS;
      subg->arg1  = 0;
      subg->arg2  = 0;
      subg++;

      /* subglyph 1 = accent character */
      subg->index = achar_index;
      subg->flags = FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES;
      subg->arg1  = (FT_Int)( adx >> 16 );
      subg->arg2  = (FT_Int)( ady >> 16 );

      /* set up remaining glyph fields */
      glyph->num_subglyphs = 2;
      glyph->subglyphs     = loader->base.subglyphs;
      glyph->format        = FT_GLYPH_FORMAT_COMPOSITE;

      loader->current.num_subglyphs = 2;
    }

    FT_GlyphLoader_Prepare( builder->loader );

    /* First load `bchar' in builder */
    error = cff_get_glyph_data( face, (FT_UInt)bchar_index,
                                &charstring, &charstring_len );
    if ( !error )
    {
      /* the seac operator must not be nested */
      decoder->seac = TRUE;
      error = cff_decoder_parse_charstrings( decoder, charstring,
                                             charstring_len, 0 );
      decoder->seac = FALSE;

      cff_free_glyph_data( face, &charstring, charstring_len );

      if ( error )
        goto Exit;
    }

    /* Save the left bearing, advance and glyph width of the base */
    /* character as they will be erased by the next load.         */

    left_bearing = builder->left_bearing;
    advance      = builder->advance;
    glyph_width  = decoder->glyph_width;

    builder->left_bearing.x = 0;
    builder->left_bearing.y = 0;

    builder->pos_x = adx - asb;
    builder->pos_y = ady;

    /* Now load `achar' on top of the base outline. */
    error = cff_get_glyph_data( face, (FT_UInt)achar_index,
                                &charstring, &charstring_len );
    if ( !error )
    {
      /* the seac operator must not be nested */
      decoder->seac = TRUE;
      error = cff_decoder_parse_charstrings( decoder, charstring,
                                             charstring_len, 0 );
      decoder->seac = FALSE;

      cff_free_glyph_data( face, &charstring, charstring_len );

      if ( error )
        goto Exit;
    }

    /* Restore the left side bearing, advance and glyph width */
    /* of the base character.                                 */
    builder->left_bearing = left_bearing;
    builder->advance      = advance;
    decoder->glyph_width  = glyph_width;

    builder->pos_x = 0;
    builder->pos_y = 0;

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    cff_decoder_parse_charstrings                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Parses a given Type 2 charstrings program.                         */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    decoder         :: The current Type 1 decoder.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charstring_base :: The base of the charstring stream.              */
  /*                                                                       */
  /*    charstring_len  :: The length in bytes of the charstring stream.   */
  /*                                                                       */
  /*    in_dict         :: Set to 1 if function is called from top or      */
  /*                       private DICT (needed for Multiple Master CFFs). */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  cff_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                 FT_Byte*      charstring_base,
                                 FT_ULong      charstring_len,
                                 FT_Bool       in_dict )
  {
    FT_Error           error;
    CFF_Decoder_Zone*  zone;
    FT_Byte*           ip;
    FT_Byte*           limit;
    CFF_Builder*       builder = &decoder->builder;
    FT_Pos             x, y;
    FT_Fixed           seed;
    FT_Fixed*          stack;
    FT_Int             charstring_type =
                         decoder->cff->top_font.font_dict.charstring_type;
    FT_UShort          num_designs =
                         decoder->cff->top_font.font_dict.num_designs;
    FT_UShort          num_axes =
                         decoder->cff->top_font.font_dict.num_axes;

    T2_Hints_Funcs     hinter;


    /* set default width */
    decoder->num_hints  = 0;
    decoder->read_width = 1;

    /* compute random seed from stack address of parameter */
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
    seed = ( seed ^ ( seed >> 10 ) ^ ( seed >> 20 ) ) & 0xFFFFL;
    if ( seed == 0 )
      seed = 0x7384;

    /* initialize the decoder */
    decoder->top  = decoder->stack;
    decoder->zone = decoder->zones;
    zone          = decoder->zones;
    stack         = decoder->top;

    hinter = (T2_Hints_Funcs)builder->hints_funcs;

    builder->path_begun = 0;

    zone->base           = charstring_base;
    limit = zone->limit  = charstring_base + charstring_len;
    ip    = zone->cursor = zone->base;

    error = FT_Err_Ok;

    x = builder->pos_x;
    y = builder->pos_y;

    /* begin hints recording session, if any */
    if ( hinter )
      hinter->open( hinter->hints );

    /* now execute loop */
    while ( ip < limit )
    {
      CFF_Operator  op;
      FT_Byte       v;


      /********************************************************************/
      /*                                                                  */
      /* Decode operator or operand                                       */
      /*                                                                  */
      v = *ip++;
      if ( v >= 32 || v == 28 )
      {
        FT_Int    shift = 16;
        FT_Int32  val;


        /* this is an operand, push it on the stack */

        /* if we use shifts, all computations are done with unsigned */
        /* values; the conversion to a signed value is the last step */
        if ( v == 28 )
        {
          if ( ip + 1 >= limit )
            goto Syntax_Error;
          val = (FT_Short)( ( (FT_UShort)ip[0] << 8 ) | ip[1] );
          ip += 2;
        }
        else if ( v < 247 )
          val = (FT_Int32)v - 139;
        else if ( v < 251 )
        {
          if ( ip >= limit )
            goto Syntax_Error;
          val = ( (FT_Int32)v - 247 ) * 256 + *ip++ + 108;
        }
        else if ( v < 255 )
        {
          if ( ip >= limit )
            goto Syntax_Error;
          val = -( (FT_Int32)v - 251 ) * 256 - *ip++ - 108;
        }
        else
        {
          if ( ip + 3 >= limit )
            goto Syntax_Error;
          val = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] <<  8 ) |
                              (FT_UInt32)ip[3]         );
          ip    += 4;
          if ( charstring_type == 2 )
            shift = 0;
        }
        if ( decoder->top - stack >= CFF_MAX_OPERANDS )
          goto Stack_Overflow;

        val             = (FT_Int32)( (FT_UInt32)val << shift );
        *decoder->top++ = val;

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( !( val & 0xFFFFL ) )
          FT_TRACE4(( " %hd", (FT_Short)( (FT_UInt32)val >> 16 ) ));
        else
          FT_TRACE4(( " %.5f", val / 65536.0 ));
#endif

      }
      else
      {
        /* The specification says that normally arguments are to be taken */
        /* from the bottom of the stack.  However, this seems not to be   */
        /* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */
        /* arguments similar to a PS interpreter.                         */

        FT_Fixed*  args     = decoder->top;
        FT_Int     num_args = (FT_Int)( args - decoder->stack );
        FT_Int     req_args;


        /* find operator */
        op = cff_op_unknown;

        switch ( v )
        {
        case 1:
          op = cff_op_hstem;
          break;
        case 3:
          op = cff_op_vstem;
          break;
        case 4:
          op = cff_op_vmoveto;
          break;
        case 5:
          op = cff_op_rlineto;
          break;
        case 6:
          op = cff_op_hlineto;
          break;
        case 7:
          op = cff_op_vlineto;
          break;
        case 8:
          op = cff_op_rrcurveto;
          break;
        case 9:
          op = cff_op_closepath;
          break;
        case 10:
          op = cff_op_callsubr;
          break;
        case 11:
          op = cff_op_return;
          break;
        case 12:
          {
            if ( ip >= limit )
              goto Syntax_Error;
            v = *ip++;

            switch ( v )
            {
            case 0:
              op = cff_op_dotsection;
              break;
            case 1: /* this is actually the Type1 vstem3 operator */
              op = cff_op_vstem;
              break;
            case 2: /* this is actually the Type1 hstem3 operator */
              op = cff_op_hstem;
              break;
            case 3:
              op = cff_op_and;
              break;
            case 4:
              op = cff_op_or;
              break;
            case 5:
              op = cff_op_not;
              break;
            case 6:
              op = cff_op_seac;
              break;
            case 7:
              op = cff_op_sbw;
              break;
            case 8:
              op = cff_op_store;
              break;
            case 9:
              op = cff_op_abs;
              break;
            case 10:
              op = cff_op_add;
              break;
            case 11:
              op = cff_op_sub;
              break;
            case 12:
              op = cff_op_div;
              break;
            case 13:
              op = cff_op_load;
              break;
            case 14:
              op = cff_op_neg;
              break;
            case 15:
              op = cff_op_eq;
              break;
            case 16:
              op = cff_op_callothersubr;
              break;
            case 17:
              op = cff_op_pop;
              break;
            case 18:
              op = cff_op_drop;
              break;
            case 20:
              op = cff_op_put;
              break;
            case 21:
              op = cff_op_get;
              break;
            case 22:
              op = cff_op_ifelse;
              break;
            case 23:
              op = cff_op_random;
              break;
            case 24:
              op = cff_op_mul;
              break;
            case 26:
              op = cff_op_sqrt;
              break;
            case 27:
              op = cff_op_dup;
              break;
            case 28:
              op = cff_op_exch;
              break;
            case 29:
              op = cff_op_index;
              break;
            case 30:
              op = cff_op_roll;
              break;
            case 33:
              op = cff_op_setcurrentpoint;
              break;
            case 34:
              op = cff_op_hflex;
              break;
            case 35:
              op = cff_op_flex;
              break;
            case 36:
              op = cff_op_hflex1;
              break;
            case 37:
              op = cff_op_flex1;
              break;
            default:
              FT_TRACE4(( " unknown op (12, %d)\n", v ));
              break;
            }
          }
          break;
        case 13:
          op = cff_op_hsbw;
          break;
        case 14:
          op = cff_op_endchar;
          break;
        case 16:
          op = cff_op_blend;
          break;
        case 18:
          op = cff_op_hstemhm;
          break;
        case 19:
          op = cff_op_hintmask;
          break;
        case 20:
          op = cff_op_cntrmask;
          break;
        case 21:
          op = cff_op_rmoveto;
          break;
        case 22:
          op = cff_op_hmoveto;
          break;
        case 23:
          op = cff_op_vstemhm;
          break;
        case 24:
          op = cff_op_rcurveline;
          break;
        case 25:
          op = cff_op_rlinecurve;
          break;
        case 26:
          op = cff_op_vvcurveto;
          break;
        case 27:
          op = cff_op_hhcurveto;
          break;
        case 29:
          op = cff_op_callgsubr;
          break;
        case 30:
          op = cff_op_vhcurveto;
          break;
        case 31:
          op = cff_op_hvcurveto;
          break;
        default:
          FT_TRACE4(( " unknown op (%d)\n", v ));
          break;
        }

        if ( op == cff_op_unknown )
          continue;

        /* in Multiple Master CFFs, T2 charstrings can appear in */
        /* dictionaries, but some operators are prohibited       */
        if ( in_dict )
        {
          switch ( op )
          {
          case cff_op_hstem:
          case cff_op_vstem:
          case cff_op_vmoveto:
          case cff_op_rlineto:
          case cff_op_hlineto:
          case cff_op_vlineto:
          case cff_op_rrcurveto:
          case cff_op_hstemhm:
          case cff_op_hintmask:
          case cff_op_cntrmask:
          case cff_op_rmoveto:
          case cff_op_hmoveto:
          case cff_op_vstemhm:
          case cff_op_rcurveline:
          case cff_op_rlinecurve:
          case cff_op_vvcurveto:
          case cff_op_hhcurveto:
          case cff_op_vhcurveto:
          case cff_op_hvcurveto:
          case cff_op_hflex:
          case cff_op_flex:
          case cff_op_hflex1:
          case cff_op_flex1:
          case cff_op_callsubr:
          case cff_op_callgsubr:
            goto MM_Error;

          default:
            break;
          }
        }

        /* check arguments */
        req_args = cff_argument_counts[op];
        if ( req_args & CFF_COUNT_CHECK_WIDTH )
        {
          if ( num_args > 0 && decoder->read_width )
          {
            /* If `nominal_width' is non-zero, the number is really a      */
            /* difference against `nominal_width'.  Else, the number here  */
            /* is truly a width, not a difference against `nominal_width'. */
            /* If the font does not set `nominal_width', then              */
            /* `nominal_width' defaults to zero, and so we can set         */
            /* `glyph_width' to `nominal_width' plus number on the stack   */
            /* -- for either case.                                         */

            FT_Int  set_width_ok;


            switch ( op )
            {
            case cff_op_hmoveto:
            case cff_op_vmoveto:
              set_width_ok = num_args & 2;
              break;

            case cff_op_hstem:
            case cff_op_vstem:
            case cff_op_hstemhm:
            case cff_op_vstemhm:
            case cff_op_rmoveto:
            case cff_op_hintmask:
            case cff_op_cntrmask:
              set_width_ok = num_args & 1;
              break;

            case cff_op_endchar:
              /* If there is a width specified for endchar, we either have */
              /* 1 argument or 5 arguments.  We like to argue.             */
              set_width_ok = in_dict
                               ? 0
                               : ( ( num_args == 5 ) || ( num_args == 1 ) );
              break;

            default:
              set_width_ok = 0;
              break;
            }

            if ( set_width_ok )
            {
              decoder->glyph_width = decoder->nominal_width +
                                       ( stack[0] >> 16 );

              if ( decoder->width_only )
              {
                /* we only want the advance width; stop here */
                break;
              }

              /* Consumed an argument. */
              num_args--;
            }
          }

          decoder->read_width = 0;
          req_args            = 0;
        }

        req_args &= 0x000F;
        if ( num_args < req_args )
          goto Stack_Underflow;
        args     -= req_args;
        num_args -= req_args;

        /* At this point, `args' points to the first argument of the  */
        /* operand in case `req_args' isn't zero.  Otherwise, we have */
        /* to adjust `args' manually.                                 */

        /* Note that we only pop arguments from the stack which we    */
        /* really need and can digest so that we can continue in case */
        /* of superfluous stack elements.                             */

        switch ( op )
        {
        case cff_op_hstem:
        case cff_op_vstem:
        case cff_op_hstemhm:
        case cff_op_vstemhm:
          /* the number of arguments is always even here */
          FT_TRACE4((
              op == cff_op_hstem   ? " hstem\n"   :
            ( op == cff_op_vstem   ? " vstem\n"   :
            ( op == cff_op_hstemhm ? " hstemhm\n" : " vstemhm\n" ) ) ));

          if ( hinter )
            hinter->stems( hinter->hints,
                           ( op == cff_op_hstem || op == cff_op_hstemhm ),
                           num_args / 2,
                           args - ( num_args & ~1 ) );

          decoder->num_hints += num_args / 2;
          args = stack;
          break;

        case cff_op_hintmask:
        case cff_op_cntrmask:
          FT_TRACE4(( op == cff_op_hintmask ? " hintmask" : " cntrmask" ));

          /* implement vstem when needed --                        */
          /* the specification doesn't say it, but this also works */
          /* with the 'cntrmask' operator                          */
          /*                                                       */
          if ( num_args > 0 )
          {
            if ( hinter )
              hinter->stems( hinter->hints,
                             0,
                             num_args / 2,
                             args - ( num_args & ~1 ) );

            decoder->num_hints += num_args / 2;
          }

          /* In a valid charstring there must be at least one byte */
          /* after `hintmask' or `cntrmask' (e.g., for a `return'  */
          /* instruction).  Additionally, there must be space for  */
          /* `num_hints' bits.                                     */

          if ( ( ip + ( ( decoder->num_hints + 7 ) >> 3 ) ) >= limit )
            goto Syntax_Error;

          if ( hinter )
          {
            if ( op == cff_op_hintmask )
              hinter->hintmask( hinter->hints,
                                (FT_UInt)builder->current->n_points,
                                (FT_UInt)decoder->num_hints,
                                ip );
            else
              hinter->counter( hinter->hints,
                               (FT_UInt)decoder->num_hints,
                               ip );
          }

#ifdef FT_DEBUG_LEVEL_TRACE
          {
            FT_UInt maskbyte;


            FT_TRACE4(( " (maskbytes:" ));

            for ( maskbyte = 0;
                  maskbyte < (FT_UInt)( ( decoder->num_hints + 7 ) >> 3 );
                  maskbyte++, ip++ )
              FT_TRACE4(( " 0x%02X", *ip ));

            FT_TRACE4(( ")\n" ));
          }
#else
          ip += ( decoder->num_hints + 7 ) >> 3;
#endif
          args = stack;
          break;

        case cff_op_rmoveto:
          FT_TRACE4(( " rmoveto\n" ));

          cff_builder_close_contour( builder );
          builder->path_begun = 0;
          x   += args[-2];
          y   += args[-1];
          args = stack;
          break;

        case cff_op_vmoveto:
          FT_TRACE4(( " vmoveto\n" ));

          cff_builder_close_contour( builder );
          builder->path_begun = 0;
          y   += args[-1];
          args = stack;
          break;

        case cff_op_hmoveto:
          FT_TRACE4(( " hmoveto\n" ));

          cff_builder_close_contour( builder );
          builder->path_begun = 0;
          x   += args[-1];
          args = stack;
          break;

        case cff_op_rlineto:
          FT_TRACE4(( " rlineto\n" ));

          if ( cff_builder_start_point( builder, x, y )  ||
               cff_check_points( builder, num_args / 2 ) )
            goto Fail;

          if ( num_args < 2 )
            goto Stack_Underflow;

          args -= num_args & ~1;
          while ( args < decoder->top )
          {
            x += args[0];
            y += args[1];
            cff_builder_add_point( builder, x, y, 1 );
            args += 2;
          }
          args = stack;
          break;

        case cff_op_hlineto:
        case cff_op_vlineto:
          {
            FT_Int  phase = ( op == cff_op_hlineto );


            FT_TRACE4(( op == cff_op_hlineto ? " hlineto\n"
                                             : " vlineto\n" ));

            if ( num_args < 0 )
              goto Stack_Underflow;

            /* there exist subsetted fonts (found in PDFs) */
            /* which call `hlineto' without arguments      */
            if ( num_args == 0 )
              break;

            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, num_args )    )
              goto Fail;

            args = stack;
            while ( args < decoder->top )
            {
              if ( phase )
                x += args[0];
              else
                y += args[0];

              if ( cff_builder_add_point1( builder, x, y ) )
                goto Fail;

              args++;
              phase ^= 1;
            }
            args = stack;
          }
          break;

        case cff_op_rrcurveto:
          {
            FT_Int  nargs;


            FT_TRACE4(( " rrcurveto\n" ));

            if ( num_args < 6 )
              goto Stack_Underflow;

            nargs = num_args - num_args % 6;

            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, nargs / 2 )   )
              goto Fail;

            args -= nargs;
            while ( args < decoder->top )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[2];
              y += args[3];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[4];
              y += args[5];
              cff_builder_add_point( builder, x, y, 1 );
              args += 6;
            }
            args = stack;
          }
          break;

        case cff_op_vvcurveto:
          {
            FT_Int  nargs;


            FT_TRACE4(( " vvcurveto\n" ));

            if ( num_args < 4 )
              goto Stack_Underflow;

            /* if num_args isn't of the form 4n or 4n+1, */
            /* we enforce it by clearing the second bit  */

            nargs = num_args & ~2;

            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;

            args -= nargs;

            if ( nargs & 1 )
            {
              x += args[0];
              args++;
              nargs--;
            }

            if ( cff_check_points( builder, 3 * ( nargs / 4 ) ) )
              goto Fail;

            while ( args < decoder->top )
            {
              y += args[0];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[1];
              y += args[2];
              cff_builder_add_point( builder, x, y, 0 );
              y += args[3];
              cff_builder_add_point( builder, x, y, 1 );
              args += 4;
            }
            args = stack;
          }
          break;

        case cff_op_hhcurveto:
          {
            FT_Int  nargs;


            FT_TRACE4(( " hhcurveto\n" ));

            if ( num_args < 4 )
              goto Stack_Underflow;

            /* if num_args isn't of the form 4n or 4n+1, */
            /* we enforce it by clearing the second bit  */

            nargs = num_args & ~2;

            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;

            args -= nargs;
            if ( nargs & 1 )
            {
              y += args[0];
              args++;
              nargs--;
            }

            if ( cff_check_points( builder, 3 * ( nargs / 4 ) ) )
              goto Fail;

            while ( args < decoder->top )
            {
              x += args[0];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[1];
              y += args[2];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[3];
              cff_builder_add_point( builder, x, y, 1 );
              args += 4;
            }
            args = stack;
          }
          break;

        case cff_op_vhcurveto:
        case cff_op_hvcurveto:
          {
            FT_Int  phase;
            FT_Int  nargs;


            FT_TRACE4(( op == cff_op_vhcurveto ? " vhcurveto\n"
                                               : " hvcurveto\n" ));

            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;

            if ( num_args < 4 )
              goto Stack_Underflow;

            /* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */
            /* we enforce it by clearing the second bit               */

            nargs = num_args & ~2;

            args -= nargs;
            if ( cff_check_points( builder, ( nargs / 4 ) * 3 ) )
              goto Stack_Underflow;

            phase = ( op == cff_op_hvcurveto );

            while ( nargs >= 4 )
            {
              nargs -= 4;
              if ( phase )
              {
                x += args[0];
                cff_builder_add_point( builder, x, y, 0 );
                x += args[1];
                y += args[2];
                cff_builder_add_point( builder, x, y, 0 );
                y += args[3];
                if ( nargs == 1 )
                  x += args[4];
                cff_builder_add_point( builder, x, y, 1 );
              }
              else
              {
                y += args[0];
                cff_builder_add_point( builder, x, y, 0 );
                x += args[1];
                y += args[2];
                cff_builder_add_point( builder, x, y, 0 );
                x += args[3];
                if ( nargs == 1 )
                  y += args[4];
                cff_builder_add_point( builder, x, y, 1 );
              }
              args  += 4;
              phase ^= 1;
            }
            args = stack;
          }
          break;

        case cff_op_rlinecurve:
          {
            FT_Int  num_lines;
            FT_Int  nargs;


            FT_TRACE4(( " rlinecurve\n" ));

            if ( num_args < 8 )
              goto Stack_Underflow;

            nargs     = num_args & ~1;
            num_lines = ( nargs - 6 ) / 2;

            if ( cff_builder_start_point( builder, x, y )   ||
                 cff_check_points( builder, num_lines + 3 ) )
              goto Fail;

            args -= nargs;

            /* first, add the line segments */
            while ( num_lines > 0 )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y, 1 );
              args += 2;
              num_lines--;
            }

            /* then the curve */
            x += args[0];
            y += args[1];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[2];
            y += args[3];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[4];
            y += args[5];
            cff_builder_add_point( builder, x, y, 1 );
            args = stack;
          }
          break;

        case cff_op_rcurveline:
          {
            FT_Int  num_curves;
            FT_Int  nargs;


            FT_TRACE4(( " rcurveline\n" ));

            if ( num_args < 8 )
              goto Stack_Underflow;

            nargs      = num_args - 2;
            nargs      = nargs - nargs % 6 + 2;
            num_curves = ( nargs - 2 ) / 6;

            if ( cff_builder_start_point( builder, x, y )        ||
                 cff_check_points( builder, num_curves * 3 + 2 ) )
              goto Fail;

            args -= nargs;

            /* first, add the curves */
            while ( num_curves > 0 )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[2];
              y += args[3];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[4];
              y += args[5];
              cff_builder_add_point( builder, x, y, 1 );
              args += 6;
              num_curves--;
            }

            /* then the final line */
            x += args[0];
            y += args[1];
            cff_builder_add_point( builder, x, y, 1 );
            args = stack;
          }
          break;

        case cff_op_hflex1:
          {
            FT_Pos start_y;


            FT_TRACE4(( " hflex1\n" ));

            /* adding five more points: 4 control points, 1 on-curve point */
            /* -- make sure we have enough space for the start point if it */
            /* needs to be added                                           */
            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, 6 )           )
              goto Fail;

            /* record the starting point's y position for later use */
            start_y = y;

            /* first control point */
            x += args[0];
            y += args[1];
            cff_builder_add_point( builder, x, y, 0 );

            /* second control point */
            x += args[2];
            y += args[3];
            cff_builder_add_point( builder, x, y, 0 );

            /* join point; on curve, with y-value the same as the last */
            /* control point's y-value                                 */
            x += args[4];
            cff_builder_add_point( builder, x, y, 1 );

            /* third control point, with y-value the same as the join */
            /* point's y-value                                        */
            x += args[5];
            cff_builder_add_point( builder, x, y, 0 );

            /* fourth control point */
            x += args[6];
            y += args[7];
            cff_builder_add_point( builder, x, y, 0 );

            /* ending point, with y-value the same as the start   */
            x += args[8];
            y  = start_y;
            cff_builder_add_point( builder, x, y, 1 );

            args = stack;
            break;
          }

        case cff_op_hflex:
          {
            FT_Pos start_y;


            FT_TRACE4(( " hflex\n" ));

            /* adding six more points; 4 control points, 2 on-curve points */
            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, 6 )           )
              goto Fail;

            /* record the starting point's y-position for later use */
            start_y = y;

            /* first control point */
            x += args[0];
            cff_builder_add_point( builder, x, y, 0 );

            /* second control point */
            x += args[1];
            y += args[2];
            cff_builder_add_point( builder, x, y, 0 );

            /* join point; on curve, with y-value the same as the last */
            /* control point's y-value                                 */
            x += args[3];
            cff_builder_add_point( builder, x, y, 1 );

            /* third control point, with y-value the same as the join */
            /* point's y-value                                        */
            x += args[4];
            cff_builder_add_point( builder, x, y, 0 );

            /* fourth control point */
            x += args[5];
            y  = start_y;
            cff_builder_add_point( builder, x, y, 0 );

            /* ending point, with y-value the same as the start point's */
            /* y-value -- we don't add this point, though               */
            x += args[6];
            cff_builder_add_point( builder, x, y, 1 );

            args = stack;
            break;
          }

        case cff_op_flex1:
          {
            FT_Pos     start_x, start_y; /* record start x, y values for */
                                         /* alter use                    */
            FT_Fixed   dx = 0, dy = 0;   /* used in horizontal/vertical  */
                                         /* algorithm below              */
            FT_Int     horizontal, count;
            FT_Fixed*  temp;


            FT_TRACE4(( " flex1\n" ));

            /* adding six more points; 4 control points, 2 on-curve points */
            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, 6 )           )
              goto Fail;

            /* record the starting point's x, y position for later use */
            start_x = x;
            start_y = y;

            /* XXX: figure out whether this is supposed to be a horizontal */
            /*      or vertical flex; the Type 2 specification is vague... */

            temp = args;

            /* grab up to the last argument */
            for ( count = 5; count > 0; count-- )
            {
              dx += temp[0];
              dy += temp[1];
              temp += 2;
            }

            if ( dx < 0 )
              dx = -dx;
            if ( dy < 0 )
              dy = -dy;

            /* strange test, but here it is... */
            horizontal = ( dx > dy );

            for ( count = 5; count > 0; count-- )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y,
                                     (FT_Bool)( count == 3 ) );
              args += 2;
            }

            /* is last operand an x- or y-delta? */
            if ( horizontal )
            {
              x += args[0];
              y  = start_y;
            }
            else
            {
              x  = start_x;
              y += args[0];
            }

            cff_builder_add_point( builder, x, y, 1 );

            args = stack;
            break;
           }

        case cff_op_flex:
          {
            FT_UInt  count;


            FT_TRACE4(( " flex\n" ));

            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, 6 )           )
              goto Fail;

            for ( count = 6; count > 0; count-- )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y,
                                     (FT_Bool)( count == 4 || count == 1 ) );
              args += 2;
            }

            args = stack;
          }
          break;

        case cff_op_seac:
            FT_TRACE4(( " seac\n" ));

            error = cff_operator_seac( decoder,
                                       args[0], args[1], args[2],
                                       (FT_Int)( args[3] >> 16 ),
                                       (FT_Int)( args[4] >> 16 ) );

            /* add current outline to the glyph slot */
            FT_GlyphLoader_Add( builder->loader );

            /* return now! */
            FT_TRACE4(( "\n" ));
            return error;

        case cff_op_endchar:
          /* in dictionaries, `endchar' simply indicates end of data */
          if ( in_dict )
            return error;

          FT_TRACE4(( " endchar\n" ));

          /* We are going to emulate the seac operator. */
          if ( num_args >= 4 )
          {
            /* Save glyph width so that the subglyphs don't overwrite it. */
            FT_Pos  glyph_width = decoder->glyph_width;


            error = cff_operator_seac( decoder,
                                       0L, args[-4], args[-3],
                                       (FT_Int)( args[-2] >> 16 ),
                                       (FT_Int)( args[-1] >> 16 ) );

            decoder->glyph_width = glyph_width;
          }
          else
          {
            cff_builder_close_contour( builder );

            /* close hints recording session */
            if ( hinter )
            {
              if ( hinter->close( hinter->hints,
                                  (FT_UInt)builder->current->n_points ) )
                goto Syntax_Error;

              /* apply hints to the loaded glyph outline now */
              error = hinter->apply( hinter->hints,
                                     builder->current,
                                     (PSH_Globals)builder->hints_globals,
                                     decoder->hint_mode );
              if ( error )
                goto Fail;
            }

            /* add current outline to the glyph slot */
            FT_GlyphLoader_Add( builder->loader );
          }

          /* return now! */
          FT_TRACE4(( "\n" ));
          return error;

        case cff_op_abs:
          FT_TRACE4(( " abs\n" ));

          if ( args[0] < 0 )
            args[0] = -args[0];
          args++;
          break;

        case cff_op_add:
          FT_TRACE4(( " add\n" ));

          args[0] += args[1];
          args++;
          break;

        case cff_op_sub:
          FT_TRACE4(( " sub\n" ));

          args[0] -= args[1];
          args++;
          break;

        case cff_op_div:
          FT_TRACE4(( " div\n" ));

          args[0] = FT_DivFix( args[0], args[1] );
          args++;
          break;

        case cff_op_neg:
          FT_TRACE4(( " neg\n" ));

          args[0] = -args[0];
          args++;
          break;

        case cff_op_random:
          {
            FT_Fixed  Rand;


            FT_TRACE4(( " rand\n" ));

            Rand = seed;
            if ( Rand >= 0x8000L )
              Rand++;

            args[0] = Rand;
            seed    = FT_MulFix( seed, 0x10000L - seed );
            if ( seed == 0 )
              seed += 0x2873;
            args++;
          }
          break;

        case cff_op_mul:
          FT_TRACE4(( " mul\n" ));

          args[0] = FT_MulFix( args[0], args[1] );
          args++;
          break;

        case cff_op_sqrt:
          FT_TRACE4(( " sqrt\n" ));

          if ( args[0] > 0 )
          {
            FT_Fixed  root = args[0];
            FT_Fixed  new_root;


            for (;;)
            {
              new_root = ( root + FT_DivFix( args[0], root ) + 1 ) >> 1;
              if ( new_root == root )
                break;
              root = new_root;
            }
            args[0] = new_root;
          }
          else
            args[0] = 0;
          args++;
          break;

        case cff_op_drop:
          /* nothing */
          FT_TRACE4(( " drop\n" ));

          break;

        case cff_op_exch:
          {
            FT_Fixed  tmp;


            FT_TRACE4(( " exch\n" ));

            tmp     = args[0];
            args[0] = args[1];
            args[1] = tmp;
            args   += 2;
          }
          break;

        case cff_op_index:
          {
            FT_Int  idx = (FT_Int)( args[0] >> 16 );


            FT_TRACE4(( " index\n" ));

            if ( idx < 0 )
              idx = 0;
            else if ( idx > num_args - 2 )
              idx = num_args - 2;
            args[0] = args[-( idx + 1 )];
            args++;
          }
          break;

        case cff_op_roll:
          {
            FT_Int  count = (FT_Int)( args[0] >> 16 );
            FT_Int  idx   = (FT_Int)( args[1] >> 16 );


            FT_TRACE4(( " roll\n" ));

            if ( count <= 0 )
              count = 1;

            args -= count;
            if ( args < stack )
              goto Stack_Underflow;

            if ( idx >= 0 )
            {
              while ( idx > 0 )
              {
                FT_Fixed  tmp = args[count - 1];
                FT_Int    i;


                for ( i = count - 2; i >= 0; i-- )
                  args[i + 1] = args[i];
                args[0] = tmp;
                idx--;
              }
            }
            else
            {
              while ( idx < 0 )
              {
                FT_Fixed  tmp = args[0];
                FT_Int    i;


                for ( i = 0; i < count - 1; i++ )
                  args[i] = args[i + 1];
                args[count - 1] = tmp;
                idx++;
              }
            }
            args += count;
          }
          break;

        case cff_op_dup:
          FT_TRACE4(( " dup\n" ));

          args[1] = args[0];
          args += 2;
          break;

        case cff_op_put:
          {
            FT_Fixed  val = args[0];
            FT_Int    idx = (FT_Int)( args[1] >> 16 );


            FT_TRACE4(( " put\n" ));

            /* the Type2 specification before version 16-March-2000 */
            /* didn't give a hard-coded size limit of the temporary */
            /* storage array; instead, an argument of the           */
            /* `MultipleMaster' operator set the size               */
            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )
              decoder->buildchar[idx] = val;
          }
          break;

        case cff_op_get:
          {
            FT_Int    idx = (FT_Int)( args[0] >> 16 );
            FT_Fixed  val = 0;


            FT_TRACE4(( " get\n" ));

            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )
              val = decoder->buildchar[idx];

            args[0] = val;
            args++;
          }
          break;

        case cff_op_store:
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */

          /* since we currently don't handle interpolation of multiple */
          /* master fonts, this is a no-op                             */
          FT_TRACE4(( " store\n"));
          break;

        case cff_op_load:
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */
          {
            FT_Int  reg_idx = (FT_Int)args[0];
            FT_Int  idx     = (FT_Int)args[1];
            FT_Int  count   = (FT_Int)args[2];


            FT_TRACE4(( " load\n" ));

            /* since we currently don't handle interpolation of multiple */
            /* master fonts, we store a vector [1 0 0 ...] in the        */
            /* temporary storage array regardless of the Registry index  */
            if ( reg_idx >= 0 && reg_idx <= 2             &&
                 idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS &&
                 count >= 0 && count <= num_axes          )
            {
              FT_Int  end, i;


              end = FT_MIN( idx + count, CFF_MAX_TRANS_ELEMENTS );

              if ( idx < end )
                decoder->buildchar[idx] = 1 << 16;

              for ( i = idx + 1; i < end; i++ )
                decoder->buildchar[i] = 0;
            }
          }
          break;

        case cff_op_blend:
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */
          {
            FT_Int  num_results = (FT_Int)( args[0] >> 16 );


            FT_TRACE4(( " blend\n" ));

            if ( num_results < 0 )
              goto Syntax_Error;

            if ( num_results * (FT_Int)num_designs > num_args )
              goto Stack_Underflow;

            /* since we currently don't handle interpolation of multiple */
            /* master fonts, return the `num_results' values of the      */
            /* first master                                              */
            args     -= num_results * ( num_designs - 1 );
            num_args -= num_results * ( num_designs - 1 );
          }
          break;

        case cff_op_dotsection:
          /* this operator is deprecated and ignored by the parser */
          FT_TRACE4(( " dotsection\n" ));
          break;

        case cff_op_closepath:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " closepath (invalid op)\n" ));

          args = stack;
          break;

        case cff_op_hsbw:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " hsbw (invalid op)\n" ));

          decoder->glyph_width = decoder->nominal_width + ( args[1] >> 16 );

          decoder->builder.left_bearing.x = args[0];
          decoder->builder.left_bearing.y = 0;

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y;
          args = stack;
          break;

        case cff_op_sbw:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " sbw (invalid op)\n" ));

          decoder->glyph_width = decoder->nominal_width + ( args[2] >> 16 );

          decoder->builder.left_bearing.x = args[0];
          decoder->builder.left_bearing.y = args[1];

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y + args[1];
          args = stack;
          break;

        case cff_op_setcurrentpoint:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " setcurrentpoint (invalid op)\n" ));

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y + args[1];
          args = stack;
          break;

        case cff_op_callothersubr:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " callothersubr (invalid op)\n" ));

          /* subsequent `pop' operands should add the arguments,       */
          /* this is the implementation described for `unknown' other  */
          /* subroutines in the Type1 spec.                            */
          /*                                                           */
          /* XXX Fix return arguments (see discussion below).          */
          args -= 2 + ( args[-2] >> 16 );
          if ( args < stack )
            goto Stack_Underflow;
          break;

        case cff_op_pop:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " pop (invalid op)\n" ));

          /* XXX Increasing `args' is wrong: After a certain number of */
          /* `pop's we get a stack overflow.  Reason for doing it is   */
          /* code like this (actually found in a CFF font):            */
          /*                                                           */
          /*   17 1 3 callothersubr                                    */
          /*   pop                                                     */
          /*   callsubr                                                */
          /*                                                           */
          /* Since we handle `callothersubr' as a no-op, and           */
          /* `callsubr' needs at least one argument, `pop' can't be a  */
          /* no-op too as it basically should be.                      */
          /*                                                           */
          /* The right solution would be to provide real support for   */
          /* `callothersubr' as done in `t1decode.c', however, given   */
          /* the fact that CFF fonts with `pop' are invalid, it is     */
          /* questionable whether it is worth the time.                */
          args++;
          break;

        case cff_op_and:
          {
            FT_Fixed  cond = ( args[0] && args[1] );


            FT_TRACE4(( " and\n" ));

            args[0] = cond ? 0x10000L : 0;
            args++;
          }
          break;

        case cff_op_or:
          {
            FT_Fixed  cond = ( args[0] || args[1] );


            FT_TRACE4(( " or\n" ));

            args[0] = cond ? 0x10000L : 0;
            args++;
          }
          break;

        case cff_op_not:
          {
            FT_Fixed  cond = !args[0];


            FT_TRACE4(( " not\n" ));

            args[0] = cond ? 0x10000L : 0;
            args++;
          }
          break;

        case cff_op_eq:
          {
            FT_Fixed  cond = ( args[0] == args[1] );


            FT_TRACE4(( " eq\n" ));

            args[0] = cond ? 0x10000L : 0;
            args++;
          }
          break;

        case cff_op_ifelse:
          {
            FT_Fixed  cond = ( args[2] <= args[3] );


            FT_TRACE4(( " ifelse\n" ));

            if ( !cond )
              args[0] = args[1];
            args++;
          }
          break;

        case cff_op_callsubr:
          {
            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +
                                      decoder->locals_bias );


            FT_TRACE4(( " callsubr (idx %d, entering level %d)\n",
                        idx,
                        zone - decoder->zones + 1 ));

            if ( idx >= decoder->num_locals )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invalid local subr index\n" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " too many nested subrs\n" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;
            zone->base   = decoder->locals[idx];
            zone->limit  = decoder->locals[idx + 1];
            zone->cursor = zone->base;

            if ( !zone->base || zone->limit == zone->base )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invoking empty subrs\n" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
          }
          break;

        case cff_op_callgsubr:
          {
            FT_UInt  idx = (FT_UInt)( ( args[0] >> 16 ) +
                                      decoder->globals_bias );


            FT_TRACE4(( " callgsubr (idx %d, entering level %d)\n",
                        idx,
                        zone - decoder->zones + 1 ));

            if ( idx >= decoder->num_globals )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invalid global subr index\n" ));
              goto Syntax_Error;
            }

            if ( zone - decoder->zones >= CFF_MAX_SUBRS_CALLS )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " too many nested subrs\n" ));
              goto Syntax_Error;
            }

            zone->cursor = ip;  /* save current instruction pointer */

            zone++;
            zone->base   = decoder->globals[idx];
            zone->limit  = decoder->globals[idx + 1];
            zone->cursor = zone->base;

            if ( !zone->base || zone->limit == zone->base )
            {
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invoking empty subrs\n" ));
              goto Syntax_Error;
            }

            decoder->zone = zone;
            ip            = zone->base;
            limit         = zone->limit;
          }
          break;

        case cff_op_return:
          FT_TRACE4(( " return (leaving level %d)\n",
                      decoder->zone - decoder->zones ));

          if ( decoder->zone <= decoder->zones )
          {
            FT_ERROR(( "cff_decoder_parse_charstrings:"
                       " unexpected return\n" ));
            goto Syntax_Error;
          }

          decoder->zone--;
          zone  = decoder->zone;
          ip    = zone->cursor;
          limit = zone->limit;
          break;

        default:
          FT_ERROR(( "Unimplemented opcode: %d", ip[-1] ));

          if ( ip[-1] == 12 )
            FT_ERROR(( " %d", ip[0] ));
          FT_ERROR(( "\n" ));

          return FT_THROW( Unimplemented_Feature );
        }

        decoder->top = args;

        if ( decoder->top - stack >= CFF_MAX_OPERANDS )
          goto Stack_Overflow;

      } /* general operator processing */

    } /* while ip < limit */

    FT_TRACE4(( "..end..\n\n" ));

  Fail:
    return error;

  MM_Error:
    FT_TRACE4(( "cff_decoder_parse_charstrings:"
                " invalid opcode found in top DICT charstring\n"));
    return FT_THROW( Invalid_File_Format );

  Syntax_Error:
    FT_TRACE4(( "cff_decoder_parse_charstrings: syntax error\n" ));
    return FT_THROW( Invalid_File_Format );

  Stack_Underflow:
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack underflow\n" ));
    return FT_THROW( Too_Few_Arguments );

  Stack_Overflow:
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack overflow\n" ));
    return FT_THROW( Stack_Overflow );
  }

#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /**********                                                      *********/
  /**********                                                      *********/
  /**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
  /**********                                                      *********/
  /**********    The following code is in charge of computing      *********/
  /**********    the maximum advance width of the font.  It        *********/
  /**********    quickly processes each glyph charstring to        *********/
  /**********    extract the value from either a `sbw' or `seac'   *********/
  /**********    operator.                                         *********/
  /**********                                                      *********/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


#if 0 /* unused until we support pure CFF fonts */


  FT_LOCAL_DEF( FT_Error )
  cff_compute_max_advance( TT_Face  face,
                           FT_Int*  max_advance )
  {
    FT_Error     error = FT_Err_Ok;
    CFF_Decoder  decoder;
    FT_Int       glyph_index;
    CFF_Font     cff = (CFF_Font)face->other;


    *max_advance = 0;

    /* Initialize load decoder */
    cff_decoder_init( &decoder, face, 0, 0, 0, 0 );

    decoder.builder.metrics_only = 1;
    decoder.builder.load_points  = 0;

    /* For each glyph, parse the glyph charstring and extract */
    /* the advance width.                                     */
    for ( glyph_index = 0; glyph_index < face->root.num_glyphs;
          glyph_index++ )
    {
      FT_Byte*  charstring;
      FT_ULong  charstring_len;


      /* now get load the unscaled outline */
      error = cff_get_glyph_data( face, glyph_index,
                                  &charstring, &charstring_len );
      if ( !error )
      {
        error = cff_decoder_prepare( &decoder, size, glyph_index );
        if ( !error )
          error = cff_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len,
                                                 0 );

        cff_free_glyph_data( face, &charstring, &charstring_len );
      }

      /* ignore the error if one has occurred -- skip to next glyph */
      error = FT_Err_Ok;
    }

    *max_advance = decoder.builder.advance.x;

    return FT_Err_Ok;
  }


#endif /* 0 */


  FT_LOCAL_DEF( FT_Error )
  cff_slot_load( CFF_GlyphSlot  glyph,
                 CFF_Size       size,
                 FT_UInt        glyph_index,
                 FT_Int32       load_flags )
  {
    FT_Error     error;
    CFF_Decoder  decoder;
    TT_Face      face = (TT_Face)glyph->root.face;
    FT_Bool      hinting, scaled, force_scaling;
    CFF_Font     cff  = (CFF_Font)face->extra.data;

    FT_Matrix    font_matrix;
    FT_Vector    font_offset;


    force_scaling = FALSE;

    /* in a CID-keyed font, consider `glyph_index' as a CID and map */
    /* it immediately to the real glyph_index -- if it isn't a      */
    /* subsetted font, glyph_indices and CIDs are identical, though */
    if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
         cff->charset.cids                               )
    {
      /* don't handle CID 0 (.notdef) which is directly mapped to GID 0 */
      if ( glyph_index != 0 )
      {
        glyph_index = cff_charset_cid_to_gindex( &cff->charset,
                                                 glyph_index );
        if ( glyph_index == 0 )
          return FT_THROW( Invalid_Argument );
      }
    }
    else if ( glyph_index >= cff->num_glyphs )
      return FT_THROW( Invalid_Argument );

    if ( load_flags & FT_LOAD_NO_RECURSE )
      load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;

    glyph->x_scale = 0x10000L;
    glyph->y_scale = 0x10000L;
    if ( size )
    {
      glyph->x_scale = size->root.metrics.x_scale;
      glyph->y_scale = size->root.metrics.y_scale;
    }

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    /* try to load embedded bitmap if any              */
    /*                                                 */
    /* XXX: The convention should be emphasized in     */
    /*      the documents because it can be confusing. */
    if ( size )
    {
      CFF_Face      cff_face = (CFF_Face)size->root.face;
      SFNT_Service  sfnt     = (SFNT_Service)cff_face->sfnt;
      FT_Stream     stream   = cff_face->root.stream;


      if ( size->strike_index != 0xFFFFFFFFUL      &&
           sfnt->load_eblc                         &&
           ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )
      {
        TT_SBit_MetricsRec  metrics;


        error = sfnt->load_sbit_image( face,
                                       size->strike_index,
                                       glyph_index,
                                       (FT_UInt)load_flags,
                                       stream,
                                       &glyph->root.bitmap,
                                       &metrics );

        if ( !error )
        {
          FT_Bool    has_vertical_info;
          FT_UShort  advance;
          FT_Short   dummy;


          glyph->root.outline.n_points   = 0;
          glyph->root.outline.n_contours = 0;

          glyph->root.metrics.width  = (FT_Pos)metrics.width  << 6;
          glyph->root.metrics.height = (FT_Pos)metrics.height << 6;

          glyph->root.metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
          glyph->root.metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
          glyph->root.metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  << 6;

          glyph->root.metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
          glyph->root.metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
          glyph->root.metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  << 6;

          glyph->root.format = FT_GLYPH_FORMAT_BITMAP;

          if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
          {
            glyph->root.bitmap_left = metrics.vertBearingX;
            glyph->root.bitmap_top  = metrics.vertBearingY;
          }
          else
          {
            glyph->root.bitmap_left = metrics.horiBearingX;
            glyph->root.bitmap_top  = metrics.horiBearingY;
          }

          /* compute linear advance widths */

          (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                           glyph_index,
                                                           &dummy,
                                                           &advance );
          glyph->root.linearHoriAdvance = advance;

          has_vertical_info = FT_BOOL(
                                face->vertical_info                   &&
                                face->vertical.number_Of_VMetrics > 0 );

          /* get the vertical metrics from the vmtx table if we have one */
          if ( has_vertical_info )
          {
            (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                             glyph_index,
                                                             &dummy,
                                                             &advance );
            glyph->root.linearVertAdvance = advance;
          }
          else
          {
            /* make up vertical ones */
            if ( face->os2.version != 0xFFFFU )
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->os2.sTypoAscender - face->os2.sTypoDescender );
            else
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->horizontal.Ascender - face->horizontal.Descender );
          }

          return error;
        }
      }
    }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    /* return immediately if we only want the embedded bitmaps */
    if ( load_flags & FT_LOAD_SBITS_ONLY )
      return FT_THROW( Invalid_Argument );

    /* if we have a CID subfont, use its matrix (which has already */
    /* been multiplied with the root matrix)                       */

    /* this scaling is only relevant if the PS hinter isn't active */
    if ( cff->num_subfonts )
    {
      FT_Long  top_upm, sub_upm;
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select,
                                             glyph_index );


      if ( fd_index >= cff->num_subfonts )
        fd_index = (FT_Byte)( cff->num_subfonts - 1 );

      top_upm = (FT_Long)cff->top_font.font_dict.units_per_em;
      sub_upm = (FT_Long)cff->subfonts[fd_index]->font_dict.units_per_em;


      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;

      if ( top_upm != sub_upm )
      {
        glyph->x_scale = FT_MulDiv( glyph->x_scale, top_upm, sub_upm );
        glyph->y_scale = FT_MulDiv( glyph->y_scale, top_upm, sub_upm );

        force_scaling = TRUE;
      }
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }

    glyph->root.outline.n_points   = 0;
    glyph->root.outline.n_contours = 0;

    /* top-level code ensures that FT_LOAD_NO_HINTING is set */
    /* if FT_LOAD_NO_SCALE is active                         */
    hinting = FT_BOOL( ( load_flags & FT_LOAD_NO_HINTING ) == 0 );
    scaled  = FT_BOOL( ( load_flags & FT_LOAD_NO_SCALE   ) == 0 );

    glyph->hint        = hinting;
    glyph->scaled      = scaled;
    glyph->root.format = FT_GLYPH_FORMAT_OUTLINE;  /* by default */

    {
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      CFF_Driver  driver = (CFF_Driver)FT_FACE_DRIVER( face );
#endif


      FT_Byte*  charstring;
      FT_ULong  charstring_len;


      cff_decoder_init( &decoder, face, size, glyph, hinting,
                        FT_LOAD_TARGET_MODE( load_flags ) );

      /* this is for pure CFFs */
      if ( load_flags & FT_LOAD_ADVANCE_ONLY )
        decoder.width_only = TRUE;

      decoder.builder.no_recurse =
        (FT_Bool)( load_flags & FT_LOAD_NO_RECURSE );

      /* now load the unscaled outline */
      error = cff_get_glyph_data( face, glyph_index,
                                  &charstring, &charstring_len );
      if ( error )
        goto Glyph_Build_Finished;

      error = cff_decoder_prepare( &decoder, size, glyph_index );
      if ( error )
        goto Glyph_Build_Finished;

#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      /* choose which CFF renderer to use */
      if ( driver->hinting_engine == FT_CFF_HINTING_FREETYPE )
        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring,
                                               charstring_len,
                                               0 );
      else
#endif
      {
        error = cf2_decoder_parse_charstrings( &decoder,
                                               charstring,
                                               charstring_len );

        /* Adobe's engine uses 16.16 numbers everywhere;              */
        /* as a consequence, glyphs larger than 2000ppem get rejected */
        if ( FT_ERR_EQ( error, Glyph_Too_Big ) )
        {
          /* this time, we retry unhinted and scale up the glyph later on */
          /* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
          /* 0x400 for both `x_scale' and `y_scale' in this case)         */
          hinting       = FALSE;
          force_scaling = TRUE;
          glyph->hint   = hinting;

          error = cf2_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
        }
      }

      cff_free_glyph_data( face, &charstring, charstring_len );

      if ( error )
        goto Glyph_Build_Finished;

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* Control data and length may not be available for incremental */
      /* fonts.                                                       */
      if ( face->root.internal->incremental_interface )
      {
        glyph->root.control_data = NULL;
        glyph->root.control_len = 0;
      }
      else
#endif /* FT_CONFIG_OPTION_INCREMENTAL */

      /* We set control_data and control_len if charstrings is loaded. */
      /* See how charstring loads at cff_index_access_element() in     */
      /* cffload.c.                                                    */
      {
        CFF_Index  csindex = &cff->charstrings_index;


        if ( csindex->offsets )
        {
          glyph->root.control_data = csindex->bytes +
                                     csindex->offsets[glyph_index] - 1;
          glyph->root.control_len  = (FT_Long)charstring_len;
        }
      }

  Glyph_Build_Finished:
      /* save new glyph tables, if no error */
      if ( !error )
        cff_builder_done( &decoder.builder );
      /* XXX: anything to do for broken glyph entry? */
    }

#ifdef FT_CONFIG_OPTION_INCREMENTAL

    /* Incremental fonts can optionally override the metrics. */
    if ( !error                                                               &&
         face->root.internal->incremental_interface                           &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec  metrics;


      metrics.bearing_x = decoder.builder.left_bearing.x;
      metrics.bearing_y = 0;
      metrics.advance   = decoder.builder.advance.x;
      metrics.advance_v = decoder.builder.advance.y;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, FALSE, &metrics );

      decoder.builder.left_bearing.x = metrics.bearing_x;
      decoder.builder.advance.x      = metrics.advance;
      decoder.builder.advance.y      = metrics.advance_v;
    }

#endif /* FT_CONFIG_OPTION_INCREMENTAL */

    if ( !error )
    {
      /* Now, set the metrics -- this is rather simple, as   */
      /* the left side bearing is the xMin, and the top side */
      /* bearing the yMax.                                   */

      /* For composite glyphs, return only left side bearing and */
      /* advance width.                                          */
      if ( load_flags & FT_LOAD_NO_RECURSE )
      {
        FT_Slot_Internal  internal = glyph->root.internal;


        glyph->root.metrics.horiBearingX = decoder.builder.left_bearing.x;
        glyph->root.metrics.horiAdvance  = decoder.glyph_width;
        internal->glyph_matrix           = font_matrix;
        internal->glyph_delta            = font_offset;
        internal->glyph_transformed      = 1;
      }
      else
      {
        FT_BBox            cbox;
        FT_Glyph_Metrics*  metrics = &glyph->root.metrics;
        FT_Bool            has_vertical_info;


        if ( face->horizontal.number_Of_HMetrics )
        {
          FT_Short   horiBearingX = 0;
          FT_UShort  horiAdvance  = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                     glyph_index,
                                                     &horiBearingX,
                                                     &horiAdvance );
          metrics->horiAdvance          = horiAdvance;
          metrics->horiBearingX         = horiBearingX;
          glyph->root.linearHoriAdvance = horiAdvance;
        }
        else
        {
          /* copy the _unscaled_ advance width */
          metrics->horiAdvance          = decoder.glyph_width;
          glyph->root.linearHoriAdvance = decoder.glyph_width;
        }

        glyph->root.internal->glyph_transformed = 0;

        has_vertical_info = FT_BOOL( face->vertical_info                   &&
                                     face->vertical.number_Of_VMetrics > 0 );

        /* get the vertical metrics from the vmtx table if we have one */
        if ( has_vertical_info )
        {
          FT_Short   vertBearingY = 0;
          FT_UShort  vertAdvance  = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                     glyph_index,
                                                     &vertBearingY,
                                                     &vertAdvance );
          metrics->vertBearingY = vertBearingY;
          metrics->vertAdvance  = vertAdvance;
        }
        else
        {
          /* make up vertical ones */
          if ( face->os2.version != 0xFFFFU )
            metrics->vertAdvance = (FT_Pos)( face->os2.sTypoAscender -
                                             face->os2.sTypoDescender );
          else
            metrics->vertAdvance = (FT_Pos)( face->horizontal.Ascender -
                                             face->horizontal.Descender );
        }

        glyph->root.linearVertAdvance = metrics->vertAdvance;

        glyph->root.format = FT_GLYPH_FORMAT_OUTLINE;

        glyph->root.outline.flags = 0;
        if ( size && size->root.metrics.y_ppem < 24 )
          glyph->root.outline.flags |= FT_OUTLINE_HIGH_PRECISION;

        glyph->root.outline.flags |= FT_OUTLINE_REVERSE_FILL;

        /* apply the font matrix, if any */
        if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
             font_matrix.xy != 0        || font_matrix.yx != 0        )
        {
          FT_Outline_Transform( &glyph->root.outline, &font_matrix );

          metrics->horiAdvance = FT_MulFix( metrics->horiAdvance,
                                            font_matrix.xx );
          metrics->vertAdvance = FT_MulFix( metrics->vertAdvance,
                                            font_matrix.yy );
        }

        if ( font_offset.x || font_offset.y )
        {
          FT_Outline_Translate( &glyph->root.outline,
                                font_offset.x,
                                font_offset.y );

          metrics->horiAdvance += font_offset.x;
          metrics->vertAdvance += font_offset.y;
        }

        if ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 || force_scaling )
        {
          /* scale the outline and the metrics */
          FT_Int       n;
          FT_Outline*  cur     = &glyph->root.outline;
          FT_Vector*   vec     = cur->points;
          FT_Fixed     x_scale = glyph->x_scale;
          FT_Fixed     y_scale = glyph->y_scale;


          /* First of all, scale the points */
          if ( !hinting || !decoder.builder.hints_funcs )
            for ( n = cur->n_points; n > 0; n--, vec++ )
            {
              vec->x = FT_MulFix( vec->x, x_scale );
              vec->y = FT_MulFix( vec->y, y_scale );
            }

          /* Then scale the metrics */
          metrics->horiAdvance = FT_MulFix( metrics->horiAdvance, x_scale );
          metrics->vertAdvance = FT_MulFix( metrics->vertAdvance, y_scale );
        }

        /* compute the other metrics */
        FT_Outline_Get_CBox( &glyph->root.outline, &cbox );

        metrics->width  = cbox.xMax - cbox.xMin;
        metrics->height = cbox.yMax - cbox.yMin;

        metrics->horiBearingX = cbox.xMin;
        metrics->horiBearingY = cbox.yMax;

        if ( has_vertical_info )
          metrics->vertBearingX = metrics->horiBearingX -
                                    metrics->horiAdvance / 2;
        else
        {
          if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
            ft_synthesize_vertical_metrics( metrics,
                                            metrics->vertAdvance );
        }
      }
    }

    return error;
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d24 1
a24 1
#include FT_INTERNAL_POSTSCRIPT_HINTS_H
d29 1
d44 2
d216 2
d276 2
a277 2
      builder->hints_globals = 0;
      builder->hints_funcs   = 0;
d394 1
a394 1
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );
d401 1
a401 1
    decoder->num_globals  = cff->num_global_subrs;
d421 1
a421 1
    FT_Error      error   = CFF_Err_Ok;
d433 1
a433 1
        error = CFF_Err_Invalid_File_Format;
d437 1
a437 1
      FT_TRACE4(( "glyph index %d (subfont %d):\n", glyph_index, fd_index ));
a449 4
#ifdef FT_DEBUG_LEVEL_TRACE
    else
      FT_TRACE4(( "glyph index %d:\n", glyph_index ));
#endif
d451 1
a451 1
    decoder->num_locals    = sub->num_local_subrs;
d460 2
d468 3
a470 3
  static FT_Error
  check_points( CFF_Builder*  builder,
                FT_Int        count )
d477 1
a477 1
  static void
d491 3
d495 12
a506 2
      point->x = x >> 16;
      point->y = y >> 16;
d515 1
a515 1
  static FT_Error
d523 1
a523 1
    error = check_points( builder, 1 );
d542 1
a542 1
      return CFF_Err_Ok;
d560 1
a560 1
  static FT_Error
d565 1
a565 1
    FT_Error  error = CFF_Err_Ok;
d582 1
a582 1
  static void
d627 1
a627 1
  static FT_Int
d649 1
a649 1
        return n;
d656 1
a656 1
  static FT_Error
d675 1
a675 1
      *length = data.length;
d683 1
a683 1
      CFF_Font  cff  = (CFF_Font)(face->extra.data);
d692 1
a692 1
  static void
d706 1
a706 1
      FT_Data data;
d710 1
a710 1
      data.length  = length;
d727 2
d750 1
a750 1
      return CFF_Err_Syntax_Error;
d778 1
a778 1
      return CFF_Err_Syntax_Error;
d822 1
a822 1
    error = cff_get_glyph_data( face, bchar_index,
d829 1
a829 1
                                             charstring_len );
d832 2
a835 2

      cff_free_glyph_data( face, &charstring, charstring_len );
d852 1
a852 1
    error = cff_get_glyph_data( face, achar_index,
d859 1
a859 1
                                             charstring_len );
d862 2
a865 2

      cff_free_glyph_data( face, &charstring, charstring_len );
d898 3
d907 2
a908 1
                                 FT_ULong      charstring_len )
d920 4
d933 4
a936 4
    seed = (FT_Fixed)( ( (FT_PtrDist)(char*)&seed              ^
                         (FT_PtrDist)(char*)&decoder           ^
                         (FT_PtrDist)(char*)&charstring_base ) &
                         FT_ULONG_MAX ) ;
d955 1
a955 1
    error = CFF_Err_Ok;
d983 3
d990 1
a990 1
          val = (FT_Short)( ( (FT_Short)ip[0] << 8 ) | ip[1] );
d1011 4
a1014 4
          val = ( (FT_Int32)ip[0] << 24 ) |
                ( (FT_Int32)ip[1] << 16 ) |
                ( (FT_Int32)ip[2] <<  8 ) |
                            ip[3];
d1022 1
a1022 1
        val           <<= shift;
d1027 1
a1027 1
          FT_TRACE4(( " %ld", (FT_Int32)( val >> 16 ) ));
d1029 1
a1029 1
          FT_TRACE4(( " %.2f", val / 65536.0 ));
d1191 2
a1192 2
              /* decrement ip for syntax error message */
              ip--;
d1245 1
d1250 39
a1288 1
          goto Syntax_Error;
d1327 3
a1329 1
              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );
d1412 8
d1424 2
a1425 2
                                builder->current->n_points,
                                decoder->num_hints,
d1429 1
a1429 1
                               decoder->num_hints,
d1438 1
a1438 1
            FT_TRACE4(( " (maskbytes: " ));
d1441 1
a1441 1
                  maskbyte < (FT_UInt)(( decoder->num_hints + 7 ) >> 3);
d1443 1
a1443 1
              FT_TRACE4(( "0x%02X", *ip ));
a1449 2
          if ( ip >= limit )
            goto Syntax_Error;
d1484 2
a1485 2
          if ( cff_builder_start_point ( builder, x, y ) ||
               check_points( builder, num_args / 2 )     )
d1511 1
a1511 1
            if ( num_args < 1 )
d1514 7
a1520 2
            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, num_args )         )
d1553 2
a1554 2
            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, nargs / 2 )     )
d1586 1
a1586 1
            /* we reduce it to 4n+1                      */
d1588 1
a1588 3
            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;
d1602 1
a1602 1
            if ( check_points( builder, 3 * ( nargs / 4 ) ) )
d1631 1
a1631 1
            /* we reduce it to 4n+1                      */
d1633 1
a1633 3
            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;
d1646 1
a1646 1
            if ( check_points( builder, 3 * ( nargs / 4 ) ) )
d1681 1
a1681 1
            /* we reduce it to the largest one which fits             */
d1683 1
a1683 3
            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;
d1686 1
a1686 1
            if ( check_points( builder, ( nargs / 4 ) * 3 ) )
d1739 2
a1740 2
            if ( cff_builder_start_point( builder, x, y ) ||
                 check_points( builder, num_lines + 3 )   )
d1784 2
a1785 2
            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, num_curves * 3 + 2 ) )
d1825 1
a1825 1
                 check_points( builder, 6 )               )
d1874 1
a1874 1
                 check_points( builder, 6 )               )
d1927 1
a1927 1
                 check_points( builder, 6 )               )
d1990 1
a1990 1
                 check_points( builder, 6 )               )
d2022 4
d2034 1
a2043 3
            if ( !error )
              error = CFF_Err_Ok;

d2050 1
a2050 1
                                  builder->current->n_points ) )
d2054 6
a2059 4
              hinter->apply( hinter->hints,
                             builder->current,
                             (PSH_Globals)builder->hints_globals,
                             decoder->hint_mode );
d2137 1
a2137 2
            FT_Int    count = 9;
            FT_Fixed  root  = args[0];
d2144 1
a2144 1
              if ( new_root == root || count <= 0 )
d2253 4
d2279 5
d2285 24
d2310 20
a2329 1
          goto Unimplemented;
d2331 2
a2332 2
        case cff_op_load:
          FT_TRACE4(( " load\n" ));
d2334 7
a2340 1
          goto Unimplemented;
d2413 2
d2416 2
d2427 16
d2448 1
a2448 1
            FT_Fixed  cond = args[0] && args[1];
d2460 1
a2460 1
            FT_Fixed  cond = args[0] || args[1];
d2470 12
d2484 1
a2484 1
            FT_Fixed  cond = !args[0];
d2513 3
a2515 1
            FT_TRACE4(( " callsubr(%d)\n", idx ));
d2557 3
a2559 1
            FT_TRACE4(( " callgsubr(%d)\n", idx ));
d2596 2
a2597 1
          FT_TRACE4(( " return\n" ));
a2612 1
        Unimplemented:
d2619 1
a2619 1
          return CFF_Err_Unimplemented_Feature;
d2622 4
a2625 1
      decoder->top = args;
d2636 5
d2643 1
a2643 1
    return CFF_Err_Invalid_File_Format;
d2647 1
a2647 1
    return CFF_Err_Too_Few_Arguments;
d2651 1
a2651 1
    return CFF_Err_Stack_Overflow;
d2654 2
d2682 1
a2682 1
    FT_Error     error = CFF_Err_Ok;
d2714 2
a2715 1
                                                 charstring_len );
d2721 1
a2721 1
      error = CFF_Err_Ok;
d2726 1
a2726 1
    return CFF_Err_Ok;
d2742 1
a2742 1
    FT_Bool      hinting, force_scaling;
d2763 1
a2763 1
          return CFF_Err_Invalid_Argument;
d2767 1
a2767 1
      return CFF_Err_Invalid_Argument;
d2803 1
a2803 1
                                       (FT_Int)load_flags,
d2810 5
d2841 33
d2883 1
a2883 1
      return CFF_Err_Invalid_Argument;
d2891 1
d2895 6
a2900 2
      FT_ULong  top_upm = cff->top_font.font_dict.units_per_em;
      FT_ULong  sub_upm = cff->subfonts[fd_index]->font_dict.units_per_em;
d2923 4
a2926 2
    hinting = FT_BOOL( ( load_flags & FT_LOAD_NO_SCALE   ) == 0 &&
                       ( load_flags & FT_LOAD_NO_HINTING ) == 0 );
d2928 2
d2933 5
d2945 1
d2955 16
a2970 1
      if ( !error )
d2972 7
a2978 2
        error = cff_decoder_prepare( &decoder, size, glyph_index );
        if ( !error )
d2980 8
a2987 1
          error = cff_decoder_parse_charstrings( &decoder,
d2990 2
d2993 1
a2993 1
          cff_free_glyph_data( face, &charstring, charstring_len );
d2995 2
d2999 8
a3006 8
          /* Control data and length may not be available for incremental */
          /* fonts.                                                       */
          if ( face->root.internal->incremental_interface )
          {
            glyph->root.control_data = 0;
            glyph->root.control_len = 0;
          }
          else
d3009 5
a3013 5
          /* We set control_data and control_len if charstrings is loaded. */
          /* See how charstring loads at cff_index_access_element() in     */
          /* cffload.c.                                                    */
          {
            CFF_Index  csindex = &cff->charstrings_index;
d3016 5
a3020 7
            if ( csindex->offsets )
            {
              glyph->root.control_data = csindex->bytes +
                                           csindex->offsets[glyph_index] - 1;
              glyph->root.control_len  = charstring_len;
            }
          }
d3024 5
a3028 2
      /* save new glyph tables */
      cff_builder_done( &decoder.builder );
a3079 1
        FT_Vector          advance;
d3083 21
a3103 3
        /* copy the _unscaled_ advance width */
        metrics->horiAdvance                    = decoder.glyph_width;
        glyph->root.linearHoriAdvance           = decoder.glyph_width;
a3105 5
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
        has_vertical_info = FT_BOOL( face->vertical_info                   &&
                                     face->vertical.number_Of_VMetrics > 0 &&
                                     face->vertical.long_metrics           );
#else
a3107 1
#endif
d3109 1
a3109 1
        /* get the vertical metrics from the vtmx table if we have one */
d3144 4
a3147 4
        if ( !( font_matrix.xx == 0x10000L &&
                font_matrix.yy == 0x10000L &&
                font_matrix.xy == 0        &&
                font_matrix.yx == 0        ) )
d3150 8
a3157 2
        if ( !( font_offset.x == 0 &&
                font_offset.y == 0 ) )
d3159 2
a3160 1
                                font_offset.x, font_offset.y );
d3162 3
a3164 9
        advance.x = metrics->horiAdvance;
        advance.y = 0;
        FT_Vector_Transform( &advance, &font_matrix );
        metrics->horiAdvance = advance.x + font_offset.x;

        advance.x = 0;
        advance.y = metrics->vertAdvance;
        FT_Vector_Transform( &advance, &font_matrix );
        metrics->vertAdvance = advance.y + font_offset.y;
d3201 1
a3201 1
        else 
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 2
a8 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
a18 2
/* $XFree86: xc/extras/freetype2/src/cff/cffgload.c,v 1.4 2004/04/26 16:15:54 dawes Exp $ */

a21 1
#include FT_INTERNAL_CALC_H
a24 1
#include FT_TRUETYPE_TAGS_H
d112 8
a119 2
    cff_op_hsbw,        /* Type 1 opcode: invalid but seen in real life */
    cff_op_closepath,   /* ditto */
d131 5
d206 6
a211 1
    0
d329 4
a332 1
  /*    num_subrs :: The number of glyph subroutines.                      */
d337 2
a338 1
  cff_compute_bias( FT_UInt  num_subrs )
d343 3
a345 1
    if ( num_subrs < 1240 )
d396 1
d399 3
a401 1
    decoder->globals_bias = cff_compute_bias( decoder->num_globals );
d433 2
d437 1
a437 1
      if ( builder->hints_funcs )
d446 4
d453 3
a455 1
    decoder->locals_bias   = cff_compute_bias( decoder->num_locals );
a492 2

      builder->last = *point;
d571 1
d577 5
a581 2
    /* XXXX: We must not include the last point in the path if it */
    /*       is located on the first point.                       */
a583 1
      FT_Int      first   = 0;
a588 6
      if ( outline->n_contours > 1 )
      {
        first = outline->contours[outline->n_contours - 2] + 1;
        p1    = outline->points + first;
      }

d597 12
a608 2
      outline->contours[outline->n_contours - 1] =
        (short)( outline->n_points - 1 );
d698 1
a698 1
        face->root.internal->incremental_interface->object,&data );
d714 1
d727 1
d730 9
d759 2
a760 2
      FT_ERROR(( "cff_operator_seac:" ));
      FT_ERROR(( " invalid seac character code arguments\n" ));
d809 2
d813 1
d821 2
a822 2
    /* Save the left bearing and width of the base character */
    /* as they will be erased by the next load.              */
d826 1
d831 1
a831 1
    builder->pos_x = adx;
d839 2
d843 1
d851 2
a852 2
    /* Restore the left side bearing and advance width */
    /* of the base character.                          */
d855 1
d897 2
d908 4
a911 3
    seed = (FT_Fixed)(char*)&seed           ^
           (FT_Fixed)(char*)&decoder        ^
           (FT_Fixed)(char*)&charstring_base;
d966 1
a966 1
          val = (FT_Long)v - 139;
d971 1
a971 1
          val = ( (FT_Long)v - 247 ) * 256 + *ip++ + 108;
d977 1
a977 1
          val = -( (FT_Long)v - 251 ) * 256 - *ip++ - 108;
d988 2
a989 1
          shift  = 0;
d1007 5
d1063 6
d1078 6
d1108 6
d1147 3
d1217 1
a1217 1
          ;
d1219 1
a1226 2
          args = stack;

d1260 1
a1260 1
              set_width_ok = ( ( num_args == 5 ) || ( num_args == 1 ) );
d1273 6
a1280 1
              args++;
d1294 8
d1309 4
a1312 3
          FT_TRACE4(( op == cff_op_hstem   ? " hstem"   :
                    ( op == cff_op_vstem   ? " vstem"   :
                    ( op == cff_op_hstemhm ? " hstemhm" : " vstemhm" ) ) ));
d1318 1
a1318 1
                           args );
d1338 1
a1338 1
                             args );
d1361 1
a1361 1
            FT_TRACE4(( " " ));
d1367 2
d1379 1
a1379 1
          FT_TRACE4(( " rmoveto" ));
d1383 2
a1384 2
          x   += args[0];
          y   += args[1];
d1389 1
a1389 1
          FT_TRACE4(( " vmoveto" ));
d1393 1
a1393 1
          y   += args[0];
d1398 1
a1398 1
          FT_TRACE4(( " hmoveto" ));
d1402 1
a1402 1
          x   += args[0];
d1407 1
a1407 1
          FT_TRACE4(( " rlineto" ));
d1413 1
a1413 1
          if ( num_args < 2 || num_args & 1 )
d1416 1
a1416 1
          args = stack;
d1433 5
a1437 2
            FT_TRACE4(( op == cff_op_hlineto ? " hlineto"
                                             : " vlineto" ));
d1462 3
a1464 1
          FT_TRACE4(( " rrcurveto" ));
d1466 6
a1471 3
          /* check number of arguments; must be a multiple of 6 */
          if ( num_args % 6 != 0 )
            goto Stack_Underflow;
d1473 3
a1475 3
          if ( cff_builder_start_point ( builder, x, y ) ||
               check_points( builder, num_args / 2 )     )
            goto Fail;
d1477 15
a1491 13
          args = stack;
          while ( args < decoder->top )
          {
            x += args[0];
            y += args[1];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[2];
            y += args[3];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[4];
            y += args[5];
            cff_builder_add_point( builder, x, y, 1 );
            args += 6;
a1492 1
          args = stack;
d1496 5
a1500 1
          FT_TRACE4(( " vvcurveto" ));
d1502 12
a1513 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1515 1
a1515 7
          args = stack;
          if ( num_args & 1 )
          {
            x += args[0];
            args++;
            num_args--;
          }
d1517 6
a1522 2
          if ( num_args % 4 != 0 )
            goto Stack_Underflow;
d1524 2
a1525 2
          if ( check_points( builder, 3 * ( num_args / 4 ) ) )
            goto Fail;
d1527 12
a1538 10
          while ( args < decoder->top )
          {
            y += args[0];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[1];
            y += args[2];
            cff_builder_add_point( builder, x, y, 0 );
            y += args[3];
            cff_builder_add_point( builder, x, y, 1 );
            args += 4;
a1539 1
          args = stack;
d1543 2
a1544 1
          FT_TRACE4(( " hhcurveto" ));
a1545 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1547 14
a1560 7
          args = stack;
          if ( num_args & 1 )
          {
            y += args[0];
            args++;
            num_args--;
          }
d1562 7
a1568 2
          if ( num_args % 4 != 0 )
            goto Stack_Underflow;
d1570 2
a1571 2
          if ( check_points( builder, 3 * ( num_args / 4 ) ) )
            goto Fail;
d1573 12
a1584 10
          while ( args < decoder->top )
          {
            x += args[0];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[1];
            y += args[2];
            cff_builder_add_point( builder, x, y, 0 );
            x += args[3];
            cff_builder_add_point( builder, x, y, 1 );
            args += 4;
a1585 1
          args = stack;
d1592 1
d1595 2
a1596 2
            FT_TRACE4(( op == cff_op_vhcurveto ? " vhcurveto"
                                               : " hvcurveto" ));
d1601 1
a1601 2
            args = stack;
            if ( num_args < 4 || ( num_args % 4 ) > 1 )
d1604 9
a1612 1
            if ( check_points( builder, ( num_args / 4 ) * 3 ) )
d1617 1
a1617 1
            while ( num_args >= 4 )
d1619 1
a1619 1
              num_args -= 4;
d1628 1
a1628 1
                if ( num_args == 1 )
d1640 1
a1640 1
                if ( num_args == 1 )
d1653 2
a1654 1
            FT_Int  num_lines = ( num_args - 6 ) / 2;
d1657 1
a1657 1
            FT_TRACE4(( " rlinecurve" ));
d1659 1
a1659 1
            if ( num_args < 8 || ( num_args - 6 ) & 1 )
d1662 3
d1669 1
a1669 1
            args = stack;
d1697 2
a1698 1
            FT_Int  num_curves = ( num_args - 2 ) / 6;
d1701 1
a1701 1
            FT_TRACE4(( " rcurveline" ));
d1703 1
a1703 1
            if ( num_args < 8 || ( num_args - 2 ) % 6 )
d1706 4
d1711 1
a1711 1
                 check_points( builder, num_curves*3 + 2 ) )
d1714 1
a1714 1
            args = stack;
d1745 1
a1745 1
            FT_TRACE4(( " hflex1" ));
d1747 2
a1748 4
            args = stack;

            /* adding five more points; 4 control points, 1 on-curve point */
            /* make sure we have enough space for the start point if it    */
d1754 1
a1754 1
            /* Record the starting point's y position for later use */
d1796 1
a1796 3
            FT_TRACE4(( " hflex" ));

            args = stack;
d1841 6
a1846 5
            FT_Pos    start_x, start_y; /* record start x, y values for */
                                        /* alter use                                */
            FT_Fixed  dx = 0, dy = 0;   /* used in horizontal/vertical  */
                                        /* algorithm below              */
            FT_Int    horizontal, count;
d1849 1
a1849 1
            FT_TRACE4(( " flex1" ));
d1863 1
a1863 1
            args = stack;
d1868 3
a1870 3
              dx += args[0];
              dy += args[1];
              args += 2;
d1873 4
a1876 5
            /* rewind */
            args = stack;

            if ( dx < 0 ) dx = -dx;
            if ( dy < 0 ) dy = -dy;
d1885 2
a1886 1
              cff_builder_add_point( builder, x, y, (FT_Bool)( count == 3 ) );
d1913 1
a1913 1
            FT_TRACE4(( " flex" ));
a1918 1
            args = stack;
d1932 15
d1948 1
a1948 1
          FT_TRACE4(( " endchar" ));
d1951 1
a1951 1
          if ( num_args == 4 )
a1955 1

d1957 3
a1959 5
                                       args[0],
                                       args[1],
                                       (FT_Int)( args[2] >> 16 ),
                                       (FT_Int)( args[3] >> 16 ) );
            args += 4;
d1989 1
a1989 1
          FT_TRACE4(( "\n\n" ));
d1993 1
a1993 1
          FT_TRACE4(( " abs" ));
d2001 1
a2001 1
          FT_TRACE4(( " add" ));
d2008 1
a2008 1
          FT_TRACE4(( " sub" ));
d2015 1
a2015 1
          FT_TRACE4(( " div" ));
d2022 1
a2022 1
          FT_TRACE4(( " neg" ));
d2033 1
a2033 1
            FT_TRACE4(( " rand" ));
d2048 1
a2048 1
          FT_TRACE4(( " mul" ));
d2055 1
a2055 1
          FT_TRACE4(( " sqrt" ));
d2080 1
a2080 1
          FT_TRACE4(( " drop" ));
d2089 1
a2089 1
            FT_TRACE4(( " exch" ));
d2103 1
a2103 1
            FT_TRACE4(( " index" ));
d2120 1
a2120 1
            FT_TRACE4(( " roll" ));
d2162 1
a2162 1
          FT_TRACE4(( " dup" ));
d2165 1
a2165 1
          args++;
d2174 1
a2174 1
            FT_TRACE4(( " put" ));
d2176 1
a2176 1
            if ( idx >= 0 && idx < decoder->len_buildchar )
d2187 1
a2187 1
            FT_TRACE4(( " get" ));
d2189 1
a2189 1
            if ( idx >= 0 && idx < decoder->len_buildchar )
d2198 1
a2198 1
          FT_TRACE4(( " store "));
d2203 1
a2203 1
          FT_TRACE4(( " load" ));
d2209 1
a2209 1
          FT_TRACE4(( " dotsection" ));
d2217 1
a2217 1
          FT_TRACE4(( " closepath (invalid op)" ));
d2227 35
a2261 1
          FT_TRACE4(( " hsbw (invalid op)" ));
d2263 2
a2264 4
          decoder->glyph_width = decoder->nominal_width +
                                   (args[1] >> 16);
          x    = args[0];
          y    = 0;
d2268 23
d2296 1
a2296 1
            FT_TRACE4(( " and" ));
d2308 1
a2308 1
            FT_TRACE4(( " or" ));
d2320 1
a2320 1
            FT_TRACE4(( " eq" ));
d2332 1
a2332 1
            FT_TRACE4(( " ifelse" ));
d2346 1
a2346 1
            FT_TRACE4(( " callsubr(%d)", idx ));
d2350 2
a2351 2
              FT_ERROR(( "cff_decoder_parse_charstrings:" ));
              FT_ERROR(( " invalid local subr index\n" ));
d2372 1
a2372 1
                         " invoking empty subrs!\n" ));
d2388 1
a2388 1
            FT_TRACE4(( " callgsubr(%d)", idx ));
d2392 2
a2393 2
              FT_ERROR(( "cff_decoder_parse_charstrings:" ));
              FT_ERROR(( " invalid global subr index\n" ));
d2414 1
a2414 1
                         " invoking empty subrs!\n" ));
d2425 1
a2425 1
          FT_TRACE4(( " return" ));
d2463 1
a2463 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: syntax error!" ));
d2467 1
a2467 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack underflow!" ));
d2471 1
a2471 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack overflow!" ));
d2559 1
a2559 1
    TT_Face      face     = (TT_Face)glyph->root.face;
d2561 1
a2561 1
    CFF_Font     cff      = (CFF_Font)face->extra.data;
d2575 8
a2582 3
      glyph_index = cff_charset_cid_to_gindex( &cff->charset, glyph_index );
      if ( glyph_index == 0 )
        return CFF_Err_Invalid_Argument;
d2674 2
a2675 2
      FT_Int  top_upm = cff->top_font.font_dict.units_per_em;
      FT_Int  sub_upm = cff->subfonts[fd_index]->font_dict.units_per_em;
d2711 3
d2715 1
a2715 1
        (FT_Bool)( ( load_flags & FT_LOAD_NO_RECURSE ) != 0 );
d2767 2
a2768 2
    if ( !error                                                              &&
         face->root.internal->incremental_interface                          &&
d2775 1
a2775 1
      metrics.bearing_y = decoder.builder.left_bearing.y;
d2777 2
d2782 1
a2783 1
      decoder.builder.left_bearing.y = metrics.bearing_y;
d2785 1
a2785 1
      decoder.builder.advance.y      = 0;
d2822 1
d2825 5
a2829 1
                                     face->vertical.long_metrics != 0 );
d2866 2
a2867 2
        /* apply the font matrix -- `xx' has already been normalized */
        if ( !( font_matrix.yy == 0x10000L &&
d2920 8
a2927 4
          metrics->vertBearingX = -metrics->width / 2;
        else
          ft_synthesize_vertical_metrics( metrics,
                                          metrics->vertAdvance );
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d115 3
d195 3
d233 2
d264 4
a267 1
        builder->hints_globals = size->root.internal;
a271 6
    if ( size )
    {
      builder->scale_x = size->root.metrics.x_scale;
      builder->scale_y = size->root.metrics.y_scale;
    }

d349 5
a353 1
  /*    face    :: The current face object.                                */
d355 1
a355 1
  /*    size    :: The current size object.                                */
d357 1
a357 1
  /*    slot    :: The current glyph object.                               */
d385 2
a386 1
  /* this function is used to select the locals subrs array */
d389 1
d392 4
a395 3
    CFF_Font     cff   = (CFF_Font)decoder->builder.face->extra.data;
    CFF_SubFont  sub   = &cff->top_font;
    FT_Error     error = CFF_Err_Ok;
d399 1
a399 1
    if ( cff->num_subfonts >= 1 )
d410 1
a410 1
        
d412 9
d980 3
d1084 3
d1200 1
a1200 1
        req_args &= 15;
d2054 24
d2316 1
a2316 1
        error = cff_decoder_prepare( &decoder, glyph_index );
d2347 1
a2347 1
    FT_Bool      hinting;
d2354 2
d2360 1
a2360 1
         cff->charset.cids )
d2447 30
d2501 1
a2501 1
        error = cff_decoder_prepare( &decoder, glyph_index );
a2568 15
      if ( cff->num_subfonts >= 1 )
      {
        FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select,
                                               glyph_index );


        font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
        font_offset = cff->subfonts[fd_index]->font_dict.font_offset;
      }
      else
      {
        font_matrix = cff->top_font.font_dict.font_matrix;
        font_offset = cff->top_font.font_dict.font_offset;
      }

d2638 2
a2639 3
        /* apply the font matrix */
        if ( !( font_matrix.xx == 0x10000L &&
                font_matrix.yy == 0x10000L &&
d2659 1
a2659 1
        if ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 )
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d377 1
a377 1
  FT_LOCAL_DEF( void )
d381 3
a383 2
    CFF_Font     cff = (CFF_Font)decoder->builder.face->extra.data;
    CFF_SubFont  sub = &cff->top_font;
d392 7
d408 3
d1579 1
a1579 1
            /* Record the starting point's y postion for later use */
d1682 1
a1682 1
            /* record the starting point's x, y postion for later use */
d2087 1
a2087 1
              FT_ERROR(( "  invalid local subr index\n" ));
d2105 1
a2105 1
            if ( !zone->base )
d2147 1
a2147 1
            if ( !zone->base )
d2265 5
a2269 3
        cff_decoder_prepare( &decoder, glyph_index );
        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring, charstring_len );
d2293 8
a2300 5
    FT_Error      error;
    CFF_Decoder   decoder;
    TT_Face       face     = (TT_Face)glyph->root.face;
    FT_Bool       hinting;
    CFF_Font      cff      = (CFF_Font)face->extra.data;
a2301 2
    FT_Matrix     font_matrix;
    FT_Vector     font_offset;
d2303 12
a2406 12
      /* in a CID-keyed font, consider `glyph_index' as a CID and map */
      /* it immediately to the real glyph_index -- if it isn't a      */
      /* subsetted font, glyph_indices and CIDs are identical, though */
      if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
           cff->charset.cids )
      {
        if ( glyph_index < cff->charset.max_cid )
          glyph_index = cff->charset.cids[glyph_index];
        else
          glyph_index = 0;
      }

d2418 6
a2423 3
        cff_decoder_prepare( &decoder, glyph_index );
        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring, charstring_len );
d2425 1
a2425 1
        cff_free_glyph_data( face, &charstring, charstring_len );
d2429 8
a2436 8
        /* Control data and length may not be available for incremental   */
        /* fonts.                                                         */
        if ( face->root.internal->incremental_interface )
        {
          glyph->root.control_data = 0;
          glyph->root.control_len = 0;
        }
        else
d2439 5
a2443 5
        /* We set control_data and control_len if charstrings is loaded.  */
        /* See how charstring loads at cff_index_access_element() in      */
        /* cffload.c.                                                     */
        {
          CFF_IndexRec csindex = cff->charstrings_index;
d2446 7
a2452 4
          glyph->root.control_data =
            csindex.bytes + csindex.offsets[glyph_index] - 1;
          glyph->root.control_len =
            charstring_len;
d2484 1
a2484 1
    if ( cff->num_subfonts >= 1 )
d2486 5
a2490 1
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select, glyph_index );
d2492 8
d2501 3
a2503 8
      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }
a2504 5
    /* Now, set the metrics -- this is rather simple, as   */
    /* the left side bearing is the xMin, and the top side */
    /* bearing the yMax.                                   */
    if ( !error )
    {
d2571 10
a2580 5
        FT_Outline_Transform( &glyph->root.outline, &font_matrix );

        FT_Outline_Translate( &glyph->root.outline,
                              font_offset.x,
                              font_offset.y );
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d408 1
a408 1
    return FT_GlyphLoader_CheckPoints( builder->loader, count, 0 );
d470 1
a470 1
    error = FT_GlyphLoader_CheckPoints( builder->loader, 0, 1 );
d513 3
d833 1
a833 1
    hinter = (T2_Hints_Funcs) builder->hints_funcs;
d850 1
a850 1
    /* now, execute loop */
d1274 1
a1274 1
            goto Memory_Error;
d1299 3
a1301 3
            if ( cff_builder_start_point ( builder, x, y )     ||
                 check_points( builder, num_args ) )
              goto Memory_Error;
d1304 1
a1304 1
            while (args < decoder->top )
d1312 1
a1312 1
                goto Memory_Error;
d1330 1
a1330 1
            goto Memory_Error;
d1352 2
a1353 2
          if ( cff_builder_start_point ( builder, x, y ) )
            goto Memory_Error;
d1367 1
a1367 1
            goto Memory_Error;
d1386 2
a1387 2
          if ( cff_builder_start_point ( builder, x, y ) )
            goto Memory_Error;
d1401 1
a1401 1
            goto Memory_Error;
d1426 2
a1427 2
            if ( cff_builder_start_point ( builder, x, y ) )
              goto Memory_Error;
d1430 1
a1430 1
            if (num_args < 4 || ( num_args % 4 ) > 1 )
d1484 1
a1484 1
              goto Memory_Error;
d1524 1
a1524 1
              goto Memory_Error;
d1563 1
a1563 1
            /* needs to be added..                                         */
d1566 1
a1566 1
              goto Memory_Error;
d1616 2
a1617 2
                 check_points ( builder, 6 )              )
              goto Memory_Error;
d1669 1
a1669 1
               goto Memory_Error;
d1732 1
a1732 1
              goto Memory_Error;
d1777 2
a1778 1
              if (hinter->close( hinter->hints, builder->current->n_points ) )
d2054 1
a2054 1
            FT_Fixed  cond = (args[2] <= args[3]);
d2184 1
a2197 3

  Memory_Error:
    return builder->error;
a2273 16
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /**********                                                      *********/
  /**********                                                      *********/
  /**********               UNHINTED GLYPH LOADER                  *********/
  /**********                                                      *********/
  /**********    The following code is in charge of loading a      *********/
  /**********    single outline.  It completely ignores hinting    *********/
  /**********    and is used when FT_LOAD_NO_HINTING is set.       *********/
  /**********                                                      *********/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


d2277 1
a2277 1
                 FT_Int         glyph_index,
d2314 2
a2315 2
      if ( size->strike_index != 0xFFFFU           &&
           sfnt->load_sbits                        &&
d2322 2
a2323 2
                                       (FT_ULong)size->strike_index,
                                       (FT_UInt)glyph_index,
d2386 6
a2391 1
        glyph_index = cff->charset.cids[glyph_index];
d2464 13
a2476 2
    font_matrix = cff->top_font.font_dict.font_matrix;
    font_offset = cff->top_font.font_dict.font_offset;
d2501 1
d2509 28
a2536 4
        /* make up vertical metrics */
        metrics->vertBearingX = 0;
        metrics->vertBearingY = 0;
        metrics->vertAdvance  = 0;
d2538 1
a2538 1
        glyph->root.linearVertAdvance = 0;
d2559 1
d2576 1
a2576 1
          if ( !hinting )
a2582 2
          FT_Outline_Get_CBox( &glyph->root.outline, &cbox );

d2584 2
a2585 14
          metrics->horiAdvance  = FT_MulFix( metrics->horiAdvance,  x_scale );
          metrics->vertAdvance  = FT_MulFix( metrics->vertAdvance,  y_scale );

          metrics->vertBearingX = FT_MulFix( metrics->vertBearingX, x_scale );
          metrics->vertBearingY = FT_MulFix( metrics->vertBearingY, y_scale );

          if ( hinting )
          {
            metrics->horiAdvance  = FT_PIX_ROUND( metrics->horiAdvance );
            metrics->vertAdvance  = FT_PIX_ROUND( metrics->vertAdvance );

            metrics->vertBearingX = FT_PIX_ROUND( metrics->vertBearingX );
            metrics->vertBearingY = FT_PIX_ROUND( metrics->vertBearingY );
          }
a2590 9
        /* grid fit the bounding box if necessary */
        if ( hinting )
        {
          cbox.xMin &= -64;
          cbox.yMin &= -64;
          cbox.xMax  = ( cbox.xMax + 63 ) & -64;
          cbox.yMax  = ( cbox.yMax + 63 ) & -64;
        }

d2596 6
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d18 2
d377 1
a377 1
  FT_LOCAL_DEF( FT_Error )
d381 2
a382 3
    CFF_Font     cff   = (CFF_Font)decoder->builder.face->extra.data;
    CFF_SubFont  sub   = &cff->top_font;
    FT_Error     error = CFF_Err_Ok;
a390 7
      if ( fd_index >= cff->num_subfonts )
      {
        FT_TRACE4(( "cff_decoder_prepare: invalid CID subfont index\n" ));
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
        
a399 3

  Exit:
    return error;
d408 1
a408 1
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
d470 1
a470 1
    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
a512 3
    if ( !outline )
      return;

d830 1
a830 1
    hinter = (T2_Hints_Funcs)builder->hints_funcs;
d847 1
a847 1
    /* now execute loop */
d1271 1
a1271 1
            goto Fail;
d1296 3
a1298 3
            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, num_args )         )
              goto Fail;
d1301 1
a1301 1
            while ( args < decoder->top )
d1309 1
a1309 1
                goto Fail;
d1327 1
a1327 1
            goto Fail;
d1349 2
a1350 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1364 1
a1364 1
            goto Fail;
d1383 2
a1384 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1398 1
a1398 1
            goto Fail;
d1423 2
a1424 2
            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;
d1427 1
a1427 1
            if ( num_args < 4 || ( num_args % 4 ) > 1 )
d1481 1
a1481 1
              goto Fail;
d1521 1
a1521 1
              goto Fail;
d1560 1
a1560 1
            /* needs to be added                                           */
d1563 1
a1563 1
              goto Fail;
d1565 1
a1565 1
            /* Record the starting point's y position for later use */
d1613 2
a1614 2
                 check_points( builder, 6 )               )
              goto Fail;
d1666 1
a1666 1
              goto Fail;
d1668 1
a1668 1
            /* record the starting point's x, y position for later use */
d1729 1
a1729 1
              goto Fail;
d1774 1
a1774 2
              if ( hinter->close( hinter->hints,
                                  builder->current->n_points ) )
d2050 1
a2050 1
            FT_Fixed  cond = ( args[2] <= args[3] );
d2072 1
a2072 1
              FT_ERROR(( " invalid local subr index\n" ));
d2090 1
a2090 1
            if ( !zone->base || zone->limit == zone->base )
d2132 1
a2132 1
            if ( !zone->base || zone->limit == zone->base )
a2179 1
  Fail:
d2193 3
d2252 3
a2254 5
        error = cff_decoder_prepare( &decoder, glyph_index );
        if ( !error )
          error = cff_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
d2272 16
d2291 1
a2291 1
                 FT_UInt        glyph_index,
d2294 5
a2298 5
    FT_Error     error;
    CFF_Decoder  decoder;
    TT_Face      face     = (TT_Face)glyph->root.face;
    FT_Bool      hinting;
    CFF_Font     cff      = (CFF_Font)face->extra.data;
d2300 2
a2301 2
    FT_Matrix    font_matrix;
    FT_Vector    font_offset;
a2303 13
    /* in a CID-keyed font, consider `glyph_index' as a CID and map */
    /* it immediately to the real glyph_index -- if it isn't a      */
    /* subsetted font, glyph_indices and CIDs are identical, though */
    if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
         cff->charset.cids )
    {
      glyph_index = cff_charset_cid_to_gindex( &cff->charset, glyph_index );
      if ( glyph_index == 0 )
        return CFF_Err_Invalid_Argument;
    }
    else if ( glyph_index >= cff->num_glyphs )
      return CFF_Err_Invalid_Argument;

d2328 2
a2329 2
      if ( size->strike_index != 0xFFFFFFFFUL      &&
           sfnt->load_eblc                         &&
d2336 2
a2337 2
                                       size->strike_index,
                                       glyph_index,
d2395 7
d2413 3
a2415 6
        error = cff_decoder_prepare( &decoder, glyph_index );
        if ( !error )
        {
          error = cff_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
d2417 1
a2417 1
          cff_free_glyph_data( face, &charstring, charstring_len );
d2421 8
a2428 8
          /* Control data and length may not be available for incremental */
          /* fonts.                                                       */
          if ( face->root.internal->incremental_interface )
          {
            glyph->root.control_data = 0;
            glyph->root.control_len = 0;
          }
          else
d2431 5
a2435 5
          /* We set control_data and control_len if charstrings is loaded. */
          /* See how charstring loads at cff_index_access_element() in     */
          /* cffload.c.                                                    */
          {
            CFF_Index  csindex = &cff->charstrings_index;
d2438 4
a2441 7
            if ( csindex->offsets )
            {
              glyph->root.control_data = csindex->bytes +
                                           csindex->offsets[glyph_index] - 1;
              glyph->root.control_len  = charstring_len;
            }
          }
d2473 6
a2480 19
      if ( cff->num_subfonts >= 1 )
      {
        FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select,
                                               glyph_index );


        font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
        font_offset = cff->subfonts[fd_index]->font_dict.font_offset;
      }
      else
      {
        font_matrix = cff->top_font.font_dict.font_matrix;
        font_offset = cff->top_font.font_dict.font_offset;
      }

      /* Now, set the metrics -- this is rather simple, as   */
      /* the left side bearing is the xMin, and the top side */
      /* bearing the yMax.                                   */

a2498 1
        FT_Bool            has_vertical_info;
d2506 4
a2509 28
        has_vertical_info = FT_BOOL( face->vertical_info                   &&
                                     face->vertical.number_Of_VMetrics > 0 &&
                                     face->vertical.long_metrics != 0 );

        /* get the vertical metrics from the vtmx table if we have one */
        if ( has_vertical_info )
        {
          FT_Short   vertBearingY = 0;
          FT_UShort  vertAdvance  = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                     glyph_index,
                                                     &vertBearingY,
                                                     &vertAdvance );
          metrics->vertBearingY = vertBearingY;
          metrics->vertAdvance  = vertAdvance;
        }
        else
        {
          /* make up vertical ones */
          if ( face->os2.version != 0xFFFFU )
            metrics->vertAdvance = (FT_Pos)( face->os2.sTypoAscender -
                                             face->os2.sTypoDescender );
          else
            metrics->vertAdvance = (FT_Pos)( face->horizontal.Ascender -
                                             face->horizontal.Descender );
        }
d2511 1
a2511 1
        glyph->root.linearVertAdvance = metrics->vertAdvance;
d2522 5
a2526 10
        if ( !( font_matrix.xx == 0x10000L &&
                font_matrix.yy == 0x10000L &&
                font_matrix.xy == 0        &&
                font_matrix.yx == 0        ) )
          FT_Outline_Transform( &glyph->root.outline, &font_matrix );

        if ( !( font_offset.x == 0 &&
                font_offset.y == 0 ) )
          FT_Outline_Translate( &glyph->root.outline,
                                font_offset.x, font_offset.y );
a2531 1

d2548 1
a2548 1
          if ( !hinting || !decoder.builder.hints_funcs )
d2555 2
d2558 14
a2571 2
          metrics->horiAdvance = FT_MulFix( metrics->horiAdvance, x_scale );
          metrics->vertAdvance = FT_MulFix( metrics->vertAdvance, y_scale );
d2577 9
a2590 6

        if ( has_vertical_info )
          metrics->vertBearingX = -metrics->width / 2;
        else
          ft_synthesize_vertical_metrics( metrics,
                                          metrics->vertAdvance );
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
a112 3
    cff_op_hsbw,        /* Type 1 opcode: invalid but seen in real life */
    cff_op_closepath,   /* ditto */

a189 3
    0,

    2, /* hsbw */
a224 2
  /*    hinting :: Whether hinting is active.                              */
  /*                                                                       */
d254 1
a254 4
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        builder->hints_globals = (void *)internal->topfont;
d259 6
d342 1
a342 1
  /*    face      :: The current face object.                              */
d344 1
a344 5
  /*    size      :: The current size object.                              */
  /*                                                                       */
  /*    slot      :: The current glyph object.                             */
  /*                                                                       */
  /*    hinting   :: Whether hinting is active.                            */
d346 1
a346 1
  /*    hint_mode :: The hinting mode.                                     */
d374 1
a374 2
  /* this function is used to select the subfont */
  /* and the locals subrs array                  */
a376 1
                       CFF_Size      size,
d379 3
a381 4
    CFF_Builder  *builder = &decoder->builder;
    CFF_Font      cff     = (CFF_Font)builder->face->extra.data;
    CFF_SubFont   sub     = &cff->top_font;
    FT_Error      error   = CFF_Err_Ok;
d385 1
a385 1
    if ( cff->num_subfonts )
d396 1
a396 1

a397 9

      if ( builder->hints_funcs )
      {
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        /* for CFFs without subfonts, this value has already been set */
        builder->hints_globals = (void *)internal->subfonts[fd_index];
      }
a956 3
        case 9:
          op = cff_op_closepath;
          break;
a1057 3
        case 13:
          op = cff_op_hsbw;
          break;
d1171 1
a1171 1
        req_args &= 0x000F;
a2024 24
        case cff_op_closepath:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " closepath (invalid op)" ));

          args = stack;
          break;

        case cff_op_hsbw:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " hsbw (invalid op)" ));

          decoder->glyph_width = decoder->nominal_width +
                                   (args[1] >> 16);
          x    = args[0];
          y    = 0;
          args = stack;
          break;

d2263 1
a2263 1
        error = cff_decoder_prepare( &decoder, size, glyph_index );
d2294 1
a2294 1
    FT_Bool      hinting, force_scaling;
a2300 2
    force_scaling = FALSE;

d2305 1
a2305 1
         cff->charset.cids                               )
a2391 30
    /* if we have a CID subfont, use its matrix (which has already */
    /* been multiplied with the root matrix)                       */

    /* this scaling is only relevant if the PS hinter isn't active */
    if ( cff->num_subfonts )
    {
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select,
                                             glyph_index );

      FT_Int  top_upm = cff->top_font.font_dict.units_per_em;
      FT_Int  sub_upm = cff->subfonts[fd_index]->font_dict.units_per_em;


      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;

      if ( top_upm != sub_upm )
      {
        glyph->x_scale = FT_MulDiv( glyph->x_scale, top_upm, sub_upm );
        glyph->y_scale = FT_MulDiv( glyph->y_scale, top_upm, sub_upm );

        force_scaling = TRUE;
      }
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }

d2416 1
a2416 1
        error = cff_decoder_prepare( &decoder, size, glyph_index );
d2484 15
d2568 3
a2570 2
        /* apply the font matrix -- `xx' has already been normalized */
        if ( !( font_matrix.yy == 0x10000L &&
d2590 1
a2590 1
        if ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 || force_scaling )
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d18 2
@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d406 1
a406 1
    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );
d468 1
a468 1
    error = FT_GLYPHLOADER_CHECK_POINTS( builder->loader, 0, 1 );
a510 3
    if ( !outline )
      return;

d828 1
a828 1
    hinter = (T2_Hints_Funcs)builder->hints_funcs;
d845 1
a845 1
    /* now execute loop */
d1269 1
a1269 1
            goto Fail;
d1294 3
a1296 3
            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, num_args )         )
              goto Fail;
d1299 1
a1299 1
            while ( args < decoder->top )
d1307 1
a1307 1
                goto Fail;
d1325 1
a1325 1
            goto Fail;
d1347 2
a1348 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1362 1
a1362 1
            goto Fail;
d1381 2
a1382 2
          if ( cff_builder_start_point( builder, x, y ) )
            goto Fail;
d1396 1
a1396 1
            goto Fail;
d1421 2
a1422 2
            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;
d1425 1
a1425 1
            if ( num_args < 4 || ( num_args % 4 ) > 1 )
d1479 1
a1479 1
              goto Fail;
d1519 1
a1519 1
              goto Fail;
d1558 1
a1558 1
            /* needs to be added                                           */
d1561 1
a1561 1
              goto Fail;
d1611 2
a1612 2
                 check_points( builder, 6 )               )
              goto Fail;
d1664 1
a1664 1
              goto Fail;
d1727 1
a1727 1
              goto Fail;
d1772 1
a1772 2
              if ( hinter->close( hinter->hints,
                                  builder->current->n_points ) )
d2048 1
a2048 1
            FT_Fixed  cond = ( args[2] <= args[3] );
a2177 1
  Fail:
d2191 3
d2270 16
d2289 1
a2289 1
                 FT_UInt        glyph_index,
d2326 2
a2327 2
      if ( size->strike_index != 0xFFFFFFFFUL      &&
           sfnt->load_eblc                         &&
d2334 2
a2335 2
                                       size->strike_index,
                                       glyph_index,
d2398 1
a2398 6
      {
        if ( glyph_index < cff->charset.max_cid )
          glyph_index = cff->charset.cids[glyph_index];
        else
          glyph_index = 0;
      }
d2471 2
a2472 13
    if ( cff->num_subfonts >= 1 )
    {
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select, glyph_index );


      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }
a2496 1
        FT_Bool            has_vertical_info;
d2504 4
a2507 28
        has_vertical_info = FT_BOOL( face->vertical_info                   &&
                                     face->vertical.number_Of_VMetrics > 0 &&
                                     face->vertical.long_metrics != 0 );

        /* get the vertical metrics from the vtmx table if we have one */
        if ( has_vertical_info )
        {
          FT_Short   vertBearingY = 0;
          FT_UShort  vertAdvance  = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                     glyph_index,
                                                     &vertBearingY,
                                                     &vertAdvance );
          metrics->vertBearingY = vertBearingY;
          metrics->vertAdvance  = vertAdvance;
        }
        else
        {
          /* make up vertical ones */
          if ( face->os2.version != 0xFFFFU )
            metrics->vertAdvance = (FT_Pos)( face->os2.sTypoAscender -
                                             face->os2.sTypoDescender );
          else
            metrics->vertAdvance = (FT_Pos)( face->horizontal.Ascender -
                                             face->horizontal.Descender );
        }
d2509 1
a2509 1
        glyph->root.linearVertAdvance = metrics->vertAdvance;
a2529 1

d2546 1
a2546 1
          if ( !hinting || !decoder.builder.hints_funcs )
d2553 2
d2556 14
a2569 2
          metrics->horiAdvance = FT_MulFix( metrics->horiAdvance, x_scale );
          metrics->vertAdvance = FT_MulFix( metrics->vertAdvance, y_scale );
d2575 9
a2588 6

        if ( has_vertical_info )
          metrics->vertBearingX = -metrics->width / 2;
        else
          ft_synthesize_vertical_metrics( metrics,
                                          metrics->vertAdvance );
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 2
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
d21 1
d25 1
a112 9
    /* Type 1 opcodes: invalid but seen in real life */
    cff_op_hsbw,
    cff_op_closepath,
    cff_op_callothersubr,
    cff_op_pop,
    cff_op_seac,
    cff_op_sbw,
    cff_op_setcurrentpoint,

a122 5
  /* count values which have the `CFF_COUNT_CHECK_WIDTH' flag set are  */
  /* used for checking the width and requested numbers of arguments    */
  /* only; they are set to zero afterwards                             */

  /* the other two flags are informative only and unused currently     */
d190 1
a190 9
    0,

    2, /* hsbw */
    0,
    0,
    0,
    5, /* seac */
    4, /* sbw */
    2  /* setcurrentpoint */
a224 2
  /*    hinting :: Whether hinting is active.                              */
  /*                                                                       */
d254 1
a254 4
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        builder->hints_globals = (void *)internal->topfont;
d259 6
d309 1
a309 4
  /*    in_charstring_type :: The `CharstringType' value of the top DICT   */
  /*                          dictionary.                                  */
  /*                                                                       */
  /*    num_subrs          :: The number of glyph subroutines.             */
d314 1
a314 2
  cff_compute_bias( FT_Int   in_charstring_type,
                    FT_UInt  num_subrs )
d319 1
a319 3
    if ( in_charstring_type == 1 )
      result = 0;
    else if ( num_subrs < 1240 )
d342 1
a342 1
  /*    face      :: The current face object.                              */
d344 1
a344 5
  /*    size      :: The current size object.                              */
  /*                                                                       */
  /*    slot      :: The current glyph object.                             */
  /*                                                                       */
  /*    hinting   :: Whether hinting is active.                            */
d346 1
a346 1
  /*    hint_mode :: The hinting mode.                                     */
a365 1
    decoder->cff          = cff;
d368 1
a368 3
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );
d374 2
a375 3
  /* this function is used to select the subfont */
  /* and the locals subrs array                  */
  FT_LOCAL_DEF( FT_Error )
a376 1
                       CFF_Size      size,
d379 2
a380 4
    CFF_Builder  *builder = &decoder->builder;
    CFF_Font      cff     = (CFF_Font)builder->face->extra.data;
    CFF_SubFont   sub     = &cff->top_font;
    FT_Error      error   = CFF_Err_Ok;
d384 1
a384 1
    if ( cff->num_subfonts )
a388 9
      if ( fd_index >= cff->num_subfonts )
      {
        FT_TRACE4(( "cff_decoder_prepare: invalid CID subfont index\n" ));
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }

      FT_TRACE4(( "glyph index %d (subfont %d):\n", glyph_index, fd_index ));

a389 9

      if ( builder->hints_funcs && size )
      {
        CFF_Internal  internal = (CFF_Internal)size->root.internal;


        /* for CFFs without subfonts, this value has already been set */
        builder->hints_globals = (void *)internal->subfonts[fd_index];
      }
a390 4
#ifdef FT_DEBUG_LEVEL_TRACE
    else
      FT_TRACE4(( "glyph index %d:\n", glyph_index ));
#endif
d394 1
a394 3
    decoder->locals_bias   = cff_compute_bias(
                               decoder->cff->top_font.font_dict.charstring_type,
                               decoder->num_locals );
a397 3

  Exit:
    return error;
d429 2
a508 1
    FT_Int       first;
d514 2
a515 5
    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;

    /* We must not include the last point in the path if it */
    /* is located on the first point.                       */
d518 1
d524 6
d538 2
a539 12
    {
      /* Don't add contours only consisting of one point, i.e., */
      /* check whether begin point and last point are the same. */
      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
d629 1
a629 1
        face->root.internal->incremental_interface->object, &data );
a644 1
                     FT_Pos        asb,
a656 1
    FT_Pos        glyph_width;
a658 9
    if ( decoder->seac )
    {
      FT_ERROR(( "cff_operator_seac: invalid nested seac\n" ));
      return CFF_Err_Syntax_Error;
    }

    adx += decoder->builder.left_bearing.x;
    ady += decoder->builder.left_bearing.y;

d679 2
a680 2
      FT_ERROR(( "cff_operator_seac:"
                 " invalid seac character code arguments\n" ));
a728 2
      /* the seac operator must not be nested */
      decoder->seac = TRUE;
a730 1
      decoder->seac = FALSE;
d738 2
a739 2
    /* Save the left bearing, advance and glyph width of the base */
    /* character as they will be erased by the next load.         */
a742 1
    glyph_width  = decoder->glyph_width;
d747 1
a747 1
    builder->pos_x = adx - asb;
a754 2
      /* the seac operator must not be nested */
      decoder->seac = TRUE;
a756 1
      decoder->seac = FALSE;
d764 2
a765 2
    /* Restore the left side bearing, advance and glyph width */
    /* of the base character.                                 */
a767 1
    decoder->glyph_width  = glyph_width;
a808 2
    FT_Int             charstring_type =
                         decoder->cff->top_font.font_dict.charstring_type;
d818 3
a820 4
    seed = (FT_Fixed)( ( (FT_PtrDist)(char*)&seed              ^
                         (FT_PtrDist)(char*)&decoder           ^
                         (FT_PtrDist)(char*)&charstring_base ) &
                         FT_ULONG_MAX ) ;
d875 1
a875 1
          val = (FT_Int32)v - 139;
d880 1
a880 1
          val = ( (FT_Int32)v - 247 ) * 256 + *ip++ + 108;
d886 1
a886 1
          val = -( (FT_Int32)v - 251 ) * 256 - *ip++ - 108;
d897 1
a897 2
          if ( charstring_type == 2 )
            shift = 0;
a914 5
        /* The specification says that normally arguments are to be taken */
        /* from the bottom of the stack.  However, this seems not to be   */
        /* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */
        /* arguments similar to a PS interpreter.                         */

a945 3
        case 9:
          op = cff_op_closepath;
          break;
a962 6
            case 1: /* this is actually the Type1 vstem3 operator */
              op = cff_op_vstem;
              break;
            case 2: /* this is actually the Type1 hstem3 operator */
              op = cff_op_hstem;
              break;
a971 6
            case 6:
              op = cff_op_seac;
              break;
            case 7:
              op = cff_op_sbw;
              break;
a995 6
            case 16:
              op = cff_op_callothersubr;
              break;
            case 17:
              op = cff_op_pop;
              break;
a1028 3
            case 33:
              op = cff_op_setcurrentpoint;
              break;
a1046 3
        case 13:
          op = cff_op_hsbw;
          break;
d1093 1
a1093 1
          break;
a1094 1

d1102 2
d1137 1
a1137 1
              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );
a1149 6
              if ( decoder->width_only )
              {
                /* we only want the advance width; stop here */
                break;
              }

d1152 1
d1160 1
a1160 1
        req_args &= 0x000F;
a1165 8
        /* At this point, `args' points to the first argument of the  */
        /* operand in case `req_args' isn't zero.  Otherwise, we have */
        /* to adjust `args' manually.                                 */

        /* Note that we only pop arguments from the stack which we    */
        /* really need and can digest so that we can continue in case */
        /* of superfluous stack elements.                             */

d1173 3
a1175 4
          FT_TRACE4((
              op == cff_op_hstem   ? " hstem\n"   :
            ( op == cff_op_vstem   ? " vstem\n"   :
            ( op == cff_op_hstemhm ? " hstemhm\n" : " vstemhm\n" ) ) ));
d1181 1
a1181 1
                           args - ( num_args & ~1 ) );
d1201 1
a1201 1
                             args - ( num_args & ~1 ) );
d1224 1
a1224 1
            FT_TRACE4(( " (maskbytes: " ));
a1229 2

            FT_TRACE4(( ")\n" ));
d1240 1
a1240 1
          FT_TRACE4(( " rmoveto\n" ));
d1244 2
a1245 2
          x   += args[-2];
          y   += args[-1];
d1250 1
a1250 1
          FT_TRACE4(( " vmoveto\n" ));
d1254 1
a1254 1
          y   += args[-1];
d1259 1
a1259 1
          FT_TRACE4(( " hmoveto\n" ));
d1263 1
a1263 1
          x   += args[-1];
d1268 1
a1268 1
          FT_TRACE4(( " rlineto\n" ));
d1274 1
a1274 1
          if ( num_args < 2 )
d1277 1
a1277 1
          args -= num_args & ~1;
d1294 2
a1295 5
            FT_TRACE4(( op == cff_op_hlineto ? " hlineto\n"
                                             : " vlineto\n" ));

            if ( num_args < 1 )
              goto Stack_Underflow;
d1320 1
a1320 2
          {
            FT_Int  nargs;
d1322 3
d1326 3
a1328 1
            FT_TRACE4(( " rrcurveto\n" ));
d1330 13
a1342 24
            if ( num_args < 6 )
              goto Stack_Underflow;

            nargs = num_args - num_args % 6;

            if ( cff_builder_start_point ( builder, x, y ) ||
                 check_points( builder, nargs / 2 )     )
              goto Fail;

            args -= nargs;
            while ( args < decoder->top )
            {
              x += args[0];
              y += args[1];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[2];
              y += args[3];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[4];
              y += args[5];
              cff_builder_add_point( builder, x, y, 1 );
              args += 6;
            }
            args = stack;
d1344 1
d1348 1
a1348 2
          {
            FT_Int  nargs;
d1350 2
d1353 7
a1359 1
            FT_TRACE4(( " vvcurveto\n" ));
d1361 2
a1362 2
            if ( num_args < 4 )
              goto Stack_Underflow;
d1364 2
a1365 2
            /* if num_args isn't of the form 4n or 4n+1, */
            /* we reduce it to 4n+1                      */
d1367 10
a1376 31
            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;

            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;

            args -= nargs;

            if ( nargs & 1 )
            {
              x += args[0];
              args++;
              nargs--;
            }

            if ( check_points( builder, 3 * ( nargs / 4 ) ) )
              goto Fail;

            while ( args < decoder->top )
            {
              y += args[0];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[1];
              y += args[2];
              cff_builder_add_point( builder, x, y, 0 );
              y += args[3];
              cff_builder_add_point( builder, x, y, 1 );
              args += 4;
            }
            args = stack;
d1378 1
d1382 1
a1382 2
          {
            FT_Int  nargs;
d1384 2
d1387 7
a1393 1
            FT_TRACE4(( " hhcurveto\n" ));
d1395 2
a1396 2
            if ( num_args < 4 )
              goto Stack_Underflow;
d1398 2
a1399 2
            /* if num_args isn't of the form 4n or 4n+1, */
            /* we reduce it to 4n+1                      */
d1401 10
a1410 30
            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;

            if ( cff_builder_start_point( builder, x, y ) )
              goto Fail;

            args -= nargs;
            if ( nargs & 1 )
            {
              y += args[0];
              args++;
              nargs--;
            }

            if ( check_points( builder, 3 * ( nargs / 4 ) ) )
              goto Fail;

            while ( args < decoder->top )
            {
              x += args[0];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[1];
              y += args[2];
              cff_builder_add_point( builder, x, y, 0 );
              x += args[3];
              cff_builder_add_point( builder, x, y, 1 );
              args += 4;
            }
            args = stack;
d1412 1
a1418 1
            FT_Int  nargs;
d1421 2
a1422 2
            FT_TRACE4(( op == cff_op_vhcurveto ? " vhcurveto\n"
                                               : " hvcurveto\n" ));
d1427 2
a1428 1
            if ( num_args < 4 )
d1431 1
a1431 9
            /* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */
            /* we reduce it to the largest one which fits             */

            nargs = num_args - num_args % 4;
            if ( num_args - nargs > 0 )
              nargs += 1;

            args -= nargs;
            if ( check_points( builder, ( nargs / 4 ) * 3 ) )
d1436 1
a1436 1
            while ( nargs >= 4 )
d1438 1
a1438 1
              nargs -= 4;
d1447 1
a1447 1
                if ( nargs == 1 )
d1459 1
a1459 1
                if ( nargs == 1 )
d1472 1
a1472 2
            FT_Int  num_lines;
            FT_Int  nargs;
d1475 1
a1475 1
            FT_TRACE4(( " rlinecurve\n" ));
d1477 1
a1477 1
            if ( num_args < 8 )
a1479 3
            nargs     = num_args & ~1;
            num_lines = ( nargs - 6 ) / 2;

d1484 1
a1484 1
            args -= nargs;
d1512 1
a1512 2
            FT_Int  num_curves;
            FT_Int  nargs;
d1515 1
a1515 1
            FT_TRACE4(( " rcurveline\n" ));
d1517 1
a1517 1
            if ( num_args < 8 )
a1519 4
            nargs      = num_args - 2;
            nargs      = nargs - nargs % 6 + 2;
            num_curves = ( nargs - 2 ) / 6;

d1521 1
a1521 1
                 check_points( builder, num_curves * 3 + 2 ) )
d1524 1
a1524 1
            args -= nargs;
d1555 1
a1555 1
            FT_TRACE4(( " hflex1\n" ));
d1557 4
a1560 2
            /* adding five more points: 4 control points, 1 on-curve point */
            /* -- make sure we have enough space for the start point if it */
d1566 1
a1566 1
            /* record the starting point's y position for later use */
d1608 3
a1610 1
            FT_TRACE4(( " hflex\n" ));
d1655 5
a1659 6
            FT_Pos     start_x, start_y; /* record start x, y values for */
                                         /* alter use                    */
            FT_Fixed   dx = 0, dy = 0;   /* used in horizontal/vertical  */
                                         /* algorithm below              */
            FT_Int     horizontal, count;
            FT_Fixed*  temp;
d1662 1
a1662 1
            FT_TRACE4(( " flex1\n" ));
d1669 1
a1669 1
            /* record the starting point's x, y position for later use */
d1676 1
a1676 1
            temp = args;
d1681 3
a1683 3
              dx += temp[0];
              dy += temp[1];
              temp += 2;
d1686 5
a1690 4
            if ( dx < 0 )
              dx = -dx;
            if ( dy < 0 )
              dy = -dy;
d1699 1
a1699 2
              cff_builder_add_point( builder, x, y,
                                     (FT_Bool)( count == 3 ) );
d1726 1
a1726 1
            FT_TRACE4(( " flex\n" ));
d1732 1
a1745 15
        case cff_op_seac:
            FT_TRACE4(( " seac\n" ));

            error = cff_operator_seac( decoder,
                                       args[0], args[1], args[2],
                                       (FT_Int)( args[3] >> 16 ),
                                       (FT_Int)( args[4] >> 16 ) );

            /* add current outline to the glyph slot */
            FT_GlyphLoader_Add( builder->loader );

            /* return now! */
            FT_TRACE4(( "\n" ));
            return error;

d1747 1
a1747 1
          FT_TRACE4(( " endchar\n" ));
d1750 1
a1750 1
          if ( num_args >= 4 )
d1755 1
d1757 5
a1761 3
                                       0L, args[-4], args[-3],
                                       (FT_Int)( args[-2] >> 16 ),
                                       (FT_Int)( args[-1] >> 16 ) );
d1791 1
a1791 1
          FT_TRACE4(( "\n" ));
d1795 1
a1795 1
          FT_TRACE4(( " abs\n" ));
d1803 1
a1803 1
          FT_TRACE4(( " add\n" ));
d1810 1
a1810 1
          FT_TRACE4(( " sub\n" ));
d1817 1
a1817 1
          FT_TRACE4(( " div\n" ));
d1824 1
a1824 1
          FT_TRACE4(( " neg\n" ));
d1835 1
a1835 1
            FT_TRACE4(( " rand\n" ));
d1850 1
a1850 1
          FT_TRACE4(( " mul\n" ));
d1857 1
a1857 1
          FT_TRACE4(( " sqrt\n" ));
d1882 1
a1882 1
          FT_TRACE4(( " drop\n" ));
d1891 1
a1891 1
            FT_TRACE4(( " exch\n" ));
d1905 1
a1905 1
            FT_TRACE4(( " index\n" ));
d1922 1
a1922 1
            FT_TRACE4(( " roll\n" ));
d1964 1
a1964 1
          FT_TRACE4(( " dup\n" ));
d1967 1
a1967 1
          args += 2;
d1976 1
a1976 1
            FT_TRACE4(( " put\n" ));
d1978 1
a1978 1
            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )
d1989 1
a1989 1
            FT_TRACE4(( " get\n" ));
d1991 1
a1991 1
            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )
d2000 1
a2000 1
          FT_TRACE4(( " store\n"));
d2005 1
a2005 1
          FT_TRACE4(( " load\n" ));
d2011 1
a2011 80
          FT_TRACE4(( " dotsection\n" ));
          break;

        case cff_op_closepath:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " closepath (invalid op)\n" ));

          args = stack;
          break;

        case cff_op_hsbw:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " hsbw (invalid op)\n" ));

          decoder->glyph_width = decoder->nominal_width + ( args[1] >> 16 );

          decoder->builder.left_bearing.x = args[0];
          decoder->builder.left_bearing.y = 0;

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y;
          args = stack;
          break;

        case cff_op_sbw:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " sbw (invalid op)\n" ));

          decoder->glyph_width = decoder->nominal_width + ( args[2] >> 16 );

          decoder->builder.left_bearing.x = args[0];
          decoder->builder.left_bearing.y = args[1];

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y + args[1];
          args = stack;
          break;

        case cff_op_setcurrentpoint:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " setcurrentpoint (invalid op)\n" ));

          x    = decoder->builder.pos_x + args[0];
          y    = decoder->builder.pos_y + args[1];
          args = stack;
          break;

        case cff_op_callothersubr:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " callothersubr (invalid op)\n" ));

          /* subsequent `pop' operands should add the arguments,       */
          /* this is the implementation described for `unknown' other  */
          /* subroutines in the Type1 spec.                            */
          args -= 2 + ( args[-2] >> 16 );
          break;

        case cff_op_pop:
          /* this is an invalid Type 2 operator; however, there        */
          /* exist fonts which are incorrectly converted from probably */
          /* Type 1 to CFF, and some parsers seem to accept it         */

          FT_TRACE4(( " pop (invalid op)\n" ));

          args++;
d2019 1
a2019 1
            FT_TRACE4(( " and\n" ));
d2031 1
a2031 1
            FT_TRACE4(( " or\n" ));
d2043 1
a2043 1
            FT_TRACE4(( " eq\n" ));
d2055 1
a2055 1
            FT_TRACE4(( " ifelse\n" ));
d2069 1
a2069 1
            FT_TRACE4(( " callsubr(%d)\n", idx ));
d2073 2
a2074 2
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invalid local subr index\n" ));
d2092 1
a2092 1
            if ( !zone->base || zone->limit == zone->base )
d2095 1
a2095 1
                         " invoking empty subrs\n" ));
d2111 1
a2111 1
            FT_TRACE4(( " callgsubr(%d)\n", idx ));
d2115 2
a2116 2
              FT_ERROR(( "cff_decoder_parse_charstrings:"
                         " invalid global subr index\n" ));
d2134 1
a2134 1
            if ( !zone->base || zone->limit == zone->base )
d2137 1
a2137 1
                         " invoking empty subrs\n" ));
d2148 1
a2148 1
          FT_TRACE4(( " return\n" ));
d2186 1
a2186 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: syntax error\n" ));
d2190 1
a2190 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack underflow\n" ));
d2194 1
a2194 1
    FT_TRACE4(( "cff_decoder_parse_charstrings: stack overflow\n" ));
d2252 3
a2254 5
        error = cff_decoder_prepare( &decoder, size, glyph_index );
        if ( !error )
          error = cff_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
d2278 5
a2282 9
    FT_Error     error;
    CFF_Decoder  decoder;
    TT_Face      face = (TT_Face)glyph->root.face;
    FT_Bool      hinting, force_scaling;
    CFF_Font     cff  = (CFF_Font)face->extra.data;

    FT_Matrix    font_matrix;
    FT_Vector    font_offset;

d2284 2
a2285 1
    force_scaling = FALSE;
a2286 17
    /* in a CID-keyed font, consider `glyph_index' as a CID and map */
    /* it immediately to the real glyph_index -- if it isn't a      */
    /* subsetted font, glyph_indices and CIDs are identical, though */
    if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
         cff->charset.cids                               )
    {
      /* don't handle CID 0 (.notdef) which is directly mapped to GID 0 */
      if ( glyph_index != 0 )
      {
        glyph_index = cff_charset_cid_to_gindex( &cff->charset,
                                                 glyph_index );
        if ( glyph_index == 0 )
          return CFF_Err_Invalid_Argument;
      }
    }
    else if ( glyph_index >= cff->num_glyphs )
      return CFF_Err_Invalid_Argument;
a2365 30
    /* if we have a CID subfont, use its matrix (which has already */
    /* been multiplied with the root matrix)                       */

    /* this scaling is only relevant if the PS hinter isn't active */
    if ( cff->num_subfonts )
    {
      FT_Byte  fd_index = cff_fd_select_get( &cff->fd_select,
                                             glyph_index );

      FT_ULong  top_upm = cff->top_font.font_dict.units_per_em;
      FT_ULong  sub_upm = cff->subfonts[fd_index]->font_dict.units_per_em;


      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;

      if ( top_upm != sub_upm )
      {
        glyph->x_scale = FT_MulDiv( glyph->x_scale, top_upm, sub_upm );
        glyph->y_scale = FT_MulDiv( glyph->y_scale, top_upm, sub_upm );

        force_scaling = TRUE;
      }
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }

d2379 12
a2393 3
      if ( load_flags & FT_LOAD_ADVANCE_ONLY )
        decoder.width_only = TRUE;

d2395 1
a2395 1
        (FT_Bool)( load_flags & FT_LOAD_NO_RECURSE );
d2402 3
a2404 6
        error = cff_decoder_prepare( &decoder, size, glyph_index );
        if ( !error )
        {
          error = cff_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
d2406 1
a2406 1
          cff_free_glyph_data( face, &charstring, charstring_len );
d2410 8
a2417 8
          /* Control data and length may not be available for incremental */
          /* fonts.                                                       */
          if ( face->root.internal->incremental_interface )
          {
            glyph->root.control_data = 0;
            glyph->root.control_len = 0;
          }
          else
d2420 5
a2424 5
          /* We set control_data and control_len if charstrings is loaded. */
          /* See how charstring loads at cff_index_access_element() in     */
          /* cffload.c.                                                    */
          {
            CFF_Index  csindex = &cff->charstrings_index;
d2427 4
a2430 7
            if ( csindex->offsets )
            {
              glyph->root.control_data = csindex->bytes +
                                           csindex->offsets[glyph_index] - 1;
              glyph->root.control_len  = charstring_len;
            }
          }
d2441 2
a2442 2
    if ( !error                                                               &&
         face->root.internal->incremental_interface                           &&
d2449 1
a2449 1
      metrics.bearing_y = 0;
a2450 2
      metrics.advance_v = decoder.builder.advance.y;

a2453 1

d2455 1
d2457 1
a2457 1
      decoder.builder.advance.y      = metrics.advance_v;
d2462 17
a2480 4
      /* Now, set the metrics -- this is rather simple, as   */
      /* the left side bearing is the xMin, and the top side */
      /* bearing the yMax.                                   */

a2506 1
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
d2509 1
a2509 5
                                     face->vertical.long_metrics           );
#else
        has_vertical_info = FT_BOOL( face->vertical_info                   &&
                                     face->vertical.number_Of_VMetrics > 0 );
#endif
d2546 6
a2551 10
        if ( !( font_matrix.xx == 0x10000L &&
                font_matrix.yy == 0x10000L &&
                font_matrix.xy == 0        &&
                font_matrix.yx == 0        ) )
          FT_Outline_Transform( &glyph->root.outline, &font_matrix );

        if ( !( font_offset.x == 0 &&
                font_offset.y == 0 ) )
          FT_Outline_Translate( &glyph->root.outline,
                                font_offset.x, font_offset.y );
d2563 1
a2563 1
        if ( ( load_flags & FT_LOAD_NO_SCALE ) == 0 || force_scaling )
d2596 4
a2599 8
          metrics->vertBearingX = metrics->horiBearingX -
                                    metrics->horiAdvance / 2;
        else 
        {
          if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
            ft_synthesize_vertical_metrics( metrics,
                                            metrics->vertAdvance );
        }
@


1.1.115.4
log
@lets see whether we cant update freetype2 as well
@
text
@d7 2
a8 1
/*  Copyright 1996-2016 by                                                 */
d25 1
a25 1
#include FT_CFF_DRIVER_H
a29 1
#include "cf2ft.h"      /* for cf2_decoder_parse_charstrings */
a43 2
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE

a213 2
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */

d272 2
a273 2
      builder->hints_globals = NULL;
      builder->hints_funcs   = NULL;
d390 1
a390 1
    FT_ZERO( decoder );
d397 1
a397 1
    decoder->num_globals  = cff->global_subrs_index.count;
d417 1
a417 1
    FT_Error      error   = FT_Err_Ok;
d429 1
a429 1
        error = FT_THROW( Invalid_File_Format );
d433 1
a433 1
      FT_TRACE3(( "  in subfont %d:\n", fd_index ));
d446 4
d451 1
a451 1
    decoder->num_locals    = sub->local_subrs_index.count;
a459 2
    decoder->current_subfont = sub;     /* for Adobe's CFF handler */

d466 3
a468 3
  FT_LOCAL_DEF( FT_Error )
  cff_check_points( CFF_Builder*  builder,
                    FT_Int        count )
d475 1
a475 1
  FT_LOCAL_DEF( void )
a488 3
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      CFF_Driver  driver  = (CFF_Driver)FT_FACE_DRIVER( builder->face );

d490 2
a491 12
      if ( driver->hinting_engine == FT_CFF_HINTING_FREETYPE )
      {
        point->x = x >> 16;
        point->y = y >> 16;
      }
      else
#endif
      {
        /* cf2_decoder_parse_charstrings uses 16.16 coordinates */
        point->x = x >> 10;
        point->y = y >> 10;
      }
d500 1
a500 1
  FT_LOCAL_DEF( FT_Error )
d508 1
a508 1
    error = cff_check_points( builder, 1 );
d527 1
a527 1
      return FT_Err_Ok;
d545 1
a545 1
  FT_LOCAL_DEF( FT_Error )
d550 1
a550 1
    FT_Error  error = FT_Err_Ok;
d567 1
a567 1
  FT_LOCAL_DEF( void )
d612 1
a612 1
  FT_LOCAL_DEF( FT_Int )
d634 1
a634 1
        return (FT_Int)n;
d641 1
a641 1
  FT_LOCAL_DEF( FT_Error )
d660 1
a660 1
      *length  = (FT_ULong)data.length;
d668 1
a668 1
      CFF_Font  cff = (CFF_Font)(face->extra.data);
d677 1
a677 1
  FT_LOCAL_DEF( void )
d691 1
a691 1
      FT_Data  data;
d695 1
a695 1
      data.length  = (FT_Int)length;
a711 2
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE

d733 1
a733 1
      return FT_THROW( Syntax_Error );
d761 1
a761 1
      return FT_THROW( Syntax_Error );
d805 1
a805 1
    error = cff_get_glyph_data( face, (FT_UInt)bchar_index,
d812 1
a812 1
                                             charstring_len, 0 );
a814 2
      cff_free_glyph_data( face, &charstring, charstring_len );

d817 2
d835 1
a835 1
    error = cff_get_glyph_data( face, (FT_UInt)achar_index,
d842 1
a842 1
                                             charstring_len, 0 );
a844 2
      cff_free_glyph_data( face, &charstring, charstring_len );

d847 2
a880 3
  /*    in_dict         :: Set to 1 if function is called from top or      */
  /*                       private DICT (needed for Multiple Master CFFs). */
  /*                                                                       */
d887 1
a887 2
                                 FT_ULong      charstring_len,
                                 FT_Bool       in_dict )
a898 4
    FT_UShort          num_designs =
                         decoder->cff->top_font.font_dict.num_designs;
    FT_UShort          num_axes =
                         decoder->cff->top_font.font_dict.num_axes;
d908 4
a911 4
    seed = (FT_Fixed)( ( (FT_Offset)(char*)&seed            ^
                         (FT_Offset)(char*)&decoder         ^
                         (FT_Offset)(char*)&charstring_base ) &
                         FT_ULONG_MAX                         );
d930 1
a930 1
    error = FT_Err_Ok;
a957 3

        /* if we use shifts, all computations are done with unsigned */
        /* values; the conversion to a signed value is the last step */
d962 1
a962 1
          val = (FT_Short)( ( (FT_UShort)ip[0] << 8 ) | ip[1] );
d983 4
a986 4
          val = (FT_Int32)( ( (FT_UInt32)ip[0] << 24 ) |
                            ( (FT_UInt32)ip[1] << 16 ) |
                            ( (FT_UInt32)ip[2] <<  8 ) |
                              (FT_UInt32)ip[3]         );
d994 1
a994 1
        val             = (FT_Int32)( (FT_UInt32)val << shift );
d999 1
a999 1
          FT_TRACE4(( " %hd", (FT_Short)( (FT_UInt32)val >> 16 ) ));
d1001 1
a1001 1
          FT_TRACE4(( " %.5f", val / 65536.0 ));
d1163 2
a1164 2
              FT_TRACE4(( " unknown op (12, %d)\n", v ));
              break;
a1216 1
          FT_TRACE4(( " unknown op (%d)\n", v ));
d1221 1
a1221 39
          continue;

        /* in Multiple Master CFFs, T2 charstrings can appear in */
        /* dictionaries, but some operators are prohibited       */
        if ( in_dict )
        {
          switch ( op )
          {
          case cff_op_hstem:
          case cff_op_vstem:
          case cff_op_vmoveto:
          case cff_op_rlineto:
          case cff_op_hlineto:
          case cff_op_vlineto:
          case cff_op_rrcurveto:
          case cff_op_hstemhm:
          case cff_op_hintmask:
          case cff_op_cntrmask:
          case cff_op_rmoveto:
          case cff_op_hmoveto:
          case cff_op_vstemhm:
          case cff_op_rcurveline:
          case cff_op_rlinecurve:
          case cff_op_vvcurveto:
          case cff_op_hhcurveto:
          case cff_op_vhcurveto:
          case cff_op_hvcurveto:
          case cff_op_hflex:
          case cff_op_flex:
          case cff_op_hflex1:
          case cff_op_flex1:
          case cff_op_callsubr:
          case cff_op_callgsubr:
            goto MM_Error;

          default:
            break;
          }
        }
d1260 1
a1260 3
              set_width_ok = in_dict
                               ? 0
                               : ( ( num_args == 5 ) || ( num_args == 1 ) );
a1342 8
          /* In a valid charstring there must be at least one byte */
          /* after `hintmask' or `cntrmask' (e.g., for a `return'  */
          /* instruction).  Additionally, there must be space for  */
          /* `num_hints' bits.                                     */

          if ( ( ip + ( ( decoder->num_hints + 7 ) >> 3 ) ) >= limit )
            goto Syntax_Error;

d1347 2
a1348 2
                                (FT_UInt)builder->current->n_points,
                                (FT_UInt)decoder->num_hints,
d1352 1
a1352 1
                               (FT_UInt)decoder->num_hints,
d1361 1
a1361 1
            FT_TRACE4(( " (maskbytes:" ));
d1364 1
a1364 1
                  maskbyte < (FT_UInt)( ( decoder->num_hints + 7 ) >> 3 );
d1366 1
a1366 1
              FT_TRACE4(( " 0x%02X", *ip ));
d1373 2
d1409 2
a1410 2
          if ( cff_builder_start_point( builder, x, y )  ||
               cff_check_points( builder, num_args / 2 ) )
d1436 1
a1436 1
            if ( num_args < 0 )
d1439 2
a1440 7
            /* there exist subsetted fonts (found in PDFs) */
            /* which call `hlineto' without arguments      */
            if ( num_args == 0 )
              break;

            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, num_args )    )
d1473 2
a1474 2
            if ( cff_builder_start_point( builder, x, y ) ||
                 cff_check_points( builder, nargs / 2 )   )
d1506 1
a1506 1
            /* we enforce it by clearing the second bit  */
d1508 3
a1510 1
            nargs = num_args & ~2;
d1524 1
a1524 1
            if ( cff_check_points( builder, 3 * ( nargs / 4 ) ) )
d1553 1
a1553 1
            /* we enforce it by clearing the second bit  */
d1555 3
a1557 1
            nargs = num_args & ~2;
d1570 1
a1570 1
            if ( cff_check_points( builder, 3 * ( nargs / 4 ) ) )
d1605 1
a1605 1
            /* we enforce it by clearing the second bit               */
d1607 3
a1609 1
            nargs = num_args & ~2;
d1612 1
a1612 1
            if ( cff_check_points( builder, ( nargs / 4 ) * 3 ) )
d1665 2
a1666 2
            if ( cff_builder_start_point( builder, x, y )   ||
                 cff_check_points( builder, num_lines + 3 ) )
d1710 2
a1711 2
            if ( cff_builder_start_point( builder, x, y )        ||
                 cff_check_points( builder, num_curves * 3 + 2 ) )
d1751 1
a1751 1
                 cff_check_points( builder, 6 )           )
d1800 1
a1800 1
                 cff_check_points( builder, 6 )           )
d1853 1
a1853 1
                 cff_check_points( builder, 6 )           )
d1916 1
a1916 1
                 cff_check_points( builder, 6 )           )
a1947 4
          /* in dictionaries, `endchar' simply indicates end of data */
          if ( in_dict )
            return error;

a1955 1

d1965 3
d1974 1
a1974 1
                                  (FT_UInt)builder->current->n_points ) )
d1978 4
a1981 6
              error = hinter->apply( hinter->hints,
                                     builder->current,
                                     (PSH_Globals)builder->hints_globals,
                                     decoder->hint_mode );
              if ( error )
                goto Fail;
d2059 2
a2060 1
            FT_Fixed  root = args[0];
d2067 1
a2067 1
              if ( new_root == root )
a2175 4
            /* the Type2 specification before version 16-March-2000 */
            /* didn't give a hard-coded size limit of the temporary */
            /* storage array; instead, an argument of the           */
            /* `MultipleMaster' operator set the size               */
d2198 1
a2198 2
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */
d2200 1
a2200 4
          /* since we currently don't handle interpolation of multiple */
          /* master fonts, this is a no-op                             */
          FT_TRACE4(( " store\n"));
          break;
d2203 1
a2203 42
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */
          {
            FT_Int  reg_idx = (FT_Int)args[0];
            FT_Int  idx     = (FT_Int)args[1];
            FT_Int  count   = (FT_Int)args[2];


            FT_TRACE4(( " load\n" ));

            /* since we currently don't handle interpolation of multiple */
            /* master fonts, we store a vector [1 0 0 ...] in the        */
            /* temporary storage array regardless of the Registry index  */
            if ( reg_idx >= 0 && reg_idx <= 2             &&
                 idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS &&
                 count >= 0 && count <= num_axes          )
            {
              FT_Int  end, i;


              end = FT_MIN( idx + count, CFF_MAX_TRANS_ELEMENTS );

              if ( idx < end )
                decoder->buildchar[idx] = 1 << 16;

              for ( i = idx + 1; i < end; i++ )
                decoder->buildchar[i] = 0;
            }
          }
          break;

        case cff_op_blend:
          /* this operator was removed from the Type2 specification */
          /* in version 16-March-2000                               */
          {
            FT_Int  num_results = (FT_Int)( args[0] >> 16 );


            FT_TRACE4(( " blend\n" ));

            if ( num_results < 0 )
              goto Syntax_Error;
d2205 1
a2205 10
            if ( num_results * (FT_Int)num_designs > num_args )
              goto Stack_Underflow;

            /* since we currently don't handle interpolation of multiple */
            /* master fonts, return the `num_results' values of the      */
            /* first master                                              */
            args     -= num_results * ( num_designs - 1 );
            num_args -= num_results * ( num_designs - 1 );
          }
          break;
a2277 2
          /*                                                           */
          /* XXX Fix return arguments (see discussion below).          */
a2278 2
          if ( args < stack )
            goto Stack_Underflow;
a2287 16
          /* XXX Increasing `args' is wrong: After a certain number of */
          /* `pop's we get a stack overflow.  Reason for doing it is   */
          /* code like this (actually found in a CFF font):            */
          /*                                                           */
          /*   17 1 3 callothersubr                                    */
          /*   pop                                                     */
          /*   callsubr                                                */
          /*                                                           */
          /* Since we handle `callothersubr' as a no-op, and           */
          /* `callsubr' needs at least one argument, `pop' can't be a  */
          /* no-op too as it basically should be.                      */
          /*                                                           */
          /* The right solution would be to provide real support for   */
          /* `callothersubr' as done in `t1decode.c', however, given   */
          /* the fact that CFF fonts with `pop' are invalid, it is     */
          /* questionable whether it is worth the time.                */
d2293 1
a2293 1
            FT_Fixed  cond = ( args[0] && args[1] );
d2305 1
a2305 1
            FT_Fixed  cond = ( args[0] || args[1] );
d2315 1
a2315 1
        case cff_op_not:
a2319 12
            FT_TRACE4(( " not\n" ));

            args[0] = cond ? 0x10000L : 0;
            args++;
          }
          break;

        case cff_op_eq:
          {
            FT_Fixed  cond = ( args[0] == args[1] );


d2346 1
a2346 3
            FT_TRACE4(( " callsubr (idx %d, entering level %d)\n",
                        idx,
                        zone - decoder->zones + 1 ));
d2388 1
a2388 3
            FT_TRACE4(( " callgsubr (idx %d, entering level %d)\n",
                        idx,
                        zone - decoder->zones + 1 ));
d2425 1
a2425 2
          FT_TRACE4(( " return (leaving level %d)\n",
                      decoder->zone - decoder->zones ));
d2441 1
d2448 1
a2448 1
          return FT_THROW( Unimplemented_Feature );
d2451 1
a2451 4
        decoder->top = args;

        if ( decoder->top - stack >= CFF_MAX_OPERANDS )
          goto Stack_Overflow;
a2461 5
  MM_Error:
    FT_TRACE4(( "cff_decoder_parse_charstrings:"
                " invalid opcode found in top DICT charstring\n"));
    return FT_THROW( Invalid_File_Format );

d2464 1
a2464 1
    return FT_THROW( Invalid_File_Format );
d2468 1
a2468 1
    return FT_THROW( Too_Few_Arguments );
d2472 1
a2472 1
    return FT_THROW( Stack_Overflow );
a2474 2
#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */

d2501 1
a2501 1
    FT_Error     error = FT_Err_Ok;
d2533 1
a2533 2
                                                 charstring_len,
                                                 0 );
d2539 1
a2539 1
      error = FT_Err_Ok;
d2544 1
a2544 1
    return FT_Err_Ok;
d2560 1
a2560 1
    FT_Bool      hinting, scaled, force_scaling;
d2581 1
a2581 1
          return FT_THROW( Invalid_Argument );
d2585 1
a2585 1
      return FT_THROW( Invalid_Argument );
d2621 1
a2621 1
                                       (FT_UInt)load_flags,
a2627 5
          FT_Bool    has_vertical_info;
          FT_UShort  advance;
          FT_Short   dummy;


a2653 33

          /* compute linear advance widths */

          (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                           glyph_index,
                                                           &dummy,
                                                           &advance );
          glyph->root.linearHoriAdvance = advance;

          has_vertical_info = FT_BOOL(
                                face->vertical_info                   &&
                                face->vertical.number_Of_VMetrics > 0 );

          /* get the vertical metrics from the vmtx table if we have one */
          if ( has_vertical_info )
          {
            (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                             glyph_index,
                                                             &dummy,
                                                             &advance );
            glyph->root.linearVertAdvance = advance;
          }
          else
          {
            /* make up vertical ones */
            if ( face->os2.version != 0xFFFFU )
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->os2.sTypoAscender - face->os2.sTypoDescender );
            else
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->horizontal.Ascender - face->horizontal.Descender );
          }

d2663 1
a2663 1
      return FT_THROW( Invalid_Argument );
a2670 1
      FT_Long  top_upm, sub_upm;
d2674 2
a2675 6

      if ( fd_index >= cff->num_subfonts )
        fd_index = (FT_Byte)( cff->num_subfonts - 1 );

      top_upm = (FT_Long)cff->top_font.font_dict.units_per_em;
      sub_upm = (FT_Long)cff->subfonts[fd_index]->font_dict.units_per_em;
d2698 2
a2699 4
    /* top-level code ensures that FT_LOAD_NO_HINTING is set */
    /* if FT_LOAD_NO_SCALE is active                         */
    hinting = FT_BOOL( ( load_flags & FT_LOAD_NO_HINTING ) == 0 );
    scaled  = FT_BOOL( ( load_flags & FT_LOAD_NO_SCALE   ) == 0 );
a2700 2
    glyph->hint        = hinting;
    glyph->scaled      = scaled;
a2703 5
#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      CFF_Driver  driver = (CFF_Driver)FT_FACE_DRIVER( face );
#endif


a2710 1
      /* this is for pure CFFs */
d2720 1
a2720 16
      if ( error )
        goto Glyph_Build_Finished;

      error = cff_decoder_prepare( &decoder, size, glyph_index );
      if ( error )
        goto Glyph_Build_Finished;

#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
      /* choose which CFF renderer to use */
      if ( driver->hinting_engine == FT_CFF_HINTING_FREETYPE )
        error = cff_decoder_parse_charstrings( &decoder,
                                               charstring,
                                               charstring_len,
                                               0 );
      else
#endif
d2722 2
a2723 7
        error = cf2_decoder_parse_charstrings( &decoder,
                                               charstring,
                                               charstring_len );

        /* Adobe's engine uses 16.16 numbers everywhere;              */
        /* as a consequence, glyphs larger than 2000ppem get rejected */
        if ( FT_ERR_EQ( error, Glyph_Too_Big ) )
d2725 1
a2725 8
          /* this time, we retry unhinted and scale up the glyph later on */
          /* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
          /* 0x400 for both `x_scale' and `y_scale' in this case)         */
          hinting       = FALSE;
          force_scaling = TRUE;
          glyph->hint   = hinting;

          error = cf2_decoder_parse_charstrings( &decoder,
a2727 2
        }
      }
d2729 1
a2729 1
      cff_free_glyph_data( face, &charstring, charstring_len );
a2730 2
      if ( error )
        goto Glyph_Build_Finished;
d2733 8
a2740 8
      /* Control data and length may not be available for incremental */
      /* fonts.                                                       */
      if ( face->root.internal->incremental_interface )
      {
        glyph->root.control_data = NULL;
        glyph->root.control_len = 0;
      }
      else
d2743 5
a2747 5
      /* We set control_data and control_len if charstrings is loaded. */
      /* See how charstring loads at cff_index_access_element() in     */
      /* cffload.c.                                                    */
      {
        CFF_Index  csindex = &cff->charstrings_index;
d2750 7
a2756 5
        if ( csindex->offsets )
        {
          glyph->root.control_data = csindex->bytes +
                                     csindex->offsets[glyph_index] - 1;
          glyph->root.control_len  = (FT_Long)charstring_len;
d2760 2
a2761 5
  Glyph_Build_Finished:
      /* save new glyph tables, if no error */
      if ( !error )
        cff_builder_done( &decoder.builder );
      /* XXX: anything to do for broken glyph entry? */
d2813 1
d2817 3
a2819 21
        if ( face->horizontal.number_Of_HMetrics )
        {
          FT_Short   horiBearingX = 0;
          FT_UShort  horiAdvance  = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                     glyph_index,
                                                     &horiBearingX,
                                                     &horiAdvance );
          metrics->horiAdvance          = horiAdvance;
          metrics->horiBearingX         = horiBearingX;
          glyph->root.linearHoriAdvance = horiAdvance;
        }
        else
        {
          /* copy the _unscaled_ advance width */
          metrics->horiAdvance          = decoder.glyph_width;
          glyph->root.linearHoriAdvance = decoder.glyph_width;
        }

d2822 5
d2829 1
d2831 1
a2831 1
        /* get the vertical metrics from the vmtx table if we have one */
d2866 4
a2869 4
        /* apply the font matrix, if any */
        if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
             font_matrix.xy != 0        || font_matrix.yx != 0        )
        {
d2872 2
a2873 8
          metrics->horiAdvance = FT_MulFix( metrics->horiAdvance,
                                            font_matrix.xx );
          metrics->vertAdvance = FT_MulFix( metrics->vertAdvance,
                                            font_matrix.yy );
        }

        if ( font_offset.x || font_offset.y )
        {
d2875 1
a2875 2
                                font_offset.x,
                                font_offset.y );
d2877 9
a2885 3
          metrics->horiAdvance += font_offset.x;
          metrics->vertAdvance += font_offset.y;
        }
d2922 1
a2922 1
        else
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
