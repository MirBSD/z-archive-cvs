head	1.4;
access;
symbols
	freetype-2_7_1:1.1.115.3
	freetype-2_3_12:1.1.115.2
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.2
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.1
	freetype:1.1.115;
locks; strict;
comment	@ * @;


1.4
date	2017.04.15.19.21.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	10058F2723111C7BEE2;

1.3
date	2013.08.06.19.47.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	100520152445E05B912;

1.2
date	2008.02.26.20.04.59;	author bsiegert;	state Exp;
branches;
next	1.1;
commitid	10047C470A72A1E13CE;

1.1
date	2006.06.29.18.37.41;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.115.1;
next	;
commitid	10044A41DBD6368BED5;

1.1.1.1
date	2008.02.26.19.53.02;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.115.1
date	2006.06.29.18.37.41;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41DBD6368BED5;

1.1.115.2
date	2013.08.06.19.12.24;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10052014A9975CEFD1D;

1.1.115.3
date	2017.04.15.15.42.07;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.4
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  gxvcommn.h                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT common tables validation (specification).             */
/*                                                                         */
/*  Copyright 2004-2016 by                                                 */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/


  /*
   * keywords in variable naming
   * ---------------------------
   *  table: Of type FT_Bytes, pointing to the start of this table/subtable.
   *  limit: Of type FT_Bytes, pointing to the end of this table/subtable,
   *         including padding for alignment.
   *  offset: Of type FT_UInt, the number of octets from the start to target.
   *  length: Of type FT_UInt, the number of octets from the start to the
   *          end in this table/subtable, including padding for alignment.
   *
   *  _MIN, _MAX: Should be added to the tail of macros, as INT_MIN, etc.
   */


#ifndef GXVCOMMN_H_
#define GXVCOMMN_H_


#include <ft2build.h>
#include "gxvalid.h"
#include FT_INTERNAL_DEBUG_H
#include FT_SFNT_NAMES_H


FT_BEGIN_HEADER


  /* some variables are not evaluated or only used in trace */

#ifdef  FT_DEBUG_LEVEL_TRACE
#define GXV_LOAD_TRACE_VARS
#else
#undef  GXV_LOAD_TRACE_VARS
#endif

#undef GXV_LOAD_UNUSED_VARS /* debug purpose */

#define IS_PARANOID_VALIDATION          ( gxvalid->root->level >= FT_VALIDATE_PARANOID )
#define GXV_SET_ERR_IF_PARANOID( err )  { if ( IS_PARANOID_VALIDATION ) ( err ); }

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                         VALIDATION                            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct GXV_ValidatorRec_*  GXV_Validator;


#define DUMMY_LIMIT 0

  typedef void
  (*GXV_Validate_Func)( FT_Bytes       table,
                        FT_Bytes       limit,
                        GXV_Validator  gxvalid );


  /* ====================== LookupTable Validator ======================== */

  typedef union  GXV_LookupValueDesc_
  {
    FT_UShort u;
    FT_Short  s;

  } GXV_LookupValueDesc;

  typedef const GXV_LookupValueDesc* GXV_LookupValueCPtr;

  typedef enum  GXV_LookupValue_SignSpec_
  {
    GXV_LOOKUPVALUE_UNSIGNED = 0,
    GXV_LOOKUPVALUE_SIGNED

  } GXV_LookupValue_SignSpec;


  typedef void
  (*GXV_Lookup_Value_Validate_Func)( FT_UShort            glyph,
                                     GXV_LookupValueCPtr  value_p,
                                     GXV_Validator        gxvalid );

  typedef GXV_LookupValueDesc
  (*GXV_Lookup_Fmt4_Transit_Func)( FT_UShort            relative_gindex,
                                   GXV_LookupValueCPtr  base_value_p,
                                   FT_Bytes             lookuptbl_limit,
                                   GXV_Validator        gxvalid );


  /* ====================== StateTable Validator ========================= */

  typedef enum  GXV_GlyphOffset_Format_
  {
    GXV_GLYPHOFFSET_NONE   = -1,
    GXV_GLYPHOFFSET_UCHAR  = 2,
    GXV_GLYPHOFFSET_CHAR,
    GXV_GLYPHOFFSET_USHORT = 4,
    GXV_GLYPHOFFSET_SHORT,
    GXV_GLYPHOFFSET_ULONG  = 8,
    GXV_GLYPHOFFSET_LONG

  } GXV_GlyphOffset_Format;


#define GXV_GLYPHOFFSET_FMT( table )           \
        ( gxvalid->table.entry_glyphoffset_fmt )

#define GXV_GLYPHOFFSET_SIZE( table )              \
        ( gxvalid->table.entry_glyphoffset_fmt / 2 )


  /* ----------------------- 16bit StateTable ---------------------------- */

  typedef union  GXV_StateTable_GlyphOffsetDesc_
  {
    FT_Byte    uc;
    FT_UShort  u;       /* same as GXV_LookupValueDesc */
    FT_ULong   ul;
    FT_Char    c;
    FT_Short   s;       /* same as GXV_LookupValueDesc */
    FT_Long    l;

  } GXV_StateTable_GlyphOffsetDesc;

  typedef const GXV_StateTable_GlyphOffsetDesc* GXV_StateTable_GlyphOffsetCPtr;

  typedef void
  (*GXV_StateTable_Subtable_Setup_Func)( FT_UShort      table_size,
                                         FT_UShort      classTable,
                                         FT_UShort      stateArray,
                                         FT_UShort      entryTable,
                                         FT_UShort*     classTable_length_p,
                                         FT_UShort*     stateArray_length_p,
                                         FT_UShort*     entryTable_length_p,
                                         GXV_Validator  gxvalid );

  typedef void
  (*GXV_StateTable_Entry_Validate_Func)(
     FT_Byte                         state,
     FT_UShort                       flags,
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        statetable_table,
     FT_Bytes                        statetable_limit,
     GXV_Validator                   gxvalid );

  typedef void
  (*GXV_StateTable_OptData_Load_Func)( FT_Bytes       table,
                                       FT_Bytes       limit,
                                       GXV_Validator  gxvalid );

  typedef struct  GXV_StateTable_ValidatorRec_
  {
    GXV_GlyphOffset_Format              entry_glyphoffset_fmt;
    void*                               optdata;

    GXV_StateTable_Subtable_Setup_Func  subtable_setup_func;
    GXV_StateTable_Entry_Validate_Func  entry_validate_func;
    GXV_StateTable_OptData_Load_Func    optdata_load_func;

  } GXV_StateTable_ValidatorRec, *GXV_StateTable_ValidatorRecData;


  /* ---------------------- 32bit XStateTable ---------------------------- */

  typedef GXV_StateTable_GlyphOffsetDesc  GXV_XStateTable_GlyphOffsetDesc;

  typedef const GXV_XStateTable_GlyphOffsetDesc* GXV_XStateTable_GlyphOffsetCPtr;

  typedef void
  (*GXV_XStateTable_Subtable_Setup_Func)( FT_ULong       table_size,
                                          FT_ULong       classTable,
                                          FT_ULong       stateArray,
                                          FT_ULong       entryTable,
                                          FT_ULong*      classTable_length_p,
                                          FT_ULong*      stateArray_length_p,
                                          FT_ULong*      entryTable_length_p,
                                          GXV_Validator  gxvalid );

  typedef void
  (*GXV_XStateTable_Entry_Validate_Func)(
     FT_UShort                       state,
     FT_UShort                       flags,
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        xstatetable_table,
     FT_Bytes                        xstatetable_limit,
     GXV_Validator                   gxvalid );


  typedef GXV_StateTable_OptData_Load_Func  GXV_XStateTable_OptData_Load_Func;


  typedef struct  GXV_XStateTable_ValidatorRec_
  {
    int                                  entry_glyphoffset_fmt;
    void*                                optdata;

    GXV_XStateTable_Subtable_Setup_Func  subtable_setup_func;
    GXV_XStateTable_Entry_Validate_Func  entry_validate_func;
    GXV_XStateTable_OptData_Load_Func    optdata_load_func;

    FT_ULong                             nClasses;
    FT_UShort                            maxClassID;

  } GXV_XStateTable_ValidatorRec, *GXV_XStateTable_ValidatorRecData;


  /* ===================================================================== */

  typedef struct  GXV_ValidatorRec_
  {
    FT_Validator  root;

    FT_Face       face;
    void*         table_data;

    FT_ULong      subtable_length;

    GXV_LookupValue_SignSpec        lookupval_sign;
    GXV_Lookup_Value_Validate_Func  lookupval_func;
    GXV_Lookup_Fmt4_Transit_Func    lookupfmt4_trans;
    FT_Bytes                        lookuptbl_head;

    FT_UShort  min_gid;
    FT_UShort  max_gid;

    GXV_StateTable_ValidatorRec     statetable;
    GXV_XStateTable_ValidatorRec    xstatetable;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_UInt             debug_indent;
    const FT_String*    debug_function_name[3];
#endif

  } GXV_ValidatorRec;


#define GXV_TABLE_DATA( tag, field )                           \
        ( ( (GXV_ ## tag ## _Data)gxvalid->table_data )->field )

#undef  FT_INVALID_
#define FT_INVALID_( _error ) \
          ft_validator_error( gxvalid->root, FT_THROW( _error ) )

#define GXV_LIMIT_CHECK( _count )                                     \
          FT_BEGIN_STMNT                                              \
            if ( p + _count > ( limit? limit : gxvalid->root->limit ) ) \
              FT_INVALID_TOO_SHORT;                                   \
          FT_END_STMNT


#ifdef FT_DEBUG_LEVEL_TRACE

#define GXV_INIT  gxvalid->debug_indent = 0

#define GXV_NAME_ENTER( name )                             \
          FT_BEGIN_STMNT                                   \
            gxvalid->debug_indent += 2;                      \
            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
            FT_TRACE4(( "%s table\n", name ));             \
          FT_END_STMNT

#define GXV_EXIT  gxvalid->debug_indent -= 2

#define GXV_TRACE( s )                                     \
          FT_BEGIN_STMNT                                   \
            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
            FT_TRACE4( s );                                \
          FT_END_STMNT

#else /* !FT_DEBUG_LEVEL_TRACE */

#define GXV_INIT                do { } while ( 0 )
#define GXV_NAME_ENTER( name )  do { } while ( 0 )
#define GXV_EXIT                do { } while ( 0 )

#define GXV_TRACE( s )          do { } while ( 0 )

#endif  /* !FT_DEBUG_LEVEL_TRACE */


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    32bit alignment checking                   *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

#define GXV_32BIT_ALIGNMENT_VALIDATE( a ) \
          FT_BEGIN_STMNT                  \
            {                             \
              if ( (a) & 3 )              \
                FT_INVALID_OFFSET;        \
            }                             \
          FT_END_STMNT


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    Dumping Binary Data                        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

#define GXV_TRACE_HEXDUMP( p, len )                     \
          FT_BEGIN_STMNT                                \
            {                                           \
              FT_Bytes  b;                              \
                                                        \
                                                        \
              for ( b = p; b < (FT_Bytes)p + len; b++ ) \
                FT_TRACE1(("\\x%02x", *b));             \
            }                                           \
          FT_END_STMNT

#define GXV_TRACE_HEXDUMP_C( p, len )                   \
          FT_BEGIN_STMNT                                \
            {                                           \
              FT_Bytes  b;                              \
                                                        \
                                                        \
              for ( b = p; b < (FT_Bytes)p + len; b++ ) \
                if ( 0x40 < *b && *b < 0x7E )           \
                  FT_TRACE1(("%c", *b));                \
                else                                    \
                  FT_TRACE1(("\\x%02x", *b));           \
            }                                           \
          FT_END_STMNT

#define GXV_TRACE_HEXDUMP_SFNTNAME( n )               \
          GXV_TRACE_HEXDUMP( n.string, n.string_len )


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                         LOOKUP TABLE                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( void )
  gxv_BinSrchHeader_validate( FT_Bytes       p,
                              FT_Bytes       limit,
                              FT_UShort*     unitSize_p,
                              FT_UShort*     nUnits_p,
                              GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_LookupTable_validate( FT_Bytes       table,
                            FT_Bytes       limit,
                            GXV_Validator  gxvalid );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                          Glyph ID                             *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( FT_Int )
  gxv_glyphid_validate( FT_UShort      gid,
                        GXV_Validator  gxvalid );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                        CONTROL POINT                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( void )
  gxv_ctlPoint_validate( FT_UShort      gid,
                         FT_UShort      ctl_point,
                         GXV_Validator  gxvalid );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                          SFNT NAME                            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( void )
  gxv_sfntName_validate( FT_UShort      name_index,
                         FT_UShort      min_index,
                         FT_UShort      max_index,
                         GXV_Validator  gxvalid );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                          STATE TABLE                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( void )
  gxv_StateTable_subtable_setup( FT_UShort      table_size,
                                 FT_UShort      classTable,
                                 FT_UShort      stateArray,
                                 FT_UShort      entryTable,
                                 FT_UShort*     classTable_length_p,
                                 FT_UShort*     stateArray_length_p,
                                 FT_UShort*     entryTable_length_p,
                                 GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_XStateTable_subtable_setup( FT_ULong       table_size,
                                  FT_ULong       classTable,
                                  FT_ULong       stateArray,
                                  FT_ULong       entryTable,
                                  FT_ULong*      classTable_length_p,
                                  FT_ULong*      stateArray_length_p,
                                  FT_ULong*      entryTable_length_p,
                                  GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_StateTable_validate( FT_Bytes       table,
                           FT_Bytes       limit,
                           GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_XStateTable_validate( FT_Bytes       table,
                            FT_Bytes       limit,
                            GXV_Validator  gxvalid );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                 UTILITY MACROS AND FUNCTIONS                  *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL( void )
  gxv_array_getlimits_byte( FT_Bytes       table,
                            FT_Bytes       limit,
                            FT_Byte*       min,
                            FT_Byte*       max,
                            GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_array_getlimits_ushort( FT_Bytes       table,
                              FT_Bytes       limit,
                              FT_UShort*     min,
                              FT_UShort*     max,
                              GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_set_length_by_ushort_offset( FT_UShort*     offset,
                                   FT_UShort**    length,
                                   FT_UShort*     buff,
                                   FT_UInt        nmemb,
                                   FT_UShort      limit,
                                   GXV_Validator  gxvalid );

  FT_LOCAL( void )
  gxv_set_length_by_ulong_offset( FT_ULong*      offset,
                                  FT_ULong**     length,
                                  FT_ULong*      buff,
                                  FT_UInt        nmemb,
                                  FT_ULong       limit,
                                  GXV_Validator  gxvalid);


#define GXV_SUBTABLE_OFFSET_CHECK( _offset )          \
          FT_BEGIN_STMNT                              \
            if ( (_offset) > gxvalid->subtable_length ) \
              FT_INVALID_OFFSET;                      \
          FT_END_STMNT

#define GXV_SUBTABLE_LIMIT_CHECK( _count )                  \
          FT_BEGIN_STMNT                                    \
            if ( ( p + (_count) - gxvalid->subtable_start ) > \
                   gxvalid->subtable_length )                 \
              FT_INVALID_TOO_SHORT;                         \
          FT_END_STMNT

#define GXV_USHORT_TO_SHORT( _us )                                    \
          ( ( 0x8000U < ( _us ) ) ? ( ( _us ) - 0x8000U ) : ( _us ) )

#define GXV_STATETABLE_HEADER_SIZE  ( 2 + 2 + 2 + 2 )
#define GXV_STATEHEADER_SIZE        GXV_STATETABLE_HEADER_SIZE

#define GXV_XSTATETABLE_HEADER_SIZE  ( 4 + 4 + 4 + 4 )
#define GXV_XSTATEHEADER_SIZE        GXV_XSTATETABLE_HEADER_SIZE


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                        Table overlapping                      *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct  GXV_odtect_DataRec_
  {
    FT_Bytes    start;
    FT_ULong    length;
    FT_String*  name;

  } GXV_odtect_DataRec,  *GXV_odtect_Data;

  typedef struct  GXV_odtect_RangeRec_
  {
    FT_UInt          nRanges;
    GXV_odtect_Data  range;

  } GXV_odtect_RangeRec, *GXV_odtect_Range;


  FT_LOCAL( void )
  gxv_odtect_add_range( FT_Bytes          start,
                        FT_ULong          length,
                        const FT_String*  name,
                        GXV_odtect_Range  odtect );

  FT_LOCAL( void )
  gxv_odtect_validate( GXV_odtect_Range  odtect,
                       GXV_Validator     gxvalid );


#define GXV_ODTECT( n, odtect )                              \
          GXV_odtect_DataRec   odtect ## _range[n];          \
          GXV_odtect_RangeRec  odtect ## _rec = { 0, NULL }; \
          GXV_odtect_Range     odtect = NULL

#define GXV_ODTECT_INIT( odtect )                      \
          FT_BEGIN_STMNT                               \
            odtect ## _rec.nRanges = 0;                \
            odtect ## _rec.range   = odtect ## _range; \
            odtect                 = & odtect ## _rec; \
          FT_END_STMNT


 /* */

FT_END_HEADER

#endif /* GXVCOMMN_H_ */


/* END */
@


1.3
log
@fastmerge
@
text
@d7 2
a8 1
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
d42 2
a43 2
#ifndef __GXVCOMMN_H__
#define __GXVCOMMN_H__
d55 13
d84 1
a84 1
                        GXV_Validator  valid );
d109 1
a109 1
                                     GXV_Validator        valid );
d115 1
a115 1
                                   GXV_Validator        valid );
d134 1
a134 1
        ( valid->table.entry_glyphoffset_fmt )
d137 1
a137 1
        ( valid->table.entry_glyphoffset_fmt / 2 )
d163 1
a163 1
                                         GXV_Validator  valid );
d172 1
a172 1
     GXV_Validator                   valid );
d177 1
a177 1
                                       GXV_Validator  valid );
d205 1
a205 1
                                          GXV_Validator  valid );
d214 1
a214 1
     GXV_Validator                   valid );
d251 3
d266 1
a266 1
        ( ( (GXV_ ## tag ## _Data)valid->table_data )->field )
d269 2
a270 2
#define FT_INVALID_( _prefix, _error )                         \
          ft_validator_error( valid->root, _prefix ## _error )
d274 1
a274 1
            if ( p + _count > ( limit? limit : valid->root->limit ) ) \
d281 1
a281 1
#define GXV_INIT  valid->debug_indent = 0
d285 2
a286 2
            valid->debug_indent += 2;                      \
            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
d290 1
a290 1
#define GXV_EXIT  valid->debug_indent -= 2
d294 1
a294 1
            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
d320 2
a321 2
              if ( 0 != ( (a) % 4 ) )     \
                FT_INVALID_OFFSET ;       \
d341 1
a341 1
                FT_TRACE1(("\\x%02x", *b)) ;            \
d352 2
a353 2
                if ( 0x40 < *b && *b < 0x7e )           \
                  FT_TRACE1(("%c", *b)) ;               \
d355 1
a355 1
                  FT_TRACE1(("\\x%02x", *b)) ;          \
d376 1
a376 1
                              GXV_Validator  valid );
d381 1
a381 1
                            GXV_Validator  valid );
d394 1
a394 1
                        GXV_Validator  valid );
d407 2
a408 2
                         FT_Short       ctl_point,
                         GXV_Validator  valid );
d423 1
a423 1
                         GXV_Validator  valid );
d442 1
a442 1
                                 GXV_Validator  valid );
d452 1
a452 1
                                  GXV_Validator  valid );
d457 1
a457 1
                           GXV_Validator  valid );
d462 1
a462 1
                            GXV_Validator  valid );
d478 1
a478 1
                            GXV_Validator  valid );
d485 1
a485 1
                              GXV_Validator  valid );
d493 1
a493 1
                                   GXV_Validator  valid );
d501 1
a501 1
                                  GXV_Validator  valid);
d506 1
a506 1
            if ( (_offset) > valid->subtable_length ) \
d512 2
a513 2
            if ( ( p + (_count) - valid->subtable_start ) > \
                   valid->subtable_length )                 \
d559 1
a559 1
                       GXV_Validator     valid );
d579 1
a579 1
#endif /* __GXVCOMMN_H__ */
@


1.2
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d82 2
d94 1
a94 1
                                     GXV_LookupValueDesc  value,
d99 1
a99 1
                                   GXV_LookupValueDesc  base_value,
d139 1
d155 1
a155 1
     GXV_StateTable_GlyphOffsetDesc  glyphOffset,
d181 2
d197 1
a197 1
     GXV_StateTable_GlyphOffsetDesc  glyphOffset,
d283 3
a285 3
#define GXV_INIT                do ; while ( 0 )
#define GXV_NAME_ENTER( name )  do ; while ( 0 )
#define GXV_EXIT                do ; while ( 0 )
d287 1
a287 1
#define GXV_TRACE( s )          do ; while ( 0 )
@


1.1
log
@Initial revision
@
text
@d129 1
a129 1
    FT_UShort  u;   	/* same as GXV_LookupValueDesc */
d132 1
a132 1
    FT_Short   s;   	/* same as GXV_LookupValueDesc */
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d129 1
a129 1
    FT_UShort  u;       /* same as GXV_LookupValueDesc */
d132 1
a132 1
    FT_Short   s;       /* same as GXV_LookupValueDesc */
@


1.1.115.1
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@@


1.1.115.2
log
@we need newer freetype for advance calculation
@
text
@a81 2
  typedef const GXV_LookupValueDesc* GXV_LookupValueCPtr;

d92 1
a92 1
                                     GXV_LookupValueCPtr  value_p,
d97 1
a97 1
                                   GXV_LookupValueCPtr  base_value_p,
d129 1
a129 1
    FT_UShort  u;       /* same as GXV_LookupValueDesc */
d132 1
a132 1
    FT_Short   s;       /* same as GXV_LookupValueDesc */
a136 1
  typedef const GXV_StateTable_GlyphOffsetDesc* GXV_StateTable_GlyphOffsetCPtr;
d152 1
a152 1
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
a177 2
  typedef const GXV_XStateTable_GlyphOffsetDesc* GXV_XStateTable_GlyphOffsetCPtr;

d192 1
a192 1
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
d278 3
a280 3
#define GXV_INIT                do { } while ( 0 )
#define GXV_NAME_ENTER( name )  do { } while ( 0 )
#define GXV_EXIT                do { } while ( 0 )
d282 1
a282 1
#define GXV_TRACE( s )          do { } while ( 0 )
@


1.1.115.3
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 2
/*  Copyright 2004-2016 by                                                 */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
d41 2
a42 2
#ifndef GXVCOMMN_H_
#define GXVCOMMN_H_
a53 13
  /* some variables are not evaluated or only used in trace */

#ifdef  FT_DEBUG_LEVEL_TRACE
#define GXV_LOAD_TRACE_VARS
#else
#undef  GXV_LOAD_TRACE_VARS
#endif

#undef GXV_LOAD_UNUSED_VARS /* debug purpose */

#define IS_PARANOID_VALIDATION          ( gxvalid->root->level >= FT_VALIDATE_PARANOID )
#define GXV_SET_ERR_IF_PARANOID( err )  { if ( IS_PARANOID_VALIDATION ) ( err ); }

d70 1
a70 1
                        GXV_Validator  gxvalid );
d95 1
a95 1
                                     GXV_Validator        gxvalid );
d101 1
a101 1
                                   GXV_Validator        gxvalid );
d120 1
a120 1
        ( gxvalid->table.entry_glyphoffset_fmt )
d123 1
a123 1
        ( gxvalid->table.entry_glyphoffset_fmt / 2 )
d149 1
a149 1
                                         GXV_Validator  gxvalid );
d158 1
a158 1
     GXV_Validator                   gxvalid );
d163 1
a163 1
                                       GXV_Validator  gxvalid );
d191 1
a191 1
                                          GXV_Validator  gxvalid );
d200 1
a200 1
     GXV_Validator                   gxvalid );
a236 3
    FT_UShort  min_gid;
    FT_UShort  max_gid;

d249 1
a249 1
        ( ( (GXV_ ## tag ## _Data)gxvalid->table_data )->field )
d252 2
a253 2
#define FT_INVALID_( _error ) \
          ft_validator_error( gxvalid->root, FT_THROW( _error ) )
d257 1
a257 1
            if ( p + _count > ( limit? limit : gxvalid->root->limit ) ) \
d264 1
a264 1
#define GXV_INIT  gxvalid->debug_indent = 0
d268 2
a269 2
            gxvalid->debug_indent += 2;                      \
            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
d273 1
a273 1
#define GXV_EXIT  gxvalid->debug_indent -= 2
d277 1
a277 1
            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
d303 2
a304 2
              if ( (a) & 3 )              \
                FT_INVALID_OFFSET;        \
d324 1
a324 1
                FT_TRACE1(("\\x%02x", *b));             \
d335 2
a336 2
                if ( 0x40 < *b && *b < 0x7E )           \
                  FT_TRACE1(("%c", *b));                \
d338 1
a338 1
                  FT_TRACE1(("\\x%02x", *b));           \
d359 1
a359 1
                              GXV_Validator  gxvalid );
d364 1
a364 1
                            GXV_Validator  gxvalid );
d377 1
a377 1
                        GXV_Validator  gxvalid );
d390 2
a391 2
                         FT_UShort      ctl_point,
                         GXV_Validator  gxvalid );
d406 1
a406 1
                         GXV_Validator  gxvalid );
d425 1
a425 1
                                 GXV_Validator  gxvalid );
d435 1
a435 1
                                  GXV_Validator  gxvalid );
d440 1
a440 1
                           GXV_Validator  gxvalid );
d445 1
a445 1
                            GXV_Validator  gxvalid );
d461 1
a461 1
                            GXV_Validator  gxvalid );
d468 1
a468 1
                              GXV_Validator  gxvalid );
d476 1
a476 1
                                   GXV_Validator  gxvalid );
d484 1
a484 1
                                  GXV_Validator  gxvalid);
d489 1
a489 1
            if ( (_offset) > gxvalid->subtable_length ) \
d495 2
a496 2
            if ( ( p + (_count) - gxvalid->subtable_start ) > \
                   gxvalid->subtable_length )                 \
d542 1
a542 1
                       GXV_Validator     gxvalid );
d562 1
a562 1
#endif /* GXVCOMMN_H_ */
@


