head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.22.02;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.45;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.04;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.04;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.31;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.39.11;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.42;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.31;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.23;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.12;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftraster.c                                                             */
/*                                                                         */
/*    The FreeType glyph rasterizer (body).                                */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* This file can be compiled without the rest of the FreeType engine, by */
  /* defining the STANDALONE_ macro when compiling it.  You also need to   */
  /* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
  /* directory.  Typically, you should do something like                   */
  /*                                                                       */
  /* - copy `src/raster/ftraster.c' (this file) to your current directory  */
  /*                                                                       */
  /* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h' to your */
  /*   current directory                                                   */
  /*                                                                       */
  /* - compile `ftraster' with the STANDALONE_ macro defined, as in        */
  /*                                                                       */
  /*     cc -c -DSTANDALONE_ ftraster.c                                    */
  /*                                                                       */
  /* The renderer can be initialized with a call to                        */
  /* `ft_standard_raster.raster_new'; a bitmap can be generated            */
  /* with a call to `ft_standard_raster.raster_render'.                    */
  /*                                                                       */
  /* See the comments and documentation in the file `ftimage.h' for more   */
  /* details on how the raster works.                                      */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This is a rewrite of the FreeType 1.x scan-line converter             */
  /*                                                                       */
  /*************************************************************************/

#ifdef STANDALONE_

  /* The size in bytes of the render pool used by the scan-line converter  */
  /* to do all of its work.                                                */
#define FT_RENDER_POOL_SIZE  16384L

#define FT_CONFIG_STANDARD_LIBRARY_H  <stdlib.h>

#include <string.h>           /* for memset */

#include "ftmisc.h"
#include "ftimage.h"

#else /* !STANDALONE_ */

#include <ft2build.h>
#include "ftraster.h"
#include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */

#include "rastpic.h"

#endif /* !STANDALONE_ */


  /*************************************************************************/
  /*                                                                       */
  /* A simple technical note on how the raster works                       */
  /* -----------------------------------------------                       */
  /*                                                                       */
  /*   Converting an outline into a bitmap is achieved in several steps:   */
  /*                                                                       */
  /*   1 - Decomposing the outline into successive `profiles'.  Each       */
  /*       profile is simply an array of scanline intersections on a given */
  /*       dimension.  A profile's main attributes are                     */
  /*                                                                       */
  /*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
  /*                                                                       */
  /*       o an array of intersection coordinates for each scanline        */
  /*         between `Ymin' and `Ymax'                                     */
  /*                                                                       */
  /*       o a direction, indicating whether it was built going `up' or    */
  /*         `down', as this is very important for filling rules           */
  /*                                                                       */
  /*       o its drop-out mode                                             */
  /*                                                                       */
  /*   2 - Sweeping the target map's scanlines in order to compute segment */
  /*       `spans' which are then filled.  Additionally, this pass         */
  /*       performs drop-out control.                                      */
  /*                                                                       */
  /*   The outline data is parsed during step 1 only.  The profiles are    */
  /*   built from the bottom of the render pool, used as a stack.  The     */
  /*   following graphics shows the profile list under construction:       */
  /*                                                                       */
  /*     __________________________________________________________ _ _    */
  /*    |         |                 |         |                 |          */
  /*    | profile | coordinates for | profile | coordinates for |-->       */
  /*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
  /*    |_________|_________________|_________|_________________|__ _ _    */
  /*                                                                       */
  /*    ^                                                       ^          */
  /*    |                                                       |          */
  /* start of render pool                                      top         */
  /*                                                                       */
  /*   The top of the profile stack is kept in the `top' variable.         */
  /*                                                                       */
  /*   As you can see, a profile record is pushed on top of the render     */
  /*   pool, which is then followed by its coordinates/intersections.  If  */
  /*   a change of direction is detected in the outline, a new profile is  */
  /*   generated until the end of the outline.                             */
  /*                                                                       */
  /*   Note that when all profiles have been generated, the function       */
  /*   Finalize_Profile_Table() is used to record, for each profile, its   */
  /*   bottom-most scanline as well as the scanline above its upmost       */
  /*   boundary.  These positions are called `y-turns' because they (sort  */
  /*   of) correspond to local extrema.  They are stored in a sorted list  */
  /*   built from the top of the render pool as a downwards stack:         */
  /*                                                                       */
  /*      _ _ _______________________________________                      */
  /*                            |                    |                     */
  /*                         <--| sorted list of     |                     */
  /*                         <--|  extrema scanlines |                     */
  /*      _ _ __________________|____________________|                     */
  /*                                                                       */
  /*                            ^                    ^                     */
  /*                            |                    |                     */
  /*                         maxBuff           sizeBuff = end of pool      */
  /*                                                                       */
  /*   This list is later used during the sweep phase in order to          */
  /*   optimize performance (see technical note on the sweep below).       */
  /*                                                                       */
  /*   Of course, the raster detects whether the two stacks collide and    */
  /*   handles the situation properly.                                     */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*************************************************************************/
  /**                                                                     **/
  /**  CONFIGURATION MACROS                                               **/
  /**                                                                     **/
  /*************************************************************************/
  /*************************************************************************/

  /* define DEBUG_RASTER if you want to compile a debugging version */
/* #define DEBUG_RASTER */


  /*************************************************************************/
  /*************************************************************************/
  /**                                                                     **/
  /**  OTHER MACROS (do not change)                                       **/
  /**                                                                     **/
  /*************************************************************************/
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_raster


#ifdef STANDALONE_

  /* Auxiliary macros for token concatenation. */
#define FT_ERR_XCAT( x, y )  x ## y
#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )

  /* This macro is used to indicate that a function parameter is unused. */
  /* Its purpose is simply to reduce compiler warnings.  Note also that  */
  /* simply defining it as `(void)x' doesn't avoid warnings with certain */
  /* ANSI compilers (e.g. LCC).                                          */
#define FT_UNUSED( x )  (x) = (x)

  /* Disable the tracing mechanism for simplicity -- developers can      */
  /* activate it easily by redefining these macros.                      */
#ifndef FT_ERROR
#define FT_ERROR( x )  do { } while ( 0 )     /* nothing */
#endif

#ifndef FT_TRACE
#define FT_TRACE( x )   do { } while ( 0 )    /* nothing */
#define FT_TRACE1( x )  do { } while ( 0 )    /* nothing */
#define FT_TRACE6( x )  do { } while ( 0 )    /* nothing */
#define FT_TRACE7( x )  do { } while ( 0 )    /* nothing */
#endif

#ifndef FT_THROW
#define FT_THROW( e )  FT_ERR_CAT( Raster_Err_, e )
#endif

#define Raster_Err_None          0
#define Raster_Err_Not_Ini      -1
#define Raster_Err_Overflow     -2
#define Raster_Err_Neg_Height   -3
#define Raster_Err_Invalid      -4
#define Raster_Err_Unsupported  -5

#define ft_memset  memset

#define FT_DEFINE_RASTER_FUNCS( class_, glyph_format_, raster_new_, \
                                raster_reset_, raster_set_mode_,    \
                                raster_render_, raster_done_ )      \
          const FT_Raster_Funcs class_ =                            \
          {                                                         \
            glyph_format_,                                          \
            raster_new_,                                            \
            raster_reset_,                                          \
            raster_set_mode_,                                       \
            raster_render_,                                         \
            raster_done_                                            \
         };

#else /* !STANDALONE_ */


#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_DEBUG_H       /* for FT_TRACE, FT_ERROR, and FT_THROW */

#include "rasterrs.h"

#define Raster_Err_None         FT_Err_Ok
#define Raster_Err_Not_Ini      Raster_Err_Raster_Uninitialized
#define Raster_Err_Overflow     Raster_Err_Raster_Overflow
#define Raster_Err_Neg_Height   Raster_Err_Raster_Negative_Height
#define Raster_Err_Invalid      Raster_Err_Invalid_Outline
#define Raster_Err_Unsupported  Raster_Err_Cannot_Render_Glyph


#endif /* !STANDALONE_ */


#ifndef FT_MEM_SET
#define FT_MEM_SET( d, s, c )  ft_memset( d, s, c )
#endif

#ifndef FT_MEM_ZERO
#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
#endif

#ifndef FT_ZERO
#define FT_ZERO( p )  FT_MEM_ZERO( p, sizeof ( *(p) ) )
#endif

  /* FMulDiv means `Fast MulDiv'; it is used in case where `b' is       */
  /* typically a small value and the result of a*b is known to fit into */
  /* 32 bits.                                                           */
#define FMulDiv( a, b, c )  ( (a) * (b) / (c) )

  /* On the other hand, SMulDiv means `Slow MulDiv', and is used typically */
  /* for clipping computations.  It simply uses the FT_MulDiv() function   */
  /* defined in `ftcalc.h'.                                                */
#define SMulDiv           FT_MulDiv
#define SMulDiv_No_Round  FT_MulDiv_No_Round

  /* The rasterizer is a very general purpose component; please leave */
  /* the following redefinitions there (you never know your target    */
  /* environment).                                                    */

#ifndef TRUE
#define TRUE   1
#endif

#ifndef FALSE
#define FALSE  0
#endif

#ifndef NULL
#define NULL  (void*)0
#endif

#ifndef SUCCESS
#define SUCCESS  0
#endif

#ifndef FAILURE
#define FAILURE  1
#endif


#define MaxBezier  32   /* The maximum number of stacked Bezier curves. */
                        /* Setting this constant to more than 32 is a   */
                        /* pure waste of space.                         */

#define Pixel_Bits  6   /* fractional bits of *input* coordinates */


  /*************************************************************************/
  /*************************************************************************/
  /**                                                                     **/
  /**  SIMPLE TYPE DECLARATIONS                                           **/
  /**                                                                     **/
  /*************************************************************************/
  /*************************************************************************/

  typedef int             Int;
  typedef unsigned int    UInt;
  typedef short           Short;
  typedef unsigned short  UShort, *PUShort;
  typedef long            Long, *PLong;
  typedef unsigned long   ULong;

  typedef unsigned char   Byte, *PByte;
  typedef char            Bool;


  typedef union  Alignment_
  {
    Long    l;
    void*   p;
    void  (*f)(void);

  } Alignment, *PAlignment;


  typedef struct  TPoint_
  {
    Long  x;
    Long  y;

  } TPoint;


  /* values for the `flags' bit field */
#define Flow_Up           0x08U
#define Overshoot_Top     0x10U
#define Overshoot_Bottom  0x20U


  /* States of each line, arc, and profile */
  typedef enum  TStates_
  {
    Unknown_State,
    Ascending_State,
    Descending_State,
    Flat_State

  } TStates;


  typedef struct TProfile_  TProfile;
  typedef TProfile*         PProfile;

  struct  TProfile_
  {
    FT_F26Dot6  X;           /* current coordinate during sweep          */
    PProfile    link;        /* link to next profile (various purposes)  */
    PLong       offset;      /* start of profile's data in render pool   */
    UShort      flags;       /* Bit 0-2: drop-out mode                   */
                             /* Bit 3: profile orientation (up/down)     */
                             /* Bit 4: is top profile?                   */
                             /* Bit 5: is bottom profile?                */
    Long        height;      /* profile's height in scanlines            */
    Long        start;       /* profile's starting scanline              */

    Int         countL;      /* number of lines to step before this      */
                             /* profile becomes drawable                 */

    PProfile    next;        /* next profile in same contour, used       */
                             /* during drop-out control                  */
  };

  typedef PProfile   TProfileList;
  typedef PProfile*  PProfileList;


  /* Simple record used to implement a stack of bands, required */
  /* by the sub-banding mechanism                               */
  typedef struct  black_TBand_
  {
    Short  y_min;   /* band's minimum */
    Short  y_max;   /* band's maximum */

  } black_TBand;


#define AlignProfileSize \
  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( Long ) )


#undef RAS_ARG
#undef RAS_ARGS
#undef RAS_VAR
#undef RAS_VARS

#ifdef FT_STATIC_RASTER


#define RAS_ARGS       /* void */
#define RAS_ARG        /* void */

#define RAS_VARS       /* void */
#define RAS_VAR        /* void */

#define FT_UNUSED_RASTER  do { } while ( 0 )


#else /* !FT_STATIC_RASTER */


#define RAS_ARGS       black_PWorker  worker,
#define RAS_ARG        black_PWorker  worker

#define RAS_VARS       worker,
#define RAS_VAR        worker

#define FT_UNUSED_RASTER  FT_UNUSED( worker )


#endif /* !FT_STATIC_RASTER */


  typedef struct black_TWorker_  black_TWorker, *black_PWorker;


  /* prototypes used for sweep function dispatch */
  typedef void
  Function_Sweep_Init( RAS_ARGS Short*  min,
                                Short*  max );

  typedef void
  Function_Sweep_Span( RAS_ARGS Short       y,
                                FT_F26Dot6  x1,
                                FT_F26Dot6  x2,
                                PProfile    left,
                                PProfile    right );

  typedef void
  Function_Sweep_Step( RAS_ARG );


  /* NOTE: These operations are only valid on 2's complement processors */
#undef FLOOR
#undef CEILING
#undef TRUNC
#undef SCALED

#define FLOOR( x )    ( (x) & -ras.precision )
#define CEILING( x )  ( ( (x) + ras.precision - 1 ) & -ras.precision )
#define TRUNC( x )    ( (Long)(x) >> ras.precision_bits )
#define FRAC( x )     ( (x) & ( ras.precision - 1 ) )
#define SCALED( x )   ( ( (x) < 0 ? -( -(x) << ras.scale_shift )   \
                                  :  (  (x) << ras.scale_shift ) ) \
                        - ras.precision_half )

#define IS_BOTTOM_OVERSHOOT( x ) \
          (Bool)( CEILING( x ) - x >= ras.precision_half )
#define IS_TOP_OVERSHOOT( x )    \
          (Bool)( x - FLOOR( x ) >= ras.precision_half )

#if FT_RENDER_POOL_SIZE > 2048
#define FT_MAX_BLACK_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( Long ) )
#else
#define FT_MAX_BLACK_POOL  ( 2048 / sizeof ( Long ) )
#endif

  /* The most used variables are positioned at the top of the structure. */
  /* Thus, their offset can be coded with less opcodes, resulting in a   */
  /* smaller executable.                                                 */

  struct  black_TWorker_
  {
    Int         precision_bits;     /* precision related variables         */
    Int         precision;
    Int         precision_half;
    Int         precision_shift;
    Int         precision_step;
    Int         precision_jitter;

    Int         scale_shift;        /* == precision_shift   for bitmaps    */
                                    /* == precision_shift+1 for pixmaps    */

    PLong       buff;               /* The profiles buffer                 */
    PLong       sizeBuff;           /* Render pool size                    */
    PLong       maxBuff;            /* Profiles buffer size                */
    PLong       top;                /* Current cursor in buffer            */

    FT_Error    error;

    Int         numTurns;           /* number of Y-turns in outline        */

    TPoint*     arc;                /* current Bezier arc pointer          */

    UShort      bWidth;             /* target bitmap width                 */
    PByte       bTarget;            /* target bitmap buffer                */
    PByte       gTarget;            /* target pixmap buffer                */

    Long        lastX, lastY;
    Long        minY, maxY;

    UShort      num_Profs;          /* current number of profiles          */

    Bool        fresh;              /* signals a fresh new profile which   */
                                    /* `start' field must be completed     */
    Bool        joint;              /* signals that the last arc ended     */
                                    /* exactly on a scanline.  Allows      */
                                    /* removal of doublets                 */
    PProfile    cProfile;           /* current profile                     */
    PProfile    fProfile;           /* head of linked list of profiles     */
    PProfile    gProfile;           /* contour's first profile in case     */
                                    /* of impact                           */

    TStates     state;              /* rendering state                     */

    FT_Bitmap   target;             /* description of target bit/pixmap    */
    FT_Outline  outline;

    Long        traceOfs;           /* current offset in target bitmap     */
    Long        traceG;             /* current offset in target pixmap     */

    Short       traceIncr;          /* sweep's increment in target bitmap  */

    /* dispatch variables */

    Function_Sweep_Init*  Proc_Sweep_Init;
    Function_Sweep_Span*  Proc_Sweep_Span;
    Function_Sweep_Span*  Proc_Sweep_Drop;
    Function_Sweep_Step*  Proc_Sweep_Step;

    Byte        dropOutControl;     /* current drop_out control method     */

    Bool        second_pass;        /* indicates whether a horizontal pass */
                                    /* should be performed to control      */
                                    /* drop-out accurately when calling    */
                                    /* Render_Glyph.                       */

    TPoint      arcs[3 * MaxBezier + 1]; /* The Bezier stack               */

    black_TBand  band_stack[16];    /* band stack used for sub-banding     */
    Int          band_top;          /* band stack top                      */

  };


  typedef struct  black_TRaster_
  {
    void*          memory;

  } black_TRaster, *black_PRaster;

#ifdef FT_STATIC_RASTER

  static black_TWorker  cur_ras;
#define ras  cur_ras

#else /* !FT_STATIC_RASTER */

#define ras  (*worker)

#endif /* !FT_STATIC_RASTER */


  /*************************************************************************/
  /*************************************************************************/
  /**                                                                     **/
  /**  PROFILES COMPUTATION                                               **/
  /**                                                                     **/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Set_High_Precision                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Set precision variables according to param flag.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    High :: Set to True for high precision (typically for ppem < 24),  */
  /*            false otherwise.                                           */
  /*                                                                       */
  static void
  Set_High_Precision( RAS_ARGS Int  High )
  {
    /*
     * `precision_step' is used in `Bezier_Up' to decide when to split a
     * given y-monotonous Bezier arc that crosses a scanline before
     * approximating it as a straight segment.  The default value of 32 (for
     * low accuracy) corresponds to
     *
     *   32 / 64 == 0.5 pixels,
     *
     * while for the high accuracy case we have
     *
     *   256 / (1 << 12) = 0.0625 pixels.
     *
     * `precision_jitter' is an epsilon threshold used in
     * `Vertical_Sweep_Span' to deal with small imperfections in the Bezier
     * decomposition (after all, we are working with approximations only);
     * it avoids switching on additional pixels which would cause artifacts
     * otherwise.
     *
     * The value of `precision_jitter' has been determined heuristically.
     *
     */

    if ( High )
    {
      ras.precision_bits   = 12;
      ras.precision_step   = 256;
      ras.precision_jitter = 30;
    }
    else
    {
      ras.precision_bits   = 6;
      ras.precision_step   = 32;
      ras.precision_jitter = 2;
    }

    FT_TRACE6(( "Set_High_Precision(%s)\n", High ? "true" : "false" ));

    ras.precision       = 1 << ras.precision_bits;
    ras.precision_half  = ras.precision / 2;
    ras.precision_shift = ras.precision_bits - Pixel_Bits;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    New_Profile                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Create a new profile in the render pool.                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    aState    :: The state/orientation of the new profile.             */
  /*                                                                       */
  /*    overshoot :: Whether the profile's unrounded start position        */
  /*                 differs by at least a half pixel.                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */
  /*   profile.                                                            */
  /*                                                                       */
  static Bool
  New_Profile( RAS_ARGS TStates  aState,
                        Bool     overshoot )
  {
    if ( !ras.fProfile )
    {
      ras.cProfile  = (PProfile)ras.top;
      ras.fProfile  = ras.cProfile;
      ras.top      += AlignProfileSize;
    }

    if ( ras.top >= ras.maxBuff )
    {
      ras.error = FT_THROW( Overflow );
      return FAILURE;
    }

    ras.cProfile->flags  = 0;
    ras.cProfile->start  = 0;
    ras.cProfile->height = 0;
    ras.cProfile->offset = ras.top;
    ras.cProfile->link   = (PProfile)0;
    ras.cProfile->next   = (PProfile)0;
    ras.cProfile->flags  = ras.dropOutControl;

    switch ( aState )
    {
    case Ascending_State:
      ras.cProfile->flags |= Flow_Up;
      if ( overshoot )
        ras.cProfile->flags |= Overshoot_Bottom;

      FT_TRACE6(( "  new ascending profile = %p\n", ras.cProfile ));
      break;

    case Descending_State:
      if ( overshoot )
        ras.cProfile->flags |= Overshoot_Top;
      FT_TRACE6(( "  new descending profile = %p\n", ras.cProfile ));
      break;

    default:
      FT_ERROR(( "New_Profile: invalid profile direction\n" ));
      ras.error = FT_THROW( Invalid );
      return FAILURE;
    }

    if ( !ras.gProfile )
      ras.gProfile = ras.cProfile;

    ras.state = aState;
    ras.fresh = TRUE;
    ras.joint = FALSE;

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    End_Profile                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalize the current profile.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    overshoot :: Whether the profile's unrounded end position differs  */
  /*                 by at least a half pixel.                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */
  /*                                                                       */
  static Bool
  End_Profile( RAS_ARGS Bool  overshoot )
  {
    Long  h;


    h = (Long)( ras.top - ras.cProfile->offset );

    if ( h < 0 )
    {
      FT_ERROR(( "End_Profile: negative height encountered\n" ));
      ras.error = FT_THROW( Neg_Height );
      return FAILURE;
    }

    if ( h > 0 )
    {
      PProfile  oldProfile;


      FT_TRACE6(( "  ending profile %p, start = %ld, height = %ld\n",
                  ras.cProfile, ras.cProfile->start, h ));

      ras.cProfile->height = h;
      if ( overshoot )
      {
        if ( ras.cProfile->flags & Flow_Up )
          ras.cProfile->flags |= Overshoot_Top;
        else
          ras.cProfile->flags |= Overshoot_Bottom;
      }

      oldProfile   = ras.cProfile;
      ras.cProfile = (PProfile)ras.top;

      ras.top += AlignProfileSize;

      ras.cProfile->height = 0;
      ras.cProfile->offset = ras.top;

      oldProfile->next = ras.cProfile;
      ras.num_Profs++;
    }

    if ( ras.top >= ras.maxBuff )
    {
      FT_TRACE1(( "overflow in End_Profile\n" ));
      ras.error = FT_THROW( Overflow );
      return FAILURE;
    }

    ras.joint = FALSE;

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Insert_Y_Turn                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Insert a salient into the sorted list placed on top of the render  */
  /*    pool.                                                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    New y scanline position.                                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success.  FAILURE in case of overflow.                  */
  /*                                                                       */
  static Bool
  Insert_Y_Turn( RAS_ARGS Int  y )
  {
    PLong  y_turns;
    Int    n;


    n       = ras.numTurns - 1;
    y_turns = ras.sizeBuff - ras.numTurns;

    /* look for first y value that is <= */
    while ( n >= 0 && y < y_turns[n] )
      n--;

    /* if it is <, simply insert it, ignore if == */
    if ( n >= 0 && y > y_turns[n] )
      do
      {
        Int  y2 = (Int)y_turns[n];


        y_turns[n] = y;
        y = y2;
      } while ( --n >= 0 );

    if ( n < 0 )
    {
      ras.maxBuff--;
      if ( ras.maxBuff <= ras.top )
      {
        ras.error = FT_THROW( Overflow );
        return FAILURE;
      }
      ras.numTurns++;
      ras.sizeBuff[-ras.numTurns] = y;
    }

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Finalize_Profile_Table                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Adjust all links in the profiles list.                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success.  FAILURE in case of overflow.                  */
  /*                                                                       */
  static Bool
  Finalize_Profile_Table( RAS_ARG )
  {
    UShort    n;
    PProfile  p;


    n = ras.num_Profs;
    p = ras.fProfile;

    if ( n > 1 && p )
    {
      do
      {
        Int  bottom, top;


        if ( n > 1 )
          p->link = (PProfile)( p->offset + p->height );
        else
          p->link = NULL;

        if ( p->flags & Flow_Up )
        {
          bottom = (Int)p->start;
          top    = (Int)( p->start + p->height - 1 );
        }
        else
        {
          bottom     = (Int)( p->start - p->height + 1 );
          top        = (Int)p->start;
          p->start   = bottom;
          p->offset += p->height - 1;
        }

        if ( Insert_Y_Turn( RAS_VARS bottom )  ||
             Insert_Y_Turn( RAS_VARS top + 1 ) )
          return FAILURE;

        p = p->link;
      } while ( --n );
    }
    else
      ras.fProfile = NULL;

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Split_Conic                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
  /*    stack.                                                             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    None (subdivided Bezier is taken from the top of the stack).       */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This routine is the `beef' of this component.  It is  _the_ inner  */
  /*    loop that should be optimized to hell to get the best performance. */
  /*                                                                       */
  static void
  Split_Conic( TPoint*  base )
  {
    Long  a, b;


    base[4].x = base[2].x;
    b = base[1].x;
    a = base[3].x = ( base[2].x + b ) / 2;
    b = base[1].x = ( base[0].x + b ) / 2;
    base[2].x = ( a + b ) / 2;

    base[4].y = base[2].y;
    b = base[1].y;
    a = base[3].y = ( base[2].y + b ) / 2;
    b = base[1].y = ( base[0].y + b ) / 2;
    base[2].y = ( a + b ) / 2;

    /* hand optimized.  gcc doesn't seem to be too good at common      */
    /* expression substitution and instruction scheduling ;-)          */
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Split_Cubic                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
  /*    Bezier stack.                                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This routine is the `beef' of the component.  It is one of _the_   */
  /*    inner loops that should be optimized like hell to get the best     */
  /*    performance.                                                       */
  /*                                                                       */
  static void
  Split_Cubic( TPoint*  base )
  {
    Long  a, b, c, d;


    base[6].x = base[3].x;
    c = base[1].x;
    d = base[2].x;
    base[1].x = a = ( base[0].x + c + 1 ) >> 1;
    base[5].x = b = ( base[3].x + d + 1 ) >> 1;
    c = ( c + d + 1 ) >> 1;
    base[2].x = a = ( a + c + 1 ) >> 1;
    base[4].x = b = ( b + c + 1 ) >> 1;
    base[3].x = ( a + b + 1 ) >> 1;

    base[6].y = base[3].y;
    c = base[1].y;
    d = base[2].y;
    base[1].y = a = ( base[0].y + c + 1 ) >> 1;
    base[5].y = b = ( base[3].y + d + 1 ) >> 1;
    c = ( c + d + 1 ) >> 1;
    base[2].y = a = ( a + c + 1 ) >> 1;
    base[4].y = b = ( b + c + 1 ) >> 1;
    base[3].y = ( a + b + 1 ) >> 1;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Line_Up                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the x-coordinates of an ascending line segment and store   */
  /*    them in the render pool.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    x1   :: The x-coordinate of the segment's start point.             */
  /*                                                                       */
  /*    y1   :: The y-coordinate of the segment's start point.             */
  /*                                                                       */
  /*    x2   :: The x-coordinate of the segment's end point.               */
  /*                                                                       */
  /*    y2   :: The y-coordinate of the segment's end point.               */
  /*                                                                       */
  /*    miny :: A lower vertical clipping bound value.                     */
  /*                                                                       */
  /*    maxy :: An upper vertical clipping bound value.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE on render pool overflow.               */
  /*                                                                       */
  static Bool
  Line_Up( RAS_ARGS Long  x1,
                    Long  y1,
                    Long  x2,
                    Long  y2,
                    Long  miny,
                    Long  maxy )
  {
    Long   Dx, Dy;
    Int    e1, e2, f1, f2, size;     /* XXX: is `Short' sufficient? */
    Long   Ix, Rx, Ax;

    PLong  top;


    Dx = x2 - x1;
    Dy = y2 - y1;

    if ( Dy <= 0 || y2 < miny || y1 > maxy )
      return SUCCESS;

    if ( y1 < miny )
    {
      /* Take care: miny-y1 can be a very large value; we use     */
      /*            a slow MulDiv function to avoid clipping bugs */
      x1 += SMulDiv( Dx, miny - y1, Dy );
      e1  = (Int)TRUNC( miny );
      f1  = 0;
    }
    else
    {
      e1 = (Int)TRUNC( y1 );
      f1 = (Int)FRAC( y1 );
    }

    if ( y2 > maxy )
    {
      /* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY */
      e2  = (Int)TRUNC( maxy );
      f2  = 0;
    }
    else
    {
      e2 = (Int)TRUNC( y2 );
      f2 = (Int)FRAC( y2 );
    }

    if ( f1 > 0 )
    {
      if ( e1 == e2 )
        return SUCCESS;
      else
      {
        x1 += SMulDiv( Dx, ras.precision - f1, Dy );
        e1 += 1;
      }
    }
    else
      if ( ras.joint )
      {
        ras.top--;
        ras.joint = FALSE;
      }

    ras.joint = (char)( f2 == 0 );

    if ( ras.fresh )
    {
      ras.cProfile->start = e1;
      ras.fresh           = FALSE;
    }

    size = e2 - e1 + 1;
    if ( ras.top + size >= ras.maxBuff )
    {
      ras.error = FT_THROW( Overflow );
      return FAILURE;
    }

    if ( Dx > 0 )
    {
      Ix = SMulDiv_No_Round( ras.precision, Dx, Dy );
      Rx = ( ras.precision * Dx ) % Dy;
      Dx = 1;
    }
    else
    {
      Ix = -SMulDiv_No_Round( ras.precision, -Dx, Dy );
      Rx = ( ras.precision * -Dx ) % Dy;
      Dx = -1;
    }

    Ax  = -Dy;
    top = ras.top;

    while ( size > 0 )
    {
      *top++ = x1;

      x1 += Ix;
      Ax += Rx;
      if ( Ax >= 0 )
      {
        Ax -= Dy;
        x1 += Dx;
      }
      size--;
    }

    ras.top = top;
    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Line_Down                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the x-coordinates of an descending line segment and store  */
  /*    them in the render pool.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    x1   :: The x-coordinate of the segment's start point.             */
  /*                                                                       */
  /*    y1   :: The y-coordinate of the segment's start point.             */
  /*                                                                       */
  /*    x2   :: The x-coordinate of the segment's end point.               */
  /*                                                                       */
  /*    y2   :: The y-coordinate of the segment's end point.               */
  /*                                                                       */
  /*    miny :: A lower vertical clipping bound value.                     */
  /*                                                                       */
  /*    maxy :: An upper vertical clipping bound value.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE on render pool overflow.               */
  /*                                                                       */
  static Bool
  Line_Down( RAS_ARGS Long  x1,
                      Long  y1,
                      Long  x2,
                      Long  y2,
                      Long  miny,
                      Long  maxy )
  {
    Bool  result, fresh;


    fresh  = ras.fresh;

    result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );

    if ( fresh && !ras.fresh )
      ras.cProfile->start = -ras.cProfile->start;

    return result;
  }


  /* A function type describing the functions used to split Bezier arcs */
  typedef void  (*TSplitter)( TPoint*  base );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Bezier_Up                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the x-coordinates of an ascending Bezier arc and store     */
  /*    them in the render pool.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
  /*                                                                       */
  /*    splitter :: The function to split Bezier arcs.                     */
  /*                                                                       */
  /*    miny     :: A lower vertical clipping bound value.                 */
  /*                                                                       */
  /*    maxy     :: An upper vertical clipping bound value.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE on render pool overflow.               */
  /*                                                                       */
  static Bool
  Bezier_Up( RAS_ARGS Int        degree,
                      TSplitter  splitter,
                      Long       miny,
                      Long       maxy )
  {
    Long   y1, y2, e, e2, e0;
    Short  f1;

    TPoint*  arc;
    TPoint*  start_arc;

    PLong top;


    arc = ras.arc;
    y1  = arc[degree].y;
    y2  = arc[0].y;
    top = ras.top;

    if ( y2 < miny || y1 > maxy )
      goto Fin;

    e2 = FLOOR( y2 );

    if ( e2 > maxy )
      e2 = maxy;

    e0 = miny;

    if ( y1 < miny )
      e = miny;
    else
    {
      e  = CEILING( y1 );
      f1 = (Short)( FRAC( y1 ) );
      e0 = e;

      if ( f1 == 0 )
      {
        if ( ras.joint )
        {
          top--;
          ras.joint = FALSE;
        }

        *top++ = arc[degree].x;

        e += ras.precision;
      }
    }

    if ( ras.fresh )
    {
      ras.cProfile->start = TRUNC( e0 );
      ras.fresh = FALSE;
    }

    if ( e2 < e )
      goto Fin;

    if ( ( top + TRUNC( e2 - e ) + 1 ) >= ras.maxBuff )
    {
      ras.top   = top;
      ras.error = FT_THROW( Overflow );
      return FAILURE;
    }

    start_arc = arc;

    do
    {
      ras.joint = FALSE;

      y2 = arc[0].y;

      if ( y2 > e )
      {
        y1 = arc[degree].y;
        if ( y2 - y1 >= ras.precision_step )
        {
          splitter( arc );
          arc += degree;
        }
        else
        {
          *top++ = arc[degree].x + FMulDiv( arc[0].x - arc[degree].x,
                                            e - y1, y2 - y1 );
          arc -= degree;
          e   += ras.precision;
        }
      }
      else
      {
        if ( y2 == e )
        {
          ras.joint  = TRUE;
          *top++     = arc[0].x;

          e += ras.precision;
        }
        arc -= degree;
      }
    } while ( arc >= start_arc && e <= e2 );

  Fin:
    ras.top  = top;
    ras.arc -= degree;
    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Bezier_Down                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the x-coordinates of an descending Bezier arc and store    */
  /*    them in the render pool.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
  /*                                                                       */
  /*    splitter :: The function to split Bezier arcs.                     */
  /*                                                                       */
  /*    miny     :: A lower vertical clipping bound value.                 */
  /*                                                                       */
  /*    maxy     :: An upper vertical clipping bound value.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE on render pool overflow.               */
  /*                                                                       */
  static Bool
  Bezier_Down( RAS_ARGS Int        degree,
                        TSplitter  splitter,
                        Long       miny,
                        Long       maxy )
  {
    TPoint*  arc = ras.arc;
    Bool     result, fresh;


    arc[0].y = -arc[0].y;
    arc[1].y = -arc[1].y;
    arc[2].y = -arc[2].y;
    if ( degree > 2 )
      arc[3].y = -arc[3].y;

    fresh = ras.fresh;

    result = Bezier_Up( RAS_VARS degree, splitter, -maxy, -miny );

    if ( fresh && !ras.fresh )
      ras.cProfile->start = -ras.cProfile->start;

    arc[0].y = -arc[0].y;
    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Line_To                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Inject a new line segment and adjust the Profiles list.            */
  /*                                                                       */
  /* <Input>                                                               */
  /*   x :: The x-coordinate of the segment's end point (its start point   */
  /*        is stored in `lastX').                                         */
  /*                                                                       */
  /*   y :: The y-coordinate of the segment's end point (its start point   */
  /*        is stored in `lastY').                                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
  /*   profile.                                                            */
  /*                                                                       */
  static Bool
  Line_To( RAS_ARGS Long  x,
                    Long  y )
  {
    /* First, detect a change of direction */

    switch ( ras.state )
    {
    case Unknown_State:
      if ( y > ras.lastY )
      {
        if ( New_Profile( RAS_VARS Ascending_State,
                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
          return FAILURE;
      }
      else
      {
        if ( y < ras.lastY )
          if ( New_Profile( RAS_VARS Descending_State,
                                     IS_TOP_OVERSHOOT( ras.lastY ) ) )
            return FAILURE;
      }
      break;

    case Ascending_State:
      if ( y < ras.lastY )
      {
        if ( End_Profile( RAS_VARS IS_TOP_OVERSHOOT( ras.lastY ) ) ||
             New_Profile( RAS_VARS Descending_State,
                                   IS_TOP_OVERSHOOT( ras.lastY ) ) )
          return FAILURE;
      }
      break;

    case Descending_State:
      if ( y > ras.lastY )
      {
        if ( End_Profile( RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY ) ) ||
             New_Profile( RAS_VARS Ascending_State,
                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
          return FAILURE;
      }
      break;

    default:
      ;
    }

    /* Then compute the lines */

    switch ( ras.state )
    {
    case Ascending_State:
      if ( Line_Up( RAS_VARS ras.lastX, ras.lastY,
                             x, y, ras.minY, ras.maxY ) )
        return FAILURE;
      break;

    case Descending_State:
      if ( Line_Down( RAS_VARS ras.lastX, ras.lastY,
                               x, y, ras.minY, ras.maxY ) )
        return FAILURE;
      break;

    default:
      ;
    }

    ras.lastX = x;
    ras.lastY = y;

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Conic_To                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Inject a new conic arc and adjust the profile list.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*   cx :: The x-coordinate of the arc's new control point.              */
  /*                                                                       */
  /*   cy :: The y-coordinate of the arc's new control point.              */
  /*                                                                       */
  /*   x  :: The x-coordinate of the arc's end point (its start point is   */
  /*         stored in `lastX').                                           */
  /*                                                                       */
  /*   y  :: The y-coordinate of the arc's end point (its start point is   */
  /*         stored in `lastY').                                           */
  /*                                                                       */
  /* <Return>                                                              */
  /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
  /*   profile.                                                            */
  /*                                                                       */
  static Bool
  Conic_To( RAS_ARGS Long  cx,
                     Long  cy,
                     Long  x,
                     Long  y )
  {
    Long     y1, y2, y3, x3, ymin, ymax;
    TStates  state_bez;


    ras.arc      = ras.arcs;
    ras.arc[2].x = ras.lastX;
    ras.arc[2].y = ras.lastY;
    ras.arc[1].x = cx;
    ras.arc[1].y = cy;
    ras.arc[0].x = x;
    ras.arc[0].y = y;

    do
    {
      y1 = ras.arc[2].y;
      y2 = ras.arc[1].y;
      y3 = ras.arc[0].y;
      x3 = ras.arc[0].x;

      /* first, categorize the Bezier arc */

      if ( y1 <= y3 )
      {
        ymin = y1;
        ymax = y3;
      }
      else
      {
        ymin = y3;
        ymax = y1;
      }

      if ( y2 < ymin || y2 > ymax )
      {
        /* this arc has no given direction, split it! */
        Split_Conic( ras.arc );
        ras.arc += 2;
      }
      else if ( y1 == y3 )
      {
        /* this arc is flat, ignore it and pop it from the Bezier stack */
        ras.arc -= 2;
      }
      else
      {
        /* the arc is y-monotonous, either ascending or descending */
        /* detect a change of direction                            */
        state_bez = y1 < y3 ? Ascending_State : Descending_State;
        if ( ras.state != state_bez )
        {
          Bool  o = ( state_bez == Ascending_State )
                      ? IS_BOTTOM_OVERSHOOT( y1 )
                      : IS_TOP_OVERSHOOT( y1 );


          /* finalize current profile if any */
          if ( ras.state != Unknown_State &&
               End_Profile( RAS_VARS o )  )
            goto Fail;

          /* create a new profile */
          if ( New_Profile( RAS_VARS state_bez, o ) )
            goto Fail;
        }

        /* now call the appropriate routine */
        if ( state_bez == Ascending_State )
        {
          if ( Bezier_Up( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
            goto Fail;
        }
        else
          if ( Bezier_Down( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
            goto Fail;
      }

    } while ( ras.arc >= ras.arcs );

    ras.lastX = x3;
    ras.lastY = y3;

    return SUCCESS;

  Fail:
    return FAILURE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Cubic_To                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Inject a new cubic arc and adjust the profile list.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*   cx1 :: The x-coordinate of the arc's first new control point.       */
  /*                                                                       */
  /*   cy1 :: The y-coordinate of the arc's first new control point.       */
  /*                                                                       */
  /*   cx2 :: The x-coordinate of the arc's second new control point.      */
  /*                                                                       */
  /*   cy2 :: The y-coordinate of the arc's second new control point.      */
  /*                                                                       */
  /*   x   :: The x-coordinate of the arc's end point (its start point is  */
  /*          stored in `lastX').                                          */
  /*                                                                       */
  /*   y   :: The y-coordinate of the arc's end point (its start point is  */
  /*          stored in `lastY').                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
  /*   profile.                                                            */
  /*                                                                       */
  static Bool
  Cubic_To( RAS_ARGS Long  cx1,
                     Long  cy1,
                     Long  cx2,
                     Long  cy2,
                     Long  x,
                     Long  y )
  {
    Long     y1, y2, y3, y4, x4, ymin1, ymax1, ymin2, ymax2;
    TStates  state_bez;


    ras.arc      = ras.arcs;
    ras.arc[3].x = ras.lastX;
    ras.arc[3].y = ras.lastY;
    ras.arc[2].x = cx1;
    ras.arc[2].y = cy1;
    ras.arc[1].x = cx2;
    ras.arc[1].y = cy2;
    ras.arc[0].x = x;
    ras.arc[0].y = y;

    do
    {
      y1 = ras.arc[3].y;
      y2 = ras.arc[2].y;
      y3 = ras.arc[1].y;
      y4 = ras.arc[0].y;
      x4 = ras.arc[0].x;

      /* first, categorize the Bezier arc */

      if ( y1 <= y4 )
      {
        ymin1 = y1;
        ymax1 = y4;
      }
      else
      {
        ymin1 = y4;
        ymax1 = y1;
      }

      if ( y2 <= y3 )
      {
        ymin2 = y2;
        ymax2 = y3;
      }
      else
      {
        ymin2 = y3;
        ymax2 = y2;
      }

      if ( ymin2 < ymin1 || ymax2 > ymax1 )
      {
        /* this arc has no given direction, split it! */
        Split_Cubic( ras.arc );
        ras.arc += 3;
      }
      else if ( y1 == y4 )
      {
        /* this arc is flat, ignore it and pop it from the Bezier stack */
        ras.arc -= 3;
      }
      else
      {
        state_bez = ( y1 <= y4 ) ? Ascending_State : Descending_State;

        /* detect a change of direction */
        if ( ras.state != state_bez )
        {
          Bool  o = ( state_bez == Ascending_State )
                      ? IS_BOTTOM_OVERSHOOT( y1 )
                      : IS_TOP_OVERSHOOT( y1 );


          /* finalize current profile if any */
          if ( ras.state != Unknown_State &&
               End_Profile( RAS_VARS o )  )
            goto Fail;

          if ( New_Profile( RAS_VARS state_bez, o ) )
            goto Fail;
        }

        /* compute intersections */
        if ( state_bez == Ascending_State )
        {
          if ( Bezier_Up( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )
            goto Fail;
        }
        else
          if ( Bezier_Down( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )
            goto Fail;
      }

    } while ( ras.arc >= ras.arcs );

    ras.lastX = x4;
    ras.lastY = y4;

    return SUCCESS;

  Fail:
    return FAILURE;
  }


#undef  SWAP_
#define SWAP_( x, y )  do                \
                       {                 \
                         Long  swap = x; \
                                         \
                                         \
                         x = y;          \
                         y = swap;       \
                       } while ( 0 )


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Decompose_Curve                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Scan the outline arrays in order to emit individual segments and   */
  /*    Beziers by calling Line_To() and Bezier_To().  It handles all      */
  /*    weird cases, like when the first point is off the curve, or when   */
  /*    there are simply no `on' points in the contour!                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    first   :: The index of the first point in the contour.            */
  /*                                                                       */
  /*    last    :: The index of the last point in the contour.             */
  /*                                                                       */
  /*    flipped :: If set, flip the direction of the curve.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE on error.                              */
  /*                                                                       */
  static Bool
  Decompose_Curve( RAS_ARGS UShort  first,
                            UShort  last,
                            Int     flipped )
  {
    FT_Vector   v_last;
    FT_Vector   v_control;
    FT_Vector   v_start;

    FT_Vector*  points;
    FT_Vector*  point;
    FT_Vector*  limit;
    char*       tags;

    UInt        tag;       /* current point's state           */


    points = ras.outline.points;
    limit  = points + last;

    v_start.x = SCALED( points[first].x );
    v_start.y = SCALED( points[first].y );
    v_last.x  = SCALED( points[last].x );
    v_last.y  = SCALED( points[last].y );

    if ( flipped )
    {
      SWAP_( v_start.x, v_start.y );
      SWAP_( v_last.x, v_last.y );
    }

    v_control = v_start;

    point = points + first;
    tags  = ras.outline.tags + first;

    /* set scan mode if necessary */
    if ( tags[0] & FT_CURVE_TAG_HAS_SCANMODE )
      ras.dropOutControl = (Byte)tags[0] >> 5;

    tag = FT_CURVE_TAG( tags[0] );

    /* A contour cannot start with a cubic control point! */
    if ( tag == FT_CURVE_TAG_CUBIC )
      goto Invalid_Outline;

    /* check first point to determine origin */
    if ( tag == FT_CURVE_TAG_CONIC )
    {
      /* first point is conic control.  Yes, this happens. */
      if ( FT_CURVE_TAG( ras.outline.tags[last] ) == FT_CURVE_TAG_ON )
      {
        /* start at last point if it is on the curve */
        v_start = v_last;
        limit--;
      }
      else
      {
        /* if both first and last points are conic,         */
        /* start at their middle and record its position    */
        /* for closure                                      */
        v_start.x = ( v_start.x + v_last.x ) / 2;
        v_start.y = ( v_start.y + v_last.y ) / 2;

     /* v_last = v_start; */
      }
      point--;
      tags--;
    }

    ras.lastX = v_start.x;
    ras.lastY = v_start.y;

    while ( point < limit )
    {
      point++;
      tags++;

      tag = FT_CURVE_TAG( tags[0] );

      switch ( tag )
      {
      case FT_CURVE_TAG_ON:  /* emit a single line_to */
        {
          Long  x, y;


          x = SCALED( point->x );
          y = SCALED( point->y );
          if ( flipped )
            SWAP_( x, y );

          if ( Line_To( RAS_VARS x, y ) )
            goto Fail;
          continue;
        }

      case FT_CURVE_TAG_CONIC:  /* consume conic arcs */
        v_control.x = SCALED( point[0].x );
        v_control.y = SCALED( point[0].y );

        if ( flipped )
          SWAP_( v_control.x, v_control.y );

      Do_Conic:
        if ( point < limit )
        {
          FT_Vector  v_middle;
          Long       x, y;


          point++;
          tags++;
          tag = FT_CURVE_TAG( tags[0] );

          x = SCALED( point[0].x );
          y = SCALED( point[0].y );

          if ( flipped )
            SWAP_( x, y );

          if ( tag == FT_CURVE_TAG_ON )
          {
            if ( Conic_To( RAS_VARS v_control.x, v_control.y, x, y ) )
              goto Fail;
            continue;
          }

          if ( tag != FT_CURVE_TAG_CONIC )
            goto Invalid_Outline;

          v_middle.x = ( v_control.x + x ) / 2;
          v_middle.y = ( v_control.y + y ) / 2;

          if ( Conic_To( RAS_VARS v_control.x, v_control.y,
                                  v_middle.x,  v_middle.y ) )
            goto Fail;

          v_control.x = x;
          v_control.y = y;

          goto Do_Conic;
        }

        if ( Conic_To( RAS_VARS v_control.x, v_control.y,
                                v_start.x,   v_start.y ) )
          goto Fail;

        goto Close;

      default:  /* FT_CURVE_TAG_CUBIC */
        {
          Long  x1, y1, x2, y2, x3, y3;


          if ( point + 1 > limit                             ||
               FT_CURVE_TAG( tags[1] ) != FT_CURVE_TAG_CUBIC )
            goto Invalid_Outline;

          point += 2;
          tags  += 2;

          x1 = SCALED( point[-2].x );
          y1 = SCALED( point[-2].y );
          x2 = SCALED( point[-1].x );
          y2 = SCALED( point[-1].y );

          if ( flipped )
          {
            SWAP_( x1, y1 );
            SWAP_( x2, y2 );
          }

          if ( point <= limit )
          {
            x3 = SCALED( point[0].x );
            y3 = SCALED( point[0].y );

            if ( flipped )
              SWAP_( x3, y3 );

            if ( Cubic_To( RAS_VARS x1, y1, x2, y2, x3, y3 ) )
              goto Fail;
            continue;
          }

          if ( Cubic_To( RAS_VARS x1, y1, x2, y2, v_start.x, v_start.y ) )
            goto Fail;
          goto Close;
        }
      }
    }

    /* close the contour with a line segment */
    if ( Line_To( RAS_VARS v_start.x, v_start.y ) )
      goto Fail;

  Close:
    return SUCCESS;

  Invalid_Outline:
    ras.error = FT_THROW( Invalid );

  Fail:
    return FAILURE;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Convert_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Convert a glyph into a series of segments and arcs and make a      */
  /*    profiles list with them.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    flipped :: If set, flip the direction of curve.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    SUCCESS on success, FAILURE if any error was encountered during    */
  /*    rendering.                                                         */
  /*                                                                       */
  static Bool
  Convert_Glyph( RAS_ARGS Int  flipped )
  {
    Int   i;
    UInt  start;


    ras.fProfile = NULL;
    ras.joint    = FALSE;
    ras.fresh    = FALSE;

    ras.maxBuff  = ras.sizeBuff - AlignProfileSize;

    ras.numTurns = 0;

    ras.cProfile         = (PProfile)ras.top;
    ras.cProfile->offset = ras.top;
    ras.num_Profs        = 0;

    start = 0;

    for ( i = 0; i < ras.outline.n_contours; i++ )
    {
      PProfile  lastProfile;
      Bool      o;


      ras.state    = Unknown_State;
      ras.gProfile = NULL;

      if ( Decompose_Curve( RAS_VARS (UShort)start,
                                     (UShort)ras.outline.contours[i],
                                     flipped ) )
        return FAILURE;

      start = (UShort)ras.outline.contours[i] + 1;

      /* we must now check whether the extreme arcs join or not */
      if ( FRAC( ras.lastY ) == 0 &&
           ras.lastY >= ras.minY  &&
           ras.lastY <= ras.maxY  )
        if ( ras.gProfile                        &&
             ( ras.gProfile->flags & Flow_Up ) ==
               ( ras.cProfile->flags & Flow_Up ) )
          ras.top--;
        /* Note that ras.gProfile can be nil if the contour was too small */
        /* to be drawn.                                                   */

      lastProfile = ras.cProfile;
      if ( ras.top != ras.cProfile->offset &&
           ( ras.cProfile->flags & Flow_Up ) )
        o = IS_TOP_OVERSHOOT( ras.lastY );
      else
        o = IS_BOTTOM_OVERSHOOT( ras.lastY );
      if ( End_Profile( RAS_VARS o ) )
        return FAILURE;

      /* close the `next profile in contour' linked list */
      if ( ras.gProfile )
        lastProfile->next = ras.gProfile;
    }

    if ( Finalize_Profile_Table( RAS_VAR ) )
      return FAILURE;

    return (Bool)( ras.top < ras.maxBuff ? SUCCESS : FAILURE );
  }


  /*************************************************************************/
  /*************************************************************************/
  /**                                                                     **/
  /**  SCAN-LINE SWEEPS AND DRAWING                                       **/
  /**                                                                     **/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /*  Init_Linked                                                          */
  /*                                                                       */
  /*    Initializes an empty linked list.                                  */
  /*                                                                       */
  static void
  Init_Linked( TProfileList*  l )
  {
    *l = NULL;
  }


  /*************************************************************************/
  /*                                                                       */
  /*  InsNew                                                               */
  /*                                                                       */
  /*    Inserts a new profile in a linked list.                            */
  /*                                                                       */
  static void
  InsNew( PProfileList  list,
          PProfile      profile )
  {
    PProfile  *old, current;
    Long       x;


    old     = list;
    current = *old;
    x       = profile->X;

    while ( current )
    {
      if ( x < current->X )
        break;
      old     = &current->link;
      current = *old;
    }

    profile->link = current;
    *old          = profile;
  }


  /*************************************************************************/
  /*                                                                       */
  /*  DelOld                                                               */
  /*                                                                       */
  /*    Removes an old profile from a linked list.                         */
  /*                                                                       */
  static void
  DelOld( PProfileList  list,
          PProfile      profile )
  {
    PProfile  *old, current;


    old     = list;
    current = *old;

    while ( current )
    {
      if ( current == profile )
      {
        *old = current->link;
        return;
      }

      old     = &current->link;
      current = *old;
    }

    /* we should never get there, unless the profile was not part of */
    /* the list.                                                     */
  }


  /*************************************************************************/
  /*                                                                       */
  /*  Sort                                                                 */
  /*                                                                       */
  /*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */
  /*    an algorithm which is fast in this case.  Bubble sort is enough    */
  /*    and simple.                                                        */
  /*                                                                       */
  static void
  Sort( PProfileList  list )
  {
    PProfile  *old, current, next;


    /* First, set the new X coordinate of each profile */
    current = *list;
    while ( current )
    {
      current->X       = *current->offset;
      current->offset += ( current->flags & Flow_Up ) ? 1 : -1;
      current->height--;
      current = current->link;
    }

    /* Then sort them */
    old     = list;
    current = *old;

    if ( !current )
      return;

    next = current->link;

    while ( next )
    {
      if ( current->X <= next->X )
      {
        old     = &current->link;
        current = *old;

        if ( !current )
          return;
      }
      else
      {
        *old          = next;
        current->link = next->link;
        next->link    = current;

        old     = list;
        current = *old;
      }

      next = current->link;
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /*  Vertical Sweep Procedure Set                                         */
  /*                                                                       */
  /*  These four routines are used during the vertical black/white sweep   */
  /*  phase by the generic Draw_Sweep() function.                          */
  /*                                                                       */
  /*************************************************************************/

  static void
  Vertical_Sweep_Init( RAS_ARGS Short*  min,
                                Short*  max )
  {
    Long  pitch = ras.target.pitch;

    FT_UNUSED( max );


    ras.traceIncr = (Short)-pitch;
    ras.traceOfs  = -*min * pitch;
    if ( pitch > 0 )
      ras.traceOfs += (Long)( ras.target.rows - 1 ) * pitch;
  }


  static void
  Vertical_Sweep_Span( RAS_ARGS Short       y,
                                FT_F26Dot6  x1,
                                FT_F26Dot6  x2,
                                PProfile    left,
                                PProfile    right )
  {
    Long   e1, e2;
    Byte*  target;

    Int  dropOutControl = left->flags & 7;

    FT_UNUSED( y );
    FT_UNUSED( left );
    FT_UNUSED( right );


    /* in high-precision mode, we need 12 digits after the comma to */
    /* represent multiples of 1/(1<<12) = 1/4096                    */
    FT_TRACE7(( "  y=%d x=[%.12f;%.12f], drop-out=%d",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision,
                dropOutControl ));

    /* Drop-out control */

    e1 = TRUNC( CEILING( x1 ) );

    if ( dropOutControl != 2                             &&
         x2 - x1 - ras.precision <= ras.precision_jitter )
      e2 = e1;
    else
      e2 = TRUNC( FLOOR( x2 ) );

    if ( e2 >= 0 && e1 < ras.bWidth )
    {
      Int   c1, c2;
      Byte  f1, f2;


      if ( e1 < 0 )
        e1 = 0;
      if ( e2 >= ras.bWidth )
        e2 = ras.bWidth - 1;

      FT_TRACE7(( " -> x=[%d;%d]", e1, e2 ));

      c1 = (Short)( e1 >> 3 );
      c2 = (Short)( e2 >> 3 );

      f1 = (Byte)  ( 0xFF >> ( e1 & 7 ) );
      f2 = (Byte) ~( 0x7F >> ( e2 & 7 ) );

      target = ras.bTarget + ras.traceOfs + c1;
      c2 -= c1;

      if ( c2 > 0 )
      {
        target[0] |= f1;

        /* memset() is slower than the following code on many platforms. */
        /* This is due to the fact that, in the vast majority of cases,  */
        /* the span length in bytes is relatively small.                 */
        c2--;
        while ( c2 > 0 )
        {
          *(++target) = 0xFF;
          c2--;
        }
        target[1] |= f2;
      }
      else
        *target |= ( f1 & f2 );
    }

    FT_TRACE7(( "\n" ));
  }


  static void
  Vertical_Sweep_Drop( RAS_ARGS Short       y,
                                FT_F26Dot6  x1,
                                FT_F26Dot6  x2,
                                PProfile    left,
                                PProfile    right )
  {
    Long   e1, e2, pxl;
    Short  c1, f1;


    FT_TRACE7(( "  y=%d x=[%.12f;%.12f]",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision ));

    /* Drop-out control */

    /*   e2            x2                    x1           e1   */
    /*                                                         */
    /*                 ^                     |                 */
    /*                 |                     |                 */
    /*   +-------------+---------------------+------------+    */
    /*                 |                     |                 */
    /*                 |                     v                 */
    /*                                                         */
    /* pixel         contour              contour       pixel  */
    /* center                                           center */

    /* drop-out mode    scan conversion rules (as defined in OpenType) */
    /* --------------------------------------------------------------- */
    /*  0                1, 2, 3                                       */
    /*  1                1, 2, 4                                       */
    /*  2                1, 2                                          */
    /*  3                same as mode 2                                */
    /*  4                1, 2, 5                                       */
    /*  5                1, 2, 6                                       */
    /*  6, 7             same as mode 2                                */

    e1  = CEILING( x1 );
    e2  = FLOOR  ( x2 );
    pxl = e1;

    if ( e1 > e2 )
    {
      Int  dropOutControl = left->flags & 7;


      FT_TRACE7(( ", drop-out=%d", dropOutControl ));

      if ( e1 == e2 + ras.precision )
      {
        switch ( dropOutControl )
        {
        case 0: /* simple drop-outs including stubs */
          pxl = e2;
          break;

        case 4: /* smart drop-outs including stubs */
          pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;

        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */

          /* Drop-out Control Rules #4 and #6 */

          /* The specification neither provides an exact definition */
          /* of a `stub' nor gives exact rules to exclude them.     */
          /*                                                        */
          /* Here the constraints we use to recognize a stub.       */
          /*                                                        */
          /*  upper stub:                                           */
          /*                                                        */
          /*   - P_Left and P_Right are in the same contour         */
          /*   - P_Right is the successor of P_Left in that contour */
          /*   - y is the top of P_Left and P_Right                 */
          /*                                                        */
          /*  lower stub:                                           */
          /*                                                        */
          /*   - P_Left and P_Right are in the same contour         */
          /*   - P_Left is the successor of P_Right in that contour */
          /*   - y is the bottom of P_Left                          */
          /*                                                        */
          /* We draw a stub if the following constraints are met.   */
          /*                                                        */
          /*   - for an upper or lower stub, there is top or bottom */
          /*     overshoot, respectively                            */
          /*   - the covered interval is greater or equal to a half */
          /*     pixel                                              */

          /* upper stub test */
          if ( left->next == right                &&
               left->height <= 0                  &&
               !( left->flags & Overshoot_Top   &&
                  x2 - x1 >= ras.precision_half ) )
            goto Exit;

          /* lower stub test */
          if ( right->next == left                 &&
               left->start == y                    &&
               !( left->flags & Overshoot_Bottom &&
                  x2 - x1 >= ras.precision_half  ) )
            goto Exit;

          if ( dropOutControl == 1 )
            pxl = e2;
          else
            pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;

        default: /* modes 2, 3, 6, 7 */
          goto Exit;  /* no drop-out control */
        }

        /* undocumented but confirmed: If the drop-out would result in a  */
        /* pixel outside of the bounding box, use the pixel inside of the */
        /* bounding box instead                                           */
        if ( pxl < 0 )
          pxl = e1;
        else if ( TRUNC( pxl ) >= ras.bWidth )
          pxl = e2;

        /* check that the other pixel isn't set */
        e1 = ( pxl == e1 ) ? e2 : e1;

        e1 = TRUNC( e1 );

        c1 = (Short)( e1 >> 3 );
        f1 = (Short)( e1 &  7 );

        if ( e1 >= 0 && e1 < ras.bWidth                      &&
             ras.bTarget[ras.traceOfs + c1] & ( 0x80 >> f1 ) )
          goto Exit;
      }
      else
        goto Exit;
    }

    e1 = TRUNC( pxl );

    if ( e1 >= 0 && e1 < ras.bWidth )
    {
      FT_TRACE7(( " -> x=%d (drop-out)", e1 ));

      c1 = (Short)( e1 >> 3 );
      f1 = (Short)( e1 & 7 );

      ras.bTarget[ras.traceOfs + c1] |= (char)( 0x80 >> f1 );
    }

  Exit:
    FT_TRACE7(( "\n" ));
  }


  static void
  Vertical_Sweep_Step( RAS_ARG )
  {
    ras.traceOfs += ras.traceIncr;
  }


  /***********************************************************************/
  /*                                                                     */
  /*  Horizontal Sweep Procedure Set                                     */
  /*                                                                     */
  /*  These four routines are used during the horizontal black/white     */
  /*  sweep phase by the generic Draw_Sweep() function.                  */
  /*                                                                     */
  /***********************************************************************/

  static void
  Horizontal_Sweep_Init( RAS_ARGS Short*  min,
                                  Short*  max )
  {
    /* nothing, really */
    FT_UNUSED_RASTER;
    FT_UNUSED( min );
    FT_UNUSED( max );
  }


  static void
  Horizontal_Sweep_Span( RAS_ARGS Short       y,
                                  FT_F26Dot6  x1,
                                  FT_F26Dot6  x2,
                                  PProfile    left,
                                  PProfile    right )
  {
    FT_UNUSED( left );
    FT_UNUSED( right );


    if ( x2 - x1 < ras.precision )
    {
      Long  e1, e2;


      FT_TRACE7(( "  x=%d y=[%.12f;%.12f]",
                  y,
                  x1 / (double)ras.precision,
                  x2 / (double)ras.precision ));

      e1 = CEILING( x1 );
      e2 = FLOOR  ( x2 );

      if ( e1 == e2 )
      {
        e1 = TRUNC( e1 );

        if ( e1 >= 0 && (ULong)e1 < ras.target.rows )
        {
          Byte   f1;
          PByte  bits;
          PByte  p;


          FT_TRACE7(( " -> y=%d (drop-out)", e1 ));

          bits = ras.bTarget + ( y >> 3 );
          f1   = (Byte)( 0x80 >> ( y & 7 ) );
          p    = bits - e1 * ras.target.pitch;

          if ( ras.target.pitch > 0 )
            p += (Long)( ras.target.rows - 1 ) * ras.target.pitch;

          p[0] |= f1;
        }
      }

      FT_TRACE7(( "\n" ));
    }
  }


  static void
  Horizontal_Sweep_Drop( RAS_ARGS Short       y,
                                  FT_F26Dot6  x1,
                                  FT_F26Dot6  x2,
                                  PProfile    left,
                                  PProfile    right )
  {
    Long   e1, e2, pxl;
    PByte  bits;
    Byte   f1;


    FT_TRACE7(( "  x=%d y=[%.12f;%.12f]",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision ));

    /* During the horizontal sweep, we only take care of drop-outs */

    /* e1     +       <-- pixel center */
    /*        |                        */
    /* x1  ---+-->    <-- contour      */
    /*        |                        */
    /*        |                        */
    /* x2  <--+---    <-- contour      */
    /*        |                        */
    /*        |                        */
    /* e2     +       <-- pixel center */

    e1  = CEILING( x1 );
    e2  = FLOOR  ( x2 );
    pxl = e1;

    if ( e1 > e2 )
    {
      Int  dropOutControl = left->flags & 7;


      FT_TRACE7(( ", dropout=%d", dropOutControl ));

      if ( e1 == e2 + ras.precision )
      {
        switch ( dropOutControl )
        {
        case 0: /* simple drop-outs including stubs */
          pxl = e2;
          break;

        case 4: /* smart drop-outs including stubs */
          pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;

        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */
          /* see Vertical_Sweep_Drop for details */

          /* rightmost stub test */
          if ( left->next == right                &&
               left->height <= 0                  &&
               !( left->flags & Overshoot_Top   &&
                  x2 - x1 >= ras.precision_half ) )
            goto Exit;

          /* leftmost stub test */
          if ( right->next == left                 &&
               left->start == y                    &&
               !( left->flags & Overshoot_Bottom &&
                  x2 - x1 >= ras.precision_half  ) )
            goto Exit;

          if ( dropOutControl == 1 )
            pxl = e2;
          else
            pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;

        default: /* modes 2, 3, 6, 7 */
          goto Exit;  /* no drop-out control */
        }

        /* undocumented but confirmed: If the drop-out would result in a  */
        /* pixel outside of the bounding box, use the pixel inside of the */
        /* bounding box instead                                           */
        if ( pxl < 0 )
          pxl = e1;
        else if ( (ULong)( TRUNC( pxl ) ) >= ras.target.rows )
          pxl = e2;

        /* check that the other pixel isn't set */
        e1 = ( pxl == e1 ) ? e2 : e1;

        e1 = TRUNC( e1 );

        bits = ras.bTarget + ( y >> 3 );
        f1   = (Byte)( 0x80 >> ( y & 7 ) );

        bits -= e1 * ras.target.pitch;
        if ( ras.target.pitch > 0 )
          bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;

        if ( e1 >= 0                     &&
             (ULong)e1 < ras.target.rows &&
             *bits & f1                  )
          goto Exit;
      }
      else
        goto Exit;
    }

    e1 = TRUNC( pxl );

    if ( e1 >= 0 && (ULong)e1 < ras.target.rows )
    {
      FT_TRACE7(( " -> y=%d (drop-out)", e1 ));

      bits  = ras.bTarget + ( y >> 3 );
      f1    = (Byte)( 0x80 >> ( y & 7 ) );
      bits -= e1 * ras.target.pitch;

      if ( ras.target.pitch > 0 )
        bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;

      bits[0] |= f1;
    }

  Exit:
    FT_TRACE7(( "\n" ));
  }


  static void
  Horizontal_Sweep_Step( RAS_ARG )
  {
    /* Nothing, really */
    FT_UNUSED_RASTER;
  }


  /*************************************************************************/
  /*                                                                       */
  /*  Generic Sweep Drawing routine                                        */
  /*                                                                       */
  /*************************************************************************/

  static Bool
  Draw_Sweep( RAS_ARG )
  {
    Short         y, y_change, y_height;

    PProfile      P, Q, P_Left, P_Right;

    Short         min_Y, max_Y, top, bottom, dropouts;

    Long          x1, x2, xs, e1, e2;

    TProfileList  waiting;
    TProfileList  draw_left, draw_right;


    /* initialize empty linked lists */

    Init_Linked( &waiting );

    Init_Linked( &draw_left  );
    Init_Linked( &draw_right );

    /* first, compute min and max Y */

    P     = ras.fProfile;
    max_Y = (Short)TRUNC( ras.minY );
    min_Y = (Short)TRUNC( ras.maxY );

    while ( P )
    {
      Q = P->link;

      bottom = (Short)P->start;
      top    = (Short)( P->start + P->height - 1 );

      if ( min_Y > bottom )
        min_Y = bottom;
      if ( max_Y < top )
        max_Y = top;

      P->X = 0;
      InsNew( &waiting, P );

      P = Q;
    }

    /* check the Y-turns */
    if ( ras.numTurns == 0 )
    {
      ras.error = FT_THROW( Invalid );
      return FAILURE;
    }

    /* now initialize the sweep */

    ras.Proc_Sweep_Init( RAS_VARS &min_Y, &max_Y );

    /* then compute the distance of each profile from min_Y */

    P = waiting;

    while ( P )
    {
      P->countL = P->start - min_Y;
      P = P->link;
    }

    /* let's go */

    y        = min_Y;
    y_height = 0;

    if ( ras.numTurns > 0                     &&
         ras.sizeBuff[-ras.numTurns] == min_Y )
      ras.numTurns--;

    while ( ras.numTurns > 0 )
    {
      /* check waiting list for new activations */

      P = waiting;

      while ( P )
      {
        Q = P->link;
        P->countL -= y_height;
        if ( P->countL == 0 )
        {
          DelOld( &waiting, P );

          if ( P->flags & Flow_Up )
            InsNew( &draw_left,  P );
          else
            InsNew( &draw_right, P );
        }

        P = Q;
      }

      /* sort the drawing lists */

      Sort( &draw_left );
      Sort( &draw_right );

      y_change = (Short)ras.sizeBuff[-ras.numTurns--];
      y_height = (Short)( y_change - y );

      while ( y < y_change )
      {
        /* let's trace */

        dropouts = 0;

        P_Left  = draw_left;
        P_Right = draw_right;

        while ( P_Left )
        {
          x1 = P_Left ->X;
          x2 = P_Right->X;

          if ( x1 > x2 )
          {
            xs = x1;
            x1 = x2;
            x2 = xs;
          }

          e1 = FLOOR( x1 );
          e2 = CEILING( x2 );

          if ( x2 - x1 <= ras.precision &&
               e1 != x1 && e2 != x2     )
          {
            if ( e1 > e2 || e2 == e1 + ras.precision )
            {
              Int  dropOutControl = P_Left->flags & 7;


              if ( dropOutControl != 2 )
              {
                /* a drop-out was detected */

                P_Left ->X = x1;
                P_Right->X = x2;

                /* mark profile for drop-out processing */
                P_Left->countL = 1;
                dropouts++;
              }

              goto Skip_To_Next;
            }
          }

          ras.Proc_Sweep_Span( RAS_VARS y, x1, x2, P_Left, P_Right );

        Skip_To_Next:

          P_Left  = P_Left->link;
          P_Right = P_Right->link;
        }

        /* handle drop-outs _after_ the span drawing --       */
        /* drop-out processing has been moved out of the loop */
        /* for performance tuning                             */
        if ( dropouts > 0 )
          goto Scan_DropOuts;

      Next_Line:

        ras.Proc_Sweep_Step( RAS_VAR );

        y++;

        if ( y < y_change )
        {
          Sort( &draw_left  );
          Sort( &draw_right );
        }
      }

      /* now finalize the profiles that need it */

      P = draw_left;
      while ( P )
      {
        Q = P->link;
        if ( P->height == 0 )
          DelOld( &draw_left, P );
        P = Q;
      }

      P = draw_right;
      while ( P )
      {
        Q = P->link;
        if ( P->height == 0 )
          DelOld( &draw_right, P );
        P = Q;
      }
    }

    /* for gray-scaling, flush the bitmap scanline cache */
    while ( y <= max_Y )
    {
      ras.Proc_Sweep_Step( RAS_VAR );
      y++;
    }

    return SUCCESS;

  Scan_DropOuts:

    P_Left  = draw_left;
    P_Right = draw_right;

    while ( P_Left )
    {
      if ( P_Left->countL )
      {
        P_Left->countL = 0;
#if 0
        dropouts--;  /* -- this is useful when debugging only */
#endif
        ras.Proc_Sweep_Drop( RAS_VARS y,
                                      P_Left->X,
                                      P_Right->X,
                                      P_Left,
                                      P_Right );
      }

      P_Left  = P_Left->link;
      P_Right = P_Right->link;
    }

    goto Next_Line;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Render_Single_Pass                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Perform one sweep with sub-banding.                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    flipped :: If set, flip the direction of the outline.              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Renderer error code.                                               */
  /*                                                                       */
  static int
  Render_Single_Pass( RAS_ARGS Bool  flipped )
  {
    Short  i, j, k;


    while ( ras.band_top >= 0 )
    {
      ras.maxY = (Long)ras.band_stack[ras.band_top].y_max * ras.precision;
      ras.minY = (Long)ras.band_stack[ras.band_top].y_min * ras.precision;

      ras.top = ras.buff;

      ras.error = Raster_Err_None;

      if ( Convert_Glyph( RAS_VARS flipped ) )
      {
        if ( ras.error != Raster_Err_Overflow )
          return FAILURE;

        ras.error = Raster_Err_None;

        /* sub-banding */

#ifdef DEBUG_RASTER
        ClearBand( RAS_VARS TRUNC( ras.minY ), TRUNC( ras.maxY ) );
#endif

        i = ras.band_stack[ras.band_top].y_min;
        j = ras.band_stack[ras.band_top].y_max;

        k = (Short)( ( i + j ) / 2 );

        if ( ras.band_top >= 7 || k < i )
        {
          ras.band_top = 0;
          ras.error    = FT_THROW( Invalid );

          return ras.error;
        }

        ras.band_stack[ras.band_top + 1].y_min = k;
        ras.band_stack[ras.band_top + 1].y_max = j;

        ras.band_stack[ras.band_top].y_max = (Short)( k - 1 );

        ras.band_top++;
      }
      else
      {
        if ( ras.fProfile )
          if ( Draw_Sweep( RAS_VAR ) )
             return ras.error;
        ras.band_top--;
      }
    }

    return SUCCESS;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Render_Glyph                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Render a glyph in a bitmap.  Sub-banding if needed.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  static FT_Error
  Render_Glyph( RAS_ARG )
  {
    FT_Error  error;


    Set_High_Precision( RAS_VARS ras.outline.flags &
                                 FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift = ras.precision_shift;

    if ( ras.outline.flags & FT_OUTLINE_IGNORE_DROPOUTS )
      ras.dropOutControl = 2;
    else
    {
      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )
        ras.dropOutControl = 4;
      else
        ras.dropOutControl = 0;

      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )
        ras.dropOutControl += 1;
    }

    ras.second_pass = (Bool)( !( ras.outline.flags      &
                                 FT_OUTLINE_SINGLE_PASS ) );

    /* Vertical Sweep */
    FT_TRACE7(( "Vertical pass (ftraster)\n" ));

    ras.Proc_Sweep_Init = Vertical_Sweep_Init;
    ras.Proc_Sweep_Span = Vertical_Sweep_Span;
    ras.Proc_Sweep_Drop = Vertical_Sweep_Drop;
    ras.Proc_Sweep_Step = Vertical_Sweep_Step;

    ras.band_top            = 0;
    ras.band_stack[0].y_min = 0;
    ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );

    ras.bWidth  = (UShort)ras.target.width;
    ras.bTarget = (Byte*)ras.target.buffer;

    if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )
      return error;

    /* Horizontal Sweep */
    if ( ras.second_pass && ras.dropOutControl != 2 )
    {
      FT_TRACE7(( "Horizontal pass (ftraster)\n" ));

      ras.Proc_Sweep_Init = Horizontal_Sweep_Init;
      ras.Proc_Sweep_Span = Horizontal_Sweep_Span;
      ras.Proc_Sweep_Drop = Horizontal_Sweep_Drop;
      ras.Proc_Sweep_Step = Horizontal_Sweep_Step;

      ras.band_top            = 0;
      ras.band_stack[0].y_min = 0;
      ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );

      if ( ( error = Render_Single_Pass( RAS_VARS 1 ) ) != 0 )
        return error;
    }

    return Raster_Err_None;
  }


  static void
  ft_black_init( black_PRaster  raster )
  {
    FT_UNUSED( raster );
  }


  /**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
  /****                         a static object.                  *****/


#ifdef STANDALONE_


  static int
  ft_black_new( void*       memory,
                FT_Raster  *araster )
  {
     static black_TRaster  the_raster;
     FT_UNUSED( memory );


     *araster = (FT_Raster)&the_raster;
     FT_ZERO( &the_raster );
     ft_black_init( &the_raster );

     return 0;
  }


  static void
  ft_black_done( FT_Raster  raster )
  {
    /* nothing */
    FT_UNUSED( raster );
  }


#else /* !STANDALONE_ */


  static int
  ft_black_new( FT_Memory       memory,
                black_PRaster  *araster )
  {
    FT_Error       error;
    black_PRaster  raster = NULL;


    *araster = 0;
    if ( !FT_NEW( raster ) )
    {
      raster->memory = memory;
      ft_black_init( raster );

      *araster = raster;
    }

    return error;
  }


  static void
  ft_black_done( black_PRaster  raster )
  {
    FT_Memory  memory = (FT_Memory)raster->memory;


    FT_FREE( raster );
  }


#endif /* !STANDALONE_ */


  static void
  ft_black_reset( FT_Raster  raster,
                  PByte      pool_base,
                  ULong      pool_size )
  {
    FT_UNUSED( raster );
    FT_UNUSED( pool_base );
    FT_UNUSED( pool_size );
  }


  static int
  ft_black_set_mode( FT_Raster  raster,
                     ULong      mode,
                     void*      args )
  {
    FT_UNUSED( raster );
    FT_UNUSED( mode );
    FT_UNUSED( args );

    return 0;
  }


  static int
  ft_black_render( FT_Raster                raster,
                   const FT_Raster_Params*  params )
  {
    const FT_Outline*  outline    = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map = params->target;

    black_TWorker  worker[1];

    Long  buffer[FT_MAX_BLACK_POOL];


    if ( !raster )
      return FT_THROW( Not_Ini );

    if ( !outline )
      return FT_THROW( Invalid );

    /* return immediately if the outline is empty */
    if ( outline->n_points == 0 || outline->n_contours <= 0 )
      return Raster_Err_None;

    if ( !outline->contours || !outline->points )
      return FT_THROW( Invalid );

    if ( outline->n_points !=
           outline->contours[outline->n_contours - 1] + 1 )
      return FT_THROW( Invalid );

    /* this version of the raster does not support direct rendering, sorry */
    if ( params->flags & FT_RASTER_FLAG_DIRECT )
      return FT_THROW( Unsupported );

    if ( params->flags & FT_RASTER_FLAG_AA )
      return FT_THROW( Unsupported );

    if ( !target_map )
      return FT_THROW( Invalid );

    /* nothing to do */
    if ( !target_map->width || !target_map->rows )
      return Raster_Err_None;

    if ( !target_map->buffer )
      return FT_THROW( Invalid );

    /* reject too large outline coordinates */
    {
      FT_Vector*  vec   = outline->points;
      FT_Vector*  limit = vec + outline->n_points;


      for ( ; vec < limit; vec++ )
      {
        if ( vec->x < -0x1000000L || vec->x > 0x1000000L ||
             vec->y < -0x1000000L || vec->y > 0x1000000L )
         return FT_THROW( Invalid );
      }
    }

    ras.outline = *outline;
    ras.target  = *target_map;

    worker->buff     = buffer;
    worker->sizeBuff = (&buffer)[1]; /* Points to right after buffer. */

    return Render_Glyph( RAS_VAR );
  }


  FT_DEFINE_RASTER_FUNCS(
    ft_standard_raster,

    FT_GLYPH_FORMAT_OUTLINE,

    (FT_Raster_New_Func)     ft_black_new,       /* raster_new      */
    (FT_Raster_Reset_Func)   ft_black_reset,     /* raster_reset    */
    (FT_Raster_Set_Mode_Func)ft_black_set_mode,  /* raster_set_mode */
    (FT_Raster_Render_Func)  ft_black_render,    /* raster_render   */
    (FT_Raster_Done_Func)    ft_black_done       /* raster_done     */
  )


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008, 2009 by             */
d21 1
a21 1
  /* defining the _STANDALONE_ macro when compiling it.  You also need to  */
d27 2
a28 2
  /* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h'         */
  /*   to your current directory                                           */
d30 1
a30 1
  /* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
d32 1
a32 1
  /*     cc -c -D_STANDALONE_ ftraster.c                                   */
d50 5
a54 1
#ifdef _STANDALONE_
d63 1
a63 1
#else /* !_STANDALONE_ */
d67 1
a67 1
#include FT_INTERNAL_CALC_H   /* for FT_MulDiv only */
d71 1
a71 1
#endif /* !_STANDALONE_ */
a156 8
  /* define FT_RASTER_OPTION_ANTI_ALIASING if you want to support */
  /* 5-levels anti-aliasing                                       */
/* #define FT_RASTER_OPTION_ANTI_ALIASING */

  /* The size of the two-lines intermediate bitmap used */
  /* for anti-aliasing, in bytes.                       */
#define RASTER_GRAY_LINES  2048

d176 1
a176 1
#ifdef _STANDALONE_
d178 3
d189 1
a189 1
  /* activate it easily by redefining these two macros.                  */
d198 5
d227 1
a227 1
#else /* !_STANDALONE_ */
d231 1
a231 1
#include FT_INTERNAL_DEBUG_H        /* for FT_TRACE() and FT_ERROR() */
d235 1
a235 1
#define Raster_Err_None         Raster_Err_Ok
d243 1
a243 1
#endif /* !_STANDALONE_ */
d254 4
d266 2
a267 1
#define SMulDiv  FT_MulDiv
d322 1
a322 1
    long    l;
d338 3
a340 3
#define Flow_Up           0x8
#define Overshoot_Top     0x10
#define Overshoot_Bottom  0x20
d362 1
a362 1
    unsigned    flags;       /* Bit 0-2: drop-out mode                   */
d366 2
a367 2
    long        height;      /* profile's height in scanlines            */
    long        start;       /* profile's starting scanline              */
d369 1
a369 1
    unsigned    countL;      /* number of lines to step before this      */
d382 1
a382 1
  typedef struct  TBand_
d387 1
a387 1
  } TBand;
d391 2
a392 1
  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( long ) )
d394 4
d414 2
a415 2
#define RAS_ARGS       PWorker    worker,
#define RAS_ARG        PWorker    worker
d426 1
a426 1
  typedef struct TWorker_  TWorker, *PWorker;
d446 4
d453 1
a453 1
#define TRUNC( x )    ( (signed long)(x) >> ras.precision_bits )
d455 8
a462 1
#define SCALED( x )   ( ( (x) << ras.scale_shift ) - ras.precision_half )
d464 5
a468 2
#define IS_BOTTOM_OVERSHOOT( x )  ( CEILING( x ) - x >= ras.precision_half )
#define IS_TOP_OVERSHOOT( x )     ( x - FLOOR( x ) >= ras.precision_half )
d474 1
a474 1
  struct  TWorker_
a478 1
    Long        precision_mask;
a525 3
    Short       gray_min_x;         /* current min x during gray rendering */
    Short       gray_max_x;         /* current max x during gray rendering */

d538 1
a538 3
                                    /* Render_Glyph.  Note that there is   */
                                    /* no horizontal pass during gray      */
                                    /* rendering.                          */
d542 2
a543 21
    TBand       band_stack[16];     /* band stack used for sub-banding     */
    Int         band_top;           /* band stack top                      */

#ifdef FT_RASTER_OPTION_ANTI_ALIASING

    Byte*       grays;

    Byte        gray_lines[RASTER_GRAY_LINES];
                                /* Intermediate table used to render the   */
                                /* graylevels pixmaps.                     */
                                /* gray_lines is a buffer holding two      */
                                /* monochrome scanlines                    */

    Short       gray_width;     /* width in bytes of one monochrome        */
                                /* intermediate scanline of gray_lines.    */
                                /* Each gray pixel takes 2 bits long there */

                       /* The gray_lines must hold 2 lines, thus with size */
                       /* in bytes of at least `gray_width*2'.             */

#endif /* FT_RASTER_ANTI_ALIASING */
d548 1
a548 1
  typedef struct  TRaster_
d550 1
a550 6
    char*    buffer;
    long     buffer_size;
    void*    memory;
    PWorker  worker;
    Byte     grays[5];
    Short    gray_width;
d552 1
a552 1
  } TRaster, *PRaster;
d556 1
a556 1
  static TWorker  cur_ras;
a565 64
#ifdef FT_RASTER_OPTION_ANTI_ALIASING

  /* A lookup table used to quickly count set bits in four gray 2x2 */
  /* cells.  The values of the table have been produced with the    */
  /* following code:                                                */
  /*                                                                */
  /*   for ( i = 0; i < 256; i++ )                                  */
  /*   {                                                            */
  /*     l = 0;                                                     */
  /*     j = i;                                                     */
  /*                                                                */
  /*     for ( c = 0; c < 4; c++ )                                  */
  /*     {                                                          */
  /*       l <<= 4;                                                 */
  /*                                                                */
  /*       if ( j & 0x80 ) l++;                                     */
  /*       if ( j & 0x40 ) l++;                                     */
  /*                                                                */
  /*       j = ( j << 2 ) & 0xFF;                                   */
  /*     }                                                          */
  /*     printf( "0x%04X", l );                                     */
  /*   }                                                            */
  /*                                                                */

  static const short  count_table[256] =
  {
    0x0000, 0x0001, 0x0001, 0x0002, 0x0010, 0x0011, 0x0011, 0x0012,
    0x0010, 0x0011, 0x0011, 0x0012, 0x0020, 0x0021, 0x0021, 0x0022,
    0x0100, 0x0101, 0x0101, 0x0102, 0x0110, 0x0111, 0x0111, 0x0112,
    0x0110, 0x0111, 0x0111, 0x0112, 0x0120, 0x0121, 0x0121, 0x0122,
    0x0100, 0x0101, 0x0101, 0x0102, 0x0110, 0x0111, 0x0111, 0x0112,
    0x0110, 0x0111, 0x0111, 0x0112, 0x0120, 0x0121, 0x0121, 0x0122,
    0x0200, 0x0201, 0x0201, 0x0202, 0x0210, 0x0211, 0x0211, 0x0212,
    0x0210, 0x0211, 0x0211, 0x0212, 0x0220, 0x0221, 0x0221, 0x0222,
    0x1000, 0x1001, 0x1001, 0x1002, 0x1010, 0x1011, 0x1011, 0x1012,
    0x1010, 0x1011, 0x1011, 0x1012, 0x1020, 0x1021, 0x1021, 0x1022,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1200, 0x1201, 0x1201, 0x1202, 0x1210, 0x1211, 0x1211, 0x1212,
    0x1210, 0x1211, 0x1211, 0x1212, 0x1220, 0x1221, 0x1221, 0x1222,
    0x1000, 0x1001, 0x1001, 0x1002, 0x1010, 0x1011, 0x1011, 0x1012,
    0x1010, 0x1011, 0x1011, 0x1012, 0x1020, 0x1021, 0x1021, 0x1022,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1200, 0x1201, 0x1201, 0x1202, 0x1210, 0x1211, 0x1211, 0x1212,
    0x1210, 0x1211, 0x1211, 0x1212, 0x1220, 0x1221, 0x1221, 0x1222,
    0x2000, 0x2001, 0x2001, 0x2002, 0x2010, 0x2011, 0x2011, 0x2012,
    0x2010, 0x2011, 0x2011, 0x2012, 0x2020, 0x2021, 0x2021, 0x2022,
    0x2100, 0x2101, 0x2101, 0x2102, 0x2110, 0x2111, 0x2111, 0x2112,
    0x2110, 0x2111, 0x2111, 0x2112, 0x2120, 0x2121, 0x2121, 0x2122,
    0x2100, 0x2101, 0x2101, 0x2102, 0x2110, 0x2111, 0x2111, 0x2112,
    0x2110, 0x2111, 0x2111, 0x2112, 0x2120, 0x2121, 0x2121, 0x2122,
    0x2200, 0x2201, 0x2201, 0x2202, 0x2210, 0x2211, 0x2211, 0x2212,
    0x2210, 0x2211, 0x2211, 0x2212, 0x2220, 0x2221, 0x2221, 0x2222
  };

#endif /* FT_RASTER_OPTION_ANTI_ALIASING */



d584 1
a584 1
  /*    High :: Set to True for high precision (typically for ppem < 18),  */
d590 22
d616 1
a616 1
      ras.precision_jitter = 50;
a629 1
    ras.precision_mask  = -ras.precision;
d664 1
a664 1
      ras.error = Raster_Err_Overflow;
d683 1
a683 1
      FT_TRACE6(( "New ascending profile = %lx\n", (long)ras.cProfile ));
d689 1
a689 1
      FT_TRACE6(( "New descending profile = %lx\n", (long)ras.cProfile ));
d694 1
a694 1
      ras.error = Raster_Err_Invalid;
d727 1
a727 2
    Long      h;
    PProfile  oldProfile;
d735 1
a735 1
      ras.error = Raster_Err_Neg_Height;
d741 5
a745 2
      FT_TRACE6(( "Ending profile %lx, start = %ld, height = %ld\n",
                  (long)ras.cProfile, ras.cProfile->start, h ));
d771 1
a771 1
      ras.error = Raster_Err_Overflow;
d800 1
a800 1
    Int    y2, n;
d812 1
a812 1
      while ( n >= 0 )
d814 3
a816 1
        y2 = (Int)y_turns[n];
d819 1
a819 2
        n--;
      }
d826 1
a826 1
        ras.error = Raster_Err_Overflow;
a850 1
    Int       bottom, top;
d860 1
a860 1
      while ( n > 0 )
d862 3
d888 1
a888 2
        n--;
      }
d1056 1
a1056 1
        x1 += FMulDiv( Dx, ras.precision - f1, Dy );
d1078 1
a1078 1
      ras.error = Raster_Err_Overflow;
d1084 1
a1084 1
      Ix = ( ras.precision * Dx ) / Dy;
d1090 2
a1091 2
      Ix = -( ( ras.precision * -Dx ) / Dy );
      Rx =    ( ras.precision * -Dx ) % Dy;
d1253 1
a1253 1
      ras.error = Raster_Err_Overflow;
d1259 1
a1259 1
    while ( arc >= start_arc && e <= e2 )
d1292 1
a1292 1
    }
d1523 3
a1525 2
          Bool  o = state_bez == Ascending_State ? IS_BOTTOM_OVERSHOOT( y1 )
                                                 : IS_TOP_OVERSHOOT( y1 );
d1660 3
a1662 2
          Bool  o = state_bez == Ascending_State ? IS_BOTTOM_OVERSHOOT( y1 )
                                                 : IS_TOP_OVERSHOOT( y1 );
d1732 1
a1732 1
                            int     flipped )
d1743 1
a1743 1
    unsigned    tag;       /* current point's state           */
d1793 1
a1793 1
        v_last = v_start;
a1894 2
          x3 = SCALED( point[ 0].x );
          y3 = SCALED( point[ 0].y );
a1899 1
            SWAP_( x3, y3 );
d1904 6
d1930 1
a1930 1
    ras.error = Raster_Err_Invalid;
d1954 1
a1954 1
  Convert_Glyph( RAS_ARGS int  flipped )
d1956 2
a1957 4
    int       i;
    unsigned  start;

    PProfile  lastProfile;
d1976 2
a1977 1
      Bool  o;
d1983 2
a1984 2
      if ( Decompose_Curve( RAS_VARS (unsigned short)start,
                                     ras.outline.contours[i],
d1988 1
a1988 1
      start = ras.outline.contours[i] + 1;
d2002 2
a2003 1
      if ( ras.cProfile->flags & Flow_Up )
d2127 1
a2127 1
      current->offset += current->flags & Flow_Up ? 1 : -1;
d2187 1
a2187 4
      ras.traceOfs += ( ras.target.rows - 1 ) * pitch;

    ras.gray_min_x = 0;
    ras.gray_max_x = 0;
a2198 2
    int    c1, c2;
    Byte   f1, f2;
d2201 2
d2208 8
d2220 2
a2221 1
    if ( x2 - x1 - ras.precision <= ras.precision_jitter )
d2228 4
d2237 2
a2244 5
      if ( ras.gray_min_x > c1 )
        ras.gray_min_x = (short)c1;
      if ( ras.gray_max_x < c2 )
        ras.gray_max_x = (short)c2;

d2266 2
d2282 5
d2319 2
d2367 1
a2367 1
            return;
d2374 1
a2374 1
            return;
d2383 1
a2383 1
          return;  /* no drop-out control */
d2386 8
d2395 1
a2395 1
        e1 = pxl == e1 ? e2 : e1;
d2404 1
a2404 1
          return;
d2407 1
a2407 1
        return;
d2414 2
a2418 5
      if ( ras.gray_min_x > c1 )
        ras.gray_min_x = c1;
      if ( ras.gray_max_x < c1 )
        ras.gray_max_x = c1;

d2421 3
a2460 4
    Long   e1, e2;
    PByte  bits;
    Byte   f1;

d2467 8
a2479 3
        bits = ras.bTarget + ( y >> 3 );
        f1   = (Byte)( 0x80 >> ( y & 7 ) );

d2482 1
a2482 1
        if ( e1 >= 0 && e1 < ras.target.rows )
d2484 2
d2489 6
a2494 1
          p = bits - e1*ras.target.pitch;
d2496 1
a2496 1
            p += ( ras.target.rows - 1 ) * ras.target.pitch;
d2501 2
d2519 5
d2545 2
d2568 1
a2568 1
            return;
d2575 1
a2575 1
            return;
d2584 1
a2584 1
          return;  /* no drop-out control */
d2587 8
d2596 1
a2596 1
        e1 = pxl == e1 ? e2 : e1;
d2605 1
a2605 1
          bits += ( ras.target.rows - 1 ) * ras.target.pitch;
d2607 4
a2610 4
        if ( e1 >= 0              &&
             e1 < ras.target.rows &&
             *bits & f1           )
          return;
d2613 1
a2613 1
        return;
a2615 3
    bits = ras.bTarget + ( y >> 3 );
    f1   = (Byte)( 0x80 >> ( y & 7 ) );

d2618 1
a2618 1
    if ( e1 >= 0 && e1 < ras.target.rows )
d2620 4
d2625 1
d2627 1
a2627 1
        bits += ( ras.target.rows - 1 ) * ras.target.pitch;
d2631 3
a2644 237
#ifdef FT_RASTER_OPTION_ANTI_ALIASING


  /*************************************************************************/
  /*                                                                       */
  /*  Vertical Gray Sweep Procedure Set                                    */
  /*                                                                       */
  /*  These two routines are used during the vertical gray-levels sweep    */
  /*  phase by the generic Draw_Sweep() function.                          */
  /*                                                                       */
  /*  NOTES                                                                */
  /*                                                                       */
  /*  - The target pixmap's width *must* be a multiple of 4.               */
  /*                                                                       */
  /*  - You have to use the function Vertical_Sweep_Span() for the gray    */
  /*    span call.                                                         */
  /*                                                                       */
  /*************************************************************************/

  static void
  Vertical_Gray_Sweep_Init( RAS_ARGS Short*  min,
                                     Short*  max )
  {
    Long  pitch, byte_len;


    *min = *min & -2;
    *max = ( *max + 3 ) & -2;

    ras.traceOfs  = 0;
    pitch         = ras.target.pitch;
    byte_len      = -pitch;
    ras.traceIncr = (Short)byte_len;
    ras.traceG    = ( *min / 2 ) * byte_len;

    if ( pitch > 0 )
    {
      ras.traceG += ( ras.target.rows - 1 ) * pitch;
      byte_len    = -byte_len;
    }

    ras.gray_min_x =  (Short)byte_len;
    ras.gray_max_x = -(Short)byte_len;
  }


  static void
  Vertical_Gray_Sweep_Step( RAS_ARG )
  {
    Int     c1, c2;
    PByte   pix, bit, bit2;
    short*  count = (short*)count_table;
    Byte*   grays;


    ras.traceOfs += ras.gray_width;

    if ( ras.traceOfs > ras.gray_width )
    {
      pix   = ras.gTarget + ras.traceG + ras.gray_min_x * 4;
      grays = ras.grays;

      if ( ras.gray_max_x >= 0 )
      {
        Long  last_pixel = ras.target.width - 1;
        Int   last_cell  = last_pixel >> 2;
        Int   last_bit   = last_pixel & 3;
        Bool  over       = 0;


        if ( ras.gray_max_x >= last_cell && last_bit != 3 )
        {
          ras.gray_max_x = last_cell - 1;
          over = 1;
        }

        if ( ras.gray_min_x < 0 )
          ras.gray_min_x = 0;

        bit  = ras.bTarget + ras.gray_min_x;
        bit2 = bit + ras.gray_width;

        c1 = ras.gray_max_x - ras.gray_min_x;

        while ( c1 >= 0 )
        {
          c2 = count[*bit] + count[*bit2];

          if ( c2 )
          {
            pix[0] = grays[(c2 >> 12) & 0x000F];
            pix[1] = grays[(c2 >> 8 ) & 0x000F];
            pix[2] = grays[(c2 >> 4 ) & 0x000F];
            pix[3] = grays[ c2        & 0x000F];

            *bit  = 0;
            *bit2 = 0;
          }

          bit++;
          bit2++;
          pix += 4;
          c1--;
        }

        if ( over )
        {
          c2 = count[*bit] + count[*bit2];
          if ( c2 )
          {
            switch ( last_bit )
            {
            case 2:
              pix[2] = grays[(c2 >> 4 ) & 0x000F];
            case 1:
              pix[1] = grays[(c2 >> 8 ) & 0x000F];
            default:
              pix[0] = grays[(c2 >> 12) & 0x000F];
            }

            *bit  = 0;
            *bit2 = 0;
          }
        }
      }

      ras.traceOfs = 0;
      ras.traceG  += ras.traceIncr;

      ras.gray_min_x =  32000;
      ras.gray_max_x = -32000;
    }
  }


  static void
  Horizontal_Gray_Sweep_Span( RAS_ARGS Short       y,
                                       FT_F26Dot6  x1,
                                       FT_F26Dot6  x2,
                                       PProfile    left,
                                       PProfile    right )
  {
    /* nothing, really */
    FT_UNUSED_RASTER;
    FT_UNUSED( y );
    FT_UNUSED( x1 );
    FT_UNUSED( x2 );
    FT_UNUSED( left );
    FT_UNUSED( right );
  }


  static void
  Horizontal_Gray_Sweep_Drop( RAS_ARGS Short       y,
                                       FT_F26Dot6  x1,
                                       FT_F26Dot6  x2,
                                       PProfile    left,
                                       PProfile    right )
  {
    Long   e1, e2;
    PByte  pixel;
    Byte   color;


    /* During the horizontal sweep, we only take care of drop-outs */

    e1 = CEILING( x1 );
    e2 = FLOOR  ( x2 );

    if ( e1 > e2 )
    {
      Int  dropOutControl = left->flags & 7;


      if ( e1 == e2 + ras.precision )
      {
        switch ( dropOutControl )
        {
        case 0: /* simple drop-outs including stubs */
          e1 = e2;
          break;

        case 4: /* smart drop-outs including stubs */
          e1 = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;

        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */
          /* see Vertical_Sweep_Drop for details */

          /* rightmost stub test */
          if ( left->next == right && left->height <= 0 )
            return;

          /* leftmost stub test */
          if ( right->next == left && left->start == y )
            return;

          if ( dropOutControl == 1 )
            e1 = e2;
          else
            e1 = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );

          break;

        default: /* modes 2, 3, 6, 7 */
          return;  /* no drop-out control */
        }
      }
      else
        return;
    }

    if ( e1 >= 0 )
    {
      if ( x2 - x1 >= ras.precision_half )
        color = ras.grays[2];
      else
        color = ras.grays[1];

      e1 = TRUNC( e1 ) / 2;
      if ( e1 < ras.target.rows )
      {
        pixel = ras.gTarget - e1 * ras.target.pitch + y / 2;
        if ( ras.target.pitch > 0 )
          pixel += ( ras.target.rows - 1 ) * ras.target.pitch;

        if ( pixel[0] == ras.grays[0] )
          pixel[0] = color;
      }
    }
  }


#endif /* FT_RASTER_OPTION_ANTI_ALIASING */


d2700 1
a2700 1
      ras.error = Raster_Err_Invalid;
d2714 1
a2714 1
      P->countL = (UShort)( P->start - min_Y );
d2941 1
a2941 1
          ras.error    = Raster_Err_Invalid;
d2977 1
a2977 1
  FT_LOCAL_DEF( FT_Error )
d3000 2
a3001 2
    ras.second_pass = (FT_Byte)( !( ras.outline.flags &
                                    FT_OUTLINE_SINGLE_PASS ) );
d3004 2
d3013 1
a3013 1
    ras.band_stack[0].y_max = (short)( ras.target.rows - 1 );
d3015 1
a3015 1
    ras.bWidth  = (unsigned short)ras.target.width;
d3024 2
d3033 1
a3033 1
      ras.band_stack[0].y_max = (short)( ras.target.width - 1 );
a3042 97
#ifdef FT_RASTER_OPTION_ANTI_ALIASING

  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Render_Gray_Glyph                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Render a glyph with grayscaling.  Sub-banding if needed.           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  Render_Gray_Glyph( RAS_ARG )
  {
    Long      pixel_width;
    FT_Error  error;


    Set_High_Precision( RAS_VARS ras.outline.flags &
                                 FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift = ras.precision_shift + 1;

    if ( ras.outline.flags & FT_OUTLINE_IGNORE_DROPOUTS )
      ras.dropOutControl = 2;
    else
    {
      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )
        ras.dropOutControl = 4;
      else
        ras.dropOutControl = 0;

      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )
        ras.dropOutControl += 1;
    }

    ras.second_pass = !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS );

    /* Vertical Sweep */

    ras.band_top            = 0;
    ras.band_stack[0].y_min = 0;
    ras.band_stack[0].y_max = 2 * ras.target.rows - 1;

    ras.bWidth  = ras.gray_width;
    pixel_width = 2 * ( ( ras.target.width + 3 ) >> 2 );

    if ( ras.bWidth > pixel_width )
      ras.bWidth = pixel_width;

    ras.bWidth  = ras.bWidth * 8;
    ras.bTarget = (Byte*)ras.gray_lines;
    ras.gTarget = (Byte*)ras.target.buffer;

    ras.Proc_Sweep_Init = Vertical_Gray_Sweep_Init;
    ras.Proc_Sweep_Span = Vertical_Sweep_Span;
    ras.Proc_Sweep_Drop = Vertical_Sweep_Drop;
    ras.Proc_Sweep_Step = Vertical_Gray_Sweep_Step;

    error = Render_Single_Pass( RAS_VARS 0 );
    if ( error )
      return error;

    /* Horizontal Sweep */
    if ( ras.second_pass && ras.dropOutControl != 2 )
    {
      ras.Proc_Sweep_Init = Horizontal_Sweep_Init;
      ras.Proc_Sweep_Span = Horizontal_Gray_Sweep_Span;
      ras.Proc_Sweep_Drop = Horizontal_Gray_Sweep_Drop;
      ras.Proc_Sweep_Step = Horizontal_Sweep_Step;

      ras.band_top            = 0;
      ras.band_stack[0].y_min = 0;
      ras.band_stack[0].y_max = ras.target.width * 2 - 1;

      error = Render_Single_Pass( RAS_VARS 1 );
      if ( error )
        return error;
    }

    return Raster_Err_None;
  }

#else /* !FT_RASTER_OPTION_ANTI_ALIASING */

  FT_LOCAL_DEF( FT_Error )
  Render_Gray_Glyph( RAS_ARG )
  {
    FT_UNUSED_RASTER;

    return Raster_Err_Unsupported;
  }

#endif /* !FT_RASTER_OPTION_ANTI_ALIASING */


d3044 1
a3044 1
  ft_black_init( PRaster  raster )
a3045 10
#ifdef FT_RASTER_OPTION_ANTI_ALIASING
    FT_UInt  n;


    /* set default 5-levels gray palette */
    for ( n = 0; n < 5; n++ )
      raster->grays[n] = n * 255 / 4;

    raster->gray_width = RASTER_GRAY_LINES / 2;
#else
a3046 1
#endif
d3054 1
a3054 1
#ifdef _STANDALONE_
d3061 2
a3062 1
     static TRaster  the_raster;
d3066 1
a3066 1
     FT_MEM_ZERO( &the_raster, sizeof ( the_raster ) );
d3081 1
a3081 1
#else /* _STANDALONE_ */
d3085 2
a3086 2
  ft_black_new( FT_Memory   memory,
                PRaster    *araster )
d3088 2
a3089 2
    FT_Error  error;
    PRaster   raster;
d3106 1
a3106 1
  ft_black_done( PRaster  raster )
d3109 2
d3115 1
a3115 1
#endif /* _STANDALONE_ */
d3119 3
a3121 3
  ft_black_reset( PRaster  raster,
                  char*    pool_base,
                  long     pool_size )
d3123 3
a3125 19
    if ( raster )
    {
      if ( pool_base && pool_size >= (long)sizeof(TWorker) + 2048 )
      {
        PWorker  worker = (PWorker)pool_base;


        raster->buffer      = pool_base + ( (sizeof ( *worker ) + 7 ) & ~7 );
        raster->buffer_size = ( ( pool_base + pool_size ) -
                                (char*)raster->buffer ) / sizeof ( Long );
        raster->worker      = worker;
      }
      else
      {
        raster->buffer      = NULL;
        raster->buffer_size = 0;
        raster->worker      = NULL;
      }
    }
d3129 5
a3133 19
  static void
  ft_black_set_mode( PRaster        raster,
                     unsigned long  mode,
                     const char*    palette )
  {
#ifdef FT_RASTER_OPTION_ANTI_ALIASING

    if ( mode == FT_MAKE_TAG( 'p', 'a', 'l', '5' ) )
    {
      /* set 5-levels gray palette */
      raster->grays[0] = palette[0];
      raster->grays[1] = palette[1];
      raster->grays[2] = palette[2];
      raster->grays[3] = palette[3];
      raster->grays[4] = palette[4];
    }

#else

d3136 1
a3136 1
    FT_UNUSED( palette );
d3138 1
a3138 1
#endif
d3143 1
a3143 1
  ft_black_render( PRaster                  raster,
a3147 1
    PWorker            worker;
d3149 3
d3153 3
a3155 2
    if ( !raster || !raster->buffer || !raster->buffer_size )
      return Raster_Err_Not_Ini;
d3158 1
a3158 1
      return Raster_Err_Invalid;
d3165 1
a3165 1
      return Raster_Err_Invalid;
d3169 1
a3169 3
      return Raster_Err_Invalid;

    worker = raster->worker;
d3173 4
a3176 1
      return Raster_Err_Unsupported;
d3179 1
a3179 1
      return Raster_Err_Invalid;
d3186 15
a3200 1
      return Raster_Err_Invalid;
d3205 2
a3206 6
    worker->buff       = (PLong) raster->buffer;
    worker->sizeBuff   = worker->buff +
                           raster->buffer_size / sizeof ( Long );
#ifdef FT_RASTER_OPTION_ANTI_ALIASING
    worker->grays      = raster->grays;
    worker->gray_width = raster->gray_width;
d3208 2
a3209 2
    FT_MEM_ZERO( worker->gray_lines, worker->gray_width * 2 );
#endif
a3210 4
    return ( params->flags & FT_RASTER_FLAG_AA )
           ? Render_Gray_Glyph( RAS_VAR )
           : Render_Glyph( RAS_VAR );
  }
d3212 2
a3214 1
  FT_DEFINE_RASTER_FUNCS( ft_standard_raster,
d3216 6
a3221 5
    (FT_Raster_New_Func)     ft_black_new,
    (FT_Raster_Reset_Func)   ft_black_reset,
    (FT_Raster_Set_Mode_Func)ft_black_set_mode,
    (FT_Raster_Render_Func)  ft_black_render,
    (FT_Raster_Done_Func)    ft_black_done
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008 by                   */
d52 4
d65 2
d81 1
a81 1
  /*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'.     */
d84 1
a84 1
  /*         between `Ymin' and `Ymax'.                                    */
d87 3
a89 1
  /*         `down', as this is very important for filling rules.          */
d99 9
a107 9
  /*     ____________________________________________________________ _ _  */
  /*    |         |                   |         |                 |        */
  /*    | profile | coordinates for   | profile | coordinates for |-->     */
  /*    |    1    |  profile 1        |    2    |  profile 2      |-->     */
  /*    |_________|___________________|_________|_________________|__ _ _  */
  /*                                                                       */
  /*    ^                                                         ^        */
  /*    |                                                         |        */
  /*  start of render pool                                       top       */
d151 1
a151 1
#define xxxDEBUG_RASTER
d153 3
a155 3
  /* undefine FT_RASTER_OPTION_ANTI_ALIASING if you do not want to support */
  /* 5-levels anti-aliasing                                                */
#undef FT_RASTER_OPTION_ANTI_ALIASING
d192 1
a192 1
#define FT_ERROR( x )  do ; while ( 0 )     /* nothing */
d196 3
a198 3
#define FT_TRACE( x )   do ; while ( 0 )    /* nothing */
#define FT_TRACE1( x )  do ; while ( 0 )    /* nothing */
#define FT_TRACE6( x )  do ; while ( 0 )    /* nothing */
d208 14
a221 1
#define ft_memset   memset
d223 1
a223 1
#else /* _STANDALONE_ */
d239 1
a239 1
#endif /* _STANDALONE_ */
d328 4
a331 7
  typedef enum  TFlow_
  {
    Flow_None = 0,
    Flow_Up   = 1,
    Flow_Down = -1

  } TFlow;
d350 9
a358 6
    FT_F26Dot6  X;           /* current coordinate during sweep        */
    PProfile    link;        /* link to next profile - various purpose */
    PLong       offset;      /* start of profile's data in render pool */
    int         flow;        /* Profile orientation: Asc/Descending    */
    long        height;      /* profile's height in scanlines          */
    long        start;       /* profile's starting scanline            */
d360 2
a361 2
    unsigned    countL;      /* number of lines to step before this    */
                             /* profile becomes drawable               */
d363 2
a364 2
    PProfile    next;        /* next profile in same contour, used     */
                             /* during drop-out control                */
d394 1
a394 1
#define FT_UNUSED_RASTER  do ; while ( 0 )
d397 1
a397 1
#else /* FT_STATIC_RASTER */
d409 1
a409 1
#endif /* FT_STATIC_RASTER */
d412 1
a412 1
  typedef struct TWorker_   TWorker, *PWorker;
d439 6
a444 4
  /* Note that I have moved the location of some fields in the */
  /* structure to ensure that the most used variables are used */
  /* at the top.  Thus, their offset can be coded with less    */
  /* opcodes, and it results in a smaller executable.          */
d448 7
a454 7
    Int       precision_bits;       /* precision related variables         */
    Int       precision;
    Int       precision_half;
    Long      precision_mask;
    Int       precision_shift;
    Int       precision_step;
    Int       precision_jitter;
d456 1
a456 1
    Int       scale_shift;          /* == precision_shift   for bitmaps    */
d459 4
a462 4
    PLong     buff;                 /* The profiles buffer                 */
    PLong     sizeBuff;             /* Render pool size                    */
    PLong     maxBuff;              /* Profiles buffer size                */
    PLong     top;                  /* Current cursor in buffer            */
d464 1
a464 1
    FT_Error  error;
d466 1
a466 1
    Int       numTurns;             /* number of Y-turns in outline        */
d468 1
a468 1
    TPoint*   arc;                  /* current Bezier arc pointer          */
d470 3
a472 3
    UShort    bWidth;               /* target bitmap width                 */
    PByte     bTarget;              /* target bitmap buffer                */
    PByte     gTarget;              /* target pixmap buffer                */
d474 2
a475 1
    Long      lastX, lastY, minY, maxY;
d477 1
a477 1
    UShort    num_Profs;            /* current number of profiles          */
d479 3
a481 3
    Bool      fresh;                /* signals a fresh new profile which   */
                                    /* 'start' field must be completed     */
    Bool      joint;                /* signals that the last arc ended     */
d484 3
a486 3
    PProfile  cProfile;             /* current profile                     */
    PProfile  fProfile;             /* head of linked list of profiles     */
    PProfile  gProfile;             /* contour's first profile in case     */
d489 1
a489 1
    TStates   state;                /* rendering state                     */
d494 2
a495 2
    Long      traceOfs;             /* current offset in target bitmap     */
    Long      traceG;               /* current offset in target pixmap     */
d497 1
a497 1
    Short     traceIncr;            /* sweep's increment in target bitmap  */
d499 2
a500 2
    Short     gray_min_x;           /* current min x during gray rendering */
    Short     gray_max_x;           /* current max x during gray rendering */
d509 1
a509 1
    Byte      dropOutControl;       /* current drop_out control method     */
d511 1
a511 1
    Bool      second_pass;          /* indicates whether a horizontal pass */
d518 1
a518 1
    TPoint    arcs[3 * MaxBezier + 1]; /* The Bezier stack                 */
d520 2
a521 2
    TBand     band_stack[16];       /* band stack used for sub-banding     */
    Int       band_top;             /* band stack top                      */
d525 1
a525 1
    Byte*     grays;
d527 1
a527 1
    Byte      gray_lines[RASTER_GRAY_LINES];
d533 1
a533 1
    Short     gray_width;       /* width in bytes of one monochrome        */
d545 1
a545 1
  typedef struct TRaster_
d547 6
a552 6
    char*     buffer;
    long      buffer_size;
    void*     memory;
    PWorker   worker;
    Byte      grays[5];
    Short     gray_width;
d558 1
a558 1
  static TWorker   cur_ras;
d561 1
a561 1
#else
d565 1
a565 1
#endif /* FT_STATIC_RASTER */
d570 57
a626 18
static const char  count_table[256] =
{
  0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  4 , 5 , 5 , 6 , 5 , 6 , 6 , 7 , 5 , 6 , 6 , 7 , 6 , 7 , 7 , 8 };
d647 1
a647 1
  /*    Sets precision variables according to param flag.                  */
d658 3
a660 3
      ras.precision_bits   = 10;
      ras.precision_step   = 128;
      ras.precision_jitter = 24;
d684 1
a684 1
  /*    Creates a new profile in the render pool.                          */
d687 4
a690 1
  /*    aState :: The state/orientation of the new profile.                */
d697 2
a698 1
  New_Profile( RAS_ARGS TStates  aState )
d713 8
d724 4
a727 1
      ras.cProfile->flow = Flow_Up;
d732 2
a733 1
      ras.cProfile->flow = Flow_Down;
d738 1
a738 1
      FT_ERROR(( "New_Profile: invalid profile direction!\n" ));
a742 6
    ras.cProfile->start  = 0;
    ras.cProfile->height = 0;
    ras.cProfile->offset = ras.top;
    ras.cProfile->link   = (PProfile)0;
    ras.cProfile->next   = (PProfile)0;

d760 5
a764 1
  /*    Finalizes the current profile.                                     */
d770 1
a770 1
  End_Profile( RAS_ARG )
d780 1
a780 1
      FT_ERROR(( "End_Profile: negative height encountered!\n" ));
a789 1
      oldProfile           = ras.cProfile;
d791 7
a797 1
      ras.cProfile         = (PProfile)ras.top;
d799 4
a802 1
      ras.top             += AlignProfileSize;
d806 2
a807 1
      oldProfile->next     = ras.cProfile;
d830 1
a830 1
  /*    Inserts a salient into the sorted list placed on top of the render */
d885 1
a885 1
  /*    Adjusts all links in the profiles list.                            */
d899 1
d901 1
a901 1
    if ( n > 1 )
a902 1
      p = ras.fProfile;
d910 6
a915 1
        switch ( p->flow )
a916 1
        case Flow_Down:
a920 6
          break;

        case Flow_Up:
        default:
          bottom = (Int)p->start;
          top    = (Int)( p->start + p->height - 1 );
d923 2
a924 2
        if ( Insert_Y_Turn( RAS_VARS bottom )   ||
             Insert_Y_Turn( RAS_VARS top + 1 )  )
d944 1
a944 1
  /*    Subdivides one conic Bezier into two joint sub-arcs in the Bezier  */
d983 1
a983 1
  /*    Subdivides a third-order Bezier arc into two joint sub-arcs in the */
d1025 1
a1025 1
  /*    Computes the x-coordinates of an ascending line segment and stores */
d1164 2
a1165 2
  /*    Computes the x-coordinates of an descending line segment and       */
  /*    stores them in the render pool.                                    */
d1215 1
a1215 1
  /*    Computes the x-coordinates of an ascending Bezier arc and stores   */
d1316 1
a1316 1
          *top++ = arc[degree].x + FMulDiv( arc[0].x-arc[degree].x,
d1348 1
a1348 1
  /*    Computes the x-coordinates of an descending Bezier arc and stores  */
d1397 1
a1397 1
  /*    Injects a new line segment and adjusts Profiles list.              */
d1421 2
a1422 1
        if ( New_Profile( RAS_VARS Ascending_State ) )
d1428 2
a1429 1
          if ( New_Profile( RAS_VARS Descending_State ) )
d1437 3
a1439 2
        if ( End_Profile( RAS_VAR )                   ||
             New_Profile( RAS_VARS Descending_State ) )
d1447 3
a1449 2
        if ( End_Profile( RAS_VAR )                  ||
             New_Profile( RAS_VARS Ascending_State ) )
d1464 1
a1464 1
                    x, y, ras.minY, ras.maxY ) )
d1470 1
a1470 1
                      x, y, ras.minY, ras.maxY ) )
d1491 1
a1491 1
  /*    Injects a new conic arc and adjusts the profile list.              */
d1521 4
a1524 2
    ras.arc[1].x = cx; ras.arc[1].y = cy;
    ras.arc[0].x = x;  ras.arc[0].y = y;
d1564 4
d1569 2
a1570 2
          if ( ras.state != Unknown_State   &&
               End_Profile( RAS_VAR ) )
d1574 1
a1574 1
          if ( New_Profile( RAS_VARS state_bez ) )
d1607 1
a1607 1
  /*    Injects a new cubic arc and adjusts the profile list.              */
d1643 6
a1648 3
    ras.arc[2].x = cx1; ras.arc[2].y = cy1;
    ras.arc[1].x = cx2; ras.arc[1].y = cy2;
    ras.arc[0].x = x;   ras.arc[0].y = y;
d1700 7
a1706 2
          if ( ras.state != Unknown_State   &&
               End_Profile( RAS_VAR ) )
d1709 1
a1709 1
          if ( New_Profile( RAS_VARS state_bez ) )
d1753 1
a1753 1
  /*    Scans the outline arrays in order to emit individual segments and  */
d1802 7
a1808 2
    tags  = ras.outline.tags  + first;
    tag   = FT_CURVE_TAG( tags[0] );
d1979 1
a1979 1
  /*    Converts a glyph into a series of segments and arcs and makes a    */
d2014 3
d2021 2
a2022 2
                            ras.outline.contours[i],
                            flipped ) )
d2027 1
a2027 1
      /* We must now see whether the extreme arcs join or not */
d2031 3
a2033 1
        if ( ras.gProfile && ras.gProfile->flow == ras.cProfile->flow )
d2039 5
a2043 1
      if ( End_Profile( RAS_VAR ) )
d2163 1
a2163 1
      current->offset += current->flow;
d2269 4
a2272 2
      if ( ras.gray_min_x > c1 ) ras.gray_min_x = (short)c1;
      if ( ras.gray_max_x < c2 ) ras.gray_max_x = (short)c2;
d2305 1
a2305 1
    Long   e1, e2;
d2311 24
a2334 2
    e1 = CEILING( x1 );
    e2 = FLOOR  ( x2 );
d2338 3
d2343 1
a2343 1
        switch ( ras.dropOutControl )
d2345 2
a2346 2
        case 1:
          e1 = e2;
d2349 2
a2350 2
        case 4:
          e1 = CEILING( (x1 + x2 + 1) / 2 );
d2353 7
a2359 7
        case 2:
        case 5:
          /* Drop-out Control Rule #4 */

          /* The spec is not very clear regarding rule #4.  It      */
          /* presents a method that is way too costly to implement  */
          /* while the general idea seems to get rid of `stubs'.    */
d2361 1
a2361 1
          /* Here, we only get rid of stubs recognized if:          */
d2375 13
d2389 6
a2394 3
          /* FIXXXME: uncommenting this line solves the disappearing */
          /*          bit problem in the `7' of verdana 10pts, but   */
          /*          makes a new one in the `C' of arial 14pts      */
d2396 5
a2400 12
#if 0
          if ( x2 - x1 < ras.precision_half )
#endif
          {
            /* upper stub test */
            if ( left->next == right && left->height <= 0 )
              return;

            /* lower stub test */
            if ( right->next == left && left->start == y )
              return;
          }
d2402 3
a2404 1
          /* check that the rightmost pixel isn't set */
d2406 2
a2407 1
          e1 = TRUNC( e1 );
d2409 1
a2409 2
          c1 = (Short)( e1 >> 3 );
          f1 = (Short)( e1 &  7 );
d2411 2
a2412 3
          if ( e1 >= 0 && e1 < ras.bWidth                      &&
               ras.bTarget[ras.traceOfs + c1] & ( 0x80 >> f1 ) )
            return;
d2414 3
a2416 10
          if ( ras.dropOutControl == 2 )
            e1 = e2;
          else
            e1 = CEILING( ( x1 + x2 + 1 ) / 2 );

          break;

        default:
          return;  /* unsupported mode */
        }
d2422 1
a2422 1
    e1 = TRUNC( e1 );
d2429 4
a2432 2
      if ( ras.gray_min_x > c1 ) ras.gray_min_x = c1;
      if ( ras.gray_max_x < c1 ) ras.gray_max_x = c1;
d2516 1
a2516 1
    Long   e1, e2;
d2523 13
a2535 2
    e1 = CEILING( x1 );
    e2 = FLOOR  ( x2 );
d2539 3
d2544 1
a2544 1
        switch ( ras.dropOutControl )
d2546 2
a2547 2
        case 1:
          e1 = e2;
d2550 2
a2551 2
        case 4:
          e1 = CEILING( ( x1 + x2 + 1 ) / 2 );
d2554 3
a2556 9
        case 2:
        case 5:

          /* Drop-out Control Rule #4 */

          /* The spec is not very clear regarding rule #4.  It      */
          /* presents a method that is way too costly to implement  */
          /* while the general idea seems to get rid of `stubs'.    */
          /*                                                        */
d2559 4
a2562 1
          if ( left->next == right && left->height <= 0 )
d2566 4
a2569 1
          if ( right->next == left && left->start == y )
d2572 5
a2576 1
          /* check that the rightmost pixel isn't set */
d2578 3
a2580 1
          e1 = TRUNC( e1 );
d2582 2
a2583 2
          bits = ras.bTarget + ( y >> 3 );
          f1   = (Byte)( 0x80 >> ( y & 7 ) );
d2585 1
a2585 3
          bits -= e1 * ras.target.pitch;
          if ( ras.target.pitch > 0 )
            bits += ( ras.target.rows - 1 ) * ras.target.pitch;
d2587 2
a2588 4
          if ( e1 >= 0              &&
               e1 < ras.target.rows &&
               *bits & f1 )
            return;
d2590 3
a2592 4
          if ( ras.dropOutControl == 2 )
            e1 = e2;
          else
            e1 = CEILING( ( x1 + x2 + 1 ) / 2 );
d2594 4
a2597 5
          break;

        default:
          return;  /* unsupported mode */
        }
d2606 1
a2606 1
    e1 = TRUNC( e1 );
d2676 4
a2679 4
    Int    c1, c2;
    PByte  pix, bit, bit2;
    char*  count = (char*)count_table;
    Byte*  grays;
d2691 4
a2694 4
        Long   last_pixel = ras.target.width - 1;
        Int    last_cell  = last_pixel >> 2;
        Int    last_bit   = last_pixel & 3;
        Bool   over       = 0;
d2706 2
a2707 2
        bit   = ras.bTarget + ras.gray_min_x;
        bit2  = bit + ras.gray_width;
d2792 1
d2798 3
d2803 1
a2803 1
        switch ( ras.dropOutControl )
d2805 1
a2805 1
        case 1:
d2809 2
a2810 2
        case 4:
          e1 = CEILING( ( x1 + x2 + 1 ) / 2 );
d2813 3
a2815 9
        case 2:
        case 5:

          /* Drop-out Control Rule #4 */

          /* The spec is not very clear regarding rule #4.  It      */
          /* presents a method that is way too costly to implement  */
          /* while the general idea seems to get rid of `stubs'.    */
          /*                                                        */
d2825 1
a2825 1
          if ( ras.dropOutControl == 2 )
d2828 1
a2828 1
            e1 = CEILING( ( x1 + x2 + 1 ) / 2 );
d2832 2
a2833 2
        default:
          return;  /* unsupported mode */
d2885 1
a2885 1
    /* Init empty linked lists */
d2905 4
a2908 2
      if ( min_Y > bottom ) min_Y = bottom;
      if ( max_Y < top    ) max_Y = top;
d2916 1
a2916 1
    /* Check the Y-turns */
d2923 1
a2923 1
    /* Now inits the sweep */
d2927 1
a2927 1
    /* Then compute the distance of each profile from min_Y */
d2937 1
a2937 1
    /* Let's go */
d2942 1
a2942 1
    if ( ras.numTurns > 0 &&
d2948 1
a2948 1
      /* look in the waiting list for new activations */
d2960 1
a2960 3
          switch ( P->flow )
          {
          case Flow_Up:
d2962 1
a2962 3
            break;

          case Flow_Down:
a2963 2
            break;
          }
d2969 1
a2969 1
      /* Sort the drawing lists */
d2979 1
a2979 1
        /* Let's trace */
d2998 5
a3002 1
          if ( x2 - x1 <= ras.precision )
d3004 3
a3006 2
            e1 = FLOOR( x1 );
            e2 = CEILING( x2 );
a3007 4
            if ( ras.dropOutControl != 0                 &&
                 ( e1 > e2 || e2 == e1 + ras.precision ) )
            {
              /* a drop out was detected */
d3009 6
a3014 2
              P_Left ->X = x1;
              P_Right->X = x2;
d3016 4
a3019 3
              /* mark profile for drop-out processing */
              P_Left->countL = 1;
              dropouts++;
d3033 3
a3035 3
        /* now perform the dropouts _after_ the span drawing -- */
        /* drop-outs processing has been moved out of the loop  */
        /* for performance tuning                               */
d3052 1
a3052 1
      /* Now finalize the profiles that needs it */
d3073 1
a3073 1
    /* for gray-scaling, flushes the bitmap scanline cache */
d3116 1
a3116 1
  /*    Performs one sweep with sub-banding.                               */
d3191 1
a3191 1
  /*    Renders a glyph in a bitmap.  Sub-banding if needed.               */
d3203 18
a3220 8
                        FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift    = ras.precision_shift;
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
    ras.dropOutControl = 2;
    ras.second_pass    = (FT_Byte)( !( ras.outline.flags &
                                       FT_OUTLINE_SINGLE_PASS ) );
d3239 1
a3239 1
    if ( ras.second_pass && ras.dropOutControl != 0 )
a3259 1

d3266 1
a3266 1
  /*    Renders a glyph with grayscaling.  Sub-banding if needed.          */
d3279 17
a3295 7
                        FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift    = ras.precision_shift + 1;
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
    ras.dropOutControl = 2;
    ras.second_pass    = !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS );
d3323 1
a3323 1
    if ( ras.second_pass && ras.dropOutControl != 0 )
a3366 1

d3381 1
a3381 1
  ft_black_new( void*      memory,
d3439 3
a3441 3
  ft_black_reset( PRaster   raster,
                  char*     pool_base,
                  long      pool_size )
d3466 3
a3468 3
  ft_black_set_mode( PRaster            raster,
                     unsigned long      mode,
                     const char*        palette )
d3534 2
a3535 2
    ras.outline  = *outline;
    ras.target   = *target_map;
d3537 3
a3539 3
    worker->buff        = (PLong) raster->buffer;
    worker->sizeBuff    = worker->buff +
                            raster->buffer_size / sizeof ( Long );
d3541 4
a3544 2
    worker->grays       = raster->grays;
    worker->gray_width  = raster->gray_width;
d3547 3
a3549 3
    return ( ( params->flags & FT_RASTER_FLAG_AA )
               ? Render_Gray_Glyph( RAS_VAR )
               : Render_Glyph( RAS_VAR ) );
d3553 1
a3553 2
  const FT_Raster_Funcs  ft_standard_raster =
  {
d3560 1
a3560 1
  };
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007 by                         */
d147 1
a147 3
#ifdef FT_CONFIG_OPTION_5_GRAY_LEVELS
#define FT_RASTER_OPTION_ANTI_ALIASING
#endif
d544 2
d565 2
a3176 2
    FT_UNUSED( raster );

d3187 2
d3324 3
d3331 1
a3331 1
    if ( !outline || !outline->contours || !outline->points )
d3334 2
a3335 1
    if ( outline->n_points != outline->contours[outline->n_contours - 1] + 1 )
d3344 8
a3351 1
    if ( !target_map || !target_map->buffer )
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005 by                               */
d129 1
a129 1
  /*   handles the situation propertly.                                    */
d381 2
a382 2
#define RAS_ARGS       TRaster_Instance*  raster,
#define RAS_ARG        TRaster_Instance*  raster
d384 2
a385 2
#define RAS_VARS       raster,
#define RAS_VAR        raster
d387 1
a387 1
#define FT_UNUSED_RASTER  FT_UNUSED( raster )
d393 1
a393 1
  typedef struct TRaster_Instance_  TRaster_Instance;
d425 1
a425 1
  struct  TRaster_Instance_
d489 1
a489 1
    Bool      second_pass;          /* indicates wether a horizontal pass  */
a500 5
    Int       count_table[256];     /* Look-up table used to quickly count */
                                    /* set bits in a gray 2x2 cell         */

    void*     memory;

d503 1
a503 2
    Byte      grays[5];             /* Palette of gray levels used for     */
                                    /* render.                             */
d520 1
a520 4
#if 0
    PByte       flags;              /* current flags table                 */
    PUShort     outs;               /* current outlines table              */
    FT_Vector*  coords;
a521 3
    UShort      nPoints;            /* number of points in current glyph   */
    Short       nContours;          /* number of contours in current glyph */
#endif
d523 8
a530 1
  };
d532 1
d536 1
a536 1
  static TRaster_Instance  cur_ras;
d541 1
a541 1
#define ras  (*raster)
d546 21
d1649 1
a1649 1
  /*    Scans the outline arays in order to emit individual segments and   */
d2514 1
a2514 1
    Int*   count = ras.count_table;
d3173 1
a3173 1
  ft_black_init( TRaster_Instance*  raster )
d3175 3
a3178 12
    FT_ULong c;


    /* setup count table */
    for ( n = 0; n < 256; n++ )
    {
      c = ( n & 0x55 ) + ( ( n & 0xAA ) >> 1 );

      c = ( ( c << 6 ) & 0x3000 ) |
          ( ( c << 4 ) & 0x0300 ) |
          ( ( c << 2 ) & 0x0030 ) |
                   (c  & 0x0003 );
a3179 4
      ras.count_table[n] = (UInt)c;
    }

#ifdef FT_RASTER_OPTION_ANTI_ALIASING
d3185 1
a3185 1
    ras.gray_width = RASTER_GRAY_LINES / 2;
d3202 1
a3202 1
     static TRaster_Instance  the_raster;
d3225 2
a3226 2
  ft_black_new( FT_Memory           memory,
                TRaster_Instance**  araster )
d3228 2
a3229 2
    FT_Error           error;
    TRaster_Instance*  raster;
d3246 1
a3246 1
  ft_black_done( TRaster_Instance*  raster )
d3257 3
a3259 3
  ft_black_reset( TRaster_Instance*  raster,
                  char*              pool_base,
                  long               pool_size )
d3261 1
a3261 1
    if ( (&ras) && pool_base && pool_size >= 4096 )
d3263 16
a3278 3
      /* save the pool */
      ras.buff     = (PLong)pool_base;
      ras.sizeBuff = ras.buff + pool_size / sizeof ( Long );
d3284 1
a3284 1
  ft_black_set_mode( TRaster_Instance*  raster,
d3293 5
a3297 5
      ras.grays[0] = palette[0];
      ras.grays[1] = palette[1];
      ras.grays[2] = palette[2];
      ras.grays[3] = palette[3];
      ras.grays[4] = palette[4];
d3311 1
a3311 1
  ft_black_render( TRaster_Instance*        raster,
d3316 1
d3319 1
a3319 1
    if ( !(&ras) || !ras.buff || !ras.sizeBuff )
d3332 2
d3344 8
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003 by                                     */
d20 26
d50 6
d61 2
a144 3
  /* The default render pool size in bytes */
#define RASTER_RENDER_POOL  8192

d190 3
a192 1
#define FT_TRACE( x )  do ; while ( 0 )     /* nothing */
d202 1
d227 3
d291 10
d363 1
a363 1
          ( ( sizeof ( TProfile ) + sizeof ( long ) - 1 ) / sizeof ( long ) )
d366 1
a366 1
#ifdef TT_STATIC_RASTER
d378 1
a378 1
#else /* TT_STATIC_RASTER */
d390 1
a390 1
#endif /* TT_STATIC_RASTER */
d538 1
a538 1
#ifdef FT_CONFIG_OPTION_STATIC_RASTER
d547 1
a547 1
#endif /* FT_CONFIG_OPTION_STATIC_RASTER */
d1298 1
a1298 1
  /*        is stored in `LastX').                                         */
d1301 1
a1301 1
  /*        is stored in `LastY').                                         */
d1392 1
a1392 1
  /*         stored in `LastX').                                           */
d1395 1
a1395 1
  /*         stored in `LastY').                                           */
d1506 1
a1506 1
  /*          stored in `LastX').                                          */
d1509 1
a1509 1
  /*          stored in `LastY').                                          */
d2293 1
a2293 1
    FT_UNUSED( raster );
d2442 1
a2442 1
    FT_UNUSED( raster );
d2589 1
a2589 1
    FT_UNUSED( raster );
d3024 3
d3063 1
a3063 1
    return Raster_Err_Ok;
d3091 3
d3139 1
a3139 1
    return Raster_Err_Ok;
d3149 1
a3149 1
    return Raster_Err_Cannot_Render_Glyph;
d3172 1
a3172 1
      raster->count_table[n] = (UInt)c;
d3181 1
a3181 1
    raster->gray_width = RASTER_GRAY_LINES / 2;
d3198 1
a3198 1
     static FT_RasterRec_  the_raster;
d3201 1
a3201 1
     *araster = &the_raster;
d3213 1
a3213 1
    raster->init = 0;
d3254 1
a3254 1
                  const char*        pool_base,
d3257 1
a3257 1
    if ( raster && pool_base && pool_size >= 4096 )
d3260 2
a3261 2
      raster->buff     = (PLong)pool_base;
      raster->sizeBuff = raster->buff + pool_size / sizeof ( Long );
d3276 5
a3280 5
      raster->grays[0] = palette[0];
      raster->grays[1] = palette[1];
      raster->grays[2] = palette[2];
      raster->grays[3] = palette[3];
      raster->grays[4] = palette[4];
d3294 2
a3295 2
  ft_black_render( TRaster_Instance*  raster,
                   FT_Raster_Params*  params )
d3297 2
a3298 2
    FT_Outline*  outline    = (FT_Outline*)params->source;
    FT_Bitmap*   target_map = params->target;
d3301 1
a3301 1
    if ( !raster || !raster->buff || !raster->sizeBuff )
d3325 2
a3326 2
               ? Render_Gray_Glyph( raster )
               : Render_Glyph( raster ) );
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007 by                         */
a19 26
  /* This file can be compiled without the rest of the FreeType engine, by */
  /* defining the _STANDALONE_ macro when compiling it.  You also need to  */
  /* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
  /* directory.  Typically, you should do something like                   */
  /*                                                                       */
  /* - copy `src/raster/ftraster.c' (this file) to your current directory  */
  /*                                                                       */
  /* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h'         */
  /*   to your current directory                                           */
  /*                                                                       */
  /* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
  /*                                                                       */
  /*     cc -c -D_STANDALONE_ ftraster.c                                   */
  /*                                                                       */
  /* The renderer can be initialized with a call to                        */
  /* `ft_standard_raster.raster_new'; a bitmap can be generated            */
  /* with a call to `ft_standard_raster.raster_render'.                    */
  /*                                                                       */
  /* See the comments and documentation in the file `ftimage.h' for more   */
  /* details on how the raster works.                                      */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
a23 6
#ifdef _STANDALONE_

#include "ftmisc.h"
#include "ftimage.h"

#else /* !_STANDALONE_ */
a28 2
#endif /* !_STANDALONE_ */

d95 1
a95 1
  /*   handles the situation properly.                                     */
d111 3
d159 1
a159 3
#define FT_TRACE( x )   do ; while ( 0 )    /* nothing */
#define FT_TRACE1( x )  do ; while ( 0 )    /* nothing */
#define FT_TRACE6( x )  do ; while ( 0 )    /* nothing */
a168 1
#define ft_memset   memset
a192 3
#ifndef FT_MEM_ZERO
#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
#endif
a253 10

  typedef union  Alignment_
  {
    long    l;
    void*   p;
    void  (*f)(void);

  } Alignment, *PAlignment;


d316 1
a316 1
  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( long ) )
d319 1
a319 1
#ifdef FT_STATIC_RASTER
d331 1
a331 1
#else /* FT_STATIC_RASTER */
d334 2
a335 2
#define RAS_ARGS       PWorker    worker,
#define RAS_ARG        PWorker    worker
d337 2
a338 2
#define RAS_VARS       worker,
#define RAS_VAR        worker
d340 1
a340 1
#define FT_UNUSED_RASTER  FT_UNUSED( worker )
d343 1
a343 1
#endif /* FT_STATIC_RASTER */
d346 1
a346 1
  typedef struct TWorker_   TWorker, *PWorker;
d378 1
a378 1
  struct  TWorker_
d442 1
a442 1
    Bool      second_pass;          /* indicates whether a horizontal pass */
d454 5
d461 2
a462 1
    Byte*     grays;
d479 4
a482 1
  };
d484 3
d488 1
a488 8
  typedef struct TRaster_
  {
    char*     buffer;
    long      buffer_size;
    void*     memory;
    PWorker   worker;
    Byte      grays[5];
    Short     gray_width;
a489 1
  } TRaster, *PRaster;
d491 1
a491 1
#ifdef FT_STATIC_RASTER
d493 1
a493 1
  static TWorker   cur_ras;
d498 1
a498 23
#define ras  (*worker)

#endif /* FT_STATIC_RASTER */


static const char  count_table[256] =
{
  0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 , 2 , 3 , 3 , 4 , 3 , 4 , 4 , 5,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  2 , 3 , 3 , 4 , 3 , 4 , 4 , 5 , 3 , 4 , 4 , 5 , 4 , 5 , 5 , 6,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  3 , 4 , 4 , 5 , 4 , 5 , 5 , 6 , 4 , 5 , 5 , 6 , 5 , 6 , 6 , 7,
  4 , 5 , 5 , 6 , 5 , 6 , 6 , 7 , 5 , 6 , 6 , 7 , 6 , 7 , 7 , 8 };
d500 1
d1251 1
a1251 1
  /*        is stored in `lastX').                                         */
d1254 1
a1254 1
  /*        is stored in `lastY').                                         */
d1345 1
a1345 1
  /*         stored in `lastX').                                           */
d1348 1
a1348 1
  /*         stored in `lastY').                                           */
d1459 1
a1459 1
  /*          stored in `lastX').                                          */
d1462 1
a1462 1
  /*          stored in `lastY').                                          */
d1585 1
a1585 1
  /*    Scans the outline arrays in order to emit individual segments and  */
d2246 1
a2246 1
    FT_UNUSED_RASTER;
d2395 1
a2395 1
    FT_UNUSED_RASTER;
d2450 1
a2450 1
    char*  count = (char*)count_table;
d2542 1
a2542 1
    FT_UNUSED_RASTER;
a2976 3
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
d3013 1
a3013 1
    return Raster_Err_None;
a3040 3
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
d3086 1
a3086 1
    return Raster_Err_None;
d3096 1
a3096 1
    return Raster_Err_Unsupported;
d3103 1
a3103 1
  ft_black_init( PRaster  raster )
d3105 16
a3120 1
    FT_UNUSED( raster );
a3122 2
    FT_UInt  n;

d3145 1
a3145 1
     static TRaster  the_raster;
d3148 1
a3148 1
     *araster = (FT_Raster)&the_raster;
d3160 1
a3160 1
    FT_UNUSED( raster );
d3168 2
a3169 2
  ft_black_new( FT_Memory   memory,
                PRaster    *araster )
d3171 2
a3172 2
    FT_Error  error;
    PRaster   raster;
d3189 1
a3189 1
  ft_black_done( PRaster  raster )
d3200 3
a3202 3
  ft_black_reset( PRaster   raster,
                  char*     pool_base,
                  long      pool_size )
d3204 1
a3204 1
    if ( raster )
d3206 3
a3208 16
      if ( pool_base && pool_size >= (long)sizeof(TWorker) + 2048 )
      {
        PWorker  worker = (PWorker)pool_base;


        raster->buffer      = pool_base + ( (sizeof ( *worker ) + 7 ) & ~7 );
        raster->buffer_size = ( ( pool_base + pool_size ) -
                                (char*)raster->buffer ) / sizeof ( Long );
        raster->worker      = worker;
      }
      else
      {
        raster->buffer      = NULL;
        raster->buffer_size = 0;
        raster->worker      = NULL;
      }
d3214 1
a3214 1
  ft_black_set_mode( PRaster            raster,
d3241 2
a3242 2
  ft_black_render( PRaster                  raster,
                   const FT_Raster_Params*  params )
d3244 2
a3245 3
    const FT_Outline*  outline    = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map = params->target;
    PWorker            worker;
d3248 1
a3248 1
    if ( !raster || !raster->buffer || !raster->buffer_size )
a3260 2
    worker = raster->worker;

a3270 8
    worker->buff        = (PLong) raster->buffer;
    worker->sizeBuff    = worker->buff +
                            raster->buffer_size / sizeof ( Long );
#ifdef FT_RASTER_OPTION_ANTI_ALIASING
    worker->grays       = raster->grays;
    worker->gray_width  = raster->gray_width;
#endif

d3272 2
a3273 2
               ? Render_Gray_Glyph( RAS_VAR )
               : Render_Glyph( RAS_VAR ) );
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008 by                   */
d147 3
a149 1
#undef FT_RASTER_OPTION_ANTI_ALIASING
a545 2
#ifdef FT_RASTER_OPTION_ANTI_ALIASING

a564 2
#endif /* FT_RASTER_OPTION_ANTI_ALIASING */

d3175 2
a3186 2
#else
    FT_UNUSED( raster );
a3321 3
    if ( !outline )
      return Raster_Err_Invalid;

d3326 1
a3326 1
    if ( !outline->contours || !outline->points )
d3329 1
a3329 2
    if ( outline->n_points !=
           outline->contours[outline->n_contours - 1] + 1 )
d3338 1
a3338 8
    if ( !target_map )
      return Raster_Err_Invalid;

    /* nothing to do */
    if ( !target_map->width || !target_map->rows )
      return Raster_Err_None;

    if ( !target_map->buffer )
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005 by                               */
a19 26
  /* This file can be compiled without the rest of the FreeType engine, by */
  /* defining the _STANDALONE_ macro when compiling it.  You also need to  */
  /* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
  /* directory.  Typically, you should do something like                   */
  /*                                                                       */
  /* - copy `src/raster/ftraster.c' (this file) to your current directory  */
  /*                                                                       */
  /* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h'         */
  /*   to your current directory                                           */
  /*                                                                       */
  /* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
  /*                                                                       */
  /*     cc -c -D_STANDALONE_ ftraster.c                                   */
  /*                                                                       */
  /* The renderer can be initialized with a call to                        */
  /* `ft_standard_raster.raster_new'; a bitmap can be generated            */
  /* with a call to `ft_standard_raster.raster_render'.                    */
  /*                                                                       */
  /* See the comments and documentation in the file `ftimage.h' for more   */
  /* details on how the raster works.                                      */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
a23 6
#ifdef _STANDALONE_

#include "ftmisc.h"
#include "ftimage.h"

#else /* !_STANDALONE_ */
a28 2
#endif /* !_STANDALONE_ */

d111 3
d159 1
a159 3
#define FT_TRACE( x )   do ; while ( 0 )    /* nothing */
#define FT_TRACE1( x )  do ; while ( 0 )    /* nothing */
#define FT_TRACE6( x )  do ; while ( 0 )    /* nothing */
a168 1
#define ft_memset   memset
a192 3
#ifndef FT_MEM_ZERO
#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
#endif
a253 10

  typedef union  Alignment_
  {
    long    l;
    void*   p;
    void  (*f)(void);

  } Alignment, *PAlignment;


d316 1
a316 1
  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( long ) )
d319 1
a319 1
#ifdef FT_STATIC_RASTER
d331 1
a331 1
#else /* FT_STATIC_RASTER */
d343 1
a343 1
#endif /* FT_STATIC_RASTER */
d491 1
a491 1
#ifdef FT_STATIC_RASTER
d500 1
a500 1
#endif /* FT_STATIC_RASTER */
d1251 1
a1251 1
  /*        is stored in `lastX').                                         */
d1254 1
a1254 1
  /*        is stored in `lastY').                                         */
d1345 1
a1345 1
  /*         stored in `lastX').                                           */
d1348 1
a1348 1
  /*         stored in `lastY').                                           */
d1459 1
a1459 1
  /*          stored in `lastX').                                          */
d1462 1
a1462 1
  /*          stored in `lastY').                                          */
d2246 1
a2246 1
    FT_UNUSED_RASTER;
d2395 1
a2395 1
    FT_UNUSED_RASTER;
d2542 1
a2542 1
    FT_UNUSED_RASTER;
a2976 3
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
d3013 1
a3013 1
    return Raster_Err_None;
a3040 3
    /* Drop-out mode 2 is hard-coded since this is the only mode used */
    /* on Windows platforms.  Using other modes, as specified by the  */
    /* font, results in misplaced pixels.                             */
d3086 1
a3086 1
    return Raster_Err_None;
d3096 1
a3096 1
    return Raster_Err_Unsupported;
d3119 1
a3119 1
      ras.count_table[n] = (UInt)c;
d3128 1
a3128 1
    ras.gray_width = RASTER_GRAY_LINES / 2;
d3145 1
a3145 1
     static TRaster_Instance  the_raster;
d3148 1
a3148 1
     *araster = (FT_Raster)&the_raster;
d3160 1
a3160 1
    FT_UNUSED( raster );
d3201 1
a3201 1
                  char*              pool_base,
d3204 1
a3204 1
    if ( (&ras) && pool_base && pool_size >= 4096 )
d3207 2
a3208 2
      ras.buff     = (PLong)pool_base;
      ras.sizeBuff = ras.buff + pool_size / sizeof ( Long );
d3223 5
a3227 5
      ras.grays[0] = palette[0];
      ras.grays[1] = palette[1];
      ras.grays[2] = palette[2];
      ras.grays[3] = palette[3];
      ras.grays[4] = palette[4];
d3241 2
a3242 2
  ft_black_render( TRaster_Instance*        raster,
                   const FT_Raster_Params*  params )
d3244 2
a3245 2
    const FT_Outline*  outline    = (const FT_Outline*)params->source;
    const FT_Bitmap*   target_map = params->target;
d3248 1
a3248 1
    if ( !(&ras) || !ras.buff || !ras.sizeBuff )
d3272 2
a3273 2
               ? Render_Gray_Glyph( RAS_VAR )
               : Render_Glyph( RAS_VAR ) );
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008, 2009 by             */
a51 4
#define FT_CONFIG_STANDARD_LIBRARY_H  <stdlib.h>

#include <string.h>           /* for memset */

a60 2
#include "rastpic.h"

d75 1
a75 1
  /*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
d78 1
a78 1
  /*         between `Ymin' and `Ymax'                                     */
d81 1
a81 3
  /*         `down', as this is very important for filling rules           */
  /*                                                                       */
  /*       o its drop-out mode                                             */
d91 9
a99 9
  /*     __________________________________________________________ _ _    */
  /*    |         |                 |         |                 |          */
  /*    | profile | coordinates for | profile | coordinates for |-->       */
  /*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
  /*    |_________|_________________|_________|_________________|__ _ _    */
  /*                                                                       */
  /*    ^                                                       ^          */
  /*    |                                                       |          */
  /* start of render pool                                      top         */
d129 1
a129 1
  /*   handles the situation properly.                                     */
d143 1
a143 1
/* #define DEBUG_RASTER */
d145 5
a149 3
  /* define FT_RASTER_OPTION_ANTI_ALIASING if you want to support */
  /* 5-levels anti-aliasing                                       */
/* #define FT_RASTER_OPTION_ANTI_ALIASING */
d186 1
a186 1
#define FT_ERROR( x )  do { } while ( 0 )     /* nothing */
d190 3
a192 3
#define FT_TRACE( x )   do { } while ( 0 )    /* nothing */
#define FT_TRACE1( x )  do { } while ( 0 )    /* nothing */
#define FT_TRACE6( x )  do { } while ( 0 )    /* nothing */
d202 1
a202 1
#define ft_memset  memset
d204 1
a204 14
#define FT_DEFINE_RASTER_FUNCS( class_, glyph_format_, raster_new_, \
                                raster_reset_, raster_set_mode_,    \
                                raster_render_, raster_done_ )      \
          const FT_Raster_Funcs class_ =                            \
          {                                                         \
            glyph_format_,                                          \
            raster_new_,                                            \
            raster_reset_,                                          \
            raster_set_mode_,                                       \
            raster_render_,                                         \
            raster_done_                                            \
         };

#else /* !_STANDALONE_ */
d220 1
a220 1
#endif /* !_STANDALONE_ */
d309 7
a315 4
  /* values for the `flags' bit field */
#define Flow_Up           0x8
#define Overshoot_Top     0x10
#define Overshoot_Bottom  0x20
d334 6
a339 9
    FT_F26Dot6  X;           /* current coordinate during sweep          */
    PProfile    link;        /* link to next profile (various purposes)  */
    PLong       offset;      /* start of profile's data in render pool   */
    unsigned    flags;       /* Bit 0-2: drop-out mode                   */
                             /* Bit 3: profile orientation (up/down)     */
                             /* Bit 4: is top profile?                   */
                             /* Bit 5: is bottom profile?                */
    long        height;      /* profile's height in scanlines            */
    long        start;       /* profile's starting scanline              */
d341 2
a342 2
    unsigned    countL;      /* number of lines to step before this      */
                             /* profile becomes drawable                 */
d344 2
a345 2
    PProfile    next;        /* next profile in same contour, used       */
                             /* during drop-out control                  */
d375 1
a375 1
#define FT_UNUSED_RASTER  do { } while ( 0 )
d378 1
a378 1
#else /* !FT_STATIC_RASTER */
d381 2
a382 2
#define RAS_ARGS       PWorker    worker,
#define RAS_ARG        PWorker    worker
d384 2
a385 2
#define RAS_VARS       worker,
#define RAS_VAR        worker
d387 1
a387 1
#define FT_UNUSED_RASTER  FT_UNUSED( worker )
d390 1
a390 1
#endif /* !FT_STATIC_RASTER */
d393 1
a393 1
  typedef struct TWorker_  TWorker, *PWorker;
d420 14
a433 2
#define IS_BOTTOM_OVERSHOOT( x )  ( CEILING( x ) - x >= ras.precision_half )
#define IS_TOP_OVERSHOOT( x )     ( x - FLOOR( x ) >= ras.precision_half )
d435 1
a435 15
  /* The most used variables are positioned at the top of the structure. */
  /* Thus, their offset can be coded with less opcodes, resulting in a   */
  /* smaller executable.                                                 */

  struct  TWorker_
  {
    Int         precision_bits;     /* precision related variables         */
    Int         precision;
    Int         precision_half;
    Long        precision_mask;
    Int         precision_shift;
    Int         precision_step;
    Int         precision_jitter;

    Int         scale_shift;        /* == precision_shift   for bitmaps    */
d438 4
a441 4
    PLong       buff;               /* The profiles buffer                 */
    PLong       sizeBuff;           /* Render pool size                    */
    PLong       maxBuff;            /* Profiles buffer size                */
    PLong       top;                /* Current cursor in buffer            */
d443 1
a443 1
    FT_Error    error;
d445 1
a445 1
    Int         numTurns;           /* number of Y-turns in outline        */
d447 1
a447 1
    TPoint*     arc;                /* current Bezier arc pointer          */
d449 3
a451 3
    UShort      bWidth;             /* target bitmap width                 */
    PByte       bTarget;            /* target bitmap buffer                */
    PByte       gTarget;            /* target pixmap buffer                */
d453 1
a453 2
    Long        lastX, lastY;
    Long        minY, maxY;
d455 1
a455 1
    UShort      num_Profs;          /* current number of profiles          */
d457 3
a459 3
    Bool        fresh;              /* signals a fresh new profile which   */
                                    /* `start' field must be completed     */
    Bool        joint;              /* signals that the last arc ended     */
d462 3
a464 3
    PProfile    cProfile;           /* current profile                     */
    PProfile    fProfile;           /* head of linked list of profiles     */
    PProfile    gProfile;           /* contour's first profile in case     */
d467 1
a467 1
    TStates     state;              /* rendering state                     */
d472 2
a473 2
    Long        traceOfs;           /* current offset in target bitmap     */
    Long        traceG;             /* current offset in target pixmap     */
d475 1
a475 1
    Short       traceIncr;          /* sweep's increment in target bitmap  */
d477 2
a478 2
    Short       gray_min_x;         /* current min x during gray rendering */
    Short       gray_max_x;         /* current max x during gray rendering */
d487 1
a487 1
    Byte        dropOutControl;     /* current drop_out control method     */
d489 1
a489 1
    Bool        second_pass;        /* indicates whether a horizontal pass */
d496 4
a499 1
    TPoint      arcs[3 * MaxBezier + 1]; /* The Bezier stack               */
d501 4
a504 2
    TBand       band_stack[16];     /* band stack used for sub-banding     */
    Int         band_top;           /* band stack top                      */
d508 2
a509 1
    Byte*       grays;
d511 1
a511 1
    Byte        gray_lines[RASTER_GRAY_LINES];
d517 1
a517 1
    Short       gray_width;     /* width in bytes of one monochrome        */
d526 4
a529 1
  };
d531 3
d535 1
a535 8
  typedef struct  TRaster_
  {
    char*    buffer;
    long     buffer_size;
    void*    memory;
    PWorker  worker;
    Byte     grays[5];
    Short    gray_width;
a536 1
  } TRaster, *PRaster;
d540 1
a540 1
  static TWorker  cur_ras;
d543 1
a543 3
#else /* !FT_STATIC_RASTER */

#define ras  (*worker)
d545 1
a545 64
#endif /* !FT_STATIC_RASTER */


#ifdef FT_RASTER_OPTION_ANTI_ALIASING

  /* A lookup table used to quickly count set bits in four gray 2x2 */
  /* cells.  The values of the table have been produced with the    */
  /* following code:                                                */
  /*                                                                */
  /*   for ( i = 0; i < 256; i++ )                                  */
  /*   {                                                            */
  /*     l = 0;                                                     */
  /*     j = i;                                                     */
  /*                                                                */
  /*     for ( c = 0; c < 4; c++ )                                  */
  /*     {                                                          */
  /*       l <<= 4;                                                 */
  /*                                                                */
  /*       if ( j & 0x80 ) l++;                                     */
  /*       if ( j & 0x40 ) l++;                                     */
  /*                                                                */
  /*       j = ( j << 2 ) & 0xFF;                                   */
  /*     }                                                          */
  /*     printf( "0x%04X", l );                                     */
  /*   }                                                            */
  /*                                                                */

  static const short  count_table[256] =
  {
    0x0000, 0x0001, 0x0001, 0x0002, 0x0010, 0x0011, 0x0011, 0x0012,
    0x0010, 0x0011, 0x0011, 0x0012, 0x0020, 0x0021, 0x0021, 0x0022,
    0x0100, 0x0101, 0x0101, 0x0102, 0x0110, 0x0111, 0x0111, 0x0112,
    0x0110, 0x0111, 0x0111, 0x0112, 0x0120, 0x0121, 0x0121, 0x0122,
    0x0100, 0x0101, 0x0101, 0x0102, 0x0110, 0x0111, 0x0111, 0x0112,
    0x0110, 0x0111, 0x0111, 0x0112, 0x0120, 0x0121, 0x0121, 0x0122,
    0x0200, 0x0201, 0x0201, 0x0202, 0x0210, 0x0211, 0x0211, 0x0212,
    0x0210, 0x0211, 0x0211, 0x0212, 0x0220, 0x0221, 0x0221, 0x0222,
    0x1000, 0x1001, 0x1001, 0x1002, 0x1010, 0x1011, 0x1011, 0x1012,
    0x1010, 0x1011, 0x1011, 0x1012, 0x1020, 0x1021, 0x1021, 0x1022,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1200, 0x1201, 0x1201, 0x1202, 0x1210, 0x1211, 0x1211, 0x1212,
    0x1210, 0x1211, 0x1211, 0x1212, 0x1220, 0x1221, 0x1221, 0x1222,
    0x1000, 0x1001, 0x1001, 0x1002, 0x1010, 0x1011, 0x1011, 0x1012,
    0x1010, 0x1011, 0x1011, 0x1012, 0x1020, 0x1021, 0x1021, 0x1022,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1100, 0x1101, 0x1101, 0x1102, 0x1110, 0x1111, 0x1111, 0x1112,
    0x1110, 0x1111, 0x1111, 0x1112, 0x1120, 0x1121, 0x1121, 0x1122,
    0x1200, 0x1201, 0x1201, 0x1202, 0x1210, 0x1211, 0x1211, 0x1212,
    0x1210, 0x1211, 0x1211, 0x1212, 0x1220, 0x1221, 0x1221, 0x1222,
    0x2000, 0x2001, 0x2001, 0x2002, 0x2010, 0x2011, 0x2011, 0x2012,
    0x2010, 0x2011, 0x2011, 0x2012, 0x2020, 0x2021, 0x2021, 0x2022,
    0x2100, 0x2101, 0x2101, 0x2102, 0x2110, 0x2111, 0x2111, 0x2112,
    0x2110, 0x2111, 0x2111, 0x2112, 0x2120, 0x2121, 0x2121, 0x2122,
    0x2100, 0x2101, 0x2101, 0x2102, 0x2110, 0x2111, 0x2111, 0x2112,
    0x2110, 0x2111, 0x2111, 0x2112, 0x2120, 0x2121, 0x2121, 0x2122,
    0x2200, 0x2201, 0x2201, 0x2202, 0x2210, 0x2211, 0x2211, 0x2212,
    0x2210, 0x2211, 0x2211, 0x2212, 0x2220, 0x2221, 0x2221, 0x2222
  };

#endif /* FT_RASTER_OPTION_ANTI_ALIASING */
d547 1
d565 1
a565 1
  /*    Set precision variables according to param flag.                   */
d576 3
a578 3
      ras.precision_bits   = 12;
      ras.precision_step   = 256;
      ras.precision_jitter = 50;
d602 1
a602 1
  /*    Create a new profile in the render pool.                           */
d605 1
a605 4
  /*    aState    :: The state/orientation of the new profile.             */
  /*                                                                       */
  /*    overshoot :: Whether the profile's unrounded start position        */
  /*                 differs by at least a half pixel.                     */
d612 1
a612 2
  New_Profile( RAS_ARGS TStates  aState,
                        Bool     overshoot )
a626 8
    ras.cProfile->flags  = 0;
    ras.cProfile->start  = 0;
    ras.cProfile->height = 0;
    ras.cProfile->offset = ras.top;
    ras.cProfile->link   = (PProfile)0;
    ras.cProfile->next   = (PProfile)0;
    ras.cProfile->flags  = ras.dropOutControl;

d630 1
a630 4
      ras.cProfile->flags |= Flow_Up;
      if ( overshoot )
        ras.cProfile->flags |= Overshoot_Bottom;

d635 1
a635 2
      if ( overshoot )
        ras.cProfile->flags |= Overshoot_Top;
d640 1
a640 1
      FT_ERROR(( "New_Profile: invalid profile direction\n" ));
d645 6
d668 1
a668 5
  /*    Finalize the current profile.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    overshoot :: Whether the profile's unrounded end position differs  */
  /*                 by at least a half pixel.                             */
d674 1
a674 1
  End_Profile( RAS_ARGS Bool  overshoot )
d684 1
a684 1
      FT_ERROR(( "End_Profile: negative height encountered\n" ));
d694 1
d696 1
a696 10
      if ( overshoot )
      {
        if ( ras.cProfile->flags & Flow_Up )
          ras.cProfile->flags |= Overshoot_Top;
        else
          ras.cProfile->flags |= Overshoot_Bottom;
      }

      oldProfile   = ras.cProfile;
      ras.cProfile = (PProfile)ras.top;
d698 1
a698 1
      ras.top += AlignProfileSize;
d702 1
a702 2

      oldProfile->next = ras.cProfile;
d725 1
a725 1
  /*    Insert a salient into the sorted list placed on top of the render  */
d780 1
a780 1
  /*    Adjust all links in the profiles list.                             */
a793 1
    p = ras.fProfile;
d795 1
a795 1
    if ( n > 1 && p )
d797 1
d805 1
a805 6
        if ( p->flags & Flow_Up )
        {
          bottom = (Int)p->start;
          top    = (Int)( p->start + p->height - 1 );
        }
        else
d807 1
d812 6
d820 2
a821 2
        if ( Insert_Y_Turn( RAS_VARS bottom )  ||
             Insert_Y_Turn( RAS_VARS top + 1 ) )
d841 1
a841 1
  /*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
d880 1
a880 1
  /*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
d922 1
a922 1
  /*    Compute the x-coordinates of an ascending line segment and store   */
d1061 2
a1062 2
  /*    Compute the x-coordinates of an descending line segment and store  */
  /*    them in the render pool.                                           */
d1112 1
a1112 1
  /*    Compute the x-coordinates of an ascending Bezier arc and store     */
d1213 1
a1213 1
          *top++ = arc[degree].x + FMulDiv( arc[0].x - arc[degree].x,
d1245 1
a1245 1
  /*    Compute the x-coordinates of an descending Bezier arc and store    */
d1294 1
a1294 1
  /*    Inject a new line segment and adjust the Profiles list.            */
d1318 1
a1318 2
        if ( New_Profile( RAS_VARS Ascending_State,
                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
d1324 1
a1324 2
          if ( New_Profile( RAS_VARS Descending_State,
                                     IS_TOP_OVERSHOOT( ras.lastY ) ) )
d1332 2
a1333 3
        if ( End_Profile( RAS_VARS IS_TOP_OVERSHOOT( ras.lastY ) ) ||
             New_Profile( RAS_VARS Descending_State,
                                   IS_TOP_OVERSHOOT( ras.lastY ) ) )
d1341 2
a1342 3
        if ( End_Profile( RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY ) ) ||
             New_Profile( RAS_VARS Ascending_State,
                                   IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
d1357 1
a1357 1
                             x, y, ras.minY, ras.maxY ) )
d1363 1
a1363 1
                               x, y, ras.minY, ras.maxY ) )
d1384 1
a1384 1
  /*    Inject a new conic arc and adjust the profile list.                */
d1414 2
a1415 4
    ras.arc[1].x = cx;
    ras.arc[1].y = cy;
    ras.arc[0].x = x;
    ras.arc[0].y = y;
a1454 4
          Bool  o = state_bez == Ascending_State ? IS_BOTTOM_OVERSHOOT( y1 )
                                                 : IS_TOP_OVERSHOOT( y1 );


d1456 2
a1457 2
          if ( ras.state != Unknown_State &&
               End_Profile( RAS_VARS o )  )
d1461 1
a1461 1
          if ( New_Profile( RAS_VARS state_bez, o ) )
d1494 1
a1494 1
  /*    Inject a new cubic arc and adjust the profile list.                */
d1530 3
a1532 6
    ras.arc[2].x = cx1;
    ras.arc[2].y = cy1;
    ras.arc[1].x = cx2;
    ras.arc[1].y = cy2;
    ras.arc[0].x = x;
    ras.arc[0].y = y;
d1584 2
a1585 7
          Bool  o = state_bez == Ascending_State ? IS_BOTTOM_OVERSHOOT( y1 )
                                                 : IS_TOP_OVERSHOOT( y1 );


          /* finalize current profile if any */
          if ( ras.state != Unknown_State &&
               End_Profile( RAS_VARS o )  )
d1588 1
a1588 1
          if ( New_Profile( RAS_VARS state_bez, o ) )
d1632 1
a1632 1
  /*    Scan the outline arrays in order to emit individual segments and   */
d1681 2
a1682 7
    tags  = ras.outline.tags + first;

    /* set scan mode if necessary */
    if ( tags[0] & FT_CURVE_TAG_HAS_SCANMODE )
      ras.dropOutControl = (Byte)tags[0] >> 5;

    tag = FT_CURVE_TAG( tags[0] );
d1853 1
a1853 1
  /*    Convert a glyph into a series of segments and arcs and make a      */
a1887 3
      Bool  o;


d1892 2
a1893 2
                                     ras.outline.contours[i],
                                     flipped ) )
d1898 1
a1898 1
      /* we must now check whether the extreme arcs join or not */
d1902 1
a1902 3
        if ( ras.gProfile                        &&
             ( ras.gProfile->flags & Flow_Up ) ==
               ( ras.cProfile->flags & Flow_Up ) )
d1908 1
a1908 5
      if ( ras.cProfile->flags & Flow_Up )
        o = IS_TOP_OVERSHOOT( ras.lastY );
      else
        o = IS_BOTTOM_OVERSHOOT( ras.lastY );
      if ( End_Profile( RAS_VARS o ) )
d2028 1
a2028 1
      current->offset += current->flags & Flow_Up ? 1 : -1;
d2134 2
a2135 4
      if ( ras.gray_min_x > c1 )
        ras.gray_min_x = (short)c1;
      if ( ras.gray_max_x < c2 )
        ras.gray_max_x = (short)c2;
d2168 1
a2168 1
    Long   e1, e2, pxl;
d2174 2
a2175 24
    /*   e2            x2                    x1           e1   */
    /*                                                         */
    /*                 ^                     |                 */
    /*                 |                     |                 */
    /*   +-------------+---------------------+------------+    */
    /*                 |                     |                 */
    /*                 |                     v                 */
    /*                                                         */
    /* pixel         contour              contour       pixel  */
    /* center                                           center */

    /* drop-out mode    scan conversion rules (as defined in OpenType) */
    /* --------------------------------------------------------------- */
    /*  0                1, 2, 3                                       */
    /*  1                1, 2, 4                                       */
    /*  2                1, 2                                          */
    /*  3                same as mode 2                                */
    /*  4                1, 2, 5                                       */
    /*  5                1, 2, 6                                       */
    /*  6, 7             same as mode 2                                */

    e1  = CEILING( x1 );
    e2  = FLOOR  ( x2 );
    pxl = e1;
a2178 3
      Int  dropOutControl = left->flags & 7;


d2181 1
a2181 1
        switch ( dropOutControl )
d2183 2
a2184 2
        case 0: /* simple drop-outs including stubs */
          pxl = e2;
d2187 2
a2188 2
        case 4: /* smart drop-outs including stubs */
          pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
d2191 7
a2197 7
        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */

          /* Drop-out Control Rules #4 and #6 */

          /* The specification neither provides an exact definition */
          /* of a `stub' nor gives exact rules to exclude them.     */
d2199 1
a2199 1
          /* Here the constraints we use to recognize a stub.       */
a2212 13
          /* We draw a stub if the following constraints are met.   */
          /*                                                        */
          /*   - for an upper or lower stub, there is top or bottom */
          /*     overshoot, respectively                            */
          /*   - the covered interval is greater or equal to a half */
          /*     pixel                                              */

          /* upper stub test */
          if ( left->next == right                &&
               left->height <= 0                  &&
               !( left->flags & Overshoot_Top   &&
                  x2 - x1 >= ras.precision_half ) )
            return;
d2214 26
a2239 5
          /* lower stub test */
          if ( right->next == left                 &&
               left->start == y                    &&
               !( left->flags & Overshoot_Bottom &&
                  x2 - x1 >= ras.precision_half  ) )
d2242 2
a2243 2
          if ( dropOutControl == 1 )
            pxl = e2;
d2245 2
a2246 1
            pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
d2249 2
a2250 2
        default: /* modes 2, 3, 6, 7 */
          return;  /* no drop-out control */
a2251 12

        /* check that the other pixel isn't set */
        e1 = pxl == e1 ? e2 : e1;

        e1 = TRUNC( e1 );

        c1 = (Short)( e1 >> 3 );
        f1 = (Short)( e1 &  7 );

        if ( e1 >= 0 && e1 < ras.bWidth                      &&
             ras.bTarget[ras.traceOfs + c1] & ( 0x80 >> f1 ) )
          return;
d2257 1
a2257 1
    e1 = TRUNC( pxl );
d2264 2
a2265 4
      if ( ras.gray_min_x > c1 )
        ras.gray_min_x = c1;
      if ( ras.gray_max_x < c1 )
        ras.gray_max_x = c1;
d2349 1
a2349 1
    Long   e1, e2, pxl;
d2356 2
a2357 13
    /* e1     +       <-- pixel center */
    /*        |                        */
    /* x1  ---+-->    <-- contour      */
    /*        |                        */
    /*        |                        */
    /* x2  <--+---    <-- contour      */
    /*        |                        */
    /*        |                        */
    /* e2     +       <-- pixel center */

    e1  = CEILING( x1 );
    e2  = FLOOR  ( x2 );
    pxl = e1;
a2360 3
      Int  dropOutControl = left->flags & 7;


d2363 1
a2363 1
        switch ( dropOutControl )
d2365 2
a2366 2
        case 0: /* simple drop-outs including stubs */
          pxl = e2;
d2369 2
a2370 2
        case 4: /* smart drop-outs including stubs */
          pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
d2373 9
a2381 3
        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */
          /* see Vertical_Sweep_Drop for details */
d2384 1
a2384 4
          if ( left->next == right                &&
               left->height <= 0                  &&
               !( left->flags & Overshoot_Top   &&
                  x2 - x1 >= ras.precision_half ) )
d2388 1
a2388 4
          if ( right->next == left                 &&
               left->start == y                    &&
               !( left->flags & Overshoot_Bottom &&
                  x2 - x1 >= ras.precision_half  ) )
d2391 3
a2393 5
          if ( dropOutControl == 1 )
            pxl = e2;
          else
            pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
          break;
d2395 2
a2396 3
        default: /* modes 2, 3, 6, 7 */
          return;  /* no drop-out control */
        }
d2398 3
a2400 2
        /* check that the other pixel isn't set */
        e1 = pxl == e1 ? e2 : e1;
d2402 4
a2405 1
        e1 = TRUNC( e1 );
d2407 4
a2410 2
        bits = ras.bTarget + ( y >> 3 );
        f1   = (Byte)( 0x80 >> ( y & 7 ) );
d2412 1
a2412 3
        bits -= e1 * ras.target.pitch;
        if ( ras.target.pitch > 0 )
          bits += ( ras.target.rows - 1 ) * ras.target.pitch;
d2414 3
a2416 4
        if ( e1 >= 0              &&
             e1 < ras.target.rows &&
             *bits & f1           )
          return;
d2425 1
a2425 1
    e1 = TRUNC( pxl );
d2495 4
a2498 4
    Int     c1, c2;
    PByte   pix, bit, bit2;
    short*  count = (short*)count_table;
    Byte*   grays;
d2510 4
a2513 4
        Long  last_pixel = ras.target.width - 1;
        Int   last_cell  = last_pixel >> 2;
        Int   last_bit   = last_pixel & 3;
        Bool  over       = 0;
d2525 2
a2526 2
        bit  = ras.bTarget + ras.gray_min_x;
        bit2 = bit + ras.gray_width;
a2610 1

a2615 3
      Int  dropOutControl = left->flags & 7;


d2618 1
a2618 1
        switch ( dropOutControl )
d2620 1
a2620 1
        case 0: /* simple drop-outs including stubs */
d2624 2
a2625 2
        case 4: /* smart drop-outs including stubs */
          e1 = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
d2628 9
a2636 3
        case 1: /* simple drop-outs excluding stubs */
        case 5: /* smart drop-outs excluding stubs  */
          /* see Vertical_Sweep_Drop for details */
d2646 1
a2646 1
          if ( dropOutControl == 1 )
d2649 1
a2649 1
            e1 = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
d2653 2
a2654 2
        default: /* modes 2, 3, 6, 7 */
          return;  /* no drop-out control */
d2706 1
a2706 1
    /* initialize empty linked lists */
d2726 2
a2727 4
      if ( min_Y > bottom )
        min_Y = bottom;
      if ( max_Y < top )
        max_Y = top;
d2735 1
a2735 1
    /* check the Y-turns */
d2742 1
a2742 1
    /* now initialize the sweep */
d2746 1
a2746 1
    /* then compute the distance of each profile from min_Y */
d2756 1
a2756 1
    /* let's go */
d2761 1
a2761 1
    if ( ras.numTurns > 0                     &&
d2767 1
a2767 1
      /* check waiting list for new activations */
d2779 3
a2781 1
          if ( P->flags & Flow_Up )
d2783 3
a2785 1
          else
d2787 2
d2794 1
a2794 1
      /* sort the drawing lists */
d2804 1
a2804 1
        /* let's trace */
d2823 4
a2826 2
          e1 = FLOOR( x1 );
          e2 = CEILING( x2 );
d2828 2
a2829 4
          if ( x2 - x1 <= ras.precision &&
               e1 != x1 && e2 != x2     )
          {
            if ( e1 > e2 || e2 == e1 + ras.precision )
d2831 1
a2831 2
              Int  dropOutControl = P_Left->flags & 7;

d2833 2
a2834 3
              if ( dropOutControl != 2 )
              {
                /* a drop-out was detected */
d2836 3
a2838 7
                P_Left ->X = x1;
                P_Right->X = x2;

                /* mark profile for drop-out processing */
                P_Left->countL = 1;
                dropouts++;
              }
d2852 3
a2854 3
        /* handle drop-outs _after_ the span drawing --       */
        /* drop-out processing has been moved out of the loop */
        /* for performance tuning                             */
d2871 1
a2871 1
      /* now finalize the profiles that need it */
d2892 1
a2892 1
    /* for gray-scaling, flush the bitmap scanline cache */
d2935 1
a2935 1
  /*    Perform one sweep with sub-banding.                                */
d3010 1
a3010 1
  /*    Render a glyph in a bitmap.  Sub-banding if needed.                */
d3022 8
a3029 18
                                 FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift = ras.precision_shift;

    if ( ras.outline.flags & FT_OUTLINE_IGNORE_DROPOUTS )
      ras.dropOutControl = 2;
    else
    {
      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )
        ras.dropOutControl = 4;
      else
        ras.dropOutControl = 0;

      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )
        ras.dropOutControl += 1;
    }

    ras.second_pass = (FT_Byte)( !( ras.outline.flags &
                                    FT_OUTLINE_SINGLE_PASS ) );
d3048 1
a3048 1
    if ( ras.second_pass && ras.dropOutControl != 2 )
d3069 1
d3076 1
a3076 1
  /*    Render a glyph with grayscaling.  Sub-banding if needed.           */
d3089 7
a3095 17
                                 FT_OUTLINE_HIGH_PRECISION );
    ras.scale_shift = ras.precision_shift + 1;

    if ( ras.outline.flags & FT_OUTLINE_IGNORE_DROPOUTS )
      ras.dropOutControl = 2;
    else
    {
      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )
        ras.dropOutControl = 4;
      else
        ras.dropOutControl = 0;

      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )
        ras.dropOutControl += 1;
    }

    ras.second_pass = !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS );
d3123 1
a3123 1
    if ( ras.second_pass && ras.dropOutControl != 2 )
d3156 1
a3156 1
  ft_black_init( PRaster  raster )
a3157 1
#ifdef FT_RASTER_OPTION_ANTI_ALIASING
d3159 7
d3167 9
d3181 2
a3182 3
    raster->gray_width = RASTER_GRAY_LINES / 2;
#else
    FT_UNUSED( raster );
d3195 1
a3195 1
  ft_black_new( void*       memory,
d3198 1
a3198 1
     static TRaster  the_raster;
d3221 2
a3222 2
  ft_black_new( FT_Memory   memory,
                PRaster    *araster )
d3224 2
a3225 2
    FT_Error  error;
    PRaster   raster;
d3242 1
a3242 1
  ft_black_done( PRaster  raster )
d3253 3
a3255 3
  ft_black_reset( PRaster  raster,
                  char*    pool_base,
                  long     pool_size )
d3257 1
a3257 1
    if ( raster )
d3259 3
a3261 16
      if ( pool_base && pool_size >= (long)sizeof(TWorker) + 2048 )
      {
        PWorker  worker = (PWorker)pool_base;


        raster->buffer      = pool_base + ( (sizeof ( *worker ) + 7 ) & ~7 );
        raster->buffer_size = ( ( pool_base + pool_size ) -
                                (char*)raster->buffer ) / sizeof ( Long );
        raster->worker      = worker;
      }
      else
      {
        raster->buffer      = NULL;
        raster->buffer_size = 0;
        raster->worker      = NULL;
      }
d3267 3
a3269 3
  ft_black_set_mode( PRaster        raster,
                     unsigned long  mode,
                     const char*    palette )
d3276 5
a3280 5
      raster->grays[0] = palette[0];
      raster->grays[1] = palette[1];
      raster->grays[2] = palette[2];
      raster->grays[3] = palette[3];
      raster->grays[4] = palette[4];
d3294 1
a3294 1
  ft_black_render( PRaster                  raster,
a3298 1
    PWorker            worker;
d3301 1
a3301 1
    if ( !raster || !raster->buffer || !raster->buffer_size )
a3303 3
    if ( !outline )
      return Raster_Err_Invalid;

d3308 1
a3308 1
    if ( !outline->contours || !outline->points )
d3311 1
a3311 2
    if ( outline->n_points !=
           outline->contours[outline->n_contours - 1] + 1 )
a3313 2
    worker = raster->worker;

d3318 1
a3318 8
    if ( !target_map )
      return Raster_Err_Invalid;

    /* nothing to do */
    if ( !target_map->width || !target_map->rows )
      return Raster_Err_None;

    if ( !target_map->buffer )
d3321 2
a3322 2
    ras.outline = *outline;
    ras.target  = *target_map;
d3324 3
a3326 13
    worker->buff       = (PLong) raster->buffer;
    worker->sizeBuff   = worker->buff +
                           raster->buffer_size / sizeof ( Long );
#ifdef FT_RASTER_OPTION_ANTI_ALIASING
    worker->grays      = raster->grays;
    worker->gray_width = raster->gray_width;

    FT_MEM_ZERO( worker->gray_lines, worker->gray_width * 2 );
#endif

    return ( params->flags & FT_RASTER_FLAG_AA )
           ? Render_Gray_Glyph( RAS_VAR )
           : Render_Glyph( RAS_VAR );
d3330 2
a3331 1
  FT_DEFINE_RASTER_FUNCS( ft_standard_raster,
d3338 1
a3338 1
  )
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d21 1
a21 1
  /* defining the STANDALONE_ macro when compiling it.  You also need to   */
d27 2
a28 2
  /* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h' to your */
  /*   current directory                                                   */
d30 1
a30 1
  /* - compile `ftraster' with the STANDALONE_ macro defined, as in        */
d32 1
a32 1
  /*     cc -c -DSTANDALONE_ ftraster.c                                    */
d50 1
a50 5
#ifdef STANDALONE_

  /* The size in bytes of the render pool used by the scan-line converter  */
  /* to do all of its work.                                                */
#define FT_RENDER_POOL_SIZE  16384L
d59 1
a59 1
#else /* !STANDALONE_ */
d63 1
a63 1
#include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */
d67 1
a67 1
#endif /* !STANDALONE_ */
d153 8
d180 1
a180 1
#ifdef STANDALONE_
a181 3
  /* Auxiliary macros for token concatenation. */
#define FT_ERR_XCAT( x, y )  x ## y
#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )
d190 1
a190 1
  /* activate it easily by redefining these macros.                      */
a198 5
#define FT_TRACE7( x )  do { } while ( 0 )    /* nothing */
#endif

#ifndef FT_THROW
#define FT_THROW( e )  FT_ERR_CAT( Raster_Err_, e )
d223 1
a223 1
#else /* !STANDALONE_ */
d227 1
a227 1
#include FT_INTERNAL_DEBUG_H       /* for FT_TRACE, FT_ERROR, and FT_THROW */
d231 1
a231 1
#define Raster_Err_None         FT_Err_Ok
d239 1
a239 1
#endif /* !STANDALONE_ */
a249 4
#ifndef FT_ZERO
#define FT_ZERO( p )  FT_MEM_ZERO( p, sizeof ( *(p) ) )
#endif

d258 1
a258 2
#define SMulDiv           FT_MulDiv
#define SMulDiv_No_Round  FT_MulDiv_No_Round
d313 1
a313 1
    Long    l;
d329 3
a331 3
#define Flow_Up           0x08U
#define Overshoot_Top     0x10U
#define Overshoot_Bottom  0x20U
d353 1
a353 1
    UShort      flags;       /* Bit 0-2: drop-out mode                   */
d357 2
a358 2
    Long        height;      /* profile's height in scanlines            */
    Long        start;       /* profile's starting scanline              */
d360 1
a360 1
    Int         countL;      /* number of lines to step before this      */
d373 1
a373 1
  typedef struct  black_TBand_
d378 1
a378 1
  } black_TBand;
d382 1
a382 2
  ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( Long ) )

a383 4
#undef RAS_ARG
#undef RAS_ARGS
#undef RAS_VAR
#undef RAS_VARS
d400 2
a401 2
#define RAS_ARGS       black_PWorker  worker,
#define RAS_ARG        black_PWorker  worker
d412 1
a412 1
  typedef struct black_TWorker_  black_TWorker, *black_PWorker;
a431 4
#undef FLOOR
#undef CEILING
#undef TRUNC
#undef SCALED
d435 1
a435 1
#define TRUNC( x )    ( (Long)(x) >> ras.precision_bits )
d437 1
a437 8
#define SCALED( x )   ( ( (x) < 0 ? -( -(x) << ras.scale_shift )   \
                                  :  (  (x) << ras.scale_shift ) ) \
                        - ras.precision_half )

#define IS_BOTTOM_OVERSHOOT( x ) \
          (Bool)( CEILING( x ) - x >= ras.precision_half )
#define IS_TOP_OVERSHOOT( x )    \
          (Bool)( x - FLOOR( x ) >= ras.precision_half )
d439 2
a440 5
#if FT_RENDER_POOL_SIZE > 2048
#define FT_MAX_BLACK_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( Long ) )
#else
#define FT_MAX_BLACK_POOL  ( 2048 / sizeof ( Long ) )
#endif
d446 1
a446 1
  struct  black_TWorker_
d451 1
d499 3
d514 3
a516 1
                                    /* Render_Glyph.                       */
d520 21
a540 2
    black_TBand  band_stack[16];    /* band stack used for sub-banding     */
    Int          band_top;          /* band stack top                      */
d545 1
a545 1
  typedef struct  black_TRaster_
d547 6
a552 1
    void*          memory;
d554 1
a554 1
  } black_TRaster, *black_PRaster;
d558 1
a558 1
  static black_TWorker  cur_ras;
d568 64
d650 1
a650 1
  /*    High :: Set to True for high precision (typically for ppem < 24),  */
a655 22
    /*
     * `precision_step' is used in `Bezier_Up' to decide when to split a
     * given y-monotonous Bezier arc that crosses a scanline before
     * approximating it as a straight segment.  The default value of 32 (for
     * low accuracy) corresponds to
     *
     *   32 / 64 == 0.5 pixels,
     *
     * while for the high accuracy case we have
     *
     *   256 / (1 << 12) = 0.0625 pixels.
     *
     * `precision_jitter' is an epsilon threshold used in
     * `Vertical_Sweep_Span' to deal with small imperfections in the Bezier
     * decomposition (after all, we are working with approximations only);
     * it avoids switching on additional pixels which would cause artifacts
     * otherwise.
     *
     * The value of `precision_jitter' has been determined heuristically.
     *
     */

d660 1
a660 1
      ras.precision_jitter = 30;
d674 1
d709 1
a709 1
      ras.error = FT_THROW( Overflow );
d728 1
a728 1
      FT_TRACE6(( "  new ascending profile = %p\n", ras.cProfile ));
d734 1
a734 1
      FT_TRACE6(( "  new descending profile = %p\n", ras.cProfile ));
d739 1
a739 1
      ras.error = FT_THROW( Invalid );
d772 2
a773 1
    Long  h;
d781 1
a781 1
      ras.error = FT_THROW( Neg_Height );
d787 2
a788 5
      PProfile  oldProfile;


      FT_TRACE6(( "  ending profile %p, start = %ld, height = %ld\n",
                  ras.cProfile, ras.cProfile->start, h ));
d814 1
a814 1
      ras.error = FT_THROW( Overflow );
d843 1
a843 1
    Int    n;
d855 1
a855 1
      do
d857 1
a857 3
        Int  y2 = (Int)y_turns[n];


d860 2
a861 1
      } while ( --n >= 0 );
d868 1
a868 1
        ras.error = FT_THROW( Overflow );
d893 1
d903 1
a903 1
      do
a904 3
        Int  bottom, top;


d928 2
a929 1
      } while ( --n );
d1097 1
a1097 1
        x1 += SMulDiv( Dx, ras.precision - f1, Dy );
d1119 1
a1119 1
      ras.error = FT_THROW( Overflow );
d1125 1
a1125 1
      Ix = SMulDiv_No_Round( ras.precision, Dx, Dy );
d1131 2
a1132 2
      Ix = -SMulDiv_No_Round( ras.precision, -Dx, Dy );
      Rx = ( ras.precision * -Dx ) % Dy;
d1294 1
a1294 1
      ras.error = FT_THROW( Overflow );
d1300 1
a1300 1
    do
d1333 1
a1333 1
    } while ( arc >= start_arc && e <= e2 );
d1564 2
a1565 3
          Bool  o = ( state_bez == Ascending_State )
                      ? IS_BOTTOM_OVERSHOOT( y1 )
                      : IS_TOP_OVERSHOOT( y1 );
d1700 2
a1701 3
          Bool  o = ( state_bez == Ascending_State )
                      ? IS_BOTTOM_OVERSHOOT( y1 )
                      : IS_TOP_OVERSHOOT( y1 );
d1771 1
a1771 1
                            Int     flipped )
d1782 1
a1782 1
    UInt        tag;       /* current point's state           */
d1832 1
a1832 1
     /* v_last = v_start; */
d1934 2
d1941 1
a1945 6
            x3 = SCALED( point[0].x );
            y3 = SCALED( point[0].y );

            if ( flipped )
              SWAP_( x3, y3 );

d1966 1
a1966 1
    ras.error = FT_THROW( Invalid );
d1990 1
a1990 1
  Convert_Glyph( RAS_ARGS Int  flipped )
d1992 4
a1995 2
    Int   i;
    UInt  start;
d2014 1
a2014 2
      PProfile  lastProfile;
      Bool      o;
d2020 2
a2021 2
      if ( Decompose_Curve( RAS_VARS (UShort)start,
                                     (UShort)ras.outline.contours[i],
d2025 1
a2025 1
      start = (UShort)ras.outline.contours[i] + 1;
d2039 1
a2039 2
      if ( ras.top != ras.cProfile->offset &&
           ( ras.cProfile->flags & Flow_Up ) )
d2163 1
a2163 1
      current->offset += ( current->flags & Flow_Up ) ? 1 : -1;
d2223 4
a2226 1
      ras.traceOfs += (Long)( ras.target.rows - 1 ) * pitch;
d2238 2
a2241 2
    Int  dropOutControl = left->flags & 7;

a2246 8
    /* in high-precision mode, we need 12 digits after the comma to */
    /* represent multiples of 1/(1<<12) = 1/4096                    */
    FT_TRACE7(( "  y=%d x=[%.12f;%.12f], drop-out=%d",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision,
                dropOutControl ));

d2251 1
a2251 2
    if ( dropOutControl != 2                             &&
         x2 - x1 - ras.precision <= ras.precision_jitter )
a2257 4
      Int   c1, c2;
      Byte  f1, f2;


a2262 2
      FT_TRACE7(( " -> x=[%d;%d]", e1, e2 ));

d2269 5
a2294 2

    FT_TRACE7(( "\n" ));
a2308 5
    FT_TRACE7(( "  y=%d x=[%.12f;%.12f]",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision ));

a2340 2
      FT_TRACE7(( ", drop-out=%d", dropOutControl ));

d2387 1
a2387 1
            goto Exit;
d2394 1
a2394 1
            goto Exit;
d2403 1
a2403 1
          goto Exit;  /* no drop-out control */
a2405 8
        /* undocumented but confirmed: If the drop-out would result in a  */
        /* pixel outside of the bounding box, use the pixel inside of the */
        /* bounding box instead                                           */
        if ( pxl < 0 )
          pxl = e1;
        else if ( TRUNC( pxl ) >= ras.bWidth )
          pxl = e2;

d2407 1
a2407 1
        e1 = ( pxl == e1 ) ? e2 : e1;
d2416 1
a2416 1
          goto Exit;
d2419 1
a2419 1
        goto Exit;
a2425 2
      FT_TRACE7(( " -> x=%d (drop-out)", e1 ));

d2429 5
a2435 3

  Exit:
    FT_TRACE7(( "\n" ));
d2473 4
a2482 8
      Long  e1, e2;


      FT_TRACE7(( "  x=%d y=[%.12f;%.12f]",
                  y,
                  x1 / (double)ras.precision,
                  x2 / (double)ras.precision ));

d2488 3
d2493 1
a2493 1
        if ( e1 >= 0 && (ULong)e1 < ras.target.rows )
a2494 2
          Byte   f1;
          PByte  bits;
d2498 1
a2498 6
          FT_TRACE7(( " -> y=%d (drop-out)", e1 ));

          bits = ras.bTarget + ( y >> 3 );
          f1   = (Byte)( 0x80 >> ( y & 7 ) );
          p    = bits - e1 * ras.target.pitch;

d2500 1
a2500 1
            p += (Long)( ras.target.rows - 1 ) * ras.target.pitch;
a2504 2

      FT_TRACE7(( "\n" ));
a2520 5
    FT_TRACE7(( "  x=%d y=[%.12f;%.12f]",
                y,
                x1 / (double)ras.precision,
                x2 / (double)ras.precision ));

a2541 2
      FT_TRACE7(( ", dropout=%d", dropOutControl ));

d2563 1
a2563 1
            goto Exit;
d2570 1
a2570 1
            goto Exit;
d2579 1
a2579 1
          goto Exit;  /* no drop-out control */
a2581 8
        /* undocumented but confirmed: If the drop-out would result in a  */
        /* pixel outside of the bounding box, use the pixel inside of the */
        /* bounding box instead                                           */
        if ( pxl < 0 )
          pxl = e1;
        else if ( (ULong)( TRUNC( pxl ) ) >= ras.target.rows )
          pxl = e2;

d2583 1
a2583 1
        e1 = ( pxl == e1 ) ? e2 : e1;
d2592 1
a2592 1
          bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;
d2594 4
a2597 4
        if ( e1 >= 0                     &&
             (ULong)e1 < ras.target.rows &&
             *bits & f1                  )
          goto Exit;
d2600 1
a2600 1
        goto Exit;
d2603 3
d2608 1
a2608 1
    if ( e1 >= 0 && (ULong)e1 < ras.target.rows )
a2609 4
      FT_TRACE7(( " -> y=%d (drop-out)", e1 ));

      bits  = ras.bTarget + ( y >> 3 );
      f1    = (Byte)( 0x80 >> ( y & 7 ) );
a2610 1

d2612 1
a2612 1
        bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;
a2615 3

  Exit:
    FT_TRACE7(( "\n" ));
d2627 237
d2919 1
a2919 1
      ras.error = FT_THROW( Invalid );
d2933 1
a2933 1
      P->countL = P->start - min_Y;
d3160 1
a3160 1
          ras.error    = FT_THROW( Invalid );
d3196 1
a3196 1
  static FT_Error
d3219 2
a3220 2
    ras.second_pass = (Bool)( !( ras.outline.flags      &
                                 FT_OUTLINE_SINGLE_PASS ) );
a3222 2
    FT_TRACE7(( "Vertical pass (ftraster)\n" ));

d3230 1
a3230 1
    ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );
d3232 1
a3232 1
    ras.bWidth  = (UShort)ras.target.width;
a3240 2
      FT_TRACE7(( "Horizontal pass (ftraster)\n" ));

d3248 1
a3248 1
      ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );
d3258 97
d3356 1
a3356 1
  ft_black_init( black_PRaster  raster )
d3358 10
d3369 1
d3377 1
a3377 1
#ifdef STANDALONE_
d3384 1
a3384 2
     static black_TRaster  the_raster;
     FT_UNUSED( memory );
d3388 1
a3388 1
     FT_ZERO( &the_raster );
d3403 1
a3403 1
#else /* !STANDALONE_ */
d3407 2
a3408 2
  ft_black_new( FT_Memory       memory,
                black_PRaster  *araster )
d3410 2
a3411 2
    FT_Error       error;
    black_PRaster  raster = NULL;
d3428 1
a3428 1
  ft_black_done( black_PRaster  raster )
a3430 2


d3435 1
a3435 1
#endif /* !STANDALONE_ */
d3439 3
a3441 3
  ft_black_reset( FT_Raster  raster,
                  PByte      pool_base,
                  ULong      pool_size )
d3443 19
a3461 3
    FT_UNUSED( raster );
    FT_UNUSED( pool_base );
    FT_UNUSED( pool_size );
d3465 19
a3483 5
  static int
  ft_black_set_mode( FT_Raster  raster,
                     ULong      mode,
                     void*      args )
  {
d3486 1
a3486 1
    FT_UNUSED( args );
d3488 1
a3488 1
    return 0;
d3493 1
a3493 1
  ft_black_render( FT_Raster                raster,
d3498 1
a3499 3
    black_TWorker  worker[1];

    Long  buffer[FT_MAX_BLACK_POOL];
d3501 2
a3502 3

    if ( !raster )
      return FT_THROW( Not_Ini );
d3505 1
a3505 1
      return FT_THROW( Invalid );
d3512 1
a3512 1
      return FT_THROW( Invalid );
d3516 3
a3518 1
      return FT_THROW( Invalid );
d3522 1
a3522 4
      return FT_THROW( Unsupported );

    if ( params->flags & FT_RASTER_FLAG_AA )
      return FT_THROW( Unsupported );
d3525 1
a3525 1
      return FT_THROW( Invalid );
d3532 1
a3532 15
      return FT_THROW( Invalid );

    /* reject too large outline coordinates */
    {
      FT_Vector*  vec   = outline->points;
      FT_Vector*  limit = vec + outline->n_points;


      for ( ; vec < limit; vec++ )
      {
        if ( vec->x < -0x1000000L || vec->x > 0x1000000L ||
             vec->y < -0x1000000L || vec->y > 0x1000000L )
         return FT_THROW( Invalid );
      }
    }
d3537 6
a3542 2
    worker->buff     = buffer;
    worker->sizeBuff = (&buffer)[1]; /* Points to right after buffer. */
d3544 6
a3549 1
    return Render_Glyph( RAS_VAR );
d3553 1
a3553 3
  FT_DEFINE_RASTER_FUNCS(
    ft_standard_raster,

d3555 5
a3559 6

    (FT_Raster_New_Func)     ft_black_new,       /* raster_new      */
    (FT_Raster_Reset_Func)   ft_black_reset,     /* raster_reset    */
    (FT_Raster_Set_Mode_Func)ft_black_set_mode,  /* raster_set_mode */
    (FT_Raster_Render_Func)  ft_black_render,    /* raster_render   */
    (FT_Raster_Done_Func)    ft_black_done       /* raster_done     */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
