head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.21.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.47.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.04.51;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.42;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.24;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.02;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.00;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.24;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.06;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftdbgmem.c                                                             */
/*                                                                         */
/*    Memory debugger (body).                                              */
/*                                                                         */
/*  Copyright 2001-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_CONFIG_CONFIG_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_MEMORY_H
#include FT_SYSTEM_H
#include FT_ERRORS_H
#include FT_TYPES_H


#ifdef FT_DEBUG_MEMORY

#define  KEEPALIVE /* `Keep alive' means that freed blocks aren't released
                    * to the heap.  This is useful to detect double-frees
                    * or weird heap corruption, but it uses large amounts of
                    * memory, however.
                    */

#include FT_CONFIG_STANDARD_LIBRARY_H

  FT_BASE_DEF( const char* )  _ft_debug_file   = NULL;
  FT_BASE_DEF( long )         _ft_debug_lineno = 0;

  extern void
  FT_DumpMemory( FT_Memory  memory );


  typedef struct FT_MemSourceRec_*  FT_MemSource;
  typedef struct FT_MemNodeRec_*    FT_MemNode;
  typedef struct FT_MemTableRec_*   FT_MemTable;


#define FT_MEM_VAL( addr )  ( (FT_PtrDist)(FT_Pointer)( addr ) )

  /*
   *  This structure holds statistics for a single allocation/release
   *  site.  This is useful to know where memory operations happen the
   *  most.
   */
  typedef struct  FT_MemSourceRec_
  {
    const char*   file_name;
    long          line_no;

    FT_Long       cur_blocks;   /* current number of allocated blocks */
    FT_Long       max_blocks;   /* max. number of allocated blocks    */
    FT_Long       all_blocks;   /* total number of blocks allocated   */

    FT_Long       cur_size;     /* current cumulative allocated size */
    FT_Long       max_size;     /* maximum cumulative allocated size */
    FT_Long       all_size;     /* total cumulative allocated size   */

    FT_Long       cur_max;      /* current maximum allocated size */

    FT_UInt32     hash;
    FT_MemSource  link;

  } FT_MemSourceRec;


  /*
   *  We don't need a resizable array for the memory sources because
   *  their number is pretty limited within FreeType.
   */
#define FT_MEM_SOURCE_BUCKETS  128

  /*
   *  This structure holds information related to a single allocated
   *  memory block.  If KEEPALIVE is defined, blocks that are freed by
   *  FreeType are never released to the system.  Instead, their `size'
   *  field is set to `-size'.  This is mainly useful to detect double
   *  frees, at the price of a large memory footprint during execution.
   */
  typedef struct  FT_MemNodeRec_
  {
    FT_Byte*      address;
    FT_Long       size;     /* < 0 if the block was freed */

    FT_MemSource  source;

#ifdef KEEPALIVE
    const char*   free_file_name;
    FT_Long       free_line_no;
#endif

    FT_MemNode    link;

  } FT_MemNodeRec;


  /*
   *  The global structure, containing compound statistics and all hash
   *  tables.
   */
  typedef struct  FT_MemTableRec_
  {
    FT_Long          size;
    FT_Long          nodes;
    FT_MemNode*      buckets;

    FT_Long          alloc_total;
    FT_Long          alloc_current;
    FT_Long          alloc_max;
    FT_Long          alloc_count;

    FT_Bool          bound_total;
    FT_Long          alloc_total_max;

    FT_Bool          bound_count;
    FT_Long          alloc_count_max;

    FT_MemSource     sources[FT_MEM_SOURCE_BUCKETS];

    FT_Bool          keep_alive;

    FT_Memory        memory;
    FT_Pointer       memory_user;
    FT_Alloc_Func    alloc;
    FT_Free_Func     free;
    FT_Realloc_Func  realloc;

  } FT_MemTableRec;


#define FT_MEM_SIZE_MIN  7
#define FT_MEM_SIZE_MAX  13845163

#define FT_FILENAME( x )  ( (x) ? (x) : "unknown file" )


  /*
   *  Prime numbers are ugly to handle.  It would be better to implement
   *  L-Hashing, which is 10% faster and doesn't require divisions.
   */
  static const FT_Int  ft_mem_primes[] =
  {
    7,
    11,
    19,
    37,
    73,
    109,
    163,
    251,
    367,
    557,
    823,
    1237,
    1861,
    2777,
    4177,
    6247,
    9371,
    14057,
    21089,
    31627,
    47431,
    71143,
    106721,
    160073,
    240101,
    360163,
    540217,
    810343,
    1215497,
    1823231,
    2734867,
    4102283,
    6153409,
    9230113,
    13845163,
  };


  static FT_Long
  ft_mem_closest_prime( FT_Long  num )
  {
    size_t  i;


    for ( i = 0;
          i < sizeof ( ft_mem_primes ) / sizeof ( ft_mem_primes[0] ); i++ )
      if ( ft_mem_primes[i] > num )
        return ft_mem_primes[i];

    return FT_MEM_SIZE_MAX;
  }


  static void
  ft_mem_debug_panic( const char*  fmt,
                      ... )
  {
    va_list  ap;


    printf( "FreeType.Debug: " );

    va_start( ap, fmt );
    vprintf( fmt, ap );
    va_end( ap );

    printf( "\n" );
    exit( EXIT_FAILURE );
  }


  static FT_Pointer
  ft_mem_table_alloc( FT_MemTable  table,
                      FT_Long      size )
  {
    FT_Memory   memory = table->memory;
    FT_Pointer  block;


    memory->user = table->memory_user;
    block = table->alloc( memory, size );
    memory->user = table;

    return block;
  }


  static void
  ft_mem_table_free( FT_MemTable  table,
                     FT_Pointer   block )
  {
    FT_Memory  memory = table->memory;


    memory->user = table->memory_user;
    table->free( memory, block );
    memory->user = table;
  }


  static void
  ft_mem_table_resize( FT_MemTable  table )
  {
    FT_Long  new_size;


    new_size = ft_mem_closest_prime( table->nodes );
    if ( new_size != table->size )
    {
      FT_MemNode*  new_buckets;
      FT_Long      i;


      new_buckets = (FT_MemNode *)
                      ft_mem_table_alloc(
                        table,
                        new_size * (FT_Long)sizeof ( FT_MemNode ) );
      if ( !new_buckets )
        return;

      FT_ARRAY_ZERO( new_buckets, new_size );

      for ( i = 0; i < table->size; i++ )
      {
        FT_MemNode  node, next, *pnode;
        FT_PtrDist  hash;


        node = table->buckets[i];
        while ( node )
        {
          next  = node->link;
          hash  = FT_MEM_VAL( node->address ) % (FT_PtrDist)new_size;
          pnode = new_buckets + hash;

          node->link = pnode[0];
          pnode[0]   = node;

          node = next;
        }
      }

      if ( table->buckets )
        ft_mem_table_free( table, table->buckets );

      table->buckets = new_buckets;
      table->size    = new_size;
    }
  }


  static FT_MemTable
  ft_mem_table_new( FT_Memory  memory )
  {
    FT_MemTable  table;


    table = (FT_MemTable)memory->alloc( memory, sizeof ( *table ) );
    if ( !table )
      goto Exit;

    FT_ZERO( table );

    table->size  = FT_MEM_SIZE_MIN;
    table->nodes = 0;

    table->memory = memory;

    table->memory_user = memory->user;

    table->alloc   = memory->alloc;
    table->realloc = memory->realloc;
    table->free    = memory->free;

    table->buckets = (FT_MemNode *)
                       memory->alloc(
                         memory,
                         table->size * (FT_Long)sizeof ( FT_MemNode ) );
    if ( table->buckets )
      FT_ARRAY_ZERO( table->buckets, table->size );
    else
    {
      memory->free( memory, table );
      table = NULL;
    }

  Exit:
    return table;
  }


  static void
  ft_mem_table_destroy( FT_MemTable  table )
  {
    FT_Long  i;
    FT_Long  leak_count = 0;
    FT_Long  leaks      = 0;


    FT_DumpMemory( table->memory );

    /* remove all blocks from the table, revealing leaked ones */
    for ( i = 0; i < table->size; i++ )
    {
      FT_MemNode  *pnode = table->buckets + i, next, node = *pnode;


      while ( node )
      {
        next       = node->link;
        node->link = NULL;

        if ( node->size > 0 )
        {
          printf(
            "leaked memory block at address %p, size %8ld in (%s:%ld)\n",
            (void*)node->address,
            node->size,
            FT_FILENAME( node->source->file_name ),
            node->source->line_no );

          leak_count++;
          leaks += node->size;

          ft_mem_table_free( table, node->address );
        }

        node->address = NULL;
        node->size    = 0;

        ft_mem_table_free( table, node );
        node = next;
      }
      table->buckets[i] = NULL;
    }

    ft_mem_table_free( table, table->buckets );
    table->buckets = NULL;

    table->size  = 0;
    table->nodes = 0;

    /* remove all sources */
    for ( i = 0; i < FT_MEM_SOURCE_BUCKETS; i++ )
    {
      FT_MemSource  source, next;


      for ( source = table->sources[i]; source != NULL; source = next )
      {
        next = source->link;
        ft_mem_table_free( table, source );
      }

      table->sources[i] = NULL;
    }

    printf( "FreeType: total memory allocations = %ld\n",
            table->alloc_total );
    printf( "FreeType: maximum memory footprint = %ld\n",
            table->alloc_max );

    ft_mem_table_free( table, table );

    if ( leak_count > 0 )
      ft_mem_debug_panic(
        "FreeType: %ld bytes of memory leaked in %ld blocks\n",
        leaks, leak_count );

    printf( "FreeType: no memory leaks detected\n" );
  }


  static FT_MemNode*
  ft_mem_table_get_nodep( FT_MemTable  table,
                          FT_Byte*     address )
  {
    FT_PtrDist   hash;
    FT_MemNode  *pnode, node;


    hash  = FT_MEM_VAL( address );
    pnode = table->buckets + ( hash % (FT_PtrDist)table->size );

    for (;;)
    {
      node = pnode[0];
      if ( !node )
        break;

      if ( node->address == address )
        break;

      pnode = &node->link;
    }
    return pnode;
  }


  static FT_MemSource
  ft_mem_table_get_source( FT_MemTable  table )
  {
    FT_UInt32     hash;
    FT_MemSource  node, *pnode;


    /* cast to FT_PtrDist first since void* can be larger */
    /* than FT_UInt32 and GCC 4.1.1 emits a warning       */
    hash  = (FT_UInt32)(FT_PtrDist)(void*)_ft_debug_file +
              (FT_UInt32)( 5 * _ft_debug_lineno );
    pnode = &table->sources[hash % FT_MEM_SOURCE_BUCKETS];

    for (;;)
    {
      node = *pnode;
      if ( !node )
        break;

      if ( node->file_name == _ft_debug_file   &&
           node->line_no   == _ft_debug_lineno )
        goto Exit;

      pnode = &node->link;
    }

    node = (FT_MemSource)ft_mem_table_alloc( table, sizeof ( *node ) );
    if ( !node )
      ft_mem_debug_panic(
        "not enough memory to perform memory debugging\n" );

    node->file_name = _ft_debug_file;
    node->line_no   = _ft_debug_lineno;

    node->cur_blocks = 0;
    node->max_blocks = 0;
    node->all_blocks = 0;

    node->cur_size = 0;
    node->max_size = 0;
    node->all_size = 0;

    node->cur_max = 0;

    node->link = NULL;
    node->hash = hash;
    *pnode     = node;

  Exit:
    return node;
  }


  static void
  ft_mem_table_set( FT_MemTable  table,
                    FT_Byte*     address,
                    FT_Long      size,
                    FT_Long      delta )
  {
    FT_MemNode  *pnode, node;


    if ( table )
    {
      FT_MemSource  source;


      pnode = ft_mem_table_get_nodep( table, address );
      node  = *pnode;
      if ( node )
      {
        if ( node->size < 0 )
        {
          /* This block was already freed.  Our memory is now completely */
          /* corrupted!                                                  */
          /* This can only happen in keep-alive mode.                    */
          ft_mem_debug_panic(
            "memory heap corrupted (allocating freed block)" );
        }
        else
        {
          /* This block was already allocated.  This means that our memory */
          /* is also corrupted!                                            */
          ft_mem_debug_panic(
            "memory heap corrupted (re-allocating allocated block at"
            " %p, of size %ld)\n"
            "org=%s:%d new=%s:%d\n",
            node->address, node->size,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
        }
      }

      /* we need to create a new node in this table */
      node = (FT_MemNode)ft_mem_table_alloc( table, sizeof ( *node ) );
      if ( !node )
        ft_mem_debug_panic( "not enough memory to run memory tests" );

      node->address = address;
      node->size    = size;
      node->source  = source = ft_mem_table_get_source( table );

      if ( delta == 0 )
      {
        /* this is an allocation */
        source->all_blocks++;
        source->cur_blocks++;
        if ( source->cur_blocks > source->max_blocks )
          source->max_blocks = source->cur_blocks;
      }

      if ( size > source->cur_max )
        source->cur_max = size;

      if ( delta != 0 )
      {
        /* we are growing or shrinking a reallocated block */
        source->cur_size     += delta;
        table->alloc_current += delta;
      }
      else
      {
        /* we are allocating a new block */
        source->cur_size     += size;
        table->alloc_current += size;
      }

      source->all_size += size;

      if ( source->cur_size > source->max_size )
        source->max_size = source->cur_size;

      node->free_file_name = NULL;
      node->free_line_no   = 0;

      node->link = pnode[0];

      pnode[0] = node;
      table->nodes++;

      table->alloc_total += size;

      if ( table->alloc_current > table->alloc_max )
        table->alloc_max = table->alloc_current;

      if ( table->nodes * 3 < table->size  ||
           table->size  * 3 < table->nodes )
        ft_mem_table_resize( table );
    }
  }


  static void
  ft_mem_table_remove( FT_MemTable  table,
                       FT_Byte*     address,
                       FT_Long      delta )
  {
    if ( table )
    {
      FT_MemNode  *pnode, node;


      pnode = ft_mem_table_get_nodep( table, address );
      node  = *pnode;
      if ( node )
      {
        FT_MemSource  source;


        if ( node->size < 0 )
          ft_mem_debug_panic(
            "freeing memory block at %p more than once at (%s:%ld)\n"
            "block allocated at (%s:%ld) and released at (%s:%ld)",
            address,
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
            FT_FILENAME( node->free_file_name ), node->free_line_no );

        /* scramble the node's content for additional safety */
        FT_MEM_SET( address, 0xF3, node->size );

        if ( delta == 0 )
        {
          source = node->source;

          source->cur_blocks--;
          source->cur_size -= node->size;

          table->alloc_current -= node->size;
        }

        if ( table->keep_alive )
        {
          /* we simply invert the node's size to indicate that the node */
          /* was freed.                                                 */
          node->size           = -node->size;
          node->free_file_name = _ft_debug_file;
          node->free_line_no   = _ft_debug_lineno;
        }
        else
        {
          table->nodes--;

          *pnode = node->link;

          node->size   = 0;
          node->source = NULL;

          ft_mem_table_free( table, node );

          if ( table->nodes * 3 < table->size  ||
               table->size  * 3 < table->nodes )
            ft_mem_table_resize( table );
        }
      }
      else
        ft_mem_debug_panic(
          "trying to free unknown block at %p in (%s:%ld)\n",
          address,
          FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
    }
  }


  static FT_Pointer
  ft_mem_debug_alloc( FT_Memory  memory,
                      FT_Long    size )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;
    FT_Byte*     block;


    if ( size <= 0 )
      ft_mem_debug_panic( "negative block size allocation (%ld)", size );

    /* return NULL if the maximum number of allocations was reached */
    if ( table->bound_count                           &&
         table->alloc_count >= table->alloc_count_max )
      return NULL;

    /* return NULL if this allocation would overflow the maximum heap size */
    if ( table->bound_total                                   &&
         table->alloc_total_max - table->alloc_current > size )
      return NULL;

    block = (FT_Byte *)ft_mem_table_alloc( table, size );
    if ( block )
    {
      ft_mem_table_set( table, block, size, 0 );

      table->alloc_count++;
    }

    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;

    return (FT_Pointer)block;
  }


  static void
  ft_mem_debug_free( FT_Memory   memory,
                     FT_Pointer  block )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;


    if ( !block )
      ft_mem_debug_panic( "trying to free NULL in (%s:%ld)",
                          FT_FILENAME( _ft_debug_file ),
                          _ft_debug_lineno );

    ft_mem_table_remove( table, (FT_Byte*)block, 0 );

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );

    table->alloc_count--;

    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;
  }


  static FT_Pointer
  ft_mem_debug_realloc( FT_Memory   memory,
                        FT_Long     cur_size,
                        FT_Long     new_size,
                        FT_Pointer  block )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;
    FT_MemNode   node, *pnode;
    FT_Pointer   new_block;
    FT_Long      delta;

    const char*  file_name = FT_FILENAME( _ft_debug_file );
    FT_Long      line_no   = _ft_debug_lineno;


    /* unlikely, but possible */
    if ( new_size == cur_size )
      return block;

    /* the following is valid according to ANSI C */
#if 0
    if ( !block || !cur_size )
      ft_mem_debug_panic( "trying to reallocate NULL in (%s:%ld)",
                          file_name, line_no );
#endif

    /* while the following is allowed in ANSI C also, we abort since */
    /* such case should be handled by FreeType.                      */
    if ( new_size <= 0 )
      ft_mem_debug_panic(
        "trying to reallocate %p to size 0 (current is %ld) in (%s:%ld)",
        block, cur_size, file_name, line_no );

    /* check `cur_size' value */
    pnode = ft_mem_table_get_nodep( table, (FT_Byte*)block );
    node  = *pnode;
    if ( !node )
      ft_mem_debug_panic(
        "trying to reallocate unknown block at %p in (%s:%ld)",
        block, file_name, line_no );

    if ( node->size <= 0 )
      ft_mem_debug_panic(
        "trying to reallocate freed block at %p in (%s:%ld)",
        block, file_name, line_no );

    if ( node->size != cur_size )
      ft_mem_debug_panic( "invalid ft_realloc request for %p. cur_size is "
                          "%ld instead of %ld in (%s:%ld)",
                          block, cur_size, node->size, file_name, line_no );

    /* return NULL if the maximum number of allocations was reached */
    if ( table->bound_count                           &&
         table->alloc_count >= table->alloc_count_max )
      return NULL;

    delta = new_size - cur_size;

    /* return NULL if this allocation would overflow the maximum heap size */
    if ( delta > 0                                             &&
         table->bound_total                                    &&
         table->alloc_current + delta > table->alloc_total_max )
      return NULL;

    new_block = (FT_Pointer)ft_mem_table_alloc( table, new_size );
    if ( !new_block )
      return NULL;

    ft_mem_table_set( table, (FT_Byte*)new_block, new_size, delta );

    ft_memcpy( new_block, block, cur_size < new_size ? (size_t)cur_size
                                                     : (size_t)new_size );

    ft_mem_table_remove( table, (FT_Byte*)block, delta );

    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );

    return new_block;
  }


  extern FT_Int
  ft_mem_debug_init( FT_Memory  memory )
  {
    FT_MemTable  table;
    FT_Int       result = 0;


    if ( getenv( "FT2_DEBUG_MEMORY" ) )
    {
      table = ft_mem_table_new( memory );
      if ( table )
      {
        const char*  p;


        memory->user    = table;
        memory->alloc   = ft_mem_debug_alloc;
        memory->realloc = ft_mem_debug_realloc;
        memory->free    = ft_mem_debug_free;

        p = getenv( "FT2_ALLOC_TOTAL_MAX" );
        if ( p )
        {
          FT_Long  total_max = ft_strtol( p, NULL, 10 );


          if ( total_max > 0 )
          {
            table->bound_total     = 1;
            table->alloc_total_max = total_max;
          }
        }

        p = getenv( "FT2_ALLOC_COUNT_MAX" );
        if ( p )
        {
          FT_Long  total_count = ft_strtol( p, NULL, 10 );


          if ( total_count > 0 )
          {
            table->bound_count     = 1;
            table->alloc_count_max = total_count;
          }
        }

        p = getenv( "FT2_KEEP_ALIVE" );
        if ( p )
        {
          FT_Long  keep_alive = ft_strtol( p, NULL, 10 );


          if ( keep_alive > 0 )
            table->keep_alive = 1;
        }

        result = 1;
      }
    }
    return result;
  }


  extern void
  ft_mem_debug_done( FT_Memory  memory )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;


    if ( table )
    {
      memory->free    = table->free;
      memory->realloc = table->realloc;
      memory->alloc   = table->alloc;

      ft_mem_table_destroy( table );
      memory->user = NULL;
    }
  }


  static int
  ft_mem_source_compare( const void*  p1,
                         const void*  p2 )
  {
    FT_MemSource  s1 = *(FT_MemSource*)p1;
    FT_MemSource  s2 = *(FT_MemSource*)p2;


    if ( s2->max_size > s1->max_size )
      return 1;
    else if ( s2->max_size < s1->max_size )
      return -1;
    else
      return 0;
  }


  extern void
  FT_DumpMemory( FT_Memory  memory )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;


    if ( table )
    {
      FT_MemSource*  bucket = table->sources;
      FT_MemSource*  limit  = bucket + FT_MEM_SOURCE_BUCKETS;
      FT_MemSource*  sources;
      FT_Int         nn, count;
      const char*    fmt;


      count = 0;
      for ( ; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;


        for ( ; source; source = source->link )
          count++;
      }

      sources = (FT_MemSource*)
                  ft_mem_table_alloc(
                    table, count * (FT_Long)sizeof ( *sources ) );

      count = 0;
      for ( bucket = table->sources; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;


        for ( ; source; source = source->link )
          sources[count++] = source;
      }

      ft_qsort( sources,
                (size_t)count,
                sizeof ( *sources ),
                ft_mem_source_compare );

      printf( "FreeType Memory Dump: "
              "current=%ld max=%ld total=%ld count=%ld\n",
              table->alloc_current, table->alloc_max,
              table->alloc_total, table->alloc_count );
      printf( " block  block    sizes    sizes    sizes   source\n" );
      printf( " count   high      sum  highsum      max   location\n" );
      printf( "-------------------------------------------------\n" );

      fmt = "%6ld %6ld %8ld %8ld %8ld %s:%d\n";

      for ( nn = 0; nn < count; nn++ )
      {
        FT_MemSource  source = sources[nn];


        printf( fmt,
                source->cur_blocks, source->max_blocks,
                source->cur_size, source->max_size, source->cur_max,
                FT_FILENAME( source->file_name ),
                source->line_no );
      }
      printf( "------------------------------------------------\n" );

      ft_mem_table_free( table, sources );
    }
  }

#else  /* !FT_DEBUG_MEMORY */

  /* ANSI C doesn't like empty source files */
  typedef int  _debug_mem_dummy;

#endif /* !FT_DEBUG_MEMORY */


/* END */
@


1.4
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2009 by                  */
d38 1
a38 1
  FT_BASE_DEF( const char* )  _ft_debug_file   = 0;
d50 1
a50 1
#define FT_MEM_VAL( addr )  ((FT_ULong)(FT_Pointer)( addr ))
d79 1
a79 1
   *  We don't need a resizable array for the memory sources, because
d88 2
a89 2
   *  field is set to -size.  This is mainly useful to detect double frees,
   *  at the price of large memory footprint during execution.
d114 2
a115 2
    FT_ULong         size;
    FT_ULong         nodes;
d118 4
a121 4
    FT_ULong         alloc_total;
    FT_ULong         alloc_current;
    FT_ULong         alloc_max;
    FT_ULong         alloc_count;
d124 1
a124 1
    FT_ULong         alloc_total_max;
d127 1
a127 1
    FT_ULong         alloc_count_max;
d145 1
a145 1
#define FT_FILENAME( x )  ((x) ? (x) : "unknown file")
d152 1
a152 1
  static const FT_UInt  ft_mem_primes[] =
d192 2
a193 2
  static FT_ULong
  ft_mem_closest_prime( FT_ULong  num )
d195 1
a195 1
    FT_UInt  i;
d207 1
a207 1
  extern void
d257 1
a257 1
    FT_ULong  new_size;
d264 1
a264 1
      FT_ULong     i;
d268 4
a271 3
                      ft_mem_table_alloc( table,
                                          new_size * sizeof ( FT_MemNode ) );
      if ( new_buckets == NULL )
d279 1
a279 1
        FT_ULong    hash;
d286 1
a286 1
          hash  = FT_MEM_VAL( node->address ) % new_size;
d312 1
a312 1
    if ( table == NULL )
d329 3
a331 2
                       memory->alloc( memory,
                                      table->size * sizeof ( FT_MemNode ) );
d348 3
a350 1
    FT_ULong  i;
d355 2
a356 1
    if ( table )
d358 1
a358 2
      FT_Long   leak_count = 0;
      FT_ULong  leaks      = 0;
d361 1
a361 2
      /* remove all blocks from the table, revealing leaked ones */
      for ( i = 0; i < table->size; i++ )
d363 2
a364 2
        FT_MemNode  *pnode = table->buckets + i, next, node = *pnode;

d366 1
a366 1
        while ( node )
d368 6
a373 10
          next       = node->link;
          node->link = 0;

          if ( node->size > 0 )
          {
            printf(
              "leaked memory block at address %p, size %8ld in (%s:%ld)\n",
              node->address, node->size,
              FT_FILENAME( node->source->file_name ),
              node->source->line_no );
d375 2
a376 2
            leak_count++;
            leaks += node->size;
d378 2
a379 2
            ft_mem_table_free( table, node->address );
          }
d381 2
a382 2
          node->address = NULL;
          node->size    = 0;
d384 2
a385 4
          ft_mem_table_free( table, node );
          node = next;
        }
        table->buckets[i] = 0;
d387 2
d390 2
a391 2
      ft_mem_table_free( table, table->buckets );
      table->buckets = NULL;
d393 2
a394 2
      table->size  = 0;
      table->nodes = 0;
d396 4
a399 4
      /* remove all sources */
      for ( i = 0; i < FT_MEM_SOURCE_BUCKETS; i++ )
      {
        FT_MemSource  source, next;
d402 5
a406 5
        for ( source = table->sources[i]; source != NULL; source = next )
        {
          next = source->link;
          ft_mem_table_free( table, source );
        }
d408 2
a409 2
        table->sources[i] = NULL;
      }
d411 4
a414 4
      printf(
        "FreeType: total memory allocations = %ld\n", table->alloc_total );
      printf(
        "FreeType: maximum memory footprint = %ld\n", table->alloc_max );
d416 1
a416 1
      ft_mem_table_free( table, table );
d418 4
a421 4
      if ( leak_count > 0 )
        ft_mem_debug_panic(
          "FreeType: %ld bytes of memory leaked in %ld blocks\n",
          leaks, leak_count );
d423 1
a423 2
      printf( "FreeType: no memory leaks detected\n" );
    }
d431 1
a431 1
    FT_ULong     hash;
d436 1
a436 1
    pnode = table->buckets + ( hash % table->size );
d466 1
a466 1
    for ( ;; )
d469 1
a469 1
      if ( node == NULL )
d472 2
a473 2
      if ( node->file_name == _ft_debug_file &&
           node->line_no   == _ft_debug_lineno   )
d480 1
a480 1
    if ( node == NULL )
d491 3
a493 3
    node->cur_size   = 0;
    node->max_size   = 0;
    node->all_size   = 0;
d495 1
a495 1
    node->cur_max    = 0;
d509 1
a509 1
                    FT_ULong     size,
d548 1
a548 1
      if ( node == NULL )
d564 1
a564 1
      if ( size > (FT_ULong)source->cur_max )
d677 1
a677 1
  extern FT_Pointer
d694 2
a695 2
    if ( table->bound_total                                             &&
         table->alloc_total_max - table->alloc_current > (FT_ULong)size )
d701 1
a701 1
      ft_mem_table_set( table, block, (FT_ULong)size, 0 );
d713 1
a713 1
  extern void
d720 1
a720 1
    if ( block == NULL )
d737 1
a737 1
  extern FT_Pointer
d758 1
a758 1
    if ( block == NULL || cur_size == 0 )
d793 1
a793 1
    delta = (FT_Long)( new_size - cur_size );
d796 3
a798 3
    if ( delta > 0                                                       &&
         table->bound_total                                              &&
         table->alloc_current + (FT_ULong)delta > table->alloc_total_max )
d801 2
a802 2
    new_block = (FT_Byte *)ft_mem_table_alloc( table, new_size );
    if ( new_block == NULL )
d807 2
a808 1
    ft_memcpy( new_block, block, cur_size < new_size ? cur_size : new_size );
d843 1
a843 1
        if ( p != NULL )
d845 1
a845 1
          FT_Long   total_max = ft_atol( p );
d851 1
a851 1
            table->alloc_total_max = (FT_ULong)total_max;
d856 1
a856 1
        if ( p != NULL )
d858 1
a858 1
          FT_Long  total_count = ft_atol( p );
d864 1
a864 1
            table->alloc_count_max = (FT_ULong)total_count;
d869 1
a869 1
        if ( p != NULL )
d871 1
a871 1
          FT_Long  keep_alive = ft_atol( p );
a902 1

d931 1
a931 1
      FT_UInt        nn, count;
d945 3
a947 2
      sources = (FT_MemSource*)ft_mem_table_alloc(
                                 table, sizeof ( *sources ) * count );
d959 4
a962 1
      ft_qsort( sources, count, sizeof ( *sources ), ft_mem_source_compare );
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006 by                        */
d36 1
a36 2
#include <stdio.h>
#include <stdlib.h>
d424 1
a424 1
      printf( "FreeType: No memory leaks detected!\n" );
d992 1
a992 1
  const FT_Byte  _debug_mem_dummy = 0;
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d463 3
a465 1
    hash  = (FT_UInt32)(void*)_ft_debug_file +
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004 by                                    */
d30 5
d39 10
a49 2
  typedef struct FT_MemNodeRec_*   FT_MemNode;
  typedef struct FT_MemTableRec_*  FT_MemTable;
d53 39
d94 2
a95 2
    FT_Byte*     address;
    FT_Long      size;     /* < 0 if the block was freed */
d97 1
a97 2
    const char*  alloc_file_name;
    FT_Long      alloc_line_no;
d99 4
a102 2
    const char*  free_file_name;
    FT_Long      free_line_no;
d104 1
a104 1
    FT_MemNode   link;
d109 4
d124 1
a124 1
    FT_Bool          bound_total;    
d126 1
a126 1
    
d130 3
a132 2
    const char*      file_name;
    FT_Long          line_no;
d149 4
d193 14
d209 2
a210 1
  ft_mem_debug_panic( const char*  fmt, ... )
a225 15
  static FT_ULong
  ft_mem_closest_prime( FT_ULong  num )
  {
    FT_UInt  i;


    for ( i = 0;
          i < sizeof ( ft_mem_primes ) / sizeof ( ft_mem_primes[0] ); i++ )
      if ( ft_mem_primes[i] > num )
        return ft_mem_primes[i];

    return FT_MEM_SIZE_MAX;
  }


d238 1
a238 1
   return block;
d264 1
a264 1
      FT_MemNode*  new_buckets ;
d269 2
a270 2
                    ft_mem_table_alloc( table,
                                        new_size * sizeof ( FT_MemNode ) );
d274 1
a274 1
      FT_MEM_ZERO( new_buckets, sizeof ( FT_MemNode ) * new_size );
d315 1
a315 1
    FT_MEM_ZERO( table, sizeof ( *table ) );
d329 2
a330 2
                     memory->alloc( memory,
                                    table->size * sizeof ( FT_MemNode ) );
d332 1
a332 1
      FT_MEM_ZERO( table->buckets, sizeof ( FT_MemNode ) * table->size );
d350 2
d354 2
a355 2
      FT_Long    leak_count = 0;
      FT_ULong   leaks = 0;
d358 1
d374 2
a375 2
              FT_FILENAME( node->alloc_file_name ),
              node->alloc_line_no );
d386 1
a386 1
          free( node );
d391 1
d395 17
a411 2
      table->size   = 0;
      table->nodes  = 0;
d418 1
a418 1
      free( table );
d424 1
d456 51
d510 2
a511 1
                    FT_ULong     size )
d518 3
d527 3
a529 2
          /* this block was already freed.  This means that our memory is */
          /* now completely corrupted!                                    */
d535 1
a535 1
          /* this block was already allocated.  This means that our memory */
d538 6
a543 1
            "memory heap corrupted (re-allocating allocated block)" );
d554 26
d581 4
a584 2
      node->alloc_file_name = table->file_name;
      node->alloc_line_no   = table->line_no;
d594 2
a595 2
      table->alloc_total   += size;
      table->alloc_current += size;
d608 2
a609 1
                       FT_Byte*     address )
d620 3
d628 2
a629 2
            FT_FILENAME( table->file_name ), table->line_no,
            FT_FILENAME( node->alloc_file_name ), node->alloc_line_no,
d632 1
a632 2
        /* we simply invert the node's size to indicate that the node */
        /* was freed.  We also change its contents.                   */
d635 33
a667 4
        table->alloc_current -= node->size;
        node->size            = -node->size;
        node->free_file_name  = table->file_name;
        node->free_line_no    = table->line_no;
d673 1
a673 1
          FT_FILENAME( table->file_name ), table->line_no );
d690 1
a690 1
    if ( table->bound_count &&
d695 3
a697 3
    if ( table->bound_total && 
         table->alloc_current + (FT_ULong)size > table->alloc_total_max )
      return NULL;         
d701 2
a702 1
      ft_mem_table_set( table, block, (FT_ULong)size );
d704 2
a705 1
    table->alloc_count++;
d707 2
a708 2
    table->file_name = NULL;
    table->line_no   = 0;
d710 1
a710 1
    return (FT_Pointer) block;
d723 7
a729 2
                          FT_FILENAME( table->file_name ),
                          table->line_no );
d731 1
a731 1
    ft_mem_table_remove( table, (FT_Byte*)block );
d733 2
a734 3
    /* we never really free the block */
    table->file_name = NULL;
    table->line_no   = 0;
d747 1
d749 2
a750 2
    const char*  file_name = FT_FILENAME( table->file_name );
    FT_Long      line_no   = table->line_no;
d753 6
d761 2
a762 1
                           file_name, line_no );
d764 2
d771 1
a771 1
    /* check 'cur_size' value */
d789 14
a802 1
    new_block = ft_mem_debug_alloc( memory, new_size );
d806 2
d810 1
a810 2
    table->file_name = file_name;
    table->line_no   = line_no;
d812 5
a816 1
    ft_mem_debug_free( memory, (FT_Byte*)block );
d835 2
a836 1
        
d841 1
a841 1
        
d845 3
a847 2
          FT_Long   total_max = ft_atol(p);
          
d851 1
a851 1
            table->alloc_total_max = (FT_ULong) total_max;
d854 1
a854 1
        
d858 3
a860 2
          FT_Long  total_count = ft_atol(p);
          
d864 1
a864 1
            table->alloc_count_max = (FT_ULong) total_count;
d868 10
d903 7
a909 8
  FT_BASE_DEF( FT_Error )
  FT_Alloc_Debug( FT_Memory    memory,
                  FT_Long      size,
                  void*       *P,
                  const char*  file_name,
                  FT_Long      line_no )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;
d912 6
a917 6
    if ( table )
    {
      table->file_name = file_name;
      table->line_no   = line_no;
    }
    return FT_Alloc( memory, size, P );
d921 2
a922 7
  FT_BASE_DEF( FT_Error )
  FT_Realloc_Debug( FT_Memory    memory,
                    FT_Long      current,
                    FT_Long      size,
                    void*       *P,
                    const char*  file_name,
                    FT_Long      line_no )
d929 39
a967 5
      table->file_name = file_name;
      table->line_no   = line_no;
    }
    return FT_Realloc( memory, current, size, P );
  }
d969 5
a974 7
  FT_BASE_DEF( void )
  FT_Free_Debug( FT_Memory    memory,
                 FT_Pointer   block,
                 const char*  file_name,
                 FT_Long      line_no )
  {
    FT_MemTable  table = (FT_MemTable)memory->user;
d976 7
d984 1
a984 4
    if ( table )
    {
      table->file_name = file_name;
      table->line_no   = line_no;
a985 1
    FT_Free( memory, (void **)block );
a987 1

@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006 by                        */
a29 5
#define  KEEPALIVE /* `Keep alive' means that freed blocks aren't released
                    * to the heap.  This is useful to detect double-frees
                    * or weird heap corruption, but it uses large amounts of
                    * memory, however.
                    */
a33 10
  FT_BASE_DEF( const char* )  _ft_debug_file   = 0;
  FT_BASE_DEF( long )         _ft_debug_lineno = 0;

  extern void
  FT_DumpMemory( FT_Memory  memory );


  typedef struct FT_MemSourceRec_*  FT_MemSource;
  typedef struct FT_MemNodeRec_*    FT_MemNode;
  typedef struct FT_MemTableRec_*   FT_MemTable;
d35 2
a39 39
  /*
   *  This structure holds statistics for a single allocation/release
   *  site.  This is useful to know where memory operations happen the
   *  most.
   */
  typedef struct  FT_MemSourceRec_
  {
    const char*   file_name;
    long          line_no;

    FT_Long       cur_blocks;   /* current number of allocated blocks */
    FT_Long       max_blocks;   /* max. number of allocated blocks    */
    FT_Long       all_blocks;   /* total number of blocks allocated   */

    FT_Long       cur_size;     /* current cumulative allocated size */
    FT_Long       max_size;     /* maximum cumulative allocated size */
    FT_Long       all_size;     /* total cumulative allocated size   */

    FT_Long       cur_max;      /* current maximum allocated size */

    FT_UInt32     hash;
    FT_MemSource  link;

  } FT_MemSourceRec;


  /*
   *  We don't need a resizable array for the memory sources, because
   *  their number is pretty limited within FreeType.
   */
#define FT_MEM_SOURCE_BUCKETS  128

  /*
   *  This structure holds information related to a single allocated
   *  memory block.  If KEEPALIVE is defined, blocks that are freed by
   *  FreeType are never released to the system.  Instead, their `size'
   *  field is set to -size.  This is mainly useful to detect double frees,
   *  at the price of large memory footprint during execution.
   */
d42 2
a43 2
    FT_Byte*      address;
    FT_Long       size;     /* < 0 if the block was freed */
d45 2
a46 1
    FT_MemSource  source;
d48 2
a49 4
#ifdef KEEPALIVE
    const char*   free_file_name;
    FT_Long       free_line_no;
#endif
d51 1
a51 1
    FT_MemNode    link;
a55 4
  /*
   *  The global structure, containing compound statistics and all hash
   *  tables.
   */
d67 1
a67 1
    FT_Bool          bound_total;
d69 1
a69 1

d73 2
a74 3
    FT_MemSource     sources[FT_MEM_SOURCE_BUCKETS];

    FT_Bool          keep_alive;
a90 4
  /*
   *  Prime numbers are ugly to handle.  It would be better to implement
   *  L-Hashing, which is 10% faster and doesn't require divisions.
   */
a130 14
  static FT_ULong
  ft_mem_closest_prime( FT_ULong  num )
  {
    FT_UInt  i;


    for ( i = 0;
          i < sizeof ( ft_mem_primes ) / sizeof ( ft_mem_primes[0] ); i++ )
      if ( ft_mem_primes[i] > num )
        return ft_mem_primes[i];

    return FT_MEM_SIZE_MAX;
  }

d133 1
a133 2
  ft_mem_debug_panic( const char*  fmt,
                      ... )
d149 15
d176 1
a176 1
    return block;
d202 1
a202 1
      FT_MemNode*  new_buckets;
d207 2
a208 2
                      ft_mem_table_alloc( table,
                                          new_size * sizeof ( FT_MemNode ) );
d212 1
a212 1
      FT_ARRAY_ZERO( new_buckets, new_size );
d253 1
a253 1
    FT_ZERO( table );
d267 2
a268 2
                       memory->alloc( memory,
                                      table->size * sizeof ( FT_MemNode ) );
d270 1
a270 1
      FT_ARRAY_ZERO( table->buckets, table->size );
a287 2
    FT_DumpMemory( table->memory );

d290 2
a291 2
      FT_Long   leak_count = 0;
      FT_ULong  leaks      = 0;
a293 1
      /* remove all blocks from the table, revealing leaked ones */
d309 2
a310 2
              FT_FILENAME( node->source->file_name ),
              node->source->line_no );
d321 1
a321 1
          ft_mem_table_free( table, node );
a325 1

d329 2
a330 17
      table->size  = 0;
      table->nodes = 0;

      /* remove all sources */
      for ( i = 0; i < FT_MEM_SOURCE_BUCKETS; i++ )
      {
        FT_MemSource  source, next;


        for ( source = table->sources[i]; source != NULL; source = next )
        {
          next = source->link;
          ft_mem_table_free( table, source );
        }

        table->sources[i] = NULL;
      }
d337 1
a337 1
      ft_mem_table_free( table, table );
a342 1

a373 53
  static FT_MemSource
  ft_mem_table_get_source( FT_MemTable  table )
  {
    FT_UInt32     hash;
    FT_MemSource  node, *pnode;


    /* cast to FT_PtrDist first since void* can be larger */
    /* than FT_UInt32 and GCC 4.1.1 emits a warning       */
    hash  = (FT_UInt32)(FT_PtrDist)(void*)_ft_debug_file +
              (FT_UInt32)( 5 * _ft_debug_lineno );
    pnode = &table->sources[hash % FT_MEM_SOURCE_BUCKETS];

    for ( ;; )
    {
      node = *pnode;
      if ( node == NULL )
        break;

      if ( node->file_name == _ft_debug_file &&
           node->line_no   == _ft_debug_lineno   )
        goto Exit;

      pnode = &node->link;
    }

    node = (FT_MemSource)ft_mem_table_alloc( table, sizeof ( *node ) );
    if ( node == NULL )
      ft_mem_debug_panic(
        "not enough memory to perform memory debugging\n" );

    node->file_name = _ft_debug_file;
    node->line_no   = _ft_debug_lineno;

    node->cur_blocks = 0;
    node->max_blocks = 0;
    node->all_blocks = 0;

    node->cur_size   = 0;
    node->max_size   = 0;
    node->all_size   = 0;

    node->cur_max    = 0;

    node->link = NULL;
    node->hash = hash;
    *pnode     = node;

  Exit:
    return node;
  }


d377 1
a377 2
                    FT_ULong     size,
                    FT_Long      delta )
a383 3
      FT_MemSource  source;


d390 2
a391 3
          /* This block was already freed.  Our memory is now completely */
          /* corrupted!                                                  */
          /* This can only happen in keep-alive mode.                    */
d397 1
a397 1
          /* This block was already allocated.  This means that our memory */
d400 1
a400 6
            "memory heap corrupted (re-allocating allocated block at"
            " %p, of size %ld)\n"
            "org=%s:%d new=%s:%d\n",
            node->address, node->size,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
a410 26
      node->source  = source = ft_mem_table_get_source( table );

      if ( delta == 0 )
      {
        /* this is an allocation */
        source->all_blocks++;
        source->cur_blocks++;
        if ( source->cur_blocks > source->max_blocks )
          source->max_blocks = source->cur_blocks;
      }

      if ( size > (FT_ULong)source->cur_max )
        source->cur_max = size;

      if ( delta != 0 )
      {
        /* we are growing or shrinking a reallocated block */
        source->cur_size     += delta;
        table->alloc_current += delta;
      }
      else
      {
        /* we are allocating a new block */
        source->cur_size     += size;
        table->alloc_current += size;
      }
d412 2
a413 4
      source->all_size += size;

      if ( source->cur_size > source->max_size )
        source->max_size = source->cur_size;
d423 2
a424 2
      table->alloc_total += size;

d437 1
a437 2
                       FT_Byte*     address,
                       FT_Long      delta )
a447 3
        FT_MemSource  source;


d453 2
a454 2
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
d457 2
a458 1
        /* scramble the node's content for additional safety */
d461 4
a464 33
        if ( delta == 0 )
        {
          source = node->source;

          source->cur_blocks--;
          source->cur_size -= node->size;

          table->alloc_current -= node->size;
        }

        if ( table->keep_alive )
        {
          /* we simply invert the node's size to indicate that the node */
          /* was freed.                                                 */
          node->size           = -node->size;
          node->free_file_name = _ft_debug_file;
          node->free_line_no   = _ft_debug_lineno;
        }
        else
        {
          table->nodes--;

          *pnode = node->link;

          node->size   = 0;
          node->source = NULL;

          ft_mem_table_free( table, node );

          if ( table->nodes * 3 < table->size  ||
               table->size  * 3 < table->nodes )
            ft_mem_table_resize( table );
        }
d470 1
a470 1
          FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
d487 1
a487 1
    if ( table->bound_count                           &&
d492 3
a494 3
    if ( table->bound_total                                             &&
         table->alloc_total_max - table->alloc_current > (FT_ULong)size )
      return NULL;
d498 1
a498 2
    {
      ft_mem_table_set( table, block, (FT_ULong)size, 0 );
d500 1
a500 2
      table->alloc_count++;
    }
d502 2
a503 2
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;
d505 1
a505 1
    return (FT_Pointer)block;
d518 2
a519 7
                          FT_FILENAME( _ft_debug_file ),
                          _ft_debug_lineno );

    ft_mem_table_remove( table, (FT_Byte*)block, 0 );

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );
d521 1
a521 1
    table->alloc_count--;
d523 3
a525 2
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;
a537 1
    FT_Long      delta;
d539 2
a540 2
    const char*  file_name = FT_FILENAME( _ft_debug_file );
    FT_Long      line_no   = _ft_debug_lineno;
a542 6
    /* unlikely, but possible */
    if ( new_size == cur_size )
      return block;

    /* the following is valid according to ANSI C */
#if 0
d545 1
a545 2
                          file_name, line_no );
#endif
a546 2
    /* while the following is allowed in ANSI C also, we abort since */
    /* such case should be handled by FreeType.                      */
d552 1
a552 1
    /* check `cur_size' value */
d570 1
a570 14
    /* return NULL if the maximum number of allocations was reached */
    if ( table->bound_count                           &&
         table->alloc_count >= table->alloc_count_max )
      return NULL;

    delta = (FT_Long)( new_size - cur_size );

    /* return NULL if this allocation would overflow the maximum heap size */
    if ( delta > 0                                                       &&
         table->bound_total                                              &&
         table->alloc_current + (FT_ULong)delta > table->alloc_total_max )
      return NULL;

    new_block = (FT_Byte *)ft_mem_table_alloc( table, new_size );
a573 2
    ft_mem_table_set( table, (FT_Byte*)new_block, new_size, delta );

d576 2
a577 1
    ft_mem_table_remove( table, (FT_Byte*)block, delta );
d579 1
a579 5
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );
d598 1
a598 2


d603 1
a603 1

d607 2
a608 3
          FT_Long   total_max = ft_atol( p );


d612 1
a612 1
            table->alloc_total_max = (FT_ULong)total_max;
d615 1
a615 1

d619 2
a620 3
          FT_Long  total_count = ft_atol( p );


d624 1
a624 1
            table->alloc_count_max = (FT_ULong)total_count;
a627 10
        p = getenv( "FT2_KEEP_ALIVE" );
        if ( p != NULL )
        {
          FT_Long  keep_alive = ft_atol( p );


          if ( keep_alive > 0 )
            table->keep_alive = 1;
        }

d653 8
a661 6
  static int
  ft_mem_source_compare( const void*  p1,
                         const void*  p2 )
  {
    FT_MemSource  s1 = *(FT_MemSource*)p1;
    FT_MemSource  s2 = *(FT_MemSource*)p2;
d663 6
a668 7

    if ( s2->max_size > s1->max_size )
      return 1;
    else if ( s2->max_size < s1->max_size )
      return -1;
    else
      return 0;
d672 7
a678 2
  extern void
  FT_DumpMemory( FT_Memory  memory )
d685 5
a689 5
      FT_MemSource*  bucket = table->sources;
      FT_MemSource*  limit  = bucket + FT_MEM_SOURCE_BUCKETS;
      FT_MemSource*  sources;
      FT_UInt        nn, count;
      const char*    fmt;
d692 7
a698 4
      count = 0;
      for ( ; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;
d701 4
a704 43
        for ( ; source; source = source->link )
          count++;
      }

      sources = (FT_MemSource*)ft_mem_table_alloc(
                                 table, sizeof ( *sources ) * count );

      count = 0;
      for ( bucket = table->sources; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;


        for ( ; source; source = source->link )
          sources[count++] = source;
      }

      ft_qsort( sources, count, sizeof ( *sources ), ft_mem_source_compare );

      printf( "FreeType Memory Dump: "
              "current=%ld max=%ld total=%ld count=%ld\n",
              table->alloc_current, table->alloc_max,
              table->alloc_total, table->alloc_count );
      printf( " block  block    sizes    sizes    sizes   source\n" );
      printf( " count   high      sum  highsum      max   location\n" );
      printf( "-------------------------------------------------\n" );

      fmt = "%6ld %6ld %8ld %8ld %8ld %s:%d\n";

      for ( nn = 0; nn < count; nn++ )
      {
        FT_MemSource  source = sources[nn];


        printf( fmt,
                source->cur_blocks, source->max_blocks,
                source->cur_size, source->max_size, source->cur_max,
                FT_FILENAME( source->file_name ),
                source->line_no );
      }
      printf( "------------------------------------------------\n" );

      ft_mem_table_free( table, sources );
d706 1
d709 1
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006 by                        */
a29 5
#define  KEEPALIVE /* `Keep alive' means that freed blocks aren't released
                    * to the heap.  This is useful to detect double-frees
                    * or weird heap corruption, but it uses large amounts of
                    * memory, however.
                    */
a33 10
  FT_BASE_DEF( const char* )  _ft_debug_file   = 0;
  FT_BASE_DEF( long )         _ft_debug_lineno = 0;

  extern void
  FT_DumpMemory( FT_Memory  memory );


  typedef struct FT_MemSourceRec_*  FT_MemSource;
  typedef struct FT_MemNodeRec_*    FT_MemNode;
  typedef struct FT_MemTableRec_*   FT_MemTable;
d35 2
a39 39
  /*
   *  This structure holds statistics for a single allocation/release
   *  site.  This is useful to know where memory operations happen the
   *  most.
   */
  typedef struct  FT_MemSourceRec_
  {
    const char*   file_name;
    long          line_no;

    FT_Long       cur_blocks;   /* current number of allocated blocks */
    FT_Long       max_blocks;   /* max. number of allocated blocks    */
    FT_Long       all_blocks;   /* total number of blocks allocated   */

    FT_Long       cur_size;     /* current cumulative allocated size */
    FT_Long       max_size;     /* maximum cumulative allocated size */
    FT_Long       all_size;     /* total cumulative allocated size   */

    FT_Long       cur_max;      /* current maximum allocated size */

    FT_UInt32     hash;
    FT_MemSource  link;

  } FT_MemSourceRec;


  /*
   *  We don't need a resizable array for the memory sources, because
   *  their number is pretty limited within FreeType.
   */
#define FT_MEM_SOURCE_BUCKETS  128

  /*
   *  This structure holds information related to a single allocated
   *  memory block.  If KEEPALIVE is defined, blocks that are freed by
   *  FreeType are never released to the system.  Instead, their `size'
   *  field is set to -size.  This is mainly useful to detect double frees,
   *  at the price of large memory footprint during execution.
   */
d42 2
a43 2
    FT_Byte*      address;
    FT_Long       size;     /* < 0 if the block was freed */
d45 2
a46 1
    FT_MemSource  source;
d48 2
a49 4
#ifdef KEEPALIVE
    const char*   free_file_name;
    FT_Long       free_line_no;
#endif
d51 1
a51 1
    FT_MemNode    link;
a55 4
  /*
   *  The global structure, containing compound statistics and all hash
   *  tables.
   */
d67 1
a67 1
    FT_Bool          bound_total;
d69 1
a69 1

d73 2
a74 3
    FT_MemSource     sources[FT_MEM_SOURCE_BUCKETS];

    FT_Bool          keep_alive;
a90 4
  /*
   *  Prime numbers are ugly to handle.  It would be better to implement
   *  L-Hashing, which is 10% faster and doesn't require divisions.
   */
a130 14
  static FT_ULong
  ft_mem_closest_prime( FT_ULong  num )
  {
    FT_UInt  i;


    for ( i = 0;
          i < sizeof ( ft_mem_primes ) / sizeof ( ft_mem_primes[0] ); i++ )
      if ( ft_mem_primes[i] > num )
        return ft_mem_primes[i];

    return FT_MEM_SIZE_MAX;
  }

d133 1
a133 2
  ft_mem_debug_panic( const char*  fmt,
                      ... )
d149 15
d176 1
a176 1
    return block;
d202 1
a202 1
      FT_MemNode*  new_buckets;
d207 2
a208 2
                      ft_mem_table_alloc( table,
                                          new_size * sizeof ( FT_MemNode ) );
d212 1
a212 1
      FT_ARRAY_ZERO( new_buckets, new_size );
d253 1
a253 1
    FT_ZERO( table );
d267 2
a268 2
                       memory->alloc( memory,
                                      table->size * sizeof ( FT_MemNode ) );
d270 1
a270 1
      FT_ARRAY_ZERO( table->buckets, table->size );
a287 2
    FT_DumpMemory( table->memory );

d290 2
a291 2
      FT_Long   leak_count = 0;
      FT_ULong  leaks      = 0;
a293 1
      /* remove all blocks from the table, revealing leaked ones */
d309 2
a310 2
              FT_FILENAME( node->source->file_name ),
              node->source->line_no );
d321 1
a321 1
          ft_mem_table_free( table, node );
a325 1

d329 2
a330 17
      table->size  = 0;
      table->nodes = 0;

      /* remove all sources */
      for ( i = 0; i < FT_MEM_SOURCE_BUCKETS; i++ )
      {
        FT_MemSource  source, next;


        for ( source = table->sources[i]; source != NULL; source = next )
        {
          next = source->link;
          ft_mem_table_free( table, source );
        }

        table->sources[i] = NULL;
      }
d337 1
a337 1
      ft_mem_table_free( table, table );
a342 1

a373 51
  static FT_MemSource
  ft_mem_table_get_source( FT_MemTable  table )
  {
    FT_UInt32     hash;
    FT_MemSource  node, *pnode;


    hash  = (FT_UInt32)(void*)_ft_debug_file +
              (FT_UInt32)( 5 * _ft_debug_lineno );
    pnode = &table->sources[hash % FT_MEM_SOURCE_BUCKETS];

    for ( ;; )
    {
      node = *pnode;
      if ( node == NULL )
        break;

      if ( node->file_name == _ft_debug_file &&
           node->line_no   == _ft_debug_lineno   )
        goto Exit;

      pnode = &node->link;
    }

    node = (FT_MemSource)ft_mem_table_alloc( table, sizeof ( *node ) );
    if ( node == NULL )
      ft_mem_debug_panic(
        "not enough memory to perform memory debugging\n" );

    node->file_name = _ft_debug_file;
    node->line_no   = _ft_debug_lineno;

    node->cur_blocks = 0;
    node->max_blocks = 0;
    node->all_blocks = 0;

    node->cur_size   = 0;
    node->max_size   = 0;
    node->all_size   = 0;

    node->cur_max    = 0;

    node->link = NULL;
    node->hash = hash;
    *pnode     = node;

  Exit:
    return node;
  }


d377 1
a377 2
                    FT_ULong     size,
                    FT_Long      delta )
a383 3
      FT_MemSource  source;


d390 2
a391 3
          /* This block was already freed.  Our memory is now completely */
          /* corrupted!                                                  */
          /* This can only happen in keep-alive mode.                    */
d397 1
a397 1
          /* This block was already allocated.  This means that our memory */
d400 1
a400 6
            "memory heap corrupted (re-allocating allocated block at"
            " %p, of size %ld)\n"
            "org=%s:%d new=%s:%d\n",
            node->address, node->size,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
a410 26
      node->source  = source = ft_mem_table_get_source( table );

      if ( delta == 0 )
      {
        /* this is an allocation */
        source->all_blocks++;
        source->cur_blocks++;
        if ( source->cur_blocks > source->max_blocks )
          source->max_blocks = source->cur_blocks;
      }

      if ( size > (FT_ULong)source->cur_max )
        source->cur_max = size;

      if ( delta != 0 )
      {
        /* we are growing or shrinking a reallocated block */
        source->cur_size     += delta;
        table->alloc_current += delta;
      }
      else
      {
        /* we are allocating a new block */
        source->cur_size     += size;
        table->alloc_current += size;
      }
d412 2
a413 4
      source->all_size += size;

      if ( source->cur_size > source->max_size )
        source->max_size = source->cur_size;
d423 2
a424 2
      table->alloc_total += size;

d437 1
a437 2
                       FT_Byte*     address,
                       FT_Long      delta )
a447 3
        FT_MemSource  source;


d453 2
a454 2
            FT_FILENAME( _ft_debug_file ), _ft_debug_lineno,
            FT_FILENAME( node->source->file_name ), node->source->line_no,
d457 2
a458 1
        /* scramble the node's content for additional safety */
d461 4
a464 33
        if ( delta == 0 )
        {
          source = node->source;

          source->cur_blocks--;
          source->cur_size -= node->size;

          table->alloc_current -= node->size;
        }

        if ( table->keep_alive )
        {
          /* we simply invert the node's size to indicate that the node */
          /* was freed.                                                 */
          node->size           = -node->size;
          node->free_file_name = _ft_debug_file;
          node->free_line_no   = _ft_debug_lineno;
        }
        else
        {
          table->nodes--;

          *pnode = node->link;

          node->size   = 0;
          node->source = NULL;

          ft_mem_table_free( table, node );

          if ( table->nodes * 3 < table->size  ||
               table->size  * 3 < table->nodes )
            ft_mem_table_resize( table );
        }
d470 1
a470 1
          FT_FILENAME( _ft_debug_file ), _ft_debug_lineno );
d487 1
a487 1
    if ( table->bound_count                           &&
d492 3
a494 3
    if ( table->bound_total                                             &&
         table->alloc_total_max - table->alloc_current > (FT_ULong)size )
      return NULL;
d498 1
a498 2
    {
      ft_mem_table_set( table, block, (FT_ULong)size, 0 );
d500 1
a500 2
      table->alloc_count++;
    }
d502 2
a503 2
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;
d505 1
a505 1
    return (FT_Pointer)block;
d518 2
a519 7
                          FT_FILENAME( _ft_debug_file ),
                          _ft_debug_lineno );

    ft_mem_table_remove( table, (FT_Byte*)block, 0 );

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );
d521 1
a521 1
    table->alloc_count--;
d523 3
a525 2
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;
a537 1
    FT_Long      delta;
d539 2
a540 2
    const char*  file_name = FT_FILENAME( _ft_debug_file );
    FT_Long      line_no   = _ft_debug_lineno;
a542 6
    /* unlikely, but possible */
    if ( new_size == cur_size )
      return block;

    /* the following is valid according to ANSI C */
#if 0
d545 1
a545 2
                          file_name, line_no );
#endif
a546 2
    /* while the following is allowed in ANSI C also, we abort since */
    /* such case should be handled by FreeType.                      */
d552 1
a552 1
    /* check `cur_size' value */
d570 1
a570 14
    /* return NULL if the maximum number of allocations was reached */
    if ( table->bound_count                           &&
         table->alloc_count >= table->alloc_count_max )
      return NULL;

    delta = (FT_Long)( new_size - cur_size );

    /* return NULL if this allocation would overflow the maximum heap size */
    if ( delta > 0                                                       &&
         table->bound_total                                              &&
         table->alloc_current + (FT_ULong)delta > table->alloc_total_max )
      return NULL;

    new_block = (FT_Byte *)ft_mem_table_alloc( table, new_size );
a573 2
    ft_mem_table_set( table, (FT_Byte*)new_block, new_size, delta );

d576 2
a577 1
    ft_mem_table_remove( table, (FT_Byte*)block, delta );
d579 1
a579 5
    _ft_debug_file   = "<unknown>";
    _ft_debug_lineno = 0;

    if ( !table->keep_alive )
      ft_mem_table_free( table, block );
d598 1
a598 2


d603 1
a603 1

d607 2
a608 3
          FT_Long   total_max = ft_atol( p );


d612 1
a612 1
            table->alloc_total_max = (FT_ULong)total_max;
d615 1
a615 1

d619 2
a620 3
          FT_Long  total_count = ft_atol( p );


d624 1
a624 1
            table->alloc_count_max = (FT_ULong)total_count;
a627 10
        p = getenv( "FT2_KEEP_ALIVE" );
        if ( p != NULL )
        {
          FT_Long  keep_alive = ft_atol( p );


          if ( keep_alive > 0 )
            table->keep_alive = 1;
        }

d653 8
a661 6
  static int
  ft_mem_source_compare( const void*  p1,
                         const void*  p2 )
  {
    FT_MemSource  s1 = *(FT_MemSource*)p1;
    FT_MemSource  s2 = *(FT_MemSource*)p2;
d663 6
a668 7

    if ( s2->max_size > s1->max_size )
      return 1;
    else if ( s2->max_size < s1->max_size )
      return -1;
    else
      return 0;
d672 7
a678 2
  extern void
  FT_DumpMemory( FT_Memory  memory )
d685 5
a689 5
      FT_MemSource*  bucket = table->sources;
      FT_MemSource*  limit  = bucket + FT_MEM_SOURCE_BUCKETS;
      FT_MemSource*  sources;
      FT_UInt        nn, count;
      const char*    fmt;
d692 7
a698 4
      count = 0;
      for ( ; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;
d701 4
a704 43
        for ( ; source; source = source->link )
          count++;
      }

      sources = (FT_MemSource*)ft_mem_table_alloc(
                                 table, sizeof ( *sources ) * count );

      count = 0;
      for ( bucket = table->sources; bucket < limit; bucket++ )
      {
        FT_MemSource  source = *bucket;


        for ( ; source; source = source->link )
          sources[count++] = source;
      }

      ft_qsort( sources, count, sizeof ( *sources ), ft_mem_source_compare );

      printf( "FreeType Memory Dump: "
              "current=%ld max=%ld total=%ld count=%ld\n",
              table->alloc_current, table->alloc_max,
              table->alloc_total, table->alloc_count );
      printf( " block  block    sizes    sizes    sizes   source\n" );
      printf( " count   high      sum  highsum      max   location\n" );
      printf( "-------------------------------------------------\n" );

      fmt = "%6ld %6ld %8ld %8ld %8ld %s:%d\n";

      for ( nn = 0; nn < count; nn++ )
      {
        FT_MemSource  source = sources[nn];


        printf( fmt,
                source->cur_blocks, source->max_blocks,
                source->cur_size, source->max_size, source->cur_max,
                FT_FILENAME( source->file_name ),
                source->line_no );
      }
      printf( "------------------------------------------------\n" );

      ft_mem_table_free( table, sources );
d706 1
d709 1
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2009 by                  */
d36 2
a37 1
#include FT_CONFIG_STANDARD_LIBRARY_H
d425 1
a425 1
      printf( "FreeType: no memory leaks detected\n" );
d463 1
a463 3
    /* cast to FT_PtrDist first since void* can be larger */
    /* than FT_UInt32 and GCC 4.1.1 emits a warning       */
    hash  = (FT_UInt32)(FT_PtrDist)(void*)_ft_debug_file +
d991 1
a991 1
  typedef int  _debug_mem_dummy;
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2001-2016 by                                                 */
d38 1
a38 1
  FT_BASE_DEF( const char* )  _ft_debug_file   = NULL;
d50 1
a50 1
#define FT_MEM_VAL( addr )  ( (FT_PtrDist)(FT_Pointer)( addr ) )
d79 1
a79 1
   *  We don't need a resizable array for the memory sources because
d88 2
a89 2
   *  field is set to `-size'.  This is mainly useful to detect double
   *  frees, at the price of a large memory footprint during execution.
d114 2
a115 2
    FT_Long          size;
    FT_Long          nodes;
d118 4
a121 4
    FT_Long          alloc_total;
    FT_Long          alloc_current;
    FT_Long          alloc_max;
    FT_Long          alloc_count;
d124 1
a124 1
    FT_Long          alloc_total_max;
d127 1
a127 1
    FT_Long          alloc_count_max;
d145 1
a145 1
#define FT_FILENAME( x )  ( (x) ? (x) : "unknown file" )
d152 1
a152 1
  static const FT_Int  ft_mem_primes[] =
d192 2
a193 2
  static FT_Long
  ft_mem_closest_prime( FT_Long  num )
d195 1
a195 1
    size_t  i;
d207 1
a207 1
  static void
d257 1
a257 1
    FT_Long  new_size;
d264 1
a264 1
      FT_Long      i;
d268 3
a270 4
                      ft_mem_table_alloc(
                        table,
                        new_size * (FT_Long)sizeof ( FT_MemNode ) );
      if ( !new_buckets )
d278 1
a278 1
        FT_PtrDist  hash;
d285 1
a285 1
          hash  = FT_MEM_VAL( node->address ) % (FT_PtrDist)new_size;
d311 1
a311 1
    if ( !table )
d328 2
a329 3
                       memory->alloc(
                         memory,
                         table->size * (FT_Long)sizeof ( FT_MemNode ) );
d346 1
a346 3
    FT_Long  i;
    FT_Long  leak_count = 0;
    FT_Long  leaks      = 0;
d351 1
a351 2
    /* remove all blocks from the table, revealing leaked ones */
    for ( i = 0; i < table->size; i++ )
d353 2
a354 1
      FT_MemNode  *pnode = table->buckets + i, next, node = *pnode;
d357 2
a358 1
      while ( node )
d360 2
a361 2
        next       = node->link;
        node->link = NULL;
d363 1
a363 1
        if ( node->size > 0 )
d365 10
a374 6
          printf(
            "leaked memory block at address %p, size %8ld in (%s:%ld)\n",
            (void*)node->address,
            node->size,
            FT_FILENAME( node->source->file_name ),
            node->source->line_no );
d376 2
a377 2
          leak_count++;
          leaks += node->size;
d379 2
a380 2
          ft_mem_table_free( table, node->address );
        }
d382 2
a383 2
        node->address = NULL;
        node->size    = 0;
d385 4
a388 2
        ft_mem_table_free( table, node );
        node = next;
a389 2
      table->buckets[i] = NULL;
    }
d391 2
a392 2
    ft_mem_table_free( table, table->buckets );
    table->buckets = NULL;
d394 2
a395 2
    table->size  = 0;
    table->nodes = 0;
d397 4
a400 4
    /* remove all sources */
    for ( i = 0; i < FT_MEM_SOURCE_BUCKETS; i++ )
    {
      FT_MemSource  source, next;
d403 7
a409 4
      for ( source = table->sources[i]; source != NULL; source = next )
      {
        next = source->link;
        ft_mem_table_free( table, source );
d412 4
a415 2
      table->sources[i] = NULL;
    }
d417 1
a417 4
    printf( "FreeType: total memory allocations = %ld\n",
            table->alloc_total );
    printf( "FreeType: maximum memory footprint = %ld\n",
            table->alloc_max );
d419 4
a422 1
    ft_mem_table_free( table, table );
d424 2
a425 6
    if ( leak_count > 0 )
      ft_mem_debug_panic(
        "FreeType: %ld bytes of memory leaked in %ld blocks\n",
        leaks, leak_count );

    printf( "FreeType: no memory leaks detected\n" );
d433 1
a433 1
    FT_PtrDist   hash;
d438 1
a438 1
    pnode = table->buckets + ( hash % (FT_PtrDist)table->size );
d468 1
a468 1
    for (;;)
d471 1
a471 1
      if ( !node )
d474 2
a475 2
      if ( node->file_name == _ft_debug_file   &&
           node->line_no   == _ft_debug_lineno )
d482 1
a482 1
    if ( !node )
d493 3
a495 3
    node->cur_size = 0;
    node->max_size = 0;
    node->all_size = 0;
d497 1
a497 1
    node->cur_max = 0;
d511 1
a511 1
                    FT_Long      size,
d550 1
a550 1
      if ( !node )
d566 1
a566 1
      if ( size > source->cur_max )
d679 1
a679 1
  static FT_Pointer
d696 2
a697 2
    if ( table->bound_total                                   &&
         table->alloc_total_max - table->alloc_current > size )
d703 1
a703 1
      ft_mem_table_set( table, block, size, 0 );
d715 1
a715 1
  static void
d722 1
a722 1
    if ( !block )
d739 1
a739 1
  static FT_Pointer
d760 1
a760 1
    if ( !block || !cur_size )
d795 1
a795 1
    delta = new_size - cur_size;
d798 3
a800 3
    if ( delta > 0                                             &&
         table->bound_total                                    &&
         table->alloc_current + delta > table->alloc_total_max )
d803 2
a804 2
    new_block = (FT_Pointer)ft_mem_table_alloc( table, new_size );
    if ( !new_block )
d809 1
a809 2
    ft_memcpy( new_block, block, cur_size < new_size ? (size_t)cur_size
                                                     : (size_t)new_size );
d844 1
a844 1
        if ( p )
d846 1
a846 1
          FT_Long  total_max = ft_strtol( p, NULL, 10 );
d852 1
a852 1
            table->alloc_total_max = total_max;
d857 1
a857 1
        if ( p )
d859 1
a859 1
          FT_Long  total_count = ft_strtol( p, NULL, 10 );
d865 1
a865 1
            table->alloc_count_max = total_count;
d870 1
a870 1
        if ( p )
d872 1
a872 1
          FT_Long  keep_alive = ft_strtol( p, NULL, 10 );
d904 1
d933 1
a933 1
      FT_Int         nn, count;
d947 2
a948 3
      sources = (FT_MemSource*)
                  ft_mem_table_alloc(
                    table, count * (FT_Long)sizeof ( *sources ) );
d960 1
a960 4
      ft_qsort( sources,
                (size_t)count,
                sizeof ( *sources ),
                ft_mem_source_compare );
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
