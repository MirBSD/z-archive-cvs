head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.30;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.04.51;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.42;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.30;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.39.09;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.02;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.03;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.24;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.07;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftcalc.c                                                               */
/*                                                                         */
/*    Arithmetic computations (body).                                      */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* Support for 1-complement arithmetic has been totally dropped in this  */
  /* release.  You can still write your own code if you need it.           */
  /*                                                                       */
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* Implementing basic computation routines.                              */
  /*                                                                       */
  /* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
  /* and FT_FloorFix() are declared in freetype.h.                         */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>
#include FT_GLYPH_H
#include FT_TRIGONOMETRY_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H


#ifdef FT_MULFIX_ASSEMBLER
#undef FT_MulFix
#endif

/* we need to emulate a 64-bit data type if a real one isn't available */

#ifndef FT_LONG64

  typedef struct  FT_Int64_
  {
    FT_UInt32  lo;
    FT_UInt32  hi;

  } FT_Int64;

#endif /* !FT_LONG64 */


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_calc


  /* transfer sign leaving a positive number */
#define FT_MOVE_SIGN( x, s ) \
  FT_BEGIN_STMNT             \
    if ( x < 0 )             \
    {                        \
      x = -x;                \
      s = -s;                \
    }                        \
  FT_END_STMNT

  /* The following three functions are available regardless of whether */
  /* FT_LONG64 is defined.                                             */

  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_RoundFix( FT_Fixed  a )
  {
    return ( a + 0x8000L - ( a < 0 ) ) & ~0xFFFFL;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_CeilFix( FT_Fixed  a )
  {
    return ( a + 0xFFFFL ) & ~0xFFFFL;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Fixed )
  FT_FloorFix( FT_Fixed  a )
  {
    return a & ~0xFFFFL;
  }

#ifndef FT_MSB

  FT_BASE_DEF ( FT_Int )
  FT_MSB( FT_UInt32 z )
  {
    FT_Int  shift = 0;


    /* determine msb bit index in `shift' */
    if ( z & 0xFFFF0000UL )
    {
      z     >>= 16;
      shift  += 16;
    }
    if ( z & 0x0000FF00UL )
    {
      z     >>= 8;
      shift  += 8;
    }
    if ( z & 0x000000F0UL )
    {
      z     >>= 4;
      shift  += 4;
    }
    if ( z & 0x0000000CUL )
    {
      z     >>= 2;
      shift  += 2;
    }
    if ( z & 0x00000002UL )
    {
   /* z     >>= 1; */
      shift  += 1;
    }

    return shift;
  }

#endif /* !FT_MSB */


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Fixed )
  FT_Hypot( FT_Fixed  x,
            FT_Fixed  y )
  {
    FT_Vector  v;


    v.x = x;
    v.y = y;

    return FT_Vector_Length( &v );
  }


#ifdef FT_LONG64


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;

    d = c > 0 ? ( a * b + ( c >> 1 ) ) / c
              : 0x7FFFFFFFUL;

    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Long )
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;

    d = c > 0 ? a * b / c
              : 0x7FFFFFFFUL;

    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
  {
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( (FT_Int32)a_, (FT_Int32)b_ );

#else

    FT_Int64  ab = (FT_Int64)a_ * (FT_Int64)b_;

    /* this requires arithmetic right shift of signed numbers */
    return (FT_Long)( ( ab + 0x8000L - ( ab < 0 ) ) >> 16 );

#endif /* FT_MULFIX_ASSEMBLER */
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
  {
    FT_Int     s = 1;
    FT_UInt64  a, b, q;
    FT_Long    q_;


    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;

    q = b > 0 ? ( ( a << 16 ) + ( b >> 1 ) ) / b
              : 0x7FFFFFFFUL;

    q_ = (FT_Long)q;

    return s < 0 ? -q_ : q_;
  }


#else /* !FT_LONG64 */


  static void
  ft_multo64( FT_UInt32  x,
              FT_UInt32  y,
              FT_Int64  *z )
  {
    FT_UInt32  lo1, hi1, lo2, hi2, lo, hi, i1, i2;


    lo1 = x & 0x0000FFFFU;  hi1 = x >> 16;
    lo2 = y & 0x0000FFFFU;  hi2 = y >> 16;

    lo = lo1 * lo2;
    i1 = lo1 * hi2;
    i2 = lo2 * hi1;
    hi = hi1 * hi2;

    /* Check carry overflow of i1 + i2 */
    i1 += i2;
    hi += (FT_UInt32)( i1 < i2 ) << 16;

    hi += i1 >> 16;
    i1  = i1 << 16;

    /* Check carry overflow of i1 + lo */
    lo += i1;
    hi += ( lo < i1 );

    z->lo = lo;
    z->hi = hi;
  }


  static FT_UInt32
  ft_div64by32( FT_UInt32  hi,
                FT_UInt32  lo,
                FT_UInt32  y )
  {
    FT_UInt32  r, q;
    FT_Int     i;


    if ( hi >= y )
      return (FT_UInt32)0x7FFFFFFFL;

    /* We shift as many bits as we can into the high register, perform     */
    /* 32-bit division with modulo there, then work through the remaining  */
    /* bits with long division. This optimization is especially noticeable */
    /* for smaller dividends that barely use the high register.            */

    i = 31 - FT_MSB( hi );
    r = ( hi << i ) | ( lo >> ( 32 - i ) ); lo <<= i; /* left 64-bit shift */
    q = r / y;
    r -= q * y;   /* remainder */

    i = 32 - i;   /* bits remaining in low register */
    do
    {
      q <<= 1;
      r   = ( r << 1 ) | ( lo >> 31 ); lo <<= 1;

      if ( r >= y )
      {
        r -= y;
        q |= 1;
      }
    } while ( --i );

    return q;
  }


  static void
  FT_Add64( FT_Int64*  x,
            FT_Int64*  y,
            FT_Int64  *z )
  {
    FT_UInt32  lo, hi;


    lo = x->lo + y->lo;
    hi = x->hi + y->hi + ( lo < x->lo );

    z->lo = lo;
    z->hi = hi;
  }


  /*  The FT_MulDiv function has been optimized thanks to ideas from     */
  /*  Graham Asher and Alexei Podtelezhnikov.  The trick is to optimize  */
  /*  a rather common case when everything fits within 32-bits.          */
  /*                                                                     */
  /*  We compute 'a*b+c/2', then divide it by 'c' (all positive values). */
  /*                                                                     */
  /*  The product of two positive numbers never exceeds the square of    */
  /*  its mean values.  Therefore, we always avoid the overflow by       */
  /*  imposing                                                           */
  /*                                                                     */
  /*    (a + b) / 2 <= sqrt(X - c/2)    ,                                */
  /*                                                                     */
  /*  where X = 2^32 - 1, the maximum unsigned 32-bit value, and using   */
  /*  unsigned arithmetic.  Now we replace `sqrt' with a linear function */
  /*  that is smaller or equal for all values of c in the interval       */
  /*  [0;X/2]; it should be equal to sqrt(X) and sqrt(3X/4) at the       */
  /*  endpoints.  Substituting the linear solution and explicit numbers  */
  /*  we get                                                             */
  /*                                                                     */
  /*    a + b <= 131071.99 - c / 122291.84    .                          */
  /*                                                                     */
  /*  In practice, we should use a faster and even stronger inequality   */
  /*                                                                     */
  /*    a + b <= 131071 - (c >> 16)                                      */
  /*                                                                     */
  /*  or, alternatively,                                                 */
  /*                                                                     */
  /*    a + b <= 129894 - (c >> 17)    .                                 */
  /*                                                                     */
  /*  FT_MulFix, on the other hand, is optimized for a small value of    */
  /*  the first argument, when the second argument can be much larger.   */
  /*  This can be achieved by scaling the second argument and the limit  */
  /*  in the above inequalities.  For example,                           */
  /*                                                                     */
  /*    a + (b >> 8) <= (131071 >> 4)                                    */
  /*                                                                     */
  /*  covers the practical range of use. The actual test below is a bit  */
  /*  tighter to avoid the border case overflows.                        */
  /*                                                                     */
  /*  In the case of FT_DivFix, the exact overflow check                 */
  /*                                                                     */
  /*    a << 16 <= X - c/2                                               */
  /*                                                                     */
  /*  is scaled down by 2^16 and we use                                  */
  /*                                                                     */
  /*    a <= 65535 - (c >> 17)    .                                      */

  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, c;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;

    if ( c == 0 )
      a = 0x7FFFFFFFUL;

    else if ( a + b <= 129894UL - ( c >> 17 ) )
      a = ( a * b + ( c >> 1 ) ) / c;

    else
    {
      FT_Int64  temp, temp2;


      ft_multo64( a, b, &temp );

      temp2.hi = 0;
      temp2.lo = c >> 1;

      FT_Add64( &temp, &temp2, &temp );

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;
  }


  FT_BASE_DEF( FT_Long )
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, c;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;

    if ( c == 0 )
      a = 0x7FFFFFFFUL;

    else if ( a + b <= 131071UL )
      a = a * b / c;

    else
    {
      FT_Int64  temp;


      ft_multo64( a, b, &temp );

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;
  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
  {
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( a_, b_ );

#elif 0

    /*
     *  This code is nonportable.  See comment below.
     *
     *  However, on a platform where right-shift of a signed quantity fills
     *  the leftmost bits by copying the sign bit, it might be faster.
     */

    FT_Long    sa, sb;
    FT_UInt32  a, b;


    /*
     *  This is a clever way of converting a signed number `a' into its
     *  absolute value (stored back into `a') and its sign.  The sign is
     *  stored in `sa'; 0 means `a' was positive or zero, and -1 means `a'
     *  was negative.  (Similarly for `b' and `sb').
     *
     *  Unfortunately, it doesn't work (at least not portably).
     *
     *  It makes the assumption that right-shift on a negative signed value
     *  fills the leftmost bits by copying the sign bit.  This is wrong.
     *  According to K&R 2nd ed, section `A7.8 Shift Operators' on page 206,
     *  the result of right-shift of a negative signed value is
     *  implementation-defined.  At least one implementation fills the
     *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned
     *  right shift).  This means that when `a' is negative, `sa' ends up
     *  with the value 1 rather than -1.  After that, everything else goes
     *  wrong.
     */
    sa = ( a_ >> ( sizeof ( a_ ) * 8 - 1 ) );
    a  = ( a_ ^ sa ) - sa;
    sb = ( b_ >> ( sizeof ( b_ ) * 8 - 1 ) );
    b  = ( b_ ^ sb ) - sb;

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000U ) >> 16;
    else
    {
      FT_UInt32  al = a & 0xFFFFUL;


      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
    }

    sa ^= sb;
    a   = ( a ^ sa ) - sa;

    return (FT_Long)a;

#else /* 0 */

    FT_Int     s = 1;
    FT_UInt32  a, b;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000UL ) >> 16;
    else
    {
      FT_UInt32  al = a & 0xFFFFUL;


      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
    }

    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;

#endif /* 0 */

  }


  /* documentation is in freetype.h */

  FT_EXPORT_DEF( FT_Long )
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
  {
    FT_Int     s = 1;
    FT_UInt32  a, b, q;
    FT_Long    q_;


    /* XXX: this function does not allow 64-bit arguments */

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;

    if ( b == 0 )
    {
      /* check for division by 0 */
      q = 0x7FFFFFFFUL;
    }
    else if ( a <= 65535UL - ( b >> 17 ) )
    {
      /* compute result directly */
      q = ( ( a << 16 ) + ( b >> 1 ) ) / b;
    }
    else
    {
      /* we need more bits; we have to do it by hand */
      FT_Int64  temp, temp2;


      temp.hi  = a >> 16;
      temp.lo  = a << 16;
      temp2.hi = 0;
      temp2.lo = b >> 1;

      FT_Add64( &temp, &temp2, &temp );
      q = ft_div64by32( temp.hi, temp.lo, b );
    }

    q_ = (FT_Long)q;

    return s < 0 ? -q_ : q_;
  }


#endif /* !FT_LONG64 */


  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( void )
  FT_Matrix_Multiply( const FT_Matrix*  a,
                      FT_Matrix        *b )
  {
    FT_Fixed  xx, xy, yx, yy;


    if ( !a || !b )
      return;

    xx = FT_MulFix( a->xx, b->xx ) + FT_MulFix( a->xy, b->yx );
    xy = FT_MulFix( a->xx, b->xy ) + FT_MulFix( a->xy, b->yy );
    yx = FT_MulFix( a->yx, b->xx ) + FT_MulFix( a->yy, b->yx );
    yy = FT_MulFix( a->yx, b->xy ) + FT_MulFix( a->yy, b->yy );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Matrix_Invert( FT_Matrix*  matrix )
  {
    FT_Pos  delta, xx, yy;


    if ( !matrix )
      return FT_THROW( Invalid_Argument );

    /* compute discriminant */
    delta = FT_MulFix( matrix->xx, matrix->yy ) -
            FT_MulFix( matrix->xy, matrix->yx );

    if ( !delta )
      return FT_THROW( Invalid_Argument );  /* matrix can't be inverted */

    matrix->xy = - FT_DivFix( matrix->xy, delta );
    matrix->yx = - FT_DivFix( matrix->yx, delta );

    xx = matrix->xx;
    yy = matrix->yy;

    matrix->xx = FT_DivFix( yy, delta );
    matrix->yy = FT_DivFix( xx, delta );

    return FT_Err_Ok;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                             FT_Matrix        *b,
                             FT_Long           scaling )
  {
    FT_Fixed  xx, xy, yx, yy;

    FT_Long   val = 0x10000L * scaling;


    if ( !a || !b )
      return;

    xx = FT_MulDiv( a->xx, b->xx, val ) + FT_MulDiv( a->xy, b->yx, val );
    xy = FT_MulDiv( a->xx, b->xy, val ) + FT_MulDiv( a->xy, b->yy, val );
    yx = FT_MulDiv( a->yx, b->xx, val ) + FT_MulDiv( a->yy, b->yx, val );
    yy = FT_MulDiv( a->yx, b->xy, val ) + FT_MulDiv( a->yy, b->yy, val );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Vector_Transform_Scaled( FT_Vector*        vector,
                              const FT_Matrix*  matrix,
                              FT_Long           scaling )
  {
    FT_Pos   xz, yz;

    FT_Long  val = 0x10000L * scaling;


    if ( !vector || !matrix )
      return;

    xz = FT_MulDiv( vector->x, matrix->xx, val ) +
         FT_MulDiv( vector->y, matrix->xy, val );

    yz = FT_MulDiv( vector->x, matrix->yx, val ) +
         FT_MulDiv( vector->y, matrix->yy, val );

    vector->x = xz;
    vector->y = yz;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_UInt32 )
  FT_Vector_NormLen( FT_Vector*  vector )
  {
    FT_Int32   x_ = vector->x;
    FT_Int32   y_ = vector->y;
    FT_Int32   b, z;
    FT_UInt32  x, y, u, v, l;
    FT_Int     sx = 1, sy = 1, shift;


    FT_MOVE_SIGN( x_, sx );
    FT_MOVE_SIGN( y_, sy );

    x = (FT_UInt32)x_;
    y = (FT_UInt32)y_;

    /* trivial cases */
    if ( x == 0 )
    {
      if ( y > 0 )
        vector->y = sy * 0x10000;
      return y;
    }
    else if ( y == 0 )
    {
      if ( x > 0 )
        vector->x = sx * 0x10000;
      return x;
    }

    /* Estimate length and prenormalize by shifting so that */
    /* the new approximate length is between 2/3 and 4/3.   */
    /* The magic constant 0xAAAAAAAAUL (2/3 of 2^32) helps  */
    /* achieve this in 16.16 fixed-point representation.    */
    l = x > y ? x + ( y >> 1 )
              : y + ( x >> 1 );

    shift  = 31 - FT_MSB( l );
    shift -= 15 + ( l >= ( 0xAAAAAAAAUL >> shift ) );

    if ( shift > 0 )
    {
      x <<= shift;
      y <<= shift;

      /* re-estimate length for tiny vectors */
      l = x > y ? x + ( y >> 1 )
                : y + ( x >> 1 );
    }
    else
    {
      x >>= -shift;
      y >>= -shift;
      l >>= -shift;
    }

    /* lower linear approximation for reciprocal length minus one */
    b = 0x10000 - (FT_Int32)l;

    x_ = (FT_Int32)x;
    y_ = (FT_Int32)y;

    /* Newton's iterations */
    do
    {
      u = (FT_UInt32)( x_ + ( x_ * b >> 16 ) );
      v = (FT_UInt32)( y_ + ( y_ * b >> 16 ) );

      /* Normalized squared length in the parentheses approaches 2^32. */
      /* On two's complement systems, converting to signed gives the   */
      /* difference with 2^32 even if the expression wraps around.     */
      z = -(FT_Int32)( u * u + v * v ) / 0x200;
      z = z * ( ( 0x10000 + b ) >> 8 ) / 0x10000;

      b += z;

    } while ( z > 0 );

    vector->x = sx < 0 ? -(FT_Pos)u : (FT_Pos)u;
    vector->y = sy < 0 ? -(FT_Pos)v : (FT_Pos)v;

    /* Conversion to signed helps to recover from likely wrap around */
    /* in calculating the prenormalized length, because it gives the */
    /* correct difference with 2^32 on two's complement systems.     */
    l = (FT_UInt32)( 0x10000 + (FT_Int32)( u * x + v * y ) / 0x10000 );
    if ( shift > 0 )
      l = ( l + ( 1 << ( shift - 1 ) ) ) >> shift;
    else
      l <<= -shift;

    return l;
  }


#if 0

  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int32 )
  FT_SqrtFixed( FT_Int32  x )
  {
    FT_UInt32  root, rem_hi, rem_lo, test_div;
    FT_Int     count;


    root = 0;

    if ( x > 0 )
    {
      rem_hi = 0;
      rem_lo = (FT_UInt32)x;
      count  = 24;
      do
      {
        rem_hi   = ( rem_hi << 2 ) | ( rem_lo >> 30 );
        rem_lo <<= 2;
        root   <<= 1;
        test_div = ( root << 1 ) + 1;

        if ( rem_hi >= test_div )
        {
          rem_hi -= test_div;
          root   += 1;
        }
      } while ( --count );
    }

    return (FT_Int32)root;
  }

#endif /* 0 */


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_orientation( FT_Pos  in_x,
                         FT_Pos  in_y,
                         FT_Pos  out_x,
                         FT_Pos  out_y )
  {
#ifdef FT_LONG64

    FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;


    return ( delta > 0 ) - ( delta < 0 );

#else

    FT_Int  result;


    if ( (FT_ULong)FT_ABS( in_x ) + (FT_ULong)FT_ABS( out_y ) <= 131071UL &&
         (FT_ULong)FT_ABS( in_y ) + (FT_ULong)FT_ABS( out_x ) <= 131071UL )
    {
      FT_Long  z1 = in_x * out_y;
      FT_Long  z2 = in_y * out_x;


      if ( z1 > z2 )
        result = +1;
      else if ( z1 < z2 )
        result = -1;
      else
        result = 0;
    }
    else /* products might overflow 32 bits */
    {
      FT_Int64  z1, z2;


      /* XXX: this function does not allow 64-bit arguments */
      ft_multo64( (FT_UInt32)in_x, (FT_UInt32)out_y, &z1 );
      ft_multo64( (FT_UInt32)in_y, (FT_UInt32)out_x, &z2 );

      if ( z1.hi > z2.hi )
        result = +1;
      else if ( z1.hi < z2.hi )
        result = -1;
      else if ( z1.lo > z2.lo )
        result = +1;
      else if ( z1.lo < z2.lo )
        result = -1;
      else
        result = 0;
    }

    /* XXX: only the sign of return value, +1/0/-1 must be used */
    return result;

#endif
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_is_flat( FT_Pos  in_x,
                     FT_Pos  in_y,
                     FT_Pos  out_x,
                     FT_Pos  out_y )
  {
    FT_Pos  ax = in_x + out_x;
    FT_Pos  ay = in_y + out_y;

    FT_Pos  d_in, d_out, d_hypot;


    /* The idea of this function is to compare the length of the */
    /* hypotenuse with the `in' and `out' length.  The `corner'  */
    /* represented by `in' and `out' is flat if the hypotenuse's */
    /* length isn't too large.                                   */
    /*                                                           */
    /* This approach has the advantage that the angle between    */
    /* `in' and `out' is not checked.  In case one of the two    */
    /* vectors is `dominant', this is, much larger than the      */
    /* other vector, we thus always have a flat corner.          */
    /*                                                           */
    /*                hypotenuse                                 */
    /*       x---------------------------x                       */
    /*        \                      /                           */
    /*         \                /                                */
    /*      in  \          /  out                                */
    /*           \    /                                          */
    /*            o                                              */
    /*              Point                                        */

    d_in    = FT_HYPOT(  in_x,  in_y );
    d_out   = FT_HYPOT( out_x, out_y );
    d_hypot = FT_HYPOT(    ax,    ay );

    /* now do a simple length comparison: */
    /*                                    */
    /*   d_in + d_out < 17/16 d_hypot     */

    return ( d_in + d_out - d_hypot ) < ( d_hypot >> 4 );
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
d37 1
d42 2
a43 1
#ifdef FT_MULFIX_INLINED
d47 1
a47 3
/* we need to define a 64-bits data type here */

#ifdef FT_LONG64
d49 1
a49 3
  typedef FT_INT64  FT_Int64;

#else
d58 1
a58 1
#endif /* FT_LONG64 */
d71 10
d89 1
a89 2
    return ( a >= 0 ) ?   ( a + 0x8000L ) & ~0xFFFFL
                      : -((-a + 0x8000L ) & ~0xFFFFL );
d98 1
a98 2
    return ( a >= 0 ) ?   ( a + 0xFFFFL ) & ~0xFFFFL
                      : -((-a + 0xFFFFL ) & ~0xFFFFL );
d107 1
a107 2
    return ( a >= 0 ) ?   a & ~0xFFFFL
                      : -((-a) & ~0xFFFFL );
d110 1
d112 32
a143 1
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
d145 2
a146 1
  /* documentation is in ftcalc.h */
d148 1
a148 4
  FT_EXPORT_DEF( FT_Int32 )
  FT_Sqrt32( FT_Int32  x )
  {
    FT_UInt32  val, root, newroot, mask;
d151 1
a151 3
    root = 0;
    mask = (FT_UInt32)0x40000000UL;
    val  = (FT_UInt32)x;
d153 5
a157 8
    do
    {
      newroot = root + mask;
      if ( newroot <= val )
      {
        val -= newroot;
        root = newroot + mask;
      }
a158 2
      root >>= 1;
      mask >>= 2;
d160 2
a161 1
    } while ( mask != 0 );
d163 1
a163 1
    return root;
a165 2
#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */

d173 3
a175 3
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c )
d177 4
a180 2
    FT_Int   s;
    FT_Long  d;
d182 3
d186 3
a188 4
    s = 1;
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
    if ( c < 0 ) { c = -c; s = -s; }
d190 2
a191 2
    d = (FT_Long)( c > 0 ? ( (FT_Int64)a * b + ( c >> 1 ) ) / c
                         : 0x7FFFFFFFL );
d193 3
a195 1
    return ( s > 0 ) ? d : -d;
a198 2
#ifdef TT_USE_BYTECODE_INTERPRETER

d202 3
a204 3
  FT_MulDiv_No_Round( FT_Long  a,
                      FT_Long  b,
                      FT_Long  c )
d206 4
a209 2
    FT_Int   s;
    FT_Long  d;
d211 3
d215 3
a217 4
    s = 1;
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
    if ( c < 0 ) { c = -c; s = -s; }
d219 2
a220 2
    d = (FT_Long)( c > 0 ? (FT_Int64)a * b / c
                         : 0x7FFFFFFFL );
d222 3
a224 1
    return ( s > 0 ) ? d : -d;
a226 2
#endif /* TT_USE_BYTECODE_INTERPRETER */

d231 2
a232 2
  FT_MulFix( FT_Long  a,
             FT_Long  b )
d236 1
a236 1
    return FT_MULFIX_ASSEMBLER( a, b );
d240 1
a240 2
    FT_Int   s = 1;
    FT_Long  c;
d242 2
a243 16

    if ( a < 0 )
    {
      a = -a;
      s = -1;
    }

    if ( b < 0 )
    {
      b = -b;
      s = -s;
    }

    c = (FT_Long)( ( (FT_Int64)a * b + 0x8000L ) >> 16 );

    return ( s > 0 ) ? c : -c;
d252 2
a253 2
  FT_DivFix( FT_Long  a,
             FT_Long  b )
d255 4
a258 2
    FT_Int32   s;
    FT_UInt32  q;
d260 2
a261 3
    s = 1;
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
d263 7
a269 6
    if ( b == 0 )
      /* check for division by 0 */
      q = 0x7FFFFFFFL;
    else
      /* compute result directly */
      q = (FT_UInt32)( ( ( (FT_Int64)a << 16 ) + ( b >> 1 ) ) / b );
d271 1
a271 1
    return ( s < 0 ? -(FT_Long)q : (FT_Long)q );
d319 2
a320 2
    q = 0;
    r = hi;
d322 9
a330 2
    if ( r >= y )
      return (FT_UInt32)0x7FFFFFFFL;
d332 1
a332 1
    i = 32;
a334 1
      r <<= 1;
d336 1
a336 1
      r  |= lo >> 31;
d338 1
a338 1
      if ( r >= (FT_UInt32)y )
a342 1
      lo <<= 1;
d354 1
a354 1
    register FT_UInt32  lo, hi;
d365 28
a392 5
  /* documentation is in freetype.h */

  /* The FT_MulDiv function has been optimized thanks to ideas from      */
  /* Graham Asher.  The trick is to optimize computation when everything */
  /* fits within 32-bits (a rather common case).                         */
d394 4
a397 1
  /*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
d399 1
a399 1
  /*  46340 is FLOOR(SQRT(2^31-1)).                                      */
d401 2
a402 1
  /*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
d404 1
a404 1
  /*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
d406 1
a406 1
  /*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
d408 1
a408 1
  /*  and 2*0x157F0 = 176096                                             */
d410 3
d415 3
a417 3
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c )
d419 2
a420 1
    long  s;
a423 2
    if ( a == 0 || b == c )
      return a;
d425 10
a434 3
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
    s ^= c; c = FT_ABS( c );
d436 1
a436 1
    if ( a <= 46340L && b <= 46340L && c <= 176095L && c > 0 )
d439 1
a439 1
    else if ( c > 0 )
d444 1
a444 1
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
d447 2
a448 1
      temp2.lo = (FT_UInt32)(c >> 1);
d450 4
a453 1
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
a454 2
    else
      a = 0x7FFFFFFFL;
d456 3
a458 1
    return ( s < 0 ? -a : a );
a461 2
#ifdef TT_USE_BYTECODE_INTERPRETER

d463 3
a465 3
  FT_MulDiv_No_Round( FT_Long  a,
                      FT_Long  b,
                      FT_Long  c )
d467 3
a469 1
    long  s;
d471 1
d473 7
a479 2
    if ( a == 0 || b == c )
      return a;
d481 2
a482 3
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
    s ^= c; c = FT_ABS( c );
d484 1
a484 1
    if ( a <= 46340L && b <= 46340L && c > 0 )
d487 1
a487 1
    else if ( c > 0 )
d492 5
a496 2
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
a497 2
    else
      a = 0x7FFFFFFFL;
d499 3
a501 1
    return ( s < 0 ? -a : a );
a503 2
#endif /* TT_USE_BYTECODE_INTERPRETER */

d508 2
a509 2
  FT_MulFix( FT_Long  a,
             FT_Long  b )
d513 1
a513 1
    return FT_MULFIX_ASSEMBLER( a, b );
d524 2
a525 3
    FT_Long   sa, sb;
    FT_ULong  ua, ub;

a526 2
    if ( a == 0 || b == 0x10000L )
      return a;
d537 1
a537 1
     *  fills the leftmost bits by copying the sign bit.  This is wrong. 
d546 4
a549 4
    sa = ( a >> ( sizeof ( a ) * 8 - 1 ) );
    a  = ( a ^ sa ) - sa;
    sb = ( b >> ( sizeof ( b ) * 8 - 1 ) );
    b  = ( b ^ sb ) - sb;
d551 2
a552 2
    ua = (FT_ULong)a;
    ub = (FT_ULong)b;
d554 2
a555 2
    if ( ua <= 2048 && ub <= 1048576L )
      ua = ( ua * ub + 0x8000U ) >> 16;
d558 1
a558 1
      FT_ULong  al = ua & 0xFFFFU;
d561 2
a562 2
      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFFU ) + 0x8000U ) >> 16 );
d565 2
a566 2
    sa ^= sb,
    ua  = (FT_ULong)(( ua ^ sa ) - sa);
d568 1
a568 1
    return (FT_Long)ua;
d572 2
a573 2
    FT_Long   s;
    FT_ULong  ua, ub;
d576 1
a576 2
    if ( a == 0 || b == 0x10000L )
      return a;
d578 2
a579 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d581 2
a582 2
    ua = (FT_ULong)a;
    ub = (FT_ULong)b;
d584 2
a585 2
    if ( ua <= 2048 && ub <= 1048576L )
      ua = ( ua * ub + 0x8000UL ) >> 16;
d588 1
a588 1
      FT_ULong  al = ua & 0xFFFFUL;
d591 2
a592 2
      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d595 3
a597 1
    return ( s < 0 ? -(FT_Long)ua : (FT_Long)ua );
d607 2
a608 2
  FT_DivFix( FT_Long  a,
             FT_Long  b )
d610 3
a612 2
    FT_Int32   s;
    FT_UInt32  q;
d616 6
a621 2
    s  = (FT_Int32)a; a = FT_ABS( a );
    s ^= (FT_Int32)b; b = FT_ABS( b );
d626 1
a626 1
      q = (FT_UInt32)0x7FFFFFFFL;
d628 1
a628 1
    else if ( ( a >> 16 ) == 0 )
d631 1
a631 1
      q = (FT_UInt32)( (a << 16) + (b >> 1) ) / (FT_UInt32)b;
d638 3
a640 2
      temp.hi  = (FT_Int32) (a >> 16);
      temp.lo  = (FT_UInt32)(a << 16);
d642 2
a643 1
      temp2.lo = (FT_UInt32)( b >> 1 );
d645 1
a645 1
      q = ft_div64by32( temp.hi, temp.lo, (FT_Int32)b );
d648 1
a648 3
    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
  }

d650 1
a650 22
#if 0

  /* documentation is in ftcalc.h */

  FT_EXPORT_DEF( void )
  FT_MulTo64( FT_Int32   x,
              FT_Int32   y,
              FT_Int64  *z )
  {
    FT_Int32  s;


    s  = x; x = FT_ABS( x );
    s ^= y; y = FT_ABS( y );

    ft_multo64( x, y, z );

    if ( s < 0 )
    {
      z->lo = (FT_UInt32)-(FT_Int32)z->lo;
      z->hi = ~z->hi + !( z->lo );
    }
d654 1
a654 97
  /* apparently, the second version of this code is not compiled correctly */
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */

#if 1

  FT_EXPORT_DEF( FT_Int32 )
  FT_Div64by32( FT_Int64*  x,
                FT_Int32   y )
  {
    FT_Int32   s;
    FT_UInt32  q, r, i, lo;


    s  = x->hi;
    if ( s < 0 )
    {
      x->lo = (FT_UInt32)-(FT_Int32)x->lo;
      x->hi = ~x->hi + !x->lo;
    }
    s ^= y;  y = FT_ABS( y );

    /* Shortcut */
    if ( x->hi == 0 )
    {
      if ( y > 0 )
        q = x->lo / y;
      else
        q = 0x7FFFFFFFL;

      return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
    }

    r  = x->hi;
    lo = x->lo;

    if ( r >= (FT_UInt32)y ) /* we know y is to be treated as unsigned here */
      return ( s < 0 ? 0x80000001UL : 0x7FFFFFFFUL );
                             /* Return Max/Min Int32 if division overflow. */
                             /* This includes division by zero!            */
    q = 0;
    for ( i = 0; i < 32; i++ )
    {
      r <<= 1;
      q <<= 1;
      r  |= lo >> 31;

      if ( r >= (FT_UInt32)y )
      {
        r -= y;
        q |= 1;
      }
      lo <<= 1;
    }

    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
  }

#else /* 0 */

  FT_EXPORT_DEF( FT_Int32 )
  FT_Div64by32( FT_Int64*  x,
                FT_Int32   y )
  {
    FT_Int32   s;
    FT_UInt32  q;


    s  = x->hi;
    if ( s < 0 )
    {
      x->lo = (FT_UInt32)-(FT_Int32)x->lo;
      x->hi = ~x->hi + !x->lo;
    }
    s ^= y;  y = FT_ABS( y );

    /* Shortcut */
    if ( x->hi == 0 )
    {
      if ( y > 0 )
        q = ( x->lo + ( y >> 1 ) ) / y;
      else
        q = 0x7FFFFFFFL;

      return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
    }

    q = ft_div64by32( x->hi, x->lo, y );

    return ( s < 0 ? -(FT_Int32)q : (FT_Int32)q );
  }

#endif /* 0 */

#endif /* 0 */


#endif /* FT_LONG64 */
d688 1
a688 1
      return FT_Err_Invalid_Argument;
d695 1
a695 1
      return FT_Err_Invalid_Argument;  /* matrix can't be inverted */
d763 98
d873 1
a873 1
      rem_lo = x;
d893 2
d904 3
a906 1
    FT_Long  result; /* avoid overflow on 16-bit system */
d909 3
a911 32
    /* deal with the trivial cases quickly */
    if ( in_y == 0 )
    {
      if ( in_x >= 0 )
        result = out_y;
      else
        result = -out_y;
    }
    else if ( in_x == 0 )
    {
      if ( in_y >= 0 )
        result = -out_x;
      else
        result = out_x;
    }
    else if ( out_y == 0 )
    {
      if ( out_x >= 0 )
        result = in_y;
      else
        result = -in_y;
    }
    else if ( out_x == 0 )
    {
      if ( out_y >= 0 )
        result = -in_x;
      else
        result =  in_x;
    }
    else /* general case */
    {
#ifdef FT_LONG64
d913 1
a913 1
      FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;
d916 5
a920 4
      if ( delta == 0 )
        result = 0;
      else
        result = 1 - 2 * ( delta < 0 );
a921 1
#else
d923 9
d936 2
a937 2
      ft_multo64( (FT_Int32)in_x, (FT_Int32)out_y, &z1 );
      ft_multo64( (FT_Int32)in_y, (FT_Int32)out_x, &z2 );
a948 2

#endif
d952 3
a954 1
    return (FT_Int)result;
d966 2
a967 2
    FT_Pos  ax = in_x;
    FT_Pos  ay = in_y;
d969 1
a969 1
    FT_Pos  d_in, d_out, d_corner;
d972 26
a997 21
    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = out_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = out_x + in_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y + in_y;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;
d999 1
a999 1
    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
@


1.4
log
@Merge freetype 2.3.6
@
text
@a0 2
/* $XFree86: xc/extras/freetype2/src/base/ftcalc.c,v 1.2 2005/02/28 23:19:13 dawes Exp $ */

d36 1
d41 21
d113 1
a113 1
    FT_ULong  val, root, newroot, mask;
d117 2
a118 2
    mask = 0x40000000L;
    val  = (FT_ULong)x;
d199 6
d209 11
a219 2
    if ( a < 0 ) { a = -a; s = -1; }
    if ( b < 0 ) { b = -b; s = -s; }
d222 4
a225 1
    return ( s > 0 ) ? c : -c ;
d365 1
d381 1
a381 1
      ft_multo64( a, b, &temp );
d386 1
a386 1
      a = ft_div64by32( temp.hi, temp.lo, c );
d420 2
a421 2
      ft_multo64( a, b, &temp );
      a = ft_div64by32( temp.hi, temp.lo, c );
d438 1
a438 1
    /* use inline assembly to speed up things a bit */
d440 1
a440 1
#if defined( __GNUC__ ) && defined( i386 )
d442 1
a442 1
    FT_Long  result;
d444 6
a449 19

    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      "mov   %%eax, %0\n"
      : "=r"(result)
      : "a"(a), "d"(b)
      : "%ecx"
    );
    return result;

#elif 1
d458 18
d543 3
a545 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d550 1
a550 1
      q = 0x7FFFFFFFL;
d567 1
a567 1
      q = ft_div64by32( temp.hi, temp.lo, b );
d698 53
d845 1
a845 1
    FT_Int  result;
d894 3
a896 2
      ft_multo64( in_x, out_y, &z1 );
      ft_multo64( in_y, out_x, &z2 );
d912 2
a913 1
    return result;
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d9 1
a9 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d499 2
a500 2
    s  = a; a = FT_ABS(a);
    s ^= b; b = FT_ABS(b);
d655 51
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d146 1
a146 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d170 1
a170 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d215 1
a215 1
#else /* FT_LONG64 */
d289 1
a289 1
    register FT_UInt32  lo, hi, max;
d292 2
a293 3
    max = x->lo > y->lo ? x->lo : y->lo;
    lo  = x->lo + y->lo;
    hi  = x->hi + y->hi + ( lo < max );
d302 17
d356 1
a356 1
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
d390 1
a390 1
#endif /* TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
d399 26
a424 1
#if 1
d433 1
a433 1
     a = ( a ^ sa ) - sa;
d435 1
a435 1
     b = ( b ^ sb ) - sb;
d441 1
a441 3
    {
      ua = ( ua * ub + 0x8000 ) >> 16;
    }
d444 1
a444 1
      FT_ULong  al = ua & 0xFFFF;
d448 1
a448 1
           ( ( al * ( ub & 0xFFFF ) + 0x8000 ) >> 16 );
d465 2
a466 2
    s  = a; a = FT_ABS(a);
    s ^= b; b = FT_ABS(b);
d472 1
a472 3
    {
      ua = ( ua * ub + 0x8000L ) >> 16;
    }
d475 1
a475 1
      FT_ULong  al = ua & 0xFFFFL;
d479 1
a479 1
           ( ( al * ( ub & 0xFFFFL ) + 0x8000L ) >> 16 );
d555 1
a555 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...         */
d592 1
a592 1
                             /* This includes division by zero! */
d688 118
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d86 2
d117 2
d284 1
a284 3
  /* documentation is in ftcalc.h */

  FT_EXPORT_DEF( void )
d383 36
d446 3
d492 2
a516 2
  /* documentation is in ftcalc.h */

d518 1
a518 1
  /* on Mac machines with the MPW C compiler..  tsss, tsss, tss...         */
d610 2
d616 1
a616 1
  /* a not-so-fast but working 16.16 fixed point square root function */
d618 1
a618 1
  FT_EXPORT_DEF( FT_Int32 )
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d1 2
d9 1
a9 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a42 18
/* we need to define a 64-bits data type here */

#ifdef FT_LONG64

  typedef FT_INT64  FT_Int64;

#else

  typedef struct  FT_Int64_
  {
    FT_UInt32  lo;
    FT_UInt32  hi;

  } FT_Int64;

#endif /* FT_LONG64 */


a85 2
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

a114 2
#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */

d142 1
a142 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d166 1
a166 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d211 1
a211 1
#else /* !FT_LONG64 */
d280 3
a282 1
  static void
d287 1
a287 1
    register FT_UInt32  lo, hi;
d290 3
a292 2
    lo = x->lo + y->lo;
    hi = x->hi + y->hi + ( lo < x->lo );
a300 17
  /* The FT_MulDiv function has been optimized thanks to ideas from      */
  /* Graham Asher.  The trick is to optimize computation when everything */
  /* fits within 32-bits (a rather common case).                         */
  /*                                                                     */
  /*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
  /*                                                                     */
  /*  46340 is FLOOR(SQRT(2^31-1)).                                      */
  /*                                                                     */
  /*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
  /*                                                                     */
  /*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
  /*                                                                     */
  /*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
  /*                                                                     */
  /*  and 2*0x157F0 = 176096                                             */
  /*                                                                     */

d338 1
a338 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d372 1
a372 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d381 1
a381 27
    /* use inline assembly to speed up things a bit */

#if defined( __GNUC__ ) && defined( i386 )

    FT_Long  result;


    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      "mov   %%eax, %0\n"
      : "=r"(result)
      : "a"(a), "d"(b)
      : "%ecx"
    );
    return result;

#elif 1

    FT_Long   sa, sb;
d388 2
a389 4
    sa = ( a >> ( sizeof ( a ) * 8 - 1 ) );
    a  = ( a ^ sa ) - sa;
    sb = ( b >> ( sizeof ( b ) * 8 - 1 ) );
    b  = ( b ^ sb ) - sb;
a394 2
      ua = ( ua * ub + 0x8000U ) >> 16;
    else
d396 1
a396 5
      FT_ULong  al = ua & 0xFFFFU;


      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFFU ) + 0x8000U ) >> 16 );
a397 23

    sa ^= sb,
    ua  = (FT_ULong)(( ua ^ sa ) - sa);

    return (FT_Long)ua;

#else /* 0 */

    FT_Long   s;
    FT_ULong  ua, ub;


    if ( a == 0 || b == 0x10000L )
      return a;

    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );

    ua = (FT_ULong)a;
    ub = (FT_ULong)b;

    if ( ua <= 2048 && ub <= 1048576L )
      ua = ( ua * ub + 0x8000UL ) >> 16;
d400 1
a400 1
      FT_ULong  al = ua & 0xFFFFUL;
d404 1
a404 1
           ( ( al * ( ub & 0xFFFFUL ) + 0x8000UL ) >> 16 );
a407 3

#endif /* 0 */

a450 2
#if 0

d474 2
d477 1
a477 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */
d514 1
a514 1
                             /* This includes division by zero!            */
a568 2
#endif /* 0 */

d573 1
a573 1
  /* documentation is in ftcalc.h */
d575 1
a575 1
  FT_BASE_DEF( FT_Int32 )
a607 118
  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_orientation( FT_Pos  in_x,
                         FT_Pos  in_y,
                         FT_Pos  out_x,
                         FT_Pos  out_y )
  {
    FT_Int  result;


    /* deal with the trivial cases quickly */
    if ( in_y == 0 )
    {
      if ( in_x >= 0 )
        result = out_y;
      else
        result = -out_y;
    }
    else if ( in_x == 0 )
    {
      if ( in_y >= 0 )
        result = -out_x;
      else
        result = out_x;
    }
    else if ( out_y == 0 )
    {
      if ( out_x >= 0 )
        result = in_y;
      else
        result = -in_y;
    }
    else if ( out_x == 0 )
    {
      if ( out_y >= 0 )
        result = -in_x;
      else
        result =  in_x;
    }
    else /* general case */
    {
#ifdef FT_LONG64

      FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;


      if ( delta == 0 )
        result = 0;
      else
        result = 1 - 2 * ( delta < 0 );

#else

      FT_Int64  z1, z2;


      ft_multo64( in_x, out_y, &z1 );
      ft_multo64( in_y, out_x, &z2 );

      if ( z1.hi > z2.hi )
        result = +1;
      else if ( z1.hi < z2.hi )
        result = -1;
      else if ( z1.lo > z2.lo )
        result = +1;
      else if ( z1.lo < z2.lo )
        result = -1;
      else
        result = 0;

#endif
    }

    return result;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_is_flat( FT_Pos  in_x,
                     FT_Pos  in_y,
                     FT_Pos  out_x,
                     FT_Pos  out_y )
  {
    FT_Pos  ax = in_x;
    FT_Pos  ay = in_y;

    FT_Pos  d_in, d_out, d_corner;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = out_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = out_x + in_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y + in_y;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;

    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
  }


@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
d515 2
a516 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
a670 51
  FT_BASE_DEF( void )
  FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                             FT_Matrix        *b,
                             FT_Long           scaling )
  {
    FT_Fixed  xx, xy, yx, yy;

    FT_Long   val = 0x10000L * scaling;


    if ( !a || !b )
      return;

    xx = FT_MulDiv( a->xx, b->xx, val ) + FT_MulDiv( a->xy, b->yx, val );
    xy = FT_MulDiv( a->xx, b->xy, val ) + FT_MulDiv( a->xy, b->yy, val );
    yx = FT_MulDiv( a->yx, b->xx, val ) + FT_MulDiv( a->yy, b->yx, val );
    yy = FT_MulDiv( a->yx, b->xy, val ) + FT_MulDiv( a->yy, b->yy, val );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Vector_Transform_Scaled( FT_Vector*        vector,
                              const FT_Matrix*  matrix,
                              FT_Long           scaling )
  {
    FT_Pos   xz, yz;

    FT_Long  val = 0x10000L * scaling;


    if ( !vector || !matrix )
      return;

    xz = FT_MulDiv( vector->x, matrix->xx, val ) +
         FT_MulDiv( vector->y, matrix->xy, val );

    yz = FT_MulDiv( vector->x, matrix->yx, val ) +
         FT_MulDiv( vector->y, matrix->yy, val );

    vector->x = xz;
    vector->y = yz;
  }


  /* documentation is in ftcalc.h */

@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d1 2
a42 18
/* we need to define a 64-bits data type here */

#ifdef FT_LONG64

  typedef FT_INT64  FT_Int64;

#else

  typedef struct  FT_Int64_
  {
    FT_UInt32  lo;
    FT_UInt32  hi;

  } FT_Int64;

#endif /* FT_LONG64 */


@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a101 2
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

a130 2
#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */

d296 3
a298 1
  static void
a396 36
#if 1
    FT_Long   sa, sb;
    FT_ULong  ua, ub;


    if ( a == 0 || b == 0x10000L )
      return a;

    sa = ( a >> ( sizeof ( a ) * 8 - 1 ) );
     a = ( a ^ sa ) - sa;
    sb = ( b >> ( sizeof ( b ) * 8 - 1 ) );
     b = ( b ^ sb ) - sb;

    ua = (FT_ULong)a;
    ub = (FT_ULong)b;

    if ( ua <= 2048 && ub <= 1048576L )
    {
      ua = ( ua * ub + 0x8000 ) >> 16;
    }
    else
    {
      FT_ULong  al = ua & 0xFFFF;


      ua = ( ua >> 16 ) * ub +  al * ( ub >> 16 ) +
           ( ( al * ( ub & 0xFFFF ) + 0x8000 ) >> 16 );
    }

    sa ^= sb,
    ua  = (FT_ULong)(( ua ^ sa ) - sa);

    return (FT_Long)ua;

#else /* 0 */

a423 3

#endif /* 0 */

a466 2
#if 0

d490 2
d493 1
a493 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...         */
a584 2
#endif /* 0 */

d589 1
a589 1
  /* documentation is in ftcalc.h */
d591 1
a591 1
  FT_BASE_DEF( FT_Int32 )
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
a35 1
#include FT_GLYPH_H
a39 3
#ifdef FT_MULFIX_INLINED
#undef FT_MulFix
#endif
d109 1
a109 1
    FT_UInt32  val, root, newroot, mask;
d113 2
a114 2
    mask = (FT_UInt32)0x40000000UL;
    val  = (FT_UInt32)x;
d162 1
a162 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d186 1
a186 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
a194 6
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( a, b );

#else

d199 2
a200 11
    if ( a < 0 )
    {
      a = -a;
      s = -1;
    }

    if ( b < 0 )
    {
      b = -b;
      s = -s;
    }
d203 1
a203 4

    return ( s > 0 ) ? c : -c;

#endif /* FT_MULFIX_ASSEMBLER */
d231 1
a231 1
#else /* !FT_LONG64 */
d305 1
a305 1
    register FT_UInt32  lo, hi;
d308 3
a310 2
    lo = x->lo + y->lo;
    hi = x->hi + y->hi + ( lo < x->lo );
a318 17
  /* The FT_MulDiv function has been optimized thanks to ideas from      */
  /* Graham Asher.  The trick is to optimize computation when everything */
  /* fits within 32-bits (a rather common case).                         */
  /*                                                                     */
  /*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
  /*                                                                     */
  /*  46340 is FLOOR(SQRT(2^31-1)).                                      */
  /*                                                                     */
  /*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
  /*                                                                     */
  /*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
  /*                                                                     */
  /*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
  /*                                                                     */
  /*  and 2*0x157F0 = 176096                                             */
  /*                                                                     */

a326 1
    /* XXX: this function does not allow 64-bit arguments */
d342 1
a342 1
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
d347 1
a347 1
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
d356 1
a356 1
#ifdef TT_USE_BYTECODE_INTERPRETER
d381 2
a382 2
      ft_multo64( (FT_Int32)a, (FT_Int32)b, &temp );
      a = ft_div64by32( temp.hi, temp.lo, (FT_Int32)c );
d390 1
a390 1
#endif /* TT_USE_BYTECODE_INTERPRETER */
d399 1
a399 13
#ifdef FT_MULFIX_ASSEMBLER

    return FT_MULFIX_ASSEMBLER( a, b );

#elif 0

    /*
     *  This code is nonportable.  See comment below.
     *
     *  However, on a platform where right-shift of a signed quantity fills
     *  the leftmost bits by copying the sign bit, it might be faster.
     */

a406 18
    /*
     *  This is a clever way of converting a signed number `a' into its
     *  absolute value (stored back into `a') and its sign.  The sign is
     *  stored in `sa'; 0 means `a' was positive or zero, and -1 means `a'
     *  was negative.  (Similarly for `b' and `sb').
     *
     *  Unfortunately, it doesn't work (at least not portably).
     *
     *  It makes the assumption that right-shift on a negative signed value
     *  fills the leftmost bits by copying the sign bit.  This is wrong. 
     *  According to K&R 2nd ed, section `A7.8 Shift Operators' on page 206,
     *  the result of right-shift of a negative signed value is
     *  implementation-defined.  At least one implementation fills the
     *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned
     *  right shift).  This means that when `a' is negative, `sa' ends up
     *  with the value 1 rather than -1.  After that, everything else goes
     *  wrong.
     */
d408 1
a408 1
    a  = ( a ^ sa ) - sa;
d410 1
a410 1
    b  = ( b ^ sb ) - sb;
d416 3
a418 1
      ua = ( ua * ub + 0x8000U ) >> 16;
d421 1
a421 1
      FT_ULong  al = ua & 0xFFFFU;
d425 1
a425 1
           ( ( al * ( ub & 0xFFFFU ) + 0x8000U ) >> 16 );
d442 2
a443 2
    s  = a; a = FT_ABS( a );
    s ^= b; b = FT_ABS( b );
d449 3
a451 1
      ua = ( ua * ub + 0x8000UL ) >> 16;
d454 1
a454 1
      FT_ULong  al = ua & 0xFFFFUL;
d458 1
a458 1
           ( ( al * ( ub & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d478 2
a479 3
    /* XXX: this function does not allow 64-bit arguments */
    s  = (FT_Int32)a; a = FT_ABS( a );
    s ^= (FT_Int32)b; b = FT_ABS( b );
d484 1
a484 1
      q = (FT_UInt32)0x7FFFFFFFL;
d501 1
a501 1
      q = ft_div64by32( temp.hi, temp.lo, (FT_Int32)b );
d534 1
a534 1
  /* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */
d571 1
a571 1
                             /* This includes division by zero!            */
a631 104
  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( void )
  FT_Matrix_Multiply( const FT_Matrix*  a,
                      FT_Matrix        *b )
  {
    FT_Fixed  xx, xy, yx, yy;


    if ( !a || !b )
      return;

    xx = FT_MulFix( a->xx, b->xx ) + FT_MulFix( a->xy, b->yx );
    xy = FT_MulFix( a->xx, b->xy ) + FT_MulFix( a->xy, b->yy );
    yx = FT_MulFix( a->yx, b->xx ) + FT_MulFix( a->yy, b->yx );
    yy = FT_MulFix( a->yx, b->xy ) + FT_MulFix( a->yy, b->yy );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftglyph.h */

  FT_EXPORT_DEF( FT_Error )
  FT_Matrix_Invert( FT_Matrix*  matrix )
  {
    FT_Pos  delta, xx, yy;


    if ( !matrix )
      return FT_Err_Invalid_Argument;

    /* compute discriminant */
    delta = FT_MulFix( matrix->xx, matrix->yy ) -
            FT_MulFix( matrix->xy, matrix->yx );

    if ( !delta )
      return FT_Err_Invalid_Argument;  /* matrix can't be inverted */

    matrix->xy = - FT_DivFix( matrix->xy, delta );
    matrix->yx = - FT_DivFix( matrix->yx, delta );

    xx = matrix->xx;
    yy = matrix->yy;

    matrix->xx = FT_DivFix( yy, delta );
    matrix->yy = FT_DivFix( xx, delta );

    return FT_Err_Ok;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                             FT_Matrix        *b,
                             FT_Long           scaling )
  {
    FT_Fixed  xx, xy, yx, yy;

    FT_Long   val = 0x10000L * scaling;


    if ( !a || !b )
      return;

    xx = FT_MulDiv( a->xx, b->xx, val ) + FT_MulDiv( a->xy, b->yx, val );
    xy = FT_MulDiv( a->xx, b->xy, val ) + FT_MulDiv( a->xy, b->yy, val );
    yx = FT_MulDiv( a->yx, b->xx, val ) + FT_MulDiv( a->yy, b->yx, val );
    yy = FT_MulDiv( a->yx, b->xy, val ) + FT_MulDiv( a->yy, b->yy, val );

    b->xx = xx;  b->xy = xy;
    b->yx = yx;  b->yy = yy;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( void )
  FT_Vector_Transform_Scaled( FT_Vector*        vector,
                              const FT_Matrix*  matrix,
                              FT_Long           scaling )
  {
    FT_Pos   xz, yz;

    FT_Long  val = 0x10000L * scaling;


    if ( !vector || !matrix )
      return;

    xz = FT_MulDiv( vector->x, matrix->xx, val ) +
         FT_MulDiv( vector->y, matrix->xy, val );

    yz = FT_MulDiv( vector->x, matrix->yx, val ) +
         FT_MulDiv( vector->y, matrix->yy, val );

    vector->x = xz;
    vector->y = yz;
  }


a666 120
  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_orientation( FT_Pos  in_x,
                         FT_Pos  in_y,
                         FT_Pos  out_x,
                         FT_Pos  out_y )
  {
    FT_Long  result; /* avoid overflow on 16-bit system */


    /* deal with the trivial cases quickly */
    if ( in_y == 0 )
    {
      if ( in_x >= 0 )
        result = out_y;
      else
        result = -out_y;
    }
    else if ( in_x == 0 )
    {
      if ( in_y >= 0 )
        result = -out_x;
      else
        result = out_x;
    }
    else if ( out_y == 0 )
    {
      if ( out_x >= 0 )
        result = in_y;
      else
        result = -in_y;
    }
    else if ( out_x == 0 )
    {
      if ( out_y >= 0 )
        result = -in_x;
      else
        result =  in_x;
    }
    else /* general case */
    {
#ifdef FT_LONG64

      FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;


      if ( delta == 0 )
        result = 0;
      else
        result = 1 - 2 * ( delta < 0 );

#else

      FT_Int64  z1, z2;


      /* XXX: this function does not allow 64-bit arguments */
      ft_multo64( (FT_Int32)in_x, (FT_Int32)out_y, &z1 );
      ft_multo64( (FT_Int32)in_y, (FT_Int32)out_x, &z2 );

      if ( z1.hi > z2.hi )
        result = +1;
      else if ( z1.hi < z2.hi )
        result = -1;
      else if ( z1.lo > z2.lo )
        result = +1;
      else if ( z1.lo < z2.lo )
        result = -1;
      else
        result = 0;

#endif
    }

    /* XXX: only the sign of return value, +1/0/-1 must be used */
    return (FT_Int)result;
  }


  /* documentation is in ftcalc.h */

  FT_BASE_DEF( FT_Int )
  ft_corner_is_flat( FT_Pos  in_x,
                     FT_Pos  in_y,
                     FT_Pos  out_x,
                     FT_Pos  out_y )
  {
    FT_Pos  ax = in_x;
    FT_Pos  ay = in_y;

    FT_Pos  d_in, d_out, d_corner;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = out_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = out_x + in_x;
    if ( ax < 0 )
      ax = -ax;
    ay = out_y + in_y;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;

    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
  }


@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
a36 1
#include FT_TRIGONOMETRY_H
d41 1
a41 2

#ifdef FT_MULFIX_ASSEMBLER
d45 3
a47 1
/* we need to emulate a 64-bit data type if a real one isn't available */
d49 3
a51 1
#ifndef FT_LONG64
d60 1
a60 1
#endif /* !FT_LONG64 */
a72 10
  /* transfer sign leaving a positive number */
#define FT_MOVE_SIGN( x, s ) \
  FT_BEGIN_STMNT             \
    if ( x < 0 )             \
    {                        \
      x = -x;                \
      s = -s;                \
    }                        \
  FT_END_STMNT

d81 2
a82 1
    return ( a + 0x8000L - ( a < 0 ) ) & ~0xFFFFL;
d91 2
a92 1
    return ( a + 0xFFFFL ) & ~0xFFFFL;
d101 2
a102 1
    return a & ~0xFFFFL;
a104 1
#ifndef FT_MSB
d106 1
a106 4
  FT_BASE_DEF ( FT_Int )
  FT_MSB( FT_UInt32 z )
  {
    FT_Int  shift = 0;
d108 1
d110 4
a113 26
    /* determine msb bit index in `shift' */
    if ( z & 0xFFFF0000UL )
    {
      z     >>= 16;
      shift  += 16;
    }
    if ( z & 0x0000FF00UL )
    {
      z     >>= 8;
      shift  += 8;
    }
    if ( z & 0x000000F0UL )
    {
      z     >>= 4;
      shift  += 4;
    }
    if ( z & 0x0000000CUL )
    {
      z     >>= 2;
      shift  += 2;
    }
    if ( z & 0x00000002UL )
    {
   /* z     >>= 1; */
      shift  += 1;
    }
a114 2
    return shift;
  }
d116 3
a118 1
#endif /* !FT_MSB */
d120 8
d129 2
a130 1
  /* documentation is in ftcalc.h */
d132 1
a132 5
  FT_BASE_DEF( FT_Fixed )
  FT_Hypot( FT_Fixed  x,
            FT_Fixed  y )
  {
    FT_Vector  v;
d134 2
d137 1
a137 5
    v.x = x;
    v.y = y;

    return FT_Vector_Length( &v );
  }
d146 3
a148 3
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
d150 2
a151 3
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;
d154 4
a157 3
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );
d159 2
a160 3
    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;
d162 2
a163 2
    d = c > 0 ? ( a * b + ( c >> 1 ) ) / c
              : 0x7FFFFFFFUL;
a164 4
    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }
d166 1
d171 3
a173 3
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
d175 2
a176 3
    FT_Int     s = 1;
    FT_UInt64  a, b, c, d;
    FT_Long    d_;
d179 4
a182 3
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );
d184 2
a185 3
    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;
    c = (FT_UInt64)c_;
d187 2
a188 2
    d = c > 0 ? a * b / c
              : 0x7FFFFFFFUL;
d190 1
a190 4
    d_ = (FT_Long)d;

    return s < 0 ? -d_ : d_;
  }
d196 2
a197 2
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
d201 1
a201 1
    return FT_MULFIX_ASSEMBLER( (FT_Int32)a_, (FT_Int32)b_ );
d205 2
a206 1
    FT_Int64  ab = (FT_Int64)a_ * (FT_Int64)b_;
d208 16
a223 2
    /* this requires arithmetic right shift of signed numbers */
    return (FT_Long)( ( ab + 0x8000L - ( ab < 0 ) ) >> 16 );
d232 2
a233 2
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
d235 2
a236 3
    FT_Int     s = 1;
    FT_UInt64  a, b, q;
    FT_Long    q_;
d238 3
d242 6
a247 2
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
d249 1
a249 9
    a = (FT_UInt64)a_;
    b = (FT_UInt64)b_;

    q = b > 0 ? ( ( a << 16 ) + ( b >> 1 ) ) / b
              : 0x7FFFFFFFUL;

    q_ = (FT_Long)q;

    return s < 0 ? -q_ : q_;
d297 4
a300 1
    if ( hi >= y )
d303 1
a303 11
    /* We shift as many bits as we can into the high register, perform     */
    /* 32-bit division with modulo there, then work through the remaining  */
    /* bits with long division. This optimization is especially noticeable */
    /* for smaller dividends that barely use the high register.            */

    i = 31 - FT_MSB( hi );
    r = ( hi << i ) | ( lo >> ( 32 - i ) ); lo <<= i; /* left 64-bit shift */
    q = r / y;
    r -= q * y;   /* remainder */

    i = 32 - i;   /* bits remaining in low register */
d306 1
d308 1
a308 1
      r   = ( r << 1 ) | ( lo >> 31 ); lo <<= 1;
d310 1
a310 1
      if ( r >= y )
d315 1
d327 1
a327 1
    FT_UInt32  lo, hi;
d338 5
a342 22
  /*  The FT_MulDiv function has been optimized thanks to ideas from     */
  /*  Graham Asher and Alexei Podtelezhnikov.  The trick is to optimize  */
  /*  a rather common case when everything fits within 32-bits.          */
  /*                                                                     */
  /*  We compute 'a*b+c/2', then divide it by 'c' (all positive values). */
  /*                                                                     */
  /*  The product of two positive numbers never exceeds the square of    */
  /*  its mean values.  Therefore, we always avoid the overflow by       */
  /*  imposing                                                           */
  /*                                                                     */
  /*    (a + b) / 2 <= sqrt(X - c/2)    ,                                */
  /*                                                                     */
  /*  where X = 2^32 - 1, the maximum unsigned 32-bit value, and using   */
  /*  unsigned arithmetic.  Now we replace `sqrt' with a linear function */
  /*  that is smaller or equal for all values of c in the interval       */
  /*  [0;X/2]; it should be equal to sqrt(X) and sqrt(3X/4) at the       */
  /*  endpoints.  Substituting the linear solution and explicit numbers  */
  /*  we get                                                             */
  /*                                                                     */
  /*    a + b <= 131071.99 - c / 122291.84    .                          */
  /*                                                                     */
  /*  In practice, we should use a faster and even stronger inequality   */
d344 1
a344 1
  /*    a + b <= 131071 - (c >> 16)                                      */
d346 1
a346 1
  /*  or, alternatively,                                                 */
d348 1
a348 1
  /*    a + b <= 129894 - (c >> 17)    .                                 */
d350 1
a350 4
  /*  FT_MulFix, on the other hand, is optimized for a small value of    */
  /*  the first argument, when the second argument can be much larger.   */
  /*  This can be achieved by scaling the second argument and the limit  */
  /*  in the above inequalities.  For example,                           */
d352 1
a352 1
  /*    a + (b >> 8) <= (131071 >> 4)                                    */
d354 1
a354 2
  /*  covers the practical range of use. The actual test below is a bit  */
  /*  tighter to avoid the border case overflows.                        */
a355 9
  /*  In the case of FT_DivFix, the exact overflow check                 */
  /*                                                                     */
  /*    a << 16 <= X - c/2                                               */
  /*                                                                     */
  /*  is scaled down by 2^16 and we use                                  */
  /*                                                                     */
  /*    a <= 65535 - (c >> 17)    .                                      */

  /* documentation is in freetype.h */
d358 3
a360 3
  FT_MulDiv( FT_Long  a_,
             FT_Long  b_,
             FT_Long  c_ )
d362 1
a362 2
    FT_Int     s = 1;
    FT_UInt32  a, b, c;
d366 2
d369 3
a371 10
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;

    if ( c == 0 )
      a = 0x7FFFFFFFUL;
d373 1
a373 1
    else if ( a + b <= 129894UL - ( c >> 17 ) )
d376 1
a376 1
    else
d381 1
a381 1
      ft_multo64( a, b, &temp );
d384 1
a384 2
      temp2.lo = c >> 1;

d386 1
a386 4

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
d388 2
d391 2
a392 1
    a_ = (FT_Long)a;
a393 2
    return s < 0 ? -a_ : a_;
  }
d395 1
d398 3
a400 3
  FT_MulDiv_No_Round( FT_Long  a_,
                      FT_Long  b_,
                      FT_Long  c_ )
d402 1
a402 3
    FT_Int     s = 1;
    FT_UInt32  a, b, c;

a403 1
    /* XXX: this function does not allow 64-bit arguments */
d405 2
a406 7
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
    FT_MOVE_SIGN( c_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
    c = (FT_UInt32)c_;
d408 3
a410 2
    if ( c == 0 )
      a = 0x7FFFFFFFUL;
d412 1
a412 1
    else if ( a + b <= 131071UL )
d415 1
a415 1
    else
d420 2
a421 5
      ft_multo64( a, b, &temp );

      /* last attempt to ditch long division */
      a = ( temp.hi == 0 ) ? temp.lo / c
                           : ft_div64by32( temp.hi, temp.lo, c );
d423 2
d426 2
a427 1
    a_ = (FT_Long)a;
d429 1
a429 2
    return s < 0 ? -a_ : a_;
  }
d435 2
a436 2
  FT_MulFix( FT_Long  a_,
             FT_Long  b_ )
d440 1
a440 1
    return FT_MULFIX_ASSEMBLER( a_, b_ );
d451 3
a453 2
    FT_Long    sa, sb;
    FT_UInt32  a, b;
d455 2
d467 1
a467 1
     *  fills the leftmost bits by copying the sign bit.  This is wrong.
d476 4
a479 4
    sa = ( a_ >> ( sizeof ( a_ ) * 8 - 1 ) );
    a  = ( a_ ^ sa ) - sa;
    sb = ( b_ >> ( sizeof ( b_ ) * 8 - 1 ) );
    b  = ( b_ ^ sb ) - sb;
d481 2
a482 2
    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
d484 2
a485 2
    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000U ) >> 16;
d488 1
a488 1
      FT_UInt32  al = a & 0xFFFFUL;
d491 2
a492 2
      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d495 2
a496 2
    sa ^= sb;
    a   = ( a ^ sa ) - sa;
d498 1
a498 1
    return (FT_Long)a;
d502 2
a503 2
    FT_Int     s = 1;
    FT_UInt32  a, b;
d506 2
a507 1
    /* XXX: this function does not allow 64-bit arguments */
d509 2
a510 2
    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );
d512 2
a513 2
    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
d515 2
a516 2
    if ( a + ( b >> 8 ) <= 8190UL )
      a = ( a * b + 0x8000UL ) >> 16;
d519 1
a519 1
      FT_UInt32  al = a & 0xFFFFUL;
d522 2
a523 2
      a = ( a >> 16 ) * b + al * ( b >> 16 ) +
          ( ( al * ( b & 0xFFFFUL ) + 0x8000UL ) >> 16 );
d526 1
a526 3
    a_ = (FT_Long)a;

    return s < 0 ? -a_ : a_;
d536 2
a537 2
  FT_DivFix( FT_Long  a_,
             FT_Long  b_ )
d539 2
a540 3
    FT_Int     s = 1;
    FT_UInt32  a, b, q;
    FT_Long    q_;
d544 2
a545 6

    FT_MOVE_SIGN( a_, s );
    FT_MOVE_SIGN( b_, s );

    a = (FT_UInt32)a_;
    b = (FT_UInt32)b_;
d550 1
a550 1
      q = 0x7FFFFFFFUL;
d552 1
a552 1
    else if ( a <= 65535UL - ( b >> 17 ) )
d555 1
a555 1
      q = ( ( a << 16 ) + ( b >> 1 ) ) / b;
d562 41
d604 77
a680 4
      temp.hi  = a >> 16;
      temp.lo  = a << 16;
      temp2.hi = 0;
      temp2.lo = b >> 1;
d682 1
a682 2
      FT_Add64( &temp, &temp2, &temp );
      q = ft_div64by32( temp.hi, temp.lo, b );
d685 1
a685 1
    q_ = (FT_Long)q;
d687 1
a687 1
    return s < 0 ? -q_ : q_;
d690 1
d692 4
a695 1
#endif /* !FT_LONG64 */
d729 1
a729 1
      return FT_THROW( Invalid_Argument );
d736 1
a736 1
      return FT_THROW( Invalid_Argument );  /* matrix can't be inverted */
a803 98
  FT_BASE_DEF( FT_UInt32 )
  FT_Vector_NormLen( FT_Vector*  vector )
  {
    FT_Int32   x_ = vector->x;
    FT_Int32   y_ = vector->y;
    FT_Int32   b, z;
    FT_UInt32  x, y, u, v, l;
    FT_Int     sx = 1, sy = 1, shift;


    FT_MOVE_SIGN( x_, sx );
    FT_MOVE_SIGN( y_, sy );

    x = (FT_UInt32)x_;
    y = (FT_UInt32)y_;

    /* trivial cases */
    if ( x == 0 )
    {
      if ( y > 0 )
        vector->y = sy * 0x10000;
      return y;
    }
    else if ( y == 0 )
    {
      if ( x > 0 )
        vector->x = sx * 0x10000;
      return x;
    }

    /* Estimate length and prenormalize by shifting so that */
    /* the new approximate length is between 2/3 and 4/3.   */
    /* The magic constant 0xAAAAAAAAUL (2/3 of 2^32) helps  */
    /* achieve this in 16.16 fixed-point representation.    */
    l = x > y ? x + ( y >> 1 )
              : y + ( x >> 1 );

    shift  = 31 - FT_MSB( l );
    shift -= 15 + ( l >= ( 0xAAAAAAAAUL >> shift ) );

    if ( shift > 0 )
    {
      x <<= shift;
      y <<= shift;

      /* re-estimate length for tiny vectors */
      l = x > y ? x + ( y >> 1 )
                : y + ( x >> 1 );
    }
    else
    {
      x >>= -shift;
      y >>= -shift;
      l >>= -shift;
    }

    /* lower linear approximation for reciprocal length minus one */
    b = 0x10000 - (FT_Int32)l;

    x_ = (FT_Int32)x;
    y_ = (FT_Int32)y;

    /* Newton's iterations */
    do
    {
      u = (FT_UInt32)( x_ + ( x_ * b >> 16 ) );
      v = (FT_UInt32)( y_ + ( y_ * b >> 16 ) );

      /* Normalized squared length in the parentheses approaches 2^32. */
      /* On two's complement systems, converting to signed gives the   */
      /* difference with 2^32 even if the expression wraps around.     */
      z = -(FT_Int32)( u * u + v * v ) / 0x200;
      z = z * ( ( 0x10000 + b ) >> 8 ) / 0x10000;

      b += z;

    } while ( z > 0 );

    vector->x = sx < 0 ? -(FT_Pos)u : (FT_Pos)u;
    vector->y = sy < 0 ? -(FT_Pos)v : (FT_Pos)v;

    /* Conversion to signed helps to recover from likely wrap around */
    /* in calculating the prenormalized length, because it gives the */
    /* correct difference with 2^32 on two's complement systems.     */
    l = (FT_UInt32)( 0x10000 + (FT_Int32)( u * x + v * y ) / 0x10000 );
    if ( shift > 0 )
      l = ( l + ( 1 << ( shift - 1 ) ) ) >> shift;
    else
      l <<= -shift;

    return l;
  }


#if 0

  /* documentation is in ftcalc.h */

d816 1
a816 1
      rem_lo = (FT_UInt32)x;
a835 2
#endif /* 0 */

d845 34
d881 1
a881 1
    FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;
d884 4
a887 1
    return ( delta > 0 ) - ( delta < 0 );
a890 19
    FT_Int  result;


    if ( (FT_ULong)FT_ABS( in_x ) + (FT_ULong)FT_ABS( out_y ) <= 131071UL &&
         (FT_ULong)FT_ABS( in_y ) + (FT_ULong)FT_ABS( out_x ) <= 131071UL )
    {
      FT_Long  z1 = in_x * out_y;
      FT_Long  z2 = in_y * out_x;


      if ( z1 > z2 )
        result = +1;
      else if ( z1 < z2 )
        result = -1;
      else
        result = 0;
    }
    else /* products might overflow 32 bits */
    {
d895 2
a896 2
      ft_multo64( (FT_UInt32)in_x, (FT_UInt32)out_y, &z1 );
      ft_multo64( (FT_UInt32)in_y, (FT_UInt32)out_x, &z2 );
d908 2
d913 1
a913 3
    return result;

#endif
d925 2
a926 2
    FT_Pos  ax = in_x + out_x;
    FT_Pos  ay = in_y + out_y;
d928 1
a928 1
    FT_Pos  d_in, d_out, d_hypot;
d931 21
a951 26
    /* The idea of this function is to compare the length of the */
    /* hypotenuse with the `in' and `out' length.  The `corner'  */
    /* represented by `in' and `out' is flat if the hypotenuse's */
    /* length isn't too large.                                   */
    /*                                                           */
    /* This approach has the advantage that the angle between    */
    /* `in' and `out' is not checked.  In case one of the two    */
    /* vectors is `dominant', this is, much larger than the      */
    /* other vector, we thus always have a flat corner.          */
    /*                                                           */
    /*                hypotenuse                                 */
    /*       x---------------------------x                       */
    /*        \                      /                           */
    /*         \                /                                */
    /*      in  \          /  out                                */
    /*           \    /                                          */
    /*            o                                              */
    /*              Point                                        */

    d_in    = FT_HYPOT(  in_x,  in_y );
    d_out   = FT_HYPOT( out_x, out_y );
    d_hypot = FT_HYPOT(    ax,    ay );

    /* now do a simple length comparison: */
    /*                                    */
    /*   d_in + d_out < 17/16 d_hypot     */
d953 1
a953 1
    return ( d_in + d_out - d_hypot ) < ( d_hypot >> 4 );
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
