head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.21.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.47.44;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.04.53;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.44;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.30;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.07;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.36.55;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.23;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.06;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftsynth.c                                                              */
/*                                                                         */
/*    FreeType synthesizing code for emboldening and slanting (body).      */
/*                                                                         */
/*  Copyright 2000-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_SYNTHESIS_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H
#include FT_OUTLINE_H
#include FT_BITMAP_H


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_synth


  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****   EXPERIMENTAL OBLIQUING SUPPORT                                ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/

  /* documentation is in ftsynth.h */

  FT_EXPORT_DEF( void )
  FT_GlyphSlot_Oblique( FT_GlyphSlot  slot )
  {
    FT_Matrix    transform;
    FT_Outline*  outline;


    if ( !slot )
      return;

    outline = &slot->outline;

    /* only oblique outline glyphs */
    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )
      return;

    /* we don't touch the advance width */

    /* For italic, simply apply a shear transform, with an angle */
    /* of about 12 degrees.                                      */

    transform.xx = 0x10000L;
    transform.yx = 0x00000L;

    transform.xy = 0x0366AL;
    transform.yy = 0x10000L;

    FT_Outline_Transform( outline, &transform );
  }


  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****   EXPERIMENTAL EMBOLDENING SUPPORT                              ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/


  /* documentation is in ftsynth.h */

  FT_EXPORT_DEF( void )
  FT_GlyphSlot_Embolden( FT_GlyphSlot  slot )
  {
    FT_Library  library;
    FT_Face     face;
    FT_Error    error;
    FT_Pos      xstr, ystr;


    if ( !slot )
      return;

    library = slot->library;
    face    = slot->face;

    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE &&
         slot->format != FT_GLYPH_FORMAT_BITMAP  )
      return;

    /* some reasonable strength */
    xstr = FT_MulFix( face->units_per_EM,
                      face->size->metrics.y_scale ) / 24;
    ystr = xstr;

    if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
      FT_Outline_EmboldenXY( &slot->outline, xstr, ystr );

    else /* slot->format == FT_GLYPH_FORMAT_BITMAP */
    {
      /* round to full pixels */
      xstr &= ~63;
      if ( xstr == 0 )
        xstr = 1 << 6;
      ystr &= ~63;

      /*
       * XXX: overflow check for 16-bit system, for compatibility
       *      with FT_GlyphSlot_Embolden() since freetype-2.1.10.
       *      unfortunately, this function return no informations
       *      about the cause of error.
       */
      if ( ( ystr >> 6 ) > FT_INT_MAX || ( ystr >> 6 ) < FT_INT_MIN )
      {
        FT_TRACE1(( "FT_GlyphSlot_Embolden:" ));
        FT_TRACE1(( "too strong embolding parameter ystr=%d\n", ystr ));
        return;
      }
      error = FT_GlyphSlot_Own_Bitmap( slot );
      if ( error )
        return;

      error = FT_Bitmap_Embolden( library, &slot->bitmap, xstr, ystr );
      if ( error )
        return;
    }

    if ( slot->advance.x )
      slot->advance.x += xstr;

    if ( slot->advance.y )
      slot->advance.y += ystr;

    slot->metrics.width        += xstr;
    slot->metrics.height       += ystr;
    slot->metrics.horiAdvance  += xstr;
    slot->metrics.vertAdvance  += ystr;
    slot->metrics.horiBearingY += ystr;

    /* XXX: 16-bit overflow case must be excluded before here */
    if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
      slot->bitmap_top += (FT_Int)( ystr >> 6 );
  }


/* END */
@


1.4
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2010 by             */
d36 1
d51 5
a55 1
    FT_Outline*  outline = &slot->outline;
d57 1
d71 1
a71 1
    transform.xy = 0x06000L;
d81 1
a81 1
  /****   EXPERIMENTAL EMBOLDENING/OUTLINING SUPPORT                    ****/
d92 2
a93 2
    FT_Library  library = slot->library;
    FT_Face     face    = slot->face;
d98 6
d105 1
a105 1
         slot->format != FT_GLYPH_FORMAT_BITMAP )
d114 1
a114 3
    {
      /* ignore error */
      (void)FT_Outline_Embolden( &slot->outline, xstr );
d116 1
a116 6
      /* this is more than enough for most glyphs; if you need accurate */
      /* values, you have to call FT_Outline_Get_CBox                   */
      xstr = xstr * 2;
      ystr = xstr;
    }
    else if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
a152 1
    slot->metrics.horiBearingY += ystr;
a153 2
    slot->metrics.vertBearingX -= xstr / 2;
    slot->metrics.vertBearingY += ystr;
d155 1
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d21 1
d28 9
a80 23
  FT_EXPORT_DEF( FT_Error )
  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )
  {
    if ( slot && slot->format == FT_GLYPH_FORMAT_BITMAP   &&
         !( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )
    {
      FT_Bitmap  bitmap;
      FT_Error   error;


      FT_Bitmap_New( &bitmap );
      error = FT_Bitmap_Copy( slot->library, &slot->bitmap, &bitmap );
      if ( error )
        return error;

      slot->bitmap = bitmap;
      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
    }

    return FT_Err_Ok;
  }


d87 1
a87 1
    FT_Face     face    = FT_SLOT_FACE( slot );
a102 1
      error = FT_Outline_Embolden( &slot->outline, xstr );
d104 1
d113 2
a114 1
      xstr = FT_PIX_FLOOR( xstr );
d117 1
a117 1
      ystr = FT_PIX_FLOOR( ystr );
d119 12
d154 1
d156 1
a156 1
      slot->bitmap_top += ystr >> 6;
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d140 5
a144 2
    /* assume the layout is horizontal */
    slot->advance.x += xstr;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003 by                                     */
d20 1
a21 1
#include FT_INTERNAL_CALC_H
d23 1
a23 5
#include FT_TRIGONOMETRY_H
#include FT_SYNTHESIS_H


#define FT_BOLD_THRESHOLD  0x0100
d34 2
d71 2
a72 4

  static int
  ft_test_extrema( FT_Outline*  outline,
                   int          n )
d74 2
a75 13
    FT_Vector  *prev, *cur, *next;
    FT_Pos      product;
    FT_Int      c, first, last;


    /* we need to compute the `previous' and `next' point */
    /* for these extrema.                                 */
    cur  = outline->points + n;
    prev = cur - 1;
    next = cur + 1;

    first = 0;
    for ( c = 0; c < outline->n_contours; c++ )
d77 2
a78 1
      last = outline->contours[c];
a79 2
      if ( n == first )
        prev = outline->points + last;
d81 4
a84 2
      if ( n == last )
        next = outline->points + first;
d86 2
a87 1
      first = last + 1;
d90 1
a90 12
    product = FT_MulDiv( cur->x - prev->x,   /* in.x  */
                         next->y - cur->y,   /* out.y */
                         0x40 )
              -
              FT_MulDiv( cur->y - prev->y,   /* in.y  */
                         next->x - cur->x,   /* out.x */
                         0x40 );

    if ( product )
      product = product > 0 ? 1 : -1;

    return product;
d94 1
a94 83
  /* Compute the orientation of path filling.  It differs between TrueType */
  /* and Type1 formats.  We could use the `FT_OUTLINE_REVERSE_FILL' flag,  */
  /* but it is better to re-compute it directly (it seems that this flag   */
  /* isn't correctly set for some weird composite glyphs currently).       */
  /*                                                                       */
  /* We do this by computing bounding box points, and computing their      */
  /* curvature.                                                            */
  /*                                                                       */
  /* The function returns either 1 or -1.                                  */
  /*                                                                       */
  static int
  ft_get_orientation( FT_Outline*  outline )
  {
    FT_BBox  box;
    FT_BBox  indices;
    int      n, last;


    indices.xMin = -1;
    indices.yMin = -1;
    indices.xMax = -1;
    indices.yMax = -1;

    box.xMin = box.yMin =  32767;
    box.xMax = box.yMax = -32768;

    /* is it empty ? */
    if ( outline->n_contours < 1 )
      return 1;

    last = outline->contours[outline->n_contours - 1];

    for ( n = 0; n <= last; n++ )
    {
      FT_Pos  x, y;


      x = outline->points[n].x;
      if ( x < box.xMin )
      {
        box.xMin     = x;
        indices.xMin = n;
      }
      if ( x > box.xMax )
      {
        box.xMax     = x;
        indices.xMax = n;
      }

      y = outline->points[n].y;
      if ( y < box.yMin )
      {
        box.yMin     = y;
        indices.yMin = n;
      }
      if ( y > box.yMax )
      {
        box.yMax     = y;
        indices.yMax = n;
      }
    }

    /* test orientation of the xmin */
    n = ft_test_extrema( outline, indices.xMin );
    if ( n )
      goto Exit;

    n = ft_test_extrema( outline, indices.yMin );
    if ( n )
      goto Exit;

    n = ft_test_extrema( outline, indices.xMax );
    if ( n )
      goto Exit;

    n = ft_test_extrema( outline, indices.yMax );
    if ( !n )
      n = 1;

  Exit:
    return n;
  }

d99 4
a102 7
    FT_Vector*   points;
    FT_Vector    v_prev, v_first, v_next, v_cur;
    FT_Pos       distance;
    FT_Outline*  outline = &slot->outline;
    FT_Face      face = FT_SLOT_FACE( slot );
    FT_Angle     rotate, angle_in, angle_out;
    FT_Int       c, n, first, orientation;
d105 2
a106 2
    /* only embolden outline glyph images */
    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )
d109 4
a112 3
    /* compute control distance */
    distance = FT_MulFix( face->units_per_EM / 60,
                          face->size->metrics.y_scale );
d114 4
a117 2
    orientation = ft_get_orientation( outline );
    rotate      = FT_ANGLE_PI2*orientation;
d119 6
a124 4
    points = outline->points;

    first = 0;
    for ( c = 0; c < outline->n_contours; c++ )
d126 13
a138 6
      int  last = outline->contours[c];


      v_first = points[first];
      v_prev  = points[last];
      v_cur   = v_first;
d140 2
a141 6
      for ( n = first; n <= last; n++ )
      {
        FT_Pos     d;
        FT_Vector  in, out;
        FT_Fixed   scale;
        FT_Angle   angle_diff;
d143 7
d151 2
a152 39
        if ( n < last ) v_next = points[n + 1];
        else            v_next = v_first;

        /* compute the in and out vectors */
        in.x  = v_cur.x - v_prev.x;
        in.y  = v_cur.y - v_prev.y;

        out.x = v_next.x - v_cur.x;
        out.y = v_next.y - v_cur.y;

        angle_in   = FT_Atan2( in.x, in.y );
        angle_out  = FT_Atan2( out.x, out.y );
        angle_diff = FT_Angle_Diff( angle_in, angle_out );
        scale      = FT_Cos( angle_diff/2 );

        if ( scale < 0x400L && scale > -0x400L )
        {
          if ( scale >= 0 )
            scale = 0x400L;
          else
            scale = -0x400L;
        }

        d = FT_DivFix( distance, scale );

        FT_Vector_From_Polar( &in, d, angle_in + angle_diff/2 - rotate );

        outline->points[n].x = v_cur.x + distance + in.x;
        outline->points[n].y = v_cur.y + distance + in.y;

        v_prev = v_cur;
        v_cur  = v_next;
      }

      first = last + 1;
    }

    slot->metrics.horiAdvance =
      ( slot->metrics.horiAdvance + distance*4 ) & ~63;
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a19 1
#include FT_SYNTHESIS_H
d21 1
d23 5
a27 1
#include FT_BITMAP_H
a37 2
  /* documentation is in ftsynth.h */

d73 4
a76 2
  FT_EXPORT_DEF( FT_Error )
  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )
d78 13
a90 2
    if ( slot && slot->format == FT_GLYPH_FORMAT_BITMAP   &&
         !( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )
d92 1
a92 2
      FT_Bitmap  bitmap;
      FT_Error   error;
d94 2
d97 2
a98 4
      FT_Bitmap_New( &bitmap );
      error = FT_Bitmap_Copy( slot->library, &slot->bitmap, &bitmap );
      if ( error )
        return error;
d100 1
a100 2
      slot->bitmap = bitmap;
      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
d103 12
a114 1
    return FT_Err_Ok;
d118 83
a200 1
  /* documentation is in ftsynth.h */
d205 7
a211 4
    FT_Library  library = slot->library;
    FT_Face     face    = FT_SLOT_FACE( slot );
    FT_Error    error;
    FT_Pos      xstr, ystr;
d214 2
a215 2
    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE &&
         slot->format != FT_GLYPH_FORMAT_BITMAP )
d218 3
a220 4
    /* some reasonable strength */
    xstr = FT_MulFix( face->units_per_EM,
                      face->size->metrics.y_scale ) / 24;
    ystr = xstr;
d222 7
a228 1
    if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
d230 13
a242 2
      error = FT_Outline_Embolden( &slot->outline, xstr );
      /* ignore error */
a243 20
      /* this is more than enough for most glyphs; if you need accurate */
      /* values, you have to call FT_Outline_Get_CBox                   */
      xstr = xstr * 2;
      ystr = xstr;
    }
    else if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
    {
      xstr = FT_PIX_FLOOR( xstr );
      if ( xstr == 0 )
        xstr = 1 << 6;
      ystr = FT_PIX_FLOOR( ystr );

      error = FT_GlyphSlot_Own_Bitmap( slot );
      if ( error )
        return;

      error = FT_Bitmap_Embolden( library, &slot->bitmap, xstr, ystr );
      if ( error )
        return;
    }
d245 29
a273 2
    if ( slot->advance.x )
      slot->advance.x += xstr;
d275 3
a277 2
    if ( slot->advance.y )
      slot->advance.y += ystr;
d279 2
a280 7
    slot->metrics.width        += xstr;
    slot->metrics.height       += ystr;
    slot->metrics.horiBearingY += ystr;
    slot->metrics.horiAdvance  += xstr;
    slot->metrics.vertBearingX -= xstr / 2;
    slot->metrics.vertBearingY += ystr;
    slot->metrics.vertAdvance  += ystr;
d282 2
a283 2
    if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
      slot->bitmap_top += ystr >> 6;
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a19 1
#include FT_SYNTHESIS_H
d21 1
d23 5
a27 1
#include FT_BITMAP_H
a37 2
  /* documentation is in ftsynth.h */

d73 4
a76 2
  FT_EXPORT_DEF( FT_Error )
  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )
d78 13
a90 2
    if ( slot && slot->format == FT_GLYPH_FORMAT_BITMAP   &&
         !( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )
d92 1
a92 2
      FT_Bitmap  bitmap;
      FT_Error   error;
d94 2
d97 2
a98 4
      FT_Bitmap_New( &bitmap );
      error = FT_Bitmap_Copy( slot->library, &slot->bitmap, &bitmap );
      if ( error )
        return error;
d100 1
a100 2
      slot->bitmap = bitmap;
      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
d103 12
a114 1
    return FT_Err_Ok;
d118 83
a200 1
  /* documentation is in ftsynth.h */
d205 7
a211 4
    FT_Library  library = slot->library;
    FT_Face     face    = FT_SLOT_FACE( slot );
    FT_Error    error;
    FT_Pos      xstr, ystr;
d214 2
a215 2
    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE &&
         slot->format != FT_GLYPH_FORMAT_BITMAP )
d218 6
a223 4
    /* some reasonable strength */
    xstr = FT_MulFix( face->units_per_EM,
                      face->size->metrics.y_scale ) / 24;
    ystr = xstr;
d225 4
a228 1
    if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
d230 14
a243 2
      error = FT_Outline_Embolden( &slot->outline, xstr );
      /* ignore error */
d245 29
a273 20
      /* this is more than enough for most glyphs; if you need accurate */
      /* values, you have to call FT_Outline_Get_CBox                   */
      xstr = xstr * 2;
      ystr = xstr;
    }
    else if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
    {
      xstr = FT_PIX_FLOOR( xstr );
      if ( xstr == 0 )
        xstr = 1 << 6;
      ystr = FT_PIX_FLOOR( ystr );

      error = FT_GlyphSlot_Own_Bitmap( slot );
      if ( error )
        return;

      error = FT_Bitmap_Embolden( library, &slot->bitmap, xstr, ystr );
      if ( error )
        return;
    }
d275 3
a277 2
    /* assume the layout is horizontal */
    slot->advance.x += xstr;
d279 2
a280 7
    slot->metrics.width        += xstr;
    slot->metrics.height       += ystr;
    slot->metrics.horiBearingY += ystr;
    slot->metrics.horiAdvance  += xstr;
    slot->metrics.vertBearingX -= xstr / 2;
    slot->metrics.vertBearingY += ystr;
    slot->metrics.vertAdvance  += ystr;
d282 2
a283 2
    if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
      slot->bitmap_top += ystr >> 6;
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2010 by             */
a20 1
#include FT_INTERNAL_DEBUG_H
a26 9
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_synth

  /*************************************************************************/
d71 23
d100 1
a100 1
    FT_Face     face    = slot->face;
d116 1
a117 1
      (void)FT_Outline_Embolden( &slot->outline, xstr );
d126 1
a126 2
      /* round to full pixels */
      xstr &= ~63;
d129 1
a129 1
      ystr &= ~63;
a130 12
      /*
       * XXX: overflow check for 16-bit system, for compatibility
       *      with FT_GlyphSlot_Embolden() since freetype-2.1.10.
       *      unfortunately, this function return no informations
       *      about the cause of error.
       */
      if ( ( ystr >> 6 ) > FT_INT_MAX || ( ystr >> 6 ) < FT_INT_MIN )
      {
        FT_TRACE1(( "FT_GlyphSlot_Embolden:" ));
        FT_TRACE1(( "too strong embolding parameter ystr=%d\n", ystr ));
        return;
      }
d140 2
a141 5
    if ( slot->advance.x )
      slot->advance.x += xstr;

    if ( slot->advance.y )
      slot->advance.y += ystr;
a150 1
    /* XXX: 16-bit overflow case must be excluded before here */
d152 1
a152 1
      slot->bitmap_top += (FT_Int)( ystr >> 6 );
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2000-2016 by                                                 */
a35 1

d50 1
a50 5
    FT_Outline*  outline;


    if ( !slot )
      return;
a51 1
    outline = &slot->outline;
d65 1
a65 1
    transform.xy = 0x0366AL;
d75 1
a75 1
  /****   EXPERIMENTAL EMBOLDENING SUPPORT                              ****/
d86 2
a87 2
    FT_Library  library;
    FT_Face     face;
a91 6
    if ( !slot )
      return;

    library = slot->library;
    face    = slot->face;

d93 1
a93 1
         slot->format != FT_GLYPH_FORMAT_BITMAP  )
d102 3
a104 1
      FT_Outline_EmboldenXY( &slot->outline, xstr, ystr );
d106 6
a111 1
    else /* slot->format == FT_GLYPH_FORMAT_BITMAP */
d148 1
d150 2
a152 1
    slot->metrics.horiBearingY += ystr;
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
