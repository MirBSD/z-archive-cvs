head	1.4;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.2
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.4
date	2017.04.15.19.21.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	10058F2723111C7BEE2;

1.3
date	2013.08.06.19.47.49;	author tg;	state Exp;
branches;
next	1.2;
commitid	100520152445E05B912;

1.2
date	2006.06.29.20.24.47;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.45;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.12;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.12;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.24;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.00;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.4
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftcmanag.c                                                             */
/*                                                                         */
/*    FreeType Cache Manager (body).                                       */
/*                                                                         */
/*  Copyright 2000-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_CACHE_H
#include "ftcmanag.h"
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_DEBUG_H
#include FT_SIZES_H

#include "ftccback.h"
#include "ftcerror.h"

#ifdef FT_CONFIG_OPTION_PIC
#error "cache system does not support PIC yet"
#endif


#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cache


  static FT_Error
  ftc_scaler_lookup_size( FTC_Manager  manager,
                          FTC_Scaler   scaler,
                          FT_Size     *asize )
  {
    FT_Face   face;
    FT_Size   size = NULL;
    FT_Error  error;


    error = FTC_Manager_LookupFace( manager, scaler->face_id, &face );
    if ( error )
      goto Exit;

    error = FT_New_Size( face, &size );
    if ( error )
      goto Exit;

    FT_Activate_Size( size );

    if ( scaler->pixel )
      error = FT_Set_Pixel_Sizes( face, scaler->width, scaler->height );
    else
      error = FT_Set_Char_Size( face,
                                (FT_F26Dot6)scaler->width,
                                (FT_F26Dot6)scaler->height,
                                scaler->x_res,
                                scaler->y_res );
    if ( error )
    {
      FT_Done_Size( size );
      size = NULL;
    }

  Exit:
    *asize = size;
    return error;
  }


  typedef struct  FTC_SizeNodeRec_
  {
    FTC_MruNodeRec  node;
    FT_Size         size;
    FTC_ScalerRec   scaler;

  } FTC_SizeNodeRec, *FTC_SizeNode;

#define FTC_SIZE_NODE( x ) ( (FTC_SizeNode)( x ) )


  FT_CALLBACK_DEF( void )
  ftc_size_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   data )
  {
    FTC_SizeNode  node = (FTC_SizeNode)ftcnode;
    FT_Size       size = node->size;
    FT_UNUSED( data );


    if ( size )
      FT_Done_Size( size );
  }


  FT_CALLBACK_DEF( FT_Bool )
  ftc_size_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcscaler )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Scaler    scaler0 = &node->scaler;


    if ( FTC_SCALER_COMPARE( scaler0, scaler ) )
    {
      FT_Activate_Size( node->size );
      return 1;
    }
    return 0;
  }


  FT_CALLBACK_DEF( FT_Error )
  ftc_size_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcscaler,
                      FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


    node->scaler = scaler[0];

    return ftc_scaler_lookup_size( manager, scaler, &node->size );
  }


  FT_CALLBACK_DEF( FT_Error )
  ftc_size_node_reset( FTC_MruNode  ftcnode,
                       FT_Pointer   ftcscaler,
                       FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


    FT_Done_Size( node->size );

    node->scaler = scaler[0];

    return ftc_scaler_lookup_size( manager, scaler, &node->size );
  }


  static
  const FTC_MruListClassRec  ftc_size_list_class =
  {
    sizeof ( FTC_SizeNodeRec ),

    ftc_size_node_compare,  /* FTC_MruNode_CompareFunc  node_compare */
    ftc_size_node_init,     /* FTC_MruNode_InitFunc     node_init    */
    ftc_size_node_reset,    /* FTC_MruNode_ResetFunc    node_reset   */
    ftc_size_node_done      /* FTC_MruNode_DoneFunc     node_done    */
  };


  /* helper function used by ftc_face_node_done */
  static FT_Bool
  ftc_size_node_compare_faceid( FTC_MruNode  ftcnode,
                                FT_Pointer   ftcface_id )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


    return FT_BOOL( node->scaler.face_id == face_id );
  }


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_LookupSize( FTC_Manager  manager,
                          FTC_Scaler   scaler,
                          FT_Size     *asize )
  {
    FT_Error     error;
    FTC_MruNode  mrunode;


    if ( !asize || !scaler )
      return FT_THROW( Invalid_Argument );

    *asize = NULL;

    if ( !manager )
      return FT_THROW( Invalid_Cache_Handle );

#ifdef FTC_INLINE

    FTC_MRULIST_LOOKUP_CMP( &manager->sizes, scaler, ftc_size_node_compare,
                            mrunode, error );

#else
    error = FTC_MruList_Lookup( &manager->sizes, scaler, &mrunode );
#endif

    if ( !error )
      *asize = FTC_SIZE_NODE( mrunode )->size;

    return error;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    FACE MRU IMPLEMENTATION                    *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct  FTC_FaceNodeRec_
  {
    FTC_MruNodeRec  node;
    FTC_FaceID      face_id;
    FT_Face         face;

  } FTC_FaceNodeRec, *FTC_FaceNode;

#define FTC_FACE_NODE( x ) ( ( FTC_FaceNode )( x ) )


  FT_CALLBACK_DEF( FT_Error )
  ftc_face_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcface_id,
                      FT_Pointer   ftcmanager )
  {
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;
    FT_Error      error;


    node->face_id = face_id;

    error = manager->request_face( face_id,
                                   manager->library,
                                   manager->request_data,
                                   &node->face );
    if ( !error )
    {
      /* destroy initial size object; it will be re-created later */
      if ( node->face->size )
        FT_Done_Size( node->face->size );
    }

    return error;
  }


  FT_CALLBACK_DEF( void )
  ftc_face_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcmanager )
  {
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


    /* we must begin by removing all scalers for the target face */
    /* from the manager's list                                   */
    FTC_MruList_RemoveSelection( &manager->sizes,
                                 ftc_size_node_compare_faceid,
                                 node->face_id );

    /* all right, we can discard the face now */
    FT_Done_Face( node->face );
    node->face    = NULL;
    node->face_id = NULL;
  }


  FT_CALLBACK_DEF( FT_Bool )
  ftc_face_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcface_id )
  {
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


    return FT_BOOL( node->face_id == face_id );
  }


  static
  const FTC_MruListClassRec  ftc_face_list_class =
  {
    sizeof ( FTC_FaceNodeRec),

    ftc_face_node_compare,  /* FTC_MruNode_CompareFunc  node_compare */
    ftc_face_node_init,     /* FTC_MruNode_InitFunc     node_init    */
    NULL,                   /* FTC_MruNode_ResetFunc    node_reset   */
    ftc_face_node_done      /* FTC_MruNode_DoneFunc     node_done    */
  };


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_LookupFace( FTC_Manager  manager,
                          FTC_FaceID   face_id,
                          FT_Face     *aface )
  {
    FT_Error     error;
    FTC_MruNode  mrunode;


    if ( !aface )
      return FT_THROW( Invalid_Argument );

    *aface = NULL;

    if ( !manager )
      return FT_THROW( Invalid_Cache_Handle );

    /* we break encapsulation for the sake of speed */
#ifdef FTC_INLINE

    FTC_MRULIST_LOOKUP_CMP( &manager->faces, face_id, ftc_face_node_compare,
                            mrunode, error );

#else
    error = FTC_MruList_Lookup( &manager->faces, face_id, &mrunode );
#endif

    if ( !error )
      *aface = FTC_FACE_NODE( mrunode )->face;

    return error;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    CACHE MANAGER ROUTINES                     *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_New( FT_Library          library,
                   FT_UInt             max_faces,
                   FT_UInt             max_sizes,
                   FT_ULong            max_bytes,
                   FTC_Face_Requester  requester,
                   FT_Pointer          req_data,
                   FTC_Manager        *amanager )
  {
    FT_Error     error;
    FT_Memory    memory;
    FTC_Manager  manager = 0;


    if ( !library )
      return FT_THROW( Invalid_Library_Handle );

    if ( !amanager || !requester )
      return FT_THROW( Invalid_Argument );

    memory = library->memory;

    if ( FT_NEW( manager ) )
      goto Exit;

    if ( max_faces == 0 )
      max_faces = FTC_MAX_FACES_DEFAULT;

    if ( max_sizes == 0 )
      max_sizes = FTC_MAX_SIZES_DEFAULT;

    if ( max_bytes == 0 )
      max_bytes = FTC_MAX_BYTES_DEFAULT;

    manager->library      = library;
    manager->memory       = memory;
    manager->max_weight   = max_bytes;

    manager->request_face = requester;
    manager->request_data = req_data;

    FTC_MruList_Init( &manager->faces,
                      &ftc_face_list_class,
                      max_faces,
                      manager,
                      memory );

    FTC_MruList_Init( &manager->sizes,
                      &ftc_size_list_class,
                      max_sizes,
                      manager,
                      memory );

    *amanager = manager;

  Exit:
    return error;
  }


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( void )
  FTC_Manager_Done( FTC_Manager  manager )
  {
    FT_Memory  memory;
    FT_UInt    idx;


    if ( !manager || !manager->library )
      return;

    memory = manager->memory;

    /* now discard all caches */
    for (idx = manager->num_caches; idx-- > 0; )
    {
      FTC_Cache  cache = manager->caches[idx];


      if ( cache )
      {
        cache->clazz.cache_done( cache );
        FT_FREE( cache );
        manager->caches[idx] = NULL;
      }
    }
    manager->num_caches = 0;

    /* discard faces and sizes */
    FTC_MruList_Done( &manager->sizes );
    FTC_MruList_Done( &manager->faces );

    manager->library = NULL;
    manager->memory  = NULL;

    FT_FREE( manager );
  }


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( void )
  FTC_Manager_Reset( FTC_Manager  manager )
  {
    if ( !manager )
      return;

    FTC_MruList_Reset( &manager->sizes );
    FTC_MruList_Reset( &manager->faces );

    FTC_Manager_FlushN( manager, manager->num_nodes );
  }


#ifdef FT_DEBUG_ERROR

  static void
  FTC_Manager_Check( FTC_Manager  manager )
  {
    FTC_Node  node, first;


    first = manager->nodes_list;

    /* check node weights */
    if ( first )
    {
      FT_Offset  weight = 0;


      node = first;

      do
      {
        FTC_Cache  cache = manager->caches[node->cache_index];


        if ( (FT_UInt)node->cache_index >= manager->num_caches )
          FT_TRACE0(( "FTC_Manager_Check: invalid node (cache index = %ld\n",
                      node->cache_index ));
        else
          weight += cache->clazz.node_weight( node, cache );

        node = FTC_NODE_NEXT( node );

      } while ( node != first );

      if ( weight != manager->cur_weight )
        FT_TRACE0(( "FTC_Manager_Check: invalid weight %ld instead of %ld\n",
                    manager->cur_weight, weight ));
    }

    /* check circular list */
    if ( first )
    {
      FT_UFast  count = 0;


      node = first;
      do
      {
        count++;
        node = FTC_NODE_NEXT( node );

      } while ( node != first );

      if ( count != manager->num_nodes )
        FT_TRACE0(( "FTC_Manager_Check:"
                    " invalid cache node count %d instead of %d\n",
                    manager->num_nodes, count ));
    }
  }

#endif /* FT_DEBUG_ERROR */


  /* `Compress' the manager's data, i.e., get rid of old cache nodes */
  /* that are not referenced anymore in order to limit the total     */
  /* memory used by the cache.                                       */

  /* documentation is in ftcmanag.h */

  FT_LOCAL_DEF( void )
  FTC_Manager_Compress( FTC_Manager  manager )
  {
    FTC_Node   node, first;


    if ( !manager )
      return;

    first = manager->nodes_list;

#ifdef FT_DEBUG_ERROR
    FTC_Manager_Check( manager );

    FT_TRACE0(( "compressing, weight = %ld, max = %ld, nodes = %d\n",
                manager->cur_weight, manager->max_weight,
                manager->num_nodes ));
#endif

    if ( manager->cur_weight < manager->max_weight || !first )
      return;

    /* go to last node -- it's a circular list */
    node = FTC_NODE_PREV( first );
    do
    {
      FTC_Node  prev;


      prev = ( node == first ) ? NULL : FTC_NODE_PREV( node );

      if ( node->ref_count <= 0 )
        ftc_node_destroy( node, manager );

      node = prev;

    } while ( node && manager->cur_weight > manager->max_weight );
  }


  /* documentation is in ftcmanag.h */

  FT_LOCAL_DEF( FT_Error )
  FTC_Manager_RegisterCache( FTC_Manager      manager,
                             FTC_CacheClass   clazz,
                             FTC_Cache       *acache )
  {
    FT_Error   error = FT_ERR( Invalid_Argument );
    FTC_Cache  cache = NULL;


    if ( manager && clazz && acache )
    {
      FT_Memory  memory = manager->memory;


      if ( manager->num_caches >= FTC_MAX_CACHES )
      {
        error = FT_THROW( Too_Many_Caches );
        FT_ERROR(( "FTC_Manager_RegisterCache:"
                   " too many registered caches\n" ));
        goto Exit;
      }

      if ( !FT_ALLOC( cache, clazz->cache_size ) )
      {
        cache->manager   = manager;
        cache->memory    = memory;
        cache->clazz     = clazz[0];
        cache->org_class = clazz;

        /* THIS IS VERY IMPORTANT!  IT WILL WRETCH THE MANAGER */
        /* IF IT IS NOT SET CORRECTLY                          */
        cache->index = manager->num_caches;

        error = clazz->cache_init( cache );
        if ( error )
        {
          clazz->cache_done( cache );
          FT_FREE( cache );
          goto Exit;
        }

        manager->caches[manager->num_caches++] = cache;
      }
    }

  Exit:
    if ( acache )
      *acache = cache;
    return error;
  }


  FT_LOCAL_DEF( FT_UInt )
  FTC_Manager_FlushN( FTC_Manager  manager,
                      FT_UInt      count )
  {
    FTC_Node  first = manager->nodes_list;
    FTC_Node  node;
    FT_UInt   result;


    /* try to remove `count' nodes from the list */
    if ( !first )  /* empty list! */
      return 0;

    /* go to last node - it's a circular list */
    node = FTC_NODE_PREV(first);
    for ( result = 0; result < count; )
    {
      FTC_Node  prev = FTC_NODE_PREV( node );


      /* don't touch locked nodes */
      if ( node->ref_count <= 0 )
      {
        ftc_node_destroy( node, manager );
        result++;
      }

      if ( node == first )
        break;

      node = prev;
    }
    return  result;
  }


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( void )
  FTC_Manager_RemoveFaceID( FTC_Manager  manager,
                            FTC_FaceID   face_id )
  {
    FT_UInt  nn;


    if ( !manager )
      return;

    /* this will remove all FTC_SizeNode that correspond to
     * the face_id as well
     */
    FTC_MruList_RemoveSelection( &manager->faces,
                                 ftc_face_node_compare,
                                 face_id );

    for ( nn = 0; nn < manager->num_caches; nn++ )
      FTC_Cache_RemoveFaceID( manager->caches[nn], face_id );
  }


  /* documentation is in ftcache.h */

  FT_EXPORT_DEF( void )
  FTC_Node_Unref( FTC_Node     node,
                  FTC_Manager  manager )
  {
    if ( node                                             &&
         manager                                          &&
         (FT_UInt)node->cache_index < manager->num_caches )
      node->ref_count--;
  }


/* END */
@


1.3
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009 by       */
d31 1
a31 1
#endif 
a36 2
#define FTC_LRU_GET_MANAGER( lru )  ( (FTC_Manager)(lru)->user_data )

d61 5
a65 2
      error = FT_Set_Char_Size( face, scaler->width, scaler->height,
                                scaler->x_res, scaler->y_res );
d155 1
a155 1
  FT_CALLBACK_TABLE_DEF
d159 5
a163 4
    ftc_size_node_compare,
    ftc_size_node_init,
    ftc_size_node_reset,
    ftc_size_node_done
d191 2
a192 2
    if ( asize == NULL )
      return FTC_Err_Invalid_Argument;
d197 1
a197 1
      return FTC_Err_Invalid_Cache_Handle;
d295 1
a295 1
  FT_CALLBACK_TABLE_DEF
d300 4
a303 4
    ftc_face_node_compare,
    ftc_face_node_init,
    0,                          /* FTC_MruNode_ResetFunc */
    ftc_face_node_done
d318 2
a319 2
    if ( aface == NULL )
      return FTC_Err_Invalid_Argument;
d324 1
a324 1
      return FTC_Err_Invalid_Cache_Handle;
d369 4
a372 1
      return FTC_Err_Invalid_Library_Handle;
d459 7
a465 6
    if ( manager )
    {
      FTC_MruList_Reset( &manager->sizes );
      FTC_MruList_Reset( &manager->faces );
    }
    /* XXX: FIXME: flush the caches? */
d482 1
a482 1
      FT_ULong  weight = 0;
d498 1
a498 1
        node = FTC_NODE__NEXT( node );
d517 1
a517 1
        node = FTC_NODE__NEXT( node );
d556 1
a556 1
    if ( manager->cur_weight < manager->max_weight || first == NULL )
d560 1
a560 1
    node = FTC_NODE__PREV( first );
d566 1
a566 1
      prev = ( node == first ) ? NULL : FTC_NODE__PREV( node );
d584 1
a584 1
    FT_Error   error = FTC_Err_Invalid_Argument;
d595 1
a595 1
        error = FTC_Err_Too_Many_Caches;
d641 1
a641 1
    if ( first == NULL )  /* empty list! */
d645 1
a645 1
    node = FTC_NODE__PREV(first);
d648 1
a648 1
      FTC_Node  prev = FTC_NODE__PREV( node );
d675 4
d683 1
a683 1
                                 (FTC_MruNode_CompareFunc)NULL,
d697 3
a699 1
    if ( node && (FT_UInt)node->cache_index < manager->num_caches )
a703 51
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_Lookup_Face( FTC_Manager  manager,
                           FTC_FaceID   face_id,
                           FT_Face     *aface )
  {
    return FTC_Manager_LookupFace( manager, face_id, aface );
  }


  FT_EXPORT( FT_Error )
  FTC_Manager_Lookup_Size( FTC_Manager  manager,
                           FTC_Font     font,
                           FT_Face     *aface,
                           FT_Size     *asize )
  {
    FTC_ScalerRec  scaler;
    FT_Error       error;
    FT_Size        size;
    FT_Face        face;


    scaler.face_id = font->face_id;
    scaler.width   = font->pix_width;
    scaler.height  = font->pix_height;
    scaler.pixel   = TRUE;
    scaler.x_res   = 0;
    scaler.y_res   = 0;

    error = FTC_Manager_LookupSize( manager, &scaler, &size );
    if ( error )
    {
      face = NULL;
      size = NULL;
    }
    else
      face = size->face;

    if ( aface )
      *aface = face;

    if ( asize )
      *asize = size;

    return error;
  }

#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */


@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d29 4
d85 2
d185 2
a186 2
    FT_Error      error;
    FTC_SizeNode  node;
d190 1
a190 1
      return FTC_Err_Bad_Argument;
d200 1
a200 1
                            node, error );
d203 1
a203 1
    error = FTC_MruList_Lookup( &manager->sizes, scaler, (FTC_MruNode*)&node );
d207 1
a207 1
      *asize = node->size;
d229 2
d312 2
a313 2
    FT_Error      error;
    FTC_FaceNode  node;
d317 1
a317 1
      return FTC_Err_Bad_Argument;
d328 1
a328 1
                            node, error );
d331 1
a331 1
    error = FTC_MruList_Lookup( &manager->faces, face_id, (FTC_MruNode*)&node );
d335 1
a335 1
      *aface = node->face;
d487 2
a488 2
          FT_ERROR(( "FTC_Manager_Check: invalid node (cache index = %ld\n",
                     node->cache_index ));
d497 2
a498 2
        FT_ERROR(( "FTC_Manager_Check: invalid weight %ld instead of %ld\n",
                   manager->cur_weight, weight ));
d516 3
a518 3
        FT_ERROR((
          "FTC_Manager_Check: invalid cache node count %d instead of %d\n",
          manager->num_nodes, count ));
d545 3
a547 3
    FT_ERROR(( "compressing, weight = %ld, max = %ld, nodes = %d\n",
               manager->cur_weight, manager->max_weight,
               manager->num_nodes ));
d590 2
a591 2
        FT_ERROR(( "%s: too many registered caches\n",
                   "FTC_Manager_Register_Cache" ));
d619 2
a620 1
    *acache = cache;
d672 3
a674 1
    FTC_MruList_RemoveSelection( &manager->faces, NULL, face_id );
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004 by                               */
d21 1
a21 1
#include FT_CACHE_INTERNAL_MANAGER_H
d26 1
d83 2
a84 1
  ftc_size_node_done( FTC_SizeNode  node )
d86 3
a88 1
    FT_Size  size = node->size;
d97 2
a98 2
  ftc_size_node_compare( FTC_SizeNode  node,
                         FTC_Scaler    scaler )
d100 3
a102 1
    FTC_Scaler  scaler0 = &node->scaler;
d115 9
a123 4
  ftc_size_node_init( FTC_SizeNode  node,
                      FTC_Scaler    scaler,
                      FTC_Manager   manager )
  {
d131 9
a139 4
  ftc_size_node_reset( FTC_SizeNode  node,
                       FTC_Scaler    scaler,
                       FTC_Manager   manager )
  {
d151 5
a155 5
    sizeof( FTC_SizeNodeRec ),
    (FTC_MruNode_CompareFunc)ftc_size_node_compare,
    (FTC_MruNode_InitFunc)   ftc_size_node_init,
    (FTC_MruNode_ResetFunc)  ftc_size_node_reset,
    (FTC_MruNode_DoneFunc)   ftc_size_node_done
d161 2
a162 2
  ftc_size_node_compare_faceid( FTC_SizeNode  node,
                                FTC_FaceID    face_id )
d164 4
d172 2
d225 8
a232 5
  ftc_face_node_init( FTC_FaceNode  node,
                      FTC_FaceID    face_id,
                      FTC_Manager   manager )
  {
    FT_Error  error;
d253 2
a254 2
  ftc_face_node_done( FTC_FaceNode  node,
                      FTC_Manager   manager )
d256 4
d262 3
a264 4
    FTC_MruList_RemoveSelection(
      & manager->sizes,
      (FTC_MruNode_CompareFunc)ftc_size_node_compare_faceid,
      node->face_id );
d274 2
a275 2
  ftc_face_node_compare( FTC_FaceNode  node,
                         FTC_FaceID    face_id )
d277 4
d288 1
a288 1
    sizeof( FTC_FaceNodeRec),
d290 4
a293 4
    (FTC_MruNode_CompareFunc)ftc_face_node_compare,
    (FTC_MruNode_InitFunc)   ftc_face_node_init,
    (FTC_MruNode_ResetFunc)  NULL,
    (FTC_MruNode_DoneFunc)   ftc_face_node_done
d457 1
a457 1
  FT_EXPORT_DEF( void )
d523 1
a523 1
  FT_EXPORT_DEF( void )
d565 1
a565 1
  FT_EXPORT_DEF( FT_Error )
d616 1
a616 1
  FT_EXPORT_DEF( FT_UInt )
d643 1
a643 1
      if ( prev == manager->nodes_list )
d652 2
d670 1
a670 1
  /* documentation is in ftcmanag.h */
d681 51
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d21 1
a21 1
#include "ftcmanag.h"
a25 1
#include "ftccback.h"
d82 1
a82 2
  ftc_size_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   data )
d84 1
a84 3
    FTC_SizeNode  node = (FTC_SizeNode)ftcnode;
    FT_Size       size = node->size;
    FT_UNUSED( data );
d93 2
a94 2
  ftc_size_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcscaler )
d96 1
a96 3
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Scaler    scaler0 = &node->scaler;
d109 4
a112 9
  ftc_size_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcscaler,
                      FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d120 4
a123 9
  ftc_size_node_reset( FTC_MruNode  ftcnode,
                       FT_Pointer   ftcscaler,
                       FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d135 5
a139 5
    sizeof ( FTC_SizeNodeRec ),
    ftc_size_node_compare,
    ftc_size_node_init,
    ftc_size_node_reset,
    ftc_size_node_done
d145 2
a146 2
  ftc_size_node_compare_faceid( FTC_MruNode  ftcnode,
                                FT_Pointer   ftcface_id )
a147 4
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


a151 2
  /* documentation is in ftcache.h */

d203 5
a207 8
  ftc_face_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcface_id,
                      FT_Pointer   ftcmanager )
  {
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;
    FT_Error      error;
d228 2
a229 2
  ftc_face_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcmanager )
a230 4
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d233 4
a236 3
    FTC_MruList_RemoveSelection( &manager->sizes,
                                 ftc_size_node_compare_faceid,
                                 node->face_id );
d246 2
a247 2
  ftc_face_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcface_id )
a248 4
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


d256 1
a256 1
    sizeof ( FTC_FaceNodeRec),
d258 4
a261 4
    ftc_face_node_compare,
    ftc_face_node_init,
    0,                          /* FTC_MruNode_ResetFunc */
    ftc_face_node_done
d425 1
a425 1
  static void
d491 1
a491 1
  FT_LOCAL_DEF( void )
d533 1
a533 1
  FT_LOCAL_DEF( FT_Error )
d584 1
a584 1
  FT_LOCAL_DEF( FT_UInt )
d611 1
a611 1
      if ( node == first )
a619 2
  /* documentation is in ftcache.h */

d636 1
a636 1
  /* documentation is in ftcache.h */
a646 51
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_Lookup_Face( FTC_Manager  manager,
                           FTC_FaceID   face_id,
                           FT_Face     *aface )
  {
    return FTC_Manager_LookupFace( manager, face_id, aface );
  }


  FT_EXPORT( FT_Error )
  FTC_Manager_Lookup_Size( FTC_Manager  manager,
                           FTC_Font     font,
                           FT_Face     *aface,
                           FT_Size     *asize )
  {
    FTC_ScalerRec  scaler;
    FT_Error       error;
    FT_Size        size;
    FT_Face        face;


    scaler.face_id = font->face_id;
    scaler.width   = font->pix_width;
    scaler.height  = font->pix_height;
    scaler.pixel   = TRUE;
    scaler.x_res   = 0;
    scaler.y_res   = 0;

    error = FTC_Manager_LookupSize( manager, &scaler, &size );
    if ( error )
    {
      face = NULL;
      size = NULL;
    }
    else
      face = size->face;

    if ( aface )
      *aface = face;

    if ( asize )
      *asize = size;

    return error;
  }

#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */


@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d21 1
a21 1
#include "ftcmanag.h"
a25 1
#include "ftccback.h"
d82 1
a82 2
  ftc_size_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   data )
d84 1
a84 3
    FTC_SizeNode  node = (FTC_SizeNode)ftcnode;
    FT_Size       size = node->size;
    FT_UNUSED( data );
d93 2
a94 2
  ftc_size_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcscaler )
d96 1
a96 3
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Scaler    scaler0 = &node->scaler;
d109 4
a112 9
  ftc_size_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcscaler,
                      FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d120 4
a123 9
  ftc_size_node_reset( FTC_MruNode  ftcnode,
                       FT_Pointer   ftcscaler,
                       FT_Pointer   ftcmanager )
  {
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_Scaler    scaler  = (FTC_Scaler)ftcscaler;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d135 5
a139 5
    sizeof ( FTC_SizeNodeRec ),
    ftc_size_node_compare,
    ftc_size_node_init,
    ftc_size_node_reset,
    ftc_size_node_done
d145 2
a146 2
  ftc_size_node_compare_faceid( FTC_MruNode  ftcnode,
                                FT_Pointer   ftcface_id )
a147 4
    FTC_SizeNode  node    = (FTC_SizeNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


a151 2
  /* documentation is in ftcache.h */

d203 5
a207 8
  ftc_face_node_init( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcface_id,
                      FT_Pointer   ftcmanager )
  {
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;
    FT_Error      error;
d228 2
a229 2
  ftc_face_node_done( FTC_MruNode  ftcnode,
                      FT_Pointer   ftcmanager )
a230 4
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_Manager   manager = (FTC_Manager)ftcmanager;


d233 4
a236 3
    FTC_MruList_RemoveSelection( &manager->sizes,
                                 ftc_size_node_compare_faceid,
                                 node->face_id );
d246 2
a247 2
  ftc_face_node_compare( FTC_MruNode  ftcnode,
                         FT_Pointer   ftcface_id )
a248 4
    FTC_FaceNode  node    = (FTC_FaceNode)ftcnode;
    FTC_FaceID    face_id = (FTC_FaceID)ftcface_id;


d256 1
a256 1
    sizeof ( FTC_FaceNodeRec),
d258 4
a261 4
    ftc_face_node_compare,
    ftc_face_node_init,
    0,                          /* FTC_MruNode_ResetFunc */
    ftc_face_node_done
d425 1
a425 1
  static void
d491 1
a491 1
  FT_LOCAL_DEF( void )
d533 1
a533 1
  FT_LOCAL_DEF( FT_Error )
d584 1
a584 1
  FT_LOCAL_DEF( FT_UInt )
d611 1
a611 1
      if ( node == first )
a619 2
  /* documentation is in ftcache.h */

d636 1
a636 1
  /* documentation is in ftcache.h */
a646 51
#ifdef FT_CONFIG_OPTION_OLD_INTERNALS

  FT_EXPORT_DEF( FT_Error )
  FTC_Manager_Lookup_Face( FTC_Manager  manager,
                           FTC_FaceID   face_id,
                           FT_Face     *aface )
  {
    return FTC_Manager_LookupFace( manager, face_id, aface );
  }


  FT_EXPORT( FT_Error )
  FTC_Manager_Lookup_Size( FTC_Manager  manager,
                           FTC_Font     font,
                           FT_Face     *aface,
                           FT_Size     *asize )
  {
    FTC_ScalerRec  scaler;
    FT_Error       error;
    FT_Size        size;
    FT_Face        face;


    scaler.face_id = font->face_id;
    scaler.width   = font->pix_width;
    scaler.height  = font->pix_height;
    scaler.pixel   = TRUE;
    scaler.x_res   = 0;
    scaler.y_res   = 0;

    error = FTC_Manager_LookupSize( manager, &scaler, &size );
    if ( error )
    {
      face = NULL;
      size = NULL;
    }
    else
      face = size->face;

    if ( aface )
      *aface = face;

    if ( asize )
      *asize = size;

    return error;
  }

#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */


@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009 by       */
a28 4
#ifdef FT_CONFIG_OPTION_PIC
#error "cache system does not support PIC yet"
#endif 

a80 2
#define FTC_SIZE_NODE( x ) ( (FTC_SizeNode)( x ) )

d179 2
a180 2
    FT_Error     error;
    FTC_MruNode  mrunode;
d184 1
a184 1
      return FTC_Err_Invalid_Argument;
d194 1
a194 1
                            mrunode, error );
d197 1
a197 1
    error = FTC_MruList_Lookup( &manager->sizes, scaler, &mrunode );
d201 1
a201 1
      *asize = FTC_SIZE_NODE( mrunode )->size;
a222 2
#define FTC_FACE_NODE( x ) ( ( FTC_FaceNode )( x ) )

d304 2
a305 2
    FT_Error     error;
    FTC_MruNode  mrunode;
d309 1
a309 1
      return FTC_Err_Invalid_Argument;
d320 1
a320 1
                            mrunode, error );
d323 1
a323 1
    error = FTC_MruList_Lookup( &manager->faces, face_id, &mrunode );
d327 1
a327 1
      *aface = FTC_FACE_NODE( mrunode )->face;
d479 2
a480 2
          FT_TRACE0(( "FTC_Manager_Check: invalid node (cache index = %ld\n",
                      node->cache_index ));
d489 2
a490 2
        FT_TRACE0(( "FTC_Manager_Check: invalid weight %ld instead of %ld\n",
                    manager->cur_weight, weight ));
d508 3
a510 3
        FT_TRACE0(( "FTC_Manager_Check:"
                    " invalid cache node count %d instead of %d\n",
                    manager->num_nodes, count ));
d537 3
a539 3
    FT_TRACE0(( "compressing, weight = %ld, max = %ld, nodes = %d\n",
                manager->cur_weight, manager->max_weight,
                manager->num_nodes ));
d582 2
a583 2
        FT_ERROR(( "FTC_Manager_RegisterCache:"
                   " too many registered caches\n" ));
d611 1
a611 2
    if ( acache )
      *acache = cache;
d663 1
a663 3
    FTC_MruList_RemoveSelection( &manager->faces,
                                 (FTC_MruNode_CompareFunc)NULL,
                                 face_id );
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2000-2016 by                                                 */
d31 1
a31 1
#endif
d37 2
d63 2
a64 5
      error = FT_Set_Char_Size( face,
                                (FT_F26Dot6)scaler->width,
                                (FT_F26Dot6)scaler->height,
                                scaler->x_res,
                                scaler->y_res );
d154 1
a154 1
  static
d158 4
a161 5

    ftc_size_node_compare,  /* FTC_MruNode_CompareFunc  node_compare */
    ftc_size_node_init,     /* FTC_MruNode_InitFunc     node_init    */
    ftc_size_node_reset,    /* FTC_MruNode_ResetFunc    node_reset   */
    ftc_size_node_done      /* FTC_MruNode_DoneFunc     node_done    */
d189 2
a190 2
    if ( !asize || !scaler )
      return FT_THROW( Invalid_Argument );
d195 1
a195 1
      return FT_THROW( Invalid_Cache_Handle );
d293 1
a293 1
  static
d298 4
a301 4
    ftc_face_node_compare,  /* FTC_MruNode_CompareFunc  node_compare */
    ftc_face_node_init,     /* FTC_MruNode_InitFunc     node_init    */
    NULL,                   /* FTC_MruNode_ResetFunc    node_reset   */
    ftc_face_node_done      /* FTC_MruNode_DoneFunc     node_done    */
d316 2
a317 2
    if ( !aface )
      return FT_THROW( Invalid_Argument );
d322 1
a322 1
      return FT_THROW( Invalid_Cache_Handle );
d367 1
a367 4
      return FT_THROW( Invalid_Library_Handle );

    if ( !amanager || !requester )
      return FT_THROW( Invalid_Argument );
d454 6
a459 7
    if ( !manager )
      return;

    FTC_MruList_Reset( &manager->sizes );
    FTC_MruList_Reset( &manager->faces );

    FTC_Manager_FlushN( manager, manager->num_nodes );
d476 1
a476 1
      FT_Offset  weight = 0;
d492 1
a492 1
        node = FTC_NODE_NEXT( node );
d511 1
a511 1
        node = FTC_NODE_NEXT( node );
d550 1
a550 1
    if ( manager->cur_weight < manager->max_weight || !first )
d554 1
a554 1
    node = FTC_NODE_PREV( first );
d560 1
a560 1
      prev = ( node == first ) ? NULL : FTC_NODE_PREV( node );
d578 1
a578 1
    FT_Error   error = FT_ERR( Invalid_Argument );
d589 1
a589 1
        error = FT_THROW( Too_Many_Caches );
d635 1
a635 1
    if ( !first )  /* empty list! */
d639 1
a639 1
    node = FTC_NODE_PREV(first);
d642 1
a642 1
      FTC_Node  prev = FTC_NODE_PREV( node );
a668 4

    if ( !manager )
      return;

d673 1
a673 1
                                 ftc_face_node_compare,
d687 1
a687 3
    if ( node                                             &&
         manager                                          &&
         (FT_UInt)node->cache_index < manager->num_caches )
d692 51
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
