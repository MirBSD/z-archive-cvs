head	1.3;
access;
symbols
	freetype-2_7_1:1.1.115.2
	freetype-2_3_12:1.1.115.1
	freetype-2_3_6:1.1.1.1
	freetype:1.1.115;
locks; strict;
comment	@ * @;


1.3
date	2017.04.15.19.21.46;	author tg;	state Exp;
branches;
next	1.2;
commitid	10058F2723111C7BEE2;

1.2
date	2013.08.06.19.48.02;	author tg;	state Exp;
branches;
next	1.1;
commitid	100520152445E05B912;

1.1
date	2008.06.12.20.37.29;	author bsiegert;	state Exp;
branches
	1.1.1.1
	1.1.115.1;
next	;
commitid	1004851887B4E012E38;

1.1.1.1
date	2008.06.12.20.37.29;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.115.1
date	2013.08.06.19.12.23;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10052014A9975CEFD1D;

1.1.115.2
date	2017.04.15.15.42.07;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.3
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  otvmath.c                                                              */
/*                                                                         */
/*    OpenType MATH table validation (body).                               */
/*                                                                         */
/*  Copyright 2007-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  Written by George Williams.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include "otvalid.h"
#include "otvcommn.h"
#include "otvgpos.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_otvmath



  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                  MATH TYPOGRAPHIC CONSTANTS                   *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static void
  otv_MathConstants_validate( FT_Bytes       table,
                              OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   i;
    FT_UInt   table_size;

    OTV_OPTIONAL_TABLE( DeviceTableOffset );


    OTV_NAME_ENTER( "MathConstants" );

    /* 56 constants, 51 have device tables */
    OTV_LIMIT_CHECK( 2 * ( 56 + 51 ) );
    table_size = 2 * ( 56 + 51 );

    p += 4 * 2;                 /* First 4 constants have no device tables */
    for ( i = 0; i < 51; i++ )
    {
      p += 2;                                            /* skip the value */
      OTV_OPTIONAL_OFFSET( DeviceTableOffset );
      OTV_SIZE_CHECK( DeviceTableOffset );
      if ( DeviceTableOffset )
        otv_Device_validate( table + DeviceTableOffset, otvalid );
    }

    OTV_EXIT;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   MATH ITALICS CORRECTION                     *****/
  /*****                 MATH TOP ACCENT ATTACHMENT                    *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static void
  otv_MathItalicsCorrectionInfo_validate( FT_Bytes       table,
                                          OTV_Validator  otvalid,
                                          FT_Int         isItalic )
  {
    FT_Bytes  p = table;
    FT_UInt   i, cnt, table_size;

    OTV_OPTIONAL_TABLE( Coverage );
    OTV_OPTIONAL_TABLE( DeviceTableOffset );

    FT_UNUSED( isItalic );  /* only used if tracing is active */


    OTV_NAME_ENTER( isItalic ? "MathItalicsCorrectionInfo"
                             : "MathTopAccentAttachment" );

    OTV_LIMIT_CHECK( 4 );

    OTV_OPTIONAL_OFFSET( Coverage );
    cnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 4 * cnt );
    table_size = 4 + 4 * cnt;

    OTV_SIZE_CHECK( Coverage );
    otv_Coverage_validate( table + Coverage, otvalid, (FT_Int)cnt );

    for ( i = 0; i < cnt; i++ )
    {
      p += 2;                                            /* Skip the value */
      OTV_OPTIONAL_OFFSET( DeviceTableOffset );
      OTV_SIZE_CHECK( DeviceTableOffset );
      if ( DeviceTableOffset )
        otv_Device_validate( table + DeviceTableOffset, otvalid );
    }

    OTV_EXIT;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                           MATH KERNING                        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static void
  otv_MathKern_validate( FT_Bytes       table,
                         OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   i, cnt, table_size;

    OTV_OPTIONAL_TABLE( DeviceTableOffset );


    /* OTV_NAME_ENTER( "MathKern" );*/

    OTV_LIMIT_CHECK( 2 );

    cnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 4 * cnt + 2 );
    table_size = 4 + 4 * cnt;

    /* Heights */
    for ( i = 0; i < cnt; i++ )
    {
      p += 2;                                            /* Skip the value */
      OTV_OPTIONAL_OFFSET( DeviceTableOffset );
      OTV_SIZE_CHECK( DeviceTableOffset );
      if ( DeviceTableOffset )
        otv_Device_validate( table + DeviceTableOffset, otvalid );
    }

    /* One more Kerning value */
    for ( i = 0; i < cnt + 1; i++ )
    {
      p += 2;                                            /* Skip the value */
      OTV_OPTIONAL_OFFSET( DeviceTableOffset );
      OTV_SIZE_CHECK( DeviceTableOffset );
      if ( DeviceTableOffset )
        otv_Device_validate( table + DeviceTableOffset, otvalid );
    }

    OTV_EXIT;
  }


  static void
  otv_MathKernInfo_validate( FT_Bytes       table,
                             OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   i, j, cnt, table_size;

    OTV_OPTIONAL_TABLE( Coverage );
    OTV_OPTIONAL_TABLE( MKRecordOffset );


    OTV_NAME_ENTER( "MathKernInfo" );

    OTV_LIMIT_CHECK( 4 );

    OTV_OPTIONAL_OFFSET( Coverage );
    cnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 8 * cnt );
    table_size = 4 + 8 * cnt;

    OTV_SIZE_CHECK( Coverage );
    otv_Coverage_validate( table + Coverage, otvalid, (FT_Int)cnt );

    for ( i = 0; i < cnt; i++ )
    {
      for ( j = 0; j < 4; j++ )
      {
        OTV_OPTIONAL_OFFSET( MKRecordOffset );
        OTV_SIZE_CHECK( MKRecordOffset );
        if ( MKRecordOffset )
          otv_MathKern_validate( table + MKRecordOffset, otvalid );
      }
    }

    OTV_EXIT;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                         MATH GLYPH INFO                       *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static void
  otv_MathGlyphInfo_validate( FT_Bytes       table,
                              OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   MathItalicsCorrectionInfo, MathTopAccentAttachment;
    FT_UInt   ExtendedShapeCoverage, MathKernInfo;


    OTV_NAME_ENTER( "MathGlyphInfo" );

    OTV_LIMIT_CHECK( 8 );

    MathItalicsCorrectionInfo = FT_NEXT_USHORT( p );
    MathTopAccentAttachment   = FT_NEXT_USHORT( p );
    ExtendedShapeCoverage     = FT_NEXT_USHORT( p );
    MathKernInfo              = FT_NEXT_USHORT( p );

    if ( MathItalicsCorrectionInfo )
      otv_MathItalicsCorrectionInfo_validate(
        table + MathItalicsCorrectionInfo, otvalid, TRUE );

    /* Italic correction and Top Accent Attachment have the same format */
    if ( MathTopAccentAttachment )
      otv_MathItalicsCorrectionInfo_validate(
        table + MathTopAccentAttachment, otvalid, FALSE );

    if ( ExtendedShapeCoverage )
    {
      OTV_NAME_ENTER( "ExtendedShapeCoverage" );
      otv_Coverage_validate( table + ExtendedShapeCoverage, otvalid, -1 );
      OTV_EXIT;
    }

    if ( MathKernInfo )
      otv_MathKernInfo_validate( table + MathKernInfo, otvalid );

    OTV_EXIT;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    MATH GLYPH CONSTRUCTION                    *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static void
  otv_GlyphAssembly_validate( FT_Bytes       table,
                              OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   pcnt, table_size;
    FT_UInt   i;

    OTV_OPTIONAL_TABLE( DeviceTableOffset );


    /* OTV_NAME_ENTER( "GlyphAssembly" ); */

    OTV_LIMIT_CHECK( 6 );

    p += 2;                           /* Skip the Italics Correction value */
    OTV_OPTIONAL_OFFSET( DeviceTableOffset );
    pcnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 8 * pcnt );
    table_size = 6 + 8 * pcnt;

    OTV_SIZE_CHECK( DeviceTableOffset );
    if ( DeviceTableOffset )
      otv_Device_validate( table + DeviceTableOffset, otvalid );

    for ( i = 0; i < pcnt; i++ )
    {
      FT_UInt  gid;


      gid = FT_NEXT_USHORT( p );
      if ( gid >= otvalid->glyph_count )
        FT_INVALID_GLYPH_ID;
      p += 2*4;             /* skip the Start, End, Full, and Flags fields */
    }

    /* OTV_EXIT; */
  }


  static void
  otv_MathGlyphConstruction_validate( FT_Bytes       table,
                                      OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   vcnt, table_size;
    FT_UInt   i;

    OTV_OPTIONAL_TABLE( GlyphAssembly );


    /* OTV_NAME_ENTER( "MathGlyphConstruction" ); */

    OTV_LIMIT_CHECK( 4 );

    OTV_OPTIONAL_OFFSET( GlyphAssembly );
    vcnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 4 * vcnt );
    table_size = 4 + 4 * vcnt;

    for ( i = 0; i < vcnt; i++ )
    {
      FT_UInt  gid;


      gid = FT_NEXT_USHORT( p );
      if ( gid >= otvalid->glyph_count )
        FT_INVALID_GLYPH_ID;
      p += 2;                          /* skip the size */
    }

    OTV_SIZE_CHECK( GlyphAssembly );
    if ( GlyphAssembly )
      otv_GlyphAssembly_validate( table+GlyphAssembly, otvalid );

    /* OTV_EXIT; */
  }


  static void
  otv_MathVariants_validate( FT_Bytes       table,
                             OTV_Validator  otvalid )
  {
    FT_Bytes  p = table;
    FT_UInt   vcnt, hcnt, i, table_size;

    OTV_OPTIONAL_TABLE( VCoverage );
    OTV_OPTIONAL_TABLE( HCoverage );
    OTV_OPTIONAL_TABLE( Offset );


    OTV_NAME_ENTER( "MathVariants" );

    OTV_LIMIT_CHECK( 10 );

    p += 2;                       /* Skip the MinConnectorOverlap constant */
    OTV_OPTIONAL_OFFSET( VCoverage );
    OTV_OPTIONAL_OFFSET( HCoverage );
    vcnt = FT_NEXT_USHORT( p );
    hcnt = FT_NEXT_USHORT( p );

    OTV_LIMIT_CHECK( 2 * vcnt + 2 * hcnt );
    table_size = 10 + 2 * vcnt + 2 * hcnt;

    OTV_SIZE_CHECK( VCoverage );
    if ( VCoverage )
      otv_Coverage_validate( table + VCoverage, otvalid, (FT_Int)vcnt );

    OTV_SIZE_CHECK( HCoverage );
    if ( HCoverage )
      otv_Coverage_validate( table + HCoverage, otvalid, (FT_Int)hcnt );

    for ( i = 0; i < vcnt; i++ )
    {
      OTV_OPTIONAL_OFFSET( Offset );
      OTV_SIZE_CHECK( Offset );
      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
    }

    for ( i = 0; i < hcnt; i++ )
    {
      OTV_OPTIONAL_OFFSET( Offset );
      OTV_SIZE_CHECK( Offset );
      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
    }

    OTV_EXIT;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                          MATH TABLE                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /* sets otvalid->glyph_count */

  FT_LOCAL_DEF( void )
  otv_MATH_validate( FT_Bytes      table,
                     FT_UInt       glyph_count,
                     FT_Validator  ftvalid )
  {
    OTV_ValidatorRec  otvalidrec;
    OTV_Validator     otvalid = &otvalidrec;
    FT_Bytes          p       = table;
    FT_UInt           MathConstants, MathGlyphInfo, MathVariants;


    otvalid->root = ftvalid;

    FT_TRACE3(( "validating MATH table\n" ));
    OTV_INIT;

    OTV_LIMIT_CHECK( 10 );

    if ( FT_NEXT_ULONG( p ) != 0x10000UL )      /* Version */
      FT_INVALID_FORMAT;

    MathConstants = FT_NEXT_USHORT( p );
    MathGlyphInfo = FT_NEXT_USHORT( p );
    MathVariants  = FT_NEXT_USHORT( p );

    otvalid->glyph_count = glyph_count;

    otv_MathConstants_validate( table + MathConstants,
                                otvalid );
    otv_MathGlyphInfo_validate( table + MathGlyphInfo,
                                otvalid );
    otv_MathVariants_validate ( table + MathVariants,
                                otvalid );

    FT_TRACE4(( "\n" ));
  }


/* END */
@


1.2
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2007, 2008 by                                                */
d47 1
a47 1
                              OTV_Validator  valid )
d63 1
a63 1
    for ( i = 0; i < 51; ++i )
d69 1
a69 1
        otv_Device_validate( table + DeviceTableOffset, valid );
d87 1
a87 1
                                          OTV_Validator  valid,
d91 1
a91 1
    FT_UInt   i, cnt, table_size ;
d111 1
a111 1
    otv_Coverage_validate( table + Coverage, valid, cnt );
d113 1
a113 1
    for ( i = 0; i < cnt; ++i )
d119 1
a119 1
        otv_Device_validate( table + DeviceTableOffset, valid );
d136 1
a136 1
                         OTV_Validator  valid )
d154 1
a154 1
    for ( i = 0; i < cnt; ++i )
d160 1
a160 1
        otv_Device_validate( table + DeviceTableOffset, valid );
d164 1
a164 1
    for ( i = 0; i < cnt + 1; ++i )
d170 1
a170 1
        otv_Device_validate( table + DeviceTableOffset, valid );
d179 1
a179 1
                             OTV_Validator  valid )
d199 1
a199 1
    otv_Coverage_validate( table + Coverage, valid, cnt );
d201 1
a201 1
    for ( i = 0; i < cnt; ++i )
d203 1
a203 1
      for ( j = 0; j < 4; ++j )
d208 1
a208 1
          otv_MathKern_validate( table + MKRecordOffset, valid );
d226 1
a226 1
                              OTV_Validator  valid )
d244 1
a244 1
        table + MathItalicsCorrectionInfo, valid, TRUE );
d249 1
a249 1
        table + MathTopAccentAttachment, valid, FALSE );
d251 2
a252 1
    if ( ExtendedShapeCoverage ) {
d254 1
a254 1
      otv_Coverage_validate( table + ExtendedShapeCoverage, valid, -1 );
d259 1
a259 1
      otv_MathKernInfo_validate( table + MathKernInfo, valid );
d275 1
a275 1
                              OTV_Validator  valid )
d297 1
a297 1
      otv_Device_validate( table + DeviceTableOffset, valid );
d299 1
a299 1
    for ( i = 0; i < pcnt; ++i )
d305 1
a305 1
      if ( gid >= valid->glyph_count )
d316 1
a316 1
                                      OTV_Validator  valid )
d335 1
a335 1
    for ( i = 0; i < vcnt; ++i )
d341 1
a341 1
      if ( gid >= valid->glyph_count )
d348 1
a348 1
      otv_GlyphAssembly_validate( table+GlyphAssembly, valid );
d356 1
a356 1
                             OTV_Validator  valid )
d381 1
a381 1
      otv_Coverage_validate( table + VCoverage, valid, vcnt );
d385 1
a385 1
      otv_Coverage_validate( table + HCoverage, valid, hcnt );
d387 1
a387 1
    for ( i = 0; i < vcnt; ++i )
d391 1
a391 1
      otv_MathGlyphConstruction_validate( table + Offset, valid );
d394 1
a394 1
    for ( i = 0; i < hcnt; ++i )
d398 1
a398 1
      otv_MathGlyphConstruction_validate( table + Offset, valid );
d413 1
a413 1
  /* sets valid->glyph_count */
d420 3
a422 3
    OTV_ValidatorRec  validrec;
    OTV_Validator     valid = &validrec;
    FT_Bytes          p     = table;
d426 1
a426 1
    valid->root = ftvalid;
d440 1
a440 1
    valid->glyph_count = glyph_count;
d443 1
a443 1
                                valid );
d445 1
a445 1
                                valid );
d447 1
a447 1
                                valid );
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 2007 by                                                      */
d96 2
@


1.1.115.1
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2007, 2008 by                                                */
a95 2
    FT_UNUSED( isItalic );  /* only used if tracing is active */

@


1.1.115.2
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2007-2016 by                                                 */
d47 1
a47 1
                              OTV_Validator  otvalid )
d63 1
a63 1
    for ( i = 0; i < 51; i++ )
d69 1
a69 1
        otv_Device_validate( table + DeviceTableOffset, otvalid );
d87 1
a87 1
                                          OTV_Validator  otvalid,
d91 1
a91 1
    FT_UInt   i, cnt, table_size;
d111 1
a111 1
    otv_Coverage_validate( table + Coverage, otvalid, (FT_Int)cnt );
d113 1
a113 1
    for ( i = 0; i < cnt; i++ )
d119 1
a119 1
        otv_Device_validate( table + DeviceTableOffset, otvalid );
d136 1
a136 1
                         OTV_Validator  otvalid )
d154 1
a154 1
    for ( i = 0; i < cnt; i++ )
d160 1
a160 1
        otv_Device_validate( table + DeviceTableOffset, otvalid );
d164 1
a164 1
    for ( i = 0; i < cnt + 1; i++ )
d170 1
a170 1
        otv_Device_validate( table + DeviceTableOffset, otvalid );
d179 1
a179 1
                             OTV_Validator  otvalid )
d199 1
a199 1
    otv_Coverage_validate( table + Coverage, otvalid, (FT_Int)cnt );
d201 1
a201 1
    for ( i = 0; i < cnt; i++ )
d203 1
a203 1
      for ( j = 0; j < 4; j++ )
d208 1
a208 1
          otv_MathKern_validate( table + MKRecordOffset, otvalid );
d226 1
a226 1
                              OTV_Validator  otvalid )
d244 1
a244 1
        table + MathItalicsCorrectionInfo, otvalid, TRUE );
d249 1
a249 1
        table + MathTopAccentAttachment, otvalid, FALSE );
d251 1
a251 2
    if ( ExtendedShapeCoverage )
    {
d253 1
a253 1
      otv_Coverage_validate( table + ExtendedShapeCoverage, otvalid, -1 );
d258 1
a258 1
      otv_MathKernInfo_validate( table + MathKernInfo, otvalid );
d274 1
a274 1
                              OTV_Validator  otvalid )
d296 1
a296 1
      otv_Device_validate( table + DeviceTableOffset, otvalid );
d298 1
a298 1
    for ( i = 0; i < pcnt; i++ )
d304 1
a304 1
      if ( gid >= otvalid->glyph_count )
d315 1
a315 1
                                      OTV_Validator  otvalid )
d334 1
a334 1
    for ( i = 0; i < vcnt; i++ )
d340 1
a340 1
      if ( gid >= otvalid->glyph_count )
d347 1
a347 1
      otv_GlyphAssembly_validate( table+GlyphAssembly, otvalid );
d355 1
a355 1
                             OTV_Validator  otvalid )
d380 1
a380 1
      otv_Coverage_validate( table + VCoverage, otvalid, (FT_Int)vcnt );
d384 1
a384 1
      otv_Coverage_validate( table + HCoverage, otvalid, (FT_Int)hcnt );
d386 1
a386 1
    for ( i = 0; i < vcnt; i++ )
d390 1
a390 1
      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
d393 1
a393 1
    for ( i = 0; i < hcnt; i++ )
d397 1
a397 1
      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
d412 1
a412 1
  /* sets otvalid->glyph_count */
d419 3
a421 3
    OTV_ValidatorRec  otvalidrec;
    OTV_Validator     otvalid = &otvalidrec;
    FT_Bytes          p       = table;
d425 1
a425 1
    otvalid->root = ftvalid;
d439 1
a439 1
    otvalid->glyph_count = glyph_count;
d442 1
a442 1
                                otvalid );
d444 1
a444 1
                                otvalid );
d446 1
a446 1
                                otvalid );
@


1.1.1.1
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@@
