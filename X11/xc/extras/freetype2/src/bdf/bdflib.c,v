head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.4
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.30;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.46;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.02.26.20.04.54;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10047C470A72A1E13CE;

1.3
date	2007.04.04.18.15.35;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004613EB4F003A0720;

1.2
date	2006.06.29.20.24.46;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.16;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.09;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.10;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.36.39;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.00;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/*
 * Copyright 2000 Computing Research Labs, New Mexico State University
 * Copyright 2001-2014
 *   Francesco Zappa Nardelli
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

  /*************************************************************************/
  /*                                                                       */
  /*  This file is based on bdf.c,v 1.22 2000/03/16 20:08:50               */
  /*                                                                       */
  /*  taken from Mark Leisher's xmbdfed package                            */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>

#include FT_FREETYPE_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_OBJECTS_H

#include "bdf.h"
#include "bdferror.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_bdflib


  /*************************************************************************/
  /*                                                                       */
  /* Default BDF font options.                                             */
  /*                                                                       */
  /*************************************************************************/


  static const bdf_options_t  _bdf_opts =
  {
    1,                /* Correct metrics.               */
    1,                /* Preserve unencoded glyphs.     */
    0,                /* Preserve comments.             */
    BDF_PROPORTIONAL  /* Default spacing.               */
  };


  /*************************************************************************/
  /*                                                                       */
  /* Builtin BDF font properties.                                          */
  /*                                                                       */
  /*************************************************************************/

  /* List of most properties that might appear in a font.  Doesn't include */
  /* the RAW_* and AXIS_* properties in X11R6 polymorphic fonts.           */

  static const bdf_property_t  _bdf_properties[] =
  {
    { (char *)"ADD_STYLE_NAME",          BDF_ATOM,     1, { 0 } },
    { (char *)"AVERAGE_WIDTH",           BDF_INTEGER,  1, { 0 } },
    { (char *)"AVG_CAPITAL_WIDTH",       BDF_INTEGER,  1, { 0 } },
    { (char *)"AVG_LOWERCASE_WIDTH",     BDF_INTEGER,  1, { 0 } },
    { (char *)"CAP_HEIGHT",              BDF_INTEGER,  1, { 0 } },
    { (char *)"CHARSET_COLLECTIONS",     BDF_ATOM,     1, { 0 } },
    { (char *)"CHARSET_ENCODING",        BDF_ATOM,     1, { 0 } },
    { (char *)"CHARSET_REGISTRY",        BDF_ATOM,     1, { 0 } },
    { (char *)"COMMENT",                 BDF_ATOM,     1, { 0 } },
    { (char *)"COPYRIGHT",               BDF_ATOM,     1, { 0 } },
    { (char *)"DEFAULT_CHAR",            BDF_CARDINAL, 1, { 0 } },
    { (char *)"DESTINATION",             BDF_CARDINAL, 1, { 0 } },
    { (char *)"DEVICE_FONT_NAME",        BDF_ATOM,     1, { 0 } },
    { (char *)"END_SPACE",               BDF_INTEGER,  1, { 0 } },
    { (char *)"FACE_NAME",               BDF_ATOM,     1, { 0 } },
    { (char *)"FAMILY_NAME",             BDF_ATOM,     1, { 0 } },
    { (char *)"FIGURE_WIDTH",            BDF_INTEGER,  1, { 0 } },
    { (char *)"FONT",                    BDF_ATOM,     1, { 0 } },
    { (char *)"FONTNAME_REGISTRY",       BDF_ATOM,     1, { 0 } },
    { (char *)"FONT_ASCENT",             BDF_INTEGER,  1, { 0 } },
    { (char *)"FONT_DESCENT",            BDF_INTEGER,  1, { 0 } },
    { (char *)"FOUNDRY",                 BDF_ATOM,     1, { 0 } },
    { (char *)"FULL_NAME",               BDF_ATOM,     1, { 0 } },
    { (char *)"ITALIC_ANGLE",            BDF_INTEGER,  1, { 0 } },
    { (char *)"MAX_SPACE",               BDF_INTEGER,  1, { 0 } },
    { (char *)"MIN_SPACE",               BDF_INTEGER,  1, { 0 } },
    { (char *)"NORM_SPACE",              BDF_INTEGER,  1, { 0 } },
    { (char *)"NOTICE",                  BDF_ATOM,     1, { 0 } },
    { (char *)"PIXEL_SIZE",              BDF_INTEGER,  1, { 0 } },
    { (char *)"POINT_SIZE",              BDF_INTEGER,  1, { 0 } },
    { (char *)"QUAD_WIDTH",              BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_ASCENT",              BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_AVERAGE_WIDTH",       BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_AVG_CAPITAL_WIDTH",   BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_AVG_LOWERCASE_WIDTH", BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_CAP_HEIGHT",          BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_DESCENT",             BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_END_SPACE",           BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_FIGURE_WIDTH",        BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_MAX_SPACE",           BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_MIN_SPACE",           BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_NORM_SPACE",          BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_PIXEL_SIZE",          BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_POINT_SIZE",          BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_PIXELSIZE",           BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_POINTSIZE",           BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_QUAD_WIDTH",          BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SMALL_CAP_SIZE",      BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_STRIKEOUT_ASCENT",    BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_STRIKEOUT_DESCENT",   BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUBSCRIPT_SIZE",      BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUBSCRIPT_X",         BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUBSCRIPT_Y",         BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUPERSCRIPT_SIZE",    BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUPERSCRIPT_X",       BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_SUPERSCRIPT_Y",       BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_UNDERLINE_POSITION",  BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_UNDERLINE_THICKNESS", BDF_INTEGER,  1, { 0 } },
    { (char *)"RAW_X_HEIGHT",            BDF_INTEGER,  1, { 0 } },
    { (char *)"RELATIVE_SETWIDTH",       BDF_CARDINAL, 1, { 0 } },
    { (char *)"RELATIVE_WEIGHT",         BDF_CARDINAL, 1, { 0 } },
    { (char *)"RESOLUTION",              BDF_INTEGER,  1, { 0 } },
    { (char *)"RESOLUTION_X",            BDF_CARDINAL, 1, { 0 } },
    { (char *)"RESOLUTION_Y",            BDF_CARDINAL, 1, { 0 } },
    { (char *)"SETWIDTH_NAME",           BDF_ATOM,     1, { 0 } },
    { (char *)"SLANT",                   BDF_ATOM,     1, { 0 } },
    { (char *)"SMALL_CAP_SIZE",          BDF_INTEGER,  1, { 0 } },
    { (char *)"SPACING",                 BDF_ATOM,     1, { 0 } },
    { (char *)"STRIKEOUT_ASCENT",        BDF_INTEGER,  1, { 0 } },
    { (char *)"STRIKEOUT_DESCENT",       BDF_INTEGER,  1, { 0 } },
    { (char *)"SUBSCRIPT_SIZE",          BDF_INTEGER,  1, { 0 } },
    { (char *)"SUBSCRIPT_X",             BDF_INTEGER,  1, { 0 } },
    { (char *)"SUBSCRIPT_Y",             BDF_INTEGER,  1, { 0 } },
    { (char *)"SUPERSCRIPT_SIZE",        BDF_INTEGER,  1, { 0 } },
    { (char *)"SUPERSCRIPT_X",           BDF_INTEGER,  1, { 0 } },
    { (char *)"SUPERSCRIPT_Y",           BDF_INTEGER,  1, { 0 } },
    { (char *)"UNDERLINE_POSITION",      BDF_INTEGER,  1, { 0 } },
    { (char *)"UNDERLINE_THICKNESS",     BDF_INTEGER,  1, { 0 } },
    { (char *)"WEIGHT",                  BDF_CARDINAL, 1, { 0 } },
    { (char *)"WEIGHT_NAME",             BDF_ATOM,     1, { 0 } },
    { (char *)"X_HEIGHT",                BDF_INTEGER,  1, { 0 } },
    { (char *)"_MULE_BASELINE_OFFSET",   BDF_INTEGER,  1, { 0 } },
    { (char *)"_MULE_RELATIVE_COMPOSE",  BDF_INTEGER,  1, { 0 } },
  };

  static const unsigned long
  _num_bdf_properties = sizeof ( _bdf_properties ) /
                        sizeof ( _bdf_properties[0] );


  /* An auxiliary macro to parse properties, to be used in conditionals. */
  /* It behaves like `strncmp' but also tests the following character    */
  /* whether it is a whitespace or NULL.                                 */
  /* `property' is a constant string of length `n' to compare with.      */
#define _bdf_strncmp( name, property, n )      \
          ( ft_strncmp( name, property, n ) || \
            !( name[n] == ' '  ||              \
               name[n] == '\0' ||              \
               name[n] == '\n' ||              \
               name[n] == '\r' ||              \
               name[n] == '\t' )            )

  /* Auto correction messages. */
#define ACMSG1   "FONT_ASCENT property missing.  " \
                 "Added `FONT_ASCENT %hd'.\n"
#define ACMSG2   "FONT_DESCENT property missing.  " \
                 "Added `FONT_DESCENT %hd'.\n"
#define ACMSG3   "Font width != actual width.  Old: %hd New: %hd.\n"
#define ACMSG4   "Font left bearing != actual left bearing.  " \
                 "Old: %hd New: %hd.\n"
#define ACMSG5   "Font ascent != actual ascent.  Old: %hd New: %hd.\n"
#define ACMSG6   "Font descent != actual descent.  Old: %hd New: %hd.\n"
#define ACMSG7   "Font height != actual height. Old: %hd New: %hd.\n"
#define ACMSG8   "Glyph scalable width (SWIDTH) adjustments made.\n"
#define ACMSG9   "SWIDTH field missing at line %ld.  Set automatically.\n"
#define ACMSG10  "DWIDTH field missing at line %ld.  Set to glyph width.\n"
#define ACMSG11  "SIZE bits per pixel field adjusted to %hd.\n"
#define ACMSG12  "Duplicate encoding %ld (%s) changed to unencoded.\n"
#define ACMSG13  "Glyph %ld extra rows removed.\n"
#define ACMSG14  "Glyph %ld extra columns removed.\n"
#define ACMSG15  "Incorrect glyph count: %ld indicated but %ld found.\n"
#define ACMSG16  "Glyph %ld missing columns padded with zero bits.\n"
#define ACMSG17  "Adjusting number of glyphs to %ld.\n"

  /* Error messages. */
#define ERRMSG1  "[line %ld] Missing `%s' line.\n"
#define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
#define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
#define ERRMSG4  "[line %ld] BBX too big.\n"
#define ERRMSG5  "[line %ld] `%s' value too big.\n"
#define ERRMSG6  "[line %ld] Input line too long.\n"
#define ERRMSG7  "[line %ld] Font name too long.\n"
#define ERRMSG8  "[line %ld] Invalid `%s' value.\n"
#define ERRMSG9  "[line %ld] Invalid keyword.\n"

  /* Debug messages. */
#define DBGMSG1  "  [%6ld] %s" /* no \n */
#define DBGMSG2  " (0x%lX)\n"


  /*************************************************************************/
  /*                                                                       */
  /* Utility types and functions.                                          */
  /*                                                                       */
  /*************************************************************************/


  /* Function type for parsing lines of a BDF font. */

  typedef FT_Error
  (*_bdf_line_func_t)( char*          line,
                       unsigned long  linelen,
                       unsigned long  lineno,
                       void*          call_data,
                       void*          client_data );


  /* List structure for splitting lines into fields. */

  typedef struct  _bdf_list_t_
  {
    char**         field;
    unsigned long  size;
    unsigned long  used;
    FT_Memory      memory;

  } _bdf_list_t;


  /* Structure used while loading BDF fonts. */

  typedef struct  _bdf_parse_t_
  {
    unsigned long   flags;
    unsigned long   cnt;
    unsigned long   row;

    short           minlb;
    short           maxlb;
    short           maxrb;
    short           maxas;
    short           maxds;

    short           rbearing;

    char*           glyph_name;
    long            glyph_enc;

    bdf_font_t*     font;
    bdf_options_t*  opts;

    unsigned long   have[34816]; /* must be in sync with `nmod' and `umod' */
                                 /* arrays from `bdf_font_t' structure     */
    _bdf_list_t     list;

    FT_Memory       memory;
    unsigned long   size;        /* the stream size */

  } _bdf_parse_t;


#define setsbit( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
#define sbitset( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )


  static void
  _bdf_list_init( _bdf_list_t*  list,
                  FT_Memory     memory )
  {
    FT_ZERO( list );
    list->memory = memory;
  }


  static void
  _bdf_list_done( _bdf_list_t*  list )
  {
    FT_Memory  memory = list->memory;


    if ( memory )
    {
      FT_FREE( list->field );
      FT_ZERO( list );
    }
  }


  static FT_Error
  _bdf_list_ensure( _bdf_list_t*   list,
                    unsigned long  num_items ) /* same as _bdf_list_t.used */
  {
    FT_Error  error = FT_Err_Ok;


    if ( num_items > list->size )
    {
      unsigned long  oldsize = list->size; /* same as _bdf_list_t.size */
      unsigned long  newsize = oldsize + ( oldsize >> 1 ) + 5;
      unsigned long  bigsize = (unsigned long)( FT_INT_MAX / sizeof ( char* ) );
      FT_Memory      memory  = list->memory;


      if ( oldsize == bigsize )
      {
        error = FT_THROW( Out_Of_Memory );
        goto Exit;
      }
      else if ( newsize < oldsize || newsize > bigsize )
        newsize = bigsize;

      if ( FT_RENEW_ARRAY( list->field, oldsize, newsize ) )
        goto Exit;

      list->size = newsize;
    }

  Exit:
    return error;
  }


  static void
  _bdf_list_shift( _bdf_list_t*   list,
                   unsigned long  n )
  {
    unsigned long  i, u;


    if ( list == 0 || list->used == 0 || n == 0 )
      return;

    if ( n >= list->used )
    {
      list->used = 0;
      return;
    }

    for ( u = n, i = 0; u < list->used; i++, u++ )
      list->field[i] = list->field[u];
    list->used -= n;
  }


  /* An empty string for empty fields. */

  static const char  empty[1] = { 0 };      /* XXX eliminate this */


  static char *
  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char*          dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      char*  fp = list->field[i];


      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }


  /* The code below ensures that we have at least 4 + 1 `field' */
  /* elements in `list' (which are possibly NULL) so that we    */
  /* don't have to check the number of fields in most cases.    */

  static FT_Error
  _bdf_list_split( _bdf_list_t*   list,
                   char*          separators,
                   char*          line,
                   unsigned long  linelen )
  {
    unsigned long  final_empty;
    int            mult;
    char           *sp, *ep, *end;
    char           seps[32];
    FT_Error       error = FT_Err_Ok;


    /* Initialize the list. */
    list->used = 0;
    if ( list->size )
    {
      list->field[0] = (char*)empty;
      list->field[1] = (char*)empty;
      list->field[2] = (char*)empty;
      list->field[3] = (char*)empty;
      list->field[4] = (char*)empty;
    }

    /* If the line is empty, then simply return. */
    if ( linelen == 0 || line[0] == 0 )
      goto Exit;

    /* In the original code, if the `separators' parameter is NULL or */
    /* empty, the list is split into individual bytes.  We don't need */
    /* this, so an error is signaled.                                 */
    if ( separators == 0 || *separators == 0 )
    {
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    /* Prepare the separator bitmap. */
    FT_MEM_ZERO( seps, 32 );

    /* If the very last character of the separator string is a plus, then */
    /* set the `mult' flag to indicate that multiple separators should be */
    /* collapsed into one.                                                */
    for ( mult = 0, sp = separators; sp && *sp; sp++ )
    {
      if ( *sp == '+' && *( sp + 1 ) == 0 )
        mult = 1;
      else
        setsbit( seps, *sp );
    }

    /* Break the line up into fields. */
    for ( final_empty = 0, sp = ep = line, end = sp + linelen;
          sp < end && *sp; )
    {
      /* Collect everything that is not a separator. */
      for ( ; *ep && !sbitset( seps, *ep ); ep++ )
        ;

      /* Resize the list if necessary. */
      if ( list->used == list->size )
      {
        error = _bdf_list_ensure( list, list->used + 1 );
        if ( error )
          goto Exit;
      }

      /* Assign the field appropriately. */
      list->field[list->used++] = ( ep > sp ) ? sp : (char*)empty;

      sp = ep;

      if ( mult )
      {
        /* If multiple separators should be collapsed, do it now by */
        /* setting all the separator characters to 0.               */
        for ( ; *ep && sbitset( seps, *ep ); ep++ )
          *ep = 0;
      }
      else if ( *ep != 0 )
        /* Don't collapse multiple separators by making them 0, so just */
        /* make the one encountered 0.                                  */
        *ep++ = 0;

      final_empty = ( ep > sp && *ep == 0 );
      sp = ep;
    }

    /* Finally, NULL-terminate the list. */
    if ( list->used + final_empty >= list->size )
    {
      error = _bdf_list_ensure( list, list->used + final_empty + 1 );
      if ( error )
        goto Exit;
    }

    if ( final_empty )
      list->field[list->used++] = (char*)empty;

    list->field[list->used] = 0;

  Exit:
    return error;
  }


#define NO_SKIP  256  /* this value cannot be stored in a 'char' */


  static FT_Error
  _bdf_readstream( FT_Stream         stream,
                   _bdf_line_func_t  callback,
                   void*             client_data,
                   unsigned long    *lno )
  {
    _bdf_line_func_t  cb;
    unsigned long     lineno, buf_size;
    int               refill, hold, to_skip;
    ptrdiff_t         bytes, start, end, cursor, avail;
    char*             buf    = NULL;
    FT_Memory         memory = stream->memory;
    FT_Error          error  = FT_Err_Ok;


    if ( callback == 0 )
    {
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    /* initial size and allocation of the input buffer */
    buf_size = 1024;

    if ( FT_NEW_ARRAY( buf, buf_size ) )
      goto Exit;

    cb      = callback;
    lineno  = 1;
    buf[0]  = 0;
    start   = 0;
    avail   = 0;
    cursor  = 0;
    refill  = 1;
    to_skip = NO_SKIP;
    bytes   = 0;        /* make compiler happy */

    for (;;)
    {
      if ( refill )
      {
        bytes  = (ptrdiff_t)FT_Stream_TryRead(
                   stream, (FT_Byte*)buf + cursor,
                   buf_size - (unsigned long)cursor );
        avail  = cursor + bytes;
        cursor = 0;
        refill = 0;
      }

      end = start;

      /* should we skip an optional character like \n or \r? */
      if ( start < avail && buf[start] == to_skip )
      {
        start  += 1;
        to_skip = NO_SKIP;
        continue;
      }

      /* try to find the end of the line */
      while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
        end++;

      /* if we hit the end of the buffer, try shifting its content */
      /* or even resizing it                                       */
      if ( end >= avail )
      {
        if ( bytes == 0 )  /* last line in file doesn't end in \r or \n */
          break;           /* ignore it then exit                       */

        if ( start == 0 )
        {
          /* this line is definitely too long; try resizing the input */
          /* buffer a bit to handle it.                               */
          FT_ULong  new_size;


          if ( buf_size >= 65536UL )  /* limit ourselves to 64KByte */
          {
            FT_ERROR(( "_bdf_readstream: " ERRMSG6, lineno ));
            error = FT_THROW( Invalid_Argument );
            goto Exit;
          }

          new_size = buf_size * 2;
          if ( FT_RENEW_ARRAY( buf, buf_size, new_size ) )
            goto Exit;

          cursor   = (ptrdiff_t)buf_size;
          buf_size = new_size;
        }
        else
        {
          bytes = avail - start;

          FT_MEM_MOVE( buf, buf + start, bytes );

          cursor = bytes;
          avail -= bytes;
          start  = 0;
        }
        refill = 1;
        continue;
      }

      /* Temporarily NUL-terminate the line. */
      hold     = buf[end];
      buf[end] = 0;

      /* XXX: Use encoding independent value for 0x1A */
      if ( buf[start] != '#' && buf[start] != 0x1A && end > start )
      {
        error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
                       (void*)&cb, client_data );
        /* Redo if we have encountered CHARS without properties. */
        if ( error == -1 )
          error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
                         (void*)&cb, client_data );
        if ( error )
          break;
      }

      lineno  += 1;
      buf[end] = (char)hold;
      start    = end + 1;

      if ( hold == '\n' )
        to_skip = '\r';
      else if ( hold == '\r' )
        to_skip = '\n';
      else
        to_skip = NO_SKIP;
    }

    *lno = lineno;

  Exit:
    FT_FREE( buf );
    return error;
  }


  /* XXX: make this work with EBCDIC also */

  static const unsigned char  a2i[128] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

  static const unsigned char  ddigits[32] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };

  static const unsigned char  hdigits[32] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x7E, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };


  /* Routine to convert a decimal ASCII string to an unsigned long integer. */
  static unsigned long
  _bdf_atoul( char*  s )
  {
    unsigned long  v;


    if ( s == 0 || *s == 0 )
      return 0;

    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = v * 10 + a2i[(int)*s];

    return v;
  }


  /* Routine to convert a decimal ASCII string to a signed long integer. */
  static long
  _bdf_atol( char*  s )
  {
    long  v, neg;


    if ( s == 0 || *s == 0 )
      return 0;

    /* Check for a minus sign. */
    neg = 0;
    if ( *s == '-' )
    {
      s++;
      neg = 1;
    }

    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = v * 10 + a2i[(int)*s];

    return ( !neg ) ? v : -v;
  }


  /* Routine to convert a decimal ASCII string to an unsigned short integer. */
  static unsigned short
  _bdf_atous( char*  s )
  {
    unsigned short  v;


    if ( s == 0 || *s == 0 )
      return 0;

    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = (unsigned short)( v * 10 + a2i[(int)*s] );

    return v;
  }


  /* Routine to convert a decimal ASCII string to a signed short integer. */
  static short
  _bdf_atos( char*  s )
  {
    short  v, neg;


    if ( s == 0 || *s == 0 )
      return 0;

    /* Check for a minus. */
    neg = 0;
    if ( *s == '-' )
    {
      s++;
      neg = 1;
    }

    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = (short)( v * 10 + a2i[(int)*s] );

    return (short)( ( !neg ) ? v : -v );
  }


  /* Routine to compare two glyphs by encoding so they can be sorted. */
  static int
  by_encoding( const void*  a,
               const void*  b )
  {
    bdf_glyph_t  *c1, *c2;


    c1 = (bdf_glyph_t *)a;
    c2 = (bdf_glyph_t *)b;

    if ( c1->encoding < c2->encoding )
      return -1;

    if ( c1->encoding > c2->encoding )
      return 1;

    return 0;
  }


  static FT_Error
  bdf_create_property( char*        name,
                       int          format,
                       bdf_font_t*  font )
  {
    size_t           n;
    bdf_property_t*  p;
    FT_Memory        memory = font->memory;
    FT_Error         error  = FT_Err_Ok;


    /* First check whether the property has        */
    /* already been added or not.  If it has, then */
    /* simply ignore it.                           */
    if ( ft_hash_str_lookup( name, &(font->proptbl) ) )
      goto Exit;

    if ( FT_RENEW_ARRAY( font->user_props,
                         font->nuser_props,
                         font->nuser_props + 1 ) )
      goto Exit;

    p = font->user_props + font->nuser_props;
    FT_ZERO( p );

    n = ft_strlen( name ) + 1;
    if ( n > FT_ULONG_MAX )
      return FT_THROW( Invalid_Argument );

    if ( FT_NEW_ARRAY( p->name, n ) )
      goto Exit;

    FT_MEM_COPY( (char *)p->name, name, n );

    p->format  = format;
    p->builtin = 0;

    n = _num_bdf_properties + font->nuser_props;

    error = ft_hash_str_insert( p->name, n, &(font->proptbl), memory );
    if ( error )
      goto Exit;

    font->nuser_props++;

  Exit:
    return error;
  }


  FT_LOCAL_DEF( bdf_property_t* )
  bdf_get_property( char*        name,
                    bdf_font_t*  font )
  {
    size_t*  propid;


    if ( name == 0 || *name == 0 )
      return 0;

    if ( ( propid = ft_hash_str_lookup( name, &(font->proptbl) ) ) == NULL )
      return 0;

    if ( *propid >= _num_bdf_properties )
      return font->user_props + ( *propid - _num_bdf_properties );

    return (bdf_property_t*)_bdf_properties + *propid;
  }


  /*************************************************************************/
  /*                                                                       */
  /* BDF font file parsing flags and functions.                            */
  /*                                                                       */
  /*************************************************************************/


  /* Parse flags. */

#define BDF_START_      0x0001U
#define BDF_FONT_NAME_  0x0002U
#define BDF_SIZE_       0x0004U
#define BDF_FONT_BBX_   0x0008U
#define BDF_PROPS_      0x0010U
#define BDF_GLYPHS_     0x0020U
#define BDF_GLYPH_      0x0040U
#define BDF_ENCODING_   0x0080U
#define BDF_SWIDTH_     0x0100U
#define BDF_DWIDTH_     0x0200U
#define BDF_BBX_        0x0400U
#define BDF_BITMAP_     0x0800U

#define BDF_SWIDTH_ADJ_  0x1000U

#define BDF_GLYPH_BITS_ ( BDF_GLYPH_    | \
                          BDF_ENCODING_ | \
                          BDF_SWIDTH_   | \
                          BDF_DWIDTH_   | \
                          BDF_BBX_      | \
                          BDF_BITMAP_   )

#define BDF_GLYPH_WIDTH_CHECK_   0x40000000UL
#define BDF_GLYPH_HEIGHT_CHECK_  0x80000000UL


  static FT_Error
  _bdf_add_comment( bdf_font_t*    font,
                    char*          comment,
                    unsigned long  len )
  {
    char*      cp;
    FT_Memory  memory = font->memory;
    FT_Error   error  = FT_Err_Ok;


    if ( FT_RENEW_ARRAY( font->comments,
                         font->comments_len,
                         font->comments_len + len + 1 ) )
      goto Exit;

    cp = font->comments + font->comments_len;

    FT_MEM_COPY( cp, comment, len );
    cp[len] = '\n';

    font->comments_len += len + 1;

  Exit:
    return error;
  }


  /* Set the spacing from the font name if it exists, or set it to the */
  /* default specified in the options.                                 */
  static FT_Error
  _bdf_set_default_spacing( bdf_font_t*     font,
                            bdf_options_t*  opts,
                            unsigned long   lineno )
  {
    size_t       len;
    char         name[256];
    _bdf_list_t  list;
    FT_Memory    memory;
    FT_Error     error = FT_Err_Ok;

    FT_UNUSED( lineno );        /* only used in debug mode */


    if ( font == 0 || font->name == 0 || font->name[0] == 0 )
    {
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    memory = font->memory;

    _bdf_list_init( &list, memory );

    font->spacing = opts->font_spacing;

    len = ft_strlen( font->name ) + 1;
    /* Limit ourselves to 256 characters in the font name. */
    if ( len >= 256 )
    {
      FT_ERROR(( "_bdf_set_default_spacing: " ERRMSG7, lineno ));
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    FT_MEM_COPY( name, font->name, len );

    error = _bdf_list_split( &list, (char *)"-", name, (unsigned long)len );
    if ( error )
      goto Fail;

    if ( list.used == 15 )
    {
      switch ( list.field[11][0] )
      {
      case 'C':
      case 'c':
        font->spacing = BDF_CHARCELL;
        break;
      case 'M':
      case 'm':
        font->spacing = BDF_MONOWIDTH;
        break;
      case 'P':
      case 'p':
        font->spacing = BDF_PROPORTIONAL;
        break;
      }
    }

  Fail:
    _bdf_list_done( &list );

  Exit:
    return error;
  }


  /* Determine whether the property is an atom or not.  If it is, then */
  /* clean it up so the double quotes are removed if they exist.       */
  static int
  _bdf_is_atom( char*          line,
                unsigned long  linelen,
                char**         name,
                char**         value,
                bdf_font_t*    font )
  {
    int              hold;
    char             *sp, *ep;
    bdf_property_t*  p;


    *name = sp = ep = line;

    while ( *ep && *ep != ' ' && *ep != '\t' )
      ep++;

    hold = -1;
    if ( *ep )
    {
      hold = *ep;
      *ep  = 0;
    }

    p = bdf_get_property( sp, font );

    /* Restore the character that was saved before any return can happen. */
    if ( hold != -1 )
      *ep = (char)hold;

    /* If the property exists and is not an atom, just return here. */
    if ( p && p->format != BDF_ATOM )
      return 0;

    /* The property is an atom.  Trim all leading and trailing whitespace */
    /* and double quotes for the atom value.                              */
    sp = ep;
    ep = line + linelen;

    /* Trim the leading whitespace if it exists. */
    if ( *sp )
      *sp++ = 0;
    while ( *sp                           &&
            ( *sp == ' ' || *sp == '\t' ) )
      sp++;

    /* Trim the leading double quote if it exists. */
    if ( *sp == '"' )
      sp++;
    *value = sp;

    /* Trim the trailing whitespace if it exists. */
    while ( ep > sp                                       &&
            ( *( ep - 1 ) == ' ' || *( ep - 1 ) == '\t' ) )
      *--ep = 0;

    /* Trim the trailing double quote if it exists. */
    if ( ep > sp && *( ep - 1 ) == '"' )
      *--ep = 0;

    return 1;
  }


  static FT_Error
  _bdf_add_property( bdf_font_t*    font,
                     char*          name,
                     char*          value,
                     unsigned long  lineno )
  {
    size_t*         propid;
    bdf_property_t  *prop, *fp;
    FT_Memory       memory = font->memory;
    FT_Error        error  = FT_Err_Ok;

    FT_UNUSED( lineno );        /* only used in debug mode */


    /* First, check whether the property already exists in the font. */
    if ( ( propid = ft_hash_str_lookup( name,
                                        (FT_Hash)font->internal ) ) != NULL )
    {
      /* The property already exists in the font, so simply replace */
      /* the value of the property with the current value.          */
      fp = font->props + *propid;

      switch ( fp->format )
      {
      case BDF_ATOM:
        /* Delete the current atom if it exists. */
        FT_FREE( fp->value.atom );

        if ( value && value[0] != 0 )
        {
          if ( FT_STRDUP( fp->value.atom, value ) )
            goto Exit;
        }
        break;

      case BDF_INTEGER:
        fp->value.l = _bdf_atol( value );
        break;

      case BDF_CARDINAL:
        fp->value.ul = _bdf_atoul( value );
        break;

      default:
        ;
      }

      goto Exit;
    }

    /* See whether this property type exists yet or not. */
    /* If not, create it.                                */
    propid = ft_hash_str_lookup( name, &(font->proptbl) );
    if ( !propid )
    {
      error = bdf_create_property( name, BDF_ATOM, font );
      if ( error )
        goto Exit;
      propid = ft_hash_str_lookup( name, &(font->proptbl) );
    }

    /* Allocate another property if this is overflowing. */
    if ( font->props_used == font->props_size )
    {
      if ( font->props_size == 0 )
      {
        if ( FT_NEW_ARRAY( font->props, 1 ) )
          goto Exit;
      }
      else
      {
        if ( FT_RENEW_ARRAY( font->props,
                             font->props_size,
                             font->props_size + 1 ) )
          goto Exit;
      }

      fp = font->props + font->props_size;
      FT_ZERO( fp );
      font->props_size++;
    }

    if ( *propid >= _num_bdf_properties )
      prop = font->user_props + ( *propid - _num_bdf_properties );
    else
      prop = (bdf_property_t*)_bdf_properties + *propid;

    fp = font->props + font->props_used;

    fp->name    = prop->name;
    fp->format  = prop->format;
    fp->builtin = prop->builtin;

    switch ( prop->format )
    {
    case BDF_ATOM:
      fp->value.atom = 0;
      if ( value != 0 && value[0] )
      {
        if ( FT_STRDUP( fp->value.atom, value ) )
          goto Exit;
      }
      break;

    case BDF_INTEGER:
      fp->value.l = _bdf_atol( value );
      break;

    case BDF_CARDINAL:
      fp->value.ul = _bdf_atoul( value );
      break;
    }

    /* If the property happens to be a comment, then it doesn't need */
    /* to be added to the internal hash table.                       */
    if ( _bdf_strncmp( name, "COMMENT", 7 ) != 0 )
    {
      /* Add the property to the font property table. */
      error = ft_hash_str_insert( fp->name,
                                  font->props_used,
                                  (FT_Hash)font->internal,
                                  memory );
      if ( error )
        goto Exit;
    }

    font->props_used++;

    /* Some special cases need to be handled here.  The DEFAULT_CHAR       */
    /* property needs to be located if it exists in the property list, the */
    /* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        */
    /* present, and the SPACING property should override the default       */
    /* spacing.                                                            */
    if ( _bdf_strncmp( name, "DEFAULT_CHAR", 12 ) == 0 )
      font->default_char = fp->value.l;
    else if ( _bdf_strncmp( name, "FONT_ASCENT", 11 ) == 0 )
      font->font_ascent = fp->value.l;
    else if ( _bdf_strncmp( name, "FONT_DESCENT", 12 ) == 0 )
      font->font_descent = fp->value.l;
    else if ( _bdf_strncmp( name, "SPACING", 7 ) == 0 )
    {
      if ( !fp->value.atom )
      {
        FT_ERROR(( "_bdf_add_property: " ERRMSG8, lineno, "SPACING" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      if ( fp->value.atom[0] == 'p' || fp->value.atom[0] == 'P' )
        font->spacing = BDF_PROPORTIONAL;
      else if ( fp->value.atom[0] == 'm' || fp->value.atom[0] == 'M' )
        font->spacing = BDF_MONOWIDTH;
      else if ( fp->value.atom[0] == 'c' || fp->value.atom[0] == 'C' )
        font->spacing = BDF_CHARCELL;
    }

  Exit:
    return error;
  }


  static const unsigned char nibble_mask[8] =
  {
    0xFF, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE
  };


  /* Actually parse the glyph info and bitmaps. */
  static FT_Error
  _bdf_parse_glyphs( char*          line,
                     unsigned long  linelen,
                     unsigned long  lineno,
                     void*          call_data,
                     void*          client_data )
  {
    int                c, mask_index;
    char*              s;
    unsigned char*     bp;
    unsigned long      i, slen, nibbles;

    _bdf_parse_t*      p;
    bdf_glyph_t*       glyph;
    bdf_font_t*        font;

    FT_Memory          memory;
    FT_Error           error = FT_Err_Ok;

    FT_UNUSED( call_data );
    FT_UNUSED( lineno );        /* only used in debug mode */


    p = (_bdf_parse_t *)client_data;

    font   = p->font;
    memory = font->memory;

    /* Check for a comment. */
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
    {
      linelen -= 7;

      s = line + 7;
      if ( *s != 0 )
      {
        s++;
        linelen--;
      }
      error = _bdf_add_comment( p->font, s, linelen );
      goto Exit;
    }

    /* The very first thing expected is the number of glyphs. */
    if ( !( p->flags & BDF_GLYPHS_ ) )
    {
      if ( _bdf_strncmp( line, "CHARS", 5 ) != 0 )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "CHARS" ));
        error = FT_THROW( Missing_Chars_Field );
        goto Exit;
      }

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;
      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1] );

      /* We need at least 20 bytes per glyph. */
      if ( p->cnt > p->size / 20 )
      {
        p->cnt = font->glyphs_size = p->size / 20;
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG17, p->cnt ));
      }

      /* Make sure the number of glyphs is non-zero. */
      if ( p->cnt == 0 )
        font->glyphs_size = 64;

      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */
      /* number of code points available in Unicode).                 */
      if ( p->cnt >= 0x110000UL )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "CHARS" ));
        error = FT_THROW( Invalid_Argument );
        goto Exit;
      }

      if ( FT_NEW_ARRAY( font->glyphs, font->glyphs_size ) )
        goto Exit;

      p->flags |= BDF_GLYPHS_;

      goto Exit;
    }

    /* Check for the ENDFONT field. */
    if ( _bdf_strncmp( line, "ENDFONT", 7 ) == 0 )
    {
      if ( p->flags & BDF_GLYPH_BITS_ )
      {
        /* Missing ENDCHAR field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
        error = FT_THROW( Corrupted_Font_Glyphs );
        goto Exit;
      }

      /* Sort the glyphs by encoding. */
      ft_qsort( (char *)font->glyphs,
                font->glyphs_used,
                sizeof ( bdf_glyph_t ),
                by_encoding );

      p->flags &= ~BDF_START_;

      goto Exit;
    }

    /* Check for the ENDCHAR field. */
    if ( _bdf_strncmp( line, "ENDCHAR", 7 ) == 0 )
    {
      p->glyph_enc = 0;
      p->flags    &= ~BDF_GLYPH_BITS_;

      goto Exit;
    }

    /* Check whether a glyph is being scanned but should be */
    /* ignored because it is an unencoded glyph.            */
    if ( ( p->flags & BDF_GLYPH_ )     &&
         p->glyph_enc            == -1 &&
         p->opts->keep_unencoded == 0  )
      goto Exit;

    /* Check for the STARTCHAR field. */
    if ( _bdf_strncmp( line, "STARTCHAR", 9 ) == 0 )
    {
      if ( p->flags & BDF_GLYPH_BITS_ )
      {
        /* Missing ENDCHAR field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
        error = FT_THROW( Missing_Startchar_Field );
        goto Exit;
      }

      /* Set the character name in the parse info first until the */
      /* encoding can be checked for an unencoded character.      */
      FT_FREE( p->glyph_name );

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      _bdf_list_shift( &p->list, 1 );

      s = _bdf_list_join( &p->list, ' ', &slen );

      if ( !s )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG8, lineno, "STARTCHAR" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      if ( FT_NEW_ARRAY( p->glyph_name, slen + 1 ) )
        goto Exit;

      FT_MEM_COPY( p->glyph_name, s, slen + 1 );

      p->flags |= BDF_GLYPH_;

      FT_TRACE4(( DBGMSG1, lineno, s ));

      goto Exit;
    }

    /* Check for the ENCODING field. */
    if ( _bdf_strncmp( line, "ENCODING", 8 ) == 0 )
    {
      if ( !( p->flags & BDF_GLYPH_ ) )
      {
        /* Missing STARTCHAR field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "STARTCHAR" ));
        error = FT_THROW( Missing_Startchar_Field );
        goto Exit;
      }

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      p->glyph_enc = _bdf_atol( p->list.field[1] );

      /* Normalize negative encoding values.  The specification only */
      /* allows -1, but we can be more generous here.                */
      if ( p->glyph_enc < -1 )
        p->glyph_enc = -1;

      /* Check for alternative encoding format. */
      if ( p->glyph_enc == -1 && p->list.used > 2 )
        p->glyph_enc = _bdf_atol( p->list.field[2] );

      if ( p->glyph_enc < -1 )
        p->glyph_enc = -1;

      FT_TRACE4(( DBGMSG2, p->glyph_enc ));

      /* Check that the encoding is in the Unicode range because  */
      /* otherwise p->have (a bitmap with static size) overflows. */
      if ( p->glyph_enc > 0                                      &&
           (size_t)p->glyph_enc >= sizeof ( p->have ) /
                                   sizeof ( unsigned long ) * 32 )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "ENCODING" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      /* Check whether this encoding has already been encountered. */
      /* If it has then change it to unencoded so it gets added if */
      /* indicated.                                                */
      if ( p->glyph_enc >= 0 )
      {
        if ( _bdf_glyph_modified( p->have, p->glyph_enc ) )
        {
          /* Emit a message saying a glyph has been moved to the */
          /* unencoded area.                                     */
          FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG12,
                      p->glyph_enc, p->glyph_name ));
          p->glyph_enc = -1;
          font->modified = 1;
        }
        else
          _bdf_set_glyph_modified( p->have, p->glyph_enc );
      }

      if ( p->glyph_enc >= 0 )
      {
        /* Make sure there are enough glyphs allocated in case the */
        /* number of characters happen to be wrong.                */
        if ( font->glyphs_used == font->glyphs_size )
        {
          if ( FT_RENEW_ARRAY( font->glyphs,
                               font->glyphs_size,
                               font->glyphs_size + 64 ) )
            goto Exit;

          font->glyphs_size += 64;
        }

        glyph           = font->glyphs + font->glyphs_used++;
        glyph->name     = p->glyph_name;
        glyph->encoding = p->glyph_enc;

        /* Reset the initial glyph info. */
        p->glyph_name = NULL;
      }
      else
      {
        /* Unencoded glyph.  Check whether it should */
        /* be added or not.                          */
        if ( p->opts->keep_unencoded != 0 )
        {
          /* Allocate the next unencoded glyph. */
          if ( font->unencoded_used == font->unencoded_size )
          {
            if ( FT_RENEW_ARRAY( font->unencoded ,
                                 font->unencoded_size,
                                 font->unencoded_size + 4 ) )
              goto Exit;

            font->unencoded_size += 4;
          }

          glyph           = font->unencoded + font->unencoded_used;
          glyph->name     = p->glyph_name;
          glyph->encoding = (long)font->unencoded_used++;

          /* Reset the initial glyph info. */
          p->glyph_name = NULL;
        }
        else
        {
          /* Free up the glyph name if the unencoded shouldn't be */
          /* kept.                                                */
          FT_FREE( p->glyph_name );
        }

        p->glyph_name = NULL;
      }

      /* Clear the flags that might be added when width and height are */
      /* checked for consistency.                                      */
      p->flags &= ~( BDF_GLYPH_WIDTH_CHECK_ | BDF_GLYPH_HEIGHT_CHECK_ );

      p->flags |= BDF_ENCODING_;

      goto Exit;
    }

    /* Point at the glyph being constructed. */
    if ( p->glyph_enc == -1 )
      glyph = font->unencoded + ( font->unencoded_used - 1 );
    else
      glyph = font->glyphs + ( font->glyphs_used - 1 );

    /* Check whether a bitmap is being constructed. */
    if ( p->flags & BDF_BITMAP_ )
    {
      /* If there are more rows than are specified in the glyph metrics, */
      /* ignore the remaining lines.                                     */
      if ( p->row >= (unsigned long)glyph->bbx.height )
      {
        if ( !( p->flags & BDF_GLYPH_HEIGHT_CHECK_ ) )
        {
          FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG13, glyph->encoding ));
          p->flags |= BDF_GLYPH_HEIGHT_CHECK_;
          font->modified = 1;
        }

        goto Exit;
      }

      /* Only collect the number of nibbles indicated by the glyph     */
      /* metrics.  If there are more columns, they are simply ignored. */
      nibbles = glyph->bpr << 1;
      bp      = glyph->bitmap + p->row * glyph->bpr;

      for ( i = 0; i < nibbles; i++ )
      {
        c = line[i];
        if ( !sbitset( hdigits, c ) )
          break;
        *bp = (FT_Byte)( ( *bp << 4 ) + a2i[c] );
        if ( i + 1 < nibbles && ( i & 1 ) )
          *++bp = 0;
      }

      /* If any line has not enough columns,            */
      /* indicate they have been padded with zero bits. */
      if ( i < nibbles                            &&
           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
      {
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG16, glyph->encoding ));
        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
        font->modified  = 1;
      }

      /* Remove possible garbage at the right. */
      mask_index = ( glyph->bbx.width * p->font->bpp ) & 7;
      if ( glyph->bbx.width )
        *bp &= nibble_mask[mask_index];

      /* If any line has extra columns, indicate they have been removed. */
      if ( i == nibbles                           &&
           sbitset( hdigits, line[nibbles] )      &&
           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
      {
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG14, glyph->encoding ));
        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
        font->modified  = 1;
      }

      p->row++;
      goto Exit;
    }

    /* Expect the SWIDTH (scalable width) field next. */
    if ( _bdf_strncmp( line, "SWIDTH", 6 ) == 0 )
    {
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1] );
      p->flags |= BDF_SWIDTH_;

      goto Exit;
    }

    /* Expect the DWIDTH (scalable width) field next. */
    if ( _bdf_strncmp( line, "DWIDTH", 6 ) == 0 )
    {
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1] );

      if ( !( p->flags & BDF_SWIDTH_ ) )
      {
        /* Missing SWIDTH field.  Emit an auto correction message and set */
        /* the scalable width from the device width.                      */
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG9, lineno ));

        glyph->swidth = (unsigned short)FT_MulDiv(
                          glyph->dwidth, 72000L,
                          (FT_Long)( font->point_size *
                                     font->resolution_x ) );
      }

      p->flags |= BDF_DWIDTH_;
      goto Exit;
    }

    /* Expect the BBX field next. */
    if ( _bdf_strncmp( line, "BBX", 3 ) == 0 )
    {
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      glyph->bbx.width    = _bdf_atous( p->list.field[1] );
      glyph->bbx.height   = _bdf_atous( p->list.field[2] );
      glyph->bbx.x_offset = _bdf_atos( p->list.field[3] );
      glyph->bbx.y_offset = _bdf_atos( p->list.field[4] );

      /* Generate the ascent and descent of the character. */
      glyph->bbx.ascent  = (short)( glyph->bbx.height + glyph->bbx.y_offset );
      glyph->bbx.descent = (short)( -glyph->bbx.y_offset );

      /* Determine the overall font bounding box as the characters are */
      /* loaded so corrections can be done later if indicated.         */
      p->maxas    = (short)FT_MAX( glyph->bbx.ascent, p->maxas );
      p->maxds    = (short)FT_MAX( glyph->bbx.descent, p->maxds );

      p->rbearing = (short)( glyph->bbx.width + glyph->bbx.x_offset );

      p->maxrb    = (short)FT_MAX( p->rbearing, p->maxrb );
      p->minlb    = (short)FT_MIN( glyph->bbx.x_offset, p->minlb );
      p->maxlb    = (short)FT_MAX( glyph->bbx.x_offset, p->maxlb );

      if ( !( p->flags & BDF_DWIDTH_ ) )
      {
        /* Missing DWIDTH field.  Emit an auto correction message and set */
        /* the device width to the glyph width.                           */
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG10, lineno ));
        glyph->dwidth = glyph->bbx.width;
      }

      /* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */
      /* value if necessary.                                            */
      if ( p->opts->correct_metrics != 0 )
      {
        /* Determine the point size of the glyph. */
        unsigned short  sw = (unsigned short)FT_MulDiv(
                               glyph->dwidth, 72000L,
                               (FT_Long)( font->point_size *
                                          font->resolution_x ) );


        if ( sw != glyph->swidth )
        {
          glyph->swidth = sw;

          if ( p->glyph_enc == -1 )
            _bdf_set_glyph_modified( font->umod,
                                     font->unencoded_used - 1 );
          else
            _bdf_set_glyph_modified( font->nmod, glyph->encoding );

          p->flags       |= BDF_SWIDTH_ADJ_;
          font->modified  = 1;
        }
      }

      p->flags |= BDF_BBX_;
      goto Exit;
    }

    /* And finally, gather up the bitmap. */
    if ( _bdf_strncmp( line, "BITMAP", 6 ) == 0 )
    {
      unsigned long  bitmap_size;


      if ( !( p->flags & BDF_BBX_ ) )
      {
        /* Missing BBX field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "BBX" ));
        error = FT_THROW( Missing_Bbx_Field );
        goto Exit;
      }

      /* Allocate enough space for the bitmap. */
      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;

      bitmap_size = glyph->bpr * glyph->bbx.height;
      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
        error = FT_THROW( Bbx_Too_Big );
        goto Exit;
      }
      else
        glyph->bytes = (unsigned short)bitmap_size;

      if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )
        goto Exit;

      p->row    = 0;
      p->flags |= BDF_BITMAP_;

      goto Exit;
    }

    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG9, lineno ));
    error = FT_THROW( Invalid_File_Format );
    goto Exit;

  Missing_Encoding:
    /* Missing ENCODING field. */
    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
    error = FT_THROW( Missing_Encoding_Field );

  Exit:
    if ( error && ( p->flags & BDF_GLYPH_ ) )
      FT_FREE( p->glyph_name );

    return error;
  }


  /* Load the font properties. */
  static FT_Error
  _bdf_parse_properties( char*          line,
                         unsigned long  linelen,
                         unsigned long  lineno,
                         void*          call_data,
                         void*          client_data )
  {
    unsigned long      vlen;
    _bdf_line_func_t*  next;
    _bdf_parse_t*      p;
    char*              name;
    char*              value;
    char               nbuf[128];
    FT_Error           error = FT_Err_Ok;

    FT_UNUSED( lineno );


    next = (_bdf_line_func_t *)call_data;
    p    = (_bdf_parse_t *)    client_data;

    /* Check for the end of the properties. */
    if ( _bdf_strncmp( line, "ENDPROPERTIES", 13 ) == 0 )
    {
      /* If the FONT_ASCENT or FONT_DESCENT properties have not been      */
      /* encountered yet, then make sure they are added as properties and */
      /* make sure they are set from the font bounding box info.          */
      /*                                                                  */
      /* This is *always* done regardless of the options, because X11     */
      /* requires these two fields to compile fonts.                      */
      if ( bdf_get_font_property( p->font, "FONT_ASCENT" ) == 0 )
      {
        p->font->font_ascent = p->font->bbx.ascent;
        ft_sprintf( nbuf, "%hd", p->font->bbx.ascent );
        error = _bdf_add_property( p->font, (char *)"FONT_ASCENT",
                                   nbuf, lineno );
        if ( error )
          goto Exit;

        FT_TRACE2(( "_bdf_parse_properties: " ACMSG1, p->font->bbx.ascent ));
        p->font->modified = 1;
      }

      if ( bdf_get_font_property( p->font, "FONT_DESCENT" ) == 0 )
      {
        p->font->font_descent = p->font->bbx.descent;
        ft_sprintf( nbuf, "%hd", p->font->bbx.descent );
        error = _bdf_add_property( p->font, (char *)"FONT_DESCENT",
                                   nbuf, lineno );
        if ( error )
          goto Exit;

        FT_TRACE2(( "_bdf_parse_properties: " ACMSG2, p->font->bbx.descent ));
        p->font->modified = 1;
      }

      p->flags &= ~BDF_PROPS_;
      *next     = _bdf_parse_glyphs;

      goto Exit;
    }

    /* Ignore the _XFREE86_GLYPH_RANGES properties. */
    if ( _bdf_strncmp( line, "_XFREE86_GLYPH_RANGES", 21 ) == 0 )
      goto Exit;

    /* Handle COMMENT fields and properties in a special way to preserve */
    /* the spacing.                                                      */
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
    {
      name = value = line;
      value += 7;
      if ( *value )
        *value++ = 0;
      error = _bdf_add_property( p->font, name, value, lineno );
      if ( error )
        goto Exit;
    }
    else if ( _bdf_is_atom( line, linelen, &name, &value, p->font ) )
    {
      error = _bdf_add_property( p->font, name, value, lineno );
      if ( error )
        goto Exit;
    }
    else
    {
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;
      name = p->list.field[0];

      _bdf_list_shift( &p->list, 1 );
      value = _bdf_list_join( &p->list, ' ', &vlen );

      error = _bdf_add_property( p->font, name, value, lineno );
      if ( error )
        goto Exit;
    }

  Exit:
    return error;
  }


  /* Load the font header. */
  static FT_Error
  _bdf_parse_start( char*          line,
                    unsigned long  linelen,
                    unsigned long  lineno,
                    void*          call_data,
                    void*          client_data )
  {
    unsigned long      slen;
    _bdf_line_func_t*  next;
    _bdf_parse_t*      p;
    bdf_font_t*        font;
    char               *s;

    FT_Memory          memory = NULL;
    FT_Error           error  = FT_Err_Ok;

    FT_UNUSED( lineno );            /* only used in debug mode */


    next = (_bdf_line_func_t *)call_data;
    p    = (_bdf_parse_t *)    client_data;

    if ( p->font )
      memory = p->font->memory;

    /* Check for a comment.  This is done to handle those fonts that have */
    /* comments before the STARTFONT line for some reason.                */
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
    {
      if ( p->opts->keep_comments != 0 && p->font != 0 )
      {
        linelen -= 7;

        s = line + 7;
        if ( *s != 0 )
        {
          s++;
          linelen--;
        }

        error = _bdf_add_comment( p->font, s, linelen );
        if ( error )
          goto Exit;
        /* here font is not defined! */
      }

      goto Exit;
    }

    if ( !( p->flags & BDF_START_ ) )
    {
      memory = p->memory;

      if ( _bdf_strncmp( line, "STARTFONT", 9 ) != 0 )
      {
        /* we don't emit an error message since this code gets */
        /* explicitly caught one level higher                  */
        error = FT_THROW( Missing_Startfont_Field );
        goto Exit;
      }

      p->flags = BDF_START_;
      font = p->font = 0;

      if ( FT_NEW( font ) )
        goto Exit;
      p->font = font;

      font->memory = p->memory;
      p->memory    = 0;

      { /* setup */
        size_t           i;
        bdf_property_t*  prop;


        error = ft_hash_str_init( &(font->proptbl), memory );
        if ( error )
          goto Exit;
        for ( i = 0, prop = (bdf_property_t*)_bdf_properties;
              i < _num_bdf_properties; i++, prop++ )
        {
          error = ft_hash_str_insert( prop->name, i,
                                      &(font->proptbl), memory );
          if ( error )
            goto Exit;
        }
      }

      if ( FT_ALLOC( p->font->internal, sizeof ( FT_HashRec ) ) )
        goto Exit;
      error = ft_hash_str_init( (FT_Hash)p->font->internal, memory );
      if ( error )
        goto Exit;
      p->font->spacing      = p->opts->font_spacing;
      p->font->default_char = -1;

      goto Exit;
    }

    /* Check for the start of the properties. */
    if ( _bdf_strncmp( line, "STARTPROPERTIES", 15 ) == 0 )
    {
      if ( !( p->flags & BDF_FONT_BBX_ ) )
      {
        /* Missing the FONTBOUNDINGBOX field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
        error = FT_THROW( Missing_Fontboundingbox_Field );
        goto Exit;
      }

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      /* at this point, `p->font' can't be NULL */
      p->cnt = p->font->props_size = _bdf_atoul( p->list.field[1] );
      /* We need at least 4 bytes per property. */
      if ( p->cnt > p->size / 4 )
      {
        p->font->props_size = 0;

        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "STARTPROPERTIES" ));
        error = FT_THROW( Invalid_Argument );
        goto Exit;
      }

      if ( FT_NEW_ARRAY( p->font->props, p->cnt ) )
      {
        p->font->props_size = 0;
        goto Exit;
      }

      p->flags |= BDF_PROPS_;
      *next     = _bdf_parse_properties;

      goto Exit;
    }

    /* Check for the FONTBOUNDINGBOX field. */
    if ( _bdf_strncmp( line, "FONTBOUNDINGBOX", 15 ) == 0 )
    {
      if ( !( p->flags & BDF_SIZE_ ) )
      {
        /* Missing the SIZE field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "SIZE" ));
        error = FT_THROW( Missing_Size_Field );
        goto Exit;
      }

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      p->font->bbx.width  = _bdf_atous( p->list.field[1] );
      p->font->bbx.height = _bdf_atous( p->list.field[2] );

      p->font->bbx.x_offset = _bdf_atos( p->list.field[3] );
      p->font->bbx.y_offset = _bdf_atos( p->list.field[4] );

      p->font->bbx.ascent  = (short)( p->font->bbx.height +
                                      p->font->bbx.y_offset );

      p->font->bbx.descent = (short)( -p->font->bbx.y_offset );

      p->flags |= BDF_FONT_BBX_;

      goto Exit;
    }

    /* The next thing to check for is the FONT field. */
    if ( _bdf_strncmp( line, "FONT", 4 ) == 0 )
    {
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;
      _bdf_list_shift( &p->list, 1 );

      s = _bdf_list_join( &p->list, ' ', &slen );

      if ( !s )
      {
        FT_ERROR(( "_bdf_parse_start: " ERRMSG8, lineno, "FONT" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      /* Allowing multiple `FONT' lines (which is invalid) doesn't hurt... */
      FT_FREE( p->font->name );

      if ( FT_NEW_ARRAY( p->font->name, slen + 1 ) )
        goto Exit;
      FT_MEM_COPY( p->font->name, s, slen + 1 );

      /* If the font name is an XLFD name, set the spacing to the one in  */
      /* the font name.  If there is no spacing fall back on the default. */
      error = _bdf_set_default_spacing( p->font, p->opts, lineno );
      if ( error )
        goto Exit;

      p->flags |= BDF_FONT_NAME_;

      goto Exit;
    }

    /* Check for the SIZE field. */
    if ( _bdf_strncmp( line, "SIZE", 4 ) == 0 )
    {
      if ( !( p->flags & BDF_FONT_NAME_ ) )
      {
        /* Missing the FONT field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONT" ));
        error = FT_THROW( Missing_Font_Field );
        goto Exit;
      }

      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
      if ( error )
        goto Exit;

      p->font->point_size   = _bdf_atoul( p->list.field[1] );
      p->font->resolution_x = _bdf_atoul( p->list.field[2] );
      p->font->resolution_y = _bdf_atoul( p->list.field[3] );

      /* Check for the bits per pixel field. */
      if ( p->list.used == 5 )
      {
        unsigned short bpp;


        bpp = (unsigned short)_bdf_atos( p->list.field[4] );

        /* Only values 1, 2, 4, 8 are allowed for greymap fonts. */
        if ( bpp > 4 )
          p->font->bpp = 8;
        else if ( bpp > 2 )
          p->font->bpp = 4;
        else if ( bpp > 1 )
          p->font->bpp = 2;
        else
          p->font->bpp = 1;

        if ( p->font->bpp != bpp )
          FT_TRACE2(( "_bdf_parse_start: " ACMSG11, p->font->bpp ));
      }
      else
        p->font->bpp = 1;

      p->flags |= BDF_SIZE_;

      goto Exit;
    }

    /* Check for the CHARS field -- font properties are optional */
    if ( _bdf_strncmp( line, "CHARS", 5 ) == 0 )
    {
      char  nbuf[128];


      if ( !( p->flags & BDF_FONT_BBX_ ) )
      {
        /* Missing the FONTBOUNDINGBOX field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
        error = FT_THROW( Missing_Fontboundingbox_Field );
        goto Exit;
      }

      /* Add the two standard X11 properties which are required */
      /* for compiling fonts.                                   */
      p->font->font_ascent = p->font->bbx.ascent;
      ft_sprintf( nbuf, "%hd", p->font->bbx.ascent );
      error = _bdf_add_property( p->font, (char *)"FONT_ASCENT",
                                 nbuf, lineno );
      if ( error )
        goto Exit;
      FT_TRACE2(( "_bdf_parse_properties: " ACMSG1, p->font->bbx.ascent ));

      p->font->font_descent = p->font->bbx.descent;
      ft_sprintf( nbuf, "%hd", p->font->bbx.descent );
      error = _bdf_add_property( p->font, (char *)"FONT_DESCENT",
                                 nbuf, lineno );
      if ( error )
        goto Exit;
      FT_TRACE2(( "_bdf_parse_properties: " ACMSG2, p->font->bbx.descent ));

      p->font->modified = 1;

      *next = _bdf_parse_glyphs;

      /* A special return value. */
      error = -1;
      goto Exit;
    }

    FT_ERROR(( "_bdf_parse_start: " ERRMSG9, lineno ));
    error = FT_THROW( Invalid_File_Format );

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* API.                                                                  */
  /*                                                                       */
  /*************************************************************************/


  FT_LOCAL_DEF( FT_Error )
  bdf_load_font( FT_Stream       stream,
                 FT_Memory       extmemory,
                 bdf_options_t*  opts,
                 bdf_font_t*    *font )
  {
    unsigned long  lineno = 0; /* make compiler happy */
    _bdf_parse_t   *p     = NULL;

    FT_Memory  memory = extmemory; /* needed for FT_NEW */
    FT_Error   error  = FT_Err_Ok;


    if ( FT_NEW( p ) )
      goto Exit;

    memory    = NULL;
    p->opts   = (bdf_options_t*)( ( opts != 0 ) ? opts : &_bdf_opts );
    p->minlb  = 32767;
    p->size   = stream->size;
    p->memory = extmemory;  /* only during font creation */

    _bdf_list_init( &p->list, extmemory );

    error = _bdf_readstream( stream, _bdf_parse_start,
                             (void *)p, &lineno );
    if ( error )
      goto Fail;

    if ( p->font != 0 )
    {
      /* If the font is not proportional, set the font's monowidth */
      /* field to the width of the font bounding box.              */

      if ( p->font->spacing != BDF_PROPORTIONAL )
        p->font->monowidth = p->font->bbx.width;

      /* If the number of glyphs loaded is not that of the original count, */
      /* indicate the difference.                                          */
      if ( p->cnt != p->font->glyphs_used + p->font->unencoded_used )
      {
        FT_TRACE2(( "bdf_load_font: " ACMSG15, p->cnt,
                    p->font->glyphs_used + p->font->unencoded_used ));
        p->font->modified = 1;
      }

      /* Once the font has been loaded, adjust the overall font metrics if */
      /* necessary.                                                        */
      if ( p->opts->correct_metrics != 0 &&
           ( p->font->glyphs_used > 0 || p->font->unencoded_used > 0 ) )
      {
        if ( p->maxrb - p->minlb != p->font->bbx.width )
        {
          FT_TRACE2(( "bdf_load_font: " ACMSG3,
                      p->font->bbx.width, p->maxrb - p->minlb ));
          p->font->bbx.width = (unsigned short)( p->maxrb - p->minlb );
          p->font->modified  = 1;
        }

        if ( p->font->bbx.x_offset != p->minlb )
        {
          FT_TRACE2(( "bdf_load_font: " ACMSG4,
                      p->font->bbx.x_offset, p->minlb ));
          p->font->bbx.x_offset = p->minlb;
          p->font->modified     = 1;
        }

        if ( p->font->bbx.ascent != p->maxas )
        {
          FT_TRACE2(( "bdf_load_font: " ACMSG5,
                      p->font->bbx.ascent, p->maxas ));
          p->font->bbx.ascent = p->maxas;
          p->font->modified   = 1;
        }

        if ( p->font->bbx.descent != p->maxds )
        {
          FT_TRACE2(( "bdf_load_font: " ACMSG6,
                      p->font->bbx.descent, p->maxds ));
          p->font->bbx.descent  = p->maxds;
          p->font->bbx.y_offset = (short)( -p->maxds );
          p->font->modified     = 1;
        }

        if ( p->maxas + p->maxds != p->font->bbx.height )
        {
          FT_TRACE2(( "bdf_load_font: " ACMSG7,
                      p->font->bbx.height, p->maxas + p->maxds ));
          p->font->bbx.height = (unsigned short)( p->maxas + p->maxds );
        }

        if ( p->flags & BDF_SWIDTH_ADJ_ )
          FT_TRACE2(( "bdf_load_font: " ACMSG8 ));
      }
    }

    if ( p->flags & BDF_START_ )
    {
      /* The ENDFONT field was never reached or did not exist. */
      if ( !( p->flags & BDF_GLYPHS_ ) )
      {
        /* Error happened while parsing header. */
        FT_ERROR(( "bdf_load_font: " ERRMSG2, lineno ));
        error = FT_THROW( Corrupted_Font_Header );
        goto Fail;
      }
      else
      {
        /* Error happened when parsing glyphs. */
        FT_ERROR(( "bdf_load_font: " ERRMSG3, lineno ));
        error = FT_THROW( Corrupted_Font_Glyphs );
        goto Fail;
      }
    }

    if ( p->font != 0 )
    {
      /* Make sure the comments are NULL terminated if they exist. */
      memory = p->font->memory;

      if ( p->font->comments_len > 0 )
      {
        if ( FT_RENEW_ARRAY( p->font->comments,
                             p->font->comments_len,
                             p->font->comments_len + 1 ) )
          goto Fail;

        p->font->comments[p->font->comments_len] = 0;
      }
    }
    else if ( !error )
      error = FT_THROW( Invalid_File_Format );

    *font = p->font;

  Exit:
    if ( p )
    {
      _bdf_list_done( &p->list );

      memory = extmemory;

      FT_FREE( p->glyph_name );
      FT_FREE( p );
    }

    return error;

  Fail:
    bdf_free_font( p->font );

    memory = extmemory;

    FT_FREE( p->font );

    goto Exit;
  }


  FT_LOCAL_DEF( void )
  bdf_free_font( bdf_font_t*  font )
  {
    bdf_property_t*  prop;
    unsigned long    i;
    bdf_glyph_t*     glyphs;
    FT_Memory        memory;


    if ( font == 0 )
      return;

    memory = font->memory;

    FT_FREE( font->name );

    /* Free up the internal hash table of property names. */
    if ( font->internal )
    {
      ft_hash_str_free( (FT_Hash)font->internal, memory );
      FT_FREE( font->internal );
    }

    /* Free up the comment info. */
    FT_FREE( font->comments );

    /* Free up the properties. */
    for ( i = 0; i < font->props_size; i++ )
    {
      if ( font->props[i].format == BDF_ATOM )
        FT_FREE( font->props[i].value.atom );
    }

    FT_FREE( font->props );

    /* Free up the character info. */
    for ( i = 0, glyphs = font->glyphs;
          i < font->glyphs_used; i++, glyphs++ )
    {
      FT_FREE( glyphs->name );
      FT_FREE( glyphs->bitmap );
    }

    for ( i = 0, glyphs = font->unencoded; i < font->unencoded_used;
          i++, glyphs++ )
    {
      FT_FREE( glyphs->name );
      FT_FREE( glyphs->bitmap );
    }

    FT_FREE( font->glyphs );
    FT_FREE( font->unencoded );

    /* Free up the overflow storage if it was used. */
    for ( i = 0, glyphs = font->overflow.glyphs;
          i < font->overflow.glyphs_used; i++, glyphs++ )
    {
      FT_FREE( glyphs->name );
      FT_FREE( glyphs->bitmap );
    }

    FT_FREE( font->overflow.glyphs );

    /* bdf_cleanup */
    ft_hash_str_free( &(font->proptbl), memory );

    /* Free up the user defined properties. */
    for ( prop = font->user_props, i = 0;
          i < font->nuser_props; i++, prop++ )
    {
      FT_FREE( prop->name );
      if ( prop->format == BDF_ATOM )
        FT_FREE( prop->value.atom );
    }

    FT_FREE( font->user_props );

    /* FREE( font ); */ /* XXX Fixme */
  }


  FT_LOCAL_DEF( bdf_property_t * )
  bdf_get_font_property( bdf_font_t*  font,
                         const char*  name )
  {
    size_t*  propid;


    if ( font == 0 || font->props_size == 0 || name == 0 || *name == 0 )
      return 0;

    propid = ft_hash_str_lookup( name, (FT_Hash)font->internal );

    return propid ? ( font->props + *propid ) : 0;
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d3 1
a3 1
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
d172 11
a182 5
  /*************************************************************************/
  /*                                                                       */
  /* Hash table utilities for the properties.                              */
  /*                                                                       */
  /*************************************************************************/
d184 21
a204 1
  /* XXX: Replace this with FreeType's hash functions */
d206 14
a219 147

#define INITIAL_HT_SIZE  241

  typedef void
  (*hash_free_func)( hashnode  node );

  static hashnode*
  hash_bucket( const char*  key,
               hashtable*   ht )
  {
    const char*    kp  = key;
    unsigned long  res = 0;
    hashnode*      bp  = ht->table, *ndp;


    /* Mocklisp hash function. */
    while ( *kp )
      res = ( res << 5 ) - res + *kp++;

    ndp = bp + ( res % ht->size );
    while ( *ndp )
    {
      kp = (*ndp)->key;
      if ( kp[0] == key[0] && ft_strcmp( kp, key ) == 0 )
        break;
      ndp--;
      if ( ndp < bp )
        ndp = bp + ( ht->size - 1 );
    }

    return ndp;
  }


  static FT_Error
  hash_rehash( hashtable*  ht,
               FT_Memory   memory )
  {
    hashnode*  obp = ht->table, *bp, *nbp;
    int        i, sz = ht->size;
    FT_Error   error = BDF_Err_Ok;


    ht->size <<= 1;
    ht->limit  = ht->size / 3;

    if ( FT_NEW_ARRAY( ht->table, ht->size ) )
      goto Exit;

    for ( i = 0, bp = obp; i < sz; i++, bp++ )
    {
      if ( *bp )
      {
        nbp = hash_bucket( (*bp)->key, ht );
        *nbp = *bp;
      }
    }
    FT_FREE( obp );

  Exit:
    return error;
  }


  static FT_Error
  hash_init( hashtable*  ht,
             FT_Memory   memory )
  {
    int       sz = INITIAL_HT_SIZE;
    FT_Error  error = BDF_Err_Ok;


    ht->size  = sz;
    ht->limit = sz / 3;
    ht->used  = 0;

    if ( FT_NEW_ARRAY( ht->table, sz ) )
      goto Exit;

  Exit:
    return error;
  }


  static void
  hash_free( hashtable*  ht,
             FT_Memory   memory )
  {
    if ( ht != 0 )
    {
      int        i, sz = ht->size;
      hashnode*  bp = ht->table;


      for ( i = 0; i < sz; i++, bp++ )
        FT_FREE( *bp );

      FT_FREE( ht->table );
    }
  }


  static FT_Error
  hash_insert( char*       key,
               size_t      data,
               hashtable*  ht,
               FT_Memory   memory )
  {
    hashnode  nn, *bp = hash_bucket( key, ht );
    FT_Error  error = BDF_Err_Ok;


    nn = *bp;
    if ( !nn )
    {
      if ( FT_NEW( nn ) )
        goto Exit;
      *bp = nn;

      nn->key  = key;
      nn->data = data;

      if ( ht->used >= ht->limit )
      {
        error = hash_rehash( ht, memory );
        if ( error )
          goto Exit;
      }
      ht->used++;
    }
    else
      nn->data = data;

  Exit:
    return error;
  }


  static hashnode
  hash_lookup( const char* key,
               hashtable*  ht )
  {
    hashnode *np = hash_bucket( key, ht );


    return *np;
  }
d273 2
a274 1
    unsigned long   have[2048];
d278 1
d316 1
a316 1
    FT_Error  error = BDF_Err_Ok;
d322 1
a322 1
      unsigned long  newsize = oldsize + ( oldsize >> 1 ) + 4;
d329 1
a329 1
        error = BDF_Err_Out_Of_Memory;
d368 5
d379 1
a379 1
    char           *fp, *dp;
d390 3
a392 1
      fp = list->field[i];
d399 2
a400 1
    dp[j] = 0;
d407 3
a409 4
  /* An empty string for empty fields. */

  static const char  empty[1] = { 0 };      /* XXX eliminate this */

d417 5
a421 4
    int       mult, final_empty;
    char      *sp, *ep, *end;
    char      seps[32];
    FT_Error  error = BDF_Err_Ok;
d426 8
d444 1
a444 1
      error = BDF_Err_Invalid_Argument;
d530 1
a530 1
    char*             buf = 0;
d532 1
a532 1
    FT_Error          error = BDF_Err_Ok;
d537 1
a537 1
      error = BDF_Err_Invalid_Argument;
a550 1
    end     = 0;
d561 3
a563 2
        bytes  = (ptrdiff_t)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
                                               (FT_ULong)(buf_size - cursor) );
d599 2
a600 1
            error = BDF_Err_Invalid_Argument;
d608 1
a608 1
          cursor   = buf_size;
d615 1
a615 1
          FT_MEM_COPY( buf, buf + start, bytes );
d629 2
a630 2
      /* XXX: Use encoding independent value for 0x1a */
      if ( buf[start] != '#' && buf[start] != 0x1a && end > start )
d632 1
a632 1
        error = (*cb)( buf + start, end - start, lineno,
d634 4
d671 1
a671 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
d674 1
a674 1
    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
a678 8
  static const unsigned char  odigits[32] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };

d681 1
a681 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
d689 2
a690 2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
    0x7e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
d696 1
a696 4
#define isdigok( m, d )  (m[(d) >> 3] & ( 1 << ( (d) & 7 ) ) )


  /* Routine to convert an ASCII string into an unsigned long integer. */
d698 1
a698 3
  _bdf_atoul( char*   s,
              char**  end,
              int     base )
d700 1
a700 2
    unsigned long         v;
    const unsigned char*  dmap;
d706 2
a707 29
    /* Make sure the radix is something recognizable.  Default to 10. */
    switch ( base )
    {
    case 8:
      dmap = odigits;
      break;
    case 16:
      dmap = hdigits;
      break;
    default:
      base = 10;
      dmap = ddigits;
      break;
    }

    /* Check for the special hex prefix. */
    if ( *s == '0'                                  &&
         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
    {
      base = 16;
      dmap = hdigits;
      s   += 2;
    }

    for ( v = 0; isdigok( dmap, *s ); s++ )
      v = v * base + a2i[(int)*s];

    if ( end != 0 )
      *end = s;
d713 1
a713 1
  /* Routine to convert an ASCII string into an signed long integer. */
d715 1
a715 3
  _bdf_atol( char*   s,
             char**  end,
             int     base )
d717 1
a717 2
    long                  v, neg;
    const unsigned char*  dmap;
a722 15
    /* Make sure the radix is something recognizable.  Default to 10. */
    switch ( base )
    {
    case 8:
      dmap = odigits;
      break;
    case 16:
      dmap = hdigits;
      break;
    default:
      base = 10;
      dmap = ddigits;
      break;
    }

d731 13
a743 8
    /* Check for the special hex prefix. */
    if ( *s == '0'                                  &&
         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
    {
      base = 16;
      dmap = hdigits;
      s   += 2;
    }
d745 2
a746 2
    for ( v = 0; isdigok( dmap, *s ); s++ )
      v = v * base + a2i[(int)*s];
d748 2
a749 2
    if ( end != 0 )
      *end = s;
d751 1
a751 1
    return ( !neg ) ? v : -v;
d755 1
a755 1
  /* Routine to convert an ASCII string into an signed short integer. */
d757 1
a757 3
  _bdf_atos( char*   s,
             char**  end,
             int     base )
d759 1
a759 2
    short                 v, neg;
    const unsigned char*  dmap;
a764 15
    /* Make sure the radix is something recognizable.  Default to 10. */
    switch ( base )
    {
    case 8:
      dmap = odigits;
      break;
    case 16:
      dmap = hdigits;
      break;
    default:
      base = 10;
      dmap = ddigits;
      break;
    }

d773 2
a774 14
    /* Check for the special hex prefix. */
    if ( *s == '0'                                  &&
         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )
    {
      base = 16;
      dmap = hdigits;
      s   += 2;
    }

    for ( v = 0; isdigok( dmap, *s ); s++ )
      v = (short)( v * base + a2i[(int)*s] );

    if ( end != 0 )
      *end = s;
d809 1
a809 1
    FT_Error         error = BDF_Err_Ok;
d812 1
a812 1
    /* First check to see if the property has      */
d815 1
a815 1
    if ( hash_lookup( name, &(font->proptbl) ) )
d828 1
a828 1
      return BDF_Err_Invalid_Argument;
d840 1
a840 1
    error = hash_insert( p->name, n, &(font->proptbl), memory );
d851 1
a851 1
  FT_LOCAL_DEF( bdf_property_t * )
d855 1
a855 2
    hashnode  hn;
    size_t    propid;
d861 1
a861 1
    if ( ( hn = hash_lookup( name, &(font->proptbl) ) ) == 0 )
d864 2
a865 3
    propid = hn->data;
    if ( propid >= _num_bdf_properties )
      return font->user_props + ( propid - _num_bdf_properties );
d867 1
a867 1
    return (bdf_property_t*)_bdf_properties + propid;
d880 21
a900 21
#define _BDF_START      0x0001
#define _BDF_FONT_NAME  0x0002
#define _BDF_SIZE       0x0004
#define _BDF_FONT_BBX   0x0008
#define _BDF_PROPS      0x0010
#define _BDF_GLYPHS     0x0020
#define _BDF_GLYPH      0x0040
#define _BDF_ENCODING   0x0080
#define _BDF_SWIDTH     0x0100
#define _BDF_DWIDTH     0x0200
#define _BDF_BBX        0x0400
#define _BDF_BITMAP     0x0800

#define _BDF_SWIDTH_ADJ  0x1000

#define _BDF_GLYPH_BITS ( _BDF_GLYPH    | \
                          _BDF_ENCODING | \
                          _BDF_SWIDTH   | \
                          _BDF_DWIDTH   | \
                          _BDF_BBX      | \
                          _BDF_BITMAP   )
d902 2
a903 29
#define _BDF_GLYPH_WIDTH_CHECK   0x40000000UL
#define _BDF_GLYPH_HEIGHT_CHECK  0x80000000UL


  /* Auto correction messages. */
#define ACMSG1   "FONT_ASCENT property missing.  " \
                 "Added \"FONT_ASCENT %hd\".\n"
#define ACMSG2   "FONT_DESCENT property missing.  " \
                 "Added \"FONT_DESCENT %hd\".\n"
#define ACMSG3   "Font width != actual width.  Old: %hd New: %hd.\n"
#define ACMSG4   "Font left bearing != actual left bearing.  " \
                 "Old: %hd New: %hd.\n"
#define ACMSG5   "Font ascent != actual ascent.  Old: %hd New: %hd.\n"
#define ACMSG6   "Font descent != actual descent.  Old: %hd New: %hd.\n"
#define ACMSG7   "Font height != actual height. Old: %hd New: %hd.\n"
#define ACMSG8   "Glyph scalable width (SWIDTH) adjustments made.\n"
#define ACMSG9   "SWIDTH field missing at line %ld.  Set automatically.\n"
#define ACMSG10  "DWIDTH field missing at line %ld.  Set to glyph width.\n"
#define ACMSG11  "SIZE bits per pixel field adjusted to %hd.\n"
#define ACMSG12  "Duplicate encoding %ld (%s) changed to unencoded.\n"
#define ACMSG13  "Glyph %ld extra rows removed.\n"
#define ACMSG14  "Glyph %ld extra columns removed.\n"
#define ACMSG15  "Incorrect glyph count: %ld indicated but %ld found.\n"

  /* Error messages. */
#define ERRMSG1  "[line %ld] Missing \"%s\" line.\n"
#define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
#define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
#define ERRMSG4  "[line %ld] BBX too big.\n"
d913 1
a913 1
    FT_Error   error = BDF_Err_Ok;
d937 2
a938 1
                            bdf_options_t*  opts )
d944 3
a946 1
    FT_Error     error = BDF_Err_Ok;
d951 1
a951 1
      error = BDF_Err_Invalid_Argument;
d965 2
a966 1
      error = BDF_Err_Invalid_Argument;
d972 1
a972 1
    error = _bdf_list_split( &list, (char *)"-", name, len );
d1045 2
a1046 1
    *sp++ = 0;
d1070 4
a1073 3
  _bdf_add_property( bdf_font_t*  font,
                     char*        name,
                     char*        value )
d1075 1
a1075 2
    size_t          propid;
    hashnode        hn;
d1078 3
a1080 1
    FT_Error        error = BDF_Err_Ok;
d1083 3
a1085 2
    /* First, check to see if the property already exists in the font. */
    if ( ( hn = hash_lookup( name, (hashtable *)font->internal ) ) != 0 )
d1089 1
a1089 1
      fp = font->props + hn->data;
d1105 1
a1105 1
        fp->value.l = _bdf_atol( value, 0, 10 );
d1109 1
a1109 1
        fp->value.ul = _bdf_atoul( value, 0, 10 );
d1121 2
a1122 2
    hn = hash_lookup( name, &(font->proptbl) );
    if ( hn == 0 )
d1127 1
a1127 1
      hn = hash_lookup( name, &(font->proptbl) );
d1130 1
a1130 1
    /* Allocate another property if this is overflow. */
d1147 1
a1147 1
      FT_MEM_ZERO( fp, sizeof ( bdf_property_t ) );
d1151 2
a1152 3
    propid = hn->data;
    if ( propid >= _num_bdf_properties )
      prop = font->user_props + ( propid - _num_bdf_properties );
d1154 1
a1154 1
      prop = (bdf_property_t*)_bdf_properties + propid;
d1174 1
a1174 1
      fp->value.l = _bdf_atol( value, 0, 10 );
d1178 1
a1178 1
      fp->value.ul = _bdf_atoul( value, 0, 10 );
d1184 2
a1185 1
    if ( ft_memcmp( name, "COMMENT", 7 ) != 0 ) {
d1187 4
a1190 4
      error = hash_insert( fp->name,
                           font->props_used,
                           (hashtable *)font->internal,
                           memory );
d1202 1
a1202 1
    if ( ft_memcmp( name, "DEFAULT_CHAR", 12 ) == 0 )
d1204 1
a1204 1
    else if ( ft_memcmp( name, "FONT_ASCENT", 11 ) == 0 )
d1206 1
a1206 1
    else if ( ft_memcmp( name, "FONT_DESCENT", 12 ) == 0 )
d1208 1
a1208 1
    else if ( ft_memcmp( name, "SPACING", 7 ) == 0 )
d1212 2
a1213 1
        error = BDF_Err_Invalid_File_Format;
d1254 1
a1254 1
    FT_Error           error = BDF_Err_Ok;
d1266 1
a1266 1
    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
d1281 1
a1281 1
    if ( !( p->flags & _BDF_GLYPHS ) )
d1283 1
a1283 1
      if ( ft_memcmp( line, "CHARS", 5 ) != 0 )
d1286 1
a1286 1
        error = BDF_Err_Missing_Chars_Field;
d1293 8
a1300 1
      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1], 0, 10 );
d1308 1
a1308 1
      if ( p->cnt >= 1114112UL )
d1310 2
a1311 1
        error = BDF_Err_Invalid_Argument;
d1318 1
a1318 1
      p->flags |= _BDF_GLYPHS;
d1324 1
a1324 1
    if ( ft_memcmp( line, "ENDFONT", 7 ) == 0 )
d1326 8
d1340 1
a1340 1
      p->flags &= ~_BDF_START;
d1346 1
a1346 1
    if ( ft_memcmp( line, "ENDCHAR", 7 ) == 0 )
d1349 1
a1349 1
      p->flags    &= ~_BDF_GLYPH_BITS;
d1354 3
a1356 3
    /* Check to see whether a glyph is being scanned but should be */
    /* ignored because it is an unencoded glyph.                   */
    if ( ( p->flags & _BDF_GLYPH )     &&
d1362 1
a1362 1
    if ( ft_memcmp( line, "STARTCHAR", 9 ) == 0 )
d1364 8
d1386 2
a1387 1
        error = BDF_Err_Invalid_File_Format;
d1396 3
a1398 1
      p->flags |= _BDF_GLYPH;
d1404 1
a1404 1
    if ( ft_memcmp( line, "ENCODING", 8 ) == 0 )
d1406 1
a1406 1
      if ( !( p->flags & _BDF_GLYPH ) )
d1410 1
a1410 1
        error = BDF_Err_Missing_Startchar_Field;
d1418 10
a1427 1
      p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );
d1429 10
a1438 3
      /* Check that the encoding is in the range [0,65536] because        */
      /* otherwise p->have (a bitmap with static size) overflows.         */
      if ( (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )
d1440 2
a1441 1
        error = BDF_Err_Invalid_File_Format;
d1445 3
a1447 3
      /* Check to see whether this encoding has already been encountered. */
      /* If it has then change it to unencoded so it gets added if        */
      /* indicated.                                                       */
d1482 1
a1482 1
        p->glyph_name = 0;
d1486 2
a1487 2
        /* Unencoded glyph.  Check to see whether it should */
        /* be added or not.                                 */
d1503 4
a1506 1
          glyph->encoding = font->unencoded_used++;
d1509 1
d1513 1
d1515 1
a1515 1
        p->glyph_name = 0;
d1520 1
a1520 1
      p->flags &= ~( _BDF_GLYPH_WIDTH_CHECK | _BDF_GLYPH_HEIGHT_CHECK );
d1522 1
a1522 1
      p->flags |= _BDF_ENCODING;
d1533 2
a1534 2
    /* Check to see whether a bitmap is being constructed. */
    if ( p->flags & _BDF_BITMAP )
d1540 1
a1540 1
        if ( !( p->flags & _BDF_GLYPH_HEIGHT_CHECK ) )
d1543 1
a1543 1
          p->flags |= _BDF_GLYPH_HEIGHT_CHECK;
d1558 2
d1565 10
d1581 3
a1583 2
      if ( ( line[nibbles] == '0' || a2i[(int)line[nibbles]] != 0 ) &&
           !( p->flags & _BDF_GLYPH_WIDTH_CHECK )                   )
d1586 1
a1586 1
        p->flags       |= _BDF_GLYPH_WIDTH_CHECK;
d1595 1
a1595 1
    if ( ft_memcmp( line, "SWIDTH", 6 ) == 0 )
d1597 2
a1598 7
      if ( !( p->flags & _BDF_ENCODING ) )
      {
        /* Missing ENCODING field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
        error = BDF_Err_Missing_Encoding_Field;
        goto Exit;
      }
d1604 2
a1605 2
      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );
      p->flags |= _BDF_SWIDTH;
d1611 1
a1611 1
    if ( ft_memcmp( line, "DWIDTH", 6 ) == 0 )
d1613 3
d1620 1
a1620 1
      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1], 0, 10 );
d1622 1
a1622 1
      if ( !( p->flags & _BDF_SWIDTH ) )
d1634 1
a1634 1
      p->flags |= _BDF_DWIDTH;
d1639 1
a1639 1
    if ( ft_memcmp( line, "BBX", 3 ) == 0 )
d1641 3
d1648 4
a1651 4
      glyph->bbx.width    = _bdf_atos( p->list.field[1], 0, 10 );
      glyph->bbx.height   = _bdf_atos( p->list.field[2], 0, 10 );
      glyph->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );
      glyph->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );
d1668 1
a1668 1
      if ( !( p->flags & _BDF_DWIDTH ) )
d1697 1
a1697 1
          p->flags       |= _BDF_SWIDTH_ADJ;
d1702 1
a1702 1
      p->flags |= _BDF_BBX;
d1707 1
a1707 1
    if ( ft_memcmp( line, "BITMAP", 6 ) == 0 )
d1712 1
a1712 1
      if ( !( p->flags & _BDF_BBX ) )
d1716 1
a1716 1
        error = BDF_Err_Missing_Bbx_Field;
d1721 1
a1721 1
      glyph->bpr   = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
d1724 1
a1724 1
      if ( bitmap_size > 0xFFFFU )
d1727 1
a1727 1
        error = BDF_Err_Bbx_Too_Big;
d1737 1
a1737 1
      p->flags |= _BDF_BITMAP;
d1742 8
a1749 1
    error = BDF_Err_Invalid_File_Format;
d1752 3
d1773 1
a1773 1
    FT_Error           error = BDF_Err_Ok;
d1782 1
a1782 1
    if ( ft_memcmp( line, "ENDPROPERTIES", 13 ) == 0 )
d1794 2
a1795 1
        error = _bdf_add_property( p->font, (char *)"FONT_ASCENT", nbuf );
d1807 2
a1808 1
        error = _bdf_add_property( p->font, (char *)"FONT_DESCENT", nbuf );
d1816 1
a1816 1
      p->flags &= ~_BDF_PROPS;
d1823 1
a1823 1
    if ( ft_memcmp( line, "_XFREE86_GLYPH_RANGES", 21 ) == 0 )
d1828 1
a1828 1
    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
d1834 1
a1834 1
      error = _bdf_add_property( p->font, name, value );
d1840 1
a1840 1
      error = _bdf_add_property( p->font, name, value );
d1854 1
a1854 1
      error = _bdf_add_property( p->font, name, value );
d1879 1
a1879 1
    FT_Error           error  = BDF_Err_Ok;
d1892 1
a1892 1
    if ( ft_memcmp( line, "COMMENT", 7 ) == 0 )
d1914 1
a1914 1
    if ( !( p->flags & _BDF_START ) )
d1918 1
a1918 1
      if ( ft_memcmp( line, "STARTFONT", 9 ) != 0 )
d1920 3
a1922 2
        /* No STARTFONT field is a good indication of a problem. */
        error = BDF_Err_Missing_Startfont_Field;
d1926 1
a1926 1
      p->flags = _BDF_START;
d1941 1
a1941 1
        error = hash_init( &(font->proptbl), memory );
d1947 2
a1948 2
          error = hash_insert( prop->name, i,
                               &(font->proptbl), memory );
d1954 1
a1954 1
      if ( FT_ALLOC( p->font->internal, sizeof ( hashtable ) ) )
d1956 1
a1956 1
      error = hash_init( (hashtable *)p->font->internal,memory );
d1966 1
a1966 1
    if ( ft_memcmp( line, "STARTPROPERTIES", 15 ) == 0 )
d1968 8
d1979 1
d1981 10
a1990 1
      p->cnt = p->font->props_size = _bdf_atoul( p->list.field[1], 0, 10 );
d1993 2
d1996 1
d1998 1
a1998 1
      p->flags |= _BDF_PROPS;
d2005 1
a2005 1
    if ( ft_memcmp( line, "FONTBOUNDINGBOX", 15 ) == 0 )
d2007 1
a2007 1
      if ( !(p->flags & _BDF_SIZE ) )
d2011 1
a2011 1
        error = BDF_Err_Missing_Size_Field;
d2019 2
a2020 2
      p->font->bbx.width  = _bdf_atos( p->list.field[1], 0, 10 );
      p->font->bbx.height = _bdf_atos( p->list.field[2], 0, 10 );
d2022 2
a2023 2
      p->font->bbx.x_offset = _bdf_atos( p->list.field[3], 0, 10 );
      p->font->bbx.y_offset = _bdf_atos( p->list.field[4], 0, 10 );
d2030 1
a2030 1
      p->flags |= _BDF_FONT_BBX;
d2036 1
a2036 1
    if ( ft_memcmp( line, "FONT", 4 ) == 0 )
d2047 2
a2048 1
        error = BDF_Err_Invalid_File_Format;
d2052 3
d2061 1
a2061 1
      error = _bdf_set_default_spacing( p->font, p->opts );
d2065 1
a2065 1
      p->flags |= _BDF_FONT_NAME;
d2071 1
a2071 1
    if ( ft_memcmp( line, "SIZE", 4 ) == 0 )
d2073 1
a2073 1
      if ( !( p->flags & _BDF_FONT_NAME ) )
d2077 1
a2077 1
        error = BDF_Err_Missing_Font_Field;
d2085 3
a2087 3
      p->font->point_size   = _bdf_atoul( p->list.field[1], 0, 10 );
      p->font->resolution_x = _bdf_atoul( p->list.field[2], 0, 10 );
      p->font->resolution_y = _bdf_atoul( p->list.field[3], 0, 10 );
d2092 1
a2092 1
        unsigned short bitcount, i, shift;
d2095 1
a2095 1
        p->font->bpp = (unsigned short)_bdf_atos( p->list.field[4], 0, 10 );
d2097 9
a2105 9
        /* Only values 1, 2, 4, 8 are allowed. */
        shift = p->font->bpp;
        bitcount = 0;
        for ( i = 0; shift > 0; i++ )
        {
          if ( shift & 1 )
            bitcount = i;
          shift >>= 1;
        }
d2107 1
a2107 6
        shift = (short)( ( bitcount > 3 ) ? 8 : ( 1 << bitcount ) );

        if ( p->font->bpp > shift || p->font->bpp != shift )
        {
          /* select next higher value */
          p->font->bpp = (unsigned short)( shift << 1 );
a2108 1
        }
d2113 38
a2150 1
      p->flags |= _BDF_SIZE;
d2152 4
d2159 2
a2160 1
    error = BDF_Err_Invalid_File_Format;
d2181 1
a2181 1
    _bdf_parse_t   *p;
d2183 2
a2184 2
    FT_Memory      memory = extmemory;
    FT_Error       error  = BDF_Err_Ok;
d2193 1
a2206 1
      memory = p->font->memory;
d2265 1
a2265 1
        if ( p->flags & _BDF_SWIDTH_ADJ )
d2270 1
a2270 1
    if ( p->flags & _BDF_START )
d2272 2
d2275 11
a2285 15
        /* The ENDFONT field was never reached or did not exist. */
        if ( !( p->flags & _BDF_GLYPHS ) )
        {
          /* Error happened while parsing header. */
          FT_ERROR(( "bdf_load_font: " ERRMSG2, lineno ));
          error = BDF_Err_Corrupted_Font_Header;
          goto Exit;
        }
        else
        {
          /* Error happened when parsing glyphs. */
          FT_ERROR(( "bdf_load_font: " ERRMSG3, lineno ));
          error = BDF_Err_Corrupted_Font_Glyphs;
          goto Exit;
        }
d2294 2
a2295 1
      if ( p->font->comments_len > 0 ) {
d2304 2
a2305 2
    else if ( error == BDF_Err_Ok )
      error = BDF_Err_Invalid_File_Format;
d2316 1
d2352 1
a2352 1
      hash_free( (hashtable *)font->internal, memory );
d2397 1
a2397 1
    hash_free( &(font->proptbl), memory );
d2400 2
a2401 2
    for (prop = font->user_props, i = 0;
         i < font->nuser_props; i++, prop++ )
d2418 1
a2418 1
    hashnode  hn;
d2424 1
a2424 1
    hn = hash_lookup( name, (hashtable *)font->internal );
d2426 1
a2426 1
    return hn ? ( font->props + hn->data ) : 0;
@


1.4
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d3 1
a3 1
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
a23 1
/* $XFree86: xc/extras/freetype2/src/bdf/bdflib.c,v 1.4 2004/04/26 16:15:54 dawes Exp $ */
d284 1
a284 1
               void*       data,
d418 2
a419 2
  _bdf_list_ensure( _bdf_list_t*  list,
                    int           num_items )
d424 1
a424 1
    if ( num_items > (int)list->size )
d426 4
a429 4
      int        oldsize = list->size;
      int        newsize = oldsize + ( oldsize >> 1 ) + 4;
      int        bigsize = FT_INT_MAX / sizeof ( char* );
      FT_Memory  memory  = list->memory;
d617 2
a618 2
    int               refill, bytes, hold, to_skip;
    int               start, end, cursor, avail;
d651 2
a652 2
        bytes  = (int)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
                                         (FT_ULong)(buf_size - cursor) );
d974 1
a974 1
    unsigned long    n;
d994 3
a996 1
    n = (unsigned long)( ft_strlen( name ) + 1 );
d1008 1
a1008 1
    error = hash_insert( p->name, (void *)n, &(font->proptbl), memory );
d1023 2
a1024 2
    hashnode       hn;
    unsigned long  propid;
d1033 1
a1033 1
    propid = (unsigned long)hn->data;
d1136 5
a1140 5
    unsigned long  len;
    char           name[256];
    _bdf_list_t    list;
    FT_Memory      memory;
    FT_Error       error = BDF_Err_Ok;
d1155 1
a1155 1
    len = (unsigned long)( ft_strlen( font->name ) + 1 );
d1266 1
a1266 1
    unsigned long   propid;
d1278 1
a1278 1
      fp = font->props + (unsigned long)hn->data;
d1294 1
a1294 1
        fp->value.int32 = _bdf_atol( value, 0, 10 );
d1298 1
a1298 1
        fp->value.card32 = _bdf_atoul( value, 0, 10 );
d1340 1
a1340 1
    propid = (unsigned long)hn->data;
d1364 1
a1364 1
      fp->value.int32 = _bdf_atol( value, 0, 10 );
d1368 1
a1368 1
      fp->value.card32 = _bdf_atoul( value, 0, 10 );
d1377 1
a1377 1
                           (void *)font->props_used,
d1392 1
a1392 1
      font->default_char = fp->value.int32;
d1394 1
a1394 1
      font->font_ascent = fp->value.int32;
d1396 1
a1396 1
      font->font_descent = fp->value.int32;
d1399 6
d2049 1
a2049 1
        unsigned long    i;
d2059 1
a2059 1
          error = hash_insert( prop->name, (void *)i,
d2083 1
d2477 1
a2477 1
    return hn ? ( font->props + (unsigned long)hn->data ) : 0;
@


1.3
log
@fix CVE 2007-1351 for freetype2, patch from that Other bsd
@
text
@d3 2
a4 1
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006 Francesco Zappa Nardelli
a1266 1
    int             len;
d1285 1
a1285 6
        if ( value == 0 )
          len = 1;
        else
          len = ft_strlen( value ) + 1;

        if ( len > 1 )
d1287 1
a1287 1
          if ( FT_NEW_ARRAY( fp->value.atom, len ) )
a1288 1
          FT_MEM_COPY( fp->value.atom, value, len );
a1289 2
        else
          fp->value.atom = 0;
d1354 2
a1355 6
      if ( value == 0 )
        len = 1;
      else
        len = ft_strlen( value ) + 1;

      if ( len > 1 )
d1357 1
a1357 1
        if ( FT_NEW_ARRAY( fp->value.atom, len ) )
a1358 1
        FT_MEM_COPY( fp->value.atom, value, len );
a1359 2
      else
        fp->value.atom = 0;
d1541 6
d2127 7
d2223 1
a2223 1
    unsigned long  lineno;
d2243 1
a2243 1
      goto Exit;
d2318 1
d2321 3
d2325 1
d2328 3
d2343 1
a2343 1
          goto Exit;
d2364 9
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d388 4
a391 2
#define setsbit( m, cc )  ( m[(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
#define sbitset( m, cc )  ( m[(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )
d1135 1
a1135 1
    char           name[128];
d1154 7
d1495 8
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright 2001, 2002, 2003, 2004 Francesco Zappa Nardelli
a227 1
    FT_MEM_ZERO( ht->table, sizeof ( hashnode ) * ht->size );
a257 1
    FT_MEM_ZERO( ht->table, sizeof ( hashnode ) * sz );
d353 1
d392 110
a506 3
  /* Assume the line is NULL-terminated and that the `list' parameter */
  /* was initialized the first time it was used.                      */

d508 4
a511 5
  _bdf_split( char*          separators,
              char*          line,
              unsigned long  linelen,
              _bdf_list_t*   list,
              FT_Memory      memory )
d560 3
a562 14
        if ( list->size == 0 )
        {
          if ( FT_NEW_ARRAY( list->field, 5 ) )
            goto Exit;
        }
        else
        {
          if ( FT_RENEW_ARRAY ( list->field ,
                                list->size,
                                list->size + 5 ) )
            goto Exit;
        }

        list->size += 5;
d587 1
a587 1
    if ( list->used + final_empty + 1 >= list->size )
d589 3
a591 17
      if ( list->used == list->size )
      {
        if ( list->size == 0 )
        {
          if ( FT_NEW_ARRAY( list->field, 5 ) )
            goto Exit;
        }
        else
        {
          if ( FT_RENEW_ARRAY( list->field,
                               list->size,
                               list->size + 5 ) )
            goto Exit;
        }

        list->size += 5;
      }
a596 18
    if ( list->used == list->size )
    {
      if ( list->size == 0 )
      {
        if ( FT_NEW_ARRAY( list->field, 5 ) )
          goto Exit;
      }
      else
      {
        if ( FT_RENEW_ARRAY( list->field,
                             list->size,
                             list->size + 5 ) )
          goto Exit;
      }

      list->size += 5;
    }

d604 1
a604 93
  static void
  _bdf_shift( unsigned long  n,
              _bdf_list_t*   list )
  {
    unsigned long  i, u;


    if ( list == 0 || list->used == 0 || n == 0 )
      return;

    if ( n >= list->used )
    {
      list->used = 0;
      return;
    }

    for ( u = n, i = 0; u < list->used; i++, u++ )
      list->field[i] = list->field[u];
    list->used -= n;
  }


  static char *
  _bdf_join( int             c,
             unsigned long*  len,
             _bdf_list_t*    list )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    if ( list == 0 || list->used == 0 )
      return 0;

    *len = 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    dp[j] = 0;

    *len = j;
    return dp;
  }


  /* High speed file reader that passes each line to a callback. */
  static FT_Error
  bdf_internal_readstream( FT_Stream  stream,
                           char*      buffer,
                           int        count,
                           int       *read_bytes )
  {
    int            rbytes;
    unsigned long  pos   = stream->pos;
    FT_Error       error = BDF_Err_Ok;


    if ( pos > stream->size )
    {
      FT_ERROR(( "bdf_internal_readstream:" ));
      FT_ERROR(( " invalid i/o; pos = 0x%lx, size = 0x%lx\n",
                 pos, stream->size ));
      error = BDF_Err_Invalid_Stream_Operation;
      goto Exit;
    }

    if ( stream->read )
      rbytes = stream->read( stream, pos,
                             (unsigned char *)buffer, count );
    else
    {
      rbytes = stream->size - pos;
      if ( rbytes > count )
        rbytes = count;

      FT_MEM_COPY( buffer, stream->base + pos, rbytes );
    }

    stream->pos = pos + rbytes;

    *read_bytes = rbytes;

  Exit:
    return error;
  }
d614 4
a617 4
    unsigned long     lineno;
    int               n, done, refill, bytes, hold;
    char              *ls, *le, *pp, *pe, *hp;
    char              *buf = 0;
d628 4
a631 1
    if ( FT_NEW_ARRAY( buf, 65536L ) )
d634 10
a643 3
    cb     = callback;
    lineno = 1;
    buf[0] = 0;
d645 10
a654 2
    done = 0;
    pp = ls = le = buf;
d656 1
a656 1
    bytes = 65536L;
d658 7
a664 5
    while ( !done )
    {
      error = bdf_internal_readstream( stream, pp, bytes, &n );
      if ( error )
        goto Exit;
d666 3
a668 5
      if ( n == 0 )
        break;

      /* Determine the new end of the buffer pages. */
      pe = pp + n;
d670 3
a672 1
      for ( refill = 0; done == 0 && refill == 0; )
d674 2
a675 2
        while ( le < pe && *le != '\n' && *le != '\r' )
          le++;
d677 1
a677 1
        if ( le == pe )
d679 17
a695 16
          /* Hit the end of the last page in the buffer.  Need to find */
          /* out how many pages to shift and how many pages need to be */
          /* read in.  Adjust the line start and end pointers down to  */
          /* point to the right places in the pages.                   */

          pp  = buf + ( ( ( ls - buf ) >> 13 ) << 13 );
          n   = pp - buf;
          ls -= n;
          le -= n;
          n   = pe - pp;

          FT_MEM_MOVE( buf, pp, n );

          pp     = buf + n;
          bytes  = 65536L - n;
          refill = 1;
d699 1
a699 18
          /* Temporarily NULL-terminate the line. */
          hp   = le;
          hold = *le;
          *le  = 0;

          /* XXX: Use encoding independent value for 0x1a */
          if ( *ls != '#' && *ls != 0x1a                          &&
               le > ls                                            &&
               ( error = (*cb)( ls, le - ls, lineno, (void *)&cb,
                                client_data ) ) != BDF_Err_Ok     )
            done = 1;
          else
          {
            ls = ++le;
            /* Handle the case of DOS crlf sequences. */
            if ( le < pe && hold == '\n' && *le =='\r' )
              ls = ++le;
          }
d701 1
a701 2
          /* Increment the line number. */
          lineno++;
d703 3
a705 2
          /* Restore the character at the end of the line. */
          *hp = (char)hold;
d707 15
d723 11
d736 1
a736 1
    *lno             = lineno;
d959 2
a960 1
    else if ( c1->encoding > c2->encoding )
d984 4
a987 12
    if ( font->nuser_props == 0 )
    {
      if ( FT_NEW_ARRAY( font->user_props, 1 ) )
        goto Exit;
    }
    else
    {
      if ( FT_RENEW_ARRAY( font->user_props,
                           font->nuser_props,
                           font->nuser_props + 1 ) )
        goto Exit;
    }
d990 1
a990 1
    FT_MEM_ZERO( p, sizeof ( bdf_property_t ) );
d993 1
d1068 2
a1069 2
#define _BDF_GLYPH_WIDTH_CHECK   0x40000000L
#define _BDF_GLYPH_HEIGHT_CHECK  0x80000000L
d1096 1
d1109 4
a1112 12
    if ( font->comments_len == 0 )
    {
      if ( FT_NEW_ARRAY( font->comments, len + 1 ) )
        goto Exit;
    }
    else
    {
      if ( FT_RENEW_ARRAY( font->comments,
                           font->comments_len,
                           font->comments_len + len + 1 ) )
        goto Exit;
    }
d1115 1
d1117 2
a1118 2
    cp   += len;
    *cp++ = '\n';
d1147 2
d1154 1
a1154 3
    list.size = list.used = 0;

    error = _bdf_split( (char *)"-", name, len, &list, memory );
d1156 1
a1156 1
      goto Exit;
d1177 2
a1178 1
    FT_FREE( list.field );
d1397 1
a1397 1
      font->default_glyph = fp->value.int32;
d1477 1
a1477 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d1531 1
a1531 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list,memory );
a1533 1
      _bdf_shift( 1, &p->list );
d1535 3
a1537 1
      s = _bdf_join( ' ', &slen, &p->list );
d1541 1
d1560 1
a1560 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d1563 1
d1566 8
d1602 1
a1602 2
          FT_MEM_ZERO( font->glyphs + font->glyphs_size,
                       sizeof ( bdf_glyph_t ) * 64 ); /* FZ inutile */
d1622 5
a1626 12
            if ( font->unencoded_size == 0 )
            {
              if ( FT_NEW_ARRAY( font->unencoded, 4 ) )
                goto Exit;
            }
            else
            {
              if ( FT_RENEW_ARRAY( font->unencoded ,
                                   font->unencoded_size,
                                   font->unencoded_size + 4 ) )
                goto Exit;
            }
d1679 1
a1679 1
      for ( i = 0, *bp = 0; i < nibbles; i++ )
d1689 2
a1690 1
      *bp &= nibble_mask[mask_index];
d1716 1
a1716 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d1719 1
d1729 1
a1729 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list,memory );
d1732 1
d1754 1
a1754 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d1819 3
d1832 10
a1841 1
      glyph->bytes = (unsigned short)( glyph->bpr * glyph->bbx.height );
a1872 1
    FT_Memory          memory;
a1880 2
    memory = p->font->memory;

d1944 1
a1944 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d1949 2
a1950 2
      _bdf_shift( 1, &p->list );
      value = _bdf_join( ' ', &vlen, &p->list );
d2056 2
a2057 2
      p->font->spacing       = p->opts->font_spacing;
      p->font->default_glyph = -1;
d2065 1
a2065 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d2090 1
a2090 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list , memory );
d2113 1
a2113 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list , memory );
d2116 1
a2116 1
      _bdf_shift( 1, &p->list );
d2118 1
a2118 1
      s = _bdf_join( ' ', &slen, &p->list );
d2145 1
a2145 1
      error = _bdf_split( (char *)" +", line, linelen, &p->list, memory );
d2215 1
a2215 1
    if ( FT_ALLOC( p, sizeof ( _bdf_parse_t ) ) )
d2223 2
a2310 4
    /* Free up the list used during the parsing. */
    if ( memory != NULL )
      FT_FREE( p->list.field );

d2333 2
d2336 1
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d3 1
a3 2
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
 *   Francesco Zappa Nardelli
d23 1
d228 1
d259 1
a354 1
    FT_Memory      memory;
d389 2
a390 114
#define setsbit( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
#define sbitset( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )


  static void
  _bdf_list_init( _bdf_list_t*  list,
                  FT_Memory     memory )
  {
    FT_ZERO( list );
    list->memory = memory;
  }


  static void
  _bdf_list_done( _bdf_list_t*  list )
  {
    FT_Memory  memory = list->memory;


    if ( memory )
    {
      FT_FREE( list->field );
      FT_ZERO( list );
    }
  }


  static FT_Error
  _bdf_list_ensure( _bdf_list_t*  list,
                    int           num_items )
  {
    FT_Error  error = BDF_Err_Ok;


    if ( num_items > (int)list->size )
    {
      int        oldsize = list->size;
      int        newsize = oldsize + ( oldsize >> 1 ) + 4;
      int        bigsize = FT_INT_MAX / sizeof ( char* );
      FT_Memory  memory  = list->memory;


      if ( oldsize == bigsize )
      {
        error = BDF_Err_Out_Of_Memory;
        goto Exit;
      }
      else if ( newsize < oldsize || newsize > bigsize )
        newsize = bigsize;

      if ( FT_RENEW_ARRAY( list->field, oldsize, newsize ) )
        goto Exit;

      list->size = newsize;
    }

  Exit:
    return error;
  }


  static void
  _bdf_list_shift( _bdf_list_t*   list,
                   unsigned long  n )
  {
    unsigned long  i, u;


    if ( list == 0 || list->used == 0 || n == 0 )
      return;

    if ( n >= list->used )
    {
      list->used = 0;
      return;
    }

    for ( u = n, i = 0; u < list->used; i++, u++ )
      list->field[i] = list->field[u];
    list->used -= n;
  }


  static char *
  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    dp[j] = 0;

    *alen = j;
    return dp;
  }
d398 3
d402 5
a406 4
  _bdf_list_split( _bdf_list_t*   list,
                   char*          separators,
                   char*          line,
                   unsigned long  linelen )
d455 14
a468 3
        error = _bdf_list_ensure( list, list->used + 1 );
        if ( error )
          goto Exit;
d493 1
a493 1
    if ( list->used + final_empty >= list->size )
d495 17
a511 3
      error = _bdf_list_ensure( list, list->used + final_empty + 1 );
      if ( error )
        goto Exit;
d517 18
d542 93
a634 1
#define NO_SKIP  256  /* this value cannot be stored in a 'char' */
d644 4
a647 4
    unsigned long     lineno, buf_size;
    int               refill, bytes, hold, to_skip;
    int               start, end, cursor, avail;
    char*             buf = 0;
d658 6
a663 2
    /* initial size and allocation of the input buffer */
    buf_size = 1024;
d665 2
a666 2
    if ( FT_NEW_ARRAY( buf, buf_size ) )
      goto Exit;
d668 1
a668 10
    cb      = callback;
    lineno  = 1;
    buf[0]  = 0;
    start   = 0;
    end     = 0;
    avail   = 0;
    cursor  = 0;
    refill  = 1;
    to_skip = NO_SKIP;
    bytes   = 0;        /* make compiler happy */
d670 1
a670 1
    for (;;)
d672 3
a674 8
      if ( refill )
      {
        bytes  = (int)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
                                         (FT_ULong)(buf_size - cursor) );
        avail  = cursor + bytes;
        cursor = 0;
        refill = 0;
      }
d676 2
a677 1
      end = start;
d679 2
a680 11
      /* should we skip an optional character like \n or \r? */
      if ( start < avail && buf[start] == to_skip )
      {
        start  += 1;
        to_skip = NO_SKIP;
        continue;
      }

      /* try to find the end of the line */
      while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
        end++;
d682 1
a682 3
      /* if we hit the end of the buffer, try shifting its content */
      /* or even resizing it                                       */
      if ( end >= avail )
d684 2
a685 2
        if ( bytes == 0 )  /* last line in file doesn't end in \r or \n */
          break;           /* ignore it then exit                       */
d687 1
a687 1
        if ( start == 0 )
d689 16
a704 17
          /* this line is definitely too long; try resizing the input */
          /* buffer a bit to handle it.                               */
          FT_ULong  new_size;


          if ( buf_size >= 65536UL )  /* limit ourselves to 64KByte */
          {
            error = BDF_Err_Invalid_Argument;
            goto Exit;
          }

          new_size = buf_size * 2;
          if ( FT_RENEW_ARRAY( buf, buf_size, new_size ) )
            goto Exit;

          cursor   = buf_size;
          buf_size = new_size;
d708 18
a725 1
          bytes = avail - start;
d727 2
a728 1
          FT_MEM_COPY( buf, buf + start, bytes );
d730 2
a731 3
          cursor = bytes;
          avail -= bytes;
          start  = 0;
a732 2
        refill = 1;
        continue;
a733 24

      /* Temporarily NUL-terminate the line. */
      hold     = buf[end];
      buf[end] = 0;

      /* XXX: Use encoding independent value for 0x1a */
      if ( buf[start] != '#' && buf[start] != 0x1a && end > start )
      {
        error = (*cb)( buf + start, end - start, lineno,
                       (void*)&cb, client_data );
        if ( error )
          break;
      }

      lineno  += 1;
      buf[end] = (char)hold;
      start    = end + 1;

      if ( hold == '\n' )
        to_skip = '\r';
      else if ( hold == '\r' )
        to_skip = '\n';
      else
        to_skip = NO_SKIP;
d736 1
a736 1
    *lno = lineno;
d959 1
a959 2

    if ( c1->encoding > c2->encoding )
d983 12
a994 4
    if ( FT_RENEW_ARRAY( font->user_props,
                         font->nuser_props,
                         font->nuser_props + 1 ) )
      goto Exit;
d997 1
a997 1
    FT_ZERO( p );
a999 1

d1074 2
a1075 2
#define _BDF_GLYPH_WIDTH_CHECK   0x40000000UL
#define _BDF_GLYPH_HEIGHT_CHECK  0x80000000UL
a1101 1
#define ERRMSG4  "[line %ld] BBX too big.\n"
d1114 12
a1125 4
    if ( FT_RENEW_ARRAY( font->comments,
                         font->comments_len,
                         font->comments_len + len + 1 ) )
      goto Exit;
a1127 1

d1129 2
a1130 2
    cp[len] = '\n';

d1145 1
a1145 1
    char           name[256];
a1158 2
    _bdf_list_init( &list, memory );

d1162 1
a1162 6
    /* Limit ourselves to 256 characters in the font name. */
    if ( len >= 256 )
    {
      error = BDF_Err_Invalid_Argument;
      goto Exit;
    }
d1164 1
a1164 1
    FT_MEM_COPY( name, font->name, len );
d1166 1
a1166 1
    error = _bdf_list_split( &list, (char *)"-", name, len );
d1168 1
a1168 1
      goto Fail;
d1189 1
a1189 2
  Fail:
    _bdf_list_done( &list );
d1268 1
d1287 6
a1292 1
        if ( value && value[0] != 0 )
d1294 1
a1294 1
          if ( FT_STRDUP( fp->value.atom, value ) )
d1296 1
d1298 2
d1364 6
a1369 2
      fp->value.atom = 0;
      if ( value != 0 && value[0] )
d1371 1
a1371 1
        if ( FT_STRDUP( fp->value.atom, value ) )
d1373 1
d1375 2
d1408 1
a1408 1
      font->default_char = fp->value.int32;
d1488 1
a1488 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1496 8
      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */
      /* number of code points available in Unicode).                 */
      if ( p->cnt >= 1114112UL )
      {
        error = BDF_Err_Invalid_Argument;
        goto Exit;
      }

d1542 1
a1542 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d1545 1
d1547 1
a1547 9
      _bdf_list_shift( &p->list, 1 );

      s = _bdf_list_join( &p->list, ' ', &slen );

      if ( !s )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }
a1550 1

d1569 1
a1569 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1571 1

a1573 8
      /* Check that the encoding is in the range [0,65536] because        */
      /* otherwise p->have (a bitmap with static size) overflows.         */
      if ( (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }

d1602 2
a1603 1

d1623 12
a1634 5
            if ( FT_RENEW_ARRAY( font->unencoded ,
                                 font->unencoded_size,
                                 font->unencoded_size + 4 ) )
              goto Exit;

d1687 1
a1687 1
      for ( i = 0; i < nibbles; i++ )
d1697 1
a1697 2
      if ( glyph->bbx.width )
        *bp &= nibble_mask[mask_index];
d1723 1
a1723 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1725 1

d1735 1
a1735 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1737 1

d1759 1
a1759 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1823 3
      unsigned long  bitmap_size;


d1834 1
a1834 10

      bitmap_size = glyph->bpr * glyph->bbx.height;
      if ( bitmap_size > 0xFFFFU )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
        error = BDF_Err_Bbx_Too_Big;
        goto Exit;
      }
      else
        glyph->bytes = (unsigned short)bitmap_size;
d1866 1
d1875 2
d1940 1
a1940 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d1945 2
a1946 2
      _bdf_list_shift( &p->list, 1 );
      value = _bdf_list_join( &p->list, ' ', &vlen );
d2052 2
a2053 2
      p->font->spacing      = p->opts->font_spacing;
      p->font->default_char = -1;
d2061 1
a2061 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2086 1
a2086 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2109 1
a2109 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2112 1
a2112 9
      _bdf_list_shift( &p->list, 1 );

      s = _bdf_list_join( &p->list, ' ', &slen );

      if ( !s )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }
d2114 1
d2141 1
a2141 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2204 1
a2204 1
    unsigned long  lineno = 0; /* make compiler happy */
d2211 1
a2211 1
    if ( FT_NEW( p ) )
a2218 2
    _bdf_list_init( &p->list, extmemory );

d2222 1
a2222 1
      goto Fail;
a2296 1
        {
a2298 3
          error = BDF_Err_Corrupted_Font_Header;
          goto Exit;
        }
a2299 1
        {
a2301 3
          error = BDF_Err_Corrupted_Font_Glyphs;
          goto Exit;
        }
d2305 4
d2318 1
a2318 1
          goto Fail;
a2330 2
      _bdf_list_done( &p->list );

a2331 1

a2335 9

  Fail:
    bdf_free_font( p->font );

    memory = extmemory;

    FT_FREE( p->font );

    goto Exit;
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d23 1
@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d3 1
a3 1
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006 Francesco Zappa Nardelli
d227 1
d258 1
a353 1
    FT_Memory      memory;
a391 110
  static void
  _bdf_list_init( _bdf_list_t*  list,
                  FT_Memory     memory )
  {
    FT_ZERO( list );
    list->memory = memory;
  }


  static void
  _bdf_list_done( _bdf_list_t*  list )
  {
    FT_Memory  memory = list->memory;


    if ( memory )
    {
      FT_FREE( list->field );
      FT_ZERO( list );
    }
  }


  static FT_Error
  _bdf_list_ensure( _bdf_list_t*  list,
                    int           num_items )
  {
    FT_Error  error = BDF_Err_Ok;


    if ( num_items > (int)list->size )
    {
      int        oldsize = list->size;
      int        newsize = oldsize + ( oldsize >> 1 ) + 4;
      int        bigsize = FT_INT_MAX / sizeof ( char* );
      FT_Memory  memory  = list->memory;


      if ( oldsize == bigsize )
      {
        error = BDF_Err_Out_Of_Memory;
        goto Exit;
      }
      else if ( newsize < oldsize || newsize > bigsize )
        newsize = bigsize;

      if ( FT_RENEW_ARRAY( list->field, oldsize, newsize ) )
        goto Exit;

      list->size = newsize;
    }

  Exit:
    return error;
  }


  static void
  _bdf_list_shift( _bdf_list_t*   list,
                   unsigned long  n )
  {
    unsigned long  i, u;


    if ( list == 0 || list->used == 0 || n == 0 )
      return;

    if ( n >= list->used )
    {
      list->used = 0;
      return;
    }

    for ( u = n, i = 0; u < list->used; i++, u++ )
      list->field[i] = list->field[u];
    list->used -= n;
  }


  static char *
  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    dp[j] = 0;

    *alen = j;
    return dp;
  }


d397 3
d401 5
a405 4
  _bdf_list_split( _bdf_list_t*   list,
                   char*          separators,
                   char*          line,
                   unsigned long  linelen )
d454 14
a467 3
        error = _bdf_list_ensure( list, list->used + 1 );
        if ( error )
          goto Exit;
d492 1
a492 1
    if ( list->used + final_empty >= list->size )
d494 17
a510 3
      error = _bdf_list_ensure( list, list->used + final_empty + 1 );
      if ( error )
        goto Exit;
d516 18
d541 93
a633 1
#define NO_SKIP  256  /* this value cannot be stored in a 'char' */
d643 4
a646 4
    unsigned long     lineno, buf_size;
    int               refill, bytes, hold, to_skip;
    int               start, end, cursor, avail;
    char*             buf = 0;
d657 6
a662 2
    /* initial size and allocation of the input buffer */
    buf_size = 1024;
d664 2
a665 2
    if ( FT_NEW_ARRAY( buf, buf_size ) )
      goto Exit;
d667 1
a667 10
    cb      = callback;
    lineno  = 1;
    buf[0]  = 0;
    start   = 0;
    end     = 0;
    avail   = 0;
    cursor  = 0;
    refill  = 1;
    to_skip = NO_SKIP;
    bytes   = 0;        /* make compiler happy */
d669 1
a669 1
    for (;;)
d671 3
a673 8
      if ( refill )
      {
        bytes  = (int)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
                                         (FT_ULong)(buf_size - cursor) );
        avail  = cursor + bytes;
        cursor = 0;
        refill = 0;
      }
d675 2
a676 9
      end = start;

      /* should we skip an optional character like \n or \r? */
      if ( start < avail && buf[start] == to_skip )
      {
        start  += 1;
        to_skip = NO_SKIP;
        continue;
      }
d678 2
a679 3
      /* try to find the end of the line */
      while ( end < avail && buf[end] != '\n' && buf[end] != '\r' )
        end++;
d681 1
a681 3
      /* if we hit the end of the buffer, try shifting its content */
      /* or even resizing it                                       */
      if ( end >= avail )
d683 2
a684 2
        if ( bytes == 0 )  /* last line in file doesn't end in \r or \n */
          break;           /* ignore it then exit                       */
d686 1
a686 1
        if ( start == 0 )
d688 16
a703 17
          /* this line is definitely too long; try resizing the input */
          /* buffer a bit to handle it.                               */
          FT_ULong  new_size;


          if ( buf_size >= 65536UL )  /* limit ourselves to 64KByte */
          {
            error = BDF_Err_Invalid_Argument;
            goto Exit;
          }

          new_size = buf_size * 2;
          if ( FT_RENEW_ARRAY( buf, buf_size, new_size ) )
            goto Exit;

          cursor   = buf_size;
          buf_size = new_size;
d707 18
a724 1
          bytes = avail - start;
d726 2
a727 1
          FT_MEM_COPY( buf, buf + start, bytes );
d729 2
a730 3
          cursor = bytes;
          avail -= bytes;
          start  = 0;
a731 15
        refill = 1;
        continue;
      }

      /* Temporarily NUL-terminate the line. */
      hold     = buf[end];
      buf[end] = 0;

      /* XXX: Use encoding independent value for 0x1a */
      if ( buf[start] != '#' && buf[start] != 0x1a && end > start )
      {
        error = (*cb)( buf + start, end - start, lineno,
                       (void*)&cb, client_data );
        if ( error )
          break;
a732 11

      lineno  += 1;
      buf[end] = (char)hold;
      start    = end + 1;

      if ( hold == '\n' )
        to_skip = '\r';
      else if ( hold == '\r' )
        to_skip = '\n';
      else
        to_skip = NO_SKIP;
d735 1
a735 1
    *lno = lineno;
d958 1
a958 2

    if ( c1->encoding > c2->encoding )
d982 12
a993 4
    if ( FT_RENEW_ARRAY( font->user_props,
                         font->nuser_props,
                         font->nuser_props + 1 ) )
      goto Exit;
d996 1
a996 1
    FT_ZERO( p );
a998 1

d1073 2
a1074 2
#define _BDF_GLYPH_WIDTH_CHECK   0x40000000UL
#define _BDF_GLYPH_HEIGHT_CHECK  0x80000000UL
a1100 1
#define ERRMSG4  "[line %ld] BBX too big.\n"
d1113 12
a1124 4
    if ( FT_RENEW_ARRAY( font->comments,
                         font->comments_len,
                         font->comments_len + len + 1 ) )
      goto Exit;
a1126 1

d1128 2
a1129 2
    cp[len] = '\n';

a1157 2
    _bdf_list_init( &list, memory );

d1163 3
a1165 1
    error = _bdf_list_split( &list, (char *)"-", name, len );
d1167 1
a1167 1
      goto Fail;
d1188 1
a1188 2
  Fail:
    _bdf_list_done( &list );
d1407 1
a1407 1
      font->default_char = fp->value.int32;
d1487 1
a1487 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d1541 1
a1541 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d1544 1
d1546 1
a1546 3
      _bdf_list_shift( &p->list, 1 );

      s = _bdf_list_join( &p->list, ' ', &slen );
a1549 1

d1568 1
a1568 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1570 1

a1572 8
      /* Check that the encoding is in the range [0,65536] because        */
      /* otherwise p->have (a bitmap with static size) overflows.         */
      if ( (size_t)p->glyph_enc >= sizeof ( p->have ) * 8 )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }

d1601 2
a1602 1

d1622 12
a1633 5
            if ( FT_RENEW_ARRAY( font->unencoded ,
                                 font->unencoded_size,
                                 font->unencoded_size + 4 ) )
              goto Exit;

d1686 1
a1686 1
      for ( i = 0; i < nibbles; i++ )
d1696 1
a1696 2
      if ( glyph->bbx.width )
        *bp &= nibble_mask[mask_index];
d1722 1
a1722 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1724 1

d1734 1
a1734 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1736 1

d1758 1
a1758 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
a1822 3
      unsigned long  bitmap_size;


d1833 1
a1833 10

      bitmap_size = glyph->bpr * glyph->bbx.height;
      if ( bitmap_size > 0xFFFFU )
      {
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
        error = BDF_Err_Bbx_Too_Big;
        goto Exit;
      }
      else
        glyph->bytes = (unsigned short)bitmap_size;
d1865 1
d1874 2
d1939 1
a1939 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d1944 2
a1945 2
      _bdf_list_shift( &p->list, 1 );
      value = _bdf_list_join( &p->list, ' ', &vlen );
d2051 2
a2052 2
      p->font->spacing      = p->opts->font_spacing;
      p->font->default_char = -1;
d2060 1
a2060 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2085 1
a2085 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2108 1
a2108 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2111 1
a2111 1
      _bdf_list_shift( &p->list, 1 );
d2113 1
a2113 1
      s = _bdf_list_join( &p->list, ' ', &slen );
d2140 1
a2140 1
      error = _bdf_list_split( &p->list, (char *)" +", line, linelen );
d2210 1
a2210 1
    if ( FT_NEW( p ) )
a2217 2
    _bdf_list_init( &p->list, extmemory );

d2304 4
a2329 2
      _bdf_list_done( &p->list );

a2330 1

@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d3 1
a3 2
 * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
 *   Francesco Zappa Nardelli
d283 1
a283 1
               size_t      data,
d387 2
a388 4
#define setsbit( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3] |= (FT_Byte)( 1 << ( (cc) & 7 ) ) )
#define sbitset( m, cc ) \
          ( m[(FT_Byte)(cc) >> 3]  & ( 1 << ( (cc) & 7 ) ) )
d415 2
a416 2
  _bdf_list_ensure( _bdf_list_t*   list,
                    unsigned long  num_items ) /* same as _bdf_list_t.used */
d421 1
a421 1
    if ( num_items > list->size )
d423 4
a426 4
      unsigned long  oldsize = list->size; /* same as _bdf_list_t.size */
      unsigned long  newsize = oldsize + ( oldsize >> 1 ) + 4;
      unsigned long  bigsize = (unsigned long)( FT_INT_MAX / sizeof ( char* ) );
      FT_Memory      memory  = list->memory;
d614 2
a615 2
    int               refill, hold, to_skip;
    ptrdiff_t         bytes, start, end, cursor, avail;
d648 2
a649 2
        bytes  = (ptrdiff_t)FT_Stream_TryRead( stream, (FT_Byte*)buf + cursor,
                                               (FT_ULong)(buf_size - cursor) );
d971 1
a971 1
    size_t           n;
d991 1
a991 3
    n = ft_strlen( name ) + 1;
    if ( n > FT_ULONG_MAX )
      return BDF_Err_Invalid_Argument;
d1003 1
a1003 1
    error = hash_insert( p->name, n, &(font->proptbl), memory );
d1018 2
a1019 2
    hashnode  hn;
    size_t    propid;
d1028 1
a1028 1
    propid = hn->data;
d1131 5
a1135 5
    size_t       len;
    char         name[256];
    _bdf_list_t  list;
    FT_Memory    memory;
    FT_Error     error = BDF_Err_Ok;
d1150 1
a1150 8
    len = ft_strlen( font->name ) + 1;
    /* Limit ourselves to 256 characters in the font name. */
    if ( len >= 256 )
    {
      error = BDF_Err_Invalid_Argument;
      goto Exit;
    }

d1254 1
a1254 1
    size_t          propid;
d1256 1
d1267 1
a1267 1
      fp = font->props + hn->data;
d1275 6
a1280 1
        if ( value && value[0] != 0 )
d1282 1
a1282 1
          if ( FT_STRDUP( fp->value.atom, value ) )
d1284 1
d1286 2
d1291 1
a1291 1
        fp->value.l = _bdf_atol( value, 0, 10 );
d1295 1
a1295 1
        fp->value.ul = _bdf_atoul( value, 0, 10 );
d1337 1
a1337 1
    propid = hn->data;
d1352 6
a1357 2
      fp->value.atom = 0;
      if ( value != 0 && value[0] )
d1359 1
a1359 1
        if ( FT_STRDUP( fp->value.atom, value ) )
d1361 1
d1363 2
d1368 1
a1368 1
      fp->value.l = _bdf_atol( value, 0, 10 );
d1372 1
a1372 1
      fp->value.ul = _bdf_atoul( value, 0, 10 );
d1381 1
a1381 1
                           font->props_used,
d1396 1
a1396 1
      font->default_char = fp->value.l;
d1398 1
a1398 1
      font->font_ascent = fp->value.l;
d1400 1
a1400 1
      font->font_descent = fp->value.l;
a1402 6
      if ( !fp->value.atom )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }

a1484 8
      /* Limit ourselves to 1,114,112 glyphs in the font (this is the */
      /* number of code points available in Unicode).                 */
      if ( p->cnt >= 1114112UL )
      {
        error = BDF_Err_Invalid_Argument;
        goto Exit;
      }

a1537 6
      if ( !s )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }

d2033 1
a2033 1
        size_t           i;
d2043 1
a2043 1
          error = hash_insert( prop->name, i,
a2066 1
      /* at this point, `p->font' can't be NULL */
a2117 7

      if ( !s )
      {
        error = BDF_Err_Invalid_File_Format;
        goto Exit;
      }

d2207 1
a2207 1
    unsigned long  lineno = 0; /* make compiler happy */
d2227 1
a2227 1
      goto Fail;
a2301 1
        {
a2303 3
          error = BDF_Err_Corrupted_Font_Header;
          goto Exit;
        }
a2304 1
        {
a2306 3
          error = BDF_Err_Corrupted_Font_Glyphs;
          goto Exit;
        }
d2319 1
a2319 1
          goto Fail;
a2339 9

  Fail:
    bdf_free_font( p->font );

    memory = extmemory;

    FT_FREE( p->font );

    goto Exit;
d2436 1
a2436 1
    return hn ? ( font->props + hn->data ) : 0;
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d3 1
a3 1
 * Copyright 2001-2014
d172 151
a322 11
  /* An auxiliary macro to parse properties, to be used in conditionals. */
  /* It behaves like `strncmp' but also tests the following character    */
  /* whether it is a whitespace or NULL.                                 */
  /* `property' is a constant string of length `n' to compare with.      */
#define _bdf_strncmp( name, property, n )      \
          ( ft_strncmp( name, property, n ) || \
            !( name[n] == ' '  ||              \
               name[n] == '\0' ||              \
               name[n] == '\n' ||              \
               name[n] == '\r' ||              \
               name[n] == '\t' )            )
a323 21
  /* Auto correction messages. */
#define ACMSG1   "FONT_ASCENT property missing.  " \
                 "Added `FONT_ASCENT %hd'.\n"
#define ACMSG2   "FONT_DESCENT property missing.  " \
                 "Added `FONT_DESCENT %hd'.\n"
#define ACMSG3   "Font width != actual width.  Old: %hd New: %hd.\n"
#define ACMSG4   "Font left bearing != actual left bearing.  " \
                 "Old: %hd New: %hd.\n"
#define ACMSG5   "Font ascent != actual ascent.  Old: %hd New: %hd.\n"
#define ACMSG6   "Font descent != actual descent.  Old: %hd New: %hd.\n"
#define ACMSG7   "Font height != actual height. Old: %hd New: %hd.\n"
#define ACMSG8   "Glyph scalable width (SWIDTH) adjustments made.\n"
#define ACMSG9   "SWIDTH field missing at line %ld.  Set automatically.\n"
#define ACMSG10  "DWIDTH field missing at line %ld.  Set to glyph width.\n"
#define ACMSG11  "SIZE bits per pixel field adjusted to %hd.\n"
#define ACMSG12  "Duplicate encoding %ld (%s) changed to unencoded.\n"
#define ACMSG13  "Glyph %ld extra rows removed.\n"
#define ACMSG14  "Glyph %ld extra columns removed.\n"
#define ACMSG15  "Incorrect glyph count: %ld indicated but %ld found.\n"
#define ACMSG16  "Glyph %ld missing columns padded with zero bits.\n"
#define ACMSG17  "Adjusting number of glyphs to %ld.\n"
d325 2
a326 14
  /* Error messages. */
#define ERRMSG1  "[line %ld] Missing `%s' line.\n"
#define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
#define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
#define ERRMSG4  "[line %ld] BBX too big.\n"
#define ERRMSG5  "[line %ld] `%s' value too big.\n"
#define ERRMSG6  "[line %ld] Input line too long.\n"
#define ERRMSG7  "[line %ld] Font name too long.\n"
#define ERRMSG8  "[line %ld] Invalid `%s' value.\n"
#define ERRMSG9  "[line %ld] Invalid keyword.\n"

  /* Debug messages. */
#define DBGMSG1  "  [%6ld] %s" /* no \n */
#define DBGMSG2  " (0x%lX)\n"
d380 1
a380 2
    unsigned long   have[34816]; /* must be in sync with `nmod' and `umod' */
                                 /* arrays from `bdf_font_t' structure     */
a383 1
    unsigned long   size;        /* the stream size */
d421 1
a421 1
    FT_Error  error = FT_Err_Ok;
d427 1
a427 1
      unsigned long  newsize = oldsize + ( oldsize >> 1 ) + 5;
d434 1
a434 1
        error = FT_THROW( Out_Of_Memory );
a472 5
  /* An empty string for empty fields. */

  static const char  empty[1] = { 0 };      /* XXX eliminate this */


d479 1
a479 1
    char*          dp;
d490 1
a490 3
      char*  fp = list->field[i];


d497 1
a497 2
    if ( dp != empty )
      dp[j] = 0;
d504 4
a507 3
  /* The code below ensures that we have at least 4 + 1 `field' */
  /* elements in `list' (which are possibly NULL) so that we    */
  /* don't have to check the number of fields in most cases.    */
d515 4
a518 5
    unsigned long  final_empty;
    int            mult;
    char           *sp, *ep, *end;
    char           seps[32];
    FT_Error       error = FT_Err_Ok;
a522 8
    if ( list->size )
    {
      list->field[0] = (char*)empty;
      list->field[1] = (char*)empty;
      list->field[2] = (char*)empty;
      list->field[3] = (char*)empty;
      list->field[4] = (char*)empty;
    }
d533 1
a533 1
      error = FT_THROW( Invalid_Argument );
d619 1
a619 1
    char*             buf    = NULL;
d621 1
a621 1
    FT_Error          error  = FT_Err_Ok;
d626 1
a626 1
      error = FT_THROW( Invalid_Argument );
d640 1
d651 2
a652 3
        bytes  = (ptrdiff_t)FT_Stream_TryRead(
                   stream, (FT_Byte*)buf + cursor,
                   buf_size - (unsigned long)cursor );
d688 1
a688 2
            FT_ERROR(( "_bdf_readstream: " ERRMSG6, lineno ));
            error = FT_THROW( Invalid_Argument );
d696 1
a696 1
          cursor   = (ptrdiff_t)buf_size;
d703 1
a703 1
          FT_MEM_MOVE( buf, buf + start, bytes );
d717 2
a718 2
      /* XXX: Use encoding independent value for 0x1A */
      if ( buf[start] != '#' && buf[start] != 0x1A && end > start )
d720 1
a720 1
        error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
a721 4
        /* Redo if we have encountered CHARS without properties. */
        if ( error == -1 )
          error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
                         (void*)&cb, client_data );
d755 1
a755 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00,
d758 1
a758 1
    0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
d763 8
d773 1
a773 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
d781 2
a782 2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x7E, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
d788 4
a791 1
  /* Routine to convert a decimal ASCII string to an unsigned long integer. */
d793 3
a795 1
  _bdf_atoul( char*  s )
d797 2
a798 1
    unsigned long  v;
d804 29
a832 2
    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = v * 10 + a2i[(int)*s];
d838 1
a838 1
  /* Routine to convert a decimal ASCII string to a signed long integer. */
d840 3
a842 1
  _bdf_atol( char*  s )
d844 2
a845 1
    long  v, neg;
d851 15
d874 8
a881 2
    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = v * 10 + a2i[(int)*s];
d883 2
a884 2
    return ( !neg ) ? v : -v;
  }
d886 2
d889 1
a889 14
  /* Routine to convert a decimal ASCII string to an unsigned short integer. */
  static unsigned short
  _bdf_atous( char*  s )
  {
    unsigned short  v;


    if ( s == 0 || *s == 0 )
      return 0;

    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = (unsigned short)( v * 10 + a2i[(int)*s] );

    return v;
d893 1
a893 1
  /* Routine to convert a decimal ASCII string to a signed short integer. */
d895 3
a897 1
  _bdf_atos( char*  s )
d899 2
a900 1
    short  v, neg;
d906 15
d929 14
a942 2
    for ( v = 0; sbitset( ddigits, *s ); s++ )
      v = (short)( v * 10 + a2i[(int)*s] );
d977 1
a977 1
    FT_Error         error  = FT_Err_Ok;
d980 1
a980 1
    /* First check whether the property has        */
d983 1
a983 1
    if ( ft_hash_str_lookup( name, &(font->proptbl) ) )
d996 1
a996 1
      return FT_THROW( Invalid_Argument );
d1008 1
a1008 1
    error = ft_hash_str_insert( p->name, n, &(font->proptbl), memory );
d1019 1
a1019 1
  FT_LOCAL_DEF( bdf_property_t* )
d1023 2
a1024 1
    size_t*  propid;
d1030 1
a1030 1
    if ( ( propid = ft_hash_str_lookup( name, &(font->proptbl) ) ) == NULL )
d1033 3
a1035 2
    if ( *propid >= _num_bdf_properties )
      return font->user_props + ( *propid - _num_bdf_properties );
d1037 1
a1037 1
    return (bdf_property_t*)_bdf_properties + *propid;
d1050 21
a1070 21
#define BDF_START_      0x0001U
#define BDF_FONT_NAME_  0x0002U
#define BDF_SIZE_       0x0004U
#define BDF_FONT_BBX_   0x0008U
#define BDF_PROPS_      0x0010U
#define BDF_GLYPHS_     0x0020U
#define BDF_GLYPH_      0x0040U
#define BDF_ENCODING_   0x0080U
#define BDF_SWIDTH_     0x0100U
#define BDF_DWIDTH_     0x0200U
#define BDF_BBX_        0x0400U
#define BDF_BITMAP_     0x0800U

#define BDF_SWIDTH_ADJ_  0x1000U

#define BDF_GLYPH_BITS_ ( BDF_GLYPH_    | \
                          BDF_ENCODING_ | \
                          BDF_SWIDTH_   | \
                          BDF_DWIDTH_   | \
                          BDF_BBX_      | \
                          BDF_BITMAP_   )
d1072 29
a1100 2
#define BDF_GLYPH_WIDTH_CHECK_   0x40000000UL
#define BDF_GLYPH_HEIGHT_CHECK_  0x80000000UL
d1110 1
a1110 1
    FT_Error   error  = FT_Err_Ok;
d1134 1
a1134 2
                            bdf_options_t*  opts,
                            unsigned long   lineno )
d1140 1
a1140 3
    FT_Error     error = FT_Err_Ok;

    FT_UNUSED( lineno );        /* only used in debug mode */
d1145 1
a1145 1
      error = FT_THROW( Invalid_Argument );
d1159 1
a1159 2
      FT_ERROR(( "_bdf_set_default_spacing: " ERRMSG7, lineno ));
      error = FT_THROW( Invalid_Argument );
d1165 1
a1165 1
    error = _bdf_list_split( &list, (char *)"-", name, (unsigned long)len );
d1238 1
a1238 2
    if ( *sp )
      *sp++ = 0;
d1262 3
a1264 4
  _bdf_add_property( bdf_font_t*    font,
                     char*          name,
                     char*          value,
                     unsigned long  lineno )
d1266 2
a1267 1
    size_t*         propid;
d1270 1
a1270 3
    FT_Error        error  = FT_Err_Ok;

    FT_UNUSED( lineno );        /* only used in debug mode */
d1273 2
a1274 3
    /* First, check whether the property already exists in the font. */
    if ( ( propid = ft_hash_str_lookup( name,
                                        (FT_Hash)font->internal ) ) != NULL )
d1278 1
a1278 1
      fp = font->props + *propid;
d1294 1
a1294 1
        fp->value.l = _bdf_atol( value );
d1298 1
a1298 1
        fp->value.ul = _bdf_atoul( value );
d1310 2
a1311 2
    propid = ft_hash_str_lookup( name, &(font->proptbl) );
    if ( !propid )
d1316 1
a1316 1
      propid = ft_hash_str_lookup( name, &(font->proptbl) );
d1319 1
a1319 1
    /* Allocate another property if this is overflowing. */
d1336 1
a1336 1
      FT_ZERO( fp );
d1340 3
a1342 2
    if ( *propid >= _num_bdf_properties )
      prop = font->user_props + ( *propid - _num_bdf_properties );
d1344 1
a1344 1
      prop = (bdf_property_t*)_bdf_properties + *propid;
d1364 1
a1364 1
      fp->value.l = _bdf_atol( value );
d1368 1
a1368 1
      fp->value.ul = _bdf_atoul( value );
d1374 1
a1374 2
    if ( _bdf_strncmp( name, "COMMENT", 7 ) != 0 )
    {
d1376 4
a1379 4
      error = ft_hash_str_insert( fp->name,
                                  font->props_used,
                                  (FT_Hash)font->internal,
                                  memory );
d1391 1
a1391 1
    if ( _bdf_strncmp( name, "DEFAULT_CHAR", 12 ) == 0 )
d1393 1
a1393 1
    else if ( _bdf_strncmp( name, "FONT_ASCENT", 11 ) == 0 )
d1395 1
a1395 1
    else if ( _bdf_strncmp( name, "FONT_DESCENT", 12 ) == 0 )
d1397 1
a1397 1
    else if ( _bdf_strncmp( name, "SPACING", 7 ) == 0 )
d1401 1
a1401 2
        FT_ERROR(( "_bdf_add_property: " ERRMSG8, lineno, "SPACING" ));
        error = FT_THROW( Invalid_File_Format );
d1442 1
a1442 1
    FT_Error           error = FT_Err_Ok;
d1454 1
a1454 1
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
d1469 1
a1469 1
    if ( !( p->flags & BDF_GLYPHS_ ) )
d1471 1
a1471 1
      if ( _bdf_strncmp( line, "CHARS", 5 ) != 0 )
d1474 1
a1474 1
        error = FT_THROW( Missing_Chars_Field );
d1481 1
a1481 8
      p->cnt = font->glyphs_size = _bdf_atoul( p->list.field[1] );

      /* We need at least 20 bytes per glyph. */
      if ( p->cnt > p->size / 20 )
      {
        p->cnt = font->glyphs_size = p->size / 20;
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG17, p->cnt ));
      }
d1489 1
a1489 1
      if ( p->cnt >= 0x110000UL )
d1491 1
a1491 2
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "CHARS" ));
        error = FT_THROW( Invalid_Argument );
d1498 1
a1498 1
      p->flags |= BDF_GLYPHS_;
d1504 1
a1504 1
    if ( _bdf_strncmp( line, "ENDFONT", 7 ) == 0 )
a1505 8
      if ( p->flags & BDF_GLYPH_BITS_ )
      {
        /* Missing ENDCHAR field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
        error = FT_THROW( Corrupted_Font_Glyphs );
        goto Exit;
      }

d1512 1
a1512 1
      p->flags &= ~BDF_START_;
d1518 1
a1518 1
    if ( _bdf_strncmp( line, "ENDCHAR", 7 ) == 0 )
d1521 1
a1521 1
      p->flags    &= ~BDF_GLYPH_BITS_;
d1526 3
a1528 3
    /* Check whether a glyph is being scanned but should be */
    /* ignored because it is an unencoded glyph.            */
    if ( ( p->flags & BDF_GLYPH_ )     &&
d1534 1
a1534 1
    if ( _bdf_strncmp( line, "STARTCHAR", 9 ) == 0 )
a1535 8
      if ( p->flags & BDF_GLYPH_BITS_ )
      {
        /* Missing ENDCHAR field. */
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENDCHAR" ));
        error = FT_THROW( Missing_Startchar_Field );
        goto Exit;
      }

d1550 1
a1550 2
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG8, lineno, "STARTCHAR" ));
        error = FT_THROW( Invalid_File_Format );
d1559 1
a1559 3
      p->flags |= BDF_GLYPH_;

      FT_TRACE4(( DBGMSG1, lineno, s ));
d1565 1
a1565 1
    if ( _bdf_strncmp( line, "ENCODING", 8 ) == 0 )
d1567 1
a1567 1
      if ( !( p->flags & BDF_GLYPH_ ) )
d1571 1
a1571 1
        error = FT_THROW( Missing_Startchar_Field );
d1579 1
a1579 10
      p->glyph_enc = _bdf_atol( p->list.field[1] );

      /* Normalize negative encoding values.  The specification only */
      /* allows -1, but we can be more generous here.                */
      if ( p->glyph_enc < -1 )
        p->glyph_enc = -1;

      /* Check for alternative encoding format. */
      if ( p->glyph_enc == -1 && p->list.used > 2 )
        p->glyph_enc = _bdf_atol( p->list.field[2] );
d1581 3
a1583 10
      if ( p->glyph_enc < -1 )
        p->glyph_enc = -1;

      FT_TRACE4(( DBGMSG2, p->glyph_enc ));

      /* Check that the encoding is in the Unicode range because  */
      /* otherwise p->have (a bitmap with static size) overflows. */
      if ( p->glyph_enc > 0                                      &&
           (size_t)p->glyph_enc >= sizeof ( p->have ) /
                                   sizeof ( unsigned long ) * 32 )
d1585 1
a1585 2
        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "ENCODING" ));
        error = FT_THROW( Invalid_File_Format );
d1589 3
a1591 3
      /* Check whether this encoding has already been encountered. */
      /* If it has then change it to unencoded so it gets added if */
      /* indicated.                                                */
d1626 1
a1626 1
        p->glyph_name = NULL;
d1630 2
a1631 2
        /* Unencoded glyph.  Check whether it should */
        /* be added or not.                          */
d1647 1
a1647 4
          glyph->encoding = (long)font->unencoded_used++;

          /* Reset the initial glyph info. */
          p->glyph_name = NULL;
a1649 1
        {
a1652 1
        }
d1654 1
a1654 1
        p->glyph_name = NULL;
d1659 1
a1659 1
      p->flags &= ~( BDF_GLYPH_WIDTH_CHECK_ | BDF_GLYPH_HEIGHT_CHECK_ );
d1661 1
a1661 1
      p->flags |= BDF_ENCODING_;
d1672 2
a1673 2
    /* Check whether a bitmap is being constructed. */
    if ( p->flags & BDF_BITMAP_ )
d1679 1
a1679 1
        if ( !( p->flags & BDF_GLYPH_HEIGHT_CHECK_ ) )
d1682 1
a1682 1
          p->flags |= BDF_GLYPH_HEIGHT_CHECK_;
a1696 2
        if ( !sbitset( hdigits, c ) )
          break;
a1701 10
      /* If any line has not enough columns,            */
      /* indicate they have been padded with zero bits. */
      if ( i < nibbles                            &&
           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
      {
        FT_TRACE2(( "_bdf_parse_glyphs: " ACMSG16, glyph->encoding ));
        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
        font->modified  = 1;
      }

d1708 2
a1709 3
      if ( i == nibbles                           &&
           sbitset( hdigits, line[nibbles] )      &&
           !( p->flags & BDF_GLYPH_WIDTH_CHECK_ ) )
d1712 1
a1712 1
        p->flags       |= BDF_GLYPH_WIDTH_CHECK_;
d1721 1
a1721 1
    if ( _bdf_strncmp( line, "SWIDTH", 6 ) == 0 )
d1723 7
a1729 2
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;
d1735 2
a1736 2
      glyph->swidth = (unsigned short)_bdf_atoul( p->list.field[1] );
      p->flags |= BDF_SWIDTH_;
d1742 1
a1742 1
    if ( _bdf_strncmp( line, "DWIDTH", 6 ) == 0 )
a1743 3
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;

d1748 1
a1748 1
      glyph->dwidth = (unsigned short)_bdf_atoul( p->list.field[1] );
d1750 1
a1750 1
      if ( !( p->flags & BDF_SWIDTH_ ) )
d1762 1
a1762 1
      p->flags |= BDF_DWIDTH_;
d1767 1
a1767 1
    if ( _bdf_strncmp( line, "BBX", 3 ) == 0 )
a1768 3
      if ( !( p->flags & BDF_ENCODING_ ) )
        goto Missing_Encoding;

d1773 4
a1776 4
      glyph->bbx.width    = _bdf_atous( p->list.field[1] );
      glyph->bbx.height   = _bdf_atous( p->list.field[2] );
      glyph->bbx.x_offset = _bdf_atos( p->list.field[3] );
      glyph->bbx.y_offset = _bdf_atos( p->list.field[4] );
d1793 1
a1793 1
      if ( !( p->flags & BDF_DWIDTH_ ) )
d1822 1
a1822 1
          p->flags       |= BDF_SWIDTH_ADJ_;
d1827 1
a1827 1
      p->flags |= BDF_BBX_;
d1832 1
a1832 1
    if ( _bdf_strncmp( line, "BITMAP", 6 ) == 0 )
d1837 1
a1837 1
      if ( !( p->flags & BDF_BBX_ ) )
d1841 1
a1841 1
        error = FT_THROW( Missing_Bbx_Field );
d1846 1
a1846 1
      glyph->bpr = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
d1849 1
a1849 1
      if ( glyph->bpr > 0xFFFFU || bitmap_size > 0xFFFFU )
d1852 1
a1852 1
        error = FT_THROW( Bbx_Too_Big );
d1862 1
a1862 1
      p->flags |= BDF_BITMAP_;
d1867 1
a1867 8
    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG9, lineno ));
    error = FT_THROW( Invalid_File_Format );
    goto Exit;

  Missing_Encoding:
    /* Missing ENCODING field. */
    FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG1, lineno, "ENCODING" ));
    error = FT_THROW( Missing_Encoding_Field );
a1869 3
    if ( error && ( p->flags & BDF_GLYPH_ ) )
      FT_FREE( p->glyph_name );

d1888 1
a1888 1
    FT_Error           error = FT_Err_Ok;
d1897 1
a1897 1
    if ( _bdf_strncmp( line, "ENDPROPERTIES", 13 ) == 0 )
d1909 1
a1909 2
        error = _bdf_add_property( p->font, (char *)"FONT_ASCENT",
                                   nbuf, lineno );
d1921 1
a1921 2
        error = _bdf_add_property( p->font, (char *)"FONT_DESCENT",
                                   nbuf, lineno );
d1929 1
a1929 1
      p->flags &= ~BDF_PROPS_;
d1936 1
a1936 1
    if ( _bdf_strncmp( line, "_XFREE86_GLYPH_RANGES", 21 ) == 0 )
d1941 1
a1941 1
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
d1947 1
a1947 1
      error = _bdf_add_property( p->font, name, value, lineno );
d1953 1
a1953 1
      error = _bdf_add_property( p->font, name, value, lineno );
d1967 1
a1967 1
      error = _bdf_add_property( p->font, name, value, lineno );
d1992 1
a1992 1
    FT_Error           error  = FT_Err_Ok;
d2005 1
a2005 1
    if ( _bdf_strncmp( line, "COMMENT", 7 ) == 0 )
d2027 1
a2027 1
    if ( !( p->flags & BDF_START_ ) )
d2031 1
a2031 1
      if ( _bdf_strncmp( line, "STARTFONT", 9 ) != 0 )
d2033 2
a2034 3
        /* we don't emit an error message since this code gets */
        /* explicitly caught one level higher                  */
        error = FT_THROW( Missing_Startfont_Field );
d2038 1
a2038 1
      p->flags = BDF_START_;
d2053 1
a2053 1
        error = ft_hash_str_init( &(font->proptbl), memory );
d2059 2
a2060 2
          error = ft_hash_str_insert( prop->name, i,
                                      &(font->proptbl), memory );
d2066 1
a2066 1
      if ( FT_ALLOC( p->font->internal, sizeof ( FT_HashRec ) ) )
d2068 1
a2068 1
      error = ft_hash_str_init( (FT_Hash)p->font->internal, memory );
d2078 1
a2078 1
    if ( _bdf_strncmp( line, "STARTPROPERTIES", 15 ) == 0 )
a2079 8
      if ( !( p->flags & BDF_FONT_BBX_ ) )
      {
        /* Missing the FONTBOUNDINGBOX field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
        error = FT_THROW( Missing_Fontboundingbox_Field );
        goto Exit;
      }

a2082 1

d2084 1
a2084 10
      p->cnt = p->font->props_size = _bdf_atoul( p->list.field[1] );
      /* We need at least 4 bytes per property. */
      if ( p->cnt > p->size / 4 )
      {
        p->font->props_size = 0;

        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG5, lineno, "STARTPROPERTIES" ));
        error = FT_THROW( Invalid_Argument );
        goto Exit;
      }
a2086 2
      {
        p->font->props_size = 0;
a2087 1
      }
d2089 1
a2089 1
      p->flags |= BDF_PROPS_;
d2096 1
a2096 1
    if ( _bdf_strncmp( line, "FONTBOUNDINGBOX", 15 ) == 0 )
d2098 1
a2098 1
      if ( !( p->flags & BDF_SIZE_ ) )
d2102 1
a2102 1
        error = FT_THROW( Missing_Size_Field );
d2110 2
a2111 2
      p->font->bbx.width  = _bdf_atous( p->list.field[1] );
      p->font->bbx.height = _bdf_atous( p->list.field[2] );
d2113 2
a2114 2
      p->font->bbx.x_offset = _bdf_atos( p->list.field[3] );
      p->font->bbx.y_offset = _bdf_atos( p->list.field[4] );
d2121 1
a2121 1
      p->flags |= BDF_FONT_BBX_;
d2127 1
a2127 1
    if ( _bdf_strncmp( line, "FONT", 4 ) == 0 )
d2138 1
a2138 2
        FT_ERROR(( "_bdf_parse_start: " ERRMSG8, lineno, "FONT" ));
        error = FT_THROW( Invalid_File_Format );
a2141 3
      /* Allowing multiple `FONT' lines (which is invalid) doesn't hurt... */
      FT_FREE( p->font->name );

d2148 1
a2148 1
      error = _bdf_set_default_spacing( p->font, p->opts, lineno );
d2152 1
a2152 1
      p->flags |= BDF_FONT_NAME_;
d2158 1
a2158 1
    if ( _bdf_strncmp( line, "SIZE", 4 ) == 0 )
d2160 1
a2160 1
      if ( !( p->flags & BDF_FONT_NAME_ ) )
d2164 1
a2164 1
        error = FT_THROW( Missing_Font_Field );
d2172 3
a2174 3
      p->font->point_size   = _bdf_atoul( p->list.field[1] );
      p->font->resolution_x = _bdf_atoul( p->list.field[2] );
      p->font->resolution_y = _bdf_atoul( p->list.field[3] );
d2179 2
a2180 1
        unsigned short bpp;
d2182 1
d2184 9
a2192 1
        bpp = (unsigned short)_bdf_atos( p->list.field[4] );
d2194 1
a2194 9
        /* Only values 1, 2, 4, 8 are allowed for greymap fonts. */
        if ( bpp > 4 )
          p->font->bpp = 8;
        else if ( bpp > 2 )
          p->font->bpp = 4;
        else if ( bpp > 1 )
          p->font->bpp = 2;
        else
          p->font->bpp = 1;
d2196 4
a2199 1
        if ( p->font->bpp != bpp )
d2201 1
d2206 1
a2206 38
      p->flags |= BDF_SIZE_;

      goto Exit;
    }

    /* Check for the CHARS field -- font properties are optional */
    if ( _bdf_strncmp( line, "CHARS", 5 ) == 0 )
    {
      char  nbuf[128];


      if ( !( p->flags & BDF_FONT_BBX_ ) )
      {
        /* Missing the FONTBOUNDINGBOX field. */
        FT_ERROR(( "_bdf_parse_start: " ERRMSG1, lineno, "FONTBOUNDINGBOX" ));
        error = FT_THROW( Missing_Fontboundingbox_Field );
        goto Exit;
      }

      /* Add the two standard X11 properties which are required */
      /* for compiling fonts.                                   */
      p->font->font_ascent = p->font->bbx.ascent;
      ft_sprintf( nbuf, "%hd", p->font->bbx.ascent );
      error = _bdf_add_property( p->font, (char *)"FONT_ASCENT",
                                 nbuf, lineno );
      if ( error )
        goto Exit;
      FT_TRACE2(( "_bdf_parse_properties: " ACMSG1, p->font->bbx.ascent ));

      p->font->font_descent = p->font->bbx.descent;
      ft_sprintf( nbuf, "%hd", p->font->bbx.descent );
      error = _bdf_add_property( p->font, (char *)"FONT_DESCENT",
                                 nbuf, lineno );
      if ( error )
        goto Exit;
      FT_TRACE2(( "_bdf_parse_properties: " ACMSG2, p->font->bbx.descent ));

      p->font->modified = 1;
a2207 4
      *next = _bdf_parse_glyphs;

      /* A special return value. */
      error = -1;
d2211 1
a2211 2
    FT_ERROR(( "_bdf_parse_start: " ERRMSG9, lineno ));
    error = FT_THROW( Invalid_File_Format );
d2232 1
a2232 1
    _bdf_parse_t   *p     = NULL;
d2234 2
a2235 2
    FT_Memory  memory = extmemory; /* needed for FT_NEW */
    FT_Error   error  = FT_Err_Ok;
a2243 1
    p->size   = stream->size;
d2257 1
d2316 1
a2316 1
        if ( p->flags & BDF_SWIDTH_ADJ_ )
d2321 1
a2321 1
    if ( p->flags & BDF_START_ )
a2322 2
      /* The ENDFONT field was never reached or did not exist. */
      if ( !( p->flags & BDF_GLYPHS_ ) )
d2324 15
a2338 11
        /* Error happened while parsing header. */
        FT_ERROR(( "bdf_load_font: " ERRMSG2, lineno ));
        error = FT_THROW( Corrupted_Font_Header );
        goto Fail;
      }
      else
      {
        /* Error happened when parsing glyphs. */
        FT_ERROR(( "bdf_load_font: " ERRMSG3, lineno ));
        error = FT_THROW( Corrupted_Font_Glyphs );
        goto Fail;
d2347 1
a2347 2
      if ( p->font->comments_len > 0 )
      {
d2356 2
a2357 2
    else if ( !error )
      error = FT_THROW( Invalid_File_Format );
a2367 1
      FT_FREE( p->glyph_name );
d2403 1
a2403 1
      ft_hash_str_free( (FT_Hash)font->internal, memory );
d2448 1
a2448 1
    ft_hash_str_free( &(font->proptbl), memory );
d2451 2
a2452 2
    for ( prop = font->user_props, i = 0;
          i < font->nuser_props; i++, prop++ )
d2469 1
a2469 1
    size_t*  propid;
d2475 1
a2475 1
    propid = ft_hash_str_lookup( name, (FT_Hash)font->internal );
d2477 1
a2477 1
    return propid ? ( font->props + *propid ) : 0;
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
