head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.22.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.37;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.54;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.13;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.13;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.23;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.37.23;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.59;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.22;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.21;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.04;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  t1objs.c                                                               */
/*                                                                         */
/*    Type 1 objects manager (body).                                       */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_TRUETYPE_IDS_H

#include "t1gload.h"
#include "t1load.h"

#include "t1errors.h"

#ifndef T1_CONFIG_OPTION_NO_AFM
#include "t1afm.h"
#endif

#include FT_SERVICE_POSTSCRIPT_CMAPS_H
#include FT_INTERNAL_POSTSCRIPT_AUX_H


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_t1objs


  /*************************************************************************/
  /*                                                                       */
  /*                            SIZE FUNCTIONS                             */
  /*                                                                       */
  /*  note that we store the global hints in the size's "internal" root    */
  /*  field                                                                */
  /*                                                                       */
  /*************************************************************************/


  static PSH_Globals_Funcs
  T1_Size_Get_Globals_Funcs( T1_Size  size )
  {
    T1_Face           face     = (T1_Face)size->root.face;
    PSHinter_Service  pshinter = (PSHinter_Service)face->pshinter;
    FT_Module         module;


    module = FT_Get_Module( size->root.face->driver->root.library,
                            "pshinter" );
    return ( module && pshinter && pshinter->get_globals_funcs )
           ? pshinter->get_globals_funcs( module )
           : 0;
  }


  FT_LOCAL_DEF( void )
  T1_Size_Done( FT_Size  t1size )          /* T1_Size */
  {
    T1_Size  size = (T1_Size)t1size;


    if ( size->root.internal )
    {
      PSH_Globals_Funcs  funcs;


      funcs = T1_Size_Get_Globals_Funcs( size );
      if ( funcs )
        funcs->destroy( (PSH_Globals)size->root.internal );

      size->root.internal = NULL;
    }
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Size_Init( FT_Size  t1size )      /* T1_Size */
  {
    T1_Size            size  = (T1_Size)t1size;
    FT_Error           error = FT_Err_Ok;
    PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );


    if ( funcs )
    {
      PSH_Globals  globals;
      T1_Face      face = (T1_Face)size->root.face;


      error = funcs->create( size->root.face->memory,
                             &face->type1.private_dict, &globals );
      if ( !error )
        size->root.internal = (FT_Size_Internal)(void*)globals;
    }

    return error;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Size_Request( FT_Size          t1size,     /* T1_Size */
                   FT_Size_Request  req )
  {
    T1_Size            size  = (T1_Size)t1size;
    PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );


    FT_Request_Metrics( size->root.face, req );

    if ( funcs )
      funcs->set_scale( (PSH_Globals)size->root.internal,
                        size->root.metrics.x_scale,
                        size->root.metrics.y_scale,
                        0, 0 );

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                            SLOT  FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/

  FT_LOCAL_DEF( void )
  T1_GlyphSlot_Done( FT_GlyphSlot  slot )
  {
    slot->internal->glyph_hints = NULL;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_GlyphSlot_Init( FT_GlyphSlot  slot )
  {
    T1_Face           face;
    PSHinter_Service  pshinter;


    face     = (T1_Face)slot->face;
    pshinter = (PSHinter_Service)face->pshinter;

    if ( pshinter )
    {
      FT_Module  module;


      module = FT_Get_Module( slot->face->driver->root.library,
                              "pshinter" );
      if ( module )
      {
        T1_Hints_Funcs  funcs;


        funcs = pshinter->get_t1_funcs( module );
        slot->internal->glyph_hints = (void*)funcs;
      }
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                            FACE  FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    T1_Face_Done                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The face object destructor.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A typeless pointer to the face object to destroy.          */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  T1_Face_Done( FT_Face  t1face )         /* T1_Face */
  {
    T1_Face    face = (T1_Face)t1face;
    FT_Memory  memory;
    T1_Font    type1;


    if ( !face )
      return;

    memory = face->root.memory;
    type1  = &face->type1;

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
    /* release multiple masters information */
    FT_ASSERT( ( face->len_buildchar == 0 ) == ( face->buildchar == NULL ) );

    if ( face->buildchar )
    {
      FT_FREE( face->buildchar );

      face->buildchar     = NULL;
      face->len_buildchar = 0;
    }

    T1_Done_Blend( face );
    face->blend = NULL;
#endif

    /* release font info strings */
    {
      PS_FontInfo  info = &type1->font_info;


      FT_FREE( info->version );
      FT_FREE( info->notice );
      FT_FREE( info->full_name );
      FT_FREE( info->family_name );
      FT_FREE( info->weight );
    }

    /* release top dictionary */
    FT_FREE( type1->charstrings_len );
    FT_FREE( type1->charstrings );
    FT_FREE( type1->glyph_names );

    FT_FREE( type1->subrs );
    FT_FREE( type1->subrs_len );

    ft_hash_num_free( type1->subrs_hash, memory );
    FT_FREE( type1->subrs_hash );

    FT_FREE( type1->subrs_block );
    FT_FREE( type1->charstrings_block );
    FT_FREE( type1->glyph_names_block );

    FT_FREE( type1->encoding.char_index );
    FT_FREE( type1->encoding.char_name );
    FT_FREE( type1->font_name );

#ifndef T1_CONFIG_OPTION_NO_AFM
    /* release afm data if present */
    if ( face->afm_data )
      T1_Done_Metrics( memory, (AFM_FontInfo)face->afm_data );
#endif

    /* release unicode map, if any */
#if 0
    FT_FREE( face->unicode_map_rec.maps );
    face->unicode_map_rec.num_maps = 0;
    face->unicode_map              = NULL;
#endif

    face->root.family_name = NULL;
    face->root.style_name  = NULL;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    T1_Face_Init                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The face object constructor.                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream     ::  input stream where to load font data.               */
  /*                                                                       */
  /*    face_index :: The index of the font face in the resource.          */
  /*                                                                       */
  /*    num_params :: Number of additional generic parameters.  Ignored.   */
  /*                                                                       */
  /*    params     :: Additional generic parameters.  Ignored.             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face       :: The face record to build.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Face_Init( FT_Stream      stream,
                FT_Face        t1face,          /* T1_Face */
                FT_Int         face_index,
                FT_Int         num_params,
                FT_Parameter*  params )
  {
    T1_Face             face = (T1_Face)t1face;
    FT_Error            error;
    FT_Service_PsCMaps  psnames;
    PSAux_Service       psaux;
    T1_Font             type1 = &face->type1;
    PS_FontInfo         info = &type1->font_info;

    FT_UNUSED( num_params );
    FT_UNUSED( params );
    FT_UNUSED( stream );


    face->root.num_faces = 1;

    FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
    face->psnames = psnames;

    face->psaux = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
                                           "psaux" );
    psaux = (PSAux_Service)face->psaux;
    if ( !psaux )
    {
      FT_ERROR(( "T1_Face_Init: cannot access `psaux' module\n" ));
      error = FT_THROW( Missing_Module );
      goto Exit;
    }

    face->pshinter = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
                                              "pshinter" );

    FT_TRACE2(( "Type 1 driver\n" ));

    /* open the tokenizer; this will also check the font format */
    error = T1_Open_Face( face );
    if ( error )
      goto Exit;

    /* if we just wanted to check the format, leave successfully now */
    if ( face_index < 0 )
      goto Exit;

    /* check the face index */
    if ( ( face_index & 0xFFFF ) > 0 )
    {
      FT_ERROR(( "T1_Face_Init: invalid face index\n" ));
      error = FT_THROW( Invalid_Argument );
      goto Exit;
    }

    /* now load the font program into the face object */

    /* initialize the face object fields */

    /* set up root face fields */
    {
      FT_Face  root = (FT_Face)&face->root;


      root->num_glyphs = type1->num_glyphs;
      root->face_index = 0;

      root->face_flags |= FT_FACE_FLAG_SCALABLE    |
                          FT_FACE_FLAG_HORIZONTAL  |
                          FT_FACE_FLAG_GLYPH_NAMES |
                          FT_FACE_FLAG_HINTER;

      if ( info->is_fixed_pitch )
        root->face_flags |= FT_FACE_FLAG_FIXED_WIDTH;

      if ( face->blend )
        root->face_flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;

      /* The following code to extract the family and the style is very   */
      /* simplistic and might get some things wrong.  For a full-featured */
      /* algorithm you might have a look at the whitepaper given at       */
      /*                                                                  */
      /*   http://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */

      /* get style name -- be careful, some broken fonts only */
      /* have a `/FontName' dictionary entry!                 */
      root->family_name = info->family_name;
      root->style_name  = NULL;

      if ( root->family_name )
      {
        char*  full   = info->full_name;
        char*  family = root->family_name;


        if ( full )
        {
          FT_Bool  the_same = TRUE;


          while ( *full )
          {
            if ( *full == *family )
            {
              family++;
              full++;
            }
            else
            {
              if ( *full == ' ' || *full == '-' )
                full++;
              else if ( *family == ' ' || *family == '-' )
                family++;
              else
              {
                the_same = FALSE;

                if ( !*family )
                  root->style_name = full;
                break;
              }
            }
          }

          if ( the_same )
            root->style_name = (char *)"Regular";
        }
      }
      else
      {
        /* do we have a `/FontName'? */
        if ( type1->font_name )
          root->family_name = type1->font_name;
      }

      if ( !root->style_name )
      {
        if ( info->weight )
          root->style_name = info->weight;
        else
          /* assume `Regular' style because we don't know better */
          root->style_name = (char *)"Regular";
      }

      /* compute style flags */
      root->style_flags = 0;
      if ( info->italic_angle )
        root->style_flags |= FT_STYLE_FLAG_ITALIC;
      if ( info->weight )
      {
        if ( !ft_strcmp( info->weight, "Bold"  ) ||
             !ft_strcmp( info->weight, "Black" ) )
          root->style_flags |= FT_STYLE_FLAG_BOLD;
      }

      /* no embedded bitmap support */
      root->num_fixed_sizes = 0;
      root->available_sizes = NULL;

      root->bbox.xMin =   type1->font_bbox.xMin            >> 16;
      root->bbox.yMin =   type1->font_bbox.yMin            >> 16;
      /* no `U' suffix here to 0xFFFF! */
      root->bbox.xMax = ( type1->font_bbox.xMax + 0xFFFF ) >> 16;
      root->bbox.yMax = ( type1->font_bbox.yMax + 0xFFFF ) >> 16;

      /* Set units_per_EM if we didn't set it in t1_parse_font_matrix. */
      if ( !root->units_per_EM )
        root->units_per_EM = 1000;

      root->ascender  = (FT_Short)( root->bbox.yMax );
      root->descender = (FT_Short)( root->bbox.yMin );

      root->height = (FT_Short)( ( root->units_per_EM * 12 ) / 10 );
      if ( root->height < root->ascender - root->descender )
        root->height = (FT_Short)( root->ascender - root->descender );

      /* now compute the maximum advance width */
      root->max_advance_width =
        (FT_Short)( root->bbox.xMax );
      {
        FT_Pos  max_advance;


        error = T1_Compute_Max_Advance( face, &max_advance );

        /* in case of error, keep the standard width */
        if ( !error )
          root->max_advance_width = (FT_Short)FIXED_TO_INT( max_advance );
        else
          error = FT_Err_Ok;   /* clear error */
      }

      root->max_advance_height = root->height;

      root->underline_position  = (FT_Short)info->underline_position;
      root->underline_thickness = (FT_Short)info->underline_thickness;
    }

    {
      FT_Face  root = &face->root;


      if ( psnames )
      {
        FT_CharMapRec    charmap;
        T1_CMap_Classes  cmap_classes = psaux->t1_cmap_classes;
        FT_CMap_Class    clazz;


        charmap.face = root;

        /* first of all, try to synthesize a Unicode charmap */
        charmap.platform_id = TT_PLATFORM_MICROSOFT;
        charmap.encoding_id = TT_MS_ID_UNICODE_CS;
        charmap.encoding    = FT_ENCODING_UNICODE;

        error = FT_CMap_New( cmap_classes->unicode, NULL, &charmap, NULL );
        if ( error                                      &&
             FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
          goto Exit;
        error = FT_Err_Ok;

        /* now, generate an Adobe Standard encoding when appropriate */
        charmap.platform_id = TT_PLATFORM_ADOBE;
        clazz               = NULL;

        switch ( type1->encoding_type )
        {
        case T1_ENCODING_TYPE_STANDARD:
          charmap.encoding    = FT_ENCODING_ADOBE_STANDARD;
          charmap.encoding_id = TT_ADOBE_ID_STANDARD;
          clazz               = cmap_classes->standard;
          break;

        case T1_ENCODING_TYPE_EXPERT:
          charmap.encoding    = FT_ENCODING_ADOBE_EXPERT;
          charmap.encoding_id = TT_ADOBE_ID_EXPERT;
          clazz               = cmap_classes->expert;
          break;

        case T1_ENCODING_TYPE_ARRAY:
          charmap.encoding    = FT_ENCODING_ADOBE_CUSTOM;
          charmap.encoding_id = TT_ADOBE_ID_CUSTOM;
          clazz               = cmap_classes->custom;
          break;

        case T1_ENCODING_TYPE_ISOLATIN1:
          charmap.encoding    = FT_ENCODING_ADOBE_LATIN_1;
          charmap.encoding_id = TT_ADOBE_ID_LATIN_1;
          clazz               = cmap_classes->unicode;
          break;

        default:
          ;
        }

        if ( clazz )
          error = FT_CMap_New( clazz, NULL, &charmap, NULL );

#if 0
        /* Select default charmap */
        if (root->num_charmaps)
          root->charmap = root->charmaps[0];
#endif
      }
    }

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    T1_Driver_Init                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given Type 1 driver object.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target driver object.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Driver_Init( FT_Module  driver )
  {
    FT_UNUSED( driver );

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    T1_Driver_Done                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a given Type 1 driver.                                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target Type 1 driver.                    */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  T1_Driver_Done( FT_Module  driver )
  {
    FT_UNUSED( driver );
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
d70 1
a70 1
           : 0 ;
d75 1
a75 1
  T1_Size_Done( T1_Size  size )
d77 3
d89 1
a89 1
      size->root.internal = 0;
d95 1
a95 1
  T1_Size_Init( T1_Size  size )
d97 2
a98 1
    FT_Error           error = T1_Err_Ok;
d119 1
a119 1
  T1_Size_Request( T1_Size          size,
d122 1
d134 1
a134 1
    return T1_Err_Ok;
d145 1
a145 1
  T1_GlyphSlot_Done( T1_GlyphSlot  slot )
d147 1
a147 1
    slot->root.internal->glyph_hints = 0;
d152 1
a152 1
  T1_GlyphSlot_Init( T1_GlyphSlot  slot )
d158 1
a158 1
    face     = (T1_Face)slot->root.face;
d166 3
a168 2
      module = FT_Get_Module( slot->root.face->driver->root.library, "pshinter" );
      if (module)
d172 1
d174 1
a174 1
        slot->root.internal->glyph_hints = (void*)funcs;
d177 1
d201 1
a201 1
  T1_Face_Done( T1_Face  face )
d203 1
d227 1
a227 1
    face->blend = 0;
d250 3
d304 1
a304 1
                T1_Face        face,
d309 1
d329 6
d339 2
d351 1
a351 1
    if ( face_index > 0 )
d354 1
a354 1
      error = T1_Err_Invalid_Argument;
d370 4
a373 4
      root->face_flags = FT_FACE_FLAG_SCALABLE    |
                         FT_FACE_FLAG_HORIZONTAL  |
                         FT_FACE_FLAG_GLYPH_NAMES |
                         FT_FACE_FLAG_HINTER;
a380 3
      /* XXX: TODO -- add kerning with .afm support */


d460 1
a460 1
      root->available_sizes = 0;
d468 1
a468 1
      /* Set units_per_EM if we didn't set it in parse_font_matrix. */
d492 1
a492 1
          error = T1_Err_Ok;   /* clear error */
d505 1
a505 1
      if ( psnames && psaux )
d515 2
a516 2
        charmap.platform_id = 3;
        charmap.encoding_id = 1;
d519 5
a523 1
        FT_CMap_New( cmap_classes->unicode, NULL, &charmap, NULL );
d526 1
a526 1
        charmap.platform_id = 7;
d560 1
a560 1
          FT_CMap_New( clazz, NULL, &charmap, NULL );
d590 1
a590 1
  T1_Driver_Init( T1_Driver  driver )
d594 1
a594 1
    return T1_Err_Ok;
d610 1
a610 1
  T1_Driver_Done( T1_Driver  driver )
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d17 1
a17 1
/* $XFree86: xc/extras/freetype2/src/type1/t1objs.c,v 1.4 2004/04/26 16:15:55 dawes Exp $ */
d20 1
d94 1
a94 1
    FT_Error           error = 0;
d195 6
a200 4
    if ( face )
    {
      FT_Memory  memory = face->root.memory;
      T1_Font    type1  = &face->type1;
d202 2
d206 2
a207 2
      /* release multiple masters information */
      FT_ASSERT( ( face->len_buildchar == 0 ) == ( face->buildchar == NULL ) );
d209 3
a211 3
      if ( face->buildchar )
      {
        FT_FREE( face->buildchar );
d213 3
a215 3
        face->buildchar     = NULL;
        face->len_buildchar = 0;
      }
d217 2
a218 2
      T1_Done_Blend( face );
      face->blend = 0;
d221 3
a223 3
      /* release font info strings */
      {
        PS_FontInfo  info = &type1->font_info;
d226 6
a231 6
        FT_FREE( info->version );
        FT_FREE( info->notice );
        FT_FREE( info->full_name );
        FT_FREE( info->family_name );
        FT_FREE( info->weight );
      }
d233 15
a247 15
      /* release top dictionary */
      FT_FREE( type1->charstrings_len );
      FT_FREE( type1->charstrings );
      FT_FREE( type1->glyph_names );

      FT_FREE( type1->subrs );
      FT_FREE( type1->subrs_len );

      FT_FREE( type1->subrs_block );
      FT_FREE( type1->charstrings_block );
      FT_FREE( type1->glyph_names_block );

      FT_FREE( type1->encoding.char_index );
      FT_FREE( type1->encoding.char_name );
      FT_FREE( type1->font_name );
d250 3
a252 3
      /* release afm data if present */
      if ( face->afm_data )
        T1_Done_Metrics( memory, (AFM_FontInfo)face->afm_data );
d255 1
a255 1
      /* release unicode map, if any */
d257 3
a259 3
      FT_FREE( face->unicode_map_rec.maps );
      face->unicode_map_rec.num_maps = 0;
      face->unicode_map              = NULL;
d262 2
a263 3
      face->root.family_name = 0;
      face->root.style_name  = 0;
    }
d330 1
a330 1
    if ( face_index != 0 )
d347 1
a347 1
      root->face_index = face_index;
d362 7
d372 1
a372 2
      /* assume "Regular" style if we don't know better */
      root->style_name = (char *)"Regular";
d374 1
a374 3
      if ( info->weight )
        root->style_name = info->weight;
      else if ( root->family_name )
d382 3
d400 2
d408 3
d420 9
d444 5
a448 4
      root->bbox.xMin =   type1->font_bbox.xMin             >> 16;
      root->bbox.yMin =   type1->font_bbox.yMin             >> 16;
      root->bbox.xMax = ( type1->font_bbox.xMax + 0xFFFFU ) >> 16;
      root->bbox.yMax = ( type1->font_bbox.yMax + 0xFFFFU ) >> 16;
d472 1
a472 1
          root->max_advance_width = (FT_Short)max_advance;
d474 1
a474 1
          error = 0;   /* clear error */
d496 1
a496 1
        /* first of all, try to synthetize a Unicode charmap */
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a300 1
    FT_UNUSED( face_index );
d363 4
a366 1
      if ( root->family_name )
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a193 4
    FT_Memory  memory;
    T1_Font    type1 = &face->type1;


d196 3
a198 1
      memory = face->root.memory;
d202 10
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d114 2
a115 1
  T1_Size_Reset( T1_Size  size )
a117 1
    FT_Error           error = 0;
d120 2
d123 6
a128 5
      error = funcs->set_scale( (PSH_Globals)size->root.internal,
                                size->root.metrics.x_scale,
                                size->root.metrics.y_scale,
                                0, 0 );
    return error;
d239 1
a239 1
        T1_Done_AFM( memory, (T1_AFM*)face->afm_data );
d243 5
a247 2
      FT_FREE( face->unicode_map.maps );
      face->unicode_map.num_maps = 0;
d338 4
a341 3
      root->face_flags  = FT_FACE_FLAG_SCALABLE;
      root->face_flags |= FT_FACE_FLAG_HORIZONTAL;
      root->face_flags |= FT_FACE_FLAG_GLYPH_NAMES;
d420 4
a423 2
      root->height    = (FT_Short)(
        ( ( root->ascender - root->descender ) * 12 ) / 10 );
a444 3

      root->internal->max_points   = 0;
      root->internal->max_contours = 0;
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d17 1
a17 1

d114 1
a114 2
  T1_Size_Request( T1_Size          size,
                   FT_Size_Request  req )
d117 1
a119 2
    FT_Request_Metrics( size->root.face, req );

d121 5
a125 6
      funcs->set_scale( (PSH_Globals)size->root.internal,
                        size->root.metrics.x_scale,
                        size->root.metrics.y_scale,
                        0, 0 );

    return T1_Err_Ok;
d191 4
d197 1
a197 3
      FT_Memory  memory = face->root.memory;
      T1_Font    type1  = &face->type1;

a200 10
      FT_ASSERT( ( face->len_buildchar == 0 ) == ( face->buildchar == NULL ) );

      if ( face->buildchar )
      {
        FT_FREE( face->buildchar );

        face->buildchar     = NULL;
        face->len_buildchar = 0;
      }

d236 1
a236 1
        T1_Done_Metrics( memory, (AFM_FontInfo)face->afm_data );
d240 2
a241 5
#if 0
      FT_FREE( face->unicode_map_rec.maps );
      face->unicode_map_rec.num_maps = 0;
      face->unicode_map              = NULL;
#endif
d332 3
a334 4
      root->face_flags = FT_FACE_FLAG_SCALABLE    |
                         FT_FACE_FLAG_HORIZONTAL  |
                         FT_FACE_FLAG_GLYPH_NAMES |
                         FT_FACE_FLAG_HINTER;
d413 2
a414 4

      root->height = (FT_Short)( ( root->units_per_EM * 12 ) / 10 );
      if ( root->height < root->ascender - root->descender )
        root->height = (FT_Short)( root->ascender - root->descender );
d436 3
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d301 1
d364 1
a364 4

      if ( info->weight )
        root->style_name = info->weight;
      else if ( root->family_name )
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d17 1
a17 1

@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d114 1
a114 2
  T1_Size_Request( T1_Size          size,
                   FT_Size_Request  req )
d117 1
a119 2
    FT_Request_Metrics( size->root.face, req );

d121 5
a125 6
      funcs->set_scale( (PSH_Globals)size->root.internal,
                        size->root.metrics.x_scale,
                        size->root.metrics.y_scale,
                        0, 0 );

    return T1_Err_Ok;
d236 1
a236 1
        T1_Done_Metrics( memory, (AFM_FontInfo)face->afm_data );
d240 2
a241 5
#if 0
      FT_FREE( face->unicode_map_rec.maps );
      face->unicode_map_rec.num_maps = 0;
      face->unicode_map              = NULL;
#endif
d332 3
a334 4
      root->face_flags = FT_FACE_FLAG_SCALABLE    |
                         FT_FACE_FLAG_HORIZONTAL  |
                         FT_FACE_FLAG_GLYPH_NAMES |
                         FT_FACE_FLAG_HINTER;
d413 2
a414 4

      root->height = (FT_Short)( ( root->units_per_EM * 12 ) / 10 );
      if ( root->height < root->ascender - root->descender )
        root->height = (FT_Short)( root->ascender - root->descender );
d436 3
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
a19 1
#include FT_INTERNAL_CALC_H
d93 1
a93 1
    FT_Error           error = T1_Err_Ok;
d195 1
a195 1
    T1_Font    type1;
d198 3
a200 5
    if ( !face )
      return;

    memory = face->root.memory;
    type1  = &face->type1;
d203 3
a205 13
    /* release multiple masters information */
    FT_ASSERT( ( face->len_buildchar == 0 ) == ( face->buildchar == NULL ) );

    if ( face->buildchar )
    {
      FT_FREE( face->buildchar );

      face->buildchar     = NULL;
      face->len_buildchar = 0;
    }

    T1_Done_Blend( face );
    face->blend = 0;
d208 3
a210 3
    /* release font info strings */
    {
      PS_FontInfo  info = &type1->font_info;
d213 6
a218 6
      FT_FREE( info->version );
      FT_FREE( info->notice );
      FT_FREE( info->full_name );
      FT_FREE( info->family_name );
      FT_FREE( info->weight );
    }
d220 15
a234 15
    /* release top dictionary */
    FT_FREE( type1->charstrings_len );
    FT_FREE( type1->charstrings );
    FT_FREE( type1->glyph_names );

    FT_FREE( type1->subrs );
    FT_FREE( type1->subrs_len );

    FT_FREE( type1->subrs_block );
    FT_FREE( type1->charstrings_block );
    FT_FREE( type1->glyph_names_block );

    FT_FREE( type1->encoding.char_index );
    FT_FREE( type1->encoding.char_name );
    FT_FREE( type1->font_name );
d237 3
a239 3
    /* release afm data if present */
    if ( face->afm_data )
      T1_Done_Metrics( memory, (AFM_FontInfo)face->afm_data );
d242 1
a242 1
    /* release unicode map, if any */
d244 3
a246 3
    FT_FREE( face->unicode_map_rec.maps );
    face->unicode_map_rec.num_maps = 0;
    face->unicode_map              = NULL;
d249 3
a251 2
    face->root.family_name = NULL;
    face->root.style_name  = NULL;
d293 1
d319 1
a319 1
    if ( face_index > 0 )
d336 1
a336 1
      root->face_index = 0;
a350 7

      /* The following code to extract the family and the style is very   */
      /* simplistic and might get some things wrong.  For a full-featured */
      /* algorithm you might have a look at the whitepaper given at       */
      /*                                                                  */
      /*   http://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */

d354 2
a355 2
      root->style_name  = NULL;

a363 3
          FT_Bool  the_same = TRUE;


a378 2
                the_same = FALSE;

a384 3

          if ( the_same )
            root->style_name = (char *)"Regular";
a393 9
      if ( !root->style_name )
      {
        if ( info->weight )
          root->style_name = info->weight;
        else
          /* assume `Regular' style because we don't know better */
          root->style_name = (char *)"Regular";
      }

d409 4
a412 5
      root->bbox.xMin =   type1->font_bbox.xMin            >> 16;
      root->bbox.yMin =   type1->font_bbox.yMin            >> 16;
      /* no `U' suffix here to 0xFFFF! */
      root->bbox.xMax = ( type1->font_bbox.xMax + 0xFFFF ) >> 16;
      root->bbox.yMax = ( type1->font_bbox.yMax + 0xFFFF ) >> 16;
d436 1
a436 1
          root->max_advance_width = (FT_Short)FIXED_TO_INT( max_advance );
d438 1
a438 1
          error = T1_Err_Ok;   /* clear error */
d460 1
a460 1
        /* first of all, try to synthesize a Unicode charmap */
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
d70 1
a70 1
           : 0;
d75 1
a75 1
  T1_Size_Done( FT_Size  t1size )          /* T1_Size */
a76 3
    T1_Size  size = (T1_Size)t1size;


d86 1
a86 1
      size->root.internal = NULL;
d92 1
a92 1
  T1_Size_Init( FT_Size  t1size )      /* T1_Size */
d94 1
a94 2
    T1_Size            size  = (T1_Size)t1size;
    FT_Error           error = FT_Err_Ok;
d115 1
a115 1
  T1_Size_Request( FT_Size          t1size,     /* T1_Size */
a117 1
    T1_Size            size  = (T1_Size)t1size;
d129 1
a129 1
    return FT_Err_Ok;
d140 1
a140 1
  T1_GlyphSlot_Done( FT_GlyphSlot  slot )
d142 1
a142 1
    slot->internal->glyph_hints = NULL;
d147 1
a147 1
  T1_GlyphSlot_Init( FT_GlyphSlot  slot )
d153 1
a153 1
    face     = (T1_Face)slot->face;
d161 2
a162 3
      module = FT_Get_Module( slot->face->driver->root.library,
                              "pshinter" );
      if ( module )
a165 1

d167 1
a167 1
        slot->internal->glyph_hints = (void*)funcs;
a169 1

d193 1
a193 1
  T1_Face_Done( FT_Face  t1face )         /* T1_Face */
a194 1
    T1_Face    face = (T1_Face)t1face;
d218 1
a218 1
    face->blend = NULL;
a240 3
    ft_hash_num_free( type1->subrs_hash, memory );
    FT_FREE( type1->subrs_hash );

d292 1
a292 1
                FT_Face        t1face,          /* T1_Face */
a296 1
    T1_Face             face = (T1_Face)t1face;
a315 6
    if ( !psaux )
    {
      FT_ERROR(( "T1_Face_Init: cannot access `psaux' module\n" ));
      error = FT_THROW( Missing_Module );
      goto Exit;
    }
a319 2
    FT_TRACE2(( "Type 1 driver\n" ));

d330 1
a330 1
    if ( ( face_index & 0xFFFF ) > 0 )
d333 1
a333 1
      error = FT_THROW( Invalid_Argument );
d349 4
a352 4
      root->face_flags |= FT_FACE_FLAG_SCALABLE    |
                          FT_FACE_FLAG_HORIZONTAL  |
                          FT_FACE_FLAG_GLYPH_NAMES |
                          FT_FACE_FLAG_HINTER;
d360 3
d442 1
a442 1
      root->available_sizes = NULL;
d450 1
a450 1
      /* Set units_per_EM if we didn't set it in t1_parse_font_matrix. */
d474 1
a474 1
          error = FT_Err_Ok;   /* clear error */
d487 1
a487 1
      if ( psnames )
d497 2
a498 2
        charmap.platform_id = TT_PLATFORM_MICROSOFT;
        charmap.encoding_id = TT_MS_ID_UNICODE_CS;
d501 1
a501 5
        error = FT_CMap_New( cmap_classes->unicode, NULL, &charmap, NULL );
        if ( error                                      &&
             FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
          goto Exit;
        error = FT_Err_Ok;
d504 1
a504 1
        charmap.platform_id = TT_PLATFORM_ADOBE;
d538 1
a538 1
          error = FT_CMap_New( clazz, NULL, &charmap, NULL );
d568 1
a568 1
  T1_Driver_Init( FT_Module  driver )
d572 1
a572 1
    return FT_Err_Ok;
d588 1
a588 1
  T1_Driver_Done( FT_Module  driver )
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
