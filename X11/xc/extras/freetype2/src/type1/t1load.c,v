head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.22.21;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.36;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.54;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.13;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.13;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.24;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.37.24;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.19;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.58;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.21;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.21;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.05;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  t1load.c                                                               */
/*                                                                         */
/*    Type 1 font loader (body).                                           */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This is the new and improved Type 1 data loader for FreeType 2.  The  */
  /* old loader has several problems: it is slow, complex, difficult to    */
  /* maintain, and contains incredible hacks to make it accept some        */
  /* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */
  /* the Type 1 fonts on my machine still aren't loaded correctly by it.   */
  /*                                                                       */
  /* This version is much simpler, much faster and also easier to read and */
  /* maintain by a great order of magnitude.  The idea behind it is to     */
  /* _not_ try to read the Type 1 token stream with a state machine (i.e.  */
  /* a Postscript-like interpreter) but rather to perform simple pattern   */
  /* matching.                                                             */
  /*                                                                       */
  /* Indeed, nearly all data definitions follow a simple pattern like      */
  /*                                                                       */
  /*  ... /Field <data> ...                                                */
  /*                                                                       */
  /* where <data> can be a number, a boolean, a string, or an array of     */
  /* numbers.  There are a few exceptions, namely the encoding, font name, */
  /* charstrings, and subrs; they are handled with a special pattern       */
  /* matching routine.                                                     */
  /*                                                                       */
  /* All other common cases are handled very simply.  The matching rules   */
  /* are defined in the file `t1tokens.h' through the use of several       */
  /* macros calls PARSE_XXX.  This file is included twice here; the first  */
  /* time to generate parsing callback functions, the second time to       */
  /* generate a table of keywords (with pointers to the associated         */
  /* callback functions).                                                  */
  /*                                                                       */
  /* The function `parse_dict' simply scans *linearly* a given dictionary  */
  /* (either the top-level or private one) and calls the appropriate       */
  /* callback when it encounters an immediate keyword.                     */
  /*                                                                       */
  /* This is by far the fastest way one can find to parse and read all     */
  /* data.                                                                 */
  /*                                                                       */
  /* This led to tremendous code size reduction.  Note that later, the     */
  /* glyph loader will also be _greatly_ simplified, and the automatic     */
  /* hinter will replace the clumsy `t1hinter'.                            */
  /*                                                                       */
  /*************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_CONFIG_CONFIG_H
#include FT_MULTIPLE_MASTERS_H
#include FT_INTERNAL_TYPE1_TYPES_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_HASH_H

#include "t1load.h"
#include "t1errors.h"


#ifdef FT_CONFIG_OPTION_INCREMENTAL
#define IS_INCREMENTAL  (FT_Bool)( face->root.internal->incremental_interface != 0 )
#else
#define IS_INCREMENTAL  0
#endif


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_t1load


#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    MULTIPLE MASTERS SUPPORT                   *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static FT_Error
  t1_allocate_blend( T1_Face  face,
                     FT_UInt  num_designs,
                     FT_UInt  num_axis )
  {
    PS_Blend   blend;
    FT_Memory  memory = face->root.memory;
    FT_Error   error  = FT_Err_Ok;


    blend = face->blend;
    if ( !blend )
    {
      if ( FT_NEW( blend ) )
        goto Exit;

      blend->num_default_design_vector = 0;

      face->blend = blend;
    }

    /* allocate design data if needed */
    if ( num_designs > 0 )
    {
      if ( blend->num_designs == 0 )
      {
        FT_UInt  nn;


        /* allocate the blend `private' and `font_info' dictionaries */
        if ( FT_NEW_ARRAY( blend->font_infos[1], num_designs     ) ||
             FT_NEW_ARRAY( blend->privates  [1], num_designs     ) ||
             FT_NEW_ARRAY( blend->bboxes    [1], num_designs     ) ||
             FT_NEW_ARRAY( blend->weight_vector, num_designs * 2 ) )
          goto Exit;

        blend->default_weight_vector = blend->weight_vector + num_designs;

        blend->font_infos[0] = &face->type1.font_info;
        blend->privates  [0] = &face->type1.private_dict;
        blend->bboxes    [0] = &face->type1.font_bbox;

        for ( nn = 2; nn <= num_designs; nn++ )
        {
          blend->font_infos[nn] = blend->font_infos[nn - 1] + 1;
          blend->privates  [nn] = blend->privates  [nn - 1] + 1;
          blend->bboxes    [nn] = blend->bboxes    [nn - 1] + 1;
        }

        blend->num_designs = num_designs;
      }
      else if ( blend->num_designs != num_designs )
        goto Fail;
    }

    /* allocate axis data if needed */
    if ( num_axis > 0 )
    {
      if ( blend->num_axis != 0 && blend->num_axis != num_axis )
        goto Fail;

      blend->num_axis = num_axis;
    }

    /* allocate the blend design pos table if needed */
    num_designs = blend->num_designs;
    num_axis    = blend->num_axis;
    if ( num_designs && num_axis && blend->design_pos[0] == 0 )
    {
      FT_UInt  n;


      if ( FT_NEW_ARRAY( blend->design_pos[0], num_designs * num_axis ) )
        goto Exit;

      for ( n = 1; n < num_designs; n++ )
        blend->design_pos[n] = blend->design_pos[0] + num_axis * n;
    }

  Exit:
    return error;

  Fail:
    error = FT_THROW( Invalid_File_Format );
    goto Exit;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Get_Multi_Master( T1_Face           face,
                       FT_Multi_Master*  master )
  {
    PS_Blend  blend = face->blend;
    FT_UInt   n;
    FT_Error  error;


    error = FT_THROW( Invalid_Argument );

    if ( blend )
    {
      master->num_axis    = blend->num_axis;
      master->num_designs = blend->num_designs;

      for ( n = 0; n < blend->num_axis; n++ )
      {
        FT_MM_Axis*   axis = master->axis + n;
        PS_DesignMap  map = blend->design_map + n;


        axis->name    = blend->axis_names[n];
        axis->minimum = map->design_points[0];
        axis->maximum = map->design_points[map->num_points - 1];
      }

      error = FT_Err_Ok;
    }

    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Given a normalized (blend) coordinate, figure out the design          */
  /* coordinate appropriate for that value.                                */
  /*                                                                       */
  static FT_Fixed
  mm_axis_unmap( PS_DesignMap  axismap,
                 FT_Fixed      ncv )
  {
    int  j;


    if ( ncv <= axismap->blend_points[0] )
      return INT_TO_FIXED( axismap->design_points[0] );

    for ( j = 1; j < axismap->num_points; j++ )
    {
      if ( ncv <= axismap->blend_points[j] )
        return INT_TO_FIXED( axismap->design_points[j - 1] ) +
               ( axismap->design_points[j] - axismap->design_points[j - 1] ) *
               FT_DivFix( ncv - axismap->blend_points[j - 1],
                          axismap->blend_points[j] -
                            axismap->blend_points[j - 1] );
    }

    return INT_TO_FIXED( axismap->design_points[axismap->num_points - 1] );
  }


  /*************************************************************************/
  /*                                                                       */
  /* Given a vector of weights, one for each design, figure out the        */
  /* normalized axis coordinates which gave rise to those weights.         */
  /*                                                                       */
  static void
  mm_weights_unmap( FT_Fixed*  weights,
                    FT_Fixed*  axiscoords,
                    FT_UInt    axis_count )
  {
    FT_ASSERT( axis_count <= T1_MAX_MM_AXIS );

    if ( axis_count == 1 )
      axiscoords[0] = weights[1];

    else if ( axis_count == 2 )
    {
      axiscoords[0] = weights[3] + weights[1];
      axiscoords[1] = weights[3] + weights[2];
    }

    else if ( axis_count == 3 )
    {
      axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
    }

    else
    {
      axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
                        weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
                        weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[7] + weights[6] + weights[5] + weights[4];
      axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[11] + weights[10] + weights[9] + weights[8];
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Get_Multi_Master to support the different    */
  /*  arguments needed by the GX var distortable fonts.                    */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Get_MM_Var( T1_Face      face,
                 FT_MM_Var*  *master )
  {
    FT_Memory        memory = face->root.memory;
    FT_MM_Var       *mmvar = NULL;
    FT_Multi_Master  mmaster;
    FT_Error         error;
    FT_UInt          i;
    FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
    PS_Blend         blend = face->blend;


    error = T1_Get_Multi_Master( face, &mmaster );
    if ( error )
      goto Exit;
    if ( FT_ALLOC( mmvar,
                   sizeof ( FT_MM_Var ) +
                     mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
      goto Exit;

    mmvar->num_axis        = mmaster.num_axis;
    mmvar->num_designs     = mmaster.num_designs;
    mmvar->num_namedstyles = 0;                           /* Not supported */
    mmvar->axis            = (FT_Var_Axis*)&mmvar[1];
                                      /* Point to axes after MM_Var struct */
    mmvar->namedstyle      = NULL;

    for ( i = 0; i < mmaster.num_axis; i++ )
    {
      mmvar->axis[i].name    = mmaster.axis[i].name;
      mmvar->axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum);
      mmvar->axis[i].maximum = INT_TO_FIXED( mmaster.axis[i].maximum);
      mmvar->axis[i].def     = ( mmvar->axis[i].minimum +
                                   mmvar->axis[i].maximum ) / 2;
                            /* Does not apply.  But this value is in range */
      mmvar->axis[i].strid   = ~0U;                      /* Does not apply */
      mmvar->axis[i].tag     = ~0U;                      /* Does not apply */

      if ( !mmvar->axis[i].name )
        continue;

      if ( ft_strcmp( mmvar->axis[i].name, "Weight" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'g', 'h', 't' );
      else if ( ft_strcmp( mmvar->axis[i].name, "Width" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'd', 't', 'h' );
      else if ( ft_strcmp( mmvar->axis[i].name, "OpticalSize" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'o', 'p', 's', 'z' );
    }

    if ( blend->num_designs == ( 1U << blend->num_axis ) )
    {
      mm_weights_unmap( blend->default_weight_vector,
                        axiscoords,
                        blend->num_axis );

      for ( i = 0; i < mmaster.num_axis; i++ )
        mmvar->axis[i].def = mm_axis_unmap( &blend->design_map[i],
                                            axiscoords[i] );
    }

    *master = mmvar;

  Exit:
    return error;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Set_MM_Blend( T1_Face    face,
                   FT_UInt    num_coords,
                   FT_Fixed*  coords )
  {
    PS_Blend  blend = face->blend;
    FT_UInt   n, m;


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    if ( num_coords > blend->num_axis )
      num_coords = blend->num_axis;

    /* recompute the weight vector from the blend coordinates */
    for ( n = 0; n < blend->num_designs; n++ )
    {
      FT_Fixed  result = 0x10000L;  /* 1.0 fixed */


      for ( m = 0; m < blend->num_axis; m++ )
      {
        FT_Fixed  factor;


        /* get current blend axis position;                  */
        /* use a default value if we don't have a coordinate */
        factor = m < num_coords ? coords[m] : 0x8000;
        if ( factor < 0 )
          factor = 0;
        if ( factor > 0x10000L )
          factor = 0x10000L;

        if ( ( n & ( 1 << m ) ) == 0 )
          factor = 0x10000L - factor;

        result = FT_MulFix( result, factor );
      }
      blend->weight_vector[n] = result;
    }

    return FT_Err_Ok;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Get_MM_Blend( T1_Face    face,
                   FT_UInt    num_coords,
                   FT_Fixed*  coords )
  {
    PS_Blend  blend = face->blend;

    FT_Fixed  axiscoords[4];
    FT_UInt   i, nc;


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    mm_weights_unmap( blend->weight_vector,
                      axiscoords,
                      blend->num_axis );

    nc = num_coords;
    if ( num_coords > blend->num_axis )
    {
      FT_TRACE2(( "T1_Get_MM_Blend: only using first %d of %d coordinates\n",
                  blend->num_axis, num_coords ));
      nc = blend->num_axis;
    }

    for ( i = 0; i < nc; i++ )
      coords[i] = axiscoords[i];
    for ( ; i < num_coords; i++ )
      coords[i] = 0x8000;

    return FT_Err_Ok;
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Set_MM_Design( T1_Face   face,
                    FT_UInt   num_coords,
                    FT_Long*  coords )
  {
    PS_Blend  blend = face->blend;
    FT_UInt   n, p;
    FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    if ( num_coords > blend->num_axis )
      num_coords = blend->num_axis;

    /* compute the blend coordinates through the blend design map */

    for ( n = 0; n < blend->num_axis; n++ )
    {
      FT_Long       design;
      FT_Fixed      the_blend;
      PS_DesignMap  map     = blend->design_map + n;
      FT_Long*      designs = map->design_points;
      FT_Fixed*     blends  = map->blend_points;
      FT_Int        before  = -1, after = -1;


      /* use a default value if we don't have a coordinate */
      if ( n < num_coords )
        design = coords[n];
      else
        design = ( designs[map->num_points - 1] - designs[0] ) / 2;

      for ( p = 0; p < (FT_UInt)map->num_points; p++ )
      {
        FT_Long  p_design = designs[p];


        /* exact match? */
        if ( design == p_design )
        {
          the_blend = blends[p];
          goto Found;
        }

        if ( design < p_design )
        {
          after = (FT_Int)p;
          break;
        }

        before = (FT_Int)p;
      }

      /* now interpolate if necessary */
      if ( before < 0 )
        the_blend = blends[0];

      else if ( after < 0 )
        the_blend = blends[map->num_points - 1];

      else
        the_blend = FT_MulDiv( design         - designs[before],
                               blends [after] - blends [before],
                               designs[after] - designs[before] );

    Found:
      final_blends[n] = the_blend;
    }

    return T1_Set_MM_Blend( face, blend->num_axis, final_blends );
  }


  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Set_MM_Design to support the different       */
  /* arguments needed by the GX var distortable fonts.                     */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Set_Var_Design( T1_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
  {
     FT_Long  lcoords[T1_MAX_MM_AXIS];
     FT_UInt  i;


     if ( num_coords > T1_MAX_MM_AXIS )
       num_coords = T1_MAX_MM_AXIS;

     for ( i = 0; i < num_coords; i++ )
       lcoords[i] = FIXED_TO_INT( coords[i] );

     return T1_Set_MM_Design( face, num_coords, lcoords );
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Get_Var_Design( T1_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
  {
    PS_Blend  blend = face->blend;

    FT_Fixed  axiscoords[4];
    FT_UInt   i, nc;


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    mm_weights_unmap( blend->weight_vector,
                      axiscoords,
                      blend->num_axis );

    nc = num_coords;
    if ( num_coords > blend->num_axis )
    {
      FT_TRACE2(( "T1_Get_Var_Design:"
                  " only using first %d of %d coordinates\n",
                  blend->num_axis, num_coords ));
      nc = blend->num_axis;
    }

    for ( i = 0; i < nc; i++ )
      coords[i] = mm_axis_unmap( &blend->design_map[i], axiscoords[i] );
    for ( ; i < num_coords; i++ )
      coords[i] = 0;

    return FT_Err_Ok;
  }


  FT_LOCAL_DEF( void )
  T1_Done_Blend( T1_Face  face )
  {
    FT_Memory  memory = face->root.memory;
    PS_Blend   blend  = face->blend;


    if ( blend )
    {
      FT_UInt  num_designs = blend->num_designs;
      FT_UInt  num_axis    = blend->num_axis;
      FT_UInt  n;


      /* release design pos table */
      FT_FREE( blend->design_pos[0] );
      for ( n = 1; n < num_designs; n++ )
        blend->design_pos[n] = NULL;

      /* release blend `private' and `font info' dictionaries */
      FT_FREE( blend->privates[1] );
      FT_FREE( blend->font_infos[1] );
      FT_FREE( blend->bboxes[1] );

      for ( n = 0; n < num_designs; n++ )
      {
        blend->privates  [n] = NULL;
        blend->font_infos[n] = NULL;
        blend->bboxes    [n] = NULL;
      }

      /* release weight vectors */
      FT_FREE( blend->weight_vector );
      blend->default_weight_vector = NULL;

      /* release axis names */
      for ( n = 0; n < num_axis; n++ )
        FT_FREE( blend->axis_names[n] );

      /* release design map */
      for ( n = 0; n < num_axis; n++ )
      {
        PS_DesignMap  dmap = blend->design_map + n;


        FT_FREE( dmap->design_points );
        dmap->num_points = 0;
      }

      FT_FREE( face->blend );
    }
  }


  static void
  parse_blend_axis_types( T1_Face    face,
                          T1_Loader  loader )
  {
    T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
    FT_Int       n, num_axis;
    FT_Error     error = FT_Err_Ok;
    PS_Blend     blend;
    FT_Memory    memory;


    /* take an array of objects */
    T1_ToTokenArray( &loader->parser, axis_tokens,
                     T1_MAX_MM_AXIS, &num_axis );
    if ( num_axis < 0 )
    {
      error = FT_ERR( Ignore );
      goto Exit;
    }
    if ( num_axis == 0 || num_axis > T1_MAX_MM_AXIS )
    {
      FT_ERROR(( "parse_blend_axis_types: incorrect number of axes: %d\n",
                 num_axis ));
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    /* allocate blend if necessary */
    error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
    if ( error )
      goto Exit;

    blend  = face->blend;
    memory = face->root.memory;

    /* each token is an immediate containing the name of the axis */
    for ( n = 0; n < num_axis; n++ )
    {
      T1_Token  token = axis_tokens + n;
      FT_Byte*  name;
      FT_UInt   len;


      /* skip first slash, if any */
      if ( token->start[0] == '/' )
        token->start++;

      len = (FT_UInt)( token->limit - token->start );
      if ( len == 0 )
      {
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      name = (FT_Byte*)blend->axis_names[n];
      if ( name )
      {
        FT_TRACE0(( "parse_blend_axis_types:"
                    " overwriting axis name `%s' with `%*.s'\n",
                    name, len, token->start ));
        FT_FREE( name );
      }

      if ( FT_ALLOC( blend->axis_names[n], len + 1 ) )
        goto Exit;

      name = (FT_Byte*)blend->axis_names[n];
      FT_MEM_COPY( name, token->start, len );
      name[len] = '\0';
    }

  Exit:
    loader->parser.root.error = error;
  }


  static void
  parse_blend_design_positions( T1_Face    face,
                                T1_Loader  loader )
  {
    T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
    FT_Int       num_designs;
    FT_Int       num_axis;
    T1_Parser    parser = &loader->parser;

    FT_Error     error = FT_Err_Ok;
    PS_Blend     blend;


    /* get the array of design tokens -- compute number of designs */
    T1_ToTokenArray( parser, design_tokens,
                     T1_MAX_MM_DESIGNS, &num_designs );
    if ( num_designs < 0 )
    {
      error = FT_ERR( Ignore );
      goto Exit;
    }
    if ( num_designs == 0 || num_designs > T1_MAX_MM_DESIGNS )
    {
      FT_ERROR(( "parse_blend_design_positions:"
                 " incorrect number of designs: %d\n",
                 num_designs ));
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    {
      FT_Byte*  old_cursor = parser->root.cursor;
      FT_Byte*  old_limit  = parser->root.limit;
      FT_Int    n;


      blend    = face->blend;
      num_axis = 0;  /* make compiler happy */

      for ( n = 0; n < num_designs; n++ )
      {
        T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
        T1_Token     token;
        FT_Int       axis, n_axis;


        /* read axis/coordinates tokens */
        token = design_tokens + n;
        parser->root.cursor = token->start;
        parser->root.limit  = token->limit;
        T1_ToTokenArray( parser, axis_tokens, T1_MAX_MM_AXIS, &n_axis );

        if ( n == 0 )
        {
          if ( n_axis <= 0 || n_axis > T1_MAX_MM_AXIS )
          {
            FT_ERROR(( "parse_blend_design_positions:"
                       " invalid number of axes: %d\n",
                       n_axis ));
            error = FT_THROW( Invalid_File_Format );
            goto Exit;
          }

          num_axis = n_axis;
          error = t1_allocate_blend( face,
                                     (FT_UInt)num_designs,
                                     (FT_UInt)num_axis );
          if ( error )
            goto Exit;
          blend = face->blend;
        }
        else if ( n_axis != num_axis )
        {
          FT_ERROR(( "parse_blend_design_positions: incorrect table\n" ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
        }

        /* now read each axis token into the design position */
        for ( axis = 0; axis < n_axis; axis++ )
        {
          T1_Token  token2 = axis_tokens + axis;


          parser->root.cursor = token2->start;
          parser->root.limit  = token2->limit;
          blend->design_pos[n][axis] = T1_ToFixed( parser, 0 );
        }
      }

      loader->parser.root.cursor = old_cursor;
      loader->parser.root.limit  = old_limit;
    }

  Exit:
    loader->parser.root.error = error;
  }


  static void
  parse_blend_design_map( T1_Face    face,
                          T1_Loader  loader )
  {
    FT_Error     error  = FT_Err_Ok;
    T1_Parser    parser = &loader->parser;
    PS_Blend     blend;
    T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
    FT_Int       n, num_axis;
    FT_Byte*     old_cursor;
    FT_Byte*     old_limit;
    FT_Memory    memory = face->root.memory;


    T1_ToTokenArray( parser, axis_tokens,
                     T1_MAX_MM_AXIS, &num_axis );
    if ( num_axis < 0 )
    {
      error = FT_ERR( Ignore );
      goto Exit;
    }
    if ( num_axis == 0 || num_axis > T1_MAX_MM_AXIS )
    {
      FT_ERROR(( "parse_blend_design_map: incorrect number of axes: %d\n",
                 num_axis ));
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    old_cursor = parser->root.cursor;
    old_limit  = parser->root.limit;

    error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
    if ( error )
      goto Exit;
    blend = face->blend;

    /* now read each axis design map */
    for ( n = 0; n < num_axis; n++ )
    {
      PS_DesignMap  map = blend->design_map + n;
      T1_Token      axis_token;
      T1_TokenRec   point_tokens[T1_MAX_MM_MAP_POINTS];
      FT_Int        p, num_points;


      axis_token = axis_tokens + n;

      parser->root.cursor = axis_token->start;
      parser->root.limit  = axis_token->limit;
      T1_ToTokenArray( parser, point_tokens,
                       T1_MAX_MM_MAP_POINTS, &num_points );

      if ( num_points <= 0 || num_points > T1_MAX_MM_MAP_POINTS )
      {
        FT_ERROR(( "parse_blend_design_map: incorrect table\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      if ( map->design_points )
      {
        FT_ERROR(( "parse_blend_design_map: duplicate table\n" ));
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      /* allocate design map data */
      if ( FT_NEW_ARRAY( map->design_points, num_points * 2 ) )
        goto Exit;
      map->blend_points = map->design_points + num_points;
      map->num_points   = (FT_Byte)num_points;

      for ( p = 0; p < num_points; p++ )
      {
        T1_Token  point_token;


        point_token = point_tokens + p;

        /* don't include delimiting brackets */
        parser->root.cursor = point_token->start + 1;
        parser->root.limit  = point_token->limit - 1;

        map->design_points[p] = T1_ToInt( parser );
        map->blend_points [p] = T1_ToFixed( parser, 0 );
      }
    }

    parser->root.cursor = old_cursor;
    parser->root.limit  = old_limit;

  Exit:
    parser->root.error = error;
  }


  static void
  parse_weight_vector( T1_Face    face,
                       T1_Loader  loader )
  {
    T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
    FT_Int       num_designs;
    FT_Error     error  = FT_Err_Ok;
    T1_Parser    parser = &loader->parser;
    PS_Blend     blend  = face->blend;
    T1_Token     token;
    FT_Int       n;
    FT_Byte*     old_cursor;
    FT_Byte*     old_limit;


    T1_ToTokenArray( parser, design_tokens,
                     T1_MAX_MM_DESIGNS, &num_designs );
    if ( num_designs < 0 )
    {
      error = FT_ERR( Ignore );
      goto Exit;
    }
    if ( num_designs == 0 || num_designs > T1_MAX_MM_DESIGNS )
    {
      FT_ERROR(( "parse_weight_vector:"
                 " incorrect number of designs: %d\n",
                 num_designs ));
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    if ( !blend || !blend->num_designs )
    {
      error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );
      if ( error )
        goto Exit;
      blend = face->blend;
    }
    else if ( blend->num_designs != (FT_UInt)num_designs )
    {
      FT_ERROR(( "parse_weight_vector:"
                 " /BlendDesignPosition and /WeightVector have\n"
                 "                    "
                 " different number of elements\n" ));
      error = FT_THROW( Invalid_File_Format );
      goto Exit;
    }

    old_cursor = parser->root.cursor;
    old_limit  = parser->root.limit;

    for ( n = 0; n < num_designs; n++ )
    {
      token = design_tokens + n;
      parser->root.cursor = token->start;
      parser->root.limit  = token->limit;

      blend->default_weight_vector[n] =
      blend->weight_vector[n]         = T1_ToFixed( parser, 0 );
    }

    parser->root.cursor = old_cursor;
    parser->root.limit  = old_limit;

  Exit:
    parser->root.error = error;
  }


  /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
  /* we're only interested in the number of array elements */
  static void
  parse_buildchar( T1_Face    face,
                   T1_Loader  loader )
  {
    face->len_buildchar = (FT_UInt)T1_ToFixedArray( &loader->parser,
                                                    0, NULL, 0 );
    return;
  }


#endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */




  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                      TYPE 1 SYMBOL PARSING                    *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  static FT_Error
  t1_load_keyword( T1_Face         face,
                   T1_Loader       loader,
                   const T1_Field  field )
  {
    FT_Error  error;
    void*     dummy_object;
    void**    objects;
    FT_UInt   max_objects;
    PS_Blend  blend = face->blend;


    if ( blend && blend->num_designs == 0 )
      blend = NULL;

    /* if the keyword has a dedicated callback, call it */
    if ( field->type == T1_FIELD_TYPE_CALLBACK )
    {
      field->reader( (FT_Face)face, loader );
      error = loader->parser.root.error;
      goto Exit;
    }

    /* now, the keyword is either a simple field, or a table of fields; */
    /* we are now going to take care of it                              */
    switch ( field->location )
    {
    case T1_FIELD_LOCATION_FONT_INFO:
      dummy_object = &face->type1.font_info;
      objects      = &dummy_object;
      max_objects  = 0;

      if ( blend )
      {
        objects     = (void**)blend->font_infos;
        max_objects = blend->num_designs;
      }
      break;

    case T1_FIELD_LOCATION_FONT_EXTRA:
      dummy_object = &face->type1.font_extra;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

    case T1_FIELD_LOCATION_PRIVATE:
      dummy_object = &face->type1.private_dict;
      objects      = &dummy_object;
      max_objects  = 0;

      if ( blend )
      {
        objects     = (void**)blend->privates;
        max_objects = blend->num_designs;
      }
      break;

    case T1_FIELD_LOCATION_BBOX:
      dummy_object = &face->type1.font_bbox;
      objects      = &dummy_object;
      max_objects  = 0;

      if ( blend )
      {
        objects     = (void**)blend->bboxes;
        max_objects = blend->num_designs;
      }
      break;

    case T1_FIELD_LOCATION_LOADER:
      dummy_object = loader;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

    case T1_FIELD_LOCATION_FACE:
      dummy_object = face;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
    case T1_FIELD_LOCATION_BLEND:
      dummy_object = face->blend;
      objects      = &dummy_object;
      max_objects  = 0;
      break;
#endif

    default:
      dummy_object = &face->type1;
      objects      = &dummy_object;
      max_objects  = 0;
    }

    if ( *objects )
    {
      if ( field->type == T1_FIELD_TYPE_INTEGER_ARRAY ||
           field->type == T1_FIELD_TYPE_FIXED_ARRAY   )
        error = T1_Load_Field_Table( &loader->parser, field,
                                     objects, max_objects, 0 );
      else
        error = T1_Load_Field( &loader->parser, field,
                               objects, max_objects, 0 );
    }
    else
    {
      FT_TRACE1(( "t1_load_keyword: ignoring keyword `%s'"
                  " which is not valid at this point\n"
                  "                 (probably due to missing keywords)\n",
                 field->ident ));
      error = FT_Err_Ok;
    }

  Exit:
    return error;
  }


  static void
  parse_private( T1_Face    face,
                 T1_Loader  loader )
  {
    FT_UNUSED( face );

    loader->keywords_encountered |= T1_PRIVATE;
  }


  /* return 1 in case of success */

  static int
  read_binary_data( T1_Parser  parser,
                    FT_ULong*  size,
                    FT_Byte**  base,
                    FT_Bool    incremental )
  {
    FT_Byte*  cur;
    FT_Byte*  limit = parser->root.limit;


    /* the binary data has one of the following formats */
    /*                                                  */
    /*   `size' [white*] RD white ....... ND            */
    /*   `size' [white*] -| white ....... |-            */
    /*                                                  */

    T1_Skip_Spaces( parser );

    cur = parser->root.cursor;

    if ( cur < limit && ft_isdigit( *cur ) )
    {
      FT_Long  s = T1_ToInt( parser );


      T1_Skip_PS_Token( parser );   /* `RD' or `-|' or something else */

      /* there is only one whitespace char after the */
      /* `RD' or `-|' token                          */
      *base = parser->root.cursor + 1;

      if ( s >= 0 && s < limit - *base )
      {
        parser->root.cursor += s + 1;
        *size = (FT_ULong)s;
        return !parser->root.error;
      }
    }

    if( !incremental )
    {
      FT_ERROR(( "read_binary_data: invalid size field\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
    }

    return 0;
  }


  /* We now define the routines to handle the `/Encoding', `/Subrs', */
  /* and `/CharStrings' dictionaries.                                */

  static void
  t1_parse_font_matrix( T1_Face    face,
                        T1_Loader  loader )
  {
    T1_Parser   parser = &loader->parser;
    FT_Matrix*  matrix = &face->type1.font_matrix;
    FT_Vector*  offset = &face->type1.font_offset;
    FT_Face     root   = (FT_Face)&face->root;
    FT_Fixed    temp[6];
    FT_Fixed    temp_scale;
    FT_Int      result;


    /* input is scaled by 1000 to accommodate default FontMatrix */
    result = T1_ToFixedArray( parser, 6, temp, 3 );

    if ( result < 6 )
    {
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    temp_scale = FT_ABS( temp[3] );

    if ( temp_scale == 0 )
    {
      FT_ERROR(( "t1_parse_font_matrix: invalid font matrix\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    /* atypical case */
    if ( temp_scale != 0x10000L )
    {
      /* set units per EM based on FontMatrix values */
      root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );

      temp[0] = FT_DivFix( temp[0], temp_scale );
      temp[1] = FT_DivFix( temp[1], temp_scale );
      temp[2] = FT_DivFix( temp[2], temp_scale );
      temp[4] = FT_DivFix( temp[4], temp_scale );
      temp[5] = FT_DivFix( temp[5], temp_scale );
      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;
    }

    matrix->xx = temp[0];
    matrix->yx = temp[1];
    matrix->xy = temp[2];
    matrix->yy = temp[3];

    /* note that the offsets must be expressed in integer font units */
    offset->x = temp[4] >> 16;
    offset->y = temp[5] >> 16;
  }


  static void
  parse_encoding( T1_Face    face,
                  T1_Loader  loader )
  {
    T1_Parser  parser = &loader->parser;
    FT_Byte*   cur;
    FT_Byte*   limit  = parser->root.limit;

    PSAux_Service  psaux = (PSAux_Service)face->psaux;


    T1_Skip_Spaces( parser );
    cur = parser->root.cursor;
    if ( cur >= limit )
    {
      FT_ERROR(( "parse_encoding: out of bounds\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    /* if we have a number or `[', the encoding is an array, */
    /* and we must load it now                               */
    if ( ft_isdigit( *cur ) || *cur == '[' )
    {
      T1_Encoding  encode          = &face->type1.encoding;
      FT_Int       count, n;
      PS_Table     char_table      = &loader->encoding_table;
      FT_Memory    memory          = parser->root.memory;
      FT_Error     error;
      FT_Bool      only_immediates = 0;


      /* read the number of entries in the encoding; should be 256 */
      if ( *cur == '[' )
      {
        count           = 256;
        only_immediates = 1;
        parser->root.cursor++;
      }
      else
        count = (FT_Int)T1_ToInt( parser );

      /* only composite fonts (which we don't support) */
      /* can have larger values                        */
      if ( count > 256 )
      {
        FT_ERROR(( "parse_encoding: invalid encoding array size\n" ));
        parser->root.error = FT_THROW( Invalid_File_Format );
        return;
      }

      T1_Skip_Spaces( parser );
      if ( parser->root.cursor >= limit )
        return;

      /* PostScript happily allows overwriting of encoding arrays */
      if ( encode->char_index )
      {
        FT_FREE( encode->char_index );
        FT_FREE( encode->char_name );
        T1_Release_Table( char_table );
      }

      /* we use a T1_Table to store our charnames */
      loader->num_chars = encode->num_chars = count;
      if ( FT_NEW_ARRAY( encode->char_index, count )     ||
           FT_NEW_ARRAY( encode->char_name,  count )     ||
           FT_SET_ERROR( psaux->ps_table_funcs->init(
                           char_table, count, memory ) ) )
      {
        parser->root.error = error;
        return;
      }

      /* We need to `zero' out encoding_table.elements */
      for ( n = 0; n < count; n++ )
      {
        char*  notdef = (char *)".notdef";


        (void)T1_Add_Table( char_table, n, notdef, 8 );
      }

      /* Now we need to read records of the form                */
      /*                                                        */
      /*   ... charcode /charname ...                           */
      /*                                                        */
      /* for each entry in our table.                           */
      /*                                                        */
      /* We simply look for a number followed by an immediate   */
      /* name.  Note that this ignores correctly the sequence   */
      /* that is often seen in type1 fonts:                     */
      /*                                                        */
      /*   0 1 255 { 1 index exch /.notdef put } for dup        */
      /*                                                        */
      /* used to clean the encoding array before anything else. */
      /*                                                        */
      /* Alternatively, if the array is directly given as       */
      /*                                                        */
      /*   /Encoding [ ... ]                                    */
      /*                                                        */
      /* we only read immediates.                               */

      n = 0;
      T1_Skip_Spaces( parser );

      while ( parser->root.cursor < limit )
      {
        cur = parser->root.cursor;

        /* we stop when we encounter a `def' or `]' */
        if ( *cur == 'd' && cur + 3 < limit )
        {
          if ( cur[1] == 'e'         &&
               cur[2] == 'f'         &&
               IS_PS_DELIM( cur[3] ) )
          {
            FT_TRACE6(( "encoding end\n" ));
            cur += 3;
            break;
          }
        }
        if ( *cur == ']' )
        {
          FT_TRACE6(( "encoding end\n" ));
          cur++;
          break;
        }

        /* check whether we've found an entry */
        if ( ft_isdigit( *cur ) || only_immediates )
        {
          FT_Int  charcode;


          if ( only_immediates )
            charcode = n;
          else
          {
            charcode = (FT_Int)T1_ToInt( parser );
            T1_Skip_Spaces( parser );

            /* protect against invalid charcode */
            if ( cur == parser->root.cursor )
            {
              parser->root.error = FT_THROW( Unknown_File_Format );
              return;
            }
          }

          cur = parser->root.cursor;

          if ( cur + 2 < limit && *cur == '/' && n < count )
          {
            FT_UInt  len;


            cur++;

            parser->root.cursor = cur;
            T1_Skip_PS_Token( parser );
            if ( parser->root.cursor >= limit )
              return;
            if ( parser->root.error )
              return;

            len = (FT_UInt)( parser->root.cursor - cur );

            parser->root.error = T1_Add_Table( char_table, charcode,
                                               cur, len + 1 );
            if ( parser->root.error )
              return;
            char_table->elements[charcode][len] = '\0';

            n++;
          }
          else if ( only_immediates )
          {
            /* Since the current position is not updated for           */
            /* immediates-only mode we would get an infinite loop if   */
            /* we don't do anything here.                              */
            /*                                                         */
            /* This encoding array is not valid according to the type1 */
            /* specification (it might be an encoding for a CID type1  */
            /* font, however), so we conclude that this font is NOT a  */
            /* type1 font.                                             */
            parser->root.error = FT_THROW( Unknown_File_Format );
            return;
          }
        }
        else
        {
          T1_Skip_PS_Token( parser );
          if ( parser->root.error )
            return;
        }

        T1_Skip_Spaces( parser );
      }

      face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
      parser->root.cursor       = cur;
    }

    /* Otherwise, we should have either `StandardEncoding', */
    /* `ExpertEncoding', or `ISOLatin1Encoding'             */
    else
    {
      if ( cur + 17 < limit                                            &&
           ft_strncmp( (const char*)cur, "StandardEncoding", 16 ) == 0 )
        face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;

      else if ( cur + 15 < limit                                          &&
                ft_strncmp( (const char*)cur, "ExpertEncoding", 14 ) == 0 )
        face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;

      else if ( cur + 18 < limit                                             &&
                ft_strncmp( (const char*)cur, "ISOLatin1Encoding", 17 ) == 0 )
        face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;

      else
        parser->root.error = FT_ERR( Ignore );
    }
  }


  static void
  parse_subrs( T1_Face    face,
               T1_Loader  loader )
  {
    T1_Parser  parser = &loader->parser;
    PS_Table   table  = &loader->subrs;
    FT_Memory  memory = parser->root.memory;
    FT_Error   error;
    FT_Int     num_subrs;
    FT_UInt    count;

    PSAux_Service  psaux = (PSAux_Service)face->psaux;


    T1_Skip_Spaces( parser );

    /* test for empty array */
    if ( parser->root.cursor < parser->root.limit &&
         *parser->root.cursor == '['              )
    {
      T1_Skip_PS_Token( parser );
      T1_Skip_Spaces  ( parser );
      if ( parser->root.cursor >= parser->root.limit ||
           *parser->root.cursor != ']'               )
        parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    num_subrs = (FT_Int)T1_ToInt( parser );
    if ( num_subrs < 0 )
    {
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    /* we certainly need more than 8 bytes per subroutine */
    if ( parser->root.limit >= parser->root.cursor                     &&
         num_subrs > ( parser->root.limit - parser->root.cursor ) >> 3 )
    {
      /*
       * There are two possibilities.  Either the font contains an invalid
       * value for `num_subrs', or we have a subsetted font where the
       * subroutine indices are not adjusted, e.g.
       *
       *   /Subrs 812 array
       *     dup 0 { ... } NP
       *     dup 51 { ... } NP
       *     dup 681 { ... } NP
       *   ND
       *
       * In both cases, we use a number hash that maps from subr indices to
       * actual array elements.
       */

      FT_TRACE0(( "parse_subrs: adjusting number of subroutines"
                  " (from %d to %d)\n",
                  num_subrs,
                  ( parser->root.limit - parser->root.cursor ) >> 3 ));
      num_subrs = ( parser->root.limit - parser->root.cursor ) >> 3;

      if ( !loader->subrs_hash )
      {
        if ( FT_NEW( loader->subrs_hash ) )
          goto Fail;

        error = ft_hash_num_init( loader->subrs_hash, memory );
        if ( error )
          goto Fail;
      }
    }

    /* position the parser right before the `dup' of the first subr */
    T1_Skip_PS_Token( parser );         /* `array' */
    if ( parser->root.error )
      return;
    T1_Skip_Spaces( parser );

    /* initialize subrs array -- with synthetic fonts it is possible */
    /* we get here twice                                             */
    if ( !loader->num_subrs )
    {
      error = psaux->ps_table_funcs->init( table, num_subrs, memory );
      if ( error )
        goto Fail;
    }

    /* the format is simple:   */
    /*                         */
    /*   `index' + binary data */
    /*                         */
    for ( count = 0; ; count++ )
    {
      FT_Long   idx;
      FT_ULong  size;
      FT_Byte*  base;


      /* If we are out of data, or if the next token isn't `dup', */
      /* we are done.                                             */
      if ( parser->root.cursor + 4 >= parser->root.limit          ||
          ft_strncmp( (char*)parser->root.cursor, "dup", 3 ) != 0 )
        break;

      T1_Skip_PS_Token( parser );       /* `dup' */

      idx = T1_ToInt( parser );

      if ( !read_binary_data( parser, &size, &base, IS_INCREMENTAL ) )
        return;

      /* The binary string is followed by one token, e.g. `NP' */
      /* (bound to `noaccess put') or by two separate tokens:  */
      /* `noaccess' & `put'.  We position the parser right     */
      /* before the next `dup', if any.                        */
      T1_Skip_PS_Token( parser );   /* `NP' or `|' or `noaccess' */
      if ( parser->root.error )
        return;
      T1_Skip_Spaces  ( parser );

      if ( parser->root.cursor + 4 < parser->root.limit            &&
           ft_strncmp( (char*)parser->root.cursor, "put", 3 ) == 0 )
      {
        T1_Skip_PS_Token( parser ); /* skip `put' */
        T1_Skip_Spaces  ( parser );
      }

      /* if we use a hash, the subrs index is the key, and a running */
      /* counter specified for `T1_Add_Table' acts as the value      */
      if ( loader->subrs_hash )
      {
        ft_hash_num_insert( idx, count, loader->subrs_hash, memory );
        idx = count;
      }

      /* with synthetic fonts it is possible we get here twice */
      if ( loader->num_subrs )
        continue;

      /* some fonts use a value of -1 for lenIV to indicate that */
      /* the charstrings are unencoded                           */
      /*                                                         */
      /* thanks to Tom Kacvinsky for pointing this out           */
      /*                                                         */
      if ( face->type1.private_dict.lenIV >= 0 )
      {
        FT_Byte*  temp = NULL;


        /* some fonts define empty subr records -- this is not totally */
        /* compliant to the specification (which says they should at   */
        /* least contain a `return'), but we support them anyway       */
        if ( size < (FT_ULong)face->type1.private_dict.lenIV )
        {
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }

        /* t1_decrypt() shouldn't write to base -- make temporary copy */
        if ( FT_ALLOC( temp, size ) )
          goto Fail;
        FT_MEM_COPY( temp, base, size );
        psaux->t1_decrypt( temp, size, 4330 );
        size -= (FT_ULong)face->type1.private_dict.lenIV;
        error = T1_Add_Table( table, (FT_Int)idx,
                              temp + face->type1.private_dict.lenIV, size );
        FT_FREE( temp );
      }
      else
        error = T1_Add_Table( table, (FT_Int)idx, base, size );
      if ( error )
        goto Fail;
    }

    if ( !loader->num_subrs )
      loader->num_subrs = num_subrs;

    return;

  Fail:
    parser->root.error = error;
  }


#define TABLE_EXTEND  5


  static void
  parse_charstrings( T1_Face    face,
                     T1_Loader  loader )
  {
    T1_Parser      parser       = &loader->parser;
    PS_Table       code_table   = &loader->charstrings;
    PS_Table       name_table   = &loader->glyph_names;
    PS_Table       swap_table   = &loader->swap_table;
    FT_Memory      memory       = parser->root.memory;
    FT_Error       error;

    PSAux_Service  psaux        = (PSAux_Service)face->psaux;

    FT_Byte*       cur          = parser->root.cursor;
    FT_Byte*       limit        = parser->root.limit;
    FT_Int         n, num_glyphs;
    FT_Int         notdef_index = 0;
    FT_Byte        notdef_found = 0;


    num_glyphs = (FT_Int)T1_ToInt( parser );
    if ( num_glyphs < 0 )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Fail;
    }

    /* we certainly need more than 8 bytes per glyph */
    if ( num_glyphs > ( limit - cur ) >> 3 )
    {
      FT_TRACE0(( "parse_charstrings: adjusting number of glyphs"
                  " (from %d to %d)\n",
                  num_glyphs, ( limit - cur ) >> 3 ));
      num_glyphs = ( limit - cur ) >> 3;
    }

    /* some fonts like Optima-Oblique not only define the /CharStrings */
    /* array but access it also                                        */
    if ( num_glyphs == 0 || parser->root.error )
      return;

    /* initialize tables, leaving space for addition of .notdef, */
    /* if necessary, and a few other glyphs to handle buggy      */
    /* fonts which have more glyphs than specified.              */

    /* for some non-standard fonts like `Optima' which provides  */
    /* different outlines depending on the resolution it is      */
    /* possible to get here twice                                */
    if ( !loader->num_glyphs )
    {
      error = psaux->ps_table_funcs->init(
                code_table, num_glyphs + 1 + TABLE_EXTEND, memory );
      if ( error )
        goto Fail;

      error = psaux->ps_table_funcs->init(
                name_table, num_glyphs + 1 + TABLE_EXTEND, memory );
      if ( error )
        goto Fail;

      /* Initialize table for swapping index notdef_index and */
      /* index 0 names and codes (if necessary).              */

      error = psaux->ps_table_funcs->init( swap_table, 4, memory );
      if ( error )
        goto Fail;
    }

    n = 0;

    for (;;)
    {
      FT_ULong  size;
      FT_Byte*  base;


      /* the format is simple:        */
      /*   `/glyphname' + binary data */

      T1_Skip_Spaces( parser );

      cur = parser->root.cursor;
      if ( cur >= limit )
        break;

      /* we stop when we find a `def' or `end' keyword */
      if ( cur + 3 < limit && IS_PS_DELIM( cur[3] ) )
      {
        if ( cur[0] == 'd' &&
             cur[1] == 'e' &&
             cur[2] == 'f' )
        {
          /* There are fonts which have this: */
          /*                                  */
          /*   /CharStrings 118 dict def      */
          /*   Private begin                  */
          /*   CharStrings begin              */
          /*   ...                            */
          /*                                  */
          /* To catch this we ignore `def' if */
          /* no charstring has actually been  */
          /* seen.                            */
          if ( n )
            break;
        }

        if ( cur[0] == 'e' &&
             cur[1] == 'n' &&
             cur[2] == 'd' )
          break;
      }

      T1_Skip_PS_Token( parser );
      if ( parser->root.cursor >= limit )
      {
        error = FT_THROW( Invalid_File_Format );
        goto Fail;
      }
      if ( parser->root.error )
        return;

      if ( *cur == '/' )
      {
        FT_UInt  len;


        if ( cur + 2 >= limit )
        {
          error = FT_THROW( Invalid_File_Format );
          goto Fail;
        }

        cur++;                              /* skip `/' */
        len = (FT_UInt)( parser->root.cursor - cur );

        if ( !read_binary_data( parser, &size, &base, IS_INCREMENTAL ) )
          return;

        /* for some non-standard fonts like `Optima' which provides */
        /* different outlines depending on the resolution it is     */
        /* possible to get here twice                               */
        if ( loader->num_glyphs )
          continue;

        error = T1_Add_Table( name_table, n, cur, len + 1 );
        if ( error )
          goto Fail;

        /* add a trailing zero to the name table */
        name_table->elements[n][len] = '\0';

        /* record index of /.notdef */
        if ( *cur == '.'                                              &&
             ft_strcmp( ".notdef",
                        (const char*)(name_table->elements[n]) ) == 0 )
        {
          notdef_index = n;
          notdef_found = 1;
        }

        if ( face->type1.private_dict.lenIV >= 0 &&
             n < num_glyphs + TABLE_EXTEND       )
        {
          FT_Byte*  temp = NULL;


          if ( size <= (FT_ULong)face->type1.private_dict.lenIV )
          {
            error = FT_THROW( Invalid_File_Format );
            goto Fail;
          }

          /* t1_decrypt() shouldn't write to base -- make temporary copy */
          if ( FT_ALLOC( temp, size ) )
            goto Fail;
          FT_MEM_COPY( temp, base, size );
          psaux->t1_decrypt( temp, size, 4330 );
          size -= (FT_ULong)face->type1.private_dict.lenIV;
          error = T1_Add_Table( code_table, n,
                                temp + face->type1.private_dict.lenIV, size );
          FT_FREE( temp );
        }
        else
          error = T1_Add_Table( code_table, n, base, size );
        if ( error )
          goto Fail;

        n++;
      }
    }

    if ( !n )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Fail;
    }

    loader->num_glyphs = n;

    /* if /.notdef is found but does not occupy index 0, do our magic. */
    if ( notdef_found                                                 &&
         ft_strcmp( ".notdef", (const char*)name_table->elements[0] ) )
    {
      /* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
      /* name and code entries to swap_table.  Then place notdef_index   */
      /* name and code entries into swap_table.  Then swap name and code */
      /* entries at indices notdef_index and 0 using values stored in    */
      /* swap_table.                                                     */

      /* Index 0 name */
      error = T1_Add_Table( swap_table, 0,
                            name_table->elements[0],
                            name_table->lengths [0] );
      if ( error )
        goto Fail;

      /* Index 0 code */
      error = T1_Add_Table( swap_table, 1,
                            code_table->elements[0],
                            code_table->lengths [0] );
      if ( error )
        goto Fail;

      /* Index notdef_index name */
      error = T1_Add_Table( swap_table, 2,
                            name_table->elements[notdef_index],
                            name_table->lengths [notdef_index] );
      if ( error )
        goto Fail;

      /* Index notdef_index code */
      error = T1_Add_Table( swap_table, 3,
                            code_table->elements[notdef_index],
                            code_table->lengths [notdef_index] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( name_table, notdef_index,
                            swap_table->elements[0],
                            swap_table->lengths [0] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( code_table, notdef_index,
                            swap_table->elements[1],
                            swap_table->lengths [1] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( name_table, 0,
                            swap_table->elements[2],
                            swap_table->lengths [2] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( code_table, 0,
                            swap_table->elements[3],
                            swap_table->lengths [3] );
      if ( error )
        goto Fail;

    }
    else if ( !notdef_found )
    {
      /* notdef_index is already 0, or /.notdef is undefined in   */
      /* charstrings dictionary.  Worry about /.notdef undefined. */
      /* We take index 0 and add it to the end of the table(s)    */
      /* and add our own /.notdef glyph to index 0.               */

      /* 0 333 hsbw endchar */
      FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };
      char*    notdef_name    = (char *)".notdef";


      error = T1_Add_Table( swap_table, 0,
                            name_table->elements[0],
                            name_table->lengths [0] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( swap_table, 1,
                            code_table->elements[0],
                            code_table->lengths [0] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( name_table, 0, notdef_name, 8 );
      if ( error )
        goto Fail;

      error = T1_Add_Table( code_table, 0, notdef_glyph, 5 );

      if ( error )
        goto Fail;

      error = T1_Add_Table( name_table, n,
                            swap_table->elements[0],
                            swap_table->lengths [0] );
      if ( error )
        goto Fail;

      error = T1_Add_Table( code_table, n,
                            swap_table->elements[1],
                            swap_table->lengths [1] );
      if ( error )
        goto Fail;

      /* we added a glyph. */
      loader->num_glyphs += 1;
    }

    return;

  Fail:
    parser->root.error = error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* Define the token field static variables.  This is a set of            */
  /* T1_FieldRec variables.                                                */
  /*                                                                       */
  /*************************************************************************/


  static
  const T1_FieldRec  t1_keywords[] =
  {

#include "t1tokens.h"

    /* now add the special functions... */
    T1_FIELD_CALLBACK( "FontMatrix",           t1_parse_font_matrix,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Encoding",             parse_encoding,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Subrs",                parse_subrs,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "CharStrings",          parse_charstrings,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "Private",              parse_private,
                       T1_FIELD_DICT_FONTDICT )

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
    T1_FIELD_CALLBACK( "BlendDesignPositions", parse_blend_design_positions,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendDesignMap",       parse_blend_design_map,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendAxisTypes",       parse_blend_axis_types,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "WeightVector",         parse_weight_vector,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BuildCharArray",       parse_buildchar,
                       T1_FIELD_DICT_PRIVATE )
#endif

    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
  };


  static FT_Error
  parse_dict( T1_Face    face,
              T1_Loader  loader,
              FT_Byte*   base,
              FT_ULong   size )
  {
    T1_Parser  parser = &loader->parser;
    FT_Byte   *limit, *start_binary = NULL;
    FT_Bool    have_integer = 0;


    parser->root.cursor = base;
    parser->root.limit  = base + size;
    parser->root.error  = FT_Err_Ok;

    limit = parser->root.limit;

    T1_Skip_Spaces( parser );

    while ( parser->root.cursor < limit )
    {
      FT_Byte*  cur;


      cur = parser->root.cursor;

      /* look for `eexec' */
      if ( IS_PS_TOKEN( cur, limit, "eexec" ) )
        break;

      /* look for `closefile' which ends the eexec section */
      else if ( IS_PS_TOKEN( cur, limit, "closefile" ) )
        break;

      /* in a synthetic font the base font starts after a           */
      /* `FontDictionary' token that is placed after a Private dict */
      else if ( IS_PS_TOKEN( cur, limit, "FontDirectory" ) )
      {
        if ( loader->keywords_encountered & T1_PRIVATE )
          loader->keywords_encountered |=
            T1_FONTDIR_AFTER_PRIVATE;
        parser->root.cursor += 13;
      }

      /* check whether we have an integer */
      else if ( ft_isdigit( *cur ) )
      {
        start_binary = cur;
        T1_Skip_PS_Token( parser );
        if ( parser->root.error )
          goto Exit;
        have_integer = 1;
      }

      /* in valid Type 1 fonts we don't see `RD' or `-|' directly */
      /* since those tokens are handled by parse_subrs and        */
      /* parse_charstrings                                        */
      else if ( *cur == 'R' && cur + 6 < limit && *(cur + 1) == 'D' &&
                have_integer )
      {
        FT_ULong  s;
        FT_Byte*  b;


        parser->root.cursor = start_binary;
        if ( !read_binary_data( parser, &s, &b, IS_INCREMENTAL ) )
          return FT_THROW( Invalid_File_Format );
        have_integer = 0;
      }

      else if ( *cur == '-' && cur + 6 < limit && *(cur + 1) == '|' &&
                have_integer )
      {
        FT_ULong  s;
        FT_Byte*  b;


        parser->root.cursor = start_binary;
        if ( !read_binary_data( parser, &s, &b, IS_INCREMENTAL ) )
          return FT_THROW( Invalid_File_Format );
        have_integer = 0;
      }

      /* look for immediates */
      else if ( *cur == '/' && cur + 2 < limit )
      {
        FT_UInt  len;


        cur++;

        parser->root.cursor = cur;
        T1_Skip_PS_Token( parser );
        if ( parser->root.error )
          goto Exit;

        len = (FT_UInt)( parser->root.cursor - cur );

        if ( len > 0 && len < 22 && parser->root.cursor < limit )
        {
          /* now compare the immediate name to the keyword table */
          T1_Field  keyword = (T1_Field)t1_keywords;


          for (;;)
          {
            FT_Byte*  name;


            name = (FT_Byte*)keyword->ident;
            if ( !name )
              break;

            if ( cur[0] == name[0]                      &&
                 len == ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0       )
            {
              /* We found it -- run the parsing callback!     */
              /* We record every instance of every field      */
              /* (until we reach the base font of a           */
              /* synthetic font) to deal adequately with      */
              /* multiple master fonts; this is also          */
              /* necessary because later PostScript           */
              /* definitions override earlier ones.           */

              /* Once we encounter `FontDirectory' after      */
              /* `/Private', we know that this is a synthetic */
              /* font; except for `/CharStrings' we are not   */
              /* interested in anything that follows this     */
              /* `FontDirectory'.                             */

              /* MM fonts have more than one /Private token at */
              /* the top level; let's hope that all the junk   */
              /* that follows the first /Private token is not  */
              /* interesting to us.                            */

              /* According to Adobe Tech Note #5175 (CID-Keyed */
              /* Font Installation for ATM Software) a `begin' */
              /* must be followed by exactly one `end', and    */
              /* `begin' -- `end' pairs must be accurately     */
              /* paired.  We could use this to distinguish     */
              /* between the global Private and the Private    */
              /* dict that is a member of the Blend dict.      */

              const FT_UInt dict =
                ( loader->keywords_encountered & T1_PRIVATE )
                    ? T1_FIELD_DICT_PRIVATE
                    : T1_FIELD_DICT_FONTDICT;

              if ( !( dict & keyword->dict ) )
              {
                FT_TRACE1(( "parse_dict: found `%s' but ignoring it"
                            " since it is in the wrong dictionary\n",
                            keyword->ident ));
                break;
              }

              if ( !( loader->keywords_encountered &
                      T1_FONTDIR_AFTER_PRIVATE     )                  ||
                   ft_strcmp( (const char*)name, "CharStrings" ) == 0 )
              {
                parser->root.error = t1_load_keyword( face,
                                                      loader,
                                                      keyword );
                if ( parser->root.error )
                {
                  if ( FT_ERR_EQ( parser->root.error, Ignore ) )
                    parser->root.error = FT_Err_Ok;
                  else
                    return parser->root.error;
                }
              }
              break;
            }

            keyword++;
          }
        }

        have_integer = 0;
      }
      else
      {
        T1_Skip_PS_Token( parser );
        if ( parser->root.error )
          goto Exit;
        have_integer = 0;
      }

      T1_Skip_Spaces( parser );
    }

  Exit:
    return parser->root.error;
  }


  static void
  t1_init_loader( T1_Loader  loader,
                  T1_Face    face )
  {
    FT_UNUSED( face );

    FT_ZERO( loader );
  }


  static void
  t1_done_loader( T1_Loader  loader )
  {
    T1_Parser  parser = &loader->parser;
    FT_Memory  memory = parser->root.memory;


    /* finalize tables */
    T1_Release_Table( &loader->encoding_table );
    T1_Release_Table( &loader->charstrings );
    T1_Release_Table( &loader->glyph_names );
    T1_Release_Table( &loader->swap_table );
    T1_Release_Table( &loader->subrs );

    /* finalize hash */
    ft_hash_num_free( loader->subrs_hash, memory );
    FT_FREE( loader->subrs_hash );

    /* finalize parser */
    T1_Finalize_Parser( parser );
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Open_Face( T1_Face  face )
  {
    T1_LoaderRec   loader;
    T1_Parser      parser;
    T1_Font        type1 = &face->type1;
    PS_Private     priv  = &type1->private_dict;
    FT_Error       error;

    PSAux_Service  psaux = (PSAux_Service)face->psaux;


    t1_init_loader( &loader, face );

    /* default values */
    face->ndv_idx          = -1;
    face->cdv_idx          = -1;
    face->len_buildchar    = 0;

    priv->blue_shift       = 7;
    priv->blue_fuzz        = 1;
    priv->lenIV            = 4;
    priv->expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
    priv->blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );

    parser = &loader.parser;
    error  = T1_New_Parser( parser,
                            face->root.stream,
                            face->root.memory,
                            psaux );
    if ( error )
      goto Exit;

    error = parse_dict( face, &loader,
                        parser->base_dict, parser->base_len );
    if ( error )
      goto Exit;

    error = T1_Get_Private_Dict( parser, psaux );
    if ( error )
      goto Exit;

    error = parse_dict( face, &loader,
                        parser->private_dict, parser->private_len );
    if ( error )
      goto Exit;

    /* ensure even-ness of `num_blue_values' */
    priv->num_blue_values &= ~1;

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT

    if ( face->blend                                                     &&
         face->blend->num_default_design_vector != 0                     &&
         face->blend->num_default_design_vector != face->blend->num_axis )
    {
      /* we don't use it currently so just warn, reset, and ignore */
      FT_ERROR(( "T1_Open_Face(): /DesignVector contains %u entries "
                 "while there are %u axes.\n",
                 face->blend->num_default_design_vector,
                 face->blend->num_axis ));

      face->blend->num_default_design_vector = 0;
    }

    /* the following can happen for MM instances; we then treat the */
    /* font as a normal PS font                                     */
    if ( face->blend                                             &&
         ( !face->blend->num_designs || !face->blend->num_axis ) )
      T1_Done_Blend( face );

    /* another safety check */
    if ( face->blend )
    {
      FT_UInt  i;


      for ( i = 0; i < face->blend->num_axis; i++ )
        if ( !face->blend->design_map[i].num_points )
        {
          T1_Done_Blend( face );
          break;
        }
    }

    if ( face->blend )
    {
      if ( face->len_buildchar > 0 )
      {
        FT_Memory  memory = face->root.memory;


        if ( FT_NEW_ARRAY( face->buildchar, face->len_buildchar ) )
        {
          FT_ERROR(( "T1_Open_Face: cannot allocate BuildCharArray\n" ));
          face->len_buildchar = 0;
          goto Exit;
        }
      }
    }
    else
      face->len_buildchar = 0;

#endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */

    /* now, propagate the subrs, charstrings, and glyphnames tables */
    /* to the Type1 data                                            */
    type1->num_glyphs = loader.num_glyphs;

    if ( loader.subrs.init )
    {
      type1->num_subrs   = loader.num_subrs;
      type1->subrs_block = loader.subrs.block;
      type1->subrs       = loader.subrs.elements;
      type1->subrs_len   = loader.subrs.lengths;
      type1->subrs_hash  = loader.subrs_hash;

      /* prevent `t1_done_loader' from freeing the propagated data */
      loader.subrs.init = 0;
      loader.subrs_hash = NULL;
    }

    if ( !IS_INCREMENTAL )
      if ( !loader.charstrings.init )
      {
        FT_ERROR(( "T1_Open_Face: no `/CharStrings' array in face\n" ));
        error = FT_THROW( Invalid_File_Format );
      }

    loader.charstrings.init  = 0;
    type1->charstrings_block = loader.charstrings.block;
    type1->charstrings       = loader.charstrings.elements;
    type1->charstrings_len   = loader.charstrings.lengths;

    /* we copy the glyph names `block' and `elements' fields; */
    /* the `lengths' field must be released later             */
    type1->glyph_names_block    = loader.glyph_names.block;
    type1->glyph_names          = (FT_String**)loader.glyph_names.elements;
    loader.glyph_names.block    = NULL;
    loader.glyph_names.elements = NULL;

    /* we must now build type1.encoding when we have a custom array */
    if ( type1->encoding_type == T1_ENCODING_TYPE_ARRAY )
    {
      FT_Int    charcode, idx, min_char, max_char;
      FT_Byte*  glyph_name;


      /* OK, we do the following: for each element in the encoding  */
      /* table, look up the index of the glyph having the same name */
      /* the index is then stored in type1.encoding.char_index, and */
      /* the name to type1.encoding.char_name                       */

      min_char = 0;
      max_char = 0;

      charcode = 0;
      for ( ; charcode < loader.encoding_table.max_elems; charcode++ )
      {
        FT_Byte*  char_name;


        type1->encoding.char_index[charcode] = 0;
        type1->encoding.char_name [charcode] = (char *)".notdef";

        char_name = loader.encoding_table.elements[charcode];
        if ( char_name )
          for ( idx = 0; idx < type1->num_glyphs; idx++ )
          {
            glyph_name = (FT_Byte*)type1->glyph_names[idx];
            if ( ft_strcmp( (const char*)char_name,
                            (const char*)glyph_name ) == 0 )
            {
              type1->encoding.char_index[charcode] = (FT_UShort)idx;
              type1->encoding.char_name [charcode] = (char*)glyph_name;

              /* Change min/max encoded char only if glyph name is */
              /* not /.notdef                                      */
              if ( ft_strcmp( (const char*)".notdef",
                              (const char*)glyph_name ) != 0 )
              {
                if ( charcode < min_char )
                  min_char = charcode;
                if ( charcode >= max_char )
                  max_char = charcode + 1;
              }
              break;
            }
          }
      }

      type1->encoding.code_first = min_char;
      type1->encoding.code_last  = max_char;
      type1->encoding.num_chars  = loader.num_chars;
    }

  Exit:
    t1_done_loader( &loader );
    return error;
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
d69 1
d75 7
d110 1
a110 1
    FT_Error   error  = T1_Err_Ok;
d134 2
a135 2
             FT_NEW_ARRAY( blend->privates[1], num_designs       ) ||
             FT_NEW_ARRAY( blend->bboxes[1], num_designs         ) ||
a146 1
          blend->privates[nn]   = blend->privates  [nn - 1] + 1;
d148 2
a149 1
          blend->bboxes[nn]     = blend->bboxes    [nn - 1] + 1;
d152 1
a152 1
        blend->num_designs   = num_designs;
d186 1
a186 1
    error = T1_Err_Invalid_File_Format;
d200 1
a200 1
    error = T1_Err_Invalid_Argument;
d218 1
a218 1
      error = T1_Err_Ok;
d230 1
a230 1
  FT_LOCAL_DEF( FT_Fixed )
d240 1
a240 1
    for ( j = 1; j < axismap->num_points; ++j )
a242 6
      {
        FT_Fixed  t = FT_MulDiv( ncv - axismap->blend_points[j - 1],
                                 0x10000L,
                                 axismap->blend_points[j] -
                                   axismap->blend_points[j - 1] );

d244 4
a247 5
                 FT_MulDiv( t,
                            axismap->design_points[j] -
                              axismap->design_points[j - 1],
                            1L );
      }
d259 1
a259 1
  FT_LOCAL_DEF( void )
d306 1
a306 1
    FT_MM_Var       *mmvar;
d324 1
a324 1
    mmvar->num_namedstyles = (FT_UInt)-1;                /* Does not apply */
d329 1
a329 1
    for ( i = 0 ; i < mmaster.num_axis; ++i )
d337 5
a341 2
      mmvar->axis[i].strid   = (FT_UInt)-1;    /* Does not apply */
      mmvar->axis[i].tag     = (FT_ULong)-1;   /* Does not apply */
d357 1
a357 1
      for ( i = 0; i < mmaster.num_axis; ++i )
a374 1
    FT_Error  error;
d378 2
a379 1
    error = T1_Err_Invalid_Argument;
d381 5
a385 1
    if ( blend && blend->num_axis == num_coords )
d387 2
a388 2
      /* recompute the weight vector from the blend coordinates */
      error = T1_Err_Ok;
d390 1
a390 1
      for ( n = 0; n < blend->num_designs; n++ )
d392 1
a392 1
        FT_Fixed  result = 0x10000L;  /* 1.0 fixed */
d395 26
a420 3
        for ( m = 0; m < blend->num_axis; m++ )
        {
          FT_Fixed  factor;
d422 2
a424 4
          /* get current blend axis position */
          factor = coords[m];
          if ( factor < 0 )        factor = 0;
          if ( factor > 0x10000L ) factor = 0x10000L;
d426 2
a427 2
          if ( ( n & ( 1 << m ) ) == 0 )
            factor = 0x10000L - factor;
d429 3
a431 4
          result = FT_MulFix( result, factor );
        }
        blend->weight_vector[n] = result;
      }
d433 6
a438 1
      error = T1_Err_Ok;
d441 6
a446 1
    return error;
a455 1
    FT_Error  error;
d457 5
d463 2
d466 3
a468 2
    error = T1_Err_Invalid_Argument;
    if ( blend && blend->num_axis == num_coords )
d470 7
a476 2
      /* compute the blend coordinates through the blend design map */
      FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];
d478 5
d484 1
a484 1
      for ( n = 0; n < blend->num_axis; n++ )
d486 1
a486 6
        FT_Long       design  = coords[n];
        FT_Fixed      the_blend;
        PS_DesignMap  map     = blend->design_map + n;
        FT_Long*      designs = map->design_points;
        FT_Fixed*     blends  = map->blend_points;
        FT_Int        before  = -1, after = -1;
d489 2
a490 1
        for ( p = 0; p < (FT_UInt)map->num_points; p++ )
d492 3
a494 1
          FT_Long  p_design = designs[p];
d496 4
a499 15

          /* exact match? */
          if ( design == p_design )
          {
            the_blend = blends[p];
            goto Found;
          }

          if ( design < p_design )
          {
            after = p;
            break;
          }

          before = p;
d502 2
a503 3
        /* now interpolate if necessary */
        if ( before < 0 )
          the_blend = blends[0];
d505 3
a507 2
        else if ( after < 0 )
          the_blend = blends[map->num_points - 1];
d509 2
a510 4
        else
          the_blend = FT_MulDiv( design         - designs[before],
                                 blends [after] - blends [before],
                                 designs[after] - designs[before] );
d512 4
a515 3
      Found:
        final_blends[n] = the_blend;
      }
d517 2
a518 1
      error = T1_Set_MM_Blend( face, num_coords, final_blends );
d521 1
a521 1
    return error;
d535 2
a536 3
     FT_Long   lcoords[4];          /* maximum axis count is 4 */
     FT_UInt   i;
     FT_Error  error;
d539 41
a579 7
     error = T1_Err_Invalid_Argument;
     if ( num_coords <= 4 && num_coords > 0 )
     {
       for ( i = 0; i < num_coords; ++i )
         lcoords[i] = FIXED_TO_INT( coords[i] );
       error = T1_Set_MM_Design( face, num_coords, lcoords );
     }
d581 1
a581 1
     return error;
d602 1
a602 1
        blend->design_pos[n] = 0;
d611 3
a613 3
        blend->privates  [n] = 0;
        blend->font_infos[n] = 0;
        blend->bboxes    [n] = 0;
d618 1
a618 1
      blend->default_weight_vector = 0;
d645 1
a645 1
    FT_Error     error = T1_Err_Ok;
d655 1
a655 1
      error = T1_Err_Ignore;
d662 1
a662 1
      error = T1_Err_Invalid_File_Format;
d677 3
a679 3
      T1_Token    token = axis_tokens + n;
      FT_Byte*    name;
      FT_PtrDist  len;
d686 1
a686 1
      len = token->limit - token->start;
d689 1
a689 1
        error = T1_Err_Invalid_File_Format;
d693 9
d707 1
a707 1
      name[len] = 0;
d724 1
a724 1
    FT_Error     error = T1_Err_Ok;
d733 1
a733 1
      error = T1_Err_Ignore;
d741 1
a741 1
      error = T1_Err_Invalid_File_Format;
d774 1
a774 1
            error = T1_Err_Invalid_File_Format;
d779 3
a781 1
          error = t1_allocate_blend( face, num_designs, num_axis );
d789 1
a789 1
          error = T1_Err_Invalid_File_Format;
d818 1
a818 1
    FT_Error     error  = T1_Err_Ok;
d832 1
a832 1
      error = T1_Err_Ignore;
d839 1
a839 1
      error = T1_Err_Invalid_File_Format;
d846 1
a846 1
    error = t1_allocate_blend( face, 0, num_axis );
d870 8
a877 1
        error = T1_Err_Invalid_File_Format;
d917 1
a917 1
    FT_Error     error  = T1_Err_Ok;
d930 1
a930 1
      error = T1_Err_Ignore;
d938 1
a938 1
      error = T1_Err_Invalid_File_Format;
d944 1
a944 1
      error = t1_allocate_blend( face, num_designs, 0 );
d955 1
a955 1
      error = T1_Err_Invalid_File_Format;
d986 2
a987 2
    face->len_buildchar = T1_ToFixedArray( &loader->parser, 0, NULL, 0 );

d992 1
a992 1
#endif /* T1_CONFIG_OPTION_NO_MM_SUPPORT */
d1017 3
d1100 10
a1109 4
    if ( field->type == T1_FIELD_TYPE_INTEGER_ARRAY ||
         field->type == T1_FIELD_TYPE_FIXED_ARRAY   )
      error = T1_Load_Field_Table( &loader->parser, field,
                                   objects, max_objects, 0 );
d1111 7
a1117 2
      error = T1_Load_Field( &loader->parser, field,
                             objects, max_objects, 0 );
d1134 2
d1138 3
a1140 2
                    FT_Long*   size,
                    FT_Byte**  base )
d1158 2
a1159 1
      *size = T1_ToInt( parser );
d1167 12
a1178 2
      parser->root.cursor += *size + 1;
      return !parser->root.error;
a1180 2
    FT_ERROR(( "read_binary_data: invalid size field\n" ));
    parser->root.error = T1_Err_Invalid_File_Format;
d1189 2
a1190 2
  parse_font_matrix( T1_Face    face,
                     T1_Loader  loader )
d1201 1
d1204 1
a1204 1
    if ( result < 0 )
d1206 1
a1206 1
      parser->root.error = T1_Err_Invalid_File_Format;
d1214 2
a1215 2
      FT_ERROR(( "parse_font_matrix: invalid font matrix\n" ));
      parser->root.error = T1_Err_Invalid_File_Format;
d1219 1
a1219 8
    /* Set Units per EM based on FontMatrix values.  We set the value to */
    /* 1000 / temp_scale, because temp_scale was already multiplied by   */
    /* 1000 (in t1_tofixed, from psobjs.c).                              */

    root->units_per_EM = (FT_UShort)( FT_DivFix( 1000 * 0x10000L,
                                                 temp_scale ) >> 16 );

    /* we need to scale the values by 1.0/temp_scale */
d1222 3
d1230 1
a1230 1
      temp[3] = 0x10000L;
d1260 1
a1260 1
      parser->root.error = T1_Err_Invalid_File_Format;
d1286 9
d1299 8
d1324 1
a1324 1
        T1_Add_Table( char_table, n, notdef, 8 );
d1385 7
d1396 1
a1396 1
          if ( *cur == '/' && cur + 2 < limit && n < count )
d1398 1
a1398 1
            FT_PtrDist  len;
d1405 2
d1410 1
a1410 1
            len = parser->root.cursor - cur;
d1430 1
a1430 1
            parser->root.error = FT_Err_Unknown_File_Format;
d1465 1
a1465 1
        parser->root.error = T1_Err_Ignore;
d1479 1
d1494 1
a1494 1
        parser->root.error = T1_Err_Invalid_File_Format;
d1499 41
d1560 1
a1560 1
    for (;;)
d1562 2
a1563 1
      FT_Long   idx, size;
d1567 4
a1570 2
      /* If the next token isn't `dup' we are done. */
      if ( ft_strncmp( (char*)parser->root.cursor, "dup", 3 ) != 0 )
d1577 1
a1577 1
      if ( !read_binary_data( parser, &size, &base ) )
d1589 2
a1590 1
      if ( ft_strncmp( (char*)parser->root.cursor, "put", 3 ) == 0 )
d1596 8
d1615 1
a1615 1
        FT_Byte*  temp;
d1621 1
a1621 1
        if ( size < face->type1.private_dict.lenIV )
d1623 1
a1623 1
          error = T1_Err_Invalid_File_Format;
d1632 1
a1632 1
        size -= face->type1.private_dict.lenIV;
d1669 1
a1669 1
    FT_Byte*       cur;
d1672 1
a1672 1
    FT_UInt        notdef_index = 0;
d1677 15
d1728 1
a1728 1
      FT_Long   size;
d1769 5
d1779 1
a1779 1
        FT_PtrDist  len;
d1782 1
a1782 1
        if ( cur + 1 >= limit )
d1784 1
a1784 1
          error = T1_Err_Invalid_File_Format;
d1789 1
a1789 1
        len = parser->root.cursor - cur;
d1791 1
a1791 1
        if ( !read_binary_data( parser, &size, &base ) )
d1819 1
a1819 1
          FT_Byte*  temp;
d1822 1
a1822 1
          if ( size <= face->type1.private_dict.lenIV )
d1824 1
a1824 1
            error = T1_Err_Invalid_File_Format;
d1833 1
a1833 1
          size -= face->type1.private_dict.lenIV;
d1847 6
d1989 1
a1989 1
    T1_FIELD_CALLBACK( "FontMatrix",           parse_font_matrix,
a2016 4
#define T1_FIELD_COUNT                                           \
          ( sizeof ( t1_keywords ) / sizeof ( t1_keywords[0] ) )


d2021 1
a2021 1
              FT_Long    size )
d2030 1
a2030 1
    parser->root.error  = T1_Err_Ok;
d2077 1
a2077 1
        FT_Long   s;
d2082 2
a2083 2
        if ( !read_binary_data( parser, &s, &b ) )
          return T1_Err_Invalid_File_Format;
d2090 1
a2090 1
        FT_Long   s;
d2095 2
a2096 2
        if ( !read_binary_data( parser, &s, &b ) )
          return T1_Err_Invalid_File_Format;
d2103 1
a2103 1
        FT_PtrDist  len;
d2113 1
a2113 1
        len = parser->root.cursor - cur;
d2130 3
a2132 3
            if ( cur[0] == name[0]                                  &&
                 len == (FT_PtrDist)ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0                   )
d2168 2
a2169 2
                FT_TRACE1(( "parse_dict: found %s but ignoring it "
                            "since it is in the wrong dictionary\n",
d2181 1
a2181 1
                if ( parser->root.error != T1_Err_Ok )
d2183 2
a2184 2
                  if ( FT_ERROR_BASE( parser->root.error ) == FT_Err_Ignore )
                    parser->root.error = T1_Err_Ok;
d2220 1
a2220 12
    FT_MEM_ZERO( loader, sizeof ( *loader ) );
    loader->num_glyphs = 0;
    loader->num_chars  = 0;

    /* initialize the tables -- simply set their `init' field to 0 */
    loader->encoding_table.init  = 0;
    loader->charstrings.init     = 0;
    loader->glyph_names.init     = 0;
    loader->subrs.init           = 0;
    loader->swap_table.init      = 0;
    loader->fontdata             = 0;
    loader->keywords_encountered = 0;
d2228 1
d2238 4
d2347 2
d2350 1
a2350 1
#endif /* T1_CONFIG_OPTION_NO_MM_SUPPORT */
a2357 1
      loader.subrs.init  = 0;
d2362 5
d2369 1
a2369 3
#ifdef FT_CONFIG_OPTION_INCREMENTAL
    if ( !face->root.internal->incremental_interface )
#endif
d2373 1
a2373 1
        error = T1_Err_Invalid_File_Format;
d2385 2
a2386 2
    loader.glyph_names.block    = 0;
    loader.glyph_names.elements = 0;
a2391 1
      FT_Byte*  char_name;
d2398 1
a2398 1
      /* a the name to type1.encoding.char_name                     */
d2406 3
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d68 1
a216 4
#define FT_INT_TO_FIXED( a )  ( (a) << 16 )
#define FT_FIXED_TO_INT( a )  ( FT_RoundFix( a ) >> 16 )


d230 1
a230 1
      return axismap->design_points[0];
d241 1
a241 2

        return axismap->design_points[j - 1] +
d249 1
a249 1
    return axismap->design_points[axismap->num_points - 1];
d331 2
a332 2
      mmvar->axis[i].minimum = FT_INT_TO_FIXED( mmaster.axis[i].minimum);
      mmvar->axis[i].maximum = FT_INT_TO_FIXED( mmaster.axis[i].maximum);
d336 2
a337 2
      mmvar->axis[i].strid   = 0xFFFFFFFFUL;   /* Does not apply */
      mmvar->axis[i].tag     = 0xFFFFFFFFUL;   /* Does not apply */
d347 1
a347 1
    if ( blend->num_designs == 1U << blend->num_axis )
d354 2
a355 3
        mmvar->axis[i].def =
          FT_INT_TO_FIXED( mm_axis_unmap( &blend->design_map[i],
                                          axiscoords[i] ) );
d502 1
a502 1
         lcoords[i] = FT_FIXED_TO_INT( coords[i] );
d654 2
a655 2
      FT_ERROR(( "parse_blend_design_positions:" ));
      FT_ERROR(( " incorrect number of designs: %d\n",
d687 2
a688 2
            FT_ERROR(( "parse_blend_design_positions:" ));
            FT_ERROR(( "  invalid number of axes: %d\n",
d842 2
a843 2
      FT_ERROR(( "parse_weight_vector:" ));
      FT_ERROR(( " incorrect number of designs: %d\n",
d859 3
a861 3
                 " /BlendDesignPosition and /WeightVector have\n" ));
      FT_ERROR(( "                    "
                 " different number of elements!\n" ));
d948 6
d1143 1
a1143 1
      FT_ERROR(( "parse_encoding: out of bounds!\n" ));
d1278 13
d1336 1
a1336 1
    FT_Int     n, num_subrs;
d1338 1
a1338 1
    PSAux_Service  psaux  = (PSAux_Service)face->psaux;
d1372 5
a1376 5
    /* the format is simple:                                 */
    /*                                                       */
    /*   `index' + binary data                               */
    /*                                                       */
    for ( n = 0; n < num_subrs; n++ )
d1382 1
a1382 2
      /* If the next token isn't `dup', we are also done.  This */
      /* happens when there are `holes' in the Subrs array.     */
d1631 1
a1631 4
    if ( loader->num_glyphs )
      return;
    else
      loader->num_glyphs = n;
d1634 2
a1635 3
    if ( ft_strcmp( (const char*)".notdef",
                    (const char*)name_table->elements[0] ) &&
         notdef_found                                      )
d1704 1
a1704 1
      FT_Byte  notdef_glyph[] = {0x8B, 0xF7, 0xE1, 0x0D, 0x0E};
d1742 1
a1742 1
      loader->num_glyphs = n + 1;
d2156 1
a2156 1
        FT_ERROR(( "T1_Open_Face: no `/CharStrings' array in face!\n" ));
d2185 2
a2186 2
      min_char = +32000;
      max_char = -32000;
d2212 2
a2213 2
                if ( charcode > max_char )
                  max_char = charcode;
a2219 11
      /*
       *  Yes, this happens: Certain PDF-embedded fonts have only a
       *  `.notdef' glyph defined!
       */

      if ( min_char > max_char )
      {
        min_char = 0;
        max_char = loader.encoding_table.max_elems;
      }

@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
d677 1
a677 1
        T1_TokenRec  axis_tokens[T1_MAX_MM_DESIGNS];
d690 9
d1409 4
a1412 1
        if ( size <= face->type1.private_dict.lenIV )
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
d110 2
d247 1
a247 1
                            axismap->design_points[j] - 
d358 3
a360 2
        mmvar->axis[i].def = mm_axis_unmap( &blend->design_map[i],
                                            axiscoords[i] );
d738 1
a738 1
    T1_ToTokenArray( parser, axis_tokens, 
d883 12
d968 20
d1007 3
a1009 2
  static int
  is_space( FT_Byte  c )
d1011 3
a1013 3
    return ( c == ' '  || c == '\t'              ||
             c == '\r' || c == '\n' || c == '\f' ||
             c == '\0'                           );
d1069 1
d1072 7
a1078 1
    (void)T1_ToFixedArray( parser, 6, temp, 3 );
d1082 7
d1214 3
a1216 3
          if ( cur[1] == 'e'      &&
               cur[2] == 'f'      &&
               is_space( cur[3] ) )
d1270 1
d1272 3
d1400 6
d1506 1
a1506 1
      if ( cur + 3 < limit && is_space( cur[3] ) )
d1575 2
a1576 2
        if ( face->type1.private_dict.lenIV >= 0   &&
             n < num_glyphs + TABLE_EXTEND )
d1581 6
d1746 10
a1755 4
    T1_FIELD_CALLBACK( "FontMatrix", parse_font_matrix )
    T1_FIELD_CALLBACK( "Encoding", parse_encoding )
    T1_FIELD_CALLBACK( "Subrs", parse_subrs )
    T1_FIELD_CALLBACK( "CharStrings", parse_charstrings )
d1758 10
a1767 4
    T1_FIELD_CALLBACK( "BlendDesignPositions", parse_blend_design_positions )
    T1_FIELD_CALLBACK( "BlendDesignMap", parse_blend_design_map )
    T1_FIELD_CALLBACK( "BlendAxisTypes", parse_blend_axis_types )
    T1_FIELD_CALLBACK( "WeightVector", parse_weight_vector )
d1770 1
a1770 1
    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0 }
d1782 1
a1782 2
              FT_Long    size,
              FT_Byte*   keyword_flags )
a1803 43
      /* look for `FontDirectory' which causes problems for some fonts */
      if ( *cur == 'F' && cur + 25 < limit                    &&
           ft_strncmp( (char*)cur, "FontDirectory", 13 ) == 0 )
      {
        FT_Byte*  cur2;


        /* skip the `FontDirectory' keyword */
        T1_Skip_PS_Token( parser );
        T1_Skip_Spaces  ( parser );
        cur = cur2 = parser->root.cursor;

        /* look up the `known' keyword */
        while ( cur < limit )
        {
          if ( *cur == 'k' && cur + 5 < limit            &&
               ft_strncmp( (char*)cur, "known", 5 ) == 0 )
            break;

          T1_Skip_PS_Token( parser );
          if ( parser->root.error )
            goto Exit;
          T1_Skip_Spaces( parser );
          cur = parser->root.cursor;
        }

        if ( cur < limit )
        {
          T1_TokenRec  token;


          /* skip the `known' keyword and the token following it */
          T1_Skip_PS_Token( parser );
          T1_ToToken( parser, &token );

          /* if the last token was an array, skip it! */
          if ( token.type == T1_TOKEN_TYPE_ARRAY )
            cur2 = parser->root.cursor;
        }
        parser->root.cursor = cur2;
        have_integer = 0;
      }

d1805 1
a1805 2
      else if ( *cur == 'e' && cur + 5 < limit &&
                ft_strncmp( (char*)cur, "eexec", 5 ) == 0 )
d1809 1
a1809 2
      else if ( *cur == 'c' && cur + 9 < limit &&
                ft_strncmp( (char*)cur, "closefile", 9 ) == 0 )
d1812 10
d1879 1
a1879 2
          T1_Field  keyword      = (T1_Field)t1_keywords;
          FT_Byte*  keyword_flag = keyword_flags;
d1895 42
a1936 7
              /* We found it -- run the parsing callback! */
              /* We only record the first instance of any */
              /* field to deal adequately with synthetic  */
              /* fonts; /Subrs and /CharStrings are       */
              /* handled specially.                       */
              if ( keyword_flag[0] == 0                               ||
                   ft_strcmp( (const char*)name, "Subrs" ) == 0       ||
d1942 1
a1942 3
                if ( parser->root.error == T1_Err_Ok )
                  keyword_flag[0] = 1;
                else
a1953 1
            keyword_flag++;
d1986 7
a1992 6
    loader->encoding_table.init = 0;
    loader->charstrings.init    = 0;
    loader->glyph_names.init    = 0;
    loader->subrs.init          = 0;
    loader->swap_table.init     = 0;
    loader->fontdata            = 0;
a2021 1
    FT_Byte        keyword_flags[T1_FIELD_COUNT];
d2029 4
d2047 2
a2048 10
    {
      FT_UInt  n;
      

      for ( n = 0; n < T1_FIELD_COUNT; n++ )
        keyword_flags[n] = 0;
    }

    error = parse_dict( face, &loader, parser->base_dict, parser->base_len,
                        keyword_flags );
d2056 2
a2057 3
    error = parse_dict( face, &loader, parser->private_dict,
                        parser->private_len,
                        keyword_flags );
d2060 1
a2060 1
 
d2066 13
d2099 16
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
d214 153
d436 1
a436 1
        FT_Fixed*     designs = map->design_points;
d443 1
a443 1
          FT_Fixed  p_design = designs[p];
d485 27
d1011 1
a1011 1
      return 1;
d1205 2
d1282 3
a1284 1
    T1_Skip_Spaces  ( parser );
d1322 2
d1451 14
a1464 1
          break;
d1473 2
d1747 3
a1749 1
          T1_Skip_Spaces  ( parser );
d1785 2
d1829 2
d1850 3
a1852 3
            if ( cur[0] == name[0]                      &&
                 len == ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0       )
d1859 3
a1861 3
              if ( keyword_flag[0] == 0                              ||
                   ft_strcmp( (const char*)name, "Subrs" ) == 0      ||
                   ft_strcmp( (const char*)name, "CharStrings") == 0 )
d1992 3
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007 by             */
a109 2
      blend->num_default_design_vector = 0;

a213 154
#define FT_INT_TO_FIXED( a )  ( (a) << 16 )
#define FT_FIXED_TO_INT( a )  ( FT_RoundFix( a ) >> 16 )


  /*************************************************************************/
  /*                                                                       */
  /* Given a normalized (blend) coordinate, figure out the design          */
  /* coordinate appropriate for that value.                                */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Fixed )
  mm_axis_unmap( PS_DesignMap  axismap,
                 FT_Fixed      ncv )
  {
    int  j;


    if ( ncv <= axismap->blend_points[0] )
      return axismap->design_points[0];

    for ( j = 1; j < axismap->num_points; ++j )
    {
      if ( ncv <= axismap->blend_points[j] )
      {
        FT_Fixed  t = FT_MulDiv( ncv - axismap->blend_points[j - 1],
                                 0x10000L,
                                 axismap->blend_points[j] -
                                   axismap->blend_points[j - 1] );


        return axismap->design_points[j - 1] +
                 FT_MulDiv( t,
                            axismap->design_points[j] -
                              axismap->design_points[j - 1],
                            1L );
      }
    }

    return axismap->design_points[axismap->num_points - 1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* Given a vector of weights, one for each design, figure out the        */
  /* normalized axis coordinates which gave rise to those weights.         */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  mm_weights_unmap( FT_Fixed*  weights,
                    FT_Fixed*  axiscoords,
                    FT_UInt    axis_count )
  {
    FT_ASSERT( axis_count <= T1_MAX_MM_AXIS );

    if ( axis_count == 1 )
      axiscoords[0] = weights[1];

    else if ( axis_count == 2 )
    {
      axiscoords[0] = weights[3] + weights[1];
      axiscoords[1] = weights[3] + weights[2];
    }

    else if ( axis_count == 3 )
    {
      axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
    }

    else
    {
      axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
                        weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
                        weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[7] + weights[6] + weights[5] + weights[4];
      axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[11] + weights[10] + weights[9] + weights[8];
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Get_Multi_Master to support the different    */
  /*  arguments needed by the GX var distortable fonts.                    */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Get_MM_Var( T1_Face      face,
                 FT_MM_Var*  *master )
  {
    FT_Memory        memory = face->root.memory;
    FT_MM_Var       *mmvar;
    FT_Multi_Master  mmaster;
    FT_Error         error;
    FT_UInt          i;
    FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
    PS_Blend         blend = face->blend;


    error = T1_Get_Multi_Master( face, &mmaster );
    if ( error )
      goto Exit;
    if ( FT_ALLOC( mmvar,
                   sizeof ( FT_MM_Var ) +
                     mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
      goto Exit;

    mmvar->num_axis        = mmaster.num_axis;
    mmvar->num_designs     = mmaster.num_designs;
    mmvar->num_namedstyles = (FT_UInt)-1;                /* Does not apply */
    mmvar->axis            = (FT_Var_Axis*)&mmvar[1];
                                      /* Point to axes after MM_Var struct */
    mmvar->namedstyle      = NULL;

    for ( i = 0 ; i < mmaster.num_axis; ++i )
    {
      mmvar->axis[i].name    = mmaster.axis[i].name;
      mmvar->axis[i].minimum = FT_INT_TO_FIXED( mmaster.axis[i].minimum);
      mmvar->axis[i].maximum = FT_INT_TO_FIXED( mmaster.axis[i].maximum);
      mmvar->axis[i].def     = ( mmvar->axis[i].minimum +
                                   mmvar->axis[i].maximum ) / 2;
                            /* Does not apply.  But this value is in range */
      mmvar->axis[i].strid   = 0xFFFFFFFFUL;   /* Does not apply */
      mmvar->axis[i].tag     = 0xFFFFFFFFUL;   /* Does not apply */

      if ( ft_strcmp( mmvar->axis[i].name, "Weight" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'g', 'h', 't' );
      else if ( ft_strcmp( mmvar->axis[i].name, "Width" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'd', 't', 'h' );
      else if ( ft_strcmp( mmvar->axis[i].name, "OpticalSize" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'o', 'p', 's', 'z' );
    }

    if ( blend->num_designs == 1U << blend->num_axis )
    {
      mm_weights_unmap( blend->default_weight_vector,
                        axiscoords,
                        blend->num_axis );

      for ( i = 0; i < mmaster.num_axis; ++i )
        mmvar->axis[i].def =
          FT_INT_TO_FIXED( mm_axis_unmap( &blend->design_map[i],
                                          axiscoords[i] ) );
    }

    *master = mmvar;

  Exit:
    return error;
  }


d283 1
a283 1
        FT_Long*      designs = map->design_points;
d290 1
a290 1
          FT_Long  p_design = designs[p];
a331 27
  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Set_MM_Design to support the different       */
  /* arguments needed by the GX var distortable fonts.                     */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Set_Var_Design( T1_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
  {
     FT_Long   lcoords[4];          /* maximum axis count is 4 */
     FT_UInt   i;
     FT_Error  error;


     error = T1_Err_Invalid_Argument;
     if ( num_coords <= 4 && num_coords > 0 )
     {
       for ( i = 0; i < num_coords; ++i )
         lcoords[i] = FT_FIXED_TO_INT( coords[i] );
       error = T1_Set_MM_Design( face, num_coords, lcoords );
     }

     return error;
  }


d555 1
a555 1
    T1_ToTokenArray( parser, axis_tokens,
a699 12
  /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
  /* we're only interested in the number of array elements */
  static void
  parse_buildchar( T1_Face    face,
                   T1_Loader  loader )
  {
    face->len_buildchar = T1_ToFixedArray( &loader->parser, 0, NULL, 0 );

    return;
  }


a772 20
    case T1_FIELD_LOCATION_LOADER:
      dummy_object = loader;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

    case T1_FIELD_LOCATION_FACE:
      dummy_object = face;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
    case T1_FIELD_LOCATION_BLEND:
      dummy_object = face->blend;
      objects      = &dummy_object;
      max_objects  = 0;
      break;
#endif

d792 2
a793 3
  static void
  parse_private( T1_Face    face,
                 T1_Loader  loader )
d795 3
a797 3
    FT_UNUSED( face );

    loader->keywords_encountered |= T1_PRIVATE;
d831 1
a831 1
      return !parser->root.error;
a852 1
    FT_Int      result;
d855 1
a855 7
    result = T1_ToFixedArray( parser, 6, temp, 3 );

    if ( result < 0 )
    {
      parser->root.error = T1_Err_Invalid_File_Format;
      return;
    }
a858 7
    if ( temp_scale == 0 )
    {
      FT_ERROR(( "parse_font_matrix: invalid font matrix\n" ));
      parser->root.error = T1_Err_Invalid_File_Format;
      return;
    }

d984 3
a986 3
          if ( cur[1] == 'e'         &&
               cur[2] == 'f'         &&
               IS_PS_DELIM( cur[3] ) )
a1024 2
            if ( parser->root.error )
              return;
a1037 1
        {
a1038 3
          if ( parser->root.error )
            return;
        }
d1100 1
a1100 3
    if ( parser->root.error )
      return;
    T1_Skip_Spaces( parser );
a1137 2
      if ( parser->root.error )
        return;
a1159 6
        if ( size <= face->type1.private_dict.lenIV )
        {
          error = T1_Err_Invalid_File_Format;
          goto Fail;
        }

d1260 1
a1260 1
      if ( cur + 3 < limit && IS_PS_DELIM( cur[3] ) )
d1265 1
a1265 14
        {
          /* There are fonts which have this: */
          /*                                  */
          /*   /CharStrings 118 dict def      */
          /*   Private begin                  */
          /*   CharStrings begin              */
          /*   ...                            */
          /*                                  */
          /* To catch this we ignore `def' if */
          /* no charstring has actually been  */
          /* seen.                            */
          if ( n )
            break;
        }
a1273 2
      if ( parser->root.error )
        return;
d1314 2
a1315 2
        if ( face->type1.private_dict.lenIV >= 0 &&
             n < num_glyphs + TABLE_EXTEND       )
a1319 6
          if ( size <= face->type1.private_dict.lenIV )
          {
            error = T1_Err_Invalid_File_Format;
            goto Fail;
          }

d1479 4
a1482 10
    T1_FIELD_CALLBACK( "FontMatrix",           parse_font_matrix,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Encoding",             parse_encoding,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Subrs",                parse_subrs,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "CharStrings",          parse_charstrings,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "Private",              parse_private,
                       T1_FIELD_DICT_FONTDICT )
d1485 4
a1488 10
    T1_FIELD_CALLBACK( "BlendDesignPositions", parse_blend_design_positions,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendDesignMap",       parse_blend_design_map,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendAxisTypes",       parse_blend_axis_types,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "WeightVector",         parse_weight_vector,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BuildCharArray",       parse_buildchar,
                       T1_FIELD_DICT_PRIVATE )
d1491 1
a1491 1
    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
d1503 2
a1504 1
              FT_Long    size )
d1526 41
d1568 2
a1569 1
      if ( IS_PS_TOKEN( cur, limit, "eexec" ) )
d1573 2
a1574 1
      else if ( IS_PS_TOKEN( cur, limit, "closefile" ) )
a1576 10
      /* in a synthetic font the base font starts after a           */
      /* `FontDictionary' token that is placed after a Private dict */
      else if ( IS_PS_TOKEN( cur, limit, "FontDirectory" ) )
      {
        if ( loader->keywords_encountered & T1_PRIVATE )
          loader->keywords_encountered |=
            T1_FONTDIR_AFTER_PRIVATE;
        parser->root.cursor += 13;
      }

a1581 2
        if ( parser->root.error )
          goto Exit;
a1623 2
        if ( parser->root.error )
          goto Exit;
d1630 2
a1631 1
          T1_Field  keyword = (T1_Field)t1_keywords;
d1643 3
a1645 3
            if ( cur[0] == name[0]                                  &&
                 len == (FT_PtrDist)ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0                   )
d1647 8
a1654 43
              /* We found it -- run the parsing callback!     */
              /* We record every instance of every field      */
              /* (until we reach the base font of a           */
              /* synthetic font) to deal adequately with      */
              /* multiple master fonts; this is also          */
              /* necessary because later PostScript           */
              /* definitions override earlier ones.           */

              /* Once we encounter `FontDirectory' after      */
              /* `/Private', we know that this is a synthetic */
              /* font; except for `/CharStrings' we are not   */
              /* interested in anything that follows this     */
              /* `FontDirectory'.                             */

              /* MM fonts have more than one /Private token at */
              /* the top level; let's hope that all the junk   */
              /* that follows the first /Private token is not  */
              /* interesting to us.                            */

              /* According to Adobe Tech Note #5175 (CID-Keyed */
              /* Font Installation for ATM Software) a `begin' */
              /* must be followed by exactly one `end', and    */
              /* `begin' -- `end' pairs must be accurately     */
              /* paired.  We could use this to distinguish     */
              /* between the global Private and the Private    */
              /* dict that is a member of the Blend dict.      */

              const FT_UInt dict =
                ( loader->keywords_encountered & T1_PRIVATE )
                    ? T1_FIELD_DICT_PRIVATE
                    : T1_FIELD_DICT_FONTDICT;

              if ( !( dict & keyword->dict ) )
              {
                FT_TRACE1(( "parse_dict: found %s but ignoring it "
                            "since it is in the wrong dictionary\n",
                            keyword->ident ));
                break;
              }

              if ( !( loader->keywords_encountered &
                      T1_FONTDIR_AFTER_PRIVATE     )                  ||
                   ft_strcmp( (const char*)name, "CharStrings" ) == 0 )
d1659 3
a1661 1
                if ( parser->root.error != T1_Err_Ok )
d1673 1
d1706 6
a1711 7
    loader->encoding_table.init  = 0;
    loader->charstrings.init     = 0;
    loader->glyph_names.init     = 0;
    loader->subrs.init           = 0;
    loader->swap_table.init      = 0;
    loader->fontdata             = 0;
    loader->keywords_encountered = 0;
d1741 1
a1748 4
    face->ndv_idx          = -1;
    face->cdv_idx          = -1;
    face->len_buildchar    = 0;

d1763 10
a1772 2
    error = parse_dict( face, &loader,
                        parser->base_dict, parser->base_len );
d1780 3
a1782 2
    error = parse_dict( face, &loader,
                        parser->private_dict, parser->private_len );
a1785 3
    /* ensure even-ness of `num_blue_values' */
    priv->num_blue_values &= ~1;

a1787 13
    if ( face->blend                                                     &&
         face->blend->num_default_design_vector != 0                     &&
         face->blend->num_default_design_vector != face->blend->num_axis )
    {
      /* we don't use it currently so just warn, reset, and ignore */
      FT_ERROR(( "T1_Open_Face(): /DesignVector contains %u entries "
                 "while there are %u axes.\n",
                 face->blend->num_default_design_vector,
                 face->blend->num_axis ));

      face->blend->num_default_design_vector = 0;
    }

a1807 16
    if ( face->blend )
    {
      if ( face->len_buildchar > 0 )
      {
        FT_Memory  memory = face->root.memory;


        if ( FT_NEW_ARRAY( face->buildchar, face->len_buildchar ) )
        {
          FT_ERROR(( "T1_Open_Face: cannot allocate BuildCharArray\n" ));
          face->len_buildchar = 0;
          goto Exit;
        }
      }
    }

@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
d677 1
a677 1
        T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
a689 9
          if ( n_axis <= 0 || n_axis > T1_MAX_MM_AXIS )
          {
            FT_ERROR(( "parse_blend_design_positions:" ));
            FT_ERROR(( "  invalid number of axes: %d\n",
                       n_axis ));
            error = T1_Err_Invalid_File_Format;
            goto Exit;
          }

d1400 1
a1400 4
        /* some fonts define empty subr records -- this is not totally */
        /* compliant to the specification (which says they should at   */
        /* least contain a `return'), but we support them anyway       */
        if ( size < face->type1.private_dict.lenIV )
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
a213 153
#define FT_INT_TO_FIXED( a )  ( (a) << 16 )
#define FT_FIXED_TO_INT( a )  ( FT_RoundFix( a ) >> 16 )


  /*************************************************************************/
  /*                                                                       */
  /* Given a normalized (blend) coordinate, figure out the design          */
  /* coordinate appropriate for that value.                                */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Fixed )
  mm_axis_unmap( PS_DesignMap  axismap,
                 FT_Fixed      ncv )
  {
    int  j;


    if ( ncv <= axismap->blend_points[0] )
      return axismap->design_points[0];

    for ( j = 1; j < axismap->num_points; ++j )
    {
      if ( ncv <= axismap->blend_points[j] )
      {
        FT_Fixed  t = FT_MulDiv( ncv - axismap->blend_points[j - 1],
                                 0x10000L,
                                 axismap->blend_points[j] -
                                   axismap->blend_points[j - 1] );


        return axismap->design_points[j - 1] +
                 FT_MulDiv( t,
                            axismap->design_points[j] - 
                              axismap->design_points[j - 1],
                            1L );
      }
    }

    return axismap->design_points[axismap->num_points - 1];
  }


  /*************************************************************************/
  /*                                                                       */
  /* Given a vector of weights, one for each design, figure out the        */
  /* normalized axis coordinates which gave rise to those weights.         */
  /*                                                                       */
  FT_LOCAL_DEF( void )
  mm_weights_unmap( FT_Fixed*  weights,
                    FT_Fixed*  axiscoords,
                    FT_UInt    axis_count )
  {
    FT_ASSERT( axis_count <= T1_MAX_MM_AXIS );

    if ( axis_count == 1 )
      axiscoords[0] = weights[1];

    else if ( axis_count == 2 )
    {
      axiscoords[0] = weights[3] + weights[1];
      axiscoords[1] = weights[3] + weights[2];
    }

    else if ( axis_count == 3 )
    {
      axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
    }

    else
    {
      axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
                        weights[7] + weights[5] + weights[3] + weights[1];
      axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
                        weights[7] + weights[6] + weights[3] + weights[2];
      axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[7] + weights[6] + weights[5] + weights[4];
      axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
                        weights[11] + weights[10] + weights[9] + weights[8];
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Get_Multi_Master to support the different    */
  /*  arguments needed by the GX var distortable fonts.                    */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Get_MM_Var( T1_Face      face,
                 FT_MM_Var*  *master )
  {
    FT_Memory        memory = face->root.memory;
    FT_MM_Var       *mmvar;
    FT_Multi_Master  mmaster;
    FT_Error         error;
    FT_UInt          i;
    FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
    PS_Blend         blend = face->blend;


    error = T1_Get_Multi_Master( face, &mmaster );
    if ( error )
      goto Exit;
    if ( FT_ALLOC( mmvar,
                   sizeof ( FT_MM_Var ) +
                     mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
      goto Exit;

    mmvar->num_axis        = mmaster.num_axis;
    mmvar->num_designs     = mmaster.num_designs;
    mmvar->num_namedstyles = (FT_UInt)-1;                /* Does not apply */
    mmvar->axis            = (FT_Var_Axis*)&mmvar[1];
                                      /* Point to axes after MM_Var struct */
    mmvar->namedstyle      = NULL;

    for ( i = 0 ; i < mmaster.num_axis; ++i )
    {
      mmvar->axis[i].name    = mmaster.axis[i].name;
      mmvar->axis[i].minimum = FT_INT_TO_FIXED( mmaster.axis[i].minimum);
      mmvar->axis[i].maximum = FT_INT_TO_FIXED( mmaster.axis[i].maximum);
      mmvar->axis[i].def     = ( mmvar->axis[i].minimum +
                                   mmvar->axis[i].maximum ) / 2;
                            /* Does not apply.  But this value is in range */
      mmvar->axis[i].strid   = 0xFFFFFFFFUL;   /* Does not apply */
      mmvar->axis[i].tag     = 0xFFFFFFFFUL;   /* Does not apply */

      if ( ft_strcmp( mmvar->axis[i].name, "Weight" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'g', 'h', 't' );
      else if ( ft_strcmp( mmvar->axis[i].name, "Width" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'w', 'd', 't', 'h' );
      else if ( ft_strcmp( mmvar->axis[i].name, "OpticalSize" ) == 0 )
        mmvar->axis[i].tag = FT_MAKE_TAG( 'o', 'p', 's', 'z' );
    }

    if ( blend->num_designs == 1U << blend->num_axis )
    {
      mm_weights_unmap( blend->default_weight_vector,
                        axiscoords,
                        blend->num_axis );

      for ( i = 0; i < mmaster.num_axis; ++i )
        mmvar->axis[i].def = mm_axis_unmap( &blend->design_map[i],
                                            axiscoords[i] );
    }

    *master = mmvar;

  Exit:
    return error;
  }


d283 1
a283 1
        FT_Long*      designs = map->design_points;
d290 1
a290 1
          FT_Long  p_design = designs[p];
a331 27
  /*************************************************************************/
  /*                                                                       */
  /* Just a wrapper around T1_Set_MM_Design to support the different       */
  /* arguments needed by the GX var distortable fonts.                     */
  /*                                                                       */
  FT_LOCAL_DEF( FT_Error )
  T1_Set_Var_Design( T1_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
  {
     FT_Long   lcoords[4];          /* maximum axis count is 4 */
     FT_UInt   i;
     FT_Error  error;


     error = T1_Err_Invalid_Argument;
     if ( num_coords <= 4 && num_coords > 0 )
     {
       for ( i = 0; i < num_coords; ++i )
         lcoords[i] = FT_FIXED_TO_INT( coords[i] );
       error = T1_Set_MM_Design( face, num_coords, lcoords );
     }

     return error;
  }


d831 1
a831 1
      return !parser->root.error;
a1024 2
            if ( parser->root.error )
              return;
d1100 1
a1100 3
    if ( parser->root.error )
      return;
    T1_Skip_Spaces( parser );
a1137 2
      if ( parser->root.error )
        return;
d1265 1
a1265 14
        {
          /* There are fonts which have this: */
          /*                                  */
          /*   /CharStrings 118 dict def      */
          /*   Private begin                  */
          /*   CharStrings begin              */
          /*   ...                            */
          /*                                  */
          /* To catch this we ignore `def' if */
          /* no charstring has actually been  */
          /* seen.                            */
          if ( n )
            break;
        }
a1273 2
      if ( parser->root.error )
        return;
d1546 1
a1546 3
          if ( parser->root.error )
            goto Exit;
          T1_Skip_Spaces( parser );
a1581 2
        if ( parser->root.error )
          goto Exit;
a1623 2
        if ( parser->root.error )
          goto Exit;
d1643 3
a1645 3
            if ( cur[0] == name[0]                                  &&
                 len == (FT_PtrDist)ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0                   )
d1652 3
a1654 3
              if ( keyword_flag[0] == 0                               ||
                   ft_strcmp( (const char*)name, "Subrs" ) == 0       ||
                   ft_strcmp( (const char*)name, "CharStrings" ) == 0 )
a1784 3
 
    /* ensure even-ness of `num_blue_values' */
    priv->num_blue_values &= ~1;
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
a67 1
#include FT_INTERNAL_CALC_H
a109 2
      blend->num_default_design_vector = 0;

d214 4
d231 1
a231 1
      return INT_TO_FIXED( axismap->design_points[0] );
d242 2
a243 1
        return INT_TO_FIXED( axismap->design_points[j - 1] ) +
d245 1
a245 1
                            axismap->design_points[j] -
d251 1
a251 1
    return INT_TO_FIXED( axismap->design_points[axismap->num_points - 1] );
d333 2
a334 2
      mmvar->axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum);
      mmvar->axis[i].maximum = INT_TO_FIXED( mmaster.axis[i].maximum);
d338 2
a339 2
      mmvar->axis[i].strid   = (FT_UInt)-1;    /* Does not apply */
      mmvar->axis[i].tag     = (FT_ULong)-1;   /* Does not apply */
d349 1
a349 1
    if ( blend->num_designs == ( 1U << blend->num_axis ) )
d504 1
a504 1
         lcoords[i] = FIXED_TO_INT( coords[i] );
d656 2
a657 2
      FT_ERROR(( "parse_blend_design_positions:"
                 " incorrect number of designs: %d\n",
d674 1
a674 1
        T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
a686 9
          if ( n_axis <= 0 || n_axis > T1_MAX_MM_AXIS )
          {
            FT_ERROR(( "parse_blend_design_positions:"
                       " invalid number of axes: %d\n",
                       n_axis ));
            error = T1_Err_Invalid_File_Format;
            goto Exit;
          }

d735 1
a735 1
    T1_ToTokenArray( parser, axis_tokens,
d835 2
a836 2
      FT_ERROR(( "parse_weight_vector:"
                 " incorrect number of designs: %d\n",
d852 3
a854 3
                 " /BlendDesignPosition and /WeightVector have\n"
                 "                    "
                 " different number of elements\n" ));
a879 12
  /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
  /* we're only interested in the number of array elements */
  static void
  parse_buildchar( T1_Face    face,
                   T1_Loader  loader )
  {
    face->len_buildchar = T1_ToFixedArray( &loader->parser, 0, NULL, 0 );

    return;
  }


a928 6
    case T1_FIELD_LOCATION_FONT_EXTRA:
      dummy_object = &face->type1.font_extra;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

a952 20
    case T1_FIELD_LOCATION_LOADER:
      dummy_object = loader;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

    case T1_FIELD_LOCATION_FACE:
      dummy_object = face;
      objects      = &dummy_object;
      max_objects  = 0;
      break;

#ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
    case T1_FIELD_LOCATION_BLEND:
      dummy_object = face->blend;
      objects      = &dummy_object;
      max_objects  = 0;
      break;
#endif

d972 2
a973 3
  static void
  parse_private( T1_Face    face,
                 T1_Loader  loader )
d975 3
a977 3
    FT_UNUSED( face );

    loader->keywords_encountered |= T1_PRIVATE;
a1032 1
    FT_Int      result;
d1035 1
a1035 7
    result = T1_ToFixedArray( parser, 6, temp, 3 );

    if ( result < 0 )
    {
      parser->root.error = T1_Err_Invalid_File_Format;
      return;
    }
a1038 7
    if ( temp_scale == 0 )
    {
      FT_ERROR(( "parse_font_matrix: invalid font matrix\n" ));
      parser->root.error = T1_Err_Invalid_File_Format;
      return;
    }

d1083 1
a1083 1
      FT_ERROR(( "parse_encoding: out of bounds\n" ));
d1164 3
a1166 3
          if ( cur[1] == 'e'         &&
               cur[2] == 'f'         &&
               IS_PS_DELIM( cur[3] ) )
a1217 13
          else if ( only_immediates )
          {
            /* Since the current position is not updated for           */
            /* immediates-only mode we would get an infinite loop if   */
            /* we don't do anything here.                              */
            /*                                                         */
            /* This encoding array is not valid according to the type1 */
            /* specification (it might be an encoding for a CID type1  */
            /* font, however), so we conclude that this font is NOT a  */
            /* type1 font.                                             */
            parser->root.error = FT_Err_Unknown_File_Format;
            return;
          }
a1219 1
        {
a1220 3
          if ( parser->root.error )
            return;
        }
d1259 1
a1259 1
    FT_Int     num_subrs;
d1261 1
a1261 1
    PSAux_Service  psaux = (PSAux_Service)face->psaux;
d1295 5
a1299 5
    /* the format is simple:   */
    /*                         */
    /*   `index' + binary data */
    /*                         */
    for (;;)
d1305 2
a1306 1
      /* If the next token isn't `dup' we are done. */
a1345 9
        /* some fonts define empty subr records -- this is not totally */
        /* compliant to the specification (which says they should at   */
        /* least contain a `return'), but we support them anyway       */
        if ( size < face->type1.private_dict.lenIV )
        {
          error = T1_Err_Invalid_File_Format;
          goto Fail;
        }

d1446 1
a1446 1
      if ( cur + 3 < limit && IS_PS_DELIM( cur[3] ) )
d1515 2
a1516 2
        if ( face->type1.private_dict.lenIV >= 0 &&
             n < num_glyphs + TABLE_EXTEND       )
a1520 6
          if ( size <= face->type1.private_dict.lenIV )
          {
            error = T1_Err_Invalid_File_Format;
            goto Fail;
          }

d1540 4
a1543 1
    loader->num_glyphs = n;
d1546 3
a1548 2
    if ( notdef_found                                                 &&
         ft_strcmp( ".notdef", (const char*)name_table->elements[0] ) )
d1617 1
a1617 1
      FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };
d1655 1
a1655 1
      loader->num_glyphs += 1;
d1680 4
a1683 10
    T1_FIELD_CALLBACK( "FontMatrix",           parse_font_matrix,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Encoding",             parse_encoding,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "Subrs",                parse_subrs,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "CharStrings",          parse_charstrings,
                       T1_FIELD_DICT_PRIVATE )
    T1_FIELD_CALLBACK( "Private",              parse_private,
                       T1_FIELD_DICT_FONTDICT )
d1686 4
a1689 10
    T1_FIELD_CALLBACK( "BlendDesignPositions", parse_blend_design_positions,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendDesignMap",       parse_blend_design_map,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BlendAxisTypes",       parse_blend_axis_types,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "WeightVector",         parse_weight_vector,
                       T1_FIELD_DICT_FONTDICT )
    T1_FIELD_CALLBACK( "BuildCharArray",       parse_buildchar,
                       T1_FIELD_DICT_PRIVATE )
d1692 1
a1692 1
    { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
d1704 2
a1705 1
              FT_Long    size )
d1727 43
d1771 2
a1772 1
      if ( IS_PS_TOKEN( cur, limit, "eexec" ) )
d1776 2
a1777 1
      else if ( IS_PS_TOKEN( cur, limit, "closefile" ) )
a1779 10
      /* in a synthetic font the base font starts after a           */
      /* `FontDictionary' token that is placed after a Private dict */
      else if ( IS_PS_TOKEN( cur, limit, "FontDirectory" ) )
      {
        if ( loader->keywords_encountered & T1_PRIVATE )
          loader->keywords_encountered |=
            T1_FONTDIR_AFTER_PRIVATE;
        parser->root.cursor += 13;
      }

d1837 2
a1838 1
          T1_Field  keyword = (T1_Field)t1_keywords;
d1854 7
a1860 42
              /* We found it -- run the parsing callback!     */
              /* We record every instance of every field      */
              /* (until we reach the base font of a           */
              /* synthetic font) to deal adequately with      */
              /* multiple master fonts; this is also          */
              /* necessary because later PostScript           */
              /* definitions override earlier ones.           */

              /* Once we encounter `FontDirectory' after      */
              /* `/Private', we know that this is a synthetic */
              /* font; except for `/CharStrings' we are not   */
              /* interested in anything that follows this     */
              /* `FontDirectory'.                             */

              /* MM fonts have more than one /Private token at */
              /* the top level; let's hope that all the junk   */
              /* that follows the first /Private token is not  */
              /* interesting to us.                            */

              /* According to Adobe Tech Note #5175 (CID-Keyed */
              /* Font Installation for ATM Software) a `begin' */
              /* must be followed by exactly one `end', and    */
              /* `begin' -- `end' pairs must be accurately     */
              /* paired.  We could use this to distinguish     */
              /* between the global Private and the Private    */
              /* dict that is a member of the Blend dict.      */

              const FT_UInt dict =
                ( loader->keywords_encountered & T1_PRIVATE )
                    ? T1_FIELD_DICT_PRIVATE
                    : T1_FIELD_DICT_FONTDICT;

              if ( !( dict & keyword->dict ) )
              {
                FT_TRACE1(( "parse_dict: found %s but ignoring it "
                            "since it is in the wrong dictionary\n",
                            keyword->ident ));
                break;
              }

              if ( !( loader->keywords_encountered &
                      T1_FONTDIR_AFTER_PRIVATE     )                  ||
d1866 3
a1868 1
                if ( parser->root.error != T1_Err_Ok )
d1880 1
d1913 6
a1918 7
    loader->encoding_table.init  = 0;
    loader->charstrings.init     = 0;
    loader->glyph_names.init     = 0;
    loader->subrs.init           = 0;
    loader->swap_table.init      = 0;
    loader->fontdata             = 0;
    loader->keywords_encountered = 0;
d1948 1
a1955 4
    face->ndv_idx          = -1;
    face->cdv_idx          = -1;
    face->len_buildchar    = 0;

d1970 10
a1979 2
    error = parse_dict( face, &loader,
                        parser->base_dict, parser->base_len );
d1987 3
a1989 2
    error = parse_dict( face, &loader,
                        parser->private_dict, parser->private_len );
d1992 1
a1992 1

a1997 13
    if ( face->blend                                                     &&
         face->blend->num_default_design_vector != 0                     &&
         face->blend->num_default_design_vector != face->blend->num_axis )
    {
      /* we don't use it currently so just warn, reset, and ignore */
      FT_ERROR(( "T1_Open_Face(): /DesignVector contains %u entries "
                 "while there are %u axes.\n",
                 face->blend->num_default_design_vector,
                 face->blend->num_axis ));

      face->blend->num_default_design_vector = 0;
    }

a2017 16
    if ( face->blend )
    {
      if ( face->len_buildchar > 0 )
      {
        FT_Memory  memory = face->root.memory;


        if ( FT_NEW_ARRAY( face->buildchar, face->len_buildchar ) )
        {
          FT_ERROR(( "T1_Open_Face: cannot allocate BuildCharArray\n" ));
          face->len_buildchar = 0;
          goto Exit;
        }
      }
    }

d2038 1
a2038 1
        FT_ERROR(( "T1_Open_Face: no `/CharStrings' array in face\n" ));
d2067 2
a2068 2
      min_char = 0;
      max_char = 0;
d2094 2
a2095 2
                if ( charcode >= max_char )
                  max_char = charcode + 1;
d2102 11
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
a68 1
#include FT_INTERNAL_HASH_H
a73 7
#ifdef FT_CONFIG_OPTION_INCREMENTAL
#define IS_INCREMENTAL  (FT_Bool)( face->root.internal->incremental_interface != 0 )
#else
#define IS_INCREMENTAL  0
#endif


d102 1
a102 1
    FT_Error   error  = FT_Err_Ok;
d126 2
a127 2
             FT_NEW_ARRAY( blend->privates  [1], num_designs     ) ||
             FT_NEW_ARRAY( blend->bboxes    [1], num_designs     ) ||
d139 1
d141 1
a141 2
          blend->privates  [nn] = blend->privates  [nn - 1] + 1;
          blend->bboxes    [nn] = blend->bboxes    [nn - 1] + 1;
d144 1
a144 1
        blend->num_designs = num_designs;
d178 1
a178 1
    error = FT_THROW( Invalid_File_Format );
d192 1
a192 1
    error = FT_THROW( Invalid_Argument );
d210 1
a210 1
      error = FT_Err_Ok;
d222 1
a222 1
  static FT_Fixed
d232 1
a232 1
    for ( j = 1; j < axismap->num_points; j++ )
d235 6
d242 5
a246 4
               ( axismap->design_points[j] - axismap->design_points[j - 1] ) *
               FT_DivFix( ncv - axismap->blend_points[j - 1],
                          axismap->blend_points[j] -
                            axismap->blend_points[j - 1] );
d258 1
a258 1
  static void
d305 1
a305 1
    FT_MM_Var       *mmvar = NULL;
d323 1
a323 1
    mmvar->num_namedstyles = 0;                           /* Not supported */
d328 1
a328 1
    for ( i = 0; i < mmaster.num_axis; i++ )
d336 2
a337 5
      mmvar->axis[i].strid   = ~0U;                      /* Does not apply */
      mmvar->axis[i].tag     = ~0U;                      /* Does not apply */

      if ( !mmvar->axis[i].name )
        continue;
d353 1
a353 1
      for ( i = 0; i < mmaster.num_axis; i++ )
d371 1
d375 1
a375 2
    if ( !blend )
      return FT_THROW( Invalid_Argument );
d377 1
a377 5
    if ( num_coords > blend->num_axis )
      num_coords = blend->num_axis;

    /* recompute the weight vector from the blend coordinates */
    for ( n = 0; n < blend->num_designs; n++ )
d379 2
a380 2
      FT_Fixed  result = 0x10000L;  /* 1.0 fixed */

d382 1
a382 1
      for ( m = 0; m < blend->num_axis; m++ )
d384 1
a384 1
        FT_Fixed  factor;
d387 3
a389 7
        /* get current blend axis position;                  */
        /* use a default value if we don't have a coordinate */
        factor = m < num_coords ? coords[m] : 0x8000;
        if ( factor < 0 )
          factor = 0;
        if ( factor > 0x10000L )
          factor = 0x10000L;
a390 2
        if ( ( n & ( 1 << m ) ) == 0 )
          factor = 0x10000L - factor;
d392 4
a395 4
        result = FT_MulFix( result, factor );
      }
      blend->weight_vector[n] = result;
    }
d397 2
a398 2
    return FT_Err_Ok;
  }
d400 4
d405 1
a405 24
  FT_LOCAL_DEF( FT_Error )
  T1_Get_MM_Blend( T1_Face    face,
                   FT_UInt    num_coords,
                   FT_Fixed*  coords )
  {
    PS_Blend  blend = face->blend;

    FT_Fixed  axiscoords[4];
    FT_UInt   i, nc;


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    mm_weights_unmap( blend->weight_vector,
                      axiscoords,
                      blend->num_axis );

    nc = num_coords;
    if ( num_coords > blend->num_axis )
    {
      FT_TRACE2(( "T1_Get_MM_Blend: only using first %d of %d coordinates\n",
                  blend->num_axis, num_coords ));
      nc = blend->num_axis;
d408 1
a408 6
    for ( i = 0; i < nc; i++ )
      coords[i] = axiscoords[i];
    for ( ; i < num_coords; i++ )
      coords[i] = 0x8000;

    return FT_Err_Ok;
d418 1
a419 1
    FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];
d422 5
a426 2
    if ( !blend )
      return FT_THROW( Invalid_Argument );
a427 2
    if ( num_coords > blend->num_axis )
      num_coords = blend->num_axis;
d429 8
a436 1
    /* compute the blend coordinates through the blend design map */
a437 8
    for ( n = 0; n < blend->num_axis; n++ )
    {
      FT_Long       design;
      FT_Fixed      the_blend;
      PS_DesignMap  map     = blend->design_map + n;
      FT_Long*      designs = map->design_points;
      FT_Fixed*     blends  = map->blend_points;
      FT_Int        before  = -1, after = -1;
d439 3
a442 5
      /* use a default value if we don't have a coordinate */
      if ( n < num_coords )
        design = coords[n];
      else
        design = ( designs[map->num_points - 1] - designs[0] ) / 2;
d444 6
a449 3
      for ( p = 0; p < (FT_UInt)map->num_points; p++ )
      {
        FT_Long  p_design = designs[p];
d451 5
d457 1
a457 11
        /* exact match? */
        if ( design == p_design )
        {
          the_blend = blends[p];
          goto Found;
        }

        if ( design < p_design )
        {
          after = (FT_Int)p;
          break;
d460 3
a462 2
        before = (FT_Int)p;
      }
d464 2
a465 3
      /* now interpolate if necessary */
      if ( before < 0 )
        the_blend = blends[0];
d467 4
a470 2
      else if ( after < 0 )
        the_blend = blends[map->num_points - 1];
d472 3
a474 4
      else
        the_blend = FT_MulDiv( design         - designs[before],
                               blends [after] - blends [before],
                               designs[after] - designs[before] );
d476 1
a476 2
    Found:
      final_blends[n] = the_blend;
d479 1
a479 1
    return T1_Set_MM_Blend( face, blend->num_axis, final_blends );
d493 3
a495 2
     FT_Long  lcoords[T1_MAX_MM_AXIS];
     FT_UInt  i;
d498 7
a504 41
     if ( num_coords > T1_MAX_MM_AXIS )
       num_coords = T1_MAX_MM_AXIS;

     for ( i = 0; i < num_coords; i++ )
       lcoords[i] = FIXED_TO_INT( coords[i] );

     return T1_Set_MM_Design( face, num_coords, lcoords );
  }


  FT_LOCAL_DEF( FT_Error )
  T1_Get_Var_Design( T1_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
  {
    PS_Blend  blend = face->blend;

    FT_Fixed  axiscoords[4];
    FT_UInt   i, nc;


    if ( !blend )
      return FT_THROW( Invalid_Argument );

    mm_weights_unmap( blend->weight_vector,
                      axiscoords,
                      blend->num_axis );

    nc = num_coords;
    if ( num_coords > blend->num_axis )
    {
      FT_TRACE2(( "T1_Get_Var_Design:"
                  " only using first %d of %d coordinates\n",
                  blend->num_axis, num_coords ));
      nc = blend->num_axis;
    }

    for ( i = 0; i < nc; i++ )
      coords[i] = mm_axis_unmap( &blend->design_map[i], axiscoords[i] );
    for ( ; i < num_coords; i++ )
      coords[i] = 0;
d506 1
a506 1
    return FT_Err_Ok;
d527 1
a527 1
        blend->design_pos[n] = NULL;
d536 3
a538 3
        blend->privates  [n] = NULL;
        blend->font_infos[n] = NULL;
        blend->bboxes    [n] = NULL;
d543 1
a543 1
      blend->default_weight_vector = NULL;
d570 1
a570 1
    FT_Error     error = FT_Err_Ok;
d580 1
a580 1
      error = FT_ERR( Ignore );
d587 1
a587 1
      error = FT_THROW( Invalid_File_Format );
d602 3
a604 3
      T1_Token  token = axis_tokens + n;
      FT_Byte*  name;
      FT_UInt   len;
d611 1
a611 1
      len = (FT_UInt)( token->limit - token->start );
d614 1
a614 1
        error = FT_THROW( Invalid_File_Format );
a617 9
      name = (FT_Byte*)blend->axis_names[n];
      if ( name )
      {
        FT_TRACE0(( "parse_blend_axis_types:"
                    " overwriting axis name `%s' with `%*.s'\n",
                    name, len, token->start ));
        FT_FREE( name );
      }

d623 1
a623 1
      name[len] = '\0';
d640 1
a640 1
    FT_Error     error = FT_Err_Ok;
d649 1
a649 1
      error = FT_ERR( Ignore );
d657 1
a657 1
      error = FT_THROW( Invalid_File_Format );
d690 1
a690 1
            error = FT_THROW( Invalid_File_Format );
d695 1
a695 3
          error = t1_allocate_blend( face,
                                     (FT_UInt)num_designs,
                                     (FT_UInt)num_axis );
d703 1
a703 1
          error = FT_THROW( Invalid_File_Format );
d732 1
a732 1
    FT_Error     error  = FT_Err_Ok;
d746 1
a746 1
      error = FT_ERR( Ignore );
d753 1
a753 1
      error = FT_THROW( Invalid_File_Format );
d760 1
a760 1
    error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
d784 1
a784 8
        error = FT_THROW( Invalid_File_Format );
        goto Exit;
      }

      if ( map->design_points )
      {
        FT_ERROR(( "parse_blend_design_map: duplicate table\n" ));
        error = FT_THROW( Invalid_File_Format );
d824 1
a824 1
    FT_Error     error  = FT_Err_Ok;
d837 1
a837 1
      error = FT_ERR( Ignore );
d845 1
a845 1
      error = FT_THROW( Invalid_File_Format );
d851 1
a851 1
      error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );
d862 1
a862 1
      error = FT_THROW( Invalid_File_Format );
d893 2
a894 2
    face->len_buildchar = (FT_UInt)T1_ToFixedArray( &loader->parser,
                                                    0, NULL, 0 );
d899 1
a899 1
#endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
a923 3
    if ( blend && blend->num_designs == 0 )
      blend = NULL;

d1004 4
a1007 10
    if ( *objects )
    {
      if ( field->type == T1_FIELD_TYPE_INTEGER_ARRAY ||
           field->type == T1_FIELD_TYPE_FIXED_ARRAY   )
        error = T1_Load_Field_Table( &loader->parser, field,
                                     objects, max_objects, 0 );
      else
        error = T1_Load_Field( &loader->parser, field,
                               objects, max_objects, 0 );
    }
d1009 2
a1010 7
    {
      FT_TRACE1(( "t1_load_keyword: ignoring keyword `%s'"
                  " which is not valid at this point\n"
                  "                 (probably due to missing keywords)\n",
                 field->ident ));
      error = FT_Err_Ok;
    }
a1026 2
  /* return 1 in case of success */

d1029 2
a1030 3
                    FT_ULong*  size,
                    FT_Byte**  base,
                    FT_Bool    incremental )
d1048 1
a1048 2
      FT_Long  s = T1_ToInt( parser );

d1056 2
a1057 12
      if ( s >= 0 && s < limit - *base )
      {
        parser->root.cursor += s + 1;
        *size = (FT_ULong)s;
        return !parser->root.error;
      }
    }

    if( !incremental )
    {
      FT_ERROR(( "read_binary_data: invalid size field\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
d1060 2
d1070 2
a1071 2
  t1_parse_font_matrix( T1_Face    face,
                        T1_Loader  loader )
a1081 1
    /* input is scaled by 1000 to accommodate default FontMatrix */
d1084 1
a1084 1
    if ( result < 6 )
d1086 1
a1086 1
      parser->root.error = FT_THROW( Invalid_File_Format );
d1094 2
a1095 2
      FT_ERROR(( "t1_parse_font_matrix: invalid font matrix\n" ));
      parser->root.error = FT_THROW( Invalid_File_Format );
d1099 8
a1106 1
    /* atypical case */
a1108 3
      /* set units per EM based on FontMatrix values */
      root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );

d1114 1
a1114 1
      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;
d1144 1
a1144 1
      parser->root.error = FT_THROW( Invalid_File_Format );
a1169 9
      /* only composite fonts (which we don't support) */
      /* can have larger values                        */
      if ( count > 256 )
      {
        FT_ERROR(( "parse_encoding: invalid encoding array size\n" ));
        parser->root.error = FT_THROW( Invalid_File_Format );
        return;
      }

a1173 8
      /* PostScript happily allows overwriting of encoding arrays */
      if ( encode->char_index )
      {
        FT_FREE( encode->char_index );
        FT_FREE( encode->char_name );
        T1_Release_Table( char_table );
      }

d1191 1
a1191 1
        (void)T1_Add_Table( char_table, n, notdef, 8 );
a1251 7

            /* protect against invalid charcode */
            if ( cur == parser->root.cursor )
            {
              parser->root.error = FT_THROW( Unknown_File_Format );
              return;
            }
d1256 1
a1256 1
          if ( cur + 2 < limit && *cur == '/' && n < count )
d1258 1
a1258 1
            FT_UInt  len;
a1264 2
            if ( parser->root.cursor >= limit )
              return;
d1268 1
a1268 1
            len = (FT_UInt)( parser->root.cursor - cur );
d1288 1
a1288 1
            parser->root.error = FT_THROW( Unknown_File_Format );
d1323 1
a1323 1
        parser->root.error = FT_ERR( Ignore );
a1336 1
    FT_UInt    count;
d1351 1
a1351 1
        parser->root.error = FT_THROW( Invalid_File_Format );
a1355 41
    if ( num_subrs < 0 )
    {
      parser->root.error = FT_THROW( Invalid_File_Format );
      return;
    }

    /* we certainly need more than 8 bytes per subroutine */
    if ( parser->root.limit >= parser->root.cursor                     &&
         num_subrs > ( parser->root.limit - parser->root.cursor ) >> 3 )
    {
      /*
       * There are two possibilities.  Either the font contains an invalid
       * value for `num_subrs', or we have a subsetted font where the
       * subroutine indices are not adjusted, e.g.
       *
       *   /Subrs 812 array
       *     dup 0 { ... } NP
       *     dup 51 { ... } NP
       *     dup 681 { ... } NP
       *   ND
       *
       * In both cases, we use a number hash that maps from subr indices to
       * actual array elements.
       */

      FT_TRACE0(( "parse_subrs: adjusting number of subroutines"
                  " (from %d to %d)\n",
                  num_subrs,
                  ( parser->root.limit - parser->root.cursor ) >> 3 ));
      num_subrs = ( parser->root.limit - parser->root.cursor ) >> 3;

      if ( !loader->subrs_hash )
      {
        if ( FT_NEW( loader->subrs_hash ) )
          goto Fail;

        error = ft_hash_num_init( loader->subrs_hash, memory );
        if ( error )
          goto Fail;
      }
    }
d1376 1
a1376 1
    for ( count = 0; ; count++ )
d1378 1
a1378 2
      FT_Long   idx;
      FT_ULong  size;
d1382 2
a1383 4
      /* If we are out of data, or if the next token isn't `dup', */
      /* we are done.                                             */
      if ( parser->root.cursor + 4 >= parser->root.limit          ||
          ft_strncmp( (char*)parser->root.cursor, "dup", 3 ) != 0 )
d1390 1
a1390 1
      if ( !read_binary_data( parser, &size, &base, IS_INCREMENTAL ) )
d1402 1
a1402 2
      if ( parser->root.cursor + 4 < parser->root.limit            &&
           ft_strncmp( (char*)parser->root.cursor, "put", 3 ) == 0 )
a1407 8
      /* if we use a hash, the subrs index is the key, and a running */
      /* counter specified for `T1_Add_Table' acts as the value      */
      if ( loader->subrs_hash )
      {
        ft_hash_num_insert( idx, count, loader->subrs_hash, memory );
        idx = count;
      }

d1419 1
a1419 1
        FT_Byte*  temp = NULL;
d1425 1
a1425 1
        if ( size < (FT_ULong)face->type1.private_dict.lenIV )
d1427 1
a1427 1
          error = FT_THROW( Invalid_File_Format );
d1436 1
a1436 1
        size -= (FT_ULong)face->type1.private_dict.lenIV;
d1473 1
a1473 1
    FT_Byte*       cur          = parser->root.cursor;
d1476 1
a1476 1
    FT_Int         notdef_index = 0;
a1480 15
    if ( num_glyphs < 0 )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Fail;
    }

    /* we certainly need more than 8 bytes per glyph */
    if ( num_glyphs > ( limit - cur ) >> 3 )
    {
      FT_TRACE0(( "parse_charstrings: adjusting number of glyphs"
                  " (from %d to %d)\n",
                  num_glyphs, ( limit - cur ) >> 3 ));
      num_glyphs = ( limit - cur ) >> 3;
    }

d1517 1
a1517 1
      FT_ULong  size;
a1557 5
      if ( parser->root.cursor >= limit )
      {
        error = FT_THROW( Invalid_File_Format );
        goto Fail;
      }
d1563 1
a1563 1
        FT_UInt  len;
d1566 1
a1566 1
        if ( cur + 2 >= limit )
d1568 1
a1568 1
          error = FT_THROW( Invalid_File_Format );
d1573 1
a1573 1
        len = (FT_UInt)( parser->root.cursor - cur );
d1575 1
a1575 1
        if ( !read_binary_data( parser, &size, &base, IS_INCREMENTAL ) )
d1603 1
a1603 1
          FT_Byte*  temp = NULL;
d1606 1
a1606 1
          if ( size <= (FT_ULong)face->type1.private_dict.lenIV )
d1608 1
a1608 1
            error = FT_THROW( Invalid_File_Format );
d1617 1
a1617 1
          size -= (FT_ULong)face->type1.private_dict.lenIV;
a1630 6
    if ( !n )
    {
      error = FT_THROW( Invalid_File_Format );
      goto Fail;
    }

d1767 1
a1767 1
    T1_FIELD_CALLBACK( "FontMatrix",           t1_parse_font_matrix,
d1795 4
d1803 1
a1803 1
              FT_ULong   size )
d1812 1
a1812 1
    parser->root.error  = FT_Err_Ok;
d1859 1
a1859 1
        FT_ULong  s;
d1864 2
a1865 2
        if ( !read_binary_data( parser, &s, &b, IS_INCREMENTAL ) )
          return FT_THROW( Invalid_File_Format );
d1872 1
a1872 1
        FT_ULong  s;
d1877 2
a1878 2
        if ( !read_binary_data( parser, &s, &b, IS_INCREMENTAL ) )
          return FT_THROW( Invalid_File_Format );
d1885 1
a1885 1
        FT_UInt  len;
d1895 1
a1895 1
        len = (FT_UInt)( parser->root.cursor - cur );
d1912 3
a1914 3
            if ( cur[0] == name[0]                      &&
                 len == ft_strlen( (const char *)name ) &&
                 ft_memcmp( cur, name, len ) == 0       )
d1950 2
a1951 2
                FT_TRACE1(( "parse_dict: found `%s' but ignoring it"
                            " since it is in the wrong dictionary\n",
d1963 1
a1963 1
                if ( parser->root.error )
d1965 2
a1966 2
                  if ( FT_ERR_EQ( parser->root.error, Ignore ) )
                    parser->root.error = FT_Err_Ok;
d2002 12
a2013 1
    FT_ZERO( loader );
a2020 1
    FT_Memory  memory = parser->root.memory;
a2029 4
    /* finalize hash */
    ft_hash_num_free( loader->subrs_hash, memory );
    FT_FREE( loader->subrs_hash );

a2134 2
    else
      face->len_buildchar = 0;
d2136 1
a2136 1
#endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
d2144 1
a2148 5
      type1->subrs_hash  = loader.subrs_hash;

      /* prevent `t1_done_loader' from freeing the propagated data */
      loader.subrs.init = 0;
      loader.subrs_hash = NULL;
d2151 3
a2153 1
    if ( !IS_INCREMENTAL )
d2157 1
a2157 1
        error = FT_THROW( Invalid_File_Format );
d2169 2
a2170 2
    loader.glyph_names.block    = NULL;
    loader.glyph_names.elements = NULL;
d2176 1
d2183 1
a2183 1
      /* the name to type1.encoding.char_name                       */
a2190 3
        FT_Byte*  char_name;


@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
