head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.48.14;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.45;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.05.04;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.25.02;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.53.09;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.38.36;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.15;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.40;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.52;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.21;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.08;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  psmodule.c                                                             */
/*                                                                         */
/*    PSNames module implementation (body).                                */
/*                                                                         */
/*  Copyright 1996-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H
#include FT_SERVICE_POSTSCRIPT_CMAPS_H

#include "psmodule.h"

#define  DEFINE_PS_TABLES
#include "pstables.h"

#include "psnamerr.h"
#include "pspic.h"


#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES


#ifdef FT_CONFIG_OPTION_ADOBE_GLYPH_LIST


#define VARIANT_BIT         0x80000000UL
#define BASE_GLYPH( code )  ( (FT_UInt32)( (code) & ~VARIANT_BIT ) )


  /* Return the Unicode value corresponding to a given glyph.  Note that */
  /* we do deal with glyph variants by detecting a non-initial dot in    */
  /* the name, as in `A.swash' or `e.final'; in this case, the           */
  /* VARIANT_BIT is set in the return value.                             */
  /*                                                                     */
  static FT_UInt32
  ps_unicode_value( const char*  glyph_name )
  {
    /* If the name begins with `uni', then the glyph name may be a */
    /* hard-coded unicode character code.                          */
    if ( glyph_name[0] == 'u' &&
         glyph_name[1] == 'n' &&
         glyph_name[2] == 'i' )
    {
      /* determine whether the next four characters following are */
      /* hexadecimal.                                             */

      /* XXX: Add code to deal with ligatures, i.e. glyph names like */
      /*      `uniXXXXYYYYZZZZ'...                                   */

      FT_Int       count;
      FT_UInt32    value = 0;
      const char*  p     = glyph_name + 3;


      for ( count = 4; count > 0; count--, p++ )
      {
        char          c = *p;
        unsigned int  d;


        d = (unsigned char)c - '0';
        if ( d >= 10 )
        {
          d = (unsigned char)c - 'A';
          if ( d >= 6 )
            d = 16;
          else
            d += 10;
        }

        /* Exit if a non-uppercase hexadecimal character was found   */
        /* -- this also catches character codes below `0' since such */
        /* negative numbers cast to `unsigned int' are far too big.  */
        if ( d >= 16 )
          break;

        value = ( value << 4 ) + d;
      }

      /* there must be exactly four hex digits */
      if ( count == 0 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return (FT_UInt32)( value | VARIANT_BIT );
      }
    }

    /* If the name begins with `u', followed by four to six uppercase */
    /* hexadecimal digits, it is a hard-coded unicode character code. */
    if ( glyph_name[0] == 'u' )
    {
      FT_Int       count;
      FT_UInt32    value = 0;
      const char*  p     = glyph_name + 1;


      for ( count = 6; count > 0; count--, p++ )
      {
        char          c = *p;
        unsigned int  d;


        d = (unsigned char)c - '0';
        if ( d >= 10 )
        {
          d = (unsigned char)c - 'A';
          if ( d >= 6 )
            d = 16;
          else
            d += 10;
        }

        if ( d >= 16 )
          break;

        value = ( value << 4 ) + d;
      }

      if ( count <= 2 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return (FT_UInt32)( value | VARIANT_BIT );
      }
    }

    /* Look for a non-initial dot in the glyph name in order to */
    /* find variants like `A.swash', `e.final', etc.            */
    {
      const char*  p   = glyph_name;
      const char*  dot = NULL;


      for ( ; *p; p++ )
      {
        if ( *p == '.' && p > glyph_name )
        {
          dot = p;
          break;
        }
      }

      /* now look up the glyph in the Adobe Glyph List */
      if ( !dot )
        return (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );
      else
        return (FT_UInt32)( ft_get_adobe_glyph_index( glyph_name, dot ) |
                            VARIANT_BIT );
    }
  }


  /* ft_qsort callback to sort the unicode map */
  FT_CALLBACK_DEF( int )
  compare_uni_maps( const void*  a,
                    const void*  b )
  {
    PS_UniMap*  map1 = (PS_UniMap*)a;
    PS_UniMap*  map2 = (PS_UniMap*)b;
    FT_UInt32   unicode1 = BASE_GLYPH( map1->unicode );
    FT_UInt32   unicode2 = BASE_GLYPH( map2->unicode );


    /* sort base glyphs before glyph variants */
    if ( unicode1 == unicode2 )
    {
      if ( map1->unicode > map2->unicode )
        return 1;
      else if ( map1->unicode < map2->unicode )
        return -1;
      else
        return 0;
    }
    else
    {
      if ( unicode1 > unicode2 )
        return 1;
      else if ( unicode1 < unicode2 )
        return -1;
      else
        return 0;
    }
  }


  /* support for extra glyphs not handled (well) in AGL; */
  /* we add extra mappings for them if necessary         */

#define EXTRA_GLYPH_LIST_SIZE  10

  static const FT_UInt32  ft_extra_glyph_unicodes[EXTRA_GLYPH_LIST_SIZE] =
  {
    /* WGL 4 */
    0x0394,
    0x03A9,
    0x2215,
    0x00AD,
    0x02C9,
    0x03BC,
    0x2219,
    0x00A0,
    /* Romanian */
    0x021A,
    0x021B
  };

  static const char  ft_extra_glyph_names[] =
  {
    'D','e','l','t','a',0,
    'O','m','e','g','a',0,
    'f','r','a','c','t','i','o','n',0,
    'h','y','p','h','e','n',0,
    'm','a','c','r','o','n',0,
    'm','u',0,
    'p','e','r','i','o','d','c','e','n','t','e','r','e','d',0,
    's','p','a','c','e',0,
    'T','c','o','m','m','a','a','c','c','e','n','t',0,
    't','c','o','m','m','a','a','c','c','e','n','t',0
  };

  static const FT_Int
  ft_extra_glyph_name_offsets[EXTRA_GLYPH_LIST_SIZE] =
  {
     0,
     6,
    12,
    21,
    28,
    35,
    38,
    53,
    59,
    72
  };


  static void
  ps_check_extra_glyph_name( const char*  gname,
                             FT_UInt      glyph,
                             FT_UInt*     extra_glyphs,
                             FT_UInt     *states )
  {
    FT_UInt  n;


    for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
    {
      if ( ft_strcmp( ft_extra_glyph_names +
                        ft_extra_glyph_name_offsets[n], gname ) == 0 )
      {
        if ( states[n] == 0 )
        {
          /* mark this extra glyph as a candidate for the cmap */
          states[n]     = 1;
          extra_glyphs[n] = glyph;
        }

        return;
      }
    }
  }


  static void
  ps_check_extra_glyph_unicode( FT_UInt32  uni_char,
                                FT_UInt   *states )
  {
    FT_UInt  n;


    for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
    {
      if ( uni_char == ft_extra_glyph_unicodes[n] )
      {
        /* disable this extra glyph from being added to the cmap */
        states[n] = 2;

        return;
      }
    }
  }


  /* Build a table that maps Unicode values to glyph indices. */
  static FT_Error
  ps_unicodes_init( FT_Memory             memory,
                    PS_Unicodes           table,
                    FT_UInt               num_glyphs,
                    PS_GetGlyphNameFunc   get_glyph_name,
                    PS_FreeGlyphNameFunc  free_glyph_name,
                    FT_Pointer            glyph_data )
  {
    FT_Error  error;

    FT_UInt  extra_glyph_list_states[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UInt  extra_glyphs[EXTRA_GLYPH_LIST_SIZE];


    /* we first allocate the table */
    table->num_maps = 0;
    table->maps     = NULL;

    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )
    {
      FT_UInt     n;
      FT_UInt     count;
      PS_UniMap*  map;
      FT_UInt32   uni_char;


      map = table->maps;

      for ( n = 0; n < num_glyphs; n++ )
      {
        const char*  gname = get_glyph_name( glyph_data, n );


        if ( gname )
        {
          ps_check_extra_glyph_name( gname, n,
                                     extra_glyphs, extra_glyph_list_states );
          uni_char = ps_unicode_value( gname );

          if ( BASE_GLYPH( uni_char ) != 0 )
          {
            ps_check_extra_glyph_unicode( uni_char,
                                          extra_glyph_list_states );
            map->unicode     = uni_char;
            map->glyph_index = n;
            map++;
          }

          if ( free_glyph_name )
            free_glyph_name( glyph_data, gname );
        }
      }

      for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
      {
        if ( extra_glyph_list_states[n] == 1 )
        {
          /* This glyph name has an additional representation. */
          /* Add it to the cmap.                               */

          map->unicode     = ft_extra_glyph_unicodes[n];
          map->glyph_index = extra_glyphs[n];
          map++;
        }
      }

      /* now compress the table a bit */
      count = (FT_UInt)( map - table->maps );

      if ( count == 0 )
      {
        /* No unicode chars here! */
        FT_FREE( table->maps );
        if ( !error )
          error = FT_THROW( No_Unicode_Glyph_Name );
      }
      else
      {
        /* Reallocate if the number of used entries is much smaller. */
        if ( count < num_glyphs / 2 )
        {
          (void)FT_RENEW_ARRAY( table->maps, num_glyphs, count );
          error = FT_Err_Ok;
        }

        /* Sort the table in increasing order of unicode values, */
        /* taking care of glyph variants.                        */
        ft_qsort( table->maps, count, sizeof ( PS_UniMap ),
                  compare_uni_maps );
      }

      table->num_maps = count;
    }

    return error;
  }


  static FT_UInt
  ps_unicodes_char_index( PS_Unicodes  table,
                          FT_UInt32    unicode )
  {
    PS_UniMap  *min, *max, *mid, *result = NULL;


    /* Perform a binary search on the table. */

    min = table->maps;
    max = min + table->num_maps - 1;

    while ( min <= max )
    {
      FT_UInt32  base_glyph;


      mid = min + ( ( max - min ) >> 1 );

      if ( mid->unicode == unicode )
      {
        result = mid;
        break;
      }

      base_glyph = BASE_GLYPH( mid->unicode );

      if ( base_glyph == unicode )
        result = mid; /* remember match but continue search for base glyph */

      if ( min == max )
        break;

      if ( base_glyph < unicode )
        min = mid + 1;
      else
        max = mid - 1;
    }

    if ( result )
      return result->glyph_index;
    else
      return 0;
  }


  static FT_UInt32
  ps_unicodes_char_next( PS_Unicodes  table,
                         FT_UInt32   *unicode )
  {
    FT_UInt    result    = 0;
    FT_UInt32  char_code = *unicode + 1;


    {
      FT_UInt     min = 0;
      FT_UInt     max = table->num_maps;
      FT_UInt     mid;
      PS_UniMap*  map;
      FT_UInt32   base_glyph;


      while ( min < max )
      {
        mid = min + ( ( max - min ) >> 1 );
        map = table->maps + mid;

        if ( map->unicode == char_code )
        {
          result = map->glyph_index;
          goto Exit;
        }

        base_glyph = BASE_GLYPH( map->unicode );

        if ( base_glyph == char_code )
          result = map->glyph_index;

        if ( base_glyph < char_code )
          min = mid + 1;
        else
          max = mid;
      }

      if ( result )
        goto Exit;               /* we have a variant glyph */

      /* we didn't find it; check whether we have a map just above it */
      char_code = 0;

      if ( min < table->num_maps )
      {
        map       = table->maps + min;
        result    = map->glyph_index;
        char_code = BASE_GLYPH( map->unicode );
      }
    }

  Exit:
    *unicode = char_code;
    return result;
  }


#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */


  static const char*
  ps_get_macintosh_name( FT_UInt  name_index )
  {
    if ( name_index >= FT_NUM_MAC_NAMES )
      name_index = 0;

    return ft_standard_glyph_names + ft_mac_names[name_index];
  }


  static const char*
  ps_get_standard_strings( FT_UInt  sid )
  {
    if ( sid >= FT_NUM_SID_NAMES )
      return 0;

    return ft_standard_glyph_names + ft_sid_names[sid];
  }


#ifdef FT_CONFIG_OPTION_ADOBE_GLYPH_LIST

  FT_DEFINE_SERVICE_PSCMAPSREC(
    pscmaps_interface,

    (PS_Unicode_ValueFunc)     ps_unicode_value,        /* unicode_value         */
    (PS_Unicodes_InitFunc)     ps_unicodes_init,        /* unicodes_init         */
    (PS_Unicodes_CharIndexFunc)ps_unicodes_char_index,  /* unicodes_char_index   */
    (PS_Unicodes_CharNextFunc) ps_unicodes_char_next,   /* unicodes_char_next    */

    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   /* macintosh_name        */
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, /* adobe_std_strings     */

    t1_standard_encoding,                               /* adobe_std_encoding    */
    t1_expert_encoding                                  /* adobe_expert_encoding */
  )

#else

  FT_DEFINE_SERVICE_PSCMAPSREC(
    pscmaps_interface,

    NULL,                                               /* unicode_value         */
    NULL,                                               /* unicodes_init         */
    NULL,                                               /* unicodes_char_index   */
    NULL,                                               /* unicodes_char_next    */

    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   /* macintosh_name        */
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, /* adobe_std_strings     */

    t1_standard_encoding,                               /* adobe_std_encoding    */
    t1_expert_encoding                                  /* adobe_expert_encoding */
  )

#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */


  FT_DEFINE_SERVICEDESCREC1(
    pscmaps_services,

    FT_SERVICE_ID_POSTSCRIPT_CMAPS, &PSCMAPS_INTERFACE_GET )


  static FT_Pointer
  psnames_get_service( FT_Module    module,
                       const char*  service_id )
  {
    /* PSCMAPS_SERVICES_GET dereferences `library' in PIC mode */
#ifdef FT_CONFIG_OPTION_PIC
    FT_Library  library;


    if ( !module )
      return NULL;
    library = module->library;
    if ( !library )
      return NULL;
#else
    FT_UNUSED( module );
#endif

    return ft_service_list_lookup( PSCMAPS_SERVICES_GET, service_id );
  }

#endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */


#ifndef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
#define PUT_PS_NAMES_SERVICE( a )  NULL
#else
#define PUT_PS_NAMES_SERVICE( a )  a
#endif

  FT_DEFINE_MODULE(
    psnames_module_class,

    0,  /* this is not a font driver, nor a renderer */
    sizeof ( FT_ModuleRec ),

    "psnames",  /* driver name                         */
    0x10000L,   /* driver version                      */
    0x20000L,   /* driver requires FreeType 2 or above */

    PUT_PS_NAMES_SERVICE(
      (void*)&PSCMAPS_INTERFACE_GET ),   /* module specific interface */

    (FT_Module_Constructor)NULL,                                       /* module_init   */
    (FT_Module_Destructor) NULL,                                       /* module_done   */
    (FT_Module_Requester)  PUT_PS_NAMES_SERVICE( psnames_get_service ) /* get_interface */
  )


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
d20 1
d25 2
d317 1
a317 1
    table->maps     = 0;
d372 1
d375 1
a375 1
          error = PSnames_Err_Invalid_Argument;  /* No unicode chars here! */
d377 2
a378 1
      else {
d383 1
a383 1
          error = PSnames_Err_Ok;
a526 5
  FT_DEFINE_SERVICE_PSCMAPSREC(pscmaps_interface, 
    (PS_Unicode_ValueFunc)     ps_unicode_value,
    (PS_Unicodes_InitFunc)     ps_unicodes_init,
    (PS_Unicodes_CharIndexFunc)ps_unicodes_char_index,
    (PS_Unicodes_CharNextFunc) ps_unicodes_char_next,
d528 7
a534 2
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings,
d536 5
a540 2
    t1_standard_encoding,
    t1_expert_encoding
d545 7
a551 5
  FT_DEFINE_SERVICE_PSCMAPSREC(pscmaps_interface, 
    0,
    0,
    0,
    0,
d553 2
a554 2
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings,
d556 2
a557 2
    t1_standard_encoding,
    t1_expert_encoding
d563 2
a564 4
  FT_DEFINE_SERVICEDESCREC1(pscmaps_services, 
    FT_SERVICE_ID_POSTSCRIPT_CMAPS, &FT_PSCMAPS_INTERFACE_GET
  )

d566 1
d573 11
d585 1
d587 1
a587 1
    return ft_service_list_lookup( FT_PSCMAPS_SERVICES_GET, service_id );
d594 1
a594 1
#define PUT_PS_NAMES_SERVICE(a) 0
d596 1
a596 1
#define PUT_PS_NAMES_SERVICE(a) a
d599 3
a601 2
  FT_DEFINE_MODULE(psnames_module_class,
  
d609 6
a614 4
    PUT_PS_NAMES_SERVICE((void*)&FT_PSCMAPS_INTERFACE_GET),   /* module specific interface */
    (FT_Module_Constructor)0,
    (FT_Module_Destructor) 0,
    (FT_Module_Requester)  PUT_PS_NAMES_SERVICE(psnames_get_service)
a617 1

@


1.4
log
@Merge freetype 2.3.6
@
text
@d27 1
d37 1
a37 1
#define BASE_GLYPH( code )  ( (code) & ~VARIANT_BIT )
d61 1
a61 1
      FT_ULong     value = 0;
d96 1
a96 1
          return value | VARIANT_BIT;
d105 1
a105 1
      FT_ULong     value = 0;
d136 1
a136 1
          return value | VARIANT_BIT;
d158 1
a158 1
        return ft_get_adobe_glyph_index( glyph_name, p );
d160 2
a161 1
        return ft_get_adobe_glyph_index( glyph_name, dot ) | VARIANT_BIT;
d179 8
a186 1
      return map1->unicode - map2->unicode;
d188 8
a195 1
      return unicode1 - unicode2;
d199 2
a200 1
  /* support for old WGL4 fonts */
d202 1
a202 1
#define WGL_EXTRA_LIST_SIZE  8
d204 1
a204 1
  static const FT_UInt32  ft_wgl_extra_unicodes[WGL_EXTRA_LIST_SIZE] =
d206 1
d214 4
a217 1
    0x00A0
d220 1
a220 1
  static const char  ft_wgl_extra_glyph_names[] =
d229 3
a231 1
    's','p','a','c','e',0
d235 1
a235 1
  ft_wgl_extra_glyph_name_offsets[WGL_EXTRA_LIST_SIZE] =
d244 3
a246 1
    53
d251 4
a254 4
  ps_check_wgl_name( const char*  gname,
                     FT_UInt      glyph,
                     FT_UInt*     wgl_glyphs,
                     FT_UInt     *states )
d259 1
a259 1
    for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
d261 2
a262 2
      if ( ft_strcmp( ft_wgl_extra_glyph_names +
                        ft_wgl_extra_glyph_name_offsets[n], gname ) == 0 )
d266 1
a266 1
          /* mark this WGL extra glyph as a candidate for the cmap */
d268 1
a268 1
          wgl_glyphs[n] = glyph;
d278 2
a279 2
  ps_check_wgl_unicode( FT_UInt32  uni_char,
                        FT_UInt   *states )
d284 1
a284 1
    for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
d286 1
a286 1
      if ( uni_char == ft_wgl_extra_unicodes[n] )
d288 1
a288 1
        /* disable this WGL extra glyph from being added to the cmap */
d308 2
a309 2
    FT_UInt  wgl_list_states[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UInt  wgl_glyphs[WGL_EXTRA_LIST_SIZE];
d316 1
a316 1
    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + WGL_EXTRA_LIST_SIZE ) )
d333 2
a334 1
          ps_check_wgl_name( gname, n, wgl_glyphs, wgl_list_states );
d339 2
a340 1
            ps_check_wgl_unicode( uni_char, wgl_list_states );
d351 1
a351 1
      for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
d353 1
a353 1
        if ( wgl_list_states[n] == 1 )
d355 2
a356 2
          /* This glyph name has an additional WGL4 representation. */
          /* Add it to the cmap.                                    */
d358 2
a359 2
          map->unicode     = ft_wgl_extra_unicodes[n];
          map->glyph_index = wgl_glyphs[n];
d440 1
a440 1
  static FT_ULong
a520 3
  static
  const FT_Service_PsCMapsRec  pscmaps_interface =
  {
d522 1
a522 1

d528 7
d537 1
a542 2
#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */

d548 8
a555 1
  };
a557 5
  static const FT_ServiceDescRec  pscmaps_services[] =
  {
    { FT_SERVICE_ID_POSTSCRIPT_CMAPS, &pscmaps_interface },
    { NULL, NULL }
  };
d566 1
a566 1
    return ft_service_list_lookup( pscmaps_services, service_id );
d572 5
d578 2
a579 3
  FT_CALLBACK_TABLE_DEF
  const FT_Module_Class  psnames_module_class =
  {
d587 1
a587 2
#ifndef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
    0,
d590 3
a592 8
    (FT_Module_Requester)  0
#else
    (void*)&pscmaps_interface,   /* module specific interface */
    (FT_Module_Constructor)0,
    (FT_Module_Destructor) 0,
    (FT_Module_Requester)  psnames_get_service
#endif
  };
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007 by                   */
d29 1
a29 1
#ifndef FT_CONFIG_OPTION_NO_POSTSCRIPT_NAMES
d183 89
d283 3
d291 1
a291 1
    if ( !FT_NEW_ARRAY( table->maps, num_glyphs ) )
d308 1
d313 1
d324 13
d537 1
a537 1
#endif /* !FT_CONFIG_OPTION_NO_POSTSCRIPT_NAMES */
d551 1
a551 1
#ifdef FT_CONFIG_OPTION_NO_POSTSCRIPT_NAMES
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006 by                         */
d35 1
a35 1
#define VARIANT_BIT         ( 1L << 31 )
d95 1
a95 1
          return value ^ VARIANT_BIT;
d100 1
a100 1
    /* hexadicimal digits, it is a hard-coded unicode character code. */
d135 1
a135 1
          return value ^ VARIANT_BIT;
d159 1
a159 1
        return ft_get_adobe_glyph_index( glyph_name, dot ) ^ VARIANT_BIT;
d185 6
a190 5
  ps_unicodes_init( FT_Memory          memory,
                    PS_Unicodes        table,
                    FT_UInt            num_glyphs,
                    PS_Glyph_NameFunc  get_glyph_name,
                    FT_Pointer         glyph_data )
d224 3
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003 by                                     */
d35 5
a39 1
  /* return the Unicode value corresponding to a given glyph.  Note that */
d41 2
a42 1
  /* the name, as in `A.swash' or `e.final', etc.                        */
a46 5
    FT_Int  n;
    char    first = glyph_name[0];
    char    temp[64];


d80 3
a82 1
        /* exit if a non-uppercase hexadecimal character was found */
d90 7
a96 2
      if ( ( *p == '\0' || *p == '.' ) && count == 0 )
        return value;
d130 7
a136 2
      if ( ( *p == '\0' || *p == '.' ) && count <= 2 )
        return value;
d139 2
a140 2
    /* look for a non-initial dot in the glyph name in order to */
    /* sort-out variants like `A.swash', `e.final', etc.        */
d142 2
a143 8
      const char*  p;
      int          len;


      p = glyph_name;

      while ( *p && *p != '.' )
        p++;
a144 1
      len = (int)( p - glyph_name );
d146 1
a146 1
      if ( *p && len < 64 )
d148 5
a152 3
        ft_strncpy( temp, glyph_name, len );
        temp[len]  = 0;
        glyph_name = temp;
a153 1
    }
d155 5
a159 8
    /* now, look up the glyph in the Adobe Glyph List */
    for ( n = 0; n < NUM_ADOBE_GLYPHS; n++ )
    {
      const char*  name = sid_standard_names[n];


      if ( first == name[0] && ft_strcmp( glyph_name, name ) == 0 )
        return ps_names_to_unicode[n];
a160 3

    /* not found, there is probably no Unicode value for this glyph name */
    return 0;
d171 2
d175 5
a179 1
    return ( map1->unicode - map2->unicode );
d183 1
a183 1
  /* Builds a table that maps Unicode values to glyph indices */
d185 5
a189 4
  ps_unicodes_init( FT_Memory     memory,
                    FT_UInt       num_glyphs,
                    const char**  glyph_names,
                    PS_Unicodes*  table )
d210 1
a210 1
        const char*  gname = glyph_names[n];
d217 1
a217 1
          if ( uni_char != 0 && uni_char != 0xFFFFL )
d219 1
a219 1
            map->unicode     = (FT_UInt)uni_char;
d226 1
a226 1
      /* now, compress the table a bit */
a228 5
      if ( count > 0 && FT_REALLOC( table->maps,
                                    num_glyphs * sizeof ( PS_UniMap ),
                                    count * sizeof ( PS_UniMap ) ) )
        count = 0;

d233 14
a246 1
          error = PSnames_Err_Invalid_Argument;  /* no unicode chars here! */
a247 3
      else
        /* sort the table in increasing order of unicode values */
        ft_qsort( table->maps, count, sizeof ( PS_UniMap ), compare_uni_maps );
d257 2
a258 2
  ps_unicodes_char_index( PS_Unicodes*  table,
                          FT_ULong      unicode )
d260 1
a260 1
    PS_UniMap  *min, *max, *mid;
d263 1
a263 1
    /* perform a binary search on the table */
d270 5
a274 1
      mid = min + ( max - min ) / 2;
d276 9
a284 1
        return mid->glyph_index;
d289 1
a289 1
      if ( mid->unicode < unicode )
d295 4
a298 1
    return 0xFFFFU;
d303 2
a304 2
  ps_unicodes_char_next( PS_Unicodes*  table,
                         FT_ULong      unicode )
d306 3
a308 1
    PS_UniMap  *min, *max, *mid;
d310 6
a316 2
    unicode++;
    /* perform a binary search on the table */
d318 12
a329 2
    min = table->maps;
    max = min + table->num_maps - 1;
d331 2
a332 5
    while ( min <= max )
    {
      mid = min + ( max - min ) / 2;
      if ( mid->unicode == unicode )
        return unicode;
d334 5
a338 2
      if ( min == max )
        break;
d340 2
a341 5
      if ( mid->unicode < unicode )
        min = mid + 1;
      else
        max = mid - 1;
    }
d343 2
a344 2
    if ( max < table->maps )
      max = table->maps;
d346 6
a351 5
    while ( max < table->maps + table->num_maps )
    {
      if ( unicode < max->unicode )
        return max->unicode;
      max++;
d354 3
a356 1
    return 0;
d366 1
a366 1
    if ( name_index >= 258 )
d369 1
a369 1
    return ps_glyph_names[mac_standard_names[name_index]];
d376 4
a379 1
    return ( sid < NUM_SID_GLYPHS ? sid_standard_names[sid] : 0 );
d402 2
a403 2
    (PS_Macintosh_Name_Func)   ps_get_macintosh_name,
    (PS_Adobe_Std_Strings_Func)ps_get_standard_strings,
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007 by                   */
d35 1
a35 5
#define VARIANT_BIT         0x80000000UL
#define BASE_GLYPH( code )  ( (code) & ~VARIANT_BIT )


  /* Return the Unicode value corresponding to a given glyph.  Note that */
d37 1
a37 2
  /* the name, as in `A.swash' or `e.final'; in this case, the           */
  /* VARIANT_BIT is set in the return value.                             */
d42 5
d80 1
a80 3
        /* Exit if a non-uppercase hexadecimal character was found   */
        /* -- this also catches character codes below `0' since such */
        /* negative numbers cast to `unsigned int' are far too big.  */
d88 2
a89 7
      if ( count == 0 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return value | VARIANT_BIT;
      }
d93 1
a93 1
    /* hexadecimal digits, it is a hard-coded unicode character code. */
d123 2
a124 7
      if ( count <= 2 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return value | VARIANT_BIT;
      }
d127 2
a128 2
    /* Look for a non-initial dot in the glyph name in order to */
    /* find variants like `A.swash', `e.final', etc.            */
d130 8
a137 2
      const char*  p   = glyph_name;
      const char*  dot = NULL;
d139 1
d141 1
a141 1
      for ( ; *p; p++ )
d143 3
a145 5
        if ( *p == '.' && p > glyph_name )
        {
          dot = p;
          break;
        }
d147 7
d155 2
a156 5
      /* now look up the glyph in the Adobe Glyph List */
      if ( !dot )
        return ft_get_adobe_glyph_index( glyph_name, p );
      else
        return ft_get_adobe_glyph_index( glyph_name, dot ) | VARIANT_BIT;
d158 3
a170 2
    FT_UInt32   unicode1 = BASE_GLYPH( map1->unicode );
    FT_UInt32   unicode2 = BASE_GLYPH( map2->unicode );
d173 1
a173 5
    /* sort base glyphs before glyph variants */
    if ( unicode1 == unicode2 )
      return map1->unicode - map2->unicode;
    else
      return unicode1 - unicode2;
d177 1
a177 1
  /* Build a table that maps Unicode values to glyph indices. */
d179 4
a182 6
  ps_unicodes_init( FT_Memory             memory,
                    PS_Unicodes           table,
                    FT_UInt               num_glyphs,
                    PS_GetGlyphNameFunc   get_glyph_name,
                    PS_FreeGlyphNameFunc  free_glyph_name,
                    FT_Pointer            glyph_data )
d203 1
a203 1
        const char*  gname = get_glyph_name( glyph_data, n );
d210 1
a210 1
          if ( BASE_GLYPH( uni_char ) != 0 )
d212 1
a212 1
            map->unicode     = uni_char;
a215 3

          if ( free_glyph_name )
            free_glyph_name( glyph_data, gname );
d219 1
a219 1
      /* now compress the table a bit */
d222 5
d231 1
a231 14
          error = PSnames_Err_Invalid_Argument;  /* No unicode chars here! */
      }
      else {
        /* Reallocate if the number of used entries is much smaller. */
        if ( count < num_glyphs / 2 )
        {
          (void)FT_RENEW_ARRAY( table->maps, num_glyphs, count );
          error = PSnames_Err_Ok;
        }

        /* Sort the table in increasing order of unicode values, */
        /* taking care of glyph variants.                        */
        ft_qsort( table->maps, count, sizeof ( PS_UniMap ),
                  compare_uni_maps );
d233 3
d245 2
a246 2
  ps_unicodes_char_index( PS_Unicodes  table,
                          FT_UInt32    unicode )
d248 1
a248 1
    PS_UniMap  *min, *max, *mid, *result = NULL;
d251 1
a251 1
    /* Perform a binary search on the table. */
d258 1
a258 5
      FT_UInt32  base_glyph;


      mid = min + ( ( max - min ) >> 1 );

d260 1
a260 9
      {
        result = mid;
        break;
      }

      base_glyph = BASE_GLYPH( mid->unicode );

      if ( base_glyph == unicode )
        result = mid; /* remember match but continue search for base glyph */
d265 1
a265 1
      if ( base_glyph < unicode )
d271 1
a271 4
    if ( result )
      return result->glyph_index;
    else
      return 0;
d276 2
a277 2
  ps_unicodes_char_next( PS_Unicodes  table,
                         FT_UInt32   *unicode )
d279 1
a279 2
    FT_UInt    result    = 0;
    FT_UInt32  char_code = *unicode + 1;
d282 2
a283 6
    {
      FT_UInt     min = 0;
      FT_UInt     max = table->num_maps;
      FT_UInt     mid;
      PS_UniMap*  map;
      FT_UInt32   base_glyph;
d285 2
d288 5
a292 4
      while ( min < max )
      {
        mid = min + ( ( max - min ) >> 1 );
        map = table->maps + mid;
d294 2
a295 5
        if ( map->unicode == char_code )
        {
          result = map->glyph_index;
          goto Exit;
        }
d297 5
a301 1
        base_glyph = BASE_GLYPH( map->unicode );
d303 2
a304 2
        if ( base_glyph == char_code )
          result = map->glyph_index;
d306 5
a310 18
        if ( base_glyph < char_code )
          min = mid + 1;
        else
          max = mid;
      }

      if ( result )
        goto Exit;               /* we have a variant glyph */

      /* we didn't find it; check whether we have a map just above it */
      char_code = 0;

      if ( min < table->num_maps )
      {
        map       = table->maps + min;
        result    = map->glyph_index;
        char_code = BASE_GLYPH( map->unicode );
      }
d313 1
a313 3
  Exit:
    *unicode = char_code;
    return result;
d323 1
a323 1
    if ( name_index >= FT_NUM_MAC_NAMES )
d326 1
a326 1
    return ft_standard_glyph_names + ft_mac_names[name_index];
d333 1
a333 4
    if ( sid >= FT_NUM_SID_NAMES )
      return 0;

    return ft_standard_glyph_names + ft_sid_names[sid];
d356 2
a357 2
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings,
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
d29 1
a29 1
#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
a182 89
  /* support for old WGL4 fonts */

#define WGL_EXTRA_LIST_SIZE  8

  static const FT_UInt32  ft_wgl_extra_unicodes[WGL_EXTRA_LIST_SIZE] =
  {
    0x0394,
    0x03A9,
    0x2215,
    0x00AD,
    0x02C9,
    0x03BC,
    0x2219,
    0x00A0
  };

  static const char  ft_wgl_extra_glyph_names[] =
  {
    'D','e','l','t','a',0,
    'O','m','e','g','a',0,
    'f','r','a','c','t','i','o','n',0,
    'h','y','p','h','e','n',0,
    'm','a','c','r','o','n',0,
    'm','u',0,
    'p','e','r','i','o','d','c','e','n','t','e','r','e','d',0,
    's','p','a','c','e',0
  };

  static const FT_Int
  ft_wgl_extra_glyph_name_offsets[WGL_EXTRA_LIST_SIZE] =
  {
     0,
     6,
    12,
    21,
    28,
    35,
    38,
    53
  };


  static void
  ps_check_wgl_name( const char*  gname,
                     FT_UInt      glyph,
                     FT_UInt*     wgl_glyphs,
                     FT_UInt     *states )
  {
    FT_UInt  n;


    for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
    {
      if ( ft_strcmp( ft_wgl_extra_glyph_names +
                        ft_wgl_extra_glyph_name_offsets[n], gname ) == 0 )
      {
        if ( states[n] == 0 )
        {
          /* mark this WGL extra glyph as a candidate for the cmap */
          states[n]     = 1;
          wgl_glyphs[n] = glyph;
        }

        return;
      }
    }
  }


  static void
  ps_check_wgl_unicode( FT_UInt32  uni_char,
                        FT_UInt   *states )
  {
    FT_UInt  n;


    for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
    {
      if ( uni_char == ft_wgl_extra_unicodes[n] )
      {
        /* disable this WGL extra glyph from being added to the cmap */
        states[n] = 2;

        return;
      }
    }
  }


a193 3
    FT_UInt  wgl_list_states[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UInt  wgl_glyphs[WGL_EXTRA_LIST_SIZE];

d199 1
a199 1
    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + WGL_EXTRA_LIST_SIZE ) )
a215 1
          ps_check_wgl_name( gname, n, wgl_glyphs, wgl_list_states );
a219 1
            ps_check_wgl_unicode( uni_char, wgl_list_states );
a229 13
      for ( n = 0; n < WGL_EXTRA_LIST_SIZE; n++ )
      {
        if ( wgl_list_states[n] == 1 )
        {
          /* This glyph name has an additional WGL4 representation. */
          /* Add it to the cmap.                                    */

          map->unicode     = ft_wgl_extra_unicodes[n];
          map->glyph_index = wgl_glyphs[n];
          map++;
        }
      }

d430 1
a430 1
#endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
d444 1
a444 1
#ifndef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006 by                         */
d35 1
a35 5
#define VARIANT_BIT         ( 1L << 31 )
#define BASE_GLYPH( code )  ( (code) & ~VARIANT_BIT )


  /* Return the Unicode value corresponding to a given glyph.  Note that */
d37 1
a37 2
  /* the name, as in `A.swash' or `e.final'; in this case, the           */
  /* VARIANT_BIT is set in the return value.                             */
d42 5
d80 1
a80 3
        /* Exit if a non-uppercase hexadecimal character was found   */
        /* -- this also catches character codes below `0' since such */
        /* negative numbers cast to `unsigned int' are far too big.  */
d88 2
a89 7
      if ( count == 0 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return value ^ VARIANT_BIT;
      }
d123 2
a124 7
      if ( count <= 2 )
      {
        if ( *p == '\0' )
          return value;
        if ( *p == '.' )
          return value ^ VARIANT_BIT;
      }
d127 2
a128 2
    /* Look for a non-initial dot in the glyph name in order to */
    /* find variants like `A.swash', `e.final', etc.            */
d130 8
a137 2
      const char*  p   = glyph_name;
      const char*  dot = NULL;
d139 1
d141 1
a141 1
      for ( ; *p; p++ )
d143 3
a145 5
        if ( *p == '.' && p > glyph_name )
        {
          dot = p;
          break;
        }
d147 7
d155 2
a156 5
      /* now look up the glyph in the Adobe Glyph List */
      if ( !dot )
        return ft_get_adobe_glyph_index( glyph_name, p );
      else
        return ft_get_adobe_glyph_index( glyph_name, dot ) ^ VARIANT_BIT;
d158 3
a170 2
    FT_UInt32   unicode1 = BASE_GLYPH( map1->unicode );
    FT_UInt32   unicode2 = BASE_GLYPH( map2->unicode );
d173 1
a173 5
    /* sort base glyphs before glyph variants */
    if ( unicode1 == unicode2 )
      return map1->unicode - map2->unicode;
    else
      return unicode1 - unicode2;
d177 1
a177 1
  /* Build a table that maps Unicode values to glyph indices. */
d179 4
a182 5
  ps_unicodes_init( FT_Memory          memory,
                    PS_Unicodes        table,
                    FT_UInt            num_glyphs,
                    PS_Glyph_NameFunc  get_glyph_name,
                    FT_Pointer         glyph_data )
d203 1
a203 1
        const char*  gname = get_glyph_name( glyph_data, n );
d210 1
a210 1
          if ( BASE_GLYPH( uni_char ) != 0 )
d212 1
a212 1
            map->unicode     = uni_char;
d219 1
a219 1
      /* now compress the table a bit */
d222 5
d231 1
a231 14
          error = PSnames_Err_Invalid_Argument;  /* No unicode chars here! */
      }
      else {
        /* Reallocate if the number of used entries is much smaller. */
        if ( count < num_glyphs / 2 )
        {
          (void)FT_RENEW_ARRAY( table->maps, num_glyphs, count );
          error = PSnames_Err_Ok;
        }

        /* Sort the table in increasing order of unicode values, */
        /* taking care of glyph variants.                        */
        ft_qsort( table->maps, count, sizeof ( PS_UniMap ),
                  compare_uni_maps );
d233 3
d245 2
a246 2
  ps_unicodes_char_index( PS_Unicodes  table,
                          FT_UInt32    unicode )
d248 1
a248 1
    PS_UniMap  *min, *max, *mid, *result = NULL;
d251 1
a251 1
    /* Perform a binary search on the table. */
d258 1
a258 5
      FT_UInt32  base_glyph;


      mid = min + ( ( max - min ) >> 1 );

d260 1
a260 9
      {
        result = mid;
        break;
      }

      base_glyph = BASE_GLYPH( mid->unicode );

      if ( base_glyph == unicode )
        result = mid; /* remember match but continue search for base glyph */
d265 1
a265 1
      if ( base_glyph < unicode )
d271 1
a271 4
    if ( result )
      return result->glyph_index;
    else
      return 0;
d276 2
a277 2
  ps_unicodes_char_next( PS_Unicodes  table,
                         FT_UInt32   *unicode )
d279 1
a279 2
    FT_UInt    result    = 0;
    FT_UInt32  char_code = *unicode + 1;
d282 2
a283 6
    {
      FT_UInt     min = 0;
      FT_UInt     max = table->num_maps;
      FT_UInt     mid;
      PS_UniMap*  map;
      FT_UInt32   base_glyph;
d285 2
d288 5
a292 4
      while ( min < max )
      {
        mid = min + ( ( max - min ) >> 1 );
        map = table->maps + mid;
d294 2
a295 5
        if ( map->unicode == char_code )
        {
          result = map->glyph_index;
          goto Exit;
        }
d297 5
a301 1
        base_glyph = BASE_GLYPH( map->unicode );
d303 2
a304 2
        if ( base_glyph == char_code )
          result = map->glyph_index;
d306 5
a310 18
        if ( base_glyph < char_code )
          min = mid + 1;
        else
          max = mid;
      }

      if ( result )
        goto Exit;               /* we have a variant glyph */

      /* we didn't find it; check whether we have a map just above it */
      char_code = 0;

      if ( min < table->num_maps )
      {
        map       = table->maps + min;
        result    = map->glyph_index;
        char_code = BASE_GLYPH( map->unicode );
      }
d313 1
a313 3
  Exit:
    *unicode = char_code;
    return result;
d323 1
a323 1
    if ( name_index >= FT_NUM_MAC_NAMES )
d326 1
a326 1
    return ft_standard_glyph_names + ft_mac_names[name_index];
d333 1
a333 4
    if ( sid >= FT_NUM_SID_NAMES )
      return 0;

    return ft_standard_glyph_names + ft_sid_names[sid];
d356 2
a357 2
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings,
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
a26 1
#include "pspic.h"
d29 1
a29 1
#ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
d35 2
a36 2
#define VARIANT_BIT         0x80000000UL
#define BASE_GLYPH( code )  ( (FT_UInt32)( (code) & ~VARIANT_BIT ) )
d60 1
a60 1
      FT_UInt32    value = 0;
d95 1
a95 1
          return (FT_UInt32)( value | VARIANT_BIT );
d100 1
a100 1
    /* hexadecimal digits, it is a hard-coded unicode character code. */
d104 1
a104 1
      FT_UInt32    value = 0;
d135 1
a135 1
          return (FT_UInt32)( value | VARIANT_BIT );
d157 1
a157 1
        return (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );
d159 1
a159 2
        return (FT_UInt32)( ft_get_adobe_glyph_index( glyph_name, dot ) |
                            VARIANT_BIT );
d177 1
a177 8
    {
      if ( map1->unicode > map2->unicode )
        return 1;
      else if ( map1->unicode < map2->unicode )
        return -1;
      else
        return 0;
    }
d179 1
a179 106
    {
      if ( unicode1 > unicode2 )
        return 1;
      else if ( unicode1 < unicode2 )
        return -1;
      else
        return 0;
    }
  }


  /* support for extra glyphs not handled (well) in AGL; */
  /* we add extra mappings for them if necessary         */

#define EXTRA_GLYPH_LIST_SIZE  10

  static const FT_UInt32  ft_extra_glyph_unicodes[EXTRA_GLYPH_LIST_SIZE] =
  {
    /* WGL 4 */
    0x0394,
    0x03A9,
    0x2215,
    0x00AD,
    0x02C9,
    0x03BC,
    0x2219,
    0x00A0,
    /* Romanian */
    0x021A,
    0x021B
  };

  static const char  ft_extra_glyph_names[] =
  {
    'D','e','l','t','a',0,
    'O','m','e','g','a',0,
    'f','r','a','c','t','i','o','n',0,
    'h','y','p','h','e','n',0,
    'm','a','c','r','o','n',0,
    'm','u',0,
    'p','e','r','i','o','d','c','e','n','t','e','r','e','d',0,
    's','p','a','c','e',0,
    'T','c','o','m','m','a','a','c','c','e','n','t',0,
    't','c','o','m','m','a','a','c','c','e','n','t',0
  };

  static const FT_Int
  ft_extra_glyph_name_offsets[EXTRA_GLYPH_LIST_SIZE] =
  {
     0,
     6,
    12,
    21,
    28,
    35,
    38,
    53,
    59,
    72
  };


  static void
  ps_check_extra_glyph_name( const char*  gname,
                             FT_UInt      glyph,
                             FT_UInt*     extra_glyphs,
                             FT_UInt     *states )
  {
    FT_UInt  n;


    for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
    {
      if ( ft_strcmp( ft_extra_glyph_names +
                        ft_extra_glyph_name_offsets[n], gname ) == 0 )
      {
        if ( states[n] == 0 )
        {
          /* mark this extra glyph as a candidate for the cmap */
          states[n]     = 1;
          extra_glyphs[n] = glyph;
        }

        return;
      }
    }
  }


  static void
  ps_check_extra_glyph_unicode( FT_UInt32  uni_char,
                                FT_UInt   *states )
  {
    FT_UInt  n;


    for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
    {
      if ( uni_char == ft_extra_glyph_unicodes[n] )
      {
        /* disable this extra glyph from being added to the cmap */
        states[n] = 2;

        return;
      }
    }
d185 5
a189 6
  ps_unicodes_init( FT_Memory             memory,
                    PS_Unicodes           table,
                    FT_UInt               num_glyphs,
                    PS_GetGlyphNameFunc   get_glyph_name,
                    PS_FreeGlyphNameFunc  free_glyph_name,
                    FT_Pointer            glyph_data )
a192 3
    FT_UInt  extra_glyph_list_states[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UInt  extra_glyphs[EXTRA_GLYPH_LIST_SIZE];

d198 1
a198 1
    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )
a214 2
          ps_check_extra_glyph_name( gname, n,
                                     extra_glyphs, extra_glyph_list_states );
a218 2
            ps_check_extra_glyph_unicode( uni_char,
                                          extra_glyph_list_states );
a222 16

          if ( free_glyph_name )
            free_glyph_name( glyph_data, gname );
        }
      }

      for ( n = 0; n < EXTRA_GLYPH_LIST_SIZE; n++ )
      {
        if ( extra_glyph_list_states[n] == 1 )
        {
          /* This glyph name has an additional representation. */
          /* Add it to the cmap.                               */

          map->unicode     = ft_extra_glyph_unicodes[n];
          map->glyph_index = extra_glyphs[n];
          map++;
d302 1
a302 1
  static FT_UInt32
d383 3
d387 1
a387 1
  FT_DEFINE_SERVICE_PSCMAPSREC(pscmaps_interface, 
a392 7
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings,

    t1_standard_encoding,
    t1_expert_encoding
  )

a394 1
  FT_DEFINE_SERVICE_PSCMAPSREC(pscmaps_interface, 
d400 2
d407 1
a407 8
  )

#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */


  FT_DEFINE_SERVICEDESCREC1(pscmaps_services, 
    FT_SERVICE_ID_POSTSCRIPT_CMAPS, &FT_PSCMAPS_INTERFACE_GET
  )
d410 5
d423 1
a423 1
    return ft_service_list_lookup( FT_PSCMAPS_SERVICES_GET, service_id );
d426 1
a426 1
#endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
a428 5
#ifndef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
#define PUT_PS_NAMES_SERVICE(a) 0
#else
#define PUT_PS_NAMES_SERVICE(a) a
#endif
d430 3
a432 2
  FT_DEFINE_MODULE(psnames_module_class,
  
d440 2
a441 1
    PUT_PS_NAMES_SERVICE((void*)&FT_PSCMAPS_INTERFACE_GET),   /* module specific interface */
d444 8
a451 3
    (FT_Module_Requester)  PUT_PS_NAMES_SERVICE(psnames_get_service)
  )

@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 1996-2016 by                                                 */
a19 1
#include FT_INTERNAL_DEBUG_H
a23 2

#define  DEFINE_PS_TABLES
d314 1
a314 1
    table->maps     = NULL;
a368 1
        /* No unicode chars here! */
d371 1
a371 1
          error = FT_THROW( No_Unicode_Glyph_Name );
d373 1
a373 2
      else
      {
d378 1
a378 1
          error = FT_Err_Ok;
d522 5
d528 2
a529 7
  FT_DEFINE_SERVICE_PSCMAPSREC(
    pscmaps_interface,

    (PS_Unicode_ValueFunc)     ps_unicode_value,        /* unicode_value         */
    (PS_Unicodes_InitFunc)     ps_unicodes_init,        /* unicodes_init         */
    (PS_Unicodes_CharIndexFunc)ps_unicodes_char_index,  /* unicodes_char_index   */
    (PS_Unicodes_CharNextFunc) ps_unicodes_char_next,   /* unicodes_char_next    */
d531 2
a532 5
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   /* macintosh_name        */
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, /* adobe_std_strings     */

    t1_standard_encoding,                               /* adobe_std_encoding    */
    t1_expert_encoding                                  /* adobe_expert_encoding */
d537 5
a541 7
  FT_DEFINE_SERVICE_PSCMAPSREC(
    pscmaps_interface,

    NULL,                                               /* unicode_value         */
    NULL,                                               /* unicodes_init         */
    NULL,                                               /* unicodes_char_index   */
    NULL,                                               /* unicodes_char_next    */
d543 2
a544 2
    (PS_Macintosh_NameFunc)    ps_get_macintosh_name,   /* macintosh_name        */
    (PS_Adobe_Std_StringsFunc) ps_get_standard_strings, /* adobe_std_strings     */
d546 2
a547 2
    t1_standard_encoding,                               /* adobe_std_encoding    */
    t1_expert_encoding                                  /* adobe_expert_encoding */
d553 4
a556 2
  FT_DEFINE_SERVICEDESCREC1(
    pscmaps_services,
a557 1
    FT_SERVICE_ID_POSTSCRIPT_CMAPS, &PSCMAPS_INTERFACE_GET )
a563 11
    /* PSCMAPS_SERVICES_GET dereferences `library' in PIC mode */
#ifdef FT_CONFIG_OPTION_PIC
    FT_Library  library;


    if ( !module )
      return NULL;
    library = module->library;
    if ( !library )
      return NULL;
#else
a564 1
#endif
d566 1
a566 1
    return ft_service_list_lookup( PSCMAPS_SERVICES_GET, service_id );
d573 1
a573 1
#define PUT_PS_NAMES_SERVICE( a )  NULL
d575 1
a575 1
#define PUT_PS_NAMES_SERVICE( a )  a
d578 2
a579 3
  FT_DEFINE_MODULE(
    psnames_module_class,

d587 5
a591 2
    PUT_PS_NAMES_SERVICE(
      (void*)&PSCMAPS_INTERFACE_GET ),   /* module specific interface */
a592 4
    (FT_Module_Constructor)NULL,                                       /* module_init   */
    (FT_Module_Destructor) NULL,                                       /* module_done   */
    (FT_Module_Requester)  PUT_PS_NAMES_SERVICE( psnames_get_service ) /* get_interface */
  )
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
