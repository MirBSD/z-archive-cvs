head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.18;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.35;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.29;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.04.50;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.35;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.51;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.38.09;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.54;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.42;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.02;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin writing system (body).        */
/*                                                                         */
/*  Copyright 2003-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_ADVANCES_H
#include FT_INTERNAL_DEBUG_H

#include "afglobal.h"
#include "afpic.h"
#include "aflatin.h"
#include "aferrors.h"


#ifdef AF_CONFIG_OPTION_USE_WARPER
#include "afwarp.h"
#endif


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_aflatin


  /* needed for computation of round vs. flat segments */
#define FLAT_THRESHOLD( x )  ( x / 14 )


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* Find segments and links, compute all stem widths, and initialize */
  /* standard width and height for the glyph with given charcode.     */

  FT_LOCAL_DEF( void )
  af_latin_metrics_init_widths( AF_LatinMetrics  metrics,
                                FT_Face          face )
  {
    /* scan the array of segments in each direction */
    AF_GlyphHintsRec  hints[1];


    FT_TRACE5(( "\n"
                "latin standard widths computation (style `%s')\n"
                "=====================================================\n"
                "\n",
                af_style_names[metrics->root.style_class->style] ));

    af_glyph_hints_init( hints, face->memory );

    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
    metrics->axis[AF_DIMENSION_VERT].width_count = 0;

    {
      FT_Error            error;
      FT_ULong            glyph_index;
      int                 dim;
      AF_LatinMetricsRec  dummy[1];
      AF_Scaler           scaler = &dummy->root.scaler;

#ifdef FT_CONFIG_OPTION_PIC
      AF_FaceGlobals  globals = metrics->root.globals;
#endif

      AF_StyleClass   style_class  = metrics->root.style_class;
      AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                       [style_class->script];

      void*        shaper_buf;
      const char*  p;

#ifdef FT_DEBUG_LEVEL_TRACE
      FT_ULong  ch = 0;
#endif

      p          = script_class->standard_charstring;
      shaper_buf = af_shaper_buf_create( face );

      /*
       * We check a list of standard characters to catch features like
       * `c2sc' (small caps from caps) that don't contain lowercase letters
       * by definition, or other features that mainly operate on numerals.
       * The first match wins.
       */

      glyph_index = 0;
      while ( *p )
      {
        unsigned int  num_idx;

#ifdef FT_DEBUG_LEVEL_TRACE
        const char*  p_old;
#endif


        while ( *p == ' ' )
          p++;

#ifdef FT_DEBUG_LEVEL_TRACE
        p_old = p;
        GET_UTF8_CHAR( ch, p_old );
#endif

        /* reject input that maps to more than a single glyph */
        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
        if ( num_idx > 1 )
          continue;

        /* otherwise exit loop if we have a result */
        glyph_index = af_shaper_get_elem( &metrics->root,
                                          shaper_buf,
                                          0,
                                          NULL,
                                          NULL );
        if ( glyph_index )
          break;
      }

      af_shaper_buf_destroy( face, shaper_buf );

      if ( !glyph_index )
        goto Exit;

      FT_TRACE5(( "standard character: U+%04lX (glyph index %d)\n",
                  ch, glyph_index ));

      error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
      if ( error || face->glyph->outline.n_points <= 0 )
        goto Exit;

      FT_ZERO( dummy );

      dummy->units_per_em = metrics->units_per_em;

      scaler->x_scale = 0x10000L;
      scaler->y_scale = 0x10000L;
      scaler->x_delta = 0;
      scaler->y_delta = 0;

      scaler->face        = face;
      scaler->render_mode = FT_RENDER_MODE_NORMAL;
      scaler->flags       = 0;

      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );

      error = af_glyph_hints_reload( hints, &face->glyph->outline );
      if ( error )
        goto Exit;

      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis  axis    = &metrics->axis[dim];
        AF_AxisHints  axhints = &hints->axis[dim];
        AF_Segment    seg, limit, link;
        FT_UInt       num_widths = 0;


        error = af_latin_hints_compute_segments( hints,
                                                 (AF_Dimension)dim );
        if ( error )
          goto Exit;

        /*
         *  We assume that the glyphs selected for the stem width
         *  computation are `featureless' enough so that the linking
         *  algorithm works fine without adjustments of its scoring
         *  function.
         */
        af_latin_hints_link_segments( hints,
                                      0,
                                      NULL,
                                      (AF_Dimension)dim );

        seg   = axhints->segments;
        limit = seg + axhints->num_segments;

        for ( ; seg < limit; seg++ )
        {
          link = seg->link;

          /* we only consider stem segments there! */
          if ( link && link->link == seg && link > seg )
          {
            FT_Pos  dist;


            dist = seg->pos - link->pos;
            if ( dist < 0 )
              dist = -dist;

            if ( num_widths < AF_LATIN_MAX_WIDTHS )
              axis->widths[num_widths++].org = dist;
          }
        }

        /* this also replaces multiple almost identical stem widths */
        /* with a single one (the value 100 is heuristic)           */
        af_sort_and_quantize_widths( &num_widths, axis->widths,
                                     dummy->units_per_em / 100 );
        axis->width_count = num_widths;
      }

    Exit:
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis  axis = &metrics->axis[dim];
        FT_Pos        stdw;


        stdw = ( axis->width_count > 0 ) ? axis->widths[0].org
                                         : AF_LATIN_CONSTANT( metrics, 50 );

        /* let's try 20% of the smallest width */
        axis->edge_distance_threshold = stdw / 5;
        axis->standard_width          = stdw;
        axis->extra_light             = 0;

#ifdef FT_DEBUG_LEVEL_TRACE
        {
          FT_UInt  i;


          FT_TRACE5(( "%s widths:\n",
                      dim == AF_DIMENSION_VERT ? "horizontal"
                                               : "vertical" ));

          FT_TRACE5(( "  %d (standard)", axis->standard_width ));
          for ( i = 1; i < axis->width_count; i++ )
            FT_TRACE5(( " %d", axis->widths[i].org ));

          FT_TRACE5(( "\n" ));
        }
#endif
      }
    }

    FT_TRACE5(( "\n" ));

    af_glyph_hints_done( hints );
  }


  /* Find all blue zones.  Flat segments give the reference points, */
  /* round segments the overshoot positions.                        */

  static void
  af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
                               FT_Face          face )
  {
    FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
    FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];

    FT_UInt       num_flats;
    FT_UInt       num_rounds;

    AF_LatinBlue  blue;
    FT_Error      error;
    AF_LatinAxis  axis = &metrics->axis[AF_DIMENSION_VERT];
    FT_Outline    outline;

    AF_StyleClass  sc = metrics->root.style_class;

    AF_Blue_Stringset         bss = sc->blue_stringset;
    const AF_Blue_StringRec*  bs  = &af_blue_stringsets[bss];

    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );

    void*  shaper_buf;


    /* we walk over the blue character strings as specified in the */
    /* style's entry in the `af_blue_stringset' array              */

    FT_TRACE5(( "latin blue zones computation\n"
                "============================\n"
                "\n" ));

    shaper_buf = af_shaper_buf_create( face );

    for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
    {
      const char*  p = &af_blue_strings[bs->string];
      FT_Pos*      blue_ref;
      FT_Pos*      blue_shoot;
      FT_Pos       ascender;
      FT_Pos       descender;


#ifdef FT_DEBUG_LEVEL_TRACE
      {
        FT_Bool  have_flag = 0;


        FT_TRACE5(( "blue zone %d", axis->blue_count ));

        if ( bs->properties )
        {
          FT_TRACE5(( " (" ));

          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          {
            FT_TRACE5(( "top" ));
            have_flag = 1;
          }
          else if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
          {
            FT_TRACE5(( "sub top" ));
            have_flag = 1;
          }

          if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "neutral" ));
            have_flag = 1;
          }

          if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "small top" ));
            have_flag = 1;
          }

          if ( AF_LATIN_IS_LONG_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "long" ));
          }

          FT_TRACE5(( ")" ));
        }

        FT_TRACE5(( ":\n" ));
      }
#endif /* FT_DEBUG_LEVEL_TRACE */

      num_flats  = 0;
      num_rounds = 0;
      ascender   = 0;
      descender  = 0;

      while ( *p )
      {
        FT_ULong    glyph_index;
        FT_Long     y_offset;
        FT_Int      best_point, best_contour_first, best_contour_last;
        FT_Vector*  points;

        FT_Pos   best_y_extremum;                      /* same as points.y */
        FT_Bool  best_round = 0;

        unsigned int  i, num_idx;

#ifdef FT_DEBUG_LEVEL_TRACE
        const char*  p_old;
        FT_ULong     ch;
#endif


        while ( *p == ' ' )
          p++;

#ifdef FT_DEBUG_LEVEL_TRACE
        p_old = p;
        GET_UTF8_CHAR( ch, p_old );
#endif

        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );

        if ( !num_idx )
        {
          FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
          continue;
        }

        if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          best_y_extremum = FT_INT_MIN;
        else
          best_y_extremum = FT_INT_MAX;

        /* iterate over all glyph elements of the character cluster */
        /* and get the data of the `biggest' one                    */
        for ( i = 0; i < num_idx; i++ )
        {
          FT_Pos   best_y;
          FT_Bool  round = 0;


          /* load the character in the face -- skip unknown or empty ones */
          glyph_index = af_shaper_get_elem( &metrics->root,
                                            shaper_buf,
                                            i,
                                            NULL,
                                            &y_offset );
          if ( glyph_index == 0 )
          {
            FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
            continue;
          }

          error   = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
          outline = face->glyph->outline;
          /* reject glyphs that don't produce any rendering */
          if ( error || outline.n_points <= 2 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            if ( num_idx == 1 )
              FT_TRACE5(( "  U+%04lX contains no (usable) outlines\n", ch ));
            else
              FT_TRACE5(( "  component %d of cluster starting with U+%04lX"
                          " contains no (usable) outlines\n", i, ch ));
#endif
            continue;
          }

          /* now compute min or max point indices and coordinates */
          points             = outline.points;
          best_point         = -1;
          best_y             = 0;  /* make compiler happy */
          best_contour_first = 0;  /* ditto */
          best_contour_last  = 0;  /* ditto */

          {
            FT_Int  nn;
            FT_Int  first = 0;
            FT_Int  last  = -1;


            for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )
            {
              FT_Int  old_best_point = best_point;
              FT_Int  pp;


              last = outline.contours[nn];

              /* Avoid single-point contours since they are never      */
              /* rasterized.  In some fonts, they correspond to mark   */
              /* attachment points that are way outside of the glyph's */
              /* real outline.                                         */
              if ( last <= first )
                continue;

              if ( AF_LATIN_IS_TOP_BLUE( bs )     ||
                   AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
              {
                for ( pp = first; pp <= last; pp++ )
                {
                  if ( best_point < 0 || points[pp].y > best_y )
                  {
                    best_point = pp;
                    best_y     = points[pp].y;
                    ascender   = FT_MAX( ascender, best_y + y_offset );
                  }
                  else
                    descender = FT_MIN( descender, points[pp].y + y_offset );
                }
              }
              else
              {
                for ( pp = first; pp <= last; pp++ )
                {
                  if ( best_point < 0 || points[pp].y < best_y )
                  {
                    best_point = pp;
                    best_y     = points[pp].y;
                    descender  = FT_MIN( descender, best_y + y_offset );
                  }
                  else
                    ascender = FT_MAX( ascender, points[pp].y + y_offset );
                }
              }

              if ( best_point != old_best_point )
              {
                best_contour_first = first;
                best_contour_last  = last;
              }
            }
          }

          /* now check whether the point belongs to a straight or round   */
          /* segment; we first need to find in which contour the extremum */
          /* lies, then inspect its previous and next points              */
          if ( best_point >= 0 )
          {
            FT_Pos  best_x = points[best_point].x;
            FT_Int  prev, next;
            FT_Int  best_segment_first, best_segment_last;
            FT_Int  best_on_point_first, best_on_point_last;
            FT_Pos  dist;


            best_segment_first = best_point;
            best_segment_last  = best_point;

            if ( FT_CURVE_TAG( outline.tags[best_point] ) == FT_CURVE_TAG_ON )
            {
              best_on_point_first = best_point;
              best_on_point_last  = best_point;
            }
            else
            {
              best_on_point_first = -1;
              best_on_point_last  = -1;
            }

            /* look for the previous and next points on the contour  */
            /* that are not on the same Y coordinate, then threshold */
            /* the `closeness'...                                    */
            prev = best_point;
            next = prev;

            do
            {
              if ( prev > best_contour_first )
                prev--;
              else
                prev = best_contour_last;

              dist = FT_ABS( points[prev].y - best_y );
              /* accept a small distance or a small angle (both values are */
              /* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
              if ( dist > 5 )
                if ( FT_ABS( points[prev].x - best_x ) <= 20 * dist )
                  break;

              best_segment_first = prev;

              if ( FT_CURVE_TAG( outline.tags[prev] ) == FT_CURVE_TAG_ON )
              {
                best_on_point_first = prev;
                if ( best_on_point_last < 0 )
                  best_on_point_last = prev;
              }

            } while ( prev != best_point );

            do
            {
              if ( next < best_contour_last )
                next++;
              else
                next = best_contour_first;

              dist = FT_ABS( points[next].y - best_y );
              if ( dist > 5 )
                if ( FT_ABS( points[next].x - best_x ) <= 20 * dist )
                  break;

              best_segment_last = next;

              if ( FT_CURVE_TAG( outline.tags[next] ) == FT_CURVE_TAG_ON )
              {
                best_on_point_last = next;
                if ( best_on_point_first < 0 )
                  best_on_point_first = next;
              }

            } while ( next != best_point );

            if ( AF_LATIN_IS_LONG_BLUE( bs ) )
            {
              /* If this flag is set, we have an additional constraint to  */
              /* get the blue zone distance: Find a segment of the topmost */
              /* (or bottommost) contour that is longer than a heuristic   */
              /* threshold.  This ensures that small bumps in the outline  */
              /* are ignored (for example, the `vertical serifs' found in  */
              /* many Hebrew glyph designs).                               */

              /* If this segment is long enough, we are done.  Otherwise,  */
              /* search the segment next to the extremum that is long      */
              /* enough, has the same direction, and a not too large       */
              /* vertical distance from the extremum.  Note that the       */
              /* algorithm doesn't check whether the found segment is      */
              /* actually the one (vertically) nearest to the extremum.    */

              /* heuristic threshold value */
              FT_Pos  length_threshold = metrics->units_per_em / 25;


              dist = FT_ABS( points[best_segment_last].x -
                               points[best_segment_first].x );

              if ( dist < length_threshold                       &&
                   best_segment_last - best_segment_first + 2 <=
                     best_contour_last - best_contour_first      )
              {
                /* heuristic threshold value */
                FT_Pos  height_threshold = metrics->units_per_em / 4;

                FT_Int   first;
                FT_Int   last;
                FT_Bool  hit;

                /* we intentionally declare these two variables        */
                /* outside of the loop since various compilers emit    */
                /* incorrect warning messages otherwise, talking about */
                /* `possibly uninitialized variables'                  */
                FT_Int  p_first = 0;            /* make compiler happy */
                FT_Int  p_last  = 0;

                FT_Bool  left2right;


                /* compute direction */
                prev = best_point;

                do
                {
                  if ( prev > best_contour_first )
                    prev--;
                  else
                    prev = best_contour_last;

                  if ( points[prev].x != best_x )
                    break;

                } while ( prev != best_point );

                /* skip glyph for the degenerate case */
                if ( prev == best_point )
                  continue;

                left2right = FT_BOOL( points[prev].x < points[best_point].x );

                first = best_segment_last;
                last  = first;
                hit   = 0;

                do
                {
                  FT_Bool  l2r;
                  FT_Pos   d;


                  if ( !hit )
                  {
                    /* no hit; adjust first point */
                    first = last;

                    /* also adjust first and last on point */
                    if ( FT_CURVE_TAG( outline.tags[first] ) ==
                           FT_CURVE_TAG_ON )
                    {
                      p_first = first;
                      p_last  = first;
                    }
                    else
                    {
                      p_first = -1;
                      p_last  = -1;
                    }

                    hit = 1;
                  }

                  if ( last < best_contour_last )
                    last++;
                  else
                    last = best_contour_first;

                  if ( FT_ABS( best_y - points[first].y ) > height_threshold )
                  {
                    /* vertical distance too large */
                    hit = 0;
                    continue;
                  }

                  /* same test as above */
                  dist = FT_ABS( points[last].y - points[first].y );
                  if ( dist > 5 )
                    if ( FT_ABS( points[last].x - points[first].x ) <=
                           20 * dist )
                    {
                      hit = 0;
                      continue;
                    }

                  if ( FT_CURVE_TAG( outline.tags[last] ) == FT_CURVE_TAG_ON )
                  {
                    p_last = last;
                    if ( p_first < 0 )
                      p_first = last;
                  }

                  l2r = FT_BOOL( points[first].x < points[last].x );
                  d   = FT_ABS( points[last].x - points[first].x );

                  if ( l2r == left2right     &&
                       d >= length_threshold )
                  {
                    /* all constraints are met; update segment after */
                    /* finding its end                               */
                    do
                    {
                      if ( last < best_contour_last )
                        last++;
                      else
                        last = best_contour_first;

                      d = FT_ABS( points[last].y - points[first].y );
                      if ( d > 5 )
                        if ( FT_ABS( points[next].x - points[first].x ) <=
                               20 * dist )
                        {
                          if ( last > best_contour_first )
                            last--;
                          else
                            last = best_contour_last;
                          break;
                        }

                      p_last = last;

                      if ( FT_CURVE_TAG( outline.tags[last] ) ==
                             FT_CURVE_TAG_ON )
                      {
                        p_last = last;
                        if ( p_first < 0 )
                          p_first = last;
                      }

                    } while ( last != best_segment_first );

                    best_y = points[first].y;

                    best_segment_first = first;
                    best_segment_last  = last;

                    best_on_point_first = p_first;
                    best_on_point_last  = p_last;

                    break;
                  }

                } while ( last != best_segment_first );
              }
            }

            /* for computing blue zones, we add the y offset as returned */
            /* by the currently used OpenType feature -- for example,    */
            /* superscript glyphs might be identical to subscript glyphs */
            /* with a vertical shift                                     */
            best_y += y_offset;

#ifdef FT_DEBUG_LEVEL_TRACE
            if ( num_idx == 1 )
              FT_TRACE5(( "  U+%04lX: best_y = %5ld", ch, best_y ));
            else
              FT_TRACE5(( "  component %d of cluster starting with U+%04lX:"
                          " best_y = %5ld", i, ch, best_y ));
#endif

            /* now set the `round' flag depending on the segment's kind: */
            /*                                                           */
            /* - if the horizontal distance between the first and last   */
            /*   `on' point is larger than a heuristic threshold         */
            /*   we have a flat segment                                  */
            /* - if either the first or the last point of the segment is */
            /*   an `off' point, the segment is round, otherwise it is   */
            /*   flat                                                    */
            if ( best_on_point_first >= 0                               &&
                 best_on_point_last >= 0                                &&
                 ( FT_ABS( points[best_on_point_last].x -
                           points[best_on_point_first].x ) ) >
                   flat_threshold                                       )
              round = 0;
            else
              round = FT_BOOL(
                        FT_CURVE_TAG( outline.tags[best_segment_first] ) !=
                          FT_CURVE_TAG_ON                                   ||
                        FT_CURVE_TAG( outline.tags[best_segment_last]  ) !=
                          FT_CURVE_TAG_ON                                   );

            if ( round && AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
            {
              /* only use flat segments for a neutral blue zone */
              FT_TRACE5(( " (round, skipped)\n" ));
              continue;
            }

            FT_TRACE5(( " (%s)\n", round ? "round" : "flat" ));
          }

          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          {
            if ( best_y > best_y_extremum )
            {
              best_y_extremum = best_y;
              best_round      = round;
            }
          }
          else
          {
            if ( best_y < best_y_extremum )
            {
              best_y_extremum = best_y;
              best_round      = round;
            }
          }

        } /* end for loop */

        if ( !( best_y_extremum == FT_INT_MIN ||
                best_y_extremum == FT_INT_MAX ) )
        {
          if ( best_round )
            rounds[num_rounds++] = best_y_extremum;
          else
            flats[num_flats++]   = best_y_extremum;
        }

      } /* end while loop */

      if ( num_flats == 0 && num_rounds == 0 )
      {
        /*
         *  we couldn't find a single glyph to compute this blue zone,
         *  we will simply ignore it then
         */
        FT_TRACE5(( "  empty\n" ));
        continue;
      }

      /* we have computed the contents of the `rounds' and `flats' tables, */
      /* now determine the reference and overshoot position of the blue -- */
      /* we simply take the median value after a simple sort               */
      af_sort_pos( num_rounds, rounds );
      af_sort_pos( num_flats,  flats );

      blue       = &axis->blues[axis->blue_count];
      blue_ref   = &blue->ref.org;
      blue_shoot = &blue->shoot.org;

      axis->blue_count++;

      if ( num_flats == 0 )
      {
        *blue_ref   =
        *blue_shoot = rounds[num_rounds / 2];
      }
      else if ( num_rounds == 0 )
      {
        *blue_ref   =
        *blue_shoot = flats[num_flats / 2];
      }
      else
      {
        *blue_ref   = flats [num_flats  / 2];
        *blue_shoot = rounds[num_rounds / 2];
      }

      /* there are sometimes problems: if the overshoot position of top     */
      /* zones is under its reference position, or the opposite for bottom  */
      /* zones.  We must thus check everything there and correct the errors */
      if ( *blue_shoot != *blue_ref )
      {
        FT_Pos   ref      = *blue_ref;
        FT_Pos   shoot    = *blue_shoot;
        FT_Bool  over_ref = FT_BOOL( shoot > ref );


        if ( ( AF_LATIN_IS_TOP_BLUE( bs )    ||
               AF_LATIN_IS_SUB_TOP_BLUE( bs) ) ^ over_ref )
        {
          *blue_ref   =
          *blue_shoot = ( shoot + ref ) / 2;

          FT_TRACE5(( "  [overshoot smaller than reference,"
                      " taking mean value]\n" ));
        }
      }

      blue->ascender  = ascender;
      blue->descender = descender;

      blue->flags = 0;
      if ( AF_LATIN_IS_TOP_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_TOP;
      if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_SUB_TOP;
      if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_NEUTRAL;

      /*
       * The following flag is used later to adjust the y and x scales
       * in order to optimize the pixel grid alignment of the top of small
       * letters.
       */
      if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_ADJUSTMENT;

      FT_TRACE5(( "    -> reference = %ld\n"
                  "       overshoot = %ld\n",
                  *blue_ref, *blue_shoot ));

    } /* end for loop */

    af_shaper_buf_destroy( face, shaper_buf );

    FT_TRACE5(( "\n" ));

    return;
  }


  /* Check whether all ASCII digits have the same advance width. */

  FT_LOCAL_DEF( void )
  af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
                                 FT_Face          face )
  {
    FT_Bool   started = 0, same_width = 1;
    FT_Fixed  advance, old_advance = 0;

    void*  shaper_buf;

    /* in all supported charmaps, digits have character codes 0x30-0x39 */
    const char   digits[] = "0 1 2 3 4 5 6 7 8 9";
    const char*  p;


    p          = digits;
    shaper_buf = af_shaper_buf_create( face );

    while ( *p )
    {
      FT_ULong      glyph_index;
      unsigned int  num_idx;


      /* reject input that maps to more than a single glyph */
      p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
      if ( num_idx > 1 )
        continue;

      glyph_index = af_shaper_get_elem( &metrics->root,
                                        shaper_buf,
                                        0,
                                        &advance,
                                        NULL );
      if ( !glyph_index )
        continue;

      if ( started )
      {
        if ( advance != old_advance )
        {
          same_width = 0;
          break;
        }
      }
      else
      {
        old_advance = advance;
        started     = 1;
      }
    }

    af_shaper_buf_destroy( face, shaper_buf );

    metrics->root.digits_have_same_width = same_width;
  }


  /* Initialize global metrics. */

  FT_LOCAL_DEF( FT_Error )
  af_latin_metrics_init( AF_LatinMetrics  metrics,
                         FT_Face          face )
  {
    FT_CharMap  oldmap = face->charmap;


    metrics->units_per_em = face->units_per_EM;

    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
    {
      af_latin_metrics_init_widths( metrics, face );
      af_latin_metrics_init_blues( metrics, face );
      af_latin_metrics_check_digits( metrics, face );
    }

    FT_Set_Charmap( face, oldmap );
    return FT_Err_Ok;
  }


  /* Adjust scaling value, then scale and shift widths   */
  /* and blue zones (if applicable) for given dimension. */

  static void
  af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
                              AF_Scaler        scaler,
                              AF_Dimension     dim )
  {
    FT_Fixed      scale;
    FT_Pos        delta;
    AF_LatinAxis  axis;
    FT_UInt       nn;


    if ( dim == AF_DIMENSION_HORZ )
    {
      scale = scaler->x_scale;
      delta = scaler->x_delta;
    }
    else
    {
      scale = scaler->y_scale;
      delta = scaler->y_delta;
    }

    axis = &metrics->axis[dim];

    if ( axis->org_scale == scale && axis->org_delta == delta )
      return;

    axis->org_scale = scale;
    axis->org_delta = delta;

    /*
     * correct X and Y scale to optimize the alignment of the top of small
     * letters to the pixel grid
     */
    {
      AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
      AF_LatinBlue  blue = NULL;


      for ( nn = 0; nn < Axis->blue_count; nn++ )
      {
        if ( Axis->blues[nn].flags & AF_LATIN_BLUE_ADJUSTMENT )
        {
          blue = &Axis->blues[nn];
          break;
        }
      }

      if ( blue )
      {
        FT_Pos   scaled;
        FT_Pos   threshold;
        FT_Pos   fitted;
        FT_UInt  limit;
        FT_UInt  ppem;


        scaled    = FT_MulFix( blue->shoot.org, scale );
        ppem      = metrics->root.scaler.face->size->metrics.x_ppem;
        limit     = metrics->root.globals->increase_x_height;
        threshold = 40;

        /* if the `increase-x-height' property is active, */
        /* we round up much more often                    */
        if ( limit                                 &&
             ppem <= limit                         &&
             ppem >= AF_PROP_INCREASE_X_HEIGHT_MIN )
          threshold = 52;

        fitted = ( scaled + threshold ) & ~63;

        if ( scaled != fitted )
        {
#if 0
          if ( dim == AF_DIMENSION_HORZ )
          {
            if ( fitted < scaled )
              scale -= scale / 50;  /* scale *= 0.98 */
          }
          else
#endif
          if ( dim == AF_DIMENSION_VERT )
          {
            FT_Pos    max_height;
            FT_Pos    dist;
            FT_Fixed  new_scale;


            new_scale = FT_MulDiv( scale, fitted, scaled );

            /* the scaling should not change the result by more than two pixels */
            max_height = metrics->units_per_em;

            for ( nn = 0; nn < Axis->blue_count; nn++ )
            {
              max_height = FT_MAX( max_height, Axis->blues[nn].ascender );
              max_height = FT_MAX( max_height, -Axis->blues[nn].descender );
            }

            dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );
            dist &= ~127;

            if ( dist == 0 )
            {
              FT_TRACE5((
                "af_latin_metrics_scale_dim:"
                " x height alignment (style `%s'):\n"
                "                           "
                " vertical scaling changed from %.5f to %.5f (by %d%%)\n"
                "\n",
                af_style_names[metrics->root.style_class->style],
                scale / 65536.0,
                new_scale / 65536.0,
                ( fitted - scaled ) * 100 / scaled ));

              scale = new_scale;
            }
#ifdef FT_DEBUG_LEVEL_TRACE
            else
            {
              FT_TRACE5((
                "af_latin_metrics_scale_dim:"
                " x height alignment (style `%s'):\n"
                "                           "
                " excessive vertical scaling abandoned\n"
                "\n",
                af_style_names[metrics->root.style_class->style] ));
            }
#endif
          }
        }
      }
    }

    axis->scale = scale;
    axis->delta = delta;

    if ( dim == AF_DIMENSION_HORZ )
    {
      metrics->root.scaler.x_scale = scale;
      metrics->root.scaler.x_delta = delta;
    }
    else
    {
      metrics->root.scaler.y_scale = scale;
      metrics->root.scaler.y_delta = delta;
    }

    FT_TRACE5(( "%s widths (style `%s')\n",
                dim == AF_DIMENSION_HORZ ? "horizontal" : "vertical",
                af_style_names[metrics->root.style_class->style] ));

    /* scale the widths */
    for ( nn = 0; nn < axis->width_count; nn++ )
    {
      AF_Width  width = axis->widths + nn;


      width->cur = FT_MulFix( width->org, scale );
      width->fit = width->cur;

      FT_TRACE5(( "  %d scaled to %.2f\n",
                  width->org,
                  width->cur / 64.0 ));
    }

    FT_TRACE5(( "\n" ));

    /* an extra-light axis corresponds to a standard width that is */
    /* smaller than 5/8 pixels                                     */
    axis->extra_light =
      (FT_Bool)( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );

#ifdef FT_DEBUG_LEVEL_TRACE
    if ( axis->extra_light )
      FT_TRACE5(( "`%s' style is extra light (at current resolution)\n"
                  "\n",
                  af_style_names[metrics->root.style_class->style] ));
#endif

    if ( dim == AF_DIMENSION_VERT )
    {
#ifdef FT_DEBUG_LEVEL_TRACE
      if ( axis->blue_count )
        FT_TRACE5(( "blue zones (style `%s')\n",
                    af_style_names[metrics->root.style_class->style] ));
#endif

      /* scale the blue zones */
      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue  blue = &axis->blues[nn];
        FT_Pos        dist;


        blue->ref.cur   = FT_MulFix( blue->ref.org, scale ) + delta;
        blue->ref.fit   = blue->ref.cur;
        blue->shoot.cur = FT_MulFix( blue->shoot.org, scale ) + delta;
        blue->shoot.fit = blue->shoot.cur;
        blue->flags    &= ~AF_LATIN_BLUE_ACTIVE;

        /* a blue zone is only active if it is less than 3/4 pixels tall */
        dist = FT_MulFix( blue->ref.org - blue->shoot.org, scale );
        if ( dist <= 48 && dist >= -48 )
        {
#if 0
          FT_Pos  delta1;
#endif
          FT_Pos  delta2;


          /* use discrete values for blue zone widths */

#if 0

          /* generic, original code */
          delta1 = blue->shoot.org - blue->ref.org;
          delta2 = delta1;
          if ( delta1 < 0 )
            delta2 = -delta2;

          delta2 = FT_MulFix( delta2, scale );

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 64 )
            delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) & ~31 );
          else
            delta2 = FT_PIX_ROUND( delta2 );

          if ( delta1 < 0 )
            delta2 = -delta2;

          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
          blue->shoot.fit = blue->ref.fit + delta2;

#else

          /* simplified version due to abs(dist) <= 48 */
          delta2 = dist;
          if ( dist < 0 )
            delta2 = -delta2;

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 48 )
            delta2 = 32;
          else
            delta2 = 64;

          if ( dist < 0 )
            delta2 = -delta2;

          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
          blue->shoot.fit = blue->ref.fit - delta2;

#endif

          blue->flags |= AF_LATIN_BLUE_ACTIVE;
        }
      }

      /* use sub-top blue zone only if it doesn't overlap with */
      /* another (non-sup-top) blue zone; otherwise, the       */
      /* effect would be similar to a neutral blue zone, which */
      /* is not desired here                                   */
      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue  blue = &axis->blues[nn];
        FT_UInt       i;


        if ( !( blue->flags & AF_LATIN_BLUE_SUB_TOP ) )
          continue;
        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
          continue;

        for ( i = 0; i < axis->blue_count; i++ )
        {
          AF_LatinBlue  b = &axis->blues[i];


          if ( b->flags & AF_LATIN_BLUE_SUB_TOP )
            continue;
          if ( !( b->flags & AF_LATIN_BLUE_ACTIVE ) )
            continue;

          if ( b->ref.fit <= blue->shoot.fit &&
               b->shoot.fit >= blue->ref.fit )
          {
            blue->flags &= ~AF_LATIN_BLUE_ACTIVE;
            break;
          }
        }
      }

#ifdef FT_DEBUG_LEVEL_TRACE
      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue  blue = &axis->blues[nn];


        FT_TRACE5(( "  reference %d: %d scaled to %.2f%s\n"
                    "  overshoot %d: %d scaled to %.2f%s\n",
                    nn,
                    blue->ref.org,
                    blue->ref.fit / 64.0,
                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
                                                       : " (inactive)",
                    nn,
                    blue->shoot.org,
                    blue->shoot.fit / 64.0,
                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
                                                       : " (inactive)" ));
      }
#endif
    }
  }


  /* Scale global values in both directions. */

  FT_LOCAL_DEF( void )
  af_latin_metrics_scale( AF_LatinMetrics  metrics,
                          AF_Scaler        scaler )
  {
    metrics->root.scaler.render_mode = scaler->render_mode;
    metrics->root.scaler.face        = scaler->face;
    metrics->root.scaler.flags       = scaler->flags;

    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
  }


  /* Extract standard_width from writing system/script specific */
  /* metrics class.                                             */

  FT_LOCAL_DEF( void )
  af_latin_get_standard_widths( AF_LatinMetrics  metrics,
                                FT_Pos*          stdHW,
                                FT_Pos*          stdVW )
  {
    if ( stdHW )
      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;

    if ( stdVW )
      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* Walk over all contours and compute its segments. */

  FT_LOCAL_DEF( FT_Error )
  af_latin_hints_compute_segments( AF_GlyphHints  hints,
                                   AF_Dimension   dim )
  {
    AF_LatinMetrics  metrics       = (AF_LatinMetrics)hints->metrics;
    AF_AxisHints     axis          = &hints->axis[dim];
    FT_Memory        memory        = hints->memory;
    FT_Error         error         = FT_Err_Ok;
    AF_Segment       segment       = NULL;
    AF_SegmentRec    seg0;
    AF_Point*        contour       = hints->contours;
    AF_Point*        contour_limit = contour + hints->num_contours;
    AF_Direction     major_dir, segment_dir;

    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );


    FT_ZERO( &seg0 );
    seg0.score = 32000;
    seg0.flags = AF_EDGE_NORMAL;

    major_dir   = (AF_Direction)FT_ABS( axis->major_dir );
    segment_dir = major_dir;

    axis->num_segments = 0;

    /* set up (u,v) in each point */
    if ( dim == AF_DIMENSION_HORZ )
    {
      AF_Point  point = hints->points;
      AF_Point  limit = point + hints->num_points;


      for ( ; point < limit; point++ )
      {
        point->u = point->fx;
        point->v = point->fy;
      }
    }
    else
    {
      AF_Point  point = hints->points;
      AF_Point  limit = point + hints->num_points;


      for ( ; point < limit; point++ )
      {
        point->u = point->fy;
        point->v = point->fx;
      }
    }

    /* do each contour separately */
    for ( ; contour < contour_limit; contour++ )
    {
      AF_Point  point   = contour[0];
      AF_Point  last    = point->prev;
      int       on_edge = 0;

      /* we call values measured along a segment (point->v)    */
      /* `coordinates', and values orthogonal to it (point->u) */
      /* `positions'                                           */
      FT_Pos     min_pos      =  32000;
      FT_Pos     max_pos      = -32000;
      FT_Pos     min_coord    =  32000;
      FT_Pos     max_coord    = -32000;
      FT_UShort  min_flags    =  AF_FLAG_NONE;
      FT_UShort  max_flags    =  AF_FLAG_NONE;
      FT_Pos     min_on_coord =  32000;
      FT_Pos     max_on_coord = -32000;

      FT_Bool  passed;

      AF_Segment  prev_segment = NULL;

      FT_Pos     prev_min_pos      = min_pos;
      FT_Pos     prev_max_pos      = max_pos;
      FT_Pos     prev_min_coord    = min_coord;
      FT_Pos     prev_max_coord    = max_coord;
      FT_UShort  prev_min_flags    = min_flags;
      FT_UShort  prev_max_flags    = max_flags;
      FT_Pos     prev_min_on_coord = min_on_coord;
      FT_Pos     prev_max_on_coord = max_on_coord;


      if ( FT_ABS( last->out_dir )  == major_dir &&
           FT_ABS( point->out_dir ) == major_dir )
      {
        /* we are already on an edge, try to locate its start */
        last = point;

        for (;;)
        {
          point = point->prev;
          if ( FT_ABS( point->out_dir ) != major_dir )
          {
            point = point->next;
            break;
          }
          if ( point == last )
            break;
        }
      }

      last   = point;
      passed = 0;

      for (;;)
      {
        FT_Pos  u, v;


        if ( on_edge )
        {
          /* get minimum and maximum position */
          u = point->u;
          if ( u < min_pos )
            min_pos = u;
          if ( u > max_pos )
            max_pos = u;

          /* get minimum and maximum coordinate together with flags */
          v = point->v;
          if ( v < min_coord )
          {
            min_coord = v;
            min_flags = point->flags;
          }
          if ( v > max_coord )
          {
            max_coord = v;
            max_flags = point->flags;
          }

          /* get minimum and maximum coordinate of `on' points */
          if ( !( point->flags & AF_FLAG_CONTROL ) )
          {
            v = point->v;
            if ( v < min_on_coord )
              min_on_coord = v;
            if ( v > max_on_coord )
              max_on_coord = v;
          }

          if ( point->out_dir != segment_dir || point == last )
          {
            /* check whether the new segment's start point is identical to */
            /* the previous segment's end point; for example, this might   */
            /* happen for spikes                                           */

            if ( !prev_segment || segment->first != prev_segment->last )
            {
              /* points are different: we are just leaving an edge, thus */
              /* record a new segment                                    */

              segment->last  = point;
              segment->pos   = (FT_Short)( ( min_pos + max_pos ) >> 1 );
              segment->delta = (FT_Short)( ( max_pos - min_pos ) >> 1 );

              /* a segment is round if either its first or last point */
              /* is a control point, and the length of the on points  */
              /* inbetween doesn't exceed a heuristic limit           */
              if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                   ( max_on_coord - min_on_coord ) < flat_threshold )
                segment->flags |= AF_EDGE_ROUND;

              segment->min_coord = (FT_Short)min_coord;
              segment->max_coord = (FT_Short)max_coord;
              segment->height    = segment->max_coord - segment->min_coord;

              prev_segment      = segment;
              prev_min_pos      = min_pos;
              prev_max_pos      = max_pos;
              prev_min_coord    = min_coord;
              prev_max_coord    = max_coord;
              prev_min_flags    = min_flags;
              prev_max_flags    = max_flags;
              prev_min_on_coord = min_on_coord;
              prev_max_on_coord = max_on_coord;
            }
            else
            {
              /* points are the same: we don't create a new segment but */
              /* merge the current segment with the previous one        */

              if ( prev_segment->last->in_dir == point->in_dir )
              {
                /* we have identical directions (this can happen for       */
                /* degenerate outlines that move zig-zag along the main    */
                /* axis without changing the coordinate value of the other */
                /* axis, and where the segments have just been merged):    */
                /* unify segments                                          */

                /* update constraints */

                if ( prev_min_pos < min_pos )
                  min_pos = prev_min_pos;
                if ( prev_max_pos > max_pos )
                  max_pos = prev_max_pos;

                if ( prev_min_coord < min_coord )
                {
                  min_coord = prev_min_coord;
                  min_flags = prev_min_flags;
                }
                if ( prev_max_coord > max_coord )
                {
                  max_coord = prev_max_coord;
                  max_flags = prev_max_flags;
                }

                if ( prev_min_on_coord < min_on_coord )
                  min_on_coord = prev_min_on_coord;
                if ( prev_max_on_coord > max_on_coord )
                  max_on_coord = prev_max_on_coord;

                prev_segment->last = point;
                prev_segment->pos  = (FT_Short)( ( min_pos +
                                                   max_pos ) >> 1 );

                if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                     ( max_on_coord - min_on_coord ) < flat_threshold )
                  prev_segment->flags |= AF_EDGE_ROUND;
                else
                  prev_segment->flags &= ~AF_EDGE_ROUND;

                prev_segment->min_coord = (FT_Short)min_coord;
                prev_segment->max_coord = (FT_Short)max_coord;
                prev_segment->height    = prev_segment->max_coord -
                                          prev_segment->min_coord;
              }
              else
              {
                /* we have different directions; use the properties of the */
                /* longer segment and discard the other one                */

                if ( FT_ABS( prev_max_coord - prev_min_coord ) >
                     FT_ABS( max_coord - min_coord ) )
                {
                  /* discard current segment */

                  if ( min_pos < prev_min_pos )
                    prev_min_pos = min_pos;
                  if ( max_pos > prev_max_pos )
                    prev_max_pos = max_pos;

                  prev_segment->last = point;
                  prev_segment->pos  = (FT_Short)( ( prev_min_pos +
                                                     prev_max_pos ) >> 1 );
                }
                else
                {
                  /* discard previous segment */

                  if ( prev_min_pos < min_pos )
                    min_pos = prev_min_pos;
                  if ( prev_max_pos > max_pos )
                    max_pos = prev_max_pos;

                  segment->last = point;
                  segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );

                  if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                       ( max_on_coord - min_on_coord ) < flat_threshold )
                    segment->flags |= AF_EDGE_ROUND;

                  segment->min_coord = (FT_Short)min_coord;
                  segment->max_coord = (FT_Short)max_coord;
                  segment->height    = segment->max_coord -
                                       segment->min_coord;

                  *prev_segment = *segment;

                  prev_min_pos      = min_pos;
                  prev_max_pos      = max_pos;
                  prev_min_coord    = min_coord;
                  prev_max_coord    = max_coord;
                  prev_min_flags    = min_flags;
                  prev_max_flags    = max_flags;
                  prev_min_on_coord = min_on_coord;
                  prev_max_on_coord = max_on_coord;
                }
              }

              axis->num_segments--;
            }

            on_edge = 0;
            segment = NULL;

            /* fall through */
          }
        }

        /* now exit if we are at the start/end point */
        if ( point == last )
        {
          if ( passed )
            break;
          passed = 1;
        }

        /* if we are not on an edge, check whether the major direction */
        /* coincides with the current point's `out' direction, or      */
        /* whether we have a single-point contour                      */
        if ( !on_edge                                  &&
             ( FT_ABS( point->out_dir ) == major_dir ||
               point == point->prev                  ) )
        {
          /* this is the start of a new segment! */
          segment_dir = (AF_Direction)point->out_dir;

          error = af_axis_hints_new_segment( axis, memory, &segment );
          if ( error )
            goto Exit;

          /* clear all segment fields */
          segment[0] = seg0;

          segment->dir   = (FT_Char)segment_dir;
          segment->first = point;
          segment->last  = point;

          /* `af_axis_hints_new_segment' reallocates memory,    */
          /* thus we have to refresh the `prev_segment' pointer */
          if ( prev_segment )
            prev_segment = segment - 1;

          min_pos   = max_pos   = point->u;
          min_coord = max_coord = point->v;
          min_flags = max_flags = point->flags;

          if ( point->flags & AF_FLAG_CONTROL )
          {
            min_on_coord =  32000;
            max_on_coord = -32000;
          }
          else
            min_on_coord = max_on_coord = point->v;

          on_edge = 1;

          if ( point == point->prev )
          {
            /* we have a one-point segment: this is a one-point */
            /* contour with `in' and `out' direction set to     */
            /* AF_DIR_NONE                                      */
            segment->pos = (FT_Short)min_pos;

            if (point->flags & AF_FLAG_CONTROL)
              segment->flags |= AF_EDGE_ROUND;

            segment->min_coord = (FT_Short)point->v;
            segment->max_coord = (FT_Short)point->v;
            segment->height = 0;

            on_edge = 0;
            segment = NULL;
          }
        }

        point = point->next;
      }

    } /* contours */


    /* now slightly increase the height of segments if this makes */
    /* sense -- this is used to better detect and ignore serifs   */
    {
      AF_Segment  segments     = axis->segments;
      AF_Segment  segments_end = segments + axis->num_segments;


      for ( segment = segments; segment < segments_end; segment++ )
      {
        AF_Point  first   = segment->first;
        AF_Point  last    = segment->last;
        FT_Pos    first_v = first->v;
        FT_Pos    last_v  = last->v;


        if ( first_v < last_v )
        {
          AF_Point  p;


          p = first->prev;
          if ( p->v < first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( first_v - p->v ) >> 1 ) );

          p = last->next;
          if ( p->v > last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - last_v ) >> 1 ) );
        }
        else
        {
          AF_Point  p;


          p = first->prev;
          if ( p->v > first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - first_v ) >> 1 ) );

          p = last->next;
          if ( p->v < last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( last_v - p->v ) >> 1 ) );
        }
      }
    }

  Exit:
    return error;
  }


  /* Link segments to form stems and serifs.  If `width_count' and      */
  /* `widths' are non-zero, use them to fine-tune the scoring function. */

  FT_LOCAL_DEF( void )
  af_latin_hints_link_segments( AF_GlyphHints  hints,
                                FT_UInt        width_count,
                                AF_WidthRec*   widths,
                                AF_Dimension   dim )
  {
    AF_AxisHints  axis          = &hints->axis[dim];
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = segments + axis->num_segments;
    FT_Pos        len_threshold, len_score, dist_score, max_width;
    AF_Segment    seg1, seg2;


    if ( width_count )
      max_width = widths[width_count - 1].org;
    else
      max_width = 0;

    /* a heuristic value to set up a minimum value for overlapping */
    len_threshold = AF_LATIN_CONSTANT( hints->metrics, 8 );
    if ( len_threshold == 0 )
      len_threshold = 1;

    /* a heuristic value to weight lengths */
    len_score = AF_LATIN_CONSTANT( hints->metrics, 6000 );

    /* a heuristic value to weight distances (no call to    */
    /* AF_LATIN_CONSTANT needed, since we work on multiples */
    /* of the stem width)                                   */
    dist_score = 3000;

    /* now compare each segment to the others */
    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      if ( seg1->dir != axis->major_dir )
        continue;

      /* search for stems having opposite directions, */
      /* with seg1 to the `left' of seg2              */
      for ( seg2 = segments; seg2 < segment_limit; seg2++ )
      {
        FT_Pos  pos1 = seg1->pos;
        FT_Pos  pos2 = seg2->pos;


        if ( seg1->dir + seg2->dir == 0 && pos2 > pos1 )
        {
          /* compute distance between the two segments */
          FT_Pos  min = seg1->min_coord;
          FT_Pos  max = seg1->max_coord;
          FT_Pos  len;


          if ( min < seg2->min_coord )
            min = seg2->min_coord;

          if ( max > seg2->max_coord )
            max = seg2->max_coord;

          /* compute maximum coordinate difference of the two segments */
          /* (this is, how much they overlap)                          */
          len = max - min;
          if ( len >= len_threshold )
          {
            /*
             *  The score is the sum of two demerits indicating the
             *  `badness' of a fit, measured along the segments' main axis
             *  and orthogonal to it, respectively.
             *
             *  o The less overlapping along the main axis, the worse it
             *    is, causing a larger demerit.
             *
             *  o The nearer the orthogonal distance to a stem width, the
             *    better it is, causing a smaller demerit.  For simplicity,
             *    however, we only increase the demerit for values that
             *    exceed the largest stem width.
             */

            FT_Pos  dist = pos2 - pos1;

            FT_Pos  dist_demerit, score;


            if ( max_width )
            {
              /* distance demerits are based on multiples of `max_width'; */
              /* we scale by 1024 for getting more precision              */
              FT_Pos  delta = ( dist << 10 ) / max_width - ( 1 << 10 );


              if ( delta > 10000 )
                dist_demerit = 32000;
              else if ( delta > 0 )
                dist_demerit = delta * delta / dist_score;
              else
                dist_demerit = 0;
            }
            else
              dist_demerit = dist; /* default if no widths available */

            score = dist_demerit + len_score / len;

            /* and we search for the smallest score */
            if ( score < seg1->score )
            {
              seg1->score = score;
              seg1->link  = seg2;
            }

            if ( score < seg2->score )
            {
              seg2->score = score;
              seg2->link  = seg1;
            }
          }
        }
      }
    }

    /* now compute the `serif' segments, cf. explanations in `afhints.h' */
    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      seg2 = seg1->link;

      if ( seg2 )
      {
        if ( seg2->link != seg1 )
        {
          seg1->link  = 0;
          seg1->serif = seg2->link;
        }
      }
    }
  }


  /* Link segments to edges, using feature analysis for selection. */

  FT_LOCAL_DEF( FT_Error )
  af_latin_hints_compute_edges( AF_GlyphHints  hints,
                                AF_Dimension   dim )
  {
    AF_AxisHints  axis   = &hints->axis[dim];
    FT_Error      error  = FT_Err_Ok;
    FT_Memory     memory = hints->memory;
    AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];

    AF_StyleClass   style_class  = hints->metrics->style_class;
    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                     [style_class->script];

    FT_Bool  top_to_bottom_hinting = 0;

    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = segments + axis->num_segments;
    AF_Segment    seg;

#if 0
    AF_Direction  up_dir;
#endif
    FT_Fixed      scale;
    FT_Pos        edge_distance_threshold;
    FT_Pos        segment_length_threshold;
    FT_Pos        segment_width_threshold;


    axis->num_edges = 0;

    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                         : hints->y_scale;

#if 0
    up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
                                          : AF_DIR_RIGHT;
#endif

    if ( dim == AF_DIMENSION_VERT )
      top_to_bottom_hinting = script_class->top_to_bottom_hinting;

    /*
     *  We ignore all segments that are less than 1 pixel in length
     *  to avoid many problems with serif fonts.  We compute the
     *  corresponding threshold in font units.
     */
    if ( dim == AF_DIMENSION_HORZ )
      segment_length_threshold = FT_DivFix( 64, hints->y_scale );
    else
      segment_length_threshold = 0;

    /*
     *  Similarly, we ignore segments that have a width delta
     *  larger than 0.5px (i.e., a width larger than 1px).
     */
    segment_width_threshold = FT_DivFix( 32, scale );

    /*********************************************************************/
    /*                                                                   */
    /* We begin by generating a sorted table of edges for the current    */
    /* direction.  To do so, we simply scan each segment and try to find */
    /* an edge in our table that corresponds to its position.            */
    /*                                                                   */
    /* If no edge is found, we create and insert a new edge in the       */
    /* sorted table.  Otherwise, we simply add the segment to the edge's */
    /* list which gets processed in the second step to compute the       */
    /* edge's properties.                                                */
    /*                                                                   */
    /* Note that the table of edges is sorted along the segment/edge     */
    /* position.                                                         */
    /*                                                                   */
    /*********************************************************************/

    /* assure that edge distance threshold is at most 0.25px */
    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
                                         scale );
    if ( edge_distance_threshold > 64 / 4 )
      edge_distance_threshold = 64 / 4;

    edge_distance_threshold = FT_DivFix( edge_distance_threshold,
                                         scale );

    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_Int   ee;


      /* ignore too short segments, too wide ones, and, in this loop, */
      /* one-point segments without a direction                       */
      if ( seg->height < segment_length_threshold ||
           seg->delta > segment_width_threshold   ||
           seg->dir == AF_DIR_NONE                )
        continue;

      /* A special case for serif edges: If they are smaller than */
      /* 1.5 pixels we ignore them.                               */
      if ( seg->serif                                     &&
           2 * seg->height < 3 * segment_length_threshold )
        continue;

      /* look for an edge corresponding to the segment */
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;


        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;

        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
        {
          found = edge;
          break;
        }
      }

      if ( !found )
      {
        AF_Edge  edge;


        /* insert a new edge in the list and */
        /* sort according to the position    */
        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        top_to_bottom_hinting,
                                        memory, &edge );
        if ( error )
          goto Exit;

        /* add the segment to the new edge's list */
        FT_ZERO( edge );

        edge->first    = seg;
        edge->last     = seg;
        edge->dir      = seg->dir;
        edge->fpos     = seg->pos;
        edge->opos     = FT_MulFix( seg->pos, scale );
        edge->pos      = edge->opos;
        seg->edge_next = seg;
      }
      else
      {
        /* if an edge was found, simply add the segment to the edge's */
        /* list                                                       */
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }

    /* we loop again over all segments to catch one-point segments   */
    /* without a direction: if possible, link them to existing edges */
    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_Int   ee;


      if ( seg->dir != AF_DIR_NONE )
        continue;

      /* look for an edge corresponding to the segment */
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;


        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;

        if ( dist < edge_distance_threshold )
        {
          found = edge;
          break;
        }
      }

      /* one-point segments without a match are ignored */
      if ( found )
      {
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }


    /******************************************************************/
    /*                                                                */
    /* Good, we now compute each edge's properties according to the   */
    /* segments found on its position.  Basically, these are          */
    /*                                                                */
    /*  - the edge's main direction                                   */
    /*  - stem edge, serif edge or both (which defaults to stem then) */
    /*  - rounded edge, straight or both (which defaults to straight) */
    /*  - link for edge                                               */
    /*                                                                */
    /******************************************************************/

    /* first of all, set the `edge' field in each segment -- this is */
    /* required in order to compute edge links                       */

    /*
     * Note that removing this loop and setting the `edge' field of each
     * segment directly in the code above slows down execution speed for
     * some reasons on platforms like the Sun.
     */
    {
      AF_Edge  edges      = axis->edges;
      AF_Edge  edge_limit = edges + axis->num_edges;
      AF_Edge  edge;


      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg       = seg->edge_next;

          } while ( seg != edge->first );
      }

      /* now compute each edge properties */
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Int  is_round    = 0;  /* does it contain round segments?    */
        FT_Int  is_straight = 0;  /* does it contain straight segments? */
#if 0
        FT_Pos  ups         = 0;  /* number of upwards segments         */
        FT_Pos  downs       = 0;  /* number of downwards segments       */
#endif


        seg = edge->first;

        do
        {
          FT_Bool  is_serif;


          /* check for roundness of segment */
          if ( seg->flags & AF_EDGE_ROUND )
            is_round++;
          else
            is_straight++;

#if 0
          /* check for segment direction */
          if ( seg->dir == up_dir )
            ups   += seg->max_coord - seg->min_coord;
          else
            downs += seg->max_coord - seg->min_coord;
#endif

          /* check for links -- if seg->serif is set, then seg->link must */
          /* be ignored                                                   */
          is_serif = (FT_Bool)( seg->serif               &&
                                seg->serif->edge         &&
                                seg->serif->edge != edge );

          if ( ( seg->link && seg->link->edge ) || is_serif )
          {
            AF_Edge     edge2;
            AF_Segment  seg2;


            edge2 = edge->link;
            seg2  = seg->link;

            if ( is_serif )
            {
              seg2  = seg->serif;
              edge2 = edge->serif;
            }

            if ( edge2 )
            {
              FT_Pos  edge_delta;
              FT_Pos  seg_delta;


              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;

              seg_delta = seg->pos - seg2->pos;
              if ( seg_delta < 0 )
                seg_delta = -seg_delta;

              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
              edge2 = seg2->edge;

            if ( is_serif )
            {
              edge->serif   = edge2;
              edge2->flags |= AF_EDGE_SERIF;
            }
            else
              edge->link  = edge2;
          }

          seg = seg->edge_next;

        } while ( seg != edge->first );

        /* set the round/straight flags */
        edge->flags = AF_EDGE_NORMAL;

        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= AF_EDGE_ROUND;

#if 0
        /* set the edge's main direction */
        edge->dir = AF_DIR_NONE;

        if ( ups > downs )
          edge->dir = (FT_Char)up_dir;

        else if ( ups < downs )
          edge->dir = (FT_Char)-up_dir;

        else if ( ups == downs )
          edge->dir = 0;  /* both up and down! */
#endif

        /* get rid of serifs if link is set                 */
        /* XXX: This gets rid of many unpleasant artefacts! */
        /*      Example: the `c' in cour.pfa at size 13     */

        if ( edge->serif && edge->link )
          edge->serif = NULL;
      }
    }

  Exit:
    return error;
  }


  /* Detect segments and edges for given dimension. */

  FT_LOCAL_DEF( FT_Error )
  af_latin_hints_detect_features( AF_GlyphHints  hints,
                                  FT_UInt        width_count,
                                  AF_WidthRec*   widths,
                                  AF_Dimension   dim )
  {
    FT_Error  error;


    error = af_latin_hints_compute_segments( hints, dim );
    if ( !error )
    {
      af_latin_hints_link_segments( hints, width_count, widths, dim );

      error = af_latin_hints_compute_edges( hints, dim );
    }

    return error;
  }


  /* Compute all edges which lie within blue zones. */

  static void
  af_latin_hints_compute_blue_edges( AF_GlyphHints    hints,
                                     AF_LatinMetrics  metrics )
  {
    AF_AxisHints  axis       = &hints->axis[AF_DIMENSION_VERT];
    AF_Edge       edge       = axis->edges;
    AF_Edge       edge_limit = edge + axis->num_edges;
    AF_LatinAxis  latin      = &metrics->axis[AF_DIMENSION_VERT];
    FT_Fixed      scale      = latin->scale;


    /* compute which blue zones are active, i.e. have their scaled */
    /* size < 3/4 pixels                                           */

    /* for each horizontal edge search the blue zone which is closest */
    for ( ; edge < edge_limit; edge++ )
    {
      FT_UInt   bb;
      AF_Width  best_blue            = NULL;
      FT_Bool   best_blue_is_neutral = 0;
      FT_Pos    best_dist;                 /* initial threshold */


      /* compute the initial threshold as a fraction of the EM size */
      /* (the value 40 is heuristic)                                */
      best_dist = FT_MulFix( metrics->units_per_em / 40, scale );

      /* assure a minimum distance of 0.5px */
      if ( best_dist > 64 / 2 )
        best_dist = 64 / 2;

      for ( bb = 0; bb < latin->blue_count; bb++ )
      {
        AF_LatinBlue  blue = latin->blues + bb;
        FT_Bool       is_top_blue, is_neutral_blue, is_major_dir;


        /* skip inactive blue zones (i.e., those that are too large) */
        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
          continue;

        /* if it is a top zone, check for right edges (against the major */
        /* direction); if it is a bottom zone, check for left edges (in  */
        /* the major direction) -- this assumes the TrueType convention  */
        /* for the orientation of contours                               */
        is_top_blue =
          (FT_Byte)( ( blue->flags & ( AF_LATIN_BLUE_TOP     |
                                       AF_LATIN_BLUE_SUB_TOP ) ) != 0 );
        is_neutral_blue =
          (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_NEUTRAL ) != 0);
        is_major_dir =
          FT_BOOL( edge->dir == axis->major_dir );

        /* neutral blue zones are handled for both directions */
        if ( is_top_blue ^ is_major_dir || is_neutral_blue )
        {
          FT_Pos  dist;


          /* first of all, compare it to the reference position */
          dist = edge->fpos - blue->ref.org;
          if ( dist < 0 )
            dist = -dist;

          dist = FT_MulFix( dist, scale );
          if ( dist < best_dist )
          {
            best_dist            = dist;
            best_blue            = &blue->ref;
            best_blue_is_neutral = is_neutral_blue;
          }

          /* now compare it to the overshoot position and check whether */
          /* the edge is rounded, and whether the edge is over the      */
          /* reference position of a top zone, or under the reference   */
          /* position of a bottom zone (provided we don't have a        */
          /* neutral blue zone)                                         */
          if ( edge->flags & AF_EDGE_ROUND &&
               dist != 0                   &&
               !is_neutral_blue            )
          {
            FT_Bool  is_under_ref = FT_BOOL( edge->fpos < blue->ref.org );


            if ( is_top_blue ^ is_under_ref )
            {
              dist = edge->fpos - blue->shoot.org;
              if ( dist < 0 )
                dist = -dist;

              dist = FT_MulFix( dist, scale );
              if ( dist < best_dist )
              {
                best_dist            = dist;
                best_blue            = &blue->shoot;
                best_blue_is_neutral = is_neutral_blue;
              }
            }
          }
        }
      }

      if ( best_blue )
      {
        edge->blue_edge = best_blue;
        if ( best_blue_is_neutral )
          edge->flags |= AF_EDGE_NEUTRAL;
      }
    }
  }


  /* Initalize hinting engine. */

  static FT_Error
  af_latin_hints_init( AF_GlyphHints    hints,
                       AF_LatinMetrics  metrics )
  {
    FT_Render_Mode  mode;
    FT_UInt32       scaler_flags, other_flags;
    FT_Face         face = metrics->root.scaler.face;


    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );

    /*
     *  correct x_scale and y_scale if needed, since they may have
     *  been modified by `af_latin_metrics_scale_dim' above
     */
    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;

    /* compute flags depending on render mode, etc. */
    mode = metrics->root.scaler.render_mode;

#if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
#endif

    scaler_flags = hints->scaler_flags;
    other_flags  = 0;

    /*
     *  We snap the width of vertical stems for the monochrome and
     *  horizontal LCD rendering targets only.
     */
    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
      other_flags |= AF_LATIN_HINTS_HORZ_SNAP;

    /*
     *  We snap the width of horizontal stems for the monochrome and
     *  vertical LCD rendering targets only.
     */
    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
      other_flags |= AF_LATIN_HINTS_VERT_SNAP;

    /*
     *  We adjust stems to full pixels only if we don't use the `light' mode.
     */
    if ( mode != FT_RENDER_MODE_LIGHT )
      other_flags |= AF_LATIN_HINTS_STEM_ADJUST;

    if ( mode == FT_RENDER_MODE_MONO )
      other_flags |= AF_LATIN_HINTS_MONO;

    /*
     *  In `light' hinting mode we disable horizontal hinting completely.
     *  We also do it if the face is italic.
     *
     *  However, if warping is enabled (which only works in `light' hinting
     *  mode), advance widths get adjusted, too.
     */
    if ( mode == FT_RENDER_MODE_LIGHT                      ||
         ( face->style_flags & FT_STYLE_FLAG_ITALIC ) != 0 )
      scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;

#ifdef AF_CONFIG_OPTION_USE_WARPER
    /* get (global) warper flag */
    if ( !metrics->root.globals->module->warping )
      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
#endif

    hints->scaler_flags = scaler_flags;
    hints->other_flags  = other_flags;

    return FT_Err_Ok;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /* Snap a given width in scaled coordinates to one of the */
  /* current standard widths.                               */

  static FT_Pos
  af_latin_snap_width( AF_Width  widths,
                       FT_UInt   count,
                       FT_Pos    width )
  {
    FT_UInt  n;
    FT_Pos   best      = 64 + 32 + 2;
    FT_Pos   reference = width;
    FT_Pos   scaled;


    for ( n = 0; n < count; n++ )
    {
      FT_Pos  w;
      FT_Pos  dist;


      w = widths[n].cur;
      dist = width - w;
      if ( dist < 0 )
        dist = -dist;
      if ( dist < best )
      {
        best      = dist;
        reference = w;
      }
    }

    scaled = FT_PIX_ROUND( reference );

    if ( width >= reference )
    {
      if ( width < scaled + 48 )
        width = reference;
    }
    else
    {
      if ( width > scaled - 48 )
        width = reference;
    }

    return width;
  }


  /* Compute the snapped width of a given stem, ignoring very thin ones. */
  /* There is a lot of voodoo in this function; changing the hard-coded  */
  /* parameters influence the whole hinting process.                     */

  static FT_Pos
  af_latin_compute_stem_width( AF_GlyphHints  hints,
                               AF_Dimension   dim,
                               FT_Pos         width,
                               FT_Pos         base_delta,
                               FT_UInt        base_flags,
                               FT_UInt        stem_flags )
  {
    AF_LatinMetrics  metrics  = (AF_LatinMetrics)hints->metrics;
    AF_LatinAxis     axis     = &metrics->axis[dim];
    FT_Pos           dist     = width;
    FT_Int           sign     = 0;
    FT_Int           vertical = ( dim == AF_DIMENSION_VERT );


    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
         axis->extra_light                       )
      return width;

    if ( dist < 0 )
    {
      dist = -width;
      sign = 1;
    }

    if ( (  vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
         ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )
    {
      /* smooth hinting process: very lightly quantize the stem width */

      /* leave the widths of serifs alone */
      if ( ( stem_flags & AF_EDGE_SERIF ) &&
           vertical                       &&
           ( dist < 3 * 64 )              )
        goto Done_Width;

      else if ( base_flags & AF_EDGE_ROUND )
      {
        if ( dist < 80 )
          dist = 64;
      }
      else if ( dist < 56 )
        dist = 56;

      if ( axis->width_count > 0 )
      {
        FT_Pos  delta;


        /* compare to standard width */
        delta = dist - axis->widths[0].cur;

        if ( delta < 0 )
          delta = -delta;

        if ( delta < 40 )
        {
          dist = axis->widths[0].cur;
          if ( dist < 48 )
            dist = 48;

          goto Done_Width;
        }

        if ( dist < 3 * 64 )
        {
          delta  = dist & 63;
          dist  &= -64;

          if ( delta < 10 )
            dist += delta;

          else if ( delta < 32 )
            dist += 10;

          else if ( delta < 54 )
            dist += 54;

          else
            dist += delta;
        }
        else
        {
          /* A stem's end position depends on two values: the start        */
          /* position and the stem length.  The former gets usually        */
          /* rounded to the grid, while the latter gets rounded also if it */
          /* exceeds a certain length (see below in this function).  This  */
          /* `double rounding' can lead to a great difference to the       */
          /* original, unhinted position; this normally doesn't matter for */
          /* large PPEM values, but for small sizes it can easily make     */
          /* outlines collide.  For this reason, we adjust the stem length */
          /* by a small amount depending on the PPEM value in case the     */
          /* former and latter rounding both point into the same           */
          /* direction.                                                    */

          FT_Pos  bdelta = 0;


          if ( ( ( width > 0 ) && ( base_delta > 0 ) ) ||
               ( ( width < 0 ) && ( base_delta < 0 ) ) )
          {
            FT_UInt  ppem = metrics->root.scaler.face->size->metrics.x_ppem;


            if ( ppem < 10 )
              bdelta = base_delta;
            else if ( ppem < 30 )
              bdelta = ( base_delta * (FT_Pos)( 30 - ppem ) ) / 20;

            if ( bdelta < 0 )
              bdelta = -bdelta;
          }

          dist = ( dist - bdelta + 32 ) & ~63;
        }
      }
    }
    else
    {
      /* strong hinting process: snap the stem width to integer pixels */

      FT_Pos  org_dist = dist;


      dist = af_latin_snap_width( axis->widths, axis->width_count, dist );

      if ( vertical )
      {
        /* in the case of vertical hinting, always round */
        /* the stem heights to integer pixels            */

        if ( dist >= 64 )
          dist = ( dist + 16 ) & ~63;
        else
          dist = 64;
      }
      else
      {
        if ( AF_LATIN_HINTS_DO_MONO( hints ) )
        {
          /* monochrome horizontal hinting: snap widths to integer pixels */
          /* with a different threshold                                   */

          if ( dist < 64 )
            dist = 64;
          else
            dist = ( dist + 32 ) & ~63;
        }
        else
        {
          /* for horizontal anti-aliased hinting, we adopt a more subtle */
          /* approach: we strengthen small stems, round stems whose size */
          /* is between 1 and 2 pixels to an integer, otherwise nothing  */

          if ( dist < 48 )
            dist = ( dist + 64 ) >> 1;

          else if ( dist < 128 )
          {
            /* We only round to an integer width if the corresponding */
            /* distortion is less than 1/4 pixel.  Otherwise this     */
            /* makes everything worse since the diagonals, which are  */
            /* not hinted, appear a lot bolder or thinner than the    */
            /* vertical stems.                                        */

            FT_Pos  delta;


            dist = ( dist + 22 ) & ~63;
            delta = dist - org_dist;
            if ( delta < 0 )
              delta = -delta;

            if ( delta >= 16 )
            {
              dist = org_dist;
              if ( dist < 48 )
                dist = ( dist + 64 ) >> 1;
            }
          }
          else
            /* round otherwise to prevent color fringes in LCD mode */
            dist = ( dist + 32 ) & ~63;
        }
      }
    }

  Done_Width:
    if ( sign )
      dist = -dist;

    return dist;
  }


  /* Align one stem edge relative to the previous stem edge. */

  static void
  af_latin_align_linked_edge( AF_GlyphHints  hints,
                              AF_Dimension   dim,
                              AF_Edge        base_edge,
                              AF_Edge        stem_edge )
  {
    FT_Pos  dist, base_delta;
    FT_Pos  fitted_width;


    dist       = stem_edge->opos - base_edge->opos;
    base_delta = base_edge->pos - base_edge->opos;

    fitted_width = af_latin_compute_stem_width( hints, dim,
                                                dist, base_delta,
                                                base_edge->flags,
                                                stem_edge->flags );


    stem_edge->pos = base_edge->pos + fitted_width;

    FT_TRACE5(( "  LINK: edge %d (opos=%.2f) linked to %.2f,"
                " dist was %.2f, now %.2f\n",
                stem_edge - hints->axis[dim].edges, stem_edge->opos / 64.0,
                stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
  }


  /* Shift the coordinates of the `serif' edge by the same amount */
  /* as the corresponding `base' edge has been moved already.     */

  static void
  af_latin_align_serif_edge( AF_GlyphHints  hints,
                             AF_Edge        base,
                             AF_Edge        serif )
  {
    FT_UNUSED( hints );

    serif->pos = base->pos + ( serif->opos - base->opos );
  }


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****                    E D G E   H I N T I N G                      ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


  /* The main grid-fitting routine. */

  static void
  af_latin_hint_edges( AF_GlyphHints  hints,
                       AF_Dimension   dim )
  {
    AF_AxisHints  axis       = &hints->axis[dim];
    AF_Edge       edges      = axis->edges;
    AF_Edge       edge_limit = edges + axis->num_edges;
    FT_PtrDist    n_edges;
    AF_Edge       edge;
    AF_Edge       anchor     = NULL;
    FT_Int        has_serifs = 0;

    AF_StyleClass   style_class  = hints->metrics->style_class;
    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                     [style_class->script];

    FT_Bool  top_to_bottom_hinting = 0;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_UInt  num_actions = 0;
#endif


    FT_TRACE5(( "latin %s edge hinting (style `%s')\n",
                dim == AF_DIMENSION_VERT ? "horizontal" : "vertical",
                af_style_names[hints->metrics->style_class->style] ));

    if ( dim == AF_DIMENSION_VERT )
      top_to_bottom_hinting = script_class->top_to_bottom_hinting;

    /* we begin by aligning all stems relative to the blue zone */
    /* if needed -- that's only for horizontal edges            */

    if ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_BLUES( hints ) )
    {
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        AF_Width  blue;
        AF_Edge   edge1, edge2; /* these edges form the stem to check */


        if ( edge->flags & AF_EDGE_DONE )
          continue;

        edge1 = NULL;
        edge2 = edge->link;

        /*
         *  If a stem contains both a neutral and a non-neutral blue zone,
         *  skip the neutral one.  Otherwise, outlines with different
         *  directions might be incorrectly aligned at the same vertical
         *  position.
         *
         *  If we have two neutral blue zones, skip one of them.
         *
         */
        if ( edge->blue_edge && edge2 && edge2->blue_edge )
        {
          FT_Byte  neutral  = edge->flags  & AF_EDGE_NEUTRAL;
          FT_Byte  neutral2 = edge2->flags & AF_EDGE_NEUTRAL;


          if ( neutral2 )
          {
            edge2->blue_edge = NULL;
            edge2->flags    &= ~AF_EDGE_NEUTRAL;
          }
          else if ( neutral )
          {
            edge->blue_edge = NULL;
            edge->flags    &= ~AF_EDGE_NEUTRAL;
          }
        }

        blue = edge->blue_edge;
        if ( blue )
          edge1 = edge;

        /* flip edges if the other edge is aligned to a blue zone */
        else if ( edge2 && edge2->blue_edge )
        {
          blue  = edge2->blue_edge;
          edge1 = edge2;
          edge2 = edge;
        }

        if ( !edge1 )
          continue;

#ifdef FT_DEBUG_LEVEL_TRACE
        if ( !anchor )
          FT_TRACE5(( "  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,"
                      " was %.2f (anchor=edge %d)\n",
                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
                      edge1->pos / 64.0, edge - edges ));
        else
          FT_TRACE5(( "  BLUE: edge %d (opos=%.2f) snapped to %.2f,"
                      " was %.2f\n",
                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
                      edge1->pos / 64.0 ));

        num_actions++;
#endif

        edge1->pos    = blue->fit;
        edge1->flags |= AF_EDGE_DONE;

        if ( edge2 && !edge2->blue_edge )
        {
          af_latin_align_linked_edge( hints, dim, edge1, edge2 );
          edge2->flags |= AF_EDGE_DONE;

#ifdef FT_DEBUG_LEVEL_TRACE
          num_actions++;
#endif
        }

        if ( !anchor )
          anchor = edge;
      }
    }

    /* now we align all other stem edges, trying to maintain the */
    /* relative order of stems in the glyph                      */
    for ( edge = edges; edge < edge_limit; edge++ )
    {
      AF_Edge  edge2;


      if ( edge->flags & AF_EDGE_DONE )
        continue;

      /* skip all non-stem edges */
      edge2 = edge->link;
      if ( !edge2 )
      {
        has_serifs++;
        continue;
      }

      /* now align the stem */

      /* this should not happen, but it's better to be safe */
      if ( edge2->blue_edge )
      {
        FT_TRACE5(( "  ASSERTION FAILED for edge %d\n", edge2 - edges ));

        af_latin_align_linked_edge( hints, dim, edge2, edge );
        edge->flags |= AF_EDGE_DONE;

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif
        continue;
      }

      if ( !anchor )
      {
        /* if we reach this if clause, no stem has been aligned yet */

        FT_Pos  org_len, org_center, cur_len;
        FT_Pos  cur_pos1, error1, error2, u_off, d_off;


        org_len = edge2->opos - edge->opos;
        cur_len = af_latin_compute_stem_width( hints, dim,
                                               org_len, 0,
                                               edge->flags,
                                               edge2->flags );

        /* some voodoo to specially round edges for small stem widths; */
        /* the idea is to align the center of a stem, then shifting    */
        /* the stem edges to suitable positions                        */
        if ( cur_len <= 64 )
        {
          /* width <= 1px */
          u_off = 32;
          d_off = 32;
        }
        else
        {
          /* 1px < width < 1.5px */
          u_off = 38;
          d_off = 26;
        }

        if ( cur_len < 96 )
        {
          org_center = edge->opos + ( org_len >> 1 );
          cur_pos1   = FT_PIX_ROUND( org_center );

          error1 = org_center - ( cur_pos1 - u_off );
          if ( error1 < 0 )
            error1 = -error1;

          error2 = org_center - ( cur_pos1 + d_off );
          if ( error2 < 0 )
            error2 = -error2;

          if ( error1 < error2 )
            cur_pos1 -= u_off;
          else
            cur_pos1 += d_off;

          edge->pos  = cur_pos1 - cur_len / 2;
          edge2->pos = edge->pos + cur_len;
        }
        else
          edge->pos = FT_PIX_ROUND( edge->opos );

        anchor       = edge;
        edge->flags |= AF_EDGE_DONE;

        FT_TRACE5(( "  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)"
                    " snapped to %.2f and %.2f\n",
                    edge - edges, edge->opos / 64.0,
                    edge2 - edges, edge2->opos / 64.0,
                    edge->pos / 64.0, edge2->pos / 64.0 ));

        af_latin_align_linked_edge( hints, dim, edge, edge2 );

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions += 2;
#endif
      }
      else
      {
        FT_Pos  org_pos, org_len, org_center, cur_len;
        FT_Pos  cur_pos1, cur_pos2, delta1, delta2;


        org_pos    = anchor->pos + ( edge->opos - anchor->opos );
        org_len    = edge2->opos - edge->opos;
        org_center = org_pos + ( org_len >> 1 );

        cur_len = af_latin_compute_stem_width( hints, dim,
                                               org_len, 0,
                                               edge->flags,
                                               edge2->flags );

        if ( edge2->flags & AF_EDGE_DONE )
        {
          FT_TRACE5(( "  ADJUST: edge %d (pos=%.2f) moved to %.2f\n",
                      edge - edges, edge->pos / 64.0,
                      ( edge2->pos - cur_len ) / 64.0 ));

          edge->pos = edge2->pos - cur_len;
        }

        else if ( cur_len < 96 )
        {
          FT_Pos  u_off, d_off;


          cur_pos1 = FT_PIX_ROUND( org_center );

          if ( cur_len <= 64 )
          {
            u_off = 32;
            d_off = 32;
          }
          else
          {
            u_off = 38;
            d_off = 26;
          }

          delta1 = org_center - ( cur_pos1 - u_off );
          if ( delta1 < 0 )
            delta1 = -delta1;

          delta2 = org_center - ( cur_pos1 + d_off );
          if ( delta2 < 0 )
            delta2 = -delta2;

          if ( delta1 < delta2 )
            cur_pos1 -= u_off;
          else
            cur_pos1 += d_off;

          edge->pos  = cur_pos1 - cur_len / 2;
          edge2->pos = cur_pos1 + cur_len / 2;

          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
                      " snapped to %.2f and %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge2 - edges, edge2->opos / 64.0,
                      edge->pos / 64.0, edge2->pos / 64.0 ));
        }

        else
        {
          org_pos    = anchor->pos + ( edge->opos - anchor->opos );
          org_len    = edge2->opos - edge->opos;
          org_center = org_pos + ( org_len >> 1 );

          cur_len    = af_latin_compute_stem_width( hints, dim,
                                                    org_len, 0,
                                                    edge->flags,
                                                    edge2->flags );

          cur_pos1 = FT_PIX_ROUND( org_pos );
          delta1   = cur_pos1 + ( cur_len >> 1 ) - org_center;
          if ( delta1 < 0 )
            delta1 = -delta1;

          cur_pos2 = FT_PIX_ROUND( org_pos + org_len ) - cur_len;
          delta2   = cur_pos2 + ( cur_len >> 1 ) - org_center;
          if ( delta2 < 0 )
            delta2 = -delta2;

          edge->pos  = ( delta1 < delta2 ) ? cur_pos1 : cur_pos2;
          edge2->pos = edge->pos + cur_len;

          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
                      " snapped to %.2f and %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge2 - edges, edge2->opos / 64.0,
                      edge->pos / 64.0, edge2->pos / 64.0 ));
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif

        edge->flags  |= AF_EDGE_DONE;
        edge2->flags |= AF_EDGE_DONE;

        if ( edge > edges                                             &&
             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                     : ( edge->pos < edge[-1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[-1].pos / 64.0 ));

            num_actions++;
#endif

            edge->pos = edge[-1].pos;
          }
        }
      }
    }

    /* make sure that lowercase m's maintain their symmetry */

    /* In general, lowercase m's have six vertical edges if they are sans */
    /* serif, or twelve if they are with serifs.  This implementation is  */
    /* based on that assumption, and seems to work very well with most    */
    /* faces.  However, if for a certain face this assumption is not      */
    /* true, the m is just rendered like before.  In addition, any stem   */
    /* correction will only be applied to symmetrical glyphs (even if the */
    /* glyph is not an m), so the potential for unwanted distortion is    */
    /* relatively low.                                                    */

    /* We don't handle horizontal edges since we can't easily assure that */
    /* the third (lowest) stem aligns with the base line; it might end up */
    /* one pixel higher or lower.                                         */

    n_edges = edge_limit - edges;
    if ( dim == AF_DIMENSION_HORZ && ( n_edges == 6 || n_edges == 12 ) )
    {
      AF_Edge  edge1, edge2, edge3;
      FT_Pos   dist1, dist2, span, delta;


      if ( n_edges == 6 )
      {
        edge1 = edges;
        edge2 = edges + 2;
        edge3 = edges + 4;
      }
      else
      {
        edge1 = edges + 1;
        edge2 = edges + 5;
        edge3 = edges + 9;
      }

      dist1 = edge2->opos - edge1->opos;
      dist2 = edge3->opos - edge2->opos;

      span = dist1 - dist2;
      if ( span < 0 )
        span = -span;

      if ( span < 8 )
      {
        delta = edge3->pos - ( 2 * edge2->pos - edge1->pos );
        edge3->pos -= delta;
        if ( edge3->link )
          edge3->link->pos -= delta;

        /* move the serifs along with the stem */
        if ( n_edges == 12 )
        {
          ( edges + 8 )->pos -= delta;
          ( edges + 11 )->pos -= delta;
        }

        edge3->flags |= AF_EDGE_DONE;
        if ( edge3->link )
          edge3->link->flags |= AF_EDGE_DONE;
      }
    }

    if ( has_serifs || !anchor )
    {
      /*
       *  now hint the remaining edges (serifs and single) in order
       *  to complete our processing
       */
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Pos  delta;


        if ( edge->flags & AF_EDGE_DONE )
          continue;

        delta = 1000;

        if ( edge->serif )
        {
          delta = edge->serif->opos - edge->opos;
          if ( delta < 0 )
            delta = -delta;
        }

        if ( delta < 64 + 16 )
        {
          af_latin_align_serif_edge( hints, edge->serif, edge );
          FT_TRACE5(( "  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)"
                      " aligned to %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge->serif - edges, edge->serif->opos / 64.0,
                      edge->pos / 64.0 ));
        }
        else if ( !anchor )
        {
          edge->pos = FT_PIX_ROUND( edge->opos );
          anchor    = edge;
          FT_TRACE5(( "  SERIF_ANCHOR: edge %d (opos=%.2f)"
                      " snapped to %.2f\n",
                      edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
        }
        else
        {
          AF_Edge  before, after;


          for ( before = edge - 1; before >= edges; before-- )
            if ( before->flags & AF_EDGE_DONE )
              break;

          for ( after = edge + 1; after < edge_limit; after++ )
            if ( after->flags & AF_EDGE_DONE )
              break;

          if ( before >= edges && before < edge   &&
               after < edge_limit && after > edge )
          {
            if ( after->opos == before->opos )
              edge->pos = before->pos;
            else
              edge->pos = before->pos +
                          FT_MulDiv( edge->opos - before->opos,
                                     after->pos - before->pos,
                                     after->opos - before->opos );

            FT_TRACE5(( "  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f"
                        " from %d (opos=%.2f)\n",
                        edge - edges, edge->opos / 64.0,
                        edge->pos / 64.0,
                        before - edges, before->opos / 64.0 ));
          }
          else
          {
            edge->pos = anchor->pos +
                        ( ( edge->opos - anchor->opos + 16 ) & ~31 );
            FT_TRACE5(( "  SERIF_LINK2: edge %d (opos=%.2f)"
                        " snapped to %.2f\n",
                        edge - edges, edge->opos / 64.0, edge->pos / 64.0 ));
          }
        }

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif
        edge->flags |= AF_EDGE_DONE;

        if ( edge > edges                                             &&
             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                     : ( edge->pos < edge[-1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[-1].pos / 64.0 ));

            num_actions++;
#endif
            edge->pos = edge[-1].pos;
          }
        }

        if ( edge + 1 < edge_limit                                   &&
             edge[1].flags & AF_EDGE_DONE                            &&
             ( top_to_bottom_hinting ? ( edge->pos < edge[1].pos )
                                     : ( edge->pos > edge[1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[1].pos / 64.0 ));

            num_actions++;
#endif

            edge->pos = edge[1].pos;
          }
        }
      }
    }

#ifdef FT_DEBUG_LEVEL_TRACE
    if ( !num_actions )
      FT_TRACE5(( "  (none)\n" ));
    FT_TRACE5(( "\n" ));
#endif
  }


  /* Apply the complete hinting algorithm to a latin glyph. */

  static FT_Error
  af_latin_hints_apply( FT_UInt          glyph_index,
                        AF_GlyphHints    hints,
                        FT_Outline*      outline,
                        AF_LatinMetrics  metrics )
  {
    FT_Error  error;
    int       dim;

    AF_LatinAxis  axis;


    error = af_glyph_hints_reload( hints, outline );
    if ( error )
      goto Exit;

    /* analyze glyph outline */
#ifdef AF_CONFIG_OPTION_USE_WARPER
    if ( ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
           AF_HINTS_DO_WARP( hints )                                ) ||
         AF_HINTS_DO_HORIZONTAL( hints )                              )
#else
    if ( AF_HINTS_DO_HORIZONTAL( hints ) )
#endif
    {
      axis  = &metrics->axis[AF_DIMENSION_HORZ];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_HORZ );
      if ( error )
        goto Exit;
    }

    if ( AF_HINTS_DO_VERTICAL( hints ) )
    {
      axis  = &metrics->axis[AF_DIMENSION_VERT];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_VERT );
      if ( error )
        goto Exit;

      /* apply blue zones to base characters only */
      if ( !( metrics->root.globals->glyph_styles[glyph_index] & AF_NONBASE ) )
        af_latin_hints_compute_blue_edges( hints, metrics );
    }

    /* grid-fit the outline */
    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
#ifdef AF_CONFIG_OPTION_USE_WARPER
      if ( dim == AF_DIMENSION_HORZ                                 &&
           metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
           AF_HINTS_DO_WARP( hints )                                )
      {
        AF_WarperRec  warper;
        FT_Fixed      scale;
        FT_Pos        delta;


        af_warper_compute( &warper, hints, (AF_Dimension)dim,
                           &scale, &delta );
        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,
                                  scale, delta );
        continue;
      }
#endif /* AF_CONFIG_OPTION_USE_WARPER */

      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
      {
        af_latin_hint_edges( hints, (AF_Dimension)dim );
        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
      }
    }

    af_glyph_hints_save( hints, outline );

  Exit:
    return error;
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****              L A T I N   S C R I P T   C L A S S              *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  AF_DEFINE_WRITING_SYSTEM_CLASS(
    af_latin_writing_system_class,

    AF_WRITING_SYSTEM_LATIN,

    sizeof ( AF_LatinMetricsRec ),

    (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init,        /* style_metrics_init    */
    (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale,       /* style_metrics_scale   */
    (AF_WritingSystem_DoneMetricsFunc) NULL,                         /* style_metrics_done    */
    (AF_WritingSystem_GetStdWidthsFunc)af_latin_get_standard_widths, /* style_metrics_getstdw */

    (AF_WritingSystem_InitHintsFunc)   af_latin_hints_init,          /* style_hints_init      */
    (AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply          /* style_hints_apply     */
  )


/* END */
@


1.5
log
@fastmerge
@
text
@d5 1
a5 1
/*    Auto-fitter hinting routines for latin script (body).                */
d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
d21 1
d23 2
d29 1
a29 1
#ifdef AF_USE_WARPER
d35 14
d56 4
d62 1
a62 2
                                FT_Face          face,
                                FT_ULong         charcode )
d68 6
d80 20
a99 5
      FT_Error             error;
      FT_UInt              glyph_index;
      int                  dim;
      AF_LatinMetricsRec   dummy[1];
      AF_Scaler            scaler = &dummy->root.scaler;
d101 2
d104 43
a146 2
      glyph_index = FT_Get_Char_Index( face, charcode );
      if ( glyph_index == 0 )
d149 3
d159 6
a164 2
      scaler->x_scale     = scaler->y_scale = 0x10000L;
      scaler->x_delta     = scaler->y_delta = 0;
d169 1
a169 1
      af_glyph_hints_rescale( hints, (AF_ScriptMetrics)dummy );
d171 1
a171 1
      error = af_glyph_hints_reload( hints, &face->glyph->outline, 0 );
d188 6
d195 2
d217 1
a217 1
              axis->widths[ num_widths++ ].org = dist;
d221 4
a224 1
        af_sort_widths( num_widths, axis->widths );
d228 1
a228 1
  Exit:
d235 2
a236 3
        stdw = ( axis->width_count > 0 )
                 ? axis->widths[0].org
                 : AF_LATIN_CONSTANT( metrics, 50 );
d242 17
d262 2
d268 2
a269 15

#define AF_LATIN_MAX_TEST_CHARACTERS  12


  static const char af_latin_blue_chars[AF_LATIN_MAX_BLUES]
                                       [AF_LATIN_MAX_TEST_CHARACTERS + 1] =
  {
    "THEZOCQS",
    "HEZLOCUS",
    "fijkdbh",
    "xzroesc",
    "xzroesc",
    "pqgjy"
  };

d275 6
a280 5
    FT_Pos        flats [AF_LATIN_MAX_TEST_CHARACTERS];
    FT_Pos        rounds[AF_LATIN_MAX_TEST_CHARACTERS];
    FT_Int        num_flats;
    FT_Int        num_rounds;
    FT_Int        bb;
d283 2
a284 2
    AF_LatinAxis  axis  = &metrics->axis[AF_DIMENSION_VERT];
    FT_GlyphSlot  glyph = face->glyph;
d286 1
d288 2
a289 3
    /* we compute the blues simply by loading each character from the    */
    /* 'af_latin_blue_chars[blues]' string, then compute its top-most or */
    /* bottom-most points (depending on `AF_IS_TOP_BLUE')                */
d291 1
a291 2
    AF_LOG(( "blue zones computation\n" ));
    AF_LOG(( "------------------------------------------------\n" ));
d293 13
a305 1
    for ( bb = 0; bb < AF_LATIN_BLUE_MAX; bb++ )
d307 1
a307 2
      const char*  p     = af_latin_blue_chars[bb];
      const char*  limit = p + AF_LATIN_MAX_TEST_CHARACTERS;
d310 25
d336 25
d362 3
a364 1
      AF_LOG(( "blue %3d: ", bb ));
d368 2
d371 1
a371 1
      for ( ; p < limit && *p; p++ )
d373 3
a375 3
        FT_UInt     glyph_index;
        FT_Pos      best_y; /* same as points.y */
        FT_Int      best_point, best_first, best_last;
a376 1
        FT_Bool     round = 0;
d378 18
d397 1
a397 1
        AF_LOG(( "'%c'", *p ));
d399 3
a401 3
        /* load the character in the face -- skip unknown or empty ones */
        glyph_index = FT_Get_Char_Index( face, (FT_UInt)*p );
        if ( glyph_index == 0 )
d403 1
d405 4
a408 3
        error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
        if ( error || glyph->outline.n_points <= 0 )
          continue;
d410 19
a428 6
        /* now compute min or max point indices and coordinates */
        points      = glyph->outline.points;
        best_point  = -1;
        best_y      = 0;  /* make compiler happy */
        best_first  = 0;  /* ditto */
        best_last   = 0;  /* ditto */
d430 14
a443 4
        {
          FT_Int  nn;
          FT_Int  first = 0;
          FT_Int  last  = -1;
d445 6
a451 1
          for ( nn = 0; nn < glyph->outline.n_contours; first = last+1, nn++ )
d453 9
a461 2
            FT_Int  old_best_point = best_point;
            FT_Int  pp;
d464 1
a464 1
            last = glyph->outline.contours[nn];
d466 5
a470 4
            /* Avoid single-point contours since they are never rasterized. */
            /* In some fonts, they correspond to mark attachment points     */
            /* which are way outside of the glyph's real outline.           */
            if ( last <= first )
d473 18
a490 4
            if ( AF_LATIN_IS_TOP_BLUE( bb ) )
            {
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y > best_y )
d492 8
a499 2
                  best_point = pp;
                  best_y     = points[pp].y;
d501 29
d533 2
a534 6
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y < best_y )
                {
                  best_point = pp;
                  best_y     = points[pp].y;
                }
d537 7
a543 1
            if ( best_point != old_best_point )
d545 119
a663 6
              best_first = first;
              best_last  = last;
            }
          }
          AF_LOG(( "%5d", best_y ));
        }
a664 7
        /* now check whether the point belongs to a straight or round   */
        /* segment; we first need to find in which contour the extremum */
        /* lies, then inspect its previous and next points              */
        if ( best_point >= 0 )
        {
          FT_Int  prev, next;
          FT_Pos  dist;
d666 93
d760 2
a761 4
          /* now look for the previous and next points that are not on the */
          /* same Y coordinate.  Threshold the `closeness'...              */
          prev = best_point;
          next = prev;
d763 2
a764 6
          do
          {
            if ( prev > best_first )
              prev--;
            else
              prev = best_last;
d766 3
a768 3
            dist = points[prev].y - best_y;
            if ( dist < -5 || dist > 5 )
              break;
d770 13
a782 1
          } while ( prev != best_point );
d784 14
a797 4
          do
          {
            if ( next < best_last )
              next++;
d799 12
a810 1
              next = best_first;
d812 2
a813 3
            dist = points[next].y - best_y;
            if ( dist < -5 || dist > 5 )
              break;
d815 16
a830 1
          } while ( next != best_point );
d832 1
a832 4
          /* now, set the `round' flag depending on the segment's kind */
          round = FT_BOOL(
            FT_CURVE_TAG( glyph->outline.tags[prev] ) != FT_CURVE_TAG_ON ||
            FT_CURVE_TAG( glyph->outline.tags[next] ) != FT_CURVE_TAG_ON );
d834 7
a840 1
          AF_LOG(( "%c ", round ? 'r' : 'f' ));
d843 1
a843 7
        if ( round )
          rounds[num_rounds++] = best_y;
        else
          flats[num_flats++]   = best_y;
      }

      AF_LOG(( "\n" ));
d851 1
a851 1
        AF_LOG(( "empty\n" ));
d861 3
a863 3
      blue       = & axis->blues[axis->blue_count];
      blue_ref   = & blue->ref.org;
      blue_shoot = & blue->shoot.org;
d879 1
a879 1
        *blue_ref   = flats[num_flats / 2];
d893 9
a901 2
        if ( AF_LATIN_IS_TOP_BLUE( bb ) ^ over_ref )
          *blue_shoot = *blue_ref = ( shoot + ref ) / 2;
d904 3
d908 1
a908 1
      if ( AF_LATIN_IS_TOP_BLUE( bb ) )
d910 4
d920 1
a920 1
      if ( bb == AF_LATIN_BLUE_SMALL_TOP )
d923 9
a931 2
      AF_LOG(( "-- ref = %ld, shoot = %ld\n", *blue_ref, *blue_shoot ));
    }
d937 2
a942 1
    FT_UInt   i;
d946 6
d953 4
a956 3
    /* check whether all ASCII digits have the same advance width; */
    /* digit `0' is 0x30 in all supported charmaps                 */
    for ( i = 0x30; i <= 0x39; i++ )
d958 2
a959 1
      FT_UInt  glyph_index;
d962 3
a964 2
      glyph_index = FT_Get_Char_Index( face, i );
      if ( glyph_index == 0 )
d967 6
a972 5
      if ( FT_Get_Advance( face, glyph_index,
                           FT_LOAD_NO_SCALE         |
                           FT_LOAD_NO_HINTING       |
                           FT_LOAD_IGNORE_TRANSFORM,
                           &advance ) )
d990 2
d996 2
a1001 1
    FT_Error    error = AF_Err_Ok;
a1002 10
    FT_UInt     ee;

    static const FT_Encoding  latin_encodings[] =
    {
      FT_ENCODING_UNICODE,
      FT_ENCODING_APPLE_ROMAN,
      FT_ENCODING_ADOBE_STANDARD,
      FT_ENCODING_ADOBE_LATIN_1,
      FT_ENCODING_NONE  /* end of list */
    };
d1007 1
a1007 9
    /* do we have a latin charmap in there? */
    for ( ee = 0; latin_encodings[ee] != FT_ENCODING_NONE; ee++ )
    {
      error = FT_Select_Charmap( face, latin_encodings[ee] );
      if ( !error )
        break;
    }

    if ( !error )
d1009 1
a1009 2
      /* For now, compute the standard width and height from the `o'. */
      af_latin_metrics_init_widths( metrics, face, 'o' );
d1015 1
a1015 1
    return AF_Err_Ok;
d1019 3
d1072 18
a1089 2
        FT_Pos  scaled = FT_MulFix( blue->shoot.org, scaler->y_scale );
        FT_Pos  fitted = ( scaled + 40 ) & ~63;
d1091 1
d1105 46
a1150 1
            scale = FT_MulDiv( scale, fitted, scaled );
d1170 5
a1174 1
    /* scale the standard widths */
d1182 4
d1188 2
d1191 1
a1191 1
    /* smaller than 0.75 pixels                                    */
d1195 7
d1204 6
d1227 5
a1231 1
          FT_Pos  delta1, delta2;
d1233 1
d1235 3
d1258 22
d1283 55
d1342 2
d1350 1
d1357 16
d1381 3
d1388 11
a1398 8
    AF_AxisHints  axis          = &hints->axis[dim];
    FT_Memory     memory        = hints->memory;
    FT_Error      error         = AF_Err_Ok;
    AF_Segment    segment       = NULL;
    AF_SegmentRec seg0;
    AF_Point*     contour       = hints->contours;
    AF_Point*     contour_limit = contour + hints->num_contours;
    AF_Direction  major_dir, segment_dir;
d1439 28
a1466 7
      AF_Point  point   =  contour[0];
      AF_Point  last    =  point->prev;
      int       on_edge =  0;
      FT_Pos    min_pos =  32000;  /* minimum segment pos != min_coord */
      FT_Pos    max_pos = -32000;  /* maximum segment pos != max_coord */
      FT_Bool   passed;

a1467 2
      if ( point == last )  /* skip singletons -- just in case */
        continue;
d1498 1
d1505 23
d1530 107
a1636 9
            /* we are just leaving an edge; record a new segment! */
            segment->last = point;
            segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );

            /* a segment is round if either its first or last point */
            /* is a control point                                   */
            if ( ( segment->first->flags | point->flags ) &
                   AF_FLAG_CONTROL                        )
              segment->flags |= AF_EDGE_ROUND;
d1638 29
a1666 2
            /* compute segment size */
            min_pos = max_pos = point->v;
d1668 2
a1669 10
            v = segment->first->v;
            if ( v < min_pos )
              min_pos = v;
            if ( v > max_pos )
              max_pos = v;

            segment->min_coord = (FT_Short)min_pos;
            segment->max_coord = (FT_Short)max_pos;
            segment->height    = (FT_Short)( segment->max_coord -
                                             segment->min_coord );
d1673 2
a1674 1
            /* fallthrough */
d1686 6
a1691 1
        if ( !on_edge && FT_ABS( point->out_dir ) == major_dir )
a1695 1
          /* clear all segment fields */
d1700 43
a1742 7
          segment[0]        = seg0;
          segment->dir      = (FT_Char)segment_dir;
          min_pos = max_pos = point->u;
          segment->first    = point;
          segment->last     = point;
          segment->contour  = contour;
          on_edge           = 1;
d1751 2
a1752 2
    /* now slightly increase the height of segments when this makes */
    /* sense -- this is used to better detect and ignore serifs     */
a1765 3
        if ( first == last )
          continue;

d1804 3
d1809 2
d1816 1
a1816 1
    FT_Pos        len_threshold, len_score;
d1820 6
d1830 1
d1833 5
d1841 1
a1841 3
      /* the fake segments are introduced to hint the metrics -- */
      /* we must never link them to anything                     */
      if ( seg1->dir != axis->major_dir || seg1->first == seg1->last )
d1844 2
d1847 6
a1852 1
        if ( seg1->dir + seg2->dir == 0 && seg2->pos > seg1->pos )
d1854 5
a1858 3
          FT_Pos  pos1 = seg1->pos;
          FT_Pos  pos2 = seg2->pos;
          FT_Pos  dist = pos2 - pos1;
d1860 2
d1863 2
a1864 2
          if ( dist < 0 )
            dist = -dist;
d1866 4
d1871 13
a1883 3
            FT_Pos  min = seg1->min_coord;
            FT_Pos  max = seg1->max_coord;
            FT_Pos  len, score;
d1885 1
d1887 1
a1887 2
            if ( min < seg2->min_coord )
              min = seg2->min_coord;
a1888 2
            if ( max > seg2->max_coord )
              max = seg2->max_coord;
d1890 1
a1890 2
            len = max - min;
            if ( len >= len_threshold )
d1892 14
a1905 1
              score = dist + len_score / len;
d1907 8
a1914 5
              if ( score < seg1->score )
              {
                seg1->score = score;
                seg1->link  = seg2;
              }
d1916 4
a1919 5
              if ( score < seg2->score )
              {
                seg2->score = score;
                seg2->link  = seg1;
              }
d1923 1
d1926 1
a1926 1
    /* now, compute the `serif' segments */
d1943 2
d1950 1
a1950 1
    FT_Error      error  = AF_Err_Ok;
d1954 6
d1964 1
d1966 1
d1970 1
d1978 1
d1981 4
d1987 1
a1987 1
     *  We ignore all segments that are less than 1 pixels in length,
d1992 1
a1992 1
        segment_length_threshold = FT_DivFix( 64, hints->y_scale );
d1994 7
a2000 1
        segment_length_threshold = 0;
d2004 3
a2006 3
    /* We will begin by generating a sorted table of edges for the       */
    /* current direction.  To do so, we simply scan each segment and try */
    /* to find an edge in our table that corresponds to its position.    */
d2010 1
a2010 1
    /* list which will be processed in the second step to compute the    */
d2013 1
a2013 1
    /* Note that the edges table is sorted along the segment/edge        */
d2018 1
d2029 1
a2029 1
      AF_Edge  found = 0;
d2033 5
a2037 1
      if ( seg->height < segment_length_threshold )
d2073 1
d2083 1
d2085 2
a2086 2
        edge->dir      = seg->dir;
        edge->opos     = edge->pos = FT_MulFix( seg->pos, scale );
d2099 38
d2138 11
a2148 11
    /*********************************************************************/
    /*                                                                   */
    /* Good, we will now compute each edge's properties according to     */
    /* segments found on its position.  Basically, these are:            */
    /*                                                                   */
    /*  - edge's main direction                                          */
    /*  - stem edge, serif edge or both (which defaults to stem then)    */
    /*  - rounded edge, straight or both (which defaults to straight)    */
    /*  - link for edge                                                  */
    /*                                                                   */
    /*********************************************************************/
d2176 1
a2176 1
      /* now, compute each edge properties */
d2181 1
d2184 1
d2200 1
d2203 1
a2203 1
            ups   += seg->max_coord-seg->min_coord;
d2205 2
a2206 1
            downs += seg->max_coord-seg->min_coord;
d2214 1
a2214 1
          if ( ( seg->link && seg->link->edge != NULL ) || is_serif )
d2282 1
a2282 1
        /* gets rid of serifs if link is set                */
d2287 1
a2287 1
          edge->serif = 0;
d2296 2
d2300 2
d2310 1
a2310 1
      af_latin_hints_link_segments( hints, dim );
d2314 1
d2319 3
a2321 1
  FT_LOCAL_DEF( void )
d2325 1
a2325 1
    AF_AxisHints  axis       = &hints->axis[ AF_DIMENSION_VERT ];
d2328 1
a2328 1
    AF_LatinAxis  latin      = &metrics->axis[ AF_DIMENSION_VERT ];
d2338 4
a2341 3
      FT_Int    bb;
      AF_Width  best_blue = NULL;
      FT_Pos    best_dist;  /* initial threshold */
d2345 1
d2348 1
d2352 1
a2352 1
      for ( bb = 0; bb < AF_LATIN_BLUE_MAX; bb++ )
d2355 1
a2355 1
        FT_Bool       is_top_blue, is_major_dir;
d2358 1
a2358 1
        /* skip inactive blue zones (i.e., those that are too small) */
d2362 14
a2375 11
        /* if it is a top zone, check for right edges -- if it is a bottom */
        /* zone, check for left edges                                      */
        /*                                                                 */
        /* of course, that's for TrueType                                  */
        is_top_blue  = (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_TOP ) != 0 );
        is_major_dir = FT_BOOL( edge->dir == axis->major_dir );

        /* if it is a top zone, the edge must be against the major    */
        /* direction; if it is a bottom zone, it must be in the major */
        /* direction                                                  */
        if ( is_top_blue ^ is_major_dir )
d2388 3
a2390 2
            best_dist = dist;
            best_blue = & blue->ref;
d2393 8
a2400 4
          /* now, compare it to the overshoot position if the edge is     */
          /* rounded, and if the edge is over the reference position of a */
          /* top zone, or under the reference position of a bottom zone   */
          if ( edge->flags & AF_EDGE_ROUND && dist != 0 )
a2406 1
              blue = latin->blues + bb;
d2414 3
a2416 2
                best_dist = dist;
                best_blue = & blue->shoot;
d2424 1
d2426 3
d2433 2
d2444 1
a2444 1
    af_glyph_hints_rescale( hints, (AF_ScriptMetrics)metrics );
d2448 1
a2448 1
     *  been modified `af_latin_metrics_scale_dim' above
d2458 1
a2458 1
#if 0 /* #ifdef AF_USE_WARPER */
a2459 1
    {
a2460 1
    }
d2492 3
d2496 2
a2497 2
    if ( mode == FT_RENDER_MODE_LIGHT                    ||
         (face->style_flags & FT_STYLE_FLAG_ITALIC) != 0 )
d2500 6
d2509 1
a2509 1
    return 0;
d2521 2
a2522 2
  /* snap a given width in scaled coordinates to one of the */
  /* current standard widths                                */
d2526 1
a2526 1
                       FT_Int    count,
d2529 4
a2532 4
    int     n;
    FT_Pos  best      = 64 + 32 + 2;
    FT_Pos  reference = width;
    FT_Pos  scaled;
d2569 3
a2571 1
  /* compute the snapped width of a given stem */
d2577 3
a2579 2
                               AF_Edge_Flags  base_flags,
                               AF_Edge_Flags  stem_flags )
d2581 2
a2582 2
    AF_LatinMetrics  metrics  = (AF_LatinMetrics) hints->metrics;
    AF_LatinAxis     axis     = & metrics->axis[dim];
d2589 1
a2589 1
          axis->extra_light                      )
d2604 3
a2606 2

      if ( ( stem_flags & AF_EDGE_SERIF ) && vertical && ( dist < 3 * 64 ) )
d2609 1
a2609 1
      else if ( ( base_flags & AF_EDGE_ROUND ) )
d2623 1
a2623 3
        if ( axis->width_count > 0 )
        {
          delta = dist - axis->widths[0].cur;
d2625 2
a2626 2
          if ( delta < 0 )
            delta = -delta;
d2628 5
a2632 5
          if ( delta < 40 )
          {
            dist = axis->widths[0].cur;
            if ( dist < 48 )
              dist = 48;
d2634 1
a2634 2
            goto Done_Width;
          }
d2655 33
a2687 1
          dist = ( dist + 32 ) & ~63;
d2693 1
d2746 1
a2746 1
            if (delta >= 16)
d2768 1
a2768 1
  /* align one stem edge relative to the previous stem edge */
d2776 2
a2777 1
    FT_Pos  dist = stem_edge->opos - base_edge->opos;
d2779 8
a2786 4
    FT_Pos  fitted_width = af_latin_compute_stem_width(
                             hints, dim, dist,
                             (AF_Edge_Flags)base_edge->flags,
                             (AF_Edge_Flags)stem_edge->flags );
d2791 4
a2794 4
    AF_LOG(( "LINK: edge %d (opos=%.2f) linked to (%.2f), "
             "dist was %.2f, now %.2f\n",
             stem_edge-hints->axis[dim].edges, stem_edge->opos / 64.0,
             stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
d2798 3
d2808 1
a2808 1
    serif->pos = base->pos + (serif->opos - base->opos);
d2823 3
a2825 1
  FT_LOCAL_DEF( void )
d2834 1
a2834 1
    AF_Edge       anchor     = 0;
d2837 17
d2863 1
a2863 1
        AF_Edge   edge1, edge2;
a2868 1
        blue  = edge->blue_edge;
d2872 28
a2900 1
        {
d2902 2
a2903 1
        }
d2914 14
a2927 4
        AF_LOG(( "BLUE: edge %d (opos=%.2f) snapped to (%.2f), "
                 "was (%.2f)\n",
                 edge1-edges, edge1->opos / 64.0, blue->fit / 64.0,
                 edge1->pos / 64.0 ));
d2936 4
d2947 2
a2948 2
    /* now we will align all stem edges, trying to maintain the */
    /* relative order of stems in the glyph                     */
d2970 1
a2970 1
        AF_LOG(( "ASSERTION FAILED for edge %d\n", edge2-edges ));
d2974 4
d2983 2
d2990 8
a2997 4
        cur_len = af_latin_compute_stem_width(
                    hints, dim, org_len,
                    (AF_Edge_Flags)edge->flags,
                    (AF_Edge_Flags)edge2->flags );
d2999 5
a3003 1
          u_off = d_off = 32;
d3006 1
a3013 1

d3035 2
a3036 6
        AF_LOG(( "ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f) "
                 "snapped to (%.2f) (%.2f)\n",
                 edge-edges, edge->opos / 64.0,
                 edge2-edges, edge2->opos / 64.0,
                 edge->pos / 64.0, edge2->pos / 64.0 ));
        anchor = edge;
d3038 5
a3042 1
        edge->flags |= AF_EDGE_DONE;
d3045 4
d3060 4
a3063 4
        cur_len = af_latin_compute_stem_width(
                   hints, dim, org_len,
                   (AF_Edge_Flags)edge->flags,
                   (AF_Edge_Flags)edge2->flags );
d3066 5
d3072 1
d3081 5
a3085 2
          if (cur_len <= 64 )
            u_off = d_off = 32;
d3108 5
a3112 5
          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
d3114 1
d3121 4
a3124 4
          cur_len    = af_latin_compute_stem_width(
                         hints, dim, org_len,
                         (AF_Edge_Flags)edge->flags,
                         (AF_Edge_Flags)edge2->flags );
d3126 2
a3127 2
          cur_pos1   = FT_PIX_ROUND( org_pos );
          delta1     = cur_pos1 + ( cur_len >> 1 ) - org_center;
d3131 2
a3132 2
          cur_pos2   = FT_PIX_ROUND( org_pos + org_len ) - cur_len;
          delta2     = cur_pos2 + ( cur_len >> 1 ) - org_center;
d3139 5
a3143 5
          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
d3146 4
d3153 19
a3171 5
        if ( edge > edges && edge->pos < edge[-1].pos )
        {
          AF_LOG(( "BOUND: %d (pos=%.2f) to (%.2f)\n",
                   edge-edges, edge->pos / 64.0, edge[-1].pos / 64.0 ));
          edge->pos = edge[-1].pos;
d3264 5
a3268 5
          AF_LOG(( "SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f) "
                   "aligned to (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge->serif - edges, edge->serif->opos / 64.0,
                   edge->pos / 64.0 ));
a3271 2
          AF_LOG(( "SERIF_ANCHOR: edge %d (opos=%.2f) snapped to (%.2f)\n",
                   edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
d3274 3
d3301 6
a3306 5
            AF_LOG(( "SERIF_LINK1: edge %d (opos=%.2f) snapped to (%.2f) "
                     "from %d (opos=%.2f)\n",
                     edge-edges, edge->opos / 64.0,
                     edge->pos / 64.0, before - edges,
                     before->opos / 64.0 ));
d3312 3
a3314 2
            AF_LOG(( "SERIF_LINK2: edge %d (opos=%.2f) snapped to (%.2f)\n",
                     edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
d3318 3
d3323 37
a3359 2
        if ( edge > edges && edge->pos < edge[-1].pos )
          edge->pos = edge[-1].pos;
d3361 3
a3363 4
        if ( edge + 1 < edge_limit        &&
             edge[1].flags & AF_EDGE_DONE &&
             edge->pos > edge[1].pos      )
          edge->pos = edge[1].pos;
d3366 6
d3375 2
d3378 2
a3379 1
  af_latin_hints_apply( AF_GlyphHints    hints,
d3386 2
d3389 1
a3389 1
    error = af_glyph_hints_reload( hints, outline, 1 );
d3394 4
a3397 3
#ifdef AF_USE_WARPER
    if ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ||
         AF_HINTS_DO_HORIZONTAL( hints ) )
d3402 5
a3406 1
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_HORZ );
d3413 5
a3417 1
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_VERT );
d3421 3
a3423 1
      af_latin_hints_compute_blue_edges( hints, metrics );
d3429 4
a3432 3
#ifdef AF_USE_WARPER
      if ( ( dim == AF_DIMENSION_HORZ &&
             metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ) )
d3439 4
a3442 2
        af_warper_compute( &warper, hints, dim, &scale, &delta );
        af_glyph_hints_scale_dim( hints, dim, scale, delta );
d3445 1
a3445 1
#endif
d3456 1
d3473 4
a3476 2
  /* XXX: this should probably fine tuned to differentiate better between */
  /*      scripts...                                                      */
d3478 6
a3483 41
  static const AF_Script_UniRangeRec  af_latin_uniranges[] =
  {
    AF_UNIRANGE_REC(  0x0020UL,  0x007FUL ),  /* Basic Latin (no control chars) */
    AF_UNIRANGE_REC(  0x00A0UL,  0x00FFUL ),  /* Latin-1 Supplement (no control chars) */
    AF_UNIRANGE_REC(  0x0100UL,  0x017FUL ),  /* Latin Extended-A */
    AF_UNIRANGE_REC(  0x0180UL,  0x024FUL ),  /* Latin Extended-B */
    AF_UNIRANGE_REC(  0x0250UL,  0x02AFUL ),  /* IPA Extensions */
    AF_UNIRANGE_REC(  0x02B0UL,  0x02FFUL ),  /* Spacing Modifier Letters */
    AF_UNIRANGE_REC(  0x0300UL,  0x036FUL ),  /* Combining Diacritical Marks */
    AF_UNIRANGE_REC(  0x0370UL,  0x03FFUL ),  /* Greek and Coptic */
    AF_UNIRANGE_REC(  0x0400UL,  0x04FFUL ),  /* Cyrillic */
    AF_UNIRANGE_REC(  0x0500UL,  0x052FUL ),  /* Cyrillic Supplement */
    AF_UNIRANGE_REC(  0x1D00UL,  0x1D7FUL ),  /* Phonetic Extensions */
    AF_UNIRANGE_REC(  0x1D80UL,  0x1DBFUL ),  /* Phonetic Extensions Supplement */
    AF_UNIRANGE_REC(  0x1DC0UL,  0x1DFFUL ),  /* Combining Diacritical Marks Supplement */
    AF_UNIRANGE_REC(  0x1E00UL,  0x1EFFUL ),  /* Latin Extended Additional */
    AF_UNIRANGE_REC(  0x1F00UL,  0x1FFFUL ),  /* Greek Extended */
    AF_UNIRANGE_REC(  0x2000UL,  0x206FUL ),  /* General Punctuation */
    AF_UNIRANGE_REC(  0x2070UL,  0x209FUL ),  /* Superscripts and Subscripts */
    AF_UNIRANGE_REC(  0x20A0UL,  0x20CFUL ),  /* Currency Symbols */
    AF_UNIRANGE_REC(  0x2150UL,  0x218FUL ),  /* Number Forms */
    AF_UNIRANGE_REC(  0x2460UL,  0x24FFUL ),  /* Enclosed Alphanumerics */
    AF_UNIRANGE_REC(  0x2C60UL,  0x2C7FUL ),  /* Latin Extended-C */
    AF_UNIRANGE_REC(  0x2DE0UL,  0x2DFFUL ),  /* Cyrillic Extended-A */
    AF_UNIRANGE_REC(  0xA640UL,  0xA69FUL ),  /* Cyrillic Extended-B */
    AF_UNIRANGE_REC(  0xA720UL,  0xA7FFUL ),  /* Latin Extended-D */
    AF_UNIRANGE_REC(  0xFB00UL,  0xFB06UL ),  /* Alphab. Present. Forms (Latin Ligs) */
    AF_UNIRANGE_REC( 0x1D400UL, 0x1D7FFUL ),  /* Mathematical Alphanumeric Symbols */
    AF_UNIRANGE_REC(       0UL,       0UL )
  };


  AF_DEFINE_SCRIPT_CLASS(af_latin_script_class,  
    AF_SCRIPT_LATIN,
    af_latin_uniranges,

    sizeof( AF_LatinMetricsRec ),

    (AF_Script_InitMetricsFunc) af_latin_metrics_init,
    (AF_Script_ScaleMetricsFunc)af_latin_metrics_scale,
    (AF_Script_DoneMetricsFunc) NULL,
d3485 2
a3486 2
    (AF_Script_InitHintsFunc)   af_latin_hints_init,
    (AF_Script_ApplyHintsFunc)  af_latin_hints_apply
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
d19 3
d152 2
a153 1
  static const char* const  af_latin_blue_chars[AF_LATIN_MAX_BLUES] =
d202 2
a203 1
        FT_Int      best_point, best_y, best_first, best_last;
d336 1
a336 1
        AF_LOG(( "empty!\n" ));
d387 1
a387 1
       * The following flags is used later to adjust the y and x scales
d401 46
d480 1
d1622 1
a1622 1
            FT_Int  delta;
d1706 1
a1706 1
    FT_Int        n_edges;
d2063 4
a2066 1
            edge->pos = before->pos +
d2182 27
a2208 21
    { 0x0020, 0x007F },  /* Basic Latin (no control characters) */
    { 0x00A0, 0x00FF },  /* Latin-1 Supplement (no control characters) */
    { 0x0100, 0x017F },  /* Latin Extended-A */
    { 0x0180, 0x024F },  /* Latin Extended-B */
    { 0x0250, 0x02AF },  /* IPA Extensions */
    { 0x02B0, 0x02FF },  /* Spacing Modifier Letters */
    { 0x0300, 0x036F },  /* Combining Diacritical Marks */
    { 0x0370, 0x03FF },  /* Greek and Coptic */
    { 0x0400, 0x04FF },  /* Cyrillic */
    { 0x0500, 0x052F },  /* Cyrillic Supplement */
    { 0x1D00, 0x1D7F },  /* Phonetic Extensions */
    { 0x1D80, 0x1DBF },  /* Phonetic Extensions Supplement */
    { 0x1DC0, 0x1DFF },  /* Combining Diacritical Marks Supplement */
    { 0x1E00, 0x1EFF },  /* Latin Extended Additional */
    { 0x1F00, 0x1FFF },  /* Greek Extended */
    { 0x2000, 0x206F },  /* General Punctuation */
    { 0x2070, 0x209F },  /* Superscripts and Subscripts */
    { 0x20A0, 0x20CF },  /* Currency Symbols */
    { 0x2150, 0x218F },  /* Number Forms */
    { 0x2460, 0x24FF },  /* Enclosed Alphanumerics */
    { 0     , 0      }
d2212 1
a2212 3
  FT_CALLBACK_TABLE_DEF const AF_ScriptClassRec
  af_latin_script_class =
  {
d2224 1
a2224 1
  };
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d200 1
a200 1
        FT_Bool     round;
d1007 1
a1007 1
        AF_Edge   edge;
d1012 3
a1014 1
        error = af_axis_hints_new_edge( axis, seg->pos, seg->dir, memory, &edge );
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d77 1
a77 1
      error = af_glyph_hints_reload( hints, &face->glyph->outline );
d136 2
d198 1
a198 1
        FT_Vector*  extremum;
a199 2
        FT_Vector*  point_limit;
        FT_Vector*  point;
d216 5
a220 12
        point_limit = points + glyph->outline.n_points;
        point       = points;
        extremum    = point;
        point++;

        if ( AF_LATIN_IS_TOP_BLUE( bb ) )
        {
          for ( ; point < point_limit; point++ )
            if ( point->y > extremum->y )
              extremum = point;
        }
        else
d222 9
a230 4
          for ( ; point < point_limit; point++ )
            if ( point->y < extremum->y )
              extremum = point;
        }
a231 1
        AF_LOG(( "%5d", (int)extremum->y ));
d233 1
a233 8
        /* now, check whether the point belongs to a straight or round  */
        /* segment; we first need to find in which contour the extremum */
        /* lies, then see its previous and next points                  */
        {
          FT_Int  idx = (FT_Int)( extremum - points );
          FT_Int  n;
          FT_Int  first, last, prev, next, end;
          FT_Pos  dist;
d235 5
d241 18
a258 2
          last  = -1;
          first = 0;
d260 1
a260 4
          for ( n = 0; n < glyph->outline.n_contours; n++ )
          {
            end = glyph->outline.contours[n];
            if ( end >= idx )
d262 2
a263 2
              last = end;
              break;
a264 1
            first = end + 1;
d266 10
a276 3
          /* XXX: should never happen! */
          if ( last < 0 )
            continue;
d280 1
a280 2

          prev = idx;
d285 1
a285 1
            if ( prev > first )
d288 1
a288 1
              prev = last;
d290 1
a290 1
            dist = points[prev].y - extremum->y;
d294 1
a294 1
          } while ( prev != idx );
d298 1
a298 1
            if ( next < last )
d301 1
a301 1
              next = first;
d303 1
a303 1
            dist = points[next].y - extremum->y;
d307 1
a307 1
          } while ( next != idx );
d318 1
a318 1
          rounds[num_rounds++] = extremum->y;
d320 1
a320 1
          flats[num_flats++] = extremum->y;
d487 1
a487 1
        FT_Pos  fitted = FT_PIX_ROUND( scaled );
d492 1
d496 1
a496 1
              scale -= scale/50;  /* x_scale = x_scale*0.98 */
d499 2
d532 5
d614 1
d619 4
a622 6
#ifdef AF_HINT_METRICS
    AF_Point  min_point =  0;
    AF_Point  max_point =  0;
    FT_Pos    min_coord =  32000;
    FT_Pos    max_coord = -32000;
#endif
a665 13
#ifdef AF_HINT_METRICS
      if ( point->u < min_coord )
      {
        min_coord = point->u;
        min_point = point;
      }
      if ( point->u > max_coord )
      {
        max_coord = point->u;
        max_point = point;
      }
#endif

d727 2
d754 1
a755 1
          segment->flags    = AF_EDGE_NORMAL;
a759 3
          segment->score    = 32000;
          segment->len      = 0;
          segment->link     = NULL;
a760 8

#ifdef AF_HINT_METRICS
          if ( point == max_point )
            max_point = 0;

          if ( point == min_point )
            min_point = 0;
#endif
a767 4
#ifdef AF_HINT_METRICS
    /* we need to ensure that there are edges on the left-most and  */
    /* right-most points of the glyph in order to hint the metrics; */
    /* we do this by inserting fake segments when needed            */
d769 2
a770 1
    if ( dim == AF_DIMENSION_HORZ )
d772 2
a773 2
      AF_Point  point       = hints->points;
      AF_Point  point_limit = point + hints->num_points;
a774 2
      FT_Pos    min_pos =  32000;
      FT_Pos    max_pos = -32000;
d776 6
a782 2
      min_point = 0;
      max_point = 0;
d784 2
a785 4
      /* compute minimum and maximum points */
      for ( ; point < point_limit; point++ )
      {
        FT_Pos  x = point->fx;
d787 1
a787 2

        if ( x < min_pos )
d789 1
a789 9
          min_pos   = x;
          min_point = point;
        }
        if ( x > max_pos )
        {
          max_pos   = x;
          max_point = point;
        }
      }
a790 7
      /* insert minimum segment */
      if ( min_point )
      {
        /* clear all segment fields */
        error = af_axis_hints_new_segment( axis, memory, &segment );
        if ( error )
          goto Exit;
d792 4
a795 8
        segment->dir   = segment_dir;
        segment->flags = AF_EDGE_NORMAL;
        segment->first = min_point;
        segment->last  = min_point;
        segment->pos   = min_pos;
        segment->score = 32000;
        segment->len   = 0;
        segment->link  = NULL;
d797 8
a804 10
        segment = NULL;
      }

      /* insert maximum segment */
      if ( max_point )
      {
        /* clear all segment fields */
        error = af_axis_hints_new_segment( axis, memory, &segment );
        if ( error )
          goto Exit;
a805 8
        segment->dir   = segment_dir;
        segment->flags = AF_EDGE_NORMAL;
        segment->first = max_point;
        segment->last  = max_point;
        segment->pos   = max_pos;
        segment->score = 32000;
        segment->len   = 0;
        segment->link  = NULL;
d807 10
a816 1
        segment = NULL;
a818 1
#endif /* AF_HINT_METRICS */
a831 1
    AF_Direction  major_dir     = axis->major_dir;
d840 1
a840 1
    len_score = AF_LATIN_CONSTANT( hints->metrics, 3000 );
d847 1
a847 1
      if ( seg1->first == seg1->last || seg1->dir != major_dir )
d851 1
a851 1
        if ( seg2 != seg1 && seg1->dir + seg2->dir == 0 )
d859 1
a859 1
            continue;
a900 1
        seg2->num_linked++;
d927 1
d938 10
d978 9
d998 1
a998 1
        if ( dist < edge_distance_threshold )
d1012 1
a1012 1
        error = af_axis_hints_new_edge( axis, seg->pos, memory, &edge );
d1022 1
d1105 3
a1107 1
          is_serif = (FT_Bool)( seg->serif && seg->serif->edge != edge );
d1109 1
a1109 1
          if ( seg->link || is_serif )
d1163 1
d1175 1
d1318 2
a1319 2
     *  correct x_scale and y_scale when needed, since they may have
     *  been modified af_latin_scale_dim above
d1329 1
a1329 1
#ifdef AF_USE_WARPER
d1449 2
a1450 1
    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) )
d1524 2
d1561 10
d1572 11
d1615 5
d1661 1
a1661 1
    if ( dim == AF_DIMENSION_VERT )
d1690 5
d1730 1
a1730 1
      if ( edge2->blue_edge || edge2 < edge )
d1732 2
d1778 1
a1778 2
          edge2->pos = cur_pos1 + cur_len / 2;

d1783 5
d1809 4
a1812 1
        if ( cur_len < 96 )
d1842 6
d1872 6
d1884 3
d1888 1
d1962 3
d1968 2
d1971 8
d1980 6
d1988 2
d1994 33
a2026 2
          edge->pos = anchor->pos +
                      FT_PIX_ROUND( edge->opos - anchor->opos );
d2051 1
a2051 1
    error = af_glyph_hints_reload( hints, outline );
d2056 4
d2061 1
d2080 3
a2082 2
      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
d2084 3
a2086 7
#ifdef AF_USE_WARPER
        if ( dim == AF_DIMENSION_HORZ &&
             metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL )
        {
          AF_WarperRec  warper;
          FT_Fixed      scale;
          FT_Pos        delta;
d2089 4
a2092 4
          af_warper_compute( &warper, hints, dim, &scale, &delta );
          af_glyph_hints_scale_dim( hints, dim, scale, delta );
          continue;
        }
d2094 4
d2120 3
d2125 21
a2145 3
    { 32,  127 },    /* XXX: TODO: Add new Unicode ranges here! */
    { 160, 255 },
    { 0,   0 }
@


1.1
log
@Initial revision
@
text
@d1 17
a17 1
/* $XFree86: xc/extras/freetype2/src/autofit/aflatin.c,v 1.2 2004/06/09 18:52:02 tsi Exp $ */
d20 6
a26 7
 /***************************************************************************/
 /***************************************************************************/
 /*****                                                                 *****/
 /*****       L A T I N   G L O B A L   M E T R I C S                   *****/
 /*****                                                                 *****/
 /***************************************************************************/
 /***************************************************************************/
d28 9
a36 1
  static void
d38 2
a39 1
                                FT_Face          face )
d44 1
d47 2
a48 2
    metrics->axis[ AF_DIMENSION_HORZ ].width_count = 0;
    metrics->axis[ AF_DIMENSION_VERT ].width_count = 0;
a49 1
    /* For now, compute the standard width and height from the `o' */
d51 5
a55 4
      FT_Error      error;
      FT_UInt       glyph_index;
      AF_Dimension  dim;
      AF_ScalerRec  scaler[1];
d58 1
a58 1
      glyph_index = FT_Get_Char_Index( face, 'o' );
d66 3
d75 3
a77 3
      error = af_glyph_hints_reset( hints, scaler,
                                    (AF_ScriptMetrics) metrics,
                                    &face->glyph->outline );
d81 1
a81 1
      for ( dim = AF_DIMENSION_HORZ; dim < AF_DIMENSION_MAX; dim++ )
d83 2
a84 2
        AF_LatinAxis  axis    = & metrics->axis[ dim ];
        AF_AxisHints  axhints = & hints->axis[ dim ];
a86 1
        FT_Pos        edge_distance_threshold = 32000;
d88 8
a95 2
        af_latin_hints_compute_segments( hints, dim );
        af_latin_hints_link_segments   ( hints, dim );
d103 1
d121 7
a128 8
        /* we will now try to find the smallest width */
        if ( num_widths > 0 && axis->widths[0].org < edge_distance_threshold )
          edge_distance_threshold = axis->widths[0].org;

        /* Now, compute the edge distance threshold as a fraction of the */
        /* smallest width in the font. Set it in `hinter->glyph' too!    */
        if ( edge_distance_threshold == 32000 )
          edge_distance_threshold = 50;
d130 6
a135 2
        /* let's try 20% */
        axis->edge_distance_threshold = edge_distance_threshold / 5;
a138 1
  Exit:
d147 1
a147 1
  static  const char* const  af_latin_blue_chars[ AF_LATIN_MAX_BLUES ] =
d162 2
a163 2
    FT_Pos        flats [ AF_LATIN_MAX_TEST_CHARACTERS ];
    FT_Pos        rounds[ AF_LATIN_MAX_TEST_CHARACTERS ];
d169 1
a169 1
    AF_LatinAxis  axis  = &metrics->axis[ AF_DIMENSION_VERT ];
d172 1
d187 1
d314 5
a318 4
       /* we couldn't find a single glyph to compute this blue zone,
        * we will simply ignore it then
        */
        AF_LOG(( "empty !!\n" ));
d328 1
a328 1
      blue       = & axis->blues[ axis->blue_count ];
d332 1
a332 1
      axis->blue_count ++;
d336 1
a336 1
        *blue_ref    =
d365 1
a365 1
      if ( AF_LATIN_IS_TOP_BLUE(bb) )
d368 8
d387 12
a398 2
    FT_Error      error;
    FT_CharMap    oldmap = face->charmap;
a399 3
    /* do we have a Unicode charmap in there? */
    error = FT_Select_Charmap( face, FT_ENCODING_UNICODE );
    if ( error ) goto Exit;
d403 14
a416 2
    af_latin_metrics_init_widths( metrics, face );
    af_latin_metrics_init_blues( metrics, face );
a417 1
  Exit:
d419 1
a419 1
    return error;
d424 3
a426 3
  af_latin_metrics_scale_dim( AF_LatinMetrics   metrics,
                              AF_Scaler         scaler,
                              AF_Dimension      dim )
d433 1
d445 1
a445 1
    axis = & metrics->axis[ dim ];
d453 39
a491 2
   /* XXX: TODO: Correct Y and X scale according to Chester rules
    */
d506 1
a506 2
   /* scale the standard widths
    */
d511 1
d518 1
a518 2
     /* scale the blue zones
      */
d521 1
a521 1
        AF_LatinBlue  blue  = & axis->blues[nn];
a523 2
        blue->ref.cur = FT_MulFix( blue->ref.org, scale ) + delta;
        blue->ref.fit = blue->ref.cur;
d525 2
d529 1
d531 1
a531 2
       /* a blue zone is only active when it is less than 3/4 pixels tall
        */
d533 27
a559 2
        if ( dist >= 48 || dist <= -48 )
          blue->flags |= ~AF_LATIN_BLUE_ACTIVE;
d569 3
d577 7
a583 7
 /***************************************************************************/
 /***************************************************************************/
 /*****                                                                 *****/
 /*****            L A T I N   G L Y P H   A N A L Y S I S              *****/
 /*****                                                                 *****/
 /***************************************************************************/
 /***************************************************************************/
d585 1
a585 1
  FT_LOCAL_DEF( void )
d589 6
a594 6
    AF_AxisHints  axis = &hints->axis[dim];
    AF_Segment    segments = axis->segments;
    AF_Segment    segment       =  segments;
    FT_Int        num_segments  =  0;
    AF_Point*     contour       =  hints->contours;
    AF_Point*     contour_limit =  contour + hints->num_contours;
d598 4
a601 4
    AF_Point    min_point     =  0;
    AF_Point    max_point     =  0;
    FT_Pos      min_coord     =  32000;
    FT_Pos      max_coord     = -32000;
d604 1
a604 1
    major_dir   = FT_ABS( axis->major_dir );
d607 2
d615 1
d627 1
a634 1

d701 1
a701 1
            segment->pos  = ( min_pos + max_pos ) >> 1;
d718 2
a719 2
            segment->min_coord = min_pos;
            segment->max_coord = max_pos;
d722 1
a722 2
            num_segments++;
            segment++;
d738 1
a738 1
          segment_dir = point->out_dir;
d741 3
a743 1
          FT_ZERO( segment );
d745 1
a745 1
          segment->dir      = segment_dir;
d752 1
d774 1
d809 3
a811 1
        FT_ZERO( segment );
d819 1
d822 1
a822 2
        num_segments++;
        segment++;
d829 3
a831 1
        FT_ZERO( segment );
d839 1
d842 1
a842 2
        num_segments++;
        segment++;
d847 2
a848 1
    axis->num_segments = num_segments;
d860 1
d863 7
d902 1
a902 1
            if ( len >= 8 )
d904 1
a904 1
              score = dist + 3000 / len;
d940 1
a940 1
  FT_LOCAL_DEF( void )
d944 4
a947 3
    AF_AxisHints  axis = &hints->axis[dim];
    AF_Edge       edges = axis->edges;
    AF_Edge       edge, edge_limit;
d949 1
a949 1
    AF_Segment    segments = axis->segments;
d958 2
d982 1
a982 1
    edge_distance_threshold = FT_MulFix( hints->edge_distance_threshold,
a989 1
    edge_limit = edges;
d993 1
d997 1
a997 1
      for ( edge = edges; edge < edge_limit; edge++ )
d999 2
a1000 1
        FT_Pos  dist;
d1016 3
d1021 3
a1023 6
        while ( edge > edges && edge[-1].fpos > seg->pos )
        {
          edge[0] = edge[-1];
          edge--;
        }
        edge_limit++;
d1025 1
a1025 1
        /* clear all edge fields */
a1027 1
        /* add the segment to the new edge's list */
d1038 3
a1040 3
        seg->edge_next        = edge->first;
        edge->last->edge_next = seg;
        edge->last            = seg;
a1042 1
    axis->num_edges = (FT_Int)( edge_limit - edges );
d1060 4
a1063 4
    /* Note that I've tried to remove this loop, setting
     * the "edge" field of each segment directly in the
     * code above.  For some reason, it slows down execution
     * speed -- on a Sun.
a1064 1
    for ( edge = edges; edge < edge_limit; edge++ )
d1066 3
a1068 9
      seg = edge->first;
      if ( seg )
        do
        {
          seg->edge = edge;
          seg       = seg->edge_next;
        }
        while ( seg != edge->first );
    }
a1069 7
    /* now, compute each edge properties */
    for ( edge = edges; edge < edge_limit; edge++ )
    {
      FT_Int  is_round    = 0;  /* does it contain round segments?    */
      FT_Int  is_straight = 0;  /* does it contain straight segments? */
      FT_Pos  ups         = 0;  /* number of upwards segments         */
      FT_Pos  downs       = 0;  /* number of downwards segments       */
d1071 8
d1080 2
a1081 1
      seg = edge->first;
d1083 2
a1084 1
      do
d1086 4
a1089 1
        FT_Bool  is_serif;
d1092 1
a1092 5
        /* check for roundness of segment */
        if ( seg->flags & AF_EDGE_ROUND )
          is_round++;
        else
          is_straight++;
d1094 3
a1096 5
        /* check for segment direction */
        if ( seg->dir == up_dir )
          ups   += seg->max_coord-seg->min_coord;
        else
          downs += seg->max_coord-seg->min_coord;
a1097 3
        /* check for links -- if seg->serif is set, then seg->link must */
        /* be ignored                                                   */
        is_serif = (FT_Bool)( seg->serif && seg->serif->edge != edge );
d1099 5
a1103 4
        if ( seg->link || is_serif )
        {
          AF_Edge     edge2;
          AF_Segment  seg2;
d1105 5
d1111 3
a1113 2
          edge2 = edge->link;
          seg2  = seg->link;
d1115 1
a1115 1
          if ( is_serif )
d1117 12
a1128 3
            seg2  = seg->serif;
            edge2 = edge->serif;
          }
d1130 4
a1133 4
          if ( edge2 )
          {
            FT_Pos  edge_delta;
            FT_Pos  seg_delta;
d1136 3
a1138 3
            edge_delta = edge->fpos - edge2->fpos;
            if ( edge_delta < 0 )
              edge_delta = -edge_delta;
d1140 3
a1142 3
            seg_delta = seg->pos - seg2->pos;
            if ( seg_delta < 0 )
              seg_delta = -seg_delta;
d1144 4
a1147 1
            if ( seg_delta < edge_delta )
a1148 3
          }
          else
            edge2 = seg2->edge;
d1150 7
a1156 4
          if ( is_serif )
          {
            edge->serif   = edge2;
            edge2->flags |= AF_EDGE_SERIF;
a1157 3
          else
            edge->link  = edge2;
        }
d1159 1
a1159 1
        seg = seg->edge_next;
d1161 1
a1161 1
      } while ( seg != edge->first );
d1163 2
a1164 2
      /* set the round/straight flags */
      edge->flags = AF_EDGE_NORMAL;
d1166 2
a1167 2
      if ( is_round > 0 && is_round >= is_straight )
        edge->flags |= AF_EDGE_ROUND;
d1169 2
a1170 2
      /* set the edge's main direction */
      edge->dir = AF_DIR_NONE;
d1172 2
a1173 2
      if ( ups > downs )
        edge->dir = up_dir;
d1175 2
a1176 2
      else if ( ups < downs )
        edge->dir = -up_dir;
d1178 2
a1179 2
      else if ( ups == downs )
        edge->dir = AF_DIR_BOTH;  /* both up and down! */
d1181 3
a1183 3
      /* gets rid of serifs if link is set                */
      /* XXX: This gets rid of many unpleasant artefacts! */
      /*      Example: the `c' in cour.pfa at size 13     */
d1185 3
a1187 2
      if ( edge->serif && edge->link )
        edge->serif = 0;
d1189 3
d1195 1
a1195 1
  FT_LOCAL_DEF( void )
d1199 11
a1209 3
    af_latin_hints_compute_segments( hints, dim );
    af_latin_hints_link_segments   ( hints, dim );
    af_latin_hints_compute_edges   ( hints, dim );
d1227 1
a1227 1
   /* for each horizontal edge search the blue zone which is closest */
d1230 3
a1232 3
      FT_Int     bb;
      AF_Width   best_blue = NULL;
      FT_Pos     best_dist;  /* initial threshold */
d1246 3
a1248 3
       /* skip inactive blue zones (i.e. those that are too small
        */
        if ( !(blue->flags & AF_LATIN_BLUE_ACTIVE) )
d1255 1
a1255 1
        is_top_blue  = (blue->flags & AF_LATIN_BLUE_TOP) != 0;
d1263 1
a1263 1
          FT_Pos   dist;
a1311 1
                       FT_Outline*      outline,
a1313 1
    FT_Error        error;
d1315 2
a1317 5
    error = af_glyph_hints_reset( hints, &metrics->root.scaler,
                                  (AF_ScriptMetrics) metrics,
                                  outline );
    if (error)
      goto Exit;
d1319 1
d1321 8
a1328 2
   /* compute flags depending on render mode, etc...
    */
d1330 1
d1333 14
a1346 3
   /* we snap the width of vertical stems for the monochrome and
    * horizontal LCD rendering targets only.
    */
d1348 1
a1348 1
      hints->other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
d1350 4
a1353 3
   /* we snap the width of horizontal stems for the monochrome and
    * vertical LCD rendering targets only.
    */
d1355 1
a1355 1
      hints->other_flags |= AF_LATIN_HINTS_VERT_SNAP;
d1357 3
a1359 2
   /* XXX
    */
d1361 1
a1361 1
      hints->other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
d1364 1
a1364 1
      hints->other_flags |= AF_LATIN_HINTS_MONO;
d1366 7
a1372 4
   /* analyze glyph outline
    */
    if ( AF_HINTS_DO_HORIZONTAL(hints) )
      af_latin_hints_detect_features( hints, AF_DIMENSION_HORZ );
d1374 2
a1375 5
    if ( AF_HINTS_DO_VERTICAL(hints) )
    {
      af_latin_hints_detect_features( hints, AF_DIMENSION_VERT );
      af_latin_hints_compute_blue_edges( hints, metrics );
    }
d1377 1
a1377 2
 Exit:
   return error;
d1380 8
a1387 7
 /***************************************************************************/
 /***************************************************************************/
 /*****                                                                 *****/
 /*****         L A T I N   G L Y P H   G R I D - F I T T I N G         *****/
 /*****                                                                 *****/
 /***************************************************************************/
 /***************************************************************************/
d1391 1
d1447 1
a1447 1
    AF_LatinAxis     axis     = & metrics->axis[ dim ];
d1450 1
a1450 1
    FT_Int           vertical = AF_HINTS_DO_VERTICAL( hints );
a1465 1
      /*                                                              */
d1484 2
a1485 2
       /* compare to standard width
        */
d1495 1
a1495 1
            dist = axis->widths[ 0 ].cur;
d1527 1
a1527 1
      /*                                                               */
d1534 1
d1546 1
d1557 1
d1578 1
a1579 1
  /* align one stem edge relative to the previous stem edge */
d1588 5
a1592 5
    FT_Pos  fitted_width = af_latin_compute_stem_width( hints,
                                                        dim,
                                                        dist,
                                                        base_edge->flags,
                                                        stem_edge->flags );
d1608 1
d1613 1
a1613 1
  /****       E D G E   H I N T I N G                                   ****/
d1621 2
a1622 2
  af_latin_hint_edges( AF_GlyphHints   hints,
                       AF_Dimension    dim )
d1624 2
a1625 2
    AF_AxisHints  axis = & hints->axis[dim];
    AF_Edge       edges = axis->edges;
d1629 1
a1629 1
    AF_Edge       anchor = 0;
d1635 1
d1714 4
a1717 2
        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
                                               edge->flags, edge2->flags );
d1768 4
a1771 2
        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
                                               edge->flags, edge2->flags  );
d1810 4
a1813 2
          cur_len    = af_latin_compute_stem_width( hints, dim, org_len,
                                                    edge->flags, edge2->flags );
d1816 1
a1816 1
          delta1     = ( cur_pos1 + ( cur_len >> 1 ) - org_center );
d1821 1
a1821 1
          delta2     = ( cur_pos2 + ( cur_len >> 1 ) - org_center );
d1840 1
a1840 1
    /* serif, or twelve if they are avec serif.  This implementation is   */
d1901 4
a1904 3
     /* now hint the remaining edges (serifs and single) in order
      * to complete our processing
      */
d1940 21
a1960 1
    AF_Dimension  dim;
d1962 2
a1963 1
    FT_UNUSED( metrics );
d1965 2
a1966 1
    for ( dim = AF_DIMENSION_HORZ; dim < AF_DIMENSION_MAX; dim++ )
d1968 2
a1969 2
      if ( (dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL(hints)) ||
           (dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL(hints))   )
d1971 18
a1988 4
        af_latin_hint_edges( hints, dim );
        af_glyph_hints_align_edge_points( hints, dim );
        af_glyph_hints_align_strong_points( hints, dim );
        af_glyph_hints_align_weak_points( hints, dim );
d1993 2
a1994 1
    return 0;
d1997 9
a2005 7
 /***************************************************************************/
 /***************************************************************************/
 /*****                                                                 *****/
 /*****      L A T I N   S C R I P T   C L A S S                        *****/
 /*****                                                                 *****/
 /***************************************************************************/
 /***************************************************************************/
d2009 1
a2009 1
    { 32, 127 },    /* XXX: TODO: Add new Unicode ranges here !! */
d2011 1
a2011 1
    { 0, 0 }
d2014 3
a2016 1
  FT_LOCAL_DEF( const AF_ScriptClassRec )  af_latin_script_class =
a2021 3
    (AF_Script_InitMetricsFunc)  af_latin_metrics_init,
    (AF_Script_ScaleMetricsFunc) af_latin_metrics_scale,
    (AF_Script_DoneMetricsFunc)  NULL,
d2023 6
a2028 2
    (AF_Script_InitHintsFunc)    af_latin_hints_init,
    (AF_Script_ApplyHintsFunc)   af_latin_hints_apply
d2031 2
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d1 1
a1 17
/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin script (body).                */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

a3 1
#include "aferrors.h"
d5 7
d13 1
a13 14
#ifdef AF_USE_WARPER
#include "afwarp.h"
#endif


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL_DEF( void )
d15 1
a15 2
                                FT_Face          face,
                                FT_ULong         charcode )
a19 1

d22 2
a23 2
    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
    metrics->axis[AF_DIMENSION_VERT].width_count = 0;
d25 1
d27 4
a30 5
      FT_Error             error;
      FT_UInt              glyph_index;
      int                  dim;
      AF_LatinMetricsRec   dummy[1];
      AF_Scaler            scaler = &dummy->root.scaler;
d33 1
a33 1
      glyph_index = FT_Get_Char_Index( face, charcode );
a40 3
      FT_ZERO( dummy );

      dummy->units_per_em = metrics->units_per_em;
d47 3
a49 3
      af_glyph_hints_rescale( hints, (AF_ScriptMetrics)dummy );

      error = af_glyph_hints_reload( hints, &face->glyph->outline, 0 );
d53 1
a53 1
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
d55 2
a56 2
        AF_LatinAxis  axis    = &metrics->axis[dim];
        AF_AxisHints  axhints = &hints->axis[dim];
d59 1
d61 2
a62 8

        error = af_latin_hints_compute_segments( hints,
                                                 (AF_Dimension)dim );
        if ( error )
          goto Exit;

        af_latin_hints_link_segments( hints,
                                      (AF_Dimension)dim );
a69 1

a86 7
      }

  Exit:
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis  axis = &metrics->axis[dim];
        FT_Pos        stdw;
d88 8
d97 2
a98 8
        stdw = ( axis->width_count > 0 )
                 ? axis->widths[0].org
                 : AF_LATIN_CONSTANT( metrics, 50 );

        /* let's try 20% of the smallest width */
        axis->edge_distance_threshold = stdw / 5;
        axis->standard_width          = stdw;
        axis->extra_light             = 0;
d102 1
d111 1
a111 1
  static const char* const  af_latin_blue_chars[AF_LATIN_MAX_BLUES] =
d126 2
a127 2
    FT_Pos        flats [AF_LATIN_MAX_TEST_CHARACTERS];
    FT_Pos        rounds[AF_LATIN_MAX_TEST_CHARACTERS];
d133 1
a133 1
    AF_LatinAxis  axis  = &metrics->axis[AF_DIMENSION_VERT];
a135 1

a149 1

d158 1
a158 1
        FT_Int      best_point, best_y, best_first, best_last;
d160 2
d178 12
a189 5
        best_point  = -1;
        best_y      = 0;  /* make compiler happy */
        best_first  = 0;  /* ditto */
        best_last   = 0;  /* ditto */

d191 4
a194 3
          FT_Int  nn;
          FT_Int  first = 0;
          FT_Int  last  = -1;
d196 1
d198 8
a205 4
          for ( nn = 0; nn < glyph->outline.n_contours; first = last+1, nn++ )
          {
            FT_Int  old_best_point = best_point;
            FT_Int  pp;
d208 2
a209 1
            last = glyph->outline.contours[nn];
d211 4
a214 7
            /* Avoid single-point contours since they are never rasterized. */
            /* In some fonts, they correspond to mark attachment points     */
            /* which are way outside of the glyph's real outline.           */
            if ( last <= first )
                continue;

            if ( AF_LATIN_IS_TOP_BLUE( bb ) )
d216 2
a217 21
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y > best_y )
                {
                  best_point = pp;
                  best_y     = points[pp].y;
                }
            }
            else
            {
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y < best_y )
                {
                  best_point = pp;
                  best_y     = points[pp].y;
                }
            }

            if ( best_point != old_best_point )
            {
              best_first = first;
              best_last  = last;
d219 1
a220 10
          AF_LOG(( "%5d", best_y ));
        }

        /* now check whether the point belongs to a straight or round   */
        /* segment; we first need to find in which contour the extremum */
        /* lies, then inspect its previous and next points              */
        if ( best_point >= 0 )
        {
          FT_Int  prev, next;
          FT_Pos  dist;
d222 3
d228 2
a229 1
          prev = best_point;
d234 1
a234 1
            if ( prev > best_first )
d237 1
a237 1
              prev = best_last;
d239 1
a239 1
            dist = points[prev].y - best_y;
d243 1
a243 1
          } while ( prev != best_point );
d247 1
a247 1
            if ( next < best_last )
d250 1
a250 1
              next = best_first;
d252 1
a252 1
            dist = points[next].y - best_y;
d256 1
a256 1
          } while ( next != best_point );
d267 1
a267 1
          rounds[num_rounds++] = best_y;
d269 1
a269 1
          flats[num_flats++]   = best_y;
d276 4
a279 5
        /*
         *  we couldn't find a single glyph to compute this blue zone,
         *  we will simply ignore it then
         */
        AF_LOG(( "empty!\n" ));
d289 1
a289 1
      blue       = & axis->blues[axis->blue_count];
d293 1
a293 1
      axis->blue_count++;
d297 1
a297 1
        *blue_ref   =
d326 1
a326 1
      if ( AF_LATIN_IS_TOP_BLUE( bb ) )
a328 8
      /*
       * The following flags is used later to adjust the y and x scales
       * in order to optimize the pixel grid alignment of the top of small
       * letters.
       */
      if ( bb == AF_LATIN_BLUE_SMALL_TOP )
        blue->flags |= AF_LATIN_BLUE_ADJUSTMENT;

d340 2
a341 12
    FT_Error    error = AF_Err_Ok;
    FT_CharMap  oldmap = face->charmap;
    FT_UInt     ee;

    static const FT_Encoding  latin_encodings[] =
    {
      FT_ENCODING_UNICODE,
      FT_ENCODING_APPLE_ROMAN,
      FT_ENCODING_ADOBE_STANDARD,
      FT_ENCODING_ADOBE_LATIN_1,
      FT_ENCODING_NONE  /* end of list */
    };
d343 3
d349 2
a350 14
    /* do we have a latin charmap in there? */
    for ( ee = 0; latin_encodings[ee] != FT_ENCODING_NONE; ee++ )
    {
      error = FT_Select_Charmap( face, latin_encodings[ee] );
      if ( !error )
        break;
    }

    if ( !error )
    {
      /* For now, compute the standard width and height from the `o'. */
      af_latin_metrics_init_widths( metrics, face, 'o' );
      af_latin_metrics_init_blues( metrics, face );
    }
d352 1
d354 1
a354 1
    return AF_Err_Ok;
d359 3
a361 3
  af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
                              AF_Scaler        scaler,
                              AF_Dimension     dim )
a367 1

d379 1
a379 1
    axis = &metrics->axis[dim];
d387 2
a388 42
    /*
     * correct X and Y scale to optimize the alignment of the top of small
     * letters to the pixel grid
     */
    {
      AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
      AF_LatinBlue  blue = NULL;


      for ( nn = 0; nn < Axis->blue_count; nn++ )
      {
        if ( Axis->blues[nn].flags & AF_LATIN_BLUE_ADJUSTMENT )
        {
          blue = &Axis->blues[nn];
          break;
        }
      }

      if ( blue )
      {
        FT_Pos  scaled = FT_MulFix( blue->shoot.org, scaler->y_scale );
        FT_Pos  fitted = ( scaled + 40 ) & ~63;


        if ( scaled != fitted )
        {
#if 0
          if ( dim == AF_DIMENSION_HORZ )
          {
            if ( fitted < scaled )
              scale -= scale / 50;  /* scale *= 0.98 */
          }
          else
#endif
          if ( dim == AF_DIMENSION_VERT )
          {
            scale = FT_MulDiv( scale, fitted, scaled );
          }
        }
      }
    }

d403 2
a404 1
    /* scale the standard widths */
a408 1

a412 5
    /* an extra-light axis corresponds to a standard width that is */
    /* smaller than 0.75 pixels                                    */
    axis->extra_light =
      (FT_Bool)( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );

d415 2
a416 1
      /* scale the blue zones */
d419 1
a419 1
        AF_LatinBlue  blue = &axis->blues[nn];
d422 2
a424 2
        blue->ref.cur   = FT_MulFix( blue->ref.org, scale ) + delta;
        blue->ref.fit   = blue->ref.cur;
a426 1
        blue->flags    &= ~AF_LATIN_BLUE_ACTIVE;
d428 2
a429 1
        /* a blue zone is only active if it is less than 3/4 pixels tall */
d431 2
a432 27
        if ( dist <= 48 && dist >= -48 )
        {
          FT_Pos  delta1, delta2;


          delta1 = blue->shoot.org - blue->ref.org;
          delta2 = delta1;
          if ( delta1 < 0 )
            delta2 = -delta2;

          delta2 = FT_MulFix( delta2, scale );

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 64 )
            delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) & ~31 );
          else
            delta2 = FT_PIX_ROUND( delta2 );

          if ( delta1 < 0 )
            delta2 = -delta2;

          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
          blue->shoot.fit = blue->ref.fit + delta2;

          blue->flags |= AF_LATIN_BLUE_ACTIVE;
        }
a441 3
    metrics->root.scaler.render_mode = scaler->render_mode;
    metrics->root.scaler.face        = scaler->face;

d447 7
a453 7
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
d455 1
a455 1
  FT_LOCAL_DEF( FT_Error )
d459 6
a464 7
    AF_AxisHints  axis          = &hints->axis[dim];
    FT_Memory     memory        = hints->memory;
    FT_Error      error         = AF_Err_Ok;
    AF_Segment    segment       = NULL;
    AF_SegmentRec seg0;
    AF_Point*     contour       = hints->contours;
    AF_Point*     contour_limit = contour + hints->num_contours;
d467 6
d474 1
a474 5
    FT_ZERO( &seg0 );
    seg0.score = 32000;
    seg0.flags = AF_EDGE_NORMAL;

    major_dir   = (AF_Direction)FT_ABS( axis->major_dir );
a476 2
    axis->num_segments = 0;

a482 1

a493 1

d501 1
d513 13
d568 1
a568 1
            segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
d585 2
a586 4
            segment->min_coord = (FT_Short)min_pos;
            segment->max_coord = (FT_Short)max_pos;
            segment->height    = (FT_Short)( segment->max_coord -
                                             segment->min_coord );
d589 2
a590 1
            segment = NULL;
d606 1
a606 1
          segment_dir = (AF_Direction)point->out_dir;
d609 1
a609 3
          error = af_axis_hints_new_segment( axis, memory, &segment );
          if ( error )
            goto Exit;
d611 2
a612 2
          segment[0]        = seg0;
          segment->dir      = (FT_Char)segment_dir;
d617 2
d620 8
d635 11
a646 5
    /* now slightly increase the height of segments when this makes */
    /* sense -- this is used to better detect and ignore serifs     */
    {
      AF_Segment  segments     = axis->segments;
      AF_Segment  segments_end = segments + axis->num_segments;
d648 2
d651 2
a652 1
      for ( segment = segments; segment < segments_end; segment++ )
d654 1
a654 4
        AF_Point  first   = segment->first;
        AF_Point  last    = segment->last;
        FT_Pos    first_v = first->v;
        FT_Pos    last_v  = last->v;
d657 11
a667 2
        if ( first == last )
          continue;
d669 5
a673 3
        if ( first_v < last_v )
        {
          AF_Point  p;
d675 7
d683 3
a685 4
          p = first->prev;
          if ( p->v < first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( first_v - p->v ) >> 1 ) );
d687 5
a691 8
          p = last->next;
          if ( p->v > last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - last_v ) >> 1 ) );
        }
        else
        {
          AF_Point  p;
d693 7
d701 2
a702 10
          p = first->prev;
          if ( p->v > first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - first_v ) >> 1 ) );

          p = last->next;
          if ( p->v < last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( last_v - p->v ) >> 1 ) );
        }
d705 1
d707 1
a707 2
  Exit:
    return error;
d718 1
a718 1
    FT_Pos        len_threshold, len_score;
a720 7

    len_threshold = AF_LATIN_CONSTANT( hints->metrics, 8 );
    if ( len_threshold == 0 )
      len_threshold = 1;

    len_score = AF_LATIN_CONSTANT( hints->metrics, 6000 );

d726 1
a726 1
      if ( seg1->dir != axis->major_dir || seg1->first == seg1->last )
d730 1
a730 1
        if ( seg1->dir + seg2->dir == 0 && seg2->pos > seg1->pos )
d738 1
a738 1
            dist = -dist;
d753 1
a753 1
            if ( len >= len_threshold )
d755 1
a755 1
              score = dist + len_score / len;
d780 1
d791 1
a791 1
  FT_LOCAL_DEF( FT_Error )
d795 3
a797 4
    AF_AxisHints  axis   = &hints->axis[dim];
    FT_Error      error  = AF_Err_Ok;
    FT_Memory     memory = hints->memory;
    AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];
d799 1
a799 1
    AF_Segment    segments      = axis->segments;
a805 2
    FT_Pos        segment_length_threshold;

a806 1
    axis->num_edges = 0;
a813 10
    /*
     *  We ignore all segments that are less than 1 pixels in length,
     *  to avoid many problems with serif fonts.  We compute the
     *  corresponding threshold in font units.
     */
    if ( dim == AF_DIMENSION_HORZ )
        segment_length_threshold = FT_DivFix( 64, hints->y_scale );
    else
        segment_length_threshold = 0;

d830 1
a830 1
    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
d838 1
a841 2
      FT_Int   ee;

a842 8
      if ( seg->height < segment_length_threshold )
        continue;

      /* A special case for serif edges: If they are smaller than */
      /* 1.5 pixels we ignore them.                               */
      if ( seg->serif                                     &&
           2 * seg->height < 3 * segment_length_threshold )
        continue;
d845 1
a845 1
      for ( ee = 0; ee < axis->num_edges; ee++ )
d847 1
a847 2
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;
d854 1
a854 1
        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
a862 3
        AF_Edge   edge;


d865 6
a870 3
        error = af_axis_hints_new_edge( axis, seg->pos, seg->dir, memory, &edge );
        if ( error )
          goto Exit;
d872 1
a872 1
        /* add the segment to the new edge's list */
d875 1
a878 1
        edge->dir      = seg->dir;
d886 3
a888 3
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
d891 1
d909 4
a912 4
    /*
     * Note that removing this loop and setting the `edge' field of each
     * segment directly in the code above slows down execution speed for
     * some reasons on platforms like the Sun.
d914 1
d916 9
a924 3
      AF_Edge  edges      = axis->edges;
      AF_Edge  edge_limit = edges + axis->num_edges;
      AF_Edge  edge;
d926 7
a933 8
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg       = seg->edge_next;
d935 1
a935 2
          } while ( seg != edge->first );
      }
d937 1
a937 2
      /* now, compute each edge properties */
      for ( edge = edges; edge < edge_limit; edge++ )
d939 1
a939 4
        FT_Int  is_round    = 0;  /* does it contain round segments?    */
        FT_Int  is_straight = 0;  /* does it contain straight segments? */
        FT_Pos  ups         = 0;  /* number of upwards segments         */
        FT_Pos  downs       = 0;  /* number of downwards segments       */
d942 5
a946 1
        seg = edge->first;
d948 5
a952 3
        do
        {
          FT_Bool  is_serif;
d954 3
d958 4
a961 5
          /* check for roundness of segment */
          if ( seg->flags & AF_EDGE_ROUND )
            is_round++;
          else
            is_straight++;
a962 5
          /* check for segment direction */
          if ( seg->dir == up_dir )
            ups   += seg->max_coord-seg->min_coord;
          else
            downs += seg->max_coord-seg->min_coord;
d964 2
a965 5
          /* check for links -- if seg->serif is set, then seg->link must */
          /* be ignored                                                   */
          is_serif = (FT_Bool)( seg->serif               &&
                                seg->serif->edge         &&
                                seg->serif->edge != edge );
d967 1
a967 1
          if ( ( seg->link && seg->link->edge != NULL ) || is_serif )
d969 3
a971 2
            AF_Edge     edge2;
            AF_Segment  seg2;
d973 4
a977 13
            edge2 = edge->link;
            seg2  = seg->link;

            if ( is_serif )
            {
              seg2  = seg->serif;
              edge2 = edge->serif;
            }

            if ( edge2 )
            {
              FT_Pos  edge_delta;
              FT_Pos  seg_delta;
d979 3
d983 3
a985 3
              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;
d987 1
a987 8
              seg_delta = seg->pos - seg2->pos;
              if ( seg_delta < 0 )
                seg_delta = -seg_delta;

              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
d989 3
d993 4
a996 7
            if ( is_serif )
            {
              edge->serif   = edge2;
              edge2->flags |= AF_EDGE_SERIF;
            }
            else
              edge->link  = edge2;
d998 3
d1002 1
a1002 1
          seg = seg->edge_next;
d1004 1
a1004 1
        } while ( seg != edge->first );
d1006 2
a1007 2
        /* set the round/straight flags */
        edge->flags = AF_EDGE_NORMAL;
d1009 2
a1010 2
        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= AF_EDGE_ROUND;
d1012 2
a1013 3
#if 0
        /* set the edge's main direction */
        edge->dir = AF_DIR_NONE;
d1015 2
a1016 2
        if ( ups > downs )
          edge->dir = (FT_Char)up_dir;
d1018 2
a1019 2
        else if ( ups < downs )
          edge->dir = (FT_Char)-up_dir;
d1021 2
a1022 3
        else if ( ups == downs )
          edge->dir = 0;  /* both up and down! */
#endif
d1024 3
a1026 3
        /* gets rid of serifs if link is set                */
        /* XXX: This gets rid of many unpleasant artefacts! */
        /*      Example: the `c' in cour.pfa at size 13     */
d1028 2
a1029 3
        if ( edge->serif && edge->link )
          edge->serif = 0;
      }
a1030 3

  Exit:
    return error;
d1034 1
a1034 1
  FT_LOCAL_DEF( FT_Error )
d1038 3
a1040 11
    FT_Error  error;


    error = af_latin_hints_compute_segments( hints, dim );
    if ( !error )
    {
      af_latin_hints_link_segments( hints, dim );

      error = af_latin_hints_compute_edges( hints, dim );
    }
    return error;
d1058 1
a1058 1
    /* for each horizontal edge search the blue zone which is closest */
d1061 3
a1063 3
      FT_Int    bb;
      AF_Width  best_blue = NULL;
      FT_Pos    best_dist;  /* initial threshold */
d1077 3
a1079 3

        /* skip inactive blue zones (i.e., those that are too small) */
        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
d1086 1
a1086 1
        is_top_blue  = (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_TOP ) != 0 );
d1094 1
a1094 1
          FT_Pos  dist;
d1143 1
d1146 1
a1147 2
    FT_UInt32       scaler_flags, other_flags;
    FT_Face         face = metrics->root.scaler.face;
d1149 5
a1154 1
    af_glyph_hints_rescale( hints, (AF_ScriptMetrics)metrics );
d1156 2
a1157 8
    /*
     *  correct x_scale and y_scale if needed, since they may have
     *  been modified `af_latin_metrics_scale_dim' above
     */
    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;
a1158 1
    /* compute flags depending on render mode, etc. */
d1161 3
a1163 14
#if 0 /* #ifdef AF_USE_WARPER */
    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
    {
      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
    }
#endif

    scaler_flags = hints->scaler_flags;
    other_flags  = 0;

    /*
     *  We snap the width of vertical stems for the monochrome and
     *  horizontal LCD rendering targets only.
     */
d1165 1
a1165 1
      other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
d1167 3
a1169 4
    /*
     *  We snap the width of horizontal stems for the monochrome and
     *  vertical LCD rendering targets only.
     */
d1171 1
a1171 1
      other_flags |= AF_LATIN_HINTS_VERT_SNAP;
d1173 2
a1174 3
    /*
     *  We adjust stems to full pixels only if we don't use the `light' mode.
     */
d1176 1
a1176 1
      other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
d1179 1
a1179 1
      other_flags |= AF_LATIN_HINTS_MONO;
d1181 4
a1184 7
    /*
     *  In `light' hinting mode we disable horizontal hinting completely.
     *  We also do it if the face is italic.
     */
    if ( mode == FT_RENDER_MODE_LIGHT                    ||
         (face->style_flags & FT_STYLE_FLAG_ITALIC) != 0 )
      scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
d1186 5
a1190 2
    hints->scaler_flags = scaler_flags;
    hints->other_flags  = other_flags;
d1192 2
a1193 1
    return 0;
d1196 7
a1202 8

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
a1205 1

d1261 1
a1261 1
    AF_LatinAxis     axis     = & metrics->axis[dim];
d1264 1
a1264 1
    FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
d1267 1
a1267 2
    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
          axis->extra_light                      )
d1280 1
d1299 2
a1300 2

        /* compare to standard width */
d1310 1
a1310 1
            dist = axis->widths[0].cur;
d1342 1
a1342 3
      FT_Pos  org_dist = dist;


a1348 1

a1359 1

a1369 1

a1373 10
          {
            /* We only round to an integer width if the corresponding */
            /* distortion is less than 1/4 pixel.  Otherwise this     */
            /* makes everything worse since the diagonals, which are  */
            /* not hinted, appear a lot bolder or thinner than the    */
            /* vertical stems.                                        */

            FT_Int  delta;


a1374 11
            delta = dist - org_dist;
            if ( delta < 0 )
              delta = -delta;

            if (delta >= 16)
            {
              dist = org_dist;
              if ( dist < 48 )
                dist = ( dist + 64 ) >> 1;
            }
          }
d1390 1
a1391 1

d1400 5
a1404 5
    FT_Pos  fitted_width = af_latin_compute_stem_width(
                             hints, dim, dist,
                             (AF_Edge_Flags)base_edge->flags,
                             (AF_Edge_Flags)stem_edge->flags );

a1406 5

    AF_LOG(( "LINK: edge %d (opos=%.2f) linked to (%.2f), "
             "dist was %.2f, now %.2f\n",
             stem_edge-hints->axis[dim].edges, stem_edge->opos / 64.0,
             stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
a1419 1

d1424 1
a1424 1
  /****                    E D G E   H I N T I N G                      ****/
d1432 2
a1433 2
  af_latin_hint_edges( AF_GlyphHints  hints,
                       AF_Dimension   dim )
d1435 2
a1436 2
    AF_AxisHints  axis       = &hints->axis[dim];
    AF_Edge       edges      = axis->edges;
d1440 1
a1440 1
    AF_Edge       anchor     = 0;
d1446 1
a1446 2

    if ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_BLUES( hints ) )
a1474 5
        AF_LOG(( "BLUE: edge %d (opos=%.2f) snapped to (%.2f), "
                 "was (%.2f)\n",
                 edge1-edges, edge1->opos / 64.0, blue->fit / 64.0,
                 edge1->pos / 64.0 ));

d1510 1
a1510 1
      if ( edge2->blue_edge )
a1511 2
        AF_LOG(( "ASSERTION FAILED for edge %d\n", edge2-edges ));

d1524 2
a1525 4
        cur_len = af_latin_compute_stem_width(
                    hints, dim, org_len,
                    (AF_Edge_Flags)edge->flags,
                    (AF_Edge_Flags)edge2->flags );
d1554 2
a1555 1
          edge2->pos = edge->pos + cur_len;
a1559 5
        AF_LOG(( "ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f) "
                 "snapped to (%.2f) (%.2f)\n",
                 edge-edges, edge->opos / 64.0,
                 edge2-edges, edge2->opos / 64.0,
                 edge->pos / 64.0, edge2->pos / 64.0 ));
d1576 2
a1577 4
        cur_len = af_latin_compute_stem_width(
                   hints, dim, org_len,
                   (AF_Edge_Flags)edge->flags,
                   (AF_Edge_Flags)edge2->flags );
d1579 1
a1579 4
        if ( edge2->flags & AF_EDGE_DONE )
          edge->pos = edge2->pos - cur_len;

        else if ( cur_len < 96 )
a1608 6

          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
d1616 2
a1617 4
          cur_len    = af_latin_compute_stem_width(
                         hints, dim, org_len,
                         (AF_Edge_Flags)edge->flags,
                         (AF_Edge_Flags)edge2->flags );
d1620 1
a1620 1
          delta1     = cur_pos1 + ( cur_len >> 1 ) - org_center;
d1625 1
a1625 1
          delta2     = cur_pos2 + ( cur_len >> 1 ) - org_center;
a1630 6

          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
a1636 3
        {
          AF_LOG(( "BOUND: %d (pos=%.2f) to (%.2f)\n",
                   edge-edges, edge->pos / 64.0, edge[-1].pos / 64.0 ));
a1637 1
        }
d1644 1
a1644 1
    /* serif, or twelve if they are with serifs.  This implementation is  */
d1705 3
a1707 4
      /*
       *  now hint the remaining edges (serifs and single) in order
       *  to complete our processing
       */
a1709 3
        FT_Pos  delta;


a1712 2
        delta = 1000;

a1713 8
        {
          delta = edge->serif->opos - edge->opos;
          if ( delta < 0 )
            delta = -delta;
        }

        if ( delta < 64 + 16 )
        {
a1714 6
          AF_LOG(( "SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f) "
                   "aligned to (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge->serif - edges, edge->serif->opos / 64.0,
                   edge->pos / 64.0 ));
        }
a1716 2
          AF_LOG(( "SERIF_ANCHOR: edge %d (opos=%.2f) snapped to (%.2f)\n",
                   edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
d1721 2
a1722 33
        {
          AF_Edge  before, after;


          for ( before = edge - 1; before >= edges; before-- )
            if ( before->flags & AF_EDGE_DONE )
              break;

          for ( after = edge + 1; after < edge_limit; after++ )
            if ( after->flags & AF_EDGE_DONE )
              break;

          if ( before >= edges && before < edge   &&
               after < edge_limit && after > edge )
          {
            edge->pos = before->pos +
                          FT_MulDiv( edge->opos - before->opos,
                                     after->pos - before->pos,
                                     after->opos - before->opos );
            AF_LOG(( "SERIF_LINK1: edge %d (opos=%.2f) snapped to (%.2f) "
                     "from %d (opos=%.2f)\n",
                     edge-edges, edge->opos / 64.0,
                     edge->pos / 64.0, before - edges,
                     before->opos / 64.0 ));
          }
          else
          {
            edge->pos = anchor->pos +
                        ( ( edge->opos - anchor->opos + 16 ) & ~31 );
            AF_LOG(( "SERIF_LINK2: edge %d (opos=%.2f) snapped to (%.2f)\n",
                     edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
          }
        }
d1743 1
a1743 2
    FT_Error  error;
    int       dim;
d1745 1
d1747 1
a1747 28
    error = af_glyph_hints_reload( hints, outline, 1 );
    if ( error )
      goto Exit;

    /* analyze glyph outline */
#ifdef AF_USE_WARPER
    if ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ||
         AF_HINTS_DO_HORIZONTAL( hints ) )
#else
    if ( AF_HINTS_DO_HORIZONTAL( hints ) )
#endif
    {
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_HORZ );
      if ( error )
        goto Exit;
    }

    if ( AF_HINTS_DO_VERTICAL( hints ) )
    {
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_VERT );
      if ( error )
        goto Exit;

      af_latin_hints_compute_blue_edges( hints, metrics );
    }

    /* grid-fit the outline */
    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
d1749 2
a1750 3
#ifdef AF_USE_WARPER
      if ( ( dim == AF_DIMENSION_HORZ &&
             metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ) )
d1752 4
a1755 18
        AF_WarperRec  warper;
        FT_Fixed      scale;
        FT_Pos        delta;


        af_warper_compute( &warper, hints, dim, &scale, &delta );
        af_glyph_hints_scale_dim( hints, dim, scale, delta );
        continue;
      }
#endif

      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
      {
        af_latin_hint_edges( hints, (AF_Dimension)dim );
        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
d1760 1
a1760 2
  Exit:
    return error;
d1763 7
a1769 12

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****              L A T I N   S C R I P T   C L A S S              *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  /* XXX: this should probably fine tuned to differentiate better between */
  /*      scripts...                                                      */
d1773 3
a1775 21
    { 0x0020, 0x007F },  /* Basic Latin (no control characters) */
    { 0x00A0, 0x00FF },  /* Latin-1 Supplement (no control characters) */
    { 0x0100, 0x017F },  /* Latin Extended-A */
    { 0x0180, 0x024F },  /* Latin Extended-B */
    { 0x0250, 0x02AF },  /* IPA Extensions */
    { 0x02B0, 0x02FF },  /* Spacing Modifier Letters */
    { 0x0300, 0x036F },  /* Combining Diacritical Marks */
    { 0x0370, 0x03FF },  /* Greek and Coptic */
    { 0x0400, 0x04FF },  /* Cyrillic */
    { 0x0500, 0x052F },  /* Cyrillic Supplement */
    { 0x1D00, 0x1D7F },  /* Phonetic Extensions */
    { 0x1D80, 0x1DBF },  /* Phonetic Extensions Supplement */
    { 0x1DC0, 0x1DFF },  /* Combining Diacritical Marks Supplement */
    { 0x1E00, 0x1EFF },  /* Latin Extended Additional */
    { 0x1F00, 0x1FFF },  /* Greek Extended */
    { 0x2000, 0x206F },  /* General Punctuation */
    { 0x2070, 0x209F },  /* Superscripts and Subscripts */
    { 0x20A0, 0x20CF },  /* Currency Symbols */
    { 0x2150, 0x218F },  /* Number Forms */
    { 0x2460, 0x24FF },  /* Enclosed Alphanumerics */
    { 0     , 0      }
d1778 1
a1778 3

  FT_CALLBACK_TABLE_DEF const AF_ScriptClassRec
  af_latin_script_class =
d1784 3
d1788 2
a1789 6
    (AF_Script_InitMetricsFunc) af_latin_metrics_init,
    (AF_Script_ScaleMetricsFunc)af_latin_metrics_scale,
    (AF_Script_DoneMetricsFunc) NULL,

    (AF_Script_InitHintsFunc)   af_latin_hints_init,
    (AF_Script_ApplyHintsFunc)  af_latin_hints_apply
a1791 2

/* END */
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d200 1
a200 1
        FT_Bool     round = 0;
d1007 1
a1007 1
        AF_Edge  edge;
d1012 1
a1012 3
        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        memory, &edge );
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d1 2
d44 1
a44 1
      scaler->render_mode = 0;
d53 1
a53 1
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
d1022 1
a1022 1
        edge->dir = 0;  /* both up and down! */
d1747 1
a1747 1
    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@a0 18
/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin script (body).                */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


a1 1
#include "aferrors.h"
d3 7
d11 1
a11 14
#ifdef AF_USE_WARPER
#include "afwarp.h"
#endif


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_LOCAL_DEF( void )
d13 1
a13 2
                                FT_Face          face,
                                FT_ULong         charcode )
a17 1

d20 2
a21 2
    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
    metrics->axis[AF_DIMENSION_VERT].width_count = 0;
d23 1
d25 4
a28 5
      FT_Error             error;
      FT_UInt              glyph_index;
      int                  dim;
      AF_LatinMetricsRec   dummy[1];
      AF_Scaler            scaler = &dummy->root.scaler;
d31 1
a31 1
      glyph_index = FT_Get_Char_Index( face, charcode );
a38 3
      FT_ZERO( dummy );

      dummy->units_per_em = metrics->units_per_em;
d42 1
a42 1
      scaler->render_mode = FT_RENDER_MODE_NORMAL;
d45 3
a47 3
      af_glyph_hints_rescale( hints, (AF_ScriptMetrics)dummy );

      error = af_glyph_hints_reload( hints, &face->glyph->outline );
d53 2
a54 2
        AF_LatinAxis  axis    = &metrics->axis[dim];
        AF_AxisHints  axhints = &hints->axis[dim];
d57 1
d59 2
a60 8

        error = af_latin_hints_compute_segments( hints,
                                                 (AF_Dimension)dim );
        if ( error )
          goto Exit;

        af_latin_hints_link_segments( hints,
                                      (AF_Dimension)dim );
a67 1

a84 7
      }

  Exit:
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis  axis = &metrics->axis[dim];
        FT_Pos        stdw;
d86 8
d95 2
a96 6
        stdw = ( axis->width_count > 0 )
                 ? axis->widths[0].org
                 : AF_LATIN_CONSTANT( metrics, 50 );

        /* let's try 20% of the smallest width */
        axis->edge_distance_threshold = stdw / 5;
d100 1
d109 1
a109 1
  static const char* const  af_latin_blue_chars[AF_LATIN_MAX_BLUES] =
d124 2
a125 2
    FT_Pos        flats [AF_LATIN_MAX_TEST_CHARACTERS];
    FT_Pos        rounds[AF_LATIN_MAX_TEST_CHARACTERS];
d131 1
a131 1
    AF_LatinAxis  axis  = &metrics->axis[AF_DIMENSION_VERT];
a133 1

a147 1

d274 4
a277 5
        /*
         *  we couldn't find a single glyph to compute this blue zone,
         *  we will simply ignore it then
         */
        AF_LOG(( "empty!\n" ));
d287 1
a287 1
      blue       = & axis->blues[axis->blue_count];
d291 1
a291 1
      axis->blue_count++;
d295 1
a295 1
        *blue_ref   =
d324 1
a324 1
      if ( AF_LATIN_IS_TOP_BLUE( bb ) )
a326 8
      /*
       * The following flags is used later to adjust the y and x scales
       * in order to optimize the pixel grid alignment of the top of small
       * letters.
       */
      if ( bb == AF_LATIN_BLUE_SMALL_TOP )
        blue->flags |= AF_LATIN_BLUE_ADJUSTMENT;

d338 2
a339 12
    FT_Error    error = AF_Err_Ok;
    FT_CharMap  oldmap = face->charmap;
    FT_UInt     ee;

    static const FT_Encoding  latin_encodings[] =
    {
      FT_ENCODING_UNICODE,
      FT_ENCODING_APPLE_ROMAN,
      FT_ENCODING_ADOBE_STANDARD,
      FT_ENCODING_ADOBE_LATIN_1,
      FT_ENCODING_NONE  /* end of list */
    };
d341 3
d347 2
a348 14
    /* do we have a latin charmap in there? */
    for ( ee = 0; latin_encodings[ee] != FT_ENCODING_NONE; ee++ )
    {
      error = FT_Select_Charmap( face, latin_encodings[ee] );
      if ( !error )
        break;
    }

    if ( !error )
    {
      /* For now, compute the standard width and height from the `o'. */
      af_latin_metrics_init_widths( metrics, face, 'o' );
      af_latin_metrics_init_blues( metrics, face );
    }
d350 1
d352 1
a352 1
    return AF_Err_Ok;
d357 3
a359 3
  af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
                              AF_Scaler        scaler,
                              AF_Dimension     dim )
a365 1

d377 1
a377 1
    axis = &metrics->axis[dim];
d385 2
a386 39
    /*
     * correct X and Y scale to optimize the alignment of the top of small
     * letters to the pixel grid
     */
    {
      AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
      AF_LatinBlue  blue = NULL;


      for ( nn = 0; nn < Axis->blue_count; nn++ )
      {
        if ( Axis->blues[nn].flags & AF_LATIN_BLUE_ADJUSTMENT )
        {
          blue = &Axis->blues[nn];
          break;
        }
      }

      if ( blue )
      {
        FT_Pos  scaled = FT_MulFix( blue->shoot.org, scaler->y_scale );
        FT_Pos  fitted = FT_PIX_ROUND( scaled );


        if ( scaled != fitted )
        {
          if ( dim == AF_DIMENSION_HORZ )
          {
            if ( fitted < scaled )
              scale -= scale/50;  /* x_scale = x_scale*0.98 */
          }
          else
          {
            scale = FT_MulDiv( scale, fitted, scaled );
          }
        }
      }
    }

d401 2
a402 1
    /* scale the standard widths */
a406 1

d413 2
a414 1
      /* scale the blue zones */
d417 1
a417 1
        AF_LatinBlue  blue = &axis->blues[nn];
d420 2
a422 2
        blue->ref.cur   = FT_MulFix( blue->ref.org, scale ) + delta;
        blue->ref.fit   = blue->ref.cur;
a424 1
        blue->flags    &= ~AF_LATIN_BLUE_ACTIVE;
d426 2
a427 1
        /* a blue zone is only active if it is less than 3/4 pixels tall */
d429 2
a430 27
        if ( dist <= 48 && dist >= -48 )
        {
          FT_Pos  delta1, delta2;


          delta1 = blue->shoot.org - blue->ref.org;
          delta2 = delta1;
          if ( delta1 < 0 )
            delta2 = -delta2;

          delta2 = FT_MulFix( delta2, scale );

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 64 )
            delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) & ~31 );
          else
            delta2 = FT_PIX_ROUND( delta2 );

          if ( delta1 < 0 )
            delta2 = -delta2;

          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
          blue->shoot.fit = blue->ref.fit + delta2;

          blue->flags |= AF_LATIN_BLUE_ACTIVE;
        }
a439 3
    metrics->root.scaler.render_mode = scaler->render_mode;
    metrics->root.scaler.face        = scaler->face;

d445 7
a451 7
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
d453 1
a453 1
  FT_LOCAL_DEF( FT_Error )
d457 6
a462 6
    AF_AxisHints  axis          = &hints->axis[dim];
    FT_Memory     memory        = hints->memory;
    FT_Error      error         = AF_Err_Ok;
    AF_Segment    segment       = NULL;
    AF_Point*     contour       = hints->contours;
    AF_Point*     contour_limit = contour + hints->num_contours;
d466 4
a469 4
    AF_Point  min_point =  0;
    AF_Point  max_point =  0;
    FT_Pos    min_coord =  32000;
    FT_Pos    max_coord = -32000;
d472 1
a472 1
    major_dir   = (AF_Direction)FT_ABS( axis->major_dir );
a474 2
    axis->num_segments = 0;

a480 1

a491 1

d499 1
d566 1
a566 1
            segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
d583 2
a584 2
            segment->min_coord = (FT_Short)min_pos;
            segment->max_coord = (FT_Short)max_pos;
d587 2
a588 1
            segment = NULL;
d604 1
a604 1
          segment_dir = (AF_Direction)point->out_dir;
d607 1
a607 3
          error = af_axis_hints_new_segment( axis, memory, &segment );
          if ( error )
            goto Exit;
d609 1
a609 1
          segment->dir      = (FT_Char)segment_dir;
a615 1
          segment->len      = 0;
a636 1

d671 1
a671 3
        error = af_axis_hints_new_segment( axis, memory, &segment );
        if ( error )
          goto Exit;
a678 1
        segment->len   = 0;
d681 2
a682 1
        segment = NULL;
d689 1
a689 3
        error = af_axis_hints_new_segment( axis, memory, &segment );
        if ( error )
          goto Exit;
a696 1
        segment->len   = 0;
d699 2
a700 1
        segment = NULL;
d705 1
a705 2
  Exit:
    return error;
a716 1
    FT_Pos        len_threshold, len_score;
a718 7

    len_threshold = AF_LATIN_CONSTANT( hints->metrics, 8 );
    if ( len_threshold == 0 )
      len_threshold = 1;

    len_score = AF_LATIN_CONSTANT( hints->metrics, 3000 );

d751 1
a751 1
            if ( len >= len_threshold )
d753 1
a753 1
              score = dist + len_score / len;
d789 1
a789 1
  FT_LOCAL_DEF( FT_Error )
d793 3
a795 4
    AF_AxisHints  axis   = &hints->axis[dim];
    FT_Error      error  = AF_Err_Ok;
    FT_Memory     memory = hints->memory;
    AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];
d797 1
a797 1
    AF_Segment    segments      = axis->segments;
a805 2
    axis->num_edges = 0;

d828 1
a828 1
    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
d836 1
a839 1
      FT_Int   ee;
d843 1
a843 1
      for ( ee = 0; ee < axis->num_edges; ee++ )
d845 1
a845 2
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;
a860 3
        AF_Edge   edge;


d863 6
a868 3
        error = af_axis_hints_new_edge( axis, seg->pos, memory, &edge );
        if ( error )
          goto Exit;
d870 1
a870 1
        /* add the segment to the new edge's list */
d873 1
d884 3
a886 3
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
d889 1
d907 4
a910 4
    /*
     * Note that removing this loop and setting the `edge' field of each
     * segment directly in the code above slows down execution speed for
     * some reasons on platforms like the Sun.
d912 1
d914 9
a922 3
      AF_Edge  edges      = axis->edges;
      AF_Edge  edge_limit = edges + axis->num_edges;
      AF_Edge  edge;
d924 7
a931 8
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg       = seg->edge_next;
d933 1
a933 2
          } while ( seg != edge->first );
      }
d935 1
a935 2
      /* now, compute each edge properties */
      for ( edge = edges; edge < edge_limit; edge++ )
d937 1
a937 4
        FT_Int  is_round    = 0;  /* does it contain round segments?    */
        FT_Int  is_straight = 0;  /* does it contain straight segments? */
        FT_Pos  ups         = 0;  /* number of upwards segments         */
        FT_Pos  downs       = 0;  /* number of downwards segments       */
d940 5
a944 1
        seg = edge->first;
d946 5
a950 3
        do
        {
          FT_Bool  is_serif;
d952 3
d956 4
a959 5
          /* check for roundness of segment */
          if ( seg->flags & AF_EDGE_ROUND )
            is_round++;
          else
            is_straight++;
a960 5
          /* check for segment direction */
          if ( seg->dir == up_dir )
            ups   += seg->max_coord-seg->min_coord;
          else
            downs += seg->max_coord-seg->min_coord;
d962 2
a963 3
          /* check for links -- if seg->serif is set, then seg->link must */
          /* be ignored                                                   */
          is_serif = (FT_Bool)( seg->serif && seg->serif->edge != edge );
d965 1
a965 1
          if ( seg->link || is_serif )
d967 3
a969 2
            AF_Edge     edge2;
            AF_Segment  seg2;
d971 4
a974 14

            edge2 = edge->link;
            seg2  = seg->link;

            if ( is_serif )
            {
              seg2  = seg->serif;
              edge2 = edge->serif;
            }

            if ( edge2 )
            {
              FT_Pos  edge_delta;
              FT_Pos  seg_delta;
d977 3
a979 3
              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;
d981 3
a983 3
              seg_delta = seg->pos - seg2->pos;
              if ( seg_delta < 0 )
                seg_delta = -seg_delta;
d985 1
a985 4
              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
d987 3
d991 4
a994 7
            if ( is_serif )
            {
              edge->serif   = edge2;
              edge2->flags |= AF_EDGE_SERIF;
            }
            else
              edge->link  = edge2;
d996 3
d1000 1
a1000 1
          seg = seg->edge_next;
d1002 1
a1002 1
        } while ( seg != edge->first );
d1004 2
a1005 2
        /* set the round/straight flags */
        edge->flags = AF_EDGE_NORMAL;
d1007 2
a1008 2
        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= AF_EDGE_ROUND;
d1010 2
a1011 2
        /* set the edge's main direction */
        edge->dir = AF_DIR_NONE;
d1013 2
a1014 2
        if ( ups > downs )
          edge->dir = (FT_Char)up_dir;
d1016 2
a1017 2
        else if ( ups < downs )
          edge->dir = (FT_Char)-up_dir;
d1019 2
a1020 2
        else if ( ups == downs )
          edge->dir = 0;  /* both up and down! */
d1022 3
a1024 3
        /* gets rid of serifs if link is set                */
        /* XXX: This gets rid of many unpleasant artefacts! */
        /*      Example: the `c' in cour.pfa at size 13     */
d1026 2
a1027 3
        if ( edge->serif && edge->link )
          edge->serif = 0;
      }
a1028 3

  Exit:
    return error;
d1032 1
a1032 1
  FT_LOCAL_DEF( FT_Error )
d1036 3
a1038 11
    FT_Error  error;


    error = af_latin_hints_compute_segments( hints, dim );
    if ( !error )
    {
      af_latin_hints_link_segments( hints, dim );

      error = af_latin_hints_compute_edges( hints, dim );
    }
    return error;
d1056 1
a1056 1
    /* for each horizontal edge search the blue zone which is closest */
d1059 3
a1061 3
      FT_Int    bb;
      AF_Width  best_blue = NULL;
      FT_Pos    best_dist;  /* initial threshold */
d1075 3
a1077 3

        /* skip inactive blue zones (i.e., those that are too small) */
        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
d1084 1
a1084 1
        is_top_blue  = (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_TOP ) != 0 );
d1092 1
a1092 1
          FT_Pos  dist;
d1141 1
d1144 1
a1145 2
    FT_UInt32       scaler_flags, other_flags;
    FT_Face         face = metrics->root.scaler.face;
d1147 5
a1152 1
    af_glyph_hints_rescale( hints, (AF_ScriptMetrics)metrics );
d1154 2
a1155 8
    /*
     *  correct x_scale and y_scale when needed, since they may have
     *  been modified af_latin_scale_dim above
     */
    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;
a1156 1
    /* compute flags depending on render mode, etc. */
d1159 3
a1161 14
#ifdef AF_USE_WARPER
    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
    {
      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
    }
#endif

    scaler_flags = hints->scaler_flags;
    other_flags  = 0;

    /*
     *  We snap the width of vertical stems for the monochrome and
     *  horizontal LCD rendering targets only.
     */
d1163 1
a1163 1
      other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
d1165 3
a1167 4
    /*
     *  We snap the width of horizontal stems for the monochrome and
     *  vertical LCD rendering targets only.
     */
d1169 1
a1169 1
      other_flags |= AF_LATIN_HINTS_VERT_SNAP;
d1171 2
a1172 3
    /*
     *  We adjust stems to full pixels only if we don't use the `light' mode.
     */
d1174 1
a1174 1
      other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
d1177 1
a1177 1
      other_flags |= AF_LATIN_HINTS_MONO;
d1179 4
a1182 7
    /*
     *  In `light' hinting mode we disable horizontal hinting completely.
     *  We also do it if the face is italic.
     */
    if ( mode == FT_RENDER_MODE_LIGHT                    ||
         (face->style_flags & FT_STYLE_FLAG_ITALIC) != 0 )
      scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
d1184 5
a1188 2
    hints->scaler_flags = scaler_flags;
    hints->other_flags  = other_flags;
d1190 2
a1191 1
    return 0;
d1194 7
a1200 8

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
a1203 1

d1259 1
a1259 1
    AF_LatinAxis     axis     = & metrics->axis[dim];
d1262 1
a1262 1
    FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
d1278 1
d1297 2
a1298 2

        /* compare to standard width */
d1308 1
a1308 1
            dist = axis->widths[0].cur;
d1340 1
a1340 1

a1346 1

a1357 1

a1367 1

d1388 1
a1389 1

d1398 5
a1402 5
    FT_Pos  fitted_width = af_latin_compute_stem_width(
                             hints, dim, dist,
                             (AF_Edge_Flags)base_edge->flags,
                             (AF_Edge_Flags)stem_edge->flags );

a1417 1

d1422 1
a1422 1
  /****                    E D G E   H I N T I N G                      ****/
d1430 2
a1431 2
  af_latin_hint_edges( AF_GlyphHints  hints,
                       AF_Dimension   dim )
d1433 2
a1434 2
    AF_AxisHints  axis       = &hints->axis[dim];
    AF_Edge       edges      = axis->edges;
d1438 1
a1438 1
    AF_Edge       anchor     = 0;
a1443 1

d1522 2
a1523 4
        cur_len = af_latin_compute_stem_width(
                    hints, dim, org_len,
                    (AF_Edge_Flags)edge->flags,
                    (AF_Edge_Flags)edge2->flags );
d1574 2
a1575 4
        cur_len = af_latin_compute_stem_width(
                   hints, dim, org_len,
                   (AF_Edge_Flags)edge->flags,
                   (AF_Edge_Flags)edge2->flags );
d1614 2
a1615 4
          cur_len    = af_latin_compute_stem_width(
                         hints, dim, org_len,
                         (AF_Edge_Flags)edge->flags,
                         (AF_Edge_Flags)edge2->flags );
d1618 1
a1618 1
          delta1     = cur_pos1 + ( cur_len >> 1 ) - org_center;
d1623 1
a1623 1
          delta2     = cur_pos2 + ( cur_len >> 1 ) - org_center;
d1642 1
a1642 1
    /* serif, or twelve if they are with serifs.  This implementation is  */
d1703 3
a1705 4
      /*
       *  now hint the remaining edges (serifs and single) in order
       *  to complete our processing
       */
d1741 1
a1741 2
    FT_Error  error;
    int       dim;
d1743 1
a1744 22
    error = af_glyph_hints_reload( hints, outline );
    if ( error )
      goto Exit;

    /* analyze glyph outline */
    if ( AF_HINTS_DO_HORIZONTAL( hints ) )
    {
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_HORZ );
      if ( error )
        goto Exit;
    }

    if ( AF_HINTS_DO_VERTICAL( hints ) )
    {
      error = af_latin_hints_detect_features( hints, AF_DIMENSION_VERT );
      if ( error )
        goto Exit;

      af_latin_hints_compute_blue_edges( hints, metrics );
    }

    /* grid-fit the outline */
d1747 2
a1748 2
      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
d1750 4
a1753 18
#ifdef AF_USE_WARPER
        if ( dim == AF_DIMENSION_HORZ &&
             metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL )
        {
          AF_WarperRec  warper;
          FT_Fixed      scale;
          FT_Pos        delta;


          af_warper_compute( &warper, hints, dim, &scale, &delta );
          af_glyph_hints_scale_dim( hints, dim, scale, delta );
          continue;
        }
#endif
        af_latin_hint_edges( hints, (AF_Dimension)dim );
        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
d1758 1
a1758 2
  Exit:
    return error;
d1761 7
a1767 9

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****              L A T I N   S C R I P T   C L A S S              *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

d1771 1
a1771 1
    { 32,  127 },    /* XXX: TODO: Add new Unicode ranges here! */
d1773 1
a1773 1
    { 0,   0 }
d1776 1
a1776 3

  FT_CALLBACK_TABLE_DEF const AF_ScriptClassRec
  af_latin_script_class =
d1782 3
d1786 2
a1787 6
    (AF_Script_InitMetricsFunc) af_latin_metrics_init,
    (AF_Script_ScaleMetricsFunc)af_latin_metrics_scale,
    (AF_Script_DoneMetricsFunc) NULL,

    (AF_Script_InitHintsFunc)   af_latin_hints_init,
    (AF_Script_ApplyHintsFunc)  af_latin_hints_apply
a1789 2

/* END */
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
a18 3
#include <ft2build.h>
#include FT_ADVANCES_H

d77 1
a77 1
      error = af_glyph_hints_reload( hints, &face->glyph->outline, 0 );
a135 2
        axis->standard_width          = stdw;
        axis->extra_light             = 0;
d147 1
a147 2
  static const char af_latin_blue_chars[AF_LATIN_MAX_BLUES]
                                       [AF_LATIN_MAX_TEST_CHARACTERS + 1] =
d196 1
a196 2
        FT_Pos      best_y; /* same as points.y */
        FT_Int      best_point, best_first, best_last;
d198 3
a200 1
        FT_Bool     round = 0;
d216 12
a227 5
        best_point  = -1;
        best_y      = 0;  /* make compiler happy */
        best_first  = 0;  /* ditto */
        best_last   = 0;  /* ditto */

d229 4
a232 3
          FT_Int  nn;
          FT_Int  first = 0;
          FT_Int  last  = -1;
d234 1
d236 8
a243 4
          for ( nn = 0; nn < glyph->outline.n_contours; first = last+1, nn++ )
          {
            FT_Int  old_best_point = best_point;
            FT_Int  pp;
d246 2
a247 1
            last = glyph->outline.contours[nn];
d249 4
a252 7
            /* Avoid single-point contours since they are never rasterized. */
            /* In some fonts, they correspond to mark attachment points     */
            /* which are way outside of the glyph's real outline.           */
            if ( last <= first )
                continue;

            if ( AF_LATIN_IS_TOP_BLUE( bb ) )
d254 2
a255 21
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y > best_y )
                {
                  best_point = pp;
                  best_y     = points[pp].y;
                }
            }
            else
            {
              for ( pp = first; pp <= last; pp++ )
                if ( best_point < 0 || points[pp].y < best_y )
                {
                  best_point = pp;
                  best_y     = points[pp].y;
                }
            }

            if ( best_point != old_best_point )
            {
              best_first = first;
              best_last  = last;
d257 1
a258 10
          AF_LOG(( "%5d", best_y ));
        }

        /* now check whether the point belongs to a straight or round   */
        /* segment; we first need to find in which contour the extremum */
        /* lies, then inspect its previous and next points              */
        if ( best_point >= 0 )
        {
          FT_Int  prev, next;
          FT_Pos  dist;
d260 3
d266 2
a267 1
          prev = best_point;
d272 1
a272 1
            if ( prev > best_first )
d275 1
a275 1
              prev = best_last;
d277 1
a277 1
            dist = points[prev].y - best_y;
d281 1
a281 1
          } while ( prev != best_point );
d285 1
a285 1
            if ( next < best_last )
d288 1
a288 1
              next = best_first;
d290 1
a290 1
            dist = points[next].y - best_y;
d294 1
a294 1
          } while ( next != best_point );
d305 1
a305 1
          rounds[num_rounds++] = best_y;
d307 1
a307 1
          flats[num_flats++]   = best_y;
d318 1
a318 1
        AF_LOG(( "empty\n" ));
d369 1
a369 1
       * The following flag is used later to adjust the y and x scales
a382 46
  FT_LOCAL_DEF( void )
  af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
                                 FT_Face          face )
  {
    FT_UInt   i;
    FT_Bool   started = 0, same_width = 1;
    FT_Fixed  advance, old_advance = 0;


    /* check whether all ASCII digits have the same advance width; */
    /* digit `0' is 0x30 in all supported charmaps                 */
    for ( i = 0x30; i <= 0x39; i++ )
    {
      FT_UInt  glyph_index;


      glyph_index = FT_Get_Char_Index( face, i );
      if ( glyph_index == 0 )
        continue;

      if ( FT_Get_Advance( face, glyph_index,
                           FT_LOAD_NO_SCALE         |
                           FT_LOAD_NO_HINTING       |
                           FT_LOAD_IGNORE_TRANSFORM,
                           &advance ) )
        continue;

      if ( started )
      {
        if ( advance != old_advance )
        {
          same_width = 0;
          break;
        }
      }
      else
      {
        old_advance = advance;
        started     = 1;
      }
    }

    metrics->root.digits_have_same_width = same_width;
  }


a415 1
      af_latin_metrics_check_digits( metrics, face );
d474 1
a474 1
        FT_Pos  fitted = ( scaled + 40 ) & ~63;
a478 1
#if 0
d482 1
a482 1
              scale -= scale / 50;  /* scale *= 0.98 */
a484 2
#endif
          if ( dim == AF_DIMENSION_VERT )
a515 5
    /* an extra-light axis corresponds to a standard width that is */
    /* smaller than 0.75 pixels                                    */
    axis->extra_light =
      (FT_Bool)( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );

a592 1
    AF_SegmentRec seg0;
d597 6
a602 4

    FT_ZERO( &seg0 );
    seg0.score = 32000;
    seg0.flags = AF_EDGE_NORMAL;
d646 13
a719 2
            segment->height    = (FT_Short)( segment->max_coord -
                                             segment->min_coord );
a744 1
          segment[0]        = seg0;
d746 1
d751 3
d755 8
d770 4
d775 1
a775 2
    /* now slightly increase the height of segments when this makes */
    /* sense -- this is used to better detect and ignore serifs     */
d777 6
a782 2
      AF_Segment  segments     = axis->segments;
      AF_Segment  segments_end = segments + axis->num_segments;
d784 2
d787 2
a788 1
      for ( segment = segments; segment < segments_end; segment++ )
d790 1
a790 4
        AF_Point  first   = segment->first;
        AF_Point  last    = segment->last;
        FT_Pos    first_v = first->v;
        FT_Pos    last_v  = last->v;
d793 11
a803 2
        if ( first == last )
          continue;
d805 7
a811 3
        if ( first_v < last_v )
        {
          AF_Point  p;
d813 8
d822 2
a823 4
          p = first->prev;
          if ( p->v < first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( first_v - p->v ) >> 1 ) );
d825 7
a831 8
          p = last->next;
          if ( p->v > last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - last_v ) >> 1 ) );
        }
        else
        {
          AF_Point  p;
d833 8
d842 1
a842 10
          p = first->prev;
          if ( p->v > first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - first_v ) >> 1 ) );

          p = last->next;
          if ( p->v < last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( last_v - p->v ) >> 1 ) );
        }
d845 1
d859 1
d868 1
a868 1
    len_score = AF_LATIN_CONSTANT( hints->metrics, 6000 );
d875 1
a875 1
      if ( seg1->dir != axis->major_dir || seg1->first == seg1->last )
d879 1
a879 1
        if ( seg1->dir + seg2->dir == 0 && seg2->pos > seg1->pos )
d887 1
a887 1
            dist = -dist;
d929 1
a955 1
    FT_Pos        segment_length_threshold;
a965 10
    /*
     *  We ignore all segments that are less than 1 pixels in length,
     *  to avoid many problems with serif fonts.  We compute the
     *  corresponding threshold in font units.
     */
    if ( dim == AF_DIMENSION_HORZ )
        segment_length_threshold = FT_DivFix( 64, hints->y_scale );
    else
        segment_length_threshold = 0;

a995 9
      if ( seg->height < segment_length_threshold )
        continue;

      /* A special case for serif edges: If they are smaller than */
      /* 1.5 pixels we ignore them.                               */
      if ( seg->serif                                     &&
           2 * seg->height < 3 * segment_length_threshold )
        continue;

d1007 1
a1007 1
        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
d1016 1
a1016 1
        AF_Edge  edge;
d1021 1
a1021 3
        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        memory, &edge );
a1030 1
        edge->dir      = seg->dir;
d1113 1
a1113 3
          is_serif = (FT_Bool)( seg->serif               &&
                                seg->serif->edge         &&
                                seg->serif->edge != edge );
d1115 1
a1115 1
          if ( ( seg->link && seg->link->edge != NULL ) || is_serif )
a1168 1
#if 0
a1179 1
#endif
d1322 2
a1323 2
     *  correct x_scale and y_scale if needed, since they may have
     *  been modified `af_latin_metrics_scale_dim' above
d1333 1
a1333 1
#if 0 /* #ifdef AF_USE_WARPER */
d1453 1
a1453 2
    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
          axis->extra_light                      )
a1526 2
      FT_Pos  org_dist = dist;

a1561 10
          {
            /* We only round to an integer width if the corresponding */
            /* distortion is less than 1/4 pixel.  Otherwise this     */
            /* makes everything worse since the diagonals, which are  */
            /* not hinted, appear a lot bolder or thinner than the    */
            /* vertical stems.                                        */

            FT_Pos  delta;


a1562 11
            delta = dist - org_dist;
            if ( delta < 0 )
              delta = -delta;

            if (delta >= 16)
            {
              dist = org_dist;
              if ( dist < 48 )
                dist = ( dist + 64 ) >> 1;
            }
          }
a1594 5

    AF_LOG(( "LINK: edge %d (opos=%.2f) linked to (%.2f), "
             "dist was %.2f, now %.2f\n",
             stem_edge-hints->axis[dim].edges, stem_edge->opos / 64.0,
             stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
d1627 1
a1627 1
    FT_PtrDist    n_edges;
d1636 1
a1636 1
    if ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_BLUES( hints ) )
a1664 5
        AF_LOG(( "BLUE: edge %d (opos=%.2f) snapped to (%.2f), "
                 "was (%.2f)\n",
                 edge1-edges, edge1->opos / 64.0, blue->fit / 64.0,
                 edge1->pos / 64.0 ));

d1700 1
a1700 1
      if ( edge2->blue_edge )
a1701 2
        AF_LOG(( "ASSERTION FAILED for edge %d\n", edge2-edges ));

d1746 2
a1747 1
          edge2->pos = edge->pos + cur_len;
a1751 5
        AF_LOG(( "ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f) "
                 "snapped to (%.2f) (%.2f)\n",
                 edge-edges, edge->opos / 64.0,
                 edge2-edges, edge2->opos / 64.0,
                 edge->pos / 64.0, edge2->pos / 64.0 ));
d1773 1
a1773 4
        if ( edge2->flags & AF_EDGE_DONE )
          edge->pos = edge2->pos - cur_len;

        else if ( cur_len < 96 )
a1802 6

          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
a1826 6

          AF_LOG(( "STEM: %d (opos=%.2f) to %d (opos=%.2f) "
                   "snapped to (%.2f) and (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge2-edges, edge2->opos / 64.0,
                   edge->pos / 64.0, edge2->pos / 64.0 ));
a1832 3
        {
          AF_LOG(( "BOUND: %d (pos=%.2f) to (%.2f)\n",
                   edge-edges, edge->pos / 64.0, edge[-1].pos / 64.0 ));
a1833 1
        }
a1906 3
        FT_Pos  delta;


a1909 2
        delta = 1000;

a1910 8
        {
          delta = edge->serif->opos - edge->opos;
          if ( delta < 0 )
            delta = -delta;
        }

        if ( delta < 64 + 16 )
        {
a1911 6
          AF_LOG(( "SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f) "
                   "aligned to (%.2f)\n",
                   edge-edges, edge->opos / 64.0,
                   edge->serif - edges, edge->serif->opos / 64.0,
                   edge->pos / 64.0 ));
        }
a1913 2
          AF_LOG(( "SERIF_ANCHOR: edge %d (opos=%.2f) snapped to (%.2f)\n",
                   edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
d1918 2
a1919 36
        {
          AF_Edge  before, after;


          for ( before = edge - 1; before >= edges; before-- )
            if ( before->flags & AF_EDGE_DONE )
              break;

          for ( after = edge + 1; after < edge_limit; after++ )
            if ( after->flags & AF_EDGE_DONE )
              break;

          if ( before >= edges && before < edge   &&
               after < edge_limit && after > edge )
          {
            if ( after->opos == before->opos )
              edge->pos = before->pos;
            else
              edge->pos = before->pos +
                          FT_MulDiv( edge->opos - before->opos,
                                     after->pos - before->pos,
                                     after->opos - before->opos );
            AF_LOG(( "SERIF_LINK1: edge %d (opos=%.2f) snapped to (%.2f) "
                     "from %d (opos=%.2f)\n",
                     edge-edges, edge->opos / 64.0,
                     edge->pos / 64.0, before - edges,
                     before->opos / 64.0 ));
          }
          else
          {
            edge->pos = anchor->pos +
                        ( ( edge->opos - anchor->opos + 16 ) & ~31 );
            AF_LOG(( "SERIF_LINK2: edge %d (opos=%.2f) snapped to (%.2f)\n",
                     edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
          }
        }
d1944 1
a1944 1
    error = af_glyph_hints_reload( hints, outline, 1 );
a1948 4
#ifdef AF_USE_WARPER
    if ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ||
         AF_HINTS_DO_HORIZONTAL( hints ) )
#else
a1949 1
#endif
d1968 3
d1972 6
a1977 6
      if ( ( dim == AF_DIMENSION_HORZ &&
             metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT ) )
      {
        AF_WarperRec  warper;
        FT_Fixed      scale;
        FT_Pos        delta;
d1980 4
a1983 4
        af_warper_compute( &warper, hints, dim, &scale, &delta );
        af_glyph_hints_scale_dim( hints, dim, scale, delta );
        continue;
      }
a1984 4

      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
      {
a2006 3
  /* XXX: this should probably fine tuned to differentiate better between */
  /*      scripts...                                                      */

d2009 3
a2011 27
    AF_UNIRANGE_REC(  0x0020UL,  0x007FUL ),  /* Basic Latin (no control chars) */
    AF_UNIRANGE_REC(  0x00A0UL,  0x00FFUL ),  /* Latin-1 Supplement (no control chars) */
    AF_UNIRANGE_REC(  0x0100UL,  0x017FUL ),  /* Latin Extended-A */
    AF_UNIRANGE_REC(  0x0180UL,  0x024FUL ),  /* Latin Extended-B */
    AF_UNIRANGE_REC(  0x0250UL,  0x02AFUL ),  /* IPA Extensions */
    AF_UNIRANGE_REC(  0x02B0UL,  0x02FFUL ),  /* Spacing Modifier Letters */
    AF_UNIRANGE_REC(  0x0300UL,  0x036FUL ),  /* Combining Diacritical Marks */
    AF_UNIRANGE_REC(  0x0370UL,  0x03FFUL ),  /* Greek and Coptic */
    AF_UNIRANGE_REC(  0x0400UL,  0x04FFUL ),  /* Cyrillic */
    AF_UNIRANGE_REC(  0x0500UL,  0x052FUL ),  /* Cyrillic Supplement */
    AF_UNIRANGE_REC(  0x1D00UL,  0x1D7FUL ),  /* Phonetic Extensions */
    AF_UNIRANGE_REC(  0x1D80UL,  0x1DBFUL ),  /* Phonetic Extensions Supplement */
    AF_UNIRANGE_REC(  0x1DC0UL,  0x1DFFUL ),  /* Combining Diacritical Marks Supplement */
    AF_UNIRANGE_REC(  0x1E00UL,  0x1EFFUL ),  /* Latin Extended Additional */
    AF_UNIRANGE_REC(  0x1F00UL,  0x1FFFUL ),  /* Greek Extended */
    AF_UNIRANGE_REC(  0x2000UL,  0x206FUL ),  /* General Punctuation */
    AF_UNIRANGE_REC(  0x2070UL,  0x209FUL ),  /* Superscripts and Subscripts */
    AF_UNIRANGE_REC(  0x20A0UL,  0x20CFUL ),  /* Currency Symbols */
    AF_UNIRANGE_REC(  0x2150UL,  0x218FUL ),  /* Number Forms */
    AF_UNIRANGE_REC(  0x2460UL,  0x24FFUL ),  /* Enclosed Alphanumerics */
    AF_UNIRANGE_REC(  0x2C60UL,  0x2C7FUL ),  /* Latin Extended-C */
    AF_UNIRANGE_REC(  0x2DE0UL,  0x2DFFUL ),  /* Cyrillic Extended-A */
    AF_UNIRANGE_REC(  0xA640UL,  0xA69FUL ),  /* Cyrillic Extended-B */
    AF_UNIRANGE_REC(  0xA720UL,  0xA7FFUL ),  /* Latin Extended-D */
    AF_UNIRANGE_REC(  0xFB00UL,  0xFB06UL ),  /* Alphab. Present. Forms (Latin Ligs) */
    AF_UNIRANGE_REC( 0x1D400UL, 0x1D7FFUL ),  /* Mathematical Alphanumeric Symbols */
    AF_UNIRANGE_REC(       0UL,       0UL )
d2015 3
a2017 1
  AF_DEFINE_SCRIPT_CLASS(af_latin_script_class,  
d2029 1
a2029 1
  )
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d5 1
a5 1
/*    Auto-fitter hinting routines for latin writing system (body).        */
d7 1
a7 1
/*  Copyright 2003-2016 by                                                 */
a20 1
#include FT_INTERNAL_DEBUG_H
a21 2
#include "afglobal.h"
#include "afpic.h"
d26 1
a26 1
#ifdef AF_CONFIG_OPTION_USE_WARPER
a31 14
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_aflatin


  /* needed for computation of round vs. flat segments */
#define FLAT_THRESHOLD( x )  ( x / 14 )


  /*************************************************************************/
a38 4

  /* Find segments and links, compute all stem widths, and initialize */
  /* standard width and height for the glyph with given charcode.     */

d41 2
a42 1
                                FT_Face          face )
a47 6
    FT_TRACE5(( "\n"
                "latin standard widths computation (style `%s')\n"
                "=====================================================\n"
                "\n",
                af_style_names[metrics->root.style_class->style] ));

d54 5
a58 20
      FT_Error            error;
      FT_ULong            glyph_index;
      int                 dim;
      AF_LatinMetricsRec  dummy[1];
      AF_Scaler           scaler = &dummy->root.scaler;

#ifdef FT_CONFIG_OPTION_PIC
      AF_FaceGlobals  globals = metrics->root.globals;
#endif

      AF_StyleClass   style_class  = metrics->root.style_class;
      AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                       [style_class->script];

      void*        shaper_buf;
      const char*  p;

#ifdef FT_DEBUG_LEVEL_TRACE
      FT_ULong  ch = 0;
#endif
a59 2
      p          = script_class->standard_charstring;
      shaper_buf = af_shaper_buf_create( face );
d61 2
a62 43
      /*
       * We check a list of standard characters to catch features like
       * `c2sc' (small caps from caps) that don't contain lowercase letters
       * by definition, or other features that mainly operate on numerals.
       * The first match wins.
       */

      glyph_index = 0;
      while ( *p )
      {
        unsigned int  num_idx;

#ifdef FT_DEBUG_LEVEL_TRACE
        const char*  p_old;
#endif


        while ( *p == ' ' )
          p++;

#ifdef FT_DEBUG_LEVEL_TRACE
        p_old = p;
        GET_UTF8_CHAR( ch, p_old );
#endif

        /* reject input that maps to more than a single glyph */
        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
        if ( num_idx > 1 )
          continue;

        /* otherwise exit loop if we have a result */
        glyph_index = af_shaper_get_elem( &metrics->root,
                                          shaper_buf,
                                          0,
                                          NULL,
                                          NULL );
        if ( glyph_index )
          break;
      }

      af_shaper_buf_destroy( face, shaper_buf );

      if ( !glyph_index )
a64 3
      FT_TRACE5(( "standard character: U+%04lX (glyph index %d)\n",
                  ch, glyph_index ));

d72 2
a73 6

      scaler->x_scale = 0x10000L;
      scaler->y_scale = 0x10000L;
      scaler->x_delta = 0;
      scaler->y_delta = 0;

d78 1
a78 1
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
d80 1
a80 1
      error = af_glyph_hints_reload( hints, &face->glyph->outline );
a96 6
        /*
         *  We assume that the glyphs selected for the stem width
         *  computation are `featureless' enough so that the linking
         *  algorithm works fine without adjustments of its scoring
         *  function.
         */
a97 2
                                      0,
                                      NULL,
d118 1
a118 1
              axis->widths[num_widths++].org = dist;
d122 1
a122 4
        /* this also replaces multiple almost identical stem widths */
        /* with a single one (the value 100 is heuristic)           */
        af_sort_and_quantize_widths( &num_widths, axis->widths,
                                     dummy->units_per_em / 100 );
d126 1
a126 1
    Exit:
d133 3
a135 2
        stdw = ( axis->width_count > 0 ) ? axis->widths[0].org
                                         : AF_LATIN_CONSTANT( metrics, 50 );
d141 2
d144 2
a145 8
#ifdef FT_DEBUG_LEVEL_TRACE
        {
          FT_UInt  i;


          FT_TRACE5(( "%s widths:\n",
                      dim == AF_DIMENSION_VERT ? "horizontal"
                                               : "vertical" ));
a146 3
          FT_TRACE5(( "  %d (standard)", axis->standard_width ));
          for ( i = 1; i < axis->width_count; i++ )
            FT_TRACE5(( " %d", axis->widths[i].org ));
a147 5
          FT_TRACE5(( "\n" ));
        }
#endif
      }
    }
d149 1
a149 1
    FT_TRACE5(( "\n" ));
a150 2
    af_glyph_hints_done( hints );
  }
d152 10
a162 2
  /* Find all blue zones.  Flat segments give the reference points, */
  /* round segments the overshoot positions.                        */
d168 5
a172 6
    FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
    FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];

    FT_UInt       num_flats;
    FT_UInt       num_rounds;

d175 2
a176 2
    AF_LatinAxis  axis = &metrics->axis[AF_DIMENSION_VERT];
    FT_Outline    outline;
a177 1
    AF_StyleClass  sc = metrics->root.style_class;
d179 3
a181 2
    AF_Blue_Stringset         bss = sc->blue_stringset;
    const AF_Blue_StringRec*  bs  = &af_blue_stringsets[bss];
d183 2
a184 1
    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );
d186 1
a186 13
    void*  shaper_buf;


    /* we walk over the blue character strings as specified in the */
    /* style's entry in the `af_blue_stringset' array              */

    FT_TRACE5(( "latin blue zones computation\n"
                "============================\n"
                "\n" ));

    shaper_buf = af_shaper_buf_create( face );

    for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
d188 2
a189 1
      const char*  p = &af_blue_strings[bs->string];
a191 25
      FT_Pos       ascender;
      FT_Pos       descender;


#ifdef FT_DEBUG_LEVEL_TRACE
      {
        FT_Bool  have_flag = 0;


        FT_TRACE5(( "blue zone %d", axis->blue_count ));

        if ( bs->properties )
        {
          FT_TRACE5(( " (" ));

          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          {
            FT_TRACE5(( "top" ));
            have_flag = 1;
          }
          else if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
          {
            FT_TRACE5(( "sub top" ));
            have_flag = 1;
          }
a192 25
          if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "neutral" ));
            have_flag = 1;
          }

          if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "small top" ));
            have_flag = 1;
          }

          if ( AF_LATIN_IS_LONG_BLUE( bs ) )
          {
            if ( have_flag )
              FT_TRACE5(( ", " ));
            FT_TRACE5(( "long" ));
          }

          FT_TRACE5(( ")" ));
        }
d194 1
a194 3
        FT_TRACE5(( ":\n" ));
      }
#endif /* FT_DEBUG_LEVEL_TRACE */
a197 2
      ascender   = 0;
      descender  = 0;
d199 1
a199 1
      while ( *p )
d201 3
a203 3
        FT_ULong    glyph_index;
        FT_Long     y_offset;
        FT_Int      best_point, best_contour_first, best_contour_last;
d205 1
a206 2
        FT_Pos   best_y_extremum;                      /* same as points.y */
        FT_Bool  best_round = 0;
d208 1
a208 1
        unsigned int  i, num_idx;
d210 4
a213 4
#ifdef FT_DEBUG_LEVEL_TRACE
        const char*  p_old;
        FT_ULong     ch;
#endif
d215 3
d219 6
a224 2
        while ( *p == ' ' )
          p++;
a225 8
#ifdef FT_DEBUG_LEVEL_TRACE
        p_old = p;
        GET_UTF8_CHAR( ch, p_old );
#endif

        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );

        if ( !num_idx )
d227 3
a229 3
          FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
          continue;
        }
a230 4
        if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          best_y_extremum = FT_INT_MIN;
        else
          best_y_extremum = FT_INT_MAX;
d232 1
a232 15
        /* iterate over all glyph elements of the character cluster */
        /* and get the data of the `biggest' one                    */
        for ( i = 0; i < num_idx; i++ )
        {
          FT_Pos   best_y;
          FT_Bool  round = 0;


          /* load the character in the face -- skip unknown or empty ones */
          glyph_index = af_shaper_get_elem( &metrics->root,
                                            shaper_buf,
                                            i,
                                            NULL,
                                            &y_offset );
          if ( glyph_index == 0 )
d234 2
a235 3
            FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
            continue;
          }
a236 14
          error   = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
          outline = face->glyph->outline;
          /* reject glyphs that don't produce any rendering */
          if ( error || outline.n_points <= 2 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            if ( num_idx == 1 )
              FT_TRACE5(( "  U+%04lX contains no (usable) outlines\n", ch ));
            else
              FT_TRACE5(( "  component %d of cluster starting with U+%04lX"
                          " contains no (usable) outlines\n", i, ch ));
#endif
            continue;
          }
d238 1
a238 6
          /* now compute min or max point indices and coordinates */
          points             = outline.points;
          best_point         = -1;
          best_y             = 0;  /* make compiler happy */
          best_contour_first = 0;  /* ditto */
          best_contour_last  = 0;  /* ditto */
d240 5
a244 4
          {
            FT_Int  nn;
            FT_Int  first = 0;
            FT_Int  last  = -1;
d246 1
a246 2

            for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )
d248 2
a249 17
              FT_Int  old_best_point = best_point;
              FT_Int  pp;


              last = outline.contours[nn];

              /* Avoid single-point contours since they are never      */
              /* rasterized.  In some fonts, they correspond to mark   */
              /* attachment points that are way outside of the glyph's */
              /* real outline.                                         */
              if ( last <= first )
                continue;

              if ( AF_LATIN_IS_TOP_BLUE( bs )     ||
                   AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
              {
                for ( pp = first; pp <= last; pp++ )
d251 2
a252 8
                  if ( best_point < 0 || points[pp].y > best_y )
                  {
                    best_point = pp;
                    best_y     = points[pp].y;
                    ascender   = FT_MAX( ascender, best_y + y_offset );
                  }
                  else
                    descender = FT_MIN( descender, points[pp].y + y_offset );
d254 5
a258 4
              }
              else
              {
                for ( pp = first; pp <= last; pp++ )
d260 2
a261 8
                  if ( best_point < 0 || points[pp].y < best_y )
                  {
                    best_point = pp;
                    best_y     = points[pp].y;
                    descender  = FT_MIN( descender, best_y + y_offset );
                  }
                  else
                    ascender = FT_MAX( ascender, points[pp].y + y_offset );
d263 1
a263 1
              }
d265 4
a268 5
              if ( best_point != old_best_point )
              {
                best_contour_first = first;
                best_contour_last  = last;
              }
d271 2
d274 7
a280 10
          /* now check whether the point belongs to a straight or round   */
          /* segment; we first need to find in which contour the extremum */
          /* lies, then inspect its previous and next points              */
          if ( best_point >= 0 )
          {
            FT_Pos  best_x = points[best_point].x;
            FT_Int  prev, next;
            FT_Int  best_segment_first, best_segment_last;
            FT_Int  best_on_point_first, best_on_point_last;
            FT_Pos  dist;
d283 4
a286 2
            best_segment_first = best_point;
            best_segment_last  = best_point;
d288 4
a291 5
            if ( FT_CURVE_TAG( outline.tags[best_point] ) == FT_CURVE_TAG_ON )
            {
              best_on_point_first = best_point;
              best_on_point_last  = best_point;
            }
d293 1
a293 4
            {
              best_on_point_first = -1;
              best_on_point_last  = -1;
            }
d295 3
a297 5
            /* look for the previous and next points on the contour  */
            /* that are not on the same Y coordinate, then threshold */
            /* the `closeness'...                                    */
            prev = best_point;
            next = prev;
d299 1
a299 13
            do
            {
              if ( prev > best_contour_first )
                prev--;
              else
                prev = best_contour_last;

              dist = FT_ABS( points[prev].y - best_y );
              /* accept a small distance or a small angle (both values are */
              /* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
              if ( dist > 5 )
                if ( FT_ABS( points[prev].x - best_x ) <= 20 * dist )
                  break;
d301 4
a304 222
              best_segment_first = prev;

              if ( FT_CURVE_TAG( outline.tags[prev] ) == FT_CURVE_TAG_ON )
              {
                best_on_point_first = prev;
                if ( best_on_point_last < 0 )
                  best_on_point_last = prev;
              }

            } while ( prev != best_point );

            do
            {
              if ( next < best_contour_last )
                next++;
              else
                next = best_contour_first;

              dist = FT_ABS( points[next].y - best_y );
              if ( dist > 5 )
                if ( FT_ABS( points[next].x - best_x ) <= 20 * dist )
                  break;

              best_segment_last = next;

              if ( FT_CURVE_TAG( outline.tags[next] ) == FT_CURVE_TAG_ON )
              {
                best_on_point_last = next;
                if ( best_on_point_first < 0 )
                  best_on_point_first = next;
              }

            } while ( next != best_point );

            if ( AF_LATIN_IS_LONG_BLUE( bs ) )
            {
              /* If this flag is set, we have an additional constraint to  */
              /* get the blue zone distance: Find a segment of the topmost */
              /* (or bottommost) contour that is longer than a heuristic   */
              /* threshold.  This ensures that small bumps in the outline  */
              /* are ignored (for example, the `vertical serifs' found in  */
              /* many Hebrew glyph designs).                               */

              /* If this segment is long enough, we are done.  Otherwise,  */
              /* search the segment next to the extremum that is long      */
              /* enough, has the same direction, and a not too large       */
              /* vertical distance from the extremum.  Note that the       */
              /* algorithm doesn't check whether the found segment is      */
              /* actually the one (vertically) nearest to the extremum.    */

              /* heuristic threshold value */
              FT_Pos  length_threshold = metrics->units_per_em / 25;


              dist = FT_ABS( points[best_segment_last].x -
                               points[best_segment_first].x );

              if ( dist < length_threshold                       &&
                   best_segment_last - best_segment_first + 2 <=
                     best_contour_last - best_contour_first      )
              {
                /* heuristic threshold value */
                FT_Pos  height_threshold = metrics->units_per_em / 4;

                FT_Int   first;
                FT_Int   last;
                FT_Bool  hit;

                /* we intentionally declare these two variables        */
                /* outside of the loop since various compilers emit    */
                /* incorrect warning messages otherwise, talking about */
                /* `possibly uninitialized variables'                  */
                FT_Int  p_first = 0;            /* make compiler happy */
                FT_Int  p_last  = 0;

                FT_Bool  left2right;


                /* compute direction */
                prev = best_point;

                do
                {
                  if ( prev > best_contour_first )
                    prev--;
                  else
                    prev = best_contour_last;

                  if ( points[prev].x != best_x )
                    break;

                } while ( prev != best_point );

                /* skip glyph for the degenerate case */
                if ( prev == best_point )
                  continue;

                left2right = FT_BOOL( points[prev].x < points[best_point].x );

                first = best_segment_last;
                last  = first;
                hit   = 0;

                do
                {
                  FT_Bool  l2r;
                  FT_Pos   d;


                  if ( !hit )
                  {
                    /* no hit; adjust first point */
                    first = last;

                    /* also adjust first and last on point */
                    if ( FT_CURVE_TAG( outline.tags[first] ) ==
                           FT_CURVE_TAG_ON )
                    {
                      p_first = first;
                      p_last  = first;
                    }
                    else
                    {
                      p_first = -1;
                      p_last  = -1;
                    }

                    hit = 1;
                  }

                  if ( last < best_contour_last )
                    last++;
                  else
                    last = best_contour_first;

                  if ( FT_ABS( best_y - points[first].y ) > height_threshold )
                  {
                    /* vertical distance too large */
                    hit = 0;
                    continue;
                  }

                  /* same test as above */
                  dist = FT_ABS( points[last].y - points[first].y );
                  if ( dist > 5 )
                    if ( FT_ABS( points[last].x - points[first].x ) <=
                           20 * dist )
                    {
                      hit = 0;
                      continue;
                    }

                  if ( FT_CURVE_TAG( outline.tags[last] ) == FT_CURVE_TAG_ON )
                  {
                    p_last = last;
                    if ( p_first < 0 )
                      p_first = last;
                  }

                  l2r = FT_BOOL( points[first].x < points[last].x );
                  d   = FT_ABS( points[last].x - points[first].x );

                  if ( l2r == left2right     &&
                       d >= length_threshold )
                  {
                    /* all constraints are met; update segment after */
                    /* finding its end                               */
                    do
                    {
                      if ( last < best_contour_last )
                        last++;
                      else
                        last = best_contour_first;

                      d = FT_ABS( points[last].y - points[first].y );
                      if ( d > 5 )
                        if ( FT_ABS( points[next].x - points[first].x ) <=
                               20 * dist )
                        {
                          if ( last > best_contour_first )
                            last--;
                          else
                            last = best_contour_last;
                          break;
                        }

                      p_last = last;

                      if ( FT_CURVE_TAG( outline.tags[last] ) ==
                             FT_CURVE_TAG_ON )
                      {
                        p_last = last;
                        if ( p_first < 0 )
                          p_first = last;
                      }

                    } while ( last != best_segment_first );

                    best_y = points[first].y;

                    best_segment_first = first;
                    best_segment_last  = last;

                    best_on_point_first = p_first;
                    best_on_point_last  = p_last;

                    break;
                  }

                } while ( last != best_segment_first );
              }
            }

            /* for computing blue zones, we add the y offset as returned */
            /* by the currently used OpenType feature -- for example,    */
            /* superscript glyphs might be identical to subscript glyphs */
            /* with a vertical shift                                     */
            best_y += y_offset;

#ifdef FT_DEBUG_LEVEL_TRACE
            if ( num_idx == 1 )
              FT_TRACE5(( "  U+%04lX: best_y = %5ld", ch, best_y ));
d306 1
a306 3
              FT_TRACE5(( "  component %d of cluster starting with U+%04lX:"
                          " best_y = %5ld", i, ch, best_y ));
#endif
d308 3
a310 20
            /* now set the `round' flag depending on the segment's kind: */
            /*                                                           */
            /* - if the horizontal distance between the first and last   */
            /*   `on' point is larger than a heuristic threshold         */
            /*   we have a flat segment                                  */
            /* - if either the first or the last point of the segment is */
            /*   an `off' point, the segment is round, otherwise it is   */
            /*   flat                                                    */
            if ( best_on_point_first >= 0                               &&
                 best_on_point_last >= 0                                &&
                 ( FT_ABS( points[best_on_point_last].x -
                           points[best_on_point_first].x ) ) >
                   flat_threshold                                       )
              round = 0;
            else
              round = FT_BOOL(
                        FT_CURVE_TAG( outline.tags[best_segment_first] ) !=
                          FT_CURVE_TAG_ON                                   ||
                        FT_CURVE_TAG( outline.tags[best_segment_last]  ) !=
                          FT_CURVE_TAG_ON                                   );
d312 1
a312 6
            if ( round && AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
            {
              /* only use flat segments for a neutral blue zone */
              FT_TRACE5(( " (round, skipped)\n" ));
              continue;
            }
d314 4
a317 2
            FT_TRACE5(( " (%s)\n", round ? "round" : "flat" ));
          }
d319 2
a320 16
          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
          {
            if ( best_y > best_y_extremum )
            {
              best_y_extremum = best_y;
              best_round      = round;
            }
          }
          else
          {
            if ( best_y < best_y_extremum )
            {
              best_y_extremum = best_y;
              best_round      = round;
            }
          }
d322 5
a326 10
        } /* end for loop */

        if ( !( best_y_extremum == FT_INT_MIN ||
                best_y_extremum == FT_INT_MAX ) )
        {
          if ( best_round )
            rounds[num_rounds++] = best_y_extremum;
          else
            flats[num_flats++]   = best_y_extremum;
        }
d328 1
a328 1
      } /* end while loop */
d336 1
a336 1
        FT_TRACE5(( "  empty\n" ));
d346 3
a348 3
      blue       = &axis->blues[axis->blue_count];
      blue_ref   = &blue->ref.org;
      blue_shoot = &blue->shoot.org;
d364 1
a364 1
        *blue_ref   = flats [num_flats  / 2];
d378 2
a379 9
        if ( ( AF_LATIN_IS_TOP_BLUE( bs )    ||
               AF_LATIN_IS_SUB_TOP_BLUE( bs) ) ^ over_ref )
        {
          *blue_ref   =
          *blue_shoot = ( shoot + ref ) / 2;

          FT_TRACE5(( "  [overshoot smaller than reference,"
                      " taking mean value]\n" ));
        }
a381 3
      blue->ascender  = ascender;
      blue->descender = descender;

d383 1
a383 1
      if ( AF_LATIN_IS_TOP_BLUE( bs ) )
a384 4
      if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_SUB_TOP;
      if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
        blue->flags |= AF_LATIN_BLUE_NEUTRAL;
d391 1
a391 1
      if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
d394 2
a395 9
      FT_TRACE5(( "    -> reference = %ld\n"
                  "       overshoot = %ld\n",
                  *blue_ref, *blue_shoot ));

    } /* end for loop */

    af_shaper_buf_destroy( face, shaper_buf );

    FT_TRACE5(( "\n" ));
a400 2
  /* Check whether all ASCII digits have the same advance width. */

d405 1
a408 6
    void*  shaper_buf;

    /* in all supported charmaps, digits have character codes 0x30-0x39 */
    const char   digits[] = "0 1 2 3 4 5 6 7 8 9";
    const char*  p;

d410 3
a412 4
    p          = digits;
    shaper_buf = af_shaper_buf_create( face );

    while ( *p )
d414 1
a414 2
      FT_ULong      glyph_index;
      unsigned int  num_idx;
d417 2
a418 3
      /* reject input that maps to more than a single glyph */
      p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
      if ( num_idx > 1 )
d421 5
a425 6
      glyph_index = af_shaper_get_elem( &metrics->root,
                                        shaper_buf,
                                        0,
                                        &advance,
                                        NULL );
      if ( !glyph_index )
a442 2
    af_shaper_buf_destroy( face, shaper_buf );

a446 2
  /* Initialize global metrics. */

d451 1
d453 10
d467 9
a475 1
    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
d477 2
a478 1
      af_latin_metrics_init_widths( metrics, face );
d484 1
a484 1
    return FT_Err_Ok;
a487 3
  /* Adjust scaling value, then scale and shift widths   */
  /* and blue zones (if applicable) for given dimension. */

d538 2
a539 18
        FT_Pos   scaled;
        FT_Pos   threshold;
        FT_Pos   fitted;
        FT_UInt  limit;
        FT_UInt  ppem;


        scaled    = FT_MulFix( blue->shoot.org, scale );
        ppem      = metrics->root.scaler.face->size->metrics.x_ppem;
        limit     = metrics->root.globals->increase_x_height;
        threshold = 40;

        /* if the `increase-x-height' property is active, */
        /* we round up much more often                    */
        if ( limit                                 &&
             ppem <= limit                         &&
             ppem >= AF_PROP_INCREASE_X_HEIGHT_MIN )
          threshold = 52;
a540 1
        fitted = ( scaled + threshold ) & ~63;
d554 1
a554 46
            FT_Pos    max_height;
            FT_Pos    dist;
            FT_Fixed  new_scale;


            new_scale = FT_MulDiv( scale, fitted, scaled );

            /* the scaling should not change the result by more than two pixels */
            max_height = metrics->units_per_em;

            for ( nn = 0; nn < Axis->blue_count; nn++ )
            {
              max_height = FT_MAX( max_height, Axis->blues[nn].ascender );
              max_height = FT_MAX( max_height, -Axis->blues[nn].descender );
            }

            dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );
            dist &= ~127;

            if ( dist == 0 )
            {
              FT_TRACE5((
                "af_latin_metrics_scale_dim:"
                " x height alignment (style `%s'):\n"
                "                           "
                " vertical scaling changed from %.5f to %.5f (by %d%%)\n"
                "\n",
                af_style_names[metrics->root.style_class->style],
                scale / 65536.0,
                new_scale / 65536.0,
                ( fitted - scaled ) * 100 / scaled ));

              scale = new_scale;
            }
#ifdef FT_DEBUG_LEVEL_TRACE
            else
            {
              FT_TRACE5((
                "af_latin_metrics_scale_dim:"
                " x height alignment (style `%s'):\n"
                "                           "
                " excessive vertical scaling abandoned\n"
                "\n",
                af_style_names[metrics->root.style_class->style] ));
            }
#endif
d574 1
a574 5
    FT_TRACE5(( "%s widths (style `%s')\n",
                dim == AF_DIMENSION_HORZ ? "horizontal" : "vertical",
                af_style_names[metrics->root.style_class->style] ));

    /* scale the widths */
a581 4

      FT_TRACE5(( "  %d scaled to %.2f\n",
                  width->org,
                  width->cur / 64.0 ));
a583 2
    FT_TRACE5(( "\n" ));

d585 1
a585 1
    /* smaller than 5/8 pixels                                     */
a588 7
#ifdef FT_DEBUG_LEVEL_TRACE
    if ( axis->extra_light )
      FT_TRACE5(( "`%s' style is extra light (at current resolution)\n"
                  "\n",
                  af_style_names[metrics->root.style_class->style] ));
#endif

a590 6
#ifdef FT_DEBUG_LEVEL_TRACE
      if ( axis->blue_count )
        FT_TRACE5(( "blue zones (style `%s')\n",
                    af_style_names[metrics->root.style_class->style] ));
#endif

d608 1
a608 5
#if 0
          FT_Pos  delta1;
#endif
          FT_Pos  delta2;

a609 1
          /* use discrete values for blue zone widths */
a610 3
#if 0

          /* generic, original code */
a630 22
#else

          /* simplified version due to abs(dist) <= 48 */
          delta2 = dist;
          if ( dist < 0 )
            delta2 = -delta2;

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 48 )
            delta2 = 32;
          else
            delta2 = 64;

          if ( dist < 0 )
            delta2 = -delta2;

          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
          blue->shoot.fit = blue->ref.fit - delta2;

#endif

a633 55

      /* use sub-top blue zone only if it doesn't overlap with */
      /* another (non-sup-top) blue zone; otherwise, the       */
      /* effect would be similar to a neutral blue zone, which */
      /* is not desired here                                   */
      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue  blue = &axis->blues[nn];
        FT_UInt       i;


        if ( !( blue->flags & AF_LATIN_BLUE_SUB_TOP ) )
          continue;
        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
          continue;

        for ( i = 0; i < axis->blue_count; i++ )
        {
          AF_LatinBlue  b = &axis->blues[i];


          if ( b->flags & AF_LATIN_BLUE_SUB_TOP )
            continue;
          if ( !( b->flags & AF_LATIN_BLUE_ACTIVE ) )
            continue;

          if ( b->ref.fit <= blue->shoot.fit &&
               b->shoot.fit >= blue->ref.fit )
          {
            blue->flags &= ~AF_LATIN_BLUE_ACTIVE;
            break;
          }
        }
      }

#ifdef FT_DEBUG_LEVEL_TRACE
      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue  blue = &axis->blues[nn];


        FT_TRACE5(( "  reference %d: %d scaled to %.2f%s\n"
                    "  overshoot %d: %d scaled to %.2f%s\n",
                    nn,
                    blue->ref.org,
                    blue->ref.fit / 64.0,
                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
                                                       : " (inactive)",
                    nn,
                    blue->shoot.org,
                    blue->shoot.fit / 64.0,
                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
                                                       : " (inactive)" ));
      }
#endif
a637 2
  /* Scale global values in both directions. */

a643 1
    metrics->root.scaler.flags       = scaler->flags;
a649 16
  /* Extract standard_width from writing system/script specific */
  /* metrics class.                                             */

  FT_LOCAL_DEF( void )
  af_latin_get_standard_widths( AF_LatinMetrics  metrics,
                                FT_Pos*          stdHW,
                                FT_Pos*          stdVW )
  {
    if ( stdHW )
      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;

    if ( stdVW )
      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
  }


a657 3

  /* Walk over all contours and compute its segments. */

d662 8
a669 11
    AF_LatinMetrics  metrics       = (AF_LatinMetrics)hints->metrics;
    AF_AxisHints     axis          = &hints->axis[dim];
    FT_Memory        memory        = hints->memory;
    FT_Error         error         = FT_Err_Ok;
    AF_Segment       segment       = NULL;
    AF_SegmentRec    seg0;
    AF_Point*        contour       = hints->contours;
    AF_Point*        contour_limit = contour + hints->num_contours;
    AF_Direction     major_dir, segment_dir;

    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );
d710 7
a716 28
      AF_Point  point   = contour[0];
      AF_Point  last    = point->prev;
      int       on_edge = 0;

      /* we call values measured along a segment (point->v)    */
      /* `coordinates', and values orthogonal to it (point->u) */
      /* `positions'                                           */
      FT_Pos     min_pos      =  32000;
      FT_Pos     max_pos      = -32000;
      FT_Pos     min_coord    =  32000;
      FT_Pos     max_coord    = -32000;
      FT_UShort  min_flags    =  AF_FLAG_NONE;
      FT_UShort  max_flags    =  AF_FLAG_NONE;
      FT_Pos     min_on_coord =  32000;
      FT_Pos     max_on_coord = -32000;

      FT_Bool  passed;

      AF_Segment  prev_segment = NULL;

      FT_Pos     prev_min_pos      = min_pos;
      FT_Pos     prev_max_pos      = max_pos;
      FT_Pos     prev_min_coord    = min_coord;
      FT_Pos     prev_max_coord    = max_coord;
      FT_UShort  prev_min_flags    = min_flags;
      FT_UShort  prev_max_flags    = max_flags;
      FT_Pos     prev_min_on_coord = min_on_coord;
      FT_Pos     prev_max_on_coord = max_on_coord;
d718 2
a749 1
          /* get minimum and maximum position */
a755 23
          /* get minimum and maximum coordinate together with flags */
          v = point->v;
          if ( v < min_coord )
          {
            min_coord = v;
            min_flags = point->flags;
          }
          if ( v > max_coord )
          {
            max_coord = v;
            max_flags = point->flags;
          }

          /* get minimum and maximum coordinate of `on' points */
          if ( !( point->flags & AF_FLAG_CONTROL ) )
          {
            v = point->v;
            if ( v < min_on_coord )
              min_on_coord = v;
            if ( v > max_on_coord )
              max_on_coord = v;
          }

d758 9
a766 94
            /* check whether the new segment's start point is identical to */
            /* the previous segment's end point; for example, this might   */
            /* happen for spikes                                           */

            if ( !prev_segment || segment->first != prev_segment->last )
            {
              /* points are different: we are just leaving an edge, thus */
              /* record a new segment                                    */

              segment->last  = point;
              segment->pos   = (FT_Short)( ( min_pos + max_pos ) >> 1 );
              segment->delta = (FT_Short)( ( max_pos - min_pos ) >> 1 );

              /* a segment is round if either its first or last point */
              /* is a control point, and the length of the on points  */
              /* inbetween doesn't exceed a heuristic limit           */
              if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                   ( max_on_coord - min_on_coord ) < flat_threshold )
                segment->flags |= AF_EDGE_ROUND;

              segment->min_coord = (FT_Short)min_coord;
              segment->max_coord = (FT_Short)max_coord;
              segment->height    = segment->max_coord - segment->min_coord;

              prev_segment      = segment;
              prev_min_pos      = min_pos;
              prev_max_pos      = max_pos;
              prev_min_coord    = min_coord;
              prev_max_coord    = max_coord;
              prev_min_flags    = min_flags;
              prev_max_flags    = max_flags;
              prev_min_on_coord = min_on_coord;
              prev_max_on_coord = max_on_coord;
            }
            else
            {
              /* points are the same: we don't create a new segment but */
              /* merge the current segment with the previous one        */

              if ( prev_segment->last->in_dir == point->in_dir )
              {
                /* we have identical directions (this can happen for       */
                /* degenerate outlines that move zig-zag along the main    */
                /* axis without changing the coordinate value of the other */
                /* axis, and where the segments have just been merged):    */
                /* unify segments                                          */

                /* update constraints */

                if ( prev_min_pos < min_pos )
                  min_pos = prev_min_pos;
                if ( prev_max_pos > max_pos )
                  max_pos = prev_max_pos;

                if ( prev_min_coord < min_coord )
                {
                  min_coord = prev_min_coord;
                  min_flags = prev_min_flags;
                }
                if ( prev_max_coord > max_coord )
                {
                  max_coord = prev_max_coord;
                  max_flags = prev_max_flags;
                }

                if ( prev_min_on_coord < min_on_coord )
                  min_on_coord = prev_min_on_coord;
                if ( prev_max_on_coord > max_on_coord )
                  max_on_coord = prev_max_on_coord;

                prev_segment->last = point;
                prev_segment->pos  = (FT_Short)( ( min_pos +
                                                   max_pos ) >> 1 );

                if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                     ( max_on_coord - min_on_coord ) < flat_threshold )
                  prev_segment->flags |= AF_EDGE_ROUND;
                else
                  prev_segment->flags &= ~AF_EDGE_ROUND;

                prev_segment->min_coord = (FT_Short)min_coord;
                prev_segment->max_coord = (FT_Short)max_coord;
                prev_segment->height    = prev_segment->max_coord -
                                          prev_segment->min_coord;
              }
              else
              {
                /* we have different directions; use the properties of the */
                /* longer segment and discard the other one                */

                if ( FT_ABS( prev_max_coord - prev_min_coord ) >
                     FT_ABS( max_coord - min_coord ) )
                {
                  /* discard current segment */
d768 2
a769 42
                  if ( min_pos < prev_min_pos )
                    prev_min_pos = min_pos;
                  if ( max_pos > prev_max_pos )
                    prev_max_pos = max_pos;

                  prev_segment->last = point;
                  prev_segment->pos  = (FT_Short)( ( prev_min_pos +
                                                     prev_max_pos ) >> 1 );
                }
                else
                {
                  /* discard previous segment */

                  if ( prev_min_pos < min_pos )
                    min_pos = prev_min_pos;
                  if ( prev_max_pos > max_pos )
                    max_pos = prev_max_pos;

                  segment->last = point;
                  segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );

                  if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
                       ( max_on_coord - min_on_coord ) < flat_threshold )
                    segment->flags |= AF_EDGE_ROUND;

                  segment->min_coord = (FT_Short)min_coord;
                  segment->max_coord = (FT_Short)max_coord;
                  segment->height    = segment->max_coord -
                                       segment->min_coord;

                  *prev_segment = *segment;

                  prev_min_pos      = min_pos;
                  prev_max_pos      = max_pos;
                  prev_min_coord    = min_coord;
                  prev_max_coord    = max_coord;
                  prev_min_flags    = min_flags;
                  prev_max_flags    = max_flags;
                  prev_min_on_coord = min_on_coord;
                  prev_max_on_coord = max_on_coord;
                }
              }
d771 10
a780 2
              axis->num_segments--;
            }
d784 1
a784 2

            /* fall through */
d796 1
a796 6
        /* if we are not on an edge, check whether the major direction */
        /* coincides with the current point's `out' direction, or      */
        /* whether we have a single-point contour                      */
        if ( !on_edge                                  &&
             ( FT_ABS( point->out_dir ) == major_dir ||
               point == point->prev                  ) )
d801 1
d806 7
a812 43
          /* clear all segment fields */
          segment[0] = seg0;

          segment->dir   = (FT_Char)segment_dir;
          segment->first = point;
          segment->last  = point;

          /* `af_axis_hints_new_segment' reallocates memory,    */
          /* thus we have to refresh the `prev_segment' pointer */
          if ( prev_segment )
            prev_segment = segment - 1;

          min_pos   = max_pos   = point->u;
          min_coord = max_coord = point->v;
          min_flags = max_flags = point->flags;

          if ( point->flags & AF_FLAG_CONTROL )
          {
            min_on_coord =  32000;
            max_on_coord = -32000;
          }
          else
            min_on_coord = max_on_coord = point->v;

          on_edge = 1;

          if ( point == point->prev )
          {
            /* we have a one-point segment: this is a one-point */
            /* contour with `in' and `out' direction set to     */
            /* AF_DIR_NONE                                      */
            segment->pos = (FT_Short)min_pos;

            if (point->flags & AF_FLAG_CONTROL)
              segment->flags |= AF_EDGE_ROUND;

            segment->min_coord = (FT_Short)point->v;
            segment->max_coord = (FT_Short)point->v;
            segment->height = 0;

            on_edge = 0;
            segment = NULL;
          }
d821 2
a822 2
    /* now slightly increase the height of segments if this makes */
    /* sense -- this is used to better detect and ignore serifs   */
d836 3
a876 3
  /* Link segments to form stems and serifs.  If `width_count' and      */
  /* `widths' are non-zero, use them to fine-tune the scoring function. */

a878 2
                                FT_UInt        width_count,
                                AF_WidthRec*   widths,
d884 1
a884 1
    FT_Pos        len_threshold, len_score, dist_score, max_width;
a887 6
    if ( width_count )
      max_width = widths[width_count - 1].org;
    else
      max_width = 0;

    /* a heuristic value to set up a minimum value for overlapping */
a891 1
    /* a heuristic value to weight lengths */
a893 5
    /* a heuristic value to weight distances (no call to    */
    /* AF_LATIN_CONSTANT needed, since we work on multiples */
    /* of the stem width)                                   */
    dist_score = 3000;

d897 3
a899 1
      if ( seg1->dir != axis->major_dir )
a901 2
      /* search for stems having opposite directions, */
      /* with seg1 to the `left' of seg2              */
d903 1
a903 6
      {
        FT_Pos  pos1 = seg1->pos;
        FT_Pos  pos2 = seg2->pos;


        if ( seg1->dir + seg2->dir == 0 && pos2 > pos1 )
d905 3
a907 4
          /* compute distance between the two segments */
          FT_Pos  min = seg1->min_coord;
          FT_Pos  max = seg1->max_coord;
          FT_Pos  len;
d910 2
a911 5
          if ( min < seg2->min_coord )
            min = seg2->min_coord;

          if ( max > seg2->max_coord )
            max = seg2->max_coord;
a912 4
          /* compute maximum coordinate difference of the two segments */
          /* (this is, how much they overlap)                          */
          len = max - min;
          if ( len >= len_threshold )
d914 3
a916 13
            /*
             *  The score is the sum of two demerits indicating the
             *  `badness' of a fit, measured along the segments' main axis
             *  and orthogonal to it, respectively.
             *
             *  o The less overlapping along the main axis, the worse it
             *    is, causing a larger demerit.
             *
             *  o The nearer the orthogonal distance to a stem width, the
             *    better it is, causing a smaller demerit.  For simplicity,
             *    however, we only increase the demerit for values that
             *    exceed the largest stem width.
             */
a917 1
            FT_Pos  dist = pos2 - pos1;
d919 2
a920 1
            FT_Pos  dist_demerit, score;
d922 2
d925 2
a926 1
            if ( max_width )
d928 1
a928 3
              /* distance demerits are based on multiples of `max_width'; */
              /* we scale by 1024 for getting more precision              */
              FT_Pos  delta = ( dist << 10 ) / max_width - ( 1 << 10 );
d930 5
d936 5
a940 23
              if ( delta > 10000 )
                dist_demerit = 32000;
              else if ( delta > 0 )
                dist_demerit = delta * delta / dist_score;
              else
                dist_demerit = 0;
            }
            else
              dist_demerit = dist; /* default if no widths available */

            score = dist_demerit + len_score / len;

            /* and we search for the smallest score */
            if ( score < seg1->score )
            {
              seg1->score = score;
              seg1->link  = seg2;
            }

            if ( score < seg2->score )
            {
              seg2->score = score;
              seg2->link  = seg1;
a943 1
      }
d946 1
a946 1
    /* now compute the `serif' segments, cf. explanations in `afhints.h' */
a962 2
  /* Link segments to edges, using feature analysis for selection. */

d968 1
a968 1
    FT_Error      error  = FT_Err_Ok;
a971 6
    AF_StyleClass   style_class  = hints->metrics->style_class;
    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                     [style_class->script];

    FT_Bool  top_to_bottom_hinting = 0;

a975 1
#if 0
a976 1
#endif
a979 1
    FT_Pos        segment_width_threshold;
a986 1
#if 0
a988 4
#endif

    if ( dim == AF_DIMENSION_VERT )
      top_to_bottom_hinting = script_class->top_to_bottom_hinting;
d991 1
a991 1
     *  We ignore all segments that are less than 1 pixel in length
d996 1
a996 1
      segment_length_threshold = FT_DivFix( 64, hints->y_scale );
d998 1
a998 7
      segment_length_threshold = 0;

    /*
     *  Similarly, we ignore segments that have a width delta
     *  larger than 0.5px (i.e., a width larger than 1px).
     */
    segment_width_threshold = FT_DivFix( 32, scale );
d1002 3
a1004 3
    /* We begin by generating a sorted table of edges for the current    */
    /* direction.  To do so, we simply scan each segment and try to find */
    /* an edge in our table that corresponds to its position.            */
d1008 1
a1008 1
    /* list which gets processed in the second step to compute the       */
d1011 1
a1011 1
    /* Note that the table of edges is sorted along the segment/edge     */
a1015 1
    /* assure that edge distance threshold is at most 0.25px */
d1026 1
a1026 1
      AF_Edge  found = NULL;
d1030 1
a1030 5
      /* ignore too short segments, too wide ones, and, in this loop, */
      /* one-point segments without a direction                       */
      if ( seg->height < segment_length_threshold ||
           seg->delta > segment_width_threshold   ||
           seg->dir == AF_DIR_NONE                )
a1065 1
                                        top_to_bottom_hinting,
d1075 1
d1077 1
a1077 3
        edge->fpos     = seg->pos;
        edge->opos     = FT_MulFix( seg->pos, scale );
        edge->pos      = edge->opos;
a1089 37
    /* we loop again over all segments to catch one-point segments   */
    /* without a direction: if possible, link them to existing edges */
    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge  found = NULL;
      FT_Int   ee;


      if ( seg->dir != AF_DIR_NONE )
        continue;

      /* look for an edge corresponding to the segment */
      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge  edge = axis->edges + ee;
        FT_Pos   dist;


        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;

        if ( dist < edge_distance_threshold )
        {
          found = edge;
          break;
        }
      }

      /* one-point segments without a match are ignored */
      if ( found )
      {
        seg->edge_next         = found->first;
        found->last->edge_next = seg;
        found->last            = seg;
      }
    }
d1091 11
a1101 12

    /******************************************************************/
    /*                                                                */
    /* Good, we now compute each edge's properties according to the   */
    /* segments found on its position.  Basically, these are          */
    /*                                                                */
    /*  - the edge's main direction                                   */
    /*  - stem edge, serif edge or both (which defaults to stem then) */
    /*  - rounded edge, straight or both (which defaults to straight) */
    /*  - link for edge                                               */
    /*                                                                */
    /******************************************************************/
d1129 1
a1129 1
      /* now compute each edge properties */
a1133 1
#if 0
a1135 1
#endif
a1150 1
#if 0
d1153 1
a1153 1
            ups   += seg->max_coord - seg->min_coord;
d1155 1
a1155 2
            downs += seg->max_coord - seg->min_coord;
#endif
d1163 1
a1163 1
          if ( ( seg->link && seg->link->edge ) || is_serif )
d1231 1
a1231 1
        /* get rid of serifs if link is set                 */
d1236 1
a1236 1
          edge->serif = NULL;
a1244 2
  /* Detect segments and edges for given dimension. */

a1246 2
                                  FT_UInt        width_count,
                                  AF_WidthRec*   widths,
d1255 1
a1255 1
      af_latin_hints_link_segments( hints, width_count, widths, dim );
a1258 1

d1263 1
a1263 3
  /* Compute all edges which lie within blue zones. */

  static void
d1267 1
a1267 1
    AF_AxisHints  axis       = &hints->axis[AF_DIMENSION_VERT];
d1270 1
a1270 1
    AF_LatinAxis  latin      = &metrics->axis[AF_DIMENSION_VERT];
d1280 3
a1282 4
      FT_UInt   bb;
      AF_Width  best_blue            = NULL;
      FT_Bool   best_blue_is_neutral = 0;
      FT_Pos    best_dist;                 /* initial threshold */
a1285 1
      /* (the value 40 is heuristic)                                */
a1287 1
      /* assure a minimum distance of 0.5px */
d1291 1
a1291 1
      for ( bb = 0; bb < latin->blue_count; bb++ )
d1294 1
a1294 1
        FT_Bool       is_top_blue, is_neutral_blue, is_major_dir;
d1297 1
a1297 1
        /* skip inactive blue zones (i.e., those that are too large) */
d1301 11
a1311 14
        /* if it is a top zone, check for right edges (against the major */
        /* direction); if it is a bottom zone, check for left edges (in  */
        /* the major direction) -- this assumes the TrueType convention  */
        /* for the orientation of contours                               */
        is_top_blue =
          (FT_Byte)( ( blue->flags & ( AF_LATIN_BLUE_TOP     |
                                       AF_LATIN_BLUE_SUB_TOP ) ) != 0 );
        is_neutral_blue =
          (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_NEUTRAL ) != 0);
        is_major_dir =
          FT_BOOL( edge->dir == axis->major_dir );

        /* neutral blue zones are handled for both directions */
        if ( is_top_blue ^ is_major_dir || is_neutral_blue )
d1324 2
a1325 3
            best_dist            = dist;
            best_blue            = &blue->ref;
            best_blue_is_neutral = is_neutral_blue;
d1328 4
a1331 8
          /* now compare it to the overshoot position and check whether */
          /* the edge is rounded, and whether the edge is over the      */
          /* reference position of a top zone, or under the reference   */
          /* position of a bottom zone (provided we don't have a        */
          /* neutral blue zone)                                         */
          if ( edge->flags & AF_EDGE_ROUND &&
               dist != 0                   &&
               !is_neutral_blue            )
d1338 1
d1346 2
a1347 3
                best_dist            = dist;
                best_blue            = &blue->shoot;
                best_blue_is_neutral = is_neutral_blue;
a1354 1
      {
a1355 3
        if ( best_blue_is_neutral )
          edge->flags |= AF_EDGE_NEUTRAL;
      }
a1359 2
  /* Initalize hinting engine. */

d1369 1
a1369 1
    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
d1373 1
a1373 1
     *  been modified by `af_latin_metrics_scale_dim' above
d1383 1
a1383 1
#if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
d1385 1
d1387 1
a1418 3
     *
     *  However, if warping is enabled (which only works in `light' hinting
     *  mode), advance widths get adjusted, too.
d1420 2
a1421 2
    if ( mode == FT_RENDER_MODE_LIGHT                      ||
         ( face->style_flags & FT_STYLE_FLAG_ITALIC ) != 0 )
a1423 6
#ifdef AF_CONFIG_OPTION_USE_WARPER
    /* get (global) warper flag */
    if ( !metrics->root.globals->module->warping )
      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
#endif

d1427 1
a1427 1
    return FT_Err_Ok;
d1439 2
a1440 2
  /* Snap a given width in scaled coordinates to one of the */
  /* current standard widths.                               */
d1444 1
a1444 1
                       FT_UInt   count,
d1447 4
a1450 4
    FT_UInt  n;
    FT_Pos   best      = 64 + 32 + 2;
    FT_Pos   reference = width;
    FT_Pos   scaled;
d1487 1
a1487 3
  /* Compute the snapped width of a given stem, ignoring very thin ones. */
  /* There is a lot of voodoo in this function; changing the hard-coded  */
  /* parameters influence the whole hinting process.                     */
d1493 2
a1494 3
                               FT_Pos         base_delta,
                               FT_UInt        base_flags,
                               FT_UInt        stem_flags )
d1496 2
a1497 2
    AF_LatinMetrics  metrics  = (AF_LatinMetrics)hints->metrics;
    AF_LatinAxis     axis     = &metrics->axis[dim];
d1504 1
a1504 1
         axis->extra_light                       )
d1519 2
a1520 3
      if ( ( stem_flags & AF_EDGE_SERIF ) &&
           vertical                       &&
           ( dist < 3 * 64 )              )
d1523 1
a1523 1
      else if ( base_flags & AF_EDGE_ROUND )
d1537 3
a1539 1
        delta = dist - axis->widths[0].cur;
d1541 2
a1542 2
        if ( delta < 0 )
          delta = -delta;
d1544 5
a1548 5
        if ( delta < 40 )
        {
          dist = axis->widths[0].cur;
          if ( dist < 48 )
            dist = 48;
d1550 2
a1551 1
          goto Done_Width;
d1572 1
a1572 33
        {
          /* A stem's end position depends on two values: the start        */
          /* position and the stem length.  The former gets usually        */
          /* rounded to the grid, while the latter gets rounded also if it */
          /* exceeds a certain length (see below in this function).  This  */
          /* `double rounding' can lead to a great difference to the       */
          /* original, unhinted position; this normally doesn't matter for */
          /* large PPEM values, but for small sizes it can easily make     */
          /* outlines collide.  For this reason, we adjust the stem length */
          /* by a small amount depending on the PPEM value in case the     */
          /* former and latter rounding both point into the same           */
          /* direction.                                                    */

          FT_Pos  bdelta = 0;


          if ( ( ( width > 0 ) && ( base_delta > 0 ) ) ||
               ( ( width < 0 ) && ( base_delta < 0 ) ) )
          {
            FT_UInt  ppem = metrics->root.scaler.face->size->metrics.x_ppem;


            if ( ppem < 10 )
              bdelta = base_delta;
            else if ( ppem < 30 )
              bdelta = ( base_delta * (FT_Pos)( 30 - ppem ) ) / 20;

            if ( bdelta < 0 )
              bdelta = -bdelta;
          }

          dist = ( dist - bdelta + 32 ) & ~63;
        }
a1577 1

d1630 1
a1630 1
            if ( delta >= 16 )
d1652 1
a1652 1
  /* Align one stem edge relative to the previous stem edge. */
d1660 1
a1660 2
    FT_Pos  dist, base_delta;
    FT_Pos  fitted_width;
d1662 4
a1665 8

    dist       = stem_edge->opos - base_edge->opos;
    base_delta = base_edge->pos - base_edge->opos;

    fitted_width = af_latin_compute_stem_width( hints, dim,
                                                dist, base_delta,
                                                base_edge->flags,
                                                stem_edge->flags );
d1670 4
a1673 4
    FT_TRACE5(( "  LINK: edge %d (opos=%.2f) linked to %.2f,"
                " dist was %.2f, now %.2f\n",
                stem_edge - hints->axis[dim].edges, stem_edge->opos / 64.0,
                stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
a1676 3
  /* Shift the coordinates of the `serif' edge by the same amount */
  /* as the corresponding `base' edge has been moved already.     */

d1684 1
a1684 1
    serif->pos = base->pos + ( serif->opos - base->opos );
d1699 1
a1699 3
  /* The main grid-fitting routine. */

  static void
d1708 1
a1708 1
    AF_Edge       anchor     = NULL;
a1710 17
    AF_StyleClass   style_class  = hints->metrics->style_class;
    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
                                     [style_class->script];

    FT_Bool  top_to_bottom_hinting = 0;

#ifdef FT_DEBUG_LEVEL_TRACE
    FT_UInt  num_actions = 0;
#endif


    FT_TRACE5(( "latin %s edge hinting (style `%s')\n",
                dim == AF_DIMENSION_VERT ? "horizontal" : "vertical",
                af_style_names[hints->metrics->style_class->style] ));

    if ( dim == AF_DIMENSION_VERT )
      top_to_bottom_hinting = script_class->top_to_bottom_hinting;
d1720 1
a1720 1
        AF_Edge   edge1, edge2; /* these edges form the stem to check */
d1726 1
d1730 1
a1730 10
        /*
         *  If a stem contains both a neutral and a non-neutral blue zone,
         *  skip the neutral one.  Otherwise, outlines with different
         *  directions might be incorrectly aligned at the same vertical
         *  position.
         *
         *  If we have two neutral blue zones, skip one of them.
         *
         */
        if ( edge->blue_edge && edge2 && edge2->blue_edge )
d1732 1
a1732 14
          FT_Byte  neutral  = edge->flags  & AF_EDGE_NEUTRAL;
          FT_Byte  neutral2 = edge2->flags & AF_EDGE_NEUTRAL;


          if ( neutral2 )
          {
            edge2->blue_edge = NULL;
            edge2->flags    &= ~AF_EDGE_NEUTRAL;
          }
          else if ( neutral )
          {
            edge->blue_edge = NULL;
            edge->flags    &= ~AF_EDGE_NEUTRAL;
          }
a1733 6

        blue = edge->blue_edge;
        if ( blue )
          edge1 = edge;

        /* flip edges if the other edge is aligned to a blue zone */
d1744 4
a1747 14
#ifdef FT_DEBUG_LEVEL_TRACE
        if ( !anchor )
          FT_TRACE5(( "  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,"
                      " was %.2f (anchor=edge %d)\n",
                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
                      edge1->pos / 64.0, edge - edges ));
        else
          FT_TRACE5(( "  BLUE: edge %d (opos=%.2f) snapped to %.2f,"
                      " was %.2f\n",
                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
                      edge1->pos / 64.0 ));

        num_actions++;
#endif
a1755 4

#ifdef FT_DEBUG_LEVEL_TRACE
          num_actions++;
#endif
d1763 2
a1764 2
    /* now we align all other stem edges, trying to maintain the */
    /* relative order of stems in the glyph                      */
d1786 1
a1786 1
        FT_TRACE5(( "  ASSERTION FAILED for edge %d\n", edge2 - edges ));
a1789 4

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif
a1794 2
        /* if we reach this if clause, no stem has been aligned yet */

d1800 4
a1803 8
        cur_len = af_latin_compute_stem_width( hints, dim,
                                               org_len, 0,
                                               edge->flags,
                                               edge2->flags );

        /* some voodoo to specially round edges for small stem widths; */
        /* the idea is to align the center of a stem, then shifting    */
        /* the stem edges to suitable positions                        */
d1805 1
a1805 5
        {
          /* width <= 1px */
          u_off = 32;
          d_off = 32;
        }
a1807 1
          /* 1px < width < 1.5px */
d1815 1
d1837 7
a1843 1
        anchor       = edge;
a1845 6
        FT_TRACE5(( "  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)"
                    " snapped to %.2f and %.2f\n",
                    edge - edges, edge->opos / 64.0,
                    edge2 - edges, edge2->opos / 64.0,
                    edge->pos / 64.0, edge2->pos / 64.0 ));

a1846 4

#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions += 2;
#endif
d1858 4
a1861 4
        cur_len = af_latin_compute_stem_width( hints, dim,
                                               org_len, 0,
                                               edge->flags,
                                               edge2->flags );
a1863 5
        {
          FT_TRACE5(( "  ADJUST: edge %d (pos=%.2f) moved to %.2f\n",
                      edge - edges, edge->pos / 64.0,
                      ( edge2->pos - cur_len ) / 64.0 ));

a1864 1
        }
d1873 2
a1874 5
          if ( cur_len <= 64 )
          {
            u_off = 32;
            d_off = 32;
          }
d1897 5
a1901 5
          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
                      " snapped to %.2f and %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge2 - edges, edge2->opos / 64.0,
                      edge->pos / 64.0, edge2->pos / 64.0 ));
a1902 1

d1909 4
a1912 4
          cur_len    = af_latin_compute_stem_width( hints, dim,
                                                    org_len, 0,
                                                    edge->flags,
                                                    edge2->flags );
d1914 2
a1915 2
          cur_pos1 = FT_PIX_ROUND( org_pos );
          delta1   = cur_pos1 + ( cur_len >> 1 ) - org_center;
d1919 2
a1920 2
          cur_pos2 = FT_PIX_ROUND( org_pos + org_len ) - cur_len;
          delta2   = cur_pos2 + ( cur_len >> 1 ) - org_center;
d1927 5
a1931 5
          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
                      " snapped to %.2f and %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge2 - edges, edge2->opos / 64.0,
                      edge->pos / 64.0, edge2->pos / 64.0 ));
a1933 4
#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif

d1937 5
a1941 19
        if ( edge > edges                                             &&
             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                     : ( edge->pos < edge[-1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[-1].pos / 64.0 ));

            num_actions++;
#endif

            edge->pos = edge[-1].pos;
          }
d2034 5
a2038 5
          FT_TRACE5(( "  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)"
                      " aligned to %.2f\n",
                      edge - edges, edge->opos / 64.0,
                      edge->serif - edges, edge->serif->opos / 64.0,
                      edge->pos / 64.0 ));
d2042 2
a2045 3
          FT_TRACE5(( "  SERIF_ANCHOR: edge %d (opos=%.2f)"
                      " snapped to %.2f\n",
                      edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
d2070 5
a2074 6

            FT_TRACE5(( "  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f"
                        " from %d (opos=%.2f)\n",
                        edge - edges, edge->opos / 64.0,
                        edge->pos / 64.0,
                        before - edges, before->opos / 64.0 ));
d2080 2
a2081 3
            FT_TRACE5(( "  SERIF_LINK2: edge %d (opos=%.2f)"
                        " snapped to %.2f\n",
                        edge - edges, edge->opos / 64.0, edge->pos / 64.0 ));
a2084 3
#ifdef FT_DEBUG_LEVEL_TRACE
        num_actions++;
#endif
d2087 2
a2088 37
        if ( edge > edges                                             &&
             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                     : ( edge->pos < edge[-1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[-1].pos / 64.0 ));

            num_actions++;
#endif
            edge->pos = edge[-1].pos;
          }
        }

        if ( edge + 1 < edge_limit                                   &&
             edge[1].flags & AF_EDGE_DONE                            &&
             ( top_to_bottom_hinting ? ( edge->pos < edge[1].pos )
                                     : ( edge->pos > edge[1].pos ) ) )
        {
          /* don't move if stem would (almost) disappear otherwise; */
          /* the ad-hoc value 16 corresponds to 1/4px               */
          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
          {
#ifdef FT_DEBUG_LEVEL_TRACE
            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
                        edge - edges,
                        edge->pos / 64.0,
                        edge[1].pos / 64.0 ));

            num_actions++;
#endif
d2090 4
a2093 3
            edge->pos = edge[1].pos;
          }
        }
a2095 6

#ifdef FT_DEBUG_LEVEL_TRACE
    if ( !num_actions )
      FT_TRACE5(( "  (none)\n" ));
    FT_TRACE5(( "\n" ));
#endif
a2098 2
  /* Apply the complete hinting algorithm to a latin glyph. */

d2100 1
a2100 2
  af_latin_hints_apply( FT_UInt          glyph_index,
                        AF_GlyphHints    hints,
a2106 2
    AF_LatinAxis  axis;

d2108 1
a2108 1
    error = af_glyph_hints_reload( hints, outline );
d2113 3
a2115 4
#ifdef AF_CONFIG_OPTION_USE_WARPER
    if ( ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
           AF_HINTS_DO_WARP( hints )                                ) ||
         AF_HINTS_DO_HORIZONTAL( hints )                              )
d2120 1
a2120 5
      axis  = &metrics->axis[AF_DIMENSION_HORZ];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_HORZ );
d2127 1
a2127 5
      axis  = &metrics->axis[AF_DIMENSION_VERT];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_VERT );
d2131 1
a2131 3
      /* apply blue zones to base characters only */
      if ( !( metrics->root.globals->glyph_styles[glyph_index] & AF_NONBASE ) )
        af_latin_hints_compute_blue_edges( hints, metrics );
d2137 3
a2139 4
#ifdef AF_CONFIG_OPTION_USE_WARPER
      if ( dim == AF_DIMENSION_HORZ                                 &&
           metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
           AF_HINTS_DO_WARP( hints )                                )
d2146 2
a2147 4
        af_warper_compute( &warper, hints, (AF_Dimension)dim,
                           &scale, &delta );
        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,
                                  scale, delta );
d2150 1
a2150 1
#endif /* AF_CONFIG_OPTION_USE_WARPER */
a2160 1

d2177 2
a2178 2
  AF_DEFINE_WRITING_SYSTEM_CLASS(
    af_latin_writing_system_class,
d2180 41
a2220 8
    AF_WRITING_SYSTEM_LATIN,

    sizeof ( AF_LatinMetricsRec ),

    (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init,        /* style_metrics_init    */
    (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale,       /* style_metrics_scale   */
    (AF_WritingSystem_DoneMetricsFunc) NULL,                         /* style_metrics_done    */
    (AF_WritingSystem_GetStdWidthsFunc)af_latin_get_standard_widths, /* style_metrics_getstdw */
d2222 2
a2223 2
    (AF_WritingSystem_InitHintsFunc)   af_latin_hints_init,          /* style_hints_init      */
    (AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply          /* style_hints_apply     */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
