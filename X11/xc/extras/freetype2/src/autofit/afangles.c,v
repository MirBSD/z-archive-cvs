head	1.4;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.4
date	2017.04.15.19.21.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	10058F2723111C7BEE2;

1.3
date	2008.02.26.20.04.49;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.35;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.50;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.52;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.42;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.01;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.4
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  afangles.c                                                             */
/*                                                                         */
/*    Routines used to compute vector angles with limited accuracy         */
/*    and very high speed.  It also contains sorting routines (body).      */
/*                                                                         */
/*  Copyright 2003-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include "aftypes.h"


  /*
   *  We are not using `af_angle_atan' anymore, but we keep the source
   *  code below just in case...
   */


#if 0


  /*
   *  The trick here is to realize that we don't need a very accurate angle
   *  approximation.  We are going to use the result of `af_angle_atan' to
   *  only compare the sign of angle differences, or check whether its
   *  magnitude is very small.
   *
   *  The approximation
   *
   *    dy * PI / (|dx|+|dy|)
   *
   *  should be enough, and much faster to compute.
   */
  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
  {
    AF_Angle  angle;
    FT_Fixed  ax = dx;
    FT_Fixed  ay = dy;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;

    ax += ay;

    if ( ax == 0 )
      angle = 0;
    else
    {
      angle = ( AF_ANGLE_PI2 * dy ) / ( ax + ay );
      if ( dx < 0 )
      {
        if ( angle >= 0 )
          angle = AF_ANGLE_PI - angle;
        else
          angle = -AF_ANGLE_PI - angle;
      }
    }

    return angle;
  }


#elif 0


  /* the following table has been automatically generated with */
  /* the `mather.py' Python script                             */

#define AF_ATAN_BITS  8

  static const FT_Byte  af_arctan[1L << AF_ATAN_BITS] =
  {
     0,  0,  1,  1,  1,  2,  2,  2,
     3,  3,  3,  3,  4,  4,  4,  5,
     5,  5,  6,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9,  9, 10, 10,
    10, 10, 11, 11, 11, 12, 12, 12,
    13, 13, 13, 14, 14, 14, 14, 15,
    15, 15, 16, 16, 16, 17, 17, 17,
    18, 18, 18, 18, 19, 19, 19, 20,
    20, 20, 21, 21, 21, 21, 22, 22,
    22, 23, 23, 23, 24, 24, 24, 24,
    25, 25, 25, 26, 26, 26, 26, 27,
    27, 27, 28, 28, 28, 28, 29, 29,
    29, 30, 30, 30, 30, 31, 31, 31,
    31, 32, 32, 32, 33, 33, 33, 33,
    34, 34, 34, 34, 35, 35, 35, 35,
    36, 36, 36, 36, 37, 37, 37, 38,
    38, 38, 38, 39, 39, 39, 39, 40,
    40, 40, 40, 41, 41, 41, 41, 42,
    42, 42, 42, 42, 43, 43, 43, 43,
    44, 44, 44, 44, 45, 45, 45, 45,
    46, 46, 46, 46, 46, 47, 47, 47,
    47, 48, 48, 48, 48, 48, 49, 49,
    49, 49, 50, 50, 50, 50, 50, 51,
    51, 51, 51, 51, 52, 52, 52, 52,
    52, 53, 53, 53, 53, 53, 54, 54,
    54, 54, 54, 55, 55, 55, 55, 55,
    56, 56, 56, 56, 56, 57, 57, 57,
    57, 57, 57, 58, 58, 58, 58, 58,
    59, 59, 59, 59, 59, 59, 60, 60,
    60, 60, 60, 61, 61, 61, 61, 61,
    61, 62, 62, 62, 62, 62, 62, 63,
    63, 63, 63, 63, 63, 64, 64, 64
  };


  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
  {
    AF_Angle  angle;


    /* check trivial cases */
    if ( dy == 0 )
    {
      angle = 0;
      if ( dx < 0 )
        angle = AF_ANGLE_PI;
      return angle;
    }
    else if ( dx == 0 )
    {
      angle = AF_ANGLE_PI2;
      if ( dy < 0 )
        angle = -AF_ANGLE_PI2;
      return angle;
    }

    angle = 0;
    if ( dx < 0 )
    {
      dx = -dx;
      dy = -dy;
      angle = AF_ANGLE_PI;
    }

    if ( dy < 0 )
    {
      FT_Pos  tmp;


      tmp = dx;
      dx  = -dy;
      dy  = tmp;
      angle -= AF_ANGLE_PI2;
    }

    if ( dx == 0 && dy == 0 )
      return 0;

    if ( dx == dy )
      angle += AF_ANGLE_PI4;
    else if ( dx > dy )
      angle += af_arctan[FT_DivFix( dy, dx ) >> ( 16 - AF_ATAN_BITS )];
    else
      angle += AF_ANGLE_PI2 -
               af_arctan[FT_DivFix( dx, dy ) >> ( 16 - AF_ATAN_BITS )];

    if ( angle > AF_ANGLE_PI )
      angle -= AF_ANGLE_2PI;

    return angle;
  }


#endif /* 0 */


  FT_LOCAL_DEF( void )
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table )
  {
    FT_UInt  i, j;
    FT_Pos   swap;


    for ( i = 1; i < count; i++ )
    {
      for ( j = i; j > 0; j-- )
      {
        if ( table[j] >= table[j - 1] )
          break;

        swap         = table[j];
        table[j]     = table[j - 1];
        table[j - 1] = swap;
      }
    }
  }


  FT_LOCAL_DEF( void )
  af_sort_and_quantize_widths( FT_UInt*  count,
                               AF_Width  table,
                               FT_Pos    threshold )
  {
    FT_UInt      i, j;
    FT_UInt      cur_idx;
    FT_Pos       cur_val;
    FT_Pos       sum;
    AF_WidthRec  swap;


    if ( *count == 1 )
      return;

    /* sort */
    for ( i = 1; i < *count; i++ )
    {
      for ( j = i; j > 0; j-- )
      {
        if ( table[j].org >= table[j - 1].org )
          break;

        swap         = table[j];
        table[j]     = table[j - 1];
        table[j - 1] = swap;
      }
    }

    cur_idx = 0;
    cur_val = table[cur_idx].org;

    /* compute and use mean values for clusters not larger than  */
    /* `threshold'; this is very primitive and might not yield   */
    /* the best result, but normally, using reference character  */
    /* `o', `*count' is 2, so the code below is fully sufficient */
    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org - cur_val > threshold ||
           i == *count - 1                    )
      {
        sum = 0;

        /* fix loop for end of array */
        if ( table[i].org - cur_val <= threshold &&
             i == *count - 1                     )
          i++;

        for ( j = cur_idx; j < i; j++ )
        {
          sum         += table[j].org;
          table[j].org = 0;
        }
        table[cur_idx].org = sum / (FT_Pos)j;

        if ( i < *count - 1 )
        {
          cur_idx = i + 1;
          cur_val = table[cur_idx].org;
        }
      }
    }

    cur_idx = 1;

    /* compress array to remove zero values */
    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org )
        table[cur_idx++] = table[i];
    }

    *count = cur_idx;
  }


/* END */
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d8 1
a8 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
a22 60
#if 0

  FT_LOCAL_DEF( FT_Int )
  af_corner_is_flat( FT_Pos  x_in,
                     FT_Pos  y_in,
                     FT_Pos  x_out,
                     FT_Pos  y_out )
  {
    FT_Pos  ax = x_in;
    FT_Pos  ay = y_in;

    FT_Pos  d_in, d_out, d_corner;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = x_out;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = x_out + x_in;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out + y_in;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;

    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
  }


  FT_LOCAL_DEF( FT_Int )
  af_corner_orientation( FT_Pos  x_in,
                         FT_Pos  y_in,
                         FT_Pos  x_out,
                         FT_Pos  y_out )
  {
    FT_Pos  delta;


    delta = x_in * y_out - y_in * x_out;

    if ( delta == 0 )
      return 0;
    else
      return 1 - 2 * ( delta < 0 );
  }

#endif


d198 1
a198 1
        if ( table[j] > table[j - 1] )
d210 3
a212 2
  af_sort_widths( FT_UInt   count,
                  AF_Width  table )
d215 3
d221 5
a225 1
    for ( i = 1; i < count; i++ )
d229 1
a229 1
        if ( table[j].org > table[j - 1].org )
d237 45
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d8 1
a8 1
/*  Copyright 2003, 2004, 2005 by                                          */
d23 117
a139 1
#if 1
a242 216
#else /* 0 */

/*
 * a python script used to generate the following table
 *

import sys, math

units = 256
scale = units/math.pi
comma = ""

print ""
print "table of arctan( 1/2^n ) for PI = " + repr( units / 65536.0 ) + " units"

r = [-1] + range( 32 )

for n in r:
    if n >= 0:
        x = 1.0 / ( 2.0 ** n )   # tangent value
    else:
        x = 2.0 ** ( -n )

    angle  = math.atan( x )      # arctangent
    angle2 = angle * scale       # arctangent in FT_Angle units

    # determine which integer value for angle gives the best tangent
    lo  = int( angle2 )
    hi  = lo + 1
    tlo = math.tan( lo / scale )
    thi = math.tan( hi / scale )

    errlo = abs( tlo - x )
    errhi = abs( thi - x )

    angle2 = hi
    if errlo < errhi:
        angle2 = lo

    if angle2 <= 0:
        break

    sys.stdout.write( comma + repr( int( angle2 ) ) )
    comma = ", "

*
* end of python script
*/


  /* this table was generated for AF_ANGLE_PI = 256 */
#define AF_ANGLE_MAX_ITERS  8
#define AF_TRIG_MAX_ITERS   8

  static const FT_Fixed
  af_angle_arctan_table[9] =
  {
    90, 64, 38, 20, 10, 5, 3, 1, 1
  };


  static FT_Int
  af_angle_prenorm( FT_Vector*  vec )
  {
    FT_Fixed  x, y, z;
    FT_Int    shift;


    x = vec->x;
    y = vec->y;

    z     = ( ( x >= 0 ) ? x : - x ) | ( (y >= 0) ? y : -y );
    shift = 0;

    if ( z < ( 1L << 27 ) )
    {
      do
      {
        shift++;
        z <<= 1;
      } while ( z < ( 1L << 27 ) );

      vec->x = x << shift;
      vec->y = y << shift;
    }
    else if ( z > ( 1L << 28 ) )
    {
      do
      {
        shift++;
        z >>= 1;
      } while ( z > ( 1L << 28 ) );

      vec->x = x >> shift;
      vec->y = y >> shift;
      shift  = -shift;
    }
    return shift;
  }


  static void
  af_angle_pseudo_polarize( FT_Vector*  vec )
  {
    FT_Fixed         theta;
    FT_Fixed         yi, i;
    FT_Fixed         x, y;
    const FT_Fixed  *arctanptr;


    x = vec->x;
    y = vec->y;

    /* Get the vector into the right half plane */
    theta = 0;
    if ( x < 0 )
    {
      x = -x;
      y = -y;
      theta = AF_ANGLE_PI;
    }

    if ( y > 0 )
      theta = -theta;

    arctanptr = af_angle_arctan_table;

    if ( y < 0 )
    {
      /* Rotate positive */
      yi     = y + ( x << 1 );
      x      = x - ( y << 1 );
      y      = yi;
      theta -= *arctanptr++;  /* Subtract angle */
    }
    else
    {
      /* Rotate negative */
      yi     = y - ( x << 1 );
      x      = x + ( y << 1 );
      y      = yi;
      theta += *arctanptr++;  /* Add angle */
    }

    i = 0;
    do
    {
      if ( y < 0 )
      {
        /* Rotate positive */
        yi     = y + ( x >> i );
        x      = x - ( y >> i );
        y      = yi;
        theta -= *arctanptr++;
      }
      else
      {
        /* Rotate negative */
        yi     = y - ( x >> i );
        x      = x + ( y >> i );
        y      = yi;
        theta += *arctanptr++;
      }
    } while ( ++i < AF_TRIG_MAX_ITERS );

#if 0
    /* round theta */
    if ( theta >= 0 )
      theta =  FT_PAD_ROUND( theta, 2 );
    else
      theta = -FT_PAD_ROUND( -theta, 2 );
#endif

    vec->x = x;
    vec->y = theta;
  }


  /* cf. documentation in fttrigon.h */

  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
  {
    FT_Vector  v;


    if ( dx == 0 && dy == 0 )
      return 0;

    v.x = dx;
    v.y = dy;
    af_angle_prenorm( &v );
    af_angle_pseudo_polarize( &v );

    return v.y;
  }


  FT_LOCAL_DEF( AF_Angle )
  af_angle_diff( AF_Angle  angle1,
                 AF_Angle  angle2 )
  {
    AF_Angle  delta = angle2 - angle1;


    delta %= AF_ANGLE_2PI;
    if ( delta < 0 )
      delta += AF_ANGLE_2PI;

    if ( delta > AF_ANGLE_PI )
      delta -= AF_ANGLE_2PI;

    return delta;
  }

a291 41
#ifdef TEST

#include <stdio.h>
#include <math.h>

int main( void )
{
  int  angle;
  int  dist;


  for ( dist = 100; dist < 1000; dist++ )
  {
    for ( angle = AF_ANGLE_PI; angle < AF_ANGLE_2PI * 4; angle++ )
    {
      double  a = ( angle * 3.1415926535 ) / ( 1.0 * AF_ANGLE_PI );
      int     dx, dy, angle1, angle2, delta;


      dx = dist * cos( a );
      dy = dist * sin( a );

      angle1 = ( ( atan2( dy, dx ) * AF_ANGLE_PI ) / 3.1415926535 );
      angle2 = af_angle_atan( dx, dy );
      delta  = ( angle2 - angle1 ) % AF_ANGLE_2PI;
      if ( delta < 0 )
        delta = -delta;

      if ( delta >= 2 )
      {
        printf( "dist:%4d angle:%4d => (%4d,%4d) angle1:%4d angle2:%4d\n",
                dist, angle, dx, dy, angle1, angle2 );
      }
    }
  }
  return 0;
}

#endif /* TEST */


@


1.1
log
@Initial revision
@
text
@d1 19
d22 155
d179 1
a179 1
#define AF_TRIG_MAX_ITERS   9
d246 1
a246 1
      theta = 2 * AF_ANGLE_PI2;
d250 1
a250 1
      theta = - theta;
d292 1
d295 1
a295 1
      theta = FT_PAD_ROUND( theta, 4 );
d297 2
a298 1
      theta = - FT_PAD_ROUND( theta, 4 );
d305 1
a305 1
  /* documentation is in fttrigon.h */
a325 1

d332 1
d343 1
a344 2
 /* well, this needs to be somewhere, right :-)
  */
d347 2
a348 2
  af_sort_pos( FT_UInt   count,
               FT_Pos*   table )
d390 44
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@a0 19
/***************************************************************************/
/*                                                                         */
/*  afangles.c                                                             */
/*                                                                         */
/*    Routines used to compute vector angles with limited accuracy         */
/*    and very high speed.  It also contains sorting routines (body).      */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


d3 3
d7 2
a8 7
#if 0

  FT_LOCAL_DEF( FT_Int )
  af_corner_is_flat( FT_Pos  x_in,
                     FT_Pos  y_in,
                     FT_Pos  x_out,
                     FT_Pos  y_out )
d10 2
a11 2
    FT_Pos  ax = x_in;
    FT_Pos  ay = y_in;
a12 1
    FT_Pos  d_in, d_out, d_corner;
d14 5
a19 21
    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = x_out;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = x_out + x_in;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out + y_in;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;
d21 2
a22 2
    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
  }
d24 2
d27 7
a33 7
  FT_LOCAL_DEF( FT_Int )
  af_corner_orientation( FT_Pos  x_in,
                         FT_Pos  y_in,
                         FT_Pos  x_out,
                         FT_Pos  y_out )
  {
    FT_Pos  delta;
d35 10
d46 5
a50 6
    delta = x_in * y_out - y_in * x_out;

    if ( delta == 0 )
      return 0;
    else
      return 1 - 2 * ( delta < 0 );
a52 2
#endif

d54 2
a55 24
  /*
   *  We are not using `af_angle_atan' anymore, but we keep the source
   *  code below just in case...
   */


#if 0


  /*
   *  The trick here is to realize that we don't need a very accurate angle
   *  approximation.  We are going to use the result of `af_angle_atan' to
   *  only compare the sign of angle differences, or check whether its
   *  magnitude is very small.
   *
   *  The approximation
   *
   *    dy * PI / (|dx|+|dy|)
   *
   *  should be enough, and much faster to compute.
   */
  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
d57 4
a60 4
    AF_Angle  angle;
    FT_Fixed  ax = dx;
    FT_Fixed  ay = dy;

a61 4
    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
d63 2
a64 1
    ax += ay;
d66 3
a68 3
    if ( ax == 0 )
      angle = 0;
    else
d70 3
a72 8
      angle = ( AF_ANGLE_PI2 * dy ) / ( ax + ay );
      if ( dx < 0 )
      {
        if ( angle >= 0 )
          angle = AF_ANGLE_PI - angle;
        else
          angle = -AF_ANGLE_PI - angle;
      }
d75 2
a76 2
    return angle;
  }
d78 1
d80 16
a95 1
#elif 0
d97 20
d118 5
a122 2
  /* the following table has been automatically generated with */
  /* the `mather.py' Python script                             */
d124 3
a126 1
#define AF_ATAN_BITS  8
a127 35
  static const FT_Byte  af_arctan[1L << AF_ATAN_BITS] =
  {
     0,  0,  1,  1,  1,  2,  2,  2,
     3,  3,  3,  3,  4,  4,  4,  5,
     5,  5,  6,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9,  9, 10, 10,
    10, 10, 11, 11, 11, 12, 12, 12,
    13, 13, 13, 14, 14, 14, 14, 15,
    15, 15, 16, 16, 16, 17, 17, 17,
    18, 18, 18, 18, 19, 19, 19, 20,
    20, 20, 21, 21, 21, 21, 22, 22,
    22, 23, 23, 23, 24, 24, 24, 24,
    25, 25, 25, 26, 26, 26, 26, 27,
    27, 27, 28, 28, 28, 28, 29, 29,
    29, 30, 30, 30, 30, 31, 31, 31,
    31, 32, 32, 32, 33, 33, 33, 33,
    34, 34, 34, 34, 35, 35, 35, 35,
    36, 36, 36, 36, 37, 37, 37, 38,
    38, 38, 38, 39, 39, 39, 39, 40,
    40, 40, 40, 41, 41, 41, 41, 42,
    42, 42, 42, 42, 43, 43, 43, 43,
    44, 44, 44, 44, 45, 45, 45, 45,
    46, 46, 46, 46, 46, 47, 47, 47,
    47, 48, 48, 48, 48, 48, 49, 49,
    49, 49, 50, 50, 50, 50, 50, 51,
    51, 51, 51, 51, 52, 52, 52, 52,
    52, 53, 53, 53, 53, 53, 54, 54,
    54, 54, 54, 55, 55, 55, 55, 55,
    56, 56, 56, 56, 56, 57, 57, 57,
    57, 57, 57, 58, 58, 58, 58, 58,
    59, 59, 59, 59, 59, 59, 60, 60,
    60, 60, 60, 61, 61, 61, 61, 61,
    61, 62, 62, 62, 62, 62, 62, 63,
    63, 63, 63, 63, 63, 64, 64, 64
  };
d129 1
d135 1
a135 1
    AF_Angle  angle;
d138 2
a139 15
    /* check trivial cases */
    if ( dy == 0 )
    {
      angle = 0;
      if ( dx < 0 )
        angle = AF_ANGLE_PI;
      return angle;
    }
    else if ( dx == 0 )
    {
      angle = AF_ANGLE_PI2;
      if ( dy < 0 )
        angle = -AF_ANGLE_PI2;
      return angle;
    }
d141 4
a144 7
    angle = 0;
    if ( dx < 0 )
    {
      dx = -dx;
      dy = -dy;
      angle = AF_ANGLE_PI;
    }
d146 2
a147 3
    if ( dy < 0 )
    {
      FT_Pos  tmp;
a149 5
      tmp = dx;
      dx  = -dy;
      dy  = tmp;
      angle -= AF_ANGLE_PI2;
    }
d151 5
a155 2
    if ( dx == 0 && dy == 0 )
      return 0;
d157 3
a159 7
    if ( dx == dy )
      angle += AF_ANGLE_PI4;
    else if ( dx > dy )
      angle += af_arctan[FT_DivFix( dy, dx ) >> ( 16 - AF_ATAN_BITS )];
    else
      angle += AF_ANGLE_PI2 -
               af_arctan[FT_DivFix( dx, dy ) >> ( 16 - AF_ATAN_BITS )];
d161 2
a162 2
    if ( angle > AF_ANGLE_PI )
      angle -= AF_ANGLE_2PI;
d164 1
a164 1
    return angle;
d168 2
a169 2
#endif /* 0 */

d172 2
a173 2
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table )
a214 3


/* END */
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@a0 19
/***************************************************************************/
/*                                                                         */
/*  afangles.c                                                             */
/*                                                                         */
/*    Routines used to compute vector angles with limited accuracy         */
/*    and very high speed.  It also contains sorting routines (body).      */
/*                                                                         */
/*  Copyright 2003, 2004, 2005 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


a2 155

#if 1

  /* the following table has been automatically generated with */
  /* the `mather.py' Python script                             */

#define AF_ATAN_BITS  8

  static const FT_Byte  af_arctan[1L << AF_ATAN_BITS] =
  {
     0,  0,  1,  1,  1,  2,  2,  2,
     3,  3,  3,  3,  4,  4,  4,  5,
     5,  5,  6,  6,  6,  7,  7,  7,
     8,  8,  8,  9,  9,  9, 10, 10,
    10, 10, 11, 11, 11, 12, 12, 12,
    13, 13, 13, 14, 14, 14, 14, 15,
    15, 15, 16, 16, 16, 17, 17, 17,
    18, 18, 18, 18, 19, 19, 19, 20,
    20, 20, 21, 21, 21, 21, 22, 22,
    22, 23, 23, 23, 24, 24, 24, 24,
    25, 25, 25, 26, 26, 26, 26, 27,
    27, 27, 28, 28, 28, 28, 29, 29,
    29, 30, 30, 30, 30, 31, 31, 31,
    31, 32, 32, 32, 33, 33, 33, 33,
    34, 34, 34, 34, 35, 35, 35, 35,
    36, 36, 36, 36, 37, 37, 37, 38,
    38, 38, 38, 39, 39, 39, 39, 40,
    40, 40, 40, 41, 41, 41, 41, 42,
    42, 42, 42, 42, 43, 43, 43, 43,
    44, 44, 44, 44, 45, 45, 45, 45,
    46, 46, 46, 46, 46, 47, 47, 47,
    47, 48, 48, 48, 48, 48, 49, 49,
    49, 49, 50, 50, 50, 50, 50, 51,
    51, 51, 51, 51, 52, 52, 52, 52,
    52, 53, 53, 53, 53, 53, 54, 54,
    54, 54, 54, 55, 55, 55, 55, 55,
    56, 56, 56, 56, 56, 57, 57, 57,
    57, 57, 57, 58, 58, 58, 58, 58,
    59, 59, 59, 59, 59, 59, 60, 60,
    60, 60, 60, 61, 61, 61, 61, 61,
    61, 62, 62, 62, 62, 62, 62, 63,
    63, 63, 63, 63, 63, 64, 64, 64
  };


  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
  {
    AF_Angle  angle;


    /* check trivial cases */
    if ( dy == 0 )
    {
      angle = 0;
      if ( dx < 0 )
        angle = AF_ANGLE_PI;
      return angle;
    }
    else if ( dx == 0 )
    {
      angle = AF_ANGLE_PI2;
      if ( dy < 0 )
        angle = -AF_ANGLE_PI2;
      return angle;
    }

    angle = 0;
    if ( dx < 0 )
    {
      dx = -dx;
      dy = -dy;
      angle = AF_ANGLE_PI;
    }

    if ( dy < 0 )
    {
      FT_Pos  tmp;


      tmp = dx;
      dx  = -dy;
      dy  = tmp;
      angle -= AF_ANGLE_PI2;
    }

    if ( dx == 0 && dy == 0 )
      return 0;

    if ( dx == dy )
      angle += AF_ANGLE_PI4;
    else if ( dx > dy )
      angle += af_arctan[FT_DivFix( dy, dx ) >> ( 16 - AF_ATAN_BITS )];
    else
      angle += AF_ANGLE_PI2 -
               af_arctan[FT_DivFix( dx, dy ) >> ( 16 - AF_ATAN_BITS )];

    if ( angle > AF_ANGLE_PI )
      angle -= AF_ANGLE_2PI;

    return angle;
  }


#else /* 0 */

/*
 * a python script used to generate the following table
 *

import sys, math

units = 256
scale = units/math.pi
comma = ""

print ""
print "table of arctan( 1/2^n ) for PI = " + repr( units / 65536.0 ) + " units"

r = [-1] + range( 32 )

for n in r:
    if n >= 0:
        x = 1.0 / ( 2.0 ** n )   # tangent value
    else:
        x = 2.0 ** ( -n )

    angle  = math.atan( x )      # arctangent
    angle2 = angle * scale       # arctangent in FT_Angle units

    # determine which integer value for angle gives the best tangent
    lo  = int( angle2 )
    hi  = lo + 1
    tlo = math.tan( lo / scale )
    thi = math.tan( hi / scale )

    errlo = abs( tlo - x )
    errhi = abs( thi - x )

    angle2 = hi
    if errlo < errhi:
        angle2 = lo

    if angle2 <= 0:
        break

    sys.stdout.write( comma + repr( int( angle2 ) ) )
    comma = ", "

*
* end of python script
*/


d5 1
a5 1
#define AF_TRIG_MAX_ITERS   8
d72 1
a72 1
      theta = AF_ANGLE_PI;
d76 1
a76 1
      theta = -theta;
a117 1
#if 0
d120 1
a120 1
      theta =  FT_PAD_ROUND( theta, 2 );
d122 1
a122 2
      theta = -FT_PAD_ROUND( -theta, 2 );
#endif
d129 1
a129 1
  /* cf. documentation in fttrigon.h */
d150 1
a156 1

a166 1
#endif /* 0 */
d168 2
d172 2
a173 2
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table )
a214 44


#ifdef TEST

#include <stdio.h>
#include <math.h>

int main( void )
{
  int  angle;
  int  dist;


  for ( dist = 100; dist < 1000; dist++ )
  {
    for ( angle = AF_ANGLE_PI; angle < AF_ANGLE_2PI * 4; angle++ )
    {
      double  a = ( angle * 3.1415926535 ) / ( 1.0 * AF_ANGLE_PI );
      int     dx, dy, angle1, angle2, delta;


      dx = dist * cos( a );
      dy = dist * sin( a );

      angle1 = ( ( atan2( dy, dx ) * AF_ANGLE_PI ) / 3.1415926535 );
      angle2 = af_angle_atan( dx, dy );
      delta  = ( angle2 - angle1 ) % AF_ANGLE_2PI;
      if ( delta < 0 )
        delta = -delta;

      if ( delta >= 2 )
      {
        printf( "dist:%4d angle:%4d => (%4d,%4d) angle1:%4d angle2:%4d\n",
                dist, angle, dx, dy, angle1, angle2 );
      }
    }
  }
  return 0;
}

#endif /* TEST */


/* END */
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d8 1
a8 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d23 1
a23 117
#if 0

  FT_LOCAL_DEF( FT_Int )
  af_corner_is_flat( FT_Pos  x_in,
                     FT_Pos  y_in,
                     FT_Pos  x_out,
                     FT_Pos  y_out )
  {
    FT_Pos  ax = x_in;
    FT_Pos  ay = y_in;

    FT_Pos  d_in, d_out, d_corner;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;
    d_in = ax + ay;

    ax = x_out;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out;
    if ( ay < 0 )
      ay = -ay;
    d_out = ax + ay;

    ax = x_out + x_in;
    if ( ax < 0 )
      ax = -ax;
    ay = y_out + y_in;
    if ( ay < 0 )
      ay = -ay;
    d_corner = ax + ay;

    return ( d_in + d_out - d_corner ) < ( d_corner >> 4 );
  }


  FT_LOCAL_DEF( FT_Int )
  af_corner_orientation( FT_Pos  x_in,
                         FT_Pos  y_in,
                         FT_Pos  x_out,
                         FT_Pos  y_out )
  {
    FT_Pos  delta;


    delta = x_in * y_out - y_in * x_out;

    if ( delta == 0 )
      return 0;
    else
      return 1 - 2 * ( delta < 0 );
  }

#endif


  /*
   *  We are not using `af_angle_atan' anymore, but we keep the source
   *  code below just in case...
   */


#if 0


  /*
   *  The trick here is to realize that we don't need a very accurate angle
   *  approximation.  We are going to use the result of `af_angle_atan' to
   *  only compare the sign of angle differences, or check whether its
   *  magnitude is very small.
   *
   *  The approximation
   *
   *    dy * PI / (|dx|+|dy|)
   *
   *  should be enough, and much faster to compute.
   */
  FT_LOCAL_DEF( AF_Angle )
  af_angle_atan( FT_Fixed  dx,
                 FT_Fixed  dy )
  {
    AF_Angle  angle;
    FT_Fixed  ax = dx;
    FT_Fixed  ay = dy;


    if ( ax < 0 )
      ax = -ax;
    if ( ay < 0 )
      ay = -ay;

    ax += ay;

    if ( ax == 0 )
      angle = 0;
    else
    {
      angle = ( AF_ANGLE_PI2 * dy ) / ( ax + ay );
      if ( dx < 0 )
      {
        if ( angle >= 0 )
          angle = AF_ANGLE_PI - angle;
        else
          angle = -AF_ANGLE_PI - angle;
      }
    }

    return angle;
  }


#elif 0

d127 216
d392 41
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d8 1
a8 1
/*  Copyright 2003-2016 by                                                 */
d23 60
d258 1
a258 1
        if ( table[j] >= table[j - 1] )
d270 2
a271 3
  af_sort_and_quantize_widths( FT_UInt*  count,
                               AF_Width  table,
                               FT_Pos    threshold )
a273 3
    FT_UInt      cur_idx;
    FT_Pos       cur_val;
    FT_Pos       sum;
d277 1
a277 5
    if ( *count == 1 )
      return;

    /* sort */
    for ( i = 1; i < *count; i++ )
d281 1
a281 1
        if ( table[j].org >= table[j - 1].org )
a288 45

    cur_idx = 0;
    cur_val = table[cur_idx].org;

    /* compute and use mean values for clusters not larger than  */
    /* `threshold'; this is very primitive and might not yield   */
    /* the best result, but normally, using reference character  */
    /* `o', `*count' is 2, so the code below is fully sufficient */
    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org - cur_val > threshold ||
           i == *count - 1                    )
      {
        sum = 0;

        /* fix loop for end of array */
        if ( table[i].org - cur_val <= threshold &&
             i == *count - 1                     )
          i++;

        for ( j = cur_idx; j < i; j++ )
        {
          sum         += table[j].org;
          table[j].org = 0;
        }
        table[cur_idx].org = sum / (FT_Pos)j;

        if ( i < *count - 1 )
        {
          cur_idx = i + 1;
          cur_val = table[cur_idx].org;
        }
      }
    }

    cur_idx = 1;

    /* compress array to remove zero values */
    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org )
        table[cur_idx++] = table[i];
    }

    *count = cur_idx;
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
