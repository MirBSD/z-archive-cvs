head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.20;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.37;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.29;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.04.50;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.36;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.53;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.38.13;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.07;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.57;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.45;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.02;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  aftypes.h                                                              */
/*                                                                         */
/*    Auto-fitter types (specification only).                              */
/*                                                                         */
/*  Copyright 2003-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************
   *
   *  The auto-fitter is a complete rewrite of the old auto-hinter.
   *  Its main feature is the ability to differentiate between different
   *  writing systems and scripts in order to apply specific rules.
   *
   *  The code has also been compartmentalized into several entities that
   *  should make algorithmic experimentation easier than with the old
   *  code.
   *
   *************************************************************************/


#ifndef AFTYPES_H_
#define AFTYPES_H_

#include <ft2build.h>

#include FT_FREETYPE_H
#include FT_OUTLINE_H
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_DEBUG_H

#include "afblue.h"

#ifdef FT_DEBUG_AUTOFIT
#include FT_CONFIG_STANDARD_LIBRARY_H
#endif


FT_BEGIN_HEADER

  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    D E B U G G I N G                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

#ifdef FT_DEBUG_AUTOFIT

extern int    _af_debug_disable_horz_hints;
extern int    _af_debug_disable_vert_hints;
extern int    _af_debug_disable_blue_hints;
extern void*  _af_debug_hints;

#endif /* FT_DEBUG_AUTOFIT */


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                 U T I L I T Y   S T U F F                     *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct  AF_WidthRec_
  {
    FT_Pos  org;  /* original position/width in font units              */
    FT_Pos  cur;  /* current/scaled position/width in device sub-pixels */
    FT_Pos  fit;  /* current/fitted position/width in device sub-pixels */

  } AF_WidthRec, *AF_Width;


  FT_LOCAL( void )
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table );

  FT_LOCAL( void )
  af_sort_and_quantize_widths( FT_UInt*  count,
                               AF_Width  widths,
                               FT_Pos    threshold );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   A N G L E   T Y P E S                       *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The auto-fitter doesn't need a very high angular accuracy;
   *  this allows us to speed up some computations considerably with a
   *  light Cordic algorithm (see afangles.c).
   */

  typedef FT_Int  AF_Angle;


#define AF_ANGLE_PI   256
#define AF_ANGLE_2PI  ( AF_ANGLE_PI * 2 )
#define AF_ANGLE_PI2  ( AF_ANGLE_PI / 2 )
#define AF_ANGLE_PI4  ( AF_ANGLE_PI / 4 )


#if 0
  /*
   *  compute the angle of a given 2-D vector
   */
  FT_LOCAL( AF_Angle )
  af_angle_atan( FT_Pos  dx,
                 FT_Pos  dy );


  /*
   *  compute `angle2 - angle1'; the result is always within
   *  the range [-AF_ANGLE_PI .. AF_ANGLE_PI - 1]
   */
  FT_LOCAL( AF_Angle )
  af_angle_diff( AF_Angle  angle1,
                 AF_Angle  angle2 );
#endif /* 0 */


#define AF_ANGLE_DIFF( result, angle1, angle2 ) \
  FT_BEGIN_STMNT                                \
    AF_Angle  _delta = (angle2) - (angle1);     \
                                                \
                                                \
    while ( _delta <= -AF_ANGLE_PI )            \
      _delta += AF_ANGLE_2PI;                   \
                                                \
    while ( _delta > AF_ANGLE_PI )              \
      _delta -= AF_ANGLE_2PI;                   \
                                                \
    result = _delta;                            \
  FT_END_STMNT


  /*  opaque handle to glyph-specific hints -- see `afhints.h' for more
   *  details
   */
  typedef struct AF_GlyphHintsRec_*  AF_GlyphHints;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                       S C A L E R S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  A scaler models the target pixel device that will receive the
   *  auto-hinted glyph image.
   */

#define AF_SCALER_FLAG_NO_HORIZONTAL  1U /* disable horizontal hinting */
#define AF_SCALER_FLAG_NO_VERTICAL    2U /* disable vertical hinting   */
#define AF_SCALER_FLAG_NO_ADVANCE     4U /* disable advance hinting    */
#define AF_SCALER_FLAG_NO_WARPER      8U /* disable warper             */


  typedef struct  AF_ScalerRec_
  {
    FT_Face         face;        /* source font face                        */
    FT_Fixed        x_scale;     /* from font units to 1/64th device pixels */
    FT_Fixed        y_scale;     /* from font units to 1/64th device pixels */
    FT_Pos          x_delta;     /* in 1/64th device pixels                 */
    FT_Pos          y_delta;     /* in 1/64th device pixels                 */
    FT_Render_Mode  render_mode; /* monochrome, anti-aliased, LCD, etc.     */
    FT_UInt32       flags;       /* additional control flags, see above     */

  } AF_ScalerRec, *AF_Scaler;


#define AF_SCALER_EQUAL_SCALES( a, b )      \
          ( (a)->x_scale == (b)->x_scale && \
            (a)->y_scale == (b)->y_scale && \
            (a)->x_delta == (b)->x_delta && \
            (a)->y_delta == (b)->y_delta )


  typedef struct AF_StyleMetricsRec_*  AF_StyleMetrics;

  /*  This function parses an FT_Face to compute global metrics for
   *  a specific style.
   */
  typedef FT_Error
  (*AF_WritingSystem_InitMetricsFunc)( AF_StyleMetrics  metrics,
                                       FT_Face          face );

  typedef void
  (*AF_WritingSystem_ScaleMetricsFunc)( AF_StyleMetrics  metrics,
                                        AF_Scaler        scaler );

  typedef void
  (*AF_WritingSystem_DoneMetricsFunc)( AF_StyleMetrics  metrics );

  typedef void
  (*AF_WritingSystem_GetStdWidthsFunc)( AF_StyleMetrics  metrics,
                                        FT_Pos*          stdHW,
                                        FT_Pos*          stdVW );


  typedef FT_Error
  (*AF_WritingSystem_InitHintsFunc)( AF_GlyphHints    hints,
                                     AF_StyleMetrics  metrics );

  typedef FT_Error
  (*AF_WritingSystem_ApplyHintsFunc)( FT_UInt          glyph_index,
                                      AF_GlyphHints    hints,
                                      FT_Outline*      outline,
                                      AF_StyleMetrics  metrics );


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                W R I T I N G   S Y S T E M S                  *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  For the auto-hinter, a writing system consists of multiple scripts that
   *  can be handled similarly *in a typographical way*; the relationship is
   *  not based on history.  For example, both the Greek and the unrelated
   *  Armenian scripts share the same features like ascender, descender,
   *  x-height, etc.  Essentially, a writing system is covered by a
   *  submodule of the auto-fitter; it contains
   *
   *  - a specific global analyzer that computes global metrics specific to
   *    the script (based on script-specific characters to identify ascender
   *    height, x-height, etc.),
   *
   *  - a specific glyph analyzer that computes segments and edges for each
   *    glyph covered by the script,
   *
   *  - a specific grid-fitting algorithm that distorts the scaled glyph
   *    outline according to the results of the glyph analyzer.
   */

#define AFWRTSYS_H_  /* don't load header files */
#undef  WRITING_SYSTEM
#define WRITING_SYSTEM( ws, WS )    \
          AF_WRITING_SYSTEM_ ## WS,

  /* The list of known writing systems. */
  typedef enum  AF_WritingSystem_
  {

#include "afwrtsys.h"

    AF_WRITING_SYSTEM_MAX   /* do not remove */

  } AF_WritingSystem;

#undef  AFWRTSYS_H_


  typedef struct  AF_WritingSystemClassRec_
  {
    AF_WritingSystem  writing_system;

    FT_Offset                          style_metrics_size;
    AF_WritingSystem_InitMetricsFunc   style_metrics_init;
    AF_WritingSystem_ScaleMetricsFunc  style_metrics_scale;
    AF_WritingSystem_DoneMetricsFunc   style_metrics_done;
    AF_WritingSystem_GetStdWidthsFunc  style_metrics_getstdw;

    AF_WritingSystem_InitHintsFunc     style_hints_init;
    AF_WritingSystem_ApplyHintsFunc    style_hints_apply;

  } AF_WritingSystemClassRec;

  typedef const AF_WritingSystemClassRec*  AF_WritingSystemClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                        S C R I P T S                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  Each script is associated with two sets of Unicode ranges to test
   *  whether the font face supports the script, and which non-base
   *  characters the script contains.
   *
   *  We use four-letter script tags from the OpenType specification,
   *  extended by `NONE', which indicates `no script'.
   */

#undef  SCRIPT
#define SCRIPT( s, S, d, h, H, ss ) \
          AF_SCRIPT_ ## S,

  /* The list of known scripts. */
  typedef enum  AF_Script_
  {

#include "afscript.h"

    AF_SCRIPT_MAX   /* do not remove */

  } AF_Script;


  typedef struct  AF_Script_UniRangeRec_
  {
    FT_UInt32  first;
    FT_UInt32  last;

  } AF_Script_UniRangeRec;

#define AF_UNIRANGE_REC( a, b ) { (FT_UInt32)(a), (FT_UInt32)(b) }

  typedef const AF_Script_UniRangeRec*  AF_Script_UniRange;


  typedef struct  AF_ScriptClassRec_
  {
    AF_Script  script;

    /* last element in the ranges must be { 0, 0 } */
    AF_Script_UniRange  script_uni_ranges;
    AF_Script_UniRange  script_uni_nonbase_ranges;

    FT_Bool  top_to_bottom_hinting;

    const char*  standard_charstring;      /* for default width and height */

  } AF_ScriptClassRec;

  typedef const AF_ScriptClassRec*  AF_ScriptClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                      C O V E R A G E S                        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  Usually, a font contains more glyphs than can be addressed by its
   *  character map.
   *
   *  In the PostScript font world, encoding vectors specific to a given
   *  task are used to select such glyphs, and these glyphs can be often
   *  recognized by having a suffix in its glyph names.  For example, a
   *  superscript glyph `A' might be called `A.sup'.  Unfortunately, this
   *  naming scheme is not standardized and thus unusable for us.
   *
   *  In the OpenType world, a better solution was invented, namely
   *  `features', which cleanly separate a character's input encoding from
   *  the corresponding glyph's appearance, and which don't use glyph names
   *  at all.  For our purposes, and slightly generalized, an OpenType
   *  feature is a name of a mapping that maps character codes to
   *  non-standard glyph indices (features get used for other things also).
   *  For example, the `sups' feature provides superscript glyphs, thus
   *  mapping character codes like `A' or `B' to superscript glyph
   *  representation forms.  How this mapping happens is completely
   *  uninteresting to us.
   *
   *  For the auto-hinter, a `coverage' represents all glyphs of an OpenType
   *  feature collected in a set (as listed below) that can be hinted
   *  together.  To continue the above example, superscript glyphs must not
   *  be hinted together with normal glyphs because the blue zones
   *  completely differ.
   *
   *  Note that FreeType itself doesn't compute coverages; it only provides
   *  the glyphs addressable by the default Unicode character map.  Instead,
   *  we use the HarfBuzz library (if available), which has many functions
   *  exactly for this purpose.
   *
   *  AF_COVERAGE_DEFAULT is special: It should cover everything that isn't
   *  listed separately (including the glyphs addressable by the character
   *  map).  In case HarfBuzz isn't available, it exactly covers the glyphs
   *  addressable by the character map.
   *
   */

#undef  COVERAGE
#define COVERAGE( name, NAME, description, \
                  tag1, tag2, tag3, tag4 ) \
          AF_COVERAGE_ ## NAME,


  typedef enum  AF_Coverage_
  {
#include "afcover.h"

    AF_COVERAGE_DEFAULT

  } AF_Coverage;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                         S T Y L E S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The topmost structure for modelling the auto-hinter glyph input data
   *  is a `style class', grouping everything together.
   */

#undef  STYLE
#define STYLE( s, S, d, ws, sc, ss, c ) \
          AF_STYLE_ ## S,

  /* The list of known styles. */
  typedef enum  AF_Style_
  {

#include "afstyles.h"

    AF_STYLE_MAX   /* do not remove */

  } AF_Style;


  typedef struct  AF_StyleClassRec_
  {
    AF_Style  style;

    AF_WritingSystem   writing_system;
    AF_Script          script;
    AF_Blue_Stringset  blue_stringset;
    AF_Coverage        coverage;

  } AF_StyleClassRec;

  typedef const AF_StyleClassRec*  AF_StyleClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   S T Y L E   M E T R I C S                   *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct AF_FaceGlobalsRec_*  AF_FaceGlobals;

  /* This is the main structure that combines everything.  Autofit modules */
  /* specific to writing systems derive their structures from it, for      */
  /* example `AF_LatinMetrics'.                                            */

  typedef struct  AF_StyleMetricsRec_
  {
    AF_StyleClass   style_class;
    AF_ScalerRec    scaler;
    FT_Bool         digits_have_same_width;

    AF_FaceGlobals  globals;    /* to access properties */

  } AF_StyleMetricsRec;


#define AF_HINTING_BOTTOM_TO_TOP  0
#define AF_HINTING_TOP_TO_BOTTOM  1


  /* Declare and define vtables for classes */
#ifndef FT_CONFIG_OPTION_PIC

#define AF_DECLARE_WRITING_SYSTEM_CLASS( writing_system_class ) \
  FT_CALLBACK_TABLE const AF_WritingSystemClassRec              \
  writing_system_class;

#define AF_DEFINE_WRITING_SYSTEM_CLASS(                  \
          writing_system_class,                          \
          system,                                        \
          m_size,                                        \
          m_init,                                        \
          m_scale,                                       \
          m_done,                                        \
          m_stdw,                                        \
          h_init,                                        \
          h_apply )                                      \
  FT_CALLBACK_TABLE_DEF                                  \
  const AF_WritingSystemClassRec  writing_system_class = \
  {                                                      \
    system,                                              \
                                                         \
    m_size,                                              \
                                                         \
    m_init,                                              \
    m_scale,                                             \
    m_done,                                              \
    m_stdw,                                              \
                                                         \
    h_init,                                              \
    h_apply                                              \
  };


#define AF_DECLARE_SCRIPT_CLASS( script_class ) \
  FT_CALLBACK_TABLE const AF_ScriptClassRec     \
  script_class;

#define AF_DEFINE_SCRIPT_CLASS(           \
          script_class,                   \
          script,                         \
          ranges,                         \
          nonbase_ranges,                 \
          top_to_bottom,                  \
          std_charstring )                \
  FT_CALLBACK_TABLE_DEF                   \
  const AF_ScriptClassRec  script_class = \
  {                                       \
    script,                               \
    ranges,                               \
    nonbase_ranges,                       \
    top_to_bottom,                        \
    std_charstring,                       \
  };


#define AF_DECLARE_STYLE_CLASS( style_class ) \
  FT_CALLBACK_TABLE const AF_StyleClassRec    \
  style_class;

#define AF_DEFINE_STYLE_CLASS(          \
          style_class,                  \
          style,                        \
          writing_system,               \
          script,                       \
          blue_stringset,               \
          coverage )                    \
  FT_CALLBACK_TABLE_DEF                 \
  const AF_StyleClassRec  style_class = \
  {                                     \
    style,                              \
    writing_system,                     \
    script,                             \
    blue_stringset,                     \
    coverage                            \
  };

#else /* FT_CONFIG_OPTION_PIC */

#define AF_DECLARE_WRITING_SYSTEM_CLASS( writing_system_class )            \
  FT_LOCAL( void )                                                         \
  FT_Init_Class_ ## writing_system_class( AF_WritingSystemClassRec*  ac );

#define AF_DEFINE_WRITING_SYSTEM_CLASS(                                   \
          writing_system_class,                                           \
          system,                                                         \
          m_size,                                                         \
          m_init,                                                         \
          m_scale,                                                        \
          m_done,                                                         \
          h_init,                                                         \
          h_apply )                                                       \
  FT_LOCAL_DEF( void )                                                    \
  FT_Init_Class_ ## writing_system_class( AF_WritingSystemClassRec*  ac ) \
  {                                                                       \
    ac->writing_system        = system;                                   \
                                                                          \
    ac->style_metrics_size    = m_size;                                   \
                                                                          \
    ac->style_metrics_init    = m_init;                                   \
    ac->style_metrics_scale   = m_scale;                                  \
    ac->style_metrics_done    = m_done;                                   \
    ac->style_metrics_getstdw = m_stdw;                                   \
                                                                          \
    ac->style_hints_init      = h_init;                                   \
    ac->style_hints_apply     = h_apply;                                  \
  }


#define AF_DECLARE_SCRIPT_CLASS( script_class )             \
  FT_LOCAL( void )                                          \
  FT_Init_Class_ ## script_class( AF_ScriptClassRec*  ac );

#define AF_DEFINE_SCRIPT_CLASS(                            \
          script_class,                                    \
          script_,                                         \
          ranges,                                          \
          nonbase_ranges,                                  \
          top_to_bottom,                                   \
          std_charstring )                                 \
  FT_LOCAL_DEF( void )                                     \
  FT_Init_Class_ ## script_class( AF_ScriptClassRec*  ac ) \
  {                                                        \
    ac->script                    = script_;               \
    ac->script_uni_ranges         = ranges;                \
    ac->script_uni_nonbase_ranges = nonbase_ranges;        \
    ac->top_to_bottom_hinting     = top_to_bottom;         \
    ac->standard_charstring       = std_charstring;        \
  }


#define AF_DECLARE_STYLE_CLASS( style_class )             \
  FT_LOCAL( void )                                        \
  FT_Init_Class_ ## style_class( AF_StyleClassRec*  ac );

#define AF_DEFINE_STYLE_CLASS(                           \
          style_class,                                   \
          style_,                                        \
          writing_system_,                               \
          script_,                                       \
          blue_stringset_,                               \
          coverage_ )                                    \
  FT_LOCAL_DEF( void )                                   \
  FT_Init_Class_ ## style_class( AF_StyleClassRec*  ac ) \
  {                                                      \
    ac->style          = style_;                         \
    ac->writing_system = writing_system_;                \
    ac->script         = script_;                        \
    ac->blue_stringset = blue_stringset_;                \
    ac->coverage       = coverage_;                      \
  }

#endif /* FT_CONFIG_OPTION_PIC */


/* */

FT_END_HEADER

#endif /* AFTYPES_H_ */


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
d23 1
a23 1
   *  scripts in order to apply language-specific rules.
d25 1
a25 1
   *  The code has also been compartmentized into several entities that
a28 3
   *  Finally, we get rid of the Catharon license, since this code is
   *  released under the FreeType one.
   *
d32 2
a33 2
#ifndef __AFTYPES_H__
#define __AFTYPES_H__
d42 6
d59 1
a59 2
#define xxAF_USE_WARPER  /* only define to use warp hinting */
#define xxAF_DEBUG
a60 7
#ifdef AF_DEBUG

#include FT_CONFIG_STANDARD_LIBRARY_H

#define AF_LOG( x )  do { if ( _af_debug ) printf x; } while ( 0 )

extern int    _af_debug;
d66 1
a66 5
#else /* !AF_DEBUG */

#define AF_LOG( x )  do { } while ( 0 )        /* nothing */

#endif /* !AF_DEBUG */
d91 3
a93 2
  af_sort_widths( FT_UInt   count,
                  AF_Width  widths );
d143 1
a143 2
    _delta %= AF_ANGLE_2PI;                     \
    if ( _delta < 0 )                           \
d146 1
a146 1
    if ( _delta > AF_ANGLE_PI )                 \
a152 8
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    O U T L I N E S                            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

a157 17
  /*  This structure is used to model an input glyph outline to
   *  the auto-hinter.  The latter will set the `hints' field
   *  depending on the glyph's script.
   */
  typedef struct  AF_OutlineRec_
  {
    FT_Face        face;
    FT_Outline     outline;
    FT_UInt        outline_resolution;

    FT_Int         advance;
    FT_UInt        metrics_resolution;

    AF_GlyphHints  hints;

  } AF_OutlineRec;

d172 4
a175 7
  typedef enum  AF_ScalerFlags_
  {
    AF_SCALER_FLAG_NO_HORIZONTAL = 1,  /* disable horizontal hinting */
    AF_SCALER_FLAG_NO_VERTICAL   = 2,  /* disable vertical hinting   */
    AF_SCALER_FLAG_NO_ADVANCE    = 4   /* disable advance hinting    */

  } AF_ScalerFlags;
d198 33
d234 1
a234 1
  /*****                       S C R I P T S                           *****/
d240 6
a245 5
   *  The list of know scripts.  Each different script corresponds to the
   *  following information:
   *
   *   - A set of Unicode ranges to test whether the face supports the
   *     script.
d247 3
a249 2
   *   - A specific global analyzer that will compute global metrics
   *     specific to the script.
d251 2
a252 2
   *   - A specific glyph analyzer that will compute segments and
   *     edges for each glyph covered by the script.
d254 2
a255 6
   *   - A specific grid-fitting algorithm that will distort the
   *     scaled glyph outline according to the results of the glyph
   *     analyzer.
   *
   *  Note that a given analyzer and/or grid-fitting algorithm can be
   *  used by more than one script.
d258 7
a264 1
  typedef enum  AF_Script_
a265 7
    AF_SCRIPT_NONE  = 0,
    AF_SCRIPT_LATIN = 1,
    AF_SCRIPT_CJK   = 2,
    AF_SCRIPT_INDIC = 3, 
#ifdef FT_OPTION_AUTOFIT2
    AF_SCRIPT_LATIN2,
#endif
d267 1
a267 2
    /* add new scripts here.  Don't forget to update the list in */
    /* `afglobal.c'.                                             */
d269 1
a269 1
    AF_SCRIPT_MAX   /* do not remove */
d271 1
a271 1
  } AF_Script;
d273 1
a274 1
  typedef struct AF_ScriptClassRec_ const*  AF_ScriptClass;
d276 1
a276 1
  typedef struct  AF_ScriptMetricsRec_
d278 12
a289 3
    AF_ScriptClass  clazz;
    AF_ScalerRec    scaler;
    FT_Bool         digits_have_same_width;
d291 1
a291 1
  } AF_ScriptMetricsRec, *AF_ScriptMetrics;
d294 15
a308 2
  /*  This function parses an FT_Face to compute global metrics for
   *  a specific script.
a309 3
  typedef FT_Error
  (*AF_Script_InitMetricsFunc)( AF_ScriptMetrics  metrics,
                                FT_Face           face );
d311 3
a313 3
  typedef void
  (*AF_Script_ScaleMetricsFunc)( AF_ScriptMetrics  metrics,
                                 AF_Scaler         scaler );
d315 3
a317 2
  typedef void
  (*AF_Script_DoneMetricsFunc)( AF_ScriptMetrics  metrics );
d319 1
d321 1
a321 3
  typedef FT_Error
  (*AF_Script_InitHintsFunc)( AF_GlyphHints     hints,
                              AF_ScriptMetrics  metrics );
d323 1
a323 4
  typedef void
  (*AF_Script_ApplyHintsFunc)( AF_GlyphHints     hints,
                               FT_Outline*       outline,
                               AF_ScriptMetrics  metrics );
d335 1
a335 1
  typedef const AF_Script_UniRangeRec  *AF_Script_UniRange;
d340 1
a340 2
    AF_Script                   script;
    AF_Script_UniRange          script_uni_ranges; /* last must be { 0, 0 } */
d342 3
a344 4
    FT_Offset                   script_metrics_size;
    AF_Script_InitMetricsFunc   script_metrics_init;
    AF_Script_ScaleMetricsFunc  script_metrics_scale;
    AF_Script_DoneMetricsFunc   script_metrics_done;
d346 3
a348 2
    AF_Script_InitHintsFunc     script_hints_init;
    AF_Script_ApplyHintsFunc    script_hints_apply;
d352 137
a488 1
/* Declare and define vtables for classes */
d491 33
a523 2
#define AF_DECLARE_SCRIPT_CLASS(script_class)                                \
  FT_CALLBACK_TABLE const AF_ScriptClassRec                                  \
d526 15
a540 16
#define AF_DEFINE_SCRIPT_CLASS(script_class, script_, ranges, m_size,        \
                               m_init, m_scale, m_done, h_init, h_apply)     \
  FT_CALLBACK_TABLE_DEF const AF_ScriptClassRec                              \
  script_class =                                                             \
  {                                                                          \
    script_,                                                                 \
    ranges,                                                                  \
                                                                             \
    m_size,                                                                  \
                                                                             \
    m_init,                                                                  \
    m_scale,                                                                 \
    m_done,                                                                  \
                                                                             \
    h_init,                                                                  \
    h_apply                                                                  \
a542 1
#else 
d544 50
a593 20
#define AF_DECLARE_SCRIPT_CLASS(script_class)                                \
  FT_LOCAL(void)                                                             \
  FT_Init_Class_##script_class(AF_ScriptClassRec* ac);

#define AF_DEFINE_SCRIPT_CLASS(script_class, script_, ranges, m_size,        \
                               m_init, m_scale, m_done, h_init, h_apply)     \
  FT_LOCAL_DEF(void)                                                         \
  FT_Init_Class_##script_class(AF_ScriptClassRec* ac)                        \
  {                                                                          \
    ac->script                = script_;                                     \
    ac->script_uni_ranges     = ranges;                                      \
                                                                             \
    ac->script_metrics_size   = m_size;                                      \
                                                                             \
    ac->script_metrics_init   = m_init;                                      \
    ac->script_metrics_scale  = m_scale;                                     \
    ac->script_metrics_done   = m_done;                                      \
                                                                             \
    ac->script_hints_init     = h_init;                                      \
    ac->script_hints_apply    = h_apply;                                     \
d595 46
a640 1
#endif
d647 1
a647 1
#endif /* __AFTYPES_H__ */
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008 by                        */
d61 2
a62 1
#include <stdio.h>
d73 1
a73 1
#define AF_LOG( x )  do ; while ( 0 )        /* nothing */
d288 1
d325 2
d335 1
a335 1
    FT_UInt                     script_metrics_size;
d345 50
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
d205 1
a205 1
  typedef enum
d263 1
a263 1
  typedef enum
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d25 1
a25 1
   *  The code has also been compartimentized into several entities that
d62 1
d64 5
a68 1
#define AF_LOG( x )  printf x
d70 1
a70 1
#else
d74 1
a74 1
#endif /* AF_DEBUG */
d126 1
a134 1
#if 0
d268 5
@


1.1
log
@Initial revision
@
text
@d1 34
d39 1
d45 1
d48 7
a54 7
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                D E B U G G I N G                               *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/
d56 1
d61 3
a63 2
#  include <stdio.h>
#  define AF_LOG( x )  printf x
d67 1
a67 1
#  define AF_LOG( x )  do ; while ( 0 ) /* nothing */
a70 7
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                U T I L I T Y                                   *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/
d72 9
a80 1
  typedef struct AF_WidthRec_
d90 2
a91 2
  af_sort_pos( FT_UInt   count,
               FT_Pos*   table );
d98 26
a123 26
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                A N G L E   T Y P E S                           *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/

 /*
  *  Angle type. The auto-fitter doesn't need a very high angular accuracy,
  *  and this allows us to speed up some computations considerably with a
  *  light Cordic algorithm (see afangles.c)
  *
  */

  typedef FT_Int    AF_Angle;

#define  AF_ANGLE_PI     128
#define  AF_ANGLE_2PI    (AF_ANGLE_PI*2)
#define  AF_ANGLE_PI2    (AF_ANGLE_PI/2)
#define  AF_ANGLE_PI4    (AF_ANGLE_PI/4)

 /*
  *  compute the angle of a given 2-D vector
  *
  */
d129 5
a133 5
 /*
  *  computes "angle2 - angle1", the result is always within
  *  the range [ -AF_ANGLE_PI .. AF_ANGLE_PI-1 ]
  *
  */
d137 1
d140 34
a173 18
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                O U T L I N E S                                 *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/

 /* opaque handle to glyph-specific hints. see "afhints.h" for more
  * details
  */
  typedef struct AF_GlyphHintsRec_*     AF_GlyphHints;

 /* this structure is used to model an input glyph outline to
  * the auto-hinter. The latter will set the "hints" field
  * depending on the glyph's script
  */
  typedef struct AF_OutlineRec_
d175 3
a177 3
    FT_Face          face;
    FT_Outline       outline;
    FT_UInt          outline_resolution;
d179 2
a180 2
    FT_Int           advance;
    FT_UInt          metrics_resolution;
d182 1
a182 1
    AF_GlyphHints    hints;
d187 12
a198 13
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                S C A L E R S                                   *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/

 /*
  *  A scaler models the target pixel device that will receive the
  *  auto-hinted glyph image
  *
  */
d209 1
a209 1
  typedef struct AF_ScalerRec_
d211 7
a217 7
    FT_Face         face;         /* source font face                        */
    FT_Fixed        x_scale;      /* from font units to 1/64th device pixels */
    FT_Fixed        y_scale;      /* from font units to 1/64th device pixels */
    FT_Pos          x_delta;      /* in 1/64th device pixels                 */
    FT_Pos          y_delta;      /* in 1/64th device pixels                 */
    FT_Render_Mode  render_mode;  /* monochrome, anti-aliased, LCD, etc..    */
    FT_UInt32       flags;        /* additionnal control flags, see above    */
d222 35
a257 28
 /**************************************************************************/
 /**************************************************************************/
 /*****                                                                *****/
 /*****                S C R I P T S                                   *****/
 /*****                                                                *****/
 /**************************************************************************/
 /**************************************************************************/

 /*
  *  the list of know scripts. Each different script correspond to the
  *  following information:
  *
  *   - a set of Unicode ranges to test weither the face supports the
  *     script
  *
  *   - a specific global analyzer that will compute global metrics
  *     specific to the script.
  *
  *   - a specific glyph analyzer that will compute segments and
  *     edges for each glyph covered by the script
  *
  *   - a specific grid-fitting algorithm that will distort the
  *     scaled glyph outline according to the results of the glyph
  *     analyzer
  *
  *  note that a given analyzer and/or grid-fitting algorithm can be
  *  used by more than one script
  */
d262 3
a264 1
    /* add new scripts here. don't forget to update the list in "afglobal.c" */
a270 1

d273 1
a273 1
  typedef struct AF_ScriptMetricsRec_
d275 2
a276 2
    AF_ScriptClass    clazz;
    AF_ScalerRec      scaler;
d281 6
a286 5
 /* this function parses a FT_Face to compute global metrics for
  * a specific script
  */
  typedef FT_Error  (*AF_Script_InitMetricsFunc)( AF_ScriptMetrics   metrics,
                                                  FT_Face            face );
d288 3
a290 2
  typedef void      (*AF_Script_ScaleMetricsFunc)( AF_ScriptMetrics  metrics,
                                                   AF_Scaler         scaler );
d292 2
a293 1
  typedef void      (*AF_Script_DoneMetricsFunc)( AF_ScriptMetrics   metrics );
d296 3
a298 3
  typedef FT_Error  (*AF_Script_InitHintsFunc)( AF_GlyphHints     hints,
                                                FT_Outline*       outline,
                                                AF_ScriptMetrics  metrics );
d300 4
a303 3
  typedef void      (*AF_Script_ApplyHintsFunc)( AF_GlyphHints     hints,
                                                 FT_Outline*       outline,
                                                 AF_ScriptMetrics  metrics );
d306 1
a306 1
  typedef struct AF_Script_UniRangeRec_
d308 2
a309 2
    FT_UInt32    first;
    FT_UInt32    last;
d313 2
a314 1
  typedef const AF_Script_UniRangeRec *  AF_Script_UniRange;
d316 1
a316 1
  typedef struct AF_ScriptClassRec_
d319 1
a319 1
    AF_Script_UniRange          script_uni_ranges;  /* last must be { 0, 0 } */
d337 3
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@a0 34
/***************************************************************************/
/*                                                                         */
/*  aftypes.h                                                              */
/*                                                                         */
/*    Auto-fitter types (specification only).                              */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************
   *
   *  The auto-fitter is a complete rewrite of the old auto-hinter.
   *  Its main feature is the ability to differentiate between different
   *  scripts in order to apply language-specific rules.
   *
   *  The code has also been compartmentized into several entities that
   *  should make algorithmic experimentation easier than with the old
   *  code.
   *
   *  Finally, we get rid of the Catharon license, since this code is
   *  released under the FreeType one.
   *
   *************************************************************************/


a4 1

a9 1

d12 7
a18 7
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    D E B U G G I N G                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
a19 1
#define xxAF_USE_WARPER  /* only define to use warp hinting */
d24 2
a25 10
#include <stdio.h>
#define AF_LOG( x )  do { if ( _af_debug ) printf x; } while ( 0 )

extern int    _af_debug;
extern int    _af_debug_disable_horz_hints;
extern int    _af_debug_disable_vert_hints;
extern int    _af_debug_disable_blue_hints;
extern void*  _af_debug_hints;

#else /* !AF_DEBUG */
d27 1
a27 1
#define AF_LOG( x )  do ; while ( 0 )        /* nothing */
d29 1
a29 1
#endif /* !AF_DEBUG */
d31 1
d33 7
a39 7
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                 U T I L I T Y   S T U F F                     *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
d41 1
a41 1
  typedef struct  AF_WidthRec_
d51 2
a52 2
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table );
d59 26
a84 27
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   A N G L E   T Y P E S                       *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The auto-fitter doesn't need a very high angular accuracy;
   *  this allows us to speed up some computations considerably with a
   *  light Cordic algorithm (see afangles.c).
   */

  typedef FT_Int  AF_Angle;


#define AF_ANGLE_PI   256
#define AF_ANGLE_2PI  ( AF_ANGLE_PI * 2 )
#define AF_ANGLE_PI2  ( AF_ANGLE_PI / 2 )
#define AF_ANGLE_PI4  ( AF_ANGLE_PI / 4 )


#if 0
  /*
   *  compute the angle of a given 2-D vector
   */
d90 5
a94 4
  /*
   *  compute `angle2 - angle1'; the result is always within
   *  the range [-AF_ANGLE_PI .. AF_ANGLE_PI - 1]
   */
a97 1
#endif /* 0 */
d100 18
a117 34
#define AF_ANGLE_DIFF( result, angle1, angle2 ) \
  FT_BEGIN_STMNT                                \
    AF_Angle  _delta = (angle2) - (angle1);     \
                                                \
                                                \
    _delta %= AF_ANGLE_2PI;                     \
    if ( _delta < 0 )                           \
      _delta += AF_ANGLE_2PI;                   \
                                                \
    if ( _delta > AF_ANGLE_PI )                 \
      _delta -= AF_ANGLE_2PI;                   \
                                                \
    result = _delta;                            \
  FT_END_STMNT


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    O U T L I N E S                            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*  opaque handle to glyph-specific hints -- see `afhints.h' for more
   *  details
   */
  typedef struct AF_GlyphHintsRec_*  AF_GlyphHints;

  /*  This structure is used to model an input glyph outline to
   *  the auto-hinter.  The latter will set the `hints' field
   *  depending on the glyph's script.
   */
  typedef struct  AF_OutlineRec_
d119 3
a121 3
    FT_Face        face;
    FT_Outline     outline;
    FT_UInt        outline_resolution;
d123 2
a124 2
    FT_Int         advance;
    FT_UInt        metrics_resolution;
d126 1
a126 1
    AF_GlyphHints  hints;
d131 13
a143 12
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                       S C A L E R S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  A scaler models the target pixel device that will receive the
   *  auto-hinted glyph image.
   */
d154 1
a154 1
  typedef struct  AF_ScalerRec_
d156 7
a162 7
    FT_Face         face;        /* source font face                        */
    FT_Fixed        x_scale;     /* from font units to 1/64th device pixels */
    FT_Fixed        y_scale;     /* from font units to 1/64th device pixels */
    FT_Pos          x_delta;     /* in 1/64th device pixels                 */
    FT_Pos          y_delta;     /* in 1/64th device pixels                 */
    FT_Render_Mode  render_mode; /* monochrome, anti-aliased, LCD, etc.     */
    FT_UInt32       flags;       /* additional control flags, see above     */
a166 35
#define AF_SCALER_EQUAL_SCALES( a, b )      \
          ( (a)->x_scale == (b)->x_scale && \
            (a)->y_scale == (b)->y_scale && \
            (a)->x_delta == (b)->x_delta && \
            (a)->y_delta == (b)->y_delta )


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                       S C R I P T S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The list of know scripts.  Each different script corresponds to the
   *  following information:
   *
   *   - A set of Unicode ranges to test whether the face supports the
   *     script.
   *
   *   - A specific global analyzer that will compute global metrics
   *     specific to the script.
   *
   *   - A specific glyph analyzer that will compute segments and
   *     edges for each glyph covered by the script.
   *
   *   - A specific grid-fitting algorithm that will distort the
   *     scaled glyph outline according to the results of the glyph
   *     analyzer.
   *
   *  Note that a given analyzer and/or grid-fitting algorithm can be
   *  used by more than one script.
   */
d168 28
d200 1
a200 8
    AF_SCRIPT_CJK   = 2,
    AF_SCRIPT_INDIC = 3, 
#ifdef FT_OPTION_AUTOFIT2
    AF_SCRIPT_LATIN2,
#endif

    /* add new scripts here.  Don't forget to update the list in */
    /* `afglobal.c'.                                             */
d207 1
d210 1
a210 1
  typedef struct  AF_ScriptMetricsRec_
d212 2
a213 2
    AF_ScriptClass  clazz;
    AF_ScalerRec    scaler;
d218 5
a222 6
  /*  This function parses an FT_Face to compute global metrics for
   *  a specific script.
   */
  typedef FT_Error
  (*AF_Script_InitMetricsFunc)( AF_ScriptMetrics  metrics,
                                FT_Face           face );
d224 2
a225 3
  typedef void
  (*AF_Script_ScaleMetricsFunc)( AF_ScriptMetrics  metrics,
                                 AF_Scaler         scaler );
d227 1
a227 2
  typedef void
  (*AF_Script_DoneMetricsFunc)( AF_ScriptMetrics  metrics );
d230 3
a232 3
  typedef FT_Error
  (*AF_Script_InitHintsFunc)( AF_GlyphHints     hints,
                              AF_ScriptMetrics  metrics );
d234 3
a236 4
  typedef void
  (*AF_Script_ApplyHintsFunc)( AF_GlyphHints     hints,
                               FT_Outline*       outline,
                               AF_ScriptMetrics  metrics );
d239 1
a239 1
  typedef struct  AF_Script_UniRangeRec_
d241 2
a242 2
    FT_UInt32  first;
    FT_UInt32  last;
d246 1
a246 2
  typedef const AF_Script_UniRangeRec  *AF_Script_UniRange;

d248 1
a248 1
  typedef struct  AF_ScriptClassRec_
d251 1
a251 1
    AF_Script_UniRange          script_uni_ranges; /* last must be { 0, 0 } */
a268 3


/* END */
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008 by                        */
d205 1
a205 1
  typedef enum  AF_ScalerFlags_
d263 1
a263 1
  typedef enum  AF_Script_
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@a0 34
/***************************************************************************/
/*                                                                         */
/*  aftypes.h                                                              */
/*                                                                         */
/*    Auto-fitter types (specification only).                              */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************
   *
   *  The auto-fitter is a complete rewrite of the old auto-hinter.
   *  Its main feature is the ability to differentiate between different
   *  scripts in order to apply language-specific rules.
   *
   *  The code has also been compartimentized into several entities that
   *  should make algorithmic experimentation easier than with the old
   *  code.
   *
   *  Finally, we get rid of the Catharon license, since this code is
   *  released under the FreeType one.
   *
   *************************************************************************/


a4 1

a9 1

d12 7
a18 7
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    D E B U G G I N G                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
a19 1
#define xxAF_USE_WARPER  /* only define to use warp hinting */
d24 2
a25 3
#include <stdio.h>

#define AF_LOG( x )  printf x
d29 1
a29 1
#define AF_LOG( x )  do ; while ( 0 )        /* nothing */
d33 7
d41 1
a41 9
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                 U T I L I T Y   S T U F F                     *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct  AF_WidthRec_
d51 2
a52 2
  af_sort_pos( FT_UInt  count,
               FT_Pos*  table );
d59 26
a84 26
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   A N G L E   T Y P E S                       *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The auto-fitter doesn't need a very high angular accuracy;
   *  this allows us to speed up some computations considerably with a
   *  light Cordic algorithm (see afangles.c).
   */

  typedef FT_Int  AF_Angle;


#define AF_ANGLE_PI   256
#define AF_ANGLE_2PI  ( AF_ANGLE_PI * 2 )
#define AF_ANGLE_PI2  ( AF_ANGLE_PI / 2 )
#define AF_ANGLE_PI4  ( AF_ANGLE_PI / 4 )


  /*
   *  compute the angle of a given 2-D vector
   */
d90 5
a94 5
#if 0
  /*
   *  compute `angle2 - angle1'; the result is always within
   *  the range [-AF_ANGLE_PI .. AF_ANGLE_PI - 1]
   */
a97 1
#endif /* 0 */
d100 18
a117 34
#define AF_ANGLE_DIFF( result, angle1, angle2 ) \
  FT_BEGIN_STMNT                                \
    AF_Angle  _delta = (angle2) - (angle1);     \
                                                \
                                                \
    _delta %= AF_ANGLE_2PI;                     \
    if ( _delta < 0 )                           \
      _delta += AF_ANGLE_2PI;                   \
                                                \
    if ( _delta > AF_ANGLE_PI )                 \
      _delta -= AF_ANGLE_2PI;                   \
                                                \
    result = _delta;                            \
  FT_END_STMNT


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    O U T L I N E S                            *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*  opaque handle to glyph-specific hints -- see `afhints.h' for more
   *  details
   */
  typedef struct AF_GlyphHintsRec_*  AF_GlyphHints;

  /*  This structure is used to model an input glyph outline to
   *  the auto-hinter.  The latter will set the `hints' field
   *  depending on the glyph's script.
   */
  typedef struct  AF_OutlineRec_
d119 3
a121 3
    FT_Face        face;
    FT_Outline     outline;
    FT_UInt        outline_resolution;
d123 2
a124 2
    FT_Int         advance;
    FT_UInt        metrics_resolution;
d126 1
a126 1
    AF_GlyphHints  hints;
d131 13
a143 12
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                       S C A L E R S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  A scaler models the target pixel device that will receive the
   *  auto-hinted glyph image.
   */
d154 1
a154 1
  typedef struct  AF_ScalerRec_
d156 7
a162 7
    FT_Face         face;        /* source font face                        */
    FT_Fixed        x_scale;     /* from font units to 1/64th device pixels */
    FT_Fixed        y_scale;     /* from font units to 1/64th device pixels */
    FT_Pos          x_delta;     /* in 1/64th device pixels                 */
    FT_Pos          y_delta;     /* in 1/64th device pixels                 */
    FT_Render_Mode  render_mode; /* monochrome, anti-aliased, LCD, etc.     */
    FT_UInt32       flags;       /* additional control flags, see above     */
a166 35
#define AF_SCALER_EQUAL_SCALES( a, b )      \
          ( (a)->x_scale == (b)->x_scale && \
            (a)->y_scale == (b)->y_scale && \
            (a)->x_delta == (b)->x_delta && \
            (a)->y_delta == (b)->y_delta )


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                       S C R I P T S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The list of know scripts.  Each different script corresponds to the
   *  following information:
   *
   *   - A set of Unicode ranges to test whether the face supports the
   *     script.
   *
   *   - A specific global analyzer that will compute global metrics
   *     specific to the script.
   *
   *   - A specific glyph analyzer that will compute segments and
   *     edges for each glyph covered by the script.
   *
   *   - A specific grid-fitting algorithm that will distort the
   *     scaled glyph outline according to the results of the glyph
   *     analyzer.
   *
   *  Note that a given analyzer and/or grid-fitting algorithm can be
   *  used by more than one script.
   */
d168 28
d200 1
a200 3
    AF_SCRIPT_CJK   = 2,
    /* add new scripts here.  Don't forget to update the list in */
    /* `afglobal.c'.                                             */
d207 1
d210 1
a210 1
  typedef struct  AF_ScriptMetricsRec_
d212 2
a213 2
    AF_ScriptClass  clazz;
    AF_ScalerRec    scaler;
d218 5
a222 6
  /*  This function parses an FT_Face to compute global metrics for
   *  a specific script.
   */
  typedef FT_Error
  (*AF_Script_InitMetricsFunc)( AF_ScriptMetrics  metrics,
                                FT_Face           face );
d224 2
a225 3
  typedef void
  (*AF_Script_ScaleMetricsFunc)( AF_ScriptMetrics  metrics,
                                 AF_Scaler         scaler );
d227 1
a227 2
  typedef void
  (*AF_Script_DoneMetricsFunc)( AF_ScriptMetrics  metrics );
d230 3
a232 3
  typedef FT_Error
  (*AF_Script_InitHintsFunc)( AF_GlyphHints     hints,
                              AF_ScriptMetrics  metrics );
d234 3
a236 4
  typedef void
  (*AF_Script_ApplyHintsFunc)( AF_GlyphHints     hints,
                               FT_Outline*       outline,
                               AF_ScriptMetrics  metrics );
d239 1
a239 1
  typedef struct  AF_Script_UniRangeRec_
d241 2
a242 2
    FT_UInt32  first;
    FT_UInt32  last;
d246 1
a246 2
  typedef const AF_Script_UniRangeRec  *AF_Script_UniRange;

d248 1
a248 1
  typedef struct  AF_ScriptClassRec_
d251 1
a251 1
    AF_Script_UniRange          script_uni_ranges; /* last must be { 0, 0 } */
a268 3


/* END */
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
d25 1
a25 1
   *  The code has also been compartmentized into several entities that
d61 1
a61 1
#include FT_CONFIG_STANDARD_LIBRARY_H
d63 1
a63 1
#define AF_LOG( x )  do { if ( _af_debug ) printf x; } while ( 0 )
d65 1
a65 5
extern int    _af_debug;
extern int    _af_debug_disable_horz_hints;
extern int    _af_debug_disable_vert_hints;
extern int    _af_debug_disable_blue_hints;
extern void*  _af_debug_hints;
d67 1
a67 1
#else /* !AF_DEBUG */
d69 1
a69 3
#define AF_LOG( x )  do { } while ( 0 )        /* nothing */

#endif /* !AF_DEBUG */
a120 1
#if 0
d129 1
d200 1
a200 1
  typedef enum  AF_ScalerFlags_
d258 1
a258 1
  typedef enum  AF_Script_
a262 5
    AF_SCRIPT_INDIC = 3, 
#ifdef FT_OPTION_AUTOFIT2
    AF_SCRIPT_LATIN2,
#endif

a276 1
    FT_Bool         digits_have_same_width;
a312 2
#define AF_UNIRANGE_REC( a, b ) { (FT_UInt32)(a), (FT_UInt32)(b) }

d321 1
a321 1
    FT_Offset                   script_metrics_size;
a330 50
/* Declare and define vtables for classes */
#ifndef FT_CONFIG_OPTION_PIC

#define AF_DECLARE_SCRIPT_CLASS(script_class)                                \
  FT_CALLBACK_TABLE const AF_ScriptClassRec                                  \
  script_class;

#define AF_DEFINE_SCRIPT_CLASS(script_class, script_, ranges, m_size,        \
                               m_init, m_scale, m_done, h_init, h_apply)     \
  FT_CALLBACK_TABLE_DEF const AF_ScriptClassRec                              \
  script_class =                                                             \
  {                                                                          \
    script_,                                                                 \
    ranges,                                                                  \
                                                                             \
    m_size,                                                                  \
                                                                             \
    m_init,                                                                  \
    m_scale,                                                                 \
    m_done,                                                                  \
                                                                             \
    h_init,                                                                  \
    h_apply                                                                  \
  };

#else 

#define AF_DECLARE_SCRIPT_CLASS(script_class)                                \
  FT_LOCAL(void)                                                             \
  FT_Init_Class_##script_class(AF_ScriptClassRec* ac);

#define AF_DEFINE_SCRIPT_CLASS(script_class, script_, ranges, m_size,        \
                               m_init, m_scale, m_done, h_init, h_apply)     \
  FT_LOCAL_DEF(void)                                                         \
  FT_Init_Class_##script_class(AF_ScriptClassRec* ac)                        \
  {                                                                          \
    ac->script                = script_;                                     \
    ac->script_uni_ranges     = ranges;                                      \
                                                                             \
    ac->script_metrics_size   = m_size;                                      \
                                                                             \
    ac->script_metrics_init   = m_init;                                      \
    ac->script_metrics_scale  = m_scale;                                     \
    ac->script_metrics_done   = m_done;                                      \
                                                                             \
    ac->script_hints_init     = h_init;                                      \
    ac->script_hints_apply    = h_apply;                                     \
  }
#endif

@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2003-2016 by                                                 */
d23 1
a23 1
   *  writing systems and scripts in order to apply specific rules.
d25 1
a25 1
   *  The code has also been compartmentalized into several entities that
d29 3
d35 2
a36 2
#ifndef AFTYPES_H_
#define AFTYPES_H_
a44 6
#include "afblue.h"

#ifdef FT_DEBUG_AUTOFIT
#include FT_CONFIG_STANDARD_LIBRARY_H
#endif

d56 2
a57 1
#ifdef FT_DEBUG_AUTOFIT
d59 7
d71 5
a75 1
#endif /* FT_DEBUG_AUTOFIT */
d100 2
a101 3
  af_sort_and_quantize_widths( FT_UInt*  count,
                               AF_Width  widths,
                               FT_Pos    threshold );
d151 2
a152 1
    while ( _delta <= -AF_ANGLE_PI )            \
d155 1
a155 1
    while ( _delta > AF_ANGLE_PI )              \
d162 8
d175 17
d206 7
a212 4
#define AF_SCALER_FLAG_NO_HORIZONTAL  1U /* disable horizontal hinting */
#define AF_SCALER_FLAG_NO_VERTICAL    2U /* disable vertical hinting   */
#define AF_SCALER_FLAG_NO_ADVANCE     4U /* disable advance hinting    */
#define AF_SCALER_FLAG_NO_WARPER      8U /* disable warper             */
a234 33
  typedef struct AF_StyleMetricsRec_*  AF_StyleMetrics;

  /*  This function parses an FT_Face to compute global metrics for
   *  a specific style.
   */
  typedef FT_Error
  (*AF_WritingSystem_InitMetricsFunc)( AF_StyleMetrics  metrics,
                                       FT_Face          face );

  typedef void
  (*AF_WritingSystem_ScaleMetricsFunc)( AF_StyleMetrics  metrics,
                                        AF_Scaler        scaler );

  typedef void
  (*AF_WritingSystem_DoneMetricsFunc)( AF_StyleMetrics  metrics );

  typedef void
  (*AF_WritingSystem_GetStdWidthsFunc)( AF_StyleMetrics  metrics,
                                        FT_Pos*          stdHW,
                                        FT_Pos*          stdVW );


  typedef FT_Error
  (*AF_WritingSystem_InitHintsFunc)( AF_GlyphHints    hints,
                                     AF_StyleMetrics  metrics );

  typedef FT_Error
  (*AF_WritingSystem_ApplyHintsFunc)( FT_UInt          glyph_index,
                                      AF_GlyphHints    hints,
                                      FT_Outline*      outline,
                                      AF_StyleMetrics  metrics );


d238 1
a238 1
  /*****                W R I T I N G   S Y S T E M S                  *****/
d244 5
a248 6
   *  For the auto-hinter, a writing system consists of multiple scripts that
   *  can be handled similarly *in a typographical way*; the relationship is
   *  not based on history.  For example, both the Greek and the unrelated
   *  Armenian scripts share the same features like ascender, descender,
   *  x-height, etc.  Essentially, a writing system is covered by a
   *  submodule of the auto-fitter; it contains
d250 2
a251 3
   *  - a specific global analyzer that computes global metrics specific to
   *    the script (based on script-specific characters to identify ascender
   *    height, x-height, etc.),
d253 2
a254 2
   *  - a specific glyph analyzer that computes segments and edges for each
   *    glyph covered by the script,
d256 6
a261 2
   *  - a specific grid-fitting algorithm that distorts the scaled glyph
   *    outline according to the results of the glyph analyzer.
d264 1
a264 7
#define AFWRTSYS_H_  /* don't load header files */
#undef  WRITING_SYSTEM
#define WRITING_SYSTEM( ws, WS )    \
          AF_WRITING_SYSTEM_ ## WS,

  /* The list of known writing systems. */
  typedef enum  AF_WritingSystem_
d266 7
d274 2
a275 1
#include "afwrtsys.h"
d277 1
a277 1
    AF_WRITING_SYSTEM_MAX   /* do not remove */
d279 1
a279 1
  } AF_WritingSystem;
a280 1
#undef  AFWRTSYS_H_
d282 1
d284 1
a284 1
  typedef struct  AF_WritingSystemClassRec_
d286 3
a288 1
    AF_WritingSystem  writing_system;
d290 1
a290 5
    FT_Offset                          style_metrics_size;
    AF_WritingSystem_InitMetricsFunc   style_metrics_init;
    AF_WritingSystem_ScaleMetricsFunc  style_metrics_scale;
    AF_WritingSystem_DoneMetricsFunc   style_metrics_done;
    AF_WritingSystem_GetStdWidthsFunc  style_metrics_getstdw;
a291 2
    AF_WritingSystem_InitHintsFunc     style_hints_init;
    AF_WritingSystem_ApplyHintsFunc    style_hints_apply;
d293 2
a294 20
  } AF_WritingSystemClassRec;

  typedef const AF_WritingSystemClassRec*  AF_WritingSystemClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                        S C R I P T S                          *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  Each script is associated with two sets of Unicode ranges to test
   *  whether the font face supports the script, and which non-base
   *  characters the script contains.
   *
   *  We use four-letter script tags from the OpenType specification,
   *  extended by `NONE', which indicates `no script'.
d296 3
d300 3
a302 3
#undef  SCRIPT
#define SCRIPT( s, S, d, h, H, ss ) \
          AF_SCRIPT_ ## S,
d304 2
a305 3
  /* The list of known scripts. */
  typedef enum  AF_Script_
  {
a306 1
#include "afscript.h"
d308 3
a310 1
    AF_SCRIPT_MAX   /* do not remove */
d312 4
a315 1
  } AF_Script;
d327 1
a327 1
  typedef const AF_Script_UniRangeRec*  AF_Script_UniRange;
d332 2
a333 1
    AF_Script  script;
d335 4
a338 3
    /* last element in the ranges must be { 0, 0 } */
    AF_Script_UniRange  script_uni_ranges;
    AF_Script_UniRange  script_uni_nonbase_ranges;
d340 2
a341 3
    FT_Bool  top_to_bottom_hinting;

    const char*  standard_charstring;      /* for default width and height */
d345 1
a345 137
  typedef const AF_ScriptClassRec*  AF_ScriptClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                      C O V E R A G E S                        *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  Usually, a font contains more glyphs than can be addressed by its
   *  character map.
   *
   *  In the PostScript font world, encoding vectors specific to a given
   *  task are used to select such glyphs, and these glyphs can be often
   *  recognized by having a suffix in its glyph names.  For example, a
   *  superscript glyph `A' might be called `A.sup'.  Unfortunately, this
   *  naming scheme is not standardized and thus unusable for us.
   *
   *  In the OpenType world, a better solution was invented, namely
   *  `features', which cleanly separate a character's input encoding from
   *  the corresponding glyph's appearance, and which don't use glyph names
   *  at all.  For our purposes, and slightly generalized, an OpenType
   *  feature is a name of a mapping that maps character codes to
   *  non-standard glyph indices (features get used for other things also).
   *  For example, the `sups' feature provides superscript glyphs, thus
   *  mapping character codes like `A' or `B' to superscript glyph
   *  representation forms.  How this mapping happens is completely
   *  uninteresting to us.
   *
   *  For the auto-hinter, a `coverage' represents all glyphs of an OpenType
   *  feature collected in a set (as listed below) that can be hinted
   *  together.  To continue the above example, superscript glyphs must not
   *  be hinted together with normal glyphs because the blue zones
   *  completely differ.
   *
   *  Note that FreeType itself doesn't compute coverages; it only provides
   *  the glyphs addressable by the default Unicode character map.  Instead,
   *  we use the HarfBuzz library (if available), which has many functions
   *  exactly for this purpose.
   *
   *  AF_COVERAGE_DEFAULT is special: It should cover everything that isn't
   *  listed separately (including the glyphs addressable by the character
   *  map).  In case HarfBuzz isn't available, it exactly covers the glyphs
   *  addressable by the character map.
   *
   */

#undef  COVERAGE
#define COVERAGE( name, NAME, description, \
                  tag1, tag2, tag3, tag4 ) \
          AF_COVERAGE_ ## NAME,


  typedef enum  AF_Coverage_
  {
#include "afcover.h"

    AF_COVERAGE_DEFAULT

  } AF_Coverage;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                         S T Y L E S                           *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  /*
   *  The topmost structure for modelling the auto-hinter glyph input data
   *  is a `style class', grouping everything together.
   */

#undef  STYLE
#define STYLE( s, S, d, ws, sc, ss, c ) \
          AF_STYLE_ ## S,

  /* The list of known styles. */
  typedef enum  AF_Style_
  {

#include "afstyles.h"

    AF_STYLE_MAX   /* do not remove */

  } AF_Style;


  typedef struct  AF_StyleClassRec_
  {
    AF_Style  style;

    AF_WritingSystem   writing_system;
    AF_Script          script;
    AF_Blue_Stringset  blue_stringset;
    AF_Coverage        coverage;

  } AF_StyleClassRec;

  typedef const AF_StyleClassRec*  AF_StyleClass;


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   S T Y L E   M E T R I C S                   *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  typedef struct AF_FaceGlobalsRec_*  AF_FaceGlobals;

  /* This is the main structure that combines everything.  Autofit modules */
  /* specific to writing systems derive their structures from it, for      */
  /* example `AF_LatinMetrics'.                                            */

  typedef struct  AF_StyleMetricsRec_
  {
    AF_StyleClass   style_class;
    AF_ScalerRec    scaler;
    FT_Bool         digits_have_same_width;

    AF_FaceGlobals  globals;    /* to access properties */

  } AF_StyleMetricsRec;


#define AF_HINTING_BOTTOM_TO_TOP  0
#define AF_HINTING_TOP_TO_BOTTOM  1


  /* Declare and define vtables for classes */
d348 2
a349 33
#define AF_DECLARE_WRITING_SYSTEM_CLASS( writing_system_class ) \
  FT_CALLBACK_TABLE const AF_WritingSystemClassRec              \
  writing_system_class;

#define AF_DEFINE_WRITING_SYSTEM_CLASS(                  \
          writing_system_class,                          \
          system,                                        \
          m_size,                                        \
          m_init,                                        \
          m_scale,                                       \
          m_done,                                        \
          m_stdw,                                        \
          h_init,                                        \
          h_apply )                                      \
  FT_CALLBACK_TABLE_DEF                                  \
  const AF_WritingSystemClassRec  writing_system_class = \
  {                                                      \
    system,                                              \
                                                         \
    m_size,                                              \
                                                         \
    m_init,                                              \
    m_scale,                                             \
    m_done,                                              \
    m_stdw,                                              \
                                                         \
    h_init,                                              \
    h_apply                                              \
  };


#define AF_DECLARE_SCRIPT_CLASS( script_class ) \
  FT_CALLBACK_TABLE const AF_ScriptClassRec     \
d352 16
a367 15
#define AF_DEFINE_SCRIPT_CLASS(           \
          script_class,                   \
          script,                         \
          ranges,                         \
          nonbase_ranges,                 \
          top_to_bottom,                  \
          std_charstring )                \
  FT_CALLBACK_TABLE_DEF                   \
  const AF_ScriptClassRec  script_class = \
  {                                       \
    script,                               \
    ranges,                               \
    nonbase_ranges,                       \
    top_to_bottom,                        \
    std_charstring,                       \
d370 1
d372 20
a391 50
#define AF_DECLARE_STYLE_CLASS( style_class ) \
  FT_CALLBACK_TABLE const AF_StyleClassRec    \
  style_class;

#define AF_DEFINE_STYLE_CLASS(          \
          style_class,                  \
          style,                        \
          writing_system,               \
          script,                       \
          blue_stringset,               \
          coverage )                    \
  FT_CALLBACK_TABLE_DEF                 \
  const AF_StyleClassRec  style_class = \
  {                                     \
    style,                              \
    writing_system,                     \
    script,                             \
    blue_stringset,                     \
    coverage                            \
  };

#else /* FT_CONFIG_OPTION_PIC */

#define AF_DECLARE_WRITING_SYSTEM_CLASS( writing_system_class )            \
  FT_LOCAL( void )                                                         \
  FT_Init_Class_ ## writing_system_class( AF_WritingSystemClassRec*  ac );

#define AF_DEFINE_WRITING_SYSTEM_CLASS(                                   \
          writing_system_class,                                           \
          system,                                                         \
          m_size,                                                         \
          m_init,                                                         \
          m_scale,                                                        \
          m_done,                                                         \
          h_init,                                                         \
          h_apply )                                                       \
  FT_LOCAL_DEF( void )                                                    \
  FT_Init_Class_ ## writing_system_class( AF_WritingSystemClassRec*  ac ) \
  {                                                                       \
    ac->writing_system        = system;                                   \
                                                                          \
    ac->style_metrics_size    = m_size;                                   \
                                                                          \
    ac->style_metrics_init    = m_init;                                   \
    ac->style_metrics_scale   = m_scale;                                  \
    ac->style_metrics_done    = m_done;                                   \
    ac->style_metrics_getstdw = m_stdw;                                   \
                                                                          \
    ac->style_hints_init      = h_init;                                   \
    ac->style_hints_apply     = h_apply;                                  \
d393 1
a393 46


#define AF_DECLARE_SCRIPT_CLASS( script_class )             \
  FT_LOCAL( void )                                          \
  FT_Init_Class_ ## script_class( AF_ScriptClassRec*  ac );

#define AF_DEFINE_SCRIPT_CLASS(                            \
          script_class,                                    \
          script_,                                         \
          ranges,                                          \
          nonbase_ranges,                                  \
          top_to_bottom,                                   \
          std_charstring )                                 \
  FT_LOCAL_DEF( void )                                     \
  FT_Init_Class_ ## script_class( AF_ScriptClassRec*  ac ) \
  {                                                        \
    ac->script                    = script_;               \
    ac->script_uni_ranges         = ranges;                \
    ac->script_uni_nonbase_ranges = nonbase_ranges;        \
    ac->top_to_bottom_hinting     = top_to_bottom;         \
    ac->standard_charstring       = std_charstring;        \
  }


#define AF_DECLARE_STYLE_CLASS( style_class )             \
  FT_LOCAL( void )                                        \
  FT_Init_Class_ ## style_class( AF_StyleClassRec*  ac );

#define AF_DEFINE_STYLE_CLASS(                           \
          style_class,                                   \
          style_,                                        \
          writing_system_,                               \
          script_,                                       \
          blue_stringset_,                               \
          coverage_ )                                    \
  FT_LOCAL_DEF( void )                                   \
  FT_Init_Class_ ## style_class( AF_StyleClassRec*  ac ) \
  {                                                      \
    ac->style          = style_;                         \
    ac->writing_system = writing_system_;                \
    ac->script         = script_;                        \
    ac->blue_stringset = blue_stringset_;                \
    ac->coverage       = coverage_;                      \
  }

#endif /* FT_CONFIG_OPTION_PIC */
d400 1
a400 1
#endif /* AFTYPES_H_ */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
