head	1.6;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.2
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.19.21.20;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F2723111C7BEE2;

1.5
date	2013.08.06.19.47.36;	author tg;	state Exp;
branches;
next	1.4;
commitid	100520152445E05B912;

1.4
date	2008.06.12.20.54.29;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	10048518C1E44F62885;

1.3
date	2008.02.26.20.04.50;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.36;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.55;	author bsiegert;	state Exp;
branches;
next	1.1.1.2;
commitid	10047C46DB5081DCD79;

1.1.1.2
date	2008.06.12.20.38.16;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004851887B4E012E38;

1.1.103.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.57;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.45;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.02;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.6
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  afloader.c                                                             */
/*                                                                         */
/*    Auto-fitter glyph loading routines (body).                           */
/*                                                                         */
/*  Copyright 2003-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include "afglobal.h"
#include "afloader.h"
#include "afhints.h"
#include "aferrors.h"
#include "afmodule.h"
#include "afpic.h"

#include FT_INTERNAL_CALC_H


  /* Initialize glyph loader. */

  FT_LOCAL_DEF( void )
  af_loader_init( AF_Loader      loader,
                  AF_GlyphHints  hints )
  {
    FT_ZERO( loader );

    loader->hints = hints;
  }


  /* Reset glyph loader and compute globals if necessary. */

  FT_LOCAL_DEF( FT_Error )
  af_loader_reset( AF_Loader  loader,
                   AF_Module  module,
                   FT_Face    face )
  {
    FT_Error  error = FT_Err_Ok;


    loader->face    = face;
    loader->globals = (AF_FaceGlobals)face->autohint.data;

    if ( !loader->globals )
    {
      error = af_face_globals_new( face, &loader->globals, module );
      if ( !error )
      {
        face->autohint.data =
          (FT_Pointer)loader->globals;
        face->autohint.finalizer =
          (FT_Generic_Finalizer)af_face_globals_free;
      }
    }

    return error;
  }


  /* Finalize glyph loader. */

  FT_LOCAL_DEF( void )
  af_loader_done( AF_Loader  loader )
  {
    loader->face    = NULL;
    loader->globals = NULL;
    loader->hints   = NULL;
  }


#define af_intToFixed( i ) \
          ( (FT_Fixed)( (FT_UInt32)(i) << 16 ) )
#define af_fixedToInt( x ) \
          ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
#define af_floatToFixed( f ) \
          ( (FT_Fixed)( (f) * 65536.0 + 0.5 ) )


  static FT_Error
  af_loader_embolden_glyph_in_slot( AF_Loader        loader,
                                    FT_Face          face,
                                    AF_StyleMetrics  style_metrics )
  {
    FT_Error  error = FT_Err_Ok;

    FT_GlyphSlot           slot    = face->glyph;
    AF_FaceGlobals         globals = loader->globals;
    AF_WritingSystemClass  writing_system_class;

    FT_Pos  stdVW = 0;
    FT_Pos  stdHW = 0;

    FT_Bool  size_changed = face->size->metrics.x_ppem
                              != globals->stem_darkening_for_ppem;

    FT_Fixed  em_size  = af_intToFixed( face->units_per_EM );
    FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );

    FT_Matrix  scale_down_matrix = { 0x10000L, 0, 0, 0x10000L };


    /* Skip stem darkening for broken fonts. */
    if ( !face->units_per_EM )
    {
      error = FT_Err_Corrupted_Font_Header;
      goto Exit;
    }

    /*
     *  We depend on the writing system (script analyzers) to supply
     *  standard widths for the script of the glyph we are looking at.  If
     *  it can't deliver, stem darkening is disabled.
     */
    writing_system_class =
      AF_WRITING_SYSTEM_CLASSES_GET[style_metrics->style_class->writing_system];

    if ( writing_system_class->style_metrics_getstdw )
      writing_system_class->style_metrics_getstdw( style_metrics,
                                                   &stdHW,
                                                   &stdVW );
    else
    {
      error = FT_Err_Unimplemented_Feature;
      goto Exit;
    }

    if ( size_changed                                               ||
         ( stdVW > 0 && stdVW != globals->standard_vertical_width ) )
    {
      FT_Fixed  darken_by_font_units_x, darken_x;


      darken_by_font_units_x =
        af_intToFixed( af_loader_compute_darkening( loader,
                                                    face,
                                                    stdVW ) );
      darken_x = FT_DivFix( FT_MulFix( darken_by_font_units_x,
                                       face->size->metrics.x_scale ),
                            em_ratio );

      globals->standard_vertical_width = stdVW;
      globals->stem_darkening_for_ppem = face->size->metrics.x_ppem;
      globals->darken_x                = af_fixedToInt( darken_x );
    }

    if ( size_changed                                                 ||
         ( stdHW > 0 && stdHW != globals->standard_horizontal_width ) )
    {
      FT_Fixed  darken_by_font_units_y, darken_y;


      darken_by_font_units_y =
        af_intToFixed( af_loader_compute_darkening( loader,
                                                    face,
                                                    stdHW ) );
      darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,
                                       face->size->metrics.y_scale ),
                            em_ratio );

      globals->standard_horizontal_width = stdHW;
      globals->stem_darkening_for_ppem   = face->size->metrics.x_ppem;
      globals->darken_y                  = af_fixedToInt( darken_y );

      /*
       *  Scale outlines down on the Y-axis to keep them inside their blue
       *  zones.  The stronger the emboldening, the stronger the downscaling
       *  (plus heuristical padding to prevent outlines still falling out
       *  their zones due to rounding).
       *
       *  Reason: `FT_Outline_Embolden' works by shifting the rightmost
       *  points of stems farther to the right, and topmost points farther
       *  up.  This positions points on the Y-axis outside their
       *  pre-computed blue zones and leads to distortion when applying the
       *  hints in the code further below.  Code outside this emboldening
       *  block doesn't know we are presenting it with modified outlines the
       *  analyzer didn't see!
       *
       *  An unfortunate side effect of downscaling is that the emboldening
       *  effect is slightly decreased.  The loss becomes more pronounced
       *  versus the CFF driver at smaller sizes, e.g., at 9ppem and below.
       */
      globals->scale_down_factor =
        FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
                   em_size );
    }

    FT_Outline_EmboldenXY( &slot->outline,
                           globals->darken_x,
                           globals->darken_y );

    scale_down_matrix.yy = globals->scale_down_factor;
    FT_Outline_Transform( &slot->outline, &scale_down_matrix );

  Exit:
    return error;
  }


  /* Load the glyph at index into the current slot of a face and hint it. */

  FT_LOCAL_DEF( FT_Error )
  af_loader_load_glyph( AF_Loader  loader,
                        AF_Module  module,
                        FT_Face    face,
                        FT_UInt    glyph_index,
                        FT_Int32   load_flags )
  {
    FT_Error  error;

    FT_Size           size     = face->size;
    FT_GlyphSlot      slot     = face->glyph;
    FT_Slot_Internal  internal = slot->internal;
    FT_GlyphLoader    gloader  = internal->loader;

    AF_GlyphHints          hints          = loader->hints;
    AF_ScalerRec           scaler;
    AF_StyleMetrics        style_metrics;
    FT_UInt                style_options  = AF_STYLE_NONE_DFLT;
    AF_StyleClass          style_class;
    AF_WritingSystemClass  writing_system_class;

#ifdef FT_CONFIG_OPTION_PIC
    AF_FaceGlobals  globals = loader->globals;
#endif


    if ( !size )
      return FT_THROW( Invalid_Size_Handle );

    FT_ZERO( &scaler );

    /*
     *  TODO: This code currently doesn't support fractional advance widths,
     *  i.e.  placing hinted glyphs at anything other than integer
     *  x-positions.  This is only relevant for the warper code, which
     *  scales and shifts glyphs to optimize blackness of stems (hinting on
     *  the x-axis by nature places things on pixel integers, hinting on the
     *  y-axis only, i.e.  LIGHT mode, doesn't touch the x-axis).  The delta
     *  values of the scaler would need to be adjusted.
     */
    scaler.face    = face;
    scaler.x_scale = size->metrics.x_scale;
    scaler.x_delta = 0;
    scaler.y_scale = size->metrics.y_scale;
    scaler.y_delta = 0;

    scaler.render_mode = FT_LOAD_TARGET_MODE( load_flags );
    scaler.flags       = 0;

    error = af_loader_reset( loader, module, face );
    if ( error )
      goto Exit;

#ifdef FT_OPTION_AUTOFIT2
    /* XXX: undocumented hook to activate the latin2 writing system. */
    if ( load_flags & ( 1UL << 20 ) )
      style_options = AF_STYLE_LTN2_DFLT;
#endif

    /*
     *  Glyphs (really code points) are assigned to scripts.  Script
     *  analysis is done lazily: For each glyph that passes through here,
     *  the corresponding script analyzer is called, but returns immediately
     *  if it has been run already.
     */
    error = af_face_globals_get_metrics( loader->globals, glyph_index,
                                         style_options, &style_metrics );
    if ( error )
      goto Exit;

    style_class          = style_metrics->style_class;
    writing_system_class =
      AF_WRITING_SYSTEM_CLASSES_GET[style_class->writing_system];

    loader->metrics = style_metrics;

    if ( writing_system_class->style_metrics_scale )
      writing_system_class->style_metrics_scale( style_metrics, &scaler );
    else
      style_metrics->scaler = scaler;

    if ( writing_system_class->style_hints_init )
    {
      error = writing_system_class->style_hints_init( hints,
                                                      style_metrics );
      if ( error )
        goto Exit;
    }

    /*
     *  Do the main work of `af_loader_load_glyph'.  Note that we never have
     *  to deal with composite glyphs as those get loaded into
     *  FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph' function.
     *  In the rare cases where FT_LOAD_NO_RECURSE is set, it implies
     *  FT_LOAD_NO_SCALE and as such the auto-hinter is never called.
     */
    load_flags |=  FT_LOAD_NO_SCALE         |
                   FT_LOAD_IGNORE_TRANSFORM |
                   FT_LOAD_LINEAR_DESIGN;
    load_flags &= ~FT_LOAD_RENDER;

    error = FT_Load_Glyph( face, glyph_index, load_flags );
    if ( error )
      goto Exit;

    /*
     *  Apply stem darkening (emboldening) here before hints are applied to
     *  the outline.  Glyphs are scaled down proportionally to the
     *  emboldening so that curve points don't fall outside their
     *  precomputed blue zones.
     *
     *  Any emboldening done by the font driver (e.g., the CFF driver)
     *  doesn't reach here because the autohinter loads the unprocessed
     *  glyphs in font units for analysis (functions `af_*_metrics_init_*')
     *  and then above to prepare it for the rasterizers by itself,
     *  independently of the font driver.  So emboldening must be done here,
     *  within the autohinter.
     *
     *  All glyphs to be autohinted pass through here one by one.  The
     *  standard widths can therefore change from one glyph to the next,
     *  depending on what script a glyph is assigned to (each script has its
     *  own set of standard widths and other metrics).  The darkening amount
     *  must therefore be recomputed for each size and
     *  `standard_{vertical,horizontal}_width' change.
     *
     *  Ignore errors and carry on without emboldening.
     */
    if ( !module->no_stem_darkening )
      af_loader_embolden_glyph_in_slot( loader, face, style_metrics );

    loader->transformed = internal->glyph_transformed;
    if ( loader->transformed )
    {
      FT_Matrix  inverse;


      loader->trans_matrix = internal->glyph_matrix;
      loader->trans_delta  = internal->glyph_delta;

      inverse = loader->trans_matrix;
      if ( !FT_Matrix_Invert( &inverse ) )
        FT_Vector_Transform( &loader->trans_delta, &inverse );
    }

    switch ( slot->format )
    {
    case FT_GLYPH_FORMAT_OUTLINE:
      /* translate the loaded glyph when an internal transform is needed */
      if ( loader->transformed )
        FT_Outline_Translate( &slot->outline,
                              loader->trans_delta.x,
                              loader->trans_delta.y );

      /* compute original horizontal phantom points */
      /* (and ignore vertical ones)                 */
      loader->pp1.x = hints->x_delta;
      loader->pp1.y = hints->y_delta;
      loader->pp2.x = FT_MulFix( slot->metrics.horiAdvance,
                                 hints->x_scale ) + hints->x_delta;
      loader->pp2.y = hints->y_delta;

      /* be sure to check for spacing glyphs */
      if ( slot->outline.n_points == 0 )
        goto Hint_Metrics;

      /* now load the slot image into the auto-outline */
      /* and run the automatic hinting process         */
      {
#ifdef FT_CONFIG_OPTION_PIC
        AF_FaceGlobals  globals = loader->globals;
#endif


        if ( writing_system_class->style_hints_apply )
          writing_system_class->style_hints_apply( glyph_index,
                                                   hints,
                                                   &gloader->base.outline,
                                                   style_metrics );
      }

      /* we now need to adjust the metrics according to the change in */
      /* width/positioning that occurred during the hinting process   */
      if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
      {
        FT_Pos  old_rsb, old_lsb, new_lsb;
        FT_Pos  pp1x_uh, pp2x_uh;

        AF_AxisHints  axis  = &hints->axis[AF_DIMENSION_HORZ];
        AF_Edge       edge1 = axis->edges;         /* leftmost edge  */
        AF_Edge       edge2 = edge1 +
                              axis->num_edges - 1; /* rightmost edge */


        if ( axis->num_edges > 1 && AF_HINTS_DO_ADVANCE( hints ) )
        {
          old_rsb = loader->pp2.x - edge2->opos;
          /* loader->pp1.x is always zero at this point of time */
          old_lsb = edge1->opos /* - loader->pp1.x */;
          new_lsb = edge1->pos;

          pp1x_uh = new_lsb    - old_lsb;
          pp2x_uh = edge2->pos + old_rsb;

          /* prefer too much space over too little space */
          /* for very small sizes                        */

          if ( old_lsb < 24 )
            pp1x_uh -= 8;

          if ( old_rsb < 24 )
            pp2x_uh += 8;

          loader->pp1.x = FT_PIX_ROUND( pp1x_uh );
          loader->pp2.x = FT_PIX_ROUND( pp2x_uh );

          if ( loader->pp1.x >= new_lsb && old_lsb > 0 )
            loader->pp1.x -= 64;

          if ( loader->pp2.x <= edge2->pos && old_rsb > 0 )
            loader->pp2.x += 64;

          slot->lsb_delta = loader->pp1.x - pp1x_uh;
          slot->rsb_delta = loader->pp2.x - pp2x_uh;
        }
        else
        {
          FT_Pos  pp1x = loader->pp1.x;
          FT_Pos  pp2x = loader->pp2.x;


          loader->pp1.x = FT_PIX_ROUND( pp1x );
          loader->pp2.x = FT_PIX_ROUND( pp2x );

          slot->lsb_delta = loader->pp1.x - pp1x;
          slot->rsb_delta = loader->pp2.x - pp2x;
        }
      }
      else
      {
        FT_Pos  pp1x = loader->pp1.x;
        FT_Pos  pp2x = loader->pp2.x;


        loader->pp1.x = FT_PIX_ROUND( pp1x + hints->xmin_delta );
        loader->pp2.x = FT_PIX_ROUND( pp2x + hints->xmax_delta );

        slot->lsb_delta = loader->pp1.x - pp1x;
        slot->rsb_delta = loader->pp2.x - pp2x;
      }

      break;

    default:
      /* we don't support other formats (yet?) */
      error = FT_THROW( Unimplemented_Feature );
    }

  Hint_Metrics:
    {
      FT_BBox    bbox;
      FT_Vector  vvector;


      vvector.x = slot->metrics.vertBearingX - slot->metrics.horiBearingX;
      vvector.y = slot->metrics.vertBearingY - slot->metrics.horiBearingY;
      vvector.x = FT_MulFix( vvector.x, style_metrics->scaler.x_scale );
      vvector.y = FT_MulFix( vvector.y, style_metrics->scaler.y_scale );

      /* transform the hinted outline if needed */
      if ( loader->transformed )
      {
        FT_Outline_Transform( &gloader->base.outline, &loader->trans_matrix );
        FT_Vector_Transform( &vvector, &loader->trans_matrix );
      }

      /* we must translate our final outline by -pp1.x and compute */
      /* the new metrics                                           */
      if ( loader->pp1.x )
        FT_Outline_Translate( &gloader->base.outline, -loader->pp1.x, 0 );

      FT_Outline_Get_CBox( &gloader->base.outline, &bbox );

      bbox.xMin = FT_PIX_FLOOR( bbox.xMin );
      bbox.yMin = FT_PIX_FLOOR( bbox.yMin );
      bbox.xMax = FT_PIX_CEIL(  bbox.xMax );
      bbox.yMax = FT_PIX_CEIL(  bbox.yMax );

      slot->metrics.width        = bbox.xMax - bbox.xMin;
      slot->metrics.height       = bbox.yMax - bbox.yMin;
      slot->metrics.horiBearingX = bbox.xMin;
      slot->metrics.horiBearingY = bbox.yMax;

      slot->metrics.vertBearingX = FT_PIX_FLOOR( bbox.xMin + vvector.x );
      slot->metrics.vertBearingY = FT_PIX_FLOOR( bbox.yMax + vvector.y );

      /* for mono-width fonts (like Andale, Courier, etc.) we need */
      /* to keep the original rounded advance width; ditto for     */
      /* digits if all have the same advance width                 */
      if ( scaler.render_mode != FT_RENDER_MODE_LIGHT                       &&
           ( FT_IS_FIXED_WIDTH( slot->face )                              ||
             ( af_face_globals_is_digit( loader->globals, glyph_index ) &&
               style_metrics->digits_have_same_width                    ) ) )
      {
        slot->metrics.horiAdvance =
          FT_MulFix( slot->metrics.horiAdvance,
                     style_metrics->scaler.x_scale );

        /* Set delta values to 0.  Otherwise code that uses them is */
        /* going to ruin the fixed advance width.                   */
        slot->lsb_delta = 0;
        slot->rsb_delta = 0;
      }
      else
      {
        /* non-spacing glyphs must stay as-is */
        if ( slot->metrics.horiAdvance )
          slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      }

      slot->metrics.vertAdvance = FT_MulFix( slot->metrics.vertAdvance,
                                             style_metrics->scaler.y_scale );

      slot->metrics.horiAdvance = FT_PIX_ROUND( slot->metrics.horiAdvance );
      slot->metrics.vertAdvance = FT_PIX_ROUND( slot->metrics.vertAdvance );

      slot->format  = FT_GLYPH_FORMAT_OUTLINE;
    }

  Exit:
    return error;
  }


  /*
   * Compute amount of font units the face should be emboldened by, in
   * analogy to the CFF driver's `cf2_computeDarkening' function.  See there
   * for details of the algorithm.
   *
   * XXX: Currently a crude adaption of the original algorithm.  Do better?
   */
  FT_LOCAL_DEF( FT_Int32 )
  af_loader_compute_darkening( AF_Loader  loader,
                               FT_Face    face,
                               FT_Pos     standard_width )
  {
    AF_Module  module = loader->globals->module;

    FT_UShort  units_per_EM;
    FT_Fixed   ppem, em_ratio;
    FT_Fixed   stem_width, stem_width_per_1000, scaled_stem, darken_amount;
    FT_Int     log_base_2;
    FT_Int     x1, y1, x2, y2, x3, y3, x4, y4;


    ppem         = FT_MAX( af_intToFixed( 4 ),
                           af_intToFixed( face->size->metrics.x_ppem ) );
    units_per_EM = face->units_per_EM;

    em_ratio = FT_DivFix( af_intToFixed( 1000 ),
                          af_intToFixed ( units_per_EM ) );
    if ( em_ratio < af_floatToFixed( .01 ) )
    {
      /* If something goes wrong, don't embolden. */
      return 0;
    }

    x1 = module->darken_params[0];
    y1 = module->darken_params[1];
    x2 = module->darken_params[2];
    y2 = module->darken_params[3];
    x3 = module->darken_params[4];
    y3 = module->darken_params[5];
    x4 = module->darken_params[6];
    y4 = module->darken_params[7];

    if ( standard_width <= 0 )
    {
      stem_width          = af_intToFixed( 75 ); /* taken from cf2font.c */
      stem_width_per_1000 = stem_width;
    }
    else
    {
      stem_width          = af_intToFixed( standard_width );
      stem_width_per_1000 = FT_MulFix( stem_width, em_ratio );
    }

    log_base_2 = FT_MSB( (FT_UInt32)stem_width_per_1000 ) +
                 FT_MSB( (FT_UInt32)ppem );

    if ( log_base_2 >= 46 )
    {
      /* possible overflow */
      scaled_stem = af_intToFixed( x4 );
    }
    else
      scaled_stem = FT_MulFix( stem_width_per_1000, ppem );

    /* now apply the darkening parameters */
    if ( scaled_stem < af_intToFixed( x1 ) )
      darken_amount = FT_DivFix( af_intToFixed( y1 ), ppem );

    else if ( scaled_stem < af_intToFixed( x2 ) )
    {
      FT_Int  xdelta = x2 - x1;
      FT_Int  ydelta = y2 - y1;
      FT_Int  x      = stem_width_per_1000 -
                       FT_DivFix( af_intToFixed( x1 ), ppem );


      if ( !xdelta )
        goto Try_x3;

      darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                      FT_DivFix( af_intToFixed( y1 ), ppem );
    }

    else if ( scaled_stem < af_intToFixed( x3 ) )
    {
    Try_x3:
      {
        FT_Int  xdelta = x3 - x2;
        FT_Int  ydelta = y3 - y2;
        FT_Int  x      = stem_width_per_1000 -
                         FT_DivFix( af_intToFixed( x2 ), ppem );


        if ( !xdelta )
          goto Try_x4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( af_intToFixed( y2 ), ppem );
      }
    }

    else if ( scaled_stem < af_intToFixed( x4 ) )
    {
    Try_x4:
      {
        FT_Int  xdelta = x4 - x3;
        FT_Int  ydelta = y4 - y3;
        FT_Int  x      = stem_width_per_1000 -
                         FT_DivFix( af_intToFixed( x3 ), ppem );


        if ( !xdelta )
          goto Use_y4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( af_intToFixed( y3 ), ppem );
      }
    }

    else
    {
    Use_y4:
      darken_amount = FT_DivFix( af_intToFixed( y4 ), ppem );
    }

    /* Convert darken_amount from per 1000 em to true character space. */
    return af_fixedToInt( FT_DivFix( darken_amount, em_ratio ) );
  }


/* END */
@


1.5
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
d19 1
a21 1
#include "afglobal.h"
d23 4
d29 5
a33 3
  FT_LOCAL_DEF( FT_Error )
  af_loader_init( AF_Loader  loader,
                  FT_Memory  memory )
d37 1
a37 5
    af_glyph_hints_init( &loader->hints, memory );
#ifdef AF_DEBUG
    _af_debug_hints = &loader->hints;
#endif
    return FT_GlyphLoader_New( memory, &loader->gloader );
d41 2
d45 1
d48 1
a48 1
    FT_Error  error = AF_Err_Ok;
d54 1
a54 3
    FT_GlyphLoader_Rewind( loader->gloader );

    if ( loader->globals == NULL )
d56 1
a56 1
      error = af_face_globals_new( face, &loader->globals );
d70 2
a74 2
    af_glyph_hints_done( &loader->hints );

d77 28
d106 100
a205 5
#ifdef AF_DEBUG
    _af_debug_hints = NULL;
#endif
    FT_GlyphLoader_Done( loader->gloader );
    loader->gloader = NULL;
d209 8
a216 6
  static FT_Error
  af_loader_load_g( AF_Loader  loader,
                    AF_Scaler  scaler,
                    FT_UInt    glyph_index,
                    FT_Int32   load_flags,
                    FT_UInt    depth )
d218 3
a220 5
    FT_Error          error;
    FT_Face           face     = loader->face;
    FT_GlyphLoader    gloader  = loader->gloader;
    AF_ScriptMetrics  metrics  = loader->metrics;
    AF_GlyphHints     hints    = &loader->hints;
d223 76
d300 11
d316 25
d351 2
a352 2
      FT_Matrix_Invert( &inverse );
      FT_Vector_Transform( &loader->trans_delta, &inverse );
a354 4
    /* set linear metrics */
    slot->linearHoriAdvance = slot->metrics.horiAdvance;
    slot->linearVertAdvance = slot->metrics.vertAdvance;

d364 2
a365 25
      /* copy the outline points in the loader's current               */
      /* extra points which is used to keep original glyph coordinates */
      error = FT_GLYPHLOADER_CHECK_POINTS( gloader,
                                           slot->outline.n_points + 4,
                                           slot->outline.n_contours );
      if ( error )
        goto Exit;

      FT_ARRAY_COPY( gloader->current.outline.points,
                     slot->outline.points,
                     slot->outline.n_points );

      FT_ARRAY_COPY( gloader->current.outline.contours,
                     slot->outline.contours,
                     slot->outline.n_contours );

      FT_ARRAY_COPY( gloader->current.outline.tags,
                     slot->outline.tags,
                     slot->outline.n_points );

      gloader->current.outline.n_points   = slot->outline.n_points;
      gloader->current.outline.n_contours = slot->outline.n_contours;

      /* compute original horizontal phantom points (and ignore */
      /* vertical ones)                                         */
d376 2
a377 10
      /* now load the slot image into the auto-outline and run the */
      /* automatic hinting process                                 */
      if ( metrics->clazz->script_hints_apply )
        metrics->clazz->script_hints_apply( hints,
                                            &gloader->current.outline,
                                            metrics );

      /* we now need to hint the metrics according to the change in */
      /* width/positioning that occurred during the hinting process */
      if ( scaler->render_mode != FT_RENDER_MODE_LIGHT )
d379 19
a397 2
        FT_Pos        old_rsb, old_lsb, new_lsb;
        FT_Pos        pp1x_uh, pp2x_uh;
d407 2
a408 1
          old_lsb = edge1->opos;
a410 3
          /* remember unhinted values to later account */
          /* for rounding errors                       */

a460 127
      /* good, we simply add the glyph to our loader's base */
      FT_GlyphLoader_Add( gloader );
      break;

    case FT_GLYPH_FORMAT_COMPOSITE:
      {
        FT_UInt      nn, num_subglyphs = slot->num_subglyphs;
        FT_UInt      num_base_subgs, start_point;
        FT_SubGlyph  subglyph;


        start_point = gloader->base.outline.n_points;

        /* first of all, copy the subglyph descriptors in the glyph loader */
        error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs );
        if ( error )
          goto Exit;

        FT_ARRAY_COPY( gloader->current.subglyphs,
                       slot->subglyphs,
                       num_subglyphs );

        gloader->current.num_subglyphs = num_subglyphs;
        num_base_subgs                 = gloader->base.num_subglyphs;

        /* now, read each subglyph independently */
        for ( nn = 0; nn < num_subglyphs; nn++ )
        {
          FT_Vector  pp1, pp2;
          FT_Pos     x, y;
          FT_UInt    num_points, num_new_points, num_base_points;


          /* gloader.current.subglyphs can change during glyph loading due */
          /* to re-allocation -- we must recompute the current subglyph on */
          /* each iteration                                                */
          subglyph = gloader->base.subglyphs + num_base_subgs + nn;

          pp1 = loader->pp1;
          pp2 = loader->pp2;

          num_base_points = gloader->base.outline.n_points;

          error = af_loader_load_g( loader, scaler, subglyph->index,
                                    load_flags, depth + 1 );
          if ( error )
            goto Exit;

          /* recompute subglyph pointer */
          subglyph = gloader->base.subglyphs + num_base_subgs + nn;

          if ( subglyph->flags & FT_SUBGLYPH_FLAG_USE_MY_METRICS )
          {
            pp1 = loader->pp1;
            pp2 = loader->pp2;
          }
          else
          {
            loader->pp1 = pp1;
            loader->pp2 = pp2;
          }

          num_points     = gloader->base.outline.n_points;
          num_new_points = num_points - num_base_points;

          /* now perform the transform required for this subglyph */

          if ( subglyph->flags & ( FT_SUBGLYPH_FLAG_SCALE    |
                                   FT_SUBGLYPH_FLAG_XY_SCALE |
                                   FT_SUBGLYPH_FLAG_2X2      ) )
          {
            FT_Vector*  cur   = gloader->base.outline.points +
                                num_base_points;
            FT_Vector*  limit = cur + num_new_points;


            for ( ; cur < limit; cur++ )
              FT_Vector_Transform( cur, &subglyph->transform );
          }

          /* apply offset */

          if ( !( subglyph->flags & FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES ) )
          {
            FT_Int      k = subglyph->arg1;
            FT_UInt     l = subglyph->arg2;
            FT_Vector*  p1;
            FT_Vector*  p2;


            if ( start_point + k >= num_base_points         ||
                               l >= (FT_UInt)num_new_points )
            {
              error = AF_Err_Invalid_Composite;
              goto Exit;
            }

            l += num_base_points;

            /* for now, only use the current point coordinates;    */
            /* we may consider another approach in the near future */
            p1 = gloader->base.outline.points + start_point + k;
            p2 = gloader->base.outline.points + start_point + l;

            x = p1->x - p2->x;
            y = p1->y - p2->y;
          }
          else
          {
            x = FT_MulFix( subglyph->arg1, hints->x_scale ) + hints->x_delta;
            y = FT_MulFix( subglyph->arg2, hints->y_scale ) + hints->y_delta;

            x = FT_PIX_ROUND( x );
            y = FT_PIX_ROUND( y );
          }

          {
            FT_Outline  dummy = gloader->base.outline;


            dummy.points  += num_base_points;
            dummy.n_points = (short)num_new_points;

            FT_Outline_Translate( &dummy, x, y );
          }
        }
      }
d465 1
a465 1
      error = AF_Err_Unimplemented_Feature;
a468 1
    if ( depth == 0 )
d476 2
a477 2
      vvector.x = FT_MulFix( vvector.x, metrics->scaler.x_scale );
      vvector.y = FT_MulFix( vvector.y, metrics->scaler.y_scale );
d485 1
a485 1
#if 1
d490 1
a490 1
#endif
d509 4
a512 10
#if 0
      if ( !FT_IS_FIXED_WIDTH( slot->face ) )
        slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      else
        slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,
                                               x_scale );
#else
      if ( FT_IS_FIXED_WIDTH( slot->face )                              ||
           ( af_face_globals_is_digit( loader->globals, glyph_index ) &&
             metrics->digits_have_same_width                          ) )
d514 3
a516 2
        slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,
                                               metrics->scaler.x_scale );
a528 1
#endif
d531 1
a531 1
                                              metrics->scaler.y_scale );
a535 7
      /* now copy outline into glyph slot */
      FT_GlyphLoader_Rewind( internal->loader );
      error = FT_GlyphLoader_CopyPoints( internal->loader, gloader );
      if ( error )
        goto Exit;

      slot->outline = internal->loader->base.outline;
a538 4
#ifdef DEBUG_HINTER
    af_debug_hinter = hinter;
#endif

d544 11
a554 5
  FT_LOCAL_DEF( FT_Error )
  af_loader_load_glyph( AF_Loader  loader,
                        FT_Face    face,
                        FT_UInt    gindex,
                        FT_UInt32  load_flags )
d556 20
a575 3
    FT_Error      error;
    FT_Size       size = face->size;
    AF_ScalerRec  scaler;
d577 8
d586 10
a595 2
    if ( !size )
      return AF_Err_Invalid_Argument;
d597 2
a598 1
    FT_ZERO( &scaler );
d600 7
a606 5
    scaler.face    = face;
    scaler.x_scale = size->metrics.x_scale;
    scaler.x_delta = 0;  /* XXX: TODO: add support for sub-pixel hinting */
    scaler.y_scale = size->metrics.y_scale;
    scaler.y_delta = 0;  /* XXX: TODO: add support for sub-pixel hinting */
d608 3
a610 2
    scaler.render_mode = FT_LOAD_TARGET_MODE( load_flags );
    scaler.flags       = 0;  /* XXX: fix this */
d612 1
a612 2
    error = af_loader_reset( loader, face );
    if ( !error )
d614 4
a617 2
      AF_ScriptMetrics  metrics;
      FT_UInt           options = 0;
d620 6
a625 5
#ifdef FT_OPTION_AUTOFIT2
      /* XXX: undocumented hook to activate the latin2 hinter */
      if ( load_flags & ( 1UL << 20 ) )
        options = 2;
#endif
d627 3
a629 3
      error = af_face_globals_get_metrics( loader->globals, gindex,
                                           options, &metrics );
      if ( !error )
d631 5
a635 1
        loader->metrics = metrics;
d637 16
a652 4
        if ( metrics->clazz->script_metrics_scale )
          metrics->clazz->script_metrics_scale( metrics, &scaler );
        else
          metrics->scaler = scaler;
a653 2
        load_flags |=  FT_LOAD_NO_SCALE | FT_LOAD_IGNORE_TRANSFORM;
        load_flags &= ~FT_LOAD_RENDER;
d655 2
a656 7
        if ( metrics->clazz->script_hints_init )
        {
          error = metrics->clazz->script_hints_init( &loader->hints,
                                                     metrics );
          if ( error )
            goto Exit;
        }
d658 2
a659 1
        error = af_loader_load_g( loader, &scaler, gindex, load_flags, 0 );
d662 9
a670 2
  Exit:
    return error;
@


1.4
log
@Merge freetype 2.3.6
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008 by                        */
a21 1
#include "aflatin.h"
d186 3
a188 3
          old_rsb     = loader->pp2.x - edge2->opos;
          old_lsb     = edge1->opos;
          new_lsb     = edge1->pos;
d219 3
a221 2
          FT_Pos   pp1x = loader->pp1.x;
          FT_Pos   pp2x = loader->pp2.x;
d232 3
a234 2
        FT_Pos   pp1x = loader->pp1.x;
        FT_Pos   pp2x = loader->pp2.x;
d417 2
a418 1
      /* to keep the original rounded advance width                */
d426 3
a428 7
      if ( !FT_IS_FIXED_WIDTH( slot->face ) )
      {
        /* non-spacing glyphs must stay as-is */
        if ( slot->metrics.horiAdvance )
          slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      }
      else
d438 6
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
d168 4
a171 3
      metrics->clazz->script_hints_apply( hints,
                                          &gloader->current.outline,
                                          metrics );
d519 7
a525 3
        error = metrics->clazz->script_hints_init( &loader->hints, metrics );
        if ( error )
          goto Exit;
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d33 3
a35 1

d76 3
d173 2
a174 1
      /* width/positioning that occured during the hinting process  */
d176 1
a176 2
#ifndef AF_USE_WARPER
        FT_Pos        old_advance, old_rsb, old_lsb, new_lsb;
d186 1
a186 2
          old_advance = loader->pp2.x;
          old_rsb     = old_advance - edge2->opos;
d200 1
a200 1
            pp1x_uh -= 5;
d203 1
a203 1
            pp2x_uh += 5;
d208 6
a217 1
#endif /* !AF_USE_WARPER */
d222 2
a223 2
          loader->pp1.x = FT_PIX_ROUND( loader->pp1.x );
          loader->pp2.x = FT_PIX_ROUND( loader->pp2.x );
d229 11
d393 1
a393 1

d398 1
a398 1

d424 5
a428 1
        slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
d430 1
d433 6
d495 1
d498 6
d505 1
a505 1
                                           &metrics );
@


1.1
log
@Initial revision
@
text
@d1 18
d23 2
a29 2
    FT_Error  error;

d34 1
a34 11
    error = FT_GlyphLoader_New( memory, &loader->gloader );
    if ( !error )
    {
      error = FT_GlyphLoader_CreateExtra( loader->gloader );
      if ( error )
      {
        FT_GlyphLoader_Done( loader->gloader );
        loader->gloader = NULL;
      }
    }
    return error;
d39 2
a40 2
  af_loader_reset( AF_Loader   loader,
                   FT_Face     face )
d42 2
a43 1
    FT_Error   error = 0;
d46 1
a46 1
    loader->globals = (AF_FaceGlobals) face->autohint.data;
d55 4
a58 2
        face->autohint.data      = (FT_Pointer) loader->globals;
        face->autohint.finalizer = (FT_Generic_Finalizer) af_face_globals_free;
d61 1
d67 1
a67 1
  af_loader_done( AF_Loader   loader )
d69 2
d86 1
a86 1
    FT_Error          error    = 0;
d94 1
d104 1
d119 14
a132 8
      case FT_GLYPH_FORMAT_OUTLINE:
       /* translate the loaded glyph when an internal transform
        * is needed
        */
        if ( loader->transformed )
        {
          FT_Vector*  point = slot->outline.points;
          FT_Vector*  limit = point + slot->outline.n_points;
d134 32
a165 6
          for ( ; point < limit; point++ )
          {
            point->x += loader->trans_delta.x;
            point->y += loader->trans_delta.y;
          }
        }
d167 10
a176 7
        /* copy the outline points in the loader's current               */
        /* extra points which is used to keep original glyph coordinates */
        error = FT_GlyphLoader_CheckPoints( gloader,
                                            slot->outline.n_points + 4,
                                            slot->outline.n_contours );
        if ( error )
          goto Exit;
a177 38
        FT_ARRAY_COPY( gloader->current.outline.points,
                       slot->outline.points,
                       slot->outline.n_points );

        FT_ARRAY_COPY( gloader->current.extra_points,
                       slot->outline.points,
                       slot->outline.n_points );

        FT_ARRAY_COPY( gloader->current.outline.contours,
                       slot->outline.contours,
                       slot->outline.n_contours );

        FT_ARRAY_COPY( gloader->current.outline.tags,
                       slot->outline.tags,
                       slot->outline.n_points );

        gloader->current.outline.n_points   = slot->outline.n_points;
        gloader->current.outline.n_contours = slot->outline.n_contours;

        /* compute original horizontal phantom points (and ignore */
        /* vertical ones)                                         */
        loader->pp1.x = hints->x_delta;
        loader->pp1.y = hints->y_delta;
        loader->pp2.x = FT_MulFix( slot->metrics.horiAdvance,
                                   hints->x_scale ) + hints->x_delta;
        loader->pp2.y = hints->y_delta;

        /* be sure to check for spacing glyphs */
        if ( slot->outline.n_points == 0 )
          goto Hint_Metrics;

        /* now load the slot image into the auto-outline and run the */
        /* automatic hinting process                                 */
        error = metrics->clazz->script_hints_init( hints,
                                                   &gloader->current.outline,
                                                   metrics );
        if ( error )
          goto Exit;
d179 1
a179 6
        /* apply the hints */
        metrics->clazz->script_hints_apply( hints,
                                            &gloader->current.outline,
                                            metrics );
        /* we now need to hint the metrics according to the change in */
        /* width/positioning that occured during the hinting process  */
a180 6
          FT_Pos        old_advance, old_rsb, old_lsb, new_lsb;
          AF_AxisHints  axis  = &hints->axis[ AF_DIMENSION_HORZ ];
          AF_Edge       edge1 = axis->edges;    /* leftmost edge  */
          AF_Edge       edge2 = edge1 + axis->num_edges - 1; /* rightmost edge */


d186 11
a196 2
          loader->pp1.x = FT_PIX_ROUND( new_lsb    - old_lsb );
          loader->pp2.x = FT_PIX_ROUND( edge2->pos + old_rsb );
d198 8
a205 5
#if 0
          /* try to fix certain bad advance computations */
          if ( loader->pp2.x + loader->pp1.x == edge2->pos && old_rsb > 4 )
            loader->pp2.x += 64;
#endif
d207 5
d213 11
a223 3
        /* good, we simply add the glyph to our loader's base */
        FT_GlyphLoader_Add( gloader );
        break;
d244 1
a244 1
        num_base_subgs = gloader->base.num_subglyphs;
a293 2
            FT_Vector*  org   = gloader->base.extra_points +
                                num_base_points;
d297 1
a297 2
            for ( ; cur < limit; cur++, org++ )
            {
a298 2
              FT_Vector_Transform( org, &subglyph->transform );
            }
d314 1
a314 1
              error = FT_Err_Invalid_Composite;
d333 2
a334 2
            x = FT_PIX_ROUND(x);
            y = FT_PIX_ROUND(y);
d352 1
a352 1
      error = FT_Err_Unimplemented_Feature;
d358 2
a359 1
      FT_BBox  bbox;
d362 5
d369 1
d371 2
d381 4
a384 4
      bbox.xMin  = FT_PIX_FLOOR(  bbox.xMin );
      bbox.yMin  = FT_PIX_FLOOR(  bbox.yMin );
      bbox.xMax  = FT_PIX_CEIL( bbox.xMax );
      bbox.yMax  = FT_PIX_CEIL( bbox.yMax );
d391 3
d403 5
a407 1
      slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
d410 3
d414 1
a434 2


d445 1
d447 1
a447 1
      return FT_Err_Invalid_Argument;
d465 3
a467 1
      error = af_face_globals_get_metrics( loader->globals, gindex, &metrics );
a471 2
        metrics->scaler = scaler;

d474 2
d480 4
d487 1
d490 3
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@a0 18
/***************************************************************************/
/*                                                                         */
/*  afloader.c                                                             */
/*                                                                         */
/*    Auto-fitter glyph loading routines (body).                           */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


a4 2
#include "aferrors.h"

d10 2
d15 12
a26 4
#ifdef AF_DEBUG
    _af_debug_hints = &loader->hints;
#endif
    return FT_GlyphLoader_New( memory, &loader->gloader );
d31 2
a32 2
  af_loader_reset( AF_Loader  loader,
                   FT_Face    face )
d34 1
a34 2
    FT_Error  error = AF_Err_Ok;

d37 1
a37 1
    loader->globals = (AF_FaceGlobals)face->autohint.data;
d46 2
a47 4
        face->autohint.data =
          (FT_Pointer)loader->globals;
        face->autohint.finalizer =
          (FT_Generic_Finalizer)af_face_globals_free;
a49 1

d55 1
a55 1
  af_loader_done( AF_Loader  loader )
a56 2
    af_glyph_hints_done( &loader->hints );

a59 3
#ifdef AF_DEBUG
    _af_debug_hints = NULL;
#endif
d72 1
a72 1
    FT_Error          error;
a79 1

a88 1

d103 5
a107 61
    case FT_GLYPH_FORMAT_OUTLINE:
      /* translate the loaded glyph when an internal transform is needed */
      if ( loader->transformed )
        FT_Outline_Translate( &slot->outline,
                              loader->trans_delta.x,
                              loader->trans_delta.y );

      /* copy the outline points in the loader's current               */
      /* extra points which is used to keep original glyph coordinates */
      error = FT_GLYPHLOADER_CHECK_POINTS( gloader,
                                           slot->outline.n_points + 4,
                                           slot->outline.n_contours );
      if ( error )
        goto Exit;

      FT_ARRAY_COPY( gloader->current.outline.points,
                     slot->outline.points,
                     slot->outline.n_points );

      FT_ARRAY_COPY( gloader->current.outline.contours,
                     slot->outline.contours,
                     slot->outline.n_contours );

      FT_ARRAY_COPY( gloader->current.outline.tags,
                     slot->outline.tags,
                     slot->outline.n_points );

      gloader->current.outline.n_points   = slot->outline.n_points;
      gloader->current.outline.n_contours = slot->outline.n_contours;

      /* compute original horizontal phantom points (and ignore */
      /* vertical ones)                                         */
      loader->pp1.x = hints->x_delta;
      loader->pp1.y = hints->y_delta;
      loader->pp2.x = FT_MulFix( slot->metrics.horiAdvance,
                                 hints->x_scale ) + hints->x_delta;
      loader->pp2.y = hints->y_delta;

      /* be sure to check for spacing glyphs */
      if ( slot->outline.n_points == 0 )
        goto Hint_Metrics;

      /* now load the slot image into the auto-outline and run the */
      /* automatic hinting process                                 */
      metrics->clazz->script_hints_apply( hints,
                                          &gloader->current.outline,
                                          metrics );

      /* we now need to hint the metrics according to the change in */
      /* width/positioning that occurred during the hinting process */
      if ( scaler->render_mode != FT_RENDER_MODE_LIGHT )
      {
        FT_Pos        old_rsb, old_lsb, new_lsb;
        FT_Pos        pp1x_uh, pp2x_uh;
        AF_AxisHints  axis  = &hints->axis[AF_DIMENSION_HORZ];
        AF_Edge       edge1 = axis->edges;         /* leftmost edge  */
        AF_Edge       edge2 = edge1 +
                              axis->num_edges - 1; /* rightmost edge */


        if ( axis->num_edges > 1 && AF_HINTS_DO_ADVANCE( hints ) )
d109 2
a110 3
          old_rsb     = loader->pp2.x - edge2->opos;
          old_lsb     = edge1->opos;
          new_lsb     = edge1->pos;
d112 6
a117 2
          /* remember unhinted values to later account */
          /* for rounding errors                       */
d119 7
a125 2
          pp1x_uh = new_lsb    - old_lsb;
          pp2x_uh = edge2->pos + old_rsb;
d127 38
a164 2
          /* prefer too much space over too little space */
          /* for very small sizes                        */
d166 11
a176 2
          if ( old_lsb < 24 )
            pp1x_uh -= 8;
a177 2
          if ( old_rsb < 24 )
            pp2x_uh += 8;
d179 4
a182 2
          loader->pp1.x = FT_PIX_ROUND( pp1x_uh );
          loader->pp2.x = FT_PIX_ROUND( pp2x_uh );
d184 2
a185 2
          if ( loader->pp1.x >= new_lsb && old_lsb > 0 )
            loader->pp1.x -= 64;
d187 3
a189 1
          if ( loader->pp2.x <= edge2->pos && old_rsb > 0 )
d191 1
a191 14

          slot->lsb_delta = loader->pp1.x - pp1x_uh;
          slot->rsb_delta = loader->pp2.x - pp2x_uh;
        }
        else
        {
          FT_Pos   pp1x = loader->pp1.x;
          FT_Pos   pp2x = loader->pp2.x;

          loader->pp1.x = FT_PIX_ROUND( pp1x );
          loader->pp2.x = FT_PIX_ROUND( pp2x );

          slot->lsb_delta = loader->pp1.x - pp1x;
          slot->rsb_delta = loader->pp2.x - pp2x;
a192 5
      }
      else
      {
        FT_Pos   pp1x = loader->pp1.x;
        FT_Pos   pp2x = loader->pp2.x;
d194 3
a196 10
        loader->pp1.x = FT_PIX_ROUND( pp1x + hints->xmin_delta );
        loader->pp2.x = FT_PIX_ROUND( pp2x + hints->xmax_delta );

        slot->lsb_delta = loader->pp1.x - pp1x;
        slot->rsb_delta = loader->pp2.x - pp2x;
      }

      /* good, we simply add the glyph to our loader's base */
      FT_GlyphLoader_Add( gloader );
      break;
d217 1
a217 1
        num_base_subgs                 = gloader->base.num_subglyphs;
d267 2
d272 2
a273 1
            for ( ; cur < limit; cur++ )
d275 2
d292 1
a292 1
              error = AF_Err_Invalid_Composite;
d311 2
a312 2
            x = FT_PIX_ROUND( x );
            y = FT_PIX_ROUND( y );
d330 1
a330 1
      error = AF_Err_Unimplemented_Feature;
d336 1
a336 3
      FT_BBox    bbox;
      FT_Vector  vvector;

a337 4
      vvector.x = slot->metrics.vertBearingX - slot->metrics.horiBearingX;
      vvector.y = slot->metrics.vertBearingY - slot->metrics.horiBearingY;
      vvector.x = FT_MulFix( vvector.x, metrics->scaler.x_scale );
      vvector.y = FT_MulFix( vvector.y, metrics->scaler.y_scale );
a340 1
      {
d342 1
a342 3
        FT_Vector_Transform( &vvector, &loader->trans_matrix );
      }
#if 1
d347 1
a347 1
#endif
d350 4
a353 4
      bbox.xMin = FT_PIX_FLOOR( bbox.xMin );
      bbox.yMin = FT_PIX_FLOOR( bbox.yMin );
      bbox.xMax = FT_PIX_CEIL(  bbox.xMax );
      bbox.yMax = FT_PIX_CEIL(  bbox.yMax );
a359 3
      slot->metrics.vertBearingX = FT_PIX_FLOOR( bbox.xMin + vvector.x );
      slot->metrics.vertBearingY = FT_PIX_FLOOR( bbox.yMax + vvector.y );

d369 1
a369 16
      if ( !FT_IS_FIXED_WIDTH( slot->face ) )
      {
        /* non-spacing glyphs must stay as-is */
        if ( slot->metrics.horiAdvance )
          slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      }
      else
      {
        slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,
                                               metrics->scaler.x_scale );

        /* Set delta values to 0.  Otherwise code that uses them is */
        /* going to ruin the fixed advance width.                   */
        slot->lsb_delta = 0;
        slot->rsb_delta = 0;
      }
a371 3
      slot->metrics.vertAdvance = FT_MulFix( slot->metrics.vertAdvance,
                                              metrics->scaler.y_scale );

a372 1
      slot->metrics.vertAdvance = FT_PIX_ROUND( slot->metrics.vertAdvance );
d393 2
a404 1

d406 1
a406 1
      return AF_Err_Invalid_Argument;
a422 1
      FT_UInt           options = 0;
d424 1
a424 9

#ifdef FT_OPTION_AUTOFIT2
      /* XXX: undocumented hook to activate the latin2 hinter */
      if ( load_flags & ( 1UL << 20 ) )
        options = 2;
#endif

      error = af_face_globals_get_metrics( loader->globals, gindex,
                                           options, &metrics );
d429 2
a432 2
        else
          metrics->scaler = scaler;
a436 4
        error = metrics->clazz->script_hints_init( &loader->hints, metrics );
        if ( error )
          goto Exit;

a439 1
  Exit:
a441 3


/* END */
@


1.1.1.2
log
@SECURITY: Import freetype 2.3.6. From the release notes:

    - A  bunch of  potential security  problems have  been found.  All
      users should update.
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008 by                        */
d168 3
a170 4
      if ( metrics->clazz->script_hints_apply )
        metrics->clazz->script_hints_apply( hints,
                                            &gloader->current.outline,
                                            metrics );
d518 3
a520 7
        if ( metrics->clazz->script_hints_init )
        {
          error = metrics->clazz->script_hints_init( &loader->hints,
                                                     metrics );
          if ( error )
            goto Exit;
        }
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@a0 18
/***************************************************************************/
/*                                                                         */
/*  afloader.c                                                             */
/*                                                                         */
/*    Auto-fitter glyph loading routines (body).                           */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


a4 2
#include "aferrors.h"

d10 2
d16 11
a26 1
    return FT_GlyphLoader_New( memory, &loader->gloader );
d31 2
a32 2
  af_loader_reset( AF_Loader  loader,
                   FT_Face    face )
d34 1
a34 2
    FT_Error  error = AF_Err_Ok;

d37 1
a37 1
    loader->globals = (AF_FaceGlobals)face->autohint.data;
d46 2
a47 4
        face->autohint.data =
          (FT_Pointer)loader->globals;
        face->autohint.finalizer =
          (FT_Generic_Finalizer)af_face_globals_free;
a49 1

d55 1
a55 1
  af_loader_done( AF_Loader  loader )
a56 2
    af_glyph_hints_done( &loader->hints );

d72 1
a72 1
    FT_Error          error;
a79 1

a88 1

d103 8
a110 14
    case FT_GLYPH_FORMAT_OUTLINE:
      /* translate the loaded glyph when an internal transform is needed */
      if ( loader->transformed )
        FT_Outline_Translate( &slot->outline,
                              loader->trans_delta.x,
                              loader->trans_delta.y );

      /* copy the outline points in the loader's current               */
      /* extra points which is used to keep original glyph coordinates */
      error = FT_GLYPHLOADER_CHECK_POINTS( gloader,
                                           slot->outline.n_points + 4,
                                           slot->outline.n_contours );
      if ( error )
        goto Exit;
d112 6
a117 32
      FT_ARRAY_COPY( gloader->current.outline.points,
                     slot->outline.points,
                     slot->outline.n_points );

      FT_ARRAY_COPY( gloader->current.outline.contours,
                     slot->outline.contours,
                     slot->outline.n_contours );

      FT_ARRAY_COPY( gloader->current.outline.tags,
                     slot->outline.tags,
                     slot->outline.n_points );

      gloader->current.outline.n_points   = slot->outline.n_points;
      gloader->current.outline.n_contours = slot->outline.n_contours;

      /* compute original horizontal phantom points (and ignore */
      /* vertical ones)                                         */
      loader->pp1.x = hints->x_delta;
      loader->pp1.y = hints->y_delta;
      loader->pp2.x = FT_MulFix( slot->metrics.horiAdvance,
                                 hints->x_scale ) + hints->x_delta;
      loader->pp2.y = hints->y_delta;

      /* be sure to check for spacing glyphs */
      if ( slot->outline.n_points == 0 )
        goto Hint_Metrics;

      /* now load the slot image into the auto-outline and run the */
      /* automatic hinting process                                 */
      metrics->clazz->script_hints_apply( hints,
                                          &gloader->current.outline,
                                          metrics );
d119 7
a125 10
      /* we now need to hint the metrics according to the change in */
      /* width/positioning that occured during the hinting process  */
      {
#ifndef AF_USE_WARPER
        FT_Pos        old_advance, old_rsb, old_lsb, new_lsb;
        FT_Pos        pp1x_uh, pp2x_uh;
        AF_AxisHints  axis  = &hints->axis[AF_DIMENSION_HORZ];
        AF_Edge       edge1 = axis->edges;         /* leftmost edge  */
        AF_Edge       edge2 = edge1 +
                              axis->num_edges - 1; /* rightmost edge */
d127 38
d166 6
a171 1
        if ( axis->num_edges > 1 && AF_HINTS_DO_ADVANCE( hints ) )
d173 6
d184 2
a185 2
          /* remember unhinted values to later account */
          /* for rounding errors                       */
d187 5
a191 17
          pp1x_uh = new_lsb    - old_lsb;
          pp2x_uh = edge2->pos + old_rsb;

          /* prefer too much space over too little space */
          /* for very small sizes                        */

          if ( old_lsb < 24 )
            pp1x_uh -= 5;

          if ( old_rsb < 24 )
            pp2x_uh += 5;

          loader->pp1.x = FT_PIX_ROUND( pp1x_uh );
          loader->pp2.x = FT_PIX_ROUND( pp2x_uh );

          slot->lsb_delta = loader->pp1.x - pp1x_uh;
          slot->rsb_delta = loader->pp2.x - pp2x_uh;
a192 5
        else
#endif /* !AF_USE_WARPER */
        {
          FT_Pos   pp1x = loader->pp1.x;
          FT_Pos   pp2x = loader->pp2.x;
d194 3
a196 11
          loader->pp1.x = FT_PIX_ROUND( loader->pp1.x );
          loader->pp2.x = FT_PIX_ROUND( loader->pp2.x );

          slot->lsb_delta = loader->pp1.x - pp1x;
          slot->rsb_delta = loader->pp2.x - pp2x;
        }
      }

      /* good, we simply add the glyph to our loader's base */
      FT_GlyphLoader_Add( gloader );
      break;
d217 1
a217 1
        num_base_subgs                 = gloader->base.num_subglyphs;
d267 2
d272 2
a273 1
            for ( ; cur < limit; cur++ )
d275 2
d292 1
a292 1
              error = AF_Err_Invalid_Composite;
d311 2
a312 2
            x = FT_PIX_ROUND( x );
            y = FT_PIX_ROUND( y );
d330 1
a330 1
      error = AF_Err_Unimplemented_Feature;
d336 1
a336 2
      FT_BBox    bbox;
      FT_Vector  vvector;
a338 5
      vvector.x = slot->metrics.vertBearingX - slot->metrics.horiBearingX;
      vvector.y = slot->metrics.vertBearingY - slot->metrics.horiBearingY;
      vvector.x = FT_MulFix( vvector.x, metrics->scaler.x_scale );
      vvector.y = FT_MulFix( vvector.y, metrics->scaler.y_scale );

a340 1
      {
a341 2
        FT_Vector_Transform( &vvector, &loader->trans_matrix );
      }
d350 4
a353 4
      bbox.xMin = FT_PIX_FLOOR( bbox.xMin );
      bbox.yMin = FT_PIX_FLOOR( bbox.yMin );
      bbox.xMax = FT_PIX_CEIL(  bbox.xMax );
      bbox.yMax = FT_PIX_CEIL(  bbox.yMax );
a359 3
      slot->metrics.vertBearingX = FT_PIX_FLOOR( bbox.xMin + vvector.x );
      slot->metrics.vertBearingY = FT_PIX_FLOOR( bbox.yMax + vvector.y );

d369 1
a369 5
      if ( !FT_IS_FIXED_WIDTH( slot->face ) )
        slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      else
        slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,
                                               metrics->scaler.x_scale );
a371 3
      slot->metrics.vertAdvance = FT_MulFix( slot->metrics.vertAdvance,
                                              metrics->scaler.y_scale );

a372 1
      slot->metrics.vertAdvance = FT_PIX_ROUND( slot->metrics.vertAdvance );
d393 2
a404 1

d406 1
a406 1
      return AF_Err_Invalid_Argument;
d424 1
a424 3

      error = af_face_globals_get_metrics( loader->globals, gindex,
                                           &metrics );
d429 2
a432 2
        else
          metrics->scaler = scaler;
a436 4
        error = metrics->clazz->script_hints_init( &loader->hints, metrics );
        if ( error )
          goto Exit;

a439 1
  Exit:
a441 3


/* END */
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
d22 1
d33 1
a33 3
#ifdef AF_DEBUG
    _af_debug_hints = &loader->hints;
#endif
a73 3
#ifdef AF_DEBUG
    _af_debug_hints = NULL;
#endif
d163 3
a165 4
      if ( metrics->clazz->script_hints_apply )
        metrics->clazz->script_hints_apply( hints,
                                            &gloader->current.outline,
                                            metrics );
d168 1
a168 2
      /* width/positioning that occurred during the hinting process */
      if ( scaler->render_mode != FT_RENDER_MODE_LIGHT )
d170 2
a171 1
        FT_Pos        old_rsb, old_lsb, new_lsb;
d181 4
a184 3
          old_rsb = loader->pp2.x - edge2->opos;
          old_lsb = edge1->opos;
          new_lsb = edge1->pos;
d196 1
a196 1
            pp1x_uh -= 8;
d199 1
a199 1
            pp2x_uh += 8;
a203 6
          if ( loader->pp1.x >= new_lsb && old_lsb > 0 )
            loader->pp1.x -= 64;

          if ( loader->pp2.x <= edge2->pos && old_rsb > 0 )
            loader->pp2.x += 64;

d208 1
d210 2
a211 3
          FT_Pos  pp1x = loader->pp1.x;
          FT_Pos  pp2x = loader->pp2.x;

d213 2
a214 2
          loader->pp1.x = FT_PIX_ROUND( pp1x );
          loader->pp2.x = FT_PIX_ROUND( pp2x );
a219 12
      else
      {
        FT_Pos  pp1x = loader->pp1.x;
        FT_Pos  pp2x = loader->pp2.x;


        loader->pp1.x = FT_PIX_ROUND( pp1x + hints->xmin_delta );
        loader->pp2.x = FT_PIX_ROUND( pp2x + hints->xmax_delta );

        slot->lsb_delta = loader->pp1.x - pp1x;
        slot->rsb_delta = loader->pp2.x - pp2x;
      }
d373 1
a373 1
#if 1
d378 1
a378 1
#endif
d395 1
a395 2
      /* to keep the original rounded advance width; ditto for     */
      /* digits if all have the same advance width                 */
d403 3
a405 4
      if ( FT_IS_FIXED_WIDTH( slot->face )                              ||
           ( af_face_globals_is_digit( loader->globals, glyph_index ) &&
             metrics->digits_have_same_width                          ) )
      {
a407 12

        /* Set delta values to 0.  Otherwise code that uses them is */
        /* going to ruin the fixed advance width.                   */
        slot->lsb_delta = 0;
        slot->rsb_delta = 0;
      }
      else
      {
        /* non-spacing glyphs must stay as-is */
        if ( slot->metrics.horiAdvance )
          slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      }
a463 1
      FT_UInt           options = 0;
a465 6
#ifdef FT_OPTION_AUTOFIT2
      /* XXX: undocumented hook to activate the latin2 hinter */
      if ( load_flags & ( 1UL << 20 ) )
        options = 2;
#endif

d467 1
a467 1
                                           options, &metrics );
d480 3
a482 7
        if ( metrics->clazz->script_hints_init )
        {
          error = metrics->clazz->script_hints_init( &loader->hints,
                                                     metrics );
          if ( error )
            goto Exit;
        }
@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2003-2016 by                                                 */
a18 1
#include "afglobal.h"
d21 1
a22 2
#include "afmodule.h"
#include "afpic.h"
a23 1
#include FT_INTERNAL_CALC_H
d25 3
a27 6

  /* Initialize glyph loader. */

  FT_LOCAL_DEF( void )
  af_loader_init( AF_Loader      loader,
                  AF_GlyphHints  hints )
d31 5
a35 1
    loader->hints = hints;
a38 2
  /* Reset glyph loader and compute globals if necessary. */

a40 1
                   AF_Module  module,
d43 1
a43 1
    FT_Error  error = FT_Err_Ok;
d49 3
a51 1
    if ( !loader->globals )
d53 1
a53 1
      error = af_face_globals_new( face, &loader->globals, module );
a66 2
  /* Finalize glyph loader. */

d70 2
d74 6
a79 1
    loader->hints   = NULL;
a82 8
#define af_intToFixed( i ) \
          ( (FT_Fixed)( (FT_UInt32)(i) << 16 ) )
#define af_fixedToInt( x ) \
          ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
#define af_floatToFixed( f ) \
          ( (FT_Fixed)( (f) * 65536.0 + 0.5 ) )


d84 5
a88 3
  af_loader_embolden_glyph_in_slot( AF_Loader        loader,
                                    FT_Face          face,
                                    AF_StyleMetrics  style_metrics )
d90 5
a94 127
    FT_Error  error = FT_Err_Ok;

    FT_GlyphSlot           slot    = face->glyph;
    AF_FaceGlobals         globals = loader->globals;
    AF_WritingSystemClass  writing_system_class;

    FT_Pos  stdVW = 0;
    FT_Pos  stdHW = 0;

    FT_Bool  size_changed = face->size->metrics.x_ppem
                              != globals->stem_darkening_for_ppem;

    FT_Fixed  em_size  = af_intToFixed( face->units_per_EM );
    FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );

    FT_Matrix  scale_down_matrix = { 0x10000L, 0, 0, 0x10000L };


    /* Skip stem darkening for broken fonts. */
    if ( !face->units_per_EM )
    {
      error = FT_Err_Corrupted_Font_Header;
      goto Exit;
    }

    /*
     *  We depend on the writing system (script analyzers) to supply
     *  standard widths for the script of the glyph we are looking at.  If
     *  it can't deliver, stem darkening is disabled.
     */
    writing_system_class =
      AF_WRITING_SYSTEM_CLASSES_GET[style_metrics->style_class->writing_system];

    if ( writing_system_class->style_metrics_getstdw )
      writing_system_class->style_metrics_getstdw( style_metrics,
                                                   &stdHW,
                                                   &stdVW );
    else
    {
      error = FT_Err_Unimplemented_Feature;
      goto Exit;
    }

    if ( size_changed                                               ||
         ( stdVW > 0 && stdVW != globals->standard_vertical_width ) )
    {
      FT_Fixed  darken_by_font_units_x, darken_x;


      darken_by_font_units_x =
        af_intToFixed( af_loader_compute_darkening( loader,
                                                    face,
                                                    stdVW ) );
      darken_x = FT_DivFix( FT_MulFix( darken_by_font_units_x,
                                       face->size->metrics.x_scale ),
                            em_ratio );

      globals->standard_vertical_width = stdVW;
      globals->stem_darkening_for_ppem = face->size->metrics.x_ppem;
      globals->darken_x                = af_fixedToInt( darken_x );
    }

    if ( size_changed                                                 ||
         ( stdHW > 0 && stdHW != globals->standard_horizontal_width ) )
    {
      FT_Fixed  darken_by_font_units_y, darken_y;


      darken_by_font_units_y =
        af_intToFixed( af_loader_compute_darkening( loader,
                                                    face,
                                                    stdHW ) );
      darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,
                                       face->size->metrics.y_scale ),
                            em_ratio );

      globals->standard_horizontal_width = stdHW;
      globals->stem_darkening_for_ppem   = face->size->metrics.x_ppem;
      globals->darken_y                  = af_fixedToInt( darken_y );

      /*
       *  Scale outlines down on the Y-axis to keep them inside their blue
       *  zones.  The stronger the emboldening, the stronger the downscaling
       *  (plus heuristical padding to prevent outlines still falling out
       *  their zones due to rounding).
       *
       *  Reason: `FT_Outline_Embolden' works by shifting the rightmost
       *  points of stems farther to the right, and topmost points farther
       *  up.  This positions points on the Y-axis outside their
       *  pre-computed blue zones and leads to distortion when applying the
       *  hints in the code further below.  Code outside this emboldening
       *  block doesn't know we are presenting it with modified outlines the
       *  analyzer didn't see!
       *
       *  An unfortunate side effect of downscaling is that the emboldening
       *  effect is slightly decreased.  The loss becomes more pronounced
       *  versus the CFF driver at smaller sizes, e.g., at 9ppem and below.
       */
      globals->scale_down_factor =
        FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
                   em_size );
    }

    FT_Outline_EmboldenXY( &slot->outline,
                           globals->darken_x,
                           globals->darken_y );

    scale_down_matrix.yy = globals->scale_down_factor;
    FT_Outline_Transform( &slot->outline, &scale_down_matrix );

  Exit:
    return error;
  }


  /* Load the glyph at index into the current slot of a face and hint it. */

  FT_LOCAL_DEF( FT_Error )
  af_loader_load_glyph( AF_Loader  loader,
                        AF_Module  module,
                        FT_Face    face,
                        FT_UInt    glyph_index,
                        FT_Int32   load_flags )
  {
    FT_Error  error;

    FT_Size           size     = face->size;
a96 76
    FT_GlyphLoader    gloader  = internal->loader;

    AF_GlyphHints          hints          = loader->hints;
    AF_ScalerRec           scaler;
    AF_StyleMetrics        style_metrics;
    FT_UInt                style_options  = AF_STYLE_NONE_DFLT;
    AF_StyleClass          style_class;
    AF_WritingSystemClass  writing_system_class;

#ifdef FT_CONFIG_OPTION_PIC
    AF_FaceGlobals  globals = loader->globals;
#endif


    if ( !size )
      return FT_THROW( Invalid_Size_Handle );

    FT_ZERO( &scaler );

    /*
     *  TODO: This code currently doesn't support fractional advance widths,
     *  i.e.  placing hinted glyphs at anything other than integer
     *  x-positions.  This is only relevant for the warper code, which
     *  scales and shifts glyphs to optimize blackness of stems (hinting on
     *  the x-axis by nature places things on pixel integers, hinting on the
     *  y-axis only, i.e.  LIGHT mode, doesn't touch the x-axis).  The delta
     *  values of the scaler would need to be adjusted.
     */
    scaler.face    = face;
    scaler.x_scale = size->metrics.x_scale;
    scaler.x_delta = 0;
    scaler.y_scale = size->metrics.y_scale;
    scaler.y_delta = 0;

    scaler.render_mode = FT_LOAD_TARGET_MODE( load_flags );
    scaler.flags       = 0;

    error = af_loader_reset( loader, module, face );
    if ( error )
      goto Exit;

#ifdef FT_OPTION_AUTOFIT2
    /* XXX: undocumented hook to activate the latin2 writing system. */
    if ( load_flags & ( 1UL << 20 ) )
      style_options = AF_STYLE_LTN2_DFLT;
#endif

    /*
     *  Glyphs (really code points) are assigned to scripts.  Script
     *  analysis is done lazily: For each glyph that passes through here,
     *  the corresponding script analyzer is called, but returns immediately
     *  if it has been run already.
     */
    error = af_face_globals_get_metrics( loader->globals, glyph_index,
                                         style_options, &style_metrics );
    if ( error )
      goto Exit;

    style_class          = style_metrics->style_class;
    writing_system_class =
      AF_WRITING_SYSTEM_CLASSES_GET[style_class->writing_system];

    loader->metrics = style_metrics;

    if ( writing_system_class->style_metrics_scale )
      writing_system_class->style_metrics_scale( style_metrics, &scaler );
    else
      style_metrics->scaler = scaler;

    if ( writing_system_class->style_hints_init )
    {
      error = writing_system_class->style_hints_init( hints,
                                                      style_metrics );
      if ( error )
        goto Exit;
    }
a97 11
    /*
     *  Do the main work of `af_loader_load_glyph'.  Note that we never have
     *  to deal with composite glyphs as those get loaded into
     *  FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph' function.
     *  In the rare cases where FT_LOAD_NO_RECURSE is set, it implies
     *  FT_LOAD_NO_SCALE and as such the auto-hinter is never called.
     */
    load_flags |=  FT_LOAD_NO_SCALE         |
                   FT_LOAD_IGNORE_TRANSFORM |
                   FT_LOAD_LINEAR_DESIGN;
    load_flags &= ~FT_LOAD_RENDER;
a102 25
    /*
     *  Apply stem darkening (emboldening) here before hints are applied to
     *  the outline.  Glyphs are scaled down proportionally to the
     *  emboldening so that curve points don't fall outside their
     *  precomputed blue zones.
     *
     *  Any emboldening done by the font driver (e.g., the CFF driver)
     *  doesn't reach here because the autohinter loads the unprocessed
     *  glyphs in font units for analysis (functions `af_*_metrics_init_*')
     *  and then above to prepare it for the rasterizers by itself,
     *  independently of the font driver.  So emboldening must be done here,
     *  within the autohinter.
     *
     *  All glyphs to be autohinted pass through here one by one.  The
     *  standard widths can therefore change from one glyph to the next,
     *  depending on what script a glyph is assigned to (each script has its
     *  own set of standard widths and other metrics).  The darkening amount
     *  must therefore be recomputed for each size and
     *  `standard_{vertical,horizontal}_width' change.
     *
     *  Ignore errors and carry on without emboldening.
     */
    if ( !module->no_stem_darkening )
      af_loader_embolden_glyph_in_slot( loader, face, style_metrics );

d113 2
a114 2
      if ( !FT_Matrix_Invert( &inverse ) )
        FT_Vector_Transform( &loader->trans_delta, &inverse );
d117 4
d130 25
a154 2
      /* compute original horizontal phantom points */
      /* (and ignore vertical ones)                 */
d165 10
a174 2
      /* now load the slot image into the auto-outline */
      /* and run the automatic hinting process         */
d176 2
a177 19
#ifdef FT_CONFIG_OPTION_PIC
        AF_FaceGlobals  globals = loader->globals;
#endif


        if ( writing_system_class->style_hints_apply )
          writing_system_class->style_hints_apply( glyph_index,
                                                   hints,
                                                   &gloader->base.outline,
                                                   style_metrics );
      }

      /* we now need to adjust the metrics according to the change in */
      /* width/positioning that occurred during the hinting process   */
      if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
      {
        FT_Pos  old_rsb, old_lsb, new_lsb;
        FT_Pos  pp1x_uh, pp2x_uh;

d187 1
a187 2
          /* loader->pp1.x is always zero at this point of time */
          old_lsb = edge1->opos /* - loader->pp1.x */;
d190 3
d243 127
d374 1
a374 1
      error = FT_THROW( Unimplemented_Feature );
d378 1
d386 2
a387 2
      vvector.x = FT_MulFix( vvector.x, style_metrics->scaler.x_scale );
      vvector.y = FT_MulFix( vvector.y, style_metrics->scaler.y_scale );
d395 1
a395 1

d400 1
a400 1

d419 10
a428 4
      if ( scaler.render_mode != FT_RENDER_MODE_LIGHT                       &&
           ( FT_IS_FIXED_WIDTH( slot->face )                              ||
             ( af_face_globals_is_digit( loader->globals, glyph_index ) &&
               style_metrics->digits_have_same_width                    ) ) )
d430 2
a431 3
        slot->metrics.horiAdvance =
          FT_MulFix( slot->metrics.horiAdvance,
                     style_metrics->scaler.x_scale );
d444 1
d447 1
a447 1
                                             style_metrics->scaler.y_scale );
d452 7
d462 4
d471 5
a475 11
  /*
   * Compute amount of font units the face should be emboldened by, in
   * analogy to the CFF driver's `cf2_computeDarkening' function.  See there
   * for details of the algorithm.
   *
   * XXX: Currently a crude adaption of the original algorithm.  Do better?
   */
  FT_LOCAL_DEF( FT_Int32 )
  af_loader_compute_darkening( AF_Loader  loader,
                               FT_Face    face,
                               FT_Pos     standard_width )
d477 3
a479 1
    AF_Module  module = loader->globals->module;
a480 18
    FT_UShort  units_per_EM;
    FT_Fixed   ppem, em_ratio;
    FT_Fixed   stem_width, stem_width_per_1000, scaled_stem, darken_amount;
    FT_Int     log_base_2;
    FT_Int     x1, y1, x2, y2, x3, y3, x4, y4;


    ppem         = FT_MAX( af_intToFixed( 4 ),
                           af_intToFixed( face->size->metrics.x_ppem ) );
    units_per_EM = face->units_per_EM;

    em_ratio = FT_DivFix( af_intToFixed( 1000 ),
                          af_intToFixed ( units_per_EM ) );
    if ( em_ratio < af_floatToFixed( .01 ) )
    {
      /* If something goes wrong, don't embolden. */
      return 0;
    }
d482 2
a483 8
    x1 = module->darken_params[0];
    y1 = module->darken_params[1];
    x2 = module->darken_params[2];
    y2 = module->darken_params[3];
    x3 = module->darken_params[4];
    y3 = module->darken_params[5];
    x4 = module->darken_params[6];
    y4 = module->darken_params[7];
d485 1
a485 10
    if ( standard_width <= 0 )
    {
      stem_width          = af_intToFixed( 75 ); /* taken from cf2font.c */
      stem_width_per_1000 = stem_width;
    }
    else
    {
      stem_width          = af_intToFixed( standard_width );
      stem_width_per_1000 = FT_MulFix( stem_width, em_ratio );
    }
d487 5
a491 2
    log_base_2 = FT_MSB( (FT_UInt32)stem_width_per_1000 ) +
                 FT_MSB( (FT_UInt32)ppem );
d493 2
a494 11
    if ( log_base_2 >= 46 )
    {
      /* possible overflow */
      scaled_stem = af_intToFixed( x4 );
    }
    else
      scaled_stem = FT_MulFix( stem_width_per_1000, ppem );

    /* now apply the darkening parameters */
    if ( scaled_stem < af_intToFixed( x1 ) )
      darken_amount = FT_DivFix( af_intToFixed( y1 ), ppem );
d496 2
a497 1
    else if ( scaled_stem < af_intToFixed( x2 ) )
d499 2
a500 4
      FT_Int  xdelta = x2 - x1;
      FT_Int  ydelta = y2 - y1;
      FT_Int  x      = stem_width_per_1000 -
                       FT_DivFix( af_intToFixed( x1 ), ppem );
d503 5
a507 2
      if ( !xdelta )
        goto Try_x3;
d509 3
a511 7
      darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                      FT_DivFix( af_intToFixed( y1 ), ppem );
    }

    else if ( scaled_stem < af_intToFixed( x3 ) )
    {
    Try_x3:
d513 1
a513 4
        FT_Int  xdelta = x3 - x2;
        FT_Int  ydelta = y3 - y2;
        FT_Int  x      = stem_width_per_1000 -
                         FT_DivFix( af_intToFixed( x2 ), ppem );
d515 4
d520 2
a521 16
        if ( !xdelta )
          goto Try_x4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( af_intToFixed( y2 ), ppem );
      }
    }

    else if ( scaled_stem < af_intToFixed( x4 ) )
    {
    Try_x4:
      {
        FT_Int  xdelta = x4 - x3;
        FT_Int  ydelta = y4 - y3;
        FT_Int  x      = stem_width_per_1000 -
                         FT_DivFix( af_intToFixed( x3 ), ppem );
d523 7
d531 1
a531 5
        if ( !xdelta )
          goto Use_y4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( af_intToFixed( y3 ), ppem );
d534 2
a535 9

    else
    {
    Use_y4:
      darken_amount = FT_DivFix( af_intToFixed( y4 ), ppem );
    }

    /* Convert darken_amount from per 1000 em to true character space. */
    return af_fixedToInt( FT_DivFix( darken_amount, em_ratio ) );
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
