head	1.5;
access;
symbols
	freetype-2_7_1:1.1.115.4
	freetype-2_3_12:1.1.115.3
	freetype-2_3_6:1.1.1.1
	MIRBSD_10_BASE:1.3
	freetype-2_3_5:1.1.1.1
	freetype-2_2_1:1.1.115.2
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.5
date	2017.04.15.19.21.17;	author tg;	state Exp;
branches;
next	1.4;
commitid	10058F2723111C7BEE2;

1.4
date	2013.08.06.19.47.34;	author tg;	state Exp;
branches;
next	1.3;
commitid	100520152445E05B912;

1.3
date	2008.02.26.20.04.49;	author bsiegert;	state Exp;
branches;
next	1.2;
commitid	10047C470A72A1E13CE;

1.2
date	2006.06.29.20.24.35;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.103.1
	1.1.115.1;
next	;

1.1.1.1
date	2008.02.26.19.52.53;	author bsiegert;	state Exp;
branches;
next	;
commitid	10047C46DB5081DCD79;

1.1.103.1
date	2005.03.18.10.43.06;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.34.53;	author tg;	state Exp;
branches;
next	1.1.115.2;
commitid	10044A41D276963C97B;

1.1.115.2
date	2006.06.29.18.37.46;	author tg;	state Exp;
branches;
next	1.1.115.3;
commitid	10044A41DBD6368BED5;

1.1.115.3
date	2013.08.06.19.12.26;	author tg;	state Exp;
branches;
next	1.1.115.4;
commitid	10052014A9975CEFD1D;

1.1.115.4
date	2017.04.15.15.42.01;	author tg;	state Exp;
branches;
next	;
commitid	10058F23F4858079E1C;


desc
@@


1.5
log
@first cut at a quickmerge
@
text
@/***************************************************************************/
/*                                                                         */
/*  afhints.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (body).                                 */
/*                                                                         */
/*  Copyright 2003-2016 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include "afhints.h"
#include "aferrors.h"
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_DEBUG_H


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_afhints


  /* Get new segment for given axis. */

  FT_LOCAL_DEF( FT_Error )
  af_axis_hints_new_segment( AF_AxisHints  axis,
                             FT_Memory     memory,
                             AF_Segment   *asegment )
  {
    FT_Error    error   = FT_Err_Ok;
    AF_Segment  segment = NULL;


    if ( axis->num_segments < AF_SEGMENTS_EMBEDDED )
    {
      if ( !axis->segments )
      {
        axis->segments     = axis->embedded.segments;
        axis->max_segments = AF_SEGMENTS_EMBEDDED;
      }
    }
    else if ( axis->num_segments >= axis->max_segments )
    {
      FT_Int  old_max = axis->max_segments;
      FT_Int  new_max = old_max;
      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *segment ) );


      if ( old_max >= big_max )
      {
        error = FT_THROW( Out_Of_Memory );
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( axis->segments == axis->embedded.segments )
      {
        if ( FT_NEW_ARRAY( axis->segments, new_max ) )
          goto Exit;
        ft_memcpy( axis->segments, axis->embedded.segments,
                   sizeof ( axis->embedded.segments ) );
      }
      else
      {
        if ( FT_RENEW_ARRAY( axis->segments, old_max, new_max ) )
          goto Exit;
      }

      axis->max_segments = new_max;
    }

    segment = axis->segments + axis->num_segments++;

  Exit:
    *asegment = segment;
    return error;
  }


  /* Get new edge for given axis, direction, and position, */
  /* without initializing the edge itself.                 */

  FT_LOCAL( FT_Error )
  af_axis_hints_new_edge( AF_AxisHints  axis,
                          FT_Int        fpos,
                          AF_Direction  dir,
                          FT_Bool       top_to_bottom_hinting,
                          FT_Memory     memory,
                          AF_Edge      *anedge )
  {
    FT_Error  error = FT_Err_Ok;
    AF_Edge   edge  = NULL;
    AF_Edge   edges;


    if ( axis->num_edges < AF_EDGES_EMBEDDED )
    {
      if ( !axis->edges )
      {
        axis->edges     = axis->embedded.edges;
        axis->max_edges = AF_EDGES_EMBEDDED;
      }
    }
    else if ( axis->num_edges >= axis->max_edges )
    {
      FT_Int  old_max = axis->max_edges;
      FT_Int  new_max = old_max;
      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *edge ) );


      if ( old_max >= big_max )
      {
        error = FT_THROW( Out_Of_Memory );
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( axis->edges == axis->embedded.edges )
      {
        if ( FT_NEW_ARRAY( axis->edges, new_max ) )
          goto Exit;
        ft_memcpy( axis->edges, axis->embedded.edges,
                   sizeof ( axis->embedded.edges ) );
      }
      else
      {
        if ( FT_RENEW_ARRAY( axis->edges, old_max, new_max ) )
          goto Exit;
      }

      axis->max_edges = new_max;
    }

    edges = axis->edges;
    edge  = edges + axis->num_edges;

    while ( edge > edges )
    {
      if ( top_to_bottom_hinting ? ( edge[-1].fpos > fpos )
                                 : ( edge[-1].fpos < fpos ) )
        break;

      /* we want the edge with same position and minor direction */
      /* to appear before those in the major one in the list     */
      if ( edge[-1].fpos == fpos && dir == axis->major_dir )
        break;

      edge[0] = edge[-1];
      edge--;
    }

    axis->num_edges++;

  Exit:
    *anedge = edge;
    return error;
  }


#ifdef FT_DEBUG_AUTOFIT

#include FT_CONFIG_STANDARD_LIBRARY_H

  /* The dump functions are used in the `ftgrid' demo program, too. */
#define AF_DUMP( varformat )          \
          do                          \
          {                           \
            if ( to_stdout )          \
              printf varformat;       \
            else                      \
              FT_TRACE7( varformat ); \
          } while ( 0 )


  static const char*
  af_dir_str( AF_Direction  dir )
  {
    const char*  result;


    switch ( dir )
    {
    case AF_DIR_UP:
      result = "up";
      break;
    case AF_DIR_DOWN:
      result = "down";
      break;
    case AF_DIR_LEFT:
      result = "left";
      break;
    case AF_DIR_RIGHT:
      result = "right";
      break;
    default:
      result = "none";
    }

    return result;
  }


#define AF_INDEX_NUM( ptr, base )  (int)( (ptr) ? ( (ptr) - (base) ) : -1 )


  static char*
  af_print_idx( char* p,
                int   idx )
  {
    if ( idx == -1 )
    {
      p[0] = '-';
      p[1] = '-';
      p[2] = '\0';
    }
    else
      ft_sprintf( p, "%d", idx );

    return p;
  }


  static int
  af_get_segment_index( AF_GlyphHints  hints,
                        int            point_idx,
                        int            dimension )
  {
    AF_AxisHints  axis     = &hints->axis[dimension];
    AF_Point      point    = hints->points + point_idx;
    AF_Segment    segments = axis->segments;
    AF_Segment    limit    = segments + axis->num_segments;
    AF_Segment    segment;


    for ( segment = segments; segment < limit; segment++ )
    {
      if ( segment->first <= segment->last )
      {
        if ( point >= segment->first && point <= segment->last )
          break;
      }
      else
      {
        AF_Point  p = segment->first;


        for (;;)
        {
          if ( point == p )
            goto Exit;

          if ( p == segment->last )
            break;

          p = p->next;
        }
      }
    }

  Exit:
    if ( segment == limit )
      return -1;

    return (int)( segment - segments );
  }


  static int
  af_get_edge_index( AF_GlyphHints  hints,
                     int            segment_idx,
                     int            dimension )
  {
    AF_AxisHints  axis    = &hints->axis[dimension];
    AF_Edge       edges   = axis->edges;
    AF_Segment    segment = axis->segments + segment_idx;


    return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment->edge, edges );
  }


#ifdef __cplusplus
  extern "C" {
#endif
  void
  af_glyph_hints_dump_points( AF_GlyphHints  hints,
                              FT_Bool        to_stdout )
  {
    AF_Point   points  = hints->points;
    AF_Point   limit   = points + hints->num_points;
    AF_Point*  contour = hints->contours;
    AF_Point*  climit  = contour + hints->num_contours;
    AF_Point   point;


    AF_DUMP(( "Table of points:\n" ));

    if ( hints->num_points )
      AF_DUMP(( "  index  hedge  hseg  vedge  vseg  flags "
                "  xorg  yorg  xscale  yscale   xfit    yfit" ));
    else
      AF_DUMP(( "  (none)\n" ));

    for ( point = points; point < limit; point++ )
    {
      int  point_idx     = AF_INDEX_NUM( point, points );
      int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
      int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );

      char  buf1[16], buf2[16], buf3[16], buf4[16];


      /* insert extra newline at the beginning of a contour */
      if ( contour < climit && *contour == point )
      {
        AF_DUMP(( "\n" ));
        contour++;
      }

      AF_DUMP(( "  %5d  %5s %5s  %5s %5s  %s"
                " %5d %5d %7.2f %7.2f %7.2f %7.2f\n",
                point_idx,
                af_print_idx( buf1,
                              af_get_edge_index( hints, segment_idx_1, 1 ) ),
                af_print_idx( buf2, segment_idx_1 ),
                af_print_idx( buf3,
                              af_get_edge_index( hints, segment_idx_0, 0 ) ),
                af_print_idx( buf4, segment_idx_0 ),
                ( point->flags & AF_FLAG_NEAR )
                  ? " near "
                  : ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
                    ? " weak "
                    : "strong",

                point->fx,
                point->fy,
                point->ox / 64.0,
                point->oy / 64.0,
                point->x / 64.0,
                point->y / 64.0 ));
    }
    AF_DUMP(( "\n" ));
  }
#ifdef __cplusplus
  }
#endif


  static const char*
  af_edge_flags_to_string( FT_UInt  flags )
  {
    static char  temp[32];
    int          pos = 0;


    if ( flags & AF_EDGE_ROUND )
    {
      ft_memcpy( temp + pos, "round", 5 );
      pos += 5;
    }
    if ( flags & AF_EDGE_SERIF )
    {
      if ( pos > 0 )
        temp[pos++] = ' ';
      ft_memcpy( temp + pos, "serif", 5 );
      pos += 5;
    }
    if ( pos == 0 )
      return "normal";

    temp[pos] = '\0';

    return temp;
  }


  /* Dump the array of linked segments. */

#ifdef __cplusplus
  extern "C" {
#endif
  void
  af_glyph_hints_dump_segments( AF_GlyphHints  hints,
                                FT_Bool        to_stdout )
  {
    FT_Int  dimension;


    for ( dimension = 1; dimension >= 0; dimension-- )
    {
      AF_AxisHints  axis     = &hints->axis[dimension];
      AF_Point      points   = hints->points;
      AF_Edge       edges    = axis->edges;
      AF_Segment    segments = axis->segments;
      AF_Segment    limit    = segments + axis->num_segments;
      AF_Segment    seg;

      char  buf1[16], buf2[16], buf3[16];


      AF_DUMP(( "Table of %s segments:\n",
                dimension == AF_DIMENSION_HORZ ? "vertical"
                                               : "horizontal" ));
      if ( axis->num_segments )
        AF_DUMP(( "  index   pos   delta   dir   from   to "
                  "  link  serif  edge"
                  "  height  extra     flags\n" ));
      else
        AF_DUMP(( "  (none)\n" ));

      for ( seg = segments; seg < limit; seg++ )
        AF_DUMP(( "  %5d  %5d  %5d  %5s  %4d  %4d"
                  "  %4s  %5s  %4s"
                  "  %6d  %5d  %11s\n",
                  AF_INDEX_NUM( seg, segments ),
                  seg->pos,
                  seg->delta,
                  af_dir_str( (AF_Direction)seg->dir ),
                  AF_INDEX_NUM( seg->first, points ),
                  AF_INDEX_NUM( seg->last, points ),

                  af_print_idx( buf1, AF_INDEX_NUM( seg->link, segments ) ),
                  af_print_idx( buf2, AF_INDEX_NUM( seg->serif, segments ) ),
                  af_print_idx( buf3, AF_INDEX_NUM( seg->edge, edges ) ),

                  seg->height,
                  seg->height - ( seg->max_coord - seg->min_coord ),
                  af_edge_flags_to_string( seg->flags ) ));
      AF_DUMP(( "\n" ));
    }
  }
#ifdef __cplusplus
  }
#endif


  /* Fetch number of segments. */

#ifdef __cplusplus
  extern "C" {
#endif
  FT_Error
  af_glyph_hints_get_num_segments( AF_GlyphHints  hints,
                                   FT_Int         dimension,
                                   FT_Int*        num_segments )
  {
    AF_Dimension  dim;
    AF_AxisHints  axis;


    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;

    axis          = &hints->axis[dim];
    *num_segments = axis->num_segments;

    return FT_Err_Ok;
  }
#ifdef __cplusplus
  }
#endif


  /* Fetch offset of segments into user supplied offset array. */

#ifdef __cplusplus
  extern "C" {
#endif
  FT_Error
  af_glyph_hints_get_segment_offset( AF_GlyphHints  hints,
                                     FT_Int         dimension,
                                     FT_Int         idx,
                                     FT_Pos        *offset,
                                     FT_Bool       *is_blue,
                                     FT_Pos        *blue_offset )
  {
    AF_Dimension  dim;
    AF_AxisHints  axis;
    AF_Segment    seg;


    if ( !offset )
      return FT_THROW( Invalid_Argument );

    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;

    axis = &hints->axis[dim];

    if ( idx < 0 || idx >= axis->num_segments )
      return FT_THROW( Invalid_Argument );

    seg      = &axis->segments[idx];
    *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg->first->ox
                                            : seg->first->oy;
    if ( seg->edge )
      *is_blue = (FT_Bool)( seg->edge->blue_edge != 0 );
    else
      *is_blue = FALSE;

    if ( *is_blue )
      *blue_offset = seg->edge->blue_edge->cur;
    else
      *blue_offset = 0;

    return FT_Err_Ok;
  }
#ifdef __cplusplus
  }
#endif


  /* Dump the array of linked edges. */

#ifdef __cplusplus
  extern "C" {
#endif
  void
  af_glyph_hints_dump_edges( AF_GlyphHints  hints,
                             FT_Bool        to_stdout )
  {
    FT_Int  dimension;


    for ( dimension = 1; dimension >= 0; dimension-- )
    {
      AF_AxisHints  axis  = &hints->axis[dimension];
      AF_Edge       edges = axis->edges;
      AF_Edge       limit = edges + axis->num_edges;
      AF_Edge       edge;

      char  buf1[16], buf2[16];


      /*
       *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
       *        since they have a constant X coordinate.
       */
      if ( dimension == AF_DIMENSION_HORZ )
        AF_DUMP(( "Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n",
                  "vertical",
                  65536.0 * 64.0 / hints->x_scale,
                  10.0 * hints->x_scale / 65536.0 / 64.0 ));
      else
        AF_DUMP(( "Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n",
                  "horizontal",
                  65536.0 * 64.0 / hints->y_scale,
                  10.0 * hints->y_scale / 65536.0 / 64.0 ));

      if ( axis->num_edges )
        AF_DUMP(( "  index    pos     dir   link  serif"
                  "  blue    opos     pos       flags\n" ));
      else
        AF_DUMP(( "  (none)\n" ));

      for ( edge = edges; edge < limit; edge++ )
        AF_DUMP(( "  %5d  %7.2f  %5s  %4s  %5s"
                  "    %c   %7.2f  %7.2f  %11s\n",
                  AF_INDEX_NUM( edge, edges ),
                  (int)edge->opos / 64.0,
                  af_dir_str( (AF_Direction)edge->dir ),
                  af_print_idx( buf1, AF_INDEX_NUM( edge->link, edges ) ),
                  af_print_idx( buf2, AF_INDEX_NUM( edge->serif, edges ) ),

                  edge->blue_edge ? 'y' : 'n',
                  edge->opos / 64.0,
                  edge->pos / 64.0,
                  af_edge_flags_to_string( edge->flags ) ));
      AF_DUMP(( "\n" ));
    }
  }
#ifdef __cplusplus
  }
#endif

#undef AF_DUMP

#endif /* !FT_DEBUG_AUTOFIT */


  /* Compute the direction value of a given vector. */

  FT_LOCAL_DEF( AF_Direction )
  af_direction_compute( FT_Pos  dx,
                        FT_Pos  dy )
  {
    FT_Pos        ll, ss;  /* long and short arm lengths */
    AF_Direction  dir;     /* candidate direction        */


    if ( dy >= dx )
    {
      if ( dy >= -dx )
      {
        dir = AF_DIR_UP;
        ll  = dy;
        ss  = dx;
      }
      else
      {
        dir = AF_DIR_LEFT;
        ll  = -dx;
        ss  = dy;
      }
    }
    else /* dy < dx */
    {
      if ( dy >= -dx )
      {
        dir = AF_DIR_RIGHT;
        ll  = dx;
        ss  = dy;
      }
      else
      {
        dir = AF_DIR_DOWN;
        ll  = -dy;
        ss  = dx;
      }
    }

    /* return no direction if arm lengths do not differ enough       */
    /* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
    /* the long arm is never negative                                */
    if ( ll <= 14 * FT_ABS( ss ) )
      dir = AF_DIR_NONE;

    return dir;
  }


  FT_LOCAL_DEF( void )
  af_glyph_hints_init( AF_GlyphHints  hints,
                       FT_Memory      memory )
  {
    /* no need to initialize the embedded items */
    FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints->embedded ) );
    hints->memory = memory;
  }


  FT_LOCAL_DEF( void )
  af_glyph_hints_done( AF_GlyphHints  hints )
  {
    FT_Memory  memory;
    int        dim;


    if ( !( hints && hints->memory ) )
      return;

    memory = hints->memory;

    /*
     *  note that we don't need to free the segment and edge
     *  buffers since they are really within the hints->points array
     */
    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
      AF_AxisHints  axis = &hints->axis[dim];


      axis->num_segments = 0;
      axis->max_segments = 0;
      if ( axis->segments != axis->embedded.segments )
        FT_FREE( axis->segments );

      axis->num_edges = 0;
      axis->max_edges = 0;
      if ( axis->edges != axis->embedded.edges )
        FT_FREE( axis->edges );
    }

    if ( hints->contours != hints->embedded.contours )
      FT_FREE( hints->contours );
    hints->max_contours = 0;
    hints->num_contours = 0;

    if ( hints->points != hints->embedded.points )
      FT_FREE( hints->points );
    hints->max_points = 0;
    hints->num_points = 0;

    hints->memory = NULL;
  }


  /* Reset metrics. */

  FT_LOCAL_DEF( void )
  af_glyph_hints_rescale( AF_GlyphHints    hints,
                          AF_StyleMetrics  metrics )
  {
    hints->metrics      = metrics;
    hints->scaler_flags = metrics->scaler.flags;
  }


  /* Recompute all AF_Point in AF_GlyphHints from the definitions */
  /* in a source outline.                                         */

  FT_LOCAL_DEF( FT_Error )
  af_glyph_hints_reload( AF_GlyphHints  hints,
                         FT_Outline*    outline )
  {
    FT_Error   error   = FT_Err_Ok;
    AF_Point   points;
    FT_UInt    old_max, new_max;
    FT_Fixed   x_scale = hints->x_scale;
    FT_Fixed   y_scale = hints->y_scale;
    FT_Pos     x_delta = hints->x_delta;
    FT_Pos     y_delta = hints->y_delta;
    FT_Memory  memory  = hints->memory;


    hints->num_points   = 0;
    hints->num_contours = 0;

    hints->axis[0].num_segments = 0;
    hints->axis[0].num_edges    = 0;
    hints->axis[1].num_segments = 0;
    hints->axis[1].num_edges    = 0;

    /* first of all, reallocate the contours array if necessary */
    new_max = (FT_UInt)outline->n_contours;
    old_max = (FT_UInt)hints->max_contours;

    if ( new_max <= AF_CONTOURS_EMBEDDED )
    {
      if ( !hints->contours )
      {
        hints->contours     = hints->embedded.contours;
        hints->max_contours = AF_CONTOURS_EMBEDDED;
      }
    }
    else if ( new_max > old_max )
    {
      if ( hints->contours == hints->embedded.contours )
        hints->contours = NULL;

      new_max = ( new_max + 3 ) & ~3U; /* round up to a multiple of 4 */

      if ( FT_RENEW_ARRAY( hints->contours, old_max, new_max ) )
        goto Exit;

      hints->max_contours = (FT_Int)new_max;
    }

    /*
     *  then reallocate the points arrays if necessary --
     *  note that we reserve two additional point positions, used to
     *  hint metrics appropriately
     */
    new_max = (FT_UInt)( outline->n_points + 2 );
    old_max = (FT_UInt)hints->max_points;

    if ( new_max <= AF_POINTS_EMBEDDED )
    {
      if ( !hints->points )
      {
        hints->points     = hints->embedded.points;
        hints->max_points = AF_POINTS_EMBEDDED;
      }
    }
    else if ( new_max > old_max )
    {
      if ( hints->points == hints->embedded.points )
        hints->points = NULL;

      new_max = ( new_max + 2 + 7 ) & ~7U; /* round up to a multiple of 8 */

      if ( FT_RENEW_ARRAY( hints->points, old_max, new_max ) )
        goto Exit;

      hints->max_points = (FT_Int)new_max;
    }

    hints->num_points   = outline->n_points;
    hints->num_contours = outline->n_contours;

    /* We can't rely on the value of `FT_Outline.flags' to know the fill   */
    /* direction used for a glyph, given that some fonts are broken (e.g., */
    /* the Arphic ones).  We thus recompute it each time we need to.       */
    /*                                                                     */
    hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
    hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;

    if ( FT_Outline_Get_Orientation( outline ) == FT_ORIENTATION_POSTSCRIPT )
    {
      hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
      hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
    }

    hints->x_scale = x_scale;
    hints->y_scale = y_scale;
    hints->x_delta = x_delta;
    hints->y_delta = y_delta;

    hints->xmin_delta = 0;
    hints->xmax_delta = 0;

    points = hints->points;
    if ( hints->num_points == 0 )
      goto Exit;

    {
      AF_Point  point;
      AF_Point  point_limit = points + hints->num_points;

      /* value 20 in `near_limit' is heuristic */
      FT_UInt  units_per_em = hints->metrics->scaler.face->units_per_EM;
      FT_Int   near_limit   = 20 * units_per_em / 2048;


      /* compute coordinates & Bezier flags, next and prev */
      {
        FT_Vector*  vec           = outline->points;
        char*       tag           = outline->tags;
        FT_Short    endpoint      = outline->contours[0];
        AF_Point    end           = points + endpoint;
        AF_Point    prev          = end;
        FT_Int      contour_index = 0;


        for ( point = points; point < point_limit; point++, vec++, tag++ )
        {
          FT_Pos  out_x, out_y;


          point->in_dir  = (FT_Char)AF_DIR_NONE;
          point->out_dir = (FT_Char)AF_DIR_NONE;

          point->fx = (FT_Short)vec->x;
          point->fy = (FT_Short)vec->y;
          point->ox = point->x = FT_MulFix( vec->x, x_scale ) + x_delta;
          point->oy = point->y = FT_MulFix( vec->y, y_scale ) + y_delta;

          end->fx = (FT_Short)outline->points[endpoint].x;
          end->fy = (FT_Short)outline->points[endpoint].y;

          switch ( FT_CURVE_TAG( *tag ) )
          {
          case FT_CURVE_TAG_CONIC:
            point->flags = AF_FLAG_CONIC;
            break;
          case FT_CURVE_TAG_CUBIC:
            point->flags = AF_FLAG_CUBIC;
            break;
          default:
            point->flags = AF_FLAG_NONE;
          }

          out_x = point->fx - prev->fx;
          out_y = point->fy - prev->fy;

          if ( FT_ABS( out_x ) + FT_ABS( out_y ) < near_limit )
            prev->flags |= AF_FLAG_NEAR;

          point->prev = prev;
          prev->next  = point;
          prev        = point;

          if ( point == end )
          {
            if ( ++contour_index < outline->n_contours )
            {
              endpoint = outline->contours[contour_index];
              end      = points + endpoint;
              prev     = end;
            }
          }
        }
      }

      /* set up the contours array */
      {
        AF_Point*  contour       = hints->contours;
        AF_Point*  contour_limit = contour + hints->num_contours;
        short*     end           = outline->contours;
        short      idx           = 0;


        for ( ; contour < contour_limit; contour++, end++ )
        {
          contour[0] = points + idx;
          idx        = (short)( end[0] + 1 );
        }
      }

      {
        /*
         *  Compute directions of `in' and `out' vectors.
         *
         *  Note that distances between points that are very near to each
         *  other are accumulated.  In other words, the auto-hinter either
         *  prepends the small vectors between near points to the first
         *  non-near vector, or the sum of small vector lengths exceeds a
         *  threshold, thus `grouping' the small vectors.  All intermediate
         *  points are tagged as weak; the directions are adjusted also to
         *  be equal to the accumulated one.
         */

        FT_Int  near_limit2 = 2 * near_limit - 1;

        AF_Point*  contour;
        AF_Point*  contour_limit = hints->contours + hints->num_contours;


        for ( contour = hints->contours; contour < contour_limit; contour++ )
        {
          AF_Point  first = *contour;
          AF_Point  next, prev, curr;

          FT_Pos  out_x, out_y;


          /* since the first point of a contour could be part of a */
          /* series of near points, go backwards to find the first */
          /* non-near point and adjust `first'                     */

          point = first;
          prev  = first->prev;

          while ( prev != first )
          {
            out_x = point->fx - prev->fx;
            out_y = point->fy - prev->fy;

            /*
             *  We use Taxicab metrics to measure the vector length.
             *
             *  Note that the accumulated distances so far could have the
             *  opposite direction of the distance measured here.  For this
             *  reason we use `near_limit2' for the comparison to get a
             *  non-near point even in the worst case.
             */
            if ( FT_ABS( out_x ) + FT_ABS( out_y ) >= near_limit2 )
              break;

            point = prev;
            prev  = prev->prev;
          }

          /* adjust first point */
          first = point;

          /* now loop over all points of the contour to get */
          /* `in' and `out' vector directions               */

          curr = first;

          /*
           *  We abuse the `u' and `v' fields to store index deltas to the
           *  next and previous non-near point, respectively.
           *
           *  To avoid problems with not having non-near points, we point to
           *  `first' by default as the next non-near point.
           *
           */
          curr->u  = (FT_Pos)( first - curr );
          first->v = -curr->u;

          out_x = 0;
          out_y = 0;

          next = first;
          do
          {
            AF_Direction  out_dir;


            point = next;
            next  = point->next;

            out_x += next->fx - point->fx;
            out_y += next->fy - point->fy;

            if ( FT_ABS( out_x ) + FT_ABS( out_y ) < near_limit )
            {
              next->flags |= AF_FLAG_WEAK_INTERPOLATION;
              continue;
            }

            curr->u = (FT_Pos)( next - curr );
            next->v = -curr->u;

            out_dir = af_direction_compute( out_x, out_y );

            /* adjust directions for all points inbetween; */
            /* the loop also updates position of `curr'    */
            curr->out_dir = (FT_Char)out_dir;
            for ( curr = curr->next; curr != next; curr = curr->next )
            {
              curr->in_dir  = (FT_Char)out_dir;
              curr->out_dir = (FT_Char)out_dir;
            }
            next->in_dir = (FT_Char)out_dir;

            curr->u  = (FT_Pos)( first - curr );
            first->v = -curr->u;

            out_x = 0;
            out_y = 0;

          } while ( next != first );
        }

        /*
         *  The next step is to `simplify' an outline's topology so that we
         *  can identify local extrema more reliably: A series of
         *  non-horizontal or non-vertical vectors pointing into the same
         *  quadrant are handled as a single, long vector.  From a
         *  topological point of the view, the intermediate points are of no
         *  interest and thus tagged as weak.
         */

        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
            continue;

          if ( point->in_dir  == AF_DIR_NONE &&
               point->out_dir == AF_DIR_NONE )
          {
            /* check whether both vectors point into the same quadrant */

            FT_Pos  in_x, in_y;
            FT_Pos  out_x, out_y;

            AF_Point  next_u = point + point->u;
            AF_Point  prev_v = point + point->v;


            in_x = point->fx - prev_v->fx;
            in_y = point->fy - prev_v->fy;

            out_x = next_u->fx - point->fx;
            out_y = next_u->fy - point->fy;

            if ( ( in_x ^ out_x ) >= 0 && ( in_y ^ out_y ) >= 0 )
            {
              /* yes, so tag current point as weak */
              /* and update index deltas           */

              point->flags |= AF_FLAG_WEAK_INTERPOLATION;

              prev_v->u = (FT_Pos)( next_u - prev_v );
              next_u->v = -prev_v->u;
            }
          }
        }

        /*
         *  Finally, check for remaining weak points.  Everything else not
         *  collected in edges so far is then implicitly classified as strong
         *  points.
         */

        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
            continue;

          if ( point->flags & AF_FLAG_CONTROL )
          {
            /* control points are always weak */
          Is_Weak_Point:
            point->flags |= AF_FLAG_WEAK_INTERPOLATION;
          }
          else if ( point->out_dir == point->in_dir )
          {
            if ( point->out_dir != AF_DIR_NONE )
            {
              /* current point lies on a horizontal or          */
              /* vertical segment (but doesn't start or end it) */
              goto Is_Weak_Point;
            }

            {
              AF_Point  next_u = point + point->u;
              AF_Point  prev_v = point + point->v;


              if ( ft_corner_is_flat( point->fx  - prev_v->fx,
                                      point->fy  - prev_v->fy,
                                      next_u->fx - point->fx,
                                      next_u->fy - point->fy ) )
              {
                /* either the `in' or the `out' vector is much more  */
                /* dominant than the other one, so tag current point */
                /* as weak and update index deltas                   */

                prev_v->u = (FT_Pos)( next_u - prev_v );
                next_u->v = -prev_v->u;

                goto Is_Weak_Point;
              }
            }
          }
          else if ( point->in_dir == -point->out_dir )
          {
            /* current point forms a spike */
            goto Is_Weak_Point;
          }
        }
      }
    }

  Exit:
    return error;
  }


  /* Store the hinted outline in an FT_Outline structure. */

  FT_LOCAL_DEF( void )
  af_glyph_hints_save( AF_GlyphHints  hints,
                       FT_Outline*    outline )
  {
    AF_Point    point = hints->points;
    AF_Point    limit = point + hints->num_points;
    FT_Vector*  vec   = outline->points;
    char*       tag   = outline->tags;


    for ( ; point < limit; point++, vec++, tag++ )
    {
      vec->x = point->x;
      vec->y = point->y;

      if ( point->flags & AF_FLAG_CONIC )
        tag[0] = FT_CURVE_TAG_CONIC;
      else if ( point->flags & AF_FLAG_CUBIC )
        tag[0] = FT_CURVE_TAG_CUBIC;
      else
        tag[0] = FT_CURVE_TAG_ON;
    }
  }


  /****************************************************************
   *
   *                     EDGE POINT GRID-FITTING
   *
   ****************************************************************/


  /* Align all points of an edge to the same coordinate value, */
  /* either horizontally or vertically.                        */

  FT_LOCAL_DEF( void )
  af_glyph_hints_align_edge_points( AF_GlyphHints  hints,
                                    AF_Dimension   dim )
  {
    AF_AxisHints  axis          = & hints->axis[dim];
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = segments + axis->num_segments;
    AF_Segment    seg;


    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;


        if ( !edge )
          continue;

        first = seg->first;
        last  = seg->last;
        point = first;
        for (;;)
        {
          point->x      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_X;

          if ( point == last )
            break;

          point = point->next;
        }
      }
    }
    else
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;


        if ( !edge )
          continue;

        first = seg->first;
        last  = seg->last;
        point = first;
        for (;;)
        {
          point->y      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_Y;

          if ( point == last )
            break;

          point = point->next;
        }
      }
    }
  }


  /****************************************************************
   *
   *                    STRONG POINT INTERPOLATION
   *
   ****************************************************************/


  /* Hint the strong points -- this is equivalent to the TrueType `IP' */
  /* hinting instruction.                                              */

  FT_LOCAL_DEF( void )
  af_glyph_hints_align_strong_points( AF_GlyphHints  hints,
                                      AF_Dimension   dim )
  {
    AF_Point      points      = hints->points;
    AF_Point      point_limit = points + hints->num_points;
    AF_AxisHints  axis        = &hints->axis[dim];
    AF_Edge       edges       = axis->edges;
    AF_Edge       edge_limit  = edges + axis->num_edges;
    FT_UInt       touch_flag;


    if ( dim == AF_DIMENSION_HORZ )
      touch_flag = AF_FLAG_TOUCH_X;
    else
      touch_flag  = AF_FLAG_TOUCH_Y;

    if ( edges < edge_limit )
    {
      AF_Point  point;
      AF_Edge   edge;


      for ( point = points; point < point_limit; point++ )
      {
        FT_Pos  u, ou, fu;  /* point position */
        FT_Pos  delta;


        if ( point->flags & touch_flag )
          continue;

        /* if this point is candidate to weak interpolation, we       */
        /* interpolate it after all strong points have been processed */

        if ( ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) )
          continue;

        if ( dim == AF_DIMENSION_VERT )
        {
          u  = point->fy;
          ou = point->oy;
        }
        else
        {
          u  = point->fx;
          ou = point->ox;
        }

        fu = u;

        /* is the point before the first edge? */
        edge  = edges;
        delta = edge->fpos - u;
        if ( delta >= 0 )
        {
          u = edge->pos - ( edge->opos - ou );
          goto Store_Point;
        }

        /* is the point after the last edge? */
        edge  = edge_limit - 1;
        delta = u - edge->fpos;
        if ( delta >= 0 )
        {
          u = edge->pos + ( ou - edge->opos );
          goto Store_Point;
        }

        {
          FT_PtrDist  min, max, mid;
          FT_Pos      fpos;


          /* find enclosing edges */
          min = 0;
          max = edge_limit - edges;

#if 1
          /* for a small number of edges, a linear search is better */
          if ( max <= 8 )
          {
            FT_PtrDist  nn;


            for ( nn = 0; nn < max; nn++ )
              if ( edges[nn].fpos >= u )
                break;

            if ( edges[nn].fpos == u )
            {
              u = edges[nn].pos;
              goto Store_Point;
            }
            min = nn;
          }
          else
#endif
          while ( min < max )
          {
            mid  = ( max + min ) >> 1;
            edge = edges + mid;
            fpos = edge->fpos;

            if ( u < fpos )
              max = mid;
            else if ( u > fpos )
              min = mid + 1;
            else
            {
              /* we are on the edge */
              u = edge->pos;
              goto Store_Point;
            }
          }

          /* point is not on an edge */
          {
            AF_Edge  before = edges + min - 1;
            AF_Edge  after  = edges + min + 0;


            /* assert( before && after && before != after ) */
            if ( before->scale == 0 )
              before->scale = FT_DivFix( after->pos - before->pos,
                                         after->fpos - before->fpos );

            u = before->pos + FT_MulFix( fu - before->fpos,
                                         before->scale );
          }
        }

      Store_Point:
        /* save the point position */
        if ( dim == AF_DIMENSION_HORZ )
          point->x = u;
        else
          point->y = u;

        point->flags |= touch_flag;
      }
    }
  }


  /****************************************************************
   *
   *                    WEAK POINT INTERPOLATION
   *
   ****************************************************************/


  /* Shift the original coordinates of all points between `p1' and */
  /* `p2' to get hinted coordinates, using the same difference as  */
  /* given by `ref'.                                               */

  static void
  af_iup_shift( AF_Point  p1,
                AF_Point  p2,
                AF_Point  ref )
  {
    AF_Point  p;
    FT_Pos    delta = ref->u - ref->v;


    if ( delta == 0 )
      return;

    for ( p = p1; p < ref; p++ )
      p->u = p->v + delta;

    for ( p = ref + 1; p <= p2; p++ )
      p->u = p->v + delta;
  }


  /* Interpolate the original coordinates of all points between `p1' and  */
  /* `p2' to get hinted coordinates, using `ref1' and `ref2' as the       */
  /* reference points.  The `u' and `v' members are the current and       */
  /* original coordinate values, respectively.                            */
  /*                                                                      */
  /* Details can be found in the TrueType bytecode specification.         */

  static void
  af_iup_interp( AF_Point  p1,
                 AF_Point  p2,
                 AF_Point  ref1,
                 AF_Point  ref2 )
  {
    AF_Point  p;
    FT_Pos    u, v1, v2, u1, u2, d1, d2;


    if ( p1 > p2 )
      return;

    if ( ref1->v > ref2->v )
    {
      p    = ref1;
      ref1 = ref2;
      ref2 = p;
    }

    v1 = ref1->v;
    v2 = ref2->v;
    u1 = ref1->u;
    u2 = ref2->u;
    d1 = u1 - v1;
    d2 = u2 - v2;

    if ( u1 == u2 || v1 == v2 )
    {
      for ( p = p1; p <= p2; p++ )
      {
        u = p->v;

        if ( u <= v1 )
          u += d1;
        else if ( u >= v2 )
          u += d2;
        else
          u = u1;

        p->u = u;
      }
    }
    else
    {
      FT_Fixed  scale = FT_DivFix( u2 - u1, v2 - v1 );


      for ( p = p1; p <= p2; p++ )
      {
        u = p->v;

        if ( u <= v1 )
          u += d1;
        else if ( u >= v2 )
          u += d2;
        else
          u = u1 + FT_MulFix( u - v1, scale );

        p->u = u;
      }
    }
  }


  /* Hint the weak points -- this is equivalent to the TrueType `IUP' */
  /* hinting instruction.                                             */

  FT_LOCAL_DEF( void )
  af_glyph_hints_align_weak_points( AF_GlyphHints  hints,
                                    AF_Dimension   dim )
  {
    AF_Point   points        = hints->points;
    AF_Point   point_limit   = points + hints->num_points;
    AF_Point*  contour       = hints->contours;
    AF_Point*  contour_limit = contour + hints->num_contours;
    FT_UInt    touch_flag;
    AF_Point   point;
    AF_Point   end_point;
    AF_Point   first_point;


    /* PASS 1: Move segment points to edge positions */

    if ( dim == AF_DIMENSION_HORZ )
    {
      touch_flag = AF_FLAG_TOUCH_X;

      for ( point = points; point < point_limit; point++ )
      {
        point->u = point->x;
        point->v = point->ox;
      }
    }
    else
    {
      touch_flag = AF_FLAG_TOUCH_Y;

      for ( point = points; point < point_limit; point++ )
      {
        point->u = point->y;
        point->v = point->oy;
      }
    }

    for ( ; contour < contour_limit; contour++ )
    {
      AF_Point  first_touched, last_touched;


      point       = *contour;
      end_point   = point->prev;
      first_point = point;

      /* find first touched point */
      for (;;)
      {
        if ( point > end_point )  /* no touched point in contour */
          goto NextContour;

        if ( point->flags & touch_flag )
          break;

        point++;
      }

      first_touched = point;

      for (;;)
      {
        FT_ASSERT( point <= end_point                 &&
                   ( point->flags & touch_flag ) != 0 );

        /* skip any touched neighbours */
        while ( point < end_point                    &&
                ( point[1].flags & touch_flag ) != 0 )
          point++;

        last_touched = point;

        /* find the next touched point, if any */
        point++;
        for (;;)
        {
          if ( point > end_point )
            goto EndContour;

          if ( ( point->flags & touch_flag ) != 0 )
            break;

          point++;
        }

        /* interpolate between last_touched and point */
        af_iup_interp( last_touched + 1, point - 1,
                       last_touched, point );
      }

    EndContour:
      /* special case: only one point was touched */
      if ( last_touched == first_touched )
        af_iup_shift( first_point, end_point, first_touched );

      else /* interpolate the last part */
      {
        if ( last_touched < end_point )
          af_iup_interp( last_touched + 1, end_point,
                         last_touched, first_touched );

        if ( first_touched > points )
          af_iup_interp( first_point, first_touched - 1,
                         last_touched, first_touched );
      }

    NextContour:
      ;
    }

    /* now save the interpolated values back to x/y */
    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( point = points; point < point_limit; point++ )
        point->x = point->u;
    }
    else
    {
      for ( point = points; point < point_limit; point++ )
        point->y = point->u;
    }
  }


#ifdef AF_CONFIG_OPTION_USE_WARPER

  /* Apply (small) warp scale and warp delta for given dimension. */

  FT_LOCAL_DEF( void )
  af_glyph_hints_scale_dim( AF_GlyphHints  hints,
                            AF_Dimension   dim,
                            FT_Fixed       scale,
                            FT_Pos         delta )
  {
    AF_Point  points       = hints->points;
    AF_Point  points_limit = points + hints->num_points;
    AF_Point  point;


    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( point = points; point < points_limit; point++ )
        point->x = FT_MulFix( point->fx, scale ) + delta;
    }
    else
    {
      for ( point = points; point < points_limit; point++ )
        point->y = FT_MulFix( point->fy, scale ) + delta;
    }
  }

#endif /* AF_CONFIG_OPTION_USE_WARPER */

/* END */
@


1.4
log
@fastmerge
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2009 by                        */
d22 1
d25 12
d42 1
a42 1
    FT_Error    error   = AF_Err_Ok;
d46 9
a54 1
    if ( axis->num_segments >= axis->max_segments )
d63 1
a63 1
        error = AF_Err_Out_Of_Memory;
d71 12
a82 2
      if ( FT_RENEW_ARRAY( axis->segments, old_max, new_max ) )
        goto Exit;
d95 3
d102 1
d104 1
a104 1
                          AF_Edge      *aedge )
d106 1
a106 1
    FT_Error  error = AF_Err_Ok;
d111 9
a119 1
    if ( axis->num_edges >= axis->max_edges )
d128 1
a128 1
        error = AF_Err_Out_Of_Memory;
d136 12
a147 2
      if ( FT_RENEW_ARRAY( axis->edges, old_max, new_max ) )
        goto Exit;
d157 2
a158 1
      if ( edge[-1].fpos < fpos )
a171 4
    FT_ZERO( edge );
    edge->fpos = (FT_Short)fpos;
    edge->dir  = (FT_Char)dir;

d173 1
a173 1
    *aedge = edge;
d178 1
a178 1
#ifdef AF_DEBUG
d182 11
d221 30
a250 1
#define AF_INDEX_NUM( ptr, base )  ( (ptr) ? ( (ptr) - (base) ) : -1 )
d253 50
d304 2
a305 1
  af_glyph_hints_dump_points( AF_GlyphHints  hints )
d307 5
a311 3
    AF_Point  points = hints->points;
    AF_Point  limit  = points + hints->num_points;
    AF_Point  point;
d314 7
a320 3
    printf( "Table of points:\n" );
    printf(   "  [ index |  xorg |  yorg |  xscale |  yscale "
              "|  xfit  |  yfit  |  flags ]\n" );
d324 35
a358 15
      printf( "  [ %5d | %5d | %5d | %-5.2f | %-5.2f "
              "| %-5.2f | %-5.2f | %c%c%c%c%c%c ]\n",
              point - points,
              point->fx,
              point->fy,
              point->ox/64.0,
              point->oy/64.0,
              point->x/64.0,
              point->y/64.0,
              ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) ? 'w' : ' ',
              ( point->flags & AF_FLAG_INFLECTION )         ? 'i' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_X )          ? '<' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_Y )          ? 'v' : ' ',
              ( point->flags & AF_FLAG_ROUND_X )            ? '(' : ' ',
              ( point->flags & AF_FLAG_ROUND_Y )            ? 'u' : ' ');
d360 3
a362 1
    printf( "\n" );
d364 1
d368 1
a368 1
  af_edge_flags_to_string( AF_Edge_Flags  flags )
d389 1
a389 1
    temp[pos] = 0;
d395 5
a399 1
  /* A function to dump the array of linked segments. */
d401 2
a402 1
  af_glyph_hints_dump_segments( AF_GlyphHints  hints )
d410 2
d416 1
d418 10
a427 4
      printf ( "Table of %s segments:\n",
               dimension == AF_DIMENSION_HORZ ? "vertical" : "horizontal" );
      printf ( "  [ index |  pos  |  dir  | link | serif |"
               " height  | extra | flags    ]\n" );
d430 18
a447 13
      {
        printf ( "  [ %5d | %5.2g | %5s | %4d | %5d | %5d | %5d | %s ]\n",
                 seg - segments,
                 dimension == AF_DIMENSION_HORZ ? (int)seg->first->ox / 64.0
                                                : (int)seg->first->oy / 64.0,
                 af_dir_str( (AF_Direction)seg->dir ),
                 AF_INDEX_NUM( seg->link, segments ),
                 AF_INDEX_NUM( seg->serif, segments ),
                 seg->height,
                 seg->height - ( seg->max_coord - seg->min_coord ),
                 af_edge_flags_to_string( seg->flags ) );
      }
      printf( "\n" );
d450 47
d499 35
d535 2
a536 1
  af_glyph_hints_dump_edges( AF_GlyphHints  hints )
d548 2
d553 1
a553 1
       *        since they have constant a X coordinate.
d555 16
a570 4
      printf ( "Table of %s edges:\n",
               dimension == AF_DIMENSION_HORZ ? "vertical" : "horizontal" );
      printf ( "  [ index |  pos  |  dir  | link |"
               " serif | blue | opos  |  pos  | flags   ]\n" );
d573 13
a585 14
      {
        printf ( "  [ %5d | %5.2g | %5s | %4d |"
                 " %5d |   %c  | %5.2f | %5.2f | %s ]\n",
                 edge - edges,
                 (int)edge->opos / 64.0,
                 af_dir_str( (AF_Direction)edge->dir ),
                 AF_INDEX_NUM( edge->link, edges ),
                 AF_INDEX_NUM( edge->serif, edges ),
                 edge->blue_edge ? 'y' : 'n',
                 edge->opos / 64.0,
                 edge->pos / 64.0,
                 af_edge_flags_to_string( edge->flags ) );
      }
      printf( "\n" );
d588 1
a588 17

#else /* !AF_DEBUG */

  /* these empty stubs are only used to link the `ftgrid' test program */
  /* when debugging is disabled                                        */

  void
  af_glyph_hints_dump_points( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }


  void
  af_glyph_hints_dump_segments( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
d590 1
d592 1
d594 1
a594 5
  void
  af_glyph_hints_dump_edges( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }
a595 1
#endif /* !AF_DEBUG */
d597 1
a598 1
  /* compute the direction value of a given vector */
d633 1
a633 1
        ll  = dy;
d638 4
a641 2
    ss *= 14;
    if ( FT_ABS( ll ) <= FT_ABS( ss ) )
a647 114
  /* compute all inflex points in a given glyph */

  static void
  af_glyph_hints_compute_inflections( AF_GlyphHints  hints )
  {
    AF_Point*  contour       = hints->contours;
    AF_Point*  contour_limit = contour + hints->num_contours;


    /* do each contour separately */
    for ( ; contour < contour_limit; contour++ )
    {
      AF_Point  point = contour[0];
      AF_Point  first = point;
      AF_Point  start = point;
      AF_Point  end   = point;
      AF_Point  before;
      AF_Point  after;
      FT_Pos    in_x, in_y, out_x, out_y;
      AF_Angle  orient_prev, orient_cur;
      FT_Int    finished = 0;


      /* compute first segment in contour */
      first = point;

      start = end = first;
      do
      {
        end = end->next;
        if ( end == first )
          goto Skip;

        in_x = end->fx - start->fx;
        in_y = end->fy - start->fy;

      } while ( in_x == 0 && in_y == 0 );

      /* extend the segment start whenever possible */
      before = start;
      do
      {
        do
        {
          start  = before;
          before = before->prev;
          if ( before == first )
            goto Skip;

          out_x = start->fx - before->fx;
          out_y = start->fy - before->fy;

        } while ( out_x == 0 && out_y == 0 );

        orient_prev = ft_corner_orientation( in_x, in_y, out_x, out_y );

      } while ( orient_prev == 0 );

      first = start;

      in_x = out_x;
      in_y = out_y;

      /* now process all segments in the contour */
      do
      {
        /* first, extend current segment's end whenever possible */
        after = end;
        do
        {
          do
          {
            end   = after;
            after = after->next;
            if ( after == first )
              finished = 1;

            out_x = after->fx - end->fx;
            out_y = after->fy - end->fy;

          } while ( out_x == 0 && out_y == 0 );

          orient_cur = ft_corner_orientation( in_x, in_y, out_x, out_y );

        } while ( orient_cur == 0 );

        if ( ( orient_prev + orient_cur ) == 0 )
        {
          /* we have an inflection point here */
          do
          {
            start->flags |= AF_FLAG_INFLECTION;
            start = start->next;

          } while ( start != end );

          start->flags |= AF_FLAG_INFLECTION;
        }

        start = end;
        end   = after;

        orient_prev = orient_cur;
        in_x        = out_x;
        in_y        = out_y;

      } while ( !finished );

    Skip:
      ;
    }
  }


d652 2
a653 1
    FT_ZERO( hints );
d661 6
a666 4
    if ( hints && hints->memory )
    {
      FT_Memory  memory = hints->memory;
      int        dim;
d668 1
d670 7
a676 7
      /*
       *  note that we don't need to free the segment and edge
       *  buffers, since they are really within the hints->points array
       */
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_AxisHints  axis = &hints->axis[dim];
d679 3
a681 2
        axis->num_segments = 0;
        axis->max_segments = 0;
d684 3
a686 2
        axis->num_edges    = 0;
        axis->max_edges    = 0;
d688 1
a688 1
      }
d690 1
d692 2
a693 2
      hints->max_contours = 0;
      hints->num_contours = 0;
d695 1
d697 2
a698 2
      hints->num_points = 0;
      hints->max_points = 0;
d700 1
a700 2
      hints->memory = NULL;
    }
d704 2
d707 2
a708 2
  af_glyph_hints_rescale( AF_GlyphHints     hints,
                          AF_ScriptMetrics  metrics )
d715 3
d720 1
a720 2
                         FT_Outline*    outline,
                         FT_Bool        get_inflections )
d722 1
a722 1
    FT_Error   error   = AF_Err_Ok;
d740 1
a740 1
    /* first of all, reallocate the contours array when necessary */
d742 11
a752 2
    old_max = hints->max_contours;
    if ( new_max > old_max )
d754 4
a757 1
      new_max = ( new_max + 3 ) & ~3;
d762 1
a762 1
      hints->max_contours = new_max;
d771 11
a781 2
    old_max = hints->max_points;
    if ( new_max > old_max )
d783 4
a786 1
      new_max = ( new_max + 2 + 7 ) & ~7;
d791 1
a791 1
      hints->max_points = new_max;
d826 4
d835 2
a836 2
        AF_Point    first         = points;
        AF_Point    end           = points + outline->contours[0];
a840 1
        FT_UNUSED( first );
d843 6
d854 3
d866 1
a866 1
            point->flags = 0;
d869 6
d883 3
a885 3
              first = point + 1;
              end   = points + outline->contours[contour_index];
              prev  = end;
d891 1
a891 1
      /* set-up the contours array */
a905 1
      /* compute directions of in & out vectors */
d907 16
a922 5
        AF_Point      first  = points;
        AF_Point      prev   = NULL;
        FT_Pos        in_x   = 0;
        FT_Pos        in_y   = 0;
        AF_Direction  in_dir = AF_DIR_NONE;
d925 1
a925 1
        for ( point = points; point < point_limit; point++ )
d927 4
a930 2
          AF_Point  next;
          FT_Pos    out_x, out_y;
d933 8
a940 1
          if ( point == first )
d942 16
a957 5
            prev   = first->prev;
            in_x   = first->fx - prev->fx;
            in_y   = first->fy - prev->fy;
            in_dir = af_direction_compute( in_x, in_y );
            first  = prev + 1;
d960 5
a964 1
          point->in_dir = (FT_Char)in_dir;
d966 1
a966 3
          next  = point->next;
          out_x = next->fx - point->fx;
          out_y = next->fy - point->fy;
d968 10
a977 2
          in_dir         = af_direction_compute( out_x, out_y );
          point->out_dir = (FT_Char)in_dir;
d979 5
a983 1
          if ( point->flags & ( AF_FLAG_CONIC | AF_FLAG_CUBIC ) )
d985 98
d1089 3
d1093 18
d1112 3
a1114 2
            if ( ft_corner_is_flat( in_x, in_y, out_x, out_y ) )
              goto Is_Weak_Point;
d1117 2
d1120 1
a1120 4

          in_x = out_x;
          in_y = out_y;
          prev = point;
a1124 5
    /* compute inflection points --                 */
    /* disabled due to no longer perceived benefits */
    if ( 0 && get_inflections )
      af_glyph_hints_compute_inflections( hints );

d1130 2
d1164 3
d1185 1
a1185 1
        if ( edge == NULL )
a1199 1

d1211 1
a1211 1
        if ( edge == NULL )
d1239 2
a1240 2
  /* hint the strong points -- this is equivalent to the TrueType `IP' */
  /* hinting instruction                                               */
d1251 1
a1251 1
    AF_Flags      touch_flag;
d1277 1
a1277 2
        if (  ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) &&
             !( point->flags & AF_FLAG_INFLECTION )         )
d1321 1
a1321 1
          /* for small edge counts, a linear search is better */
d1326 1
d1358 1
d1394 4
d1406 1
d1418 7
d1432 1
a1432 5
    FT_Pos    u;
    FT_Pos    v1 = ref1->v;
    FT_Pos    v2 = ref2->v;
    FT_Pos    d1 = ref1->u - v1;
    FT_Pos    d2 = ref2->u - v2;
d1438 1
a1438 1
    if ( v1 == v2 )
d1440 4
a1443 3
      for ( p = p1; p <= p2; p++ )
      {
        u = p->v;
d1445 6
a1450 9
        if ( u <= v1 )
          u += d1;
        else
          u += d2;

        p->u = u;
      }
      return;
    }
d1452 1
a1452 1
    if ( v1 < v2 )
d1463 1
a1463 1
          u = ref1->u + FT_MulDiv( u - v1, ref2->u - ref1->u, v2 - v1 );
d1470 3
d1477 3
a1479 1
        if ( u <= v2 )
a1480 2
        else if ( u >= v1 )
          u += d1;
d1482 1
a1482 1
          u = ref1->u + FT_MulDiv( u - v1, ref2->u - ref1->u, v2 - v1 );
d1490 3
d1501 1
a1501 1
    AF_Flags   touch_flag;
a1529 2
    point = points;

a1551 1
      last_touched  = point;
d1555 1
a1555 1
        FT_ASSERT( point <= end_point &&
d1558 3
a1560 2
        /* skip any touched neighbhours */
        while ( point < end_point && ( point[1].flags & touch_flag ) != 0 )
d1566 1
a1566 1
        point ++;
a1585 1
      {
d1587 1
a1587 1
      }
d1617 3
a1619 1
#ifdef AF_USE_WARPER
d1644 1
a1644 1
#endif /* AF_USE_WARPER */
@


1.3
log
@Merge freetype 2.3.5, all conflicts automatically resolved
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
d37 1
a37 1
      FT_Int  big_max = FT_INT_MAX / sizeof ( *segment );
d80 1
a80 1
      FT_Int  big_max = FT_INT_MAX / sizeof ( *edge );
d130 1
a130 1
#include <stdio.h>
d206 1
a206 1
      memcpy( temp + pos, "round", 5 );
d213 1
a213 1
      memcpy( temp + pos, "serif", 5 );
d648 1
d944 2
a945 2
          FT_UInt  min, max, mid;
          FT_Pos   fpos;
d956 1
a956 1
            FT_UInt  nn;
@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
d21 1
a56 1
    FT_ZERO( segment );
d67 1
d102 1
a102 1
    while ( edge > edges && edge[-1].fpos > fpos )
d104 8
d120 1
d197 28
d229 1
a229 2
    AF_Point  points = hints->points;
    FT_Int    dimension;
d242 2
a243 2
      printf ( "  [ index |  pos |  dir  | link | serif |"
               " numl | first | start ]\n" );
d247 1
a247 1
        printf ( "  [ %5d | %4d | %5s | %4d | %5d | %4d | %5d | %5d ]\n",
d249 3
a251 2
                 (int)seg->pos,
                 af_dir_str( seg->dir ),
d254 3
a256 3
                 (int)seg->num_linked,
                 seg->first - points,
                 seg->last - points );
d283 2
a284 2
      printf ( "  [ index |  pos |  dir  | link |"
               " serif | blue | opos  |  pos  ]\n" );
d288 2
a289 2
        printf ( "  [ %5d | %4d | %5s | %4d |"
                 " %5d |   %c  | %5.2f | %5.2f ]\n",
d291 2
a292 2
                 (int)edge->fpos,
                 af_dir_str( edge->dir ),
d297 2
a298 1
                 edge->pos / 64.0 );
d304 11
a314 1
#endif /* AF_DEBUG */
d316 14
d337 2
a338 2
#if 1
    AF_Direction  dir = AF_DIR_NONE;
d341 1
a341 3
    /* atan(1/12) == 4.7 degrees */

    if ( dx < 0 )
d343 1
a343 1
      if ( dy < 0 )
d345 3
a347 5
        if ( -dx * 12 < -dy )
          dir = AF_DIR_DOWN;

        else if ( -dy * 12 < -dx )
          dir = AF_DIR_LEFT;
d349 1
a349 1
      else /* dy >= 0 */
d351 3
a353 5
        if ( -dx * 12 < dy )
          dir = AF_DIR_UP;

        else if ( dy * 12 < -dx )
          dir = AF_DIR_LEFT;
d356 1
a356 1
    else /* dx >= 0 */
d358 1
a358 1
      if ( dy < 0 )
d360 3
a362 5
        if ( dx * 12 < -dy )
          dir = AF_DIR_DOWN;

        else if ( -dy * 12 < dx )
          dir = AF_DIR_RIGHT;
d364 1
a364 1
      else  /* dy >= 0 */
d366 3
a368 5
        if ( dx * 12 < dy )
          dir = AF_DIR_UP;

        else if ( dy * 12 < dx )
          dir = AF_DIR_RIGHT;
d372 3
a374 23
    return dir;

#else /* 0 */

    AF_Direction  dir;
    FT_Pos        ax = FT_ABS( dx );
    FT_Pos        ay = FT_ABS( dy );


    dir = AF_DIR_NONE;

    /* atan(1/12) == 4.7 degrees */

    /* test for vertical direction */
    if ( ax * 12 < ay )
    {
      dir = dy > 0 ? AF_DIR_UP : AF_DIR_DOWN;
    }
    /* test for horizontal direction */
    else if ( ay * 12 < ax )
    {
      dir = dx > 0 ? AF_DIR_RIGHT : AF_DIR_LEFT;
    }
a376 3

#endif /* 0 */

d381 1
d398 2
a399 2
      AF_Angle  angle_in, angle_seg, angle_out;
      AF_Angle  diff_in, diff_out;
d413 2
a414 1
      } while ( end->fx == first->fx && end->fy == first->fy );
d416 1
a416 2
      angle_seg = af_angle_atan( end->fx - start->fx,
                                 end->fy - start->fy );
d429 2
a430 1
        } while ( before->fx == start->fx && before->fy == start->fy );
d432 1
a432 2
        angle_in = af_angle_atan( start->fx - before->fx,
                                  start->fy - before->fy );
d434 3
a436 1
      } while ( angle_in == angle_seg );
d440 2
a441 1
      AF_ANGLE_DIFF( diff_in, angle_in, angle_seg );
d443 1
a443 1
      /* now, process all segments in the contour */
d457 2
a458 1
          } while ( end->fx == after->fx && end->fy == after->fy );
d460 1
a460 2
          angle_out = af_angle_atan( after->fx - end->fx,
                                     after->fy - end->fy );
d462 1
a462 1
        } while ( angle_out == angle_seg );
d464 1
a464 1
        AF_ANGLE_DIFF( diff_out, angle_seg, angle_out );
d466 1
a466 1
        if ( ( diff_in ^ diff_out ) < 0 )
d468 1
a468 2
          /* diff_in and diff_out have different signs, we have */
          /* inflection points here...                          */
d479 6
a484 4
        start     = end;
        end       = after;
        angle_seg = angle_out;
        diff_in   = diff_out;
d554 2
a555 1
                         FT_Outline*    outline )
d626 3
d638 1
a638 1
      /* compute coordinates & Bezier flags */
d640 6
a645 2
        FT_Vector*  vec = outline->points;
        char*       tag = outline->tags;
a665 2
        }
      }
d667 3
a669 13
      /* compute `next' and `prev' */
      {
        FT_Int    contour_index;
        AF_Point  prev;
        AF_Point  first;
        AF_Point  end;


        contour_index = 0;

        first = points;
        end   = points + outline->contours[0];
        prev  = end;
d671 1
a671 4
        for ( point = points; point < point_limit; point++ )
        {
          point->prev = prev;
          if ( point < end )
d673 1
a673 8
            point->next = point + 1;
            prev        = point;
          }
          else
          {
            point->next = first;
            contour_index++;
            if ( point + 1 < point_limit )
d675 1
a676 1
              first = point + 1;
d700 7
a708 1
          AF_Point  prev;
d710 1
a710 1
          FT_Pos    in_x, in_y, out_x, out_y;
d713 8
a720 3
          prev   = point->prev;
          in_x   = point->fx - prev->fx;
          in_y   = point->fy - prev->fy;
d722 1
a722 1
          point->in_dir = (FT_Char)af_direction_compute( in_x, in_y );
d724 3
a726 3
          next   = point->next;
          out_x  = next->fx - point->fx;
          out_y  = next->fy - point->fy;
d728 2
a729 1
          point->out_dir = (FT_Char)af_direction_compute( out_x, out_y );
a737 3
            AF_Angle  angle_in, angle_out, delta;


d741 1
a741 6
            angle_in  = af_angle_atan( in_x, in_y );
            angle_out = af_angle_atan( out_x, out_y );

            AF_ANGLE_DIFF( delta, angle_in, angle_out );

            if ( delta < 2 && delta > -2 )
d746 4
d754 4
a757 2
    /* compute inflection points */
    af_glyph_hints_compute_inflections( hints );
d800 4
a803 4
    AF_AxisHints  axis       = & hints->axis[dim];
    AF_Edge       edges      = axis->edges;
    AF_Edge       edge_limit = edges + axis->num_edges;
    AF_Edge       edge;
d806 1
a806 1
    for ( edge = edges; edge < edge_limit; edge++ )
d808 4
a811 3
      /* move the points of each segment     */
      /* in each edge to the edge's position */
      AF_Segment  seg = edge->first;
d814 22
a835 1
      do
d837 3
a839 1
        AF_Point  point = seg->first;
d841 2
d844 3
d849 2
a850 10
          if ( dim == AF_DIMENSION_HORZ )
          {
            point->x      = edge->pos;
            point->flags |= AF_FLAG_TOUCH_X;
          }
          else
          {
            point->y      = edge->pos;
            point->flags |= AF_FLAG_TOUCH_Y;
          }
d852 1
a852 1
          if ( point == seg->last )
d857 1
a857 4

        seg = seg->edge_next;

      } while ( seg != edge->first );
d951 19
d1031 2
d1151 3
d1158 9
a1166 1
      while ( point <= end_point && !( point->flags & touch_flag ) )
d1168 4
d1173 1
a1173 1
      if ( point <= end_point )
d1175 2
a1176 2
        AF_Point  first_touched = point;
        AF_Point  cur_touched   = point;
d1178 5
d1184 3
a1186 2
        point++;
        while ( point <= end_point )
d1188 6
a1193 8
          if ( point->flags & touch_flag )
          {
            /* we found two successive touched points; we interpolate */
            /* all contour points between them                        */
            af_iup_interp( cur_touched + 1, point - 1,
                           cur_touched, point );
            cur_touched = point;
          }
d1197 20
a1216 19
        if ( cur_touched == first_touched )
        {
          /* this is a special case: only one point was touched in the */
          /* contour; we thus simply shift the whole contour           */
          af_iup_shift( first_point, end_point, cur_touched );
        }
        else
        {
          /* now interpolate after the last touched point to the end */
          /* of the contour                                          */
          af_iup_interp( cur_touched + 1, end_point,
                         cur_touched, first_touched );

          /* if the first contour point isn't touched, interpolate */
          /* from the contour start to the first touched point     */
          if ( first_touched > points )
            af_iup_interp( first_point, first_touched - 1,
                           cur_touched, first_touched );
        }
d1218 3
d1248 1
a1248 1
    
@


1.1
log
@Initial revision
@
text
@d1 17
a17 1
/* $XFree86: xc/extras/freetype2/src/autofit/afhints.c,v 1.2 2004/06/09 18:52:02 tsi Exp $ */
d20 97
d122 2
a123 1
  static const char* af_dir_str( AF_Direction  dir )
d127 2
a128 1
    switch (dir)
d130 14
a143 5
     case AF_DIR_UP: result = "up"; break;
     case AF_DIR_DOWN: result = "down"; break;
     case AF_DIR_LEFT: result = "left"; break;
     case AF_DIR_RIGHT: result = "right"; break;
     default: result = "none";
d145 1
d149 3
a151 1
#define  AF_INDEX_NUM(ptr,base)  ( (ptr) ? ((ptr)-(base)) : -1 )
d160 1
d162 3
a164 1
    printf(   "  [ index |  xorg |  yorg |  xscale |  yscale |  xfit  |  yfit  |  flags ]\n" );
d167 2
a168 1
      printf( "  [ %5d | %5d | %5d | %-5.2f | %-5.2f | %-5.2f | %-5.2f | %c%c%c%c%c%c ]\n",
d176 6
a181 7
              (point->flags & AF_FLAG_WEAK_INTERPOLATION) ? 'w' : ' ',
              (point->flags & AF_FLAG_INFLECTION)         ? 'i' : ' ',
              (point->flags & AF_FLAG_EXTREMA_X)          ? '<' : ' ',
              (point->flags & AF_FLAG_EXTREMA_Y)          ? 'v' : ' ',
              (point->flags & AF_FLAG_ROUND_X)            ? '(' : ' ',
              (point->flags & AF_FLAG_ROUND_Y)            ? 'u' : ' '
            );
d187 1
a187 1
  /* A function used to dump the array of linked segments */
d191 3
a193 2
    AF_Point    points = hints->points;
    FT_Int      dimension;
d197 1
a197 1
      AF_AxisHints  axis = &hints->axis[dimension];
d228 2
a229 1
    FT_Int      dimension;
d233 1
a233 1
      AF_AxisHints  axis  = &hints->axis[ dimension ];
d238 5
a242 3
     /* note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
      * since they have constant X coordinate
      */
d250 2
a251 1
        printf ( "  [ %5d | %4d | %5s | %4d | %5d |  %c  | %5.2f | %5.2f ]\n",
a260 1

d265 1
a267 2
#endif /* AF_DEBUG */

d274 49
d344 3
d361 9
a369 9
      AF_Point   point = contour[0];
      AF_Point   first = point;
      AF_Point   start = point;
      AF_Point   end   = point;
      AF_Point   before;
      AF_Point   after;
      AF_Angle   angle_in, angle_seg, angle_out;
      AF_Angle   diff_in, diff_out;
      FT_Int     finished = 0;
d405 3
a407 2
      first   = start;
      diff_in = af_angle_diff( angle_in, angle_seg );
d430 1
a430 1
        diff_out = af_angle_diff( angle_seg, angle_out );
a458 1

a467 1

d473 2
a474 2
      FT_Memory     memory = hints->memory;
      AF_Dimension  dim;
d476 6
a481 4
     /* note that we don't need to free the segment and edge
      * buffers, since they're really within the hints->points array
      */
      for ( dim = AF_DIMENSION_HORZ; dim < AF_DIMENSION_MAX; dim++ )
d483 2
a484 1
        AF_AxisHints  axis = &hints->axis[ dim ];
d487 3
d491 2
a492 2
        axis->segments     = NULL;
        axis->edges        = NULL;
d508 8
d518 11
a528 13
  af_glyph_hints_reset( AF_GlyphHints     hints,
                        AF_Scaler         scaler,
                        AF_ScriptMetrics  metrics,
                        FT_Outline*       outline )
  {
    FT_Error     error        = FT_Err_Ok;
    AF_Point     points;
    FT_UInt      old_max, new_max;
    FT_Fixed     x_scale = scaler->x_scale;
    FT_Fixed     y_scale = scaler->y_scale;
    FT_Pos       x_delta = scaler->x_delta;
    FT_Pos       y_delta = scaler->y_delta;
    FT_Memory    memory  = hints->memory;
a529 1
    hints->metrics = metrics;
d531 2
a532 5
    hints->scaler_flags = scaler->flags;
    hints->other_flags  = 0;

    hints->num_points    = 0;
    hints->num_contours  = 0;
d539 2
a540 3
   /* first of all, reallocate the contours array when necessary
    */
    new_max = (FT_UInt) outline->n_contours;
d544 1
a544 1
      new_max = (new_max + 3) & ~3;
d552 5
a556 4
   /* then, reallocate the points, segments & edges arrays if needed --
    * note that we reserved two additional point positions, used to
    * hint metrics appropriately
    */
a560 11
      FT_Byte*    items;
      FT_ULong    off1, off2, off3;

     /* we store in a single buffer the following arrays:
      *
      *  - an array of   N  AF_PointRec   items
      *  - an array of 2*N  AF_SegmentRec items
      *  - an array of 2*N  AF_EdgeRec    items
      *
      */

d563 1
a563 21
#define OFF_PAD2(x,y)   (((x)+(y)-1) & ~((y)-1))
#define OFF_PADX(x,y)   ((((x)+(y)-1)/(y))*(y))
#define OFF_PAD(x,y)    ( ((y) & ((y)-1)) ? OFF_PADX(x,y) : OFF_PAD2(x,y) )

#undef  OFF_INCREMENT
#define OFF_INCREMENT( _off, _type, _count )   \
     ( OFF_PAD( _off, sizeof(_type) ) + (_count)*sizeof(_type))

      off1 = OFF_INCREMENT( 0, AF_PointRec, new_max );
      off2 = OFF_INCREMENT( off1, AF_SegmentRec, new_max*2 );
      off3 = OFF_INCREMENT( off2, AF_EdgeRec, new_max*2 );

      FT_FREE( hints->points );

      if ( FT_ALLOC( items, off3 ) )
      {
        hints->max_points       = 0;
        hints->axis[0].segments = NULL;
        hints->axis[0].edges    = NULL;
        hints->axis[1].segments = NULL;
        hints->axis[1].edges    = NULL;
a564 6
      }

     /* readjust some pointers
      */
      hints->max_points       = new_max;
      hints->points           = (AF_Point) items;
d566 1
a566 5
      hints->axis[0].segments = (AF_Segment)( items + off1 );
      hints->axis[1].segments = hints->axis[0].segments + new_max;

      hints->axis[0].edges    = (AF_Edge)   ( items + off2 );
      hints->axis[1].edges    = hints->axis[0].edges + new_max;
d572 6
a577 7

    /* We can't rely on the value of `FT_Outline.flags' to know the fill  */
    /* direction used for a glyph, given that some fonts are broken (e.g. */
    /* the Arphic ones).  We thus recompute it each time we need to.      */
    /*                                                                    */
    hints->axis[ AF_DIMENSION_HORZ ].major_dir = AF_DIR_UP;
    hints->axis[ AF_DIMENSION_VERT ].major_dir = AF_DIR_LEFT;
d581 2
a582 2
      hints->axis[ AF_DIMENSION_HORZ ].major_dir = AF_DIR_DOWN;
      hints->axis[ AF_DIMENSION_VERT ].major_dir = AF_DIR_RIGHT;
d599 1
a599 1
      /* compute coordinates & bezier flags */
d607 2
a608 2
          point->fx = vec->x;
          point->fy = vec->y;
d621 1
a621 2
            point->flags = AF_FLAG_NONE;
            ;
d681 3
a683 3
          AF_Point   prev;
          AF_Point   next;
          FT_Pos     in_x, in_y, out_x, out_y;
d690 1
a690 1
          point->in_dir = af_direction_compute( in_x, in_y );
d696 1
a696 1
          point->out_dir = af_direction_compute( out_x, out_y );
d713 2
a714 1
            delta     = af_angle_diff( angle_in, angle_out );
d725 1
a725 2
   /* compute inflection points
    */
d734 2
a735 2
  af_glyph_hints_save( AF_GlyphHints   hints,
                       FT_Outline*     outline )
d742 1
d745 2
a746 2
      vec->x = (FT_Pos) point->x;
      vec->y = (FT_Pos) point->y;
d758 5
a762 5
 /*
  *
  *  E D G E   P O I N T   G R I D - F I T T I N G
  *
  */
d769 1
a769 1
    AF_AxisHints  axis       = & hints->axis[ dim ];
d774 1
d813 5
a817 5
 /*
  *
  *  S T R O N G   P O I N T   I N T E R P O L A T I O N
  *
  */
d822 1
d845 1
d855 1
a855 1
        /* if this point is candidate to weak interpolation, we will  */
d857 1
a934 1

a935 1

d948 6
a953 5
 /*
  *
  *  W E A K   P O I N T   I N T E R P O L A T I O N
  *
  */
d1044 8
a1051 8
    AF_Point    points        = hints->points;
    AF_Point    point_limit   = points + hints->num_points;
    AF_Point*   contour       = hints->contours;
    AF_Point*   contour_limit = contour + hints->num_contours;
    AF_Flags    touch_flag;
    AF_Point    point;
    AF_Point    end_point;
    AF_Point    first_point;
d1077 1
a1077 1
    point   = points;
d1142 30
@


1.1.1.1
log
@Import freetype-2.3.5 into the X11 tree. This is a recommended security
update for everyone.
@
text
@d1 1
a1 17
/***************************************************************************/
/*                                                                         */
/*  afhints.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (body).                                 */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

a3 107
#include "aferrors.h"
#include FT_INTERNAL_CALC_H


  FT_LOCAL_DEF( FT_Error )
  af_axis_hints_new_segment( AF_AxisHints  axis,
                             FT_Memory     memory,
                             AF_Segment   *asegment )
  {
    FT_Error    error   = AF_Err_Ok;
    AF_Segment  segment = NULL;


    if ( axis->num_segments >= axis->max_segments )
    {
      FT_Int  old_max = axis->max_segments;
      FT_Int  new_max = old_max;
      FT_Int  big_max = FT_INT_MAX / sizeof ( *segment );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( FT_RENEW_ARRAY( axis->segments, old_max, new_max ) )
        goto Exit;

      axis->max_segments = new_max;
    }

    segment = axis->segments + axis->num_segments++;

  Exit:
    *asegment = segment;
    return error;
  }


  FT_LOCAL( FT_Error )
  af_axis_hints_new_edge( AF_AxisHints  axis,
                          FT_Int        fpos,
                          AF_Direction  dir,
                          FT_Memory     memory,
                          AF_Edge      *aedge )
  {
    FT_Error  error = AF_Err_Ok;
    AF_Edge   edge  = NULL;
    AF_Edge   edges;


    if ( axis->num_edges >= axis->max_edges )
    {
      FT_Int  old_max = axis->max_edges;
      FT_Int  new_max = old_max;
      FT_Int  big_max = FT_INT_MAX / sizeof ( *edge );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( FT_RENEW_ARRAY( axis->edges, old_max, new_max ) )
        goto Exit;

      axis->max_edges = new_max;
    }

    edges = axis->edges;
    edge  = edges + axis->num_edges;

    while ( edge > edges )
    {
      if ( edge[-1].fpos < fpos )
        break;

      /* we want the edge with same position and minor direction */
      /* to appear before those in the major one in the list     */
      if ( edge[-1].fpos == fpos && dir == axis->major_dir )
        break;

      edge[0] = edge[-1];
      edge--;
    }

    axis->num_edges++;

    FT_ZERO( edge );
    edge->fpos = (FT_Short)fpos;
    edge->dir  = (FT_Char)dir;

  Exit:
    *aedge = edge;
    return error;
  }

d9 1
a9 2
  static const char*
  af_dir_str( AF_Direction  dir )
d13 1
a13 2

    switch ( dir )
d15 5
a19 14
    case AF_DIR_UP:
      result = "up";
      break;
    case AF_DIR_DOWN:
      result = "down";
      break;
    case AF_DIR_LEFT:
      result = "left";
      break;
    case AF_DIR_RIGHT:
      result = "right";
      break;
    default:
      result = "none";
a20 1

d24 1
a24 3

#define AF_INDEX_NUM( ptr, base )  ( (ptr) ? ( (ptr) - (base) ) : -1 )

a32 1

d34 1
a34 3
    printf(   "  [ index |  xorg |  yorg |  xscale |  yscale "
              "|  xfit  |  yfit  |  flags ]\n" );

d37 1
a37 2
      printf( "  [ %5d | %5d | %5d | %-5.2f | %-5.2f "
              "| %-5.2f | %-5.2f | %c%c%c%c%c%c ]\n",
d45 7
a51 6
              ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) ? 'w' : ' ',
              ( point->flags & AF_FLAG_INFLECTION )         ? 'i' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_X )          ? '<' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_Y )          ? 'v' : ' ',
              ( point->flags & AF_FLAG_ROUND_X )            ? '(' : ' ',
              ( point->flags & AF_FLAG_ROUND_Y )            ? 'u' : ' ');
d57 1
a57 29
  static const char*
  af_edge_flags_to_string( AF_Edge_Flags  flags )
  {
    static char  temp[32];
    int          pos = 0;


    if ( flags & AF_EDGE_ROUND )
    {
      memcpy( temp + pos, "round", 5 );
      pos += 5;
    }
    if ( flags & AF_EDGE_SERIF )
    {
      if ( pos > 0 )
        temp[pos++] = ' ';
      memcpy( temp + pos, "serif", 5 );
      pos += 5;
    }
    if ( pos == 0 )
      return "normal";

    temp[pos] = 0;

    return temp;
  }


  /* A function to dump the array of linked segments. */
d61 2
a62 2
    FT_Int  dimension;

d66 1
a66 1
      AF_AxisHints  axis     = &hints->axis[dimension];
d74 2
a75 2
      printf ( "  [ index |  pos  |  dir  | link | serif |"
               " height  | extra | flags    ]\n" );
d79 1
a79 1
        printf ( "  [ %5d | %5.2g | %5s | %4d | %5d | %5d | %5d | %s ]\n",
d81 2
a82 3
                 dimension == AF_DIMENSION_HORZ ? (int)seg->first->ox / 64.0
                                                : (int)seg->first->oy / 64.0,
                 af_dir_str( (AF_Direction)seg->dir ),
d85 3
a87 3
                 seg->height,
                 seg->height - ( seg->max_coord - seg->min_coord ),
                 af_edge_flags_to_string( seg->flags ) );
d97 1
a97 2
    FT_Int  dimension;

d101 1
a101 1
      AF_AxisHints  axis  = &hints->axis[dimension];
d106 3
a108 5

      /*
       *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
       *        since they have constant a X coordinate.
       */
d111 2
a112 2
      printf ( "  [ index |  pos  |  dir  | link |"
               " serif | blue | opos  |  pos  | flags   ]\n" );
d116 1
a116 2
        printf ( "  [ %5d | %5.2g | %5s | %4d |"
                 " %5d |   %c  | %5.2f | %5.2f | %s ]\n",
d118 2
a119 2
                 (int)edge->opos / 64.0,
                 af_dir_str( (AF_Direction)edge->dir ),
d124 1
a124 2
                 edge->pos / 64.0,
                 af_edge_flags_to_string( edge->flags ) );
d126 1
a130 1
#else /* !AF_DEBUG */
a131 2
  /* these empty stubs are only used to link the `ftgrid' test program */
  /* when debugging is disabled                                        */
d133 1
a133 21
  void
  af_glyph_hints_dump_points( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }


  void
  af_glyph_hints_dump_segments( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }


  void
  af_glyph_hints_dump_edges( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }

#endif /* !AF_DEBUG */
d141 4
a144 2
    FT_Pos        ll, ss;  /* long and short arm lengths */
    AF_Direction  dir;     /* candidate direction        */
d146 1
d148 4
a151 1
    if ( dy >= dx )
d153 1
a153 12
      if ( dy >= -dx )
      {
        dir = AF_DIR_UP;
        ll  = dy;
        ss  = dx;
      }
      else
      {
        dir = AF_DIR_LEFT;
        ll  = -dx;
        ss  = dy;
      }
d155 2
a156 1
    else /* dy < dx */
d158 1
a158 12
      if ( dy >= -dx )
      {
        dir = AF_DIR_RIGHT;
        ll  = dx;
        ss  = dy;
      }
      else
      {
        dir = AF_DIR_DOWN;
        ll  = dy;
        ss  = dx;
      }
a160 4
    ss *= 14;
    if ( FT_ABS( ll ) <= FT_ABS( ss ) )
      dir = AF_DIR_NONE;

a165 1

d176 9
a184 9
      AF_Point  point = contour[0];
      AF_Point  first = point;
      AF_Point  start = point;
      AF_Point  end   = point;
      AF_Point  before;
      AF_Point  after;
      FT_Pos    in_x, in_y, out_x, out_y;
      AF_Angle  orient_prev, orient_cur;
      FT_Int    finished = 0;
d197 1
a197 2
        in_x = end->fx - start->fx;
        in_y = end->fy - start->fy;
d199 2
a200 1
      } while ( in_x == 0 && in_y == 0 );
d213 1
a213 6
          out_x = start->fx - before->fx;
          out_y = start->fy - before->fy;

        } while ( out_x == 0 && out_y == 0 );

        orient_prev = ft_corner_orientation( in_x, in_y, out_x, out_y );
d215 2
a216 1
      } while ( orient_prev == 0 );
d218 1
a218 1
      first = start;
d220 2
a221 2
      in_x = out_x;
      in_y = out_y;
d223 1
a223 1
      /* now process all segments in the contour */
d237 1
a237 2
            out_x = after->fx - end->fx;
            out_y = after->fy - end->fy;
d239 2
a240 1
          } while ( out_x == 0 && out_y == 0 );
d242 1
a242 1
          orient_cur = ft_corner_orientation( in_x, in_y, out_x, out_y );
d244 1
a244 1
        } while ( orient_cur == 0 );
d246 1
a246 1
        if ( ( orient_prev + orient_cur ) == 0 )
d248 2
a249 1
          /* we have an inflection point here */
d260 4
a263 6
        start = end;
        end   = after;

        orient_prev = orient_cur;
        in_x        = out_x;
        in_y        = out_y;
d273 1
d283 1
d289 2
a290 3
      FT_Memory  memory = hints->memory;
      int        dim;

d292 4
a295 5
      /*
       *  note that we don't need to free the segment and edge
       *  buffers, since they are really within the hints->points array
       */
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
d297 1
a297 2
        AF_AxisHints  axis = &hints->axis[dim];

a299 3
        axis->max_segments = 0;
        FT_FREE( axis->segments );

d301 2
a302 2
        axis->max_edges    = 0;
        FT_FREE( axis->edges );
a317 7
  FT_LOCAL_DEF( void )
  af_glyph_hints_rescale( AF_GlyphHints     hints,
                          AF_ScriptMetrics  metrics )
  {
    hints->metrics      = metrics;
    hints->scaler_flags = metrics->scaler.flags;
  }
d319 14
d334 1
a334 13
  FT_LOCAL_DEF( FT_Error )
  af_glyph_hints_reload( AF_GlyphHints  hints,
                         FT_Outline*    outline,
                         FT_Bool        get_inflections )
  {
    FT_Error   error   = AF_Err_Ok;
    AF_Point   points;
    FT_UInt    old_max, new_max;
    FT_Fixed   x_scale = hints->x_scale;
    FT_Fixed   y_scale = hints->y_scale;
    FT_Pos     x_delta = hints->x_delta;
    FT_Pos     y_delta = hints->y_delta;
    FT_Memory  memory  = hints->memory;
d336 2
d339 2
a340 2
    hints->num_points   = 0;
    hints->num_contours = 0;
d347 3
a349 2
    /* first of all, reallocate the contours array when necessary */
    new_max = (FT_UInt)outline->n_contours;
d353 1
a353 1
      new_max = ( new_max + 3 ) & ~3;
d361 4
a364 5
    /*
     *  then reallocate the points arrays if necessary --
     *  note that we reserve two additional point positions, used to
     *  hint metrics appropriately
     */
d369 11
d382 21
a402 1
      if ( FT_RENEW_ARRAY( hints->points, old_max, new_max ) )
d404 1
d406 10
a415 1
      hints->max_points = new_max;
d421 7
a427 6
    /* We can't rely on the value of `FT_Outline.flags' to know the fill   */
    /* direction used for a glyph, given that some fonts are broken (e.g., */
    /* the Arphic ones).  We thus recompute it each time we need to.       */
    /*                                                                     */
    hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
    hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;
d431 2
a432 2
      hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
      hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
a439 3
    hints->xmin_delta = 0;
    hints->xmax_delta = 0;

d449 1
a449 1
      /* compute coordinates & Bezier flags, next and prev */
d451 2
a452 6
        FT_Vector*  vec           = outline->points;
        char*       tag           = outline->tags;
        AF_Point    first         = points;
        AF_Point    end           = points + outline->contours[0];
        AF_Point    prev          = end;
        FT_Int      contour_index = 0;
d457 2
a458 2
          point->fx = (FT_Short)vec->x;
          point->fy = (FT_Short)vec->y;
d471 2
a472 1
            point->flags = 0;
d474 9
d484 9
d494 6
a499 4
          prev->next  = point;
          prev        = point;

          if ( point == end )
d501 3
a503 1
            if ( ++contour_index < outline->n_contours )
d505 1
a506 1
              end   = points + outline->contours[contour_index];
a529 7
        AF_Point      first  = points;
        AF_Point      prev   = NULL;
        FT_Pos        in_x   = 0;
        FT_Pos        in_y   = 0;
        AF_Direction  in_dir = AF_DIR_NONE;


d532 3
a534 2
          AF_Point  next;
          FT_Pos    out_x, out_y;
d537 3
a539 8
          if ( point == first )
          {
            prev   = first->prev;
            in_x   = first->fx - prev->fx;
            in_y   = first->fy - prev->fy;
            in_dir = af_direction_compute( in_x, in_y );
            first  = prev + 1;
          }
d541 1
a541 1
          point->in_dir = (FT_Char)in_dir;
d543 3
a545 3
          next  = point->next;
          out_x = next->fx - point->fx;
          out_y = next->fy - point->fy;
d547 1
a547 2
          in_dir         = af_direction_compute( out_x, out_y );
          point->out_dir = (FT_Char)in_dir;
d556 3
d562 5
a566 1
            if ( ft_corner_is_flat( in_x, in_y, out_x, out_y ) )
a570 4

          in_x = out_x;
          in_y = out_y;
          prev = point;
d575 3
a577 4
    /* compute inflection points --                 */
    /* disabled due to no longer perceived benefits */
    if ( 0 && get_inflections )
      af_glyph_hints_compute_inflections( hints );
d585 2
a586 2
  af_glyph_hints_save( AF_GlyphHints  hints,
                       FT_Outline*    outline )
a592 1

d595 2
a596 2
      vec->x = point->x;
      vec->y = point->y;
d608 5
a612 5
  /****************************************************************
   *
   *                     EDGE POINT GRID-FITTING
   *
   ****************************************************************/
d619 10
a628 4
    AF_AxisHints  axis          = & hints->axis[dim];
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = segments + axis->num_segments;
    AF_Segment    seg;
d631 1
a631 3
    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( seg = segments; seg < segment_limit; seg++ )
d633 1
a633 2
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;
a635 6
        if ( edge == NULL )
          continue;

        first = seg->first;
        last  = seg->last;
        point = first;
d638 10
a647 2
          point->x      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_X;
d649 1
a649 1
          if ( point == last )
a652 1

a653 12
      }
    }
    else
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;


        if ( edge == NULL )
          continue;
d655 1
a655 7
        first = seg->first;
        last  = seg->last;
        point = first;
        for (;;)
        {
          point->y      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_Y;
d657 1
a657 6
          if ( point == last )
            break;

          point = point->next;
        }
      }
d662 5
a666 5
  /****************************************************************
   *
   *                    STRONG POINT INTERPOLATION
   *
   ****************************************************************/
a670 1

a692 1

d702 1
a702 1
        /* if this point is candidate to weak interpolation, we       */
a703 1

a747 19
#if 1
          /* for small edge counts, a linear search is better */
          if ( max <= 8 )
          {
            FT_UInt  nn;

            for ( nn = 0; nn < max; nn++ )
              if ( edges[nn].fpos >= u )
                break;

            if ( edges[nn].fpos == u )
            {
              u = edges[nn].pos;
              goto Store_Point;
            }
            min = nn;
          }
          else
#endif
d781 1
d783 1
d796 5
a800 6
  /****************************************************************
   *
   *                    WEAK POINT INTERPOLATION
   *
   ****************************************************************/

a809 2
    if ( delta == 0 )
      return;
d891 8
a898 8
    AF_Point   points        = hints->points;
    AF_Point   point_limit   = points + hints->num_points;
    AF_Point*  contour       = hints->contours;
    AF_Point*  contour_limit = contour + hints->num_contours;
    AF_Flags   touch_flag;
    AF_Point   point;
    AF_Point   end_point;
    AF_Point   first_point;
d924 1
a924 1
    point = points;
a927 3
      AF_Point  first_touched, last_touched;


d932 1
a932 9
      /* find first touched point */
      for (;;)
      {
        if ( point > end_point )  /* no touched point in contour */
          goto NextContour;

        if ( point->flags & touch_flag )
          break;

a933 1
      }
d935 1
a935 4
      first_touched = point;
      last_touched  = point;

      for (;;)
d937 2
a938 2
        FT_ASSERT( point <= end_point &&
                   ( point->flags & touch_flag ) != 0 );
a939 3
        /* skip any touched neighbhours */
        while ( point < end_point && ( point[1].flags & touch_flag ) != 0 )
          point++;
d941 2
a942 5
        last_touched = point;

        /* find the next touched point, if any */
        point ++;
        for (;;)
d944 8
a951 6
          if ( point > end_point )
            goto EndContour;

          if ( ( point->flags & touch_flag ) != 0 )
            break;

d955 19
a973 3
        /* interpolate between last_touched and point */
        af_iup_interp( last_touched + 1, point - 1,
                       last_touched, point );
a974 20

    EndContour:
      /* special case: only one point was touched */
      if ( last_touched == first_touched )
      {
        af_iup_shift( first_point, end_point, first_touched );
      }
      else /* interpolate the last part */
      {
        if ( last_touched < end_point )
          af_iup_interp( last_touched + 1, end_point,
                         last_touched, first_touched );

        if ( first_touched > points )
          af_iup_interp( first_point, first_touched - 1,
                         last_touched, first_touched );
      }

    NextContour:
      ;
a988 30


#ifdef AF_USE_WARPER

  FT_LOCAL_DEF( void )
  af_glyph_hints_scale_dim( AF_GlyphHints  hints,
                            AF_Dimension   dim,
                            FT_Fixed       scale,
                            FT_Pos         delta )
  {
    AF_Point  points       = hints->points;
    AF_Point  points_limit = points + hints->num_points;
    AF_Point  point;


    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( point = points; point < points_limit; point++ )
        point->x = FT_MulFix( point->fx, scale ) + delta;
    }
    else
    {
      for ( point = points; point < points_limit; point++ )
        point->y = FT_MulFix( point->fy, scale ) + delta;
    }
  }

#endif /* AF_USE_WARPER */

/* END */
@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@d1 2
d295 1
a295 1
      for ( dim = 0; dim < 2; dim++ )
d471 1
a471 1
            point->flags = 0;
@


1.1.115.2
log
@Import Freetype 2.2.1 with a bunch of security fixes
@
text
@a0 18
/***************************************************************************/
/*                                                                         */
/*  afhints.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (body).                                 */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


a1 97
#include "aferrors.h"


  FT_LOCAL_DEF( FT_Error )
  af_axis_hints_new_segment( AF_AxisHints  axis,
                             FT_Memory     memory,
                             AF_Segment   *asegment )
  {
    FT_Error    error   = AF_Err_Ok;
    AF_Segment  segment = NULL;


    if ( axis->num_segments >= axis->max_segments )
    {
      FT_Int  old_max = axis->max_segments;
      FT_Int  new_max = old_max;
      FT_Int  big_max = FT_INT_MAX / sizeof ( *segment );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( FT_RENEW_ARRAY( axis->segments, old_max, new_max ) )
        goto Exit;

      axis->max_segments = new_max;
    }

    segment = axis->segments + axis->num_segments++;
    FT_ZERO( segment );

  Exit:
    *asegment = segment;
    return error;
  }


  FT_LOCAL( FT_Error )
  af_axis_hints_new_edge( AF_AxisHints  axis,
                          FT_Int        fpos,
                          FT_Memory     memory,
                          AF_Edge      *aedge )
  {
    FT_Error  error = AF_Err_Ok;
    AF_Edge   edge  = NULL;
    AF_Edge   edges;


    if ( axis->num_edges >= axis->max_edges )
    {
      FT_Int  old_max = axis->max_edges;
      FT_Int  new_max = old_max;
      FT_Int  big_max = FT_INT_MAX / sizeof ( *edge );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( FT_RENEW_ARRAY( axis->edges, old_max, new_max ) )
        goto Exit;

      axis->max_edges = new_max;
    }

    edges = axis->edges;
    edge  = edges + axis->num_edges;

    while ( edge > edges && edge[-1].fpos > fpos )
    {
      edge[0] = edge[-1];
      edge--;
    }

    axis->num_edges++;

    FT_ZERO( edge );
    edge->fpos = (FT_Short)fpos;

  Exit:
    *aedge = edge;
    return error;
  }

d7 1
a7 2
  static const char*
  af_dir_str( AF_Direction  dir )
d11 1
a11 2

    switch ( dir )
d13 5
a17 14
    case AF_DIR_UP:
      result = "up";
      break;
    case AF_DIR_DOWN:
      result = "down";
      break;
    case AF_DIR_LEFT:
      result = "left";
      break;
    case AF_DIR_RIGHT:
      result = "right";
      break;
    default:
      result = "none";
a18 1

d22 1
a22 3

#define AF_INDEX_NUM( ptr, base )  ( (ptr) ? ( (ptr) - (base) ) : -1 )

a30 1

d32 1
a32 3
    printf(   "  [ index |  xorg |  yorg |  xscale |  yscale "
              "|  xfit  |  yfit  |  flags ]\n" );

d35 1
a35 2
      printf( "  [ %5d | %5d | %5d | %-5.2f | %-5.2f "
              "| %-5.2f | %-5.2f | %c%c%c%c%c%c ]\n",
d43 7
a49 6
              ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) ? 'w' : ' ',
              ( point->flags & AF_FLAG_INFLECTION )         ? 'i' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_X )          ? '<' : ' ',
              ( point->flags & AF_FLAG_EXTREMA_Y )          ? 'v' : ' ',
              ( point->flags & AF_FLAG_ROUND_X )            ? '(' : ' ',
              ( point->flags & AF_FLAG_ROUND_Y )            ? 'u' : ' ');
d55 1
a55 1
  /* A function to dump the array of linked segments. */
d59 2
a60 3
    AF_Point  points = hints->points;
    FT_Int    dimension;

d64 1
a64 1
      AF_AxisHints  axis     = &hints->axis[dimension];
d95 1
a95 2
    FT_Int  dimension;

d99 1
a99 1
      AF_AxisHints  axis  = &hints->axis[dimension];
d104 3
a106 5

      /*
       *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
       *        since they have constant a X coordinate.
       */
d114 1
a114 2
        printf ( "  [ %5d | %4d | %5s | %4d |"
                 " %5d |   %c  | %5.2f | %5.2f ]\n",
d124 1
d129 2
a133 1

a138 49
#if 1
    AF_Direction  dir = AF_DIR_NONE;


    /* atan(1/12) == 4.7 degrees */

    if ( dx < 0 )
    {
      if ( dy < 0 )
      {
        if ( -dx * 12 < -dy )
          dir = AF_DIR_DOWN;

        else if ( -dy * 12 < -dx )
          dir = AF_DIR_LEFT;
      }
      else /* dy >= 0 */
      {
        if ( -dx * 12 < dy )
          dir = AF_DIR_UP;

        else if ( dy * 12 < -dx )
          dir = AF_DIR_LEFT;
      }
    }
    else /* dx >= 0 */
    {
      if ( dy < 0 )
      {
        if ( dx * 12 < -dy )
          dir = AF_DIR_DOWN;

        else if ( -dy * 12 < dx )
          dir = AF_DIR_RIGHT;
      }
      else  /* dy >= 0 */
      {
        if ( dx * 12 < dy )
          dir = AF_DIR_UP;

        else if ( dy * 12 < dx )
          dir = AF_DIR_RIGHT;
      }
    }

    return dir;

#else /* 0 */

a159 3

#endif /* 0 */

d174 9
a182 9
      AF_Point  point = contour[0];
      AF_Point  first = point;
      AF_Point  start = point;
      AF_Point  end   = point;
      AF_Point  before;
      AF_Point  after;
      AF_Angle  angle_in, angle_seg, angle_out;
      AF_Angle  diff_in, diff_out;
      FT_Int    finished = 0;
d218 2
a219 3
      first = start;

      AF_ANGLE_DIFF( diff_in, angle_in, angle_seg );
d242 1
a242 1
        AF_ANGLE_DIFF( diff_out, angle_seg, angle_out );
d271 1
d281 1
d287 2
a288 3
      FT_Memory  memory = hints->memory;
      int        dim;

d290 4
a293 5
      /*
       *  note that we don't need to free the segment and edge
       *  buffers, since they are really within the hints->points array
       */
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
d295 1
a295 2
        AF_AxisHints  axis = &hints->axis[dim];

a297 3
        axis->max_segments = 0;
        FT_FREE( axis->segments );

d299 2
a300 2
        axis->max_edges    = 0;
        FT_FREE( axis->edges );
a315 7
  FT_LOCAL_DEF( void )
  af_glyph_hints_rescale( AF_GlyphHints     hints,
                          AF_ScriptMetrics  metrics )
  {
    hints->metrics      = metrics;
    hints->scaler_flags = metrics->scaler.flags;
  }
d317 14
d332 1
a332 12
  FT_LOCAL_DEF( FT_Error )
  af_glyph_hints_reload( AF_GlyphHints  hints,
                         FT_Outline*    outline )
  {
    FT_Error   error   = AF_Err_Ok;
    AF_Point   points;
    FT_UInt    old_max, new_max;
    FT_Fixed   x_scale = hints->x_scale;
    FT_Fixed   y_scale = hints->y_scale;
    FT_Pos     x_delta = hints->x_delta;
    FT_Pos     y_delta = hints->y_delta;
    FT_Memory  memory  = hints->memory;
d334 2
d337 2
a338 2
    hints->num_points   = 0;
    hints->num_contours = 0;
d345 3
a347 2
    /* first of all, reallocate the contours array when necessary */
    new_max = (FT_UInt)outline->n_contours;
d351 1
a351 1
      new_max = ( new_max + 3 ) & ~3;
d359 4
a362 5
    /*
     *  then reallocate the points arrays if necessary --
     *  note that we reserve two additional point positions, used to
     *  hint metrics appropriately
     */
d367 11
d380 21
a400 1
      if ( FT_RENEW_ARRAY( hints->points, old_max, new_max ) )
d402 1
d404 10
a413 1
      hints->max_points = new_max;
d419 7
a425 6
    /* We can't rely on the value of `FT_Outline.flags' to know the fill   */
    /* direction used for a glyph, given that some fonts are broken (e.g., */
    /* the Arphic ones).  We thus recompute it each time we need to.       */
    /*                                                                     */
    hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
    hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;
d429 2
a430 2
      hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
      hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
d447 1
a447 1
      /* compute coordinates & Bezier flags */
d455 2
a456 2
          point->fx = (FT_Short)vec->x;
          point->fy = (FT_Short)vec->y;
d470 1
d530 3
a532 3
          AF_Point  prev;
          AF_Point  next;
          FT_Pos    in_x, in_y, out_x, out_y;
d539 1
a539 1
          point->in_dir = (FT_Char)af_direction_compute( in_x, in_y );
d545 1
a545 1
          point->out_dir = (FT_Char)af_direction_compute( out_x, out_y );
d562 1
a562 2

            AF_ANGLE_DIFF( delta, angle_in, angle_out );
d573 2
a574 1
    /* compute inflection points */
d583 2
a584 2
  af_glyph_hints_save( AF_GlyphHints  hints,
                       FT_Outline*    outline )
a590 1

d593 2
a594 2
      vec->x = point->x;
      vec->y = point->y;
d606 5
a610 5
  /****************************************************************
   *
   *                     EDGE POINT GRID-FITTING
   *
   ****************************************************************/
d617 1
a617 1
    AF_AxisHints  axis       = & hints->axis[dim];
a621 1

d660 5
a664 5
  /****************************************************************
   *
   *                    STRONG POINT INTERPOLATION
   *
   ****************************************************************/
a668 1

a690 1

d700 1
a700 1
        /* if this point is candidate to weak interpolation, we       */
a701 1

d779 1
d781 1
d794 5
a798 6
  /****************************************************************
   *
   *                    WEAK POINT INTERPOLATION
   *
   ****************************************************************/

d889 8
a896 8
    AF_Point   points        = hints->points;
    AF_Point   point_limit   = points + hints->num_points;
    AF_Point*  contour       = hints->contours;
    AF_Point*  contour_limit = contour + hints->num_contours;
    AF_Flags   touch_flag;
    AF_Point   point;
    AF_Point   end_point;
    AF_Point   first_point;
d922 1
a922 1
    point = points;
a986 30


#ifdef AF_USE_WARPER

  FT_LOCAL_DEF( void )
  af_glyph_hints_scale_dim( AF_GlyphHints  hints,
                            AF_Dimension   dim,
                            FT_Fixed       scale,
                            FT_Pos         delta )
  {
    AF_Point  points       = hints->points;
    AF_Point  points_limit = points + hints->num_points;
    AF_Point  point;
    

    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( point = points; point < points_limit; point++ )
        point->x = FT_MulFix( point->fx, scale ) + delta;
    }
    else
    {
      for ( point = points; point < points_limit; point++ )
        point->y = FT_MulFix( point->fy, scale ) + delta;
    }
  }

#endif /* AF_USE_WARPER */

/* END */
@


1.1.115.3
log
@we need newer freetype for advance calculation
@
text
@d7 1
a7 1
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2009 by                        */
a20 1
#include FT_INTERNAL_CALC_H
d36 1
a36 1
      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *segment ) );
d56 1
a66 1
                          AF_Direction  dir,
d79 1
a79 1
      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *edge ) );
d101 1
a101 1
    while ( edge > edges )
a102 8
      if ( edge[-1].fpos < fpos )
        break;

      /* we want the edge with same position and minor direction */
      /* to appear before those in the major one in the list     */
      if ( edge[-1].fpos == fpos && dir == axis->major_dir )
        break;

a110 1
    edge->dir  = (FT_Char)dir;
d120 1
a120 1
#include FT_CONFIG_STANDARD_LIBRARY_H
a186 28
  static const char*
  af_edge_flags_to_string( AF_Edge_Flags  flags )
  {
    static char  temp[32];
    int          pos = 0;


    if ( flags & AF_EDGE_ROUND )
    {
      ft_memcpy( temp + pos, "round", 5 );
      pos += 5;
    }
    if ( flags & AF_EDGE_SERIF )
    {
      if ( pos > 0 )
        temp[pos++] = ' ';
      ft_memcpy( temp + pos, "serif", 5 );
      pos += 5;
    }
    if ( pos == 0 )
      return "normal";

    temp[pos] = 0;

    return temp;
  }


d191 2
a192 1
    FT_Int  dimension;
d205 2
a206 2
      printf ( "  [ index |  pos  |  dir  | link | serif |"
               " height  | extra | flags    ]\n" );
d210 1
a210 1
        printf ( "  [ %5d | %5.2g | %5s | %4d | %5d | %5d | %5d | %s ]\n",
d212 2
a213 3
                 dimension == AF_DIMENSION_HORZ ? (int)seg->first->ox / 64.0
                                                : (int)seg->first->oy / 64.0,
                 af_dir_str( (AF_Direction)seg->dir ),
d216 3
a218 3
                 seg->height,
                 seg->height - ( seg->max_coord - seg->min_coord ),
                 af_edge_flags_to_string( seg->flags ) );
d245 2
a246 2
      printf ( "  [ index |  pos  |  dir  | link |"
               " serif | blue | opos  |  pos  | flags   ]\n" );
d250 2
a251 2
        printf ( "  [ %5d | %5.2g | %5s | %4d |"
                 " %5d |   %c  | %5.2f | %5.2f | %s ]\n",
d253 2
a254 2
                 (int)edge->opos / 64.0,
                 af_dir_str( (AF_Direction)edge->dir ),
d259 1
a259 2
                 edge->pos / 64.0,
                 af_edge_flags_to_string( edge->flags ) );
d265 1
a265 11
#else /* !AF_DEBUG */

  /* these empty stubs are only used to link the `ftgrid' test program */
  /* when debugging is disabled                                        */

  void
  af_glyph_hints_dump_points( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }

a266 14
  void
  af_glyph_hints_dump_segments( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }


  void
  af_glyph_hints_dump_edges( AF_GlyphHints  hints )
  {
    FT_UNUSED( hints );
  }

#endif /* !AF_DEBUG */
d274 2
a275 2
    FT_Pos        ll, ss;  /* long and short arm lengths */
    AF_Direction  dir;     /* candidate direction        */
d278 3
a280 1
    if ( dy >= dx )
d282 1
a282 1
      if ( dy >= -dx )
d284 5
a288 3
        dir = AF_DIR_UP;
        ll  = dy;
        ss  = dx;
d290 1
a290 1
      else
d292 5
a296 3
        dir = AF_DIR_LEFT;
        ll  = -dx;
        ss  = dy;
d299 1
a299 1
    else /* dy < dx */
d301 1
a301 1
      if ( dy >= -dx )
d303 5
a307 3
        dir = AF_DIR_RIGHT;
        ll  = dx;
        ss  = dy;
d309 1
a309 1
      else
d311 5
a315 3
        dir = AF_DIR_DOWN;
        ll  = dy;
        ss  = dx;
d319 23
a341 3
    ss *= 14;
    if ( FT_ABS( ll ) <= FT_ABS( ss ) )
      dir = AF_DIR_NONE;
d344 3
a350 1

d367 2
a368 2
      FT_Pos    in_x, in_y, out_x, out_y;
      AF_Angle  orient_prev, orient_cur;
d382 1
a382 2
        in_x = end->fx - start->fx;
        in_y = end->fy - start->fy;
d384 2
a385 1
      } while ( in_x == 0 && in_y == 0 );
d398 1
a398 2
          out_x = start->fx - before->fx;
          out_y = start->fy - before->fy;
d400 2
a401 1
        } while ( out_x == 0 && out_y == 0 );
d403 1
a403 3
        orient_prev = ft_corner_orientation( in_x, in_y, out_x, out_y );

      } while ( orient_prev == 0 );
d407 1
a407 2
      in_x = out_x;
      in_y = out_y;
d409 1
a409 1
      /* now process all segments in the contour */
d423 1
a423 2
            out_x = after->fx - end->fx;
            out_y = after->fy - end->fy;
d425 2
a426 1
          } while ( out_x == 0 && out_y == 0 );
d428 1
a428 1
          orient_cur = ft_corner_orientation( in_x, in_y, out_x, out_y );
d430 1
a430 1
        } while ( orient_cur == 0 );
d432 1
a432 1
        if ( ( orient_prev + orient_cur ) == 0 )
d434 2
a435 1
          /* we have an inflection point here */
d446 4
a449 6
        start = end;
        end   = after;

        orient_prev = orient_cur;
        in_x        = out_x;
        in_y        = out_y;
d519 1
a519 2
                         FT_Outline*    outline,
                         FT_Bool        get_inflections )
a589 3
    hints->xmin_delta = 0;
    hints->xmax_delta = 0;

d599 1
a599 1
      /* compute coordinates & Bezier flags, next and prev */
d601 2
a602 6
        FT_Vector*  vec           = outline->points;
        char*       tag           = outline->tags;
        AF_Point    first         = points;
        AF_Point    end           = points + outline->contours[0];
        AF_Point    prev          = end;
        FT_Int      contour_index = 0;
a604 1
        FT_UNUSED( first );
d623 16
d640 2
d643 6
a648 4
          prev->next  = point;
          prev        = point;

          if ( point == end )
d650 3
a652 1
            if ( ++contour_index < outline->n_contours )
d654 1
a655 1
              end   = points + outline->contours[contour_index];
a678 7
        AF_Point      first  = points;
        AF_Point      prev   = NULL;
        FT_Pos        in_x   = 0;
        FT_Pos        in_y   = 0;
        AF_Direction  in_dir = AF_DIR_NONE;


d681 1
d683 1
a683 1
          FT_Pos    out_x, out_y;
d686 3
a688 8
          if ( point == first )
          {
            prev   = first->prev;
            in_x   = first->fx - prev->fx;
            in_y   = first->fy - prev->fy;
            in_dir = af_direction_compute( in_x, in_y );
            first  = prev + 1;
          }
d690 1
a690 1
          point->in_dir = (FT_Char)in_dir;
d692 3
a694 3
          next  = point->next;
          out_x = next->fx - point->fx;
          out_y = next->fy - point->fy;
d696 1
a696 2
          in_dir         = af_direction_compute( out_x, out_y );
          point->out_dir = (FT_Char)in_dir;
d705 3
d711 6
a716 1
            if ( ft_corner_is_flat( in_x, in_y, out_x, out_y ) )
a720 4

          in_x = out_x;
          in_y = out_y;
          prev = point;
d725 2
a726 4
    /* compute inflection points --                 */
    /* disabled due to no longer perceived benefits */
    if ( 0 && get_inflections )
      af_glyph_hints_compute_inflections( hints );
d769 4
a772 4
    AF_AxisHints  axis          = & hints->axis[dim];
    AF_Segment    segments      = axis->segments;
    AF_Segment    segment_limit = segments + axis->num_segments;
    AF_Segment    seg;
d775 1
a775 1
    if ( dim == AF_DIMENSION_HORZ )
d777 6
a782 1
      for ( seg = segments; seg < segment_limit; seg++ )
d784 1
a784 2
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;
a786 6
        if ( edge == NULL )
          continue;

        first = seg->first;
        last  = seg->last;
        point = first;
d789 10
a798 2
          point->x      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_X;
d800 1
a800 1
          if ( point == last )
a803 1

a804 9
      }
    }
    else
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge   edge = seg->edge;
        AF_Point  point, first, last;

d806 1
a806 2
        if ( edge == NULL )
          continue;
d808 1
a808 14
        first = seg->first;
        last  = seg->last;
        point = first;
        for (;;)
        {
          point->y      = edge->pos;
          point->flags |= AF_FLAG_TOUCH_Y;

          if ( point == last )
            break;

          point = point->next;
        }
      }
d894 2
a895 2
          FT_PtrDist  min, max, mid;
          FT_Pos      fpos;
a901 19
#if 1
          /* for small edge counts, a linear search is better */
          if ( max <= 8 )
          {
            FT_PtrDist  nn;

            for ( nn = 0; nn < max; nn++ )
              if ( edges[nn].fpos >= u )
                break;

            if ( edges[nn].fpos == u )
            {
              u = edges[nn].pos;
              goto Store_Point;
            }
            min = nn;
          }
          else
#endif
a962 2
    if ( delta == 0 )
      return;
a1080 3
      AF_Point  first_touched, last_touched;


d1085 1
a1085 9
      /* find first touched point */
      for (;;)
      {
        if ( point > end_point )  /* no touched point in contour */
          goto NextContour;

        if ( point->flags & touch_flag )
          break;

a1086 4
      }

      first_touched = point;
      last_touched  = point;
d1088 1
a1088 1
      for (;;)
d1090 2
a1091 2
        FT_ASSERT( point <= end_point &&
                   ( point->flags & touch_flag ) != 0 );
a1092 3
        /* skip any touched neighbhours */
        while ( point < end_point && ( point[1].flags & touch_flag ) != 0 )
          point++;
d1094 2
a1095 5
        last_touched = point;

        /* find the next touched point, if any */
        point ++;
        for (;;)
d1097 8
a1104 6
          if ( point > end_point )
            goto EndContour;

          if ( ( point->flags & touch_flag ) != 0 )
            break;

d1108 19
a1126 3
        /* interpolate between last_touched and point */
        af_iup_interp( last_touched + 1, point - 1,
                       last_touched, point );
a1127 20

    EndContour:
      /* special case: only one point was touched */
      if ( last_touched == first_touched )
      {
        af_iup_shift( first_point, end_point, first_touched );
      }
      else /* interpolate the last part */
      {
        if ( last_touched < end_point )
          af_iup_interp( last_touched + 1, end_point,
                         last_touched, first_touched );

        if ( first_touched > points )
          af_iup_interp( first_point, first_touched - 1,
                         last_touched, first_touched );
      }

    NextContour:
      ;
d1155 1
a1155 1

@


1.1.115.4
log
@let’s see whether we can’t update freetype2 as well…
@
text
@d7 1
a7 1
/*  Copyright 2003-2016 by                                                 */
a21 1
#include FT_INTERNAL_DEBUG_H
a23 12
  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_afhints


  /* Get new segment for given axis. */

d29 1
a29 1
    FT_Error    error   = FT_Err_Ok;
d33 1
a33 9
    if ( axis->num_segments < AF_SEGMENTS_EMBEDDED )
    {
      if ( !axis->segments )
      {
        axis->segments     = axis->embedded.segments;
        axis->max_segments = AF_SEGMENTS_EMBEDDED;
      }
    }
    else if ( axis->num_segments >= axis->max_segments )
d42 1
a42 1
        error = FT_THROW( Out_Of_Memory );
d50 2
a51 12
      if ( axis->segments == axis->embedded.segments )
      {
        if ( FT_NEW_ARRAY( axis->segments, new_max ) )
          goto Exit;
        ft_memcpy( axis->segments, axis->embedded.segments,
                   sizeof ( axis->embedded.segments ) );
      }
      else
      {
        if ( FT_RENEW_ARRAY( axis->segments, old_max, new_max ) )
          goto Exit;
      }
a63 3
  /* Get new edge for given axis, direction, and position, */
  /* without initializing the edge itself.                 */

a67 1
                          FT_Bool       top_to_bottom_hinting,
d69 1
a69 1
                          AF_Edge      *anedge )
d71 1
a71 1
    FT_Error  error = FT_Err_Ok;
d76 1
a76 9
    if ( axis->num_edges < AF_EDGES_EMBEDDED )
    {
      if ( !axis->edges )
      {
        axis->edges     = axis->embedded.edges;
        axis->max_edges = AF_EDGES_EMBEDDED;
      }
    }
    else if ( axis->num_edges >= axis->max_edges )
d85 1
a85 1
        error = FT_THROW( Out_Of_Memory );
d93 2
a94 12
      if ( axis->edges == axis->embedded.edges )
      {
        if ( FT_NEW_ARRAY( axis->edges, new_max ) )
          goto Exit;
        ft_memcpy( axis->edges, axis->embedded.edges,
                   sizeof ( axis->embedded.edges ) );
      }
      else
      {
        if ( FT_RENEW_ARRAY( axis->edges, old_max, new_max ) )
          goto Exit;
      }
d104 1
a104 2
      if ( top_to_bottom_hinting ? ( edge[-1].fpos > fpos )
                                 : ( edge[-1].fpos < fpos ) )
d118 4
d123 1
a123 1
    *anedge = edge;
d128 1
a128 1
#ifdef FT_DEBUG_AUTOFIT
a131 11
  /* The dump functions are used in the `ftgrid' demo program, too. */
#define AF_DUMP( varformat )          \
          do                          \
          {                           \
            if ( to_stdout )          \
              printf varformat;       \
            else                      \
              FT_TRACE7( varformat ); \
          } while ( 0 )


d160 1
a160 30
#define AF_INDEX_NUM( ptr, base )  (int)( (ptr) ? ( (ptr) - (base) ) : -1 )


  static char*
  af_print_idx( char* p,
                int   idx )
  {
    if ( idx == -1 )
    {
      p[0] = '-';
      p[1] = '-';
      p[2] = '\0';
    }
    else
      ft_sprintf( p, "%d", idx );

    return p;
  }


  static int
  af_get_segment_index( AF_GlyphHints  hints,
                        int            point_idx,
                        int            dimension )
  {
    AF_AxisHints  axis     = &hints->axis[dimension];
    AF_Point      point    = hints->points + point_idx;
    AF_Segment    segments = axis->segments;
    AF_Segment    limit    = segments + axis->num_segments;
    AF_Segment    segment;
a162 50
    for ( segment = segments; segment < limit; segment++ )
    {
      if ( segment->first <= segment->last )
      {
        if ( point >= segment->first && point <= segment->last )
          break;
      }
      else
      {
        AF_Point  p = segment->first;


        for (;;)
        {
          if ( point == p )
            goto Exit;

          if ( p == segment->last )
            break;

          p = p->next;
        }
      }
    }

  Exit:
    if ( segment == limit )
      return -1;

    return (int)( segment - segments );
  }


  static int
  af_get_edge_index( AF_GlyphHints  hints,
                     int            segment_idx,
                     int            dimension )
  {
    AF_AxisHints  axis    = &hints->axis[dimension];
    AF_Edge       edges   = axis->edges;
    AF_Segment    segment = axis->segments + segment_idx;


    return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment->edge, edges );
  }


#ifdef __cplusplus
  extern "C" {
#endif
d164 1
a164 2
  af_glyph_hints_dump_points( AF_GlyphHints  hints,
                              FT_Bool        to_stdout )
d166 3
a168 5
    AF_Point   points  = hints->points;
    AF_Point   limit   = points + hints->num_points;
    AF_Point*  contour = hints->contours;
    AF_Point*  climit  = contour + hints->num_contours;
    AF_Point   point;
d171 3
a173 7
    AF_DUMP(( "Table of points:\n" ));

    if ( hints->num_points )
      AF_DUMP(( "  index  hedge  hseg  vedge  vseg  flags "
                "  xorg  yorg  xscale  yscale   xfit    yfit" ));
    else
      AF_DUMP(( "  (none)\n" ));
d177 15
a191 35
      int  point_idx     = AF_INDEX_NUM( point, points );
      int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
      int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );

      char  buf1[16], buf2[16], buf3[16], buf4[16];


      /* insert extra newline at the beginning of a contour */
      if ( contour < climit && *contour == point )
      {
        AF_DUMP(( "\n" ));
        contour++;
      }

      AF_DUMP(( "  %5d  %5s %5s  %5s %5s  %s"
                " %5d %5d %7.2f %7.2f %7.2f %7.2f\n",
                point_idx,
                af_print_idx( buf1,
                              af_get_edge_index( hints, segment_idx_1, 1 ) ),
                af_print_idx( buf2, segment_idx_1 ),
                af_print_idx( buf3,
                              af_get_edge_index( hints, segment_idx_0, 0 ) ),
                af_print_idx( buf4, segment_idx_0 ),
                ( point->flags & AF_FLAG_NEAR )
                  ? " near "
                  : ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
                    ? " weak "
                    : "strong",

                point->fx,
                point->fy,
                point->ox / 64.0,
                point->oy / 64.0,
                point->x / 64.0,
                point->y / 64.0 ));
d193 1
a193 3
    AF_DUMP(( "\n" ));
  }
#ifdef __cplusplus
a194 1
#endif
d198 1
a198 1
  af_edge_flags_to_string( FT_UInt  flags )
d219 1
a219 1
    temp[pos] = '\0';
d225 1
a225 5
  /* Dump the array of linked segments. */

#ifdef __cplusplus
  extern "C" {
#endif
d227 1
a227 2
  af_glyph_hints_dump_segments( AF_GlyphHints  hints,
                                FT_Bool        to_stdout )
a234 2
      AF_Point      points   = hints->points;
      AF_Edge       edges    = axis->edges;
a238 1
      char  buf1[16], buf2[16], buf3[16];
d240 4
a243 10

      AF_DUMP(( "Table of %s segments:\n",
                dimension == AF_DIMENSION_HORZ ? "vertical"
                                               : "horizontal" ));
      if ( axis->num_segments )
        AF_DUMP(( "  index   pos   delta   dir   from   to "
                  "  link  serif  edge"
                  "  height  extra     flags\n" ));
      else
        AF_DUMP(( "  (none)\n" ));
d246 13
a258 18
        AF_DUMP(( "  %5d  %5d  %5d  %5s  %4d  %4d"
                  "  %4s  %5s  %4s"
                  "  %6d  %5d  %11s\n",
                  AF_INDEX_NUM( seg, segments ),
                  seg->pos,
                  seg->delta,
                  af_dir_str( (AF_Direction)seg->dir ),
                  AF_INDEX_NUM( seg->first, points ),
                  AF_INDEX_NUM( seg->last, points ),

                  af_print_idx( buf1, AF_INDEX_NUM( seg->link, segments ) ),
                  af_print_idx( buf2, AF_INDEX_NUM( seg->serif, segments ) ),
                  af_print_idx( buf3, AF_INDEX_NUM( seg->edge, edges ) ),

                  seg->height,
                  seg->height - ( seg->max_coord - seg->min_coord ),
                  af_edge_flags_to_string( seg->flags ) ));
      AF_DUMP(( "\n" ));
a260 47
#ifdef __cplusplus
  }
#endif


  /* Fetch number of segments. */

#ifdef __cplusplus
  extern "C" {
#endif
  FT_Error
  af_glyph_hints_get_num_segments( AF_GlyphHints  hints,
                                   FT_Int         dimension,
                                   FT_Int*        num_segments )
  {
    AF_Dimension  dim;
    AF_AxisHints  axis;


    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;

    axis          = &hints->axis[dim];
    *num_segments = axis->num_segments;

    return FT_Err_Ok;
  }
#ifdef __cplusplus
  }
#endif


  /* Fetch offset of segments into user supplied offset array. */

#ifdef __cplusplus
  extern "C" {
#endif
  FT_Error
  af_glyph_hints_get_segment_offset( AF_GlyphHints  hints,
                                     FT_Int         dimension,
                                     FT_Int         idx,
                                     FT_Pos        *offset,
                                     FT_Bool       *is_blue,
                                     FT_Pos        *blue_offset )
  {
    AF_Dimension  dim;
    AF_AxisHints  axis;
    AF_Segment    seg;
a262 35
    if ( !offset )
      return FT_THROW( Invalid_Argument );

    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;

    axis = &hints->axis[dim];

    if ( idx < 0 || idx >= axis->num_segments )
      return FT_THROW( Invalid_Argument );

    seg      = &axis->segments[idx];
    *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg->first->ox
                                            : seg->first->oy;
    if ( seg->edge )
      *is_blue = (FT_Bool)( seg->edge->blue_edge != 0 );
    else
      *is_blue = FALSE;

    if ( *is_blue )
      *blue_offset = seg->edge->blue_edge->cur;
    else
      *blue_offset = 0;

    return FT_Err_Ok;
  }
#ifdef __cplusplus
  }
#endif


  /* Dump the array of linked edges. */

#ifdef __cplusplus
  extern "C" {
#endif
d264 1
a264 2
  af_glyph_hints_dump_edges( AF_GlyphHints  hints,
                             FT_Bool        to_stdout )
a275 2
      char  buf1[16], buf2[16];

d279 1
a279 1
       *        since they have a constant X coordinate.
d281 4
a284 16
      if ( dimension == AF_DIMENSION_HORZ )
        AF_DUMP(( "Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n",
                  "vertical",
                  65536.0 * 64.0 / hints->x_scale,
                  10.0 * hints->x_scale / 65536.0 / 64.0 ));
      else
        AF_DUMP(( "Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n",
                  "horizontal",
                  65536.0 * 64.0 / hints->y_scale,
                  10.0 * hints->y_scale / 65536.0 / 64.0 ));

      if ( axis->num_edges )
        AF_DUMP(( "  index    pos     dir   link  serif"
                  "  blue    opos     pos       flags\n" ));
      else
        AF_DUMP(( "  (none)\n" ));
d287 14
a300 13
        AF_DUMP(( "  %5d  %7.2f  %5s  %4s  %5s"
                  "    %c   %7.2f  %7.2f  %11s\n",
                  AF_INDEX_NUM( edge, edges ),
                  (int)edge->opos / 64.0,
                  af_dir_str( (AF_Direction)edge->dir ),
                  af_print_idx( buf1, AF_INDEX_NUM( edge->link, edges ) ),
                  af_print_idx( buf2, AF_INDEX_NUM( edge->serif, edges ) ),

                  edge->blue_edge ? 'y' : 'n',
                  edge->opos / 64.0,
                  edge->pos / 64.0,
                  af_edge_flags_to_string( edge->flags ) ));
      AF_DUMP(( "\n" ));
d303 17
a319 1
#ifdef __cplusplus
a320 1
#endif
a321 1
#undef AF_DUMP
d323 5
a327 1
#endif /* !FT_DEBUG_AUTOFIT */
d329 1
a330 1
  /* Compute the direction value of a given vector. */
d332 1
d367 1
a367 1
        ll  = -dy;
d372 2
a373 4
    /* return no direction if arm lengths do not differ enough       */
    /* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
    /* the long arm is never negative                                */
    if ( ll <= 14 * FT_ABS( ss ) )
d380 114
d498 1
a498 2
    /* no need to initialize the embedded items */
    FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints->embedded ) );
d506 4
a509 2
    FT_Memory  memory;
    int        dim;
d512 7
a518 12
    if ( !( hints && hints->memory ) )
      return;

    memory = hints->memory;

    /*
     *  note that we don't need to free the segment and edge
     *  buffers since they are really within the hints->points array
     */
    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
      AF_AxisHints  axis = &hints->axis[dim];
d521 2
a522 3
      axis->num_segments = 0;
      axis->max_segments = 0;
      if ( axis->segments != axis->embedded.segments )
d525 2
a526 3
      axis->num_edges = 0;
      axis->max_edges = 0;
      if ( axis->edges != axis->embedded.edges )
d528 1
a528 1
    }
a529 1
    if ( hints->contours != hints->embedded.contours )
d531 2
a532 2
    hints->max_contours = 0;
    hints->num_contours = 0;
a533 1
    if ( hints->points != hints->embedded.points )
d535 2
a536 2
    hints->max_points = 0;
    hints->num_points = 0;
d538 2
a539 1
    hints->memory = NULL;
a542 2
  /* Reset metrics. */

d544 2
a545 2
  af_glyph_hints_rescale( AF_GlyphHints    hints,
                          AF_StyleMetrics  metrics )
a551 3
  /* Recompute all AF_Point in AF_GlyphHints from the definitions */
  /* in a source outline.                                         */

d554 2
a555 1
                         FT_Outline*    outline )
d557 1
a557 1
    FT_Error   error   = FT_Err_Ok;
d575 1
a575 1
    /* first of all, reallocate the contours array if necessary */
d577 2
a578 11
    old_max = (FT_UInt)hints->max_contours;

    if ( new_max <= AF_CONTOURS_EMBEDDED )
    {
      if ( !hints->contours )
      {
        hints->contours     = hints->embedded.contours;
        hints->max_contours = AF_CONTOURS_EMBEDDED;
      }
    }
    else if ( new_max > old_max )
d580 1
a580 4
      if ( hints->contours == hints->embedded.contours )
        hints->contours = NULL;

      new_max = ( new_max + 3 ) & ~3U; /* round up to a multiple of 4 */
d585 1
a585 1
      hints->max_contours = (FT_Int)new_max;
d594 2
a595 11
    old_max = (FT_UInt)hints->max_points;

    if ( new_max <= AF_POINTS_EMBEDDED )
    {
      if ( !hints->points )
      {
        hints->points     = hints->embedded.points;
        hints->max_points = AF_POINTS_EMBEDDED;
      }
    }
    else if ( new_max > old_max )
d597 1
a597 4
      if ( hints->points == hints->embedded.points )
        hints->points = NULL;

      new_max = ( new_max + 2 + 7 ) & ~7U; /* round up to a multiple of 8 */
d602 1
a602 1
      hints->max_points = (FT_Int)new_max;
a636 4
      /* value 20 in `near_limit' is heuristic */
      FT_UInt  units_per_em = hints->metrics->scaler.face->units_per_EM;
      FT_Int   near_limit   = 20 * units_per_em / 2048;

d642 2
a643 2
        FT_Short    endpoint      = outline->contours[0];
        AF_Point    end           = points + endpoint;
d648 1
a650 6
          FT_Pos  out_x, out_y;


          point->in_dir  = (FT_Char)AF_DIR_NONE;
          point->out_dir = (FT_Char)AF_DIR_NONE;

a655 3
          end->fx = (FT_Short)outline->points[endpoint].x;
          end->fy = (FT_Short)outline->points[endpoint].y;

d665 1
a665 1
            point->flags = AF_FLAG_NONE;
a667 6
          out_x = point->fx - prev->fx;
          out_y = point->fy - prev->fy;

          if ( FT_ABS( out_x ) + FT_ABS( out_y ) < near_limit )
            prev->flags |= AF_FLAG_NEAR;

d676 3
a678 3
              endpoint = outline->contours[contour_index];
              end      = points + endpoint;
              prev     = end;
d684 1
a684 1
      /* set up the contours array */
d699 1
d701 5
a705 11
        /*
         *  Compute directions of `in' and `out' vectors.
         *
         *  Note that distances between points that are very near to each
         *  other are accumulated.  In other words, the auto-hinter either
         *  prepends the small vectors between near points to the first
         *  non-near vector, or the sum of small vector lengths exceeds a
         *  threshold, thus `grouping' the small vectors.  All intermediate
         *  points are tagged as weak; the directions are adjusted also to
         *  be equal to the accumulated one.
         */
a706 1
        FT_Int  near_limit2 = 2 * near_limit - 1;
d708 1
a708 5
        AF_Point*  contour;
        AF_Point*  contour_limit = hints->contours + hints->num_contours;


        for ( contour = hints->contours; contour < contour_limit; contour++ )
d710 2
a711 4
          AF_Point  first = *contour;
          AF_Point  next, prev, curr;

          FT_Pos  out_x, out_y;
d714 1
a714 8
          /* since the first point of a contour could be part of a */
          /* series of near points, go backwards to find the first */
          /* non-near point and adjust `first'                     */

          point = first;
          prev  = first->prev;

          while ( prev != first )
d716 5
a720 16
            out_x = point->fx - prev->fx;
            out_y = point->fy - prev->fy;

            /*
             *  We use Taxicab metrics to measure the vector length.
             *
             *  Note that the accumulated distances so far could have the
             *  opposite direction of the distance measured here.  For this
             *  reason we use `near_limit2' for the comparison to get a
             *  non-near point even in the worst case.
             */
            if ( FT_ABS( out_x ) + FT_ABS( out_y ) >= near_limit2 )
              break;

            point = prev;
            prev  = prev->prev;
d723 1
a723 5
          /* adjust first point */
          first = point;

          /* now loop over all points of the contour to get */
          /* `in' and `out' vector directions               */
d725 3
a727 1
          curr = first;
d729 2
a730 10
          /*
           *  We abuse the `u' and `v' fields to store index deltas to the
           *  next and previous non-near point, respectively.
           *
           *  To avoid problems with not having non-near points, we point to
           *  `first' by default as the next non-near point.
           *
           */
          curr->u  = (FT_Pos)( first - curr );
          first->v = -curr->u;
d732 1
a732 5
          out_x = 0;
          out_y = 0;

          next = first;
          do
a733 98
            AF_Direction  out_dir;


            point = next;
            next  = point->next;

            out_x += next->fx - point->fx;
            out_y += next->fy - point->fy;

            if ( FT_ABS( out_x ) + FT_ABS( out_y ) < near_limit )
            {
              next->flags |= AF_FLAG_WEAK_INTERPOLATION;
              continue;
            }

            curr->u = (FT_Pos)( next - curr );
            next->v = -curr->u;

            out_dir = af_direction_compute( out_x, out_y );

            /* adjust directions for all points inbetween; */
            /* the loop also updates position of `curr'    */
            curr->out_dir = (FT_Char)out_dir;
            for ( curr = curr->next; curr != next; curr = curr->next )
            {
              curr->in_dir  = (FT_Char)out_dir;
              curr->out_dir = (FT_Char)out_dir;
            }
            next->in_dir = (FT_Char)out_dir;

            curr->u  = (FT_Pos)( first - curr );
            first->v = -curr->u;

            out_x = 0;
            out_y = 0;

          } while ( next != first );
        }

        /*
         *  The next step is to `simplify' an outline's topology so that we
         *  can identify local extrema more reliably: A series of
         *  non-horizontal or non-vertical vectors pointing into the same
         *  quadrant are handled as a single, long vector.  From a
         *  topological point of the view, the intermediate points are of no
         *  interest and thus tagged as weak.
         */

        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
            continue;

          if ( point->in_dir  == AF_DIR_NONE &&
               point->out_dir == AF_DIR_NONE )
          {
            /* check whether both vectors point into the same quadrant */

            FT_Pos  in_x, in_y;
            FT_Pos  out_x, out_y;

            AF_Point  next_u = point + point->u;
            AF_Point  prev_v = point + point->v;


            in_x = point->fx - prev_v->fx;
            in_y = point->fy - prev_v->fy;

            out_x = next_u->fx - point->fx;
            out_y = next_u->fy - point->fy;

            if ( ( in_x ^ out_x ) >= 0 && ( in_y ^ out_y ) >= 0 )
            {
              /* yes, so tag current point as weak */
              /* and update index deltas           */

              point->flags |= AF_FLAG_WEAK_INTERPOLATION;

              prev_v->u = (FT_Pos)( next_u - prev_v );
              next_u->v = -prev_v->u;
            }
          }
        }

        /*
         *  Finally, check for remaining weak points.  Everything else not
         *  collected in edges so far is then implicitly classified as strong
         *  points.
         */

        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
            continue;

          if ( point->flags & AF_FLAG_CONTROL )
          {
            /* control points are always weak */
a739 3
            {
              /* current point lies on a horizontal or          */
              /* vertical segment (but doesn't start or end it) */
a740 1
            }
d742 2
a743 20
            {
              AF_Point  next_u = point + point->u;
              AF_Point  prev_v = point + point->v;


              if ( ft_corner_is_flat( point->fx  - prev_v->fx,
                                      point->fy  - prev_v->fy,
                                      next_u->fx - point->fx,
                                      next_u->fy - point->fy ) )
              {
                /* either the `in' or the `out' vector is much more  */
                /* dominant than the other one, so tag current point */
                /* as weak and update index deltas                   */

                prev_v->u = (FT_Pos)( next_u - prev_v );
                next_u->v = -prev_v->u;

                goto Is_Weak_Point;
              }
            }
a745 2
          {
            /* current point forms a spike */
d747 4
a750 1
          }
d755 5
a764 2
  /* Store the hinted outline in an FT_Outline structure. */

a796 3
  /* Align all points of an edge to the same coordinate value, */
  /* either horizontally or vertically.                        */

d815 1
a815 1
        if ( !edge )
d830 1
d842 1
a842 1
        if ( !edge )
d870 2
a871 2
  /* Hint the strong points -- this is equivalent to the TrueType `IP' */
  /* hinting instruction.                                              */
d882 1
a882 1
    FT_UInt       touch_flag;
d908 2
a909 1
        if ( ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) )
d953 1
a953 1
          /* for a small number of edges, a linear search is better */
a957 1

a988 1
          /* point is not on an edge */
a1023 4
  /* Shift the original coordinates of all points between `p1' and */
  /* `p2' to get hinted coordinates, using the same difference as  */
  /* given by `ref'.                                               */

a1031 1

a1042 7
  /* Interpolate the original coordinates of all points between `p1' and  */
  /* `p2' to get hinted coordinates, using `ref1' and `ref2' as the       */
  /* reference points.  The `u' and `v' members are the current and       */
  /* original coordinate values, respectively.                            */
  /*                                                                      */
  /* Details can be found in the TrueType bytecode specification.         */

d1050 5
a1054 1
    FT_Pos    u, v1, v2, u1, u2, d1, d2;
d1060 1
a1060 1
    if ( ref1->v > ref2->v )
d1062 12
a1073 3
      p    = ref1;
      ref1 = ref2;
      ref2 = p;
d1076 1
a1076 8
    v1 = ref1->v;
    v2 = ref2->v;
    u1 = ref1->u;
    u2 = ref2->u;
    d1 = u1 - v1;
    d2 = u2 - v2;

    if ( u1 == u2 || v1 == v2 )
d1087 1
a1087 1
          u = u1;
a1093 3
      FT_Fixed  scale = FT_DivFix( u2 - u1, v2 - v1 );


d1098 3
a1100 1
        if ( u <= v1 )
a1101 2
        else if ( u >= v2 )
          u += d2;
d1103 1
a1103 1
          u = u1 + FT_MulFix( u - v1, scale );
a1110 3
  /* Hint the weak points -- this is equivalent to the TrueType `IUP' */
  /* hinting instruction.                                             */

d1119 1
a1119 1
    FT_UInt    touch_flag;
d1148 2
d1172 1
d1176 1
a1176 1
        FT_ASSERT( point <= end_point                 &&
d1179 2
a1180 3
        /* skip any touched neighbours */
        while ( point < end_point                    &&
                ( point[1].flags & touch_flag ) != 0 )
d1186 1
a1186 1
        point++;
d1206 1
d1208 1
a1208 1

d1238 1
a1238 3
#ifdef AF_CONFIG_OPTION_USE_WARPER

  /* Apply (small) warp scale and warp delta for given dimension. */
d1263 1
a1263 1
#endif /* AF_CONFIG_OPTION_USE_WARPER */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
