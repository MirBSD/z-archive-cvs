head	1.2;
access;
symbols
	freetype-2_1_8:1.1.115.1
	freetype:1.1.115
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.2
date	2006.06.29.20.24.54;	author tg;	state dead;
branches;
next	1.1;
commitid	10044A435A50E5F7C11;

1.1
date	2005.03.18.10.43.12;	author tg;	state Exp;
branches
	1.1.103.1
	1.1.115.1;
next	;

1.1.103.1
date	2005.03.18.10.43.12;	author tg;	state Exp;
branches;
next	;

1.1.115.1
date	2006.06.29.18.35.25;	author tg;	state Exp;
branches;
next	;
commitid	10044A41D276963C97B;


desc
@@


1.2
log
@merge freetype 2.2.1, reduce diff against ft (rid some xf86 changes)
@
text
@#include "otlgdef.h"
#include "otlcommn.h"

 /************************************************************************/
 /************************************************************************/
 /*****                                                              *****/
 /*****                      ATTACHMENTS LIST                        *****/
 /*****                                                              *****/
 /************************************************************************/
 /************************************************************************/

  static void
  otl_attach_point_validate( OTL_Bytes      table,
                             OTL_Validator  valid )
  {
    OTL_Bytes  p = table;
    OTL_UInt   count;

    if ( p + 2 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    count = OTL_NEXT_USHORT( p );
    if ( table + count*2 > valid->limit )
      OTL_INVALID_TOO_SHORT;
  }


  static void
  otl_attach_list_validate( OTL_Bytes      table,
                            OTL_Validator  valid )
  {
    OTL_Bytes  p = table;
    OTL_Bytes  coverage;
    OTL_UInt   count;

    if ( p + 4 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    coverage = table + OTL_NEXT_USHORT( p );
    count    = OTL_NEXT_USHORT( p );

    otl_coverage_validate( coverage, valid );
    if ( count != otl_coverage_get_count( coverage ) )
      OTL_INVALID_DATA;

    if ( p + count*2 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    for ( ; count > 0; count-- )
      otl_attach_point_validate( table + OTL_NEXT_USHORT( p ) );
  }


 /************************************************************************/
 /************************************************************************/
 /*****                                                              *****/
 /*****                      LIGATURE CARETS                         *****/
 /*****                                                              *****/
 /************************************************************************/
 /************************************************************************/

  static void
  otl_caret_value_validate( OTL_Bytes      table,
                            OTL_Validator  valid )
  {
    OTL_Bytes  p = table;

    if ( p + 4 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    format = OTL_NEXT_USHORT( p );
    switch ( format )
    {
      case 1:
      case 2:
        break;

      case 3:
        {
          OTL_Bytes  device;

          p += 2;
          if ( p + 2 > valid->limit )
            OTL_INVALID_TOO_SHORT;

          otl_device_table_validate( table + OTL_PEEK_USHORT( p ) );
        }
        break;

      default:
        OTL_INVALID_DATA;
    }
  }


  static void
  otl_ligature_glyph_validate( OTL_Bytes      table,
                               OTL_Validator  valid )
  {
    OTL_Bytes  p = table;
    OTL_UInt   count;

    if ( p + 2 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    count = OTL_NEXT_USHORT( p );

    if ( p + count*2 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    for ( ; count > 0; count-- )
      otl_caret_value_validate( table + OTL_NEXT_USHORT( p ) );
  }


  static void
  otl_ligature_caret_list_validate( OTL_Bytes      table,
                                    OTL_Validator  valid )
  {
    OTL_Bytes  p = table;
    OTL_Bytes  coverage;
    OTL_UInt   count;

    if ( p + 4 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    coverage = table + OTL_NEXT_USHORT( p );
    count    = OTL_NEXT_USHORT( p );

    otl_coverage_validate( coverage, valid );
    if ( count != otl_coverage_get_count( coverage ) )
      OTL_INVALID_DATA;

    if ( p + count*2 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    for ( ; count > 0; count-- )
      otl_ligature_glyph_validate( table + OTL_NEXT_USHORT( p ) );
  }


 /************************************************************************/
 /************************************************************************/
 /*****                                                              *****/
 /*****                         GDEF TABLE                           *****/
 /*****                                                              *****/
 /************************************************************************/
 /************************************************************************/

  OTL_APIDEF( void )
  otl_gdef_validate( OTL_Bytes      table,
                     OTL_Validator  valid )
  {
    OTL_Bytes  p = table;

    if ( p + 12 > valid->limit )
      OTL_INVALID_TOO_SHORT;

    /* check format */
    if ( OTL_NEXT_ULONG( p ) != 0x00010000UL )
      OTL_INVALID_FORMAT;

    /* validate class definition table */
    otl_class_definition_validate( table + OTL_NEXT_USHORT( p ) );

    /* validate attachment point list */
    otl_attach_list_validate( table + OTL_NEXT_USHORT( p ) );

    /* validate ligature caret list */
    otl_ligature_caret_list_validate( table + OTL_NEXT_USHORT( p ) );

    /* validate mark attach class */
    otl_class_definition_validate( table + OTL_NEXT_USHORT( p ) );
  }

@


1.1
log
@Initial revision
@
text
@@


1.1.115.1
log
@re-base freetype 2.1.8
@
text
@@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
