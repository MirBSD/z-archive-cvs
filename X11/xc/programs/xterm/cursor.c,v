head	1.3;
access;
symbols
	MIRBSD_10_BASE:1.3
	tg-xterm-215-based:1.2.0.2
	tg-xterm-200-based:1.1
	xterm-215:1.1.109.1
	lynx:1.1.109
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.3
date	2006.07.02.00.54.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044A719405F9E103E;

1.2
date	2006.07.02.00.02.45;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A70D294F0BB63C;

1.1
date	2005.03.18.10.52.30;	author tg;	state Exp;
branches
	1.1.103.1
	1.1.109.1;
next	;

1.1.103.1
date	2005.03.18.10.52.30;	author tg;	state Exp;
branches;
next	;

1.1.109.1
date	2006.07.01.23.27.03;	author tg;	state Exp;
branches;
next	;
commitid	10044A704BD2A6243A3;


desc
@@


1.3
log
@revert to xterm-200-based (plus fix an openbsd glitch)
xterm-215-based does not work correctly:
* uxterm does not honour its class (e.g. my font is too small)
* utmp is never updated
@
text
@/* $XTermId: cursor.c,v 1.31 2004/11/26 18:09:23 tom Exp $ */

/*
 *	$Xorg: cursor.c,v 1.3 2000/08/17 19:55:08 cpqbld Exp $
 */

/* $XFree86: xc/programs/xterm/cursor.c,v 3.16 2004/12/01 01:27:46 dickey Exp $ */

/*
 * Copyright 2002,2004 by Thomas E. Dickey
 * 
 *                         All Rights Reserved
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 * 
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* cursor.c */

#include <xterm.h>
#include <data.h>

/*
 * Moves the cursor to the specified position, checking for bounds.
 * (this includes scrolling regions)
 * The origin is considered to be 0, 0 for this procedure.
 */
void
CursorSet(TScreen * screen, int row, int col, unsigned flags)
{
    int use_row = row;
    int max_row;

    col = (col < 0 ? 0 : col);
    screen->cur_col = (col <= screen->max_col ? col : screen->max_col);
    max_row = screen->max_row;
    if (flags & ORIGIN) {
	use_row += screen->top_marg;
	max_row = screen->bot_marg;
    }
    use_row = (use_row < 0 ? 0 : use_row);
    screen->cur_row = (use_row <= max_row ? use_row : max_row);
    screen->do_wrap = 0;

    TRACE(("CursorSet(%d,%d) margins [%d..%d] -> %d,%d %s\n",
	   row, col,
	   screen->top_marg,
	   screen->bot_marg,
	   screen->cur_row,
	   screen->cur_col,
	   (flags & ORIGIN ? "origin" : "normal")));
}

/*
 * moves the cursor left n, no wrap around
 */
void
CursorBack(TScreen * screen, int n)
{
    int i, j, k, rev;

    if ((rev = (term->flags & (REVERSEWRAP | WRAPAROUND)) ==
	 (REVERSEWRAP | WRAPAROUND)) != 0
	&& screen->do_wrap)
	n--;
    if ((screen->cur_col -= n) < 0) {
	if (rev) {
	    if ((i = ((j = screen->max_col + 1)
		      * screen->cur_row) + screen->cur_col) < 0) {
		k = j * (screen->max_row + 1);
		i += ((-i) / k + 1) * k;
	    }
	    screen->cur_row = i / j;
	    screen->cur_col = i % j;
	} else
	    screen->cur_col = 0;
    }
    screen->do_wrap = 0;
}

/*
 * moves the cursor forward n, no wraparound
 */
void
CursorForward(TScreen * screen, int n)
{
    screen->cur_col += n;
    if (screen->cur_col > CurMaxCol(screen, screen->cur_row))
	screen->cur_col = CurMaxCol(screen, screen->cur_row);
    screen->do_wrap = 0;
}

/*
 * moves the cursor down n, no scrolling.
 * Won't pass bottom margin or bottom of screen.
 */
void
CursorDown(TScreen * screen, int n)
{
    int max;

    max = (screen->cur_row > screen->bot_marg ?
	   screen->max_row : screen->bot_marg);

    screen->cur_row += n;
    if (screen->cur_row > max)
	screen->cur_row = max;
    screen->do_wrap = 0;
}

/*
 * moves the cursor up n, no linestarving.
 * Won't pass top margin or top of screen.
 */
void
CursorUp(TScreen * screen, int n)
{
    int min;

    min = ((screen->cur_row < screen->top_marg)
	   ? 0
	   : screen->top_marg);

    screen->cur_row -= n;
    if (screen->cur_row < min)
	screen->cur_row = min;
    screen->do_wrap = 0;
}

/*
 * Moves cursor down amount lines, scrolls if necessary.
 * Won't leave scrolling region. No carriage return.
 */
void
xtermIndex(TScreen * screen, int amount)
{
    int j;

    /*
     * indexing when below scrolling region is cursor down.
     * if cursor high enough, no scrolling necessary.
     */
    if (screen->cur_row > screen->bot_marg
	|| screen->cur_row + amount <= screen->bot_marg) {
	CursorDown(screen, amount);
	return;
    }

    CursorDown(screen, j = screen->bot_marg - screen->cur_row);
    xtermScroll(screen, amount - j);
}

/*
 * Moves cursor up amount lines, reverse scrolls if necessary.
 * Won't leave scrolling region. No carriage return.
 */
void
RevIndex(TScreen * screen, int amount)
{
    /*
     * reverse indexing when above scrolling region is cursor up.
     * if cursor low enough, no reverse indexing needed
     */
    if (screen->cur_row < screen->top_marg
	|| screen->cur_row - amount >= screen->top_marg) {
	CursorUp(screen, amount);
	return;
    }

    RevScroll(screen, amount - (screen->cur_row - screen->top_marg));
    CursorUp(screen, screen->cur_row - screen->top_marg);
}

/*
 * Moves Cursor To First Column In Line
 * (Note: xterm doesn't implement SLH, SLL which would affect use of this)
 */
void
CarriageReturn(TScreen * screen)
{
    screen->cur_col = 0;
    screen->do_wrap = 0;
}

/*
 * Save Cursor and Attributes
 */
void
CursorSave(XtermWidget tw)
{
    TScreen *screen = &tw->screen;
    SavedCursor *sc = &screen->sc[screen->alternate != False];

    sc->saved = True;
    sc->row = screen->cur_row;
    sc->col = screen->cur_col;
    sc->flags = tw->flags;
    sc->curgl = screen->curgl;
    sc->curgr = screen->curgr;
#if OPT_ISO_COLORS
    sc->cur_foreground = tw->cur_foreground;
    sc->cur_background = tw->cur_background;
    sc->sgr_foreground = tw->sgr_foreground;
#endif
    memmove(sc->gsets, screen->gsets, sizeof(screen->gsets));
}

/*
 * We save/restore all visible attributes, plus wrapping, origin mode, and the
 * selective erase attribute.
 */
#define DECSC_FLAGS (ATTRIBUTES|ORIGIN|WRAPAROUND|PROTECTED)

/*
 * Restore Cursor and Attributes
 */
void
CursorRestore(XtermWidget tw)
{
    TScreen *screen = &tw->screen;
    SavedCursor *sc = &screen->sc[screen->alternate != False];

    /* Restore the character sets, unless we never did a save-cursor op.
     * In that case, we'll reset the character sets.
     */
    if (sc->saved) {
	memmove(screen->gsets, sc->gsets, sizeof(screen->gsets));
	screen->curgl = sc->curgl;
	screen->curgr = sc->curgr;
    } else {
	resetCharsets(screen);
    }

    tw->flags &= ~DECSC_FLAGS;
    tw->flags |= sc->flags & DECSC_FLAGS;
    CursorSet(screen,
	      ((tw->flags & ORIGIN)
	       ? sc->row - screen->top_marg
	       : sc->row),
	      sc->col, tw->flags);

#if OPT_ISO_COLORS
    tw->sgr_foreground = sc->sgr_foreground;
    SGR_Foreground(tw->flags & FG_COLOR ? sc->cur_foreground : -1);
    SGR_Background(tw->flags & BG_COLOR ? sc->cur_background : -1);
#endif
}

/*
 * Move the cursor to the first column of the n-th next line.
 */
void
CursorNextLine(TScreen * screen, int count)
{
    CursorDown(screen, count < 1 ? 1 : count);
    CarriageReturn(screen);
    do_xevents();
}

/*
 * Move the cursor to the first column of the n-th previous line.
 */
void
CursorPrevLine(TScreen * screen, int count)
{
    CursorUp(screen, count < 1 ? 1 : count);
    CarriageReturn(screen);
    do_xevents();
}
@


1.2
log
@merge and go back to xterm-215
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.39 2006/02/13 01:14:58 tom Exp $ */
d3 5
a7 1
/* $XFree86: xc/programs/xterm/cursor.c,v 3.20 2006/02/13 01:14:58 dickey Exp $ */
d10 1
a10 1
 * Copyright 2002-2005,2006 by Thomas E. Dickey
a63 3
#include <menu.h>

#include <assert.h>
d77 1
a77 1
    set_cur_col(screen, (col <= screen->max_col ? col : screen->max_col));
d84 1
a84 1
    set_cur_row(screen, (use_row <= max_row ? use_row : max_row));
d110 1
a110 1
	    if ((i = ((j = MaxCols(screen))
d112 1
a112 1
		k = j * MaxRows(screen);
d115 2
a116 2
	    set_cur_row(screen, i / j);
	    set_cur_col(screen, i % j);
d118 1
a118 1
	    set_cur_col(screen, 0);
d129 3
a131 7
    int next = screen->cur_col + n;
    int max = CurMaxCol(screen, screen->cur_row);

    if (next > max)
	next = max;

    set_cur_col(screen, next);
a142 1
    int next = screen->cur_row + n;
a145 4
    if (next > max)
	next = max;
    if (next > screen->max_row)
	next = screen->max_row;
d147 3
a149 1
    set_cur_row(screen, next);
a160 1
    int next = screen->cur_row - n;
a164 4
    if (next < min)
	next = min;
    if (next < 0)
	next = 0;
d166 3
a168 1
    set_cur_row(screen, next);
d223 1
a223 1
    set_cur_col(screen, 0);
a288 1
    update_autowrap();
a311 22

#if OPT_TRACE
int
set_cur_row(TScreen * screen, int value)
{
    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_row);
    screen->cur_row = value;
    return value;
}

int
set_cur_col(TScreen * screen, int value)
{
    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_col);
    screen->cur_col = value;
    return value;
}
#endif /* OPT_TRACE */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.31 2004/11/26 18:09:23 tom Exp $ */
d3 1
a3 5
/*
 *	$Xorg: cursor.c,v 1.3 2000/08/17 19:55:08 cpqbld Exp $
 */

/* $XFree86: xc/programs/xterm/cursor.c,v 3.16 2004/12/01 01:27:46 dickey Exp $ */
d6 1
a6 1
 * Copyright 2002,2004 by Thomas E. Dickey
d60 3
d76 1
a76 1
    screen->cur_col = (col <= screen->max_col ? col : screen->max_col);
d83 1
a83 1
    screen->cur_row = (use_row <= max_row ? use_row : max_row);
d109 1
a109 1
	    if ((i = ((j = screen->max_col + 1)
d111 1
a111 1
		k = j * (screen->max_row + 1);
d114 2
a115 2
	    screen->cur_row = i / j;
	    screen->cur_col = i % j;
d117 1
a117 1
	    screen->cur_col = 0;
d128 7
a134 3
    screen->cur_col += n;
    if (screen->cur_col > CurMaxCol(screen, screen->cur_row))
	screen->cur_col = CurMaxCol(screen, screen->cur_row);
d146 1
d150 4
d155 1
a155 3
    screen->cur_row += n;
    if (screen->cur_row > max)
	screen->cur_row = max;
d167 1
d172 4
d177 1
a177 3
    screen->cur_row -= n;
    if (screen->cur_row < min)
	screen->cur_row = min;
d232 1
a232 1
    screen->cur_col = 0;
d298 1
d322 22
@


1.1.109.1
log
@Import xterm-215 (latest from Tom Dickey)
XFree86 4.6.0 had xterm-213 with no diffs,
so we only need to care about both obsd and
mbsd local diffs
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.39 2006/02/13 01:14:58 tom Exp $ */
d3 5
a7 1
/* $XFree86: xc/programs/xterm/cursor.c,v 3.20 2006/02/13 01:14:58 dickey Exp $ */
d10 1
a10 1
 * Copyright 2002-2005,2006 by Thomas E. Dickey
a63 3
#include <menu.h>

#include <assert.h>
d77 1
a77 1
    set_cur_col(screen, (col <= screen->max_col ? col : screen->max_col));
d84 1
a84 1
    set_cur_row(screen, (use_row <= max_row ? use_row : max_row));
d110 1
a110 1
	    if ((i = ((j = MaxCols(screen))
d112 1
a112 1
		k = j * MaxRows(screen);
d115 2
a116 2
	    set_cur_row(screen, i / j);
	    set_cur_col(screen, i % j);
d118 1
a118 1
	    set_cur_col(screen, 0);
d129 3
a131 7
    int next = screen->cur_col + n;
    int max = CurMaxCol(screen, screen->cur_row);

    if (next > max)
	next = max;

    set_cur_col(screen, next);
a142 1
    int next = screen->cur_row + n;
a145 4
    if (next > max)
	next = max;
    if (next > screen->max_row)
	next = screen->max_row;
d147 3
a149 1
    set_cur_row(screen, next);
a160 1
    int next = screen->cur_row - n;
a164 4
    if (next < min)
	next = min;
    if (next < 0)
	next = 0;
d166 3
a168 1
    set_cur_row(screen, next);
d223 1
a223 1
    set_cur_col(screen, 0);
a288 1
    update_autowrap();
a311 22

#if OPT_TRACE
int
set_cur_row(TScreen * screen, int value)
{
    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_row);
    screen->cur_row = value;
    return value;
}

int
set_cur_col(TScreen * screen, int value)
{
    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_col);
    screen->cur_col = value;
    return value;
}
#endif /* OPT_TRACE */
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
