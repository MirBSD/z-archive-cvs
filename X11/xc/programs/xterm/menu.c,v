head	1.3;
access;
symbols
	MIRBSD_10_BASE:1.3
	tg-xterm-215-based:1.2.0.2
	tg-xterm-200-based:1.1
	xterm-215:1.1.109.1
	lynx:1.1.109
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.3
date	2006.07.02.00.54.50;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044A719405F9E103E;

1.2
date	2006.07.02.00.02.47;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A70D294F0BB63C;

1.1
date	2005.03.18.10.52.31;	author tg;	state Exp;
branches
	1.1.103.1
	1.1.109.1;
next	;

1.1.103.1
date	2005.03.18.10.52.31;	author tg;	state Exp;
branches;
next	;

1.1.109.1
date	2006.07.01.23.27.04;	author tg;	state Exp;
branches;
next	;
commitid	10044A704BD2A6243A3;


desc
@@


1.3
log
@revert to xterm-200-based (plus fix an openbsd glitch)
xterm-215-based does not work correctly:
* uxterm does not honour its class (e.g. my font is too small)
* utmp is never updated
@
text
@/* $XTermId: menu.c,v 1.153 2005/01/10 22:53:49 tom Exp $ */

/* $Xorg: menu.c,v 1.4 2001/02/09 02:06:03 xorgcvs Exp $ */
/*

Copyright 1999-2004,2005 by Thomas E. Dickey

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Copyright 1989  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/
/* $XFree86: xc/programs/xterm/menu.c,v 3.58 2005/01/14 01:50:03 dickey Exp $ */

#include <xterm.h>
#include <data.h>
#include <menu.h>
#include <fontutils.h>

#include <X11/Xmu/CharSet.h>

#define app_con Xaw_app_con	/* quiet a warning from SimpleMenu.h */

#if defined(HAVE_LIB_XAW)

#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/Form.h>
#endif

#elif defined(HAVE_LIB_XAW3D)

#include <X11/Xaw3d/SimpleMenu.h>
#include <X11/Xaw3d/Box.h>
#include <X11/Xaw3d/SmeBSB.h>
#include <X11/Xaw3d/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw3d/MenuButton.h>
#include <X11/Xaw3d/Form.h>
#endif

#elif defined(HAVE_LIB_NEXTAW)

#include <X11/neXtaw/SimpleMenu.h>
#include <X11/neXtaw/Box.h>
#include <X11/neXtaw/SmeBSB.h>
#include <X11/neXtaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/neXtaw/MenuButton.h>
#include <X11/neXtaw/Form.h>
#endif

#elif defined(HAVE_LIB_XAWPLUS)

#include <X11/XawPlus/SimpleMenu.h>
#include <X11/XawPlus/Box.h>
#include <X11/XawPlus/SmeBSB.h>
#include <X11/XawPlus/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/XawPlus/MenuButton.h>
#include <X11/XawPlus/Form.h>
#endif

#endif

#undef app_con

#include <stdio.h>
#include <signal.h>
/* *INDENT-OFF* */
static void do_8bit_control    PROTO_XT_CALLBACK_ARGS;
static void do_allow132        PROTO_XT_CALLBACK_ARGS;
static void do_allowsends      PROTO_XT_CALLBACK_ARGS;
static void do_altscreen       PROTO_XT_CALLBACK_ARGS;
static void do_appcursor       PROTO_XT_CALLBACK_ARGS;
static void do_appkeypad       PROTO_XT_CALLBACK_ARGS;
static void do_autolinefeed    PROTO_XT_CALLBACK_ARGS;
static void do_autowrap        PROTO_XT_CALLBACK_ARGS;
static void do_backarrow       PROTO_XT_CALLBACK_ARGS;
static void do_clearsavedlines PROTO_XT_CALLBACK_ARGS;
static void do_continue        PROTO_XT_CALLBACK_ARGS;
static void do_cursesemul      PROTO_XT_CALLBACK_ARGS;
static void do_delete_del      PROTO_XT_CALLBACK_ARGS;
static void do_hardreset       PROTO_XT_CALLBACK_ARGS;
static void do_interrupt       PROTO_XT_CALLBACK_ARGS;
static void do_jumpscroll      PROTO_XT_CALLBACK_ARGS;
static void do_kill            PROTO_XT_CALLBACK_ARGS;
static void do_marginbell      PROTO_XT_CALLBACK_ARGS;
static void do_old_fkeys       PROTO_XT_CALLBACK_ARGS;
static void do_print           PROTO_XT_CALLBACK_ARGS;
static void do_print_redir     PROTO_XT_CALLBACK_ARGS;
static void do_quit            PROTO_XT_CALLBACK_ARGS;
static void do_redraw          PROTO_XT_CALLBACK_ARGS;
static void do_reversevideo    PROTO_XT_CALLBACK_ARGS;
static void do_reversewrap     PROTO_XT_CALLBACK_ARGS;
static void do_scrollbar       PROTO_XT_CALLBACK_ARGS;
static void do_scrollkey       PROTO_XT_CALLBACK_ARGS;
static void do_scrollttyoutput PROTO_XT_CALLBACK_ARGS;
static void do_securekbd       PROTO_XT_CALLBACK_ARGS;
static void do_softreset       PROTO_XT_CALLBACK_ARGS;
static void do_sun_fkeys       PROTO_XT_CALLBACK_ARGS;
static void do_suspend         PROTO_XT_CALLBACK_ARGS;
static void do_terminate       PROTO_XT_CALLBACK_ARGS;
static void do_titeInhibit     PROTO_XT_CALLBACK_ARGS;
static void do_visualbell      PROTO_XT_CALLBACK_ARGS;
static void do_poponbell       PROTO_XT_CALLBACK_ARGS;
static void do_vtfont          PROTO_XT_CALLBACK_ARGS;

#ifdef ALLOWLOGGING
static void do_logging         PROTO_XT_CALLBACK_ARGS;
#endif

#ifndef NO_ACTIVE_ICON
static void do_activeicon      PROTO_XT_CALLBACK_ARGS;
#endif /* NO_ACTIVE_ICON */

#if OPT_BLINK_CURS
static void do_cursorblink     PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_BOX_CHARS
static void do_font_boxchars   PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_CHRSET
static void do_font_doublesize PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_SOFTFONT
static void do_font_loadable   PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_HP_FUNC_KEYS
static void do_hp_fkeys        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_NUM_LOCK
static void do_num_lock        PROTO_XT_CALLBACK_ARGS;
static void do_meta_esc        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_RENDERFONT
static void do_font_renderfont PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SCO_FUNC_KEYS
static void do_sco_fkeys       PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SUNPC_KBD
static void do_sun_kbd         PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_TEK4014
static void do_tekcopy         PROTO_XT_CALLBACK_ARGS;
static void do_tekhide         PROTO_XT_CALLBACK_ARGS;
static void do_tekmode         PROTO_XT_CALLBACK_ARGS;
static void do_tekonoff        PROTO_XT_CALLBACK_ARGS;
static void do_tekpage         PROTO_XT_CALLBACK_ARGS;
static void do_tekreset        PROTO_XT_CALLBACK_ARGS;
static void do_tekshow         PROTO_XT_CALLBACK_ARGS;
static void do_tektext2        PROTO_XT_CALLBACK_ARGS;
static void do_tektext3        PROTO_XT_CALLBACK_ARGS;
static void do_tektextlarge    PROTO_XT_CALLBACK_ARGS;
static void do_tektextsmall    PROTO_XT_CALLBACK_ARGS;
static void do_vthide          PROTO_XT_CALLBACK_ARGS;
static void do_vtmode          PROTO_XT_CALLBACK_ARGS;
static void do_vtonoff         PROTO_XT_CALLBACK_ARGS;
static void do_vtshow          PROTO_XT_CALLBACK_ARGS;
static void handle_tekshow     (Widget gw, Bool allowswitch);
static void handle_vtshow      (Widget gw, Bool allowswitch);
#endif

#if OPT_TOOLBAR
static void do_toolbar         PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_WIDE_CHARS
static void do_font_utf8_mode  PROTO_XT_CALLBACK_ARGS;
#endif

/*
 * The order of entries MUST match the values given in menu.h
 */
MenuEntry mainMenuEntries[] = {
#if OPT_TOOLBAR
    { "toolbar",	do_toolbar,	NULL },
#endif
    { "securekbd",	do_securekbd,	NULL },
    { "allowsends",	do_allowsends,	NULL },
    { "redraw",		do_redraw,	NULL },
    { "line1",		NULL,		NULL },
#ifdef ALLOWLOGGING
    { "logging",	do_logging,	NULL },
#endif
    { "print",		do_print,	NULL },
    { "print-redirect",	do_print_redir,	NULL },
    { "line2",		NULL,		NULL },
    { "8-bit control",	do_8bit_control,NULL },
    { "backarrow key",	do_backarrow,	NULL },
#if OPT_NUM_LOCK
    { "num-lock",	do_num_lock,	NULL },
    { "meta-esc",	do_meta_esc,	NULL },
#endif
    { "delete-is-del",	do_delete_del,	NULL },
    { "oldFunctionKeys",do_old_fkeys,	NULL },
#if OPT_HP_FUNC_KEYS
    { "hpFunctionKeys",	do_hp_fkeys,	NULL },
#endif
#if OPT_SCO_FUNC_KEYS
    { "scoFunctionKeys",do_sco_fkeys,	NULL },
#endif
    { "sunFunctionKeys",do_sun_fkeys,	NULL },
#if OPT_SUNPC_KBD
    { "sunKeyboard",	do_sun_kbd,	NULL },
#endif
    { "line3",		NULL,		NULL },
    { "suspend",	do_suspend,	NULL },
    { "continue",	do_continue,	NULL },
    { "interrupt",	do_interrupt,	NULL },
    { "hangup",		do_hangup,	NULL },
    { "terminate",	do_terminate,	NULL },
    { "kill",		do_kill,	NULL },
    { "line4",		NULL,		NULL },
    { "quit",		do_quit,	NULL }};

MenuEntry vtMenuEntries[] = {
    { "scrollbar",	do_scrollbar,	NULL },
    { "jumpscroll",	do_jumpscroll,	NULL },
    { "reversevideo",	do_reversevideo, NULL },
    { "autowrap",	do_autowrap,	NULL },
    { "reversewrap",	do_reversewrap, NULL },
    { "autolinefeed",	do_autolinefeed, NULL },
    { "appcursor",	do_appcursor,	NULL },
    { "appkeypad",	do_appkeypad,	NULL },
    { "scrollkey",	do_scrollkey,	NULL },
    { "scrollttyoutput",do_scrollttyoutput, NULL },
    { "allow132",	do_allow132,	NULL },
    { "cursesemul",	do_cursesemul,	NULL },
    { "visualbell",	do_visualbell,	NULL },
    { "poponbell",	do_poponbell,	NULL },
    { "marginbell",	do_marginbell,	NULL },
#if OPT_BLINK_CURS
    { "cursorblink",	do_cursorblink,	NULL },
#endif
    { "titeInhibit",	do_titeInhibit,	NULL },
#ifndef NO_ACTIVE_ICON
    { "activeicon",	do_activeicon,	NULL },
#endif /* NO_ACTIVE_ICON */
    { "line1",		NULL,		NULL },
    { "softreset",	do_softreset,	NULL },
    { "hardreset",	do_hardreset,	NULL },
    { "clearsavedlines",do_clearsavedlines, NULL },
    { "line2",		NULL,		NULL },
#if OPT_TEK4014
    { "tekshow",	do_tekshow,	NULL },
    { "tekmode",	do_tekmode,	NULL },
    { "vthide",		do_vthide,	NULL },
#endif
    { "altscreen",	do_altscreen,	NULL },
    };

MenuEntry fontMenuEntries[] = {
    { "fontdefault",	do_vtfont,	NULL },
    { "font1",		do_vtfont,	NULL },
    { "font2",		do_vtfont,	NULL },
    { "font3",		do_vtfont,	NULL },
    { "font4",		do_vtfont,	NULL },
    { "font5",		do_vtfont,	NULL },
    { "font6",		do_vtfont,	NULL },
    /* this is after the last builtin font; the other entries are special */
    { "fontescape",	do_vtfont,	NULL },
    { "fontsel",	do_vtfont,	NULL },
    /* down to here should match NMENUFONTS in ptyx.h */

#if OPT_DEC_CHRSET || OPT_BOX_CHARS || OPT_DEC_SOFTFONT
    { "line1",		NULL,		NULL },
#if OPT_BOX_CHARS
    { "font-linedrawing",do_font_boxchars,NULL },
#endif
#if OPT_DEC_CHRSET
    { "font-doublesize",do_font_doublesize,NULL },
#endif
#if OPT_DEC_SOFTFONT
    { "font-loadable",	do_font_loadable,NULL },
#endif
#endif /* toggles for DEC font extensions */

#if OPT_RENDERFONT || OPT_WIDE_CHARS
    { "line2",		NULL,		NULL },
#if OPT_RENDERFONT
    { "render-font",	do_font_renderfont,NULL },
#endif
#if OPT_WIDE_CHARS
    { "utf8-mode",	do_font_utf8_mode,NULL },
#endif
#endif /* toggles for other font extensions */

    };

#if OPT_TEK4014
MenuEntry tekMenuEntries[] = {
    { "tektextlarge",	do_tektextlarge, NULL },
    { "tektext2",	do_tektext2,	NULL },
    { "tektext3",	do_tektext3,	NULL },
    { "tektextsmall",	do_tektextsmall, NULL },
    { "line1",		NULL,		NULL },
    { "tekpage",	do_tekpage,	NULL },
    { "tekreset",	do_tekreset,	NULL },
    { "tekcopy",	do_tekcopy,	NULL },
    { "line2",		NULL,		NULL },
    { "vtshow",		do_vtshow,	NULL },
    { "vtmode",		do_vtmode,	NULL },
    { "tekhide",	do_tekhide,	NULL }};
#endif

typedef struct {
    char *internal_name;
    MenuEntry *entry_list;
    Cardinal entry_len;
} MenuHeader;

    /* This table is ordered to correspond with MenuIndex */
static MenuHeader menu_names[] = {
    { "mainMenu", mainMenuEntries, XtNumber(mainMenuEntries) },
    { "vtMenu",   vtMenuEntries,   XtNumber(vtMenuEntries)   },
    { "fontMenu", fontMenuEntries, XtNumber(fontMenuEntries) },
#if OPT_TEK4014
    { "tekMenu",  tekMenuEntries,  XtNumber(tekMenuEntries)  },
#endif
    { 0,          0,               0 },
};
/* *INDENT-ON* */

/*
 * FIXME:  These are global data rather than in the xterm widget because they
 * are initialized before the widget is created.
 */
typedef struct {
    Widget w;
    Cardinal entries;
} MenuList;

static MenuList vt_shell[NUM_POPUP_MENUS];

#if OPT_TEK4014 && OPT_TOOLBAR
static MenuList tek_shell[NUM_POPUP_MENUS];
#endif

/*
 * Returns a pointer to the MenuList entry that matches the popup menu.
 */
static MenuList *
select_menu(Widget w GCC_UNUSED, MenuIndex num)
{
#if OPT_TEK4014 && OPT_TOOLBAR
    while (w != 0) {
	if (w == tekshellwidget) {
	    return &tek_shell[num];
	}
	w = XtParent(w);
    }
#endif
    return &vt_shell[num];
}

/*
 * Returns a pointer to the given popup menu shell
 */
static Widget
obtain_menu(Widget w, MenuIndex num)
{
    return select_menu(w, num)->w;
}

/*
 * Returns the number of entries in the given popup menu shell
 */
static Cardinal
sizeof_menu(Widget w, MenuIndex num)
{
    return select_menu(w, num)->entries;
}

/*
 * create_menu - create a popup shell and stuff the menu into it.
 */

static Widget
create_menu(Widget w, XtermWidget xtw, MenuIndex num)
{
    static XtCallbackRec cb[2] =
    {
	{NULL, NULL},
	{NULL, NULL}};
    static Arg arg =
    {XtNcallback, (XtArgVal) cb};

    Widget m;
    TScreen *screen = &xtw->screen;
    MenuHeader *data = &menu_names[num];
    MenuList *list = select_menu(w, num);
    struct _MenuEntry *entries = data->entry_list;
    int nentries = data->entry_len;

    if (screen->menu_item_bitmap == None) {
	/*
	 * we really want to do these dynamically
	 */
#define check_width 9
#define check_height 8
	static unsigned char check_bits[] =
	{
	    0x00, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00,
	    0x31, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x04, 0x00
	};

	screen->menu_item_bitmap =
	    XCreateBitmapFromData(XtDisplay(xtw),
				  RootWindowOfScreen(XtScreen(xtw)),
				  (char *) check_bits, check_width, check_height);
    }
#if OPT_TOOLBAR
    m = list->w;
    if (m == 0) {
	return m;
    }
#else
    m = XtCreatePopupShell(data->internal_name,
			   simpleMenuWidgetClass,
			   toplevel,
			   NULL, 0);
    list->w = m;
#endif
    list->entries = nentries;

    for (; nentries > 0; nentries--, entries++) {
	cb[0].callback = (XtCallbackProc) entries->function;
	cb[0].closure = (caddr_t) entries->name;
	entries->widget = XtCreateManagedWidget(entries->name,
						(entries->function ?
						 smeBSBObjectClass :
						 smeLineObjectClass), m,
						&arg, (Cardinal) 1);
    }

    /* do not realize at this point */
    return m;
}

static MenuIndex
indexOfMenu(String menuName)
{
    MenuIndex me;
    switch (*menuName) {
    case 'm':
	me = mainMenu;
	break;
    case 'v':
	me = vtMenu;
	break;
    case 'f':
	me = fontMenu;
	break;
#if OPT_TEK4014
    case 't':
	me = tekMenu;
	break;
#endif
    default:
	me = noMenu;
    }
    return (me);
}

/*
 * public interfaces
 */

/* ARGSUSED */
static Bool
domenu(Widget w GCC_UNUSED,
       XEvent * event GCC_UNUSED,
       String * params,		/* mainMenu, vtMenu, or tekMenu */
       Cardinal *param_count)	/* 0 or 1 */
{
    TScreen *screen = &term->screen;
    MenuIndex me;
    Bool created = False;
    Widget mw;

    if (*param_count != 1) {
	Bell(XkbBI_MinorError, 0);
	return False;
    }

    if ((me = indexOfMenu(params[0])) == noMenu) {
	Bell(XkbBI_MinorError, 0);
	return False;
    }

    if ((mw = obtain_menu(w, me)) == 0
	|| sizeof_menu(w, me) == 0) {
	mw = create_menu(w, term, me);
	created = (mw != 0);
    }
    if (mw == 0)
	return False;

    switch (me) {
    case mainMenu:
	if (created) {
	    update_toolbar();
	    update_securekbd();
	    update_allowsends();
	    update_logging();
	    update_print_redir();
	    update_8bit_control();
	    update_decbkm();
	    update_num_lock();
	    update_meta_esc();
	    update_delete_del();
	    update_keyboard_type();
	    if (screen->terminal_id < 200) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_8bit_ctrl].widget,
				False);
	    }
#if !defined(SIGTSTP)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_suspend].widget, False);
#endif
#if !defined(SIGCONT)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_continue].widget, False);
#endif
#ifdef ALLOWLOGGING
	    if (screen->inhibit & I_LOG) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_logging].widget, False);
	    }
#endif
	    if (screen->inhibit & I_SIGNAL) {
		int n;
		for (n = (int) mainMenu_suspend; n <= (int) mainMenu_quit; ++n) {
		    set_sensitivity(mw, mainMenuEntries[n].widget, False);
		}
	    }
	}
	break;

    case vtMenu:
	if (created) {
	    update_scrollbar();
	    update_jumpscroll();
	    update_reversevideo();
	    update_autowrap();
	    update_reversewrap();
	    update_autolinefeed();
	    update_appcursor();
	    update_appkeypad();
	    update_scrollkey();
	    update_scrollttyoutput();
	    update_allow132();
	    update_cursesemul();
	    update_visualbell();
	    update_poponbell();
	    update_marginbell();
	    update_cursorblink();
	    update_altscreen();
	    update_titeInhibit();
#ifndef NO_ACTIVE_ICON
	    if (!screen->fnt_icon || !screen->iconVwin.window) {
		set_sensitivity(mw,
				vtMenuEntries[vtMenu_activeicon].widget,
				False);
	    } else
		update_activeicon();
#endif /* NO_ACTIVE_ICON */
#if OPT_TEK4014
	    if (screen->inhibit & I_TEK) {
		int n;
		for (n = (int) vtMenu_tekshow; n <= (int) vtMenu_vthide; ++n) {
		    set_sensitivity(mw, vtMenuEntries[n].widget, False);
		}
	    }
#endif
	}
	break;

    case fontMenu:
	if (created) {
	    set_menu_font(True);
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_fontescape].widget,
			    (screen->menu_font_names[fontMenu_fontescape]
			     ? True : False));
#if OPT_BOX_CHARS
	    update_font_boxchars();
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_boxchars].widget,
			    True);
#endif
#if OPT_DEC_SOFTFONT		/* FIXME: not implemented */
	    update_font_loadable();
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_loadable].widget,
			    False);
#endif
#if OPT_DEC_CHRSET
	    update_font_doublesize();
	    if (term->screen.cache_doublesize == 0)
		set_sensitivity(mw,
				fontMenuEntries[fontMenu_font_doublesize].widget,
				False);
#endif
#if OPT_RENDERFONT
	    update_font_renderfont();
	    if (term->misc.face_name == 0) {
		set_sensitivity(mw,
				fontMenuEntries[fontMenu_render_font].widget,
				False);
	    }
#endif
#if OPT_WIDE_CHARS
	    update_font_utf8_mode();
	    if (term->screen.utf8_mode > 1)
		set_sensitivity(mw,
				fontMenuEntries[fontMenu_wide_chars].widget,
				False);
#endif
	}
	FindFontSelection(NULL, True);
	set_sensitivity(mw,
			fontMenuEntries[fontMenu_fontsel].widget,
			(screen->menu_font_names[fontMenu_fontsel]
			 ? True : False));
	break;

#if OPT_TEK4014
    case tekMenu:
	if (created) {
	    set_tekfont_menu_item(screen->cur.fontsize, True);
	    update_vtshow();
	}
	break;
#endif
    default:
	break;
    }

    return True;
}

void
HandleCreateMenu(Widget w,
		 XEvent * event,
		 String * params,	/* mainMenu, vtMenu, or tekMenu */
		 Cardinal *param_count)		/* 0 or 1 */
{
    (void) domenu(w, event, params, param_count);
}

void
HandlePopupMenu(Widget w,
		XEvent * event,
		String * params,	/* mainMenu, vtMenu, or tekMenu */
		Cardinal *param_count)	/* 0 or 1 */
{
    if (domenu(w, event, params, param_count)) {
#if OPT_TOOLBAR
	w = select_menu(w, mainMenu)->w;
#endif
	XtCallActionProc(w, "XawPositionSimpleMenu", event, params, 1);
	XtCallActionProc(w, "MenuPopup", event, params, 1);
    }
}

/*
 * private interfaces - keep out!
 */

/* ARGSUSED */
static void
handle_send_signal(Widget gw GCC_UNUSED, int sig)
{
#ifndef VMS
    TScreen *screen = &term->screen;

    if (hold_screen > 1)
	hold_screen = 0;
    if (screen->pid > 1)
	kill_process_group(screen->pid, sig);
#endif
}

/*
 * action routines
 */

/* ARGSUSED */
void
DoSecureKeyboard(Time tp GCC_UNUSED)
{
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
}

static void
do_securekbd(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Time now = CurrentTime;	/* XXX - wrong */

    if (screen->grabbedKbd) {
	XUngrabKeyboard(screen->display, now);
	ReverseVideo(term);
	screen->grabbedKbd = False;
    } else {
	if (XGrabKeyboard(screen->display, XtWindow(term),
			  True, GrabModeAsync, GrabModeAsync, now)
	    != GrabSuccess) {
	    Bell(XkbBI_MinorError, 100);
	} else {
	    ReverseVideo(term);
	    screen->grabbedKbd = True;
	}
    }
    update_securekbd();
}

static void
do_allowsends(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->allowSendEvents = !screen->allowSendEvents;
    update_allowsends();
}

static void
do_visualbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->visualbell = !screen->visualbell;
    update_visualbell();
}

static void
do_poponbell(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->poponbell = !screen->poponbell;
    update_poponbell();
}

#ifdef ALLOWLOGGING
static void
do_logging(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    if (screen->logging) {
	CloseLog(screen);
    } else {
	StartLog(screen);
    }
    /* update_logging done by CloseLog and StartLog */
}
#endif

static void
do_print(Widget gw GCC_UNUSED,
	 XtPointer closure GCC_UNUSED,
	 XtPointer data GCC_UNUSED)
{
    xtermPrintScreen(True);
}

static void
do_print_redir(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    setPrinterControlMode(term->screen.printer_controlmode ? 0 : 2);
}

static void
do_redraw(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    Redraw();
}

void
show_8bit_control(Bool value)
{
    if (term->screen.control_eight_bits != value) {
	term->screen.control_eight_bits = value;
	update_8bit_control();
    }
}

static void
do_8bit_control(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    show_8bit_control(!term->screen.control_eight_bits);
}

static void
do_backarrow(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECBKM;
    update_decbkm();
}

#if OPT_NUM_LOCK
static void
do_num_lock(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    term->misc.real_NumLock = !term->misc.real_NumLock;
    update_num_lock();
}

static void
do_meta_esc(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    term->screen.meta_sends_esc = !term->screen.meta_sends_esc;
    update_meta_esc();
}
#endif

static void
do_delete_del(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    if (xtermDeleteIsDEL())
	term->screen.delete_is_del = False;
    else
	term->screen.delete_is_del = True;
    update_delete_del();
}

static void
do_old_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsLegacy);
}

#if OPT_HP_FUNC_KEYS
static void
do_hp_fkeys(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
static void
do_sco_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsSCO);
}
#endif

static void
do_sun_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsSun);
}

#if OPT_SUNPC_KBD
/*
 * This really means "Sun/PC keyboard emulating VT220".
 */
static void
do_sun_kbd(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsVT220);
}
#endif

/*
 * The following cases use the pid instead of the process group so that we
 * don't get hosed by programs that change their process group
 */

/* ARGSUSED */
static void
do_suspend(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
#if defined(SIGTSTP)
    handle_send_signal(gw, SIGTSTP);
#endif
}

/* ARGSUSED */
static void
do_continue(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
#if defined(SIGCONT)
    handle_send_signal(gw, SIGCONT);
#endif
}

/* ARGSUSED */
static void
do_interrupt(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGINT);
}

/* ARGSUSED */
void
do_hangup(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGHUP);
}

/* ARGSUSED */
static void
do_terminate(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGTERM);
}

/* ARGSUSED */
static void
do_kill(Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGKILL);
}

static void
do_quit(Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    Cleanup(0);
}

/*
 * vt menu callbacks
 */

static void
do_scrollbar(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    ToggleScrollBar(term);
}

static void
do_jumpscroll(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    term->flags ^= SMOOTHSCROLL;
    if (term->flags & SMOOTHSCROLL) {
	screen->jumpscroll = False;
	if (screen->scroll_amt)
	    FlushScroll(screen);
    } else {
	screen->jumpscroll = True;
    }
    update_jumpscroll();
}

static void
do_reversevideo(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    ReverseVideo(term);
}

static void
do_autowrap(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    term->flags ^= WRAPAROUND;
    update_autowrap();
}

static void
do_reversewrap(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    term->flags ^= REVERSEWRAP;
    update_reversewrap();
}

static void
do_autolinefeed(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    term->flags ^= LINEFEED;
    update_autolinefeed();
}

static void
do_appcursor(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECCKM;
    update_appcursor();
}

static void
do_appkeypad(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECKPAM;
    update_appkeypad();
}

static void
do_scrollkey(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->scrollkey = !screen->scrollkey;
    update_scrollkey();
}

static void
do_scrollttyoutput(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->scrollttyoutput = !screen->scrollttyoutput;
    update_scrollttyoutput();
}

static void
do_allow132(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->c132 = !screen->c132;
    update_allow132();
}

static void
do_cursesemul(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->curses = !screen->curses;
    update_cursesemul();
}

static void
do_marginbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    if (!(screen->marginbell = !screen->marginbell))
	screen->bellarmed = -1;
    update_marginbell();
}

#if OPT_TEK4014
static void
handle_tekshow(Widget gw GCC_UNUSED, Bool allowswitch)
{
    TScreen *screen = &term->screen;

    if (!screen->Tshow) {	/* not showing, turn on */
	set_tek_visibility(True);
    } else if (screen->Vshow || allowswitch) {	/* is showing, turn off */
	set_tek_visibility(False);
	end_tek_mode();		/* WARNING: this does a longjmp */
    } else
	Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
static void
do_tekshow(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    handle_tekshow(gw, True);
}

/* ARGSUSED */
static void
do_tekonoff(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    handle_tekshow(gw, False);
}
#endif /* OPT_TEK4014 */

#if OPT_BLINK_CURS
/* ARGSUSED */
static void
do_cursorblink(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    ToggleCursorBlink(screen);
}
#endif

/* ARGSUSED */
static void
do_altscreen(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    ToggleAlternate(screen);
}

/* ARGSUSED */
static void
do_titeInhibit(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    term->misc.titeInhibit = !term->misc.titeInhibit;
    update_titeInhibit();
}

#ifndef NO_ACTIVE_ICON
/* ARGSUSED */
static void
do_activeicon(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    if (screen->iconVwin.window) {
	Widget shell = XtParent(term);
	term->misc.active_icon = !term->misc.active_icon;
	XtVaSetValues(shell, XtNiconWindow,
		      term->misc.active_icon ? screen->iconVwin.window : None,
		      (XtPointer) 0);
	update_activeicon();
    }
}
#endif /* NO_ACTIVE_ICON */

static void
do_softreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    VTReset(False, False);
}

static void
do_hardreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    VTReset(True, False);
}

static void
do_clearsavedlines(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    VTReset(True, True);
}

#if OPT_TEK4014
static void
do_tekmode(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    switch_modes(screen->TekEmu);	/* switch to tek mode */
}

/* ARGSUSED */
static void
do_vthide(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    hide_vt_window();
}
#endif /* OPT_TEK4014 */

/*
 * vtfont menu
 */

static void
do_vtfont(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    char *entryname = (char *) closure;
    int i;

    for (i = 0; i < NMENUFONTS; i++) {
	if (strcmp(entryname, fontMenuEntries[i].name) == 0) {
	    SetVTFont(i, True, NULL);
	    return;
	}
    }
    Bell(XkbBI_MinorError, 0);
}

#if OPT_DEC_CHRSET
static void
do_font_doublesize(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    if (term->screen.cache_doublesize != 0)
	term->screen.font_doublesize = !term->screen.font_doublesize;
    update_font_doublesize();
    Redraw();
}
#endif

#if OPT_BOX_CHARS
static void
do_font_boxchars(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    term->screen.force_box_chars = !term->screen.force_box_chars;
    update_font_boxchars();
    Redraw();
}
#endif

#if OPT_DEC_SOFTFONT
static void
do_font_loadable(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    term->misc.font_loadable = !term->misc.font_loadable;
    update_font_loadable();
}
#endif

#if OPT_RENDERFONT
static void
do_font_renderfont(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    int fontnum = screen->menu_font_number;
    String name = term->screen.menu_font_names[fontnum];

    term->misc.render_font = !term->misc.render_font;
    update_font_renderfont();
    xtermLoadFont(screen, xtermFontName(name), True, fontnum);
    ScrnRefresh(screen, 0, 0,
		screen->max_row + 1,
		screen->max_col + 1, True);
}
#endif

#if OPT_WIDE_CHARS
static void
do_font_utf8_mode(Widget gw GCC_UNUSED,
		  XtPointer closure GCC_UNUSED,
		  XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    switchPtyData(screen, !screen->utf8_mode);
    update_font_utf8_mode();
    /*
     * We don't repaint the screen when switching UTF-8 on/off.  When switching
     * on - the Latin-1 codes should paint as-is.  When switching off, that's
     * hard to do properly.
     */
}
#endif

/*
 * tek menu
 */

#if OPT_TEK4014
static void
do_tektextlarge(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    TekSetFontSize(tekMenu_tektextlarge);
}

static void
do_tektext2(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSetFontSize(tekMenu_tektext2);
}

static void
do_tektext3(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSetFontSize(tekMenu_tektext3);
}

static void
do_tektextsmall(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{

    TekSetFontSize(tekMenu_tektextsmall);
}

static void
do_tekpage(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton(False);
}

static void
do_tekreset(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton(True);
}

static void
do_tekcopy(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TekCopy();
}

static void
handle_vtshow(Widget gw GCC_UNUSED, Bool allowswitch)
{
    TScreen *screen = &term->screen;

    if (!screen->Vshow) {	/* not showing, turn on */
	set_vt_visibility(True);
    } else if (screen->Tshow || allowswitch) {	/* is showing, turn off */
	set_vt_visibility(False);
	if (!screen->TekEmu && TekRefresh)
	    dorefresh();
	end_vt_mode();		/* WARNING: this does a longjmp... */
    } else
	Bell(XkbBI_MinorError, 0);
}

static void
do_vtshow(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    handle_vtshow(gw, True);
}

static void
do_vtonoff(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    handle_vtshow(gw, False);
}

static void
do_vtmode(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    switch_modes(screen->TekEmu);	/* switch to vt, or from */
}

/* ARGSUSED */
static void
do_tekhide(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    hide_tek_window();
}
#endif /* OPT_TEK4014 */

/*
 * public handler routines
 */

static void
handle_toggle(void (*proc) PROTO_XT_CALLBACK_ARGS,
	      int var,
	      String * params,
	      Cardinal nparams,
	      Widget w,
	      XtPointer closure,
	      XtPointer data)
{
    int dir = -2;

    switch (nparams) {
    case 0:
	dir = -1;
	break;
    case 1:
	if (XmuCompareISOLatin1(params[0], "on") == 0)
	    dir = 1;
	else if (XmuCompareISOLatin1(params[0], "off") == 0)
	    dir = 0;
	else if (XmuCompareISOLatin1(params[0], "toggle") == 0)
	    dir = -1;
	break;
    }

    switch (dir) {
    case -2:
	Bell(XkbBI_MinorError, 0);
	break;

    case -1:
	(*proc) (w, closure, data);
	break;

    case 0:
	if (var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
	break;

    case 1:
	if (!var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
	break;
    }
    return;
}

void
HandleAllowSends(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    handle_toggle(do_allowsends, (int) term->screen.allowSendEvents,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetVisualBell(Widget w,
		    XEvent * event GCC_UNUSED,
		    String * params,
		    Cardinal *param_count)
{
    handle_toggle(do_visualbell, (int) term->screen.visualbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetPopOnBell(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal *param_count)
{
    handle_toggle(do_poponbell, (int) term->screen.poponbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

#ifdef ALLOWLOGGING
void
HandleLogging(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal *param_count)
{
    handle_toggle(do_logging, (int) term->screen.logging,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

/* ARGSUSED */
void
HandlePrintScreen(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params GCC_UNUSED,
		  Cardinal *param_count GCC_UNUSED)
{
    do_print(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandlePrintControlMode(Widget w,
		       XEvent * event GCC_UNUSED,
		       String * params GCC_UNUSED,
		       Cardinal *param_count GCC_UNUSED)
{
    do_print_redir(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleRedraw(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal *param_count GCC_UNUSED)
{
    do_redraw(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleSendSignal(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    /* *INDENT-OFF* */
    static struct sigtab {
	char *name;
	int sig;
    } signals[] = {
#ifdef SIGTSTP
	{ "suspend",	SIGTSTP },
	{ "tstp",	SIGTSTP },
#endif
#ifdef SIGCONT
	{ "cont",	SIGCONT },
#endif
	{ "int",	SIGINT },
	{ "hup",	SIGHUP },
	{ "quit",	SIGQUIT },
	{ "alrm",	SIGALRM },
	{ "alarm",	SIGALRM },
	{ "term",	SIGTERM },
	{ "kill",	SIGKILL },
	{ NULL, 0 },
    };
    /* *INDENT-ON* */

    if (*param_count == 1) {
	struct sigtab *st;

	for (st = signals; st->name; st++) {
	    if (XmuCompareISOLatin1(st->name, params[0]) == 0) {
		handle_send_signal(w, st->sig);
		return;
	    }
	}
	/* one could allow numeric values, but that would be a security hole */
    }

    Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
void
HandleQuit(Widget w,
	   XEvent * event GCC_UNUSED,
	   String * params GCC_UNUSED,
	   Cardinal *param_count GCC_UNUSED)
{
    do_quit(w, (XtPointer) 0, (XtPointer) 0);
}

void
Handle8BitControl(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    handle_toggle(do_8bit_control, (int) term->screen.control_eight_bits,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleBackarrow(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_toggle(do_backarrow, (int) term->keyboard.flags & MODE_DECBKM,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSunFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal *param_count)
{
    handle_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

#if OPT_NUM_LOCK
void
HandleNumLock(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal *param_count)
{
    handle_toggle(do_num_lock, (int) term->misc.real_NumLock,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleMetaEsc(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal *param_count)
{
    handle_toggle(do_meta_esc, (int) term->screen.meta_sends_esc,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

void
HandleDeleteIsDEL(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    handle_toggle(do_delete_del, term->screen.delete_is_del,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleOldFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal *param_count)
{
    handle_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

#if OPT_SUNPC_KBD
void
HandleSunKeyboard(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    handle_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_HP_FUNC_KEYS
void
HandleHpFunctionKeys(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal *param_count)
{
    handle_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_SCO_FUNC_KEYS
void
HandleScoFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal *param_count)
{
    handle_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

void
HandleScrollbar(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_toggle(do_scrollbar, (int) term->screen.fullVwin.sb_info.width,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleJumpscroll(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    handle_toggle(do_jumpscroll, (int) term->screen.jumpscroll,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleReverseVideo(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal *param_count)
{
    handle_toggle(do_reversevideo, (int) (term->misc.re_verse0),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAutoWrap(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal *param_count)
{
    handle_toggle(do_autowrap, (int) (term->flags & WRAPAROUND),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleReverseWrap(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    handle_toggle(do_reversewrap, (int) (term->flags & REVERSEWRAP),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAutoLineFeed(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal *param_count)
{
    handle_toggle(do_autolinefeed, (int) (term->flags & LINEFEED),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAppCursor(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_toggle(do_appcursor, (int) (term->keyboard.flags & MODE_DECCKM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAppKeypad(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_toggle(do_appkeypad, (int) (term->keyboard.flags & MODE_DECKPAM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleScrollKey(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_toggle(do_scrollkey, (int) term->screen.scrollkey,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleScrollTtyOutput(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal *param_count)
{
    handle_toggle(do_scrollttyoutput, (int) term->screen.scrollttyoutput,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAllow132(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal *param_count)
{
    handle_toggle(do_allow132, (int) term->screen.c132,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleCursesEmul(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    handle_toggle(do_cursesemul, (int) term->screen.curses,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleMarginBell(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    handle_toggle(do_marginbell, (int) term->screen.marginbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

#if OPT_BLINK_CURS
void
HandleCursorBlink(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle(do_cursorblink, (int) term->screen.cursor_blink,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

void
HandleAltScreen(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle(do_altscreen, (int) term->screen.alternate,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleTiteInhibit(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle(do_titeInhibit, !((int) term->misc.titeInhibit),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleSoftReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal *param_count GCC_UNUSED)
{
    do_softreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleHardReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal *param_count GCC_UNUSED)
{
    do_hardreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleClearSavedLines(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params GCC_UNUSED,
		      Cardinal *param_count GCC_UNUSED)
{
    do_clearsavedlines(w, (XtPointer) 0, (XtPointer) 0);
}

#if OPT_DEC_CHRSET
void
HandleFontDoublesize(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal *param_count)
{
    handle_toggle(do_font_doublesize, (int) term->screen.font_doublesize,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_BOX_CHARS
void
HandleFontBoxChars(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal *param_count)
{
    handle_toggle(do_font_boxchars, (int) term->screen.force_box_chars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_DEC_SOFTFONT
void
HandleFontLoading(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal *param_count)
{
    handle_toggle(do_font_loadable, (int) term->misc.font_loadable,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_RENDERFONT
void
HandleRenderFont(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    handle_toggle(do_font_renderfont, term->misc.render_font,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_WIDE_CHARS
void
HandleUTF8Mode(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal *param_count)
{
    handle_toggle(do_font_utf8_mode, term->screen.utf8_mode,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}
#endif

#if OPT_TEK4014
void
HandleSetTerminalType(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal *param_count)
{
    if (*param_count == 1) {
	switch (params[0][0]) {
	case 'v':
	case 'V':
	    if (term->screen.TekEmu)
		do_vtmode(w, (XtPointer) 0, (XtPointer) 0);
	    break;
	case 't':
	case 'T':
	    if (!term->screen.TekEmu)
		do_tekmode(w, (XtPointer) 0, (XtPointer) 0);
	    break;
	default:
	    Bell(XkbBI_MinorError, 0);
	}
    } else {
	Bell(XkbBI_MinorError, 0);
    }
}

void
HandleVisibility(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    if (*param_count == 2) {
	switch (params[0][0]) {
	case 'v':
	case 'V':
	    handle_toggle(do_vtonoff, (int) term->screen.Vshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
	    break;
	case 't':
	case 'T':
	    handle_toggle(do_tekonoff, (int) term->screen.Tshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
	    break;
	default:
	    Bell(XkbBI_MinorError, 0);
	}
    } else {
	Bell(XkbBI_MinorError, 0);
    }
}

/* ARGSUSED */
void
HandleSetTekText(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal *param_count)
{
    void (*proc) PROTO_XT_CALLBACK_ARGS = 0;

    switch (*param_count) {
    case 0:
	proc = do_tektextlarge;
	break;
    case 1:
	switch (params[0][0]) {
	case 'l':
	case 'L':
	    proc = do_tektextlarge;
	    break;
	case '2':
	    proc = do_tektext2;
	    break;
	case '3':
	    proc = do_tektext3;
	    break;
	case 's':
	case 'S':
	    proc = do_tektextsmall;
	    break;
	}
	break;
    }
    if (proc)
	(*proc) (w, (XtPointer) 0, (XtPointer) 0);
    else
	Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
void
HandleTekPage(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    do_tekpage(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleTekReset(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params GCC_UNUSED,
	       Cardinal *param_count GCC_UNUSED)
{
    do_tekreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleTekCopy(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    do_tekcopy(w, (XtPointer) 0, (XtPointer) 0);
}
#endif /* OPT_TEK4014 */

void
UpdateMenuItem(Widget mi, XtArgVal val)
{
    static Arg menuArgs =
    {XtNleftBitmap, (XtArgVal) 0};

    if (mi) {
	menuArgs.value = (XtArgVal) ((val)
				     ? term->screen.menu_item_bitmap
				     : None);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
}

void
SetItemSensitivity(Widget mi, XtArgVal val)
{
    static Arg menuArgs =
    {XtNsensitive, (XtArgVal) 0};

    if (mi) {
	menuArgs.value = (XtArgVal) (val);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
}

#if OPT_TOOLBAR
/*
 * The normal style of xterm popup menu delays initialization until the menu is
 * first requested.  When using a toolbar, we can use the same initialization,
 * though on the first popup there will be a little geometry layout jitter,
 * since the menu is already managed when this callback is invoked.
 */
static void
InitPopup(Widget gw,
	  XtPointer closure,
	  XtPointer data GCC_UNUSED)
{
    String params[2];
    Cardinal count = 1;

    params[0] = (char *) closure;
    params[1] = 0;
    TRACE(("InitPopup(%s)\n", params[0]));

    domenu(gw, (XEvent *) 0, params, &count);

    XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
}

static void
SetupShell(Widget *menus, MenuList * shell, Widget *menu_tops, int n, int m)
{
    char temp[80];
    char *external_name = 0;

    shell[n].w = XtVaCreatePopupShell(menu_names[n].internal_name,
				      simpleMenuWidgetClass,
				      *menus,
				      XtNgeometry, NULL,
				      (XtPointer) 0);

    XtAddCallback(shell[n].w, XtNpopupCallback, InitPopup, menu_names[n].internal_name);
    XtVaGetValues(shell[n].w,
		  XtNlabel, &external_name,
		  (XtPointer) 0);

    TRACE(("...SetupShell(%s) -> %s -> %#lx\n",
	   menu_names[n].internal_name,
	   external_name,
	   (long) shell[n].w));

    sprintf(temp, "%sButton", menu_names[n].internal_name);
    menu_tops[n] = XtVaCreateManagedWidget(temp,
					   menuButtonWidgetClass,
					   *menus,
					   XtNfromHoriz, ((m >= 0)
							  ? menu_tops[m]
							  : 0),
					   XtNmenuName, menu_names[n].internal_name,
					   XtNlabel, external_name,
					   (XtPointer) 0);
}

#endif

void
SetupMenus(Widget shell, Widget *forms, Widget *menus)
{
#if OPT_TOOLBAR
    int n;
    Widget menu_tops[NUM_POPUP_MENUS];
#endif

    TRACE(("SetupMenus(%s)\n", shell == toplevel ? "vt100" : "tek4014"));

    if (shell == toplevel) {
	XawSimpleMenuAddGlobalActions(app_con);
	XtRegisterGrabAction(HandlePopupMenu, True,
			     (ButtonPressMask | ButtonReleaseMask),
			     GrabModeAsync, GrabModeAsync);
    }
#if OPT_TOOLBAR
    *forms = XtVaCreateManagedWidget("form",
				     formWidgetClass, shell,
				     (XtPointer) 0);
    xtermAddInput(*forms);

    /*
     * Set a nominal value for the preferred pane size, which lets the
     * buttons determine the actual height of the menu bar.  We don't show
     * the grip, because it's too easy to make the toolbar look bad that
     * way.
     */
    *menus = XtVaCreateManagedWidget("menubar",
				     boxWidgetClass, *forms,
				     XtNorientation, XtorientHorizontal,
				     XtNtop, XawChainTop,
				     XtNbottom, XawChainTop,
				     XtNleft, XawChainLeft,
				     XtNright, XawChainLeft,
				     (XtPointer) 0);

    if (shell == toplevel) {	/* vt100 */
	for (n = mainMenu; n <= fontMenu; n++) {
	    SetupShell(menus, vt_shell, menu_tops, n, n - 1);
	}
    }
#if OPT_TEK4014
    else {			/* tek4014 */
	SetupShell(menus, tek_shell, menu_tops, mainMenu, -1);
	SetupShell(menus, tek_shell, menu_tops, tekMenu, mainMenu);
    }
#endif

#else
    *forms = shell;
    *menus = shell;
#endif

    TRACE(("...shell=%#lx\n", (long) shell));
    TRACE(("...forms=%#lx\n", (long) *forms));
    TRACE(("...menus=%#lx\n", (long) *menus));
}

#if OPT_TOOLBAR
void
SetupToolbar(Widget shell)
{
    int n;
    if (shell == toplevel) {	/* vt100 */
	for (n = mainMenu; n <= fontMenu; n++) {
	    InitPopup(vt_shell[n].w, menu_names[n].internal_name, 0);
	}
    }
#if OPT_TEK4014
    else {			/* tek4014 */
	InitPopup(tek_shell[mainMenu].w, menu_names[mainMenu].internal_name, 0);
	InitPopup(tek_shell[tekMenu].w, menu_names[tekMenu].internal_name, 0);
    }
#endif
    term->screen.toolbars = True;
    update_toolbar();
}

static TbInfo *
toolbar_info(Widget w)
{
    return ((w == (Widget) term)
	    ? &(WhichVWin(&(term->screen))->tb_info)
	    : &(tekWidget->tek.tb_info));
}

static void
hide_toolbar(Widget w)
{
    if (w != 0) {
	TbInfo *info = toolbar_info(w);

	if (info->menu_bar != 0) {
	    if (XtIsRealized(info->menu_bar))
		XtUnmapWidget(info->menu_bar);
	}
	XtVaSetValues(w,
		      XtNfromVert, (Widget) 0,
		      (XtPointer) 0);
    }
}

static void
show_toolbar(Widget w)
{
    if (w != 0) {
	TbInfo *info = toolbar_info(w);

	if (info->menu_bar != 0) {
	    if (XtIsRealized(info->menu_bar))
		XtMapWidget(info->menu_bar);
	}
	XtVaSetValues(w,
		      XtNfromVert, info->menu_bar,
		      (XtPointer) 0);
	/*
	 * This is needed to make the terminal widget move down below the
	 * toolbar.
	 */
	XawFormDoLayout(XtParent(w), True);
    }
}

void
ShowToolbar(Bool enable)
{
    if (enable) {
	show_toolbar((Widget) term);
	show_toolbar((Widget) tekWidget);
    } else {
	hide_toolbar((Widget) term);
	hide_toolbar((Widget) tekWidget);
    }
}

void
HandleToolbar(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    handle_toggle(do_toolbar, (int) term->screen.toolbars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
static void
do_toolbar(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    /*
     * Toggle toolbars for both vt100 and tek windows, since they share the
     * menu which contains the checkbox indicating whether the toolbar is
     * active.
     */
    ShowToolbar(term->screen.toolbars = !term->screen.toolbars);
    update_toolbar();
}

void
update_toolbar(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_toolbar].widget,
		     term->screen.toolbars);
}
#endif /* OPT_TOOLBAR */

void
update_securekbd(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_securekbd].widget,
		     term->screen.grabbedKbd);
}

void
update_allowsends(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_allowsends].widget,
		     term->screen.allowSendEvents);
}

#ifdef ALLOWLOGGING
void
update_logging(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_logging].widget,
		     term->screen.logging);
}
#endif

void
update_print_redir(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_print_redir].widget,
		     term->screen.printer_controlmode);
}

void
update_8bit_control(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_8bit_ctrl].widget,
		     term->screen.control_eight_bits);
}

void
update_decbkm(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_backarrow].widget,
		     (term->keyboard.flags & MODE_DECBKM) != 0);
}

#if OPT_NUM_LOCK
void
update_num_lock(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_num_lock].widget,
		     term->misc.real_NumLock);
}

void
update_meta_esc(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_meta_esc].widget,
		     term->screen.meta_sends_esc);
}
#endif

void
update_sun_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_fkeys].widget,
		     term->keyboard.type == keyboardIsSun);
}

void
update_old_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_old_fkeys].widget,
		     term->keyboard.type == keyboardIsLegacy);
}

void
update_delete_del(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_delete_del].widget,
		     xtermDeleteIsDEL());
}

#if OPT_SUNPC_KBD
void
update_sun_kbd(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_kbd].widget,
		     term->keyboard.type == keyboardIsVT220);
}
#endif

#if OPT_HP_FUNC_KEYS
void
update_hp_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_hp_fkeys].widget,
		     term->keyboard.type == keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
void
update_sco_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sco_fkeys].widget,
		     term->keyboard.type == keyboardIsSCO);
}
#endif

void
update_scrollbar(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollbar].widget,
		     ScrollbarWidth(&term->screen));
}

void
update_jumpscroll(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_jumpscroll].widget,
		     term->screen.jumpscroll);
}

void
update_reversevideo(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversevideo].widget,
		     (term->misc.re_verse));
}

void
update_autowrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autowrap].widget,
		     (term->flags & WRAPAROUND) != 0);
}

void
update_reversewrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversewrap].widget,
		     (term->flags & REVERSEWRAP) != 0);
}

void
update_autolinefeed(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autolinefeed].widget,
		     (term->flags & LINEFEED) != 0);
}

void
update_appcursor(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appcursor].widget,
		     (term->keyboard.flags & MODE_DECCKM) != 0);
}

void
update_appkeypad(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appkeypad].widget,
		     (term->keyboard.flags & MODE_DECKPAM) != 0);
}

void
update_scrollkey(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollkey].widget,
		     term->screen.scrollkey);
}

void
update_scrollttyoutput(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollttyoutput].widget,
		     term->screen.scrollttyoutput);
}

void
update_allow132(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_allow132].widget,
		     term->screen.c132);
}

void
update_cursesemul(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursesemul].widget,
		     term->screen.curses);
}

void
update_visualbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_visualbell].widget,
		     term->screen.visualbell);
}

void
update_poponbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_poponbell].widget,
		     term->screen.poponbell);
}

void
update_marginbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_marginbell].widget,
		     term->screen.marginbell);
}

#if OPT_BLINK_CURS
void
update_cursorblink(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursorblink].widget,
		     term->screen.cursor_blink);
}
#endif

void
update_altscreen(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_altscreen].widget,
		     term->screen.alternate);
}

void
update_titeInhibit(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_titeInhibit].widget,
		     !(term->misc.titeInhibit));
}

#ifndef NO_ACTIVE_ICON
void
update_activeicon(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_activeicon].widget,
		     term->misc.active_icon);
}
#endif /* NO_ACTIVE_ICON */

#if OPT_DEC_CHRSET
void
update_font_doublesize(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_doublesize].widget,
		     term->screen.font_doublesize);
}
#endif

#if OPT_BOX_CHARS
void
update_font_boxchars(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_boxchars].widget,
		     term->screen.force_box_chars);
}
#endif

#if OPT_DEC_SOFTFONT
void
update_font_loadable(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_loadable].widget,
		     term->misc.font_loadable);
}
#endif

#if OPT_RENDERFONT
void
update_font_renderfont(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_render_font].widget,
		     term->misc.render_font);
}
#endif

#if OPT_WIDE_CHARS
void
update_font_utf8_mode(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_wide_chars].widget,
		     term->screen.utf8_mode);
}
#endif

#if OPT_TEK4014
void
update_tekshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekshow].widget,
			 term->screen.Tshow);
    }
}

void
update_vttekmode(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekmode].widget,
			 term->screen.TekEmu);
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtmode].widget,
			 !term->screen.TekEmu);
    }
}

void
update_vtshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtshow].widget,
			 term->screen.Vshow);
    }
}

void
set_vthide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.vtMenu,
			vtMenuEntries[vtMenu_vthide].widget,
			term->screen.Tshow);
    }
}

void
set_tekhide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.tekMenu,
			tekMenuEntries[tekMenu_tekhide].widget,
			term->screen.Vshow);
    }
}

void
set_tekfont_menu_item(int n, int val)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[FS2MI(n)].widget,
			 (val));
    }
}
#endif /* OPT_TEK4014 */

void
set_menu_font(int val)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[term->screen.menu_font_number].widget,
		     (val));
}
@


1.2
log
@merge and go back to xterm-215
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.206 2006/04/10 00:34:36 tom Exp $ */
d3 1
d6 1
a6 1
Copyright 1999-2005,2006 by Thomas E. Dickey
d50 1
a50 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.68 2006/04/10 00:34:36 dickey Exp $ */
d127 1
a144 1
static void do_selectClipboard PROTO_XT_CALLBACK_ARGS;
a182 1
static void do_alt_esc         PROTO_XT_CALLBACK_ARGS;
a224 1
static void do_font_utf8_title PROTO_XT_CALLBACK_ARGS;
a247 1
    { "alt-esc",	do_alt_esc,	NULL },
d284 1
a284 1
    { "selectToClipboard",do_selectClipboard, NULL },
a340 1
    { "utf8-title",	do_font_utf8_title,NULL },
d385 1
a385 2
    Widget b;			/* the toolbar's buttons */
    Widget w;			/* the popup shell activated by the button */
a554 1
    TRACE(("domenu(%s) %s\n", params[0], created ? "create" : "update"));
a565 1
	    update_alt_esc();
a568 8
	    if (!xtermHasPrinter()) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_print].widget,
				False);
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_print_redir].widget,
				False);
	    }
a610 1
	    update_selectToClipboard();
d672 4
a675 1
	    update_font_utf8_title();
a705 1
    TRACE(("HandleCreateMenu\n"));
a714 1
    TRACE(("HandlePopupMenu\n"));
d746 7
d766 1
a766 1
	if (XGrabKeyboard(screen->display, XtWindow(CURRENT_EMU(screen)),
a777 20
/* ARGSUSED */
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event GCC_UNUSED,		/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
#if 0
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
#endif
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
}

a888 9
do_alt_esc(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    term->screen.input_eight_bits = !term->screen.input_eight_bits;
    update_alt_esc();
}

static void
a1135 11
do_selectClipboard(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->selectToClipboard = !screen->selectToClipboard;
    update_selectToClipboard();
}

static void
a1174 1
    TRACE(("Show tek-window\n"));
d1306 1
a1306 1
	  XtPointer closure,
d1314 1
a1314 1
	    SetVTFont(term, i, True, NULL);
d1365 1
a1365 1
    String name = term->screen.MenuFontName(fontnum);
d1369 1
a1369 1
    xtermLoadFont(term, xtermFontName(name), True, fontnum);
d1371 2
a1372 2
		MaxRows(screen),
		MaxCols(screen), True);
a1383 13
    /*
     * If xterm was started with -wc option, it might not have the wide fonts.
     * If xterm was not started with -wc, it might not have wide cells.
     */
    if (!screen->utf8_mode) {
	if (screen->wide_chars) {
	    if (xtermLoadWideFonts(term, True)) {
		SetVTFont(term, screen->menu_font_number, TRUE, NULL);
	    }
	} else {
	    ChangeToWide(screen);
	}
    }
d1385 1
a1391 11

static void
do_font_utf8_title(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->utf8_title = !screen->utf8_title;
    update_font_utf8_title();
}
a1460 1
    TRACE(("Show vt-window\n"));
a1562 6
#define handle_vt_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

#define handle_tek_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

d1569 2
a1570 2
    handle_vt_toggle(do_allowsends, term->screen.allowSendEvents,
		     params, *param_count, w);
d1579 2
a1580 2
    handle_vt_toggle(do_visualbell, term->screen.visualbell,
		     params, *param_count, w);
d1589 2
a1590 2
    handle_vt_toggle(do_poponbell, term->screen.poponbell,
		     params, *param_count, w);
d1600 2
a1601 2
    handle_vt_toggle(do_logging, term->screen.logging,
		     params, *param_count, w);
d1696 2
a1697 2
    handle_vt_toggle(do_8bit_control, term->screen.control_eight_bits,
		     params, *param_count, w);
d1706 2
a1707 2
    handle_vt_toggle(do_backarrow, term->keyboard.flags & MODE_DECBKM,
		     params, *param_count, w);
d1716 2
a1717 2
    handle_vt_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		     params, *param_count, w);
d1727 2
a1728 12
    handle_vt_toggle(do_num_lock, term->misc.real_NumLock,
		     params, *param_count, w);
}

void
HandleAltEsc(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params,
	     Cardinal *param_count)
{
    handle_vt_toggle(do_alt_esc, !term->screen.input_eight_bits,
		     params, *param_count, w);
d1737 2
a1738 2
    handle_vt_toggle(do_meta_esc, term->screen.meta_sends_esc,
		     params, *param_count, w);
d1748 2
a1749 2
    handle_vt_toggle(do_delete_del, term->screen.delete_is_del,
		     params, *param_count, w);
d1758 2
a1759 2
    handle_vt_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		     params, *param_count, w);
d1769 2
a1770 2
    handle_vt_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		     params, *param_count, w);
d1781 2
a1782 2
    handle_vt_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		     params, *param_count, w);
d1793 2
a1794 2
    handle_vt_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		     params, *param_count, w);
d1804 2
a1805 6
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_scrollbar, term->screen.fullVwin.sb_info.width,
			 params, *param_count, w);
    }
d1814 2
a1815 12
    handle_vt_toggle(do_jumpscroll, term->screen.jumpscroll,
		     params, *param_count, w);
}

void
HandleSetSelect(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_selectClipboard, term->screen.selectToClipboard,
		     params, *param_count, w);
d1824 2
a1825 2
    handle_vt_toggle(do_reversevideo, (term->misc.re_verse0),
		     params, *param_count, w);
d1834 2
a1835 2
    handle_vt_toggle(do_autowrap, (term->flags & WRAPAROUND),
		     params, *param_count, w);
d1844 2
a1845 2
    handle_vt_toggle(do_reversewrap, (term->flags & REVERSEWRAP),
		     params, *param_count, w);
d1854 2
a1855 2
    handle_vt_toggle(do_autolinefeed, (term->flags & LINEFEED),
		     params, *param_count, w);
d1864 2
a1865 2
    handle_vt_toggle(do_appcursor, (term->keyboard.flags & MODE_DECCKM),
		     params, *param_count, w);
d1874 2
a1875 2
    handle_vt_toggle(do_appkeypad, (term->keyboard.flags & MODE_DECKPAM),
		     params, *param_count, w);
d1884 2
a1885 2
    handle_vt_toggle(do_scrollkey, term->screen.scrollkey,
		     params, *param_count, w);
d1894 2
a1895 2
    handle_vt_toggle(do_scrollttyoutput, term->screen.scrollttyoutput,
		     params, *param_count, w);
d1904 2
a1905 2
    handle_vt_toggle(do_allow132, term->screen.c132,
		     params, *param_count, w);
d1914 2
a1915 2
    handle_vt_toggle(do_cursesemul, term->screen.curses,
		     params, *param_count, w);
d1924 2
a1925 2
    handle_vt_toggle(do_marginbell, term->screen.marginbell,
		     params, *param_count, w);
d1936 2
a1937 2
    handle_vt_toggle(do_cursorblink, term->screen.cursor_blink,
		     params, *param_count, w);
d1948 2
a1949 2
    handle_vt_toggle(do_altscreen, term->screen.alternate,
		     params, *param_count, w);
d1959 2
a1960 2
    handle_vt_toggle(do_titeInhibit, !(term->misc.titeInhibit),
		     params, *param_count, w);
d2000 2
a2001 2
    handle_vt_toggle(do_font_doublesize, term->screen.font_doublesize,
		     params, *param_count, w);
d2012 2
a2013 2
    handle_vt_toggle(do_font_boxchars, term->screen.force_box_chars,
		     params, *param_count, w);
d2024 2
a2025 2
    handle_vt_toggle(do_font_loadable, term->misc.font_loadable,
		     params, *param_count, w);
d2036 2
a2037 2
    handle_vt_toggle(do_font_renderfont, term->misc.render_font,
		     params, *param_count, w);
d2048 2
a2049 12
    handle_vt_toggle(do_font_utf8_mode, term->screen.utf8_mode,
		     params, *param_count, w);
}

void
HandleUTF8Title(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_font_utf8_title, term->screen.utf8_title,
		     params, *param_count, w);
d2090 3
a2092 2
	    handle_tek_toggle(do_vtonoff, (int) term->screen.Vshow,
			      params + 1, (*param_count) - 1, w);
d2096 3
a2098 2
	    handle_tek_toggle(do_tekonoff, (int) term->screen.Tshow,
			      params + 1, (*param_count) - 1, w);
d2224 1
a2224 2
    if (gw)
	XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
d2227 2
a2228 2
static Dimension
SetupShell(Widget *menus, MenuList * shell, int n, int m)
a2231 2
    Dimension button_height;
    Dimension button_border;
d2250 10
a2259 13
    shell[n].b = XtVaCreateManagedWidget(temp,
					 menuButtonWidgetClass,
					 *menus,
					 XtNfromHoriz, ((m >= 0)
							? shell[m].b
							: 0),
					 XtNmenuName, menu_names[n].internal_name,
					 XtNlabel, external_name,
					 (XtPointer) 0);
    XtVaGetValues(shell[n].b,
		  XtNheight, &button_height,
		  XtNborderWidth, &button_border,
		  (XtPointer) 0);
d2261 1
a2261 3
    return button_height + (button_border * 2);
}
#endif /* OPT_TOOLBAR */
d2264 1
a2264 1
SetupMenus(Widget shell, Widget *forms, Widget *menus, Dimension * menu_high)
d2267 2
a2268 4
    Dimension button_height;
    Dimension toolbar_hSpace;
    Dimension toolbar_border;
    Arg args[10];
a2272 2
    *menu_high = 0;

d2291 8
a2298 22
    XtSetArg(args[0], XtNorientation, XtorientHorizontal);
    XtSetArg(args[1], XtNtop, XawChainTop);
    XtSetArg(args[2], XtNbottom, XawChainTop);
    XtSetArg(args[3], XtNleft, XawChainLeft);
    XtSetArg(args[4], XtNright, XawChainLeft);

    if (resource.toolBar) {
	*menus = XtCreateManagedWidget("menubar", boxWidgetClass, *forms,
				       args, 5);
    } else {
	*menus = XtCreateWidget("menubar", boxWidgetClass, *forms, args, 5);
    }

    /*
     * The toolbar widget's height is not necessarily known yet.  If the
     * toolbar is not created as a managed widget, we can still make a good
     * guess about its height by collecting the widget's other resource values.
     */
    XtVaGetValues(*menus,
		  XtNhSpace, &toolbar_hSpace,
		  XtNborderWidth, &toolbar_border,
		  (XtPointer) 0);
d2301 2
a2302 3
	int j;
	for (j = mainMenu; j <= fontMenu; j++) {
	    button_height = SetupShell(menus, vt_shell, j, j - 1);
d2307 2
a2308 2
	button_height = SetupShell(menus, tek_shell, mainMenu, -1);
	button_height = SetupShell(menus, tek_shell, tekMenu, mainMenu);
a2311 8
    /*
     * Tell the main program how high the toolbar is, to help with the initial
     * layout.
     */
    *menu_high = (button_height + 2 * (toolbar_hSpace + toolbar_border));
    TRACE(("...menuHeight:%d = (%d + 2 * (%d + %d))\n",
	   *menu_high, button_height, toolbar_hSpace, toolbar_border));

d2322 1
d2324 1
a2324 1
repairSizeHints(void)
d2326 5
a2330 9
    TScreen *screen = &term->screen;

    XSizeHints sizehints;

    if (XtIsRealized((Widget) term)) {
	bzero(&sizehints, sizeof(sizehints));
	xtermSizeHints(term, &sizehints, ScrollbarWidth(screen));

	XSetWMNormalHints(screen->display, XtWindow(SHELL_OF(term)), &sizehints);
a2331 22
}

#if OPT_TOOLBAR
#define INIT_POPUP(s, n) InitPopup(s[n].w, menu_names[n].internal_name, 0)

static Bool
InitWidgetMenu(Widget shell)
{
    Bool result = False;

    TRACE(("InitWidgetMenu(%p)\n", shell));
    if (term != 0) {
	if (shell == toplevel) {	/* vt100 */
	    if (!term->init_vt_menu) {
		INIT_POPUP(vt_shell, mainMenu);
		INIT_POPUP(vt_shell, vtMenu);
		INIT_POPUP(vt_shell, fontMenu);
		term->init_vt_menu = True;
		TRACE(("...InitWidgetMenu(vt)\n"));
	    }
	    result = term->init_vt_menu;
	}
d2333 4
a2336 9
	else if (tekWidget) {	/* tek4014 */
	    if (!term->init_tek_menu) {
		INIT_POPUP(tek_shell, mainMenu);
		INIT_POPUP(tek_shell, tekMenu);
		term->init_tek_menu = True;
		TRACE(("...InitWidgetMenu(tek)\n"));
	    }
	    result = term->init_tek_menu;
	}
d2338 2
a2339 3
    }
    TRACE(("...InitWidgetMenu ->%d\n", result));
    return result;
d2345 3
a2347 6
    TRACE(("...getting toolbar_info\n"));
#if OPT_TEK4014
    if (w != (Widget) term)
	return &(tekWidget->tek.tb_info);
#endif
    return &(WhichVWin(&(term->screen))->tb_info);
d2356 4
a2359 1
	TRACE(("hiding toolbar\n"));
a2362 9

	if (info->menu_bar != 0) {
	    repairSizeHints();
	    XtUnmanageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
		XtUnmapWidget(info->menu_bar);
	    }
	}
	TRACE(("...hiding toolbar (done)\n"));
a2371 1
	TRACE(("showing toolbar\n"));
a2372 3
	    XtVaSetValues(w,
			  XtNfromVert, info->menu_bar,
			  (XtPointer) 0);
a2373 3
		repairSizeHints();
	    XtManageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
a2374 1
	    }
d2376 3
a2383 1
	TRACE(("...showing toolbar (done)\n"));
a2386 3
/*
 * Make the toolbar visible or invisible in the current window(s).
 */
d2390 3
a2392 4
    TRACE(("ShowToolbar(%d)\n", enable));

    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
d2394 2
a2395 15
	if (enable) {
	    if (InitWidgetMenu(toplevel))
		show_toolbar((Widget) term);
#if OPT_TEK4014
	    if (InitWidgetMenu(tekshellwidget))
		show_toolbar((Widget) tekWidget);
#endif
	} else {
	    hide_toolbar((Widget) term);
#if OPT_TEK4014
	    hide_toolbar((Widget) tekWidget);
#endif
	}
	resource.toolBar = enable;
	update_toolbar();
d2405 2
a2406 6
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_toolbar, resource.toolBar,
			 params, *param_count, w);
    }
d2420 2
a2421 5
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	ShowToolbar(resource.toolBar = !resource.toolBar);
    }
d2429 1
a2429 1
		     resource.toolBar);
a2492 8
update_alt_esc(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_alt_esc].widget,
		     !term->screen.input_eight_bits);
}

void
a2635 8
update_selectToClipboard(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_selectToClipboard].widget,
		     term->screen.selectToClipboard);
}

void
a2645 1
#if 0				/* 2006-2-12: no longer menu entry */
a2648 1
#endif
d2755 3
a2757 19
    Widget iw = fontMenuEntries[fontMenu_wide_chars].widget;
    Bool active = (term->screen.utf8_mode != uAlways);
    Bool enable = (term->screen.utf8_mode != uFalse);

    TRACE(("update_font_utf8_mode active %d, enable %d\n", active, enable));
    set_sensitivity(term->screen.fontMenu, iw, active);
    update_menu_item(term->screen.fontMenu, iw, enable);
}

void
update_font_utf8_title(void)
{
    Widget iw = fontMenuEntries[fontMenu_wide_title].widget;
    Bool active = (term->screen.utf8_mode != uFalse);
    Bool enable = (term->screen.utf8_title);

    TRACE(("update_font_utf8_title active %d, enable %d\n", active, enable));
    set_sensitivity(term->screen.fontMenu, iw, active);
    update_menu_item(term->screen.fontMenu, iw, enable);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.153 2005/01/10 22:53:49 tom Exp $ */
a2 1
/* $Xorg: menu.c,v 1.4 2001/02/09 02:06:03 xorgcvs Exp $ */
d5 1
a5 1
Copyright 1999-2004,2005 by Thomas E. Dickey
d49 1
a49 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.58 2005/01/14 01:50:03 dickey Exp $ */
a125 1
static void do_cursesemul      PROTO_XT_CALLBACK_ARGS;
d143 1
d182 1
d225 1
d249 1
d286 1
a286 1
    { "cursesemul",	do_cursesemul,	NULL },
d343 1
d388 2
a389 1
    Widget w;
d559 1
d571 1
d575 8
d625 1
d687 1
a687 4
	    if (term->screen.utf8_mode > 1)
		set_sensitivity(mw,
				fontMenuEntries[fontMenu_wide_chars].widget,
				False);
d718 1
d728 1
a759 7
/* ARGSUSED */
void
DoSecureKeyboard(Time tp GCC_UNUSED)
{
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
}

d773 1
a773 1
	if (XGrabKeyboard(screen->display, XtWindow(term),
d785 20
d916 9
d1172 11
d1222 1
d1354 1
a1354 1
	  XtPointer closure GCC_UNUSED,
d1362 1
a1362 1
	    SetVTFont(i, True, NULL);
d1413 1
a1413 1
    String name = term->screen.menu_font_names[fontnum];
d1417 1
a1417 1
    xtermLoadFont(screen, xtermFontName(name), True, fontnum);
d1419 2
a1420 2
		screen->max_row + 1,
		screen->max_col + 1, True);
d1432 13
a1445 1
    update_font_utf8_mode();
d1452 11
d1532 1
d1635 6
d1647 2
a1648 2
    handle_toggle(do_allowsends, (int) term->screen.allowSendEvents,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1657 2
a1658 2
    handle_toggle(do_visualbell, (int) term->screen.visualbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1667 2
a1668 2
    handle_toggle(do_poponbell, (int) term->screen.poponbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1678 2
a1679 2
    handle_toggle(do_logging, (int) term->screen.logging,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1774 2
a1775 2
    handle_toggle(do_8bit_control, (int) term->screen.control_eight_bits,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1784 2
a1785 2
    handle_toggle(do_backarrow, (int) term->keyboard.flags & MODE_DECBKM,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1794 2
a1795 2
    handle_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1805 12
a1816 2
    handle_toggle(do_num_lock, (int) term->misc.real_NumLock,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1825 2
a1826 2
    handle_toggle(do_meta_esc, (int) term->screen.meta_sends_esc,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1836 2
a1837 2
    handle_toggle(do_delete_del, term->screen.delete_is_del,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1846 2
a1847 2
    handle_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1857 2
a1858 2
    handle_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1869 2
a1870 2
    handle_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1881 2
a1882 2
    handle_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1892 6
a1897 2
    handle_toggle(do_scrollbar, (int) term->screen.fullVwin.sb_info.width,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1906 12
a1917 2
    handle_toggle(do_jumpscroll, (int) term->screen.jumpscroll,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1926 2
a1927 2
    handle_toggle(do_reversevideo, (int) (term->misc.re_verse0),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1936 2
a1937 2
    handle_toggle(do_autowrap, (int) (term->flags & WRAPAROUND),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1946 2
a1947 2
    handle_toggle(do_reversewrap, (int) (term->flags & REVERSEWRAP),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1956 2
a1957 2
    handle_toggle(do_autolinefeed, (int) (term->flags & LINEFEED),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1966 2
a1967 2
    handle_toggle(do_appcursor, (int) (term->keyboard.flags & MODE_DECCKM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1976 2
a1977 2
    handle_toggle(do_appkeypad, (int) (term->keyboard.flags & MODE_DECKPAM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1986 2
a1987 2
    handle_toggle(do_scrollkey, (int) term->screen.scrollkey,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1996 2
a1997 2
    handle_toggle(do_scrollttyoutput, (int) term->screen.scrollttyoutput,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2006 2
a2007 2
    handle_toggle(do_allow132, (int) term->screen.c132,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2016 2
a2017 2
    handle_toggle(do_cursesemul, (int) term->screen.curses,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2026 2
a2027 2
    handle_toggle(do_marginbell, (int) term->screen.marginbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2038 2
a2039 2
    handle_toggle(do_cursorblink, (int) term->screen.cursor_blink,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2050 2
a2051 2
    handle_toggle(do_altscreen, (int) term->screen.alternate,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2061 2
a2062 2
    handle_toggle(do_titeInhibit, !((int) term->misc.titeInhibit),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2102 2
a2103 2
    handle_toggle(do_font_doublesize, (int) term->screen.font_doublesize,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2114 2
a2115 2
    handle_toggle(do_font_boxchars, (int) term->screen.force_box_chars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2126 2
a2127 2
    handle_toggle(do_font_loadable, (int) term->misc.font_loadable,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2138 2
a2139 2
    handle_toggle(do_font_renderfont, term->misc.render_font,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2150 12
a2161 2
    handle_toggle(do_font_utf8_mode, term->screen.utf8_mode,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2202 2
a2203 3
	    handle_toggle(do_vtonoff, (int) term->screen.Vshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d2207 2
a2208 3
	    handle_toggle(do_tekonoff, (int) term->screen.Tshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d2334 2
a2335 1
    XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
d2338 2
a2339 2
static void
SetupShell(Widget *menus, MenuList * shell, Widget *menu_tops, int n, int m)
d2343 2
d2363 15
a2377 9
    menu_tops[n] = XtVaCreateManagedWidget(temp,
					   menuButtonWidgetClass,
					   *menus,
					   XtNfromHoriz, ((m >= 0)
							  ? menu_tops[m]
							  : 0),
					   XtNmenuName, menu_names[n].internal_name,
					   XtNlabel, external_name,
					   (XtPointer) 0);
d2379 1
a2379 2

#endif
d2382 1
a2382 1
SetupMenus(Widget shell, Widget *forms, Widget *menus)
d2385 4
a2388 2
    int n;
    Widget menu_tops[NUM_POPUP_MENUS];
d2393 2
d2413 22
a2434 8
    *menus = XtVaCreateManagedWidget("menubar",
				     boxWidgetClass, *forms,
				     XtNorientation, XtorientHorizontal,
				     XtNtop, XawChainTop,
				     XtNbottom, XawChainTop,
				     XtNleft, XawChainLeft,
				     XtNright, XawChainLeft,
				     (XtPointer) 0);
d2437 3
a2439 2
	for (n = mainMenu; n <= fontMenu; n++) {
	    SetupShell(menus, vt_shell, menu_tops, n, n - 1);
d2444 2
a2445 2
	SetupShell(menus, tek_shell, menu_tops, mainMenu, -1);
	SetupShell(menus, tek_shell, menu_tops, tekMenu, mainMenu);
d2449 8
d2467 15
d2483 4
a2486 2
void
SetupToolbar(Widget shell)
d2488 13
a2500 4
    int n;
    if (shell == toplevel) {	/* vt100 */
	for (n = mainMenu; n <= fontMenu; n++) {
	    InitPopup(vt_shell[n].w, menu_names[n].internal_name, 0);
a2501 1
    }
d2503 10
a2512 3
    else {			/* tek4014 */
	InitPopup(tek_shell[mainMenu].w, menu_names[mainMenu].internal_name, 0);
	InitPopup(tek_shell[tekMenu].w, menu_names[tekMenu].internal_name, 0);
d2514 2
a2515 3
#endif
    term->screen.toolbars = True;
    update_toolbar();
d2521 6
a2526 3
    return ((w == (Widget) term)
	    ? &(WhichVWin(&(term->screen))->tb_info)
	    : &(tekWidget->tek.tb_info));
d2535 5
d2541 3
a2543 1
	    if (XtIsRealized(info->menu_bar))
d2545 1
d2547 1
a2547 3
	XtVaSetValues(w,
		      XtNfromVert, (Widget) 0,
		      (XtPointer) 0);
d2557 1
d2559 3
d2563 3
d2567 1
a2568 3
	XtVaSetValues(w,
		      XtNfromVert, info->menu_bar,
		      (XtPointer) 0);
d2574 1
d2578 3
d2584 4
a2587 3
    if (enable) {
	show_toolbar((Widget) term);
	show_toolbar((Widget) tekWidget);
d2589 15
a2603 2
	hide_toolbar((Widget) term);
	hide_toolbar((Widget) tekWidget);
d2613 6
a2618 2
    handle_toggle(do_toolbar, (int) term->screen.toolbars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d2632 5
a2636 2
    ShowToolbar(term->screen.toolbars = !term->screen.toolbars);
    update_toolbar();
d2644 1
a2644 1
		     term->screen.toolbars);
d2708 8
d2859 8
d2877 1
d2881 1
d2988 19
a3006 3
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_wide_chars].widget,
		     term->screen.utf8_mode);
@


1.1.109.1
log
@Import xterm-215 (latest from Tom Dickey)
XFree86 4.6.0 had xterm-213 with no diffs,
so we only need to care about both obsd and
mbsd local diffs
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.206 2006/04/10 00:34:36 tom Exp $ */
d3 1
d6 1
a6 1
Copyright 1999-2005,2006 by Thomas E. Dickey
d50 1
a50 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.68 2006/04/10 00:34:36 dickey Exp $ */
d127 1
a144 1
static void do_selectClipboard PROTO_XT_CALLBACK_ARGS;
a182 1
static void do_alt_esc         PROTO_XT_CALLBACK_ARGS;
a224 1
static void do_font_utf8_title PROTO_XT_CALLBACK_ARGS;
a247 1
    { "alt-esc",	do_alt_esc,	NULL },
d284 1
a284 1
    { "selectToClipboard",do_selectClipboard, NULL },
a340 1
    { "utf8-title",	do_font_utf8_title,NULL },
d385 1
a385 2
    Widget b;			/* the toolbar's buttons */
    Widget w;			/* the popup shell activated by the button */
a554 1
    TRACE(("domenu(%s) %s\n", params[0], created ? "create" : "update"));
a565 1
	    update_alt_esc();
a568 8
	    if (!xtermHasPrinter()) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_print].widget,
				False);
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_print_redir].widget,
				False);
	    }
a610 1
	    update_selectToClipboard();
d672 4
a675 1
	    update_font_utf8_title();
a705 1
    TRACE(("HandleCreateMenu\n"));
a714 1
    TRACE(("HandlePopupMenu\n"));
d746 7
d766 1
a766 1
	if (XGrabKeyboard(screen->display, XtWindow(CURRENT_EMU(screen)),
a777 20
/* ARGSUSED */
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event GCC_UNUSED,		/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
#if 0
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
#endif
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
}

a888 9
do_alt_esc(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    term->screen.input_eight_bits = !term->screen.input_eight_bits;
    update_alt_esc();
}

static void
a1135 11
do_selectClipboard(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->selectToClipboard = !screen->selectToClipboard;
    update_selectToClipboard();
}

static void
a1174 1
    TRACE(("Show tek-window\n"));
d1306 1
a1306 1
	  XtPointer closure,
d1314 1
a1314 1
	    SetVTFont(term, i, True, NULL);
d1365 1
a1365 1
    String name = term->screen.MenuFontName(fontnum);
d1369 1
a1369 1
    xtermLoadFont(term, xtermFontName(name), True, fontnum);
d1371 2
a1372 2
		MaxRows(screen),
		MaxCols(screen), True);
a1383 13
    /*
     * If xterm was started with -wc option, it might not have the wide fonts.
     * If xterm was not started with -wc, it might not have wide cells.
     */
    if (!screen->utf8_mode) {
	if (screen->wide_chars) {
	    if (xtermLoadWideFonts(term, True)) {
		SetVTFont(term, screen->menu_font_number, TRUE, NULL);
	    }
	} else {
	    ChangeToWide(screen);
	}
    }
d1385 1
a1391 11

static void
do_font_utf8_title(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    screen->utf8_title = !screen->utf8_title;
    update_font_utf8_title();
}
a1460 1
    TRACE(("Show vt-window\n"));
a1562 6
#define handle_vt_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

#define handle_tek_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

d1569 2
a1570 2
    handle_vt_toggle(do_allowsends, term->screen.allowSendEvents,
		     params, *param_count, w);
d1579 2
a1580 2
    handle_vt_toggle(do_visualbell, term->screen.visualbell,
		     params, *param_count, w);
d1589 2
a1590 2
    handle_vt_toggle(do_poponbell, term->screen.poponbell,
		     params, *param_count, w);
d1600 2
a1601 2
    handle_vt_toggle(do_logging, term->screen.logging,
		     params, *param_count, w);
d1696 2
a1697 2
    handle_vt_toggle(do_8bit_control, term->screen.control_eight_bits,
		     params, *param_count, w);
d1706 2
a1707 2
    handle_vt_toggle(do_backarrow, term->keyboard.flags & MODE_DECBKM,
		     params, *param_count, w);
d1716 2
a1717 2
    handle_vt_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		     params, *param_count, w);
d1727 2
a1728 12
    handle_vt_toggle(do_num_lock, term->misc.real_NumLock,
		     params, *param_count, w);
}

void
HandleAltEsc(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params,
	     Cardinal *param_count)
{
    handle_vt_toggle(do_alt_esc, !term->screen.input_eight_bits,
		     params, *param_count, w);
d1737 2
a1738 2
    handle_vt_toggle(do_meta_esc, term->screen.meta_sends_esc,
		     params, *param_count, w);
d1748 2
a1749 2
    handle_vt_toggle(do_delete_del, term->screen.delete_is_del,
		     params, *param_count, w);
d1758 2
a1759 2
    handle_vt_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		     params, *param_count, w);
d1769 2
a1770 2
    handle_vt_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		     params, *param_count, w);
d1781 2
a1782 2
    handle_vt_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		     params, *param_count, w);
d1793 2
a1794 2
    handle_vt_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		     params, *param_count, w);
d1804 2
a1805 6
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_scrollbar, term->screen.fullVwin.sb_info.width,
			 params, *param_count, w);
    }
d1814 2
a1815 12
    handle_vt_toggle(do_jumpscroll, term->screen.jumpscroll,
		     params, *param_count, w);
}

void
HandleSetSelect(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_selectClipboard, term->screen.selectToClipboard,
		     params, *param_count, w);
d1824 2
a1825 2
    handle_vt_toggle(do_reversevideo, (term->misc.re_verse0),
		     params, *param_count, w);
d1834 2
a1835 2
    handle_vt_toggle(do_autowrap, (term->flags & WRAPAROUND),
		     params, *param_count, w);
d1844 2
a1845 2
    handle_vt_toggle(do_reversewrap, (term->flags & REVERSEWRAP),
		     params, *param_count, w);
d1854 2
a1855 2
    handle_vt_toggle(do_autolinefeed, (term->flags & LINEFEED),
		     params, *param_count, w);
d1864 2
a1865 2
    handle_vt_toggle(do_appcursor, (term->keyboard.flags & MODE_DECCKM),
		     params, *param_count, w);
d1874 2
a1875 2
    handle_vt_toggle(do_appkeypad, (term->keyboard.flags & MODE_DECKPAM),
		     params, *param_count, w);
d1884 2
a1885 2
    handle_vt_toggle(do_scrollkey, term->screen.scrollkey,
		     params, *param_count, w);
d1894 2
a1895 2
    handle_vt_toggle(do_scrollttyoutput, term->screen.scrollttyoutput,
		     params, *param_count, w);
d1904 2
a1905 2
    handle_vt_toggle(do_allow132, term->screen.c132,
		     params, *param_count, w);
d1914 2
a1915 2
    handle_vt_toggle(do_cursesemul, term->screen.curses,
		     params, *param_count, w);
d1924 2
a1925 2
    handle_vt_toggle(do_marginbell, term->screen.marginbell,
		     params, *param_count, w);
d1936 2
a1937 2
    handle_vt_toggle(do_cursorblink, term->screen.cursor_blink,
		     params, *param_count, w);
d1948 2
a1949 2
    handle_vt_toggle(do_altscreen, term->screen.alternate,
		     params, *param_count, w);
d1959 2
a1960 2
    handle_vt_toggle(do_titeInhibit, !(term->misc.titeInhibit),
		     params, *param_count, w);
d2000 2
a2001 2
    handle_vt_toggle(do_font_doublesize, term->screen.font_doublesize,
		     params, *param_count, w);
d2012 2
a2013 2
    handle_vt_toggle(do_font_boxchars, term->screen.force_box_chars,
		     params, *param_count, w);
d2024 2
a2025 2
    handle_vt_toggle(do_font_loadable, term->misc.font_loadable,
		     params, *param_count, w);
d2036 2
a2037 2
    handle_vt_toggle(do_font_renderfont, term->misc.render_font,
		     params, *param_count, w);
d2048 2
a2049 12
    handle_vt_toggle(do_font_utf8_mode, term->screen.utf8_mode,
		     params, *param_count, w);
}

void
HandleUTF8Title(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_font_utf8_title, term->screen.utf8_title,
		     params, *param_count, w);
d2090 3
a2092 2
	    handle_tek_toggle(do_vtonoff, (int) term->screen.Vshow,
			      params + 1, (*param_count) - 1, w);
d2096 3
a2098 2
	    handle_tek_toggle(do_tekonoff, (int) term->screen.Tshow,
			      params + 1, (*param_count) - 1, w);
d2224 1
a2224 2
    if (gw)
	XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
d2227 2
a2228 2
static Dimension
SetupShell(Widget *menus, MenuList * shell, int n, int m)
a2231 2
    Dimension button_height;
    Dimension button_border;
d2250 10
a2259 13
    shell[n].b = XtVaCreateManagedWidget(temp,
					 menuButtonWidgetClass,
					 *menus,
					 XtNfromHoriz, ((m >= 0)
							? shell[m].b
							: 0),
					 XtNmenuName, menu_names[n].internal_name,
					 XtNlabel, external_name,
					 (XtPointer) 0);
    XtVaGetValues(shell[n].b,
		  XtNheight, &button_height,
		  XtNborderWidth, &button_border,
		  (XtPointer) 0);
d2261 1
a2261 3
    return button_height + (button_border * 2);
}
#endif /* OPT_TOOLBAR */
d2264 1
a2264 1
SetupMenus(Widget shell, Widget *forms, Widget *menus, Dimension * menu_high)
d2267 2
a2268 4
    Dimension button_height;
    Dimension toolbar_hSpace;
    Dimension toolbar_border;
    Arg args[10];
a2272 2
    *menu_high = 0;

d2291 8
a2298 22
    XtSetArg(args[0], XtNorientation, XtorientHorizontal);
    XtSetArg(args[1], XtNtop, XawChainTop);
    XtSetArg(args[2], XtNbottom, XawChainTop);
    XtSetArg(args[3], XtNleft, XawChainLeft);
    XtSetArg(args[4], XtNright, XawChainLeft);

    if (resource.toolBar) {
	*menus = XtCreateManagedWidget("menubar", boxWidgetClass, *forms,
				       args, 5);
    } else {
	*menus = XtCreateWidget("menubar", boxWidgetClass, *forms, args, 5);
    }

    /*
     * The toolbar widget's height is not necessarily known yet.  If the
     * toolbar is not created as a managed widget, we can still make a good
     * guess about its height by collecting the widget's other resource values.
     */
    XtVaGetValues(*menus,
		  XtNhSpace, &toolbar_hSpace,
		  XtNborderWidth, &toolbar_border,
		  (XtPointer) 0);
d2301 2
a2302 3
	int j;
	for (j = mainMenu; j <= fontMenu; j++) {
	    button_height = SetupShell(menus, vt_shell, j, j - 1);
d2307 2
a2308 2
	button_height = SetupShell(menus, tek_shell, mainMenu, -1);
	button_height = SetupShell(menus, tek_shell, tekMenu, mainMenu);
a2311 8
    /*
     * Tell the main program how high the toolbar is, to help with the initial
     * layout.
     */
    *menu_high = (button_height + 2 * (toolbar_hSpace + toolbar_border));
    TRACE(("...menuHeight:%d = (%d + 2 * (%d + %d))\n",
	   *menu_high, button_height, toolbar_hSpace, toolbar_border));

d2322 1
d2324 1
a2324 1
repairSizeHints(void)
d2326 5
a2330 9
    TScreen *screen = &term->screen;

    XSizeHints sizehints;

    if (XtIsRealized((Widget) term)) {
	bzero(&sizehints, sizeof(sizehints));
	xtermSizeHints(term, &sizehints, ScrollbarWidth(screen));

	XSetWMNormalHints(screen->display, XtWindow(SHELL_OF(term)), &sizehints);
a2331 22
}

#if OPT_TOOLBAR
#define INIT_POPUP(s, n) InitPopup(s[n].w, menu_names[n].internal_name, 0)

static Bool
InitWidgetMenu(Widget shell)
{
    Bool result = False;

    TRACE(("InitWidgetMenu(%p)\n", shell));
    if (term != 0) {
	if (shell == toplevel) {	/* vt100 */
	    if (!term->init_vt_menu) {
		INIT_POPUP(vt_shell, mainMenu);
		INIT_POPUP(vt_shell, vtMenu);
		INIT_POPUP(vt_shell, fontMenu);
		term->init_vt_menu = True;
		TRACE(("...InitWidgetMenu(vt)\n"));
	    }
	    result = term->init_vt_menu;
	}
d2333 4
a2336 9
	else if (tekWidget) {	/* tek4014 */
	    if (!term->init_tek_menu) {
		INIT_POPUP(tek_shell, mainMenu);
		INIT_POPUP(tek_shell, tekMenu);
		term->init_tek_menu = True;
		TRACE(("...InitWidgetMenu(tek)\n"));
	    }
	    result = term->init_tek_menu;
	}
d2338 2
a2339 3
    }
    TRACE(("...InitWidgetMenu ->%d\n", result));
    return result;
d2345 3
a2347 6
    TRACE(("...getting toolbar_info\n"));
#if OPT_TEK4014
    if (w != (Widget) term)
	return &(tekWidget->tek.tb_info);
#endif
    return &(WhichVWin(&(term->screen))->tb_info);
d2356 4
a2359 1
	TRACE(("hiding toolbar\n"));
a2362 9

	if (info->menu_bar != 0) {
	    repairSizeHints();
	    XtUnmanageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
		XtUnmapWidget(info->menu_bar);
	    }
	}
	TRACE(("...hiding toolbar (done)\n"));
a2371 1
	TRACE(("showing toolbar\n"));
a2372 3
	    XtVaSetValues(w,
			  XtNfromVert, info->menu_bar,
			  (XtPointer) 0);
a2373 3
		repairSizeHints();
	    XtManageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
a2374 1
	    }
d2376 3
a2383 1
	TRACE(("...showing toolbar (done)\n"));
a2386 3
/*
 * Make the toolbar visible or invisible in the current window(s).
 */
d2390 3
a2392 4
    TRACE(("ShowToolbar(%d)\n", enable));

    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
d2394 2
a2395 15
	if (enable) {
	    if (InitWidgetMenu(toplevel))
		show_toolbar((Widget) term);
#if OPT_TEK4014
	    if (InitWidgetMenu(tekshellwidget))
		show_toolbar((Widget) tekWidget);
#endif
	} else {
	    hide_toolbar((Widget) term);
#if OPT_TEK4014
	    hide_toolbar((Widget) tekWidget);
#endif
	}
	resource.toolBar = enable;
	update_toolbar();
d2405 2
a2406 6
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_toolbar, resource.toolBar,
			 params, *param_count, w);
    }
d2420 2
a2421 5
    if (IsIcon(&(term->screen))) {
	Bell(XkbBI_MinorError, 0);
    } else {
	ShowToolbar(resource.toolBar = !resource.toolBar);
    }
d2429 1
a2429 1
		     resource.toolBar);
a2492 8
update_alt_esc(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_alt_esc].widget,
		     !term->screen.input_eight_bits);
}

void
a2635 8
update_selectToClipboard(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_selectToClipboard].widget,
		     term->screen.selectToClipboard);
}

void
a2645 1
#if 0				/* 2006-2-12: no longer menu entry */
a2648 1
#endif
d2755 3
a2757 19
    Widget iw = fontMenuEntries[fontMenu_wide_chars].widget;
    Bool active = (term->screen.utf8_mode != uAlways);
    Bool enable = (term->screen.utf8_mode != uFalse);

    TRACE(("update_font_utf8_mode active %d, enable %d\n", active, enable));
    set_sensitivity(term->screen.fontMenu, iw, active);
    update_menu_item(term->screen.fontMenu, iw, enable);
}

void
update_font_utf8_title(void)
{
    Widget iw = fontMenuEntries[fontMenu_wide_title].widget;
    Bool active = (term->screen.utf8_mode != uFalse);
    Bool enable = (term->screen.utf8_title);

    TRACE(("update_font_utf8_title active %d, enable %d\n", active, enable));
    set_sensitivity(term->screen.fontMenu, iw, active);
    update_menu_item(term->screen.fontMenu, iw, enable);
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
