head	1.3;
access;
symbols
	MIRBSD_10_BASE:1.3
	tg-xterm-215-based:1.2.0.2
	tg-xterm-200-based:1.1
	xterm-215:1.1.109.1
	lynx:1.1.109
	MIRBSD_9_BASE:1.1.103.1
	MIRBSD_8:1.1.103.1.0.2
	MIRBSD_8_BASE:1.1.103.1
	xf-4_5_0:1.1.103.1
	xwindow:1.1.103;
locks; strict;
comment	@ * @;


1.3
date	2006.07.02.00.54.53;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044A719405F9E103E;

1.2
date	2006.07.02.00.02.50;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044A70D294F0BB63C;

1.1
date	2005.03.18.10.52.33;	author tg;	state Exp;
branches
	1.1.103.1
	1.1.109.1;
next	;

1.1.103.1
date	2005.03.18.10.52.33;	author tg;	state Exp;
branches;
next	;

1.1.109.1
date	2006.07.01.23.27.05;	author tg;	state Exp;
branches;
next	;
commitid	10044A704BD2A6243A3;


desc
@@


1.3
log
@revert to xterm-200-based (plus fix an openbsd glitch)
xterm-215-based does not work correctly:
* uxterm does not honour its class (e.g. my font is too small)
* utmp is never updated
@
text
@/*
 *	$XFree86: xc/programs/xterm/tabs.c,v 3.11 2005/01/14 01:50:03 dickey Exp $
 */

/* $Xorg: tabs.c,v 1.3 2000/08/17 19:55:09 cpqbld Exp $ */

/*
 * Copyright 2000-2002,2005 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* tabs.c */

#include <xterm.h>
#include <data.h>

/*
 * This file presumes 32bits/word.  This is somewhat of a crock, and should
 * be fixed sometime.
 */
#define TAB_INDEX(n) ((n) >> 5)
#define TAB_MASK(n)  (1 << ((n) & (TAB_BITS_WIDTH-1)))

#define SET_TAB(tabs,n) tabs[TAB_INDEX(n)] |=  TAB_MASK(n)
#define CLR_TAB(tabs,n) tabs[TAB_INDEX(n)] &= ~TAB_MASK(n)
#define TST_TAB(tabs,n) tabs[TAB_INDEX(n)] &   TAB_MASK(n)

/*
 * places tabstops at only every 8 columns
 */
void
TabReset(Tabs tabs)
{
    int i;

    for (i = 0; i < TAB_ARRAY_SIZE; ++i)
	tabs[i] = 0;

    for (i = 0; i < MAX_TABS; i += 8)
	TabSet(tabs, i);
}

/*
 * places a tabstop at col
 */
void
TabSet(Tabs tabs, int col)
{
    SET_TAB(tabs, col);
}

/*
 * clears a tabstop at col
 */
void
TabClear(Tabs tabs, int col)
{
    CLR_TAB(tabs, col);
}

/*
 * returns the column of the next tabstop
 * (or MAX_TABS - 1 if there are no more).
 * A tabstop at col is ignored.
 */
int
TabNext(Tabs tabs, int col)
{
    TScreen *screen = &term->screen;

    if (screen->curses && screen->do_wrap && (term->flags & WRAPAROUND)) {
	xtermIndex(screen, 1);
	col = screen->cur_col = screen->do_wrap = 0;
    }
    for (++col; col < MAX_TABS; ++col)
	if (TST_TAB(tabs, col))
	    return (col);

    return (MAX_TABS - 1);
}

/*
 * returns the column of the previous tabstop
 * (or 0 if there are no more).
 * A tabstop at col is ignored.
 */
int
TabPrev(Tabs tabs, int col)
{
    for (--col; col >= 0; --col)
	if (TST_TAB(tabs, col))
	    return (col);

    return (0);
}

/*
 * Tab to the next stop, returning true if the cursor moved
 */
Bool
TabToNextStop(void)
{
    TScreen *screen = &term->screen;
    int saved_column = screen->cur_col;

    screen->cur_col = TabNext(term->tabs, screen->cur_col);
    if (screen->cur_col > CurMaxCol(screen, screen->cur_row))
	screen->cur_col = CurMaxCol(screen, screen->cur_row);

    return (screen->cur_col > saved_column);
}

/*
 * Tab to the previous stop, returning true if the cursor moved
 */
Bool
TabToPrevStop(void)
{
    TScreen *screen = &term->screen;
    int saved_column = screen->cur_col;

    screen->cur_col = TabPrev(term->tabs, screen->cur_col);

    return (screen->cur_col < saved_column);
}

/*
 * clears all tabs
 */
void
TabZonk(Tabs tabs)
{
    int i;

    for (i = 0; i < TAB_ARRAY_SIZE; ++i)
	tabs[i] = 0;
}
@


1.2
log
@merge and go back to xterm-215
@
text
@a0 2
/* $XTermId: tabs.c,v 1.26 2006/02/13 01:14:59 tom Exp $ */

d2 1
a2 1
 *	$XFree86: xc/programs/xterm/tabs.c,v 3.14 2006/02/13 01:14:59 dickey Exp $
d5 2
d8 1
a8 1
 * Copyright 2000-2005,2006 by Thomas E. Dickey
d112 2
a113 2
static int
TabNext(TScreen * screen, Tabs tabs, int col)
d115 2
d119 1
a119 2
	set_cur_col(screen, 0);
	col = screen->do_wrap = 0;
d133 1
a133 1
static int
d147 1
a147 1
TabToNextStop(TScreen * screen)
d149 1
a150 2
    int next = TabNext(screen, term->tabs, screen->cur_col);
    int max = CurMaxCol(screen, screen->cur_row);
d152 3
a154 3
    if (next > max)
	next = max;
    set_cur_col(screen, next);
d163 1
a163 1
TabToPrevStop(TScreen * screen)
d165 1
d168 1
a168 1
    set_cur_col(screen, TabPrev(term->tabs, screen->cur_col));
@


1.1
log
@Initial revision
@
text
@d1 2
d4 1
a4 1
 *	$XFree86: xc/programs/xterm/tabs.c,v 3.11 2005/01/14 01:50:03 dickey Exp $
a6 2
/* $Xorg: tabs.c,v 1.3 2000/08/17 19:55:09 cpqbld Exp $ */

d8 1
a8 1
 * Copyright 2000-2002,2005 by Thomas E. Dickey
d112 2
a113 2
int
TabNext(Tabs tabs, int col)
a114 2
    TScreen *screen = &term->screen;

d117 2
a118 1
	col = screen->cur_col = screen->do_wrap = 0;
d132 1
a132 1
int
d146 1
a146 1
TabToNextStop(void)
a147 1
    TScreen *screen = &term->screen;
d149 2
d152 3
a154 3
    screen->cur_col = TabNext(term->tabs, screen->cur_col);
    if (screen->cur_col > CurMaxCol(screen, screen->cur_row))
	screen->cur_col = CurMaxCol(screen, screen->cur_row);
d163 1
a163 1
TabToPrevStop(void)
a164 1
    TScreen *screen = &term->screen;
d167 1
a167 1
    screen->cur_col = TabPrev(term->tabs, screen->cur_col);
@


1.1.109.1
log
@Import xterm-215 (latest from Tom Dickey)
XFree86 4.6.0 had xterm-213 with no diffs,
so we only need to care about both obsd and
mbsd local diffs
@
text
@a0 2
/* $XTermId: tabs.c,v 1.26 2006/02/13 01:14:59 tom Exp $ */

d2 1
a2 1
 *	$XFree86: xc/programs/xterm/tabs.c,v 3.14 2006/02/13 01:14:59 dickey Exp $
d5 2
d8 1
a8 1
 * Copyright 2000-2005,2006 by Thomas E. Dickey
d112 2
a113 2
static int
TabNext(TScreen * screen, Tabs tabs, int col)
d115 2
d119 1
a119 2
	set_cur_col(screen, 0);
	col = screen->do_wrap = 0;
d133 1
a133 1
static int
d147 1
a147 1
TabToNextStop(TScreen * screen)
d149 1
a150 2
    int next = TabNext(screen, term->tabs, screen->cur_col);
    int max = CurMaxCol(screen, screen->cur_row);
d152 3
a154 3
    if (next > max)
	next = max;
    set_cur_col(screen, next);
d163 1
a163 1
TabToPrevStop(TScreen * screen)
d165 1
d168 1
a168 1
    set_cur_col(screen, TabPrev(term->tabs, screen->cur_col));
@


1.1.103.1
log
@Import XFree86 4.5.0 directly from vendor anoncvs, -rxf-4_5_0 xc
at anoncvs@@anoncvs.xfree86.org:/cvs (ssh)
@
text
@@
